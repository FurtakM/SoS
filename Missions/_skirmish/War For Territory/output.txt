// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 219 0 0
// if debug then
   8: LD_EXP 1
  12: IFFALSE 21
// begin FogOff ( 1 ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 344
// end ; ChangeSideFog ( 4 , 1 ) ;
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: CALL_OW 343
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 3
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: LD_INT 0
  45: PPUSH
  46: LD_INT 0
  48: PPUSH
  49: LD_INT 0
  51: PPUSH
  52: LD_INT 7
  54: PPUSH
  55: LD_INT 0
  57: PPUSH
  58: CALL 37114 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 3
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 4
  85: PPUSH
  86: LD_INT 0
  88: PPUSH
  89: CALL 37114 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
  93: LD_INT 0
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 3
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 11
 116: PPUSH
 117: LD_INT 0
 119: PPUSH
 120: CALL 37114 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 3
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 14
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: CALL 37114 0 9
// PrepareGensher ;
 155: CALL 1370 0 0
// PreparePopov ;
 159: CALL 2620 0 0
// PreparePowell ;
 163: CALL 433 0 0
// uc_side := 1 ;
 167: LD_ADDR_OWVAR 20
 171: PUSH
 172: LD_INT 1
 174: ST_TO_ADDR
// uc_nation := 1 ;
 175: LD_ADDR_OWVAR 21
 179: PUSH
 180: LD_INT 1
 182: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
 183: LD_INT 0
 185: PPUSH
 186: LD_INT 5
 188: PPUSH
 189: LD_INT 10
 191: PPUSH
 192: CALL_OW 380
// PlaceUnitXY ( CreateHuman , 178 , 113 , false ) ;
 196: CALL_OW 44
 200: PPUSH
 201: LD_INT 178
 203: PPUSH
 204: LD_INT 113
 206: PPUSH
 207: LD_INT 0
 209: PPUSH
 210: CALL_OW 48
// MC_Start ( ) ;
 214: CALL 43423 0 0
// end ;
 218: END
// export debug , game , staticMines ; function InitVariables ; begin
 219: LD_INT 0
 221: PPUSH
// debug := 0 ;
 222: LD_ADDR_EXP 1
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// game := true ;
 230: LD_ADDR_EXP 2
 234: PUSH
 235: LD_INT 1
 237: ST_TO_ADDR
// staticMines := [ ] ;
 238: LD_ADDR_EXP 3
 242: PUSH
 243: EMPTY
 244: ST_TO_ADDR
// end ;
 245: LD_VAR 0 1
 249: RET
// export function CustomInitMacro ; begin
 250: LD_INT 0
 252: PPUSH
// InitMC_Gensher ( ) ;
 253: CALL 1758 0 0
// InitMC_Powell ( ) ;
 257: CALL 648 0 0
// InitMC_Popov ( ) ;
 261: CALL 2946 0 0
// end ;
 265: LD_VAR 0 1
 269: RET
// every 0 0$10 do var cr , time , i ;
 270: GO 272
 272: DISABLE
 273: LD_INT 0
 275: PPUSH
 276: PPUSH
 277: PPUSH
// begin time := 0 0$30 ;
 278: LD_ADDR_VAR 0 2
 282: PUSH
 283: LD_INT 1050
 285: ST_TO_ADDR
// repeat wait ( time ) ;
 286: LD_VAR 0 2
 290: PPUSH
 291: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 295: LD_ADDR_VAR 0 1
 299: PUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 5
 305: PPUSH
 306: CALL_OW 12
 310: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 311: LD_ADDR_VAR 0 3
 315: PUSH
 316: LD_INT 5
 318: PUSH
 319: LD_INT 8
 321: PUSH
 322: LD_INT 12
 324: PUSH
 325: LD_INT 13
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: PUSH
 334: FOR_IN
 335: IFFALSE 389
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 337: LD_VAR 0 3
 341: PPUSH
 342: LD_INT 1
 344: PPUSH
 345: CALL_OW 287
 349: PUSH
 350: LD_INT 20
 352: LESS
 353: IFFALSE 372
// CreateCratesArea ( cr , i , true ) ;
 355: LD_VAR 0 1
 359: PPUSH
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 372: LD_INT 175
 374: PPUSH
 375: LD_INT 700
 377: PPUSH
 378: CALL_OW 12
 382: PPUSH
 383: CALL_OW 67
// end ;
 387: GO 334
 389: POP
 390: POP
// time := time + 0 0$2 ;
 391: LD_ADDR_VAR 0 2
 395: PUSH
 396: LD_VAR 0 2
 400: PUSH
 401: LD_INT 70
 403: PLUS
 404: ST_TO_ADDR
// if time > 1 1$00 then
 405: LD_VAR 0 2
 409: PUSH
 410: LD_INT 2100
 412: GREATER
 413: IFFALSE 423
// time := 0 0$25 ;
 415: LD_ADDR_VAR 0 2
 419: PUSH
 420: LD_INT 875
 422: ST_TO_ADDR
// until not game ;
 423: LD_EXP 2
 427: NOT
 428: IFFALSE 286
// end ; end_of_file
 430: PPOPN 3
 432: END
// export Powell , powell_side ; export function PreparePowell ; var i , tmp ; begin
 433: LD_INT 0
 435: PPUSH
 436: PPUSH
 437: PPUSH
// powell_side := 4 ;
 438: LD_ADDR_EXP 5
 442: PUSH
 443: LD_INT 4
 445: ST_TO_ADDR
// uc_side := powell_side ;
 446: LD_ADDR_OWVAR 20
 450: PUSH
 451: LD_EXP 5
 455: ST_TO_ADDR
// uc_nation := 1 ;
 456: LD_ADDR_OWVAR 21
 460: PUSH
 461: LD_INT 1
 463: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 464: LD_ADDR_EXP 4
 468: PUSH
 469: LD_STRING Powell
 471: PPUSH
 472: CALL_OW 25
 476: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 477: LD_EXP 4
 481: PPUSH
 482: LD_INT 1
 484: PPUSH
 485: LD_INT 7
 487: PPUSH
 488: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 492: LD_EXP 4
 496: PPUSH
 497: LD_INT 2
 499: PPUSH
 500: LD_INT 5
 502: PPUSH
 503: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 507: LD_EXP 4
 511: PPUSH
 512: LD_INT 3
 514: PPUSH
 515: LD_INT 6
 517: PPUSH
 518: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 522: LD_EXP 4
 526: PPUSH
 527: LD_INT 4
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 537: LD_EXP 4
 541: PPUSH
 542: LD_INT 4
 544: PPUSH
 545: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1000 , 100 , 0 ] , [ 4 , 4 , 4 , 4 ] ) ;
 549: LD_ADDR_VAR 0 3
 553: PUSH
 554: LD_INT 4
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: LD_STRING 
 562: PPUSH
 563: LD_INT 8
 565: PUSH
 566: LD_INT 7
 568: PUSH
 569: LD_INT 6
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_OWVAR 67
 581: ARRAY
 582: PPUSH
 583: LD_INT 1000
 585: PUSH
 586: LD_INT 100
 588: PUSH
 589: LD_INT 0
 591: PUSH
 592: EMPTY
 593: LIST
 594: LIST
 595: LIST
 596: PPUSH
 597: LD_INT 4
 599: PUSH
 600: LD_INT 4
 602: PUSH
 603: LD_INT 4
 605: PUSH
 606: LD_INT 4
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: LIST
 614: PPUSH
 615: CALL 12732 0 6
 619: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 620: LD_ADDR_EXP 14
 624: PUSH
 625: LD_EXP 14
 629: PPUSH
 630: LD_INT 1
 632: PPUSH
 633: LD_VAR 0 3
 637: PPUSH
 638: CALL_OW 1
 642: ST_TO_ADDR
// end ;
 643: LD_VAR 0 1
 647: RET
// export function InitMC_Powell ( ) ; begin
 648: LD_INT 0
 650: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 651: LD_INT 1
 653: PPUSH
 654: LD_INT 1
 656: PPUSH
 657: CALL 66263 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 661: LD_INT 1
 663: PPUSH
 664: LD_INT 6
 666: PPUSH
 667: CALL 66207 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 671: LD_INT 1
 673: PPUSH
 674: LD_INT 167
 676: PUSH
 677: LD_INT 102
 679: PUSH
 680: LD_INT 0
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: LD_INT 173
 690: PUSH
 691: LD_INT 83
 693: PUSH
 694: LD_INT 1
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 171
 704: PUSH
 705: LD_INT 141
 707: PUSH
 708: LD_INT 0
 710: PUSH
 711: EMPTY
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 178
 718: PUSH
 719: LD_INT 148
 721: PUSH
 722: LD_INT 1
 724: PUSH
 725: EMPTY
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PPUSH
 736: CALL 65266 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 740: LD_INT 1
 742: PPUSH
 743: LD_INT 11
 745: PUSH
 746: LD_INT 6
 748: PUSH
 749: LD_INT 7
 751: PUSH
 752: LD_INT 9
 754: PUSH
 755: LD_INT 10
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: PPUSH
 765: CALL 66095 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 5
 774: PPUSH
 775: CALL 65777 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 779: LD_INT 1
 781: PPUSH
 782: LD_INT 4
 784: PPUSH
 785: CALL 65508 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 789: LD_INT 1
 791: PPUSH
 792: LD_INT 4
 794: PPUSH
 795: CALL 65127 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 799: LD_INT 1
 801: PPUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 1
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 5
 813: PUSH
 814: EMPTY
 815: LIST
 816: LIST
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 4
 822: PUSH
 823: LD_INT 1
 825: PUSH
 826: LD_INT 2
 828: PUSH
 829: LD_INT 6
 831: PUSH
 832: EMPTY
 833: LIST
 834: LIST
 835: LIST
 836: LIST
 837: PUSH
 838: LD_INT 4
 840: PUSH
 841: LD_INT 1
 843: PUSH
 844: LD_INT 2
 846: PUSH
 847: LD_INT 7
 849: PUSH
 850: EMPTY
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: PUSH
 856: LD_INT 4
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 2
 864: PUSH
 865: LD_INT 6
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_INT 5
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 2
 882: PUSH
 883: LD_INT 6
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: PPUSH
 899: CALL 64942 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 197 , 144 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] ] ) ;
 903: LD_INT 1
 905: PPUSH
 906: LD_INT 6
 908: PUSH
 909: LD_INT 200
 911: PUSH
 912: LD_INT 111
 914: PUSH
 915: LD_INT 4
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: PUSH
 924: LD_INT 29
 926: PUSH
 927: LD_INT 167
 929: PUSH
 930: LD_INT 102
 932: PUSH
 933: LD_INT 0
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PUSH
 942: LD_INT 4
 944: PUSH
 945: LD_INT 178
 947: PUSH
 948: LD_INT 117
 950: PUSH
 951: LD_INT 2
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 2
 962: PUSH
 963: LD_INT 197
 965: PUSH
 966: LD_INT 144
 968: PUSH
 969: LD_INT 4
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 27
 980: PUSH
 981: LD_INT 206
 983: PUSH
 984: LD_INT 124
 986: PUSH
 987: LD_INT 3
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 27
 998: PUSH
 999: LD_INT 209
1001: PUSH
1002: LD_INT 128
1004: PUSH
1005: LD_INT 3
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 27
1016: PUSH
1017: LD_INT 211
1019: PUSH
1020: LD_INT 132
1022: PUSH
1023: LD_INT 3
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: LD_INT 30
1034: PUSH
1035: LD_INT 173
1037: PUSH
1038: LD_INT 83
1040: PUSH
1041: LD_INT 3
1043: PUSH
1044: EMPTY
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: PUSH
1050: LD_INT 6
1052: PUSH
1053: LD_INT 186
1055: PUSH
1056: LD_INT 103
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: EMPTY
1063: LIST
1064: LIST
1065: LIST
1066: LIST
1067: PUSH
1068: LD_INT 33
1070: PUSH
1071: LD_INT 173
1073: PUSH
1074: LD_INT 99
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PUSH
1086: LD_INT 32
1088: PUSH
1089: LD_INT 174
1091: PUSH
1092: LD_INT 102
1094: PUSH
1095: LD_INT 2
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: PUSH
1104: LD_INT 32
1106: PUSH
1107: LD_INT 178
1109: PUSH
1110: LD_INT 100
1112: PUSH
1113: LD_INT 2
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 33
1124: PUSH
1125: LD_INT 174
1127: PUSH
1128: LD_INT 108
1130: PUSH
1131: LD_INT 1
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 33
1142: PUSH
1143: LD_INT 182
1145: PUSH
1146: LD_INT 122
1148: PUSH
1149: LD_INT 1
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 36
1160: PUSH
1161: LD_INT 194
1163: PUSH
1164: LD_INT 124
1166: PUSH
1167: LD_INT 5
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 28
1178: PUSH
1179: LD_INT 204
1181: PUSH
1182: LD_INT 133
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 201
1199: PUSH
1200: LD_INT 133
1202: PUSH
1203: LD_INT 3
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 28
1214: PUSH
1215: LD_INT 199
1217: PUSH
1218: LD_INT 119
1220: PUSH
1221: LD_INT 5
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 33
1232: PUSH
1233: LD_INT 184
1235: PUSH
1236: LD_INT 141
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 33
1250: PUSH
1251: LD_INT 183
1253: PUSH
1254: LD_INT 131
1256: PUSH
1257: LD_INT 2
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PPUSH
1288: CALL 64834 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1292: LD_INT 1
1294: PPUSH
1295: LD_INT 10
1297: PUSH
1298: LD_INT 15
1300: PUSH
1301: LD_INT 12
1303: PUSH
1304: LD_INT 11
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PPUSH
1313: CALL 65684 0 2
// MC_SetFactoryExtension ( 1 , 197 , 144 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1317: LD_INT 1
1319: PPUSH
1320: LD_INT 197
1322: PPUSH
1323: LD_INT 144
1325: PPUSH
1326: LD_INT 4
1328: PPUSH
1329: LD_INT 19
1331: PUSH
1332: LD_INT 16
1334: PUSH
1335: LD_INT 17
1337: PUSH
1338: LD_INT 18
1340: PUSH
1341: LD_INT 22
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: PPUSH
1351: CALL 65889 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1355: LD_INT 1
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL 65557 0 2
// end ; end_of_file
1365: LD_VAR 0 1
1369: RET
// export Gensher , gensher_side ; export function PrepareGensher ; var i , tmp , un ; begin
1370: LD_INT 0
1372: PPUSH
1373: PPUSH
1374: PPUSH
1375: PPUSH
// gensher_side := 2 ;
1376: LD_ADDR_EXP 7
1380: PUSH
1381: LD_INT 2
1383: ST_TO_ADDR
// uc_side := gensher_side ;
1384: LD_ADDR_OWVAR 20
1388: PUSH
1389: LD_EXP 7
1393: ST_TO_ADDR
// uc_nation := 2 ;
1394: LD_ADDR_OWVAR 21
1398: PUSH
1399: LD_INT 2
1401: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
1402: LD_ADDR_VAR 0 3
1406: PUSH
1407: LD_INT 7
1409: PPUSH
1410: LD_INT 2
1412: PPUSH
1413: LD_STRING 
1415: PPUSH
1416: LD_INT 8
1418: PUSH
1419: LD_INT 7
1421: PUSH
1422: LD_INT 6
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: PUSH
1430: LD_OWVAR 67
1434: ARRAY
1435: PPUSH
1436: LD_INT 1500
1438: PUSH
1439: LD_INT 300
1441: PUSH
1442: LD_INT 30
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: LIST
1449: PPUSH
1450: LD_INT 4
1452: PUSH
1453: LD_INT 4
1455: PUSH
1456: LD_INT 4
1458: PUSH
1459: LD_INT 4
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: PPUSH
1468: CALL 12732 0 6
1472: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
1473: LD_ADDR_EXP 14
1477: PUSH
1478: LD_EXP 14
1482: PPUSH
1483: LD_INT 2
1485: PPUSH
1486: LD_VAR 0 3
1490: PPUSH
1491: CALL_OW 1
1495: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
1496: LD_ADDR_VAR 0 3
1500: PUSH
1501: LD_INT 22
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: PUSH
1511: LD_INT 30
1513: PUSH
1514: LD_INT 31
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: PUSH
1521: EMPTY
1522: LIST
1523: LIST
1524: PPUSH
1525: CALL_OW 69
1529: ST_TO_ADDR
// for i in tmp do
1530: LD_ADDR_VAR 0 2
1534: PUSH
1535: LD_VAR 0 3
1539: PUSH
1540: FOR_IN
1541: IFFALSE 1611
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
1543: LD_INT 0
1545: PPUSH
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 4
1551: PUSH
1552: LD_INT 3
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: EMPTY
1559: LIST
1560: LIST
1561: LIST
1562: PUSH
1563: LD_OWVAR 67
1567: ARRAY
1568: PPUSH
1569: CALL_OW 380
// un := CreateHuman ;
1573: LD_ADDR_VAR 0 4
1577: PUSH
1578: CALL_OW 44
1582: ST_TO_ADDR
// SetDir ( un , 1 ) ;
1583: LD_VAR 0 4
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
1595: LD_VAR 0 4
1599: PPUSH
1600: LD_VAR 0 2
1604: PPUSH
1605: CALL_OW 52
// end ;
1609: GO 1540
1611: POP
1612: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
1613: LD_ADDR_VAR 0 3
1617: PUSH
1618: LD_INT 15
1620: PPUSH
1621: LD_INT 0
1623: PPUSH
1624: CALL_OW 517
1628: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: LD_INT 1
1646: ARRAY
1647: PUSH
1648: FOR_TO
1649: IFFALSE 1751
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
1651: LD_VAR 0 3
1655: PUSH
1656: LD_INT 1
1658: ARRAY
1659: PUSH
1660: LD_VAR 0 2
1664: ARRAY
1665: PPUSH
1666: LD_VAR 0 3
1670: PUSH
1671: LD_INT 2
1673: ARRAY
1674: PUSH
1675: LD_VAR 0 2
1679: ARRAY
1680: PPUSH
1681: LD_INT 2
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
1691: LD_ADDR_EXP 3
1695: PUSH
1696: LD_EXP 3
1700: PPUSH
1701: LD_EXP 3
1705: PUSH
1706: LD_INT 1
1708: PLUS
1709: PPUSH
1710: LD_VAR 0 3
1714: PUSH
1715: LD_INT 1
1717: ARRAY
1718: PUSH
1719: LD_VAR 0 2
1723: ARRAY
1724: PUSH
1725: LD_VAR 0 3
1729: PUSH
1730: LD_INT 2
1732: ARRAY
1733: PUSH
1734: LD_VAR 0 2
1738: ARRAY
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PPUSH
1744: CALL_OW 2
1748: ST_TO_ADDR
// end ;
1749: GO 1648
1751: POP
1752: POP
// end ;
1753: LD_VAR 0 1
1757: RET
// export function InitMC_Gensher ( ) ; begin
1758: LD_INT 0
1760: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 2
1766: PPUSH
1767: CALL 66263 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
1771: LD_INT 2
1773: PPUSH
1774: LD_INT 9
1776: PPUSH
1777: CALL 66207 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
1781: LD_INT 2
1783: PPUSH
1784: LD_INT 56
1786: PUSH
1787: LD_INT 23
1789: PUSH
1790: LD_INT 0
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: LIST
1797: PUSH
1798: LD_INT 52
1800: PUSH
1801: LD_INT 40
1803: PUSH
1804: LD_INT 1
1806: PUSH
1807: EMPTY
1808: LIST
1809: LIST
1810: LIST
1811: PUSH
1812: EMPTY
1813: LIST
1814: LIST
1815: PPUSH
1816: CALL 65266 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
1820: LD_INT 2
1822: PPUSH
1823: LD_INT 27
1825: PUSH
1826: LD_INT 28
1828: PUSH
1829: EMPTY
1830: LIST
1831: LIST
1832: PPUSH
1833: CALL 66095 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
1837: LD_INT 2
1839: PPUSH
1840: LD_INT 8
1842: PPUSH
1843: CALL 65777 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
1847: LD_INT 2
1849: PPUSH
1850: LD_INT 7
1852: PPUSH
1853: CALL 65508 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
1857: LD_INT 2
1859: PPUSH
1860: LD_INT 4
1862: PPUSH
1863: CALL 65127 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower ] ] ) ;
1867: LD_INT 2
1869: PPUSH
1870: LD_INT 13
1872: PUSH
1873: LD_INT 2
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 31
1881: PUSH
1882: EMPTY
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: PUSH
1888: LD_INT 13
1890: PUSH
1891: LD_INT 2
1893: PUSH
1894: LD_INT 1
1896: PUSH
1897: LD_INT 31
1899: PUSH
1900: EMPTY
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: PUSH
1906: LD_INT 14
1908: PUSH
1909: LD_INT 1
1911: PUSH
1912: LD_INT 2
1914: PUSH
1915: LD_INT 27
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: PUSH
1924: LD_INT 14
1926: PUSH
1927: LD_INT 1
1929: PUSH
1930: LD_INT 2
1932: PUSH
1933: LD_INT 27
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 14
1944: PUSH
1945: LD_INT 1
1947: PUSH
1948: LD_INT 2
1950: PUSH
1951: LD_INT 28
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: PUSH
1960: LD_INT 14
1962: PUSH
1963: LD_INT 1
1965: PUSH
1966: LD_INT 1
1968: PUSH
1969: LD_INT 26
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: LIST
1976: LIST
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PPUSH
1986: CALL 64942 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_lab , 17 , 27 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
1990: LD_INT 2
1992: PPUSH
1993: LD_INT 6
1995: PUSH
1996: LD_INT 13
1998: PUSH
1999: LD_INT 18
2001: PUSH
2002: LD_INT 1
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: PUSH
2011: LD_INT 6
2013: PUSH
2014: LD_INT 17
2016: PUSH
2017: LD_INT 27
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: EMPTY
2024: LIST
2025: LIST
2026: LIST
2027: LIST
2028: PUSH
2029: LD_INT 27
2031: PUSH
2032: LD_INT 17
2034: PUSH
2035: LD_INT 3
2037: PUSH
2038: LD_INT 0
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PUSH
2047: LD_INT 29
2049: PUSH
2050: LD_INT 56
2052: PUSH
2053: LD_INT 23
2055: PUSH
2056: LD_INT 0
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: PUSH
2065: LD_INT 4
2067: PUSH
2068: LD_INT 42
2070: PUSH
2071: LD_INT 29
2073: PUSH
2074: LD_INT 5
2076: PUSH
2077: EMPTY
2078: LIST
2079: LIST
2080: LIST
2081: LIST
2082: PUSH
2083: LD_INT 2
2085: PUSH
2086: LD_INT 11
2088: PUSH
2089: LD_INT 7
2091: PUSH
2092: LD_INT 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: LIST
2099: LIST
2100: PUSH
2101: LD_INT 27
2103: PUSH
2104: LD_INT 20
2106: PUSH
2107: LD_INT 3
2109: PUSH
2110: LD_INT 0
2112: PUSH
2113: EMPTY
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: PUSH
2119: LD_INT 27
2121: PUSH
2122: LD_INT 23
2124: PUSH
2125: LD_INT 3
2127: PUSH
2128: LD_INT 0
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: LIST
2135: LIST
2136: PUSH
2137: LD_INT 27
2139: PUSH
2140: LD_INT 26
2142: PUSH
2143: LD_INT 3
2145: PUSH
2146: LD_INT 0
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: PUSH
2155: LD_INT 32
2157: PUSH
2158: LD_INT 27
2160: PUSH
2161: LD_INT 44
2163: PUSH
2164: LD_INT 5
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: LIST
2171: LIST
2172: PUSH
2173: LD_INT 32
2175: PUSH
2176: LD_INT 41
2178: PUSH
2179: LD_INT 41
2181: PUSH
2182: LD_INT 5
2184: PUSH
2185: EMPTY
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: PUSH
2191: LD_INT 32
2193: PUSH
2194: LD_INT 45
2196: PUSH
2197: LD_INT 24
2199: PUSH
2200: LD_INT 5
2202: PUSH
2203: EMPTY
2204: LIST
2205: LIST
2206: LIST
2207: LIST
2208: PUSH
2209: LD_INT 32
2211: PUSH
2212: LD_INT 48
2214: PUSH
2215: LD_INT 19
2217: PUSH
2218: LD_INT 5
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: LIST
2225: LIST
2226: PUSH
2227: LD_INT 32
2229: PUSH
2230: LD_INT 41
2232: PUSH
2233: LD_INT 3
2235: PUSH
2236: LD_INT 4
2238: PUSH
2239: EMPTY
2240: LIST
2241: LIST
2242: LIST
2243: LIST
2244: PUSH
2245: LD_INT 4
2247: PUSH
2248: LD_INT 44
2250: PUSH
2251: LD_INT 9
2253: PUSH
2254: LD_INT 4
2256: PUSH
2257: EMPTY
2258: LIST
2259: LIST
2260: LIST
2261: LIST
2262: PUSH
2263: LD_INT 30
2265: PUSH
2266: LD_INT 52
2268: PUSH
2269: LD_INT 40
2271: PUSH
2272: LD_INT 3
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: LIST
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: LIST
2295: LIST
2296: LIST
2297: LIST
2298: PPUSH
2299: CALL 64834 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
2303: LD_INT 2
2305: PPUSH
2306: LD_INT 10
2308: PUSH
2309: LD_INT 15
2311: PUSH
2312: LD_INT 13
2314: PUSH
2315: LD_INT 11
2317: PUSH
2318: EMPTY
2319: LIST
2320: LIST
2321: LIST
2322: LIST
2323: PPUSH
2324: CALL 65684 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
2328: LD_INT 2
2330: PPUSH
2331: LD_INT 11
2333: PPUSH
2334: LD_INT 7
2336: PPUSH
2337: LD_INT 2
2339: PPUSH
2340: LD_INT 23
2342: PUSH
2343: LD_INT 16
2345: PUSH
2346: LD_INT 17
2348: PUSH
2349: LD_INT 18
2351: PUSH
2352: LD_INT 22
2354: PUSH
2355: EMPTY
2356: LIST
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: PPUSH
2362: CALL 65889 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
2366: LD_INT 2
2368: PPUSH
2369: LD_INT 0
2371: PPUSH
2372: CALL 65557 0 2
// end ;
2376: LD_VAR 0 1
2380: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
2381: LD_EXP 3
2385: PUSH
2386: LD_INT 15
2388: PPUSH
2389: LD_INT 81
2391: PUSH
2392: LD_INT 2
2394: PUSH
2395: EMPTY
2396: LIST
2397: LIST
2398: PPUSH
2399: CALL_OW 70
2403: AND
2404: IFFALSE 2617
2406: GO 2408
2408: DISABLE
2409: LD_INT 0
2411: PPUSH
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
// begin enable ;
2416: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
2417: LD_ADDR_VAR 0 3
2421: PUSH
2422: LD_INT 15
2424: PPUSH
2425: LD_INT 81
2427: PUSH
2428: LD_INT 2
2430: PUSH
2431: EMPTY
2432: LIST
2433: LIST
2434: PPUSH
2435: CALL_OW 70
2439: ST_TO_ADDR
// if not tmp then
2440: LD_VAR 0 3
2444: NOT
2445: IFFALSE 2449
// exit ;
2447: GO 2617
// for i in tmp do
2449: LD_ADDR_VAR 0 1
2453: PUSH
2454: LD_VAR 0 3
2458: PUSH
2459: FOR_IN
2460: IFFALSE 2615
// begin x := GetX ( i ) ;
2462: LD_ADDR_VAR 0 4
2466: PUSH
2467: LD_VAR 0 1
2471: PPUSH
2472: CALL_OW 250
2476: ST_TO_ADDR
// y := GetY ( i ) ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: LD_VAR 0 1
2486: PPUSH
2487: CALL_OW 251
2491: ST_TO_ADDR
// if MineAtPos ( x , y ) then
2492: LD_VAR 0 4
2496: PPUSH
2497: LD_VAR 0 5
2501: PPUSH
2502: CALL_OW 458
2506: IFFALSE 2613
// begin LaunchMineAtPos ( x , y , 2 ) ;
2508: LD_VAR 0 4
2512: PPUSH
2513: LD_VAR 0 5
2517: PPUSH
2518: LD_INT 2
2520: PPUSH
2521: CALL_OW 456
// for j = 1 to staticMines do
2525: LD_ADDR_VAR 0 2
2529: PUSH
2530: DOUBLE
2531: LD_INT 1
2533: DEC
2534: ST_TO_ADDR
2535: LD_EXP 3
2539: PUSH
2540: FOR_TO
2541: IFFALSE 2611
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
2543: LD_EXP 3
2547: PUSH
2548: LD_VAR 0 2
2552: ARRAY
2553: PUSH
2554: LD_INT 1
2556: ARRAY
2557: PUSH
2558: LD_VAR 0 4
2562: EQUAL
2563: PUSH
2564: LD_EXP 3
2568: PUSH
2569: LD_VAR 0 2
2573: ARRAY
2574: PUSH
2575: LD_INT 2
2577: ARRAY
2578: PUSH
2579: LD_VAR 0 5
2583: EQUAL
2584: AND
2585: IFFALSE 2609
// begin staticMines := Delete ( staticMines , j ) ;
2587: LD_ADDR_EXP 3
2591: PUSH
2592: LD_EXP 3
2596: PPUSH
2597: LD_VAR 0 2
2601: PPUSH
2602: CALL_OW 3
2606: ST_TO_ADDR
// break ;
2607: GO 2611
// end ;
2609: GO 2540
2611: POP
2612: POP
// end ; end ;
2613: GO 2459
2615: POP
2616: POP
// end ; end_of_file
2617: PPOPN 5
2619: END
// export Popov , popov_side , extraPopovForces ; export function PreparePopov ; var i , un , tmp ; begin
2620: LD_INT 0
2622: PPUSH
2623: PPUSH
2624: PPUSH
2625: PPUSH
// popov_side := 3 ;
2626: LD_ADDR_EXP 9
2630: PUSH
2631: LD_INT 3
2633: ST_TO_ADDR
// uc_side := popov_side ;
2634: LD_ADDR_OWVAR 20
2638: PUSH
2639: LD_EXP 9
2643: ST_TO_ADDR
// uc_nation := 3 ;
2644: LD_ADDR_OWVAR 21
2648: PUSH
2649: LD_INT 3
2651: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
2652: LD_ADDR_VAR 0 4
2656: PUSH
2657: LD_INT 9
2659: PPUSH
2660: LD_INT 3
2662: PPUSH
2663: LD_STRING 
2665: PPUSH
2666: LD_INT 8
2668: PUSH
2669: LD_INT 7
2671: PUSH
2672: LD_INT 6
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: LIST
2679: PUSH
2680: LD_OWVAR 67
2684: ARRAY
2685: PPUSH
2686: LD_INT 1500
2688: PUSH
2689: LD_INT 300
2691: PUSH
2692: LD_INT 30
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: LIST
2699: PPUSH
2700: LD_INT 4
2702: PUSH
2703: LD_INT 4
2705: PUSH
2706: LD_INT 4
2708: PUSH
2709: LD_INT 4
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL 12732 0 6
2722: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
2723: LD_ADDR_EXP 14
2727: PUSH
2728: LD_EXP 14
2732: PPUSH
2733: LD_INT 3
2735: PPUSH
2736: LD_VAR 0 4
2740: PPUSH
2741: CALL_OW 1
2745: ST_TO_ADDR
// extraPopovForces := [ ] ;
2746: LD_ADDR_EXP 10
2750: PUSH
2751: EMPTY
2752: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2753: LD_ADDR_VAR 0 2
2757: PUSH
2758: DOUBLE
2759: LD_INT 1
2761: DEC
2762: ST_TO_ADDR
2763: LD_INT 4
2765: PUSH
2766: LD_INT 5
2768: PUSH
2769: LD_INT 6
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: LIST
2776: PUSH
2777: LD_OWVAR 67
2781: ARRAY
2782: PUSH
2783: FOR_TO
2784: IFFALSE 2887
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
2786: LD_INT 0
2788: PPUSH
2789: LD_INT 1
2791: PPUSH
2792: LD_INT 4
2794: PUSH
2795: LD_INT 5
2797: PUSH
2798: LD_INT 6
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: LIST
2805: PUSH
2806: LD_OWVAR 67
2810: ARRAY
2811: PPUSH
2812: CALL_OW 380
// un := CreateHuman ;
2816: LD_ADDR_VAR 0 3
2820: PUSH
2821: CALL_OW 44
2825: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
2826: LD_VAR 0 3
2830: PPUSH
2831: LD_INT 131
2833: PPUSH
2834: LD_INT 110
2836: PPUSH
2837: LD_INT 8
2839: PPUSH
2840: LD_INT 0
2842: PPUSH
2843: CALL_OW 50
// ComHold ( un ) ;
2847: LD_VAR 0 3
2851: PPUSH
2852: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
2856: LD_ADDR_EXP 10
2860: PUSH
2861: LD_EXP 10
2865: PPUSH
2866: LD_EXP 10
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 3
2879: PPUSH
2880: CALL_OW 1
2884: ST_TO_ADDR
// end ;
2885: GO 2783
2887: POP
2888: POP
// PrepareSoldier ( false , 6 ) ;
2889: LD_INT 0
2891: PPUSH
2892: LD_INT 6
2894: PPUSH
2895: CALL_OW 381
// un := CreateHuman ;
2899: LD_ADDR_VAR 0 3
2903: PUSH
2904: CALL_OW 44
2908: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2909: LD_VAR 0 3
2913: PPUSH
2914: LD_INT 1
2916: PPUSH
2917: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
2921: LD_VAR 0 3
2925: PPUSH
2926: LD_INT 150
2928: PPUSH
2929: LD_INT 158
2931: PPUSH
2932: CALL_OW 428
2936: PPUSH
2937: CALL_OW 52
// end ;
2941: LD_VAR 0 1
2945: RET
// export function InitMC_Popov ( ) ; begin
2946: LD_INT 0
2948: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
2949: LD_INT 3
2951: PPUSH
2952: LD_INT 3
2954: PPUSH
2955: CALL 66263 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 10
2964: PPUSH
2965: CALL 66207 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 106 , 113 , 0 ] ] ) ;
2969: LD_INT 3
2971: PPUSH
2972: LD_INT 86
2974: PUSH
2975: LD_INT 118
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: PUSH
2986: LD_INT 123
2988: PUSH
2989: LD_INT 151
2991: PUSH
2992: LD_INT 1
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: LIST
2999: PUSH
3000: LD_INT 106
3002: PUSH
3003: LD_INT 113
3005: PUSH
3006: LD_INT 0
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: LIST
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: PPUSH
3019: CALL 65266 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ) ;
3023: LD_INT 3
3025: PPUSH
3026: LD_INT 46
3028: PUSH
3029: LD_INT 45
3031: PUSH
3032: LD_INT 47
3034: PUSH
3035: LD_INT 49
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PPUSH
3044: CALL 66095 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
3048: LD_INT 3
3050: PPUSH
3051: LD_INT 12
3053: PPUSH
3054: CALL 65777 0 2
// MC_SetTame ( 3 , popov_ape ) ;
3058: LD_INT 3
3060: PPUSH
3061: LD_INT 11
3063: PPUSH
3064: CALL 65508 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
3068: LD_INT 3
3070: PPUSH
3071: LD_INT 4
3073: PPUSH
3074: CALL 65127 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
3078: LD_INT 3
3080: PPUSH
3081: LD_INT 23
3083: PUSH
3084: LD_INT 1
3086: PUSH
3087: LD_INT 1
3089: PUSH
3090: LD_INT 44
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_INT 23
3101: PUSH
3102: LD_INT 1
3104: PUSH
3105: LD_INT 3
3107: PUSH
3108: LD_INT 45
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 21
3119: PUSH
3120: LD_INT 1
3122: PUSH
3123: LD_INT 3
3125: PUSH
3126: LD_INT 43
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: LD_INT 21
3137: PUSH
3138: LD_INT 1
3140: PUSH
3141: LD_INT 3
3143: PUSH
3144: LD_INT 45
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PPUSH
3159: CALL 64942 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 106 , 113 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] , [ b_teleport , 91 , 147 , 3 ] ] ) ;
3163: LD_INT 3
3165: PPUSH
3166: LD_INT 6
3168: PUSH
3169: LD_INT 76
3171: PUSH
3172: LD_INT 145
3174: PUSH
3175: LD_INT 1
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: LIST
3183: PUSH
3184: LD_INT 26
3186: PUSH
3187: LD_INT 87
3189: PUSH
3190: LD_INT 144
3192: PUSH
3193: LD_INT 0
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 29
3204: PUSH
3205: LD_INT 86
3207: PUSH
3208: LD_INT 118
3210: PUSH
3211: LD_INT 0
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PUSH
3220: LD_INT 29
3222: PUSH
3223: LD_INT 106
3225: PUSH
3226: LD_INT 113
3228: PUSH
3229: LD_INT 0
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 26
3240: PUSH
3241: LD_INT 87
3243: PUSH
3244: LD_INT 147
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 2
3258: PUSH
3259: LD_INT 94
3261: PUSH
3262: LD_INT 161
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 6
3276: PUSH
3277: LD_INT 81
3279: PUSH
3280: LD_INT 155
3282: PUSH
3283: LD_INT 1
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 4
3294: PUSH
3295: LD_INT 103
3297: PUSH
3298: LD_INT 147
3300: PUSH
3301: LD_INT 3
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: LD_INT 26
3312: PUSH
3313: LD_INT 96
3315: PUSH
3316: LD_INT 152
3318: PUSH
3319: LD_INT 0
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: LIST
3326: LIST
3327: PUSH
3328: LD_INT 26
3330: PUSH
3331: LD_INT 96
3333: PUSH
3334: LD_INT 149
3336: PUSH
3337: LD_INT 3
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: LIST
3345: PUSH
3346: LD_INT 32
3348: PUSH
3349: LD_INT 109
3351: PUSH
3352: LD_INT 142
3354: PUSH
3355: LD_INT 3
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: LIST
3362: LIST
3363: PUSH
3364: LD_INT 32
3366: PUSH
3367: LD_INT 112
3369: PUSH
3370: LD_INT 148
3372: PUSH
3373: LD_INT 3
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: PUSH
3382: LD_INT 33
3384: PUSH
3385: LD_INT 120
3387: PUSH
3388: LD_INT 159
3390: PUSH
3391: LD_INT 4
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: LIST
3398: LIST
3399: PUSH
3400: LD_INT 33
3402: PUSH
3403: LD_INT 122
3405: PUSH
3406: LD_INT 163
3408: PUSH
3409: LD_INT 4
3411: PUSH
3412: EMPTY
3413: LIST
3414: LIST
3415: LIST
3416: LIST
3417: PUSH
3418: LD_INT 33
3420: PUSH
3421: LD_INT 123
3423: PUSH
3424: LD_INT 167
3426: PUSH
3427: LD_INT 4
3429: PUSH
3430: EMPTY
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: PUSH
3436: LD_INT 33
3438: PUSH
3439: LD_INT 59
3441: PUSH
3442: LD_INT 111
3444: PUSH
3445: LD_INT 3
3447: PUSH
3448: EMPTY
3449: LIST
3450: LIST
3451: LIST
3452: LIST
3453: PUSH
3454: LD_INT 33
3456: PUSH
3457: LD_INT 65
3459: PUSH
3460: LD_INT 111
3462: PUSH
3463: LD_INT 3
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: PUSH
3472: LD_INT 33
3474: PUSH
3475: LD_INT 76
3477: PUSH
3478: LD_INT 117
3480: PUSH
3481: LD_INT 3
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: PUSH
3490: LD_INT 33
3492: PUSH
3493: LD_INT 80
3495: PUSH
3496: LD_INT 119
3498: PUSH
3499: LD_INT 3
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_INT 33
3510: PUSH
3511: LD_INT 87
3513: PUSH
3514: LD_INT 125
3516: PUSH
3517: LD_INT 3
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: LIST
3524: LIST
3525: PUSH
3526: LD_INT 4
3528: PUSH
3529: LD_INT 92
3531: PUSH
3532: LD_INT 129
3534: PUSH
3535: LD_INT 3
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: PUSH
3544: LD_INT 28
3546: PUSH
3547: LD_INT 85
3549: PUSH
3550: LD_INT 165
3552: PUSH
3553: LD_INT 0
3555: PUSH
3556: EMPTY
3557: LIST
3558: LIST
3559: LIST
3560: LIST
3561: PUSH
3562: LD_INT 28
3564: PUSH
3565: LD_INT 83
3567: PUSH
3568: LD_INT 161
3570: PUSH
3571: LD_INT 4
3573: PUSH
3574: EMPTY
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: PUSH
3580: LD_INT 28
3582: PUSH
3583: LD_INT 91
3585: PUSH
3586: LD_INT 166
3588: PUSH
3589: LD_INT 3
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 28
3600: PUSH
3601: LD_INT 102
3603: PUSH
3604: LD_INT 166
3606: PUSH
3607: LD_INT 2
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: PUSH
3616: LD_INT 34
3618: PUSH
3619: LD_INT 91
3621: PUSH
3622: LD_INT 147
3624: PUSH
3625: LD_INT 3
3627: PUSH
3628: EMPTY
3629: LIST
3630: LIST
3631: LIST
3632: LIST
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: LIST
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: LIST
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: LIST
3661: PPUSH
3662: CALL 64834 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
3666: LD_INT 3
3668: PPUSH
3669: LD_INT 10
3671: PUSH
3672: LD_INT 12
3674: PUSH
3675: LD_INT 14
3677: PUSH
3678: LD_INT 11
3680: PUSH
3681: EMPTY
3682: LIST
3683: LIST
3684: LIST
3685: LIST
3686: PPUSH
3687: CALL 65684 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
3691: LD_INT 3
3693: PPUSH
3694: LD_INT 94
3696: PPUSH
3697: LD_INT 161
3699: PPUSH
3700: LD_INT 0
3702: PPUSH
3703: LD_INT 19
3705: PUSH
3706: LD_INT 17
3708: PUSH
3709: LD_INT 18
3711: PUSH
3712: LD_INT 24
3714: PUSH
3715: LD_INT 21
3717: PUSH
3718: EMPTY
3719: LIST
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: PPUSH
3725: CALL 65889 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
3729: LD_INT 3
3731: PPUSH
3732: LD_INT 0
3734: PPUSH
3735: CALL 65557 0 2
// end ; end_of_file
3739: LD_VAR 0 1
3743: RET
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
3744: LD_INT 0
3746: PPUSH
3747: PPUSH
3748: PPUSH
3749: PPUSH
// uc_side := 1 ;
3750: LD_ADDR_OWVAR 20
3754: PUSH
3755: LD_INT 1
3757: ST_TO_ADDR
// uc_nation := 1 ;
3758: LD_ADDR_OWVAR 21
3762: PUSH
3763: LD_INT 1
3765: ST_TO_ADDR
// hc_importance := 100 ;
3766: LD_ADDR_OWVAR 32
3770: PUSH
3771: LD_INT 100
3773: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
3774: LD_ADDR_OWVAR 26
3778: PUSH
3779: LD_STRING Jeremy Sikorski
3781: ST_TO_ADDR
// hc_gallery := us ;
3782: LD_ADDR_OWVAR 33
3786: PUSH
3787: LD_STRING us
3789: ST_TO_ADDR
// hc_face_number := 19 ;
3790: LD_ADDR_OWVAR 34
3794: PUSH
3795: LD_INT 19
3797: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
3798: LD_INT 1
3800: PPUSH
3801: LD_INT 1
3803: PPUSH
3804: LD_INT 4
3806: PUSH
3807: LD_INT 4
3809: PUSH
3810: LD_INT 3
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: LIST
3817: PUSH
3818: LD_OWVAR 67
3822: ARRAY
3823: PPUSH
3824: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3828: LD_ADDR_OWVAR 29
3832: PUSH
3833: LD_INT 10
3835: PUSH
3836: LD_INT 12
3838: PUSH
3839: EMPTY
3840: LIST
3841: LIST
3842: ST_TO_ADDR
// Sikorski := CreateHuman ;
3843: LD_ADDR_EXP 11
3847: PUSH
3848: CALL_OW 44
3852: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
3853: LD_EXP 11
3857: PPUSH
3858: LD_INT 133
3860: PPUSH
3861: LD_INT 19
3863: PPUSH
3864: LD_INT 2
3866: PPUSH
3867: LD_INT 0
3869: PPUSH
3870: CALL_OW 50
// InitHc_All ( ) ;
3874: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3878: LD_ADDR_VAR 0 2
3882: PUSH
3883: DOUBLE
3884: LD_INT 1
3886: DEC
3887: ST_TO_ADDR
3888: LD_INT 4
3890: PUSH
3891: LD_INT 3
3893: PUSH
3894: LD_INT 3
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: LIST
3901: PUSH
3902: LD_OWVAR 67
3906: ARRAY
3907: PUSH
3908: FOR_TO
3909: IFFALSE 4025
// for j := 1 to 4 do
3911: LD_ADDR_VAR 0 3
3915: PUSH
3916: DOUBLE
3917: LD_INT 1
3919: DEC
3920: ST_TO_ADDR
3921: LD_INT 4
3923: PUSH
3924: FOR_TO
3925: IFFALSE 4021
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
3927: LD_INT 0
3929: PPUSH
3930: LD_VAR 0 3
3934: PPUSH
3935: LD_INT 5
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 3
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: LIST
3948: PUSH
3949: LD_OWVAR 67
3953: ARRAY
3954: PPUSH
3955: CALL_OW 380
// un := CreateHuman ;
3959: LD_ADDR_VAR 0 4
3963: PUSH
3964: CALL_OW 44
3968: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3969: LD_VAR 0 4
3973: PPUSH
3974: LD_INT 0
3976: PPUSH
3977: LD_INT 5
3979: PPUSH
3980: CALL_OW 12
3984: PPUSH
3985: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
3989: LD_VAR 0 4
3993: PPUSH
3994: LD_INT 133
3996: PPUSH
3997: LD_INT 19
3999: PPUSH
4000: LD_INT 6
4002: PPUSH
4003: LD_INT 0
4005: PPUSH
4006: CALL_OW 50
// ComHold ( un ) ;
4010: LD_VAR 0 4
4014: PPUSH
4015: CALL_OW 140
// end ;
4019: GO 3924
4021: POP
4022: POP
4023: GO 3908
4025: POP
4026: POP
// vc_chassis := us_heavy_tracked ;
4027: LD_ADDR_OWVAR 37
4031: PUSH
4032: LD_INT 4
4034: ST_TO_ADDR
// vc_engine := engine_combustion ;
4035: LD_ADDR_OWVAR 39
4039: PUSH
4040: LD_INT 1
4042: ST_TO_ADDR
// vc_control := control_manual ;
4043: LD_ADDR_OWVAR 38
4047: PUSH
4048: LD_INT 1
4050: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
4051: LD_ADDR_OWVAR 40
4055: PUSH
4056: LD_INT 14
4058: ST_TO_ADDR
// vc_fuel_battery := 60 ;
4059: LD_ADDR_OWVAR 41
4063: PUSH
4064: LD_INT 60
4066: ST_TO_ADDR
// un := CreateVehicle ;
4067: LD_ADDR_VAR 0 4
4071: PUSH
4072: CALL_OW 45
4076: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4077: LD_VAR 0 4
4081: PPUSH
4082: LD_INT 2
4084: PPUSH
4085: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
4089: LD_VAR 0 4
4093: PPUSH
4094: LD_INT 128
4096: PPUSH
4097: LD_INT 12
4099: PPUSH
4100: LD_INT 0
4102: PPUSH
4103: CALL_OW 48
// for i := 1 to 3 do
4107: LD_ADDR_VAR 0 2
4111: PUSH
4112: DOUBLE
4113: LD_INT 1
4115: DEC
4116: ST_TO_ADDR
4117: LD_INT 3
4119: PUSH
4120: FOR_TO
4121: IFFALSE 4144
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
4123: LD_INT 5
4125: PPUSH
4126: LD_INT 133
4128: PPUSH
4129: LD_INT 19
4131: PPUSH
4132: LD_INT 3
4134: PPUSH
4135: LD_INT 0
4137: PPUSH
4138: CALL_OW 56
4142: GO 4120
4144: POP
4145: POP
// end ; end_of_file
4146: LD_VAR 0 1
4150: RET
// export function Action ; begin
4151: LD_INT 0
4153: PPUSH
// InGameOn ;
4154: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
4158: LD_INT 133
4160: PPUSH
4161: LD_INT 19
4163: PPUSH
4164: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
4168: LD_EXP 11
4172: PPUSH
4173: LD_STRING WT-DS-1
4175: PPUSH
4176: CALL_OW 88
// InGameOff ;
4180: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
4184: LD_STRING DestroyEnemy
4186: PPUSH
4187: CALL_OW 337
// end ; end_of_file
4191: LD_VAR 0 1
4195: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
4196: LD_VAR 0 1
4200: PPUSH
4201: CALL 68382 0 1
// if un = Powell then
4205: LD_VAR 0 1
4209: PUSH
4210: LD_EXP 4
4214: EQUAL
4215: IFFALSE 4224
// YouLost ( Powell ) ;
4217: LD_STRING Powell
4219: PPUSH
4220: CALL_OW 104
// end ;
4224: PPOPN 1
4226: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
4227: LD_VAR 0 1
4231: PPUSH
4232: LD_VAR 0 2
4236: PPUSH
4237: CALL 70716 0 2
// end ;
4241: PPOPN 2
4243: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
4244: LD_VAR 0 1
4248: PPUSH
4249: CALL 69784 0 1
// end ;
4253: PPOPN 1
4255: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
4256: LD_VAR 0 1
4260: PPUSH
4261: CALL 70025 0 1
// end ;
4265: PPOPN 1
4267: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
4268: LD_VAR 0 1
4272: PPUSH
4273: LD_VAR 0 2
4277: PPUSH
4278: CALL 68078 0 2
// end ;
4282: PPOPN 2
4284: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
4285: LD_VAR 0 1
4289: PPUSH
4290: LD_VAR 0 2
4294: PPUSH
4295: LD_VAR 0 3
4299: PPUSH
4300: LD_VAR 0 4
4304: PPUSH
4305: LD_VAR 0 5
4309: PPUSH
4310: CALL 67698 0 5
// end ;
4314: PPOPN 5
4316: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
4317: LD_VAR 0 1
4321: PPUSH
4322: LD_VAR 0 2
4326: PPUSH
4327: CALL 67294 0 2
// end ;
4331: PPOPN 2
4333: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
4334: LD_VAR 0 1
4338: PPUSH
4339: LD_VAR 0 2
4343: PPUSH
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_VAR 0 4
4353: PPUSH
4354: CALL 67132 0 4
// end ;
4358: PPOPN 4
4360: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
4361: LD_VAR 0 1
4365: PPUSH
4366: LD_VAR 0 2
4370: PPUSH
4371: LD_VAR 0 3
4375: PPUSH
4376: CALL 66907 0 3
// end ;
4380: PPOPN 3
4382: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
4383: LD_VAR 0 1
4387: PPUSH
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL 66792 0 2
// end ;
4397: PPOPN 2
4399: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
4400: LD_VAR 0 1
4404: PPUSH
4405: LD_VAR 0 2
4409: PPUSH
4410: CALL 70977 0 2
// end ;
4414: PPOPN 2
4416: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
4417: LD_VAR 0 1
4421: PPUSH
4422: LD_VAR 0 2
4426: PPUSH
4427: LD_VAR 0 3
4431: PPUSH
4432: LD_VAR 0 4
4436: PPUSH
4437: CALL 71193 0 4
// end ;
4441: PPOPN 4
4443: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
4444: LD_VAR 0 1
4448: PPUSH
4449: LD_VAR 0 2
4453: PPUSH
4454: CALL 66601 0 2
// end ;
4458: PPOPN 2
4460: END
// export function CustomEvent ( event ) ; begin
4461: LD_INT 0
4463: PPUSH
// end ;
4464: LD_VAR 0 2
4468: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
4469: LD_VAR 0 1
4473: PUSH
4474: LD_INT 1
4476: EQUAL
4477: PUSH
4478: LD_VAR 0 2
4482: PUSH
4483: LD_INT 4
4485: EQUAL
4486: AND
4487: IFFALSE 4496
// YouLost ( FriendlyFire ) ;
4489: LD_STRING FriendlyFire
4491: PPUSH
4492: CALL_OW 104
// end ; end_of_file
4496: PPOPN 2
4498: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4499: LD_INT 0
4501: PPUSH
4502: PPUSH
// if exist_mode then
4503: LD_VAR 0 2
4507: IFFALSE 4532
// unit := CreateCharacter ( prefix & ident ) else
4509: LD_ADDR_VAR 0 5
4513: PUSH
4514: LD_VAR 0 3
4518: PUSH
4519: LD_VAR 0 1
4523: STR
4524: PPUSH
4525: CALL_OW 34
4529: ST_TO_ADDR
4530: GO 4547
// unit := NewCharacter ( ident ) ;
4532: LD_ADDR_VAR 0 5
4536: PUSH
4537: LD_VAR 0 1
4541: PPUSH
4542: CALL_OW 25
4546: ST_TO_ADDR
// result := unit ;
4547: LD_ADDR_VAR 0 4
4551: PUSH
4552: LD_VAR 0 5
4556: ST_TO_ADDR
// end ;
4557: LD_VAR 0 4
4561: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
4562: LD_INT 0
4564: PPUSH
4565: PPUSH
// if not side or not nation then
4566: LD_VAR 0 1
4570: NOT
4571: PUSH
4572: LD_VAR 0 2
4576: NOT
4577: OR
4578: IFFALSE 4582
// exit ;
4580: GO 5346
// case nation of nation_american :
4582: LD_VAR 0 2
4586: PUSH
4587: LD_INT 1
4589: DOUBLE
4590: EQUAL
4591: IFTRUE 4595
4593: GO 4809
4595: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
4596: LD_ADDR_VAR 0 4
4600: PUSH
4601: LD_INT 35
4603: PUSH
4604: LD_INT 45
4606: PUSH
4607: LD_INT 46
4609: PUSH
4610: LD_INT 47
4612: PUSH
4613: LD_INT 82
4615: PUSH
4616: LD_INT 83
4618: PUSH
4619: LD_INT 84
4621: PUSH
4622: LD_INT 85
4624: PUSH
4625: LD_INT 86
4627: PUSH
4628: LD_INT 1
4630: PUSH
4631: LD_INT 2
4633: PUSH
4634: LD_INT 6
4636: PUSH
4637: LD_INT 15
4639: PUSH
4640: LD_INT 16
4642: PUSH
4643: LD_INT 7
4645: PUSH
4646: LD_INT 12
4648: PUSH
4649: LD_INT 13
4651: PUSH
4652: LD_INT 10
4654: PUSH
4655: LD_INT 14
4657: PUSH
4658: LD_INT 20
4660: PUSH
4661: LD_INT 21
4663: PUSH
4664: LD_INT 22
4666: PUSH
4667: LD_INT 25
4669: PUSH
4670: LD_INT 32
4672: PUSH
4673: LD_INT 27
4675: PUSH
4676: LD_INT 36
4678: PUSH
4679: LD_INT 69
4681: PUSH
4682: LD_INT 39
4684: PUSH
4685: LD_INT 34
4687: PUSH
4688: LD_INT 40
4690: PUSH
4691: LD_INT 48
4693: PUSH
4694: LD_INT 49
4696: PUSH
4697: LD_INT 50
4699: PUSH
4700: LD_INT 51
4702: PUSH
4703: LD_INT 52
4705: PUSH
4706: LD_INT 53
4708: PUSH
4709: LD_INT 54
4711: PUSH
4712: LD_INT 55
4714: PUSH
4715: LD_INT 56
4717: PUSH
4718: LD_INT 57
4720: PUSH
4721: LD_INT 58
4723: PUSH
4724: LD_INT 59
4726: PUSH
4727: LD_INT 60
4729: PUSH
4730: LD_INT 61
4732: PUSH
4733: LD_INT 62
4735: PUSH
4736: LD_INT 80
4738: PUSH
4739: LD_INT 82
4741: PUSH
4742: LD_INT 83
4744: PUSH
4745: LD_INT 84
4747: PUSH
4748: LD_INT 85
4750: PUSH
4751: LD_INT 86
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: ST_TO_ADDR
4807: GO 5270
4809: LD_INT 2
4811: DOUBLE
4812: EQUAL
4813: IFTRUE 4817
4815: GO 5039
4817: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
4818: LD_ADDR_VAR 0 4
4822: PUSH
4823: LD_INT 35
4825: PUSH
4826: LD_INT 45
4828: PUSH
4829: LD_INT 46
4831: PUSH
4832: LD_INT 47
4834: PUSH
4835: LD_INT 82
4837: PUSH
4838: LD_INT 83
4840: PUSH
4841: LD_INT 84
4843: PUSH
4844: LD_INT 85
4846: PUSH
4847: LD_INT 87
4849: PUSH
4850: LD_INT 70
4852: PUSH
4853: LD_INT 1
4855: PUSH
4856: LD_INT 11
4858: PUSH
4859: LD_INT 3
4861: PUSH
4862: LD_INT 4
4864: PUSH
4865: LD_INT 5
4867: PUSH
4868: LD_INT 6
4870: PUSH
4871: LD_INT 15
4873: PUSH
4874: LD_INT 18
4876: PUSH
4877: LD_INT 7
4879: PUSH
4880: LD_INT 17
4882: PUSH
4883: LD_INT 8
4885: PUSH
4886: LD_INT 20
4888: PUSH
4889: LD_INT 21
4891: PUSH
4892: LD_INT 22
4894: PUSH
4895: LD_INT 72
4897: PUSH
4898: LD_INT 26
4900: PUSH
4901: LD_INT 69
4903: PUSH
4904: LD_INT 39
4906: PUSH
4907: LD_INT 40
4909: PUSH
4910: LD_INT 41
4912: PUSH
4913: LD_INT 42
4915: PUSH
4916: LD_INT 43
4918: PUSH
4919: LD_INT 48
4921: PUSH
4922: LD_INT 49
4924: PUSH
4925: LD_INT 50
4927: PUSH
4928: LD_INT 51
4930: PUSH
4931: LD_INT 52
4933: PUSH
4934: LD_INT 53
4936: PUSH
4937: LD_INT 54
4939: PUSH
4940: LD_INT 55
4942: PUSH
4943: LD_INT 56
4945: PUSH
4946: LD_INT 60
4948: PUSH
4949: LD_INT 61
4951: PUSH
4952: LD_INT 62
4954: PUSH
4955: LD_INT 66
4957: PUSH
4958: LD_INT 67
4960: PUSH
4961: LD_INT 68
4963: PUSH
4964: LD_INT 81
4966: PUSH
4967: LD_INT 82
4969: PUSH
4970: LD_INT 83
4972: PUSH
4973: LD_INT 84
4975: PUSH
4976: LD_INT 85
4978: PUSH
4979: LD_INT 87
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: LIST
5024: LIST
5025: LIST
5026: LIST
5027: LIST
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: ST_TO_ADDR
5037: GO 5270
5039: LD_INT 3
5041: DOUBLE
5042: EQUAL
5043: IFTRUE 5047
5045: GO 5269
5047: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_INT 46
5055: PUSH
5056: LD_INT 47
5058: PUSH
5059: LD_INT 1
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: LD_INT 82
5067: PUSH
5068: LD_INT 83
5070: PUSH
5071: LD_INT 84
5073: PUSH
5074: LD_INT 85
5076: PUSH
5077: LD_INT 86
5079: PUSH
5080: LD_INT 11
5082: PUSH
5083: LD_INT 9
5085: PUSH
5086: LD_INT 20
5088: PUSH
5089: LD_INT 19
5091: PUSH
5092: LD_INT 21
5094: PUSH
5095: LD_INT 24
5097: PUSH
5098: LD_INT 22
5100: PUSH
5101: LD_INT 25
5103: PUSH
5104: LD_INT 28
5106: PUSH
5107: LD_INT 29
5109: PUSH
5110: LD_INT 30
5112: PUSH
5113: LD_INT 31
5115: PUSH
5116: LD_INT 37
5118: PUSH
5119: LD_INT 38
5121: PUSH
5122: LD_INT 32
5124: PUSH
5125: LD_INT 27
5127: PUSH
5128: LD_INT 33
5130: PUSH
5131: LD_INT 69
5133: PUSH
5134: LD_INT 39
5136: PUSH
5137: LD_INT 34
5139: PUSH
5140: LD_INT 40
5142: PUSH
5143: LD_INT 71
5145: PUSH
5146: LD_INT 23
5148: PUSH
5149: LD_INT 44
5151: PUSH
5152: LD_INT 48
5154: PUSH
5155: LD_INT 49
5157: PUSH
5158: LD_INT 50
5160: PUSH
5161: LD_INT 51
5163: PUSH
5164: LD_INT 52
5166: PUSH
5167: LD_INT 53
5169: PUSH
5170: LD_INT 54
5172: PUSH
5173: LD_INT 55
5175: PUSH
5176: LD_INT 56
5178: PUSH
5179: LD_INT 57
5181: PUSH
5182: LD_INT 58
5184: PUSH
5185: LD_INT 59
5187: PUSH
5188: LD_INT 63
5190: PUSH
5191: LD_INT 64
5193: PUSH
5194: LD_INT 65
5196: PUSH
5197: LD_INT 82
5199: PUSH
5200: LD_INT 83
5202: PUSH
5203: LD_INT 84
5205: PUSH
5206: LD_INT 85
5208: PUSH
5209: LD_INT 86
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: LIST
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: ST_TO_ADDR
5267: GO 5270
5269: POP
// if state > - 1 and state < 3 then
5270: LD_VAR 0 3
5274: PUSH
5275: LD_INT 1
5277: NEG
5278: GREATER
5279: PUSH
5280: LD_VAR 0 3
5284: PUSH
5285: LD_INT 3
5287: LESS
5288: AND
5289: IFFALSE 5346
// for i in result do
5291: LD_ADDR_VAR 0 5
5295: PUSH
5296: LD_VAR 0 4
5300: PUSH
5301: FOR_IN
5302: IFFALSE 5344
// if GetTech ( i , side ) <> state then
5304: LD_VAR 0 5
5308: PPUSH
5309: LD_VAR 0 1
5313: PPUSH
5314: CALL_OW 321
5318: PUSH
5319: LD_VAR 0 3
5323: NONEQUAL
5324: IFFALSE 5342
// result := result diff i ;
5326: LD_ADDR_VAR 0 4
5330: PUSH
5331: LD_VAR 0 4
5335: PUSH
5336: LD_VAR 0 5
5340: DIFF
5341: ST_TO_ADDR
5342: GO 5301
5344: POP
5345: POP
// end ;
5346: LD_VAR 0 4
5350: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
5351: LD_INT 0
5353: PPUSH
5354: PPUSH
5355: PPUSH
// result := true ;
5356: LD_ADDR_VAR 0 3
5360: PUSH
5361: LD_INT 1
5363: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
5364: LD_ADDR_VAR 0 5
5368: PUSH
5369: LD_VAR 0 2
5373: PPUSH
5374: CALL_OW 480
5378: ST_TO_ADDR
// if not tmp then
5379: LD_VAR 0 5
5383: NOT
5384: IFFALSE 5388
// exit ;
5386: GO 5437
// for i in tmp do
5388: LD_ADDR_VAR 0 4
5392: PUSH
5393: LD_VAR 0 5
5397: PUSH
5398: FOR_IN
5399: IFFALSE 5435
// if GetTech ( i , side ) <> state_researched then
5401: LD_VAR 0 4
5405: PPUSH
5406: LD_VAR 0 1
5410: PPUSH
5411: CALL_OW 321
5415: PUSH
5416: LD_INT 2
5418: NONEQUAL
5419: IFFALSE 5433
// begin result := false ;
5421: LD_ADDR_VAR 0 3
5425: PUSH
5426: LD_INT 0
5428: ST_TO_ADDR
// exit ;
5429: POP
5430: POP
5431: GO 5437
// end ;
5433: GO 5398
5435: POP
5436: POP
// end ;
5437: LD_VAR 0 3
5441: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
5442: LD_INT 0
5444: PPUSH
5445: PPUSH
5446: PPUSH
5447: PPUSH
5448: PPUSH
5449: PPUSH
5450: PPUSH
5451: PPUSH
5452: PPUSH
5453: PPUSH
5454: PPUSH
5455: PPUSH
5456: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
5457: LD_VAR 0 1
5461: NOT
5462: PUSH
5463: LD_VAR 0 1
5467: PPUSH
5468: CALL_OW 257
5472: PUSH
5473: LD_INT 9
5475: NONEQUAL
5476: OR
5477: IFFALSE 5481
// exit ;
5479: GO 6054
// side := GetSide ( unit ) ;
5481: LD_ADDR_VAR 0 9
5485: PUSH
5486: LD_VAR 0 1
5490: PPUSH
5491: CALL_OW 255
5495: ST_TO_ADDR
// tech_space := tech_spacanom ;
5496: LD_ADDR_VAR 0 12
5500: PUSH
5501: LD_INT 29
5503: ST_TO_ADDR
// tech_time := tech_taurad ;
5504: LD_ADDR_VAR 0 13
5508: PUSH
5509: LD_INT 28
5511: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
5512: LD_ADDR_VAR 0 11
5516: PUSH
5517: LD_VAR 0 1
5521: PPUSH
5522: CALL_OW 310
5526: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
5527: LD_VAR 0 11
5531: PPUSH
5532: CALL_OW 247
5536: PUSH
5537: LD_INT 2
5539: EQUAL
5540: IFFALSE 5544
// exit ;
5542: GO 6054
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
5544: LD_ADDR_VAR 0 8
5548: PUSH
5549: LD_INT 81
5551: PUSH
5552: LD_VAR 0 9
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PUSH
5561: LD_INT 3
5563: PUSH
5564: LD_INT 21
5566: PUSH
5567: LD_INT 3
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 69
5586: ST_TO_ADDR
// if not tmp then
5587: LD_VAR 0 8
5591: NOT
5592: IFFALSE 5596
// exit ;
5594: GO 6054
// if in_unit then
5596: LD_VAR 0 11
5600: IFFALSE 5624
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
5602: LD_ADDR_VAR 0 10
5606: PUSH
5607: LD_VAR 0 8
5611: PPUSH
5612: LD_VAR 0 11
5616: PPUSH
5617: CALL_OW 74
5621: ST_TO_ADDR
5622: GO 5644
// enemy := NearestUnitToUnit ( tmp , unit ) ;
5624: LD_ADDR_VAR 0 10
5628: PUSH
5629: LD_VAR 0 8
5633: PPUSH
5634: LD_VAR 0 1
5638: PPUSH
5639: CALL_OW 74
5643: ST_TO_ADDR
// if not enemy then
5644: LD_VAR 0 10
5648: NOT
5649: IFFALSE 5653
// exit ;
5651: GO 6054
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
5653: LD_VAR 0 11
5657: PUSH
5658: LD_VAR 0 11
5662: PPUSH
5663: LD_VAR 0 10
5667: PPUSH
5668: CALL_OW 296
5672: PUSH
5673: LD_INT 13
5675: GREATER
5676: AND
5677: PUSH
5678: LD_VAR 0 1
5682: PPUSH
5683: LD_VAR 0 10
5687: PPUSH
5688: CALL_OW 296
5692: PUSH
5693: LD_INT 12
5695: GREATER
5696: OR
5697: IFFALSE 5701
// exit ;
5699: GO 6054
// missile := [ 1 ] ;
5701: LD_ADDR_VAR 0 14
5705: PUSH
5706: LD_INT 1
5708: PUSH
5709: EMPTY
5710: LIST
5711: ST_TO_ADDR
// if Researched ( side , tech_space ) then
5712: LD_VAR 0 9
5716: PPUSH
5717: LD_VAR 0 12
5721: PPUSH
5722: CALL_OW 325
5726: IFFALSE 5755
// missile := Insert ( missile , missile + 1 , 2 ) ;
5728: LD_ADDR_VAR 0 14
5732: PUSH
5733: LD_VAR 0 14
5737: PPUSH
5738: LD_VAR 0 14
5742: PUSH
5743: LD_INT 1
5745: PLUS
5746: PPUSH
5747: LD_INT 2
5749: PPUSH
5750: CALL_OW 2
5754: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
5755: LD_VAR 0 9
5759: PPUSH
5760: LD_VAR 0 13
5764: PPUSH
5765: CALL_OW 325
5769: PUSH
5770: LD_VAR 0 10
5774: PPUSH
5775: CALL_OW 255
5779: PPUSH
5780: LD_VAR 0 13
5784: PPUSH
5785: CALL_OW 325
5789: NOT
5790: AND
5791: IFFALSE 5820
// missile := Insert ( missile , missile + 1 , 3 ) ;
5793: LD_ADDR_VAR 0 14
5797: PUSH
5798: LD_VAR 0 14
5802: PPUSH
5803: LD_VAR 0 14
5807: PUSH
5808: LD_INT 1
5810: PLUS
5811: PPUSH
5812: LD_INT 3
5814: PPUSH
5815: CALL_OW 2
5819: ST_TO_ADDR
// if missile < 2 then
5820: LD_VAR 0 14
5824: PUSH
5825: LD_INT 2
5827: LESS
5828: IFFALSE 5832
// exit ;
5830: GO 6054
// x := GetX ( enemy ) ;
5832: LD_ADDR_VAR 0 4
5836: PUSH
5837: LD_VAR 0 10
5841: PPUSH
5842: CALL_OW 250
5846: ST_TO_ADDR
// y := GetY ( enemy ) ;
5847: LD_ADDR_VAR 0 5
5851: PUSH
5852: LD_VAR 0 10
5856: PPUSH
5857: CALL_OW 251
5861: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
5862: LD_ADDR_VAR 0 6
5866: PUSH
5867: LD_VAR 0 4
5871: PUSH
5872: LD_INT 1
5874: NEG
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL_OW 12
5883: PLUS
5884: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
5885: LD_ADDR_VAR 0 7
5889: PUSH
5890: LD_VAR 0 5
5894: PUSH
5895: LD_INT 1
5897: NEG
5898: PPUSH
5899: LD_INT 1
5901: PPUSH
5902: CALL_OW 12
5906: PLUS
5907: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
5908: LD_VAR 0 6
5912: PPUSH
5913: LD_VAR 0 7
5917: PPUSH
5918: CALL_OW 488
5922: NOT
5923: IFFALSE 5945
// begin _x := x ;
5925: LD_ADDR_VAR 0 6
5929: PUSH
5930: LD_VAR 0 4
5934: ST_TO_ADDR
// _y := y ;
5935: LD_ADDR_VAR 0 7
5939: PUSH
5940: LD_VAR 0 5
5944: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 1
5952: PPUSH
5953: LD_VAR 0 14
5957: PPUSH
5958: CALL_OW 12
5962: ST_TO_ADDR
// case i of 1 :
5963: LD_VAR 0 3
5967: PUSH
5968: LD_INT 1
5970: DOUBLE
5971: EQUAL
5972: IFTRUE 5976
5974: GO 5993
5976: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
5977: LD_VAR 0 1
5981: PPUSH
5982: LD_VAR 0 10
5986: PPUSH
5987: CALL_OW 115
5991: GO 6054
5993: LD_INT 2
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6023
6001: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
6002: LD_VAR 0 1
6006: PPUSH
6007: LD_VAR 0 6
6011: PPUSH
6012: LD_VAR 0 7
6016: PPUSH
6017: CALL_OW 153
6021: GO 6054
6023: LD_INT 3
6025: DOUBLE
6026: EQUAL
6027: IFTRUE 6031
6029: GO 6053
6031: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
6032: LD_VAR 0 1
6036: PPUSH
6037: LD_VAR 0 6
6041: PPUSH
6042: LD_VAR 0 7
6046: PPUSH
6047: CALL_OW 154
6051: GO 6054
6053: POP
// end ;
6054: LD_VAR 0 2
6058: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
6059: LD_INT 0
6061: PPUSH
6062: PPUSH
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
// if not unit or not building then
6067: LD_VAR 0 1
6071: NOT
6072: PUSH
6073: LD_VAR 0 2
6077: NOT
6078: OR
6079: IFFALSE 6083
// exit ;
6081: GO 6241
// x := GetX ( building ) ;
6083: LD_ADDR_VAR 0 5
6087: PUSH
6088: LD_VAR 0 2
6092: PPUSH
6093: CALL_OW 250
6097: ST_TO_ADDR
// y := GetY ( building ) ;
6098: LD_ADDR_VAR 0 6
6102: PUSH
6103: LD_VAR 0 2
6107: PPUSH
6108: CALL_OW 251
6112: ST_TO_ADDR
// for i = 0 to 5 do
6113: LD_ADDR_VAR 0 4
6117: PUSH
6118: DOUBLE
6119: LD_INT 0
6121: DEC
6122: ST_TO_ADDR
6123: LD_INT 5
6125: PUSH
6126: FOR_TO
6127: IFFALSE 6239
// begin _x := ShiftX ( x , i , 3 ) ;
6129: LD_ADDR_VAR 0 7
6133: PUSH
6134: LD_VAR 0 5
6138: PPUSH
6139: LD_VAR 0 4
6143: PPUSH
6144: LD_INT 3
6146: PPUSH
6147: CALL_OW 272
6151: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
6152: LD_ADDR_VAR 0 8
6156: PUSH
6157: LD_VAR 0 6
6161: PPUSH
6162: LD_VAR 0 4
6166: PPUSH
6167: LD_INT 3
6169: PPUSH
6170: CALL_OW 273
6174: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
6175: LD_VAR 0 7
6179: PPUSH
6180: LD_VAR 0 8
6184: PPUSH
6185: CALL_OW 488
6189: NOT
6190: IFFALSE 6194
// continue ;
6192: GO 6126
// if HexInfo ( _x , _y ) = 0 then
6194: LD_VAR 0 7
6198: PPUSH
6199: LD_VAR 0 8
6203: PPUSH
6204: CALL_OW 428
6208: PUSH
6209: LD_INT 0
6211: EQUAL
6212: IFFALSE 6237
// begin ComMoveXY ( unit , _x , _y ) ;
6214: LD_VAR 0 1
6218: PPUSH
6219: LD_VAR 0 7
6223: PPUSH
6224: LD_VAR 0 8
6228: PPUSH
6229: CALL_OW 111
// exit ;
6233: POP
6234: POP
6235: GO 6241
// end ; end ;
6237: GO 6126
6239: POP
6240: POP
// end ;
6241: LD_VAR 0 3
6245: RET
// export function ScanBase ( side , base_area ) ; begin
6246: LD_INT 0
6248: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
6249: LD_ADDR_VAR 0 3
6253: PUSH
6254: LD_VAR 0 2
6258: PPUSH
6259: LD_INT 81
6261: PUSH
6262: LD_VAR 0 1
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: PPUSH
6271: CALL_OW 70
6275: ST_TO_ADDR
// end ;
6276: LD_VAR 0 3
6280: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
6281: LD_INT 0
6283: PPUSH
6284: PPUSH
6285: PPUSH
6286: PPUSH
// result := false ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 0
6294: ST_TO_ADDR
// side := GetSide ( unit ) ;
6295: LD_ADDR_VAR 0 3
6299: PUSH
6300: LD_VAR 0 1
6304: PPUSH
6305: CALL_OW 255
6309: ST_TO_ADDR
// nat := GetNation ( unit ) ;
6310: LD_ADDR_VAR 0 4
6314: PUSH
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL_OW 248
6324: ST_TO_ADDR
// case nat of 1 :
6325: LD_VAR 0 4
6329: PUSH
6330: LD_INT 1
6332: DOUBLE
6333: EQUAL
6334: IFTRUE 6338
6336: GO 6349
6338: POP
// tech := tech_lassight ; 2 :
6339: LD_ADDR_VAR 0 5
6343: PUSH
6344: LD_INT 12
6346: ST_TO_ADDR
6347: GO 6388
6349: LD_INT 2
6351: DOUBLE
6352: EQUAL
6353: IFTRUE 6357
6355: GO 6368
6357: POP
// tech := tech_mortar ; 3 :
6358: LD_ADDR_VAR 0 5
6362: PUSH
6363: LD_INT 41
6365: ST_TO_ADDR
6366: GO 6388
6368: LD_INT 3
6370: DOUBLE
6371: EQUAL
6372: IFTRUE 6376
6374: GO 6387
6376: POP
// tech := tech_bazooka ; end ;
6377: LD_ADDR_VAR 0 5
6381: PUSH
6382: LD_INT 44
6384: ST_TO_ADDR
6385: GO 6388
6387: POP
// if Researched ( side , tech ) then
6388: LD_VAR 0 3
6392: PPUSH
6393: LD_VAR 0 5
6397: PPUSH
6398: CALL_OW 325
6402: IFFALSE 6429
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
6404: LD_ADDR_VAR 0 2
6408: PUSH
6409: LD_INT 5
6411: PUSH
6412: LD_INT 8
6414: PUSH
6415: LD_INT 9
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: PUSH
6423: LD_VAR 0 4
6427: ARRAY
6428: ST_TO_ADDR
// end ;
6429: LD_VAR 0 2
6433: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
6434: LD_INT 0
6436: PPUSH
6437: PPUSH
6438: PPUSH
// if not mines then
6439: LD_VAR 0 2
6443: NOT
6444: IFFALSE 6448
// exit ;
6446: GO 6592
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
6448: LD_ADDR_VAR 0 5
6452: PUSH
6453: LD_INT 81
6455: PUSH
6456: LD_VAR 0 1
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 3
6467: PUSH
6468: LD_INT 21
6470: PUSH
6471: LD_INT 3
6473: PUSH
6474: EMPTY
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL_OW 69
6490: ST_TO_ADDR
// for i in mines do
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_VAR 0 2
6500: PUSH
6501: FOR_IN
6502: IFFALSE 6590
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
6504: LD_VAR 0 4
6508: PUSH
6509: LD_INT 1
6511: ARRAY
6512: PPUSH
6513: LD_VAR 0 4
6517: PUSH
6518: LD_INT 2
6520: ARRAY
6521: PPUSH
6522: CALL_OW 458
6526: NOT
6527: IFFALSE 6531
// continue ;
6529: GO 6501
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
6531: LD_VAR 0 4
6535: PUSH
6536: LD_INT 1
6538: ARRAY
6539: PPUSH
6540: LD_VAR 0 4
6544: PUSH
6545: LD_INT 2
6547: ARRAY
6548: PPUSH
6549: CALL_OW 428
6553: PUSH
6554: LD_VAR 0 5
6558: IN
6559: IFFALSE 6588
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
6561: LD_VAR 0 4
6565: PUSH
6566: LD_INT 1
6568: ARRAY
6569: PPUSH
6570: LD_VAR 0 4
6574: PUSH
6575: LD_INT 2
6577: ARRAY
6578: PPUSH
6579: LD_VAR 0 1
6583: PPUSH
6584: CALL_OW 456
// end ;
6588: GO 6501
6590: POP
6591: POP
// end ;
6592: LD_VAR 0 3
6596: RET
// export function Count ( array ) ; var i ; begin
6597: LD_INT 0
6599: PPUSH
6600: PPUSH
// result := 0 ;
6601: LD_ADDR_VAR 0 2
6605: PUSH
6606: LD_INT 0
6608: ST_TO_ADDR
// for i in array do
6609: LD_ADDR_VAR 0 3
6613: PUSH
6614: LD_VAR 0 1
6618: PUSH
6619: FOR_IN
6620: IFFALSE 6644
// if i then
6622: LD_VAR 0 3
6626: IFFALSE 6642
// result := result + 1 ;
6628: LD_ADDR_VAR 0 2
6632: PUSH
6633: LD_VAR 0 2
6637: PUSH
6638: LD_INT 1
6640: PLUS
6641: ST_TO_ADDR
6642: GO 6619
6644: POP
6645: POP
// end ;
6646: LD_VAR 0 2
6650: RET
// export function IsEmpty ( building ) ; begin
6651: LD_INT 0
6653: PPUSH
// if not building then
6654: LD_VAR 0 1
6658: NOT
6659: IFFALSE 6663
// exit ;
6661: GO 6706
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
6663: LD_ADDR_VAR 0 2
6667: PUSH
6668: LD_VAR 0 1
6672: PUSH
6673: LD_INT 22
6675: PUSH
6676: LD_VAR 0 1
6680: PPUSH
6681: CALL_OW 255
6685: PUSH
6686: EMPTY
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 58
6692: PUSH
6693: EMPTY
6694: LIST
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: PPUSH
6700: CALL_OW 69
6704: IN
6705: ST_TO_ADDR
// end ;
6706: LD_VAR 0 2
6710: RET
// export function IsNotFull ( building ) ; begin
6711: LD_INT 0
6713: PPUSH
// if not building then
6714: LD_VAR 0 1
6718: NOT
6719: IFFALSE 6723
// exit ;
6721: GO 6742
// result := UnitsInside ( building ) < 6 ;
6723: LD_ADDR_VAR 0 2
6727: PUSH
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 313
6737: PUSH
6738: LD_INT 6
6740: LESS
6741: ST_TO_ADDR
// end ;
6742: LD_VAR 0 2
6746: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
6747: LD_INT 0
6749: PPUSH
6750: PPUSH
6751: PPUSH
6752: PPUSH
// tmp := [ ] ;
6753: LD_ADDR_VAR 0 3
6757: PUSH
6758: EMPTY
6759: ST_TO_ADDR
// list := [ ] ;
6760: LD_ADDR_VAR 0 5
6764: PUSH
6765: EMPTY
6766: ST_TO_ADDR
// for i = 16 to 25 do
6767: LD_ADDR_VAR 0 4
6771: PUSH
6772: DOUBLE
6773: LD_INT 16
6775: DEC
6776: ST_TO_ADDR
6777: LD_INT 25
6779: PUSH
6780: FOR_TO
6781: IFFALSE 6854
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
6783: LD_ADDR_VAR 0 3
6787: PUSH
6788: LD_VAR 0 3
6792: PUSH
6793: LD_INT 22
6795: PUSH
6796: LD_VAR 0 1
6800: PPUSH
6801: CALL_OW 255
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: PUSH
6810: LD_INT 91
6812: PUSH
6813: LD_VAR 0 1
6817: PUSH
6818: LD_INT 6
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 30
6828: PUSH
6829: LD_VAR 0 4
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: LIST
6842: PUSH
6843: EMPTY
6844: LIST
6845: PPUSH
6846: CALL_OW 69
6850: ADD
6851: ST_TO_ADDR
6852: GO 6780
6854: POP
6855: POP
// for i = 1 to tmp do
6856: LD_ADDR_VAR 0 4
6860: PUSH
6861: DOUBLE
6862: LD_INT 1
6864: DEC
6865: ST_TO_ADDR
6866: LD_VAR 0 3
6870: PUSH
6871: FOR_TO
6872: IFFALSE 6960
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
6874: LD_ADDR_VAR 0 5
6878: PUSH
6879: LD_VAR 0 5
6883: PUSH
6884: LD_VAR 0 3
6888: PUSH
6889: LD_VAR 0 4
6893: ARRAY
6894: PPUSH
6895: CALL_OW 266
6899: PUSH
6900: LD_VAR 0 3
6904: PUSH
6905: LD_VAR 0 4
6909: ARRAY
6910: PPUSH
6911: CALL_OW 250
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 4
6925: ARRAY
6926: PPUSH
6927: CALL_OW 251
6931: PUSH
6932: LD_VAR 0 3
6936: PUSH
6937: LD_VAR 0 4
6941: ARRAY
6942: PPUSH
6943: CALL_OW 254
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PUSH
6954: EMPTY
6955: LIST
6956: ADD
6957: ST_TO_ADDR
6958: GO 6871
6960: POP
6961: POP
// result := list ;
6962: LD_ADDR_VAR 0 2
6966: PUSH
6967: LD_VAR 0 5
6971: ST_TO_ADDR
// end ;
6972: LD_VAR 0 2
6976: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
6977: LD_INT 0
6979: PPUSH
6980: PPUSH
6981: PPUSH
6982: PPUSH
6983: PPUSH
6984: PPUSH
6985: PPUSH
// if not factory then
6986: LD_VAR 0 1
6990: NOT
6991: IFFALSE 6995
// exit ;
6993: GO 7588
// if control = control_apeman then
6995: LD_VAR 0 4
6999: PUSH
7000: LD_INT 5
7002: EQUAL
7003: IFFALSE 7112
// begin tmp := UnitsInside ( factory ) ;
7005: LD_ADDR_VAR 0 8
7009: PUSH
7010: LD_VAR 0 1
7014: PPUSH
7015: CALL_OW 313
7019: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
7020: LD_VAR 0 8
7024: PPUSH
7025: LD_INT 25
7027: PUSH
7028: LD_INT 12
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PPUSH
7035: CALL_OW 72
7039: NOT
7040: IFFALSE 7050
// control := control_manual ;
7042: LD_ADDR_VAR 0 4
7046: PUSH
7047: LD_INT 1
7049: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
7050: LD_ADDR_VAR 0 8
7054: PUSH
7055: LD_VAR 0 1
7059: PPUSH
7060: CALL 6747 0 1
7064: ST_TO_ADDR
// if tmp then
7065: LD_VAR 0 8
7069: IFFALSE 7112
// begin for i in tmp do
7071: LD_ADDR_VAR 0 7
7075: PUSH
7076: LD_VAR 0 8
7080: PUSH
7081: FOR_IN
7082: IFFALSE 7110
// if i [ 1 ] = b_ext_radio then
7084: LD_VAR 0 7
7088: PUSH
7089: LD_INT 1
7091: ARRAY
7092: PUSH
7093: LD_INT 22
7095: EQUAL
7096: IFFALSE 7108
// begin control := control_remote ;
7098: LD_ADDR_VAR 0 4
7102: PUSH
7103: LD_INT 2
7105: ST_TO_ADDR
// break ;
7106: GO 7110
// end ;
7108: GO 7081
7110: POP
7111: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7112: LD_VAR 0 1
7116: PPUSH
7117: LD_VAR 0 2
7121: PPUSH
7122: LD_VAR 0 3
7126: PPUSH
7127: LD_VAR 0 4
7131: PPUSH
7132: LD_VAR 0 5
7136: PPUSH
7137: CALL_OW 448
7141: IFFALSE 7176
// begin result := [ chassis , engine , control , weapon ] ;
7143: LD_ADDR_VAR 0 6
7147: PUSH
7148: LD_VAR 0 2
7152: PUSH
7153: LD_VAR 0 3
7157: PUSH
7158: LD_VAR 0 4
7162: PUSH
7163: LD_VAR 0 5
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: ST_TO_ADDR
// exit ;
7174: GO 7588
// end ; _chassis := AvailableChassisList ( factory ) ;
7176: LD_ADDR_VAR 0 9
7180: PUSH
7181: LD_VAR 0 1
7185: PPUSH
7186: CALL_OW 475
7190: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
7191: LD_ADDR_VAR 0 11
7195: PUSH
7196: LD_VAR 0 1
7200: PPUSH
7201: CALL_OW 476
7205: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
7206: LD_ADDR_VAR 0 12
7210: PUSH
7211: LD_VAR 0 1
7215: PPUSH
7216: CALL_OW 477
7220: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
7221: LD_ADDR_VAR 0 10
7225: PUSH
7226: LD_VAR 0 1
7230: PPUSH
7231: CALL_OW 478
7235: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
7236: LD_VAR 0 9
7240: NOT
7241: PUSH
7242: LD_VAR 0 11
7246: NOT
7247: OR
7248: PUSH
7249: LD_VAR 0 12
7253: NOT
7254: OR
7255: PUSH
7256: LD_VAR 0 10
7260: NOT
7261: OR
7262: IFFALSE 7297
// begin result := [ chassis , engine , control , weapon ] ;
7264: LD_ADDR_VAR 0 6
7268: PUSH
7269: LD_VAR 0 2
7273: PUSH
7274: LD_VAR 0 3
7278: PUSH
7279: LD_VAR 0 4
7283: PUSH
7284: LD_VAR 0 5
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: LIST
7294: ST_TO_ADDR
// exit ;
7295: GO 7588
// end ; if not chassis in _chassis then
7297: LD_VAR 0 2
7301: PUSH
7302: LD_VAR 0 9
7306: IN
7307: NOT
7308: IFFALSE 7334
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
7310: LD_ADDR_VAR 0 2
7314: PUSH
7315: LD_VAR 0 9
7319: PUSH
7320: LD_INT 1
7322: PPUSH
7323: LD_VAR 0 9
7327: PPUSH
7328: CALL_OW 12
7332: ARRAY
7333: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
7334: LD_VAR 0 2
7338: PPUSH
7339: LD_VAR 0 3
7343: PPUSH
7344: CALL 7593 0 2
7348: NOT
7349: IFFALSE 7408
// repeat engine := _engine [ 1 ] ;
7351: LD_ADDR_VAR 0 3
7355: PUSH
7356: LD_VAR 0 11
7360: PUSH
7361: LD_INT 1
7363: ARRAY
7364: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
7365: LD_ADDR_VAR 0 11
7369: PUSH
7370: LD_VAR 0 11
7374: PPUSH
7375: LD_INT 1
7377: PPUSH
7378: CALL_OW 3
7382: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
7383: LD_VAR 0 2
7387: PPUSH
7388: LD_VAR 0 3
7392: PPUSH
7393: CALL 7593 0 2
7397: PUSH
7398: LD_VAR 0 11
7402: PUSH
7403: EMPTY
7404: EQUAL
7405: OR
7406: IFFALSE 7351
// if not control in _control then
7408: LD_VAR 0 4
7412: PUSH
7413: LD_VAR 0 12
7417: IN
7418: NOT
7419: IFFALSE 7445
// control := _control [ rand ( 1 , _control ) ] ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_VAR 0 12
7430: PUSH
7431: LD_INT 1
7433: PPUSH
7434: LD_VAR 0 12
7438: PPUSH
7439: CALL_OW 12
7443: ARRAY
7444: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
7445: LD_VAR 0 2
7449: PPUSH
7450: LD_VAR 0 5
7454: PPUSH
7455: CALL 7813 0 2
7459: NOT
7460: IFFALSE 7519
// repeat weapon := _weapon [ 1 ] ;
7462: LD_ADDR_VAR 0 5
7466: PUSH
7467: LD_VAR 0 10
7471: PUSH
7472: LD_INT 1
7474: ARRAY
7475: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
7476: LD_ADDR_VAR 0 10
7480: PUSH
7481: LD_VAR 0 10
7485: PPUSH
7486: LD_INT 1
7488: PPUSH
7489: CALL_OW 3
7493: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
7494: LD_VAR 0 2
7498: PPUSH
7499: LD_VAR 0 5
7503: PPUSH
7504: CALL 7813 0 2
7508: PUSH
7509: LD_VAR 0 10
7513: PUSH
7514: EMPTY
7515: EQUAL
7516: OR
7517: IFFALSE 7462
// result := [ ] ;
7519: LD_ADDR_VAR 0 6
7523: PUSH
7524: EMPTY
7525: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7526: LD_VAR 0 1
7530: PPUSH
7531: LD_VAR 0 2
7535: PPUSH
7536: LD_VAR 0 3
7540: PPUSH
7541: LD_VAR 0 4
7545: PPUSH
7546: LD_VAR 0 5
7550: PPUSH
7551: CALL_OW 448
7555: IFFALSE 7588
// result := [ chassis , engine , control , weapon ] ;
7557: LD_ADDR_VAR 0 6
7561: PUSH
7562: LD_VAR 0 2
7566: PUSH
7567: LD_VAR 0 3
7571: PUSH
7572: LD_VAR 0 4
7576: PUSH
7577: LD_VAR 0 5
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: ST_TO_ADDR
// end ;
7588: LD_VAR 0 6
7592: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
7593: LD_INT 0
7595: PPUSH
// if not chassis or not engine then
7596: LD_VAR 0 1
7600: NOT
7601: PUSH
7602: LD_VAR 0 2
7606: NOT
7607: OR
7608: IFFALSE 7612
// exit ;
7610: GO 7808
// case engine of engine_solar :
7612: LD_VAR 0 2
7616: PUSH
7617: LD_INT 2
7619: DOUBLE
7620: EQUAL
7621: IFTRUE 7625
7623: GO 7663
7625: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
7626: LD_ADDR_VAR 0 3
7630: PUSH
7631: LD_INT 11
7633: PUSH
7634: LD_INT 12
7636: PUSH
7637: LD_INT 13
7639: PUSH
7640: LD_INT 14
7642: PUSH
7643: LD_INT 1
7645: PUSH
7646: LD_INT 2
7648: PUSH
7649: LD_INT 3
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: LIST
7659: LIST
7660: ST_TO_ADDR
7661: GO 7792
7663: LD_INT 1
7665: DOUBLE
7666: EQUAL
7667: IFTRUE 7671
7669: GO 7733
7671: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
7672: LD_ADDR_VAR 0 3
7676: PUSH
7677: LD_INT 11
7679: PUSH
7680: LD_INT 12
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 14
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 2
7694: PUSH
7695: LD_INT 3
7697: PUSH
7698: LD_INT 4
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: LD_INT 21
7706: PUSH
7707: LD_INT 23
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 24
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: ST_TO_ADDR
7731: GO 7792
7733: LD_INT 3
7735: DOUBLE
7736: EQUAL
7737: IFTRUE 7741
7739: GO 7791
7741: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
7742: LD_ADDR_VAR 0 3
7746: PUSH
7747: LD_INT 13
7749: PUSH
7750: LD_INT 14
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: LD_INT 3
7758: PUSH
7759: LD_INT 4
7761: PUSH
7762: LD_INT 5
7764: PUSH
7765: LD_INT 21
7767: PUSH
7768: LD_INT 22
7770: PUSH
7771: LD_INT 23
7773: PUSH
7774: LD_INT 24
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: ST_TO_ADDR
7789: GO 7792
7791: POP
// result := ( chassis in result ) ;
7792: LD_ADDR_VAR 0 3
7796: PUSH
7797: LD_VAR 0 1
7801: PUSH
7802: LD_VAR 0 3
7806: IN
7807: ST_TO_ADDR
// end ;
7808: LD_VAR 0 3
7812: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
7813: LD_INT 0
7815: PPUSH
// if not chassis or not weapon then
7816: LD_VAR 0 1
7820: NOT
7821: PUSH
7822: LD_VAR 0 2
7826: NOT
7827: OR
7828: IFFALSE 7832
// exit ;
7830: GO 8858
// case weapon of us_machine_gun :
7832: LD_VAR 0 2
7836: PUSH
7837: LD_INT 2
7839: DOUBLE
7840: EQUAL
7841: IFTRUE 7845
7843: GO 7875
7845: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_INT 1
7853: PUSH
7854: LD_INT 2
7856: PUSH
7857: LD_INT 3
7859: PUSH
7860: LD_INT 4
7862: PUSH
7863: LD_INT 5
7865: PUSH
7866: EMPTY
7867: LIST
7868: LIST
7869: LIST
7870: LIST
7871: LIST
7872: ST_TO_ADDR
7873: GO 8842
7875: LD_INT 3
7877: DOUBLE
7878: EQUAL
7879: IFTRUE 7883
7881: GO 7913
7883: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
7884: LD_ADDR_VAR 0 3
7888: PUSH
7889: LD_INT 1
7891: PUSH
7892: LD_INT 2
7894: PUSH
7895: LD_INT 3
7897: PUSH
7898: LD_INT 4
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: EMPTY
7905: LIST
7906: LIST
7907: LIST
7908: LIST
7909: LIST
7910: ST_TO_ADDR
7911: GO 8842
7913: LD_INT 11
7915: DOUBLE
7916: EQUAL
7917: IFTRUE 7921
7919: GO 7951
7921: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
7922: LD_ADDR_VAR 0 3
7926: PUSH
7927: LD_INT 1
7929: PUSH
7930: LD_INT 2
7932: PUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 4
7938: PUSH
7939: LD_INT 5
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: LIST
7946: LIST
7947: LIST
7948: ST_TO_ADDR
7949: GO 8842
7951: LD_INT 4
7953: DOUBLE
7954: EQUAL
7955: IFTRUE 7959
7957: GO 7985
7959: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
7960: LD_ADDR_VAR 0 3
7964: PUSH
7965: LD_INT 2
7967: PUSH
7968: LD_INT 3
7970: PUSH
7971: LD_INT 4
7973: PUSH
7974: LD_INT 5
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: LIST
7981: LIST
7982: ST_TO_ADDR
7983: GO 8842
7985: LD_INT 5
7987: DOUBLE
7988: EQUAL
7989: IFTRUE 7993
7991: GO 8019
7993: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
7994: LD_ADDR_VAR 0 3
7998: PUSH
7999: LD_INT 2
8001: PUSH
8002: LD_INT 3
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 5
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: ST_TO_ADDR
8017: GO 8842
8019: LD_INT 9
8021: DOUBLE
8022: EQUAL
8023: IFTRUE 8027
8025: GO 8053
8027: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
8028: LD_ADDR_VAR 0 3
8032: PUSH
8033: LD_INT 2
8035: PUSH
8036: LD_INT 3
8038: PUSH
8039: LD_INT 4
8041: PUSH
8042: LD_INT 5
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: LIST
8049: LIST
8050: ST_TO_ADDR
8051: GO 8842
8053: LD_INT 7
8055: DOUBLE
8056: EQUAL
8057: IFTRUE 8061
8059: GO 8087
8061: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
8062: LD_ADDR_VAR 0 3
8066: PUSH
8067: LD_INT 2
8069: PUSH
8070: LD_INT 3
8072: PUSH
8073: LD_INT 4
8075: PUSH
8076: LD_INT 5
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: LIST
8083: LIST
8084: ST_TO_ADDR
8085: GO 8842
8087: LD_INT 12
8089: DOUBLE
8090: EQUAL
8091: IFTRUE 8095
8093: GO 8121
8095: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
8096: LD_ADDR_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: PUSH
8104: LD_INT 3
8106: PUSH
8107: LD_INT 4
8109: PUSH
8110: LD_INT 5
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: LIST
8117: LIST
8118: ST_TO_ADDR
8119: GO 8842
8121: LD_INT 13
8123: DOUBLE
8124: EQUAL
8125: IFTRUE 8129
8127: GO 8155
8129: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
8130: LD_ADDR_VAR 0 3
8134: PUSH
8135: LD_INT 2
8137: PUSH
8138: LD_INT 3
8140: PUSH
8141: LD_INT 4
8143: PUSH
8144: LD_INT 5
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: LIST
8151: LIST
8152: ST_TO_ADDR
8153: GO 8842
8155: LD_INT 14
8157: DOUBLE
8158: EQUAL
8159: IFTRUE 8163
8161: GO 8181
8163: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
8164: LD_ADDR_VAR 0 3
8168: PUSH
8169: LD_INT 4
8171: PUSH
8172: LD_INT 5
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: ST_TO_ADDR
8179: GO 8842
8181: LD_INT 6
8183: DOUBLE
8184: EQUAL
8185: IFTRUE 8189
8187: GO 8207
8189: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
8190: LD_ADDR_VAR 0 3
8194: PUSH
8195: LD_INT 4
8197: PUSH
8198: LD_INT 5
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
8205: GO 8842
8207: LD_INT 10
8209: DOUBLE
8210: EQUAL
8211: IFTRUE 8215
8213: GO 8233
8215: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
8216: LD_ADDR_VAR 0 3
8220: PUSH
8221: LD_INT 4
8223: PUSH
8224: LD_INT 5
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: ST_TO_ADDR
8231: GO 8842
8233: LD_INT 22
8235: DOUBLE
8236: EQUAL
8237: IFTRUE 8241
8239: GO 8267
8241: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
8242: LD_ADDR_VAR 0 3
8246: PUSH
8247: LD_INT 11
8249: PUSH
8250: LD_INT 12
8252: PUSH
8253: LD_INT 13
8255: PUSH
8256: LD_INT 14
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: ST_TO_ADDR
8265: GO 8842
8267: LD_INT 23
8269: DOUBLE
8270: EQUAL
8271: IFTRUE 8275
8273: GO 8301
8275: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
8276: LD_ADDR_VAR 0 3
8280: PUSH
8281: LD_INT 11
8283: PUSH
8284: LD_INT 12
8286: PUSH
8287: LD_INT 13
8289: PUSH
8290: LD_INT 14
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: LIST
8297: LIST
8298: ST_TO_ADDR
8299: GO 8842
8301: LD_INT 24
8303: DOUBLE
8304: EQUAL
8305: IFTRUE 8309
8307: GO 8335
8309: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
8310: LD_ADDR_VAR 0 3
8314: PUSH
8315: LD_INT 11
8317: PUSH
8318: LD_INT 12
8320: PUSH
8321: LD_INT 13
8323: PUSH
8324: LD_INT 14
8326: PUSH
8327: EMPTY
8328: LIST
8329: LIST
8330: LIST
8331: LIST
8332: ST_TO_ADDR
8333: GO 8842
8335: LD_INT 30
8337: DOUBLE
8338: EQUAL
8339: IFTRUE 8343
8341: GO 8369
8343: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
8344: LD_ADDR_VAR 0 3
8348: PUSH
8349: LD_INT 11
8351: PUSH
8352: LD_INT 12
8354: PUSH
8355: LD_INT 13
8357: PUSH
8358: LD_INT 14
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
8367: GO 8842
8369: LD_INT 25
8371: DOUBLE
8372: EQUAL
8373: IFTRUE 8377
8375: GO 8395
8377: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
8378: LD_ADDR_VAR 0 3
8382: PUSH
8383: LD_INT 13
8385: PUSH
8386: LD_INT 14
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: ST_TO_ADDR
8393: GO 8842
8395: LD_INT 27
8397: DOUBLE
8398: EQUAL
8399: IFTRUE 8403
8401: GO 8421
8403: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_INT 13
8411: PUSH
8412: LD_INT 14
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: ST_TO_ADDR
8419: GO 8842
8421: LD_INT 28
8423: DOUBLE
8424: EQUAL
8425: IFTRUE 8429
8427: GO 8447
8429: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
8430: LD_ADDR_VAR 0 3
8434: PUSH
8435: LD_INT 13
8437: PUSH
8438: LD_INT 14
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: ST_TO_ADDR
8445: GO 8842
8447: LD_INT 29
8449: DOUBLE
8450: EQUAL
8451: IFTRUE 8455
8453: GO 8473
8455: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
8456: LD_ADDR_VAR 0 3
8460: PUSH
8461: LD_INT 13
8463: PUSH
8464: LD_INT 14
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: ST_TO_ADDR
8471: GO 8842
8473: LD_INT 31
8475: DOUBLE
8476: EQUAL
8477: IFTRUE 8481
8479: GO 8499
8481: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
8482: LD_ADDR_VAR 0 3
8486: PUSH
8487: LD_INT 13
8489: PUSH
8490: LD_INT 14
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: ST_TO_ADDR
8497: GO 8842
8499: LD_INT 26
8501: DOUBLE
8502: EQUAL
8503: IFTRUE 8507
8505: GO 8525
8507: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
8508: LD_ADDR_VAR 0 3
8512: PUSH
8513: LD_INT 13
8515: PUSH
8516: LD_INT 14
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: ST_TO_ADDR
8523: GO 8842
8525: LD_INT 42
8527: DOUBLE
8528: EQUAL
8529: IFTRUE 8533
8531: GO 8559
8533: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
8534: LD_ADDR_VAR 0 3
8538: PUSH
8539: LD_INT 21
8541: PUSH
8542: LD_INT 22
8544: PUSH
8545: LD_INT 23
8547: PUSH
8548: LD_INT 24
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: ST_TO_ADDR
8557: GO 8842
8559: LD_INT 43
8561: DOUBLE
8562: EQUAL
8563: IFTRUE 8567
8565: GO 8593
8567: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
8568: LD_ADDR_VAR 0 3
8572: PUSH
8573: LD_INT 21
8575: PUSH
8576: LD_INT 22
8578: PUSH
8579: LD_INT 23
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: ST_TO_ADDR
8591: GO 8842
8593: LD_INT 44
8595: DOUBLE
8596: EQUAL
8597: IFTRUE 8601
8599: GO 8627
8601: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
8602: LD_ADDR_VAR 0 3
8606: PUSH
8607: LD_INT 21
8609: PUSH
8610: LD_INT 22
8612: PUSH
8613: LD_INT 23
8615: PUSH
8616: LD_INT 24
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: LIST
8624: ST_TO_ADDR
8625: GO 8842
8627: LD_INT 45
8629: DOUBLE
8630: EQUAL
8631: IFTRUE 8635
8633: GO 8661
8635: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
8636: LD_ADDR_VAR 0 3
8640: PUSH
8641: LD_INT 21
8643: PUSH
8644: LD_INT 22
8646: PUSH
8647: LD_INT 23
8649: PUSH
8650: LD_INT 24
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: ST_TO_ADDR
8659: GO 8842
8661: LD_INT 49
8663: DOUBLE
8664: EQUAL
8665: IFTRUE 8669
8667: GO 8695
8669: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
8670: LD_ADDR_VAR 0 3
8674: PUSH
8675: LD_INT 21
8677: PUSH
8678: LD_INT 22
8680: PUSH
8681: LD_INT 23
8683: PUSH
8684: LD_INT 24
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: ST_TO_ADDR
8693: GO 8842
8695: LD_INT 51
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8729
8703: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_INT 21
8711: PUSH
8712: LD_INT 22
8714: PUSH
8715: LD_INT 23
8717: PUSH
8718: LD_INT 24
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: LIST
8725: LIST
8726: ST_TO_ADDR
8727: GO 8842
8729: LD_INT 52
8731: DOUBLE
8732: EQUAL
8733: IFTRUE 8737
8735: GO 8763
8737: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
8738: LD_ADDR_VAR 0 3
8742: PUSH
8743: LD_INT 21
8745: PUSH
8746: LD_INT 22
8748: PUSH
8749: LD_INT 23
8751: PUSH
8752: LD_INT 24
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: ST_TO_ADDR
8761: GO 8842
8763: LD_INT 53
8765: DOUBLE
8766: EQUAL
8767: IFTRUE 8771
8769: GO 8789
8771: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
8772: LD_ADDR_VAR 0 3
8776: PUSH
8777: LD_INT 23
8779: PUSH
8780: LD_INT 24
8782: PUSH
8783: EMPTY
8784: LIST
8785: LIST
8786: ST_TO_ADDR
8787: GO 8842
8789: LD_INT 46
8791: DOUBLE
8792: EQUAL
8793: IFTRUE 8797
8795: GO 8815
8797: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
8798: LD_ADDR_VAR 0 3
8802: PUSH
8803: LD_INT 23
8805: PUSH
8806: LD_INT 24
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: ST_TO_ADDR
8813: GO 8842
8815: LD_INT 47
8817: DOUBLE
8818: EQUAL
8819: IFTRUE 8823
8821: GO 8841
8823: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
8824: LD_ADDR_VAR 0 3
8828: PUSH
8829: LD_INT 23
8831: PUSH
8832: LD_INT 24
8834: PUSH
8835: EMPTY
8836: LIST
8837: LIST
8838: ST_TO_ADDR
8839: GO 8842
8841: POP
// result := ( chassis in result ) ;
8842: LD_ADDR_VAR 0 3
8846: PUSH
8847: LD_VAR 0 1
8851: PUSH
8852: LD_VAR 0 3
8856: IN
8857: ST_TO_ADDR
// end ;
8858: LD_VAR 0 3
8862: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
8863: LD_INT 0
8865: PPUSH
8866: PPUSH
8867: PPUSH
8868: PPUSH
8869: PPUSH
8870: PPUSH
8871: PPUSH
// result := array ;
8872: LD_ADDR_VAR 0 5
8876: PUSH
8877: LD_VAR 0 1
8881: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
8882: LD_VAR 0 1
8886: NOT
8887: PUSH
8888: LD_VAR 0 2
8892: NOT
8893: OR
8894: PUSH
8895: LD_VAR 0 3
8899: NOT
8900: OR
8901: PUSH
8902: LD_VAR 0 2
8906: PUSH
8907: LD_VAR 0 1
8911: GREATER
8912: OR
8913: PUSH
8914: LD_VAR 0 3
8918: PUSH
8919: LD_VAR 0 1
8923: GREATER
8924: OR
8925: IFFALSE 8929
// exit ;
8927: GO 9225
// if direction then
8929: LD_VAR 0 4
8933: IFFALSE 8997
// begin d := 1 ;
8935: LD_ADDR_VAR 0 9
8939: PUSH
8940: LD_INT 1
8942: ST_TO_ADDR
// if i_from > i_to then
8943: LD_VAR 0 2
8947: PUSH
8948: LD_VAR 0 3
8952: GREATER
8953: IFFALSE 8979
// length := ( array - i_from ) + i_to else
8955: LD_ADDR_VAR 0 11
8959: PUSH
8960: LD_VAR 0 1
8964: PUSH
8965: LD_VAR 0 2
8969: MINUS
8970: PUSH
8971: LD_VAR 0 3
8975: PLUS
8976: ST_TO_ADDR
8977: GO 8995
// length := i_to - i_from ;
8979: LD_ADDR_VAR 0 11
8983: PUSH
8984: LD_VAR 0 3
8988: PUSH
8989: LD_VAR 0 2
8993: MINUS
8994: ST_TO_ADDR
// end else
8995: GO 9058
// begin d := - 1 ;
8997: LD_ADDR_VAR 0 9
9001: PUSH
9002: LD_INT 1
9004: NEG
9005: ST_TO_ADDR
// if i_from > i_to then
9006: LD_VAR 0 2
9010: PUSH
9011: LD_VAR 0 3
9015: GREATER
9016: IFFALSE 9036
// length := i_from - i_to else
9018: LD_ADDR_VAR 0 11
9022: PUSH
9023: LD_VAR 0 2
9027: PUSH
9028: LD_VAR 0 3
9032: MINUS
9033: ST_TO_ADDR
9034: GO 9058
// length := ( array - i_to ) + i_from ;
9036: LD_ADDR_VAR 0 11
9040: PUSH
9041: LD_VAR 0 1
9045: PUSH
9046: LD_VAR 0 3
9050: MINUS
9051: PUSH
9052: LD_VAR 0 2
9056: PLUS
9057: ST_TO_ADDR
// end ; if not length then
9058: LD_VAR 0 11
9062: NOT
9063: IFFALSE 9067
// exit ;
9065: GO 9225
// tmp := array ;
9067: LD_ADDR_VAR 0 10
9071: PUSH
9072: LD_VAR 0 1
9076: ST_TO_ADDR
// for i = 1 to length do
9077: LD_ADDR_VAR 0 6
9081: PUSH
9082: DOUBLE
9083: LD_INT 1
9085: DEC
9086: ST_TO_ADDR
9087: LD_VAR 0 11
9091: PUSH
9092: FOR_TO
9093: IFFALSE 9213
// begin for j = 1 to array do
9095: LD_ADDR_VAR 0 7
9099: PUSH
9100: DOUBLE
9101: LD_INT 1
9103: DEC
9104: ST_TO_ADDR
9105: LD_VAR 0 1
9109: PUSH
9110: FOR_TO
9111: IFFALSE 9199
// begin k := j + d ;
9113: LD_ADDR_VAR 0 8
9117: PUSH
9118: LD_VAR 0 7
9122: PUSH
9123: LD_VAR 0 9
9127: PLUS
9128: ST_TO_ADDR
// if k > array then
9129: LD_VAR 0 8
9133: PUSH
9134: LD_VAR 0 1
9138: GREATER
9139: IFFALSE 9149
// k := 1 ;
9141: LD_ADDR_VAR 0 8
9145: PUSH
9146: LD_INT 1
9148: ST_TO_ADDR
// if not k then
9149: LD_VAR 0 8
9153: NOT
9154: IFFALSE 9166
// k := array ;
9156: LD_ADDR_VAR 0 8
9160: PUSH
9161: LD_VAR 0 1
9165: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
9166: LD_ADDR_VAR 0 10
9170: PUSH
9171: LD_VAR 0 10
9175: PPUSH
9176: LD_VAR 0 8
9180: PPUSH
9181: LD_VAR 0 1
9185: PUSH
9186: LD_VAR 0 7
9190: ARRAY
9191: PPUSH
9192: CALL_OW 1
9196: ST_TO_ADDR
// end ;
9197: GO 9110
9199: POP
9200: POP
// array := tmp ;
9201: LD_ADDR_VAR 0 1
9205: PUSH
9206: LD_VAR 0 10
9210: ST_TO_ADDR
// end ;
9211: GO 9092
9213: POP
9214: POP
// result := array ;
9215: LD_ADDR_VAR 0 5
9219: PUSH
9220: LD_VAR 0 1
9224: ST_TO_ADDR
// end ;
9225: LD_VAR 0 5
9229: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
9230: LD_INT 0
9232: PPUSH
9233: PPUSH
// result := 0 ;
9234: LD_ADDR_VAR 0 3
9238: PUSH
9239: LD_INT 0
9241: ST_TO_ADDR
// if not array or not value in array then
9242: LD_VAR 0 1
9246: NOT
9247: PUSH
9248: LD_VAR 0 2
9252: PUSH
9253: LD_VAR 0 1
9257: IN
9258: NOT
9259: OR
9260: IFFALSE 9264
// exit ;
9262: GO 9318
// for i = 1 to array do
9264: LD_ADDR_VAR 0 4
9268: PUSH
9269: DOUBLE
9270: LD_INT 1
9272: DEC
9273: ST_TO_ADDR
9274: LD_VAR 0 1
9278: PUSH
9279: FOR_TO
9280: IFFALSE 9316
// if value = array [ i ] then
9282: LD_VAR 0 2
9286: PUSH
9287: LD_VAR 0 1
9291: PUSH
9292: LD_VAR 0 4
9296: ARRAY
9297: EQUAL
9298: IFFALSE 9314
// begin result := i ;
9300: LD_ADDR_VAR 0 3
9304: PUSH
9305: LD_VAR 0 4
9309: ST_TO_ADDR
// exit ;
9310: POP
9311: POP
9312: GO 9318
// end ;
9314: GO 9279
9316: POP
9317: POP
// end ;
9318: LD_VAR 0 3
9322: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
9323: LD_INT 0
9325: PPUSH
// vc_chassis := chassis ;
9326: LD_ADDR_OWVAR 37
9330: PUSH
9331: LD_VAR 0 1
9335: ST_TO_ADDR
// vc_engine := engine ;
9336: LD_ADDR_OWVAR 39
9340: PUSH
9341: LD_VAR 0 2
9345: ST_TO_ADDR
// vc_control := control ;
9346: LD_ADDR_OWVAR 38
9350: PUSH
9351: LD_VAR 0 3
9355: ST_TO_ADDR
// vc_weapon := weapon ;
9356: LD_ADDR_OWVAR 40
9360: PUSH
9361: LD_VAR 0 4
9365: ST_TO_ADDR
// vc_fuel_battery := fuel ;
9366: LD_ADDR_OWVAR 41
9370: PUSH
9371: LD_VAR 0 5
9375: ST_TO_ADDR
// end ;
9376: LD_VAR 0 6
9380: RET
// export function WantPlant ( unit ) ; var task ; begin
9381: LD_INT 0
9383: PPUSH
9384: PPUSH
// result := false ;
9385: LD_ADDR_VAR 0 2
9389: PUSH
9390: LD_INT 0
9392: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
9393: LD_ADDR_VAR 0 3
9397: PUSH
9398: LD_VAR 0 1
9402: PPUSH
9403: CALL_OW 437
9407: ST_TO_ADDR
// if task then
9408: LD_VAR 0 3
9412: IFFALSE 9440
// if task [ 1 ] [ 1 ] = p then
9414: LD_VAR 0 3
9418: PUSH
9419: LD_INT 1
9421: ARRAY
9422: PUSH
9423: LD_INT 1
9425: ARRAY
9426: PUSH
9427: LD_STRING p
9429: EQUAL
9430: IFFALSE 9440
// result := true ;
9432: LD_ADDR_VAR 0 2
9436: PUSH
9437: LD_INT 1
9439: ST_TO_ADDR
// end ;
9440: LD_VAR 0 2
9444: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
9445: LD_INT 0
9447: PPUSH
9448: PPUSH
9449: PPUSH
9450: PPUSH
// if pos < 1 then
9451: LD_VAR 0 2
9455: PUSH
9456: LD_INT 1
9458: LESS
9459: IFFALSE 9463
// exit ;
9461: GO 9766
// if pos = 1 then
9463: LD_VAR 0 2
9467: PUSH
9468: LD_INT 1
9470: EQUAL
9471: IFFALSE 9504
// result := Replace ( arr , pos [ 1 ] , value ) else
9473: LD_ADDR_VAR 0 4
9477: PUSH
9478: LD_VAR 0 1
9482: PPUSH
9483: LD_VAR 0 2
9487: PUSH
9488: LD_INT 1
9490: ARRAY
9491: PPUSH
9492: LD_VAR 0 3
9496: PPUSH
9497: CALL_OW 1
9501: ST_TO_ADDR
9502: GO 9766
// begin tmp := arr ;
9504: LD_ADDR_VAR 0 6
9508: PUSH
9509: LD_VAR 0 1
9513: ST_TO_ADDR
// s_arr := [ tmp ] ;
9514: LD_ADDR_VAR 0 7
9518: PUSH
9519: LD_VAR 0 6
9523: PUSH
9524: EMPTY
9525: LIST
9526: ST_TO_ADDR
// for i = 1 to pos - 1 do
9527: LD_ADDR_VAR 0 5
9531: PUSH
9532: DOUBLE
9533: LD_INT 1
9535: DEC
9536: ST_TO_ADDR
9537: LD_VAR 0 2
9541: PUSH
9542: LD_INT 1
9544: MINUS
9545: PUSH
9546: FOR_TO
9547: IFFALSE 9592
// begin tmp := tmp [ pos [ i ] ] ;
9549: LD_ADDR_VAR 0 6
9553: PUSH
9554: LD_VAR 0 6
9558: PUSH
9559: LD_VAR 0 2
9563: PUSH
9564: LD_VAR 0 5
9568: ARRAY
9569: ARRAY
9570: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
9571: LD_ADDR_VAR 0 7
9575: PUSH
9576: LD_VAR 0 7
9580: PUSH
9581: LD_VAR 0 6
9585: PUSH
9586: EMPTY
9587: LIST
9588: ADD
9589: ST_TO_ADDR
// end ;
9590: GO 9546
9592: POP
9593: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
9594: LD_ADDR_VAR 0 6
9598: PUSH
9599: LD_VAR 0 6
9603: PPUSH
9604: LD_VAR 0 2
9608: PUSH
9609: LD_VAR 0 2
9613: ARRAY
9614: PPUSH
9615: LD_VAR 0 3
9619: PPUSH
9620: CALL_OW 1
9624: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
9625: LD_ADDR_VAR 0 7
9629: PUSH
9630: LD_VAR 0 7
9634: PPUSH
9635: LD_VAR 0 7
9639: PPUSH
9640: LD_VAR 0 6
9644: PPUSH
9645: CALL_OW 1
9649: ST_TO_ADDR
// for i = s_arr downto 2 do
9650: LD_ADDR_VAR 0 5
9654: PUSH
9655: DOUBLE
9656: LD_VAR 0 7
9660: INC
9661: ST_TO_ADDR
9662: LD_INT 2
9664: PUSH
9665: FOR_DOWNTO
9666: IFFALSE 9750
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
9668: LD_ADDR_VAR 0 6
9672: PUSH
9673: LD_VAR 0 7
9677: PUSH
9678: LD_VAR 0 5
9682: PUSH
9683: LD_INT 1
9685: MINUS
9686: ARRAY
9687: PPUSH
9688: LD_VAR 0 2
9692: PUSH
9693: LD_VAR 0 5
9697: PUSH
9698: LD_INT 1
9700: MINUS
9701: ARRAY
9702: PPUSH
9703: LD_VAR 0 7
9707: PUSH
9708: LD_VAR 0 5
9712: ARRAY
9713: PPUSH
9714: CALL_OW 1
9718: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
9719: LD_ADDR_VAR 0 7
9723: PUSH
9724: LD_VAR 0 7
9728: PPUSH
9729: LD_VAR 0 5
9733: PUSH
9734: LD_INT 1
9736: MINUS
9737: PPUSH
9738: LD_VAR 0 6
9742: PPUSH
9743: CALL_OW 1
9747: ST_TO_ADDR
// end ;
9748: GO 9665
9750: POP
9751: POP
// result := s_arr [ 1 ] ;
9752: LD_ADDR_VAR 0 4
9756: PUSH
9757: LD_VAR 0 7
9761: PUSH
9762: LD_INT 1
9764: ARRAY
9765: ST_TO_ADDR
// end ; end ;
9766: LD_VAR 0 4
9770: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
9771: LD_INT 0
9773: PPUSH
9774: PPUSH
// if not list then
9775: LD_VAR 0 1
9779: NOT
9780: IFFALSE 9784
// exit ;
9782: GO 9875
// i := list [ pos1 ] ;
9784: LD_ADDR_VAR 0 5
9788: PUSH
9789: LD_VAR 0 1
9793: PUSH
9794: LD_VAR 0 2
9798: ARRAY
9799: ST_TO_ADDR
// if not i then
9800: LD_VAR 0 5
9804: NOT
9805: IFFALSE 9809
// exit ;
9807: GO 9875
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
9809: LD_ADDR_VAR 0 1
9813: PUSH
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_VAR 0 2
9823: PPUSH
9824: LD_VAR 0 1
9828: PUSH
9829: LD_VAR 0 3
9833: ARRAY
9834: PPUSH
9835: CALL_OW 1
9839: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
9840: LD_ADDR_VAR 0 1
9844: PUSH
9845: LD_VAR 0 1
9849: PPUSH
9850: LD_VAR 0 3
9854: PPUSH
9855: LD_VAR 0 5
9859: PPUSH
9860: CALL_OW 1
9864: ST_TO_ADDR
// result := list ;
9865: LD_ADDR_VAR 0 4
9869: PUSH
9870: LD_VAR 0 1
9874: ST_TO_ADDR
// end ;
9875: LD_VAR 0 4
9879: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
9880: LD_INT 0
9882: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
9883: LD_ADDR_VAR 0 5
9887: PUSH
9888: LD_VAR 0 1
9892: PPUSH
9893: CALL_OW 250
9897: PPUSH
9898: LD_VAR 0 1
9902: PPUSH
9903: CALL_OW 251
9907: PPUSH
9908: LD_VAR 0 2
9912: PPUSH
9913: LD_VAR 0 3
9917: PPUSH
9918: LD_VAR 0 4
9922: PPUSH
9923: CALL 9933 0 5
9927: ST_TO_ADDR
// end ;
9928: LD_VAR 0 5
9932: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
9933: LD_INT 0
9935: PPUSH
9936: PPUSH
9937: PPUSH
9938: PPUSH
// if not list then
9939: LD_VAR 0 3
9943: NOT
9944: IFFALSE 9948
// exit ;
9946: GO 10336
// result := [ ] ;
9948: LD_ADDR_VAR 0 6
9952: PUSH
9953: EMPTY
9954: ST_TO_ADDR
// for i in list do
9955: LD_ADDR_VAR 0 7
9959: PUSH
9960: LD_VAR 0 3
9964: PUSH
9965: FOR_IN
9966: IFFALSE 10168
// begin tmp := GetDistUnitXY ( i , x , y ) ;
9968: LD_ADDR_VAR 0 9
9972: PUSH
9973: LD_VAR 0 7
9977: PPUSH
9978: LD_VAR 0 1
9982: PPUSH
9983: LD_VAR 0 2
9987: PPUSH
9988: CALL_OW 297
9992: ST_TO_ADDR
// if not result then
9993: LD_VAR 0 6
9997: NOT
9998: IFFALSE 10024
// result := [ [ i , tmp ] ] else
10000: LD_ADDR_VAR 0 6
10004: PUSH
10005: LD_VAR 0 7
10009: PUSH
10010: LD_VAR 0 9
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: EMPTY
10020: LIST
10021: ST_TO_ADDR
10022: GO 10166
// begin if result [ result ] [ 2 ] < tmp then
10024: LD_VAR 0 6
10028: PUSH
10029: LD_VAR 0 6
10033: ARRAY
10034: PUSH
10035: LD_INT 2
10037: ARRAY
10038: PUSH
10039: LD_VAR 0 9
10043: LESS
10044: IFFALSE 10086
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
10046: LD_ADDR_VAR 0 6
10050: PUSH
10051: LD_VAR 0 6
10055: PPUSH
10056: LD_VAR 0 6
10060: PUSH
10061: LD_INT 1
10063: PLUS
10064: PPUSH
10065: LD_VAR 0 7
10069: PUSH
10070: LD_VAR 0 9
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 2
10083: ST_TO_ADDR
10084: GO 10166
// for j = 1 to result do
10086: LD_ADDR_VAR 0 8
10090: PUSH
10091: DOUBLE
10092: LD_INT 1
10094: DEC
10095: ST_TO_ADDR
10096: LD_VAR 0 6
10100: PUSH
10101: FOR_TO
10102: IFFALSE 10164
// begin if tmp < result [ j ] [ 2 ] then
10104: LD_VAR 0 9
10108: PUSH
10109: LD_VAR 0 6
10113: PUSH
10114: LD_VAR 0 8
10118: ARRAY
10119: PUSH
10120: LD_INT 2
10122: ARRAY
10123: LESS
10124: IFFALSE 10162
// begin result := Insert ( result , j , [ i , tmp ] ) ;
10126: LD_ADDR_VAR 0 6
10130: PUSH
10131: LD_VAR 0 6
10135: PPUSH
10136: LD_VAR 0 8
10140: PPUSH
10141: LD_VAR 0 7
10145: PUSH
10146: LD_VAR 0 9
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PPUSH
10155: CALL_OW 2
10159: ST_TO_ADDR
// break ;
10160: GO 10164
// end ; end ;
10162: GO 10101
10164: POP
10165: POP
// end ; end ;
10166: GO 9965
10168: POP
10169: POP
// if result and not asc then
10170: LD_VAR 0 6
10174: PUSH
10175: LD_VAR 0 4
10179: NOT
10180: AND
10181: IFFALSE 10256
// begin tmp := result ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_VAR 0 6
10192: ST_TO_ADDR
// for i = tmp downto 1 do
10193: LD_ADDR_VAR 0 7
10197: PUSH
10198: DOUBLE
10199: LD_VAR 0 9
10203: INC
10204: ST_TO_ADDR
10205: LD_INT 1
10207: PUSH
10208: FOR_DOWNTO
10209: IFFALSE 10254
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
10211: LD_ADDR_VAR 0 6
10215: PUSH
10216: LD_VAR 0 6
10220: PPUSH
10221: LD_VAR 0 9
10225: PUSH
10226: LD_VAR 0 7
10230: MINUS
10231: PUSH
10232: LD_INT 1
10234: PLUS
10235: PPUSH
10236: LD_VAR 0 9
10240: PUSH
10241: LD_VAR 0 7
10245: ARRAY
10246: PPUSH
10247: CALL_OW 1
10251: ST_TO_ADDR
10252: GO 10208
10254: POP
10255: POP
// end ; tmp := [ ] ;
10256: LD_ADDR_VAR 0 9
10260: PUSH
10261: EMPTY
10262: ST_TO_ADDR
// if mode then
10263: LD_VAR 0 5
10267: IFFALSE 10336
// begin for i = 1 to result do
10269: LD_ADDR_VAR 0 7
10273: PUSH
10274: DOUBLE
10275: LD_INT 1
10277: DEC
10278: ST_TO_ADDR
10279: LD_VAR 0 6
10283: PUSH
10284: FOR_TO
10285: IFFALSE 10324
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
10287: LD_ADDR_VAR 0 9
10291: PUSH
10292: LD_VAR 0 9
10296: PPUSH
10297: LD_VAR 0 7
10301: PPUSH
10302: LD_VAR 0 6
10306: PUSH
10307: LD_VAR 0 7
10311: ARRAY
10312: PUSH
10313: LD_INT 1
10315: ARRAY
10316: PPUSH
10317: CALL_OW 1
10321: ST_TO_ADDR
10322: GO 10284
10324: POP
10325: POP
// result := tmp ;
10326: LD_ADDR_VAR 0 6
10330: PUSH
10331: LD_VAR 0 9
10335: ST_TO_ADDR
// end ; end ;
10336: LD_VAR 0 6
10340: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
10341: LD_INT 0
10343: PPUSH
10344: PPUSH
10345: PPUSH
10346: PPUSH
10347: PPUSH
10348: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
10349: LD_ADDR_VAR 0 5
10353: PUSH
10354: LD_INT 0
10356: PUSH
10357: LD_INT 0
10359: PUSH
10360: LD_INT 0
10362: PUSH
10363: EMPTY
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: ST_TO_ADDR
// if not x or not y then
10371: LD_VAR 0 2
10375: NOT
10376: PUSH
10377: LD_VAR 0 3
10381: NOT
10382: OR
10383: IFFALSE 10387
// exit ;
10385: GO 12033
// if not range then
10387: LD_VAR 0 4
10391: NOT
10392: IFFALSE 10402
// range := 10 ;
10394: LD_ADDR_VAR 0 4
10398: PUSH
10399: LD_INT 10
10401: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10402: LD_ADDR_VAR 0 8
10406: PUSH
10407: LD_INT 81
10409: PUSH
10410: LD_VAR 0 1
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 92
10421: PUSH
10422: LD_VAR 0 2
10426: PUSH
10427: LD_VAR 0 3
10431: PUSH
10432: LD_VAR 0 4
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: PUSH
10443: LD_INT 3
10445: PUSH
10446: LD_INT 21
10448: PUSH
10449: LD_INT 3
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: LIST
10464: PPUSH
10465: CALL_OW 69
10469: ST_TO_ADDR
// if not tmp then
10470: LD_VAR 0 8
10474: NOT
10475: IFFALSE 10479
// exit ;
10477: GO 12033
// for i in tmp do
10479: LD_ADDR_VAR 0 6
10483: PUSH
10484: LD_VAR 0 8
10488: PUSH
10489: FOR_IN
10490: IFFALSE 12008
// begin points := [ 0 , 0 , 0 ] ;
10492: LD_ADDR_VAR 0 9
10496: PUSH
10497: LD_INT 0
10499: PUSH
10500: LD_INT 0
10502: PUSH
10503: LD_INT 0
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: ST_TO_ADDR
// bpoints := 1 ;
10511: LD_ADDR_VAR 0 10
10515: PUSH
10516: LD_INT 1
10518: ST_TO_ADDR
// case GetType ( i ) of unit_human :
10519: LD_VAR 0 6
10523: PPUSH
10524: CALL_OW 247
10528: PUSH
10529: LD_INT 1
10531: DOUBLE
10532: EQUAL
10533: IFTRUE 10537
10535: GO 11115
10537: POP
// begin if GetClass ( i ) = 1 then
10538: LD_VAR 0 6
10542: PPUSH
10543: CALL_OW 257
10547: PUSH
10548: LD_INT 1
10550: EQUAL
10551: IFFALSE 10572
// points := [ 10 , 5 , 3 ] ;
10553: LD_ADDR_VAR 0 9
10557: PUSH
10558: LD_INT 10
10560: PUSH
10561: LD_INT 5
10563: PUSH
10564: LD_INT 3
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
10572: LD_VAR 0 6
10576: PPUSH
10577: CALL_OW 257
10581: PUSH
10582: LD_INT 2
10584: PUSH
10585: LD_INT 3
10587: PUSH
10588: LD_INT 4
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: LIST
10595: IN
10596: IFFALSE 10617
// points := [ 3 , 2 , 1 ] ;
10598: LD_ADDR_VAR 0 9
10602: PUSH
10603: LD_INT 3
10605: PUSH
10606: LD_INT 2
10608: PUSH
10609: LD_INT 1
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: LIST
10616: ST_TO_ADDR
// if GetClass ( i ) = 5 then
10617: LD_VAR 0 6
10621: PPUSH
10622: CALL_OW 257
10626: PUSH
10627: LD_INT 5
10629: EQUAL
10630: IFFALSE 10651
// points := [ 130 , 5 , 2 ] ;
10632: LD_ADDR_VAR 0 9
10636: PUSH
10637: LD_INT 130
10639: PUSH
10640: LD_INT 5
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: ST_TO_ADDR
// if GetClass ( i ) = 8 then
10651: LD_VAR 0 6
10655: PPUSH
10656: CALL_OW 257
10660: PUSH
10661: LD_INT 8
10663: EQUAL
10664: IFFALSE 10685
// points := [ 35 , 35 , 30 ] ;
10666: LD_ADDR_VAR 0 9
10670: PUSH
10671: LD_INT 35
10673: PUSH
10674: LD_INT 35
10676: PUSH
10677: LD_INT 30
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: LIST
10684: ST_TO_ADDR
// if GetClass ( i ) = 9 then
10685: LD_VAR 0 6
10689: PPUSH
10690: CALL_OW 257
10694: PUSH
10695: LD_INT 9
10697: EQUAL
10698: IFFALSE 10719
// points := [ 20 , 55 , 40 ] ;
10700: LD_ADDR_VAR 0 9
10704: PUSH
10705: LD_INT 20
10707: PUSH
10708: LD_INT 55
10710: PUSH
10711: LD_INT 40
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
10719: LD_VAR 0 6
10723: PPUSH
10724: CALL_OW 257
10728: PUSH
10729: LD_INT 12
10731: PUSH
10732: LD_INT 16
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: IN
10739: IFFALSE 10760
// points := [ 5 , 3 , 2 ] ;
10741: LD_ADDR_VAR 0 9
10745: PUSH
10746: LD_INT 5
10748: PUSH
10749: LD_INT 3
10751: PUSH
10752: LD_INT 2
10754: PUSH
10755: EMPTY
10756: LIST
10757: LIST
10758: LIST
10759: ST_TO_ADDR
// if GetClass ( i ) = 17 then
10760: LD_VAR 0 6
10764: PPUSH
10765: CALL_OW 257
10769: PUSH
10770: LD_INT 17
10772: EQUAL
10773: IFFALSE 10794
// points := [ 100 , 50 , 75 ] ;
10775: LD_ADDR_VAR 0 9
10779: PUSH
10780: LD_INT 100
10782: PUSH
10783: LD_INT 50
10785: PUSH
10786: LD_INT 75
10788: PUSH
10789: EMPTY
10790: LIST
10791: LIST
10792: LIST
10793: ST_TO_ADDR
// if GetClass ( i ) = 15 then
10794: LD_VAR 0 6
10798: PPUSH
10799: CALL_OW 257
10803: PUSH
10804: LD_INT 15
10806: EQUAL
10807: IFFALSE 10828
// points := [ 10 , 5 , 3 ] ;
10809: LD_ADDR_VAR 0 9
10813: PUSH
10814: LD_INT 10
10816: PUSH
10817: LD_INT 5
10819: PUSH
10820: LD_INT 3
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: LIST
10827: ST_TO_ADDR
// if GetClass ( i ) = 14 then
10828: LD_VAR 0 6
10832: PPUSH
10833: CALL_OW 257
10837: PUSH
10838: LD_INT 14
10840: EQUAL
10841: IFFALSE 10862
// points := [ 10 , 0 , 0 ] ;
10843: LD_ADDR_VAR 0 9
10847: PUSH
10848: LD_INT 10
10850: PUSH
10851: LD_INT 0
10853: PUSH
10854: LD_INT 0
10856: PUSH
10857: EMPTY
10858: LIST
10859: LIST
10860: LIST
10861: ST_TO_ADDR
// if GetClass ( i ) = 11 then
10862: LD_VAR 0 6
10866: PPUSH
10867: CALL_OW 257
10871: PUSH
10872: LD_INT 11
10874: EQUAL
10875: IFFALSE 10896
// points := [ 30 , 10 , 5 ] ;
10877: LD_ADDR_VAR 0 9
10881: PUSH
10882: LD_INT 30
10884: PUSH
10885: LD_INT 10
10887: PUSH
10888: LD_INT 5
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: LIST
10895: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 5
10903: PPUSH
10904: CALL_OW 321
10908: PUSH
10909: LD_INT 2
10911: EQUAL
10912: IFFALSE 10929
// bpoints := bpoints * 1.8 ;
10914: LD_ADDR_VAR 0 10
10918: PUSH
10919: LD_VAR 0 10
10923: PUSH
10924: LD_REAL  1.80000000000000E+0000
10927: MUL
10928: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
10929: LD_VAR 0 6
10933: PPUSH
10934: CALL_OW 257
10938: PUSH
10939: LD_INT 1
10941: PUSH
10942: LD_INT 2
10944: PUSH
10945: LD_INT 3
10947: PUSH
10948: LD_INT 4
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: IN
10957: PUSH
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_INT 51
10965: PPUSH
10966: CALL_OW 321
10970: PUSH
10971: LD_INT 2
10973: EQUAL
10974: AND
10975: IFFALSE 10992
// bpoints := bpoints * 1.2 ;
10977: LD_ADDR_VAR 0 10
10981: PUSH
10982: LD_VAR 0 10
10986: PUSH
10987: LD_REAL  1.20000000000000E+0000
10990: MUL
10991: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
10992: LD_VAR 0 6
10996: PPUSH
10997: CALL_OW 257
11001: PUSH
11002: LD_INT 5
11004: PUSH
11005: LD_INT 7
11007: PUSH
11008: LD_INT 9
11010: PUSH
11011: EMPTY
11012: LIST
11013: LIST
11014: LIST
11015: IN
11016: PUSH
11017: LD_VAR 0 1
11021: PPUSH
11022: LD_INT 52
11024: PPUSH
11025: CALL_OW 321
11029: PUSH
11030: LD_INT 2
11032: EQUAL
11033: AND
11034: IFFALSE 11051
// bpoints := bpoints * 1.5 ;
11036: LD_ADDR_VAR 0 10
11040: PUSH
11041: LD_VAR 0 10
11045: PUSH
11046: LD_REAL  1.50000000000000E+0000
11049: MUL
11050: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
11051: LD_VAR 0 1
11055: PPUSH
11056: LD_INT 66
11058: PPUSH
11059: CALL_OW 321
11063: PUSH
11064: LD_INT 2
11066: EQUAL
11067: IFFALSE 11084
// bpoints := bpoints * 1.1 ;
11069: LD_ADDR_VAR 0 10
11073: PUSH
11074: LD_VAR 0 10
11078: PUSH
11079: LD_REAL  1.10000000000000E+0000
11082: MUL
11083: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
11084: LD_ADDR_VAR 0 10
11088: PUSH
11089: LD_VAR 0 10
11093: PUSH
11094: LD_VAR 0 6
11098: PPUSH
11099: LD_INT 1
11101: PPUSH
11102: CALL_OW 259
11106: PUSH
11107: LD_REAL  1.15000000000000E+0000
11110: MUL
11111: MUL
11112: ST_TO_ADDR
// end ; unit_vehicle :
11113: GO 11937
11115: LD_INT 2
11117: DOUBLE
11118: EQUAL
11119: IFTRUE 11123
11121: GO 11925
11123: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
11124: LD_VAR 0 6
11128: PPUSH
11129: CALL_OW 264
11133: PUSH
11134: LD_INT 2
11136: PUSH
11137: LD_INT 42
11139: PUSH
11140: LD_INT 24
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: LIST
11147: IN
11148: IFFALSE 11169
// points := [ 25 , 5 , 3 ] ;
11150: LD_ADDR_VAR 0 9
11154: PUSH
11155: LD_INT 25
11157: PUSH
11158: LD_INT 5
11160: PUSH
11161: LD_INT 3
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
11169: LD_VAR 0 6
11173: PPUSH
11174: CALL_OW 264
11178: PUSH
11179: LD_INT 4
11181: PUSH
11182: LD_INT 43
11184: PUSH
11185: LD_INT 25
11187: PUSH
11188: EMPTY
11189: LIST
11190: LIST
11191: LIST
11192: IN
11193: IFFALSE 11214
// points := [ 40 , 15 , 5 ] ;
11195: LD_ADDR_VAR 0 9
11199: PUSH
11200: LD_INT 40
11202: PUSH
11203: LD_INT 15
11205: PUSH
11206: LD_INT 5
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: LIST
11213: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
11214: LD_VAR 0 6
11218: PPUSH
11219: CALL_OW 264
11223: PUSH
11224: LD_INT 3
11226: PUSH
11227: LD_INT 23
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: IN
11234: IFFALSE 11255
// points := [ 7 , 25 , 8 ] ;
11236: LD_ADDR_VAR 0 9
11240: PUSH
11241: LD_INT 7
11243: PUSH
11244: LD_INT 25
11246: PUSH
11247: LD_INT 8
11249: PUSH
11250: EMPTY
11251: LIST
11252: LIST
11253: LIST
11254: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
11255: LD_VAR 0 6
11259: PPUSH
11260: CALL_OW 264
11264: PUSH
11265: LD_INT 5
11267: PUSH
11268: LD_INT 27
11270: PUSH
11271: LD_INT 44
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: LIST
11278: IN
11279: IFFALSE 11300
// points := [ 14 , 50 , 16 ] ;
11281: LD_ADDR_VAR 0 9
11285: PUSH
11286: LD_INT 14
11288: PUSH
11289: LD_INT 50
11291: PUSH
11292: LD_INT 16
11294: PUSH
11295: EMPTY
11296: LIST
11297: LIST
11298: LIST
11299: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
11300: LD_VAR 0 6
11304: PPUSH
11305: CALL_OW 264
11309: PUSH
11310: LD_INT 6
11312: PUSH
11313: LD_INT 46
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: IN
11320: IFFALSE 11341
// points := [ 32 , 120 , 70 ] ;
11322: LD_ADDR_VAR 0 9
11326: PUSH
11327: LD_INT 32
11329: PUSH
11330: LD_INT 120
11332: PUSH
11333: LD_INT 70
11335: PUSH
11336: EMPTY
11337: LIST
11338: LIST
11339: LIST
11340: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
11341: LD_VAR 0 6
11345: PPUSH
11346: CALL_OW 264
11350: PUSH
11351: LD_INT 7
11353: PUSH
11354: LD_INT 28
11356: PUSH
11357: LD_INT 45
11359: PUSH
11360: EMPTY
11361: LIST
11362: LIST
11363: LIST
11364: IN
11365: IFFALSE 11386
// points := [ 35 , 20 , 45 ] ;
11367: LD_ADDR_VAR 0 9
11371: PUSH
11372: LD_INT 35
11374: PUSH
11375: LD_INT 20
11377: PUSH
11378: LD_INT 45
11380: PUSH
11381: EMPTY
11382: LIST
11383: LIST
11384: LIST
11385: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
11386: LD_VAR 0 6
11390: PPUSH
11391: CALL_OW 264
11395: PUSH
11396: LD_INT 47
11398: PUSH
11399: EMPTY
11400: LIST
11401: IN
11402: IFFALSE 11423
// points := [ 67 , 45 , 75 ] ;
11404: LD_ADDR_VAR 0 9
11408: PUSH
11409: LD_INT 67
11411: PUSH
11412: LD_INT 45
11414: PUSH
11415: LD_INT 75
11417: PUSH
11418: EMPTY
11419: LIST
11420: LIST
11421: LIST
11422: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
11423: LD_VAR 0 6
11427: PPUSH
11428: CALL_OW 264
11432: PUSH
11433: LD_INT 26
11435: PUSH
11436: EMPTY
11437: LIST
11438: IN
11439: IFFALSE 11460
// points := [ 120 , 30 , 80 ] ;
11441: LD_ADDR_VAR 0 9
11445: PUSH
11446: LD_INT 120
11448: PUSH
11449: LD_INT 30
11451: PUSH
11452: LD_INT 80
11454: PUSH
11455: EMPTY
11456: LIST
11457: LIST
11458: LIST
11459: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
11460: LD_VAR 0 6
11464: PPUSH
11465: CALL_OW 264
11469: PUSH
11470: LD_INT 22
11472: PUSH
11473: EMPTY
11474: LIST
11475: IN
11476: IFFALSE 11497
// points := [ 40 , 1 , 1 ] ;
11478: LD_ADDR_VAR 0 9
11482: PUSH
11483: LD_INT 40
11485: PUSH
11486: LD_INT 1
11488: PUSH
11489: LD_INT 1
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: LIST
11496: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
11497: LD_VAR 0 6
11501: PPUSH
11502: CALL_OW 264
11506: PUSH
11507: LD_INT 29
11509: PUSH
11510: EMPTY
11511: LIST
11512: IN
11513: IFFALSE 11534
// points := [ 70 , 200 , 400 ] ;
11515: LD_ADDR_VAR 0 9
11519: PUSH
11520: LD_INT 70
11522: PUSH
11523: LD_INT 200
11525: PUSH
11526: LD_INT 400
11528: PUSH
11529: EMPTY
11530: LIST
11531: LIST
11532: LIST
11533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
11534: LD_VAR 0 6
11538: PPUSH
11539: CALL_OW 264
11543: PUSH
11544: LD_INT 14
11546: PUSH
11547: LD_INT 53
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: IN
11554: IFFALSE 11575
// points := [ 40 , 10 , 20 ] ;
11556: LD_ADDR_VAR 0 9
11560: PUSH
11561: LD_INT 40
11563: PUSH
11564: LD_INT 10
11566: PUSH
11567: LD_INT 20
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: LIST
11574: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
11575: LD_VAR 0 6
11579: PPUSH
11580: CALL_OW 264
11584: PUSH
11585: LD_INT 9
11587: PUSH
11588: EMPTY
11589: LIST
11590: IN
11591: IFFALSE 11612
// points := [ 5 , 70 , 20 ] ;
11593: LD_ADDR_VAR 0 9
11597: PUSH
11598: LD_INT 5
11600: PUSH
11601: LD_INT 70
11603: PUSH
11604: LD_INT 20
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: LIST
11611: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
11612: LD_VAR 0 6
11616: PPUSH
11617: CALL_OW 264
11621: PUSH
11622: LD_INT 10
11624: PUSH
11625: EMPTY
11626: LIST
11627: IN
11628: IFFALSE 11649
// points := [ 35 , 110 , 70 ] ;
11630: LD_ADDR_VAR 0 9
11634: PUSH
11635: LD_INT 35
11637: PUSH
11638: LD_INT 110
11640: PUSH
11641: LD_INT 70
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: LIST
11648: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
11649: LD_VAR 0 6
11653: PPUSH
11654: CALL_OW 265
11658: PUSH
11659: LD_INT 25
11661: EQUAL
11662: IFFALSE 11683
// points := [ 80 , 65 , 100 ] ;
11664: LD_ADDR_VAR 0 9
11668: PUSH
11669: LD_INT 80
11671: PUSH
11672: LD_INT 65
11674: PUSH
11675: LD_INT 100
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: LIST
11682: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
11683: LD_VAR 0 6
11687: PPUSH
11688: CALL_OW 263
11692: PUSH
11693: LD_INT 1
11695: EQUAL
11696: IFFALSE 11731
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
11698: LD_ADDR_VAR 0 10
11702: PUSH
11703: LD_VAR 0 10
11707: PUSH
11708: LD_VAR 0 6
11712: PPUSH
11713: CALL_OW 311
11717: PPUSH
11718: LD_INT 3
11720: PPUSH
11721: CALL_OW 259
11725: PUSH
11726: LD_INT 4
11728: MUL
11729: MUL
11730: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
11731: LD_VAR 0 6
11735: PPUSH
11736: CALL_OW 263
11740: PUSH
11741: LD_INT 2
11743: EQUAL
11744: IFFALSE 11795
// begin j := IsControledBy ( i ) ;
11746: LD_ADDR_VAR 0 7
11750: PUSH
11751: LD_VAR 0 6
11755: PPUSH
11756: CALL_OW 312
11760: ST_TO_ADDR
// if j then
11761: LD_VAR 0 7
11765: IFFALSE 11795
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
11767: LD_ADDR_VAR 0 10
11771: PUSH
11772: LD_VAR 0 10
11776: PUSH
11777: LD_VAR 0 7
11781: PPUSH
11782: LD_INT 3
11784: PPUSH
11785: CALL_OW 259
11789: PUSH
11790: LD_INT 3
11792: MUL
11793: MUL
11794: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
11795: LD_VAR 0 6
11799: PPUSH
11800: CALL_OW 264
11804: PUSH
11805: LD_INT 5
11807: PUSH
11808: LD_INT 6
11810: PUSH
11811: LD_INT 46
11813: PUSH
11814: LD_INT 44
11816: PUSH
11817: LD_INT 47
11819: PUSH
11820: LD_INT 45
11822: PUSH
11823: LD_INT 28
11825: PUSH
11826: LD_INT 7
11828: PUSH
11829: LD_INT 27
11831: PUSH
11832: LD_INT 29
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: IN
11847: PUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: LD_INT 52
11855: PPUSH
11856: CALL_OW 321
11860: PUSH
11861: LD_INT 2
11863: EQUAL
11864: AND
11865: IFFALSE 11882
// bpoints := bpoints * 1.2 ;
11867: LD_ADDR_VAR 0 10
11871: PUSH
11872: LD_VAR 0 10
11876: PUSH
11877: LD_REAL  1.20000000000000E+0000
11880: MUL
11881: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
11882: LD_VAR 0 6
11886: PPUSH
11887: CALL_OW 264
11891: PUSH
11892: LD_INT 6
11894: PUSH
11895: LD_INT 46
11897: PUSH
11898: LD_INT 47
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: LIST
11905: IN
11906: IFFALSE 11923
// bpoints := bpoints * 1.2 ;
11908: LD_ADDR_VAR 0 10
11912: PUSH
11913: LD_VAR 0 10
11917: PUSH
11918: LD_REAL  1.20000000000000E+0000
11921: MUL
11922: ST_TO_ADDR
// end ; unit_building :
11923: GO 11937
11925: LD_INT 3
11927: DOUBLE
11928: EQUAL
11929: IFTRUE 11933
11931: GO 11936
11933: POP
// ; end ;
11934: GO 11937
11936: POP
// for j = 1 to 3 do
11937: LD_ADDR_VAR 0 7
11941: PUSH
11942: DOUBLE
11943: LD_INT 1
11945: DEC
11946: ST_TO_ADDR
11947: LD_INT 3
11949: PUSH
11950: FOR_TO
11951: IFFALSE 12004
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
11953: LD_ADDR_VAR 0 5
11957: PUSH
11958: LD_VAR 0 5
11962: PPUSH
11963: LD_VAR 0 7
11967: PPUSH
11968: LD_VAR 0 5
11972: PUSH
11973: LD_VAR 0 7
11977: ARRAY
11978: PUSH
11979: LD_VAR 0 9
11983: PUSH
11984: LD_VAR 0 7
11988: ARRAY
11989: PUSH
11990: LD_VAR 0 10
11994: MUL
11995: PLUS
11996: PPUSH
11997: CALL_OW 1
12001: ST_TO_ADDR
12002: GO 11950
12004: POP
12005: POP
// end ;
12006: GO 10489
12008: POP
12009: POP
// result := Replace ( result , 4 , tmp ) ;
12010: LD_ADDR_VAR 0 5
12014: PUSH
12015: LD_VAR 0 5
12019: PPUSH
12020: LD_INT 4
12022: PPUSH
12023: LD_VAR 0 8
12027: PPUSH
12028: CALL_OW 1
12032: ST_TO_ADDR
// end ;
12033: LD_VAR 0 5
12037: RET
// export function DangerAtRange ( unit , range ) ; begin
12038: LD_INT 0
12040: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
12041: LD_ADDR_VAR 0 3
12045: PUSH
12046: LD_VAR 0 1
12050: PPUSH
12051: CALL_OW 255
12055: PPUSH
12056: LD_VAR 0 1
12060: PPUSH
12061: CALL_OW 250
12065: PPUSH
12066: LD_VAR 0 1
12070: PPUSH
12071: CALL_OW 251
12075: PPUSH
12076: LD_VAR 0 2
12080: PPUSH
12081: CALL 10341 0 4
12085: ST_TO_ADDR
// end ;
12086: LD_VAR 0 3
12090: RET
// export function DangerInArea ( side , area ) ; begin
12091: LD_INT 0
12093: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
12094: LD_ADDR_VAR 0 3
12098: PUSH
12099: LD_VAR 0 2
12103: PPUSH
12104: LD_INT 81
12106: PUSH
12107: LD_VAR 0 1
12111: PUSH
12112: EMPTY
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 70
12120: ST_TO_ADDR
// end ;
12121: LD_VAR 0 3
12125: RET
// export function IsExtension ( b ) ; begin
12126: LD_INT 0
12128: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
12129: LD_ADDR_VAR 0 2
12133: PUSH
12134: LD_VAR 0 1
12138: PUSH
12139: LD_INT 23
12141: PUSH
12142: LD_INT 20
12144: PUSH
12145: LD_INT 22
12147: PUSH
12148: LD_INT 17
12150: PUSH
12151: LD_INT 24
12153: PUSH
12154: LD_INT 21
12156: PUSH
12157: LD_INT 19
12159: PUSH
12160: LD_INT 16
12162: PUSH
12163: LD_INT 25
12165: PUSH
12166: LD_INT 18
12168: PUSH
12169: EMPTY
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: LIST
12179: LIST
12180: IN
12181: ST_TO_ADDR
// end ;
12182: LD_VAR 0 2
12186: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
12187: LD_INT 0
12189: PPUSH
12190: PPUSH
12191: PPUSH
// result := [ ] ;
12192: LD_ADDR_VAR 0 3
12196: PUSH
12197: EMPTY
12198: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
12199: LD_ADDR_VAR 0 4
12203: PUSH
12204: LD_VAR 0 2
12208: PPUSH
12209: LD_INT 21
12211: PUSH
12212: LD_INT 3
12214: PUSH
12215: EMPTY
12216: LIST
12217: LIST
12218: PPUSH
12219: CALL_OW 70
12223: ST_TO_ADDR
// if not tmp then
12224: LD_VAR 0 4
12228: NOT
12229: IFFALSE 12233
// exit ;
12231: GO 12291
// for i in tmp do
12233: LD_ADDR_VAR 0 5
12237: PUSH
12238: LD_VAR 0 4
12242: PUSH
12243: FOR_IN
12244: IFFALSE 12279
// if GetBase ( i ) <> base then
12246: LD_VAR 0 5
12250: PPUSH
12251: CALL_OW 274
12255: PUSH
12256: LD_VAR 0 1
12260: NONEQUAL
12261: IFFALSE 12277
// ComLinkToBase ( base , i ) ;
12263: LD_VAR 0 1
12267: PPUSH
12268: LD_VAR 0 5
12272: PPUSH
12273: CALL_OW 169
12277: GO 12243
12279: POP
12280: POP
// result := tmp ;
12281: LD_ADDR_VAR 0 3
12285: PUSH
12286: LD_VAR 0 4
12290: ST_TO_ADDR
// end ;
12291: LD_VAR 0 3
12295: RET
// export function ComComplete ( unit , b ) ; var i ; begin
12296: LD_INT 0
12298: PPUSH
12299: PPUSH
// if BuildingStatus ( b ) = bs_build then
12300: LD_VAR 0 2
12304: PPUSH
12305: CALL_OW 461
12309: PUSH
12310: LD_INT 1
12312: EQUAL
12313: IFFALSE 12373
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
12315: LD_VAR 0 1
12319: PPUSH
12320: LD_STRING h
12322: PUSH
12323: LD_VAR 0 2
12327: PPUSH
12328: CALL_OW 250
12332: PUSH
12333: LD_VAR 0 2
12337: PPUSH
12338: CALL_OW 251
12342: PUSH
12343: LD_VAR 0 2
12347: PUSH
12348: LD_INT 0
12350: PUSH
12351: LD_INT 0
12353: PUSH
12354: LD_INT 0
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: PUSH
12366: EMPTY
12367: LIST
12368: PPUSH
12369: CALL_OW 446
// end ;
12373: LD_VAR 0 3
12377: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
12378: LD_INT 0
12380: PPUSH
12381: PPUSH
12382: PPUSH
12383: PPUSH
12384: PPUSH
12385: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
12386: LD_VAR 0 1
12390: NOT
12391: PUSH
12392: LD_VAR 0 1
12396: PPUSH
12397: CALL_OW 263
12401: PUSH
12402: LD_INT 2
12404: EQUAL
12405: NOT
12406: OR
12407: IFFALSE 12411
// exit ;
12409: GO 12727
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
12411: LD_ADDR_VAR 0 6
12415: PUSH
12416: LD_INT 22
12418: PUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 255
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: LD_INT 2
12435: PUSH
12436: LD_INT 30
12438: PUSH
12439: LD_INT 36
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: PUSH
12446: LD_INT 34
12448: PUSH
12449: LD_INT 31
12451: PUSH
12452: EMPTY
12453: LIST
12454: LIST
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: LIST
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: PPUSH
12465: CALL_OW 69
12469: ST_TO_ADDR
// if not tmp then
12470: LD_VAR 0 6
12474: NOT
12475: IFFALSE 12479
// exit ;
12477: GO 12727
// result := [ ] ;
12479: LD_ADDR_VAR 0 2
12483: PUSH
12484: EMPTY
12485: ST_TO_ADDR
// for i in tmp do
12486: LD_ADDR_VAR 0 3
12490: PUSH
12491: LD_VAR 0 6
12495: PUSH
12496: FOR_IN
12497: IFFALSE 12568
// begin t := UnitsInside ( i ) ;
12499: LD_ADDR_VAR 0 4
12503: PUSH
12504: LD_VAR 0 3
12508: PPUSH
12509: CALL_OW 313
12513: ST_TO_ADDR
// if t then
12514: LD_VAR 0 4
12518: IFFALSE 12566
// for j in t do
12520: LD_ADDR_VAR 0 7
12524: PUSH
12525: LD_VAR 0 4
12529: PUSH
12530: FOR_IN
12531: IFFALSE 12564
// result := Insert ( result , result + 1 , j ) ;
12533: LD_ADDR_VAR 0 2
12537: PUSH
12538: LD_VAR 0 2
12542: PPUSH
12543: LD_VAR 0 2
12547: PUSH
12548: LD_INT 1
12550: PLUS
12551: PPUSH
12552: LD_VAR 0 7
12556: PPUSH
12557: CALL_OW 2
12561: ST_TO_ADDR
12562: GO 12530
12564: POP
12565: POP
// end ;
12566: GO 12496
12568: POP
12569: POP
// if not result then
12570: LD_VAR 0 2
12574: NOT
12575: IFFALSE 12579
// exit ;
12577: GO 12727
// mech := result [ 1 ] ;
12579: LD_ADDR_VAR 0 5
12583: PUSH
12584: LD_VAR 0 2
12588: PUSH
12589: LD_INT 1
12591: ARRAY
12592: ST_TO_ADDR
// if result > 1 then
12593: LD_VAR 0 2
12597: PUSH
12598: LD_INT 1
12600: GREATER
12601: IFFALSE 12713
// for i = 2 to result do
12603: LD_ADDR_VAR 0 3
12607: PUSH
12608: DOUBLE
12609: LD_INT 2
12611: DEC
12612: ST_TO_ADDR
12613: LD_VAR 0 2
12617: PUSH
12618: FOR_TO
12619: IFFALSE 12711
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
12621: LD_ADDR_VAR 0 4
12625: PUSH
12626: LD_VAR 0 2
12630: PUSH
12631: LD_VAR 0 3
12635: ARRAY
12636: PPUSH
12637: LD_INT 3
12639: PPUSH
12640: CALL_OW 259
12644: PUSH
12645: LD_VAR 0 2
12649: PUSH
12650: LD_VAR 0 3
12654: ARRAY
12655: PPUSH
12656: CALL_OW 432
12660: MINUS
12661: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: PPUSH
12672: LD_INT 3
12674: PPUSH
12675: CALL_OW 259
12679: PUSH
12680: LD_VAR 0 5
12684: PPUSH
12685: CALL_OW 432
12689: MINUS
12690: GREATEREQUAL
12691: IFFALSE 12709
// mech := result [ i ] ;
12693: LD_ADDR_VAR 0 5
12697: PUSH
12698: LD_VAR 0 2
12702: PUSH
12703: LD_VAR 0 3
12707: ARRAY
12708: ST_TO_ADDR
// end ;
12709: GO 12618
12711: POP
12712: POP
// ComLinkTo ( vehicle , mech ) ;
12713: LD_VAR 0 1
12717: PPUSH
12718: LD_VAR 0 5
12722: PPUSH
12723: CALL_OW 135
// end ;
12727: LD_VAR 0 2
12731: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
12732: LD_INT 0
12734: PPUSH
12735: PPUSH
12736: PPUSH
12737: PPUSH
12738: PPUSH
12739: PPUSH
12740: PPUSH
12741: PPUSH
12742: PPUSH
12743: PPUSH
12744: PPUSH
12745: PPUSH
12746: PPUSH
// result := [ ] ;
12747: LD_ADDR_VAR 0 7
12751: PUSH
12752: EMPTY
12753: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
12754: LD_VAR 0 1
12758: PPUSH
12759: CALL_OW 266
12763: PUSH
12764: LD_INT 0
12766: PUSH
12767: LD_INT 1
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: IN
12774: NOT
12775: IFFALSE 12779
// exit ;
12777: GO 14410
// if name then
12779: LD_VAR 0 3
12783: IFFALSE 12799
// SetBName ( base_dep , name ) ;
12785: LD_VAR 0 1
12789: PPUSH
12790: LD_VAR 0 3
12794: PPUSH
12795: CALL_OW 500
// base := GetBase ( base_dep ) ;
12799: LD_ADDR_VAR 0 15
12803: PUSH
12804: LD_VAR 0 1
12808: PPUSH
12809: CALL_OW 274
12813: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
12814: LD_ADDR_VAR 0 16
12818: PUSH
12819: LD_VAR 0 1
12823: PPUSH
12824: CALL_OW 255
12828: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
12829: LD_ADDR_VAR 0 17
12833: PUSH
12834: LD_VAR 0 1
12838: PPUSH
12839: CALL_OW 248
12843: ST_TO_ADDR
// if sources then
12844: LD_VAR 0 5
12848: IFFALSE 12895
// for i = 1 to 3 do
12850: LD_ADDR_VAR 0 8
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_INT 3
12862: PUSH
12863: FOR_TO
12864: IFFALSE 12893
// AddResourceType ( base , i , sources [ i ] ) ;
12866: LD_VAR 0 15
12870: PPUSH
12871: LD_VAR 0 8
12875: PPUSH
12876: LD_VAR 0 5
12880: PUSH
12881: LD_VAR 0 8
12885: ARRAY
12886: PPUSH
12887: CALL_OW 276
12891: GO 12863
12893: POP
12894: POP
// buildings := GetBaseBuildings ( base , area ) ;
12895: LD_ADDR_VAR 0 18
12899: PUSH
12900: LD_VAR 0 15
12904: PPUSH
12905: LD_VAR 0 2
12909: PPUSH
12910: CALL 12187 0 2
12914: ST_TO_ADDR
// InitHc ;
12915: CALL_OW 19
// InitUc ;
12919: CALL_OW 18
// uc_side := side ;
12923: LD_ADDR_OWVAR 20
12927: PUSH
12928: LD_VAR 0 16
12932: ST_TO_ADDR
// uc_nation := nation ;
12933: LD_ADDR_OWVAR 21
12937: PUSH
12938: LD_VAR 0 17
12942: ST_TO_ADDR
// if buildings then
12943: LD_VAR 0 18
12947: IFFALSE 14269
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
12949: LD_ADDR_VAR 0 19
12953: PUSH
12954: LD_VAR 0 18
12958: PPUSH
12959: LD_INT 2
12961: PUSH
12962: LD_INT 30
12964: PUSH
12965: LD_INT 29
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 30
12974: PUSH
12975: LD_INT 30
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: PPUSH
12987: CALL_OW 72
12991: ST_TO_ADDR
// if tmp then
12992: LD_VAR 0 19
12996: IFFALSE 13044
// for i in tmp do
12998: LD_ADDR_VAR 0 8
13002: PUSH
13003: LD_VAR 0 19
13007: PUSH
13008: FOR_IN
13009: IFFALSE 13042
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
13011: LD_VAR 0 8
13015: PPUSH
13016: CALL_OW 250
13020: PPUSH
13021: LD_VAR 0 8
13025: PPUSH
13026: CALL_OW 251
13030: PPUSH
13031: LD_VAR 0 16
13035: PPUSH
13036: CALL_OW 441
13040: GO 13008
13042: POP
13043: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
13044: LD_VAR 0 18
13048: PPUSH
13049: LD_INT 2
13051: PUSH
13052: LD_INT 30
13054: PUSH
13055: LD_INT 32
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PUSH
13062: LD_INT 30
13064: PUSH
13065: LD_INT 33
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: PPUSH
13077: CALL_OW 72
13081: IFFALSE 13169
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
13083: LD_ADDR_VAR 0 8
13087: PUSH
13088: LD_VAR 0 18
13092: PPUSH
13093: LD_INT 2
13095: PUSH
13096: LD_INT 30
13098: PUSH
13099: LD_INT 32
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PUSH
13106: LD_INT 30
13108: PUSH
13109: LD_INT 33
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PUSH
13116: EMPTY
13117: LIST
13118: LIST
13119: LIST
13120: PPUSH
13121: CALL_OW 72
13125: PUSH
13126: FOR_IN
13127: IFFALSE 13167
// begin if not GetBWeapon ( i ) then
13129: LD_VAR 0 8
13133: PPUSH
13134: CALL_OW 269
13138: NOT
13139: IFFALSE 13165
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
13141: LD_VAR 0 8
13145: PPUSH
13146: LD_VAR 0 8
13150: PPUSH
13151: LD_VAR 0 2
13155: PPUSH
13156: CALL 14415 0 2
13160: PPUSH
13161: CALL_OW 431
// end ;
13165: GO 13126
13167: POP
13168: POP
// end ; for i = 1 to personel do
13169: LD_ADDR_VAR 0 8
13173: PUSH
13174: DOUBLE
13175: LD_INT 1
13177: DEC
13178: ST_TO_ADDR
13179: LD_VAR 0 6
13183: PUSH
13184: FOR_TO
13185: IFFALSE 14249
// begin if i > 4 then
13187: LD_VAR 0 8
13191: PUSH
13192: LD_INT 4
13194: GREATER
13195: IFFALSE 13199
// break ;
13197: GO 14249
// case i of 1 :
13199: LD_VAR 0 8
13203: PUSH
13204: LD_INT 1
13206: DOUBLE
13207: EQUAL
13208: IFTRUE 13212
13210: GO 13292
13212: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
13213: LD_ADDR_VAR 0 12
13217: PUSH
13218: LD_VAR 0 18
13222: PPUSH
13223: LD_INT 22
13225: PUSH
13226: LD_VAR 0 16
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 58
13237: PUSH
13238: EMPTY
13239: LIST
13240: PUSH
13241: LD_INT 2
13243: PUSH
13244: LD_INT 30
13246: PUSH
13247: LD_INT 32
13249: PUSH
13250: EMPTY
13251: LIST
13252: LIST
13253: PUSH
13254: LD_INT 30
13256: PUSH
13257: LD_INT 4
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: PUSH
13264: LD_INT 30
13266: PUSH
13267: LD_INT 5
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: PUSH
13280: EMPTY
13281: LIST
13282: LIST
13283: LIST
13284: PPUSH
13285: CALL_OW 72
13289: ST_TO_ADDR
13290: GO 13514
13292: LD_INT 2
13294: DOUBLE
13295: EQUAL
13296: IFTRUE 13300
13298: GO 13362
13300: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
13301: LD_ADDR_VAR 0 12
13305: PUSH
13306: LD_VAR 0 18
13310: PPUSH
13311: LD_INT 22
13313: PUSH
13314: LD_VAR 0 16
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PUSH
13323: LD_INT 2
13325: PUSH
13326: LD_INT 30
13328: PUSH
13329: LD_INT 0
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: PUSH
13336: LD_INT 30
13338: PUSH
13339: LD_INT 1
13341: PUSH
13342: EMPTY
13343: LIST
13344: LIST
13345: PUSH
13346: EMPTY
13347: LIST
13348: LIST
13349: LIST
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PPUSH
13355: CALL_OW 72
13359: ST_TO_ADDR
13360: GO 13514
13362: LD_INT 3
13364: DOUBLE
13365: EQUAL
13366: IFTRUE 13370
13368: GO 13432
13370: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
13371: LD_ADDR_VAR 0 12
13375: PUSH
13376: LD_VAR 0 18
13380: PPUSH
13381: LD_INT 22
13383: PUSH
13384: LD_VAR 0 16
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: PUSH
13393: LD_INT 2
13395: PUSH
13396: LD_INT 30
13398: PUSH
13399: LD_INT 2
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 30
13408: PUSH
13409: LD_INT 3
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: LIST
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PPUSH
13425: CALL_OW 72
13429: ST_TO_ADDR
13430: GO 13514
13432: LD_INT 4
13434: DOUBLE
13435: EQUAL
13436: IFTRUE 13440
13438: GO 13513
13440: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
13441: LD_ADDR_VAR 0 12
13445: PUSH
13446: LD_VAR 0 18
13450: PPUSH
13451: LD_INT 22
13453: PUSH
13454: LD_VAR 0 16
13458: PUSH
13459: EMPTY
13460: LIST
13461: LIST
13462: PUSH
13463: LD_INT 2
13465: PUSH
13466: LD_INT 30
13468: PUSH
13469: LD_INT 6
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: LD_INT 30
13478: PUSH
13479: LD_INT 7
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PUSH
13486: LD_INT 30
13488: PUSH
13489: LD_INT 8
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: LIST
13500: LIST
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PPUSH
13506: CALL_OW 72
13510: ST_TO_ADDR
13511: GO 13514
13513: POP
// if i = 1 then
13514: LD_VAR 0 8
13518: PUSH
13519: LD_INT 1
13521: EQUAL
13522: IFFALSE 13633
// begin tmp := [ ] ;
13524: LD_ADDR_VAR 0 19
13528: PUSH
13529: EMPTY
13530: ST_TO_ADDR
// for j in f do
13531: LD_ADDR_VAR 0 9
13535: PUSH
13536: LD_VAR 0 12
13540: PUSH
13541: FOR_IN
13542: IFFALSE 13615
// if GetBType ( j ) = b_bunker then
13544: LD_VAR 0 9
13548: PPUSH
13549: CALL_OW 266
13553: PUSH
13554: LD_INT 32
13556: EQUAL
13557: IFFALSE 13584
// tmp := Insert ( tmp , 1 , j ) else
13559: LD_ADDR_VAR 0 19
13563: PUSH
13564: LD_VAR 0 19
13568: PPUSH
13569: LD_INT 1
13571: PPUSH
13572: LD_VAR 0 9
13576: PPUSH
13577: CALL_OW 2
13581: ST_TO_ADDR
13582: GO 13613
// tmp := Insert ( tmp , tmp + 1 , j ) ;
13584: LD_ADDR_VAR 0 19
13588: PUSH
13589: LD_VAR 0 19
13593: PPUSH
13594: LD_VAR 0 19
13598: PUSH
13599: LD_INT 1
13601: PLUS
13602: PPUSH
13603: LD_VAR 0 9
13607: PPUSH
13608: CALL_OW 2
13612: ST_TO_ADDR
13613: GO 13541
13615: POP
13616: POP
// if tmp then
13617: LD_VAR 0 19
13621: IFFALSE 13633
// f := tmp ;
13623: LD_ADDR_VAR 0 12
13627: PUSH
13628: LD_VAR 0 19
13632: ST_TO_ADDR
// end ; x := personel [ i ] ;
13633: LD_ADDR_VAR 0 13
13637: PUSH
13638: LD_VAR 0 6
13642: PUSH
13643: LD_VAR 0 8
13647: ARRAY
13648: ST_TO_ADDR
// if x = - 1 then
13649: LD_VAR 0 13
13653: PUSH
13654: LD_INT 1
13656: NEG
13657: EQUAL
13658: IFFALSE 13867
// begin for j in f do
13660: LD_ADDR_VAR 0 9
13664: PUSH
13665: LD_VAR 0 12
13669: PUSH
13670: FOR_IN
13671: IFFALSE 13863
// repeat InitHc ;
13673: CALL_OW 19
// if GetBType ( j ) = b_barracks then
13677: LD_VAR 0 9
13681: PPUSH
13682: CALL_OW 266
13686: PUSH
13687: LD_INT 5
13689: EQUAL
13690: IFFALSE 13760
// begin if UnitsInside ( j ) < 3 then
13692: LD_VAR 0 9
13696: PPUSH
13697: CALL_OW 313
13701: PUSH
13702: LD_INT 3
13704: LESS
13705: IFFALSE 13741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
13707: LD_INT 0
13709: PPUSH
13710: LD_INT 5
13712: PUSH
13713: LD_INT 8
13715: PUSH
13716: LD_INT 9
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: LIST
13723: PUSH
13724: LD_VAR 0 17
13728: ARRAY
13729: PPUSH
13730: LD_VAR 0 4
13734: PPUSH
13735: CALL_OW 380
13739: GO 13758
// PrepareHuman ( false , i , skill ) ;
13741: LD_INT 0
13743: PPUSH
13744: LD_VAR 0 8
13748: PPUSH
13749: LD_VAR 0 4
13753: PPUSH
13754: CALL_OW 380
// end else
13758: GO 13777
// PrepareHuman ( false , i , skill ) ;
13760: LD_INT 0
13762: PPUSH
13763: LD_VAR 0 8
13767: PPUSH
13768: LD_VAR 0 4
13772: PPUSH
13773: CALL_OW 380
// un := CreateHuman ;
13777: LD_ADDR_VAR 0 14
13781: PUSH
13782: CALL_OW 44
13786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13787: LD_ADDR_VAR 0 7
13791: PUSH
13792: LD_VAR 0 7
13796: PPUSH
13797: LD_INT 1
13799: PPUSH
13800: LD_VAR 0 14
13804: PPUSH
13805: CALL_OW 2
13809: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
13810: LD_VAR 0 14
13814: PPUSH
13815: LD_VAR 0 9
13819: PPUSH
13820: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
13824: LD_VAR 0 9
13828: PPUSH
13829: CALL_OW 313
13833: PUSH
13834: LD_INT 6
13836: EQUAL
13837: PUSH
13838: LD_VAR 0 9
13842: PPUSH
13843: CALL_OW 266
13847: PUSH
13848: LD_INT 32
13850: PUSH
13851: LD_INT 31
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: IN
13858: OR
13859: IFFALSE 13673
13861: GO 13670
13863: POP
13864: POP
// end else
13865: GO 14247
// for j = 1 to x do
13867: LD_ADDR_VAR 0 9
13871: PUSH
13872: DOUBLE
13873: LD_INT 1
13875: DEC
13876: ST_TO_ADDR
13877: LD_VAR 0 13
13881: PUSH
13882: FOR_TO
13883: IFFALSE 14245
// begin InitHc ;
13885: CALL_OW 19
// if not f then
13889: LD_VAR 0 12
13893: NOT
13894: IFFALSE 13983
// begin PrepareHuman ( false , i , skill ) ;
13896: LD_INT 0
13898: PPUSH
13899: LD_VAR 0 8
13903: PPUSH
13904: LD_VAR 0 4
13908: PPUSH
13909: CALL_OW 380
// un := CreateHuman ;
13913: LD_ADDR_VAR 0 14
13917: PUSH
13918: CALL_OW 44
13922: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13923: LD_ADDR_VAR 0 7
13927: PUSH
13928: LD_VAR 0 7
13932: PPUSH
13933: LD_INT 1
13935: PPUSH
13936: LD_VAR 0 14
13940: PPUSH
13941: CALL_OW 2
13945: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
13946: LD_VAR 0 14
13950: PPUSH
13951: LD_VAR 0 1
13955: PPUSH
13956: CALL_OW 250
13960: PPUSH
13961: LD_VAR 0 1
13965: PPUSH
13966: CALL_OW 251
13970: PPUSH
13971: LD_INT 10
13973: PPUSH
13974: LD_INT 0
13976: PPUSH
13977: CALL_OW 50
// continue ;
13981: GO 13882
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
13983: LD_VAR 0 12
13987: PUSH
13988: LD_INT 1
13990: ARRAY
13991: PPUSH
13992: CALL_OW 313
13996: PUSH
13997: LD_VAR 0 12
14001: PUSH
14002: LD_INT 1
14004: ARRAY
14005: PPUSH
14006: CALL_OW 266
14010: PUSH
14011: LD_INT 32
14013: PUSH
14014: LD_INT 31
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: IN
14021: AND
14022: PUSH
14023: LD_VAR 0 12
14027: PUSH
14028: LD_INT 1
14030: ARRAY
14031: PPUSH
14032: CALL_OW 313
14036: PUSH
14037: LD_INT 6
14039: EQUAL
14040: OR
14041: IFFALSE 14061
// f := Delete ( f , 1 ) ;
14043: LD_ADDR_VAR 0 12
14047: PUSH
14048: LD_VAR 0 12
14052: PPUSH
14053: LD_INT 1
14055: PPUSH
14056: CALL_OW 3
14060: ST_TO_ADDR
// if not f then
14061: LD_VAR 0 12
14065: NOT
14066: IFFALSE 14084
// begin x := x + 2 ;
14068: LD_ADDR_VAR 0 13
14072: PUSH
14073: LD_VAR 0 13
14077: PUSH
14078: LD_INT 2
14080: PLUS
14081: ST_TO_ADDR
// continue ;
14082: GO 13882
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
14084: LD_VAR 0 12
14088: PUSH
14089: LD_INT 1
14091: ARRAY
14092: PPUSH
14093: CALL_OW 266
14097: PUSH
14098: LD_INT 5
14100: EQUAL
14101: IFFALSE 14175
// begin if UnitsInside ( f [ 1 ] ) < 3 then
14103: LD_VAR 0 12
14107: PUSH
14108: LD_INT 1
14110: ARRAY
14111: PPUSH
14112: CALL_OW 313
14116: PUSH
14117: LD_INT 3
14119: LESS
14120: IFFALSE 14156
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
14122: LD_INT 0
14124: PPUSH
14125: LD_INT 5
14127: PUSH
14128: LD_INT 8
14130: PUSH
14131: LD_INT 9
14133: PUSH
14134: EMPTY
14135: LIST
14136: LIST
14137: LIST
14138: PUSH
14139: LD_VAR 0 17
14143: ARRAY
14144: PPUSH
14145: LD_VAR 0 4
14149: PPUSH
14150: CALL_OW 380
14154: GO 14173
// PrepareHuman ( false , i , skill ) ;
14156: LD_INT 0
14158: PPUSH
14159: LD_VAR 0 8
14163: PPUSH
14164: LD_VAR 0 4
14168: PPUSH
14169: CALL_OW 380
// end else
14173: GO 14192
// PrepareHuman ( false , i , skill ) ;
14175: LD_INT 0
14177: PPUSH
14178: LD_VAR 0 8
14182: PPUSH
14183: LD_VAR 0 4
14187: PPUSH
14188: CALL_OW 380
// un := CreateHuman ;
14192: LD_ADDR_VAR 0 14
14196: PUSH
14197: CALL_OW 44
14201: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
14202: LD_ADDR_VAR 0 7
14206: PUSH
14207: LD_VAR 0 7
14211: PPUSH
14212: LD_INT 1
14214: PPUSH
14215: LD_VAR 0 14
14219: PPUSH
14220: CALL_OW 2
14224: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
14225: LD_VAR 0 14
14229: PPUSH
14230: LD_VAR 0 12
14234: PUSH
14235: LD_INT 1
14237: ARRAY
14238: PPUSH
14239: CALL_OW 52
// end ;
14243: GO 13882
14245: POP
14246: POP
// end ;
14247: GO 13184
14249: POP
14250: POP
// result := result ^ buildings ;
14251: LD_ADDR_VAR 0 7
14255: PUSH
14256: LD_VAR 0 7
14260: PUSH
14261: LD_VAR 0 18
14265: ADD
14266: ST_TO_ADDR
// end else
14267: GO 14410
// begin for i = 1 to personel do
14269: LD_ADDR_VAR 0 8
14273: PUSH
14274: DOUBLE
14275: LD_INT 1
14277: DEC
14278: ST_TO_ADDR
14279: LD_VAR 0 6
14283: PUSH
14284: FOR_TO
14285: IFFALSE 14408
// begin if i > 4 then
14287: LD_VAR 0 8
14291: PUSH
14292: LD_INT 4
14294: GREATER
14295: IFFALSE 14299
// break ;
14297: GO 14408
// x := personel [ i ] ;
14299: LD_ADDR_VAR 0 13
14303: PUSH
14304: LD_VAR 0 6
14308: PUSH
14309: LD_VAR 0 8
14313: ARRAY
14314: ST_TO_ADDR
// if x = - 1 then
14315: LD_VAR 0 13
14319: PUSH
14320: LD_INT 1
14322: NEG
14323: EQUAL
14324: IFFALSE 14328
// continue ;
14326: GO 14284
// PrepareHuman ( false , i , skill ) ;
14328: LD_INT 0
14330: PPUSH
14331: LD_VAR 0 8
14335: PPUSH
14336: LD_VAR 0 4
14340: PPUSH
14341: CALL_OW 380
// un := CreateHuman ;
14345: LD_ADDR_VAR 0 14
14349: PUSH
14350: CALL_OW 44
14354: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
14355: LD_VAR 0 14
14359: PPUSH
14360: LD_VAR 0 1
14364: PPUSH
14365: CALL_OW 250
14369: PPUSH
14370: LD_VAR 0 1
14374: PPUSH
14375: CALL_OW 251
14379: PPUSH
14380: LD_INT 10
14382: PPUSH
14383: LD_INT 0
14385: PPUSH
14386: CALL_OW 50
// result := result ^ un ;
14390: LD_ADDR_VAR 0 7
14394: PUSH
14395: LD_VAR 0 7
14399: PUSH
14400: LD_VAR 0 14
14404: ADD
14405: ST_TO_ADDR
// end ;
14406: GO 14284
14408: POP
14409: POP
// end ; end ;
14410: LD_VAR 0 7
14414: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
14415: LD_INT 0
14417: PPUSH
14418: PPUSH
14419: PPUSH
14420: PPUSH
14421: PPUSH
14422: PPUSH
14423: PPUSH
14424: PPUSH
14425: PPUSH
14426: PPUSH
14427: PPUSH
14428: PPUSH
14429: PPUSH
14430: PPUSH
14431: PPUSH
14432: PPUSH
// result := false ;
14433: LD_ADDR_VAR 0 3
14437: PUSH
14438: LD_INT 0
14440: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
14441: LD_VAR 0 1
14445: NOT
14446: PUSH
14447: LD_VAR 0 1
14451: PPUSH
14452: CALL_OW 266
14456: PUSH
14457: LD_INT 32
14459: PUSH
14460: LD_INT 33
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: IN
14467: NOT
14468: OR
14469: IFFALSE 14473
// exit ;
14471: GO 15609
// nat := GetNation ( tower ) ;
14473: LD_ADDR_VAR 0 12
14477: PUSH
14478: LD_VAR 0 1
14482: PPUSH
14483: CALL_OW 248
14487: ST_TO_ADDR
// side := GetSide ( tower ) ;
14488: LD_ADDR_VAR 0 16
14492: PUSH
14493: LD_VAR 0 1
14497: PPUSH
14498: CALL_OW 255
14502: ST_TO_ADDR
// x := GetX ( tower ) ;
14503: LD_ADDR_VAR 0 10
14507: PUSH
14508: LD_VAR 0 1
14512: PPUSH
14513: CALL_OW 250
14517: ST_TO_ADDR
// y := GetY ( tower ) ;
14518: LD_ADDR_VAR 0 11
14522: PUSH
14523: LD_VAR 0 1
14527: PPUSH
14528: CALL_OW 251
14532: ST_TO_ADDR
// if not x or not y then
14533: LD_VAR 0 10
14537: NOT
14538: PUSH
14539: LD_VAR 0 11
14543: NOT
14544: OR
14545: IFFALSE 14549
// exit ;
14547: GO 15609
// weapon := 0 ;
14549: LD_ADDR_VAR 0 18
14553: PUSH
14554: LD_INT 0
14556: ST_TO_ADDR
// fac_list := [ ] ;
14557: LD_ADDR_VAR 0 17
14561: PUSH
14562: EMPTY
14563: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
14564: LD_ADDR_VAR 0 6
14568: PUSH
14569: LD_VAR 0 1
14573: PPUSH
14574: CALL_OW 274
14578: PPUSH
14579: LD_VAR 0 2
14583: PPUSH
14584: CALL 12187 0 2
14588: PPUSH
14589: LD_INT 30
14591: PUSH
14592: LD_INT 3
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: PPUSH
14599: CALL_OW 72
14603: ST_TO_ADDR
// if not factories then
14604: LD_VAR 0 6
14608: NOT
14609: IFFALSE 14613
// exit ;
14611: GO 15609
// for i in factories do
14613: LD_ADDR_VAR 0 8
14617: PUSH
14618: LD_VAR 0 6
14622: PUSH
14623: FOR_IN
14624: IFFALSE 14649
// fac_list := fac_list union AvailableWeaponList ( i ) ;
14626: LD_ADDR_VAR 0 17
14630: PUSH
14631: LD_VAR 0 17
14635: PUSH
14636: LD_VAR 0 8
14640: PPUSH
14641: CALL_OW 478
14645: UNION
14646: ST_TO_ADDR
14647: GO 14623
14649: POP
14650: POP
// if not fac_list then
14651: LD_VAR 0 17
14655: NOT
14656: IFFALSE 14660
// exit ;
14658: GO 15609
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
14660: LD_ADDR_VAR 0 5
14664: PUSH
14665: LD_INT 4
14667: PUSH
14668: LD_INT 5
14670: PUSH
14671: LD_INT 9
14673: PUSH
14674: LD_INT 10
14676: PUSH
14677: LD_INT 6
14679: PUSH
14680: LD_INT 7
14682: PUSH
14683: LD_INT 11
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: PUSH
14695: LD_INT 27
14697: PUSH
14698: LD_INT 28
14700: PUSH
14701: LD_INT 26
14703: PUSH
14704: LD_INT 30
14706: PUSH
14707: EMPTY
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 43
14715: PUSH
14716: LD_INT 44
14718: PUSH
14719: LD_INT 46
14721: PUSH
14722: LD_INT 45
14724: PUSH
14725: LD_INT 47
14727: PUSH
14728: LD_INT 49
14730: PUSH
14731: EMPTY
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: LIST
14743: PUSH
14744: LD_VAR 0 12
14748: ARRAY
14749: ST_TO_ADDR
// for i in list do
14750: LD_ADDR_VAR 0 8
14754: PUSH
14755: LD_VAR 0 5
14759: PUSH
14760: FOR_IN
14761: IFFALSE 14794
// if not i in fac_list then
14763: LD_VAR 0 8
14767: PUSH
14768: LD_VAR 0 17
14772: IN
14773: NOT
14774: IFFALSE 14792
// list := list diff i ;
14776: LD_ADDR_VAR 0 5
14780: PUSH
14781: LD_VAR 0 5
14785: PUSH
14786: LD_VAR 0 8
14790: DIFF
14791: ST_TO_ADDR
14792: GO 14760
14794: POP
14795: POP
// if not list then
14796: LD_VAR 0 5
14800: NOT
14801: IFFALSE 14805
// exit ;
14803: GO 15609
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
14805: LD_VAR 0 12
14809: PUSH
14810: LD_INT 3
14812: EQUAL
14813: PUSH
14814: LD_INT 49
14816: PUSH
14817: LD_VAR 0 5
14821: IN
14822: AND
14823: PUSH
14824: LD_INT 31
14826: PPUSH
14827: LD_VAR 0 16
14831: PPUSH
14832: CALL_OW 321
14836: PUSH
14837: LD_INT 2
14839: EQUAL
14840: AND
14841: IFFALSE 14901
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
14843: LD_INT 22
14845: PUSH
14846: LD_VAR 0 16
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PUSH
14855: LD_INT 35
14857: PUSH
14858: LD_INT 49
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PUSH
14865: LD_INT 91
14867: PUSH
14868: LD_VAR 0 1
14872: PUSH
14873: LD_INT 10
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: LIST
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: LIST
14885: PPUSH
14886: CALL_OW 69
14890: NOT
14891: IFFALSE 14901
// weapon := ru_time_lapser ;
14893: LD_ADDR_VAR 0 18
14897: PUSH
14898: LD_INT 49
14900: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
14901: LD_VAR 0 12
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: LD_INT 2
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: IN
14916: PUSH
14917: LD_INT 11
14919: PUSH
14920: LD_VAR 0 5
14924: IN
14925: PUSH
14926: LD_INT 30
14928: PUSH
14929: LD_VAR 0 5
14933: IN
14934: OR
14935: AND
14936: PUSH
14937: LD_INT 6
14939: PPUSH
14940: LD_VAR 0 16
14944: PPUSH
14945: CALL_OW 321
14949: PUSH
14950: LD_INT 2
14952: EQUAL
14953: AND
14954: IFFALSE 15119
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
14956: LD_INT 22
14958: PUSH
14959: LD_VAR 0 16
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PUSH
14968: LD_INT 2
14970: PUSH
14971: LD_INT 35
14973: PUSH
14974: LD_INT 11
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PUSH
14981: LD_INT 35
14983: PUSH
14984: LD_INT 30
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: PUSH
14991: EMPTY
14992: LIST
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 91
14998: PUSH
14999: LD_VAR 0 1
15003: PUSH
15004: LD_INT 18
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: LIST
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: LIST
15016: PPUSH
15017: CALL_OW 69
15021: NOT
15022: PUSH
15023: LD_INT 22
15025: PUSH
15026: LD_VAR 0 16
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: PUSH
15035: LD_INT 2
15037: PUSH
15038: LD_INT 30
15040: PUSH
15041: LD_INT 32
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: LD_INT 30
15050: PUSH
15051: LD_INT 33
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PUSH
15058: EMPTY
15059: LIST
15060: LIST
15061: LIST
15062: PUSH
15063: LD_INT 91
15065: PUSH
15066: LD_VAR 0 1
15070: PUSH
15071: LD_INT 12
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: LIST
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: LIST
15083: PUSH
15084: EMPTY
15085: LIST
15086: PPUSH
15087: CALL_OW 69
15091: PUSH
15092: LD_INT 2
15094: GREATER
15095: AND
15096: IFFALSE 15119
// weapon := [ us_radar , ar_radar ] [ nat ] ;
15098: LD_ADDR_VAR 0 18
15102: PUSH
15103: LD_INT 11
15105: PUSH
15106: LD_INT 30
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PUSH
15113: LD_VAR 0 12
15117: ARRAY
15118: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
15119: LD_VAR 0 18
15123: NOT
15124: PUSH
15125: LD_INT 40
15127: PPUSH
15128: LD_VAR 0 16
15132: PPUSH
15133: CALL_OW 321
15137: PUSH
15138: LD_INT 2
15140: EQUAL
15141: AND
15142: PUSH
15143: LD_INT 7
15145: PUSH
15146: LD_VAR 0 5
15150: IN
15151: PUSH
15152: LD_INT 28
15154: PUSH
15155: LD_VAR 0 5
15159: IN
15160: OR
15161: PUSH
15162: LD_INT 45
15164: PUSH
15165: LD_VAR 0 5
15169: IN
15170: OR
15171: AND
15172: IFFALSE 15426
// begin hex := GetHexInfo ( x , y ) ;
15174: LD_ADDR_VAR 0 4
15178: PUSH
15179: LD_VAR 0 10
15183: PPUSH
15184: LD_VAR 0 11
15188: PPUSH
15189: CALL_OW 546
15193: ST_TO_ADDR
// if hex [ 1 ] then
15194: LD_VAR 0 4
15198: PUSH
15199: LD_INT 1
15201: ARRAY
15202: IFFALSE 15206
// exit ;
15204: GO 15609
// height := hex [ 2 ] ;
15206: LD_ADDR_VAR 0 15
15210: PUSH
15211: LD_VAR 0 4
15215: PUSH
15216: LD_INT 2
15218: ARRAY
15219: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
15220: LD_ADDR_VAR 0 14
15224: PUSH
15225: LD_INT 0
15227: PUSH
15228: LD_INT 2
15230: PUSH
15231: LD_INT 3
15233: PUSH
15234: LD_INT 5
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: ST_TO_ADDR
// for i in tmp do
15243: LD_ADDR_VAR 0 8
15247: PUSH
15248: LD_VAR 0 14
15252: PUSH
15253: FOR_IN
15254: IFFALSE 15424
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
15256: LD_ADDR_VAR 0 9
15260: PUSH
15261: LD_VAR 0 10
15265: PPUSH
15266: LD_VAR 0 8
15270: PPUSH
15271: LD_INT 5
15273: PPUSH
15274: CALL_OW 272
15278: PUSH
15279: LD_VAR 0 11
15283: PPUSH
15284: LD_VAR 0 8
15288: PPUSH
15289: LD_INT 5
15291: PPUSH
15292: CALL_OW 273
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
15301: LD_VAR 0 9
15305: PUSH
15306: LD_INT 1
15308: ARRAY
15309: PPUSH
15310: LD_VAR 0 9
15314: PUSH
15315: LD_INT 2
15317: ARRAY
15318: PPUSH
15319: CALL_OW 488
15323: IFFALSE 15422
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
15325: LD_ADDR_VAR 0 4
15329: PUSH
15330: LD_VAR 0 9
15334: PUSH
15335: LD_INT 1
15337: ARRAY
15338: PPUSH
15339: LD_VAR 0 9
15343: PUSH
15344: LD_INT 2
15346: ARRAY
15347: PPUSH
15348: CALL_OW 546
15352: ST_TO_ADDR
// if hex [ 1 ] then
15353: LD_VAR 0 4
15357: PUSH
15358: LD_INT 1
15360: ARRAY
15361: IFFALSE 15365
// continue ;
15363: GO 15253
// h := hex [ 2 ] ;
15365: LD_ADDR_VAR 0 13
15369: PUSH
15370: LD_VAR 0 4
15374: PUSH
15375: LD_INT 2
15377: ARRAY
15378: ST_TO_ADDR
// if h + 7 < height then
15379: LD_VAR 0 13
15383: PUSH
15384: LD_INT 7
15386: PLUS
15387: PUSH
15388: LD_VAR 0 15
15392: LESS
15393: IFFALSE 15422
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
15395: LD_ADDR_VAR 0 18
15399: PUSH
15400: LD_INT 7
15402: PUSH
15403: LD_INT 28
15405: PUSH
15406: LD_INT 45
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: LIST
15413: PUSH
15414: LD_VAR 0 12
15418: ARRAY
15419: ST_TO_ADDR
// break ;
15420: GO 15424
// end ; end ; end ;
15422: GO 15253
15424: POP
15425: POP
// end ; if not weapon then
15426: LD_VAR 0 18
15430: NOT
15431: IFFALSE 15491
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
15433: LD_ADDR_VAR 0 5
15437: PUSH
15438: LD_VAR 0 5
15442: PUSH
15443: LD_INT 11
15445: PUSH
15446: LD_INT 30
15448: PUSH
15449: LD_INT 49
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: LIST
15456: DIFF
15457: ST_TO_ADDR
// if not list then
15458: LD_VAR 0 5
15462: NOT
15463: IFFALSE 15467
// exit ;
15465: GO 15609
// weapon := list [ rand ( 1 , list ) ] ;
15467: LD_ADDR_VAR 0 18
15471: PUSH
15472: LD_VAR 0 5
15476: PUSH
15477: LD_INT 1
15479: PPUSH
15480: LD_VAR 0 5
15484: PPUSH
15485: CALL_OW 12
15489: ARRAY
15490: ST_TO_ADDR
// end ; if weapon then
15491: LD_VAR 0 18
15495: IFFALSE 15609
// begin tmp := CostOfWeapon ( weapon ) ;
15497: LD_ADDR_VAR 0 14
15501: PUSH
15502: LD_VAR 0 18
15506: PPUSH
15507: CALL_OW 451
15511: ST_TO_ADDR
// j := GetBase ( tower ) ;
15512: LD_ADDR_VAR 0 9
15516: PUSH
15517: LD_VAR 0 1
15521: PPUSH
15522: CALL_OW 274
15526: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
15527: LD_VAR 0 9
15531: PPUSH
15532: LD_INT 1
15534: PPUSH
15535: CALL_OW 275
15539: PUSH
15540: LD_VAR 0 14
15544: PUSH
15545: LD_INT 1
15547: ARRAY
15548: GREATEREQUAL
15549: PUSH
15550: LD_VAR 0 9
15554: PPUSH
15555: LD_INT 2
15557: PPUSH
15558: CALL_OW 275
15562: PUSH
15563: LD_VAR 0 14
15567: PUSH
15568: LD_INT 2
15570: ARRAY
15571: GREATEREQUAL
15572: AND
15573: PUSH
15574: LD_VAR 0 9
15578: PPUSH
15579: LD_INT 3
15581: PPUSH
15582: CALL_OW 275
15586: PUSH
15587: LD_VAR 0 14
15591: PUSH
15592: LD_INT 3
15594: ARRAY
15595: GREATEREQUAL
15596: AND
15597: IFFALSE 15609
// result := weapon ;
15599: LD_ADDR_VAR 0 3
15603: PUSH
15604: LD_VAR 0 18
15608: ST_TO_ADDR
// end ; end ;
15609: LD_VAR 0 3
15613: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
15614: LD_INT 0
15616: PPUSH
15617: PPUSH
// result := true ;
15618: LD_ADDR_VAR 0 3
15622: PUSH
15623: LD_INT 1
15625: ST_TO_ADDR
// if array1 = array2 then
15626: LD_VAR 0 1
15630: PUSH
15631: LD_VAR 0 2
15635: EQUAL
15636: IFFALSE 15696
// begin for i = 1 to array1 do
15638: LD_ADDR_VAR 0 4
15642: PUSH
15643: DOUBLE
15644: LD_INT 1
15646: DEC
15647: ST_TO_ADDR
15648: LD_VAR 0 1
15652: PUSH
15653: FOR_TO
15654: IFFALSE 15692
// if array1 [ i ] <> array2 [ i ] then
15656: LD_VAR 0 1
15660: PUSH
15661: LD_VAR 0 4
15665: ARRAY
15666: PUSH
15667: LD_VAR 0 2
15671: PUSH
15672: LD_VAR 0 4
15676: ARRAY
15677: NONEQUAL
15678: IFFALSE 15690
// begin result := false ;
15680: LD_ADDR_VAR 0 3
15684: PUSH
15685: LD_INT 0
15687: ST_TO_ADDR
// break ;
15688: GO 15692
// end ;
15690: GO 15653
15692: POP
15693: POP
// end else
15694: GO 15704
// result := false ;
15696: LD_ADDR_VAR 0 3
15700: PUSH
15701: LD_INT 0
15703: ST_TO_ADDR
// end ;
15704: LD_VAR 0 3
15708: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
15709: LD_INT 0
15711: PPUSH
15712: PPUSH
15713: PPUSH
// pom := GetBase ( fac ) ;
15714: LD_ADDR_VAR 0 5
15718: PUSH
15719: LD_VAR 0 1
15723: PPUSH
15724: CALL_OW 274
15728: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
15729: LD_ADDR_VAR 0 4
15733: PUSH
15734: LD_VAR 0 2
15738: PUSH
15739: LD_INT 1
15741: ARRAY
15742: PPUSH
15743: LD_VAR 0 2
15747: PUSH
15748: LD_INT 2
15750: ARRAY
15751: PPUSH
15752: LD_VAR 0 2
15756: PUSH
15757: LD_INT 3
15759: ARRAY
15760: PPUSH
15761: LD_VAR 0 2
15765: PUSH
15766: LD_INT 4
15768: ARRAY
15769: PPUSH
15770: CALL_OW 449
15774: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15775: LD_ADDR_VAR 0 3
15779: PUSH
15780: LD_VAR 0 5
15784: PPUSH
15785: LD_INT 1
15787: PPUSH
15788: CALL_OW 275
15792: PUSH
15793: LD_VAR 0 4
15797: PUSH
15798: LD_INT 1
15800: ARRAY
15801: GREATEREQUAL
15802: PUSH
15803: LD_VAR 0 5
15807: PPUSH
15808: LD_INT 2
15810: PPUSH
15811: CALL_OW 275
15815: PUSH
15816: LD_VAR 0 4
15820: PUSH
15821: LD_INT 2
15823: ARRAY
15824: GREATEREQUAL
15825: AND
15826: PUSH
15827: LD_VAR 0 5
15831: PPUSH
15832: LD_INT 3
15834: PPUSH
15835: CALL_OW 275
15839: PUSH
15840: LD_VAR 0 4
15844: PUSH
15845: LD_INT 3
15847: ARRAY
15848: GREATEREQUAL
15849: AND
15850: ST_TO_ADDR
// end ;
15851: LD_VAR 0 3
15855: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
15856: LD_INT 0
15858: PPUSH
15859: PPUSH
15860: PPUSH
15861: PPUSH
// pom := GetBase ( building ) ;
15862: LD_ADDR_VAR 0 3
15866: PUSH
15867: LD_VAR 0 1
15871: PPUSH
15872: CALL_OW 274
15876: ST_TO_ADDR
// if not pom then
15877: LD_VAR 0 3
15881: NOT
15882: IFFALSE 15886
// exit ;
15884: GO 16056
// btype := GetBType ( building ) ;
15886: LD_ADDR_VAR 0 5
15890: PUSH
15891: LD_VAR 0 1
15895: PPUSH
15896: CALL_OW 266
15900: ST_TO_ADDR
// if btype = b_armoury then
15901: LD_VAR 0 5
15905: PUSH
15906: LD_INT 4
15908: EQUAL
15909: IFFALSE 15919
// btype := b_barracks ;
15911: LD_ADDR_VAR 0 5
15915: PUSH
15916: LD_INT 5
15918: ST_TO_ADDR
// if btype = b_depot then
15919: LD_VAR 0 5
15923: PUSH
15924: LD_INT 0
15926: EQUAL
15927: IFFALSE 15937
// btype := b_warehouse ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_INT 1
15936: ST_TO_ADDR
// if btype = b_workshop then
15937: LD_VAR 0 5
15941: PUSH
15942: LD_INT 2
15944: EQUAL
15945: IFFALSE 15955
// btype := b_factory ;
15947: LD_ADDR_VAR 0 5
15951: PUSH
15952: LD_INT 3
15954: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
15955: LD_ADDR_VAR 0 4
15959: PUSH
15960: LD_VAR 0 5
15964: PPUSH
15965: LD_VAR 0 1
15969: PPUSH
15970: CALL_OW 248
15974: PPUSH
15975: CALL_OW 450
15979: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15980: LD_ADDR_VAR 0 2
15984: PUSH
15985: LD_VAR 0 3
15989: PPUSH
15990: LD_INT 1
15992: PPUSH
15993: CALL_OW 275
15997: PUSH
15998: LD_VAR 0 4
16002: PUSH
16003: LD_INT 1
16005: ARRAY
16006: GREATEREQUAL
16007: PUSH
16008: LD_VAR 0 3
16012: PPUSH
16013: LD_INT 2
16015: PPUSH
16016: CALL_OW 275
16020: PUSH
16021: LD_VAR 0 4
16025: PUSH
16026: LD_INT 2
16028: ARRAY
16029: GREATEREQUAL
16030: AND
16031: PUSH
16032: LD_VAR 0 3
16036: PPUSH
16037: LD_INT 3
16039: PPUSH
16040: CALL_OW 275
16044: PUSH
16045: LD_VAR 0 4
16049: PUSH
16050: LD_INT 3
16052: ARRAY
16053: GREATEREQUAL
16054: AND
16055: ST_TO_ADDR
// end ;
16056: LD_VAR 0 2
16060: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
16061: LD_INT 0
16063: PPUSH
16064: PPUSH
16065: PPUSH
// pom := GetBase ( building ) ;
16066: LD_ADDR_VAR 0 4
16070: PUSH
16071: LD_VAR 0 1
16075: PPUSH
16076: CALL_OW 274
16080: ST_TO_ADDR
// if not pom then
16081: LD_VAR 0 4
16085: NOT
16086: IFFALSE 16090
// exit ;
16088: GO 16191
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16090: LD_ADDR_VAR 0 5
16094: PUSH
16095: LD_VAR 0 2
16099: PPUSH
16100: LD_VAR 0 1
16104: PPUSH
16105: CALL_OW 248
16109: PPUSH
16110: CALL_OW 450
16114: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16115: LD_ADDR_VAR 0 3
16119: PUSH
16120: LD_VAR 0 4
16124: PPUSH
16125: LD_INT 1
16127: PPUSH
16128: CALL_OW 275
16132: PUSH
16133: LD_VAR 0 5
16137: PUSH
16138: LD_INT 1
16140: ARRAY
16141: GREATEREQUAL
16142: PUSH
16143: LD_VAR 0 4
16147: PPUSH
16148: LD_INT 2
16150: PPUSH
16151: CALL_OW 275
16155: PUSH
16156: LD_VAR 0 5
16160: PUSH
16161: LD_INT 2
16163: ARRAY
16164: GREATEREQUAL
16165: AND
16166: PUSH
16167: LD_VAR 0 4
16171: PPUSH
16172: LD_INT 3
16174: PPUSH
16175: CALL_OW 275
16179: PUSH
16180: LD_VAR 0 5
16184: PUSH
16185: LD_INT 3
16187: ARRAY
16188: GREATEREQUAL
16189: AND
16190: ST_TO_ADDR
// end ;
16191: LD_VAR 0 3
16195: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
16196: LD_INT 0
16198: PPUSH
16199: PPUSH
16200: PPUSH
16201: PPUSH
16202: PPUSH
16203: PPUSH
16204: PPUSH
16205: PPUSH
16206: PPUSH
16207: PPUSH
// result := false ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_INT 0
16215: ST_TO_ADDR
// if not base or not btype or not x or not y then
16216: LD_VAR 0 1
16220: NOT
16221: PUSH
16222: LD_VAR 0 2
16226: NOT
16227: OR
16228: PUSH
16229: LD_VAR 0 3
16233: NOT
16234: OR
16235: PUSH
16236: LD_VAR 0 4
16240: NOT
16241: OR
16242: IFFALSE 16246
// exit ;
16244: GO 16855
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
16246: LD_ADDR_VAR 0 12
16250: PUSH
16251: LD_VAR 0 2
16255: PPUSH
16256: LD_VAR 0 3
16260: PPUSH
16261: LD_VAR 0 4
16265: PPUSH
16266: LD_VAR 0 5
16270: PPUSH
16271: LD_VAR 0 1
16275: PUSH
16276: LD_INT 1
16278: ARRAY
16279: PPUSH
16280: CALL_OW 248
16284: PPUSH
16285: LD_INT 0
16287: PPUSH
16288: CALL 17692 0 6
16292: ST_TO_ADDR
// if not hexes then
16293: LD_VAR 0 12
16297: NOT
16298: IFFALSE 16302
// exit ;
16300: GO 16855
// for i = 1 to hexes do
16302: LD_ADDR_VAR 0 7
16306: PUSH
16307: DOUBLE
16308: LD_INT 1
16310: DEC
16311: ST_TO_ADDR
16312: LD_VAR 0 12
16316: PUSH
16317: FOR_TO
16318: IFFALSE 16853
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
16320: LD_ADDR_VAR 0 11
16324: PUSH
16325: LD_VAR 0 12
16329: PUSH
16330: LD_VAR 0 7
16334: ARRAY
16335: PUSH
16336: LD_INT 1
16338: ARRAY
16339: PPUSH
16340: LD_VAR 0 12
16344: PUSH
16345: LD_VAR 0 7
16349: ARRAY
16350: PUSH
16351: LD_INT 2
16353: ARRAY
16354: PPUSH
16355: CALL_OW 428
16359: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
16360: LD_VAR 0 12
16364: PUSH
16365: LD_VAR 0 7
16369: ARRAY
16370: PUSH
16371: LD_INT 1
16373: ARRAY
16374: PPUSH
16375: LD_VAR 0 12
16379: PUSH
16380: LD_VAR 0 7
16384: ARRAY
16385: PUSH
16386: LD_INT 2
16388: ARRAY
16389: PPUSH
16390: CALL_OW 351
16394: PUSH
16395: LD_VAR 0 12
16399: PUSH
16400: LD_VAR 0 7
16404: ARRAY
16405: PUSH
16406: LD_INT 1
16408: ARRAY
16409: PPUSH
16410: LD_VAR 0 12
16414: PUSH
16415: LD_VAR 0 7
16419: ARRAY
16420: PUSH
16421: LD_INT 2
16423: ARRAY
16424: PPUSH
16425: CALL_OW 488
16429: NOT
16430: OR
16431: PUSH
16432: LD_VAR 0 11
16436: PPUSH
16437: CALL_OW 247
16441: PUSH
16442: LD_INT 3
16444: EQUAL
16445: OR
16446: IFFALSE 16452
// exit ;
16448: POP
16449: POP
16450: GO 16855
// if not tmp or not tmp in base then
16452: LD_VAR 0 11
16456: NOT
16457: PUSH
16458: LD_VAR 0 11
16462: PUSH
16463: LD_VAR 0 1
16467: IN
16468: NOT
16469: OR
16470: IFFALSE 16474
// continue ;
16472: GO 16317
// result := true ;
16474: LD_ADDR_VAR 0 6
16478: PUSH
16479: LD_INT 1
16481: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16482: LD_ADDR_VAR 0 15
16486: PUSH
16487: LD_VAR 0 1
16491: PPUSH
16492: LD_INT 22
16494: PUSH
16495: LD_VAR 0 11
16499: PPUSH
16500: CALL_OW 255
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: PUSH
16509: LD_INT 2
16511: PUSH
16512: LD_INT 30
16514: PUSH
16515: LD_INT 0
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: LD_INT 30
16524: PUSH
16525: LD_INT 1
16527: PUSH
16528: EMPTY
16529: LIST
16530: LIST
16531: PUSH
16532: EMPTY
16533: LIST
16534: LIST
16535: LIST
16536: PUSH
16537: EMPTY
16538: LIST
16539: LIST
16540: PPUSH
16541: CALL_OW 72
16545: ST_TO_ADDR
// if dep then
16546: LD_VAR 0 15
16550: IFFALSE 16686
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
16552: LD_ADDR_VAR 0 14
16556: PUSH
16557: LD_VAR 0 15
16561: PUSH
16562: LD_INT 1
16564: ARRAY
16565: PPUSH
16566: CALL_OW 250
16570: PPUSH
16571: LD_VAR 0 15
16575: PUSH
16576: LD_INT 1
16578: ARRAY
16579: PPUSH
16580: CALL_OW 254
16584: PPUSH
16585: LD_INT 5
16587: PPUSH
16588: CALL_OW 272
16592: PUSH
16593: LD_VAR 0 15
16597: PUSH
16598: LD_INT 1
16600: ARRAY
16601: PPUSH
16602: CALL_OW 251
16606: PPUSH
16607: LD_VAR 0 15
16611: PUSH
16612: LD_INT 1
16614: ARRAY
16615: PPUSH
16616: CALL_OW 254
16620: PPUSH
16621: LD_INT 5
16623: PPUSH
16624: CALL_OW 273
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
16633: LD_VAR 0 14
16637: PUSH
16638: LD_INT 1
16640: ARRAY
16641: PPUSH
16642: LD_VAR 0 14
16646: PUSH
16647: LD_INT 2
16649: ARRAY
16650: PPUSH
16651: CALL_OW 488
16655: IFFALSE 16686
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
16657: LD_VAR 0 11
16661: PPUSH
16662: LD_VAR 0 14
16666: PUSH
16667: LD_INT 1
16669: ARRAY
16670: PPUSH
16671: LD_VAR 0 14
16675: PUSH
16676: LD_INT 2
16678: ARRAY
16679: PPUSH
16680: CALL_OW 111
// continue ;
16684: GO 16317
// end ; end ; r := GetDir ( tmp ) ;
16686: LD_ADDR_VAR 0 13
16690: PUSH
16691: LD_VAR 0 11
16695: PPUSH
16696: CALL_OW 254
16700: ST_TO_ADDR
// if r = 5 then
16701: LD_VAR 0 13
16705: PUSH
16706: LD_INT 5
16708: EQUAL
16709: IFFALSE 16719
// r := 0 ;
16711: LD_ADDR_VAR 0 13
16715: PUSH
16716: LD_INT 0
16718: ST_TO_ADDR
// for j = r to 5 do
16719: LD_ADDR_VAR 0 8
16723: PUSH
16724: DOUBLE
16725: LD_VAR 0 13
16729: DEC
16730: ST_TO_ADDR
16731: LD_INT 5
16733: PUSH
16734: FOR_TO
16735: IFFALSE 16849
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
16737: LD_ADDR_VAR 0 9
16741: PUSH
16742: LD_VAR 0 11
16746: PPUSH
16747: CALL_OW 250
16751: PPUSH
16752: LD_VAR 0 8
16756: PPUSH
16757: LD_INT 2
16759: PPUSH
16760: CALL_OW 272
16764: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
16765: LD_ADDR_VAR 0 10
16769: PUSH
16770: LD_VAR 0 11
16774: PPUSH
16775: CALL_OW 251
16779: PPUSH
16780: LD_VAR 0 8
16784: PPUSH
16785: LD_INT 2
16787: PPUSH
16788: CALL_OW 273
16792: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
16793: LD_VAR 0 9
16797: PPUSH
16798: LD_VAR 0 10
16802: PPUSH
16803: CALL_OW 488
16807: PUSH
16808: LD_VAR 0 9
16812: PPUSH
16813: LD_VAR 0 10
16817: PPUSH
16818: CALL_OW 428
16822: NOT
16823: AND
16824: IFFALSE 16847
// begin ComMoveXY ( tmp , _x , _y ) ;
16826: LD_VAR 0 11
16830: PPUSH
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_VAR 0 10
16840: PPUSH
16841: CALL_OW 111
// break ;
16845: GO 16849
// end ; end ;
16847: GO 16734
16849: POP
16850: POP
// end ;
16851: GO 16317
16853: POP
16854: POP
// end ;
16855: LD_VAR 0 6
16859: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
16860: LD_INT 0
16862: PPUSH
16863: PPUSH
16864: PPUSH
16865: PPUSH
16866: PPUSH
16867: PPUSH
16868: PPUSH
16869: PPUSH
16870: PPUSH
16871: PPUSH
// result := false ;
16872: LD_ADDR_VAR 0 6
16876: PUSH
16877: LD_INT 0
16879: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
16880: LD_VAR 0 1
16884: NOT
16885: PUSH
16886: LD_VAR 0 1
16890: PPUSH
16891: CALL_OW 266
16895: PUSH
16896: LD_INT 0
16898: PUSH
16899: LD_INT 1
16901: PUSH
16902: EMPTY
16903: LIST
16904: LIST
16905: IN
16906: NOT
16907: OR
16908: PUSH
16909: LD_VAR 0 2
16913: NOT
16914: OR
16915: PUSH
16916: LD_VAR 0 5
16920: PUSH
16921: LD_INT 0
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 3
16932: PUSH
16933: LD_INT 4
16935: PUSH
16936: LD_INT 5
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: IN
16947: NOT
16948: OR
16949: PUSH
16950: LD_VAR 0 3
16954: PPUSH
16955: LD_VAR 0 4
16959: PPUSH
16960: CALL_OW 488
16964: NOT
16965: OR
16966: IFFALSE 16970
// exit ;
16968: GO 17687
// pom := GetBase ( depot ) ;
16970: LD_ADDR_VAR 0 10
16974: PUSH
16975: LD_VAR 0 1
16979: PPUSH
16980: CALL_OW 274
16984: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
16985: LD_ADDR_VAR 0 11
16989: PUSH
16990: LD_VAR 0 2
16994: PPUSH
16995: LD_VAR 0 1
16999: PPUSH
17000: CALL_OW 248
17004: PPUSH
17005: CALL_OW 450
17009: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
17010: LD_VAR 0 10
17014: PPUSH
17015: LD_INT 1
17017: PPUSH
17018: CALL_OW 275
17022: PUSH
17023: LD_VAR 0 11
17027: PUSH
17028: LD_INT 1
17030: ARRAY
17031: GREATEREQUAL
17032: PUSH
17033: LD_VAR 0 10
17037: PPUSH
17038: LD_INT 2
17040: PPUSH
17041: CALL_OW 275
17045: PUSH
17046: LD_VAR 0 11
17050: PUSH
17051: LD_INT 2
17053: ARRAY
17054: GREATEREQUAL
17055: AND
17056: PUSH
17057: LD_VAR 0 10
17061: PPUSH
17062: LD_INT 3
17064: PPUSH
17065: CALL_OW 275
17069: PUSH
17070: LD_VAR 0 11
17074: PUSH
17075: LD_INT 3
17077: ARRAY
17078: GREATEREQUAL
17079: AND
17080: NOT
17081: IFFALSE 17085
// exit ;
17083: GO 17687
// if GetBType ( depot ) = b_depot then
17085: LD_VAR 0 1
17089: PPUSH
17090: CALL_OW 266
17094: PUSH
17095: LD_INT 0
17097: EQUAL
17098: IFFALSE 17110
// dist := 28 else
17100: LD_ADDR_VAR 0 14
17104: PUSH
17105: LD_INT 28
17107: ST_TO_ADDR
17108: GO 17118
// dist := 36 ;
17110: LD_ADDR_VAR 0 14
17114: PUSH
17115: LD_INT 36
17117: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
17118: LD_VAR 0 1
17122: PPUSH
17123: LD_VAR 0 3
17127: PPUSH
17128: LD_VAR 0 4
17132: PPUSH
17133: CALL_OW 297
17137: PUSH
17138: LD_VAR 0 14
17142: GREATER
17143: IFFALSE 17147
// exit ;
17145: GO 17687
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
17147: LD_ADDR_VAR 0 12
17151: PUSH
17152: LD_VAR 0 2
17156: PPUSH
17157: LD_VAR 0 3
17161: PPUSH
17162: LD_VAR 0 4
17166: PPUSH
17167: LD_VAR 0 5
17171: PPUSH
17172: LD_VAR 0 1
17176: PPUSH
17177: CALL_OW 248
17181: PPUSH
17182: LD_INT 0
17184: PPUSH
17185: CALL 17692 0 6
17189: ST_TO_ADDR
// if not hexes then
17190: LD_VAR 0 12
17194: NOT
17195: IFFALSE 17199
// exit ;
17197: GO 17687
// hex := GetHexInfo ( x , y ) ;
17199: LD_ADDR_VAR 0 15
17203: PUSH
17204: LD_VAR 0 3
17208: PPUSH
17209: LD_VAR 0 4
17213: PPUSH
17214: CALL_OW 546
17218: ST_TO_ADDR
// if hex [ 1 ] then
17219: LD_VAR 0 15
17223: PUSH
17224: LD_INT 1
17226: ARRAY
17227: IFFALSE 17231
// exit ;
17229: GO 17687
// height := hex [ 2 ] ;
17231: LD_ADDR_VAR 0 13
17235: PUSH
17236: LD_VAR 0 15
17240: PUSH
17241: LD_INT 2
17243: ARRAY
17244: ST_TO_ADDR
// for i = 1 to hexes do
17245: LD_ADDR_VAR 0 7
17249: PUSH
17250: DOUBLE
17251: LD_INT 1
17253: DEC
17254: ST_TO_ADDR
17255: LD_VAR 0 12
17259: PUSH
17260: FOR_TO
17261: IFFALSE 17591
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
17263: LD_VAR 0 12
17267: PUSH
17268: LD_VAR 0 7
17272: ARRAY
17273: PUSH
17274: LD_INT 1
17276: ARRAY
17277: PPUSH
17278: LD_VAR 0 12
17282: PUSH
17283: LD_VAR 0 7
17287: ARRAY
17288: PUSH
17289: LD_INT 2
17291: ARRAY
17292: PPUSH
17293: CALL_OW 488
17297: NOT
17298: PUSH
17299: LD_VAR 0 12
17303: PUSH
17304: LD_VAR 0 7
17308: ARRAY
17309: PUSH
17310: LD_INT 1
17312: ARRAY
17313: PPUSH
17314: LD_VAR 0 12
17318: PUSH
17319: LD_VAR 0 7
17323: ARRAY
17324: PUSH
17325: LD_INT 2
17327: ARRAY
17328: PPUSH
17329: CALL_OW 428
17333: PUSH
17334: LD_INT 0
17336: GREATER
17337: OR
17338: PUSH
17339: LD_VAR 0 12
17343: PUSH
17344: LD_VAR 0 7
17348: ARRAY
17349: PUSH
17350: LD_INT 1
17352: ARRAY
17353: PPUSH
17354: LD_VAR 0 12
17358: PUSH
17359: LD_VAR 0 7
17363: ARRAY
17364: PUSH
17365: LD_INT 2
17367: ARRAY
17368: PPUSH
17369: CALL_OW 351
17373: OR
17374: IFFALSE 17380
// exit ;
17376: POP
17377: POP
17378: GO 17687
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
17380: LD_ADDR_VAR 0 8
17384: PUSH
17385: LD_VAR 0 12
17389: PUSH
17390: LD_VAR 0 7
17394: ARRAY
17395: PUSH
17396: LD_INT 1
17398: ARRAY
17399: PPUSH
17400: LD_VAR 0 12
17404: PUSH
17405: LD_VAR 0 7
17409: ARRAY
17410: PUSH
17411: LD_INT 2
17413: ARRAY
17414: PPUSH
17415: CALL_OW 546
17419: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
17420: LD_VAR 0 8
17424: PUSH
17425: LD_INT 1
17427: ARRAY
17428: PUSH
17429: LD_VAR 0 8
17433: PUSH
17434: LD_INT 2
17436: ARRAY
17437: PUSH
17438: LD_VAR 0 13
17442: PUSH
17443: LD_INT 2
17445: PLUS
17446: GREATER
17447: OR
17448: PUSH
17449: LD_VAR 0 8
17453: PUSH
17454: LD_INT 2
17456: ARRAY
17457: PUSH
17458: LD_VAR 0 13
17462: PUSH
17463: LD_INT 2
17465: MINUS
17466: LESS
17467: OR
17468: PUSH
17469: LD_VAR 0 8
17473: PUSH
17474: LD_INT 3
17476: ARRAY
17477: PUSH
17478: LD_INT 0
17480: PUSH
17481: LD_INT 8
17483: PUSH
17484: LD_INT 9
17486: PUSH
17487: LD_INT 10
17489: PUSH
17490: LD_INT 11
17492: PUSH
17493: LD_INT 12
17495: PUSH
17496: LD_INT 13
17498: PUSH
17499: LD_INT 16
17501: PUSH
17502: LD_INT 17
17504: PUSH
17505: LD_INT 18
17507: PUSH
17508: LD_INT 19
17510: PUSH
17511: LD_INT 20
17513: PUSH
17514: LD_INT 21
17516: PUSH
17517: EMPTY
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: IN
17532: NOT
17533: OR
17534: PUSH
17535: LD_VAR 0 8
17539: PUSH
17540: LD_INT 5
17542: ARRAY
17543: NOT
17544: OR
17545: PUSH
17546: LD_VAR 0 8
17550: PUSH
17551: LD_INT 6
17553: ARRAY
17554: PUSH
17555: LD_INT 1
17557: PUSH
17558: LD_INT 2
17560: PUSH
17561: LD_INT 7
17563: PUSH
17564: LD_INT 9
17566: PUSH
17567: LD_INT 10
17569: PUSH
17570: LD_INT 11
17572: PUSH
17573: EMPTY
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: IN
17581: NOT
17582: OR
17583: IFFALSE 17589
// exit ;
17585: POP
17586: POP
17587: GO 17687
// end ;
17589: GO 17260
17591: POP
17592: POP
// side := GetSide ( depot ) ;
17593: LD_ADDR_VAR 0 9
17597: PUSH
17598: LD_VAR 0 1
17602: PPUSH
17603: CALL_OW 255
17607: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
17608: LD_VAR 0 9
17612: PPUSH
17613: LD_VAR 0 3
17617: PPUSH
17618: LD_VAR 0 4
17622: PPUSH
17623: LD_INT 20
17625: PPUSH
17626: CALL 10341 0 4
17630: PUSH
17631: LD_INT 4
17633: ARRAY
17634: IFFALSE 17638
// exit ;
17636: GO 17687
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
17638: LD_VAR 0 2
17642: PUSH
17643: LD_INT 29
17645: PUSH
17646: LD_INT 30
17648: PUSH
17649: EMPTY
17650: LIST
17651: LIST
17652: IN
17653: PUSH
17654: LD_VAR 0 3
17658: PPUSH
17659: LD_VAR 0 4
17663: PPUSH
17664: LD_VAR 0 9
17668: PPUSH
17669: CALL_OW 440
17673: NOT
17674: AND
17675: IFFALSE 17679
// exit ;
17677: GO 17687
// result := true ;
17679: LD_ADDR_VAR 0 6
17683: PUSH
17684: LD_INT 1
17686: ST_TO_ADDR
// end ;
17687: LD_VAR 0 6
17691: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
17692: LD_INT 0
17694: PPUSH
17695: PPUSH
17696: PPUSH
17697: PPUSH
17698: PPUSH
17699: PPUSH
17700: PPUSH
17701: PPUSH
17702: PPUSH
17703: PPUSH
17704: PPUSH
17705: PPUSH
17706: PPUSH
17707: PPUSH
17708: PPUSH
17709: PPUSH
17710: PPUSH
17711: PPUSH
17712: PPUSH
17713: PPUSH
17714: PPUSH
17715: PPUSH
17716: PPUSH
17717: PPUSH
17718: PPUSH
17719: PPUSH
17720: PPUSH
17721: PPUSH
17722: PPUSH
17723: PPUSH
17724: PPUSH
17725: PPUSH
17726: PPUSH
17727: PPUSH
17728: PPUSH
17729: PPUSH
17730: PPUSH
17731: PPUSH
17732: PPUSH
17733: PPUSH
17734: PPUSH
17735: PPUSH
17736: PPUSH
17737: PPUSH
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
17743: PPUSH
17744: PPUSH
17745: PPUSH
17746: PPUSH
17747: PPUSH
17748: PPUSH
17749: PPUSH
17750: PPUSH
17751: PPUSH
// result = [ ] ;
17752: LD_ADDR_VAR 0 7
17756: PUSH
17757: EMPTY
17758: ST_TO_ADDR
// temp_list = [ ] ;
17759: LD_ADDR_VAR 0 9
17763: PUSH
17764: EMPTY
17765: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
17766: LD_VAR 0 4
17770: PUSH
17771: LD_INT 0
17773: PUSH
17774: LD_INT 1
17776: PUSH
17777: LD_INT 2
17779: PUSH
17780: LD_INT 3
17782: PUSH
17783: LD_INT 4
17785: PUSH
17786: LD_INT 5
17788: PUSH
17789: EMPTY
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: IN
17797: NOT
17798: PUSH
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 0
17806: PUSH
17807: LD_INT 1
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: IN
17814: PUSH
17815: LD_VAR 0 5
17819: PUSH
17820: LD_INT 1
17822: PUSH
17823: LD_INT 2
17825: PUSH
17826: LD_INT 3
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: LIST
17833: IN
17834: NOT
17835: AND
17836: OR
17837: IFFALSE 17841
// exit ;
17839: GO 36232
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
17841: LD_VAR 0 1
17845: PUSH
17846: LD_INT 6
17848: PUSH
17849: LD_INT 7
17851: PUSH
17852: LD_INT 8
17854: PUSH
17855: LD_INT 13
17857: PUSH
17858: LD_INT 12
17860: PUSH
17861: LD_INT 15
17863: PUSH
17864: LD_INT 11
17866: PUSH
17867: LD_INT 14
17869: PUSH
17870: LD_INT 10
17872: PUSH
17873: EMPTY
17874: LIST
17875: LIST
17876: LIST
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: LIST
17882: LIST
17883: IN
17884: IFFALSE 17894
// btype = b_lab ;
17886: LD_ADDR_VAR 0 1
17890: PUSH
17891: LD_INT 6
17893: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
17894: LD_VAR 0 6
17898: PUSH
17899: LD_INT 0
17901: PUSH
17902: LD_INT 1
17904: PUSH
17905: LD_INT 2
17907: PUSH
17908: EMPTY
17909: LIST
17910: LIST
17911: LIST
17912: IN
17913: NOT
17914: PUSH
17915: LD_VAR 0 1
17919: PUSH
17920: LD_INT 0
17922: PUSH
17923: LD_INT 1
17925: PUSH
17926: LD_INT 2
17928: PUSH
17929: LD_INT 3
17931: PUSH
17932: LD_INT 6
17934: PUSH
17935: LD_INT 36
17937: PUSH
17938: LD_INT 4
17940: PUSH
17941: LD_INT 5
17943: PUSH
17944: LD_INT 31
17946: PUSH
17947: LD_INT 32
17949: PUSH
17950: LD_INT 33
17952: PUSH
17953: EMPTY
17954: LIST
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: LIST
17964: LIST
17965: IN
17966: NOT
17967: PUSH
17968: LD_VAR 0 6
17972: PUSH
17973: LD_INT 1
17975: EQUAL
17976: AND
17977: OR
17978: PUSH
17979: LD_VAR 0 1
17983: PUSH
17984: LD_INT 2
17986: PUSH
17987: LD_INT 3
17989: PUSH
17990: EMPTY
17991: LIST
17992: LIST
17993: IN
17994: NOT
17995: PUSH
17996: LD_VAR 0 6
18000: PUSH
18001: LD_INT 2
18003: EQUAL
18004: AND
18005: OR
18006: IFFALSE 18016
// mode = 0 ;
18008: LD_ADDR_VAR 0 6
18012: PUSH
18013: LD_INT 0
18015: ST_TO_ADDR
// case mode of 0 :
18016: LD_VAR 0 6
18020: PUSH
18021: LD_INT 0
18023: DOUBLE
18024: EQUAL
18025: IFTRUE 18029
18027: GO 29482
18029: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
18030: LD_ADDR_VAR 0 11
18034: PUSH
18035: LD_INT 0
18037: PUSH
18038: LD_INT 0
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 0
18047: PUSH
18048: LD_INT 1
18050: NEG
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: PUSH
18056: LD_INT 1
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: EMPTY
18063: LIST
18064: LIST
18065: PUSH
18066: LD_INT 1
18068: PUSH
18069: LD_INT 1
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 1
18081: PUSH
18082: EMPTY
18083: LIST
18084: LIST
18085: PUSH
18086: LD_INT 1
18088: NEG
18089: PUSH
18090: LD_INT 0
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: PUSH
18097: LD_INT 1
18099: NEG
18100: PUSH
18101: LD_INT 1
18103: NEG
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PUSH
18109: LD_INT 1
18111: NEG
18112: PUSH
18113: LD_INT 2
18115: NEG
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: PUSH
18121: LD_INT 0
18123: PUSH
18124: LD_INT 2
18126: NEG
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: PUSH
18132: LD_INT 1
18134: PUSH
18135: LD_INT 1
18137: NEG
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: PUSH
18143: LD_INT 1
18145: PUSH
18146: LD_INT 2
18148: PUSH
18149: EMPTY
18150: LIST
18151: LIST
18152: PUSH
18153: LD_INT 0
18155: PUSH
18156: LD_INT 2
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: PUSH
18163: LD_INT 1
18165: NEG
18166: PUSH
18167: LD_INT 1
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: PUSH
18174: LD_INT 1
18176: PUSH
18177: LD_INT 3
18179: PUSH
18180: EMPTY
18181: LIST
18182: LIST
18183: PUSH
18184: LD_INT 0
18186: PUSH
18187: LD_INT 3
18189: PUSH
18190: EMPTY
18191: LIST
18192: LIST
18193: PUSH
18194: LD_INT 1
18196: NEG
18197: PUSH
18198: LD_INT 2
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: PUSH
18205: EMPTY
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
18223: LD_ADDR_VAR 0 12
18227: PUSH
18228: LD_INT 0
18230: PUSH
18231: LD_INT 0
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: PUSH
18238: LD_INT 0
18240: PUSH
18241: LD_INT 1
18243: NEG
18244: PUSH
18245: EMPTY
18246: LIST
18247: LIST
18248: PUSH
18249: LD_INT 1
18251: PUSH
18252: LD_INT 0
18254: PUSH
18255: EMPTY
18256: LIST
18257: LIST
18258: PUSH
18259: LD_INT 1
18261: PUSH
18262: LD_INT 1
18264: PUSH
18265: EMPTY
18266: LIST
18267: LIST
18268: PUSH
18269: LD_INT 0
18271: PUSH
18272: LD_INT 1
18274: PUSH
18275: EMPTY
18276: LIST
18277: LIST
18278: PUSH
18279: LD_INT 1
18281: NEG
18282: PUSH
18283: LD_INT 0
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 1
18292: NEG
18293: PUSH
18294: LD_INT 1
18296: NEG
18297: PUSH
18298: EMPTY
18299: LIST
18300: LIST
18301: PUSH
18302: LD_INT 1
18304: PUSH
18305: LD_INT 1
18307: NEG
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 2
18315: PUSH
18316: LD_INT 0
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 2
18325: PUSH
18326: LD_INT 1
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: LD_INT 1
18335: NEG
18336: PUSH
18337: LD_INT 1
18339: PUSH
18340: EMPTY
18341: LIST
18342: LIST
18343: PUSH
18344: LD_INT 2
18346: NEG
18347: PUSH
18348: LD_INT 0
18350: PUSH
18351: EMPTY
18352: LIST
18353: LIST
18354: PUSH
18355: LD_INT 2
18357: NEG
18358: PUSH
18359: LD_INT 1
18361: NEG
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: PUSH
18367: LD_INT 2
18369: NEG
18370: PUSH
18371: LD_INT 1
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: PUSH
18378: LD_INT 3
18380: NEG
18381: PUSH
18382: LD_INT 0
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: PUSH
18389: LD_INT 3
18391: NEG
18392: PUSH
18393: LD_INT 1
18395: NEG
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
18419: LD_ADDR_VAR 0 13
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: LD_INT 0
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: PUSH
18434: LD_INT 0
18436: PUSH
18437: LD_INT 1
18439: NEG
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PUSH
18445: LD_INT 1
18447: PUSH
18448: LD_INT 0
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: PUSH
18455: LD_INT 1
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PUSH
18465: LD_INT 0
18467: PUSH
18468: LD_INT 1
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: PUSH
18475: LD_INT 1
18477: NEG
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: EMPTY
18483: LIST
18484: LIST
18485: PUSH
18486: LD_INT 1
18488: NEG
18489: PUSH
18490: LD_INT 1
18492: NEG
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PUSH
18498: LD_INT 1
18500: NEG
18501: PUSH
18502: LD_INT 2
18504: NEG
18505: PUSH
18506: EMPTY
18507: LIST
18508: LIST
18509: PUSH
18510: LD_INT 2
18512: PUSH
18513: LD_INT 1
18515: PUSH
18516: EMPTY
18517: LIST
18518: LIST
18519: PUSH
18520: LD_INT 2
18522: PUSH
18523: LD_INT 2
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 1
18532: PUSH
18533: LD_INT 2
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: PUSH
18540: LD_INT 2
18542: NEG
18543: PUSH
18544: LD_INT 1
18546: NEG
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: PUSH
18552: LD_INT 2
18554: NEG
18555: PUSH
18556: LD_INT 2
18558: NEG
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: LD_INT 2
18566: NEG
18567: PUSH
18568: LD_INT 3
18570: NEG
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: PUSH
18576: LD_INT 3
18578: NEG
18579: PUSH
18580: LD_INT 2
18582: NEG
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: LD_INT 3
18590: NEG
18591: PUSH
18592: LD_INT 3
18594: NEG
18595: PUSH
18596: EMPTY
18597: LIST
18598: LIST
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
18618: LD_ADDR_VAR 0 14
18622: PUSH
18623: LD_INT 0
18625: PUSH
18626: LD_INT 0
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 0
18635: PUSH
18636: LD_INT 1
18638: NEG
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: PUSH
18644: LD_INT 1
18646: PUSH
18647: LD_INT 0
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: PUSH
18654: LD_INT 1
18656: PUSH
18657: LD_INT 1
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: PUSH
18664: LD_INT 0
18666: PUSH
18667: LD_INT 1
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: PUSH
18674: LD_INT 1
18676: NEG
18677: PUSH
18678: LD_INT 0
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PUSH
18685: LD_INT 1
18687: NEG
18688: PUSH
18689: LD_INT 1
18691: NEG
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PUSH
18697: LD_INT 1
18699: NEG
18700: PUSH
18701: LD_INT 2
18703: NEG
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 2
18714: NEG
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: PUSH
18720: LD_INT 1
18722: PUSH
18723: LD_INT 1
18725: NEG
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PUSH
18731: LD_INT 1
18733: PUSH
18734: LD_INT 2
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: PUSH
18741: LD_INT 0
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PUSH
18751: LD_INT 1
18753: NEG
18754: PUSH
18755: LD_INT 1
18757: PUSH
18758: EMPTY
18759: LIST
18760: LIST
18761: PUSH
18762: LD_INT 1
18764: NEG
18765: PUSH
18766: LD_INT 3
18768: NEG
18769: PUSH
18770: EMPTY
18771: LIST
18772: LIST
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: LD_INT 3
18779: NEG
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: LD_INT 1
18787: PUSH
18788: LD_INT 2
18790: NEG
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: PUSH
18796: EMPTY
18797: LIST
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
18814: LD_ADDR_VAR 0 15
18818: PUSH
18819: LD_INT 0
18821: PUSH
18822: LD_INT 0
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: PUSH
18829: LD_INT 0
18831: PUSH
18832: LD_INT 1
18834: NEG
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: PUSH
18840: LD_INT 1
18842: PUSH
18843: LD_INT 0
18845: PUSH
18846: EMPTY
18847: LIST
18848: LIST
18849: PUSH
18850: LD_INT 1
18852: PUSH
18853: LD_INT 1
18855: PUSH
18856: EMPTY
18857: LIST
18858: LIST
18859: PUSH
18860: LD_INT 0
18862: PUSH
18863: LD_INT 1
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: PUSH
18870: LD_INT 1
18872: NEG
18873: PUSH
18874: LD_INT 0
18876: PUSH
18877: EMPTY
18878: LIST
18879: LIST
18880: PUSH
18881: LD_INT 1
18883: NEG
18884: PUSH
18885: LD_INT 1
18887: NEG
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: PUSH
18893: LD_INT 1
18895: PUSH
18896: LD_INT 1
18898: NEG
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 2
18906: PUSH
18907: LD_INT 0
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: LD_INT 2
18916: PUSH
18917: LD_INT 1
18919: PUSH
18920: EMPTY
18921: LIST
18922: LIST
18923: PUSH
18924: LD_INT 1
18926: NEG
18927: PUSH
18928: LD_INT 1
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: PUSH
18935: LD_INT 2
18937: NEG
18938: PUSH
18939: LD_INT 0
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 2
18948: NEG
18949: PUSH
18950: LD_INT 1
18952: NEG
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PUSH
18958: LD_INT 2
18960: PUSH
18961: LD_INT 1
18963: NEG
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: PUSH
18969: LD_INT 3
18971: PUSH
18972: LD_INT 0
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 3
18981: PUSH
18982: LD_INT 1
18984: PUSH
18985: EMPTY
18986: LIST
18987: LIST
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: LIST
18993: LIST
18994: LIST
18995: LIST
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: LIST
19004: LIST
19005: LIST
19006: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
19007: LD_ADDR_VAR 0 16
19011: PUSH
19012: LD_INT 0
19014: PUSH
19015: LD_INT 0
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: PUSH
19022: LD_INT 0
19024: PUSH
19025: LD_INT 1
19027: NEG
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: PUSH
19033: LD_INT 1
19035: PUSH
19036: LD_INT 0
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: PUSH
19043: LD_INT 1
19045: PUSH
19046: LD_INT 1
19048: PUSH
19049: EMPTY
19050: LIST
19051: LIST
19052: PUSH
19053: LD_INT 0
19055: PUSH
19056: LD_INT 1
19058: PUSH
19059: EMPTY
19060: LIST
19061: LIST
19062: PUSH
19063: LD_INT 1
19065: NEG
19066: PUSH
19067: LD_INT 0
19069: PUSH
19070: EMPTY
19071: LIST
19072: LIST
19073: PUSH
19074: LD_INT 1
19076: NEG
19077: PUSH
19078: LD_INT 1
19080: NEG
19081: PUSH
19082: EMPTY
19083: LIST
19084: LIST
19085: PUSH
19086: LD_INT 1
19088: NEG
19089: PUSH
19090: LD_INT 2
19092: NEG
19093: PUSH
19094: EMPTY
19095: LIST
19096: LIST
19097: PUSH
19098: LD_INT 2
19100: PUSH
19101: LD_INT 1
19103: PUSH
19104: EMPTY
19105: LIST
19106: LIST
19107: PUSH
19108: LD_INT 2
19110: PUSH
19111: LD_INT 2
19113: PUSH
19114: EMPTY
19115: LIST
19116: LIST
19117: PUSH
19118: LD_INT 1
19120: PUSH
19121: LD_INT 2
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: PUSH
19128: LD_INT 2
19130: NEG
19131: PUSH
19132: LD_INT 1
19134: NEG
19135: PUSH
19136: EMPTY
19137: LIST
19138: LIST
19139: PUSH
19140: LD_INT 2
19142: NEG
19143: PUSH
19144: LD_INT 2
19146: NEG
19147: PUSH
19148: EMPTY
19149: LIST
19150: LIST
19151: PUSH
19152: LD_INT 3
19154: PUSH
19155: LD_INT 2
19157: PUSH
19158: EMPTY
19159: LIST
19160: LIST
19161: PUSH
19162: LD_INT 3
19164: PUSH
19165: LD_INT 3
19167: PUSH
19168: EMPTY
19169: LIST
19170: LIST
19171: PUSH
19172: LD_INT 2
19174: PUSH
19175: LD_INT 3
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PUSH
19182: EMPTY
19183: LIST
19184: LIST
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: LIST
19195: LIST
19196: LIST
19197: LIST
19198: LIST
19199: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19200: LD_ADDR_VAR 0 17
19204: PUSH
19205: LD_INT 0
19207: PUSH
19208: LD_INT 0
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PUSH
19215: LD_INT 0
19217: PUSH
19218: LD_INT 1
19220: NEG
19221: PUSH
19222: EMPTY
19223: LIST
19224: LIST
19225: PUSH
19226: LD_INT 1
19228: PUSH
19229: LD_INT 0
19231: PUSH
19232: EMPTY
19233: LIST
19234: LIST
19235: PUSH
19236: LD_INT 1
19238: PUSH
19239: LD_INT 1
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: PUSH
19246: LD_INT 0
19248: PUSH
19249: LD_INT 1
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: PUSH
19256: LD_INT 1
19258: NEG
19259: PUSH
19260: LD_INT 0
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: PUSH
19267: LD_INT 1
19269: NEG
19270: PUSH
19271: LD_INT 1
19273: NEG
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 1
19281: NEG
19282: PUSH
19283: LD_INT 2
19285: NEG
19286: PUSH
19287: EMPTY
19288: LIST
19289: LIST
19290: PUSH
19291: LD_INT 0
19293: PUSH
19294: LD_INT 2
19296: NEG
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: LD_INT 1
19304: PUSH
19305: LD_INT 1
19307: NEG
19308: PUSH
19309: EMPTY
19310: LIST
19311: LIST
19312: PUSH
19313: LD_INT 2
19315: PUSH
19316: LD_INT 0
19318: PUSH
19319: EMPTY
19320: LIST
19321: LIST
19322: PUSH
19323: LD_INT 2
19325: PUSH
19326: LD_INT 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 2
19335: PUSH
19336: LD_INT 2
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 1
19345: PUSH
19346: LD_INT 2
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 0
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: EMPTY
19360: LIST
19361: LIST
19362: PUSH
19363: LD_INT 1
19365: NEG
19366: PUSH
19367: LD_INT 1
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: PUSH
19374: LD_INT 2
19376: NEG
19377: PUSH
19378: LD_INT 0
19380: PUSH
19381: EMPTY
19382: LIST
19383: LIST
19384: PUSH
19385: LD_INT 2
19387: NEG
19388: PUSH
19389: LD_INT 1
19391: NEG
19392: PUSH
19393: EMPTY
19394: LIST
19395: LIST
19396: PUSH
19397: LD_INT 2
19399: NEG
19400: PUSH
19401: LD_INT 2
19403: NEG
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: PUSH
19409: EMPTY
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19430: LD_ADDR_VAR 0 18
19434: PUSH
19435: LD_INT 0
19437: PUSH
19438: LD_INT 0
19440: PUSH
19441: EMPTY
19442: LIST
19443: LIST
19444: PUSH
19445: LD_INT 0
19447: PUSH
19448: LD_INT 1
19450: NEG
19451: PUSH
19452: EMPTY
19453: LIST
19454: LIST
19455: PUSH
19456: LD_INT 1
19458: PUSH
19459: LD_INT 0
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PUSH
19466: LD_INT 1
19468: PUSH
19469: LD_INT 1
19471: PUSH
19472: EMPTY
19473: LIST
19474: LIST
19475: PUSH
19476: LD_INT 0
19478: PUSH
19479: LD_INT 1
19481: PUSH
19482: EMPTY
19483: LIST
19484: LIST
19485: PUSH
19486: LD_INT 1
19488: NEG
19489: PUSH
19490: LD_INT 0
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: PUSH
19497: LD_INT 1
19499: NEG
19500: PUSH
19501: LD_INT 1
19503: NEG
19504: PUSH
19505: EMPTY
19506: LIST
19507: LIST
19508: PUSH
19509: LD_INT 1
19511: NEG
19512: PUSH
19513: LD_INT 2
19515: NEG
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: PUSH
19521: LD_INT 0
19523: PUSH
19524: LD_INT 2
19526: NEG
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: PUSH
19532: LD_INT 1
19534: PUSH
19535: LD_INT 1
19537: NEG
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: LD_INT 2
19545: PUSH
19546: LD_INT 0
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: PUSH
19553: LD_INT 2
19555: PUSH
19556: LD_INT 1
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PUSH
19563: LD_INT 2
19565: PUSH
19566: LD_INT 2
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: PUSH
19573: LD_INT 1
19575: PUSH
19576: LD_INT 2
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: PUSH
19583: LD_INT 0
19585: PUSH
19586: LD_INT 2
19588: PUSH
19589: EMPTY
19590: LIST
19591: LIST
19592: PUSH
19593: LD_INT 1
19595: NEG
19596: PUSH
19597: LD_INT 1
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: PUSH
19604: LD_INT 2
19606: NEG
19607: PUSH
19608: LD_INT 0
19610: PUSH
19611: EMPTY
19612: LIST
19613: LIST
19614: PUSH
19615: LD_INT 2
19617: NEG
19618: PUSH
19619: LD_INT 1
19621: NEG
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: PUSH
19627: LD_INT 2
19629: NEG
19630: PUSH
19631: LD_INT 2
19633: NEG
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: PUSH
19639: EMPTY
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19660: LD_ADDR_VAR 0 19
19664: PUSH
19665: LD_INT 0
19667: PUSH
19668: LD_INT 0
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: PUSH
19675: LD_INT 0
19677: PUSH
19678: LD_INT 1
19680: NEG
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 1
19688: PUSH
19689: LD_INT 0
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: LD_INT 1
19698: PUSH
19699: LD_INT 1
19701: PUSH
19702: EMPTY
19703: LIST
19704: LIST
19705: PUSH
19706: LD_INT 0
19708: PUSH
19709: LD_INT 1
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: PUSH
19716: LD_INT 1
19718: NEG
19719: PUSH
19720: LD_INT 0
19722: PUSH
19723: EMPTY
19724: LIST
19725: LIST
19726: PUSH
19727: LD_INT 1
19729: NEG
19730: PUSH
19731: LD_INT 1
19733: NEG
19734: PUSH
19735: EMPTY
19736: LIST
19737: LIST
19738: PUSH
19739: LD_INT 1
19741: NEG
19742: PUSH
19743: LD_INT 2
19745: NEG
19746: PUSH
19747: EMPTY
19748: LIST
19749: LIST
19750: PUSH
19751: LD_INT 0
19753: PUSH
19754: LD_INT 2
19756: NEG
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: PUSH
19762: LD_INT 1
19764: PUSH
19765: LD_INT 1
19767: NEG
19768: PUSH
19769: EMPTY
19770: LIST
19771: LIST
19772: PUSH
19773: LD_INT 2
19775: PUSH
19776: LD_INT 0
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: PUSH
19783: LD_INT 2
19785: PUSH
19786: LD_INT 1
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: PUSH
19793: LD_INT 2
19795: PUSH
19796: LD_INT 2
19798: PUSH
19799: EMPTY
19800: LIST
19801: LIST
19802: PUSH
19803: LD_INT 1
19805: PUSH
19806: LD_INT 2
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: PUSH
19813: LD_INT 0
19815: PUSH
19816: LD_INT 2
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: PUSH
19823: LD_INT 1
19825: NEG
19826: PUSH
19827: LD_INT 1
19829: PUSH
19830: EMPTY
19831: LIST
19832: LIST
19833: PUSH
19834: LD_INT 2
19836: NEG
19837: PUSH
19838: LD_INT 0
19840: PUSH
19841: EMPTY
19842: LIST
19843: LIST
19844: PUSH
19845: LD_INT 2
19847: NEG
19848: PUSH
19849: LD_INT 1
19851: NEG
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: PUSH
19857: LD_INT 2
19859: NEG
19860: PUSH
19861: LD_INT 2
19863: NEG
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: LIST
19888: LIST
19889: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19890: LD_ADDR_VAR 0 20
19894: PUSH
19895: LD_INT 0
19897: PUSH
19898: LD_INT 0
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PUSH
19905: LD_INT 0
19907: PUSH
19908: LD_INT 1
19910: NEG
19911: PUSH
19912: EMPTY
19913: LIST
19914: LIST
19915: PUSH
19916: LD_INT 1
19918: PUSH
19919: LD_INT 0
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: LD_INT 1
19928: PUSH
19929: LD_INT 1
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: PUSH
19936: LD_INT 0
19938: PUSH
19939: LD_INT 1
19941: PUSH
19942: EMPTY
19943: LIST
19944: LIST
19945: PUSH
19946: LD_INT 1
19948: NEG
19949: PUSH
19950: LD_INT 0
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: LD_INT 1
19959: NEG
19960: PUSH
19961: LD_INT 1
19963: NEG
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: PUSH
19969: LD_INT 1
19971: NEG
19972: PUSH
19973: LD_INT 2
19975: NEG
19976: PUSH
19977: EMPTY
19978: LIST
19979: LIST
19980: PUSH
19981: LD_INT 0
19983: PUSH
19984: LD_INT 2
19986: NEG
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: PUSH
19992: LD_INT 1
19994: PUSH
19995: LD_INT 1
19997: NEG
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PUSH
20003: LD_INT 2
20005: PUSH
20006: LD_INT 0
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 2
20015: PUSH
20016: LD_INT 1
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: PUSH
20023: LD_INT 2
20025: PUSH
20026: LD_INT 2
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: PUSH
20033: LD_INT 1
20035: PUSH
20036: LD_INT 2
20038: PUSH
20039: EMPTY
20040: LIST
20041: LIST
20042: PUSH
20043: LD_INT 0
20045: PUSH
20046: LD_INT 2
20048: PUSH
20049: EMPTY
20050: LIST
20051: LIST
20052: PUSH
20053: LD_INT 1
20055: NEG
20056: PUSH
20057: LD_INT 1
20059: PUSH
20060: EMPTY
20061: LIST
20062: LIST
20063: PUSH
20064: LD_INT 2
20066: NEG
20067: PUSH
20068: LD_INT 0
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: PUSH
20075: LD_INT 2
20077: NEG
20078: PUSH
20079: LD_INT 1
20081: NEG
20082: PUSH
20083: EMPTY
20084: LIST
20085: LIST
20086: PUSH
20087: LD_INT 2
20089: NEG
20090: PUSH
20091: LD_INT 2
20093: NEG
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: PUSH
20099: EMPTY
20100: LIST
20101: LIST
20102: LIST
20103: LIST
20104: LIST
20105: LIST
20106: LIST
20107: LIST
20108: LIST
20109: LIST
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: LIST
20115: LIST
20116: LIST
20117: LIST
20118: LIST
20119: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20120: LD_ADDR_VAR 0 21
20124: PUSH
20125: LD_INT 0
20127: PUSH
20128: LD_INT 0
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: PUSH
20135: LD_INT 0
20137: PUSH
20138: LD_INT 1
20140: NEG
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: PUSH
20146: LD_INT 1
20148: PUSH
20149: LD_INT 0
20151: PUSH
20152: EMPTY
20153: LIST
20154: LIST
20155: PUSH
20156: LD_INT 1
20158: PUSH
20159: LD_INT 1
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: PUSH
20166: LD_INT 0
20168: PUSH
20169: LD_INT 1
20171: PUSH
20172: EMPTY
20173: LIST
20174: LIST
20175: PUSH
20176: LD_INT 1
20178: NEG
20179: PUSH
20180: LD_INT 0
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: PUSH
20187: LD_INT 1
20189: NEG
20190: PUSH
20191: LD_INT 1
20193: NEG
20194: PUSH
20195: EMPTY
20196: LIST
20197: LIST
20198: PUSH
20199: LD_INT 1
20201: NEG
20202: PUSH
20203: LD_INT 2
20205: NEG
20206: PUSH
20207: EMPTY
20208: LIST
20209: LIST
20210: PUSH
20211: LD_INT 0
20213: PUSH
20214: LD_INT 2
20216: NEG
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PUSH
20222: LD_INT 1
20224: PUSH
20225: LD_INT 1
20227: NEG
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: PUSH
20233: LD_INT 2
20235: PUSH
20236: LD_INT 0
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: LD_INT 2
20245: PUSH
20246: LD_INT 1
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: LD_INT 2
20255: PUSH
20256: LD_INT 2
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: PUSH
20263: LD_INT 1
20265: PUSH
20266: LD_INT 2
20268: PUSH
20269: EMPTY
20270: LIST
20271: LIST
20272: PUSH
20273: LD_INT 0
20275: PUSH
20276: LD_INT 2
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: PUSH
20283: LD_INT 1
20285: NEG
20286: PUSH
20287: LD_INT 1
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: PUSH
20294: LD_INT 2
20296: NEG
20297: PUSH
20298: LD_INT 0
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: PUSH
20305: LD_INT 2
20307: NEG
20308: PUSH
20309: LD_INT 1
20311: NEG
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: PUSH
20317: LD_INT 2
20319: NEG
20320: PUSH
20321: LD_INT 2
20323: NEG
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: PUSH
20329: EMPTY
20330: LIST
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: LIST
20349: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20350: LD_ADDR_VAR 0 22
20354: PUSH
20355: LD_INT 0
20357: PUSH
20358: LD_INT 0
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: PUSH
20365: LD_INT 0
20367: PUSH
20368: LD_INT 1
20370: NEG
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PUSH
20376: LD_INT 1
20378: PUSH
20379: LD_INT 0
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: PUSH
20386: LD_INT 1
20388: PUSH
20389: LD_INT 1
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: LD_INT 0
20398: PUSH
20399: LD_INT 1
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: PUSH
20406: LD_INT 1
20408: NEG
20409: PUSH
20410: LD_INT 0
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: LD_INT 1
20419: NEG
20420: PUSH
20421: LD_INT 1
20423: NEG
20424: PUSH
20425: EMPTY
20426: LIST
20427: LIST
20428: PUSH
20429: LD_INT 1
20431: NEG
20432: PUSH
20433: LD_INT 2
20435: NEG
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 0
20443: PUSH
20444: LD_INT 2
20446: NEG
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: PUSH
20452: LD_INT 1
20454: PUSH
20455: LD_INT 1
20457: NEG
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: LD_INT 2
20465: PUSH
20466: LD_INT 0
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: PUSH
20473: LD_INT 2
20475: PUSH
20476: LD_INT 1
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: PUSH
20483: LD_INT 2
20485: PUSH
20486: LD_INT 2
20488: PUSH
20489: EMPTY
20490: LIST
20491: LIST
20492: PUSH
20493: LD_INT 1
20495: PUSH
20496: LD_INT 2
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: LD_INT 0
20505: PUSH
20506: LD_INT 2
20508: PUSH
20509: EMPTY
20510: LIST
20511: LIST
20512: PUSH
20513: LD_INT 1
20515: NEG
20516: PUSH
20517: LD_INT 1
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: PUSH
20524: LD_INT 2
20526: NEG
20527: PUSH
20528: LD_INT 0
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 2
20537: NEG
20538: PUSH
20539: LD_INT 1
20541: NEG
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 2
20549: NEG
20550: PUSH
20551: LD_INT 2
20553: NEG
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
20580: LD_ADDR_VAR 0 23
20584: PUSH
20585: LD_INT 0
20587: PUSH
20588: LD_INT 0
20590: PUSH
20591: EMPTY
20592: LIST
20593: LIST
20594: PUSH
20595: LD_INT 0
20597: PUSH
20598: LD_INT 1
20600: NEG
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: LD_INT 1
20608: PUSH
20609: LD_INT 0
20611: PUSH
20612: EMPTY
20613: LIST
20614: LIST
20615: PUSH
20616: LD_INT 1
20618: PUSH
20619: LD_INT 1
20621: PUSH
20622: EMPTY
20623: LIST
20624: LIST
20625: PUSH
20626: LD_INT 0
20628: PUSH
20629: LD_INT 1
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: PUSH
20636: LD_INT 1
20638: NEG
20639: PUSH
20640: LD_INT 0
20642: PUSH
20643: EMPTY
20644: LIST
20645: LIST
20646: PUSH
20647: LD_INT 1
20649: NEG
20650: PUSH
20651: LD_INT 1
20653: NEG
20654: PUSH
20655: EMPTY
20656: LIST
20657: LIST
20658: PUSH
20659: LD_INT 1
20661: NEG
20662: PUSH
20663: LD_INT 2
20665: NEG
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: PUSH
20671: LD_INT 0
20673: PUSH
20674: LD_INT 2
20676: NEG
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: PUSH
20682: LD_INT 1
20684: PUSH
20685: LD_INT 1
20687: NEG
20688: PUSH
20689: EMPTY
20690: LIST
20691: LIST
20692: PUSH
20693: LD_INT 2
20695: PUSH
20696: LD_INT 0
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: PUSH
20703: LD_INT 2
20705: PUSH
20706: LD_INT 1
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PUSH
20713: LD_INT 2
20715: PUSH
20716: LD_INT 2
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: PUSH
20723: LD_INT 1
20725: PUSH
20726: LD_INT 2
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: PUSH
20733: LD_INT 0
20735: PUSH
20736: LD_INT 2
20738: PUSH
20739: EMPTY
20740: LIST
20741: LIST
20742: PUSH
20743: LD_INT 1
20745: NEG
20746: PUSH
20747: LD_INT 1
20749: PUSH
20750: EMPTY
20751: LIST
20752: LIST
20753: PUSH
20754: LD_INT 2
20756: NEG
20757: PUSH
20758: LD_INT 0
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: PUSH
20765: LD_INT 2
20767: NEG
20768: PUSH
20769: LD_INT 1
20771: NEG
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: PUSH
20777: LD_INT 2
20779: NEG
20780: PUSH
20781: LD_INT 2
20783: NEG
20784: PUSH
20785: EMPTY
20786: LIST
20787: LIST
20788: PUSH
20789: LD_INT 2
20791: NEG
20792: PUSH
20793: LD_INT 3
20795: NEG
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: PUSH
20801: LD_INT 1
20803: NEG
20804: PUSH
20805: LD_INT 3
20807: NEG
20808: PUSH
20809: EMPTY
20810: LIST
20811: LIST
20812: PUSH
20813: LD_INT 1
20815: PUSH
20816: LD_INT 2
20818: NEG
20819: PUSH
20820: EMPTY
20821: LIST
20822: LIST
20823: PUSH
20824: LD_INT 2
20826: PUSH
20827: LD_INT 1
20829: NEG
20830: PUSH
20831: EMPTY
20832: LIST
20833: LIST
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: LIST
20845: LIST
20846: LIST
20847: LIST
20848: LIST
20849: LIST
20850: LIST
20851: LIST
20852: LIST
20853: LIST
20854: LIST
20855: LIST
20856: LIST
20857: LIST
20858: LIST
20859: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
20860: LD_ADDR_VAR 0 24
20864: PUSH
20865: LD_INT 0
20867: PUSH
20868: LD_INT 0
20870: PUSH
20871: EMPTY
20872: LIST
20873: LIST
20874: PUSH
20875: LD_INT 0
20877: PUSH
20878: LD_INT 1
20880: NEG
20881: PUSH
20882: EMPTY
20883: LIST
20884: LIST
20885: PUSH
20886: LD_INT 1
20888: PUSH
20889: LD_INT 0
20891: PUSH
20892: EMPTY
20893: LIST
20894: LIST
20895: PUSH
20896: LD_INT 1
20898: PUSH
20899: LD_INT 1
20901: PUSH
20902: EMPTY
20903: LIST
20904: LIST
20905: PUSH
20906: LD_INT 0
20908: PUSH
20909: LD_INT 1
20911: PUSH
20912: EMPTY
20913: LIST
20914: LIST
20915: PUSH
20916: LD_INT 1
20918: NEG
20919: PUSH
20920: LD_INT 0
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: PUSH
20927: LD_INT 1
20929: NEG
20930: PUSH
20931: LD_INT 1
20933: NEG
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: PUSH
20939: LD_INT 1
20941: NEG
20942: PUSH
20943: LD_INT 2
20945: NEG
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: PUSH
20951: LD_INT 0
20953: PUSH
20954: LD_INT 2
20956: NEG
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: PUSH
20962: LD_INT 1
20964: PUSH
20965: LD_INT 1
20967: NEG
20968: PUSH
20969: EMPTY
20970: LIST
20971: LIST
20972: PUSH
20973: LD_INT 2
20975: PUSH
20976: LD_INT 0
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: PUSH
20983: LD_INT 2
20985: PUSH
20986: LD_INT 1
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PUSH
20993: LD_INT 2
20995: PUSH
20996: LD_INT 2
20998: PUSH
20999: EMPTY
21000: LIST
21001: LIST
21002: PUSH
21003: LD_INT 1
21005: PUSH
21006: LD_INT 2
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: PUSH
21013: LD_INT 0
21015: PUSH
21016: LD_INT 2
21018: PUSH
21019: EMPTY
21020: LIST
21021: LIST
21022: PUSH
21023: LD_INT 1
21025: NEG
21026: PUSH
21027: LD_INT 1
21029: PUSH
21030: EMPTY
21031: LIST
21032: LIST
21033: PUSH
21034: LD_INT 2
21036: NEG
21037: PUSH
21038: LD_INT 0
21040: PUSH
21041: EMPTY
21042: LIST
21043: LIST
21044: PUSH
21045: LD_INT 2
21047: NEG
21048: PUSH
21049: LD_INT 1
21051: NEG
21052: PUSH
21053: EMPTY
21054: LIST
21055: LIST
21056: PUSH
21057: LD_INT 2
21059: NEG
21060: PUSH
21061: LD_INT 2
21063: NEG
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: LD_INT 1
21071: PUSH
21072: LD_INT 2
21074: NEG
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PUSH
21080: LD_INT 2
21082: PUSH
21083: LD_INT 1
21085: NEG
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: PUSH
21091: LD_INT 3
21093: PUSH
21094: LD_INT 1
21096: PUSH
21097: EMPTY
21098: LIST
21099: LIST
21100: PUSH
21101: LD_INT 3
21103: PUSH
21104: LD_INT 2
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: LIST
21115: LIST
21116: LIST
21117: LIST
21118: LIST
21119: LIST
21120: LIST
21121: LIST
21122: LIST
21123: LIST
21124: LIST
21125: LIST
21126: LIST
21127: LIST
21128: LIST
21129: LIST
21130: LIST
21131: LIST
21132: LIST
21133: LIST
21134: LIST
21135: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
21136: LD_ADDR_VAR 0 25
21140: PUSH
21141: LD_INT 0
21143: PUSH
21144: LD_INT 0
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: PUSH
21151: LD_INT 0
21153: PUSH
21154: LD_INT 1
21156: NEG
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: LD_INT 1
21164: PUSH
21165: LD_INT 0
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: PUSH
21172: LD_INT 1
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PUSH
21182: LD_INT 0
21184: PUSH
21185: LD_INT 1
21187: PUSH
21188: EMPTY
21189: LIST
21190: LIST
21191: PUSH
21192: LD_INT 1
21194: NEG
21195: PUSH
21196: LD_INT 0
21198: PUSH
21199: EMPTY
21200: LIST
21201: LIST
21202: PUSH
21203: LD_INT 1
21205: NEG
21206: PUSH
21207: LD_INT 1
21209: NEG
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PUSH
21215: LD_INT 1
21217: NEG
21218: PUSH
21219: LD_INT 2
21221: NEG
21222: PUSH
21223: EMPTY
21224: LIST
21225: LIST
21226: PUSH
21227: LD_INT 0
21229: PUSH
21230: LD_INT 2
21232: NEG
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: LD_INT 1
21240: PUSH
21241: LD_INT 1
21243: NEG
21244: PUSH
21245: EMPTY
21246: LIST
21247: LIST
21248: PUSH
21249: LD_INT 2
21251: PUSH
21252: LD_INT 0
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: LD_INT 2
21261: PUSH
21262: LD_INT 1
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PUSH
21269: LD_INT 2
21271: PUSH
21272: LD_INT 2
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PUSH
21279: LD_INT 1
21281: PUSH
21282: LD_INT 2
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: PUSH
21289: LD_INT 0
21291: PUSH
21292: LD_INT 2
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PUSH
21299: LD_INT 1
21301: NEG
21302: PUSH
21303: LD_INT 1
21305: PUSH
21306: EMPTY
21307: LIST
21308: LIST
21309: PUSH
21310: LD_INT 2
21312: NEG
21313: PUSH
21314: LD_INT 0
21316: PUSH
21317: EMPTY
21318: LIST
21319: LIST
21320: PUSH
21321: LD_INT 2
21323: NEG
21324: PUSH
21325: LD_INT 1
21327: NEG
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: PUSH
21333: LD_INT 2
21335: NEG
21336: PUSH
21337: LD_INT 2
21339: NEG
21340: PUSH
21341: EMPTY
21342: LIST
21343: LIST
21344: PUSH
21345: LD_INT 3
21347: PUSH
21348: LD_INT 1
21350: PUSH
21351: EMPTY
21352: LIST
21353: LIST
21354: PUSH
21355: LD_INT 3
21357: PUSH
21358: LD_INT 2
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: PUSH
21365: LD_INT 2
21367: PUSH
21368: LD_INT 3
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PUSH
21375: LD_INT 1
21377: PUSH
21378: LD_INT 3
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: PUSH
21385: EMPTY
21386: LIST
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: LIST
21392: LIST
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: LIST
21399: LIST
21400: LIST
21401: LIST
21402: LIST
21403: LIST
21404: LIST
21405: LIST
21406: LIST
21407: LIST
21408: LIST
21409: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
21410: LD_ADDR_VAR 0 26
21414: PUSH
21415: LD_INT 0
21417: PUSH
21418: LD_INT 0
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: PUSH
21425: LD_INT 0
21427: PUSH
21428: LD_INT 1
21430: NEG
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: PUSH
21436: LD_INT 1
21438: PUSH
21439: LD_INT 0
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: PUSH
21446: LD_INT 1
21448: PUSH
21449: LD_INT 1
21451: PUSH
21452: EMPTY
21453: LIST
21454: LIST
21455: PUSH
21456: LD_INT 0
21458: PUSH
21459: LD_INT 1
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: PUSH
21466: LD_INT 1
21468: NEG
21469: PUSH
21470: LD_INT 0
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 1
21479: NEG
21480: PUSH
21481: LD_INT 1
21483: NEG
21484: PUSH
21485: EMPTY
21486: LIST
21487: LIST
21488: PUSH
21489: LD_INT 1
21491: NEG
21492: PUSH
21493: LD_INT 2
21495: NEG
21496: PUSH
21497: EMPTY
21498: LIST
21499: LIST
21500: PUSH
21501: LD_INT 0
21503: PUSH
21504: LD_INT 2
21506: NEG
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PUSH
21512: LD_INT 1
21514: PUSH
21515: LD_INT 1
21517: NEG
21518: PUSH
21519: EMPTY
21520: LIST
21521: LIST
21522: PUSH
21523: LD_INT 2
21525: PUSH
21526: LD_INT 0
21528: PUSH
21529: EMPTY
21530: LIST
21531: LIST
21532: PUSH
21533: LD_INT 2
21535: PUSH
21536: LD_INT 1
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: PUSH
21543: LD_INT 2
21545: PUSH
21546: LD_INT 2
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: PUSH
21553: LD_INT 1
21555: PUSH
21556: LD_INT 2
21558: PUSH
21559: EMPTY
21560: LIST
21561: LIST
21562: PUSH
21563: LD_INT 0
21565: PUSH
21566: LD_INT 2
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: PUSH
21573: LD_INT 1
21575: NEG
21576: PUSH
21577: LD_INT 1
21579: PUSH
21580: EMPTY
21581: LIST
21582: LIST
21583: PUSH
21584: LD_INT 2
21586: NEG
21587: PUSH
21588: LD_INT 0
21590: PUSH
21591: EMPTY
21592: LIST
21593: LIST
21594: PUSH
21595: LD_INT 2
21597: NEG
21598: PUSH
21599: LD_INT 1
21601: NEG
21602: PUSH
21603: EMPTY
21604: LIST
21605: LIST
21606: PUSH
21607: LD_INT 2
21609: NEG
21610: PUSH
21611: LD_INT 2
21613: NEG
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PUSH
21619: LD_INT 2
21621: PUSH
21622: LD_INT 3
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: LD_INT 1
21631: PUSH
21632: LD_INT 3
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 1
21641: NEG
21642: PUSH
21643: LD_INT 2
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: PUSH
21650: LD_INT 2
21652: NEG
21653: PUSH
21654: LD_INT 1
21656: PUSH
21657: EMPTY
21658: LIST
21659: LIST
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: LIST
21671: LIST
21672: LIST
21673: LIST
21674: LIST
21675: LIST
21676: LIST
21677: LIST
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: LIST
21683: LIST
21684: LIST
21685: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
21686: LD_ADDR_VAR 0 27
21690: PUSH
21691: LD_INT 0
21693: PUSH
21694: LD_INT 0
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PUSH
21701: LD_INT 0
21703: PUSH
21704: LD_INT 1
21706: NEG
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: LD_INT 1
21714: PUSH
21715: LD_INT 0
21717: PUSH
21718: EMPTY
21719: LIST
21720: LIST
21721: PUSH
21722: LD_INT 1
21724: PUSH
21725: LD_INT 1
21727: PUSH
21728: EMPTY
21729: LIST
21730: LIST
21731: PUSH
21732: LD_INT 0
21734: PUSH
21735: LD_INT 1
21737: PUSH
21738: EMPTY
21739: LIST
21740: LIST
21741: PUSH
21742: LD_INT 1
21744: NEG
21745: PUSH
21746: LD_INT 0
21748: PUSH
21749: EMPTY
21750: LIST
21751: LIST
21752: PUSH
21753: LD_INT 1
21755: NEG
21756: PUSH
21757: LD_INT 1
21759: NEG
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PUSH
21765: LD_INT 1
21767: NEG
21768: PUSH
21769: LD_INT 2
21771: NEG
21772: PUSH
21773: EMPTY
21774: LIST
21775: LIST
21776: PUSH
21777: LD_INT 0
21779: PUSH
21780: LD_INT 2
21782: NEG
21783: PUSH
21784: EMPTY
21785: LIST
21786: LIST
21787: PUSH
21788: LD_INT 1
21790: PUSH
21791: LD_INT 1
21793: NEG
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 2
21801: PUSH
21802: LD_INT 0
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 2
21811: PUSH
21812: LD_INT 1
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PUSH
21819: LD_INT 2
21821: PUSH
21822: LD_INT 2
21824: PUSH
21825: EMPTY
21826: LIST
21827: LIST
21828: PUSH
21829: LD_INT 1
21831: PUSH
21832: LD_INT 2
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: PUSH
21839: LD_INT 0
21841: PUSH
21842: LD_INT 2
21844: PUSH
21845: EMPTY
21846: LIST
21847: LIST
21848: PUSH
21849: LD_INT 1
21851: NEG
21852: PUSH
21853: LD_INT 1
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 2
21862: NEG
21863: PUSH
21864: LD_INT 0
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: LD_INT 2
21873: NEG
21874: PUSH
21875: LD_INT 1
21877: NEG
21878: PUSH
21879: EMPTY
21880: LIST
21881: LIST
21882: PUSH
21883: LD_INT 2
21885: NEG
21886: PUSH
21887: LD_INT 2
21889: NEG
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: PUSH
21895: LD_INT 1
21897: NEG
21898: PUSH
21899: LD_INT 2
21901: PUSH
21902: EMPTY
21903: LIST
21904: LIST
21905: PUSH
21906: LD_INT 2
21908: NEG
21909: PUSH
21910: LD_INT 1
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: PUSH
21917: LD_INT 3
21919: NEG
21920: PUSH
21921: LD_INT 1
21923: NEG
21924: PUSH
21925: EMPTY
21926: LIST
21927: LIST
21928: PUSH
21929: LD_INT 3
21931: NEG
21932: PUSH
21933: LD_INT 2
21935: NEG
21936: PUSH
21937: EMPTY
21938: LIST
21939: LIST
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: LIST
21953: LIST
21954: LIST
21955: LIST
21956: LIST
21957: LIST
21958: LIST
21959: LIST
21960: LIST
21961: LIST
21962: LIST
21963: LIST
21964: LIST
21965: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
21966: LD_ADDR_VAR 0 28
21970: PUSH
21971: LD_INT 0
21973: PUSH
21974: LD_INT 0
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PUSH
21981: LD_INT 0
21983: PUSH
21984: LD_INT 1
21986: NEG
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: PUSH
21992: LD_INT 1
21994: PUSH
21995: LD_INT 0
21997: PUSH
21998: EMPTY
21999: LIST
22000: LIST
22001: PUSH
22002: LD_INT 1
22004: PUSH
22005: LD_INT 1
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PUSH
22012: LD_INT 0
22014: PUSH
22015: LD_INT 1
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: PUSH
22022: LD_INT 1
22024: NEG
22025: PUSH
22026: LD_INT 0
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: PUSH
22033: LD_INT 1
22035: NEG
22036: PUSH
22037: LD_INT 1
22039: NEG
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: LD_INT 1
22047: NEG
22048: PUSH
22049: LD_INT 2
22051: NEG
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PUSH
22057: LD_INT 0
22059: PUSH
22060: LD_INT 2
22062: NEG
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PUSH
22068: LD_INT 1
22070: PUSH
22071: LD_INT 1
22073: NEG
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 2
22081: PUSH
22082: LD_INT 0
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PUSH
22089: LD_INT 2
22091: PUSH
22092: LD_INT 1
22094: PUSH
22095: EMPTY
22096: LIST
22097: LIST
22098: PUSH
22099: LD_INT 2
22101: PUSH
22102: LD_INT 2
22104: PUSH
22105: EMPTY
22106: LIST
22107: LIST
22108: PUSH
22109: LD_INT 1
22111: PUSH
22112: LD_INT 2
22114: PUSH
22115: EMPTY
22116: LIST
22117: LIST
22118: PUSH
22119: LD_INT 0
22121: PUSH
22122: LD_INT 2
22124: PUSH
22125: EMPTY
22126: LIST
22127: LIST
22128: PUSH
22129: LD_INT 1
22131: NEG
22132: PUSH
22133: LD_INT 1
22135: PUSH
22136: EMPTY
22137: LIST
22138: LIST
22139: PUSH
22140: LD_INT 2
22142: NEG
22143: PUSH
22144: LD_INT 0
22146: PUSH
22147: EMPTY
22148: LIST
22149: LIST
22150: PUSH
22151: LD_INT 2
22153: NEG
22154: PUSH
22155: LD_INT 1
22157: NEG
22158: PUSH
22159: EMPTY
22160: LIST
22161: LIST
22162: PUSH
22163: LD_INT 2
22165: NEG
22166: PUSH
22167: LD_INT 2
22169: NEG
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: LD_INT 2
22177: NEG
22178: PUSH
22179: LD_INT 3
22181: NEG
22182: PUSH
22183: EMPTY
22184: LIST
22185: LIST
22186: PUSH
22187: LD_INT 1
22189: NEG
22190: PUSH
22191: LD_INT 3
22193: NEG
22194: PUSH
22195: EMPTY
22196: LIST
22197: LIST
22198: PUSH
22199: LD_INT 3
22201: NEG
22202: PUSH
22203: LD_INT 1
22205: NEG
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PUSH
22211: LD_INT 3
22213: NEG
22214: PUSH
22215: LD_INT 2
22217: NEG
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: LIST
22227: LIST
22228: LIST
22229: LIST
22230: LIST
22231: LIST
22232: LIST
22233: LIST
22234: LIST
22235: LIST
22236: LIST
22237: LIST
22238: LIST
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22248: LD_ADDR_VAR 0 29
22252: PUSH
22253: LD_INT 0
22255: PUSH
22256: LD_INT 0
22258: PUSH
22259: EMPTY
22260: LIST
22261: LIST
22262: PUSH
22263: LD_INT 0
22265: PUSH
22266: LD_INT 1
22268: NEG
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: PUSH
22274: LD_INT 1
22276: PUSH
22277: LD_INT 0
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: PUSH
22284: LD_INT 1
22286: PUSH
22287: LD_INT 1
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: LD_INT 0
22296: PUSH
22297: LD_INT 1
22299: PUSH
22300: EMPTY
22301: LIST
22302: LIST
22303: PUSH
22304: LD_INT 1
22306: NEG
22307: PUSH
22308: LD_INT 0
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: PUSH
22315: LD_INT 1
22317: NEG
22318: PUSH
22319: LD_INT 1
22321: NEG
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 1
22329: NEG
22330: PUSH
22331: LD_INT 2
22333: NEG
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: PUSH
22339: LD_INT 0
22341: PUSH
22342: LD_INT 2
22344: NEG
22345: PUSH
22346: EMPTY
22347: LIST
22348: LIST
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: NEG
22356: PUSH
22357: EMPTY
22358: LIST
22359: LIST
22360: PUSH
22361: LD_INT 2
22363: PUSH
22364: LD_INT 0
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: PUSH
22371: LD_INT 2
22373: PUSH
22374: LD_INT 1
22376: PUSH
22377: EMPTY
22378: LIST
22379: LIST
22380: PUSH
22381: LD_INT 1
22383: PUSH
22384: LD_INT 2
22386: PUSH
22387: EMPTY
22388: LIST
22389: LIST
22390: PUSH
22391: LD_INT 0
22393: PUSH
22394: LD_INT 2
22396: PUSH
22397: EMPTY
22398: LIST
22399: LIST
22400: PUSH
22401: LD_INT 1
22403: NEG
22404: PUSH
22405: LD_INT 1
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PUSH
22412: LD_INT 2
22414: NEG
22415: PUSH
22416: LD_INT 1
22418: NEG
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: LD_INT 2
22426: NEG
22427: PUSH
22428: LD_INT 2
22430: NEG
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: PUSH
22436: LD_INT 2
22438: NEG
22439: PUSH
22440: LD_INT 3
22442: NEG
22443: PUSH
22444: EMPTY
22445: LIST
22446: LIST
22447: PUSH
22448: LD_INT 2
22450: PUSH
22451: LD_INT 1
22453: NEG
22454: PUSH
22455: EMPTY
22456: LIST
22457: LIST
22458: PUSH
22459: LD_INT 3
22461: PUSH
22462: LD_INT 1
22464: PUSH
22465: EMPTY
22466: LIST
22467: LIST
22468: PUSH
22469: LD_INT 1
22471: PUSH
22472: LD_INT 3
22474: PUSH
22475: EMPTY
22476: LIST
22477: LIST
22478: PUSH
22479: LD_INT 1
22481: NEG
22482: PUSH
22483: LD_INT 2
22485: PUSH
22486: EMPTY
22487: LIST
22488: LIST
22489: PUSH
22490: LD_INT 3
22492: NEG
22493: PUSH
22494: LD_INT 2
22496: NEG
22497: PUSH
22498: EMPTY
22499: LIST
22500: LIST
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: LIST
22506: LIST
22507: LIST
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: LIST
22515: LIST
22516: LIST
22517: LIST
22518: LIST
22519: LIST
22520: LIST
22521: LIST
22522: LIST
22523: LIST
22524: LIST
22525: LIST
22526: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
22527: LD_ADDR_VAR 0 30
22531: PUSH
22532: LD_INT 0
22534: PUSH
22535: LD_INT 0
22537: PUSH
22538: EMPTY
22539: LIST
22540: LIST
22541: PUSH
22542: LD_INT 0
22544: PUSH
22545: LD_INT 1
22547: NEG
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 1
22555: PUSH
22556: LD_INT 0
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 1
22565: PUSH
22566: LD_INT 1
22568: PUSH
22569: EMPTY
22570: LIST
22571: LIST
22572: PUSH
22573: LD_INT 0
22575: PUSH
22576: LD_INT 1
22578: PUSH
22579: EMPTY
22580: LIST
22581: LIST
22582: PUSH
22583: LD_INT 1
22585: NEG
22586: PUSH
22587: LD_INT 0
22589: PUSH
22590: EMPTY
22591: LIST
22592: LIST
22593: PUSH
22594: LD_INT 1
22596: NEG
22597: PUSH
22598: LD_INT 1
22600: NEG
22601: PUSH
22602: EMPTY
22603: LIST
22604: LIST
22605: PUSH
22606: LD_INT 1
22608: NEG
22609: PUSH
22610: LD_INT 2
22612: NEG
22613: PUSH
22614: EMPTY
22615: LIST
22616: LIST
22617: PUSH
22618: LD_INT 0
22620: PUSH
22621: LD_INT 2
22623: NEG
22624: PUSH
22625: EMPTY
22626: LIST
22627: LIST
22628: PUSH
22629: LD_INT 1
22631: PUSH
22632: LD_INT 1
22634: NEG
22635: PUSH
22636: EMPTY
22637: LIST
22638: LIST
22639: PUSH
22640: LD_INT 2
22642: PUSH
22643: LD_INT 0
22645: PUSH
22646: EMPTY
22647: LIST
22648: LIST
22649: PUSH
22650: LD_INT 2
22652: PUSH
22653: LD_INT 1
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: PUSH
22660: LD_INT 2
22662: PUSH
22663: LD_INT 2
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: PUSH
22670: LD_INT 1
22672: PUSH
22673: LD_INT 2
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: PUSH
22680: LD_INT 1
22682: NEG
22683: PUSH
22684: LD_INT 1
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: LD_INT 2
22693: NEG
22694: PUSH
22695: LD_INT 0
22697: PUSH
22698: EMPTY
22699: LIST
22700: LIST
22701: PUSH
22702: LD_INT 2
22704: NEG
22705: PUSH
22706: LD_INT 1
22708: NEG
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: PUSH
22714: LD_INT 1
22716: NEG
22717: PUSH
22718: LD_INT 3
22720: NEG
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: PUSH
22726: LD_INT 1
22728: PUSH
22729: LD_INT 2
22731: NEG
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: PUSH
22737: LD_INT 3
22739: PUSH
22740: LD_INT 2
22742: PUSH
22743: EMPTY
22744: LIST
22745: LIST
22746: PUSH
22747: LD_INT 2
22749: PUSH
22750: LD_INT 3
22752: PUSH
22753: EMPTY
22754: LIST
22755: LIST
22756: PUSH
22757: LD_INT 2
22759: NEG
22760: PUSH
22761: LD_INT 1
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: PUSH
22768: LD_INT 3
22770: NEG
22771: PUSH
22772: LD_INT 1
22774: NEG
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: LIST
22784: LIST
22785: LIST
22786: LIST
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: LIST
22794: LIST
22795: LIST
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: LIST
22801: LIST
22802: LIST
22803: LIST
22804: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22805: LD_ADDR_VAR 0 31
22809: PUSH
22810: LD_INT 0
22812: PUSH
22813: LD_INT 0
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: PUSH
22820: LD_INT 0
22822: PUSH
22823: LD_INT 1
22825: NEG
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: LD_INT 1
22833: PUSH
22834: LD_INT 0
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 1
22843: PUSH
22844: LD_INT 1
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PUSH
22851: LD_INT 0
22853: PUSH
22854: LD_INT 1
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: PUSH
22861: LD_INT 1
22863: NEG
22864: PUSH
22865: LD_INT 0
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: PUSH
22872: LD_INT 1
22874: NEG
22875: PUSH
22876: LD_INT 1
22878: NEG
22879: PUSH
22880: EMPTY
22881: LIST
22882: LIST
22883: PUSH
22884: LD_INT 1
22886: NEG
22887: PUSH
22888: LD_INT 2
22890: NEG
22891: PUSH
22892: EMPTY
22893: LIST
22894: LIST
22895: PUSH
22896: LD_INT 1
22898: PUSH
22899: LD_INT 1
22901: NEG
22902: PUSH
22903: EMPTY
22904: LIST
22905: LIST
22906: PUSH
22907: LD_INT 2
22909: PUSH
22910: LD_INT 0
22912: PUSH
22913: EMPTY
22914: LIST
22915: LIST
22916: PUSH
22917: LD_INT 2
22919: PUSH
22920: LD_INT 1
22922: PUSH
22923: EMPTY
22924: LIST
22925: LIST
22926: PUSH
22927: LD_INT 2
22929: PUSH
22930: LD_INT 2
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: PUSH
22937: LD_INT 1
22939: PUSH
22940: LD_INT 2
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: PUSH
22947: LD_INT 0
22949: PUSH
22950: LD_INT 2
22952: PUSH
22953: EMPTY
22954: LIST
22955: LIST
22956: PUSH
22957: LD_INT 1
22959: NEG
22960: PUSH
22961: LD_INT 1
22963: PUSH
22964: EMPTY
22965: LIST
22966: LIST
22967: PUSH
22968: LD_INT 2
22970: NEG
22971: PUSH
22972: LD_INT 1
22974: NEG
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: PUSH
22980: LD_INT 2
22982: NEG
22983: PUSH
22984: LD_INT 2
22986: NEG
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: PUSH
22992: LD_INT 2
22994: NEG
22995: PUSH
22996: LD_INT 3
22998: NEG
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PUSH
23004: LD_INT 2
23006: PUSH
23007: LD_INT 1
23009: NEG
23010: PUSH
23011: EMPTY
23012: LIST
23013: LIST
23014: PUSH
23015: LD_INT 3
23017: PUSH
23018: LD_INT 1
23020: PUSH
23021: EMPTY
23022: LIST
23023: LIST
23024: PUSH
23025: LD_INT 1
23027: PUSH
23028: LD_INT 3
23030: PUSH
23031: EMPTY
23032: LIST
23033: LIST
23034: PUSH
23035: LD_INT 1
23037: NEG
23038: PUSH
23039: LD_INT 2
23041: PUSH
23042: EMPTY
23043: LIST
23044: LIST
23045: PUSH
23046: LD_INT 3
23048: NEG
23049: PUSH
23050: LD_INT 2
23052: NEG
23053: PUSH
23054: EMPTY
23055: LIST
23056: LIST
23057: PUSH
23058: EMPTY
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: LIST
23065: LIST
23066: LIST
23067: LIST
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: LIST
23073: LIST
23074: LIST
23075: LIST
23076: LIST
23077: LIST
23078: LIST
23079: LIST
23080: LIST
23081: LIST
23082: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23083: LD_ADDR_VAR 0 32
23087: PUSH
23088: LD_INT 0
23090: PUSH
23091: LD_INT 0
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PUSH
23098: LD_INT 0
23100: PUSH
23101: LD_INT 1
23103: NEG
23104: PUSH
23105: EMPTY
23106: LIST
23107: LIST
23108: PUSH
23109: LD_INT 1
23111: PUSH
23112: LD_INT 0
23114: PUSH
23115: EMPTY
23116: LIST
23117: LIST
23118: PUSH
23119: LD_INT 1
23121: PUSH
23122: LD_INT 1
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: LD_INT 0
23131: PUSH
23132: LD_INT 1
23134: PUSH
23135: EMPTY
23136: LIST
23137: LIST
23138: PUSH
23139: LD_INT 1
23141: NEG
23142: PUSH
23143: LD_INT 0
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 1
23152: NEG
23153: PUSH
23154: LD_INT 1
23156: NEG
23157: PUSH
23158: EMPTY
23159: LIST
23160: LIST
23161: PUSH
23162: LD_INT 1
23164: NEG
23165: PUSH
23166: LD_INT 2
23168: NEG
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: PUSH
23174: LD_INT 0
23176: PUSH
23177: LD_INT 2
23179: NEG
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: LD_INT 1
23187: PUSH
23188: LD_INT 1
23190: NEG
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: LD_INT 2
23198: PUSH
23199: LD_INT 1
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: PUSH
23206: LD_INT 2
23208: PUSH
23209: LD_INT 2
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 1
23218: PUSH
23219: LD_INT 2
23221: PUSH
23222: EMPTY
23223: LIST
23224: LIST
23225: PUSH
23226: LD_INT 0
23228: PUSH
23229: LD_INT 2
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: PUSH
23236: LD_INT 1
23238: NEG
23239: PUSH
23240: LD_INT 1
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 2
23249: NEG
23250: PUSH
23251: LD_INT 0
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: LD_INT 2
23260: NEG
23261: PUSH
23262: LD_INT 1
23264: NEG
23265: PUSH
23266: EMPTY
23267: LIST
23268: LIST
23269: PUSH
23270: LD_INT 1
23272: NEG
23273: PUSH
23274: LD_INT 3
23276: NEG
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: PUSH
23282: LD_INT 1
23284: PUSH
23285: LD_INT 2
23287: NEG
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: PUSH
23293: LD_INT 3
23295: PUSH
23296: LD_INT 2
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PUSH
23303: LD_INT 2
23305: PUSH
23306: LD_INT 3
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: PUSH
23313: LD_INT 2
23315: NEG
23316: PUSH
23317: LD_INT 1
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: PUSH
23324: LD_INT 3
23326: NEG
23327: PUSH
23328: LD_INT 1
23330: NEG
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: LIST
23340: LIST
23341: LIST
23342: LIST
23343: LIST
23344: LIST
23345: LIST
23346: LIST
23347: LIST
23348: LIST
23349: LIST
23350: LIST
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: LIST
23356: LIST
23357: LIST
23358: LIST
23359: LIST
23360: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23361: LD_ADDR_VAR 0 33
23365: PUSH
23366: LD_INT 0
23368: PUSH
23369: LD_INT 0
23371: PUSH
23372: EMPTY
23373: LIST
23374: LIST
23375: PUSH
23376: LD_INT 0
23378: PUSH
23379: LD_INT 1
23381: NEG
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: PUSH
23387: LD_INT 1
23389: PUSH
23390: LD_INT 0
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: PUSH
23397: LD_INT 1
23399: PUSH
23400: LD_INT 1
23402: PUSH
23403: EMPTY
23404: LIST
23405: LIST
23406: PUSH
23407: LD_INT 0
23409: PUSH
23410: LD_INT 1
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: PUSH
23417: LD_INT 1
23419: NEG
23420: PUSH
23421: LD_INT 0
23423: PUSH
23424: EMPTY
23425: LIST
23426: LIST
23427: PUSH
23428: LD_INT 1
23430: NEG
23431: PUSH
23432: LD_INT 1
23434: NEG
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: PUSH
23440: LD_INT 1
23442: NEG
23443: PUSH
23444: LD_INT 2
23446: NEG
23447: PUSH
23448: EMPTY
23449: LIST
23450: LIST
23451: PUSH
23452: LD_INT 1
23454: PUSH
23455: LD_INT 1
23457: NEG
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: PUSH
23463: LD_INT 2
23465: PUSH
23466: LD_INT 0
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: PUSH
23473: LD_INT 2
23475: PUSH
23476: LD_INT 1
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: LD_INT 2
23488: PUSH
23489: EMPTY
23490: LIST
23491: LIST
23492: PUSH
23493: LD_INT 0
23495: PUSH
23496: LD_INT 2
23498: PUSH
23499: EMPTY
23500: LIST
23501: LIST
23502: PUSH
23503: LD_INT 1
23505: NEG
23506: PUSH
23507: LD_INT 1
23509: PUSH
23510: EMPTY
23511: LIST
23512: LIST
23513: PUSH
23514: LD_INT 2
23516: NEG
23517: PUSH
23518: LD_INT 0
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: PUSH
23525: LD_INT 2
23527: NEG
23528: PUSH
23529: LD_INT 1
23531: NEG
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: PUSH
23537: LD_INT 2
23539: NEG
23540: PUSH
23541: LD_INT 2
23543: NEG
23544: PUSH
23545: EMPTY
23546: LIST
23547: LIST
23548: PUSH
23549: LD_INT 2
23551: NEG
23552: PUSH
23553: LD_INT 3
23555: NEG
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: LD_INT 2
23563: PUSH
23564: LD_INT 1
23566: NEG
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: PUSH
23572: LD_INT 3
23574: PUSH
23575: LD_INT 1
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: PUSH
23582: LD_INT 1
23584: PUSH
23585: LD_INT 3
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PUSH
23592: LD_INT 1
23594: NEG
23595: PUSH
23596: LD_INT 2
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: PUSH
23603: LD_INT 3
23605: NEG
23606: PUSH
23607: LD_INT 2
23609: NEG
23610: PUSH
23611: EMPTY
23612: LIST
23613: LIST
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: LIST
23621: LIST
23622: LIST
23623: LIST
23624: LIST
23625: LIST
23626: LIST
23627: LIST
23628: LIST
23629: LIST
23630: LIST
23631: LIST
23632: LIST
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23640: LD_ADDR_VAR 0 34
23644: PUSH
23645: LD_INT 0
23647: PUSH
23648: LD_INT 0
23650: PUSH
23651: EMPTY
23652: LIST
23653: LIST
23654: PUSH
23655: LD_INT 0
23657: PUSH
23658: LD_INT 1
23660: NEG
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: PUSH
23666: LD_INT 1
23668: PUSH
23669: LD_INT 0
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: PUSH
23676: LD_INT 1
23678: PUSH
23679: LD_INT 1
23681: PUSH
23682: EMPTY
23683: LIST
23684: LIST
23685: PUSH
23686: LD_INT 0
23688: PUSH
23689: LD_INT 1
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: PUSH
23696: LD_INT 1
23698: NEG
23699: PUSH
23700: LD_INT 0
23702: PUSH
23703: EMPTY
23704: LIST
23705: LIST
23706: PUSH
23707: LD_INT 1
23709: NEG
23710: PUSH
23711: LD_INT 1
23713: NEG
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PUSH
23719: LD_INT 1
23721: NEG
23722: PUSH
23723: LD_INT 2
23725: NEG
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: PUSH
23731: LD_INT 0
23733: PUSH
23734: LD_INT 2
23736: NEG
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: LD_INT 1
23744: PUSH
23745: LD_INT 1
23747: NEG
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: LD_INT 2
23755: PUSH
23756: LD_INT 1
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PUSH
23763: LD_INT 2
23765: PUSH
23766: LD_INT 2
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: LD_INT 1
23775: PUSH
23776: LD_INT 2
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: PUSH
23783: LD_INT 1
23785: NEG
23786: PUSH
23787: LD_INT 1
23789: PUSH
23790: EMPTY
23791: LIST
23792: LIST
23793: PUSH
23794: LD_INT 2
23796: NEG
23797: PUSH
23798: LD_INT 0
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: PUSH
23805: LD_INT 2
23807: NEG
23808: PUSH
23809: LD_INT 1
23811: NEG
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 2
23819: NEG
23820: PUSH
23821: LD_INT 2
23823: NEG
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 1
23831: NEG
23832: PUSH
23833: LD_INT 3
23835: NEG
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PUSH
23841: LD_INT 1
23843: PUSH
23844: LD_INT 2
23846: NEG
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: PUSH
23852: LD_INT 3
23854: PUSH
23855: LD_INT 2
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PUSH
23862: LD_INT 2
23864: PUSH
23865: LD_INT 3
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: LD_INT 2
23874: NEG
23875: PUSH
23876: LD_INT 1
23878: PUSH
23879: EMPTY
23880: LIST
23881: LIST
23882: PUSH
23883: LD_INT 3
23885: NEG
23886: PUSH
23887: LD_INT 1
23889: NEG
23890: PUSH
23891: EMPTY
23892: LIST
23893: LIST
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: LIST
23901: LIST
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: LIST
23907: LIST
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: LIST
23919: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
23920: LD_ADDR_VAR 0 35
23924: PUSH
23925: LD_INT 0
23927: PUSH
23928: LD_INT 0
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PUSH
23935: LD_INT 0
23937: PUSH
23938: LD_INT 1
23940: NEG
23941: PUSH
23942: EMPTY
23943: LIST
23944: LIST
23945: PUSH
23946: LD_INT 1
23948: PUSH
23949: LD_INT 0
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: PUSH
23956: LD_INT 1
23958: PUSH
23959: LD_INT 1
23961: PUSH
23962: EMPTY
23963: LIST
23964: LIST
23965: PUSH
23966: LD_INT 0
23968: PUSH
23969: LD_INT 1
23971: PUSH
23972: EMPTY
23973: LIST
23974: LIST
23975: PUSH
23976: LD_INT 1
23978: NEG
23979: PUSH
23980: LD_INT 0
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: PUSH
23987: LD_INT 1
23989: NEG
23990: PUSH
23991: LD_INT 1
23993: NEG
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 2
24001: PUSH
24002: LD_INT 1
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: PUSH
24009: LD_INT 2
24011: NEG
24012: PUSH
24013: LD_INT 1
24015: NEG
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: LIST
24025: LIST
24026: LIST
24027: LIST
24028: LIST
24029: LIST
24030: LIST
24031: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24032: LD_ADDR_VAR 0 36
24036: PUSH
24037: LD_INT 0
24039: PUSH
24040: LD_INT 0
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: PUSH
24047: LD_INT 0
24049: PUSH
24050: LD_INT 1
24052: NEG
24053: PUSH
24054: EMPTY
24055: LIST
24056: LIST
24057: PUSH
24058: LD_INT 1
24060: PUSH
24061: LD_INT 0
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: PUSH
24068: LD_INT 1
24070: PUSH
24071: LD_INT 1
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 0
24080: PUSH
24081: LD_INT 1
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 1
24090: NEG
24091: PUSH
24092: LD_INT 0
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: PUSH
24099: LD_INT 1
24101: NEG
24102: PUSH
24103: LD_INT 1
24105: NEG
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PUSH
24111: LD_INT 1
24113: NEG
24114: PUSH
24115: LD_INT 2
24117: NEG
24118: PUSH
24119: EMPTY
24120: LIST
24121: LIST
24122: PUSH
24123: LD_INT 1
24125: PUSH
24126: LD_INT 2
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24144: LD_ADDR_VAR 0 37
24148: PUSH
24149: LD_INT 0
24151: PUSH
24152: LD_INT 0
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: PUSH
24159: LD_INT 0
24161: PUSH
24162: LD_INT 1
24164: NEG
24165: PUSH
24166: EMPTY
24167: LIST
24168: LIST
24169: PUSH
24170: LD_INT 1
24172: PUSH
24173: LD_INT 0
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PUSH
24180: LD_INT 1
24182: PUSH
24183: LD_INT 1
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: PUSH
24190: LD_INT 0
24192: PUSH
24193: LD_INT 1
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: PUSH
24200: LD_INT 1
24202: NEG
24203: PUSH
24204: LD_INT 0
24206: PUSH
24207: EMPTY
24208: LIST
24209: LIST
24210: PUSH
24211: LD_INT 1
24213: NEG
24214: PUSH
24215: LD_INT 1
24217: NEG
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PUSH
24223: LD_INT 1
24225: PUSH
24226: LD_INT 1
24228: NEG
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: PUSH
24234: LD_INT 1
24236: NEG
24237: PUSH
24238: LD_INT 1
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: LIST
24249: LIST
24250: LIST
24251: LIST
24252: LIST
24253: LIST
24254: LIST
24255: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24256: LD_ADDR_VAR 0 38
24260: PUSH
24261: LD_INT 0
24263: PUSH
24264: LD_INT 0
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: PUSH
24271: LD_INT 0
24273: PUSH
24274: LD_INT 1
24276: NEG
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 1
24284: PUSH
24285: LD_INT 0
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: LD_INT 1
24294: PUSH
24295: LD_INT 1
24297: PUSH
24298: EMPTY
24299: LIST
24300: LIST
24301: PUSH
24302: LD_INT 0
24304: PUSH
24305: LD_INT 1
24307: PUSH
24308: EMPTY
24309: LIST
24310: LIST
24311: PUSH
24312: LD_INT 1
24314: NEG
24315: PUSH
24316: LD_INT 0
24318: PUSH
24319: EMPTY
24320: LIST
24321: LIST
24322: PUSH
24323: LD_INT 1
24325: NEG
24326: PUSH
24327: LD_INT 1
24329: NEG
24330: PUSH
24331: EMPTY
24332: LIST
24333: LIST
24334: PUSH
24335: LD_INT 2
24337: PUSH
24338: LD_INT 1
24340: PUSH
24341: EMPTY
24342: LIST
24343: LIST
24344: PUSH
24345: LD_INT 2
24347: NEG
24348: PUSH
24349: LD_INT 1
24351: NEG
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24368: LD_ADDR_VAR 0 39
24372: PUSH
24373: LD_INT 0
24375: PUSH
24376: LD_INT 0
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: PUSH
24383: LD_INT 0
24385: PUSH
24386: LD_INT 1
24388: NEG
24389: PUSH
24390: EMPTY
24391: LIST
24392: LIST
24393: PUSH
24394: LD_INT 1
24396: PUSH
24397: LD_INT 0
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: PUSH
24404: LD_INT 1
24406: PUSH
24407: LD_INT 1
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: PUSH
24414: LD_INT 0
24416: PUSH
24417: LD_INT 1
24419: PUSH
24420: EMPTY
24421: LIST
24422: LIST
24423: PUSH
24424: LD_INT 1
24426: NEG
24427: PUSH
24428: LD_INT 0
24430: PUSH
24431: EMPTY
24432: LIST
24433: LIST
24434: PUSH
24435: LD_INT 1
24437: NEG
24438: PUSH
24439: LD_INT 1
24441: NEG
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: PUSH
24447: LD_INT 1
24449: NEG
24450: PUSH
24451: LD_INT 2
24453: NEG
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PUSH
24459: LD_INT 1
24461: PUSH
24462: LD_INT 2
24464: PUSH
24465: EMPTY
24466: LIST
24467: LIST
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: LIST
24473: LIST
24474: LIST
24475: LIST
24476: LIST
24477: LIST
24478: LIST
24479: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24480: LD_ADDR_VAR 0 40
24484: PUSH
24485: LD_INT 0
24487: PUSH
24488: LD_INT 0
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: LD_INT 0
24497: PUSH
24498: LD_INT 1
24500: NEG
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 1
24508: PUSH
24509: LD_INT 0
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PUSH
24516: LD_INT 1
24518: PUSH
24519: LD_INT 1
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 0
24528: PUSH
24529: LD_INT 1
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: PUSH
24536: LD_INT 1
24538: NEG
24539: PUSH
24540: LD_INT 0
24542: PUSH
24543: EMPTY
24544: LIST
24545: LIST
24546: PUSH
24547: LD_INT 1
24549: NEG
24550: PUSH
24551: LD_INT 1
24553: NEG
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: PUSH
24559: LD_INT 1
24561: PUSH
24562: LD_INT 1
24564: NEG
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: PUSH
24570: LD_INT 1
24572: NEG
24573: PUSH
24574: LD_INT 1
24576: PUSH
24577: EMPTY
24578: LIST
24579: LIST
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: LIST
24590: LIST
24591: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24592: LD_ADDR_VAR 0 41
24596: PUSH
24597: LD_INT 0
24599: PUSH
24600: LD_INT 0
24602: PUSH
24603: EMPTY
24604: LIST
24605: LIST
24606: PUSH
24607: LD_INT 0
24609: PUSH
24610: LD_INT 1
24612: NEG
24613: PUSH
24614: EMPTY
24615: LIST
24616: LIST
24617: PUSH
24618: LD_INT 1
24620: PUSH
24621: LD_INT 0
24623: PUSH
24624: EMPTY
24625: LIST
24626: LIST
24627: PUSH
24628: LD_INT 1
24630: PUSH
24631: LD_INT 1
24633: PUSH
24634: EMPTY
24635: LIST
24636: LIST
24637: PUSH
24638: LD_INT 0
24640: PUSH
24641: LD_INT 1
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 1
24650: NEG
24651: PUSH
24652: LD_INT 0
24654: PUSH
24655: EMPTY
24656: LIST
24657: LIST
24658: PUSH
24659: LD_INT 1
24661: NEG
24662: PUSH
24663: LD_INT 1
24665: NEG
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: LD_INT 1
24673: NEG
24674: PUSH
24675: LD_INT 2
24677: NEG
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 1
24685: PUSH
24686: LD_INT 1
24688: NEG
24689: PUSH
24690: EMPTY
24691: LIST
24692: LIST
24693: PUSH
24694: LD_INT 2
24696: PUSH
24697: LD_INT 0
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: LD_INT 1
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: LD_INT 2
24716: PUSH
24717: LD_INT 2
24719: PUSH
24720: EMPTY
24721: LIST
24722: LIST
24723: PUSH
24724: LD_INT 1
24726: PUSH
24727: LD_INT 2
24729: PUSH
24730: EMPTY
24731: LIST
24732: LIST
24733: PUSH
24734: LD_INT 1
24736: NEG
24737: PUSH
24738: LD_INT 1
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: PUSH
24745: LD_INT 2
24747: NEG
24748: PUSH
24749: LD_INT 0
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: PUSH
24756: LD_INT 2
24758: NEG
24759: PUSH
24760: LD_INT 1
24762: NEG
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: LD_INT 2
24770: NEG
24771: PUSH
24772: LD_INT 2
24774: NEG
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: PUSH
24780: LD_INT 2
24782: NEG
24783: PUSH
24784: LD_INT 3
24786: NEG
24787: PUSH
24788: EMPTY
24789: LIST
24790: LIST
24791: PUSH
24792: LD_INT 2
24794: PUSH
24795: LD_INT 1
24797: NEG
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: PUSH
24803: LD_INT 3
24805: PUSH
24806: LD_INT 0
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PUSH
24813: LD_INT 3
24815: PUSH
24816: LD_INT 1
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: PUSH
24823: LD_INT 3
24825: PUSH
24826: LD_INT 2
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: PUSH
24833: LD_INT 3
24835: PUSH
24836: LD_INT 3
24838: PUSH
24839: EMPTY
24840: LIST
24841: LIST
24842: PUSH
24843: LD_INT 2
24845: PUSH
24846: LD_INT 3
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: LD_INT 2
24855: NEG
24856: PUSH
24857: LD_INT 1
24859: PUSH
24860: EMPTY
24861: LIST
24862: LIST
24863: PUSH
24864: LD_INT 3
24866: NEG
24867: PUSH
24868: LD_INT 0
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: LD_INT 3
24877: NEG
24878: PUSH
24879: LD_INT 1
24881: NEG
24882: PUSH
24883: EMPTY
24884: LIST
24885: LIST
24886: PUSH
24887: LD_INT 3
24889: NEG
24890: PUSH
24891: LD_INT 2
24893: NEG
24894: PUSH
24895: EMPTY
24896: LIST
24897: LIST
24898: PUSH
24899: LD_INT 3
24901: NEG
24902: PUSH
24903: LD_INT 3
24905: NEG
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: LIST
24915: LIST
24916: LIST
24917: LIST
24918: LIST
24919: LIST
24920: LIST
24921: LIST
24922: LIST
24923: LIST
24924: LIST
24925: LIST
24926: LIST
24927: LIST
24928: LIST
24929: LIST
24930: LIST
24931: LIST
24932: LIST
24933: LIST
24934: LIST
24935: LIST
24936: LIST
24937: LIST
24938: LIST
24939: LIST
24940: LIST
24941: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24942: LD_ADDR_VAR 0 42
24946: PUSH
24947: LD_INT 0
24949: PUSH
24950: LD_INT 0
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 0
24959: PUSH
24960: LD_INT 1
24962: NEG
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PUSH
24968: LD_INT 1
24970: PUSH
24971: LD_INT 0
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: PUSH
24978: LD_INT 1
24980: PUSH
24981: LD_INT 1
24983: PUSH
24984: EMPTY
24985: LIST
24986: LIST
24987: PUSH
24988: LD_INT 0
24990: PUSH
24991: LD_INT 1
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 1
25000: NEG
25001: PUSH
25002: LD_INT 0
25004: PUSH
25005: EMPTY
25006: LIST
25007: LIST
25008: PUSH
25009: LD_INT 1
25011: NEG
25012: PUSH
25013: LD_INT 1
25015: NEG
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: PUSH
25021: LD_INT 1
25023: NEG
25024: PUSH
25025: LD_INT 2
25027: NEG
25028: PUSH
25029: EMPTY
25030: LIST
25031: LIST
25032: PUSH
25033: LD_INT 0
25035: PUSH
25036: LD_INT 2
25038: NEG
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 1
25046: PUSH
25047: LD_INT 1
25049: NEG
25050: PUSH
25051: EMPTY
25052: LIST
25053: LIST
25054: PUSH
25055: LD_INT 2
25057: PUSH
25058: LD_INT 1
25060: PUSH
25061: EMPTY
25062: LIST
25063: LIST
25064: PUSH
25065: LD_INT 2
25067: PUSH
25068: LD_INT 2
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PUSH
25075: LD_INT 1
25077: PUSH
25078: LD_INT 2
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: PUSH
25085: LD_INT 0
25087: PUSH
25088: LD_INT 2
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: PUSH
25095: LD_INT 1
25097: NEG
25098: PUSH
25099: LD_INT 1
25101: PUSH
25102: EMPTY
25103: LIST
25104: LIST
25105: PUSH
25106: LD_INT 2
25108: NEG
25109: PUSH
25110: LD_INT 1
25112: NEG
25113: PUSH
25114: EMPTY
25115: LIST
25116: LIST
25117: PUSH
25118: LD_INT 2
25120: NEG
25121: PUSH
25122: LD_INT 2
25124: NEG
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: PUSH
25130: LD_INT 2
25132: NEG
25133: PUSH
25134: LD_INT 3
25136: NEG
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: PUSH
25142: LD_INT 1
25144: NEG
25145: PUSH
25146: LD_INT 3
25148: NEG
25149: PUSH
25150: EMPTY
25151: LIST
25152: LIST
25153: PUSH
25154: LD_INT 0
25156: PUSH
25157: LD_INT 3
25159: NEG
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: PUSH
25165: LD_INT 1
25167: PUSH
25168: LD_INT 2
25170: NEG
25171: PUSH
25172: EMPTY
25173: LIST
25174: LIST
25175: PUSH
25176: LD_INT 3
25178: PUSH
25179: LD_INT 2
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 3
25188: PUSH
25189: LD_INT 3
25191: PUSH
25192: EMPTY
25193: LIST
25194: LIST
25195: PUSH
25196: LD_INT 2
25198: PUSH
25199: LD_INT 3
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: PUSH
25206: LD_INT 1
25208: PUSH
25209: LD_INT 3
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: LD_INT 0
25218: PUSH
25219: LD_INT 3
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: LD_INT 1
25228: NEG
25229: PUSH
25230: LD_INT 2
25232: PUSH
25233: EMPTY
25234: LIST
25235: LIST
25236: PUSH
25237: LD_INT 3
25239: NEG
25240: PUSH
25241: LD_INT 2
25243: NEG
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: PUSH
25249: LD_INT 3
25251: NEG
25252: PUSH
25253: LD_INT 3
25255: NEG
25256: PUSH
25257: EMPTY
25258: LIST
25259: LIST
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: LIST
25274: LIST
25275: LIST
25276: LIST
25277: LIST
25278: LIST
25279: LIST
25280: LIST
25281: LIST
25282: LIST
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25292: LD_ADDR_VAR 0 43
25296: PUSH
25297: LD_INT 0
25299: PUSH
25300: LD_INT 0
25302: PUSH
25303: EMPTY
25304: LIST
25305: LIST
25306: PUSH
25307: LD_INT 0
25309: PUSH
25310: LD_INT 1
25312: NEG
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: LD_INT 1
25320: PUSH
25321: LD_INT 0
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: LD_INT 1
25330: PUSH
25331: LD_INT 1
25333: PUSH
25334: EMPTY
25335: LIST
25336: LIST
25337: PUSH
25338: LD_INT 0
25340: PUSH
25341: LD_INT 1
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 1
25350: NEG
25351: PUSH
25352: LD_INT 0
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: PUSH
25359: LD_INT 1
25361: NEG
25362: PUSH
25363: LD_INT 1
25365: NEG
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: PUSH
25371: LD_INT 1
25373: NEG
25374: PUSH
25375: LD_INT 2
25377: NEG
25378: PUSH
25379: EMPTY
25380: LIST
25381: LIST
25382: PUSH
25383: LD_INT 0
25385: PUSH
25386: LD_INT 2
25388: NEG
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: PUSH
25394: LD_INT 1
25396: PUSH
25397: LD_INT 1
25399: NEG
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: PUSH
25405: LD_INT 2
25407: PUSH
25408: LD_INT 0
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: PUSH
25415: LD_INT 2
25417: PUSH
25418: LD_INT 1
25420: PUSH
25421: EMPTY
25422: LIST
25423: LIST
25424: PUSH
25425: LD_INT 1
25427: PUSH
25428: LD_INT 2
25430: PUSH
25431: EMPTY
25432: LIST
25433: LIST
25434: PUSH
25435: LD_INT 0
25437: PUSH
25438: LD_INT 2
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PUSH
25445: LD_INT 1
25447: NEG
25448: PUSH
25449: LD_INT 1
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: PUSH
25456: LD_INT 2
25458: NEG
25459: PUSH
25460: LD_INT 0
25462: PUSH
25463: EMPTY
25464: LIST
25465: LIST
25466: PUSH
25467: LD_INT 2
25469: NEG
25470: PUSH
25471: LD_INT 1
25473: NEG
25474: PUSH
25475: EMPTY
25476: LIST
25477: LIST
25478: PUSH
25479: LD_INT 1
25481: NEG
25482: PUSH
25483: LD_INT 3
25485: NEG
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 3
25496: NEG
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: LD_INT 2
25507: NEG
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: PUSH
25513: LD_INT 2
25515: PUSH
25516: LD_INT 1
25518: NEG
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: PUSH
25524: LD_INT 3
25526: PUSH
25527: LD_INT 0
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: PUSH
25534: LD_INT 3
25536: PUSH
25537: LD_INT 1
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: PUSH
25544: LD_INT 1
25546: PUSH
25547: LD_INT 3
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 0
25556: PUSH
25557: LD_INT 3
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 1
25566: NEG
25567: PUSH
25568: LD_INT 2
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PUSH
25575: LD_INT 2
25577: NEG
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 3
25588: NEG
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 3
25599: NEG
25600: PUSH
25601: LD_INT 1
25603: NEG
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: LIST
25613: LIST
25614: LIST
25615: LIST
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: LIST
25628: LIST
25629: LIST
25630: LIST
25631: LIST
25632: LIST
25633: LIST
25634: LIST
25635: LIST
25636: LIST
25637: LIST
25638: LIST
25639: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25640: LD_ADDR_VAR 0 44
25644: PUSH
25645: LD_INT 0
25647: PUSH
25648: LD_INT 0
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PUSH
25655: LD_INT 0
25657: PUSH
25658: LD_INT 1
25660: NEG
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: LD_INT 1
25668: PUSH
25669: LD_INT 0
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 1
25678: PUSH
25679: LD_INT 1
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 0
25688: PUSH
25689: LD_INT 1
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 1
25698: NEG
25699: PUSH
25700: LD_INT 0
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: PUSH
25707: LD_INT 1
25709: NEG
25710: PUSH
25711: LD_INT 1
25713: NEG
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PUSH
25719: LD_INT 1
25721: NEG
25722: PUSH
25723: LD_INT 2
25725: NEG
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 1
25733: PUSH
25734: LD_INT 1
25736: NEG
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 2
25744: PUSH
25745: LD_INT 0
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 2
25754: PUSH
25755: LD_INT 1
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 2
25764: PUSH
25765: LD_INT 2
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: PUSH
25772: LD_INT 1
25774: PUSH
25775: LD_INT 2
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PUSH
25782: LD_INT 1
25784: NEG
25785: PUSH
25786: LD_INT 1
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: NEG
25796: PUSH
25797: LD_INT 0
25799: PUSH
25800: EMPTY
25801: LIST
25802: LIST
25803: PUSH
25804: LD_INT 2
25806: NEG
25807: PUSH
25808: LD_INT 1
25810: NEG
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 2
25818: NEG
25819: PUSH
25820: LD_INT 2
25822: NEG
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 2
25830: NEG
25831: PUSH
25832: LD_INT 3
25834: NEG
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 2
25842: PUSH
25843: LD_INT 1
25845: NEG
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 3
25853: PUSH
25854: LD_INT 0
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: LD_INT 3
25863: PUSH
25864: LD_INT 1
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: PUSH
25871: LD_INT 3
25873: PUSH
25874: LD_INT 2
25876: PUSH
25877: EMPTY
25878: LIST
25879: LIST
25880: PUSH
25881: LD_INT 3
25883: PUSH
25884: LD_INT 3
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: PUSH
25891: LD_INT 2
25893: PUSH
25894: LD_INT 3
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PUSH
25901: LD_INT 2
25903: NEG
25904: PUSH
25905: LD_INT 1
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: LD_INT 3
25914: NEG
25915: PUSH
25916: LD_INT 0
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 3
25925: NEG
25926: PUSH
25927: LD_INT 1
25929: NEG
25930: PUSH
25931: EMPTY
25932: LIST
25933: LIST
25934: PUSH
25935: LD_INT 3
25937: NEG
25938: PUSH
25939: LD_INT 2
25941: NEG
25942: PUSH
25943: EMPTY
25944: LIST
25945: LIST
25946: PUSH
25947: LD_INT 3
25949: NEG
25950: PUSH
25951: LD_INT 3
25953: NEG
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: LIST
25963: LIST
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: LIST
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: LIST
25985: LIST
25986: LIST
25987: LIST
25988: LIST
25989: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25990: LD_ADDR_VAR 0 45
25994: PUSH
25995: LD_INT 0
25997: PUSH
25998: LD_INT 0
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: LD_INT 0
26007: PUSH
26008: LD_INT 1
26010: NEG
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PUSH
26016: LD_INT 1
26018: PUSH
26019: LD_INT 0
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PUSH
26026: LD_INT 1
26028: PUSH
26029: LD_INT 1
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 0
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: NEG
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 1
26059: NEG
26060: PUSH
26061: LD_INT 1
26063: NEG
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 1
26071: NEG
26072: PUSH
26073: LD_INT 2
26075: NEG
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 2
26086: NEG
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 1
26094: PUSH
26095: LD_INT 1
26097: NEG
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 2
26105: PUSH
26106: LD_INT 1
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 2
26115: PUSH
26116: LD_INT 2
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 1
26125: PUSH
26126: LD_INT 2
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: PUSH
26133: LD_INT 0
26135: PUSH
26136: LD_INT 2
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 1
26145: NEG
26146: PUSH
26147: LD_INT 1
26149: PUSH
26150: EMPTY
26151: LIST
26152: LIST
26153: PUSH
26154: LD_INT 2
26156: NEG
26157: PUSH
26158: LD_INT 1
26160: NEG
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 2
26168: NEG
26169: PUSH
26170: LD_INT 2
26172: NEG
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: PUSH
26178: LD_INT 2
26180: NEG
26181: PUSH
26182: LD_INT 3
26184: NEG
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: PUSH
26190: LD_INT 1
26192: NEG
26193: PUSH
26194: LD_INT 3
26196: NEG
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: PUSH
26202: LD_INT 0
26204: PUSH
26205: LD_INT 3
26207: NEG
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: PUSH
26213: LD_INT 1
26215: PUSH
26216: LD_INT 2
26218: NEG
26219: PUSH
26220: EMPTY
26221: LIST
26222: LIST
26223: PUSH
26224: LD_INT 3
26226: PUSH
26227: LD_INT 2
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 3
26236: PUSH
26237: LD_INT 3
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: LD_INT 2
26246: PUSH
26247: LD_INT 3
26249: PUSH
26250: EMPTY
26251: LIST
26252: LIST
26253: PUSH
26254: LD_INT 1
26256: PUSH
26257: LD_INT 3
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: PUSH
26264: LD_INT 0
26266: PUSH
26267: LD_INT 3
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: PUSH
26274: LD_INT 1
26276: NEG
26277: PUSH
26278: LD_INT 2
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: PUSH
26285: LD_INT 3
26287: NEG
26288: PUSH
26289: LD_INT 2
26291: NEG
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: PUSH
26297: LD_INT 3
26299: NEG
26300: PUSH
26301: LD_INT 3
26303: NEG
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: LIST
26322: LIST
26323: LIST
26324: LIST
26325: LIST
26326: LIST
26327: LIST
26328: LIST
26329: LIST
26330: LIST
26331: LIST
26332: LIST
26333: LIST
26334: LIST
26335: LIST
26336: LIST
26337: LIST
26338: LIST
26339: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26340: LD_ADDR_VAR 0 46
26344: PUSH
26345: LD_INT 0
26347: PUSH
26348: LD_INT 0
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 0
26357: PUSH
26358: LD_INT 1
26360: NEG
26361: PUSH
26362: EMPTY
26363: LIST
26364: LIST
26365: PUSH
26366: LD_INT 1
26368: PUSH
26369: LD_INT 0
26371: PUSH
26372: EMPTY
26373: LIST
26374: LIST
26375: PUSH
26376: LD_INT 1
26378: PUSH
26379: LD_INT 1
26381: PUSH
26382: EMPTY
26383: LIST
26384: LIST
26385: PUSH
26386: LD_INT 0
26388: PUSH
26389: LD_INT 1
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 1
26398: NEG
26399: PUSH
26400: LD_INT 0
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PUSH
26407: LD_INT 1
26409: NEG
26410: PUSH
26411: LD_INT 1
26413: NEG
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: PUSH
26419: LD_INT 1
26421: NEG
26422: PUSH
26423: LD_INT 2
26425: NEG
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 0
26433: PUSH
26434: LD_INT 2
26436: NEG
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: LD_INT 1
26447: NEG
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: PUSH
26453: LD_INT 2
26455: PUSH
26456: LD_INT 0
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: PUSH
26463: LD_INT 2
26465: PUSH
26466: LD_INT 1
26468: PUSH
26469: EMPTY
26470: LIST
26471: LIST
26472: PUSH
26473: LD_INT 1
26475: PUSH
26476: LD_INT 2
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: PUSH
26483: LD_INT 0
26485: PUSH
26486: LD_INT 2
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 1
26495: NEG
26496: PUSH
26497: LD_INT 1
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: PUSH
26504: LD_INT 2
26506: NEG
26507: PUSH
26508: LD_INT 0
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 2
26517: NEG
26518: PUSH
26519: LD_INT 1
26521: NEG
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 1
26529: NEG
26530: PUSH
26531: LD_INT 3
26533: NEG
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 0
26541: PUSH
26542: LD_INT 3
26544: NEG
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 1
26552: PUSH
26553: LD_INT 2
26555: NEG
26556: PUSH
26557: EMPTY
26558: LIST
26559: LIST
26560: PUSH
26561: LD_INT 2
26563: PUSH
26564: LD_INT 1
26566: NEG
26567: PUSH
26568: EMPTY
26569: LIST
26570: LIST
26571: PUSH
26572: LD_INT 3
26574: PUSH
26575: LD_INT 0
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 3
26584: PUSH
26585: LD_INT 1
26587: PUSH
26588: EMPTY
26589: LIST
26590: LIST
26591: PUSH
26592: LD_INT 1
26594: PUSH
26595: LD_INT 3
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PUSH
26602: LD_INT 0
26604: PUSH
26605: LD_INT 3
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: LD_INT 2
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 2
26625: NEG
26626: PUSH
26627: LD_INT 1
26629: PUSH
26630: EMPTY
26631: LIST
26632: LIST
26633: PUSH
26634: LD_INT 3
26636: NEG
26637: PUSH
26638: LD_INT 0
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 3
26647: NEG
26648: PUSH
26649: LD_INT 1
26651: NEG
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: LIST
26683: LIST
26684: LIST
26685: LIST
26686: LIST
26687: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26688: LD_ADDR_VAR 0 47
26692: PUSH
26693: LD_INT 0
26695: PUSH
26696: LD_INT 0
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: PUSH
26703: LD_INT 0
26705: PUSH
26706: LD_INT 1
26708: NEG
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: PUSH
26714: LD_INT 1
26716: PUSH
26717: LD_INT 0
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: PUSH
26724: LD_INT 1
26726: PUSH
26727: LD_INT 1
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PUSH
26734: LD_INT 0
26736: PUSH
26737: LD_INT 1
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: PUSH
26744: LD_INT 1
26746: NEG
26747: PUSH
26748: LD_INT 0
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PUSH
26755: LD_INT 1
26757: NEG
26758: PUSH
26759: LD_INT 1
26761: NEG
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: PUSH
26767: LD_INT 1
26769: NEG
26770: PUSH
26771: LD_INT 2
26773: NEG
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PUSH
26779: LD_INT 0
26781: PUSH
26782: LD_INT 2
26784: NEG
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: PUSH
26790: LD_INT 1
26792: PUSH
26793: LD_INT 1
26795: NEG
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 2
26803: NEG
26804: PUSH
26805: LD_INT 1
26807: NEG
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 2
26815: NEG
26816: PUSH
26817: LD_INT 2
26819: NEG
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
26839: LD_ADDR_VAR 0 48
26843: PUSH
26844: LD_INT 0
26846: PUSH
26847: LD_INT 0
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: LD_INT 1
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 1
26867: PUSH
26868: LD_INT 0
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: LD_INT 1
26877: PUSH
26878: LD_INT 1
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 1
26897: NEG
26898: PUSH
26899: LD_INT 0
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 1
26908: NEG
26909: PUSH
26910: LD_INT 1
26912: NEG
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 1
26920: NEG
26921: PUSH
26922: LD_INT 2
26924: NEG
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: LD_INT 0
26932: PUSH
26933: LD_INT 2
26935: NEG
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 1
26943: PUSH
26944: LD_INT 1
26946: NEG
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: PUSH
26952: LD_INT 2
26954: PUSH
26955: LD_INT 0
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: PUSH
26962: LD_INT 2
26964: PUSH
26965: LD_INT 1
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: LIST
26976: LIST
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
26986: LD_ADDR_VAR 0 49
26990: PUSH
26991: LD_INT 0
26993: PUSH
26994: LD_INT 0
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PUSH
27001: LD_INT 0
27003: PUSH
27004: LD_INT 1
27006: NEG
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 1
27014: PUSH
27015: LD_INT 0
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 1
27024: PUSH
27025: LD_INT 1
27027: PUSH
27028: EMPTY
27029: LIST
27030: LIST
27031: PUSH
27032: LD_INT 0
27034: PUSH
27035: LD_INT 1
27037: PUSH
27038: EMPTY
27039: LIST
27040: LIST
27041: PUSH
27042: LD_INT 1
27044: NEG
27045: PUSH
27046: LD_INT 0
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 1
27055: NEG
27056: PUSH
27057: LD_INT 1
27059: NEG
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 1
27067: PUSH
27068: LD_INT 1
27070: NEG
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 2
27078: PUSH
27079: LD_INT 0
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: PUSH
27086: LD_INT 2
27088: PUSH
27089: LD_INT 1
27091: PUSH
27092: EMPTY
27093: LIST
27094: LIST
27095: PUSH
27096: LD_INT 2
27098: PUSH
27099: LD_INT 2
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 1
27108: PUSH
27109: LD_INT 2
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: LIST
27120: LIST
27121: LIST
27122: LIST
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
27130: LD_ADDR_VAR 0 50
27134: PUSH
27135: LD_INT 0
27137: PUSH
27138: LD_INT 0
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 0
27147: PUSH
27148: LD_INT 1
27150: NEG
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PUSH
27156: LD_INT 1
27158: PUSH
27159: LD_INT 0
27161: PUSH
27162: EMPTY
27163: LIST
27164: LIST
27165: PUSH
27166: LD_INT 1
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 0
27178: PUSH
27179: LD_INT 1
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 1
27188: NEG
27189: PUSH
27190: LD_INT 0
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 1
27199: NEG
27200: PUSH
27201: LD_INT 1
27203: NEG
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PUSH
27209: LD_INT 2
27211: PUSH
27212: LD_INT 1
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: LD_INT 2
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: PUSH
27229: LD_INT 1
27231: PUSH
27232: LD_INT 2
27234: PUSH
27235: EMPTY
27236: LIST
27237: LIST
27238: PUSH
27239: LD_INT 0
27241: PUSH
27242: LD_INT 2
27244: PUSH
27245: EMPTY
27246: LIST
27247: LIST
27248: PUSH
27249: LD_INT 1
27251: NEG
27252: PUSH
27253: LD_INT 1
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: LIST
27264: LIST
27265: LIST
27266: LIST
27267: LIST
27268: LIST
27269: LIST
27270: LIST
27271: LIST
27272: LIST
27273: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
27274: LD_ADDR_VAR 0 51
27278: PUSH
27279: LD_INT 0
27281: PUSH
27282: LD_INT 0
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: PUSH
27289: LD_INT 0
27291: PUSH
27292: LD_INT 1
27294: NEG
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: PUSH
27300: LD_INT 1
27302: PUSH
27303: LD_INT 0
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: PUSH
27310: LD_INT 1
27312: PUSH
27313: LD_INT 1
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: PUSH
27320: LD_INT 0
27322: PUSH
27323: LD_INT 1
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: PUSH
27330: LD_INT 1
27332: NEG
27333: PUSH
27334: LD_INT 0
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 1
27343: NEG
27344: PUSH
27345: LD_INT 1
27347: NEG
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: LD_INT 1
27355: PUSH
27356: LD_INT 2
27358: PUSH
27359: EMPTY
27360: LIST
27361: LIST
27362: PUSH
27363: LD_INT 0
27365: PUSH
27366: LD_INT 2
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: LD_INT 1
27375: NEG
27376: PUSH
27377: LD_INT 1
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 2
27386: NEG
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 2
27397: NEG
27398: PUSH
27399: LD_INT 1
27401: NEG
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: LIST
27411: LIST
27412: LIST
27413: LIST
27414: LIST
27415: LIST
27416: LIST
27417: LIST
27418: LIST
27419: LIST
27420: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27421: LD_ADDR_VAR 0 52
27425: PUSH
27426: LD_INT 0
27428: PUSH
27429: LD_INT 0
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 0
27438: PUSH
27439: LD_INT 1
27441: NEG
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: PUSH
27447: LD_INT 1
27449: PUSH
27450: LD_INT 0
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 1
27459: PUSH
27460: LD_INT 1
27462: PUSH
27463: EMPTY
27464: LIST
27465: LIST
27466: PUSH
27467: LD_INT 0
27469: PUSH
27470: LD_INT 1
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: PUSH
27477: LD_INT 1
27479: NEG
27480: PUSH
27481: LD_INT 0
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: PUSH
27488: LD_INT 1
27490: NEG
27491: PUSH
27492: LD_INT 1
27494: NEG
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: PUSH
27500: LD_INT 1
27502: NEG
27503: PUSH
27504: LD_INT 2
27506: NEG
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 1
27514: NEG
27515: PUSH
27516: LD_INT 1
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 2
27525: NEG
27526: PUSH
27527: LD_INT 0
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 2
27536: NEG
27537: PUSH
27538: LD_INT 1
27540: NEG
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 2
27548: NEG
27549: PUSH
27550: LD_INT 2
27552: NEG
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: LIST
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27572: LD_ADDR_VAR 0 53
27576: PUSH
27577: LD_INT 0
27579: PUSH
27580: LD_INT 0
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: PUSH
27587: LD_INT 0
27589: PUSH
27590: LD_INT 1
27592: NEG
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PUSH
27598: LD_INT 1
27600: PUSH
27601: LD_INT 0
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 1
27610: PUSH
27611: LD_INT 1
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: LD_INT 1
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: NEG
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: LD_INT 1
27641: NEG
27642: PUSH
27643: LD_INT 1
27645: NEG
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 1
27653: NEG
27654: PUSH
27655: LD_INT 2
27657: NEG
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: LD_INT 2
27668: NEG
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 1
27676: PUSH
27677: LD_INT 1
27679: NEG
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PUSH
27685: LD_INT 2
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 2
27697: PUSH
27698: LD_INT 1
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 2
27707: PUSH
27708: LD_INT 2
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: LD_INT 1
27717: PUSH
27718: LD_INT 2
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: PUSH
27725: LD_INT 0
27727: PUSH
27728: LD_INT 2
27730: PUSH
27731: EMPTY
27732: LIST
27733: LIST
27734: PUSH
27735: LD_INT 1
27737: NEG
27738: PUSH
27739: LD_INT 1
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 2
27748: NEG
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 2
27759: NEG
27760: PUSH
27761: LD_INT 1
27763: NEG
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 2
27771: NEG
27772: PUSH
27773: LD_INT 2
27775: NEG
27776: PUSH
27777: EMPTY
27778: LIST
27779: LIST
27780: PUSH
27781: EMPTY
27782: LIST
27783: LIST
27784: LIST
27785: LIST
27786: LIST
27787: LIST
27788: LIST
27789: LIST
27790: LIST
27791: LIST
27792: LIST
27793: LIST
27794: LIST
27795: LIST
27796: LIST
27797: LIST
27798: LIST
27799: LIST
27800: LIST
27801: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27802: LD_ADDR_VAR 0 54
27806: PUSH
27807: LD_INT 0
27809: PUSH
27810: LD_INT 0
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: PUSH
27817: LD_INT 0
27819: PUSH
27820: LD_INT 1
27822: NEG
27823: PUSH
27824: EMPTY
27825: LIST
27826: LIST
27827: PUSH
27828: LD_INT 1
27830: PUSH
27831: LD_INT 0
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 1
27840: PUSH
27841: LD_INT 1
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: LD_INT 1
27853: PUSH
27854: EMPTY
27855: LIST
27856: LIST
27857: PUSH
27858: LD_INT 1
27860: NEG
27861: PUSH
27862: LD_INT 0
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 1
27871: NEG
27872: PUSH
27873: LD_INT 1
27875: NEG
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 1
27883: NEG
27884: PUSH
27885: LD_INT 2
27887: NEG
27888: PUSH
27889: EMPTY
27890: LIST
27891: LIST
27892: PUSH
27893: LD_INT 0
27895: PUSH
27896: LD_INT 2
27898: NEG
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: LD_INT 1
27906: PUSH
27907: LD_INT 1
27909: NEG
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 2
27917: PUSH
27918: LD_INT 0
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 2
27927: PUSH
27928: LD_INT 1
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 2
27937: PUSH
27938: LD_INT 2
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: PUSH
27945: LD_INT 1
27947: PUSH
27948: LD_INT 2
27950: PUSH
27951: EMPTY
27952: LIST
27953: LIST
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: LD_INT 2
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 1
27967: NEG
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 2
27978: NEG
27979: PUSH
27980: LD_INT 0
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 2
27989: NEG
27990: PUSH
27991: LD_INT 1
27993: NEG
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: LD_INT 2
28001: NEG
28002: PUSH
28003: LD_INT 2
28005: NEG
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: LIST
28015: LIST
28016: LIST
28017: LIST
28018: LIST
28019: LIST
28020: LIST
28021: LIST
28022: LIST
28023: LIST
28024: LIST
28025: LIST
28026: LIST
28027: LIST
28028: LIST
28029: LIST
28030: LIST
28031: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28032: LD_ADDR_VAR 0 55
28036: PUSH
28037: LD_INT 0
28039: PUSH
28040: LD_INT 0
28042: PUSH
28043: EMPTY
28044: LIST
28045: LIST
28046: PUSH
28047: LD_INT 0
28049: PUSH
28050: LD_INT 1
28052: NEG
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 1
28060: PUSH
28061: LD_INT 0
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 1
28070: PUSH
28071: LD_INT 1
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: LD_INT 0
28080: PUSH
28081: LD_INT 1
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: LD_INT 1
28090: NEG
28091: PUSH
28092: LD_INT 0
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: PUSH
28099: LD_INT 1
28101: NEG
28102: PUSH
28103: LD_INT 1
28105: NEG
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: LD_INT 1
28113: NEG
28114: PUSH
28115: LD_INT 2
28117: NEG
28118: PUSH
28119: EMPTY
28120: LIST
28121: LIST
28122: PUSH
28123: LD_INT 0
28125: PUSH
28126: LD_INT 2
28128: NEG
28129: PUSH
28130: EMPTY
28131: LIST
28132: LIST
28133: PUSH
28134: LD_INT 1
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 2
28147: PUSH
28148: LD_INT 0
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: PUSH
28155: LD_INT 2
28157: PUSH
28158: LD_INT 1
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: PUSH
28165: LD_INT 2
28167: PUSH
28168: LD_INT 2
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PUSH
28175: LD_INT 1
28177: PUSH
28178: LD_INT 2
28180: PUSH
28181: EMPTY
28182: LIST
28183: LIST
28184: PUSH
28185: LD_INT 0
28187: PUSH
28188: LD_INT 2
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: PUSH
28195: LD_INT 1
28197: NEG
28198: PUSH
28199: LD_INT 1
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 2
28208: NEG
28209: PUSH
28210: LD_INT 0
28212: PUSH
28213: EMPTY
28214: LIST
28215: LIST
28216: PUSH
28217: LD_INT 2
28219: NEG
28220: PUSH
28221: LD_INT 1
28223: NEG
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 2
28231: NEG
28232: PUSH
28233: LD_INT 2
28235: NEG
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28262: LD_ADDR_VAR 0 56
28266: PUSH
28267: LD_INT 0
28269: PUSH
28270: LD_INT 0
28272: PUSH
28273: EMPTY
28274: LIST
28275: LIST
28276: PUSH
28277: LD_INT 0
28279: PUSH
28280: LD_INT 1
28282: NEG
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: LD_INT 1
28290: PUSH
28291: LD_INT 0
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 1
28300: PUSH
28301: LD_INT 1
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: PUSH
28308: LD_INT 0
28310: PUSH
28311: LD_INT 1
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 1
28320: NEG
28321: PUSH
28322: LD_INT 0
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: NEG
28332: PUSH
28333: LD_INT 1
28335: NEG
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: PUSH
28341: LD_INT 1
28343: NEG
28344: PUSH
28345: LD_INT 2
28347: NEG
28348: PUSH
28349: EMPTY
28350: LIST
28351: LIST
28352: PUSH
28353: LD_INT 0
28355: PUSH
28356: LD_INT 2
28358: NEG
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: LD_INT 1
28369: NEG
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: PUSH
28375: LD_INT 2
28377: PUSH
28378: LD_INT 0
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: PUSH
28385: LD_INT 2
28387: PUSH
28388: LD_INT 1
28390: PUSH
28391: EMPTY
28392: LIST
28393: LIST
28394: PUSH
28395: LD_INT 2
28397: PUSH
28398: LD_INT 2
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 1
28407: PUSH
28408: LD_INT 2
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 0
28417: PUSH
28418: LD_INT 2
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 1
28427: NEG
28428: PUSH
28429: LD_INT 1
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 2
28438: NEG
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 2
28449: NEG
28450: PUSH
28451: LD_INT 1
28453: NEG
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: LD_INT 2
28461: NEG
28462: PUSH
28463: LD_INT 2
28465: NEG
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: EMPTY
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28492: LD_ADDR_VAR 0 57
28496: PUSH
28497: LD_INT 0
28499: PUSH
28500: LD_INT 0
28502: PUSH
28503: EMPTY
28504: LIST
28505: LIST
28506: PUSH
28507: LD_INT 0
28509: PUSH
28510: LD_INT 1
28512: NEG
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: LD_INT 1
28520: PUSH
28521: LD_INT 0
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: PUSH
28528: LD_INT 1
28530: PUSH
28531: LD_INT 1
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: LD_INT 1
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 1
28550: NEG
28551: PUSH
28552: LD_INT 0
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 1
28561: NEG
28562: PUSH
28563: LD_INT 1
28565: NEG
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 1
28573: NEG
28574: PUSH
28575: LD_INT 2
28577: NEG
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PUSH
28583: LD_INT 0
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 1
28596: PUSH
28597: LD_INT 1
28599: NEG
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: LD_INT 2
28607: PUSH
28608: LD_INT 0
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PUSH
28615: LD_INT 2
28617: PUSH
28618: LD_INT 1
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 2
28627: PUSH
28628: LD_INT 2
28630: PUSH
28631: EMPTY
28632: LIST
28633: LIST
28634: PUSH
28635: LD_INT 1
28637: PUSH
28638: LD_INT 2
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: PUSH
28645: LD_INT 0
28647: PUSH
28648: LD_INT 2
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PUSH
28655: LD_INT 1
28657: NEG
28658: PUSH
28659: LD_INT 1
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 2
28668: NEG
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 2
28691: NEG
28692: PUSH
28693: LD_INT 2
28695: NEG
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: EMPTY
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: LIST
28719: LIST
28720: LIST
28721: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28722: LD_ADDR_VAR 0 58
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: LD_INT 0
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: PUSH
28737: LD_INT 0
28739: PUSH
28740: LD_INT 1
28742: NEG
28743: PUSH
28744: EMPTY
28745: LIST
28746: LIST
28747: PUSH
28748: LD_INT 1
28750: PUSH
28751: LD_INT 0
28753: PUSH
28754: EMPTY
28755: LIST
28756: LIST
28757: PUSH
28758: LD_INT 1
28760: PUSH
28761: LD_INT 1
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 0
28770: PUSH
28771: LD_INT 1
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 1
28780: NEG
28781: PUSH
28782: LD_INT 0
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 1
28791: NEG
28792: PUSH
28793: LD_INT 1
28795: NEG
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PUSH
28801: LD_INT 1
28803: NEG
28804: PUSH
28805: LD_INT 2
28807: NEG
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: PUSH
28813: LD_INT 0
28815: PUSH
28816: LD_INT 2
28818: NEG
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 1
28826: PUSH
28827: LD_INT 1
28829: NEG
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 2
28837: PUSH
28838: LD_INT 0
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 2
28847: PUSH
28848: LD_INT 1
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: LD_INT 2
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 1
28867: PUSH
28868: LD_INT 2
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: LD_INT 0
28877: PUSH
28878: LD_INT 2
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 2
28898: NEG
28899: PUSH
28900: LD_INT 0
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PUSH
28907: LD_INT 2
28909: NEG
28910: PUSH
28911: LD_INT 1
28913: NEG
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: LD_INT 2
28921: NEG
28922: PUSH
28923: LD_INT 2
28925: NEG
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: EMPTY
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
28952: LD_ADDR_VAR 0 59
28956: PUSH
28957: LD_INT 0
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 0
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 1
28980: PUSH
28981: LD_INT 0
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: LD_INT 1
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 1
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 1
29010: NEG
29011: PUSH
29012: LD_INT 0
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: NEG
29022: PUSH
29023: LD_INT 1
29025: NEG
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29040: LD_ADDR_VAR 0 60
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: LD_INT 0
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: LD_INT 1
29060: NEG
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 1
29068: PUSH
29069: LD_INT 0
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 0
29088: PUSH
29089: LD_INT 1
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 1
29098: NEG
29099: PUSH
29100: LD_INT 0
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: LD_INT 1
29113: NEG
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PUSH
29119: EMPTY
29120: LIST
29121: LIST
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29128: LD_ADDR_VAR 0 61
29132: PUSH
29133: LD_INT 0
29135: PUSH
29136: LD_INT 0
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 0
29145: PUSH
29146: LD_INT 1
29148: NEG
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 1
29156: PUSH
29157: LD_INT 0
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 1
29166: PUSH
29167: LD_INT 1
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 0
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 1
29186: NEG
29187: PUSH
29188: LD_INT 0
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: LD_INT 1
29197: NEG
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29216: LD_ADDR_VAR 0 62
29220: PUSH
29221: LD_INT 0
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: LD_INT 1
29236: NEG
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: PUSH
29242: LD_INT 1
29244: PUSH
29245: LD_INT 0
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: LD_INT 1
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 0
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 1
29274: NEG
29275: PUSH
29276: LD_INT 0
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: PUSH
29283: LD_INT 1
29285: NEG
29286: PUSH
29287: LD_INT 1
29289: NEG
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: LIST
29299: LIST
29300: LIST
29301: LIST
29302: LIST
29303: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29304: LD_ADDR_VAR 0 63
29308: PUSH
29309: LD_INT 0
29311: PUSH
29312: LD_INT 0
29314: PUSH
29315: EMPTY
29316: LIST
29317: LIST
29318: PUSH
29319: LD_INT 0
29321: PUSH
29322: LD_INT 1
29324: NEG
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 1
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: LD_INT 1
29342: PUSH
29343: LD_INT 1
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 0
29352: PUSH
29353: LD_INT 1
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: LD_INT 0
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 1
29373: NEG
29374: PUSH
29375: LD_INT 1
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: LIST
29389: LIST
29390: LIST
29391: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29392: LD_ADDR_VAR 0 64
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 0
29409: PUSH
29410: LD_INT 1
29412: NEG
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 1
29420: PUSH
29421: LD_INT 0
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 1
29430: PUSH
29431: LD_INT 1
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 0
29440: PUSH
29441: LD_INT 1
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 1
29450: NEG
29451: PUSH
29452: LD_INT 0
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 1
29461: NEG
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: ST_TO_ADDR
// end ; 1 :
29480: GO 35377
29482: LD_INT 1
29484: DOUBLE
29485: EQUAL
29486: IFTRUE 29490
29488: GO 32113
29490: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29491: LD_ADDR_VAR 0 11
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: LD_INT 3
29502: NEG
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 0
29510: PUSH
29511: LD_INT 3
29513: NEG
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 2
29524: NEG
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: LIST
29534: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29535: LD_ADDR_VAR 0 12
29539: PUSH
29540: LD_INT 2
29542: PUSH
29543: LD_INT 1
29545: NEG
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: PUSH
29551: LD_INT 3
29553: PUSH
29554: LD_INT 0
29556: PUSH
29557: EMPTY
29558: LIST
29559: LIST
29560: PUSH
29561: LD_INT 3
29563: PUSH
29564: LD_INT 1
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: LIST
29575: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29576: LD_ADDR_VAR 0 13
29580: PUSH
29581: LD_INT 3
29583: PUSH
29584: LD_INT 2
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 3
29593: PUSH
29594: LD_INT 3
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 2
29603: PUSH
29604: LD_INT 3
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: LIST
29615: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29616: LD_ADDR_VAR 0 14
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: LD_INT 3
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: LD_INT 3
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: NEG
29644: PUSH
29645: LD_INT 2
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: LIST
29656: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29657: LD_ADDR_VAR 0 15
29661: PUSH
29662: LD_INT 2
29664: NEG
29665: PUSH
29666: LD_INT 1
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 3
29675: NEG
29676: PUSH
29677: LD_INT 0
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 3
29686: NEG
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: LIST
29700: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29701: LD_ADDR_VAR 0 16
29705: PUSH
29706: LD_INT 2
29708: NEG
29709: PUSH
29710: LD_INT 3
29712: NEG
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 3
29720: NEG
29721: PUSH
29722: LD_INT 2
29724: NEG
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 3
29732: NEG
29733: PUSH
29734: LD_INT 3
29736: NEG
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: LIST
29746: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29747: LD_ADDR_VAR 0 17
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 3
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 0
29766: PUSH
29767: LD_INT 3
29769: NEG
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: PUSH
29778: LD_INT 2
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: LIST
29790: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29791: LD_ADDR_VAR 0 18
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 1
29801: NEG
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 3
29809: PUSH
29810: LD_INT 0
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: LD_INT 3
29819: PUSH
29820: LD_INT 1
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: LIST
29831: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29832: LD_ADDR_VAR 0 19
29836: PUSH
29837: LD_INT 3
29839: PUSH
29840: LD_INT 2
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 3
29849: PUSH
29850: LD_INT 3
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: PUSH
29860: LD_INT 3
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: LIST
29871: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29872: LD_ADDR_VAR 0 20
29876: PUSH
29877: LD_INT 1
29879: PUSH
29880: LD_INT 3
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 0
29889: PUSH
29890: LD_INT 3
29892: PUSH
29893: EMPTY
29894: LIST
29895: LIST
29896: PUSH
29897: LD_INT 1
29899: NEG
29900: PUSH
29901: LD_INT 2
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: LIST
29912: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29913: LD_ADDR_VAR 0 21
29917: PUSH
29918: LD_INT 2
29920: NEG
29921: PUSH
29922: LD_INT 1
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 3
29931: NEG
29932: PUSH
29933: LD_INT 0
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 3
29942: NEG
29943: PUSH
29944: LD_INT 1
29946: NEG
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: LIST
29956: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29957: LD_ADDR_VAR 0 22
29961: PUSH
29962: LD_INT 2
29964: NEG
29965: PUSH
29966: LD_INT 3
29968: NEG
29969: PUSH
29970: EMPTY
29971: LIST
29972: LIST
29973: PUSH
29974: LD_INT 3
29976: NEG
29977: PUSH
29978: LD_INT 2
29980: NEG
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 3
29988: NEG
29989: PUSH
29990: LD_INT 3
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: LIST
30002: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
30003: LD_ADDR_VAR 0 23
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: LD_INT 3
30013: NEG
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: NEG
30022: PUSH
30023: LD_INT 4
30025: NEG
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 1
30033: PUSH
30034: LD_INT 3
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: LIST
30046: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
30047: LD_ADDR_VAR 0 24
30051: PUSH
30052: LD_INT 3
30054: PUSH
30055: LD_INT 0
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 3
30064: PUSH
30065: LD_INT 1
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 4
30075: PUSH
30076: LD_INT 1
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: LIST
30087: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
30088: LD_ADDR_VAR 0 25
30092: PUSH
30093: LD_INT 3
30095: PUSH
30096: LD_INT 3
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: PUSH
30103: LD_INT 4
30105: PUSH
30106: LD_INT 3
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 3
30115: PUSH
30116: LD_INT 4
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: LIST
30127: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
30128: LD_ADDR_VAR 0 26
30132: PUSH
30133: LD_INT 0
30135: PUSH
30136: LD_INT 3
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 1
30145: PUSH
30146: LD_INT 4
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: PUSH
30153: LD_INT 1
30155: NEG
30156: PUSH
30157: LD_INT 3
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: LIST
30168: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
30169: LD_ADDR_VAR 0 27
30173: PUSH
30174: LD_INT 3
30176: NEG
30177: PUSH
30178: LD_INT 0
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: LD_INT 3
30187: NEG
30188: PUSH
30189: LD_INT 1
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PUSH
30196: LD_INT 4
30198: NEG
30199: PUSH
30200: LD_INT 1
30202: NEG
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: LIST
30212: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
30213: LD_ADDR_VAR 0 28
30217: PUSH
30218: LD_INT 3
30220: NEG
30221: PUSH
30222: LD_INT 3
30224: NEG
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 3
30232: NEG
30233: PUSH
30234: LD_INT 4
30236: NEG
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 4
30244: NEG
30245: PUSH
30246: LD_INT 3
30248: NEG
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
30259: LD_ADDR_VAR 0 29
30263: PUSH
30264: LD_INT 1
30266: NEG
30267: PUSH
30268: LD_INT 3
30270: NEG
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 0
30278: PUSH
30279: LD_INT 3
30281: NEG
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: LD_INT 2
30292: NEG
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PUSH
30298: LD_INT 1
30300: NEG
30301: PUSH
30302: LD_INT 4
30304: NEG
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 0
30312: PUSH
30313: LD_INT 4
30315: NEG
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 1
30323: PUSH
30324: LD_INT 3
30326: NEG
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: LD_INT 5
30338: NEG
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: LD_INT 5
30349: NEG
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 1
30357: PUSH
30358: LD_INT 4
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 6
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 6
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: LD_INT 5
30394: NEG
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: LIST
30409: LIST
30410: LIST
30411: LIST
30412: LIST
30413: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
30414: LD_ADDR_VAR 0 30
30418: PUSH
30419: LD_INT 2
30421: PUSH
30422: LD_INT 1
30424: NEG
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 3
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 3
30442: PUSH
30443: LD_INT 1
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 3
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 4
30463: PUSH
30464: LD_INT 0
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: PUSH
30471: LD_INT 4
30473: PUSH
30474: LD_INT 1
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 4
30483: PUSH
30484: LD_INT 1
30486: NEG
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 5
30494: PUSH
30495: LD_INT 0
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 5
30504: PUSH
30505: LD_INT 1
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 5
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 6
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 6
30535: PUSH
30536: LD_INT 1
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
30557: LD_ADDR_VAR 0 31
30561: PUSH
30562: LD_INT 3
30564: PUSH
30565: LD_INT 2
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 3
30574: PUSH
30575: LD_INT 3
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: PUSH
30585: LD_INT 3
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 4
30594: PUSH
30595: LD_INT 3
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 4
30604: PUSH
30605: LD_INT 4
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 3
30614: PUSH
30615: LD_INT 4
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 5
30624: PUSH
30625: LD_INT 4
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: PUSH
30632: LD_INT 5
30634: PUSH
30635: LD_INT 5
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 4
30644: PUSH
30645: LD_INT 5
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 6
30654: PUSH
30655: LD_INT 5
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: LD_INT 6
30664: PUSH
30665: LD_INT 6
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 5
30674: PUSH
30675: LD_INT 6
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
30696: LD_ADDR_VAR 0 32
30700: PUSH
30701: LD_INT 1
30703: PUSH
30704: LD_INT 3
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 0
30713: PUSH
30714: LD_INT 3
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: PUSH
30721: LD_INT 1
30723: NEG
30724: PUSH
30725: LD_INT 2
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: LD_INT 4
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: LD_INT 4
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 1
30754: NEG
30755: PUSH
30756: LD_INT 3
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 1
30765: PUSH
30766: LD_INT 5
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 0
30775: PUSH
30776: LD_INT 5
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: LD_INT 4
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 1
30796: PUSH
30797: LD_INT 6
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: LD_INT 6
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: LD_INT 5
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
30839: LD_ADDR_VAR 0 33
30843: PUSH
30844: LD_INT 2
30846: NEG
30847: PUSH
30848: LD_INT 1
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PUSH
30855: LD_INT 3
30857: NEG
30858: PUSH
30859: LD_INT 0
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: PUSH
30866: LD_INT 3
30868: NEG
30869: PUSH
30870: LD_INT 1
30872: NEG
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 3
30880: NEG
30881: PUSH
30882: LD_INT 1
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: PUSH
30889: LD_INT 4
30891: NEG
30892: PUSH
30893: LD_INT 0
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 4
30902: NEG
30903: PUSH
30904: LD_INT 1
30906: NEG
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 4
30914: NEG
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 5
30925: NEG
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 5
30936: NEG
30937: PUSH
30938: LD_INT 1
30940: NEG
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 5
30948: NEG
30949: PUSH
30950: LD_INT 1
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 6
30959: NEG
30960: PUSH
30961: LD_INT 0
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: PUSH
30968: LD_INT 6
30970: NEG
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
30994: LD_ADDR_VAR 0 34
30998: PUSH
30999: LD_INT 2
31001: NEG
31002: PUSH
31003: LD_INT 3
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 3
31013: NEG
31014: PUSH
31015: LD_INT 2
31017: NEG
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 3
31025: NEG
31026: PUSH
31027: LD_INT 3
31029: NEG
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: LD_INT 3
31037: NEG
31038: PUSH
31039: LD_INT 4
31041: NEG
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 4
31049: NEG
31050: PUSH
31051: LD_INT 3
31053: NEG
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 4
31061: NEG
31062: PUSH
31063: LD_INT 4
31065: NEG
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 4
31073: NEG
31074: PUSH
31075: LD_INT 5
31077: NEG
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 5
31085: NEG
31086: PUSH
31087: LD_INT 4
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 5
31097: NEG
31098: PUSH
31099: LD_INT 5
31101: NEG
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 5
31109: NEG
31110: PUSH
31111: LD_INT 6
31113: NEG
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 6
31121: NEG
31122: PUSH
31123: LD_INT 5
31125: NEG
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: LD_INT 6
31133: NEG
31134: PUSH
31135: LD_INT 6
31137: NEG
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
31157: LD_ADDR_VAR 0 41
31161: PUSH
31162: LD_INT 0
31164: PUSH
31165: LD_INT 2
31167: NEG
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 1
31175: NEG
31176: PUSH
31177: LD_INT 3
31179: NEG
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: LIST
31200: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
31201: LD_ADDR_VAR 0 42
31205: PUSH
31206: LD_INT 2
31208: PUSH
31209: LD_INT 0
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: PUSH
31219: LD_INT 1
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 3
31229: PUSH
31230: LD_INT 1
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: LIST
31241: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
31242: LD_ADDR_VAR 0 43
31246: PUSH
31247: LD_INT 2
31249: PUSH
31250: LD_INT 2
31252: PUSH
31253: EMPTY
31254: LIST
31255: LIST
31256: PUSH
31257: LD_INT 3
31259: PUSH
31260: LD_INT 2
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PUSH
31267: LD_INT 2
31269: PUSH
31270: LD_INT 3
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: LIST
31281: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
31282: LD_ADDR_VAR 0 44
31286: PUSH
31287: LD_INT 0
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 3
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 1
31309: NEG
31310: PUSH
31311: LD_INT 2
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: LIST
31322: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31323: LD_ADDR_VAR 0 45
31327: PUSH
31328: LD_INT 2
31330: NEG
31331: PUSH
31332: LD_INT 0
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: LD_INT 2
31341: NEG
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 3
31352: NEG
31353: PUSH
31354: LD_INT 1
31356: NEG
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: LIST
31366: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
31367: LD_ADDR_VAR 0 46
31371: PUSH
31372: LD_INT 2
31374: NEG
31375: PUSH
31376: LD_INT 2
31378: NEG
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: NEG
31387: PUSH
31388: LD_INT 3
31390: NEG
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 3
31398: NEG
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: LIST
31412: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
31413: LD_ADDR_VAR 0 47
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: LD_INT 3
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 1
31432: NEG
31433: PUSH
31434: LD_INT 3
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31446: LD_ADDR_VAR 0 48
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: LD_INT 2
31456: NEG
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 2
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
31477: LD_ADDR_VAR 0 49
31481: PUSH
31482: LD_INT 3
31484: PUSH
31485: LD_INT 1
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 3
31494: PUSH
31495: LD_INT 2
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
31506: LD_ADDR_VAR 0 50
31510: PUSH
31511: LD_INT 2
31513: PUSH
31514: LD_INT 3
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 1
31523: PUSH
31524: LD_INT 3
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31535: LD_ADDR_VAR 0 51
31539: PUSH
31540: LD_INT 1
31542: NEG
31543: PUSH
31544: LD_INT 2
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 2
31553: NEG
31554: PUSH
31555: LD_INT 1
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31566: LD_ADDR_VAR 0 52
31570: PUSH
31571: LD_INT 3
31573: NEG
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: NEG
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31599: LD_ADDR_VAR 0 53
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 3
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 0
31618: PUSH
31619: LD_INT 3
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 1
31629: PUSH
31630: LD_INT 2
31632: NEG
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: LIST
31642: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31643: LD_ADDR_VAR 0 54
31647: PUSH
31648: LD_INT 2
31650: PUSH
31651: LD_INT 1
31653: NEG
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 3
31661: PUSH
31662: LD_INT 0
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 3
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: LIST
31683: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31684: LD_ADDR_VAR 0 55
31688: PUSH
31689: LD_INT 3
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 3
31701: PUSH
31702: LD_INT 3
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 2
31711: PUSH
31712: LD_INT 3
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: LIST
31723: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31724: LD_ADDR_VAR 0 56
31728: PUSH
31729: LD_INT 1
31731: PUSH
31732: LD_INT 3
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 0
31741: PUSH
31742: LD_INT 3
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 1
31751: NEG
31752: PUSH
31753: LD_INT 2
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: EMPTY
31761: LIST
31762: LIST
31763: LIST
31764: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31765: LD_ADDR_VAR 0 57
31769: PUSH
31770: LD_INT 2
31772: NEG
31773: PUSH
31774: LD_INT 1
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 3
31783: NEG
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 3
31794: NEG
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: LIST
31808: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31809: LD_ADDR_VAR 0 58
31813: PUSH
31814: LD_INT 2
31816: NEG
31817: PUSH
31818: LD_INT 3
31820: NEG
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 3
31828: NEG
31829: PUSH
31830: LD_INT 2
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 3
31840: NEG
31841: PUSH
31842: LD_INT 3
31844: NEG
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: LIST
31854: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
31855: LD_ADDR_VAR 0 59
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: LD_INT 2
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: LD_INT 1
31888: NEG
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: LIST
31898: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
31899: LD_ADDR_VAR 0 60
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: LD_INT 0
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 2
31927: PUSH
31928: LD_INT 1
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: LIST
31939: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
31940: LD_ADDR_VAR 0 61
31944: PUSH
31945: LD_INT 2
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 2
31957: PUSH
31958: LD_INT 2
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: PUSH
31968: LD_INT 2
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: LIST
31979: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
31980: LD_ADDR_VAR 0 62
31984: PUSH
31985: LD_INT 1
31987: PUSH
31988: LD_INT 2
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: LD_INT 2
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 1
32007: NEG
32008: PUSH
32009: LD_INT 1
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: LIST
32020: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32021: LD_ADDR_VAR 0 63
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: LD_INT 1
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: LD_INT 0
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: LD_INT 2
32050: NEG
32051: PUSH
32052: LD_INT 1
32054: NEG
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: LIST
32064: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32065: LD_ADDR_VAR 0 64
32069: PUSH
32070: LD_INT 1
32072: NEG
32073: PUSH
32074: LD_INT 2
32076: NEG
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: LD_INT 2
32084: NEG
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 2
32096: NEG
32097: PUSH
32098: LD_INT 2
32100: NEG
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: EMPTY
32107: LIST
32108: LIST
32109: LIST
32110: ST_TO_ADDR
// end ; 2 :
32111: GO 35377
32113: LD_INT 2
32115: DOUBLE
32116: EQUAL
32117: IFTRUE 32121
32119: GO 35376
32121: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
32122: LD_ADDR_VAR 0 29
32126: PUSH
32127: LD_INT 4
32129: PUSH
32130: LD_INT 0
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 4
32139: PUSH
32140: LD_INT 1
32142: NEG
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 5
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 5
32160: PUSH
32161: LD_INT 1
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 4
32170: PUSH
32171: LD_INT 1
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 3
32180: PUSH
32181: LD_INT 0
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 3
32190: PUSH
32191: LD_INT 1
32193: NEG
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 3
32201: PUSH
32202: LD_INT 2
32204: NEG
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 5
32212: PUSH
32213: LD_INT 2
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 3
32222: PUSH
32223: LD_INT 3
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 3
32232: PUSH
32233: LD_INT 2
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 4
32242: PUSH
32243: LD_INT 3
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 4
32252: PUSH
32253: LD_INT 4
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 3
32262: PUSH
32263: LD_INT 4
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 2
32272: PUSH
32273: LD_INT 3
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 2
32282: PUSH
32283: LD_INT 2
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 4
32292: PUSH
32293: LD_INT 2
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 2
32302: PUSH
32303: LD_INT 4
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 4
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: LD_INT 4
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 1
32342: PUSH
32343: LD_INT 5
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 5
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 1
32362: NEG
32363: PUSH
32364: LD_INT 4
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: NEG
32374: PUSH
32375: LD_INT 3
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 2
32384: PUSH
32385: LD_INT 5
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 2
32394: NEG
32395: PUSH
32396: LD_INT 3
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: PUSH
32403: LD_INT 3
32405: NEG
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 3
32416: NEG
32417: PUSH
32418: LD_INT 1
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 2
32428: NEG
32429: PUSH
32430: LD_INT 0
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: NEG
32440: PUSH
32441: LD_INT 1
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 3
32450: NEG
32451: PUSH
32452: LD_INT 1
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 4
32461: NEG
32462: PUSH
32463: LD_INT 0
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 4
32472: NEG
32473: PUSH
32474: LD_INT 1
32476: NEG
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 4
32484: NEG
32485: PUSH
32486: LD_INT 2
32488: NEG
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: LD_INT 2
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 4
32507: NEG
32508: PUSH
32509: LD_INT 4
32511: NEG
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 4
32519: NEG
32520: PUSH
32521: LD_INT 5
32523: NEG
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 3
32531: NEG
32532: PUSH
32533: LD_INT 4
32535: NEG
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 3
32543: NEG
32544: PUSH
32545: LD_INT 3
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 4
32555: NEG
32556: PUSH
32557: LD_INT 3
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 5
32567: NEG
32568: PUSH
32569: LD_INT 4
32571: NEG
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 5
32579: NEG
32580: PUSH
32581: LD_INT 5
32583: NEG
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 3
32591: NEG
32592: PUSH
32593: LD_INT 5
32595: NEG
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 5
32603: NEG
32604: PUSH
32605: LD_INT 3
32607: NEG
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
32660: LD_ADDR_VAR 0 30
32664: PUSH
32665: LD_INT 4
32667: PUSH
32668: LD_INT 4
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 4
32677: PUSH
32678: LD_INT 3
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 5
32687: PUSH
32688: LD_INT 4
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 5
32697: PUSH
32698: LD_INT 5
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 4
32707: PUSH
32708: LD_INT 5
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 3
32717: PUSH
32718: LD_INT 4
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 3
32727: PUSH
32728: LD_INT 3
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 5
32737: PUSH
32738: LD_INT 3
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 3
32747: PUSH
32748: LD_INT 5
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: LD_INT 3
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 3
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 1
32787: PUSH
32788: LD_INT 4
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 0
32797: PUSH
32798: LD_INT 4
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 1
32807: NEG
32808: PUSH
32809: LD_INT 3
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: LD_INT 2
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 2
32829: PUSH
32830: LD_INT 4
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: LD_INT 2
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 4
32850: NEG
32851: PUSH
32852: LD_INT 0
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 4
32861: NEG
32862: PUSH
32863: LD_INT 1
32865: NEG
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 3
32873: NEG
32874: PUSH
32875: LD_INT 0
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 3
32884: NEG
32885: PUSH
32886: LD_INT 1
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: LD_INT 4
32895: NEG
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 5
32906: NEG
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: PUSH
32915: LD_INT 5
32917: NEG
32918: PUSH
32919: LD_INT 1
32921: NEG
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 5
32929: NEG
32930: PUSH
32931: LD_INT 2
32933: NEG
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 3
32941: NEG
32942: PUSH
32943: LD_INT 2
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 3
32952: NEG
32953: PUSH
32954: LD_INT 3
32956: NEG
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 3
32964: NEG
32965: PUSH
32966: LD_INT 4
32968: NEG
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 2
32976: NEG
32977: PUSH
32978: LD_INT 3
32980: NEG
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 2
32988: NEG
32989: PUSH
32990: LD_INT 2
32992: NEG
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 3
33000: NEG
33001: PUSH
33002: LD_INT 2
33004: NEG
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 4
33012: NEG
33013: PUSH
33014: LD_INT 3
33016: NEG
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 4
33024: NEG
33025: PUSH
33026: LD_INT 4
33028: NEG
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 2
33036: NEG
33037: PUSH
33038: LD_INT 4
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 4
33048: NEG
33049: PUSH
33050: LD_INT 2
33052: NEG
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 0
33060: PUSH
33061: LD_INT 4
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 5
33074: NEG
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 1
33082: PUSH
33083: LD_INT 4
33085: NEG
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: LD_INT 3
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 0
33104: PUSH
33105: LD_INT 3
33107: NEG
33108: PUSH
33109: EMPTY
33110: LIST
33111: LIST
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: LD_INT 4
33119: NEG
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: LD_INT 5
33131: NEG
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 2
33139: PUSH
33140: LD_INT 3
33142: NEG
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 2
33150: NEG
33151: PUSH
33152: LD_INT 5
33154: NEG
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: LIST
33180: LIST
33181: LIST
33182: LIST
33183: LIST
33184: LIST
33185: LIST
33186: LIST
33187: LIST
33188: LIST
33189: LIST
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
33207: LD_ADDR_VAR 0 31
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: LD_INT 4
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: LD_INT 3
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: LD_INT 1
33234: PUSH
33235: LD_INT 4
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 1
33244: PUSH
33245: LD_INT 5
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 0
33254: PUSH
33255: LD_INT 5
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 1
33264: NEG
33265: PUSH
33266: LD_INT 4
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: NEG
33276: PUSH
33277: LD_INT 3
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: LD_INT 5
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 2
33296: NEG
33297: PUSH
33298: LD_INT 3
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 3
33307: NEG
33308: PUSH
33309: LD_INT 0
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 3
33318: NEG
33319: PUSH
33320: LD_INT 1
33322: NEG
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 2
33330: NEG
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 2
33341: NEG
33342: PUSH
33343: LD_INT 1
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PUSH
33350: LD_INT 3
33352: NEG
33353: PUSH
33354: LD_INT 1
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 4
33363: NEG
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 4
33374: NEG
33375: PUSH
33376: LD_INT 1
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 4
33386: NEG
33387: PUSH
33388: LD_INT 2
33390: NEG
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 2
33398: NEG
33399: PUSH
33400: LD_INT 2
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 4
33409: NEG
33410: PUSH
33411: LD_INT 4
33413: NEG
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 4
33421: NEG
33422: PUSH
33423: LD_INT 5
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 3
33433: NEG
33434: PUSH
33435: LD_INT 4
33437: NEG
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 3
33445: NEG
33446: PUSH
33447: LD_INT 3
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 4
33457: NEG
33458: PUSH
33459: LD_INT 3
33461: NEG
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 5
33469: NEG
33470: PUSH
33471: LD_INT 4
33473: NEG
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 5
33481: NEG
33482: PUSH
33483: LD_INT 5
33485: NEG
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: LD_INT 3
33493: NEG
33494: PUSH
33495: LD_INT 5
33497: NEG
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 5
33505: NEG
33506: PUSH
33507: LD_INT 3
33509: NEG
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: LD_INT 3
33520: NEG
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 4
33531: NEG
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 1
33539: PUSH
33540: LD_INT 3
33542: NEG
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 1
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 0
33561: PUSH
33562: LD_INT 2
33564: NEG
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 3
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: NEG
33585: PUSH
33586: LD_INT 4
33588: NEG
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 2
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 2
33607: NEG
33608: PUSH
33609: LD_INT 4
33611: NEG
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 4
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 4
33629: PUSH
33630: LD_INT 1
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 5
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 5
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 4
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 3
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 3
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 3
33691: PUSH
33692: LD_INT 2
33694: NEG
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 5
33702: PUSH
33703: LD_INT 2
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
33757: LD_ADDR_VAR 0 32
33761: PUSH
33762: LD_INT 4
33764: NEG
33765: PUSH
33766: LD_INT 0
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 4
33775: NEG
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 3
33787: NEG
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 3
33798: NEG
33799: PUSH
33800: LD_INT 1
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 4
33809: NEG
33810: PUSH
33811: LD_INT 1
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 5
33820: NEG
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 5
33831: NEG
33832: PUSH
33833: LD_INT 1
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 5
33843: NEG
33844: PUSH
33845: LD_INT 2
33847: NEG
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 3
33855: NEG
33856: PUSH
33857: LD_INT 2
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 3
33866: NEG
33867: PUSH
33868: LD_INT 3
33870: NEG
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 3
33878: NEG
33879: PUSH
33880: LD_INT 4
33882: NEG
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 2
33890: NEG
33891: PUSH
33892: LD_INT 3
33894: NEG
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: LD_INT 2
33906: NEG
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 3
33914: NEG
33915: PUSH
33916: LD_INT 2
33918: NEG
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 4
33926: NEG
33927: PUSH
33928: LD_INT 3
33930: NEG
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 4
33938: NEG
33939: PUSH
33940: LD_INT 4
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 2
33950: NEG
33951: PUSH
33952: LD_INT 4
33954: NEG
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 4
33962: NEG
33963: PUSH
33964: LD_INT 2
33966: NEG
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 0
33974: PUSH
33975: LD_INT 4
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 5
33988: NEG
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: LD_INT 4
33999: NEG
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 1
34007: PUSH
34008: LD_INT 3
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 0
34018: PUSH
34019: LD_INT 3
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: NEG
34030: PUSH
34031: LD_INT 4
34033: NEG
34034: PUSH
34035: EMPTY
34036: LIST
34037: LIST
34038: PUSH
34039: LD_INT 1
34041: NEG
34042: PUSH
34043: LD_INT 5
34045: NEG
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 2
34053: PUSH
34054: LD_INT 3
34056: NEG
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 2
34064: NEG
34065: PUSH
34066: LD_INT 5
34068: NEG
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 3
34076: PUSH
34077: LD_INT 0
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 3
34086: PUSH
34087: LD_INT 1
34089: NEG
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 4
34097: PUSH
34098: LD_INT 0
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 4
34107: PUSH
34108: LD_INT 1
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: PUSH
34115: LD_INT 3
34117: PUSH
34118: LD_INT 1
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 2
34127: PUSH
34128: LD_INT 0
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PUSH
34135: LD_INT 2
34137: PUSH
34138: LD_INT 1
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 4
34159: PUSH
34160: LD_INT 2
34162: PUSH
34163: EMPTY
34164: LIST
34165: LIST
34166: PUSH
34167: LD_INT 4
34169: PUSH
34170: LD_INT 4
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 4
34179: PUSH
34180: LD_INT 3
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 5
34189: PUSH
34190: LD_INT 4
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 5
34199: PUSH
34200: LD_INT 5
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 4
34209: PUSH
34210: LD_INT 5
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 4
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 3
34229: PUSH
34230: LD_INT 3
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 5
34239: PUSH
34240: LD_INT 3
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 3
34249: PUSH
34250: LD_INT 5
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: LIST
34287: LIST
34288: LIST
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: LIST
34297: LIST
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
34304: LD_ADDR_VAR 0 33
34308: PUSH
34309: LD_INT 4
34311: NEG
34312: PUSH
34313: LD_INT 4
34315: NEG
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 4
34323: NEG
34324: PUSH
34325: LD_INT 5
34327: NEG
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 3
34335: NEG
34336: PUSH
34337: LD_INT 4
34339: NEG
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 3
34347: NEG
34348: PUSH
34349: LD_INT 3
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 4
34359: NEG
34360: PUSH
34361: LD_INT 3
34363: NEG
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 5
34371: NEG
34372: PUSH
34373: LD_INT 4
34375: NEG
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 5
34383: NEG
34384: PUSH
34385: LD_INT 5
34387: NEG
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 3
34395: NEG
34396: PUSH
34397: LD_INT 5
34399: NEG
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 5
34407: NEG
34408: PUSH
34409: LD_INT 3
34411: NEG
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 0
34419: PUSH
34420: LD_INT 3
34422: NEG
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 0
34430: PUSH
34431: LD_INT 4
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: PUSH
34442: LD_INT 3
34444: NEG
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: LD_INT 2
34455: NEG
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 0
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 3
34478: NEG
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: NEG
34487: PUSH
34488: LD_INT 4
34490: NEG
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 2
34498: PUSH
34499: LD_INT 2
34501: NEG
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: NEG
34510: PUSH
34511: LD_INT 4
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 4
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 4
34531: PUSH
34532: LD_INT 1
34534: NEG
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 5
34542: PUSH
34543: LD_INT 0
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 5
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 4
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 3
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 3
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 3
34593: PUSH
34594: LD_INT 2
34596: NEG
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 5
34604: PUSH
34605: LD_INT 2
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 3
34614: PUSH
34615: LD_INT 3
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 3
34624: PUSH
34625: LD_INT 2
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 4
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 4
34644: PUSH
34645: LD_INT 4
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 3
34654: PUSH
34655: LD_INT 4
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 2
34664: PUSH
34665: LD_INT 3
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 4
34684: PUSH
34685: LD_INT 2
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: PUSH
34695: LD_INT 4
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 4
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 3
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: LD_INT 4
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 1
34734: PUSH
34735: LD_INT 5
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 5
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: NEG
34755: PUSH
34756: LD_INT 4
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: NEG
34766: PUSH
34767: LD_INT 3
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 2
34776: PUSH
34777: LD_INT 5
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 2
34786: NEG
34787: PUSH
34788: LD_INT 3
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
34842: LD_ADDR_VAR 0 34
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: LD_INT 4
34852: NEG
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 0
34860: PUSH
34861: LD_INT 5
34863: NEG
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 1
34871: PUSH
34872: LD_INT 4
34874: NEG
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: PUSH
34883: LD_INT 3
34885: NEG
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: PUSH
34891: LD_INT 0
34893: PUSH
34894: LD_INT 3
34896: NEG
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 1
34904: NEG
34905: PUSH
34906: LD_INT 4
34908: NEG
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: LD_INT 5
34920: NEG
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 2
34928: PUSH
34929: LD_INT 3
34931: NEG
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 2
34939: NEG
34940: PUSH
34941: LD_INT 5
34943: NEG
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 3
34951: PUSH
34952: LD_INT 0
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 3
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 4
34972: PUSH
34973: LD_INT 0
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 4
34982: PUSH
34983: LD_INT 1
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 3
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 2
35002: PUSH
35003: LD_INT 0
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: PUSH
35013: LD_INT 1
35015: NEG
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 2
35023: PUSH
35024: LD_INT 2
35026: NEG
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 4
35034: PUSH
35035: LD_INT 2
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 4
35044: PUSH
35045: LD_INT 4
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 4
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 5
35064: PUSH
35065: LD_INT 4
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 5
35074: PUSH
35075: LD_INT 5
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 4
35084: PUSH
35085: LD_INT 5
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 3
35094: PUSH
35095: LD_INT 4
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 3
35104: PUSH
35105: LD_INT 3
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 5
35114: PUSH
35115: LD_INT 3
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 3
35124: PUSH
35125: LD_INT 5
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 0
35134: PUSH
35135: LD_INT 3
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: LD_INT 2
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: PUSH
35155: LD_INT 3
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 1
35164: PUSH
35165: LD_INT 4
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: LD_INT 4
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 1
35184: NEG
35185: PUSH
35186: LD_INT 3
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: LD_INT 2
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 2
35206: PUSH
35207: LD_INT 4
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 2
35216: NEG
35217: PUSH
35218: LD_INT 2
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 4
35227: NEG
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 4
35238: NEG
35239: PUSH
35240: LD_INT 1
35242: NEG
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 3
35250: NEG
35251: PUSH
35252: LD_INT 0
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: PUSH
35259: LD_INT 3
35261: NEG
35262: PUSH
35263: LD_INT 1
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 4
35272: NEG
35273: PUSH
35274: LD_INT 1
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 5
35283: NEG
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 5
35294: NEG
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 5
35306: NEG
35307: PUSH
35308: LD_INT 2
35310: NEG
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 3
35318: NEG
35319: PUSH
35320: LD_INT 2
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: LIST
35363: LIST
35364: LIST
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: ST_TO_ADDR
// end ; end ;
35374: GO 35377
35376: POP
// case btype of b_depot , b_warehouse :
35377: LD_VAR 0 1
35381: PUSH
35382: LD_INT 0
35384: DOUBLE
35385: EQUAL
35386: IFTRUE 35396
35388: LD_INT 1
35390: DOUBLE
35391: EQUAL
35392: IFTRUE 35396
35394: GO 35597
35396: POP
// case nation of nation_american :
35397: LD_VAR 0 5
35401: PUSH
35402: LD_INT 1
35404: DOUBLE
35405: EQUAL
35406: IFTRUE 35410
35408: GO 35466
35410: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
35411: LD_ADDR_VAR 0 9
35415: PUSH
35416: LD_VAR 0 11
35420: PUSH
35421: LD_VAR 0 12
35425: PUSH
35426: LD_VAR 0 13
35430: PUSH
35431: LD_VAR 0 14
35435: PUSH
35436: LD_VAR 0 15
35440: PUSH
35441: LD_VAR 0 16
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: PUSH
35454: LD_VAR 0 4
35458: PUSH
35459: LD_INT 1
35461: PLUS
35462: ARRAY
35463: ST_TO_ADDR
35464: GO 35595
35466: LD_INT 2
35468: DOUBLE
35469: EQUAL
35470: IFTRUE 35474
35472: GO 35530
35474: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
35475: LD_ADDR_VAR 0 9
35479: PUSH
35480: LD_VAR 0 17
35484: PUSH
35485: LD_VAR 0 18
35489: PUSH
35490: LD_VAR 0 19
35494: PUSH
35495: LD_VAR 0 20
35499: PUSH
35500: LD_VAR 0 21
35504: PUSH
35505: LD_VAR 0 22
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: PUSH
35518: LD_VAR 0 4
35522: PUSH
35523: LD_INT 1
35525: PLUS
35526: ARRAY
35527: ST_TO_ADDR
35528: GO 35595
35530: LD_INT 3
35532: DOUBLE
35533: EQUAL
35534: IFTRUE 35538
35536: GO 35594
35538: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
35539: LD_ADDR_VAR 0 9
35543: PUSH
35544: LD_VAR 0 23
35548: PUSH
35549: LD_VAR 0 24
35553: PUSH
35554: LD_VAR 0 25
35558: PUSH
35559: LD_VAR 0 26
35563: PUSH
35564: LD_VAR 0 27
35568: PUSH
35569: LD_VAR 0 28
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: PUSH
35582: LD_VAR 0 4
35586: PUSH
35587: LD_INT 1
35589: PLUS
35590: ARRAY
35591: ST_TO_ADDR
35592: GO 35595
35594: POP
35595: GO 36150
35597: LD_INT 2
35599: DOUBLE
35600: EQUAL
35601: IFTRUE 35611
35603: LD_INT 3
35605: DOUBLE
35606: EQUAL
35607: IFTRUE 35611
35609: GO 35667
35611: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
35612: LD_ADDR_VAR 0 9
35616: PUSH
35617: LD_VAR 0 29
35621: PUSH
35622: LD_VAR 0 30
35626: PUSH
35627: LD_VAR 0 31
35631: PUSH
35632: LD_VAR 0 32
35636: PUSH
35637: LD_VAR 0 33
35641: PUSH
35642: LD_VAR 0 34
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: PUSH
35655: LD_VAR 0 4
35659: PUSH
35660: LD_INT 1
35662: PLUS
35663: ARRAY
35664: ST_TO_ADDR
35665: GO 36150
35667: LD_INT 16
35669: DOUBLE
35670: EQUAL
35671: IFTRUE 35729
35673: LD_INT 17
35675: DOUBLE
35676: EQUAL
35677: IFTRUE 35729
35679: LD_INT 18
35681: DOUBLE
35682: EQUAL
35683: IFTRUE 35729
35685: LD_INT 19
35687: DOUBLE
35688: EQUAL
35689: IFTRUE 35729
35691: LD_INT 22
35693: DOUBLE
35694: EQUAL
35695: IFTRUE 35729
35697: LD_INT 20
35699: DOUBLE
35700: EQUAL
35701: IFTRUE 35729
35703: LD_INT 21
35705: DOUBLE
35706: EQUAL
35707: IFTRUE 35729
35709: LD_INT 23
35711: DOUBLE
35712: EQUAL
35713: IFTRUE 35729
35715: LD_INT 24
35717: DOUBLE
35718: EQUAL
35719: IFTRUE 35729
35721: LD_INT 25
35723: DOUBLE
35724: EQUAL
35725: IFTRUE 35729
35727: GO 35785
35729: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
35730: LD_ADDR_VAR 0 9
35734: PUSH
35735: LD_VAR 0 35
35739: PUSH
35740: LD_VAR 0 36
35744: PUSH
35745: LD_VAR 0 37
35749: PUSH
35750: LD_VAR 0 38
35754: PUSH
35755: LD_VAR 0 39
35759: PUSH
35760: LD_VAR 0 40
35764: PUSH
35765: EMPTY
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: PUSH
35773: LD_VAR 0 4
35777: PUSH
35778: LD_INT 1
35780: PLUS
35781: ARRAY
35782: ST_TO_ADDR
35783: GO 36150
35785: LD_INT 6
35787: DOUBLE
35788: EQUAL
35789: IFTRUE 35841
35791: LD_INT 7
35793: DOUBLE
35794: EQUAL
35795: IFTRUE 35841
35797: LD_INT 8
35799: DOUBLE
35800: EQUAL
35801: IFTRUE 35841
35803: LD_INT 13
35805: DOUBLE
35806: EQUAL
35807: IFTRUE 35841
35809: LD_INT 12
35811: DOUBLE
35812: EQUAL
35813: IFTRUE 35841
35815: LD_INT 15
35817: DOUBLE
35818: EQUAL
35819: IFTRUE 35841
35821: LD_INT 11
35823: DOUBLE
35824: EQUAL
35825: IFTRUE 35841
35827: LD_INT 14
35829: DOUBLE
35830: EQUAL
35831: IFTRUE 35841
35833: LD_INT 10
35835: DOUBLE
35836: EQUAL
35837: IFTRUE 35841
35839: GO 35897
35841: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
35842: LD_ADDR_VAR 0 9
35846: PUSH
35847: LD_VAR 0 41
35851: PUSH
35852: LD_VAR 0 42
35856: PUSH
35857: LD_VAR 0 43
35861: PUSH
35862: LD_VAR 0 44
35866: PUSH
35867: LD_VAR 0 45
35871: PUSH
35872: LD_VAR 0 46
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: LIST
35881: LIST
35882: LIST
35883: LIST
35884: PUSH
35885: LD_VAR 0 4
35889: PUSH
35890: LD_INT 1
35892: PLUS
35893: ARRAY
35894: ST_TO_ADDR
35895: GO 36150
35897: LD_INT 36
35899: DOUBLE
35900: EQUAL
35901: IFTRUE 35905
35903: GO 35961
35905: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
35906: LD_ADDR_VAR 0 9
35910: PUSH
35911: LD_VAR 0 47
35915: PUSH
35916: LD_VAR 0 48
35920: PUSH
35921: LD_VAR 0 49
35925: PUSH
35926: LD_VAR 0 50
35930: PUSH
35931: LD_VAR 0 51
35935: PUSH
35936: LD_VAR 0 52
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: LIST
35945: LIST
35946: LIST
35947: LIST
35948: PUSH
35949: LD_VAR 0 4
35953: PUSH
35954: LD_INT 1
35956: PLUS
35957: ARRAY
35958: ST_TO_ADDR
35959: GO 36150
35961: LD_INT 4
35963: DOUBLE
35964: EQUAL
35965: IFTRUE 35987
35967: LD_INT 5
35969: DOUBLE
35970: EQUAL
35971: IFTRUE 35987
35973: LD_INT 34
35975: DOUBLE
35976: EQUAL
35977: IFTRUE 35987
35979: LD_INT 37
35981: DOUBLE
35982: EQUAL
35983: IFTRUE 35987
35985: GO 36043
35987: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
35988: LD_ADDR_VAR 0 9
35992: PUSH
35993: LD_VAR 0 53
35997: PUSH
35998: LD_VAR 0 54
36002: PUSH
36003: LD_VAR 0 55
36007: PUSH
36008: LD_VAR 0 56
36012: PUSH
36013: LD_VAR 0 57
36017: PUSH
36018: LD_VAR 0 58
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: LIST
36027: LIST
36028: LIST
36029: LIST
36030: PUSH
36031: LD_VAR 0 4
36035: PUSH
36036: LD_INT 1
36038: PLUS
36039: ARRAY
36040: ST_TO_ADDR
36041: GO 36150
36043: LD_INT 31
36045: DOUBLE
36046: EQUAL
36047: IFTRUE 36093
36049: LD_INT 32
36051: DOUBLE
36052: EQUAL
36053: IFTRUE 36093
36055: LD_INT 33
36057: DOUBLE
36058: EQUAL
36059: IFTRUE 36093
36061: LD_INT 27
36063: DOUBLE
36064: EQUAL
36065: IFTRUE 36093
36067: LD_INT 26
36069: DOUBLE
36070: EQUAL
36071: IFTRUE 36093
36073: LD_INT 28
36075: DOUBLE
36076: EQUAL
36077: IFTRUE 36093
36079: LD_INT 29
36081: DOUBLE
36082: EQUAL
36083: IFTRUE 36093
36085: LD_INT 30
36087: DOUBLE
36088: EQUAL
36089: IFTRUE 36093
36091: GO 36149
36093: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
36094: LD_ADDR_VAR 0 9
36098: PUSH
36099: LD_VAR 0 59
36103: PUSH
36104: LD_VAR 0 60
36108: PUSH
36109: LD_VAR 0 61
36113: PUSH
36114: LD_VAR 0 62
36118: PUSH
36119: LD_VAR 0 63
36123: PUSH
36124: LD_VAR 0 64
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: PUSH
36137: LD_VAR 0 4
36141: PUSH
36142: LD_INT 1
36144: PLUS
36145: ARRAY
36146: ST_TO_ADDR
36147: GO 36150
36149: POP
// temp_list2 = [ ] ;
36150: LD_ADDR_VAR 0 10
36154: PUSH
36155: EMPTY
36156: ST_TO_ADDR
// for i in temp_list do
36157: LD_ADDR_VAR 0 8
36161: PUSH
36162: LD_VAR 0 9
36166: PUSH
36167: FOR_IN
36168: IFFALSE 36220
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
36170: LD_ADDR_VAR 0 10
36174: PUSH
36175: LD_VAR 0 10
36179: PUSH
36180: LD_VAR 0 8
36184: PUSH
36185: LD_INT 1
36187: ARRAY
36188: PUSH
36189: LD_VAR 0 2
36193: PLUS
36194: PUSH
36195: LD_VAR 0 8
36199: PUSH
36200: LD_INT 2
36202: ARRAY
36203: PUSH
36204: LD_VAR 0 3
36208: PLUS
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: EMPTY
36215: LIST
36216: ADD
36217: ST_TO_ADDR
36218: GO 36167
36220: POP
36221: POP
// result = temp_list2 ;
36222: LD_ADDR_VAR 0 7
36226: PUSH
36227: LD_VAR 0 10
36231: ST_TO_ADDR
// end ;
36232: LD_VAR 0 7
36236: RET
// export function EnemyInRange ( unit , dist ) ; begin
36237: LD_INT 0
36239: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
36240: LD_ADDR_VAR 0 3
36244: PUSH
36245: LD_VAR 0 1
36249: PPUSH
36250: CALL_OW 255
36254: PPUSH
36255: LD_VAR 0 1
36259: PPUSH
36260: CALL_OW 250
36264: PPUSH
36265: LD_VAR 0 1
36269: PPUSH
36270: CALL_OW 251
36274: PPUSH
36275: LD_VAR 0 2
36279: PPUSH
36280: CALL 10341 0 4
36284: PUSH
36285: LD_INT 4
36287: ARRAY
36288: ST_TO_ADDR
// end ;
36289: LD_VAR 0 3
36293: RET
// export function PlayerSeeMe ( unit ) ; begin
36294: LD_INT 0
36296: PPUSH
// result := See ( your_side , unit ) ;
36297: LD_ADDR_VAR 0 2
36301: PUSH
36302: LD_OWVAR 2
36306: PPUSH
36307: LD_VAR 0 1
36311: PPUSH
36312: CALL_OW 292
36316: ST_TO_ADDR
// end ;
36317: LD_VAR 0 2
36321: RET
// export function ReverseDir ( unit ) ; begin
36322: LD_INT 0
36324: PPUSH
// if not unit then
36325: LD_VAR 0 1
36329: NOT
36330: IFFALSE 36334
// exit ;
36332: GO 36357
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
36334: LD_ADDR_VAR 0 2
36338: PUSH
36339: LD_VAR 0 1
36343: PPUSH
36344: CALL_OW 254
36348: PUSH
36349: LD_INT 3
36351: PLUS
36352: PUSH
36353: LD_INT 6
36355: MOD
36356: ST_TO_ADDR
// end ;
36357: LD_VAR 0 2
36361: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
36362: LD_INT 0
36364: PPUSH
36365: PPUSH
36366: PPUSH
36367: PPUSH
36368: PPUSH
// if not hexes then
36369: LD_VAR 0 2
36373: NOT
36374: IFFALSE 36378
// exit ;
36376: GO 36526
// dist := 9999 ;
36378: LD_ADDR_VAR 0 5
36382: PUSH
36383: LD_INT 9999
36385: ST_TO_ADDR
// for i = 1 to hexes do
36386: LD_ADDR_VAR 0 4
36390: PUSH
36391: DOUBLE
36392: LD_INT 1
36394: DEC
36395: ST_TO_ADDR
36396: LD_VAR 0 2
36400: PUSH
36401: FOR_TO
36402: IFFALSE 36514
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
36404: LD_VAR 0 1
36408: PPUSH
36409: LD_VAR 0 2
36413: PUSH
36414: LD_VAR 0 4
36418: ARRAY
36419: PUSH
36420: LD_INT 1
36422: ARRAY
36423: PPUSH
36424: LD_VAR 0 2
36428: PUSH
36429: LD_VAR 0 4
36433: ARRAY
36434: PUSH
36435: LD_INT 2
36437: ARRAY
36438: PPUSH
36439: CALL_OW 297
36443: PUSH
36444: LD_VAR 0 5
36448: LESS
36449: IFFALSE 36512
// begin hex := hexes [ i ] ;
36451: LD_ADDR_VAR 0 7
36455: PUSH
36456: LD_VAR 0 2
36460: PUSH
36461: LD_VAR 0 4
36465: ARRAY
36466: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
36467: LD_ADDR_VAR 0 5
36471: PUSH
36472: LD_VAR 0 1
36476: PPUSH
36477: LD_VAR 0 2
36481: PUSH
36482: LD_VAR 0 4
36486: ARRAY
36487: PUSH
36488: LD_INT 1
36490: ARRAY
36491: PPUSH
36492: LD_VAR 0 2
36496: PUSH
36497: LD_VAR 0 4
36501: ARRAY
36502: PUSH
36503: LD_INT 2
36505: ARRAY
36506: PPUSH
36507: CALL_OW 297
36511: ST_TO_ADDR
// end ; end ;
36512: GO 36401
36514: POP
36515: POP
// result := hex ;
36516: LD_ADDR_VAR 0 3
36520: PUSH
36521: LD_VAR 0 7
36525: ST_TO_ADDR
// end ;
36526: LD_VAR 0 3
36530: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
36531: LD_INT 0
36533: PPUSH
36534: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
36535: LD_VAR 0 1
36539: NOT
36540: PUSH
36541: LD_VAR 0 1
36545: PUSH
36546: LD_INT 21
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 23
36558: PUSH
36559: LD_INT 2
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PPUSH
36570: CALL_OW 69
36574: IN
36575: NOT
36576: OR
36577: IFFALSE 36581
// exit ;
36579: GO 36628
// for i = 1 to 3 do
36581: LD_ADDR_VAR 0 3
36585: PUSH
36586: DOUBLE
36587: LD_INT 1
36589: DEC
36590: ST_TO_ADDR
36591: LD_INT 3
36593: PUSH
36594: FOR_TO
36595: IFFALSE 36626
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
36597: LD_VAR 0 1
36601: PPUSH
36602: CALL_OW 250
36606: PPUSH
36607: LD_VAR 0 1
36611: PPUSH
36612: CALL_OW 251
36616: PPUSH
36617: LD_INT 1
36619: PPUSH
36620: CALL_OW 453
36624: GO 36594
36626: POP
36627: POP
// end ;
36628: LD_VAR 0 2
36632: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
36633: LD_INT 0
36635: PPUSH
36636: PPUSH
36637: PPUSH
36638: PPUSH
36639: PPUSH
36640: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
36641: LD_VAR 0 1
36645: NOT
36646: PUSH
36647: LD_VAR 0 2
36651: NOT
36652: OR
36653: PUSH
36654: LD_VAR 0 1
36658: PPUSH
36659: CALL_OW 314
36663: OR
36664: IFFALSE 36668
// exit ;
36666: GO 37109
// x := GetX ( enemy_unit ) ;
36668: LD_ADDR_VAR 0 7
36672: PUSH
36673: LD_VAR 0 2
36677: PPUSH
36678: CALL_OW 250
36682: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
36683: LD_ADDR_VAR 0 8
36687: PUSH
36688: LD_VAR 0 2
36692: PPUSH
36693: CALL_OW 251
36697: ST_TO_ADDR
// if not x or not y then
36698: LD_VAR 0 7
36702: NOT
36703: PUSH
36704: LD_VAR 0 8
36708: NOT
36709: OR
36710: IFFALSE 36714
// exit ;
36712: GO 37109
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
36714: LD_ADDR_VAR 0 6
36718: PUSH
36719: LD_VAR 0 7
36723: PPUSH
36724: LD_INT 0
36726: PPUSH
36727: LD_INT 4
36729: PPUSH
36730: CALL_OW 272
36734: PUSH
36735: LD_VAR 0 8
36739: PPUSH
36740: LD_INT 0
36742: PPUSH
36743: LD_INT 4
36745: PPUSH
36746: CALL_OW 273
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_VAR 0 7
36759: PPUSH
36760: LD_INT 1
36762: PPUSH
36763: LD_INT 4
36765: PPUSH
36766: CALL_OW 272
36770: PUSH
36771: LD_VAR 0 8
36775: PPUSH
36776: LD_INT 1
36778: PPUSH
36779: LD_INT 4
36781: PPUSH
36782: CALL_OW 273
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_VAR 0 7
36795: PPUSH
36796: LD_INT 2
36798: PPUSH
36799: LD_INT 4
36801: PPUSH
36802: CALL_OW 272
36806: PUSH
36807: LD_VAR 0 8
36811: PPUSH
36812: LD_INT 2
36814: PPUSH
36815: LD_INT 4
36817: PPUSH
36818: CALL_OW 273
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_VAR 0 7
36831: PPUSH
36832: LD_INT 3
36834: PPUSH
36835: LD_INT 4
36837: PPUSH
36838: CALL_OW 272
36842: PUSH
36843: LD_VAR 0 8
36847: PPUSH
36848: LD_INT 3
36850: PPUSH
36851: LD_INT 4
36853: PPUSH
36854: CALL_OW 273
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_VAR 0 7
36867: PPUSH
36868: LD_INT 4
36870: PPUSH
36871: LD_INT 4
36873: PPUSH
36874: CALL_OW 272
36878: PUSH
36879: LD_VAR 0 8
36883: PPUSH
36884: LD_INT 4
36886: PPUSH
36887: LD_INT 4
36889: PPUSH
36890: CALL_OW 273
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_VAR 0 7
36903: PPUSH
36904: LD_INT 5
36906: PPUSH
36907: LD_INT 4
36909: PPUSH
36910: CALL_OW 272
36914: PUSH
36915: LD_VAR 0 8
36919: PPUSH
36920: LD_INT 5
36922: PPUSH
36923: LD_INT 4
36925: PPUSH
36926: CALL_OW 273
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: ST_TO_ADDR
// for i = tmp downto 1 do
36943: LD_ADDR_VAR 0 4
36947: PUSH
36948: DOUBLE
36949: LD_VAR 0 6
36953: INC
36954: ST_TO_ADDR
36955: LD_INT 1
36957: PUSH
36958: FOR_DOWNTO
36959: IFFALSE 37060
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
36961: LD_VAR 0 6
36965: PUSH
36966: LD_VAR 0 4
36970: ARRAY
36971: PUSH
36972: LD_INT 1
36974: ARRAY
36975: PPUSH
36976: LD_VAR 0 6
36980: PUSH
36981: LD_VAR 0 4
36985: ARRAY
36986: PUSH
36987: LD_INT 2
36989: ARRAY
36990: PPUSH
36991: CALL_OW 488
36995: NOT
36996: PUSH
36997: LD_VAR 0 6
37001: PUSH
37002: LD_VAR 0 4
37006: ARRAY
37007: PUSH
37008: LD_INT 1
37010: ARRAY
37011: PPUSH
37012: LD_VAR 0 6
37016: PUSH
37017: LD_VAR 0 4
37021: ARRAY
37022: PUSH
37023: LD_INT 2
37025: ARRAY
37026: PPUSH
37027: CALL_OW 428
37031: PUSH
37032: LD_INT 0
37034: NONEQUAL
37035: OR
37036: IFFALSE 37058
// tmp := Delete ( tmp , i ) ;
37038: LD_ADDR_VAR 0 6
37042: PUSH
37043: LD_VAR 0 6
37047: PPUSH
37048: LD_VAR 0 4
37052: PPUSH
37053: CALL_OW 3
37057: ST_TO_ADDR
37058: GO 36958
37060: POP
37061: POP
// j := GetClosestHex ( unit , tmp ) ;
37062: LD_ADDR_VAR 0 5
37066: PUSH
37067: LD_VAR 0 1
37071: PPUSH
37072: LD_VAR 0 6
37076: PPUSH
37077: CALL 36362 0 2
37081: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
37082: LD_VAR 0 1
37086: PPUSH
37087: LD_VAR 0 5
37091: PUSH
37092: LD_INT 1
37094: ARRAY
37095: PPUSH
37096: LD_VAR 0 5
37100: PUSH
37101: LD_INT 2
37103: ARRAY
37104: PPUSH
37105: CALL_OW 111
// end ;
37109: LD_VAR 0 3
37113: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
37114: LD_INT 0
37116: PPUSH
37117: PPUSH
37118: PPUSH
// uc_side = 0 ;
37119: LD_ADDR_OWVAR 20
37123: PUSH
37124: LD_INT 0
37126: ST_TO_ADDR
// uc_nation = 0 ;
37127: LD_ADDR_OWVAR 21
37131: PUSH
37132: LD_INT 0
37134: ST_TO_ADDR
// InitHc ;
37135: CALL_OW 19
// InitVc ;
37139: CALL_OW 20
// if mastodonts then
37143: LD_VAR 0 6
37147: IFFALSE 37214
// for i = 1 to mastodonts do
37149: LD_ADDR_VAR 0 11
37153: PUSH
37154: DOUBLE
37155: LD_INT 1
37157: DEC
37158: ST_TO_ADDR
37159: LD_VAR 0 6
37163: PUSH
37164: FOR_TO
37165: IFFALSE 37212
// begin vc_chassis := 31 ;
37167: LD_ADDR_OWVAR 37
37171: PUSH
37172: LD_INT 31
37174: ST_TO_ADDR
// vc_control := control_rider ;
37175: LD_ADDR_OWVAR 38
37179: PUSH
37180: LD_INT 4
37182: ST_TO_ADDR
// animal := CreateVehicle ;
37183: LD_ADDR_VAR 0 12
37187: PUSH
37188: CALL_OW 45
37192: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37193: LD_VAR 0 12
37197: PPUSH
37198: LD_VAR 0 8
37202: PPUSH
37203: LD_INT 0
37205: PPUSH
37206: CALL 39402 0 3
// end ;
37210: GO 37164
37212: POP
37213: POP
// if horses then
37214: LD_VAR 0 5
37218: IFFALSE 37285
// for i = 1 to horses do
37220: LD_ADDR_VAR 0 11
37224: PUSH
37225: DOUBLE
37226: LD_INT 1
37228: DEC
37229: ST_TO_ADDR
37230: LD_VAR 0 5
37234: PUSH
37235: FOR_TO
37236: IFFALSE 37283
// begin hc_class := 21 ;
37238: LD_ADDR_OWVAR 28
37242: PUSH
37243: LD_INT 21
37245: ST_TO_ADDR
// hc_gallery :=  ;
37246: LD_ADDR_OWVAR 33
37250: PUSH
37251: LD_STRING 
37253: ST_TO_ADDR
// animal := CreateHuman ;
37254: LD_ADDR_VAR 0 12
37258: PUSH
37259: CALL_OW 44
37263: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37264: LD_VAR 0 12
37268: PPUSH
37269: LD_VAR 0 8
37273: PPUSH
37274: LD_INT 0
37276: PPUSH
37277: CALL 39402 0 3
// end ;
37281: GO 37235
37283: POP
37284: POP
// if birds then
37285: LD_VAR 0 1
37289: IFFALSE 37356
// for i = 1 to birds do
37291: LD_ADDR_VAR 0 11
37295: PUSH
37296: DOUBLE
37297: LD_INT 1
37299: DEC
37300: ST_TO_ADDR
37301: LD_VAR 0 1
37305: PUSH
37306: FOR_TO
37307: IFFALSE 37354
// begin hc_class = 18 ;
37309: LD_ADDR_OWVAR 28
37313: PUSH
37314: LD_INT 18
37316: ST_TO_ADDR
// hc_gallery =  ;
37317: LD_ADDR_OWVAR 33
37321: PUSH
37322: LD_STRING 
37324: ST_TO_ADDR
// animal := CreateHuman ;
37325: LD_ADDR_VAR 0 12
37329: PUSH
37330: CALL_OW 44
37334: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37335: LD_VAR 0 12
37339: PPUSH
37340: LD_VAR 0 8
37344: PPUSH
37345: LD_INT 0
37347: PPUSH
37348: CALL 39402 0 3
// end ;
37352: GO 37306
37354: POP
37355: POP
// if tigers then
37356: LD_VAR 0 2
37360: IFFALSE 37444
// for i = 1 to tigers do
37362: LD_ADDR_VAR 0 11
37366: PUSH
37367: DOUBLE
37368: LD_INT 1
37370: DEC
37371: ST_TO_ADDR
37372: LD_VAR 0 2
37376: PUSH
37377: FOR_TO
37378: IFFALSE 37442
// begin hc_class = class_tiger ;
37380: LD_ADDR_OWVAR 28
37384: PUSH
37385: LD_INT 14
37387: ST_TO_ADDR
// hc_gallery =  ;
37388: LD_ADDR_OWVAR 33
37392: PUSH
37393: LD_STRING 
37395: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
37396: LD_ADDR_OWVAR 35
37400: PUSH
37401: LD_INT 7
37403: NEG
37404: PPUSH
37405: LD_INT 7
37407: PPUSH
37408: CALL_OW 12
37412: ST_TO_ADDR
// animal := CreateHuman ;
37413: LD_ADDR_VAR 0 12
37417: PUSH
37418: CALL_OW 44
37422: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37423: LD_VAR 0 12
37427: PPUSH
37428: LD_VAR 0 8
37432: PPUSH
37433: LD_INT 0
37435: PPUSH
37436: CALL 39402 0 3
// end ;
37440: GO 37377
37442: POP
37443: POP
// if apemans then
37444: LD_VAR 0 3
37448: IFFALSE 37571
// for i = 1 to apemans do
37450: LD_ADDR_VAR 0 11
37454: PUSH
37455: DOUBLE
37456: LD_INT 1
37458: DEC
37459: ST_TO_ADDR
37460: LD_VAR 0 3
37464: PUSH
37465: FOR_TO
37466: IFFALSE 37569
// begin hc_class = class_apeman ;
37468: LD_ADDR_OWVAR 28
37472: PUSH
37473: LD_INT 12
37475: ST_TO_ADDR
// hc_gallery =  ;
37476: LD_ADDR_OWVAR 33
37480: PUSH
37481: LD_STRING 
37483: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
37484: LD_ADDR_OWVAR 35
37488: PUSH
37489: LD_INT 5
37491: NEG
37492: PPUSH
37493: LD_INT 5
37495: PPUSH
37496: CALL_OW 12
37500: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
37501: LD_ADDR_OWVAR 31
37505: PUSH
37506: LD_INT 1
37508: PPUSH
37509: LD_INT 3
37511: PPUSH
37512: CALL_OW 12
37516: PUSH
37517: LD_INT 1
37519: PPUSH
37520: LD_INT 3
37522: PPUSH
37523: CALL_OW 12
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: LD_INT 0
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: ST_TO_ADDR
// animal := CreateHuman ;
37540: LD_ADDR_VAR 0 12
37544: PUSH
37545: CALL_OW 44
37549: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37550: LD_VAR 0 12
37554: PPUSH
37555: LD_VAR 0 8
37559: PPUSH
37560: LD_INT 0
37562: PPUSH
37563: CALL 39402 0 3
// end ;
37567: GO 37465
37569: POP
37570: POP
// if enchidnas then
37571: LD_VAR 0 4
37575: IFFALSE 37642
// for i = 1 to enchidnas do
37577: LD_ADDR_VAR 0 11
37581: PUSH
37582: DOUBLE
37583: LD_INT 1
37585: DEC
37586: ST_TO_ADDR
37587: LD_VAR 0 4
37591: PUSH
37592: FOR_TO
37593: IFFALSE 37640
// begin hc_class = 13 ;
37595: LD_ADDR_OWVAR 28
37599: PUSH
37600: LD_INT 13
37602: ST_TO_ADDR
// hc_gallery =  ;
37603: LD_ADDR_OWVAR 33
37607: PUSH
37608: LD_STRING 
37610: ST_TO_ADDR
// animal := CreateHuman ;
37611: LD_ADDR_VAR 0 12
37615: PUSH
37616: CALL_OW 44
37620: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37621: LD_VAR 0 12
37625: PPUSH
37626: LD_VAR 0 8
37630: PPUSH
37631: LD_INT 0
37633: PPUSH
37634: CALL 39402 0 3
// end ;
37638: GO 37592
37640: POP
37641: POP
// if fishes then
37642: LD_VAR 0 7
37646: IFFALSE 37713
// for i = 1 to fishes do
37648: LD_ADDR_VAR 0 11
37652: PUSH
37653: DOUBLE
37654: LD_INT 1
37656: DEC
37657: ST_TO_ADDR
37658: LD_VAR 0 7
37662: PUSH
37663: FOR_TO
37664: IFFALSE 37711
// begin hc_class = 20 ;
37666: LD_ADDR_OWVAR 28
37670: PUSH
37671: LD_INT 20
37673: ST_TO_ADDR
// hc_gallery =  ;
37674: LD_ADDR_OWVAR 33
37678: PUSH
37679: LD_STRING 
37681: ST_TO_ADDR
// animal := CreateHuman ;
37682: LD_ADDR_VAR 0 12
37686: PUSH
37687: CALL_OW 44
37691: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
37692: LD_VAR 0 12
37696: PPUSH
37697: LD_VAR 0 9
37701: PPUSH
37702: LD_INT 0
37704: PPUSH
37705: CALL 39402 0 3
// end ;
37709: GO 37663
37711: POP
37712: POP
// end ;
37713: LD_VAR 0 10
37717: RET
// export function WantHeal ( sci , unit ) ; begin
37718: LD_INT 0
37720: PPUSH
// if GetTaskList ( sci ) > 0 then
37721: LD_VAR 0 1
37725: PPUSH
37726: CALL_OW 437
37730: PUSH
37731: LD_INT 0
37733: GREATER
37734: IFFALSE 37804
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
37736: LD_VAR 0 1
37740: PPUSH
37741: CALL_OW 437
37745: PUSH
37746: LD_INT 1
37748: ARRAY
37749: PUSH
37750: LD_INT 1
37752: ARRAY
37753: PUSH
37754: LD_STRING l
37756: EQUAL
37757: PUSH
37758: LD_VAR 0 1
37762: PPUSH
37763: CALL_OW 437
37767: PUSH
37768: LD_INT 1
37770: ARRAY
37771: PUSH
37772: LD_INT 4
37774: ARRAY
37775: PUSH
37776: LD_VAR 0 2
37780: EQUAL
37781: AND
37782: IFFALSE 37794
// result := true else
37784: LD_ADDR_VAR 0 3
37788: PUSH
37789: LD_INT 1
37791: ST_TO_ADDR
37792: GO 37802
// result := false ;
37794: LD_ADDR_VAR 0 3
37798: PUSH
37799: LD_INT 0
37801: ST_TO_ADDR
// end else
37802: GO 37812
// result := false ;
37804: LD_ADDR_VAR 0 3
37808: PUSH
37809: LD_INT 0
37811: ST_TO_ADDR
// end ;
37812: LD_VAR 0 3
37816: RET
// export function HealTarget ( sci ) ; begin
37817: LD_INT 0
37819: PPUSH
// if not sci then
37820: LD_VAR 0 1
37824: NOT
37825: IFFALSE 37829
// exit ;
37827: GO 37894
// result := 0 ;
37829: LD_ADDR_VAR 0 2
37833: PUSH
37834: LD_INT 0
37836: ST_TO_ADDR
// if GetTaskList ( sci ) then
37837: LD_VAR 0 1
37841: PPUSH
37842: CALL_OW 437
37846: IFFALSE 37894
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
37848: LD_VAR 0 1
37852: PPUSH
37853: CALL_OW 437
37857: PUSH
37858: LD_INT 1
37860: ARRAY
37861: PUSH
37862: LD_INT 1
37864: ARRAY
37865: PUSH
37866: LD_STRING l
37868: EQUAL
37869: IFFALSE 37894
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
37871: LD_ADDR_VAR 0 2
37875: PUSH
37876: LD_VAR 0 1
37880: PPUSH
37881: CALL_OW 437
37885: PUSH
37886: LD_INT 1
37888: ARRAY
37889: PUSH
37890: LD_INT 4
37892: ARRAY
37893: ST_TO_ADDR
// end ;
37894: LD_VAR 0 2
37898: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
37899: LD_INT 0
37901: PPUSH
37902: PPUSH
37903: PPUSH
37904: PPUSH
// if not base_units then
37905: LD_VAR 0 1
37909: NOT
37910: IFFALSE 37914
// exit ;
37912: GO 38001
// result := false ;
37914: LD_ADDR_VAR 0 2
37918: PUSH
37919: LD_INT 0
37921: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
37922: LD_ADDR_VAR 0 5
37926: PUSH
37927: LD_VAR 0 1
37931: PPUSH
37932: LD_INT 21
37934: PUSH
37935: LD_INT 3
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PPUSH
37942: CALL_OW 72
37946: ST_TO_ADDR
// if not tmp then
37947: LD_VAR 0 5
37951: NOT
37952: IFFALSE 37956
// exit ;
37954: GO 38001
// for i in tmp do
37956: LD_ADDR_VAR 0 3
37960: PUSH
37961: LD_VAR 0 5
37965: PUSH
37966: FOR_IN
37967: IFFALSE 37999
// begin result := EnemyInRange ( i , 22 ) ;
37969: LD_ADDR_VAR 0 2
37973: PUSH
37974: LD_VAR 0 3
37978: PPUSH
37979: LD_INT 22
37981: PPUSH
37982: CALL 36237 0 2
37986: ST_TO_ADDR
// if result then
37987: LD_VAR 0 2
37991: IFFALSE 37997
// exit ;
37993: POP
37994: POP
37995: GO 38001
// end ;
37997: GO 37966
37999: POP
38000: POP
// end ;
38001: LD_VAR 0 2
38005: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
38006: LD_INT 0
38008: PPUSH
38009: PPUSH
// if not units then
38010: LD_VAR 0 1
38014: NOT
38015: IFFALSE 38019
// exit ;
38017: GO 38089
// result := [ ] ;
38019: LD_ADDR_VAR 0 3
38023: PUSH
38024: EMPTY
38025: ST_TO_ADDR
// for i in units do
38026: LD_ADDR_VAR 0 4
38030: PUSH
38031: LD_VAR 0 1
38035: PUSH
38036: FOR_IN
38037: IFFALSE 38087
// if GetTag ( i ) = tag then
38039: LD_VAR 0 4
38043: PPUSH
38044: CALL_OW 110
38048: PUSH
38049: LD_VAR 0 2
38053: EQUAL
38054: IFFALSE 38085
// result := Insert ( result , result + 1 , i ) ;
38056: LD_ADDR_VAR 0 3
38060: PUSH
38061: LD_VAR 0 3
38065: PPUSH
38066: LD_VAR 0 3
38070: PUSH
38071: LD_INT 1
38073: PLUS
38074: PPUSH
38075: LD_VAR 0 4
38079: PPUSH
38080: CALL_OW 2
38084: ST_TO_ADDR
38085: GO 38036
38087: POP
38088: POP
// end ;
38089: LD_VAR 0 3
38093: RET
// export function IsDriver ( un ) ; begin
38094: LD_INT 0
38096: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
38097: LD_ADDR_VAR 0 2
38101: PUSH
38102: LD_VAR 0 1
38106: PUSH
38107: LD_INT 55
38109: PUSH
38110: EMPTY
38111: LIST
38112: PPUSH
38113: CALL_OW 69
38117: IN
38118: ST_TO_ADDR
// end ;
38119: LD_VAR 0 2
38123: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
38124: LD_INT 0
38126: PPUSH
38127: PPUSH
// list := [ ] ;
38128: LD_ADDR_VAR 0 5
38132: PUSH
38133: EMPTY
38134: ST_TO_ADDR
// case d of 0 :
38135: LD_VAR 0 3
38139: PUSH
38140: LD_INT 0
38142: DOUBLE
38143: EQUAL
38144: IFTRUE 38148
38146: GO 38281
38148: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
38149: LD_ADDR_VAR 0 5
38153: PUSH
38154: LD_VAR 0 1
38158: PUSH
38159: LD_INT 4
38161: MINUS
38162: PUSH
38163: LD_VAR 0 2
38167: PUSH
38168: LD_INT 4
38170: MINUS
38171: PUSH
38172: LD_INT 2
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: LIST
38179: PUSH
38180: LD_VAR 0 1
38184: PUSH
38185: LD_INT 3
38187: MINUS
38188: PUSH
38189: LD_VAR 0 2
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: LIST
38201: PUSH
38202: LD_VAR 0 1
38206: PUSH
38207: LD_INT 4
38209: PLUS
38210: PUSH
38211: LD_VAR 0 2
38215: PUSH
38216: LD_INT 4
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: LIST
38223: PUSH
38224: LD_VAR 0 1
38228: PUSH
38229: LD_INT 3
38231: PLUS
38232: PUSH
38233: LD_VAR 0 2
38237: PUSH
38238: LD_INT 3
38240: PLUS
38241: PUSH
38242: LD_INT 5
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: LIST
38249: PUSH
38250: LD_VAR 0 1
38254: PUSH
38255: LD_VAR 0 2
38259: PUSH
38260: LD_INT 4
38262: PLUS
38263: PUSH
38264: LD_INT 0
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: LIST
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: ST_TO_ADDR
// end ; 1 :
38279: GO 38979
38281: LD_INT 1
38283: DOUBLE
38284: EQUAL
38285: IFTRUE 38289
38287: GO 38422
38289: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
38290: LD_ADDR_VAR 0 5
38294: PUSH
38295: LD_VAR 0 1
38299: PUSH
38300: LD_VAR 0 2
38304: PUSH
38305: LD_INT 4
38307: MINUS
38308: PUSH
38309: LD_INT 3
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: LIST
38316: PUSH
38317: LD_VAR 0 1
38321: PUSH
38322: LD_INT 3
38324: MINUS
38325: PUSH
38326: LD_VAR 0 2
38330: PUSH
38331: LD_INT 3
38333: MINUS
38334: PUSH
38335: LD_INT 2
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: LIST
38342: PUSH
38343: LD_VAR 0 1
38347: PUSH
38348: LD_INT 4
38350: MINUS
38351: PUSH
38352: LD_VAR 0 2
38356: PUSH
38357: LD_INT 1
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: LIST
38364: PUSH
38365: LD_VAR 0 1
38369: PUSH
38370: LD_VAR 0 2
38374: PUSH
38375: LD_INT 3
38377: PLUS
38378: PUSH
38379: LD_INT 0
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: LIST
38386: PUSH
38387: LD_VAR 0 1
38391: PUSH
38392: LD_INT 4
38394: PLUS
38395: PUSH
38396: LD_VAR 0 2
38400: PUSH
38401: LD_INT 4
38403: PLUS
38404: PUSH
38405: LD_INT 5
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: LIST
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: ST_TO_ADDR
// end ; 2 :
38420: GO 38979
38422: LD_INT 2
38424: DOUBLE
38425: EQUAL
38426: IFTRUE 38430
38428: GO 38559
38430: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
38431: LD_ADDR_VAR 0 5
38435: PUSH
38436: LD_VAR 0 1
38440: PUSH
38441: LD_VAR 0 2
38445: PUSH
38446: LD_INT 3
38448: MINUS
38449: PUSH
38450: LD_INT 3
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: LIST
38457: PUSH
38458: LD_VAR 0 1
38462: PUSH
38463: LD_INT 4
38465: PLUS
38466: PUSH
38467: LD_VAR 0 2
38471: PUSH
38472: LD_INT 4
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: LIST
38479: PUSH
38480: LD_VAR 0 1
38484: PUSH
38485: LD_VAR 0 2
38489: PUSH
38490: LD_INT 4
38492: PLUS
38493: PUSH
38494: LD_INT 0
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: LIST
38501: PUSH
38502: LD_VAR 0 1
38506: PUSH
38507: LD_INT 3
38509: MINUS
38510: PUSH
38511: LD_VAR 0 2
38515: PUSH
38516: LD_INT 1
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: LIST
38523: PUSH
38524: LD_VAR 0 1
38528: PUSH
38529: LD_INT 4
38531: MINUS
38532: PUSH
38533: LD_VAR 0 2
38537: PUSH
38538: LD_INT 4
38540: MINUS
38541: PUSH
38542: LD_INT 2
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: LIST
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: ST_TO_ADDR
// end ; 3 :
38557: GO 38979
38559: LD_INT 3
38561: DOUBLE
38562: EQUAL
38563: IFTRUE 38567
38565: GO 38700
38567: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
38568: LD_ADDR_VAR 0 5
38572: PUSH
38573: LD_VAR 0 1
38577: PUSH
38578: LD_INT 3
38580: PLUS
38581: PUSH
38582: LD_VAR 0 2
38586: PUSH
38587: LD_INT 4
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: LIST
38594: PUSH
38595: LD_VAR 0 1
38599: PUSH
38600: LD_INT 4
38602: PLUS
38603: PUSH
38604: LD_VAR 0 2
38608: PUSH
38609: LD_INT 4
38611: PLUS
38612: PUSH
38613: LD_INT 5
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: LIST
38620: PUSH
38621: LD_VAR 0 1
38625: PUSH
38626: LD_INT 4
38628: MINUS
38629: PUSH
38630: LD_VAR 0 2
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: LIST
38642: PUSH
38643: LD_VAR 0 1
38647: PUSH
38648: LD_VAR 0 2
38652: PUSH
38653: LD_INT 4
38655: MINUS
38656: PUSH
38657: LD_INT 3
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: LIST
38664: PUSH
38665: LD_VAR 0 1
38669: PUSH
38670: LD_INT 3
38672: MINUS
38673: PUSH
38674: LD_VAR 0 2
38678: PUSH
38679: LD_INT 3
38681: MINUS
38682: PUSH
38683: LD_INT 2
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: LIST
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: ST_TO_ADDR
// end ; 4 :
38698: GO 38979
38700: LD_INT 4
38702: DOUBLE
38703: EQUAL
38704: IFTRUE 38708
38706: GO 38841
38708: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
38709: LD_ADDR_VAR 0 5
38713: PUSH
38714: LD_VAR 0 1
38718: PUSH
38719: LD_VAR 0 2
38723: PUSH
38724: LD_INT 4
38726: PLUS
38727: PUSH
38728: LD_INT 0
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: LIST
38735: PUSH
38736: LD_VAR 0 1
38740: PUSH
38741: LD_INT 3
38743: PLUS
38744: PUSH
38745: LD_VAR 0 2
38749: PUSH
38750: LD_INT 3
38752: PLUS
38753: PUSH
38754: LD_INT 5
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: LIST
38761: PUSH
38762: LD_VAR 0 1
38766: PUSH
38767: LD_INT 4
38769: PLUS
38770: PUSH
38771: LD_VAR 0 2
38775: PUSH
38776: LD_INT 4
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: LIST
38783: PUSH
38784: LD_VAR 0 1
38788: PUSH
38789: LD_VAR 0 2
38793: PUSH
38794: LD_INT 3
38796: MINUS
38797: PUSH
38798: LD_INT 3
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: LIST
38805: PUSH
38806: LD_VAR 0 1
38810: PUSH
38811: LD_INT 4
38813: MINUS
38814: PUSH
38815: LD_VAR 0 2
38819: PUSH
38820: LD_INT 4
38822: MINUS
38823: PUSH
38824: LD_INT 2
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: LIST
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: ST_TO_ADDR
// end ; 5 :
38839: GO 38979
38841: LD_INT 5
38843: DOUBLE
38844: EQUAL
38845: IFTRUE 38849
38847: GO 38978
38849: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
38850: LD_ADDR_VAR 0 5
38854: PUSH
38855: LD_VAR 0 1
38859: PUSH
38860: LD_INT 4
38862: MINUS
38863: PUSH
38864: LD_VAR 0 2
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: LIST
38876: PUSH
38877: LD_VAR 0 1
38881: PUSH
38882: LD_VAR 0 2
38886: PUSH
38887: LD_INT 4
38889: MINUS
38890: PUSH
38891: LD_INT 3
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: LIST
38898: PUSH
38899: LD_VAR 0 1
38903: PUSH
38904: LD_INT 4
38906: PLUS
38907: PUSH
38908: LD_VAR 0 2
38912: PUSH
38913: LD_INT 4
38915: PLUS
38916: PUSH
38917: LD_INT 5
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: LIST
38924: PUSH
38925: LD_VAR 0 1
38929: PUSH
38930: LD_INT 3
38932: PLUS
38933: PUSH
38934: LD_VAR 0 2
38938: PUSH
38939: LD_INT 4
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: LIST
38946: PUSH
38947: LD_VAR 0 1
38951: PUSH
38952: LD_VAR 0 2
38956: PUSH
38957: LD_INT 3
38959: PLUS
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: LIST
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: ST_TO_ADDR
// end ; end ;
38976: GO 38979
38978: POP
// result := list ;
38979: LD_ADDR_VAR 0 4
38983: PUSH
38984: LD_VAR 0 5
38988: ST_TO_ADDR
// end ;
38989: LD_VAR 0 4
38993: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
38994: LD_INT 0
38996: PPUSH
38997: PPUSH
38998: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
38999: LD_VAR 0 1
39003: NOT
39004: PUSH
39005: LD_VAR 0 2
39009: PUSH
39010: LD_INT 1
39012: PUSH
39013: LD_INT 2
39015: PUSH
39016: LD_INT 3
39018: PUSH
39019: LD_INT 4
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: IN
39028: NOT
39029: OR
39030: IFFALSE 39034
// exit ;
39032: GO 39126
// tmp := [ ] ;
39034: LD_ADDR_VAR 0 5
39038: PUSH
39039: EMPTY
39040: ST_TO_ADDR
// for i in units do
39041: LD_ADDR_VAR 0 4
39045: PUSH
39046: LD_VAR 0 1
39050: PUSH
39051: FOR_IN
39052: IFFALSE 39095
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
39054: LD_ADDR_VAR 0 5
39058: PUSH
39059: LD_VAR 0 5
39063: PPUSH
39064: LD_VAR 0 5
39068: PUSH
39069: LD_INT 1
39071: PLUS
39072: PPUSH
39073: LD_VAR 0 4
39077: PPUSH
39078: LD_VAR 0 2
39082: PPUSH
39083: CALL_OW 259
39087: PPUSH
39088: CALL_OW 2
39092: ST_TO_ADDR
39093: GO 39051
39095: POP
39096: POP
// if not tmp then
39097: LD_VAR 0 5
39101: NOT
39102: IFFALSE 39106
// exit ;
39104: GO 39126
// result := SortListByListDesc ( units , tmp ) ;
39106: LD_ADDR_VAR 0 3
39110: PUSH
39111: LD_VAR 0 1
39115: PPUSH
39116: LD_VAR 0 5
39120: PPUSH
39121: CALL_OW 77
39125: ST_TO_ADDR
// end ;
39126: LD_VAR 0 3
39130: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
39131: LD_INT 0
39133: PPUSH
39134: PPUSH
39135: PPUSH
// result := false ;
39136: LD_ADDR_VAR 0 3
39140: PUSH
39141: LD_INT 0
39143: ST_TO_ADDR
// x := GetX ( building ) ;
39144: LD_ADDR_VAR 0 4
39148: PUSH
39149: LD_VAR 0 2
39153: PPUSH
39154: CALL_OW 250
39158: ST_TO_ADDR
// y := GetY ( building ) ;
39159: LD_ADDR_VAR 0 5
39163: PUSH
39164: LD_VAR 0 2
39168: PPUSH
39169: CALL_OW 251
39173: ST_TO_ADDR
// if not building or not x or not y then
39174: LD_VAR 0 2
39178: NOT
39179: PUSH
39180: LD_VAR 0 4
39184: NOT
39185: OR
39186: PUSH
39187: LD_VAR 0 5
39191: NOT
39192: OR
39193: IFFALSE 39197
// exit ;
39195: GO 39289
// if GetTaskList ( unit ) then
39197: LD_VAR 0 1
39201: PPUSH
39202: CALL_OW 437
39206: IFFALSE 39289
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39208: LD_STRING e
39210: PUSH
39211: LD_VAR 0 1
39215: PPUSH
39216: CALL_OW 437
39220: PUSH
39221: LD_INT 1
39223: ARRAY
39224: PUSH
39225: LD_INT 1
39227: ARRAY
39228: EQUAL
39229: PUSH
39230: LD_VAR 0 4
39234: PUSH
39235: LD_VAR 0 1
39239: PPUSH
39240: CALL_OW 437
39244: PUSH
39245: LD_INT 1
39247: ARRAY
39248: PUSH
39249: LD_INT 2
39251: ARRAY
39252: EQUAL
39253: AND
39254: PUSH
39255: LD_VAR 0 5
39259: PUSH
39260: LD_VAR 0 1
39264: PPUSH
39265: CALL_OW 437
39269: PUSH
39270: LD_INT 1
39272: ARRAY
39273: PUSH
39274: LD_INT 3
39276: ARRAY
39277: EQUAL
39278: AND
39279: IFFALSE 39289
// result := true end ;
39281: LD_ADDR_VAR 0 3
39285: PUSH
39286: LD_INT 1
39288: ST_TO_ADDR
// end ;
39289: LD_VAR 0 3
39293: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
39294: LD_INT 0
39296: PPUSH
// result := false ;
39297: LD_ADDR_VAR 0 4
39301: PUSH
39302: LD_INT 0
39304: ST_TO_ADDR
// if GetTaskList ( unit ) then
39305: LD_VAR 0 1
39309: PPUSH
39310: CALL_OW 437
39314: IFFALSE 39397
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39316: LD_STRING M
39318: PUSH
39319: LD_VAR 0 1
39323: PPUSH
39324: CALL_OW 437
39328: PUSH
39329: LD_INT 1
39331: ARRAY
39332: PUSH
39333: LD_INT 1
39335: ARRAY
39336: EQUAL
39337: PUSH
39338: LD_VAR 0 2
39342: PUSH
39343: LD_VAR 0 1
39347: PPUSH
39348: CALL_OW 437
39352: PUSH
39353: LD_INT 1
39355: ARRAY
39356: PUSH
39357: LD_INT 2
39359: ARRAY
39360: EQUAL
39361: AND
39362: PUSH
39363: LD_VAR 0 3
39367: PUSH
39368: LD_VAR 0 1
39372: PPUSH
39373: CALL_OW 437
39377: PUSH
39378: LD_INT 1
39380: ARRAY
39381: PUSH
39382: LD_INT 3
39384: ARRAY
39385: EQUAL
39386: AND
39387: IFFALSE 39397
// result := true ;
39389: LD_ADDR_VAR 0 4
39393: PUSH
39394: LD_INT 1
39396: ST_TO_ADDR
// end ; end ;
39397: LD_VAR 0 4
39401: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
39402: LD_INT 0
39404: PPUSH
39405: PPUSH
39406: PPUSH
39407: PPUSH
// if not unit or not area then
39408: LD_VAR 0 1
39412: NOT
39413: PUSH
39414: LD_VAR 0 2
39418: NOT
39419: OR
39420: IFFALSE 39424
// exit ;
39422: GO 39588
// tmp := AreaToList ( area , i ) ;
39424: LD_ADDR_VAR 0 6
39428: PUSH
39429: LD_VAR 0 2
39433: PPUSH
39434: LD_VAR 0 5
39438: PPUSH
39439: CALL_OW 517
39443: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
39444: LD_ADDR_VAR 0 5
39448: PUSH
39449: DOUBLE
39450: LD_INT 1
39452: DEC
39453: ST_TO_ADDR
39454: LD_VAR 0 6
39458: PUSH
39459: LD_INT 1
39461: ARRAY
39462: PUSH
39463: FOR_TO
39464: IFFALSE 39586
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
39466: LD_ADDR_VAR 0 7
39470: PUSH
39471: LD_VAR 0 6
39475: PUSH
39476: LD_INT 1
39478: ARRAY
39479: PUSH
39480: LD_VAR 0 5
39484: ARRAY
39485: PUSH
39486: LD_VAR 0 6
39490: PUSH
39491: LD_INT 2
39493: ARRAY
39494: PUSH
39495: LD_VAR 0 5
39499: ARRAY
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
39505: LD_VAR 0 7
39509: PUSH
39510: LD_INT 1
39512: ARRAY
39513: PPUSH
39514: LD_VAR 0 7
39518: PUSH
39519: LD_INT 2
39521: ARRAY
39522: PPUSH
39523: CALL_OW 428
39527: PUSH
39528: LD_INT 0
39530: EQUAL
39531: IFFALSE 39584
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
39533: LD_VAR 0 1
39537: PPUSH
39538: LD_VAR 0 7
39542: PUSH
39543: LD_INT 1
39545: ARRAY
39546: PPUSH
39547: LD_VAR 0 7
39551: PUSH
39552: LD_INT 2
39554: ARRAY
39555: PPUSH
39556: LD_VAR 0 3
39560: PPUSH
39561: CALL_OW 48
// result := IsPlaced ( unit ) ;
39565: LD_ADDR_VAR 0 4
39569: PUSH
39570: LD_VAR 0 1
39574: PPUSH
39575: CALL_OW 305
39579: ST_TO_ADDR
// exit ;
39580: POP
39581: POP
39582: GO 39588
// end ; end ;
39584: GO 39463
39586: POP
39587: POP
// end ;
39588: LD_VAR 0 4
39592: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
39593: LD_INT 0
39595: PPUSH
39596: PPUSH
39597: PPUSH
// if not side or side > 8 then
39598: LD_VAR 0 1
39602: NOT
39603: PUSH
39604: LD_VAR 0 1
39608: PUSH
39609: LD_INT 8
39611: GREATER
39612: OR
39613: IFFALSE 39617
// exit ;
39615: GO 39804
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
39617: LD_ADDR_VAR 0 4
39621: PUSH
39622: LD_INT 22
39624: PUSH
39625: LD_VAR 0 1
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 21
39636: PUSH
39637: LD_INT 3
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PPUSH
39648: CALL_OW 69
39652: ST_TO_ADDR
// if not tmp then
39653: LD_VAR 0 4
39657: NOT
39658: IFFALSE 39662
// exit ;
39660: GO 39804
// enable_addtolog := true ;
39662: LD_ADDR_OWVAR 81
39666: PUSH
39667: LD_INT 1
39669: ST_TO_ADDR
// AddToLog ( [ ) ;
39670: LD_STRING [
39672: PPUSH
39673: CALL_OW 561
// for i in tmp do
39677: LD_ADDR_VAR 0 3
39681: PUSH
39682: LD_VAR 0 4
39686: PUSH
39687: FOR_IN
39688: IFFALSE 39795
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
39690: LD_STRING [
39692: PUSH
39693: LD_VAR 0 3
39697: PPUSH
39698: CALL_OW 266
39702: STR
39703: PUSH
39704: LD_STRING , 
39706: STR
39707: PUSH
39708: LD_VAR 0 3
39712: PPUSH
39713: CALL_OW 250
39717: STR
39718: PUSH
39719: LD_STRING , 
39721: STR
39722: PUSH
39723: LD_VAR 0 3
39727: PPUSH
39728: CALL_OW 251
39732: STR
39733: PUSH
39734: LD_STRING , 
39736: STR
39737: PUSH
39738: LD_VAR 0 3
39742: PPUSH
39743: CALL_OW 254
39747: STR
39748: PUSH
39749: LD_STRING , 
39751: STR
39752: PUSH
39753: LD_VAR 0 3
39757: PPUSH
39758: LD_INT 1
39760: PPUSH
39761: CALL_OW 268
39765: STR
39766: PUSH
39767: LD_STRING , 
39769: STR
39770: PUSH
39771: LD_VAR 0 3
39775: PPUSH
39776: LD_INT 2
39778: PPUSH
39779: CALL_OW 268
39783: STR
39784: PUSH
39785: LD_STRING ],
39787: STR
39788: PPUSH
39789: CALL_OW 561
// end ;
39793: GO 39687
39795: POP
39796: POP
// AddToLog ( ]; ) ;
39797: LD_STRING ];
39799: PPUSH
39800: CALL_OW 561
// end ;
39804: LD_VAR 0 2
39808: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
39809: LD_INT 0
39811: PPUSH
39812: PPUSH
39813: PPUSH
39814: PPUSH
39815: PPUSH
// if not area or not rate or not max then
39816: LD_VAR 0 1
39820: NOT
39821: PUSH
39822: LD_VAR 0 2
39826: NOT
39827: OR
39828: PUSH
39829: LD_VAR 0 4
39833: NOT
39834: OR
39835: IFFALSE 39839
// exit ;
39837: GO 40031
// while 1 do
39839: LD_INT 1
39841: IFFALSE 40031
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
39843: LD_ADDR_VAR 0 9
39847: PUSH
39848: LD_VAR 0 1
39852: PPUSH
39853: LD_INT 1
39855: PPUSH
39856: CALL_OW 287
39860: PUSH
39861: LD_INT 10
39863: MUL
39864: ST_TO_ADDR
// r := rate / 10 ;
39865: LD_ADDR_VAR 0 7
39869: PUSH
39870: LD_VAR 0 2
39874: PUSH
39875: LD_INT 10
39877: DIVREAL
39878: ST_TO_ADDR
// time := 1 1$00 ;
39879: LD_ADDR_VAR 0 8
39883: PUSH
39884: LD_INT 2100
39886: ST_TO_ADDR
// if amount < min then
39887: LD_VAR 0 9
39891: PUSH
39892: LD_VAR 0 3
39896: LESS
39897: IFFALSE 39915
// r := r * 2 else
39899: LD_ADDR_VAR 0 7
39903: PUSH
39904: LD_VAR 0 7
39908: PUSH
39909: LD_INT 2
39911: MUL
39912: ST_TO_ADDR
39913: GO 39941
// if amount > max then
39915: LD_VAR 0 9
39919: PUSH
39920: LD_VAR 0 4
39924: GREATER
39925: IFFALSE 39941
// r := r / 2 ;
39927: LD_ADDR_VAR 0 7
39931: PUSH
39932: LD_VAR 0 7
39936: PUSH
39937: LD_INT 2
39939: DIVREAL
39940: ST_TO_ADDR
// time := time / r ;
39941: LD_ADDR_VAR 0 8
39945: PUSH
39946: LD_VAR 0 8
39950: PUSH
39951: LD_VAR 0 7
39955: DIVREAL
39956: ST_TO_ADDR
// if time < 0 then
39957: LD_VAR 0 8
39961: PUSH
39962: LD_INT 0
39964: LESS
39965: IFFALSE 39982
// time := time * - 1 ;
39967: LD_ADDR_VAR 0 8
39971: PUSH
39972: LD_VAR 0 8
39976: PUSH
39977: LD_INT 1
39979: NEG
39980: MUL
39981: ST_TO_ADDR
// wait ( time ) ;
39982: LD_VAR 0 8
39986: PPUSH
39987: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
39991: LD_INT 35
39993: PPUSH
39994: LD_INT 875
39996: PPUSH
39997: CALL_OW 12
40001: PPUSH
40002: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
40006: LD_INT 1
40008: PPUSH
40009: LD_INT 5
40011: PPUSH
40012: CALL_OW 12
40016: PPUSH
40017: LD_VAR 0 1
40021: PPUSH
40022: LD_INT 1
40024: PPUSH
40025: CALL_OW 55
// end ;
40029: GO 39839
// end ;
40031: LD_VAR 0 5
40035: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
40036: LD_INT 0
40038: PPUSH
40039: PPUSH
40040: PPUSH
40041: PPUSH
40042: PPUSH
40043: PPUSH
40044: PPUSH
40045: PPUSH
// if not turrets or not factories then
40046: LD_VAR 0 1
40050: NOT
40051: PUSH
40052: LD_VAR 0 2
40056: NOT
40057: OR
40058: IFFALSE 40062
// exit ;
40060: GO 40369
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
40062: LD_ADDR_VAR 0 10
40066: PUSH
40067: LD_INT 5
40069: PUSH
40070: LD_INT 6
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 2
40079: PUSH
40080: LD_INT 4
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 3
40089: PUSH
40090: LD_INT 5
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 24
40104: PUSH
40105: LD_INT 25
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 23
40114: PUSH
40115: LD_INT 27
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 42
40128: PUSH
40129: LD_INT 43
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 44
40138: PUSH
40139: LD_INT 46
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 45
40148: PUSH
40149: LD_INT 47
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: EMPTY
40157: LIST
40158: LIST
40159: LIST
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: LIST
40165: ST_TO_ADDR
// result := [ ] ;
40166: LD_ADDR_VAR 0 3
40170: PUSH
40171: EMPTY
40172: ST_TO_ADDR
// for i in turrets do
40173: LD_ADDR_VAR 0 4
40177: PUSH
40178: LD_VAR 0 1
40182: PUSH
40183: FOR_IN
40184: IFFALSE 40367
// begin nat := GetNation ( i ) ;
40186: LD_ADDR_VAR 0 7
40190: PUSH
40191: LD_VAR 0 4
40195: PPUSH
40196: CALL_OW 248
40200: ST_TO_ADDR
// weapon := 0 ;
40201: LD_ADDR_VAR 0 8
40205: PUSH
40206: LD_INT 0
40208: ST_TO_ADDR
// if not nat then
40209: LD_VAR 0 7
40213: NOT
40214: IFFALSE 40218
// continue ;
40216: GO 40183
// for j in list [ nat ] do
40218: LD_ADDR_VAR 0 5
40222: PUSH
40223: LD_VAR 0 10
40227: PUSH
40228: LD_VAR 0 7
40232: ARRAY
40233: PUSH
40234: FOR_IN
40235: IFFALSE 40276
// if GetBWeapon ( i ) = j [ 1 ] then
40237: LD_VAR 0 4
40241: PPUSH
40242: CALL_OW 269
40246: PUSH
40247: LD_VAR 0 5
40251: PUSH
40252: LD_INT 1
40254: ARRAY
40255: EQUAL
40256: IFFALSE 40274
// begin weapon := j [ 2 ] ;
40258: LD_ADDR_VAR 0 8
40262: PUSH
40263: LD_VAR 0 5
40267: PUSH
40268: LD_INT 2
40270: ARRAY
40271: ST_TO_ADDR
// break ;
40272: GO 40276
// end ;
40274: GO 40234
40276: POP
40277: POP
// if not weapon then
40278: LD_VAR 0 8
40282: NOT
40283: IFFALSE 40287
// continue ;
40285: GO 40183
// for k in factories do
40287: LD_ADDR_VAR 0 6
40291: PUSH
40292: LD_VAR 0 2
40296: PUSH
40297: FOR_IN
40298: IFFALSE 40363
// begin weapons := AvailableWeaponList ( k ) ;
40300: LD_ADDR_VAR 0 9
40304: PUSH
40305: LD_VAR 0 6
40309: PPUSH
40310: CALL_OW 478
40314: ST_TO_ADDR
// if not weapons then
40315: LD_VAR 0 9
40319: NOT
40320: IFFALSE 40324
// continue ;
40322: GO 40297
// if weapon in weapons then
40324: LD_VAR 0 8
40328: PUSH
40329: LD_VAR 0 9
40333: IN
40334: IFFALSE 40361
// begin result := [ i , weapon ] ;
40336: LD_ADDR_VAR 0 3
40340: PUSH
40341: LD_VAR 0 4
40345: PUSH
40346: LD_VAR 0 8
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: ST_TO_ADDR
// exit ;
40355: POP
40356: POP
40357: POP
40358: POP
40359: GO 40369
// end ; end ;
40361: GO 40297
40363: POP
40364: POP
// end ;
40365: GO 40183
40367: POP
40368: POP
// end ;
40369: LD_VAR 0 3
40373: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
40374: LD_INT 0
40376: PPUSH
// if not side or side > 8 then
40377: LD_VAR 0 3
40381: NOT
40382: PUSH
40383: LD_VAR 0 3
40387: PUSH
40388: LD_INT 8
40390: GREATER
40391: OR
40392: IFFALSE 40396
// exit ;
40394: GO 40455
// if not range then
40396: LD_VAR 0 4
40400: NOT
40401: IFFALSE 40412
// range := - 12 ;
40403: LD_ADDR_VAR 0 4
40407: PUSH
40408: LD_INT 12
40410: NEG
40411: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
40412: LD_VAR 0 1
40416: PPUSH
40417: LD_VAR 0 2
40421: PPUSH
40422: LD_VAR 0 3
40426: PPUSH
40427: LD_VAR 0 4
40431: PPUSH
40432: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
40436: LD_VAR 0 1
40440: PPUSH
40441: LD_VAR 0 2
40445: PPUSH
40446: LD_VAR 0 3
40450: PPUSH
40451: CALL_OW 331
// end ;
40455: LD_VAR 0 5
40459: RET
// export function Video ( mode ) ; begin
40460: LD_INT 0
40462: PPUSH
// ingame_video = mode ;
40463: LD_ADDR_OWVAR 52
40467: PUSH
40468: LD_VAR 0 1
40472: ST_TO_ADDR
// interface_hidden = mode ;
40473: LD_ADDR_OWVAR 54
40477: PUSH
40478: LD_VAR 0 1
40482: ST_TO_ADDR
// end ;
40483: LD_VAR 0 2
40487: RET
// export function Join ( array , element ) ; begin
40488: LD_INT 0
40490: PPUSH
// result := Replace ( array , array + 1 , element ) ;
40491: LD_ADDR_VAR 0 3
40495: PUSH
40496: LD_VAR 0 1
40500: PPUSH
40501: LD_VAR 0 1
40505: PUSH
40506: LD_INT 1
40508: PLUS
40509: PPUSH
40510: LD_VAR 0 2
40514: PPUSH
40515: CALL_OW 1
40519: ST_TO_ADDR
// end ;
40520: LD_VAR 0 3
40524: RET
// export function JoinUnion ( array , element ) ; begin
40525: LD_INT 0
40527: PPUSH
// result := array union element ;
40528: LD_ADDR_VAR 0 3
40532: PUSH
40533: LD_VAR 0 1
40537: PUSH
40538: LD_VAR 0 2
40542: UNION
40543: ST_TO_ADDR
// end ;
40544: LD_VAR 0 3
40548: RET
// export function GetBehemoths ( side ) ; begin
40549: LD_INT 0
40551: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
40552: LD_ADDR_VAR 0 2
40556: PUSH
40557: LD_INT 22
40559: PUSH
40560: LD_VAR 0 1
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 31
40571: PUSH
40572: LD_INT 25
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PPUSH
40583: CALL_OW 69
40587: ST_TO_ADDR
// end ;
40588: LD_VAR 0 2
40592: RET
// export function Shuffle ( array ) ; var i , index ; begin
40593: LD_INT 0
40595: PPUSH
40596: PPUSH
40597: PPUSH
// result := [ ] ;
40598: LD_ADDR_VAR 0 2
40602: PUSH
40603: EMPTY
40604: ST_TO_ADDR
// if not array then
40605: LD_VAR 0 1
40609: NOT
40610: IFFALSE 40614
// exit ;
40612: GO 40713
// Randomize ;
40614: CALL_OW 10
// for i = array downto 1 do
40618: LD_ADDR_VAR 0 3
40622: PUSH
40623: DOUBLE
40624: LD_VAR 0 1
40628: INC
40629: ST_TO_ADDR
40630: LD_INT 1
40632: PUSH
40633: FOR_DOWNTO
40634: IFFALSE 40711
// begin index := rand ( 1 , array ) ;
40636: LD_ADDR_VAR 0 4
40640: PUSH
40641: LD_INT 1
40643: PPUSH
40644: LD_VAR 0 1
40648: PPUSH
40649: CALL_OW 12
40653: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
40654: LD_ADDR_VAR 0 2
40658: PUSH
40659: LD_VAR 0 2
40663: PPUSH
40664: LD_VAR 0 2
40668: PUSH
40669: LD_INT 1
40671: PLUS
40672: PPUSH
40673: LD_VAR 0 1
40677: PUSH
40678: LD_VAR 0 4
40682: ARRAY
40683: PPUSH
40684: CALL_OW 2
40688: ST_TO_ADDR
// array := Delete ( array , index ) ;
40689: LD_ADDR_VAR 0 1
40693: PUSH
40694: LD_VAR 0 1
40698: PPUSH
40699: LD_VAR 0 4
40703: PPUSH
40704: CALL_OW 3
40708: ST_TO_ADDR
// end ;
40709: GO 40633
40711: POP
40712: POP
// end ;
40713: LD_VAR 0 2
40717: RET
// export function GetBaseMaterials ( base ) ; begin
40718: LD_INT 0
40720: PPUSH
// result := [ 0 , 0 , 0 ] ;
40721: LD_ADDR_VAR 0 2
40725: PUSH
40726: LD_INT 0
40728: PUSH
40729: LD_INT 0
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: LIST
40739: ST_TO_ADDR
// if not base then
40740: LD_VAR 0 1
40744: NOT
40745: IFFALSE 40749
// exit ;
40747: GO 40798
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
40749: LD_ADDR_VAR 0 2
40753: PUSH
40754: LD_VAR 0 1
40758: PPUSH
40759: LD_INT 1
40761: PPUSH
40762: CALL_OW 275
40766: PUSH
40767: LD_VAR 0 1
40771: PPUSH
40772: LD_INT 2
40774: PPUSH
40775: CALL_OW 275
40779: PUSH
40780: LD_VAR 0 1
40784: PPUSH
40785: LD_INT 3
40787: PPUSH
40788: CALL_OW 275
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: LIST
40797: ST_TO_ADDR
// end ;
40798: LD_VAR 0 2
40802: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
40803: LD_INT 0
40805: PPUSH
40806: PPUSH
// result := array ;
40807: LD_ADDR_VAR 0 3
40811: PUSH
40812: LD_VAR 0 1
40816: ST_TO_ADDR
// if size > 0 then
40817: LD_VAR 0 2
40821: PUSH
40822: LD_INT 0
40824: GREATER
40825: IFFALSE 40871
// for i := array downto size do
40827: LD_ADDR_VAR 0 4
40831: PUSH
40832: DOUBLE
40833: LD_VAR 0 1
40837: INC
40838: ST_TO_ADDR
40839: LD_VAR 0 2
40843: PUSH
40844: FOR_DOWNTO
40845: IFFALSE 40869
// result := Delete ( result , result ) ;
40847: LD_ADDR_VAR 0 3
40851: PUSH
40852: LD_VAR 0 3
40856: PPUSH
40857: LD_VAR 0 3
40861: PPUSH
40862: CALL_OW 3
40866: ST_TO_ADDR
40867: GO 40844
40869: POP
40870: POP
// end ;
40871: LD_VAR 0 3
40875: RET
// export function ComExit ( unit ) ; var tmp ; begin
40876: LD_INT 0
40878: PPUSH
40879: PPUSH
// if not IsInUnit ( unit ) then
40880: LD_VAR 0 1
40884: PPUSH
40885: CALL_OW 310
40889: NOT
40890: IFFALSE 40894
// exit ;
40892: GO 40954
// tmp := IsInUnit ( unit ) ;
40894: LD_ADDR_VAR 0 3
40898: PUSH
40899: LD_VAR 0 1
40903: PPUSH
40904: CALL_OW 310
40908: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
40909: LD_VAR 0 3
40913: PPUSH
40914: CALL_OW 247
40918: PUSH
40919: LD_INT 2
40921: EQUAL
40922: IFFALSE 40935
// ComExitVehicle ( unit ) else
40924: LD_VAR 0 1
40928: PPUSH
40929: CALL_OW 121
40933: GO 40944
// ComExitBuilding ( unit ) ;
40935: LD_VAR 0 1
40939: PPUSH
40940: CALL_OW 122
// result := tmp ;
40944: LD_ADDR_VAR 0 2
40948: PUSH
40949: LD_VAR 0 3
40953: ST_TO_ADDR
// end ;
40954: LD_VAR 0 2
40958: RET
// export function ResetHc ; begin
40959: LD_INT 0
40961: PPUSH
// InitHc ;
40962: CALL_OW 19
// hc_importance := 0 ;
40966: LD_ADDR_OWVAR 32
40970: PUSH
40971: LD_INT 0
40973: ST_TO_ADDR
// end ;
40974: LD_VAR 0 1
40978: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
40979: LD_INT 0
40981: PPUSH
40982: PPUSH
40983: PPUSH
// _x := ( x1 + x2 ) div 2 ;
40984: LD_ADDR_VAR 0 6
40988: PUSH
40989: LD_VAR 0 1
40993: PUSH
40994: LD_VAR 0 3
40998: PLUS
40999: PUSH
41000: LD_INT 2
41002: DIV
41003: ST_TO_ADDR
// if _x < 0 then
41004: LD_VAR 0 6
41008: PUSH
41009: LD_INT 0
41011: LESS
41012: IFFALSE 41029
// _x := _x * - 1 ;
41014: LD_ADDR_VAR 0 6
41018: PUSH
41019: LD_VAR 0 6
41023: PUSH
41024: LD_INT 1
41026: NEG
41027: MUL
41028: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
41029: LD_ADDR_VAR 0 7
41033: PUSH
41034: LD_VAR 0 2
41038: PUSH
41039: LD_VAR 0 4
41043: PLUS
41044: PUSH
41045: LD_INT 2
41047: DIV
41048: ST_TO_ADDR
// if _y < 0 then
41049: LD_VAR 0 7
41053: PUSH
41054: LD_INT 0
41056: LESS
41057: IFFALSE 41074
// _y := _y * - 1 ;
41059: LD_ADDR_VAR 0 7
41063: PUSH
41064: LD_VAR 0 7
41068: PUSH
41069: LD_INT 1
41071: NEG
41072: MUL
41073: ST_TO_ADDR
// result := [ _x , _y ] ;
41074: LD_ADDR_VAR 0 5
41078: PUSH
41079: LD_VAR 0 6
41083: PUSH
41084: LD_VAR 0 7
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: ST_TO_ADDR
// end ;
41093: LD_VAR 0 5
41097: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
41098: LD_INT 0
41100: PPUSH
41101: PPUSH
41102: PPUSH
41103: PPUSH
// task := GetTaskList ( unit ) ;
41104: LD_ADDR_VAR 0 7
41108: PUSH
41109: LD_VAR 0 1
41113: PPUSH
41114: CALL_OW 437
41118: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
41119: LD_VAR 0 7
41123: NOT
41124: PUSH
41125: LD_VAR 0 1
41129: PPUSH
41130: LD_VAR 0 2
41134: PPUSH
41135: CALL_OW 308
41139: NOT
41140: AND
41141: IFFALSE 41145
// exit ;
41143: GO 41263
// if IsInArea ( unit , area ) then
41145: LD_VAR 0 1
41149: PPUSH
41150: LD_VAR 0 2
41154: PPUSH
41155: CALL_OW 308
41159: IFFALSE 41177
// begin ComMoveToArea ( unit , goAway ) ;
41161: LD_VAR 0 1
41165: PPUSH
41166: LD_VAR 0 3
41170: PPUSH
41171: CALL_OW 113
// exit ;
41175: GO 41263
// end ; if task [ 1 ] [ 1 ] <> M then
41177: LD_VAR 0 7
41181: PUSH
41182: LD_INT 1
41184: ARRAY
41185: PUSH
41186: LD_INT 1
41188: ARRAY
41189: PUSH
41190: LD_STRING M
41192: NONEQUAL
41193: IFFALSE 41197
// exit ;
41195: GO 41263
// x := task [ 1 ] [ 2 ] ;
41197: LD_ADDR_VAR 0 5
41201: PUSH
41202: LD_VAR 0 7
41206: PUSH
41207: LD_INT 1
41209: ARRAY
41210: PUSH
41211: LD_INT 2
41213: ARRAY
41214: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
41215: LD_ADDR_VAR 0 6
41219: PUSH
41220: LD_VAR 0 7
41224: PUSH
41225: LD_INT 1
41227: ARRAY
41228: PUSH
41229: LD_INT 3
41231: ARRAY
41232: ST_TO_ADDR
// if InArea ( x , y , area ) then
41233: LD_VAR 0 5
41237: PPUSH
41238: LD_VAR 0 6
41242: PPUSH
41243: LD_VAR 0 2
41247: PPUSH
41248: CALL_OW 309
41252: IFFALSE 41263
// ComStop ( unit ) ;
41254: LD_VAR 0 1
41258: PPUSH
41259: CALL_OW 141
// end ;
41263: LD_VAR 0 4
41267: RET
// export function Abs ( value ) ; begin
41268: LD_INT 0
41270: PPUSH
// result := value ;
41271: LD_ADDR_VAR 0 2
41275: PUSH
41276: LD_VAR 0 1
41280: ST_TO_ADDR
// if value < 0 then
41281: LD_VAR 0 1
41285: PUSH
41286: LD_INT 0
41288: LESS
41289: IFFALSE 41306
// result := value * - 1 ;
41291: LD_ADDR_VAR 0 2
41295: PUSH
41296: LD_VAR 0 1
41300: PUSH
41301: LD_INT 1
41303: NEG
41304: MUL
41305: ST_TO_ADDR
// end ; end_of_file
41306: LD_VAR 0 2
41310: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
41311: LD_INT 0
41313: PPUSH
41314: PPUSH
// skirmish := false ;
41315: LD_ADDR_EXP 12
41319: PUSH
41320: LD_INT 0
41322: ST_TO_ADDR
// debug_mc := false ;
41323: LD_ADDR_EXP 13
41327: PUSH
41328: LD_INT 0
41330: ST_TO_ADDR
// mc_bases := [ ] ;
41331: LD_ADDR_EXP 14
41335: PUSH
41336: EMPTY
41337: ST_TO_ADDR
// mc_sides := [ ] ;
41338: LD_ADDR_EXP 40
41342: PUSH
41343: EMPTY
41344: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
41345: LD_ADDR_EXP 15
41349: PUSH
41350: EMPTY
41351: ST_TO_ADDR
// mc_building_repairs := [ ] ;
41352: LD_ADDR_EXP 16
41356: PUSH
41357: EMPTY
41358: ST_TO_ADDR
// mc_need_heal := [ ] ;
41359: LD_ADDR_EXP 17
41363: PUSH
41364: EMPTY
41365: ST_TO_ADDR
// mc_healers := [ ] ;
41366: LD_ADDR_EXP 18
41370: PUSH
41371: EMPTY
41372: ST_TO_ADDR
// mc_build_list := [ ] ;
41373: LD_ADDR_EXP 19
41377: PUSH
41378: EMPTY
41379: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
41380: LD_ADDR_EXP 46
41384: PUSH
41385: EMPTY
41386: ST_TO_ADDR
// mc_builders := [ ] ;
41387: LD_ADDR_EXP 20
41391: PUSH
41392: EMPTY
41393: ST_TO_ADDR
// mc_construct_list := [ ] ;
41394: LD_ADDR_EXP 21
41398: PUSH
41399: EMPTY
41400: ST_TO_ADDR
// mc_turret_list := [ ] ;
41401: LD_ADDR_EXP 22
41405: PUSH
41406: EMPTY
41407: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
41408: LD_ADDR_EXP 23
41412: PUSH
41413: EMPTY
41414: ST_TO_ADDR
// mc_miners := [ ] ;
41415: LD_ADDR_EXP 28
41419: PUSH
41420: EMPTY
41421: ST_TO_ADDR
// mc_mines := [ ] ;
41422: LD_ADDR_EXP 27
41426: PUSH
41427: EMPTY
41428: ST_TO_ADDR
// mc_minefields := [ ] ;
41429: LD_ADDR_EXP 29
41433: PUSH
41434: EMPTY
41435: ST_TO_ADDR
// mc_crates := [ ] ;
41436: LD_ADDR_EXP 30
41440: PUSH
41441: EMPTY
41442: ST_TO_ADDR
// mc_crates_collector := [ ] ;
41443: LD_ADDR_EXP 31
41447: PUSH
41448: EMPTY
41449: ST_TO_ADDR
// mc_crates_area := [ ] ;
41450: LD_ADDR_EXP 32
41454: PUSH
41455: EMPTY
41456: ST_TO_ADDR
// mc_vehicles := [ ] ;
41457: LD_ADDR_EXP 33
41461: PUSH
41462: EMPTY
41463: ST_TO_ADDR
// mc_attack := [ ] ;
41464: LD_ADDR_EXP 34
41468: PUSH
41469: EMPTY
41470: ST_TO_ADDR
// mc_produce := [ ] ;
41471: LD_ADDR_EXP 35
41475: PUSH
41476: EMPTY
41477: ST_TO_ADDR
// mc_defender := [ ] ;
41478: LD_ADDR_EXP 36
41482: PUSH
41483: EMPTY
41484: ST_TO_ADDR
// mc_parking := [ ] ;
41485: LD_ADDR_EXP 38
41489: PUSH
41490: EMPTY
41491: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
41492: LD_ADDR_EXP 24
41496: PUSH
41497: EMPTY
41498: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
41499: LD_ADDR_EXP 26
41503: PUSH
41504: EMPTY
41505: ST_TO_ADDR
// mc_scan := [ ] ;
41506: LD_ADDR_EXP 37
41510: PUSH
41511: EMPTY
41512: ST_TO_ADDR
// mc_scan_area := [ ] ;
41513: LD_ADDR_EXP 39
41517: PUSH
41518: EMPTY
41519: ST_TO_ADDR
// mc_tech := [ ] ;
41520: LD_ADDR_EXP 41
41524: PUSH
41525: EMPTY
41526: ST_TO_ADDR
// mc_class := [ ] ;
41527: LD_ADDR_EXP 55
41531: PUSH
41532: EMPTY
41533: ST_TO_ADDR
// mc_class_case_use := [ ] ;
41534: LD_ADDR_EXP 56
41538: PUSH
41539: EMPTY
41540: ST_TO_ADDR
// end ;
41541: LD_VAR 0 1
41545: RET
// export function MC_Kill ( base ) ; begin
41546: LD_INT 0
41548: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
41549: LD_ADDR_EXP 14
41553: PUSH
41554: LD_EXP 14
41558: PPUSH
41559: LD_VAR 0 1
41563: PPUSH
41564: EMPTY
41565: PPUSH
41566: CALL_OW 1
41570: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
41571: LD_ADDR_EXP 15
41575: PUSH
41576: LD_EXP 15
41580: PPUSH
41581: LD_VAR 0 1
41585: PPUSH
41586: EMPTY
41587: PPUSH
41588: CALL_OW 1
41592: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
41593: LD_ADDR_EXP 16
41597: PUSH
41598: LD_EXP 16
41602: PPUSH
41603: LD_VAR 0 1
41607: PPUSH
41608: EMPTY
41609: PPUSH
41610: CALL_OW 1
41614: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
41615: LD_ADDR_EXP 17
41619: PUSH
41620: LD_EXP 17
41624: PPUSH
41625: LD_VAR 0 1
41629: PPUSH
41630: EMPTY
41631: PPUSH
41632: CALL_OW 1
41636: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
41637: LD_ADDR_EXP 18
41641: PUSH
41642: LD_EXP 18
41646: PPUSH
41647: LD_VAR 0 1
41651: PPUSH
41652: EMPTY
41653: PPUSH
41654: CALL_OW 1
41658: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
41659: LD_ADDR_EXP 19
41663: PUSH
41664: LD_EXP 19
41668: PPUSH
41669: LD_VAR 0 1
41673: PPUSH
41674: EMPTY
41675: PPUSH
41676: CALL_OW 1
41680: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
41681: LD_ADDR_EXP 20
41685: PUSH
41686: LD_EXP 20
41690: PPUSH
41691: LD_VAR 0 1
41695: PPUSH
41696: EMPTY
41697: PPUSH
41698: CALL_OW 1
41702: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
41703: LD_ADDR_EXP 21
41707: PUSH
41708: LD_EXP 21
41712: PPUSH
41713: LD_VAR 0 1
41717: PPUSH
41718: EMPTY
41719: PPUSH
41720: CALL_OW 1
41724: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41725: LD_ADDR_EXP 22
41729: PUSH
41730: LD_EXP 22
41734: PPUSH
41735: LD_VAR 0 1
41739: PPUSH
41740: EMPTY
41741: PPUSH
41742: CALL_OW 1
41746: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41747: LD_ADDR_EXP 23
41751: PUSH
41752: LD_EXP 23
41756: PPUSH
41757: LD_VAR 0 1
41761: PPUSH
41762: EMPTY
41763: PPUSH
41764: CALL_OW 1
41768: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41769: LD_ADDR_EXP 24
41773: PUSH
41774: LD_EXP 24
41778: PPUSH
41779: LD_VAR 0 1
41783: PPUSH
41784: EMPTY
41785: PPUSH
41786: CALL_OW 1
41790: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41791: LD_ADDR_EXP 25
41795: PUSH
41796: LD_EXP 25
41800: PPUSH
41801: LD_VAR 0 1
41805: PPUSH
41806: LD_INT 0
41808: PPUSH
41809: CALL_OW 1
41813: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41814: LD_ADDR_EXP 26
41818: PUSH
41819: LD_EXP 26
41823: PPUSH
41824: LD_VAR 0 1
41828: PPUSH
41829: EMPTY
41830: PPUSH
41831: CALL_OW 1
41835: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41836: LD_ADDR_EXP 27
41840: PUSH
41841: LD_EXP 27
41845: PPUSH
41846: LD_VAR 0 1
41850: PPUSH
41851: EMPTY
41852: PPUSH
41853: CALL_OW 1
41857: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41858: LD_ADDR_EXP 28
41862: PUSH
41863: LD_EXP 28
41867: PPUSH
41868: LD_VAR 0 1
41872: PPUSH
41873: EMPTY
41874: PPUSH
41875: CALL_OW 1
41879: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41880: LD_ADDR_EXP 29
41884: PUSH
41885: LD_EXP 29
41889: PPUSH
41890: LD_VAR 0 1
41894: PPUSH
41895: EMPTY
41896: PPUSH
41897: CALL_OW 1
41901: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41902: LD_ADDR_EXP 30
41906: PUSH
41907: LD_EXP 30
41911: PPUSH
41912: LD_VAR 0 1
41916: PPUSH
41917: EMPTY
41918: PPUSH
41919: CALL_OW 1
41923: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41924: LD_ADDR_EXP 31
41928: PUSH
41929: LD_EXP 31
41933: PPUSH
41934: LD_VAR 0 1
41938: PPUSH
41939: EMPTY
41940: PPUSH
41941: CALL_OW 1
41945: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41946: LD_ADDR_EXP 32
41950: PUSH
41951: LD_EXP 32
41955: PPUSH
41956: LD_VAR 0 1
41960: PPUSH
41961: EMPTY
41962: PPUSH
41963: CALL_OW 1
41967: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41968: LD_ADDR_EXP 33
41972: PUSH
41973: LD_EXP 33
41977: PPUSH
41978: LD_VAR 0 1
41982: PPUSH
41983: EMPTY
41984: PPUSH
41985: CALL_OW 1
41989: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41990: LD_ADDR_EXP 34
41994: PUSH
41995: LD_EXP 34
41999: PPUSH
42000: LD_VAR 0 1
42004: PPUSH
42005: EMPTY
42006: PPUSH
42007: CALL_OW 1
42011: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
42012: LD_ADDR_EXP 35
42016: PUSH
42017: LD_EXP 35
42021: PPUSH
42022: LD_VAR 0 1
42026: PPUSH
42027: EMPTY
42028: PPUSH
42029: CALL_OW 1
42033: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42034: LD_ADDR_EXP 36
42038: PUSH
42039: LD_EXP 36
42043: PPUSH
42044: LD_VAR 0 1
42048: PPUSH
42049: EMPTY
42050: PPUSH
42051: CALL_OW 1
42055: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
42056: LD_ADDR_EXP 37
42060: PUSH
42061: LD_EXP 37
42065: PPUSH
42066: LD_VAR 0 1
42070: PPUSH
42071: EMPTY
42072: PPUSH
42073: CALL_OW 1
42077: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
42078: LD_ADDR_EXP 38
42082: PUSH
42083: LD_EXP 38
42087: PPUSH
42088: LD_VAR 0 1
42092: PPUSH
42093: EMPTY
42094: PPUSH
42095: CALL_OW 1
42099: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
42100: LD_ADDR_EXP 39
42104: PUSH
42105: LD_EXP 39
42109: PPUSH
42110: LD_VAR 0 1
42114: PPUSH
42115: EMPTY
42116: PPUSH
42117: CALL_OW 1
42121: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
42122: LD_ADDR_EXP 41
42126: PUSH
42127: LD_EXP 41
42131: PPUSH
42132: LD_VAR 0 1
42136: PPUSH
42137: EMPTY
42138: PPUSH
42139: CALL_OW 1
42143: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
42144: LD_ADDR_EXP 43
42148: PUSH
42149: LD_EXP 43
42153: PPUSH
42154: LD_VAR 0 1
42158: PPUSH
42159: EMPTY
42160: PPUSH
42161: CALL_OW 1
42165: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
42166: LD_ADDR_EXP 44
42170: PUSH
42171: LD_EXP 44
42175: PPUSH
42176: LD_VAR 0 1
42180: PPUSH
42181: EMPTY
42182: PPUSH
42183: CALL_OW 1
42187: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
42188: LD_ADDR_EXP 45
42192: PUSH
42193: LD_EXP 45
42197: PPUSH
42198: LD_VAR 0 1
42202: PPUSH
42203: EMPTY
42204: PPUSH
42205: CALL_OW 1
42209: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
42210: LD_ADDR_EXP 46
42214: PUSH
42215: LD_EXP 46
42219: PPUSH
42220: LD_VAR 0 1
42224: PPUSH
42225: EMPTY
42226: PPUSH
42227: CALL_OW 1
42231: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
42232: LD_ADDR_EXP 47
42236: PUSH
42237: LD_EXP 47
42241: PPUSH
42242: LD_VAR 0 1
42246: PPUSH
42247: EMPTY
42248: PPUSH
42249: CALL_OW 1
42253: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
42254: LD_ADDR_EXP 48
42258: PUSH
42259: LD_EXP 48
42263: PPUSH
42264: LD_VAR 0 1
42268: PPUSH
42269: EMPTY
42270: PPUSH
42271: CALL_OW 1
42275: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
42276: LD_ADDR_EXP 49
42280: PUSH
42281: LD_EXP 49
42285: PPUSH
42286: LD_VAR 0 1
42290: PPUSH
42291: EMPTY
42292: PPUSH
42293: CALL_OW 1
42297: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
42298: LD_ADDR_EXP 50
42302: PUSH
42303: LD_EXP 50
42307: PPUSH
42308: LD_VAR 0 1
42312: PPUSH
42313: EMPTY
42314: PPUSH
42315: CALL_OW 1
42319: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
42320: LD_ADDR_EXP 51
42324: PUSH
42325: LD_EXP 51
42329: PPUSH
42330: LD_VAR 0 1
42334: PPUSH
42335: EMPTY
42336: PPUSH
42337: CALL_OW 1
42341: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
42342: LD_ADDR_EXP 52
42346: PUSH
42347: LD_EXP 52
42351: PPUSH
42352: LD_VAR 0 1
42356: PPUSH
42357: EMPTY
42358: PPUSH
42359: CALL_OW 1
42363: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
42364: LD_ADDR_EXP 53
42368: PUSH
42369: LD_EXP 53
42373: PPUSH
42374: LD_VAR 0 1
42378: PPUSH
42379: EMPTY
42380: PPUSH
42381: CALL_OW 1
42385: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
42386: LD_ADDR_EXP 54
42390: PUSH
42391: LD_EXP 54
42395: PPUSH
42396: LD_VAR 0 1
42400: PPUSH
42401: EMPTY
42402: PPUSH
42403: CALL_OW 1
42407: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
42408: LD_ADDR_EXP 55
42412: PUSH
42413: LD_EXP 55
42417: PPUSH
42418: LD_VAR 0 1
42422: PPUSH
42423: EMPTY
42424: PPUSH
42425: CALL_OW 1
42429: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
42430: LD_ADDR_EXP 56
42434: PUSH
42435: LD_EXP 56
42439: PPUSH
42440: LD_VAR 0 1
42444: PPUSH
42445: LD_INT 0
42447: PPUSH
42448: CALL_OW 1
42452: ST_TO_ADDR
// end ;
42453: LD_VAR 0 2
42457: RET
// export function MC_Add ( side , units ) ; var base ; begin
42458: LD_INT 0
42460: PPUSH
42461: PPUSH
// base := mc_bases + 1 ;
42462: LD_ADDR_VAR 0 4
42466: PUSH
42467: LD_EXP 14
42471: PUSH
42472: LD_INT 1
42474: PLUS
42475: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
42476: LD_ADDR_EXP 40
42480: PUSH
42481: LD_EXP 40
42485: PPUSH
42486: LD_VAR 0 4
42490: PPUSH
42491: LD_VAR 0 1
42495: PPUSH
42496: CALL_OW 1
42500: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
42501: LD_ADDR_EXP 14
42505: PUSH
42506: LD_EXP 14
42510: PPUSH
42511: LD_VAR 0 4
42515: PPUSH
42516: LD_VAR 0 2
42520: PPUSH
42521: CALL_OW 1
42525: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
42526: LD_ADDR_EXP 15
42530: PUSH
42531: LD_EXP 15
42535: PPUSH
42536: LD_VAR 0 4
42540: PPUSH
42541: EMPTY
42542: PPUSH
42543: CALL_OW 1
42547: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
42548: LD_ADDR_EXP 16
42552: PUSH
42553: LD_EXP 16
42557: PPUSH
42558: LD_VAR 0 4
42562: PPUSH
42563: EMPTY
42564: PPUSH
42565: CALL_OW 1
42569: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
42570: LD_ADDR_EXP 17
42574: PUSH
42575: LD_EXP 17
42579: PPUSH
42580: LD_VAR 0 4
42584: PPUSH
42585: EMPTY
42586: PPUSH
42587: CALL_OW 1
42591: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
42592: LD_ADDR_EXP 18
42596: PUSH
42597: LD_EXP 18
42601: PPUSH
42602: LD_VAR 0 4
42606: PPUSH
42607: EMPTY
42608: PPUSH
42609: CALL_OW 1
42613: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
42614: LD_ADDR_EXP 19
42618: PUSH
42619: LD_EXP 19
42623: PPUSH
42624: LD_VAR 0 4
42628: PPUSH
42629: EMPTY
42630: PPUSH
42631: CALL_OW 1
42635: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
42636: LD_ADDR_EXP 20
42640: PUSH
42641: LD_EXP 20
42645: PPUSH
42646: LD_VAR 0 4
42650: PPUSH
42651: EMPTY
42652: PPUSH
42653: CALL_OW 1
42657: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
42658: LD_ADDR_EXP 21
42662: PUSH
42663: LD_EXP 21
42667: PPUSH
42668: LD_VAR 0 4
42672: PPUSH
42673: EMPTY
42674: PPUSH
42675: CALL_OW 1
42679: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
42680: LD_ADDR_EXP 22
42684: PUSH
42685: LD_EXP 22
42689: PPUSH
42690: LD_VAR 0 4
42694: PPUSH
42695: EMPTY
42696: PPUSH
42697: CALL_OW 1
42701: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
42702: LD_ADDR_EXP 23
42706: PUSH
42707: LD_EXP 23
42711: PPUSH
42712: LD_VAR 0 4
42716: PPUSH
42717: EMPTY
42718: PPUSH
42719: CALL_OW 1
42723: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
42724: LD_ADDR_EXP 24
42728: PUSH
42729: LD_EXP 24
42733: PPUSH
42734: LD_VAR 0 4
42738: PPUSH
42739: EMPTY
42740: PPUSH
42741: CALL_OW 1
42745: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
42746: LD_ADDR_EXP 25
42750: PUSH
42751: LD_EXP 25
42755: PPUSH
42756: LD_VAR 0 4
42760: PPUSH
42761: LD_INT 0
42763: PPUSH
42764: CALL_OW 1
42768: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
42769: LD_ADDR_EXP 26
42773: PUSH
42774: LD_EXP 26
42778: PPUSH
42779: LD_VAR 0 4
42783: PPUSH
42784: EMPTY
42785: PPUSH
42786: CALL_OW 1
42790: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
42791: LD_ADDR_EXP 27
42795: PUSH
42796: LD_EXP 27
42800: PPUSH
42801: LD_VAR 0 4
42805: PPUSH
42806: EMPTY
42807: PPUSH
42808: CALL_OW 1
42812: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
42813: LD_ADDR_EXP 28
42817: PUSH
42818: LD_EXP 28
42822: PPUSH
42823: LD_VAR 0 4
42827: PPUSH
42828: EMPTY
42829: PPUSH
42830: CALL_OW 1
42834: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
42835: LD_ADDR_EXP 29
42839: PUSH
42840: LD_EXP 29
42844: PPUSH
42845: LD_VAR 0 4
42849: PPUSH
42850: EMPTY
42851: PPUSH
42852: CALL_OW 1
42856: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
42857: LD_ADDR_EXP 30
42861: PUSH
42862: LD_EXP 30
42866: PPUSH
42867: LD_VAR 0 4
42871: PPUSH
42872: EMPTY
42873: PPUSH
42874: CALL_OW 1
42878: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
42879: LD_ADDR_EXP 31
42883: PUSH
42884: LD_EXP 31
42888: PPUSH
42889: LD_VAR 0 4
42893: PPUSH
42894: EMPTY
42895: PPUSH
42896: CALL_OW 1
42900: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
42901: LD_ADDR_EXP 32
42905: PUSH
42906: LD_EXP 32
42910: PPUSH
42911: LD_VAR 0 4
42915: PPUSH
42916: EMPTY
42917: PPUSH
42918: CALL_OW 1
42922: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
42923: LD_ADDR_EXP 33
42927: PUSH
42928: LD_EXP 33
42932: PPUSH
42933: LD_VAR 0 4
42937: PPUSH
42938: EMPTY
42939: PPUSH
42940: CALL_OW 1
42944: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
42945: LD_ADDR_EXP 34
42949: PUSH
42950: LD_EXP 34
42954: PPUSH
42955: LD_VAR 0 4
42959: PPUSH
42960: EMPTY
42961: PPUSH
42962: CALL_OW 1
42966: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
42967: LD_ADDR_EXP 35
42971: PUSH
42972: LD_EXP 35
42976: PPUSH
42977: LD_VAR 0 4
42981: PPUSH
42982: EMPTY
42983: PPUSH
42984: CALL_OW 1
42988: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42989: LD_ADDR_EXP 36
42993: PUSH
42994: LD_EXP 36
42998: PPUSH
42999: LD_VAR 0 4
43003: PPUSH
43004: EMPTY
43005: PPUSH
43006: CALL_OW 1
43010: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
43011: LD_ADDR_EXP 37
43015: PUSH
43016: LD_EXP 37
43020: PPUSH
43021: LD_VAR 0 4
43025: PPUSH
43026: EMPTY
43027: PPUSH
43028: CALL_OW 1
43032: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
43033: LD_ADDR_EXP 38
43037: PUSH
43038: LD_EXP 38
43042: PPUSH
43043: LD_VAR 0 4
43047: PPUSH
43048: EMPTY
43049: PPUSH
43050: CALL_OW 1
43054: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
43055: LD_ADDR_EXP 39
43059: PUSH
43060: LD_EXP 39
43064: PPUSH
43065: LD_VAR 0 4
43069: PPUSH
43070: EMPTY
43071: PPUSH
43072: CALL_OW 1
43076: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
43077: LD_ADDR_EXP 41
43081: PUSH
43082: LD_EXP 41
43086: PPUSH
43087: LD_VAR 0 4
43091: PPUSH
43092: EMPTY
43093: PPUSH
43094: CALL_OW 1
43098: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
43099: LD_ADDR_EXP 43
43103: PUSH
43104: LD_EXP 43
43108: PPUSH
43109: LD_VAR 0 4
43113: PPUSH
43114: EMPTY
43115: PPUSH
43116: CALL_OW 1
43120: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
43121: LD_ADDR_EXP 44
43125: PUSH
43126: LD_EXP 44
43130: PPUSH
43131: LD_VAR 0 4
43135: PPUSH
43136: EMPTY
43137: PPUSH
43138: CALL_OW 1
43142: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43143: LD_ADDR_EXP 45
43147: PUSH
43148: LD_EXP 45
43152: PPUSH
43153: LD_VAR 0 4
43157: PPUSH
43158: EMPTY
43159: PPUSH
43160: CALL_OW 1
43164: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
43165: LD_ADDR_EXP 46
43169: PUSH
43170: LD_EXP 46
43174: PPUSH
43175: LD_VAR 0 4
43179: PPUSH
43180: EMPTY
43181: PPUSH
43182: CALL_OW 1
43186: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
43187: LD_ADDR_EXP 47
43191: PUSH
43192: LD_EXP 47
43196: PPUSH
43197: LD_VAR 0 4
43201: PPUSH
43202: EMPTY
43203: PPUSH
43204: CALL_OW 1
43208: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
43209: LD_ADDR_EXP 48
43213: PUSH
43214: LD_EXP 48
43218: PPUSH
43219: LD_VAR 0 4
43223: PPUSH
43224: EMPTY
43225: PPUSH
43226: CALL_OW 1
43230: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
43231: LD_ADDR_EXP 49
43235: PUSH
43236: LD_EXP 49
43240: PPUSH
43241: LD_VAR 0 4
43245: PPUSH
43246: EMPTY
43247: PPUSH
43248: CALL_OW 1
43252: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
43253: LD_ADDR_EXP 50
43257: PUSH
43258: LD_EXP 50
43262: PPUSH
43263: LD_VAR 0 4
43267: PPUSH
43268: EMPTY
43269: PPUSH
43270: CALL_OW 1
43274: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
43275: LD_ADDR_EXP 51
43279: PUSH
43280: LD_EXP 51
43284: PPUSH
43285: LD_VAR 0 4
43289: PPUSH
43290: EMPTY
43291: PPUSH
43292: CALL_OW 1
43296: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
43297: LD_ADDR_EXP 52
43301: PUSH
43302: LD_EXP 52
43306: PPUSH
43307: LD_VAR 0 4
43311: PPUSH
43312: EMPTY
43313: PPUSH
43314: CALL_OW 1
43318: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
43319: LD_ADDR_EXP 53
43323: PUSH
43324: LD_EXP 53
43328: PPUSH
43329: LD_VAR 0 4
43333: PPUSH
43334: EMPTY
43335: PPUSH
43336: CALL_OW 1
43340: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
43341: LD_ADDR_EXP 54
43345: PUSH
43346: LD_EXP 54
43350: PPUSH
43351: LD_VAR 0 4
43355: PPUSH
43356: EMPTY
43357: PPUSH
43358: CALL_OW 1
43362: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
43363: LD_ADDR_EXP 55
43367: PUSH
43368: LD_EXP 55
43372: PPUSH
43373: LD_VAR 0 4
43377: PPUSH
43378: EMPTY
43379: PPUSH
43380: CALL_OW 1
43384: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
43385: LD_ADDR_EXP 56
43389: PUSH
43390: LD_EXP 56
43394: PPUSH
43395: LD_VAR 0 4
43399: PPUSH
43400: LD_INT 0
43402: PPUSH
43403: CALL_OW 1
43407: ST_TO_ADDR
// result := base ;
43408: LD_ADDR_VAR 0 3
43412: PUSH
43413: LD_VAR 0 4
43417: ST_TO_ADDR
// end ;
43418: LD_VAR 0 3
43422: RET
// export function MC_Start ( ) ; var i ; begin
43423: LD_INT 0
43425: PPUSH
43426: PPUSH
// for i = 1 to mc_bases do
43427: LD_ADDR_VAR 0 2
43431: PUSH
43432: DOUBLE
43433: LD_INT 1
43435: DEC
43436: ST_TO_ADDR
43437: LD_EXP 14
43441: PUSH
43442: FOR_TO
43443: IFFALSE 44520
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
43445: LD_ADDR_EXP 14
43449: PUSH
43450: LD_EXP 14
43454: PPUSH
43455: LD_VAR 0 2
43459: PPUSH
43460: LD_EXP 14
43464: PUSH
43465: LD_VAR 0 2
43469: ARRAY
43470: PUSH
43471: LD_INT 0
43473: DIFF
43474: PPUSH
43475: CALL_OW 1
43479: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
43480: LD_ADDR_EXP 15
43484: PUSH
43485: LD_EXP 15
43489: PPUSH
43490: LD_VAR 0 2
43494: PPUSH
43495: EMPTY
43496: PPUSH
43497: CALL_OW 1
43501: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43502: LD_ADDR_EXP 16
43506: PUSH
43507: LD_EXP 16
43511: PPUSH
43512: LD_VAR 0 2
43516: PPUSH
43517: EMPTY
43518: PPUSH
43519: CALL_OW 1
43523: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
43524: LD_ADDR_EXP 17
43528: PUSH
43529: LD_EXP 17
43533: PPUSH
43534: LD_VAR 0 2
43538: PPUSH
43539: EMPTY
43540: PPUSH
43541: CALL_OW 1
43545: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
43546: LD_ADDR_EXP 18
43550: PUSH
43551: LD_EXP 18
43555: PPUSH
43556: LD_VAR 0 2
43560: PPUSH
43561: EMPTY
43562: PUSH
43563: EMPTY
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PPUSH
43569: CALL_OW 1
43573: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
43574: LD_ADDR_EXP 19
43578: PUSH
43579: LD_EXP 19
43583: PPUSH
43584: LD_VAR 0 2
43588: PPUSH
43589: EMPTY
43590: PPUSH
43591: CALL_OW 1
43595: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
43596: LD_ADDR_EXP 46
43600: PUSH
43601: LD_EXP 46
43605: PPUSH
43606: LD_VAR 0 2
43610: PPUSH
43611: EMPTY
43612: PPUSH
43613: CALL_OW 1
43617: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
43618: LD_ADDR_EXP 20
43622: PUSH
43623: LD_EXP 20
43627: PPUSH
43628: LD_VAR 0 2
43632: PPUSH
43633: EMPTY
43634: PPUSH
43635: CALL_OW 1
43639: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
43640: LD_ADDR_EXP 21
43644: PUSH
43645: LD_EXP 21
43649: PPUSH
43650: LD_VAR 0 2
43654: PPUSH
43655: EMPTY
43656: PPUSH
43657: CALL_OW 1
43661: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
43662: LD_ADDR_EXP 22
43666: PUSH
43667: LD_EXP 22
43671: PPUSH
43672: LD_VAR 0 2
43676: PPUSH
43677: LD_EXP 14
43681: PUSH
43682: LD_VAR 0 2
43686: ARRAY
43687: PPUSH
43688: LD_INT 2
43690: PUSH
43691: LD_INT 30
43693: PUSH
43694: LD_INT 32
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 30
43703: PUSH
43704: LD_INT 33
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: LIST
43715: PPUSH
43716: CALL_OW 72
43720: PPUSH
43721: CALL_OW 1
43725: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
43726: LD_ADDR_EXP 23
43730: PUSH
43731: LD_EXP 23
43735: PPUSH
43736: LD_VAR 0 2
43740: PPUSH
43741: LD_EXP 14
43745: PUSH
43746: LD_VAR 0 2
43750: ARRAY
43751: PPUSH
43752: LD_INT 2
43754: PUSH
43755: LD_INT 30
43757: PUSH
43758: LD_INT 32
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 30
43767: PUSH
43768: LD_INT 31
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: LIST
43779: PUSH
43780: LD_INT 58
43782: PUSH
43783: EMPTY
43784: LIST
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PPUSH
43790: CALL_OW 72
43794: PPUSH
43795: CALL_OW 1
43799: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
43800: LD_ADDR_EXP 24
43804: PUSH
43805: LD_EXP 24
43809: PPUSH
43810: LD_VAR 0 2
43814: PPUSH
43815: EMPTY
43816: PPUSH
43817: CALL_OW 1
43821: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
43822: LD_ADDR_EXP 28
43826: PUSH
43827: LD_EXP 28
43831: PPUSH
43832: LD_VAR 0 2
43836: PPUSH
43837: EMPTY
43838: PPUSH
43839: CALL_OW 1
43843: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
43844: LD_ADDR_EXP 27
43848: PUSH
43849: LD_EXP 27
43853: PPUSH
43854: LD_VAR 0 2
43858: PPUSH
43859: EMPTY
43860: PPUSH
43861: CALL_OW 1
43865: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
43866: LD_ADDR_EXP 29
43870: PUSH
43871: LD_EXP 29
43875: PPUSH
43876: LD_VAR 0 2
43880: PPUSH
43881: EMPTY
43882: PPUSH
43883: CALL_OW 1
43887: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
43888: LD_ADDR_EXP 30
43892: PUSH
43893: LD_EXP 30
43897: PPUSH
43898: LD_VAR 0 2
43902: PPUSH
43903: EMPTY
43904: PPUSH
43905: CALL_OW 1
43909: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
43910: LD_ADDR_EXP 31
43914: PUSH
43915: LD_EXP 31
43919: PPUSH
43920: LD_VAR 0 2
43924: PPUSH
43925: EMPTY
43926: PPUSH
43927: CALL_OW 1
43931: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
43932: LD_ADDR_EXP 32
43936: PUSH
43937: LD_EXP 32
43941: PPUSH
43942: LD_VAR 0 2
43946: PPUSH
43947: EMPTY
43948: PPUSH
43949: CALL_OW 1
43953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
43954: LD_ADDR_EXP 33
43958: PUSH
43959: LD_EXP 33
43963: PPUSH
43964: LD_VAR 0 2
43968: PPUSH
43969: EMPTY
43970: PPUSH
43971: CALL_OW 1
43975: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
43976: LD_ADDR_EXP 34
43980: PUSH
43981: LD_EXP 34
43985: PPUSH
43986: LD_VAR 0 2
43990: PPUSH
43991: EMPTY
43992: PPUSH
43993: CALL_OW 1
43997: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
43998: LD_ADDR_EXP 35
44002: PUSH
44003: LD_EXP 35
44007: PPUSH
44008: LD_VAR 0 2
44012: PPUSH
44013: EMPTY
44014: PPUSH
44015: CALL_OW 1
44019: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
44020: LD_ADDR_EXP 36
44024: PUSH
44025: LD_EXP 36
44029: PPUSH
44030: LD_VAR 0 2
44034: PPUSH
44035: EMPTY
44036: PPUSH
44037: CALL_OW 1
44041: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
44042: LD_ADDR_EXP 25
44046: PUSH
44047: LD_EXP 25
44051: PPUSH
44052: LD_VAR 0 2
44056: PPUSH
44057: LD_INT 0
44059: PPUSH
44060: CALL_OW 1
44064: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
44065: LD_ADDR_EXP 38
44069: PUSH
44070: LD_EXP 38
44074: PPUSH
44075: LD_VAR 0 2
44079: PPUSH
44080: LD_INT 0
44082: PPUSH
44083: CALL_OW 1
44087: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
44088: LD_ADDR_EXP 26
44092: PUSH
44093: LD_EXP 26
44097: PPUSH
44098: LD_VAR 0 2
44102: PPUSH
44103: EMPTY
44104: PPUSH
44105: CALL_OW 1
44109: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
44110: LD_ADDR_EXP 37
44114: PUSH
44115: LD_EXP 37
44119: PPUSH
44120: LD_VAR 0 2
44124: PPUSH
44125: LD_INT 0
44127: PPUSH
44128: CALL_OW 1
44132: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
44133: LD_ADDR_EXP 39
44137: PUSH
44138: LD_EXP 39
44142: PPUSH
44143: LD_VAR 0 2
44147: PPUSH
44148: EMPTY
44149: PPUSH
44150: CALL_OW 1
44154: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
44155: LD_ADDR_EXP 42
44159: PUSH
44160: LD_EXP 42
44164: PPUSH
44165: LD_VAR 0 2
44169: PPUSH
44170: LD_INT 0
44172: PPUSH
44173: CALL_OW 1
44177: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
44178: LD_ADDR_EXP 43
44182: PUSH
44183: LD_EXP 43
44187: PPUSH
44188: LD_VAR 0 2
44192: PPUSH
44193: EMPTY
44194: PPUSH
44195: CALL_OW 1
44199: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44200: LD_ADDR_EXP 44
44204: PUSH
44205: LD_EXP 44
44209: PPUSH
44210: LD_VAR 0 2
44214: PPUSH
44215: EMPTY
44216: PPUSH
44217: CALL_OW 1
44221: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44222: LD_ADDR_EXP 45
44226: PUSH
44227: LD_EXP 45
44231: PPUSH
44232: LD_VAR 0 2
44236: PPUSH
44237: EMPTY
44238: PPUSH
44239: CALL_OW 1
44243: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
44244: LD_ADDR_EXP 47
44248: PUSH
44249: LD_EXP 47
44253: PPUSH
44254: LD_VAR 0 2
44258: PPUSH
44259: LD_EXP 14
44263: PUSH
44264: LD_VAR 0 2
44268: ARRAY
44269: PPUSH
44270: LD_INT 2
44272: PUSH
44273: LD_INT 30
44275: PUSH
44276: LD_INT 6
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 30
44285: PUSH
44286: LD_INT 7
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 30
44295: PUSH
44296: LD_INT 8
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: PPUSH
44309: CALL_OW 72
44313: PPUSH
44314: CALL_OW 1
44318: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
44319: LD_ADDR_EXP 48
44323: PUSH
44324: LD_EXP 48
44328: PPUSH
44329: LD_VAR 0 2
44333: PPUSH
44334: EMPTY
44335: PPUSH
44336: CALL_OW 1
44340: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
44341: LD_ADDR_EXP 49
44345: PUSH
44346: LD_EXP 49
44350: PPUSH
44351: LD_VAR 0 2
44355: PPUSH
44356: EMPTY
44357: PPUSH
44358: CALL_OW 1
44362: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
44363: LD_ADDR_EXP 50
44367: PUSH
44368: LD_EXP 50
44372: PPUSH
44373: LD_VAR 0 2
44377: PPUSH
44378: EMPTY
44379: PPUSH
44380: CALL_OW 1
44384: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
44385: LD_ADDR_EXP 51
44389: PUSH
44390: LD_EXP 51
44394: PPUSH
44395: LD_VAR 0 2
44399: PPUSH
44400: EMPTY
44401: PPUSH
44402: CALL_OW 1
44406: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44407: LD_ADDR_EXP 52
44411: PUSH
44412: LD_EXP 52
44416: PPUSH
44417: LD_VAR 0 2
44421: PPUSH
44422: EMPTY
44423: PPUSH
44424: CALL_OW 1
44428: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
44429: LD_ADDR_EXP 53
44433: PUSH
44434: LD_EXP 53
44438: PPUSH
44439: LD_VAR 0 2
44443: PPUSH
44444: EMPTY
44445: PPUSH
44446: CALL_OW 1
44450: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
44451: LD_ADDR_EXP 54
44455: PUSH
44456: LD_EXP 54
44460: PPUSH
44461: LD_VAR 0 2
44465: PPUSH
44466: EMPTY
44467: PPUSH
44468: CALL_OW 1
44472: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
44473: LD_ADDR_EXP 55
44477: PUSH
44478: LD_EXP 55
44482: PPUSH
44483: LD_VAR 0 2
44487: PPUSH
44488: EMPTY
44489: PPUSH
44490: CALL_OW 1
44494: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
44495: LD_ADDR_EXP 56
44499: PUSH
44500: LD_EXP 56
44504: PPUSH
44505: LD_VAR 0 2
44509: PPUSH
44510: LD_INT 0
44512: PPUSH
44513: CALL_OW 1
44517: ST_TO_ADDR
// end ;
44518: GO 43442
44520: POP
44521: POP
// MC_InitSides ( ) ;
44522: CALL 44808 0 0
// MC_InitResearch ( ) ;
44526: CALL 44547 0 0
// CustomInitMacro ( ) ;
44530: CALL 250 0 0
// skirmish := true ;
44534: LD_ADDR_EXP 12
44538: PUSH
44539: LD_INT 1
44541: ST_TO_ADDR
// end ;
44542: LD_VAR 0 1
44546: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
44547: LD_INT 0
44549: PPUSH
44550: PPUSH
44551: PPUSH
44552: PPUSH
44553: PPUSH
44554: PPUSH
// if not mc_bases then
44555: LD_EXP 14
44559: NOT
44560: IFFALSE 44564
// exit ;
44562: GO 44803
// for i = 1 to 8 do
44564: LD_ADDR_VAR 0 2
44568: PUSH
44569: DOUBLE
44570: LD_INT 1
44572: DEC
44573: ST_TO_ADDR
44574: LD_INT 8
44576: PUSH
44577: FOR_TO
44578: IFFALSE 44604
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
44580: LD_ADDR_EXP 41
44584: PUSH
44585: LD_EXP 41
44589: PPUSH
44590: LD_VAR 0 2
44594: PPUSH
44595: EMPTY
44596: PPUSH
44597: CALL_OW 1
44601: ST_TO_ADDR
44602: GO 44577
44604: POP
44605: POP
// tmp := [ ] ;
44606: LD_ADDR_VAR 0 5
44610: PUSH
44611: EMPTY
44612: ST_TO_ADDR
// for i = 1 to mc_sides do
44613: LD_ADDR_VAR 0 2
44617: PUSH
44618: DOUBLE
44619: LD_INT 1
44621: DEC
44622: ST_TO_ADDR
44623: LD_EXP 40
44627: PUSH
44628: FOR_TO
44629: IFFALSE 44687
// if not mc_sides [ i ] in tmp then
44631: LD_EXP 40
44635: PUSH
44636: LD_VAR 0 2
44640: ARRAY
44641: PUSH
44642: LD_VAR 0 5
44646: IN
44647: NOT
44648: IFFALSE 44685
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
44650: LD_ADDR_VAR 0 5
44654: PUSH
44655: LD_VAR 0 5
44659: PPUSH
44660: LD_VAR 0 5
44664: PUSH
44665: LD_INT 1
44667: PLUS
44668: PPUSH
44669: LD_EXP 40
44673: PUSH
44674: LD_VAR 0 2
44678: ARRAY
44679: PPUSH
44680: CALL_OW 2
44684: ST_TO_ADDR
44685: GO 44628
44687: POP
44688: POP
// if not tmp then
44689: LD_VAR 0 5
44693: NOT
44694: IFFALSE 44698
// exit ;
44696: GO 44803
// for j in tmp do
44698: LD_ADDR_VAR 0 3
44702: PUSH
44703: LD_VAR 0 5
44707: PUSH
44708: FOR_IN
44709: IFFALSE 44801
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
44711: LD_ADDR_VAR 0 6
44715: PUSH
44716: LD_INT 22
44718: PUSH
44719: LD_VAR 0 3
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PPUSH
44728: CALL_OW 69
44732: ST_TO_ADDR
// if not un then
44733: LD_VAR 0 6
44737: NOT
44738: IFFALSE 44742
// continue ;
44740: GO 44708
// nation := GetNation ( un [ 1 ] ) ;
44742: LD_ADDR_VAR 0 4
44746: PUSH
44747: LD_VAR 0 6
44751: PUSH
44752: LD_INT 1
44754: ARRAY
44755: PPUSH
44756: CALL_OW 248
44760: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
44761: LD_ADDR_EXP 41
44765: PUSH
44766: LD_EXP 41
44770: PPUSH
44771: LD_VAR 0 3
44775: PPUSH
44776: LD_VAR 0 3
44780: PPUSH
44781: LD_VAR 0 4
44785: PPUSH
44786: LD_INT 1
44788: PPUSH
44789: CALL 4562 0 3
44793: PPUSH
44794: CALL_OW 1
44798: ST_TO_ADDR
// end ;
44799: GO 44708
44801: POP
44802: POP
// end ;
44803: LD_VAR 0 1
44807: RET
// export function MC_InitSides ( ) ; var i ; begin
44808: LD_INT 0
44810: PPUSH
44811: PPUSH
// if not mc_bases then
44812: LD_EXP 14
44816: NOT
44817: IFFALSE 44821
// exit ;
44819: GO 44895
// for i = 1 to mc_bases do
44821: LD_ADDR_VAR 0 2
44825: PUSH
44826: DOUBLE
44827: LD_INT 1
44829: DEC
44830: ST_TO_ADDR
44831: LD_EXP 14
44835: PUSH
44836: FOR_TO
44837: IFFALSE 44893
// if mc_bases [ i ] then
44839: LD_EXP 14
44843: PUSH
44844: LD_VAR 0 2
44848: ARRAY
44849: IFFALSE 44891
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
44851: LD_ADDR_EXP 40
44855: PUSH
44856: LD_EXP 40
44860: PPUSH
44861: LD_VAR 0 2
44865: PPUSH
44866: LD_EXP 14
44870: PUSH
44871: LD_VAR 0 2
44875: ARRAY
44876: PUSH
44877: LD_INT 1
44879: ARRAY
44880: PPUSH
44881: CALL_OW 255
44885: PPUSH
44886: CALL_OW 1
44890: ST_TO_ADDR
44891: GO 44836
44893: POP
44894: POP
// end ;
44895: LD_VAR 0 1
44899: RET
// every 0 0$01 trigger skirmish do
44900: LD_EXP 12
44904: IFFALSE 45058
44906: GO 44908
44908: DISABLE
// begin enable ;
44909: ENABLE
// MC_CheckBuildings ( ) ;
44910: CALL 49556 0 0
// MC_CheckPeopleLife ( ) ;
44914: CALL 49681 0 0
// RaiseSailEvent ( 100 ) ;
44918: LD_INT 100
44920: PPUSH
44921: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
44925: LD_INT 103
44927: PPUSH
44928: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
44932: LD_INT 104
44934: PPUSH
44935: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
44939: LD_INT 105
44941: PPUSH
44942: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
44946: LD_INT 106
44948: PPUSH
44949: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
44953: LD_INT 107
44955: PPUSH
44956: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
44960: LD_INT 108
44962: PPUSH
44963: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
44967: LD_INT 109
44969: PPUSH
44970: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
44974: LD_INT 110
44976: PPUSH
44977: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
44981: LD_INT 111
44983: PPUSH
44984: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
44988: LD_INT 112
44990: PPUSH
44991: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
44995: LD_INT 113
44997: PPUSH
44998: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
45002: LD_INT 120
45004: PPUSH
45005: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
45009: LD_INT 121
45011: PPUSH
45012: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
45016: LD_INT 122
45018: PPUSH
45019: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
45023: LD_INT 123
45025: PPUSH
45026: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
45030: LD_INT 124
45032: PPUSH
45033: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
45037: LD_INT 125
45039: PPUSH
45040: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
45044: LD_INT 126
45046: PPUSH
45047: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
45051: LD_INT 200
45053: PPUSH
45054: CALL_OW 427
// end ;
45058: END
// on SailEvent ( event ) do begin if event < 100 then
45059: LD_VAR 0 1
45063: PUSH
45064: LD_INT 100
45066: LESS
45067: IFFALSE 45078
// CustomEvent ( event ) ;
45069: LD_VAR 0 1
45073: PPUSH
45074: CALL 4461 0 1
// if event = 100 then
45078: LD_VAR 0 1
45082: PUSH
45083: LD_INT 100
45085: EQUAL
45086: IFFALSE 45092
// MC_ClassManager ( ) ;
45088: CALL 45484 0 0
// if event = 101 then
45092: LD_VAR 0 1
45096: PUSH
45097: LD_INT 101
45099: EQUAL
45100: IFFALSE 45106
// MC_RepairBuildings ( ) ;
45102: CALL 50266 0 0
// if event = 102 then
45106: LD_VAR 0 1
45110: PUSH
45111: LD_INT 102
45113: EQUAL
45114: IFFALSE 45120
// MC_Heal ( ) ;
45116: CALL 51125 0 0
// if event = 103 then
45120: LD_VAR 0 1
45124: PUSH
45125: LD_INT 103
45127: EQUAL
45128: IFFALSE 45134
// MC_Build ( ) ;
45130: CALL 51547 0 0
// if event = 104 then
45134: LD_VAR 0 1
45138: PUSH
45139: LD_INT 104
45141: EQUAL
45142: IFFALSE 45148
// MC_TurretWeapon ( ) ;
45144: CALL 53160 0 0
// if event = 105 then
45148: LD_VAR 0 1
45152: PUSH
45153: LD_INT 105
45155: EQUAL
45156: IFFALSE 45162
// MC_BuildUpgrade ( ) ;
45158: CALL 52711 0 0
// if event = 106 then
45162: LD_VAR 0 1
45166: PUSH
45167: LD_INT 106
45169: EQUAL
45170: IFFALSE 45176
// MC_PlantMines ( ) ;
45172: CALL 53590 0 0
// if event = 107 then
45176: LD_VAR 0 1
45180: PUSH
45181: LD_INT 107
45183: EQUAL
45184: IFFALSE 45190
// MC_CollectCrates ( ) ;
45186: CALL 54388 0 0
// if event = 108 then
45190: LD_VAR 0 1
45194: PUSH
45195: LD_INT 108
45197: EQUAL
45198: IFFALSE 45204
// MC_LinkRemoteControl ( ) ;
45200: CALL 56164 0 0
// if event = 109 then
45204: LD_VAR 0 1
45208: PUSH
45209: LD_INT 109
45211: EQUAL
45212: IFFALSE 45218
// MC_ProduceVehicle ( ) ;
45214: CALL 56345 0 0
// if event = 110 then
45218: LD_VAR 0 1
45222: PUSH
45223: LD_INT 110
45225: EQUAL
45226: IFFALSE 45232
// MC_SendAttack ( ) ;
45228: CALL 56811 0 0
// if event = 111 then
45232: LD_VAR 0 1
45236: PUSH
45237: LD_INT 111
45239: EQUAL
45240: IFFALSE 45246
// MC_Defend ( ) ;
45242: CALL 56919 0 0
// if event = 112 then
45246: LD_VAR 0 1
45250: PUSH
45251: LD_INT 112
45253: EQUAL
45254: IFFALSE 45260
// MC_Research ( ) ;
45256: CALL 57524 0 0
// if event = 113 then
45260: LD_VAR 0 1
45264: PUSH
45265: LD_INT 113
45267: EQUAL
45268: IFFALSE 45274
// MC_MinesTrigger ( ) ;
45270: CALL 58638 0 0
// if event = 120 then
45274: LD_VAR 0 1
45278: PUSH
45279: LD_INT 120
45281: EQUAL
45282: IFFALSE 45288
// MC_RepairVehicle ( ) ;
45284: CALL 58737 0 0
// if event = 121 then
45288: LD_VAR 0 1
45292: PUSH
45293: LD_INT 121
45295: EQUAL
45296: IFFALSE 45302
// MC_TameApe ( ) ;
45298: CALL 59467 0 0
// if event = 122 then
45302: LD_VAR 0 1
45306: PUSH
45307: LD_INT 122
45309: EQUAL
45310: IFFALSE 45316
// MC_ChangeApeClass ( ) ;
45312: CALL 60296 0 0
// if event = 123 then
45316: LD_VAR 0 1
45320: PUSH
45321: LD_INT 123
45323: EQUAL
45324: IFFALSE 45330
// MC_Bazooka ( ) ;
45326: CALL 60946 0 0
// if event = 124 then
45330: LD_VAR 0 1
45334: PUSH
45335: LD_INT 124
45337: EQUAL
45338: IFFALSE 45344
// MC_TeleportExit ( ) ;
45340: CALL 61144 0 0
// if event = 125 then
45344: LD_VAR 0 1
45348: PUSH
45349: LD_INT 125
45351: EQUAL
45352: IFFALSE 45358
// MC_Deposits ( ) ;
45354: CALL 61791 0 0
// if event = 126 then
45358: LD_VAR 0 1
45362: PUSH
45363: LD_INT 126
45365: EQUAL
45366: IFFALSE 45372
// MC_RemoteDriver ( ) ;
45368: CALL 62416 0 0
// if event = 200 then
45372: LD_VAR 0 1
45376: PUSH
45377: LD_INT 200
45379: EQUAL
45380: IFFALSE 45386
// MC_Idle ( ) ;
45382: CALL 64365 0 0
// end ;
45386: PPOPN 1
45388: END
// export function MC_Reset ( base , tag ) ; var i ; begin
45389: LD_INT 0
45391: PPUSH
45392: PPUSH
// if not mc_bases [ base ] or not tag then
45393: LD_EXP 14
45397: PUSH
45398: LD_VAR 0 1
45402: ARRAY
45403: NOT
45404: PUSH
45405: LD_VAR 0 2
45409: NOT
45410: OR
45411: IFFALSE 45415
// exit ;
45413: GO 45479
// for i in mc_bases [ base ] union mc_ape [ base ] do
45415: LD_ADDR_VAR 0 4
45419: PUSH
45420: LD_EXP 14
45424: PUSH
45425: LD_VAR 0 1
45429: ARRAY
45430: PUSH
45431: LD_EXP 43
45435: PUSH
45436: LD_VAR 0 1
45440: ARRAY
45441: UNION
45442: PUSH
45443: FOR_IN
45444: IFFALSE 45477
// if GetTag ( i ) = tag then
45446: LD_VAR 0 4
45450: PPUSH
45451: CALL_OW 110
45455: PUSH
45456: LD_VAR 0 2
45460: EQUAL
45461: IFFALSE 45475
// SetTag ( i , 0 ) ;
45463: LD_VAR 0 4
45467: PPUSH
45468: LD_INT 0
45470: PPUSH
45471: CALL_OW 109
45475: GO 45443
45477: POP
45478: POP
// end ;
45479: LD_VAR 0 3
45483: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
45484: LD_INT 0
45486: PPUSH
45487: PPUSH
45488: PPUSH
45489: PPUSH
45490: PPUSH
45491: PPUSH
45492: PPUSH
45493: PPUSH
// if not mc_bases then
45494: LD_EXP 14
45498: NOT
45499: IFFALSE 45503
// exit ;
45501: GO 45961
// for i = 1 to mc_bases do
45503: LD_ADDR_VAR 0 2
45507: PUSH
45508: DOUBLE
45509: LD_INT 1
45511: DEC
45512: ST_TO_ADDR
45513: LD_EXP 14
45517: PUSH
45518: FOR_TO
45519: IFFALSE 45959
// begin tmp := MC_ClassCheckReq ( i ) ;
45521: LD_ADDR_VAR 0 4
45525: PUSH
45526: LD_VAR 0 2
45530: PPUSH
45531: CALL 45966 0 1
45535: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
45536: LD_ADDR_EXP 55
45540: PUSH
45541: LD_EXP 55
45545: PPUSH
45546: LD_VAR 0 2
45550: PPUSH
45551: LD_VAR 0 4
45555: PPUSH
45556: CALL_OW 1
45560: ST_TO_ADDR
// if not tmp then
45561: LD_VAR 0 4
45565: NOT
45566: IFFALSE 45570
// continue ;
45568: GO 45518
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
45570: LD_ADDR_VAR 0 6
45574: PUSH
45575: LD_EXP 14
45579: PUSH
45580: LD_VAR 0 2
45584: ARRAY
45585: PPUSH
45586: LD_INT 2
45588: PUSH
45589: LD_INT 30
45591: PUSH
45592: LD_INT 4
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 30
45601: PUSH
45602: LD_INT 5
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: LIST
45613: PPUSH
45614: CALL_OW 72
45618: PUSH
45619: LD_EXP 14
45623: PUSH
45624: LD_VAR 0 2
45628: ARRAY
45629: PPUSH
45630: LD_INT 2
45632: PUSH
45633: LD_INT 30
45635: PUSH
45636: LD_INT 0
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PUSH
45643: LD_INT 30
45645: PUSH
45646: LD_INT 1
45648: PUSH
45649: EMPTY
45650: LIST
45651: LIST
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: LIST
45657: PPUSH
45658: CALL_OW 72
45662: PUSH
45663: LD_EXP 14
45667: PUSH
45668: LD_VAR 0 2
45672: ARRAY
45673: PPUSH
45674: LD_INT 30
45676: PUSH
45677: LD_INT 3
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PPUSH
45684: CALL_OW 72
45688: PUSH
45689: LD_EXP 14
45693: PUSH
45694: LD_VAR 0 2
45698: ARRAY
45699: PPUSH
45700: LD_INT 2
45702: PUSH
45703: LD_INT 30
45705: PUSH
45706: LD_INT 6
45708: PUSH
45709: EMPTY
45710: LIST
45711: LIST
45712: PUSH
45713: LD_INT 30
45715: PUSH
45716: LD_INT 7
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: PUSH
45723: LD_INT 30
45725: PUSH
45726: LD_INT 8
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: LIST
45737: LIST
45738: PPUSH
45739: CALL_OW 72
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: ST_TO_ADDR
// for j = 1 to 4 do
45750: LD_ADDR_VAR 0 3
45754: PUSH
45755: DOUBLE
45756: LD_INT 1
45758: DEC
45759: ST_TO_ADDR
45760: LD_INT 4
45762: PUSH
45763: FOR_TO
45764: IFFALSE 45955
// begin if not tmp [ j ] then
45766: LD_VAR 0 4
45770: PUSH
45771: LD_VAR 0 3
45775: ARRAY
45776: NOT
45777: IFFALSE 45781
// continue ;
45779: GO 45763
// for p in tmp [ j ] do
45781: LD_ADDR_VAR 0 5
45785: PUSH
45786: LD_VAR 0 4
45790: PUSH
45791: LD_VAR 0 3
45795: ARRAY
45796: PUSH
45797: FOR_IN
45798: IFFALSE 45951
// begin if not b [ j ] then
45800: LD_VAR 0 6
45804: PUSH
45805: LD_VAR 0 3
45809: ARRAY
45810: NOT
45811: IFFALSE 45815
// break ;
45813: GO 45951
// e := 0 ;
45815: LD_ADDR_VAR 0 7
45819: PUSH
45820: LD_INT 0
45822: ST_TO_ADDR
// for k in b [ j ] do
45823: LD_ADDR_VAR 0 8
45827: PUSH
45828: LD_VAR 0 6
45832: PUSH
45833: LD_VAR 0 3
45837: ARRAY
45838: PUSH
45839: FOR_IN
45840: IFFALSE 45867
// if IsNotFull ( k ) then
45842: LD_VAR 0 8
45846: PPUSH
45847: CALL 6711 0 1
45851: IFFALSE 45865
// begin e := k ;
45853: LD_ADDR_VAR 0 7
45857: PUSH
45858: LD_VAR 0 8
45862: ST_TO_ADDR
// break ;
45863: GO 45867
// end ;
45865: GO 45839
45867: POP
45868: POP
// if e and not UnitGoingToBuilding ( p , e ) then
45869: LD_VAR 0 7
45873: PUSH
45874: LD_VAR 0 5
45878: PPUSH
45879: LD_VAR 0 7
45883: PPUSH
45884: CALL 39131 0 2
45888: NOT
45889: AND
45890: IFFALSE 45949
// begin if IsInUnit ( p ) then
45892: LD_VAR 0 5
45896: PPUSH
45897: CALL_OW 310
45901: IFFALSE 45912
// ComExitBuilding ( p ) ;
45903: LD_VAR 0 5
45907: PPUSH
45908: CALL_OW 122
// ComEnterUnit ( p , e ) ;
45912: LD_VAR 0 5
45916: PPUSH
45917: LD_VAR 0 7
45921: PPUSH
45922: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
45926: LD_VAR 0 5
45930: PPUSH
45931: LD_VAR 0 3
45935: PPUSH
45936: CALL_OW 183
// AddComExitBuilding ( p ) ;
45940: LD_VAR 0 5
45944: PPUSH
45945: CALL_OW 182
// end ; end ;
45949: GO 45797
45951: POP
45952: POP
// end ;
45953: GO 45763
45955: POP
45956: POP
// end ;
45957: GO 45518
45959: POP
45960: POP
// end ;
45961: LD_VAR 0 1
45965: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
45966: LD_INT 0
45968: PPUSH
45969: PPUSH
45970: PPUSH
45971: PPUSH
45972: PPUSH
45973: PPUSH
45974: PPUSH
45975: PPUSH
45976: PPUSH
45977: PPUSH
45978: PPUSH
45979: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45980: LD_VAR 0 1
45984: NOT
45985: PUSH
45986: LD_EXP 14
45990: PUSH
45991: LD_VAR 0 1
45995: ARRAY
45996: NOT
45997: OR
45998: PUSH
45999: LD_EXP 14
46003: PUSH
46004: LD_VAR 0 1
46008: ARRAY
46009: PPUSH
46010: LD_INT 2
46012: PUSH
46013: LD_INT 30
46015: PUSH
46016: LD_INT 0
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: LD_INT 30
46025: PUSH
46026: LD_INT 1
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: LIST
46037: PPUSH
46038: CALL_OW 72
46042: NOT
46043: OR
46044: IFFALSE 46048
// exit ;
46046: GO 49551
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46048: LD_ADDR_VAR 0 4
46052: PUSH
46053: LD_EXP 14
46057: PUSH
46058: LD_VAR 0 1
46062: ARRAY
46063: PPUSH
46064: LD_INT 2
46066: PUSH
46067: LD_INT 25
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 25
46079: PUSH
46080: LD_INT 2
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: LD_INT 25
46089: PUSH
46090: LD_INT 3
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 25
46099: PUSH
46100: LD_INT 4
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 25
46109: PUSH
46110: LD_INT 5
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: PUSH
46117: LD_INT 25
46119: PUSH
46120: LD_INT 8
46122: PUSH
46123: EMPTY
46124: LIST
46125: LIST
46126: PUSH
46127: LD_INT 25
46129: PUSH
46130: LD_INT 9
46132: PUSH
46133: EMPTY
46134: LIST
46135: LIST
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: PPUSH
46147: CALL_OW 72
46151: ST_TO_ADDR
// if not tmp then
46152: LD_VAR 0 4
46156: NOT
46157: IFFALSE 46161
// exit ;
46159: GO 49551
// for i in tmp do
46161: LD_ADDR_VAR 0 3
46165: PUSH
46166: LD_VAR 0 4
46170: PUSH
46171: FOR_IN
46172: IFFALSE 46203
// if GetTag ( i ) then
46174: LD_VAR 0 3
46178: PPUSH
46179: CALL_OW 110
46183: IFFALSE 46201
// tmp := tmp diff i ;
46185: LD_ADDR_VAR 0 4
46189: PUSH
46190: LD_VAR 0 4
46194: PUSH
46195: LD_VAR 0 3
46199: DIFF
46200: ST_TO_ADDR
46201: GO 46171
46203: POP
46204: POP
// if not tmp then
46205: LD_VAR 0 4
46209: NOT
46210: IFFALSE 46214
// exit ;
46212: GO 49551
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46214: LD_ADDR_VAR 0 5
46218: PUSH
46219: LD_EXP 14
46223: PUSH
46224: LD_VAR 0 1
46228: ARRAY
46229: PPUSH
46230: LD_INT 2
46232: PUSH
46233: LD_INT 25
46235: PUSH
46236: LD_INT 1
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 25
46245: PUSH
46246: LD_INT 5
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 25
46255: PUSH
46256: LD_INT 8
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 25
46265: PUSH
46266: LD_INT 9
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: LIST
46277: LIST
46278: LIST
46279: PPUSH
46280: CALL_OW 72
46284: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
46285: LD_ADDR_VAR 0 6
46289: PUSH
46290: LD_EXP 14
46294: PUSH
46295: LD_VAR 0 1
46299: ARRAY
46300: PPUSH
46301: LD_INT 25
46303: PUSH
46304: LD_INT 2
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PPUSH
46311: CALL_OW 72
46315: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
46316: LD_ADDR_VAR 0 7
46320: PUSH
46321: LD_EXP 14
46325: PUSH
46326: LD_VAR 0 1
46330: ARRAY
46331: PPUSH
46332: LD_INT 25
46334: PUSH
46335: LD_INT 3
46337: PUSH
46338: EMPTY
46339: LIST
46340: LIST
46341: PPUSH
46342: CALL_OW 72
46346: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
46347: LD_ADDR_VAR 0 8
46351: PUSH
46352: LD_EXP 14
46356: PUSH
46357: LD_VAR 0 1
46361: ARRAY
46362: PPUSH
46363: LD_INT 25
46365: PUSH
46366: LD_INT 4
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 24
46375: PUSH
46376: LD_INT 251
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: EMPTY
46384: LIST
46385: LIST
46386: PPUSH
46387: CALL_OW 72
46391: ST_TO_ADDR
// if mc_scan [ base ] then
46392: LD_EXP 37
46396: PUSH
46397: LD_VAR 0 1
46401: ARRAY
46402: IFFALSE 46863
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
46404: LD_ADDR_EXP 56
46408: PUSH
46409: LD_EXP 56
46413: PPUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: LD_INT 4
46421: PPUSH
46422: CALL_OW 1
46426: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46427: LD_ADDR_VAR 0 12
46431: PUSH
46432: LD_EXP 14
46436: PUSH
46437: LD_VAR 0 1
46441: ARRAY
46442: PPUSH
46443: LD_INT 2
46445: PUSH
46446: LD_INT 30
46448: PUSH
46449: LD_INT 4
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: PUSH
46456: LD_INT 30
46458: PUSH
46459: LD_INT 5
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: LIST
46470: PPUSH
46471: CALL_OW 72
46475: ST_TO_ADDR
// if not b then
46476: LD_VAR 0 12
46480: NOT
46481: IFFALSE 46485
// exit ;
46483: GO 49551
// p := [ ] ;
46485: LD_ADDR_VAR 0 11
46489: PUSH
46490: EMPTY
46491: ST_TO_ADDR
// if sci >= 2 then
46492: LD_VAR 0 8
46496: PUSH
46497: LD_INT 2
46499: GREATEREQUAL
46500: IFFALSE 46531
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
46502: LD_ADDR_VAR 0 8
46506: PUSH
46507: LD_VAR 0 8
46511: PUSH
46512: LD_INT 1
46514: ARRAY
46515: PUSH
46516: LD_VAR 0 8
46520: PUSH
46521: LD_INT 2
46523: ARRAY
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: ST_TO_ADDR
46529: GO 46592
// if sci = 1 then
46531: LD_VAR 0 8
46535: PUSH
46536: LD_INT 1
46538: EQUAL
46539: IFFALSE 46560
// sci := [ sci [ 1 ] ] else
46541: LD_ADDR_VAR 0 8
46545: PUSH
46546: LD_VAR 0 8
46550: PUSH
46551: LD_INT 1
46553: ARRAY
46554: PUSH
46555: EMPTY
46556: LIST
46557: ST_TO_ADDR
46558: GO 46592
// if sci = 0 then
46560: LD_VAR 0 8
46564: PUSH
46565: LD_INT 0
46567: EQUAL
46568: IFFALSE 46592
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
46570: LD_ADDR_VAR 0 11
46574: PUSH
46575: LD_VAR 0 4
46579: PPUSH
46580: LD_INT 4
46582: PPUSH
46583: CALL 38994 0 2
46587: PUSH
46588: LD_INT 1
46590: ARRAY
46591: ST_TO_ADDR
// if eng > 4 then
46592: LD_VAR 0 6
46596: PUSH
46597: LD_INT 4
46599: GREATER
46600: IFFALSE 46646
// for i = eng downto 4 do
46602: LD_ADDR_VAR 0 3
46606: PUSH
46607: DOUBLE
46608: LD_VAR 0 6
46612: INC
46613: ST_TO_ADDR
46614: LD_INT 4
46616: PUSH
46617: FOR_DOWNTO
46618: IFFALSE 46644
// eng := eng diff eng [ i ] ;
46620: LD_ADDR_VAR 0 6
46624: PUSH
46625: LD_VAR 0 6
46629: PUSH
46630: LD_VAR 0 6
46634: PUSH
46635: LD_VAR 0 3
46639: ARRAY
46640: DIFF
46641: ST_TO_ADDR
46642: GO 46617
46644: POP
46645: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
46646: LD_ADDR_VAR 0 4
46650: PUSH
46651: LD_VAR 0 4
46655: PUSH
46656: LD_VAR 0 5
46660: PUSH
46661: LD_VAR 0 6
46665: UNION
46666: PUSH
46667: LD_VAR 0 7
46671: UNION
46672: PUSH
46673: LD_VAR 0 8
46677: UNION
46678: DIFF
46679: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
46680: LD_ADDR_VAR 0 13
46684: PUSH
46685: LD_EXP 14
46689: PUSH
46690: LD_VAR 0 1
46694: ARRAY
46695: PPUSH
46696: LD_INT 2
46698: PUSH
46699: LD_INT 30
46701: PUSH
46702: LD_INT 32
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 30
46711: PUSH
46712: LD_INT 31
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: LIST
46723: PPUSH
46724: CALL_OW 72
46728: PUSH
46729: LD_EXP 14
46733: PUSH
46734: LD_VAR 0 1
46738: ARRAY
46739: PPUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 30
46745: PUSH
46746: LD_INT 4
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: LD_INT 30
46755: PUSH
46756: LD_INT 5
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: LIST
46767: PPUSH
46768: CALL_OW 72
46772: PUSH
46773: LD_INT 6
46775: MUL
46776: PLUS
46777: ST_TO_ADDR
// if bcount < tmp then
46778: LD_VAR 0 13
46782: PUSH
46783: LD_VAR 0 4
46787: LESS
46788: IFFALSE 46834
// for i = tmp downto bcount do
46790: LD_ADDR_VAR 0 3
46794: PUSH
46795: DOUBLE
46796: LD_VAR 0 4
46800: INC
46801: ST_TO_ADDR
46802: LD_VAR 0 13
46806: PUSH
46807: FOR_DOWNTO
46808: IFFALSE 46832
// tmp := Delete ( tmp , tmp ) ;
46810: LD_ADDR_VAR 0 4
46814: PUSH
46815: LD_VAR 0 4
46819: PPUSH
46820: LD_VAR 0 4
46824: PPUSH
46825: CALL_OW 3
46829: ST_TO_ADDR
46830: GO 46807
46832: POP
46833: POP
// result := [ tmp , 0 , 0 , p ] ;
46834: LD_ADDR_VAR 0 2
46838: PUSH
46839: LD_VAR 0 4
46843: PUSH
46844: LD_INT 0
46846: PUSH
46847: LD_INT 0
46849: PUSH
46850: LD_VAR 0 11
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: ST_TO_ADDR
// exit ;
46861: GO 49551
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
46863: LD_EXP 14
46867: PUSH
46868: LD_VAR 0 1
46872: ARRAY
46873: PPUSH
46874: LD_INT 2
46876: PUSH
46877: LD_INT 30
46879: PUSH
46880: LD_INT 6
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 30
46889: PUSH
46890: LD_INT 7
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: LD_INT 30
46899: PUSH
46900: LD_INT 8
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: PPUSH
46913: CALL_OW 72
46917: NOT
46918: PUSH
46919: LD_EXP 14
46923: PUSH
46924: LD_VAR 0 1
46928: ARRAY
46929: PPUSH
46930: LD_INT 30
46932: PUSH
46933: LD_INT 3
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PPUSH
46940: CALL_OW 72
46944: NOT
46945: AND
46946: IFFALSE 47018
// begin if eng = tmp then
46948: LD_VAR 0 6
46952: PUSH
46953: LD_VAR 0 4
46957: EQUAL
46958: IFFALSE 46962
// exit ;
46960: GO 49551
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
46962: LD_ADDR_EXP 56
46966: PUSH
46967: LD_EXP 56
46971: PPUSH
46972: LD_VAR 0 1
46976: PPUSH
46977: LD_INT 1
46979: PPUSH
46980: CALL_OW 1
46984: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
46985: LD_ADDR_VAR 0 2
46989: PUSH
46990: LD_INT 0
46992: PUSH
46993: LD_VAR 0 4
46997: PUSH
46998: LD_VAR 0 6
47002: DIFF
47003: PUSH
47004: LD_INT 0
47006: PUSH
47007: LD_INT 0
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: LIST
47014: LIST
47015: ST_TO_ADDR
// exit ;
47016: GO 49551
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47018: LD_EXP 41
47022: PUSH
47023: LD_EXP 40
47027: PUSH
47028: LD_VAR 0 1
47032: ARRAY
47033: ARRAY
47034: PUSH
47035: LD_EXP 14
47039: PUSH
47040: LD_VAR 0 1
47044: ARRAY
47045: PPUSH
47046: LD_INT 2
47048: PUSH
47049: LD_INT 30
47051: PUSH
47052: LD_INT 6
47054: PUSH
47055: EMPTY
47056: LIST
47057: LIST
47058: PUSH
47059: LD_INT 30
47061: PUSH
47062: LD_INT 7
47064: PUSH
47065: EMPTY
47066: LIST
47067: LIST
47068: PUSH
47069: LD_INT 30
47071: PUSH
47072: LD_INT 8
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: PPUSH
47085: CALL_OW 72
47089: AND
47090: PUSH
47091: LD_EXP 14
47095: PUSH
47096: LD_VAR 0 1
47100: ARRAY
47101: PPUSH
47102: LD_INT 30
47104: PUSH
47105: LD_INT 3
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PPUSH
47112: CALL_OW 72
47116: NOT
47117: AND
47118: IFFALSE 47332
// begin if sci >= 6 then
47120: LD_VAR 0 8
47124: PUSH
47125: LD_INT 6
47127: GREATEREQUAL
47128: IFFALSE 47132
// exit ;
47130: GO 49551
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
47132: LD_ADDR_EXP 56
47136: PUSH
47137: LD_EXP 56
47141: PPUSH
47142: LD_VAR 0 1
47146: PPUSH
47147: LD_INT 2
47149: PPUSH
47150: CALL_OW 1
47154: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
47155: LD_ADDR_VAR 0 9
47159: PUSH
47160: LD_VAR 0 4
47164: PUSH
47165: LD_VAR 0 8
47169: DIFF
47170: PPUSH
47171: LD_INT 4
47173: PPUSH
47174: CALL 38994 0 2
47178: ST_TO_ADDR
// p := [ ] ;
47179: LD_ADDR_VAR 0 11
47183: PUSH
47184: EMPTY
47185: ST_TO_ADDR
// if sci < 6 and sort > 6 then
47186: LD_VAR 0 8
47190: PUSH
47191: LD_INT 6
47193: LESS
47194: PUSH
47195: LD_VAR 0 9
47199: PUSH
47200: LD_INT 6
47202: GREATER
47203: AND
47204: IFFALSE 47285
// begin for i = 1 to 6 - sci do
47206: LD_ADDR_VAR 0 3
47210: PUSH
47211: DOUBLE
47212: LD_INT 1
47214: DEC
47215: ST_TO_ADDR
47216: LD_INT 6
47218: PUSH
47219: LD_VAR 0 8
47223: MINUS
47224: PUSH
47225: FOR_TO
47226: IFFALSE 47281
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
47228: LD_ADDR_VAR 0 11
47232: PUSH
47233: LD_VAR 0 11
47237: PPUSH
47238: LD_VAR 0 11
47242: PUSH
47243: LD_INT 1
47245: PLUS
47246: PPUSH
47247: LD_VAR 0 9
47251: PUSH
47252: LD_INT 1
47254: ARRAY
47255: PPUSH
47256: CALL_OW 2
47260: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
47261: LD_ADDR_VAR 0 9
47265: PUSH
47266: LD_VAR 0 9
47270: PPUSH
47271: LD_INT 1
47273: PPUSH
47274: CALL_OW 3
47278: ST_TO_ADDR
// end ;
47279: GO 47225
47281: POP
47282: POP
// end else
47283: GO 47305
// if sort then
47285: LD_VAR 0 9
47289: IFFALSE 47305
// p := sort [ 1 ] ;
47291: LD_ADDR_VAR 0 11
47295: PUSH
47296: LD_VAR 0 9
47300: PUSH
47301: LD_INT 1
47303: ARRAY
47304: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
47305: LD_ADDR_VAR 0 2
47309: PUSH
47310: LD_INT 0
47312: PUSH
47313: LD_INT 0
47315: PUSH
47316: LD_INT 0
47318: PUSH
47319: LD_VAR 0 11
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: ST_TO_ADDR
// exit ;
47330: GO 49551
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47332: LD_EXP 41
47336: PUSH
47337: LD_EXP 40
47341: PUSH
47342: LD_VAR 0 1
47346: ARRAY
47347: ARRAY
47348: PUSH
47349: LD_EXP 14
47353: PUSH
47354: LD_VAR 0 1
47358: ARRAY
47359: PPUSH
47360: LD_INT 2
47362: PUSH
47363: LD_INT 30
47365: PUSH
47366: LD_INT 6
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: LD_INT 30
47375: PUSH
47376: LD_INT 7
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: PUSH
47383: LD_INT 30
47385: PUSH
47386: LD_INT 8
47388: PUSH
47389: EMPTY
47390: LIST
47391: LIST
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: PPUSH
47399: CALL_OW 72
47403: AND
47404: PUSH
47405: LD_EXP 14
47409: PUSH
47410: LD_VAR 0 1
47414: ARRAY
47415: PPUSH
47416: LD_INT 30
47418: PUSH
47419: LD_INT 3
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: PPUSH
47426: CALL_OW 72
47430: AND
47431: IFFALSE 48165
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
47433: LD_ADDR_EXP 56
47437: PUSH
47438: LD_EXP 56
47442: PPUSH
47443: LD_VAR 0 1
47447: PPUSH
47448: LD_INT 3
47450: PPUSH
47451: CALL_OW 1
47455: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47456: LD_ADDR_VAR 0 2
47460: PUSH
47461: LD_INT 0
47463: PUSH
47464: LD_INT 0
47466: PUSH
47467: LD_INT 0
47469: PUSH
47470: LD_INT 0
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: ST_TO_ADDR
// if not eng then
47479: LD_VAR 0 6
47483: NOT
47484: IFFALSE 47547
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
47486: LD_ADDR_VAR 0 11
47490: PUSH
47491: LD_VAR 0 4
47495: PPUSH
47496: LD_INT 2
47498: PPUSH
47499: CALL 38994 0 2
47503: PUSH
47504: LD_INT 1
47506: ARRAY
47507: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
47508: LD_ADDR_VAR 0 2
47512: PUSH
47513: LD_VAR 0 2
47517: PPUSH
47518: LD_INT 2
47520: PPUSH
47521: LD_VAR 0 11
47525: PPUSH
47526: CALL_OW 1
47530: ST_TO_ADDR
// tmp := tmp diff p ;
47531: LD_ADDR_VAR 0 4
47535: PUSH
47536: LD_VAR 0 4
47540: PUSH
47541: LD_VAR 0 11
47545: DIFF
47546: ST_TO_ADDR
// end ; if tmp and sci < 6 then
47547: LD_VAR 0 4
47551: PUSH
47552: LD_VAR 0 8
47556: PUSH
47557: LD_INT 6
47559: LESS
47560: AND
47561: IFFALSE 47749
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
47563: LD_ADDR_VAR 0 9
47567: PUSH
47568: LD_VAR 0 4
47572: PUSH
47573: LD_VAR 0 8
47577: PUSH
47578: LD_VAR 0 7
47582: UNION
47583: DIFF
47584: PPUSH
47585: LD_INT 4
47587: PPUSH
47588: CALL 38994 0 2
47592: ST_TO_ADDR
// p := [ ] ;
47593: LD_ADDR_VAR 0 11
47597: PUSH
47598: EMPTY
47599: ST_TO_ADDR
// if sort then
47600: LD_VAR 0 9
47604: IFFALSE 47720
// for i = 1 to 6 - sci do
47606: LD_ADDR_VAR 0 3
47610: PUSH
47611: DOUBLE
47612: LD_INT 1
47614: DEC
47615: ST_TO_ADDR
47616: LD_INT 6
47618: PUSH
47619: LD_VAR 0 8
47623: MINUS
47624: PUSH
47625: FOR_TO
47626: IFFALSE 47718
// begin if i = sort then
47628: LD_VAR 0 3
47632: PUSH
47633: LD_VAR 0 9
47637: EQUAL
47638: IFFALSE 47642
// break ;
47640: GO 47718
// if GetClass ( i ) = 4 then
47642: LD_VAR 0 3
47646: PPUSH
47647: CALL_OW 257
47651: PUSH
47652: LD_INT 4
47654: EQUAL
47655: IFFALSE 47659
// continue ;
47657: GO 47625
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47659: LD_ADDR_VAR 0 11
47663: PUSH
47664: LD_VAR 0 11
47668: PPUSH
47669: LD_VAR 0 11
47673: PUSH
47674: LD_INT 1
47676: PLUS
47677: PPUSH
47678: LD_VAR 0 9
47682: PUSH
47683: LD_VAR 0 3
47687: ARRAY
47688: PPUSH
47689: CALL_OW 2
47693: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47694: LD_ADDR_VAR 0 4
47698: PUSH
47699: LD_VAR 0 4
47703: PUSH
47704: LD_VAR 0 9
47708: PUSH
47709: LD_VAR 0 3
47713: ARRAY
47714: DIFF
47715: ST_TO_ADDR
// end ;
47716: GO 47625
47718: POP
47719: POP
// if p then
47720: LD_VAR 0 11
47724: IFFALSE 47749
// result := Replace ( result , 4 , p ) ;
47726: LD_ADDR_VAR 0 2
47730: PUSH
47731: LD_VAR 0 2
47735: PPUSH
47736: LD_INT 4
47738: PPUSH
47739: LD_VAR 0 11
47743: PPUSH
47744: CALL_OW 1
47748: ST_TO_ADDR
// end ; if tmp and mech < 6 then
47749: LD_VAR 0 4
47753: PUSH
47754: LD_VAR 0 7
47758: PUSH
47759: LD_INT 6
47761: LESS
47762: AND
47763: IFFALSE 47951
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
47765: LD_ADDR_VAR 0 9
47769: PUSH
47770: LD_VAR 0 4
47774: PUSH
47775: LD_VAR 0 8
47779: PUSH
47780: LD_VAR 0 7
47784: UNION
47785: DIFF
47786: PPUSH
47787: LD_INT 3
47789: PPUSH
47790: CALL 38994 0 2
47794: ST_TO_ADDR
// p := [ ] ;
47795: LD_ADDR_VAR 0 11
47799: PUSH
47800: EMPTY
47801: ST_TO_ADDR
// if sort then
47802: LD_VAR 0 9
47806: IFFALSE 47922
// for i = 1 to 6 - mech do
47808: LD_ADDR_VAR 0 3
47812: PUSH
47813: DOUBLE
47814: LD_INT 1
47816: DEC
47817: ST_TO_ADDR
47818: LD_INT 6
47820: PUSH
47821: LD_VAR 0 7
47825: MINUS
47826: PUSH
47827: FOR_TO
47828: IFFALSE 47920
// begin if i = sort then
47830: LD_VAR 0 3
47834: PUSH
47835: LD_VAR 0 9
47839: EQUAL
47840: IFFALSE 47844
// break ;
47842: GO 47920
// if GetClass ( i ) = 3 then
47844: LD_VAR 0 3
47848: PPUSH
47849: CALL_OW 257
47853: PUSH
47854: LD_INT 3
47856: EQUAL
47857: IFFALSE 47861
// continue ;
47859: GO 47827
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47861: LD_ADDR_VAR 0 11
47865: PUSH
47866: LD_VAR 0 11
47870: PPUSH
47871: LD_VAR 0 11
47875: PUSH
47876: LD_INT 1
47878: PLUS
47879: PPUSH
47880: LD_VAR 0 9
47884: PUSH
47885: LD_VAR 0 3
47889: ARRAY
47890: PPUSH
47891: CALL_OW 2
47895: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47896: LD_ADDR_VAR 0 4
47900: PUSH
47901: LD_VAR 0 4
47905: PUSH
47906: LD_VAR 0 9
47910: PUSH
47911: LD_VAR 0 3
47915: ARRAY
47916: DIFF
47917: ST_TO_ADDR
// end ;
47918: GO 47827
47920: POP
47921: POP
// if p then
47922: LD_VAR 0 11
47926: IFFALSE 47951
// result := Replace ( result , 3 , p ) ;
47928: LD_ADDR_VAR 0 2
47932: PUSH
47933: LD_VAR 0 2
47937: PPUSH
47938: LD_INT 3
47940: PPUSH
47941: LD_VAR 0 11
47945: PPUSH
47946: CALL_OW 1
47950: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
47951: LD_VAR 0 4
47955: PUSH
47956: LD_INT 6
47958: GREATER
47959: PUSH
47960: LD_VAR 0 6
47964: PUSH
47965: LD_INT 6
47967: LESS
47968: AND
47969: IFFALSE 48163
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47971: LD_ADDR_VAR 0 9
47975: PUSH
47976: LD_VAR 0 4
47980: PUSH
47981: LD_VAR 0 8
47985: PUSH
47986: LD_VAR 0 7
47990: UNION
47991: PUSH
47992: LD_VAR 0 6
47996: UNION
47997: DIFF
47998: PPUSH
47999: LD_INT 2
48001: PPUSH
48002: CALL 38994 0 2
48006: ST_TO_ADDR
// p := [ ] ;
48007: LD_ADDR_VAR 0 11
48011: PUSH
48012: EMPTY
48013: ST_TO_ADDR
// if sort then
48014: LD_VAR 0 9
48018: IFFALSE 48134
// for i = 1 to 6 - eng do
48020: LD_ADDR_VAR 0 3
48024: PUSH
48025: DOUBLE
48026: LD_INT 1
48028: DEC
48029: ST_TO_ADDR
48030: LD_INT 6
48032: PUSH
48033: LD_VAR 0 6
48037: MINUS
48038: PUSH
48039: FOR_TO
48040: IFFALSE 48132
// begin if i = sort then
48042: LD_VAR 0 3
48046: PUSH
48047: LD_VAR 0 9
48051: EQUAL
48052: IFFALSE 48056
// break ;
48054: GO 48132
// if GetClass ( i ) = 2 then
48056: LD_VAR 0 3
48060: PPUSH
48061: CALL_OW 257
48065: PUSH
48066: LD_INT 2
48068: EQUAL
48069: IFFALSE 48073
// continue ;
48071: GO 48039
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48073: LD_ADDR_VAR 0 11
48077: PUSH
48078: LD_VAR 0 11
48082: PPUSH
48083: LD_VAR 0 11
48087: PUSH
48088: LD_INT 1
48090: PLUS
48091: PPUSH
48092: LD_VAR 0 9
48096: PUSH
48097: LD_VAR 0 3
48101: ARRAY
48102: PPUSH
48103: CALL_OW 2
48107: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48108: LD_ADDR_VAR 0 4
48112: PUSH
48113: LD_VAR 0 4
48117: PUSH
48118: LD_VAR 0 9
48122: PUSH
48123: LD_VAR 0 3
48127: ARRAY
48128: DIFF
48129: ST_TO_ADDR
// end ;
48130: GO 48039
48132: POP
48133: POP
// if p then
48134: LD_VAR 0 11
48138: IFFALSE 48163
// result := Replace ( result , 2 , p ) ;
48140: LD_ADDR_VAR 0 2
48144: PUSH
48145: LD_VAR 0 2
48149: PPUSH
48150: LD_INT 2
48152: PPUSH
48153: LD_VAR 0 11
48157: PPUSH
48158: CALL_OW 1
48162: ST_TO_ADDR
// end ; exit ;
48163: GO 49551
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
48165: LD_EXP 41
48169: PUSH
48170: LD_EXP 40
48174: PUSH
48175: LD_VAR 0 1
48179: ARRAY
48180: ARRAY
48181: NOT
48182: PUSH
48183: LD_EXP 14
48187: PUSH
48188: LD_VAR 0 1
48192: ARRAY
48193: PPUSH
48194: LD_INT 30
48196: PUSH
48197: LD_INT 3
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: PPUSH
48204: CALL_OW 72
48208: AND
48209: PUSH
48210: LD_EXP 19
48214: PUSH
48215: LD_VAR 0 1
48219: ARRAY
48220: AND
48221: IFFALSE 48829
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
48223: LD_ADDR_EXP 56
48227: PUSH
48228: LD_EXP 56
48232: PPUSH
48233: LD_VAR 0 1
48237: PPUSH
48238: LD_INT 5
48240: PPUSH
48241: CALL_OW 1
48245: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48246: LD_ADDR_VAR 0 2
48250: PUSH
48251: LD_INT 0
48253: PUSH
48254: LD_INT 0
48256: PUSH
48257: LD_INT 0
48259: PUSH
48260: LD_INT 0
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: ST_TO_ADDR
// if sci > 1 then
48269: LD_VAR 0 8
48273: PUSH
48274: LD_INT 1
48276: GREATER
48277: IFFALSE 48305
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
48279: LD_ADDR_VAR 0 4
48283: PUSH
48284: LD_VAR 0 4
48288: PUSH
48289: LD_VAR 0 8
48293: PUSH
48294: LD_VAR 0 8
48298: PUSH
48299: LD_INT 1
48301: ARRAY
48302: DIFF
48303: DIFF
48304: ST_TO_ADDR
// if tmp and not sci then
48305: LD_VAR 0 4
48309: PUSH
48310: LD_VAR 0 8
48314: NOT
48315: AND
48316: IFFALSE 48385
// begin sort := SortBySkill ( tmp , 4 ) ;
48318: LD_ADDR_VAR 0 9
48322: PUSH
48323: LD_VAR 0 4
48327: PPUSH
48328: LD_INT 4
48330: PPUSH
48331: CALL 38994 0 2
48335: ST_TO_ADDR
// if sort then
48336: LD_VAR 0 9
48340: IFFALSE 48356
// p := sort [ 1 ] ;
48342: LD_ADDR_VAR 0 11
48346: PUSH
48347: LD_VAR 0 9
48351: PUSH
48352: LD_INT 1
48354: ARRAY
48355: ST_TO_ADDR
// if p then
48356: LD_VAR 0 11
48360: IFFALSE 48385
// result := Replace ( result , 4 , p ) ;
48362: LD_ADDR_VAR 0 2
48366: PUSH
48367: LD_VAR 0 2
48371: PPUSH
48372: LD_INT 4
48374: PPUSH
48375: LD_VAR 0 11
48379: PPUSH
48380: CALL_OW 1
48384: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
48385: LD_ADDR_VAR 0 4
48389: PUSH
48390: LD_VAR 0 4
48394: PUSH
48395: LD_VAR 0 7
48399: DIFF
48400: ST_TO_ADDR
// if tmp and mech < 6 then
48401: LD_VAR 0 4
48405: PUSH
48406: LD_VAR 0 7
48410: PUSH
48411: LD_INT 6
48413: LESS
48414: AND
48415: IFFALSE 48603
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
48417: LD_ADDR_VAR 0 9
48421: PUSH
48422: LD_VAR 0 4
48426: PUSH
48427: LD_VAR 0 8
48431: PUSH
48432: LD_VAR 0 7
48436: UNION
48437: DIFF
48438: PPUSH
48439: LD_INT 3
48441: PPUSH
48442: CALL 38994 0 2
48446: ST_TO_ADDR
// p := [ ] ;
48447: LD_ADDR_VAR 0 11
48451: PUSH
48452: EMPTY
48453: ST_TO_ADDR
// if sort then
48454: LD_VAR 0 9
48458: IFFALSE 48574
// for i = 1 to 6 - mech do
48460: LD_ADDR_VAR 0 3
48464: PUSH
48465: DOUBLE
48466: LD_INT 1
48468: DEC
48469: ST_TO_ADDR
48470: LD_INT 6
48472: PUSH
48473: LD_VAR 0 7
48477: MINUS
48478: PUSH
48479: FOR_TO
48480: IFFALSE 48572
// begin if i = sort then
48482: LD_VAR 0 3
48486: PUSH
48487: LD_VAR 0 9
48491: EQUAL
48492: IFFALSE 48496
// break ;
48494: GO 48572
// if GetClass ( i ) = 3 then
48496: LD_VAR 0 3
48500: PPUSH
48501: CALL_OW 257
48505: PUSH
48506: LD_INT 3
48508: EQUAL
48509: IFFALSE 48513
// continue ;
48511: GO 48479
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48513: LD_ADDR_VAR 0 11
48517: PUSH
48518: LD_VAR 0 11
48522: PPUSH
48523: LD_VAR 0 11
48527: PUSH
48528: LD_INT 1
48530: PLUS
48531: PPUSH
48532: LD_VAR 0 9
48536: PUSH
48537: LD_VAR 0 3
48541: ARRAY
48542: PPUSH
48543: CALL_OW 2
48547: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48548: LD_ADDR_VAR 0 4
48552: PUSH
48553: LD_VAR 0 4
48557: PUSH
48558: LD_VAR 0 9
48562: PUSH
48563: LD_VAR 0 3
48567: ARRAY
48568: DIFF
48569: ST_TO_ADDR
// end ;
48570: GO 48479
48572: POP
48573: POP
// if p then
48574: LD_VAR 0 11
48578: IFFALSE 48603
// result := Replace ( result , 3 , p ) ;
48580: LD_ADDR_VAR 0 2
48584: PUSH
48585: LD_VAR 0 2
48589: PPUSH
48590: LD_INT 3
48592: PPUSH
48593: LD_VAR 0 11
48597: PPUSH
48598: CALL_OW 1
48602: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
48603: LD_ADDR_VAR 0 4
48607: PUSH
48608: LD_VAR 0 4
48612: PUSH
48613: LD_VAR 0 6
48617: DIFF
48618: ST_TO_ADDR
// if tmp and eng < 6 then
48619: LD_VAR 0 4
48623: PUSH
48624: LD_VAR 0 6
48628: PUSH
48629: LD_INT 6
48631: LESS
48632: AND
48633: IFFALSE 48827
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
48635: LD_ADDR_VAR 0 9
48639: PUSH
48640: LD_VAR 0 4
48644: PUSH
48645: LD_VAR 0 8
48649: PUSH
48650: LD_VAR 0 7
48654: UNION
48655: PUSH
48656: LD_VAR 0 6
48660: UNION
48661: DIFF
48662: PPUSH
48663: LD_INT 2
48665: PPUSH
48666: CALL 38994 0 2
48670: ST_TO_ADDR
// p := [ ] ;
48671: LD_ADDR_VAR 0 11
48675: PUSH
48676: EMPTY
48677: ST_TO_ADDR
// if sort then
48678: LD_VAR 0 9
48682: IFFALSE 48798
// for i = 1 to 6 - eng do
48684: LD_ADDR_VAR 0 3
48688: PUSH
48689: DOUBLE
48690: LD_INT 1
48692: DEC
48693: ST_TO_ADDR
48694: LD_INT 6
48696: PUSH
48697: LD_VAR 0 6
48701: MINUS
48702: PUSH
48703: FOR_TO
48704: IFFALSE 48796
// begin if i = sort then
48706: LD_VAR 0 3
48710: PUSH
48711: LD_VAR 0 9
48715: EQUAL
48716: IFFALSE 48720
// break ;
48718: GO 48796
// if GetClass ( i ) = 2 then
48720: LD_VAR 0 3
48724: PPUSH
48725: CALL_OW 257
48729: PUSH
48730: LD_INT 2
48732: EQUAL
48733: IFFALSE 48737
// continue ;
48735: GO 48703
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48737: LD_ADDR_VAR 0 11
48741: PUSH
48742: LD_VAR 0 11
48746: PPUSH
48747: LD_VAR 0 11
48751: PUSH
48752: LD_INT 1
48754: PLUS
48755: PPUSH
48756: LD_VAR 0 9
48760: PUSH
48761: LD_VAR 0 3
48765: ARRAY
48766: PPUSH
48767: CALL_OW 2
48771: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48772: LD_ADDR_VAR 0 4
48776: PUSH
48777: LD_VAR 0 4
48781: PUSH
48782: LD_VAR 0 9
48786: PUSH
48787: LD_VAR 0 3
48791: ARRAY
48792: DIFF
48793: ST_TO_ADDR
// end ;
48794: GO 48703
48796: POP
48797: POP
// if p then
48798: LD_VAR 0 11
48802: IFFALSE 48827
// result := Replace ( result , 2 , p ) ;
48804: LD_ADDR_VAR 0 2
48808: PUSH
48809: LD_VAR 0 2
48813: PPUSH
48814: LD_INT 2
48816: PPUSH
48817: LD_VAR 0 11
48821: PPUSH
48822: CALL_OW 1
48826: ST_TO_ADDR
// end ; exit ;
48827: GO 49551
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
48829: LD_EXP 41
48833: PUSH
48834: LD_EXP 40
48838: PUSH
48839: LD_VAR 0 1
48843: ARRAY
48844: ARRAY
48845: NOT
48846: PUSH
48847: LD_EXP 14
48851: PUSH
48852: LD_VAR 0 1
48856: ARRAY
48857: PPUSH
48858: LD_INT 30
48860: PUSH
48861: LD_INT 3
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PPUSH
48868: CALL_OW 72
48872: AND
48873: PUSH
48874: LD_EXP 19
48878: PUSH
48879: LD_VAR 0 1
48883: ARRAY
48884: NOT
48885: AND
48886: IFFALSE 49551
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
48888: LD_ADDR_EXP 56
48892: PUSH
48893: LD_EXP 56
48897: PPUSH
48898: LD_VAR 0 1
48902: PPUSH
48903: LD_INT 6
48905: PPUSH
48906: CALL_OW 1
48910: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48911: LD_ADDR_VAR 0 2
48915: PUSH
48916: LD_INT 0
48918: PUSH
48919: LD_INT 0
48921: PUSH
48922: LD_INT 0
48924: PUSH
48925: LD_INT 0
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: ST_TO_ADDR
// if sci >= 1 then
48934: LD_VAR 0 8
48938: PUSH
48939: LD_INT 1
48941: GREATEREQUAL
48942: IFFALSE 48964
// tmp := tmp diff sci [ 1 ] ;
48944: LD_ADDR_VAR 0 4
48948: PUSH
48949: LD_VAR 0 4
48953: PUSH
48954: LD_VAR 0 8
48958: PUSH
48959: LD_INT 1
48961: ARRAY
48962: DIFF
48963: ST_TO_ADDR
// if tmp and not sci then
48964: LD_VAR 0 4
48968: PUSH
48969: LD_VAR 0 8
48973: NOT
48974: AND
48975: IFFALSE 49044
// begin sort := SortBySkill ( tmp , 4 ) ;
48977: LD_ADDR_VAR 0 9
48981: PUSH
48982: LD_VAR 0 4
48986: PPUSH
48987: LD_INT 4
48989: PPUSH
48990: CALL 38994 0 2
48994: ST_TO_ADDR
// if sort then
48995: LD_VAR 0 9
48999: IFFALSE 49015
// p := sort [ 1 ] ;
49001: LD_ADDR_VAR 0 11
49005: PUSH
49006: LD_VAR 0 9
49010: PUSH
49011: LD_INT 1
49013: ARRAY
49014: ST_TO_ADDR
// if p then
49015: LD_VAR 0 11
49019: IFFALSE 49044
// result := Replace ( result , 4 , p ) ;
49021: LD_ADDR_VAR 0 2
49025: PUSH
49026: LD_VAR 0 2
49030: PPUSH
49031: LD_INT 4
49033: PPUSH
49034: LD_VAR 0 11
49038: PPUSH
49039: CALL_OW 1
49043: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49044: LD_ADDR_VAR 0 4
49048: PUSH
49049: LD_VAR 0 4
49053: PUSH
49054: LD_VAR 0 7
49058: DIFF
49059: ST_TO_ADDR
// if tmp and mech < 6 then
49060: LD_VAR 0 4
49064: PUSH
49065: LD_VAR 0 7
49069: PUSH
49070: LD_INT 6
49072: LESS
49073: AND
49074: IFFALSE 49256
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
49076: LD_ADDR_VAR 0 9
49080: PUSH
49081: LD_VAR 0 4
49085: PUSH
49086: LD_VAR 0 7
49090: DIFF
49091: PPUSH
49092: LD_INT 3
49094: PPUSH
49095: CALL 38994 0 2
49099: ST_TO_ADDR
// p := [ ] ;
49100: LD_ADDR_VAR 0 11
49104: PUSH
49105: EMPTY
49106: ST_TO_ADDR
// if sort then
49107: LD_VAR 0 9
49111: IFFALSE 49227
// for i = 1 to 6 - mech do
49113: LD_ADDR_VAR 0 3
49117: PUSH
49118: DOUBLE
49119: LD_INT 1
49121: DEC
49122: ST_TO_ADDR
49123: LD_INT 6
49125: PUSH
49126: LD_VAR 0 7
49130: MINUS
49131: PUSH
49132: FOR_TO
49133: IFFALSE 49225
// begin if i = sort then
49135: LD_VAR 0 3
49139: PUSH
49140: LD_VAR 0 9
49144: EQUAL
49145: IFFALSE 49149
// break ;
49147: GO 49225
// if GetClass ( i ) = 3 then
49149: LD_VAR 0 3
49153: PPUSH
49154: CALL_OW 257
49158: PUSH
49159: LD_INT 3
49161: EQUAL
49162: IFFALSE 49166
// continue ;
49164: GO 49132
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49166: LD_ADDR_VAR 0 11
49170: PUSH
49171: LD_VAR 0 11
49175: PPUSH
49176: LD_VAR 0 11
49180: PUSH
49181: LD_INT 1
49183: PLUS
49184: PPUSH
49185: LD_VAR 0 9
49189: PUSH
49190: LD_VAR 0 3
49194: ARRAY
49195: PPUSH
49196: CALL_OW 2
49200: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49201: LD_ADDR_VAR 0 4
49205: PUSH
49206: LD_VAR 0 4
49210: PUSH
49211: LD_VAR 0 9
49215: PUSH
49216: LD_VAR 0 3
49220: ARRAY
49221: DIFF
49222: ST_TO_ADDR
// end ;
49223: GO 49132
49225: POP
49226: POP
// if p then
49227: LD_VAR 0 11
49231: IFFALSE 49256
// result := Replace ( result , 3 , p ) ;
49233: LD_ADDR_VAR 0 2
49237: PUSH
49238: LD_VAR 0 2
49242: PPUSH
49243: LD_INT 3
49245: PPUSH
49246: LD_VAR 0 11
49250: PPUSH
49251: CALL_OW 1
49255: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
49256: LD_ADDR_VAR 0 4
49260: PUSH
49261: LD_VAR 0 4
49265: PUSH
49266: LD_VAR 0 6
49270: DIFF
49271: ST_TO_ADDR
// if tmp and eng < 4 then
49272: LD_VAR 0 4
49276: PUSH
49277: LD_VAR 0 6
49281: PUSH
49282: LD_INT 4
49284: LESS
49285: AND
49286: IFFALSE 49476
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
49288: LD_ADDR_VAR 0 9
49292: PUSH
49293: LD_VAR 0 4
49297: PUSH
49298: LD_VAR 0 7
49302: PUSH
49303: LD_VAR 0 6
49307: UNION
49308: DIFF
49309: PPUSH
49310: LD_INT 2
49312: PPUSH
49313: CALL 38994 0 2
49317: ST_TO_ADDR
// p := [ ] ;
49318: LD_ADDR_VAR 0 11
49322: PUSH
49323: EMPTY
49324: ST_TO_ADDR
// if sort then
49325: LD_VAR 0 9
49329: IFFALSE 49445
// for i = 1 to 4 - eng do
49331: LD_ADDR_VAR 0 3
49335: PUSH
49336: DOUBLE
49337: LD_INT 1
49339: DEC
49340: ST_TO_ADDR
49341: LD_INT 4
49343: PUSH
49344: LD_VAR 0 6
49348: MINUS
49349: PUSH
49350: FOR_TO
49351: IFFALSE 49443
// begin if i = sort then
49353: LD_VAR 0 3
49357: PUSH
49358: LD_VAR 0 9
49362: EQUAL
49363: IFFALSE 49367
// break ;
49365: GO 49443
// if GetClass ( i ) = 2 then
49367: LD_VAR 0 3
49371: PPUSH
49372: CALL_OW 257
49376: PUSH
49377: LD_INT 2
49379: EQUAL
49380: IFFALSE 49384
// continue ;
49382: GO 49350
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49384: LD_ADDR_VAR 0 11
49388: PUSH
49389: LD_VAR 0 11
49393: PPUSH
49394: LD_VAR 0 11
49398: PUSH
49399: LD_INT 1
49401: PLUS
49402: PPUSH
49403: LD_VAR 0 9
49407: PUSH
49408: LD_VAR 0 3
49412: ARRAY
49413: PPUSH
49414: CALL_OW 2
49418: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49419: LD_ADDR_VAR 0 4
49423: PUSH
49424: LD_VAR 0 4
49428: PUSH
49429: LD_VAR 0 9
49433: PUSH
49434: LD_VAR 0 3
49438: ARRAY
49439: DIFF
49440: ST_TO_ADDR
// end ;
49441: GO 49350
49443: POP
49444: POP
// if p then
49445: LD_VAR 0 11
49449: IFFALSE 49474
// result := Replace ( result , 2 , p ) ;
49451: LD_ADDR_VAR 0 2
49455: PUSH
49456: LD_VAR 0 2
49460: PPUSH
49461: LD_INT 2
49463: PPUSH
49464: LD_VAR 0 11
49468: PPUSH
49469: CALL_OW 1
49473: ST_TO_ADDR
// end else
49474: GO 49520
// for i = eng downto 5 do
49476: LD_ADDR_VAR 0 3
49480: PUSH
49481: DOUBLE
49482: LD_VAR 0 6
49486: INC
49487: ST_TO_ADDR
49488: LD_INT 5
49490: PUSH
49491: FOR_DOWNTO
49492: IFFALSE 49518
// tmp := tmp union eng [ i ] ;
49494: LD_ADDR_VAR 0 4
49498: PUSH
49499: LD_VAR 0 4
49503: PUSH
49504: LD_VAR 0 6
49508: PUSH
49509: LD_VAR 0 3
49513: ARRAY
49514: UNION
49515: ST_TO_ADDR
49516: GO 49491
49518: POP
49519: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
49520: LD_ADDR_VAR 0 2
49524: PUSH
49525: LD_VAR 0 2
49529: PPUSH
49530: LD_INT 1
49532: PPUSH
49533: LD_VAR 0 4
49537: PUSH
49538: LD_VAR 0 5
49542: DIFF
49543: PPUSH
49544: CALL_OW 1
49548: ST_TO_ADDR
// exit ;
49549: GO 49551
// end ; end ;
49551: LD_VAR 0 2
49555: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
49556: LD_INT 0
49558: PPUSH
49559: PPUSH
49560: PPUSH
// if not mc_bases then
49561: LD_EXP 14
49565: NOT
49566: IFFALSE 49570
// exit ;
49568: GO 49676
// for i = 1 to mc_bases do
49570: LD_ADDR_VAR 0 2
49574: PUSH
49575: DOUBLE
49576: LD_INT 1
49578: DEC
49579: ST_TO_ADDR
49580: LD_EXP 14
49584: PUSH
49585: FOR_TO
49586: IFFALSE 49667
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
49588: LD_ADDR_VAR 0 3
49592: PUSH
49593: LD_EXP 14
49597: PUSH
49598: LD_VAR 0 2
49602: ARRAY
49603: PPUSH
49604: LD_INT 21
49606: PUSH
49607: LD_INT 3
49609: PUSH
49610: EMPTY
49611: LIST
49612: LIST
49613: PUSH
49614: LD_INT 3
49616: PUSH
49617: LD_INT 24
49619: PUSH
49620: LD_INT 1000
49622: PUSH
49623: EMPTY
49624: LIST
49625: LIST
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: PPUSH
49635: CALL_OW 72
49639: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
49640: LD_ADDR_EXP 15
49644: PUSH
49645: LD_EXP 15
49649: PPUSH
49650: LD_VAR 0 2
49654: PPUSH
49655: LD_VAR 0 3
49659: PPUSH
49660: CALL_OW 1
49664: ST_TO_ADDR
// end ;
49665: GO 49585
49667: POP
49668: POP
// RaiseSailEvent ( 101 ) ;
49669: LD_INT 101
49671: PPUSH
49672: CALL_OW 427
// end ;
49676: LD_VAR 0 1
49680: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
49681: LD_INT 0
49683: PPUSH
49684: PPUSH
49685: PPUSH
49686: PPUSH
49687: PPUSH
49688: PPUSH
49689: PPUSH
// if not mc_bases then
49690: LD_EXP 14
49694: NOT
49695: IFFALSE 49699
// exit ;
49697: GO 50261
// for i = 1 to mc_bases do
49699: LD_ADDR_VAR 0 2
49703: PUSH
49704: DOUBLE
49705: LD_INT 1
49707: DEC
49708: ST_TO_ADDR
49709: LD_EXP 14
49713: PUSH
49714: FOR_TO
49715: IFFALSE 50252
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
49717: LD_ADDR_VAR 0 5
49721: PUSH
49722: LD_EXP 14
49726: PUSH
49727: LD_VAR 0 2
49731: ARRAY
49732: PUSH
49733: LD_EXP 43
49737: PUSH
49738: LD_VAR 0 2
49742: ARRAY
49743: UNION
49744: PPUSH
49745: LD_INT 21
49747: PUSH
49748: LD_INT 1
49750: PUSH
49751: EMPTY
49752: LIST
49753: LIST
49754: PUSH
49755: LD_INT 1
49757: PUSH
49758: LD_INT 3
49760: PUSH
49761: LD_INT 54
49763: PUSH
49764: EMPTY
49765: LIST
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: LD_INT 3
49773: PUSH
49774: LD_INT 24
49776: PUSH
49777: LD_INT 800
49779: PUSH
49780: EMPTY
49781: LIST
49782: LIST
49783: PUSH
49784: EMPTY
49785: LIST
49786: LIST
49787: PUSH
49788: EMPTY
49789: LIST
49790: LIST
49791: LIST
49792: PUSH
49793: EMPTY
49794: LIST
49795: LIST
49796: PPUSH
49797: CALL_OW 72
49801: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
49802: LD_ADDR_VAR 0 6
49806: PUSH
49807: LD_EXP 14
49811: PUSH
49812: LD_VAR 0 2
49816: ARRAY
49817: PPUSH
49818: LD_INT 21
49820: PUSH
49821: LD_INT 1
49823: PUSH
49824: EMPTY
49825: LIST
49826: LIST
49827: PUSH
49828: LD_INT 1
49830: PUSH
49831: LD_INT 3
49833: PUSH
49834: LD_INT 54
49836: PUSH
49837: EMPTY
49838: LIST
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PUSH
49844: LD_INT 3
49846: PUSH
49847: LD_INT 24
49849: PUSH
49850: LD_INT 250
49852: PUSH
49853: EMPTY
49854: LIST
49855: LIST
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: LIST
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PPUSH
49870: CALL_OW 72
49874: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
49875: LD_ADDR_VAR 0 7
49879: PUSH
49880: LD_VAR 0 5
49884: PUSH
49885: LD_VAR 0 6
49889: DIFF
49890: ST_TO_ADDR
// if not need_heal_1 then
49891: LD_VAR 0 6
49895: NOT
49896: IFFALSE 49929
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
49898: LD_ADDR_EXP 17
49902: PUSH
49903: LD_EXP 17
49907: PPUSH
49908: LD_VAR 0 2
49912: PUSH
49913: LD_INT 1
49915: PUSH
49916: EMPTY
49917: LIST
49918: LIST
49919: PPUSH
49920: EMPTY
49921: PPUSH
49922: CALL 9445 0 3
49926: ST_TO_ADDR
49927: GO 49999
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
49929: LD_ADDR_EXP 17
49933: PUSH
49934: LD_EXP 17
49938: PPUSH
49939: LD_VAR 0 2
49943: PUSH
49944: LD_INT 1
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: PPUSH
49951: LD_EXP 17
49955: PUSH
49956: LD_VAR 0 2
49960: ARRAY
49961: PUSH
49962: LD_INT 1
49964: ARRAY
49965: PPUSH
49966: LD_INT 3
49968: PUSH
49969: LD_INT 24
49971: PUSH
49972: LD_INT 1000
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: PPUSH
49983: CALL_OW 72
49987: PUSH
49988: LD_VAR 0 6
49992: UNION
49993: PPUSH
49994: CALL 9445 0 3
49998: ST_TO_ADDR
// if not need_heal_2 then
49999: LD_VAR 0 7
50003: NOT
50004: IFFALSE 50037
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
50006: LD_ADDR_EXP 17
50010: PUSH
50011: LD_EXP 17
50015: PPUSH
50016: LD_VAR 0 2
50020: PUSH
50021: LD_INT 2
50023: PUSH
50024: EMPTY
50025: LIST
50026: LIST
50027: PPUSH
50028: EMPTY
50029: PPUSH
50030: CALL 9445 0 3
50034: ST_TO_ADDR
50035: GO 50069
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
50037: LD_ADDR_EXP 17
50041: PUSH
50042: LD_EXP 17
50046: PPUSH
50047: LD_VAR 0 2
50051: PUSH
50052: LD_INT 2
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PPUSH
50059: LD_VAR 0 7
50063: PPUSH
50064: CALL 9445 0 3
50068: ST_TO_ADDR
// if need_heal_2 then
50069: LD_VAR 0 7
50073: IFFALSE 50234
// for j in need_heal_2 do
50075: LD_ADDR_VAR 0 3
50079: PUSH
50080: LD_VAR 0 7
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50232
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50088: LD_ADDR_VAR 0 5
50092: PUSH
50093: LD_EXP 14
50097: PUSH
50098: LD_VAR 0 2
50102: ARRAY
50103: PPUSH
50104: LD_INT 2
50106: PUSH
50107: LD_INT 30
50109: PUSH
50110: LD_INT 6
50112: PUSH
50113: EMPTY
50114: LIST
50115: LIST
50116: PUSH
50117: LD_INT 30
50119: PUSH
50120: LD_INT 7
50122: PUSH
50123: EMPTY
50124: LIST
50125: LIST
50126: PUSH
50127: LD_INT 30
50129: PUSH
50130: LD_INT 8
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PUSH
50137: LD_INT 30
50139: PUSH
50140: LD_INT 0
50142: PUSH
50143: EMPTY
50144: LIST
50145: LIST
50146: PUSH
50147: LD_INT 30
50149: PUSH
50150: LD_INT 1
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PUSH
50157: EMPTY
50158: LIST
50159: LIST
50160: LIST
50161: LIST
50162: LIST
50163: LIST
50164: PPUSH
50165: CALL_OW 72
50169: ST_TO_ADDR
// if tmp then
50170: LD_VAR 0 5
50174: IFFALSE 50230
// begin k := NearestUnitToUnit ( tmp , j ) ;
50176: LD_ADDR_VAR 0 4
50180: PUSH
50181: LD_VAR 0 5
50185: PPUSH
50186: LD_VAR 0 3
50190: PPUSH
50191: CALL_OW 74
50195: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
50196: LD_VAR 0 3
50200: PPUSH
50201: LD_VAR 0 4
50205: PPUSH
50206: CALL_OW 296
50210: PUSH
50211: LD_INT 5
50213: GREATER
50214: IFFALSE 50230
// ComMoveUnit ( j , k ) ;
50216: LD_VAR 0 3
50220: PPUSH
50221: LD_VAR 0 4
50225: PPUSH
50226: CALL_OW 112
// end ; end ;
50230: GO 50085
50232: POP
50233: POP
// if not need_heal_1 and not need_heal_2 then
50234: LD_VAR 0 6
50238: NOT
50239: PUSH
50240: LD_VAR 0 7
50244: NOT
50245: AND
50246: IFFALSE 50250
// continue ;
50248: GO 49714
// end ;
50250: GO 49714
50252: POP
50253: POP
// RaiseSailEvent ( 102 ) ;
50254: LD_INT 102
50256: PPUSH
50257: CALL_OW 427
// end ;
50261: LD_VAR 0 1
50265: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
50266: LD_INT 0
50268: PPUSH
50269: PPUSH
50270: PPUSH
50271: PPUSH
50272: PPUSH
50273: PPUSH
50274: PPUSH
50275: PPUSH
// if not mc_bases then
50276: LD_EXP 14
50280: NOT
50281: IFFALSE 50285
// exit ;
50283: GO 51120
// for i = 1 to mc_bases do
50285: LD_ADDR_VAR 0 2
50289: PUSH
50290: DOUBLE
50291: LD_INT 1
50293: DEC
50294: ST_TO_ADDR
50295: LD_EXP 14
50299: PUSH
50300: FOR_TO
50301: IFFALSE 51118
// begin if not mc_building_need_repair [ i ] then
50303: LD_EXP 15
50307: PUSH
50308: LD_VAR 0 2
50312: ARRAY
50313: NOT
50314: IFFALSE 50488
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
50316: LD_ADDR_VAR 0 6
50320: PUSH
50321: LD_EXP 33
50325: PUSH
50326: LD_VAR 0 2
50330: ARRAY
50331: PPUSH
50332: LD_INT 3
50334: PUSH
50335: LD_INT 24
50337: PUSH
50338: LD_INT 1000
50340: PUSH
50341: EMPTY
50342: LIST
50343: LIST
50344: PUSH
50345: EMPTY
50346: LIST
50347: LIST
50348: PUSH
50349: LD_INT 2
50351: PUSH
50352: LD_INT 34
50354: PUSH
50355: LD_INT 13
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 34
50364: PUSH
50365: LD_INT 52
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: LIST
50376: PUSH
50377: EMPTY
50378: LIST
50379: LIST
50380: PPUSH
50381: CALL_OW 72
50385: ST_TO_ADDR
// if cranes then
50386: LD_VAR 0 6
50390: IFFALSE 50452
// for j in cranes do
50392: LD_ADDR_VAR 0 3
50396: PUSH
50397: LD_VAR 0 6
50401: PUSH
50402: FOR_IN
50403: IFFALSE 50450
// if not IsInArea ( j , mc_parking [ i ] ) then
50405: LD_VAR 0 3
50409: PPUSH
50410: LD_EXP 38
50414: PUSH
50415: LD_VAR 0 2
50419: ARRAY
50420: PPUSH
50421: CALL_OW 308
50425: NOT
50426: IFFALSE 50448
// ComMoveToArea ( j , mc_parking [ i ] ) ;
50428: LD_VAR 0 3
50432: PPUSH
50433: LD_EXP 38
50437: PUSH
50438: LD_VAR 0 2
50442: ARRAY
50443: PPUSH
50444: CALL_OW 113
50448: GO 50402
50450: POP
50451: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
50452: LD_ADDR_EXP 16
50456: PUSH
50457: LD_EXP 16
50461: PPUSH
50462: LD_VAR 0 2
50466: PPUSH
50467: EMPTY
50468: PPUSH
50469: CALL_OW 1
50473: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
50474: LD_VAR 0 2
50478: PPUSH
50479: LD_INT 101
50481: PPUSH
50482: CALL 45389 0 2
// continue ;
50486: GO 50300
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
50488: LD_ADDR_EXP 20
50492: PUSH
50493: LD_EXP 20
50497: PPUSH
50498: LD_VAR 0 2
50502: PPUSH
50503: EMPTY
50504: PPUSH
50505: CALL_OW 1
50509: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50510: LD_VAR 0 2
50514: PPUSH
50515: LD_INT 103
50517: PPUSH
50518: CALL 45389 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
50522: LD_ADDR_VAR 0 5
50526: PUSH
50527: LD_EXP 14
50531: PUSH
50532: LD_VAR 0 2
50536: ARRAY
50537: PUSH
50538: LD_EXP 43
50542: PUSH
50543: LD_VAR 0 2
50547: ARRAY
50548: UNION
50549: PPUSH
50550: LD_INT 2
50552: PUSH
50553: LD_INT 25
50555: PUSH
50556: LD_INT 2
50558: PUSH
50559: EMPTY
50560: LIST
50561: LIST
50562: PUSH
50563: LD_INT 25
50565: PUSH
50566: LD_INT 16
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PUSH
50573: EMPTY
50574: LIST
50575: LIST
50576: LIST
50577: PUSH
50578: EMPTY
50579: LIST
50580: PPUSH
50581: CALL_OW 72
50585: PUSH
50586: LD_EXP 17
50590: PUSH
50591: LD_VAR 0 2
50595: ARRAY
50596: PUSH
50597: LD_INT 1
50599: ARRAY
50600: PUSH
50601: LD_EXP 17
50605: PUSH
50606: LD_VAR 0 2
50610: ARRAY
50611: PUSH
50612: LD_INT 2
50614: ARRAY
50615: UNION
50616: DIFF
50617: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
50618: LD_ADDR_VAR 0 6
50622: PUSH
50623: LD_EXP 33
50627: PUSH
50628: LD_VAR 0 2
50632: ARRAY
50633: PPUSH
50634: LD_INT 2
50636: PUSH
50637: LD_INT 34
50639: PUSH
50640: LD_INT 13
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 34
50649: PUSH
50650: LD_INT 52
50652: PUSH
50653: EMPTY
50654: LIST
50655: LIST
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: LIST
50661: PPUSH
50662: CALL_OW 72
50666: ST_TO_ADDR
// if cranes then
50667: LD_VAR 0 6
50671: IFFALSE 50807
// begin for j in cranes do
50673: LD_ADDR_VAR 0 3
50677: PUSH
50678: LD_VAR 0 6
50682: PUSH
50683: FOR_IN
50684: IFFALSE 50805
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
50686: LD_VAR 0 3
50690: PPUSH
50691: CALL_OW 256
50695: PUSH
50696: LD_INT 500
50698: GREATEREQUAL
50699: PUSH
50700: LD_VAR 0 3
50704: PPUSH
50705: CALL_OW 314
50709: NOT
50710: AND
50711: IFFALSE 50745
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
50713: LD_VAR 0 3
50717: PPUSH
50718: LD_EXP 15
50722: PUSH
50723: LD_VAR 0 2
50727: ARRAY
50728: PPUSH
50729: LD_VAR 0 3
50733: PPUSH
50734: CALL_OW 74
50738: PPUSH
50739: CALL_OW 130
50743: GO 50803
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
50745: LD_VAR 0 3
50749: PPUSH
50750: CALL_OW 256
50754: PUSH
50755: LD_INT 500
50757: LESS
50758: PUSH
50759: LD_VAR 0 3
50763: PPUSH
50764: LD_EXP 38
50768: PUSH
50769: LD_VAR 0 2
50773: ARRAY
50774: PPUSH
50775: CALL_OW 308
50779: NOT
50780: AND
50781: IFFALSE 50803
// ComMoveToArea ( j , mc_parking [ i ] ) ;
50783: LD_VAR 0 3
50787: PPUSH
50788: LD_EXP 38
50792: PUSH
50793: LD_VAR 0 2
50797: ARRAY
50798: PPUSH
50799: CALL_OW 113
50803: GO 50683
50805: POP
50806: POP
// end ; if tmp > 3 then
50807: LD_VAR 0 5
50811: PUSH
50812: LD_INT 3
50814: GREATER
50815: IFFALSE 50835
// tmp := ShrinkArray ( tmp , 4 ) ;
50817: LD_ADDR_VAR 0 5
50821: PUSH
50822: LD_VAR 0 5
50826: PPUSH
50827: LD_INT 4
50829: PPUSH
50830: CALL 40803 0 2
50834: ST_TO_ADDR
// if not tmp then
50835: LD_VAR 0 5
50839: NOT
50840: IFFALSE 50844
// continue ;
50842: GO 50300
// for j in tmp do
50844: LD_ADDR_VAR 0 3
50848: PUSH
50849: LD_VAR 0 5
50853: PUSH
50854: FOR_IN
50855: IFFALSE 51114
// begin if IsInUnit ( j ) then
50857: LD_VAR 0 3
50861: PPUSH
50862: CALL_OW 310
50866: IFFALSE 50877
// ComExitBuilding ( j ) ;
50868: LD_VAR 0 3
50872: PPUSH
50873: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
50877: LD_VAR 0 3
50881: PUSH
50882: LD_EXP 16
50886: PUSH
50887: LD_VAR 0 2
50891: ARRAY
50892: IN
50893: NOT
50894: IFFALSE 50952
// begin SetTag ( j , 101 ) ;
50896: LD_VAR 0 3
50900: PPUSH
50901: LD_INT 101
50903: PPUSH
50904: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
50908: LD_ADDR_EXP 16
50912: PUSH
50913: LD_EXP 16
50917: PPUSH
50918: LD_VAR 0 2
50922: PUSH
50923: LD_EXP 16
50927: PUSH
50928: LD_VAR 0 2
50932: ARRAY
50933: PUSH
50934: LD_INT 1
50936: PLUS
50937: PUSH
50938: EMPTY
50939: LIST
50940: LIST
50941: PPUSH
50942: LD_VAR 0 3
50946: PPUSH
50947: CALL 9445 0 3
50951: ST_TO_ADDR
// end ; wait ( 1 ) ;
50952: LD_INT 1
50954: PPUSH
50955: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
50959: LD_ADDR_VAR 0 7
50963: PUSH
50964: LD_EXP 15
50968: PUSH
50969: LD_VAR 0 2
50973: ARRAY
50974: ST_TO_ADDR
// if mc_scan [ i ] then
50975: LD_EXP 37
50979: PUSH
50980: LD_VAR 0 2
50984: ARRAY
50985: IFFALSE 51047
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
50987: LD_ADDR_VAR 0 7
50991: PUSH
50992: LD_EXP 15
50996: PUSH
50997: LD_VAR 0 2
51001: ARRAY
51002: PPUSH
51003: LD_INT 3
51005: PUSH
51006: LD_INT 30
51008: PUSH
51009: LD_INT 32
51011: PUSH
51012: EMPTY
51013: LIST
51014: LIST
51015: PUSH
51016: LD_INT 30
51018: PUSH
51019: LD_INT 33
51021: PUSH
51022: EMPTY
51023: LIST
51024: LIST
51025: PUSH
51026: LD_INT 30
51028: PUSH
51029: LD_INT 31
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: PPUSH
51042: CALL_OW 72
51046: ST_TO_ADDR
// if not to_repair_tmp then
51047: LD_VAR 0 7
51051: NOT
51052: IFFALSE 51056
// continue ;
51054: GO 50854
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
51056: LD_ADDR_VAR 0 8
51060: PUSH
51061: LD_VAR 0 7
51065: PPUSH
51066: LD_VAR 0 3
51070: PPUSH
51071: CALL_OW 74
51075: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
51076: LD_VAR 0 8
51080: PPUSH
51081: LD_INT 16
51083: PPUSH
51084: CALL 12038 0 2
51088: PUSH
51089: LD_INT 4
51091: ARRAY
51092: PUSH
51093: LD_INT 5
51095: LESS
51096: IFFALSE 51112
// ComRepairBuilding ( j , to_repair ) ;
51098: LD_VAR 0 3
51102: PPUSH
51103: LD_VAR 0 8
51107: PPUSH
51108: CALL_OW 130
// end ;
51112: GO 50854
51114: POP
51115: POP
// end ;
51116: GO 50300
51118: POP
51119: POP
// end ;
51120: LD_VAR 0 1
51124: RET
// export function MC_Heal ; var i , j , tmp ; begin
51125: LD_INT 0
51127: PPUSH
51128: PPUSH
51129: PPUSH
51130: PPUSH
// if not mc_bases then
51131: LD_EXP 14
51135: NOT
51136: IFFALSE 51140
// exit ;
51138: GO 51542
// for i = 1 to mc_bases do
51140: LD_ADDR_VAR 0 2
51144: PUSH
51145: DOUBLE
51146: LD_INT 1
51148: DEC
51149: ST_TO_ADDR
51150: LD_EXP 14
51154: PUSH
51155: FOR_TO
51156: IFFALSE 51540
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
51158: LD_EXP 17
51162: PUSH
51163: LD_VAR 0 2
51167: ARRAY
51168: PUSH
51169: LD_INT 1
51171: ARRAY
51172: NOT
51173: PUSH
51174: LD_EXP 17
51178: PUSH
51179: LD_VAR 0 2
51183: ARRAY
51184: PUSH
51185: LD_INT 2
51187: ARRAY
51188: NOT
51189: AND
51190: IFFALSE 51228
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
51192: LD_ADDR_EXP 18
51196: PUSH
51197: LD_EXP 18
51201: PPUSH
51202: LD_VAR 0 2
51206: PPUSH
51207: EMPTY
51208: PPUSH
51209: CALL_OW 1
51213: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
51214: LD_VAR 0 2
51218: PPUSH
51219: LD_INT 102
51221: PPUSH
51222: CALL 45389 0 2
// continue ;
51226: GO 51155
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
51228: LD_ADDR_VAR 0 4
51232: PUSH
51233: LD_EXP 14
51237: PUSH
51238: LD_VAR 0 2
51242: ARRAY
51243: PPUSH
51244: LD_INT 25
51246: PUSH
51247: LD_INT 4
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PPUSH
51254: CALL_OW 72
51258: ST_TO_ADDR
// if not tmp then
51259: LD_VAR 0 4
51263: NOT
51264: IFFALSE 51268
// continue ;
51266: GO 51155
// if mc_taming [ i ] then
51268: LD_EXP 45
51272: PUSH
51273: LD_VAR 0 2
51277: ARRAY
51278: IFFALSE 51302
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
51280: LD_ADDR_EXP 45
51284: PUSH
51285: LD_EXP 45
51289: PPUSH
51290: LD_VAR 0 2
51294: PPUSH
51295: EMPTY
51296: PPUSH
51297: CALL_OW 1
51301: ST_TO_ADDR
// for j in tmp do
51302: LD_ADDR_VAR 0 3
51306: PUSH
51307: LD_VAR 0 4
51311: PUSH
51312: FOR_IN
51313: IFFALSE 51536
// begin if IsInUnit ( j ) then
51315: LD_VAR 0 3
51319: PPUSH
51320: CALL_OW 310
51324: IFFALSE 51335
// ComExitBuilding ( j ) ;
51326: LD_VAR 0 3
51330: PPUSH
51331: CALL_OW 122
// if not j in mc_healers [ i ] then
51335: LD_VAR 0 3
51339: PUSH
51340: LD_EXP 18
51344: PUSH
51345: LD_VAR 0 2
51349: ARRAY
51350: IN
51351: NOT
51352: IFFALSE 51398
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
51354: LD_ADDR_EXP 18
51358: PUSH
51359: LD_EXP 18
51363: PPUSH
51364: LD_VAR 0 2
51368: PUSH
51369: LD_EXP 18
51373: PUSH
51374: LD_VAR 0 2
51378: ARRAY
51379: PUSH
51380: LD_INT 1
51382: PLUS
51383: PUSH
51384: EMPTY
51385: LIST
51386: LIST
51387: PPUSH
51388: LD_VAR 0 3
51392: PPUSH
51393: CALL 9445 0 3
51397: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
51398: LD_VAR 0 3
51402: PPUSH
51403: CALL_OW 110
51407: PUSH
51408: LD_INT 102
51410: NONEQUAL
51411: IFFALSE 51425
// SetTag ( j , 102 ) ;
51413: LD_VAR 0 3
51417: PPUSH
51418: LD_INT 102
51420: PPUSH
51421: CALL_OW 109
// Wait ( 3 ) ;
51425: LD_INT 3
51427: PPUSH
51428: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
51432: LD_EXP 17
51436: PUSH
51437: LD_VAR 0 2
51441: ARRAY
51442: PUSH
51443: LD_INT 1
51445: ARRAY
51446: IFFALSE 51478
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
51448: LD_VAR 0 3
51452: PPUSH
51453: LD_EXP 17
51457: PUSH
51458: LD_VAR 0 2
51462: ARRAY
51463: PUSH
51464: LD_INT 1
51466: ARRAY
51467: PUSH
51468: LD_INT 1
51470: ARRAY
51471: PPUSH
51472: CALL_OW 128
51476: GO 51534
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
51478: LD_VAR 0 3
51482: PPUSH
51483: CALL_OW 314
51487: NOT
51488: PUSH
51489: LD_EXP 17
51493: PUSH
51494: LD_VAR 0 2
51498: ARRAY
51499: PUSH
51500: LD_INT 2
51502: ARRAY
51503: AND
51504: IFFALSE 51534
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
51506: LD_VAR 0 3
51510: PPUSH
51511: LD_EXP 17
51515: PUSH
51516: LD_VAR 0 2
51520: ARRAY
51521: PUSH
51522: LD_INT 2
51524: ARRAY
51525: PUSH
51526: LD_INT 1
51528: ARRAY
51529: PPUSH
51530: CALL_OW 128
// end ;
51534: GO 51312
51536: POP
51537: POP
// end ;
51538: GO 51155
51540: POP
51541: POP
// end ;
51542: LD_VAR 0 1
51546: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
51547: LD_INT 0
51549: PPUSH
51550: PPUSH
51551: PPUSH
51552: PPUSH
51553: PPUSH
// if not mc_bases then
51554: LD_EXP 14
51558: NOT
51559: IFFALSE 51563
// exit ;
51561: GO 52706
// for i = 1 to mc_bases do
51563: LD_ADDR_VAR 0 2
51567: PUSH
51568: DOUBLE
51569: LD_INT 1
51571: DEC
51572: ST_TO_ADDR
51573: LD_EXP 14
51577: PUSH
51578: FOR_TO
51579: IFFALSE 52704
// begin if mc_scan [ i ] then
51581: LD_EXP 37
51585: PUSH
51586: LD_VAR 0 2
51590: ARRAY
51591: IFFALSE 51595
// continue ;
51593: GO 51578
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
51595: LD_EXP 19
51599: PUSH
51600: LD_VAR 0 2
51604: ARRAY
51605: NOT
51606: PUSH
51607: LD_EXP 21
51611: PUSH
51612: LD_VAR 0 2
51616: ARRAY
51617: NOT
51618: AND
51619: PUSH
51620: LD_EXP 20
51624: PUSH
51625: LD_VAR 0 2
51629: ARRAY
51630: AND
51631: IFFALSE 51669
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
51633: LD_ADDR_EXP 20
51637: PUSH
51638: LD_EXP 20
51642: PPUSH
51643: LD_VAR 0 2
51647: PPUSH
51648: EMPTY
51649: PPUSH
51650: CALL_OW 1
51654: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
51655: LD_VAR 0 2
51659: PPUSH
51660: LD_INT 103
51662: PPUSH
51663: CALL 45389 0 2
// continue ;
51667: GO 51578
// end ; if mc_construct_list [ i ] then
51669: LD_EXP 21
51673: PUSH
51674: LD_VAR 0 2
51678: ARRAY
51679: IFFALSE 51899
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
51681: LD_ADDR_VAR 0 4
51685: PUSH
51686: LD_EXP 14
51690: PUSH
51691: LD_VAR 0 2
51695: ARRAY
51696: PPUSH
51697: LD_INT 25
51699: PUSH
51700: LD_INT 2
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: PPUSH
51707: CALL_OW 72
51711: PUSH
51712: LD_EXP 16
51716: PUSH
51717: LD_VAR 0 2
51721: ARRAY
51722: DIFF
51723: ST_TO_ADDR
// if not tmp then
51724: LD_VAR 0 4
51728: NOT
51729: IFFALSE 51733
// continue ;
51731: GO 51578
// for j in tmp do
51733: LD_ADDR_VAR 0 3
51737: PUSH
51738: LD_VAR 0 4
51742: PUSH
51743: FOR_IN
51744: IFFALSE 51895
// begin if not mc_builders [ i ] then
51746: LD_EXP 20
51750: PUSH
51751: LD_VAR 0 2
51755: ARRAY
51756: NOT
51757: IFFALSE 51815
// begin SetTag ( j , 103 ) ;
51759: LD_VAR 0 3
51763: PPUSH
51764: LD_INT 103
51766: PPUSH
51767: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
51771: LD_ADDR_EXP 20
51775: PUSH
51776: LD_EXP 20
51780: PPUSH
51781: LD_VAR 0 2
51785: PUSH
51786: LD_EXP 20
51790: PUSH
51791: LD_VAR 0 2
51795: ARRAY
51796: PUSH
51797: LD_INT 1
51799: PLUS
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: PPUSH
51805: LD_VAR 0 3
51809: PPUSH
51810: CALL 9445 0 3
51814: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
51815: LD_VAR 0 3
51819: PPUSH
51820: CALL_OW 310
51824: IFFALSE 51835
// ComExitBuilding ( j ) ;
51826: LD_VAR 0 3
51830: PPUSH
51831: CALL_OW 122
// wait ( 3 ) ;
51835: LD_INT 3
51837: PPUSH
51838: CALL_OW 67
// if not mc_construct_list [ i ] then
51842: LD_EXP 21
51846: PUSH
51847: LD_VAR 0 2
51851: ARRAY
51852: NOT
51853: IFFALSE 51857
// break ;
51855: GO 51895
// if not HasTask ( j ) then
51857: LD_VAR 0 3
51861: PPUSH
51862: CALL_OW 314
51866: NOT
51867: IFFALSE 51893
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
51869: LD_VAR 0 3
51873: PPUSH
51874: LD_EXP 21
51878: PUSH
51879: LD_VAR 0 2
51883: ARRAY
51884: PUSH
51885: LD_INT 1
51887: ARRAY
51888: PPUSH
51889: CALL 12296 0 2
// end ;
51893: GO 51743
51895: POP
51896: POP
// end else
51897: GO 52702
// if mc_build_list [ i ] then
51899: LD_EXP 19
51903: PUSH
51904: LD_VAR 0 2
51908: ARRAY
51909: IFFALSE 52702
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51911: LD_ADDR_VAR 0 5
51915: PUSH
51916: LD_EXP 14
51920: PUSH
51921: LD_VAR 0 2
51925: ARRAY
51926: PPUSH
51927: LD_INT 2
51929: PUSH
51930: LD_INT 30
51932: PUSH
51933: LD_INT 0
51935: PUSH
51936: EMPTY
51937: LIST
51938: LIST
51939: PUSH
51940: LD_INT 30
51942: PUSH
51943: LD_INT 1
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: PUSH
51950: EMPTY
51951: LIST
51952: LIST
51953: LIST
51954: PPUSH
51955: CALL_OW 72
51959: ST_TO_ADDR
// if depot then
51960: LD_VAR 0 5
51964: IFFALSE 51982
// depot := depot [ 1 ] else
51966: LD_ADDR_VAR 0 5
51970: PUSH
51971: LD_VAR 0 5
51975: PUSH
51976: LD_INT 1
51978: ARRAY
51979: ST_TO_ADDR
51980: GO 51990
// depot := 0 ;
51982: LD_ADDR_VAR 0 5
51986: PUSH
51987: LD_INT 0
51989: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
51990: LD_EXP 19
51994: PUSH
51995: LD_VAR 0 2
51999: ARRAY
52000: PUSH
52001: LD_INT 1
52003: ARRAY
52004: PUSH
52005: LD_INT 1
52007: ARRAY
52008: PPUSH
52009: CALL 12126 0 1
52013: PUSH
52014: LD_EXP 14
52018: PUSH
52019: LD_VAR 0 2
52023: ARRAY
52024: PPUSH
52025: LD_INT 2
52027: PUSH
52028: LD_INT 30
52030: PUSH
52031: LD_INT 2
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: PUSH
52038: LD_INT 30
52040: PUSH
52041: LD_INT 3
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: PUSH
52048: EMPTY
52049: LIST
52050: LIST
52051: LIST
52052: PPUSH
52053: CALL_OW 72
52057: NOT
52058: AND
52059: IFFALSE 52164
// begin for j = 1 to mc_build_list [ i ] do
52061: LD_ADDR_VAR 0 3
52065: PUSH
52066: DOUBLE
52067: LD_INT 1
52069: DEC
52070: ST_TO_ADDR
52071: LD_EXP 19
52075: PUSH
52076: LD_VAR 0 2
52080: ARRAY
52081: PUSH
52082: FOR_TO
52083: IFFALSE 52162
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
52085: LD_EXP 19
52089: PUSH
52090: LD_VAR 0 2
52094: ARRAY
52095: PUSH
52096: LD_VAR 0 3
52100: ARRAY
52101: PUSH
52102: LD_INT 1
52104: ARRAY
52105: PUSH
52106: LD_INT 2
52108: EQUAL
52109: IFFALSE 52160
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
52111: LD_ADDR_EXP 19
52115: PUSH
52116: LD_EXP 19
52120: PPUSH
52121: LD_VAR 0 2
52125: PPUSH
52126: LD_EXP 19
52130: PUSH
52131: LD_VAR 0 2
52135: ARRAY
52136: PPUSH
52137: LD_VAR 0 3
52141: PPUSH
52142: LD_INT 1
52144: PPUSH
52145: LD_INT 0
52147: PPUSH
52148: CALL 8863 0 4
52152: PPUSH
52153: CALL_OW 1
52157: ST_TO_ADDR
// break ;
52158: GO 52162
// end ;
52160: GO 52082
52162: POP
52163: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
52164: LD_EXP 19
52168: PUSH
52169: LD_VAR 0 2
52173: ARRAY
52174: PUSH
52175: LD_INT 1
52177: ARRAY
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PUSH
52183: LD_INT 0
52185: EQUAL
52186: PUSH
52187: LD_VAR 0 5
52191: PUSH
52192: LD_VAR 0 5
52196: PPUSH
52197: LD_EXP 19
52201: PUSH
52202: LD_VAR 0 2
52206: ARRAY
52207: PUSH
52208: LD_INT 1
52210: ARRAY
52211: PUSH
52212: LD_INT 1
52214: ARRAY
52215: PPUSH
52216: LD_EXP 19
52220: PUSH
52221: LD_VAR 0 2
52225: ARRAY
52226: PUSH
52227: LD_INT 1
52229: ARRAY
52230: PUSH
52231: LD_INT 2
52233: ARRAY
52234: PPUSH
52235: LD_EXP 19
52239: PUSH
52240: LD_VAR 0 2
52244: ARRAY
52245: PUSH
52246: LD_INT 1
52248: ARRAY
52249: PUSH
52250: LD_INT 3
52252: ARRAY
52253: PPUSH
52254: LD_EXP 19
52258: PUSH
52259: LD_VAR 0 2
52263: ARRAY
52264: PUSH
52265: LD_INT 1
52267: ARRAY
52268: PUSH
52269: LD_INT 4
52271: ARRAY
52272: PPUSH
52273: CALL 16860 0 5
52277: AND
52278: OR
52279: IFFALSE 52560
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
52281: LD_ADDR_VAR 0 4
52285: PUSH
52286: LD_EXP 14
52290: PUSH
52291: LD_VAR 0 2
52295: ARRAY
52296: PPUSH
52297: LD_INT 25
52299: PUSH
52300: LD_INT 2
52302: PUSH
52303: EMPTY
52304: LIST
52305: LIST
52306: PPUSH
52307: CALL_OW 72
52311: PUSH
52312: LD_EXP 16
52316: PUSH
52317: LD_VAR 0 2
52321: ARRAY
52322: DIFF
52323: ST_TO_ADDR
// if not tmp then
52324: LD_VAR 0 4
52328: NOT
52329: IFFALSE 52333
// continue ;
52331: GO 51578
// for j in tmp do
52333: LD_ADDR_VAR 0 3
52337: PUSH
52338: LD_VAR 0 4
52342: PUSH
52343: FOR_IN
52344: IFFALSE 52556
// begin if not mc_builders [ i ] then
52346: LD_EXP 20
52350: PUSH
52351: LD_VAR 0 2
52355: ARRAY
52356: NOT
52357: IFFALSE 52415
// begin SetTag ( j , 103 ) ;
52359: LD_VAR 0 3
52363: PPUSH
52364: LD_INT 103
52366: PPUSH
52367: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
52371: LD_ADDR_EXP 20
52375: PUSH
52376: LD_EXP 20
52380: PPUSH
52381: LD_VAR 0 2
52385: PUSH
52386: LD_EXP 20
52390: PUSH
52391: LD_VAR 0 2
52395: ARRAY
52396: PUSH
52397: LD_INT 1
52399: PLUS
52400: PUSH
52401: EMPTY
52402: LIST
52403: LIST
52404: PPUSH
52405: LD_VAR 0 3
52409: PPUSH
52410: CALL 9445 0 3
52414: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
52415: LD_VAR 0 3
52419: PPUSH
52420: CALL_OW 310
52424: IFFALSE 52435
// ComExitBuilding ( j ) ;
52426: LD_VAR 0 3
52430: PPUSH
52431: CALL_OW 122
// wait ( 3 ) ;
52435: LD_INT 3
52437: PPUSH
52438: CALL_OW 67
// if not mc_build_list [ i ] then
52442: LD_EXP 19
52446: PUSH
52447: LD_VAR 0 2
52451: ARRAY
52452: NOT
52453: IFFALSE 52457
// break ;
52455: GO 52556
// if not HasTask ( j ) then
52457: LD_VAR 0 3
52461: PPUSH
52462: CALL_OW 314
52466: NOT
52467: IFFALSE 52554
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
52469: LD_VAR 0 3
52473: PPUSH
52474: LD_EXP 19
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PUSH
52485: LD_INT 1
52487: ARRAY
52488: PUSH
52489: LD_INT 1
52491: ARRAY
52492: PPUSH
52493: LD_EXP 19
52497: PUSH
52498: LD_VAR 0 2
52502: ARRAY
52503: PUSH
52504: LD_INT 1
52506: ARRAY
52507: PUSH
52508: LD_INT 2
52510: ARRAY
52511: PPUSH
52512: LD_EXP 19
52516: PUSH
52517: LD_VAR 0 2
52521: ARRAY
52522: PUSH
52523: LD_INT 1
52525: ARRAY
52526: PUSH
52527: LD_INT 3
52529: ARRAY
52530: PPUSH
52531: LD_EXP 19
52535: PUSH
52536: LD_VAR 0 2
52540: ARRAY
52541: PUSH
52542: LD_INT 1
52544: ARRAY
52545: PUSH
52546: LD_INT 4
52548: ARRAY
52549: PPUSH
52550: CALL_OW 145
// end ;
52554: GO 52343
52556: POP
52557: POP
// end else
52558: GO 52702
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
52560: LD_EXP 14
52564: PUSH
52565: LD_VAR 0 2
52569: ARRAY
52570: PPUSH
52571: LD_EXP 19
52575: PUSH
52576: LD_VAR 0 2
52580: ARRAY
52581: PUSH
52582: LD_INT 1
52584: ARRAY
52585: PUSH
52586: LD_INT 1
52588: ARRAY
52589: PPUSH
52590: LD_EXP 19
52594: PUSH
52595: LD_VAR 0 2
52599: ARRAY
52600: PUSH
52601: LD_INT 1
52603: ARRAY
52604: PUSH
52605: LD_INT 2
52607: ARRAY
52608: PPUSH
52609: LD_EXP 19
52613: PUSH
52614: LD_VAR 0 2
52618: ARRAY
52619: PUSH
52620: LD_INT 1
52622: ARRAY
52623: PUSH
52624: LD_INT 3
52626: ARRAY
52627: PPUSH
52628: LD_EXP 19
52632: PUSH
52633: LD_VAR 0 2
52637: ARRAY
52638: PUSH
52639: LD_INT 1
52641: ARRAY
52642: PUSH
52643: LD_INT 4
52645: ARRAY
52646: PPUSH
52647: CALL 16196 0 5
52651: NOT
52652: IFFALSE 52702
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
52654: LD_ADDR_EXP 19
52658: PUSH
52659: LD_EXP 19
52663: PPUSH
52664: LD_VAR 0 2
52668: PPUSH
52669: LD_EXP 19
52673: PUSH
52674: LD_VAR 0 2
52678: ARRAY
52679: PPUSH
52680: LD_INT 1
52682: PPUSH
52683: LD_INT 1
52685: NEG
52686: PPUSH
52687: LD_INT 0
52689: PPUSH
52690: CALL 8863 0 4
52694: PPUSH
52695: CALL_OW 1
52699: ST_TO_ADDR
// continue ;
52700: GO 51578
// end ; end ; end ;
52702: GO 51578
52704: POP
52705: POP
// end ;
52706: LD_VAR 0 1
52710: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
52711: LD_INT 0
52713: PPUSH
52714: PPUSH
52715: PPUSH
52716: PPUSH
52717: PPUSH
52718: PPUSH
// if not mc_bases then
52719: LD_EXP 14
52723: NOT
52724: IFFALSE 52728
// exit ;
52726: GO 53155
// for i = 1 to mc_bases do
52728: LD_ADDR_VAR 0 2
52732: PUSH
52733: DOUBLE
52734: LD_INT 1
52736: DEC
52737: ST_TO_ADDR
52738: LD_EXP 14
52742: PUSH
52743: FOR_TO
52744: IFFALSE 53153
// begin tmp := mc_build_upgrade [ i ] ;
52746: LD_ADDR_VAR 0 4
52750: PUSH
52751: LD_EXP 46
52755: PUSH
52756: LD_VAR 0 2
52760: ARRAY
52761: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
52762: LD_ADDR_VAR 0 6
52766: PUSH
52767: LD_EXP 47
52771: PUSH
52772: LD_VAR 0 2
52776: ARRAY
52777: PPUSH
52778: LD_INT 2
52780: PUSH
52781: LD_INT 30
52783: PUSH
52784: LD_INT 6
52786: PUSH
52787: EMPTY
52788: LIST
52789: LIST
52790: PUSH
52791: LD_INT 30
52793: PUSH
52794: LD_INT 7
52796: PUSH
52797: EMPTY
52798: LIST
52799: LIST
52800: PUSH
52801: EMPTY
52802: LIST
52803: LIST
52804: LIST
52805: PPUSH
52806: CALL_OW 72
52810: ST_TO_ADDR
// if not tmp and not lab then
52811: LD_VAR 0 4
52815: NOT
52816: PUSH
52817: LD_VAR 0 6
52821: NOT
52822: AND
52823: IFFALSE 52827
// continue ;
52825: GO 52743
// if tmp then
52827: LD_VAR 0 4
52831: IFFALSE 52951
// for j in tmp do
52833: LD_ADDR_VAR 0 3
52837: PUSH
52838: LD_VAR 0 4
52842: PUSH
52843: FOR_IN
52844: IFFALSE 52949
// begin if UpgradeCost ( j ) then
52846: LD_VAR 0 3
52850: PPUSH
52851: CALL 15856 0 1
52855: IFFALSE 52947
// begin ComUpgrade ( j ) ;
52857: LD_VAR 0 3
52861: PPUSH
52862: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
52866: LD_ADDR_EXP 46
52870: PUSH
52871: LD_EXP 46
52875: PPUSH
52876: LD_VAR 0 2
52880: PPUSH
52881: LD_EXP 46
52885: PUSH
52886: LD_VAR 0 2
52890: ARRAY
52891: PUSH
52892: LD_VAR 0 3
52896: DIFF
52897: PPUSH
52898: CALL_OW 1
52902: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
52903: LD_ADDR_EXP 21
52907: PUSH
52908: LD_EXP 21
52912: PPUSH
52913: LD_VAR 0 2
52917: PUSH
52918: LD_EXP 21
52922: PUSH
52923: LD_VAR 0 2
52927: ARRAY
52928: PUSH
52929: LD_INT 1
52931: PLUS
52932: PUSH
52933: EMPTY
52934: LIST
52935: LIST
52936: PPUSH
52937: LD_VAR 0 3
52941: PPUSH
52942: CALL 9445 0 3
52946: ST_TO_ADDR
// end ; end ;
52947: GO 52843
52949: POP
52950: POP
// if not lab or not mc_lab_upgrade [ i ] then
52951: LD_VAR 0 6
52955: NOT
52956: PUSH
52957: LD_EXP 48
52961: PUSH
52962: LD_VAR 0 2
52966: ARRAY
52967: NOT
52968: OR
52969: IFFALSE 52973
// continue ;
52971: GO 52743
// for j in lab do
52973: LD_ADDR_VAR 0 3
52977: PUSH
52978: LD_VAR 0 6
52982: PUSH
52983: FOR_IN
52984: IFFALSE 53149
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
52986: LD_VAR 0 3
52990: PPUSH
52991: CALL_OW 266
52995: PUSH
52996: LD_INT 6
52998: PUSH
52999: LD_INT 7
53001: PUSH
53002: EMPTY
53003: LIST
53004: LIST
53005: IN
53006: PUSH
53007: LD_VAR 0 3
53011: PPUSH
53012: CALL_OW 461
53016: PUSH
53017: LD_INT 1
53019: NONEQUAL
53020: AND
53021: IFFALSE 53147
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
53023: LD_VAR 0 3
53027: PPUSH
53028: LD_EXP 48
53032: PUSH
53033: LD_VAR 0 2
53037: ARRAY
53038: PUSH
53039: LD_INT 1
53041: ARRAY
53042: PPUSH
53043: CALL 16061 0 2
53047: IFFALSE 53147
// begin ComCancel ( j ) ;
53049: LD_VAR 0 3
53053: PPUSH
53054: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
53058: LD_VAR 0 3
53062: PPUSH
53063: LD_EXP 48
53067: PUSH
53068: LD_VAR 0 2
53072: ARRAY
53073: PUSH
53074: LD_INT 1
53076: ARRAY
53077: PPUSH
53078: CALL_OW 207
// if not j in mc_construct_list [ i ] then
53082: LD_VAR 0 3
53086: PUSH
53087: LD_EXP 21
53091: PUSH
53092: LD_VAR 0 2
53096: ARRAY
53097: IN
53098: NOT
53099: IFFALSE 53145
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53101: LD_ADDR_EXP 21
53105: PUSH
53106: LD_EXP 21
53110: PPUSH
53111: LD_VAR 0 2
53115: PUSH
53116: LD_EXP 21
53120: PUSH
53121: LD_VAR 0 2
53125: ARRAY
53126: PUSH
53127: LD_INT 1
53129: PLUS
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: PPUSH
53135: LD_VAR 0 3
53139: PPUSH
53140: CALL 9445 0 3
53144: ST_TO_ADDR
// break ;
53145: GO 53149
// end ; end ; end ;
53147: GO 52983
53149: POP
53150: POP
// end ;
53151: GO 52743
53153: POP
53154: POP
// end ;
53155: LD_VAR 0 1
53159: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
53160: LD_INT 0
53162: PPUSH
53163: PPUSH
53164: PPUSH
53165: PPUSH
53166: PPUSH
53167: PPUSH
53168: PPUSH
53169: PPUSH
53170: PPUSH
// if not mc_bases then
53171: LD_EXP 14
53175: NOT
53176: IFFALSE 53180
// exit ;
53178: GO 53585
// for i = 1 to mc_bases do
53180: LD_ADDR_VAR 0 2
53184: PUSH
53185: DOUBLE
53186: LD_INT 1
53188: DEC
53189: ST_TO_ADDR
53190: LD_EXP 14
53194: PUSH
53195: FOR_TO
53196: IFFALSE 53583
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
53198: LD_EXP 22
53202: PUSH
53203: LD_VAR 0 2
53207: ARRAY
53208: NOT
53209: PUSH
53210: LD_EXP 14
53214: PUSH
53215: LD_VAR 0 2
53219: ARRAY
53220: PPUSH
53221: LD_INT 30
53223: PUSH
53224: LD_INT 3
53226: PUSH
53227: EMPTY
53228: LIST
53229: LIST
53230: PPUSH
53231: CALL_OW 72
53235: NOT
53236: OR
53237: IFFALSE 53241
// continue ;
53239: GO 53195
// busy := false ;
53241: LD_ADDR_VAR 0 8
53245: PUSH
53246: LD_INT 0
53248: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53249: LD_ADDR_VAR 0 4
53253: PUSH
53254: LD_EXP 14
53258: PUSH
53259: LD_VAR 0 2
53263: ARRAY
53264: PPUSH
53265: LD_INT 30
53267: PUSH
53268: LD_INT 3
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PPUSH
53275: CALL_OW 72
53279: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
53280: LD_ADDR_VAR 0 6
53284: PUSH
53285: LD_EXP 22
53289: PUSH
53290: LD_VAR 0 2
53294: ARRAY
53295: PPUSH
53296: LD_INT 2
53298: PUSH
53299: LD_INT 30
53301: PUSH
53302: LD_INT 32
53304: PUSH
53305: EMPTY
53306: LIST
53307: LIST
53308: PUSH
53309: LD_INT 30
53311: PUSH
53312: LD_INT 33
53314: PUSH
53315: EMPTY
53316: LIST
53317: LIST
53318: PUSH
53319: EMPTY
53320: LIST
53321: LIST
53322: LIST
53323: PPUSH
53324: CALL_OW 72
53328: ST_TO_ADDR
// if not t then
53329: LD_VAR 0 6
53333: NOT
53334: IFFALSE 53338
// continue ;
53336: GO 53195
// for j in tmp do
53338: LD_ADDR_VAR 0 3
53342: PUSH
53343: LD_VAR 0 4
53347: PUSH
53348: FOR_IN
53349: IFFALSE 53379
// if not BuildingStatus ( j ) = bs_idle then
53351: LD_VAR 0 3
53355: PPUSH
53356: CALL_OW 461
53360: PUSH
53361: LD_INT 2
53363: EQUAL
53364: NOT
53365: IFFALSE 53377
// begin busy := true ;
53367: LD_ADDR_VAR 0 8
53371: PUSH
53372: LD_INT 1
53374: ST_TO_ADDR
// break ;
53375: GO 53379
// end ;
53377: GO 53348
53379: POP
53380: POP
// if busy then
53381: LD_VAR 0 8
53385: IFFALSE 53389
// continue ;
53387: GO 53195
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
53389: LD_ADDR_VAR 0 7
53393: PUSH
53394: LD_VAR 0 6
53398: PPUSH
53399: LD_INT 35
53401: PUSH
53402: LD_INT 0
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: PPUSH
53409: CALL_OW 72
53413: ST_TO_ADDR
// if tw then
53414: LD_VAR 0 7
53418: IFFALSE 53495
// begin tw := tw [ 1 ] ;
53420: LD_ADDR_VAR 0 7
53424: PUSH
53425: LD_VAR 0 7
53429: PUSH
53430: LD_INT 1
53432: ARRAY
53433: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
53434: LD_ADDR_VAR 0 9
53438: PUSH
53439: LD_VAR 0 7
53443: PPUSH
53444: LD_EXP 39
53448: PUSH
53449: LD_VAR 0 2
53453: ARRAY
53454: PPUSH
53455: CALL 14415 0 2
53459: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
53460: LD_EXP 53
53464: PUSH
53465: LD_VAR 0 2
53469: ARRAY
53470: IFFALSE 53493
// if not weapon in mc_allowed_tower_weapons [ i ] then
53472: LD_VAR 0 9
53476: PUSH
53477: LD_EXP 53
53481: PUSH
53482: LD_VAR 0 2
53486: ARRAY
53487: IN
53488: NOT
53489: IFFALSE 53493
// continue ;
53491: GO 53195
// end else
53493: GO 53558
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
53495: LD_ADDR_VAR 0 5
53499: PUSH
53500: LD_EXP 22
53504: PUSH
53505: LD_VAR 0 2
53509: ARRAY
53510: PPUSH
53511: LD_VAR 0 4
53515: PPUSH
53516: CALL 40036 0 2
53520: ST_TO_ADDR
// if not tmp2 then
53521: LD_VAR 0 5
53525: NOT
53526: IFFALSE 53530
// continue ;
53528: GO 53195
// tw := tmp2 [ 1 ] ;
53530: LD_ADDR_VAR 0 7
53534: PUSH
53535: LD_VAR 0 5
53539: PUSH
53540: LD_INT 1
53542: ARRAY
53543: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
53544: LD_ADDR_VAR 0 9
53548: PUSH
53549: LD_VAR 0 5
53553: PUSH
53554: LD_INT 2
53556: ARRAY
53557: ST_TO_ADDR
// end ; if not weapon then
53558: LD_VAR 0 9
53562: NOT
53563: IFFALSE 53567
// continue ;
53565: GO 53195
// ComPlaceWeapon ( tw , weapon ) ;
53567: LD_VAR 0 7
53571: PPUSH
53572: LD_VAR 0 9
53576: PPUSH
53577: CALL_OW 148
// end ;
53581: GO 53195
53583: POP
53584: POP
// end ;
53585: LD_VAR 0 1
53589: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
53590: LD_INT 0
53592: PPUSH
53593: PPUSH
53594: PPUSH
53595: PPUSH
53596: PPUSH
53597: PPUSH
// if not mc_bases then
53598: LD_EXP 14
53602: NOT
53603: IFFALSE 53607
// exit ;
53605: GO 54383
// for i = 1 to mc_bases do
53607: LD_ADDR_VAR 0 2
53611: PUSH
53612: DOUBLE
53613: LD_INT 1
53615: DEC
53616: ST_TO_ADDR
53617: LD_EXP 14
53621: PUSH
53622: FOR_TO
53623: IFFALSE 54381
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
53625: LD_EXP 27
53629: PUSH
53630: LD_VAR 0 2
53634: ARRAY
53635: NOT
53636: PUSH
53637: LD_EXP 27
53641: PUSH
53642: LD_VAR 0 2
53646: ARRAY
53647: PUSH
53648: LD_EXP 28
53652: PUSH
53653: LD_VAR 0 2
53657: ARRAY
53658: EQUAL
53659: OR
53660: PUSH
53661: LD_EXP 37
53665: PUSH
53666: LD_VAR 0 2
53670: ARRAY
53671: OR
53672: IFFALSE 53676
// continue ;
53674: GO 53622
// if mc_miners [ i ] then
53676: LD_EXP 28
53680: PUSH
53681: LD_VAR 0 2
53685: ARRAY
53686: IFFALSE 54068
// begin for j = mc_miners [ i ] downto 1 do
53688: LD_ADDR_VAR 0 3
53692: PUSH
53693: DOUBLE
53694: LD_EXP 28
53698: PUSH
53699: LD_VAR 0 2
53703: ARRAY
53704: INC
53705: ST_TO_ADDR
53706: LD_INT 1
53708: PUSH
53709: FOR_DOWNTO
53710: IFFALSE 54066
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
53712: LD_EXP 28
53716: PUSH
53717: LD_VAR 0 2
53721: ARRAY
53722: PUSH
53723: LD_VAR 0 3
53727: ARRAY
53728: PPUSH
53729: CALL_OW 301
53733: PUSH
53734: LD_EXP 28
53738: PUSH
53739: LD_VAR 0 2
53743: ARRAY
53744: PUSH
53745: LD_VAR 0 3
53749: ARRAY
53750: PPUSH
53751: CALL_OW 257
53755: PUSH
53756: LD_INT 1
53758: NONEQUAL
53759: OR
53760: IFFALSE 53823
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
53762: LD_ADDR_VAR 0 5
53766: PUSH
53767: LD_EXP 28
53771: PUSH
53772: LD_VAR 0 2
53776: ARRAY
53777: PUSH
53778: LD_EXP 28
53782: PUSH
53783: LD_VAR 0 2
53787: ARRAY
53788: PUSH
53789: LD_VAR 0 3
53793: ARRAY
53794: DIFF
53795: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
53796: LD_ADDR_EXP 28
53800: PUSH
53801: LD_EXP 28
53805: PPUSH
53806: LD_VAR 0 2
53810: PPUSH
53811: LD_VAR 0 5
53815: PPUSH
53816: CALL_OW 1
53820: ST_TO_ADDR
// continue ;
53821: GO 53709
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
53823: LD_EXP 28
53827: PUSH
53828: LD_VAR 0 2
53832: ARRAY
53833: PUSH
53834: LD_VAR 0 3
53838: ARRAY
53839: PPUSH
53840: CALL_OW 257
53844: PUSH
53845: LD_INT 1
53847: EQUAL
53848: PUSH
53849: LD_EXP 28
53853: PUSH
53854: LD_VAR 0 2
53858: ARRAY
53859: PUSH
53860: LD_VAR 0 3
53864: ARRAY
53865: PPUSH
53866: CALL_OW 459
53870: NOT
53871: AND
53872: PUSH
53873: LD_EXP 28
53877: PUSH
53878: LD_VAR 0 2
53882: ARRAY
53883: PUSH
53884: LD_VAR 0 3
53888: ARRAY
53889: PPUSH
53890: CALL_OW 314
53894: NOT
53895: AND
53896: IFFALSE 54064
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
53898: LD_EXP 28
53902: PUSH
53903: LD_VAR 0 2
53907: ARRAY
53908: PUSH
53909: LD_VAR 0 3
53913: ARRAY
53914: PPUSH
53915: CALL_OW 310
53919: IFFALSE 53942
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
53921: LD_EXP 28
53925: PUSH
53926: LD_VAR 0 2
53930: ARRAY
53931: PUSH
53932: LD_VAR 0 3
53936: ARRAY
53937: PPUSH
53938: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
53942: LD_EXP 28
53946: PUSH
53947: LD_VAR 0 2
53951: ARRAY
53952: PUSH
53953: LD_VAR 0 3
53957: ARRAY
53958: PPUSH
53959: CALL_OW 314
53963: NOT
53964: IFFALSE 54064
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
53966: LD_EXP 28
53970: PUSH
53971: LD_VAR 0 2
53975: ARRAY
53976: PUSH
53977: LD_VAR 0 3
53981: ARRAY
53982: PPUSH
53983: LD_EXP 27
53987: PUSH
53988: LD_VAR 0 2
53992: ARRAY
53993: PUSH
53994: LD_VAR 0 3
53998: PUSH
53999: LD_EXP 27
54003: PUSH
54004: LD_VAR 0 2
54008: ARRAY
54009: MOD
54010: PUSH
54011: LD_INT 1
54013: PLUS
54014: ARRAY
54015: PUSH
54016: LD_INT 1
54018: ARRAY
54019: PPUSH
54020: LD_EXP 27
54024: PUSH
54025: LD_VAR 0 2
54029: ARRAY
54030: PUSH
54031: LD_VAR 0 3
54035: PUSH
54036: LD_EXP 27
54040: PUSH
54041: LD_VAR 0 2
54045: ARRAY
54046: MOD
54047: PUSH
54048: LD_INT 1
54050: PLUS
54051: ARRAY
54052: PUSH
54053: LD_INT 2
54055: ARRAY
54056: PPUSH
54057: LD_INT 0
54059: PPUSH
54060: CALL_OW 193
// end ; end ;
54064: GO 53709
54066: POP
54067: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
54068: LD_ADDR_VAR 0 5
54072: PUSH
54073: LD_EXP 14
54077: PUSH
54078: LD_VAR 0 2
54082: ARRAY
54083: PPUSH
54084: LD_INT 2
54086: PUSH
54087: LD_INT 30
54089: PUSH
54090: LD_INT 4
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: PUSH
54097: LD_INT 30
54099: PUSH
54100: LD_INT 5
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: PUSH
54107: LD_INT 30
54109: PUSH
54110: LD_INT 32
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: LIST
54121: LIST
54122: PPUSH
54123: CALL_OW 72
54127: ST_TO_ADDR
// if not tmp then
54128: LD_VAR 0 5
54132: NOT
54133: IFFALSE 54137
// continue ;
54135: GO 53622
// list := [ ] ;
54137: LD_ADDR_VAR 0 6
54141: PUSH
54142: EMPTY
54143: ST_TO_ADDR
// for j in tmp do
54144: LD_ADDR_VAR 0 3
54148: PUSH
54149: LD_VAR 0 5
54153: PUSH
54154: FOR_IN
54155: IFFALSE 54224
// begin for k in UnitsInside ( j ) do
54157: LD_ADDR_VAR 0 4
54161: PUSH
54162: LD_VAR 0 3
54166: PPUSH
54167: CALL_OW 313
54171: PUSH
54172: FOR_IN
54173: IFFALSE 54220
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
54175: LD_VAR 0 4
54179: PPUSH
54180: CALL_OW 257
54184: PUSH
54185: LD_INT 1
54187: EQUAL
54188: PUSH
54189: LD_VAR 0 4
54193: PPUSH
54194: CALL_OW 459
54198: NOT
54199: AND
54200: IFFALSE 54218
// list := list ^ k ;
54202: LD_ADDR_VAR 0 6
54206: PUSH
54207: LD_VAR 0 6
54211: PUSH
54212: LD_VAR 0 4
54216: ADD
54217: ST_TO_ADDR
54218: GO 54172
54220: POP
54221: POP
// end ;
54222: GO 54154
54224: POP
54225: POP
// list := list diff mc_miners [ i ] ;
54226: LD_ADDR_VAR 0 6
54230: PUSH
54231: LD_VAR 0 6
54235: PUSH
54236: LD_EXP 28
54240: PUSH
54241: LD_VAR 0 2
54245: ARRAY
54246: DIFF
54247: ST_TO_ADDR
// if not list then
54248: LD_VAR 0 6
54252: NOT
54253: IFFALSE 54257
// continue ;
54255: GO 53622
// k := mc_mines [ i ] - mc_miners [ i ] ;
54257: LD_ADDR_VAR 0 4
54261: PUSH
54262: LD_EXP 27
54266: PUSH
54267: LD_VAR 0 2
54271: ARRAY
54272: PUSH
54273: LD_EXP 28
54277: PUSH
54278: LD_VAR 0 2
54282: ARRAY
54283: MINUS
54284: ST_TO_ADDR
// if k > list then
54285: LD_VAR 0 4
54289: PUSH
54290: LD_VAR 0 6
54294: GREATER
54295: IFFALSE 54307
// k := list ;
54297: LD_ADDR_VAR 0 4
54301: PUSH
54302: LD_VAR 0 6
54306: ST_TO_ADDR
// for j = 1 to k do
54307: LD_ADDR_VAR 0 3
54311: PUSH
54312: DOUBLE
54313: LD_INT 1
54315: DEC
54316: ST_TO_ADDR
54317: LD_VAR 0 4
54321: PUSH
54322: FOR_TO
54323: IFFALSE 54377
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
54325: LD_ADDR_EXP 28
54329: PUSH
54330: LD_EXP 28
54334: PPUSH
54335: LD_VAR 0 2
54339: PUSH
54340: LD_EXP 28
54344: PUSH
54345: LD_VAR 0 2
54349: ARRAY
54350: PUSH
54351: LD_INT 1
54353: PLUS
54354: PUSH
54355: EMPTY
54356: LIST
54357: LIST
54358: PPUSH
54359: LD_VAR 0 6
54363: PUSH
54364: LD_VAR 0 3
54368: ARRAY
54369: PPUSH
54370: CALL 9445 0 3
54374: ST_TO_ADDR
54375: GO 54322
54377: POP
54378: POP
// end ;
54379: GO 53622
54381: POP
54382: POP
// end ;
54383: LD_VAR 0 1
54387: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
54388: LD_INT 0
54390: PPUSH
54391: PPUSH
54392: PPUSH
54393: PPUSH
54394: PPUSH
54395: PPUSH
54396: PPUSH
54397: PPUSH
54398: PPUSH
54399: PPUSH
// if not mc_bases then
54400: LD_EXP 14
54404: NOT
54405: IFFALSE 54409
// exit ;
54407: GO 56159
// for i = 1 to mc_bases do
54409: LD_ADDR_VAR 0 2
54413: PUSH
54414: DOUBLE
54415: LD_INT 1
54417: DEC
54418: ST_TO_ADDR
54419: LD_EXP 14
54423: PUSH
54424: FOR_TO
54425: IFFALSE 56157
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
54427: LD_EXP 14
54431: PUSH
54432: LD_VAR 0 2
54436: ARRAY
54437: NOT
54438: PUSH
54439: LD_EXP 21
54443: PUSH
54444: LD_VAR 0 2
54448: ARRAY
54449: OR
54450: IFFALSE 54454
// continue ;
54452: GO 54424
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
54454: LD_EXP 30
54458: PUSH
54459: LD_VAR 0 2
54463: ARRAY
54464: NOT
54465: PUSH
54466: LD_EXP 31
54470: PUSH
54471: LD_VAR 0 2
54475: ARRAY
54476: AND
54477: IFFALSE 54515
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54479: LD_ADDR_EXP 31
54483: PUSH
54484: LD_EXP 31
54488: PPUSH
54489: LD_VAR 0 2
54493: PPUSH
54494: EMPTY
54495: PPUSH
54496: CALL_OW 1
54500: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
54501: LD_VAR 0 2
54505: PPUSH
54506: LD_INT 107
54508: PPUSH
54509: CALL 45389 0 2
// continue ;
54513: GO 54424
// end ; target := [ ] ;
54515: LD_ADDR_VAR 0 6
54519: PUSH
54520: EMPTY
54521: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
54522: LD_ADDR_VAR 0 3
54526: PUSH
54527: DOUBLE
54528: LD_EXP 30
54532: PUSH
54533: LD_VAR 0 2
54537: ARRAY
54538: INC
54539: ST_TO_ADDR
54540: LD_INT 1
54542: PUSH
54543: FOR_DOWNTO
54544: IFFALSE 54804
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
54546: LD_EXP 30
54550: PUSH
54551: LD_VAR 0 2
54555: ARRAY
54556: PUSH
54557: LD_VAR 0 3
54561: ARRAY
54562: PUSH
54563: LD_INT 2
54565: ARRAY
54566: PPUSH
54567: LD_EXP 30
54571: PUSH
54572: LD_VAR 0 2
54576: ARRAY
54577: PUSH
54578: LD_VAR 0 3
54582: ARRAY
54583: PUSH
54584: LD_INT 3
54586: ARRAY
54587: PPUSH
54588: CALL_OW 488
54592: PUSH
54593: LD_EXP 30
54597: PUSH
54598: LD_VAR 0 2
54602: ARRAY
54603: PUSH
54604: LD_VAR 0 3
54608: ARRAY
54609: PUSH
54610: LD_INT 2
54612: ARRAY
54613: PPUSH
54614: LD_EXP 30
54618: PUSH
54619: LD_VAR 0 2
54623: ARRAY
54624: PUSH
54625: LD_VAR 0 3
54629: ARRAY
54630: PUSH
54631: LD_INT 3
54633: ARRAY
54634: PPUSH
54635: CALL_OW 284
54639: PUSH
54640: LD_INT 0
54642: EQUAL
54643: AND
54644: IFFALSE 54699
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
54646: LD_ADDR_VAR 0 5
54650: PUSH
54651: LD_EXP 30
54655: PUSH
54656: LD_VAR 0 2
54660: ARRAY
54661: PPUSH
54662: LD_VAR 0 3
54666: PPUSH
54667: CALL_OW 3
54671: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
54672: LD_ADDR_EXP 30
54676: PUSH
54677: LD_EXP 30
54681: PPUSH
54682: LD_VAR 0 2
54686: PPUSH
54687: LD_VAR 0 5
54691: PPUSH
54692: CALL_OW 1
54696: ST_TO_ADDR
// continue ;
54697: GO 54543
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
54699: LD_EXP 14
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: PUSH
54710: LD_INT 1
54712: ARRAY
54713: PPUSH
54714: CALL_OW 255
54718: PPUSH
54719: LD_EXP 30
54723: PUSH
54724: LD_VAR 0 2
54728: ARRAY
54729: PUSH
54730: LD_VAR 0 3
54734: ARRAY
54735: PUSH
54736: LD_INT 2
54738: ARRAY
54739: PPUSH
54740: LD_EXP 30
54744: PUSH
54745: LD_VAR 0 2
54749: ARRAY
54750: PUSH
54751: LD_VAR 0 3
54755: ARRAY
54756: PUSH
54757: LD_INT 3
54759: ARRAY
54760: PPUSH
54761: LD_INT 30
54763: PPUSH
54764: CALL 10341 0 4
54768: PUSH
54769: LD_INT 4
54771: ARRAY
54772: PUSH
54773: LD_INT 0
54775: EQUAL
54776: IFFALSE 54802
// begin target := mc_crates [ i ] [ j ] ;
54778: LD_ADDR_VAR 0 6
54782: PUSH
54783: LD_EXP 30
54787: PUSH
54788: LD_VAR 0 2
54792: ARRAY
54793: PUSH
54794: LD_VAR 0 3
54798: ARRAY
54799: ST_TO_ADDR
// break ;
54800: GO 54804
// end ; end ;
54802: GO 54543
54804: POP
54805: POP
// if not target then
54806: LD_VAR 0 6
54810: NOT
54811: IFFALSE 54815
// continue ;
54813: GO 54424
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
54815: LD_ADDR_VAR 0 7
54819: PUSH
54820: LD_EXP 33
54824: PUSH
54825: LD_VAR 0 2
54829: ARRAY
54830: PPUSH
54831: LD_INT 2
54833: PUSH
54834: LD_INT 3
54836: PUSH
54837: LD_INT 58
54839: PUSH
54840: EMPTY
54841: LIST
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: PUSH
54847: LD_INT 61
54849: PUSH
54850: EMPTY
54851: LIST
54852: PUSH
54853: LD_INT 33
54855: PUSH
54856: LD_INT 5
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: PUSH
54863: LD_INT 33
54865: PUSH
54866: LD_INT 3
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: PUSH
54873: EMPTY
54874: LIST
54875: LIST
54876: LIST
54877: LIST
54878: LIST
54879: PUSH
54880: LD_INT 2
54882: PUSH
54883: LD_INT 34
54885: PUSH
54886: LD_INT 32
54888: PUSH
54889: EMPTY
54890: LIST
54891: LIST
54892: PUSH
54893: LD_INT 34
54895: PUSH
54896: LD_INT 51
54898: PUSH
54899: EMPTY
54900: LIST
54901: LIST
54902: PUSH
54903: LD_INT 34
54905: PUSH
54906: LD_INT 12
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: PUSH
54913: EMPTY
54914: LIST
54915: LIST
54916: LIST
54917: LIST
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: PPUSH
54923: CALL_OW 72
54927: ST_TO_ADDR
// if not cargo then
54928: LD_VAR 0 7
54932: NOT
54933: IFFALSE 55576
// begin if mc_crates_collector [ i ] < 5 then
54935: LD_EXP 31
54939: PUSH
54940: LD_VAR 0 2
54944: ARRAY
54945: PUSH
54946: LD_INT 5
54948: LESS
54949: IFFALSE 55315
// begin if mc_ape [ i ] then
54951: LD_EXP 43
54955: PUSH
54956: LD_VAR 0 2
54960: ARRAY
54961: IFFALSE 55008
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
54963: LD_ADDR_VAR 0 5
54967: PUSH
54968: LD_EXP 43
54972: PUSH
54973: LD_VAR 0 2
54977: ARRAY
54978: PPUSH
54979: LD_INT 25
54981: PUSH
54982: LD_INT 16
54984: PUSH
54985: EMPTY
54986: LIST
54987: LIST
54988: PUSH
54989: LD_INT 24
54991: PUSH
54992: LD_INT 750
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: PUSH
54999: EMPTY
55000: LIST
55001: LIST
55002: PPUSH
55003: CALL_OW 72
55007: ST_TO_ADDR
// if not tmp then
55008: LD_VAR 0 5
55012: NOT
55013: IFFALSE 55060
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
55015: LD_ADDR_VAR 0 5
55019: PUSH
55020: LD_EXP 14
55024: PUSH
55025: LD_VAR 0 2
55029: ARRAY
55030: PPUSH
55031: LD_INT 25
55033: PUSH
55034: LD_INT 2
55036: PUSH
55037: EMPTY
55038: LIST
55039: LIST
55040: PUSH
55041: LD_INT 24
55043: PUSH
55044: LD_INT 750
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: PUSH
55051: EMPTY
55052: LIST
55053: LIST
55054: PPUSH
55055: CALL_OW 72
55059: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
55060: LD_EXP 43
55064: PUSH
55065: LD_VAR 0 2
55069: ARRAY
55070: PUSH
55071: LD_EXP 14
55075: PUSH
55076: LD_VAR 0 2
55080: ARRAY
55081: PPUSH
55082: LD_INT 25
55084: PUSH
55085: LD_INT 2
55087: PUSH
55088: EMPTY
55089: LIST
55090: LIST
55091: PUSH
55092: LD_INT 24
55094: PUSH
55095: LD_INT 750
55097: PUSH
55098: EMPTY
55099: LIST
55100: LIST
55101: PUSH
55102: EMPTY
55103: LIST
55104: LIST
55105: PPUSH
55106: CALL_OW 72
55110: AND
55111: PUSH
55112: LD_VAR 0 5
55116: PUSH
55117: LD_INT 5
55119: LESS
55120: AND
55121: IFFALSE 55203
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
55123: LD_ADDR_VAR 0 3
55127: PUSH
55128: LD_EXP 14
55132: PUSH
55133: LD_VAR 0 2
55137: ARRAY
55138: PPUSH
55139: LD_INT 25
55141: PUSH
55142: LD_INT 2
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: PUSH
55149: LD_INT 24
55151: PUSH
55152: LD_INT 750
55154: PUSH
55155: EMPTY
55156: LIST
55157: LIST
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: PPUSH
55163: CALL_OW 72
55167: PUSH
55168: FOR_IN
55169: IFFALSE 55201
// begin tmp := tmp union j ;
55171: LD_ADDR_VAR 0 5
55175: PUSH
55176: LD_VAR 0 5
55180: PUSH
55181: LD_VAR 0 3
55185: UNION
55186: ST_TO_ADDR
// if tmp >= 5 then
55187: LD_VAR 0 5
55191: PUSH
55192: LD_INT 5
55194: GREATEREQUAL
55195: IFFALSE 55199
// break ;
55197: GO 55201
// end ;
55199: GO 55168
55201: POP
55202: POP
// end ; if not tmp then
55203: LD_VAR 0 5
55207: NOT
55208: IFFALSE 55212
// continue ;
55210: GO 54424
// for j in tmp do
55212: LD_ADDR_VAR 0 3
55216: PUSH
55217: LD_VAR 0 5
55221: PUSH
55222: FOR_IN
55223: IFFALSE 55313
// if not GetTag ( j ) then
55225: LD_VAR 0 3
55229: PPUSH
55230: CALL_OW 110
55234: NOT
55235: IFFALSE 55311
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
55237: LD_ADDR_EXP 31
55241: PUSH
55242: LD_EXP 31
55246: PPUSH
55247: LD_VAR 0 2
55251: PUSH
55252: LD_EXP 31
55256: PUSH
55257: LD_VAR 0 2
55261: ARRAY
55262: PUSH
55263: LD_INT 1
55265: PLUS
55266: PUSH
55267: EMPTY
55268: LIST
55269: LIST
55270: PPUSH
55271: LD_VAR 0 3
55275: PPUSH
55276: CALL 9445 0 3
55280: ST_TO_ADDR
// SetTag ( j , 107 ) ;
55281: LD_VAR 0 3
55285: PPUSH
55286: LD_INT 107
55288: PPUSH
55289: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
55293: LD_EXP 31
55297: PUSH
55298: LD_VAR 0 2
55302: ARRAY
55303: PUSH
55304: LD_INT 5
55306: GREATEREQUAL
55307: IFFALSE 55311
// break ;
55309: GO 55313
// end ;
55311: GO 55222
55313: POP
55314: POP
// end ; if mc_crates_collector [ i ] and target then
55315: LD_EXP 31
55319: PUSH
55320: LD_VAR 0 2
55324: ARRAY
55325: PUSH
55326: LD_VAR 0 6
55330: AND
55331: IFFALSE 55574
// begin if mc_crates_collector [ i ] < target [ 1 ] then
55333: LD_EXP 31
55337: PUSH
55338: LD_VAR 0 2
55342: ARRAY
55343: PUSH
55344: LD_VAR 0 6
55348: PUSH
55349: LD_INT 1
55351: ARRAY
55352: LESS
55353: IFFALSE 55373
// tmp := mc_crates_collector [ i ] else
55355: LD_ADDR_VAR 0 5
55359: PUSH
55360: LD_EXP 31
55364: PUSH
55365: LD_VAR 0 2
55369: ARRAY
55370: ST_TO_ADDR
55371: GO 55387
// tmp := target [ 1 ] ;
55373: LD_ADDR_VAR 0 5
55377: PUSH
55378: LD_VAR 0 6
55382: PUSH
55383: LD_INT 1
55385: ARRAY
55386: ST_TO_ADDR
// k := 0 ;
55387: LD_ADDR_VAR 0 4
55391: PUSH
55392: LD_INT 0
55394: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
55395: LD_ADDR_VAR 0 3
55399: PUSH
55400: LD_EXP 31
55404: PUSH
55405: LD_VAR 0 2
55409: ARRAY
55410: PUSH
55411: FOR_IN
55412: IFFALSE 55572
// begin k := k + 1 ;
55414: LD_ADDR_VAR 0 4
55418: PUSH
55419: LD_VAR 0 4
55423: PUSH
55424: LD_INT 1
55426: PLUS
55427: ST_TO_ADDR
// if k > tmp then
55428: LD_VAR 0 4
55432: PUSH
55433: LD_VAR 0 5
55437: GREATER
55438: IFFALSE 55442
// break ;
55440: GO 55572
// if not GetClass ( j ) in [ 2 , 16 ] then
55442: LD_VAR 0 3
55446: PPUSH
55447: CALL_OW 257
55451: PUSH
55452: LD_INT 2
55454: PUSH
55455: LD_INT 16
55457: PUSH
55458: EMPTY
55459: LIST
55460: LIST
55461: IN
55462: NOT
55463: IFFALSE 55516
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
55465: LD_ADDR_EXP 31
55469: PUSH
55470: LD_EXP 31
55474: PPUSH
55475: LD_VAR 0 2
55479: PPUSH
55480: LD_EXP 31
55484: PUSH
55485: LD_VAR 0 2
55489: ARRAY
55490: PUSH
55491: LD_VAR 0 3
55495: DIFF
55496: PPUSH
55497: CALL_OW 1
55501: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55502: LD_VAR 0 3
55506: PPUSH
55507: LD_INT 0
55509: PPUSH
55510: CALL_OW 109
// continue ;
55514: GO 55411
// end ; if IsInUnit ( j ) then
55516: LD_VAR 0 3
55520: PPUSH
55521: CALL_OW 310
55525: IFFALSE 55536
// ComExitBuilding ( j ) ;
55527: LD_VAR 0 3
55531: PPUSH
55532: CALL_OW 122
// wait ( 3 ) ;
55536: LD_INT 3
55538: PPUSH
55539: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
55543: LD_VAR 0 3
55547: PPUSH
55548: LD_VAR 0 6
55552: PUSH
55553: LD_INT 2
55555: ARRAY
55556: PPUSH
55557: LD_VAR 0 6
55561: PUSH
55562: LD_INT 3
55564: ARRAY
55565: PPUSH
55566: CALL_OW 117
// end ;
55570: GO 55411
55572: POP
55573: POP
// end ; end else
55574: GO 56155
// begin for j in cargo do
55576: LD_ADDR_VAR 0 3
55580: PUSH
55581: LD_VAR 0 7
55585: PUSH
55586: FOR_IN
55587: IFFALSE 56153
// begin if GetTag ( j ) <> 0 then
55589: LD_VAR 0 3
55593: PPUSH
55594: CALL_OW 110
55598: PUSH
55599: LD_INT 0
55601: NONEQUAL
55602: IFFALSE 55606
// continue ;
55604: GO 55586
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
55606: LD_VAR 0 3
55610: PPUSH
55611: CALL_OW 256
55615: PUSH
55616: LD_INT 1000
55618: LESS
55619: PUSH
55620: LD_VAR 0 3
55624: PPUSH
55625: LD_EXP 38
55629: PUSH
55630: LD_VAR 0 2
55634: ARRAY
55635: PPUSH
55636: CALL_OW 308
55640: NOT
55641: AND
55642: IFFALSE 55664
// ComMoveToArea ( j , mc_parking [ i ] ) ;
55644: LD_VAR 0 3
55648: PPUSH
55649: LD_EXP 38
55653: PUSH
55654: LD_VAR 0 2
55658: ARRAY
55659: PPUSH
55660: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
55664: LD_VAR 0 3
55668: PPUSH
55669: CALL_OW 256
55673: PUSH
55674: LD_INT 1000
55676: LESS
55677: PUSH
55678: LD_VAR 0 3
55682: PPUSH
55683: LD_EXP 38
55687: PUSH
55688: LD_VAR 0 2
55692: ARRAY
55693: PPUSH
55694: CALL_OW 308
55698: AND
55699: IFFALSE 55703
// continue ;
55701: GO 55586
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
55703: LD_VAR 0 3
55707: PPUSH
55708: CALL_OW 262
55712: PUSH
55713: LD_INT 2
55715: EQUAL
55716: PUSH
55717: LD_VAR 0 3
55721: PPUSH
55722: CALL_OW 261
55726: PUSH
55727: LD_INT 15
55729: LESS
55730: AND
55731: IFFALSE 55735
// continue ;
55733: GO 55586
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
55735: LD_VAR 0 3
55739: PPUSH
55740: CALL_OW 262
55744: PUSH
55745: LD_INT 1
55747: EQUAL
55748: PUSH
55749: LD_VAR 0 3
55753: PPUSH
55754: CALL_OW 261
55758: PUSH
55759: LD_INT 10
55761: LESS
55762: AND
55763: IFFALSE 56092
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55765: LD_ADDR_VAR 0 8
55769: PUSH
55770: LD_EXP 14
55774: PUSH
55775: LD_VAR 0 2
55779: ARRAY
55780: PPUSH
55781: LD_INT 2
55783: PUSH
55784: LD_INT 30
55786: PUSH
55787: LD_INT 0
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: PUSH
55794: LD_INT 30
55796: PUSH
55797: LD_INT 1
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: LIST
55808: PPUSH
55809: CALL_OW 72
55813: ST_TO_ADDR
// if not depot then
55814: LD_VAR 0 8
55818: NOT
55819: IFFALSE 55823
// continue ;
55821: GO 55586
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
55823: LD_VAR 0 3
55827: PPUSH
55828: LD_VAR 0 8
55832: PPUSH
55833: LD_VAR 0 3
55837: PPUSH
55838: CALL_OW 74
55842: PPUSH
55843: CALL_OW 296
55847: PUSH
55848: LD_INT 6
55850: LESS
55851: IFFALSE 55867
// SetFuel ( j , 100 ) else
55853: LD_VAR 0 3
55857: PPUSH
55858: LD_INT 100
55860: PPUSH
55861: CALL_OW 240
55865: GO 56092
// if GetFuel ( j ) = 0 then
55867: LD_VAR 0 3
55871: PPUSH
55872: CALL_OW 261
55876: PUSH
55877: LD_INT 0
55879: EQUAL
55880: IFFALSE 56092
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
55882: LD_ADDR_EXP 33
55886: PUSH
55887: LD_EXP 33
55891: PPUSH
55892: LD_VAR 0 2
55896: PPUSH
55897: LD_EXP 33
55901: PUSH
55902: LD_VAR 0 2
55906: ARRAY
55907: PUSH
55908: LD_VAR 0 3
55912: DIFF
55913: PPUSH
55914: CALL_OW 1
55918: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
55919: LD_VAR 0 3
55923: PPUSH
55924: CALL_OW 263
55928: PUSH
55929: LD_INT 1
55931: EQUAL
55932: IFFALSE 55948
// ComExitVehicle ( IsInUnit ( j ) ) ;
55934: LD_VAR 0 3
55938: PPUSH
55939: CALL_OW 310
55943: PPUSH
55944: CALL_OW 121
// if GetControl ( j ) = control_remote then
55948: LD_VAR 0 3
55952: PPUSH
55953: CALL_OW 263
55957: PUSH
55958: LD_INT 2
55960: EQUAL
55961: IFFALSE 55972
// ComUnlink ( j ) ;
55963: LD_VAR 0 3
55967: PPUSH
55968: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
55972: LD_ADDR_VAR 0 9
55976: PUSH
55977: LD_VAR 0 2
55981: PPUSH
55982: LD_INT 3
55984: PPUSH
55985: CALL 65445 0 2
55989: ST_TO_ADDR
// if fac then
55990: LD_VAR 0 9
55994: IFFALSE 56090
// begin for k in fac do
55996: LD_ADDR_VAR 0 4
56000: PUSH
56001: LD_VAR 0 9
56005: PUSH
56006: FOR_IN
56007: IFFALSE 56088
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
56009: LD_ADDR_VAR 0 10
56013: PUSH
56014: LD_VAR 0 9
56018: PPUSH
56019: LD_VAR 0 3
56023: PPUSH
56024: CALL_OW 265
56028: PPUSH
56029: LD_VAR 0 3
56033: PPUSH
56034: CALL_OW 262
56038: PPUSH
56039: LD_VAR 0 3
56043: PPUSH
56044: CALL_OW 263
56048: PPUSH
56049: LD_VAR 0 3
56053: PPUSH
56054: CALL_OW 264
56058: PPUSH
56059: CALL 6977 0 5
56063: ST_TO_ADDR
// if components then
56064: LD_VAR 0 10
56068: IFFALSE 56086
// begin MC_InsertProduceList ( i , components ) ;
56070: LD_VAR 0 2
56074: PPUSH
56075: LD_VAR 0 10
56079: PPUSH
56080: CALL 64990 0 2
// break ;
56084: GO 56088
// end ; end ;
56086: GO 56006
56088: POP
56089: POP
// end ; continue ;
56090: GO 55586
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
56092: LD_VAR 0 3
56096: PPUSH
56097: LD_INT 1
56099: PPUSH
56100: CALL_OW 289
56104: PUSH
56105: LD_INT 100
56107: LESS
56108: PUSH
56109: LD_VAR 0 3
56113: PPUSH
56114: CALL_OW 314
56118: NOT
56119: AND
56120: IFFALSE 56149
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
56122: LD_VAR 0 3
56126: PPUSH
56127: LD_VAR 0 6
56131: PUSH
56132: LD_INT 2
56134: ARRAY
56135: PPUSH
56136: LD_VAR 0 6
56140: PUSH
56141: LD_INT 3
56143: ARRAY
56144: PPUSH
56145: CALL_OW 117
// break ;
56149: GO 56153
// end ;
56151: GO 55586
56153: POP
56154: POP
// end ; end ;
56155: GO 54424
56157: POP
56158: POP
// end ;
56159: LD_VAR 0 1
56163: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
56164: LD_INT 0
56166: PPUSH
56167: PPUSH
56168: PPUSH
56169: PPUSH
// if not mc_bases then
56170: LD_EXP 14
56174: NOT
56175: IFFALSE 56179
// exit ;
56177: GO 56340
// for i = 1 to mc_bases do
56179: LD_ADDR_VAR 0 2
56183: PUSH
56184: DOUBLE
56185: LD_INT 1
56187: DEC
56188: ST_TO_ADDR
56189: LD_EXP 14
56193: PUSH
56194: FOR_TO
56195: IFFALSE 56338
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
56197: LD_ADDR_VAR 0 4
56201: PUSH
56202: LD_EXP 33
56206: PUSH
56207: LD_VAR 0 2
56211: ARRAY
56212: PUSH
56213: LD_EXP 36
56217: PUSH
56218: LD_VAR 0 2
56222: ARRAY
56223: UNION
56224: PPUSH
56225: LD_INT 33
56227: PUSH
56228: LD_INT 2
56230: PUSH
56231: EMPTY
56232: LIST
56233: LIST
56234: PPUSH
56235: CALL_OW 72
56239: ST_TO_ADDR
// if tmp then
56240: LD_VAR 0 4
56244: IFFALSE 56336
// for j in tmp do
56246: LD_ADDR_VAR 0 3
56250: PUSH
56251: LD_VAR 0 4
56255: PUSH
56256: FOR_IN
56257: IFFALSE 56334
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
56259: LD_VAR 0 3
56263: PPUSH
56264: CALL_OW 312
56268: NOT
56269: PUSH
56270: LD_VAR 0 3
56274: PPUSH
56275: CALL_OW 256
56279: PUSH
56280: LD_INT 250
56282: GREATEREQUAL
56283: AND
56284: IFFALSE 56297
// Connect ( j ) else
56286: LD_VAR 0 3
56290: PPUSH
56291: CALL 12378 0 1
56295: GO 56332
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
56297: LD_VAR 0 3
56301: PPUSH
56302: CALL_OW 256
56306: PUSH
56307: LD_INT 250
56309: LESS
56310: PUSH
56311: LD_VAR 0 3
56315: PPUSH
56316: CALL_OW 312
56320: AND
56321: IFFALSE 56332
// ComUnlink ( j ) ;
56323: LD_VAR 0 3
56327: PPUSH
56328: CALL_OW 136
56332: GO 56256
56334: POP
56335: POP
// end ;
56336: GO 56194
56338: POP
56339: POP
// end ;
56340: LD_VAR 0 1
56344: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
56345: LD_INT 0
56347: PPUSH
56348: PPUSH
56349: PPUSH
56350: PPUSH
56351: PPUSH
// if not mc_bases then
56352: LD_EXP 14
56356: NOT
56357: IFFALSE 56361
// exit ;
56359: GO 56806
// for i = 1 to mc_bases do
56361: LD_ADDR_VAR 0 2
56365: PUSH
56366: DOUBLE
56367: LD_INT 1
56369: DEC
56370: ST_TO_ADDR
56371: LD_EXP 14
56375: PUSH
56376: FOR_TO
56377: IFFALSE 56804
// begin if not mc_produce [ i ] then
56379: LD_EXP 35
56383: PUSH
56384: LD_VAR 0 2
56388: ARRAY
56389: NOT
56390: IFFALSE 56394
// continue ;
56392: GO 56376
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56394: LD_ADDR_VAR 0 5
56398: PUSH
56399: LD_EXP 14
56403: PUSH
56404: LD_VAR 0 2
56408: ARRAY
56409: PPUSH
56410: LD_INT 30
56412: PUSH
56413: LD_INT 3
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: PPUSH
56420: CALL_OW 72
56424: ST_TO_ADDR
// if not fac then
56425: LD_VAR 0 5
56429: NOT
56430: IFFALSE 56434
// continue ;
56432: GO 56376
// for j in fac do
56434: LD_ADDR_VAR 0 3
56438: PUSH
56439: LD_VAR 0 5
56443: PUSH
56444: FOR_IN
56445: IFFALSE 56800
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
56447: LD_VAR 0 3
56451: PPUSH
56452: CALL_OW 461
56456: PUSH
56457: LD_INT 2
56459: NONEQUAL
56460: PUSH
56461: LD_VAR 0 3
56465: PPUSH
56466: LD_INT 15
56468: PPUSH
56469: CALL 12038 0 2
56473: PUSH
56474: LD_INT 4
56476: ARRAY
56477: OR
56478: IFFALSE 56482
// continue ;
56480: GO 56444
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
56482: LD_VAR 0 3
56486: PPUSH
56487: LD_EXP 35
56491: PUSH
56492: LD_VAR 0 2
56496: ARRAY
56497: PUSH
56498: LD_INT 1
56500: ARRAY
56501: PUSH
56502: LD_INT 1
56504: ARRAY
56505: PPUSH
56506: LD_EXP 35
56510: PUSH
56511: LD_VAR 0 2
56515: ARRAY
56516: PUSH
56517: LD_INT 1
56519: ARRAY
56520: PUSH
56521: LD_INT 2
56523: ARRAY
56524: PPUSH
56525: LD_EXP 35
56529: PUSH
56530: LD_VAR 0 2
56534: ARRAY
56535: PUSH
56536: LD_INT 1
56538: ARRAY
56539: PUSH
56540: LD_INT 3
56542: ARRAY
56543: PPUSH
56544: LD_EXP 35
56548: PUSH
56549: LD_VAR 0 2
56553: ARRAY
56554: PUSH
56555: LD_INT 1
56557: ARRAY
56558: PUSH
56559: LD_INT 4
56561: ARRAY
56562: PPUSH
56563: CALL_OW 448
56567: PUSH
56568: LD_VAR 0 3
56572: PPUSH
56573: LD_EXP 35
56577: PUSH
56578: LD_VAR 0 2
56582: ARRAY
56583: PUSH
56584: LD_INT 1
56586: ARRAY
56587: PUSH
56588: LD_INT 1
56590: ARRAY
56591: PUSH
56592: LD_EXP 35
56596: PUSH
56597: LD_VAR 0 2
56601: ARRAY
56602: PUSH
56603: LD_INT 1
56605: ARRAY
56606: PUSH
56607: LD_INT 2
56609: ARRAY
56610: PUSH
56611: LD_EXP 35
56615: PUSH
56616: LD_VAR 0 2
56620: ARRAY
56621: PUSH
56622: LD_INT 1
56624: ARRAY
56625: PUSH
56626: LD_INT 3
56628: ARRAY
56629: PUSH
56630: LD_EXP 35
56634: PUSH
56635: LD_VAR 0 2
56639: ARRAY
56640: PUSH
56641: LD_INT 1
56643: ARRAY
56644: PUSH
56645: LD_INT 4
56647: ARRAY
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: LIST
56653: LIST
56654: PPUSH
56655: CALL 15709 0 2
56659: AND
56660: IFFALSE 56798
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
56662: LD_VAR 0 3
56666: PPUSH
56667: LD_EXP 35
56671: PUSH
56672: LD_VAR 0 2
56676: ARRAY
56677: PUSH
56678: LD_INT 1
56680: ARRAY
56681: PUSH
56682: LD_INT 1
56684: ARRAY
56685: PPUSH
56686: LD_EXP 35
56690: PUSH
56691: LD_VAR 0 2
56695: ARRAY
56696: PUSH
56697: LD_INT 1
56699: ARRAY
56700: PUSH
56701: LD_INT 2
56703: ARRAY
56704: PPUSH
56705: LD_EXP 35
56709: PUSH
56710: LD_VAR 0 2
56714: ARRAY
56715: PUSH
56716: LD_INT 1
56718: ARRAY
56719: PUSH
56720: LD_INT 3
56722: ARRAY
56723: PPUSH
56724: LD_EXP 35
56728: PUSH
56729: LD_VAR 0 2
56733: ARRAY
56734: PUSH
56735: LD_INT 1
56737: ARRAY
56738: PUSH
56739: LD_INT 4
56741: ARRAY
56742: PPUSH
56743: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
56747: LD_ADDR_VAR 0 4
56751: PUSH
56752: LD_EXP 35
56756: PUSH
56757: LD_VAR 0 2
56761: ARRAY
56762: PPUSH
56763: LD_INT 1
56765: PPUSH
56766: CALL_OW 3
56770: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
56771: LD_ADDR_EXP 35
56775: PUSH
56776: LD_EXP 35
56780: PPUSH
56781: LD_VAR 0 2
56785: PPUSH
56786: LD_VAR 0 4
56790: PPUSH
56791: CALL_OW 1
56795: ST_TO_ADDR
// break ;
56796: GO 56800
// end ; end ;
56798: GO 56444
56800: POP
56801: POP
// end ;
56802: GO 56376
56804: POP
56805: POP
// end ;
56806: LD_VAR 0 1
56810: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
56811: LD_INT 0
56813: PPUSH
56814: PPUSH
56815: PPUSH
// if not mc_bases then
56816: LD_EXP 14
56820: NOT
56821: IFFALSE 56825
// exit ;
56823: GO 56914
// for i = 1 to mc_bases do
56825: LD_ADDR_VAR 0 2
56829: PUSH
56830: DOUBLE
56831: LD_INT 1
56833: DEC
56834: ST_TO_ADDR
56835: LD_EXP 14
56839: PUSH
56840: FOR_TO
56841: IFFALSE 56912
// begin if mc_attack [ i ] then
56843: LD_EXP 34
56847: PUSH
56848: LD_VAR 0 2
56852: ARRAY
56853: IFFALSE 56910
// begin tmp := mc_attack [ i ] [ 1 ] ;
56855: LD_ADDR_VAR 0 3
56859: PUSH
56860: LD_EXP 34
56864: PUSH
56865: LD_VAR 0 2
56869: ARRAY
56870: PUSH
56871: LD_INT 1
56873: ARRAY
56874: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56875: LD_ADDR_EXP 34
56879: PUSH
56880: LD_EXP 34
56884: PPUSH
56885: LD_VAR 0 2
56889: PPUSH
56890: EMPTY
56891: PPUSH
56892: CALL_OW 1
56896: ST_TO_ADDR
// Attack ( tmp ) ;
56897: LD_VAR 0 3
56901: PPUSH
56902: CALL 71478 0 1
// exit ;
56906: POP
56907: POP
56908: GO 56914
// end ; end ;
56910: GO 56840
56912: POP
56913: POP
// end ;
56914: LD_VAR 0 1
56918: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
56919: LD_INT 0
56921: PPUSH
56922: PPUSH
56923: PPUSH
56924: PPUSH
56925: PPUSH
56926: PPUSH
56927: PPUSH
// if not mc_bases then
56928: LD_EXP 14
56932: NOT
56933: IFFALSE 56937
// exit ;
56935: GO 57519
// for i = 1 to mc_bases do
56937: LD_ADDR_VAR 0 2
56941: PUSH
56942: DOUBLE
56943: LD_INT 1
56945: DEC
56946: ST_TO_ADDR
56947: LD_EXP 14
56951: PUSH
56952: FOR_TO
56953: IFFALSE 57517
// begin if not mc_bases [ i ] then
56955: LD_EXP 14
56959: PUSH
56960: LD_VAR 0 2
56964: ARRAY
56965: NOT
56966: IFFALSE 56970
// continue ;
56968: GO 56952
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
56970: LD_ADDR_VAR 0 7
56974: PUSH
56975: LD_EXP 14
56979: PUSH
56980: LD_VAR 0 2
56984: ARRAY
56985: PUSH
56986: LD_INT 1
56988: ARRAY
56989: PPUSH
56990: CALL 6281 0 1
56994: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
56995: LD_ADDR_EXP 37
56999: PUSH
57000: LD_EXP 37
57004: PPUSH
57005: LD_VAR 0 2
57009: PPUSH
57010: LD_EXP 14
57014: PUSH
57015: LD_VAR 0 2
57019: ARRAY
57020: PUSH
57021: LD_INT 1
57023: ARRAY
57024: PPUSH
57025: CALL_OW 255
57029: PPUSH
57030: LD_EXP 39
57034: PUSH
57035: LD_VAR 0 2
57039: ARRAY
57040: PPUSH
57041: CALL 6246 0 2
57045: PPUSH
57046: CALL_OW 1
57050: ST_TO_ADDR
// if not mc_scan [ i ] then
57051: LD_EXP 37
57055: PUSH
57056: LD_VAR 0 2
57060: ARRAY
57061: NOT
57062: IFFALSE 57217
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57064: LD_ADDR_VAR 0 4
57068: PUSH
57069: LD_EXP 14
57073: PUSH
57074: LD_VAR 0 2
57078: ARRAY
57079: PPUSH
57080: LD_INT 2
57082: PUSH
57083: LD_INT 25
57085: PUSH
57086: LD_INT 5
57088: PUSH
57089: EMPTY
57090: LIST
57091: LIST
57092: PUSH
57093: LD_INT 25
57095: PUSH
57096: LD_INT 8
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: PUSH
57103: LD_INT 25
57105: PUSH
57106: LD_INT 9
57108: PUSH
57109: EMPTY
57110: LIST
57111: LIST
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: LIST
57117: LIST
57118: PPUSH
57119: CALL_OW 72
57123: ST_TO_ADDR
// if not tmp then
57124: LD_VAR 0 4
57128: NOT
57129: IFFALSE 57133
// continue ;
57131: GO 56952
// for j in tmp do
57133: LD_ADDR_VAR 0 3
57137: PUSH
57138: LD_VAR 0 4
57142: PUSH
57143: FOR_IN
57144: IFFALSE 57215
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
57146: LD_VAR 0 3
57150: PPUSH
57151: CALL_OW 310
57155: PPUSH
57156: CALL_OW 266
57160: PUSH
57161: LD_INT 5
57163: EQUAL
57164: PUSH
57165: LD_VAR 0 3
57169: PPUSH
57170: CALL_OW 257
57174: PUSH
57175: LD_INT 1
57177: EQUAL
57178: AND
57179: PUSH
57180: LD_VAR 0 3
57184: PPUSH
57185: CALL_OW 459
57189: NOT
57190: AND
57191: PUSH
57192: LD_VAR 0 7
57196: AND
57197: IFFALSE 57213
// ComChangeProfession ( j , class ) ;
57199: LD_VAR 0 3
57203: PPUSH
57204: LD_VAR 0 7
57208: PPUSH
57209: CALL_OW 123
57213: GO 57143
57215: POP
57216: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
57217: LD_EXP 37
57221: PUSH
57222: LD_VAR 0 2
57226: ARRAY
57227: PUSH
57228: LD_EXP 36
57232: PUSH
57233: LD_VAR 0 2
57237: ARRAY
57238: NOT
57239: AND
57240: PUSH
57241: LD_EXP 14
57245: PUSH
57246: LD_VAR 0 2
57250: ARRAY
57251: PPUSH
57252: LD_INT 30
57254: PUSH
57255: LD_INT 32
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: PPUSH
57262: CALL_OW 72
57266: NOT
57267: AND
57268: PUSH
57269: LD_EXP 14
57273: PUSH
57274: LD_VAR 0 2
57278: ARRAY
57279: PPUSH
57280: LD_INT 2
57282: PUSH
57283: LD_INT 30
57285: PUSH
57286: LD_INT 4
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PUSH
57293: LD_INT 30
57295: PUSH
57296: LD_INT 5
57298: PUSH
57299: EMPTY
57300: LIST
57301: LIST
57302: PUSH
57303: EMPTY
57304: LIST
57305: LIST
57306: LIST
57307: PPUSH
57308: CALL_OW 72
57312: NOT
57313: AND
57314: IFFALSE 57446
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57316: LD_ADDR_VAR 0 4
57320: PUSH
57321: LD_EXP 14
57325: PUSH
57326: LD_VAR 0 2
57330: ARRAY
57331: PPUSH
57332: LD_INT 2
57334: PUSH
57335: LD_INT 25
57337: PUSH
57338: LD_INT 1
57340: PUSH
57341: EMPTY
57342: LIST
57343: LIST
57344: PUSH
57345: LD_INT 25
57347: PUSH
57348: LD_INT 5
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: PUSH
57355: LD_INT 25
57357: PUSH
57358: LD_INT 8
57360: PUSH
57361: EMPTY
57362: LIST
57363: LIST
57364: PUSH
57365: LD_INT 25
57367: PUSH
57368: LD_INT 9
57370: PUSH
57371: EMPTY
57372: LIST
57373: LIST
57374: PUSH
57375: EMPTY
57376: LIST
57377: LIST
57378: LIST
57379: LIST
57380: LIST
57381: PPUSH
57382: CALL_OW 72
57386: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
57387: LD_ADDR_VAR 0 4
57391: PUSH
57392: LD_VAR 0 4
57396: PUSH
57397: LD_VAR 0 4
57401: PPUSH
57402: LD_INT 18
57404: PPUSH
57405: CALL 38006 0 2
57409: DIFF
57410: ST_TO_ADDR
// if tmp then
57411: LD_VAR 0 4
57415: IFFALSE 57446
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
57417: LD_VAR 0 2
57421: PPUSH
57422: LD_VAR 0 4
57426: PPUSH
57427: LD_EXP 39
57431: PUSH
57432: LD_VAR 0 2
57436: ARRAY
57437: PPUSH
57438: CALL 76187 0 3
// exit ;
57442: POP
57443: POP
57444: GO 57519
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
57446: LD_EXP 37
57450: PUSH
57451: LD_VAR 0 2
57455: ARRAY
57456: PUSH
57457: LD_EXP 36
57461: PUSH
57462: LD_VAR 0 2
57466: ARRAY
57467: AND
57468: IFFALSE 57515
// begin tmp := mc_defender [ i ] ;
57470: LD_ADDR_VAR 0 4
57474: PUSH
57475: LD_EXP 36
57479: PUSH
57480: LD_VAR 0 2
57484: ARRAY
57485: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
57486: LD_VAR 0 2
57490: PPUSH
57491: LD_VAR 0 4
57495: PPUSH
57496: LD_EXP 37
57500: PUSH
57501: LD_VAR 0 2
57505: ARRAY
57506: PPUSH
57507: CALL 76748 0 3
// exit ;
57511: POP
57512: POP
57513: GO 57519
// end ; end ;
57515: GO 56952
57517: POP
57518: POP
// end ;
57519: LD_VAR 0 1
57523: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
57524: LD_INT 0
57526: PPUSH
57527: PPUSH
57528: PPUSH
57529: PPUSH
57530: PPUSH
57531: PPUSH
57532: PPUSH
57533: PPUSH
57534: PPUSH
57535: PPUSH
57536: PPUSH
// if not mc_bases then
57537: LD_EXP 14
57541: NOT
57542: IFFALSE 57546
// exit ;
57544: GO 58633
// for i = 1 to mc_bases do
57546: LD_ADDR_VAR 0 2
57550: PUSH
57551: DOUBLE
57552: LD_INT 1
57554: DEC
57555: ST_TO_ADDR
57556: LD_EXP 14
57560: PUSH
57561: FOR_TO
57562: IFFALSE 58631
// begin tmp := mc_lab [ i ] ;
57564: LD_ADDR_VAR 0 6
57568: PUSH
57569: LD_EXP 47
57573: PUSH
57574: LD_VAR 0 2
57578: ARRAY
57579: ST_TO_ADDR
// if not tmp then
57580: LD_VAR 0 6
57584: NOT
57585: IFFALSE 57589
// continue ;
57587: GO 57561
// idle_lab := 0 ;
57589: LD_ADDR_VAR 0 11
57593: PUSH
57594: LD_INT 0
57596: ST_TO_ADDR
// for j in tmp do
57597: LD_ADDR_VAR 0 3
57601: PUSH
57602: LD_VAR 0 6
57606: PUSH
57607: FOR_IN
57608: IFFALSE 58627
// begin researching := false ;
57610: LD_ADDR_VAR 0 10
57614: PUSH
57615: LD_INT 0
57617: ST_TO_ADDR
// side := GetSide ( j ) ;
57618: LD_ADDR_VAR 0 4
57622: PUSH
57623: LD_VAR 0 3
57627: PPUSH
57628: CALL_OW 255
57632: ST_TO_ADDR
// if not mc_tech [ side ] then
57633: LD_EXP 41
57637: PUSH
57638: LD_VAR 0 4
57642: ARRAY
57643: NOT
57644: IFFALSE 57648
// continue ;
57646: GO 57607
// if BuildingStatus ( j ) = bs_idle then
57648: LD_VAR 0 3
57652: PPUSH
57653: CALL_OW 461
57657: PUSH
57658: LD_INT 2
57660: EQUAL
57661: IFFALSE 57849
// begin if idle_lab and UnitsInside ( j ) < 6 then
57663: LD_VAR 0 11
57667: PUSH
57668: LD_VAR 0 3
57672: PPUSH
57673: CALL_OW 313
57677: PUSH
57678: LD_INT 6
57680: LESS
57681: AND
57682: IFFALSE 57753
// begin tmp2 := UnitsInside ( idle_lab ) ;
57684: LD_ADDR_VAR 0 9
57688: PUSH
57689: LD_VAR 0 11
57693: PPUSH
57694: CALL_OW 313
57698: ST_TO_ADDR
// if tmp2 then
57699: LD_VAR 0 9
57703: IFFALSE 57745
// for x in tmp2 do
57705: LD_ADDR_VAR 0 7
57709: PUSH
57710: LD_VAR 0 9
57714: PUSH
57715: FOR_IN
57716: IFFALSE 57743
// begin ComExitBuilding ( x ) ;
57718: LD_VAR 0 7
57722: PPUSH
57723: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57727: LD_VAR 0 7
57731: PPUSH
57732: LD_VAR 0 3
57736: PPUSH
57737: CALL_OW 180
// end ;
57741: GO 57715
57743: POP
57744: POP
// idle_lab := 0 ;
57745: LD_ADDR_VAR 0 11
57749: PUSH
57750: LD_INT 0
57752: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
57753: LD_ADDR_VAR 0 5
57757: PUSH
57758: LD_EXP 41
57762: PUSH
57763: LD_VAR 0 4
57767: ARRAY
57768: PUSH
57769: FOR_IN
57770: IFFALSE 57830
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
57772: LD_VAR 0 3
57776: PPUSH
57777: LD_VAR 0 5
57781: PPUSH
57782: CALL_OW 430
57786: PUSH
57787: LD_VAR 0 4
57791: PPUSH
57792: LD_VAR 0 5
57796: PPUSH
57797: CALL 5351 0 2
57801: AND
57802: IFFALSE 57828
// begin researching := true ;
57804: LD_ADDR_VAR 0 10
57808: PUSH
57809: LD_INT 1
57811: ST_TO_ADDR
// ComResearch ( j , t ) ;
57812: LD_VAR 0 3
57816: PPUSH
57817: LD_VAR 0 5
57821: PPUSH
57822: CALL_OW 124
// break ;
57826: GO 57830
// end ;
57828: GO 57769
57830: POP
57831: POP
// if not researching then
57832: LD_VAR 0 10
57836: NOT
57837: IFFALSE 57849
// idle_lab := j ;
57839: LD_ADDR_VAR 0 11
57843: PUSH
57844: LD_VAR 0 3
57848: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
57849: LD_VAR 0 3
57853: PPUSH
57854: CALL_OW 461
57858: PUSH
57859: LD_INT 10
57861: EQUAL
57862: IFFALSE 58450
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
57864: LD_EXP 43
57868: PUSH
57869: LD_VAR 0 2
57873: ARRAY
57874: NOT
57875: PUSH
57876: LD_EXP 44
57880: PUSH
57881: LD_VAR 0 2
57885: ARRAY
57886: NOT
57887: AND
57888: PUSH
57889: LD_EXP 41
57893: PUSH
57894: LD_VAR 0 4
57898: ARRAY
57899: PUSH
57900: LD_INT 1
57902: GREATER
57903: AND
57904: IFFALSE 58035
// begin ComCancel ( j ) ;
57906: LD_VAR 0 3
57910: PPUSH
57911: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
57915: LD_ADDR_EXP 41
57919: PUSH
57920: LD_EXP 41
57924: PPUSH
57925: LD_VAR 0 4
57929: PPUSH
57930: LD_EXP 41
57934: PUSH
57935: LD_VAR 0 4
57939: ARRAY
57940: PPUSH
57941: LD_EXP 41
57945: PUSH
57946: LD_VAR 0 4
57950: ARRAY
57951: PUSH
57952: LD_INT 1
57954: MINUS
57955: PPUSH
57956: LD_EXP 41
57960: PUSH
57961: LD_VAR 0 4
57965: ARRAY
57966: PPUSH
57967: LD_INT 0
57969: PPUSH
57970: CALL 8863 0 4
57974: PPUSH
57975: CALL_OW 1
57979: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
57980: LD_ADDR_EXP 41
57984: PUSH
57985: LD_EXP 41
57989: PPUSH
57990: LD_VAR 0 4
57994: PPUSH
57995: LD_EXP 41
57999: PUSH
58000: LD_VAR 0 4
58004: ARRAY
58005: PPUSH
58006: LD_EXP 41
58010: PUSH
58011: LD_VAR 0 4
58015: ARRAY
58016: PPUSH
58017: LD_INT 1
58019: PPUSH
58020: LD_INT 0
58022: PPUSH
58023: CALL 8863 0 4
58027: PPUSH
58028: CALL_OW 1
58032: ST_TO_ADDR
// continue ;
58033: GO 57607
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
58035: LD_EXP 43
58039: PUSH
58040: LD_VAR 0 2
58044: ARRAY
58045: PUSH
58046: LD_EXP 44
58050: PUSH
58051: LD_VAR 0 2
58055: ARRAY
58056: NOT
58057: AND
58058: IFFALSE 58185
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
58060: LD_ADDR_EXP 44
58064: PUSH
58065: LD_EXP 44
58069: PPUSH
58070: LD_VAR 0 2
58074: PUSH
58075: LD_EXP 44
58079: PUSH
58080: LD_VAR 0 2
58084: ARRAY
58085: PUSH
58086: LD_INT 1
58088: PLUS
58089: PUSH
58090: EMPTY
58091: LIST
58092: LIST
58093: PPUSH
58094: LD_EXP 43
58098: PUSH
58099: LD_VAR 0 2
58103: ARRAY
58104: PUSH
58105: LD_INT 1
58107: ARRAY
58108: PPUSH
58109: CALL 9445 0 3
58113: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
58114: LD_EXP 43
58118: PUSH
58119: LD_VAR 0 2
58123: ARRAY
58124: PUSH
58125: LD_INT 1
58127: ARRAY
58128: PPUSH
58129: LD_INT 112
58131: PPUSH
58132: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
58136: LD_ADDR_VAR 0 9
58140: PUSH
58141: LD_EXP 43
58145: PUSH
58146: LD_VAR 0 2
58150: ARRAY
58151: PPUSH
58152: LD_INT 1
58154: PPUSH
58155: CALL_OW 3
58159: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
58160: LD_ADDR_EXP 43
58164: PUSH
58165: LD_EXP 43
58169: PPUSH
58170: LD_VAR 0 2
58174: PPUSH
58175: LD_VAR 0 9
58179: PPUSH
58180: CALL_OW 1
58184: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
58185: LD_EXP 43
58189: PUSH
58190: LD_VAR 0 2
58194: ARRAY
58195: PUSH
58196: LD_EXP 44
58200: PUSH
58201: LD_VAR 0 2
58205: ARRAY
58206: AND
58207: PUSH
58208: LD_EXP 44
58212: PUSH
58213: LD_VAR 0 2
58217: ARRAY
58218: PUSH
58219: LD_INT 1
58221: ARRAY
58222: PPUSH
58223: CALL_OW 310
58227: NOT
58228: AND
58229: PUSH
58230: LD_VAR 0 3
58234: PPUSH
58235: CALL_OW 313
58239: PUSH
58240: LD_INT 6
58242: EQUAL
58243: AND
58244: IFFALSE 58300
// begin tmp2 := UnitsInside ( j ) ;
58246: LD_ADDR_VAR 0 9
58250: PUSH
58251: LD_VAR 0 3
58255: PPUSH
58256: CALL_OW 313
58260: ST_TO_ADDR
// if tmp2 = 6 then
58261: LD_VAR 0 9
58265: PUSH
58266: LD_INT 6
58268: EQUAL
58269: IFFALSE 58300
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
58271: LD_VAR 0 9
58275: PUSH
58276: LD_INT 1
58278: ARRAY
58279: PPUSH
58280: LD_INT 112
58282: PPUSH
58283: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
58287: LD_VAR 0 9
58291: PUSH
58292: LD_INT 1
58294: ARRAY
58295: PPUSH
58296: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
58300: LD_EXP 44
58304: PUSH
58305: LD_VAR 0 2
58309: ARRAY
58310: PUSH
58311: LD_EXP 44
58315: PUSH
58316: LD_VAR 0 2
58320: ARRAY
58321: PUSH
58322: LD_INT 1
58324: ARRAY
58325: PPUSH
58326: CALL_OW 314
58330: NOT
58331: AND
58332: PUSH
58333: LD_EXP 44
58337: PUSH
58338: LD_VAR 0 2
58342: ARRAY
58343: PUSH
58344: LD_INT 1
58346: ARRAY
58347: PPUSH
58348: CALL_OW 310
58352: NOT
58353: AND
58354: IFFALSE 58380
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
58356: LD_EXP 44
58360: PUSH
58361: LD_VAR 0 2
58365: ARRAY
58366: PUSH
58367: LD_INT 1
58369: ARRAY
58370: PPUSH
58371: LD_VAR 0 3
58375: PPUSH
58376: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
58380: LD_EXP 44
58384: PUSH
58385: LD_VAR 0 2
58389: ARRAY
58390: PUSH
58391: LD_INT 1
58393: ARRAY
58394: PPUSH
58395: CALL_OW 310
58399: PUSH
58400: LD_EXP 44
58404: PUSH
58405: LD_VAR 0 2
58409: ARRAY
58410: PUSH
58411: LD_INT 1
58413: ARRAY
58414: PPUSH
58415: CALL_OW 310
58419: PPUSH
58420: CALL_OW 461
58424: PUSH
58425: LD_INT 3
58427: NONEQUAL
58428: AND
58429: IFFALSE 58450
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
58431: LD_EXP 44
58435: PUSH
58436: LD_VAR 0 2
58440: ARRAY
58441: PUSH
58442: LD_INT 1
58444: ARRAY
58445: PPUSH
58446: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
58450: LD_VAR 0 3
58454: PPUSH
58455: CALL_OW 461
58459: PUSH
58460: LD_INT 6
58462: EQUAL
58463: PUSH
58464: LD_VAR 0 6
58468: PUSH
58469: LD_INT 1
58471: GREATER
58472: AND
58473: IFFALSE 58625
// begin sci := [ ] ;
58475: LD_ADDR_VAR 0 8
58479: PUSH
58480: EMPTY
58481: ST_TO_ADDR
// for x in ( tmp diff j ) do
58482: LD_ADDR_VAR 0 7
58486: PUSH
58487: LD_VAR 0 6
58491: PUSH
58492: LD_VAR 0 3
58496: DIFF
58497: PUSH
58498: FOR_IN
58499: IFFALSE 58551
// begin if sci = 6 then
58501: LD_VAR 0 8
58505: PUSH
58506: LD_INT 6
58508: EQUAL
58509: IFFALSE 58513
// break ;
58511: GO 58551
// if BuildingStatus ( x ) = bs_idle then
58513: LD_VAR 0 7
58517: PPUSH
58518: CALL_OW 461
58522: PUSH
58523: LD_INT 2
58525: EQUAL
58526: IFFALSE 58549
// sci := sci ^ UnitsInside ( x ) ;
58528: LD_ADDR_VAR 0 8
58532: PUSH
58533: LD_VAR 0 8
58537: PUSH
58538: LD_VAR 0 7
58542: PPUSH
58543: CALL_OW 313
58547: ADD
58548: ST_TO_ADDR
// end ;
58549: GO 58498
58551: POP
58552: POP
// if not sci then
58553: LD_VAR 0 8
58557: NOT
58558: IFFALSE 58562
// continue ;
58560: GO 57607
// for x in sci do
58562: LD_ADDR_VAR 0 7
58566: PUSH
58567: LD_VAR 0 8
58571: PUSH
58572: FOR_IN
58573: IFFALSE 58623
// if IsInUnit ( x ) and not HasTask ( x ) then
58575: LD_VAR 0 7
58579: PPUSH
58580: CALL_OW 310
58584: PUSH
58585: LD_VAR 0 7
58589: PPUSH
58590: CALL_OW 314
58594: NOT
58595: AND
58596: IFFALSE 58621
// begin ComExitBuilding ( x ) ;
58598: LD_VAR 0 7
58602: PPUSH
58603: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
58607: LD_VAR 0 7
58611: PPUSH
58612: LD_VAR 0 3
58616: PPUSH
58617: CALL_OW 180
// end ;
58621: GO 58572
58623: POP
58624: POP
// end ; end ;
58625: GO 57607
58627: POP
58628: POP
// end ;
58629: GO 57561
58631: POP
58632: POP
// end ;
58633: LD_VAR 0 1
58637: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
58638: LD_INT 0
58640: PPUSH
58641: PPUSH
// if not mc_bases then
58642: LD_EXP 14
58646: NOT
58647: IFFALSE 58651
// exit ;
58649: GO 58732
// for i = 1 to mc_bases do
58651: LD_ADDR_VAR 0 2
58655: PUSH
58656: DOUBLE
58657: LD_INT 1
58659: DEC
58660: ST_TO_ADDR
58661: LD_EXP 14
58665: PUSH
58666: FOR_TO
58667: IFFALSE 58730
// if mc_mines [ i ] and mc_miners [ i ] then
58669: LD_EXP 27
58673: PUSH
58674: LD_VAR 0 2
58678: ARRAY
58679: PUSH
58680: LD_EXP 28
58684: PUSH
58685: LD_VAR 0 2
58689: ARRAY
58690: AND
58691: IFFALSE 58728
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
58693: LD_EXP 28
58697: PUSH
58698: LD_VAR 0 2
58702: ARRAY
58703: PUSH
58704: LD_INT 1
58706: ARRAY
58707: PPUSH
58708: CALL_OW 255
58712: PPUSH
58713: LD_EXP 27
58717: PUSH
58718: LD_VAR 0 2
58722: ARRAY
58723: PPUSH
58724: CALL 6434 0 2
58728: GO 58666
58730: POP
58731: POP
// end ;
58732: LD_VAR 0 1
58736: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
58737: LD_INT 0
58739: PPUSH
58740: PPUSH
58741: PPUSH
58742: PPUSH
58743: PPUSH
58744: PPUSH
58745: PPUSH
58746: PPUSH
// if not mc_bases or not mc_parking then
58747: LD_EXP 14
58751: NOT
58752: PUSH
58753: LD_EXP 38
58757: NOT
58758: OR
58759: IFFALSE 58763
// exit ;
58761: GO 59462
// for i = 1 to mc_bases do
58763: LD_ADDR_VAR 0 2
58767: PUSH
58768: DOUBLE
58769: LD_INT 1
58771: DEC
58772: ST_TO_ADDR
58773: LD_EXP 14
58777: PUSH
58778: FOR_TO
58779: IFFALSE 59460
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
58781: LD_EXP 14
58785: PUSH
58786: LD_VAR 0 2
58790: ARRAY
58791: NOT
58792: PUSH
58793: LD_EXP 38
58797: PUSH
58798: LD_VAR 0 2
58802: ARRAY
58803: NOT
58804: OR
58805: IFFALSE 58809
// continue ;
58807: GO 58778
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
58809: LD_ADDR_VAR 0 5
58813: PUSH
58814: LD_EXP 14
58818: PUSH
58819: LD_VAR 0 2
58823: ARRAY
58824: PUSH
58825: LD_INT 1
58827: ARRAY
58828: PPUSH
58829: CALL_OW 255
58833: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58834: LD_ADDR_VAR 0 6
58838: PUSH
58839: LD_EXP 14
58843: PUSH
58844: LD_VAR 0 2
58848: ARRAY
58849: PPUSH
58850: LD_INT 30
58852: PUSH
58853: LD_INT 3
58855: PUSH
58856: EMPTY
58857: LIST
58858: LIST
58859: PPUSH
58860: CALL_OW 72
58864: ST_TO_ADDR
// if not fac then
58865: LD_VAR 0 6
58869: NOT
58870: IFFALSE 58921
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58872: LD_ADDR_VAR 0 6
58876: PUSH
58877: LD_EXP 14
58881: PUSH
58882: LD_VAR 0 2
58886: ARRAY
58887: PPUSH
58888: LD_INT 2
58890: PUSH
58891: LD_INT 30
58893: PUSH
58894: LD_INT 0
58896: PUSH
58897: EMPTY
58898: LIST
58899: LIST
58900: PUSH
58901: LD_INT 30
58903: PUSH
58904: LD_INT 1
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: LIST
58915: PPUSH
58916: CALL_OW 72
58920: ST_TO_ADDR
// if not fac then
58921: LD_VAR 0 6
58925: NOT
58926: IFFALSE 58930
// continue ;
58928: GO 58778
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58930: LD_ADDR_VAR 0 7
58934: PUSH
58935: LD_EXP 38
58939: PUSH
58940: LD_VAR 0 2
58944: ARRAY
58945: PPUSH
58946: LD_INT 22
58948: PUSH
58949: LD_VAR 0 5
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: PUSH
58958: LD_INT 21
58960: PUSH
58961: LD_INT 2
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: PUSH
58968: LD_INT 3
58970: PUSH
58971: LD_INT 24
58973: PUSH
58974: LD_INT 1000
58976: PUSH
58977: EMPTY
58978: LIST
58979: LIST
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: PUSH
58985: EMPTY
58986: LIST
58987: LIST
58988: LIST
58989: PPUSH
58990: CALL_OW 70
58994: ST_TO_ADDR
// for j in fac do
58995: LD_ADDR_VAR 0 3
58999: PUSH
59000: LD_VAR 0 6
59004: PUSH
59005: FOR_IN
59006: IFFALSE 59087
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59008: LD_ADDR_VAR 0 7
59012: PUSH
59013: LD_VAR 0 7
59017: PUSH
59018: LD_INT 22
59020: PUSH
59021: LD_VAR 0 5
59025: PUSH
59026: EMPTY
59027: LIST
59028: LIST
59029: PUSH
59030: LD_INT 91
59032: PUSH
59033: LD_VAR 0 3
59037: PUSH
59038: LD_INT 15
59040: PUSH
59041: EMPTY
59042: LIST
59043: LIST
59044: LIST
59045: PUSH
59046: LD_INT 21
59048: PUSH
59049: LD_INT 2
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: PUSH
59056: LD_INT 3
59058: PUSH
59059: LD_INT 24
59061: PUSH
59062: LD_INT 1000
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: PUSH
59069: EMPTY
59070: LIST
59071: LIST
59072: PUSH
59073: EMPTY
59074: LIST
59075: LIST
59076: LIST
59077: LIST
59078: PPUSH
59079: CALL_OW 69
59083: UNION
59084: ST_TO_ADDR
59085: GO 59005
59087: POP
59088: POP
// if not vehs then
59089: LD_VAR 0 7
59093: NOT
59094: IFFALSE 59120
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59096: LD_ADDR_EXP 26
59100: PUSH
59101: LD_EXP 26
59105: PPUSH
59106: LD_VAR 0 2
59110: PPUSH
59111: EMPTY
59112: PPUSH
59113: CALL_OW 1
59117: ST_TO_ADDR
// continue ;
59118: GO 58778
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59120: LD_ADDR_VAR 0 8
59124: PUSH
59125: LD_EXP 14
59129: PUSH
59130: LD_VAR 0 2
59134: ARRAY
59135: PPUSH
59136: LD_INT 30
59138: PUSH
59139: LD_INT 3
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: PPUSH
59146: CALL_OW 72
59150: ST_TO_ADDR
// if tmp then
59151: LD_VAR 0 8
59155: IFFALSE 59258
// begin for j in tmp do
59157: LD_ADDR_VAR 0 3
59161: PUSH
59162: LD_VAR 0 8
59166: PUSH
59167: FOR_IN
59168: IFFALSE 59256
// for k in UnitsInside ( j ) do
59170: LD_ADDR_VAR 0 4
59174: PUSH
59175: LD_VAR 0 3
59179: PPUSH
59180: CALL_OW 313
59184: PUSH
59185: FOR_IN
59186: IFFALSE 59252
// if k then
59188: LD_VAR 0 4
59192: IFFALSE 59250
// if not k in mc_repair_vehicle [ i ] then
59194: LD_VAR 0 4
59198: PUSH
59199: LD_EXP 26
59203: PUSH
59204: LD_VAR 0 2
59208: ARRAY
59209: IN
59210: NOT
59211: IFFALSE 59250
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
59213: LD_ADDR_EXP 26
59217: PUSH
59218: LD_EXP 26
59222: PPUSH
59223: LD_VAR 0 2
59227: PPUSH
59228: LD_EXP 26
59232: PUSH
59233: LD_VAR 0 2
59237: ARRAY
59238: PUSH
59239: LD_VAR 0 4
59243: UNION
59244: PPUSH
59245: CALL_OW 1
59249: ST_TO_ADDR
59250: GO 59185
59252: POP
59253: POP
59254: GO 59167
59256: POP
59257: POP
// end ; if not mc_repair_vehicle [ i ] then
59258: LD_EXP 26
59262: PUSH
59263: LD_VAR 0 2
59267: ARRAY
59268: NOT
59269: IFFALSE 59273
// continue ;
59271: GO 58778
// for j in mc_repair_vehicle [ i ] do
59273: LD_ADDR_VAR 0 3
59277: PUSH
59278: LD_EXP 26
59282: PUSH
59283: LD_VAR 0 2
59287: ARRAY
59288: PUSH
59289: FOR_IN
59290: IFFALSE 59456
// begin if GetClass ( j ) <> 3 then
59292: LD_VAR 0 3
59296: PPUSH
59297: CALL_OW 257
59301: PUSH
59302: LD_INT 3
59304: NONEQUAL
59305: IFFALSE 59346
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
59307: LD_ADDR_EXP 26
59311: PUSH
59312: LD_EXP 26
59316: PPUSH
59317: LD_VAR 0 2
59321: PPUSH
59322: LD_EXP 26
59326: PUSH
59327: LD_VAR 0 2
59331: ARRAY
59332: PUSH
59333: LD_VAR 0 3
59337: DIFF
59338: PPUSH
59339: CALL_OW 1
59343: ST_TO_ADDR
// continue ;
59344: GO 59289
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59346: LD_VAR 0 3
59350: PPUSH
59351: CALL_OW 311
59355: NOT
59356: PUSH
59357: LD_VAR 0 3
59361: PUSH
59362: LD_EXP 17
59366: PUSH
59367: LD_VAR 0 2
59371: ARRAY
59372: PUSH
59373: LD_INT 1
59375: ARRAY
59376: IN
59377: NOT
59378: AND
59379: PUSH
59380: LD_VAR 0 3
59384: PUSH
59385: LD_EXP 17
59389: PUSH
59390: LD_VAR 0 2
59394: ARRAY
59395: PUSH
59396: LD_INT 2
59398: ARRAY
59399: IN
59400: NOT
59401: AND
59402: IFFALSE 59454
// begin if IsInUnit ( j ) then
59404: LD_VAR 0 3
59408: PPUSH
59409: CALL_OW 310
59413: IFFALSE 59424
// ComExitBuilding ( j ) ;
59415: LD_VAR 0 3
59419: PPUSH
59420: CALL_OW 122
// if not HasTask ( j ) then
59424: LD_VAR 0 3
59428: PPUSH
59429: CALL_OW 314
59433: NOT
59434: IFFALSE 59454
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
59436: LD_VAR 0 3
59440: PPUSH
59441: LD_VAR 0 7
59445: PUSH
59446: LD_INT 1
59448: ARRAY
59449: PPUSH
59450: CALL_OW 189
// end ; end ;
59454: GO 59289
59456: POP
59457: POP
// end ;
59458: GO 58778
59460: POP
59461: POP
// end ;
59462: LD_VAR 0 1
59466: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
59467: LD_INT 0
59469: PPUSH
59470: PPUSH
59471: PPUSH
59472: PPUSH
59473: PPUSH
59474: PPUSH
59475: PPUSH
59476: PPUSH
59477: PPUSH
59478: PPUSH
59479: PPUSH
// if not mc_bases then
59480: LD_EXP 14
59484: NOT
59485: IFFALSE 59489
// exit ;
59487: GO 60291
// for i = 1 to mc_bases do
59489: LD_ADDR_VAR 0 2
59493: PUSH
59494: DOUBLE
59495: LD_INT 1
59497: DEC
59498: ST_TO_ADDR
59499: LD_EXP 14
59503: PUSH
59504: FOR_TO
59505: IFFALSE 60289
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
59507: LD_EXP 42
59511: PUSH
59512: LD_VAR 0 2
59516: ARRAY
59517: NOT
59518: PUSH
59519: LD_EXP 17
59523: PUSH
59524: LD_VAR 0 2
59528: ARRAY
59529: PUSH
59530: LD_INT 1
59532: ARRAY
59533: OR
59534: PUSH
59535: LD_EXP 17
59539: PUSH
59540: LD_VAR 0 2
59544: ARRAY
59545: PUSH
59546: LD_INT 2
59548: ARRAY
59549: OR
59550: PUSH
59551: LD_EXP 40
59555: PUSH
59556: LD_VAR 0 2
59560: ARRAY
59561: PPUSH
59562: LD_INT 1
59564: PPUSH
59565: CALL_OW 325
59569: NOT
59570: OR
59571: PUSH
59572: LD_EXP 37
59576: PUSH
59577: LD_VAR 0 2
59581: ARRAY
59582: OR
59583: IFFALSE 59587
// continue ;
59585: GO 59504
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
59587: LD_ADDR_VAR 0 8
59591: PUSH
59592: LD_EXP 14
59596: PUSH
59597: LD_VAR 0 2
59601: ARRAY
59602: PPUSH
59603: LD_INT 25
59605: PUSH
59606: LD_INT 4
59608: PUSH
59609: EMPTY
59610: LIST
59611: LIST
59612: PUSH
59613: LD_INT 50
59615: PUSH
59616: EMPTY
59617: LIST
59618: PUSH
59619: LD_INT 3
59621: PUSH
59622: LD_INT 60
59624: PUSH
59625: EMPTY
59626: LIST
59627: PUSH
59628: EMPTY
59629: LIST
59630: LIST
59631: PUSH
59632: EMPTY
59633: LIST
59634: LIST
59635: LIST
59636: PPUSH
59637: CALL_OW 72
59641: PUSH
59642: LD_EXP 18
59646: PUSH
59647: LD_VAR 0 2
59651: ARRAY
59652: DIFF
59653: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59654: LD_ADDR_VAR 0 9
59658: PUSH
59659: LD_EXP 14
59663: PUSH
59664: LD_VAR 0 2
59668: ARRAY
59669: PPUSH
59670: LD_INT 2
59672: PUSH
59673: LD_INT 30
59675: PUSH
59676: LD_INT 0
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: PUSH
59683: LD_INT 30
59685: PUSH
59686: LD_INT 1
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: PUSH
59693: EMPTY
59694: LIST
59695: LIST
59696: LIST
59697: PPUSH
59698: CALL_OW 72
59702: ST_TO_ADDR
// if not tmp or not dep then
59703: LD_VAR 0 8
59707: NOT
59708: PUSH
59709: LD_VAR 0 9
59713: NOT
59714: OR
59715: IFFALSE 59719
// continue ;
59717: GO 59504
// side := GetSide ( tmp [ 1 ] ) ;
59719: LD_ADDR_VAR 0 11
59723: PUSH
59724: LD_VAR 0 8
59728: PUSH
59729: LD_INT 1
59731: ARRAY
59732: PPUSH
59733: CALL_OW 255
59737: ST_TO_ADDR
// dep := dep [ 1 ] ;
59738: LD_ADDR_VAR 0 9
59742: PUSH
59743: LD_VAR 0 9
59747: PUSH
59748: LD_INT 1
59750: ARRAY
59751: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
59752: LD_ADDR_VAR 0 7
59756: PUSH
59757: LD_EXP 42
59761: PUSH
59762: LD_VAR 0 2
59766: ARRAY
59767: PPUSH
59768: LD_INT 22
59770: PUSH
59771: LD_INT 0
59773: PUSH
59774: EMPTY
59775: LIST
59776: LIST
59777: PUSH
59778: LD_INT 25
59780: PUSH
59781: LD_INT 12
59783: PUSH
59784: EMPTY
59785: LIST
59786: LIST
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: PPUSH
59792: CALL_OW 70
59796: PUSH
59797: LD_INT 22
59799: PUSH
59800: LD_INT 0
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: PUSH
59807: LD_INT 25
59809: PUSH
59810: LD_INT 12
59812: PUSH
59813: EMPTY
59814: LIST
59815: LIST
59816: PUSH
59817: LD_INT 91
59819: PUSH
59820: LD_VAR 0 9
59824: PUSH
59825: LD_INT 20
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: LIST
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: LIST
59837: PPUSH
59838: CALL_OW 69
59842: UNION
59843: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
59844: LD_ADDR_VAR 0 10
59848: PUSH
59849: LD_EXP 42
59853: PUSH
59854: LD_VAR 0 2
59858: ARRAY
59859: PPUSH
59860: LD_INT 81
59862: PUSH
59863: LD_VAR 0 11
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: PPUSH
59872: CALL_OW 70
59876: ST_TO_ADDR
// if not apes or danger_at_area then
59877: LD_VAR 0 7
59881: NOT
59882: PUSH
59883: LD_VAR 0 10
59887: OR
59888: IFFALSE 59938
// begin if mc_taming [ i ] then
59890: LD_EXP 45
59894: PUSH
59895: LD_VAR 0 2
59899: ARRAY
59900: IFFALSE 59936
// begin MC_Reset ( i , 121 ) ;
59902: LD_VAR 0 2
59906: PPUSH
59907: LD_INT 121
59909: PPUSH
59910: CALL 45389 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59914: LD_ADDR_EXP 45
59918: PUSH
59919: LD_EXP 45
59923: PPUSH
59924: LD_VAR 0 2
59928: PPUSH
59929: EMPTY
59930: PPUSH
59931: CALL_OW 1
59935: ST_TO_ADDR
// end ; continue ;
59936: GO 59504
// end ; for j in tmp do
59938: LD_ADDR_VAR 0 3
59942: PUSH
59943: LD_VAR 0 8
59947: PUSH
59948: FOR_IN
59949: IFFALSE 60285
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
59951: LD_VAR 0 3
59955: PUSH
59956: LD_EXP 45
59960: PUSH
59961: LD_VAR 0 2
59965: ARRAY
59966: IN
59967: NOT
59968: PUSH
59969: LD_EXP 45
59973: PUSH
59974: LD_VAR 0 2
59978: ARRAY
59979: PUSH
59980: LD_INT 3
59982: LESS
59983: AND
59984: IFFALSE 60042
// begin SetTag ( j , 121 ) ;
59986: LD_VAR 0 3
59990: PPUSH
59991: LD_INT 121
59993: PPUSH
59994: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
59998: LD_ADDR_EXP 45
60002: PUSH
60003: LD_EXP 45
60007: PPUSH
60008: LD_VAR 0 2
60012: PUSH
60013: LD_EXP 45
60017: PUSH
60018: LD_VAR 0 2
60022: ARRAY
60023: PUSH
60024: LD_INT 1
60026: PLUS
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: PPUSH
60032: LD_VAR 0 3
60036: PPUSH
60037: CALL 9445 0 3
60041: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
60042: LD_VAR 0 3
60046: PUSH
60047: LD_EXP 45
60051: PUSH
60052: LD_VAR 0 2
60056: ARRAY
60057: IN
60058: IFFALSE 60283
// begin if GetClass ( j ) <> 4 then
60060: LD_VAR 0 3
60064: PPUSH
60065: CALL_OW 257
60069: PUSH
60070: LD_INT 4
60072: NONEQUAL
60073: IFFALSE 60126
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
60075: LD_ADDR_EXP 45
60079: PUSH
60080: LD_EXP 45
60084: PPUSH
60085: LD_VAR 0 2
60089: PPUSH
60090: LD_EXP 45
60094: PUSH
60095: LD_VAR 0 2
60099: ARRAY
60100: PUSH
60101: LD_VAR 0 3
60105: DIFF
60106: PPUSH
60107: CALL_OW 1
60111: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60112: LD_VAR 0 3
60116: PPUSH
60117: LD_INT 0
60119: PPUSH
60120: CALL_OW 109
// continue ;
60124: GO 59948
// end ; if IsInUnit ( j ) then
60126: LD_VAR 0 3
60130: PPUSH
60131: CALL_OW 310
60135: IFFALSE 60146
// ComExitBuilding ( j ) ;
60137: LD_VAR 0 3
60141: PPUSH
60142: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
60146: LD_ADDR_VAR 0 6
60150: PUSH
60151: LD_VAR 0 7
60155: PPUSH
60156: LD_VAR 0 3
60160: PPUSH
60161: CALL_OW 74
60165: ST_TO_ADDR
// if not ape then
60166: LD_VAR 0 6
60170: NOT
60171: IFFALSE 60175
// break ;
60173: GO 60285
// x := GetX ( ape ) ;
60175: LD_ADDR_VAR 0 4
60179: PUSH
60180: LD_VAR 0 6
60184: PPUSH
60185: CALL_OW 250
60189: ST_TO_ADDR
// y := GetY ( ape ) ;
60190: LD_ADDR_VAR 0 5
60194: PUSH
60195: LD_VAR 0 6
60199: PPUSH
60200: CALL_OW 251
60204: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60205: LD_VAR 0 4
60209: PPUSH
60210: LD_VAR 0 5
60214: PPUSH
60215: CALL_OW 488
60219: NOT
60220: PUSH
60221: LD_VAR 0 11
60225: PPUSH
60226: LD_VAR 0 4
60230: PPUSH
60231: LD_VAR 0 5
60235: PPUSH
60236: LD_INT 20
60238: PPUSH
60239: CALL 10341 0 4
60243: PUSH
60244: LD_INT 4
60246: ARRAY
60247: OR
60248: IFFALSE 60252
// break ;
60250: GO 60285
// if not HasTask ( j ) then
60252: LD_VAR 0 3
60256: PPUSH
60257: CALL_OW 314
60261: NOT
60262: IFFALSE 60283
// ComTameXY ( j , x , y ) ;
60264: LD_VAR 0 3
60268: PPUSH
60269: LD_VAR 0 4
60273: PPUSH
60274: LD_VAR 0 5
60278: PPUSH
60279: CALL_OW 131
// end ; end ;
60283: GO 59948
60285: POP
60286: POP
// end ;
60287: GO 59504
60289: POP
60290: POP
// end ;
60291: LD_VAR 0 1
60295: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
60296: LD_INT 0
60298: PPUSH
60299: PPUSH
60300: PPUSH
60301: PPUSH
60302: PPUSH
60303: PPUSH
60304: PPUSH
60305: PPUSH
// if not mc_bases then
60306: LD_EXP 14
60310: NOT
60311: IFFALSE 60315
// exit ;
60313: GO 60941
// for i = 1 to mc_bases do
60315: LD_ADDR_VAR 0 2
60319: PUSH
60320: DOUBLE
60321: LD_INT 1
60323: DEC
60324: ST_TO_ADDR
60325: LD_EXP 14
60329: PUSH
60330: FOR_TO
60331: IFFALSE 60939
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
60333: LD_EXP 43
60337: PUSH
60338: LD_VAR 0 2
60342: ARRAY
60343: NOT
60344: PUSH
60345: LD_EXP 43
60349: PUSH
60350: LD_VAR 0 2
60354: ARRAY
60355: PPUSH
60356: LD_INT 25
60358: PUSH
60359: LD_INT 12
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: PPUSH
60366: CALL_OW 72
60370: NOT
60371: OR
60372: IFFALSE 60376
// continue ;
60374: GO 60330
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
60376: LD_ADDR_VAR 0 5
60380: PUSH
60381: LD_EXP 43
60385: PUSH
60386: LD_VAR 0 2
60390: ARRAY
60391: PUSH
60392: LD_INT 1
60394: ARRAY
60395: PPUSH
60396: CALL_OW 255
60400: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
60401: LD_VAR 0 5
60405: PPUSH
60406: LD_INT 2
60408: PPUSH
60409: CALL_OW 325
60413: IFFALSE 60666
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60415: LD_ADDR_VAR 0 4
60419: PUSH
60420: LD_EXP 43
60424: PUSH
60425: LD_VAR 0 2
60429: ARRAY
60430: PPUSH
60431: LD_INT 25
60433: PUSH
60434: LD_INT 16
60436: PUSH
60437: EMPTY
60438: LIST
60439: LIST
60440: PPUSH
60441: CALL_OW 72
60445: ST_TO_ADDR
// if tmp < 6 then
60446: LD_VAR 0 4
60450: PUSH
60451: LD_INT 6
60453: LESS
60454: IFFALSE 60666
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60456: LD_ADDR_VAR 0 6
60460: PUSH
60461: LD_EXP 14
60465: PUSH
60466: LD_VAR 0 2
60470: ARRAY
60471: PPUSH
60472: LD_INT 2
60474: PUSH
60475: LD_INT 30
60477: PUSH
60478: LD_INT 0
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PUSH
60485: LD_INT 30
60487: PUSH
60488: LD_INT 1
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: PUSH
60495: EMPTY
60496: LIST
60497: LIST
60498: LIST
60499: PPUSH
60500: CALL_OW 72
60504: ST_TO_ADDR
// if depot then
60505: LD_VAR 0 6
60509: IFFALSE 60666
// begin selected := 0 ;
60511: LD_ADDR_VAR 0 7
60515: PUSH
60516: LD_INT 0
60518: ST_TO_ADDR
// for j in depot do
60519: LD_ADDR_VAR 0 3
60523: PUSH
60524: LD_VAR 0 6
60528: PUSH
60529: FOR_IN
60530: IFFALSE 60561
// begin if UnitsInside ( j ) < 6 then
60532: LD_VAR 0 3
60536: PPUSH
60537: CALL_OW 313
60541: PUSH
60542: LD_INT 6
60544: LESS
60545: IFFALSE 60559
// begin selected := j ;
60547: LD_ADDR_VAR 0 7
60551: PUSH
60552: LD_VAR 0 3
60556: ST_TO_ADDR
// break ;
60557: GO 60561
// end ; end ;
60559: GO 60529
60561: POP
60562: POP
// if selected then
60563: LD_VAR 0 7
60567: IFFALSE 60666
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60569: LD_ADDR_VAR 0 3
60573: PUSH
60574: LD_EXP 43
60578: PUSH
60579: LD_VAR 0 2
60583: ARRAY
60584: PPUSH
60585: LD_INT 25
60587: PUSH
60588: LD_INT 12
60590: PUSH
60591: EMPTY
60592: LIST
60593: LIST
60594: PPUSH
60595: CALL_OW 72
60599: PUSH
60600: FOR_IN
60601: IFFALSE 60664
// if not HasTask ( j ) then
60603: LD_VAR 0 3
60607: PPUSH
60608: CALL_OW 314
60612: NOT
60613: IFFALSE 60662
// begin if not IsInUnit ( j ) then
60615: LD_VAR 0 3
60619: PPUSH
60620: CALL_OW 310
60624: NOT
60625: IFFALSE 60641
// ComEnterUnit ( j , selected ) ;
60627: LD_VAR 0 3
60631: PPUSH
60632: LD_VAR 0 7
60636: PPUSH
60637: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
60641: LD_VAR 0 3
60645: PPUSH
60646: LD_INT 16
60648: PPUSH
60649: CALL_OW 183
// AddComExitBuilding ( j ) ;
60653: LD_VAR 0 3
60657: PPUSH
60658: CALL_OW 182
// end ;
60662: GO 60600
60664: POP
60665: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
60666: LD_VAR 0 5
60670: PPUSH
60671: LD_INT 11
60673: PPUSH
60674: CALL_OW 325
60678: IFFALSE 60937
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60680: LD_ADDR_VAR 0 4
60684: PUSH
60685: LD_EXP 43
60689: PUSH
60690: LD_VAR 0 2
60694: ARRAY
60695: PPUSH
60696: LD_INT 25
60698: PUSH
60699: LD_INT 16
60701: PUSH
60702: EMPTY
60703: LIST
60704: LIST
60705: PPUSH
60706: CALL_OW 72
60710: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
60711: LD_VAR 0 4
60715: PUSH
60716: LD_INT 6
60718: GREATEREQUAL
60719: PUSH
60720: LD_VAR 0 5
60724: PPUSH
60725: LD_INT 2
60727: PPUSH
60728: CALL_OW 325
60732: NOT
60733: OR
60734: IFFALSE 60937
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60736: LD_ADDR_VAR 0 8
60740: PUSH
60741: LD_EXP 14
60745: PUSH
60746: LD_VAR 0 2
60750: ARRAY
60751: PPUSH
60752: LD_INT 2
60754: PUSH
60755: LD_INT 30
60757: PUSH
60758: LD_INT 4
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PUSH
60765: LD_INT 30
60767: PUSH
60768: LD_INT 5
60770: PUSH
60771: EMPTY
60772: LIST
60773: LIST
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: LIST
60779: PPUSH
60780: CALL_OW 72
60784: ST_TO_ADDR
// if barracks then
60785: LD_VAR 0 8
60789: IFFALSE 60937
// begin selected := 0 ;
60791: LD_ADDR_VAR 0 7
60795: PUSH
60796: LD_INT 0
60798: ST_TO_ADDR
// for j in barracks do
60799: LD_ADDR_VAR 0 3
60803: PUSH
60804: LD_VAR 0 8
60808: PUSH
60809: FOR_IN
60810: IFFALSE 60841
// begin if UnitsInside ( j ) < 6 then
60812: LD_VAR 0 3
60816: PPUSH
60817: CALL_OW 313
60821: PUSH
60822: LD_INT 6
60824: LESS
60825: IFFALSE 60839
// begin selected := j ;
60827: LD_ADDR_VAR 0 7
60831: PUSH
60832: LD_VAR 0 3
60836: ST_TO_ADDR
// break ;
60837: GO 60841
// end ; end ;
60839: GO 60809
60841: POP
60842: POP
// if selected then
60843: LD_VAR 0 7
60847: IFFALSE 60937
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60849: LD_ADDR_VAR 0 3
60853: PUSH
60854: LD_EXP 43
60858: PUSH
60859: LD_VAR 0 2
60863: ARRAY
60864: PPUSH
60865: LD_INT 25
60867: PUSH
60868: LD_INT 12
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PPUSH
60875: CALL_OW 72
60879: PUSH
60880: FOR_IN
60881: IFFALSE 60935
// if not IsInUnit ( j ) and not HasTask ( j ) then
60883: LD_VAR 0 3
60887: PPUSH
60888: CALL_OW 310
60892: NOT
60893: PUSH
60894: LD_VAR 0 3
60898: PPUSH
60899: CALL_OW 314
60903: NOT
60904: AND
60905: IFFALSE 60933
// begin ComEnterUnit ( j , selected ) ;
60907: LD_VAR 0 3
60911: PPUSH
60912: LD_VAR 0 7
60916: PPUSH
60917: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
60921: LD_VAR 0 3
60925: PPUSH
60926: LD_INT 15
60928: PPUSH
60929: CALL_OW 183
// end ;
60933: GO 60880
60935: POP
60936: POP
// end ; end ; end ; end ; end ;
60937: GO 60330
60939: POP
60940: POP
// end ;
60941: LD_VAR 0 1
60945: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
60946: LD_INT 0
60948: PPUSH
60949: PPUSH
60950: PPUSH
60951: PPUSH
// if not mc_bases then
60952: LD_EXP 14
60956: NOT
60957: IFFALSE 60961
// exit ;
60959: GO 61139
// for i = 1 to mc_bases do
60961: LD_ADDR_VAR 0 2
60965: PUSH
60966: DOUBLE
60967: LD_INT 1
60969: DEC
60970: ST_TO_ADDR
60971: LD_EXP 14
60975: PUSH
60976: FOR_TO
60977: IFFALSE 61137
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
60979: LD_ADDR_VAR 0 4
60983: PUSH
60984: LD_EXP 14
60988: PUSH
60989: LD_VAR 0 2
60993: ARRAY
60994: PPUSH
60995: LD_INT 25
60997: PUSH
60998: LD_INT 9
61000: PUSH
61001: EMPTY
61002: LIST
61003: LIST
61004: PPUSH
61005: CALL_OW 72
61009: ST_TO_ADDR
// if not tmp then
61010: LD_VAR 0 4
61014: NOT
61015: IFFALSE 61019
// continue ;
61017: GO 60976
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
61019: LD_EXP 40
61023: PUSH
61024: LD_VAR 0 2
61028: ARRAY
61029: PPUSH
61030: LD_INT 29
61032: PPUSH
61033: CALL_OW 325
61037: NOT
61038: PUSH
61039: LD_EXP 40
61043: PUSH
61044: LD_VAR 0 2
61048: ARRAY
61049: PPUSH
61050: LD_INT 28
61052: PPUSH
61053: CALL_OW 325
61057: NOT
61058: AND
61059: IFFALSE 61063
// continue ;
61061: GO 60976
// for j in tmp do
61063: LD_ADDR_VAR 0 3
61067: PUSH
61068: LD_VAR 0 4
61072: PUSH
61073: FOR_IN
61074: IFFALSE 61133
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
61076: LD_VAR 0 3
61080: PUSH
61081: LD_EXP 17
61085: PUSH
61086: LD_VAR 0 2
61090: ARRAY
61091: PUSH
61092: LD_INT 1
61094: ARRAY
61095: IN
61096: NOT
61097: PUSH
61098: LD_VAR 0 3
61102: PUSH
61103: LD_EXP 17
61107: PUSH
61108: LD_VAR 0 2
61112: ARRAY
61113: PUSH
61114: LD_INT 2
61116: ARRAY
61117: IN
61118: NOT
61119: AND
61120: IFFALSE 61131
// ComSpaceTimeShoot ( j ) ;
61122: LD_VAR 0 3
61126: PPUSH
61127: CALL 5442 0 1
61131: GO 61073
61133: POP
61134: POP
// end ;
61135: GO 60976
61137: POP
61138: POP
// end ;
61139: LD_VAR 0 1
61143: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
61144: LD_INT 0
61146: PPUSH
61147: PPUSH
61148: PPUSH
61149: PPUSH
61150: PPUSH
61151: PPUSH
61152: PPUSH
61153: PPUSH
61154: PPUSH
// if not mc_bases then
61155: LD_EXP 14
61159: NOT
61160: IFFALSE 61164
// exit ;
61162: GO 61786
// for i = 1 to mc_bases do
61164: LD_ADDR_VAR 0 2
61168: PUSH
61169: DOUBLE
61170: LD_INT 1
61172: DEC
61173: ST_TO_ADDR
61174: LD_EXP 14
61178: PUSH
61179: FOR_TO
61180: IFFALSE 61784
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
61182: LD_EXP 49
61186: PUSH
61187: LD_VAR 0 2
61191: ARRAY
61192: NOT
61193: PUSH
61194: LD_INT 38
61196: PPUSH
61197: LD_EXP 40
61201: PUSH
61202: LD_VAR 0 2
61206: ARRAY
61207: PPUSH
61208: CALL_OW 321
61212: PUSH
61213: LD_INT 2
61215: NONEQUAL
61216: OR
61217: IFFALSE 61221
// continue ;
61219: GO 61179
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
61221: LD_ADDR_VAR 0 8
61225: PUSH
61226: LD_EXP 14
61230: PUSH
61231: LD_VAR 0 2
61235: ARRAY
61236: PPUSH
61237: LD_INT 30
61239: PUSH
61240: LD_INT 34
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PPUSH
61247: CALL_OW 72
61251: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
61252: LD_ADDR_VAR 0 9
61256: PUSH
61257: LD_EXP 14
61261: PUSH
61262: LD_VAR 0 2
61266: ARRAY
61267: PPUSH
61268: LD_INT 25
61270: PUSH
61271: LD_INT 4
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PPUSH
61278: CALL_OW 72
61282: PPUSH
61283: LD_INT 0
61285: PPUSH
61286: CALL 38006 0 2
61290: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
61291: LD_VAR 0 9
61295: NOT
61296: PUSH
61297: LD_VAR 0 8
61301: NOT
61302: OR
61303: PUSH
61304: LD_EXP 14
61308: PUSH
61309: LD_VAR 0 2
61313: ARRAY
61314: PPUSH
61315: LD_INT 124
61317: PPUSH
61318: CALL 38006 0 2
61322: OR
61323: IFFALSE 61327
// continue ;
61325: GO 61179
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
61327: LD_EXP 50
61331: PUSH
61332: LD_VAR 0 2
61336: ARRAY
61337: PUSH
61338: LD_EXP 49
61342: PUSH
61343: LD_VAR 0 2
61347: ARRAY
61348: LESS
61349: PUSH
61350: LD_EXP 50
61354: PUSH
61355: LD_VAR 0 2
61359: ARRAY
61360: PUSH
61361: LD_VAR 0 8
61365: LESS
61366: AND
61367: IFFALSE 61782
// begin tmp := sci [ 1 ] ;
61369: LD_ADDR_VAR 0 7
61373: PUSH
61374: LD_VAR 0 9
61378: PUSH
61379: LD_INT 1
61381: ARRAY
61382: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
61383: LD_VAR 0 7
61387: PPUSH
61388: LD_INT 124
61390: PPUSH
61391: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
61395: LD_ADDR_VAR 0 3
61399: PUSH
61400: DOUBLE
61401: LD_EXP 49
61405: PUSH
61406: LD_VAR 0 2
61410: ARRAY
61411: INC
61412: ST_TO_ADDR
61413: LD_EXP 49
61417: PUSH
61418: LD_VAR 0 2
61422: ARRAY
61423: PUSH
61424: FOR_DOWNTO
61425: IFFALSE 61768
// begin if IsInUnit ( tmp ) then
61427: LD_VAR 0 7
61431: PPUSH
61432: CALL_OW 310
61436: IFFALSE 61447
// ComExitBuilding ( tmp ) ;
61438: LD_VAR 0 7
61442: PPUSH
61443: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
61447: LD_INT 35
61449: PPUSH
61450: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
61454: LD_VAR 0 7
61458: PPUSH
61459: CALL_OW 310
61463: NOT
61464: PUSH
61465: LD_VAR 0 7
61469: PPUSH
61470: CALL_OW 314
61474: NOT
61475: AND
61476: IFFALSE 61447
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
61478: LD_ADDR_VAR 0 6
61482: PUSH
61483: LD_VAR 0 7
61487: PPUSH
61488: CALL_OW 250
61492: PUSH
61493: LD_VAR 0 7
61497: PPUSH
61498: CALL_OW 251
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
61507: LD_INT 35
61509: PPUSH
61510: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
61514: LD_ADDR_VAR 0 4
61518: PUSH
61519: LD_EXP 49
61523: PUSH
61524: LD_VAR 0 2
61528: ARRAY
61529: PUSH
61530: LD_VAR 0 3
61534: ARRAY
61535: PUSH
61536: LD_INT 1
61538: ARRAY
61539: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
61540: LD_ADDR_VAR 0 5
61544: PUSH
61545: LD_EXP 49
61549: PUSH
61550: LD_VAR 0 2
61554: ARRAY
61555: PUSH
61556: LD_VAR 0 3
61560: ARRAY
61561: PUSH
61562: LD_INT 2
61564: ARRAY
61565: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
61566: LD_VAR 0 7
61570: PPUSH
61571: LD_INT 10
61573: PPUSH
61574: CALL 12038 0 2
61578: PUSH
61579: LD_INT 4
61581: ARRAY
61582: IFFALSE 61620
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
61584: LD_VAR 0 7
61588: PPUSH
61589: LD_VAR 0 6
61593: PUSH
61594: LD_INT 1
61596: ARRAY
61597: PPUSH
61598: LD_VAR 0 6
61602: PUSH
61603: LD_INT 2
61605: ARRAY
61606: PPUSH
61607: CALL_OW 111
// wait ( 0 0$10 ) ;
61611: LD_INT 350
61613: PPUSH
61614: CALL_OW 67
// end else
61618: GO 61646
// begin ComMoveXY ( tmp , x , y ) ;
61620: LD_VAR 0 7
61624: PPUSH
61625: LD_VAR 0 4
61629: PPUSH
61630: LD_VAR 0 5
61634: PPUSH
61635: CALL_OW 111
// wait ( 0 0$3 ) ;
61639: LD_INT 105
61641: PPUSH
61642: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
61646: LD_VAR 0 7
61650: PPUSH
61651: LD_VAR 0 4
61655: PPUSH
61656: LD_VAR 0 5
61660: PPUSH
61661: CALL_OW 307
61665: IFFALSE 61507
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
61667: LD_VAR 0 7
61671: PPUSH
61672: LD_VAR 0 4
61676: PPUSH
61677: LD_VAR 0 5
61681: PPUSH
61682: LD_VAR 0 8
61686: PUSH
61687: LD_VAR 0 3
61691: ARRAY
61692: PPUSH
61693: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
61697: LD_INT 35
61699: PPUSH
61700: CALL_OW 67
// until not HasTask ( tmp ) ;
61704: LD_VAR 0 7
61708: PPUSH
61709: CALL_OW 314
61713: NOT
61714: IFFALSE 61697
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
61716: LD_ADDR_EXP 50
61720: PUSH
61721: LD_EXP 50
61725: PPUSH
61726: LD_VAR 0 2
61730: PUSH
61731: LD_EXP 50
61735: PUSH
61736: LD_VAR 0 2
61740: ARRAY
61741: PUSH
61742: LD_INT 1
61744: PLUS
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PPUSH
61750: LD_VAR 0 8
61754: PUSH
61755: LD_VAR 0 3
61759: ARRAY
61760: PPUSH
61761: CALL 9445 0 3
61765: ST_TO_ADDR
// end ;
61766: GO 61424
61768: POP
61769: POP
// MC_Reset ( i , 124 ) ;
61770: LD_VAR 0 2
61774: PPUSH
61775: LD_INT 124
61777: PPUSH
61778: CALL 45389 0 2
// end ; end ;
61782: GO 61179
61784: POP
61785: POP
// end ;
61786: LD_VAR 0 1
61790: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
61791: LD_INT 0
61793: PPUSH
61794: PPUSH
61795: PPUSH
// if not mc_bases then
61796: LD_EXP 14
61800: NOT
61801: IFFALSE 61805
// exit ;
61803: GO 62411
// for i = 1 to mc_bases do
61805: LD_ADDR_VAR 0 2
61809: PUSH
61810: DOUBLE
61811: LD_INT 1
61813: DEC
61814: ST_TO_ADDR
61815: LD_EXP 14
61819: PUSH
61820: FOR_TO
61821: IFFALSE 62409
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61823: LD_ADDR_VAR 0 3
61827: PUSH
61828: LD_EXP 14
61832: PUSH
61833: LD_VAR 0 2
61837: ARRAY
61838: PPUSH
61839: LD_INT 25
61841: PUSH
61842: LD_INT 4
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PPUSH
61849: CALL_OW 72
61853: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61854: LD_VAR 0 3
61858: NOT
61859: PUSH
61860: LD_EXP 51
61864: PUSH
61865: LD_VAR 0 2
61869: ARRAY
61870: NOT
61871: OR
61872: PUSH
61873: LD_EXP 14
61877: PUSH
61878: LD_VAR 0 2
61882: ARRAY
61883: PPUSH
61884: LD_INT 2
61886: PUSH
61887: LD_INT 30
61889: PUSH
61890: LD_INT 0
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 30
61899: PUSH
61900: LD_INT 1
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: LIST
61911: PPUSH
61912: CALL_OW 72
61916: NOT
61917: OR
61918: IFFALSE 61968
// begin if mc_deposits_finder [ i ] then
61920: LD_EXP 52
61924: PUSH
61925: LD_VAR 0 2
61929: ARRAY
61930: IFFALSE 61966
// begin MC_Reset ( i , 125 ) ;
61932: LD_VAR 0 2
61936: PPUSH
61937: LD_INT 125
61939: PPUSH
61940: CALL 45389 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61944: LD_ADDR_EXP 52
61948: PUSH
61949: LD_EXP 52
61953: PPUSH
61954: LD_VAR 0 2
61958: PPUSH
61959: EMPTY
61960: PPUSH
61961: CALL_OW 1
61965: ST_TO_ADDR
// end ; continue ;
61966: GO 61820
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
61968: LD_EXP 51
61972: PUSH
61973: LD_VAR 0 2
61977: ARRAY
61978: PUSH
61979: LD_INT 1
61981: ARRAY
61982: PUSH
61983: LD_INT 3
61985: ARRAY
61986: PUSH
61987: LD_INT 1
61989: EQUAL
61990: PUSH
61991: LD_INT 20
61993: PPUSH
61994: LD_EXP 40
61998: PUSH
61999: LD_VAR 0 2
62003: ARRAY
62004: PPUSH
62005: CALL_OW 321
62009: PUSH
62010: LD_INT 2
62012: NONEQUAL
62013: AND
62014: IFFALSE 62064
// begin if mc_deposits_finder [ i ] then
62016: LD_EXP 52
62020: PUSH
62021: LD_VAR 0 2
62025: ARRAY
62026: IFFALSE 62062
// begin MC_Reset ( i , 125 ) ;
62028: LD_VAR 0 2
62032: PPUSH
62033: LD_INT 125
62035: PPUSH
62036: CALL 45389 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62040: LD_ADDR_EXP 52
62044: PUSH
62045: LD_EXP 52
62049: PPUSH
62050: LD_VAR 0 2
62054: PPUSH
62055: EMPTY
62056: PPUSH
62057: CALL_OW 1
62061: ST_TO_ADDR
// end ; continue ;
62062: GO 61820
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
62064: LD_EXP 51
62068: PUSH
62069: LD_VAR 0 2
62073: ARRAY
62074: PUSH
62075: LD_INT 1
62077: ARRAY
62078: PUSH
62079: LD_INT 1
62081: ARRAY
62082: PPUSH
62083: LD_EXP 51
62087: PUSH
62088: LD_VAR 0 2
62092: ARRAY
62093: PUSH
62094: LD_INT 1
62096: ARRAY
62097: PUSH
62098: LD_INT 2
62100: ARRAY
62101: PPUSH
62102: LD_EXP 40
62106: PUSH
62107: LD_VAR 0 2
62111: ARRAY
62112: PPUSH
62113: CALL_OW 440
62117: IFFALSE 62160
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
62119: LD_ADDR_EXP 51
62123: PUSH
62124: LD_EXP 51
62128: PPUSH
62129: LD_VAR 0 2
62133: PPUSH
62134: LD_EXP 51
62138: PUSH
62139: LD_VAR 0 2
62143: ARRAY
62144: PPUSH
62145: LD_INT 1
62147: PPUSH
62148: CALL_OW 3
62152: PPUSH
62153: CALL_OW 1
62157: ST_TO_ADDR
62158: GO 62407
// begin if not mc_deposits_finder [ i ] then
62160: LD_EXP 52
62164: PUSH
62165: LD_VAR 0 2
62169: ARRAY
62170: NOT
62171: IFFALSE 62223
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
62173: LD_ADDR_EXP 52
62177: PUSH
62178: LD_EXP 52
62182: PPUSH
62183: LD_VAR 0 2
62187: PPUSH
62188: LD_VAR 0 3
62192: PUSH
62193: LD_INT 1
62195: ARRAY
62196: PUSH
62197: EMPTY
62198: LIST
62199: PPUSH
62200: CALL_OW 1
62204: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
62205: LD_VAR 0 3
62209: PUSH
62210: LD_INT 1
62212: ARRAY
62213: PPUSH
62214: LD_INT 125
62216: PPUSH
62217: CALL_OW 109
// end else
62221: GO 62407
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
62223: LD_EXP 52
62227: PUSH
62228: LD_VAR 0 2
62232: ARRAY
62233: PUSH
62234: LD_INT 1
62236: ARRAY
62237: PPUSH
62238: CALL_OW 310
62242: IFFALSE 62265
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
62244: LD_EXP 52
62248: PUSH
62249: LD_VAR 0 2
62253: ARRAY
62254: PUSH
62255: LD_INT 1
62257: ARRAY
62258: PPUSH
62259: CALL_OW 122
62263: GO 62407
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
62265: LD_EXP 52
62269: PUSH
62270: LD_VAR 0 2
62274: ARRAY
62275: PUSH
62276: LD_INT 1
62278: ARRAY
62279: PPUSH
62280: CALL_OW 314
62284: NOT
62285: PUSH
62286: LD_EXP 52
62290: PUSH
62291: LD_VAR 0 2
62295: ARRAY
62296: PUSH
62297: LD_INT 1
62299: ARRAY
62300: PPUSH
62301: LD_EXP 51
62305: PUSH
62306: LD_VAR 0 2
62310: ARRAY
62311: PUSH
62312: LD_INT 1
62314: ARRAY
62315: PUSH
62316: LD_INT 1
62318: ARRAY
62319: PPUSH
62320: LD_EXP 51
62324: PUSH
62325: LD_VAR 0 2
62329: ARRAY
62330: PUSH
62331: LD_INT 1
62333: ARRAY
62334: PUSH
62335: LD_INT 2
62337: ARRAY
62338: PPUSH
62339: CALL_OW 297
62343: PUSH
62344: LD_INT 6
62346: GREATER
62347: AND
62348: IFFALSE 62407
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
62350: LD_EXP 52
62354: PUSH
62355: LD_VAR 0 2
62359: ARRAY
62360: PUSH
62361: LD_INT 1
62363: ARRAY
62364: PPUSH
62365: LD_EXP 51
62369: PUSH
62370: LD_VAR 0 2
62374: ARRAY
62375: PUSH
62376: LD_INT 1
62378: ARRAY
62379: PUSH
62380: LD_INT 1
62382: ARRAY
62383: PPUSH
62384: LD_EXP 51
62388: PUSH
62389: LD_VAR 0 2
62393: ARRAY
62394: PUSH
62395: LD_INT 1
62397: ARRAY
62398: PUSH
62399: LD_INT 2
62401: ARRAY
62402: PPUSH
62403: CALL_OW 111
// end ; end ; end ;
62407: GO 61820
62409: POP
62410: POP
// end ;
62411: LD_VAR 0 1
62415: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
62416: LD_INT 0
62418: PPUSH
62419: PPUSH
62420: PPUSH
62421: PPUSH
62422: PPUSH
62423: PPUSH
62424: PPUSH
62425: PPUSH
62426: PPUSH
62427: PPUSH
62428: PPUSH
// if not mc_bases then
62429: LD_EXP 14
62433: NOT
62434: IFFALSE 62438
// exit ;
62436: GO 63378
// for i = 1 to mc_bases do
62438: LD_ADDR_VAR 0 2
62442: PUSH
62443: DOUBLE
62444: LD_INT 1
62446: DEC
62447: ST_TO_ADDR
62448: LD_EXP 14
62452: PUSH
62453: FOR_TO
62454: IFFALSE 63376
// begin if not mc_bases [ i ] or mc_scan [ i ] then
62456: LD_EXP 14
62460: PUSH
62461: LD_VAR 0 2
62465: ARRAY
62466: NOT
62467: PUSH
62468: LD_EXP 37
62472: PUSH
62473: LD_VAR 0 2
62477: ARRAY
62478: OR
62479: IFFALSE 62483
// continue ;
62481: GO 62453
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
62483: LD_ADDR_VAR 0 7
62487: PUSH
62488: LD_EXP 14
62492: PUSH
62493: LD_VAR 0 2
62497: ARRAY
62498: PUSH
62499: LD_INT 1
62501: ARRAY
62502: PPUSH
62503: CALL_OW 248
62507: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
62508: LD_VAR 0 7
62512: PUSH
62513: LD_INT 3
62515: EQUAL
62516: PUSH
62517: LD_EXP 33
62521: PUSH
62522: LD_VAR 0 2
62526: ARRAY
62527: PUSH
62528: LD_EXP 36
62532: PUSH
62533: LD_VAR 0 2
62537: ARRAY
62538: UNION
62539: PPUSH
62540: LD_INT 33
62542: PUSH
62543: LD_INT 2
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: PPUSH
62550: CALL_OW 72
62554: NOT
62555: OR
62556: IFFALSE 62560
// continue ;
62558: GO 62453
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
62560: LD_ADDR_VAR 0 9
62564: PUSH
62565: LD_EXP 14
62569: PUSH
62570: LD_VAR 0 2
62574: ARRAY
62575: PPUSH
62576: LD_INT 30
62578: PUSH
62579: LD_INT 36
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PPUSH
62586: CALL_OW 72
62590: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
62591: LD_ADDR_VAR 0 10
62595: PUSH
62596: LD_EXP 33
62600: PUSH
62601: LD_VAR 0 2
62605: ARRAY
62606: PPUSH
62607: LD_INT 34
62609: PUSH
62610: LD_INT 31
62612: PUSH
62613: EMPTY
62614: LIST
62615: LIST
62616: PPUSH
62617: CALL_OW 72
62621: ST_TO_ADDR
// if not cts and not mcts then
62622: LD_VAR 0 9
62626: NOT
62627: PUSH
62628: LD_VAR 0 10
62632: NOT
62633: AND
62634: IFFALSE 62638
// continue ;
62636: GO 62453
// x := cts ;
62638: LD_ADDR_VAR 0 11
62642: PUSH
62643: LD_VAR 0 9
62647: ST_TO_ADDR
// if not x then
62648: LD_VAR 0 11
62652: NOT
62653: IFFALSE 62665
// x := mcts ;
62655: LD_ADDR_VAR 0 11
62659: PUSH
62660: LD_VAR 0 10
62664: ST_TO_ADDR
// if not x then
62665: LD_VAR 0 11
62669: NOT
62670: IFFALSE 62674
// continue ;
62672: GO 62453
// if mc_remote_driver [ i ] then
62674: LD_EXP 54
62678: PUSH
62679: LD_VAR 0 2
62683: ARRAY
62684: IFFALSE 63071
// for j in mc_remote_driver [ i ] do
62686: LD_ADDR_VAR 0 3
62690: PUSH
62691: LD_EXP 54
62695: PUSH
62696: LD_VAR 0 2
62700: ARRAY
62701: PUSH
62702: FOR_IN
62703: IFFALSE 63069
// begin if GetClass ( j ) <> 3 then
62705: LD_VAR 0 3
62709: PPUSH
62710: CALL_OW 257
62714: PUSH
62715: LD_INT 3
62717: NONEQUAL
62718: IFFALSE 62771
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
62720: LD_ADDR_EXP 54
62724: PUSH
62725: LD_EXP 54
62729: PPUSH
62730: LD_VAR 0 2
62734: PPUSH
62735: LD_EXP 54
62739: PUSH
62740: LD_VAR 0 2
62744: ARRAY
62745: PUSH
62746: LD_VAR 0 3
62750: DIFF
62751: PPUSH
62752: CALL_OW 1
62756: ST_TO_ADDR
// SetTag ( j , 0 ) ;
62757: LD_VAR 0 3
62761: PPUSH
62762: LD_INT 0
62764: PPUSH
62765: CALL_OW 109
// continue ;
62769: GO 62702
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
62771: LD_EXP 33
62775: PUSH
62776: LD_VAR 0 2
62780: ARRAY
62781: PPUSH
62782: LD_INT 34
62784: PUSH
62785: LD_INT 31
62787: PUSH
62788: EMPTY
62789: LIST
62790: LIST
62791: PUSH
62792: LD_INT 58
62794: PUSH
62795: EMPTY
62796: LIST
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: PPUSH
62802: CALL_OW 72
62806: PUSH
62807: LD_VAR 0 3
62811: PPUSH
62812: CALL 38094 0 1
62816: NOT
62817: AND
62818: IFFALSE 62889
// begin if IsInUnit ( j ) then
62820: LD_VAR 0 3
62824: PPUSH
62825: CALL_OW 310
62829: IFFALSE 62840
// ComExitBuilding ( j ) ;
62831: LD_VAR 0 3
62835: PPUSH
62836: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
62840: LD_VAR 0 3
62844: PPUSH
62845: LD_EXP 33
62849: PUSH
62850: LD_VAR 0 2
62854: ARRAY
62855: PPUSH
62856: LD_INT 34
62858: PUSH
62859: LD_INT 31
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: LD_INT 58
62868: PUSH
62869: EMPTY
62870: LIST
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: PPUSH
62876: CALL_OW 72
62880: PUSH
62881: LD_INT 1
62883: ARRAY
62884: PPUSH
62885: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
62889: LD_VAR 0 3
62893: PPUSH
62894: CALL_OW 310
62898: NOT
62899: PUSH
62900: LD_VAR 0 3
62904: PPUSH
62905: CALL_OW 310
62909: PPUSH
62910: CALL_OW 266
62914: PUSH
62915: LD_INT 36
62917: NONEQUAL
62918: PUSH
62919: LD_VAR 0 3
62923: PPUSH
62924: CALL 38094 0 1
62928: NOT
62929: AND
62930: OR
62931: IFFALSE 63067
// begin if IsInUnit ( j ) then
62933: LD_VAR 0 3
62937: PPUSH
62938: CALL_OW 310
62942: IFFALSE 62953
// ComExitBuilding ( j ) ;
62944: LD_VAR 0 3
62948: PPUSH
62949: CALL_OW 122
// ct := 0 ;
62953: LD_ADDR_VAR 0 8
62957: PUSH
62958: LD_INT 0
62960: ST_TO_ADDR
// for k in x do
62961: LD_ADDR_VAR 0 4
62965: PUSH
62966: LD_VAR 0 11
62970: PUSH
62971: FOR_IN
62972: IFFALSE 63045
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
62974: LD_VAR 0 4
62978: PPUSH
62979: CALL_OW 264
62983: PUSH
62984: LD_INT 31
62986: EQUAL
62987: PUSH
62988: LD_VAR 0 4
62992: PPUSH
62993: CALL_OW 311
62997: NOT
62998: AND
62999: PUSH
63000: LD_VAR 0 4
63004: PPUSH
63005: CALL_OW 266
63009: PUSH
63010: LD_INT 36
63012: EQUAL
63013: PUSH
63014: LD_VAR 0 4
63018: PPUSH
63019: CALL_OW 313
63023: PUSH
63024: LD_INT 3
63026: LESS
63027: AND
63028: OR
63029: IFFALSE 63043
// begin ct := k ;
63031: LD_ADDR_VAR 0 8
63035: PUSH
63036: LD_VAR 0 4
63040: ST_TO_ADDR
// break ;
63041: GO 63045
// end ;
63043: GO 62971
63045: POP
63046: POP
// if ct then
63047: LD_VAR 0 8
63051: IFFALSE 63067
// ComEnterUnit ( j , ct ) ;
63053: LD_VAR 0 3
63057: PPUSH
63058: LD_VAR 0 8
63062: PPUSH
63063: CALL_OW 120
// end ; end ;
63067: GO 62702
63069: POP
63070: POP
// places := 0 ;
63071: LD_ADDR_VAR 0 5
63075: PUSH
63076: LD_INT 0
63078: ST_TO_ADDR
// for j = 1 to x do
63079: LD_ADDR_VAR 0 3
63083: PUSH
63084: DOUBLE
63085: LD_INT 1
63087: DEC
63088: ST_TO_ADDR
63089: LD_VAR 0 11
63093: PUSH
63094: FOR_TO
63095: IFFALSE 63171
// if GetWeapon ( x [ j ] ) = ar_control_tower then
63097: LD_VAR 0 11
63101: PUSH
63102: LD_VAR 0 3
63106: ARRAY
63107: PPUSH
63108: CALL_OW 264
63112: PUSH
63113: LD_INT 31
63115: EQUAL
63116: IFFALSE 63134
// places := places + 1 else
63118: LD_ADDR_VAR 0 5
63122: PUSH
63123: LD_VAR 0 5
63127: PUSH
63128: LD_INT 1
63130: PLUS
63131: ST_TO_ADDR
63132: GO 63169
// if GetBType ( x [ j ] ) = b_control_tower then
63134: LD_VAR 0 11
63138: PUSH
63139: LD_VAR 0 3
63143: ARRAY
63144: PPUSH
63145: CALL_OW 266
63149: PUSH
63150: LD_INT 36
63152: EQUAL
63153: IFFALSE 63169
// places := places + 3 ;
63155: LD_ADDR_VAR 0 5
63159: PUSH
63160: LD_VAR 0 5
63164: PUSH
63165: LD_INT 3
63167: PLUS
63168: ST_TO_ADDR
63169: GO 63094
63171: POP
63172: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
63173: LD_VAR 0 5
63177: PUSH
63178: LD_INT 0
63180: EQUAL
63181: PUSH
63182: LD_VAR 0 5
63186: PUSH
63187: LD_EXP 54
63191: PUSH
63192: LD_VAR 0 2
63196: ARRAY
63197: LESSEQUAL
63198: OR
63199: IFFALSE 63203
// continue ;
63201: GO 62453
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
63203: LD_ADDR_VAR 0 6
63207: PUSH
63208: LD_EXP 14
63212: PUSH
63213: LD_VAR 0 2
63217: ARRAY
63218: PPUSH
63219: LD_INT 25
63221: PUSH
63222: LD_INT 3
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: PPUSH
63229: CALL_OW 72
63233: PUSH
63234: LD_EXP 54
63238: PUSH
63239: LD_VAR 0 2
63243: ARRAY
63244: DIFF
63245: PPUSH
63246: LD_INT 3
63248: PPUSH
63249: CALL 38994 0 2
63253: ST_TO_ADDR
// for j in tmp do
63254: LD_ADDR_VAR 0 3
63258: PUSH
63259: LD_VAR 0 6
63263: PUSH
63264: FOR_IN
63265: IFFALSE 63300
// if GetTag ( j ) > 0 then
63267: LD_VAR 0 3
63271: PPUSH
63272: CALL_OW 110
63276: PUSH
63277: LD_INT 0
63279: GREATER
63280: IFFALSE 63298
// tmp := tmp diff j ;
63282: LD_ADDR_VAR 0 6
63286: PUSH
63287: LD_VAR 0 6
63291: PUSH
63292: LD_VAR 0 3
63296: DIFF
63297: ST_TO_ADDR
63298: GO 63264
63300: POP
63301: POP
// if not tmp then
63302: LD_VAR 0 6
63306: NOT
63307: IFFALSE 63311
// continue ;
63309: GO 62453
// if places then
63311: LD_VAR 0 5
63315: IFFALSE 63374
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
63317: LD_ADDR_EXP 54
63321: PUSH
63322: LD_EXP 54
63326: PPUSH
63327: LD_VAR 0 2
63331: PPUSH
63332: LD_EXP 54
63336: PUSH
63337: LD_VAR 0 2
63341: ARRAY
63342: PUSH
63343: LD_VAR 0 6
63347: PUSH
63348: LD_INT 1
63350: ARRAY
63351: UNION
63352: PPUSH
63353: CALL_OW 1
63357: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
63358: LD_VAR 0 6
63362: PUSH
63363: LD_INT 1
63365: ARRAY
63366: PPUSH
63367: LD_INT 126
63369: PPUSH
63370: CALL_OW 109
// end ; end ;
63374: GO 62453
63376: POP
63377: POP
// end ;
63378: LD_VAR 0 1
63382: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
63383: LD_INT 0
63385: PPUSH
63386: PPUSH
63387: PPUSH
63388: PPUSH
63389: PPUSH
63390: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
63391: LD_VAR 0 1
63395: NOT
63396: PUSH
63397: LD_VAR 0 2
63401: NOT
63402: OR
63403: PUSH
63404: LD_VAR 0 3
63408: NOT
63409: OR
63410: PUSH
63411: LD_VAR 0 4
63415: PUSH
63416: LD_INT 1
63418: PUSH
63419: LD_INT 2
63421: PUSH
63422: LD_INT 3
63424: PUSH
63425: LD_INT 4
63427: PUSH
63428: LD_INT 5
63430: PUSH
63431: LD_INT 8
63433: PUSH
63434: LD_INT 9
63436: PUSH
63437: LD_INT 15
63439: PUSH
63440: LD_INT 16
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: LIST
63447: LIST
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: LIST
63453: IN
63454: NOT
63455: OR
63456: IFFALSE 63460
// exit ;
63458: GO 64360
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
63460: LD_ADDR_VAR 0 2
63464: PUSH
63465: LD_VAR 0 2
63469: PPUSH
63470: LD_INT 21
63472: PUSH
63473: LD_INT 3
63475: PUSH
63476: EMPTY
63477: LIST
63478: LIST
63479: PUSH
63480: LD_INT 24
63482: PUSH
63483: LD_INT 250
63485: PUSH
63486: EMPTY
63487: LIST
63488: LIST
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PPUSH
63494: CALL_OW 72
63498: ST_TO_ADDR
// case class of 1 , 15 :
63499: LD_VAR 0 4
63503: PUSH
63504: LD_INT 1
63506: DOUBLE
63507: EQUAL
63508: IFTRUE 63518
63510: LD_INT 15
63512: DOUBLE
63513: EQUAL
63514: IFTRUE 63518
63516: GO 63603
63518: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
63519: LD_ADDR_VAR 0 8
63523: PUSH
63524: LD_VAR 0 2
63528: PPUSH
63529: LD_INT 2
63531: PUSH
63532: LD_INT 30
63534: PUSH
63535: LD_INT 32
63537: PUSH
63538: EMPTY
63539: LIST
63540: LIST
63541: PUSH
63542: LD_INT 30
63544: PUSH
63545: LD_INT 31
63547: PUSH
63548: EMPTY
63549: LIST
63550: LIST
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: LIST
63556: PPUSH
63557: CALL_OW 72
63561: PUSH
63562: LD_VAR 0 2
63566: PPUSH
63567: LD_INT 2
63569: PUSH
63570: LD_INT 30
63572: PUSH
63573: LD_INT 4
63575: PUSH
63576: EMPTY
63577: LIST
63578: LIST
63579: PUSH
63580: LD_INT 30
63582: PUSH
63583: LD_INT 5
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: LIST
63594: PPUSH
63595: CALL_OW 72
63599: ADD
63600: ST_TO_ADDR
63601: GO 63849
63603: LD_INT 2
63605: DOUBLE
63606: EQUAL
63607: IFTRUE 63617
63609: LD_INT 16
63611: DOUBLE
63612: EQUAL
63613: IFTRUE 63617
63615: GO 63663
63617: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
63618: LD_ADDR_VAR 0 8
63622: PUSH
63623: LD_VAR 0 2
63627: PPUSH
63628: LD_INT 2
63630: PUSH
63631: LD_INT 30
63633: PUSH
63634: LD_INT 0
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: PUSH
63641: LD_INT 30
63643: PUSH
63644: LD_INT 1
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: LIST
63655: PPUSH
63656: CALL_OW 72
63660: ST_TO_ADDR
63661: GO 63849
63663: LD_INT 3
63665: DOUBLE
63666: EQUAL
63667: IFTRUE 63671
63669: GO 63717
63671: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
63672: LD_ADDR_VAR 0 8
63676: PUSH
63677: LD_VAR 0 2
63681: PPUSH
63682: LD_INT 2
63684: PUSH
63685: LD_INT 30
63687: PUSH
63688: LD_INT 2
63690: PUSH
63691: EMPTY
63692: LIST
63693: LIST
63694: PUSH
63695: LD_INT 30
63697: PUSH
63698: LD_INT 3
63700: PUSH
63701: EMPTY
63702: LIST
63703: LIST
63704: PUSH
63705: EMPTY
63706: LIST
63707: LIST
63708: LIST
63709: PPUSH
63710: CALL_OW 72
63714: ST_TO_ADDR
63715: GO 63849
63717: LD_INT 4
63719: DOUBLE
63720: EQUAL
63721: IFTRUE 63725
63723: GO 63782
63725: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
63726: LD_ADDR_VAR 0 8
63730: PUSH
63731: LD_VAR 0 2
63735: PPUSH
63736: LD_INT 2
63738: PUSH
63739: LD_INT 30
63741: PUSH
63742: LD_INT 6
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: PUSH
63749: LD_INT 30
63751: PUSH
63752: LD_INT 7
63754: PUSH
63755: EMPTY
63756: LIST
63757: LIST
63758: PUSH
63759: LD_INT 30
63761: PUSH
63762: LD_INT 8
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: PPUSH
63775: CALL_OW 72
63779: ST_TO_ADDR
63780: GO 63849
63782: LD_INT 5
63784: DOUBLE
63785: EQUAL
63786: IFTRUE 63802
63788: LD_INT 8
63790: DOUBLE
63791: EQUAL
63792: IFTRUE 63802
63794: LD_INT 9
63796: DOUBLE
63797: EQUAL
63798: IFTRUE 63802
63800: GO 63848
63802: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
63803: LD_ADDR_VAR 0 8
63807: PUSH
63808: LD_VAR 0 2
63812: PPUSH
63813: LD_INT 2
63815: PUSH
63816: LD_INT 30
63818: PUSH
63819: LD_INT 4
63821: PUSH
63822: EMPTY
63823: LIST
63824: LIST
63825: PUSH
63826: LD_INT 30
63828: PUSH
63829: LD_INT 5
63831: PUSH
63832: EMPTY
63833: LIST
63834: LIST
63835: PUSH
63836: EMPTY
63837: LIST
63838: LIST
63839: LIST
63840: PPUSH
63841: CALL_OW 72
63845: ST_TO_ADDR
63846: GO 63849
63848: POP
// if not tmp then
63849: LD_VAR 0 8
63853: NOT
63854: IFFALSE 63858
// exit ;
63856: GO 64360
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
63858: LD_VAR 0 4
63862: PUSH
63863: LD_INT 1
63865: PUSH
63866: LD_INT 15
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: IN
63873: PUSH
63874: LD_EXP 23
63878: PUSH
63879: LD_VAR 0 1
63883: ARRAY
63884: AND
63885: IFFALSE 64041
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
63887: LD_ADDR_VAR 0 9
63891: PUSH
63892: LD_EXP 23
63896: PUSH
63897: LD_VAR 0 1
63901: ARRAY
63902: PUSH
63903: LD_INT 1
63905: ARRAY
63906: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
63907: LD_VAR 0 9
63911: PUSH
63912: LD_EXP 24
63916: PUSH
63917: LD_VAR 0 1
63921: ARRAY
63922: IN
63923: NOT
63924: IFFALSE 64039
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
63926: LD_ADDR_EXP 24
63930: PUSH
63931: LD_EXP 24
63935: PPUSH
63936: LD_VAR 0 1
63940: PUSH
63941: LD_EXP 24
63945: PUSH
63946: LD_VAR 0 1
63950: ARRAY
63951: PUSH
63952: LD_INT 1
63954: PLUS
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PPUSH
63960: LD_VAR 0 9
63964: PPUSH
63965: CALL 9445 0 3
63969: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
63970: LD_ADDR_EXP 23
63974: PUSH
63975: LD_EXP 23
63979: PPUSH
63980: LD_VAR 0 1
63984: PPUSH
63985: LD_EXP 23
63989: PUSH
63990: LD_VAR 0 1
63994: ARRAY
63995: PUSH
63996: LD_VAR 0 9
64000: DIFF
64001: PPUSH
64002: CALL_OW 1
64006: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
64007: LD_VAR 0 3
64011: PPUSH
64012: LD_EXP 24
64016: PUSH
64017: LD_VAR 0 1
64021: ARRAY
64022: PUSH
64023: LD_EXP 24
64027: PUSH
64028: LD_VAR 0 1
64032: ARRAY
64033: ARRAY
64034: PPUSH
64035: CALL_OW 120
// end ; exit ;
64039: GO 64360
// end ; if tmp > 1 then
64041: LD_VAR 0 8
64045: PUSH
64046: LD_INT 1
64048: GREATER
64049: IFFALSE 64153
// for i = 2 to tmp do
64051: LD_ADDR_VAR 0 6
64055: PUSH
64056: DOUBLE
64057: LD_INT 2
64059: DEC
64060: ST_TO_ADDR
64061: LD_VAR 0 8
64065: PUSH
64066: FOR_TO
64067: IFFALSE 64151
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
64069: LD_VAR 0 8
64073: PUSH
64074: LD_VAR 0 6
64078: ARRAY
64079: PPUSH
64080: CALL_OW 461
64084: PUSH
64085: LD_INT 6
64087: EQUAL
64088: IFFALSE 64149
// begin x := tmp [ i ] ;
64090: LD_ADDR_VAR 0 9
64094: PUSH
64095: LD_VAR 0 8
64099: PUSH
64100: LD_VAR 0 6
64104: ARRAY
64105: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
64106: LD_ADDR_VAR 0 8
64110: PUSH
64111: LD_VAR 0 8
64115: PPUSH
64116: LD_VAR 0 6
64120: PPUSH
64121: CALL_OW 3
64125: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
64126: LD_ADDR_VAR 0 8
64130: PUSH
64131: LD_VAR 0 8
64135: PPUSH
64136: LD_INT 1
64138: PPUSH
64139: LD_VAR 0 9
64143: PPUSH
64144: CALL_OW 2
64148: ST_TO_ADDR
// end ;
64149: GO 64066
64151: POP
64152: POP
// for i in tmp do
64153: LD_ADDR_VAR 0 6
64157: PUSH
64158: LD_VAR 0 8
64162: PUSH
64163: FOR_IN
64164: IFFALSE 64233
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
64166: LD_VAR 0 6
64170: PPUSH
64171: CALL_OW 313
64175: PUSH
64176: LD_INT 6
64178: LESS
64179: PUSH
64180: LD_VAR 0 6
64184: PPUSH
64185: CALL_OW 266
64189: PUSH
64190: LD_INT 31
64192: PUSH
64193: LD_INT 32
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: IN
64200: NOT
64201: AND
64202: PUSH
64203: LD_VAR 0 6
64207: PPUSH
64208: CALL_OW 313
64212: PUSH
64213: LD_INT 0
64215: EQUAL
64216: OR
64217: IFFALSE 64231
// begin j := i ;
64219: LD_ADDR_VAR 0 7
64223: PUSH
64224: LD_VAR 0 6
64228: ST_TO_ADDR
// break ;
64229: GO 64233
// end ; end ;
64231: GO 64163
64233: POP
64234: POP
// if j then
64235: LD_VAR 0 7
64239: IFFALSE 64257
// ComEnterUnit ( unit , j ) else
64241: LD_VAR 0 3
64245: PPUSH
64246: LD_VAR 0 7
64250: PPUSH
64251: CALL_OW 120
64255: GO 64360
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64257: LD_ADDR_VAR 0 10
64261: PUSH
64262: LD_VAR 0 2
64266: PPUSH
64267: LD_INT 2
64269: PUSH
64270: LD_INT 30
64272: PUSH
64273: LD_INT 0
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: LD_INT 30
64282: PUSH
64283: LD_INT 1
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: LIST
64294: PPUSH
64295: CALL_OW 72
64299: ST_TO_ADDR
// if depot then
64300: LD_VAR 0 10
64304: IFFALSE 64360
// begin depot := NearestUnitToUnit ( depot , unit ) ;
64306: LD_ADDR_VAR 0 10
64310: PUSH
64311: LD_VAR 0 10
64315: PPUSH
64316: LD_VAR 0 3
64320: PPUSH
64321: CALL_OW 74
64325: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
64326: LD_VAR 0 3
64330: PPUSH
64331: LD_VAR 0 10
64335: PPUSH
64336: CALL_OW 296
64340: PUSH
64341: LD_INT 10
64343: GREATER
64344: IFFALSE 64360
// ComStandNearbyBuilding ( unit , depot ) ;
64346: LD_VAR 0 3
64350: PPUSH
64351: LD_VAR 0 10
64355: PPUSH
64356: CALL 6059 0 2
// end ; end ; end ;
64360: LD_VAR 0 5
64364: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
64365: LD_INT 0
64367: PPUSH
64368: PPUSH
64369: PPUSH
64370: PPUSH
// if not mc_bases then
64371: LD_EXP 14
64375: NOT
64376: IFFALSE 64380
// exit ;
64378: GO 64619
// for i = 1 to mc_bases do
64380: LD_ADDR_VAR 0 2
64384: PUSH
64385: DOUBLE
64386: LD_INT 1
64388: DEC
64389: ST_TO_ADDR
64390: LD_EXP 14
64394: PUSH
64395: FOR_TO
64396: IFFALSE 64617
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
64398: LD_ADDR_VAR 0 4
64402: PUSH
64403: LD_EXP 14
64407: PUSH
64408: LD_VAR 0 2
64412: ARRAY
64413: PPUSH
64414: LD_INT 21
64416: PUSH
64417: LD_INT 1
64419: PUSH
64420: EMPTY
64421: LIST
64422: LIST
64423: PPUSH
64424: CALL_OW 72
64428: PUSH
64429: LD_EXP 43
64433: PUSH
64434: LD_VAR 0 2
64438: ARRAY
64439: UNION
64440: ST_TO_ADDR
// if not tmp then
64441: LD_VAR 0 4
64445: NOT
64446: IFFALSE 64450
// continue ;
64448: GO 64395
// for j in tmp do
64450: LD_ADDR_VAR 0 3
64454: PUSH
64455: LD_VAR 0 4
64459: PUSH
64460: FOR_IN
64461: IFFALSE 64613
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
64463: LD_VAR 0 3
64467: PPUSH
64468: CALL_OW 110
64472: NOT
64473: PUSH
64474: LD_VAR 0 3
64478: PPUSH
64479: CALL_OW 314
64483: NOT
64484: AND
64485: PUSH
64486: LD_VAR 0 3
64490: PPUSH
64491: CALL_OW 311
64495: NOT
64496: AND
64497: PUSH
64498: LD_VAR 0 3
64502: PPUSH
64503: CALL_OW 310
64507: NOT
64508: AND
64509: PUSH
64510: LD_VAR 0 3
64514: PUSH
64515: LD_EXP 17
64519: PUSH
64520: LD_VAR 0 2
64524: ARRAY
64525: PUSH
64526: LD_INT 1
64528: ARRAY
64529: IN
64530: NOT
64531: AND
64532: PUSH
64533: LD_VAR 0 3
64537: PUSH
64538: LD_EXP 17
64542: PUSH
64543: LD_VAR 0 2
64547: ARRAY
64548: PUSH
64549: LD_INT 2
64551: ARRAY
64552: IN
64553: NOT
64554: AND
64555: PUSH
64556: LD_VAR 0 3
64560: PUSH
64561: LD_EXP 26
64565: PUSH
64566: LD_VAR 0 2
64570: ARRAY
64571: IN
64572: NOT
64573: AND
64574: IFFALSE 64611
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
64576: LD_VAR 0 2
64580: PPUSH
64581: LD_EXP 14
64585: PUSH
64586: LD_VAR 0 2
64590: ARRAY
64591: PPUSH
64592: LD_VAR 0 3
64596: PPUSH
64597: LD_VAR 0 3
64601: PPUSH
64602: CALL_OW 257
64606: PPUSH
64607: CALL 63383 0 4
// end ;
64611: GO 64460
64613: POP
64614: POP
// end ;
64615: GO 64395
64617: POP
64618: POP
// end ;
64619: LD_VAR 0 1
64623: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
64624: LD_INT 0
64626: PPUSH
64627: PPUSH
64628: PPUSH
64629: PPUSH
64630: PPUSH
64631: PPUSH
// if not mc_bases [ base ] then
64632: LD_EXP 14
64636: PUSH
64637: LD_VAR 0 1
64641: ARRAY
64642: NOT
64643: IFFALSE 64647
// exit ;
64645: GO 64829
// tmp := [ ] ;
64647: LD_ADDR_VAR 0 6
64651: PUSH
64652: EMPTY
64653: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
64654: LD_ADDR_VAR 0 7
64658: PUSH
64659: LD_VAR 0 3
64663: PPUSH
64664: LD_INT 0
64666: PPUSH
64667: CALL_OW 517
64671: ST_TO_ADDR
// if not list then
64672: LD_VAR 0 7
64676: NOT
64677: IFFALSE 64681
// exit ;
64679: GO 64829
// for i = 1 to amount do
64681: LD_ADDR_VAR 0 5
64685: PUSH
64686: DOUBLE
64687: LD_INT 1
64689: DEC
64690: ST_TO_ADDR
64691: LD_VAR 0 2
64695: PUSH
64696: FOR_TO
64697: IFFALSE 64777
// begin x := rand ( 1 , list [ 1 ] ) ;
64699: LD_ADDR_VAR 0 8
64703: PUSH
64704: LD_INT 1
64706: PPUSH
64707: LD_VAR 0 7
64711: PUSH
64712: LD_INT 1
64714: ARRAY
64715: PPUSH
64716: CALL_OW 12
64720: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
64721: LD_ADDR_VAR 0 6
64725: PUSH
64726: LD_VAR 0 6
64730: PPUSH
64731: LD_VAR 0 5
64735: PPUSH
64736: LD_VAR 0 7
64740: PUSH
64741: LD_INT 1
64743: ARRAY
64744: PUSH
64745: LD_VAR 0 8
64749: ARRAY
64750: PUSH
64751: LD_VAR 0 7
64755: PUSH
64756: LD_INT 2
64758: ARRAY
64759: PUSH
64760: LD_VAR 0 8
64764: ARRAY
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PPUSH
64770: CALL_OW 1
64774: ST_TO_ADDR
// end ;
64775: GO 64696
64777: POP
64778: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
64779: LD_ADDR_EXP 27
64783: PUSH
64784: LD_EXP 27
64788: PPUSH
64789: LD_VAR 0 1
64793: PPUSH
64794: LD_VAR 0 6
64798: PPUSH
64799: CALL_OW 1
64803: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
64804: LD_ADDR_EXP 29
64808: PUSH
64809: LD_EXP 29
64813: PPUSH
64814: LD_VAR 0 1
64818: PPUSH
64819: LD_VAR 0 3
64823: PPUSH
64824: CALL_OW 1
64828: ST_TO_ADDR
// end ;
64829: LD_VAR 0 4
64833: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
64834: LD_INT 0
64836: PPUSH
// if not mc_bases [ base ] then
64837: LD_EXP 14
64841: PUSH
64842: LD_VAR 0 1
64846: ARRAY
64847: NOT
64848: IFFALSE 64852
// exit ;
64850: GO 64877
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
64852: LD_ADDR_EXP 19
64856: PUSH
64857: LD_EXP 19
64861: PPUSH
64862: LD_VAR 0 1
64866: PPUSH
64867: LD_VAR 0 2
64871: PPUSH
64872: CALL_OW 1
64876: ST_TO_ADDR
// end ;
64877: LD_VAR 0 3
64881: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
64882: LD_INT 0
64884: PPUSH
// if not mc_bases [ base ] then
64885: LD_EXP 14
64889: PUSH
64890: LD_VAR 0 1
64894: ARRAY
64895: NOT
64896: IFFALSE 64900
// exit ;
64898: GO 64937
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
64900: LD_ADDR_EXP 19
64904: PUSH
64905: LD_EXP 19
64909: PPUSH
64910: LD_VAR 0 1
64914: PPUSH
64915: LD_EXP 19
64919: PUSH
64920: LD_VAR 0 1
64924: ARRAY
64925: PUSH
64926: LD_VAR 0 2
64930: UNION
64931: PPUSH
64932: CALL_OW 1
64936: ST_TO_ADDR
// end ;
64937: LD_VAR 0 3
64941: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
64942: LD_INT 0
64944: PPUSH
// if not mc_bases [ base ] then
64945: LD_EXP 14
64949: PUSH
64950: LD_VAR 0 1
64954: ARRAY
64955: NOT
64956: IFFALSE 64960
// exit ;
64958: GO 64985
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
64960: LD_ADDR_EXP 35
64964: PUSH
64965: LD_EXP 35
64969: PPUSH
64970: LD_VAR 0 1
64974: PPUSH
64975: LD_VAR 0 2
64979: PPUSH
64980: CALL_OW 1
64984: ST_TO_ADDR
// end ;
64985: LD_VAR 0 3
64989: RET
// export function MC_InsertProduceList ( base , components ) ; begin
64990: LD_INT 0
64992: PPUSH
// if not mc_bases [ base ] then
64993: LD_EXP 14
64997: PUSH
64998: LD_VAR 0 1
65002: ARRAY
65003: NOT
65004: IFFALSE 65008
// exit ;
65006: GO 65045
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
65008: LD_ADDR_EXP 35
65012: PUSH
65013: LD_EXP 35
65017: PPUSH
65018: LD_VAR 0 1
65022: PPUSH
65023: LD_EXP 35
65027: PUSH
65028: LD_VAR 0 1
65032: ARRAY
65033: PUSH
65034: LD_VAR 0 2
65038: ADD
65039: PPUSH
65040: CALL_OW 1
65044: ST_TO_ADDR
// end ;
65045: LD_VAR 0 3
65049: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
65050: LD_INT 0
65052: PPUSH
// if not mc_bases [ base ] then
65053: LD_EXP 14
65057: PUSH
65058: LD_VAR 0 1
65062: ARRAY
65063: NOT
65064: IFFALSE 65068
// exit ;
65066: GO 65122
// mc_defender := Replace ( mc_defender , base , deflist ) ;
65068: LD_ADDR_EXP 36
65072: PUSH
65073: LD_EXP 36
65077: PPUSH
65078: LD_VAR 0 1
65082: PPUSH
65083: LD_VAR 0 2
65087: PPUSH
65088: CALL_OW 1
65092: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
65093: LD_ADDR_EXP 25
65097: PUSH
65098: LD_EXP 25
65102: PPUSH
65103: LD_VAR 0 1
65107: PPUSH
65108: LD_VAR 0 2
65112: PUSH
65113: LD_INT 0
65115: PLUS
65116: PPUSH
65117: CALL_OW 1
65121: ST_TO_ADDR
// end ;
65122: LD_VAR 0 3
65126: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
65127: LD_INT 0
65129: PPUSH
// if not mc_bases [ base ] then
65130: LD_EXP 14
65134: PUSH
65135: LD_VAR 0 1
65139: ARRAY
65140: NOT
65141: IFFALSE 65145
// exit ;
65143: GO 65170
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
65145: LD_ADDR_EXP 25
65149: PUSH
65150: LD_EXP 25
65154: PPUSH
65155: LD_VAR 0 1
65159: PPUSH
65160: LD_VAR 0 2
65164: PPUSH
65165: CALL_OW 1
65169: ST_TO_ADDR
// end ;
65170: LD_VAR 0 3
65174: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
65175: LD_INT 0
65177: PPUSH
65178: PPUSH
65179: PPUSH
65180: PPUSH
// if not mc_bases [ base ] then
65181: LD_EXP 14
65185: PUSH
65186: LD_VAR 0 1
65190: ARRAY
65191: NOT
65192: IFFALSE 65196
// exit ;
65194: GO 65261
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
65196: LD_ADDR_EXP 34
65200: PUSH
65201: LD_EXP 34
65205: PPUSH
65206: LD_VAR 0 1
65210: PUSH
65211: LD_EXP 34
65215: PUSH
65216: LD_VAR 0 1
65220: ARRAY
65221: PUSH
65222: LD_INT 1
65224: PLUS
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PPUSH
65230: LD_VAR 0 1
65234: PUSH
65235: LD_VAR 0 2
65239: PUSH
65240: LD_VAR 0 3
65244: PUSH
65245: LD_VAR 0 4
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: PPUSH
65256: CALL 9445 0 3
65260: ST_TO_ADDR
// end ;
65261: LD_VAR 0 5
65265: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
65266: LD_INT 0
65268: PPUSH
// if not mc_bases [ base ] then
65269: LD_EXP 14
65273: PUSH
65274: LD_VAR 0 1
65278: ARRAY
65279: NOT
65280: IFFALSE 65284
// exit ;
65282: GO 65309
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
65284: LD_ADDR_EXP 51
65288: PUSH
65289: LD_EXP 51
65293: PPUSH
65294: LD_VAR 0 1
65298: PPUSH
65299: LD_VAR 0 2
65303: PPUSH
65304: CALL_OW 1
65308: ST_TO_ADDR
// end ;
65309: LD_VAR 0 3
65313: RET
// export function MC_GetMinesField ( base ) ; begin
65314: LD_INT 0
65316: PPUSH
// result := mc_mines [ base ] ;
65317: LD_ADDR_VAR 0 2
65321: PUSH
65322: LD_EXP 27
65326: PUSH
65327: LD_VAR 0 1
65331: ARRAY
65332: ST_TO_ADDR
// end ;
65333: LD_VAR 0 2
65337: RET
// export function MC_GetProduceList ( base ) ; begin
65338: LD_INT 0
65340: PPUSH
// result := mc_produce [ base ] ;
65341: LD_ADDR_VAR 0 2
65345: PUSH
65346: LD_EXP 35
65350: PUSH
65351: LD_VAR 0 1
65355: ARRAY
65356: ST_TO_ADDR
// end ;
65357: LD_VAR 0 2
65361: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
65362: LD_INT 0
65364: PPUSH
65365: PPUSH
// if not mc_bases then
65366: LD_EXP 14
65370: NOT
65371: IFFALSE 65375
// exit ;
65373: GO 65440
// if mc_bases [ base ] then
65375: LD_EXP 14
65379: PUSH
65380: LD_VAR 0 1
65384: ARRAY
65385: IFFALSE 65440
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65387: LD_ADDR_VAR 0 3
65391: PUSH
65392: LD_EXP 14
65396: PUSH
65397: LD_VAR 0 1
65401: ARRAY
65402: PPUSH
65403: LD_INT 30
65405: PUSH
65406: LD_VAR 0 2
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PPUSH
65415: CALL_OW 72
65419: ST_TO_ADDR
// if result then
65420: LD_VAR 0 3
65424: IFFALSE 65440
// result := result [ 1 ] ;
65426: LD_ADDR_VAR 0 3
65430: PUSH
65431: LD_VAR 0 3
65435: PUSH
65436: LD_INT 1
65438: ARRAY
65439: ST_TO_ADDR
// end ; end ;
65440: LD_VAR 0 3
65444: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
65445: LD_INT 0
65447: PPUSH
65448: PPUSH
// if not mc_bases then
65449: LD_EXP 14
65453: NOT
65454: IFFALSE 65458
// exit ;
65456: GO 65503
// if mc_bases [ base ] then
65458: LD_EXP 14
65462: PUSH
65463: LD_VAR 0 1
65467: ARRAY
65468: IFFALSE 65503
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65470: LD_ADDR_VAR 0 3
65474: PUSH
65475: LD_EXP 14
65479: PUSH
65480: LD_VAR 0 1
65484: ARRAY
65485: PPUSH
65486: LD_INT 30
65488: PUSH
65489: LD_VAR 0 2
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PPUSH
65498: CALL_OW 72
65502: ST_TO_ADDR
// end ;
65503: LD_VAR 0 3
65507: RET
// export function MC_SetTame ( base , area ) ; begin
65508: LD_INT 0
65510: PPUSH
// if not mc_bases or not base then
65511: LD_EXP 14
65515: NOT
65516: PUSH
65517: LD_VAR 0 1
65521: NOT
65522: OR
65523: IFFALSE 65527
// exit ;
65525: GO 65552
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
65527: LD_ADDR_EXP 42
65531: PUSH
65532: LD_EXP 42
65536: PPUSH
65537: LD_VAR 0 1
65541: PPUSH
65542: LD_VAR 0 2
65546: PPUSH
65547: CALL_OW 1
65551: ST_TO_ADDR
// end ;
65552: LD_VAR 0 3
65556: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
65557: LD_INT 0
65559: PPUSH
65560: PPUSH
// if not mc_bases or not base then
65561: LD_EXP 14
65565: NOT
65566: PUSH
65567: LD_VAR 0 1
65571: NOT
65572: OR
65573: IFFALSE 65577
// exit ;
65575: GO 65679
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65577: LD_ADDR_VAR 0 4
65581: PUSH
65582: LD_EXP 14
65586: PUSH
65587: LD_VAR 0 1
65591: ARRAY
65592: PPUSH
65593: LD_INT 30
65595: PUSH
65596: LD_VAR 0 2
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PPUSH
65605: CALL_OW 72
65609: ST_TO_ADDR
// if not tmp then
65610: LD_VAR 0 4
65614: NOT
65615: IFFALSE 65619
// exit ;
65617: GO 65679
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
65619: LD_ADDR_EXP 46
65623: PUSH
65624: LD_EXP 46
65628: PPUSH
65629: LD_VAR 0 1
65633: PPUSH
65634: LD_EXP 46
65638: PUSH
65639: LD_VAR 0 1
65643: ARRAY
65644: PPUSH
65645: LD_EXP 46
65649: PUSH
65650: LD_VAR 0 1
65654: ARRAY
65655: PUSH
65656: LD_INT 1
65658: PLUS
65659: PPUSH
65660: LD_VAR 0 4
65664: PUSH
65665: LD_INT 1
65667: ARRAY
65668: PPUSH
65669: CALL_OW 2
65673: PPUSH
65674: CALL_OW 1
65678: ST_TO_ADDR
// end ;
65679: LD_VAR 0 3
65683: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
65684: LD_INT 0
65686: PPUSH
65687: PPUSH
// if not mc_bases or not base or not kinds then
65688: LD_EXP 14
65692: NOT
65693: PUSH
65694: LD_VAR 0 1
65698: NOT
65699: OR
65700: PUSH
65701: LD_VAR 0 2
65705: NOT
65706: OR
65707: IFFALSE 65711
// exit ;
65709: GO 65772
// for i in kinds do
65711: LD_ADDR_VAR 0 4
65715: PUSH
65716: LD_VAR 0 2
65720: PUSH
65721: FOR_IN
65722: IFFALSE 65770
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
65724: LD_ADDR_EXP 48
65728: PUSH
65729: LD_EXP 48
65733: PPUSH
65734: LD_VAR 0 1
65738: PUSH
65739: LD_EXP 48
65743: PUSH
65744: LD_VAR 0 1
65748: ARRAY
65749: PUSH
65750: LD_INT 1
65752: PLUS
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PPUSH
65758: LD_VAR 0 4
65762: PPUSH
65763: CALL 9445 0 3
65767: ST_TO_ADDR
65768: GO 65721
65770: POP
65771: POP
// end ;
65772: LD_VAR 0 3
65776: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
65777: LD_INT 0
65779: PPUSH
// if not mc_bases or not base or not areas then
65780: LD_EXP 14
65784: NOT
65785: PUSH
65786: LD_VAR 0 1
65790: NOT
65791: OR
65792: PUSH
65793: LD_VAR 0 2
65797: NOT
65798: OR
65799: IFFALSE 65803
// exit ;
65801: GO 65828
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
65803: LD_ADDR_EXP 32
65807: PUSH
65808: LD_EXP 32
65812: PPUSH
65813: LD_VAR 0 1
65817: PPUSH
65818: LD_VAR 0 2
65822: PPUSH
65823: CALL_OW 1
65827: ST_TO_ADDR
// end ;
65828: LD_VAR 0 3
65832: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
65833: LD_INT 0
65835: PPUSH
// if not mc_bases or not base or not teleports_exit then
65836: LD_EXP 14
65840: NOT
65841: PUSH
65842: LD_VAR 0 1
65846: NOT
65847: OR
65848: PUSH
65849: LD_VAR 0 2
65853: NOT
65854: OR
65855: IFFALSE 65859
// exit ;
65857: GO 65884
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
65859: LD_ADDR_EXP 49
65863: PUSH
65864: LD_EXP 49
65868: PPUSH
65869: LD_VAR 0 1
65873: PPUSH
65874: LD_VAR 0 2
65878: PPUSH
65879: CALL_OW 1
65883: ST_TO_ADDR
// end ;
65884: LD_VAR 0 3
65888: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
65889: LD_INT 0
65891: PPUSH
65892: PPUSH
65893: PPUSH
// if not mc_bases or not base or not ext_list then
65894: LD_EXP 14
65898: NOT
65899: PUSH
65900: LD_VAR 0 1
65904: NOT
65905: OR
65906: PUSH
65907: LD_VAR 0 5
65911: NOT
65912: OR
65913: IFFALSE 65917
// exit ;
65915: GO 66090
// tmp := GetFacExtXYD ( x , y , d ) ;
65917: LD_ADDR_VAR 0 8
65921: PUSH
65922: LD_VAR 0 2
65926: PPUSH
65927: LD_VAR 0 3
65931: PPUSH
65932: LD_VAR 0 4
65936: PPUSH
65937: CALL 38124 0 3
65941: ST_TO_ADDR
// if not tmp then
65942: LD_VAR 0 8
65946: NOT
65947: IFFALSE 65951
// exit ;
65949: GO 66090
// for i in tmp do
65951: LD_ADDR_VAR 0 7
65955: PUSH
65956: LD_VAR 0 8
65960: PUSH
65961: FOR_IN
65962: IFFALSE 66088
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
65964: LD_ADDR_EXP 19
65968: PUSH
65969: LD_EXP 19
65973: PPUSH
65974: LD_VAR 0 1
65978: PPUSH
65979: LD_EXP 19
65983: PUSH
65984: LD_VAR 0 1
65988: ARRAY
65989: PPUSH
65990: LD_EXP 19
65994: PUSH
65995: LD_VAR 0 1
65999: ARRAY
66000: PUSH
66001: LD_INT 1
66003: PLUS
66004: PPUSH
66005: LD_VAR 0 5
66009: PUSH
66010: LD_INT 1
66012: ARRAY
66013: PUSH
66014: LD_VAR 0 7
66018: PUSH
66019: LD_INT 1
66021: ARRAY
66022: PUSH
66023: LD_VAR 0 7
66027: PUSH
66028: LD_INT 2
66030: ARRAY
66031: PUSH
66032: LD_VAR 0 7
66036: PUSH
66037: LD_INT 3
66039: ARRAY
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: PPUSH
66047: CALL_OW 2
66051: PPUSH
66052: CALL_OW 1
66056: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
66057: LD_ADDR_VAR 0 5
66061: PUSH
66062: LD_VAR 0 5
66066: PPUSH
66067: LD_INT 1
66069: PPUSH
66070: CALL_OW 3
66074: ST_TO_ADDR
// if not ext_list then
66075: LD_VAR 0 5
66079: NOT
66080: IFFALSE 66086
// exit ;
66082: POP
66083: POP
66084: GO 66090
// end ;
66086: GO 65961
66088: POP
66089: POP
// end ;
66090: LD_VAR 0 6
66094: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
66095: LD_INT 0
66097: PPUSH
// if not mc_bases or not base or not weapon_list then
66098: LD_EXP 14
66102: NOT
66103: PUSH
66104: LD_VAR 0 1
66108: NOT
66109: OR
66110: PUSH
66111: LD_VAR 0 2
66115: NOT
66116: OR
66117: IFFALSE 66121
// exit ;
66119: GO 66146
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
66121: LD_ADDR_EXP 53
66125: PUSH
66126: LD_EXP 53
66130: PPUSH
66131: LD_VAR 0 1
66135: PPUSH
66136: LD_VAR 0 2
66140: PPUSH
66141: CALL_OW 1
66145: ST_TO_ADDR
// end ;
66146: LD_VAR 0 3
66150: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
66151: LD_INT 0
66153: PPUSH
// if not mc_bases or not base or not tech_list then
66154: LD_EXP 14
66158: NOT
66159: PUSH
66160: LD_VAR 0 1
66164: NOT
66165: OR
66166: PUSH
66167: LD_VAR 0 2
66171: NOT
66172: OR
66173: IFFALSE 66177
// exit ;
66175: GO 66202
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
66177: LD_ADDR_EXP 41
66181: PUSH
66182: LD_EXP 41
66186: PPUSH
66187: LD_VAR 0 1
66191: PPUSH
66192: LD_VAR 0 2
66196: PPUSH
66197: CALL_OW 1
66201: ST_TO_ADDR
// end ;
66202: LD_VAR 0 3
66206: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
66207: LD_INT 0
66209: PPUSH
// if not mc_bases or not parking_area or not base then
66210: LD_EXP 14
66214: NOT
66215: PUSH
66216: LD_VAR 0 2
66220: NOT
66221: OR
66222: PUSH
66223: LD_VAR 0 1
66227: NOT
66228: OR
66229: IFFALSE 66233
// exit ;
66231: GO 66258
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
66233: LD_ADDR_EXP 38
66237: PUSH
66238: LD_EXP 38
66242: PPUSH
66243: LD_VAR 0 1
66247: PPUSH
66248: LD_VAR 0 2
66252: PPUSH
66253: CALL_OW 1
66257: ST_TO_ADDR
// end ;
66258: LD_VAR 0 3
66262: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
66263: LD_INT 0
66265: PPUSH
// if not mc_bases or not base or not scan_area then
66266: LD_EXP 14
66270: NOT
66271: PUSH
66272: LD_VAR 0 1
66276: NOT
66277: OR
66278: PUSH
66279: LD_VAR 0 2
66283: NOT
66284: OR
66285: IFFALSE 66289
// exit ;
66287: GO 66314
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
66289: LD_ADDR_EXP 39
66293: PUSH
66294: LD_EXP 39
66298: PPUSH
66299: LD_VAR 0 1
66303: PPUSH
66304: LD_VAR 0 2
66308: PPUSH
66309: CALL_OW 1
66313: ST_TO_ADDR
// end ;
66314: LD_VAR 0 3
66318: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
66319: LD_INT 0
66321: PPUSH
66322: PPUSH
// if not mc_bases or not base then
66323: LD_EXP 14
66327: NOT
66328: PUSH
66329: LD_VAR 0 1
66333: NOT
66334: OR
66335: IFFALSE 66339
// exit ;
66337: GO 66403
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
66339: LD_ADDR_VAR 0 3
66343: PUSH
66344: LD_INT 1
66346: PUSH
66347: LD_INT 2
66349: PUSH
66350: LD_INT 3
66352: PUSH
66353: LD_INT 4
66355: PUSH
66356: LD_INT 11
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
66366: LD_ADDR_EXP 41
66370: PUSH
66371: LD_EXP 41
66375: PPUSH
66376: LD_VAR 0 1
66380: PPUSH
66381: LD_EXP 41
66385: PUSH
66386: LD_VAR 0 1
66390: ARRAY
66391: PUSH
66392: LD_VAR 0 3
66396: DIFF
66397: PPUSH
66398: CALL_OW 1
66402: ST_TO_ADDR
// end ;
66403: LD_VAR 0 2
66407: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
66408: LD_INT 0
66410: PPUSH
// result := mc_vehicles [ base ] ;
66411: LD_ADDR_VAR 0 3
66415: PUSH
66416: LD_EXP 33
66420: PUSH
66421: LD_VAR 0 1
66425: ARRAY
66426: ST_TO_ADDR
// if onlyCombat then
66427: LD_VAR 0 2
66431: IFFALSE 66596
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
66433: LD_ADDR_VAR 0 3
66437: PUSH
66438: LD_VAR 0 3
66442: PUSH
66443: LD_VAR 0 3
66447: PPUSH
66448: LD_INT 2
66450: PUSH
66451: LD_INT 34
66453: PUSH
66454: LD_INT 12
66456: PUSH
66457: EMPTY
66458: LIST
66459: LIST
66460: PUSH
66461: LD_INT 34
66463: PUSH
66464: LD_INT 51
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PUSH
66471: LD_INT 34
66473: PUSH
66474: LD_EXP 58
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 34
66485: PUSH
66486: LD_INT 32
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 34
66495: PUSH
66496: LD_INT 13
66498: PUSH
66499: EMPTY
66500: LIST
66501: LIST
66502: PUSH
66503: LD_INT 34
66505: PUSH
66506: LD_INT 52
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: LD_INT 34
66515: PUSH
66516: LD_INT 14
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 34
66525: PUSH
66526: LD_INT 53
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: PUSH
66533: LD_INT 34
66535: PUSH
66536: LD_EXP 57
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 34
66547: PUSH
66548: LD_INT 31
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 34
66557: PUSH
66558: LD_INT 48
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 34
66567: PUSH
66568: LD_INT 8
66570: PUSH
66571: EMPTY
66572: LIST
66573: LIST
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: LIST
66579: LIST
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: PPUSH
66590: CALL_OW 72
66594: DIFF
66595: ST_TO_ADDR
// end ; end_of_file
66596: LD_VAR 0 3
66600: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
66601: LD_INT 0
66603: PPUSH
66604: PPUSH
66605: PPUSH
// if not mc_bases or not skirmish then
66606: LD_EXP 14
66610: NOT
66611: PUSH
66612: LD_EXP 12
66616: NOT
66617: OR
66618: IFFALSE 66622
// exit ;
66620: GO 66787
// for i = 1 to mc_bases do
66622: LD_ADDR_VAR 0 4
66626: PUSH
66627: DOUBLE
66628: LD_INT 1
66630: DEC
66631: ST_TO_ADDR
66632: LD_EXP 14
66636: PUSH
66637: FOR_TO
66638: IFFALSE 66785
// begin if sci in mc_bases [ i ] then
66640: LD_VAR 0 2
66644: PUSH
66645: LD_EXP 14
66649: PUSH
66650: LD_VAR 0 4
66654: ARRAY
66655: IN
66656: IFFALSE 66783
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
66658: LD_ADDR_EXP 43
66662: PUSH
66663: LD_EXP 43
66667: PPUSH
66668: LD_VAR 0 4
66672: PUSH
66673: LD_EXP 43
66677: PUSH
66678: LD_VAR 0 4
66682: ARRAY
66683: PUSH
66684: LD_INT 1
66686: PLUS
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: PPUSH
66692: LD_VAR 0 1
66696: PPUSH
66697: CALL 9445 0 3
66701: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
66702: LD_ADDR_VAR 0 5
66706: PUSH
66707: LD_EXP 14
66711: PUSH
66712: LD_VAR 0 4
66716: ARRAY
66717: PPUSH
66718: LD_INT 2
66720: PUSH
66721: LD_INT 30
66723: PUSH
66724: LD_INT 0
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 30
66733: PUSH
66734: LD_INT 1
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: LIST
66745: PPUSH
66746: CALL_OW 72
66750: PPUSH
66751: LD_VAR 0 1
66755: PPUSH
66756: CALL_OW 74
66760: ST_TO_ADDR
// if tmp then
66761: LD_VAR 0 5
66765: IFFALSE 66781
// ComStandNearbyBuilding ( ape , tmp ) ;
66767: LD_VAR 0 1
66771: PPUSH
66772: LD_VAR 0 5
66776: PPUSH
66777: CALL 6059 0 2
// break ;
66781: GO 66785
// end ; end ;
66783: GO 66637
66785: POP
66786: POP
// end ;
66787: LD_VAR 0 3
66791: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
66792: LD_INT 0
66794: PPUSH
66795: PPUSH
66796: PPUSH
// if not mc_bases or not skirmish then
66797: LD_EXP 14
66801: NOT
66802: PUSH
66803: LD_EXP 12
66807: NOT
66808: OR
66809: IFFALSE 66813
// exit ;
66811: GO 66902
// for i = 1 to mc_bases do
66813: LD_ADDR_VAR 0 4
66817: PUSH
66818: DOUBLE
66819: LD_INT 1
66821: DEC
66822: ST_TO_ADDR
66823: LD_EXP 14
66827: PUSH
66828: FOR_TO
66829: IFFALSE 66900
// begin if building in mc_busy_turret_list [ i ] then
66831: LD_VAR 0 1
66835: PUSH
66836: LD_EXP 24
66840: PUSH
66841: LD_VAR 0 4
66845: ARRAY
66846: IN
66847: IFFALSE 66898
// begin tmp := mc_busy_turret_list [ i ] diff building ;
66849: LD_ADDR_VAR 0 5
66853: PUSH
66854: LD_EXP 24
66858: PUSH
66859: LD_VAR 0 4
66863: ARRAY
66864: PUSH
66865: LD_VAR 0 1
66869: DIFF
66870: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
66871: LD_ADDR_EXP 24
66875: PUSH
66876: LD_EXP 24
66880: PPUSH
66881: LD_VAR 0 4
66885: PPUSH
66886: LD_VAR 0 5
66890: PPUSH
66891: CALL_OW 1
66895: ST_TO_ADDR
// break ;
66896: GO 66900
// end ; end ;
66898: GO 66828
66900: POP
66901: POP
// end ;
66902: LD_VAR 0 3
66906: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
66907: LD_INT 0
66909: PPUSH
66910: PPUSH
66911: PPUSH
// if not mc_bases or not skirmish then
66912: LD_EXP 14
66916: NOT
66917: PUSH
66918: LD_EXP 12
66922: NOT
66923: OR
66924: IFFALSE 66928
// exit ;
66926: GO 67127
// for i = 1 to mc_bases do
66928: LD_ADDR_VAR 0 5
66932: PUSH
66933: DOUBLE
66934: LD_INT 1
66936: DEC
66937: ST_TO_ADDR
66938: LD_EXP 14
66942: PUSH
66943: FOR_TO
66944: IFFALSE 67125
// if building in mc_bases [ i ] then
66946: LD_VAR 0 1
66950: PUSH
66951: LD_EXP 14
66955: PUSH
66956: LD_VAR 0 5
66960: ARRAY
66961: IN
66962: IFFALSE 67123
// begin tmp := mc_bases [ i ] diff building ;
66964: LD_ADDR_VAR 0 6
66968: PUSH
66969: LD_EXP 14
66973: PUSH
66974: LD_VAR 0 5
66978: ARRAY
66979: PUSH
66980: LD_VAR 0 1
66984: DIFF
66985: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
66986: LD_ADDR_EXP 14
66990: PUSH
66991: LD_EXP 14
66995: PPUSH
66996: LD_VAR 0 5
67000: PPUSH
67001: LD_VAR 0 6
67005: PPUSH
67006: CALL_OW 1
67010: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
67011: LD_VAR 0 1
67015: PUSH
67016: LD_EXP 22
67020: PUSH
67021: LD_VAR 0 5
67025: ARRAY
67026: IN
67027: IFFALSE 67066
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
67029: LD_ADDR_EXP 22
67033: PUSH
67034: LD_EXP 22
67038: PPUSH
67039: LD_VAR 0 5
67043: PPUSH
67044: LD_EXP 22
67048: PUSH
67049: LD_VAR 0 5
67053: ARRAY
67054: PUSH
67055: LD_VAR 0 1
67059: DIFF
67060: PPUSH
67061: CALL_OW 1
67065: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
67066: LD_VAR 0 1
67070: PUSH
67071: LD_EXP 23
67075: PUSH
67076: LD_VAR 0 5
67080: ARRAY
67081: IN
67082: IFFALSE 67121
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
67084: LD_ADDR_EXP 23
67088: PUSH
67089: LD_EXP 23
67093: PPUSH
67094: LD_VAR 0 5
67098: PPUSH
67099: LD_EXP 23
67103: PUSH
67104: LD_VAR 0 5
67108: ARRAY
67109: PUSH
67110: LD_VAR 0 1
67114: DIFF
67115: PPUSH
67116: CALL_OW 1
67120: ST_TO_ADDR
// break ;
67121: GO 67125
// end ;
67123: GO 66943
67125: POP
67126: POP
// end ;
67127: LD_VAR 0 4
67131: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
67132: LD_INT 0
67134: PPUSH
67135: PPUSH
67136: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
67137: LD_EXP 14
67141: NOT
67142: PUSH
67143: LD_EXP 12
67147: NOT
67148: OR
67149: PUSH
67150: LD_VAR 0 3
67154: PUSH
67155: LD_EXP 40
67159: IN
67160: NOT
67161: OR
67162: IFFALSE 67166
// exit ;
67164: GO 67289
// for i = 1 to mc_vehicles do
67166: LD_ADDR_VAR 0 6
67170: PUSH
67171: DOUBLE
67172: LD_INT 1
67174: DEC
67175: ST_TO_ADDR
67176: LD_EXP 33
67180: PUSH
67181: FOR_TO
67182: IFFALSE 67287
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
67184: LD_VAR 0 2
67188: PUSH
67189: LD_EXP 33
67193: PUSH
67194: LD_VAR 0 6
67198: ARRAY
67199: IN
67200: PUSH
67201: LD_VAR 0 1
67205: PUSH
67206: LD_EXP 33
67210: PUSH
67211: LD_VAR 0 6
67215: ARRAY
67216: IN
67217: OR
67218: IFFALSE 67285
// begin tmp := mc_vehicles [ i ] diff old ;
67220: LD_ADDR_VAR 0 7
67224: PUSH
67225: LD_EXP 33
67229: PUSH
67230: LD_VAR 0 6
67234: ARRAY
67235: PUSH
67236: LD_VAR 0 2
67240: DIFF
67241: ST_TO_ADDR
// tmp := tmp diff new ;
67242: LD_ADDR_VAR 0 7
67246: PUSH
67247: LD_VAR 0 7
67251: PUSH
67252: LD_VAR 0 1
67256: DIFF
67257: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
67258: LD_ADDR_EXP 33
67262: PUSH
67263: LD_EXP 33
67267: PPUSH
67268: LD_VAR 0 6
67272: PPUSH
67273: LD_VAR 0 7
67277: PPUSH
67278: CALL_OW 1
67282: ST_TO_ADDR
// break ;
67283: GO 67287
// end ;
67285: GO 67181
67287: POP
67288: POP
// end ;
67289: LD_VAR 0 5
67293: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
67294: LD_INT 0
67296: PPUSH
67297: PPUSH
67298: PPUSH
67299: PPUSH
// if not mc_bases or not skirmish then
67300: LD_EXP 14
67304: NOT
67305: PUSH
67306: LD_EXP 12
67310: NOT
67311: OR
67312: IFFALSE 67316
// exit ;
67314: GO 67693
// side := GetSide ( vehicle ) ;
67316: LD_ADDR_VAR 0 5
67320: PUSH
67321: LD_VAR 0 1
67325: PPUSH
67326: CALL_OW 255
67330: ST_TO_ADDR
// for i = 1 to mc_bases do
67331: LD_ADDR_VAR 0 4
67335: PUSH
67336: DOUBLE
67337: LD_INT 1
67339: DEC
67340: ST_TO_ADDR
67341: LD_EXP 14
67345: PUSH
67346: FOR_TO
67347: IFFALSE 67691
// begin if factory in mc_bases [ i ] then
67349: LD_VAR 0 2
67353: PUSH
67354: LD_EXP 14
67358: PUSH
67359: LD_VAR 0 4
67363: ARRAY
67364: IN
67365: IFFALSE 67689
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
67367: LD_EXP 36
67371: PUSH
67372: LD_VAR 0 4
67376: ARRAY
67377: PUSH
67378: LD_EXP 25
67382: PUSH
67383: LD_VAR 0 4
67387: ARRAY
67388: LESS
67389: PUSH
67390: LD_VAR 0 1
67394: PPUSH
67395: CALL_OW 264
67399: PUSH
67400: LD_INT 31
67402: PUSH
67403: LD_INT 32
67405: PUSH
67406: LD_INT 51
67408: PUSH
67409: LD_EXP 58
67413: PUSH
67414: LD_INT 12
67416: PUSH
67417: LD_INT 30
67419: PUSH
67420: LD_EXP 57
67424: PUSH
67425: LD_INT 11
67427: PUSH
67428: LD_INT 53
67430: PUSH
67431: LD_INT 14
67433: PUSH
67434: LD_EXP 61
67438: PUSH
67439: LD_INT 29
67441: PUSH
67442: LD_EXP 59
67446: PUSH
67447: LD_INT 13
67449: PUSH
67450: LD_INT 52
67452: PUSH
67453: LD_INT 48
67455: PUSH
67456: LD_INT 8
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: IN
67478: NOT
67479: AND
67480: IFFALSE 67528
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
67482: LD_ADDR_EXP 36
67486: PUSH
67487: LD_EXP 36
67491: PPUSH
67492: LD_VAR 0 4
67496: PUSH
67497: LD_EXP 36
67501: PUSH
67502: LD_VAR 0 4
67506: ARRAY
67507: PUSH
67508: LD_INT 1
67510: PLUS
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PPUSH
67516: LD_VAR 0 1
67520: PPUSH
67521: CALL 9445 0 3
67525: ST_TO_ADDR
67526: GO 67572
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
67528: LD_ADDR_EXP 33
67532: PUSH
67533: LD_EXP 33
67537: PPUSH
67538: LD_VAR 0 4
67542: PUSH
67543: LD_EXP 33
67547: PUSH
67548: LD_VAR 0 4
67552: ARRAY
67553: PUSH
67554: LD_INT 1
67556: PLUS
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PPUSH
67562: LD_VAR 0 1
67566: PPUSH
67567: CALL 9445 0 3
67571: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
67572: LD_VAR 0 1
67576: PPUSH
67577: CALL_OW 263
67581: PUSH
67582: LD_INT 2
67584: EQUAL
67585: IFFALSE 67605
// begin repeat wait ( 0 0$1 ) ;
67587: LD_INT 35
67589: PPUSH
67590: CALL_OW 67
// until IsControledBy ( vehicle ) ;
67594: LD_VAR 0 1
67598: PPUSH
67599: CALL_OW 312
67603: IFFALSE 67587
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
67605: LD_VAR 0 1
67609: PPUSH
67610: LD_EXP 38
67614: PUSH
67615: LD_VAR 0 4
67619: ARRAY
67620: PPUSH
67621: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
67625: LD_VAR 0 1
67629: PPUSH
67630: CALL_OW 263
67634: PUSH
67635: LD_INT 1
67637: NONEQUAL
67638: IFFALSE 67642
// break ;
67640: GO 67691
// repeat wait ( 0 0$1 ) ;
67642: LD_INT 35
67644: PPUSH
67645: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
67649: LD_VAR 0 1
67653: PPUSH
67654: LD_EXP 38
67658: PUSH
67659: LD_VAR 0 4
67663: ARRAY
67664: PPUSH
67665: CALL_OW 308
67669: IFFALSE 67642
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
67671: LD_VAR 0 1
67675: PPUSH
67676: CALL_OW 311
67680: PPUSH
67681: CALL_OW 121
// exit ;
67685: POP
67686: POP
67687: GO 67693
// end ; end ;
67689: GO 67346
67691: POP
67692: POP
// end ;
67693: LD_VAR 0 3
67697: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
67698: LD_INT 0
67700: PPUSH
67701: PPUSH
67702: PPUSH
67703: PPUSH
// if not mc_bases or not skirmish then
67704: LD_EXP 14
67708: NOT
67709: PUSH
67710: LD_EXP 12
67714: NOT
67715: OR
67716: IFFALSE 67720
// exit ;
67718: GO 68073
// repeat wait ( 0 0$1 ) ;
67720: LD_INT 35
67722: PPUSH
67723: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
67727: LD_VAR 0 2
67731: PPUSH
67732: LD_VAR 0 3
67736: PPUSH
67737: CALL_OW 284
67741: IFFALSE 67720
// if GetResourceTypeXY ( x , y ) = mat_artefact then
67743: LD_VAR 0 2
67747: PPUSH
67748: LD_VAR 0 3
67752: PPUSH
67753: CALL_OW 283
67757: PUSH
67758: LD_INT 4
67760: EQUAL
67761: IFFALSE 67765
// exit ;
67763: GO 68073
// for i = 1 to mc_bases do
67765: LD_ADDR_VAR 0 7
67769: PUSH
67770: DOUBLE
67771: LD_INT 1
67773: DEC
67774: ST_TO_ADDR
67775: LD_EXP 14
67779: PUSH
67780: FOR_TO
67781: IFFALSE 68071
// begin if mc_crates_area [ i ] then
67783: LD_EXP 32
67787: PUSH
67788: LD_VAR 0 7
67792: ARRAY
67793: IFFALSE 67904
// for j in mc_crates_area [ i ] do
67795: LD_ADDR_VAR 0 8
67799: PUSH
67800: LD_EXP 32
67804: PUSH
67805: LD_VAR 0 7
67809: ARRAY
67810: PUSH
67811: FOR_IN
67812: IFFALSE 67902
// if InArea ( x , y , j ) then
67814: LD_VAR 0 2
67818: PPUSH
67819: LD_VAR 0 3
67823: PPUSH
67824: LD_VAR 0 8
67828: PPUSH
67829: CALL_OW 309
67833: IFFALSE 67900
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67835: LD_ADDR_EXP 30
67839: PUSH
67840: LD_EXP 30
67844: PPUSH
67845: LD_VAR 0 7
67849: PUSH
67850: LD_EXP 30
67854: PUSH
67855: LD_VAR 0 7
67859: ARRAY
67860: PUSH
67861: LD_INT 1
67863: PLUS
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PPUSH
67869: LD_VAR 0 4
67873: PUSH
67874: LD_VAR 0 2
67878: PUSH
67879: LD_VAR 0 3
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: LIST
67888: PPUSH
67889: CALL 9445 0 3
67893: ST_TO_ADDR
// exit ;
67894: POP
67895: POP
67896: POP
67897: POP
67898: GO 68073
// end ;
67900: GO 67811
67902: POP
67903: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67904: LD_ADDR_VAR 0 9
67908: PUSH
67909: LD_EXP 14
67913: PUSH
67914: LD_VAR 0 7
67918: ARRAY
67919: PPUSH
67920: LD_INT 2
67922: PUSH
67923: LD_INT 30
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 30
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: LIST
67947: PPUSH
67948: CALL_OW 72
67952: ST_TO_ADDR
// if not depot then
67953: LD_VAR 0 9
67957: NOT
67958: IFFALSE 67962
// continue ;
67960: GO 67780
// for j in depot do
67962: LD_ADDR_VAR 0 8
67966: PUSH
67967: LD_VAR 0 9
67971: PUSH
67972: FOR_IN
67973: IFFALSE 68067
// if GetDistUnitXY ( j , x , y ) < 30 then
67975: LD_VAR 0 8
67979: PPUSH
67980: LD_VAR 0 2
67984: PPUSH
67985: LD_VAR 0 3
67989: PPUSH
67990: CALL_OW 297
67994: PUSH
67995: LD_INT 30
67997: LESS
67998: IFFALSE 68065
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
68000: LD_ADDR_EXP 30
68004: PUSH
68005: LD_EXP 30
68009: PPUSH
68010: LD_VAR 0 7
68014: PUSH
68015: LD_EXP 30
68019: PUSH
68020: LD_VAR 0 7
68024: ARRAY
68025: PUSH
68026: LD_INT 1
68028: PLUS
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PPUSH
68034: LD_VAR 0 4
68038: PUSH
68039: LD_VAR 0 2
68043: PUSH
68044: LD_VAR 0 3
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: LIST
68053: PPUSH
68054: CALL 9445 0 3
68058: ST_TO_ADDR
// exit ;
68059: POP
68060: POP
68061: POP
68062: POP
68063: GO 68073
// end ;
68065: GO 67972
68067: POP
68068: POP
// end ;
68069: GO 67780
68071: POP
68072: POP
// end ;
68073: LD_VAR 0 6
68077: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
68078: LD_INT 0
68080: PPUSH
68081: PPUSH
68082: PPUSH
68083: PPUSH
// if not mc_bases or not skirmish then
68084: LD_EXP 14
68088: NOT
68089: PUSH
68090: LD_EXP 12
68094: NOT
68095: OR
68096: IFFALSE 68100
// exit ;
68098: GO 68377
// side := GetSide ( lab ) ;
68100: LD_ADDR_VAR 0 4
68104: PUSH
68105: LD_VAR 0 2
68109: PPUSH
68110: CALL_OW 255
68114: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
68115: LD_VAR 0 4
68119: PUSH
68120: LD_EXP 40
68124: IN
68125: NOT
68126: PUSH
68127: LD_EXP 41
68131: NOT
68132: OR
68133: PUSH
68134: LD_EXP 14
68138: NOT
68139: OR
68140: IFFALSE 68144
// exit ;
68142: GO 68377
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
68144: LD_ADDR_EXP 41
68148: PUSH
68149: LD_EXP 41
68153: PPUSH
68154: LD_VAR 0 4
68158: PPUSH
68159: LD_EXP 41
68163: PUSH
68164: LD_VAR 0 4
68168: ARRAY
68169: PUSH
68170: LD_VAR 0 1
68174: DIFF
68175: PPUSH
68176: CALL_OW 1
68180: ST_TO_ADDR
// for i = 1 to mc_bases do
68181: LD_ADDR_VAR 0 5
68185: PUSH
68186: DOUBLE
68187: LD_INT 1
68189: DEC
68190: ST_TO_ADDR
68191: LD_EXP 14
68195: PUSH
68196: FOR_TO
68197: IFFALSE 68375
// begin if lab in mc_bases [ i ] then
68199: LD_VAR 0 2
68203: PUSH
68204: LD_EXP 14
68208: PUSH
68209: LD_VAR 0 5
68213: ARRAY
68214: IN
68215: IFFALSE 68373
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
68217: LD_VAR 0 1
68221: PUSH
68222: LD_INT 11
68224: PUSH
68225: LD_INT 4
68227: PUSH
68228: LD_INT 3
68230: PUSH
68231: LD_INT 2
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: IN
68240: PUSH
68241: LD_EXP 44
68245: PUSH
68246: LD_VAR 0 5
68250: ARRAY
68251: AND
68252: IFFALSE 68373
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
68254: LD_ADDR_VAR 0 6
68258: PUSH
68259: LD_EXP 44
68263: PUSH
68264: LD_VAR 0 5
68268: ARRAY
68269: PUSH
68270: LD_INT 1
68272: ARRAY
68273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68274: LD_ADDR_EXP 44
68278: PUSH
68279: LD_EXP 44
68283: PPUSH
68284: LD_VAR 0 5
68288: PPUSH
68289: EMPTY
68290: PPUSH
68291: CALL_OW 1
68295: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
68296: LD_VAR 0 6
68300: PPUSH
68301: LD_INT 0
68303: PPUSH
68304: CALL_OW 109
// ComExitBuilding ( tmp ) ;
68308: LD_VAR 0 6
68312: PPUSH
68313: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
68317: LD_ADDR_EXP 43
68321: PUSH
68322: LD_EXP 43
68326: PPUSH
68327: LD_VAR 0 5
68331: PPUSH
68332: LD_EXP 43
68336: PUSH
68337: LD_VAR 0 5
68341: ARRAY
68342: PPUSH
68343: LD_INT 1
68345: PPUSH
68346: LD_VAR 0 6
68350: PPUSH
68351: CALL_OW 2
68355: PPUSH
68356: CALL_OW 1
68360: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
68361: LD_VAR 0 5
68365: PPUSH
68366: LD_INT 112
68368: PPUSH
68369: CALL 45389 0 2
// end ; end ; end ;
68373: GO 68196
68375: POP
68376: POP
// end ;
68377: LD_VAR 0 3
68381: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
68382: LD_INT 0
68384: PPUSH
68385: PPUSH
68386: PPUSH
68387: PPUSH
68388: PPUSH
68389: PPUSH
68390: PPUSH
68391: PPUSH
// if not mc_bases or not skirmish then
68392: LD_EXP 14
68396: NOT
68397: PUSH
68398: LD_EXP 12
68402: NOT
68403: OR
68404: IFFALSE 68408
// exit ;
68406: GO 69779
// for i = 1 to mc_bases do
68408: LD_ADDR_VAR 0 3
68412: PUSH
68413: DOUBLE
68414: LD_INT 1
68416: DEC
68417: ST_TO_ADDR
68418: LD_EXP 14
68422: PUSH
68423: FOR_TO
68424: IFFALSE 69777
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
68426: LD_VAR 0 1
68430: PUSH
68431: LD_EXP 14
68435: PUSH
68436: LD_VAR 0 3
68440: ARRAY
68441: IN
68442: PUSH
68443: LD_VAR 0 1
68447: PUSH
68448: LD_EXP 21
68452: PUSH
68453: LD_VAR 0 3
68457: ARRAY
68458: IN
68459: OR
68460: PUSH
68461: LD_VAR 0 1
68465: PUSH
68466: LD_EXP 36
68470: PUSH
68471: LD_VAR 0 3
68475: ARRAY
68476: IN
68477: OR
68478: PUSH
68479: LD_VAR 0 1
68483: PUSH
68484: LD_EXP 33
68488: PUSH
68489: LD_VAR 0 3
68493: ARRAY
68494: IN
68495: OR
68496: PUSH
68497: LD_VAR 0 1
68501: PUSH
68502: LD_EXP 43
68506: PUSH
68507: LD_VAR 0 3
68511: ARRAY
68512: IN
68513: OR
68514: PUSH
68515: LD_VAR 0 1
68519: PUSH
68520: LD_EXP 44
68524: PUSH
68525: LD_VAR 0 3
68529: ARRAY
68530: IN
68531: OR
68532: IFFALSE 69775
// begin if un in mc_ape [ i ] then
68534: LD_VAR 0 1
68538: PUSH
68539: LD_EXP 43
68543: PUSH
68544: LD_VAR 0 3
68548: ARRAY
68549: IN
68550: IFFALSE 68589
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
68552: LD_ADDR_EXP 43
68556: PUSH
68557: LD_EXP 43
68561: PPUSH
68562: LD_VAR 0 3
68566: PPUSH
68567: LD_EXP 43
68571: PUSH
68572: LD_VAR 0 3
68576: ARRAY
68577: PUSH
68578: LD_VAR 0 1
68582: DIFF
68583: PPUSH
68584: CALL_OW 1
68588: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
68589: LD_VAR 0 1
68593: PUSH
68594: LD_EXP 44
68598: PUSH
68599: LD_VAR 0 3
68603: ARRAY
68604: IN
68605: IFFALSE 68629
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68607: LD_ADDR_EXP 44
68611: PUSH
68612: LD_EXP 44
68616: PPUSH
68617: LD_VAR 0 3
68621: PPUSH
68622: EMPTY
68623: PPUSH
68624: CALL_OW 1
68628: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
68629: LD_VAR 0 1
68633: PPUSH
68634: CALL_OW 247
68638: PUSH
68639: LD_INT 2
68641: EQUAL
68642: PUSH
68643: LD_VAR 0 1
68647: PPUSH
68648: CALL_OW 110
68652: PUSH
68653: LD_INT 20
68655: EQUAL
68656: PUSH
68657: LD_VAR 0 1
68661: PUSH
68662: LD_EXP 36
68666: PUSH
68667: LD_VAR 0 3
68671: ARRAY
68672: IN
68673: OR
68674: PUSH
68675: LD_VAR 0 1
68679: PPUSH
68680: CALL_OW 264
68684: PUSH
68685: LD_INT 12
68687: PUSH
68688: LD_INT 51
68690: PUSH
68691: LD_EXP 58
68695: PUSH
68696: LD_INT 32
68698: PUSH
68699: LD_INT 13
68701: PUSH
68702: LD_INT 52
68704: PUSH
68705: LD_INT 31
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: IN
68717: OR
68718: AND
68719: IFFALSE 69027
// begin if un in mc_defender [ i ] then
68721: LD_VAR 0 1
68725: PUSH
68726: LD_EXP 36
68730: PUSH
68731: LD_VAR 0 3
68735: ARRAY
68736: IN
68737: IFFALSE 68776
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68739: LD_ADDR_EXP 36
68743: PUSH
68744: LD_EXP 36
68748: PPUSH
68749: LD_VAR 0 3
68753: PPUSH
68754: LD_EXP 36
68758: PUSH
68759: LD_VAR 0 3
68763: ARRAY
68764: PUSH
68765: LD_VAR 0 1
68769: DIFF
68770: PPUSH
68771: CALL_OW 1
68775: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
68776: LD_ADDR_VAR 0 8
68780: PUSH
68781: LD_VAR 0 3
68785: PPUSH
68786: LD_INT 3
68788: PPUSH
68789: CALL 65445 0 2
68793: ST_TO_ADDR
// if fac then
68794: LD_VAR 0 8
68798: IFFALSE 69027
// begin for j in fac do
68800: LD_ADDR_VAR 0 4
68804: PUSH
68805: LD_VAR 0 8
68809: PUSH
68810: FOR_IN
68811: IFFALSE 69025
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
68813: LD_ADDR_VAR 0 9
68817: PUSH
68818: LD_VAR 0 8
68822: PPUSH
68823: LD_VAR 0 1
68827: PPUSH
68828: CALL_OW 265
68832: PPUSH
68833: LD_VAR 0 1
68837: PPUSH
68838: CALL_OW 262
68842: PPUSH
68843: LD_VAR 0 1
68847: PPUSH
68848: CALL_OW 263
68852: PPUSH
68853: LD_VAR 0 1
68857: PPUSH
68858: CALL_OW 264
68862: PPUSH
68863: CALL 6977 0 5
68867: ST_TO_ADDR
// if components then
68868: LD_VAR 0 9
68872: IFFALSE 69023
// begin if GetWeapon ( un ) = ar_control_tower then
68874: LD_VAR 0 1
68878: PPUSH
68879: CALL_OW 264
68883: PUSH
68884: LD_INT 31
68886: EQUAL
68887: IFFALSE 69004
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
68889: LD_VAR 0 1
68893: PPUSH
68894: CALL_OW 311
68898: PPUSH
68899: LD_INT 0
68901: PPUSH
68902: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
68906: LD_ADDR_EXP 54
68910: PUSH
68911: LD_EXP 54
68915: PPUSH
68916: LD_VAR 0 3
68920: PPUSH
68921: LD_EXP 54
68925: PUSH
68926: LD_VAR 0 3
68930: ARRAY
68931: PUSH
68932: LD_VAR 0 1
68936: PPUSH
68937: CALL_OW 311
68941: DIFF
68942: PPUSH
68943: CALL_OW 1
68947: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
68948: LD_ADDR_VAR 0 7
68952: PUSH
68953: LD_EXP 35
68957: PUSH
68958: LD_VAR 0 3
68962: ARRAY
68963: PPUSH
68964: LD_INT 1
68966: PPUSH
68967: LD_VAR 0 9
68971: PPUSH
68972: CALL_OW 2
68976: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68977: LD_ADDR_EXP 35
68981: PUSH
68982: LD_EXP 35
68986: PPUSH
68987: LD_VAR 0 3
68991: PPUSH
68992: LD_VAR 0 7
68996: PPUSH
68997: CALL_OW 1
69001: ST_TO_ADDR
// end else
69002: GO 69021
// MC_InsertProduceList ( i , [ components ] ) ;
69004: LD_VAR 0 3
69008: PPUSH
69009: LD_VAR 0 9
69013: PUSH
69014: EMPTY
69015: LIST
69016: PPUSH
69017: CALL 64990 0 2
// break ;
69021: GO 69025
// end ; end ;
69023: GO 68810
69025: POP
69026: POP
// end ; end ; if GetType ( un ) = unit_building then
69027: LD_VAR 0 1
69031: PPUSH
69032: CALL_OW 247
69036: PUSH
69037: LD_INT 3
69039: EQUAL
69040: IFFALSE 69443
// begin btype := GetBType ( un ) ;
69042: LD_ADDR_VAR 0 5
69046: PUSH
69047: LD_VAR 0 1
69051: PPUSH
69052: CALL_OW 266
69056: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
69057: LD_VAR 0 5
69061: PUSH
69062: LD_INT 29
69064: PUSH
69065: LD_INT 30
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: IN
69072: IFFALSE 69145
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
69074: LD_VAR 0 1
69078: PPUSH
69079: CALL_OW 250
69083: PPUSH
69084: LD_VAR 0 1
69088: PPUSH
69089: CALL_OW 251
69093: PPUSH
69094: LD_VAR 0 1
69098: PPUSH
69099: CALL_OW 255
69103: PPUSH
69104: CALL_OW 440
69108: NOT
69109: IFFALSE 69145
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
69111: LD_VAR 0 1
69115: PPUSH
69116: CALL_OW 250
69120: PPUSH
69121: LD_VAR 0 1
69125: PPUSH
69126: CALL_OW 251
69130: PPUSH
69131: LD_VAR 0 1
69135: PPUSH
69136: CALL_OW 255
69140: PPUSH
69141: CALL_OW 441
// end ; if btype = b_warehouse then
69145: LD_VAR 0 5
69149: PUSH
69150: LD_INT 1
69152: EQUAL
69153: IFFALSE 69171
// begin btype := b_depot ;
69155: LD_ADDR_VAR 0 5
69159: PUSH
69160: LD_INT 0
69162: ST_TO_ADDR
// pos := 1 ;
69163: LD_ADDR_VAR 0 6
69167: PUSH
69168: LD_INT 1
69170: ST_TO_ADDR
// end ; if btype = b_factory then
69171: LD_VAR 0 5
69175: PUSH
69176: LD_INT 3
69178: EQUAL
69179: IFFALSE 69197
// begin btype := b_workshop ;
69181: LD_ADDR_VAR 0 5
69185: PUSH
69186: LD_INT 2
69188: ST_TO_ADDR
// pos := 1 ;
69189: LD_ADDR_VAR 0 6
69193: PUSH
69194: LD_INT 1
69196: ST_TO_ADDR
// end ; if btype = b_barracks then
69197: LD_VAR 0 5
69201: PUSH
69202: LD_INT 5
69204: EQUAL
69205: IFFALSE 69215
// btype := b_armoury ;
69207: LD_ADDR_VAR 0 5
69211: PUSH
69212: LD_INT 4
69214: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
69215: LD_VAR 0 5
69219: PUSH
69220: LD_INT 7
69222: PUSH
69223: LD_INT 8
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: IN
69230: IFFALSE 69240
// btype := b_lab ;
69232: LD_ADDR_VAR 0 5
69236: PUSH
69237: LD_INT 6
69239: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
69240: LD_ADDR_EXP 19
69244: PUSH
69245: LD_EXP 19
69249: PPUSH
69250: LD_VAR 0 3
69254: PUSH
69255: LD_EXP 19
69259: PUSH
69260: LD_VAR 0 3
69264: ARRAY
69265: PUSH
69266: LD_INT 1
69268: PLUS
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PPUSH
69274: LD_VAR 0 5
69278: PUSH
69279: LD_VAR 0 1
69283: PPUSH
69284: CALL_OW 250
69288: PUSH
69289: LD_VAR 0 1
69293: PPUSH
69294: CALL_OW 251
69298: PUSH
69299: LD_VAR 0 1
69303: PPUSH
69304: CALL_OW 254
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: PPUSH
69315: CALL 9445 0 3
69319: ST_TO_ADDR
// if pos = 1 then
69320: LD_VAR 0 6
69324: PUSH
69325: LD_INT 1
69327: EQUAL
69328: IFFALSE 69443
// begin tmp := mc_build_list [ i ] ;
69330: LD_ADDR_VAR 0 7
69334: PUSH
69335: LD_EXP 19
69339: PUSH
69340: LD_VAR 0 3
69344: ARRAY
69345: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
69346: LD_VAR 0 7
69350: PPUSH
69351: LD_INT 2
69353: PUSH
69354: LD_INT 30
69356: PUSH
69357: LD_INT 0
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 30
69366: PUSH
69367: LD_INT 1
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: LIST
69378: PPUSH
69379: CALL_OW 72
69383: IFFALSE 69393
// pos := 2 ;
69385: LD_ADDR_VAR 0 6
69389: PUSH
69390: LD_INT 2
69392: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
69393: LD_ADDR_VAR 0 7
69397: PUSH
69398: LD_VAR 0 7
69402: PPUSH
69403: LD_VAR 0 6
69407: PPUSH
69408: LD_VAR 0 7
69412: PPUSH
69413: CALL 9771 0 3
69417: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
69418: LD_ADDR_EXP 19
69422: PUSH
69423: LD_EXP 19
69427: PPUSH
69428: LD_VAR 0 3
69432: PPUSH
69433: LD_VAR 0 7
69437: PPUSH
69438: CALL_OW 1
69442: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
69443: LD_VAR 0 1
69447: PUSH
69448: LD_EXP 14
69452: PUSH
69453: LD_VAR 0 3
69457: ARRAY
69458: IN
69459: IFFALSE 69498
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
69461: LD_ADDR_EXP 14
69465: PUSH
69466: LD_EXP 14
69470: PPUSH
69471: LD_VAR 0 3
69475: PPUSH
69476: LD_EXP 14
69480: PUSH
69481: LD_VAR 0 3
69485: ARRAY
69486: PUSH
69487: LD_VAR 0 1
69491: DIFF
69492: PPUSH
69493: CALL_OW 1
69497: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
69498: LD_VAR 0 1
69502: PUSH
69503: LD_EXP 21
69507: PUSH
69508: LD_VAR 0 3
69512: ARRAY
69513: IN
69514: IFFALSE 69553
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
69516: LD_ADDR_EXP 21
69520: PUSH
69521: LD_EXP 21
69525: PPUSH
69526: LD_VAR 0 3
69530: PPUSH
69531: LD_EXP 21
69535: PUSH
69536: LD_VAR 0 3
69540: ARRAY
69541: PUSH
69542: LD_VAR 0 1
69546: DIFF
69547: PPUSH
69548: CALL_OW 1
69552: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
69553: LD_VAR 0 1
69557: PUSH
69558: LD_EXP 33
69562: PUSH
69563: LD_VAR 0 3
69567: ARRAY
69568: IN
69569: IFFALSE 69608
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
69571: LD_ADDR_EXP 33
69575: PUSH
69576: LD_EXP 33
69580: PPUSH
69581: LD_VAR 0 3
69585: PPUSH
69586: LD_EXP 33
69590: PUSH
69591: LD_VAR 0 3
69595: ARRAY
69596: PUSH
69597: LD_VAR 0 1
69601: DIFF
69602: PPUSH
69603: CALL_OW 1
69607: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
69608: LD_VAR 0 1
69612: PUSH
69613: LD_EXP 36
69617: PUSH
69618: LD_VAR 0 3
69622: ARRAY
69623: IN
69624: IFFALSE 69663
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69626: LD_ADDR_EXP 36
69630: PUSH
69631: LD_EXP 36
69635: PPUSH
69636: LD_VAR 0 3
69640: PPUSH
69641: LD_EXP 36
69645: PUSH
69646: LD_VAR 0 3
69650: ARRAY
69651: PUSH
69652: LD_VAR 0 1
69656: DIFF
69657: PPUSH
69658: CALL_OW 1
69662: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
69663: LD_VAR 0 1
69667: PUSH
69668: LD_EXP 23
69672: PUSH
69673: LD_VAR 0 3
69677: ARRAY
69678: IN
69679: IFFALSE 69718
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
69681: LD_ADDR_EXP 23
69685: PUSH
69686: LD_EXP 23
69690: PPUSH
69691: LD_VAR 0 3
69695: PPUSH
69696: LD_EXP 23
69700: PUSH
69701: LD_VAR 0 3
69705: ARRAY
69706: PUSH
69707: LD_VAR 0 1
69711: DIFF
69712: PPUSH
69713: CALL_OW 1
69717: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
69718: LD_VAR 0 1
69722: PUSH
69723: LD_EXP 22
69727: PUSH
69728: LD_VAR 0 3
69732: ARRAY
69733: IN
69734: IFFALSE 69773
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
69736: LD_ADDR_EXP 22
69740: PUSH
69741: LD_EXP 22
69745: PPUSH
69746: LD_VAR 0 3
69750: PPUSH
69751: LD_EXP 22
69755: PUSH
69756: LD_VAR 0 3
69760: ARRAY
69761: PUSH
69762: LD_VAR 0 1
69766: DIFF
69767: PPUSH
69768: CALL_OW 1
69772: ST_TO_ADDR
// end ; break ;
69773: GO 69777
// end ;
69775: GO 68423
69777: POP
69778: POP
// end ;
69779: LD_VAR 0 2
69783: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
69784: LD_INT 0
69786: PPUSH
69787: PPUSH
69788: PPUSH
// if not mc_bases or not skirmish then
69789: LD_EXP 14
69793: NOT
69794: PUSH
69795: LD_EXP 12
69799: NOT
69800: OR
69801: IFFALSE 69805
// exit ;
69803: GO 70020
// for i = 1 to mc_bases do
69805: LD_ADDR_VAR 0 3
69809: PUSH
69810: DOUBLE
69811: LD_INT 1
69813: DEC
69814: ST_TO_ADDR
69815: LD_EXP 14
69819: PUSH
69820: FOR_TO
69821: IFFALSE 70018
// begin if building in mc_construct_list [ i ] then
69823: LD_VAR 0 1
69827: PUSH
69828: LD_EXP 21
69832: PUSH
69833: LD_VAR 0 3
69837: ARRAY
69838: IN
69839: IFFALSE 70016
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69841: LD_ADDR_EXP 21
69845: PUSH
69846: LD_EXP 21
69850: PPUSH
69851: LD_VAR 0 3
69855: PPUSH
69856: LD_EXP 21
69860: PUSH
69861: LD_VAR 0 3
69865: ARRAY
69866: PUSH
69867: LD_VAR 0 1
69871: DIFF
69872: PPUSH
69873: CALL_OW 1
69877: ST_TO_ADDR
// if building in mc_lab [ i ] then
69878: LD_VAR 0 1
69882: PUSH
69883: LD_EXP 47
69887: PUSH
69888: LD_VAR 0 3
69892: ARRAY
69893: IN
69894: IFFALSE 69949
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
69896: LD_ADDR_EXP 48
69900: PUSH
69901: LD_EXP 48
69905: PPUSH
69906: LD_VAR 0 3
69910: PPUSH
69911: LD_EXP 48
69915: PUSH
69916: LD_VAR 0 3
69920: ARRAY
69921: PPUSH
69922: LD_INT 1
69924: PPUSH
69925: LD_EXP 48
69929: PUSH
69930: LD_VAR 0 3
69934: ARRAY
69935: PPUSH
69936: LD_INT 0
69938: PPUSH
69939: CALL 8863 0 4
69943: PPUSH
69944: CALL_OW 1
69948: ST_TO_ADDR
// if not building in mc_bases [ i ] then
69949: LD_VAR 0 1
69953: PUSH
69954: LD_EXP 14
69958: PUSH
69959: LD_VAR 0 3
69963: ARRAY
69964: IN
69965: NOT
69966: IFFALSE 70012
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69968: LD_ADDR_EXP 14
69972: PUSH
69973: LD_EXP 14
69977: PPUSH
69978: LD_VAR 0 3
69982: PUSH
69983: LD_EXP 14
69987: PUSH
69988: LD_VAR 0 3
69992: ARRAY
69993: PUSH
69994: LD_INT 1
69996: PLUS
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PPUSH
70002: LD_VAR 0 1
70006: PPUSH
70007: CALL 9445 0 3
70011: ST_TO_ADDR
// exit ;
70012: POP
70013: POP
70014: GO 70020
// end ; end ;
70016: GO 69820
70018: POP
70019: POP
// end ;
70020: LD_VAR 0 2
70024: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
70025: LD_INT 0
70027: PPUSH
70028: PPUSH
70029: PPUSH
70030: PPUSH
70031: PPUSH
70032: PPUSH
70033: PPUSH
// if not mc_bases or not skirmish then
70034: LD_EXP 14
70038: NOT
70039: PUSH
70040: LD_EXP 12
70044: NOT
70045: OR
70046: IFFALSE 70050
// exit ;
70048: GO 70711
// for i = 1 to mc_bases do
70050: LD_ADDR_VAR 0 3
70054: PUSH
70055: DOUBLE
70056: LD_INT 1
70058: DEC
70059: ST_TO_ADDR
70060: LD_EXP 14
70064: PUSH
70065: FOR_TO
70066: IFFALSE 70709
// begin if building in mc_construct_list [ i ] then
70068: LD_VAR 0 1
70072: PUSH
70073: LD_EXP 21
70077: PUSH
70078: LD_VAR 0 3
70082: ARRAY
70083: IN
70084: IFFALSE 70707
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
70086: LD_ADDR_EXP 21
70090: PUSH
70091: LD_EXP 21
70095: PPUSH
70096: LD_VAR 0 3
70100: PPUSH
70101: LD_EXP 21
70105: PUSH
70106: LD_VAR 0 3
70110: ARRAY
70111: PUSH
70112: LD_VAR 0 1
70116: DIFF
70117: PPUSH
70118: CALL_OW 1
70122: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
70123: LD_ADDR_EXP 14
70127: PUSH
70128: LD_EXP 14
70132: PPUSH
70133: LD_VAR 0 3
70137: PUSH
70138: LD_EXP 14
70142: PUSH
70143: LD_VAR 0 3
70147: ARRAY
70148: PUSH
70149: LD_INT 1
70151: PLUS
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PPUSH
70157: LD_VAR 0 1
70161: PPUSH
70162: CALL 9445 0 3
70166: ST_TO_ADDR
// btype := GetBType ( building ) ;
70167: LD_ADDR_VAR 0 5
70171: PUSH
70172: LD_VAR 0 1
70176: PPUSH
70177: CALL_OW 266
70181: ST_TO_ADDR
// side := GetSide ( building ) ;
70182: LD_ADDR_VAR 0 8
70186: PUSH
70187: LD_VAR 0 1
70191: PPUSH
70192: CALL_OW 255
70196: ST_TO_ADDR
// if btype = b_lab then
70197: LD_VAR 0 5
70201: PUSH
70202: LD_INT 6
70204: EQUAL
70205: IFFALSE 70255
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
70207: LD_ADDR_EXP 47
70211: PUSH
70212: LD_EXP 47
70216: PPUSH
70217: LD_VAR 0 3
70221: PUSH
70222: LD_EXP 47
70226: PUSH
70227: LD_VAR 0 3
70231: ARRAY
70232: PUSH
70233: LD_INT 1
70235: PLUS
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PPUSH
70241: LD_VAR 0 1
70245: PPUSH
70246: CALL 9445 0 3
70250: ST_TO_ADDR
// exit ;
70251: POP
70252: POP
70253: GO 70711
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
70255: LD_VAR 0 5
70259: PUSH
70260: LD_INT 0
70262: PUSH
70263: LD_INT 2
70265: PUSH
70266: LD_INT 4
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: LIST
70273: IN
70274: IFFALSE 70398
// begin if btype = b_armoury then
70276: LD_VAR 0 5
70280: PUSH
70281: LD_INT 4
70283: EQUAL
70284: IFFALSE 70294
// btype := b_barracks ;
70286: LD_ADDR_VAR 0 5
70290: PUSH
70291: LD_INT 5
70293: ST_TO_ADDR
// if btype = b_depot then
70294: LD_VAR 0 5
70298: PUSH
70299: LD_INT 0
70301: EQUAL
70302: IFFALSE 70312
// btype := b_warehouse ;
70304: LD_ADDR_VAR 0 5
70308: PUSH
70309: LD_INT 1
70311: ST_TO_ADDR
// if btype = b_workshop then
70312: LD_VAR 0 5
70316: PUSH
70317: LD_INT 2
70319: EQUAL
70320: IFFALSE 70330
// btype := b_factory ;
70322: LD_ADDR_VAR 0 5
70326: PUSH
70327: LD_INT 3
70329: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
70330: LD_VAR 0 5
70334: PPUSH
70335: LD_VAR 0 8
70339: PPUSH
70340: CALL_OW 323
70344: PUSH
70345: LD_INT 1
70347: EQUAL
70348: IFFALSE 70394
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
70350: LD_ADDR_EXP 46
70354: PUSH
70355: LD_EXP 46
70359: PPUSH
70360: LD_VAR 0 3
70364: PUSH
70365: LD_EXP 46
70369: PUSH
70370: LD_VAR 0 3
70374: ARRAY
70375: PUSH
70376: LD_INT 1
70378: PLUS
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PPUSH
70384: LD_VAR 0 1
70388: PPUSH
70389: CALL 9445 0 3
70393: ST_TO_ADDR
// exit ;
70394: POP
70395: POP
70396: GO 70711
// end ; if btype in [ b_bunker , b_turret ] then
70398: LD_VAR 0 5
70402: PUSH
70403: LD_INT 32
70405: PUSH
70406: LD_INT 33
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: IN
70413: IFFALSE 70703
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
70415: LD_ADDR_EXP 22
70419: PUSH
70420: LD_EXP 22
70424: PPUSH
70425: LD_VAR 0 3
70429: PUSH
70430: LD_EXP 22
70434: PUSH
70435: LD_VAR 0 3
70439: ARRAY
70440: PUSH
70441: LD_INT 1
70443: PLUS
70444: PUSH
70445: EMPTY
70446: LIST
70447: LIST
70448: PPUSH
70449: LD_VAR 0 1
70453: PPUSH
70454: CALL 9445 0 3
70458: ST_TO_ADDR
// if btype = b_bunker then
70459: LD_VAR 0 5
70463: PUSH
70464: LD_INT 32
70466: EQUAL
70467: IFFALSE 70703
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70469: LD_ADDR_EXP 23
70473: PUSH
70474: LD_EXP 23
70478: PPUSH
70479: LD_VAR 0 3
70483: PUSH
70484: LD_EXP 23
70488: PUSH
70489: LD_VAR 0 3
70493: ARRAY
70494: PUSH
70495: LD_INT 1
70497: PLUS
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PPUSH
70503: LD_VAR 0 1
70507: PPUSH
70508: CALL 9445 0 3
70512: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
70513: LD_ADDR_VAR 0 6
70517: PUSH
70518: LD_EXP 14
70522: PUSH
70523: LD_VAR 0 3
70527: ARRAY
70528: PPUSH
70529: LD_INT 25
70531: PUSH
70532: LD_INT 1
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 3
70541: PUSH
70542: LD_INT 54
70544: PUSH
70545: EMPTY
70546: LIST
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PPUSH
70556: CALL_OW 72
70560: ST_TO_ADDR
// if tmp then
70561: LD_VAR 0 6
70565: IFFALSE 70571
// exit ;
70567: POP
70568: POP
70569: GO 70711
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70571: LD_ADDR_VAR 0 6
70575: PUSH
70576: LD_EXP 14
70580: PUSH
70581: LD_VAR 0 3
70585: ARRAY
70586: PPUSH
70587: LD_INT 2
70589: PUSH
70590: LD_INT 30
70592: PUSH
70593: LD_INT 4
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 30
70602: PUSH
70603: LD_INT 5
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: LIST
70614: PPUSH
70615: CALL_OW 72
70619: ST_TO_ADDR
// if not tmp then
70620: LD_VAR 0 6
70624: NOT
70625: IFFALSE 70631
// exit ;
70627: POP
70628: POP
70629: GO 70711
// for j in tmp do
70631: LD_ADDR_VAR 0 4
70635: PUSH
70636: LD_VAR 0 6
70640: PUSH
70641: FOR_IN
70642: IFFALSE 70701
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
70644: LD_ADDR_VAR 0 7
70648: PUSH
70649: LD_VAR 0 4
70653: PPUSH
70654: CALL_OW 313
70658: PPUSH
70659: LD_INT 25
70661: PUSH
70662: LD_INT 1
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PPUSH
70669: CALL_OW 72
70673: ST_TO_ADDR
// if units then
70674: LD_VAR 0 7
70678: IFFALSE 70699
// begin ComExitBuilding ( units [ 1 ] ) ;
70680: LD_VAR 0 7
70684: PUSH
70685: LD_INT 1
70687: ARRAY
70688: PPUSH
70689: CALL_OW 122
// exit ;
70693: POP
70694: POP
70695: POP
70696: POP
70697: GO 70711
// end ; end ;
70699: GO 70641
70701: POP
70702: POP
// end ; end ; exit ;
70703: POP
70704: POP
70705: GO 70711
// end ; end ;
70707: GO 70065
70709: POP
70710: POP
// end ;
70711: LD_VAR 0 2
70715: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
70716: LD_INT 0
70718: PPUSH
70719: PPUSH
70720: PPUSH
70721: PPUSH
70722: PPUSH
70723: PPUSH
70724: PPUSH
// if not mc_bases or not skirmish then
70725: LD_EXP 14
70729: NOT
70730: PUSH
70731: LD_EXP 12
70735: NOT
70736: OR
70737: IFFALSE 70741
// exit ;
70739: GO 70972
// btype := GetBType ( building ) ;
70741: LD_ADDR_VAR 0 6
70745: PUSH
70746: LD_VAR 0 1
70750: PPUSH
70751: CALL_OW 266
70755: ST_TO_ADDR
// x := GetX ( building ) ;
70756: LD_ADDR_VAR 0 7
70760: PUSH
70761: LD_VAR 0 1
70765: PPUSH
70766: CALL_OW 250
70770: ST_TO_ADDR
// y := GetY ( building ) ;
70771: LD_ADDR_VAR 0 8
70775: PUSH
70776: LD_VAR 0 1
70780: PPUSH
70781: CALL_OW 251
70785: ST_TO_ADDR
// d := GetDir ( building ) ;
70786: LD_ADDR_VAR 0 9
70790: PUSH
70791: LD_VAR 0 1
70795: PPUSH
70796: CALL_OW 254
70800: ST_TO_ADDR
// for i = 1 to mc_bases do
70801: LD_ADDR_VAR 0 4
70805: PUSH
70806: DOUBLE
70807: LD_INT 1
70809: DEC
70810: ST_TO_ADDR
70811: LD_EXP 14
70815: PUSH
70816: FOR_TO
70817: IFFALSE 70970
// begin if not mc_build_list [ i ] then
70819: LD_EXP 19
70823: PUSH
70824: LD_VAR 0 4
70828: ARRAY
70829: NOT
70830: IFFALSE 70834
// continue ;
70832: GO 70816
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
70834: LD_VAR 0 6
70838: PUSH
70839: LD_VAR 0 7
70843: PUSH
70844: LD_VAR 0 8
70848: PUSH
70849: LD_VAR 0 9
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: PPUSH
70860: LD_EXP 19
70864: PUSH
70865: LD_VAR 0 4
70869: ARRAY
70870: PUSH
70871: LD_INT 1
70873: ARRAY
70874: PPUSH
70875: CALL 15614 0 2
70879: IFFALSE 70968
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
70881: LD_ADDR_EXP 19
70885: PUSH
70886: LD_EXP 19
70890: PPUSH
70891: LD_VAR 0 4
70895: PPUSH
70896: LD_EXP 19
70900: PUSH
70901: LD_VAR 0 4
70905: ARRAY
70906: PPUSH
70907: LD_INT 1
70909: PPUSH
70910: CALL_OW 3
70914: PPUSH
70915: CALL_OW 1
70919: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
70920: LD_ADDR_EXP 21
70924: PUSH
70925: LD_EXP 21
70929: PPUSH
70930: LD_VAR 0 4
70934: PUSH
70935: LD_EXP 21
70939: PUSH
70940: LD_VAR 0 4
70944: ARRAY
70945: PUSH
70946: LD_INT 1
70948: PLUS
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PPUSH
70954: LD_VAR 0 1
70958: PPUSH
70959: CALL 9445 0 3
70963: ST_TO_ADDR
// exit ;
70964: POP
70965: POP
70966: GO 70972
// end ; end ;
70968: GO 70816
70970: POP
70971: POP
// end ;
70972: LD_VAR 0 3
70976: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
70977: LD_INT 0
70979: PPUSH
70980: PPUSH
70981: PPUSH
// if not mc_bases or not skirmish then
70982: LD_EXP 14
70986: NOT
70987: PUSH
70988: LD_EXP 12
70992: NOT
70993: OR
70994: IFFALSE 70998
// exit ;
70996: GO 71188
// for i = 1 to mc_bases do
70998: LD_ADDR_VAR 0 4
71002: PUSH
71003: DOUBLE
71004: LD_INT 1
71006: DEC
71007: ST_TO_ADDR
71008: LD_EXP 14
71012: PUSH
71013: FOR_TO
71014: IFFALSE 71101
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
71016: LD_VAR 0 1
71020: PUSH
71021: LD_EXP 22
71025: PUSH
71026: LD_VAR 0 4
71030: ARRAY
71031: IN
71032: PUSH
71033: LD_VAR 0 1
71037: PUSH
71038: LD_EXP 23
71042: PUSH
71043: LD_VAR 0 4
71047: ARRAY
71048: IN
71049: NOT
71050: AND
71051: IFFALSE 71099
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
71053: LD_ADDR_EXP 23
71057: PUSH
71058: LD_EXP 23
71062: PPUSH
71063: LD_VAR 0 4
71067: PUSH
71068: LD_EXP 23
71072: PUSH
71073: LD_VAR 0 4
71077: ARRAY
71078: PUSH
71079: LD_INT 1
71081: PLUS
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PPUSH
71087: LD_VAR 0 1
71091: PPUSH
71092: CALL 9445 0 3
71096: ST_TO_ADDR
// break ;
71097: GO 71101
// end ; end ;
71099: GO 71013
71101: POP
71102: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
71103: LD_VAR 0 1
71107: PPUSH
71108: CALL_OW 257
71112: PUSH
71113: LD_EXP 40
71117: IN
71118: PUSH
71119: LD_VAR 0 1
71123: PPUSH
71124: CALL_OW 266
71128: PUSH
71129: LD_INT 5
71131: EQUAL
71132: AND
71133: PUSH
71134: LD_VAR 0 2
71138: PPUSH
71139: CALL_OW 110
71143: PUSH
71144: LD_INT 18
71146: NONEQUAL
71147: AND
71148: IFFALSE 71188
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
71150: LD_VAR 0 2
71154: PPUSH
71155: CALL_OW 257
71159: PUSH
71160: LD_INT 5
71162: PUSH
71163: LD_INT 8
71165: PUSH
71166: LD_INT 9
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: LIST
71173: IN
71174: IFFALSE 71188
// SetClass ( unit , 1 ) ;
71176: LD_VAR 0 2
71180: PPUSH
71181: LD_INT 1
71183: PPUSH
71184: CALL_OW 336
// end ;
71188: LD_VAR 0 3
71192: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
71193: LD_INT 0
71195: PPUSH
71196: PPUSH
// if not mc_bases or not skirmish then
71197: LD_EXP 14
71201: NOT
71202: PUSH
71203: LD_EXP 12
71207: NOT
71208: OR
71209: IFFALSE 71213
// exit ;
71211: GO 71329
// if GetLives ( abandoned_vehicle ) > 250 then
71213: LD_VAR 0 2
71217: PPUSH
71218: CALL_OW 256
71222: PUSH
71223: LD_INT 250
71225: GREATER
71226: IFFALSE 71230
// exit ;
71228: GO 71329
// for i = 1 to mc_bases do
71230: LD_ADDR_VAR 0 6
71234: PUSH
71235: DOUBLE
71236: LD_INT 1
71238: DEC
71239: ST_TO_ADDR
71240: LD_EXP 14
71244: PUSH
71245: FOR_TO
71246: IFFALSE 71327
// begin if driver in mc_bases [ i ] then
71248: LD_VAR 0 1
71252: PUSH
71253: LD_EXP 14
71257: PUSH
71258: LD_VAR 0 6
71262: ARRAY
71263: IN
71264: IFFALSE 71325
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
71266: LD_VAR 0 1
71270: PPUSH
71271: LD_EXP 14
71275: PUSH
71276: LD_VAR 0 6
71280: ARRAY
71281: PPUSH
71282: LD_INT 2
71284: PUSH
71285: LD_INT 30
71287: PUSH
71288: LD_INT 0
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 30
71297: PUSH
71298: LD_INT 1
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: LIST
71309: PPUSH
71310: CALL_OW 72
71314: PUSH
71315: LD_INT 1
71317: ARRAY
71318: PPUSH
71319: CALL_OW 112
// break ;
71323: GO 71327
// end ; end ;
71325: GO 71245
71327: POP
71328: POP
// end ; end_of_file
71329: LD_VAR 0 5
71333: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
71334: LD_INT 0
71336: PPUSH
// ar_miner := 81 ;
71337: LD_ADDR_EXP 64
71341: PUSH
71342: LD_INT 81
71344: ST_TO_ADDR
// ar_crane := 88 ;
71345: LD_ADDR_EXP 63
71349: PUSH
71350: LD_INT 88
71352: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
71353: LD_ADDR_EXP 58
71357: PUSH
71358: LD_INT 89
71360: ST_TO_ADDR
// us_hack := 99 ;
71361: LD_ADDR_EXP 59
71365: PUSH
71366: LD_INT 99
71368: ST_TO_ADDR
// us_artillery := 97 ;
71369: LD_ADDR_EXP 60
71373: PUSH
71374: LD_INT 97
71376: ST_TO_ADDR
// ar_bio_bomb := 91 ;
71377: LD_ADDR_EXP 61
71381: PUSH
71382: LD_INT 91
71384: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
71385: LD_ADDR_EXP 62
71389: PUSH
71390: LD_INT 92
71392: ST_TO_ADDR
// ru_radar := 98 ;
71393: LD_ADDR_EXP 57
71397: PUSH
71398: LD_INT 98
71400: ST_TO_ADDR
// tech_Artillery := 80 ;
71401: LD_ADDR_EXP 65
71405: PUSH
71406: LD_INT 80
71408: ST_TO_ADDR
// tech_RadMat := 81 ;
71409: LD_ADDR_EXP 66
71413: PUSH
71414: LD_INT 81
71416: ST_TO_ADDR
// tech_BasicTools := 82 ;
71417: LD_ADDR_EXP 67
71421: PUSH
71422: LD_INT 82
71424: ST_TO_ADDR
// tech_Cargo := 83 ;
71425: LD_ADDR_EXP 68
71429: PUSH
71430: LD_INT 83
71432: ST_TO_ADDR
// tech_Track := 84 ;
71433: LD_ADDR_EXP 69
71437: PUSH
71438: LD_INT 84
71440: ST_TO_ADDR
// tech_Crane := 85 ;
71441: LD_ADDR_EXP 70
71445: PUSH
71446: LD_INT 85
71448: ST_TO_ADDR
// tech_Bulldozer := 86 ;
71449: LD_ADDR_EXP 71
71453: PUSH
71454: LD_INT 86
71456: ST_TO_ADDR
// tech_Hovercraft := 87 ;
71457: LD_ADDR_EXP 72
71461: PUSH
71462: LD_INT 87
71464: ST_TO_ADDR
// end ;
71465: LD_VAR 0 1
71469: RET
// every 1 do
71470: GO 71472
71472: DISABLE
// InitGlobalVariables ; end_of_file
71473: CALL 71334 0 0
71477: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
71478: LD_INT 0
71480: PPUSH
71481: PPUSH
71482: PPUSH
71483: PPUSH
71484: PPUSH
71485: PPUSH
71486: PPUSH
71487: PPUSH
71488: PPUSH
71489: PPUSH
71490: PPUSH
71491: PPUSH
71492: PPUSH
71493: PPUSH
71494: PPUSH
71495: PPUSH
71496: PPUSH
71497: PPUSH
71498: PPUSH
71499: PPUSH
71500: PPUSH
71501: PPUSH
71502: PPUSH
71503: PPUSH
71504: PPUSH
71505: PPUSH
71506: PPUSH
71507: PPUSH
71508: PPUSH
71509: PPUSH
71510: PPUSH
71511: PPUSH
71512: PPUSH
71513: PPUSH
// if not list then
71514: LD_VAR 0 1
71518: NOT
71519: IFFALSE 71523
// exit ;
71521: GO 76182
// base := list [ 1 ] ;
71523: LD_ADDR_VAR 0 3
71527: PUSH
71528: LD_VAR 0 1
71532: PUSH
71533: LD_INT 1
71535: ARRAY
71536: ST_TO_ADDR
// group := list [ 2 ] ;
71537: LD_ADDR_VAR 0 4
71541: PUSH
71542: LD_VAR 0 1
71546: PUSH
71547: LD_INT 2
71549: ARRAY
71550: ST_TO_ADDR
// path := list [ 3 ] ;
71551: LD_ADDR_VAR 0 5
71555: PUSH
71556: LD_VAR 0 1
71560: PUSH
71561: LD_INT 3
71563: ARRAY
71564: ST_TO_ADDR
// flags := list [ 4 ] ;
71565: LD_ADDR_VAR 0 6
71569: PUSH
71570: LD_VAR 0 1
71574: PUSH
71575: LD_INT 4
71577: ARRAY
71578: ST_TO_ADDR
// mined := [ ] ;
71579: LD_ADDR_VAR 0 27
71583: PUSH
71584: EMPTY
71585: ST_TO_ADDR
// bombed := [ ] ;
71586: LD_ADDR_VAR 0 28
71590: PUSH
71591: EMPTY
71592: ST_TO_ADDR
// healers := [ ] ;
71593: LD_ADDR_VAR 0 31
71597: PUSH
71598: EMPTY
71599: ST_TO_ADDR
// to_heal := [ ] ;
71600: LD_ADDR_VAR 0 30
71604: PUSH
71605: EMPTY
71606: ST_TO_ADDR
// repairs := [ ] ;
71607: LD_ADDR_VAR 0 33
71611: PUSH
71612: EMPTY
71613: ST_TO_ADDR
// to_repair := [ ] ;
71614: LD_ADDR_VAR 0 32
71618: PUSH
71619: EMPTY
71620: ST_TO_ADDR
// if not group or not path then
71621: LD_VAR 0 4
71625: NOT
71626: PUSH
71627: LD_VAR 0 5
71631: NOT
71632: OR
71633: IFFALSE 71637
// exit ;
71635: GO 76182
// side := GetSide ( group [ 1 ] ) ;
71637: LD_ADDR_VAR 0 35
71641: PUSH
71642: LD_VAR 0 4
71646: PUSH
71647: LD_INT 1
71649: ARRAY
71650: PPUSH
71651: CALL_OW 255
71655: ST_TO_ADDR
// if flags then
71656: LD_VAR 0 6
71660: IFFALSE 71804
// begin f_ignore_area := flags [ 1 ] ;
71662: LD_ADDR_VAR 0 17
71666: PUSH
71667: LD_VAR 0 6
71671: PUSH
71672: LD_INT 1
71674: ARRAY
71675: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
71676: LD_ADDR_VAR 0 18
71680: PUSH
71681: LD_VAR 0 6
71685: PUSH
71686: LD_INT 2
71688: ARRAY
71689: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
71690: LD_ADDR_VAR 0 19
71694: PUSH
71695: LD_VAR 0 6
71699: PUSH
71700: LD_INT 3
71702: ARRAY
71703: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
71704: LD_ADDR_VAR 0 20
71708: PUSH
71709: LD_VAR 0 6
71713: PUSH
71714: LD_INT 4
71716: ARRAY
71717: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
71718: LD_ADDR_VAR 0 21
71722: PUSH
71723: LD_VAR 0 6
71727: PUSH
71728: LD_INT 5
71730: ARRAY
71731: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
71732: LD_ADDR_VAR 0 22
71736: PUSH
71737: LD_VAR 0 6
71741: PUSH
71742: LD_INT 6
71744: ARRAY
71745: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
71746: LD_ADDR_VAR 0 23
71750: PUSH
71751: LD_VAR 0 6
71755: PUSH
71756: LD_INT 7
71758: ARRAY
71759: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
71760: LD_ADDR_VAR 0 24
71764: PUSH
71765: LD_VAR 0 6
71769: PUSH
71770: LD_INT 8
71772: ARRAY
71773: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
71774: LD_ADDR_VAR 0 25
71778: PUSH
71779: LD_VAR 0 6
71783: PUSH
71784: LD_INT 9
71786: ARRAY
71787: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
71788: LD_ADDR_VAR 0 26
71792: PUSH
71793: LD_VAR 0 6
71797: PUSH
71798: LD_INT 10
71800: ARRAY
71801: ST_TO_ADDR
// end else
71802: GO 71884
// begin f_ignore_area := false ;
71804: LD_ADDR_VAR 0 17
71808: PUSH
71809: LD_INT 0
71811: ST_TO_ADDR
// f_capture := false ;
71812: LD_ADDR_VAR 0 18
71816: PUSH
71817: LD_INT 0
71819: ST_TO_ADDR
// f_ignore_civ := false ;
71820: LD_ADDR_VAR 0 19
71824: PUSH
71825: LD_INT 0
71827: ST_TO_ADDR
// f_murder := false ;
71828: LD_ADDR_VAR 0 20
71832: PUSH
71833: LD_INT 0
71835: ST_TO_ADDR
// f_mines := false ;
71836: LD_ADDR_VAR 0 21
71840: PUSH
71841: LD_INT 0
71843: ST_TO_ADDR
// f_repair := false ;
71844: LD_ADDR_VAR 0 22
71848: PUSH
71849: LD_INT 0
71851: ST_TO_ADDR
// f_heal := false ;
71852: LD_ADDR_VAR 0 23
71856: PUSH
71857: LD_INT 0
71859: ST_TO_ADDR
// f_spacetime := false ;
71860: LD_ADDR_VAR 0 24
71864: PUSH
71865: LD_INT 0
71867: ST_TO_ADDR
// f_attack_depot := false ;
71868: LD_ADDR_VAR 0 25
71872: PUSH
71873: LD_INT 0
71875: ST_TO_ADDR
// f_crawl := false ;
71876: LD_ADDR_VAR 0 26
71880: PUSH
71881: LD_INT 0
71883: ST_TO_ADDR
// end ; if f_heal then
71884: LD_VAR 0 23
71888: IFFALSE 71915
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
71890: LD_ADDR_VAR 0 31
71894: PUSH
71895: LD_VAR 0 4
71899: PPUSH
71900: LD_INT 25
71902: PUSH
71903: LD_INT 4
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PPUSH
71910: CALL_OW 72
71914: ST_TO_ADDR
// if f_repair then
71915: LD_VAR 0 22
71919: IFFALSE 71946
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
71921: LD_ADDR_VAR 0 33
71925: PUSH
71926: LD_VAR 0 4
71930: PPUSH
71931: LD_INT 25
71933: PUSH
71934: LD_INT 3
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PPUSH
71941: CALL_OW 72
71945: ST_TO_ADDR
// units_path := [ ] ;
71946: LD_ADDR_VAR 0 16
71950: PUSH
71951: EMPTY
71952: ST_TO_ADDR
// for i = 1 to group do
71953: LD_ADDR_VAR 0 7
71957: PUSH
71958: DOUBLE
71959: LD_INT 1
71961: DEC
71962: ST_TO_ADDR
71963: LD_VAR 0 4
71967: PUSH
71968: FOR_TO
71969: IFFALSE 71998
// units_path := Replace ( units_path , i , path ) ;
71971: LD_ADDR_VAR 0 16
71975: PUSH
71976: LD_VAR 0 16
71980: PPUSH
71981: LD_VAR 0 7
71985: PPUSH
71986: LD_VAR 0 5
71990: PPUSH
71991: CALL_OW 1
71995: ST_TO_ADDR
71996: GO 71968
71998: POP
71999: POP
// repeat for i = group downto 1 do
72000: LD_ADDR_VAR 0 7
72004: PUSH
72005: DOUBLE
72006: LD_VAR 0 4
72010: INC
72011: ST_TO_ADDR
72012: LD_INT 1
72014: PUSH
72015: FOR_DOWNTO
72016: IFFALSE 76138
// begin wait ( 5 ) ;
72018: LD_INT 5
72020: PPUSH
72021: CALL_OW 67
// tmp := [ ] ;
72025: LD_ADDR_VAR 0 14
72029: PUSH
72030: EMPTY
72031: ST_TO_ADDR
// attacking := false ;
72032: LD_ADDR_VAR 0 29
72036: PUSH
72037: LD_INT 0
72039: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
72040: LD_VAR 0 4
72044: PUSH
72045: LD_VAR 0 7
72049: ARRAY
72050: PPUSH
72051: CALL_OW 301
72055: PUSH
72056: LD_VAR 0 4
72060: PUSH
72061: LD_VAR 0 7
72065: ARRAY
72066: NOT
72067: OR
72068: IFFALSE 72177
// begin if GetType ( group [ i ] ) = unit_human then
72070: LD_VAR 0 4
72074: PUSH
72075: LD_VAR 0 7
72079: ARRAY
72080: PPUSH
72081: CALL_OW 247
72085: PUSH
72086: LD_INT 1
72088: EQUAL
72089: IFFALSE 72135
// begin to_heal := to_heal diff group [ i ] ;
72091: LD_ADDR_VAR 0 30
72095: PUSH
72096: LD_VAR 0 30
72100: PUSH
72101: LD_VAR 0 4
72105: PUSH
72106: LD_VAR 0 7
72110: ARRAY
72111: DIFF
72112: ST_TO_ADDR
// healers := healers diff group [ i ] ;
72113: LD_ADDR_VAR 0 31
72117: PUSH
72118: LD_VAR 0 31
72122: PUSH
72123: LD_VAR 0 4
72127: PUSH
72128: LD_VAR 0 7
72132: ARRAY
72133: DIFF
72134: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
72135: LD_ADDR_VAR 0 4
72139: PUSH
72140: LD_VAR 0 4
72144: PPUSH
72145: LD_VAR 0 7
72149: PPUSH
72150: CALL_OW 3
72154: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
72155: LD_ADDR_VAR 0 16
72159: PUSH
72160: LD_VAR 0 16
72164: PPUSH
72165: LD_VAR 0 7
72169: PPUSH
72170: CALL_OW 3
72174: ST_TO_ADDR
// continue ;
72175: GO 72015
// end ; if f_repair then
72177: LD_VAR 0 22
72181: IFFALSE 72670
// begin if GetType ( group [ i ] ) = unit_vehicle then
72183: LD_VAR 0 4
72187: PUSH
72188: LD_VAR 0 7
72192: ARRAY
72193: PPUSH
72194: CALL_OW 247
72198: PUSH
72199: LD_INT 2
72201: EQUAL
72202: IFFALSE 72392
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
72204: LD_VAR 0 4
72208: PUSH
72209: LD_VAR 0 7
72213: ARRAY
72214: PPUSH
72215: CALL_OW 256
72219: PUSH
72220: LD_INT 700
72222: LESS
72223: PUSH
72224: LD_VAR 0 4
72228: PUSH
72229: LD_VAR 0 7
72233: ARRAY
72234: PUSH
72235: LD_VAR 0 32
72239: IN
72240: NOT
72241: AND
72242: IFFALSE 72266
// to_repair := to_repair union group [ i ] ;
72244: LD_ADDR_VAR 0 32
72248: PUSH
72249: LD_VAR 0 32
72253: PUSH
72254: LD_VAR 0 4
72258: PUSH
72259: LD_VAR 0 7
72263: ARRAY
72264: UNION
72265: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
72266: LD_VAR 0 4
72270: PUSH
72271: LD_VAR 0 7
72275: ARRAY
72276: PPUSH
72277: CALL_OW 256
72281: PUSH
72282: LD_INT 1000
72284: EQUAL
72285: PUSH
72286: LD_VAR 0 4
72290: PUSH
72291: LD_VAR 0 7
72295: ARRAY
72296: PUSH
72297: LD_VAR 0 32
72301: IN
72302: AND
72303: IFFALSE 72327
// to_repair := to_repair diff group [ i ] ;
72305: LD_ADDR_VAR 0 32
72309: PUSH
72310: LD_VAR 0 32
72314: PUSH
72315: LD_VAR 0 4
72319: PUSH
72320: LD_VAR 0 7
72324: ARRAY
72325: DIFF
72326: ST_TO_ADDR
// if group [ i ] in to_repair then
72327: LD_VAR 0 4
72331: PUSH
72332: LD_VAR 0 7
72336: ARRAY
72337: PUSH
72338: LD_VAR 0 32
72342: IN
72343: IFFALSE 72390
// begin if not IsInArea ( group [ i ] , f_repair ) then
72345: LD_VAR 0 4
72349: PUSH
72350: LD_VAR 0 7
72354: ARRAY
72355: PPUSH
72356: LD_VAR 0 22
72360: PPUSH
72361: CALL_OW 308
72365: NOT
72366: IFFALSE 72388
// ComMoveToArea ( group [ i ] , f_repair ) ;
72368: LD_VAR 0 4
72372: PUSH
72373: LD_VAR 0 7
72377: ARRAY
72378: PPUSH
72379: LD_VAR 0 22
72383: PPUSH
72384: CALL_OW 113
// continue ;
72388: GO 72015
// end ; end else
72390: GO 72670
// if group [ i ] in repairs then
72392: LD_VAR 0 4
72396: PUSH
72397: LD_VAR 0 7
72401: ARRAY
72402: PUSH
72403: LD_VAR 0 33
72407: IN
72408: IFFALSE 72670
// begin if IsInUnit ( group [ i ] ) then
72410: LD_VAR 0 4
72414: PUSH
72415: LD_VAR 0 7
72419: ARRAY
72420: PPUSH
72421: CALL_OW 310
72425: IFFALSE 72493
// begin z := IsInUnit ( group [ i ] ) ;
72427: LD_ADDR_VAR 0 13
72431: PUSH
72432: LD_VAR 0 4
72436: PUSH
72437: LD_VAR 0 7
72441: ARRAY
72442: PPUSH
72443: CALL_OW 310
72447: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
72448: LD_VAR 0 13
72452: PUSH
72453: LD_VAR 0 32
72457: IN
72458: PUSH
72459: LD_VAR 0 13
72463: PPUSH
72464: LD_VAR 0 22
72468: PPUSH
72469: CALL_OW 308
72473: AND
72474: IFFALSE 72491
// ComExitVehicle ( group [ i ] ) ;
72476: LD_VAR 0 4
72480: PUSH
72481: LD_VAR 0 7
72485: ARRAY
72486: PPUSH
72487: CALL_OW 121
// end else
72491: GO 72670
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
72493: LD_ADDR_VAR 0 13
72497: PUSH
72498: LD_VAR 0 4
72502: PPUSH
72503: LD_INT 95
72505: PUSH
72506: LD_VAR 0 22
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 58
72517: PUSH
72518: EMPTY
72519: LIST
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PPUSH
72525: CALL_OW 72
72529: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
72530: LD_VAR 0 4
72534: PUSH
72535: LD_VAR 0 7
72539: ARRAY
72540: PPUSH
72541: CALL_OW 314
72545: NOT
72546: IFFALSE 72668
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
72548: LD_ADDR_VAR 0 10
72552: PUSH
72553: LD_VAR 0 13
72557: PPUSH
72558: LD_VAR 0 4
72562: PUSH
72563: LD_VAR 0 7
72567: ARRAY
72568: PPUSH
72569: CALL_OW 74
72573: ST_TO_ADDR
// if not x then
72574: LD_VAR 0 10
72578: NOT
72579: IFFALSE 72583
// continue ;
72581: GO 72015
// if GetLives ( x ) < 1000 then
72583: LD_VAR 0 10
72587: PPUSH
72588: CALL_OW 256
72592: PUSH
72593: LD_INT 1000
72595: LESS
72596: IFFALSE 72620
// ComRepairVehicle ( group [ i ] , x ) else
72598: LD_VAR 0 4
72602: PUSH
72603: LD_VAR 0 7
72607: ARRAY
72608: PPUSH
72609: LD_VAR 0 10
72613: PPUSH
72614: CALL_OW 129
72618: GO 72668
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
72620: LD_VAR 0 23
72624: PUSH
72625: LD_VAR 0 4
72629: PUSH
72630: LD_VAR 0 7
72634: ARRAY
72635: PPUSH
72636: CALL_OW 256
72640: PUSH
72641: LD_INT 1000
72643: LESS
72644: AND
72645: NOT
72646: IFFALSE 72668
// ComEnterUnit ( group [ i ] , x ) ;
72648: LD_VAR 0 4
72652: PUSH
72653: LD_VAR 0 7
72657: ARRAY
72658: PPUSH
72659: LD_VAR 0 10
72663: PPUSH
72664: CALL_OW 120
// end ; continue ;
72668: GO 72015
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
72670: LD_VAR 0 23
72674: PUSH
72675: LD_VAR 0 4
72679: PUSH
72680: LD_VAR 0 7
72684: ARRAY
72685: PPUSH
72686: CALL_OW 247
72690: PUSH
72691: LD_INT 1
72693: EQUAL
72694: AND
72695: IFFALSE 73173
// begin if group [ i ] in healers then
72697: LD_VAR 0 4
72701: PUSH
72702: LD_VAR 0 7
72706: ARRAY
72707: PUSH
72708: LD_VAR 0 31
72712: IN
72713: IFFALSE 72986
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
72715: LD_VAR 0 4
72719: PUSH
72720: LD_VAR 0 7
72724: ARRAY
72725: PPUSH
72726: LD_VAR 0 23
72730: PPUSH
72731: CALL_OW 308
72735: NOT
72736: PUSH
72737: LD_VAR 0 4
72741: PUSH
72742: LD_VAR 0 7
72746: ARRAY
72747: PPUSH
72748: CALL_OW 314
72752: NOT
72753: AND
72754: IFFALSE 72778
// ComMoveToArea ( group [ i ] , f_heal ) else
72756: LD_VAR 0 4
72760: PUSH
72761: LD_VAR 0 7
72765: ARRAY
72766: PPUSH
72767: LD_VAR 0 23
72771: PPUSH
72772: CALL_OW 113
72776: GO 72984
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
72778: LD_VAR 0 4
72782: PUSH
72783: LD_VAR 0 7
72787: ARRAY
72788: PPUSH
72789: CALL 37817 0 1
72793: PPUSH
72794: CALL_OW 256
72798: PUSH
72799: LD_INT 1000
72801: EQUAL
72802: IFFALSE 72821
// ComStop ( group [ i ] ) else
72804: LD_VAR 0 4
72808: PUSH
72809: LD_VAR 0 7
72813: ARRAY
72814: PPUSH
72815: CALL_OW 141
72819: GO 72984
// if not HasTask ( group [ i ] ) and to_heal then
72821: LD_VAR 0 4
72825: PUSH
72826: LD_VAR 0 7
72830: ARRAY
72831: PPUSH
72832: CALL_OW 314
72836: NOT
72837: PUSH
72838: LD_VAR 0 30
72842: AND
72843: IFFALSE 72984
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
72845: LD_ADDR_VAR 0 13
72849: PUSH
72850: LD_VAR 0 30
72854: PPUSH
72855: LD_INT 3
72857: PUSH
72858: LD_INT 54
72860: PUSH
72861: EMPTY
72862: LIST
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PPUSH
72868: CALL_OW 72
72872: PPUSH
72873: LD_VAR 0 4
72877: PUSH
72878: LD_VAR 0 7
72882: ARRAY
72883: PPUSH
72884: CALL_OW 74
72888: ST_TO_ADDR
// if z then
72889: LD_VAR 0 13
72893: IFFALSE 72984
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
72895: LD_INT 91
72897: PUSH
72898: LD_VAR 0 13
72902: PUSH
72903: LD_INT 10
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 81
72913: PUSH
72914: LD_VAR 0 13
72918: PPUSH
72919: CALL_OW 255
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PPUSH
72932: CALL_OW 69
72936: PUSH
72937: LD_INT 0
72939: EQUAL
72940: IFFALSE 72964
// ComHeal ( group [ i ] , z ) else
72942: LD_VAR 0 4
72946: PUSH
72947: LD_VAR 0 7
72951: ARRAY
72952: PPUSH
72953: LD_VAR 0 13
72957: PPUSH
72958: CALL_OW 128
72962: GO 72984
// ComMoveToArea ( group [ i ] , f_heal ) ;
72964: LD_VAR 0 4
72968: PUSH
72969: LD_VAR 0 7
72973: ARRAY
72974: PPUSH
72975: LD_VAR 0 23
72979: PPUSH
72980: CALL_OW 113
// end ; continue ;
72984: GO 72015
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
72986: LD_VAR 0 4
72990: PUSH
72991: LD_VAR 0 7
72995: ARRAY
72996: PPUSH
72997: CALL_OW 256
73001: PUSH
73002: LD_INT 700
73004: LESS
73005: PUSH
73006: LD_VAR 0 4
73010: PUSH
73011: LD_VAR 0 7
73015: ARRAY
73016: PUSH
73017: LD_VAR 0 30
73021: IN
73022: NOT
73023: AND
73024: IFFALSE 73048
// to_heal := to_heal union group [ i ] ;
73026: LD_ADDR_VAR 0 30
73030: PUSH
73031: LD_VAR 0 30
73035: PUSH
73036: LD_VAR 0 4
73040: PUSH
73041: LD_VAR 0 7
73045: ARRAY
73046: UNION
73047: ST_TO_ADDR
// if group [ i ] in to_heal then
73048: LD_VAR 0 4
73052: PUSH
73053: LD_VAR 0 7
73057: ARRAY
73058: PUSH
73059: LD_VAR 0 30
73063: IN
73064: IFFALSE 73173
// begin if GetLives ( group [ i ] ) = 1000 then
73066: LD_VAR 0 4
73070: PUSH
73071: LD_VAR 0 7
73075: ARRAY
73076: PPUSH
73077: CALL_OW 256
73081: PUSH
73082: LD_INT 1000
73084: EQUAL
73085: IFFALSE 73111
// to_heal := to_heal diff group [ i ] else
73087: LD_ADDR_VAR 0 30
73091: PUSH
73092: LD_VAR 0 30
73096: PUSH
73097: LD_VAR 0 4
73101: PUSH
73102: LD_VAR 0 7
73106: ARRAY
73107: DIFF
73108: ST_TO_ADDR
73109: GO 73173
// begin if not IsInArea ( group [ i ] , to_heal ) then
73111: LD_VAR 0 4
73115: PUSH
73116: LD_VAR 0 7
73120: ARRAY
73121: PPUSH
73122: LD_VAR 0 30
73126: PPUSH
73127: CALL_OW 308
73131: NOT
73132: IFFALSE 73156
// ComMoveToArea ( group [ i ] , f_heal ) else
73134: LD_VAR 0 4
73138: PUSH
73139: LD_VAR 0 7
73143: ARRAY
73144: PPUSH
73145: LD_VAR 0 23
73149: PPUSH
73150: CALL_OW 113
73154: GO 73171
// ComHold ( group [ i ] ) ;
73156: LD_VAR 0 4
73160: PUSH
73161: LD_VAR 0 7
73165: ARRAY
73166: PPUSH
73167: CALL_OW 140
// continue ;
73171: GO 72015
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
73173: LD_VAR 0 4
73177: PUSH
73178: LD_VAR 0 7
73182: ARRAY
73183: PPUSH
73184: LD_INT 10
73186: PPUSH
73187: CALL 36237 0 2
73191: NOT
73192: PUSH
73193: LD_VAR 0 16
73197: PUSH
73198: LD_VAR 0 7
73202: ARRAY
73203: PUSH
73204: EMPTY
73205: EQUAL
73206: NOT
73207: AND
73208: IFFALSE 73474
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
73210: LD_VAR 0 4
73214: PUSH
73215: LD_VAR 0 7
73219: ARRAY
73220: PPUSH
73221: CALL_OW 262
73225: PUSH
73226: LD_INT 1
73228: PUSH
73229: LD_INT 2
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: IN
73236: IFFALSE 73277
// if GetFuel ( group [ i ] ) < 10 then
73238: LD_VAR 0 4
73242: PUSH
73243: LD_VAR 0 7
73247: ARRAY
73248: PPUSH
73249: CALL_OW 261
73253: PUSH
73254: LD_INT 10
73256: LESS
73257: IFFALSE 73277
// SetFuel ( group [ i ] , 12 ) ;
73259: LD_VAR 0 4
73263: PUSH
73264: LD_VAR 0 7
73268: ARRAY
73269: PPUSH
73270: LD_INT 12
73272: PPUSH
73273: CALL_OW 240
// if units_path [ i ] then
73277: LD_VAR 0 16
73281: PUSH
73282: LD_VAR 0 7
73286: ARRAY
73287: IFFALSE 73472
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
73289: LD_VAR 0 4
73293: PUSH
73294: LD_VAR 0 7
73298: ARRAY
73299: PPUSH
73300: LD_VAR 0 16
73304: PUSH
73305: LD_VAR 0 7
73309: ARRAY
73310: PUSH
73311: LD_INT 1
73313: ARRAY
73314: PUSH
73315: LD_INT 1
73317: ARRAY
73318: PPUSH
73319: LD_VAR 0 16
73323: PUSH
73324: LD_VAR 0 7
73328: ARRAY
73329: PUSH
73330: LD_INT 1
73332: ARRAY
73333: PUSH
73334: LD_INT 2
73336: ARRAY
73337: PPUSH
73338: CALL_OW 297
73342: PUSH
73343: LD_INT 6
73345: GREATER
73346: IFFALSE 73421
// begin if not HasTask ( group [ i ] ) then
73348: LD_VAR 0 4
73352: PUSH
73353: LD_VAR 0 7
73357: ARRAY
73358: PPUSH
73359: CALL_OW 314
73363: NOT
73364: IFFALSE 73419
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
73366: LD_VAR 0 4
73370: PUSH
73371: LD_VAR 0 7
73375: ARRAY
73376: PPUSH
73377: LD_VAR 0 16
73381: PUSH
73382: LD_VAR 0 7
73386: ARRAY
73387: PUSH
73388: LD_INT 1
73390: ARRAY
73391: PUSH
73392: LD_INT 1
73394: ARRAY
73395: PPUSH
73396: LD_VAR 0 16
73400: PUSH
73401: LD_VAR 0 7
73405: ARRAY
73406: PUSH
73407: LD_INT 1
73409: ARRAY
73410: PUSH
73411: LD_INT 2
73413: ARRAY
73414: PPUSH
73415: CALL_OW 114
// end else
73419: GO 73472
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
73421: LD_ADDR_VAR 0 15
73425: PUSH
73426: LD_VAR 0 16
73430: PUSH
73431: LD_VAR 0 7
73435: ARRAY
73436: PPUSH
73437: LD_INT 1
73439: PPUSH
73440: CALL_OW 3
73444: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
73445: LD_ADDR_VAR 0 16
73449: PUSH
73450: LD_VAR 0 16
73454: PPUSH
73455: LD_VAR 0 7
73459: PPUSH
73460: LD_VAR 0 15
73464: PPUSH
73465: CALL_OW 1
73469: ST_TO_ADDR
// continue ;
73470: GO 72015
// end ; end ; end else
73472: GO 76136
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
73474: LD_ADDR_VAR 0 14
73478: PUSH
73479: LD_INT 81
73481: PUSH
73482: LD_VAR 0 4
73486: PUSH
73487: LD_VAR 0 7
73491: ARRAY
73492: PPUSH
73493: CALL_OW 255
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PPUSH
73502: CALL_OW 69
73506: ST_TO_ADDR
// if not tmp then
73507: LD_VAR 0 14
73511: NOT
73512: IFFALSE 73516
// continue ;
73514: GO 72015
// if f_ignore_area then
73516: LD_VAR 0 17
73520: IFFALSE 73608
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
73522: LD_ADDR_VAR 0 15
73526: PUSH
73527: LD_VAR 0 14
73531: PPUSH
73532: LD_INT 3
73534: PUSH
73535: LD_INT 92
73537: PUSH
73538: LD_VAR 0 17
73542: PUSH
73543: LD_INT 1
73545: ARRAY
73546: PUSH
73547: LD_VAR 0 17
73551: PUSH
73552: LD_INT 2
73554: ARRAY
73555: PUSH
73556: LD_VAR 0 17
73560: PUSH
73561: LD_INT 3
73563: ARRAY
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PPUSH
73575: CALL_OW 72
73579: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
73580: LD_VAR 0 14
73584: PUSH
73585: LD_VAR 0 15
73589: DIFF
73590: IFFALSE 73608
// tmp := tmp diff tmp2 ;
73592: LD_ADDR_VAR 0 14
73596: PUSH
73597: LD_VAR 0 14
73601: PUSH
73602: LD_VAR 0 15
73606: DIFF
73607: ST_TO_ADDR
// end ; if not f_murder then
73608: LD_VAR 0 20
73612: NOT
73613: IFFALSE 73671
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
73615: LD_ADDR_VAR 0 15
73619: PUSH
73620: LD_VAR 0 14
73624: PPUSH
73625: LD_INT 3
73627: PUSH
73628: LD_INT 50
73630: PUSH
73631: EMPTY
73632: LIST
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PPUSH
73638: CALL_OW 72
73642: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
73643: LD_VAR 0 14
73647: PUSH
73648: LD_VAR 0 15
73652: DIFF
73653: IFFALSE 73671
// tmp := tmp diff tmp2 ;
73655: LD_ADDR_VAR 0 14
73659: PUSH
73660: LD_VAR 0 14
73664: PUSH
73665: LD_VAR 0 15
73669: DIFF
73670: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
73671: LD_ADDR_VAR 0 14
73675: PUSH
73676: LD_VAR 0 4
73680: PUSH
73681: LD_VAR 0 7
73685: ARRAY
73686: PPUSH
73687: LD_VAR 0 14
73691: PPUSH
73692: LD_INT 1
73694: PPUSH
73695: LD_INT 1
73697: PPUSH
73698: CALL 9880 0 4
73702: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
73703: LD_VAR 0 4
73707: PUSH
73708: LD_VAR 0 7
73712: ARRAY
73713: PPUSH
73714: CALL_OW 257
73718: PUSH
73719: LD_INT 1
73721: EQUAL
73722: IFFALSE 74170
// begin if WantPlant ( group [ i ] ) then
73724: LD_VAR 0 4
73728: PUSH
73729: LD_VAR 0 7
73733: ARRAY
73734: PPUSH
73735: CALL 9381 0 1
73739: IFFALSE 73743
// continue ;
73741: GO 72015
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
73743: LD_VAR 0 18
73747: PUSH
73748: LD_VAR 0 4
73752: PUSH
73753: LD_VAR 0 7
73757: ARRAY
73758: PPUSH
73759: CALL_OW 310
73763: NOT
73764: AND
73765: PUSH
73766: LD_VAR 0 14
73770: PUSH
73771: LD_INT 1
73773: ARRAY
73774: PUSH
73775: LD_VAR 0 14
73779: PPUSH
73780: LD_INT 21
73782: PUSH
73783: LD_INT 2
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 58
73792: PUSH
73793: EMPTY
73794: LIST
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PPUSH
73800: CALL_OW 72
73804: IN
73805: AND
73806: IFFALSE 73842
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
73808: LD_VAR 0 4
73812: PUSH
73813: LD_VAR 0 7
73817: ARRAY
73818: PPUSH
73819: LD_VAR 0 14
73823: PUSH
73824: LD_INT 1
73826: ARRAY
73827: PPUSH
73828: CALL_OW 120
// attacking := true ;
73832: LD_ADDR_VAR 0 29
73836: PUSH
73837: LD_INT 1
73839: ST_TO_ADDR
// continue ;
73840: GO 72015
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
73842: LD_VAR 0 26
73846: PUSH
73847: LD_VAR 0 4
73851: PUSH
73852: LD_VAR 0 7
73856: ARRAY
73857: PPUSH
73858: CALL_OW 257
73862: PUSH
73863: LD_INT 1
73865: EQUAL
73866: AND
73867: PUSH
73868: LD_VAR 0 4
73872: PUSH
73873: LD_VAR 0 7
73877: ARRAY
73878: PPUSH
73879: CALL_OW 256
73883: PUSH
73884: LD_INT 800
73886: LESS
73887: AND
73888: PUSH
73889: LD_VAR 0 4
73893: PUSH
73894: LD_VAR 0 7
73898: ARRAY
73899: PPUSH
73900: CALL_OW 318
73904: NOT
73905: AND
73906: IFFALSE 73923
// ComCrawl ( group [ i ] ) ;
73908: LD_VAR 0 4
73912: PUSH
73913: LD_VAR 0 7
73917: ARRAY
73918: PPUSH
73919: CALL_OW 137
// if f_mines then
73923: LD_VAR 0 21
73927: IFFALSE 74170
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
73929: LD_VAR 0 14
73933: PUSH
73934: LD_INT 1
73936: ARRAY
73937: PPUSH
73938: CALL_OW 247
73942: PUSH
73943: LD_INT 3
73945: EQUAL
73946: PUSH
73947: LD_VAR 0 14
73951: PUSH
73952: LD_INT 1
73954: ARRAY
73955: PUSH
73956: LD_VAR 0 27
73960: IN
73961: NOT
73962: AND
73963: IFFALSE 74170
// begin x := GetX ( tmp [ 1 ] ) ;
73965: LD_ADDR_VAR 0 10
73969: PUSH
73970: LD_VAR 0 14
73974: PUSH
73975: LD_INT 1
73977: ARRAY
73978: PPUSH
73979: CALL_OW 250
73983: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
73984: LD_ADDR_VAR 0 11
73988: PUSH
73989: LD_VAR 0 14
73993: PUSH
73994: LD_INT 1
73996: ARRAY
73997: PPUSH
73998: CALL_OW 251
74002: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
74003: LD_ADDR_VAR 0 12
74007: PUSH
74008: LD_VAR 0 4
74012: PUSH
74013: LD_VAR 0 7
74017: ARRAY
74018: PPUSH
74019: CALL 36322 0 1
74023: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
74024: LD_VAR 0 4
74028: PUSH
74029: LD_VAR 0 7
74033: ARRAY
74034: PPUSH
74035: LD_VAR 0 10
74039: PPUSH
74040: LD_VAR 0 11
74044: PPUSH
74045: LD_VAR 0 14
74049: PUSH
74050: LD_INT 1
74052: ARRAY
74053: PPUSH
74054: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
74058: LD_VAR 0 4
74062: PUSH
74063: LD_VAR 0 7
74067: ARRAY
74068: PPUSH
74069: LD_VAR 0 10
74073: PPUSH
74074: LD_VAR 0 12
74078: PPUSH
74079: LD_INT 7
74081: PPUSH
74082: CALL_OW 272
74086: PPUSH
74087: LD_VAR 0 11
74091: PPUSH
74092: LD_VAR 0 12
74096: PPUSH
74097: LD_INT 7
74099: PPUSH
74100: CALL_OW 273
74104: PPUSH
74105: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
74109: LD_VAR 0 4
74113: PUSH
74114: LD_VAR 0 7
74118: ARRAY
74119: PPUSH
74120: LD_INT 71
74122: PPUSH
74123: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
74127: LD_ADDR_VAR 0 27
74131: PUSH
74132: LD_VAR 0 27
74136: PPUSH
74137: LD_VAR 0 27
74141: PUSH
74142: LD_INT 1
74144: PLUS
74145: PPUSH
74146: LD_VAR 0 14
74150: PUSH
74151: LD_INT 1
74153: ARRAY
74154: PPUSH
74155: CALL_OW 1
74159: ST_TO_ADDR
// attacking := true ;
74160: LD_ADDR_VAR 0 29
74164: PUSH
74165: LD_INT 1
74167: ST_TO_ADDR
// continue ;
74168: GO 72015
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
74170: LD_VAR 0 4
74174: PUSH
74175: LD_VAR 0 7
74179: ARRAY
74180: PPUSH
74181: CALL_OW 257
74185: PUSH
74186: LD_INT 17
74188: EQUAL
74189: PUSH
74190: LD_VAR 0 4
74194: PUSH
74195: LD_VAR 0 7
74199: ARRAY
74200: PPUSH
74201: CALL_OW 110
74205: PUSH
74206: LD_INT 71
74208: EQUAL
74209: NOT
74210: AND
74211: IFFALSE 74357
// begin attacking := false ;
74213: LD_ADDR_VAR 0 29
74217: PUSH
74218: LD_INT 0
74220: ST_TO_ADDR
// k := 5 ;
74221: LD_ADDR_VAR 0 9
74225: PUSH
74226: LD_INT 5
74228: ST_TO_ADDR
// if tmp < k then
74229: LD_VAR 0 14
74233: PUSH
74234: LD_VAR 0 9
74238: LESS
74239: IFFALSE 74251
// k := tmp ;
74241: LD_ADDR_VAR 0 9
74245: PUSH
74246: LD_VAR 0 14
74250: ST_TO_ADDR
// for j = 1 to k do
74251: LD_ADDR_VAR 0 8
74255: PUSH
74256: DOUBLE
74257: LD_INT 1
74259: DEC
74260: ST_TO_ADDR
74261: LD_VAR 0 9
74265: PUSH
74266: FOR_TO
74267: IFFALSE 74355
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
74269: LD_VAR 0 14
74273: PUSH
74274: LD_VAR 0 8
74278: ARRAY
74279: PUSH
74280: LD_VAR 0 14
74284: PPUSH
74285: LD_INT 58
74287: PUSH
74288: EMPTY
74289: LIST
74290: PPUSH
74291: CALL_OW 72
74295: IN
74296: NOT
74297: IFFALSE 74353
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
74299: LD_VAR 0 4
74303: PUSH
74304: LD_VAR 0 7
74308: ARRAY
74309: PPUSH
74310: LD_VAR 0 14
74314: PUSH
74315: LD_VAR 0 8
74319: ARRAY
74320: PPUSH
74321: CALL_OW 115
// attacking := true ;
74325: LD_ADDR_VAR 0 29
74329: PUSH
74330: LD_INT 1
74332: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
74333: LD_VAR 0 4
74337: PUSH
74338: LD_VAR 0 7
74342: ARRAY
74343: PPUSH
74344: LD_INT 71
74346: PPUSH
74347: CALL_OW 109
// continue ;
74351: GO 74266
// end ; end ;
74353: GO 74266
74355: POP
74356: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
74357: LD_VAR 0 4
74361: PUSH
74362: LD_VAR 0 7
74366: ARRAY
74367: PPUSH
74368: CALL_OW 257
74372: PUSH
74373: LD_INT 8
74375: EQUAL
74376: PUSH
74377: LD_VAR 0 4
74381: PUSH
74382: LD_VAR 0 7
74386: ARRAY
74387: PPUSH
74388: CALL_OW 264
74392: PUSH
74393: LD_INT 28
74395: PUSH
74396: LD_INT 45
74398: PUSH
74399: LD_INT 7
74401: PUSH
74402: LD_INT 47
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: IN
74411: OR
74412: IFFALSE 74668
// begin attacking := false ;
74414: LD_ADDR_VAR 0 29
74418: PUSH
74419: LD_INT 0
74421: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
74422: LD_VAR 0 14
74426: PUSH
74427: LD_INT 1
74429: ARRAY
74430: PPUSH
74431: CALL_OW 266
74435: PUSH
74436: LD_INT 32
74438: PUSH
74439: LD_INT 31
74441: PUSH
74442: LD_INT 33
74444: PUSH
74445: LD_INT 4
74447: PUSH
74448: LD_INT 5
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: IN
74458: IFFALSE 74644
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
74460: LD_ADDR_VAR 0 9
74464: PUSH
74465: LD_VAR 0 14
74469: PUSH
74470: LD_INT 1
74472: ARRAY
74473: PPUSH
74474: CALL_OW 266
74478: PPUSH
74479: LD_VAR 0 14
74483: PUSH
74484: LD_INT 1
74486: ARRAY
74487: PPUSH
74488: CALL_OW 250
74492: PPUSH
74493: LD_VAR 0 14
74497: PUSH
74498: LD_INT 1
74500: ARRAY
74501: PPUSH
74502: CALL_OW 251
74506: PPUSH
74507: LD_VAR 0 14
74511: PUSH
74512: LD_INT 1
74514: ARRAY
74515: PPUSH
74516: CALL_OW 254
74520: PPUSH
74521: LD_VAR 0 14
74525: PUSH
74526: LD_INT 1
74528: ARRAY
74529: PPUSH
74530: CALL_OW 248
74534: PPUSH
74535: LD_INT 0
74537: PPUSH
74538: CALL 17692 0 6
74542: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
74543: LD_ADDR_VAR 0 8
74547: PUSH
74548: LD_VAR 0 4
74552: PUSH
74553: LD_VAR 0 7
74557: ARRAY
74558: PPUSH
74559: LD_VAR 0 9
74563: PPUSH
74564: CALL 36362 0 2
74568: ST_TO_ADDR
// if j then
74569: LD_VAR 0 8
74573: IFFALSE 74642
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74575: LD_VAR 0 8
74579: PUSH
74580: LD_INT 1
74582: ARRAY
74583: PPUSH
74584: LD_VAR 0 8
74588: PUSH
74589: LD_INT 2
74591: ARRAY
74592: PPUSH
74593: CALL_OW 488
74597: IFFALSE 74642
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
74599: LD_VAR 0 4
74603: PUSH
74604: LD_VAR 0 7
74608: ARRAY
74609: PPUSH
74610: LD_VAR 0 8
74614: PUSH
74615: LD_INT 1
74617: ARRAY
74618: PPUSH
74619: LD_VAR 0 8
74623: PUSH
74624: LD_INT 2
74626: ARRAY
74627: PPUSH
74628: CALL_OW 116
// attacking := true ;
74632: LD_ADDR_VAR 0 29
74636: PUSH
74637: LD_INT 1
74639: ST_TO_ADDR
// continue ;
74640: GO 72015
// end ; end else
74642: GO 74668
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
74644: LD_VAR 0 4
74648: PUSH
74649: LD_VAR 0 7
74653: ARRAY
74654: PPUSH
74655: LD_VAR 0 14
74659: PUSH
74660: LD_INT 1
74662: ARRAY
74663: PPUSH
74664: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
74668: LD_VAR 0 4
74672: PUSH
74673: LD_VAR 0 7
74677: ARRAY
74678: PPUSH
74679: CALL_OW 265
74683: PUSH
74684: LD_INT 11
74686: EQUAL
74687: IFFALSE 74965
// begin k := 10 ;
74689: LD_ADDR_VAR 0 9
74693: PUSH
74694: LD_INT 10
74696: ST_TO_ADDR
// x := 0 ;
74697: LD_ADDR_VAR 0 10
74701: PUSH
74702: LD_INT 0
74704: ST_TO_ADDR
// if tmp < k then
74705: LD_VAR 0 14
74709: PUSH
74710: LD_VAR 0 9
74714: LESS
74715: IFFALSE 74727
// k := tmp ;
74717: LD_ADDR_VAR 0 9
74721: PUSH
74722: LD_VAR 0 14
74726: ST_TO_ADDR
// for j = k downto 1 do
74727: LD_ADDR_VAR 0 8
74731: PUSH
74732: DOUBLE
74733: LD_VAR 0 9
74737: INC
74738: ST_TO_ADDR
74739: LD_INT 1
74741: PUSH
74742: FOR_DOWNTO
74743: IFFALSE 74818
// begin if GetType ( tmp [ j ] ) = unit_human then
74745: LD_VAR 0 14
74749: PUSH
74750: LD_VAR 0 8
74754: ARRAY
74755: PPUSH
74756: CALL_OW 247
74760: PUSH
74761: LD_INT 1
74763: EQUAL
74764: IFFALSE 74816
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
74766: LD_VAR 0 4
74770: PUSH
74771: LD_VAR 0 7
74775: ARRAY
74776: PPUSH
74777: LD_VAR 0 14
74781: PUSH
74782: LD_VAR 0 8
74786: ARRAY
74787: PPUSH
74788: CALL 36633 0 2
// x := tmp [ j ] ;
74792: LD_ADDR_VAR 0 10
74796: PUSH
74797: LD_VAR 0 14
74801: PUSH
74802: LD_VAR 0 8
74806: ARRAY
74807: ST_TO_ADDR
// attacking := true ;
74808: LD_ADDR_VAR 0 29
74812: PUSH
74813: LD_INT 1
74815: ST_TO_ADDR
// end ; end ;
74816: GO 74742
74818: POP
74819: POP
// if not x then
74820: LD_VAR 0 10
74824: NOT
74825: IFFALSE 74965
// begin attacking := true ;
74827: LD_ADDR_VAR 0 29
74831: PUSH
74832: LD_INT 1
74834: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
74835: LD_VAR 0 4
74839: PUSH
74840: LD_VAR 0 7
74844: ARRAY
74845: PPUSH
74846: CALL_OW 250
74850: PPUSH
74851: LD_VAR 0 4
74855: PUSH
74856: LD_VAR 0 7
74860: ARRAY
74861: PPUSH
74862: CALL_OW 251
74866: PPUSH
74867: CALL_OW 546
74871: PUSH
74872: LD_INT 2
74874: ARRAY
74875: PUSH
74876: LD_VAR 0 14
74880: PUSH
74881: LD_INT 1
74883: ARRAY
74884: PPUSH
74885: CALL_OW 250
74889: PPUSH
74890: LD_VAR 0 14
74894: PUSH
74895: LD_INT 1
74897: ARRAY
74898: PPUSH
74899: CALL_OW 251
74903: PPUSH
74904: CALL_OW 546
74908: PUSH
74909: LD_INT 2
74911: ARRAY
74912: EQUAL
74913: IFFALSE 74941
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
74915: LD_VAR 0 4
74919: PUSH
74920: LD_VAR 0 7
74924: ARRAY
74925: PPUSH
74926: LD_VAR 0 14
74930: PUSH
74931: LD_INT 1
74933: ARRAY
74934: PPUSH
74935: CALL 36633 0 2
74939: GO 74965
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
74941: LD_VAR 0 4
74945: PUSH
74946: LD_VAR 0 7
74950: ARRAY
74951: PPUSH
74952: LD_VAR 0 14
74956: PUSH
74957: LD_INT 1
74959: ARRAY
74960: PPUSH
74961: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
74965: LD_VAR 0 4
74969: PUSH
74970: LD_VAR 0 7
74974: ARRAY
74975: PPUSH
74976: CALL_OW 264
74980: PUSH
74981: LD_INT 29
74983: EQUAL
74984: IFFALSE 75350
// begin if WantsToAttack ( group [ i ] ) in bombed then
74986: LD_VAR 0 4
74990: PUSH
74991: LD_VAR 0 7
74995: ARRAY
74996: PPUSH
74997: CALL_OW 319
75001: PUSH
75002: LD_VAR 0 28
75006: IN
75007: IFFALSE 75011
// continue ;
75009: GO 72015
// k := 8 ;
75011: LD_ADDR_VAR 0 9
75015: PUSH
75016: LD_INT 8
75018: ST_TO_ADDR
// x := 0 ;
75019: LD_ADDR_VAR 0 10
75023: PUSH
75024: LD_INT 0
75026: ST_TO_ADDR
// if tmp < k then
75027: LD_VAR 0 14
75031: PUSH
75032: LD_VAR 0 9
75036: LESS
75037: IFFALSE 75049
// k := tmp ;
75039: LD_ADDR_VAR 0 9
75043: PUSH
75044: LD_VAR 0 14
75048: ST_TO_ADDR
// for j = 1 to k do
75049: LD_ADDR_VAR 0 8
75053: PUSH
75054: DOUBLE
75055: LD_INT 1
75057: DEC
75058: ST_TO_ADDR
75059: LD_VAR 0 9
75063: PUSH
75064: FOR_TO
75065: IFFALSE 75197
// begin if GetType ( tmp [ j ] ) = unit_building then
75067: LD_VAR 0 14
75071: PUSH
75072: LD_VAR 0 8
75076: ARRAY
75077: PPUSH
75078: CALL_OW 247
75082: PUSH
75083: LD_INT 3
75085: EQUAL
75086: IFFALSE 75195
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
75088: LD_VAR 0 14
75092: PUSH
75093: LD_VAR 0 8
75097: ARRAY
75098: PUSH
75099: LD_VAR 0 28
75103: IN
75104: NOT
75105: PUSH
75106: LD_VAR 0 14
75110: PUSH
75111: LD_VAR 0 8
75115: ARRAY
75116: PPUSH
75117: CALL_OW 313
75121: AND
75122: IFFALSE 75195
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75124: LD_VAR 0 4
75128: PUSH
75129: LD_VAR 0 7
75133: ARRAY
75134: PPUSH
75135: LD_VAR 0 14
75139: PUSH
75140: LD_VAR 0 8
75144: ARRAY
75145: PPUSH
75146: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
75150: LD_ADDR_VAR 0 28
75154: PUSH
75155: LD_VAR 0 28
75159: PPUSH
75160: LD_VAR 0 28
75164: PUSH
75165: LD_INT 1
75167: PLUS
75168: PPUSH
75169: LD_VAR 0 14
75173: PUSH
75174: LD_VAR 0 8
75178: ARRAY
75179: PPUSH
75180: CALL_OW 1
75184: ST_TO_ADDR
// attacking := true ;
75185: LD_ADDR_VAR 0 29
75189: PUSH
75190: LD_INT 1
75192: ST_TO_ADDR
// break ;
75193: GO 75197
// end ; end ;
75195: GO 75064
75197: POP
75198: POP
// if not attacking and f_attack_depot then
75199: LD_VAR 0 29
75203: NOT
75204: PUSH
75205: LD_VAR 0 25
75209: AND
75210: IFFALSE 75305
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75212: LD_ADDR_VAR 0 13
75216: PUSH
75217: LD_VAR 0 14
75221: PPUSH
75222: LD_INT 2
75224: PUSH
75225: LD_INT 30
75227: PUSH
75228: LD_INT 0
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 30
75237: PUSH
75238: LD_INT 1
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: LIST
75249: PPUSH
75250: CALL_OW 72
75254: ST_TO_ADDR
// if z then
75255: LD_VAR 0 13
75259: IFFALSE 75305
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
75261: LD_VAR 0 4
75265: PUSH
75266: LD_VAR 0 7
75270: ARRAY
75271: PPUSH
75272: LD_VAR 0 13
75276: PPUSH
75277: LD_VAR 0 4
75281: PUSH
75282: LD_VAR 0 7
75286: ARRAY
75287: PPUSH
75288: CALL_OW 74
75292: PPUSH
75293: CALL_OW 115
// attacking := true ;
75297: LD_ADDR_VAR 0 29
75301: PUSH
75302: LD_INT 1
75304: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
75305: LD_VAR 0 4
75309: PUSH
75310: LD_VAR 0 7
75314: ARRAY
75315: PPUSH
75316: CALL_OW 256
75320: PUSH
75321: LD_INT 500
75323: LESS
75324: IFFALSE 75350
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75326: LD_VAR 0 4
75330: PUSH
75331: LD_VAR 0 7
75335: ARRAY
75336: PPUSH
75337: LD_VAR 0 14
75341: PUSH
75342: LD_INT 1
75344: ARRAY
75345: PPUSH
75346: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
75350: LD_VAR 0 4
75354: PUSH
75355: LD_VAR 0 7
75359: ARRAY
75360: PPUSH
75361: CALL_OW 264
75365: PUSH
75366: LD_INT 49
75368: EQUAL
75369: IFFALSE 75490
// begin if not HasTask ( group [ i ] ) then
75371: LD_VAR 0 4
75375: PUSH
75376: LD_VAR 0 7
75380: ARRAY
75381: PPUSH
75382: CALL_OW 314
75386: NOT
75387: IFFALSE 75490
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
75389: LD_ADDR_VAR 0 9
75393: PUSH
75394: LD_INT 81
75396: PUSH
75397: LD_VAR 0 4
75401: PUSH
75402: LD_VAR 0 7
75406: ARRAY
75407: PPUSH
75408: CALL_OW 255
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PPUSH
75417: CALL_OW 69
75421: PPUSH
75422: LD_VAR 0 4
75426: PUSH
75427: LD_VAR 0 7
75431: ARRAY
75432: PPUSH
75433: CALL_OW 74
75437: ST_TO_ADDR
// if k then
75438: LD_VAR 0 9
75442: IFFALSE 75490
// if GetDistUnits ( group [ i ] , k ) > 10 then
75444: LD_VAR 0 4
75448: PUSH
75449: LD_VAR 0 7
75453: ARRAY
75454: PPUSH
75455: LD_VAR 0 9
75459: PPUSH
75460: CALL_OW 296
75464: PUSH
75465: LD_INT 10
75467: GREATER
75468: IFFALSE 75490
// ComMoveUnit ( group [ i ] , k ) ;
75470: LD_VAR 0 4
75474: PUSH
75475: LD_VAR 0 7
75479: ARRAY
75480: PPUSH
75481: LD_VAR 0 9
75485: PPUSH
75486: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
75490: LD_VAR 0 4
75494: PUSH
75495: LD_VAR 0 7
75499: ARRAY
75500: PPUSH
75501: CALL_OW 256
75505: PUSH
75506: LD_INT 250
75508: LESS
75509: PUSH
75510: LD_VAR 0 4
75514: PUSH
75515: LD_VAR 0 7
75519: ARRAY
75520: PUSH
75521: LD_INT 21
75523: PUSH
75524: LD_INT 2
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 23
75533: PUSH
75534: LD_INT 2
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PPUSH
75545: CALL_OW 69
75549: IN
75550: AND
75551: IFFALSE 75676
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
75553: LD_ADDR_VAR 0 9
75557: PUSH
75558: LD_OWVAR 3
75562: PUSH
75563: LD_VAR 0 4
75567: PUSH
75568: LD_VAR 0 7
75572: ARRAY
75573: DIFF
75574: PPUSH
75575: LD_VAR 0 4
75579: PUSH
75580: LD_VAR 0 7
75584: ARRAY
75585: PPUSH
75586: CALL_OW 74
75590: ST_TO_ADDR
// if not k then
75591: LD_VAR 0 9
75595: NOT
75596: IFFALSE 75600
// continue ;
75598: GO 72015
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
75600: LD_VAR 0 9
75604: PUSH
75605: LD_INT 81
75607: PUSH
75608: LD_VAR 0 4
75612: PUSH
75613: LD_VAR 0 7
75617: ARRAY
75618: PPUSH
75619: CALL_OW 255
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PPUSH
75628: CALL_OW 69
75632: IN
75633: PUSH
75634: LD_VAR 0 9
75638: PPUSH
75639: LD_VAR 0 4
75643: PUSH
75644: LD_VAR 0 7
75648: ARRAY
75649: PPUSH
75650: CALL_OW 296
75654: PUSH
75655: LD_INT 5
75657: LESS
75658: AND
75659: IFFALSE 75676
// ComAutodestruct ( group [ i ] ) ;
75661: LD_VAR 0 4
75665: PUSH
75666: LD_VAR 0 7
75670: ARRAY
75671: PPUSH
75672: CALL 36531 0 1
// end ; if f_attack_depot then
75676: LD_VAR 0 25
75680: IFFALSE 75792
// begin k := 6 ;
75682: LD_ADDR_VAR 0 9
75686: PUSH
75687: LD_INT 6
75689: ST_TO_ADDR
// if tmp < k then
75690: LD_VAR 0 14
75694: PUSH
75695: LD_VAR 0 9
75699: LESS
75700: IFFALSE 75712
// k := tmp ;
75702: LD_ADDR_VAR 0 9
75706: PUSH
75707: LD_VAR 0 14
75711: ST_TO_ADDR
// for j = 1 to k do
75712: LD_ADDR_VAR 0 8
75716: PUSH
75717: DOUBLE
75718: LD_INT 1
75720: DEC
75721: ST_TO_ADDR
75722: LD_VAR 0 9
75726: PUSH
75727: FOR_TO
75728: IFFALSE 75790
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
75730: LD_VAR 0 8
75734: PPUSH
75735: CALL_OW 266
75739: PUSH
75740: LD_INT 0
75742: PUSH
75743: LD_INT 1
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: IN
75750: IFFALSE 75788
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75752: LD_VAR 0 4
75756: PUSH
75757: LD_VAR 0 7
75761: ARRAY
75762: PPUSH
75763: LD_VAR 0 14
75767: PUSH
75768: LD_VAR 0 8
75772: ARRAY
75773: PPUSH
75774: CALL_OW 115
// attacking := true ;
75778: LD_ADDR_VAR 0 29
75782: PUSH
75783: LD_INT 1
75785: ST_TO_ADDR
// break ;
75786: GO 75790
// end ;
75788: GO 75727
75790: POP
75791: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
75792: LD_VAR 0 4
75796: PUSH
75797: LD_VAR 0 7
75801: ARRAY
75802: PPUSH
75803: CALL_OW 302
75807: PUSH
75808: LD_VAR 0 29
75812: NOT
75813: AND
75814: IFFALSE 76136
// begin if GetTag ( group [ i ] ) = 71 then
75816: LD_VAR 0 4
75820: PUSH
75821: LD_VAR 0 7
75825: ARRAY
75826: PPUSH
75827: CALL_OW 110
75831: PUSH
75832: LD_INT 71
75834: EQUAL
75835: IFFALSE 75876
// begin if HasTask ( group [ i ] ) then
75837: LD_VAR 0 4
75841: PUSH
75842: LD_VAR 0 7
75846: ARRAY
75847: PPUSH
75848: CALL_OW 314
75852: IFFALSE 75858
// continue else
75854: GO 72015
75856: GO 75876
// SetTag ( group [ i ] , 0 ) ;
75858: LD_VAR 0 4
75862: PUSH
75863: LD_VAR 0 7
75867: ARRAY
75868: PPUSH
75869: LD_INT 0
75871: PPUSH
75872: CALL_OW 109
// end ; k := 8 ;
75876: LD_ADDR_VAR 0 9
75880: PUSH
75881: LD_INT 8
75883: ST_TO_ADDR
// x := 0 ;
75884: LD_ADDR_VAR 0 10
75888: PUSH
75889: LD_INT 0
75891: ST_TO_ADDR
// if tmp < k then
75892: LD_VAR 0 14
75896: PUSH
75897: LD_VAR 0 9
75901: LESS
75902: IFFALSE 75914
// k := tmp ;
75904: LD_ADDR_VAR 0 9
75908: PUSH
75909: LD_VAR 0 14
75913: ST_TO_ADDR
// for j = 1 to k do
75914: LD_ADDR_VAR 0 8
75918: PUSH
75919: DOUBLE
75920: LD_INT 1
75922: DEC
75923: ST_TO_ADDR
75924: LD_VAR 0 9
75928: PUSH
75929: FOR_TO
75930: IFFALSE 76028
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
75932: LD_VAR 0 14
75936: PUSH
75937: LD_VAR 0 8
75941: ARRAY
75942: PPUSH
75943: CALL_OW 247
75947: PUSH
75948: LD_INT 1
75950: EQUAL
75951: PUSH
75952: LD_VAR 0 14
75956: PUSH
75957: LD_VAR 0 8
75961: ARRAY
75962: PPUSH
75963: CALL_OW 256
75967: PUSH
75968: LD_INT 250
75970: LESS
75971: PUSH
75972: LD_VAR 0 20
75976: AND
75977: PUSH
75978: LD_VAR 0 20
75982: NOT
75983: PUSH
75984: LD_VAR 0 14
75988: PUSH
75989: LD_VAR 0 8
75993: ARRAY
75994: PPUSH
75995: CALL_OW 256
75999: PUSH
76000: LD_INT 250
76002: GREATEREQUAL
76003: AND
76004: OR
76005: AND
76006: IFFALSE 76026
// begin x := tmp [ j ] ;
76008: LD_ADDR_VAR 0 10
76012: PUSH
76013: LD_VAR 0 14
76017: PUSH
76018: LD_VAR 0 8
76022: ARRAY
76023: ST_TO_ADDR
// break ;
76024: GO 76028
// end ;
76026: GO 75929
76028: POP
76029: POP
// if x then
76030: LD_VAR 0 10
76034: IFFALSE 76058
// ComAttackUnit ( group [ i ] , x ) else
76036: LD_VAR 0 4
76040: PUSH
76041: LD_VAR 0 7
76045: ARRAY
76046: PPUSH
76047: LD_VAR 0 10
76051: PPUSH
76052: CALL_OW 115
76056: GO 76082
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76058: LD_VAR 0 4
76062: PUSH
76063: LD_VAR 0 7
76067: ARRAY
76068: PPUSH
76069: LD_VAR 0 14
76073: PUSH
76074: LD_INT 1
76076: ARRAY
76077: PPUSH
76078: CALL_OW 115
// if not HasTask ( group [ i ] ) then
76082: LD_VAR 0 4
76086: PUSH
76087: LD_VAR 0 7
76091: ARRAY
76092: PPUSH
76093: CALL_OW 314
76097: NOT
76098: IFFALSE 76136
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
76100: LD_VAR 0 4
76104: PUSH
76105: LD_VAR 0 7
76109: ARRAY
76110: PPUSH
76111: LD_VAR 0 14
76115: PPUSH
76116: LD_VAR 0 4
76120: PUSH
76121: LD_VAR 0 7
76125: ARRAY
76126: PPUSH
76127: CALL_OW 74
76131: PPUSH
76132: CALL_OW 115
// end ; end ; end ;
76136: GO 72015
76138: POP
76139: POP
// wait ( 0 0$2 ) ;
76140: LD_INT 70
76142: PPUSH
76143: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
76147: LD_VAR 0 4
76151: NOT
76152: PUSH
76153: LD_VAR 0 4
76157: PUSH
76158: EMPTY
76159: EQUAL
76160: OR
76161: PUSH
76162: LD_INT 81
76164: PUSH
76165: LD_VAR 0 35
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PPUSH
76174: CALL_OW 69
76178: NOT
76179: OR
76180: IFFALSE 72000
// end ;
76182: LD_VAR 0 2
76186: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
76187: LD_INT 0
76189: PPUSH
76190: PPUSH
76191: PPUSH
76192: PPUSH
76193: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
76194: LD_VAR 0 1
76198: NOT
76199: PUSH
76200: LD_EXP 14
76204: PUSH
76205: LD_VAR 0 1
76209: ARRAY
76210: NOT
76211: OR
76212: PUSH
76213: LD_VAR 0 2
76217: NOT
76218: OR
76219: PUSH
76220: LD_VAR 0 3
76224: NOT
76225: OR
76226: IFFALSE 76230
// exit ;
76228: GO 76743
// side := mc_sides [ base ] ;
76230: LD_ADDR_VAR 0 6
76234: PUSH
76235: LD_EXP 40
76239: PUSH
76240: LD_VAR 0 1
76244: ARRAY
76245: ST_TO_ADDR
// if not side then
76246: LD_VAR 0 6
76250: NOT
76251: IFFALSE 76255
// exit ;
76253: GO 76743
// for i in solds do
76255: LD_ADDR_VAR 0 7
76259: PUSH
76260: LD_VAR 0 2
76264: PUSH
76265: FOR_IN
76266: IFFALSE 76327
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
76268: LD_VAR 0 7
76272: PPUSH
76273: CALL_OW 310
76277: PPUSH
76278: CALL_OW 266
76282: PUSH
76283: LD_INT 32
76285: PUSH
76286: LD_INT 31
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: IN
76293: IFFALSE 76313
// solds := solds diff i else
76295: LD_ADDR_VAR 0 2
76299: PUSH
76300: LD_VAR 0 2
76304: PUSH
76305: LD_VAR 0 7
76309: DIFF
76310: ST_TO_ADDR
76311: GO 76325
// SetTag ( i , 18 ) ;
76313: LD_VAR 0 7
76317: PPUSH
76318: LD_INT 18
76320: PPUSH
76321: CALL_OW 109
76325: GO 76265
76327: POP
76328: POP
// if not solds then
76329: LD_VAR 0 2
76333: NOT
76334: IFFALSE 76338
// exit ;
76336: GO 76743
// repeat wait ( 0 0$1 ) ;
76338: LD_INT 35
76340: PPUSH
76341: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
76345: LD_ADDR_VAR 0 5
76349: PUSH
76350: LD_VAR 0 6
76354: PPUSH
76355: LD_VAR 0 3
76359: PPUSH
76360: CALL 6246 0 2
76364: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
76365: LD_EXP 14
76369: PUSH
76370: LD_VAR 0 1
76374: ARRAY
76375: NOT
76376: PUSH
76377: LD_EXP 14
76381: PUSH
76382: LD_VAR 0 1
76386: ARRAY
76387: PUSH
76388: EMPTY
76389: EQUAL
76390: OR
76391: IFFALSE 76428
// begin for i in solds do
76393: LD_ADDR_VAR 0 7
76397: PUSH
76398: LD_VAR 0 2
76402: PUSH
76403: FOR_IN
76404: IFFALSE 76417
// ComStop ( i ) ;
76406: LD_VAR 0 7
76410: PPUSH
76411: CALL_OW 141
76415: GO 76403
76417: POP
76418: POP
// solds := [ ] ;
76419: LD_ADDR_VAR 0 2
76423: PUSH
76424: EMPTY
76425: ST_TO_ADDR
// exit ;
76426: GO 76743
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
76428: LD_VAR 0 5
76432: NOT
76433: PUSH
76434: LD_VAR 0 5
76438: PUSH
76439: LD_INT 3
76441: GREATER
76442: OR
76443: PUSH
76444: LD_EXP 36
76448: PUSH
76449: LD_VAR 0 1
76453: ARRAY
76454: OR
76455: IFFALSE 76496
// begin for i in solds do
76457: LD_ADDR_VAR 0 7
76461: PUSH
76462: LD_VAR 0 2
76466: PUSH
76467: FOR_IN
76468: IFFALSE 76492
// if HasTask ( i ) then
76470: LD_VAR 0 7
76474: PPUSH
76475: CALL_OW 314
76479: IFFALSE 76490
// ComStop ( i ) ;
76481: LD_VAR 0 7
76485: PPUSH
76486: CALL_OW 141
76490: GO 76467
76492: POP
76493: POP
// break ;
76494: GO 76731
// end ; for i in solds do
76496: LD_ADDR_VAR 0 7
76500: PUSH
76501: LD_VAR 0 2
76505: PUSH
76506: FOR_IN
76507: IFFALSE 76723
// begin if IsInUnit ( i ) then
76509: LD_VAR 0 7
76513: PPUSH
76514: CALL_OW 310
76518: IFFALSE 76529
// ComExitBuilding ( i ) ;
76520: LD_VAR 0 7
76524: PPUSH
76525: CALL_OW 122
// if GetLives ( i ) > 333 then
76529: LD_VAR 0 7
76533: PPUSH
76534: CALL_OW 256
76538: PUSH
76539: LD_INT 333
76541: GREATER
76542: IFFALSE 76570
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
76544: LD_VAR 0 7
76548: PPUSH
76549: LD_VAR 0 5
76553: PPUSH
76554: LD_VAR 0 7
76558: PPUSH
76559: CALL_OW 74
76563: PPUSH
76564: CALL_OW 115
76568: GO 76721
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
76570: LD_ADDR_VAR 0 8
76574: PUSH
76575: LD_EXP 14
76579: PUSH
76580: LD_VAR 0 1
76584: ARRAY
76585: PPUSH
76586: LD_INT 2
76588: PUSH
76589: LD_INT 30
76591: PUSH
76592: LD_INT 0
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 30
76601: PUSH
76602: LD_INT 1
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 30
76611: PUSH
76612: LD_INT 6
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: LIST
76623: LIST
76624: PPUSH
76625: CALL_OW 72
76629: PPUSH
76630: LD_VAR 0 7
76634: PPUSH
76635: CALL_OW 74
76639: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
76640: LD_VAR 0 7
76644: PPUSH
76645: LD_VAR 0 8
76649: PPUSH
76650: CALL_OW 250
76654: PPUSH
76655: LD_INT 3
76657: PPUSH
76658: LD_INT 5
76660: PPUSH
76661: CALL_OW 272
76665: PPUSH
76666: LD_VAR 0 8
76670: PPUSH
76671: CALL_OW 251
76675: PPUSH
76676: LD_INT 3
76678: PPUSH
76679: LD_INT 5
76681: PPUSH
76682: CALL_OW 273
76686: PPUSH
76687: CALL_OW 111
// SetTag ( i , 0 ) ;
76691: LD_VAR 0 7
76695: PPUSH
76696: LD_INT 0
76698: PPUSH
76699: CALL_OW 109
// solds := solds diff i ;
76703: LD_ADDR_VAR 0 2
76707: PUSH
76708: LD_VAR 0 2
76712: PUSH
76713: LD_VAR 0 7
76717: DIFF
76718: ST_TO_ADDR
// continue ;
76719: GO 76506
// end ; end ;
76721: GO 76506
76723: POP
76724: POP
// until solds ;
76725: LD_VAR 0 2
76729: IFFALSE 76338
// MC_Reset ( base , 18 ) ;
76731: LD_VAR 0 1
76735: PPUSH
76736: LD_INT 18
76738: PPUSH
76739: CALL 45389 0 2
// end ;
76743: LD_VAR 0 4
76747: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
76748: LD_INT 0
76750: PPUSH
76751: PPUSH
76752: PPUSH
76753: PPUSH
76754: PPUSH
76755: PPUSH
76756: PPUSH
76757: PPUSH
76758: PPUSH
76759: PPUSH
76760: PPUSH
76761: PPUSH
76762: PPUSH
76763: PPUSH
76764: PPUSH
76765: PPUSH
76766: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
76767: LD_ADDR_VAR 0 13
76771: PUSH
76772: LD_EXP 14
76776: PUSH
76777: LD_VAR 0 1
76781: ARRAY
76782: PPUSH
76783: LD_INT 25
76785: PUSH
76786: LD_INT 3
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PPUSH
76793: CALL_OW 72
76797: ST_TO_ADDR
// if mc_remote_driver [ base ] then
76798: LD_EXP 54
76802: PUSH
76803: LD_VAR 0 1
76807: ARRAY
76808: IFFALSE 76832
// mechs := mechs diff mc_remote_driver [ base ] ;
76810: LD_ADDR_VAR 0 13
76814: PUSH
76815: LD_VAR 0 13
76819: PUSH
76820: LD_EXP 54
76824: PUSH
76825: LD_VAR 0 1
76829: ARRAY
76830: DIFF
76831: ST_TO_ADDR
// for i in mechs do
76832: LD_ADDR_VAR 0 5
76836: PUSH
76837: LD_VAR 0 13
76841: PUSH
76842: FOR_IN
76843: IFFALSE 76878
// if GetTag ( i ) > 0 then
76845: LD_VAR 0 5
76849: PPUSH
76850: CALL_OW 110
76854: PUSH
76855: LD_INT 0
76857: GREATER
76858: IFFALSE 76876
// mechs := mechs diff i ;
76860: LD_ADDR_VAR 0 13
76864: PUSH
76865: LD_VAR 0 13
76869: PUSH
76870: LD_VAR 0 5
76874: DIFF
76875: ST_TO_ADDR
76876: GO 76842
76878: POP
76879: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76880: LD_ADDR_VAR 0 9
76884: PUSH
76885: LD_EXP 14
76889: PUSH
76890: LD_VAR 0 1
76894: ARRAY
76895: PPUSH
76896: LD_INT 2
76898: PUSH
76899: LD_INT 25
76901: PUSH
76902: LD_INT 1
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 25
76911: PUSH
76912: LD_INT 5
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 25
76921: PUSH
76922: LD_INT 8
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 25
76931: PUSH
76932: LD_INT 9
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: PPUSH
76946: CALL_OW 72
76950: ST_TO_ADDR
// if not defenders and not solds then
76951: LD_VAR 0 2
76955: NOT
76956: PUSH
76957: LD_VAR 0 9
76961: NOT
76962: AND
76963: IFFALSE 76967
// exit ;
76965: GO 78593
// depot_under_attack := false ;
76967: LD_ADDR_VAR 0 17
76971: PUSH
76972: LD_INT 0
76974: ST_TO_ADDR
// sold_defenders := [ ] ;
76975: LD_ADDR_VAR 0 18
76979: PUSH
76980: EMPTY
76981: ST_TO_ADDR
// if mechs then
76982: LD_VAR 0 13
76986: IFFALSE 77115
// for i in defenders do
76988: LD_ADDR_VAR 0 5
76992: PUSH
76993: LD_VAR 0 2
76997: PUSH
76998: FOR_IN
76999: IFFALSE 77113
// begin SetTag ( i , 20 ) ;
77001: LD_VAR 0 5
77005: PPUSH
77006: LD_INT 20
77008: PPUSH
77009: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
77013: LD_VAR 0 5
77017: PPUSH
77018: CALL_OW 263
77022: PUSH
77023: LD_INT 1
77025: EQUAL
77026: PUSH
77027: LD_VAR 0 5
77031: PPUSH
77032: CALL_OW 311
77036: NOT
77037: AND
77038: PUSH
77039: LD_VAR 0 13
77043: AND
77044: IFFALSE 77111
// begin un := mechs [ 1 ] ;
77046: LD_ADDR_VAR 0 11
77050: PUSH
77051: LD_VAR 0 13
77055: PUSH
77056: LD_INT 1
77058: ARRAY
77059: ST_TO_ADDR
// ComExitBuilding ( un ) ;
77060: LD_VAR 0 11
77064: PPUSH
77065: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
77069: LD_VAR 0 11
77073: PPUSH
77074: LD_VAR 0 5
77078: PPUSH
77079: CALL_OW 180
// SetTag ( un , 19 ) ;
77083: LD_VAR 0 11
77087: PPUSH
77088: LD_INT 19
77090: PPUSH
77091: CALL_OW 109
// mechs := mechs diff un ;
77095: LD_ADDR_VAR 0 13
77099: PUSH
77100: LD_VAR 0 13
77104: PUSH
77105: LD_VAR 0 11
77109: DIFF
77110: ST_TO_ADDR
// end ; end ;
77111: GO 76998
77113: POP
77114: POP
// if solds then
77115: LD_VAR 0 9
77119: IFFALSE 77178
// for i in solds do
77121: LD_ADDR_VAR 0 5
77125: PUSH
77126: LD_VAR 0 9
77130: PUSH
77131: FOR_IN
77132: IFFALSE 77176
// if not GetTag ( i ) then
77134: LD_VAR 0 5
77138: PPUSH
77139: CALL_OW 110
77143: NOT
77144: IFFALSE 77174
// begin defenders := defenders union i ;
77146: LD_ADDR_VAR 0 2
77150: PUSH
77151: LD_VAR 0 2
77155: PUSH
77156: LD_VAR 0 5
77160: UNION
77161: ST_TO_ADDR
// SetTag ( i , 18 ) ;
77162: LD_VAR 0 5
77166: PPUSH
77167: LD_INT 18
77169: PPUSH
77170: CALL_OW 109
// end ;
77174: GO 77131
77176: POP
77177: POP
// repeat wait ( 0 0$1 ) ;
77178: LD_INT 35
77180: PPUSH
77181: CALL_OW 67
// enemy := mc_scan [ base ] ;
77185: LD_ADDR_VAR 0 3
77189: PUSH
77190: LD_EXP 37
77194: PUSH
77195: LD_VAR 0 1
77199: ARRAY
77200: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
77201: LD_EXP 14
77205: PUSH
77206: LD_VAR 0 1
77210: ARRAY
77211: NOT
77212: PUSH
77213: LD_EXP 14
77217: PUSH
77218: LD_VAR 0 1
77222: ARRAY
77223: PUSH
77224: EMPTY
77225: EQUAL
77226: OR
77227: IFFALSE 77264
// begin for i in defenders do
77229: LD_ADDR_VAR 0 5
77233: PUSH
77234: LD_VAR 0 2
77238: PUSH
77239: FOR_IN
77240: IFFALSE 77253
// ComStop ( i ) ;
77242: LD_VAR 0 5
77246: PPUSH
77247: CALL_OW 141
77251: GO 77239
77253: POP
77254: POP
// defenders := [ ] ;
77255: LD_ADDR_VAR 0 2
77259: PUSH
77260: EMPTY
77261: ST_TO_ADDR
// exit ;
77262: GO 78593
// end ; for i in defenders do
77264: LD_ADDR_VAR 0 5
77268: PUSH
77269: LD_VAR 0 2
77273: PUSH
77274: FOR_IN
77275: IFFALSE 78093
// begin e := NearestUnitToUnit ( enemy , i ) ;
77277: LD_ADDR_VAR 0 14
77281: PUSH
77282: LD_VAR 0 3
77286: PPUSH
77287: LD_VAR 0 5
77291: PPUSH
77292: CALL_OW 74
77296: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77297: LD_ADDR_VAR 0 8
77301: PUSH
77302: LD_EXP 14
77306: PUSH
77307: LD_VAR 0 1
77311: ARRAY
77312: PPUSH
77313: LD_INT 2
77315: PUSH
77316: LD_INT 30
77318: PUSH
77319: LD_INT 0
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 30
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: LIST
77340: PPUSH
77341: CALL_OW 72
77345: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
77346: LD_ADDR_VAR 0 17
77350: PUSH
77351: LD_VAR 0 8
77355: NOT
77356: PUSH
77357: LD_VAR 0 8
77361: PPUSH
77362: LD_INT 3
77364: PUSH
77365: LD_INT 24
77367: PUSH
77368: LD_INT 600
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PPUSH
77379: CALL_OW 72
77383: OR
77384: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
77385: LD_VAR 0 5
77389: PPUSH
77390: CALL_OW 247
77394: PUSH
77395: LD_INT 2
77397: DOUBLE
77398: EQUAL
77399: IFTRUE 77403
77401: GO 77799
77403: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
77404: LD_VAR 0 5
77408: PPUSH
77409: CALL_OW 256
77413: PUSH
77414: LD_INT 650
77416: GREATER
77417: PUSH
77418: LD_VAR 0 5
77422: PPUSH
77423: LD_VAR 0 14
77427: PPUSH
77428: CALL_OW 296
77432: PUSH
77433: LD_INT 40
77435: LESS
77436: PUSH
77437: LD_VAR 0 14
77441: PPUSH
77442: LD_EXP 39
77446: PUSH
77447: LD_VAR 0 1
77451: ARRAY
77452: PPUSH
77453: CALL_OW 308
77457: OR
77458: AND
77459: IFFALSE 77581
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
77461: LD_VAR 0 5
77465: PPUSH
77466: CALL_OW 262
77470: PUSH
77471: LD_INT 1
77473: EQUAL
77474: PUSH
77475: LD_VAR 0 5
77479: PPUSH
77480: CALL_OW 261
77484: PUSH
77485: LD_INT 30
77487: LESS
77488: AND
77489: PUSH
77490: LD_VAR 0 8
77494: AND
77495: IFFALSE 77565
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
77497: LD_VAR 0 5
77501: PPUSH
77502: LD_VAR 0 8
77506: PPUSH
77507: LD_VAR 0 5
77511: PPUSH
77512: CALL_OW 74
77516: PPUSH
77517: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
77521: LD_VAR 0 5
77525: PPUSH
77526: LD_VAR 0 8
77530: PPUSH
77531: LD_VAR 0 5
77535: PPUSH
77536: CALL_OW 74
77540: PPUSH
77541: CALL_OW 296
77545: PUSH
77546: LD_INT 6
77548: LESS
77549: IFFALSE 77563
// SetFuel ( i , 100 ) ;
77551: LD_VAR 0 5
77555: PPUSH
77556: LD_INT 100
77558: PPUSH
77559: CALL_OW 240
// end else
77563: GO 77579
// ComAttackUnit ( i , e ) ;
77565: LD_VAR 0 5
77569: PPUSH
77570: LD_VAR 0 14
77574: PPUSH
77575: CALL_OW 115
// end else
77579: GO 77682
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
77581: LD_VAR 0 14
77585: PPUSH
77586: LD_EXP 39
77590: PUSH
77591: LD_VAR 0 1
77595: ARRAY
77596: PPUSH
77597: CALL_OW 308
77601: NOT
77602: PUSH
77603: LD_VAR 0 5
77607: PPUSH
77608: LD_VAR 0 14
77612: PPUSH
77613: CALL_OW 296
77617: PUSH
77618: LD_INT 40
77620: GREATEREQUAL
77621: AND
77622: PUSH
77623: LD_VAR 0 5
77627: PPUSH
77628: CALL_OW 256
77632: PUSH
77633: LD_INT 650
77635: LESSEQUAL
77636: OR
77637: PUSH
77638: LD_VAR 0 5
77642: PPUSH
77643: LD_EXP 38
77647: PUSH
77648: LD_VAR 0 1
77652: ARRAY
77653: PPUSH
77654: CALL_OW 308
77658: NOT
77659: AND
77660: IFFALSE 77682
// ComMoveToArea ( i , mc_parking [ base ] ) ;
77662: LD_VAR 0 5
77666: PPUSH
77667: LD_EXP 38
77671: PUSH
77672: LD_VAR 0 1
77676: ARRAY
77677: PPUSH
77678: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
77682: LD_VAR 0 5
77686: PPUSH
77687: CALL_OW 256
77691: PUSH
77692: LD_INT 998
77694: LESS
77695: PUSH
77696: LD_VAR 0 5
77700: PPUSH
77701: CALL_OW 263
77705: PUSH
77706: LD_INT 1
77708: EQUAL
77709: AND
77710: PUSH
77711: LD_VAR 0 5
77715: PPUSH
77716: CALL_OW 311
77720: AND
77721: PUSH
77722: LD_VAR 0 5
77726: PPUSH
77727: LD_EXP 38
77731: PUSH
77732: LD_VAR 0 1
77736: ARRAY
77737: PPUSH
77738: CALL_OW 308
77742: AND
77743: IFFALSE 77797
// begin mech := IsDrivenBy ( i ) ;
77745: LD_ADDR_VAR 0 10
77749: PUSH
77750: LD_VAR 0 5
77754: PPUSH
77755: CALL_OW 311
77759: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
77760: LD_VAR 0 10
77764: PPUSH
77765: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
77769: LD_VAR 0 10
77773: PPUSH
77774: LD_VAR 0 5
77778: PPUSH
77779: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
77783: LD_VAR 0 10
77787: PPUSH
77788: LD_VAR 0 5
77792: PPUSH
77793: CALL_OW 180
// end ; end ; unit_human :
77797: GO 78064
77799: LD_INT 1
77801: DOUBLE
77802: EQUAL
77803: IFTRUE 77807
77805: GO 78063
77807: POP
// begin b := IsInUnit ( i ) ;
77808: LD_ADDR_VAR 0 19
77812: PUSH
77813: LD_VAR 0 5
77817: PPUSH
77818: CALL_OW 310
77822: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
77823: LD_ADDR_VAR 0 20
77827: PUSH
77828: LD_VAR 0 19
77832: NOT
77833: PUSH
77834: LD_VAR 0 19
77838: PPUSH
77839: CALL_OW 266
77843: PUSH
77844: LD_INT 32
77846: PUSH
77847: LD_INT 31
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: IN
77854: OR
77855: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
77856: LD_VAR 0 17
77860: PUSH
77861: LD_VAR 0 2
77865: PPUSH
77866: LD_INT 21
77868: PUSH
77869: LD_INT 2
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PPUSH
77876: CALL_OW 72
77880: PUSH
77881: LD_INT 1
77883: LESSEQUAL
77884: OR
77885: PUSH
77886: LD_VAR 0 20
77890: AND
77891: PUSH
77892: LD_VAR 0 5
77896: PUSH
77897: LD_VAR 0 18
77901: IN
77902: NOT
77903: AND
77904: IFFALSE 77997
// begin if b then
77906: LD_VAR 0 19
77910: IFFALSE 77959
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
77912: LD_VAR 0 19
77916: PPUSH
77917: LD_VAR 0 3
77921: PPUSH
77922: LD_VAR 0 19
77926: PPUSH
77927: CALL_OW 74
77931: PPUSH
77932: CALL_OW 296
77936: PUSH
77937: LD_INT 10
77939: LESS
77940: PUSH
77941: LD_VAR 0 19
77945: PPUSH
77946: CALL_OW 461
77950: PUSH
77951: LD_INT 7
77953: NONEQUAL
77954: AND
77955: IFFALSE 77959
// continue ;
77957: GO 77274
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
77959: LD_ADDR_VAR 0 18
77963: PUSH
77964: LD_VAR 0 18
77968: PPUSH
77969: LD_VAR 0 18
77973: PUSH
77974: LD_INT 1
77976: PLUS
77977: PPUSH
77978: LD_VAR 0 5
77982: PPUSH
77983: CALL_OW 1
77987: ST_TO_ADDR
// ComExitBuilding ( i ) ;
77988: LD_VAR 0 5
77992: PPUSH
77993: CALL_OW 122
// end ; if sold_defenders then
77997: LD_VAR 0 18
78001: IFFALSE 78061
// if i in sold_defenders then
78003: LD_VAR 0 5
78007: PUSH
78008: LD_VAR 0 18
78012: IN
78013: IFFALSE 78061
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
78015: LD_VAR 0 5
78019: PPUSH
78020: CALL_OW 314
78024: NOT
78025: PUSH
78026: LD_VAR 0 5
78030: PPUSH
78031: LD_VAR 0 14
78035: PPUSH
78036: CALL_OW 296
78040: PUSH
78041: LD_INT 30
78043: LESS
78044: AND
78045: IFFALSE 78061
// ComAttackUnit ( i , e ) ;
78047: LD_VAR 0 5
78051: PPUSH
78052: LD_VAR 0 14
78056: PPUSH
78057: CALL_OW 115
// end ; end ; end ;
78061: GO 78064
78063: POP
// if IsDead ( i ) then
78064: LD_VAR 0 5
78068: PPUSH
78069: CALL_OW 301
78073: IFFALSE 78091
// defenders := defenders diff i ;
78075: LD_ADDR_VAR 0 2
78079: PUSH
78080: LD_VAR 0 2
78084: PUSH
78085: LD_VAR 0 5
78089: DIFF
78090: ST_TO_ADDR
// end ;
78091: GO 77274
78093: POP
78094: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
78095: LD_VAR 0 3
78099: NOT
78100: PUSH
78101: LD_VAR 0 2
78105: NOT
78106: OR
78107: PUSH
78108: LD_EXP 14
78112: PUSH
78113: LD_VAR 0 1
78117: ARRAY
78118: NOT
78119: OR
78120: IFFALSE 77178
// MC_Reset ( base , 18 ) ;
78122: LD_VAR 0 1
78126: PPUSH
78127: LD_INT 18
78129: PPUSH
78130: CALL 45389 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78134: LD_ADDR_VAR 0 2
78138: PUSH
78139: LD_VAR 0 2
78143: PUSH
78144: LD_VAR 0 2
78148: PPUSH
78149: LD_INT 2
78151: PUSH
78152: LD_INT 25
78154: PUSH
78155: LD_INT 1
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 25
78164: PUSH
78165: LD_INT 5
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 25
78174: PUSH
78175: LD_INT 8
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 25
78184: PUSH
78185: LD_INT 9
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: PPUSH
78199: CALL_OW 72
78203: DIFF
78204: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
78205: LD_VAR 0 3
78209: NOT
78210: PUSH
78211: LD_VAR 0 2
78215: PPUSH
78216: LD_INT 21
78218: PUSH
78219: LD_INT 2
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PPUSH
78226: CALL_OW 72
78230: AND
78231: IFFALSE 78569
// begin tmp := FilterByTag ( defenders , 19 ) ;
78233: LD_ADDR_VAR 0 12
78237: PUSH
78238: LD_VAR 0 2
78242: PPUSH
78243: LD_INT 19
78245: PPUSH
78246: CALL 38006 0 2
78250: ST_TO_ADDR
// if tmp then
78251: LD_VAR 0 12
78255: IFFALSE 78325
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
78257: LD_ADDR_VAR 0 12
78261: PUSH
78262: LD_VAR 0 12
78266: PPUSH
78267: LD_INT 25
78269: PUSH
78270: LD_INT 3
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PPUSH
78277: CALL_OW 72
78281: ST_TO_ADDR
// if tmp then
78282: LD_VAR 0 12
78286: IFFALSE 78325
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
78288: LD_ADDR_EXP 26
78292: PUSH
78293: LD_EXP 26
78297: PPUSH
78298: LD_VAR 0 1
78302: PPUSH
78303: LD_EXP 26
78307: PUSH
78308: LD_VAR 0 1
78312: ARRAY
78313: PUSH
78314: LD_VAR 0 12
78318: UNION
78319: PPUSH
78320: CALL_OW 1
78324: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
78325: LD_VAR 0 1
78329: PPUSH
78330: LD_INT 19
78332: PPUSH
78333: CALL 45389 0 2
// repeat wait ( 0 0$1 ) ;
78337: LD_INT 35
78339: PPUSH
78340: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78344: LD_EXP 14
78348: PUSH
78349: LD_VAR 0 1
78353: ARRAY
78354: NOT
78355: PUSH
78356: LD_EXP 14
78360: PUSH
78361: LD_VAR 0 1
78365: ARRAY
78366: PUSH
78367: EMPTY
78368: EQUAL
78369: OR
78370: IFFALSE 78407
// begin for i in defenders do
78372: LD_ADDR_VAR 0 5
78376: PUSH
78377: LD_VAR 0 2
78381: PUSH
78382: FOR_IN
78383: IFFALSE 78396
// ComStop ( i ) ;
78385: LD_VAR 0 5
78389: PPUSH
78390: CALL_OW 141
78394: GO 78382
78396: POP
78397: POP
// defenders := [ ] ;
78398: LD_ADDR_VAR 0 2
78402: PUSH
78403: EMPTY
78404: ST_TO_ADDR
// exit ;
78405: GO 78593
// end ; for i in defenders do
78407: LD_ADDR_VAR 0 5
78411: PUSH
78412: LD_VAR 0 2
78416: PUSH
78417: FOR_IN
78418: IFFALSE 78507
// begin if not IsInArea ( i , mc_parking [ base ] ) then
78420: LD_VAR 0 5
78424: PPUSH
78425: LD_EXP 38
78429: PUSH
78430: LD_VAR 0 1
78434: ARRAY
78435: PPUSH
78436: CALL_OW 308
78440: NOT
78441: IFFALSE 78465
// ComMoveToArea ( i , mc_parking [ base ] ) else
78443: LD_VAR 0 5
78447: PPUSH
78448: LD_EXP 38
78452: PUSH
78453: LD_VAR 0 1
78457: ARRAY
78458: PPUSH
78459: CALL_OW 113
78463: GO 78505
// if GetControl ( i ) = control_manual then
78465: LD_VAR 0 5
78469: PPUSH
78470: CALL_OW 263
78474: PUSH
78475: LD_INT 1
78477: EQUAL
78478: IFFALSE 78505
// if IsDrivenBy ( i ) then
78480: LD_VAR 0 5
78484: PPUSH
78485: CALL_OW 311
78489: IFFALSE 78505
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
78491: LD_VAR 0 5
78495: PPUSH
78496: CALL_OW 311
78500: PPUSH
78501: CALL_OW 121
// end ;
78505: GO 78417
78507: POP
78508: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
78509: LD_VAR 0 2
78513: PPUSH
78514: LD_INT 95
78516: PUSH
78517: LD_EXP 38
78521: PUSH
78522: LD_VAR 0 1
78526: ARRAY
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PPUSH
78532: CALL_OW 72
78536: PUSH
78537: LD_VAR 0 2
78541: EQUAL
78542: PUSH
78543: LD_EXP 37
78547: PUSH
78548: LD_VAR 0 1
78552: ARRAY
78553: OR
78554: PUSH
78555: LD_EXP 14
78559: PUSH
78560: LD_VAR 0 1
78564: ARRAY
78565: NOT
78566: OR
78567: IFFALSE 78337
// end ; MC_Reset ( base , 19 ) ;
78569: LD_VAR 0 1
78573: PPUSH
78574: LD_INT 19
78576: PPUSH
78577: CALL 45389 0 2
// MC_Reset ( base , 20 ) ;
78581: LD_VAR 0 1
78585: PPUSH
78586: LD_INT 20
78588: PPUSH
78589: CALL 45389 0 2
// end ; end_of_file
78593: LD_VAR 0 4
78597: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
78598: LD_INT 0
78600: PPUSH
78601: PPUSH
78602: PPUSH
78603: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
78604: LD_VAR 0 1
78608: PPUSH
78609: CALL_OW 264
78613: PUSH
78614: LD_EXP 61
78618: EQUAL
78619: IFFALSE 78691
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
78621: LD_INT 68
78623: PPUSH
78624: LD_VAR 0 1
78628: PPUSH
78629: CALL_OW 255
78633: PPUSH
78634: CALL_OW 321
78638: PUSH
78639: LD_INT 2
78641: EQUAL
78642: IFFALSE 78654
// eff := 70 else
78644: LD_ADDR_VAR 0 4
78648: PUSH
78649: LD_INT 70
78651: ST_TO_ADDR
78652: GO 78662
// eff := 30 ;
78654: LD_ADDR_VAR 0 4
78658: PUSH
78659: LD_INT 30
78661: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
78662: LD_VAR 0 1
78666: PPUSH
78667: CALL_OW 250
78671: PPUSH
78672: LD_VAR 0 1
78676: PPUSH
78677: CALL_OW 251
78681: PPUSH
78682: LD_VAR 0 4
78686: PPUSH
78687: CALL_OW 495
// end ; end ;
78691: LD_VAR 0 2
78695: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
78696: LD_INT 0
78698: PPUSH
// end ;
78699: LD_VAR 0 4
78703: RET
// export function SOS_Command ( cmd ) ; begin
78704: LD_INT 0
78706: PPUSH
// end ;
78707: LD_VAR 0 2
78711: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
78712: LD_INT 0
78714: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
78715: LD_VAR 0 1
78719: PUSH
78720: LD_INT 250
78722: EQUAL
78723: PUSH
78724: LD_VAR 0 2
78728: PPUSH
78729: CALL_OW 264
78733: PUSH
78734: LD_EXP 64
78738: EQUAL
78739: AND
78740: IFFALSE 78761
// MinerPlaceMine ( unit , x , y ) ;
78742: LD_VAR 0 2
78746: PPUSH
78747: LD_VAR 0 4
78751: PPUSH
78752: LD_VAR 0 5
78756: PPUSH
78757: CALL 81102 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
78761: LD_VAR 0 1
78765: PUSH
78766: LD_INT 251
78768: EQUAL
78769: PUSH
78770: LD_VAR 0 2
78774: PPUSH
78775: CALL_OW 264
78779: PUSH
78780: LD_EXP 64
78784: EQUAL
78785: AND
78786: IFFALSE 78807
// MinerDetonateMine ( unit , x , y ) ;
78788: LD_VAR 0 2
78792: PPUSH
78793: LD_VAR 0 4
78797: PPUSH
78798: LD_VAR 0 5
78802: PPUSH
78803: CALL 81379 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
78807: LD_VAR 0 1
78811: PUSH
78812: LD_INT 252
78814: EQUAL
78815: PUSH
78816: LD_VAR 0 2
78820: PPUSH
78821: CALL_OW 264
78825: PUSH
78826: LD_EXP 64
78830: EQUAL
78831: AND
78832: IFFALSE 78853
// MinerCreateMinefield ( unit , x , y ) ;
78834: LD_VAR 0 2
78838: PPUSH
78839: LD_VAR 0 4
78843: PPUSH
78844: LD_VAR 0 5
78848: PPUSH
78849: CALL 81796 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
78853: LD_VAR 0 1
78857: PUSH
78858: LD_INT 253
78860: EQUAL
78861: PUSH
78862: LD_VAR 0 2
78866: PPUSH
78867: CALL_OW 257
78871: PUSH
78872: LD_INT 5
78874: EQUAL
78875: AND
78876: IFFALSE 78897
// ComBinocular ( unit , x , y ) ;
78878: LD_VAR 0 2
78882: PPUSH
78883: LD_VAR 0 4
78887: PPUSH
78888: LD_VAR 0 5
78892: PPUSH
78893: CALL 82167 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
78897: LD_VAR 0 1
78901: PUSH
78902: LD_INT 254
78904: EQUAL
78905: PUSH
78906: LD_VAR 0 2
78910: PPUSH
78911: CALL_OW 264
78915: PUSH
78916: LD_EXP 59
78920: EQUAL
78921: AND
78922: PUSH
78923: LD_VAR 0 3
78927: PPUSH
78928: CALL_OW 263
78932: PUSH
78933: LD_INT 3
78935: EQUAL
78936: AND
78937: IFFALSE 78953
// HackDestroyVehicle ( unit , selectedUnit ) ;
78939: LD_VAR 0 2
78943: PPUSH
78944: LD_VAR 0 3
78948: PPUSH
78949: CALL 80462 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
78953: LD_VAR 0 1
78957: PUSH
78958: LD_INT 255
78960: EQUAL
78961: PUSH
78962: LD_VAR 0 2
78966: PPUSH
78967: CALL_OW 264
78971: PUSH
78972: LD_INT 14
78974: PUSH
78975: LD_INT 53
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: IN
78982: AND
78983: PUSH
78984: LD_VAR 0 4
78988: PPUSH
78989: LD_VAR 0 5
78993: PPUSH
78994: CALL_OW 488
78998: AND
78999: IFFALSE 79023
// CutTreeXYR ( unit , x , y , 12 ) ;
79001: LD_VAR 0 2
79005: PPUSH
79006: LD_VAR 0 4
79010: PPUSH
79011: LD_VAR 0 5
79015: PPUSH
79016: LD_INT 12
79018: PPUSH
79019: CALL 79028 0 4
// end ;
79023: LD_VAR 0 6
79027: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
79028: LD_INT 0
79030: PPUSH
79031: PPUSH
79032: PPUSH
79033: PPUSH
79034: PPUSH
79035: PPUSH
79036: PPUSH
79037: PPUSH
79038: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
79039: LD_VAR 0 1
79043: NOT
79044: PUSH
79045: LD_VAR 0 2
79049: PPUSH
79050: LD_VAR 0 3
79054: PPUSH
79055: CALL_OW 488
79059: NOT
79060: OR
79061: PUSH
79062: LD_VAR 0 4
79066: NOT
79067: OR
79068: IFFALSE 79072
// exit ;
79070: GO 79412
// list := [ ] ;
79072: LD_ADDR_VAR 0 13
79076: PUSH
79077: EMPTY
79078: ST_TO_ADDR
// if x - r < 0 then
79079: LD_VAR 0 2
79083: PUSH
79084: LD_VAR 0 4
79088: MINUS
79089: PUSH
79090: LD_INT 0
79092: LESS
79093: IFFALSE 79105
// min_x := 0 else
79095: LD_ADDR_VAR 0 7
79099: PUSH
79100: LD_INT 0
79102: ST_TO_ADDR
79103: GO 79121
// min_x := x - r ;
79105: LD_ADDR_VAR 0 7
79109: PUSH
79110: LD_VAR 0 2
79114: PUSH
79115: LD_VAR 0 4
79119: MINUS
79120: ST_TO_ADDR
// if y - r < 0 then
79121: LD_VAR 0 3
79125: PUSH
79126: LD_VAR 0 4
79130: MINUS
79131: PUSH
79132: LD_INT 0
79134: LESS
79135: IFFALSE 79147
// min_y := 0 else
79137: LD_ADDR_VAR 0 8
79141: PUSH
79142: LD_INT 0
79144: ST_TO_ADDR
79145: GO 79163
// min_y := y - r ;
79147: LD_ADDR_VAR 0 8
79151: PUSH
79152: LD_VAR 0 3
79156: PUSH
79157: LD_VAR 0 4
79161: MINUS
79162: ST_TO_ADDR
// max_x := x + r ;
79163: LD_ADDR_VAR 0 9
79167: PUSH
79168: LD_VAR 0 2
79172: PUSH
79173: LD_VAR 0 4
79177: PLUS
79178: ST_TO_ADDR
// max_y := y + r ;
79179: LD_ADDR_VAR 0 10
79183: PUSH
79184: LD_VAR 0 3
79188: PUSH
79189: LD_VAR 0 4
79193: PLUS
79194: ST_TO_ADDR
// for _x = min_x to max_x do
79195: LD_ADDR_VAR 0 11
79199: PUSH
79200: DOUBLE
79201: LD_VAR 0 7
79205: DEC
79206: ST_TO_ADDR
79207: LD_VAR 0 9
79211: PUSH
79212: FOR_TO
79213: IFFALSE 79330
// for _y = min_y to max_y do
79215: LD_ADDR_VAR 0 12
79219: PUSH
79220: DOUBLE
79221: LD_VAR 0 8
79225: DEC
79226: ST_TO_ADDR
79227: LD_VAR 0 10
79231: PUSH
79232: FOR_TO
79233: IFFALSE 79326
// begin if not ValidHex ( _x , _y ) then
79235: LD_VAR 0 11
79239: PPUSH
79240: LD_VAR 0 12
79244: PPUSH
79245: CALL_OW 488
79249: NOT
79250: IFFALSE 79254
// continue ;
79252: GO 79232
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
79254: LD_VAR 0 11
79258: PPUSH
79259: LD_VAR 0 12
79263: PPUSH
79264: CALL_OW 351
79268: PUSH
79269: LD_VAR 0 11
79273: PPUSH
79274: LD_VAR 0 12
79278: PPUSH
79279: CALL_OW 554
79283: AND
79284: IFFALSE 79324
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
79286: LD_ADDR_VAR 0 13
79290: PUSH
79291: LD_VAR 0 13
79295: PPUSH
79296: LD_VAR 0 13
79300: PUSH
79301: LD_INT 1
79303: PLUS
79304: PPUSH
79305: LD_VAR 0 11
79309: PUSH
79310: LD_VAR 0 12
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PPUSH
79319: CALL_OW 2
79323: ST_TO_ADDR
// end ;
79324: GO 79232
79326: POP
79327: POP
79328: GO 79212
79330: POP
79331: POP
// if not list then
79332: LD_VAR 0 13
79336: NOT
79337: IFFALSE 79341
// exit ;
79339: GO 79412
// for i in list do
79341: LD_ADDR_VAR 0 6
79345: PUSH
79346: LD_VAR 0 13
79350: PUSH
79351: FOR_IN
79352: IFFALSE 79410
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
79354: LD_VAR 0 1
79358: PPUSH
79359: LD_STRING M
79361: PUSH
79362: LD_VAR 0 6
79366: PUSH
79367: LD_INT 1
79369: ARRAY
79370: PUSH
79371: LD_VAR 0 6
79375: PUSH
79376: LD_INT 2
79378: ARRAY
79379: PUSH
79380: LD_INT 0
79382: PUSH
79383: LD_INT 0
79385: PUSH
79386: LD_INT 0
79388: PUSH
79389: LD_INT 0
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: PUSH
79401: EMPTY
79402: LIST
79403: PPUSH
79404: CALL_OW 447
79408: GO 79351
79410: POP
79411: POP
// end ;
79412: LD_VAR 0 5
79416: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
79417: LD_EXP 73
79421: NOT
79422: IFFALSE 79472
79424: GO 79426
79426: DISABLE
// begin initHack := true ;
79427: LD_ADDR_EXP 73
79431: PUSH
79432: LD_INT 1
79434: ST_TO_ADDR
// hackTanks := [ ] ;
79435: LD_ADDR_EXP 74
79439: PUSH
79440: EMPTY
79441: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
79442: LD_ADDR_EXP 75
79446: PUSH
79447: EMPTY
79448: ST_TO_ADDR
// hackLimit := 3 ;
79449: LD_ADDR_EXP 76
79453: PUSH
79454: LD_INT 3
79456: ST_TO_ADDR
// hackDist := 12 ;
79457: LD_ADDR_EXP 77
79461: PUSH
79462: LD_INT 12
79464: ST_TO_ADDR
// hackCounter := [ ] ;
79465: LD_ADDR_EXP 78
79469: PUSH
79470: EMPTY
79471: ST_TO_ADDR
// end ;
79472: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
79473: LD_EXP 73
79477: PUSH
79478: LD_INT 34
79480: PUSH
79481: LD_EXP 59
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PPUSH
79490: CALL_OW 69
79494: AND
79495: IFFALSE 79750
79497: GO 79499
79499: DISABLE
79500: LD_INT 0
79502: PPUSH
79503: PPUSH
// begin enable ;
79504: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
79505: LD_ADDR_VAR 0 1
79509: PUSH
79510: LD_INT 34
79512: PUSH
79513: LD_EXP 59
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PPUSH
79522: CALL_OW 69
79526: PUSH
79527: FOR_IN
79528: IFFALSE 79748
// begin if not i in hackTanks then
79530: LD_VAR 0 1
79534: PUSH
79535: LD_EXP 74
79539: IN
79540: NOT
79541: IFFALSE 79624
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
79543: LD_ADDR_EXP 74
79547: PUSH
79548: LD_EXP 74
79552: PPUSH
79553: LD_EXP 74
79557: PUSH
79558: LD_INT 1
79560: PLUS
79561: PPUSH
79562: LD_VAR 0 1
79566: PPUSH
79567: CALL_OW 1
79571: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
79572: LD_ADDR_EXP 75
79576: PUSH
79577: LD_EXP 75
79581: PPUSH
79582: LD_EXP 75
79586: PUSH
79587: LD_INT 1
79589: PLUS
79590: PPUSH
79591: EMPTY
79592: PPUSH
79593: CALL_OW 1
79597: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
79598: LD_ADDR_EXP 78
79602: PUSH
79603: LD_EXP 78
79607: PPUSH
79608: LD_EXP 78
79612: PUSH
79613: LD_INT 1
79615: PLUS
79616: PPUSH
79617: EMPTY
79618: PPUSH
79619: CALL_OW 1
79623: ST_TO_ADDR
// end ; if not IsOk ( i ) then
79624: LD_VAR 0 1
79628: PPUSH
79629: CALL_OW 302
79633: NOT
79634: IFFALSE 79647
// begin HackUnlinkAll ( i ) ;
79636: LD_VAR 0 1
79640: PPUSH
79641: CALL 79753 0 1
// continue ;
79645: GO 79527
// end ; HackCheckCapturedStatus ( i ) ;
79647: LD_VAR 0 1
79651: PPUSH
79652: CALL 80196 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
79656: LD_ADDR_VAR 0 2
79660: PUSH
79661: LD_INT 81
79663: PUSH
79664: LD_VAR 0 1
79668: PPUSH
79669: CALL_OW 255
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 33
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 91
79690: PUSH
79691: LD_VAR 0 1
79695: PUSH
79696: LD_EXP 77
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 50
79708: PUSH
79709: EMPTY
79710: LIST
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: PPUSH
79718: CALL_OW 69
79722: ST_TO_ADDR
// if not tmp then
79723: LD_VAR 0 2
79727: NOT
79728: IFFALSE 79732
// continue ;
79730: GO 79527
// HackLink ( i , tmp ) ;
79732: LD_VAR 0 1
79736: PPUSH
79737: LD_VAR 0 2
79741: PPUSH
79742: CALL 79889 0 2
// end ;
79746: GO 79527
79748: POP
79749: POP
// end ;
79750: PPOPN 2
79752: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
79753: LD_INT 0
79755: PPUSH
79756: PPUSH
79757: PPUSH
// if not hack in hackTanks then
79758: LD_VAR 0 1
79762: PUSH
79763: LD_EXP 74
79767: IN
79768: NOT
79769: IFFALSE 79773
// exit ;
79771: GO 79884
// index := GetElementIndex ( hackTanks , hack ) ;
79773: LD_ADDR_VAR 0 4
79777: PUSH
79778: LD_EXP 74
79782: PPUSH
79783: LD_VAR 0 1
79787: PPUSH
79788: CALL 9230 0 2
79792: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
79793: LD_EXP 75
79797: PUSH
79798: LD_VAR 0 4
79802: ARRAY
79803: IFFALSE 79884
// begin for i in hackTanksCaptured [ index ] do
79805: LD_ADDR_VAR 0 3
79809: PUSH
79810: LD_EXP 75
79814: PUSH
79815: LD_VAR 0 4
79819: ARRAY
79820: PUSH
79821: FOR_IN
79822: IFFALSE 79848
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
79824: LD_VAR 0 3
79828: PUSH
79829: LD_INT 1
79831: ARRAY
79832: PPUSH
79833: LD_VAR 0 3
79837: PUSH
79838: LD_INT 2
79840: ARRAY
79841: PPUSH
79842: CALL_OW 235
79846: GO 79821
79848: POP
79849: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
79850: LD_ADDR_EXP 75
79854: PUSH
79855: LD_EXP 75
79859: PPUSH
79860: LD_VAR 0 4
79864: PPUSH
79865: EMPTY
79866: PPUSH
79867: CALL_OW 1
79871: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
79872: LD_VAR 0 1
79876: PPUSH
79877: LD_INT 0
79879: PPUSH
79880: CALL_OW 505
// end ; end ;
79884: LD_VAR 0 2
79888: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
79889: LD_INT 0
79891: PPUSH
79892: PPUSH
79893: PPUSH
// if not hack in hackTanks or not vehicles then
79894: LD_VAR 0 1
79898: PUSH
79899: LD_EXP 74
79903: IN
79904: NOT
79905: PUSH
79906: LD_VAR 0 2
79910: NOT
79911: OR
79912: IFFALSE 79916
// exit ;
79914: GO 80191
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
79916: LD_ADDR_VAR 0 2
79920: PUSH
79921: LD_VAR 0 1
79925: PPUSH
79926: LD_VAR 0 2
79930: PPUSH
79931: LD_INT 1
79933: PPUSH
79934: LD_INT 1
79936: PPUSH
79937: CALL 9880 0 4
79941: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
79942: LD_ADDR_VAR 0 5
79946: PUSH
79947: LD_EXP 74
79951: PPUSH
79952: LD_VAR 0 1
79956: PPUSH
79957: CALL 9230 0 2
79961: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
79962: LD_EXP 75
79966: PUSH
79967: LD_VAR 0 5
79971: ARRAY
79972: PUSH
79973: LD_EXP 76
79977: LESS
79978: IFFALSE 80167
// begin for i := 1 to vehicles do
79980: LD_ADDR_VAR 0 4
79984: PUSH
79985: DOUBLE
79986: LD_INT 1
79988: DEC
79989: ST_TO_ADDR
79990: LD_VAR 0 2
79994: PUSH
79995: FOR_TO
79996: IFFALSE 80165
// begin if hackTanksCaptured [ index ] = hackLimit then
79998: LD_EXP 75
80002: PUSH
80003: LD_VAR 0 5
80007: ARRAY
80008: PUSH
80009: LD_EXP 76
80013: EQUAL
80014: IFFALSE 80018
// break ;
80016: GO 80165
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
80018: LD_ADDR_EXP 78
80022: PUSH
80023: LD_EXP 78
80027: PPUSH
80028: LD_VAR 0 5
80032: PPUSH
80033: LD_EXP 78
80037: PUSH
80038: LD_VAR 0 5
80042: ARRAY
80043: PUSH
80044: LD_INT 1
80046: PLUS
80047: PPUSH
80048: CALL_OW 1
80052: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
80053: LD_ADDR_EXP 75
80057: PUSH
80058: LD_EXP 75
80062: PPUSH
80063: LD_VAR 0 5
80067: PUSH
80068: LD_EXP 75
80072: PUSH
80073: LD_VAR 0 5
80077: ARRAY
80078: PUSH
80079: LD_INT 1
80081: PLUS
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PPUSH
80087: LD_VAR 0 2
80091: PUSH
80092: LD_VAR 0 4
80096: ARRAY
80097: PUSH
80098: LD_VAR 0 2
80102: PUSH
80103: LD_VAR 0 4
80107: ARRAY
80108: PPUSH
80109: CALL_OW 255
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PPUSH
80118: CALL 9445 0 3
80122: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
80123: LD_VAR 0 2
80127: PUSH
80128: LD_VAR 0 4
80132: ARRAY
80133: PPUSH
80134: LD_VAR 0 1
80138: PPUSH
80139: CALL_OW 255
80143: PPUSH
80144: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
80148: LD_VAR 0 2
80152: PUSH
80153: LD_VAR 0 4
80157: ARRAY
80158: PPUSH
80159: CALL_OW 141
// end ;
80163: GO 79995
80165: POP
80166: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
80167: LD_VAR 0 1
80171: PPUSH
80172: LD_EXP 75
80176: PUSH
80177: LD_VAR 0 5
80181: ARRAY
80182: PUSH
80183: LD_INT 0
80185: PLUS
80186: PPUSH
80187: CALL_OW 505
// end ;
80191: LD_VAR 0 3
80195: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
80196: LD_INT 0
80198: PPUSH
80199: PPUSH
80200: PPUSH
80201: PPUSH
// if not hack in hackTanks then
80202: LD_VAR 0 1
80206: PUSH
80207: LD_EXP 74
80211: IN
80212: NOT
80213: IFFALSE 80217
// exit ;
80215: GO 80457
// index := GetElementIndex ( hackTanks , hack ) ;
80217: LD_ADDR_VAR 0 4
80221: PUSH
80222: LD_EXP 74
80226: PPUSH
80227: LD_VAR 0 1
80231: PPUSH
80232: CALL 9230 0 2
80236: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
80237: LD_ADDR_VAR 0 3
80241: PUSH
80242: DOUBLE
80243: LD_EXP 75
80247: PUSH
80248: LD_VAR 0 4
80252: ARRAY
80253: INC
80254: ST_TO_ADDR
80255: LD_INT 1
80257: PUSH
80258: FOR_DOWNTO
80259: IFFALSE 80431
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
80261: LD_ADDR_VAR 0 5
80265: PUSH
80266: LD_EXP 75
80270: PUSH
80271: LD_VAR 0 4
80275: ARRAY
80276: PUSH
80277: LD_VAR 0 3
80281: ARRAY
80282: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
80283: LD_VAR 0 5
80287: PUSH
80288: LD_INT 1
80290: ARRAY
80291: PPUSH
80292: CALL_OW 302
80296: NOT
80297: PUSH
80298: LD_VAR 0 5
80302: PUSH
80303: LD_INT 1
80305: ARRAY
80306: PPUSH
80307: CALL_OW 255
80311: PUSH
80312: LD_VAR 0 1
80316: PPUSH
80317: CALL_OW 255
80321: NONEQUAL
80322: OR
80323: IFFALSE 80429
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
80325: LD_VAR 0 5
80329: PUSH
80330: LD_INT 1
80332: ARRAY
80333: PPUSH
80334: CALL_OW 305
80338: PUSH
80339: LD_VAR 0 5
80343: PUSH
80344: LD_INT 1
80346: ARRAY
80347: PPUSH
80348: CALL_OW 255
80352: PUSH
80353: LD_VAR 0 1
80357: PPUSH
80358: CALL_OW 255
80362: EQUAL
80363: AND
80364: IFFALSE 80388
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
80366: LD_VAR 0 5
80370: PUSH
80371: LD_INT 1
80373: ARRAY
80374: PPUSH
80375: LD_VAR 0 5
80379: PUSH
80380: LD_INT 2
80382: ARRAY
80383: PPUSH
80384: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
80388: LD_ADDR_EXP 75
80392: PUSH
80393: LD_EXP 75
80397: PPUSH
80398: LD_VAR 0 4
80402: PPUSH
80403: LD_EXP 75
80407: PUSH
80408: LD_VAR 0 4
80412: ARRAY
80413: PPUSH
80414: LD_VAR 0 3
80418: PPUSH
80419: CALL_OW 3
80423: PPUSH
80424: CALL_OW 1
80428: ST_TO_ADDR
// end ; end ;
80429: GO 80258
80431: POP
80432: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
80433: LD_VAR 0 1
80437: PPUSH
80438: LD_EXP 75
80442: PUSH
80443: LD_VAR 0 4
80447: ARRAY
80448: PUSH
80449: LD_INT 0
80451: PLUS
80452: PPUSH
80453: CALL_OW 505
// end ;
80457: LD_VAR 0 2
80461: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
80462: LD_INT 0
80464: PPUSH
80465: PPUSH
80466: PPUSH
80467: PPUSH
// if not hack in hackTanks then
80468: LD_VAR 0 1
80472: PUSH
80473: LD_EXP 74
80477: IN
80478: NOT
80479: IFFALSE 80483
// exit ;
80481: GO 80568
// index := GetElementIndex ( hackTanks , hack ) ;
80483: LD_ADDR_VAR 0 5
80487: PUSH
80488: LD_EXP 74
80492: PPUSH
80493: LD_VAR 0 1
80497: PPUSH
80498: CALL 9230 0 2
80502: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
80503: LD_ADDR_VAR 0 4
80507: PUSH
80508: DOUBLE
80509: LD_INT 1
80511: DEC
80512: ST_TO_ADDR
80513: LD_EXP 75
80517: PUSH
80518: LD_VAR 0 5
80522: ARRAY
80523: PUSH
80524: FOR_TO
80525: IFFALSE 80566
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
80527: LD_EXP 75
80531: PUSH
80532: LD_VAR 0 5
80536: ARRAY
80537: PUSH
80538: LD_VAR 0 4
80542: ARRAY
80543: PUSH
80544: LD_INT 1
80546: ARRAY
80547: PUSH
80548: LD_VAR 0 2
80552: EQUAL
80553: IFFALSE 80564
// KillUnit ( vehicle ) ;
80555: LD_VAR 0 2
80559: PPUSH
80560: CALL_OW 66
80564: GO 80524
80566: POP
80567: POP
// end ;
80568: LD_VAR 0 3
80572: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
80573: LD_EXP 79
80577: NOT
80578: IFFALSE 80613
80580: GO 80582
80582: DISABLE
// begin initMiner := true ;
80583: LD_ADDR_EXP 79
80587: PUSH
80588: LD_INT 1
80590: ST_TO_ADDR
// minersList := [ ] ;
80591: LD_ADDR_EXP 80
80595: PUSH
80596: EMPTY
80597: ST_TO_ADDR
// minerMinesList := [ ] ;
80598: LD_ADDR_EXP 81
80602: PUSH
80603: EMPTY
80604: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
80605: LD_ADDR_EXP 82
80609: PUSH
80610: LD_INT 5
80612: ST_TO_ADDR
// end ;
80613: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
80614: LD_EXP 79
80618: PUSH
80619: LD_INT 34
80621: PUSH
80622: LD_EXP 64
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PPUSH
80631: CALL_OW 69
80635: AND
80636: IFFALSE 81099
80638: GO 80640
80640: DISABLE
80641: LD_INT 0
80643: PPUSH
80644: PPUSH
80645: PPUSH
80646: PPUSH
// begin enable ;
80647: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
80648: LD_ADDR_VAR 0 1
80652: PUSH
80653: LD_INT 34
80655: PUSH
80656: LD_EXP 64
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PPUSH
80665: CALL_OW 69
80669: PUSH
80670: FOR_IN
80671: IFFALSE 80743
// begin if not i in minersList then
80673: LD_VAR 0 1
80677: PUSH
80678: LD_EXP 80
80682: IN
80683: NOT
80684: IFFALSE 80741
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
80686: LD_ADDR_EXP 80
80690: PUSH
80691: LD_EXP 80
80695: PPUSH
80696: LD_EXP 80
80700: PUSH
80701: LD_INT 1
80703: PLUS
80704: PPUSH
80705: LD_VAR 0 1
80709: PPUSH
80710: CALL_OW 1
80714: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
80715: LD_ADDR_EXP 81
80719: PUSH
80720: LD_EXP 81
80724: PPUSH
80725: LD_EXP 81
80729: PUSH
80730: LD_INT 1
80732: PLUS
80733: PPUSH
80734: EMPTY
80735: PPUSH
80736: CALL_OW 1
80740: ST_TO_ADDR
// end end ;
80741: GO 80670
80743: POP
80744: POP
// for i := minerMinesList downto 1 do
80745: LD_ADDR_VAR 0 1
80749: PUSH
80750: DOUBLE
80751: LD_EXP 81
80755: INC
80756: ST_TO_ADDR
80757: LD_INT 1
80759: PUSH
80760: FOR_DOWNTO
80761: IFFALSE 81097
// begin if IsLive ( minersList [ i ] ) then
80763: LD_EXP 80
80767: PUSH
80768: LD_VAR 0 1
80772: ARRAY
80773: PPUSH
80774: CALL_OW 300
80778: IFFALSE 80806
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
80780: LD_EXP 80
80784: PUSH
80785: LD_VAR 0 1
80789: ARRAY
80790: PPUSH
80791: LD_EXP 81
80795: PUSH
80796: LD_VAR 0 1
80800: ARRAY
80801: PPUSH
80802: CALL_OW 505
// if not minerMinesList [ i ] then
80806: LD_EXP 81
80810: PUSH
80811: LD_VAR 0 1
80815: ARRAY
80816: NOT
80817: IFFALSE 80821
// continue ;
80819: GO 80760
// for j := minerMinesList [ i ] downto 1 do
80821: LD_ADDR_VAR 0 2
80825: PUSH
80826: DOUBLE
80827: LD_EXP 81
80831: PUSH
80832: LD_VAR 0 1
80836: ARRAY
80837: INC
80838: ST_TO_ADDR
80839: LD_INT 1
80841: PUSH
80842: FOR_DOWNTO
80843: IFFALSE 81093
// begin side := GetSide ( minersList [ i ] ) ;
80845: LD_ADDR_VAR 0 3
80849: PUSH
80850: LD_EXP 80
80854: PUSH
80855: LD_VAR 0 1
80859: ARRAY
80860: PPUSH
80861: CALL_OW 255
80865: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
80866: LD_ADDR_VAR 0 4
80870: PUSH
80871: LD_EXP 81
80875: PUSH
80876: LD_VAR 0 1
80880: ARRAY
80881: PUSH
80882: LD_VAR 0 2
80886: ARRAY
80887: PUSH
80888: LD_INT 1
80890: ARRAY
80891: PPUSH
80892: LD_EXP 81
80896: PUSH
80897: LD_VAR 0 1
80901: ARRAY
80902: PUSH
80903: LD_VAR 0 2
80907: ARRAY
80908: PUSH
80909: LD_INT 2
80911: ARRAY
80912: PPUSH
80913: CALL_OW 428
80917: ST_TO_ADDR
// if not tmp then
80918: LD_VAR 0 4
80922: NOT
80923: IFFALSE 80927
// continue ;
80925: GO 80842
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
80927: LD_VAR 0 4
80931: PUSH
80932: LD_INT 81
80934: PUSH
80935: LD_VAR 0 3
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PPUSH
80944: CALL_OW 69
80948: IN
80949: PUSH
80950: LD_EXP 81
80954: PUSH
80955: LD_VAR 0 1
80959: ARRAY
80960: PUSH
80961: LD_VAR 0 2
80965: ARRAY
80966: PUSH
80967: LD_INT 1
80969: ARRAY
80970: PPUSH
80971: LD_EXP 81
80975: PUSH
80976: LD_VAR 0 1
80980: ARRAY
80981: PUSH
80982: LD_VAR 0 2
80986: ARRAY
80987: PUSH
80988: LD_INT 2
80990: ARRAY
80991: PPUSH
80992: CALL_OW 458
80996: AND
80997: IFFALSE 81091
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
80999: LD_EXP 81
81003: PUSH
81004: LD_VAR 0 1
81008: ARRAY
81009: PUSH
81010: LD_VAR 0 2
81014: ARRAY
81015: PUSH
81016: LD_INT 1
81018: ARRAY
81019: PPUSH
81020: LD_EXP 81
81024: PUSH
81025: LD_VAR 0 1
81029: ARRAY
81030: PUSH
81031: LD_VAR 0 2
81035: ARRAY
81036: PUSH
81037: LD_INT 2
81039: ARRAY
81040: PPUSH
81041: LD_VAR 0 3
81045: PPUSH
81046: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
81050: LD_ADDR_EXP 81
81054: PUSH
81055: LD_EXP 81
81059: PPUSH
81060: LD_VAR 0 1
81064: PPUSH
81065: LD_EXP 81
81069: PUSH
81070: LD_VAR 0 1
81074: ARRAY
81075: PPUSH
81076: LD_VAR 0 2
81080: PPUSH
81081: CALL_OW 3
81085: PPUSH
81086: CALL_OW 1
81090: ST_TO_ADDR
// end ; end ;
81091: GO 80842
81093: POP
81094: POP
// end ;
81095: GO 80760
81097: POP
81098: POP
// end ;
81099: PPOPN 4
81101: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
81102: LD_INT 0
81104: PPUSH
81105: PPUSH
// result := false ;
81106: LD_ADDR_VAR 0 4
81110: PUSH
81111: LD_INT 0
81113: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
81114: LD_VAR 0 1
81118: PPUSH
81119: CALL_OW 264
81123: PUSH
81124: LD_EXP 64
81128: EQUAL
81129: NOT
81130: IFFALSE 81134
// exit ;
81132: GO 81374
// index := GetElementIndex ( minersList , unit ) ;
81134: LD_ADDR_VAR 0 5
81138: PUSH
81139: LD_EXP 80
81143: PPUSH
81144: LD_VAR 0 1
81148: PPUSH
81149: CALL 9230 0 2
81153: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
81154: LD_EXP 81
81158: PUSH
81159: LD_VAR 0 5
81163: ARRAY
81164: PUSH
81165: LD_EXP 82
81169: GREATEREQUAL
81170: IFFALSE 81174
// exit ;
81172: GO 81374
// ComMoveXY ( unit , x , y ) ;
81174: LD_VAR 0 1
81178: PPUSH
81179: LD_VAR 0 2
81183: PPUSH
81184: LD_VAR 0 3
81188: PPUSH
81189: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
81193: LD_INT 35
81195: PPUSH
81196: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
81200: LD_VAR 0 1
81204: PPUSH
81205: LD_VAR 0 2
81209: PPUSH
81210: LD_VAR 0 3
81214: PPUSH
81215: CALL 39294 0 3
81219: NOT
81220: PUSH
81221: LD_VAR 0 1
81225: PPUSH
81226: CALL_OW 314
81230: AND
81231: IFFALSE 81235
// exit ;
81233: GO 81374
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
81235: LD_VAR 0 2
81239: PPUSH
81240: LD_VAR 0 3
81244: PPUSH
81245: CALL_OW 428
81249: PUSH
81250: LD_VAR 0 1
81254: EQUAL
81255: PUSH
81256: LD_VAR 0 1
81260: PPUSH
81261: CALL_OW 314
81265: NOT
81266: AND
81267: IFFALSE 81193
// PlaySoundXY ( x , y , PlantMine ) ;
81269: LD_VAR 0 2
81273: PPUSH
81274: LD_VAR 0 3
81278: PPUSH
81279: LD_STRING PlantMine
81281: PPUSH
81282: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
81286: LD_VAR 0 2
81290: PPUSH
81291: LD_VAR 0 3
81295: PPUSH
81296: LD_VAR 0 1
81300: PPUSH
81301: CALL_OW 255
81305: PPUSH
81306: LD_INT 0
81308: PPUSH
81309: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
81313: LD_ADDR_EXP 81
81317: PUSH
81318: LD_EXP 81
81322: PPUSH
81323: LD_VAR 0 5
81327: PUSH
81328: LD_EXP 81
81332: PUSH
81333: LD_VAR 0 5
81337: ARRAY
81338: PUSH
81339: LD_INT 1
81341: PLUS
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PPUSH
81347: LD_VAR 0 2
81351: PUSH
81352: LD_VAR 0 3
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PPUSH
81361: CALL 9445 0 3
81365: ST_TO_ADDR
// result := true ;
81366: LD_ADDR_VAR 0 4
81370: PUSH
81371: LD_INT 1
81373: ST_TO_ADDR
// end ;
81374: LD_VAR 0 4
81378: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
81379: LD_INT 0
81381: PPUSH
81382: PPUSH
81383: PPUSH
// if not unit in minersList then
81384: LD_VAR 0 1
81388: PUSH
81389: LD_EXP 80
81393: IN
81394: NOT
81395: IFFALSE 81399
// exit ;
81397: GO 81791
// index := GetElementIndex ( minersList , unit ) ;
81399: LD_ADDR_VAR 0 6
81403: PUSH
81404: LD_EXP 80
81408: PPUSH
81409: LD_VAR 0 1
81413: PPUSH
81414: CALL 9230 0 2
81418: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
81419: LD_ADDR_VAR 0 5
81423: PUSH
81424: DOUBLE
81425: LD_EXP 81
81429: PUSH
81430: LD_VAR 0 6
81434: ARRAY
81435: INC
81436: ST_TO_ADDR
81437: LD_INT 1
81439: PUSH
81440: FOR_DOWNTO
81441: IFFALSE 81602
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
81443: LD_EXP 81
81447: PUSH
81448: LD_VAR 0 6
81452: ARRAY
81453: PUSH
81454: LD_VAR 0 5
81458: ARRAY
81459: PUSH
81460: LD_INT 1
81462: ARRAY
81463: PUSH
81464: LD_VAR 0 2
81468: EQUAL
81469: PUSH
81470: LD_EXP 81
81474: PUSH
81475: LD_VAR 0 6
81479: ARRAY
81480: PUSH
81481: LD_VAR 0 5
81485: ARRAY
81486: PUSH
81487: LD_INT 2
81489: ARRAY
81490: PUSH
81491: LD_VAR 0 3
81495: EQUAL
81496: AND
81497: IFFALSE 81600
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
81499: LD_EXP 81
81503: PUSH
81504: LD_VAR 0 6
81508: ARRAY
81509: PUSH
81510: LD_VAR 0 5
81514: ARRAY
81515: PUSH
81516: LD_INT 1
81518: ARRAY
81519: PPUSH
81520: LD_EXP 81
81524: PUSH
81525: LD_VAR 0 6
81529: ARRAY
81530: PUSH
81531: LD_VAR 0 5
81535: ARRAY
81536: PUSH
81537: LD_INT 2
81539: ARRAY
81540: PPUSH
81541: LD_VAR 0 1
81545: PPUSH
81546: CALL_OW 255
81550: PPUSH
81551: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
81555: LD_ADDR_EXP 81
81559: PUSH
81560: LD_EXP 81
81564: PPUSH
81565: LD_VAR 0 6
81569: PPUSH
81570: LD_EXP 81
81574: PUSH
81575: LD_VAR 0 6
81579: ARRAY
81580: PPUSH
81581: LD_VAR 0 5
81585: PPUSH
81586: CALL_OW 3
81590: PPUSH
81591: CALL_OW 1
81595: ST_TO_ADDR
// exit ;
81596: POP
81597: POP
81598: GO 81791
// end ; end ;
81600: GO 81440
81602: POP
81603: POP
// for i := minerMinesList [ index ] downto 1 do
81604: LD_ADDR_VAR 0 5
81608: PUSH
81609: DOUBLE
81610: LD_EXP 81
81614: PUSH
81615: LD_VAR 0 6
81619: ARRAY
81620: INC
81621: ST_TO_ADDR
81622: LD_INT 1
81624: PUSH
81625: FOR_DOWNTO
81626: IFFALSE 81789
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
81628: LD_EXP 81
81632: PUSH
81633: LD_VAR 0 6
81637: ARRAY
81638: PUSH
81639: LD_VAR 0 5
81643: ARRAY
81644: PUSH
81645: LD_INT 1
81647: ARRAY
81648: PPUSH
81649: LD_EXP 81
81653: PUSH
81654: LD_VAR 0 6
81658: ARRAY
81659: PUSH
81660: LD_VAR 0 5
81664: ARRAY
81665: PUSH
81666: LD_INT 2
81668: ARRAY
81669: PPUSH
81670: LD_VAR 0 2
81674: PPUSH
81675: LD_VAR 0 3
81679: PPUSH
81680: CALL_OW 298
81684: PUSH
81685: LD_INT 6
81687: LESS
81688: IFFALSE 81787
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
81690: LD_EXP 81
81694: PUSH
81695: LD_VAR 0 6
81699: ARRAY
81700: PUSH
81701: LD_VAR 0 5
81705: ARRAY
81706: PUSH
81707: LD_INT 1
81709: ARRAY
81710: PPUSH
81711: LD_EXP 81
81715: PUSH
81716: LD_VAR 0 6
81720: ARRAY
81721: PUSH
81722: LD_VAR 0 5
81726: ARRAY
81727: PUSH
81728: LD_INT 2
81730: ARRAY
81731: PPUSH
81732: LD_VAR 0 1
81736: PPUSH
81737: CALL_OW 255
81741: PPUSH
81742: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
81746: LD_ADDR_EXP 81
81750: PUSH
81751: LD_EXP 81
81755: PPUSH
81756: LD_VAR 0 6
81760: PPUSH
81761: LD_EXP 81
81765: PUSH
81766: LD_VAR 0 6
81770: ARRAY
81771: PPUSH
81772: LD_VAR 0 5
81776: PPUSH
81777: CALL_OW 3
81781: PPUSH
81782: CALL_OW 1
81786: ST_TO_ADDR
// end ; end ;
81787: GO 81625
81789: POP
81790: POP
// end ;
81791: LD_VAR 0 4
81795: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
81796: LD_INT 0
81798: PPUSH
81799: PPUSH
81800: PPUSH
81801: PPUSH
81802: PPUSH
81803: PPUSH
81804: PPUSH
81805: PPUSH
81806: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
81807: LD_VAR 0 1
81811: PPUSH
81812: CALL_OW 264
81816: PUSH
81817: LD_EXP 64
81821: EQUAL
81822: NOT
81823: PUSH
81824: LD_VAR 0 1
81828: PUSH
81829: LD_EXP 80
81833: IN
81834: NOT
81835: OR
81836: IFFALSE 81840
// exit ;
81838: GO 82162
// index := GetElementIndex ( minersList , unit ) ;
81840: LD_ADDR_VAR 0 6
81844: PUSH
81845: LD_EXP 80
81849: PPUSH
81850: LD_VAR 0 1
81854: PPUSH
81855: CALL 9230 0 2
81859: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
81860: LD_ADDR_VAR 0 8
81864: PUSH
81865: LD_EXP 82
81869: PUSH
81870: LD_EXP 81
81874: PUSH
81875: LD_VAR 0 6
81879: ARRAY
81880: MINUS
81881: ST_TO_ADDR
// if not minesFreeAmount then
81882: LD_VAR 0 8
81886: NOT
81887: IFFALSE 81891
// exit ;
81889: GO 82162
// tmp := [ ] ;
81891: LD_ADDR_VAR 0 7
81895: PUSH
81896: EMPTY
81897: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
81898: LD_ADDR_VAR 0 5
81902: PUSH
81903: DOUBLE
81904: LD_INT 1
81906: DEC
81907: ST_TO_ADDR
81908: LD_VAR 0 8
81912: PUSH
81913: FOR_TO
81914: IFFALSE 82109
// begin _d := rand ( 0 , 5 ) ;
81916: LD_ADDR_VAR 0 11
81920: PUSH
81921: LD_INT 0
81923: PPUSH
81924: LD_INT 5
81926: PPUSH
81927: CALL_OW 12
81931: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
81932: LD_ADDR_VAR 0 12
81936: PUSH
81937: LD_INT 2
81939: PPUSH
81940: LD_INT 6
81942: PPUSH
81943: CALL_OW 12
81947: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
81948: LD_ADDR_VAR 0 9
81952: PUSH
81953: LD_VAR 0 2
81957: PPUSH
81958: LD_VAR 0 11
81962: PPUSH
81963: LD_VAR 0 12
81967: PPUSH
81968: CALL_OW 272
81972: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
81973: LD_ADDR_VAR 0 10
81977: PUSH
81978: LD_VAR 0 3
81982: PPUSH
81983: LD_VAR 0 11
81987: PPUSH
81988: LD_VAR 0 12
81992: PPUSH
81993: CALL_OW 273
81997: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
81998: LD_VAR 0 9
82002: PPUSH
82003: LD_VAR 0 10
82007: PPUSH
82008: CALL_OW 488
82012: PUSH
82013: LD_VAR 0 9
82017: PUSH
82018: LD_VAR 0 10
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_VAR 0 7
82031: IN
82032: NOT
82033: AND
82034: PUSH
82035: LD_VAR 0 9
82039: PPUSH
82040: LD_VAR 0 10
82044: PPUSH
82045: CALL_OW 458
82049: NOT
82050: AND
82051: IFFALSE 82093
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
82053: LD_ADDR_VAR 0 7
82057: PUSH
82058: LD_VAR 0 7
82062: PPUSH
82063: LD_VAR 0 7
82067: PUSH
82068: LD_INT 1
82070: PLUS
82071: PPUSH
82072: LD_VAR 0 9
82076: PUSH
82077: LD_VAR 0 10
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PPUSH
82086: CALL_OW 1
82090: ST_TO_ADDR
82091: GO 82107
// i := i - 1 ;
82093: LD_ADDR_VAR 0 5
82097: PUSH
82098: LD_VAR 0 5
82102: PUSH
82103: LD_INT 1
82105: MINUS
82106: ST_TO_ADDR
// end ;
82107: GO 81913
82109: POP
82110: POP
// for i in tmp do
82111: LD_ADDR_VAR 0 5
82115: PUSH
82116: LD_VAR 0 7
82120: PUSH
82121: FOR_IN
82122: IFFALSE 82160
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
82124: LD_VAR 0 1
82128: PPUSH
82129: LD_VAR 0 5
82133: PUSH
82134: LD_INT 1
82136: ARRAY
82137: PPUSH
82138: LD_VAR 0 5
82142: PUSH
82143: LD_INT 2
82145: ARRAY
82146: PPUSH
82147: CALL 81102 0 3
82151: NOT
82152: IFFALSE 82158
// exit ;
82154: POP
82155: POP
82156: GO 82162
82158: GO 82121
82160: POP
82161: POP
// end ;
82162: LD_VAR 0 4
82166: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
82167: LD_INT 0
82169: PPUSH
82170: PPUSH
82171: PPUSH
82172: PPUSH
82173: PPUSH
82174: PPUSH
82175: PPUSH
// if not GetClass ( unit ) = class_sniper then
82176: LD_VAR 0 1
82180: PPUSH
82181: CALL_OW 257
82185: PUSH
82186: LD_INT 5
82188: EQUAL
82189: NOT
82190: IFFALSE 82194
// exit ;
82192: GO 82571
// dist := 8 ;
82194: LD_ADDR_VAR 0 5
82198: PUSH
82199: LD_INT 8
82201: ST_TO_ADDR
// viewRange := 12 ;
82202: LD_ADDR_VAR 0 7
82206: PUSH
82207: LD_INT 12
82209: ST_TO_ADDR
// side := GetSide ( unit ) ;
82210: LD_ADDR_VAR 0 6
82214: PUSH
82215: LD_VAR 0 1
82219: PPUSH
82220: CALL_OW 255
82224: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
82225: LD_INT 61
82227: PPUSH
82228: LD_VAR 0 6
82232: PPUSH
82233: CALL_OW 321
82237: PUSH
82238: LD_INT 2
82240: EQUAL
82241: IFFALSE 82251
// viewRange := 16 ;
82243: LD_ADDR_VAR 0 7
82247: PUSH
82248: LD_INT 16
82250: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
82251: LD_VAR 0 1
82255: PPUSH
82256: LD_VAR 0 2
82260: PPUSH
82261: LD_VAR 0 3
82265: PPUSH
82266: CALL_OW 297
82270: PUSH
82271: LD_VAR 0 5
82275: GREATER
82276: IFFALSE 82355
// begin ComMoveXY ( unit , x , y ) ;
82278: LD_VAR 0 1
82282: PPUSH
82283: LD_VAR 0 2
82287: PPUSH
82288: LD_VAR 0 3
82292: PPUSH
82293: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
82297: LD_INT 35
82299: PPUSH
82300: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
82304: LD_VAR 0 1
82308: PPUSH
82309: LD_VAR 0 2
82313: PPUSH
82314: LD_VAR 0 3
82318: PPUSH
82319: CALL 39294 0 3
82323: NOT
82324: IFFALSE 82328
// exit ;
82326: GO 82571
// until GetDistUnitXY ( unit , x , y ) < dist ;
82328: LD_VAR 0 1
82332: PPUSH
82333: LD_VAR 0 2
82337: PPUSH
82338: LD_VAR 0 3
82342: PPUSH
82343: CALL_OW 297
82347: PUSH
82348: LD_VAR 0 5
82352: LESS
82353: IFFALSE 82297
// end ; ComTurnXY ( unit , x , y ) ;
82355: LD_VAR 0 1
82359: PPUSH
82360: LD_VAR 0 2
82364: PPUSH
82365: LD_VAR 0 3
82369: PPUSH
82370: CALL_OW 118
// wait ( 5 ) ;
82374: LD_INT 5
82376: PPUSH
82377: CALL_OW 67
// _d := GetDir ( unit ) ;
82381: LD_ADDR_VAR 0 10
82385: PUSH
82386: LD_VAR 0 1
82390: PPUSH
82391: CALL_OW 254
82395: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
82396: LD_ADDR_VAR 0 8
82400: PUSH
82401: LD_VAR 0 1
82405: PPUSH
82406: CALL_OW 250
82410: PPUSH
82411: LD_VAR 0 10
82415: PPUSH
82416: LD_VAR 0 5
82420: PPUSH
82421: CALL_OW 272
82425: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
82426: LD_ADDR_VAR 0 9
82430: PUSH
82431: LD_VAR 0 1
82435: PPUSH
82436: CALL_OW 251
82440: PPUSH
82441: LD_VAR 0 10
82445: PPUSH
82446: LD_VAR 0 5
82450: PPUSH
82451: CALL_OW 273
82455: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
82456: LD_VAR 0 8
82460: PPUSH
82461: LD_VAR 0 9
82465: PPUSH
82466: CALL_OW 488
82470: NOT
82471: IFFALSE 82475
// exit ;
82473: GO 82571
// ComAnimCustom ( unit , 1 ) ;
82475: LD_VAR 0 1
82479: PPUSH
82480: LD_INT 1
82482: PPUSH
82483: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
82487: LD_VAR 0 8
82491: PPUSH
82492: LD_VAR 0 9
82496: PPUSH
82497: LD_VAR 0 6
82501: PPUSH
82502: LD_VAR 0 7
82506: PPUSH
82507: CALL_OW 330
// repeat wait ( 1 ) ;
82511: LD_INT 1
82513: PPUSH
82514: CALL_OW 67
// until IsIdle ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
82518: LD_VAR 0 1
82522: PPUSH
82523: CALL_OW 316
82527: PUSH
82528: LD_VAR 0 1
82532: PPUSH
82533: CALL_OW 302
82537: NOT
82538: OR
82539: PUSH
82540: LD_VAR 0 1
82544: PPUSH
82545: CALL_OW 301
82549: OR
82550: IFFALSE 82511
// RemoveSeeing ( _x , _y , side ) ;
82552: LD_VAR 0 8
82556: PPUSH
82557: LD_VAR 0 9
82561: PPUSH
82562: LD_VAR 0 6
82566: PPUSH
82567: CALL_OW 331
// end ; end_of_file end_of_file
82571: LD_VAR 0 4
82575: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
82576: LD_VAR 0 1
82580: PUSH
82581: LD_INT 200
82583: DOUBLE
82584: GREATEREQUAL
82585: IFFALSE 82593
82587: LD_INT 299
82589: DOUBLE
82590: LESSEQUAL
82591: IFTRUE 82595
82593: GO 82627
82595: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
82596: LD_VAR 0 1
82600: PPUSH
82601: LD_VAR 0 2
82605: PPUSH
82606: LD_VAR 0 3
82610: PPUSH
82611: LD_VAR 0 4
82615: PPUSH
82616: LD_VAR 0 5
82620: PPUSH
82621: CALL 78712 0 5
82625: GO 82704
82627: LD_INT 300
82629: DOUBLE
82630: GREATEREQUAL
82631: IFFALSE 82639
82633: LD_INT 399
82635: DOUBLE
82636: LESSEQUAL
82637: IFTRUE 82641
82639: GO 82703
82641: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
82642: LD_VAR 0 1
82646: PPUSH
82647: LD_VAR 0 2
82651: PPUSH
82652: LD_VAR 0 3
82656: PPUSH
82657: LD_VAR 0 4
82661: PPUSH
82662: LD_VAR 0 5
82666: PPUSH
82667: LD_VAR 0 6
82671: PPUSH
82672: LD_VAR 0 7
82676: PPUSH
82677: LD_VAR 0 8
82681: PPUSH
82682: LD_VAR 0 9
82686: PPUSH
82687: LD_VAR 0 10
82691: PPUSH
82692: LD_VAR 0 11
82696: PPUSH
82697: CALL 93894 0 11
82701: GO 82704
82703: POP
// end ; end_of_file
82704: PPOPN 11
82706: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
82707: LD_VAR 0 2
82711: PUSH
82712: LD_INT 100
82714: EQUAL
82715: IFFALSE 83664
// begin if not StreamModeActive then
82717: LD_EXP 83
82721: NOT
82722: IFFALSE 82732
// StreamModeActive := true ;
82724: LD_ADDR_EXP 83
82728: PUSH
82729: LD_INT 1
82731: ST_TO_ADDR
// if p3 = 0 then
82732: LD_VAR 0 3
82736: PUSH
82737: LD_INT 0
82739: EQUAL
82740: IFFALSE 82746
// InitStreamMode ;
82742: CALL 83822 0 0
// if p3 = 1 then
82746: LD_VAR 0 3
82750: PUSH
82751: LD_INT 1
82753: EQUAL
82754: IFFALSE 82764
// sRocket := true ;
82756: LD_ADDR_EXP 88
82760: PUSH
82761: LD_INT 1
82763: ST_TO_ADDR
// if p3 = 2 then
82764: LD_VAR 0 3
82768: PUSH
82769: LD_INT 2
82771: EQUAL
82772: IFFALSE 82782
// sSpeed := true ;
82774: LD_ADDR_EXP 87
82778: PUSH
82779: LD_INT 1
82781: ST_TO_ADDR
// if p3 = 3 then
82782: LD_VAR 0 3
82786: PUSH
82787: LD_INT 3
82789: EQUAL
82790: IFFALSE 82800
// sEngine := true ;
82792: LD_ADDR_EXP 89
82796: PUSH
82797: LD_INT 1
82799: ST_TO_ADDR
// if p3 = 4 then
82800: LD_VAR 0 3
82804: PUSH
82805: LD_INT 4
82807: EQUAL
82808: IFFALSE 82818
// sSpec := true ;
82810: LD_ADDR_EXP 86
82814: PUSH
82815: LD_INT 1
82817: ST_TO_ADDR
// if p3 = 5 then
82818: LD_VAR 0 3
82822: PUSH
82823: LD_INT 5
82825: EQUAL
82826: IFFALSE 82836
// sLevel := true ;
82828: LD_ADDR_EXP 90
82832: PUSH
82833: LD_INT 1
82835: ST_TO_ADDR
// if p3 = 6 then
82836: LD_VAR 0 3
82840: PUSH
82841: LD_INT 6
82843: EQUAL
82844: IFFALSE 82854
// sArmoury := true ;
82846: LD_ADDR_EXP 91
82850: PUSH
82851: LD_INT 1
82853: ST_TO_ADDR
// if p3 = 7 then
82854: LD_VAR 0 3
82858: PUSH
82859: LD_INT 7
82861: EQUAL
82862: IFFALSE 82872
// sRadar := true ;
82864: LD_ADDR_EXP 92
82868: PUSH
82869: LD_INT 1
82871: ST_TO_ADDR
// if p3 = 8 then
82872: LD_VAR 0 3
82876: PUSH
82877: LD_INT 8
82879: EQUAL
82880: IFFALSE 82890
// sBunker := true ;
82882: LD_ADDR_EXP 93
82886: PUSH
82887: LD_INT 1
82889: ST_TO_ADDR
// if p3 = 9 then
82890: LD_VAR 0 3
82894: PUSH
82895: LD_INT 9
82897: EQUAL
82898: IFFALSE 82908
// sHack := true ;
82900: LD_ADDR_EXP 94
82904: PUSH
82905: LD_INT 1
82907: ST_TO_ADDR
// if p3 = 10 then
82908: LD_VAR 0 3
82912: PUSH
82913: LD_INT 10
82915: EQUAL
82916: IFFALSE 82926
// sFire := true ;
82918: LD_ADDR_EXP 95
82922: PUSH
82923: LD_INT 1
82925: ST_TO_ADDR
// if p3 = 11 then
82926: LD_VAR 0 3
82930: PUSH
82931: LD_INT 11
82933: EQUAL
82934: IFFALSE 82944
// sRefresh := true ;
82936: LD_ADDR_EXP 96
82940: PUSH
82941: LD_INT 1
82943: ST_TO_ADDR
// if p3 = 12 then
82944: LD_VAR 0 3
82948: PUSH
82949: LD_INT 12
82951: EQUAL
82952: IFFALSE 82962
// sExp := true ;
82954: LD_ADDR_EXP 97
82958: PUSH
82959: LD_INT 1
82961: ST_TO_ADDR
// if p3 = 13 then
82962: LD_VAR 0 3
82966: PUSH
82967: LD_INT 13
82969: EQUAL
82970: IFFALSE 82980
// sDepot := true ;
82972: LD_ADDR_EXP 98
82976: PUSH
82977: LD_INT 1
82979: ST_TO_ADDR
// if p3 = 14 then
82980: LD_VAR 0 3
82984: PUSH
82985: LD_INT 14
82987: EQUAL
82988: IFFALSE 82998
// sFlag := true ;
82990: LD_ADDR_EXP 99
82994: PUSH
82995: LD_INT 1
82997: ST_TO_ADDR
// if p3 = 15 then
82998: LD_VAR 0 3
83002: PUSH
83003: LD_INT 15
83005: EQUAL
83006: IFFALSE 83016
// sKamikadze := true ;
83008: LD_ADDR_EXP 107
83012: PUSH
83013: LD_INT 1
83015: ST_TO_ADDR
// if p3 = 16 then
83016: LD_VAR 0 3
83020: PUSH
83021: LD_INT 16
83023: EQUAL
83024: IFFALSE 83034
// sTroll := true ;
83026: LD_ADDR_EXP 108
83030: PUSH
83031: LD_INT 1
83033: ST_TO_ADDR
// if p3 = 17 then
83034: LD_VAR 0 3
83038: PUSH
83039: LD_INT 17
83041: EQUAL
83042: IFFALSE 83052
// sSlow := true ;
83044: LD_ADDR_EXP 109
83048: PUSH
83049: LD_INT 1
83051: ST_TO_ADDR
// if p3 = 18 then
83052: LD_VAR 0 3
83056: PUSH
83057: LD_INT 18
83059: EQUAL
83060: IFFALSE 83070
// sLack := true ;
83062: LD_ADDR_EXP 110
83066: PUSH
83067: LD_INT 1
83069: ST_TO_ADDR
// if p3 = 19 then
83070: LD_VAR 0 3
83074: PUSH
83075: LD_INT 19
83077: EQUAL
83078: IFFALSE 83088
// sTank := true ;
83080: LD_ADDR_EXP 112
83084: PUSH
83085: LD_INT 1
83087: ST_TO_ADDR
// if p3 = 20 then
83088: LD_VAR 0 3
83092: PUSH
83093: LD_INT 20
83095: EQUAL
83096: IFFALSE 83106
// sRemote := true ;
83098: LD_ADDR_EXP 113
83102: PUSH
83103: LD_INT 1
83105: ST_TO_ADDR
// if p3 = 21 then
83106: LD_VAR 0 3
83110: PUSH
83111: LD_INT 21
83113: EQUAL
83114: IFFALSE 83124
// sPowell := true ;
83116: LD_ADDR_EXP 114
83120: PUSH
83121: LD_INT 1
83123: ST_TO_ADDR
// if p3 = 22 then
83124: LD_VAR 0 3
83128: PUSH
83129: LD_INT 22
83131: EQUAL
83132: IFFALSE 83142
// sTeleport := true ;
83134: LD_ADDR_EXP 117
83138: PUSH
83139: LD_INT 1
83141: ST_TO_ADDR
// if p3 = 23 then
83142: LD_VAR 0 3
83146: PUSH
83147: LD_INT 23
83149: EQUAL
83150: IFFALSE 83160
// sOilTower := true ;
83152: LD_ADDR_EXP 119
83156: PUSH
83157: LD_INT 1
83159: ST_TO_ADDR
// if p3 = 24 then
83160: LD_VAR 0 3
83164: PUSH
83165: LD_INT 24
83167: EQUAL
83168: IFFALSE 83178
// sShovel := true ;
83170: LD_ADDR_EXP 120
83174: PUSH
83175: LD_INT 1
83177: ST_TO_ADDR
// if p3 = 25 then
83178: LD_VAR 0 3
83182: PUSH
83183: LD_INT 25
83185: EQUAL
83186: IFFALSE 83196
// sSheik := true ;
83188: LD_ADDR_EXP 121
83192: PUSH
83193: LD_INT 1
83195: ST_TO_ADDR
// if p3 = 26 then
83196: LD_VAR 0 3
83200: PUSH
83201: LD_INT 26
83203: EQUAL
83204: IFFALSE 83214
// sEarthquake := true ;
83206: LD_ADDR_EXP 123
83210: PUSH
83211: LD_INT 1
83213: ST_TO_ADDR
// if p3 = 27 then
83214: LD_VAR 0 3
83218: PUSH
83219: LD_INT 27
83221: EQUAL
83222: IFFALSE 83232
// sAI := true ;
83224: LD_ADDR_EXP 124
83228: PUSH
83229: LD_INT 1
83231: ST_TO_ADDR
// if p3 = 28 then
83232: LD_VAR 0 3
83236: PUSH
83237: LD_INT 28
83239: EQUAL
83240: IFFALSE 83250
// sCargo := true ;
83242: LD_ADDR_EXP 127
83246: PUSH
83247: LD_INT 1
83249: ST_TO_ADDR
// if p3 = 29 then
83250: LD_VAR 0 3
83254: PUSH
83255: LD_INT 29
83257: EQUAL
83258: IFFALSE 83268
// sDLaser := true ;
83260: LD_ADDR_EXP 128
83264: PUSH
83265: LD_INT 1
83267: ST_TO_ADDR
// if p3 = 30 then
83268: LD_VAR 0 3
83272: PUSH
83273: LD_INT 30
83275: EQUAL
83276: IFFALSE 83286
// sExchange := true ;
83278: LD_ADDR_EXP 129
83282: PUSH
83283: LD_INT 1
83285: ST_TO_ADDR
// if p3 = 31 then
83286: LD_VAR 0 3
83290: PUSH
83291: LD_INT 31
83293: EQUAL
83294: IFFALSE 83304
// sFac := true ;
83296: LD_ADDR_EXP 130
83300: PUSH
83301: LD_INT 1
83303: ST_TO_ADDR
// if p3 = 32 then
83304: LD_VAR 0 3
83308: PUSH
83309: LD_INT 32
83311: EQUAL
83312: IFFALSE 83322
// sPower := true ;
83314: LD_ADDR_EXP 131
83318: PUSH
83319: LD_INT 1
83321: ST_TO_ADDR
// if p3 = 33 then
83322: LD_VAR 0 3
83326: PUSH
83327: LD_INT 33
83329: EQUAL
83330: IFFALSE 83340
// sRandom := true ;
83332: LD_ADDR_EXP 132
83336: PUSH
83337: LD_INT 1
83339: ST_TO_ADDR
// if p3 = 34 then
83340: LD_VAR 0 3
83344: PUSH
83345: LD_INT 34
83347: EQUAL
83348: IFFALSE 83358
// sShield := true ;
83350: LD_ADDR_EXP 133
83354: PUSH
83355: LD_INT 1
83357: ST_TO_ADDR
// if p3 = 35 then
83358: LD_VAR 0 3
83362: PUSH
83363: LD_INT 35
83365: EQUAL
83366: IFFALSE 83376
// sTime := true ;
83368: LD_ADDR_EXP 134
83372: PUSH
83373: LD_INT 1
83375: ST_TO_ADDR
// if p3 = 36 then
83376: LD_VAR 0 3
83380: PUSH
83381: LD_INT 36
83383: EQUAL
83384: IFFALSE 83394
// sTools := true ;
83386: LD_ADDR_EXP 135
83390: PUSH
83391: LD_INT 1
83393: ST_TO_ADDR
// if p3 = 101 then
83394: LD_VAR 0 3
83398: PUSH
83399: LD_INT 101
83401: EQUAL
83402: IFFALSE 83412
// sSold := true ;
83404: LD_ADDR_EXP 100
83408: PUSH
83409: LD_INT 1
83411: ST_TO_ADDR
// if p3 = 102 then
83412: LD_VAR 0 3
83416: PUSH
83417: LD_INT 102
83419: EQUAL
83420: IFFALSE 83430
// sDiff := true ;
83422: LD_ADDR_EXP 101
83426: PUSH
83427: LD_INT 1
83429: ST_TO_ADDR
// if p3 = 103 then
83430: LD_VAR 0 3
83434: PUSH
83435: LD_INT 103
83437: EQUAL
83438: IFFALSE 83448
// sFog := true ;
83440: LD_ADDR_EXP 104
83444: PUSH
83445: LD_INT 1
83447: ST_TO_ADDR
// if p3 = 104 then
83448: LD_VAR 0 3
83452: PUSH
83453: LD_INT 104
83455: EQUAL
83456: IFFALSE 83466
// sReset := true ;
83458: LD_ADDR_EXP 105
83462: PUSH
83463: LD_INT 1
83465: ST_TO_ADDR
// if p3 = 105 then
83466: LD_VAR 0 3
83470: PUSH
83471: LD_INT 105
83473: EQUAL
83474: IFFALSE 83484
// sSun := true ;
83476: LD_ADDR_EXP 106
83480: PUSH
83481: LD_INT 1
83483: ST_TO_ADDR
// if p3 = 106 then
83484: LD_VAR 0 3
83488: PUSH
83489: LD_INT 106
83491: EQUAL
83492: IFFALSE 83502
// sTiger := true ;
83494: LD_ADDR_EXP 102
83498: PUSH
83499: LD_INT 1
83501: ST_TO_ADDR
// if p3 = 107 then
83502: LD_VAR 0 3
83506: PUSH
83507: LD_INT 107
83509: EQUAL
83510: IFFALSE 83520
// sBomb := true ;
83512: LD_ADDR_EXP 103
83516: PUSH
83517: LD_INT 1
83519: ST_TO_ADDR
// if p3 = 108 then
83520: LD_VAR 0 3
83524: PUSH
83525: LD_INT 108
83527: EQUAL
83528: IFFALSE 83538
// sWound := true ;
83530: LD_ADDR_EXP 111
83534: PUSH
83535: LD_INT 1
83537: ST_TO_ADDR
// if p3 = 109 then
83538: LD_VAR 0 3
83542: PUSH
83543: LD_INT 109
83545: EQUAL
83546: IFFALSE 83556
// sBetray := true ;
83548: LD_ADDR_EXP 115
83552: PUSH
83553: LD_INT 1
83555: ST_TO_ADDR
// if p3 = 110 then
83556: LD_VAR 0 3
83560: PUSH
83561: LD_INT 110
83563: EQUAL
83564: IFFALSE 83574
// sContamin := true ;
83566: LD_ADDR_EXP 116
83570: PUSH
83571: LD_INT 1
83573: ST_TO_ADDR
// if p3 = 111 then
83574: LD_VAR 0 3
83578: PUSH
83579: LD_INT 111
83581: EQUAL
83582: IFFALSE 83592
// sOil := true ;
83584: LD_ADDR_EXP 118
83588: PUSH
83589: LD_INT 1
83591: ST_TO_ADDR
// if p3 = 112 then
83592: LD_VAR 0 3
83596: PUSH
83597: LD_INT 112
83599: EQUAL
83600: IFFALSE 83610
// sStu := true ;
83602: LD_ADDR_EXP 122
83606: PUSH
83607: LD_INT 1
83609: ST_TO_ADDR
// if p3 = 113 then
83610: LD_VAR 0 3
83614: PUSH
83615: LD_INT 113
83617: EQUAL
83618: IFFALSE 83628
// sBazooka := true ;
83620: LD_ADDR_EXP 125
83624: PUSH
83625: LD_INT 1
83627: ST_TO_ADDR
// if p3 = 114 then
83628: LD_VAR 0 3
83632: PUSH
83633: LD_INT 114
83635: EQUAL
83636: IFFALSE 83646
// sMortar := true ;
83638: LD_ADDR_EXP 126
83642: PUSH
83643: LD_INT 1
83645: ST_TO_ADDR
// if p3 = 115 then
83646: LD_VAR 0 3
83650: PUSH
83651: LD_INT 115
83653: EQUAL
83654: IFFALSE 83664
// sRanger := true ;
83656: LD_ADDR_EXP 136
83660: PUSH
83661: LD_INT 1
83663: ST_TO_ADDR
// end ; if p2 = 101 then
83664: LD_VAR 0 2
83668: PUSH
83669: LD_INT 101
83671: EQUAL
83672: IFFALSE 83800
// begin case p3 of 1 :
83674: LD_VAR 0 3
83678: PUSH
83679: LD_INT 1
83681: DOUBLE
83682: EQUAL
83683: IFTRUE 83687
83685: GO 83694
83687: POP
// hHackUnlimitedResources ; 2 :
83688: CALL 94835 0 0
83692: GO 83800
83694: LD_INT 2
83696: DOUBLE
83697: EQUAL
83698: IFTRUE 83702
83700: GO 83709
83702: POP
// hHackSetLevel10 ; 3 :
83703: CALL 94968 0 0
83707: GO 83800
83709: LD_INT 3
83711: DOUBLE
83712: EQUAL
83713: IFTRUE 83717
83715: GO 83724
83717: POP
// hHackSetLevel10YourUnits ; 4 :
83718: CALL 95053 0 0
83722: GO 83800
83724: LD_INT 4
83726: DOUBLE
83727: EQUAL
83728: IFTRUE 83732
83730: GO 83739
83732: POP
// hHackInvincible ; 5 :
83733: CALL 95501 0 0
83737: GO 83800
83739: LD_INT 5
83741: DOUBLE
83742: EQUAL
83743: IFTRUE 83747
83745: GO 83754
83747: POP
// hHackInvisible ; 6 :
83748: CALL 95612 0 0
83752: GO 83800
83754: LD_INT 6
83756: DOUBLE
83757: EQUAL
83758: IFTRUE 83762
83760: GO 83769
83762: POP
// hHackChangeYourSide ; 7 :
83763: CALL 95669 0 0
83767: GO 83800
83769: LD_INT 7
83771: DOUBLE
83772: EQUAL
83773: IFTRUE 83777
83775: GO 83784
83777: POP
// hHackChangeUnitSide ; 8 :
83778: CALL 95711 0 0
83782: GO 83800
83784: LD_INT 8
83786: DOUBLE
83787: EQUAL
83788: IFTRUE 83792
83790: GO 83799
83792: POP
// hHackFog ; end ;
83793: CALL 95812 0 0
83797: GO 83800
83799: POP
// end ; end ;
83800: PPOPN 6
83802: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83803: GO 83805
83805: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83806: LD_STRING initStreamRollete();
83808: PPUSH
83809: CALL_OW 559
// InitStreamMode ;
83813: CALL 83822 0 0
// DefineStreamItems ( ) ;
83817: CALL 84262 0 0
// end ;
83821: END
// function InitStreamMode ; begin
83822: LD_INT 0
83824: PPUSH
// streamModeActive := false ;
83825: LD_ADDR_EXP 83
83829: PUSH
83830: LD_INT 0
83832: ST_TO_ADDR
// normalCounter := 36 ;
83833: LD_ADDR_EXP 84
83837: PUSH
83838: LD_INT 36
83840: ST_TO_ADDR
// hardcoreCounter := 16 ;
83841: LD_ADDR_EXP 85
83845: PUSH
83846: LD_INT 16
83848: ST_TO_ADDR
// sRocket := false ;
83849: LD_ADDR_EXP 88
83853: PUSH
83854: LD_INT 0
83856: ST_TO_ADDR
// sSpeed := false ;
83857: LD_ADDR_EXP 87
83861: PUSH
83862: LD_INT 0
83864: ST_TO_ADDR
// sEngine := false ;
83865: LD_ADDR_EXP 89
83869: PUSH
83870: LD_INT 0
83872: ST_TO_ADDR
// sSpec := false ;
83873: LD_ADDR_EXP 86
83877: PUSH
83878: LD_INT 0
83880: ST_TO_ADDR
// sLevel := false ;
83881: LD_ADDR_EXP 90
83885: PUSH
83886: LD_INT 0
83888: ST_TO_ADDR
// sArmoury := false ;
83889: LD_ADDR_EXP 91
83893: PUSH
83894: LD_INT 0
83896: ST_TO_ADDR
// sRadar := false ;
83897: LD_ADDR_EXP 92
83901: PUSH
83902: LD_INT 0
83904: ST_TO_ADDR
// sBunker := false ;
83905: LD_ADDR_EXP 93
83909: PUSH
83910: LD_INT 0
83912: ST_TO_ADDR
// sHack := false ;
83913: LD_ADDR_EXP 94
83917: PUSH
83918: LD_INT 0
83920: ST_TO_ADDR
// sFire := false ;
83921: LD_ADDR_EXP 95
83925: PUSH
83926: LD_INT 0
83928: ST_TO_ADDR
// sRefresh := false ;
83929: LD_ADDR_EXP 96
83933: PUSH
83934: LD_INT 0
83936: ST_TO_ADDR
// sExp := false ;
83937: LD_ADDR_EXP 97
83941: PUSH
83942: LD_INT 0
83944: ST_TO_ADDR
// sDepot := false ;
83945: LD_ADDR_EXP 98
83949: PUSH
83950: LD_INT 0
83952: ST_TO_ADDR
// sFlag := false ;
83953: LD_ADDR_EXP 99
83957: PUSH
83958: LD_INT 0
83960: ST_TO_ADDR
// sKamikadze := false ;
83961: LD_ADDR_EXP 107
83965: PUSH
83966: LD_INT 0
83968: ST_TO_ADDR
// sTroll := false ;
83969: LD_ADDR_EXP 108
83973: PUSH
83974: LD_INT 0
83976: ST_TO_ADDR
// sSlow := false ;
83977: LD_ADDR_EXP 109
83981: PUSH
83982: LD_INT 0
83984: ST_TO_ADDR
// sLack := false ;
83985: LD_ADDR_EXP 110
83989: PUSH
83990: LD_INT 0
83992: ST_TO_ADDR
// sTank := false ;
83993: LD_ADDR_EXP 112
83997: PUSH
83998: LD_INT 0
84000: ST_TO_ADDR
// sRemote := false ;
84001: LD_ADDR_EXP 113
84005: PUSH
84006: LD_INT 0
84008: ST_TO_ADDR
// sPowell := false ;
84009: LD_ADDR_EXP 114
84013: PUSH
84014: LD_INT 0
84016: ST_TO_ADDR
// sTeleport := false ;
84017: LD_ADDR_EXP 117
84021: PUSH
84022: LD_INT 0
84024: ST_TO_ADDR
// sOilTower := false ;
84025: LD_ADDR_EXP 119
84029: PUSH
84030: LD_INT 0
84032: ST_TO_ADDR
// sShovel := false ;
84033: LD_ADDR_EXP 120
84037: PUSH
84038: LD_INT 0
84040: ST_TO_ADDR
// sSheik := false ;
84041: LD_ADDR_EXP 121
84045: PUSH
84046: LD_INT 0
84048: ST_TO_ADDR
// sEarthquake := false ;
84049: LD_ADDR_EXP 123
84053: PUSH
84054: LD_INT 0
84056: ST_TO_ADDR
// sAI := false ;
84057: LD_ADDR_EXP 124
84061: PUSH
84062: LD_INT 0
84064: ST_TO_ADDR
// sCargo := false ;
84065: LD_ADDR_EXP 127
84069: PUSH
84070: LD_INT 0
84072: ST_TO_ADDR
// sDLaser := false ;
84073: LD_ADDR_EXP 128
84077: PUSH
84078: LD_INT 0
84080: ST_TO_ADDR
// sExchange := false ;
84081: LD_ADDR_EXP 129
84085: PUSH
84086: LD_INT 0
84088: ST_TO_ADDR
// sFac := false ;
84089: LD_ADDR_EXP 130
84093: PUSH
84094: LD_INT 0
84096: ST_TO_ADDR
// sPower := false ;
84097: LD_ADDR_EXP 131
84101: PUSH
84102: LD_INT 0
84104: ST_TO_ADDR
// sRandom := false ;
84105: LD_ADDR_EXP 132
84109: PUSH
84110: LD_INT 0
84112: ST_TO_ADDR
// sShield := false ;
84113: LD_ADDR_EXP 133
84117: PUSH
84118: LD_INT 0
84120: ST_TO_ADDR
// sTime := false ;
84121: LD_ADDR_EXP 134
84125: PUSH
84126: LD_INT 0
84128: ST_TO_ADDR
// sTools := false ;
84129: LD_ADDR_EXP 135
84133: PUSH
84134: LD_INT 0
84136: ST_TO_ADDR
// sSold := false ;
84137: LD_ADDR_EXP 100
84141: PUSH
84142: LD_INT 0
84144: ST_TO_ADDR
// sDiff := false ;
84145: LD_ADDR_EXP 101
84149: PUSH
84150: LD_INT 0
84152: ST_TO_ADDR
// sFog := false ;
84153: LD_ADDR_EXP 104
84157: PUSH
84158: LD_INT 0
84160: ST_TO_ADDR
// sReset := false ;
84161: LD_ADDR_EXP 105
84165: PUSH
84166: LD_INT 0
84168: ST_TO_ADDR
// sSun := false ;
84169: LD_ADDR_EXP 106
84173: PUSH
84174: LD_INT 0
84176: ST_TO_ADDR
// sTiger := false ;
84177: LD_ADDR_EXP 102
84181: PUSH
84182: LD_INT 0
84184: ST_TO_ADDR
// sBomb := false ;
84185: LD_ADDR_EXP 103
84189: PUSH
84190: LD_INT 0
84192: ST_TO_ADDR
// sWound := false ;
84193: LD_ADDR_EXP 111
84197: PUSH
84198: LD_INT 0
84200: ST_TO_ADDR
// sBetray := false ;
84201: LD_ADDR_EXP 115
84205: PUSH
84206: LD_INT 0
84208: ST_TO_ADDR
// sContamin := false ;
84209: LD_ADDR_EXP 116
84213: PUSH
84214: LD_INT 0
84216: ST_TO_ADDR
// sOil := false ;
84217: LD_ADDR_EXP 118
84221: PUSH
84222: LD_INT 0
84224: ST_TO_ADDR
// sStu := false ;
84225: LD_ADDR_EXP 122
84229: PUSH
84230: LD_INT 0
84232: ST_TO_ADDR
// sBazooka := false ;
84233: LD_ADDR_EXP 125
84237: PUSH
84238: LD_INT 0
84240: ST_TO_ADDR
// sMortar := false ;
84241: LD_ADDR_EXP 126
84245: PUSH
84246: LD_INT 0
84248: ST_TO_ADDR
// sRanger := false ;
84249: LD_ADDR_EXP 136
84253: PUSH
84254: LD_INT 0
84256: ST_TO_ADDR
// end ;
84257: LD_VAR 0 1
84261: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
84262: LD_INT 0
84264: PPUSH
84265: PPUSH
84266: PPUSH
84267: PPUSH
84268: PPUSH
// result := [ ] ;
84269: LD_ADDR_VAR 0 1
84273: PUSH
84274: EMPTY
84275: ST_TO_ADDR
// if campaign_id = 1 then
84276: LD_OWVAR 69
84280: PUSH
84281: LD_INT 1
84283: EQUAL
84284: IFFALSE 87222
// begin case mission_number of 1 :
84286: LD_OWVAR 70
84290: PUSH
84291: LD_INT 1
84293: DOUBLE
84294: EQUAL
84295: IFTRUE 84299
84297: GO 84363
84299: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84300: LD_ADDR_VAR 0 1
84304: PUSH
84305: LD_INT 2
84307: PUSH
84308: LD_INT 4
84310: PUSH
84311: LD_INT 11
84313: PUSH
84314: LD_INT 12
84316: PUSH
84317: LD_INT 15
84319: PUSH
84320: LD_INT 16
84322: PUSH
84323: LD_INT 22
84325: PUSH
84326: LD_INT 23
84328: PUSH
84329: LD_INT 26
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: PUSH
84343: LD_INT 101
84345: PUSH
84346: LD_INT 102
84348: PUSH
84349: LD_INT 106
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: LIST
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: ST_TO_ADDR
84361: GO 87220
84363: LD_INT 2
84365: DOUBLE
84366: EQUAL
84367: IFTRUE 84371
84369: GO 84443
84371: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84372: LD_ADDR_VAR 0 1
84376: PUSH
84377: LD_INT 2
84379: PUSH
84380: LD_INT 4
84382: PUSH
84383: LD_INT 11
84385: PUSH
84386: LD_INT 12
84388: PUSH
84389: LD_INT 15
84391: PUSH
84392: LD_INT 16
84394: PUSH
84395: LD_INT 22
84397: PUSH
84398: LD_INT 23
84400: PUSH
84401: LD_INT 26
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 101
84417: PUSH
84418: LD_INT 102
84420: PUSH
84421: LD_INT 105
84423: PUSH
84424: LD_INT 106
84426: PUSH
84427: LD_INT 108
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: ST_TO_ADDR
84441: GO 87220
84443: LD_INT 3
84445: DOUBLE
84446: EQUAL
84447: IFTRUE 84451
84449: GO 84527
84451: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84452: LD_ADDR_VAR 0 1
84456: PUSH
84457: LD_INT 2
84459: PUSH
84460: LD_INT 4
84462: PUSH
84463: LD_INT 5
84465: PUSH
84466: LD_INT 11
84468: PUSH
84469: LD_INT 12
84471: PUSH
84472: LD_INT 15
84474: PUSH
84475: LD_INT 16
84477: PUSH
84478: LD_INT 22
84480: PUSH
84481: LD_INT 26
84483: PUSH
84484: LD_INT 36
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 101
84501: PUSH
84502: LD_INT 102
84504: PUSH
84505: LD_INT 105
84507: PUSH
84508: LD_INT 106
84510: PUSH
84511: LD_INT 108
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: ST_TO_ADDR
84525: GO 87220
84527: LD_INT 4
84529: DOUBLE
84530: EQUAL
84531: IFTRUE 84535
84533: GO 84619
84535: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84536: LD_ADDR_VAR 0 1
84540: PUSH
84541: LD_INT 2
84543: PUSH
84544: LD_INT 4
84546: PUSH
84547: LD_INT 5
84549: PUSH
84550: LD_INT 8
84552: PUSH
84553: LD_INT 11
84555: PUSH
84556: LD_INT 12
84558: PUSH
84559: LD_INT 15
84561: PUSH
84562: LD_INT 16
84564: PUSH
84565: LD_INT 22
84567: PUSH
84568: LD_INT 23
84570: PUSH
84571: LD_INT 26
84573: PUSH
84574: LD_INT 36
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 101
84593: PUSH
84594: LD_INT 102
84596: PUSH
84597: LD_INT 105
84599: PUSH
84600: LD_INT 106
84602: PUSH
84603: LD_INT 108
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: ST_TO_ADDR
84617: GO 87220
84619: LD_INT 5
84621: DOUBLE
84622: EQUAL
84623: IFTRUE 84627
84625: GO 84727
84627: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84628: LD_ADDR_VAR 0 1
84632: PUSH
84633: LD_INT 2
84635: PUSH
84636: LD_INT 4
84638: PUSH
84639: LD_INT 5
84641: PUSH
84642: LD_INT 6
84644: PUSH
84645: LD_INT 8
84647: PUSH
84648: LD_INT 11
84650: PUSH
84651: LD_INT 12
84653: PUSH
84654: LD_INT 15
84656: PUSH
84657: LD_INT 16
84659: PUSH
84660: LD_INT 22
84662: PUSH
84663: LD_INT 23
84665: PUSH
84666: LD_INT 25
84668: PUSH
84669: LD_INT 26
84671: PUSH
84672: LD_INT 36
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 101
84693: PUSH
84694: LD_INT 102
84696: PUSH
84697: LD_INT 105
84699: PUSH
84700: LD_INT 106
84702: PUSH
84703: LD_INT 108
84705: PUSH
84706: LD_INT 109
84708: PUSH
84709: LD_INT 112
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: ST_TO_ADDR
84725: GO 87220
84727: LD_INT 6
84729: DOUBLE
84730: EQUAL
84731: IFTRUE 84735
84733: GO 84855
84735: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84736: LD_ADDR_VAR 0 1
84740: PUSH
84741: LD_INT 2
84743: PUSH
84744: LD_INT 4
84746: PUSH
84747: LD_INT 5
84749: PUSH
84750: LD_INT 6
84752: PUSH
84753: LD_INT 8
84755: PUSH
84756: LD_INT 11
84758: PUSH
84759: LD_INT 12
84761: PUSH
84762: LD_INT 15
84764: PUSH
84765: LD_INT 16
84767: PUSH
84768: LD_INT 20
84770: PUSH
84771: LD_INT 21
84773: PUSH
84774: LD_INT 22
84776: PUSH
84777: LD_INT 23
84779: PUSH
84780: LD_INT 25
84782: PUSH
84783: LD_INT 26
84785: PUSH
84786: LD_INT 30
84788: PUSH
84789: LD_INT 31
84791: PUSH
84792: LD_INT 32
84794: PUSH
84795: LD_INT 36
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: PUSH
84819: LD_INT 101
84821: PUSH
84822: LD_INT 102
84824: PUSH
84825: LD_INT 105
84827: PUSH
84828: LD_INT 106
84830: PUSH
84831: LD_INT 108
84833: PUSH
84834: LD_INT 109
84836: PUSH
84837: LD_INT 112
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: PUSH
84849: EMPTY
84850: LIST
84851: LIST
84852: ST_TO_ADDR
84853: GO 87220
84855: LD_INT 7
84857: DOUBLE
84858: EQUAL
84859: IFTRUE 84863
84861: GO 84963
84863: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84864: LD_ADDR_VAR 0 1
84868: PUSH
84869: LD_INT 2
84871: PUSH
84872: LD_INT 4
84874: PUSH
84875: LD_INT 5
84877: PUSH
84878: LD_INT 7
84880: PUSH
84881: LD_INT 11
84883: PUSH
84884: LD_INT 12
84886: PUSH
84887: LD_INT 15
84889: PUSH
84890: LD_INT 16
84892: PUSH
84893: LD_INT 20
84895: PUSH
84896: LD_INT 21
84898: PUSH
84899: LD_INT 22
84901: PUSH
84902: LD_INT 23
84904: PUSH
84905: LD_INT 25
84907: PUSH
84908: LD_INT 26
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 101
84929: PUSH
84930: LD_INT 102
84932: PUSH
84933: LD_INT 103
84935: PUSH
84936: LD_INT 105
84938: PUSH
84939: LD_INT 106
84941: PUSH
84942: LD_INT 108
84944: PUSH
84945: LD_INT 112
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: ST_TO_ADDR
84961: GO 87220
84963: LD_INT 8
84965: DOUBLE
84966: EQUAL
84967: IFTRUE 84971
84969: GO 85099
84971: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
84972: LD_ADDR_VAR 0 1
84976: PUSH
84977: LD_INT 2
84979: PUSH
84980: LD_INT 4
84982: PUSH
84983: LD_INT 5
84985: PUSH
84986: LD_INT 6
84988: PUSH
84989: LD_INT 7
84991: PUSH
84992: LD_INT 8
84994: PUSH
84995: LD_INT 11
84997: PUSH
84998: LD_INT 12
85000: PUSH
85001: LD_INT 15
85003: PUSH
85004: LD_INT 16
85006: PUSH
85007: LD_INT 20
85009: PUSH
85010: LD_INT 21
85012: PUSH
85013: LD_INT 22
85015: PUSH
85016: LD_INT 23
85018: PUSH
85019: LD_INT 25
85021: PUSH
85022: LD_INT 26
85024: PUSH
85025: LD_INT 30
85027: PUSH
85028: LD_INT 31
85030: PUSH
85031: LD_INT 32
85033: PUSH
85034: LD_INT 36
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 101
85061: PUSH
85062: LD_INT 102
85064: PUSH
85065: LD_INT 103
85067: PUSH
85068: LD_INT 105
85070: PUSH
85071: LD_INT 106
85073: PUSH
85074: LD_INT 108
85076: PUSH
85077: LD_INT 109
85079: PUSH
85080: LD_INT 112
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: ST_TO_ADDR
85097: GO 87220
85099: LD_INT 9
85101: DOUBLE
85102: EQUAL
85103: IFTRUE 85107
85105: GO 85243
85107: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
85108: LD_ADDR_VAR 0 1
85112: PUSH
85113: LD_INT 2
85115: PUSH
85116: LD_INT 4
85118: PUSH
85119: LD_INT 5
85121: PUSH
85122: LD_INT 6
85124: PUSH
85125: LD_INT 7
85127: PUSH
85128: LD_INT 8
85130: PUSH
85131: LD_INT 11
85133: PUSH
85134: LD_INT 12
85136: PUSH
85137: LD_INT 15
85139: PUSH
85140: LD_INT 16
85142: PUSH
85143: LD_INT 20
85145: PUSH
85146: LD_INT 21
85148: PUSH
85149: LD_INT 22
85151: PUSH
85152: LD_INT 23
85154: PUSH
85155: LD_INT 25
85157: PUSH
85158: LD_INT 26
85160: PUSH
85161: LD_INT 28
85163: PUSH
85164: LD_INT 30
85166: PUSH
85167: LD_INT 31
85169: PUSH
85170: LD_INT 32
85172: PUSH
85173: LD_INT 36
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 101
85201: PUSH
85202: LD_INT 102
85204: PUSH
85205: LD_INT 103
85207: PUSH
85208: LD_INT 105
85210: PUSH
85211: LD_INT 106
85213: PUSH
85214: LD_INT 108
85216: PUSH
85217: LD_INT 109
85219: PUSH
85220: LD_INT 112
85222: PUSH
85223: LD_INT 114
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: ST_TO_ADDR
85241: GO 87220
85243: LD_INT 10
85245: DOUBLE
85246: EQUAL
85247: IFTRUE 85251
85249: GO 85435
85251: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
85252: LD_ADDR_VAR 0 1
85256: PUSH
85257: LD_INT 2
85259: PUSH
85260: LD_INT 4
85262: PUSH
85263: LD_INT 5
85265: PUSH
85266: LD_INT 6
85268: PUSH
85269: LD_INT 7
85271: PUSH
85272: LD_INT 8
85274: PUSH
85275: LD_INT 9
85277: PUSH
85278: LD_INT 10
85280: PUSH
85281: LD_INT 11
85283: PUSH
85284: LD_INT 12
85286: PUSH
85287: LD_INT 13
85289: PUSH
85290: LD_INT 14
85292: PUSH
85293: LD_INT 15
85295: PUSH
85296: LD_INT 16
85298: PUSH
85299: LD_INT 17
85301: PUSH
85302: LD_INT 18
85304: PUSH
85305: LD_INT 19
85307: PUSH
85308: LD_INT 20
85310: PUSH
85311: LD_INT 21
85313: PUSH
85314: LD_INT 22
85316: PUSH
85317: LD_INT 23
85319: PUSH
85320: LD_INT 24
85322: PUSH
85323: LD_INT 25
85325: PUSH
85326: LD_INT 26
85328: PUSH
85329: LD_INT 28
85331: PUSH
85332: LD_INT 30
85334: PUSH
85335: LD_INT 31
85337: PUSH
85338: LD_INT 32
85340: PUSH
85341: LD_INT 36
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 101
85377: PUSH
85378: LD_INT 102
85380: PUSH
85381: LD_INT 103
85383: PUSH
85384: LD_INT 104
85386: PUSH
85387: LD_INT 105
85389: PUSH
85390: LD_INT 106
85392: PUSH
85393: LD_INT 107
85395: PUSH
85396: LD_INT 108
85398: PUSH
85399: LD_INT 109
85401: PUSH
85402: LD_INT 110
85404: PUSH
85405: LD_INT 111
85407: PUSH
85408: LD_INT 112
85410: PUSH
85411: LD_INT 114
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: PUSH
85429: EMPTY
85430: LIST
85431: LIST
85432: ST_TO_ADDR
85433: GO 87220
85435: LD_INT 11
85437: DOUBLE
85438: EQUAL
85439: IFTRUE 85443
85441: GO 85635
85443: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85444: LD_ADDR_VAR 0 1
85448: PUSH
85449: LD_INT 2
85451: PUSH
85452: LD_INT 3
85454: PUSH
85455: LD_INT 4
85457: PUSH
85458: LD_INT 5
85460: PUSH
85461: LD_INT 6
85463: PUSH
85464: LD_INT 7
85466: PUSH
85467: LD_INT 8
85469: PUSH
85470: LD_INT 9
85472: PUSH
85473: LD_INT 10
85475: PUSH
85476: LD_INT 11
85478: PUSH
85479: LD_INT 12
85481: PUSH
85482: LD_INT 13
85484: PUSH
85485: LD_INT 14
85487: PUSH
85488: LD_INT 15
85490: PUSH
85491: LD_INT 16
85493: PUSH
85494: LD_INT 17
85496: PUSH
85497: LD_INT 18
85499: PUSH
85500: LD_INT 19
85502: PUSH
85503: LD_INT 20
85505: PUSH
85506: LD_INT 21
85508: PUSH
85509: LD_INT 22
85511: PUSH
85512: LD_INT 23
85514: PUSH
85515: LD_INT 24
85517: PUSH
85518: LD_INT 25
85520: PUSH
85521: LD_INT 26
85523: PUSH
85524: LD_INT 28
85526: PUSH
85527: LD_INT 30
85529: PUSH
85530: LD_INT 31
85532: PUSH
85533: LD_INT 32
85535: PUSH
85536: LD_INT 34
85538: PUSH
85539: LD_INT 36
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 101
85577: PUSH
85578: LD_INT 102
85580: PUSH
85581: LD_INT 103
85583: PUSH
85584: LD_INT 104
85586: PUSH
85587: LD_INT 105
85589: PUSH
85590: LD_INT 106
85592: PUSH
85593: LD_INT 107
85595: PUSH
85596: LD_INT 108
85598: PUSH
85599: LD_INT 109
85601: PUSH
85602: LD_INT 110
85604: PUSH
85605: LD_INT 111
85607: PUSH
85608: LD_INT 112
85610: PUSH
85611: LD_INT 114
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: ST_TO_ADDR
85633: GO 87220
85635: LD_INT 12
85637: DOUBLE
85638: EQUAL
85639: IFTRUE 85643
85641: GO 85851
85643: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85644: LD_ADDR_VAR 0 1
85648: PUSH
85649: LD_INT 1
85651: PUSH
85652: LD_INT 2
85654: PUSH
85655: LD_INT 3
85657: PUSH
85658: LD_INT 4
85660: PUSH
85661: LD_INT 5
85663: PUSH
85664: LD_INT 6
85666: PUSH
85667: LD_INT 7
85669: PUSH
85670: LD_INT 8
85672: PUSH
85673: LD_INT 9
85675: PUSH
85676: LD_INT 10
85678: PUSH
85679: LD_INT 11
85681: PUSH
85682: LD_INT 12
85684: PUSH
85685: LD_INT 13
85687: PUSH
85688: LD_INT 14
85690: PUSH
85691: LD_INT 15
85693: PUSH
85694: LD_INT 16
85696: PUSH
85697: LD_INT 17
85699: PUSH
85700: LD_INT 18
85702: PUSH
85703: LD_INT 19
85705: PUSH
85706: LD_INT 20
85708: PUSH
85709: LD_INT 21
85711: PUSH
85712: LD_INT 22
85714: PUSH
85715: LD_INT 23
85717: PUSH
85718: LD_INT 24
85720: PUSH
85721: LD_INT 25
85723: PUSH
85724: LD_INT 26
85726: PUSH
85727: LD_INT 27
85729: PUSH
85730: LD_INT 28
85732: PUSH
85733: LD_INT 30
85735: PUSH
85736: LD_INT 31
85738: PUSH
85739: LD_INT 32
85741: PUSH
85742: LD_INT 33
85744: PUSH
85745: LD_INT 34
85747: PUSH
85748: LD_INT 36
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 101
85789: PUSH
85790: LD_INT 102
85792: PUSH
85793: LD_INT 103
85795: PUSH
85796: LD_INT 104
85798: PUSH
85799: LD_INT 105
85801: PUSH
85802: LD_INT 106
85804: PUSH
85805: LD_INT 107
85807: PUSH
85808: LD_INT 108
85810: PUSH
85811: LD_INT 109
85813: PUSH
85814: LD_INT 110
85816: PUSH
85817: LD_INT 111
85819: PUSH
85820: LD_INT 112
85822: PUSH
85823: LD_INT 113
85825: PUSH
85826: LD_INT 114
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: ST_TO_ADDR
85849: GO 87220
85851: LD_INT 13
85853: DOUBLE
85854: EQUAL
85855: IFTRUE 85859
85857: GO 86055
85859: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85860: LD_ADDR_VAR 0 1
85864: PUSH
85865: LD_INT 1
85867: PUSH
85868: LD_INT 2
85870: PUSH
85871: LD_INT 3
85873: PUSH
85874: LD_INT 4
85876: PUSH
85877: LD_INT 5
85879: PUSH
85880: LD_INT 8
85882: PUSH
85883: LD_INT 9
85885: PUSH
85886: LD_INT 10
85888: PUSH
85889: LD_INT 11
85891: PUSH
85892: LD_INT 12
85894: PUSH
85895: LD_INT 14
85897: PUSH
85898: LD_INT 15
85900: PUSH
85901: LD_INT 16
85903: PUSH
85904: LD_INT 17
85906: PUSH
85907: LD_INT 18
85909: PUSH
85910: LD_INT 19
85912: PUSH
85913: LD_INT 20
85915: PUSH
85916: LD_INT 21
85918: PUSH
85919: LD_INT 22
85921: PUSH
85922: LD_INT 23
85924: PUSH
85925: LD_INT 24
85927: PUSH
85928: LD_INT 25
85930: PUSH
85931: LD_INT 26
85933: PUSH
85934: LD_INT 27
85936: PUSH
85937: LD_INT 28
85939: PUSH
85940: LD_INT 30
85942: PUSH
85943: LD_INT 31
85945: PUSH
85946: LD_INT 32
85948: PUSH
85949: LD_INT 33
85951: PUSH
85952: LD_INT 34
85954: PUSH
85955: LD_INT 36
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 101
85993: PUSH
85994: LD_INT 102
85996: PUSH
85997: LD_INT 103
85999: PUSH
86000: LD_INT 104
86002: PUSH
86003: LD_INT 105
86005: PUSH
86006: LD_INT 106
86008: PUSH
86009: LD_INT 107
86011: PUSH
86012: LD_INT 108
86014: PUSH
86015: LD_INT 109
86017: PUSH
86018: LD_INT 110
86020: PUSH
86021: LD_INT 111
86023: PUSH
86024: LD_INT 112
86026: PUSH
86027: LD_INT 113
86029: PUSH
86030: LD_INT 114
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: ST_TO_ADDR
86053: GO 87220
86055: LD_INT 14
86057: DOUBLE
86058: EQUAL
86059: IFTRUE 86063
86061: GO 86275
86063: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
86064: LD_ADDR_VAR 0 1
86068: PUSH
86069: LD_INT 1
86071: PUSH
86072: LD_INT 2
86074: PUSH
86075: LD_INT 3
86077: PUSH
86078: LD_INT 4
86080: PUSH
86081: LD_INT 5
86083: PUSH
86084: LD_INT 6
86086: PUSH
86087: LD_INT 7
86089: PUSH
86090: LD_INT 8
86092: PUSH
86093: LD_INT 9
86095: PUSH
86096: LD_INT 10
86098: PUSH
86099: LD_INT 11
86101: PUSH
86102: LD_INT 12
86104: PUSH
86105: LD_INT 13
86107: PUSH
86108: LD_INT 14
86110: PUSH
86111: LD_INT 15
86113: PUSH
86114: LD_INT 16
86116: PUSH
86117: LD_INT 17
86119: PUSH
86120: LD_INT 18
86122: PUSH
86123: LD_INT 19
86125: PUSH
86126: LD_INT 20
86128: PUSH
86129: LD_INT 21
86131: PUSH
86132: LD_INT 22
86134: PUSH
86135: LD_INT 23
86137: PUSH
86138: LD_INT 24
86140: PUSH
86141: LD_INT 25
86143: PUSH
86144: LD_INT 26
86146: PUSH
86147: LD_INT 27
86149: PUSH
86150: LD_INT 28
86152: PUSH
86153: LD_INT 29
86155: PUSH
86156: LD_INT 30
86158: PUSH
86159: LD_INT 31
86161: PUSH
86162: LD_INT 32
86164: PUSH
86165: LD_INT 33
86167: PUSH
86168: LD_INT 34
86170: PUSH
86171: LD_INT 36
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 101
86213: PUSH
86214: LD_INT 102
86216: PUSH
86217: LD_INT 103
86219: PUSH
86220: LD_INT 104
86222: PUSH
86223: LD_INT 105
86225: PUSH
86226: LD_INT 106
86228: PUSH
86229: LD_INT 107
86231: PUSH
86232: LD_INT 108
86234: PUSH
86235: LD_INT 109
86237: PUSH
86238: LD_INT 110
86240: PUSH
86241: LD_INT 111
86243: PUSH
86244: LD_INT 112
86246: PUSH
86247: LD_INT 113
86249: PUSH
86250: LD_INT 114
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: ST_TO_ADDR
86273: GO 87220
86275: LD_INT 15
86277: DOUBLE
86278: EQUAL
86279: IFTRUE 86283
86281: GO 86495
86283: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86284: LD_ADDR_VAR 0 1
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: LD_INT 2
86294: PUSH
86295: LD_INT 3
86297: PUSH
86298: LD_INT 4
86300: PUSH
86301: LD_INT 5
86303: PUSH
86304: LD_INT 6
86306: PUSH
86307: LD_INT 7
86309: PUSH
86310: LD_INT 8
86312: PUSH
86313: LD_INT 9
86315: PUSH
86316: LD_INT 10
86318: PUSH
86319: LD_INT 11
86321: PUSH
86322: LD_INT 12
86324: PUSH
86325: LD_INT 13
86327: PUSH
86328: LD_INT 14
86330: PUSH
86331: LD_INT 15
86333: PUSH
86334: LD_INT 16
86336: PUSH
86337: LD_INT 17
86339: PUSH
86340: LD_INT 18
86342: PUSH
86343: LD_INT 19
86345: PUSH
86346: LD_INT 20
86348: PUSH
86349: LD_INT 21
86351: PUSH
86352: LD_INT 22
86354: PUSH
86355: LD_INT 23
86357: PUSH
86358: LD_INT 24
86360: PUSH
86361: LD_INT 25
86363: PUSH
86364: LD_INT 26
86366: PUSH
86367: LD_INT 27
86369: PUSH
86370: LD_INT 28
86372: PUSH
86373: LD_INT 29
86375: PUSH
86376: LD_INT 30
86378: PUSH
86379: LD_INT 31
86381: PUSH
86382: LD_INT 32
86384: PUSH
86385: LD_INT 33
86387: PUSH
86388: LD_INT 34
86390: PUSH
86391: LD_INT 36
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 101
86433: PUSH
86434: LD_INT 102
86436: PUSH
86437: LD_INT 103
86439: PUSH
86440: LD_INT 104
86442: PUSH
86443: LD_INT 105
86445: PUSH
86446: LD_INT 106
86448: PUSH
86449: LD_INT 107
86451: PUSH
86452: LD_INT 108
86454: PUSH
86455: LD_INT 109
86457: PUSH
86458: LD_INT 110
86460: PUSH
86461: LD_INT 111
86463: PUSH
86464: LD_INT 112
86466: PUSH
86467: LD_INT 113
86469: PUSH
86470: LD_INT 114
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: ST_TO_ADDR
86493: GO 87220
86495: LD_INT 16
86497: DOUBLE
86498: EQUAL
86499: IFTRUE 86503
86501: GO 86627
86503: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86504: LD_ADDR_VAR 0 1
86508: PUSH
86509: LD_INT 2
86511: PUSH
86512: LD_INT 4
86514: PUSH
86515: LD_INT 5
86517: PUSH
86518: LD_INT 7
86520: PUSH
86521: LD_INT 11
86523: PUSH
86524: LD_INT 12
86526: PUSH
86527: LD_INT 15
86529: PUSH
86530: LD_INT 16
86532: PUSH
86533: LD_INT 20
86535: PUSH
86536: LD_INT 21
86538: PUSH
86539: LD_INT 22
86541: PUSH
86542: LD_INT 23
86544: PUSH
86545: LD_INT 25
86547: PUSH
86548: LD_INT 26
86550: PUSH
86551: LD_INT 30
86553: PUSH
86554: LD_INT 31
86556: PUSH
86557: LD_INT 32
86559: PUSH
86560: LD_INT 33
86562: PUSH
86563: LD_INT 34
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 101
86589: PUSH
86590: LD_INT 102
86592: PUSH
86593: LD_INT 103
86595: PUSH
86596: LD_INT 106
86598: PUSH
86599: LD_INT 108
86601: PUSH
86602: LD_INT 112
86604: PUSH
86605: LD_INT 113
86607: PUSH
86608: LD_INT 114
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: ST_TO_ADDR
86625: GO 87220
86627: LD_INT 17
86629: DOUBLE
86630: EQUAL
86631: IFTRUE 86635
86633: GO 86847
86635: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86636: LD_ADDR_VAR 0 1
86640: PUSH
86641: LD_INT 1
86643: PUSH
86644: LD_INT 2
86646: PUSH
86647: LD_INT 3
86649: PUSH
86650: LD_INT 4
86652: PUSH
86653: LD_INT 5
86655: PUSH
86656: LD_INT 6
86658: PUSH
86659: LD_INT 7
86661: PUSH
86662: LD_INT 8
86664: PUSH
86665: LD_INT 9
86667: PUSH
86668: LD_INT 10
86670: PUSH
86671: LD_INT 11
86673: PUSH
86674: LD_INT 12
86676: PUSH
86677: LD_INT 13
86679: PUSH
86680: LD_INT 14
86682: PUSH
86683: LD_INT 15
86685: PUSH
86686: LD_INT 16
86688: PUSH
86689: LD_INT 17
86691: PUSH
86692: LD_INT 18
86694: PUSH
86695: LD_INT 19
86697: PUSH
86698: LD_INT 20
86700: PUSH
86701: LD_INT 21
86703: PUSH
86704: LD_INT 22
86706: PUSH
86707: LD_INT 23
86709: PUSH
86710: LD_INT 24
86712: PUSH
86713: LD_INT 25
86715: PUSH
86716: LD_INT 26
86718: PUSH
86719: LD_INT 27
86721: PUSH
86722: LD_INT 28
86724: PUSH
86725: LD_INT 29
86727: PUSH
86728: LD_INT 30
86730: PUSH
86731: LD_INT 31
86733: PUSH
86734: LD_INT 32
86736: PUSH
86737: LD_INT 33
86739: PUSH
86740: LD_INT 34
86742: PUSH
86743: LD_INT 36
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: LIST
86766: LIST
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 101
86785: PUSH
86786: LD_INT 102
86788: PUSH
86789: LD_INT 103
86791: PUSH
86792: LD_INT 104
86794: PUSH
86795: LD_INT 105
86797: PUSH
86798: LD_INT 106
86800: PUSH
86801: LD_INT 107
86803: PUSH
86804: LD_INT 108
86806: PUSH
86807: LD_INT 109
86809: PUSH
86810: LD_INT 110
86812: PUSH
86813: LD_INT 111
86815: PUSH
86816: LD_INT 112
86818: PUSH
86819: LD_INT 113
86821: PUSH
86822: LD_INT 114
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: ST_TO_ADDR
86845: GO 87220
86847: LD_INT 18
86849: DOUBLE
86850: EQUAL
86851: IFTRUE 86855
86853: GO 86991
86855: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86856: LD_ADDR_VAR 0 1
86860: PUSH
86861: LD_INT 2
86863: PUSH
86864: LD_INT 4
86866: PUSH
86867: LD_INT 5
86869: PUSH
86870: LD_INT 7
86872: PUSH
86873: LD_INT 11
86875: PUSH
86876: LD_INT 12
86878: PUSH
86879: LD_INT 15
86881: PUSH
86882: LD_INT 16
86884: PUSH
86885: LD_INT 20
86887: PUSH
86888: LD_INT 21
86890: PUSH
86891: LD_INT 22
86893: PUSH
86894: LD_INT 23
86896: PUSH
86897: LD_INT 25
86899: PUSH
86900: LD_INT 26
86902: PUSH
86903: LD_INT 30
86905: PUSH
86906: LD_INT 31
86908: PUSH
86909: LD_INT 32
86911: PUSH
86912: LD_INT 33
86914: PUSH
86915: LD_INT 34
86917: PUSH
86918: LD_INT 35
86920: PUSH
86921: LD_INT 36
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 101
86949: PUSH
86950: LD_INT 102
86952: PUSH
86953: LD_INT 103
86955: PUSH
86956: LD_INT 106
86958: PUSH
86959: LD_INT 108
86961: PUSH
86962: LD_INT 112
86964: PUSH
86965: LD_INT 113
86967: PUSH
86968: LD_INT 114
86970: PUSH
86971: LD_INT 115
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: ST_TO_ADDR
86989: GO 87220
86991: LD_INT 19
86993: DOUBLE
86994: EQUAL
86995: IFTRUE 86999
86997: GO 87219
86999: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
87000: LD_ADDR_VAR 0 1
87004: PUSH
87005: LD_INT 1
87007: PUSH
87008: LD_INT 2
87010: PUSH
87011: LD_INT 3
87013: PUSH
87014: LD_INT 4
87016: PUSH
87017: LD_INT 5
87019: PUSH
87020: LD_INT 6
87022: PUSH
87023: LD_INT 7
87025: PUSH
87026: LD_INT 8
87028: PUSH
87029: LD_INT 9
87031: PUSH
87032: LD_INT 10
87034: PUSH
87035: LD_INT 11
87037: PUSH
87038: LD_INT 12
87040: PUSH
87041: LD_INT 13
87043: PUSH
87044: LD_INT 14
87046: PUSH
87047: LD_INT 15
87049: PUSH
87050: LD_INT 16
87052: PUSH
87053: LD_INT 17
87055: PUSH
87056: LD_INT 18
87058: PUSH
87059: LD_INT 19
87061: PUSH
87062: LD_INT 20
87064: PUSH
87065: LD_INT 21
87067: PUSH
87068: LD_INT 22
87070: PUSH
87071: LD_INT 23
87073: PUSH
87074: LD_INT 24
87076: PUSH
87077: LD_INT 25
87079: PUSH
87080: LD_INT 26
87082: PUSH
87083: LD_INT 27
87085: PUSH
87086: LD_INT 28
87088: PUSH
87089: LD_INT 29
87091: PUSH
87092: LD_INT 30
87094: PUSH
87095: LD_INT 31
87097: PUSH
87098: LD_INT 32
87100: PUSH
87101: LD_INT 33
87103: PUSH
87104: LD_INT 34
87106: PUSH
87107: LD_INT 35
87109: PUSH
87110: LD_INT 36
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 101
87153: PUSH
87154: LD_INT 102
87156: PUSH
87157: LD_INT 103
87159: PUSH
87160: LD_INT 104
87162: PUSH
87163: LD_INT 105
87165: PUSH
87166: LD_INT 106
87168: PUSH
87169: LD_INT 107
87171: PUSH
87172: LD_INT 108
87174: PUSH
87175: LD_INT 109
87177: PUSH
87178: LD_INT 110
87180: PUSH
87181: LD_INT 111
87183: PUSH
87184: LD_INT 112
87186: PUSH
87187: LD_INT 113
87189: PUSH
87190: LD_INT 114
87192: PUSH
87193: LD_INT 115
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: PUSH
87213: EMPTY
87214: LIST
87215: LIST
87216: ST_TO_ADDR
87217: GO 87220
87219: POP
// end else
87220: GO 87439
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
87222: LD_ADDR_VAR 0 1
87226: PUSH
87227: LD_INT 1
87229: PUSH
87230: LD_INT 2
87232: PUSH
87233: LD_INT 3
87235: PUSH
87236: LD_INT 4
87238: PUSH
87239: LD_INT 5
87241: PUSH
87242: LD_INT 6
87244: PUSH
87245: LD_INT 7
87247: PUSH
87248: LD_INT 8
87250: PUSH
87251: LD_INT 9
87253: PUSH
87254: LD_INT 10
87256: PUSH
87257: LD_INT 11
87259: PUSH
87260: LD_INT 12
87262: PUSH
87263: LD_INT 13
87265: PUSH
87266: LD_INT 14
87268: PUSH
87269: LD_INT 15
87271: PUSH
87272: LD_INT 16
87274: PUSH
87275: LD_INT 17
87277: PUSH
87278: LD_INT 18
87280: PUSH
87281: LD_INT 19
87283: PUSH
87284: LD_INT 20
87286: PUSH
87287: LD_INT 21
87289: PUSH
87290: LD_INT 22
87292: PUSH
87293: LD_INT 23
87295: PUSH
87296: LD_INT 24
87298: PUSH
87299: LD_INT 25
87301: PUSH
87302: LD_INT 26
87304: PUSH
87305: LD_INT 27
87307: PUSH
87308: LD_INT 28
87310: PUSH
87311: LD_INT 29
87313: PUSH
87314: LD_INT 30
87316: PUSH
87317: LD_INT 31
87319: PUSH
87320: LD_INT 32
87322: PUSH
87323: LD_INT 33
87325: PUSH
87326: LD_INT 34
87328: PUSH
87329: LD_INT 35
87331: PUSH
87332: LD_INT 36
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 101
87375: PUSH
87376: LD_INT 102
87378: PUSH
87379: LD_INT 103
87381: PUSH
87382: LD_INT 104
87384: PUSH
87385: LD_INT 105
87387: PUSH
87388: LD_INT 106
87390: PUSH
87391: LD_INT 107
87393: PUSH
87394: LD_INT 108
87396: PUSH
87397: LD_INT 109
87399: PUSH
87400: LD_INT 110
87402: PUSH
87403: LD_INT 111
87405: PUSH
87406: LD_INT 112
87408: PUSH
87409: LD_INT 113
87411: PUSH
87412: LD_INT 114
87414: PUSH
87415: LD_INT 115
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: ST_TO_ADDR
// if result then
87439: LD_VAR 0 1
87443: IFFALSE 87732
// begin normal :=  ;
87445: LD_ADDR_VAR 0 3
87449: PUSH
87450: LD_STRING 
87452: ST_TO_ADDR
// hardcore :=  ;
87453: LD_ADDR_VAR 0 4
87457: PUSH
87458: LD_STRING 
87460: ST_TO_ADDR
// for i = 1 to normalCounter do
87461: LD_ADDR_VAR 0 5
87465: PUSH
87466: DOUBLE
87467: LD_INT 1
87469: DEC
87470: ST_TO_ADDR
87471: LD_EXP 84
87475: PUSH
87476: FOR_TO
87477: IFFALSE 87578
// begin tmp := 0 ;
87479: LD_ADDR_VAR 0 2
87483: PUSH
87484: LD_STRING 0
87486: ST_TO_ADDR
// if result [ 1 ] then
87487: LD_VAR 0 1
87491: PUSH
87492: LD_INT 1
87494: ARRAY
87495: IFFALSE 87560
// if result [ 1 ] [ 1 ] = i then
87497: LD_VAR 0 1
87501: PUSH
87502: LD_INT 1
87504: ARRAY
87505: PUSH
87506: LD_INT 1
87508: ARRAY
87509: PUSH
87510: LD_VAR 0 5
87514: EQUAL
87515: IFFALSE 87560
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87517: LD_ADDR_VAR 0 1
87521: PUSH
87522: LD_VAR 0 1
87526: PPUSH
87527: LD_INT 1
87529: PPUSH
87530: LD_VAR 0 1
87534: PUSH
87535: LD_INT 1
87537: ARRAY
87538: PPUSH
87539: LD_INT 1
87541: PPUSH
87542: CALL_OW 3
87546: PPUSH
87547: CALL_OW 1
87551: ST_TO_ADDR
// tmp := 1 ;
87552: LD_ADDR_VAR 0 2
87556: PUSH
87557: LD_STRING 1
87559: ST_TO_ADDR
// end ; normal := normal & tmp ;
87560: LD_ADDR_VAR 0 3
87564: PUSH
87565: LD_VAR 0 3
87569: PUSH
87570: LD_VAR 0 2
87574: STR
87575: ST_TO_ADDR
// end ;
87576: GO 87476
87578: POP
87579: POP
// for i = 1 to hardcoreCounter do
87580: LD_ADDR_VAR 0 5
87584: PUSH
87585: DOUBLE
87586: LD_INT 1
87588: DEC
87589: ST_TO_ADDR
87590: LD_EXP 85
87594: PUSH
87595: FOR_TO
87596: IFFALSE 87701
// begin tmp := 0 ;
87598: LD_ADDR_VAR 0 2
87602: PUSH
87603: LD_STRING 0
87605: ST_TO_ADDR
// if result [ 2 ] then
87606: LD_VAR 0 1
87610: PUSH
87611: LD_INT 2
87613: ARRAY
87614: IFFALSE 87683
// if result [ 2 ] [ 1 ] = 100 + i then
87616: LD_VAR 0 1
87620: PUSH
87621: LD_INT 2
87623: ARRAY
87624: PUSH
87625: LD_INT 1
87627: ARRAY
87628: PUSH
87629: LD_INT 100
87631: PUSH
87632: LD_VAR 0 5
87636: PLUS
87637: EQUAL
87638: IFFALSE 87683
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87640: LD_ADDR_VAR 0 1
87644: PUSH
87645: LD_VAR 0 1
87649: PPUSH
87650: LD_INT 2
87652: PPUSH
87653: LD_VAR 0 1
87657: PUSH
87658: LD_INT 2
87660: ARRAY
87661: PPUSH
87662: LD_INT 1
87664: PPUSH
87665: CALL_OW 3
87669: PPUSH
87670: CALL_OW 1
87674: ST_TO_ADDR
// tmp := 1 ;
87675: LD_ADDR_VAR 0 2
87679: PUSH
87680: LD_STRING 1
87682: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87683: LD_ADDR_VAR 0 4
87687: PUSH
87688: LD_VAR 0 4
87692: PUSH
87693: LD_VAR 0 2
87697: STR
87698: ST_TO_ADDR
// end ;
87699: GO 87595
87701: POP
87702: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87703: LD_STRING getStreamItemsFromMission("
87705: PUSH
87706: LD_VAR 0 3
87710: STR
87711: PUSH
87712: LD_STRING ","
87714: STR
87715: PUSH
87716: LD_VAR 0 4
87720: STR
87721: PUSH
87722: LD_STRING ")
87724: STR
87725: PPUSH
87726: CALL_OW 559
// end else
87730: GO 87739
// ToLua ( getStreamItemsFromMission("","") ) ;
87732: LD_STRING getStreamItemsFromMission("","")
87734: PPUSH
87735: CALL_OW 559
// end ;
87739: LD_VAR 0 1
87743: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
87744: LD_EXP 83
87748: PUSH
87749: LD_EXP 88
87753: AND
87754: IFFALSE 87878
87756: GO 87758
87758: DISABLE
87759: LD_INT 0
87761: PPUSH
87762: PPUSH
// begin enable ;
87763: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
87764: LD_ADDR_VAR 0 2
87768: PUSH
87769: LD_INT 22
87771: PUSH
87772: LD_OWVAR 2
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 2
87783: PUSH
87784: LD_INT 34
87786: PUSH
87787: LD_INT 7
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 34
87796: PUSH
87797: LD_INT 45
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 34
87806: PUSH
87807: LD_INT 28
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 34
87816: PUSH
87817: LD_INT 47
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PPUSH
87835: CALL_OW 69
87839: ST_TO_ADDR
// if not tmp then
87840: LD_VAR 0 2
87844: NOT
87845: IFFALSE 87849
// exit ;
87847: GO 87878
// for i in tmp do
87849: LD_ADDR_VAR 0 1
87853: PUSH
87854: LD_VAR 0 2
87858: PUSH
87859: FOR_IN
87860: IFFALSE 87876
// begin SetLives ( i , 0 ) ;
87862: LD_VAR 0 1
87866: PPUSH
87867: LD_INT 0
87869: PPUSH
87870: CALL_OW 234
// end ;
87874: GO 87859
87876: POP
87877: POP
// end ;
87878: PPOPN 2
87880: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
87881: LD_EXP 83
87885: PUSH
87886: LD_EXP 89
87890: AND
87891: IFFALSE 87975
87893: GO 87895
87895: DISABLE
87896: LD_INT 0
87898: PPUSH
87899: PPUSH
// begin enable ;
87900: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
87901: LD_ADDR_VAR 0 2
87905: PUSH
87906: LD_INT 22
87908: PUSH
87909: LD_OWVAR 2
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 32
87920: PUSH
87921: LD_INT 3
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PPUSH
87932: CALL_OW 69
87936: ST_TO_ADDR
// if not tmp then
87937: LD_VAR 0 2
87941: NOT
87942: IFFALSE 87946
// exit ;
87944: GO 87975
// for i in tmp do
87946: LD_ADDR_VAR 0 1
87950: PUSH
87951: LD_VAR 0 2
87955: PUSH
87956: FOR_IN
87957: IFFALSE 87973
// begin SetLives ( i , 0 ) ;
87959: LD_VAR 0 1
87963: PPUSH
87964: LD_INT 0
87966: PPUSH
87967: CALL_OW 234
// end ;
87971: GO 87956
87973: POP
87974: POP
// end ;
87975: PPOPN 2
87977: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
87978: LD_EXP 83
87982: PUSH
87983: LD_EXP 86
87987: AND
87988: IFFALSE 88081
87990: GO 87992
87992: DISABLE
87993: LD_INT 0
87995: PPUSH
// begin enable ;
87996: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
87997: LD_ADDR_VAR 0 1
88001: PUSH
88002: LD_INT 22
88004: PUSH
88005: LD_OWVAR 2
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: PUSH
88014: LD_INT 2
88016: PUSH
88017: LD_INT 25
88019: PUSH
88020: LD_INT 5
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 25
88029: PUSH
88030: LD_INT 9
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 25
88039: PUSH
88040: LD_INT 8
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PPUSH
88057: CALL_OW 69
88061: PUSH
88062: FOR_IN
88063: IFFALSE 88079
// begin SetClass ( i , 1 ) ;
88065: LD_VAR 0 1
88069: PPUSH
88070: LD_INT 1
88072: PPUSH
88073: CALL_OW 336
// end ;
88077: GO 88062
88079: POP
88080: POP
// end ;
88081: PPOPN 1
88083: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
88084: LD_EXP 83
88088: PUSH
88089: LD_EXP 87
88093: AND
88094: PUSH
88095: LD_OWVAR 65
88099: PUSH
88100: LD_INT 7
88102: LESS
88103: AND
88104: IFFALSE 88118
88106: GO 88108
88108: DISABLE
// begin enable ;
88109: ENABLE
// game_speed := 7 ;
88110: LD_ADDR_OWVAR 65
88114: PUSH
88115: LD_INT 7
88117: ST_TO_ADDR
// end ;
88118: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
88119: LD_EXP 83
88123: PUSH
88124: LD_EXP 90
88128: AND
88129: IFFALSE 88331
88131: GO 88133
88133: DISABLE
88134: LD_INT 0
88136: PPUSH
88137: PPUSH
88138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
88139: LD_ADDR_VAR 0 3
88143: PUSH
88144: LD_INT 81
88146: PUSH
88147: LD_OWVAR 2
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 21
88158: PUSH
88159: LD_INT 1
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PPUSH
88170: CALL_OW 69
88174: ST_TO_ADDR
// if not tmp then
88175: LD_VAR 0 3
88179: NOT
88180: IFFALSE 88184
// exit ;
88182: GO 88331
// if tmp > 5 then
88184: LD_VAR 0 3
88188: PUSH
88189: LD_INT 5
88191: GREATER
88192: IFFALSE 88204
// k := 5 else
88194: LD_ADDR_VAR 0 2
88198: PUSH
88199: LD_INT 5
88201: ST_TO_ADDR
88202: GO 88214
// k := tmp ;
88204: LD_ADDR_VAR 0 2
88208: PUSH
88209: LD_VAR 0 3
88213: ST_TO_ADDR
// for i := 1 to k do
88214: LD_ADDR_VAR 0 1
88218: PUSH
88219: DOUBLE
88220: LD_INT 1
88222: DEC
88223: ST_TO_ADDR
88224: LD_VAR 0 2
88228: PUSH
88229: FOR_TO
88230: IFFALSE 88329
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
88232: LD_VAR 0 3
88236: PUSH
88237: LD_VAR 0 1
88241: ARRAY
88242: PPUSH
88243: LD_VAR 0 1
88247: PUSH
88248: LD_INT 4
88250: MOD
88251: PUSH
88252: LD_INT 1
88254: PLUS
88255: PPUSH
88256: CALL_OW 259
88260: PUSH
88261: LD_INT 10
88263: LESS
88264: IFFALSE 88327
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
88266: LD_VAR 0 3
88270: PUSH
88271: LD_VAR 0 1
88275: ARRAY
88276: PPUSH
88277: LD_VAR 0 1
88281: PUSH
88282: LD_INT 4
88284: MOD
88285: PUSH
88286: LD_INT 1
88288: PLUS
88289: PPUSH
88290: LD_VAR 0 3
88294: PUSH
88295: LD_VAR 0 1
88299: ARRAY
88300: PPUSH
88301: LD_VAR 0 1
88305: PUSH
88306: LD_INT 4
88308: MOD
88309: PUSH
88310: LD_INT 1
88312: PLUS
88313: PPUSH
88314: CALL_OW 259
88318: PUSH
88319: LD_INT 1
88321: PLUS
88322: PPUSH
88323: CALL_OW 237
88327: GO 88229
88329: POP
88330: POP
// end ;
88331: PPOPN 3
88333: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
88334: LD_EXP 83
88338: PUSH
88339: LD_EXP 91
88343: AND
88344: IFFALSE 88364
88346: GO 88348
88348: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
88349: LD_INT 4
88351: PPUSH
88352: LD_OWVAR 2
88356: PPUSH
88357: LD_INT 0
88359: PPUSH
88360: CALL_OW 324
88364: END
// every 0 0$1 trigger StreamModeActive and sShovel do
88365: LD_EXP 83
88369: PUSH
88370: LD_EXP 120
88374: AND
88375: IFFALSE 88395
88377: GO 88379
88379: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
88380: LD_INT 19
88382: PPUSH
88383: LD_OWVAR 2
88387: PPUSH
88388: LD_INT 0
88390: PPUSH
88391: CALL_OW 324
88395: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
88396: LD_EXP 83
88400: PUSH
88401: LD_EXP 92
88405: AND
88406: IFFALSE 88508
88408: GO 88410
88410: DISABLE
88411: LD_INT 0
88413: PPUSH
88414: PPUSH
// begin enable ;
88415: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
88416: LD_ADDR_VAR 0 2
88420: PUSH
88421: LD_INT 22
88423: PUSH
88424: LD_OWVAR 2
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 2
88435: PUSH
88436: LD_INT 34
88438: PUSH
88439: LD_INT 11
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 34
88448: PUSH
88449: LD_INT 30
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: LIST
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PPUSH
88465: CALL_OW 69
88469: ST_TO_ADDR
// if not tmp then
88470: LD_VAR 0 2
88474: NOT
88475: IFFALSE 88479
// exit ;
88477: GO 88508
// for i in tmp do
88479: LD_ADDR_VAR 0 1
88483: PUSH
88484: LD_VAR 0 2
88488: PUSH
88489: FOR_IN
88490: IFFALSE 88506
// begin SetLives ( i , 0 ) ;
88492: LD_VAR 0 1
88496: PPUSH
88497: LD_INT 0
88499: PPUSH
88500: CALL_OW 234
// end ;
88504: GO 88489
88506: POP
88507: POP
// end ;
88508: PPOPN 2
88510: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88511: LD_EXP 83
88515: PUSH
88516: LD_EXP 93
88520: AND
88521: IFFALSE 88541
88523: GO 88525
88525: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88526: LD_INT 32
88528: PPUSH
88529: LD_OWVAR 2
88533: PPUSH
88534: LD_INT 0
88536: PPUSH
88537: CALL_OW 324
88541: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88542: LD_EXP 83
88546: PUSH
88547: LD_EXP 94
88551: AND
88552: IFFALSE 88733
88554: GO 88556
88556: DISABLE
88557: LD_INT 0
88559: PPUSH
88560: PPUSH
88561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88562: LD_ADDR_VAR 0 2
88566: PUSH
88567: LD_INT 22
88569: PUSH
88570: LD_OWVAR 2
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 33
88581: PUSH
88582: LD_INT 3
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PPUSH
88593: CALL_OW 69
88597: ST_TO_ADDR
// if not tmp then
88598: LD_VAR 0 2
88602: NOT
88603: IFFALSE 88607
// exit ;
88605: GO 88733
// side := 0 ;
88607: LD_ADDR_VAR 0 3
88611: PUSH
88612: LD_INT 0
88614: ST_TO_ADDR
// for i := 1 to 8 do
88615: LD_ADDR_VAR 0 1
88619: PUSH
88620: DOUBLE
88621: LD_INT 1
88623: DEC
88624: ST_TO_ADDR
88625: LD_INT 8
88627: PUSH
88628: FOR_TO
88629: IFFALSE 88677
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
88631: LD_OWVAR 2
88635: PUSH
88636: LD_VAR 0 1
88640: NONEQUAL
88641: PUSH
88642: LD_OWVAR 2
88646: PPUSH
88647: LD_VAR 0 1
88651: PPUSH
88652: CALL_OW 81
88656: PUSH
88657: LD_INT 2
88659: EQUAL
88660: AND
88661: IFFALSE 88675
// begin side := i ;
88663: LD_ADDR_VAR 0 3
88667: PUSH
88668: LD_VAR 0 1
88672: ST_TO_ADDR
// break ;
88673: GO 88677
// end ;
88675: GO 88628
88677: POP
88678: POP
// if not side then
88679: LD_VAR 0 3
88683: NOT
88684: IFFALSE 88688
// exit ;
88686: GO 88733
// for i := 1 to tmp do
88688: LD_ADDR_VAR 0 1
88692: PUSH
88693: DOUBLE
88694: LD_INT 1
88696: DEC
88697: ST_TO_ADDR
88698: LD_VAR 0 2
88702: PUSH
88703: FOR_TO
88704: IFFALSE 88731
// if Prob ( 60 ) then
88706: LD_INT 60
88708: PPUSH
88709: CALL_OW 13
88713: IFFALSE 88729
// SetSide ( i , side ) ;
88715: LD_VAR 0 1
88719: PPUSH
88720: LD_VAR 0 3
88724: PPUSH
88725: CALL_OW 235
88729: GO 88703
88731: POP
88732: POP
// end ;
88733: PPOPN 3
88735: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
88736: LD_EXP 83
88740: PUSH
88741: LD_EXP 96
88745: AND
88746: IFFALSE 88865
88748: GO 88750
88750: DISABLE
88751: LD_INT 0
88753: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
88754: LD_ADDR_VAR 0 1
88758: PUSH
88759: LD_INT 22
88761: PUSH
88762: LD_OWVAR 2
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 21
88773: PUSH
88774: LD_INT 1
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 3
88783: PUSH
88784: LD_INT 23
88786: PUSH
88787: LD_INT 0
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: LIST
88802: PPUSH
88803: CALL_OW 69
88807: PUSH
88808: FOR_IN
88809: IFFALSE 88863
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
88811: LD_VAR 0 1
88815: PPUSH
88816: CALL_OW 257
88820: PUSH
88821: LD_INT 1
88823: PUSH
88824: LD_INT 2
88826: PUSH
88827: LD_INT 3
88829: PUSH
88830: LD_INT 4
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: IN
88839: IFFALSE 88861
// SetClass ( un , rand ( 1 , 4 ) ) ;
88841: LD_VAR 0 1
88845: PPUSH
88846: LD_INT 1
88848: PPUSH
88849: LD_INT 4
88851: PPUSH
88852: CALL_OW 12
88856: PPUSH
88857: CALL_OW 336
88861: GO 88808
88863: POP
88864: POP
// end ;
88865: PPOPN 1
88867: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
88868: LD_EXP 83
88872: PUSH
88873: LD_EXP 95
88877: AND
88878: IFFALSE 88957
88880: GO 88882
88882: DISABLE
88883: LD_INT 0
88885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88886: LD_ADDR_VAR 0 1
88890: PUSH
88891: LD_INT 22
88893: PUSH
88894: LD_OWVAR 2
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 21
88905: PUSH
88906: LD_INT 3
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: EMPTY
88914: LIST
88915: LIST
88916: PPUSH
88917: CALL_OW 69
88921: ST_TO_ADDR
// if not tmp then
88922: LD_VAR 0 1
88926: NOT
88927: IFFALSE 88931
// exit ;
88929: GO 88957
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
88931: LD_VAR 0 1
88935: PUSH
88936: LD_INT 1
88938: PPUSH
88939: LD_VAR 0 1
88943: PPUSH
88944: CALL_OW 12
88948: ARRAY
88949: PPUSH
88950: LD_INT 100
88952: PPUSH
88953: CALL_OW 234
// end ;
88957: PPOPN 1
88959: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
88960: LD_EXP 83
88964: PUSH
88965: LD_EXP 97
88969: AND
88970: IFFALSE 89068
88972: GO 88974
88974: DISABLE
88975: LD_INT 0
88977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88978: LD_ADDR_VAR 0 1
88982: PUSH
88983: LD_INT 22
88985: PUSH
88986: LD_OWVAR 2
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 21
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PPUSH
89009: CALL_OW 69
89013: ST_TO_ADDR
// if not tmp then
89014: LD_VAR 0 1
89018: NOT
89019: IFFALSE 89023
// exit ;
89021: GO 89068
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89023: LD_VAR 0 1
89027: PUSH
89028: LD_INT 1
89030: PPUSH
89031: LD_VAR 0 1
89035: PPUSH
89036: CALL_OW 12
89040: ARRAY
89041: PPUSH
89042: LD_INT 1
89044: PPUSH
89045: LD_INT 4
89047: PPUSH
89048: CALL_OW 12
89052: PPUSH
89053: LD_INT 3000
89055: PPUSH
89056: LD_INT 9000
89058: PPUSH
89059: CALL_OW 12
89063: PPUSH
89064: CALL_OW 492
// end ;
89068: PPOPN 1
89070: END
// every 0 0$1 trigger StreamModeActive and sDepot do
89071: LD_EXP 83
89075: PUSH
89076: LD_EXP 98
89080: AND
89081: IFFALSE 89101
89083: GO 89085
89085: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
89086: LD_INT 1
89088: PPUSH
89089: LD_OWVAR 2
89093: PPUSH
89094: LD_INT 0
89096: PPUSH
89097: CALL_OW 324
89101: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
89102: LD_EXP 83
89106: PUSH
89107: LD_EXP 99
89111: AND
89112: IFFALSE 89195
89114: GO 89116
89116: DISABLE
89117: LD_INT 0
89119: PPUSH
89120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89121: LD_ADDR_VAR 0 2
89125: PUSH
89126: LD_INT 22
89128: PUSH
89129: LD_OWVAR 2
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 21
89140: PUSH
89141: LD_INT 3
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PPUSH
89152: CALL_OW 69
89156: ST_TO_ADDR
// if not tmp then
89157: LD_VAR 0 2
89161: NOT
89162: IFFALSE 89166
// exit ;
89164: GO 89195
// for i in tmp do
89166: LD_ADDR_VAR 0 1
89170: PUSH
89171: LD_VAR 0 2
89175: PUSH
89176: FOR_IN
89177: IFFALSE 89193
// SetBLevel ( i , 10 ) ;
89179: LD_VAR 0 1
89183: PPUSH
89184: LD_INT 10
89186: PPUSH
89187: CALL_OW 241
89191: GO 89176
89193: POP
89194: POP
// end ;
89195: PPOPN 2
89197: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
89198: LD_EXP 83
89202: PUSH
89203: LD_EXP 100
89207: AND
89208: IFFALSE 89319
89210: GO 89212
89212: DISABLE
89213: LD_INT 0
89215: PPUSH
89216: PPUSH
89217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89218: LD_ADDR_VAR 0 3
89222: PUSH
89223: LD_INT 22
89225: PUSH
89226: LD_OWVAR 2
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: LD_INT 25
89237: PUSH
89238: LD_INT 1
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: PPUSH
89249: CALL_OW 69
89253: ST_TO_ADDR
// if not tmp then
89254: LD_VAR 0 3
89258: NOT
89259: IFFALSE 89263
// exit ;
89261: GO 89319
// un := tmp [ rand ( 1 , tmp ) ] ;
89263: LD_ADDR_VAR 0 2
89267: PUSH
89268: LD_VAR 0 3
89272: PUSH
89273: LD_INT 1
89275: PPUSH
89276: LD_VAR 0 3
89280: PPUSH
89281: CALL_OW 12
89285: ARRAY
89286: ST_TO_ADDR
// if Crawls ( un ) then
89287: LD_VAR 0 2
89291: PPUSH
89292: CALL_OW 318
89296: IFFALSE 89307
// ComWalk ( un ) ;
89298: LD_VAR 0 2
89302: PPUSH
89303: CALL_OW 138
// SetClass ( un , class_sniper ) ;
89307: LD_VAR 0 2
89311: PPUSH
89312: LD_INT 5
89314: PPUSH
89315: CALL_OW 336
// end ;
89319: PPOPN 3
89321: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
89322: LD_EXP 83
89326: PUSH
89327: LD_EXP 101
89331: AND
89332: PUSH
89333: LD_OWVAR 67
89337: PUSH
89338: LD_INT 3
89340: LESS
89341: AND
89342: IFFALSE 89361
89344: GO 89346
89346: DISABLE
// Difficulty := Difficulty + 1 ;
89347: LD_ADDR_OWVAR 67
89351: PUSH
89352: LD_OWVAR 67
89356: PUSH
89357: LD_INT 1
89359: PLUS
89360: ST_TO_ADDR
89361: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
89362: LD_EXP 83
89366: PUSH
89367: LD_EXP 102
89371: AND
89372: IFFALSE 89475
89374: GO 89376
89376: DISABLE
89377: LD_INT 0
89379: PPUSH
// begin for i := 1 to 5 do
89380: LD_ADDR_VAR 0 1
89384: PUSH
89385: DOUBLE
89386: LD_INT 1
89388: DEC
89389: ST_TO_ADDR
89390: LD_INT 5
89392: PUSH
89393: FOR_TO
89394: IFFALSE 89473
// begin uc_nation := nation_nature ;
89396: LD_ADDR_OWVAR 21
89400: PUSH
89401: LD_INT 0
89403: ST_TO_ADDR
// uc_side := 0 ;
89404: LD_ADDR_OWVAR 20
89408: PUSH
89409: LD_INT 0
89411: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89412: LD_ADDR_OWVAR 29
89416: PUSH
89417: LD_INT 12
89419: PUSH
89420: LD_INT 12
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: ST_TO_ADDR
// hc_agressivity := 20 ;
89427: LD_ADDR_OWVAR 35
89431: PUSH
89432: LD_INT 20
89434: ST_TO_ADDR
// hc_class := class_tiger ;
89435: LD_ADDR_OWVAR 28
89439: PUSH
89440: LD_INT 14
89442: ST_TO_ADDR
// hc_gallery :=  ;
89443: LD_ADDR_OWVAR 33
89447: PUSH
89448: LD_STRING 
89450: ST_TO_ADDR
// hc_name :=  ;
89451: LD_ADDR_OWVAR 26
89455: PUSH
89456: LD_STRING 
89458: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89459: CALL_OW 44
89463: PPUSH
89464: LD_INT 0
89466: PPUSH
89467: CALL_OW 51
// end ;
89471: GO 89393
89473: POP
89474: POP
// end ;
89475: PPOPN 1
89477: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89478: LD_EXP 83
89482: PUSH
89483: LD_EXP 103
89487: AND
89488: IFFALSE 89497
89490: GO 89492
89492: DISABLE
// StreamSibBomb ;
89493: CALL 89498 0 0
89497: END
// export function StreamSibBomb ; var i , x , y ; begin
89498: LD_INT 0
89500: PPUSH
89501: PPUSH
89502: PPUSH
89503: PPUSH
// result := false ;
89504: LD_ADDR_VAR 0 1
89508: PUSH
89509: LD_INT 0
89511: ST_TO_ADDR
// for i := 1 to 16 do
89512: LD_ADDR_VAR 0 2
89516: PUSH
89517: DOUBLE
89518: LD_INT 1
89520: DEC
89521: ST_TO_ADDR
89522: LD_INT 16
89524: PUSH
89525: FOR_TO
89526: IFFALSE 89725
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89528: LD_ADDR_VAR 0 3
89532: PUSH
89533: LD_INT 10
89535: PUSH
89536: LD_INT 20
89538: PUSH
89539: LD_INT 30
89541: PUSH
89542: LD_INT 40
89544: PUSH
89545: LD_INT 50
89547: PUSH
89548: LD_INT 60
89550: PUSH
89551: LD_INT 70
89553: PUSH
89554: LD_INT 80
89556: PUSH
89557: LD_INT 90
89559: PUSH
89560: LD_INT 100
89562: PUSH
89563: LD_INT 110
89565: PUSH
89566: LD_INT 120
89568: PUSH
89569: LD_INT 130
89571: PUSH
89572: LD_INT 140
89574: PUSH
89575: LD_INT 150
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: PUSH
89595: LD_INT 1
89597: PPUSH
89598: LD_INT 15
89600: PPUSH
89601: CALL_OW 12
89605: ARRAY
89606: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89607: LD_ADDR_VAR 0 4
89611: PUSH
89612: LD_INT 10
89614: PUSH
89615: LD_INT 20
89617: PUSH
89618: LD_INT 30
89620: PUSH
89621: LD_INT 40
89623: PUSH
89624: LD_INT 50
89626: PUSH
89627: LD_INT 60
89629: PUSH
89630: LD_INT 70
89632: PUSH
89633: LD_INT 80
89635: PUSH
89636: LD_INT 90
89638: PUSH
89639: LD_INT 100
89641: PUSH
89642: LD_INT 110
89644: PUSH
89645: LD_INT 120
89647: PUSH
89648: LD_INT 130
89650: PUSH
89651: LD_INT 140
89653: PUSH
89654: LD_INT 150
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 1
89676: PPUSH
89677: LD_INT 15
89679: PPUSH
89680: CALL_OW 12
89684: ARRAY
89685: ST_TO_ADDR
// if ValidHex ( x , y ) then
89686: LD_VAR 0 3
89690: PPUSH
89691: LD_VAR 0 4
89695: PPUSH
89696: CALL_OW 488
89700: IFFALSE 89723
// begin result := [ x , y ] ;
89702: LD_ADDR_VAR 0 1
89706: PUSH
89707: LD_VAR 0 3
89711: PUSH
89712: LD_VAR 0 4
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: ST_TO_ADDR
// break ;
89721: GO 89725
// end ; end ;
89723: GO 89525
89725: POP
89726: POP
// if result then
89727: LD_VAR 0 1
89731: IFFALSE 89791
// begin ToLua ( playSibBomb() ) ;
89733: LD_STRING playSibBomb()
89735: PPUSH
89736: CALL_OW 559
// wait ( 0 0$14 ) ;
89740: LD_INT 490
89742: PPUSH
89743: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
89747: LD_VAR 0 1
89751: PUSH
89752: LD_INT 1
89754: ARRAY
89755: PPUSH
89756: LD_VAR 0 1
89760: PUSH
89761: LD_INT 2
89763: ARRAY
89764: PPUSH
89765: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
89769: LD_VAR 0 1
89773: PUSH
89774: LD_INT 1
89776: ARRAY
89777: PPUSH
89778: LD_VAR 0 1
89782: PUSH
89783: LD_INT 2
89785: ARRAY
89786: PPUSH
89787: CALL_OW 429
// end ; end ;
89791: LD_VAR 0 1
89795: RET
// every 0 0$1 trigger StreamModeActive and sReset do
89796: LD_EXP 83
89800: PUSH
89801: LD_EXP 105
89805: AND
89806: IFFALSE 89818
89808: GO 89810
89810: DISABLE
// YouLost (  ) ;
89811: LD_STRING 
89813: PPUSH
89814: CALL_OW 104
89818: END
// every 0 0$1 trigger StreamModeActive and sFog do
89819: LD_EXP 83
89823: PUSH
89824: LD_EXP 104
89828: AND
89829: IFFALSE 89843
89831: GO 89833
89833: DISABLE
// FogOff ( your_side ) ;
89834: LD_OWVAR 2
89838: PPUSH
89839: CALL_OW 344
89843: END
// every 0 0$1 trigger StreamModeActive and sSun do
89844: LD_EXP 83
89848: PUSH
89849: LD_EXP 106
89853: AND
89854: IFFALSE 89882
89856: GO 89858
89858: DISABLE
// begin solar_recharge_percent := 0 ;
89859: LD_ADDR_OWVAR 79
89863: PUSH
89864: LD_INT 0
89866: ST_TO_ADDR
// wait ( 5 5$00 ) ;
89867: LD_INT 10500
89869: PPUSH
89870: CALL_OW 67
// solar_recharge_percent := 100 ;
89874: LD_ADDR_OWVAR 79
89878: PUSH
89879: LD_INT 100
89881: ST_TO_ADDR
// end ;
89882: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
89883: LD_EXP 83
89887: PUSH
89888: LD_EXP 107
89892: AND
89893: IFFALSE 90132
89895: GO 89897
89897: DISABLE
89898: LD_INT 0
89900: PPUSH
89901: PPUSH
89902: PPUSH
// begin tmp := [ ] ;
89903: LD_ADDR_VAR 0 3
89907: PUSH
89908: EMPTY
89909: ST_TO_ADDR
// for i := 1 to 6 do
89910: LD_ADDR_VAR 0 1
89914: PUSH
89915: DOUBLE
89916: LD_INT 1
89918: DEC
89919: ST_TO_ADDR
89920: LD_INT 6
89922: PUSH
89923: FOR_TO
89924: IFFALSE 90029
// begin uc_nation := nation_nature ;
89926: LD_ADDR_OWVAR 21
89930: PUSH
89931: LD_INT 0
89933: ST_TO_ADDR
// uc_side := 0 ;
89934: LD_ADDR_OWVAR 20
89938: PUSH
89939: LD_INT 0
89941: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89942: LD_ADDR_OWVAR 29
89946: PUSH
89947: LD_INT 12
89949: PUSH
89950: LD_INT 12
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: ST_TO_ADDR
// hc_agressivity := 20 ;
89957: LD_ADDR_OWVAR 35
89961: PUSH
89962: LD_INT 20
89964: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
89965: LD_ADDR_OWVAR 28
89969: PUSH
89970: LD_INT 17
89972: ST_TO_ADDR
// hc_gallery :=  ;
89973: LD_ADDR_OWVAR 33
89977: PUSH
89978: LD_STRING 
89980: ST_TO_ADDR
// hc_name :=  ;
89981: LD_ADDR_OWVAR 26
89985: PUSH
89986: LD_STRING 
89988: ST_TO_ADDR
// un := CreateHuman ;
89989: LD_ADDR_VAR 0 2
89993: PUSH
89994: CALL_OW 44
89998: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
89999: LD_VAR 0 2
90003: PPUSH
90004: LD_INT 1
90006: PPUSH
90007: CALL_OW 51
// tmp := tmp ^ un ;
90011: LD_ADDR_VAR 0 3
90015: PUSH
90016: LD_VAR 0 3
90020: PUSH
90021: LD_VAR 0 2
90025: ADD
90026: ST_TO_ADDR
// end ;
90027: GO 89923
90029: POP
90030: POP
// repeat wait ( 0 0$1 ) ;
90031: LD_INT 35
90033: PPUSH
90034: CALL_OW 67
// for un in tmp do
90038: LD_ADDR_VAR 0 2
90042: PUSH
90043: LD_VAR 0 3
90047: PUSH
90048: FOR_IN
90049: IFFALSE 90123
// begin if IsDead ( un ) then
90051: LD_VAR 0 2
90055: PPUSH
90056: CALL_OW 301
90060: IFFALSE 90080
// begin tmp := tmp diff un ;
90062: LD_ADDR_VAR 0 3
90066: PUSH
90067: LD_VAR 0 3
90071: PUSH
90072: LD_VAR 0 2
90076: DIFF
90077: ST_TO_ADDR
// continue ;
90078: GO 90048
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
90080: LD_VAR 0 2
90084: PPUSH
90085: LD_INT 3
90087: PUSH
90088: LD_INT 22
90090: PUSH
90091: LD_INT 0
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PPUSH
90102: CALL_OW 69
90106: PPUSH
90107: LD_VAR 0 2
90111: PPUSH
90112: CALL_OW 74
90116: PPUSH
90117: CALL_OW 115
// end ;
90121: GO 90048
90123: POP
90124: POP
// until not tmp ;
90125: LD_VAR 0 3
90129: NOT
90130: IFFALSE 90031
// end ;
90132: PPOPN 3
90134: END
// every 0 0$1 trigger StreamModeActive and sTroll do
90135: LD_EXP 83
90139: PUSH
90140: LD_EXP 108
90144: AND
90145: IFFALSE 90199
90147: GO 90149
90149: DISABLE
// begin ToLua ( displayTroll(); ) ;
90150: LD_STRING displayTroll();
90152: PPUSH
90153: CALL_OW 559
// wait ( 3 3$00 ) ;
90157: LD_INT 6300
90159: PPUSH
90160: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90164: LD_STRING hideTroll();
90166: PPUSH
90167: CALL_OW 559
// wait ( 1 1$00 ) ;
90171: LD_INT 2100
90173: PPUSH
90174: CALL_OW 67
// ToLua ( displayTroll(); ) ;
90178: LD_STRING displayTroll();
90180: PPUSH
90181: CALL_OW 559
// wait ( 1 1$00 ) ;
90185: LD_INT 2100
90187: PPUSH
90188: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90192: LD_STRING hideTroll();
90194: PPUSH
90195: CALL_OW 559
// end ;
90199: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
90200: LD_EXP 83
90204: PUSH
90205: LD_EXP 109
90209: AND
90210: IFFALSE 90273
90212: GO 90214
90214: DISABLE
90215: LD_INT 0
90217: PPUSH
// begin p := 0 ;
90218: LD_ADDR_VAR 0 1
90222: PUSH
90223: LD_INT 0
90225: ST_TO_ADDR
// repeat game_speed := 1 ;
90226: LD_ADDR_OWVAR 65
90230: PUSH
90231: LD_INT 1
90233: ST_TO_ADDR
// wait ( 0 0$1 ) ;
90234: LD_INT 35
90236: PPUSH
90237: CALL_OW 67
// p := p + 1 ;
90241: LD_ADDR_VAR 0 1
90245: PUSH
90246: LD_VAR 0 1
90250: PUSH
90251: LD_INT 1
90253: PLUS
90254: ST_TO_ADDR
// until p >= 60 ;
90255: LD_VAR 0 1
90259: PUSH
90260: LD_INT 60
90262: GREATEREQUAL
90263: IFFALSE 90226
// game_speed := 4 ;
90265: LD_ADDR_OWVAR 65
90269: PUSH
90270: LD_INT 4
90272: ST_TO_ADDR
// end ;
90273: PPOPN 1
90275: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
90276: LD_EXP 83
90280: PUSH
90281: LD_EXP 110
90285: AND
90286: IFFALSE 90432
90288: GO 90290
90290: DISABLE
90291: LD_INT 0
90293: PPUSH
90294: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90295: LD_ADDR_VAR 0 1
90299: PUSH
90300: LD_INT 22
90302: PUSH
90303: LD_OWVAR 2
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: PUSH
90312: LD_INT 2
90314: PUSH
90315: LD_INT 30
90317: PUSH
90318: LD_INT 0
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: LD_INT 30
90327: PUSH
90328: LD_INT 1
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: LIST
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PPUSH
90344: CALL_OW 69
90348: ST_TO_ADDR
// if not depot then
90349: LD_VAR 0 1
90353: NOT
90354: IFFALSE 90358
// exit ;
90356: GO 90432
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
90358: LD_ADDR_VAR 0 2
90362: PUSH
90363: LD_VAR 0 1
90367: PUSH
90368: LD_INT 1
90370: PPUSH
90371: LD_VAR 0 1
90375: PPUSH
90376: CALL_OW 12
90380: ARRAY
90381: PPUSH
90382: CALL_OW 274
90386: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
90387: LD_VAR 0 2
90391: PPUSH
90392: LD_INT 1
90394: PPUSH
90395: LD_INT 0
90397: PPUSH
90398: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
90402: LD_VAR 0 2
90406: PPUSH
90407: LD_INT 2
90409: PPUSH
90410: LD_INT 0
90412: PPUSH
90413: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
90417: LD_VAR 0 2
90421: PPUSH
90422: LD_INT 3
90424: PPUSH
90425: LD_INT 0
90427: PPUSH
90428: CALL_OW 277
// end ;
90432: PPOPN 2
90434: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
90435: LD_EXP 83
90439: PUSH
90440: LD_EXP 111
90444: AND
90445: IFFALSE 90542
90447: GO 90449
90449: DISABLE
90450: LD_INT 0
90452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90453: LD_ADDR_VAR 0 1
90457: PUSH
90458: LD_INT 22
90460: PUSH
90461: LD_OWVAR 2
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 21
90472: PUSH
90473: LD_INT 1
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 3
90482: PUSH
90483: LD_INT 23
90485: PUSH
90486: LD_INT 0
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: LIST
90501: PPUSH
90502: CALL_OW 69
90506: ST_TO_ADDR
// if not tmp then
90507: LD_VAR 0 1
90511: NOT
90512: IFFALSE 90516
// exit ;
90514: GO 90542
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90516: LD_VAR 0 1
90520: PUSH
90521: LD_INT 1
90523: PPUSH
90524: LD_VAR 0 1
90528: PPUSH
90529: CALL_OW 12
90533: ARRAY
90534: PPUSH
90535: LD_INT 200
90537: PPUSH
90538: CALL_OW 234
// end ;
90542: PPOPN 1
90544: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90545: LD_EXP 83
90549: PUSH
90550: LD_EXP 112
90554: AND
90555: IFFALSE 90634
90557: GO 90559
90559: DISABLE
90560: LD_INT 0
90562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90563: LD_ADDR_VAR 0 1
90567: PUSH
90568: LD_INT 22
90570: PUSH
90571: LD_OWVAR 2
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 21
90582: PUSH
90583: LD_INT 2
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PPUSH
90594: CALL_OW 69
90598: ST_TO_ADDR
// if not tmp then
90599: LD_VAR 0 1
90603: NOT
90604: IFFALSE 90608
// exit ;
90606: GO 90634
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90608: LD_VAR 0 1
90612: PUSH
90613: LD_INT 1
90615: PPUSH
90616: LD_VAR 0 1
90620: PPUSH
90621: CALL_OW 12
90625: ARRAY
90626: PPUSH
90627: LD_INT 60
90629: PPUSH
90630: CALL_OW 234
// end ;
90634: PPOPN 1
90636: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
90637: LD_EXP 83
90641: PUSH
90642: LD_EXP 113
90646: AND
90647: IFFALSE 90746
90649: GO 90651
90651: DISABLE
90652: LD_INT 0
90654: PPUSH
90655: PPUSH
// begin enable ;
90656: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
90657: LD_ADDR_VAR 0 1
90661: PUSH
90662: LD_INT 22
90664: PUSH
90665: LD_OWVAR 2
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 61
90676: PUSH
90677: EMPTY
90678: LIST
90679: PUSH
90680: LD_INT 33
90682: PUSH
90683: LD_INT 2
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: LIST
90694: PPUSH
90695: CALL_OW 69
90699: ST_TO_ADDR
// if not tmp then
90700: LD_VAR 0 1
90704: NOT
90705: IFFALSE 90709
// exit ;
90707: GO 90746
// for i in tmp do
90709: LD_ADDR_VAR 0 2
90713: PUSH
90714: LD_VAR 0 1
90718: PUSH
90719: FOR_IN
90720: IFFALSE 90744
// if IsControledBy ( i ) then
90722: LD_VAR 0 2
90726: PPUSH
90727: CALL_OW 312
90731: IFFALSE 90742
// ComUnlink ( i ) ;
90733: LD_VAR 0 2
90737: PPUSH
90738: CALL_OW 136
90742: GO 90719
90744: POP
90745: POP
// end ;
90746: PPOPN 2
90748: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
90749: LD_EXP 83
90753: PUSH
90754: LD_EXP 114
90758: AND
90759: IFFALSE 90899
90761: GO 90763
90763: DISABLE
90764: LD_INT 0
90766: PPUSH
90767: PPUSH
// begin ToLua ( displayPowell(); ) ;
90768: LD_STRING displayPowell();
90770: PPUSH
90771: CALL_OW 559
// uc_side := 0 ;
90775: LD_ADDR_OWVAR 20
90779: PUSH
90780: LD_INT 0
90782: ST_TO_ADDR
// uc_nation := 2 ;
90783: LD_ADDR_OWVAR 21
90787: PUSH
90788: LD_INT 2
90790: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
90791: LD_ADDR_OWVAR 37
90795: PUSH
90796: LD_INT 14
90798: ST_TO_ADDR
// vc_engine := engine_siberite ;
90799: LD_ADDR_OWVAR 39
90803: PUSH
90804: LD_INT 3
90806: ST_TO_ADDR
// vc_control := control_apeman ;
90807: LD_ADDR_OWVAR 38
90811: PUSH
90812: LD_INT 5
90814: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
90815: LD_ADDR_OWVAR 40
90819: PUSH
90820: LD_INT 29
90822: ST_TO_ADDR
// un := CreateVehicle ;
90823: LD_ADDR_VAR 0 2
90827: PUSH
90828: CALL_OW 45
90832: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90833: LD_VAR 0 2
90837: PPUSH
90838: LD_INT 1
90840: PPUSH
90841: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90845: LD_INT 35
90847: PPUSH
90848: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90852: LD_VAR 0 2
90856: PPUSH
90857: LD_INT 22
90859: PUSH
90860: LD_OWVAR 2
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PPUSH
90869: CALL_OW 69
90873: PPUSH
90874: LD_VAR 0 2
90878: PPUSH
90879: CALL_OW 74
90883: PPUSH
90884: CALL_OW 115
// until IsDead ( un ) ;
90888: LD_VAR 0 2
90892: PPUSH
90893: CALL_OW 301
90897: IFFALSE 90845
// end ;
90899: PPOPN 2
90901: END
// every 0 0$1 trigger StreamModeActive and sStu do
90902: LD_EXP 83
90906: PUSH
90907: LD_EXP 122
90911: AND
90912: IFFALSE 90928
90914: GO 90916
90916: DISABLE
// begin ToLua ( displayStucuk(); ) ;
90917: LD_STRING displayStucuk();
90919: PPUSH
90920: CALL_OW 559
// ResetFog ;
90924: CALL_OW 335
// end ;
90928: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
90929: LD_EXP 83
90933: PUSH
90934: LD_EXP 115
90938: AND
90939: IFFALSE 91080
90941: GO 90943
90943: DISABLE
90944: LD_INT 0
90946: PPUSH
90947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90948: LD_ADDR_VAR 0 2
90952: PUSH
90953: LD_INT 22
90955: PUSH
90956: LD_OWVAR 2
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 21
90967: PUSH
90968: LD_INT 1
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PPUSH
90979: CALL_OW 69
90983: ST_TO_ADDR
// if not tmp then
90984: LD_VAR 0 2
90988: NOT
90989: IFFALSE 90993
// exit ;
90991: GO 91080
// un := tmp [ rand ( 1 , tmp ) ] ;
90993: LD_ADDR_VAR 0 1
90997: PUSH
90998: LD_VAR 0 2
91002: PUSH
91003: LD_INT 1
91005: PPUSH
91006: LD_VAR 0 2
91010: PPUSH
91011: CALL_OW 12
91015: ARRAY
91016: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91017: LD_VAR 0 1
91021: PPUSH
91022: LD_INT 0
91024: PPUSH
91025: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91029: LD_VAR 0 1
91033: PPUSH
91034: LD_OWVAR 3
91038: PUSH
91039: LD_VAR 0 1
91043: DIFF
91044: PPUSH
91045: LD_VAR 0 1
91049: PPUSH
91050: CALL_OW 74
91054: PPUSH
91055: CALL_OW 115
// wait ( 0 0$20 ) ;
91059: LD_INT 700
91061: PPUSH
91062: CALL_OW 67
// SetSide ( un , your_side ) ;
91066: LD_VAR 0 1
91070: PPUSH
91071: LD_OWVAR 2
91075: PPUSH
91076: CALL_OW 235
// end ;
91080: PPOPN 2
91082: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
91083: LD_EXP 83
91087: PUSH
91088: LD_EXP 116
91092: AND
91093: IFFALSE 91199
91095: GO 91097
91097: DISABLE
91098: LD_INT 0
91100: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91101: LD_ADDR_VAR 0 1
91105: PUSH
91106: LD_INT 22
91108: PUSH
91109: LD_OWVAR 2
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 2
91120: PUSH
91121: LD_INT 30
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 30
91133: PUSH
91134: LD_INT 1
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: LIST
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PPUSH
91150: CALL_OW 69
91154: ST_TO_ADDR
// if not depot then
91155: LD_VAR 0 1
91159: NOT
91160: IFFALSE 91164
// exit ;
91162: GO 91199
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
91164: LD_VAR 0 1
91168: PUSH
91169: LD_INT 1
91171: ARRAY
91172: PPUSH
91173: CALL_OW 250
91177: PPUSH
91178: LD_VAR 0 1
91182: PUSH
91183: LD_INT 1
91185: ARRAY
91186: PPUSH
91187: CALL_OW 251
91191: PPUSH
91192: LD_INT 70
91194: PPUSH
91195: CALL_OW 495
// end ;
91199: PPOPN 1
91201: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
91202: LD_EXP 83
91206: PUSH
91207: LD_EXP 117
91211: AND
91212: IFFALSE 91423
91214: GO 91216
91216: DISABLE
91217: LD_INT 0
91219: PPUSH
91220: PPUSH
91221: PPUSH
91222: PPUSH
91223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91224: LD_ADDR_VAR 0 5
91228: PUSH
91229: LD_INT 22
91231: PUSH
91232: LD_OWVAR 2
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 21
91243: PUSH
91244: LD_INT 1
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PPUSH
91255: CALL_OW 69
91259: ST_TO_ADDR
// if not tmp then
91260: LD_VAR 0 5
91264: NOT
91265: IFFALSE 91269
// exit ;
91267: GO 91423
// for i in tmp do
91269: LD_ADDR_VAR 0 1
91273: PUSH
91274: LD_VAR 0 5
91278: PUSH
91279: FOR_IN
91280: IFFALSE 91421
// begin d := rand ( 0 , 5 ) ;
91282: LD_ADDR_VAR 0 4
91286: PUSH
91287: LD_INT 0
91289: PPUSH
91290: LD_INT 5
91292: PPUSH
91293: CALL_OW 12
91297: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
91298: LD_ADDR_VAR 0 2
91302: PUSH
91303: LD_VAR 0 1
91307: PPUSH
91308: CALL_OW 250
91312: PPUSH
91313: LD_VAR 0 4
91317: PPUSH
91318: LD_INT 3
91320: PPUSH
91321: LD_INT 12
91323: PPUSH
91324: CALL_OW 12
91328: PPUSH
91329: CALL_OW 272
91333: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
91334: LD_ADDR_VAR 0 3
91338: PUSH
91339: LD_VAR 0 1
91343: PPUSH
91344: CALL_OW 251
91348: PPUSH
91349: LD_VAR 0 4
91353: PPUSH
91354: LD_INT 3
91356: PPUSH
91357: LD_INT 12
91359: PPUSH
91360: CALL_OW 12
91364: PPUSH
91365: CALL_OW 273
91369: ST_TO_ADDR
// if ValidHex ( x , y ) then
91370: LD_VAR 0 2
91374: PPUSH
91375: LD_VAR 0 3
91379: PPUSH
91380: CALL_OW 488
91384: IFFALSE 91419
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
91386: LD_VAR 0 1
91390: PPUSH
91391: LD_VAR 0 2
91395: PPUSH
91396: LD_VAR 0 3
91400: PPUSH
91401: LD_INT 3
91403: PPUSH
91404: LD_INT 6
91406: PPUSH
91407: CALL_OW 12
91411: PPUSH
91412: LD_INT 1
91414: PPUSH
91415: CALL_OW 483
// end ;
91419: GO 91279
91421: POP
91422: POP
// end ;
91423: PPOPN 5
91425: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
91426: LD_EXP 83
91430: PUSH
91431: LD_EXP 118
91435: AND
91436: IFFALSE 91530
91438: GO 91440
91440: DISABLE
91441: LD_INT 0
91443: PPUSH
91444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
91445: LD_ADDR_VAR 0 2
91449: PUSH
91450: LD_INT 22
91452: PUSH
91453: LD_OWVAR 2
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 32
91464: PUSH
91465: LD_INT 1
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 21
91474: PUSH
91475: LD_INT 2
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: LIST
91486: PPUSH
91487: CALL_OW 69
91491: ST_TO_ADDR
// if not tmp then
91492: LD_VAR 0 2
91496: NOT
91497: IFFALSE 91501
// exit ;
91499: GO 91530
// for i in tmp do
91501: LD_ADDR_VAR 0 1
91505: PUSH
91506: LD_VAR 0 2
91510: PUSH
91511: FOR_IN
91512: IFFALSE 91528
// SetFuel ( i , 0 ) ;
91514: LD_VAR 0 1
91518: PPUSH
91519: LD_INT 0
91521: PPUSH
91522: CALL_OW 240
91526: GO 91511
91528: POP
91529: POP
// end ;
91530: PPOPN 2
91532: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91533: LD_EXP 83
91537: PUSH
91538: LD_EXP 119
91542: AND
91543: IFFALSE 91609
91545: GO 91547
91547: DISABLE
91548: LD_INT 0
91550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91551: LD_ADDR_VAR 0 1
91555: PUSH
91556: LD_INT 22
91558: PUSH
91559: LD_OWVAR 2
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 30
91570: PUSH
91571: LD_INT 29
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PPUSH
91582: CALL_OW 69
91586: ST_TO_ADDR
// if not tmp then
91587: LD_VAR 0 1
91591: NOT
91592: IFFALSE 91596
// exit ;
91594: GO 91609
// DestroyUnit ( tmp [ 1 ] ) ;
91596: LD_VAR 0 1
91600: PUSH
91601: LD_INT 1
91603: ARRAY
91604: PPUSH
91605: CALL_OW 65
// end ;
91609: PPOPN 1
91611: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91612: LD_EXP 83
91616: PUSH
91617: LD_EXP 121
91621: AND
91622: IFFALSE 91751
91624: GO 91626
91626: DISABLE
91627: LD_INT 0
91629: PPUSH
// begin uc_side := 0 ;
91630: LD_ADDR_OWVAR 20
91634: PUSH
91635: LD_INT 0
91637: ST_TO_ADDR
// uc_nation := nation_arabian ;
91638: LD_ADDR_OWVAR 21
91642: PUSH
91643: LD_INT 2
91645: ST_TO_ADDR
// hc_gallery :=  ;
91646: LD_ADDR_OWVAR 33
91650: PUSH
91651: LD_STRING 
91653: ST_TO_ADDR
// hc_name :=  ;
91654: LD_ADDR_OWVAR 26
91658: PUSH
91659: LD_STRING 
91661: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
91662: LD_INT 1
91664: PPUSH
91665: LD_INT 11
91667: PPUSH
91668: LD_INT 10
91670: PPUSH
91671: CALL_OW 380
// un := CreateHuman ;
91675: LD_ADDR_VAR 0 1
91679: PUSH
91680: CALL_OW 44
91684: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91685: LD_VAR 0 1
91689: PPUSH
91690: LD_INT 1
91692: PPUSH
91693: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91697: LD_INT 35
91699: PPUSH
91700: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91704: LD_VAR 0 1
91708: PPUSH
91709: LD_INT 22
91711: PUSH
91712: LD_OWVAR 2
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PPUSH
91721: CALL_OW 69
91725: PPUSH
91726: LD_VAR 0 1
91730: PPUSH
91731: CALL_OW 74
91735: PPUSH
91736: CALL_OW 115
// until IsDead ( un ) ;
91740: LD_VAR 0 1
91744: PPUSH
91745: CALL_OW 301
91749: IFFALSE 91697
// end ;
91751: PPOPN 1
91753: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
91754: LD_EXP 83
91758: PUSH
91759: LD_EXP 123
91763: AND
91764: IFFALSE 91776
91766: GO 91768
91768: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
91769: LD_STRING earthquake(getX(game), 0, 32)
91771: PPUSH
91772: CALL_OW 559
91776: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
91777: LD_EXP 83
91781: PUSH
91782: LD_EXP 124
91786: AND
91787: IFFALSE 91878
91789: GO 91791
91791: DISABLE
91792: LD_INT 0
91794: PPUSH
// begin enable ;
91795: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
91796: LD_ADDR_VAR 0 1
91800: PUSH
91801: LD_INT 22
91803: PUSH
91804: LD_OWVAR 2
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: PUSH
91813: LD_INT 21
91815: PUSH
91816: LD_INT 2
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 33
91825: PUSH
91826: LD_INT 3
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: LIST
91837: PPUSH
91838: CALL_OW 69
91842: ST_TO_ADDR
// if not tmp then
91843: LD_VAR 0 1
91847: NOT
91848: IFFALSE 91852
// exit ;
91850: GO 91878
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91852: LD_VAR 0 1
91856: PUSH
91857: LD_INT 1
91859: PPUSH
91860: LD_VAR 0 1
91864: PPUSH
91865: CALL_OW 12
91869: ARRAY
91870: PPUSH
91871: LD_INT 1
91873: PPUSH
91874: CALL_OW 234
// end ;
91878: PPOPN 1
91880: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
91881: LD_EXP 83
91885: PUSH
91886: LD_EXP 125
91890: AND
91891: IFFALSE 92032
91893: GO 91895
91895: DISABLE
91896: LD_INT 0
91898: PPUSH
91899: PPUSH
91900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91901: LD_ADDR_VAR 0 3
91905: PUSH
91906: LD_INT 22
91908: PUSH
91909: LD_OWVAR 2
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 25
91920: PUSH
91921: LD_INT 1
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PPUSH
91932: CALL_OW 69
91936: ST_TO_ADDR
// if not tmp then
91937: LD_VAR 0 3
91941: NOT
91942: IFFALSE 91946
// exit ;
91944: GO 92032
// un := tmp [ rand ( 1 , tmp ) ] ;
91946: LD_ADDR_VAR 0 2
91950: PUSH
91951: LD_VAR 0 3
91955: PUSH
91956: LD_INT 1
91958: PPUSH
91959: LD_VAR 0 3
91963: PPUSH
91964: CALL_OW 12
91968: ARRAY
91969: ST_TO_ADDR
// if Crawls ( un ) then
91970: LD_VAR 0 2
91974: PPUSH
91975: CALL_OW 318
91979: IFFALSE 91990
// ComWalk ( un ) ;
91981: LD_VAR 0 2
91985: PPUSH
91986: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
91990: LD_VAR 0 2
91994: PPUSH
91995: LD_INT 9
91997: PPUSH
91998: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92002: LD_INT 28
92004: PPUSH
92005: LD_OWVAR 2
92009: PPUSH
92010: LD_INT 2
92012: PPUSH
92013: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92017: LD_INT 29
92019: PPUSH
92020: LD_OWVAR 2
92024: PPUSH
92025: LD_INT 2
92027: PPUSH
92028: CALL_OW 322
// end ;
92032: PPOPN 3
92034: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92035: LD_EXP 83
92039: PUSH
92040: LD_EXP 126
92044: AND
92045: IFFALSE 92156
92047: GO 92049
92049: DISABLE
92050: LD_INT 0
92052: PPUSH
92053: PPUSH
92054: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92055: LD_ADDR_VAR 0 3
92059: PUSH
92060: LD_INT 22
92062: PUSH
92063: LD_OWVAR 2
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: PUSH
92072: LD_INT 25
92074: PUSH
92075: LD_INT 1
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PPUSH
92086: CALL_OW 69
92090: ST_TO_ADDR
// if not tmp then
92091: LD_VAR 0 3
92095: NOT
92096: IFFALSE 92100
// exit ;
92098: GO 92156
// un := tmp [ rand ( 1 , tmp ) ] ;
92100: LD_ADDR_VAR 0 2
92104: PUSH
92105: LD_VAR 0 3
92109: PUSH
92110: LD_INT 1
92112: PPUSH
92113: LD_VAR 0 3
92117: PPUSH
92118: CALL_OW 12
92122: ARRAY
92123: ST_TO_ADDR
// if Crawls ( un ) then
92124: LD_VAR 0 2
92128: PPUSH
92129: CALL_OW 318
92133: IFFALSE 92144
// ComWalk ( un ) ;
92135: LD_VAR 0 2
92139: PPUSH
92140: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92144: LD_VAR 0 2
92148: PPUSH
92149: LD_INT 8
92151: PPUSH
92152: CALL_OW 336
// end ;
92156: PPOPN 3
92158: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
92159: LD_EXP 83
92163: PUSH
92164: LD_EXP 127
92168: AND
92169: IFFALSE 92313
92171: GO 92173
92173: DISABLE
92174: LD_INT 0
92176: PPUSH
92177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
92178: LD_ADDR_VAR 0 2
92182: PUSH
92183: LD_INT 22
92185: PUSH
92186: LD_OWVAR 2
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 21
92197: PUSH
92198: LD_INT 2
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 2
92207: PUSH
92208: LD_INT 34
92210: PUSH
92211: LD_INT 12
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 34
92220: PUSH
92221: LD_INT 51
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 34
92230: PUSH
92231: LD_INT 32
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: LIST
92248: PPUSH
92249: CALL_OW 69
92253: ST_TO_ADDR
// if not tmp then
92254: LD_VAR 0 2
92258: NOT
92259: IFFALSE 92263
// exit ;
92261: GO 92313
// for i in tmp do
92263: LD_ADDR_VAR 0 1
92267: PUSH
92268: LD_VAR 0 2
92272: PUSH
92273: FOR_IN
92274: IFFALSE 92311
// if GetCargo ( i , mat_artifact ) = 0 then
92276: LD_VAR 0 1
92280: PPUSH
92281: LD_INT 4
92283: PPUSH
92284: CALL_OW 289
92288: PUSH
92289: LD_INT 0
92291: EQUAL
92292: IFFALSE 92309
// SetCargo ( i , mat_siberit , 100 ) ;
92294: LD_VAR 0 1
92298: PPUSH
92299: LD_INT 3
92301: PPUSH
92302: LD_INT 100
92304: PPUSH
92305: CALL_OW 290
92309: GO 92273
92311: POP
92312: POP
// end ;
92313: PPOPN 2
92315: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
92316: LD_EXP 83
92320: PUSH
92321: LD_EXP 128
92325: AND
92326: IFFALSE 92509
92328: GO 92330
92330: DISABLE
92331: LD_INT 0
92333: PPUSH
92334: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
92335: LD_ADDR_VAR 0 2
92339: PUSH
92340: LD_INT 22
92342: PUSH
92343: LD_OWVAR 2
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PPUSH
92352: CALL_OW 69
92356: ST_TO_ADDR
// if not tmp then
92357: LD_VAR 0 2
92361: NOT
92362: IFFALSE 92366
// exit ;
92364: GO 92509
// for i := 1 to 2 do
92366: LD_ADDR_VAR 0 1
92370: PUSH
92371: DOUBLE
92372: LD_INT 1
92374: DEC
92375: ST_TO_ADDR
92376: LD_INT 2
92378: PUSH
92379: FOR_TO
92380: IFFALSE 92507
// begin uc_side := your_side ;
92382: LD_ADDR_OWVAR 20
92386: PUSH
92387: LD_OWVAR 2
92391: ST_TO_ADDR
// uc_nation := nation_american ;
92392: LD_ADDR_OWVAR 21
92396: PUSH
92397: LD_INT 1
92399: ST_TO_ADDR
// vc_chassis := us_morphling ;
92400: LD_ADDR_OWVAR 37
92404: PUSH
92405: LD_INT 5
92407: ST_TO_ADDR
// vc_engine := engine_siberite ;
92408: LD_ADDR_OWVAR 39
92412: PUSH
92413: LD_INT 3
92415: ST_TO_ADDR
// vc_control := control_computer ;
92416: LD_ADDR_OWVAR 38
92420: PUSH
92421: LD_INT 3
92423: ST_TO_ADDR
// vc_weapon := us_double_laser ;
92424: LD_ADDR_OWVAR 40
92428: PUSH
92429: LD_INT 10
92431: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
92432: LD_VAR 0 2
92436: PUSH
92437: LD_INT 1
92439: ARRAY
92440: PPUSH
92441: CALL_OW 310
92445: NOT
92446: IFFALSE 92493
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
92448: CALL_OW 45
92452: PPUSH
92453: LD_VAR 0 2
92457: PUSH
92458: LD_INT 1
92460: ARRAY
92461: PPUSH
92462: CALL_OW 250
92466: PPUSH
92467: LD_VAR 0 2
92471: PUSH
92472: LD_INT 1
92474: ARRAY
92475: PPUSH
92476: CALL_OW 251
92480: PPUSH
92481: LD_INT 12
92483: PPUSH
92484: LD_INT 1
92486: PPUSH
92487: CALL_OW 50
92491: GO 92505
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92493: CALL_OW 45
92497: PPUSH
92498: LD_INT 1
92500: PPUSH
92501: CALL_OW 51
// end ;
92505: GO 92379
92507: POP
92508: POP
// end ;
92509: PPOPN 2
92511: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92512: LD_EXP 83
92516: PUSH
92517: LD_EXP 129
92521: AND
92522: IFFALSE 92744
92524: GO 92526
92526: DISABLE
92527: LD_INT 0
92529: PPUSH
92530: PPUSH
92531: PPUSH
92532: PPUSH
92533: PPUSH
92534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92535: LD_ADDR_VAR 0 6
92539: PUSH
92540: LD_INT 22
92542: PUSH
92543: LD_OWVAR 2
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: LD_INT 21
92554: PUSH
92555: LD_INT 1
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 3
92564: PUSH
92565: LD_INT 23
92567: PUSH
92568: LD_INT 0
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: LIST
92583: PPUSH
92584: CALL_OW 69
92588: ST_TO_ADDR
// if not tmp then
92589: LD_VAR 0 6
92593: NOT
92594: IFFALSE 92598
// exit ;
92596: GO 92744
// s1 := rand ( 1 , 4 ) ;
92598: LD_ADDR_VAR 0 2
92602: PUSH
92603: LD_INT 1
92605: PPUSH
92606: LD_INT 4
92608: PPUSH
92609: CALL_OW 12
92613: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92614: LD_ADDR_VAR 0 4
92618: PUSH
92619: LD_VAR 0 6
92623: PUSH
92624: LD_INT 1
92626: ARRAY
92627: PPUSH
92628: LD_VAR 0 2
92632: PPUSH
92633: CALL_OW 259
92637: ST_TO_ADDR
// if s1 = 1 then
92638: LD_VAR 0 2
92642: PUSH
92643: LD_INT 1
92645: EQUAL
92646: IFFALSE 92666
// s2 := rand ( 2 , 4 ) else
92648: LD_ADDR_VAR 0 3
92652: PUSH
92653: LD_INT 2
92655: PPUSH
92656: LD_INT 4
92658: PPUSH
92659: CALL_OW 12
92663: ST_TO_ADDR
92664: GO 92674
// s2 := 1 ;
92666: LD_ADDR_VAR 0 3
92670: PUSH
92671: LD_INT 1
92673: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
92674: LD_ADDR_VAR 0 5
92678: PUSH
92679: LD_VAR 0 6
92683: PUSH
92684: LD_INT 1
92686: ARRAY
92687: PPUSH
92688: LD_VAR 0 3
92692: PPUSH
92693: CALL_OW 259
92697: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
92698: LD_VAR 0 6
92702: PUSH
92703: LD_INT 1
92705: ARRAY
92706: PPUSH
92707: LD_VAR 0 2
92711: PPUSH
92712: LD_VAR 0 5
92716: PPUSH
92717: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
92721: LD_VAR 0 6
92725: PUSH
92726: LD_INT 1
92728: ARRAY
92729: PPUSH
92730: LD_VAR 0 3
92734: PPUSH
92735: LD_VAR 0 4
92739: PPUSH
92740: CALL_OW 237
// end ;
92744: PPOPN 6
92746: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
92747: LD_EXP 83
92751: PUSH
92752: LD_EXP 130
92756: AND
92757: IFFALSE 92836
92759: GO 92761
92761: DISABLE
92762: LD_INT 0
92764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
92765: LD_ADDR_VAR 0 1
92769: PUSH
92770: LD_INT 22
92772: PUSH
92773: LD_OWVAR 2
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: PUSH
92782: LD_INT 30
92784: PUSH
92785: LD_INT 3
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PPUSH
92796: CALL_OW 69
92800: ST_TO_ADDR
// if not tmp then
92801: LD_VAR 0 1
92805: NOT
92806: IFFALSE 92810
// exit ;
92808: GO 92836
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92810: LD_VAR 0 1
92814: PUSH
92815: LD_INT 1
92817: PPUSH
92818: LD_VAR 0 1
92822: PPUSH
92823: CALL_OW 12
92827: ARRAY
92828: PPUSH
92829: LD_INT 1
92831: PPUSH
92832: CALL_OW 234
// end ;
92836: PPOPN 1
92838: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
92839: LD_EXP 83
92843: PUSH
92844: LD_EXP 131
92848: AND
92849: IFFALSE 92961
92851: GO 92853
92853: DISABLE
92854: LD_INT 0
92856: PPUSH
92857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
92858: LD_ADDR_VAR 0 2
92862: PUSH
92863: LD_INT 22
92865: PUSH
92866: LD_OWVAR 2
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 2
92877: PUSH
92878: LD_INT 30
92880: PUSH
92881: LD_INT 27
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 30
92890: PUSH
92891: LD_INT 26
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 30
92900: PUSH
92901: LD_INT 28
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PPUSH
92918: CALL_OW 69
92922: ST_TO_ADDR
// if not tmp then
92923: LD_VAR 0 2
92927: NOT
92928: IFFALSE 92932
// exit ;
92930: GO 92961
// for i in tmp do
92932: LD_ADDR_VAR 0 1
92936: PUSH
92937: LD_VAR 0 2
92941: PUSH
92942: FOR_IN
92943: IFFALSE 92959
// SetLives ( i , 1 ) ;
92945: LD_VAR 0 1
92949: PPUSH
92950: LD_INT 1
92952: PPUSH
92953: CALL_OW 234
92957: GO 92942
92959: POP
92960: POP
// end ;
92961: PPOPN 2
92963: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
92964: LD_EXP 83
92968: PUSH
92969: LD_EXP 132
92973: AND
92974: IFFALSE 93248
92976: GO 92978
92978: DISABLE
92979: LD_INT 0
92981: PPUSH
92982: PPUSH
92983: PPUSH
// begin i := rand ( 1 , 7 ) ;
92984: LD_ADDR_VAR 0 1
92988: PUSH
92989: LD_INT 1
92991: PPUSH
92992: LD_INT 7
92994: PPUSH
92995: CALL_OW 12
92999: ST_TO_ADDR
// case i of 1 :
93000: LD_VAR 0 1
93004: PUSH
93005: LD_INT 1
93007: DOUBLE
93008: EQUAL
93009: IFTRUE 93013
93011: GO 93023
93013: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93014: LD_STRING earthquake(getX(game), 0, 32)
93016: PPUSH
93017: CALL_OW 559
93021: GO 93248
93023: LD_INT 2
93025: DOUBLE
93026: EQUAL
93027: IFTRUE 93031
93029: GO 93045
93031: POP
// begin ToLua ( displayStucuk(); ) ;
93032: LD_STRING displayStucuk();
93034: PPUSH
93035: CALL_OW 559
// ResetFog ;
93039: CALL_OW 335
// end ; 3 :
93043: GO 93248
93045: LD_INT 3
93047: DOUBLE
93048: EQUAL
93049: IFTRUE 93053
93051: GO 93157
93053: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93054: LD_ADDR_VAR 0 2
93058: PUSH
93059: LD_INT 22
93061: PUSH
93062: LD_OWVAR 2
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PUSH
93071: LD_INT 25
93073: PUSH
93074: LD_INT 1
93076: PUSH
93077: EMPTY
93078: LIST
93079: LIST
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PPUSH
93085: CALL_OW 69
93089: ST_TO_ADDR
// if not tmp then
93090: LD_VAR 0 2
93094: NOT
93095: IFFALSE 93099
// exit ;
93097: GO 93248
// un := tmp [ rand ( 1 , tmp ) ] ;
93099: LD_ADDR_VAR 0 3
93103: PUSH
93104: LD_VAR 0 2
93108: PUSH
93109: LD_INT 1
93111: PPUSH
93112: LD_VAR 0 2
93116: PPUSH
93117: CALL_OW 12
93121: ARRAY
93122: ST_TO_ADDR
// if Crawls ( un ) then
93123: LD_VAR 0 3
93127: PPUSH
93128: CALL_OW 318
93132: IFFALSE 93143
// ComWalk ( un ) ;
93134: LD_VAR 0 3
93138: PPUSH
93139: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93143: LD_VAR 0 3
93147: PPUSH
93148: LD_INT 8
93150: PPUSH
93151: CALL_OW 336
// end ; 4 :
93155: GO 93248
93157: LD_INT 4
93159: DOUBLE
93160: EQUAL
93161: IFTRUE 93165
93163: GO 93226
93165: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93166: LD_ADDR_VAR 0 2
93170: PUSH
93171: LD_INT 22
93173: PUSH
93174: LD_OWVAR 2
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: PUSH
93183: LD_INT 30
93185: PUSH
93186: LD_INT 29
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PPUSH
93197: CALL_OW 69
93201: ST_TO_ADDR
// if not tmp then
93202: LD_VAR 0 2
93206: NOT
93207: IFFALSE 93211
// exit ;
93209: GO 93248
// DestroyUnit ( tmp [ 1 ] ) ;
93211: LD_VAR 0 2
93215: PUSH
93216: LD_INT 1
93218: ARRAY
93219: PPUSH
93220: CALL_OW 65
// end ; 5 .. 7 :
93224: GO 93248
93226: LD_INT 5
93228: DOUBLE
93229: GREATEREQUAL
93230: IFFALSE 93238
93232: LD_INT 7
93234: DOUBLE
93235: LESSEQUAL
93236: IFTRUE 93240
93238: GO 93247
93240: POP
// StreamSibBomb ; end ;
93241: CALL 89498 0 0
93245: GO 93248
93247: POP
// end ;
93248: PPOPN 3
93250: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
93251: LD_EXP 83
93255: PUSH
93256: LD_EXP 133
93260: AND
93261: IFFALSE 93417
93263: GO 93265
93265: DISABLE
93266: LD_INT 0
93268: PPUSH
93269: PPUSH
93270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
93271: LD_ADDR_VAR 0 2
93275: PUSH
93276: LD_INT 81
93278: PUSH
93279: LD_OWVAR 2
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PUSH
93288: LD_INT 2
93290: PUSH
93291: LD_INT 21
93293: PUSH
93294: LD_INT 1
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 21
93303: PUSH
93304: LD_INT 2
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: LIST
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PPUSH
93320: CALL_OW 69
93324: ST_TO_ADDR
// if not tmp then
93325: LD_VAR 0 2
93329: NOT
93330: IFFALSE 93334
// exit ;
93332: GO 93417
// p := 0 ;
93334: LD_ADDR_VAR 0 3
93338: PUSH
93339: LD_INT 0
93341: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93342: LD_INT 35
93344: PPUSH
93345: CALL_OW 67
// p := p + 1 ;
93349: LD_ADDR_VAR 0 3
93353: PUSH
93354: LD_VAR 0 3
93358: PUSH
93359: LD_INT 1
93361: PLUS
93362: ST_TO_ADDR
// for i in tmp do
93363: LD_ADDR_VAR 0 1
93367: PUSH
93368: LD_VAR 0 2
93372: PUSH
93373: FOR_IN
93374: IFFALSE 93405
// if GetLives ( i ) < 1000 then
93376: LD_VAR 0 1
93380: PPUSH
93381: CALL_OW 256
93385: PUSH
93386: LD_INT 1000
93388: LESS
93389: IFFALSE 93403
// SetLives ( i , 1000 ) ;
93391: LD_VAR 0 1
93395: PPUSH
93396: LD_INT 1000
93398: PPUSH
93399: CALL_OW 234
93403: GO 93373
93405: POP
93406: POP
// until p > 20 ;
93407: LD_VAR 0 3
93411: PUSH
93412: LD_INT 20
93414: GREATER
93415: IFFALSE 93342
// end ;
93417: PPOPN 3
93419: END
// every 0 0$1 trigger StreamModeActive and sTime do
93420: LD_EXP 83
93424: PUSH
93425: LD_EXP 134
93429: AND
93430: IFFALSE 93465
93432: GO 93434
93434: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
93435: LD_INT 28
93437: PPUSH
93438: LD_OWVAR 2
93442: PPUSH
93443: LD_INT 2
93445: PPUSH
93446: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
93450: LD_INT 30
93452: PPUSH
93453: LD_OWVAR 2
93457: PPUSH
93458: LD_INT 2
93460: PPUSH
93461: CALL_OW 322
// end ;
93465: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93466: LD_EXP 83
93470: PUSH
93471: LD_EXP 135
93475: AND
93476: IFFALSE 93597
93478: GO 93480
93480: DISABLE
93481: LD_INT 0
93483: PPUSH
93484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93485: LD_ADDR_VAR 0 2
93489: PUSH
93490: LD_INT 22
93492: PUSH
93493: LD_OWVAR 2
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 21
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 3
93514: PUSH
93515: LD_INT 23
93517: PUSH
93518: LD_INT 0
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: LIST
93533: PPUSH
93534: CALL_OW 69
93538: ST_TO_ADDR
// if not tmp then
93539: LD_VAR 0 2
93543: NOT
93544: IFFALSE 93548
// exit ;
93546: GO 93597
// for i in tmp do
93548: LD_ADDR_VAR 0 1
93552: PUSH
93553: LD_VAR 0 2
93557: PUSH
93558: FOR_IN
93559: IFFALSE 93595
// begin if Crawls ( i ) then
93561: LD_VAR 0 1
93565: PPUSH
93566: CALL_OW 318
93570: IFFALSE 93581
// ComWalk ( i ) ;
93572: LD_VAR 0 1
93576: PPUSH
93577: CALL_OW 138
// SetClass ( i , 2 ) ;
93581: LD_VAR 0 1
93585: PPUSH
93586: LD_INT 2
93588: PPUSH
93589: CALL_OW 336
// end ;
93593: GO 93558
93595: POP
93596: POP
// end ;
93597: PPOPN 2
93599: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93600: LD_EXP 83
93604: PUSH
93605: LD_EXP 136
93609: AND
93610: IFFALSE 93891
93612: GO 93614
93614: DISABLE
93615: LD_INT 0
93617: PPUSH
93618: PPUSH
93619: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
93620: LD_OWVAR 2
93624: PPUSH
93625: LD_INT 9
93627: PPUSH
93628: LD_INT 1
93630: PPUSH
93631: LD_INT 1
93633: PPUSH
93634: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
93638: LD_INT 9
93640: PPUSH
93641: LD_OWVAR 2
93645: PPUSH
93646: CALL_OW 343
// uc_side := 9 ;
93650: LD_ADDR_OWVAR 20
93654: PUSH
93655: LD_INT 9
93657: ST_TO_ADDR
// uc_nation := 2 ;
93658: LD_ADDR_OWVAR 21
93662: PUSH
93663: LD_INT 2
93665: ST_TO_ADDR
// hc_name := Dark Warrior ;
93666: LD_ADDR_OWVAR 26
93670: PUSH
93671: LD_STRING Dark Warrior
93673: ST_TO_ADDR
// hc_gallery :=  ;
93674: LD_ADDR_OWVAR 33
93678: PUSH
93679: LD_STRING 
93681: ST_TO_ADDR
// hc_noskilllimit := true ;
93682: LD_ADDR_OWVAR 76
93686: PUSH
93687: LD_INT 1
93689: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
93690: LD_ADDR_OWVAR 31
93694: PUSH
93695: LD_INT 30
93697: PUSH
93698: LD_INT 30
93700: PUSH
93701: LD_INT 30
93703: PUSH
93704: LD_INT 30
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: ST_TO_ADDR
// un := CreateHuman ;
93713: LD_ADDR_VAR 0 3
93717: PUSH
93718: CALL_OW 44
93722: ST_TO_ADDR
// hc_noskilllimit := false ;
93723: LD_ADDR_OWVAR 76
93727: PUSH
93728: LD_INT 0
93730: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93731: LD_VAR 0 3
93735: PPUSH
93736: LD_INT 1
93738: PPUSH
93739: CALL_OW 51
// p := 0 ;
93743: LD_ADDR_VAR 0 2
93747: PUSH
93748: LD_INT 0
93750: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93751: LD_INT 35
93753: PPUSH
93754: CALL_OW 67
// p := p + 1 ;
93758: LD_ADDR_VAR 0 2
93762: PUSH
93763: LD_VAR 0 2
93767: PUSH
93768: LD_INT 1
93770: PLUS
93771: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
93772: LD_VAR 0 3
93776: PPUSH
93777: CALL_OW 256
93781: PUSH
93782: LD_INT 1000
93784: LESS
93785: IFFALSE 93799
// SetLives ( un , 1000 ) ;
93787: LD_VAR 0 3
93791: PPUSH
93792: LD_INT 1000
93794: PPUSH
93795: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
93799: LD_VAR 0 3
93803: PPUSH
93804: LD_INT 81
93806: PUSH
93807: LD_OWVAR 2
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: LD_INT 91
93818: PUSH
93819: LD_VAR 0 3
93823: PUSH
93824: LD_INT 30
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: LIST
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PPUSH
93836: CALL_OW 69
93840: PPUSH
93841: LD_VAR 0 3
93845: PPUSH
93846: CALL_OW 74
93850: PPUSH
93851: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
93855: LD_VAR 0 2
93859: PUSH
93860: LD_INT 60
93862: GREATER
93863: PUSH
93864: LD_VAR 0 3
93868: PPUSH
93869: CALL_OW 301
93873: OR
93874: IFFALSE 93751
// if un then
93876: LD_VAR 0 3
93880: IFFALSE 93891
// RemoveUnit ( un ) ;
93882: LD_VAR 0 3
93886: PPUSH
93887: CALL_OW 64
// end ;
93891: PPOPN 3
93893: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93894: LD_INT 0
93896: PPUSH
// case cmd of 301 :
93897: LD_VAR 0 1
93901: PUSH
93902: LD_INT 301
93904: DOUBLE
93905: EQUAL
93906: IFTRUE 93910
93908: GO 93942
93910: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
93911: LD_VAR 0 6
93915: PPUSH
93916: LD_VAR 0 7
93920: PPUSH
93921: LD_VAR 0 8
93925: PPUSH
93926: LD_VAR 0 4
93930: PPUSH
93931: LD_VAR 0 5
93935: PPUSH
93936: CALL 95143 0 5
93940: GO 94063
93942: LD_INT 302
93944: DOUBLE
93945: EQUAL
93946: IFTRUE 93950
93948: GO 93987
93950: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
93951: LD_VAR 0 6
93955: PPUSH
93956: LD_VAR 0 7
93960: PPUSH
93961: LD_VAR 0 8
93965: PPUSH
93966: LD_VAR 0 9
93970: PPUSH
93971: LD_VAR 0 4
93975: PPUSH
93976: LD_VAR 0 5
93980: PPUSH
93981: CALL 95234 0 6
93985: GO 94063
93987: LD_INT 303
93989: DOUBLE
93990: EQUAL
93991: IFTRUE 93995
93993: GO 94032
93995: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
93996: LD_VAR 0 6
94000: PPUSH
94001: LD_VAR 0 7
94005: PPUSH
94006: LD_VAR 0 8
94010: PPUSH
94011: LD_VAR 0 9
94015: PPUSH
94016: LD_VAR 0 4
94020: PPUSH
94021: LD_VAR 0 5
94025: PPUSH
94026: CALL 94068 0 6
94030: GO 94063
94032: LD_INT 304
94034: DOUBLE
94035: EQUAL
94036: IFTRUE 94040
94038: GO 94062
94040: POP
// hHackTeleport ( unit , x , y ) ; end ;
94041: LD_VAR 0 2
94045: PPUSH
94046: LD_VAR 0 4
94050: PPUSH
94051: LD_VAR 0 5
94055: PPUSH
94056: CALL 95827 0 3
94060: GO 94063
94062: POP
// end ;
94063: LD_VAR 0 12
94067: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
94068: LD_INT 0
94070: PPUSH
94071: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
94072: LD_VAR 0 1
94076: PUSH
94077: LD_INT 1
94079: LESS
94080: PUSH
94081: LD_VAR 0 1
94085: PUSH
94086: LD_INT 3
94088: GREATER
94089: OR
94090: PUSH
94091: LD_VAR 0 5
94095: PPUSH
94096: LD_VAR 0 6
94100: PPUSH
94101: CALL_OW 428
94105: OR
94106: IFFALSE 94110
// exit ;
94108: GO 94830
// uc_side := your_side ;
94110: LD_ADDR_OWVAR 20
94114: PUSH
94115: LD_OWVAR 2
94119: ST_TO_ADDR
// uc_nation := nation ;
94120: LD_ADDR_OWVAR 21
94124: PUSH
94125: LD_VAR 0 1
94129: ST_TO_ADDR
// bc_level = 1 ;
94130: LD_ADDR_OWVAR 43
94134: PUSH
94135: LD_INT 1
94137: ST_TO_ADDR
// case btype of 1 :
94138: LD_VAR 0 2
94142: PUSH
94143: LD_INT 1
94145: DOUBLE
94146: EQUAL
94147: IFTRUE 94151
94149: GO 94162
94151: POP
// bc_type := b_depot ; 2 :
94152: LD_ADDR_OWVAR 42
94156: PUSH
94157: LD_INT 0
94159: ST_TO_ADDR
94160: GO 94774
94162: LD_INT 2
94164: DOUBLE
94165: EQUAL
94166: IFTRUE 94170
94168: GO 94181
94170: POP
// bc_type := b_warehouse ; 3 :
94171: LD_ADDR_OWVAR 42
94175: PUSH
94176: LD_INT 1
94178: ST_TO_ADDR
94179: GO 94774
94181: LD_INT 3
94183: DOUBLE
94184: EQUAL
94185: IFTRUE 94189
94187: GO 94200
94189: POP
// bc_type := b_lab ; 4 .. 9 :
94190: LD_ADDR_OWVAR 42
94194: PUSH
94195: LD_INT 6
94197: ST_TO_ADDR
94198: GO 94774
94200: LD_INT 4
94202: DOUBLE
94203: GREATEREQUAL
94204: IFFALSE 94212
94206: LD_INT 9
94208: DOUBLE
94209: LESSEQUAL
94210: IFTRUE 94214
94212: GO 94266
94214: POP
// begin bc_type := b_lab_half ;
94215: LD_ADDR_OWVAR 42
94219: PUSH
94220: LD_INT 7
94222: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
94223: LD_ADDR_OWVAR 44
94227: PUSH
94228: LD_INT 10
94230: PUSH
94231: LD_INT 11
94233: PUSH
94234: LD_INT 12
94236: PUSH
94237: LD_INT 15
94239: PUSH
94240: LD_INT 14
94242: PUSH
94243: LD_INT 13
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: PUSH
94254: LD_VAR 0 2
94258: PUSH
94259: LD_INT 3
94261: MINUS
94262: ARRAY
94263: ST_TO_ADDR
// end ; 10 .. 13 :
94264: GO 94774
94266: LD_INT 10
94268: DOUBLE
94269: GREATEREQUAL
94270: IFFALSE 94278
94272: LD_INT 13
94274: DOUBLE
94275: LESSEQUAL
94276: IFTRUE 94280
94278: GO 94357
94280: POP
// begin bc_type := b_lab_full ;
94281: LD_ADDR_OWVAR 42
94285: PUSH
94286: LD_INT 8
94288: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
94289: LD_ADDR_OWVAR 44
94293: PUSH
94294: LD_INT 10
94296: PUSH
94297: LD_INT 12
94299: PUSH
94300: LD_INT 14
94302: PUSH
94303: LD_INT 13
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: PUSH
94312: LD_VAR 0 2
94316: PUSH
94317: LD_INT 9
94319: MINUS
94320: ARRAY
94321: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
94322: LD_ADDR_OWVAR 45
94326: PUSH
94327: LD_INT 11
94329: PUSH
94330: LD_INT 15
94332: PUSH
94333: LD_INT 12
94335: PUSH
94336: LD_INT 15
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: PUSH
94345: LD_VAR 0 2
94349: PUSH
94350: LD_INT 9
94352: MINUS
94353: ARRAY
94354: ST_TO_ADDR
// end ; 14 :
94355: GO 94774
94357: LD_INT 14
94359: DOUBLE
94360: EQUAL
94361: IFTRUE 94365
94363: GO 94376
94365: POP
// bc_type := b_workshop ; 15 :
94366: LD_ADDR_OWVAR 42
94370: PUSH
94371: LD_INT 2
94373: ST_TO_ADDR
94374: GO 94774
94376: LD_INT 15
94378: DOUBLE
94379: EQUAL
94380: IFTRUE 94384
94382: GO 94395
94384: POP
// bc_type := b_factory ; 16 :
94385: LD_ADDR_OWVAR 42
94389: PUSH
94390: LD_INT 3
94392: ST_TO_ADDR
94393: GO 94774
94395: LD_INT 16
94397: DOUBLE
94398: EQUAL
94399: IFTRUE 94403
94401: GO 94414
94403: POP
// bc_type := b_ext_gun ; 17 :
94404: LD_ADDR_OWVAR 42
94408: PUSH
94409: LD_INT 17
94411: ST_TO_ADDR
94412: GO 94774
94414: LD_INT 17
94416: DOUBLE
94417: EQUAL
94418: IFTRUE 94422
94420: GO 94450
94422: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
94423: LD_ADDR_OWVAR 42
94427: PUSH
94428: LD_INT 19
94430: PUSH
94431: LD_INT 23
94433: PUSH
94434: LD_INT 19
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: LIST
94441: PUSH
94442: LD_VAR 0 1
94446: ARRAY
94447: ST_TO_ADDR
94448: GO 94774
94450: LD_INT 18
94452: DOUBLE
94453: EQUAL
94454: IFTRUE 94458
94456: GO 94469
94458: POP
// bc_type := b_ext_radar ; 19 :
94459: LD_ADDR_OWVAR 42
94463: PUSH
94464: LD_INT 20
94466: ST_TO_ADDR
94467: GO 94774
94469: LD_INT 19
94471: DOUBLE
94472: EQUAL
94473: IFTRUE 94477
94475: GO 94488
94477: POP
// bc_type := b_ext_radio ; 20 :
94478: LD_ADDR_OWVAR 42
94482: PUSH
94483: LD_INT 22
94485: ST_TO_ADDR
94486: GO 94774
94488: LD_INT 20
94490: DOUBLE
94491: EQUAL
94492: IFTRUE 94496
94494: GO 94507
94496: POP
// bc_type := b_ext_siberium ; 21 :
94497: LD_ADDR_OWVAR 42
94501: PUSH
94502: LD_INT 21
94504: ST_TO_ADDR
94505: GO 94774
94507: LD_INT 21
94509: DOUBLE
94510: EQUAL
94511: IFTRUE 94515
94513: GO 94526
94515: POP
// bc_type := b_ext_computer ; 22 :
94516: LD_ADDR_OWVAR 42
94520: PUSH
94521: LD_INT 24
94523: ST_TO_ADDR
94524: GO 94774
94526: LD_INT 22
94528: DOUBLE
94529: EQUAL
94530: IFTRUE 94534
94532: GO 94545
94534: POP
// bc_type := b_ext_track ; 23 :
94535: LD_ADDR_OWVAR 42
94539: PUSH
94540: LD_INT 16
94542: ST_TO_ADDR
94543: GO 94774
94545: LD_INT 23
94547: DOUBLE
94548: EQUAL
94549: IFTRUE 94553
94551: GO 94564
94553: POP
// bc_type := b_ext_laser ; 24 :
94554: LD_ADDR_OWVAR 42
94558: PUSH
94559: LD_INT 25
94561: ST_TO_ADDR
94562: GO 94774
94564: LD_INT 24
94566: DOUBLE
94567: EQUAL
94568: IFTRUE 94572
94570: GO 94583
94572: POP
// bc_type := b_control_tower ; 25 :
94573: LD_ADDR_OWVAR 42
94577: PUSH
94578: LD_INT 36
94580: ST_TO_ADDR
94581: GO 94774
94583: LD_INT 25
94585: DOUBLE
94586: EQUAL
94587: IFTRUE 94591
94589: GO 94602
94591: POP
// bc_type := b_breastwork ; 26 :
94592: LD_ADDR_OWVAR 42
94596: PUSH
94597: LD_INT 31
94599: ST_TO_ADDR
94600: GO 94774
94602: LD_INT 26
94604: DOUBLE
94605: EQUAL
94606: IFTRUE 94610
94608: GO 94621
94610: POP
// bc_type := b_bunker ; 27 :
94611: LD_ADDR_OWVAR 42
94615: PUSH
94616: LD_INT 32
94618: ST_TO_ADDR
94619: GO 94774
94621: LD_INT 27
94623: DOUBLE
94624: EQUAL
94625: IFTRUE 94629
94627: GO 94640
94629: POP
// bc_type := b_turret ; 28 :
94630: LD_ADDR_OWVAR 42
94634: PUSH
94635: LD_INT 33
94637: ST_TO_ADDR
94638: GO 94774
94640: LD_INT 28
94642: DOUBLE
94643: EQUAL
94644: IFTRUE 94648
94646: GO 94659
94648: POP
// bc_type := b_armoury ; 29 :
94649: LD_ADDR_OWVAR 42
94653: PUSH
94654: LD_INT 4
94656: ST_TO_ADDR
94657: GO 94774
94659: LD_INT 29
94661: DOUBLE
94662: EQUAL
94663: IFTRUE 94667
94665: GO 94678
94667: POP
// bc_type := b_barracks ; 30 :
94668: LD_ADDR_OWVAR 42
94672: PUSH
94673: LD_INT 5
94675: ST_TO_ADDR
94676: GO 94774
94678: LD_INT 30
94680: DOUBLE
94681: EQUAL
94682: IFTRUE 94686
94684: GO 94697
94686: POP
// bc_type := b_solar_power ; 31 :
94687: LD_ADDR_OWVAR 42
94691: PUSH
94692: LD_INT 27
94694: ST_TO_ADDR
94695: GO 94774
94697: LD_INT 31
94699: DOUBLE
94700: EQUAL
94701: IFTRUE 94705
94703: GO 94716
94705: POP
// bc_type := b_oil_power ; 32 :
94706: LD_ADDR_OWVAR 42
94710: PUSH
94711: LD_INT 26
94713: ST_TO_ADDR
94714: GO 94774
94716: LD_INT 32
94718: DOUBLE
94719: EQUAL
94720: IFTRUE 94724
94722: GO 94735
94724: POP
// bc_type := b_siberite_power ; 33 :
94725: LD_ADDR_OWVAR 42
94729: PUSH
94730: LD_INT 28
94732: ST_TO_ADDR
94733: GO 94774
94735: LD_INT 33
94737: DOUBLE
94738: EQUAL
94739: IFTRUE 94743
94741: GO 94754
94743: POP
// bc_type := b_oil_mine ; 34 :
94744: LD_ADDR_OWVAR 42
94748: PUSH
94749: LD_INT 29
94751: ST_TO_ADDR
94752: GO 94774
94754: LD_INT 34
94756: DOUBLE
94757: EQUAL
94758: IFTRUE 94762
94760: GO 94773
94762: POP
// bc_type := b_siberite_mine ; end ;
94763: LD_ADDR_OWVAR 42
94767: PUSH
94768: LD_INT 30
94770: ST_TO_ADDR
94771: GO 94774
94773: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
94774: LD_ADDR_VAR 0 8
94778: PUSH
94779: LD_VAR 0 5
94783: PPUSH
94784: LD_VAR 0 6
94788: PPUSH
94789: LD_VAR 0 3
94793: PPUSH
94794: CALL_OW 47
94798: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
94799: LD_OWVAR 42
94803: PUSH
94804: LD_INT 32
94806: PUSH
94807: LD_INT 33
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: IN
94814: IFFALSE 94830
// PlaceWeaponTurret ( b , weapon ) ;
94816: LD_VAR 0 8
94820: PPUSH
94821: LD_VAR 0 4
94825: PPUSH
94826: CALL_OW 431
// end ;
94830: LD_VAR 0 7
94834: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
94835: LD_INT 0
94837: PPUSH
94838: PPUSH
94839: PPUSH
94840: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94841: LD_ADDR_VAR 0 4
94845: PUSH
94846: LD_INT 22
94848: PUSH
94849: LD_OWVAR 2
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 2
94860: PUSH
94861: LD_INT 30
94863: PUSH
94864: LD_INT 0
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 30
94873: PUSH
94874: LD_INT 1
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PPUSH
94890: CALL_OW 69
94894: ST_TO_ADDR
// if not tmp then
94895: LD_VAR 0 4
94899: NOT
94900: IFFALSE 94904
// exit ;
94902: GO 94963
// for i in tmp do
94904: LD_ADDR_VAR 0 2
94908: PUSH
94909: LD_VAR 0 4
94913: PUSH
94914: FOR_IN
94915: IFFALSE 94961
// for j = 1 to 3 do
94917: LD_ADDR_VAR 0 3
94921: PUSH
94922: DOUBLE
94923: LD_INT 1
94925: DEC
94926: ST_TO_ADDR
94927: LD_INT 3
94929: PUSH
94930: FOR_TO
94931: IFFALSE 94957
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
94933: LD_VAR 0 2
94937: PPUSH
94938: CALL_OW 274
94942: PPUSH
94943: LD_VAR 0 3
94947: PPUSH
94948: LD_INT 99999
94950: PPUSH
94951: CALL_OW 277
94955: GO 94930
94957: POP
94958: POP
94959: GO 94914
94961: POP
94962: POP
// end ;
94963: LD_VAR 0 1
94967: RET
// export function hHackSetLevel10 ; var i , j ; begin
94968: LD_INT 0
94970: PPUSH
94971: PPUSH
94972: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94973: LD_ADDR_VAR 0 2
94977: PUSH
94978: LD_INT 21
94980: PUSH
94981: LD_INT 1
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PPUSH
94988: CALL_OW 69
94992: PUSH
94993: FOR_IN
94994: IFFALSE 95046
// if IsSelected ( i ) then
94996: LD_VAR 0 2
95000: PPUSH
95001: CALL_OW 306
95005: IFFALSE 95044
// begin for j := 1 to 4 do
95007: LD_ADDR_VAR 0 3
95011: PUSH
95012: DOUBLE
95013: LD_INT 1
95015: DEC
95016: ST_TO_ADDR
95017: LD_INT 4
95019: PUSH
95020: FOR_TO
95021: IFFALSE 95042
// SetSkill ( i , j , 10 ) ;
95023: LD_VAR 0 2
95027: PPUSH
95028: LD_VAR 0 3
95032: PPUSH
95033: LD_INT 10
95035: PPUSH
95036: CALL_OW 237
95040: GO 95020
95042: POP
95043: POP
// end ;
95044: GO 94993
95046: POP
95047: POP
// end ;
95048: LD_VAR 0 1
95052: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95053: LD_INT 0
95055: PPUSH
95056: PPUSH
95057: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95058: LD_ADDR_VAR 0 2
95062: PUSH
95063: LD_INT 22
95065: PUSH
95066: LD_OWVAR 2
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 21
95077: PUSH
95078: LD_INT 1
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PPUSH
95089: CALL_OW 69
95093: PUSH
95094: FOR_IN
95095: IFFALSE 95136
// begin for j := 1 to 4 do
95097: LD_ADDR_VAR 0 3
95101: PUSH
95102: DOUBLE
95103: LD_INT 1
95105: DEC
95106: ST_TO_ADDR
95107: LD_INT 4
95109: PUSH
95110: FOR_TO
95111: IFFALSE 95132
// SetSkill ( i , j , 10 ) ;
95113: LD_VAR 0 2
95117: PPUSH
95118: LD_VAR 0 3
95122: PPUSH
95123: LD_INT 10
95125: PPUSH
95126: CALL_OW 237
95130: GO 95110
95132: POP
95133: POP
// end ;
95134: GO 95094
95136: POP
95137: POP
// end ;
95138: LD_VAR 0 1
95142: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
95143: LD_INT 0
95145: PPUSH
// uc_side := your_side ;
95146: LD_ADDR_OWVAR 20
95150: PUSH
95151: LD_OWVAR 2
95155: ST_TO_ADDR
// uc_nation := nation ;
95156: LD_ADDR_OWVAR 21
95160: PUSH
95161: LD_VAR 0 1
95165: ST_TO_ADDR
// InitHc ;
95166: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
95170: LD_INT 0
95172: PPUSH
95173: LD_VAR 0 2
95177: PPUSH
95178: LD_VAR 0 3
95182: PPUSH
95183: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
95187: LD_VAR 0 4
95191: PPUSH
95192: LD_VAR 0 5
95196: PPUSH
95197: CALL_OW 428
95201: PUSH
95202: LD_INT 0
95204: EQUAL
95205: IFFALSE 95229
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
95207: CALL_OW 44
95211: PPUSH
95212: LD_VAR 0 4
95216: PPUSH
95217: LD_VAR 0 5
95221: PPUSH
95222: LD_INT 1
95224: PPUSH
95225: CALL_OW 48
// end ;
95229: LD_VAR 0 6
95233: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
95234: LD_INT 0
95236: PPUSH
95237: PPUSH
// uc_side := your_side ;
95238: LD_ADDR_OWVAR 20
95242: PUSH
95243: LD_OWVAR 2
95247: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
95248: LD_VAR 0 1
95252: PUSH
95253: LD_INT 1
95255: PUSH
95256: LD_INT 2
95258: PUSH
95259: LD_INT 3
95261: PUSH
95262: LD_INT 4
95264: PUSH
95265: LD_INT 5
95267: PUSH
95268: EMPTY
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: IN
95275: IFFALSE 95287
// uc_nation := nation_american else
95277: LD_ADDR_OWVAR 21
95281: PUSH
95282: LD_INT 1
95284: ST_TO_ADDR
95285: GO 95330
// if chassis in [ 11 , 12 , 13 , 14 ] then
95287: LD_VAR 0 1
95291: PUSH
95292: LD_INT 11
95294: PUSH
95295: LD_INT 12
95297: PUSH
95298: LD_INT 13
95300: PUSH
95301: LD_INT 14
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: IN
95310: IFFALSE 95322
// uc_nation := nation_arabian else
95312: LD_ADDR_OWVAR 21
95316: PUSH
95317: LD_INT 2
95319: ST_TO_ADDR
95320: GO 95330
// uc_nation := nation_russian ;
95322: LD_ADDR_OWVAR 21
95326: PUSH
95327: LD_INT 3
95329: ST_TO_ADDR
// vc_chassis := chassis ;
95330: LD_ADDR_OWVAR 37
95334: PUSH
95335: LD_VAR 0 1
95339: ST_TO_ADDR
// vc_engine := engine ;
95340: LD_ADDR_OWVAR 39
95344: PUSH
95345: LD_VAR 0 2
95349: ST_TO_ADDR
// vc_control := control ;
95350: LD_ADDR_OWVAR 38
95354: PUSH
95355: LD_VAR 0 3
95359: ST_TO_ADDR
// vc_weapon := weapon ;
95360: LD_ADDR_OWVAR 40
95364: PUSH
95365: LD_VAR 0 4
95369: ST_TO_ADDR
// un := CreateVehicle ;
95370: LD_ADDR_VAR 0 8
95374: PUSH
95375: CALL_OW 45
95379: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
95380: LD_VAR 0 8
95384: PPUSH
95385: LD_INT 0
95387: PPUSH
95388: LD_INT 5
95390: PPUSH
95391: CALL_OW 12
95395: PPUSH
95396: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
95400: LD_VAR 0 8
95404: PPUSH
95405: LD_VAR 0 5
95409: PPUSH
95410: LD_VAR 0 6
95414: PPUSH
95415: LD_INT 1
95417: PPUSH
95418: CALL_OW 48
// end ;
95422: LD_VAR 0 7
95426: RET
// export hInvincible ; every 1 do
95427: GO 95429
95429: DISABLE
// hInvincible := [ ] ;
95430: LD_ADDR_EXP 137
95434: PUSH
95435: EMPTY
95436: ST_TO_ADDR
95437: END
// every 10 do var i ;
95438: GO 95440
95440: DISABLE
95441: LD_INT 0
95443: PPUSH
// begin enable ;
95444: ENABLE
// if not hInvincible then
95445: LD_EXP 137
95449: NOT
95450: IFFALSE 95454
// exit ;
95452: GO 95498
// for i in hInvincible do
95454: LD_ADDR_VAR 0 1
95458: PUSH
95459: LD_EXP 137
95463: PUSH
95464: FOR_IN
95465: IFFALSE 95496
// if GetLives ( i ) < 1000 then
95467: LD_VAR 0 1
95471: PPUSH
95472: CALL_OW 256
95476: PUSH
95477: LD_INT 1000
95479: LESS
95480: IFFALSE 95494
// SetLives ( i , 1000 ) ;
95482: LD_VAR 0 1
95486: PPUSH
95487: LD_INT 1000
95489: PPUSH
95490: CALL_OW 234
95494: GO 95464
95496: POP
95497: POP
// end ;
95498: PPOPN 1
95500: END
// export function hHackInvincible ; var i ; begin
95501: LD_INT 0
95503: PPUSH
95504: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95505: LD_ADDR_VAR 0 2
95509: PUSH
95510: LD_INT 2
95512: PUSH
95513: LD_INT 21
95515: PUSH
95516: LD_INT 1
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 21
95525: PUSH
95526: LD_INT 2
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: LIST
95537: PPUSH
95538: CALL_OW 69
95542: PUSH
95543: FOR_IN
95544: IFFALSE 95605
// if IsSelected ( i ) then
95546: LD_VAR 0 2
95550: PPUSH
95551: CALL_OW 306
95555: IFFALSE 95603
// begin if i in hInvincible then
95557: LD_VAR 0 2
95561: PUSH
95562: LD_EXP 137
95566: IN
95567: IFFALSE 95587
// hInvincible := hInvincible diff i else
95569: LD_ADDR_EXP 137
95573: PUSH
95574: LD_EXP 137
95578: PUSH
95579: LD_VAR 0 2
95583: DIFF
95584: ST_TO_ADDR
95585: GO 95603
// hInvincible := hInvincible union i ;
95587: LD_ADDR_EXP 137
95591: PUSH
95592: LD_EXP 137
95596: PUSH
95597: LD_VAR 0 2
95601: UNION
95602: ST_TO_ADDR
// end ;
95603: GO 95543
95605: POP
95606: POP
// end ;
95607: LD_VAR 0 1
95611: RET
// export function hHackInvisible ; var i , j ; begin
95612: LD_INT 0
95614: PPUSH
95615: PPUSH
95616: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95617: LD_ADDR_VAR 0 2
95621: PUSH
95622: LD_INT 21
95624: PUSH
95625: LD_INT 1
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PPUSH
95632: CALL_OW 69
95636: PUSH
95637: FOR_IN
95638: IFFALSE 95662
// if IsSelected ( i ) then
95640: LD_VAR 0 2
95644: PPUSH
95645: CALL_OW 306
95649: IFFALSE 95660
// ComForceInvisible ( i ) ;
95651: LD_VAR 0 2
95655: PPUSH
95656: CALL_OW 496
95660: GO 95637
95662: POP
95663: POP
// end ;
95664: LD_VAR 0 1
95668: RET
// export function hHackChangeYourSide ; begin
95669: LD_INT 0
95671: PPUSH
// if your_side = 8 then
95672: LD_OWVAR 2
95676: PUSH
95677: LD_INT 8
95679: EQUAL
95680: IFFALSE 95692
// your_side := 0 else
95682: LD_ADDR_OWVAR 2
95686: PUSH
95687: LD_INT 0
95689: ST_TO_ADDR
95690: GO 95706
// your_side := your_side + 1 ;
95692: LD_ADDR_OWVAR 2
95696: PUSH
95697: LD_OWVAR 2
95701: PUSH
95702: LD_INT 1
95704: PLUS
95705: ST_TO_ADDR
// end ;
95706: LD_VAR 0 1
95710: RET
// export function hHackChangeUnitSide ; var i , j ; begin
95711: LD_INT 0
95713: PPUSH
95714: PPUSH
95715: PPUSH
// for i in all_units do
95716: LD_ADDR_VAR 0 2
95720: PUSH
95721: LD_OWVAR 3
95725: PUSH
95726: FOR_IN
95727: IFFALSE 95805
// if IsSelected ( i ) then
95729: LD_VAR 0 2
95733: PPUSH
95734: CALL_OW 306
95738: IFFALSE 95803
// begin j := GetSide ( i ) ;
95740: LD_ADDR_VAR 0 3
95744: PUSH
95745: LD_VAR 0 2
95749: PPUSH
95750: CALL_OW 255
95754: ST_TO_ADDR
// if j = 8 then
95755: LD_VAR 0 3
95759: PUSH
95760: LD_INT 8
95762: EQUAL
95763: IFFALSE 95775
// j := 0 else
95765: LD_ADDR_VAR 0 3
95769: PUSH
95770: LD_INT 0
95772: ST_TO_ADDR
95773: GO 95789
// j := j + 1 ;
95775: LD_ADDR_VAR 0 3
95779: PUSH
95780: LD_VAR 0 3
95784: PUSH
95785: LD_INT 1
95787: PLUS
95788: ST_TO_ADDR
// SetSide ( i , j ) ;
95789: LD_VAR 0 2
95793: PPUSH
95794: LD_VAR 0 3
95798: PPUSH
95799: CALL_OW 235
// end ;
95803: GO 95726
95805: POP
95806: POP
// end ;
95807: LD_VAR 0 1
95811: RET
// export function hHackFog ; begin
95812: LD_INT 0
95814: PPUSH
// FogOff ( true ) ;
95815: LD_INT 1
95817: PPUSH
95818: CALL_OW 344
// end ;
95822: LD_VAR 0 1
95826: RET
// export function hHackTeleport ( unit , x , y ) ; begin
95827: LD_INT 0
95829: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
95830: LD_VAR 0 1
95834: PPUSH
95835: LD_VAR 0 2
95839: PPUSH
95840: LD_VAR 0 3
95844: PPUSH
95845: LD_INT 1
95847: PPUSH
95848: LD_INT 1
95850: PPUSH
95851: CALL_OW 483
// CenterOnXY ( x , y ) ;
95855: LD_VAR 0 2
95859: PPUSH
95860: LD_VAR 0 3
95864: PPUSH
95865: CALL_OW 84
// end ;
95869: LD_VAR 0 4
95873: RET
