// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 81688 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 44390 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 44390 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 44390 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 44390 0 9
// PrepareGensher ;
 189: CALL 3160 0 0
// PreparePopov ;
 193: CALL 6371 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 9059 0 0
// MC_Start ( ) ;
 205: CALL 53227 0 0
// Action ;
 209: CALL 9466 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4294 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7529 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19337 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 76555 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 76499 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 75558 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 76387 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 76069 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 75800 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 75419 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 75234 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 76181 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 75282 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 76700 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9597 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9862 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 45282 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 45282 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ;
3014: PPOPN 3
3016: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3017: LD_INT 22
3019: PUSH
3020: LD_INT 4
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 33
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 50
3039: PUSH
3040: EMPTY
3041: LIST
3042: PUSH
3043: LD_INT 3
3045: PUSH
3046: LD_INT 61
3048: PUSH
3049: EMPTY
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3157
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 33
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: EMPTY
3105: LIST
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: LD_INT 61
3112: PUSH
3113: EMPTY
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 69
3130: ST_TO_ADDR
// for i in tmp do
3131: LD_ADDR_VAR 0 1
3135: PUSH
3136: LD_VAR 0 2
3140: PUSH
3141: FOR_IN
3142: IFFALSE 3155
// Connect ( i ) ;
3144: LD_VAR 0 1
3148: PPUSH
3149: CALL 18984 0 1
3153: GO 3141
3155: POP
3156: POP
// end ; end_of_file
3157: PPOPN 2
3159: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3160: LD_INT 0
3162: PPUSH
3163: PPUSH
3164: PPUSH
3165: PPUSH
3166: PPUSH
3167: PPUSH
// gensher_side := 2 ;
3168: LD_ADDR_EXP 14
3172: PUSH
3173: LD_INT 2
3175: ST_TO_ADDR
// uc_side := gensher_side ;
3176: LD_ADDR_OWVAR 20
3180: PUSH
3181: LD_EXP 14
3185: ST_TO_ADDR
// uc_nation := 2 ;
3186: LD_ADDR_OWVAR 21
3190: PUSH
3191: LD_INT 2
3193: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3194: LD_ADDR_VAR 0 6
3198: PUSH
3199: LD_INT 5
3201: PUSH
3202: LD_INT 42
3204: PUSH
3205: LD_INT 29
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 5
3219: PUSH
3220: LD_INT 36
3222: PUSH
3223: LD_INT 40
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 18
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: LD_INT 10
3249: PUSH
3250: LD_INT 15
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 27
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 29
3281: PUSH
3282: LD_INT 56
3284: PUSH
3285: LD_INT 23
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 7
3305: PUSH
3306: LD_INT 2
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 27
3317: PUSH
3318: LD_INT 20
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 27
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: LD_INT 0
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 27
3353: PUSH
3354: LD_INT 26
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: LD_INT 17
3374: PUSH
3375: LD_INT 27
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 13
3383: PUSH
3384: LD_INT 11
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 27
3400: PUSH
3401: LD_INT 44
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 41
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 27
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 45
3444: PUSH
3445: LD_INT 24
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: LD_INT 19
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 32
3485: PUSH
3486: LD_INT 41
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: LD_INT 28
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 5
3507: PUSH
3508: LD_INT 44
3510: PUSH
3511: LD_INT 9
3513: PUSH
3514: LD_INT 4
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 52
3528: PUSH
3529: LD_INT 40
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: ST_TO_ADDR
// for i in list do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: FOR_IN
3571: IFFALSE 3749
// begin uc_side := 2 ;
3573: LD_ADDR_OWVAR 20
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// uc_nation := 2 ;
3581: LD_ADDR_OWVAR 21
3585: PUSH
3586: LD_INT 2
3588: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3589: LD_ADDR_OWVAR 42
3593: PUSH
3594: LD_VAR 0 2
3598: PUSH
3599: LD_INT 1
3601: ARRAY
3602: ST_TO_ADDR
// bc_kind1 := - 1 ;
3603: LD_ADDR_OWVAR 44
3607: PUSH
3608: LD_INT 1
3610: NEG
3611: ST_TO_ADDR
// bc_kind2 := - 1 ;
3612: LD_ADDR_OWVAR 45
3616: PUSH
3617: LD_INT 1
3619: NEG
3620: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3621: LD_VAR 0 2
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: PUSH
3630: LD_INT 6
3632: EQUAL
3633: IFFALSE 3671
// begin bc_type := b_lab_full ;
3635: LD_ADDR_OWVAR 42
3639: PUSH
3640: LD_INT 8
3642: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3643: LD_ADDR_OWVAR 44
3647: PUSH
3648: LD_VAR 0 2
3652: PUSH
3653: LD_INT 5
3655: ARRAY
3656: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3657: LD_ADDR_OWVAR 45
3661: PUSH
3662: LD_VAR 0 2
3666: PUSH
3667: LD_INT 6
3669: ARRAY
3670: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3671: LD_ADDR_VAR 0 3
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_INT 2
3683: ARRAY
3684: PPUSH
3685: LD_VAR 0 2
3689: PUSH
3690: LD_INT 3
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 4
3701: ARRAY
3702: PPUSH
3703: CALL_OW 47
3707: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 1
3715: ARRAY
3716: PUSH
3717: LD_INT 33
3719: PUSH
3720: LD_INT 32
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: IN
3727: IFFALSE 3747
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_VAR 0 2
3738: PUSH
3739: LD_INT 5
3741: ARRAY
3742: PPUSH
3743: CALL_OW 431
// end ;
3747: GO 3570
3749: POP
3750: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3751: LD_ADDR_VAR 0 4
3755: PUSH
3756: LD_INT 7
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: LD_STRING 
3764: PPUSH
3765: LD_INT 8
3767: PUSH
3768: LD_INT 7
3770: PUSH
3771: LD_INT 6
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: LD_INT 11500
3787: PUSH
3788: LD_INT 1100
3790: PUSH
3791: LD_INT 60
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_INT 6
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 6
3807: PUSH
3808: LD_INT 6
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL 19337 0 6
3821: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3822: LD_ADDR_EXP 23
3826: PUSH
3827: LD_EXP 23
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 2
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: UNION
3869: PPUSH
3870: CALL_OW 1
3874: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_INT 22
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 30
3892: PUSH
3893: LD_INT 31
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PPUSH
3904: CALL_OW 69
3908: ST_TO_ADDR
// for i in tmp do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: LD_VAR 0 4
3918: PUSH
3919: FOR_IN
3920: IFFALSE 3990
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 4
3930: PUSH
3931: LD_INT 3
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: LD_OWVAR 67
3946: ARRAY
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 1
3969: PPUSH
3970: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3974: LD_VAR 0 5
3978: PPUSH
3979: LD_VAR 0 2
3983: PPUSH
3984: CALL_OW 52
// end ;
3988: GO 3919
3990: POP
3991: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: LD_INT 15
3999: PPUSH
4000: LD_INT 0
4002: PPUSH
4003: CALL_OW 517
4007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: DOUBLE
4014: LD_INT 1
4016: DEC
4017: ST_TO_ADDR
4018: LD_VAR 0 4
4022: PUSH
4023: LD_INT 1
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4130
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4030: LD_VAR 0 4
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PUSH
4039: LD_VAR 0 2
4043: ARRAY
4044: PPUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PUSH
4054: LD_VAR 0 2
4058: ARRAY
4059: PPUSH
4060: LD_INT 2
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4070: LD_ADDR_EXP 3
4074: PUSH
4075: LD_EXP 3
4079: PPUSH
4080: LD_EXP 3
4084: PUSH
4085: LD_INT 1
4087: PLUS
4088: PPUSH
4089: LD_VAR 0 4
4093: PUSH
4094: LD_INT 1
4096: ARRAY
4097: PUSH
4098: LD_VAR 0 2
4102: ARRAY
4103: PUSH
4104: LD_VAR 0 4
4108: PUSH
4109: LD_INT 2
4111: ARRAY
4112: PUSH
4113: LD_VAR 0 2
4117: ARRAY
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 2
4127: ST_TO_ADDR
// end ;
4128: GO 4027
4130: POP
4131: POP
// if Difficulty > 1 then
4132: LD_OWVAR 67
4136: PUSH
4137: LD_INT 1
4139: GREATER
4140: IFFALSE 4282
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4142: LD_ADDR_VAR 0 4
4146: PUSH
4147: LD_INT 19
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 517
4157: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: DOUBLE
4164: LD_INT 1
4166: DEC
4167: ST_TO_ADDR
4168: LD_VAR 0 4
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4280
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4180: LD_VAR 0 4
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: PPUSH
4195: LD_VAR 0 4
4199: PUSH
4200: LD_INT 2
4202: ARRAY
4203: PUSH
4204: LD_VAR 0 2
4208: ARRAY
4209: PPUSH
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4220: LD_ADDR_EXP 3
4224: PUSH
4225: LD_EXP 3
4229: PPUSH
4230: LD_EXP 3
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 4
4243: PUSH
4244: LD_INT 1
4246: ARRAY
4247: PUSH
4248: LD_VAR 0 2
4252: ARRAY
4253: PUSH
4254: LD_VAR 0 4
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PPUSH
4273: CALL_OW 2
4277: ST_TO_ADDR
// end ;
4278: GO 4177
4280: POP
4281: POP
// end ; gensherAttackGroup := [ ] ;
4282: LD_ADDR_EXP 15
4286: PUSH
4287: EMPTY
4288: ST_TO_ADDR
// end ;
4289: LD_VAR 0 1
4293: RET
// export function InitMC_Gensher ( ) ; begin
4294: LD_INT 0
4296: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4297: LD_INT 2
4299: PPUSH
4300: LD_INT 2
4302: PPUSH
4303: CALL 76555 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4307: LD_INT 2
4309: PPUSH
4310: LD_INT 9
4312: PPUSH
4313: CALL 76499 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4317: LD_INT 2
4319: PPUSH
4320: LD_INT 56
4322: PUSH
4323: LD_INT 23
4325: PUSH
4326: LD_INT 0
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 52
4336: PUSH
4337: LD_INT 40
4339: PUSH
4340: LD_INT 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PPUSH
4352: CALL 75558 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4356: LD_INT 2
4358: PPUSH
4359: LD_INT 27
4361: PUSH
4362: LD_INT 28
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PPUSH
4369: CALL 76387 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 8
4378: PPUSH
4379: CALL 76069 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 7
4388: PPUSH
4389: CALL 75800 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4393: LD_INT 2
4395: PPUSH
4396: LD_INT 4
4398: PPUSH
4399: CALL 75419 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4403: LD_INT 2
4405: PPUSH
4406: LD_INT 13
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: LD_INT 31
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 13
4426: PUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 1
4432: PUSH
4433: LD_INT 31
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 27
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 27
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 14
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: LD_INT 2
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 14
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 2
4504: PUSH
4505: LD_INT 26
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL 75234 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4526: LD_INT 2
4528: PPUSH
4529: LD_INT 11
4531: PPUSH
4532: LD_INT 7
4534: PPUSH
4535: LD_INT 2
4537: PPUSH
4538: LD_INT 23
4540: PUSH
4541: LD_INT 16
4543: PUSH
4544: LD_INT 17
4546: PUSH
4547: LD_INT 18
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PPUSH
4560: CALL 76181 0 5
// end ;
4564: LD_VAR 0 1
4568: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4569: LD_EXP 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: AND
4592: IFFALSE 4805
4594: GO 4596
4596: DISABLE
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
// begin enable ;
4604: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: LD_INT 15
4612: PPUSH
4613: LD_INT 81
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 70
4627: ST_TO_ADDR
// if not tmp then
4628: LD_VAR 0 3
4632: NOT
4633: IFFALSE 4637
// exit ;
4635: GO 4805
// for i in tmp do
4637: LD_ADDR_VAR 0 1
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4803
// begin x := GetX ( i ) ;
4650: LD_ADDR_VAR 0 4
4654: PUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: CALL_OW 250
4664: ST_TO_ADDR
// y := GetY ( i ) ;
4665: LD_ADDR_VAR 0 5
4669: PUSH
4670: LD_VAR 0 1
4674: PPUSH
4675: CALL_OW 251
4679: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4680: LD_VAR 0 4
4684: PPUSH
4685: LD_VAR 0 5
4689: PPUSH
4690: CALL_OW 458
4694: IFFALSE 4801
// begin LaunchMineAtPos ( x , y , 2 ) ;
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: LD_INT 2
4708: PPUSH
4709: CALL_OW 456
// for j = 1 to staticMines do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 3
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4799
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4731: LD_EXP 3
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PUSH
4746: LD_VAR 0 4
4750: EQUAL
4751: PUSH
4752: LD_EXP 3
4756: PUSH
4757: LD_VAR 0 2
4761: ARRAY
4762: PUSH
4763: LD_INT 2
4765: ARRAY
4766: PUSH
4767: LD_VAR 0 5
4771: EQUAL
4772: AND
4773: IFFALSE 4797
// begin staticMines := Delete ( staticMines , j ) ;
4775: LD_ADDR_EXP 3
4779: PUSH
4780: LD_EXP 3
4784: PPUSH
4785: LD_VAR 0 2
4789: PPUSH
4790: CALL_OW 3
4794: ST_TO_ADDR
// break ;
4795: GO 4799
// end ;
4797: GO 4728
4799: POP
4800: POP
// end ; end ;
4801: GO 4647
4803: POP
4804: POP
// end ;
4805: PPOPN 5
4807: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4808: LD_INT 7
4810: PPUSH
4811: CALL_OW 302
4815: PUSH
4816: LD_EXP 4
4820: NOT
4821: AND
4822: IFFALSE 5426
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
4832: PPUSH
4833: PPUSH
// begin enable ;
4834: ENABLE
// base := 2 ;
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 27
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 27
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_EXP 72
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 14
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 26
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 5
4937: PUSH
4938: LD_OWVAR 1
4942: PUSH
4943: LD_INT 21000
4945: DIV
4946: PLUS
4947: ST_TO_ADDR
// if amount > 8 then
4948: LD_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: GREATER
4956: IFFALSE 4966
// amount := 8 ;
4958: LD_ADDR_VAR 0 5
4962: PUSH
4963: LD_INT 8
4965: ST_TO_ADDR
// for i = 1 to amount do
4966: LD_ADDR_VAR 0 1
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_VAR 0 5
4980: PUSH
4981: FOR_TO
4982: IFFALSE 5070
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 1
5001: PLUS
5002: PPUSH
5003: LD_INT 14
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 2
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 28
5033: PUSH
5034: LD_INT 25
5036: PUSH
5037: LD_INT 27
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_INT 1
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL_OW 12
5055: ARRAY
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 2
5067: ST_TO_ADDR
5068: GO 4981
5070: POP
5071: POP
// MC_InsertProduceList ( base , tmp ) ;
5072: LD_VAR 0 2
5076: PPUSH
5077: LD_VAR 0 3
5081: PPUSH
5082: CALL 75282 0 2
// repeat wait ( 0 0$1 ) ;
5086: LD_INT 35
5088: PPUSH
5089: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5093: LD_VAR 0 2
5097: PPUSH
5098: LD_INT 1
5100: PPUSH
5101: CALL 76700 0 2
5105: PUSH
5106: LD_VAR 0 5
5110: GREATEREQUAL
5111: IFFALSE 5086
// wait ( 0 0$30 ) ;
5113: LD_INT 1050
5115: PPUSH
5116: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5120: LD_ADDR_VAR 0 4
5124: PUSH
5125: LD_EXP 42
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PUSH
5136: LD_EXP 42
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 2
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 31
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 32
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 34
5172: PUSH
5173: LD_EXP 73
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 72
5192: DIFF
5193: ST_TO_ADDR
// if not attackers then
5194: LD_VAR 0 4
5198: NOT
5199: IFFALSE 5203
// exit ;
5201: GO 5426
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5203: LD_ADDR_EXP 42
5207: PUSH
5208: LD_EXP 42
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_VAR 0 2
5227: ARRAY
5228: PUSH
5229: LD_VAR 0 4
5233: DIFF
5234: PPUSH
5235: CALL_OW 1
5239: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_INT 107
5247: PPUSH
5248: LD_INT 74
5250: PPUSH
5251: CALL_OW 114
// wait ( 0 0$5 ) ;
5255: LD_INT 175
5257: PPUSH
5258: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5262: LD_INT 35
5264: PPUSH
5265: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5269: LD_VAR 0 4
5273: PPUSH
5274: LD_INT 60
5276: PUSH
5277: EMPTY
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: NOT
5285: IFFALSE 5262
// if rand ( 0 , 1 ) then
5287: LD_INT 0
5289: PPUSH
5290: LD_INT 1
5292: PPUSH
5293: CALL_OW 12
5297: IFFALSE 5316
// ComAgressiveMove ( attackers , 155 , 108 ) else
5299: LD_VAR 0 4
5303: PPUSH
5304: LD_INT 155
5306: PPUSH
5307: LD_INT 108
5309: PPUSH
5310: CALL_OW 114
5314: GO 5331
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5316: LD_VAR 0 4
5320: PPUSH
5321: LD_INT 149
5323: PPUSH
5324: LD_INT 55
5326: PPUSH
5327: CALL_OW 114
// wait ( 0 0$10 ) ;
5331: LD_INT 350
5333: PPUSH
5334: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5338: LD_INT 35
5340: PPUSH
5341: CALL_OW 67
// for i in attackers do
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_VAR 0 4
5354: PUSH
5355: FOR_IN
5356: IFFALSE 5406
// if not HasTask ( i ) then
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 314
5367: NOT
5368: IFFALSE 5404
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5370: LD_VAR 0 1
5374: PPUSH
5375: LD_INT 81
5377: PUSH
5378: LD_INT 2
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: PPUSH
5390: LD_VAR 0 1
5394: PPUSH
5395: CALL_OW 74
5399: PPUSH
5400: CALL_OW 115
5404: GO 5355
5406: POP
5407: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5408: LD_VAR 0 4
5412: PPUSH
5413: LD_INT 50
5415: PUSH
5416: EMPTY
5417: LIST
5418: PPUSH
5419: CALL_OW 72
5423: NOT
5424: IFFALSE 5338
// end ;
5426: PPOPN 5
5428: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5429: LD_EXP 4
5433: NOT
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 191100
5442: LESS
5443: AND
5444: IFFALSE 6116
5446: GO 5448
5448: DISABLE
5449: LD_INT 0
5451: PPUSH
5452: PPUSH
5453: PPUSH
// begin enable ;
5454: ENABLE
// tmp := [ ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: EMPTY
5461: ST_TO_ADDR
// if tick < 35 35$00 then
5462: LD_OWVAR 1
5466: PUSH
5467: LD_INT 73500
5469: LESS
5470: IFFALSE 5668
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: DOUBLE
5478: LD_INT 1
5480: DEC
5481: ST_TO_ADDR
5482: LD_INT 4
5484: PUSH
5485: LD_INT 5
5487: PUSH
5488: LD_INT 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5664
// begin uc_side := 2 ;
5505: LD_ADDR_OWVAR 20
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// uc_nation := 2 ;
5513: LD_ADDR_OWVAR 21
5517: PUSH
5518: LD_INT 2
5520: ST_TO_ADDR
// InitHC_All ( ) ;
5521: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: LD_INT 5
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 7
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PUSH
5545: LD_OWVAR 67
5549: ARRAY
5550: PPUSH
5551: CALL_OW 380
// un := CreateHuman ;
5555: LD_ADDR_VAR 0 2
5559: PUSH
5560: CALL_OW 44
5564: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: LD_INT 17
5572: PPUSH
5573: LD_INT 0
5575: PPUSH
5576: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_INT 2
5600: PPUSH
5601: CALL_OW 12
5605: ARRAY
5606: PPUSH
5607: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 111
5618: PPUSH
5619: LD_INT 34
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5502
5664: POP
5665: POP
// end else
5666: GO 5809
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5668: LD_ADDR_VAR 0 1
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 4
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_OWVAR 67
5696: ARRAY
5697: PUSH
5698: FOR_TO
5699: IFFALSE 5807
// begin uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 0 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 0
5716: ST_TO_ADDR
// InitHC_All ( ) ;
5717: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5721: LD_ADDR_OWVAR 28
5725: PUSH
5726: LD_INT 17
5728: ST_TO_ADDR
// un := CreateHuman ;
5729: LD_ADDR_VAR 0 2
5733: PUSH
5734: CALL_OW 44
5738: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: LD_INT 17
5746: PPUSH
5747: LD_INT 0
5749: PPUSH
5750: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5754: LD_VAR 0 2
5758: PPUSH
5759: LD_INT 110
5761: PPUSH
5762: LD_INT 33
5764: PPUSH
5765: CALL_OW 114
// wait ( 0 0$2 ) ;
5769: LD_INT 70
5771: PPUSH
5772: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5776: LD_ADDR_VAR 0 3
5780: PUSH
5781: LD_VAR 0 3
5785: PPUSH
5786: LD_VAR 0 3
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PPUSH
5795: LD_VAR 0 2
5799: PPUSH
5800: CALL_OW 1
5804: ST_TO_ADDR
// end ;
5805: GO 5698
5807: POP
5808: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5809: LD_ADDR_VAR 0 1
5813: PUSH
5814: DOUBLE
5815: LD_INT 1
5817: DEC
5818: ST_TO_ADDR
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: LD_INT 5
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_OWVAR 67
5837: ARRAY
5838: PUSH
5839: FOR_TO
5840: IFFALSE 6005
// begin uc_side := 2 ;
5842: LD_ADDR_OWVAR 20
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// uc_nation := 2 ;
5850: LD_ADDR_OWVAR 21
5854: PUSH
5855: LD_INT 2
5857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5858: LD_INT 14
5860: PPUSH
5861: LD_INT 3
5863: PPUSH
5864: LD_INT 5
5866: PPUSH
5867: LD_INT 29
5869: PUSH
5870: LD_INT 28
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 12
5891: ARRAY
5892: PPUSH
5893: LD_INT 90
5895: PPUSH
5896: CALL 15891 0 5
// un := CreateVehicle ;
5900: LD_ADDR_VAR 0 2
5904: PUSH
5905: CALL_OW 45
5909: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5922: LD_VAR 0 2
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_INT 0
5932: PPUSH
5933: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_INT 66
5944: PPUSH
5945: LD_INT 23
5947: PPUSH
5948: CALL_OW 111
// wait ( 0 0$3 ) ;
5952: LD_INT 105
5954: PPUSH
5955: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 147
5966: PPUSH
5967: LD_INT 103
5969: PPUSH
5970: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5974: LD_ADDR_VAR 0 3
5978: PUSH
5979: LD_VAR 0 3
5983: PPUSH
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 1
6002: ST_TO_ADDR
// end ;
6003: GO 5839
6005: POP
6006: POP
// if not tmp then
6007: LD_VAR 0 3
6011: NOT
6012: IFFALSE 6016
// exit ;
6014: GO 6116
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6023: LD_INT 70
6025: PPUSH
6026: CALL_OW 67
// for i in tmp do
6030: LD_ADDR_VAR 0 1
6034: PUSH
6035: LD_VAR 0 3
6039: PUSH
6040: FOR_IN
6041: IFFALSE 6107
// begin if not IsOk ( i ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: CALL_OW 302
6052: NOT
6053: IFFALSE 6071
// tmp := tmp diff i ;
6055: LD_ADDR_VAR 0 3
6059: PUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_VAR 0 1
6069: DIFF
6070: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6071: LD_VAR 0 1
6075: PPUSH
6076: LD_INT 81
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 69
6090: PPUSH
6091: LD_VAR 0 1
6095: PPUSH
6096: CALL_OW 74
6100: PPUSH
6101: CALL_OW 115
// end ;
6105: GO 6040
6107: POP
6108: POP
// until not tmp ;
6109: LD_VAR 0 3
6113: NOT
6114: IFFALSE 6023
// end ;
6116: PPOPN 3
6118: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6119: LD_OWVAR 67
6123: PUSH
6124: LD_INT 1
6126: GREATER
6127: IFFALSE 6225
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
// begin uc_side := 2 ;
6135: LD_ADDR_OWVAR 20
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// uc_nation := 2 ;
6143: LD_ADDR_OWVAR 21
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6151: LD_INT 0
6153: PPUSH
6154: LD_INT 4
6156: PPUSH
6157: LD_INT 6
6159: PPUSH
6160: CALL_OW 380
// un := CreateHuman ;
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: CALL_OW 44
6173: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 88
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 0
6190: PPUSH
6191: CALL 49840 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 130
6202: PPUSH
6203: LD_INT 35
6205: PPUSH
6206: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6210: LD_VAR 0 1
6214: PPUSH
6215: LD_INT 132
6217: PPUSH
6218: LD_INT 39
6220: PPUSH
6221: CALL_OW 218
// end ;
6225: PPOPN 1
6227: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6228: LD_INT 22
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 33
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 50
6250: PUSH
6251: EMPTY
6252: LIST
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 61
6259: PUSH
6260: EMPTY
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 69
6277: IFFALSE 6368
6279: GO 6281
6281: DISABLE
6282: LD_INT 0
6284: PPUSH
6285: PPUSH
// begin enable ;
6286: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_INT 2
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 33
6304: PUSH
6305: LD_INT 2
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: LD_INT 50
6314: PUSH
6315: EMPTY
6316: LIST
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: LD_INT 61
6323: PUSH
6324: EMPTY
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PPUSH
6337: CALL_OW 69
6341: ST_TO_ADDR
// for i in tmp do
6342: LD_ADDR_VAR 0 1
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6366
// Connect ( i ) ;
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL 18984 0 1
6364: GO 6352
6366: POP
6367: POP
// end ; end_of_file
6368: PPOPN 2
6370: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
6376: PPUSH
6377: PPUSH
6378: PPUSH
// popov_side := 3 ;
6379: LD_ADDR_EXP 17
6383: PUSH
6384: LD_INT 3
6386: ST_TO_ADDR
// uc_side := popov_side ;
6387: LD_ADDR_OWVAR 20
6391: PUSH
6392: LD_EXP 17
6396: ST_TO_ADDR
// uc_nation := 3 ;
6397: LD_ADDR_OWVAR 21
6401: PUSH
6402: LD_INT 3
6404: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6405: LD_ADDR_VAR 0 6
6409: PUSH
6410: LD_INT 5
6412: PUSH
6413: LD_INT 103
6415: PUSH
6416: LD_INT 147
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 70
6433: PUSH
6434: LD_INT 117
6436: PUSH
6437: LD_INT 3
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: LD_INT 76
6451: PUSH
6452: LD_INT 145
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 10
6460: PUSH
6461: LD_INT 11
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 26
6474: PUSH
6475: LD_INT 87
6477: PUSH
6478: LD_INT 144
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 29
6492: PUSH
6493: LD_INT 86
6495: PUSH
6496: LD_INT 118
6498: PUSH
6499: LD_INT 0
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 29
6510: PUSH
6511: LD_INT 98
6513: PUSH
6514: LD_INT 121
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: LD_INT 87
6531: PUSH
6532: LD_INT 147
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 30
6546: PUSH
6547: LD_INT 123
6549: PUSH
6550: LD_INT 151
6552: PUSH
6553: LD_INT 1
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 94
6567: PUSH
6568: LD_INT 161
6570: PUSH
6571: LD_INT 0
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: LD_INT 81
6585: PUSH
6586: LD_INT 155
6588: PUSH
6589: LD_INT 1
6591: PUSH
6592: LD_INT 12
6594: PUSH
6595: LD_INT 14
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 26
6608: PUSH
6609: LD_INT 96
6611: PUSH
6612: LD_INT 152
6614: PUSH
6615: LD_INT 0
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 26
6626: PUSH
6627: LD_INT 96
6629: PUSH
6630: LD_INT 149
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 32
6644: PUSH
6645: LD_INT 109
6647: PUSH
6648: LD_INT 142
6650: PUSH
6651: LD_INT 3
6653: PUSH
6654: LD_INT 46
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 32
6666: PUSH
6667: LD_INT 112
6669: PUSH
6670: LD_INT 148
6672: PUSH
6673: LD_INT 3
6675: PUSH
6676: LD_INT 46
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 33
6688: PUSH
6689: LD_INT 120
6691: PUSH
6692: LD_INT 159
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: LD_INT 45
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 33
6710: PUSH
6711: LD_INT 122
6713: PUSH
6714: LD_INT 163
6716: PUSH
6717: LD_INT 4
6719: PUSH
6720: LD_INT 45
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 33
6732: PUSH
6733: LD_INT 123
6735: PUSH
6736: LD_INT 167
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: LD_INT 45
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 59
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 65
6779: PUSH
6780: LD_INT 111
6782: PUSH
6783: LD_INT 3
6785: PUSH
6786: LD_INT 46
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 76
6801: PUSH
6802: LD_INT 117
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 80
6823: PUSH
6824: LD_INT 119
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 46
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 87
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 45
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 92
6867: PUSH
6868: LD_INT 129
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 28
6882: PUSH
6883: LD_INT 85
6885: PUSH
6886: LD_INT 165
6888: PUSH
6889: LD_INT 0
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 28
6900: PUSH
6901: LD_INT 83
6903: PUSH
6904: LD_INT 161
6906: PUSH
6907: LD_INT 4
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: PUSH
6916: LD_INT 28
6918: PUSH
6919: LD_INT 91
6921: PUSH
6922: LD_INT 166
6924: PUSH
6925: LD_INT 3
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_INT 28
6936: PUSH
6937: LD_INT 102
6939: PUSH
6940: LD_INT 166
6942: PUSH
6943: LD_INT 2
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: ST_TO_ADDR
// for i in list do
6981: LD_ADDR_VAR 0 2
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7170
// begin uc_side := 3 ;
6994: LD_ADDR_OWVAR 20
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// uc_nation := 3 ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 3
7009: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7010: LD_ADDR_OWVAR 42
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind1 := - 1 ;
7024: LD_ADDR_OWVAR 44
7028: PUSH
7029: LD_INT 1
7031: NEG
7032: ST_TO_ADDR
// bc_kind2 := - 1 ;
7033: LD_ADDR_OWVAR 45
7037: PUSH
7038: LD_INT 1
7040: NEG
7041: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7042: LD_VAR 0 2
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PUSH
7051: LD_INT 6
7053: EQUAL
7054: IFFALSE 7092
// begin bc_type := b_lab_full ;
7056: LD_ADDR_OWVAR 42
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7064: LD_ADDR_OWVAR 44
7068: PUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_INT 5
7076: ARRAY
7077: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7078: LD_ADDR_OWVAR 45
7082: PUSH
7083: LD_VAR 0 2
7087: PUSH
7088: LD_INT 6
7090: ARRAY
7091: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7092: LD_ADDR_VAR 0 5
7096: PUSH
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: LD_VAR 0 2
7110: PUSH
7111: LD_INT 3
7113: ARRAY
7114: PPUSH
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: PPUSH
7124: CALL_OW 47
7128: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7129: LD_VAR 0 2
7133: PUSH
7134: LD_INT 1
7136: ARRAY
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 32
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: IN
7148: IFFALSE 7168
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7150: LD_VAR 0 5
7154: PPUSH
7155: LD_VAR 0 2
7159: PUSH
7160: LD_INT 5
7162: ARRAY
7163: PPUSH
7164: CALL_OW 431
// end ;
7168: GO 6991
7170: POP
7171: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 9
7179: PPUSH
7180: LD_INT 3
7182: PPUSH
7183: LD_STRING 
7185: PPUSH
7186: LD_INT 8
7188: PUSH
7189: LD_INT 7
7191: PUSH
7192: LD_INT 6
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PPUSH
7206: LD_INT 11500
7208: PUSH
7209: LD_INT 1100
7211: PUSH
7212: LD_INT 60
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: LD_INT 6
7222: PUSH
7223: LD_INT 6
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 6
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PPUSH
7238: CALL 19337 0 6
7242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7243: LD_ADDR_EXP 23
7247: PUSH
7248: LD_EXP 23
7252: PPUSH
7253: LD_INT 3
7255: PPUSH
7256: LD_VAR 0 4
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: UNION
7290: PPUSH
7291: CALL_OW 1
7295: ST_TO_ADDR
// extraPopovForces := [ ] ;
7296: LD_ADDR_EXP 18
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: DOUBLE
7309: LD_INT 1
7311: DEC
7312: ST_TO_ADDR
7313: LD_INT 8
7315: PUSH
7316: LD_INT 9
7318: PUSH
7319: LD_INT 10
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: LIST
7326: PUSH
7327: LD_OWVAR 67
7331: ARRAY
7332: PUSH
7333: FOR_TO
7334: IFFALSE 7463
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7336: LD_INT 0
7338: PPUSH
7339: LD_INT 1
7341: PPUSH
7342: LD_INT 4
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: LD_INT 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PPUSH
7362: CALL_OW 380
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 12
7386: IFFALSE 7411
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 131
7395: PPUSH
7396: LD_INT 110
7398: PPUSH
7399: LD_INT 8
7401: PPUSH
7402: LD_INT 0
7404: PPUSH
7405: CALL_OW 50
7409: GO 7432
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7411: LD_VAR 0 3
7415: PPUSH
7416: LD_INT 100
7418: PPUSH
7419: LD_INT 99
7421: PPUSH
7422: LD_INT 8
7424: PPUSH
7425: LD_INT 0
7427: PPUSH
7428: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7432: LD_ADDR_EXP 18
7436: PUSH
7437: LD_EXP 18
7441: PPUSH
7442: LD_EXP 18
7446: PUSH
7447: LD_INT 1
7449: PLUS
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL_OW 1
7460: ST_TO_ADDR
// end ;
7461: GO 7333
7463: POP
7464: POP
// PrepareSoldier ( false , 6 ) ;
7465: LD_INT 0
7467: PPUSH
7468: LD_INT 6
7470: PPUSH
7471: CALL_OW 381
// un := CreateHuman ;
7475: LD_ADDR_VAR 0 3
7479: PUSH
7480: CALL_OW 44
7484: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7497: LD_VAR 0 3
7501: PPUSH
7502: LD_INT 150
7504: PPUSH
7505: LD_INT 158
7507: PPUSH
7508: CALL_OW 428
7512: PPUSH
7513: CALL_OW 52
// popovAttackGroup := [ ] ;
7517: LD_ADDR_EXP 19
7521: PUSH
7522: EMPTY
7523: ST_TO_ADDR
// end ;
7524: LD_VAR 0 1
7528: RET
// export function InitMC_Popov ( ) ; begin
7529: LD_INT 0
7531: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7532: LD_INT 3
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL 76555 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7542: LD_INT 3
7544: PPUSH
7545: LD_INT 10
7547: PPUSH
7548: CALL 76499 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 86
7557: PUSH
7558: LD_INT 118
7560: PUSH
7561: LD_INT 0
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 123
7571: PUSH
7572: LD_INT 151
7574: PUSH
7575: LD_INT 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 98
7585: PUSH
7586: LD_INT 121
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: PPUSH
7602: CALL 75558 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7606: LD_INT 3
7608: PPUSH
7609: LD_INT 46
7611: PUSH
7612: LD_INT 45
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL 76387 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7623: LD_INT 3
7625: PPUSH
7626: LD_INT 12
7628: PPUSH
7629: CALL 76069 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7633: LD_INT 3
7635: PPUSH
7636: LD_INT 11
7638: PPUSH
7639: CALL 75800 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7643: LD_INT 3
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL 75419 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7653: LD_INT 3
7655: PPUSH
7656: LD_INT 23
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 44
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 23
7676: PUSH
7677: LD_INT 1
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 45
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 1
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 44
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 21
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL 75234 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7738: LD_INT 3
7740: PPUSH
7741: LD_INT 94
7743: PPUSH
7744: LD_INT 161
7746: PPUSH
7747: LD_INT 0
7749: PPUSH
7750: LD_INT 19
7752: PUSH
7753: LD_INT 17
7755: PUSH
7756: LD_INT 18
7758: PUSH
7759: LD_INT 24
7761: PUSH
7762: LD_INT 21
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL 76181 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7776: LD_INT 3
7778: PPUSH
7779: LD_INT 21
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 51
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: PPUSH
7800: CALL 75282 0 2
// end ;
7804: LD_VAR 0 1
7808: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7809: LD_EXP 18
7813: PUSH
7814: LD_EXP 5
7818: NOT
7819: AND
7820: IFFALSE 7880
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_INT 106
7832: PPUSH
7833: LD_INT 137
7835: PPUSH
7836: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7840: LD_ADDR_EXP 23
7844: PUSH
7845: LD_EXP 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_EXP 23
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: LD_EXP 18
7866: UNION
7867: PPUSH
7868: CALL_OW 1
7872: ST_TO_ADDR
// extraPopovForces := [ ] ;
7873: LD_ADDR_EXP 18
7877: PUSH
7878: EMPTY
7879: ST_TO_ADDR
// end ;
7880: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7881: LD_INT 9
7883: PPUSH
7884: CALL_OW 302
7888: PUSH
7889: LD_EXP 5
7893: NOT
7894: AND
7895: IFFALSE 8461
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
7903: PPUSH
7904: PPUSH
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// base := 3 ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7916: LD_ADDR_VAR 0 3
7920: PUSH
7921: LD_INT 22
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 44
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 24
7941: PUSH
7942: LD_INT 1
7944: PUSH
7945: LD_INT 3
7947: PUSH
7948: LD_INT 46
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 24
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 3
7965: PUSH
7966: LD_INT 46
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: LD_INT 24
7977: PUSH
7978: LD_INT 1
7980: PUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 46
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7999: LD_ADDR_VAR 0 5
8003: PUSH
8004: LD_VAR 0 5
8008: PUSH
8009: LD_OWVAR 1
8013: PUSH
8014: LD_INT 21000
8016: DIV
8017: PLUS
8018: ST_TO_ADDR
// if amount > 8 then
8019: LD_VAR 0 5
8023: PUSH
8024: LD_INT 8
8026: GREATER
8027: IFFALSE 8037
// amount := 8 ;
8029: LD_ADDR_VAR 0 5
8033: PUSH
8034: LD_INT 8
8036: ST_TO_ADDR
// for i = 1 to amount do
8037: LD_ADDR_VAR 0 1
8041: PUSH
8042: DOUBLE
8043: LD_INT 1
8045: DEC
8046: ST_TO_ADDR
8047: LD_VAR 0 5
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8118
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PPUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 1
8072: PLUS
8073: PPUSH
8074: LD_INT 24
8076: PUSH
8077: LD_INT 1
8079: PUSH
8080: LD_INT 3
8082: PUSH
8083: LD_INT 46
8085: PUSH
8086: LD_INT 45
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: PUSH
8093: LD_INT 1
8095: PPUSH
8096: LD_INT 2
8098: PPUSH
8099: CALL_OW 12
8103: ARRAY
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 2
8115: ST_TO_ADDR
8116: GO 8052
8118: POP
8119: POP
// MC_InsertProduceList ( base , tmp ) ;
8120: LD_VAR 0 2
8124: PPUSH
8125: LD_VAR 0 3
8129: PPUSH
8130: CALL 75282 0 2
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8141: LD_VAR 0 2
8145: PPUSH
8146: LD_INT 1
8148: PPUSH
8149: CALL 76700 0 2
8153: PUSH
8154: LD_VAR 0 5
8158: GREATEREQUAL
8159: IFFALSE 8134
// wait ( 0 0$30 ) ;
8161: LD_INT 1050
8163: PPUSH
8164: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8168: LD_ADDR_VAR 0 4
8172: PUSH
8173: LD_EXP 42
8177: PUSH
8178: LD_VAR 0 2
8182: ARRAY
8183: PUSH
8184: LD_EXP 42
8188: PUSH
8189: LD_VAR 0 2
8193: ARRAY
8194: PPUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 34
8200: PUSH
8201: LD_INT 51
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 34
8210: PUSH
8211: LD_INT 52
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: DIFF
8228: ST_TO_ADDR
// if not attackers then
8229: LD_VAR 0 4
8233: NOT
8234: IFFALSE 8238
// exit ;
8236: GO 8461
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8238: LD_ADDR_EXP 42
8242: PUSH
8243: LD_EXP 42
8247: PPUSH
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_EXP 42
8257: PUSH
8258: LD_VAR 0 2
8262: ARRAY
8263: PUSH
8264: LD_VAR 0 4
8268: DIFF
8269: PPUSH
8270: CALL_OW 1
8274: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8275: LD_VAR 0 4
8279: PPUSH
8280: LD_INT 107
8282: PPUSH
8283: LD_INT 74
8285: PPUSH
8286: CALL_OW 114
// wait ( 0 0$5 ) ;
8290: LD_INT 175
8292: PPUSH
8293: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8304: LD_VAR 0 4
8308: PPUSH
8309: LD_INT 60
8311: PUSH
8312: EMPTY
8313: LIST
8314: PPUSH
8315: CALL_OW 72
8319: NOT
8320: IFFALSE 8297
// if rand ( 0 , 1 ) then
8322: LD_INT 0
8324: PPUSH
8325: LD_INT 1
8327: PPUSH
8328: CALL_OW 12
8332: IFFALSE 8351
// ComAgressiveMove ( attackers , 155 , 108 ) else
8334: LD_VAR 0 4
8338: PPUSH
8339: LD_INT 155
8341: PPUSH
8342: LD_INT 108
8344: PPUSH
8345: CALL_OW 114
8349: GO 8366
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8351: LD_VAR 0 4
8355: PPUSH
8356: LD_INT 149
8358: PPUSH
8359: LD_INT 55
8361: PPUSH
8362: CALL_OW 114
// wait ( 0 0$10 ) ;
8366: LD_INT 350
8368: PPUSH
8369: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8373: LD_INT 35
8375: PPUSH
8376: CALL_OW 67
// for i in attackers do
8380: LD_ADDR_VAR 0 1
8384: PUSH
8385: LD_VAR 0 4
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8441
// if not HasTask ( i ) then
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL_OW 314
8402: NOT
8403: IFFALSE 8439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_INT 81
8412: PUSH
8413: LD_INT 3
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: PPUSH
8425: LD_VAR 0 1
8429: PPUSH
8430: CALL_OW 74
8434: PPUSH
8435: CALL_OW 115
8439: GO 8390
8441: POP
8442: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8443: LD_VAR 0 4
8447: PPUSH
8448: LD_INT 50
8450: PUSH
8451: EMPTY
8452: LIST
8453: PPUSH
8454: CALL_OW 72
8458: NOT
8459: IFFALSE 8373
// end ;
8461: PPOPN 5
8463: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8464: LD_EXP 5
8468: NOT
8469: IFFALSE 9056
8471: GO 8473
8473: DISABLE
8474: LD_INT 0
8476: PPUSH
8477: PPUSH
8478: PPUSH
8479: PPUSH
// begin enable ;
8480: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8481: LD_OWVAR 67
8485: PUSH
8486: LD_INT 1
8488: EQUAL
8489: PUSH
8490: LD_OWVAR 1
8494: PUSH
8495: LD_INT 63000
8497: LESS
8498: AND
8499: IFFALSE 8503
// exit ;
8501: GO 9056
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// if tick < 45 45$00 then
8510: LD_OWVAR 1
8514: PUSH
8515: LD_INT 94500
8517: LESS
8518: IFFALSE 8695
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_INT 2
8532: PUSH
8533: LD_INT 3
8535: PUSH
8536: LD_INT 4
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_OWVAR 67
8548: ARRAY
8549: PUSH
8550: FOR_TO
8551: IFFALSE 8693
// begin uc_side := 3 ;
8553: LD_ADDR_OWVAR 20
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// uc_nation := 3 ;
8561: LD_ADDR_OWVAR 21
8565: PUSH
8566: LD_INT 3
8568: ST_TO_ADDR
// InitHC_All ( ) ;
8569: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 5
8581: PUSH
8582: LD_INT 6
8584: PUSH
8585: LD_INT 7
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PPUSH
8599: CALL_OW 380
// un := CreateHuman ;
8603: LD_ADDR_VAR 0 2
8607: PUSH
8608: CALL_OW 44
8612: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 18
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 9
8635: PPUSH
8636: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8640: LD_VAR 0 2
8644: PPUSH
8645: LD_INT 147
8647: PPUSH
8648: LD_INT 161
8650: PPUSH
8651: CALL_OW 111
// wait ( 0 0$2 ) ;
8655: LD_INT 70
8657: PPUSH
8658: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 1
8690: ST_TO_ADDR
// end ;
8691: GO 8550
8693: POP
8694: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8695: LD_ADDR_VAR 0 4
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 4
8705: PUSH
8706: LD_INT 5
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_OWVAR 67
8718: ARRAY
8719: PUSH
8720: LD_OWVAR 1
8724: PUSH
8725: LD_INT 21000
8727: DIV
8728: PLUS
8729: ST_TO_ADDR
// if amount > 15 then
8730: LD_VAR 0 4
8734: PUSH
8735: LD_INT 15
8737: GREATER
8738: IFFALSE 8748
// amount := 15 ;
8740: LD_ADDR_VAR 0 4
8744: PUSH
8745: LD_INT 15
8747: ST_TO_ADDR
// for i := 1 to amount do
8748: LD_ADDR_VAR 0 1
8752: PUSH
8753: DOUBLE
8754: LD_INT 1
8756: DEC
8757: ST_TO_ADDR
8758: LD_VAR 0 4
8762: PUSH
8763: FOR_TO
8764: IFFALSE 8910
// begin uc_side := 3 ;
8766: LD_ADDR_OWVAR 20
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// uc_nation := 3 ;
8774: LD_ADDR_OWVAR 21
8778: PUSH
8779: LD_INT 3
8781: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8782: LD_INT 24
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 46
8793: PUSH
8794: LD_INT 45
8796: PUSH
8797: LD_INT 44
8799: PUSH
8800: LD_INT 43
8802: PUSH
8803: LD_INT 42
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: PPUSH
8825: LD_INT 90
8827: PPUSH
8828: CALL 15891 0 5
// un := CreateVehicle ;
8832: LD_ADDR_VAR 0 2
8836: PUSH
8837: CALL_OW 45
8841: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_INT 18
8849: PPUSH
8850: LD_INT 0
8852: PPUSH
8853: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8857: LD_VAR 0 2
8861: PPUSH
8862: LD_INT 147
8864: PPUSH
8865: LD_INT 161
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$3 ) ;
8872: LD_INT 105
8874: PPUSH
8875: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8879: LD_ADDR_VAR 0 3
8883: PUSH
8884: LD_VAR 0 3
8888: PPUSH
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 1
8896: PLUS
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// end ;
8908: GO 8763
8910: POP
8911: POP
// if not tmp then
8912: LD_VAR 0 3
8916: NOT
8917: IFFALSE 8921
// exit ;
8919: GO 9056
// wait ( 0 0$5 ) ;
8921: LD_INT 175
8923: PPUSH
8924: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// for i in tmp do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: LD_VAR 0 3
8944: PUSH
8945: FOR_IN
8946: IFFALSE 9047
// begin if not IsOk ( i ) or IsDead ( i ) then
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL_OW 302
8957: NOT
8958: PUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: CALL_OW 301
8968: OR
8969: IFFALSE 8987
// tmp := tmp diff i ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: DIFF
8986: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 257
8996: PUSH
8997: LD_INT 9
8999: EQUAL
9000: IFFALSE 9011
// ComSpaceTimeShoot ( i ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: CALL 11974 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9011: LD_VAR 0 1
9015: PPUSH
9016: LD_INT 81
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: PPUSH
9031: LD_VAR 0 1
9035: PPUSH
9036: CALL_OW 74
9040: PPUSH
9041: CALL_OW 115
// end ;
9045: GO 8945
9047: POP
9048: POP
// until not tmp ;
9049: LD_VAR 0 3
9053: NOT
9054: IFFALSE 8928
// end ; end_of_file
9056: PPOPN 4
9058: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
// uc_side := 1 ;
9065: LD_ADDR_OWVAR 20
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// uc_nation := 1 ;
9073: LD_ADDR_OWVAR 21
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// hc_importance := 100 ;
9081: LD_ADDR_OWVAR 32
9085: PUSH
9086: LD_INT 100
9088: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9089: LD_ADDR_OWVAR 26
9093: PUSH
9094: LD_STRING Jeremy Sikorski
9096: ST_TO_ADDR
// hc_gallery := us ;
9097: LD_ADDR_OWVAR 33
9101: PUSH
9102: LD_STRING us
9104: ST_TO_ADDR
// hc_face_number := 19 ;
9105: LD_ADDR_OWVAR 34
9109: PUSH
9110: LD_INT 19
9112: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 4
9121: PUSH
9122: LD_INT 4
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PUSH
9133: LD_OWVAR 67
9137: ARRAY
9138: PPUSH
9139: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9143: LD_ADDR_OWVAR 29
9147: PUSH
9148: LD_INT 10
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
// Sikorski := CreateHuman ;
9158: LD_ADDR_EXP 20
9162: PUSH
9163: CALL_OW 44
9167: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9168: LD_EXP 20
9172: PPUSH
9173: LD_INT 133
9175: PPUSH
9176: LD_INT 19
9178: PPUSH
9179: LD_INT 2
9181: PPUSH
9182: LD_INT 0
9184: PPUSH
9185: CALL_OW 50
// InitHc_All ( ) ;
9189: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_INT 4
9205: PUSH
9206: LD_INT 3
9208: PUSH
9209: LD_INT 3
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: PUSH
9217: LD_OWVAR 67
9221: ARRAY
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9340
// for j := 1 to 4 do
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: DOUBLE
9232: LD_INT 1
9234: DEC
9235: ST_TO_ADDR
9236: LD_INT 4
9238: PUSH
9239: FOR_TO
9240: IFFALSE 9336
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9242: LD_INT 0
9244: PPUSH
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 5
9252: PUSH
9253: LD_INT 4
9255: PUSH
9256: LD_INT 3
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PUSH
9264: LD_OWVAR 67
9268: ARRAY
9269: PPUSH
9270: CALL_OW 380
// un := CreateHuman ;
9274: LD_ADDR_VAR 0 4
9278: PUSH
9279: CALL_OW 44
9283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9284: LD_VAR 0 4
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: LD_INT 5
9294: PPUSH
9295: CALL_OW 12
9299: PPUSH
9300: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9304: LD_VAR 0 4
9308: PPUSH
9309: LD_INT 133
9311: PPUSH
9312: LD_INT 19
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 0
9320: PPUSH
9321: CALL_OW 50
// ComHold ( un ) ;
9325: LD_VAR 0 4
9329: PPUSH
9330: CALL_OW 140
// end ;
9334: GO 9239
9336: POP
9337: POP
9338: GO 9223
9340: POP
9341: POP
// vc_chassis := us_heavy_tracked ;
9342: LD_ADDR_OWVAR 37
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// vc_engine := engine_combustion ;
9350: LD_ADDR_OWVAR 39
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_control := control_manual ;
9358: LD_ADDR_OWVAR 38
9362: PUSH
9363: LD_INT 1
9365: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9366: LD_ADDR_OWVAR 40
9370: PUSH
9371: LD_INT 14
9373: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9374: LD_ADDR_OWVAR 41
9378: PUSH
9379: LD_INT 60
9381: ST_TO_ADDR
// un := CreateVehicle ;
9382: LD_ADDR_VAR 0 4
9386: PUSH
9387: CALL_OW 45
9391: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 2
9399: PPUSH
9400: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9404: LD_VAR 0 4
9408: PPUSH
9409: LD_INT 128
9411: PPUSH
9412: LD_INT 12
9414: PPUSH
9415: LD_INT 0
9417: PPUSH
9418: CALL_OW 48
// for i := 1 to 3 do
9422: LD_ADDR_VAR 0 2
9426: PUSH
9427: DOUBLE
9428: LD_INT 1
9430: DEC
9431: ST_TO_ADDR
9432: LD_INT 3
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9459
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9438: LD_INT 5
9440: PPUSH
9441: LD_INT 133
9443: PPUSH
9444: LD_INT 19
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: LD_INT 0
9452: PPUSH
9453: CALL_OW 56
9457: GO 9435
9459: POP
9460: POP
// end ; end_of_file
9461: LD_VAR 0 1
9465: RET
// export function Action ; begin
9466: LD_INT 0
9468: PPUSH
// InGameOn ;
9469: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9473: LD_INT 133
9475: PPUSH
9476: LD_INT 19
9478: PPUSH
9479: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9483: LD_EXP 20
9487: PPUSH
9488: LD_STRING WT-DS-1
9490: PPUSH
9491: CALL_OW 88
// InGameOff ;
9495: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9499: LD_STRING DestroyEnemy
9501: PPUSH
9502: CALL_OW 337
// wait ( 0 0$20 ) ;
9506: LD_INT 700
9508: PPUSH
9509: CALL_OW 67
// DialogueOn ;
9513: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9517: LD_INT 100
9519: PPUSH
9520: LD_INT 37
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: LD_INT 30
9528: NEG
9529: PPUSH
9530: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9534: LD_INT 100
9536: PPUSH
9537: LD_INT 37
9539: PPUSH
9540: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9544: LD_EXP 10
9548: PPUSH
9549: LD_STRING WT-PL-1
9551: PPUSH
9552: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9556: LD_EXP 20
9560: PPUSH
9561: LD_STRING WT-DS-2
9563: PPUSH
9564: CALL_OW 88
// DialogueOff ;
9568: CALL_OW 7
// wait ( 0 0$2 ) ;
9572: LD_INT 70
9574: PPUSH
9575: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9579: LD_INT 100
9581: PPUSH
9582: LD_INT 37
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL_OW 331
// end ;
9592: LD_VAR 0 1
9596: RET
// export function DialogPowellsAttack ; begin
9597: LD_INT 0
9599: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-8
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// export function DialogContaminateSib ( x , y ) ; begin
9617: LD_INT 0
9619: PPUSH
// DialogueOn ;
9620: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9624: LD_VAR 0 1
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9638: LD_EXP 20
9642: PPUSH
9643: LD_STRING WT-DS-3
9645: PPUSH
9646: CALL_OW 88
// DialogueOff ;
9650: CALL_OW 7
// end ;
9654: LD_VAR 0 3
9658: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9659: LD_EXP 8
9663: NOT
9664: PUSH
9665: LD_INT 1
9667: PPUSH
9668: LD_INT 81
9670: PUSH
9671: LD_INT 4
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 70
9682: PUSH
9683: LD_INT 3
9685: GREATER
9686: AND
9687: IFFALSE 9759
9689: GO 9691
9691: DISABLE
// begin powellInTrouble := true ;
9692: LD_ADDR_EXP 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9700: LD_EXP 20
9704: PPUSH
9705: LD_STRING WT-DS-6
9707: PPUSH
9708: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9712: LD_INT 1
9714: PPUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: NOT
9730: IFFALSE 9744
// SayRadio ( Powell , WT-PL-6 ) ;
9732: LD_EXP 10
9736: PPUSH
9737: LD_STRING WT-PL-6
9739: PPUSH
9740: CALL_OW 94
// wait ( 1 1$30 ) ;
9744: LD_INT 3150
9746: PPUSH
9747: CALL_OW 67
// powellInTrouble := false ;
9751: LD_ADDR_EXP 8
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// end ;
9759: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9760: LD_EXP 9
9764: NOT
9765: PUSH
9766: LD_INT 16
9768: PPUSH
9769: LD_INT 81
9771: PUSH
9772: LD_INT 1
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: PUSH
9784: LD_INT 6
9786: GREATER
9787: AND
9788: IFFALSE 9861
9790: GO 9792
9792: DISABLE
// begin sikorskiInTrouble := true ;
9793: LD_ADDR_EXP 9
9797: PUSH
9798: LD_INT 1
9800: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9801: LD_EXP 20
9805: PPUSH
9806: LD_STRING WT-DS-7
9808: PPUSH
9809: CALL_OW 88
// if not powellAttackGroup then
9813: LD_EXP 12
9817: NOT
9818: IFFALSE 9834
// SayRadio ( Powell , WT-PL-7n ) else
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-7n
9827: PPUSH
9828: CALL_OW 94
9832: GO 9846
// SayRadio ( Powell , WT-PL-7y ) ;
9834: LD_EXP 10
9838: PPUSH
9839: LD_STRING WT-PL-7y
9841: PPUSH
9842: CALL_OW 94
// wait ( 1 1$30 ) ;
9846: LD_INT 3150
9848: PPUSH
9849: CALL_OW 67
// sikorskiInTrouble := false ;
9853: LD_ADDR_EXP 9
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// end ;
9861: END
// export function DialogPowellsAttackFailed ; begin
9862: LD_INT 0
9864: PPUSH
// if not ruDestroyed then
9865: LD_EXP 5
9869: NOT
9870: IFFALSE 9886
// SayRadio ( Powell , WT-PL-9 ) else
9872: LD_EXP 10
9876: PPUSH
9877: LD_STRING WT-PL-9
9879: PPUSH
9880: CALL_OW 94
9884: GO 9898
// SayRadio ( Powell , WT-PL-10 ) ;
9886: LD_EXP 10
9890: PPUSH
9891: LD_STRING WT-PL-10
9893: PPUSH
9894: CALL_OW 94
// end ;
9898: LD_VAR 0 1
9902: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9903: LD_INT 22
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 1
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
9937: GO 9939
9939: DISABLE
// begin arDestroyed := true ;
9940: LD_ADDR_EXP 4
9944: PUSH
9945: LD_INT 1
9947: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9948: LD_INT 2
9950: PPUSH
9951: CALL 51304 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9955: LD_EXP 20
9959: PPUSH
9960: LD_STRING WT-DS-4
9962: PPUSH
9963: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9967: LD_EXP 10
9971: PPUSH
9972: LD_STRING WT-PL-4
9974: PPUSH
9975: CALL_OW 94
// end ;
9979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9980: LD_INT 22
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 0
10011: EQUAL
10012: IFFALSE 10056
10014: GO 10016
10016: DISABLE
// begin ruDestroyed := true ;
10017: LD_ADDR_EXP 5
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10025: LD_INT 3
10027: PPUSH
10028: CALL 51304 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10032: LD_EXP 20
10036: PPUSH
10037: LD_STRING WT-DS-5
10039: PPUSH
10040: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10044: LD_EXP 10
10048: PPUSH
10049: LD_STRING WT-PL-5
10051: PPUSH
10052: CALL_OW 94
// end ;
10056: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10057: LD_EXP 5
10061: PUSH
10062: LD_EXP 4
10066: AND
10067: IFFALSE 10240
10069: GO 10071
10071: DISABLE
// begin wait ( 0 0$3 ) ;
10072: LD_INT 105
10074: PPUSH
10075: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10079: LD_OWVAR 1
10083: PUSH
10084: LD_INT 126000
10086: PUSH
10087: LD_INT 105000
10089: PUSH
10090: LD_INT 94500
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_OWVAR 67
10102: ARRAY
10103: GREATEREQUAL
10104: IFFALSE 10119
// AddMedal ( WoT-med-1 , - 1 ) else
10106: LD_STRING WoT-med-1
10108: PPUSH
10109: LD_INT 1
10111: NEG
10112: PPUSH
10113: CALL_OW 101
10117: GO 10129
// AddMedal ( WoT-med-1 , 1 ) ;
10119: LD_STRING WoT-med-1
10121: PPUSH
10122: LD_INT 1
10124: PPUSH
10125: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10129: LD_EXP 6
10133: PUSH
10134: LD_INT 4
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 2
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: GREATEREQUAL
10154: IFFALSE 10169
// AddMedal ( WoT-med-2 , - 1 ) else
10156: LD_STRING WoT-med-2
10158: PPUSH
10159: LD_INT 1
10161: NEG
10162: PPUSH
10163: CALL_OW 101
10167: GO 10179
// AddMedal ( WoT-med-2 , 1 ) ;
10169: LD_STRING WoT-med-2
10171: PPUSH
10172: LD_INT 1
10174: PPUSH
10175: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10179: LD_EXP 7
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 5
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: LD_OWVAR 67
10202: ARRAY
10203: GREATEREQUAL
10204: IFFALSE 10219
// AddMedal ( WoT-med-3 , - 1 ) else
10206: LD_STRING WoT-med-3
10208: PPUSH
10209: LD_INT 1
10211: NEG
10212: PPUSH
10213: CALL_OW 101
10217: GO 10229
// AddMedal ( WoT-med-3 , 1 ) ;
10219: LD_STRING WoT-med-3
10221: PPUSH
10222: LD_INT 1
10224: PPUSH
10225: CALL_OW 101
// GiveMedals ( MAIN ) ;
10229: LD_STRING MAIN
10231: PPUSH
10232: CALL_OW 102
// YouWin ;
10236: CALL_OW 103
// end ; end_of_file
10240: END
// export function CustomEvent ( event ) ; begin
10241: LD_INT 0
10243: PPUSH
// end ;
10244: LD_VAR 0 2
10248: RET
// on Command ( com ) do var i , j , temp ;
10249: LD_INT 0
10251: PPUSH
10252: PPUSH
10253: PPUSH
// begin if com = 60 then
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 60
10261: EQUAL
10262: IFFALSE 10441
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10264: LD_ADDR_VAR 0 2
10268: PUSH
10269: LD_INT 22
10271: PUSH
10272: LD_INT 1
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 12
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PPUSH
10311: CALL_OW 69
10315: PUSH
10316: FOR_IN
10317: IFFALSE 10439
// begin if GetTaskList ( i ) > 0 then
10319: LD_VAR 0 2
10323: PPUSH
10324: CALL_OW 437
10328: PUSH
10329: LD_INT 0
10331: GREATER
10332: IFFALSE 10437
// for j = 1 to GetTaskList ( i ) do
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: DOUBLE
10340: LD_INT 1
10342: DEC
10343: ST_TO_ADDR
10344: LD_VAR 0 2
10348: PPUSH
10349: CALL_OW 437
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10435
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10357: LD_ADDR_VAR 0 4
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: CALL_OW 437
10371: PUSH
10372: LD_VAR 0 3
10376: ARRAY
10377: PUSH
10378: LD_INT 4
10380: ARRAY
10381: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10382: LD_VAR 0 4
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_INT 4
10394: EQUAL
10395: PUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: CALL_OW 437
10405: PUSH
10406: LD_VAR 0 3
10410: ARRAY
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PUSH
10416: LD_STRING <
10418: EQUAL
10419: AND
10420: IFFALSE 10433
// SetTaskList ( i , [ ] ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: EMPTY
10428: PPUSH
10429: CALL_OW 446
// end ;
10433: GO 10354
10435: POP
10436: POP
// end ;
10437: GO 10316
10439: POP
10440: POP
// end ; end ;
10441: PPOPN 4
10443: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 3
10453: PPUSH
10454: CALL_OW 428
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: LD_INT 1
10466: EQUAL
10467: PUSH
10468: LD_VAR 0 2
10472: PUSH
10473: LD_INT 132
10475: EQUAL
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_INT 39
10484: EQUAL
10485: AND
10486: OR
10487: IFFALSE 10503
// DialogContaminateSib ( x , y ) ;
10489: LD_VAR 0 2
10493: PPUSH
10494: LD_VAR 0 3
10498: PPUSH
10499: CALL 9617 0 2
// end ;
10503: PPOPN 3
10505: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL 89157 0 1
// MCE_UnitDestroyed ( un ) ;
10515: LD_VAR 0 1
10519: PPUSH
10520: CALL 78702 0 1
// if un = Powell then
10524: LD_VAR 0 1
10528: PUSH
10529: LD_EXP 10
10533: EQUAL
10534: IFFALSE 10543
// YouLost ( Powell ) ;
10536: LD_STRING Powell
10538: PPUSH
10539: CALL_OW 104
// if un = Sikorski then
10543: LD_VAR 0 1
10547: PUSH
10548: LD_EXP 20
10552: EQUAL
10553: IFFALSE 10562
// YouLost ( Sikorski ) ;
10555: LD_STRING Sikorski
10557: PPUSH
10558: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 22
10569: PUSH
10570: LD_INT 1
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PUSH
10577: LD_INT 21
10579: PUSH
10580: LD_INT 1
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PUSH
10587: EMPTY
10588: LIST
10589: LIST
10590: PPUSH
10591: CALL_OW 69
10595: IN
10596: IFFALSE 10612
// loseCounter := loseCounter + 1 ;
10598: LD_ADDR_EXP 6
10602: PUSH
10603: LD_EXP 6
10607: PUSH
10608: LD_INT 1
10610: PLUS
10611: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10612: LD_VAR 0 1
10616: PUSH
10617: LD_INT 22
10619: PUSH
10620: LD_INT 4
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PUSH
10627: LD_INT 21
10629: PUSH
10630: LD_INT 1
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PPUSH
10641: CALL_OW 69
10645: IN
10646: IFFALSE 10662
// powellLoseCounter := powellLoseCounter + 1 ;
10648: LD_ADDR_EXP 7
10652: PUSH
10653: LD_EXP 7
10657: PUSH
10658: LD_INT 1
10660: PLUS
10661: ST_TO_ADDR
// if un in powellAttackGroup then
10662: LD_VAR 0 1
10666: PUSH
10667: LD_EXP 12
10671: IN
10672: IFFALSE 10690
// powellAttackGroup := powellAttackGroup diff un ;
10674: LD_ADDR_EXP 12
10678: PUSH
10679: LD_EXP 12
10683: PUSH
10684: LD_VAR 0 1
10688: DIFF
10689: ST_TO_ADDR
// if un in gensherAttackGroup then
10690: LD_VAR 0 1
10694: PUSH
10695: LD_EXP 15
10699: IN
10700: IFFALSE 10718
// gensherAttackGroup := gensherAttackGroup diff un ;
10702: LD_ADDR_EXP 15
10706: PUSH
10707: LD_EXP 15
10711: PUSH
10712: LD_VAR 0 1
10716: DIFF
10717: ST_TO_ADDR
// if un in popovAttackGroup then
10718: LD_VAR 0 1
10722: PUSH
10723: LD_EXP 19
10727: IN
10728: IFFALSE 10746
// popovAttackGroup := popovAttackGroup diff un ;
10730: LD_ADDR_EXP 19
10734: PUSH
10735: LD_EXP 19
10739: PUSH
10740: LD_VAR 0 1
10744: DIFF
10745: ST_TO_ADDR
// end ;
10746: PPOPN 1
10748: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10749: LD_VAR 0 1
10753: PPUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: CALL 81036 0 2
// end ;
10763: PPOPN 2
10765: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL 80104 0 1
// end ;
10775: PPOPN 1
10777: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10778: LD_VAR 0 1
10782: PPUSH
10783: CALL 80345 0 1
// end ;
10787: PPOPN 1
10789: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10790: LD_VAR 0 1
10794: PPUSH
10795: LD_VAR 0 2
10799: PPUSH
10800: CALL 78398 0 2
// end ;
10804: PPOPN 2
10806: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10807: LD_VAR 0 1
10811: PPUSH
10812: LD_VAR 0 2
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: LD_VAR 0 4
10826: PPUSH
10827: LD_VAR 0 5
10831: PPUSH
10832: CALL 78018 0 5
// end ;
10836: PPOPN 5
10838: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_VAR 0 2
10848: PPUSH
10849: CALL 89279 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_VAR 0 2
10862: PPUSH
10863: CALL 77599 0 2
// end ;
10867: PPOPN 2
10869: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10870: LD_VAR 0 1
10874: PPUSH
10875: LD_VAR 0 2
10879: PPUSH
10880: LD_VAR 0 3
10884: PPUSH
10885: LD_VAR 0 4
10889: PPUSH
10890: CALL 77437 0 4
// end ;
10894: PPOPN 4
10896: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_VAR 0 2
10906: PPUSH
10907: LD_VAR 0 3
10911: PPUSH
10912: CALL 77212 0 3
// end ;
10916: PPOPN 3
10918: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: LD_VAR 0 2
10928: PPUSH
10929: CALL 77097 0 2
// end ;
10933: PPOPN 2
10935: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10936: LD_VAR 0 1
10940: PPUSH
10941: LD_VAR 0 2
10945: PPUSH
10946: CALL 81331 0 2
// end ;
10950: PPOPN 2
10952: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10953: LD_VAR 0 1
10957: PPUSH
10958: LD_VAR 0 2
10962: PPUSH
10963: LD_VAR 0 3
10967: PPUSH
10968: LD_VAR 0 4
10972: PPUSH
10973: CALL 81547 0 4
// end ;
10977: PPOPN 4
10979: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10980: LD_VAR 0 1
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL 76906 0 2
// end ;
10994: PPOPN 2
10996: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10997: LD_VAR 0 1
11001: PUSH
11002: LD_INT 1
11004: EQUAL
11005: PUSH
11006: LD_VAR 0 2
11010: PUSH
11011: LD_INT 4
11013: EQUAL
11014: AND
11015: IFFALSE 11024
// YouLost ( FriendlyFire ) ;
11017: LD_STRING FriendlyFire
11019: PPUSH
11020: CALL_OW 104
// end ; end_of_file
11024: PPOPN 2
11026: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11027: LD_INT 0
11029: PPUSH
11030: PPUSH
// if exist_mode then
11031: LD_VAR 0 2
11035: IFFALSE 11060
// unit := CreateCharacter ( prefix & ident ) else
11037: LD_ADDR_VAR 0 5
11041: PUSH
11042: LD_VAR 0 3
11046: PUSH
11047: LD_VAR 0 1
11051: STR
11052: PPUSH
11053: CALL_OW 34
11057: ST_TO_ADDR
11058: GO 11075
// unit := NewCharacter ( ident ) ;
11060: LD_ADDR_VAR 0 5
11064: PUSH
11065: LD_VAR 0 1
11069: PPUSH
11070: CALL_OW 25
11074: ST_TO_ADDR
// result := unit ;
11075: LD_ADDR_VAR 0 4
11079: PUSH
11080: LD_VAR 0 5
11084: ST_TO_ADDR
// end ;
11085: LD_VAR 0 4
11089: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11090: LD_INT 0
11092: PPUSH
11093: PPUSH
// if not side or not nation then
11094: LD_VAR 0 1
11098: NOT
11099: PUSH
11100: LD_VAR 0 2
11104: NOT
11105: OR
11106: IFFALSE 11110
// exit ;
11108: GO 11878
// case nation of nation_american :
11110: LD_VAR 0 2
11114: PUSH
11115: LD_INT 1
11117: DOUBLE
11118: EQUAL
11119: IFTRUE 11123
11121: GO 11337
11123: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11124: LD_ADDR_VAR 0 4
11128: PUSH
11129: LD_INT 35
11131: PUSH
11132: LD_INT 45
11134: PUSH
11135: LD_INT 46
11137: PUSH
11138: LD_INT 47
11140: PUSH
11141: LD_INT 82
11143: PUSH
11144: LD_INT 83
11146: PUSH
11147: LD_INT 84
11149: PUSH
11150: LD_INT 85
11152: PUSH
11153: LD_INT 86
11155: PUSH
11156: LD_INT 1
11158: PUSH
11159: LD_INT 2
11161: PUSH
11162: LD_INT 6
11164: PUSH
11165: LD_INT 15
11167: PUSH
11168: LD_INT 16
11170: PUSH
11171: LD_INT 7
11173: PUSH
11174: LD_INT 12
11176: PUSH
11177: LD_INT 13
11179: PUSH
11180: LD_INT 10
11182: PUSH
11183: LD_INT 14
11185: PUSH
11186: LD_INT 20
11188: PUSH
11189: LD_INT 21
11191: PUSH
11192: LD_INT 22
11194: PUSH
11195: LD_INT 25
11197: PUSH
11198: LD_INT 32
11200: PUSH
11201: LD_INT 27
11203: PUSH
11204: LD_INT 36
11206: PUSH
11207: LD_INT 69
11209: PUSH
11210: LD_INT 39
11212: PUSH
11213: LD_INT 34
11215: PUSH
11216: LD_INT 40
11218: PUSH
11219: LD_INT 48
11221: PUSH
11222: LD_INT 49
11224: PUSH
11225: LD_INT 50
11227: PUSH
11228: LD_INT 51
11230: PUSH
11231: LD_INT 52
11233: PUSH
11234: LD_INT 53
11236: PUSH
11237: LD_INT 54
11239: PUSH
11240: LD_INT 55
11242: PUSH
11243: LD_INT 56
11245: PUSH
11246: LD_INT 57
11248: PUSH
11249: LD_INT 58
11251: PUSH
11252: LD_INT 59
11254: PUSH
11255: LD_INT 60
11257: PUSH
11258: LD_INT 61
11260: PUSH
11261: LD_INT 62
11263: PUSH
11264: LD_INT 80
11266: PUSH
11267: LD_INT 82
11269: PUSH
11270: LD_INT 83
11272: PUSH
11273: LD_INT 84
11275: PUSH
11276: LD_INT 85
11278: PUSH
11279: LD_INT 86
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: ST_TO_ADDR
11335: GO 11802
11337: LD_INT 2
11339: DOUBLE
11340: EQUAL
11341: IFTRUE 11345
11343: GO 11571
11345: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11346: LD_ADDR_VAR 0 4
11350: PUSH
11351: LD_INT 35
11353: PUSH
11354: LD_INT 45
11356: PUSH
11357: LD_INT 46
11359: PUSH
11360: LD_INT 47
11362: PUSH
11363: LD_INT 82
11365: PUSH
11366: LD_INT 83
11368: PUSH
11369: LD_INT 84
11371: PUSH
11372: LD_INT 85
11374: PUSH
11375: LD_INT 87
11377: PUSH
11378: LD_INT 70
11380: PUSH
11381: LD_INT 1
11383: PUSH
11384: LD_INT 11
11386: PUSH
11387: LD_INT 3
11389: PUSH
11390: LD_INT 4
11392: PUSH
11393: LD_INT 5
11395: PUSH
11396: LD_INT 6
11398: PUSH
11399: LD_INT 15
11401: PUSH
11402: LD_INT 18
11404: PUSH
11405: LD_INT 7
11407: PUSH
11408: LD_INT 17
11410: PUSH
11411: LD_INT 8
11413: PUSH
11414: LD_INT 20
11416: PUSH
11417: LD_INT 21
11419: PUSH
11420: LD_INT 22
11422: PUSH
11423: LD_INT 72
11425: PUSH
11426: LD_INT 26
11428: PUSH
11429: LD_INT 69
11431: PUSH
11432: LD_INT 39
11434: PUSH
11435: LD_INT 40
11437: PUSH
11438: LD_INT 41
11440: PUSH
11441: LD_INT 42
11443: PUSH
11444: LD_INT 43
11446: PUSH
11447: LD_INT 48
11449: PUSH
11450: LD_INT 49
11452: PUSH
11453: LD_INT 50
11455: PUSH
11456: LD_INT 51
11458: PUSH
11459: LD_INT 52
11461: PUSH
11462: LD_INT 53
11464: PUSH
11465: LD_INT 54
11467: PUSH
11468: LD_INT 55
11470: PUSH
11471: LD_INT 56
11473: PUSH
11474: LD_INT 60
11476: PUSH
11477: LD_INT 61
11479: PUSH
11480: LD_INT 62
11482: PUSH
11483: LD_INT 66
11485: PUSH
11486: LD_INT 67
11488: PUSH
11489: LD_INT 68
11491: PUSH
11492: LD_INT 81
11494: PUSH
11495: LD_INT 82
11497: PUSH
11498: LD_INT 83
11500: PUSH
11501: LD_INT 84
11503: PUSH
11504: LD_INT 85
11506: PUSH
11507: LD_INT 87
11509: PUSH
11510: LD_INT 88
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: LIST
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: LIST
11567: LIST
11568: ST_TO_ADDR
11569: GO 11802
11571: LD_INT 3
11573: DOUBLE
11574: EQUAL
11575: IFTRUE 11579
11577: GO 11801
11579: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11580: LD_ADDR_VAR 0 4
11584: PUSH
11585: LD_INT 46
11587: PUSH
11588: LD_INT 47
11590: PUSH
11591: LD_INT 1
11593: PUSH
11594: LD_INT 2
11596: PUSH
11597: LD_INT 82
11599: PUSH
11600: LD_INT 83
11602: PUSH
11603: LD_INT 84
11605: PUSH
11606: LD_INT 85
11608: PUSH
11609: LD_INT 86
11611: PUSH
11612: LD_INT 11
11614: PUSH
11615: LD_INT 9
11617: PUSH
11618: LD_INT 20
11620: PUSH
11621: LD_INT 19
11623: PUSH
11624: LD_INT 21
11626: PUSH
11627: LD_INT 24
11629: PUSH
11630: LD_INT 22
11632: PUSH
11633: LD_INT 25
11635: PUSH
11636: LD_INT 28
11638: PUSH
11639: LD_INT 29
11641: PUSH
11642: LD_INT 30
11644: PUSH
11645: LD_INT 31
11647: PUSH
11648: LD_INT 37
11650: PUSH
11651: LD_INT 38
11653: PUSH
11654: LD_INT 32
11656: PUSH
11657: LD_INT 27
11659: PUSH
11660: LD_INT 33
11662: PUSH
11663: LD_INT 69
11665: PUSH
11666: LD_INT 39
11668: PUSH
11669: LD_INT 34
11671: PUSH
11672: LD_INT 40
11674: PUSH
11675: LD_INT 71
11677: PUSH
11678: LD_INT 23
11680: PUSH
11681: LD_INT 44
11683: PUSH
11684: LD_INT 48
11686: PUSH
11687: LD_INT 49
11689: PUSH
11690: LD_INT 50
11692: PUSH
11693: LD_INT 51
11695: PUSH
11696: LD_INT 52
11698: PUSH
11699: LD_INT 53
11701: PUSH
11702: LD_INT 54
11704: PUSH
11705: LD_INT 55
11707: PUSH
11708: LD_INT 56
11710: PUSH
11711: LD_INT 57
11713: PUSH
11714: LD_INT 58
11716: PUSH
11717: LD_INT 59
11719: PUSH
11720: LD_INT 63
11722: PUSH
11723: LD_INT 64
11725: PUSH
11726: LD_INT 65
11728: PUSH
11729: LD_INT 82
11731: PUSH
11732: LD_INT 83
11734: PUSH
11735: LD_INT 84
11737: PUSH
11738: LD_INT 85
11740: PUSH
11741: LD_INT 86
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: ST_TO_ADDR
11799: GO 11802
11801: POP
// if state > - 1 and state < 3 then
11802: LD_VAR 0 3
11806: PUSH
11807: LD_INT 1
11809: NEG
11810: GREATER
11811: PUSH
11812: LD_VAR 0 3
11816: PUSH
11817: LD_INT 3
11819: LESS
11820: AND
11821: IFFALSE 11878
// for i in result do
11823: LD_ADDR_VAR 0 5
11827: PUSH
11828: LD_VAR 0 4
11832: PUSH
11833: FOR_IN
11834: IFFALSE 11876
// if GetTech ( i , side ) <> state then
11836: LD_VAR 0 5
11840: PPUSH
11841: LD_VAR 0 1
11845: PPUSH
11846: CALL_OW 321
11850: PUSH
11851: LD_VAR 0 3
11855: NONEQUAL
11856: IFFALSE 11874
// result := result diff i ;
11858: LD_ADDR_VAR 0 4
11862: PUSH
11863: LD_VAR 0 4
11867: PUSH
11868: LD_VAR 0 5
11872: DIFF
11873: ST_TO_ADDR
11874: GO 11833
11876: POP
11877: POP
// end ;
11878: LD_VAR 0 4
11882: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11883: LD_INT 0
11885: PPUSH
11886: PPUSH
11887: PPUSH
// result := true ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11896: LD_ADDR_VAR 0 5
11900: PUSH
11901: LD_VAR 0 2
11905: PPUSH
11906: CALL_OW 480
11910: ST_TO_ADDR
// if not tmp then
11911: LD_VAR 0 5
11915: NOT
11916: IFFALSE 11920
// exit ;
11918: GO 11969
// for i in tmp do
11920: LD_ADDR_VAR 0 4
11924: PUSH
11925: LD_VAR 0 5
11929: PUSH
11930: FOR_IN
11931: IFFALSE 11967
// if GetTech ( i , side ) <> state_researched then
11933: LD_VAR 0 4
11937: PPUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 321
11947: PUSH
11948: LD_INT 2
11950: NONEQUAL
11951: IFFALSE 11965
// begin result := false ;
11953: LD_ADDR_VAR 0 3
11957: PUSH
11958: LD_INT 0
11960: ST_TO_ADDR
// exit ;
11961: POP
11962: POP
11963: GO 11969
// end ;
11965: GO 11930
11967: POP
11968: POP
// end ;
11969: LD_VAR 0 3
11973: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11974: LD_INT 0
11976: PPUSH
11977: PPUSH
11978: PPUSH
11979: PPUSH
11980: PPUSH
11981: PPUSH
11982: PPUSH
11983: PPUSH
11984: PPUSH
11985: PPUSH
11986: PPUSH
11987: PPUSH
11988: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11989: LD_VAR 0 1
11993: NOT
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 257
12004: PUSH
12005: LD_INT 9
12007: NONEQUAL
12008: OR
12009: IFFALSE 12013
// exit ;
12011: GO 12586
// side := GetSide ( unit ) ;
12013: LD_ADDR_VAR 0 9
12017: PUSH
12018: LD_VAR 0 1
12022: PPUSH
12023: CALL_OW 255
12027: ST_TO_ADDR
// tech_space := tech_spacanom ;
12028: LD_ADDR_VAR 0 12
12032: PUSH
12033: LD_INT 29
12035: ST_TO_ADDR
// tech_time := tech_taurad ;
12036: LD_ADDR_VAR 0 13
12040: PUSH
12041: LD_INT 28
12043: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12044: LD_ADDR_VAR 0 11
12048: PUSH
12049: LD_VAR 0 1
12053: PPUSH
12054: CALL_OW 310
12058: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12059: LD_VAR 0 11
12063: PPUSH
12064: CALL_OW 247
12068: PUSH
12069: LD_INT 2
12071: EQUAL
12072: IFFALSE 12076
// exit ;
12074: GO 12586
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12076: LD_ADDR_VAR 0 8
12080: PUSH
12081: LD_INT 81
12083: PUSH
12084: LD_VAR 0 9
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 3
12095: PUSH
12096: LD_INT 21
12098: PUSH
12099: LD_INT 3
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: ST_TO_ADDR
// if not tmp then
12119: LD_VAR 0 8
12123: NOT
12124: IFFALSE 12128
// exit ;
12126: GO 12586
// if in_unit then
12128: LD_VAR 0 11
12132: IFFALSE 12156
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12134: LD_ADDR_VAR 0 10
12138: PUSH
12139: LD_VAR 0 8
12143: PPUSH
12144: LD_VAR 0 11
12148: PPUSH
12149: CALL_OW 74
12153: ST_TO_ADDR
12154: GO 12176
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12156: LD_ADDR_VAR 0 10
12160: PUSH
12161: LD_VAR 0 8
12165: PPUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL_OW 74
12175: ST_TO_ADDR
// if not enemy then
12176: LD_VAR 0 10
12180: NOT
12181: IFFALSE 12185
// exit ;
12183: GO 12586
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12185: LD_VAR 0 11
12189: PUSH
12190: LD_VAR 0 11
12194: PPUSH
12195: LD_VAR 0 10
12199: PPUSH
12200: CALL_OW 296
12204: PUSH
12205: LD_INT 13
12207: GREATER
12208: AND
12209: PUSH
12210: LD_VAR 0 1
12214: PPUSH
12215: LD_VAR 0 10
12219: PPUSH
12220: CALL_OW 296
12224: PUSH
12225: LD_INT 12
12227: GREATER
12228: OR
12229: IFFALSE 12233
// exit ;
12231: GO 12586
// missile := [ 1 ] ;
12233: LD_ADDR_VAR 0 14
12237: PUSH
12238: LD_INT 1
12240: PUSH
12241: EMPTY
12242: LIST
12243: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12244: LD_VAR 0 9
12248: PPUSH
12249: LD_VAR 0 12
12253: PPUSH
12254: CALL_OW 325
12258: IFFALSE 12287
// missile := Replace ( missile , missile + 1 , 2 ) ;
12260: LD_ADDR_VAR 0 14
12264: PUSH
12265: LD_VAR 0 14
12269: PPUSH
12270: LD_VAR 0 14
12274: PUSH
12275: LD_INT 1
12277: PLUS
12278: PPUSH
12279: LD_INT 2
12281: PPUSH
12282: CALL_OW 1
12286: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12287: LD_VAR 0 9
12291: PPUSH
12292: LD_VAR 0 13
12296: PPUSH
12297: CALL_OW 325
12301: PUSH
12302: LD_VAR 0 10
12306: PPUSH
12307: CALL_OW 255
12311: PPUSH
12312: LD_VAR 0 13
12316: PPUSH
12317: CALL_OW 325
12321: NOT
12322: AND
12323: IFFALSE 12352
// missile := Replace ( missile , missile + 1 , 3 ) ;
12325: LD_ADDR_VAR 0 14
12329: PUSH
12330: LD_VAR 0 14
12334: PPUSH
12335: LD_VAR 0 14
12339: PUSH
12340: LD_INT 1
12342: PLUS
12343: PPUSH
12344: LD_INT 3
12346: PPUSH
12347: CALL_OW 1
12351: ST_TO_ADDR
// if missile < 2 then
12352: LD_VAR 0 14
12356: PUSH
12357: LD_INT 2
12359: LESS
12360: IFFALSE 12364
// exit ;
12362: GO 12586
// x := GetX ( enemy ) ;
12364: LD_ADDR_VAR 0 4
12368: PUSH
12369: LD_VAR 0 10
12373: PPUSH
12374: CALL_OW 250
12378: ST_TO_ADDR
// y := GetY ( enemy ) ;
12379: LD_ADDR_VAR 0 5
12383: PUSH
12384: LD_VAR 0 10
12388: PPUSH
12389: CALL_OW 251
12393: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12394: LD_ADDR_VAR 0 6
12398: PUSH
12399: LD_VAR 0 4
12403: PUSH
12404: LD_INT 1
12406: NEG
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: CALL_OW 12
12415: PLUS
12416: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12417: LD_ADDR_VAR 0 7
12421: PUSH
12422: LD_VAR 0 5
12426: PUSH
12427: LD_INT 1
12429: NEG
12430: PPUSH
12431: LD_INT 1
12433: PPUSH
12434: CALL_OW 12
12438: PLUS
12439: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12440: LD_VAR 0 6
12444: PPUSH
12445: LD_VAR 0 7
12449: PPUSH
12450: CALL_OW 488
12454: NOT
12455: IFFALSE 12477
// begin _x := x ;
12457: LD_ADDR_VAR 0 6
12461: PUSH
12462: LD_VAR 0 4
12466: ST_TO_ADDR
// _y := y ;
12467: LD_ADDR_VAR 0 7
12471: PUSH
12472: LD_VAR 0 5
12476: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12477: LD_ADDR_VAR 0 3
12481: PUSH
12482: LD_INT 1
12484: PPUSH
12485: LD_VAR 0 14
12489: PPUSH
12490: CALL_OW 12
12494: ST_TO_ADDR
// case i of 1 :
12495: LD_VAR 0 3
12499: PUSH
12500: LD_INT 1
12502: DOUBLE
12503: EQUAL
12504: IFTRUE 12508
12506: GO 12525
12508: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12509: LD_VAR 0 1
12513: PPUSH
12514: LD_VAR 0 10
12518: PPUSH
12519: CALL_OW 115
12523: GO 12586
12525: LD_INT 2
12527: DOUBLE
12528: EQUAL
12529: IFTRUE 12533
12531: GO 12555
12533: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12534: LD_VAR 0 1
12538: PPUSH
12539: LD_VAR 0 6
12543: PPUSH
12544: LD_VAR 0 7
12548: PPUSH
12549: CALL_OW 153
12553: GO 12586
12555: LD_INT 3
12557: DOUBLE
12558: EQUAL
12559: IFTRUE 12563
12561: GO 12585
12563: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12564: LD_VAR 0 1
12568: PPUSH
12569: LD_VAR 0 6
12573: PPUSH
12574: LD_VAR 0 7
12578: PPUSH
12579: CALL_OW 154
12583: GO 12586
12585: POP
// end ;
12586: LD_VAR 0 2
12590: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12591: LD_INT 0
12593: PPUSH
12594: PPUSH
12595: PPUSH
12596: PPUSH
12597: PPUSH
12598: PPUSH
// if not unit or not building then
12599: LD_VAR 0 1
12603: NOT
12604: PUSH
12605: LD_VAR 0 2
12609: NOT
12610: OR
12611: IFFALSE 12615
// exit ;
12613: GO 12773
// x := GetX ( building ) ;
12615: LD_ADDR_VAR 0 5
12619: PUSH
12620: LD_VAR 0 2
12624: PPUSH
12625: CALL_OW 250
12629: ST_TO_ADDR
// y := GetY ( building ) ;
12630: LD_ADDR_VAR 0 6
12634: PUSH
12635: LD_VAR 0 2
12639: PPUSH
12640: CALL_OW 251
12644: ST_TO_ADDR
// for i = 0 to 5 do
12645: LD_ADDR_VAR 0 4
12649: PUSH
12650: DOUBLE
12651: LD_INT 0
12653: DEC
12654: ST_TO_ADDR
12655: LD_INT 5
12657: PUSH
12658: FOR_TO
12659: IFFALSE 12771
// begin _x := ShiftX ( x , i , 3 ) ;
12661: LD_ADDR_VAR 0 7
12665: PUSH
12666: LD_VAR 0 5
12670: PPUSH
12671: LD_VAR 0 4
12675: PPUSH
12676: LD_INT 3
12678: PPUSH
12679: CALL_OW 272
12683: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12684: LD_ADDR_VAR 0 8
12688: PUSH
12689: LD_VAR 0 6
12693: PPUSH
12694: LD_VAR 0 4
12698: PPUSH
12699: LD_INT 3
12701: PPUSH
12702: CALL_OW 273
12706: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12707: LD_VAR 0 7
12711: PPUSH
12712: LD_VAR 0 8
12716: PPUSH
12717: CALL_OW 488
12721: NOT
12722: IFFALSE 12726
// continue ;
12724: GO 12658
// if HexInfo ( _x , _y ) = 0 then
12726: LD_VAR 0 7
12730: PPUSH
12731: LD_VAR 0 8
12735: PPUSH
12736: CALL_OW 428
12740: PUSH
12741: LD_INT 0
12743: EQUAL
12744: IFFALSE 12769
// begin ComMoveXY ( unit , _x , _y ) ;
12746: LD_VAR 0 1
12750: PPUSH
12751: LD_VAR 0 7
12755: PPUSH
12756: LD_VAR 0 8
12760: PPUSH
12761: CALL_OW 111
// exit ;
12765: POP
12766: POP
12767: GO 12773
// end ; end ;
12769: GO 12658
12771: POP
12772: POP
// end ;
12773: LD_VAR 0 3
12777: RET
// export function ScanBase ( side , base_area ) ; begin
12778: LD_INT 0
12780: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12781: LD_ADDR_VAR 0 3
12785: PUSH
12786: LD_VAR 0 2
12790: PPUSH
12791: LD_INT 81
12793: PUSH
12794: LD_VAR 0 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PPUSH
12803: CALL_OW 70
12807: ST_TO_ADDR
// end ;
12808: LD_VAR 0 3
12812: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12813: LD_INT 0
12815: PPUSH
12816: PPUSH
12817: PPUSH
12818: PPUSH
// result := false ;
12819: LD_ADDR_VAR 0 2
12823: PUSH
12824: LD_INT 0
12826: ST_TO_ADDR
// side := GetSide ( unit ) ;
12827: LD_ADDR_VAR 0 3
12831: PUSH
12832: LD_VAR 0 1
12836: PPUSH
12837: CALL_OW 255
12841: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12842: LD_ADDR_VAR 0 4
12846: PUSH
12847: LD_VAR 0 1
12851: PPUSH
12852: CALL_OW 248
12856: ST_TO_ADDR
// case nat of 1 :
12857: LD_VAR 0 4
12861: PUSH
12862: LD_INT 1
12864: DOUBLE
12865: EQUAL
12866: IFTRUE 12870
12868: GO 12881
12870: POP
// tech := tech_lassight ; 2 :
12871: LD_ADDR_VAR 0 5
12875: PUSH
12876: LD_INT 12
12878: ST_TO_ADDR
12879: GO 12920
12881: LD_INT 2
12883: DOUBLE
12884: EQUAL
12885: IFTRUE 12889
12887: GO 12900
12889: POP
// tech := tech_mortar ; 3 :
12890: LD_ADDR_VAR 0 5
12894: PUSH
12895: LD_INT 41
12897: ST_TO_ADDR
12898: GO 12920
12900: LD_INT 3
12902: DOUBLE
12903: EQUAL
12904: IFTRUE 12908
12906: GO 12919
12908: POP
// tech := tech_bazooka ; end ;
12909: LD_ADDR_VAR 0 5
12913: PUSH
12914: LD_INT 44
12916: ST_TO_ADDR
12917: GO 12920
12919: POP
// if Researched ( side , tech ) then
12920: LD_VAR 0 3
12924: PPUSH
12925: LD_VAR 0 5
12929: PPUSH
12930: CALL_OW 325
12934: IFFALSE 12961
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12936: LD_ADDR_VAR 0 2
12940: PUSH
12941: LD_INT 5
12943: PUSH
12944: LD_INT 8
12946: PUSH
12947: LD_INT 9
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: LIST
12954: PUSH
12955: LD_VAR 0 4
12959: ARRAY
12960: ST_TO_ADDR
// end ;
12961: LD_VAR 0 2
12965: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12966: LD_INT 0
12968: PPUSH
12969: PPUSH
12970: PPUSH
// if not mines then
12971: LD_VAR 0 2
12975: NOT
12976: IFFALSE 12980
// exit ;
12978: GO 13124
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12980: LD_ADDR_VAR 0 5
12984: PUSH
12985: LD_INT 81
12987: PUSH
12988: LD_VAR 0 1
12992: PUSH
12993: EMPTY
12994: LIST
12995: LIST
12996: PUSH
12997: LD_INT 3
12999: PUSH
13000: LD_INT 21
13002: PUSH
13003: LD_INT 3
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: PPUSH
13018: CALL_OW 69
13022: ST_TO_ADDR
// for i in mines do
13023: LD_ADDR_VAR 0 4
13027: PUSH
13028: LD_VAR 0 2
13032: PUSH
13033: FOR_IN
13034: IFFALSE 13122
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13036: LD_VAR 0 4
13040: PUSH
13041: LD_INT 1
13043: ARRAY
13044: PPUSH
13045: LD_VAR 0 4
13049: PUSH
13050: LD_INT 2
13052: ARRAY
13053: PPUSH
13054: CALL_OW 458
13058: NOT
13059: IFFALSE 13063
// continue ;
13061: GO 13033
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13063: LD_VAR 0 4
13067: PUSH
13068: LD_INT 1
13070: ARRAY
13071: PPUSH
13072: LD_VAR 0 4
13076: PUSH
13077: LD_INT 2
13079: ARRAY
13080: PPUSH
13081: CALL_OW 428
13085: PUSH
13086: LD_VAR 0 5
13090: IN
13091: IFFALSE 13120
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13093: LD_VAR 0 4
13097: PUSH
13098: LD_INT 1
13100: ARRAY
13101: PPUSH
13102: LD_VAR 0 4
13106: PUSH
13107: LD_INT 2
13109: ARRAY
13110: PPUSH
13111: LD_VAR 0 1
13115: PPUSH
13116: CALL_OW 456
// end ;
13120: GO 13033
13122: POP
13123: POP
// end ;
13124: LD_VAR 0 3
13128: RET
// export function Count ( array ) ; var i ; begin
13129: LD_INT 0
13131: PPUSH
13132: PPUSH
// result := 0 ;
13133: LD_ADDR_VAR 0 2
13137: PUSH
13138: LD_INT 0
13140: ST_TO_ADDR
// for i in array do
13141: LD_ADDR_VAR 0 3
13145: PUSH
13146: LD_VAR 0 1
13150: PUSH
13151: FOR_IN
13152: IFFALSE 13176
// if i then
13154: LD_VAR 0 3
13158: IFFALSE 13174
// result := result + 1 ;
13160: LD_ADDR_VAR 0 2
13164: PUSH
13165: LD_VAR 0 2
13169: PUSH
13170: LD_INT 1
13172: PLUS
13173: ST_TO_ADDR
13174: GO 13151
13176: POP
13177: POP
// end ;
13178: LD_VAR 0 2
13182: RET
// export function IsEmpty ( building ) ; begin
13183: LD_INT 0
13185: PPUSH
// if not building then
13186: LD_VAR 0 1
13190: NOT
13191: IFFALSE 13195
// exit ;
13193: GO 13238
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13195: LD_ADDR_VAR 0 2
13199: PUSH
13200: LD_VAR 0 1
13204: PUSH
13205: LD_INT 22
13207: PUSH
13208: LD_VAR 0 1
13212: PPUSH
13213: CALL_OW 255
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: LD_INT 58
13224: PUSH
13225: EMPTY
13226: LIST
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PPUSH
13232: CALL_OW 69
13236: IN
13237: ST_TO_ADDR
// end ;
13238: LD_VAR 0 2
13242: RET
// export function IsNotFull ( building ) ; begin
13243: LD_INT 0
13245: PPUSH
// if not building then
13246: LD_VAR 0 1
13250: NOT
13251: IFFALSE 13255
// exit ;
13253: GO 13274
// result := UnitsInside ( building ) < 6 ;
13255: LD_ADDR_VAR 0 2
13259: PUSH
13260: LD_VAR 0 1
13264: PPUSH
13265: CALL_OW 313
13269: PUSH
13270: LD_INT 6
13272: LESS
13273: ST_TO_ADDR
// end ;
13274: LD_VAR 0 2
13278: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13279: LD_INT 0
13281: PPUSH
13282: PPUSH
13283: PPUSH
13284: PPUSH
// tmp := [ ] ;
13285: LD_ADDR_VAR 0 3
13289: PUSH
13290: EMPTY
13291: ST_TO_ADDR
// list := [ ] ;
13292: LD_ADDR_VAR 0 5
13296: PUSH
13297: EMPTY
13298: ST_TO_ADDR
// for i = 16 to 25 do
13299: LD_ADDR_VAR 0 4
13303: PUSH
13304: DOUBLE
13305: LD_INT 16
13307: DEC
13308: ST_TO_ADDR
13309: LD_INT 25
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13386
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13315: LD_ADDR_VAR 0 3
13319: PUSH
13320: LD_VAR 0 3
13324: PUSH
13325: LD_INT 22
13327: PUSH
13328: LD_VAR 0 1
13332: PPUSH
13333: CALL_OW 255
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: PUSH
13342: LD_INT 91
13344: PUSH
13345: LD_VAR 0 1
13349: PUSH
13350: LD_INT 6
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: LIST
13357: PUSH
13358: LD_INT 30
13360: PUSH
13361: LD_VAR 0 4
13365: PUSH
13366: EMPTY
13367: LIST
13368: LIST
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: PPUSH
13378: CALL_OW 69
13382: ADD
13383: ST_TO_ADDR
13384: GO 13312
13386: POP
13387: POP
// for i = 1 to tmp do
13388: LD_ADDR_VAR 0 4
13392: PUSH
13393: DOUBLE
13394: LD_INT 1
13396: DEC
13397: ST_TO_ADDR
13398: LD_VAR 0 3
13402: PUSH
13403: FOR_TO
13404: IFFALSE 13492
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13406: LD_ADDR_VAR 0 5
13410: PUSH
13411: LD_VAR 0 5
13415: PUSH
13416: LD_VAR 0 3
13420: PUSH
13421: LD_VAR 0 4
13425: ARRAY
13426: PPUSH
13427: CALL_OW 266
13431: PUSH
13432: LD_VAR 0 3
13436: PUSH
13437: LD_VAR 0 4
13441: ARRAY
13442: PPUSH
13443: CALL_OW 250
13447: PUSH
13448: LD_VAR 0 3
13452: PUSH
13453: LD_VAR 0 4
13457: ARRAY
13458: PPUSH
13459: CALL_OW 251
13463: PUSH
13464: LD_VAR 0 3
13468: PUSH
13469: LD_VAR 0 4
13473: ARRAY
13474: PPUSH
13475: CALL_OW 254
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: PUSH
13486: EMPTY
13487: LIST
13488: ADD
13489: ST_TO_ADDR
13490: GO 13403
13492: POP
13493: POP
// result := list ;
13494: LD_ADDR_VAR 0 2
13498: PUSH
13499: LD_VAR 0 5
13503: ST_TO_ADDR
// end ;
13504: LD_VAR 0 2
13508: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13509: LD_INT 0
13511: PPUSH
13512: PPUSH
13513: PPUSH
13514: PPUSH
13515: PPUSH
13516: PPUSH
13517: PPUSH
// if not factory then
13518: LD_VAR 0 1
13522: NOT
13523: IFFALSE 13527
// exit ;
13525: GO 14120
// if control = control_apeman then
13527: LD_VAR 0 4
13531: PUSH
13532: LD_INT 5
13534: EQUAL
13535: IFFALSE 13644
// begin tmp := UnitsInside ( factory ) ;
13537: LD_ADDR_VAR 0 8
13541: PUSH
13542: LD_VAR 0 1
13546: PPUSH
13547: CALL_OW 313
13551: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13552: LD_VAR 0 8
13556: PPUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 12
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PPUSH
13567: CALL_OW 72
13571: NOT
13572: IFFALSE 13582
// control := control_manual ;
13574: LD_ADDR_VAR 0 4
13578: PUSH
13579: LD_INT 1
13581: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13582: LD_ADDR_VAR 0 8
13586: PUSH
13587: LD_VAR 0 1
13591: PPUSH
13592: CALL 13279 0 1
13596: ST_TO_ADDR
// if tmp then
13597: LD_VAR 0 8
13601: IFFALSE 13644
// begin for i in tmp do
13603: LD_ADDR_VAR 0 7
13607: PUSH
13608: LD_VAR 0 8
13612: PUSH
13613: FOR_IN
13614: IFFALSE 13642
// if i [ 1 ] = b_ext_radio then
13616: LD_VAR 0 7
13620: PUSH
13621: LD_INT 1
13623: ARRAY
13624: PUSH
13625: LD_INT 22
13627: EQUAL
13628: IFFALSE 13640
// begin control := control_remote ;
13630: LD_ADDR_VAR 0 4
13634: PUSH
13635: LD_INT 2
13637: ST_TO_ADDR
// break ;
13638: GO 13642
// end ;
13640: GO 13613
13642: POP
13643: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13644: LD_VAR 0 1
13648: PPUSH
13649: LD_VAR 0 2
13653: PPUSH
13654: LD_VAR 0 3
13658: PPUSH
13659: LD_VAR 0 4
13663: PPUSH
13664: LD_VAR 0 5
13668: PPUSH
13669: CALL_OW 448
13673: IFFALSE 13708
// begin result := [ chassis , engine , control , weapon ] ;
13675: LD_ADDR_VAR 0 6
13679: PUSH
13680: LD_VAR 0 2
13684: PUSH
13685: LD_VAR 0 3
13689: PUSH
13690: LD_VAR 0 4
13694: PUSH
13695: LD_VAR 0 5
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: ST_TO_ADDR
// exit ;
13706: GO 14120
// end ; _chassis := AvailableChassisList ( factory ) ;
13708: LD_ADDR_VAR 0 9
13712: PUSH
13713: LD_VAR 0 1
13717: PPUSH
13718: CALL_OW 475
13722: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13723: LD_ADDR_VAR 0 11
13727: PUSH
13728: LD_VAR 0 1
13732: PPUSH
13733: CALL_OW 476
13737: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13738: LD_ADDR_VAR 0 12
13742: PUSH
13743: LD_VAR 0 1
13747: PPUSH
13748: CALL_OW 477
13752: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13753: LD_ADDR_VAR 0 10
13757: PUSH
13758: LD_VAR 0 1
13762: PPUSH
13763: CALL_OW 478
13767: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13768: LD_VAR 0 9
13772: NOT
13773: PUSH
13774: LD_VAR 0 11
13778: NOT
13779: OR
13780: PUSH
13781: LD_VAR 0 12
13785: NOT
13786: OR
13787: PUSH
13788: LD_VAR 0 10
13792: NOT
13793: OR
13794: IFFALSE 13829
// begin result := [ chassis , engine , control , weapon ] ;
13796: LD_ADDR_VAR 0 6
13800: PUSH
13801: LD_VAR 0 2
13805: PUSH
13806: LD_VAR 0 3
13810: PUSH
13811: LD_VAR 0 4
13815: PUSH
13816: LD_VAR 0 5
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: ST_TO_ADDR
// exit ;
13827: GO 14120
// end ; if not chassis in _chassis then
13829: LD_VAR 0 2
13833: PUSH
13834: LD_VAR 0 9
13838: IN
13839: NOT
13840: IFFALSE 13866
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13842: LD_ADDR_VAR 0 2
13846: PUSH
13847: LD_VAR 0 9
13851: PUSH
13852: LD_INT 1
13854: PPUSH
13855: LD_VAR 0 9
13859: PPUSH
13860: CALL_OW 12
13864: ARRAY
13865: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13866: LD_VAR 0 2
13870: PPUSH
13871: LD_VAR 0 3
13875: PPUSH
13876: CALL 14125 0 2
13880: NOT
13881: IFFALSE 13940
// repeat engine := _engine [ 1 ] ;
13883: LD_ADDR_VAR 0 3
13887: PUSH
13888: LD_VAR 0 11
13892: PUSH
13893: LD_INT 1
13895: ARRAY
13896: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13897: LD_ADDR_VAR 0 11
13901: PUSH
13902: LD_VAR 0 11
13906: PPUSH
13907: LD_INT 1
13909: PPUSH
13910: CALL_OW 3
13914: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13915: LD_VAR 0 2
13919: PPUSH
13920: LD_VAR 0 3
13924: PPUSH
13925: CALL 14125 0 2
13929: PUSH
13930: LD_VAR 0 11
13934: PUSH
13935: EMPTY
13936: EQUAL
13937: OR
13938: IFFALSE 13883
// if not control in _control then
13940: LD_VAR 0 4
13944: PUSH
13945: LD_VAR 0 12
13949: IN
13950: NOT
13951: IFFALSE 13977
// control := _control [ rand ( 1 , _control ) ] ;
13953: LD_ADDR_VAR 0 4
13957: PUSH
13958: LD_VAR 0 12
13962: PUSH
13963: LD_INT 1
13965: PPUSH
13966: LD_VAR 0 12
13970: PPUSH
13971: CALL_OW 12
13975: ARRAY
13976: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
13977: LD_VAR 0 2
13981: PPUSH
13982: LD_VAR 0 5
13986: PPUSH
13987: CALL 14345 0 2
13991: NOT
13992: IFFALSE 14051
// repeat weapon := _weapon [ 1 ] ;
13994: LD_ADDR_VAR 0 5
13998: PUSH
13999: LD_VAR 0 10
14003: PUSH
14004: LD_INT 1
14006: ARRAY
14007: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14008: LD_ADDR_VAR 0 10
14012: PUSH
14013: LD_VAR 0 10
14017: PPUSH
14018: LD_INT 1
14020: PPUSH
14021: CALL_OW 3
14025: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14026: LD_VAR 0 2
14030: PPUSH
14031: LD_VAR 0 5
14035: PPUSH
14036: CALL 14345 0 2
14040: PUSH
14041: LD_VAR 0 10
14045: PUSH
14046: EMPTY
14047: EQUAL
14048: OR
14049: IFFALSE 13994
// result := [ ] ;
14051: LD_ADDR_VAR 0 6
14055: PUSH
14056: EMPTY
14057: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14058: LD_VAR 0 1
14062: PPUSH
14063: LD_VAR 0 2
14067: PPUSH
14068: LD_VAR 0 3
14072: PPUSH
14073: LD_VAR 0 4
14077: PPUSH
14078: LD_VAR 0 5
14082: PPUSH
14083: CALL_OW 448
14087: IFFALSE 14120
// result := [ chassis , engine , control , weapon ] ;
14089: LD_ADDR_VAR 0 6
14093: PUSH
14094: LD_VAR 0 2
14098: PUSH
14099: LD_VAR 0 3
14103: PUSH
14104: LD_VAR 0 4
14108: PUSH
14109: LD_VAR 0 5
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: ST_TO_ADDR
// end ;
14120: LD_VAR 0 6
14124: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14125: LD_INT 0
14127: PPUSH
// if not chassis or not engine then
14128: LD_VAR 0 1
14132: NOT
14133: PUSH
14134: LD_VAR 0 2
14138: NOT
14139: OR
14140: IFFALSE 14144
// exit ;
14142: GO 14340
// case engine of engine_solar :
14144: LD_VAR 0 2
14148: PUSH
14149: LD_INT 2
14151: DOUBLE
14152: EQUAL
14153: IFTRUE 14157
14155: GO 14195
14157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14158: LD_ADDR_VAR 0 3
14162: PUSH
14163: LD_INT 11
14165: PUSH
14166: LD_INT 12
14168: PUSH
14169: LD_INT 13
14171: PUSH
14172: LD_INT 14
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: LD_INT 3
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: LIST
14192: ST_TO_ADDR
14193: GO 14324
14195: LD_INT 1
14197: DOUBLE
14198: EQUAL
14199: IFTRUE 14203
14201: GO 14265
14203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14204: LD_ADDR_VAR 0 3
14208: PUSH
14209: LD_INT 11
14211: PUSH
14212: LD_INT 12
14214: PUSH
14215: LD_INT 13
14217: PUSH
14218: LD_INT 14
14220: PUSH
14221: LD_INT 1
14223: PUSH
14224: LD_INT 2
14226: PUSH
14227: LD_INT 3
14229: PUSH
14230: LD_INT 4
14232: PUSH
14233: LD_INT 5
14235: PUSH
14236: LD_INT 21
14238: PUSH
14239: LD_INT 23
14241: PUSH
14242: LD_INT 22
14244: PUSH
14245: LD_INT 24
14247: PUSH
14248: EMPTY
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: ST_TO_ADDR
14263: GO 14324
14265: LD_INT 3
14267: DOUBLE
14268: EQUAL
14269: IFTRUE 14273
14271: GO 14323
14273: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14274: LD_ADDR_VAR 0 3
14278: PUSH
14279: LD_INT 13
14281: PUSH
14282: LD_INT 14
14284: PUSH
14285: LD_INT 2
14287: PUSH
14288: LD_INT 3
14290: PUSH
14291: LD_INT 4
14293: PUSH
14294: LD_INT 5
14296: PUSH
14297: LD_INT 21
14299: PUSH
14300: LD_INT 22
14302: PUSH
14303: LD_INT 23
14305: PUSH
14306: LD_INT 24
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: LIST
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: ST_TO_ADDR
14321: GO 14324
14323: POP
// result := ( chassis in result ) ;
14324: LD_ADDR_VAR 0 3
14328: PUSH
14329: LD_VAR 0 1
14333: PUSH
14334: LD_VAR 0 3
14338: IN
14339: ST_TO_ADDR
// end ;
14340: LD_VAR 0 3
14344: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14345: LD_INT 0
14347: PPUSH
// if not chassis or not weapon then
14348: LD_VAR 0 1
14352: NOT
14353: PUSH
14354: LD_VAR 0 2
14358: NOT
14359: OR
14360: IFFALSE 14364
// exit ;
14362: GO 15426
// case weapon of us_machine_gun :
14364: LD_VAR 0 2
14368: PUSH
14369: LD_INT 2
14371: DOUBLE
14372: EQUAL
14373: IFTRUE 14377
14375: GO 14407
14377: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14378: LD_ADDR_VAR 0 3
14382: PUSH
14383: LD_INT 1
14385: PUSH
14386: LD_INT 2
14388: PUSH
14389: LD_INT 3
14391: PUSH
14392: LD_INT 4
14394: PUSH
14395: LD_INT 5
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: ST_TO_ADDR
14405: GO 15410
14407: LD_INT 3
14409: DOUBLE
14410: EQUAL
14411: IFTRUE 14415
14413: GO 14445
14415: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14416: LD_ADDR_VAR 0 3
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 3
14429: PUSH
14430: LD_INT 4
14432: PUSH
14433: LD_INT 5
14435: PUSH
14436: EMPTY
14437: LIST
14438: LIST
14439: LIST
14440: LIST
14441: LIST
14442: ST_TO_ADDR
14443: GO 15410
14445: LD_INT 11
14447: DOUBLE
14448: EQUAL
14449: IFTRUE 14453
14451: GO 14483
14453: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14454: LD_ADDR_VAR 0 3
14458: PUSH
14459: LD_INT 1
14461: PUSH
14462: LD_INT 2
14464: PUSH
14465: LD_INT 3
14467: PUSH
14468: LD_INT 4
14470: PUSH
14471: LD_INT 5
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: ST_TO_ADDR
14481: GO 15410
14483: LD_INT 4
14485: DOUBLE
14486: EQUAL
14487: IFTRUE 14491
14489: GO 14517
14491: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14492: LD_ADDR_VAR 0 3
14496: PUSH
14497: LD_INT 2
14499: PUSH
14500: LD_INT 3
14502: PUSH
14503: LD_INT 4
14505: PUSH
14506: LD_INT 5
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: ST_TO_ADDR
14515: GO 15410
14517: LD_INT 5
14519: DOUBLE
14520: EQUAL
14521: IFTRUE 14525
14523: GO 14551
14525: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14526: LD_ADDR_VAR 0 3
14530: PUSH
14531: LD_INT 2
14533: PUSH
14534: LD_INT 3
14536: PUSH
14537: LD_INT 4
14539: PUSH
14540: LD_INT 5
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: ST_TO_ADDR
14549: GO 15410
14551: LD_INT 9
14553: DOUBLE
14554: EQUAL
14555: IFTRUE 14559
14557: GO 14585
14559: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14560: LD_ADDR_VAR 0 3
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: LD_INT 3
14570: PUSH
14571: LD_INT 4
14573: PUSH
14574: LD_INT 5
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: ST_TO_ADDR
14583: GO 15410
14585: LD_INT 7
14587: DOUBLE
14588: EQUAL
14589: IFTRUE 14593
14591: GO 14619
14593: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14594: LD_ADDR_VAR 0 3
14598: PUSH
14599: LD_INT 2
14601: PUSH
14602: LD_INT 3
14604: PUSH
14605: LD_INT 4
14607: PUSH
14608: LD_INT 5
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: ST_TO_ADDR
14617: GO 15410
14619: LD_INT 12
14621: DOUBLE
14622: EQUAL
14623: IFTRUE 14627
14625: GO 14653
14627: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: LD_INT 2
14635: PUSH
14636: LD_INT 3
14638: PUSH
14639: LD_INT 4
14641: PUSH
14642: LD_INT 5
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: ST_TO_ADDR
14651: GO 15410
14653: LD_INT 13
14655: DOUBLE
14656: EQUAL
14657: IFTRUE 14661
14659: GO 14687
14661: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14662: LD_ADDR_VAR 0 3
14666: PUSH
14667: LD_INT 2
14669: PUSH
14670: LD_INT 3
14672: PUSH
14673: LD_INT 4
14675: PUSH
14676: LD_INT 5
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: ST_TO_ADDR
14685: GO 15410
14687: LD_INT 14
14689: DOUBLE
14690: EQUAL
14691: IFTRUE 14695
14693: GO 14713
14695: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14696: LD_ADDR_VAR 0 3
14700: PUSH
14701: LD_INT 4
14703: PUSH
14704: LD_INT 5
14706: PUSH
14707: EMPTY
14708: LIST
14709: LIST
14710: ST_TO_ADDR
14711: GO 15410
14713: LD_INT 6
14715: DOUBLE
14716: EQUAL
14717: IFTRUE 14721
14719: GO 14739
14721: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14722: LD_ADDR_VAR 0 3
14726: PUSH
14727: LD_INT 4
14729: PUSH
14730: LD_INT 5
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: ST_TO_ADDR
14737: GO 15410
14739: LD_INT 10
14741: DOUBLE
14742: EQUAL
14743: IFTRUE 14747
14745: GO 14765
14747: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14748: LD_ADDR_VAR 0 3
14752: PUSH
14753: LD_INT 4
14755: PUSH
14756: LD_INT 5
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: ST_TO_ADDR
14763: GO 15410
14765: LD_INT 22
14767: DOUBLE
14768: EQUAL
14769: IFTRUE 14773
14771: GO 14799
14773: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14774: LD_ADDR_VAR 0 3
14778: PUSH
14779: LD_INT 11
14781: PUSH
14782: LD_INT 12
14784: PUSH
14785: LD_INT 13
14787: PUSH
14788: LD_INT 14
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: ST_TO_ADDR
14797: GO 15410
14799: LD_INT 23
14801: DOUBLE
14802: EQUAL
14803: IFTRUE 14807
14805: GO 14833
14807: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14808: LD_ADDR_VAR 0 3
14812: PUSH
14813: LD_INT 11
14815: PUSH
14816: LD_INT 12
14818: PUSH
14819: LD_INT 13
14821: PUSH
14822: LD_INT 14
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: ST_TO_ADDR
14831: GO 15410
14833: LD_INT 24
14835: DOUBLE
14836: EQUAL
14837: IFTRUE 14841
14839: GO 14867
14841: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14842: LD_ADDR_VAR 0 3
14846: PUSH
14847: LD_INT 11
14849: PUSH
14850: LD_INT 12
14852: PUSH
14853: LD_INT 13
14855: PUSH
14856: LD_INT 14
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: ST_TO_ADDR
14865: GO 15410
14867: LD_INT 30
14869: DOUBLE
14870: EQUAL
14871: IFTRUE 14875
14873: GO 14901
14875: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14876: LD_ADDR_VAR 0 3
14880: PUSH
14881: LD_INT 11
14883: PUSH
14884: LD_INT 12
14886: PUSH
14887: LD_INT 13
14889: PUSH
14890: LD_INT 14
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: ST_TO_ADDR
14899: GO 15410
14901: LD_INT 25
14903: DOUBLE
14904: EQUAL
14905: IFTRUE 14909
14907: GO 14927
14909: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14910: LD_ADDR_VAR 0 3
14914: PUSH
14915: LD_INT 13
14917: PUSH
14918: LD_INT 14
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: ST_TO_ADDR
14925: GO 15410
14927: LD_INT 27
14929: DOUBLE
14930: EQUAL
14931: IFTRUE 14935
14933: GO 14953
14935: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
14936: LD_ADDR_VAR 0 3
14940: PUSH
14941: LD_INT 13
14943: PUSH
14944: LD_INT 14
14946: PUSH
14947: EMPTY
14948: LIST
14949: LIST
14950: ST_TO_ADDR
14951: GO 15410
14953: LD_EXP 72
14957: DOUBLE
14958: EQUAL
14959: IFTRUE 14963
14961: GO 14989
14963: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
14964: LD_ADDR_VAR 0 3
14968: PUSH
14969: LD_INT 11
14971: PUSH
14972: LD_INT 12
14974: PUSH
14975: LD_INT 13
14977: PUSH
14978: LD_INT 14
14980: PUSH
14981: EMPTY
14982: LIST
14983: LIST
14984: LIST
14985: LIST
14986: ST_TO_ADDR
14987: GO 15410
14989: LD_INT 28
14991: DOUBLE
14992: EQUAL
14993: IFTRUE 14997
14995: GO 15015
14997: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
14998: LD_ADDR_VAR 0 3
15002: PUSH
15003: LD_INT 13
15005: PUSH
15006: LD_INT 14
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: ST_TO_ADDR
15013: GO 15410
15015: LD_INT 29
15017: DOUBLE
15018: EQUAL
15019: IFTRUE 15023
15021: GO 15041
15023: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15024: LD_ADDR_VAR 0 3
15028: PUSH
15029: LD_INT 13
15031: PUSH
15032: LD_INT 14
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: ST_TO_ADDR
15039: GO 15410
15041: LD_INT 31
15043: DOUBLE
15044: EQUAL
15045: IFTRUE 15049
15047: GO 15067
15049: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 13
15057: PUSH
15058: LD_INT 14
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: ST_TO_ADDR
15065: GO 15410
15067: LD_INT 26
15069: DOUBLE
15070: EQUAL
15071: IFTRUE 15075
15073: GO 15093
15075: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15076: LD_ADDR_VAR 0 3
15080: PUSH
15081: LD_INT 13
15083: PUSH
15084: LD_INT 14
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: ST_TO_ADDR
15091: GO 15410
15093: LD_INT 42
15095: DOUBLE
15096: EQUAL
15097: IFTRUE 15101
15099: GO 15127
15101: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15102: LD_ADDR_VAR 0 3
15106: PUSH
15107: LD_INT 21
15109: PUSH
15110: LD_INT 22
15112: PUSH
15113: LD_INT 23
15115: PUSH
15116: LD_INT 24
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: LIST
15123: LIST
15124: ST_TO_ADDR
15125: GO 15410
15127: LD_INT 43
15129: DOUBLE
15130: EQUAL
15131: IFTRUE 15135
15133: GO 15161
15135: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15136: LD_ADDR_VAR 0 3
15140: PUSH
15141: LD_INT 21
15143: PUSH
15144: LD_INT 22
15146: PUSH
15147: LD_INT 23
15149: PUSH
15150: LD_INT 24
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: ST_TO_ADDR
15159: GO 15410
15161: LD_INT 44
15163: DOUBLE
15164: EQUAL
15165: IFTRUE 15169
15167: GO 15195
15169: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15170: LD_ADDR_VAR 0 3
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 22
15180: PUSH
15181: LD_INT 23
15183: PUSH
15184: LD_INT 24
15186: PUSH
15187: EMPTY
15188: LIST
15189: LIST
15190: LIST
15191: LIST
15192: ST_TO_ADDR
15193: GO 15410
15195: LD_INT 45
15197: DOUBLE
15198: EQUAL
15199: IFTRUE 15203
15201: GO 15229
15203: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15204: LD_ADDR_VAR 0 3
15208: PUSH
15209: LD_INT 21
15211: PUSH
15212: LD_INT 22
15214: PUSH
15215: LD_INT 23
15217: PUSH
15218: LD_INT 24
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: ST_TO_ADDR
15227: GO 15410
15229: LD_INT 49
15231: DOUBLE
15232: EQUAL
15233: IFTRUE 15237
15235: GO 15263
15237: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15238: LD_ADDR_VAR 0 3
15242: PUSH
15243: LD_INT 21
15245: PUSH
15246: LD_INT 22
15248: PUSH
15249: LD_INT 23
15251: PUSH
15252: LD_INT 24
15254: PUSH
15255: EMPTY
15256: LIST
15257: LIST
15258: LIST
15259: LIST
15260: ST_TO_ADDR
15261: GO 15410
15263: LD_INT 51
15265: DOUBLE
15266: EQUAL
15267: IFTRUE 15271
15269: GO 15297
15271: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 21
15279: PUSH
15280: LD_INT 22
15282: PUSH
15283: LD_INT 23
15285: PUSH
15286: LD_INT 24
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: LIST
15293: LIST
15294: ST_TO_ADDR
15295: GO 15410
15297: LD_INT 52
15299: DOUBLE
15300: EQUAL
15301: IFTRUE 15305
15303: GO 15331
15305: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15306: LD_ADDR_VAR 0 3
15310: PUSH
15311: LD_INT 21
15313: PUSH
15314: LD_INT 22
15316: PUSH
15317: LD_INT 23
15319: PUSH
15320: LD_INT 24
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: ST_TO_ADDR
15329: GO 15410
15331: LD_INT 53
15333: DOUBLE
15334: EQUAL
15335: IFTRUE 15339
15337: GO 15357
15339: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15340: LD_ADDR_VAR 0 3
15344: PUSH
15345: LD_INT 23
15347: PUSH
15348: LD_INT 24
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: ST_TO_ADDR
15355: GO 15410
15357: LD_INT 46
15359: DOUBLE
15360: EQUAL
15361: IFTRUE 15365
15363: GO 15383
15365: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15366: LD_ADDR_VAR 0 3
15370: PUSH
15371: LD_INT 23
15373: PUSH
15374: LD_INT 24
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: ST_TO_ADDR
15381: GO 15410
15383: LD_INT 47
15385: DOUBLE
15386: EQUAL
15387: IFTRUE 15391
15389: GO 15409
15391: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15392: LD_ADDR_VAR 0 3
15396: PUSH
15397: LD_INT 23
15399: PUSH
15400: LD_INT 24
15402: PUSH
15403: EMPTY
15404: LIST
15405: LIST
15406: ST_TO_ADDR
15407: GO 15410
15409: POP
// result := ( chassis in result ) ;
15410: LD_ADDR_VAR 0 3
15414: PUSH
15415: LD_VAR 0 1
15419: PUSH
15420: LD_VAR 0 3
15424: IN
15425: ST_TO_ADDR
// end ;
15426: LD_VAR 0 3
15430: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15431: LD_INT 0
15433: PPUSH
15434: PPUSH
15435: PPUSH
15436: PPUSH
15437: PPUSH
15438: PPUSH
15439: PPUSH
// result := array ;
15440: LD_ADDR_VAR 0 5
15444: PUSH
15445: LD_VAR 0 1
15449: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15450: LD_VAR 0 1
15454: NOT
15455: PUSH
15456: LD_VAR 0 2
15460: NOT
15461: OR
15462: PUSH
15463: LD_VAR 0 3
15467: NOT
15468: OR
15469: PUSH
15470: LD_VAR 0 2
15474: PUSH
15475: LD_VAR 0 1
15479: GREATER
15480: OR
15481: PUSH
15482: LD_VAR 0 3
15486: PUSH
15487: LD_VAR 0 1
15491: GREATER
15492: OR
15493: IFFALSE 15497
// exit ;
15495: GO 15793
// if direction then
15497: LD_VAR 0 4
15501: IFFALSE 15565
// begin d := 1 ;
15503: LD_ADDR_VAR 0 9
15507: PUSH
15508: LD_INT 1
15510: ST_TO_ADDR
// if i_from > i_to then
15511: LD_VAR 0 2
15515: PUSH
15516: LD_VAR 0 3
15520: GREATER
15521: IFFALSE 15547
// length := ( array - i_from ) + i_to else
15523: LD_ADDR_VAR 0 11
15527: PUSH
15528: LD_VAR 0 1
15532: PUSH
15533: LD_VAR 0 2
15537: MINUS
15538: PUSH
15539: LD_VAR 0 3
15543: PLUS
15544: ST_TO_ADDR
15545: GO 15563
// length := i_to - i_from ;
15547: LD_ADDR_VAR 0 11
15551: PUSH
15552: LD_VAR 0 3
15556: PUSH
15557: LD_VAR 0 2
15561: MINUS
15562: ST_TO_ADDR
// end else
15563: GO 15626
// begin d := - 1 ;
15565: LD_ADDR_VAR 0 9
15569: PUSH
15570: LD_INT 1
15572: NEG
15573: ST_TO_ADDR
// if i_from > i_to then
15574: LD_VAR 0 2
15578: PUSH
15579: LD_VAR 0 3
15583: GREATER
15584: IFFALSE 15604
// length := i_from - i_to else
15586: LD_ADDR_VAR 0 11
15590: PUSH
15591: LD_VAR 0 2
15595: PUSH
15596: LD_VAR 0 3
15600: MINUS
15601: ST_TO_ADDR
15602: GO 15626
// length := ( array - i_to ) + i_from ;
15604: LD_ADDR_VAR 0 11
15608: PUSH
15609: LD_VAR 0 1
15613: PUSH
15614: LD_VAR 0 3
15618: MINUS
15619: PUSH
15620: LD_VAR 0 2
15624: PLUS
15625: ST_TO_ADDR
// end ; if not length then
15626: LD_VAR 0 11
15630: NOT
15631: IFFALSE 15635
// exit ;
15633: GO 15793
// tmp := array ;
15635: LD_ADDR_VAR 0 10
15639: PUSH
15640: LD_VAR 0 1
15644: ST_TO_ADDR
// for i = 1 to length do
15645: LD_ADDR_VAR 0 6
15649: PUSH
15650: DOUBLE
15651: LD_INT 1
15653: DEC
15654: ST_TO_ADDR
15655: LD_VAR 0 11
15659: PUSH
15660: FOR_TO
15661: IFFALSE 15781
// begin for j = 1 to array do
15663: LD_ADDR_VAR 0 7
15667: PUSH
15668: DOUBLE
15669: LD_INT 1
15671: DEC
15672: ST_TO_ADDR
15673: LD_VAR 0 1
15677: PUSH
15678: FOR_TO
15679: IFFALSE 15767
// begin k := j + d ;
15681: LD_ADDR_VAR 0 8
15685: PUSH
15686: LD_VAR 0 7
15690: PUSH
15691: LD_VAR 0 9
15695: PLUS
15696: ST_TO_ADDR
// if k > array then
15697: LD_VAR 0 8
15701: PUSH
15702: LD_VAR 0 1
15706: GREATER
15707: IFFALSE 15717
// k := 1 ;
15709: LD_ADDR_VAR 0 8
15713: PUSH
15714: LD_INT 1
15716: ST_TO_ADDR
// if not k then
15717: LD_VAR 0 8
15721: NOT
15722: IFFALSE 15734
// k := array ;
15724: LD_ADDR_VAR 0 8
15728: PUSH
15729: LD_VAR 0 1
15733: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15734: LD_ADDR_VAR 0 10
15738: PUSH
15739: LD_VAR 0 10
15743: PPUSH
15744: LD_VAR 0 8
15748: PPUSH
15749: LD_VAR 0 1
15753: PUSH
15754: LD_VAR 0 7
15758: ARRAY
15759: PPUSH
15760: CALL_OW 1
15764: ST_TO_ADDR
// end ;
15765: GO 15678
15767: POP
15768: POP
// array := tmp ;
15769: LD_ADDR_VAR 0 1
15773: PUSH
15774: LD_VAR 0 10
15778: ST_TO_ADDR
// end ;
15779: GO 15660
15781: POP
15782: POP
// result := array ;
15783: LD_ADDR_VAR 0 5
15787: PUSH
15788: LD_VAR 0 1
15792: ST_TO_ADDR
// end ;
15793: LD_VAR 0 5
15797: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15798: LD_INT 0
15800: PPUSH
15801: PPUSH
// result := 0 ;
15802: LD_ADDR_VAR 0 3
15806: PUSH
15807: LD_INT 0
15809: ST_TO_ADDR
// if not array or not value in array then
15810: LD_VAR 0 1
15814: NOT
15815: PUSH
15816: LD_VAR 0 2
15820: PUSH
15821: LD_VAR 0 1
15825: IN
15826: NOT
15827: OR
15828: IFFALSE 15832
// exit ;
15830: GO 15886
// for i = 1 to array do
15832: LD_ADDR_VAR 0 4
15836: PUSH
15837: DOUBLE
15838: LD_INT 1
15840: DEC
15841: ST_TO_ADDR
15842: LD_VAR 0 1
15846: PUSH
15847: FOR_TO
15848: IFFALSE 15884
// if value = array [ i ] then
15850: LD_VAR 0 2
15854: PUSH
15855: LD_VAR 0 1
15859: PUSH
15860: LD_VAR 0 4
15864: ARRAY
15865: EQUAL
15866: IFFALSE 15882
// begin result := i ;
15868: LD_ADDR_VAR 0 3
15872: PUSH
15873: LD_VAR 0 4
15877: ST_TO_ADDR
// exit ;
15878: POP
15879: POP
15880: GO 15886
// end ;
15882: GO 15847
15884: POP
15885: POP
// end ;
15886: LD_VAR 0 3
15890: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15891: LD_INT 0
15893: PPUSH
// vc_chassis := chassis ;
15894: LD_ADDR_OWVAR 37
15898: PUSH
15899: LD_VAR 0 1
15903: ST_TO_ADDR
// vc_engine := engine ;
15904: LD_ADDR_OWVAR 39
15908: PUSH
15909: LD_VAR 0 2
15913: ST_TO_ADDR
// vc_control := control ;
15914: LD_ADDR_OWVAR 38
15918: PUSH
15919: LD_VAR 0 3
15923: ST_TO_ADDR
// vc_weapon := weapon ;
15924: LD_ADDR_OWVAR 40
15928: PUSH
15929: LD_VAR 0 4
15933: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15934: LD_ADDR_OWVAR 41
15938: PUSH
15939: LD_VAR 0 5
15943: ST_TO_ADDR
// end ;
15944: LD_VAR 0 6
15948: RET
// export function WantPlant ( unit ) ; var task ; begin
15949: LD_INT 0
15951: PPUSH
15952: PPUSH
// result := false ;
15953: LD_ADDR_VAR 0 2
15957: PUSH
15958: LD_INT 0
15960: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
15961: LD_ADDR_VAR 0 3
15965: PUSH
15966: LD_VAR 0 1
15970: PPUSH
15971: CALL_OW 437
15975: ST_TO_ADDR
// if task then
15976: LD_VAR 0 3
15980: IFFALSE 16008
// if task [ 1 ] [ 1 ] = p then
15982: LD_VAR 0 3
15986: PUSH
15987: LD_INT 1
15989: ARRAY
15990: PUSH
15991: LD_INT 1
15993: ARRAY
15994: PUSH
15995: LD_STRING p
15997: EQUAL
15998: IFFALSE 16008
// result := true ;
16000: LD_ADDR_VAR 0 2
16004: PUSH
16005: LD_INT 1
16007: ST_TO_ADDR
// end ;
16008: LD_VAR 0 2
16012: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16013: LD_INT 0
16015: PPUSH
16016: PPUSH
16017: PPUSH
16018: PPUSH
// if pos < 1 then
16019: LD_VAR 0 2
16023: PUSH
16024: LD_INT 1
16026: LESS
16027: IFFALSE 16031
// exit ;
16029: GO 16334
// if pos = 1 then
16031: LD_VAR 0 2
16035: PUSH
16036: LD_INT 1
16038: EQUAL
16039: IFFALSE 16072
// result := Replace ( arr , pos [ 1 ] , value ) else
16041: LD_ADDR_VAR 0 4
16045: PUSH
16046: LD_VAR 0 1
16050: PPUSH
16051: LD_VAR 0 2
16055: PUSH
16056: LD_INT 1
16058: ARRAY
16059: PPUSH
16060: LD_VAR 0 3
16064: PPUSH
16065: CALL_OW 1
16069: ST_TO_ADDR
16070: GO 16334
// begin tmp := arr ;
16072: LD_ADDR_VAR 0 6
16076: PUSH
16077: LD_VAR 0 1
16081: ST_TO_ADDR
// s_arr := [ tmp ] ;
16082: LD_ADDR_VAR 0 7
16086: PUSH
16087: LD_VAR 0 6
16091: PUSH
16092: EMPTY
16093: LIST
16094: ST_TO_ADDR
// for i = 1 to pos - 1 do
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: DOUBLE
16101: LD_INT 1
16103: DEC
16104: ST_TO_ADDR
16105: LD_VAR 0 2
16109: PUSH
16110: LD_INT 1
16112: MINUS
16113: PUSH
16114: FOR_TO
16115: IFFALSE 16160
// begin tmp := tmp [ pos [ i ] ] ;
16117: LD_ADDR_VAR 0 6
16121: PUSH
16122: LD_VAR 0 6
16126: PUSH
16127: LD_VAR 0 2
16131: PUSH
16132: LD_VAR 0 5
16136: ARRAY
16137: ARRAY
16138: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16139: LD_ADDR_VAR 0 7
16143: PUSH
16144: LD_VAR 0 7
16148: PUSH
16149: LD_VAR 0 6
16153: PUSH
16154: EMPTY
16155: LIST
16156: ADD
16157: ST_TO_ADDR
// end ;
16158: GO 16114
16160: POP
16161: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16162: LD_ADDR_VAR 0 6
16166: PUSH
16167: LD_VAR 0 6
16171: PPUSH
16172: LD_VAR 0 2
16176: PUSH
16177: LD_VAR 0 2
16181: ARRAY
16182: PPUSH
16183: LD_VAR 0 3
16187: PPUSH
16188: CALL_OW 1
16192: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16193: LD_ADDR_VAR 0 7
16197: PUSH
16198: LD_VAR 0 7
16202: PPUSH
16203: LD_VAR 0 7
16207: PPUSH
16208: LD_VAR 0 6
16212: PPUSH
16213: CALL_OW 1
16217: ST_TO_ADDR
// for i = s_arr downto 2 do
16218: LD_ADDR_VAR 0 5
16222: PUSH
16223: DOUBLE
16224: LD_VAR 0 7
16228: INC
16229: ST_TO_ADDR
16230: LD_INT 2
16232: PUSH
16233: FOR_DOWNTO
16234: IFFALSE 16318
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16236: LD_ADDR_VAR 0 6
16240: PUSH
16241: LD_VAR 0 7
16245: PUSH
16246: LD_VAR 0 5
16250: PUSH
16251: LD_INT 1
16253: MINUS
16254: ARRAY
16255: PPUSH
16256: LD_VAR 0 2
16260: PUSH
16261: LD_VAR 0 5
16265: PUSH
16266: LD_INT 1
16268: MINUS
16269: ARRAY
16270: PPUSH
16271: LD_VAR 0 7
16275: PUSH
16276: LD_VAR 0 5
16280: ARRAY
16281: PPUSH
16282: CALL_OW 1
16286: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16287: LD_ADDR_VAR 0 7
16291: PUSH
16292: LD_VAR 0 7
16296: PPUSH
16297: LD_VAR 0 5
16301: PUSH
16302: LD_INT 1
16304: MINUS
16305: PPUSH
16306: LD_VAR 0 6
16310: PPUSH
16311: CALL_OW 1
16315: ST_TO_ADDR
// end ;
16316: GO 16233
16318: POP
16319: POP
// result := s_arr [ 1 ] ;
16320: LD_ADDR_VAR 0 4
16324: PUSH
16325: LD_VAR 0 7
16329: PUSH
16330: LD_INT 1
16332: ARRAY
16333: ST_TO_ADDR
// end ; end ;
16334: LD_VAR 0 4
16338: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16339: LD_INT 0
16341: PPUSH
16342: PPUSH
// if not list then
16343: LD_VAR 0 1
16347: NOT
16348: IFFALSE 16352
// exit ;
16350: GO 16443
// i := list [ pos1 ] ;
16352: LD_ADDR_VAR 0 5
16356: PUSH
16357: LD_VAR 0 1
16361: PUSH
16362: LD_VAR 0 2
16366: ARRAY
16367: ST_TO_ADDR
// if not i then
16368: LD_VAR 0 5
16372: NOT
16373: IFFALSE 16377
// exit ;
16375: GO 16443
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16377: LD_ADDR_VAR 0 1
16381: PUSH
16382: LD_VAR 0 1
16386: PPUSH
16387: LD_VAR 0 2
16391: PPUSH
16392: LD_VAR 0 1
16396: PUSH
16397: LD_VAR 0 3
16401: ARRAY
16402: PPUSH
16403: CALL_OW 1
16407: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16408: LD_ADDR_VAR 0 1
16412: PUSH
16413: LD_VAR 0 1
16417: PPUSH
16418: LD_VAR 0 3
16422: PPUSH
16423: LD_VAR 0 5
16427: PPUSH
16428: CALL_OW 1
16432: ST_TO_ADDR
// result := list ;
16433: LD_ADDR_VAR 0 4
16437: PUSH
16438: LD_VAR 0 1
16442: ST_TO_ADDR
// end ;
16443: LD_VAR 0 4
16447: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16448: LD_INT 0
16450: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16451: LD_ADDR_VAR 0 5
16455: PUSH
16456: LD_VAR 0 1
16460: PPUSH
16461: CALL_OW 250
16465: PPUSH
16466: LD_VAR 0 1
16470: PPUSH
16471: CALL_OW 251
16475: PPUSH
16476: LD_VAR 0 2
16480: PPUSH
16481: LD_VAR 0 3
16485: PPUSH
16486: LD_VAR 0 4
16490: PPUSH
16491: CALL 16501 0 5
16495: ST_TO_ADDR
// end ;
16496: LD_VAR 0 5
16500: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16501: LD_INT 0
16503: PPUSH
16504: PPUSH
16505: PPUSH
16506: PPUSH
// if not list then
16507: LD_VAR 0 3
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16904
// result := [ ] ;
16516: LD_ADDR_VAR 0 6
16520: PUSH
16521: EMPTY
16522: ST_TO_ADDR
// for i in list do
16523: LD_ADDR_VAR 0 7
16527: PUSH
16528: LD_VAR 0 3
16532: PUSH
16533: FOR_IN
16534: IFFALSE 16736
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16536: LD_ADDR_VAR 0 9
16540: PUSH
16541: LD_VAR 0 7
16545: PPUSH
16546: LD_VAR 0 1
16550: PPUSH
16551: LD_VAR 0 2
16555: PPUSH
16556: CALL_OW 297
16560: ST_TO_ADDR
// if not result then
16561: LD_VAR 0 6
16565: NOT
16566: IFFALSE 16592
// result := [ [ i , tmp ] ] else
16568: LD_ADDR_VAR 0 6
16572: PUSH
16573: LD_VAR 0 7
16577: PUSH
16578: LD_VAR 0 9
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: PUSH
16587: EMPTY
16588: LIST
16589: ST_TO_ADDR
16590: GO 16734
// begin if result [ result ] [ 2 ] < tmp then
16592: LD_VAR 0 6
16596: PUSH
16597: LD_VAR 0 6
16601: ARRAY
16602: PUSH
16603: LD_INT 2
16605: ARRAY
16606: PUSH
16607: LD_VAR 0 9
16611: LESS
16612: IFFALSE 16654
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16614: LD_ADDR_VAR 0 6
16618: PUSH
16619: LD_VAR 0 6
16623: PPUSH
16624: LD_VAR 0 6
16628: PUSH
16629: LD_INT 1
16631: PLUS
16632: PPUSH
16633: LD_VAR 0 7
16637: PUSH
16638: LD_VAR 0 9
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PPUSH
16647: CALL_OW 2
16651: ST_TO_ADDR
16652: GO 16734
// for j = 1 to result do
16654: LD_ADDR_VAR 0 8
16658: PUSH
16659: DOUBLE
16660: LD_INT 1
16662: DEC
16663: ST_TO_ADDR
16664: LD_VAR 0 6
16668: PUSH
16669: FOR_TO
16670: IFFALSE 16732
// begin if tmp < result [ j ] [ 2 ] then
16672: LD_VAR 0 9
16676: PUSH
16677: LD_VAR 0 6
16681: PUSH
16682: LD_VAR 0 8
16686: ARRAY
16687: PUSH
16688: LD_INT 2
16690: ARRAY
16691: LESS
16692: IFFALSE 16730
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16694: LD_ADDR_VAR 0 6
16698: PUSH
16699: LD_VAR 0 6
16703: PPUSH
16704: LD_VAR 0 8
16708: PPUSH
16709: LD_VAR 0 7
16713: PUSH
16714: LD_VAR 0 9
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PPUSH
16723: CALL_OW 2
16727: ST_TO_ADDR
// break ;
16728: GO 16732
// end ; end ;
16730: GO 16669
16732: POP
16733: POP
// end ; end ;
16734: GO 16533
16736: POP
16737: POP
// if result and not asc then
16738: LD_VAR 0 6
16742: PUSH
16743: LD_VAR 0 4
16747: NOT
16748: AND
16749: IFFALSE 16824
// begin tmp := result ;
16751: LD_ADDR_VAR 0 9
16755: PUSH
16756: LD_VAR 0 6
16760: ST_TO_ADDR
// for i = tmp downto 1 do
16761: LD_ADDR_VAR 0 7
16765: PUSH
16766: DOUBLE
16767: LD_VAR 0 9
16771: INC
16772: ST_TO_ADDR
16773: LD_INT 1
16775: PUSH
16776: FOR_DOWNTO
16777: IFFALSE 16822
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16779: LD_ADDR_VAR 0 6
16783: PUSH
16784: LD_VAR 0 6
16788: PPUSH
16789: LD_VAR 0 9
16793: PUSH
16794: LD_VAR 0 7
16798: MINUS
16799: PUSH
16800: LD_INT 1
16802: PLUS
16803: PPUSH
16804: LD_VAR 0 9
16808: PUSH
16809: LD_VAR 0 7
16813: ARRAY
16814: PPUSH
16815: CALL_OW 1
16819: ST_TO_ADDR
16820: GO 16776
16822: POP
16823: POP
// end ; tmp := [ ] ;
16824: LD_ADDR_VAR 0 9
16828: PUSH
16829: EMPTY
16830: ST_TO_ADDR
// if mode then
16831: LD_VAR 0 5
16835: IFFALSE 16904
// begin for i = 1 to result do
16837: LD_ADDR_VAR 0 7
16841: PUSH
16842: DOUBLE
16843: LD_INT 1
16845: DEC
16846: ST_TO_ADDR
16847: LD_VAR 0 6
16851: PUSH
16852: FOR_TO
16853: IFFALSE 16892
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16855: LD_ADDR_VAR 0 9
16859: PUSH
16860: LD_VAR 0 9
16864: PPUSH
16865: LD_VAR 0 7
16869: PPUSH
16870: LD_VAR 0 6
16874: PUSH
16875: LD_VAR 0 7
16879: ARRAY
16880: PUSH
16881: LD_INT 1
16883: ARRAY
16884: PPUSH
16885: CALL_OW 1
16889: ST_TO_ADDR
16890: GO 16852
16892: POP
16893: POP
// result := tmp ;
16894: LD_ADDR_VAR 0 6
16898: PUSH
16899: LD_VAR 0 9
16903: ST_TO_ADDR
// end ; end ;
16904: LD_VAR 0 6
16908: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16909: LD_INT 0
16911: PPUSH
16912: PPUSH
16913: PPUSH
16914: PPUSH
16915: PPUSH
16916: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16917: LD_ADDR_VAR 0 5
16921: PUSH
16922: LD_INT 0
16924: PUSH
16925: LD_INT 0
16927: PUSH
16928: LD_INT 0
16930: PUSH
16931: EMPTY
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: ST_TO_ADDR
// if not x or not y then
16939: LD_VAR 0 2
16943: NOT
16944: PUSH
16945: LD_VAR 0 3
16949: NOT
16950: OR
16951: IFFALSE 16955
// exit ;
16953: GO 18607
// if not range then
16955: LD_VAR 0 4
16959: NOT
16960: IFFALSE 16970
// range := 10 ;
16962: LD_ADDR_VAR 0 4
16966: PUSH
16967: LD_INT 10
16969: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16970: LD_ADDR_VAR 0 8
16974: PUSH
16975: LD_INT 81
16977: PUSH
16978: LD_VAR 0 1
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 92
16989: PUSH
16990: LD_VAR 0 2
16994: PUSH
16995: LD_VAR 0 3
16999: PUSH
17000: LD_VAR 0 4
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: PUSH
17011: LD_INT 3
17013: PUSH
17014: LD_INT 21
17016: PUSH
17017: LD_INT 3
17019: PUSH
17020: EMPTY
17021: LIST
17022: LIST
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: LIST
17032: PPUSH
17033: CALL_OW 69
17037: ST_TO_ADDR
// if not tmp then
17038: LD_VAR 0 8
17042: NOT
17043: IFFALSE 17047
// exit ;
17045: GO 18607
// for i in tmp do
17047: LD_ADDR_VAR 0 6
17051: PUSH
17052: LD_VAR 0 8
17056: PUSH
17057: FOR_IN
17058: IFFALSE 18582
// begin points := [ 0 , 0 , 0 ] ;
17060: LD_ADDR_VAR 0 9
17064: PUSH
17065: LD_INT 0
17067: PUSH
17068: LD_INT 0
17070: PUSH
17071: LD_INT 0
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: LIST
17078: ST_TO_ADDR
// bpoints := 1 ;
17079: LD_ADDR_VAR 0 10
17083: PUSH
17084: LD_INT 1
17086: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17087: LD_VAR 0 6
17091: PPUSH
17092: CALL_OW 247
17096: PUSH
17097: LD_INT 1
17099: DOUBLE
17100: EQUAL
17101: IFTRUE 17105
17103: GO 17683
17105: POP
// begin if GetClass ( i ) = 1 then
17106: LD_VAR 0 6
17110: PPUSH
17111: CALL_OW 257
17115: PUSH
17116: LD_INT 1
17118: EQUAL
17119: IFFALSE 17140
// points := [ 10 , 5 , 3 ] ;
17121: LD_ADDR_VAR 0 9
17125: PUSH
17126: LD_INT 10
17128: PUSH
17129: LD_INT 5
17131: PUSH
17132: LD_INT 3
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: LIST
17139: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17140: LD_VAR 0 6
17144: PPUSH
17145: CALL_OW 257
17149: PUSH
17150: LD_INT 2
17152: PUSH
17153: LD_INT 3
17155: PUSH
17156: LD_INT 4
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: LIST
17163: IN
17164: IFFALSE 17185
// points := [ 3 , 2 , 1 ] ;
17166: LD_ADDR_VAR 0 9
17170: PUSH
17171: LD_INT 3
17173: PUSH
17174: LD_INT 2
17176: PUSH
17177: LD_INT 1
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17185: LD_VAR 0 6
17189: PPUSH
17190: CALL_OW 257
17194: PUSH
17195: LD_INT 5
17197: EQUAL
17198: IFFALSE 17219
// points := [ 130 , 5 , 2 ] ;
17200: LD_ADDR_VAR 0 9
17204: PUSH
17205: LD_INT 130
17207: PUSH
17208: LD_INT 5
17210: PUSH
17211: LD_INT 2
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17219: LD_VAR 0 6
17223: PPUSH
17224: CALL_OW 257
17228: PUSH
17229: LD_INT 8
17231: EQUAL
17232: IFFALSE 17253
// points := [ 35 , 35 , 30 ] ;
17234: LD_ADDR_VAR 0 9
17238: PUSH
17239: LD_INT 35
17241: PUSH
17242: LD_INT 35
17244: PUSH
17245: LD_INT 30
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: LIST
17252: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17253: LD_VAR 0 6
17257: PPUSH
17258: CALL_OW 257
17262: PUSH
17263: LD_INT 9
17265: EQUAL
17266: IFFALSE 17287
// points := [ 20 , 55 , 40 ] ;
17268: LD_ADDR_VAR 0 9
17272: PUSH
17273: LD_INT 20
17275: PUSH
17276: LD_INT 55
17278: PUSH
17279: LD_INT 40
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: LIST
17286: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17287: LD_VAR 0 6
17291: PPUSH
17292: CALL_OW 257
17296: PUSH
17297: LD_INT 12
17299: PUSH
17300: LD_INT 16
17302: PUSH
17303: EMPTY
17304: LIST
17305: LIST
17306: IN
17307: IFFALSE 17328
// points := [ 5 , 3 , 2 ] ;
17309: LD_ADDR_VAR 0 9
17313: PUSH
17314: LD_INT 5
17316: PUSH
17317: LD_INT 3
17319: PUSH
17320: LD_INT 2
17322: PUSH
17323: EMPTY
17324: LIST
17325: LIST
17326: LIST
17327: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17328: LD_VAR 0 6
17332: PPUSH
17333: CALL_OW 257
17337: PUSH
17338: LD_INT 17
17340: EQUAL
17341: IFFALSE 17362
// points := [ 100 , 50 , 75 ] ;
17343: LD_ADDR_VAR 0 9
17347: PUSH
17348: LD_INT 100
17350: PUSH
17351: LD_INT 50
17353: PUSH
17354: LD_INT 75
17356: PUSH
17357: EMPTY
17358: LIST
17359: LIST
17360: LIST
17361: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17362: LD_VAR 0 6
17366: PPUSH
17367: CALL_OW 257
17371: PUSH
17372: LD_INT 15
17374: EQUAL
17375: IFFALSE 17396
// points := [ 10 , 5 , 3 ] ;
17377: LD_ADDR_VAR 0 9
17381: PUSH
17382: LD_INT 10
17384: PUSH
17385: LD_INT 5
17387: PUSH
17388: LD_INT 3
17390: PUSH
17391: EMPTY
17392: LIST
17393: LIST
17394: LIST
17395: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17396: LD_VAR 0 6
17400: PPUSH
17401: CALL_OW 257
17405: PUSH
17406: LD_INT 14
17408: EQUAL
17409: IFFALSE 17430
// points := [ 10 , 0 , 0 ] ;
17411: LD_ADDR_VAR 0 9
17415: PUSH
17416: LD_INT 10
17418: PUSH
17419: LD_INT 0
17421: PUSH
17422: LD_INT 0
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: LIST
17429: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17430: LD_VAR 0 6
17434: PPUSH
17435: CALL_OW 257
17439: PUSH
17440: LD_INT 11
17442: EQUAL
17443: IFFALSE 17464
// points := [ 30 , 10 , 5 ] ;
17445: LD_ADDR_VAR 0 9
17449: PUSH
17450: LD_INT 30
17452: PUSH
17453: LD_INT 10
17455: PUSH
17456: LD_INT 5
17458: PUSH
17459: EMPTY
17460: LIST
17461: LIST
17462: LIST
17463: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17464: LD_VAR 0 1
17468: PPUSH
17469: LD_INT 5
17471: PPUSH
17472: CALL_OW 321
17476: PUSH
17477: LD_INT 2
17479: EQUAL
17480: IFFALSE 17497
// bpoints := bpoints * 1.8 ;
17482: LD_ADDR_VAR 0 10
17486: PUSH
17487: LD_VAR 0 10
17491: PUSH
17492: LD_REAL  1.80000000000000E+0000
17495: MUL
17496: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17497: LD_VAR 0 6
17501: PPUSH
17502: CALL_OW 257
17506: PUSH
17507: LD_INT 1
17509: PUSH
17510: LD_INT 2
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: LD_INT 4
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: LIST
17523: LIST
17524: IN
17525: PUSH
17526: LD_VAR 0 1
17530: PPUSH
17531: LD_INT 51
17533: PPUSH
17534: CALL_OW 321
17538: PUSH
17539: LD_INT 2
17541: EQUAL
17542: AND
17543: IFFALSE 17560
// bpoints := bpoints * 1.2 ;
17545: LD_ADDR_VAR 0 10
17549: PUSH
17550: LD_VAR 0 10
17554: PUSH
17555: LD_REAL  1.20000000000000E+0000
17558: MUL
17559: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17560: LD_VAR 0 6
17564: PPUSH
17565: CALL_OW 257
17569: PUSH
17570: LD_INT 5
17572: PUSH
17573: LD_INT 7
17575: PUSH
17576: LD_INT 9
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: IN
17584: PUSH
17585: LD_VAR 0 1
17589: PPUSH
17590: LD_INT 52
17592: PPUSH
17593: CALL_OW 321
17597: PUSH
17598: LD_INT 2
17600: EQUAL
17601: AND
17602: IFFALSE 17619
// bpoints := bpoints * 1.5 ;
17604: LD_ADDR_VAR 0 10
17608: PUSH
17609: LD_VAR 0 10
17613: PUSH
17614: LD_REAL  1.50000000000000E+0000
17617: MUL
17618: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17619: LD_VAR 0 1
17623: PPUSH
17624: LD_INT 66
17626: PPUSH
17627: CALL_OW 321
17631: PUSH
17632: LD_INT 2
17634: EQUAL
17635: IFFALSE 17652
// bpoints := bpoints * 1.1 ;
17637: LD_ADDR_VAR 0 10
17641: PUSH
17642: LD_VAR 0 10
17646: PUSH
17647: LD_REAL  1.10000000000000E+0000
17650: MUL
17651: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17652: LD_ADDR_VAR 0 10
17656: PUSH
17657: LD_VAR 0 10
17661: PUSH
17662: LD_VAR 0 6
17666: PPUSH
17667: LD_INT 1
17669: PPUSH
17670: CALL_OW 259
17674: PUSH
17675: LD_REAL  1.15000000000000E+0000
17678: MUL
17679: MUL
17680: ST_TO_ADDR
// end ; unit_vehicle :
17681: GO 18511
17683: LD_INT 2
17685: DOUBLE
17686: EQUAL
17687: IFTRUE 17691
17689: GO 18499
17691: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17692: LD_VAR 0 6
17696: PPUSH
17697: CALL_OW 264
17701: PUSH
17702: LD_INT 2
17704: PUSH
17705: LD_INT 42
17707: PUSH
17708: LD_INT 24
17710: PUSH
17711: EMPTY
17712: LIST
17713: LIST
17714: LIST
17715: IN
17716: IFFALSE 17737
// points := [ 25 , 5 , 3 ] ;
17718: LD_ADDR_VAR 0 9
17722: PUSH
17723: LD_INT 25
17725: PUSH
17726: LD_INT 5
17728: PUSH
17729: LD_INT 3
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17737: LD_VAR 0 6
17741: PPUSH
17742: CALL_OW 264
17746: PUSH
17747: LD_INT 4
17749: PUSH
17750: LD_INT 43
17752: PUSH
17753: LD_INT 25
17755: PUSH
17756: EMPTY
17757: LIST
17758: LIST
17759: LIST
17760: IN
17761: IFFALSE 17782
// points := [ 40 , 15 , 5 ] ;
17763: LD_ADDR_VAR 0 9
17767: PUSH
17768: LD_INT 40
17770: PUSH
17771: LD_INT 15
17773: PUSH
17774: LD_INT 5
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: LIST
17781: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17782: LD_VAR 0 6
17786: PPUSH
17787: CALL_OW 264
17791: PUSH
17792: LD_INT 3
17794: PUSH
17795: LD_INT 23
17797: PUSH
17798: EMPTY
17799: LIST
17800: LIST
17801: IN
17802: IFFALSE 17823
// points := [ 7 , 25 , 8 ] ;
17804: LD_ADDR_VAR 0 9
17808: PUSH
17809: LD_INT 7
17811: PUSH
17812: LD_INT 25
17814: PUSH
17815: LD_INT 8
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: LIST
17822: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17823: LD_VAR 0 6
17827: PPUSH
17828: CALL_OW 264
17832: PUSH
17833: LD_INT 5
17835: PUSH
17836: LD_INT 27
17838: PUSH
17839: LD_INT 44
17841: PUSH
17842: EMPTY
17843: LIST
17844: LIST
17845: LIST
17846: IN
17847: IFFALSE 17868
// points := [ 14 , 50 , 16 ] ;
17849: LD_ADDR_VAR 0 9
17853: PUSH
17854: LD_INT 14
17856: PUSH
17857: LD_INT 50
17859: PUSH
17860: LD_INT 16
17862: PUSH
17863: EMPTY
17864: LIST
17865: LIST
17866: LIST
17867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17868: LD_VAR 0 6
17872: PPUSH
17873: CALL_OW 264
17877: PUSH
17878: LD_INT 6
17880: PUSH
17881: LD_INT 46
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: IN
17888: IFFALSE 17909
// points := [ 32 , 120 , 70 ] ;
17890: LD_ADDR_VAR 0 9
17894: PUSH
17895: LD_INT 32
17897: PUSH
17898: LD_INT 120
17900: PUSH
17901: LD_INT 70
17903: PUSH
17904: EMPTY
17905: LIST
17906: LIST
17907: LIST
17908: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17909: LD_VAR 0 6
17913: PPUSH
17914: CALL_OW 264
17918: PUSH
17919: LD_INT 7
17921: PUSH
17922: LD_INT 28
17924: PUSH
17925: LD_INT 45
17927: PUSH
17928: LD_EXP 72
17932: PUSH
17933: EMPTY
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: IN
17939: IFFALSE 17960
// points := [ 35 , 20 , 45 ] ;
17941: LD_ADDR_VAR 0 9
17945: PUSH
17946: LD_INT 35
17948: PUSH
17949: LD_INT 20
17951: PUSH
17952: LD_INT 45
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: LIST
17959: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17960: LD_VAR 0 6
17964: PPUSH
17965: CALL_OW 264
17969: PUSH
17970: LD_INT 47
17972: PUSH
17973: EMPTY
17974: LIST
17975: IN
17976: IFFALSE 17997
// points := [ 67 , 45 , 75 ] ;
17978: LD_ADDR_VAR 0 9
17982: PUSH
17983: LD_INT 67
17985: PUSH
17986: LD_INT 45
17988: PUSH
17989: LD_INT 75
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17997: LD_VAR 0 6
18001: PPUSH
18002: CALL_OW 264
18006: PUSH
18007: LD_INT 26
18009: PUSH
18010: EMPTY
18011: LIST
18012: IN
18013: IFFALSE 18034
// points := [ 120 , 30 , 80 ] ;
18015: LD_ADDR_VAR 0 9
18019: PUSH
18020: LD_INT 120
18022: PUSH
18023: LD_INT 30
18025: PUSH
18026: LD_INT 80
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: LIST
18033: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18034: LD_VAR 0 6
18038: PPUSH
18039: CALL_OW 264
18043: PUSH
18044: LD_INT 22
18046: PUSH
18047: EMPTY
18048: LIST
18049: IN
18050: IFFALSE 18071
// points := [ 40 , 1 , 1 ] ;
18052: LD_ADDR_VAR 0 9
18056: PUSH
18057: LD_INT 40
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: LD_INT 1
18065: PUSH
18066: EMPTY
18067: LIST
18068: LIST
18069: LIST
18070: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18071: LD_VAR 0 6
18075: PPUSH
18076: CALL_OW 264
18080: PUSH
18081: LD_INT 29
18083: PUSH
18084: EMPTY
18085: LIST
18086: IN
18087: IFFALSE 18108
// points := [ 70 , 200 , 400 ] ;
18089: LD_ADDR_VAR 0 9
18093: PUSH
18094: LD_INT 70
18096: PUSH
18097: LD_INT 200
18099: PUSH
18100: LD_INT 400
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18108: LD_VAR 0 6
18112: PPUSH
18113: CALL_OW 264
18117: PUSH
18118: LD_INT 14
18120: PUSH
18121: LD_INT 53
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: IN
18128: IFFALSE 18149
// points := [ 40 , 10 , 20 ] ;
18130: LD_ADDR_VAR 0 9
18134: PUSH
18135: LD_INT 40
18137: PUSH
18138: LD_INT 10
18140: PUSH
18141: LD_INT 20
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: LIST
18148: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18149: LD_VAR 0 6
18153: PPUSH
18154: CALL_OW 264
18158: PUSH
18159: LD_INT 9
18161: PUSH
18162: EMPTY
18163: LIST
18164: IN
18165: IFFALSE 18186
// points := [ 5 , 70 , 20 ] ;
18167: LD_ADDR_VAR 0 9
18171: PUSH
18172: LD_INT 5
18174: PUSH
18175: LD_INT 70
18177: PUSH
18178: LD_INT 20
18180: PUSH
18181: EMPTY
18182: LIST
18183: LIST
18184: LIST
18185: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18186: LD_VAR 0 6
18190: PPUSH
18191: CALL_OW 264
18195: PUSH
18196: LD_INT 10
18198: PUSH
18199: EMPTY
18200: LIST
18201: IN
18202: IFFALSE 18223
// points := [ 35 , 110 , 70 ] ;
18204: LD_ADDR_VAR 0 9
18208: PUSH
18209: LD_INT 35
18211: PUSH
18212: LD_INT 110
18214: PUSH
18215: LD_INT 70
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18223: LD_VAR 0 6
18227: PPUSH
18228: CALL_OW 265
18232: PUSH
18233: LD_INT 25
18235: EQUAL
18236: IFFALSE 18257
// points := [ 80 , 65 , 100 ] ;
18238: LD_ADDR_VAR 0 9
18242: PUSH
18243: LD_INT 80
18245: PUSH
18246: LD_INT 65
18248: PUSH
18249: LD_INT 100
18251: PUSH
18252: EMPTY
18253: LIST
18254: LIST
18255: LIST
18256: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18257: LD_VAR 0 6
18261: PPUSH
18262: CALL_OW 263
18266: PUSH
18267: LD_INT 1
18269: EQUAL
18270: IFFALSE 18305
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18272: LD_ADDR_VAR 0 10
18276: PUSH
18277: LD_VAR 0 10
18281: PUSH
18282: LD_VAR 0 6
18286: PPUSH
18287: CALL_OW 311
18291: PPUSH
18292: LD_INT 3
18294: PPUSH
18295: CALL_OW 259
18299: PUSH
18300: LD_INT 4
18302: MUL
18303: MUL
18304: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18305: LD_VAR 0 6
18309: PPUSH
18310: CALL_OW 263
18314: PUSH
18315: LD_INT 2
18317: EQUAL
18318: IFFALSE 18369
// begin j := IsControledBy ( i ) ;
18320: LD_ADDR_VAR 0 7
18324: PUSH
18325: LD_VAR 0 6
18329: PPUSH
18330: CALL_OW 312
18334: ST_TO_ADDR
// if j then
18335: LD_VAR 0 7
18339: IFFALSE 18369
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18341: LD_ADDR_VAR 0 10
18345: PUSH
18346: LD_VAR 0 10
18350: PUSH
18351: LD_VAR 0 7
18355: PPUSH
18356: LD_INT 3
18358: PPUSH
18359: CALL_OW 259
18363: PUSH
18364: LD_INT 3
18366: MUL
18367: MUL
18368: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18369: LD_VAR 0 6
18373: PPUSH
18374: CALL_OW 264
18378: PUSH
18379: LD_INT 5
18381: PUSH
18382: LD_INT 6
18384: PUSH
18385: LD_INT 46
18387: PUSH
18388: LD_INT 44
18390: PUSH
18391: LD_INT 47
18393: PUSH
18394: LD_INT 45
18396: PUSH
18397: LD_INT 28
18399: PUSH
18400: LD_INT 7
18402: PUSH
18403: LD_INT 27
18405: PUSH
18406: LD_INT 29
18408: PUSH
18409: EMPTY
18410: LIST
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: IN
18421: PUSH
18422: LD_VAR 0 1
18426: PPUSH
18427: LD_INT 52
18429: PPUSH
18430: CALL_OW 321
18434: PUSH
18435: LD_INT 2
18437: EQUAL
18438: AND
18439: IFFALSE 18456
// bpoints := bpoints * 1.2 ;
18441: LD_ADDR_VAR 0 10
18445: PUSH
18446: LD_VAR 0 10
18450: PUSH
18451: LD_REAL  1.20000000000000E+0000
18454: MUL
18455: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18456: LD_VAR 0 6
18460: PPUSH
18461: CALL_OW 264
18465: PUSH
18466: LD_INT 6
18468: PUSH
18469: LD_INT 46
18471: PUSH
18472: LD_INT 47
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: LIST
18479: IN
18480: IFFALSE 18497
// bpoints := bpoints * 1.2 ;
18482: LD_ADDR_VAR 0 10
18486: PUSH
18487: LD_VAR 0 10
18491: PUSH
18492: LD_REAL  1.20000000000000E+0000
18495: MUL
18496: ST_TO_ADDR
// end ; unit_building :
18497: GO 18511
18499: LD_INT 3
18501: DOUBLE
18502: EQUAL
18503: IFTRUE 18507
18505: GO 18510
18507: POP
// ; end ;
18508: GO 18511
18510: POP
// for j = 1 to 3 do
18511: LD_ADDR_VAR 0 7
18515: PUSH
18516: DOUBLE
18517: LD_INT 1
18519: DEC
18520: ST_TO_ADDR
18521: LD_INT 3
18523: PUSH
18524: FOR_TO
18525: IFFALSE 18578
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18527: LD_ADDR_VAR 0 5
18531: PUSH
18532: LD_VAR 0 5
18536: PPUSH
18537: LD_VAR 0 7
18541: PPUSH
18542: LD_VAR 0 5
18546: PUSH
18547: LD_VAR 0 7
18551: ARRAY
18552: PUSH
18553: LD_VAR 0 9
18557: PUSH
18558: LD_VAR 0 7
18562: ARRAY
18563: PUSH
18564: LD_VAR 0 10
18568: MUL
18569: PLUS
18570: PPUSH
18571: CALL_OW 1
18575: ST_TO_ADDR
18576: GO 18524
18578: POP
18579: POP
// end ;
18580: GO 17057
18582: POP
18583: POP
// result := Replace ( result , 4 , tmp ) ;
18584: LD_ADDR_VAR 0 5
18588: PUSH
18589: LD_VAR 0 5
18593: PPUSH
18594: LD_INT 4
18596: PPUSH
18597: LD_VAR 0 8
18601: PPUSH
18602: CALL_OW 1
18606: ST_TO_ADDR
// end ;
18607: LD_VAR 0 5
18611: RET
// export function DangerAtRange ( unit , range ) ; begin
18612: LD_INT 0
18614: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18615: LD_ADDR_VAR 0 3
18619: PUSH
18620: LD_VAR 0 1
18624: PPUSH
18625: CALL_OW 255
18629: PPUSH
18630: LD_VAR 0 1
18634: PPUSH
18635: CALL_OW 250
18639: PPUSH
18640: LD_VAR 0 1
18644: PPUSH
18645: CALL_OW 251
18649: PPUSH
18650: LD_VAR 0 2
18654: PPUSH
18655: CALL 16909 0 4
18659: ST_TO_ADDR
// end ;
18660: LD_VAR 0 3
18664: RET
// export function DangerInArea ( side , area ) ; begin
18665: LD_INT 0
18667: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18668: LD_ADDR_VAR 0 3
18672: PUSH
18673: LD_VAR 0 2
18677: PPUSH
18678: LD_INT 81
18680: PUSH
18681: LD_VAR 0 1
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: PPUSH
18690: CALL_OW 70
18694: ST_TO_ADDR
// end ;
18695: LD_VAR 0 3
18699: RET
// export function IsExtension ( b ) ; begin
18700: LD_INT 0
18702: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18703: LD_ADDR_VAR 0 2
18707: PUSH
18708: LD_VAR 0 1
18712: PUSH
18713: LD_INT 23
18715: PUSH
18716: LD_INT 20
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 17
18724: PUSH
18725: LD_INT 24
18727: PUSH
18728: LD_INT 21
18730: PUSH
18731: LD_INT 19
18733: PUSH
18734: LD_INT 16
18736: PUSH
18737: LD_INT 25
18739: PUSH
18740: LD_INT 18
18742: PUSH
18743: EMPTY
18744: LIST
18745: LIST
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: LIST
18751: LIST
18752: LIST
18753: LIST
18754: IN
18755: ST_TO_ADDR
// end ;
18756: LD_VAR 0 2
18760: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18761: LD_INT 0
18763: PPUSH
18764: PPUSH
18765: PPUSH
// result := [ ] ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: EMPTY
18772: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18773: LD_ADDR_VAR 0 5
18777: PUSH
18778: LD_VAR 0 2
18782: PPUSH
18783: LD_INT 21
18785: PUSH
18786: LD_INT 3
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: PPUSH
18793: CALL_OW 70
18797: ST_TO_ADDR
// if not tmp then
18798: LD_VAR 0 5
18802: NOT
18803: IFFALSE 18807
// exit ;
18805: GO 18871
// if checkLink then
18807: LD_VAR 0 3
18811: IFFALSE 18861
// begin for i in tmp do
18813: LD_ADDR_VAR 0 6
18817: PUSH
18818: LD_VAR 0 5
18822: PUSH
18823: FOR_IN
18824: IFFALSE 18859
// if GetBase ( i ) <> base then
18826: LD_VAR 0 6
18830: PPUSH
18831: CALL_OW 274
18835: PUSH
18836: LD_VAR 0 1
18840: NONEQUAL
18841: IFFALSE 18857
// ComLinkToBase ( base , i ) ;
18843: LD_VAR 0 1
18847: PPUSH
18848: LD_VAR 0 6
18852: PPUSH
18853: CALL_OW 169
18857: GO 18823
18859: POP
18860: POP
// end ; result := tmp ;
18861: LD_ADDR_VAR 0 4
18865: PUSH
18866: LD_VAR 0 5
18870: ST_TO_ADDR
// end ;
18871: LD_VAR 0 4
18875: RET
// export function ComComplete ( units , b ) ; var i ; begin
18876: LD_INT 0
18878: PPUSH
18879: PPUSH
// if not units then
18880: LD_VAR 0 1
18884: NOT
18885: IFFALSE 18889
// exit ;
18887: GO 18979
// for i in units do
18889: LD_ADDR_VAR 0 4
18893: PUSH
18894: LD_VAR 0 1
18898: PUSH
18899: FOR_IN
18900: IFFALSE 18977
// if BuildingStatus ( b ) = bs_build then
18902: LD_VAR 0 2
18906: PPUSH
18907: CALL_OW 461
18911: PUSH
18912: LD_INT 1
18914: EQUAL
18915: IFFALSE 18975
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18917: LD_VAR 0 4
18921: PPUSH
18922: LD_STRING h
18924: PUSH
18925: LD_VAR 0 2
18929: PPUSH
18930: CALL_OW 250
18934: PUSH
18935: LD_VAR 0 2
18939: PPUSH
18940: CALL_OW 251
18944: PUSH
18945: LD_VAR 0 2
18949: PUSH
18950: LD_INT 0
18952: PUSH
18953: LD_INT 0
18955: PUSH
18956: LD_INT 0
18958: PUSH
18959: EMPTY
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: LIST
18967: PUSH
18968: EMPTY
18969: LIST
18970: PPUSH
18971: CALL_OW 446
18975: GO 18899
18977: POP
18978: POP
// end ;
18979: LD_VAR 0 3
18983: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18984: LD_INT 0
18986: PPUSH
18987: PPUSH
18988: PPUSH
18989: PPUSH
18990: PPUSH
18991: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18992: LD_VAR 0 1
18996: NOT
18997: PUSH
18998: LD_VAR 0 1
19002: PPUSH
19003: CALL_OW 263
19007: PUSH
19008: LD_INT 2
19010: NONEQUAL
19011: OR
19012: IFFALSE 19016
// exit ;
19014: GO 19332
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19016: LD_ADDR_VAR 0 6
19020: PUSH
19021: LD_INT 22
19023: PUSH
19024: LD_VAR 0 1
19028: PPUSH
19029: CALL_OW 255
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: LD_INT 2
19040: PUSH
19041: LD_INT 30
19043: PUSH
19044: LD_INT 36
19046: PUSH
19047: EMPTY
19048: LIST
19049: LIST
19050: PUSH
19051: LD_INT 34
19053: PUSH
19054: LD_INT 31
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: PUSH
19061: EMPTY
19062: LIST
19063: LIST
19064: LIST
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL_OW 69
19074: ST_TO_ADDR
// if not tmp then
19075: LD_VAR 0 6
19079: NOT
19080: IFFALSE 19084
// exit ;
19082: GO 19332
// result := [ ] ;
19084: LD_ADDR_VAR 0 2
19088: PUSH
19089: EMPTY
19090: ST_TO_ADDR
// for i in tmp do
19091: LD_ADDR_VAR 0 3
19095: PUSH
19096: LD_VAR 0 6
19100: PUSH
19101: FOR_IN
19102: IFFALSE 19173
// begin t := UnitsInside ( i ) ;
19104: LD_ADDR_VAR 0 4
19108: PUSH
19109: LD_VAR 0 3
19113: PPUSH
19114: CALL_OW 313
19118: ST_TO_ADDR
// if t then
19119: LD_VAR 0 4
19123: IFFALSE 19171
// for j in t do
19125: LD_ADDR_VAR 0 7
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: FOR_IN
19136: IFFALSE 19169
// result := Replace ( result , result + 1 , j ) ;
19138: LD_ADDR_VAR 0 2
19142: PUSH
19143: LD_VAR 0 2
19147: PPUSH
19148: LD_VAR 0 2
19152: PUSH
19153: LD_INT 1
19155: PLUS
19156: PPUSH
19157: LD_VAR 0 7
19161: PPUSH
19162: CALL_OW 1
19166: ST_TO_ADDR
19167: GO 19135
19169: POP
19170: POP
// end ;
19171: GO 19101
19173: POP
19174: POP
// if not result then
19175: LD_VAR 0 2
19179: NOT
19180: IFFALSE 19184
// exit ;
19182: GO 19332
// mech := result [ 1 ] ;
19184: LD_ADDR_VAR 0 5
19188: PUSH
19189: LD_VAR 0 2
19193: PUSH
19194: LD_INT 1
19196: ARRAY
19197: ST_TO_ADDR
// if result > 1 then
19198: LD_VAR 0 2
19202: PUSH
19203: LD_INT 1
19205: GREATER
19206: IFFALSE 19318
// begin for i = 2 to result do
19208: LD_ADDR_VAR 0 3
19212: PUSH
19213: DOUBLE
19214: LD_INT 2
19216: DEC
19217: ST_TO_ADDR
19218: LD_VAR 0 2
19222: PUSH
19223: FOR_TO
19224: IFFALSE 19316
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19226: LD_ADDR_VAR 0 4
19230: PUSH
19231: LD_VAR 0 2
19235: PUSH
19236: LD_VAR 0 3
19240: ARRAY
19241: PPUSH
19242: LD_INT 3
19244: PPUSH
19245: CALL_OW 259
19249: PUSH
19250: LD_VAR 0 2
19254: PUSH
19255: LD_VAR 0 3
19259: ARRAY
19260: PPUSH
19261: CALL_OW 432
19265: MINUS
19266: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19267: LD_VAR 0 4
19271: PUSH
19272: LD_VAR 0 5
19276: PPUSH
19277: LD_INT 3
19279: PPUSH
19280: CALL_OW 259
19284: PUSH
19285: LD_VAR 0 5
19289: PPUSH
19290: CALL_OW 432
19294: MINUS
19295: GREATEREQUAL
19296: IFFALSE 19314
// mech := result [ i ] ;
19298: LD_ADDR_VAR 0 5
19302: PUSH
19303: LD_VAR 0 2
19307: PUSH
19308: LD_VAR 0 3
19312: ARRAY
19313: ST_TO_ADDR
// end ;
19314: GO 19223
19316: POP
19317: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19318: LD_VAR 0 1
19322: PPUSH
19323: LD_VAR 0 5
19327: PPUSH
19328: CALL_OW 135
// end ;
19332: LD_VAR 0 2
19336: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19337: LD_INT 0
19339: PPUSH
19340: PPUSH
19341: PPUSH
19342: PPUSH
19343: PPUSH
19344: PPUSH
19345: PPUSH
19346: PPUSH
19347: PPUSH
19348: PPUSH
19349: PPUSH
19350: PPUSH
19351: PPUSH
// result := [ ] ;
19352: LD_ADDR_VAR 0 7
19356: PUSH
19357: EMPTY
19358: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19359: LD_VAR 0 1
19363: PPUSH
19364: CALL_OW 266
19368: PUSH
19369: LD_INT 0
19371: PUSH
19372: LD_INT 1
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: IN
19379: NOT
19380: IFFALSE 19384
// exit ;
19382: GO 21018
// if name then
19384: LD_VAR 0 3
19388: IFFALSE 19404
// SetBName ( base_dep , name ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_VAR 0 3
19399: PPUSH
19400: CALL_OW 500
// base := GetBase ( base_dep ) ;
19404: LD_ADDR_VAR 0 15
19408: PUSH
19409: LD_VAR 0 1
19413: PPUSH
19414: CALL_OW 274
19418: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19419: LD_ADDR_VAR 0 16
19423: PUSH
19424: LD_VAR 0 1
19428: PPUSH
19429: CALL_OW 255
19433: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19434: LD_ADDR_VAR 0 17
19438: PUSH
19439: LD_VAR 0 1
19443: PPUSH
19444: CALL_OW 248
19448: ST_TO_ADDR
// if sources then
19449: LD_VAR 0 5
19453: IFFALSE 19500
// for i = 1 to 3 do
19455: LD_ADDR_VAR 0 8
19459: PUSH
19460: DOUBLE
19461: LD_INT 1
19463: DEC
19464: ST_TO_ADDR
19465: LD_INT 3
19467: PUSH
19468: FOR_TO
19469: IFFALSE 19498
// AddResourceType ( base , i , sources [ i ] ) ;
19471: LD_VAR 0 15
19475: PPUSH
19476: LD_VAR 0 8
19480: PPUSH
19481: LD_VAR 0 5
19485: PUSH
19486: LD_VAR 0 8
19490: ARRAY
19491: PPUSH
19492: CALL_OW 276
19496: GO 19468
19498: POP
19499: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19500: LD_ADDR_VAR 0 18
19504: PUSH
19505: LD_VAR 0 15
19509: PPUSH
19510: LD_VAR 0 2
19514: PPUSH
19515: LD_INT 1
19517: PPUSH
19518: CALL 18761 0 3
19522: ST_TO_ADDR
// InitHc ;
19523: CALL_OW 19
// InitUc ;
19527: CALL_OW 18
// uc_side := side ;
19531: LD_ADDR_OWVAR 20
19535: PUSH
19536: LD_VAR 0 16
19540: ST_TO_ADDR
// uc_nation := nation ;
19541: LD_ADDR_OWVAR 21
19545: PUSH
19546: LD_VAR 0 17
19550: ST_TO_ADDR
// if buildings then
19551: LD_VAR 0 18
19555: IFFALSE 20877
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19557: LD_ADDR_VAR 0 19
19561: PUSH
19562: LD_VAR 0 18
19566: PPUSH
19567: LD_INT 2
19569: PUSH
19570: LD_INT 30
19572: PUSH
19573: LD_INT 29
19575: PUSH
19576: EMPTY
19577: LIST
19578: LIST
19579: PUSH
19580: LD_INT 30
19582: PUSH
19583: LD_INT 30
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: LIST
19594: PPUSH
19595: CALL_OW 72
19599: ST_TO_ADDR
// if tmp then
19600: LD_VAR 0 19
19604: IFFALSE 19652
// for i in tmp do
19606: LD_ADDR_VAR 0 8
19610: PUSH
19611: LD_VAR 0 19
19615: PUSH
19616: FOR_IN
19617: IFFALSE 19650
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19619: LD_VAR 0 8
19623: PPUSH
19624: CALL_OW 250
19628: PPUSH
19629: LD_VAR 0 8
19633: PPUSH
19634: CALL_OW 251
19638: PPUSH
19639: LD_VAR 0 16
19643: PPUSH
19644: CALL_OW 441
19648: GO 19616
19650: POP
19651: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19652: LD_VAR 0 18
19656: PPUSH
19657: LD_INT 2
19659: PUSH
19660: LD_INT 30
19662: PUSH
19663: LD_INT 32
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: PUSH
19670: LD_INT 30
19672: PUSH
19673: LD_INT 33
19675: PUSH
19676: EMPTY
19677: LIST
19678: LIST
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: LIST
19684: PPUSH
19685: CALL_OW 72
19689: IFFALSE 19777
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19691: LD_ADDR_VAR 0 8
19695: PUSH
19696: LD_VAR 0 18
19700: PPUSH
19701: LD_INT 2
19703: PUSH
19704: LD_INT 30
19706: PUSH
19707: LD_INT 32
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: PUSH
19714: LD_INT 30
19716: PUSH
19717: LD_INT 33
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: EMPTY
19725: LIST
19726: LIST
19727: LIST
19728: PPUSH
19729: CALL_OW 72
19733: PUSH
19734: FOR_IN
19735: IFFALSE 19775
// begin if not GetBWeapon ( i ) then
19737: LD_VAR 0 8
19741: PPUSH
19742: CALL_OW 269
19746: NOT
19747: IFFALSE 19773
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19749: LD_VAR 0 8
19753: PPUSH
19754: LD_VAR 0 8
19758: PPUSH
19759: LD_VAR 0 2
19763: PPUSH
19764: CALL 21023 0 2
19768: PPUSH
19769: CALL_OW 431
// end ;
19773: GO 19734
19775: POP
19776: POP
// end ; for i = 1 to personel do
19777: LD_ADDR_VAR 0 8
19781: PUSH
19782: DOUBLE
19783: LD_INT 1
19785: DEC
19786: ST_TO_ADDR
19787: LD_VAR 0 6
19791: PUSH
19792: FOR_TO
19793: IFFALSE 20857
// begin if i > 4 then
19795: LD_VAR 0 8
19799: PUSH
19800: LD_INT 4
19802: GREATER
19803: IFFALSE 19807
// break ;
19805: GO 20857
// case i of 1 :
19807: LD_VAR 0 8
19811: PUSH
19812: LD_INT 1
19814: DOUBLE
19815: EQUAL
19816: IFTRUE 19820
19818: GO 19900
19820: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19821: LD_ADDR_VAR 0 12
19825: PUSH
19826: LD_VAR 0 18
19830: PPUSH
19831: LD_INT 22
19833: PUSH
19834: LD_VAR 0 16
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: PUSH
19843: LD_INT 58
19845: PUSH
19846: EMPTY
19847: LIST
19848: PUSH
19849: LD_INT 2
19851: PUSH
19852: LD_INT 30
19854: PUSH
19855: LD_INT 32
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: PUSH
19862: LD_INT 30
19864: PUSH
19865: LD_INT 4
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PUSH
19872: LD_INT 30
19874: PUSH
19875: LD_INT 5
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: PUSH
19888: EMPTY
19889: LIST
19890: LIST
19891: LIST
19892: PPUSH
19893: CALL_OW 72
19897: ST_TO_ADDR
19898: GO 20122
19900: LD_INT 2
19902: DOUBLE
19903: EQUAL
19904: IFTRUE 19908
19906: GO 19970
19908: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19909: LD_ADDR_VAR 0 12
19913: PUSH
19914: LD_VAR 0 18
19918: PPUSH
19919: LD_INT 22
19921: PUSH
19922: LD_VAR 0 16
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: PUSH
19931: LD_INT 2
19933: PUSH
19934: LD_INT 30
19936: PUSH
19937: LD_INT 0
19939: PUSH
19940: EMPTY
19941: LIST
19942: LIST
19943: PUSH
19944: LD_INT 30
19946: PUSH
19947: LD_INT 1
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: LIST
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: PPUSH
19963: CALL_OW 72
19967: ST_TO_ADDR
19968: GO 20122
19970: LD_INT 3
19972: DOUBLE
19973: EQUAL
19974: IFTRUE 19978
19976: GO 20040
19978: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19979: LD_ADDR_VAR 0 12
19983: PUSH
19984: LD_VAR 0 18
19988: PPUSH
19989: LD_INT 22
19991: PUSH
19992: LD_VAR 0 16
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: LD_INT 2
20003: PUSH
20004: LD_INT 30
20006: PUSH
20007: LD_INT 2
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: PUSH
20014: LD_INT 30
20016: PUSH
20017: LD_INT 3
20019: PUSH
20020: EMPTY
20021: LIST
20022: LIST
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: LIST
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: PPUSH
20033: CALL_OW 72
20037: ST_TO_ADDR
20038: GO 20122
20040: LD_INT 4
20042: DOUBLE
20043: EQUAL
20044: IFTRUE 20048
20046: GO 20121
20048: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20049: LD_ADDR_VAR 0 12
20053: PUSH
20054: LD_VAR 0 18
20058: PPUSH
20059: LD_INT 22
20061: PUSH
20062: LD_VAR 0 16
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 2
20073: PUSH
20074: LD_INT 30
20076: PUSH
20077: LD_INT 6
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: PUSH
20084: LD_INT 30
20086: PUSH
20087: LD_INT 7
20089: PUSH
20090: EMPTY
20091: LIST
20092: LIST
20093: PUSH
20094: LD_INT 30
20096: PUSH
20097: LD_INT 8
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: PUSH
20104: EMPTY
20105: LIST
20106: LIST
20107: LIST
20108: LIST
20109: PUSH
20110: EMPTY
20111: LIST
20112: LIST
20113: PPUSH
20114: CALL_OW 72
20118: ST_TO_ADDR
20119: GO 20122
20121: POP
// if i = 1 then
20122: LD_VAR 0 8
20126: PUSH
20127: LD_INT 1
20129: EQUAL
20130: IFFALSE 20241
// begin tmp := [ ] ;
20132: LD_ADDR_VAR 0 19
20136: PUSH
20137: EMPTY
20138: ST_TO_ADDR
// for j in f do
20139: LD_ADDR_VAR 0 9
20143: PUSH
20144: LD_VAR 0 12
20148: PUSH
20149: FOR_IN
20150: IFFALSE 20223
// if GetBType ( j ) = b_bunker then
20152: LD_VAR 0 9
20156: PPUSH
20157: CALL_OW 266
20161: PUSH
20162: LD_INT 32
20164: EQUAL
20165: IFFALSE 20192
// tmp := Insert ( tmp , 1 , j ) else
20167: LD_ADDR_VAR 0 19
20171: PUSH
20172: LD_VAR 0 19
20176: PPUSH
20177: LD_INT 1
20179: PPUSH
20180: LD_VAR 0 9
20184: PPUSH
20185: CALL_OW 2
20189: ST_TO_ADDR
20190: GO 20221
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20192: LD_ADDR_VAR 0 19
20196: PUSH
20197: LD_VAR 0 19
20201: PPUSH
20202: LD_VAR 0 19
20206: PUSH
20207: LD_INT 1
20209: PLUS
20210: PPUSH
20211: LD_VAR 0 9
20215: PPUSH
20216: CALL_OW 2
20220: ST_TO_ADDR
20221: GO 20149
20223: POP
20224: POP
// if tmp then
20225: LD_VAR 0 19
20229: IFFALSE 20241
// f := tmp ;
20231: LD_ADDR_VAR 0 12
20235: PUSH
20236: LD_VAR 0 19
20240: ST_TO_ADDR
// end ; x := personel [ i ] ;
20241: LD_ADDR_VAR 0 13
20245: PUSH
20246: LD_VAR 0 6
20250: PUSH
20251: LD_VAR 0 8
20255: ARRAY
20256: ST_TO_ADDR
// if x = - 1 then
20257: LD_VAR 0 13
20261: PUSH
20262: LD_INT 1
20264: NEG
20265: EQUAL
20266: IFFALSE 20475
// begin for j in f do
20268: LD_ADDR_VAR 0 9
20272: PUSH
20273: LD_VAR 0 12
20277: PUSH
20278: FOR_IN
20279: IFFALSE 20471
// repeat InitHc ;
20281: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20285: LD_VAR 0 9
20289: PPUSH
20290: CALL_OW 266
20294: PUSH
20295: LD_INT 5
20297: EQUAL
20298: IFFALSE 20368
// begin if UnitsInside ( j ) < 3 then
20300: LD_VAR 0 9
20304: PPUSH
20305: CALL_OW 313
20309: PUSH
20310: LD_INT 3
20312: LESS
20313: IFFALSE 20349
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20315: LD_INT 0
20317: PPUSH
20318: LD_INT 5
20320: PUSH
20321: LD_INT 8
20323: PUSH
20324: LD_INT 9
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: PUSH
20332: LD_VAR 0 17
20336: ARRAY
20337: PPUSH
20338: LD_VAR 0 4
20342: PPUSH
20343: CALL_OW 380
20347: GO 20366
// PrepareHuman ( false , i , skill ) ;
20349: LD_INT 0
20351: PPUSH
20352: LD_VAR 0 8
20356: PPUSH
20357: LD_VAR 0 4
20361: PPUSH
20362: CALL_OW 380
// end else
20366: GO 20385
// PrepareHuman ( false , i , skill ) ;
20368: LD_INT 0
20370: PPUSH
20371: LD_VAR 0 8
20375: PPUSH
20376: LD_VAR 0 4
20380: PPUSH
20381: CALL_OW 380
// un := CreateHuman ;
20385: LD_ADDR_VAR 0 14
20389: PUSH
20390: CALL_OW 44
20394: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20395: LD_ADDR_VAR 0 7
20399: PUSH
20400: LD_VAR 0 7
20404: PPUSH
20405: LD_INT 1
20407: PPUSH
20408: LD_VAR 0 14
20412: PPUSH
20413: CALL_OW 2
20417: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20418: LD_VAR 0 14
20422: PPUSH
20423: LD_VAR 0 9
20427: PPUSH
20428: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20432: LD_VAR 0 9
20436: PPUSH
20437: CALL_OW 313
20441: PUSH
20442: LD_INT 6
20444: EQUAL
20445: PUSH
20446: LD_VAR 0 9
20450: PPUSH
20451: CALL_OW 266
20455: PUSH
20456: LD_INT 32
20458: PUSH
20459: LD_INT 31
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: IN
20466: OR
20467: IFFALSE 20281
20469: GO 20278
20471: POP
20472: POP
// end else
20473: GO 20855
// for j = 1 to x do
20475: LD_ADDR_VAR 0 9
20479: PUSH
20480: DOUBLE
20481: LD_INT 1
20483: DEC
20484: ST_TO_ADDR
20485: LD_VAR 0 13
20489: PUSH
20490: FOR_TO
20491: IFFALSE 20853
// begin InitHc ;
20493: CALL_OW 19
// if not f then
20497: LD_VAR 0 12
20501: NOT
20502: IFFALSE 20591
// begin PrepareHuman ( false , i , skill ) ;
20504: LD_INT 0
20506: PPUSH
20507: LD_VAR 0 8
20511: PPUSH
20512: LD_VAR 0 4
20516: PPUSH
20517: CALL_OW 380
// un := CreateHuman ;
20521: LD_ADDR_VAR 0 14
20525: PUSH
20526: CALL_OW 44
20530: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20531: LD_ADDR_VAR 0 7
20535: PUSH
20536: LD_VAR 0 7
20540: PPUSH
20541: LD_INT 1
20543: PPUSH
20544: LD_VAR 0 14
20548: PPUSH
20549: CALL_OW 2
20553: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20554: LD_VAR 0 14
20558: PPUSH
20559: LD_VAR 0 1
20563: PPUSH
20564: CALL_OW 250
20568: PPUSH
20569: LD_VAR 0 1
20573: PPUSH
20574: CALL_OW 251
20578: PPUSH
20579: LD_INT 10
20581: PPUSH
20582: LD_INT 0
20584: PPUSH
20585: CALL_OW 50
// continue ;
20589: GO 20490
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20591: LD_VAR 0 12
20595: PUSH
20596: LD_INT 1
20598: ARRAY
20599: PPUSH
20600: CALL_OW 313
20604: PUSH
20605: LD_VAR 0 12
20609: PUSH
20610: LD_INT 1
20612: ARRAY
20613: PPUSH
20614: CALL_OW 266
20618: PUSH
20619: LD_INT 32
20621: PUSH
20622: LD_INT 31
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: IN
20629: AND
20630: PUSH
20631: LD_VAR 0 12
20635: PUSH
20636: LD_INT 1
20638: ARRAY
20639: PPUSH
20640: CALL_OW 313
20644: PUSH
20645: LD_INT 6
20647: EQUAL
20648: OR
20649: IFFALSE 20669
// f := Delete ( f , 1 ) ;
20651: LD_ADDR_VAR 0 12
20655: PUSH
20656: LD_VAR 0 12
20660: PPUSH
20661: LD_INT 1
20663: PPUSH
20664: CALL_OW 3
20668: ST_TO_ADDR
// if not f then
20669: LD_VAR 0 12
20673: NOT
20674: IFFALSE 20692
// begin x := x + 2 ;
20676: LD_ADDR_VAR 0 13
20680: PUSH
20681: LD_VAR 0 13
20685: PUSH
20686: LD_INT 2
20688: PLUS
20689: ST_TO_ADDR
// continue ;
20690: GO 20490
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20692: LD_VAR 0 12
20696: PUSH
20697: LD_INT 1
20699: ARRAY
20700: PPUSH
20701: CALL_OW 266
20705: PUSH
20706: LD_INT 5
20708: EQUAL
20709: IFFALSE 20783
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20711: LD_VAR 0 12
20715: PUSH
20716: LD_INT 1
20718: ARRAY
20719: PPUSH
20720: CALL_OW 313
20724: PUSH
20725: LD_INT 3
20727: LESS
20728: IFFALSE 20764
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20730: LD_INT 0
20732: PPUSH
20733: LD_INT 5
20735: PUSH
20736: LD_INT 8
20738: PUSH
20739: LD_INT 9
20741: PUSH
20742: EMPTY
20743: LIST
20744: LIST
20745: LIST
20746: PUSH
20747: LD_VAR 0 17
20751: ARRAY
20752: PPUSH
20753: LD_VAR 0 4
20757: PPUSH
20758: CALL_OW 380
20762: GO 20781
// PrepareHuman ( false , i , skill ) ;
20764: LD_INT 0
20766: PPUSH
20767: LD_VAR 0 8
20771: PPUSH
20772: LD_VAR 0 4
20776: PPUSH
20777: CALL_OW 380
// end else
20781: GO 20800
// PrepareHuman ( false , i , skill ) ;
20783: LD_INT 0
20785: PPUSH
20786: LD_VAR 0 8
20790: PPUSH
20791: LD_VAR 0 4
20795: PPUSH
20796: CALL_OW 380
// un := CreateHuman ;
20800: LD_ADDR_VAR 0 14
20804: PUSH
20805: CALL_OW 44
20809: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20810: LD_ADDR_VAR 0 7
20814: PUSH
20815: LD_VAR 0 7
20819: PPUSH
20820: LD_INT 1
20822: PPUSH
20823: LD_VAR 0 14
20827: PPUSH
20828: CALL_OW 2
20832: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20833: LD_VAR 0 14
20837: PPUSH
20838: LD_VAR 0 12
20842: PUSH
20843: LD_INT 1
20845: ARRAY
20846: PPUSH
20847: CALL_OW 52
// end ;
20851: GO 20490
20853: POP
20854: POP
// end ;
20855: GO 19792
20857: POP
20858: POP
// result := result ^ buildings ;
20859: LD_ADDR_VAR 0 7
20863: PUSH
20864: LD_VAR 0 7
20868: PUSH
20869: LD_VAR 0 18
20873: ADD
20874: ST_TO_ADDR
// end else
20875: GO 21018
// begin for i = 1 to personel do
20877: LD_ADDR_VAR 0 8
20881: PUSH
20882: DOUBLE
20883: LD_INT 1
20885: DEC
20886: ST_TO_ADDR
20887: LD_VAR 0 6
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21016
// begin if i > 4 then
20895: LD_VAR 0 8
20899: PUSH
20900: LD_INT 4
20902: GREATER
20903: IFFALSE 20907
// break ;
20905: GO 21016
// x := personel [ i ] ;
20907: LD_ADDR_VAR 0 13
20911: PUSH
20912: LD_VAR 0 6
20916: PUSH
20917: LD_VAR 0 8
20921: ARRAY
20922: ST_TO_ADDR
// if x = - 1 then
20923: LD_VAR 0 13
20927: PUSH
20928: LD_INT 1
20930: NEG
20931: EQUAL
20932: IFFALSE 20936
// continue ;
20934: GO 20892
// PrepareHuman ( false , i , skill ) ;
20936: LD_INT 0
20938: PPUSH
20939: LD_VAR 0 8
20943: PPUSH
20944: LD_VAR 0 4
20948: PPUSH
20949: CALL_OW 380
// un := CreateHuman ;
20953: LD_ADDR_VAR 0 14
20957: PUSH
20958: CALL_OW 44
20962: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20963: LD_VAR 0 14
20967: PPUSH
20968: LD_VAR 0 1
20972: PPUSH
20973: CALL_OW 250
20977: PPUSH
20978: LD_VAR 0 1
20982: PPUSH
20983: CALL_OW 251
20987: PPUSH
20988: LD_INT 10
20990: PPUSH
20991: LD_INT 0
20993: PPUSH
20994: CALL_OW 50
// result := result ^ un ;
20998: LD_ADDR_VAR 0 7
21002: PUSH
21003: LD_VAR 0 7
21007: PUSH
21008: LD_VAR 0 14
21012: ADD
21013: ST_TO_ADDR
// end ;
21014: GO 20892
21016: POP
21017: POP
// end ; end ;
21018: LD_VAR 0 7
21022: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21023: LD_INT 0
21025: PPUSH
21026: PPUSH
21027: PPUSH
21028: PPUSH
21029: PPUSH
21030: PPUSH
21031: PPUSH
21032: PPUSH
21033: PPUSH
21034: PPUSH
21035: PPUSH
21036: PPUSH
21037: PPUSH
21038: PPUSH
21039: PPUSH
21040: PPUSH
// result := false ;
21041: LD_ADDR_VAR 0 3
21045: PUSH
21046: LD_INT 0
21048: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21049: LD_VAR 0 1
21053: NOT
21054: PUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: CALL_OW 266
21064: PUSH
21065: LD_INT 32
21067: PUSH
21068: LD_INT 33
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: IN
21075: NOT
21076: OR
21077: IFFALSE 21081
// exit ;
21079: GO 22190
// nat := GetNation ( tower ) ;
21081: LD_ADDR_VAR 0 12
21085: PUSH
21086: LD_VAR 0 1
21090: PPUSH
21091: CALL_OW 248
21095: ST_TO_ADDR
// side := GetSide ( tower ) ;
21096: LD_ADDR_VAR 0 16
21100: PUSH
21101: LD_VAR 0 1
21105: PPUSH
21106: CALL_OW 255
21110: ST_TO_ADDR
// x := GetX ( tower ) ;
21111: LD_ADDR_VAR 0 10
21115: PUSH
21116: LD_VAR 0 1
21120: PPUSH
21121: CALL_OW 250
21125: ST_TO_ADDR
// y := GetY ( tower ) ;
21126: LD_ADDR_VAR 0 11
21130: PUSH
21131: LD_VAR 0 1
21135: PPUSH
21136: CALL_OW 251
21140: ST_TO_ADDR
// if not x or not y then
21141: LD_VAR 0 10
21145: NOT
21146: PUSH
21147: LD_VAR 0 11
21151: NOT
21152: OR
21153: IFFALSE 21157
// exit ;
21155: GO 22190
// weapon := 0 ;
21157: LD_ADDR_VAR 0 18
21161: PUSH
21162: LD_INT 0
21164: ST_TO_ADDR
// fac_list := [ ] ;
21165: LD_ADDR_VAR 0 17
21169: PUSH
21170: EMPTY
21171: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21172: LD_ADDR_VAR 0 6
21176: PUSH
21177: LD_VAR 0 1
21181: PPUSH
21182: CALL_OW 274
21186: PPUSH
21187: LD_VAR 0 2
21191: PPUSH
21192: LD_INT 0
21194: PPUSH
21195: CALL 18761 0 3
21199: PPUSH
21200: LD_INT 30
21202: PUSH
21203: LD_INT 3
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: PPUSH
21210: CALL_OW 72
21214: ST_TO_ADDR
// if not factories then
21215: LD_VAR 0 6
21219: NOT
21220: IFFALSE 21224
// exit ;
21222: GO 22190
// for i in factories do
21224: LD_ADDR_VAR 0 8
21228: PUSH
21229: LD_VAR 0 6
21233: PUSH
21234: FOR_IN
21235: IFFALSE 21260
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21237: LD_ADDR_VAR 0 17
21241: PUSH
21242: LD_VAR 0 17
21246: PUSH
21247: LD_VAR 0 8
21251: PPUSH
21252: CALL_OW 478
21256: UNION
21257: ST_TO_ADDR
21258: GO 21234
21260: POP
21261: POP
// if not fac_list then
21262: LD_VAR 0 17
21266: NOT
21267: IFFALSE 21271
// exit ;
21269: GO 22190
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21271: LD_ADDR_VAR 0 5
21275: PUSH
21276: LD_INT 4
21278: PUSH
21279: LD_INT 5
21281: PUSH
21282: LD_INT 9
21284: PUSH
21285: LD_INT 10
21287: PUSH
21288: LD_INT 6
21290: PUSH
21291: LD_INT 7
21293: PUSH
21294: LD_INT 11
21296: PUSH
21297: EMPTY
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: PUSH
21306: LD_INT 27
21308: PUSH
21309: LD_INT 28
21311: PUSH
21312: LD_INT 26
21314: PUSH
21315: LD_INT 30
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: PUSH
21324: LD_INT 43
21326: PUSH
21327: LD_INT 44
21329: PUSH
21330: LD_INT 46
21332: PUSH
21333: LD_INT 45
21335: PUSH
21336: LD_INT 47
21338: PUSH
21339: LD_INT 49
21341: PUSH
21342: EMPTY
21343: LIST
21344: LIST
21345: LIST
21346: LIST
21347: LIST
21348: LIST
21349: PUSH
21350: EMPTY
21351: LIST
21352: LIST
21353: LIST
21354: PUSH
21355: LD_VAR 0 12
21359: ARRAY
21360: ST_TO_ADDR
// list := list isect fac_list ;
21361: LD_ADDR_VAR 0 5
21365: PUSH
21366: LD_VAR 0 5
21370: PUSH
21371: LD_VAR 0 17
21375: ISECT
21376: ST_TO_ADDR
// if not list then
21377: LD_VAR 0 5
21381: NOT
21382: IFFALSE 21386
// exit ;
21384: GO 22190
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21386: LD_VAR 0 12
21390: PUSH
21391: LD_INT 3
21393: EQUAL
21394: PUSH
21395: LD_INT 49
21397: PUSH
21398: LD_VAR 0 5
21402: IN
21403: AND
21404: PUSH
21405: LD_INT 31
21407: PPUSH
21408: LD_VAR 0 16
21412: PPUSH
21413: CALL_OW 321
21417: PUSH
21418: LD_INT 2
21420: EQUAL
21421: AND
21422: IFFALSE 21482
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21424: LD_INT 22
21426: PUSH
21427: LD_VAR 0 16
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: PUSH
21436: LD_INT 35
21438: PUSH
21439: LD_INT 49
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: PUSH
21446: LD_INT 91
21448: PUSH
21449: LD_VAR 0 1
21453: PUSH
21454: LD_INT 10
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: LIST
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: LIST
21466: PPUSH
21467: CALL_OW 69
21471: NOT
21472: IFFALSE 21482
// weapon := ru_time_lapser ;
21474: LD_ADDR_VAR 0 18
21478: PUSH
21479: LD_INT 49
21481: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21482: LD_VAR 0 12
21486: PUSH
21487: LD_INT 1
21489: PUSH
21490: LD_INT 2
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: IN
21497: PUSH
21498: LD_INT 11
21500: PUSH
21501: LD_VAR 0 5
21505: IN
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_VAR 0 5
21514: IN
21515: OR
21516: AND
21517: PUSH
21518: LD_INT 6
21520: PPUSH
21521: LD_VAR 0 16
21525: PPUSH
21526: CALL_OW 321
21530: PUSH
21531: LD_INT 2
21533: EQUAL
21534: AND
21535: IFFALSE 21700
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21537: LD_INT 22
21539: PUSH
21540: LD_VAR 0 16
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: LD_INT 2
21551: PUSH
21552: LD_INT 35
21554: PUSH
21555: LD_INT 11
21557: PUSH
21558: EMPTY
21559: LIST
21560: LIST
21561: PUSH
21562: LD_INT 35
21564: PUSH
21565: LD_INT 30
21567: PUSH
21568: EMPTY
21569: LIST
21570: LIST
21571: PUSH
21572: EMPTY
21573: LIST
21574: LIST
21575: LIST
21576: PUSH
21577: LD_INT 91
21579: PUSH
21580: LD_VAR 0 1
21584: PUSH
21585: LD_INT 18
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: LIST
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: LIST
21597: PPUSH
21598: CALL_OW 69
21602: NOT
21603: PUSH
21604: LD_INT 22
21606: PUSH
21607: LD_VAR 0 16
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: LD_INT 2
21618: PUSH
21619: LD_INT 30
21621: PUSH
21622: LD_INT 32
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: LD_INT 30
21631: PUSH
21632: LD_INT 33
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: LIST
21643: PUSH
21644: LD_INT 91
21646: PUSH
21647: LD_VAR 0 1
21651: PUSH
21652: LD_INT 12
21654: PUSH
21655: EMPTY
21656: LIST
21657: LIST
21658: LIST
21659: PUSH
21660: EMPTY
21661: LIST
21662: LIST
21663: LIST
21664: PUSH
21665: EMPTY
21666: LIST
21667: PPUSH
21668: CALL_OW 69
21672: PUSH
21673: LD_INT 2
21675: GREATER
21676: AND
21677: IFFALSE 21700
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21679: LD_ADDR_VAR 0 18
21683: PUSH
21684: LD_INT 11
21686: PUSH
21687: LD_INT 30
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: LD_VAR 0 12
21698: ARRAY
21699: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21700: LD_VAR 0 18
21704: NOT
21705: PUSH
21706: LD_INT 40
21708: PPUSH
21709: LD_VAR 0 16
21713: PPUSH
21714: CALL_OW 321
21718: PUSH
21719: LD_INT 2
21721: EQUAL
21722: AND
21723: PUSH
21724: LD_INT 7
21726: PUSH
21727: LD_VAR 0 5
21731: IN
21732: PUSH
21733: LD_INT 28
21735: PUSH
21736: LD_VAR 0 5
21740: IN
21741: OR
21742: PUSH
21743: LD_INT 45
21745: PUSH
21746: LD_VAR 0 5
21750: IN
21751: OR
21752: AND
21753: IFFALSE 22007
// begin hex := GetHexInfo ( x , y ) ;
21755: LD_ADDR_VAR 0 4
21759: PUSH
21760: LD_VAR 0 10
21764: PPUSH
21765: LD_VAR 0 11
21769: PPUSH
21770: CALL_OW 546
21774: ST_TO_ADDR
// if hex [ 1 ] then
21775: LD_VAR 0 4
21779: PUSH
21780: LD_INT 1
21782: ARRAY
21783: IFFALSE 21787
// exit ;
21785: GO 22190
// height := hex [ 2 ] ;
21787: LD_ADDR_VAR 0 15
21791: PUSH
21792: LD_VAR 0 4
21796: PUSH
21797: LD_INT 2
21799: ARRAY
21800: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21801: LD_ADDR_VAR 0 14
21805: PUSH
21806: LD_INT 0
21808: PUSH
21809: LD_INT 2
21811: PUSH
21812: LD_INT 3
21814: PUSH
21815: LD_INT 5
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: LIST
21822: LIST
21823: ST_TO_ADDR
// for i in tmp do
21824: LD_ADDR_VAR 0 8
21828: PUSH
21829: LD_VAR 0 14
21833: PUSH
21834: FOR_IN
21835: IFFALSE 22005
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21837: LD_ADDR_VAR 0 9
21841: PUSH
21842: LD_VAR 0 10
21846: PPUSH
21847: LD_VAR 0 8
21851: PPUSH
21852: LD_INT 5
21854: PPUSH
21855: CALL_OW 272
21859: PUSH
21860: LD_VAR 0 11
21864: PPUSH
21865: LD_VAR 0 8
21869: PPUSH
21870: LD_INT 5
21872: PPUSH
21873: CALL_OW 273
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21882: LD_VAR 0 9
21886: PUSH
21887: LD_INT 1
21889: ARRAY
21890: PPUSH
21891: LD_VAR 0 9
21895: PUSH
21896: LD_INT 2
21898: ARRAY
21899: PPUSH
21900: CALL_OW 488
21904: IFFALSE 22003
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21906: LD_ADDR_VAR 0 4
21910: PUSH
21911: LD_VAR 0 9
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: PPUSH
21920: LD_VAR 0 9
21924: PUSH
21925: LD_INT 2
21927: ARRAY
21928: PPUSH
21929: CALL_OW 546
21933: ST_TO_ADDR
// if hex [ 1 ] then
21934: LD_VAR 0 4
21938: PUSH
21939: LD_INT 1
21941: ARRAY
21942: IFFALSE 21946
// continue ;
21944: GO 21834
// h := hex [ 2 ] ;
21946: LD_ADDR_VAR 0 13
21950: PUSH
21951: LD_VAR 0 4
21955: PUSH
21956: LD_INT 2
21958: ARRAY
21959: ST_TO_ADDR
// if h + 7 < height then
21960: LD_VAR 0 13
21964: PUSH
21965: LD_INT 7
21967: PLUS
21968: PUSH
21969: LD_VAR 0 15
21973: LESS
21974: IFFALSE 22003
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21976: LD_ADDR_VAR 0 18
21980: PUSH
21981: LD_INT 7
21983: PUSH
21984: LD_INT 28
21986: PUSH
21987: LD_INT 45
21989: PUSH
21990: EMPTY
21991: LIST
21992: LIST
21993: LIST
21994: PUSH
21995: LD_VAR 0 12
21999: ARRAY
22000: ST_TO_ADDR
// break ;
22001: GO 22005
// end ; end ; end ;
22003: GO 21834
22005: POP
22006: POP
// end ; if not weapon then
22007: LD_VAR 0 18
22011: NOT
22012: IFFALSE 22072
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22014: LD_ADDR_VAR 0 5
22018: PUSH
22019: LD_VAR 0 5
22023: PUSH
22024: LD_INT 11
22026: PUSH
22027: LD_INT 30
22029: PUSH
22030: LD_INT 49
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: LIST
22037: DIFF
22038: ST_TO_ADDR
// if not list then
22039: LD_VAR 0 5
22043: NOT
22044: IFFALSE 22048
// exit ;
22046: GO 22190
// weapon := list [ rand ( 1 , list ) ] ;
22048: LD_ADDR_VAR 0 18
22052: PUSH
22053: LD_VAR 0 5
22057: PUSH
22058: LD_INT 1
22060: PPUSH
22061: LD_VAR 0 5
22065: PPUSH
22066: CALL_OW 12
22070: ARRAY
22071: ST_TO_ADDR
// end ; if weapon then
22072: LD_VAR 0 18
22076: IFFALSE 22190
// begin tmp := CostOfWeapon ( weapon ) ;
22078: LD_ADDR_VAR 0 14
22082: PUSH
22083: LD_VAR 0 18
22087: PPUSH
22088: CALL_OW 451
22092: ST_TO_ADDR
// j := GetBase ( tower ) ;
22093: LD_ADDR_VAR 0 9
22097: PUSH
22098: LD_VAR 0 1
22102: PPUSH
22103: CALL_OW 274
22107: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22108: LD_VAR 0 9
22112: PPUSH
22113: LD_INT 1
22115: PPUSH
22116: CALL_OW 275
22120: PUSH
22121: LD_VAR 0 14
22125: PUSH
22126: LD_INT 1
22128: ARRAY
22129: GREATEREQUAL
22130: PUSH
22131: LD_VAR 0 9
22135: PPUSH
22136: LD_INT 2
22138: PPUSH
22139: CALL_OW 275
22143: PUSH
22144: LD_VAR 0 14
22148: PUSH
22149: LD_INT 2
22151: ARRAY
22152: GREATEREQUAL
22153: AND
22154: PUSH
22155: LD_VAR 0 9
22159: PPUSH
22160: LD_INT 3
22162: PPUSH
22163: CALL_OW 275
22167: PUSH
22168: LD_VAR 0 14
22172: PUSH
22173: LD_INT 3
22175: ARRAY
22176: GREATEREQUAL
22177: AND
22178: IFFALSE 22190
// result := weapon ;
22180: LD_ADDR_VAR 0 3
22184: PUSH
22185: LD_VAR 0 18
22189: ST_TO_ADDR
// end ; end ;
22190: LD_VAR 0 3
22194: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22195: LD_INT 0
22197: PPUSH
22198: PPUSH
// result := true ;
22199: LD_ADDR_VAR 0 3
22203: PUSH
22204: LD_INT 1
22206: ST_TO_ADDR
// if array1 = array2 then
22207: LD_VAR 0 1
22211: PUSH
22212: LD_VAR 0 2
22216: EQUAL
22217: IFFALSE 22277
// begin for i = 1 to array1 do
22219: LD_ADDR_VAR 0 4
22223: PUSH
22224: DOUBLE
22225: LD_INT 1
22227: DEC
22228: ST_TO_ADDR
22229: LD_VAR 0 1
22233: PUSH
22234: FOR_TO
22235: IFFALSE 22273
// if array1 [ i ] <> array2 [ i ] then
22237: LD_VAR 0 1
22241: PUSH
22242: LD_VAR 0 4
22246: ARRAY
22247: PUSH
22248: LD_VAR 0 2
22252: PUSH
22253: LD_VAR 0 4
22257: ARRAY
22258: NONEQUAL
22259: IFFALSE 22271
// begin result := false ;
22261: LD_ADDR_VAR 0 3
22265: PUSH
22266: LD_INT 0
22268: ST_TO_ADDR
// break ;
22269: GO 22273
// end ;
22271: GO 22234
22273: POP
22274: POP
// end else
22275: GO 22285
// result := false ;
22277: LD_ADDR_VAR 0 3
22281: PUSH
22282: LD_INT 0
22284: ST_TO_ADDR
// end ;
22285: LD_VAR 0 3
22289: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22290: LD_INT 0
22292: PPUSH
22293: PPUSH
// if not array1 or not array2 then
22294: LD_VAR 0 1
22298: NOT
22299: PUSH
22300: LD_VAR 0 2
22304: NOT
22305: OR
22306: IFFALSE 22310
// exit ;
22308: GO 22374
// result := true ;
22310: LD_ADDR_VAR 0 3
22314: PUSH
22315: LD_INT 1
22317: ST_TO_ADDR
// for i = 1 to array1 do
22318: LD_ADDR_VAR 0 4
22322: PUSH
22323: DOUBLE
22324: LD_INT 1
22326: DEC
22327: ST_TO_ADDR
22328: LD_VAR 0 1
22332: PUSH
22333: FOR_TO
22334: IFFALSE 22372
// if array1 [ i ] <> array2 [ i ] then
22336: LD_VAR 0 1
22340: PUSH
22341: LD_VAR 0 4
22345: ARRAY
22346: PUSH
22347: LD_VAR 0 2
22351: PUSH
22352: LD_VAR 0 4
22356: ARRAY
22357: NONEQUAL
22358: IFFALSE 22370
// begin result := false ;
22360: LD_ADDR_VAR 0 3
22364: PUSH
22365: LD_INT 0
22367: ST_TO_ADDR
// break ;
22368: GO 22372
// end ;
22370: GO 22333
22372: POP
22373: POP
// end ;
22374: LD_VAR 0 3
22378: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22379: LD_INT 0
22381: PPUSH
22382: PPUSH
22383: PPUSH
// pom := GetBase ( fac ) ;
22384: LD_ADDR_VAR 0 5
22388: PUSH
22389: LD_VAR 0 1
22393: PPUSH
22394: CALL_OW 274
22398: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22399: LD_ADDR_VAR 0 4
22403: PUSH
22404: LD_VAR 0 2
22408: PUSH
22409: LD_INT 1
22411: ARRAY
22412: PPUSH
22413: LD_VAR 0 2
22417: PUSH
22418: LD_INT 2
22420: ARRAY
22421: PPUSH
22422: LD_VAR 0 2
22426: PUSH
22427: LD_INT 3
22429: ARRAY
22430: PPUSH
22431: LD_VAR 0 2
22435: PUSH
22436: LD_INT 4
22438: ARRAY
22439: PPUSH
22440: CALL_OW 449
22444: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22445: LD_ADDR_VAR 0 3
22449: PUSH
22450: LD_VAR 0 5
22454: PPUSH
22455: LD_INT 1
22457: PPUSH
22458: CALL_OW 275
22462: PUSH
22463: LD_VAR 0 4
22467: PUSH
22468: LD_INT 1
22470: ARRAY
22471: GREATEREQUAL
22472: PUSH
22473: LD_VAR 0 5
22477: PPUSH
22478: LD_INT 2
22480: PPUSH
22481: CALL_OW 275
22485: PUSH
22486: LD_VAR 0 4
22490: PUSH
22491: LD_INT 2
22493: ARRAY
22494: GREATEREQUAL
22495: AND
22496: PUSH
22497: LD_VAR 0 5
22501: PPUSH
22502: LD_INT 3
22504: PPUSH
22505: CALL_OW 275
22509: PUSH
22510: LD_VAR 0 4
22514: PUSH
22515: LD_INT 3
22517: ARRAY
22518: GREATEREQUAL
22519: AND
22520: ST_TO_ADDR
// end ;
22521: LD_VAR 0 3
22525: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22526: LD_INT 0
22528: PPUSH
22529: PPUSH
22530: PPUSH
22531: PPUSH
// pom := GetBase ( building ) ;
22532: LD_ADDR_VAR 0 3
22536: PUSH
22537: LD_VAR 0 1
22541: PPUSH
22542: CALL_OW 274
22546: ST_TO_ADDR
// if not pom then
22547: LD_VAR 0 3
22551: NOT
22552: IFFALSE 22556
// exit ;
22554: GO 22726
// btype := GetBType ( building ) ;
22556: LD_ADDR_VAR 0 5
22560: PUSH
22561: LD_VAR 0 1
22565: PPUSH
22566: CALL_OW 266
22570: ST_TO_ADDR
// if btype = b_armoury then
22571: LD_VAR 0 5
22575: PUSH
22576: LD_INT 4
22578: EQUAL
22579: IFFALSE 22589
// btype := b_barracks ;
22581: LD_ADDR_VAR 0 5
22585: PUSH
22586: LD_INT 5
22588: ST_TO_ADDR
// if btype = b_depot then
22589: LD_VAR 0 5
22593: PUSH
22594: LD_INT 0
22596: EQUAL
22597: IFFALSE 22607
// btype := b_warehouse ;
22599: LD_ADDR_VAR 0 5
22603: PUSH
22604: LD_INT 1
22606: ST_TO_ADDR
// if btype = b_workshop then
22607: LD_VAR 0 5
22611: PUSH
22612: LD_INT 2
22614: EQUAL
22615: IFFALSE 22625
// btype := b_factory ;
22617: LD_ADDR_VAR 0 5
22621: PUSH
22622: LD_INT 3
22624: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22625: LD_ADDR_VAR 0 4
22629: PUSH
22630: LD_VAR 0 5
22634: PPUSH
22635: LD_VAR 0 1
22639: PPUSH
22640: CALL_OW 248
22644: PPUSH
22645: CALL_OW 450
22649: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22650: LD_ADDR_VAR 0 2
22654: PUSH
22655: LD_VAR 0 3
22659: PPUSH
22660: LD_INT 1
22662: PPUSH
22663: CALL_OW 275
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_INT 1
22675: ARRAY
22676: GREATEREQUAL
22677: PUSH
22678: LD_VAR 0 3
22682: PPUSH
22683: LD_INT 2
22685: PPUSH
22686: CALL_OW 275
22690: PUSH
22691: LD_VAR 0 4
22695: PUSH
22696: LD_INT 2
22698: ARRAY
22699: GREATEREQUAL
22700: AND
22701: PUSH
22702: LD_VAR 0 3
22706: PPUSH
22707: LD_INT 3
22709: PPUSH
22710: CALL_OW 275
22714: PUSH
22715: LD_VAR 0 4
22719: PUSH
22720: LD_INT 3
22722: ARRAY
22723: GREATEREQUAL
22724: AND
22725: ST_TO_ADDR
// end ;
22726: LD_VAR 0 2
22730: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22731: LD_INT 0
22733: PPUSH
22734: PPUSH
22735: PPUSH
// pom := GetBase ( building ) ;
22736: LD_ADDR_VAR 0 4
22740: PUSH
22741: LD_VAR 0 1
22745: PPUSH
22746: CALL_OW 274
22750: ST_TO_ADDR
// if not pom then
22751: LD_VAR 0 4
22755: NOT
22756: IFFALSE 22760
// exit ;
22758: GO 22861
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22760: LD_ADDR_VAR 0 5
22764: PUSH
22765: LD_VAR 0 2
22769: PPUSH
22770: LD_VAR 0 1
22774: PPUSH
22775: CALL_OW 248
22779: PPUSH
22780: CALL_OW 450
22784: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22785: LD_ADDR_VAR 0 3
22789: PUSH
22790: LD_VAR 0 4
22794: PPUSH
22795: LD_INT 1
22797: PPUSH
22798: CALL_OW 275
22802: PUSH
22803: LD_VAR 0 5
22807: PUSH
22808: LD_INT 1
22810: ARRAY
22811: GREATEREQUAL
22812: PUSH
22813: LD_VAR 0 4
22817: PPUSH
22818: LD_INT 2
22820: PPUSH
22821: CALL_OW 275
22825: PUSH
22826: LD_VAR 0 5
22830: PUSH
22831: LD_INT 2
22833: ARRAY
22834: GREATEREQUAL
22835: AND
22836: PUSH
22837: LD_VAR 0 4
22841: PPUSH
22842: LD_INT 3
22844: PPUSH
22845: CALL_OW 275
22849: PUSH
22850: LD_VAR 0 5
22854: PUSH
22855: LD_INT 3
22857: ARRAY
22858: GREATEREQUAL
22859: AND
22860: ST_TO_ADDR
// end ;
22861: LD_VAR 0 3
22865: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22866: LD_INT 0
22868: PPUSH
22869: PPUSH
22870: PPUSH
22871: PPUSH
22872: PPUSH
22873: PPUSH
22874: PPUSH
22875: PPUSH
22876: PPUSH
22877: PPUSH
22878: PPUSH
// result := false ;
22879: LD_ADDR_VAR 0 8
22883: PUSH
22884: LD_INT 0
22886: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22887: LD_VAR 0 5
22891: NOT
22892: PUSH
22893: LD_VAR 0 1
22897: NOT
22898: OR
22899: PUSH
22900: LD_VAR 0 2
22904: NOT
22905: OR
22906: PUSH
22907: LD_VAR 0 3
22911: NOT
22912: OR
22913: IFFALSE 22917
// exit ;
22915: GO 23731
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22917: LD_ADDR_VAR 0 14
22921: PUSH
22922: LD_VAR 0 1
22926: PPUSH
22927: LD_VAR 0 2
22931: PPUSH
22932: LD_VAR 0 3
22936: PPUSH
22937: LD_VAR 0 4
22941: PPUSH
22942: LD_VAR 0 5
22946: PUSH
22947: LD_INT 1
22949: ARRAY
22950: PPUSH
22951: CALL_OW 248
22955: PPUSH
22956: LD_INT 0
22958: PPUSH
22959: CALL 24968 0 6
22963: ST_TO_ADDR
// if not hexes then
22964: LD_VAR 0 14
22968: NOT
22969: IFFALSE 22973
// exit ;
22971: GO 23731
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22973: LD_ADDR_VAR 0 17
22977: PUSH
22978: LD_VAR 0 5
22982: PPUSH
22983: LD_INT 22
22985: PUSH
22986: LD_VAR 0 13
22990: PPUSH
22991: CALL_OW 255
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: LD_INT 2
23002: PUSH
23003: LD_INT 30
23005: PUSH
23006: LD_INT 0
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: PUSH
23013: LD_INT 30
23015: PUSH
23016: LD_INT 1
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: PUSH
23023: EMPTY
23024: LIST
23025: LIST
23026: LIST
23027: PUSH
23028: EMPTY
23029: LIST
23030: LIST
23031: PPUSH
23032: CALL_OW 72
23036: ST_TO_ADDR
// for i = 1 to hexes do
23037: LD_ADDR_VAR 0 9
23041: PUSH
23042: DOUBLE
23043: LD_INT 1
23045: DEC
23046: ST_TO_ADDR
23047: LD_VAR 0 14
23051: PUSH
23052: FOR_TO
23053: IFFALSE 23729
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23055: LD_ADDR_VAR 0 13
23059: PUSH
23060: LD_VAR 0 14
23064: PUSH
23065: LD_VAR 0 9
23069: ARRAY
23070: PUSH
23071: LD_INT 1
23073: ARRAY
23074: PPUSH
23075: LD_VAR 0 14
23079: PUSH
23080: LD_VAR 0 9
23084: ARRAY
23085: PUSH
23086: LD_INT 2
23088: ARRAY
23089: PPUSH
23090: CALL_OW 428
23094: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23095: LD_VAR 0 14
23099: PUSH
23100: LD_VAR 0 9
23104: ARRAY
23105: PUSH
23106: LD_INT 1
23108: ARRAY
23109: PPUSH
23110: LD_VAR 0 14
23114: PUSH
23115: LD_VAR 0 9
23119: ARRAY
23120: PUSH
23121: LD_INT 2
23123: ARRAY
23124: PPUSH
23125: CALL_OW 351
23129: PUSH
23130: LD_VAR 0 14
23134: PUSH
23135: LD_VAR 0 9
23139: ARRAY
23140: PUSH
23141: LD_INT 1
23143: ARRAY
23144: PPUSH
23145: LD_VAR 0 14
23149: PUSH
23150: LD_VAR 0 9
23154: ARRAY
23155: PUSH
23156: LD_INT 2
23158: ARRAY
23159: PPUSH
23160: CALL_OW 488
23164: NOT
23165: OR
23166: PUSH
23167: LD_VAR 0 13
23171: PPUSH
23172: CALL_OW 247
23176: PUSH
23177: LD_INT 3
23179: EQUAL
23180: OR
23181: IFFALSE 23187
// exit ;
23183: POP
23184: POP
23185: GO 23731
// if not tmp then
23187: LD_VAR 0 13
23191: NOT
23192: IFFALSE 23196
// continue ;
23194: GO 23052
// result := true ;
23196: LD_ADDR_VAR 0 8
23200: PUSH
23201: LD_INT 1
23203: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23204: LD_VAR 0 6
23208: PUSH
23209: LD_VAR 0 13
23213: PPUSH
23214: CALL_OW 247
23218: PUSH
23219: LD_INT 2
23221: EQUAL
23222: AND
23223: PUSH
23224: LD_VAR 0 13
23228: PPUSH
23229: CALL_OW 263
23233: PUSH
23234: LD_INT 1
23236: EQUAL
23237: AND
23238: IFFALSE 23402
// begin if IsDrivenBy ( tmp ) then
23240: LD_VAR 0 13
23244: PPUSH
23245: CALL_OW 311
23249: IFFALSE 23253
// continue ;
23251: GO 23052
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23253: LD_VAR 0 6
23257: PPUSH
23258: LD_INT 3
23260: PUSH
23261: LD_INT 60
23263: PUSH
23264: EMPTY
23265: LIST
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: PUSH
23271: LD_INT 3
23273: PUSH
23274: LD_INT 55
23276: PUSH
23277: EMPTY
23278: LIST
23279: PUSH
23280: EMPTY
23281: LIST
23282: LIST
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PPUSH
23288: CALL_OW 72
23292: IFFALSE 23400
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23294: LD_ADDR_VAR 0 18
23298: PUSH
23299: LD_VAR 0 6
23303: PPUSH
23304: LD_INT 3
23306: PUSH
23307: LD_INT 60
23309: PUSH
23310: EMPTY
23311: LIST
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PUSH
23317: LD_INT 3
23319: PUSH
23320: LD_INT 55
23322: PUSH
23323: EMPTY
23324: LIST
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: PPUSH
23334: CALL_OW 72
23338: PUSH
23339: LD_INT 1
23341: ARRAY
23342: ST_TO_ADDR
// if IsInUnit ( driver ) then
23343: LD_VAR 0 18
23347: PPUSH
23348: CALL_OW 310
23352: IFFALSE 23363
// ComExit ( driver ) ;
23354: LD_VAR 0 18
23358: PPUSH
23359: CALL 48096 0 1
// AddComEnterUnit ( driver , tmp ) ;
23363: LD_VAR 0 18
23367: PPUSH
23368: LD_VAR 0 13
23372: PPUSH
23373: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23377: LD_VAR 0 18
23381: PPUSH
23382: LD_VAR 0 7
23386: PPUSH
23387: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23391: LD_VAR 0 18
23395: PPUSH
23396: CALL_OW 181
// end ; continue ;
23400: GO 23052
// end ; if not cleaners or not tmp in cleaners then
23402: LD_VAR 0 6
23406: NOT
23407: PUSH
23408: LD_VAR 0 13
23412: PUSH
23413: LD_VAR 0 6
23417: IN
23418: NOT
23419: OR
23420: IFFALSE 23727
// begin if dep then
23422: LD_VAR 0 17
23426: IFFALSE 23562
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23428: LD_ADDR_VAR 0 16
23432: PUSH
23433: LD_VAR 0 17
23437: PUSH
23438: LD_INT 1
23440: ARRAY
23441: PPUSH
23442: CALL_OW 250
23446: PPUSH
23447: LD_VAR 0 17
23451: PUSH
23452: LD_INT 1
23454: ARRAY
23455: PPUSH
23456: CALL_OW 254
23460: PPUSH
23461: LD_INT 5
23463: PPUSH
23464: CALL_OW 272
23468: PUSH
23469: LD_VAR 0 17
23473: PUSH
23474: LD_INT 1
23476: ARRAY
23477: PPUSH
23478: CALL_OW 251
23482: PPUSH
23483: LD_VAR 0 17
23487: PUSH
23488: LD_INT 1
23490: ARRAY
23491: PPUSH
23492: CALL_OW 254
23496: PPUSH
23497: LD_INT 5
23499: PPUSH
23500: CALL_OW 273
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23509: LD_VAR 0 16
23513: PUSH
23514: LD_INT 1
23516: ARRAY
23517: PPUSH
23518: LD_VAR 0 16
23522: PUSH
23523: LD_INT 2
23525: ARRAY
23526: PPUSH
23527: CALL_OW 488
23531: IFFALSE 23562
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23533: LD_VAR 0 13
23537: PPUSH
23538: LD_VAR 0 16
23542: PUSH
23543: LD_INT 1
23545: ARRAY
23546: PPUSH
23547: LD_VAR 0 16
23551: PUSH
23552: LD_INT 2
23554: ARRAY
23555: PPUSH
23556: CALL_OW 111
// continue ;
23560: GO 23052
// end ; end ; r := GetDir ( tmp ) ;
23562: LD_ADDR_VAR 0 15
23566: PUSH
23567: LD_VAR 0 13
23571: PPUSH
23572: CALL_OW 254
23576: ST_TO_ADDR
// if r = 5 then
23577: LD_VAR 0 15
23581: PUSH
23582: LD_INT 5
23584: EQUAL
23585: IFFALSE 23595
// r := 0 ;
23587: LD_ADDR_VAR 0 15
23591: PUSH
23592: LD_INT 0
23594: ST_TO_ADDR
// for j = r to 5 do
23595: LD_ADDR_VAR 0 10
23599: PUSH
23600: DOUBLE
23601: LD_VAR 0 15
23605: DEC
23606: ST_TO_ADDR
23607: LD_INT 5
23609: PUSH
23610: FOR_TO
23611: IFFALSE 23725
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23613: LD_ADDR_VAR 0 11
23617: PUSH
23618: LD_VAR 0 13
23622: PPUSH
23623: CALL_OW 250
23627: PPUSH
23628: LD_VAR 0 10
23632: PPUSH
23633: LD_INT 2
23635: PPUSH
23636: CALL_OW 272
23640: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23641: LD_ADDR_VAR 0 12
23645: PUSH
23646: LD_VAR 0 13
23650: PPUSH
23651: CALL_OW 251
23655: PPUSH
23656: LD_VAR 0 10
23660: PPUSH
23661: LD_INT 2
23663: PPUSH
23664: CALL_OW 273
23668: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23669: LD_VAR 0 11
23673: PPUSH
23674: LD_VAR 0 12
23678: PPUSH
23679: CALL_OW 488
23683: PUSH
23684: LD_VAR 0 11
23688: PPUSH
23689: LD_VAR 0 12
23693: PPUSH
23694: CALL_OW 428
23698: NOT
23699: AND
23700: IFFALSE 23723
// begin ComMoveXY ( tmp , _x , _y ) ;
23702: LD_VAR 0 13
23706: PPUSH
23707: LD_VAR 0 11
23711: PPUSH
23712: LD_VAR 0 12
23716: PPUSH
23717: CALL_OW 111
// break ;
23721: GO 23725
// end ; end ;
23723: GO 23610
23725: POP
23726: POP
// end ; end ;
23727: GO 23052
23729: POP
23730: POP
// end ;
23731: LD_VAR 0 8
23735: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23736: LD_INT 0
23738: PPUSH
// result := true ;
23739: LD_ADDR_VAR 0 3
23743: PUSH
23744: LD_INT 1
23746: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23747: LD_VAR 0 2
23751: PUSH
23752: LD_INT 24
23754: DOUBLE
23755: EQUAL
23756: IFTRUE 23766
23758: LD_INT 33
23760: DOUBLE
23761: EQUAL
23762: IFTRUE 23766
23764: GO 23791
23766: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23767: LD_ADDR_VAR 0 3
23771: PUSH
23772: LD_INT 32
23774: PPUSH
23775: LD_VAR 0 1
23779: PPUSH
23780: CALL_OW 321
23784: PUSH
23785: LD_INT 2
23787: EQUAL
23788: ST_TO_ADDR
23789: GO 24111
23791: LD_INT 20
23793: DOUBLE
23794: EQUAL
23795: IFTRUE 23799
23797: GO 23824
23799: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23800: LD_ADDR_VAR 0 3
23804: PUSH
23805: LD_INT 6
23807: PPUSH
23808: LD_VAR 0 1
23812: PPUSH
23813: CALL_OW 321
23817: PUSH
23818: LD_INT 2
23820: EQUAL
23821: ST_TO_ADDR
23822: GO 24111
23824: LD_INT 22
23826: DOUBLE
23827: EQUAL
23828: IFTRUE 23838
23830: LD_INT 36
23832: DOUBLE
23833: EQUAL
23834: IFTRUE 23838
23836: GO 23863
23838: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23839: LD_ADDR_VAR 0 3
23843: PUSH
23844: LD_INT 15
23846: PPUSH
23847: LD_VAR 0 1
23851: PPUSH
23852: CALL_OW 321
23856: PUSH
23857: LD_INT 2
23859: EQUAL
23860: ST_TO_ADDR
23861: GO 24111
23863: LD_INT 30
23865: DOUBLE
23866: EQUAL
23867: IFTRUE 23871
23869: GO 23896
23871: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23872: LD_ADDR_VAR 0 3
23876: PUSH
23877: LD_INT 20
23879: PPUSH
23880: LD_VAR 0 1
23884: PPUSH
23885: CALL_OW 321
23889: PUSH
23890: LD_INT 2
23892: EQUAL
23893: ST_TO_ADDR
23894: GO 24111
23896: LD_INT 28
23898: DOUBLE
23899: EQUAL
23900: IFTRUE 23910
23902: LD_INT 21
23904: DOUBLE
23905: EQUAL
23906: IFTRUE 23910
23908: GO 23935
23910: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23911: LD_ADDR_VAR 0 3
23915: PUSH
23916: LD_INT 21
23918: PPUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: CALL_OW 321
23928: PUSH
23929: LD_INT 2
23931: EQUAL
23932: ST_TO_ADDR
23933: GO 24111
23935: LD_INT 16
23937: DOUBLE
23938: EQUAL
23939: IFTRUE 23943
23941: GO 23970
23943: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23944: LD_ADDR_VAR 0 3
23948: PUSH
23949: LD_EXP 79
23953: PPUSH
23954: LD_VAR 0 1
23958: PPUSH
23959: CALL_OW 321
23963: PUSH
23964: LD_INT 2
23966: EQUAL
23967: ST_TO_ADDR
23968: GO 24111
23970: LD_INT 19
23972: DOUBLE
23973: EQUAL
23974: IFTRUE 23984
23976: LD_INT 23
23978: DOUBLE
23979: EQUAL
23980: IFTRUE 23984
23982: GO 24011
23984: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23985: LD_ADDR_VAR 0 3
23989: PUSH
23990: LD_EXP 78
23994: PPUSH
23995: LD_VAR 0 1
23999: PPUSH
24000: CALL_OW 321
24004: PUSH
24005: LD_INT 2
24007: EQUAL
24008: ST_TO_ADDR
24009: GO 24111
24011: LD_INT 17
24013: DOUBLE
24014: EQUAL
24015: IFTRUE 24019
24017: GO 24044
24019: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24020: LD_ADDR_VAR 0 3
24024: PUSH
24025: LD_INT 39
24027: PPUSH
24028: LD_VAR 0 1
24032: PPUSH
24033: CALL_OW 321
24037: PUSH
24038: LD_INT 2
24040: EQUAL
24041: ST_TO_ADDR
24042: GO 24111
24044: LD_INT 18
24046: DOUBLE
24047: EQUAL
24048: IFTRUE 24052
24050: GO 24077
24052: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24053: LD_ADDR_VAR 0 3
24057: PUSH
24058: LD_INT 40
24060: PPUSH
24061: LD_VAR 0 1
24065: PPUSH
24066: CALL_OW 321
24070: PUSH
24071: LD_INT 2
24073: EQUAL
24074: ST_TO_ADDR
24075: GO 24111
24077: LD_INT 27
24079: DOUBLE
24080: EQUAL
24081: IFTRUE 24085
24083: GO 24110
24085: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24086: LD_ADDR_VAR 0 3
24090: PUSH
24091: LD_INT 35
24093: PPUSH
24094: LD_VAR 0 1
24098: PPUSH
24099: CALL_OW 321
24103: PUSH
24104: LD_INT 2
24106: EQUAL
24107: ST_TO_ADDR
24108: GO 24111
24110: POP
// end ;
24111: LD_VAR 0 3
24115: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24116: LD_INT 0
24118: PPUSH
24119: PPUSH
24120: PPUSH
24121: PPUSH
24122: PPUSH
24123: PPUSH
24124: PPUSH
24125: PPUSH
24126: PPUSH
24127: PPUSH
24128: PPUSH
// result := false ;
24129: LD_ADDR_VAR 0 6
24133: PUSH
24134: LD_INT 0
24136: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24137: LD_VAR 0 1
24141: NOT
24142: PUSH
24143: LD_VAR 0 1
24147: PPUSH
24148: CALL_OW 266
24152: PUSH
24153: LD_INT 0
24155: PUSH
24156: LD_INT 1
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: IN
24163: NOT
24164: OR
24165: PUSH
24166: LD_VAR 0 2
24170: NOT
24171: OR
24172: PUSH
24173: LD_VAR 0 5
24177: PUSH
24178: LD_INT 0
24180: PUSH
24181: LD_INT 1
24183: PUSH
24184: LD_INT 2
24186: PUSH
24187: LD_INT 3
24189: PUSH
24190: LD_INT 4
24192: PUSH
24193: LD_INT 5
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: LIST
24200: LIST
24201: LIST
24202: LIST
24203: IN
24204: NOT
24205: OR
24206: PUSH
24207: LD_VAR 0 3
24211: PPUSH
24212: LD_VAR 0 4
24216: PPUSH
24217: CALL_OW 488
24221: NOT
24222: OR
24223: IFFALSE 24227
// exit ;
24225: GO 24963
// side := GetSide ( depot ) ;
24227: LD_ADDR_VAR 0 9
24231: PUSH
24232: LD_VAR 0 1
24236: PPUSH
24237: CALL_OW 255
24241: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24242: LD_VAR 0 9
24246: PPUSH
24247: LD_VAR 0 2
24251: PPUSH
24252: CALL 23736 0 2
24256: NOT
24257: IFFALSE 24261
// exit ;
24259: GO 24963
// pom := GetBase ( depot ) ;
24261: LD_ADDR_VAR 0 10
24265: PUSH
24266: LD_VAR 0 1
24270: PPUSH
24271: CALL_OW 274
24275: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24276: LD_ADDR_VAR 0 11
24280: PUSH
24281: LD_VAR 0 2
24285: PPUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 248
24295: PPUSH
24296: CALL_OW 450
24300: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24301: LD_VAR 0 10
24305: PPUSH
24306: LD_INT 1
24308: PPUSH
24309: CALL_OW 275
24313: PUSH
24314: LD_VAR 0 11
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: GREATEREQUAL
24323: PUSH
24324: LD_VAR 0 10
24328: PPUSH
24329: LD_INT 2
24331: PPUSH
24332: CALL_OW 275
24336: PUSH
24337: LD_VAR 0 11
24341: PUSH
24342: LD_INT 2
24344: ARRAY
24345: GREATEREQUAL
24346: AND
24347: PUSH
24348: LD_VAR 0 10
24352: PPUSH
24353: LD_INT 3
24355: PPUSH
24356: CALL_OW 275
24360: PUSH
24361: LD_VAR 0 11
24365: PUSH
24366: LD_INT 3
24368: ARRAY
24369: GREATEREQUAL
24370: AND
24371: NOT
24372: IFFALSE 24376
// exit ;
24374: GO 24963
// if GetBType ( depot ) = b_depot then
24376: LD_VAR 0 1
24380: PPUSH
24381: CALL_OW 266
24385: PUSH
24386: LD_INT 0
24388: EQUAL
24389: IFFALSE 24401
// dist := 28 else
24391: LD_ADDR_VAR 0 14
24395: PUSH
24396: LD_INT 28
24398: ST_TO_ADDR
24399: GO 24409
// dist := 36 ;
24401: LD_ADDR_VAR 0 14
24405: PUSH
24406: LD_INT 36
24408: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24409: LD_VAR 0 1
24413: PPUSH
24414: LD_VAR 0 3
24418: PPUSH
24419: LD_VAR 0 4
24423: PPUSH
24424: CALL_OW 297
24428: PUSH
24429: LD_VAR 0 14
24433: GREATER
24434: IFFALSE 24438
// exit ;
24436: GO 24963
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24438: LD_ADDR_VAR 0 12
24442: PUSH
24443: LD_VAR 0 2
24447: PPUSH
24448: LD_VAR 0 3
24452: PPUSH
24453: LD_VAR 0 4
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 1
24467: PPUSH
24468: CALL_OW 248
24472: PPUSH
24473: LD_INT 0
24475: PPUSH
24476: CALL 24968 0 6
24480: ST_TO_ADDR
// if not hexes then
24481: LD_VAR 0 12
24485: NOT
24486: IFFALSE 24490
// exit ;
24488: GO 24963
// hex := GetHexInfo ( x , y ) ;
24490: LD_ADDR_VAR 0 15
24494: PUSH
24495: LD_VAR 0 3
24499: PPUSH
24500: LD_VAR 0 4
24504: PPUSH
24505: CALL_OW 546
24509: ST_TO_ADDR
// if hex [ 1 ] then
24510: LD_VAR 0 15
24514: PUSH
24515: LD_INT 1
24517: ARRAY
24518: IFFALSE 24522
// exit ;
24520: GO 24963
// height := hex [ 2 ] ;
24522: LD_ADDR_VAR 0 13
24526: PUSH
24527: LD_VAR 0 15
24531: PUSH
24532: LD_INT 2
24534: ARRAY
24535: ST_TO_ADDR
// for i = 1 to hexes do
24536: LD_ADDR_VAR 0 7
24540: PUSH
24541: DOUBLE
24542: LD_INT 1
24544: DEC
24545: ST_TO_ADDR
24546: LD_VAR 0 12
24550: PUSH
24551: FOR_TO
24552: IFFALSE 24882
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24554: LD_VAR 0 12
24558: PUSH
24559: LD_VAR 0 7
24563: ARRAY
24564: PUSH
24565: LD_INT 1
24567: ARRAY
24568: PPUSH
24569: LD_VAR 0 12
24573: PUSH
24574: LD_VAR 0 7
24578: ARRAY
24579: PUSH
24580: LD_INT 2
24582: ARRAY
24583: PPUSH
24584: CALL_OW 488
24588: NOT
24589: PUSH
24590: LD_VAR 0 12
24594: PUSH
24595: LD_VAR 0 7
24599: ARRAY
24600: PUSH
24601: LD_INT 1
24603: ARRAY
24604: PPUSH
24605: LD_VAR 0 12
24609: PUSH
24610: LD_VAR 0 7
24614: ARRAY
24615: PUSH
24616: LD_INT 2
24618: ARRAY
24619: PPUSH
24620: CALL_OW 428
24624: PUSH
24625: LD_INT 0
24627: GREATER
24628: OR
24629: PUSH
24630: LD_VAR 0 12
24634: PUSH
24635: LD_VAR 0 7
24639: ARRAY
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PPUSH
24645: LD_VAR 0 12
24649: PUSH
24650: LD_VAR 0 7
24654: ARRAY
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PPUSH
24660: CALL_OW 351
24664: OR
24665: IFFALSE 24671
// exit ;
24667: POP
24668: POP
24669: GO 24963
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24671: LD_ADDR_VAR 0 8
24675: PUSH
24676: LD_VAR 0 12
24680: PUSH
24681: LD_VAR 0 7
24685: ARRAY
24686: PUSH
24687: LD_INT 1
24689: ARRAY
24690: PPUSH
24691: LD_VAR 0 12
24695: PUSH
24696: LD_VAR 0 7
24700: ARRAY
24701: PUSH
24702: LD_INT 2
24704: ARRAY
24705: PPUSH
24706: CALL_OW 546
24710: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24711: LD_VAR 0 8
24715: PUSH
24716: LD_INT 1
24718: ARRAY
24719: PUSH
24720: LD_VAR 0 8
24724: PUSH
24725: LD_INT 2
24727: ARRAY
24728: PUSH
24729: LD_VAR 0 13
24733: PUSH
24734: LD_INT 2
24736: PLUS
24737: GREATER
24738: OR
24739: PUSH
24740: LD_VAR 0 8
24744: PUSH
24745: LD_INT 2
24747: ARRAY
24748: PUSH
24749: LD_VAR 0 13
24753: PUSH
24754: LD_INT 2
24756: MINUS
24757: LESS
24758: OR
24759: PUSH
24760: LD_VAR 0 8
24764: PUSH
24765: LD_INT 3
24767: ARRAY
24768: PUSH
24769: LD_INT 0
24771: PUSH
24772: LD_INT 8
24774: PUSH
24775: LD_INT 9
24777: PUSH
24778: LD_INT 10
24780: PUSH
24781: LD_INT 11
24783: PUSH
24784: LD_INT 12
24786: PUSH
24787: LD_INT 13
24789: PUSH
24790: LD_INT 16
24792: PUSH
24793: LD_INT 17
24795: PUSH
24796: LD_INT 18
24798: PUSH
24799: LD_INT 19
24801: PUSH
24802: LD_INT 20
24804: PUSH
24805: LD_INT 21
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: LIST
24812: LIST
24813: LIST
24814: LIST
24815: LIST
24816: LIST
24817: LIST
24818: LIST
24819: LIST
24820: LIST
24821: LIST
24822: IN
24823: NOT
24824: OR
24825: PUSH
24826: LD_VAR 0 8
24830: PUSH
24831: LD_INT 5
24833: ARRAY
24834: NOT
24835: OR
24836: PUSH
24837: LD_VAR 0 8
24841: PUSH
24842: LD_INT 6
24844: ARRAY
24845: PUSH
24846: LD_INT 1
24848: PUSH
24849: LD_INT 2
24851: PUSH
24852: LD_INT 7
24854: PUSH
24855: LD_INT 9
24857: PUSH
24858: LD_INT 10
24860: PUSH
24861: LD_INT 11
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: LIST
24868: LIST
24869: LIST
24870: LIST
24871: IN
24872: NOT
24873: OR
24874: IFFALSE 24880
// exit ;
24876: POP
24877: POP
24878: GO 24963
// end ;
24880: GO 24551
24882: POP
24883: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24884: LD_VAR 0 9
24888: PPUSH
24889: LD_VAR 0 3
24893: PPUSH
24894: LD_VAR 0 4
24898: PPUSH
24899: LD_INT 20
24901: PPUSH
24902: CALL 16909 0 4
24906: PUSH
24907: LD_INT 4
24909: ARRAY
24910: IFFALSE 24914
// exit ;
24912: GO 24963
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24914: LD_VAR 0 2
24918: PUSH
24919: LD_INT 29
24921: PUSH
24922: LD_INT 30
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: IN
24929: PUSH
24930: LD_VAR 0 3
24934: PPUSH
24935: LD_VAR 0 4
24939: PPUSH
24940: LD_VAR 0 9
24944: PPUSH
24945: CALL_OW 440
24949: NOT
24950: AND
24951: IFFALSE 24955
// exit ;
24953: GO 24963
// result := true ;
24955: LD_ADDR_VAR 0 6
24959: PUSH
24960: LD_INT 1
24962: ST_TO_ADDR
// end ;
24963: LD_VAR 0 6
24967: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24968: LD_INT 0
24970: PPUSH
24971: PPUSH
24972: PPUSH
24973: PPUSH
24974: PPUSH
24975: PPUSH
24976: PPUSH
24977: PPUSH
24978: PPUSH
24979: PPUSH
24980: PPUSH
24981: PPUSH
24982: PPUSH
24983: PPUSH
24984: PPUSH
24985: PPUSH
24986: PPUSH
24987: PPUSH
24988: PPUSH
24989: PPUSH
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
25000: PPUSH
25001: PPUSH
25002: PPUSH
25003: PPUSH
25004: PPUSH
25005: PPUSH
25006: PPUSH
25007: PPUSH
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
25013: PPUSH
25014: PPUSH
25015: PPUSH
25016: PPUSH
25017: PPUSH
25018: PPUSH
25019: PPUSH
25020: PPUSH
25021: PPUSH
25022: PPUSH
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
// result = [ ] ;
25028: LD_ADDR_VAR 0 7
25032: PUSH
25033: EMPTY
25034: ST_TO_ADDR
// temp_list = [ ] ;
25035: LD_ADDR_VAR 0 9
25039: PUSH
25040: EMPTY
25041: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25042: LD_VAR 0 4
25046: PUSH
25047: LD_INT 0
25049: PUSH
25050: LD_INT 1
25052: PUSH
25053: LD_INT 2
25055: PUSH
25056: LD_INT 3
25058: PUSH
25059: LD_INT 4
25061: PUSH
25062: LD_INT 5
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: LIST
25069: LIST
25070: LIST
25071: LIST
25072: IN
25073: NOT
25074: PUSH
25075: LD_VAR 0 1
25079: PUSH
25080: LD_INT 0
25082: PUSH
25083: LD_INT 1
25085: PUSH
25086: EMPTY
25087: LIST
25088: LIST
25089: IN
25090: PUSH
25091: LD_VAR 0 5
25095: PUSH
25096: LD_INT 1
25098: PUSH
25099: LD_INT 2
25101: PUSH
25102: LD_INT 3
25104: PUSH
25105: EMPTY
25106: LIST
25107: LIST
25108: LIST
25109: IN
25110: NOT
25111: AND
25112: OR
25113: IFFALSE 25117
// exit ;
25115: GO 43508
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25117: LD_VAR 0 1
25121: PUSH
25122: LD_INT 6
25124: PUSH
25125: LD_INT 7
25127: PUSH
25128: LD_INT 8
25130: PUSH
25131: LD_INT 13
25133: PUSH
25134: LD_INT 12
25136: PUSH
25137: LD_INT 15
25139: PUSH
25140: LD_INT 11
25142: PUSH
25143: LD_INT 14
25145: PUSH
25146: LD_INT 10
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: LIST
25153: LIST
25154: LIST
25155: LIST
25156: LIST
25157: LIST
25158: LIST
25159: IN
25160: IFFALSE 25170
// btype = b_lab ;
25162: LD_ADDR_VAR 0 1
25166: PUSH
25167: LD_INT 6
25169: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25170: LD_VAR 0 6
25174: PUSH
25175: LD_INT 0
25177: PUSH
25178: LD_INT 1
25180: PUSH
25181: LD_INT 2
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: LIST
25188: IN
25189: NOT
25190: PUSH
25191: LD_VAR 0 1
25195: PUSH
25196: LD_INT 0
25198: PUSH
25199: LD_INT 1
25201: PUSH
25202: LD_INT 2
25204: PUSH
25205: LD_INT 3
25207: PUSH
25208: LD_INT 6
25210: PUSH
25211: LD_INT 36
25213: PUSH
25214: LD_INT 4
25216: PUSH
25217: LD_INT 5
25219: PUSH
25220: LD_INT 31
25222: PUSH
25223: LD_INT 32
25225: PUSH
25226: LD_INT 33
25228: PUSH
25229: EMPTY
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: IN
25242: NOT
25243: PUSH
25244: LD_VAR 0 6
25248: PUSH
25249: LD_INT 1
25251: EQUAL
25252: AND
25253: OR
25254: PUSH
25255: LD_VAR 0 1
25259: PUSH
25260: LD_INT 2
25262: PUSH
25263: LD_INT 3
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: IN
25270: NOT
25271: PUSH
25272: LD_VAR 0 6
25276: PUSH
25277: LD_INT 2
25279: EQUAL
25280: AND
25281: OR
25282: IFFALSE 25292
// mode = 0 ;
25284: LD_ADDR_VAR 0 6
25288: PUSH
25289: LD_INT 0
25291: ST_TO_ADDR
// case mode of 0 :
25292: LD_VAR 0 6
25296: PUSH
25297: LD_INT 0
25299: DOUBLE
25300: EQUAL
25301: IFTRUE 25305
25303: GO 36758
25305: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25306: LD_ADDR_VAR 0 11
25310: PUSH
25311: LD_INT 0
25313: PUSH
25314: LD_INT 0
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: PUSH
25321: LD_INT 0
25323: PUSH
25324: LD_INT 1
25326: NEG
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: LD_INT 0
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: PUSH
25342: LD_INT 1
25344: PUSH
25345: LD_INT 1
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: LD_INT 0
25354: PUSH
25355: LD_INT 1
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: LD_INT 0
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PUSH
25373: LD_INT 1
25375: NEG
25376: PUSH
25377: LD_INT 1
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: NEG
25388: PUSH
25389: LD_INT 2
25391: NEG
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 0
25399: PUSH
25400: LD_INT 2
25402: NEG
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: PUSH
25408: LD_INT 1
25410: PUSH
25411: LD_INT 1
25413: NEG
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: LD_INT 1
25421: PUSH
25422: LD_INT 2
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: LD_INT 0
25431: PUSH
25432: LD_INT 2
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 1
25441: NEG
25442: PUSH
25443: LD_INT 1
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: PUSH
25450: LD_INT 1
25452: PUSH
25453: LD_INT 3
25455: PUSH
25456: EMPTY
25457: LIST
25458: LIST
25459: PUSH
25460: LD_INT 0
25462: PUSH
25463: LD_INT 3
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: PUSH
25470: LD_INT 1
25472: NEG
25473: PUSH
25474: LD_INT 2
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: LIST
25485: LIST
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: LIST
25491: LIST
25492: LIST
25493: LIST
25494: LIST
25495: LIST
25496: LIST
25497: LIST
25498: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25499: LD_ADDR_VAR 0 12
25503: PUSH
25504: LD_INT 0
25506: PUSH
25507: LD_INT 0
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: PUSH
25514: LD_INT 0
25516: PUSH
25517: LD_INT 1
25519: NEG
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: LD_INT 0
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: PUSH
25535: LD_INT 1
25537: PUSH
25538: LD_INT 1
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: PUSH
25545: LD_INT 0
25547: PUSH
25548: LD_INT 1
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: NEG
25558: PUSH
25559: LD_INT 0
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 1
25568: NEG
25569: PUSH
25570: LD_INT 1
25572: NEG
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: LD_INT 1
25580: PUSH
25581: LD_INT 1
25583: NEG
25584: PUSH
25585: EMPTY
25586: LIST
25587: LIST
25588: PUSH
25589: LD_INT 2
25591: PUSH
25592: LD_INT 0
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PUSH
25599: LD_INT 2
25601: PUSH
25602: LD_INT 1
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: LD_INT 1
25611: NEG
25612: PUSH
25613: LD_INT 1
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 2
25622: NEG
25623: PUSH
25624: LD_INT 0
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 2
25633: NEG
25634: PUSH
25635: LD_INT 1
25637: NEG
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 2
25645: NEG
25646: PUSH
25647: LD_INT 1
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 3
25656: NEG
25657: PUSH
25658: LD_INT 0
25660: PUSH
25661: EMPTY
25662: LIST
25663: LIST
25664: PUSH
25665: LD_INT 3
25667: NEG
25668: PUSH
25669: LD_INT 1
25671: NEG
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: PUSH
25677: EMPTY
25678: LIST
25679: LIST
25680: LIST
25681: LIST
25682: LIST
25683: LIST
25684: LIST
25685: LIST
25686: LIST
25687: LIST
25688: LIST
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: LIST
25694: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25695: LD_ADDR_VAR 0 13
25699: PUSH
25700: LD_INT 0
25702: PUSH
25703: LD_INT 0
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PUSH
25710: LD_INT 0
25712: PUSH
25713: LD_INT 1
25715: NEG
25716: PUSH
25717: EMPTY
25718: LIST
25719: LIST
25720: PUSH
25721: LD_INT 1
25723: PUSH
25724: LD_INT 0
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 1
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: LD_INT 0
25743: PUSH
25744: LD_INT 1
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PUSH
25751: LD_INT 1
25753: NEG
25754: PUSH
25755: LD_INT 0
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 1
25764: NEG
25765: PUSH
25766: LD_INT 1
25768: NEG
25769: PUSH
25770: EMPTY
25771: LIST
25772: LIST
25773: PUSH
25774: LD_INT 1
25776: NEG
25777: PUSH
25778: LD_INT 2
25780: NEG
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 2
25788: PUSH
25789: LD_INT 1
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 2
25798: PUSH
25799: LD_INT 2
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 1
25808: PUSH
25809: LD_INT 2
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 2
25818: NEG
25819: PUSH
25820: LD_INT 1
25822: NEG
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 2
25830: NEG
25831: PUSH
25832: LD_INT 2
25834: NEG
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 2
25842: NEG
25843: PUSH
25844: LD_INT 3
25846: NEG
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: LD_INT 3
25854: NEG
25855: PUSH
25856: LD_INT 2
25858: NEG
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 3
25866: NEG
25867: PUSH
25868: LD_INT 3
25870: NEG
25871: PUSH
25872: EMPTY
25873: LIST
25874: LIST
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: LIST
25880: LIST
25881: LIST
25882: LIST
25883: LIST
25884: LIST
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25894: LD_ADDR_VAR 0 14
25898: PUSH
25899: LD_INT 0
25901: PUSH
25902: LD_INT 0
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PUSH
25909: LD_INT 0
25911: PUSH
25912: LD_INT 1
25914: NEG
25915: PUSH
25916: EMPTY
25917: LIST
25918: LIST
25919: PUSH
25920: LD_INT 1
25922: PUSH
25923: LD_INT 0
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: PUSH
25930: LD_INT 1
25932: PUSH
25933: LD_INT 1
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 0
25942: PUSH
25943: LD_INT 1
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: LD_INT 1
25952: NEG
25953: PUSH
25954: LD_INT 0
25956: PUSH
25957: EMPTY
25958: LIST
25959: LIST
25960: PUSH
25961: LD_INT 1
25963: NEG
25964: PUSH
25965: LD_INT 1
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 1
25975: NEG
25976: PUSH
25977: LD_INT 2
25979: NEG
25980: PUSH
25981: EMPTY
25982: LIST
25983: LIST
25984: PUSH
25985: LD_INT 0
25987: PUSH
25988: LD_INT 2
25990: NEG
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: LD_INT 1
25998: PUSH
25999: LD_INT 1
26001: NEG
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 1
26009: PUSH
26010: LD_INT 2
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 0
26019: PUSH
26020: LD_INT 2
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 1
26029: NEG
26030: PUSH
26031: LD_INT 1
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 1
26040: NEG
26041: PUSH
26042: LD_INT 3
26044: NEG
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 3
26055: NEG
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: PUSH
26061: LD_INT 1
26063: PUSH
26064: LD_INT 2
26066: NEG
26067: PUSH
26068: EMPTY
26069: LIST
26070: LIST
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: LIST
26076: LIST
26077: LIST
26078: LIST
26079: LIST
26080: LIST
26081: LIST
26082: LIST
26083: LIST
26084: LIST
26085: LIST
26086: LIST
26087: LIST
26088: LIST
26089: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26090: LD_ADDR_VAR 0 15
26094: PUSH
26095: LD_INT 0
26097: PUSH
26098: LD_INT 0
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: LD_INT 0
26107: PUSH
26108: LD_INT 1
26110: NEG
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: LD_INT 0
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 1
26128: PUSH
26129: LD_INT 1
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 0
26138: PUSH
26139: LD_INT 1
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 1
26148: NEG
26149: PUSH
26150: LD_INT 0
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: LD_INT 1
26159: NEG
26160: PUSH
26161: LD_INT 1
26163: NEG
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: LD_INT 1
26171: PUSH
26172: LD_INT 1
26174: NEG
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PUSH
26180: LD_INT 2
26182: PUSH
26183: LD_INT 0
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: PUSH
26190: LD_INT 2
26192: PUSH
26193: LD_INT 1
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: PUSH
26200: LD_INT 1
26202: NEG
26203: PUSH
26204: LD_INT 1
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 2
26213: NEG
26214: PUSH
26215: LD_INT 0
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 2
26224: NEG
26225: PUSH
26226: LD_INT 1
26228: NEG
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 2
26236: PUSH
26237: LD_INT 1
26239: NEG
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 3
26247: PUSH
26248: LD_INT 0
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 3
26257: PUSH
26258: LD_INT 1
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: LIST
26269: LIST
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: LIST
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26283: LD_ADDR_VAR 0 16
26287: PUSH
26288: LD_INT 0
26290: PUSH
26291: LD_INT 0
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: PUSH
26298: LD_INT 0
26300: PUSH
26301: LD_INT 1
26303: NEG
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: LD_INT 1
26311: PUSH
26312: LD_INT 0
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: PUSH
26319: LD_INT 1
26321: PUSH
26322: LD_INT 1
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 0
26331: PUSH
26332: LD_INT 1
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 1
26341: NEG
26342: PUSH
26343: LD_INT 0
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PUSH
26350: LD_INT 1
26352: NEG
26353: PUSH
26354: LD_INT 1
26356: NEG
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PUSH
26362: LD_INT 1
26364: NEG
26365: PUSH
26366: LD_INT 2
26368: NEG
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 2
26376: PUSH
26377: LD_INT 1
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: LD_INT 2
26386: PUSH
26387: LD_INT 2
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: PUSH
26394: LD_INT 1
26396: PUSH
26397: LD_INT 2
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: LD_INT 2
26406: NEG
26407: PUSH
26408: LD_INT 1
26410: NEG
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 2
26418: NEG
26419: PUSH
26420: LD_INT 2
26422: NEG
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 3
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: LD_INT 3
26440: PUSH
26441: LD_INT 3
26443: PUSH
26444: EMPTY
26445: LIST
26446: LIST
26447: PUSH
26448: LD_INT 2
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: LIST
26462: LIST
26463: LIST
26464: LIST
26465: LIST
26466: LIST
26467: LIST
26468: LIST
26469: LIST
26470: LIST
26471: LIST
26472: LIST
26473: LIST
26474: LIST
26475: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26476: LD_ADDR_VAR 0 17
26480: PUSH
26481: LD_INT 0
26483: PUSH
26484: LD_INT 0
26486: PUSH
26487: EMPTY
26488: LIST
26489: LIST
26490: PUSH
26491: LD_INT 0
26493: PUSH
26494: LD_INT 1
26496: NEG
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: LD_INT 0
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 1
26514: PUSH
26515: LD_INT 1
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: LD_INT 0
26524: PUSH
26525: LD_INT 1
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: NEG
26535: PUSH
26536: LD_INT 0
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 1
26545: NEG
26546: PUSH
26547: LD_INT 1
26549: NEG
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: NEG
26558: PUSH
26559: LD_INT 2
26561: NEG
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PUSH
26567: LD_INT 0
26569: PUSH
26570: LD_INT 2
26572: NEG
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: LD_INT 1
26580: PUSH
26581: LD_INT 1
26583: NEG
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PUSH
26589: LD_INT 2
26591: PUSH
26592: LD_INT 0
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: PUSH
26599: LD_INT 2
26601: PUSH
26602: LD_INT 1
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PUSH
26609: LD_INT 2
26611: PUSH
26612: LD_INT 2
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: LD_INT 1
26621: PUSH
26622: LD_INT 2
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: LD_INT 0
26631: PUSH
26632: LD_INT 2
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: LD_INT 1
26641: NEG
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: LD_INT 0
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: PUSH
26661: LD_INT 2
26663: NEG
26664: PUSH
26665: LD_INT 1
26667: NEG
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: PUSH
26673: LD_INT 2
26675: NEG
26676: PUSH
26677: LD_INT 2
26679: NEG
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: LIST
26689: LIST
26690: LIST
26691: LIST
26692: LIST
26693: LIST
26694: LIST
26695: LIST
26696: LIST
26697: LIST
26698: LIST
26699: LIST
26700: LIST
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26706: LD_ADDR_VAR 0 18
26710: PUSH
26711: LD_INT 0
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: PUSH
26721: LD_INT 0
26723: PUSH
26724: LD_INT 1
26726: NEG
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: PUSH
26732: LD_INT 1
26734: PUSH
26735: LD_INT 0
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 1
26744: PUSH
26745: LD_INT 1
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PUSH
26752: LD_INT 0
26754: PUSH
26755: LD_INT 1
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: LD_INT 0
26768: PUSH
26769: EMPTY
26770: LIST
26771: LIST
26772: PUSH
26773: LD_INT 1
26775: NEG
26776: PUSH
26777: LD_INT 1
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: NEG
26788: PUSH
26789: LD_INT 2
26791: NEG
26792: PUSH
26793: EMPTY
26794: LIST
26795: LIST
26796: PUSH
26797: LD_INT 0
26799: PUSH
26800: LD_INT 2
26802: NEG
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 1
26810: PUSH
26811: LD_INT 1
26813: NEG
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PUSH
26819: LD_INT 2
26821: PUSH
26822: LD_INT 0
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: LD_INT 1
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: LD_INT 2
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: PUSH
26849: LD_INT 1
26851: PUSH
26852: LD_INT 2
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PUSH
26859: LD_INT 0
26861: PUSH
26862: LD_INT 2
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 1
26871: NEG
26872: PUSH
26873: LD_INT 1
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: LD_INT 0
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 2
26893: NEG
26894: PUSH
26895: LD_INT 1
26897: NEG
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 2
26905: NEG
26906: PUSH
26907: LD_INT 2
26909: NEG
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: LIST
26919: LIST
26920: LIST
26921: LIST
26922: LIST
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: LIST
26931: LIST
26932: LIST
26933: LIST
26934: LIST
26935: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26936: LD_ADDR_VAR 0 19
26940: PUSH
26941: LD_INT 0
26943: PUSH
26944: LD_INT 0
26946: PUSH
26947: EMPTY
26948: LIST
26949: LIST
26950: PUSH
26951: LD_INT 0
26953: PUSH
26954: LD_INT 1
26956: NEG
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: PUSH
26962: LD_INT 1
26964: PUSH
26965: LD_INT 0
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 1
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 0
26984: PUSH
26985: LD_INT 1
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: NEG
26995: PUSH
26996: LD_INT 0
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 1
27005: NEG
27006: PUSH
27007: LD_INT 1
27009: NEG
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 1
27017: NEG
27018: PUSH
27019: LD_INT 2
27021: NEG
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 0
27029: PUSH
27030: LD_INT 2
27032: NEG
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PUSH
27038: LD_INT 1
27040: PUSH
27041: LD_INT 1
27043: NEG
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: LD_INT 2
27051: PUSH
27052: LD_INT 0
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 2
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: LD_INT 2
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: PUSH
27079: LD_INT 1
27081: PUSH
27082: LD_INT 2
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: PUSH
27089: LD_INT 0
27091: PUSH
27092: LD_INT 2
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: LD_INT 1
27101: NEG
27102: PUSH
27103: LD_INT 1
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: LD_INT 0
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PUSH
27121: LD_INT 2
27123: NEG
27124: PUSH
27125: LD_INT 1
27127: NEG
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 2
27135: NEG
27136: PUSH
27137: LD_INT 2
27139: NEG
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: LIST
27152: LIST
27153: LIST
27154: LIST
27155: LIST
27156: LIST
27157: LIST
27158: LIST
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: LIST
27164: LIST
27165: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27166: LD_ADDR_VAR 0 20
27170: PUSH
27171: LD_INT 0
27173: PUSH
27174: LD_INT 0
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: PUSH
27181: LD_INT 0
27183: PUSH
27184: LD_INT 1
27186: NEG
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 1
27194: PUSH
27195: LD_INT 0
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 1
27204: PUSH
27205: LD_INT 1
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 0
27214: PUSH
27215: LD_INT 1
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: NEG
27225: PUSH
27226: LD_INT 0
27228: PUSH
27229: EMPTY
27230: LIST
27231: LIST
27232: PUSH
27233: LD_INT 1
27235: NEG
27236: PUSH
27237: LD_INT 1
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 1
27247: NEG
27248: PUSH
27249: LD_INT 2
27251: NEG
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: PUSH
27257: LD_INT 0
27259: PUSH
27260: LD_INT 2
27262: NEG
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 1
27270: PUSH
27271: LD_INT 1
27273: NEG
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: LD_INT 0
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: PUSH
27289: LD_INT 2
27291: PUSH
27292: LD_INT 1
27294: PUSH
27295: EMPTY
27296: LIST
27297: LIST
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: LD_INT 2
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: PUSH
27309: LD_INT 1
27311: PUSH
27312: LD_INT 2
27314: PUSH
27315: EMPTY
27316: LIST
27317: LIST
27318: PUSH
27319: LD_INT 0
27321: PUSH
27322: LD_INT 2
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 1
27331: NEG
27332: PUSH
27333: LD_INT 1
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: PUSH
27351: LD_INT 2
27353: NEG
27354: PUSH
27355: LD_INT 1
27357: NEG
27358: PUSH
27359: EMPTY
27360: LIST
27361: LIST
27362: PUSH
27363: LD_INT 2
27365: NEG
27366: PUSH
27367: LD_INT 2
27369: NEG
27370: PUSH
27371: EMPTY
27372: LIST
27373: LIST
27374: PUSH
27375: EMPTY
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27396: LD_ADDR_VAR 0 21
27400: PUSH
27401: LD_INT 0
27403: PUSH
27404: LD_INT 0
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: LD_INT 0
27413: PUSH
27414: LD_INT 1
27416: NEG
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: LD_INT 0
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 1
27434: PUSH
27435: LD_INT 1
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 0
27444: PUSH
27445: LD_INT 1
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: LD_INT 0
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: PUSH
27463: LD_INT 1
27465: NEG
27466: PUSH
27467: LD_INT 1
27469: NEG
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: NEG
27478: PUSH
27479: LD_INT 2
27481: NEG
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: PUSH
27487: LD_INT 0
27489: PUSH
27490: LD_INT 2
27492: NEG
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: PUSH
27498: LD_INT 1
27500: PUSH
27501: LD_INT 1
27503: NEG
27504: PUSH
27505: EMPTY
27506: LIST
27507: LIST
27508: PUSH
27509: LD_INT 2
27511: PUSH
27512: LD_INT 0
27514: PUSH
27515: EMPTY
27516: LIST
27517: LIST
27518: PUSH
27519: LD_INT 2
27521: PUSH
27522: LD_INT 1
27524: PUSH
27525: EMPTY
27526: LIST
27527: LIST
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: LD_INT 2
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 1
27541: PUSH
27542: LD_INT 2
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: PUSH
27549: LD_INT 0
27551: PUSH
27552: LD_INT 2
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: LD_INT 1
27561: NEG
27562: PUSH
27563: LD_INT 1
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: LD_INT 0
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: PUSH
27581: LD_INT 2
27583: NEG
27584: PUSH
27585: LD_INT 1
27587: NEG
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: PUSH
27593: LD_INT 2
27595: NEG
27596: PUSH
27597: LD_INT 2
27599: NEG
27600: PUSH
27601: EMPTY
27602: LIST
27603: LIST
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: LIST
27616: LIST
27617: LIST
27618: LIST
27619: LIST
27620: LIST
27621: LIST
27622: LIST
27623: LIST
27624: LIST
27625: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27626: LD_ADDR_VAR 0 22
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: LD_INT 0
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: PUSH
27641: LD_INT 0
27643: PUSH
27644: LD_INT 1
27646: NEG
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PUSH
27652: LD_INT 1
27654: PUSH
27655: LD_INT 0
27657: PUSH
27658: EMPTY
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 1
27664: PUSH
27665: LD_INT 1
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 0
27674: PUSH
27675: LD_INT 1
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 1
27684: NEG
27685: PUSH
27686: LD_INT 0
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: PUSH
27693: LD_INT 1
27695: NEG
27696: PUSH
27697: LD_INT 1
27699: NEG
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: NEG
27708: PUSH
27709: LD_INT 2
27711: NEG
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: LD_INT 2
27722: NEG
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 1
27730: PUSH
27731: LD_INT 1
27733: NEG
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 2
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: EMPTY
27746: LIST
27747: LIST
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: LD_INT 1
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: LD_INT 2
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 1
27771: PUSH
27772: LD_INT 2
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: PUSH
27779: LD_INT 0
27781: PUSH
27782: LD_INT 2
27784: PUSH
27785: EMPTY
27786: LIST
27787: LIST
27788: PUSH
27789: LD_INT 1
27791: NEG
27792: PUSH
27793: LD_INT 1
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: LD_INT 0
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: LD_INT 2
27813: NEG
27814: PUSH
27815: LD_INT 1
27817: NEG
27818: PUSH
27819: EMPTY
27820: LIST
27821: LIST
27822: PUSH
27823: LD_INT 2
27825: NEG
27826: PUSH
27827: LD_INT 2
27829: NEG
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: EMPTY
27836: LIST
27837: LIST
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: LIST
27852: LIST
27853: LIST
27854: LIST
27855: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27856: LD_ADDR_VAR 0 23
27860: PUSH
27861: LD_INT 0
27863: PUSH
27864: LD_INT 0
27866: PUSH
27867: EMPTY
27868: LIST
27869: LIST
27870: PUSH
27871: LD_INT 0
27873: PUSH
27874: LD_INT 1
27876: NEG
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: LD_INT 0
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 1
27894: PUSH
27895: LD_INT 1
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: LD_INT 1
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: NEG
27915: PUSH
27916: LD_INT 0
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: LD_INT 1
27925: NEG
27926: PUSH
27927: LD_INT 1
27929: NEG
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 1
27937: NEG
27938: PUSH
27939: LD_INT 2
27941: NEG
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: PUSH
27947: LD_INT 0
27949: PUSH
27950: LD_INT 2
27952: NEG
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 1
27960: PUSH
27961: LD_INT 1
27963: NEG
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: LD_INT 0
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: LD_INT 1
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 2
27991: PUSH
27992: LD_INT 2
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: LD_INT 1
28001: PUSH
28002: LD_INT 2
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: PUSH
28009: LD_INT 0
28011: PUSH
28012: LD_INT 2
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: LD_INT 1
28021: NEG
28022: PUSH
28023: LD_INT 1
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: LD_INT 0
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: LD_INT 2
28043: NEG
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: EMPTY
28050: LIST
28051: LIST
28052: PUSH
28053: LD_INT 2
28055: NEG
28056: PUSH
28057: LD_INT 2
28059: NEG
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PUSH
28065: LD_INT 2
28067: NEG
28068: PUSH
28069: LD_INT 3
28071: NEG
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 1
28079: NEG
28080: PUSH
28081: LD_INT 3
28083: NEG
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 1
28091: PUSH
28092: LD_INT 2
28094: NEG
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 2
28102: PUSH
28103: LD_INT 1
28105: NEG
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: LIST
28115: LIST
28116: LIST
28117: LIST
28118: LIST
28119: LIST
28120: LIST
28121: LIST
28122: LIST
28123: LIST
28124: LIST
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: LIST
28130: LIST
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28136: LD_ADDR_VAR 0 24
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: LD_INT 0
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: LD_INT 0
28153: PUSH
28154: LD_INT 1
28156: NEG
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 1
28164: PUSH
28165: LD_INT 0
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 1
28174: PUSH
28175: LD_INT 1
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 0
28184: PUSH
28185: LD_INT 1
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: LD_INT 0
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: PUSH
28203: LD_INT 1
28205: NEG
28206: PUSH
28207: LD_INT 1
28209: NEG
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 1
28217: NEG
28218: PUSH
28219: LD_INT 2
28221: NEG
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 2
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 1
28243: NEG
28244: PUSH
28245: EMPTY
28246: LIST
28247: LIST
28248: PUSH
28249: LD_INT 2
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: LD_INT 1
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: PUSH
28269: LD_INT 2
28271: PUSH
28272: LD_INT 2
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: PUSH
28282: LD_INT 2
28284: PUSH
28285: EMPTY
28286: LIST
28287: LIST
28288: PUSH
28289: LD_INT 0
28291: PUSH
28292: LD_INT 2
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 1
28301: NEG
28302: PUSH
28303: LD_INT 1
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: LD_INT 0
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: LD_INT 2
28323: NEG
28324: PUSH
28325: LD_INT 1
28327: NEG
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: NEG
28336: PUSH
28337: LD_INT 2
28339: NEG
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 1
28347: PUSH
28348: LD_INT 2
28350: NEG
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 2
28358: PUSH
28359: LD_INT 1
28361: NEG
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: LD_INT 3
28379: PUSH
28380: LD_INT 2
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: LIST
28391: LIST
28392: LIST
28393: LIST
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: LIST
28411: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28412: LD_ADDR_VAR 0 25
28416: PUSH
28417: LD_INT 0
28419: PUSH
28420: LD_INT 0
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: LD_INT 1
28432: NEG
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: LD_INT 1
28440: PUSH
28441: LD_INT 0
28443: PUSH
28444: EMPTY
28445: LIST
28446: LIST
28447: PUSH
28448: LD_INT 1
28450: PUSH
28451: LD_INT 1
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 0
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: NEG
28471: PUSH
28472: LD_INT 0
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 1
28481: NEG
28482: PUSH
28483: LD_INT 1
28485: NEG
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: NEG
28494: PUSH
28495: LD_INT 2
28497: NEG
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 0
28505: PUSH
28506: LD_INT 2
28508: NEG
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 1
28516: PUSH
28517: LD_INT 1
28519: NEG
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: LD_INT 0
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: LD_INT 1
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 2
28547: PUSH
28548: LD_INT 2
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: PUSH
28558: LD_INT 2
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 0
28567: PUSH
28568: LD_INT 2
28570: PUSH
28571: EMPTY
28572: LIST
28573: LIST
28574: PUSH
28575: LD_INT 1
28577: NEG
28578: PUSH
28579: LD_INT 1
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: LD_INT 0
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: PUSH
28597: LD_INT 2
28599: NEG
28600: PUSH
28601: LD_INT 1
28603: NEG
28604: PUSH
28605: EMPTY
28606: LIST
28607: LIST
28608: PUSH
28609: LD_INT 2
28611: NEG
28612: PUSH
28613: LD_INT 2
28615: NEG
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PUSH
28621: LD_INT 3
28623: PUSH
28624: LD_INT 1
28626: PUSH
28627: EMPTY
28628: LIST
28629: LIST
28630: PUSH
28631: LD_INT 3
28633: PUSH
28634: LD_INT 2
28636: PUSH
28637: EMPTY
28638: LIST
28639: LIST
28640: PUSH
28641: LD_INT 2
28643: PUSH
28644: LD_INT 3
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PUSH
28651: LD_INT 1
28653: PUSH
28654: LD_INT 3
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: LIST
28665: LIST
28666: LIST
28667: LIST
28668: LIST
28669: LIST
28670: LIST
28671: LIST
28672: LIST
28673: LIST
28674: LIST
28675: LIST
28676: LIST
28677: LIST
28678: LIST
28679: LIST
28680: LIST
28681: LIST
28682: LIST
28683: LIST
28684: LIST
28685: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28686: LD_ADDR_VAR 0 26
28690: PUSH
28691: LD_INT 0
28693: PUSH
28694: LD_INT 0
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 0
28703: PUSH
28704: LD_INT 1
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: LD_INT 0
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 1
28724: PUSH
28725: LD_INT 1
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 0
28734: PUSH
28735: LD_INT 1
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 0
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: PUSH
28753: LD_INT 1
28755: NEG
28756: PUSH
28757: LD_INT 1
28759: NEG
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 1
28767: NEG
28768: PUSH
28769: LD_INT 2
28771: NEG
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: PUSH
28777: LD_INT 0
28779: PUSH
28780: LD_INT 2
28782: NEG
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: LD_INT 1
28793: NEG
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: LD_INT 0
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 2
28821: PUSH
28822: LD_INT 2
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: LD_INT 2
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 0
28841: PUSH
28842: LD_INT 2
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 1
28851: NEG
28852: PUSH
28853: LD_INT 1
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: LD_INT 0
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PUSH
28871: LD_INT 2
28873: NEG
28874: PUSH
28875: LD_INT 1
28877: NEG
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 2
28885: NEG
28886: PUSH
28887: LD_INT 2
28889: NEG
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 2
28897: PUSH
28898: LD_INT 3
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: PUSH
28905: LD_INT 1
28907: PUSH
28908: LD_INT 3
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PUSH
28915: LD_INT 1
28917: NEG
28918: PUSH
28919: LD_INT 2
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 2
28928: NEG
28929: PUSH
28930: LD_INT 1
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: LIST
28955: LIST
28956: LIST
28957: LIST
28958: LIST
28959: LIST
28960: LIST
28961: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28962: LD_ADDR_VAR 0 27
28966: PUSH
28967: LD_INT 0
28969: PUSH
28970: LD_INT 0
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: LD_INT 0
28979: PUSH
28980: LD_INT 1
28982: NEG
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: LD_INT 0
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PUSH
28998: LD_INT 1
29000: PUSH
29001: LD_INT 1
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: NEG
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: NEG
29032: PUSH
29033: LD_INT 1
29035: NEG
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 1
29043: NEG
29044: PUSH
29045: LD_INT 2
29047: NEG
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: LD_INT 2
29058: NEG
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 1
29066: PUSH
29067: LD_INT 1
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: LD_INT 2
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 1
29107: PUSH
29108: LD_INT 2
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 0
29117: PUSH
29118: LD_INT 2
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: PUSH
29129: LD_INT 1
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: LD_INT 0
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: NEG
29150: PUSH
29151: LD_INT 1
29153: NEG
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 2
29165: NEG
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 1
29173: NEG
29174: PUSH
29175: LD_INT 2
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 2
29184: NEG
29185: PUSH
29186: LD_INT 1
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 3
29195: NEG
29196: PUSH
29197: LD_INT 1
29199: NEG
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: PUSH
29205: LD_INT 3
29207: NEG
29208: PUSH
29209: LD_INT 2
29211: NEG
29212: PUSH
29213: EMPTY
29214: LIST
29215: LIST
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29242: LD_ADDR_VAR 0 28
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 0
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 0
29259: PUSH
29260: LD_INT 1
29262: NEG
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: LD_INT 0
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 1
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 0
29290: PUSH
29291: LD_INT 1
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: LD_INT 0
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: PUSH
29309: LD_INT 1
29311: NEG
29312: PUSH
29313: LD_INT 1
29315: NEG
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: PUSH
29321: LD_INT 1
29323: NEG
29324: PUSH
29325: LD_INT 2
29327: NEG
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: LD_INT 2
29338: NEG
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PUSH
29344: LD_INT 1
29346: PUSH
29347: LD_INT 1
29349: NEG
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: LD_INT 0
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: LD_INT 1
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 2
29377: PUSH
29378: LD_INT 2
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 1
29387: PUSH
29388: LD_INT 2
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 0
29397: PUSH
29398: LD_INT 2
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: PUSH
29405: LD_INT 1
29407: NEG
29408: PUSH
29409: LD_INT 1
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: LD_INT 0
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 2
29429: NEG
29430: PUSH
29431: LD_INT 1
29433: NEG
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: PUSH
29439: LD_INT 2
29441: NEG
29442: PUSH
29443: LD_INT 2
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 2
29453: NEG
29454: PUSH
29455: LD_INT 3
29457: NEG
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: LD_INT 3
29469: NEG
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 3
29477: NEG
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 3
29489: NEG
29490: PUSH
29491: LD_INT 2
29493: NEG
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: LIST
29511: LIST
29512: LIST
29513: LIST
29514: LIST
29515: LIST
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: LIST
29521: LIST
29522: LIST
29523: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29524: LD_ADDR_VAR 0 29
29528: PUSH
29529: LD_INT 0
29531: PUSH
29532: LD_INT 0
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 0
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: LD_INT 1
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 0
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 0
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 1
29593: NEG
29594: PUSH
29595: LD_INT 1
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: NEG
29606: PUSH
29607: LD_INT 2
29609: NEG
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: PUSH
29615: LD_INT 0
29617: PUSH
29618: LD_INT 2
29620: NEG
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: LD_INT 1
29631: NEG
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: LD_INT 0
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 2
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 2
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 1
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 2
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 2
29702: NEG
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 2
29714: NEG
29715: PUSH
29716: LD_INT 3
29718: NEG
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 2
29726: PUSH
29727: LD_INT 1
29729: NEG
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PUSH
29735: LD_INT 3
29737: PUSH
29738: LD_INT 1
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PUSH
29745: LD_INT 1
29747: PUSH
29748: LD_INT 3
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: LD_INT 1
29757: NEG
29758: PUSH
29759: LD_INT 2
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 3
29768: NEG
29769: PUSH
29770: LD_INT 2
29772: NEG
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: LIST
29786: LIST
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: LIST
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29803: LD_ADDR_VAR 0 30
29807: PUSH
29808: LD_INT 0
29810: PUSH
29811: LD_INT 0
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 1
29823: NEG
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 1
29841: PUSH
29842: LD_INT 1
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: LD_INT 1
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: NEG
29862: PUSH
29863: LD_INT 0
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: NEG
29873: PUSH
29874: LD_INT 1
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: NEG
29885: PUSH
29886: LD_INT 2
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: LD_INT 2
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 1
29907: PUSH
29908: LD_INT 1
29910: NEG
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: LD_INT 2
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 2
29938: PUSH
29939: LD_INT 2
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 1
29948: PUSH
29949: LD_INT 2
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: LD_INT 1
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 2
29969: NEG
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 2
29980: NEG
29981: PUSH
29982: LD_INT 1
29984: NEG
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 1
29992: NEG
29993: PUSH
29994: LD_INT 3
29996: NEG
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: LD_INT 1
30004: PUSH
30005: LD_INT 2
30007: NEG
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 3
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 2
30025: PUSH
30026: LD_INT 3
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 2
30035: NEG
30036: PUSH
30037: LD_INT 1
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PUSH
30044: LD_INT 3
30046: NEG
30047: PUSH
30048: LD_INT 1
30050: NEG
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: EMPTY
30057: LIST
30058: LIST
30059: LIST
30060: LIST
30061: LIST
30062: LIST
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30081: LD_ADDR_VAR 0 31
30085: PUSH
30086: LD_INT 0
30088: PUSH
30089: LD_INT 0
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 0
30098: PUSH
30099: LD_INT 1
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: LD_INT 0
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 1
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 0
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 1
30150: NEG
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 1
30162: NEG
30163: PUSH
30164: LD_INT 2
30166: NEG
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 1
30174: PUSH
30175: LD_INT 1
30177: NEG
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: LD_INT 0
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 2
30195: PUSH
30196: LD_INT 1
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: LD_INT 2
30205: PUSH
30206: LD_INT 2
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PUSH
30213: LD_INT 1
30215: PUSH
30216: LD_INT 2
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 0
30225: PUSH
30226: LD_INT 2
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 1
30235: NEG
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 2
30246: NEG
30247: PUSH
30248: LD_INT 1
30250: NEG
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: NEG
30259: PUSH
30260: LD_INT 2
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 2
30270: NEG
30271: PUSH
30272: LD_INT 3
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 2
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 3
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 1
30303: PUSH
30304: LD_INT 3
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: NEG
30314: PUSH
30315: LD_INT 2
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 3
30324: NEG
30325: PUSH
30326: LD_INT 2
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30359: LD_ADDR_VAR 0 32
30363: PUSH
30364: LD_INT 0
30366: PUSH
30367: LD_INT 0
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: LD_INT 1
30379: NEG
30380: PUSH
30381: EMPTY
30382: LIST
30383: LIST
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 1
30397: PUSH
30398: LD_INT 1
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: LD_INT 0
30407: PUSH
30408: LD_INT 1
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: LD_INT 0
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PUSH
30426: LD_INT 1
30428: NEG
30429: PUSH
30430: LD_INT 1
30432: NEG
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: NEG
30441: PUSH
30442: LD_INT 2
30444: NEG
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 0
30452: PUSH
30453: LD_INT 2
30455: NEG
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 1
30463: PUSH
30464: LD_INT 1
30466: NEG
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: PUSH
30472: LD_INT 2
30474: PUSH
30475: LD_INT 1
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: LD_INT 2
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 1
30494: PUSH
30495: LD_INT 2
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 0
30504: PUSH
30505: LD_INT 2
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 1
30514: NEG
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 2
30525: NEG
30526: PUSH
30527: LD_INT 0
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 2
30536: NEG
30537: PUSH
30538: LD_INT 1
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 1
30548: NEG
30549: PUSH
30550: LD_INT 3
30552: NEG
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 1
30560: PUSH
30561: LD_INT 2
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 3
30571: PUSH
30572: LD_INT 2
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 2
30581: PUSH
30582: LD_INT 3
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 2
30591: NEG
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 3
30602: NEG
30603: PUSH
30604: LD_INT 1
30606: NEG
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30637: LD_ADDR_VAR 0 33
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 0
30654: PUSH
30655: LD_INT 1
30657: NEG
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: LD_INT 0
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 1
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: LD_INT 1
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 1
30695: NEG
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: NEG
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: LD_INT 2
30722: NEG
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 1
30733: NEG
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: LD_INT 1
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 1
30761: PUSH
30762: LD_INT 2
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: LD_INT 2
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 1
30781: NEG
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: NEG
30804: PUSH
30805: LD_INT 1
30807: NEG
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 2
30815: NEG
30816: PUSH
30817: LD_INT 2
30819: NEG
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 2
30827: NEG
30828: PUSH
30829: LD_INT 3
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 3
30850: PUSH
30851: LD_INT 1
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 1
30860: PUSH
30861: LD_INT 3
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 1
30870: NEG
30871: PUSH
30872: LD_INT 2
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PUSH
30879: LD_INT 3
30881: NEG
30882: PUSH
30883: LD_INT 2
30885: NEG
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: LIST
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: LIST
30904: LIST
30905: LIST
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30916: LD_ADDR_VAR 0 34
30920: PUSH
30921: LD_INT 0
30923: PUSH
30924: LD_INT 0
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 0
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: LD_INT 0
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 0
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 1
30985: NEG
30986: PUSH
30987: LD_INT 1
30989: NEG
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: LD_INT 2
31001: NEG
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 0
31009: PUSH
31010: LD_INT 2
31012: NEG
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 1
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: LD_INT 1
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 2
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 1
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: LD_INT 1
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: LD_INT 1
31087: NEG
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 2
31095: NEG
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: NEG
31108: PUSH
31109: LD_INT 3
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 2
31122: NEG
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 3
31130: PUSH
31131: LD_INT 2
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 2
31140: PUSH
31141: LD_INT 3
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 2
31150: NEG
31151: PUSH
31152: LD_INT 1
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 3
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31196: LD_ADDR_VAR 0 35
31200: PUSH
31201: LD_INT 0
31203: PUSH
31204: LD_INT 0
31206: PUSH
31207: EMPTY
31208: LIST
31209: LIST
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 1
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 0
31244: PUSH
31245: LD_INT 1
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 1
31254: NEG
31255: PUSH
31256: LD_INT 0
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: NEG
31266: PUSH
31267: LD_INT 1
31269: NEG
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 2
31277: PUSH
31278: LD_INT 1
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 2
31287: NEG
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31308: LD_ADDR_VAR 0 36
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 0
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 1
31346: PUSH
31347: LD_INT 1
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: LD_INT 1
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 1
31366: NEG
31367: PUSH
31368: LD_INT 0
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 1
31377: NEG
31378: PUSH
31379: LD_INT 1
31381: NEG
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: NEG
31390: PUSH
31391: LD_INT 2
31393: NEG
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 1
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31420: LD_ADDR_VAR 0 37
31424: PUSH
31425: LD_INT 0
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 0
31437: PUSH
31438: LD_INT 1
31440: NEG
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: LD_INT 0
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: PUSH
31456: LD_INT 1
31458: PUSH
31459: LD_INT 1
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 0
31468: PUSH
31469: LD_INT 1
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: NEG
31479: PUSH
31480: LD_INT 0
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: LD_INT 1
31493: NEG
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 1
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 1
31512: NEG
31513: PUSH
31514: LD_INT 1
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31532: LD_ADDR_VAR 0 38
31536: PUSH
31537: LD_INT 0
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 0
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: LD_INT 0
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 1
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 0
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 1
31590: NEG
31591: PUSH
31592: LD_INT 0
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 1
31601: NEG
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 2
31623: NEG
31624: PUSH
31625: LD_INT 1
31627: NEG
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31644: LD_ADDR_VAR 0 39
31648: PUSH
31649: LD_INT 0
31651: PUSH
31652: LD_INT 0
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: LD_INT 1
31664: NEG
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: LD_INT 0
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 1
31682: PUSH
31683: LD_INT 1
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 1
31713: NEG
31714: PUSH
31715: LD_INT 1
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 2
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: PUSH
31738: LD_INT 2
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31756: LD_ADDR_VAR 0 40
31760: PUSH
31761: LD_INT 0
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 0
31773: PUSH
31774: LD_INT 1
31776: NEG
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 1
31794: PUSH
31795: LD_INT 1
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 0
31804: PUSH
31805: LD_INT 1
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 1
31814: NEG
31815: PUSH
31816: LD_INT 0
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 1
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 1
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: LD_INT 1
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31868: LD_ADDR_VAR 0 41
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: LD_INT 0
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 0
31885: PUSH
31886: LD_INT 1
31888: NEG
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PUSH
31894: LD_INT 1
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: LD_INT 1
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: LD_INT 1
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: NEG
31927: PUSH
31928: LD_INT 0
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 1
31937: NEG
31938: PUSH
31939: LD_INT 1
31941: NEG
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 1
31949: NEG
31950: PUSH
31951: LD_INT 2
31953: NEG
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 1
31961: PUSH
31962: LD_INT 1
31964: NEG
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: LD_INT 0
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 2
31992: PUSH
31993: LD_INT 2
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: LD_INT 2
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 2
32023: NEG
32024: PUSH
32025: LD_INT 0
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 2
32034: NEG
32035: PUSH
32036: LD_INT 1
32038: NEG
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: LD_INT 2
32046: NEG
32047: PUSH
32048: LD_INT 2
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 2
32058: NEG
32059: PUSH
32060: LD_INT 3
32062: NEG
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 2
32070: PUSH
32071: LD_INT 1
32073: NEG
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 3
32081: PUSH
32082: LD_INT 0
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PUSH
32089: LD_INT 3
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PUSH
32099: LD_INT 3
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 3
32111: PUSH
32112: LD_INT 3
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 2
32121: PUSH
32122: LD_INT 3
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 2
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 3
32142: NEG
32143: PUSH
32144: LD_INT 0
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 3
32153: NEG
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 3
32165: NEG
32166: PUSH
32167: LD_INT 2
32169: NEG
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: LD_INT 3
32177: NEG
32178: PUSH
32179: LD_INT 3
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32218: LD_ADDR_VAR 0 42
32222: PUSH
32223: LD_INT 0
32225: PUSH
32226: LD_INT 0
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 1
32238: NEG
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 1
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 1
32256: PUSH
32257: LD_INT 1
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: LD_INT 1
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: EMPTY
32282: LIST
32283: LIST
32284: PUSH
32285: LD_INT 1
32287: NEG
32288: PUSH
32289: LD_INT 1
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 2
32303: NEG
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 0
32311: PUSH
32312: LD_INT 2
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: PUSH
32323: LD_INT 1
32325: NEG
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 2
32333: PUSH
32334: LD_INT 1
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 2
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: EMPTY
32348: LIST
32349: LIST
32350: PUSH
32351: LD_INT 1
32353: PUSH
32354: LD_INT 2
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 0
32363: PUSH
32364: LD_INT 2
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: NEG
32374: PUSH
32375: LD_INT 1
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 2
32384: NEG
32385: PUSH
32386: LD_INT 1
32388: NEG
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 2
32396: NEG
32397: PUSH
32398: LD_INT 2
32400: NEG
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 2
32408: NEG
32409: PUSH
32410: LD_INT 3
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: NEG
32421: PUSH
32422: LD_INT 3
32424: NEG
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 0
32432: PUSH
32433: LD_INT 3
32435: NEG
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 1
32443: PUSH
32444: LD_INT 2
32446: NEG
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 3
32454: PUSH
32455: LD_INT 2
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 3
32464: PUSH
32465: LD_INT 3
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 2
32474: PUSH
32475: LD_INT 3
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 1
32484: PUSH
32485: LD_INT 3
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: LD_INT 0
32494: PUSH
32495: LD_INT 3
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 1
32504: NEG
32505: PUSH
32506: LD_INT 2
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 3
32515: NEG
32516: PUSH
32517: LD_INT 2
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 3
32527: NEG
32528: PUSH
32529: LD_INT 3
32531: NEG
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: LIST
32546: LIST
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: LIST
32554: LIST
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32568: LD_ADDR_VAR 0 43
32572: PUSH
32573: LD_INT 0
32575: PUSH
32576: LD_INT 0
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: LD_INT 0
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 1
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 0
32616: PUSH
32617: LD_INT 1
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: LD_INT 0
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: LD_INT 1
32641: NEG
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: NEG
32650: PUSH
32651: LD_INT 2
32653: NEG
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 0
32661: PUSH
32662: LD_INT 2
32664: NEG
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PUSH
32670: LD_INT 1
32672: PUSH
32673: LD_INT 1
32675: NEG
32676: PUSH
32677: EMPTY
32678: LIST
32679: LIST
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 2
32693: PUSH
32694: LD_INT 1
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 1
32703: PUSH
32704: LD_INT 2
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 0
32713: PUSH
32714: LD_INT 2
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 1
32723: NEG
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 2
32734: NEG
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 2
32745: NEG
32746: PUSH
32747: LD_INT 1
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: LD_INT 3
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 3
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: LD_INT 2
32783: NEG
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 1
32794: NEG
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 3
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 3
32812: PUSH
32813: LD_INT 1
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 1
32822: PUSH
32823: LD_INT 3
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 0
32832: PUSH
32833: LD_INT 3
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 2
32853: NEG
32854: PUSH
32855: LD_INT 1
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 3
32864: NEG
32865: PUSH
32866: LD_INT 0
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 3
32875: NEG
32876: PUSH
32877: LD_INT 1
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: LIST
32900: LIST
32901: LIST
32902: LIST
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32916: LD_ADDR_VAR 0 44
32920: PUSH
32921: LD_INT 0
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 0
32933: PUSH
32934: LD_INT 1
32936: NEG
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: LD_INT 0
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 1
32954: PUSH
32955: LD_INT 1
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: LD_INT 1
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: LD_INT 0
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 1
32985: NEG
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: LD_INT 2
33001: NEG
33002: PUSH
33003: EMPTY
33004: LIST
33005: LIST
33006: PUSH
33007: LD_INT 1
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: LD_INT 0
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 2
33040: PUSH
33041: LD_INT 2
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 1
33050: PUSH
33051: LD_INT 2
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 2
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 2
33106: NEG
33107: PUSH
33108: LD_INT 3
33110: NEG
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 2
33118: PUSH
33119: LD_INT 1
33121: NEG
33122: PUSH
33123: EMPTY
33124: LIST
33125: LIST
33126: PUSH
33127: LD_INT 3
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 3
33139: PUSH
33140: LD_INT 1
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 3
33149: PUSH
33150: LD_INT 2
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: PUSH
33157: LD_INT 3
33159: PUSH
33160: LD_INT 3
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 2
33169: PUSH
33170: LD_INT 3
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 2
33179: NEG
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: LD_INT 0
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 3
33201: NEG
33202: PUSH
33203: LD_INT 1
33205: NEG
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 3
33213: NEG
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: PUSH
33223: LD_INT 3
33225: NEG
33226: PUSH
33227: LD_INT 3
33229: NEG
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: LIST
33243: LIST
33244: LIST
33245: LIST
33246: LIST
33247: LIST
33248: LIST
33249: LIST
33250: LIST
33251: LIST
33252: LIST
33253: LIST
33254: LIST
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33266: LD_ADDR_VAR 0 45
33270: PUSH
33271: LD_INT 0
33273: PUSH
33274: LD_INT 0
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 0
33283: PUSH
33284: LD_INT 1
33286: NEG
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: LD_INT 0
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: LD_INT 1
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 0
33314: PUSH
33315: LD_INT 1
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: LD_INT 0
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 1
33335: NEG
33336: PUSH
33337: LD_INT 1
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: NEG
33348: PUSH
33349: LD_INT 2
33351: NEG
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 0
33359: PUSH
33360: LD_INT 2
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: LD_INT 1
33373: NEG
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: LD_INT 2
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 1
33401: PUSH
33402: LD_INT 2
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: LD_INT 2
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 1
33421: NEG
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 2
33432: NEG
33433: PUSH
33434: LD_INT 1
33436: NEG
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 2
33444: NEG
33445: PUSH
33446: LD_INT 2
33448: NEG
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: LD_INT 3
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: NEG
33469: PUSH
33470: LD_INT 3
33472: NEG
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 0
33480: PUSH
33481: LD_INT 3
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: LD_INT 2
33494: NEG
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 3
33502: PUSH
33503: LD_INT 2
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 3
33512: PUSH
33513: LD_INT 3
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PUSH
33520: LD_INT 2
33522: PUSH
33523: LD_INT 3
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: LD_INT 3
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 0
33542: PUSH
33543: LD_INT 3
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: LD_INT 2
33556: PUSH
33557: EMPTY
33558: LIST
33559: LIST
33560: PUSH
33561: LD_INT 3
33563: NEG
33564: PUSH
33565: LD_INT 2
33567: NEG
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 3
33575: NEG
33576: PUSH
33577: LD_INT 3
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33616: LD_ADDR_VAR 0 46
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: LD_INT 0
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 0
33633: PUSH
33634: LD_INT 1
33636: NEG
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: LD_INT 0
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 1
33654: PUSH
33655: LD_INT 1
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 0
33664: PUSH
33665: LD_INT 1
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: LD_INT 0
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: LD_INT 1
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 1
33697: NEG
33698: PUSH
33699: LD_INT 2
33701: NEG
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: LD_INT 2
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: LD_INT 1
33723: NEG
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 1
33751: PUSH
33752: LD_INT 2
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: LD_INT 2
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: LD_INT 1
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 2
33782: NEG
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: LD_INT 1
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: LD_INT 3
33809: NEG
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 0
33817: PUSH
33818: LD_INT 3
33820: NEG
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 1
33828: PUSH
33829: LD_INT 2
33831: NEG
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 2
33839: PUSH
33840: LD_INT 1
33842: NEG
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 3
33850: PUSH
33851: LD_INT 0
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 3
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: LD_INT 1
33870: PUSH
33871: LD_INT 3
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: LD_INT 3
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 1
33890: NEG
33891: PUSH
33892: LD_INT 2
33894: PUSH
33895: EMPTY
33896: LIST
33897: LIST
33898: PUSH
33899: LD_INT 2
33901: NEG
33902: PUSH
33903: LD_INT 1
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 3
33912: NEG
33913: PUSH
33914: LD_INT 0
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 3
33923: NEG
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: LIST
33945: LIST
33946: LIST
33947: LIST
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: LIST
33962: LIST
33963: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33964: LD_ADDR_VAR 0 47
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: LD_INT 0
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 0
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: LD_INT 0
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 1
34033: NEG
34034: PUSH
34035: LD_INT 1
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: NEG
34046: PUSH
34047: LD_INT 2
34049: NEG
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: LD_INT 2
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 1
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 2
34079: NEG
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 2
34091: NEG
34092: PUSH
34093: LD_INT 2
34095: NEG
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: LIST
34107: LIST
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34115: LD_ADDR_VAR 0 48
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 0
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 0
34132: PUSH
34133: LD_INT 1
34135: NEG
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 1
34153: PUSH
34154: LD_INT 1
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: LD_INT 1
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 0
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 1
34184: NEG
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: NEG
34197: PUSH
34198: LD_INT 2
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 0
34208: PUSH
34209: LD_INT 2
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: LD_INT 1
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 2
34230: PUSH
34231: LD_INT 0
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: LD_INT 2
34240: PUSH
34241: LD_INT 1
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34262: LD_ADDR_VAR 0 49
34266: PUSH
34267: LD_INT 0
34269: PUSH
34270: LD_INT 0
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 0
34279: PUSH
34280: LD_INT 1
34282: NEG
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: LD_INT 0
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 1
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 0
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: NEG
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 2
34374: PUSH
34375: LD_INT 2
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: LD_INT 2
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34406: LD_ADDR_VAR 0 50
34410: PUSH
34411: LD_INT 0
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 0
34423: PUSH
34424: LD_INT 1
34426: NEG
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: LD_INT 0
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 1
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: NEG
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34550: LD_ADDR_VAR 0 51
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: LD_INT 0
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 0
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: LD_INT 0
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 1
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 0
34598: PUSH
34599: LD_INT 1
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: NEG
34609: PUSH
34610: LD_INT 0
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PUSH
34617: LD_INT 1
34619: NEG
34620: PUSH
34621: LD_INT 1
34623: NEG
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PUSH
34629: LD_INT 1
34631: PUSH
34632: LD_INT 2
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 0
34641: PUSH
34642: LD_INT 2
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: LD_INT 1
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 2
34662: NEG
34663: PUSH
34664: LD_INT 0
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 2
34673: NEG
34674: PUSH
34675: LD_INT 1
34677: NEG
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34697: LD_ADDR_VAR 0 52
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 1
34790: NEG
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 2
34812: NEG
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: LD_INT 2
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: LIST
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34848: LD_ADDR_VAR 0 53
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: LD_INT 0
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 0
34865: PUSH
34866: LD_INT 1
34868: NEG
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: LD_INT 0
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 1
34886: PUSH
34887: LD_INT 1
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: LD_INT 1
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: NEG
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: NEG
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: NEG
34930: PUSH
34931: LD_INT 2
34933: NEG
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 0
34941: PUSH
34942: LD_INT 2
34944: NEG
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: LD_INT 1
34955: NEG
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 2
34963: PUSH
34964: LD_INT 0
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 2
34973: PUSH
34974: LD_INT 1
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 2
34983: PUSH
34984: LD_INT 2
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 1
34993: PUSH
34994: LD_INT 2
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: LD_INT 2
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: LD_INT 1
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 2
35035: NEG
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 2
35047: NEG
35048: PUSH
35049: LD_INT 2
35051: NEG
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35078: LD_ADDR_VAR 0 54
35082: PUSH
35083: LD_INT 0
35085: PUSH
35086: LD_INT 0
35088: PUSH
35089: EMPTY
35090: LIST
35091: LIST
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 1
35116: PUSH
35117: LD_INT 1
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 0
35126: PUSH
35127: LD_INT 1
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: LD_INT 1
35147: NEG
35148: PUSH
35149: LD_INT 1
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: NEG
35160: PUSH
35161: LD_INT 2
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 0
35171: PUSH
35172: LD_INT 2
35174: NEG
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 1
35182: PUSH
35183: LD_INT 1
35185: NEG
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 2
35193: PUSH
35194: LD_INT 0
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: LD_INT 2
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 1
35223: PUSH
35224: LD_INT 2
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 0
35233: PUSH
35234: LD_INT 2
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 1
35243: NEG
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 2
35265: NEG
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: NEG
35278: PUSH
35279: LD_INT 2
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35308: LD_ADDR_VAR 0 55
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 0
35325: PUSH
35326: LD_INT 1
35328: NEG
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: LD_INT 0
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 1
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 1
35377: NEG
35378: PUSH
35379: LD_INT 1
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 0
35401: PUSH
35402: LD_INT 2
35404: NEG
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 1
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 2
35423: PUSH
35424: LD_INT 0
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: LD_INT 2
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 1
35453: PUSH
35454: LD_INT 2
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 0
35463: PUSH
35464: LD_INT 2
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: NEG
35474: PUSH
35475: LD_INT 1
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 2
35495: NEG
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 2
35507: NEG
35508: PUSH
35509: LD_INT 2
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35538: LD_ADDR_VAR 0 56
35542: PUSH
35543: LD_INT 0
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 0
35555: PUSH
35556: LD_INT 1
35558: NEG
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 1
35576: PUSH
35577: LD_INT 1
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 0
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: LD_INT 1
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: NEG
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 0
35631: PUSH
35632: LD_INT 2
35634: NEG
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 1
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 2
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 2
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: LD_INT 2
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 2
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 2
35725: NEG
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 2
35737: NEG
35738: PUSH
35739: LD_INT 2
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35768: LD_ADDR_VAR 0 57
35772: PUSH
35773: LD_INT 0
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 0
35785: PUSH
35786: LD_INT 1
35788: NEG
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: LD_INT 0
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 1
35806: PUSH
35807: LD_INT 1
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 0
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 1
35837: NEG
35838: PUSH
35839: LD_INT 1
35841: NEG
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: LD_INT 2
35853: NEG
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: LD_INT 2
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 1
35872: PUSH
35873: LD_INT 1
35875: NEG
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 2
35883: PUSH
35884: LD_INT 0
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: LD_INT 1
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: LD_INT 2
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 1
35913: PUSH
35914: LD_INT 2
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 0
35923: PUSH
35924: LD_INT 2
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 1
35933: NEG
35934: PUSH
35935: LD_INT 1
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 2
35955: NEG
35956: PUSH
35957: LD_INT 1
35959: NEG
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 2
35967: NEG
35968: PUSH
35969: LD_INT 2
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35998: LD_ADDR_VAR 0 58
36002: PUSH
36003: LD_INT 0
36005: PUSH
36006: LD_INT 0
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 0
36015: PUSH
36016: LD_INT 1
36018: NEG
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: LD_INT 0
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: LD_INT 1
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 0
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 1
36056: NEG
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 1
36067: NEG
36068: PUSH
36069: LD_INT 1
36071: NEG
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 1
36079: NEG
36080: PUSH
36081: LD_INT 2
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 0
36091: PUSH
36092: LD_INT 2
36094: NEG
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: LD_INT 1
36105: NEG
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 2
36113: PUSH
36114: LD_INT 0
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: LD_INT 2
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: PUSH
36144: LD_INT 2
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 0
36153: PUSH
36154: LD_INT 2
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: LD_INT 1
36163: NEG
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 2
36197: NEG
36198: PUSH
36199: LD_INT 2
36201: NEG
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36228: LD_ADDR_VAR 0 59
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 0
36245: PUSH
36246: LD_INT 1
36248: NEG
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: LD_INT 0
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: NEG
36287: PUSH
36288: LD_INT 0
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: LD_INT 1
36301: NEG
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36316: LD_ADDR_VAR 0 60
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 0
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 0
36333: PUSH
36334: LD_INT 1
36336: NEG
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: LD_INT 0
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: PUSH
36355: LD_INT 1
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 1
36374: NEG
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 1
36385: NEG
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36404: LD_ADDR_VAR 0 61
36408: PUSH
36409: LD_INT 0
36411: PUSH
36412: LD_INT 0
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: LD_INT 1
36424: NEG
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: LD_INT 0
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 1
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 0
36452: PUSH
36453: LD_INT 1
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: LD_INT 1
36462: NEG
36463: PUSH
36464: LD_INT 0
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: LD_INT 1
36477: NEG
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36492: LD_ADDR_VAR 0 62
36496: PUSH
36497: LD_INT 0
36499: PUSH
36500: LD_INT 0
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: LD_INT 1
36512: NEG
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 1
36530: PUSH
36531: LD_INT 1
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 0
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 1
36561: NEG
36562: PUSH
36563: LD_INT 1
36565: NEG
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: LIST
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36580: LD_ADDR_VAR 0 63
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 0
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: LD_INT 0
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 1
36618: PUSH
36619: LD_INT 1
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: LD_INT 1
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 1
36638: NEG
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 1
36649: NEG
36650: PUSH
36651: LD_INT 1
36653: NEG
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36668: LD_ADDR_VAR 0 64
36672: PUSH
36673: LD_INT 0
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: LD_INT 0
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: ST_TO_ADDR
// end ; 1 :
36756: GO 42653
36758: LD_INT 1
36760: DOUBLE
36761: EQUAL
36762: IFTRUE 36766
36764: GO 39389
36766: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36767: LD_ADDR_VAR 0 11
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 3
36778: NEG
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 3
36789: NEG
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: LD_INT 2
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: LIST
36810: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36811: LD_ADDR_VAR 0 12
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: LD_INT 1
36821: NEG
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 3
36829: PUSH
36830: LD_INT 0
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 3
36839: PUSH
36840: LD_INT 1
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: LIST
36851: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36852: LD_ADDR_VAR 0 13
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: LD_INT 2
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 3
36869: PUSH
36870: LD_INT 3
36872: PUSH
36873: EMPTY
36874: LIST
36875: LIST
36876: PUSH
36877: LD_INT 2
36879: PUSH
36880: LD_INT 3
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: LIST
36891: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36892: LD_ADDR_VAR 0 14
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: LD_INT 3
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: LD_INT 3
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: LD_INT 2
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: LIST
36932: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36933: LD_ADDR_VAR 0 15
36937: PUSH
36938: LD_INT 2
36940: NEG
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 3
36951: NEG
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 3
36962: NEG
36963: PUSH
36964: LD_INT 1
36966: NEG
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: LIST
36976: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36977: LD_ADDR_VAR 0 16
36981: PUSH
36982: LD_INT 2
36984: NEG
36985: PUSH
36986: LD_INT 3
36988: NEG
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 3
36996: NEG
36997: PUSH
36998: LD_INT 2
37000: NEG
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 3
37008: NEG
37009: PUSH
37010: LD_INT 3
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: LIST
37022: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37023: LD_ADDR_VAR 0 17
37027: PUSH
37028: LD_INT 1
37030: NEG
37031: PUSH
37032: LD_INT 3
37034: NEG
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: LD_INT 3
37045: NEG
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 1
37053: PUSH
37054: LD_INT 2
37056: NEG
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: LIST
37066: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37067: LD_ADDR_VAR 0 18
37071: PUSH
37072: LD_INT 2
37074: PUSH
37075: LD_INT 1
37077: NEG
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 3
37085: PUSH
37086: LD_INT 0
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 3
37095: PUSH
37096: LD_INT 1
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: LIST
37107: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37108: LD_ADDR_VAR 0 19
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 3
37125: PUSH
37126: LD_INT 3
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 2
37135: PUSH
37136: LD_INT 3
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: LIST
37147: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37148: LD_ADDR_VAR 0 20
37152: PUSH
37153: LD_INT 1
37155: PUSH
37156: LD_INT 3
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 0
37165: PUSH
37166: LD_INT 3
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 1
37175: NEG
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37189: LD_ADDR_VAR 0 21
37193: PUSH
37194: LD_INT 2
37196: NEG
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 3
37207: NEG
37208: PUSH
37209: LD_INT 0
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 3
37218: NEG
37219: PUSH
37220: LD_INT 1
37222: NEG
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: LIST
37232: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37233: LD_ADDR_VAR 0 22
37237: PUSH
37238: LD_INT 2
37240: NEG
37241: PUSH
37242: LD_INT 3
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 3
37252: NEG
37253: PUSH
37254: LD_INT 2
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 3
37264: NEG
37265: PUSH
37266: LD_INT 3
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: LIST
37278: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37279: LD_ADDR_VAR 0 23
37283: PUSH
37284: LD_INT 0
37286: PUSH
37287: LD_INT 3
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 1
37297: NEG
37298: PUSH
37299: LD_INT 4
37301: NEG
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: LD_INT 3
37312: NEG
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: LIST
37322: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37323: LD_ADDR_VAR 0 24
37327: PUSH
37328: LD_INT 3
37330: PUSH
37331: LD_INT 0
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 3
37340: PUSH
37341: LD_INT 1
37343: NEG
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 4
37351: PUSH
37352: LD_INT 1
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: LIST
37363: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37364: LD_ADDR_VAR 0 25
37368: PUSH
37369: LD_INT 3
37371: PUSH
37372: LD_INT 3
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 4
37381: PUSH
37382: LD_INT 3
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: LD_INT 4
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: LIST
37403: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37404: LD_ADDR_VAR 0 26
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 3
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: PUSH
37422: LD_INT 4
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 1
37431: NEG
37432: PUSH
37433: LD_INT 3
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: LIST
37444: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37445: LD_ADDR_VAR 0 27
37449: PUSH
37450: LD_INT 3
37452: NEG
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 3
37463: NEG
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 4
37474: NEG
37475: PUSH
37476: LD_INT 1
37478: NEG
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: LIST
37488: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37489: LD_ADDR_VAR 0 28
37493: PUSH
37494: LD_INT 3
37496: NEG
37497: PUSH
37498: LD_INT 3
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 3
37508: NEG
37509: PUSH
37510: LD_INT 4
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 4
37520: NEG
37521: PUSH
37522: LD_INT 3
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37535: LD_ADDR_VAR 0 29
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: LD_INT 3
37546: NEG
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 0
37554: PUSH
37555: LD_INT 3
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: LD_INT 4
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 0
37588: PUSH
37589: LD_INT 4
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: PUSH
37600: LD_INT 3
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: NEG
37611: PUSH
37612: LD_INT 5
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 0
37622: PUSH
37623: LD_INT 5
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 4
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: NEG
37645: PUSH
37646: LD_INT 6
37648: NEG
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 0
37656: PUSH
37657: LD_INT 6
37659: NEG
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 1
37667: PUSH
37668: LD_INT 5
37670: NEG
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37690: LD_ADDR_VAR 0 30
37694: PUSH
37695: LD_INT 2
37697: PUSH
37698: LD_INT 1
37700: NEG
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 3
37708: PUSH
37709: LD_INT 0
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 3
37718: PUSH
37719: LD_INT 1
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PUSH
37726: LD_INT 3
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 4
37739: PUSH
37740: LD_INT 0
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 4
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 4
37759: PUSH
37760: LD_INT 1
37762: NEG
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 5
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 5
37780: PUSH
37781: LD_INT 1
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 5
37790: PUSH
37791: LD_INT 1
37793: NEG
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 6
37801: PUSH
37802: LD_INT 0
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 6
37811: PUSH
37812: LD_INT 1
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: LIST
37825: LIST
37826: LIST
37827: LIST
37828: LIST
37829: LIST
37830: LIST
37831: LIST
37832: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37833: LD_ADDR_VAR 0 31
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: LD_INT 2
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: LD_INT 3
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 2
37860: PUSH
37861: LD_INT 3
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 4
37870: PUSH
37871: LD_INT 3
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: LD_INT 4
37880: PUSH
37881: LD_INT 4
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 3
37890: PUSH
37891: LD_INT 4
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 5
37900: PUSH
37901: LD_INT 4
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 5
37910: PUSH
37911: LD_INT 5
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 4
37920: PUSH
37921: LD_INT 5
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 6
37930: PUSH
37931: LD_INT 5
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 6
37940: PUSH
37941: LD_INT 6
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 5
37950: PUSH
37951: LD_INT 6
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37972: LD_ADDR_VAR 0 32
37976: PUSH
37977: LD_INT 1
37979: PUSH
37980: LD_INT 3
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: LD_INT 0
37989: PUSH
37990: LD_INT 3
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: LD_INT 1
37999: NEG
38000: PUSH
38001: LD_INT 2
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 1
38010: PUSH
38011: LD_INT 4
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: LD_INT 4
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PUSH
38028: LD_INT 1
38030: NEG
38031: PUSH
38032: LD_INT 3
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 1
38041: PUSH
38042: LD_INT 5
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 0
38051: PUSH
38052: LD_INT 5
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: LD_INT 4
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 1
38072: PUSH
38073: LD_INT 6
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: LD_INT 6
38085: PUSH
38086: EMPTY
38087: LIST
38088: LIST
38089: PUSH
38090: LD_INT 1
38092: NEG
38093: PUSH
38094: LD_INT 5
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38115: LD_ADDR_VAR 0 33
38119: PUSH
38120: LD_INT 2
38122: NEG
38123: PUSH
38124: LD_INT 1
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 3
38133: NEG
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 3
38144: NEG
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 3
38156: NEG
38157: PUSH
38158: LD_INT 1
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 4
38167: NEG
38168: PUSH
38169: LD_INT 0
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 4
38178: NEG
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 4
38190: NEG
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 5
38201: NEG
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 5
38212: NEG
38213: PUSH
38214: LD_INT 1
38216: NEG
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 5
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 6
38235: NEG
38236: PUSH
38237: LD_INT 0
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 6
38246: NEG
38247: PUSH
38248: LD_INT 1
38250: NEG
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38270: LD_ADDR_VAR 0 34
38274: PUSH
38275: LD_INT 2
38277: NEG
38278: PUSH
38279: LD_INT 3
38281: NEG
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 3
38289: NEG
38290: PUSH
38291: LD_INT 2
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 3
38301: NEG
38302: PUSH
38303: LD_INT 3
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 3
38313: NEG
38314: PUSH
38315: LD_INT 4
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 4
38325: NEG
38326: PUSH
38327: LD_INT 3
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 4
38337: NEG
38338: PUSH
38339: LD_INT 4
38341: NEG
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 4
38349: NEG
38350: PUSH
38351: LD_INT 5
38353: NEG
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 5
38361: NEG
38362: PUSH
38363: LD_INT 4
38365: NEG
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 5
38373: NEG
38374: PUSH
38375: LD_INT 5
38377: NEG
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 5
38385: NEG
38386: PUSH
38387: LD_INT 6
38389: NEG
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 6
38397: NEG
38398: PUSH
38399: LD_INT 5
38401: NEG
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 6
38409: NEG
38410: PUSH
38411: LD_INT 6
38413: NEG
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: LIST
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: LIST
38432: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38433: LD_ADDR_VAR 0 41
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: LD_INT 3
38455: NEG
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PUSH
38461: LD_INT 1
38463: PUSH
38464: LD_INT 2
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: LIST
38476: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38477: LD_ADDR_VAR 0 42
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 0
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: LD_INT 1
38497: NEG
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 3
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: LIST
38517: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38518: LD_ADDR_VAR 0 43
38522: PUSH
38523: LD_INT 2
38525: PUSH
38526: LD_INT 2
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 3
38535: PUSH
38536: LD_INT 2
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: LD_INT 3
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: LIST
38557: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38558: LD_ADDR_VAR 0 44
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: LD_INT 2
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: LD_INT 3
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 1
38585: NEG
38586: PUSH
38587: LD_INT 2
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: LIST
38598: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38599: LD_ADDR_VAR 0 45
38603: PUSH
38604: LD_INT 2
38606: NEG
38607: PUSH
38608: LD_INT 0
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 2
38617: NEG
38618: PUSH
38619: LD_INT 1
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 3
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: NEG
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: LIST
38642: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38643: LD_ADDR_VAR 0 46
38647: PUSH
38648: LD_INT 2
38650: NEG
38651: PUSH
38652: LD_INT 2
38654: NEG
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 2
38662: NEG
38663: PUSH
38664: LD_INT 3
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 3
38674: NEG
38675: PUSH
38676: LD_INT 2
38678: NEG
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: LIST
38688: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38689: LD_ADDR_VAR 0 47
38693: PUSH
38694: LD_INT 2
38696: NEG
38697: PUSH
38698: LD_INT 3
38700: NEG
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 1
38708: NEG
38709: PUSH
38710: LD_INT 3
38712: NEG
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38722: LD_ADDR_VAR 0 48
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 2
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 2
38740: PUSH
38741: LD_INT 1
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38753: LD_ADDR_VAR 0 49
38757: PUSH
38758: LD_INT 3
38760: PUSH
38761: LD_INT 1
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: PUSH
38771: LD_INT 2
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38782: LD_ADDR_VAR 0 50
38786: PUSH
38787: LD_INT 2
38789: PUSH
38790: LD_INT 3
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 1
38799: PUSH
38800: LD_INT 3
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38811: LD_ADDR_VAR 0 51
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: LD_INT 2
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 2
38829: NEG
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38842: LD_ADDR_VAR 0 52
38846: PUSH
38847: LD_INT 3
38849: NEG
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 3
38861: NEG
38862: PUSH
38863: LD_INT 2
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38875: LD_ADDR_VAR 0 53
38879: PUSH
38880: LD_INT 1
38882: NEG
38883: PUSH
38884: LD_INT 3
38886: NEG
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 0
38894: PUSH
38895: LD_INT 3
38897: NEG
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 1
38905: PUSH
38906: LD_INT 2
38908: NEG
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: LIST
38918: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38919: LD_ADDR_VAR 0 54
38923: PUSH
38924: LD_INT 2
38926: PUSH
38927: LD_INT 1
38929: NEG
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 3
38937: PUSH
38938: LD_INT 0
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 3
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: LIST
38959: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38960: LD_ADDR_VAR 0 55
38964: PUSH
38965: LD_INT 3
38967: PUSH
38968: LD_INT 2
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: LD_INT 3
38977: PUSH
38978: LD_INT 3
38980: PUSH
38981: EMPTY
38982: LIST
38983: LIST
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: LD_INT 3
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: LIST
38999: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39000: LD_ADDR_VAR 0 56
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 3
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 0
39017: PUSH
39018: LD_INT 3
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 1
39027: NEG
39028: PUSH
39029: LD_INT 2
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: LIST
39040: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39041: LD_ADDR_VAR 0 57
39045: PUSH
39046: LD_INT 2
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 3
39059: NEG
39060: PUSH
39061: LD_INT 0
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 3
39070: NEG
39071: PUSH
39072: LD_INT 1
39074: NEG
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: LIST
39084: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39085: LD_ADDR_VAR 0 58
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: LD_INT 3
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 3
39104: NEG
39105: PUSH
39106: LD_INT 2
39108: NEG
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: LD_INT 3
39120: NEG
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: LIST
39130: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39131: LD_ADDR_VAR 0 59
39135: PUSH
39136: LD_INT 1
39138: NEG
39139: PUSH
39140: LD_INT 2
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: LD_INT 2
39153: NEG
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: LIST
39174: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39175: LD_ADDR_VAR 0 60
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: LD_INT 1
39185: NEG
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 2
39193: PUSH
39194: LD_INT 0
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 2
39203: PUSH
39204: LD_INT 1
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: LIST
39215: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39216: LD_ADDR_VAR 0 61
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: LD_INT 1
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 2
39233: PUSH
39234: LD_INT 2
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: PUSH
39244: LD_INT 2
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: LIST
39255: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39256: LD_ADDR_VAR 0 62
39260: PUSH
39261: LD_INT 1
39263: PUSH
39264: LD_INT 2
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: LD_INT 2
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: LD_INT 1
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: LIST
39296: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39297: LD_ADDR_VAR 0 63
39301: PUSH
39302: LD_INT 1
39304: NEG
39305: PUSH
39306: LD_INT 1
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 2
39315: NEG
39316: PUSH
39317: LD_INT 0
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 2
39326: NEG
39327: PUSH
39328: LD_INT 1
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39341: LD_ADDR_VAR 0 64
39345: PUSH
39346: LD_INT 1
39348: NEG
39349: PUSH
39350: LD_INT 2
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 2
39360: NEG
39361: PUSH
39362: LD_INT 1
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 2
39372: NEG
39373: PUSH
39374: LD_INT 2
39376: NEG
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: LIST
39386: ST_TO_ADDR
// end ; 2 :
39387: GO 42653
39389: LD_INT 2
39391: DOUBLE
39392: EQUAL
39393: IFTRUE 39397
39395: GO 42652
39397: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39398: LD_ADDR_VAR 0 29
39402: PUSH
39403: LD_INT 4
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 4
39415: PUSH
39416: LD_INT 1
39418: NEG
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 5
39426: PUSH
39427: LD_INT 0
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 5
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 4
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 3
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 3
39466: PUSH
39467: LD_INT 1
39469: NEG
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 3
39477: PUSH
39478: LD_INT 2
39480: NEG
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 5
39488: PUSH
39489: LD_INT 2
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 3
39498: PUSH
39499: LD_INT 3
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: LD_INT 3
39508: PUSH
39509: LD_INT 2
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 4
39518: PUSH
39519: LD_INT 3
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 4
39528: PUSH
39529: LD_INT 4
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 3
39538: PUSH
39539: LD_INT 4
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 2
39548: PUSH
39549: LD_INT 3
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 2
39558: PUSH
39559: LD_INT 2
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: LD_INT 2
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 2
39578: PUSH
39579: LD_INT 4
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 0
39588: PUSH
39589: LD_INT 4
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 0
39598: PUSH
39599: LD_INT 3
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 1
39608: PUSH
39609: LD_INT 4
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 1
39618: PUSH
39619: LD_INT 5
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: LD_INT 5
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 1
39638: NEG
39639: PUSH
39640: LD_INT 4
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 1
39649: NEG
39650: PUSH
39651: LD_INT 3
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 2
39660: PUSH
39661: LD_INT 5
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 2
39670: NEG
39671: PUSH
39672: LD_INT 3
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 3
39681: NEG
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 3
39692: NEG
39693: PUSH
39694: LD_INT 1
39696: NEG
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: NEG
39705: PUSH
39706: LD_INT 0
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 2
39715: NEG
39716: PUSH
39717: LD_INT 1
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 3
39726: NEG
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 4
39737: NEG
39738: PUSH
39739: LD_INT 0
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 4
39748: NEG
39749: PUSH
39750: LD_INT 1
39752: NEG
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: NEG
39761: PUSH
39762: LD_INT 2
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 2
39772: NEG
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 4
39783: NEG
39784: PUSH
39785: LD_INT 4
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 4
39795: NEG
39796: PUSH
39797: LD_INT 5
39799: NEG
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 3
39807: NEG
39808: PUSH
39809: LD_INT 4
39811: NEG
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 3
39819: NEG
39820: PUSH
39821: LD_INT 3
39823: NEG
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 4
39831: NEG
39832: PUSH
39833: LD_INT 3
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 5
39843: NEG
39844: PUSH
39845: LD_INT 4
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 5
39855: NEG
39856: PUSH
39857: LD_INT 5
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 3
39867: NEG
39868: PUSH
39869: LD_INT 5
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 5
39879: NEG
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39936: LD_ADDR_VAR 0 30
39940: PUSH
39941: LD_INT 4
39943: PUSH
39944: LD_INT 4
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 4
39953: PUSH
39954: LD_INT 3
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 5
39963: PUSH
39964: LD_INT 4
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 5
39973: PUSH
39974: LD_INT 5
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 4
39983: PUSH
39984: LD_INT 5
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: LD_INT 4
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 3
40003: PUSH
40004: LD_INT 3
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 5
40013: PUSH
40014: LD_INT 3
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 3
40023: PUSH
40024: LD_INT 5
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: LD_INT 3
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 0
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 1
40053: PUSH
40054: LD_INT 3
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: PUSH
40064: LD_INT 4
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: LD_INT 4
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 1
40083: NEG
40084: PUSH
40085: LD_INT 3
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 1
40094: NEG
40095: PUSH
40096: LD_INT 2
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 2
40105: PUSH
40106: LD_INT 4
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 2
40115: NEG
40116: PUSH
40117: LD_INT 2
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 4
40126: NEG
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 4
40137: NEG
40138: PUSH
40139: LD_INT 1
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 3
40149: NEG
40150: PUSH
40151: LD_INT 0
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 3
40160: NEG
40161: PUSH
40162: LD_INT 1
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 4
40171: NEG
40172: PUSH
40173: LD_INT 1
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 5
40182: NEG
40183: PUSH
40184: LD_INT 0
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 5
40193: NEG
40194: PUSH
40195: LD_INT 1
40197: NEG
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 5
40205: NEG
40206: PUSH
40207: LD_INT 2
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: NEG
40218: PUSH
40219: LD_INT 2
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 3
40228: NEG
40229: PUSH
40230: LD_INT 3
40232: NEG
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 3
40240: NEG
40241: PUSH
40242: LD_INT 4
40244: NEG
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 2
40252: NEG
40253: PUSH
40254: LD_INT 3
40256: NEG
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 2
40264: NEG
40265: PUSH
40266: LD_INT 2
40268: NEG
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 3
40276: NEG
40277: PUSH
40278: LD_INT 2
40280: NEG
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 4
40288: NEG
40289: PUSH
40290: LD_INT 3
40292: NEG
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 4
40300: NEG
40301: PUSH
40302: LD_INT 4
40304: NEG
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: PUSH
40310: LD_INT 2
40312: NEG
40313: PUSH
40314: LD_INT 4
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 4
40324: NEG
40325: PUSH
40326: LD_INT 2
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 0
40336: PUSH
40337: LD_INT 4
40339: NEG
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: LD_INT 5
40350: NEG
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 4
40361: NEG
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 1
40369: PUSH
40370: LD_INT 3
40372: NEG
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 0
40380: PUSH
40381: LD_INT 3
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 1
40391: NEG
40392: PUSH
40393: LD_INT 4
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: NEG
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 2
40415: PUSH
40416: LD_INT 3
40418: NEG
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 2
40426: NEG
40427: PUSH
40428: LD_INT 5
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40483: LD_ADDR_VAR 0 31
40487: PUSH
40488: LD_INT 0
40490: PUSH
40491: LD_INT 4
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 0
40500: PUSH
40501: LD_INT 3
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 4
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: LD_INT 5
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 5
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 4
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 3
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 2
40562: PUSH
40563: LD_INT 5
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 2
40572: NEG
40573: PUSH
40574: LD_INT 3
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 3
40583: NEG
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 3
40594: NEG
40595: PUSH
40596: LD_INT 1
40598: NEG
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 2
40606: NEG
40607: PUSH
40608: LD_INT 0
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 2
40617: NEG
40618: PUSH
40619: LD_INT 1
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 3
40628: NEG
40629: PUSH
40630: LD_INT 1
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 4
40639: NEG
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 4
40650: NEG
40651: PUSH
40652: LD_INT 1
40654: NEG
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: NEG
40663: PUSH
40664: LD_INT 2
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 2
40674: NEG
40675: PUSH
40676: LD_INT 2
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 4
40685: NEG
40686: PUSH
40687: LD_INT 4
40689: NEG
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 4
40697: NEG
40698: PUSH
40699: LD_INT 5
40701: NEG
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 3
40709: NEG
40710: PUSH
40711: LD_INT 4
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 3
40721: NEG
40722: PUSH
40723: LD_INT 3
40725: NEG
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 4
40733: NEG
40734: PUSH
40735: LD_INT 3
40737: NEG
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 5
40745: NEG
40746: PUSH
40747: LD_INT 4
40749: NEG
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 5
40757: NEG
40758: PUSH
40759: LD_INT 5
40761: NEG
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 3
40769: NEG
40770: PUSH
40771: LD_INT 5
40773: NEG
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 5
40781: NEG
40782: PUSH
40783: LD_INT 3
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 0
40793: PUSH
40794: LD_INT 3
40796: NEG
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: LD_INT 4
40807: NEG
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 1
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: PUSH
40827: LD_INT 2
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: LD_INT 2
40840: NEG
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 1
40848: NEG
40849: PUSH
40850: LD_INT 3
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 1
40860: NEG
40861: PUSH
40862: LD_INT 4
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 2
40872: PUSH
40873: LD_INT 2
40875: NEG
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 2
40883: NEG
40884: PUSH
40885: LD_INT 4
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 4
40895: PUSH
40896: LD_INT 0
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 4
40905: PUSH
40906: LD_INT 1
40908: NEG
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PUSH
40914: LD_INT 5
40916: PUSH
40917: LD_INT 0
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 5
40926: PUSH
40927: LD_INT 1
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 4
40936: PUSH
40937: LD_INT 1
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 3
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 3
40956: PUSH
40957: LD_INT 1
40959: NEG
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 3
40967: PUSH
40968: LD_INT 2
40970: NEG
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 5
40978: PUSH
40979: LD_INT 2
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41033: LD_ADDR_VAR 0 32
41037: PUSH
41038: LD_INT 4
41040: NEG
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 4
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 3
41063: NEG
41064: PUSH
41065: LD_INT 0
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 3
41074: NEG
41075: PUSH
41076: LD_INT 1
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 4
41085: NEG
41086: PUSH
41087: LD_INT 1
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 5
41096: NEG
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 5
41107: NEG
41108: PUSH
41109: LD_INT 1
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 5
41119: NEG
41120: PUSH
41121: LD_INT 2
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: NEG
41132: PUSH
41133: LD_INT 2
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 3
41142: NEG
41143: PUSH
41144: LD_INT 3
41146: NEG
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: NEG
41155: PUSH
41156: LD_INT 4
41158: NEG
41159: PUSH
41160: EMPTY
41161: LIST
41162: LIST
41163: PUSH
41164: LD_INT 2
41166: NEG
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 2
41178: NEG
41179: PUSH
41180: LD_INT 2
41182: NEG
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 3
41190: NEG
41191: PUSH
41192: LD_INT 2
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 4
41202: NEG
41203: PUSH
41204: LD_INT 3
41206: NEG
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 4
41214: NEG
41215: PUSH
41216: LD_INT 4
41218: NEG
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 2
41226: NEG
41227: PUSH
41228: LD_INT 4
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 4
41238: NEG
41239: PUSH
41240: LD_INT 2
41242: NEG
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 0
41250: PUSH
41251: LD_INT 4
41253: NEG
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 0
41261: PUSH
41262: LD_INT 5
41264: NEG
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 1
41272: PUSH
41273: LD_INT 4
41275: NEG
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 1
41283: PUSH
41284: LD_INT 3
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 0
41294: PUSH
41295: LD_INT 3
41297: NEG
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: PUSH
41303: LD_INT 1
41305: NEG
41306: PUSH
41307: LD_INT 4
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 1
41317: NEG
41318: PUSH
41319: LD_INT 5
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 2
41329: PUSH
41330: LD_INT 3
41332: NEG
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 2
41340: NEG
41341: PUSH
41342: LD_INT 5
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 3
41352: PUSH
41353: LD_INT 0
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 3
41362: PUSH
41363: LD_INT 1
41365: NEG
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: LD_INT 4
41373: PUSH
41374: LD_INT 0
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 4
41383: PUSH
41384: LD_INT 1
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: LD_INT 3
41393: PUSH
41394: LD_INT 1
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 2
41403: PUSH
41404: LD_INT 0
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 2
41413: PUSH
41414: LD_INT 1
41416: NEG
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 2
41424: PUSH
41425: LD_INT 2
41427: NEG
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 4
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: LD_INT 4
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 4
41455: PUSH
41456: LD_INT 3
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 5
41465: PUSH
41466: LD_INT 4
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 5
41475: PUSH
41476: LD_INT 5
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 4
41485: PUSH
41486: LD_INT 5
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: LD_INT 4
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: LD_INT 3
41505: PUSH
41506: LD_INT 3
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 5
41515: PUSH
41516: LD_INT 3
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 3
41525: PUSH
41526: LD_INT 5
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: LIST
41570: LIST
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41580: LD_ADDR_VAR 0 33
41584: PUSH
41585: LD_INT 4
41587: NEG
41588: PUSH
41589: LD_INT 4
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 4
41599: NEG
41600: PUSH
41601: LD_INT 5
41603: NEG
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: LD_INT 3
41611: NEG
41612: PUSH
41613: LD_INT 4
41615: NEG
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 3
41623: NEG
41624: PUSH
41625: LD_INT 3
41627: NEG
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: LD_INT 4
41635: NEG
41636: PUSH
41637: LD_INT 3
41639: NEG
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 5
41647: NEG
41648: PUSH
41649: LD_INT 4
41651: NEG
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: LD_INT 5
41659: NEG
41660: PUSH
41661: LD_INT 5
41663: NEG
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: LD_INT 3
41671: NEG
41672: PUSH
41673: LD_INT 5
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 5
41683: NEG
41684: PUSH
41685: LD_INT 3
41687: NEG
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 0
41695: PUSH
41696: LD_INT 3
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 0
41706: PUSH
41707: LD_INT 4
41709: NEG
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 1
41717: PUSH
41718: LD_INT 3
41720: NEG
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 1
41728: PUSH
41729: LD_INT 2
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 0
41739: PUSH
41740: LD_INT 2
41742: NEG
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 1
41750: NEG
41751: PUSH
41752: LD_INT 3
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 1
41762: NEG
41763: PUSH
41764: LD_INT 4
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 2
41774: PUSH
41775: LD_INT 2
41777: NEG
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: LD_INT 4
41789: NEG
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: PUSH
41795: LD_INT 4
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 4
41807: PUSH
41808: LD_INT 1
41810: NEG
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 5
41818: PUSH
41819: LD_INT 0
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 5
41828: PUSH
41829: LD_INT 1
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 4
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 3
41848: PUSH
41849: LD_INT 0
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 3
41858: PUSH
41859: LD_INT 1
41861: NEG
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 3
41869: PUSH
41870: LD_INT 2
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 5
41880: PUSH
41881: LD_INT 2
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 3
41890: PUSH
41891: LD_INT 3
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 3
41900: PUSH
41901: LD_INT 2
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: LD_INT 3
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 4
41920: PUSH
41921: LD_INT 4
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 3
41930: PUSH
41931: LD_INT 4
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: LD_INT 3
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 2
41950: PUSH
41951: LD_INT 2
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 4
41960: PUSH
41961: LD_INT 2
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 2
41970: PUSH
41971: LD_INT 4
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: LD_INT 4
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 0
41990: PUSH
41991: LD_INT 3
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: LD_INT 4
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 1
42010: PUSH
42011: LD_INT 5
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: LD_INT 5
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 1
42030: NEG
42031: PUSH
42032: LD_INT 4
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 1
42041: NEG
42042: PUSH
42043: LD_INT 3
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 2
42052: PUSH
42053: LD_INT 5
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 2
42062: NEG
42063: PUSH
42064: LD_INT 3
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42118: LD_ADDR_VAR 0 34
42122: PUSH
42123: LD_INT 0
42125: PUSH
42126: LD_INT 4
42128: NEG
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: PUSH
42134: LD_INT 0
42136: PUSH
42137: LD_INT 5
42139: NEG
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PUSH
42145: LD_INT 1
42147: PUSH
42148: LD_INT 4
42150: NEG
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: LD_INT 1
42158: PUSH
42159: LD_INT 3
42161: NEG
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 0
42169: PUSH
42170: LD_INT 3
42172: NEG
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: LD_INT 4
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 1
42192: NEG
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 2
42204: PUSH
42205: LD_INT 3
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 2
42215: NEG
42216: PUSH
42217: LD_INT 5
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: PUSH
42228: LD_INT 0
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 3
42237: PUSH
42238: LD_INT 1
42240: NEG
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 4
42248: PUSH
42249: LD_INT 0
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 4
42258: PUSH
42259: LD_INT 1
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 3
42268: PUSH
42269: LD_INT 1
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 0
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: PUSH
42289: LD_INT 1
42291: NEG
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 2
42299: PUSH
42300: LD_INT 2
42302: NEG
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 4
42310: PUSH
42311: LD_INT 2
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: LD_INT 4
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 4
42330: PUSH
42331: LD_INT 3
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 5
42340: PUSH
42341: LD_INT 4
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 5
42350: PUSH
42351: LD_INT 5
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 4
42360: PUSH
42361: LD_INT 5
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: LD_INT 4
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 3
42380: PUSH
42381: LD_INT 3
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 5
42390: PUSH
42391: LD_INT 3
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 3
42400: PUSH
42401: LD_INT 5
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: LD_INT 3
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 0
42420: PUSH
42421: LD_INT 2
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 1
42430: PUSH
42431: LD_INT 3
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: LD_INT 4
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 4
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 1
42460: NEG
42461: PUSH
42462: LD_INT 3
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: NEG
42472: PUSH
42473: LD_INT 2
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 2
42482: PUSH
42483: LD_INT 4
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: PUSH
42490: LD_INT 2
42492: NEG
42493: PUSH
42494: LD_INT 2
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 4
42503: NEG
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 4
42514: NEG
42515: PUSH
42516: LD_INT 1
42518: NEG
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 3
42526: NEG
42527: PUSH
42528: LD_INT 0
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 3
42537: NEG
42538: PUSH
42539: LD_INT 1
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 4
42548: NEG
42549: PUSH
42550: LD_INT 1
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 5
42559: NEG
42560: PUSH
42561: LD_INT 0
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 5
42570: NEG
42571: PUSH
42572: LD_INT 1
42574: NEG
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 5
42582: NEG
42583: PUSH
42584: LD_INT 2
42586: NEG
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 3
42594: NEG
42595: PUSH
42596: LD_INT 2
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: LIST
42643: LIST
42644: LIST
42645: LIST
42646: LIST
42647: LIST
42648: LIST
42649: ST_TO_ADDR
// end ; end ;
42650: GO 42653
42652: POP
// case btype of b_depot , b_warehouse :
42653: LD_VAR 0 1
42657: PUSH
42658: LD_INT 0
42660: DOUBLE
42661: EQUAL
42662: IFTRUE 42672
42664: LD_INT 1
42666: DOUBLE
42667: EQUAL
42668: IFTRUE 42672
42670: GO 42873
42672: POP
// case nation of nation_american :
42673: LD_VAR 0 5
42677: PUSH
42678: LD_INT 1
42680: DOUBLE
42681: EQUAL
42682: IFTRUE 42686
42684: GO 42742
42686: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42687: LD_ADDR_VAR 0 9
42691: PUSH
42692: LD_VAR 0 11
42696: PUSH
42697: LD_VAR 0 12
42701: PUSH
42702: LD_VAR 0 13
42706: PUSH
42707: LD_VAR 0 14
42711: PUSH
42712: LD_VAR 0 15
42716: PUSH
42717: LD_VAR 0 16
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: PUSH
42730: LD_VAR 0 4
42734: PUSH
42735: LD_INT 1
42737: PLUS
42738: ARRAY
42739: ST_TO_ADDR
42740: GO 42871
42742: LD_INT 2
42744: DOUBLE
42745: EQUAL
42746: IFTRUE 42750
42748: GO 42806
42750: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42751: LD_ADDR_VAR 0 9
42755: PUSH
42756: LD_VAR 0 17
42760: PUSH
42761: LD_VAR 0 18
42765: PUSH
42766: LD_VAR 0 19
42770: PUSH
42771: LD_VAR 0 20
42775: PUSH
42776: LD_VAR 0 21
42780: PUSH
42781: LD_VAR 0 22
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: PUSH
42794: LD_VAR 0 4
42798: PUSH
42799: LD_INT 1
42801: PLUS
42802: ARRAY
42803: ST_TO_ADDR
42804: GO 42871
42806: LD_INT 3
42808: DOUBLE
42809: EQUAL
42810: IFTRUE 42814
42812: GO 42870
42814: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42815: LD_ADDR_VAR 0 9
42819: PUSH
42820: LD_VAR 0 23
42824: PUSH
42825: LD_VAR 0 24
42829: PUSH
42830: LD_VAR 0 25
42834: PUSH
42835: LD_VAR 0 26
42839: PUSH
42840: LD_VAR 0 27
42844: PUSH
42845: LD_VAR 0 28
42849: PUSH
42850: EMPTY
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: PUSH
42858: LD_VAR 0 4
42862: PUSH
42863: LD_INT 1
42865: PLUS
42866: ARRAY
42867: ST_TO_ADDR
42868: GO 42871
42870: POP
42871: GO 43426
42873: LD_INT 2
42875: DOUBLE
42876: EQUAL
42877: IFTRUE 42887
42879: LD_INT 3
42881: DOUBLE
42882: EQUAL
42883: IFTRUE 42887
42885: GO 42943
42887: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42888: LD_ADDR_VAR 0 9
42892: PUSH
42893: LD_VAR 0 29
42897: PUSH
42898: LD_VAR 0 30
42902: PUSH
42903: LD_VAR 0 31
42907: PUSH
42908: LD_VAR 0 32
42912: PUSH
42913: LD_VAR 0 33
42917: PUSH
42918: LD_VAR 0 34
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: LIST
42927: LIST
42928: LIST
42929: LIST
42930: PUSH
42931: LD_VAR 0 4
42935: PUSH
42936: LD_INT 1
42938: PLUS
42939: ARRAY
42940: ST_TO_ADDR
42941: GO 43426
42943: LD_INT 16
42945: DOUBLE
42946: EQUAL
42947: IFTRUE 43005
42949: LD_INT 17
42951: DOUBLE
42952: EQUAL
42953: IFTRUE 43005
42955: LD_INT 18
42957: DOUBLE
42958: EQUAL
42959: IFTRUE 43005
42961: LD_INT 19
42963: DOUBLE
42964: EQUAL
42965: IFTRUE 43005
42967: LD_INT 22
42969: DOUBLE
42970: EQUAL
42971: IFTRUE 43005
42973: LD_INT 20
42975: DOUBLE
42976: EQUAL
42977: IFTRUE 43005
42979: LD_INT 21
42981: DOUBLE
42982: EQUAL
42983: IFTRUE 43005
42985: LD_INT 23
42987: DOUBLE
42988: EQUAL
42989: IFTRUE 43005
42991: LD_INT 24
42993: DOUBLE
42994: EQUAL
42995: IFTRUE 43005
42997: LD_INT 25
42999: DOUBLE
43000: EQUAL
43001: IFTRUE 43005
43003: GO 43061
43005: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43006: LD_ADDR_VAR 0 9
43010: PUSH
43011: LD_VAR 0 35
43015: PUSH
43016: LD_VAR 0 36
43020: PUSH
43021: LD_VAR 0 37
43025: PUSH
43026: LD_VAR 0 38
43030: PUSH
43031: LD_VAR 0 39
43035: PUSH
43036: LD_VAR 0 40
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: PUSH
43049: LD_VAR 0 4
43053: PUSH
43054: LD_INT 1
43056: PLUS
43057: ARRAY
43058: ST_TO_ADDR
43059: GO 43426
43061: LD_INT 6
43063: DOUBLE
43064: EQUAL
43065: IFTRUE 43117
43067: LD_INT 7
43069: DOUBLE
43070: EQUAL
43071: IFTRUE 43117
43073: LD_INT 8
43075: DOUBLE
43076: EQUAL
43077: IFTRUE 43117
43079: LD_INT 13
43081: DOUBLE
43082: EQUAL
43083: IFTRUE 43117
43085: LD_INT 12
43087: DOUBLE
43088: EQUAL
43089: IFTRUE 43117
43091: LD_INT 15
43093: DOUBLE
43094: EQUAL
43095: IFTRUE 43117
43097: LD_INT 11
43099: DOUBLE
43100: EQUAL
43101: IFTRUE 43117
43103: LD_INT 14
43105: DOUBLE
43106: EQUAL
43107: IFTRUE 43117
43109: LD_INT 10
43111: DOUBLE
43112: EQUAL
43113: IFTRUE 43117
43115: GO 43173
43117: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43118: LD_ADDR_VAR 0 9
43122: PUSH
43123: LD_VAR 0 41
43127: PUSH
43128: LD_VAR 0 42
43132: PUSH
43133: LD_VAR 0 43
43137: PUSH
43138: LD_VAR 0 44
43142: PUSH
43143: LD_VAR 0 45
43147: PUSH
43148: LD_VAR 0 46
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: PUSH
43161: LD_VAR 0 4
43165: PUSH
43166: LD_INT 1
43168: PLUS
43169: ARRAY
43170: ST_TO_ADDR
43171: GO 43426
43173: LD_INT 36
43175: DOUBLE
43176: EQUAL
43177: IFTRUE 43181
43179: GO 43237
43181: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43182: LD_ADDR_VAR 0 9
43186: PUSH
43187: LD_VAR 0 47
43191: PUSH
43192: LD_VAR 0 48
43196: PUSH
43197: LD_VAR 0 49
43201: PUSH
43202: LD_VAR 0 50
43206: PUSH
43207: LD_VAR 0 51
43211: PUSH
43212: LD_VAR 0 52
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: PUSH
43225: LD_VAR 0 4
43229: PUSH
43230: LD_INT 1
43232: PLUS
43233: ARRAY
43234: ST_TO_ADDR
43235: GO 43426
43237: LD_INT 4
43239: DOUBLE
43240: EQUAL
43241: IFTRUE 43263
43243: LD_INT 5
43245: DOUBLE
43246: EQUAL
43247: IFTRUE 43263
43249: LD_INT 34
43251: DOUBLE
43252: EQUAL
43253: IFTRUE 43263
43255: LD_INT 37
43257: DOUBLE
43258: EQUAL
43259: IFTRUE 43263
43261: GO 43319
43263: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43264: LD_ADDR_VAR 0 9
43268: PUSH
43269: LD_VAR 0 53
43273: PUSH
43274: LD_VAR 0 54
43278: PUSH
43279: LD_VAR 0 55
43283: PUSH
43284: LD_VAR 0 56
43288: PUSH
43289: LD_VAR 0 57
43293: PUSH
43294: LD_VAR 0 58
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: LIST
43303: LIST
43304: LIST
43305: LIST
43306: PUSH
43307: LD_VAR 0 4
43311: PUSH
43312: LD_INT 1
43314: PLUS
43315: ARRAY
43316: ST_TO_ADDR
43317: GO 43426
43319: LD_INT 31
43321: DOUBLE
43322: EQUAL
43323: IFTRUE 43369
43325: LD_INT 32
43327: DOUBLE
43328: EQUAL
43329: IFTRUE 43369
43331: LD_INT 33
43333: DOUBLE
43334: EQUAL
43335: IFTRUE 43369
43337: LD_INT 27
43339: DOUBLE
43340: EQUAL
43341: IFTRUE 43369
43343: LD_INT 26
43345: DOUBLE
43346: EQUAL
43347: IFTRUE 43369
43349: LD_INT 28
43351: DOUBLE
43352: EQUAL
43353: IFTRUE 43369
43355: LD_INT 29
43357: DOUBLE
43358: EQUAL
43359: IFTRUE 43369
43361: LD_INT 30
43363: DOUBLE
43364: EQUAL
43365: IFTRUE 43369
43367: GO 43425
43369: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43370: LD_ADDR_VAR 0 9
43374: PUSH
43375: LD_VAR 0 59
43379: PUSH
43380: LD_VAR 0 60
43384: PUSH
43385: LD_VAR 0 61
43389: PUSH
43390: LD_VAR 0 62
43394: PUSH
43395: LD_VAR 0 63
43399: PUSH
43400: LD_VAR 0 64
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: PUSH
43413: LD_VAR 0 4
43417: PUSH
43418: LD_INT 1
43420: PLUS
43421: ARRAY
43422: ST_TO_ADDR
43423: GO 43426
43425: POP
// temp_list2 = [ ] ;
43426: LD_ADDR_VAR 0 10
43430: PUSH
43431: EMPTY
43432: ST_TO_ADDR
// for i in temp_list do
43433: LD_ADDR_VAR 0 8
43437: PUSH
43438: LD_VAR 0 9
43442: PUSH
43443: FOR_IN
43444: IFFALSE 43496
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43446: LD_ADDR_VAR 0 10
43450: PUSH
43451: LD_VAR 0 10
43455: PUSH
43456: LD_VAR 0 8
43460: PUSH
43461: LD_INT 1
43463: ARRAY
43464: PUSH
43465: LD_VAR 0 2
43469: PLUS
43470: PUSH
43471: LD_VAR 0 8
43475: PUSH
43476: LD_INT 2
43478: ARRAY
43479: PUSH
43480: LD_VAR 0 3
43484: PLUS
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: EMPTY
43491: LIST
43492: ADD
43493: ST_TO_ADDR
43494: GO 43443
43496: POP
43497: POP
// result = temp_list2 ;
43498: LD_ADDR_VAR 0 7
43502: PUSH
43503: LD_VAR 0 10
43507: ST_TO_ADDR
// end ;
43508: LD_VAR 0 7
43512: RET
// export function EnemyInRange ( unit , dist ) ; begin
43513: LD_INT 0
43515: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43516: LD_ADDR_VAR 0 3
43520: PUSH
43521: LD_VAR 0 1
43525: PPUSH
43526: CALL_OW 255
43530: PPUSH
43531: LD_VAR 0 1
43535: PPUSH
43536: CALL_OW 250
43540: PPUSH
43541: LD_VAR 0 1
43545: PPUSH
43546: CALL_OW 251
43550: PPUSH
43551: LD_VAR 0 2
43555: PPUSH
43556: CALL 16909 0 4
43560: PUSH
43561: LD_INT 4
43563: ARRAY
43564: ST_TO_ADDR
// end ;
43565: LD_VAR 0 3
43569: RET
// export function PlayerSeeMe ( unit ) ; begin
43570: LD_INT 0
43572: PPUSH
// result := See ( your_side , unit ) ;
43573: LD_ADDR_VAR 0 2
43577: PUSH
43578: LD_OWVAR 2
43582: PPUSH
43583: LD_VAR 0 1
43587: PPUSH
43588: CALL_OW 292
43592: ST_TO_ADDR
// end ;
43593: LD_VAR 0 2
43597: RET
// export function ReverseDir ( unit ) ; begin
43598: LD_INT 0
43600: PPUSH
// if not unit then
43601: LD_VAR 0 1
43605: NOT
43606: IFFALSE 43610
// exit ;
43608: GO 43633
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43610: LD_ADDR_VAR 0 2
43614: PUSH
43615: LD_VAR 0 1
43619: PPUSH
43620: CALL_OW 254
43624: PUSH
43625: LD_INT 3
43627: PLUS
43628: PUSH
43629: LD_INT 6
43631: MOD
43632: ST_TO_ADDR
// end ;
43633: LD_VAR 0 2
43637: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43638: LD_INT 0
43640: PPUSH
43641: PPUSH
43642: PPUSH
43643: PPUSH
43644: PPUSH
// if not hexes then
43645: LD_VAR 0 2
43649: NOT
43650: IFFALSE 43654
// exit ;
43652: GO 43802
// dist := 9999 ;
43654: LD_ADDR_VAR 0 5
43658: PUSH
43659: LD_INT 9999
43661: ST_TO_ADDR
// for i = 1 to hexes do
43662: LD_ADDR_VAR 0 4
43666: PUSH
43667: DOUBLE
43668: LD_INT 1
43670: DEC
43671: ST_TO_ADDR
43672: LD_VAR 0 2
43676: PUSH
43677: FOR_TO
43678: IFFALSE 43790
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43680: LD_VAR 0 1
43684: PPUSH
43685: LD_VAR 0 2
43689: PUSH
43690: LD_VAR 0 4
43694: ARRAY
43695: PUSH
43696: LD_INT 1
43698: ARRAY
43699: PPUSH
43700: LD_VAR 0 2
43704: PUSH
43705: LD_VAR 0 4
43709: ARRAY
43710: PUSH
43711: LD_INT 2
43713: ARRAY
43714: PPUSH
43715: CALL_OW 297
43719: PUSH
43720: LD_VAR 0 5
43724: LESS
43725: IFFALSE 43788
// begin hex := hexes [ i ] ;
43727: LD_ADDR_VAR 0 7
43731: PUSH
43732: LD_VAR 0 2
43736: PUSH
43737: LD_VAR 0 4
43741: ARRAY
43742: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43743: LD_ADDR_VAR 0 5
43747: PUSH
43748: LD_VAR 0 1
43752: PPUSH
43753: LD_VAR 0 2
43757: PUSH
43758: LD_VAR 0 4
43762: ARRAY
43763: PUSH
43764: LD_INT 1
43766: ARRAY
43767: PPUSH
43768: LD_VAR 0 2
43772: PUSH
43773: LD_VAR 0 4
43777: ARRAY
43778: PUSH
43779: LD_INT 2
43781: ARRAY
43782: PPUSH
43783: CALL_OW 297
43787: ST_TO_ADDR
// end ; end ;
43788: GO 43677
43790: POP
43791: POP
// result := hex ;
43792: LD_ADDR_VAR 0 3
43796: PUSH
43797: LD_VAR 0 7
43801: ST_TO_ADDR
// end ;
43802: LD_VAR 0 3
43806: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43807: LD_INT 0
43809: PPUSH
43810: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43811: LD_VAR 0 1
43815: NOT
43816: PUSH
43817: LD_VAR 0 1
43821: PUSH
43822: LD_INT 21
43824: PUSH
43825: LD_INT 2
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 23
43834: PUSH
43835: LD_INT 2
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PPUSH
43846: CALL_OW 69
43850: IN
43851: NOT
43852: OR
43853: IFFALSE 43857
// exit ;
43855: GO 43904
// for i = 1 to 3 do
43857: LD_ADDR_VAR 0 3
43861: PUSH
43862: DOUBLE
43863: LD_INT 1
43865: DEC
43866: ST_TO_ADDR
43867: LD_INT 3
43869: PUSH
43870: FOR_TO
43871: IFFALSE 43902
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43873: LD_VAR 0 1
43877: PPUSH
43878: CALL_OW 250
43882: PPUSH
43883: LD_VAR 0 1
43887: PPUSH
43888: CALL_OW 251
43892: PPUSH
43893: LD_INT 1
43895: PPUSH
43896: CALL_OW 453
43900: GO 43870
43902: POP
43903: POP
// end ;
43904: LD_VAR 0 2
43908: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43909: LD_INT 0
43911: PPUSH
43912: PPUSH
43913: PPUSH
43914: PPUSH
43915: PPUSH
43916: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43917: LD_VAR 0 1
43921: NOT
43922: PUSH
43923: LD_VAR 0 2
43927: NOT
43928: OR
43929: PUSH
43930: LD_VAR 0 1
43934: PPUSH
43935: CALL_OW 314
43939: OR
43940: IFFALSE 43944
// exit ;
43942: GO 44385
// x := GetX ( enemy_unit ) ;
43944: LD_ADDR_VAR 0 7
43948: PUSH
43949: LD_VAR 0 2
43953: PPUSH
43954: CALL_OW 250
43958: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43959: LD_ADDR_VAR 0 8
43963: PUSH
43964: LD_VAR 0 2
43968: PPUSH
43969: CALL_OW 251
43973: ST_TO_ADDR
// if not x or not y then
43974: LD_VAR 0 7
43978: NOT
43979: PUSH
43980: LD_VAR 0 8
43984: NOT
43985: OR
43986: IFFALSE 43990
// exit ;
43988: GO 44385
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43990: LD_ADDR_VAR 0 6
43994: PUSH
43995: LD_VAR 0 7
43999: PPUSH
44000: LD_INT 0
44002: PPUSH
44003: LD_INT 4
44005: PPUSH
44006: CALL_OW 272
44010: PUSH
44011: LD_VAR 0 8
44015: PPUSH
44016: LD_INT 0
44018: PPUSH
44019: LD_INT 4
44021: PPUSH
44022: CALL_OW 273
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_VAR 0 7
44035: PPUSH
44036: LD_INT 1
44038: PPUSH
44039: LD_INT 4
44041: PPUSH
44042: CALL_OW 272
44046: PUSH
44047: LD_VAR 0 8
44051: PPUSH
44052: LD_INT 1
44054: PPUSH
44055: LD_INT 4
44057: PPUSH
44058: CALL_OW 273
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_VAR 0 7
44071: PPUSH
44072: LD_INT 2
44074: PPUSH
44075: LD_INT 4
44077: PPUSH
44078: CALL_OW 272
44082: PUSH
44083: LD_VAR 0 8
44087: PPUSH
44088: LD_INT 2
44090: PPUSH
44091: LD_INT 4
44093: PPUSH
44094: CALL_OW 273
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_VAR 0 7
44107: PPUSH
44108: LD_INT 3
44110: PPUSH
44111: LD_INT 4
44113: PPUSH
44114: CALL_OW 272
44118: PUSH
44119: LD_VAR 0 8
44123: PPUSH
44124: LD_INT 3
44126: PPUSH
44127: LD_INT 4
44129: PPUSH
44130: CALL_OW 273
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_VAR 0 7
44143: PPUSH
44144: LD_INT 4
44146: PPUSH
44147: LD_INT 4
44149: PPUSH
44150: CALL_OW 272
44154: PUSH
44155: LD_VAR 0 8
44159: PPUSH
44160: LD_INT 4
44162: PPUSH
44163: LD_INT 4
44165: PPUSH
44166: CALL_OW 273
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_VAR 0 7
44179: PPUSH
44180: LD_INT 5
44182: PPUSH
44183: LD_INT 4
44185: PPUSH
44186: CALL_OW 272
44190: PUSH
44191: LD_VAR 0 8
44195: PPUSH
44196: LD_INT 5
44198: PPUSH
44199: LD_INT 4
44201: PPUSH
44202: CALL_OW 273
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: LIST
44215: LIST
44216: LIST
44217: LIST
44218: ST_TO_ADDR
// for i = tmp downto 1 do
44219: LD_ADDR_VAR 0 4
44223: PUSH
44224: DOUBLE
44225: LD_VAR 0 6
44229: INC
44230: ST_TO_ADDR
44231: LD_INT 1
44233: PUSH
44234: FOR_DOWNTO
44235: IFFALSE 44336
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44237: LD_VAR 0 6
44241: PUSH
44242: LD_VAR 0 4
44246: ARRAY
44247: PUSH
44248: LD_INT 1
44250: ARRAY
44251: PPUSH
44252: LD_VAR 0 6
44256: PUSH
44257: LD_VAR 0 4
44261: ARRAY
44262: PUSH
44263: LD_INT 2
44265: ARRAY
44266: PPUSH
44267: CALL_OW 488
44271: NOT
44272: PUSH
44273: LD_VAR 0 6
44277: PUSH
44278: LD_VAR 0 4
44282: ARRAY
44283: PUSH
44284: LD_INT 1
44286: ARRAY
44287: PPUSH
44288: LD_VAR 0 6
44292: PUSH
44293: LD_VAR 0 4
44297: ARRAY
44298: PUSH
44299: LD_INT 2
44301: ARRAY
44302: PPUSH
44303: CALL_OW 428
44307: PUSH
44308: LD_INT 0
44310: NONEQUAL
44311: OR
44312: IFFALSE 44334
// tmp := Delete ( tmp , i ) ;
44314: LD_ADDR_VAR 0 6
44318: PUSH
44319: LD_VAR 0 6
44323: PPUSH
44324: LD_VAR 0 4
44328: PPUSH
44329: CALL_OW 3
44333: ST_TO_ADDR
44334: GO 44234
44336: POP
44337: POP
// j := GetClosestHex ( unit , tmp ) ;
44338: LD_ADDR_VAR 0 5
44342: PUSH
44343: LD_VAR 0 1
44347: PPUSH
44348: LD_VAR 0 6
44352: PPUSH
44353: CALL 43638 0 2
44357: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44358: LD_VAR 0 1
44362: PPUSH
44363: LD_VAR 0 5
44367: PUSH
44368: LD_INT 1
44370: ARRAY
44371: PPUSH
44372: LD_VAR 0 5
44376: PUSH
44377: LD_INT 2
44379: ARRAY
44380: PPUSH
44381: CALL_OW 111
// end ;
44385: LD_VAR 0 3
44389: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44390: LD_INT 0
44392: PPUSH
44393: PPUSH
44394: PPUSH
// uc_side = 0 ;
44395: LD_ADDR_OWVAR 20
44399: PUSH
44400: LD_INT 0
44402: ST_TO_ADDR
// uc_nation = 0 ;
44403: LD_ADDR_OWVAR 21
44407: PUSH
44408: LD_INT 0
44410: ST_TO_ADDR
// InitHc_All ( ) ;
44411: CALL_OW 584
// InitVc ;
44415: CALL_OW 20
// if mastodonts then
44419: LD_VAR 0 6
44423: IFFALSE 44490
// for i = 1 to mastodonts do
44425: LD_ADDR_VAR 0 11
44429: PUSH
44430: DOUBLE
44431: LD_INT 1
44433: DEC
44434: ST_TO_ADDR
44435: LD_VAR 0 6
44439: PUSH
44440: FOR_TO
44441: IFFALSE 44488
// begin vc_chassis := 31 ;
44443: LD_ADDR_OWVAR 37
44447: PUSH
44448: LD_INT 31
44450: ST_TO_ADDR
// vc_control := control_rider ;
44451: LD_ADDR_OWVAR 38
44455: PUSH
44456: LD_INT 4
44458: ST_TO_ADDR
// animal := CreateVehicle ;
44459: LD_ADDR_VAR 0 12
44463: PUSH
44464: CALL_OW 45
44468: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44469: LD_VAR 0 12
44473: PPUSH
44474: LD_VAR 0 8
44478: PPUSH
44479: LD_INT 0
44481: PPUSH
44482: CALL 46625 0 3
// end ;
44486: GO 44440
44488: POP
44489: POP
// if horses then
44490: LD_VAR 0 5
44494: IFFALSE 44561
// for i = 1 to horses do
44496: LD_ADDR_VAR 0 11
44500: PUSH
44501: DOUBLE
44502: LD_INT 1
44504: DEC
44505: ST_TO_ADDR
44506: LD_VAR 0 5
44510: PUSH
44511: FOR_TO
44512: IFFALSE 44559
// begin hc_class := 21 ;
44514: LD_ADDR_OWVAR 28
44518: PUSH
44519: LD_INT 21
44521: ST_TO_ADDR
// hc_gallery :=  ;
44522: LD_ADDR_OWVAR 33
44526: PUSH
44527: LD_STRING 
44529: ST_TO_ADDR
// animal := CreateHuman ;
44530: LD_ADDR_VAR 0 12
44534: PUSH
44535: CALL_OW 44
44539: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44540: LD_VAR 0 12
44544: PPUSH
44545: LD_VAR 0 8
44549: PPUSH
44550: LD_INT 0
44552: PPUSH
44553: CALL 46625 0 3
// end ;
44557: GO 44511
44559: POP
44560: POP
// if birds then
44561: LD_VAR 0 1
44565: IFFALSE 44632
// for i = 1 to birds do
44567: LD_ADDR_VAR 0 11
44571: PUSH
44572: DOUBLE
44573: LD_INT 1
44575: DEC
44576: ST_TO_ADDR
44577: LD_VAR 0 1
44581: PUSH
44582: FOR_TO
44583: IFFALSE 44630
// begin hc_class = 18 ;
44585: LD_ADDR_OWVAR 28
44589: PUSH
44590: LD_INT 18
44592: ST_TO_ADDR
// hc_gallery =  ;
44593: LD_ADDR_OWVAR 33
44597: PUSH
44598: LD_STRING 
44600: ST_TO_ADDR
// animal := CreateHuman ;
44601: LD_ADDR_VAR 0 12
44605: PUSH
44606: CALL_OW 44
44610: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44611: LD_VAR 0 12
44615: PPUSH
44616: LD_VAR 0 8
44620: PPUSH
44621: LD_INT 0
44623: PPUSH
44624: CALL 46625 0 3
// end ;
44628: GO 44582
44630: POP
44631: POP
// if tigers then
44632: LD_VAR 0 2
44636: IFFALSE 44720
// for i = 1 to tigers do
44638: LD_ADDR_VAR 0 11
44642: PUSH
44643: DOUBLE
44644: LD_INT 1
44646: DEC
44647: ST_TO_ADDR
44648: LD_VAR 0 2
44652: PUSH
44653: FOR_TO
44654: IFFALSE 44718
// begin hc_class = class_tiger ;
44656: LD_ADDR_OWVAR 28
44660: PUSH
44661: LD_INT 14
44663: ST_TO_ADDR
// hc_gallery =  ;
44664: LD_ADDR_OWVAR 33
44668: PUSH
44669: LD_STRING 
44671: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44672: LD_ADDR_OWVAR 35
44676: PUSH
44677: LD_INT 7
44679: NEG
44680: PPUSH
44681: LD_INT 7
44683: PPUSH
44684: CALL_OW 12
44688: ST_TO_ADDR
// animal := CreateHuman ;
44689: LD_ADDR_VAR 0 12
44693: PUSH
44694: CALL_OW 44
44698: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44699: LD_VAR 0 12
44703: PPUSH
44704: LD_VAR 0 8
44708: PPUSH
44709: LD_INT 0
44711: PPUSH
44712: CALL 46625 0 3
// end ;
44716: GO 44653
44718: POP
44719: POP
// if apemans then
44720: LD_VAR 0 3
44724: IFFALSE 44847
// for i = 1 to apemans do
44726: LD_ADDR_VAR 0 11
44730: PUSH
44731: DOUBLE
44732: LD_INT 1
44734: DEC
44735: ST_TO_ADDR
44736: LD_VAR 0 3
44740: PUSH
44741: FOR_TO
44742: IFFALSE 44845
// begin hc_class = class_apeman ;
44744: LD_ADDR_OWVAR 28
44748: PUSH
44749: LD_INT 12
44751: ST_TO_ADDR
// hc_gallery =  ;
44752: LD_ADDR_OWVAR 33
44756: PUSH
44757: LD_STRING 
44759: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44760: LD_ADDR_OWVAR 35
44764: PUSH
44765: LD_INT 2
44767: NEG
44768: PPUSH
44769: LD_INT 2
44771: PPUSH
44772: CALL_OW 12
44776: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44777: LD_ADDR_OWVAR 31
44781: PUSH
44782: LD_INT 1
44784: PPUSH
44785: LD_INT 3
44787: PPUSH
44788: CALL_OW 12
44792: PUSH
44793: LD_INT 1
44795: PPUSH
44796: LD_INT 3
44798: PPUSH
44799: CALL_OW 12
44803: PUSH
44804: LD_INT 0
44806: PUSH
44807: LD_INT 0
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// animal := CreateHuman ;
44816: LD_ADDR_VAR 0 12
44820: PUSH
44821: CALL_OW 44
44825: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44826: LD_VAR 0 12
44830: PPUSH
44831: LD_VAR 0 8
44835: PPUSH
44836: LD_INT 0
44838: PPUSH
44839: CALL 46625 0 3
// end ;
44843: GO 44741
44845: POP
44846: POP
// if enchidnas then
44847: LD_VAR 0 4
44851: IFFALSE 44918
// for i = 1 to enchidnas do
44853: LD_ADDR_VAR 0 11
44857: PUSH
44858: DOUBLE
44859: LD_INT 1
44861: DEC
44862: ST_TO_ADDR
44863: LD_VAR 0 4
44867: PUSH
44868: FOR_TO
44869: IFFALSE 44916
// begin hc_class = 13 ;
44871: LD_ADDR_OWVAR 28
44875: PUSH
44876: LD_INT 13
44878: ST_TO_ADDR
// hc_gallery =  ;
44879: LD_ADDR_OWVAR 33
44883: PUSH
44884: LD_STRING 
44886: ST_TO_ADDR
// animal := CreateHuman ;
44887: LD_ADDR_VAR 0 12
44891: PUSH
44892: CALL_OW 44
44896: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44897: LD_VAR 0 12
44901: PPUSH
44902: LD_VAR 0 8
44906: PPUSH
44907: LD_INT 0
44909: PPUSH
44910: CALL 46625 0 3
// end ;
44914: GO 44868
44916: POP
44917: POP
// if fishes then
44918: LD_VAR 0 7
44922: IFFALSE 44989
// for i = 1 to fishes do
44924: LD_ADDR_VAR 0 11
44928: PUSH
44929: DOUBLE
44930: LD_INT 1
44932: DEC
44933: ST_TO_ADDR
44934: LD_VAR 0 7
44938: PUSH
44939: FOR_TO
44940: IFFALSE 44987
// begin hc_class = 20 ;
44942: LD_ADDR_OWVAR 28
44946: PUSH
44947: LD_INT 20
44949: ST_TO_ADDR
// hc_gallery =  ;
44950: LD_ADDR_OWVAR 33
44954: PUSH
44955: LD_STRING 
44957: ST_TO_ADDR
// animal := CreateHuman ;
44958: LD_ADDR_VAR 0 12
44962: PUSH
44963: CALL_OW 44
44967: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44968: LD_VAR 0 12
44972: PPUSH
44973: LD_VAR 0 9
44977: PPUSH
44978: LD_INT 0
44980: PPUSH
44981: CALL 46625 0 3
// end ;
44985: GO 44939
44987: POP
44988: POP
// end ;
44989: LD_VAR 0 10
44993: RET
// export function WantHeal ( sci , unit ) ; begin
44994: LD_INT 0
44996: PPUSH
// if GetTaskList ( sci ) > 0 then
44997: LD_VAR 0 1
45001: PPUSH
45002: CALL_OW 437
45006: PUSH
45007: LD_INT 0
45009: GREATER
45010: IFFALSE 45080
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45012: LD_VAR 0 1
45016: PPUSH
45017: CALL_OW 437
45021: PUSH
45022: LD_INT 1
45024: ARRAY
45025: PUSH
45026: LD_INT 1
45028: ARRAY
45029: PUSH
45030: LD_STRING l
45032: EQUAL
45033: PUSH
45034: LD_VAR 0 1
45038: PPUSH
45039: CALL_OW 437
45043: PUSH
45044: LD_INT 1
45046: ARRAY
45047: PUSH
45048: LD_INT 4
45050: ARRAY
45051: PUSH
45052: LD_VAR 0 2
45056: EQUAL
45057: AND
45058: IFFALSE 45070
// result := true else
45060: LD_ADDR_VAR 0 3
45064: PUSH
45065: LD_INT 1
45067: ST_TO_ADDR
45068: GO 45078
// result := false ;
45070: LD_ADDR_VAR 0 3
45074: PUSH
45075: LD_INT 0
45077: ST_TO_ADDR
// end else
45078: GO 45088
// result := false ;
45080: LD_ADDR_VAR 0 3
45084: PUSH
45085: LD_INT 0
45087: ST_TO_ADDR
// end ;
45088: LD_VAR 0 3
45092: RET
// export function HealTarget ( sci ) ; begin
45093: LD_INT 0
45095: PPUSH
// if not sci then
45096: LD_VAR 0 1
45100: NOT
45101: IFFALSE 45105
// exit ;
45103: GO 45170
// result := 0 ;
45105: LD_ADDR_VAR 0 2
45109: PUSH
45110: LD_INT 0
45112: ST_TO_ADDR
// if GetTaskList ( sci ) then
45113: LD_VAR 0 1
45117: PPUSH
45118: CALL_OW 437
45122: IFFALSE 45170
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45124: LD_VAR 0 1
45128: PPUSH
45129: CALL_OW 437
45133: PUSH
45134: LD_INT 1
45136: ARRAY
45137: PUSH
45138: LD_INT 1
45140: ARRAY
45141: PUSH
45142: LD_STRING l
45144: EQUAL
45145: IFFALSE 45170
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45147: LD_ADDR_VAR 0 2
45151: PUSH
45152: LD_VAR 0 1
45156: PPUSH
45157: CALL_OW 437
45161: PUSH
45162: LD_INT 1
45164: ARRAY
45165: PUSH
45166: LD_INT 4
45168: ARRAY
45169: ST_TO_ADDR
// end ;
45170: LD_VAR 0 2
45174: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45175: LD_INT 0
45177: PPUSH
45178: PPUSH
45179: PPUSH
45180: PPUSH
// if not base_units then
45181: LD_VAR 0 1
45185: NOT
45186: IFFALSE 45190
// exit ;
45188: GO 45277
// result := false ;
45190: LD_ADDR_VAR 0 2
45194: PUSH
45195: LD_INT 0
45197: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45198: LD_ADDR_VAR 0 5
45202: PUSH
45203: LD_VAR 0 1
45207: PPUSH
45208: LD_INT 21
45210: PUSH
45211: LD_INT 3
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PPUSH
45218: CALL_OW 72
45222: ST_TO_ADDR
// if not tmp then
45223: LD_VAR 0 5
45227: NOT
45228: IFFALSE 45232
// exit ;
45230: GO 45277
// for i in tmp do
45232: LD_ADDR_VAR 0 3
45236: PUSH
45237: LD_VAR 0 5
45241: PUSH
45242: FOR_IN
45243: IFFALSE 45275
// begin result := EnemyInRange ( i , 22 ) ;
45245: LD_ADDR_VAR 0 2
45249: PUSH
45250: LD_VAR 0 3
45254: PPUSH
45255: LD_INT 22
45257: PPUSH
45258: CALL 43513 0 2
45262: ST_TO_ADDR
// if result then
45263: LD_VAR 0 2
45267: IFFALSE 45273
// exit ;
45269: POP
45270: POP
45271: GO 45277
// end ;
45273: GO 45242
45275: POP
45276: POP
// end ;
45277: LD_VAR 0 2
45281: RET
// export function FilterByTag ( units , tag ) ; begin
45282: LD_INT 0
45284: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
45285: LD_ADDR_VAR 0 3
45289: PUSH
45290: LD_VAR 0 1
45294: PPUSH
45295: LD_INT 120
45297: PUSH
45298: LD_VAR 0 2
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PPUSH
45307: CALL_OW 72
45311: ST_TO_ADDR
// end ;
45312: LD_VAR 0 3
45316: RET
// export function IsDriver ( un ) ; begin
45317: LD_INT 0
45319: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45320: LD_ADDR_VAR 0 2
45324: PUSH
45325: LD_VAR 0 1
45329: PUSH
45330: LD_INT 55
45332: PUSH
45333: EMPTY
45334: LIST
45335: PPUSH
45336: CALL_OW 69
45340: IN
45341: ST_TO_ADDR
// end ;
45342: LD_VAR 0 2
45346: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45347: LD_INT 0
45349: PPUSH
45350: PPUSH
// list := [ ] ;
45351: LD_ADDR_VAR 0 5
45355: PUSH
45356: EMPTY
45357: ST_TO_ADDR
// case d of 0 :
45358: LD_VAR 0 3
45362: PUSH
45363: LD_INT 0
45365: DOUBLE
45366: EQUAL
45367: IFTRUE 45371
45369: GO 45504
45371: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45372: LD_ADDR_VAR 0 5
45376: PUSH
45377: LD_VAR 0 1
45381: PUSH
45382: LD_INT 4
45384: MINUS
45385: PUSH
45386: LD_VAR 0 2
45390: PUSH
45391: LD_INT 4
45393: MINUS
45394: PUSH
45395: LD_INT 2
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: LIST
45402: PUSH
45403: LD_VAR 0 1
45407: PUSH
45408: LD_INT 3
45410: MINUS
45411: PUSH
45412: LD_VAR 0 2
45416: PUSH
45417: LD_INT 1
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: LIST
45424: PUSH
45425: LD_VAR 0 1
45429: PUSH
45430: LD_INT 4
45432: PLUS
45433: PUSH
45434: LD_VAR 0 2
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: PUSH
45447: LD_VAR 0 1
45451: PUSH
45452: LD_INT 3
45454: PLUS
45455: PUSH
45456: LD_VAR 0 2
45460: PUSH
45461: LD_INT 3
45463: PLUS
45464: PUSH
45465: LD_INT 5
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: LIST
45472: PUSH
45473: LD_VAR 0 1
45477: PUSH
45478: LD_VAR 0 2
45482: PUSH
45483: LD_INT 4
45485: PLUS
45486: PUSH
45487: LD_INT 0
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: LIST
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: ST_TO_ADDR
// end ; 1 :
45502: GO 46202
45504: LD_INT 1
45506: DOUBLE
45507: EQUAL
45508: IFTRUE 45512
45510: GO 45645
45512: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45513: LD_ADDR_VAR 0 5
45517: PUSH
45518: LD_VAR 0 1
45522: PUSH
45523: LD_VAR 0 2
45527: PUSH
45528: LD_INT 4
45530: MINUS
45531: PUSH
45532: LD_INT 3
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: LIST
45539: PUSH
45540: LD_VAR 0 1
45544: PUSH
45545: LD_INT 3
45547: MINUS
45548: PUSH
45549: LD_VAR 0 2
45553: PUSH
45554: LD_INT 3
45556: MINUS
45557: PUSH
45558: LD_INT 2
45560: PUSH
45561: EMPTY
45562: LIST
45563: LIST
45564: LIST
45565: PUSH
45566: LD_VAR 0 1
45570: PUSH
45571: LD_INT 4
45573: MINUS
45574: PUSH
45575: LD_VAR 0 2
45579: PUSH
45580: LD_INT 1
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: LIST
45587: PUSH
45588: LD_VAR 0 1
45592: PUSH
45593: LD_VAR 0 2
45597: PUSH
45598: LD_INT 3
45600: PLUS
45601: PUSH
45602: LD_INT 0
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: LIST
45609: PUSH
45610: LD_VAR 0 1
45614: PUSH
45615: LD_INT 4
45617: PLUS
45618: PUSH
45619: LD_VAR 0 2
45623: PUSH
45624: LD_INT 4
45626: PLUS
45627: PUSH
45628: LD_INT 5
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: LIST
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: ST_TO_ADDR
// end ; 2 :
45643: GO 46202
45645: LD_INT 2
45647: DOUBLE
45648: EQUAL
45649: IFTRUE 45653
45651: GO 45782
45653: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45654: LD_ADDR_VAR 0 5
45658: PUSH
45659: LD_VAR 0 1
45663: PUSH
45664: LD_VAR 0 2
45668: PUSH
45669: LD_INT 3
45671: MINUS
45672: PUSH
45673: LD_INT 3
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: LIST
45680: PUSH
45681: LD_VAR 0 1
45685: PUSH
45686: LD_INT 4
45688: PLUS
45689: PUSH
45690: LD_VAR 0 2
45694: PUSH
45695: LD_INT 4
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: LIST
45702: PUSH
45703: LD_VAR 0 1
45707: PUSH
45708: LD_VAR 0 2
45712: PUSH
45713: LD_INT 4
45715: PLUS
45716: PUSH
45717: LD_INT 0
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: LIST
45724: PUSH
45725: LD_VAR 0 1
45729: PUSH
45730: LD_INT 3
45732: MINUS
45733: PUSH
45734: LD_VAR 0 2
45738: PUSH
45739: LD_INT 1
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: LIST
45746: PUSH
45747: LD_VAR 0 1
45751: PUSH
45752: LD_INT 4
45754: MINUS
45755: PUSH
45756: LD_VAR 0 2
45760: PUSH
45761: LD_INT 4
45763: MINUS
45764: PUSH
45765: LD_INT 2
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: LIST
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: LIST
45777: LIST
45778: LIST
45779: ST_TO_ADDR
// end ; 3 :
45780: GO 46202
45782: LD_INT 3
45784: DOUBLE
45785: EQUAL
45786: IFTRUE 45790
45788: GO 45923
45790: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45791: LD_ADDR_VAR 0 5
45795: PUSH
45796: LD_VAR 0 1
45800: PUSH
45801: LD_INT 3
45803: PLUS
45804: PUSH
45805: LD_VAR 0 2
45809: PUSH
45810: LD_INT 4
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: LIST
45817: PUSH
45818: LD_VAR 0 1
45822: PUSH
45823: LD_INT 4
45825: PLUS
45826: PUSH
45827: LD_VAR 0 2
45831: PUSH
45832: LD_INT 4
45834: PLUS
45835: PUSH
45836: LD_INT 5
45838: PUSH
45839: EMPTY
45840: LIST
45841: LIST
45842: LIST
45843: PUSH
45844: LD_VAR 0 1
45848: PUSH
45849: LD_INT 4
45851: MINUS
45852: PUSH
45853: LD_VAR 0 2
45857: PUSH
45858: LD_INT 1
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: LIST
45865: PUSH
45866: LD_VAR 0 1
45870: PUSH
45871: LD_VAR 0 2
45875: PUSH
45876: LD_INT 4
45878: MINUS
45879: PUSH
45880: LD_INT 3
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: LIST
45887: PUSH
45888: LD_VAR 0 1
45892: PUSH
45893: LD_INT 3
45895: MINUS
45896: PUSH
45897: LD_VAR 0 2
45901: PUSH
45902: LD_INT 3
45904: MINUS
45905: PUSH
45906: LD_INT 2
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: LIST
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: ST_TO_ADDR
// end ; 4 :
45921: GO 46202
45923: LD_INT 4
45925: DOUBLE
45926: EQUAL
45927: IFTRUE 45931
45929: GO 46064
45931: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45932: LD_ADDR_VAR 0 5
45936: PUSH
45937: LD_VAR 0 1
45941: PUSH
45942: LD_VAR 0 2
45946: PUSH
45947: LD_INT 4
45949: PLUS
45950: PUSH
45951: LD_INT 0
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: LIST
45958: PUSH
45959: LD_VAR 0 1
45963: PUSH
45964: LD_INT 3
45966: PLUS
45967: PUSH
45968: LD_VAR 0 2
45972: PUSH
45973: LD_INT 3
45975: PLUS
45976: PUSH
45977: LD_INT 5
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: LIST
45984: PUSH
45985: LD_VAR 0 1
45989: PUSH
45990: LD_INT 4
45992: PLUS
45993: PUSH
45994: LD_VAR 0 2
45998: PUSH
45999: LD_INT 4
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: LIST
46006: PUSH
46007: LD_VAR 0 1
46011: PUSH
46012: LD_VAR 0 2
46016: PUSH
46017: LD_INT 3
46019: MINUS
46020: PUSH
46021: LD_INT 3
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: LIST
46028: PUSH
46029: LD_VAR 0 1
46033: PUSH
46034: LD_INT 4
46036: MINUS
46037: PUSH
46038: LD_VAR 0 2
46042: PUSH
46043: LD_INT 4
46045: MINUS
46046: PUSH
46047: LD_INT 2
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: LIST
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: LIST
46061: ST_TO_ADDR
// end ; 5 :
46062: GO 46202
46064: LD_INT 5
46066: DOUBLE
46067: EQUAL
46068: IFTRUE 46072
46070: GO 46201
46072: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46073: LD_ADDR_VAR 0 5
46077: PUSH
46078: LD_VAR 0 1
46082: PUSH
46083: LD_INT 4
46085: MINUS
46086: PUSH
46087: LD_VAR 0 2
46091: PUSH
46092: LD_INT 1
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: LIST
46099: PUSH
46100: LD_VAR 0 1
46104: PUSH
46105: LD_VAR 0 2
46109: PUSH
46110: LD_INT 4
46112: MINUS
46113: PUSH
46114: LD_INT 3
46116: PUSH
46117: EMPTY
46118: LIST
46119: LIST
46120: LIST
46121: PUSH
46122: LD_VAR 0 1
46126: PUSH
46127: LD_INT 4
46129: PLUS
46130: PUSH
46131: LD_VAR 0 2
46135: PUSH
46136: LD_INT 4
46138: PLUS
46139: PUSH
46140: LD_INT 5
46142: PUSH
46143: EMPTY
46144: LIST
46145: LIST
46146: LIST
46147: PUSH
46148: LD_VAR 0 1
46152: PUSH
46153: LD_INT 3
46155: PLUS
46156: PUSH
46157: LD_VAR 0 2
46161: PUSH
46162: LD_INT 4
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: LIST
46169: PUSH
46170: LD_VAR 0 1
46174: PUSH
46175: LD_VAR 0 2
46179: PUSH
46180: LD_INT 3
46182: PLUS
46183: PUSH
46184: LD_INT 0
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: LIST
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: ST_TO_ADDR
// end ; end ;
46199: GO 46202
46201: POP
// result := list ;
46202: LD_ADDR_VAR 0 4
46206: PUSH
46207: LD_VAR 0 5
46211: ST_TO_ADDR
// end ;
46212: LD_VAR 0 4
46216: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46217: LD_INT 0
46219: PPUSH
46220: PPUSH
46221: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46222: LD_VAR 0 1
46226: NOT
46227: PUSH
46228: LD_VAR 0 2
46232: PUSH
46233: LD_INT 1
46235: PUSH
46236: LD_INT 2
46238: PUSH
46239: LD_INT 3
46241: PUSH
46242: LD_INT 4
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: IN
46251: NOT
46252: OR
46253: IFFALSE 46257
// exit ;
46255: GO 46349
// tmp := [ ] ;
46257: LD_ADDR_VAR 0 5
46261: PUSH
46262: EMPTY
46263: ST_TO_ADDR
// for i in units do
46264: LD_ADDR_VAR 0 4
46268: PUSH
46269: LD_VAR 0 1
46273: PUSH
46274: FOR_IN
46275: IFFALSE 46318
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46277: LD_ADDR_VAR 0 5
46281: PUSH
46282: LD_VAR 0 5
46286: PPUSH
46287: LD_VAR 0 5
46291: PUSH
46292: LD_INT 1
46294: PLUS
46295: PPUSH
46296: LD_VAR 0 4
46300: PPUSH
46301: LD_VAR 0 2
46305: PPUSH
46306: CALL_OW 259
46310: PPUSH
46311: CALL_OW 2
46315: ST_TO_ADDR
46316: GO 46274
46318: POP
46319: POP
// if not tmp then
46320: LD_VAR 0 5
46324: NOT
46325: IFFALSE 46329
// exit ;
46327: GO 46349
// result := SortListByListDesc ( units , tmp ) ;
46329: LD_ADDR_VAR 0 3
46333: PUSH
46334: LD_VAR 0 1
46338: PPUSH
46339: LD_VAR 0 5
46343: PPUSH
46344: CALL_OW 77
46348: ST_TO_ADDR
// end ;
46349: LD_VAR 0 3
46353: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46354: LD_INT 0
46356: PPUSH
46357: PPUSH
46358: PPUSH
// result := false ;
46359: LD_ADDR_VAR 0 3
46363: PUSH
46364: LD_INT 0
46366: ST_TO_ADDR
// x := GetX ( building ) ;
46367: LD_ADDR_VAR 0 4
46371: PUSH
46372: LD_VAR 0 2
46376: PPUSH
46377: CALL_OW 250
46381: ST_TO_ADDR
// y := GetY ( building ) ;
46382: LD_ADDR_VAR 0 5
46386: PUSH
46387: LD_VAR 0 2
46391: PPUSH
46392: CALL_OW 251
46396: ST_TO_ADDR
// if not building or not x or not y then
46397: LD_VAR 0 2
46401: NOT
46402: PUSH
46403: LD_VAR 0 4
46407: NOT
46408: OR
46409: PUSH
46410: LD_VAR 0 5
46414: NOT
46415: OR
46416: IFFALSE 46420
// exit ;
46418: GO 46512
// if GetTaskList ( unit ) then
46420: LD_VAR 0 1
46424: PPUSH
46425: CALL_OW 437
46429: IFFALSE 46512
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46431: LD_STRING e
46433: PUSH
46434: LD_VAR 0 1
46438: PPUSH
46439: CALL_OW 437
46443: PUSH
46444: LD_INT 1
46446: ARRAY
46447: PUSH
46448: LD_INT 1
46450: ARRAY
46451: EQUAL
46452: PUSH
46453: LD_VAR 0 4
46457: PUSH
46458: LD_VAR 0 1
46462: PPUSH
46463: CALL_OW 437
46467: PUSH
46468: LD_INT 1
46470: ARRAY
46471: PUSH
46472: LD_INT 2
46474: ARRAY
46475: EQUAL
46476: AND
46477: PUSH
46478: LD_VAR 0 5
46482: PUSH
46483: LD_VAR 0 1
46487: PPUSH
46488: CALL_OW 437
46492: PUSH
46493: LD_INT 1
46495: ARRAY
46496: PUSH
46497: LD_INT 3
46499: ARRAY
46500: EQUAL
46501: AND
46502: IFFALSE 46512
// result := true end ;
46504: LD_ADDR_VAR 0 3
46508: PUSH
46509: LD_INT 1
46511: ST_TO_ADDR
// end ;
46512: LD_VAR 0 3
46516: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46517: LD_INT 0
46519: PPUSH
// result := false ;
46520: LD_ADDR_VAR 0 4
46524: PUSH
46525: LD_INT 0
46527: ST_TO_ADDR
// if GetTaskList ( unit ) then
46528: LD_VAR 0 1
46532: PPUSH
46533: CALL_OW 437
46537: IFFALSE 46620
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46539: LD_STRING M
46541: PUSH
46542: LD_VAR 0 1
46546: PPUSH
46547: CALL_OW 437
46551: PUSH
46552: LD_INT 1
46554: ARRAY
46555: PUSH
46556: LD_INT 1
46558: ARRAY
46559: EQUAL
46560: PUSH
46561: LD_VAR 0 2
46565: PUSH
46566: LD_VAR 0 1
46570: PPUSH
46571: CALL_OW 437
46575: PUSH
46576: LD_INT 1
46578: ARRAY
46579: PUSH
46580: LD_INT 2
46582: ARRAY
46583: EQUAL
46584: AND
46585: PUSH
46586: LD_VAR 0 3
46590: PUSH
46591: LD_VAR 0 1
46595: PPUSH
46596: CALL_OW 437
46600: PUSH
46601: LD_INT 1
46603: ARRAY
46604: PUSH
46605: LD_INT 3
46607: ARRAY
46608: EQUAL
46609: AND
46610: IFFALSE 46620
// result := true ;
46612: LD_ADDR_VAR 0 4
46616: PUSH
46617: LD_INT 1
46619: ST_TO_ADDR
// end ; end ;
46620: LD_VAR 0 4
46624: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46625: LD_INT 0
46627: PPUSH
46628: PPUSH
46629: PPUSH
46630: PPUSH
// if not unit or not area then
46631: LD_VAR 0 1
46635: NOT
46636: PUSH
46637: LD_VAR 0 2
46641: NOT
46642: OR
46643: IFFALSE 46647
// exit ;
46645: GO 46811
// tmp := AreaToList ( area , i ) ;
46647: LD_ADDR_VAR 0 6
46651: PUSH
46652: LD_VAR 0 2
46656: PPUSH
46657: LD_VAR 0 5
46661: PPUSH
46662: CALL_OW 517
46666: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46667: LD_ADDR_VAR 0 5
46671: PUSH
46672: DOUBLE
46673: LD_INT 1
46675: DEC
46676: ST_TO_ADDR
46677: LD_VAR 0 6
46681: PUSH
46682: LD_INT 1
46684: ARRAY
46685: PUSH
46686: FOR_TO
46687: IFFALSE 46809
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46689: LD_ADDR_VAR 0 7
46693: PUSH
46694: LD_VAR 0 6
46698: PUSH
46699: LD_INT 1
46701: ARRAY
46702: PUSH
46703: LD_VAR 0 5
46707: ARRAY
46708: PUSH
46709: LD_VAR 0 6
46713: PUSH
46714: LD_INT 2
46716: ARRAY
46717: PUSH
46718: LD_VAR 0 5
46722: ARRAY
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46728: LD_VAR 0 7
46732: PUSH
46733: LD_INT 1
46735: ARRAY
46736: PPUSH
46737: LD_VAR 0 7
46741: PUSH
46742: LD_INT 2
46744: ARRAY
46745: PPUSH
46746: CALL_OW 428
46750: PUSH
46751: LD_INT 0
46753: EQUAL
46754: IFFALSE 46807
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46756: LD_VAR 0 1
46760: PPUSH
46761: LD_VAR 0 7
46765: PUSH
46766: LD_INT 1
46768: ARRAY
46769: PPUSH
46770: LD_VAR 0 7
46774: PUSH
46775: LD_INT 2
46777: ARRAY
46778: PPUSH
46779: LD_VAR 0 3
46783: PPUSH
46784: CALL_OW 48
// result := IsPlaced ( unit ) ;
46788: LD_ADDR_VAR 0 4
46792: PUSH
46793: LD_VAR 0 1
46797: PPUSH
46798: CALL_OW 305
46802: ST_TO_ADDR
// exit ;
46803: POP
46804: POP
46805: GO 46811
// end ; end ;
46807: GO 46686
46809: POP
46810: POP
// end ;
46811: LD_VAR 0 4
46815: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46816: LD_INT 0
46818: PPUSH
46819: PPUSH
46820: PPUSH
// if not side or side > 8 then
46821: LD_VAR 0 1
46825: NOT
46826: PUSH
46827: LD_VAR 0 1
46831: PUSH
46832: LD_INT 8
46834: GREATER
46835: OR
46836: IFFALSE 46840
// exit ;
46838: GO 47027
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46840: LD_ADDR_VAR 0 4
46844: PUSH
46845: LD_INT 22
46847: PUSH
46848: LD_VAR 0 1
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 21
46859: PUSH
46860: LD_INT 3
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PPUSH
46871: CALL_OW 69
46875: ST_TO_ADDR
// if not tmp then
46876: LD_VAR 0 4
46880: NOT
46881: IFFALSE 46885
// exit ;
46883: GO 47027
// enable_addtolog := true ;
46885: LD_ADDR_OWVAR 81
46889: PUSH
46890: LD_INT 1
46892: ST_TO_ADDR
// AddToLog ( [ ) ;
46893: LD_STRING [
46895: PPUSH
46896: CALL_OW 561
// for i in tmp do
46900: LD_ADDR_VAR 0 3
46904: PUSH
46905: LD_VAR 0 4
46909: PUSH
46910: FOR_IN
46911: IFFALSE 47018
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46913: LD_STRING [
46915: PUSH
46916: LD_VAR 0 3
46920: PPUSH
46921: CALL_OW 266
46925: STR
46926: PUSH
46927: LD_STRING , 
46929: STR
46930: PUSH
46931: LD_VAR 0 3
46935: PPUSH
46936: CALL_OW 250
46940: STR
46941: PUSH
46942: LD_STRING , 
46944: STR
46945: PUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: CALL_OW 251
46955: STR
46956: PUSH
46957: LD_STRING , 
46959: STR
46960: PUSH
46961: LD_VAR 0 3
46965: PPUSH
46966: CALL_OW 254
46970: STR
46971: PUSH
46972: LD_STRING , 
46974: STR
46975: PUSH
46976: LD_VAR 0 3
46980: PPUSH
46981: LD_INT 1
46983: PPUSH
46984: CALL_OW 268
46988: STR
46989: PUSH
46990: LD_STRING , 
46992: STR
46993: PUSH
46994: LD_VAR 0 3
46998: PPUSH
46999: LD_INT 2
47001: PPUSH
47002: CALL_OW 268
47006: STR
47007: PUSH
47008: LD_STRING ],
47010: STR
47011: PPUSH
47012: CALL_OW 561
// end ;
47016: GO 46910
47018: POP
47019: POP
// AddToLog ( ]; ) ;
47020: LD_STRING ];
47022: PPUSH
47023: CALL_OW 561
// end ;
47027: LD_VAR 0 2
47031: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47032: LD_INT 0
47034: PPUSH
47035: PPUSH
47036: PPUSH
47037: PPUSH
47038: PPUSH
// if not area or not rate or not max then
47039: LD_VAR 0 1
47043: NOT
47044: PUSH
47045: LD_VAR 0 2
47049: NOT
47050: OR
47051: PUSH
47052: LD_VAR 0 4
47056: NOT
47057: OR
47058: IFFALSE 47062
// exit ;
47060: GO 47251
// while 1 do
47062: LD_INT 1
47064: IFFALSE 47251
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47066: LD_ADDR_VAR 0 9
47070: PUSH
47071: LD_VAR 0 1
47075: PPUSH
47076: LD_INT 1
47078: PPUSH
47079: CALL_OW 287
47083: PUSH
47084: LD_INT 10
47086: MUL
47087: ST_TO_ADDR
// r := rate / 10 ;
47088: LD_ADDR_VAR 0 7
47092: PUSH
47093: LD_VAR 0 2
47097: PUSH
47098: LD_INT 10
47100: DIVREAL
47101: ST_TO_ADDR
// time := 1 1$00 ;
47102: LD_ADDR_VAR 0 8
47106: PUSH
47107: LD_INT 2100
47109: ST_TO_ADDR
// if amount < min then
47110: LD_VAR 0 9
47114: PUSH
47115: LD_VAR 0 3
47119: LESS
47120: IFFALSE 47138
// r := r * 2 else
47122: LD_ADDR_VAR 0 7
47126: PUSH
47127: LD_VAR 0 7
47131: PUSH
47132: LD_INT 2
47134: MUL
47135: ST_TO_ADDR
47136: GO 47164
// if amount > max then
47138: LD_VAR 0 9
47142: PUSH
47143: LD_VAR 0 4
47147: GREATER
47148: IFFALSE 47164
// r := r / 2 ;
47150: LD_ADDR_VAR 0 7
47154: PUSH
47155: LD_VAR 0 7
47159: PUSH
47160: LD_INT 2
47162: DIVREAL
47163: ST_TO_ADDR
// time := time / r ;
47164: LD_ADDR_VAR 0 8
47168: PUSH
47169: LD_VAR 0 8
47173: PUSH
47174: LD_VAR 0 7
47178: DIVREAL
47179: ST_TO_ADDR
// if time < 0 then
47180: LD_VAR 0 8
47184: PUSH
47185: LD_INT 0
47187: LESS
47188: IFFALSE 47205
// time := time * - 1 ;
47190: LD_ADDR_VAR 0 8
47194: PUSH
47195: LD_VAR 0 8
47199: PUSH
47200: LD_INT 1
47202: NEG
47203: MUL
47204: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47205: LD_VAR 0 8
47209: PUSH
47210: LD_INT 35
47212: PPUSH
47213: LD_INT 875
47215: PPUSH
47216: CALL_OW 12
47220: PLUS
47221: PPUSH
47222: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47226: LD_INT 1
47228: PPUSH
47229: LD_INT 5
47231: PPUSH
47232: CALL_OW 12
47236: PPUSH
47237: LD_VAR 0 1
47241: PPUSH
47242: LD_INT 1
47244: PPUSH
47245: CALL_OW 55
// end ;
47249: GO 47062
// end ;
47251: LD_VAR 0 5
47255: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47256: LD_INT 0
47258: PPUSH
47259: PPUSH
47260: PPUSH
47261: PPUSH
47262: PPUSH
47263: PPUSH
47264: PPUSH
47265: PPUSH
// if not turrets or not factories then
47266: LD_VAR 0 1
47270: NOT
47271: PUSH
47272: LD_VAR 0 2
47276: NOT
47277: OR
47278: IFFALSE 47282
// exit ;
47280: GO 47589
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47282: LD_ADDR_VAR 0 10
47286: PUSH
47287: LD_INT 5
47289: PUSH
47290: LD_INT 6
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: LD_INT 2
47299: PUSH
47300: LD_INT 4
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: PUSH
47307: LD_INT 3
47309: PUSH
47310: LD_INT 5
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: LIST
47321: PUSH
47322: LD_INT 24
47324: PUSH
47325: LD_INT 25
47327: PUSH
47328: EMPTY
47329: LIST
47330: LIST
47331: PUSH
47332: LD_INT 23
47334: PUSH
47335: LD_INT 27
47337: PUSH
47338: EMPTY
47339: LIST
47340: LIST
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 42
47348: PUSH
47349: LD_INT 43
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 44
47358: PUSH
47359: LD_INT 46
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 45
47368: PUSH
47369: LD_INT 47
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: LIST
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: LIST
47385: ST_TO_ADDR
// result := [ ] ;
47386: LD_ADDR_VAR 0 3
47390: PUSH
47391: EMPTY
47392: ST_TO_ADDR
// for i in turrets do
47393: LD_ADDR_VAR 0 4
47397: PUSH
47398: LD_VAR 0 1
47402: PUSH
47403: FOR_IN
47404: IFFALSE 47587
// begin nat := GetNation ( i ) ;
47406: LD_ADDR_VAR 0 7
47410: PUSH
47411: LD_VAR 0 4
47415: PPUSH
47416: CALL_OW 248
47420: ST_TO_ADDR
// weapon := 0 ;
47421: LD_ADDR_VAR 0 8
47425: PUSH
47426: LD_INT 0
47428: ST_TO_ADDR
// if not nat then
47429: LD_VAR 0 7
47433: NOT
47434: IFFALSE 47438
// continue ;
47436: GO 47403
// for j in list [ nat ] do
47438: LD_ADDR_VAR 0 5
47442: PUSH
47443: LD_VAR 0 10
47447: PUSH
47448: LD_VAR 0 7
47452: ARRAY
47453: PUSH
47454: FOR_IN
47455: IFFALSE 47496
// if GetBWeapon ( i ) = j [ 1 ] then
47457: LD_VAR 0 4
47461: PPUSH
47462: CALL_OW 269
47466: PUSH
47467: LD_VAR 0 5
47471: PUSH
47472: LD_INT 1
47474: ARRAY
47475: EQUAL
47476: IFFALSE 47494
// begin weapon := j [ 2 ] ;
47478: LD_ADDR_VAR 0 8
47482: PUSH
47483: LD_VAR 0 5
47487: PUSH
47488: LD_INT 2
47490: ARRAY
47491: ST_TO_ADDR
// break ;
47492: GO 47496
// end ;
47494: GO 47454
47496: POP
47497: POP
// if not weapon then
47498: LD_VAR 0 8
47502: NOT
47503: IFFALSE 47507
// continue ;
47505: GO 47403
// for k in factories do
47507: LD_ADDR_VAR 0 6
47511: PUSH
47512: LD_VAR 0 2
47516: PUSH
47517: FOR_IN
47518: IFFALSE 47583
// begin weapons := AvailableWeaponList ( k ) ;
47520: LD_ADDR_VAR 0 9
47524: PUSH
47525: LD_VAR 0 6
47529: PPUSH
47530: CALL_OW 478
47534: ST_TO_ADDR
// if not weapons then
47535: LD_VAR 0 9
47539: NOT
47540: IFFALSE 47544
// continue ;
47542: GO 47517
// if weapon in weapons then
47544: LD_VAR 0 8
47548: PUSH
47549: LD_VAR 0 9
47553: IN
47554: IFFALSE 47581
// begin result := [ i , weapon ] ;
47556: LD_ADDR_VAR 0 3
47560: PUSH
47561: LD_VAR 0 4
47565: PUSH
47566: LD_VAR 0 8
47570: PUSH
47571: EMPTY
47572: LIST
47573: LIST
47574: ST_TO_ADDR
// exit ;
47575: POP
47576: POP
47577: POP
47578: POP
47579: GO 47589
// end ; end ;
47581: GO 47517
47583: POP
47584: POP
// end ;
47585: GO 47403
47587: POP
47588: POP
// end ;
47589: LD_VAR 0 3
47593: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47594: LD_INT 0
47596: PPUSH
// if not side or side > 8 then
47597: LD_VAR 0 3
47601: NOT
47602: PUSH
47603: LD_VAR 0 3
47607: PUSH
47608: LD_INT 8
47610: GREATER
47611: OR
47612: IFFALSE 47616
// exit ;
47614: GO 47675
// if not range then
47616: LD_VAR 0 4
47620: NOT
47621: IFFALSE 47632
// range := - 12 ;
47623: LD_ADDR_VAR 0 4
47627: PUSH
47628: LD_INT 12
47630: NEG
47631: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47632: LD_VAR 0 1
47636: PPUSH
47637: LD_VAR 0 2
47641: PPUSH
47642: LD_VAR 0 3
47646: PPUSH
47647: LD_VAR 0 4
47651: PPUSH
47652: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47656: LD_VAR 0 1
47660: PPUSH
47661: LD_VAR 0 2
47665: PPUSH
47666: LD_VAR 0 3
47670: PPUSH
47671: CALL_OW 331
// end ;
47675: LD_VAR 0 5
47679: RET
// export function Video ( mode ) ; begin
47680: LD_INT 0
47682: PPUSH
// ingame_video = mode ;
47683: LD_ADDR_OWVAR 52
47687: PUSH
47688: LD_VAR 0 1
47692: ST_TO_ADDR
// interface_hidden = mode ;
47693: LD_ADDR_OWVAR 54
47697: PUSH
47698: LD_VAR 0 1
47702: ST_TO_ADDR
// end ;
47703: LD_VAR 0 2
47707: RET
// export function Join ( array , element ) ; begin
47708: LD_INT 0
47710: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47711: LD_ADDR_VAR 0 3
47715: PUSH
47716: LD_VAR 0 1
47720: PPUSH
47721: LD_VAR 0 1
47725: PUSH
47726: LD_INT 1
47728: PLUS
47729: PPUSH
47730: LD_VAR 0 2
47734: PPUSH
47735: CALL_OW 1
47739: ST_TO_ADDR
// end ;
47740: LD_VAR 0 3
47744: RET
// export function JoinUnion ( array , element ) ; begin
47745: LD_INT 0
47747: PPUSH
// result := array union element ;
47748: LD_ADDR_VAR 0 3
47752: PUSH
47753: LD_VAR 0 1
47757: PUSH
47758: LD_VAR 0 2
47762: UNION
47763: ST_TO_ADDR
// end ;
47764: LD_VAR 0 3
47768: RET
// export function GetBehemoths ( side ) ; begin
47769: LD_INT 0
47771: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
47772: LD_ADDR_VAR 0 2
47776: PUSH
47777: LD_INT 22
47779: PUSH
47780: LD_VAR 0 1
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PUSH
47789: LD_INT 31
47791: PUSH
47792: LD_INT 25
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PPUSH
47803: CALL_OW 69
47807: ST_TO_ADDR
// end ;
47808: LD_VAR 0 2
47812: RET
// export function Shuffle ( array ) ; var i , index ; begin
47813: LD_INT 0
47815: PPUSH
47816: PPUSH
47817: PPUSH
// result := [ ] ;
47818: LD_ADDR_VAR 0 2
47822: PUSH
47823: EMPTY
47824: ST_TO_ADDR
// if not array then
47825: LD_VAR 0 1
47829: NOT
47830: IFFALSE 47834
// exit ;
47832: GO 47933
// Randomize ;
47834: CALL_OW 10
// for i = array downto 1 do
47838: LD_ADDR_VAR 0 3
47842: PUSH
47843: DOUBLE
47844: LD_VAR 0 1
47848: INC
47849: ST_TO_ADDR
47850: LD_INT 1
47852: PUSH
47853: FOR_DOWNTO
47854: IFFALSE 47931
// begin index := rand ( 1 , array ) ;
47856: LD_ADDR_VAR 0 4
47860: PUSH
47861: LD_INT 1
47863: PPUSH
47864: LD_VAR 0 1
47868: PPUSH
47869: CALL_OW 12
47873: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47874: LD_ADDR_VAR 0 2
47878: PUSH
47879: LD_VAR 0 2
47883: PPUSH
47884: LD_VAR 0 2
47888: PUSH
47889: LD_INT 1
47891: PLUS
47892: PPUSH
47893: LD_VAR 0 1
47897: PUSH
47898: LD_VAR 0 4
47902: ARRAY
47903: PPUSH
47904: CALL_OW 2
47908: ST_TO_ADDR
// array := Delete ( array , index ) ;
47909: LD_ADDR_VAR 0 1
47913: PUSH
47914: LD_VAR 0 1
47918: PPUSH
47919: LD_VAR 0 4
47923: PPUSH
47924: CALL_OW 3
47928: ST_TO_ADDR
// end ;
47929: GO 47853
47931: POP
47932: POP
// end ;
47933: LD_VAR 0 2
47937: RET
// export function GetBaseMaterials ( base ) ; begin
47938: LD_INT 0
47940: PPUSH
// result := [ 0 , 0 , 0 ] ;
47941: LD_ADDR_VAR 0 2
47945: PUSH
47946: LD_INT 0
47948: PUSH
47949: LD_INT 0
47951: PUSH
47952: LD_INT 0
47954: PUSH
47955: EMPTY
47956: LIST
47957: LIST
47958: LIST
47959: ST_TO_ADDR
// if not base then
47960: LD_VAR 0 1
47964: NOT
47965: IFFALSE 47969
// exit ;
47967: GO 48018
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47969: LD_ADDR_VAR 0 2
47973: PUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: LD_INT 1
47981: PPUSH
47982: CALL_OW 275
47986: PUSH
47987: LD_VAR 0 1
47991: PPUSH
47992: LD_INT 2
47994: PPUSH
47995: CALL_OW 275
47999: PUSH
48000: LD_VAR 0 1
48004: PPUSH
48005: LD_INT 3
48007: PPUSH
48008: CALL_OW 275
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: LIST
48017: ST_TO_ADDR
// end ;
48018: LD_VAR 0 2
48022: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48023: LD_INT 0
48025: PPUSH
48026: PPUSH
// result := array ;
48027: LD_ADDR_VAR 0 3
48031: PUSH
48032: LD_VAR 0 1
48036: ST_TO_ADDR
// if size > 0 then
48037: LD_VAR 0 2
48041: PUSH
48042: LD_INT 0
48044: GREATER
48045: IFFALSE 48091
// for i := array downto size do
48047: LD_ADDR_VAR 0 4
48051: PUSH
48052: DOUBLE
48053: LD_VAR 0 1
48057: INC
48058: ST_TO_ADDR
48059: LD_VAR 0 2
48063: PUSH
48064: FOR_DOWNTO
48065: IFFALSE 48089
// result := Delete ( result , result ) ;
48067: LD_ADDR_VAR 0 3
48071: PUSH
48072: LD_VAR 0 3
48076: PPUSH
48077: LD_VAR 0 3
48081: PPUSH
48082: CALL_OW 3
48086: ST_TO_ADDR
48087: GO 48064
48089: POP
48090: POP
// end ;
48091: LD_VAR 0 3
48095: RET
// export function ComExit ( unit ) ; var tmp ; begin
48096: LD_INT 0
48098: PPUSH
48099: PPUSH
// if not IsInUnit ( unit ) then
48100: LD_VAR 0 1
48104: PPUSH
48105: CALL_OW 310
48109: NOT
48110: IFFALSE 48114
// exit ;
48112: GO 48174
// tmp := IsInUnit ( unit ) ;
48114: LD_ADDR_VAR 0 3
48118: PUSH
48119: LD_VAR 0 1
48123: PPUSH
48124: CALL_OW 310
48128: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48129: LD_VAR 0 3
48133: PPUSH
48134: CALL_OW 247
48138: PUSH
48139: LD_INT 2
48141: EQUAL
48142: IFFALSE 48155
// ComExitVehicle ( unit ) else
48144: LD_VAR 0 1
48148: PPUSH
48149: CALL_OW 121
48153: GO 48164
// ComExitBuilding ( unit ) ;
48155: LD_VAR 0 1
48159: PPUSH
48160: CALL_OW 122
// result := tmp ;
48164: LD_ADDR_VAR 0 2
48168: PUSH
48169: LD_VAR 0 3
48173: ST_TO_ADDR
// end ;
48174: LD_VAR 0 2
48178: RET
// export function ComExitAll ( units ) ; var i ; begin
48179: LD_INT 0
48181: PPUSH
48182: PPUSH
// if not units then
48183: LD_VAR 0 1
48187: NOT
48188: IFFALSE 48192
// exit ;
48190: GO 48218
// for i in units do
48192: LD_ADDR_VAR 0 3
48196: PUSH
48197: LD_VAR 0 1
48201: PUSH
48202: FOR_IN
48203: IFFALSE 48216
// ComExit ( i ) ;
48205: LD_VAR 0 3
48209: PPUSH
48210: CALL 48096 0 1
48214: GO 48202
48216: POP
48217: POP
// end ;
48218: LD_VAR 0 2
48222: RET
// export function ResetHc ; begin
48223: LD_INT 0
48225: PPUSH
// InitHc ;
48226: CALL_OW 19
// hc_importance := 0 ;
48230: LD_ADDR_OWVAR 32
48234: PUSH
48235: LD_INT 0
48237: ST_TO_ADDR
// end ;
48238: LD_VAR 0 1
48242: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48243: LD_INT 0
48245: PPUSH
48246: PPUSH
48247: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48248: LD_ADDR_VAR 0 6
48252: PUSH
48253: LD_VAR 0 1
48257: PUSH
48258: LD_VAR 0 3
48262: PLUS
48263: PUSH
48264: LD_INT 2
48266: DIV
48267: ST_TO_ADDR
// if _x < 0 then
48268: LD_VAR 0 6
48272: PUSH
48273: LD_INT 0
48275: LESS
48276: IFFALSE 48293
// _x := _x * - 1 ;
48278: LD_ADDR_VAR 0 6
48282: PUSH
48283: LD_VAR 0 6
48287: PUSH
48288: LD_INT 1
48290: NEG
48291: MUL
48292: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48293: LD_ADDR_VAR 0 7
48297: PUSH
48298: LD_VAR 0 2
48302: PUSH
48303: LD_VAR 0 4
48307: PLUS
48308: PUSH
48309: LD_INT 2
48311: DIV
48312: ST_TO_ADDR
// if _y < 0 then
48313: LD_VAR 0 7
48317: PUSH
48318: LD_INT 0
48320: LESS
48321: IFFALSE 48338
// _y := _y * - 1 ;
48323: LD_ADDR_VAR 0 7
48327: PUSH
48328: LD_VAR 0 7
48332: PUSH
48333: LD_INT 1
48335: NEG
48336: MUL
48337: ST_TO_ADDR
// result := [ _x , _y ] ;
48338: LD_ADDR_VAR 0 5
48342: PUSH
48343: LD_VAR 0 6
48347: PUSH
48348: LD_VAR 0 7
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: ST_TO_ADDR
// end ;
48357: LD_VAR 0 5
48361: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48362: LD_INT 0
48364: PPUSH
48365: PPUSH
48366: PPUSH
48367: PPUSH
// task := GetTaskList ( unit ) ;
48368: LD_ADDR_VAR 0 7
48372: PUSH
48373: LD_VAR 0 1
48377: PPUSH
48378: CALL_OW 437
48382: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48383: LD_VAR 0 7
48387: NOT
48388: PUSH
48389: LD_VAR 0 1
48393: PPUSH
48394: LD_VAR 0 2
48398: PPUSH
48399: CALL_OW 308
48403: NOT
48404: AND
48405: IFFALSE 48409
// exit ;
48407: GO 48527
// if IsInArea ( unit , area ) then
48409: LD_VAR 0 1
48413: PPUSH
48414: LD_VAR 0 2
48418: PPUSH
48419: CALL_OW 308
48423: IFFALSE 48441
// begin ComMoveToArea ( unit , goAway ) ;
48425: LD_VAR 0 1
48429: PPUSH
48430: LD_VAR 0 3
48434: PPUSH
48435: CALL_OW 113
// exit ;
48439: GO 48527
// end ; if task [ 1 ] [ 1 ] <> M then
48441: LD_VAR 0 7
48445: PUSH
48446: LD_INT 1
48448: ARRAY
48449: PUSH
48450: LD_INT 1
48452: ARRAY
48453: PUSH
48454: LD_STRING M
48456: NONEQUAL
48457: IFFALSE 48461
// exit ;
48459: GO 48527
// x := task [ 1 ] [ 2 ] ;
48461: LD_ADDR_VAR 0 5
48465: PUSH
48466: LD_VAR 0 7
48470: PUSH
48471: LD_INT 1
48473: ARRAY
48474: PUSH
48475: LD_INT 2
48477: ARRAY
48478: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48479: LD_ADDR_VAR 0 6
48483: PUSH
48484: LD_VAR 0 7
48488: PUSH
48489: LD_INT 1
48491: ARRAY
48492: PUSH
48493: LD_INT 3
48495: ARRAY
48496: ST_TO_ADDR
// if InArea ( x , y , area ) then
48497: LD_VAR 0 5
48501: PPUSH
48502: LD_VAR 0 6
48506: PPUSH
48507: LD_VAR 0 2
48511: PPUSH
48512: CALL_OW 309
48516: IFFALSE 48527
// ComStop ( unit ) ;
48518: LD_VAR 0 1
48522: PPUSH
48523: CALL_OW 141
// end ;
48527: LD_VAR 0 4
48531: RET
// export function Abs ( value ) ; begin
48532: LD_INT 0
48534: PPUSH
// result := value ;
48535: LD_ADDR_VAR 0 2
48539: PUSH
48540: LD_VAR 0 1
48544: ST_TO_ADDR
// if value < 0 then
48545: LD_VAR 0 1
48549: PUSH
48550: LD_INT 0
48552: LESS
48553: IFFALSE 48570
// result := value * - 1 ;
48555: LD_ADDR_VAR 0 2
48559: PUSH
48560: LD_VAR 0 1
48564: PUSH
48565: LD_INT 1
48567: NEG
48568: MUL
48569: ST_TO_ADDR
// end ;
48570: LD_VAR 0 2
48574: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48575: LD_INT 0
48577: PPUSH
48578: PPUSH
48579: PPUSH
48580: PPUSH
48581: PPUSH
48582: PPUSH
48583: PPUSH
48584: PPUSH
// if not unit or not building then
48585: LD_VAR 0 1
48589: NOT
48590: PUSH
48591: LD_VAR 0 2
48595: NOT
48596: OR
48597: IFFALSE 48601
// exit ;
48599: GO 48827
// x := GetX ( building ) ;
48601: LD_ADDR_VAR 0 4
48605: PUSH
48606: LD_VAR 0 2
48610: PPUSH
48611: CALL_OW 250
48615: ST_TO_ADDR
// y := GetY ( building ) ;
48616: LD_ADDR_VAR 0 6
48620: PUSH
48621: LD_VAR 0 2
48625: PPUSH
48626: CALL_OW 251
48630: ST_TO_ADDR
// d := GetDir ( building ) ;
48631: LD_ADDR_VAR 0 8
48635: PUSH
48636: LD_VAR 0 2
48640: PPUSH
48641: CALL_OW 254
48645: ST_TO_ADDR
// r := 4 ;
48646: LD_ADDR_VAR 0 9
48650: PUSH
48651: LD_INT 4
48653: ST_TO_ADDR
// for i := 1 to 5 do
48654: LD_ADDR_VAR 0 10
48658: PUSH
48659: DOUBLE
48660: LD_INT 1
48662: DEC
48663: ST_TO_ADDR
48664: LD_INT 5
48666: PUSH
48667: FOR_TO
48668: IFFALSE 48825
// begin _x := ShiftX ( x , d , r + i ) ;
48670: LD_ADDR_VAR 0 5
48674: PUSH
48675: LD_VAR 0 4
48679: PPUSH
48680: LD_VAR 0 8
48684: PPUSH
48685: LD_VAR 0 9
48689: PUSH
48690: LD_VAR 0 10
48694: PLUS
48695: PPUSH
48696: CALL_OW 272
48700: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48701: LD_ADDR_VAR 0 7
48705: PUSH
48706: LD_VAR 0 6
48710: PPUSH
48711: LD_VAR 0 8
48715: PPUSH
48716: LD_VAR 0 9
48720: PUSH
48721: LD_VAR 0 10
48725: PLUS
48726: PPUSH
48727: CALL_OW 273
48731: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48732: LD_VAR 0 5
48736: PPUSH
48737: LD_VAR 0 7
48741: PPUSH
48742: CALL_OW 488
48746: PUSH
48747: LD_VAR 0 5
48751: PPUSH
48752: LD_VAR 0 7
48756: PPUSH
48757: CALL_OW 428
48761: PPUSH
48762: CALL_OW 247
48766: PUSH
48767: LD_INT 3
48769: PUSH
48770: LD_INT 2
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: IN
48777: NOT
48778: AND
48779: IFFALSE 48823
// begin ComMoveXY ( unit , _x , _y ) ;
48781: LD_VAR 0 1
48785: PPUSH
48786: LD_VAR 0 5
48790: PPUSH
48791: LD_VAR 0 7
48795: PPUSH
48796: CALL_OW 111
// result := [ _x , _y ] ;
48800: LD_ADDR_VAR 0 3
48804: PUSH
48805: LD_VAR 0 5
48809: PUSH
48810: LD_VAR 0 7
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: ST_TO_ADDR
// exit ;
48819: POP
48820: POP
48821: GO 48827
// end ; end ;
48823: GO 48667
48825: POP
48826: POP
// end ;
48827: LD_VAR 0 3
48831: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48832: LD_INT 0
48834: PPUSH
48835: PPUSH
48836: PPUSH
// result := 0 ;
48837: LD_ADDR_VAR 0 3
48841: PUSH
48842: LD_INT 0
48844: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48845: LD_VAR 0 1
48849: PUSH
48850: LD_INT 0
48852: LESS
48853: PUSH
48854: LD_VAR 0 1
48858: PUSH
48859: LD_INT 8
48861: GREATER
48862: OR
48863: PUSH
48864: LD_VAR 0 2
48868: PUSH
48869: LD_INT 0
48871: LESS
48872: OR
48873: PUSH
48874: LD_VAR 0 2
48878: PUSH
48879: LD_INT 8
48881: GREATER
48882: OR
48883: IFFALSE 48887
// exit ;
48885: GO 48962
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48887: LD_ADDR_VAR 0 4
48891: PUSH
48892: LD_INT 22
48894: PUSH
48895: LD_VAR 0 2
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PPUSH
48904: CALL_OW 69
48908: PUSH
48909: FOR_IN
48910: IFFALSE 48960
// begin un := UnitShoot ( i ) ;
48912: LD_ADDR_VAR 0 5
48916: PUSH
48917: LD_VAR 0 4
48921: PPUSH
48922: CALL_OW 504
48926: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48927: LD_VAR 0 5
48931: PPUSH
48932: CALL_OW 255
48936: PUSH
48937: LD_VAR 0 1
48941: EQUAL
48942: IFFALSE 48958
// begin result := un ;
48944: LD_ADDR_VAR 0 3
48948: PUSH
48949: LD_VAR 0 5
48953: ST_TO_ADDR
// exit ;
48954: POP
48955: POP
48956: GO 48962
// end ; end ;
48958: GO 48909
48960: POP
48961: POP
// end ;
48962: LD_VAR 0 3
48966: RET
// export function GetCargoBay ( units ) ; begin
48967: LD_INT 0
48969: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48970: LD_ADDR_VAR 0 2
48974: PUSH
48975: LD_VAR 0 1
48979: PPUSH
48980: LD_INT 2
48982: PUSH
48983: LD_INT 34
48985: PUSH
48986: LD_INT 12
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 34
48995: PUSH
48996: LD_INT 51
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 34
49005: PUSH
49006: LD_INT 32
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: LD_INT 34
49015: PUSH
49016: LD_EXP 68
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: EMPTY
49026: LIST
49027: LIST
49028: LIST
49029: LIST
49030: LIST
49031: PPUSH
49032: CALL_OW 72
49036: ST_TO_ADDR
// end ;
49037: LD_VAR 0 2
49041: RET
// export function Negate ( value ) ; begin
49042: LD_INT 0
49044: PPUSH
// result := not value ;
49045: LD_ADDR_VAR 0 2
49049: PUSH
49050: LD_VAR 0 1
49054: NOT
49055: ST_TO_ADDR
// end ;
49056: LD_VAR 0 2
49060: RET
// export function Inc ( value ) ; begin
49061: LD_INT 0
49063: PPUSH
// result := value + 1 ;
49064: LD_ADDR_VAR 0 2
49068: PUSH
49069: LD_VAR 0 1
49073: PUSH
49074: LD_INT 1
49076: PLUS
49077: ST_TO_ADDR
// end ;
49078: LD_VAR 0 2
49082: RET
// export function Dec ( value ) ; begin
49083: LD_INT 0
49085: PPUSH
// result := value - 1 ;
49086: LD_ADDR_VAR 0 2
49090: PUSH
49091: LD_VAR 0 1
49095: PUSH
49096: LD_INT 1
49098: MINUS
49099: ST_TO_ADDR
// end ;
49100: LD_VAR 0 2
49104: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49105: LD_INT 0
49107: PPUSH
49108: PPUSH
49109: PPUSH
49110: PPUSH
49111: PPUSH
49112: PPUSH
49113: PPUSH
49114: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49115: LD_VAR 0 1
49119: PPUSH
49120: LD_VAR 0 2
49124: PPUSH
49125: CALL_OW 488
49129: NOT
49130: PUSH
49131: LD_VAR 0 3
49135: PPUSH
49136: LD_VAR 0 4
49140: PPUSH
49141: CALL_OW 488
49145: NOT
49146: OR
49147: IFFALSE 49160
// begin result := - 1 ;
49149: LD_ADDR_VAR 0 5
49153: PUSH
49154: LD_INT 1
49156: NEG
49157: ST_TO_ADDR
// exit ;
49158: GO 49395
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49160: LD_ADDR_VAR 0 12
49164: PUSH
49165: LD_VAR 0 1
49169: PPUSH
49170: LD_VAR 0 2
49174: PPUSH
49175: LD_VAR 0 3
49179: PPUSH
49180: LD_VAR 0 4
49184: PPUSH
49185: CALL 48243 0 4
49189: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49190: LD_ADDR_VAR 0 11
49194: PUSH
49195: LD_VAR 0 1
49199: PPUSH
49200: LD_VAR 0 2
49204: PPUSH
49205: LD_VAR 0 12
49209: PUSH
49210: LD_INT 1
49212: ARRAY
49213: PPUSH
49214: LD_VAR 0 12
49218: PUSH
49219: LD_INT 2
49221: ARRAY
49222: PPUSH
49223: CALL_OW 298
49227: ST_TO_ADDR
// distance := 9999 ;
49228: LD_ADDR_VAR 0 10
49232: PUSH
49233: LD_INT 9999
49235: ST_TO_ADDR
// for i := 0 to 5 do
49236: LD_ADDR_VAR 0 6
49240: PUSH
49241: DOUBLE
49242: LD_INT 0
49244: DEC
49245: ST_TO_ADDR
49246: LD_INT 5
49248: PUSH
49249: FOR_TO
49250: IFFALSE 49393
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49252: LD_ADDR_VAR 0 7
49256: PUSH
49257: LD_VAR 0 1
49261: PPUSH
49262: LD_VAR 0 6
49266: PPUSH
49267: LD_VAR 0 11
49271: PPUSH
49272: CALL_OW 272
49276: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
49277: LD_ADDR_VAR 0 8
49281: PUSH
49282: LD_VAR 0 2
49286: PPUSH
49287: LD_VAR 0 6
49291: PPUSH
49292: LD_VAR 0 11
49296: PPUSH
49297: CALL_OW 273
49301: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49302: LD_VAR 0 7
49306: PPUSH
49307: LD_VAR 0 8
49311: PPUSH
49312: CALL_OW 488
49316: NOT
49317: IFFALSE 49321
// continue ;
49319: GO 49249
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
49321: LD_ADDR_VAR 0 9
49325: PUSH
49326: LD_VAR 0 12
49330: PUSH
49331: LD_INT 1
49333: ARRAY
49334: PPUSH
49335: LD_VAR 0 12
49339: PUSH
49340: LD_INT 2
49342: ARRAY
49343: PPUSH
49344: LD_VAR 0 7
49348: PPUSH
49349: LD_VAR 0 8
49353: PPUSH
49354: CALL_OW 298
49358: ST_TO_ADDR
// if tmp < distance then
49359: LD_VAR 0 9
49363: PUSH
49364: LD_VAR 0 10
49368: LESS
49369: IFFALSE 49391
// begin result := i ;
49371: LD_ADDR_VAR 0 5
49375: PUSH
49376: LD_VAR 0 6
49380: ST_TO_ADDR
// distance := tmp ;
49381: LD_ADDR_VAR 0 10
49385: PUSH
49386: LD_VAR 0 9
49390: ST_TO_ADDR
// end ; end ;
49391: GO 49249
49393: POP
49394: POP
// end ;
49395: LD_VAR 0 5
49399: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49400: LD_INT 0
49402: PPUSH
49403: PPUSH
// if not driver or not IsInUnit ( driver ) then
49404: LD_VAR 0 1
49408: NOT
49409: PUSH
49410: LD_VAR 0 1
49414: PPUSH
49415: CALL_OW 310
49419: NOT
49420: OR
49421: IFFALSE 49425
// exit ;
49423: GO 49515
// vehicle := IsInUnit ( driver ) ;
49425: LD_ADDR_VAR 0 3
49429: PUSH
49430: LD_VAR 0 1
49434: PPUSH
49435: CALL_OW 310
49439: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49440: LD_VAR 0 1
49444: PPUSH
49445: LD_STRING \
49447: PUSH
49448: LD_INT 0
49450: PUSH
49451: LD_INT 0
49453: PUSH
49454: LD_INT 0
49456: PUSH
49457: LD_INT 0
49459: PUSH
49460: LD_INT 0
49462: PUSH
49463: LD_INT 0
49465: PUSH
49466: EMPTY
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: PUSH
49475: LD_STRING E
49477: PUSH
49478: LD_INT 0
49480: PUSH
49481: LD_INT 0
49483: PUSH
49484: LD_VAR 0 3
49488: PUSH
49489: LD_INT 0
49491: PUSH
49492: LD_INT 0
49494: PUSH
49495: LD_INT 0
49497: PUSH
49498: EMPTY
49499: LIST
49500: LIST
49501: LIST
49502: LIST
49503: LIST
49504: LIST
49505: LIST
49506: PUSH
49507: EMPTY
49508: LIST
49509: LIST
49510: PPUSH
49511: CALL_OW 446
// end ;
49515: LD_VAR 0 2
49519: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49520: LD_INT 0
49522: PPUSH
49523: PPUSH
// if not driver or not IsInUnit ( driver ) then
49524: LD_VAR 0 1
49528: NOT
49529: PUSH
49530: LD_VAR 0 1
49534: PPUSH
49535: CALL_OW 310
49539: NOT
49540: OR
49541: IFFALSE 49545
// exit ;
49543: GO 49635
// vehicle := IsInUnit ( driver ) ;
49545: LD_ADDR_VAR 0 3
49549: PUSH
49550: LD_VAR 0 1
49554: PPUSH
49555: CALL_OW 310
49559: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49560: LD_VAR 0 1
49564: PPUSH
49565: LD_STRING \
49567: PUSH
49568: LD_INT 0
49570: PUSH
49571: LD_INT 0
49573: PUSH
49574: LD_INT 0
49576: PUSH
49577: LD_INT 0
49579: PUSH
49580: LD_INT 0
49582: PUSH
49583: LD_INT 0
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: LIST
49590: LIST
49591: LIST
49592: LIST
49593: LIST
49594: PUSH
49595: LD_STRING E
49597: PUSH
49598: LD_INT 0
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: LD_VAR 0 3
49608: PUSH
49609: LD_INT 0
49611: PUSH
49612: LD_INT 0
49614: PUSH
49615: LD_INT 0
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: PPUSH
49631: CALL_OW 447
// end ;
49635: LD_VAR 0 2
49639: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49640: LD_INT 0
49642: PPUSH
49643: PPUSH
49644: PPUSH
// tmp := [ ] ;
49645: LD_ADDR_VAR 0 5
49649: PUSH
49650: EMPTY
49651: ST_TO_ADDR
// for i in units do
49652: LD_ADDR_VAR 0 4
49656: PUSH
49657: LD_VAR 0 1
49661: PUSH
49662: FOR_IN
49663: IFFALSE 49701
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49665: LD_ADDR_VAR 0 5
49669: PUSH
49670: LD_VAR 0 5
49674: PPUSH
49675: LD_VAR 0 5
49679: PUSH
49680: LD_INT 1
49682: PLUS
49683: PPUSH
49684: LD_VAR 0 4
49688: PPUSH
49689: CALL_OW 256
49693: PPUSH
49694: CALL_OW 2
49698: ST_TO_ADDR
49699: GO 49662
49701: POP
49702: POP
// if not tmp then
49703: LD_VAR 0 5
49707: NOT
49708: IFFALSE 49712
// exit ;
49710: GO 49760
// if asc then
49712: LD_VAR 0 2
49716: IFFALSE 49740
// result := SortListByListAsc ( units , tmp ) else
49718: LD_ADDR_VAR 0 3
49722: PUSH
49723: LD_VAR 0 1
49727: PPUSH
49728: LD_VAR 0 5
49732: PPUSH
49733: CALL_OW 76
49737: ST_TO_ADDR
49738: GO 49760
// result := SortListByListDesc ( units , tmp ) ;
49740: LD_ADDR_VAR 0 3
49744: PUSH
49745: LD_VAR 0 1
49749: PPUSH
49750: LD_VAR 0 5
49754: PPUSH
49755: CALL_OW 77
49759: ST_TO_ADDR
// end ;
49760: LD_VAR 0 3
49764: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49765: LD_INT 0
49767: PPUSH
49768: PPUSH
// task := GetTaskList ( mech ) ;
49769: LD_ADDR_VAR 0 4
49773: PUSH
49774: LD_VAR 0 1
49778: PPUSH
49779: CALL_OW 437
49783: ST_TO_ADDR
// if not task then
49784: LD_VAR 0 4
49788: NOT
49789: IFFALSE 49793
// exit ;
49791: GO 49835
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49793: LD_ADDR_VAR 0 3
49797: PUSH
49798: LD_VAR 0 4
49802: PUSH
49803: LD_INT 1
49805: ARRAY
49806: PUSH
49807: LD_INT 1
49809: ARRAY
49810: PUSH
49811: LD_STRING r
49813: EQUAL
49814: PUSH
49815: LD_VAR 0 4
49819: PUSH
49820: LD_INT 1
49822: ARRAY
49823: PUSH
49824: LD_INT 4
49826: ARRAY
49827: PUSH
49828: LD_VAR 0 2
49832: EQUAL
49833: AND
49834: ST_TO_ADDR
// end ;
49835: LD_VAR 0 3
49839: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49840: LD_INT 0
49842: PPUSH
// SetDir ( unit , d ) ;
49843: LD_VAR 0 1
49847: PPUSH
49848: LD_VAR 0 4
49852: PPUSH
49853: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49857: LD_VAR 0 1
49861: PPUSH
49862: LD_VAR 0 2
49866: PPUSH
49867: LD_VAR 0 3
49871: PPUSH
49872: LD_VAR 0 5
49876: PPUSH
49877: CALL_OW 48
// end ;
49881: LD_VAR 0 6
49885: RET
// export function ToNaturalNumber ( number ) ; begin
49886: LD_INT 0
49888: PPUSH
// result := number div 1 ;
49889: LD_ADDR_VAR 0 2
49893: PUSH
49894: LD_VAR 0 1
49898: PUSH
49899: LD_INT 1
49901: DIV
49902: ST_TO_ADDR
// if number < 0 then
49903: LD_VAR 0 1
49907: PUSH
49908: LD_INT 0
49910: LESS
49911: IFFALSE 49921
// result := 0 ;
49913: LD_ADDR_VAR 0 2
49917: PUSH
49918: LD_INT 0
49920: ST_TO_ADDR
// end ;
49921: LD_VAR 0 2
49925: RET
// export function SortByClass ( units , class ) ; var un ; begin
49926: LD_INT 0
49928: PPUSH
49929: PPUSH
// if not units or not class then
49930: LD_VAR 0 1
49934: NOT
49935: PUSH
49936: LD_VAR 0 2
49940: NOT
49941: OR
49942: IFFALSE 49946
// exit ;
49944: GO 50041
// result := [ ] ;
49946: LD_ADDR_VAR 0 3
49950: PUSH
49951: EMPTY
49952: ST_TO_ADDR
// for un in units do
49953: LD_ADDR_VAR 0 4
49957: PUSH
49958: LD_VAR 0 1
49962: PUSH
49963: FOR_IN
49964: IFFALSE 50039
// if GetClass ( un ) = class then
49966: LD_VAR 0 4
49970: PPUSH
49971: CALL_OW 257
49975: PUSH
49976: LD_VAR 0 2
49980: EQUAL
49981: IFFALSE 50008
// result := Insert ( result , 1 , un ) else
49983: LD_ADDR_VAR 0 3
49987: PUSH
49988: LD_VAR 0 3
49992: PPUSH
49993: LD_INT 1
49995: PPUSH
49996: LD_VAR 0 4
50000: PPUSH
50001: CALL_OW 2
50005: ST_TO_ADDR
50006: GO 50037
// result := Replace ( result , result + 1 , un ) ;
50008: LD_ADDR_VAR 0 3
50012: PUSH
50013: LD_VAR 0 3
50017: PPUSH
50018: LD_VAR 0 3
50022: PUSH
50023: LD_INT 1
50025: PLUS
50026: PPUSH
50027: LD_VAR 0 4
50031: PPUSH
50032: CALL_OW 1
50036: ST_TO_ADDR
50037: GO 49963
50039: POP
50040: POP
// end ;
50041: LD_VAR 0 3
50045: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50046: LD_INT 0
50048: PPUSH
50049: PPUSH
50050: PPUSH
50051: PPUSH
50052: PPUSH
50053: PPUSH
50054: PPUSH
// result := [ ] ;
50055: LD_ADDR_VAR 0 4
50059: PUSH
50060: EMPTY
50061: ST_TO_ADDR
// if x - r < 0 then
50062: LD_VAR 0 1
50066: PUSH
50067: LD_VAR 0 3
50071: MINUS
50072: PUSH
50073: LD_INT 0
50075: LESS
50076: IFFALSE 50088
// min_x := 0 else
50078: LD_ADDR_VAR 0 8
50082: PUSH
50083: LD_INT 0
50085: ST_TO_ADDR
50086: GO 50104
// min_x := x - r ;
50088: LD_ADDR_VAR 0 8
50092: PUSH
50093: LD_VAR 0 1
50097: PUSH
50098: LD_VAR 0 3
50102: MINUS
50103: ST_TO_ADDR
// if y - r < 0 then
50104: LD_VAR 0 2
50108: PUSH
50109: LD_VAR 0 3
50113: MINUS
50114: PUSH
50115: LD_INT 0
50117: LESS
50118: IFFALSE 50130
// min_y := 0 else
50120: LD_ADDR_VAR 0 7
50124: PUSH
50125: LD_INT 0
50127: ST_TO_ADDR
50128: GO 50146
// min_y := y - r ;
50130: LD_ADDR_VAR 0 7
50134: PUSH
50135: LD_VAR 0 2
50139: PUSH
50140: LD_VAR 0 3
50144: MINUS
50145: ST_TO_ADDR
// max_x := x + r ;
50146: LD_ADDR_VAR 0 9
50150: PUSH
50151: LD_VAR 0 1
50155: PUSH
50156: LD_VAR 0 3
50160: PLUS
50161: ST_TO_ADDR
// max_y := y + r ;
50162: LD_ADDR_VAR 0 10
50166: PUSH
50167: LD_VAR 0 2
50171: PUSH
50172: LD_VAR 0 3
50176: PLUS
50177: ST_TO_ADDR
// for _x = min_x to max_x do
50178: LD_ADDR_VAR 0 5
50182: PUSH
50183: DOUBLE
50184: LD_VAR 0 8
50188: DEC
50189: ST_TO_ADDR
50190: LD_VAR 0 9
50194: PUSH
50195: FOR_TO
50196: IFFALSE 50297
// for _y = min_y to max_y do
50198: LD_ADDR_VAR 0 6
50202: PUSH
50203: DOUBLE
50204: LD_VAR 0 7
50208: DEC
50209: ST_TO_ADDR
50210: LD_VAR 0 10
50214: PUSH
50215: FOR_TO
50216: IFFALSE 50293
// begin if not ValidHex ( _x , _y ) then
50218: LD_VAR 0 5
50222: PPUSH
50223: LD_VAR 0 6
50227: PPUSH
50228: CALL_OW 488
50232: NOT
50233: IFFALSE 50237
// continue ;
50235: GO 50215
// if GetResourceTypeXY ( _x , _y ) then
50237: LD_VAR 0 5
50241: PPUSH
50242: LD_VAR 0 6
50246: PPUSH
50247: CALL_OW 283
50251: IFFALSE 50291
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50253: LD_ADDR_VAR 0 4
50257: PUSH
50258: LD_VAR 0 4
50262: PPUSH
50263: LD_VAR 0 4
50267: PUSH
50268: LD_INT 1
50270: PLUS
50271: PPUSH
50272: LD_VAR 0 5
50276: PUSH
50277: LD_VAR 0 6
50281: PUSH
50282: EMPTY
50283: LIST
50284: LIST
50285: PPUSH
50286: CALL_OW 1
50290: ST_TO_ADDR
// end ;
50291: GO 50215
50293: POP
50294: POP
50295: GO 50195
50297: POP
50298: POP
// end ;
50299: LD_VAR 0 4
50303: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
50304: LD_INT 0
50306: PPUSH
50307: PPUSH
50308: PPUSH
50309: PPUSH
50310: PPUSH
50311: PPUSH
50312: PPUSH
50313: PPUSH
// if not units then
50314: LD_VAR 0 1
50318: NOT
50319: IFFALSE 50323
// exit ;
50321: GO 50748
// result := UnitFilter ( units , [ f_ok ] ) ;
50323: LD_ADDR_VAR 0 3
50327: PUSH
50328: LD_VAR 0 1
50332: PPUSH
50333: LD_INT 50
50335: PUSH
50336: EMPTY
50337: LIST
50338: PPUSH
50339: CALL_OW 72
50343: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
50344: LD_ADDR_VAR 0 8
50348: PUSH
50349: LD_VAR 0 1
50353: PUSH
50354: LD_INT 1
50356: ARRAY
50357: PPUSH
50358: CALL_OW 255
50362: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
50363: LD_ADDR_VAR 0 10
50367: PUSH
50368: LD_INT 29
50370: PUSH
50371: LD_EXP 71
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: ST_TO_ADDR
// if not result then
50380: LD_VAR 0 3
50384: NOT
50385: IFFALSE 50389
// exit ;
50387: GO 50748
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50389: LD_ADDR_VAR 0 5
50393: PUSH
50394: LD_INT 81
50396: PUSH
50397: LD_VAR 0 8
50401: PUSH
50402: EMPTY
50403: LIST
50404: LIST
50405: PPUSH
50406: CALL_OW 69
50410: ST_TO_ADDR
// for i in result do
50411: LD_ADDR_VAR 0 4
50415: PUSH
50416: LD_VAR 0 3
50420: PUSH
50421: FOR_IN
50422: IFFALSE 50746
// begin tag := GetTag ( i ) + 1 ;
50424: LD_ADDR_VAR 0 9
50428: PUSH
50429: LD_VAR 0 4
50433: PPUSH
50434: CALL_OW 110
50438: PUSH
50439: LD_INT 1
50441: PLUS
50442: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50443: LD_ADDR_VAR 0 7
50447: PUSH
50448: LD_VAR 0 4
50452: PPUSH
50453: CALL_OW 250
50457: PPUSH
50458: LD_VAR 0 4
50462: PPUSH
50463: CALL_OW 251
50467: PPUSH
50468: LD_INT 6
50470: PPUSH
50471: CALL 50046 0 3
50475: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50476: LD_VAR 0 7
50480: PUSH
50481: LD_VAR 0 4
50485: PPUSH
50486: CALL_OW 264
50490: PUSH
50491: LD_VAR 0 10
50495: IN
50496: NOT
50497: AND
50498: IFFALSE 50537
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50500: LD_VAR 0 4
50504: PPUSH
50505: LD_VAR 0 7
50509: PUSH
50510: LD_INT 1
50512: ARRAY
50513: PUSH
50514: LD_INT 1
50516: ARRAY
50517: PPUSH
50518: LD_VAR 0 7
50522: PUSH
50523: LD_INT 1
50525: ARRAY
50526: PUSH
50527: LD_INT 2
50529: ARRAY
50530: PPUSH
50531: CALL_OW 116
50535: GO 50744
// if path > tag then
50537: LD_VAR 0 2
50541: PUSH
50542: LD_VAR 0 9
50546: GREATER
50547: IFFALSE 50714
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
50549: LD_ADDR_VAR 0 6
50553: PUSH
50554: LD_VAR 0 5
50558: PPUSH
50559: LD_INT 91
50561: PUSH
50562: LD_VAR 0 4
50566: PUSH
50567: LD_INT 12
50569: PUSH
50570: EMPTY
50571: LIST
50572: LIST
50573: LIST
50574: PPUSH
50575: CALL_OW 72
50579: ST_TO_ADDR
// if nearEnemy then
50580: LD_VAR 0 6
50584: IFFALSE 50612
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50586: LD_VAR 0 4
50590: PPUSH
50591: LD_VAR 0 6
50595: PPUSH
50596: LD_VAR 0 4
50600: PPUSH
50601: CALL_OW 74
50605: PPUSH
50606: CALL_OW 115
50610: GO 50712
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50612: LD_VAR 0 4
50616: PPUSH
50617: LD_VAR 0 2
50621: PUSH
50622: LD_VAR 0 9
50626: ARRAY
50627: PUSH
50628: LD_INT 1
50630: ARRAY
50631: PPUSH
50632: LD_VAR 0 2
50636: PUSH
50637: LD_VAR 0 9
50641: ARRAY
50642: PUSH
50643: LD_INT 2
50645: ARRAY
50646: PPUSH
50647: CALL_OW 297
50651: PUSH
50652: LD_INT 6
50654: GREATER
50655: IFFALSE 50698
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50657: LD_VAR 0 4
50661: PPUSH
50662: LD_VAR 0 2
50666: PUSH
50667: LD_VAR 0 9
50671: ARRAY
50672: PUSH
50673: LD_INT 1
50675: ARRAY
50676: PPUSH
50677: LD_VAR 0 2
50681: PUSH
50682: LD_VAR 0 9
50686: ARRAY
50687: PUSH
50688: LD_INT 2
50690: ARRAY
50691: PPUSH
50692: CALL_OW 114
50696: GO 50712
// SetTag ( i , tag ) ;
50698: LD_VAR 0 4
50702: PPUSH
50703: LD_VAR 0 9
50707: PPUSH
50708: CALL_OW 109
// end else
50712: GO 50744
// if enemy then
50714: LD_VAR 0 5
50718: IFFALSE 50744
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50720: LD_VAR 0 4
50724: PPUSH
50725: LD_VAR 0 5
50729: PPUSH
50730: LD_VAR 0 4
50734: PPUSH
50735: CALL_OW 74
50739: PPUSH
50740: CALL_OW 115
// end ;
50744: GO 50421
50746: POP
50747: POP
// end ;
50748: LD_VAR 0 3
50752: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50753: LD_INT 0
50755: PPUSH
50756: PPUSH
50757: PPUSH
// if not unit or IsInUnit ( unit ) then
50758: LD_VAR 0 1
50762: NOT
50763: PUSH
50764: LD_VAR 0 1
50768: PPUSH
50769: CALL_OW 310
50773: OR
50774: IFFALSE 50778
// exit ;
50776: GO 50869
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50778: LD_ADDR_VAR 0 4
50782: PUSH
50783: LD_VAR 0 1
50787: PPUSH
50788: CALL_OW 250
50792: PPUSH
50793: LD_VAR 0 2
50797: PPUSH
50798: LD_INT 1
50800: PPUSH
50801: CALL_OW 272
50805: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50806: LD_ADDR_VAR 0 5
50810: PUSH
50811: LD_VAR 0 1
50815: PPUSH
50816: CALL_OW 251
50820: PPUSH
50821: LD_VAR 0 2
50825: PPUSH
50826: LD_INT 1
50828: PPUSH
50829: CALL_OW 273
50833: ST_TO_ADDR
// if ValidHex ( x , y ) then
50834: LD_VAR 0 4
50838: PPUSH
50839: LD_VAR 0 5
50843: PPUSH
50844: CALL_OW 488
50848: IFFALSE 50869
// ComTurnXY ( unit , x , y ) ;
50850: LD_VAR 0 1
50854: PPUSH
50855: LD_VAR 0 4
50859: PPUSH
50860: LD_VAR 0 5
50864: PPUSH
50865: CALL_OW 118
// end ;
50869: LD_VAR 0 3
50873: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50874: LD_INT 0
50876: PPUSH
50877: PPUSH
// result := false ;
50878: LD_ADDR_VAR 0 3
50882: PUSH
50883: LD_INT 0
50885: ST_TO_ADDR
// if not units then
50886: LD_VAR 0 2
50890: NOT
50891: IFFALSE 50895
// exit ;
50893: GO 50940
// for i in units do
50895: LD_ADDR_VAR 0 4
50899: PUSH
50900: LD_VAR 0 2
50904: PUSH
50905: FOR_IN
50906: IFFALSE 50938
// if See ( side , i ) then
50908: LD_VAR 0 1
50912: PPUSH
50913: LD_VAR 0 4
50917: PPUSH
50918: CALL_OW 292
50922: IFFALSE 50936
// begin result := true ;
50924: LD_ADDR_VAR 0 3
50928: PUSH
50929: LD_INT 1
50931: ST_TO_ADDR
// exit ;
50932: POP
50933: POP
50934: GO 50940
// end ;
50936: GO 50905
50938: POP
50939: POP
// end ;
50940: LD_VAR 0 3
50944: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50945: LD_INT 0
50947: PPUSH
50948: PPUSH
50949: PPUSH
50950: PPUSH
// if not unit or not points then
50951: LD_VAR 0 1
50955: NOT
50956: PUSH
50957: LD_VAR 0 2
50961: NOT
50962: OR
50963: IFFALSE 50967
// exit ;
50965: GO 51057
// dist := 99999 ;
50967: LD_ADDR_VAR 0 5
50971: PUSH
50972: LD_INT 99999
50974: ST_TO_ADDR
// for i in points do
50975: LD_ADDR_VAR 0 4
50979: PUSH
50980: LD_VAR 0 2
50984: PUSH
50985: FOR_IN
50986: IFFALSE 51055
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50988: LD_ADDR_VAR 0 6
50992: PUSH
50993: LD_VAR 0 1
50997: PPUSH
50998: LD_VAR 0 4
51002: PUSH
51003: LD_INT 1
51005: ARRAY
51006: PPUSH
51007: LD_VAR 0 4
51011: PUSH
51012: LD_INT 2
51014: ARRAY
51015: PPUSH
51016: CALL_OW 297
51020: ST_TO_ADDR
// if tmpDist < dist then
51021: LD_VAR 0 6
51025: PUSH
51026: LD_VAR 0 5
51030: LESS
51031: IFFALSE 51053
// begin result := i ;
51033: LD_ADDR_VAR 0 3
51037: PUSH
51038: LD_VAR 0 4
51042: ST_TO_ADDR
// dist := tmpDist ;
51043: LD_ADDR_VAR 0 5
51047: PUSH
51048: LD_VAR 0 6
51052: ST_TO_ADDR
// end ; end ;
51053: GO 50985
51055: POP
51056: POP
// end ; end_of_file
51057: LD_VAR 0 3
51061: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
51062: LD_INT 0
51064: PPUSH
51065: PPUSH
// skirmish := false ;
51066: LD_ADDR_EXP 21
51070: PUSH
51071: LD_INT 0
51073: ST_TO_ADDR
// debug_mc := false ;
51074: LD_ADDR_EXP 22
51078: PUSH
51079: LD_INT 0
51081: ST_TO_ADDR
// mc_bases := [ ] ;
51082: LD_ADDR_EXP 23
51086: PUSH
51087: EMPTY
51088: ST_TO_ADDR
// mc_sides := [ ] ;
51089: LD_ADDR_EXP 49
51093: PUSH
51094: EMPTY
51095: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51096: LD_ADDR_EXP 24
51100: PUSH
51101: EMPTY
51102: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51103: LD_ADDR_EXP 25
51107: PUSH
51108: EMPTY
51109: ST_TO_ADDR
// mc_need_heal := [ ] ;
51110: LD_ADDR_EXP 26
51114: PUSH
51115: EMPTY
51116: ST_TO_ADDR
// mc_healers := [ ] ;
51117: LD_ADDR_EXP 27
51121: PUSH
51122: EMPTY
51123: ST_TO_ADDR
// mc_build_list := [ ] ;
51124: LD_ADDR_EXP 28
51128: PUSH
51129: EMPTY
51130: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51131: LD_ADDR_EXP 55
51135: PUSH
51136: EMPTY
51137: ST_TO_ADDR
// mc_builders := [ ] ;
51138: LD_ADDR_EXP 29
51142: PUSH
51143: EMPTY
51144: ST_TO_ADDR
// mc_construct_list := [ ] ;
51145: LD_ADDR_EXP 30
51149: PUSH
51150: EMPTY
51151: ST_TO_ADDR
// mc_turret_list := [ ] ;
51152: LD_ADDR_EXP 31
51156: PUSH
51157: EMPTY
51158: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51159: LD_ADDR_EXP 32
51163: PUSH
51164: EMPTY
51165: ST_TO_ADDR
// mc_miners := [ ] ;
51166: LD_ADDR_EXP 37
51170: PUSH
51171: EMPTY
51172: ST_TO_ADDR
// mc_mines := [ ] ;
51173: LD_ADDR_EXP 36
51177: PUSH
51178: EMPTY
51179: ST_TO_ADDR
// mc_minefields := [ ] ;
51180: LD_ADDR_EXP 38
51184: PUSH
51185: EMPTY
51186: ST_TO_ADDR
// mc_crates := [ ] ;
51187: LD_ADDR_EXP 39
51191: PUSH
51192: EMPTY
51193: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51194: LD_ADDR_EXP 40
51198: PUSH
51199: EMPTY
51200: ST_TO_ADDR
// mc_crates_area := [ ] ;
51201: LD_ADDR_EXP 41
51205: PUSH
51206: EMPTY
51207: ST_TO_ADDR
// mc_vehicles := [ ] ;
51208: LD_ADDR_EXP 42
51212: PUSH
51213: EMPTY
51214: ST_TO_ADDR
// mc_attack := [ ] ;
51215: LD_ADDR_EXP 43
51219: PUSH
51220: EMPTY
51221: ST_TO_ADDR
// mc_produce := [ ] ;
51222: LD_ADDR_EXP 44
51226: PUSH
51227: EMPTY
51228: ST_TO_ADDR
// mc_defender := [ ] ;
51229: LD_ADDR_EXP 45
51233: PUSH
51234: EMPTY
51235: ST_TO_ADDR
// mc_parking := [ ] ;
51236: LD_ADDR_EXP 47
51240: PUSH
51241: EMPTY
51242: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51243: LD_ADDR_EXP 33
51247: PUSH
51248: EMPTY
51249: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51250: LD_ADDR_EXP 35
51254: PUSH
51255: EMPTY
51256: ST_TO_ADDR
// mc_scan := [ ] ;
51257: LD_ADDR_EXP 46
51261: PUSH
51262: EMPTY
51263: ST_TO_ADDR
// mc_scan_area := [ ] ;
51264: LD_ADDR_EXP 48
51268: PUSH
51269: EMPTY
51270: ST_TO_ADDR
// mc_tech := [ ] ;
51271: LD_ADDR_EXP 50
51275: PUSH
51276: EMPTY
51277: ST_TO_ADDR
// mc_class := [ ] ;
51278: LD_ADDR_EXP 64
51282: PUSH
51283: EMPTY
51284: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51285: LD_ADDR_EXP 65
51289: PUSH
51290: EMPTY
51291: ST_TO_ADDR
// mc_is_defending := [ ] ;
51292: LD_ADDR_EXP 66
51296: PUSH
51297: EMPTY
51298: ST_TO_ADDR
// end ;
51299: LD_VAR 0 1
51303: RET
// export function MC_Kill ( base ) ; begin
51304: LD_INT 0
51306: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51307: LD_ADDR_EXP 23
51311: PUSH
51312: LD_EXP 23
51316: PPUSH
51317: LD_VAR 0 1
51321: PPUSH
51322: EMPTY
51323: PPUSH
51324: CALL_OW 1
51328: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51329: LD_ADDR_EXP 24
51333: PUSH
51334: LD_EXP 24
51338: PPUSH
51339: LD_VAR 0 1
51343: PPUSH
51344: EMPTY
51345: PPUSH
51346: CALL_OW 1
51350: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51351: LD_ADDR_EXP 25
51355: PUSH
51356: LD_EXP 25
51360: PPUSH
51361: LD_VAR 0 1
51365: PPUSH
51366: EMPTY
51367: PPUSH
51368: CALL_OW 1
51372: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51373: LD_ADDR_EXP 26
51377: PUSH
51378: LD_EXP 26
51382: PPUSH
51383: LD_VAR 0 1
51387: PPUSH
51388: EMPTY
51389: PPUSH
51390: CALL_OW 1
51394: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51395: LD_ADDR_EXP 27
51399: PUSH
51400: LD_EXP 27
51404: PPUSH
51405: LD_VAR 0 1
51409: PPUSH
51410: EMPTY
51411: PPUSH
51412: CALL_OW 1
51416: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51417: LD_ADDR_EXP 28
51421: PUSH
51422: LD_EXP 28
51426: PPUSH
51427: LD_VAR 0 1
51431: PPUSH
51432: EMPTY
51433: PPUSH
51434: CALL_OW 1
51438: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51439: LD_ADDR_EXP 29
51443: PUSH
51444: LD_EXP 29
51448: PPUSH
51449: LD_VAR 0 1
51453: PPUSH
51454: EMPTY
51455: PPUSH
51456: CALL_OW 1
51460: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51461: LD_ADDR_EXP 30
51465: PUSH
51466: LD_EXP 30
51470: PPUSH
51471: LD_VAR 0 1
51475: PPUSH
51476: EMPTY
51477: PPUSH
51478: CALL_OW 1
51482: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51483: LD_ADDR_EXP 31
51487: PUSH
51488: LD_EXP 31
51492: PPUSH
51493: LD_VAR 0 1
51497: PPUSH
51498: EMPTY
51499: PPUSH
51500: CALL_OW 1
51504: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51505: LD_ADDR_EXP 32
51509: PUSH
51510: LD_EXP 32
51514: PPUSH
51515: LD_VAR 0 1
51519: PPUSH
51520: EMPTY
51521: PPUSH
51522: CALL_OW 1
51526: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51527: LD_ADDR_EXP 33
51531: PUSH
51532: LD_EXP 33
51536: PPUSH
51537: LD_VAR 0 1
51541: PPUSH
51542: EMPTY
51543: PPUSH
51544: CALL_OW 1
51548: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51549: LD_ADDR_EXP 34
51553: PUSH
51554: LD_EXP 34
51558: PPUSH
51559: LD_VAR 0 1
51563: PPUSH
51564: LD_INT 0
51566: PPUSH
51567: CALL_OW 1
51571: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51572: LD_ADDR_EXP 35
51576: PUSH
51577: LD_EXP 35
51581: PPUSH
51582: LD_VAR 0 1
51586: PPUSH
51587: EMPTY
51588: PPUSH
51589: CALL_OW 1
51593: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51594: LD_ADDR_EXP 36
51598: PUSH
51599: LD_EXP 36
51603: PPUSH
51604: LD_VAR 0 1
51608: PPUSH
51609: EMPTY
51610: PPUSH
51611: CALL_OW 1
51615: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51616: LD_ADDR_EXP 37
51620: PUSH
51621: LD_EXP 37
51625: PPUSH
51626: LD_VAR 0 1
51630: PPUSH
51631: EMPTY
51632: PPUSH
51633: CALL_OW 1
51637: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51638: LD_ADDR_EXP 38
51642: PUSH
51643: LD_EXP 38
51647: PPUSH
51648: LD_VAR 0 1
51652: PPUSH
51653: EMPTY
51654: PPUSH
51655: CALL_OW 1
51659: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51660: LD_ADDR_EXP 39
51664: PUSH
51665: LD_EXP 39
51669: PPUSH
51670: LD_VAR 0 1
51674: PPUSH
51675: EMPTY
51676: PPUSH
51677: CALL_OW 1
51681: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51682: LD_ADDR_EXP 40
51686: PUSH
51687: LD_EXP 40
51691: PPUSH
51692: LD_VAR 0 1
51696: PPUSH
51697: EMPTY
51698: PPUSH
51699: CALL_OW 1
51703: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51704: LD_ADDR_EXP 41
51708: PUSH
51709: LD_EXP 41
51713: PPUSH
51714: LD_VAR 0 1
51718: PPUSH
51719: EMPTY
51720: PPUSH
51721: CALL_OW 1
51725: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51726: LD_ADDR_EXP 42
51730: PUSH
51731: LD_EXP 42
51735: PPUSH
51736: LD_VAR 0 1
51740: PPUSH
51741: EMPTY
51742: PPUSH
51743: CALL_OW 1
51747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51748: LD_ADDR_EXP 43
51752: PUSH
51753: LD_EXP 43
51757: PPUSH
51758: LD_VAR 0 1
51762: PPUSH
51763: EMPTY
51764: PPUSH
51765: CALL_OW 1
51769: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51770: LD_ADDR_EXP 44
51774: PUSH
51775: LD_EXP 44
51779: PPUSH
51780: LD_VAR 0 1
51784: PPUSH
51785: EMPTY
51786: PPUSH
51787: CALL_OW 1
51791: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51792: LD_ADDR_EXP 45
51796: PUSH
51797: LD_EXP 45
51801: PPUSH
51802: LD_VAR 0 1
51806: PPUSH
51807: EMPTY
51808: PPUSH
51809: CALL_OW 1
51813: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51814: LD_ADDR_EXP 46
51818: PUSH
51819: LD_EXP 46
51823: PPUSH
51824: LD_VAR 0 1
51828: PPUSH
51829: EMPTY
51830: PPUSH
51831: CALL_OW 1
51835: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51836: LD_ADDR_EXP 47
51840: PUSH
51841: LD_EXP 47
51845: PPUSH
51846: LD_VAR 0 1
51850: PPUSH
51851: EMPTY
51852: PPUSH
51853: CALL_OW 1
51857: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51858: LD_ADDR_EXP 48
51862: PUSH
51863: LD_EXP 48
51867: PPUSH
51868: LD_VAR 0 1
51872: PPUSH
51873: EMPTY
51874: PPUSH
51875: CALL_OW 1
51879: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51880: LD_ADDR_EXP 50
51884: PUSH
51885: LD_EXP 50
51889: PPUSH
51890: LD_VAR 0 1
51894: PPUSH
51895: EMPTY
51896: PPUSH
51897: CALL_OW 1
51901: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51902: LD_ADDR_EXP 52
51906: PUSH
51907: LD_EXP 52
51911: PPUSH
51912: LD_VAR 0 1
51916: PPUSH
51917: EMPTY
51918: PPUSH
51919: CALL_OW 1
51923: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51924: LD_ADDR_EXP 53
51928: PUSH
51929: LD_EXP 53
51933: PPUSH
51934: LD_VAR 0 1
51938: PPUSH
51939: EMPTY
51940: PPUSH
51941: CALL_OW 1
51945: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51946: LD_ADDR_EXP 54
51950: PUSH
51951: LD_EXP 54
51955: PPUSH
51956: LD_VAR 0 1
51960: PPUSH
51961: EMPTY
51962: PPUSH
51963: CALL_OW 1
51967: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51968: LD_ADDR_EXP 55
51972: PUSH
51973: LD_EXP 55
51977: PPUSH
51978: LD_VAR 0 1
51982: PPUSH
51983: EMPTY
51984: PPUSH
51985: CALL_OW 1
51989: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51990: LD_ADDR_EXP 56
51994: PUSH
51995: LD_EXP 56
51999: PPUSH
52000: LD_VAR 0 1
52004: PPUSH
52005: EMPTY
52006: PPUSH
52007: CALL_OW 1
52011: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52012: LD_ADDR_EXP 57
52016: PUSH
52017: LD_EXP 57
52021: PPUSH
52022: LD_VAR 0 1
52026: PPUSH
52027: EMPTY
52028: PPUSH
52029: CALL_OW 1
52033: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52034: LD_ADDR_EXP 58
52038: PUSH
52039: LD_EXP 58
52043: PPUSH
52044: LD_VAR 0 1
52048: PPUSH
52049: EMPTY
52050: PPUSH
52051: CALL_OW 1
52055: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52056: LD_ADDR_EXP 59
52060: PUSH
52061: LD_EXP 59
52065: PPUSH
52066: LD_VAR 0 1
52070: PPUSH
52071: EMPTY
52072: PPUSH
52073: CALL_OW 1
52077: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52078: LD_ADDR_EXP 60
52082: PUSH
52083: LD_EXP 60
52087: PPUSH
52088: LD_VAR 0 1
52092: PPUSH
52093: EMPTY
52094: PPUSH
52095: CALL_OW 1
52099: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52100: LD_ADDR_EXP 61
52104: PUSH
52105: LD_EXP 61
52109: PPUSH
52110: LD_VAR 0 1
52114: PPUSH
52115: EMPTY
52116: PPUSH
52117: CALL_OW 1
52121: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52122: LD_ADDR_EXP 62
52126: PUSH
52127: LD_EXP 62
52131: PPUSH
52132: LD_VAR 0 1
52136: PPUSH
52137: EMPTY
52138: PPUSH
52139: CALL_OW 1
52143: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52144: LD_ADDR_EXP 63
52148: PUSH
52149: LD_EXP 63
52153: PPUSH
52154: LD_VAR 0 1
52158: PPUSH
52159: EMPTY
52160: PPUSH
52161: CALL_OW 1
52165: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52166: LD_ADDR_EXP 64
52170: PUSH
52171: LD_EXP 64
52175: PPUSH
52176: LD_VAR 0 1
52180: PPUSH
52181: EMPTY
52182: PPUSH
52183: CALL_OW 1
52187: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52188: LD_ADDR_EXP 65
52192: PUSH
52193: LD_EXP 65
52197: PPUSH
52198: LD_VAR 0 1
52202: PPUSH
52203: LD_INT 0
52205: PPUSH
52206: CALL_OW 1
52210: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52211: LD_ADDR_EXP 66
52215: PUSH
52216: LD_EXP 66
52220: PPUSH
52221: LD_VAR 0 1
52225: PPUSH
52226: LD_INT 0
52228: PPUSH
52229: CALL_OW 1
52233: ST_TO_ADDR
// end ;
52234: LD_VAR 0 2
52238: RET
// export function MC_Add ( side , units ) ; var base ; begin
52239: LD_INT 0
52241: PPUSH
52242: PPUSH
// base := mc_bases + 1 ;
52243: LD_ADDR_VAR 0 4
52247: PUSH
52248: LD_EXP 23
52252: PUSH
52253: LD_INT 1
52255: PLUS
52256: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52257: LD_ADDR_EXP 49
52261: PUSH
52262: LD_EXP 49
52266: PPUSH
52267: LD_VAR 0 4
52271: PPUSH
52272: LD_VAR 0 1
52276: PPUSH
52277: CALL_OW 1
52281: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52282: LD_ADDR_EXP 23
52286: PUSH
52287: LD_EXP 23
52291: PPUSH
52292: LD_VAR 0 4
52296: PPUSH
52297: LD_VAR 0 2
52301: PPUSH
52302: CALL_OW 1
52306: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52307: LD_ADDR_EXP 24
52311: PUSH
52312: LD_EXP 24
52316: PPUSH
52317: LD_VAR 0 4
52321: PPUSH
52322: EMPTY
52323: PPUSH
52324: CALL_OW 1
52328: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52329: LD_ADDR_EXP 25
52333: PUSH
52334: LD_EXP 25
52338: PPUSH
52339: LD_VAR 0 4
52343: PPUSH
52344: EMPTY
52345: PPUSH
52346: CALL_OW 1
52350: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52351: LD_ADDR_EXP 26
52355: PUSH
52356: LD_EXP 26
52360: PPUSH
52361: LD_VAR 0 4
52365: PPUSH
52366: EMPTY
52367: PPUSH
52368: CALL_OW 1
52372: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52373: LD_ADDR_EXP 27
52377: PUSH
52378: LD_EXP 27
52382: PPUSH
52383: LD_VAR 0 4
52387: PPUSH
52388: EMPTY
52389: PPUSH
52390: CALL_OW 1
52394: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52395: LD_ADDR_EXP 28
52399: PUSH
52400: LD_EXP 28
52404: PPUSH
52405: LD_VAR 0 4
52409: PPUSH
52410: EMPTY
52411: PPUSH
52412: CALL_OW 1
52416: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52417: LD_ADDR_EXP 29
52421: PUSH
52422: LD_EXP 29
52426: PPUSH
52427: LD_VAR 0 4
52431: PPUSH
52432: EMPTY
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52439: LD_ADDR_EXP 30
52443: PUSH
52444: LD_EXP 30
52448: PPUSH
52449: LD_VAR 0 4
52453: PPUSH
52454: EMPTY
52455: PPUSH
52456: CALL_OW 1
52460: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52461: LD_ADDR_EXP 31
52465: PUSH
52466: LD_EXP 31
52470: PPUSH
52471: LD_VAR 0 4
52475: PPUSH
52476: EMPTY
52477: PPUSH
52478: CALL_OW 1
52482: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52483: LD_ADDR_EXP 32
52487: PUSH
52488: LD_EXP 32
52492: PPUSH
52493: LD_VAR 0 4
52497: PPUSH
52498: EMPTY
52499: PPUSH
52500: CALL_OW 1
52504: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52505: LD_ADDR_EXP 33
52509: PUSH
52510: LD_EXP 33
52514: PPUSH
52515: LD_VAR 0 4
52519: PPUSH
52520: EMPTY
52521: PPUSH
52522: CALL_OW 1
52526: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52527: LD_ADDR_EXP 34
52531: PUSH
52532: LD_EXP 34
52536: PPUSH
52537: LD_VAR 0 4
52541: PPUSH
52542: LD_INT 0
52544: PPUSH
52545: CALL_OW 1
52549: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52550: LD_ADDR_EXP 35
52554: PUSH
52555: LD_EXP 35
52559: PPUSH
52560: LD_VAR 0 4
52564: PPUSH
52565: EMPTY
52566: PPUSH
52567: CALL_OW 1
52571: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52572: LD_ADDR_EXP 36
52576: PUSH
52577: LD_EXP 36
52581: PPUSH
52582: LD_VAR 0 4
52586: PPUSH
52587: EMPTY
52588: PPUSH
52589: CALL_OW 1
52593: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52594: LD_ADDR_EXP 37
52598: PUSH
52599: LD_EXP 37
52603: PPUSH
52604: LD_VAR 0 4
52608: PPUSH
52609: EMPTY
52610: PPUSH
52611: CALL_OW 1
52615: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52616: LD_ADDR_EXP 38
52620: PUSH
52621: LD_EXP 38
52625: PPUSH
52626: LD_VAR 0 4
52630: PPUSH
52631: EMPTY
52632: PPUSH
52633: CALL_OW 1
52637: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52638: LD_ADDR_EXP 39
52642: PUSH
52643: LD_EXP 39
52647: PPUSH
52648: LD_VAR 0 4
52652: PPUSH
52653: EMPTY
52654: PPUSH
52655: CALL_OW 1
52659: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52660: LD_ADDR_EXP 40
52664: PUSH
52665: LD_EXP 40
52669: PPUSH
52670: LD_VAR 0 4
52674: PPUSH
52675: EMPTY
52676: PPUSH
52677: CALL_OW 1
52681: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52682: LD_ADDR_EXP 41
52686: PUSH
52687: LD_EXP 41
52691: PPUSH
52692: LD_VAR 0 4
52696: PPUSH
52697: EMPTY
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52704: LD_ADDR_EXP 42
52708: PUSH
52709: LD_EXP 42
52713: PPUSH
52714: LD_VAR 0 4
52718: PPUSH
52719: EMPTY
52720: PPUSH
52721: CALL_OW 1
52725: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52726: LD_ADDR_EXP 43
52730: PUSH
52731: LD_EXP 43
52735: PPUSH
52736: LD_VAR 0 4
52740: PPUSH
52741: EMPTY
52742: PPUSH
52743: CALL_OW 1
52747: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52748: LD_ADDR_EXP 44
52752: PUSH
52753: LD_EXP 44
52757: PPUSH
52758: LD_VAR 0 4
52762: PPUSH
52763: EMPTY
52764: PPUSH
52765: CALL_OW 1
52769: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52770: LD_ADDR_EXP 45
52774: PUSH
52775: LD_EXP 45
52779: PPUSH
52780: LD_VAR 0 4
52784: PPUSH
52785: EMPTY
52786: PPUSH
52787: CALL_OW 1
52791: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52792: LD_ADDR_EXP 46
52796: PUSH
52797: LD_EXP 46
52801: PPUSH
52802: LD_VAR 0 4
52806: PPUSH
52807: EMPTY
52808: PPUSH
52809: CALL_OW 1
52813: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52814: LD_ADDR_EXP 47
52818: PUSH
52819: LD_EXP 47
52823: PPUSH
52824: LD_VAR 0 4
52828: PPUSH
52829: EMPTY
52830: PPUSH
52831: CALL_OW 1
52835: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52836: LD_ADDR_EXP 48
52840: PUSH
52841: LD_EXP 48
52845: PPUSH
52846: LD_VAR 0 4
52850: PPUSH
52851: EMPTY
52852: PPUSH
52853: CALL_OW 1
52857: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52858: LD_ADDR_EXP 50
52862: PUSH
52863: LD_EXP 50
52867: PPUSH
52868: LD_VAR 0 4
52872: PPUSH
52873: EMPTY
52874: PPUSH
52875: CALL_OW 1
52879: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52880: LD_ADDR_EXP 52
52884: PUSH
52885: LD_EXP 52
52889: PPUSH
52890: LD_VAR 0 4
52894: PPUSH
52895: EMPTY
52896: PPUSH
52897: CALL_OW 1
52901: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52902: LD_ADDR_EXP 53
52906: PUSH
52907: LD_EXP 53
52911: PPUSH
52912: LD_VAR 0 4
52916: PPUSH
52917: EMPTY
52918: PPUSH
52919: CALL_OW 1
52923: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52924: LD_ADDR_EXP 54
52928: PUSH
52929: LD_EXP 54
52933: PPUSH
52934: LD_VAR 0 4
52938: PPUSH
52939: EMPTY
52940: PPUSH
52941: CALL_OW 1
52945: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52946: LD_ADDR_EXP 55
52950: PUSH
52951: LD_EXP 55
52955: PPUSH
52956: LD_VAR 0 4
52960: PPUSH
52961: EMPTY
52962: PPUSH
52963: CALL_OW 1
52967: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52968: LD_ADDR_EXP 56
52972: PUSH
52973: LD_EXP 56
52977: PPUSH
52978: LD_VAR 0 4
52982: PPUSH
52983: EMPTY
52984: PPUSH
52985: CALL_OW 1
52989: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52990: LD_ADDR_EXP 57
52994: PUSH
52995: LD_EXP 57
52999: PPUSH
53000: LD_VAR 0 4
53004: PPUSH
53005: EMPTY
53006: PPUSH
53007: CALL_OW 1
53011: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53012: LD_ADDR_EXP 58
53016: PUSH
53017: LD_EXP 58
53021: PPUSH
53022: LD_VAR 0 4
53026: PPUSH
53027: EMPTY
53028: PPUSH
53029: CALL_OW 1
53033: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53034: LD_ADDR_EXP 59
53038: PUSH
53039: LD_EXP 59
53043: PPUSH
53044: LD_VAR 0 4
53048: PPUSH
53049: EMPTY
53050: PPUSH
53051: CALL_OW 1
53055: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53056: LD_ADDR_EXP 60
53060: PUSH
53061: LD_EXP 60
53065: PPUSH
53066: LD_VAR 0 4
53070: PPUSH
53071: EMPTY
53072: PPUSH
53073: CALL_OW 1
53077: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53078: LD_ADDR_EXP 61
53082: PUSH
53083: LD_EXP 61
53087: PPUSH
53088: LD_VAR 0 4
53092: PPUSH
53093: EMPTY
53094: PPUSH
53095: CALL_OW 1
53099: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53100: LD_ADDR_EXP 62
53104: PUSH
53105: LD_EXP 62
53109: PPUSH
53110: LD_VAR 0 4
53114: PPUSH
53115: EMPTY
53116: PPUSH
53117: CALL_OW 1
53121: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53122: LD_ADDR_EXP 63
53126: PUSH
53127: LD_EXP 63
53131: PPUSH
53132: LD_VAR 0 4
53136: PPUSH
53137: EMPTY
53138: PPUSH
53139: CALL_OW 1
53143: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53144: LD_ADDR_EXP 64
53148: PUSH
53149: LD_EXP 64
53153: PPUSH
53154: LD_VAR 0 4
53158: PPUSH
53159: EMPTY
53160: PPUSH
53161: CALL_OW 1
53165: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53166: LD_ADDR_EXP 65
53170: PUSH
53171: LD_EXP 65
53175: PPUSH
53176: LD_VAR 0 4
53180: PPUSH
53181: LD_INT 0
53183: PPUSH
53184: CALL_OW 1
53188: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53189: LD_ADDR_EXP 66
53193: PUSH
53194: LD_EXP 66
53198: PPUSH
53199: LD_VAR 0 4
53203: PPUSH
53204: LD_INT 0
53206: PPUSH
53207: CALL_OW 1
53211: ST_TO_ADDR
// result := base ;
53212: LD_ADDR_VAR 0 3
53216: PUSH
53217: LD_VAR 0 4
53221: ST_TO_ADDR
// end ;
53222: LD_VAR 0 3
53226: RET
// export function MC_Start ( ) ; var i ; begin
53227: LD_INT 0
53229: PPUSH
53230: PPUSH
// for i = 1 to mc_bases do
53231: LD_ADDR_VAR 0 2
53235: PUSH
53236: DOUBLE
53237: LD_INT 1
53239: DEC
53240: ST_TO_ADDR
53241: LD_EXP 23
53245: PUSH
53246: FOR_TO
53247: IFFALSE 54347
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53249: LD_ADDR_EXP 23
53253: PUSH
53254: LD_EXP 23
53258: PPUSH
53259: LD_VAR 0 2
53263: PPUSH
53264: LD_EXP 23
53268: PUSH
53269: LD_VAR 0 2
53273: ARRAY
53274: PUSH
53275: LD_INT 0
53277: DIFF
53278: PPUSH
53279: CALL_OW 1
53283: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53284: LD_ADDR_EXP 24
53288: PUSH
53289: LD_EXP 24
53293: PPUSH
53294: LD_VAR 0 2
53298: PPUSH
53299: EMPTY
53300: PPUSH
53301: CALL_OW 1
53305: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53306: LD_ADDR_EXP 25
53310: PUSH
53311: LD_EXP 25
53315: PPUSH
53316: LD_VAR 0 2
53320: PPUSH
53321: EMPTY
53322: PPUSH
53323: CALL_OW 1
53327: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53328: LD_ADDR_EXP 26
53332: PUSH
53333: LD_EXP 26
53337: PPUSH
53338: LD_VAR 0 2
53342: PPUSH
53343: EMPTY
53344: PPUSH
53345: CALL_OW 1
53349: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53350: LD_ADDR_EXP 27
53354: PUSH
53355: LD_EXP 27
53359: PPUSH
53360: LD_VAR 0 2
53364: PPUSH
53365: EMPTY
53366: PUSH
53367: EMPTY
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: PPUSH
53373: CALL_OW 1
53377: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53378: LD_ADDR_EXP 28
53382: PUSH
53383: LD_EXP 28
53387: PPUSH
53388: LD_VAR 0 2
53392: PPUSH
53393: EMPTY
53394: PPUSH
53395: CALL_OW 1
53399: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53400: LD_ADDR_EXP 55
53404: PUSH
53405: LD_EXP 55
53409: PPUSH
53410: LD_VAR 0 2
53414: PPUSH
53415: EMPTY
53416: PPUSH
53417: CALL_OW 1
53421: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53422: LD_ADDR_EXP 29
53426: PUSH
53427: LD_EXP 29
53431: PPUSH
53432: LD_VAR 0 2
53436: PPUSH
53437: EMPTY
53438: PPUSH
53439: CALL_OW 1
53443: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53444: LD_ADDR_EXP 30
53448: PUSH
53449: LD_EXP 30
53453: PPUSH
53454: LD_VAR 0 2
53458: PPUSH
53459: EMPTY
53460: PPUSH
53461: CALL_OW 1
53465: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53466: LD_ADDR_EXP 31
53470: PUSH
53471: LD_EXP 31
53475: PPUSH
53476: LD_VAR 0 2
53480: PPUSH
53481: LD_EXP 23
53485: PUSH
53486: LD_VAR 0 2
53490: ARRAY
53491: PPUSH
53492: LD_INT 2
53494: PUSH
53495: LD_INT 30
53497: PUSH
53498: LD_INT 32
53500: PUSH
53501: EMPTY
53502: LIST
53503: LIST
53504: PUSH
53505: LD_INT 30
53507: PUSH
53508: LD_INT 33
53510: PUSH
53511: EMPTY
53512: LIST
53513: LIST
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: LIST
53519: PPUSH
53520: CALL_OW 72
53524: PPUSH
53525: CALL_OW 1
53529: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53530: LD_ADDR_EXP 32
53534: PUSH
53535: LD_EXP 32
53539: PPUSH
53540: LD_VAR 0 2
53544: PPUSH
53545: LD_EXP 23
53549: PUSH
53550: LD_VAR 0 2
53554: ARRAY
53555: PPUSH
53556: LD_INT 2
53558: PUSH
53559: LD_INT 30
53561: PUSH
53562: LD_INT 32
53564: PUSH
53565: EMPTY
53566: LIST
53567: LIST
53568: PUSH
53569: LD_INT 30
53571: PUSH
53572: LD_INT 31
53574: PUSH
53575: EMPTY
53576: LIST
53577: LIST
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: LIST
53583: PUSH
53584: LD_INT 58
53586: PUSH
53587: EMPTY
53588: LIST
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: PPUSH
53594: CALL_OW 72
53598: PPUSH
53599: CALL_OW 1
53603: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53604: LD_ADDR_EXP 33
53608: PUSH
53609: LD_EXP 33
53613: PPUSH
53614: LD_VAR 0 2
53618: PPUSH
53619: EMPTY
53620: PPUSH
53621: CALL_OW 1
53625: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53626: LD_ADDR_EXP 37
53630: PUSH
53631: LD_EXP 37
53635: PPUSH
53636: LD_VAR 0 2
53640: PPUSH
53641: EMPTY
53642: PPUSH
53643: CALL_OW 1
53647: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53648: LD_ADDR_EXP 36
53652: PUSH
53653: LD_EXP 36
53657: PPUSH
53658: LD_VAR 0 2
53662: PPUSH
53663: EMPTY
53664: PPUSH
53665: CALL_OW 1
53669: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53670: LD_ADDR_EXP 38
53674: PUSH
53675: LD_EXP 38
53679: PPUSH
53680: LD_VAR 0 2
53684: PPUSH
53685: EMPTY
53686: PPUSH
53687: CALL_OW 1
53691: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53692: LD_ADDR_EXP 39
53696: PUSH
53697: LD_EXP 39
53701: PPUSH
53702: LD_VAR 0 2
53706: PPUSH
53707: EMPTY
53708: PPUSH
53709: CALL_OW 1
53713: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53714: LD_ADDR_EXP 40
53718: PUSH
53719: LD_EXP 40
53723: PPUSH
53724: LD_VAR 0 2
53728: PPUSH
53729: EMPTY
53730: PPUSH
53731: CALL_OW 1
53735: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53736: LD_ADDR_EXP 41
53740: PUSH
53741: LD_EXP 41
53745: PPUSH
53746: LD_VAR 0 2
53750: PPUSH
53751: EMPTY
53752: PPUSH
53753: CALL_OW 1
53757: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53758: LD_ADDR_EXP 42
53762: PUSH
53763: LD_EXP 42
53767: PPUSH
53768: LD_VAR 0 2
53772: PPUSH
53773: EMPTY
53774: PPUSH
53775: CALL_OW 1
53779: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53780: LD_ADDR_EXP 43
53784: PUSH
53785: LD_EXP 43
53789: PPUSH
53790: LD_VAR 0 2
53794: PPUSH
53795: EMPTY
53796: PPUSH
53797: CALL_OW 1
53801: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53802: LD_ADDR_EXP 44
53806: PUSH
53807: LD_EXP 44
53811: PPUSH
53812: LD_VAR 0 2
53816: PPUSH
53817: EMPTY
53818: PPUSH
53819: CALL_OW 1
53823: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53824: LD_ADDR_EXP 45
53828: PUSH
53829: LD_EXP 45
53833: PPUSH
53834: LD_VAR 0 2
53838: PPUSH
53839: EMPTY
53840: PPUSH
53841: CALL_OW 1
53845: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53846: LD_ADDR_EXP 34
53850: PUSH
53851: LD_EXP 34
53855: PPUSH
53856: LD_VAR 0 2
53860: PPUSH
53861: LD_INT 0
53863: PPUSH
53864: CALL_OW 1
53868: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53869: LD_ADDR_EXP 47
53873: PUSH
53874: LD_EXP 47
53878: PPUSH
53879: LD_VAR 0 2
53883: PPUSH
53884: LD_INT 0
53886: PPUSH
53887: CALL_OW 1
53891: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53892: LD_ADDR_EXP 35
53896: PUSH
53897: LD_EXP 35
53901: PPUSH
53902: LD_VAR 0 2
53906: PPUSH
53907: EMPTY
53908: PPUSH
53909: CALL_OW 1
53913: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53914: LD_ADDR_EXP 46
53918: PUSH
53919: LD_EXP 46
53923: PPUSH
53924: LD_VAR 0 2
53928: PPUSH
53929: LD_INT 0
53931: PPUSH
53932: CALL_OW 1
53936: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53937: LD_ADDR_EXP 48
53941: PUSH
53942: LD_EXP 48
53946: PPUSH
53947: LD_VAR 0 2
53951: PPUSH
53952: EMPTY
53953: PPUSH
53954: CALL_OW 1
53958: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53959: LD_ADDR_EXP 51
53963: PUSH
53964: LD_EXP 51
53968: PPUSH
53969: LD_VAR 0 2
53973: PPUSH
53974: LD_INT 0
53976: PPUSH
53977: CALL_OW 1
53981: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53982: LD_ADDR_EXP 52
53986: PUSH
53987: LD_EXP 52
53991: PPUSH
53992: LD_VAR 0 2
53996: PPUSH
53997: EMPTY
53998: PPUSH
53999: CALL_OW 1
54003: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54004: LD_ADDR_EXP 53
54008: PUSH
54009: LD_EXP 53
54013: PPUSH
54014: LD_VAR 0 2
54018: PPUSH
54019: EMPTY
54020: PPUSH
54021: CALL_OW 1
54025: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54026: LD_ADDR_EXP 54
54030: PUSH
54031: LD_EXP 54
54035: PPUSH
54036: LD_VAR 0 2
54040: PPUSH
54041: EMPTY
54042: PPUSH
54043: CALL_OW 1
54047: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54048: LD_ADDR_EXP 56
54052: PUSH
54053: LD_EXP 56
54057: PPUSH
54058: LD_VAR 0 2
54062: PPUSH
54063: LD_EXP 23
54067: PUSH
54068: LD_VAR 0 2
54072: ARRAY
54073: PPUSH
54074: LD_INT 2
54076: PUSH
54077: LD_INT 30
54079: PUSH
54080: LD_INT 6
54082: PUSH
54083: EMPTY
54084: LIST
54085: LIST
54086: PUSH
54087: LD_INT 30
54089: PUSH
54090: LD_INT 7
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: PUSH
54097: LD_INT 30
54099: PUSH
54100: LD_INT 8
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: PUSH
54107: EMPTY
54108: LIST
54109: LIST
54110: LIST
54111: LIST
54112: PPUSH
54113: CALL_OW 72
54117: PPUSH
54118: CALL_OW 1
54122: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54123: LD_ADDR_EXP 57
54127: PUSH
54128: LD_EXP 57
54132: PPUSH
54133: LD_VAR 0 2
54137: PPUSH
54138: EMPTY
54139: PPUSH
54140: CALL_OW 1
54144: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54145: LD_ADDR_EXP 58
54149: PUSH
54150: LD_EXP 58
54154: PPUSH
54155: LD_VAR 0 2
54159: PPUSH
54160: EMPTY
54161: PPUSH
54162: CALL_OW 1
54166: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54167: LD_ADDR_EXP 59
54171: PUSH
54172: LD_EXP 59
54176: PPUSH
54177: LD_VAR 0 2
54181: PPUSH
54182: EMPTY
54183: PPUSH
54184: CALL_OW 1
54188: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54189: LD_ADDR_EXP 60
54193: PUSH
54194: LD_EXP 60
54198: PPUSH
54199: LD_VAR 0 2
54203: PPUSH
54204: EMPTY
54205: PPUSH
54206: CALL_OW 1
54210: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54211: LD_ADDR_EXP 61
54215: PUSH
54216: LD_EXP 61
54220: PPUSH
54221: LD_VAR 0 2
54225: PPUSH
54226: EMPTY
54227: PPUSH
54228: CALL_OW 1
54232: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54233: LD_ADDR_EXP 62
54237: PUSH
54238: LD_EXP 62
54242: PPUSH
54243: LD_VAR 0 2
54247: PPUSH
54248: EMPTY
54249: PPUSH
54250: CALL_OW 1
54254: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54255: LD_ADDR_EXP 63
54259: PUSH
54260: LD_EXP 63
54264: PPUSH
54265: LD_VAR 0 2
54269: PPUSH
54270: EMPTY
54271: PPUSH
54272: CALL_OW 1
54276: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54277: LD_ADDR_EXP 64
54281: PUSH
54282: LD_EXP 64
54286: PPUSH
54287: LD_VAR 0 2
54291: PPUSH
54292: EMPTY
54293: PPUSH
54294: CALL_OW 1
54298: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54299: LD_ADDR_EXP 65
54303: PUSH
54304: LD_EXP 65
54308: PPUSH
54309: LD_VAR 0 2
54313: PPUSH
54314: LD_INT 0
54316: PPUSH
54317: CALL_OW 1
54321: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54322: LD_ADDR_EXP 66
54326: PUSH
54327: LD_EXP 66
54331: PPUSH
54332: LD_VAR 0 2
54336: PPUSH
54337: LD_INT 0
54339: PPUSH
54340: CALL_OW 1
54344: ST_TO_ADDR
// end ;
54345: GO 53246
54347: POP
54348: POP
// MC_InitSides ( ) ;
54349: CALL 54635 0 0
// MC_InitResearch ( ) ;
54353: CALL 54374 0 0
// CustomInitMacro ( ) ;
54357: CALL 277 0 0
// skirmish := true ;
54361: LD_ADDR_EXP 21
54365: PUSH
54366: LD_INT 1
54368: ST_TO_ADDR
// end ;
54369: LD_VAR 0 1
54373: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54374: LD_INT 0
54376: PPUSH
54377: PPUSH
54378: PPUSH
54379: PPUSH
54380: PPUSH
54381: PPUSH
// if not mc_bases then
54382: LD_EXP 23
54386: NOT
54387: IFFALSE 54391
// exit ;
54389: GO 54630
// for i = 1 to 8 do
54391: LD_ADDR_VAR 0 2
54395: PUSH
54396: DOUBLE
54397: LD_INT 1
54399: DEC
54400: ST_TO_ADDR
54401: LD_INT 8
54403: PUSH
54404: FOR_TO
54405: IFFALSE 54431
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54407: LD_ADDR_EXP 50
54411: PUSH
54412: LD_EXP 50
54416: PPUSH
54417: LD_VAR 0 2
54421: PPUSH
54422: EMPTY
54423: PPUSH
54424: CALL_OW 1
54428: ST_TO_ADDR
54429: GO 54404
54431: POP
54432: POP
// tmp := [ ] ;
54433: LD_ADDR_VAR 0 5
54437: PUSH
54438: EMPTY
54439: ST_TO_ADDR
// for i = 1 to mc_sides do
54440: LD_ADDR_VAR 0 2
54444: PUSH
54445: DOUBLE
54446: LD_INT 1
54448: DEC
54449: ST_TO_ADDR
54450: LD_EXP 49
54454: PUSH
54455: FOR_TO
54456: IFFALSE 54514
// if not mc_sides [ i ] in tmp then
54458: LD_EXP 49
54462: PUSH
54463: LD_VAR 0 2
54467: ARRAY
54468: PUSH
54469: LD_VAR 0 5
54473: IN
54474: NOT
54475: IFFALSE 54512
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54477: LD_ADDR_VAR 0 5
54481: PUSH
54482: LD_VAR 0 5
54486: PPUSH
54487: LD_VAR 0 5
54491: PUSH
54492: LD_INT 1
54494: PLUS
54495: PPUSH
54496: LD_EXP 49
54500: PUSH
54501: LD_VAR 0 2
54505: ARRAY
54506: PPUSH
54507: CALL_OW 2
54511: ST_TO_ADDR
54512: GO 54455
54514: POP
54515: POP
// if not tmp then
54516: LD_VAR 0 5
54520: NOT
54521: IFFALSE 54525
// exit ;
54523: GO 54630
// for j in tmp do
54525: LD_ADDR_VAR 0 3
54529: PUSH
54530: LD_VAR 0 5
54534: PUSH
54535: FOR_IN
54536: IFFALSE 54628
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54538: LD_ADDR_VAR 0 6
54542: PUSH
54543: LD_INT 22
54545: PUSH
54546: LD_VAR 0 3
54550: PUSH
54551: EMPTY
54552: LIST
54553: LIST
54554: PPUSH
54555: CALL_OW 69
54559: ST_TO_ADDR
// if not un then
54560: LD_VAR 0 6
54564: NOT
54565: IFFALSE 54569
// continue ;
54567: GO 54535
// nation := GetNation ( un [ 1 ] ) ;
54569: LD_ADDR_VAR 0 4
54573: PUSH
54574: LD_VAR 0 6
54578: PUSH
54579: LD_INT 1
54581: ARRAY
54582: PPUSH
54583: CALL_OW 248
54587: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54588: LD_ADDR_EXP 50
54592: PUSH
54593: LD_EXP 50
54597: PPUSH
54598: LD_VAR 0 3
54602: PPUSH
54603: LD_VAR 0 3
54607: PPUSH
54608: LD_VAR 0 4
54612: PPUSH
54613: LD_INT 1
54615: PPUSH
54616: CALL 11090 0 3
54620: PPUSH
54621: CALL_OW 1
54625: ST_TO_ADDR
// end ;
54626: GO 54535
54628: POP
54629: POP
// end ;
54630: LD_VAR 0 1
54634: RET
// export function MC_InitSides ( ) ; var i ; begin
54635: LD_INT 0
54637: PPUSH
54638: PPUSH
// if not mc_bases then
54639: LD_EXP 23
54643: NOT
54644: IFFALSE 54648
// exit ;
54646: GO 54722
// for i = 1 to mc_bases do
54648: LD_ADDR_VAR 0 2
54652: PUSH
54653: DOUBLE
54654: LD_INT 1
54656: DEC
54657: ST_TO_ADDR
54658: LD_EXP 23
54662: PUSH
54663: FOR_TO
54664: IFFALSE 54720
// if mc_bases [ i ] then
54666: LD_EXP 23
54670: PUSH
54671: LD_VAR 0 2
54675: ARRAY
54676: IFFALSE 54718
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54678: LD_ADDR_EXP 49
54682: PUSH
54683: LD_EXP 49
54687: PPUSH
54688: LD_VAR 0 2
54692: PPUSH
54693: LD_EXP 23
54697: PUSH
54698: LD_VAR 0 2
54702: ARRAY
54703: PUSH
54704: LD_INT 1
54706: ARRAY
54707: PPUSH
54708: CALL_OW 255
54712: PPUSH
54713: CALL_OW 1
54717: ST_TO_ADDR
54718: GO 54663
54720: POP
54721: POP
// end ;
54722: LD_VAR 0 1
54726: RET
// every 0 0$03 trigger skirmish do
54727: LD_EXP 21
54731: IFFALSE 54885
54733: GO 54735
54735: DISABLE
// begin enable ;
54736: ENABLE
// MC_CheckBuildings ( ) ;
54737: CALL 59383 0 0
// MC_CheckPeopleLife ( ) ;
54741: CALL 59544 0 0
// RaiseSailEvent ( 100 ) ;
54745: LD_INT 100
54747: PPUSH
54748: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54752: LD_INT 103
54754: PPUSH
54755: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54759: LD_INT 104
54761: PPUSH
54762: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54766: LD_INT 105
54768: PPUSH
54769: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54773: LD_INT 106
54775: PPUSH
54776: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54780: LD_INT 107
54782: PPUSH
54783: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54787: LD_INT 108
54789: PPUSH
54790: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54794: LD_INT 109
54796: PPUSH
54797: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54801: LD_INT 110
54803: PPUSH
54804: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54808: LD_INT 111
54810: PPUSH
54811: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54815: LD_INT 112
54817: PPUSH
54818: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54822: LD_INT 113
54824: PPUSH
54825: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54829: LD_INT 120
54831: PPUSH
54832: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54836: LD_INT 121
54838: PPUSH
54839: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54843: LD_INT 122
54845: PPUSH
54846: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54850: LD_INT 123
54852: PPUSH
54853: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54857: LD_INT 124
54859: PPUSH
54860: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54864: LD_INT 125
54866: PPUSH
54867: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54871: LD_INT 126
54873: PPUSH
54874: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54878: LD_INT 200
54880: PPUSH
54881: CALL_OW 427
// end ;
54885: END
// on SailEvent ( event ) do begin if event < 100 then
54886: LD_VAR 0 1
54890: PUSH
54891: LD_INT 100
54893: LESS
54894: IFFALSE 54905
// CustomEvent ( event ) ;
54896: LD_VAR 0 1
54900: PPUSH
54901: CALL 10241 0 1
// if event = 100 then
54905: LD_VAR 0 1
54909: PUSH
54910: LD_INT 100
54912: EQUAL
54913: IFFALSE 54919
// MC_ClassManager ( ) ;
54915: CALL 55311 0 0
// if event = 101 then
54919: LD_VAR 0 1
54923: PUSH
54924: LD_INT 101
54926: EQUAL
54927: IFFALSE 54933
// MC_RepairBuildings ( ) ;
54929: CALL 60129 0 0
// if event = 102 then
54933: LD_VAR 0 1
54937: PUSH
54938: LD_INT 102
54940: EQUAL
54941: IFFALSE 54947
// MC_Heal ( ) ;
54943: CALL 61036 0 0
// if event = 103 then
54947: LD_VAR 0 1
54951: PUSH
54952: LD_INT 103
54954: EQUAL
54955: IFFALSE 54961
// MC_Build ( ) ;
54957: CALL 61458 0 0
// if event = 104 then
54961: LD_VAR 0 1
54965: PUSH
54966: LD_INT 104
54968: EQUAL
54969: IFFALSE 54975
// MC_TurretWeapon ( ) ;
54971: CALL 63099 0 0
// if event = 105 then
54975: LD_VAR 0 1
54979: PUSH
54980: LD_INT 105
54982: EQUAL
54983: IFFALSE 54989
// MC_BuildUpgrade ( ) ;
54985: CALL 62650 0 0
// if event = 106 then
54989: LD_VAR 0 1
54993: PUSH
54994: LD_INT 106
54996: EQUAL
54997: IFFALSE 55003
// MC_PlantMines ( ) ;
54999: CALL 63529 0 0
// if event = 107 then
55003: LD_VAR 0 1
55007: PUSH
55008: LD_INT 107
55010: EQUAL
55011: IFFALSE 55017
// MC_CollectCrates ( ) ;
55013: CALL 64320 0 0
// if event = 108 then
55017: LD_VAR 0 1
55021: PUSH
55022: LD_INT 108
55024: EQUAL
55025: IFFALSE 55031
// MC_LinkRemoteControl ( ) ;
55027: CALL 66170 0 0
// if event = 109 then
55031: LD_VAR 0 1
55035: PUSH
55036: LD_INT 109
55038: EQUAL
55039: IFFALSE 55045
// MC_ProduceVehicle ( ) ;
55041: CALL 66351 0 0
// if event = 110 then
55045: LD_VAR 0 1
55049: PUSH
55050: LD_INT 110
55052: EQUAL
55053: IFFALSE 55059
// MC_SendAttack ( ) ;
55055: CALL 66817 0 0
// if event = 111 then
55059: LD_VAR 0 1
55063: PUSH
55064: LD_INT 111
55066: EQUAL
55067: IFFALSE 55073
// MC_Defend ( ) ;
55069: CALL 66925 0 0
// if event = 112 then
55073: LD_VAR 0 1
55077: PUSH
55078: LD_INT 112
55080: EQUAL
55081: IFFALSE 55087
// MC_Research ( ) ;
55083: CALL 67805 0 0
// if event = 113 then
55087: LD_VAR 0 1
55091: PUSH
55092: LD_INT 113
55094: EQUAL
55095: IFFALSE 55101
// MC_MinesTrigger ( ) ;
55097: CALL 68919 0 0
// if event = 120 then
55101: LD_VAR 0 1
55105: PUSH
55106: LD_INT 120
55108: EQUAL
55109: IFFALSE 55115
// MC_RepairVehicle ( ) ;
55111: CALL 69018 0 0
// if event = 121 then
55115: LD_VAR 0 1
55119: PUSH
55120: LD_INT 121
55122: EQUAL
55123: IFFALSE 55129
// MC_TameApe ( ) ;
55125: CALL 69759 0 0
// if event = 122 then
55129: LD_VAR 0 1
55133: PUSH
55134: LD_INT 122
55136: EQUAL
55137: IFFALSE 55143
// MC_ChangeApeClass ( ) ;
55139: CALL 70588 0 0
// if event = 123 then
55143: LD_VAR 0 1
55147: PUSH
55148: LD_INT 123
55150: EQUAL
55151: IFFALSE 55157
// MC_Bazooka ( ) ;
55153: CALL 71238 0 0
// if event = 124 then
55157: LD_VAR 0 1
55161: PUSH
55162: LD_INT 124
55164: EQUAL
55165: IFFALSE 55171
// MC_TeleportExit ( ) ;
55167: CALL 71436 0 0
// if event = 125 then
55171: LD_VAR 0 1
55175: PUSH
55176: LD_INT 125
55178: EQUAL
55179: IFFALSE 55185
// MC_Deposits ( ) ;
55181: CALL 72083 0 0
// if event = 126 then
55185: LD_VAR 0 1
55189: PUSH
55190: LD_INT 126
55192: EQUAL
55193: IFFALSE 55199
// MC_RemoteDriver ( ) ;
55195: CALL 72708 0 0
// if event = 200 then
55199: LD_VAR 0 1
55203: PUSH
55204: LD_INT 200
55206: EQUAL
55207: IFFALSE 55213
// MC_Idle ( ) ;
55209: CALL 74657 0 0
// end ;
55213: PPOPN 1
55215: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55216: LD_INT 0
55218: PPUSH
55219: PPUSH
// if not mc_bases [ base ] or not tag then
55220: LD_EXP 23
55224: PUSH
55225: LD_VAR 0 1
55229: ARRAY
55230: NOT
55231: PUSH
55232: LD_VAR 0 2
55236: NOT
55237: OR
55238: IFFALSE 55242
// exit ;
55240: GO 55306
// for i in mc_bases [ base ] union mc_ape [ base ] do
55242: LD_ADDR_VAR 0 4
55246: PUSH
55247: LD_EXP 23
55251: PUSH
55252: LD_VAR 0 1
55256: ARRAY
55257: PUSH
55258: LD_EXP 52
55262: PUSH
55263: LD_VAR 0 1
55267: ARRAY
55268: UNION
55269: PUSH
55270: FOR_IN
55271: IFFALSE 55304
// if GetTag ( i ) = tag then
55273: LD_VAR 0 4
55277: PPUSH
55278: CALL_OW 110
55282: PUSH
55283: LD_VAR 0 2
55287: EQUAL
55288: IFFALSE 55302
// SetTag ( i , 0 ) ;
55290: LD_VAR 0 4
55294: PPUSH
55295: LD_INT 0
55297: PPUSH
55298: CALL_OW 109
55302: GO 55270
55304: POP
55305: POP
// end ;
55306: LD_VAR 0 3
55310: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55311: LD_INT 0
55313: PPUSH
55314: PPUSH
55315: PPUSH
55316: PPUSH
55317: PPUSH
55318: PPUSH
55319: PPUSH
55320: PPUSH
// if not mc_bases then
55321: LD_EXP 23
55325: NOT
55326: IFFALSE 55330
// exit ;
55328: GO 55788
// for i = 1 to mc_bases do
55330: LD_ADDR_VAR 0 2
55334: PUSH
55335: DOUBLE
55336: LD_INT 1
55338: DEC
55339: ST_TO_ADDR
55340: LD_EXP 23
55344: PUSH
55345: FOR_TO
55346: IFFALSE 55786
// begin tmp := MC_ClassCheckReq ( i ) ;
55348: LD_ADDR_VAR 0 4
55352: PUSH
55353: LD_VAR 0 2
55357: PPUSH
55358: CALL 55793 0 1
55362: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55363: LD_ADDR_EXP 64
55367: PUSH
55368: LD_EXP 64
55372: PPUSH
55373: LD_VAR 0 2
55377: PPUSH
55378: LD_VAR 0 4
55382: PPUSH
55383: CALL_OW 1
55387: ST_TO_ADDR
// if not tmp then
55388: LD_VAR 0 4
55392: NOT
55393: IFFALSE 55397
// continue ;
55395: GO 55345
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55397: LD_ADDR_VAR 0 6
55401: PUSH
55402: LD_EXP 23
55406: PUSH
55407: LD_VAR 0 2
55411: ARRAY
55412: PPUSH
55413: LD_INT 2
55415: PUSH
55416: LD_INT 30
55418: PUSH
55419: LD_INT 4
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PUSH
55426: LD_INT 30
55428: PUSH
55429: LD_INT 5
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: LIST
55440: PPUSH
55441: CALL_OW 72
55445: PUSH
55446: LD_EXP 23
55450: PUSH
55451: LD_VAR 0 2
55455: ARRAY
55456: PPUSH
55457: LD_INT 2
55459: PUSH
55460: LD_INT 30
55462: PUSH
55463: LD_INT 0
55465: PUSH
55466: EMPTY
55467: LIST
55468: LIST
55469: PUSH
55470: LD_INT 30
55472: PUSH
55473: LD_INT 1
55475: PUSH
55476: EMPTY
55477: LIST
55478: LIST
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: LIST
55484: PPUSH
55485: CALL_OW 72
55489: PUSH
55490: LD_EXP 23
55494: PUSH
55495: LD_VAR 0 2
55499: ARRAY
55500: PPUSH
55501: LD_INT 30
55503: PUSH
55504: LD_INT 3
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: PPUSH
55511: CALL_OW 72
55515: PUSH
55516: LD_EXP 23
55520: PUSH
55521: LD_VAR 0 2
55525: ARRAY
55526: PPUSH
55527: LD_INT 2
55529: PUSH
55530: LD_INT 30
55532: PUSH
55533: LD_INT 6
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: PUSH
55540: LD_INT 30
55542: PUSH
55543: LD_INT 7
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: LD_INT 30
55552: PUSH
55553: LD_INT 8
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: LIST
55564: LIST
55565: PPUSH
55566: CALL_OW 72
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: LIST
55575: LIST
55576: ST_TO_ADDR
// for j = 1 to 4 do
55577: LD_ADDR_VAR 0 3
55581: PUSH
55582: DOUBLE
55583: LD_INT 1
55585: DEC
55586: ST_TO_ADDR
55587: LD_INT 4
55589: PUSH
55590: FOR_TO
55591: IFFALSE 55782
// begin if not tmp [ j ] then
55593: LD_VAR 0 4
55597: PUSH
55598: LD_VAR 0 3
55602: ARRAY
55603: NOT
55604: IFFALSE 55608
// continue ;
55606: GO 55590
// for p in tmp [ j ] do
55608: LD_ADDR_VAR 0 5
55612: PUSH
55613: LD_VAR 0 4
55617: PUSH
55618: LD_VAR 0 3
55622: ARRAY
55623: PUSH
55624: FOR_IN
55625: IFFALSE 55778
// begin if not b [ j ] then
55627: LD_VAR 0 6
55631: PUSH
55632: LD_VAR 0 3
55636: ARRAY
55637: NOT
55638: IFFALSE 55642
// break ;
55640: GO 55778
// e := 0 ;
55642: LD_ADDR_VAR 0 7
55646: PUSH
55647: LD_INT 0
55649: ST_TO_ADDR
// for k in b [ j ] do
55650: LD_ADDR_VAR 0 8
55654: PUSH
55655: LD_VAR 0 6
55659: PUSH
55660: LD_VAR 0 3
55664: ARRAY
55665: PUSH
55666: FOR_IN
55667: IFFALSE 55694
// if IsNotFull ( k ) then
55669: LD_VAR 0 8
55673: PPUSH
55674: CALL 13243 0 1
55678: IFFALSE 55692
// begin e := k ;
55680: LD_ADDR_VAR 0 7
55684: PUSH
55685: LD_VAR 0 8
55689: ST_TO_ADDR
// break ;
55690: GO 55694
// end ;
55692: GO 55666
55694: POP
55695: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55696: LD_VAR 0 7
55700: PUSH
55701: LD_VAR 0 5
55705: PPUSH
55706: LD_VAR 0 7
55710: PPUSH
55711: CALL 46354 0 2
55715: NOT
55716: AND
55717: IFFALSE 55776
// begin if IsInUnit ( p ) then
55719: LD_VAR 0 5
55723: PPUSH
55724: CALL_OW 310
55728: IFFALSE 55739
// ComExitBuilding ( p ) ;
55730: LD_VAR 0 5
55734: PPUSH
55735: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55739: LD_VAR 0 5
55743: PPUSH
55744: LD_VAR 0 7
55748: PPUSH
55749: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55753: LD_VAR 0 5
55757: PPUSH
55758: LD_VAR 0 3
55762: PPUSH
55763: CALL_OW 183
// AddComExitBuilding ( p ) ;
55767: LD_VAR 0 5
55771: PPUSH
55772: CALL_OW 182
// end ; end ;
55776: GO 55624
55778: POP
55779: POP
// end ;
55780: GO 55590
55782: POP
55783: POP
// end ;
55784: GO 55345
55786: POP
55787: POP
// end ;
55788: LD_VAR 0 1
55792: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55793: LD_INT 0
55795: PPUSH
55796: PPUSH
55797: PPUSH
55798: PPUSH
55799: PPUSH
55800: PPUSH
55801: PPUSH
55802: PPUSH
55803: PPUSH
55804: PPUSH
55805: PPUSH
55806: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55807: LD_VAR 0 1
55811: NOT
55812: PUSH
55813: LD_EXP 23
55817: PUSH
55818: LD_VAR 0 1
55822: ARRAY
55823: NOT
55824: OR
55825: PUSH
55826: LD_EXP 23
55830: PUSH
55831: LD_VAR 0 1
55835: ARRAY
55836: PPUSH
55837: LD_INT 2
55839: PUSH
55840: LD_INT 30
55842: PUSH
55843: LD_INT 0
55845: PUSH
55846: EMPTY
55847: LIST
55848: LIST
55849: PUSH
55850: LD_INT 30
55852: PUSH
55853: LD_INT 1
55855: PUSH
55856: EMPTY
55857: LIST
55858: LIST
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: LIST
55864: PPUSH
55865: CALL_OW 72
55869: NOT
55870: OR
55871: IFFALSE 55875
// exit ;
55873: GO 59378
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55875: LD_ADDR_VAR 0 4
55879: PUSH
55880: LD_EXP 23
55884: PUSH
55885: LD_VAR 0 1
55889: ARRAY
55890: PPUSH
55891: LD_INT 2
55893: PUSH
55894: LD_INT 25
55896: PUSH
55897: LD_INT 1
55899: PUSH
55900: EMPTY
55901: LIST
55902: LIST
55903: PUSH
55904: LD_INT 25
55906: PUSH
55907: LD_INT 2
55909: PUSH
55910: EMPTY
55911: LIST
55912: LIST
55913: PUSH
55914: LD_INT 25
55916: PUSH
55917: LD_INT 3
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: PUSH
55924: LD_INT 25
55926: PUSH
55927: LD_INT 4
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: PUSH
55934: LD_INT 25
55936: PUSH
55937: LD_INT 5
55939: PUSH
55940: EMPTY
55941: LIST
55942: LIST
55943: PUSH
55944: LD_INT 25
55946: PUSH
55947: LD_INT 8
55949: PUSH
55950: EMPTY
55951: LIST
55952: LIST
55953: PUSH
55954: LD_INT 25
55956: PUSH
55957: LD_INT 9
55959: PUSH
55960: EMPTY
55961: LIST
55962: LIST
55963: PUSH
55964: EMPTY
55965: LIST
55966: LIST
55967: LIST
55968: LIST
55969: LIST
55970: LIST
55971: LIST
55972: LIST
55973: PPUSH
55974: CALL_OW 72
55978: ST_TO_ADDR
// if not tmp then
55979: LD_VAR 0 4
55983: NOT
55984: IFFALSE 55988
// exit ;
55986: GO 59378
// for i in tmp do
55988: LD_ADDR_VAR 0 3
55992: PUSH
55993: LD_VAR 0 4
55997: PUSH
55998: FOR_IN
55999: IFFALSE 56030
// if GetTag ( i ) then
56001: LD_VAR 0 3
56005: PPUSH
56006: CALL_OW 110
56010: IFFALSE 56028
// tmp := tmp diff i ;
56012: LD_ADDR_VAR 0 4
56016: PUSH
56017: LD_VAR 0 4
56021: PUSH
56022: LD_VAR 0 3
56026: DIFF
56027: ST_TO_ADDR
56028: GO 55998
56030: POP
56031: POP
// if not tmp then
56032: LD_VAR 0 4
56036: NOT
56037: IFFALSE 56041
// exit ;
56039: GO 59378
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56041: LD_ADDR_VAR 0 5
56045: PUSH
56046: LD_EXP 23
56050: PUSH
56051: LD_VAR 0 1
56055: ARRAY
56056: PPUSH
56057: LD_INT 2
56059: PUSH
56060: LD_INT 25
56062: PUSH
56063: LD_INT 1
56065: PUSH
56066: EMPTY
56067: LIST
56068: LIST
56069: PUSH
56070: LD_INT 25
56072: PUSH
56073: LD_INT 5
56075: PUSH
56076: EMPTY
56077: LIST
56078: LIST
56079: PUSH
56080: LD_INT 25
56082: PUSH
56083: LD_INT 8
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: PUSH
56090: LD_INT 25
56092: PUSH
56093: LD_INT 9
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: LIST
56104: LIST
56105: LIST
56106: PPUSH
56107: CALL_OW 72
56111: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56112: LD_ADDR_VAR 0 6
56116: PUSH
56117: LD_EXP 23
56121: PUSH
56122: LD_VAR 0 1
56126: ARRAY
56127: PPUSH
56128: LD_INT 25
56130: PUSH
56131: LD_INT 2
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PPUSH
56138: CALL_OW 72
56142: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56143: LD_ADDR_VAR 0 7
56147: PUSH
56148: LD_EXP 23
56152: PUSH
56153: LD_VAR 0 1
56157: ARRAY
56158: PPUSH
56159: LD_INT 25
56161: PUSH
56162: LD_INT 3
56164: PUSH
56165: EMPTY
56166: LIST
56167: LIST
56168: PPUSH
56169: CALL_OW 72
56173: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56174: LD_ADDR_VAR 0 8
56178: PUSH
56179: LD_EXP 23
56183: PUSH
56184: LD_VAR 0 1
56188: ARRAY
56189: PPUSH
56190: LD_INT 25
56192: PUSH
56193: LD_INT 4
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: LD_INT 24
56202: PUSH
56203: LD_INT 251
56205: PUSH
56206: EMPTY
56207: LIST
56208: LIST
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: PPUSH
56214: CALL_OW 72
56218: ST_TO_ADDR
// if mc_is_defending [ base ] then
56219: LD_EXP 66
56223: PUSH
56224: LD_VAR 0 1
56228: ARRAY
56229: IFFALSE 56690
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56231: LD_ADDR_EXP 65
56235: PUSH
56236: LD_EXP 65
56240: PPUSH
56241: LD_VAR 0 1
56245: PPUSH
56246: LD_INT 4
56248: PPUSH
56249: CALL_OW 1
56253: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56254: LD_ADDR_VAR 0 12
56258: PUSH
56259: LD_EXP 23
56263: PUSH
56264: LD_VAR 0 1
56268: ARRAY
56269: PPUSH
56270: LD_INT 2
56272: PUSH
56273: LD_INT 30
56275: PUSH
56276: LD_INT 4
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: PUSH
56283: LD_INT 30
56285: PUSH
56286: LD_INT 5
56288: PUSH
56289: EMPTY
56290: LIST
56291: LIST
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: LIST
56297: PPUSH
56298: CALL_OW 72
56302: ST_TO_ADDR
// if not b then
56303: LD_VAR 0 12
56307: NOT
56308: IFFALSE 56312
// exit ;
56310: GO 59378
// p := [ ] ;
56312: LD_ADDR_VAR 0 11
56316: PUSH
56317: EMPTY
56318: ST_TO_ADDR
// if sci >= 2 then
56319: LD_VAR 0 8
56323: PUSH
56324: LD_INT 2
56326: GREATEREQUAL
56327: IFFALSE 56358
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56329: LD_ADDR_VAR 0 8
56333: PUSH
56334: LD_VAR 0 8
56338: PUSH
56339: LD_INT 1
56341: ARRAY
56342: PUSH
56343: LD_VAR 0 8
56347: PUSH
56348: LD_INT 2
56350: ARRAY
56351: PUSH
56352: EMPTY
56353: LIST
56354: LIST
56355: ST_TO_ADDR
56356: GO 56419
// if sci = 1 then
56358: LD_VAR 0 8
56362: PUSH
56363: LD_INT 1
56365: EQUAL
56366: IFFALSE 56387
// sci := [ sci [ 1 ] ] else
56368: LD_ADDR_VAR 0 8
56372: PUSH
56373: LD_VAR 0 8
56377: PUSH
56378: LD_INT 1
56380: ARRAY
56381: PUSH
56382: EMPTY
56383: LIST
56384: ST_TO_ADDR
56385: GO 56419
// if sci = 0 then
56387: LD_VAR 0 8
56391: PUSH
56392: LD_INT 0
56394: EQUAL
56395: IFFALSE 56419
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56397: LD_ADDR_VAR 0 11
56401: PUSH
56402: LD_VAR 0 4
56406: PPUSH
56407: LD_INT 4
56409: PPUSH
56410: CALL 46217 0 2
56414: PUSH
56415: LD_INT 1
56417: ARRAY
56418: ST_TO_ADDR
// if eng > 4 then
56419: LD_VAR 0 6
56423: PUSH
56424: LD_INT 4
56426: GREATER
56427: IFFALSE 56473
// for i = eng downto 4 do
56429: LD_ADDR_VAR 0 3
56433: PUSH
56434: DOUBLE
56435: LD_VAR 0 6
56439: INC
56440: ST_TO_ADDR
56441: LD_INT 4
56443: PUSH
56444: FOR_DOWNTO
56445: IFFALSE 56471
// eng := eng diff eng [ i ] ;
56447: LD_ADDR_VAR 0 6
56451: PUSH
56452: LD_VAR 0 6
56456: PUSH
56457: LD_VAR 0 6
56461: PUSH
56462: LD_VAR 0 3
56466: ARRAY
56467: DIFF
56468: ST_TO_ADDR
56469: GO 56444
56471: POP
56472: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56473: LD_ADDR_VAR 0 4
56477: PUSH
56478: LD_VAR 0 4
56482: PUSH
56483: LD_VAR 0 5
56487: PUSH
56488: LD_VAR 0 6
56492: UNION
56493: PUSH
56494: LD_VAR 0 7
56498: UNION
56499: PUSH
56500: LD_VAR 0 8
56504: UNION
56505: DIFF
56506: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56507: LD_ADDR_VAR 0 13
56511: PUSH
56512: LD_EXP 23
56516: PUSH
56517: LD_VAR 0 1
56521: ARRAY
56522: PPUSH
56523: LD_INT 2
56525: PUSH
56526: LD_INT 30
56528: PUSH
56529: LD_INT 32
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: PUSH
56536: LD_INT 30
56538: PUSH
56539: LD_INT 31
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: PUSH
56546: EMPTY
56547: LIST
56548: LIST
56549: LIST
56550: PPUSH
56551: CALL_OW 72
56555: PUSH
56556: LD_EXP 23
56560: PUSH
56561: LD_VAR 0 1
56565: ARRAY
56566: PPUSH
56567: LD_INT 2
56569: PUSH
56570: LD_INT 30
56572: PUSH
56573: LD_INT 4
56575: PUSH
56576: EMPTY
56577: LIST
56578: LIST
56579: PUSH
56580: LD_INT 30
56582: PUSH
56583: LD_INT 5
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: LIST
56594: PPUSH
56595: CALL_OW 72
56599: PUSH
56600: LD_INT 6
56602: MUL
56603: PLUS
56604: ST_TO_ADDR
// if bcount < tmp then
56605: LD_VAR 0 13
56609: PUSH
56610: LD_VAR 0 4
56614: LESS
56615: IFFALSE 56661
// for i = tmp downto bcount do
56617: LD_ADDR_VAR 0 3
56621: PUSH
56622: DOUBLE
56623: LD_VAR 0 4
56627: INC
56628: ST_TO_ADDR
56629: LD_VAR 0 13
56633: PUSH
56634: FOR_DOWNTO
56635: IFFALSE 56659
// tmp := Delete ( tmp , tmp ) ;
56637: LD_ADDR_VAR 0 4
56641: PUSH
56642: LD_VAR 0 4
56646: PPUSH
56647: LD_VAR 0 4
56651: PPUSH
56652: CALL_OW 3
56656: ST_TO_ADDR
56657: GO 56634
56659: POP
56660: POP
// result := [ tmp , 0 , 0 , p ] ;
56661: LD_ADDR_VAR 0 2
56665: PUSH
56666: LD_VAR 0 4
56670: PUSH
56671: LD_INT 0
56673: PUSH
56674: LD_INT 0
56676: PUSH
56677: LD_VAR 0 11
56681: PUSH
56682: EMPTY
56683: LIST
56684: LIST
56685: LIST
56686: LIST
56687: ST_TO_ADDR
// exit ;
56688: GO 59378
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56690: LD_EXP 23
56694: PUSH
56695: LD_VAR 0 1
56699: ARRAY
56700: PPUSH
56701: LD_INT 2
56703: PUSH
56704: LD_INT 30
56706: PUSH
56707: LD_INT 6
56709: PUSH
56710: EMPTY
56711: LIST
56712: LIST
56713: PUSH
56714: LD_INT 30
56716: PUSH
56717: LD_INT 7
56719: PUSH
56720: EMPTY
56721: LIST
56722: LIST
56723: PUSH
56724: LD_INT 30
56726: PUSH
56727: LD_INT 8
56729: PUSH
56730: EMPTY
56731: LIST
56732: LIST
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: LIST
56738: LIST
56739: PPUSH
56740: CALL_OW 72
56744: NOT
56745: PUSH
56746: LD_EXP 23
56750: PUSH
56751: LD_VAR 0 1
56755: ARRAY
56756: PPUSH
56757: LD_INT 30
56759: PUSH
56760: LD_INT 3
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: PPUSH
56767: CALL_OW 72
56771: NOT
56772: AND
56773: IFFALSE 56845
// begin if eng = tmp then
56775: LD_VAR 0 6
56779: PUSH
56780: LD_VAR 0 4
56784: EQUAL
56785: IFFALSE 56789
// exit ;
56787: GO 59378
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56789: LD_ADDR_EXP 65
56793: PUSH
56794: LD_EXP 65
56798: PPUSH
56799: LD_VAR 0 1
56803: PPUSH
56804: LD_INT 1
56806: PPUSH
56807: CALL_OW 1
56811: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56812: LD_ADDR_VAR 0 2
56816: PUSH
56817: LD_INT 0
56819: PUSH
56820: LD_VAR 0 4
56824: PUSH
56825: LD_VAR 0 6
56829: DIFF
56830: PUSH
56831: LD_INT 0
56833: PUSH
56834: LD_INT 0
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: LIST
56841: LIST
56842: ST_TO_ADDR
// exit ;
56843: GO 59378
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56845: LD_EXP 50
56849: PUSH
56850: LD_EXP 49
56854: PUSH
56855: LD_VAR 0 1
56859: ARRAY
56860: ARRAY
56861: PUSH
56862: LD_EXP 23
56866: PUSH
56867: LD_VAR 0 1
56871: ARRAY
56872: PPUSH
56873: LD_INT 2
56875: PUSH
56876: LD_INT 30
56878: PUSH
56879: LD_INT 6
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PUSH
56886: LD_INT 30
56888: PUSH
56889: LD_INT 7
56891: PUSH
56892: EMPTY
56893: LIST
56894: LIST
56895: PUSH
56896: LD_INT 30
56898: PUSH
56899: LD_INT 8
56901: PUSH
56902: EMPTY
56903: LIST
56904: LIST
56905: PUSH
56906: EMPTY
56907: LIST
56908: LIST
56909: LIST
56910: LIST
56911: PPUSH
56912: CALL_OW 72
56916: AND
56917: PUSH
56918: LD_EXP 23
56922: PUSH
56923: LD_VAR 0 1
56927: ARRAY
56928: PPUSH
56929: LD_INT 30
56931: PUSH
56932: LD_INT 3
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PPUSH
56939: CALL_OW 72
56943: NOT
56944: AND
56945: IFFALSE 57159
// begin if sci >= 6 then
56947: LD_VAR 0 8
56951: PUSH
56952: LD_INT 6
56954: GREATEREQUAL
56955: IFFALSE 56959
// exit ;
56957: GO 59378
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56959: LD_ADDR_EXP 65
56963: PUSH
56964: LD_EXP 65
56968: PPUSH
56969: LD_VAR 0 1
56973: PPUSH
56974: LD_INT 2
56976: PPUSH
56977: CALL_OW 1
56981: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56982: LD_ADDR_VAR 0 9
56986: PUSH
56987: LD_VAR 0 4
56991: PUSH
56992: LD_VAR 0 8
56996: DIFF
56997: PPUSH
56998: LD_INT 4
57000: PPUSH
57001: CALL 46217 0 2
57005: ST_TO_ADDR
// p := [ ] ;
57006: LD_ADDR_VAR 0 11
57010: PUSH
57011: EMPTY
57012: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57013: LD_VAR 0 8
57017: PUSH
57018: LD_INT 6
57020: LESS
57021: PUSH
57022: LD_VAR 0 9
57026: PUSH
57027: LD_INT 6
57029: GREATER
57030: AND
57031: IFFALSE 57112
// begin for i = 1 to 6 - sci do
57033: LD_ADDR_VAR 0 3
57037: PUSH
57038: DOUBLE
57039: LD_INT 1
57041: DEC
57042: ST_TO_ADDR
57043: LD_INT 6
57045: PUSH
57046: LD_VAR 0 8
57050: MINUS
57051: PUSH
57052: FOR_TO
57053: IFFALSE 57108
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57055: LD_ADDR_VAR 0 11
57059: PUSH
57060: LD_VAR 0 11
57064: PPUSH
57065: LD_VAR 0 11
57069: PUSH
57070: LD_INT 1
57072: PLUS
57073: PPUSH
57074: LD_VAR 0 9
57078: PUSH
57079: LD_INT 1
57081: ARRAY
57082: PPUSH
57083: CALL_OW 2
57087: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57088: LD_ADDR_VAR 0 9
57092: PUSH
57093: LD_VAR 0 9
57097: PPUSH
57098: LD_INT 1
57100: PPUSH
57101: CALL_OW 3
57105: ST_TO_ADDR
// end ;
57106: GO 57052
57108: POP
57109: POP
// end else
57110: GO 57132
// if sort then
57112: LD_VAR 0 9
57116: IFFALSE 57132
// p := sort [ 1 ] ;
57118: LD_ADDR_VAR 0 11
57122: PUSH
57123: LD_VAR 0 9
57127: PUSH
57128: LD_INT 1
57130: ARRAY
57131: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57132: LD_ADDR_VAR 0 2
57136: PUSH
57137: LD_INT 0
57139: PUSH
57140: LD_INT 0
57142: PUSH
57143: LD_INT 0
57145: PUSH
57146: LD_VAR 0 11
57150: PUSH
57151: EMPTY
57152: LIST
57153: LIST
57154: LIST
57155: LIST
57156: ST_TO_ADDR
// exit ;
57157: GO 59378
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57159: LD_EXP 50
57163: PUSH
57164: LD_EXP 49
57168: PUSH
57169: LD_VAR 0 1
57173: ARRAY
57174: ARRAY
57175: PUSH
57176: LD_EXP 23
57180: PUSH
57181: LD_VAR 0 1
57185: ARRAY
57186: PPUSH
57187: LD_INT 2
57189: PUSH
57190: LD_INT 30
57192: PUSH
57193: LD_INT 6
57195: PUSH
57196: EMPTY
57197: LIST
57198: LIST
57199: PUSH
57200: LD_INT 30
57202: PUSH
57203: LD_INT 7
57205: PUSH
57206: EMPTY
57207: LIST
57208: LIST
57209: PUSH
57210: LD_INT 30
57212: PUSH
57213: LD_INT 8
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: PUSH
57220: EMPTY
57221: LIST
57222: LIST
57223: LIST
57224: LIST
57225: PPUSH
57226: CALL_OW 72
57230: AND
57231: PUSH
57232: LD_EXP 23
57236: PUSH
57237: LD_VAR 0 1
57241: ARRAY
57242: PPUSH
57243: LD_INT 30
57245: PUSH
57246: LD_INT 3
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PPUSH
57253: CALL_OW 72
57257: AND
57258: IFFALSE 57992
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57260: LD_ADDR_EXP 65
57264: PUSH
57265: LD_EXP 65
57269: PPUSH
57270: LD_VAR 0 1
57274: PPUSH
57275: LD_INT 3
57277: PPUSH
57278: CALL_OW 1
57282: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57283: LD_ADDR_VAR 0 2
57287: PUSH
57288: LD_INT 0
57290: PUSH
57291: LD_INT 0
57293: PUSH
57294: LD_INT 0
57296: PUSH
57297: LD_INT 0
57299: PUSH
57300: EMPTY
57301: LIST
57302: LIST
57303: LIST
57304: LIST
57305: ST_TO_ADDR
// if not eng then
57306: LD_VAR 0 6
57310: NOT
57311: IFFALSE 57374
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57313: LD_ADDR_VAR 0 11
57317: PUSH
57318: LD_VAR 0 4
57322: PPUSH
57323: LD_INT 2
57325: PPUSH
57326: CALL 46217 0 2
57330: PUSH
57331: LD_INT 1
57333: ARRAY
57334: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57335: LD_ADDR_VAR 0 2
57339: PUSH
57340: LD_VAR 0 2
57344: PPUSH
57345: LD_INT 2
57347: PPUSH
57348: LD_VAR 0 11
57352: PPUSH
57353: CALL_OW 1
57357: ST_TO_ADDR
// tmp := tmp diff p ;
57358: LD_ADDR_VAR 0 4
57362: PUSH
57363: LD_VAR 0 4
57367: PUSH
57368: LD_VAR 0 11
57372: DIFF
57373: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57374: LD_VAR 0 4
57378: PUSH
57379: LD_VAR 0 8
57383: PUSH
57384: LD_INT 6
57386: LESS
57387: AND
57388: IFFALSE 57576
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57390: LD_ADDR_VAR 0 9
57394: PUSH
57395: LD_VAR 0 4
57399: PUSH
57400: LD_VAR 0 8
57404: PUSH
57405: LD_VAR 0 7
57409: UNION
57410: DIFF
57411: PPUSH
57412: LD_INT 4
57414: PPUSH
57415: CALL 46217 0 2
57419: ST_TO_ADDR
// p := [ ] ;
57420: LD_ADDR_VAR 0 11
57424: PUSH
57425: EMPTY
57426: ST_TO_ADDR
// if sort then
57427: LD_VAR 0 9
57431: IFFALSE 57547
// for i = 1 to 6 - sci do
57433: LD_ADDR_VAR 0 3
57437: PUSH
57438: DOUBLE
57439: LD_INT 1
57441: DEC
57442: ST_TO_ADDR
57443: LD_INT 6
57445: PUSH
57446: LD_VAR 0 8
57450: MINUS
57451: PUSH
57452: FOR_TO
57453: IFFALSE 57545
// begin if i = sort then
57455: LD_VAR 0 3
57459: PUSH
57460: LD_VAR 0 9
57464: EQUAL
57465: IFFALSE 57469
// break ;
57467: GO 57545
// if GetClass ( i ) = 4 then
57469: LD_VAR 0 3
57473: PPUSH
57474: CALL_OW 257
57478: PUSH
57479: LD_INT 4
57481: EQUAL
57482: IFFALSE 57486
// continue ;
57484: GO 57452
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57486: LD_ADDR_VAR 0 11
57490: PUSH
57491: LD_VAR 0 11
57495: PPUSH
57496: LD_VAR 0 11
57500: PUSH
57501: LD_INT 1
57503: PLUS
57504: PPUSH
57505: LD_VAR 0 9
57509: PUSH
57510: LD_VAR 0 3
57514: ARRAY
57515: PPUSH
57516: CALL_OW 2
57520: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57521: LD_ADDR_VAR 0 4
57525: PUSH
57526: LD_VAR 0 4
57530: PUSH
57531: LD_VAR 0 9
57535: PUSH
57536: LD_VAR 0 3
57540: ARRAY
57541: DIFF
57542: ST_TO_ADDR
// end ;
57543: GO 57452
57545: POP
57546: POP
// if p then
57547: LD_VAR 0 11
57551: IFFALSE 57576
// result := Replace ( result , 4 , p ) ;
57553: LD_ADDR_VAR 0 2
57557: PUSH
57558: LD_VAR 0 2
57562: PPUSH
57563: LD_INT 4
57565: PPUSH
57566: LD_VAR 0 11
57570: PPUSH
57571: CALL_OW 1
57575: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57576: LD_VAR 0 4
57580: PUSH
57581: LD_VAR 0 7
57585: PUSH
57586: LD_INT 6
57588: LESS
57589: AND
57590: IFFALSE 57778
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57592: LD_ADDR_VAR 0 9
57596: PUSH
57597: LD_VAR 0 4
57601: PUSH
57602: LD_VAR 0 8
57606: PUSH
57607: LD_VAR 0 7
57611: UNION
57612: DIFF
57613: PPUSH
57614: LD_INT 3
57616: PPUSH
57617: CALL 46217 0 2
57621: ST_TO_ADDR
// p := [ ] ;
57622: LD_ADDR_VAR 0 11
57626: PUSH
57627: EMPTY
57628: ST_TO_ADDR
// if sort then
57629: LD_VAR 0 9
57633: IFFALSE 57749
// for i = 1 to 6 - mech do
57635: LD_ADDR_VAR 0 3
57639: PUSH
57640: DOUBLE
57641: LD_INT 1
57643: DEC
57644: ST_TO_ADDR
57645: LD_INT 6
57647: PUSH
57648: LD_VAR 0 7
57652: MINUS
57653: PUSH
57654: FOR_TO
57655: IFFALSE 57747
// begin if i = sort then
57657: LD_VAR 0 3
57661: PUSH
57662: LD_VAR 0 9
57666: EQUAL
57667: IFFALSE 57671
// break ;
57669: GO 57747
// if GetClass ( i ) = 3 then
57671: LD_VAR 0 3
57675: PPUSH
57676: CALL_OW 257
57680: PUSH
57681: LD_INT 3
57683: EQUAL
57684: IFFALSE 57688
// continue ;
57686: GO 57654
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57688: LD_ADDR_VAR 0 11
57692: PUSH
57693: LD_VAR 0 11
57697: PPUSH
57698: LD_VAR 0 11
57702: PUSH
57703: LD_INT 1
57705: PLUS
57706: PPUSH
57707: LD_VAR 0 9
57711: PUSH
57712: LD_VAR 0 3
57716: ARRAY
57717: PPUSH
57718: CALL_OW 2
57722: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57723: LD_ADDR_VAR 0 4
57727: PUSH
57728: LD_VAR 0 4
57732: PUSH
57733: LD_VAR 0 9
57737: PUSH
57738: LD_VAR 0 3
57742: ARRAY
57743: DIFF
57744: ST_TO_ADDR
// end ;
57745: GO 57654
57747: POP
57748: POP
// if p then
57749: LD_VAR 0 11
57753: IFFALSE 57778
// result := Replace ( result , 3 , p ) ;
57755: LD_ADDR_VAR 0 2
57759: PUSH
57760: LD_VAR 0 2
57764: PPUSH
57765: LD_INT 3
57767: PPUSH
57768: LD_VAR 0 11
57772: PPUSH
57773: CALL_OW 1
57777: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57778: LD_VAR 0 4
57782: PUSH
57783: LD_INT 6
57785: GREATER
57786: PUSH
57787: LD_VAR 0 6
57791: PUSH
57792: LD_INT 6
57794: LESS
57795: AND
57796: IFFALSE 57990
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57798: LD_ADDR_VAR 0 9
57802: PUSH
57803: LD_VAR 0 4
57807: PUSH
57808: LD_VAR 0 8
57812: PUSH
57813: LD_VAR 0 7
57817: UNION
57818: PUSH
57819: LD_VAR 0 6
57823: UNION
57824: DIFF
57825: PPUSH
57826: LD_INT 2
57828: PPUSH
57829: CALL 46217 0 2
57833: ST_TO_ADDR
// p := [ ] ;
57834: LD_ADDR_VAR 0 11
57838: PUSH
57839: EMPTY
57840: ST_TO_ADDR
// if sort then
57841: LD_VAR 0 9
57845: IFFALSE 57961
// for i = 1 to 6 - eng do
57847: LD_ADDR_VAR 0 3
57851: PUSH
57852: DOUBLE
57853: LD_INT 1
57855: DEC
57856: ST_TO_ADDR
57857: LD_INT 6
57859: PUSH
57860: LD_VAR 0 6
57864: MINUS
57865: PUSH
57866: FOR_TO
57867: IFFALSE 57959
// begin if i = sort then
57869: LD_VAR 0 3
57873: PUSH
57874: LD_VAR 0 9
57878: EQUAL
57879: IFFALSE 57883
// break ;
57881: GO 57959
// if GetClass ( i ) = 2 then
57883: LD_VAR 0 3
57887: PPUSH
57888: CALL_OW 257
57892: PUSH
57893: LD_INT 2
57895: EQUAL
57896: IFFALSE 57900
// continue ;
57898: GO 57866
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57900: LD_ADDR_VAR 0 11
57904: PUSH
57905: LD_VAR 0 11
57909: PPUSH
57910: LD_VAR 0 11
57914: PUSH
57915: LD_INT 1
57917: PLUS
57918: PPUSH
57919: LD_VAR 0 9
57923: PUSH
57924: LD_VAR 0 3
57928: ARRAY
57929: PPUSH
57930: CALL_OW 2
57934: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57935: LD_ADDR_VAR 0 4
57939: PUSH
57940: LD_VAR 0 4
57944: PUSH
57945: LD_VAR 0 9
57949: PUSH
57950: LD_VAR 0 3
57954: ARRAY
57955: DIFF
57956: ST_TO_ADDR
// end ;
57957: GO 57866
57959: POP
57960: POP
// if p then
57961: LD_VAR 0 11
57965: IFFALSE 57990
// result := Replace ( result , 2 , p ) ;
57967: LD_ADDR_VAR 0 2
57971: PUSH
57972: LD_VAR 0 2
57976: PPUSH
57977: LD_INT 2
57979: PPUSH
57980: LD_VAR 0 11
57984: PPUSH
57985: CALL_OW 1
57989: ST_TO_ADDR
// end ; exit ;
57990: GO 59378
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57992: LD_EXP 50
57996: PUSH
57997: LD_EXP 49
58001: PUSH
58002: LD_VAR 0 1
58006: ARRAY
58007: ARRAY
58008: NOT
58009: PUSH
58010: LD_EXP 23
58014: PUSH
58015: LD_VAR 0 1
58019: ARRAY
58020: PPUSH
58021: LD_INT 30
58023: PUSH
58024: LD_INT 3
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PPUSH
58031: CALL_OW 72
58035: AND
58036: PUSH
58037: LD_EXP 28
58041: PUSH
58042: LD_VAR 0 1
58046: ARRAY
58047: AND
58048: IFFALSE 58656
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58050: LD_ADDR_EXP 65
58054: PUSH
58055: LD_EXP 65
58059: PPUSH
58060: LD_VAR 0 1
58064: PPUSH
58065: LD_INT 5
58067: PPUSH
58068: CALL_OW 1
58072: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58073: LD_ADDR_VAR 0 2
58077: PUSH
58078: LD_INT 0
58080: PUSH
58081: LD_INT 0
58083: PUSH
58084: LD_INT 0
58086: PUSH
58087: LD_INT 0
58089: PUSH
58090: EMPTY
58091: LIST
58092: LIST
58093: LIST
58094: LIST
58095: ST_TO_ADDR
// if sci > 1 then
58096: LD_VAR 0 8
58100: PUSH
58101: LD_INT 1
58103: GREATER
58104: IFFALSE 58132
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58106: LD_ADDR_VAR 0 4
58110: PUSH
58111: LD_VAR 0 4
58115: PUSH
58116: LD_VAR 0 8
58120: PUSH
58121: LD_VAR 0 8
58125: PUSH
58126: LD_INT 1
58128: ARRAY
58129: DIFF
58130: DIFF
58131: ST_TO_ADDR
// if tmp and not sci then
58132: LD_VAR 0 4
58136: PUSH
58137: LD_VAR 0 8
58141: NOT
58142: AND
58143: IFFALSE 58212
// begin sort := SortBySkill ( tmp , 4 ) ;
58145: LD_ADDR_VAR 0 9
58149: PUSH
58150: LD_VAR 0 4
58154: PPUSH
58155: LD_INT 4
58157: PPUSH
58158: CALL 46217 0 2
58162: ST_TO_ADDR
// if sort then
58163: LD_VAR 0 9
58167: IFFALSE 58183
// p := sort [ 1 ] ;
58169: LD_ADDR_VAR 0 11
58173: PUSH
58174: LD_VAR 0 9
58178: PUSH
58179: LD_INT 1
58181: ARRAY
58182: ST_TO_ADDR
// if p then
58183: LD_VAR 0 11
58187: IFFALSE 58212
// result := Replace ( result , 4 , p ) ;
58189: LD_ADDR_VAR 0 2
58193: PUSH
58194: LD_VAR 0 2
58198: PPUSH
58199: LD_INT 4
58201: PPUSH
58202: LD_VAR 0 11
58206: PPUSH
58207: CALL_OW 1
58211: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58212: LD_ADDR_VAR 0 4
58216: PUSH
58217: LD_VAR 0 4
58221: PUSH
58222: LD_VAR 0 7
58226: DIFF
58227: ST_TO_ADDR
// if tmp and mech < 6 then
58228: LD_VAR 0 4
58232: PUSH
58233: LD_VAR 0 7
58237: PUSH
58238: LD_INT 6
58240: LESS
58241: AND
58242: IFFALSE 58430
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58244: LD_ADDR_VAR 0 9
58248: PUSH
58249: LD_VAR 0 4
58253: PUSH
58254: LD_VAR 0 8
58258: PUSH
58259: LD_VAR 0 7
58263: UNION
58264: DIFF
58265: PPUSH
58266: LD_INT 3
58268: PPUSH
58269: CALL 46217 0 2
58273: ST_TO_ADDR
// p := [ ] ;
58274: LD_ADDR_VAR 0 11
58278: PUSH
58279: EMPTY
58280: ST_TO_ADDR
// if sort then
58281: LD_VAR 0 9
58285: IFFALSE 58401
// for i = 1 to 6 - mech do
58287: LD_ADDR_VAR 0 3
58291: PUSH
58292: DOUBLE
58293: LD_INT 1
58295: DEC
58296: ST_TO_ADDR
58297: LD_INT 6
58299: PUSH
58300: LD_VAR 0 7
58304: MINUS
58305: PUSH
58306: FOR_TO
58307: IFFALSE 58399
// begin if i = sort then
58309: LD_VAR 0 3
58313: PUSH
58314: LD_VAR 0 9
58318: EQUAL
58319: IFFALSE 58323
// break ;
58321: GO 58399
// if GetClass ( i ) = 3 then
58323: LD_VAR 0 3
58327: PPUSH
58328: CALL_OW 257
58332: PUSH
58333: LD_INT 3
58335: EQUAL
58336: IFFALSE 58340
// continue ;
58338: GO 58306
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58340: LD_ADDR_VAR 0 11
58344: PUSH
58345: LD_VAR 0 11
58349: PPUSH
58350: LD_VAR 0 11
58354: PUSH
58355: LD_INT 1
58357: PLUS
58358: PPUSH
58359: LD_VAR 0 9
58363: PUSH
58364: LD_VAR 0 3
58368: ARRAY
58369: PPUSH
58370: CALL_OW 2
58374: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58375: LD_ADDR_VAR 0 4
58379: PUSH
58380: LD_VAR 0 4
58384: PUSH
58385: LD_VAR 0 9
58389: PUSH
58390: LD_VAR 0 3
58394: ARRAY
58395: DIFF
58396: ST_TO_ADDR
// end ;
58397: GO 58306
58399: POP
58400: POP
// if p then
58401: LD_VAR 0 11
58405: IFFALSE 58430
// result := Replace ( result , 3 , p ) ;
58407: LD_ADDR_VAR 0 2
58411: PUSH
58412: LD_VAR 0 2
58416: PPUSH
58417: LD_INT 3
58419: PPUSH
58420: LD_VAR 0 11
58424: PPUSH
58425: CALL_OW 1
58429: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58430: LD_ADDR_VAR 0 4
58434: PUSH
58435: LD_VAR 0 4
58439: PUSH
58440: LD_VAR 0 6
58444: DIFF
58445: ST_TO_ADDR
// if tmp and eng < 6 then
58446: LD_VAR 0 4
58450: PUSH
58451: LD_VAR 0 6
58455: PUSH
58456: LD_INT 6
58458: LESS
58459: AND
58460: IFFALSE 58654
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58462: LD_ADDR_VAR 0 9
58466: PUSH
58467: LD_VAR 0 4
58471: PUSH
58472: LD_VAR 0 8
58476: PUSH
58477: LD_VAR 0 7
58481: UNION
58482: PUSH
58483: LD_VAR 0 6
58487: UNION
58488: DIFF
58489: PPUSH
58490: LD_INT 2
58492: PPUSH
58493: CALL 46217 0 2
58497: ST_TO_ADDR
// p := [ ] ;
58498: LD_ADDR_VAR 0 11
58502: PUSH
58503: EMPTY
58504: ST_TO_ADDR
// if sort then
58505: LD_VAR 0 9
58509: IFFALSE 58625
// for i = 1 to 6 - eng do
58511: LD_ADDR_VAR 0 3
58515: PUSH
58516: DOUBLE
58517: LD_INT 1
58519: DEC
58520: ST_TO_ADDR
58521: LD_INT 6
58523: PUSH
58524: LD_VAR 0 6
58528: MINUS
58529: PUSH
58530: FOR_TO
58531: IFFALSE 58623
// begin if i = sort then
58533: LD_VAR 0 3
58537: PUSH
58538: LD_VAR 0 9
58542: EQUAL
58543: IFFALSE 58547
// break ;
58545: GO 58623
// if GetClass ( i ) = 2 then
58547: LD_VAR 0 3
58551: PPUSH
58552: CALL_OW 257
58556: PUSH
58557: LD_INT 2
58559: EQUAL
58560: IFFALSE 58564
// continue ;
58562: GO 58530
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58564: LD_ADDR_VAR 0 11
58568: PUSH
58569: LD_VAR 0 11
58573: PPUSH
58574: LD_VAR 0 11
58578: PUSH
58579: LD_INT 1
58581: PLUS
58582: PPUSH
58583: LD_VAR 0 9
58587: PUSH
58588: LD_VAR 0 3
58592: ARRAY
58593: PPUSH
58594: CALL_OW 2
58598: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58599: LD_ADDR_VAR 0 4
58603: PUSH
58604: LD_VAR 0 4
58608: PUSH
58609: LD_VAR 0 9
58613: PUSH
58614: LD_VAR 0 3
58618: ARRAY
58619: DIFF
58620: ST_TO_ADDR
// end ;
58621: GO 58530
58623: POP
58624: POP
// if p then
58625: LD_VAR 0 11
58629: IFFALSE 58654
// result := Replace ( result , 2 , p ) ;
58631: LD_ADDR_VAR 0 2
58635: PUSH
58636: LD_VAR 0 2
58640: PPUSH
58641: LD_INT 2
58643: PPUSH
58644: LD_VAR 0 11
58648: PPUSH
58649: CALL_OW 1
58653: ST_TO_ADDR
// end ; exit ;
58654: GO 59378
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58656: LD_EXP 50
58660: PUSH
58661: LD_EXP 49
58665: PUSH
58666: LD_VAR 0 1
58670: ARRAY
58671: ARRAY
58672: NOT
58673: PUSH
58674: LD_EXP 23
58678: PUSH
58679: LD_VAR 0 1
58683: ARRAY
58684: PPUSH
58685: LD_INT 30
58687: PUSH
58688: LD_INT 3
58690: PUSH
58691: EMPTY
58692: LIST
58693: LIST
58694: PPUSH
58695: CALL_OW 72
58699: AND
58700: PUSH
58701: LD_EXP 28
58705: PUSH
58706: LD_VAR 0 1
58710: ARRAY
58711: NOT
58712: AND
58713: IFFALSE 59378
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58715: LD_ADDR_EXP 65
58719: PUSH
58720: LD_EXP 65
58724: PPUSH
58725: LD_VAR 0 1
58729: PPUSH
58730: LD_INT 6
58732: PPUSH
58733: CALL_OW 1
58737: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58738: LD_ADDR_VAR 0 2
58742: PUSH
58743: LD_INT 0
58745: PUSH
58746: LD_INT 0
58748: PUSH
58749: LD_INT 0
58751: PUSH
58752: LD_INT 0
58754: PUSH
58755: EMPTY
58756: LIST
58757: LIST
58758: LIST
58759: LIST
58760: ST_TO_ADDR
// if sci >= 1 then
58761: LD_VAR 0 8
58765: PUSH
58766: LD_INT 1
58768: GREATEREQUAL
58769: IFFALSE 58791
// tmp := tmp diff sci [ 1 ] ;
58771: LD_ADDR_VAR 0 4
58775: PUSH
58776: LD_VAR 0 4
58780: PUSH
58781: LD_VAR 0 8
58785: PUSH
58786: LD_INT 1
58788: ARRAY
58789: DIFF
58790: ST_TO_ADDR
// if tmp and not sci then
58791: LD_VAR 0 4
58795: PUSH
58796: LD_VAR 0 8
58800: NOT
58801: AND
58802: IFFALSE 58871
// begin sort := SortBySkill ( tmp , 4 ) ;
58804: LD_ADDR_VAR 0 9
58808: PUSH
58809: LD_VAR 0 4
58813: PPUSH
58814: LD_INT 4
58816: PPUSH
58817: CALL 46217 0 2
58821: ST_TO_ADDR
// if sort then
58822: LD_VAR 0 9
58826: IFFALSE 58842
// p := sort [ 1 ] ;
58828: LD_ADDR_VAR 0 11
58832: PUSH
58833: LD_VAR 0 9
58837: PUSH
58838: LD_INT 1
58840: ARRAY
58841: ST_TO_ADDR
// if p then
58842: LD_VAR 0 11
58846: IFFALSE 58871
// result := Replace ( result , 4 , p ) ;
58848: LD_ADDR_VAR 0 2
58852: PUSH
58853: LD_VAR 0 2
58857: PPUSH
58858: LD_INT 4
58860: PPUSH
58861: LD_VAR 0 11
58865: PPUSH
58866: CALL_OW 1
58870: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58871: LD_ADDR_VAR 0 4
58875: PUSH
58876: LD_VAR 0 4
58880: PUSH
58881: LD_VAR 0 7
58885: DIFF
58886: ST_TO_ADDR
// if tmp and mech < 6 then
58887: LD_VAR 0 4
58891: PUSH
58892: LD_VAR 0 7
58896: PUSH
58897: LD_INT 6
58899: LESS
58900: AND
58901: IFFALSE 59083
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58903: LD_ADDR_VAR 0 9
58907: PUSH
58908: LD_VAR 0 4
58912: PUSH
58913: LD_VAR 0 7
58917: DIFF
58918: PPUSH
58919: LD_INT 3
58921: PPUSH
58922: CALL 46217 0 2
58926: ST_TO_ADDR
// p := [ ] ;
58927: LD_ADDR_VAR 0 11
58931: PUSH
58932: EMPTY
58933: ST_TO_ADDR
// if sort then
58934: LD_VAR 0 9
58938: IFFALSE 59054
// for i = 1 to 6 - mech do
58940: LD_ADDR_VAR 0 3
58944: PUSH
58945: DOUBLE
58946: LD_INT 1
58948: DEC
58949: ST_TO_ADDR
58950: LD_INT 6
58952: PUSH
58953: LD_VAR 0 7
58957: MINUS
58958: PUSH
58959: FOR_TO
58960: IFFALSE 59052
// begin if i = sort then
58962: LD_VAR 0 3
58966: PUSH
58967: LD_VAR 0 9
58971: EQUAL
58972: IFFALSE 58976
// break ;
58974: GO 59052
// if GetClass ( i ) = 3 then
58976: LD_VAR 0 3
58980: PPUSH
58981: CALL_OW 257
58985: PUSH
58986: LD_INT 3
58988: EQUAL
58989: IFFALSE 58993
// continue ;
58991: GO 58959
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58993: LD_ADDR_VAR 0 11
58997: PUSH
58998: LD_VAR 0 11
59002: PPUSH
59003: LD_VAR 0 11
59007: PUSH
59008: LD_INT 1
59010: PLUS
59011: PPUSH
59012: LD_VAR 0 9
59016: PUSH
59017: LD_VAR 0 3
59021: ARRAY
59022: PPUSH
59023: CALL_OW 2
59027: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59028: LD_ADDR_VAR 0 4
59032: PUSH
59033: LD_VAR 0 4
59037: PUSH
59038: LD_VAR 0 9
59042: PUSH
59043: LD_VAR 0 3
59047: ARRAY
59048: DIFF
59049: ST_TO_ADDR
// end ;
59050: GO 58959
59052: POP
59053: POP
// if p then
59054: LD_VAR 0 11
59058: IFFALSE 59083
// result := Replace ( result , 3 , p ) ;
59060: LD_ADDR_VAR 0 2
59064: PUSH
59065: LD_VAR 0 2
59069: PPUSH
59070: LD_INT 3
59072: PPUSH
59073: LD_VAR 0 11
59077: PPUSH
59078: CALL_OW 1
59082: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59083: LD_ADDR_VAR 0 4
59087: PUSH
59088: LD_VAR 0 4
59092: PUSH
59093: LD_VAR 0 6
59097: DIFF
59098: ST_TO_ADDR
// if tmp and eng < 4 then
59099: LD_VAR 0 4
59103: PUSH
59104: LD_VAR 0 6
59108: PUSH
59109: LD_INT 4
59111: LESS
59112: AND
59113: IFFALSE 59303
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59115: LD_ADDR_VAR 0 9
59119: PUSH
59120: LD_VAR 0 4
59124: PUSH
59125: LD_VAR 0 7
59129: PUSH
59130: LD_VAR 0 6
59134: UNION
59135: DIFF
59136: PPUSH
59137: LD_INT 2
59139: PPUSH
59140: CALL 46217 0 2
59144: ST_TO_ADDR
// p := [ ] ;
59145: LD_ADDR_VAR 0 11
59149: PUSH
59150: EMPTY
59151: ST_TO_ADDR
// if sort then
59152: LD_VAR 0 9
59156: IFFALSE 59272
// for i = 1 to 4 - eng do
59158: LD_ADDR_VAR 0 3
59162: PUSH
59163: DOUBLE
59164: LD_INT 1
59166: DEC
59167: ST_TO_ADDR
59168: LD_INT 4
59170: PUSH
59171: LD_VAR 0 6
59175: MINUS
59176: PUSH
59177: FOR_TO
59178: IFFALSE 59270
// begin if i = sort then
59180: LD_VAR 0 3
59184: PUSH
59185: LD_VAR 0 9
59189: EQUAL
59190: IFFALSE 59194
// break ;
59192: GO 59270
// if GetClass ( i ) = 2 then
59194: LD_VAR 0 3
59198: PPUSH
59199: CALL_OW 257
59203: PUSH
59204: LD_INT 2
59206: EQUAL
59207: IFFALSE 59211
// continue ;
59209: GO 59177
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59211: LD_ADDR_VAR 0 11
59215: PUSH
59216: LD_VAR 0 11
59220: PPUSH
59221: LD_VAR 0 11
59225: PUSH
59226: LD_INT 1
59228: PLUS
59229: PPUSH
59230: LD_VAR 0 9
59234: PUSH
59235: LD_VAR 0 3
59239: ARRAY
59240: PPUSH
59241: CALL_OW 2
59245: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59246: LD_ADDR_VAR 0 4
59250: PUSH
59251: LD_VAR 0 4
59255: PUSH
59256: LD_VAR 0 9
59260: PUSH
59261: LD_VAR 0 3
59265: ARRAY
59266: DIFF
59267: ST_TO_ADDR
// end ;
59268: GO 59177
59270: POP
59271: POP
// if p then
59272: LD_VAR 0 11
59276: IFFALSE 59301
// result := Replace ( result , 2 , p ) ;
59278: LD_ADDR_VAR 0 2
59282: PUSH
59283: LD_VAR 0 2
59287: PPUSH
59288: LD_INT 2
59290: PPUSH
59291: LD_VAR 0 11
59295: PPUSH
59296: CALL_OW 1
59300: ST_TO_ADDR
// end else
59301: GO 59347
// for i = eng downto 5 do
59303: LD_ADDR_VAR 0 3
59307: PUSH
59308: DOUBLE
59309: LD_VAR 0 6
59313: INC
59314: ST_TO_ADDR
59315: LD_INT 5
59317: PUSH
59318: FOR_DOWNTO
59319: IFFALSE 59345
// tmp := tmp union eng [ i ] ;
59321: LD_ADDR_VAR 0 4
59325: PUSH
59326: LD_VAR 0 4
59330: PUSH
59331: LD_VAR 0 6
59335: PUSH
59336: LD_VAR 0 3
59340: ARRAY
59341: UNION
59342: ST_TO_ADDR
59343: GO 59318
59345: POP
59346: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59347: LD_ADDR_VAR 0 2
59351: PUSH
59352: LD_VAR 0 2
59356: PPUSH
59357: LD_INT 1
59359: PPUSH
59360: LD_VAR 0 4
59364: PUSH
59365: LD_VAR 0 5
59369: DIFF
59370: PPUSH
59371: CALL_OW 1
59375: ST_TO_ADDR
// exit ;
59376: GO 59378
// end ; end ;
59378: LD_VAR 0 2
59382: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59383: LD_INT 0
59385: PPUSH
59386: PPUSH
59387: PPUSH
// if not mc_bases then
59388: LD_EXP 23
59392: NOT
59393: IFFALSE 59397
// exit ;
59395: GO 59539
// for i = 1 to mc_bases do
59397: LD_ADDR_VAR 0 2
59401: PUSH
59402: DOUBLE
59403: LD_INT 1
59405: DEC
59406: ST_TO_ADDR
59407: LD_EXP 23
59411: PUSH
59412: FOR_TO
59413: IFFALSE 59530
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59415: LD_ADDR_VAR 0 3
59419: PUSH
59420: LD_EXP 23
59424: PUSH
59425: LD_VAR 0 2
59429: ARRAY
59430: PPUSH
59431: LD_INT 21
59433: PUSH
59434: LD_INT 3
59436: PUSH
59437: EMPTY
59438: LIST
59439: LIST
59440: PUSH
59441: LD_INT 3
59443: PUSH
59444: LD_INT 2
59446: PUSH
59447: LD_INT 30
59449: PUSH
59450: LD_INT 29
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: LD_INT 30
59459: PUSH
59460: LD_INT 30
59462: PUSH
59463: EMPTY
59464: LIST
59465: LIST
59466: PUSH
59467: EMPTY
59468: LIST
59469: LIST
59470: LIST
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: PUSH
59476: LD_INT 3
59478: PUSH
59479: LD_INT 24
59481: PUSH
59482: LD_INT 1000
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: PUSH
59489: EMPTY
59490: LIST
59491: LIST
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: LIST
59497: PPUSH
59498: CALL_OW 72
59502: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59503: LD_ADDR_EXP 24
59507: PUSH
59508: LD_EXP 24
59512: PPUSH
59513: LD_VAR 0 2
59517: PPUSH
59518: LD_VAR 0 3
59522: PPUSH
59523: CALL_OW 1
59527: ST_TO_ADDR
// end ;
59528: GO 59412
59530: POP
59531: POP
// RaiseSailEvent ( 101 ) ;
59532: LD_INT 101
59534: PPUSH
59535: CALL_OW 427
// end ;
59539: LD_VAR 0 1
59543: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59544: LD_INT 0
59546: PPUSH
59547: PPUSH
59548: PPUSH
59549: PPUSH
59550: PPUSH
59551: PPUSH
59552: PPUSH
// if not mc_bases then
59553: LD_EXP 23
59557: NOT
59558: IFFALSE 59562
// exit ;
59560: GO 60124
// for i = 1 to mc_bases do
59562: LD_ADDR_VAR 0 2
59566: PUSH
59567: DOUBLE
59568: LD_INT 1
59570: DEC
59571: ST_TO_ADDR
59572: LD_EXP 23
59576: PUSH
59577: FOR_TO
59578: IFFALSE 60115
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59580: LD_ADDR_VAR 0 5
59584: PUSH
59585: LD_EXP 23
59589: PUSH
59590: LD_VAR 0 2
59594: ARRAY
59595: PUSH
59596: LD_EXP 52
59600: PUSH
59601: LD_VAR 0 2
59605: ARRAY
59606: UNION
59607: PPUSH
59608: LD_INT 21
59610: PUSH
59611: LD_INT 1
59613: PUSH
59614: EMPTY
59615: LIST
59616: LIST
59617: PUSH
59618: LD_INT 1
59620: PUSH
59621: LD_INT 3
59623: PUSH
59624: LD_INT 54
59626: PUSH
59627: EMPTY
59628: LIST
59629: PUSH
59630: EMPTY
59631: LIST
59632: LIST
59633: PUSH
59634: LD_INT 3
59636: PUSH
59637: LD_INT 24
59639: PUSH
59640: LD_INT 1000
59642: PUSH
59643: EMPTY
59644: LIST
59645: LIST
59646: PUSH
59647: EMPTY
59648: LIST
59649: LIST
59650: PUSH
59651: EMPTY
59652: LIST
59653: LIST
59654: LIST
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: PPUSH
59660: CALL_OW 72
59664: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59665: LD_ADDR_VAR 0 6
59669: PUSH
59670: LD_EXP 23
59674: PUSH
59675: LD_VAR 0 2
59679: ARRAY
59680: PPUSH
59681: LD_INT 21
59683: PUSH
59684: LD_INT 1
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: PUSH
59691: LD_INT 1
59693: PUSH
59694: LD_INT 3
59696: PUSH
59697: LD_INT 54
59699: PUSH
59700: EMPTY
59701: LIST
59702: PUSH
59703: EMPTY
59704: LIST
59705: LIST
59706: PUSH
59707: LD_INT 3
59709: PUSH
59710: LD_INT 24
59712: PUSH
59713: LD_INT 250
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: PUSH
59724: EMPTY
59725: LIST
59726: LIST
59727: LIST
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: PPUSH
59733: CALL_OW 72
59737: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59738: LD_ADDR_VAR 0 7
59742: PUSH
59743: LD_VAR 0 5
59747: PUSH
59748: LD_VAR 0 6
59752: DIFF
59753: ST_TO_ADDR
// if not need_heal_1 then
59754: LD_VAR 0 6
59758: NOT
59759: IFFALSE 59792
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59761: LD_ADDR_EXP 26
59765: PUSH
59766: LD_EXP 26
59770: PPUSH
59771: LD_VAR 0 2
59775: PUSH
59776: LD_INT 1
59778: PUSH
59779: EMPTY
59780: LIST
59781: LIST
59782: PPUSH
59783: EMPTY
59784: PPUSH
59785: CALL 16013 0 3
59789: ST_TO_ADDR
59790: GO 59862
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59792: LD_ADDR_EXP 26
59796: PUSH
59797: LD_EXP 26
59801: PPUSH
59802: LD_VAR 0 2
59806: PUSH
59807: LD_INT 1
59809: PUSH
59810: EMPTY
59811: LIST
59812: LIST
59813: PPUSH
59814: LD_EXP 26
59818: PUSH
59819: LD_VAR 0 2
59823: ARRAY
59824: PUSH
59825: LD_INT 1
59827: ARRAY
59828: PPUSH
59829: LD_INT 3
59831: PUSH
59832: LD_INT 24
59834: PUSH
59835: LD_INT 1000
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PPUSH
59846: CALL_OW 72
59850: PUSH
59851: LD_VAR 0 6
59855: UNION
59856: PPUSH
59857: CALL 16013 0 3
59861: ST_TO_ADDR
// if not need_heal_2 then
59862: LD_VAR 0 7
59866: NOT
59867: IFFALSE 59900
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59869: LD_ADDR_EXP 26
59873: PUSH
59874: LD_EXP 26
59878: PPUSH
59879: LD_VAR 0 2
59883: PUSH
59884: LD_INT 2
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PPUSH
59891: EMPTY
59892: PPUSH
59893: CALL 16013 0 3
59897: ST_TO_ADDR
59898: GO 59932
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59900: LD_ADDR_EXP 26
59904: PUSH
59905: LD_EXP 26
59909: PPUSH
59910: LD_VAR 0 2
59914: PUSH
59915: LD_INT 2
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: PPUSH
59922: LD_VAR 0 7
59926: PPUSH
59927: CALL 16013 0 3
59931: ST_TO_ADDR
// if need_heal_2 then
59932: LD_VAR 0 7
59936: IFFALSE 60097
// for j in need_heal_2 do
59938: LD_ADDR_VAR 0 3
59942: PUSH
59943: LD_VAR 0 7
59947: PUSH
59948: FOR_IN
59949: IFFALSE 60095
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59951: LD_ADDR_VAR 0 5
59955: PUSH
59956: LD_EXP 23
59960: PUSH
59961: LD_VAR 0 2
59965: ARRAY
59966: PPUSH
59967: LD_INT 2
59969: PUSH
59970: LD_INT 30
59972: PUSH
59973: LD_INT 6
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: PUSH
59980: LD_INT 30
59982: PUSH
59983: LD_INT 7
59985: PUSH
59986: EMPTY
59987: LIST
59988: LIST
59989: PUSH
59990: LD_INT 30
59992: PUSH
59993: LD_INT 8
59995: PUSH
59996: EMPTY
59997: LIST
59998: LIST
59999: PUSH
60000: LD_INT 30
60002: PUSH
60003: LD_INT 0
60005: PUSH
60006: EMPTY
60007: LIST
60008: LIST
60009: PUSH
60010: LD_INT 30
60012: PUSH
60013: LD_INT 1
60015: PUSH
60016: EMPTY
60017: LIST
60018: LIST
60019: PUSH
60020: EMPTY
60021: LIST
60022: LIST
60023: LIST
60024: LIST
60025: LIST
60026: LIST
60027: PPUSH
60028: CALL_OW 72
60032: ST_TO_ADDR
// if tmp then
60033: LD_VAR 0 5
60037: IFFALSE 60093
// begin k := NearestUnitToUnit ( tmp , j ) ;
60039: LD_ADDR_VAR 0 4
60043: PUSH
60044: LD_VAR 0 5
60048: PPUSH
60049: LD_VAR 0 3
60053: PPUSH
60054: CALL_OW 74
60058: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60059: LD_VAR 0 3
60063: PPUSH
60064: LD_VAR 0 4
60068: PPUSH
60069: CALL_OW 296
60073: PUSH
60074: LD_INT 5
60076: GREATER
60077: IFFALSE 60093
// ComMoveToNearbyEntrance ( j , k ) ;
60079: LD_VAR 0 3
60083: PPUSH
60084: LD_VAR 0 4
60088: PPUSH
60089: CALL 48575 0 2
// end ; end ;
60093: GO 59948
60095: POP
60096: POP
// if not need_heal_1 and not need_heal_2 then
60097: LD_VAR 0 6
60101: NOT
60102: PUSH
60103: LD_VAR 0 7
60107: NOT
60108: AND
60109: IFFALSE 60113
// continue ;
60111: GO 59577
// end ;
60113: GO 59577
60115: POP
60116: POP
// RaiseSailEvent ( 102 ) ;
60117: LD_INT 102
60119: PPUSH
60120: CALL_OW 427
// end ;
60124: LD_VAR 0 1
60128: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60129: LD_INT 0
60131: PPUSH
60132: PPUSH
60133: PPUSH
60134: PPUSH
60135: PPUSH
60136: PPUSH
60137: PPUSH
60138: PPUSH
// if not mc_bases then
60139: LD_EXP 23
60143: NOT
60144: IFFALSE 60148
// exit ;
60146: GO 61031
// for i = 1 to mc_bases do
60148: LD_ADDR_VAR 0 2
60152: PUSH
60153: DOUBLE
60154: LD_INT 1
60156: DEC
60157: ST_TO_ADDR
60158: LD_EXP 23
60162: PUSH
60163: FOR_TO
60164: IFFALSE 61029
// begin if not mc_building_need_repair [ i ] then
60166: LD_EXP 24
60170: PUSH
60171: LD_VAR 0 2
60175: ARRAY
60176: NOT
60177: IFFALSE 60364
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60179: LD_ADDR_VAR 0 6
60183: PUSH
60184: LD_EXP 42
60188: PUSH
60189: LD_VAR 0 2
60193: ARRAY
60194: PPUSH
60195: LD_INT 3
60197: PUSH
60198: LD_INT 24
60200: PUSH
60201: LD_INT 1000
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: PUSH
60212: LD_INT 2
60214: PUSH
60215: LD_INT 34
60217: PUSH
60218: LD_INT 13
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: PUSH
60225: LD_INT 34
60227: PUSH
60228: LD_INT 52
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 34
60237: PUSH
60238: LD_EXP 73
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: LIST
60251: LIST
60252: PUSH
60253: EMPTY
60254: LIST
60255: LIST
60256: PPUSH
60257: CALL_OW 72
60261: ST_TO_ADDR
// if cranes then
60262: LD_VAR 0 6
60266: IFFALSE 60328
// for j in cranes do
60268: LD_ADDR_VAR 0 3
60272: PUSH
60273: LD_VAR 0 6
60277: PUSH
60278: FOR_IN
60279: IFFALSE 60326
// if not IsInArea ( j , mc_parking [ i ] ) then
60281: LD_VAR 0 3
60285: PPUSH
60286: LD_EXP 47
60290: PUSH
60291: LD_VAR 0 2
60295: ARRAY
60296: PPUSH
60297: CALL_OW 308
60301: NOT
60302: IFFALSE 60324
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60304: LD_VAR 0 3
60308: PPUSH
60309: LD_EXP 47
60313: PUSH
60314: LD_VAR 0 2
60318: ARRAY
60319: PPUSH
60320: CALL_OW 113
60324: GO 60278
60326: POP
60327: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60328: LD_ADDR_EXP 25
60332: PUSH
60333: LD_EXP 25
60337: PPUSH
60338: LD_VAR 0 2
60342: PPUSH
60343: EMPTY
60344: PPUSH
60345: CALL_OW 1
60349: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60350: LD_VAR 0 2
60354: PPUSH
60355: LD_INT 101
60357: PPUSH
60358: CALL 55216 0 2
// continue ;
60362: GO 60163
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60364: LD_ADDR_EXP 29
60368: PUSH
60369: LD_EXP 29
60373: PPUSH
60374: LD_VAR 0 2
60378: PPUSH
60379: EMPTY
60380: PPUSH
60381: CALL_OW 1
60385: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60386: LD_VAR 0 2
60390: PPUSH
60391: LD_INT 103
60393: PPUSH
60394: CALL 55216 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60398: LD_ADDR_VAR 0 5
60402: PUSH
60403: LD_EXP 23
60407: PUSH
60408: LD_VAR 0 2
60412: ARRAY
60413: PUSH
60414: LD_EXP 52
60418: PUSH
60419: LD_VAR 0 2
60423: ARRAY
60424: UNION
60425: PPUSH
60426: LD_INT 2
60428: PUSH
60429: LD_INT 25
60431: PUSH
60432: LD_INT 2
60434: PUSH
60435: EMPTY
60436: LIST
60437: LIST
60438: PUSH
60439: LD_INT 25
60441: PUSH
60442: LD_INT 16
60444: PUSH
60445: EMPTY
60446: LIST
60447: LIST
60448: PUSH
60449: EMPTY
60450: LIST
60451: LIST
60452: LIST
60453: PUSH
60454: EMPTY
60455: LIST
60456: PPUSH
60457: CALL_OW 72
60461: ST_TO_ADDR
// if mc_need_heal [ i ] then
60462: LD_EXP 26
60466: PUSH
60467: LD_VAR 0 2
60471: ARRAY
60472: IFFALSE 60516
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60474: LD_ADDR_VAR 0 5
60478: PUSH
60479: LD_VAR 0 5
60483: PUSH
60484: LD_EXP 26
60488: PUSH
60489: LD_VAR 0 2
60493: ARRAY
60494: PUSH
60495: LD_INT 1
60497: ARRAY
60498: PUSH
60499: LD_EXP 26
60503: PUSH
60504: LD_VAR 0 2
60508: ARRAY
60509: PUSH
60510: LD_INT 2
60512: ARRAY
60513: UNION
60514: DIFF
60515: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60516: LD_ADDR_VAR 0 6
60520: PUSH
60521: LD_EXP 42
60525: PUSH
60526: LD_VAR 0 2
60530: ARRAY
60531: PPUSH
60532: LD_INT 2
60534: PUSH
60535: LD_INT 34
60537: PUSH
60538: LD_INT 13
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: LD_INT 34
60547: PUSH
60548: LD_INT 52
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: PUSH
60555: LD_INT 34
60557: PUSH
60558: LD_EXP 73
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: PUSH
60567: EMPTY
60568: LIST
60569: LIST
60570: LIST
60571: LIST
60572: PPUSH
60573: CALL_OW 72
60577: ST_TO_ADDR
// if cranes then
60578: LD_VAR 0 6
60582: IFFALSE 60718
// begin for j in cranes do
60584: LD_ADDR_VAR 0 3
60588: PUSH
60589: LD_VAR 0 6
60593: PUSH
60594: FOR_IN
60595: IFFALSE 60716
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60597: LD_VAR 0 3
60601: PPUSH
60602: CALL_OW 256
60606: PUSH
60607: LD_INT 1000
60609: EQUAL
60610: PUSH
60611: LD_VAR 0 3
60615: PPUSH
60616: CALL_OW 314
60620: NOT
60621: AND
60622: IFFALSE 60656
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60624: LD_VAR 0 3
60628: PPUSH
60629: LD_EXP 24
60633: PUSH
60634: LD_VAR 0 2
60638: ARRAY
60639: PPUSH
60640: LD_VAR 0 3
60644: PPUSH
60645: CALL_OW 74
60649: PPUSH
60650: CALL_OW 130
60654: GO 60714
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60656: LD_VAR 0 3
60660: PPUSH
60661: CALL_OW 256
60665: PUSH
60666: LD_INT 500
60668: LESS
60669: PUSH
60670: LD_VAR 0 3
60674: PPUSH
60675: LD_EXP 47
60679: PUSH
60680: LD_VAR 0 2
60684: ARRAY
60685: PPUSH
60686: CALL_OW 308
60690: NOT
60691: AND
60692: IFFALSE 60714
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60694: LD_VAR 0 3
60698: PPUSH
60699: LD_EXP 47
60703: PUSH
60704: LD_VAR 0 2
60708: ARRAY
60709: PPUSH
60710: CALL_OW 113
// end ;
60714: GO 60594
60716: POP
60717: POP
// end ; if tmp > 3 then
60718: LD_VAR 0 5
60722: PUSH
60723: LD_INT 3
60725: GREATER
60726: IFFALSE 60746
// tmp := ShrinkArray ( tmp , 4 ) ;
60728: LD_ADDR_VAR 0 5
60732: PUSH
60733: LD_VAR 0 5
60737: PPUSH
60738: LD_INT 4
60740: PPUSH
60741: CALL 48023 0 2
60745: ST_TO_ADDR
// if not tmp then
60746: LD_VAR 0 5
60750: NOT
60751: IFFALSE 60755
// continue ;
60753: GO 60163
// for j in tmp do
60755: LD_ADDR_VAR 0 3
60759: PUSH
60760: LD_VAR 0 5
60764: PUSH
60765: FOR_IN
60766: IFFALSE 61025
// begin if IsInUnit ( j ) then
60768: LD_VAR 0 3
60772: PPUSH
60773: CALL_OW 310
60777: IFFALSE 60788
// ComExitBuilding ( j ) ;
60779: LD_VAR 0 3
60783: PPUSH
60784: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60788: LD_VAR 0 3
60792: PUSH
60793: LD_EXP 25
60797: PUSH
60798: LD_VAR 0 2
60802: ARRAY
60803: IN
60804: NOT
60805: IFFALSE 60863
// begin SetTag ( j , 101 ) ;
60807: LD_VAR 0 3
60811: PPUSH
60812: LD_INT 101
60814: PPUSH
60815: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60819: LD_ADDR_EXP 25
60823: PUSH
60824: LD_EXP 25
60828: PPUSH
60829: LD_VAR 0 2
60833: PUSH
60834: LD_EXP 25
60838: PUSH
60839: LD_VAR 0 2
60843: ARRAY
60844: PUSH
60845: LD_INT 1
60847: PLUS
60848: PUSH
60849: EMPTY
60850: LIST
60851: LIST
60852: PPUSH
60853: LD_VAR 0 3
60857: PPUSH
60858: CALL 16013 0 3
60862: ST_TO_ADDR
// end ; wait ( 1 ) ;
60863: LD_INT 1
60865: PPUSH
60866: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60870: LD_ADDR_VAR 0 7
60874: PUSH
60875: LD_EXP 24
60879: PUSH
60880: LD_VAR 0 2
60884: ARRAY
60885: ST_TO_ADDR
// if mc_scan [ i ] then
60886: LD_EXP 46
60890: PUSH
60891: LD_VAR 0 2
60895: ARRAY
60896: IFFALSE 60958
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60898: LD_ADDR_VAR 0 7
60902: PUSH
60903: LD_EXP 24
60907: PUSH
60908: LD_VAR 0 2
60912: ARRAY
60913: PPUSH
60914: LD_INT 3
60916: PUSH
60917: LD_INT 30
60919: PUSH
60920: LD_INT 32
60922: PUSH
60923: EMPTY
60924: LIST
60925: LIST
60926: PUSH
60927: LD_INT 30
60929: PUSH
60930: LD_INT 33
60932: PUSH
60933: EMPTY
60934: LIST
60935: LIST
60936: PUSH
60937: LD_INT 30
60939: PUSH
60940: LD_INT 31
60942: PUSH
60943: EMPTY
60944: LIST
60945: LIST
60946: PUSH
60947: EMPTY
60948: LIST
60949: LIST
60950: LIST
60951: LIST
60952: PPUSH
60953: CALL_OW 72
60957: ST_TO_ADDR
// if not to_repair_tmp then
60958: LD_VAR 0 7
60962: NOT
60963: IFFALSE 60967
// continue ;
60965: GO 60765
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60967: LD_ADDR_VAR 0 8
60971: PUSH
60972: LD_VAR 0 7
60976: PPUSH
60977: LD_VAR 0 3
60981: PPUSH
60982: CALL_OW 74
60986: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60987: LD_VAR 0 8
60991: PPUSH
60992: LD_INT 16
60994: PPUSH
60995: CALL 18612 0 2
60999: PUSH
61000: LD_INT 4
61002: ARRAY
61003: PUSH
61004: LD_INT 10
61006: LESS
61007: IFFALSE 61023
// ComRepairBuilding ( j , to_repair ) ;
61009: LD_VAR 0 3
61013: PPUSH
61014: LD_VAR 0 8
61018: PPUSH
61019: CALL_OW 130
// end ;
61023: GO 60765
61025: POP
61026: POP
// end ;
61027: GO 60163
61029: POP
61030: POP
// end ;
61031: LD_VAR 0 1
61035: RET
// export function MC_Heal ; var i , j , tmp ; begin
61036: LD_INT 0
61038: PPUSH
61039: PPUSH
61040: PPUSH
61041: PPUSH
// if not mc_bases then
61042: LD_EXP 23
61046: NOT
61047: IFFALSE 61051
// exit ;
61049: GO 61453
// for i = 1 to mc_bases do
61051: LD_ADDR_VAR 0 2
61055: PUSH
61056: DOUBLE
61057: LD_INT 1
61059: DEC
61060: ST_TO_ADDR
61061: LD_EXP 23
61065: PUSH
61066: FOR_TO
61067: IFFALSE 61451
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61069: LD_EXP 26
61073: PUSH
61074: LD_VAR 0 2
61078: ARRAY
61079: PUSH
61080: LD_INT 1
61082: ARRAY
61083: NOT
61084: PUSH
61085: LD_EXP 26
61089: PUSH
61090: LD_VAR 0 2
61094: ARRAY
61095: PUSH
61096: LD_INT 2
61098: ARRAY
61099: NOT
61100: AND
61101: IFFALSE 61139
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61103: LD_ADDR_EXP 27
61107: PUSH
61108: LD_EXP 27
61112: PPUSH
61113: LD_VAR 0 2
61117: PPUSH
61118: EMPTY
61119: PPUSH
61120: CALL_OW 1
61124: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61125: LD_VAR 0 2
61129: PPUSH
61130: LD_INT 102
61132: PPUSH
61133: CALL 55216 0 2
// continue ;
61137: GO 61066
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61139: LD_ADDR_VAR 0 4
61143: PUSH
61144: LD_EXP 23
61148: PUSH
61149: LD_VAR 0 2
61153: ARRAY
61154: PPUSH
61155: LD_INT 25
61157: PUSH
61158: LD_INT 4
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: PPUSH
61165: CALL_OW 72
61169: ST_TO_ADDR
// if not tmp then
61170: LD_VAR 0 4
61174: NOT
61175: IFFALSE 61179
// continue ;
61177: GO 61066
// if mc_taming [ i ] then
61179: LD_EXP 54
61183: PUSH
61184: LD_VAR 0 2
61188: ARRAY
61189: IFFALSE 61213
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61191: LD_ADDR_EXP 54
61195: PUSH
61196: LD_EXP 54
61200: PPUSH
61201: LD_VAR 0 2
61205: PPUSH
61206: EMPTY
61207: PPUSH
61208: CALL_OW 1
61212: ST_TO_ADDR
// for j in tmp do
61213: LD_ADDR_VAR 0 3
61217: PUSH
61218: LD_VAR 0 4
61222: PUSH
61223: FOR_IN
61224: IFFALSE 61447
// begin if IsInUnit ( j ) then
61226: LD_VAR 0 3
61230: PPUSH
61231: CALL_OW 310
61235: IFFALSE 61246
// ComExitBuilding ( j ) ;
61237: LD_VAR 0 3
61241: PPUSH
61242: CALL_OW 122
// if not j in mc_healers [ i ] then
61246: LD_VAR 0 3
61250: PUSH
61251: LD_EXP 27
61255: PUSH
61256: LD_VAR 0 2
61260: ARRAY
61261: IN
61262: NOT
61263: IFFALSE 61309
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61265: LD_ADDR_EXP 27
61269: PUSH
61270: LD_EXP 27
61274: PPUSH
61275: LD_VAR 0 2
61279: PUSH
61280: LD_EXP 27
61284: PUSH
61285: LD_VAR 0 2
61289: ARRAY
61290: PUSH
61291: LD_INT 1
61293: PLUS
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: PPUSH
61299: LD_VAR 0 3
61303: PPUSH
61304: CALL 16013 0 3
61308: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61309: LD_VAR 0 3
61313: PPUSH
61314: CALL_OW 110
61318: PUSH
61319: LD_INT 102
61321: NONEQUAL
61322: IFFALSE 61336
// SetTag ( j , 102 ) ;
61324: LD_VAR 0 3
61328: PPUSH
61329: LD_INT 102
61331: PPUSH
61332: CALL_OW 109
// Wait ( 3 ) ;
61336: LD_INT 3
61338: PPUSH
61339: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61343: LD_EXP 26
61347: PUSH
61348: LD_VAR 0 2
61352: ARRAY
61353: PUSH
61354: LD_INT 1
61356: ARRAY
61357: IFFALSE 61389
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61359: LD_VAR 0 3
61363: PPUSH
61364: LD_EXP 26
61368: PUSH
61369: LD_VAR 0 2
61373: ARRAY
61374: PUSH
61375: LD_INT 1
61377: ARRAY
61378: PUSH
61379: LD_INT 1
61381: ARRAY
61382: PPUSH
61383: CALL_OW 128
61387: GO 61445
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61389: LD_VAR 0 3
61393: PPUSH
61394: CALL_OW 314
61398: NOT
61399: PUSH
61400: LD_EXP 26
61404: PUSH
61405: LD_VAR 0 2
61409: ARRAY
61410: PUSH
61411: LD_INT 2
61413: ARRAY
61414: AND
61415: IFFALSE 61445
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61417: LD_VAR 0 3
61421: PPUSH
61422: LD_EXP 26
61426: PUSH
61427: LD_VAR 0 2
61431: ARRAY
61432: PUSH
61433: LD_INT 2
61435: ARRAY
61436: PUSH
61437: LD_INT 1
61439: ARRAY
61440: PPUSH
61441: CALL_OW 128
// end ;
61445: GO 61223
61447: POP
61448: POP
// end ;
61449: GO 61066
61451: POP
61452: POP
// end ;
61453: LD_VAR 0 1
61457: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61458: LD_INT 0
61460: PPUSH
61461: PPUSH
61462: PPUSH
61463: PPUSH
61464: PPUSH
// if not mc_bases then
61465: LD_EXP 23
61469: NOT
61470: IFFALSE 61474
// exit ;
61472: GO 62645
// for i = 1 to mc_bases do
61474: LD_ADDR_VAR 0 2
61478: PUSH
61479: DOUBLE
61480: LD_INT 1
61482: DEC
61483: ST_TO_ADDR
61484: LD_EXP 23
61488: PUSH
61489: FOR_TO
61490: IFFALSE 62643
// begin if mc_scan [ i ] then
61492: LD_EXP 46
61496: PUSH
61497: LD_VAR 0 2
61501: ARRAY
61502: IFFALSE 61506
// continue ;
61504: GO 61489
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61506: LD_EXP 28
61510: PUSH
61511: LD_VAR 0 2
61515: ARRAY
61516: NOT
61517: PUSH
61518: LD_EXP 30
61522: PUSH
61523: LD_VAR 0 2
61527: ARRAY
61528: NOT
61529: AND
61530: PUSH
61531: LD_EXP 29
61535: PUSH
61536: LD_VAR 0 2
61540: ARRAY
61541: AND
61542: IFFALSE 61580
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61544: LD_ADDR_EXP 29
61548: PUSH
61549: LD_EXP 29
61553: PPUSH
61554: LD_VAR 0 2
61558: PPUSH
61559: EMPTY
61560: PPUSH
61561: CALL_OW 1
61565: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61566: LD_VAR 0 2
61570: PPUSH
61571: LD_INT 103
61573: PPUSH
61574: CALL 55216 0 2
// continue ;
61578: GO 61489
// end ; if mc_construct_list [ i ] then
61580: LD_EXP 30
61584: PUSH
61585: LD_VAR 0 2
61589: ARRAY
61590: IFFALSE 61810
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61592: LD_ADDR_VAR 0 4
61596: PUSH
61597: LD_EXP 23
61601: PUSH
61602: LD_VAR 0 2
61606: ARRAY
61607: PPUSH
61608: LD_INT 25
61610: PUSH
61611: LD_INT 2
61613: PUSH
61614: EMPTY
61615: LIST
61616: LIST
61617: PPUSH
61618: CALL_OW 72
61622: PUSH
61623: LD_EXP 25
61627: PUSH
61628: LD_VAR 0 2
61632: ARRAY
61633: DIFF
61634: ST_TO_ADDR
// if not tmp then
61635: LD_VAR 0 4
61639: NOT
61640: IFFALSE 61644
// continue ;
61642: GO 61489
// for j in tmp do
61644: LD_ADDR_VAR 0 3
61648: PUSH
61649: LD_VAR 0 4
61653: PUSH
61654: FOR_IN
61655: IFFALSE 61806
// begin if not mc_builders [ i ] then
61657: LD_EXP 29
61661: PUSH
61662: LD_VAR 0 2
61666: ARRAY
61667: NOT
61668: IFFALSE 61726
// begin SetTag ( j , 103 ) ;
61670: LD_VAR 0 3
61674: PPUSH
61675: LD_INT 103
61677: PPUSH
61678: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61682: LD_ADDR_EXP 29
61686: PUSH
61687: LD_EXP 29
61691: PPUSH
61692: LD_VAR 0 2
61696: PUSH
61697: LD_EXP 29
61701: PUSH
61702: LD_VAR 0 2
61706: ARRAY
61707: PUSH
61708: LD_INT 1
61710: PLUS
61711: PUSH
61712: EMPTY
61713: LIST
61714: LIST
61715: PPUSH
61716: LD_VAR 0 3
61720: PPUSH
61721: CALL 16013 0 3
61725: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61726: LD_VAR 0 3
61730: PPUSH
61731: CALL_OW 310
61735: IFFALSE 61746
// ComExitBuilding ( j ) ;
61737: LD_VAR 0 3
61741: PPUSH
61742: CALL_OW 122
// wait ( 3 ) ;
61746: LD_INT 3
61748: PPUSH
61749: CALL_OW 67
// if not mc_construct_list [ i ] then
61753: LD_EXP 30
61757: PUSH
61758: LD_VAR 0 2
61762: ARRAY
61763: NOT
61764: IFFALSE 61768
// break ;
61766: GO 61806
// if not HasTask ( j ) then
61768: LD_VAR 0 3
61772: PPUSH
61773: CALL_OW 314
61777: NOT
61778: IFFALSE 61804
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61780: LD_VAR 0 3
61784: PPUSH
61785: LD_EXP 30
61789: PUSH
61790: LD_VAR 0 2
61794: ARRAY
61795: PUSH
61796: LD_INT 1
61798: ARRAY
61799: PPUSH
61800: CALL 18876 0 2
// end ;
61804: GO 61654
61806: POP
61807: POP
// end else
61808: GO 62641
// if mc_build_list [ i ] then
61810: LD_EXP 28
61814: PUSH
61815: LD_VAR 0 2
61819: ARRAY
61820: IFFALSE 62641
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61822: LD_ADDR_VAR 0 5
61826: PUSH
61827: LD_EXP 23
61831: PUSH
61832: LD_VAR 0 2
61836: ARRAY
61837: PPUSH
61838: LD_INT 2
61840: PUSH
61841: LD_INT 30
61843: PUSH
61844: LD_INT 0
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: PUSH
61851: LD_INT 30
61853: PUSH
61854: LD_INT 1
61856: PUSH
61857: EMPTY
61858: LIST
61859: LIST
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: LIST
61865: PPUSH
61866: CALL_OW 72
61870: ST_TO_ADDR
// if depot then
61871: LD_VAR 0 5
61875: IFFALSE 61893
// depot := depot [ 1 ] else
61877: LD_ADDR_VAR 0 5
61881: PUSH
61882: LD_VAR 0 5
61886: PUSH
61887: LD_INT 1
61889: ARRAY
61890: ST_TO_ADDR
61891: GO 61901
// depot := 0 ;
61893: LD_ADDR_VAR 0 5
61897: PUSH
61898: LD_INT 0
61900: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61901: LD_EXP 28
61905: PUSH
61906: LD_VAR 0 2
61910: ARRAY
61911: PUSH
61912: LD_INT 1
61914: ARRAY
61915: PUSH
61916: LD_INT 1
61918: ARRAY
61919: PPUSH
61920: CALL 18700 0 1
61924: PUSH
61925: LD_EXP 23
61929: PUSH
61930: LD_VAR 0 2
61934: ARRAY
61935: PPUSH
61936: LD_INT 2
61938: PUSH
61939: LD_INT 30
61941: PUSH
61942: LD_INT 2
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 30
61951: PUSH
61952: LD_INT 3
61954: PUSH
61955: EMPTY
61956: LIST
61957: LIST
61958: PUSH
61959: EMPTY
61960: LIST
61961: LIST
61962: LIST
61963: PPUSH
61964: CALL_OW 72
61968: NOT
61969: AND
61970: IFFALSE 62075
// begin for j = 1 to mc_build_list [ i ] do
61972: LD_ADDR_VAR 0 3
61976: PUSH
61977: DOUBLE
61978: LD_INT 1
61980: DEC
61981: ST_TO_ADDR
61982: LD_EXP 28
61986: PUSH
61987: LD_VAR 0 2
61991: ARRAY
61992: PUSH
61993: FOR_TO
61994: IFFALSE 62073
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61996: LD_EXP 28
62000: PUSH
62001: LD_VAR 0 2
62005: ARRAY
62006: PUSH
62007: LD_VAR 0 3
62011: ARRAY
62012: PUSH
62013: LD_INT 1
62015: ARRAY
62016: PUSH
62017: LD_INT 2
62019: EQUAL
62020: IFFALSE 62071
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62022: LD_ADDR_EXP 28
62026: PUSH
62027: LD_EXP 28
62031: PPUSH
62032: LD_VAR 0 2
62036: PPUSH
62037: LD_EXP 28
62041: PUSH
62042: LD_VAR 0 2
62046: ARRAY
62047: PPUSH
62048: LD_VAR 0 3
62052: PPUSH
62053: LD_INT 1
62055: PPUSH
62056: LD_INT 0
62058: PPUSH
62059: CALL 15431 0 4
62063: PPUSH
62064: CALL_OW 1
62068: ST_TO_ADDR
// break ;
62069: GO 62073
// end ;
62071: GO 61993
62073: POP
62074: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62075: LD_EXP 28
62079: PUSH
62080: LD_VAR 0 2
62084: ARRAY
62085: PUSH
62086: LD_INT 1
62088: ARRAY
62089: PUSH
62090: LD_INT 1
62092: ARRAY
62093: PUSH
62094: LD_INT 0
62096: EQUAL
62097: PUSH
62098: LD_VAR 0 5
62102: PUSH
62103: LD_VAR 0 5
62107: PPUSH
62108: LD_EXP 28
62112: PUSH
62113: LD_VAR 0 2
62117: ARRAY
62118: PUSH
62119: LD_INT 1
62121: ARRAY
62122: PUSH
62123: LD_INT 1
62125: ARRAY
62126: PPUSH
62127: LD_EXP 28
62131: PUSH
62132: LD_VAR 0 2
62136: ARRAY
62137: PUSH
62138: LD_INT 1
62140: ARRAY
62141: PUSH
62142: LD_INT 2
62144: ARRAY
62145: PPUSH
62146: LD_EXP 28
62150: PUSH
62151: LD_VAR 0 2
62155: ARRAY
62156: PUSH
62157: LD_INT 1
62159: ARRAY
62160: PUSH
62161: LD_INT 3
62163: ARRAY
62164: PPUSH
62165: LD_EXP 28
62169: PUSH
62170: LD_VAR 0 2
62174: ARRAY
62175: PUSH
62176: LD_INT 1
62178: ARRAY
62179: PUSH
62180: LD_INT 4
62182: ARRAY
62183: PPUSH
62184: CALL 24116 0 5
62188: AND
62189: OR
62190: IFFALSE 62471
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62192: LD_ADDR_VAR 0 4
62196: PUSH
62197: LD_EXP 23
62201: PUSH
62202: LD_VAR 0 2
62206: ARRAY
62207: PPUSH
62208: LD_INT 25
62210: PUSH
62211: LD_INT 2
62213: PUSH
62214: EMPTY
62215: LIST
62216: LIST
62217: PPUSH
62218: CALL_OW 72
62222: PUSH
62223: LD_EXP 25
62227: PUSH
62228: LD_VAR 0 2
62232: ARRAY
62233: DIFF
62234: ST_TO_ADDR
// if not tmp then
62235: LD_VAR 0 4
62239: NOT
62240: IFFALSE 62244
// continue ;
62242: GO 61489
// for j in tmp do
62244: LD_ADDR_VAR 0 3
62248: PUSH
62249: LD_VAR 0 4
62253: PUSH
62254: FOR_IN
62255: IFFALSE 62467
// begin if not mc_builders [ i ] then
62257: LD_EXP 29
62261: PUSH
62262: LD_VAR 0 2
62266: ARRAY
62267: NOT
62268: IFFALSE 62326
// begin SetTag ( j , 103 ) ;
62270: LD_VAR 0 3
62274: PPUSH
62275: LD_INT 103
62277: PPUSH
62278: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62282: LD_ADDR_EXP 29
62286: PUSH
62287: LD_EXP 29
62291: PPUSH
62292: LD_VAR 0 2
62296: PUSH
62297: LD_EXP 29
62301: PUSH
62302: LD_VAR 0 2
62306: ARRAY
62307: PUSH
62308: LD_INT 1
62310: PLUS
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: PPUSH
62316: LD_VAR 0 3
62320: PPUSH
62321: CALL 16013 0 3
62325: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62326: LD_VAR 0 3
62330: PPUSH
62331: CALL_OW 310
62335: IFFALSE 62346
// ComExitBuilding ( j ) ;
62337: LD_VAR 0 3
62341: PPUSH
62342: CALL_OW 122
// wait ( 3 ) ;
62346: LD_INT 3
62348: PPUSH
62349: CALL_OW 67
// if not mc_build_list [ i ] then
62353: LD_EXP 28
62357: PUSH
62358: LD_VAR 0 2
62362: ARRAY
62363: NOT
62364: IFFALSE 62368
// break ;
62366: GO 62467
// if not HasTask ( j ) then
62368: LD_VAR 0 3
62372: PPUSH
62373: CALL_OW 314
62377: NOT
62378: IFFALSE 62465
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62380: LD_VAR 0 3
62384: PPUSH
62385: LD_EXP 28
62389: PUSH
62390: LD_VAR 0 2
62394: ARRAY
62395: PUSH
62396: LD_INT 1
62398: ARRAY
62399: PUSH
62400: LD_INT 1
62402: ARRAY
62403: PPUSH
62404: LD_EXP 28
62408: PUSH
62409: LD_VAR 0 2
62413: ARRAY
62414: PUSH
62415: LD_INT 1
62417: ARRAY
62418: PUSH
62419: LD_INT 2
62421: ARRAY
62422: PPUSH
62423: LD_EXP 28
62427: PUSH
62428: LD_VAR 0 2
62432: ARRAY
62433: PUSH
62434: LD_INT 1
62436: ARRAY
62437: PUSH
62438: LD_INT 3
62440: ARRAY
62441: PPUSH
62442: LD_EXP 28
62446: PUSH
62447: LD_VAR 0 2
62451: ARRAY
62452: PUSH
62453: LD_INT 1
62455: ARRAY
62456: PUSH
62457: LD_INT 4
62459: ARRAY
62460: PPUSH
62461: CALL_OW 145
// end ;
62465: GO 62254
62467: POP
62468: POP
// end else
62469: GO 62641
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62471: LD_EXP 23
62475: PUSH
62476: LD_VAR 0 2
62480: ARRAY
62481: PPUSH
62482: LD_EXP 28
62486: PUSH
62487: LD_VAR 0 2
62491: ARRAY
62492: PUSH
62493: LD_INT 1
62495: ARRAY
62496: PUSH
62497: LD_INT 1
62499: ARRAY
62500: PPUSH
62501: LD_EXP 28
62505: PUSH
62506: LD_VAR 0 2
62510: ARRAY
62511: PUSH
62512: LD_INT 1
62514: ARRAY
62515: PUSH
62516: LD_INT 2
62518: ARRAY
62519: PPUSH
62520: LD_EXP 28
62524: PUSH
62525: LD_VAR 0 2
62529: ARRAY
62530: PUSH
62531: LD_INT 1
62533: ARRAY
62534: PUSH
62535: LD_INT 3
62537: ARRAY
62538: PPUSH
62539: LD_EXP 28
62543: PUSH
62544: LD_VAR 0 2
62548: ARRAY
62549: PUSH
62550: LD_INT 1
62552: ARRAY
62553: PUSH
62554: LD_INT 4
62556: ARRAY
62557: PPUSH
62558: LD_EXP 23
62562: PUSH
62563: LD_VAR 0 2
62567: ARRAY
62568: PPUSH
62569: LD_INT 21
62571: PUSH
62572: LD_INT 3
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: PPUSH
62579: CALL_OW 72
62583: PPUSH
62584: EMPTY
62585: PPUSH
62586: CALL 22866 0 7
62590: NOT
62591: IFFALSE 62641
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62593: LD_ADDR_EXP 28
62597: PUSH
62598: LD_EXP 28
62602: PPUSH
62603: LD_VAR 0 2
62607: PPUSH
62608: LD_EXP 28
62612: PUSH
62613: LD_VAR 0 2
62617: ARRAY
62618: PPUSH
62619: LD_INT 1
62621: PPUSH
62622: LD_INT 1
62624: NEG
62625: PPUSH
62626: LD_INT 0
62628: PPUSH
62629: CALL 15431 0 4
62633: PPUSH
62634: CALL_OW 1
62638: ST_TO_ADDR
// continue ;
62639: GO 61489
// end ; end ; end ;
62641: GO 61489
62643: POP
62644: POP
// end ;
62645: LD_VAR 0 1
62649: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62650: LD_INT 0
62652: PPUSH
62653: PPUSH
62654: PPUSH
62655: PPUSH
62656: PPUSH
62657: PPUSH
// if not mc_bases then
62658: LD_EXP 23
62662: NOT
62663: IFFALSE 62667
// exit ;
62665: GO 63094
// for i = 1 to mc_bases do
62667: LD_ADDR_VAR 0 2
62671: PUSH
62672: DOUBLE
62673: LD_INT 1
62675: DEC
62676: ST_TO_ADDR
62677: LD_EXP 23
62681: PUSH
62682: FOR_TO
62683: IFFALSE 63092
// begin tmp := mc_build_upgrade [ i ] ;
62685: LD_ADDR_VAR 0 4
62689: PUSH
62690: LD_EXP 55
62694: PUSH
62695: LD_VAR 0 2
62699: ARRAY
62700: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62701: LD_ADDR_VAR 0 6
62705: PUSH
62706: LD_EXP 56
62710: PUSH
62711: LD_VAR 0 2
62715: ARRAY
62716: PPUSH
62717: LD_INT 2
62719: PUSH
62720: LD_INT 30
62722: PUSH
62723: LD_INT 6
62725: PUSH
62726: EMPTY
62727: LIST
62728: LIST
62729: PUSH
62730: LD_INT 30
62732: PUSH
62733: LD_INT 7
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: LIST
62744: PPUSH
62745: CALL_OW 72
62749: ST_TO_ADDR
// if not tmp and not lab then
62750: LD_VAR 0 4
62754: NOT
62755: PUSH
62756: LD_VAR 0 6
62760: NOT
62761: AND
62762: IFFALSE 62766
// continue ;
62764: GO 62682
// if tmp then
62766: LD_VAR 0 4
62770: IFFALSE 62890
// for j in tmp do
62772: LD_ADDR_VAR 0 3
62776: PUSH
62777: LD_VAR 0 4
62781: PUSH
62782: FOR_IN
62783: IFFALSE 62888
// begin if UpgradeCost ( j ) then
62785: LD_VAR 0 3
62789: PPUSH
62790: CALL 22526 0 1
62794: IFFALSE 62886
// begin ComUpgrade ( j ) ;
62796: LD_VAR 0 3
62800: PPUSH
62801: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62805: LD_ADDR_EXP 55
62809: PUSH
62810: LD_EXP 55
62814: PPUSH
62815: LD_VAR 0 2
62819: PPUSH
62820: LD_EXP 55
62824: PUSH
62825: LD_VAR 0 2
62829: ARRAY
62830: PUSH
62831: LD_VAR 0 3
62835: DIFF
62836: PPUSH
62837: CALL_OW 1
62841: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62842: LD_ADDR_EXP 30
62846: PUSH
62847: LD_EXP 30
62851: PPUSH
62852: LD_VAR 0 2
62856: PUSH
62857: LD_EXP 30
62861: PUSH
62862: LD_VAR 0 2
62866: ARRAY
62867: PUSH
62868: LD_INT 1
62870: PLUS
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: PPUSH
62876: LD_VAR 0 3
62880: PPUSH
62881: CALL 16013 0 3
62885: ST_TO_ADDR
// end ; end ;
62886: GO 62782
62888: POP
62889: POP
// if not lab or not mc_lab_upgrade [ i ] then
62890: LD_VAR 0 6
62894: NOT
62895: PUSH
62896: LD_EXP 57
62900: PUSH
62901: LD_VAR 0 2
62905: ARRAY
62906: NOT
62907: OR
62908: IFFALSE 62912
// continue ;
62910: GO 62682
// for j in lab do
62912: LD_ADDR_VAR 0 3
62916: PUSH
62917: LD_VAR 0 6
62921: PUSH
62922: FOR_IN
62923: IFFALSE 63088
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62925: LD_VAR 0 3
62929: PPUSH
62930: CALL_OW 266
62934: PUSH
62935: LD_INT 6
62937: PUSH
62938: LD_INT 7
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: IN
62945: PUSH
62946: LD_VAR 0 3
62950: PPUSH
62951: CALL_OW 461
62955: PUSH
62956: LD_INT 1
62958: NONEQUAL
62959: AND
62960: IFFALSE 63086
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62962: LD_VAR 0 3
62966: PPUSH
62967: LD_EXP 57
62971: PUSH
62972: LD_VAR 0 2
62976: ARRAY
62977: PUSH
62978: LD_INT 1
62980: ARRAY
62981: PPUSH
62982: CALL 22731 0 2
62986: IFFALSE 63086
// begin ComCancel ( j ) ;
62988: LD_VAR 0 3
62992: PPUSH
62993: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62997: LD_VAR 0 3
63001: PPUSH
63002: LD_EXP 57
63006: PUSH
63007: LD_VAR 0 2
63011: ARRAY
63012: PUSH
63013: LD_INT 1
63015: ARRAY
63016: PPUSH
63017: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63021: LD_VAR 0 3
63025: PUSH
63026: LD_EXP 30
63030: PUSH
63031: LD_VAR 0 2
63035: ARRAY
63036: IN
63037: NOT
63038: IFFALSE 63084
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63040: LD_ADDR_EXP 30
63044: PUSH
63045: LD_EXP 30
63049: PPUSH
63050: LD_VAR 0 2
63054: PUSH
63055: LD_EXP 30
63059: PUSH
63060: LD_VAR 0 2
63064: ARRAY
63065: PUSH
63066: LD_INT 1
63068: PLUS
63069: PUSH
63070: EMPTY
63071: LIST
63072: LIST
63073: PPUSH
63074: LD_VAR 0 3
63078: PPUSH
63079: CALL 16013 0 3
63083: ST_TO_ADDR
// break ;
63084: GO 63088
// end ; end ; end ;
63086: GO 62922
63088: POP
63089: POP
// end ;
63090: GO 62682
63092: POP
63093: POP
// end ;
63094: LD_VAR 0 1
63098: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63099: LD_INT 0
63101: PPUSH
63102: PPUSH
63103: PPUSH
63104: PPUSH
63105: PPUSH
63106: PPUSH
63107: PPUSH
63108: PPUSH
63109: PPUSH
// if not mc_bases then
63110: LD_EXP 23
63114: NOT
63115: IFFALSE 63119
// exit ;
63117: GO 63524
// for i = 1 to mc_bases do
63119: LD_ADDR_VAR 0 2
63123: PUSH
63124: DOUBLE
63125: LD_INT 1
63127: DEC
63128: ST_TO_ADDR
63129: LD_EXP 23
63133: PUSH
63134: FOR_TO
63135: IFFALSE 63522
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63137: LD_EXP 31
63141: PUSH
63142: LD_VAR 0 2
63146: ARRAY
63147: NOT
63148: PUSH
63149: LD_EXP 23
63153: PUSH
63154: LD_VAR 0 2
63158: ARRAY
63159: PPUSH
63160: LD_INT 30
63162: PUSH
63163: LD_INT 3
63165: PUSH
63166: EMPTY
63167: LIST
63168: LIST
63169: PPUSH
63170: CALL_OW 72
63174: NOT
63175: OR
63176: IFFALSE 63180
// continue ;
63178: GO 63134
// busy := false ;
63180: LD_ADDR_VAR 0 8
63184: PUSH
63185: LD_INT 0
63187: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63188: LD_ADDR_VAR 0 4
63192: PUSH
63193: LD_EXP 23
63197: PUSH
63198: LD_VAR 0 2
63202: ARRAY
63203: PPUSH
63204: LD_INT 30
63206: PUSH
63207: LD_INT 3
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PPUSH
63214: CALL_OW 72
63218: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63219: LD_ADDR_VAR 0 6
63223: PUSH
63224: LD_EXP 31
63228: PUSH
63229: LD_VAR 0 2
63233: ARRAY
63234: PPUSH
63235: LD_INT 2
63237: PUSH
63238: LD_INT 30
63240: PUSH
63241: LD_INT 32
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: LD_INT 30
63250: PUSH
63251: LD_INT 33
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: LIST
63262: PPUSH
63263: CALL_OW 72
63267: ST_TO_ADDR
// if not t then
63268: LD_VAR 0 6
63272: NOT
63273: IFFALSE 63277
// continue ;
63275: GO 63134
// for j in tmp do
63277: LD_ADDR_VAR 0 3
63281: PUSH
63282: LD_VAR 0 4
63286: PUSH
63287: FOR_IN
63288: IFFALSE 63318
// if not BuildingStatus ( j ) = bs_idle then
63290: LD_VAR 0 3
63294: PPUSH
63295: CALL_OW 461
63299: PUSH
63300: LD_INT 2
63302: EQUAL
63303: NOT
63304: IFFALSE 63316
// begin busy := true ;
63306: LD_ADDR_VAR 0 8
63310: PUSH
63311: LD_INT 1
63313: ST_TO_ADDR
// break ;
63314: GO 63318
// end ;
63316: GO 63287
63318: POP
63319: POP
// if busy then
63320: LD_VAR 0 8
63324: IFFALSE 63328
// continue ;
63326: GO 63134
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63328: LD_ADDR_VAR 0 7
63332: PUSH
63333: LD_VAR 0 6
63337: PPUSH
63338: LD_INT 35
63340: PUSH
63341: LD_INT 0
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PPUSH
63348: CALL_OW 72
63352: ST_TO_ADDR
// if tw then
63353: LD_VAR 0 7
63357: IFFALSE 63434
// begin tw := tw [ 1 ] ;
63359: LD_ADDR_VAR 0 7
63363: PUSH
63364: LD_VAR 0 7
63368: PUSH
63369: LD_INT 1
63371: ARRAY
63372: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63373: LD_ADDR_VAR 0 9
63377: PUSH
63378: LD_VAR 0 7
63382: PPUSH
63383: LD_EXP 48
63387: PUSH
63388: LD_VAR 0 2
63392: ARRAY
63393: PPUSH
63394: CALL 21023 0 2
63398: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63399: LD_EXP 62
63403: PUSH
63404: LD_VAR 0 2
63408: ARRAY
63409: IFFALSE 63432
// if not weapon in mc_allowed_tower_weapons [ i ] then
63411: LD_VAR 0 9
63415: PUSH
63416: LD_EXP 62
63420: PUSH
63421: LD_VAR 0 2
63425: ARRAY
63426: IN
63427: NOT
63428: IFFALSE 63432
// continue ;
63430: GO 63134
// end else
63432: GO 63497
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63434: LD_ADDR_VAR 0 5
63438: PUSH
63439: LD_EXP 31
63443: PUSH
63444: LD_VAR 0 2
63448: ARRAY
63449: PPUSH
63450: LD_VAR 0 4
63454: PPUSH
63455: CALL 47256 0 2
63459: ST_TO_ADDR
// if not tmp2 then
63460: LD_VAR 0 5
63464: NOT
63465: IFFALSE 63469
// continue ;
63467: GO 63134
// tw := tmp2 [ 1 ] ;
63469: LD_ADDR_VAR 0 7
63473: PUSH
63474: LD_VAR 0 5
63478: PUSH
63479: LD_INT 1
63481: ARRAY
63482: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63483: LD_ADDR_VAR 0 9
63487: PUSH
63488: LD_VAR 0 5
63492: PUSH
63493: LD_INT 2
63495: ARRAY
63496: ST_TO_ADDR
// end ; if not weapon then
63497: LD_VAR 0 9
63501: NOT
63502: IFFALSE 63506
// continue ;
63504: GO 63134
// ComPlaceWeapon ( tw , weapon ) ;
63506: LD_VAR 0 7
63510: PPUSH
63511: LD_VAR 0 9
63515: PPUSH
63516: CALL_OW 148
// end ;
63520: GO 63134
63522: POP
63523: POP
// end ;
63524: LD_VAR 0 1
63528: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63529: LD_INT 0
63531: PPUSH
63532: PPUSH
63533: PPUSH
63534: PPUSH
63535: PPUSH
63536: PPUSH
63537: PPUSH
// if not mc_bases then
63538: LD_EXP 23
63542: NOT
63543: IFFALSE 63547
// exit ;
63545: GO 64315
// for i = 1 to mc_bases do
63547: LD_ADDR_VAR 0 2
63551: PUSH
63552: DOUBLE
63553: LD_INT 1
63555: DEC
63556: ST_TO_ADDR
63557: LD_EXP 23
63561: PUSH
63562: FOR_TO
63563: IFFALSE 64313
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63565: LD_EXP 36
63569: PUSH
63570: LD_VAR 0 2
63574: ARRAY
63575: NOT
63576: PUSH
63577: LD_EXP 36
63581: PUSH
63582: LD_VAR 0 2
63586: ARRAY
63587: PUSH
63588: LD_EXP 37
63592: PUSH
63593: LD_VAR 0 2
63597: ARRAY
63598: EQUAL
63599: OR
63600: PUSH
63601: LD_EXP 46
63605: PUSH
63606: LD_VAR 0 2
63610: ARRAY
63611: OR
63612: IFFALSE 63616
// continue ;
63614: GO 63562
// if mc_miners [ i ] then
63616: LD_EXP 37
63620: PUSH
63621: LD_VAR 0 2
63625: ARRAY
63626: IFFALSE 64000
// begin for j = mc_miners [ i ] downto 1 do
63628: LD_ADDR_VAR 0 3
63632: PUSH
63633: DOUBLE
63634: LD_EXP 37
63638: PUSH
63639: LD_VAR 0 2
63643: ARRAY
63644: INC
63645: ST_TO_ADDR
63646: LD_INT 1
63648: PUSH
63649: FOR_DOWNTO
63650: IFFALSE 63998
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63652: LD_EXP 37
63656: PUSH
63657: LD_VAR 0 2
63661: ARRAY
63662: PUSH
63663: LD_VAR 0 3
63667: ARRAY
63668: PPUSH
63669: CALL_OW 301
63673: PUSH
63674: LD_EXP 37
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: PUSH
63685: LD_VAR 0 3
63689: ARRAY
63690: PPUSH
63691: CALL_OW 257
63695: PUSH
63696: LD_INT 1
63698: NONEQUAL
63699: OR
63700: IFFALSE 63763
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63702: LD_ADDR_VAR 0 5
63706: PUSH
63707: LD_EXP 37
63711: PUSH
63712: LD_VAR 0 2
63716: ARRAY
63717: PUSH
63718: LD_EXP 37
63722: PUSH
63723: LD_VAR 0 2
63727: ARRAY
63728: PUSH
63729: LD_VAR 0 3
63733: ARRAY
63734: DIFF
63735: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63736: LD_ADDR_EXP 37
63740: PUSH
63741: LD_EXP 37
63745: PPUSH
63746: LD_VAR 0 2
63750: PPUSH
63751: LD_VAR 0 5
63755: PPUSH
63756: CALL_OW 1
63760: ST_TO_ADDR
// continue ;
63761: GO 63649
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63763: LD_EXP 37
63767: PUSH
63768: LD_VAR 0 2
63772: ARRAY
63773: PUSH
63774: LD_VAR 0 3
63778: ARRAY
63779: PPUSH
63780: CALL_OW 257
63784: PUSH
63785: LD_INT 1
63787: EQUAL
63788: PUSH
63789: LD_EXP 37
63793: PUSH
63794: LD_VAR 0 2
63798: ARRAY
63799: PUSH
63800: LD_VAR 0 3
63804: ARRAY
63805: PPUSH
63806: CALL_OW 459
63810: NOT
63811: AND
63812: PUSH
63813: LD_EXP 37
63817: PUSH
63818: LD_VAR 0 2
63822: ARRAY
63823: PUSH
63824: LD_VAR 0 3
63828: ARRAY
63829: PPUSH
63830: CALL_OW 314
63834: NOT
63835: AND
63836: IFFALSE 63996
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63838: LD_EXP 37
63842: PUSH
63843: LD_VAR 0 2
63847: ARRAY
63848: PUSH
63849: LD_VAR 0 3
63853: ARRAY
63854: PPUSH
63855: CALL_OW 310
63859: IFFALSE 63882
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63861: LD_EXP 37
63865: PUSH
63866: LD_VAR 0 2
63870: ARRAY
63871: PUSH
63872: LD_VAR 0 3
63876: ARRAY
63877: PPUSH
63878: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63882: LD_EXP 37
63886: PUSH
63887: LD_VAR 0 2
63891: ARRAY
63892: PUSH
63893: LD_VAR 0 3
63897: ARRAY
63898: PPUSH
63899: CALL_OW 314
63903: NOT
63904: IFFALSE 63996
// begin r := rand ( 1 , mc_mines [ i ] ) ;
63906: LD_ADDR_VAR 0 7
63910: PUSH
63911: LD_INT 1
63913: PPUSH
63914: LD_EXP 36
63918: PUSH
63919: LD_VAR 0 2
63923: ARRAY
63924: PPUSH
63925: CALL_OW 12
63929: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
63930: LD_EXP 37
63934: PUSH
63935: LD_VAR 0 2
63939: ARRAY
63940: PUSH
63941: LD_VAR 0 3
63945: ARRAY
63946: PPUSH
63947: LD_EXP 36
63951: PUSH
63952: LD_VAR 0 2
63956: ARRAY
63957: PUSH
63958: LD_VAR 0 7
63962: ARRAY
63963: PUSH
63964: LD_INT 1
63966: ARRAY
63967: PPUSH
63968: LD_EXP 36
63972: PUSH
63973: LD_VAR 0 2
63977: ARRAY
63978: PUSH
63979: LD_VAR 0 7
63983: ARRAY
63984: PUSH
63985: LD_INT 2
63987: ARRAY
63988: PPUSH
63989: LD_INT 0
63991: PPUSH
63992: CALL_OW 193
// end ; end ; end ;
63996: GO 63649
63998: POP
63999: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64000: LD_ADDR_VAR 0 5
64004: PUSH
64005: LD_EXP 23
64009: PUSH
64010: LD_VAR 0 2
64014: ARRAY
64015: PPUSH
64016: LD_INT 2
64018: PUSH
64019: LD_INT 30
64021: PUSH
64022: LD_INT 4
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PUSH
64029: LD_INT 30
64031: PUSH
64032: LD_INT 5
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: PUSH
64039: LD_INT 30
64041: PUSH
64042: LD_INT 32
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: PPUSH
64055: CALL_OW 72
64059: ST_TO_ADDR
// if not tmp then
64060: LD_VAR 0 5
64064: NOT
64065: IFFALSE 64069
// continue ;
64067: GO 63562
// list := [ ] ;
64069: LD_ADDR_VAR 0 6
64073: PUSH
64074: EMPTY
64075: ST_TO_ADDR
// for j in tmp do
64076: LD_ADDR_VAR 0 3
64080: PUSH
64081: LD_VAR 0 5
64085: PUSH
64086: FOR_IN
64087: IFFALSE 64156
// begin for k in UnitsInside ( j ) do
64089: LD_ADDR_VAR 0 4
64093: PUSH
64094: LD_VAR 0 3
64098: PPUSH
64099: CALL_OW 313
64103: PUSH
64104: FOR_IN
64105: IFFALSE 64152
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64107: LD_VAR 0 4
64111: PPUSH
64112: CALL_OW 257
64116: PUSH
64117: LD_INT 1
64119: EQUAL
64120: PUSH
64121: LD_VAR 0 4
64125: PPUSH
64126: CALL_OW 459
64130: NOT
64131: AND
64132: IFFALSE 64150
// list := list ^ k ;
64134: LD_ADDR_VAR 0 6
64138: PUSH
64139: LD_VAR 0 6
64143: PUSH
64144: LD_VAR 0 4
64148: ADD
64149: ST_TO_ADDR
64150: GO 64104
64152: POP
64153: POP
// end ;
64154: GO 64086
64156: POP
64157: POP
// list := list diff mc_miners [ i ] ;
64158: LD_ADDR_VAR 0 6
64162: PUSH
64163: LD_VAR 0 6
64167: PUSH
64168: LD_EXP 37
64172: PUSH
64173: LD_VAR 0 2
64177: ARRAY
64178: DIFF
64179: ST_TO_ADDR
// if not list then
64180: LD_VAR 0 6
64184: NOT
64185: IFFALSE 64189
// continue ;
64187: GO 63562
// k := mc_mines [ i ] - mc_miners [ i ] ;
64189: LD_ADDR_VAR 0 4
64193: PUSH
64194: LD_EXP 36
64198: PUSH
64199: LD_VAR 0 2
64203: ARRAY
64204: PUSH
64205: LD_EXP 37
64209: PUSH
64210: LD_VAR 0 2
64214: ARRAY
64215: MINUS
64216: ST_TO_ADDR
// if k > list then
64217: LD_VAR 0 4
64221: PUSH
64222: LD_VAR 0 6
64226: GREATER
64227: IFFALSE 64239
// k := list ;
64229: LD_ADDR_VAR 0 4
64233: PUSH
64234: LD_VAR 0 6
64238: ST_TO_ADDR
// for j = 1 to k do
64239: LD_ADDR_VAR 0 3
64243: PUSH
64244: DOUBLE
64245: LD_INT 1
64247: DEC
64248: ST_TO_ADDR
64249: LD_VAR 0 4
64253: PUSH
64254: FOR_TO
64255: IFFALSE 64309
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64257: LD_ADDR_EXP 37
64261: PUSH
64262: LD_EXP 37
64266: PPUSH
64267: LD_VAR 0 2
64271: PUSH
64272: LD_EXP 37
64276: PUSH
64277: LD_VAR 0 2
64281: ARRAY
64282: PUSH
64283: LD_INT 1
64285: PLUS
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: PPUSH
64291: LD_VAR 0 6
64295: PUSH
64296: LD_VAR 0 3
64300: ARRAY
64301: PPUSH
64302: CALL 16013 0 3
64306: ST_TO_ADDR
64307: GO 64254
64309: POP
64310: POP
// end ;
64311: GO 63562
64313: POP
64314: POP
// end ;
64315: LD_VAR 0 1
64319: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64320: LD_INT 0
64322: PPUSH
64323: PPUSH
64324: PPUSH
64325: PPUSH
64326: PPUSH
64327: PPUSH
64328: PPUSH
64329: PPUSH
64330: PPUSH
64331: PPUSH
64332: PPUSH
// if not mc_bases then
64333: LD_EXP 23
64337: NOT
64338: IFFALSE 64342
// exit ;
64340: GO 66165
// for i = 1 to mc_bases do
64342: LD_ADDR_VAR 0 2
64346: PUSH
64347: DOUBLE
64348: LD_INT 1
64350: DEC
64351: ST_TO_ADDR
64352: LD_EXP 23
64356: PUSH
64357: FOR_TO
64358: IFFALSE 66163
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64360: LD_EXP 23
64364: PUSH
64365: LD_VAR 0 2
64369: ARRAY
64370: NOT
64371: PUSH
64372: LD_EXP 30
64376: PUSH
64377: LD_VAR 0 2
64381: ARRAY
64382: OR
64383: IFFALSE 64387
// continue ;
64385: GO 64357
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64387: LD_EXP 39
64391: PUSH
64392: LD_VAR 0 2
64396: ARRAY
64397: NOT
64398: PUSH
64399: LD_EXP 40
64403: PUSH
64404: LD_VAR 0 2
64408: ARRAY
64409: AND
64410: IFFALSE 64448
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64412: LD_ADDR_EXP 40
64416: PUSH
64417: LD_EXP 40
64421: PPUSH
64422: LD_VAR 0 2
64426: PPUSH
64427: EMPTY
64428: PPUSH
64429: CALL_OW 1
64433: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64434: LD_VAR 0 2
64438: PPUSH
64439: LD_INT 107
64441: PPUSH
64442: CALL 55216 0 2
// continue ;
64446: GO 64357
// end ; target := [ ] ;
64448: LD_ADDR_VAR 0 7
64452: PUSH
64453: EMPTY
64454: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64455: LD_ADDR_VAR 0 6
64459: PUSH
64460: LD_EXP 23
64464: PUSH
64465: LD_VAR 0 2
64469: ARRAY
64470: PUSH
64471: LD_INT 1
64473: ARRAY
64474: PPUSH
64475: CALL_OW 255
64479: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64480: LD_ADDR_VAR 0 9
64484: PUSH
64485: LD_EXP 23
64489: PUSH
64490: LD_VAR 0 2
64494: ARRAY
64495: PPUSH
64496: LD_INT 2
64498: PUSH
64499: LD_INT 30
64501: PUSH
64502: LD_INT 0
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 30
64511: PUSH
64512: LD_INT 1
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: LIST
64523: PPUSH
64524: CALL_OW 72
64528: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64529: LD_ADDR_VAR 0 3
64533: PUSH
64534: DOUBLE
64535: LD_EXP 39
64539: PUSH
64540: LD_VAR 0 2
64544: ARRAY
64545: INC
64546: ST_TO_ADDR
64547: LD_INT 1
64549: PUSH
64550: FOR_DOWNTO
64551: IFFALSE 64796
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64553: LD_EXP 39
64557: PUSH
64558: LD_VAR 0 2
64562: ARRAY
64563: PUSH
64564: LD_VAR 0 3
64568: ARRAY
64569: PUSH
64570: LD_INT 2
64572: ARRAY
64573: PPUSH
64574: LD_EXP 39
64578: PUSH
64579: LD_VAR 0 2
64583: ARRAY
64584: PUSH
64585: LD_VAR 0 3
64589: ARRAY
64590: PUSH
64591: LD_INT 3
64593: ARRAY
64594: PPUSH
64595: CALL_OW 488
64599: PUSH
64600: LD_EXP 39
64604: PUSH
64605: LD_VAR 0 2
64609: ARRAY
64610: PUSH
64611: LD_VAR 0 3
64615: ARRAY
64616: PUSH
64617: LD_INT 2
64619: ARRAY
64620: PPUSH
64621: LD_EXP 39
64625: PUSH
64626: LD_VAR 0 2
64630: ARRAY
64631: PUSH
64632: LD_VAR 0 3
64636: ARRAY
64637: PUSH
64638: LD_INT 3
64640: ARRAY
64641: PPUSH
64642: CALL_OW 284
64646: PUSH
64647: LD_INT 0
64649: EQUAL
64650: AND
64651: IFFALSE 64706
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64653: LD_ADDR_VAR 0 5
64657: PUSH
64658: LD_EXP 39
64662: PUSH
64663: LD_VAR 0 2
64667: ARRAY
64668: PPUSH
64669: LD_VAR 0 3
64673: PPUSH
64674: CALL_OW 3
64678: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64679: LD_ADDR_EXP 39
64683: PUSH
64684: LD_EXP 39
64688: PPUSH
64689: LD_VAR 0 2
64693: PPUSH
64694: LD_VAR 0 5
64698: PPUSH
64699: CALL_OW 1
64703: ST_TO_ADDR
// continue ;
64704: GO 64550
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64706: LD_VAR 0 6
64710: PPUSH
64711: LD_EXP 39
64715: PUSH
64716: LD_VAR 0 2
64720: ARRAY
64721: PUSH
64722: LD_VAR 0 3
64726: ARRAY
64727: PUSH
64728: LD_INT 2
64730: ARRAY
64731: PPUSH
64732: LD_EXP 39
64736: PUSH
64737: LD_VAR 0 2
64741: ARRAY
64742: PUSH
64743: LD_VAR 0 3
64747: ARRAY
64748: PUSH
64749: LD_INT 3
64751: ARRAY
64752: PPUSH
64753: LD_INT 30
64755: PPUSH
64756: CALL 16909 0 4
64760: PUSH
64761: LD_INT 4
64763: ARRAY
64764: PUSH
64765: LD_INT 0
64767: EQUAL
64768: IFFALSE 64794
// begin target := mc_crates [ i ] [ j ] ;
64770: LD_ADDR_VAR 0 7
64774: PUSH
64775: LD_EXP 39
64779: PUSH
64780: LD_VAR 0 2
64784: ARRAY
64785: PUSH
64786: LD_VAR 0 3
64790: ARRAY
64791: ST_TO_ADDR
// break ;
64792: GO 64796
// end ; end ;
64794: GO 64550
64796: POP
64797: POP
// if not target then
64798: LD_VAR 0 7
64802: NOT
64803: IFFALSE 64807
// continue ;
64805: GO 64357
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64807: LD_ADDR_VAR 0 8
64811: PUSH
64812: LD_EXP 42
64816: PUSH
64817: LD_VAR 0 2
64821: ARRAY
64822: PPUSH
64823: LD_INT 2
64825: PUSH
64826: LD_INT 3
64828: PUSH
64829: LD_INT 58
64831: PUSH
64832: EMPTY
64833: LIST
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 61
64841: PUSH
64842: EMPTY
64843: LIST
64844: PUSH
64845: LD_INT 33
64847: PUSH
64848: LD_INT 5
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 33
64857: PUSH
64858: LD_INT 3
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 2
64874: PUSH
64875: LD_INT 34
64877: PUSH
64878: LD_INT 32
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 34
64887: PUSH
64888: LD_INT 51
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 34
64897: PUSH
64898: LD_INT 12
64900: PUSH
64901: EMPTY
64902: LIST
64903: LIST
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PPUSH
64915: CALL_OW 72
64919: ST_TO_ADDR
// if not cargo then
64920: LD_VAR 0 8
64924: NOT
64925: IFFALSE 65631
// begin if mc_crates_collector [ i ] < 5 then
64927: LD_EXP 40
64931: PUSH
64932: LD_VAR 0 2
64936: ARRAY
64937: PUSH
64938: LD_INT 5
64940: LESS
64941: IFFALSE 65307
// begin if mc_ape [ i ] then
64943: LD_EXP 52
64947: PUSH
64948: LD_VAR 0 2
64952: ARRAY
64953: IFFALSE 65000
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64955: LD_ADDR_VAR 0 5
64959: PUSH
64960: LD_EXP 52
64964: PUSH
64965: LD_VAR 0 2
64969: ARRAY
64970: PPUSH
64971: LD_INT 25
64973: PUSH
64974: LD_INT 16
64976: PUSH
64977: EMPTY
64978: LIST
64979: LIST
64980: PUSH
64981: LD_INT 24
64983: PUSH
64984: LD_INT 750
64986: PUSH
64987: EMPTY
64988: LIST
64989: LIST
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PPUSH
64995: CALL_OW 72
64999: ST_TO_ADDR
// if not tmp then
65000: LD_VAR 0 5
65004: NOT
65005: IFFALSE 65052
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65007: LD_ADDR_VAR 0 5
65011: PUSH
65012: LD_EXP 23
65016: PUSH
65017: LD_VAR 0 2
65021: ARRAY
65022: PPUSH
65023: LD_INT 25
65025: PUSH
65026: LD_INT 2
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: LD_INT 24
65035: PUSH
65036: LD_INT 750
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: EMPTY
65044: LIST
65045: LIST
65046: PPUSH
65047: CALL_OW 72
65051: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65052: LD_EXP 52
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: PUSH
65063: LD_EXP 23
65067: PUSH
65068: LD_VAR 0 2
65072: ARRAY
65073: PPUSH
65074: LD_INT 25
65076: PUSH
65077: LD_INT 2
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: PUSH
65084: LD_INT 24
65086: PUSH
65087: LD_INT 750
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PPUSH
65098: CALL_OW 72
65102: AND
65103: PUSH
65104: LD_VAR 0 5
65108: PUSH
65109: LD_INT 5
65111: LESS
65112: AND
65113: IFFALSE 65195
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65115: LD_ADDR_VAR 0 3
65119: PUSH
65120: LD_EXP 23
65124: PUSH
65125: LD_VAR 0 2
65129: ARRAY
65130: PPUSH
65131: LD_INT 25
65133: PUSH
65134: LD_INT 2
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 24
65143: PUSH
65144: LD_INT 750
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: PPUSH
65155: CALL_OW 72
65159: PUSH
65160: FOR_IN
65161: IFFALSE 65193
// begin tmp := tmp union j ;
65163: LD_ADDR_VAR 0 5
65167: PUSH
65168: LD_VAR 0 5
65172: PUSH
65173: LD_VAR 0 3
65177: UNION
65178: ST_TO_ADDR
// if tmp >= 5 then
65179: LD_VAR 0 5
65183: PUSH
65184: LD_INT 5
65186: GREATEREQUAL
65187: IFFALSE 65191
// break ;
65189: GO 65193
// end ;
65191: GO 65160
65193: POP
65194: POP
// end ; if not tmp then
65195: LD_VAR 0 5
65199: NOT
65200: IFFALSE 65204
// continue ;
65202: GO 64357
// for j in tmp do
65204: LD_ADDR_VAR 0 3
65208: PUSH
65209: LD_VAR 0 5
65213: PUSH
65214: FOR_IN
65215: IFFALSE 65305
// if not GetTag ( j ) then
65217: LD_VAR 0 3
65221: PPUSH
65222: CALL_OW 110
65226: NOT
65227: IFFALSE 65303
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65229: LD_ADDR_EXP 40
65233: PUSH
65234: LD_EXP 40
65238: PPUSH
65239: LD_VAR 0 2
65243: PUSH
65244: LD_EXP 40
65248: PUSH
65249: LD_VAR 0 2
65253: ARRAY
65254: PUSH
65255: LD_INT 1
65257: PLUS
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PPUSH
65263: LD_VAR 0 3
65267: PPUSH
65268: CALL 16013 0 3
65272: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65273: LD_VAR 0 3
65277: PPUSH
65278: LD_INT 107
65280: PPUSH
65281: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65285: LD_EXP 40
65289: PUSH
65290: LD_VAR 0 2
65294: ARRAY
65295: PUSH
65296: LD_INT 5
65298: GREATEREQUAL
65299: IFFALSE 65303
// break ;
65301: GO 65305
// end ;
65303: GO 65214
65305: POP
65306: POP
// end ; if mc_crates_collector [ i ] and target then
65307: LD_EXP 40
65311: PUSH
65312: LD_VAR 0 2
65316: ARRAY
65317: PUSH
65318: LD_VAR 0 7
65322: AND
65323: IFFALSE 65629
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65325: LD_EXP 40
65329: PUSH
65330: LD_VAR 0 2
65334: ARRAY
65335: PUSH
65336: LD_VAR 0 7
65340: PUSH
65341: LD_INT 1
65343: ARRAY
65344: LESS
65345: IFFALSE 65365
// tmp := mc_crates_collector [ i ] else
65347: LD_ADDR_VAR 0 5
65351: PUSH
65352: LD_EXP 40
65356: PUSH
65357: LD_VAR 0 2
65361: ARRAY
65362: ST_TO_ADDR
65363: GO 65379
// tmp := target [ 1 ] ;
65365: LD_ADDR_VAR 0 5
65369: PUSH
65370: LD_VAR 0 7
65374: PUSH
65375: LD_INT 1
65377: ARRAY
65378: ST_TO_ADDR
// k := 0 ;
65379: LD_ADDR_VAR 0 4
65383: PUSH
65384: LD_INT 0
65386: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65387: LD_ADDR_VAR 0 3
65391: PUSH
65392: LD_EXP 40
65396: PUSH
65397: LD_VAR 0 2
65401: ARRAY
65402: PUSH
65403: FOR_IN
65404: IFFALSE 65627
// begin k := k + 1 ;
65406: LD_ADDR_VAR 0 4
65410: PUSH
65411: LD_VAR 0 4
65415: PUSH
65416: LD_INT 1
65418: PLUS
65419: ST_TO_ADDR
// if k > tmp then
65420: LD_VAR 0 4
65424: PUSH
65425: LD_VAR 0 5
65429: GREATER
65430: IFFALSE 65434
// break ;
65432: GO 65627
// if not GetClass ( j ) in [ 2 , 16 ] then
65434: LD_VAR 0 3
65438: PPUSH
65439: CALL_OW 257
65443: PUSH
65444: LD_INT 2
65446: PUSH
65447: LD_INT 16
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: IN
65454: NOT
65455: IFFALSE 65508
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65457: LD_ADDR_EXP 40
65461: PUSH
65462: LD_EXP 40
65466: PPUSH
65467: LD_VAR 0 2
65471: PPUSH
65472: LD_EXP 40
65476: PUSH
65477: LD_VAR 0 2
65481: ARRAY
65482: PUSH
65483: LD_VAR 0 3
65487: DIFF
65488: PPUSH
65489: CALL_OW 1
65493: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65494: LD_VAR 0 3
65498: PPUSH
65499: LD_INT 0
65501: PPUSH
65502: CALL_OW 109
// continue ;
65506: GO 65403
// end ; if IsInUnit ( j ) then
65508: LD_VAR 0 3
65512: PPUSH
65513: CALL_OW 310
65517: IFFALSE 65528
// ComExitBuilding ( j ) ;
65519: LD_VAR 0 3
65523: PPUSH
65524: CALL_OW 122
// wait ( 3 ) ;
65528: LD_INT 3
65530: PPUSH
65531: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65535: LD_VAR 0 3
65539: PPUSH
65540: CALL_OW 314
65544: PUSH
65545: LD_VAR 0 6
65549: PPUSH
65550: LD_VAR 0 7
65554: PUSH
65555: LD_INT 2
65557: ARRAY
65558: PPUSH
65559: LD_VAR 0 7
65563: PUSH
65564: LD_INT 3
65566: ARRAY
65567: PPUSH
65568: LD_INT 30
65570: PPUSH
65571: CALL 16909 0 4
65575: PUSH
65576: LD_INT 4
65578: ARRAY
65579: AND
65580: IFFALSE 65598
// ComStandNearbyBuilding ( j , depot ) else
65582: LD_VAR 0 3
65586: PPUSH
65587: LD_VAR 0 9
65591: PPUSH
65592: CALL 12591 0 2
65596: GO 65625
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65598: LD_VAR 0 3
65602: PPUSH
65603: LD_VAR 0 7
65607: PUSH
65608: LD_INT 2
65610: ARRAY
65611: PPUSH
65612: LD_VAR 0 7
65616: PUSH
65617: LD_INT 3
65619: ARRAY
65620: PPUSH
65621: CALL_OW 117
// end ;
65625: GO 65403
65627: POP
65628: POP
// end ; end else
65629: GO 66161
// begin for j in cargo do
65631: LD_ADDR_VAR 0 3
65635: PUSH
65636: LD_VAR 0 8
65640: PUSH
65641: FOR_IN
65642: IFFALSE 66159
// begin if GetTag ( j ) <> 0 then
65644: LD_VAR 0 3
65648: PPUSH
65649: CALL_OW 110
65653: PUSH
65654: LD_INT 0
65656: NONEQUAL
65657: IFFALSE 65661
// continue ;
65659: GO 65641
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65661: LD_VAR 0 3
65665: PPUSH
65666: CALL_OW 256
65670: PUSH
65671: LD_INT 1000
65673: LESS
65674: PUSH
65675: LD_VAR 0 3
65679: PPUSH
65680: LD_EXP 47
65684: PUSH
65685: LD_VAR 0 2
65689: ARRAY
65690: PPUSH
65691: CALL_OW 308
65695: NOT
65696: AND
65697: IFFALSE 65719
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65699: LD_VAR 0 3
65703: PPUSH
65704: LD_EXP 47
65708: PUSH
65709: LD_VAR 0 2
65713: ARRAY
65714: PPUSH
65715: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65719: LD_VAR 0 3
65723: PPUSH
65724: CALL_OW 256
65728: PUSH
65729: LD_INT 1000
65731: LESS
65732: PUSH
65733: LD_VAR 0 3
65737: PPUSH
65738: LD_EXP 47
65742: PUSH
65743: LD_VAR 0 2
65747: ARRAY
65748: PPUSH
65749: CALL_OW 308
65753: AND
65754: IFFALSE 65758
// continue ;
65756: GO 65641
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65758: LD_VAR 0 3
65762: PPUSH
65763: CALL_OW 262
65767: PUSH
65768: LD_INT 2
65770: EQUAL
65771: PUSH
65772: LD_VAR 0 3
65776: PPUSH
65777: CALL_OW 261
65781: PUSH
65782: LD_INT 15
65784: LESS
65785: AND
65786: IFFALSE 65790
// continue ;
65788: GO 65641
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65790: LD_VAR 0 3
65794: PPUSH
65795: CALL_OW 262
65799: PUSH
65800: LD_INT 1
65802: EQUAL
65803: PUSH
65804: LD_VAR 0 3
65808: PPUSH
65809: CALL_OW 261
65813: PUSH
65814: LD_INT 10
65816: LESS
65817: AND
65818: IFFALSE 66098
// begin if not depot then
65820: LD_VAR 0 9
65824: NOT
65825: IFFALSE 65829
// continue ;
65827: GO 65641
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65829: LD_VAR 0 3
65833: PPUSH
65834: LD_VAR 0 9
65838: PPUSH
65839: LD_VAR 0 3
65843: PPUSH
65844: CALL_OW 74
65848: PPUSH
65849: CALL_OW 296
65853: PUSH
65854: LD_INT 6
65856: LESS
65857: IFFALSE 65873
// SetFuel ( j , 100 ) else
65859: LD_VAR 0 3
65863: PPUSH
65864: LD_INT 100
65866: PPUSH
65867: CALL_OW 240
65871: GO 66098
// if GetFuel ( j ) = 0 then
65873: LD_VAR 0 3
65877: PPUSH
65878: CALL_OW 261
65882: PUSH
65883: LD_INT 0
65885: EQUAL
65886: IFFALSE 66098
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65888: LD_ADDR_EXP 42
65892: PUSH
65893: LD_EXP 42
65897: PPUSH
65898: LD_VAR 0 2
65902: PPUSH
65903: LD_EXP 42
65907: PUSH
65908: LD_VAR 0 2
65912: ARRAY
65913: PUSH
65914: LD_VAR 0 3
65918: DIFF
65919: PPUSH
65920: CALL_OW 1
65924: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65925: LD_VAR 0 3
65929: PPUSH
65930: CALL_OW 263
65934: PUSH
65935: LD_INT 1
65937: EQUAL
65938: IFFALSE 65954
// ComExitVehicle ( IsInUnit ( j ) ) ;
65940: LD_VAR 0 3
65944: PPUSH
65945: CALL_OW 310
65949: PPUSH
65950: CALL_OW 121
// if GetControl ( j ) = control_remote then
65954: LD_VAR 0 3
65958: PPUSH
65959: CALL_OW 263
65963: PUSH
65964: LD_INT 2
65966: EQUAL
65967: IFFALSE 65978
// ComUnlink ( j ) ;
65969: LD_VAR 0 3
65973: PPUSH
65974: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65978: LD_ADDR_VAR 0 10
65982: PUSH
65983: LD_VAR 0 2
65987: PPUSH
65988: LD_INT 3
65990: PPUSH
65991: CALL 75737 0 2
65995: ST_TO_ADDR
// if fac then
65996: LD_VAR 0 10
66000: IFFALSE 66096
// begin for k in fac do
66002: LD_ADDR_VAR 0 4
66006: PUSH
66007: LD_VAR 0 10
66011: PUSH
66012: FOR_IN
66013: IFFALSE 66094
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66015: LD_ADDR_VAR 0 11
66019: PUSH
66020: LD_VAR 0 10
66024: PPUSH
66025: LD_VAR 0 3
66029: PPUSH
66030: CALL_OW 265
66034: PPUSH
66035: LD_VAR 0 3
66039: PPUSH
66040: CALL_OW 262
66044: PPUSH
66045: LD_VAR 0 3
66049: PPUSH
66050: CALL_OW 263
66054: PPUSH
66055: LD_VAR 0 3
66059: PPUSH
66060: CALL_OW 264
66064: PPUSH
66065: CALL 13509 0 5
66069: ST_TO_ADDR
// if components then
66070: LD_VAR 0 11
66074: IFFALSE 66092
// begin MC_InsertProduceList ( i , components ) ;
66076: LD_VAR 0 2
66080: PPUSH
66081: LD_VAR 0 11
66085: PPUSH
66086: CALL 75282 0 2
// break ;
66090: GO 66094
// end ; end ;
66092: GO 66012
66094: POP
66095: POP
// end ; continue ;
66096: GO 65641
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66098: LD_VAR 0 3
66102: PPUSH
66103: LD_INT 1
66105: PPUSH
66106: CALL_OW 289
66110: PUSH
66111: LD_INT 100
66113: LESS
66114: PUSH
66115: LD_VAR 0 3
66119: PPUSH
66120: CALL_OW 314
66124: NOT
66125: AND
66126: IFFALSE 66155
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66128: LD_VAR 0 3
66132: PPUSH
66133: LD_VAR 0 7
66137: PUSH
66138: LD_INT 2
66140: ARRAY
66141: PPUSH
66142: LD_VAR 0 7
66146: PUSH
66147: LD_INT 3
66149: ARRAY
66150: PPUSH
66151: CALL_OW 117
// break ;
66155: GO 66159
// end ;
66157: GO 65641
66159: POP
66160: POP
// end ; end ;
66161: GO 64357
66163: POP
66164: POP
// end ;
66165: LD_VAR 0 1
66169: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66170: LD_INT 0
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
// if not mc_bases then
66176: LD_EXP 23
66180: NOT
66181: IFFALSE 66185
// exit ;
66183: GO 66346
// for i = 1 to mc_bases do
66185: LD_ADDR_VAR 0 2
66189: PUSH
66190: DOUBLE
66191: LD_INT 1
66193: DEC
66194: ST_TO_ADDR
66195: LD_EXP 23
66199: PUSH
66200: FOR_TO
66201: IFFALSE 66344
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66203: LD_ADDR_VAR 0 4
66207: PUSH
66208: LD_EXP 42
66212: PUSH
66213: LD_VAR 0 2
66217: ARRAY
66218: PUSH
66219: LD_EXP 45
66223: PUSH
66224: LD_VAR 0 2
66228: ARRAY
66229: UNION
66230: PPUSH
66231: LD_INT 33
66233: PUSH
66234: LD_INT 2
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PPUSH
66241: CALL_OW 72
66245: ST_TO_ADDR
// if tmp then
66246: LD_VAR 0 4
66250: IFFALSE 66342
// for j in tmp do
66252: LD_ADDR_VAR 0 3
66256: PUSH
66257: LD_VAR 0 4
66261: PUSH
66262: FOR_IN
66263: IFFALSE 66340
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66265: LD_VAR 0 3
66269: PPUSH
66270: CALL_OW 312
66274: NOT
66275: PUSH
66276: LD_VAR 0 3
66280: PPUSH
66281: CALL_OW 256
66285: PUSH
66286: LD_INT 250
66288: GREATEREQUAL
66289: AND
66290: IFFALSE 66303
// Connect ( j ) else
66292: LD_VAR 0 3
66296: PPUSH
66297: CALL 18984 0 1
66301: GO 66338
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66303: LD_VAR 0 3
66307: PPUSH
66308: CALL_OW 256
66312: PUSH
66313: LD_INT 250
66315: LESS
66316: PUSH
66317: LD_VAR 0 3
66321: PPUSH
66322: CALL_OW 312
66326: AND
66327: IFFALSE 66338
// ComUnlink ( j ) ;
66329: LD_VAR 0 3
66333: PPUSH
66334: CALL_OW 136
66338: GO 66262
66340: POP
66341: POP
// end ;
66342: GO 66200
66344: POP
66345: POP
// end ;
66346: LD_VAR 0 1
66350: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66351: LD_INT 0
66353: PPUSH
66354: PPUSH
66355: PPUSH
66356: PPUSH
66357: PPUSH
// if not mc_bases then
66358: LD_EXP 23
66362: NOT
66363: IFFALSE 66367
// exit ;
66365: GO 66812
// for i = 1 to mc_bases do
66367: LD_ADDR_VAR 0 2
66371: PUSH
66372: DOUBLE
66373: LD_INT 1
66375: DEC
66376: ST_TO_ADDR
66377: LD_EXP 23
66381: PUSH
66382: FOR_TO
66383: IFFALSE 66810
// begin if not mc_produce [ i ] then
66385: LD_EXP 44
66389: PUSH
66390: LD_VAR 0 2
66394: ARRAY
66395: NOT
66396: IFFALSE 66400
// continue ;
66398: GO 66382
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66400: LD_ADDR_VAR 0 5
66404: PUSH
66405: LD_EXP 23
66409: PUSH
66410: LD_VAR 0 2
66414: ARRAY
66415: PPUSH
66416: LD_INT 30
66418: PUSH
66419: LD_INT 3
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PPUSH
66426: CALL_OW 72
66430: ST_TO_ADDR
// if not fac then
66431: LD_VAR 0 5
66435: NOT
66436: IFFALSE 66440
// continue ;
66438: GO 66382
// for j in fac do
66440: LD_ADDR_VAR 0 3
66444: PUSH
66445: LD_VAR 0 5
66449: PUSH
66450: FOR_IN
66451: IFFALSE 66806
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66453: LD_VAR 0 3
66457: PPUSH
66458: CALL_OW 461
66462: PUSH
66463: LD_INT 2
66465: NONEQUAL
66466: PUSH
66467: LD_VAR 0 3
66471: PPUSH
66472: LD_INT 15
66474: PPUSH
66475: CALL 18612 0 2
66479: PUSH
66480: LD_INT 4
66482: ARRAY
66483: OR
66484: IFFALSE 66488
// continue ;
66486: GO 66450
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66488: LD_VAR 0 3
66492: PPUSH
66493: LD_EXP 44
66497: PUSH
66498: LD_VAR 0 2
66502: ARRAY
66503: PUSH
66504: LD_INT 1
66506: ARRAY
66507: PUSH
66508: LD_INT 1
66510: ARRAY
66511: PPUSH
66512: LD_EXP 44
66516: PUSH
66517: LD_VAR 0 2
66521: ARRAY
66522: PUSH
66523: LD_INT 1
66525: ARRAY
66526: PUSH
66527: LD_INT 2
66529: ARRAY
66530: PPUSH
66531: LD_EXP 44
66535: PUSH
66536: LD_VAR 0 2
66540: ARRAY
66541: PUSH
66542: LD_INT 1
66544: ARRAY
66545: PUSH
66546: LD_INT 3
66548: ARRAY
66549: PPUSH
66550: LD_EXP 44
66554: PUSH
66555: LD_VAR 0 2
66559: ARRAY
66560: PUSH
66561: LD_INT 1
66563: ARRAY
66564: PUSH
66565: LD_INT 4
66567: ARRAY
66568: PPUSH
66569: CALL_OW 448
66573: PUSH
66574: LD_VAR 0 3
66578: PPUSH
66579: LD_EXP 44
66583: PUSH
66584: LD_VAR 0 2
66588: ARRAY
66589: PUSH
66590: LD_INT 1
66592: ARRAY
66593: PUSH
66594: LD_INT 1
66596: ARRAY
66597: PUSH
66598: LD_EXP 44
66602: PUSH
66603: LD_VAR 0 2
66607: ARRAY
66608: PUSH
66609: LD_INT 1
66611: ARRAY
66612: PUSH
66613: LD_INT 2
66615: ARRAY
66616: PUSH
66617: LD_EXP 44
66621: PUSH
66622: LD_VAR 0 2
66626: ARRAY
66627: PUSH
66628: LD_INT 1
66630: ARRAY
66631: PUSH
66632: LD_INT 3
66634: ARRAY
66635: PUSH
66636: LD_EXP 44
66640: PUSH
66641: LD_VAR 0 2
66645: ARRAY
66646: PUSH
66647: LD_INT 1
66649: ARRAY
66650: PUSH
66651: LD_INT 4
66653: ARRAY
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: PPUSH
66661: CALL 22379 0 2
66665: AND
66666: IFFALSE 66804
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66668: LD_VAR 0 3
66672: PPUSH
66673: LD_EXP 44
66677: PUSH
66678: LD_VAR 0 2
66682: ARRAY
66683: PUSH
66684: LD_INT 1
66686: ARRAY
66687: PUSH
66688: LD_INT 1
66690: ARRAY
66691: PPUSH
66692: LD_EXP 44
66696: PUSH
66697: LD_VAR 0 2
66701: ARRAY
66702: PUSH
66703: LD_INT 1
66705: ARRAY
66706: PUSH
66707: LD_INT 2
66709: ARRAY
66710: PPUSH
66711: LD_EXP 44
66715: PUSH
66716: LD_VAR 0 2
66720: ARRAY
66721: PUSH
66722: LD_INT 1
66724: ARRAY
66725: PUSH
66726: LD_INT 3
66728: ARRAY
66729: PPUSH
66730: LD_EXP 44
66734: PUSH
66735: LD_VAR 0 2
66739: ARRAY
66740: PUSH
66741: LD_INT 1
66743: ARRAY
66744: PUSH
66745: LD_INT 4
66747: ARRAY
66748: PPUSH
66749: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66753: LD_ADDR_VAR 0 4
66757: PUSH
66758: LD_EXP 44
66762: PUSH
66763: LD_VAR 0 2
66767: ARRAY
66768: PPUSH
66769: LD_INT 1
66771: PPUSH
66772: CALL_OW 3
66776: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66777: LD_ADDR_EXP 44
66781: PUSH
66782: LD_EXP 44
66786: PPUSH
66787: LD_VAR 0 2
66791: PPUSH
66792: LD_VAR 0 4
66796: PPUSH
66797: CALL_OW 1
66801: ST_TO_ADDR
// break ;
66802: GO 66806
// end ; end ;
66804: GO 66450
66806: POP
66807: POP
// end ;
66808: GO 66382
66810: POP
66811: POP
// end ;
66812: LD_VAR 0 1
66816: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66817: LD_INT 0
66819: PPUSH
66820: PPUSH
66821: PPUSH
// if not mc_bases then
66822: LD_EXP 23
66826: NOT
66827: IFFALSE 66831
// exit ;
66829: GO 66920
// for i = 1 to mc_bases do
66831: LD_ADDR_VAR 0 2
66835: PUSH
66836: DOUBLE
66837: LD_INT 1
66839: DEC
66840: ST_TO_ADDR
66841: LD_EXP 23
66845: PUSH
66846: FOR_TO
66847: IFFALSE 66918
// begin if mc_attack [ i ] then
66849: LD_EXP 43
66853: PUSH
66854: LD_VAR 0 2
66858: ARRAY
66859: IFFALSE 66916
// begin tmp := mc_attack [ i ] [ 1 ] ;
66861: LD_ADDR_VAR 0 3
66865: PUSH
66866: LD_EXP 43
66870: PUSH
66871: LD_VAR 0 2
66875: ARRAY
66876: PUSH
66877: LD_INT 1
66879: ARRAY
66880: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66881: LD_ADDR_EXP 43
66885: PUSH
66886: LD_EXP 43
66890: PPUSH
66891: LD_VAR 0 2
66895: PPUSH
66896: EMPTY
66897: PPUSH
66898: CALL_OW 1
66902: ST_TO_ADDR
// Attack ( tmp ) ;
66903: LD_VAR 0 3
66907: PPUSH
66908: CALL 81856 0 1
// exit ;
66912: POP
66913: POP
66914: GO 66920
// end ; end ;
66916: GO 66846
66918: POP
66919: POP
// end ;
66920: LD_VAR 0 1
66924: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66925: LD_INT 0
66927: PPUSH
66928: PPUSH
66929: PPUSH
66930: PPUSH
66931: PPUSH
66932: PPUSH
66933: PPUSH
// if not mc_bases then
66934: LD_EXP 23
66938: NOT
66939: IFFALSE 66943
// exit ;
66941: GO 67800
// for i = 1 to mc_bases do
66943: LD_ADDR_VAR 0 2
66947: PUSH
66948: DOUBLE
66949: LD_INT 1
66951: DEC
66952: ST_TO_ADDR
66953: LD_EXP 23
66957: PUSH
66958: FOR_TO
66959: IFFALSE 67798
// begin if not mc_bases [ i ] then
66961: LD_EXP 23
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: NOT
66972: IFFALSE 66976
// continue ;
66974: GO 66958
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66976: LD_ADDR_VAR 0 7
66980: PUSH
66981: LD_EXP 23
66985: PUSH
66986: LD_VAR 0 2
66990: ARRAY
66991: PUSH
66992: LD_INT 1
66994: ARRAY
66995: PPUSH
66996: CALL 12813 0 1
67000: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67001: LD_ADDR_EXP 46
67005: PUSH
67006: LD_EXP 46
67010: PPUSH
67011: LD_VAR 0 2
67015: PPUSH
67016: LD_EXP 23
67020: PUSH
67021: LD_VAR 0 2
67025: ARRAY
67026: PUSH
67027: LD_INT 1
67029: ARRAY
67030: PPUSH
67031: CALL_OW 255
67035: PPUSH
67036: LD_EXP 48
67040: PUSH
67041: LD_VAR 0 2
67045: ARRAY
67046: PPUSH
67047: CALL 12778 0 2
67051: PPUSH
67052: CALL_OW 1
67056: ST_TO_ADDR
// if not mc_scan [ i ] then
67057: LD_EXP 46
67061: PUSH
67062: LD_VAR 0 2
67066: ARRAY
67067: NOT
67068: IFFALSE 67246
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67070: LD_ADDR_EXP 66
67074: PUSH
67075: LD_EXP 66
67079: PPUSH
67080: LD_VAR 0 2
67084: PPUSH
67085: LD_INT 0
67087: PPUSH
67088: CALL_OW 1
67092: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67093: LD_ADDR_VAR 0 4
67097: PUSH
67098: LD_EXP 23
67102: PUSH
67103: LD_VAR 0 2
67107: ARRAY
67108: PPUSH
67109: LD_INT 2
67111: PUSH
67112: LD_INT 25
67114: PUSH
67115: LD_INT 5
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 25
67124: PUSH
67125: LD_INT 8
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 25
67134: PUSH
67135: LD_INT 9
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: PPUSH
67148: CALL_OW 72
67152: ST_TO_ADDR
// if not tmp then
67153: LD_VAR 0 4
67157: NOT
67158: IFFALSE 67162
// continue ;
67160: GO 66958
// for j in tmp do
67162: LD_ADDR_VAR 0 3
67166: PUSH
67167: LD_VAR 0 4
67171: PUSH
67172: FOR_IN
67173: IFFALSE 67244
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67175: LD_VAR 0 3
67179: PPUSH
67180: CALL_OW 310
67184: PPUSH
67185: CALL_OW 266
67189: PUSH
67190: LD_INT 5
67192: EQUAL
67193: PUSH
67194: LD_VAR 0 3
67198: PPUSH
67199: CALL_OW 257
67203: PUSH
67204: LD_INT 1
67206: EQUAL
67207: AND
67208: PUSH
67209: LD_VAR 0 3
67213: PPUSH
67214: CALL_OW 459
67218: NOT
67219: AND
67220: PUSH
67221: LD_VAR 0 7
67225: AND
67226: IFFALSE 67242
// ComChangeProfession ( j , class ) ;
67228: LD_VAR 0 3
67232: PPUSH
67233: LD_VAR 0 7
67237: PPUSH
67238: CALL_OW 123
67242: GO 67172
67244: POP
67245: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67246: LD_EXP 46
67250: PUSH
67251: LD_VAR 0 2
67255: ARRAY
67256: PUSH
67257: LD_EXP 66
67261: PUSH
67262: LD_VAR 0 2
67266: ARRAY
67267: NOT
67268: AND
67269: PUSH
67270: LD_EXP 45
67274: PUSH
67275: LD_VAR 0 2
67279: ARRAY
67280: NOT
67281: AND
67282: PUSH
67283: LD_EXP 23
67287: PUSH
67288: LD_VAR 0 2
67292: ARRAY
67293: PPUSH
67294: LD_INT 50
67296: PUSH
67297: EMPTY
67298: LIST
67299: PUSH
67300: LD_INT 2
67302: PUSH
67303: LD_INT 30
67305: PUSH
67306: LD_INT 32
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 30
67315: PUSH
67316: LD_INT 33
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 30
67325: PUSH
67326: LD_INT 4
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 30
67335: PUSH
67336: LD_INT 5
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PPUSH
67354: CALL_OW 72
67358: PUSH
67359: LD_INT 4
67361: LESS
67362: PUSH
67363: LD_EXP 23
67367: PUSH
67368: LD_VAR 0 2
67372: ARRAY
67373: PPUSH
67374: LD_INT 3
67376: PUSH
67377: LD_INT 24
67379: PUSH
67380: LD_INT 1000
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 2
67393: PUSH
67394: LD_INT 30
67396: PUSH
67397: LD_INT 0
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 30
67406: PUSH
67407: LD_INT 1
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: LIST
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PPUSH
67423: CALL_OW 72
67427: OR
67428: AND
67429: IFFALSE 67680
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67431: LD_ADDR_EXP 66
67435: PUSH
67436: LD_EXP 66
67440: PPUSH
67441: LD_VAR 0 2
67445: PPUSH
67446: LD_INT 1
67448: PPUSH
67449: CALL_OW 1
67453: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67454: LD_ADDR_VAR 0 4
67458: PUSH
67459: LD_EXP 23
67463: PUSH
67464: LD_VAR 0 2
67468: ARRAY
67469: PPUSH
67470: LD_INT 2
67472: PUSH
67473: LD_INT 25
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 25
67485: PUSH
67486: LD_INT 5
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 25
67495: PUSH
67496: LD_INT 8
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 25
67505: PUSH
67506: LD_INT 9
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: PPUSH
67520: CALL_OW 72
67524: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67525: LD_ADDR_VAR 0 4
67529: PUSH
67530: LD_VAR 0 4
67534: PUSH
67535: LD_VAR 0 4
67539: PPUSH
67540: LD_INT 18
67542: PPUSH
67543: CALL 45282 0 2
67547: DIFF
67548: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67549: LD_VAR 0 4
67553: NOT
67554: PUSH
67555: LD_EXP 23
67559: PUSH
67560: LD_VAR 0 2
67564: ARRAY
67565: PPUSH
67566: LD_INT 2
67568: PUSH
67569: LD_INT 30
67571: PUSH
67572: LD_INT 4
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 30
67581: PUSH
67582: LD_INT 5
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: LIST
67593: PPUSH
67594: CALL_OW 72
67598: NOT
67599: AND
67600: IFFALSE 67662
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67602: LD_ADDR_VAR 0 4
67606: PUSH
67607: LD_EXP 23
67611: PUSH
67612: LD_VAR 0 2
67616: ARRAY
67617: PPUSH
67618: LD_INT 2
67620: PUSH
67621: LD_INT 25
67623: PUSH
67624: LD_INT 2
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 25
67633: PUSH
67634: LD_INT 3
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 25
67643: PUSH
67644: LD_INT 4
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: PPUSH
67657: CALL_OW 72
67661: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67662: LD_VAR 0 2
67666: PPUSH
67667: LD_VAR 0 4
67671: PPUSH
67672: CALL 86565 0 2
// exit ;
67676: POP
67677: POP
67678: GO 67800
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67680: LD_EXP 46
67684: PUSH
67685: LD_VAR 0 2
67689: ARRAY
67690: PUSH
67691: LD_EXP 66
67695: PUSH
67696: LD_VAR 0 2
67700: ARRAY
67701: NOT
67702: AND
67703: PUSH
67704: LD_EXP 45
67708: PUSH
67709: LD_VAR 0 2
67713: ARRAY
67714: AND
67715: IFFALSE 67796
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67717: LD_ADDR_EXP 66
67721: PUSH
67722: LD_EXP 66
67726: PPUSH
67727: LD_VAR 0 2
67731: PPUSH
67732: LD_INT 1
67734: PPUSH
67735: CALL_OW 1
67739: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67740: LD_ADDR_VAR 0 4
67744: PUSH
67745: LD_EXP 45
67749: PUSH
67750: LD_VAR 0 2
67754: ARRAY
67755: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67756: LD_ADDR_EXP 45
67760: PUSH
67761: LD_EXP 45
67765: PPUSH
67766: LD_VAR 0 2
67770: PPUSH
67771: EMPTY
67772: PPUSH
67773: CALL_OW 1
67777: ST_TO_ADDR
// Defend ( i , tmp ) ;
67778: LD_VAR 0 2
67782: PPUSH
67783: LD_VAR 0 4
67787: PPUSH
67788: CALL 87161 0 2
// exit ;
67792: POP
67793: POP
67794: GO 67800
// end ; end ;
67796: GO 66958
67798: POP
67799: POP
// end ;
67800: LD_VAR 0 1
67804: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67805: LD_INT 0
67807: PPUSH
67808: PPUSH
67809: PPUSH
67810: PPUSH
67811: PPUSH
67812: PPUSH
67813: PPUSH
67814: PPUSH
67815: PPUSH
67816: PPUSH
67817: PPUSH
// if not mc_bases then
67818: LD_EXP 23
67822: NOT
67823: IFFALSE 67827
// exit ;
67825: GO 68914
// for i = 1 to mc_bases do
67827: LD_ADDR_VAR 0 2
67831: PUSH
67832: DOUBLE
67833: LD_INT 1
67835: DEC
67836: ST_TO_ADDR
67837: LD_EXP 23
67841: PUSH
67842: FOR_TO
67843: IFFALSE 68912
// begin tmp := mc_lab [ i ] ;
67845: LD_ADDR_VAR 0 6
67849: PUSH
67850: LD_EXP 56
67854: PUSH
67855: LD_VAR 0 2
67859: ARRAY
67860: ST_TO_ADDR
// if not tmp then
67861: LD_VAR 0 6
67865: NOT
67866: IFFALSE 67870
// continue ;
67868: GO 67842
// idle_lab := 0 ;
67870: LD_ADDR_VAR 0 11
67874: PUSH
67875: LD_INT 0
67877: ST_TO_ADDR
// for j in tmp do
67878: LD_ADDR_VAR 0 3
67882: PUSH
67883: LD_VAR 0 6
67887: PUSH
67888: FOR_IN
67889: IFFALSE 68908
// begin researching := false ;
67891: LD_ADDR_VAR 0 10
67895: PUSH
67896: LD_INT 0
67898: ST_TO_ADDR
// side := GetSide ( j ) ;
67899: LD_ADDR_VAR 0 4
67903: PUSH
67904: LD_VAR 0 3
67908: PPUSH
67909: CALL_OW 255
67913: ST_TO_ADDR
// if not mc_tech [ side ] then
67914: LD_EXP 50
67918: PUSH
67919: LD_VAR 0 4
67923: ARRAY
67924: NOT
67925: IFFALSE 67929
// continue ;
67927: GO 67888
// if BuildingStatus ( j ) = bs_idle then
67929: LD_VAR 0 3
67933: PPUSH
67934: CALL_OW 461
67938: PUSH
67939: LD_INT 2
67941: EQUAL
67942: IFFALSE 68130
// begin if idle_lab and UnitsInside ( j ) < 6 then
67944: LD_VAR 0 11
67948: PUSH
67949: LD_VAR 0 3
67953: PPUSH
67954: CALL_OW 313
67958: PUSH
67959: LD_INT 6
67961: LESS
67962: AND
67963: IFFALSE 68034
// begin tmp2 := UnitsInside ( idle_lab ) ;
67965: LD_ADDR_VAR 0 9
67969: PUSH
67970: LD_VAR 0 11
67974: PPUSH
67975: CALL_OW 313
67979: ST_TO_ADDR
// if tmp2 then
67980: LD_VAR 0 9
67984: IFFALSE 68026
// for x in tmp2 do
67986: LD_ADDR_VAR 0 7
67990: PUSH
67991: LD_VAR 0 9
67995: PUSH
67996: FOR_IN
67997: IFFALSE 68024
// begin ComExitBuilding ( x ) ;
67999: LD_VAR 0 7
68003: PPUSH
68004: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68008: LD_VAR 0 7
68012: PPUSH
68013: LD_VAR 0 3
68017: PPUSH
68018: CALL_OW 180
// end ;
68022: GO 67996
68024: POP
68025: POP
// idle_lab := 0 ;
68026: LD_ADDR_VAR 0 11
68030: PUSH
68031: LD_INT 0
68033: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68034: LD_ADDR_VAR 0 5
68038: PUSH
68039: LD_EXP 50
68043: PUSH
68044: LD_VAR 0 4
68048: ARRAY
68049: PUSH
68050: FOR_IN
68051: IFFALSE 68111
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68053: LD_VAR 0 3
68057: PPUSH
68058: LD_VAR 0 5
68062: PPUSH
68063: CALL_OW 430
68067: PUSH
68068: LD_VAR 0 4
68072: PPUSH
68073: LD_VAR 0 5
68077: PPUSH
68078: CALL 11883 0 2
68082: AND
68083: IFFALSE 68109
// begin researching := true ;
68085: LD_ADDR_VAR 0 10
68089: PUSH
68090: LD_INT 1
68092: ST_TO_ADDR
// ComResearch ( j , t ) ;
68093: LD_VAR 0 3
68097: PPUSH
68098: LD_VAR 0 5
68102: PPUSH
68103: CALL_OW 124
// break ;
68107: GO 68111
// end ;
68109: GO 68050
68111: POP
68112: POP
// if not researching then
68113: LD_VAR 0 10
68117: NOT
68118: IFFALSE 68130
// idle_lab := j ;
68120: LD_ADDR_VAR 0 11
68124: PUSH
68125: LD_VAR 0 3
68129: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68130: LD_VAR 0 3
68134: PPUSH
68135: CALL_OW 461
68139: PUSH
68140: LD_INT 10
68142: EQUAL
68143: IFFALSE 68731
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68145: LD_EXP 52
68149: PUSH
68150: LD_VAR 0 2
68154: ARRAY
68155: NOT
68156: PUSH
68157: LD_EXP 53
68161: PUSH
68162: LD_VAR 0 2
68166: ARRAY
68167: NOT
68168: AND
68169: PUSH
68170: LD_EXP 50
68174: PUSH
68175: LD_VAR 0 4
68179: ARRAY
68180: PUSH
68181: LD_INT 1
68183: GREATER
68184: AND
68185: IFFALSE 68316
// begin ComCancel ( j ) ;
68187: LD_VAR 0 3
68191: PPUSH
68192: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68196: LD_ADDR_EXP 50
68200: PUSH
68201: LD_EXP 50
68205: PPUSH
68206: LD_VAR 0 4
68210: PPUSH
68211: LD_EXP 50
68215: PUSH
68216: LD_VAR 0 4
68220: ARRAY
68221: PPUSH
68222: LD_EXP 50
68226: PUSH
68227: LD_VAR 0 4
68231: ARRAY
68232: PUSH
68233: LD_INT 1
68235: MINUS
68236: PPUSH
68237: LD_EXP 50
68241: PUSH
68242: LD_VAR 0 4
68246: ARRAY
68247: PPUSH
68248: LD_INT 0
68250: PPUSH
68251: CALL 15431 0 4
68255: PPUSH
68256: CALL_OW 1
68260: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68261: LD_ADDR_EXP 50
68265: PUSH
68266: LD_EXP 50
68270: PPUSH
68271: LD_VAR 0 4
68275: PPUSH
68276: LD_EXP 50
68280: PUSH
68281: LD_VAR 0 4
68285: ARRAY
68286: PPUSH
68287: LD_EXP 50
68291: PUSH
68292: LD_VAR 0 4
68296: ARRAY
68297: PPUSH
68298: LD_INT 1
68300: PPUSH
68301: LD_INT 0
68303: PPUSH
68304: CALL 15431 0 4
68308: PPUSH
68309: CALL_OW 1
68313: ST_TO_ADDR
// continue ;
68314: GO 67888
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68316: LD_EXP 52
68320: PUSH
68321: LD_VAR 0 2
68325: ARRAY
68326: PUSH
68327: LD_EXP 53
68331: PUSH
68332: LD_VAR 0 2
68336: ARRAY
68337: NOT
68338: AND
68339: IFFALSE 68466
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68341: LD_ADDR_EXP 53
68345: PUSH
68346: LD_EXP 53
68350: PPUSH
68351: LD_VAR 0 2
68355: PUSH
68356: LD_EXP 53
68360: PUSH
68361: LD_VAR 0 2
68365: ARRAY
68366: PUSH
68367: LD_INT 1
68369: PLUS
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PPUSH
68375: LD_EXP 52
68379: PUSH
68380: LD_VAR 0 2
68384: ARRAY
68385: PUSH
68386: LD_INT 1
68388: ARRAY
68389: PPUSH
68390: CALL 16013 0 3
68394: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68395: LD_EXP 52
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: PUSH
68406: LD_INT 1
68408: ARRAY
68409: PPUSH
68410: LD_INT 112
68412: PPUSH
68413: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68417: LD_ADDR_VAR 0 9
68421: PUSH
68422: LD_EXP 52
68426: PUSH
68427: LD_VAR 0 2
68431: ARRAY
68432: PPUSH
68433: LD_INT 1
68435: PPUSH
68436: CALL_OW 3
68440: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68441: LD_ADDR_EXP 52
68445: PUSH
68446: LD_EXP 52
68450: PPUSH
68451: LD_VAR 0 2
68455: PPUSH
68456: LD_VAR 0 9
68460: PPUSH
68461: CALL_OW 1
68465: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68466: LD_EXP 52
68470: PUSH
68471: LD_VAR 0 2
68475: ARRAY
68476: PUSH
68477: LD_EXP 53
68481: PUSH
68482: LD_VAR 0 2
68486: ARRAY
68487: AND
68488: PUSH
68489: LD_EXP 53
68493: PUSH
68494: LD_VAR 0 2
68498: ARRAY
68499: PUSH
68500: LD_INT 1
68502: ARRAY
68503: PPUSH
68504: CALL_OW 310
68508: NOT
68509: AND
68510: PUSH
68511: LD_VAR 0 3
68515: PPUSH
68516: CALL_OW 313
68520: PUSH
68521: LD_INT 6
68523: EQUAL
68524: AND
68525: IFFALSE 68581
// begin tmp2 := UnitsInside ( j ) ;
68527: LD_ADDR_VAR 0 9
68531: PUSH
68532: LD_VAR 0 3
68536: PPUSH
68537: CALL_OW 313
68541: ST_TO_ADDR
// if tmp2 = 6 then
68542: LD_VAR 0 9
68546: PUSH
68547: LD_INT 6
68549: EQUAL
68550: IFFALSE 68581
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68552: LD_VAR 0 9
68556: PUSH
68557: LD_INT 1
68559: ARRAY
68560: PPUSH
68561: LD_INT 112
68563: PPUSH
68564: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68568: LD_VAR 0 9
68572: PUSH
68573: LD_INT 1
68575: ARRAY
68576: PPUSH
68577: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68581: LD_EXP 53
68585: PUSH
68586: LD_VAR 0 2
68590: ARRAY
68591: PUSH
68592: LD_EXP 53
68596: PUSH
68597: LD_VAR 0 2
68601: ARRAY
68602: PUSH
68603: LD_INT 1
68605: ARRAY
68606: PPUSH
68607: CALL_OW 314
68611: NOT
68612: AND
68613: PUSH
68614: LD_EXP 53
68618: PUSH
68619: LD_VAR 0 2
68623: ARRAY
68624: PUSH
68625: LD_INT 1
68627: ARRAY
68628: PPUSH
68629: CALL_OW 310
68633: NOT
68634: AND
68635: IFFALSE 68661
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68637: LD_EXP 53
68641: PUSH
68642: LD_VAR 0 2
68646: ARRAY
68647: PUSH
68648: LD_INT 1
68650: ARRAY
68651: PPUSH
68652: LD_VAR 0 3
68656: PPUSH
68657: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68661: LD_EXP 53
68665: PUSH
68666: LD_VAR 0 2
68670: ARRAY
68671: PUSH
68672: LD_INT 1
68674: ARRAY
68675: PPUSH
68676: CALL_OW 310
68680: PUSH
68681: LD_EXP 53
68685: PUSH
68686: LD_VAR 0 2
68690: ARRAY
68691: PUSH
68692: LD_INT 1
68694: ARRAY
68695: PPUSH
68696: CALL_OW 310
68700: PPUSH
68701: CALL_OW 461
68705: PUSH
68706: LD_INT 3
68708: NONEQUAL
68709: AND
68710: IFFALSE 68731
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68712: LD_EXP 53
68716: PUSH
68717: LD_VAR 0 2
68721: ARRAY
68722: PUSH
68723: LD_INT 1
68725: ARRAY
68726: PPUSH
68727: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68731: LD_VAR 0 3
68735: PPUSH
68736: CALL_OW 461
68740: PUSH
68741: LD_INT 6
68743: EQUAL
68744: PUSH
68745: LD_VAR 0 6
68749: PUSH
68750: LD_INT 1
68752: GREATER
68753: AND
68754: IFFALSE 68906
// begin sci := [ ] ;
68756: LD_ADDR_VAR 0 8
68760: PUSH
68761: EMPTY
68762: ST_TO_ADDR
// for x in ( tmp diff j ) do
68763: LD_ADDR_VAR 0 7
68767: PUSH
68768: LD_VAR 0 6
68772: PUSH
68773: LD_VAR 0 3
68777: DIFF
68778: PUSH
68779: FOR_IN
68780: IFFALSE 68832
// begin if sci = 6 then
68782: LD_VAR 0 8
68786: PUSH
68787: LD_INT 6
68789: EQUAL
68790: IFFALSE 68794
// break ;
68792: GO 68832
// if BuildingStatus ( x ) = bs_idle then
68794: LD_VAR 0 7
68798: PPUSH
68799: CALL_OW 461
68803: PUSH
68804: LD_INT 2
68806: EQUAL
68807: IFFALSE 68830
// sci := sci ^ UnitsInside ( x ) ;
68809: LD_ADDR_VAR 0 8
68813: PUSH
68814: LD_VAR 0 8
68818: PUSH
68819: LD_VAR 0 7
68823: PPUSH
68824: CALL_OW 313
68828: ADD
68829: ST_TO_ADDR
// end ;
68830: GO 68779
68832: POP
68833: POP
// if not sci then
68834: LD_VAR 0 8
68838: NOT
68839: IFFALSE 68843
// continue ;
68841: GO 67888
// for x in sci do
68843: LD_ADDR_VAR 0 7
68847: PUSH
68848: LD_VAR 0 8
68852: PUSH
68853: FOR_IN
68854: IFFALSE 68904
// if IsInUnit ( x ) and not HasTask ( x ) then
68856: LD_VAR 0 7
68860: PPUSH
68861: CALL_OW 310
68865: PUSH
68866: LD_VAR 0 7
68870: PPUSH
68871: CALL_OW 314
68875: NOT
68876: AND
68877: IFFALSE 68902
// begin ComExitBuilding ( x ) ;
68879: LD_VAR 0 7
68883: PPUSH
68884: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68888: LD_VAR 0 7
68892: PPUSH
68893: LD_VAR 0 3
68897: PPUSH
68898: CALL_OW 180
// end ;
68902: GO 68853
68904: POP
68905: POP
// end ; end ;
68906: GO 67888
68908: POP
68909: POP
// end ;
68910: GO 67842
68912: POP
68913: POP
// end ;
68914: LD_VAR 0 1
68918: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68919: LD_INT 0
68921: PPUSH
68922: PPUSH
// if not mc_bases then
68923: LD_EXP 23
68927: NOT
68928: IFFALSE 68932
// exit ;
68930: GO 69013
// for i = 1 to mc_bases do
68932: LD_ADDR_VAR 0 2
68936: PUSH
68937: DOUBLE
68938: LD_INT 1
68940: DEC
68941: ST_TO_ADDR
68942: LD_EXP 23
68946: PUSH
68947: FOR_TO
68948: IFFALSE 69011
// if mc_mines [ i ] and mc_miners [ i ] then
68950: LD_EXP 36
68954: PUSH
68955: LD_VAR 0 2
68959: ARRAY
68960: PUSH
68961: LD_EXP 37
68965: PUSH
68966: LD_VAR 0 2
68970: ARRAY
68971: AND
68972: IFFALSE 69009
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68974: LD_EXP 37
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PUSH
68985: LD_INT 1
68987: ARRAY
68988: PPUSH
68989: CALL_OW 255
68993: PPUSH
68994: LD_EXP 36
68998: PUSH
68999: LD_VAR 0 2
69003: ARRAY
69004: PPUSH
69005: CALL 12966 0 2
69009: GO 68947
69011: POP
69012: POP
// end ;
69013: LD_VAR 0 1
69017: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69018: LD_INT 0
69020: PPUSH
69021: PPUSH
69022: PPUSH
69023: PPUSH
69024: PPUSH
69025: PPUSH
69026: PPUSH
69027: PPUSH
// if not mc_bases or not mc_parking then
69028: LD_EXP 23
69032: NOT
69033: PUSH
69034: LD_EXP 47
69038: NOT
69039: OR
69040: IFFALSE 69044
// exit ;
69042: GO 69754
// for i = 1 to mc_bases do
69044: LD_ADDR_VAR 0 2
69048: PUSH
69049: DOUBLE
69050: LD_INT 1
69052: DEC
69053: ST_TO_ADDR
69054: LD_EXP 23
69058: PUSH
69059: FOR_TO
69060: IFFALSE 69752
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69062: LD_EXP 23
69066: PUSH
69067: LD_VAR 0 2
69071: ARRAY
69072: NOT
69073: PUSH
69074: LD_EXP 47
69078: PUSH
69079: LD_VAR 0 2
69083: ARRAY
69084: NOT
69085: OR
69086: IFFALSE 69090
// continue ;
69088: GO 69059
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69090: LD_ADDR_VAR 0 5
69094: PUSH
69095: LD_EXP 23
69099: PUSH
69100: LD_VAR 0 2
69104: ARRAY
69105: PUSH
69106: LD_INT 1
69108: ARRAY
69109: PPUSH
69110: CALL_OW 255
69114: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69115: LD_ADDR_VAR 0 6
69119: PUSH
69120: LD_EXP 23
69124: PUSH
69125: LD_VAR 0 2
69129: ARRAY
69130: PPUSH
69131: LD_INT 30
69133: PUSH
69134: LD_INT 3
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PPUSH
69141: CALL_OW 72
69145: ST_TO_ADDR
// if not fac then
69146: LD_VAR 0 6
69150: NOT
69151: IFFALSE 69202
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69153: LD_ADDR_VAR 0 6
69157: PUSH
69158: LD_EXP 23
69162: PUSH
69163: LD_VAR 0 2
69167: ARRAY
69168: PPUSH
69169: LD_INT 2
69171: PUSH
69172: LD_INT 30
69174: PUSH
69175: LD_INT 0
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 30
69184: PUSH
69185: LD_INT 1
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: LIST
69196: PPUSH
69197: CALL_OW 72
69201: ST_TO_ADDR
// if not fac then
69202: LD_VAR 0 6
69206: NOT
69207: IFFALSE 69211
// continue ;
69209: GO 69059
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69211: LD_ADDR_VAR 0 7
69215: PUSH
69216: LD_EXP 47
69220: PUSH
69221: LD_VAR 0 2
69225: ARRAY
69226: PPUSH
69227: LD_INT 22
69229: PUSH
69230: LD_VAR 0 5
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 21
69241: PUSH
69242: LD_INT 2
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 3
69251: PUSH
69252: LD_INT 24
69254: PUSH
69255: LD_INT 1000
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: EMPTY
69263: LIST
69264: LIST
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: LIST
69270: PPUSH
69271: CALL_OW 70
69275: ST_TO_ADDR
// for j in fac do
69276: LD_ADDR_VAR 0 3
69280: PUSH
69281: LD_VAR 0 6
69285: PUSH
69286: FOR_IN
69287: IFFALSE 69368
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69289: LD_ADDR_VAR 0 7
69293: PUSH
69294: LD_VAR 0 7
69298: PUSH
69299: LD_INT 22
69301: PUSH
69302: LD_VAR 0 5
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 91
69313: PUSH
69314: LD_VAR 0 3
69318: PUSH
69319: LD_INT 15
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 21
69329: PUSH
69330: LD_INT 2
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 3
69339: PUSH
69340: LD_INT 24
69342: PUSH
69343: LD_INT 1000
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: PPUSH
69360: CALL_OW 69
69364: UNION
69365: ST_TO_ADDR
69366: GO 69286
69368: POP
69369: POP
// if not vehs then
69370: LD_VAR 0 7
69374: NOT
69375: IFFALSE 69401
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69377: LD_ADDR_EXP 35
69381: PUSH
69382: LD_EXP 35
69386: PPUSH
69387: LD_VAR 0 2
69391: PPUSH
69392: EMPTY
69393: PPUSH
69394: CALL_OW 1
69398: ST_TO_ADDR
// continue ;
69399: GO 69059
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69401: LD_ADDR_VAR 0 8
69405: PUSH
69406: LD_EXP 23
69410: PUSH
69411: LD_VAR 0 2
69415: ARRAY
69416: PPUSH
69417: LD_INT 30
69419: PUSH
69420: LD_INT 3
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PPUSH
69427: CALL_OW 72
69431: ST_TO_ADDR
// if tmp then
69432: LD_VAR 0 8
69436: IFFALSE 69539
// begin for j in tmp do
69438: LD_ADDR_VAR 0 3
69442: PUSH
69443: LD_VAR 0 8
69447: PUSH
69448: FOR_IN
69449: IFFALSE 69537
// for k in UnitsInside ( j ) do
69451: LD_ADDR_VAR 0 4
69455: PUSH
69456: LD_VAR 0 3
69460: PPUSH
69461: CALL_OW 313
69465: PUSH
69466: FOR_IN
69467: IFFALSE 69533
// if k then
69469: LD_VAR 0 4
69473: IFFALSE 69531
// if not k in mc_repair_vehicle [ i ] then
69475: LD_VAR 0 4
69479: PUSH
69480: LD_EXP 35
69484: PUSH
69485: LD_VAR 0 2
69489: ARRAY
69490: IN
69491: NOT
69492: IFFALSE 69531
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69494: LD_ADDR_EXP 35
69498: PUSH
69499: LD_EXP 35
69503: PPUSH
69504: LD_VAR 0 2
69508: PPUSH
69509: LD_EXP 35
69513: PUSH
69514: LD_VAR 0 2
69518: ARRAY
69519: PUSH
69520: LD_VAR 0 4
69524: UNION
69525: PPUSH
69526: CALL_OW 1
69530: ST_TO_ADDR
69531: GO 69466
69533: POP
69534: POP
69535: GO 69448
69537: POP
69538: POP
// end ; if not mc_repair_vehicle [ i ] then
69539: LD_EXP 35
69543: PUSH
69544: LD_VAR 0 2
69548: ARRAY
69549: NOT
69550: IFFALSE 69554
// continue ;
69552: GO 69059
// for j in mc_repair_vehicle [ i ] do
69554: LD_ADDR_VAR 0 3
69558: PUSH
69559: LD_EXP 35
69563: PUSH
69564: LD_VAR 0 2
69568: ARRAY
69569: PUSH
69570: FOR_IN
69571: IFFALSE 69748
// begin if GetClass ( j ) <> 3 then
69573: LD_VAR 0 3
69577: PPUSH
69578: CALL_OW 257
69582: PUSH
69583: LD_INT 3
69585: NONEQUAL
69586: IFFALSE 69627
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69588: LD_ADDR_EXP 35
69592: PUSH
69593: LD_EXP 35
69597: PPUSH
69598: LD_VAR 0 2
69602: PPUSH
69603: LD_EXP 35
69607: PUSH
69608: LD_VAR 0 2
69612: ARRAY
69613: PUSH
69614: LD_VAR 0 3
69618: DIFF
69619: PPUSH
69620: CALL_OW 1
69624: ST_TO_ADDR
// continue ;
69625: GO 69570
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69627: LD_VAR 0 3
69631: PPUSH
69632: CALL_OW 311
69636: NOT
69637: PUSH
69638: LD_VAR 0 3
69642: PUSH
69643: LD_EXP 26
69647: PUSH
69648: LD_VAR 0 2
69652: ARRAY
69653: PUSH
69654: LD_INT 1
69656: ARRAY
69657: IN
69658: NOT
69659: AND
69660: PUSH
69661: LD_VAR 0 3
69665: PUSH
69666: LD_EXP 26
69670: PUSH
69671: LD_VAR 0 2
69675: ARRAY
69676: PUSH
69677: LD_INT 2
69679: ARRAY
69680: IN
69681: NOT
69682: AND
69683: IFFALSE 69746
// begin if IsInUnit ( j ) then
69685: LD_VAR 0 3
69689: PPUSH
69690: CALL_OW 310
69694: IFFALSE 69707
// ComExitBuilding ( j ) else
69696: LD_VAR 0 3
69700: PPUSH
69701: CALL_OW 122
69705: GO 69746
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69707: LD_VAR 0 3
69711: PPUSH
69712: LD_VAR 0 7
69716: PUSH
69717: LD_INT 1
69719: ARRAY
69720: PPUSH
69721: CALL 49765 0 2
69725: NOT
69726: IFFALSE 69746
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69728: LD_VAR 0 3
69732: PPUSH
69733: LD_VAR 0 7
69737: PUSH
69738: LD_INT 1
69740: ARRAY
69741: PPUSH
69742: CALL_OW 129
// end ; end ;
69746: GO 69570
69748: POP
69749: POP
// end ;
69750: GO 69059
69752: POP
69753: POP
// end ;
69754: LD_VAR 0 1
69758: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69759: LD_INT 0
69761: PPUSH
69762: PPUSH
69763: PPUSH
69764: PPUSH
69765: PPUSH
69766: PPUSH
69767: PPUSH
69768: PPUSH
69769: PPUSH
69770: PPUSH
69771: PPUSH
// if not mc_bases then
69772: LD_EXP 23
69776: NOT
69777: IFFALSE 69781
// exit ;
69779: GO 70583
// for i = 1 to mc_bases do
69781: LD_ADDR_VAR 0 2
69785: PUSH
69786: DOUBLE
69787: LD_INT 1
69789: DEC
69790: ST_TO_ADDR
69791: LD_EXP 23
69795: PUSH
69796: FOR_TO
69797: IFFALSE 70581
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69799: LD_EXP 51
69803: PUSH
69804: LD_VAR 0 2
69808: ARRAY
69809: NOT
69810: PUSH
69811: LD_EXP 26
69815: PUSH
69816: LD_VAR 0 2
69820: ARRAY
69821: PUSH
69822: LD_INT 1
69824: ARRAY
69825: OR
69826: PUSH
69827: LD_EXP 26
69831: PUSH
69832: LD_VAR 0 2
69836: ARRAY
69837: PUSH
69838: LD_INT 2
69840: ARRAY
69841: OR
69842: PUSH
69843: LD_EXP 49
69847: PUSH
69848: LD_VAR 0 2
69852: ARRAY
69853: PPUSH
69854: LD_INT 1
69856: PPUSH
69857: CALL_OW 325
69861: NOT
69862: OR
69863: PUSH
69864: LD_EXP 46
69868: PUSH
69869: LD_VAR 0 2
69873: ARRAY
69874: OR
69875: IFFALSE 69879
// continue ;
69877: GO 69796
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69879: LD_ADDR_VAR 0 8
69883: PUSH
69884: LD_EXP 23
69888: PUSH
69889: LD_VAR 0 2
69893: ARRAY
69894: PPUSH
69895: LD_INT 25
69897: PUSH
69898: LD_INT 4
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 50
69907: PUSH
69908: EMPTY
69909: LIST
69910: PUSH
69911: LD_INT 3
69913: PUSH
69914: LD_INT 60
69916: PUSH
69917: EMPTY
69918: LIST
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: LIST
69928: PPUSH
69929: CALL_OW 72
69933: PUSH
69934: LD_EXP 27
69938: PUSH
69939: LD_VAR 0 2
69943: ARRAY
69944: DIFF
69945: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69946: LD_ADDR_VAR 0 9
69950: PUSH
69951: LD_EXP 23
69955: PUSH
69956: LD_VAR 0 2
69960: ARRAY
69961: PPUSH
69962: LD_INT 2
69964: PUSH
69965: LD_INT 30
69967: PUSH
69968: LD_INT 0
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 30
69977: PUSH
69978: LD_INT 1
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: LIST
69989: PPUSH
69990: CALL_OW 72
69994: ST_TO_ADDR
// if not tmp or not dep then
69995: LD_VAR 0 8
69999: NOT
70000: PUSH
70001: LD_VAR 0 9
70005: NOT
70006: OR
70007: IFFALSE 70011
// continue ;
70009: GO 69796
// side := GetSide ( tmp [ 1 ] ) ;
70011: LD_ADDR_VAR 0 11
70015: PUSH
70016: LD_VAR 0 8
70020: PUSH
70021: LD_INT 1
70023: ARRAY
70024: PPUSH
70025: CALL_OW 255
70029: ST_TO_ADDR
// dep := dep [ 1 ] ;
70030: LD_ADDR_VAR 0 9
70034: PUSH
70035: LD_VAR 0 9
70039: PUSH
70040: LD_INT 1
70042: ARRAY
70043: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70044: LD_ADDR_VAR 0 7
70048: PUSH
70049: LD_EXP 51
70053: PUSH
70054: LD_VAR 0 2
70058: ARRAY
70059: PPUSH
70060: LD_INT 22
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 25
70072: PUSH
70073: LD_INT 12
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: PPUSH
70084: CALL_OW 70
70088: PUSH
70089: LD_INT 22
70091: PUSH
70092: LD_INT 0
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 25
70101: PUSH
70102: LD_INT 12
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 91
70111: PUSH
70112: LD_VAR 0 9
70116: PUSH
70117: LD_INT 20
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: LIST
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: LIST
70129: PPUSH
70130: CALL_OW 69
70134: UNION
70135: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70136: LD_ADDR_VAR 0 10
70140: PUSH
70141: LD_EXP 51
70145: PUSH
70146: LD_VAR 0 2
70150: ARRAY
70151: PPUSH
70152: LD_INT 81
70154: PUSH
70155: LD_VAR 0 11
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PPUSH
70164: CALL_OW 70
70168: ST_TO_ADDR
// if not apes or danger_at_area then
70169: LD_VAR 0 7
70173: NOT
70174: PUSH
70175: LD_VAR 0 10
70179: OR
70180: IFFALSE 70230
// begin if mc_taming [ i ] then
70182: LD_EXP 54
70186: PUSH
70187: LD_VAR 0 2
70191: ARRAY
70192: IFFALSE 70228
// begin MC_Reset ( i , 121 ) ;
70194: LD_VAR 0 2
70198: PPUSH
70199: LD_INT 121
70201: PPUSH
70202: CALL 55216 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70206: LD_ADDR_EXP 54
70210: PUSH
70211: LD_EXP 54
70215: PPUSH
70216: LD_VAR 0 2
70220: PPUSH
70221: EMPTY
70222: PPUSH
70223: CALL_OW 1
70227: ST_TO_ADDR
// end ; continue ;
70228: GO 69796
// end ; for j in tmp do
70230: LD_ADDR_VAR 0 3
70234: PUSH
70235: LD_VAR 0 8
70239: PUSH
70240: FOR_IN
70241: IFFALSE 70577
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70243: LD_VAR 0 3
70247: PUSH
70248: LD_EXP 54
70252: PUSH
70253: LD_VAR 0 2
70257: ARRAY
70258: IN
70259: NOT
70260: PUSH
70261: LD_EXP 54
70265: PUSH
70266: LD_VAR 0 2
70270: ARRAY
70271: PUSH
70272: LD_INT 3
70274: LESS
70275: AND
70276: IFFALSE 70334
// begin SetTag ( j , 121 ) ;
70278: LD_VAR 0 3
70282: PPUSH
70283: LD_INT 121
70285: PPUSH
70286: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70290: LD_ADDR_EXP 54
70294: PUSH
70295: LD_EXP 54
70299: PPUSH
70300: LD_VAR 0 2
70304: PUSH
70305: LD_EXP 54
70309: PUSH
70310: LD_VAR 0 2
70314: ARRAY
70315: PUSH
70316: LD_INT 1
70318: PLUS
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PPUSH
70324: LD_VAR 0 3
70328: PPUSH
70329: CALL 16013 0 3
70333: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70334: LD_VAR 0 3
70338: PUSH
70339: LD_EXP 54
70343: PUSH
70344: LD_VAR 0 2
70348: ARRAY
70349: IN
70350: IFFALSE 70575
// begin if GetClass ( j ) <> 4 then
70352: LD_VAR 0 3
70356: PPUSH
70357: CALL_OW 257
70361: PUSH
70362: LD_INT 4
70364: NONEQUAL
70365: IFFALSE 70418
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70367: LD_ADDR_EXP 54
70371: PUSH
70372: LD_EXP 54
70376: PPUSH
70377: LD_VAR 0 2
70381: PPUSH
70382: LD_EXP 54
70386: PUSH
70387: LD_VAR 0 2
70391: ARRAY
70392: PUSH
70393: LD_VAR 0 3
70397: DIFF
70398: PPUSH
70399: CALL_OW 1
70403: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70404: LD_VAR 0 3
70408: PPUSH
70409: LD_INT 0
70411: PPUSH
70412: CALL_OW 109
// continue ;
70416: GO 70240
// end ; if IsInUnit ( j ) then
70418: LD_VAR 0 3
70422: PPUSH
70423: CALL_OW 310
70427: IFFALSE 70438
// ComExitBuilding ( j ) ;
70429: LD_VAR 0 3
70433: PPUSH
70434: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70438: LD_ADDR_VAR 0 6
70442: PUSH
70443: LD_VAR 0 7
70447: PPUSH
70448: LD_VAR 0 3
70452: PPUSH
70453: CALL_OW 74
70457: ST_TO_ADDR
// if not ape then
70458: LD_VAR 0 6
70462: NOT
70463: IFFALSE 70467
// break ;
70465: GO 70577
// x := GetX ( ape ) ;
70467: LD_ADDR_VAR 0 4
70471: PUSH
70472: LD_VAR 0 6
70476: PPUSH
70477: CALL_OW 250
70481: ST_TO_ADDR
// y := GetY ( ape ) ;
70482: LD_ADDR_VAR 0 5
70486: PUSH
70487: LD_VAR 0 6
70491: PPUSH
70492: CALL_OW 251
70496: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70497: LD_VAR 0 4
70501: PPUSH
70502: LD_VAR 0 5
70506: PPUSH
70507: CALL_OW 488
70511: NOT
70512: PUSH
70513: LD_VAR 0 11
70517: PPUSH
70518: LD_VAR 0 4
70522: PPUSH
70523: LD_VAR 0 5
70527: PPUSH
70528: LD_INT 20
70530: PPUSH
70531: CALL 16909 0 4
70535: PUSH
70536: LD_INT 4
70538: ARRAY
70539: OR
70540: IFFALSE 70544
// break ;
70542: GO 70577
// if not HasTask ( j ) then
70544: LD_VAR 0 3
70548: PPUSH
70549: CALL_OW 314
70553: NOT
70554: IFFALSE 70575
// ComTameXY ( j , x , y ) ;
70556: LD_VAR 0 3
70560: PPUSH
70561: LD_VAR 0 4
70565: PPUSH
70566: LD_VAR 0 5
70570: PPUSH
70571: CALL_OW 131
// end ; end ;
70575: GO 70240
70577: POP
70578: POP
// end ;
70579: GO 69796
70581: POP
70582: POP
// end ;
70583: LD_VAR 0 1
70587: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70588: LD_INT 0
70590: PPUSH
70591: PPUSH
70592: PPUSH
70593: PPUSH
70594: PPUSH
70595: PPUSH
70596: PPUSH
70597: PPUSH
// if not mc_bases then
70598: LD_EXP 23
70602: NOT
70603: IFFALSE 70607
// exit ;
70605: GO 71233
// for i = 1 to mc_bases do
70607: LD_ADDR_VAR 0 2
70611: PUSH
70612: DOUBLE
70613: LD_INT 1
70615: DEC
70616: ST_TO_ADDR
70617: LD_EXP 23
70621: PUSH
70622: FOR_TO
70623: IFFALSE 71231
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70625: LD_EXP 52
70629: PUSH
70630: LD_VAR 0 2
70634: ARRAY
70635: NOT
70636: PUSH
70637: LD_EXP 52
70641: PUSH
70642: LD_VAR 0 2
70646: ARRAY
70647: PPUSH
70648: LD_INT 25
70650: PUSH
70651: LD_INT 12
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PPUSH
70658: CALL_OW 72
70662: NOT
70663: OR
70664: IFFALSE 70668
// continue ;
70666: GO 70622
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70668: LD_ADDR_VAR 0 5
70672: PUSH
70673: LD_EXP 52
70677: PUSH
70678: LD_VAR 0 2
70682: ARRAY
70683: PUSH
70684: LD_INT 1
70686: ARRAY
70687: PPUSH
70688: CALL_OW 255
70692: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70693: LD_VAR 0 5
70697: PPUSH
70698: LD_INT 2
70700: PPUSH
70701: CALL_OW 325
70705: IFFALSE 70958
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70707: LD_ADDR_VAR 0 4
70711: PUSH
70712: LD_EXP 52
70716: PUSH
70717: LD_VAR 0 2
70721: ARRAY
70722: PPUSH
70723: LD_INT 25
70725: PUSH
70726: LD_INT 16
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PPUSH
70733: CALL_OW 72
70737: ST_TO_ADDR
// if tmp < 6 then
70738: LD_VAR 0 4
70742: PUSH
70743: LD_INT 6
70745: LESS
70746: IFFALSE 70958
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70748: LD_ADDR_VAR 0 6
70752: PUSH
70753: LD_EXP 23
70757: PUSH
70758: LD_VAR 0 2
70762: ARRAY
70763: PPUSH
70764: LD_INT 2
70766: PUSH
70767: LD_INT 30
70769: PUSH
70770: LD_INT 0
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 30
70779: PUSH
70780: LD_INT 1
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: LIST
70791: PPUSH
70792: CALL_OW 72
70796: ST_TO_ADDR
// if depot then
70797: LD_VAR 0 6
70801: IFFALSE 70958
// begin selected := 0 ;
70803: LD_ADDR_VAR 0 7
70807: PUSH
70808: LD_INT 0
70810: ST_TO_ADDR
// for j in depot do
70811: LD_ADDR_VAR 0 3
70815: PUSH
70816: LD_VAR 0 6
70820: PUSH
70821: FOR_IN
70822: IFFALSE 70853
// begin if UnitsInside ( j ) < 6 then
70824: LD_VAR 0 3
70828: PPUSH
70829: CALL_OW 313
70833: PUSH
70834: LD_INT 6
70836: LESS
70837: IFFALSE 70851
// begin selected := j ;
70839: LD_ADDR_VAR 0 7
70843: PUSH
70844: LD_VAR 0 3
70848: ST_TO_ADDR
// break ;
70849: GO 70853
// end ; end ;
70851: GO 70821
70853: POP
70854: POP
// if selected then
70855: LD_VAR 0 7
70859: IFFALSE 70958
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70861: LD_ADDR_VAR 0 3
70865: PUSH
70866: LD_EXP 52
70870: PUSH
70871: LD_VAR 0 2
70875: ARRAY
70876: PPUSH
70877: LD_INT 25
70879: PUSH
70880: LD_INT 12
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PPUSH
70887: CALL_OW 72
70891: PUSH
70892: FOR_IN
70893: IFFALSE 70956
// if not HasTask ( j ) then
70895: LD_VAR 0 3
70899: PPUSH
70900: CALL_OW 314
70904: NOT
70905: IFFALSE 70954
// begin if not IsInUnit ( j ) then
70907: LD_VAR 0 3
70911: PPUSH
70912: CALL_OW 310
70916: NOT
70917: IFFALSE 70933
// ComEnterUnit ( j , selected ) ;
70919: LD_VAR 0 3
70923: PPUSH
70924: LD_VAR 0 7
70928: PPUSH
70929: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70933: LD_VAR 0 3
70937: PPUSH
70938: LD_INT 16
70940: PPUSH
70941: CALL_OW 183
// AddComExitBuilding ( j ) ;
70945: LD_VAR 0 3
70949: PPUSH
70950: CALL_OW 182
// end ;
70954: GO 70892
70956: POP
70957: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70958: LD_VAR 0 5
70962: PPUSH
70963: LD_INT 11
70965: PPUSH
70966: CALL_OW 325
70970: IFFALSE 71229
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70972: LD_ADDR_VAR 0 4
70976: PUSH
70977: LD_EXP 52
70981: PUSH
70982: LD_VAR 0 2
70986: ARRAY
70987: PPUSH
70988: LD_INT 25
70990: PUSH
70991: LD_INT 16
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PPUSH
70998: CALL_OW 72
71002: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71003: LD_VAR 0 4
71007: PUSH
71008: LD_INT 6
71010: GREATEREQUAL
71011: PUSH
71012: LD_VAR 0 5
71016: PPUSH
71017: LD_INT 2
71019: PPUSH
71020: CALL_OW 325
71024: NOT
71025: OR
71026: IFFALSE 71229
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71028: LD_ADDR_VAR 0 8
71032: PUSH
71033: LD_EXP 23
71037: PUSH
71038: LD_VAR 0 2
71042: ARRAY
71043: PPUSH
71044: LD_INT 2
71046: PUSH
71047: LD_INT 30
71049: PUSH
71050: LD_INT 4
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 30
71059: PUSH
71060: LD_INT 5
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: LIST
71071: PPUSH
71072: CALL_OW 72
71076: ST_TO_ADDR
// if barracks then
71077: LD_VAR 0 8
71081: IFFALSE 71229
// begin selected := 0 ;
71083: LD_ADDR_VAR 0 7
71087: PUSH
71088: LD_INT 0
71090: ST_TO_ADDR
// for j in barracks do
71091: LD_ADDR_VAR 0 3
71095: PUSH
71096: LD_VAR 0 8
71100: PUSH
71101: FOR_IN
71102: IFFALSE 71133
// begin if UnitsInside ( j ) < 6 then
71104: LD_VAR 0 3
71108: PPUSH
71109: CALL_OW 313
71113: PUSH
71114: LD_INT 6
71116: LESS
71117: IFFALSE 71131
// begin selected := j ;
71119: LD_ADDR_VAR 0 7
71123: PUSH
71124: LD_VAR 0 3
71128: ST_TO_ADDR
// break ;
71129: GO 71133
// end ; end ;
71131: GO 71101
71133: POP
71134: POP
// if selected then
71135: LD_VAR 0 7
71139: IFFALSE 71229
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71141: LD_ADDR_VAR 0 3
71145: PUSH
71146: LD_EXP 52
71150: PUSH
71151: LD_VAR 0 2
71155: ARRAY
71156: PPUSH
71157: LD_INT 25
71159: PUSH
71160: LD_INT 12
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PPUSH
71167: CALL_OW 72
71171: PUSH
71172: FOR_IN
71173: IFFALSE 71227
// if not IsInUnit ( j ) and not HasTask ( j ) then
71175: LD_VAR 0 3
71179: PPUSH
71180: CALL_OW 310
71184: NOT
71185: PUSH
71186: LD_VAR 0 3
71190: PPUSH
71191: CALL_OW 314
71195: NOT
71196: AND
71197: IFFALSE 71225
// begin ComEnterUnit ( j , selected ) ;
71199: LD_VAR 0 3
71203: PPUSH
71204: LD_VAR 0 7
71208: PPUSH
71209: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71213: LD_VAR 0 3
71217: PPUSH
71218: LD_INT 15
71220: PPUSH
71221: CALL_OW 183
// end ;
71225: GO 71172
71227: POP
71228: POP
// end ; end ; end ; end ; end ;
71229: GO 70622
71231: POP
71232: POP
// end ;
71233: LD_VAR 0 1
71237: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71238: LD_INT 0
71240: PPUSH
71241: PPUSH
71242: PPUSH
71243: PPUSH
// if not mc_bases then
71244: LD_EXP 23
71248: NOT
71249: IFFALSE 71253
// exit ;
71251: GO 71431
// for i = 1 to mc_bases do
71253: LD_ADDR_VAR 0 2
71257: PUSH
71258: DOUBLE
71259: LD_INT 1
71261: DEC
71262: ST_TO_ADDR
71263: LD_EXP 23
71267: PUSH
71268: FOR_TO
71269: IFFALSE 71429
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71271: LD_ADDR_VAR 0 4
71275: PUSH
71276: LD_EXP 23
71280: PUSH
71281: LD_VAR 0 2
71285: ARRAY
71286: PPUSH
71287: LD_INT 25
71289: PUSH
71290: LD_INT 9
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PPUSH
71297: CALL_OW 72
71301: ST_TO_ADDR
// if not tmp then
71302: LD_VAR 0 4
71306: NOT
71307: IFFALSE 71311
// continue ;
71309: GO 71268
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71311: LD_EXP 49
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: PPUSH
71322: LD_INT 29
71324: PPUSH
71325: CALL_OW 325
71329: NOT
71330: PUSH
71331: LD_EXP 49
71335: PUSH
71336: LD_VAR 0 2
71340: ARRAY
71341: PPUSH
71342: LD_INT 28
71344: PPUSH
71345: CALL_OW 325
71349: NOT
71350: AND
71351: IFFALSE 71355
// continue ;
71353: GO 71268
// for j in tmp do
71355: LD_ADDR_VAR 0 3
71359: PUSH
71360: LD_VAR 0 4
71364: PUSH
71365: FOR_IN
71366: IFFALSE 71425
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71368: LD_VAR 0 3
71372: PUSH
71373: LD_EXP 26
71377: PUSH
71378: LD_VAR 0 2
71382: ARRAY
71383: PUSH
71384: LD_INT 1
71386: ARRAY
71387: IN
71388: NOT
71389: PUSH
71390: LD_VAR 0 3
71394: PUSH
71395: LD_EXP 26
71399: PUSH
71400: LD_VAR 0 2
71404: ARRAY
71405: PUSH
71406: LD_INT 2
71408: ARRAY
71409: IN
71410: NOT
71411: AND
71412: IFFALSE 71423
// ComSpaceTimeShoot ( j ) ;
71414: LD_VAR 0 3
71418: PPUSH
71419: CALL 11974 0 1
71423: GO 71365
71425: POP
71426: POP
// end ;
71427: GO 71268
71429: POP
71430: POP
// end ;
71431: LD_VAR 0 1
71435: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71436: LD_INT 0
71438: PPUSH
71439: PPUSH
71440: PPUSH
71441: PPUSH
71442: PPUSH
71443: PPUSH
71444: PPUSH
71445: PPUSH
71446: PPUSH
// if not mc_bases then
71447: LD_EXP 23
71451: NOT
71452: IFFALSE 71456
// exit ;
71454: GO 72078
// for i = 1 to mc_bases do
71456: LD_ADDR_VAR 0 2
71460: PUSH
71461: DOUBLE
71462: LD_INT 1
71464: DEC
71465: ST_TO_ADDR
71466: LD_EXP 23
71470: PUSH
71471: FOR_TO
71472: IFFALSE 72076
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71474: LD_EXP 58
71478: PUSH
71479: LD_VAR 0 2
71483: ARRAY
71484: NOT
71485: PUSH
71486: LD_INT 38
71488: PPUSH
71489: LD_EXP 49
71493: PUSH
71494: LD_VAR 0 2
71498: ARRAY
71499: PPUSH
71500: CALL_OW 321
71504: PUSH
71505: LD_INT 2
71507: NONEQUAL
71508: OR
71509: IFFALSE 71513
// continue ;
71511: GO 71471
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71513: LD_ADDR_VAR 0 8
71517: PUSH
71518: LD_EXP 23
71522: PUSH
71523: LD_VAR 0 2
71527: ARRAY
71528: PPUSH
71529: LD_INT 30
71531: PUSH
71532: LD_INT 34
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PPUSH
71539: CALL_OW 72
71543: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71544: LD_ADDR_VAR 0 9
71548: PUSH
71549: LD_EXP 23
71553: PUSH
71554: LD_VAR 0 2
71558: ARRAY
71559: PPUSH
71560: LD_INT 25
71562: PUSH
71563: LD_INT 4
71565: PUSH
71566: EMPTY
71567: LIST
71568: LIST
71569: PPUSH
71570: CALL_OW 72
71574: PPUSH
71575: LD_INT 0
71577: PPUSH
71578: CALL 45282 0 2
71582: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71583: LD_VAR 0 9
71587: NOT
71588: PUSH
71589: LD_VAR 0 8
71593: NOT
71594: OR
71595: PUSH
71596: LD_EXP 23
71600: PUSH
71601: LD_VAR 0 2
71605: ARRAY
71606: PPUSH
71607: LD_INT 124
71609: PPUSH
71610: CALL 45282 0 2
71614: OR
71615: IFFALSE 71619
// continue ;
71617: GO 71471
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71619: LD_EXP 59
71623: PUSH
71624: LD_VAR 0 2
71628: ARRAY
71629: PUSH
71630: LD_EXP 58
71634: PUSH
71635: LD_VAR 0 2
71639: ARRAY
71640: LESS
71641: PUSH
71642: LD_EXP 59
71646: PUSH
71647: LD_VAR 0 2
71651: ARRAY
71652: PUSH
71653: LD_VAR 0 8
71657: LESS
71658: AND
71659: IFFALSE 72074
// begin tmp := sci [ 1 ] ;
71661: LD_ADDR_VAR 0 7
71665: PUSH
71666: LD_VAR 0 9
71670: PUSH
71671: LD_INT 1
71673: ARRAY
71674: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71675: LD_VAR 0 7
71679: PPUSH
71680: LD_INT 124
71682: PPUSH
71683: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71687: LD_ADDR_VAR 0 3
71691: PUSH
71692: DOUBLE
71693: LD_EXP 58
71697: PUSH
71698: LD_VAR 0 2
71702: ARRAY
71703: INC
71704: ST_TO_ADDR
71705: LD_EXP 58
71709: PUSH
71710: LD_VAR 0 2
71714: ARRAY
71715: PUSH
71716: FOR_DOWNTO
71717: IFFALSE 72060
// begin if IsInUnit ( tmp ) then
71719: LD_VAR 0 7
71723: PPUSH
71724: CALL_OW 310
71728: IFFALSE 71739
// ComExitBuilding ( tmp ) ;
71730: LD_VAR 0 7
71734: PPUSH
71735: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71739: LD_INT 35
71741: PPUSH
71742: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71746: LD_VAR 0 7
71750: PPUSH
71751: CALL_OW 310
71755: NOT
71756: PUSH
71757: LD_VAR 0 7
71761: PPUSH
71762: CALL_OW 314
71766: NOT
71767: AND
71768: IFFALSE 71739
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71770: LD_ADDR_VAR 0 6
71774: PUSH
71775: LD_VAR 0 7
71779: PPUSH
71780: CALL_OW 250
71784: PUSH
71785: LD_VAR 0 7
71789: PPUSH
71790: CALL_OW 251
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71799: LD_INT 35
71801: PPUSH
71802: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71806: LD_ADDR_VAR 0 4
71810: PUSH
71811: LD_EXP 58
71815: PUSH
71816: LD_VAR 0 2
71820: ARRAY
71821: PUSH
71822: LD_VAR 0 3
71826: ARRAY
71827: PUSH
71828: LD_INT 1
71830: ARRAY
71831: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71832: LD_ADDR_VAR 0 5
71836: PUSH
71837: LD_EXP 58
71841: PUSH
71842: LD_VAR 0 2
71846: ARRAY
71847: PUSH
71848: LD_VAR 0 3
71852: ARRAY
71853: PUSH
71854: LD_INT 2
71856: ARRAY
71857: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71858: LD_VAR 0 7
71862: PPUSH
71863: LD_INT 10
71865: PPUSH
71866: CALL 18612 0 2
71870: PUSH
71871: LD_INT 4
71873: ARRAY
71874: IFFALSE 71912
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71876: LD_VAR 0 7
71880: PPUSH
71881: LD_VAR 0 6
71885: PUSH
71886: LD_INT 1
71888: ARRAY
71889: PPUSH
71890: LD_VAR 0 6
71894: PUSH
71895: LD_INT 2
71897: ARRAY
71898: PPUSH
71899: CALL_OW 111
// wait ( 0 0$10 ) ;
71903: LD_INT 350
71905: PPUSH
71906: CALL_OW 67
// end else
71910: GO 71938
// begin ComMoveXY ( tmp , x , y ) ;
71912: LD_VAR 0 7
71916: PPUSH
71917: LD_VAR 0 4
71921: PPUSH
71922: LD_VAR 0 5
71926: PPUSH
71927: CALL_OW 111
// wait ( 0 0$3 ) ;
71931: LD_INT 105
71933: PPUSH
71934: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71938: LD_VAR 0 7
71942: PPUSH
71943: LD_VAR 0 4
71947: PPUSH
71948: LD_VAR 0 5
71952: PPUSH
71953: CALL_OW 307
71957: IFFALSE 71799
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71959: LD_VAR 0 7
71963: PPUSH
71964: LD_VAR 0 4
71968: PPUSH
71969: LD_VAR 0 5
71973: PPUSH
71974: LD_VAR 0 8
71978: PUSH
71979: LD_VAR 0 3
71983: ARRAY
71984: PPUSH
71985: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71989: LD_INT 35
71991: PPUSH
71992: CALL_OW 67
// until not HasTask ( tmp ) ;
71996: LD_VAR 0 7
72000: PPUSH
72001: CALL_OW 314
72005: NOT
72006: IFFALSE 71989
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72008: LD_ADDR_EXP 59
72012: PUSH
72013: LD_EXP 59
72017: PPUSH
72018: LD_VAR 0 2
72022: PUSH
72023: LD_EXP 59
72027: PUSH
72028: LD_VAR 0 2
72032: ARRAY
72033: PUSH
72034: LD_INT 1
72036: PLUS
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PPUSH
72042: LD_VAR 0 8
72046: PUSH
72047: LD_VAR 0 3
72051: ARRAY
72052: PPUSH
72053: CALL 16013 0 3
72057: ST_TO_ADDR
// end ;
72058: GO 71716
72060: POP
72061: POP
// MC_Reset ( i , 124 ) ;
72062: LD_VAR 0 2
72066: PPUSH
72067: LD_INT 124
72069: PPUSH
72070: CALL 55216 0 2
// end ; end ;
72074: GO 71471
72076: POP
72077: POP
// end ;
72078: LD_VAR 0 1
72082: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72083: LD_INT 0
72085: PPUSH
72086: PPUSH
72087: PPUSH
// if not mc_bases then
72088: LD_EXP 23
72092: NOT
72093: IFFALSE 72097
// exit ;
72095: GO 72703
// for i = 1 to mc_bases do
72097: LD_ADDR_VAR 0 2
72101: PUSH
72102: DOUBLE
72103: LD_INT 1
72105: DEC
72106: ST_TO_ADDR
72107: LD_EXP 23
72111: PUSH
72112: FOR_TO
72113: IFFALSE 72701
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72115: LD_ADDR_VAR 0 3
72119: PUSH
72120: LD_EXP 23
72124: PUSH
72125: LD_VAR 0 2
72129: ARRAY
72130: PPUSH
72131: LD_INT 25
72133: PUSH
72134: LD_INT 4
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PPUSH
72141: CALL_OW 72
72145: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72146: LD_VAR 0 3
72150: NOT
72151: PUSH
72152: LD_EXP 60
72156: PUSH
72157: LD_VAR 0 2
72161: ARRAY
72162: NOT
72163: OR
72164: PUSH
72165: LD_EXP 23
72169: PUSH
72170: LD_VAR 0 2
72174: ARRAY
72175: PPUSH
72176: LD_INT 2
72178: PUSH
72179: LD_INT 30
72181: PUSH
72182: LD_INT 0
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 30
72191: PUSH
72192: LD_INT 1
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: LIST
72203: PPUSH
72204: CALL_OW 72
72208: NOT
72209: OR
72210: IFFALSE 72260
// begin if mc_deposits_finder [ i ] then
72212: LD_EXP 61
72216: PUSH
72217: LD_VAR 0 2
72221: ARRAY
72222: IFFALSE 72258
// begin MC_Reset ( i , 125 ) ;
72224: LD_VAR 0 2
72228: PPUSH
72229: LD_INT 125
72231: PPUSH
72232: CALL 55216 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72236: LD_ADDR_EXP 61
72240: PUSH
72241: LD_EXP 61
72245: PPUSH
72246: LD_VAR 0 2
72250: PPUSH
72251: EMPTY
72252: PPUSH
72253: CALL_OW 1
72257: ST_TO_ADDR
// end ; continue ;
72258: GO 72112
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72260: LD_EXP 60
72264: PUSH
72265: LD_VAR 0 2
72269: ARRAY
72270: PUSH
72271: LD_INT 1
72273: ARRAY
72274: PUSH
72275: LD_INT 3
72277: ARRAY
72278: PUSH
72279: LD_INT 1
72281: EQUAL
72282: PUSH
72283: LD_INT 20
72285: PPUSH
72286: LD_EXP 49
72290: PUSH
72291: LD_VAR 0 2
72295: ARRAY
72296: PPUSH
72297: CALL_OW 321
72301: PUSH
72302: LD_INT 2
72304: NONEQUAL
72305: AND
72306: IFFALSE 72356
// begin if mc_deposits_finder [ i ] then
72308: LD_EXP 61
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: IFFALSE 72354
// begin MC_Reset ( i , 125 ) ;
72320: LD_VAR 0 2
72324: PPUSH
72325: LD_INT 125
72327: PPUSH
72328: CALL 55216 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72332: LD_ADDR_EXP 61
72336: PUSH
72337: LD_EXP 61
72341: PPUSH
72342: LD_VAR 0 2
72346: PPUSH
72347: EMPTY
72348: PPUSH
72349: CALL_OW 1
72353: ST_TO_ADDR
// end ; continue ;
72354: GO 72112
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72356: LD_EXP 60
72360: PUSH
72361: LD_VAR 0 2
72365: ARRAY
72366: PUSH
72367: LD_INT 1
72369: ARRAY
72370: PUSH
72371: LD_INT 1
72373: ARRAY
72374: PPUSH
72375: LD_EXP 60
72379: PUSH
72380: LD_VAR 0 2
72384: ARRAY
72385: PUSH
72386: LD_INT 1
72388: ARRAY
72389: PUSH
72390: LD_INT 2
72392: ARRAY
72393: PPUSH
72394: LD_EXP 49
72398: PUSH
72399: LD_VAR 0 2
72403: ARRAY
72404: PPUSH
72405: CALL_OW 440
72409: IFFALSE 72452
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72411: LD_ADDR_EXP 60
72415: PUSH
72416: LD_EXP 60
72420: PPUSH
72421: LD_VAR 0 2
72425: PPUSH
72426: LD_EXP 60
72430: PUSH
72431: LD_VAR 0 2
72435: ARRAY
72436: PPUSH
72437: LD_INT 1
72439: PPUSH
72440: CALL_OW 3
72444: PPUSH
72445: CALL_OW 1
72449: ST_TO_ADDR
72450: GO 72699
// begin if not mc_deposits_finder [ i ] then
72452: LD_EXP 61
72456: PUSH
72457: LD_VAR 0 2
72461: ARRAY
72462: NOT
72463: IFFALSE 72515
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72465: LD_ADDR_EXP 61
72469: PUSH
72470: LD_EXP 61
72474: PPUSH
72475: LD_VAR 0 2
72479: PPUSH
72480: LD_VAR 0 3
72484: PUSH
72485: LD_INT 1
72487: ARRAY
72488: PUSH
72489: EMPTY
72490: LIST
72491: PPUSH
72492: CALL_OW 1
72496: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72497: LD_VAR 0 3
72501: PUSH
72502: LD_INT 1
72504: ARRAY
72505: PPUSH
72506: LD_INT 125
72508: PPUSH
72509: CALL_OW 109
// end else
72513: GO 72699
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72515: LD_EXP 61
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: PUSH
72526: LD_INT 1
72528: ARRAY
72529: PPUSH
72530: CALL_OW 310
72534: IFFALSE 72557
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72536: LD_EXP 61
72540: PUSH
72541: LD_VAR 0 2
72545: ARRAY
72546: PUSH
72547: LD_INT 1
72549: ARRAY
72550: PPUSH
72551: CALL_OW 122
72555: GO 72699
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72557: LD_EXP 61
72561: PUSH
72562: LD_VAR 0 2
72566: ARRAY
72567: PUSH
72568: LD_INT 1
72570: ARRAY
72571: PPUSH
72572: CALL_OW 314
72576: NOT
72577: PUSH
72578: LD_EXP 61
72582: PUSH
72583: LD_VAR 0 2
72587: ARRAY
72588: PUSH
72589: LD_INT 1
72591: ARRAY
72592: PPUSH
72593: LD_EXP 60
72597: PUSH
72598: LD_VAR 0 2
72602: ARRAY
72603: PUSH
72604: LD_INT 1
72606: ARRAY
72607: PUSH
72608: LD_INT 1
72610: ARRAY
72611: PPUSH
72612: LD_EXP 60
72616: PUSH
72617: LD_VAR 0 2
72621: ARRAY
72622: PUSH
72623: LD_INT 1
72625: ARRAY
72626: PUSH
72627: LD_INT 2
72629: ARRAY
72630: PPUSH
72631: CALL_OW 297
72635: PUSH
72636: LD_INT 6
72638: GREATER
72639: AND
72640: IFFALSE 72699
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72642: LD_EXP 61
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: PUSH
72653: LD_INT 1
72655: ARRAY
72656: PPUSH
72657: LD_EXP 60
72661: PUSH
72662: LD_VAR 0 2
72666: ARRAY
72667: PUSH
72668: LD_INT 1
72670: ARRAY
72671: PUSH
72672: LD_INT 1
72674: ARRAY
72675: PPUSH
72676: LD_EXP 60
72680: PUSH
72681: LD_VAR 0 2
72685: ARRAY
72686: PUSH
72687: LD_INT 1
72689: ARRAY
72690: PUSH
72691: LD_INT 2
72693: ARRAY
72694: PPUSH
72695: CALL_OW 111
// end ; end ; end ;
72699: GO 72112
72701: POP
72702: POP
// end ;
72703: LD_VAR 0 1
72707: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72708: LD_INT 0
72710: PPUSH
72711: PPUSH
72712: PPUSH
72713: PPUSH
72714: PPUSH
72715: PPUSH
72716: PPUSH
72717: PPUSH
72718: PPUSH
72719: PPUSH
72720: PPUSH
// if not mc_bases then
72721: LD_EXP 23
72725: NOT
72726: IFFALSE 72730
// exit ;
72728: GO 73670
// for i = 1 to mc_bases do
72730: LD_ADDR_VAR 0 2
72734: PUSH
72735: DOUBLE
72736: LD_INT 1
72738: DEC
72739: ST_TO_ADDR
72740: LD_EXP 23
72744: PUSH
72745: FOR_TO
72746: IFFALSE 73668
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72748: LD_EXP 23
72752: PUSH
72753: LD_VAR 0 2
72757: ARRAY
72758: NOT
72759: PUSH
72760: LD_EXP 46
72764: PUSH
72765: LD_VAR 0 2
72769: ARRAY
72770: OR
72771: IFFALSE 72775
// continue ;
72773: GO 72745
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72775: LD_ADDR_VAR 0 7
72779: PUSH
72780: LD_EXP 23
72784: PUSH
72785: LD_VAR 0 2
72789: ARRAY
72790: PUSH
72791: LD_INT 1
72793: ARRAY
72794: PPUSH
72795: CALL_OW 248
72799: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72800: LD_VAR 0 7
72804: PUSH
72805: LD_INT 3
72807: EQUAL
72808: PUSH
72809: LD_EXP 42
72813: PUSH
72814: LD_VAR 0 2
72818: ARRAY
72819: PUSH
72820: LD_EXP 45
72824: PUSH
72825: LD_VAR 0 2
72829: ARRAY
72830: UNION
72831: PPUSH
72832: LD_INT 33
72834: PUSH
72835: LD_INT 2
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PPUSH
72842: CALL_OW 72
72846: NOT
72847: OR
72848: IFFALSE 72852
// continue ;
72850: GO 72745
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72852: LD_ADDR_VAR 0 9
72856: PUSH
72857: LD_EXP 23
72861: PUSH
72862: LD_VAR 0 2
72866: ARRAY
72867: PPUSH
72868: LD_INT 30
72870: PUSH
72871: LD_INT 36
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PPUSH
72878: CALL_OW 72
72882: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72883: LD_ADDR_VAR 0 10
72887: PUSH
72888: LD_EXP 42
72892: PUSH
72893: LD_VAR 0 2
72897: ARRAY
72898: PPUSH
72899: LD_INT 34
72901: PUSH
72902: LD_INT 31
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PPUSH
72909: CALL_OW 72
72913: ST_TO_ADDR
// if not cts and not mcts then
72914: LD_VAR 0 9
72918: NOT
72919: PUSH
72920: LD_VAR 0 10
72924: NOT
72925: AND
72926: IFFALSE 72930
// continue ;
72928: GO 72745
// x := cts ;
72930: LD_ADDR_VAR 0 11
72934: PUSH
72935: LD_VAR 0 9
72939: ST_TO_ADDR
// if not x then
72940: LD_VAR 0 11
72944: NOT
72945: IFFALSE 72957
// x := mcts ;
72947: LD_ADDR_VAR 0 11
72951: PUSH
72952: LD_VAR 0 10
72956: ST_TO_ADDR
// if not x then
72957: LD_VAR 0 11
72961: NOT
72962: IFFALSE 72966
// continue ;
72964: GO 72745
// if mc_remote_driver [ i ] then
72966: LD_EXP 63
72970: PUSH
72971: LD_VAR 0 2
72975: ARRAY
72976: IFFALSE 73363
// for j in mc_remote_driver [ i ] do
72978: LD_ADDR_VAR 0 3
72982: PUSH
72983: LD_EXP 63
72987: PUSH
72988: LD_VAR 0 2
72992: ARRAY
72993: PUSH
72994: FOR_IN
72995: IFFALSE 73361
// begin if GetClass ( j ) <> 3 then
72997: LD_VAR 0 3
73001: PPUSH
73002: CALL_OW 257
73006: PUSH
73007: LD_INT 3
73009: NONEQUAL
73010: IFFALSE 73063
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73012: LD_ADDR_EXP 63
73016: PUSH
73017: LD_EXP 63
73021: PPUSH
73022: LD_VAR 0 2
73026: PPUSH
73027: LD_EXP 63
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: PUSH
73038: LD_VAR 0 3
73042: DIFF
73043: PPUSH
73044: CALL_OW 1
73048: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73049: LD_VAR 0 3
73053: PPUSH
73054: LD_INT 0
73056: PPUSH
73057: CALL_OW 109
// continue ;
73061: GO 72994
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73063: LD_EXP 42
73067: PUSH
73068: LD_VAR 0 2
73072: ARRAY
73073: PPUSH
73074: LD_INT 34
73076: PUSH
73077: LD_INT 31
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 58
73086: PUSH
73087: EMPTY
73088: LIST
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PPUSH
73094: CALL_OW 72
73098: PUSH
73099: LD_VAR 0 3
73103: PPUSH
73104: CALL 45317 0 1
73108: NOT
73109: AND
73110: IFFALSE 73181
// begin if IsInUnit ( j ) then
73112: LD_VAR 0 3
73116: PPUSH
73117: CALL_OW 310
73121: IFFALSE 73132
// ComExitBuilding ( j ) ;
73123: LD_VAR 0 3
73127: PPUSH
73128: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73132: LD_VAR 0 3
73136: PPUSH
73137: LD_EXP 42
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: PPUSH
73148: LD_INT 34
73150: PUSH
73151: LD_INT 31
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 58
73160: PUSH
73161: EMPTY
73162: LIST
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PPUSH
73168: CALL_OW 72
73172: PUSH
73173: LD_INT 1
73175: ARRAY
73176: PPUSH
73177: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73181: LD_VAR 0 3
73185: PPUSH
73186: CALL_OW 310
73190: NOT
73191: PUSH
73192: LD_VAR 0 3
73196: PPUSH
73197: CALL_OW 310
73201: PPUSH
73202: CALL_OW 266
73206: PUSH
73207: LD_INT 36
73209: NONEQUAL
73210: PUSH
73211: LD_VAR 0 3
73215: PPUSH
73216: CALL 45317 0 1
73220: NOT
73221: AND
73222: OR
73223: IFFALSE 73359
// begin if IsInUnit ( j ) then
73225: LD_VAR 0 3
73229: PPUSH
73230: CALL_OW 310
73234: IFFALSE 73245
// ComExitBuilding ( j ) ;
73236: LD_VAR 0 3
73240: PPUSH
73241: CALL_OW 122
// ct := 0 ;
73245: LD_ADDR_VAR 0 8
73249: PUSH
73250: LD_INT 0
73252: ST_TO_ADDR
// for k in x do
73253: LD_ADDR_VAR 0 4
73257: PUSH
73258: LD_VAR 0 11
73262: PUSH
73263: FOR_IN
73264: IFFALSE 73337
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73266: LD_VAR 0 4
73270: PPUSH
73271: CALL_OW 264
73275: PUSH
73276: LD_INT 31
73278: EQUAL
73279: PUSH
73280: LD_VAR 0 4
73284: PPUSH
73285: CALL_OW 311
73289: NOT
73290: AND
73291: PUSH
73292: LD_VAR 0 4
73296: PPUSH
73297: CALL_OW 266
73301: PUSH
73302: LD_INT 36
73304: EQUAL
73305: PUSH
73306: LD_VAR 0 4
73310: PPUSH
73311: CALL_OW 313
73315: PUSH
73316: LD_INT 3
73318: LESS
73319: AND
73320: OR
73321: IFFALSE 73335
// begin ct := k ;
73323: LD_ADDR_VAR 0 8
73327: PUSH
73328: LD_VAR 0 4
73332: ST_TO_ADDR
// break ;
73333: GO 73337
// end ;
73335: GO 73263
73337: POP
73338: POP
// if ct then
73339: LD_VAR 0 8
73343: IFFALSE 73359
// ComEnterUnit ( j , ct ) ;
73345: LD_VAR 0 3
73349: PPUSH
73350: LD_VAR 0 8
73354: PPUSH
73355: CALL_OW 120
// end ; end ;
73359: GO 72994
73361: POP
73362: POP
// places := 0 ;
73363: LD_ADDR_VAR 0 5
73367: PUSH
73368: LD_INT 0
73370: ST_TO_ADDR
// for j = 1 to x do
73371: LD_ADDR_VAR 0 3
73375: PUSH
73376: DOUBLE
73377: LD_INT 1
73379: DEC
73380: ST_TO_ADDR
73381: LD_VAR 0 11
73385: PUSH
73386: FOR_TO
73387: IFFALSE 73463
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73389: LD_VAR 0 11
73393: PUSH
73394: LD_VAR 0 3
73398: ARRAY
73399: PPUSH
73400: CALL_OW 264
73404: PUSH
73405: LD_INT 31
73407: EQUAL
73408: IFFALSE 73426
// places := places + 1 else
73410: LD_ADDR_VAR 0 5
73414: PUSH
73415: LD_VAR 0 5
73419: PUSH
73420: LD_INT 1
73422: PLUS
73423: ST_TO_ADDR
73424: GO 73461
// if GetBType ( x [ j ] ) = b_control_tower then
73426: LD_VAR 0 11
73430: PUSH
73431: LD_VAR 0 3
73435: ARRAY
73436: PPUSH
73437: CALL_OW 266
73441: PUSH
73442: LD_INT 36
73444: EQUAL
73445: IFFALSE 73461
// places := places + 3 ;
73447: LD_ADDR_VAR 0 5
73451: PUSH
73452: LD_VAR 0 5
73456: PUSH
73457: LD_INT 3
73459: PLUS
73460: ST_TO_ADDR
73461: GO 73386
73463: POP
73464: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73465: LD_VAR 0 5
73469: PUSH
73470: LD_INT 0
73472: EQUAL
73473: PUSH
73474: LD_VAR 0 5
73478: PUSH
73479: LD_EXP 63
73483: PUSH
73484: LD_VAR 0 2
73488: ARRAY
73489: LESSEQUAL
73490: OR
73491: IFFALSE 73495
// continue ;
73493: GO 72745
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73495: LD_ADDR_VAR 0 6
73499: PUSH
73500: LD_EXP 23
73504: PUSH
73505: LD_VAR 0 2
73509: ARRAY
73510: PPUSH
73511: LD_INT 25
73513: PUSH
73514: LD_INT 3
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PPUSH
73521: CALL_OW 72
73525: PUSH
73526: LD_EXP 63
73530: PUSH
73531: LD_VAR 0 2
73535: ARRAY
73536: DIFF
73537: PPUSH
73538: LD_INT 3
73540: PPUSH
73541: CALL 46217 0 2
73545: ST_TO_ADDR
// for j in tmp do
73546: LD_ADDR_VAR 0 3
73550: PUSH
73551: LD_VAR 0 6
73555: PUSH
73556: FOR_IN
73557: IFFALSE 73592
// if GetTag ( j ) > 0 then
73559: LD_VAR 0 3
73563: PPUSH
73564: CALL_OW 110
73568: PUSH
73569: LD_INT 0
73571: GREATER
73572: IFFALSE 73590
// tmp := tmp diff j ;
73574: LD_ADDR_VAR 0 6
73578: PUSH
73579: LD_VAR 0 6
73583: PUSH
73584: LD_VAR 0 3
73588: DIFF
73589: ST_TO_ADDR
73590: GO 73556
73592: POP
73593: POP
// if not tmp then
73594: LD_VAR 0 6
73598: NOT
73599: IFFALSE 73603
// continue ;
73601: GO 72745
// if places then
73603: LD_VAR 0 5
73607: IFFALSE 73666
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73609: LD_ADDR_EXP 63
73613: PUSH
73614: LD_EXP 63
73618: PPUSH
73619: LD_VAR 0 2
73623: PPUSH
73624: LD_EXP 63
73628: PUSH
73629: LD_VAR 0 2
73633: ARRAY
73634: PUSH
73635: LD_VAR 0 6
73639: PUSH
73640: LD_INT 1
73642: ARRAY
73643: UNION
73644: PPUSH
73645: CALL_OW 1
73649: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73650: LD_VAR 0 6
73654: PUSH
73655: LD_INT 1
73657: ARRAY
73658: PPUSH
73659: LD_INT 126
73661: PPUSH
73662: CALL_OW 109
// end ; end ;
73666: GO 72745
73668: POP
73669: POP
// end ;
73670: LD_VAR 0 1
73674: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73675: LD_INT 0
73677: PPUSH
73678: PPUSH
73679: PPUSH
73680: PPUSH
73681: PPUSH
73682: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73683: LD_VAR 0 1
73687: NOT
73688: PUSH
73689: LD_VAR 0 2
73693: NOT
73694: OR
73695: PUSH
73696: LD_VAR 0 3
73700: NOT
73701: OR
73702: PUSH
73703: LD_VAR 0 4
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: LD_INT 2
73713: PUSH
73714: LD_INT 3
73716: PUSH
73717: LD_INT 4
73719: PUSH
73720: LD_INT 5
73722: PUSH
73723: LD_INT 8
73725: PUSH
73726: LD_INT 9
73728: PUSH
73729: LD_INT 15
73731: PUSH
73732: LD_INT 16
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: IN
73746: NOT
73747: OR
73748: IFFALSE 73752
// exit ;
73750: GO 74652
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73752: LD_ADDR_VAR 0 2
73756: PUSH
73757: LD_VAR 0 2
73761: PPUSH
73762: LD_INT 21
73764: PUSH
73765: LD_INT 3
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 24
73774: PUSH
73775: LD_INT 250
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PPUSH
73786: CALL_OW 72
73790: ST_TO_ADDR
// case class of 1 , 15 :
73791: LD_VAR 0 4
73795: PUSH
73796: LD_INT 1
73798: DOUBLE
73799: EQUAL
73800: IFTRUE 73810
73802: LD_INT 15
73804: DOUBLE
73805: EQUAL
73806: IFTRUE 73810
73808: GO 73895
73810: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73811: LD_ADDR_VAR 0 8
73815: PUSH
73816: LD_VAR 0 2
73820: PPUSH
73821: LD_INT 2
73823: PUSH
73824: LD_INT 30
73826: PUSH
73827: LD_INT 32
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 30
73836: PUSH
73837: LD_INT 31
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: LIST
73848: PPUSH
73849: CALL_OW 72
73853: PUSH
73854: LD_VAR 0 2
73858: PPUSH
73859: LD_INT 2
73861: PUSH
73862: LD_INT 30
73864: PUSH
73865: LD_INT 4
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 30
73874: PUSH
73875: LD_INT 5
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: LIST
73886: PPUSH
73887: CALL_OW 72
73891: ADD
73892: ST_TO_ADDR
73893: GO 74141
73895: LD_INT 2
73897: DOUBLE
73898: EQUAL
73899: IFTRUE 73909
73901: LD_INT 16
73903: DOUBLE
73904: EQUAL
73905: IFTRUE 73909
73907: GO 73955
73909: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73910: LD_ADDR_VAR 0 8
73914: PUSH
73915: LD_VAR 0 2
73919: PPUSH
73920: LD_INT 2
73922: PUSH
73923: LD_INT 30
73925: PUSH
73926: LD_INT 0
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 30
73935: PUSH
73936: LD_INT 1
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: LIST
73947: PPUSH
73948: CALL_OW 72
73952: ST_TO_ADDR
73953: GO 74141
73955: LD_INT 3
73957: DOUBLE
73958: EQUAL
73959: IFTRUE 73963
73961: GO 74009
73963: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73964: LD_ADDR_VAR 0 8
73968: PUSH
73969: LD_VAR 0 2
73973: PPUSH
73974: LD_INT 2
73976: PUSH
73977: LD_INT 30
73979: PUSH
73980: LD_INT 2
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 30
73989: PUSH
73990: LD_INT 3
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: LIST
74001: PPUSH
74002: CALL_OW 72
74006: ST_TO_ADDR
74007: GO 74141
74009: LD_INT 4
74011: DOUBLE
74012: EQUAL
74013: IFTRUE 74017
74015: GO 74074
74017: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74018: LD_ADDR_VAR 0 8
74022: PUSH
74023: LD_VAR 0 2
74027: PPUSH
74028: LD_INT 2
74030: PUSH
74031: LD_INT 30
74033: PUSH
74034: LD_INT 6
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 30
74043: PUSH
74044: LD_INT 7
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 30
74053: PUSH
74054: LD_INT 8
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: PPUSH
74067: CALL_OW 72
74071: ST_TO_ADDR
74072: GO 74141
74074: LD_INT 5
74076: DOUBLE
74077: EQUAL
74078: IFTRUE 74094
74080: LD_INT 8
74082: DOUBLE
74083: EQUAL
74084: IFTRUE 74094
74086: LD_INT 9
74088: DOUBLE
74089: EQUAL
74090: IFTRUE 74094
74092: GO 74140
74094: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74095: LD_ADDR_VAR 0 8
74099: PUSH
74100: LD_VAR 0 2
74104: PPUSH
74105: LD_INT 2
74107: PUSH
74108: LD_INT 30
74110: PUSH
74111: LD_INT 4
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 30
74120: PUSH
74121: LD_INT 5
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: LIST
74132: PPUSH
74133: CALL_OW 72
74137: ST_TO_ADDR
74138: GO 74141
74140: POP
// if not tmp then
74141: LD_VAR 0 8
74145: NOT
74146: IFFALSE 74150
// exit ;
74148: GO 74652
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74150: LD_VAR 0 4
74154: PUSH
74155: LD_INT 1
74157: PUSH
74158: LD_INT 15
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: IN
74165: PUSH
74166: LD_EXP 32
74170: PUSH
74171: LD_VAR 0 1
74175: ARRAY
74176: AND
74177: IFFALSE 74333
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74179: LD_ADDR_VAR 0 9
74183: PUSH
74184: LD_EXP 32
74188: PUSH
74189: LD_VAR 0 1
74193: ARRAY
74194: PUSH
74195: LD_INT 1
74197: ARRAY
74198: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74199: LD_VAR 0 9
74203: PUSH
74204: LD_EXP 33
74208: PUSH
74209: LD_VAR 0 1
74213: ARRAY
74214: IN
74215: NOT
74216: IFFALSE 74331
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74218: LD_ADDR_EXP 33
74222: PUSH
74223: LD_EXP 33
74227: PPUSH
74228: LD_VAR 0 1
74232: PUSH
74233: LD_EXP 33
74237: PUSH
74238: LD_VAR 0 1
74242: ARRAY
74243: PUSH
74244: LD_INT 1
74246: PLUS
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PPUSH
74252: LD_VAR 0 9
74256: PPUSH
74257: CALL 16013 0 3
74261: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74262: LD_ADDR_EXP 32
74266: PUSH
74267: LD_EXP 32
74271: PPUSH
74272: LD_VAR 0 1
74276: PPUSH
74277: LD_EXP 32
74281: PUSH
74282: LD_VAR 0 1
74286: ARRAY
74287: PUSH
74288: LD_VAR 0 9
74292: DIFF
74293: PPUSH
74294: CALL_OW 1
74298: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74299: LD_VAR 0 3
74303: PPUSH
74304: LD_EXP 33
74308: PUSH
74309: LD_VAR 0 1
74313: ARRAY
74314: PUSH
74315: LD_EXP 33
74319: PUSH
74320: LD_VAR 0 1
74324: ARRAY
74325: ARRAY
74326: PPUSH
74327: CALL_OW 120
// end ; exit ;
74331: GO 74652
// end ; if tmp > 1 then
74333: LD_VAR 0 8
74337: PUSH
74338: LD_INT 1
74340: GREATER
74341: IFFALSE 74445
// for i = 2 to tmp do
74343: LD_ADDR_VAR 0 6
74347: PUSH
74348: DOUBLE
74349: LD_INT 2
74351: DEC
74352: ST_TO_ADDR
74353: LD_VAR 0 8
74357: PUSH
74358: FOR_TO
74359: IFFALSE 74443
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74361: LD_VAR 0 8
74365: PUSH
74366: LD_VAR 0 6
74370: ARRAY
74371: PPUSH
74372: CALL_OW 461
74376: PUSH
74377: LD_INT 6
74379: EQUAL
74380: IFFALSE 74441
// begin x := tmp [ i ] ;
74382: LD_ADDR_VAR 0 9
74386: PUSH
74387: LD_VAR 0 8
74391: PUSH
74392: LD_VAR 0 6
74396: ARRAY
74397: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74398: LD_ADDR_VAR 0 8
74402: PUSH
74403: LD_VAR 0 8
74407: PPUSH
74408: LD_VAR 0 6
74412: PPUSH
74413: CALL_OW 3
74417: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74418: LD_ADDR_VAR 0 8
74422: PUSH
74423: LD_VAR 0 8
74427: PPUSH
74428: LD_INT 1
74430: PPUSH
74431: LD_VAR 0 9
74435: PPUSH
74436: CALL_OW 2
74440: ST_TO_ADDR
// end ;
74441: GO 74358
74443: POP
74444: POP
// for i in tmp do
74445: LD_ADDR_VAR 0 6
74449: PUSH
74450: LD_VAR 0 8
74454: PUSH
74455: FOR_IN
74456: IFFALSE 74525
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74458: LD_VAR 0 6
74462: PPUSH
74463: CALL_OW 313
74467: PUSH
74468: LD_INT 6
74470: LESS
74471: PUSH
74472: LD_VAR 0 6
74476: PPUSH
74477: CALL_OW 266
74481: PUSH
74482: LD_INT 31
74484: PUSH
74485: LD_INT 32
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: IN
74492: NOT
74493: AND
74494: PUSH
74495: LD_VAR 0 6
74499: PPUSH
74500: CALL_OW 313
74504: PUSH
74505: LD_INT 0
74507: EQUAL
74508: OR
74509: IFFALSE 74523
// begin j := i ;
74511: LD_ADDR_VAR 0 7
74515: PUSH
74516: LD_VAR 0 6
74520: ST_TO_ADDR
// break ;
74521: GO 74525
// end ; end ;
74523: GO 74455
74525: POP
74526: POP
// if j then
74527: LD_VAR 0 7
74531: IFFALSE 74549
// ComEnterUnit ( unit , j ) else
74533: LD_VAR 0 3
74537: PPUSH
74538: LD_VAR 0 7
74542: PPUSH
74543: CALL_OW 120
74547: GO 74652
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74549: LD_ADDR_VAR 0 10
74553: PUSH
74554: LD_VAR 0 2
74558: PPUSH
74559: LD_INT 2
74561: PUSH
74562: LD_INT 30
74564: PUSH
74565: LD_INT 0
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 30
74574: PUSH
74575: LD_INT 1
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: LIST
74586: PPUSH
74587: CALL_OW 72
74591: ST_TO_ADDR
// if depot then
74592: LD_VAR 0 10
74596: IFFALSE 74652
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74598: LD_ADDR_VAR 0 10
74602: PUSH
74603: LD_VAR 0 10
74607: PPUSH
74608: LD_VAR 0 3
74612: PPUSH
74613: CALL_OW 74
74617: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74618: LD_VAR 0 3
74622: PPUSH
74623: LD_VAR 0 10
74627: PPUSH
74628: CALL_OW 296
74632: PUSH
74633: LD_INT 10
74635: GREATER
74636: IFFALSE 74652
// ComStandNearbyBuilding ( unit , depot ) ;
74638: LD_VAR 0 3
74642: PPUSH
74643: LD_VAR 0 10
74647: PPUSH
74648: CALL 12591 0 2
// end ; end ; end ;
74652: LD_VAR 0 5
74656: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74657: LD_INT 0
74659: PPUSH
74660: PPUSH
74661: PPUSH
74662: PPUSH
// if not mc_bases then
74663: LD_EXP 23
74667: NOT
74668: IFFALSE 74672
// exit ;
74670: GO 74911
// for i = 1 to mc_bases do
74672: LD_ADDR_VAR 0 2
74676: PUSH
74677: DOUBLE
74678: LD_INT 1
74680: DEC
74681: ST_TO_ADDR
74682: LD_EXP 23
74686: PUSH
74687: FOR_TO
74688: IFFALSE 74909
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74690: LD_ADDR_VAR 0 4
74694: PUSH
74695: LD_EXP 23
74699: PUSH
74700: LD_VAR 0 2
74704: ARRAY
74705: PPUSH
74706: LD_INT 21
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PPUSH
74716: CALL_OW 72
74720: PUSH
74721: LD_EXP 52
74725: PUSH
74726: LD_VAR 0 2
74730: ARRAY
74731: UNION
74732: ST_TO_ADDR
// if not tmp then
74733: LD_VAR 0 4
74737: NOT
74738: IFFALSE 74742
// continue ;
74740: GO 74687
// for j in tmp do
74742: LD_ADDR_VAR 0 3
74746: PUSH
74747: LD_VAR 0 4
74751: PUSH
74752: FOR_IN
74753: IFFALSE 74905
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74755: LD_VAR 0 3
74759: PPUSH
74760: CALL_OW 110
74764: NOT
74765: PUSH
74766: LD_VAR 0 3
74770: PPUSH
74771: CALL_OW 314
74775: NOT
74776: AND
74777: PUSH
74778: LD_VAR 0 3
74782: PPUSH
74783: CALL_OW 311
74787: NOT
74788: AND
74789: PUSH
74790: LD_VAR 0 3
74794: PPUSH
74795: CALL_OW 310
74799: NOT
74800: AND
74801: PUSH
74802: LD_VAR 0 3
74806: PUSH
74807: LD_EXP 26
74811: PUSH
74812: LD_VAR 0 2
74816: ARRAY
74817: PUSH
74818: LD_INT 1
74820: ARRAY
74821: IN
74822: NOT
74823: AND
74824: PUSH
74825: LD_VAR 0 3
74829: PUSH
74830: LD_EXP 26
74834: PUSH
74835: LD_VAR 0 2
74839: ARRAY
74840: PUSH
74841: LD_INT 2
74843: ARRAY
74844: IN
74845: NOT
74846: AND
74847: PUSH
74848: LD_VAR 0 3
74852: PUSH
74853: LD_EXP 35
74857: PUSH
74858: LD_VAR 0 2
74862: ARRAY
74863: IN
74864: NOT
74865: AND
74866: IFFALSE 74903
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74868: LD_VAR 0 2
74872: PPUSH
74873: LD_EXP 23
74877: PUSH
74878: LD_VAR 0 2
74882: ARRAY
74883: PPUSH
74884: LD_VAR 0 3
74888: PPUSH
74889: LD_VAR 0 3
74893: PPUSH
74894: CALL_OW 257
74898: PPUSH
74899: CALL 73675 0 4
// end ;
74903: GO 74752
74905: POP
74906: POP
// end ;
74907: GO 74687
74909: POP
74910: POP
// end ;
74911: LD_VAR 0 1
74915: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74916: LD_INT 0
74918: PPUSH
74919: PPUSH
74920: PPUSH
74921: PPUSH
74922: PPUSH
74923: PPUSH
// if not mc_bases [ base ] then
74924: LD_EXP 23
74928: PUSH
74929: LD_VAR 0 1
74933: ARRAY
74934: NOT
74935: IFFALSE 74939
// exit ;
74937: GO 75121
// tmp := [ ] ;
74939: LD_ADDR_VAR 0 6
74943: PUSH
74944: EMPTY
74945: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74946: LD_ADDR_VAR 0 7
74950: PUSH
74951: LD_VAR 0 3
74955: PPUSH
74956: LD_INT 0
74958: PPUSH
74959: CALL_OW 517
74963: ST_TO_ADDR
// if not list then
74964: LD_VAR 0 7
74968: NOT
74969: IFFALSE 74973
// exit ;
74971: GO 75121
// for i = 1 to amount do
74973: LD_ADDR_VAR 0 5
74977: PUSH
74978: DOUBLE
74979: LD_INT 1
74981: DEC
74982: ST_TO_ADDR
74983: LD_VAR 0 2
74987: PUSH
74988: FOR_TO
74989: IFFALSE 75069
// begin x := rand ( 1 , list [ 1 ] ) ;
74991: LD_ADDR_VAR 0 8
74995: PUSH
74996: LD_INT 1
74998: PPUSH
74999: LD_VAR 0 7
75003: PUSH
75004: LD_INT 1
75006: ARRAY
75007: PPUSH
75008: CALL_OW 12
75012: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75013: LD_ADDR_VAR 0 6
75017: PUSH
75018: LD_VAR 0 6
75022: PPUSH
75023: LD_VAR 0 5
75027: PPUSH
75028: LD_VAR 0 7
75032: PUSH
75033: LD_INT 1
75035: ARRAY
75036: PUSH
75037: LD_VAR 0 8
75041: ARRAY
75042: PUSH
75043: LD_VAR 0 7
75047: PUSH
75048: LD_INT 2
75050: ARRAY
75051: PUSH
75052: LD_VAR 0 8
75056: ARRAY
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PPUSH
75062: CALL_OW 1
75066: ST_TO_ADDR
// end ;
75067: GO 74988
75069: POP
75070: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75071: LD_ADDR_EXP 36
75075: PUSH
75076: LD_EXP 36
75080: PPUSH
75081: LD_VAR 0 1
75085: PPUSH
75086: LD_VAR 0 6
75090: PPUSH
75091: CALL_OW 1
75095: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75096: LD_ADDR_EXP 38
75100: PUSH
75101: LD_EXP 38
75105: PPUSH
75106: LD_VAR 0 1
75110: PPUSH
75111: LD_VAR 0 3
75115: PPUSH
75116: CALL_OW 1
75120: ST_TO_ADDR
// end ;
75121: LD_VAR 0 4
75125: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75126: LD_INT 0
75128: PPUSH
// if not mc_bases [ base ] then
75129: LD_EXP 23
75133: PUSH
75134: LD_VAR 0 1
75138: ARRAY
75139: NOT
75140: IFFALSE 75144
// exit ;
75142: GO 75169
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75144: LD_ADDR_EXP 28
75148: PUSH
75149: LD_EXP 28
75153: PPUSH
75154: LD_VAR 0 1
75158: PPUSH
75159: LD_VAR 0 2
75163: PPUSH
75164: CALL_OW 1
75168: ST_TO_ADDR
// end ;
75169: LD_VAR 0 3
75173: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75174: LD_INT 0
75176: PPUSH
// if not mc_bases [ base ] then
75177: LD_EXP 23
75181: PUSH
75182: LD_VAR 0 1
75186: ARRAY
75187: NOT
75188: IFFALSE 75192
// exit ;
75190: GO 75229
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75192: LD_ADDR_EXP 28
75196: PUSH
75197: LD_EXP 28
75201: PPUSH
75202: LD_VAR 0 1
75206: PPUSH
75207: LD_EXP 28
75211: PUSH
75212: LD_VAR 0 1
75216: ARRAY
75217: PUSH
75218: LD_VAR 0 2
75222: UNION
75223: PPUSH
75224: CALL_OW 1
75228: ST_TO_ADDR
// end ;
75229: LD_VAR 0 3
75233: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75234: LD_INT 0
75236: PPUSH
// if not mc_bases [ base ] then
75237: LD_EXP 23
75241: PUSH
75242: LD_VAR 0 1
75246: ARRAY
75247: NOT
75248: IFFALSE 75252
// exit ;
75250: GO 75277
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75252: LD_ADDR_EXP 44
75256: PUSH
75257: LD_EXP 44
75261: PPUSH
75262: LD_VAR 0 1
75266: PPUSH
75267: LD_VAR 0 2
75271: PPUSH
75272: CALL_OW 1
75276: ST_TO_ADDR
// end ;
75277: LD_VAR 0 3
75281: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75282: LD_INT 0
75284: PPUSH
// if not mc_bases [ base ] then
75285: LD_EXP 23
75289: PUSH
75290: LD_VAR 0 1
75294: ARRAY
75295: NOT
75296: IFFALSE 75300
// exit ;
75298: GO 75337
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75300: LD_ADDR_EXP 44
75304: PUSH
75305: LD_EXP 44
75309: PPUSH
75310: LD_VAR 0 1
75314: PPUSH
75315: LD_EXP 44
75319: PUSH
75320: LD_VAR 0 1
75324: ARRAY
75325: PUSH
75326: LD_VAR 0 2
75330: ADD
75331: PPUSH
75332: CALL_OW 1
75336: ST_TO_ADDR
// end ;
75337: LD_VAR 0 3
75341: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75342: LD_INT 0
75344: PPUSH
// if not mc_bases [ base ] then
75345: LD_EXP 23
75349: PUSH
75350: LD_VAR 0 1
75354: ARRAY
75355: NOT
75356: IFFALSE 75360
// exit ;
75358: GO 75414
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75360: LD_ADDR_EXP 45
75364: PUSH
75365: LD_EXP 45
75369: PPUSH
75370: LD_VAR 0 1
75374: PPUSH
75375: LD_VAR 0 2
75379: PPUSH
75380: CALL_OW 1
75384: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75385: LD_ADDR_EXP 34
75389: PUSH
75390: LD_EXP 34
75394: PPUSH
75395: LD_VAR 0 1
75399: PPUSH
75400: LD_VAR 0 2
75404: PUSH
75405: LD_INT 0
75407: PLUS
75408: PPUSH
75409: CALL_OW 1
75413: ST_TO_ADDR
// end ;
75414: LD_VAR 0 3
75418: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75419: LD_INT 0
75421: PPUSH
// if not mc_bases [ base ] then
75422: LD_EXP 23
75426: PUSH
75427: LD_VAR 0 1
75431: ARRAY
75432: NOT
75433: IFFALSE 75437
// exit ;
75435: GO 75462
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75437: LD_ADDR_EXP 34
75441: PUSH
75442: LD_EXP 34
75446: PPUSH
75447: LD_VAR 0 1
75451: PPUSH
75452: LD_VAR 0 2
75456: PPUSH
75457: CALL_OW 1
75461: ST_TO_ADDR
// end ;
75462: LD_VAR 0 3
75466: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75467: LD_INT 0
75469: PPUSH
75470: PPUSH
75471: PPUSH
75472: PPUSH
// if not mc_bases [ base ] then
75473: LD_EXP 23
75477: PUSH
75478: LD_VAR 0 1
75482: ARRAY
75483: NOT
75484: IFFALSE 75488
// exit ;
75486: GO 75553
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75488: LD_ADDR_EXP 43
75492: PUSH
75493: LD_EXP 43
75497: PPUSH
75498: LD_VAR 0 1
75502: PUSH
75503: LD_EXP 43
75507: PUSH
75508: LD_VAR 0 1
75512: ARRAY
75513: PUSH
75514: LD_INT 1
75516: PLUS
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: PPUSH
75522: LD_VAR 0 1
75526: PUSH
75527: LD_VAR 0 2
75531: PUSH
75532: LD_VAR 0 3
75536: PUSH
75537: LD_VAR 0 4
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: PPUSH
75548: CALL 16013 0 3
75552: ST_TO_ADDR
// end ;
75553: LD_VAR 0 5
75557: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75558: LD_INT 0
75560: PPUSH
// if not mc_bases [ base ] then
75561: LD_EXP 23
75565: PUSH
75566: LD_VAR 0 1
75570: ARRAY
75571: NOT
75572: IFFALSE 75576
// exit ;
75574: GO 75601
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75576: LD_ADDR_EXP 60
75580: PUSH
75581: LD_EXP 60
75585: PPUSH
75586: LD_VAR 0 1
75590: PPUSH
75591: LD_VAR 0 2
75595: PPUSH
75596: CALL_OW 1
75600: ST_TO_ADDR
// end ;
75601: LD_VAR 0 3
75605: RET
// export function MC_GetMinesField ( base ) ; begin
75606: LD_INT 0
75608: PPUSH
// result := mc_mines [ base ] ;
75609: LD_ADDR_VAR 0 2
75613: PUSH
75614: LD_EXP 36
75618: PUSH
75619: LD_VAR 0 1
75623: ARRAY
75624: ST_TO_ADDR
// end ;
75625: LD_VAR 0 2
75629: RET
// export function MC_GetProduceList ( base ) ; begin
75630: LD_INT 0
75632: PPUSH
// result := mc_produce [ base ] ;
75633: LD_ADDR_VAR 0 2
75637: PUSH
75638: LD_EXP 44
75642: PUSH
75643: LD_VAR 0 1
75647: ARRAY
75648: ST_TO_ADDR
// end ;
75649: LD_VAR 0 2
75653: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75654: LD_INT 0
75656: PPUSH
75657: PPUSH
// if not mc_bases then
75658: LD_EXP 23
75662: NOT
75663: IFFALSE 75667
// exit ;
75665: GO 75732
// if mc_bases [ base ] then
75667: LD_EXP 23
75671: PUSH
75672: LD_VAR 0 1
75676: ARRAY
75677: IFFALSE 75732
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75679: LD_ADDR_VAR 0 3
75683: PUSH
75684: LD_EXP 23
75688: PUSH
75689: LD_VAR 0 1
75693: ARRAY
75694: PPUSH
75695: LD_INT 30
75697: PUSH
75698: LD_VAR 0 2
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PPUSH
75707: CALL_OW 72
75711: ST_TO_ADDR
// if result then
75712: LD_VAR 0 3
75716: IFFALSE 75732
// result := result [ 1 ] ;
75718: LD_ADDR_VAR 0 3
75722: PUSH
75723: LD_VAR 0 3
75727: PUSH
75728: LD_INT 1
75730: ARRAY
75731: ST_TO_ADDR
// end ; end ;
75732: LD_VAR 0 3
75736: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75737: LD_INT 0
75739: PPUSH
75740: PPUSH
// if not mc_bases then
75741: LD_EXP 23
75745: NOT
75746: IFFALSE 75750
// exit ;
75748: GO 75795
// if mc_bases [ base ] then
75750: LD_EXP 23
75754: PUSH
75755: LD_VAR 0 1
75759: ARRAY
75760: IFFALSE 75795
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75762: LD_ADDR_VAR 0 3
75766: PUSH
75767: LD_EXP 23
75771: PUSH
75772: LD_VAR 0 1
75776: ARRAY
75777: PPUSH
75778: LD_INT 30
75780: PUSH
75781: LD_VAR 0 2
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PPUSH
75790: CALL_OW 72
75794: ST_TO_ADDR
// end ;
75795: LD_VAR 0 3
75799: RET
// export function MC_SetTame ( base , area ) ; begin
75800: LD_INT 0
75802: PPUSH
// if not mc_bases or not base then
75803: LD_EXP 23
75807: NOT
75808: PUSH
75809: LD_VAR 0 1
75813: NOT
75814: OR
75815: IFFALSE 75819
// exit ;
75817: GO 75844
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75819: LD_ADDR_EXP 51
75823: PUSH
75824: LD_EXP 51
75828: PPUSH
75829: LD_VAR 0 1
75833: PPUSH
75834: LD_VAR 0 2
75838: PPUSH
75839: CALL_OW 1
75843: ST_TO_ADDR
// end ;
75844: LD_VAR 0 3
75848: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75849: LD_INT 0
75851: PPUSH
75852: PPUSH
// if not mc_bases or not base then
75853: LD_EXP 23
75857: NOT
75858: PUSH
75859: LD_VAR 0 1
75863: NOT
75864: OR
75865: IFFALSE 75869
// exit ;
75867: GO 75971
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75869: LD_ADDR_VAR 0 4
75873: PUSH
75874: LD_EXP 23
75878: PUSH
75879: LD_VAR 0 1
75883: ARRAY
75884: PPUSH
75885: LD_INT 30
75887: PUSH
75888: LD_VAR 0 2
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PPUSH
75897: CALL_OW 72
75901: ST_TO_ADDR
// if not tmp then
75902: LD_VAR 0 4
75906: NOT
75907: IFFALSE 75911
// exit ;
75909: GO 75971
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75911: LD_ADDR_EXP 55
75915: PUSH
75916: LD_EXP 55
75920: PPUSH
75921: LD_VAR 0 1
75925: PPUSH
75926: LD_EXP 55
75930: PUSH
75931: LD_VAR 0 1
75935: ARRAY
75936: PPUSH
75937: LD_EXP 55
75941: PUSH
75942: LD_VAR 0 1
75946: ARRAY
75947: PUSH
75948: LD_INT 1
75950: PLUS
75951: PPUSH
75952: LD_VAR 0 4
75956: PUSH
75957: LD_INT 1
75959: ARRAY
75960: PPUSH
75961: CALL_OW 2
75965: PPUSH
75966: CALL_OW 1
75970: ST_TO_ADDR
// end ;
75971: LD_VAR 0 3
75975: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75976: LD_INT 0
75978: PPUSH
75979: PPUSH
// if not mc_bases or not base or not kinds then
75980: LD_EXP 23
75984: NOT
75985: PUSH
75986: LD_VAR 0 1
75990: NOT
75991: OR
75992: PUSH
75993: LD_VAR 0 2
75997: NOT
75998: OR
75999: IFFALSE 76003
// exit ;
76001: GO 76064
// for i in kinds do
76003: LD_ADDR_VAR 0 4
76007: PUSH
76008: LD_VAR 0 2
76012: PUSH
76013: FOR_IN
76014: IFFALSE 76062
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76016: LD_ADDR_EXP 57
76020: PUSH
76021: LD_EXP 57
76025: PPUSH
76026: LD_VAR 0 1
76030: PUSH
76031: LD_EXP 57
76035: PUSH
76036: LD_VAR 0 1
76040: ARRAY
76041: PUSH
76042: LD_INT 1
76044: PLUS
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: PPUSH
76050: LD_VAR 0 4
76054: PPUSH
76055: CALL 16013 0 3
76059: ST_TO_ADDR
76060: GO 76013
76062: POP
76063: POP
// end ;
76064: LD_VAR 0 3
76068: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76069: LD_INT 0
76071: PPUSH
// if not mc_bases or not base or not areas then
76072: LD_EXP 23
76076: NOT
76077: PUSH
76078: LD_VAR 0 1
76082: NOT
76083: OR
76084: PUSH
76085: LD_VAR 0 2
76089: NOT
76090: OR
76091: IFFALSE 76095
// exit ;
76093: GO 76120
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76095: LD_ADDR_EXP 41
76099: PUSH
76100: LD_EXP 41
76104: PPUSH
76105: LD_VAR 0 1
76109: PPUSH
76110: LD_VAR 0 2
76114: PPUSH
76115: CALL_OW 1
76119: ST_TO_ADDR
// end ;
76120: LD_VAR 0 3
76124: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76125: LD_INT 0
76127: PPUSH
// if not mc_bases or not base or not teleports_exit then
76128: LD_EXP 23
76132: NOT
76133: PUSH
76134: LD_VAR 0 1
76138: NOT
76139: OR
76140: PUSH
76141: LD_VAR 0 2
76145: NOT
76146: OR
76147: IFFALSE 76151
// exit ;
76149: GO 76176
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76151: LD_ADDR_EXP 58
76155: PUSH
76156: LD_EXP 58
76160: PPUSH
76161: LD_VAR 0 1
76165: PPUSH
76166: LD_VAR 0 2
76170: PPUSH
76171: CALL_OW 1
76175: ST_TO_ADDR
// end ;
76176: LD_VAR 0 3
76180: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76181: LD_INT 0
76183: PPUSH
76184: PPUSH
76185: PPUSH
// if not mc_bases or not base or not ext_list then
76186: LD_EXP 23
76190: NOT
76191: PUSH
76192: LD_VAR 0 1
76196: NOT
76197: OR
76198: PUSH
76199: LD_VAR 0 5
76203: NOT
76204: OR
76205: IFFALSE 76209
// exit ;
76207: GO 76382
// tmp := GetFacExtXYD ( x , y , d ) ;
76209: LD_ADDR_VAR 0 8
76213: PUSH
76214: LD_VAR 0 2
76218: PPUSH
76219: LD_VAR 0 3
76223: PPUSH
76224: LD_VAR 0 4
76228: PPUSH
76229: CALL 45347 0 3
76233: ST_TO_ADDR
// if not tmp then
76234: LD_VAR 0 8
76238: NOT
76239: IFFALSE 76243
// exit ;
76241: GO 76382
// for i in tmp do
76243: LD_ADDR_VAR 0 7
76247: PUSH
76248: LD_VAR 0 8
76252: PUSH
76253: FOR_IN
76254: IFFALSE 76380
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76256: LD_ADDR_EXP 28
76260: PUSH
76261: LD_EXP 28
76265: PPUSH
76266: LD_VAR 0 1
76270: PPUSH
76271: LD_EXP 28
76275: PUSH
76276: LD_VAR 0 1
76280: ARRAY
76281: PPUSH
76282: LD_EXP 28
76286: PUSH
76287: LD_VAR 0 1
76291: ARRAY
76292: PUSH
76293: LD_INT 1
76295: PLUS
76296: PPUSH
76297: LD_VAR 0 5
76301: PUSH
76302: LD_INT 1
76304: ARRAY
76305: PUSH
76306: LD_VAR 0 7
76310: PUSH
76311: LD_INT 1
76313: ARRAY
76314: PUSH
76315: LD_VAR 0 7
76319: PUSH
76320: LD_INT 2
76322: ARRAY
76323: PUSH
76324: LD_VAR 0 7
76328: PUSH
76329: LD_INT 3
76331: ARRAY
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: LIST
76337: LIST
76338: PPUSH
76339: CALL_OW 2
76343: PPUSH
76344: CALL_OW 1
76348: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76349: LD_ADDR_VAR 0 5
76353: PUSH
76354: LD_VAR 0 5
76358: PPUSH
76359: LD_INT 1
76361: PPUSH
76362: CALL_OW 3
76366: ST_TO_ADDR
// if not ext_list then
76367: LD_VAR 0 5
76371: NOT
76372: IFFALSE 76378
// exit ;
76374: POP
76375: POP
76376: GO 76382
// end ;
76378: GO 76253
76380: POP
76381: POP
// end ;
76382: LD_VAR 0 6
76386: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76387: LD_INT 0
76389: PPUSH
// if not mc_bases or not base or not weapon_list then
76390: LD_EXP 23
76394: NOT
76395: PUSH
76396: LD_VAR 0 1
76400: NOT
76401: OR
76402: PUSH
76403: LD_VAR 0 2
76407: NOT
76408: OR
76409: IFFALSE 76413
// exit ;
76411: GO 76438
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76413: LD_ADDR_EXP 62
76417: PUSH
76418: LD_EXP 62
76422: PPUSH
76423: LD_VAR 0 1
76427: PPUSH
76428: LD_VAR 0 2
76432: PPUSH
76433: CALL_OW 1
76437: ST_TO_ADDR
// end ;
76438: LD_VAR 0 3
76442: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76443: LD_INT 0
76445: PPUSH
// if not mc_bases or not base or not tech_list then
76446: LD_EXP 23
76450: NOT
76451: PUSH
76452: LD_VAR 0 1
76456: NOT
76457: OR
76458: PUSH
76459: LD_VAR 0 2
76463: NOT
76464: OR
76465: IFFALSE 76469
// exit ;
76467: GO 76494
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76469: LD_ADDR_EXP 50
76473: PUSH
76474: LD_EXP 50
76478: PPUSH
76479: LD_VAR 0 1
76483: PPUSH
76484: LD_VAR 0 2
76488: PPUSH
76489: CALL_OW 1
76493: ST_TO_ADDR
// end ;
76494: LD_VAR 0 3
76498: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76499: LD_INT 0
76501: PPUSH
// if not mc_bases or not parking_area or not base then
76502: LD_EXP 23
76506: NOT
76507: PUSH
76508: LD_VAR 0 2
76512: NOT
76513: OR
76514: PUSH
76515: LD_VAR 0 1
76519: NOT
76520: OR
76521: IFFALSE 76525
// exit ;
76523: GO 76550
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76525: LD_ADDR_EXP 47
76529: PUSH
76530: LD_EXP 47
76534: PPUSH
76535: LD_VAR 0 1
76539: PPUSH
76540: LD_VAR 0 2
76544: PPUSH
76545: CALL_OW 1
76549: ST_TO_ADDR
// end ;
76550: LD_VAR 0 3
76554: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76555: LD_INT 0
76557: PPUSH
// if not mc_bases or not base or not scan_area then
76558: LD_EXP 23
76562: NOT
76563: PUSH
76564: LD_VAR 0 1
76568: NOT
76569: OR
76570: PUSH
76571: LD_VAR 0 2
76575: NOT
76576: OR
76577: IFFALSE 76581
// exit ;
76579: GO 76606
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76581: LD_ADDR_EXP 48
76585: PUSH
76586: LD_EXP 48
76590: PPUSH
76591: LD_VAR 0 1
76595: PPUSH
76596: LD_VAR 0 2
76600: PPUSH
76601: CALL_OW 1
76605: ST_TO_ADDR
// end ;
76606: LD_VAR 0 3
76610: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76611: LD_INT 0
76613: PPUSH
76614: PPUSH
// if not mc_bases or not base then
76615: LD_EXP 23
76619: NOT
76620: PUSH
76621: LD_VAR 0 1
76625: NOT
76626: OR
76627: IFFALSE 76631
// exit ;
76629: GO 76695
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76631: LD_ADDR_VAR 0 3
76635: PUSH
76636: LD_INT 1
76638: PUSH
76639: LD_INT 2
76641: PUSH
76642: LD_INT 3
76644: PUSH
76645: LD_INT 4
76647: PUSH
76648: LD_INT 11
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76658: LD_ADDR_EXP 50
76662: PUSH
76663: LD_EXP 50
76667: PPUSH
76668: LD_VAR 0 1
76672: PPUSH
76673: LD_EXP 50
76677: PUSH
76678: LD_VAR 0 1
76682: ARRAY
76683: PUSH
76684: LD_VAR 0 3
76688: DIFF
76689: PPUSH
76690: CALL_OW 1
76694: ST_TO_ADDR
// end ;
76695: LD_VAR 0 2
76699: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76700: LD_INT 0
76702: PPUSH
// result := mc_vehicles [ base ] ;
76703: LD_ADDR_VAR 0 3
76707: PUSH
76708: LD_EXP 42
76712: PUSH
76713: LD_VAR 0 1
76717: ARRAY
76718: ST_TO_ADDR
// if onlyCombat then
76719: LD_VAR 0 2
76723: IFFALSE 76901
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76725: LD_ADDR_VAR 0 3
76729: PUSH
76730: LD_VAR 0 3
76734: PUSH
76735: LD_VAR 0 3
76739: PPUSH
76740: LD_INT 2
76742: PUSH
76743: LD_INT 34
76745: PUSH
76746: LD_INT 12
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 34
76755: PUSH
76756: LD_INT 51
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 34
76765: PUSH
76766: LD_EXP 68
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 34
76777: PUSH
76778: LD_INT 32
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 34
76787: PUSH
76788: LD_INT 13
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 34
76797: PUSH
76798: LD_INT 52
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 34
76807: PUSH
76808: LD_EXP 73
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: PUSH
76817: LD_INT 34
76819: PUSH
76820: LD_INT 14
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 34
76829: PUSH
76830: LD_INT 53
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 34
76839: PUSH
76840: LD_EXP 67
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 34
76851: PUSH
76852: LD_INT 31
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 34
76861: PUSH
76862: LD_INT 48
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 34
76871: PUSH
76872: LD_INT 8
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: LIST
76883: LIST
76884: LIST
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: PPUSH
76895: CALL_OW 72
76899: DIFF
76900: ST_TO_ADDR
// end ; end_of_file
76901: LD_VAR 0 3
76905: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76906: LD_INT 0
76908: PPUSH
76909: PPUSH
76910: PPUSH
// if not mc_bases or not skirmish then
76911: LD_EXP 23
76915: NOT
76916: PUSH
76917: LD_EXP 21
76921: NOT
76922: OR
76923: IFFALSE 76927
// exit ;
76925: GO 77092
// for i = 1 to mc_bases do
76927: LD_ADDR_VAR 0 4
76931: PUSH
76932: DOUBLE
76933: LD_INT 1
76935: DEC
76936: ST_TO_ADDR
76937: LD_EXP 23
76941: PUSH
76942: FOR_TO
76943: IFFALSE 77090
// begin if sci in mc_bases [ i ] then
76945: LD_VAR 0 2
76949: PUSH
76950: LD_EXP 23
76954: PUSH
76955: LD_VAR 0 4
76959: ARRAY
76960: IN
76961: IFFALSE 77088
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76963: LD_ADDR_EXP 52
76967: PUSH
76968: LD_EXP 52
76972: PPUSH
76973: LD_VAR 0 4
76977: PUSH
76978: LD_EXP 52
76982: PUSH
76983: LD_VAR 0 4
76987: ARRAY
76988: PUSH
76989: LD_INT 1
76991: PLUS
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PPUSH
76997: LD_VAR 0 1
77001: PPUSH
77002: CALL 16013 0 3
77006: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77007: LD_ADDR_VAR 0 5
77011: PUSH
77012: LD_EXP 23
77016: PUSH
77017: LD_VAR 0 4
77021: ARRAY
77022: PPUSH
77023: LD_INT 2
77025: PUSH
77026: LD_INT 30
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 30
77038: PUSH
77039: LD_INT 1
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: LIST
77050: PPUSH
77051: CALL_OW 72
77055: PPUSH
77056: LD_VAR 0 1
77060: PPUSH
77061: CALL_OW 74
77065: ST_TO_ADDR
// if tmp then
77066: LD_VAR 0 5
77070: IFFALSE 77086
// ComStandNearbyBuilding ( ape , tmp ) ;
77072: LD_VAR 0 1
77076: PPUSH
77077: LD_VAR 0 5
77081: PPUSH
77082: CALL 12591 0 2
// break ;
77086: GO 77090
// end ; end ;
77088: GO 76942
77090: POP
77091: POP
// end ;
77092: LD_VAR 0 3
77096: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77097: LD_INT 0
77099: PPUSH
77100: PPUSH
77101: PPUSH
// if not mc_bases or not skirmish then
77102: LD_EXP 23
77106: NOT
77107: PUSH
77108: LD_EXP 21
77112: NOT
77113: OR
77114: IFFALSE 77118
// exit ;
77116: GO 77207
// for i = 1 to mc_bases do
77118: LD_ADDR_VAR 0 4
77122: PUSH
77123: DOUBLE
77124: LD_INT 1
77126: DEC
77127: ST_TO_ADDR
77128: LD_EXP 23
77132: PUSH
77133: FOR_TO
77134: IFFALSE 77205
// begin if building in mc_busy_turret_list [ i ] then
77136: LD_VAR 0 1
77140: PUSH
77141: LD_EXP 33
77145: PUSH
77146: LD_VAR 0 4
77150: ARRAY
77151: IN
77152: IFFALSE 77203
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77154: LD_ADDR_VAR 0 5
77158: PUSH
77159: LD_EXP 33
77163: PUSH
77164: LD_VAR 0 4
77168: ARRAY
77169: PUSH
77170: LD_VAR 0 1
77174: DIFF
77175: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77176: LD_ADDR_EXP 33
77180: PUSH
77181: LD_EXP 33
77185: PPUSH
77186: LD_VAR 0 4
77190: PPUSH
77191: LD_VAR 0 5
77195: PPUSH
77196: CALL_OW 1
77200: ST_TO_ADDR
// break ;
77201: GO 77205
// end ; end ;
77203: GO 77133
77205: POP
77206: POP
// end ;
77207: LD_VAR 0 3
77211: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77212: LD_INT 0
77214: PPUSH
77215: PPUSH
77216: PPUSH
// if not mc_bases or not skirmish then
77217: LD_EXP 23
77221: NOT
77222: PUSH
77223: LD_EXP 21
77227: NOT
77228: OR
77229: IFFALSE 77233
// exit ;
77231: GO 77432
// for i = 1 to mc_bases do
77233: LD_ADDR_VAR 0 5
77237: PUSH
77238: DOUBLE
77239: LD_INT 1
77241: DEC
77242: ST_TO_ADDR
77243: LD_EXP 23
77247: PUSH
77248: FOR_TO
77249: IFFALSE 77430
// if building in mc_bases [ i ] then
77251: LD_VAR 0 1
77255: PUSH
77256: LD_EXP 23
77260: PUSH
77261: LD_VAR 0 5
77265: ARRAY
77266: IN
77267: IFFALSE 77428
// begin tmp := mc_bases [ i ] diff building ;
77269: LD_ADDR_VAR 0 6
77273: PUSH
77274: LD_EXP 23
77278: PUSH
77279: LD_VAR 0 5
77283: ARRAY
77284: PUSH
77285: LD_VAR 0 1
77289: DIFF
77290: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77291: LD_ADDR_EXP 23
77295: PUSH
77296: LD_EXP 23
77300: PPUSH
77301: LD_VAR 0 5
77305: PPUSH
77306: LD_VAR 0 6
77310: PPUSH
77311: CALL_OW 1
77315: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77316: LD_VAR 0 1
77320: PUSH
77321: LD_EXP 31
77325: PUSH
77326: LD_VAR 0 5
77330: ARRAY
77331: IN
77332: IFFALSE 77371
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77334: LD_ADDR_EXP 31
77338: PUSH
77339: LD_EXP 31
77343: PPUSH
77344: LD_VAR 0 5
77348: PPUSH
77349: LD_EXP 31
77353: PUSH
77354: LD_VAR 0 5
77358: ARRAY
77359: PUSH
77360: LD_VAR 0 1
77364: DIFF
77365: PPUSH
77366: CALL_OW 1
77370: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77371: LD_VAR 0 1
77375: PUSH
77376: LD_EXP 32
77380: PUSH
77381: LD_VAR 0 5
77385: ARRAY
77386: IN
77387: IFFALSE 77426
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77389: LD_ADDR_EXP 32
77393: PUSH
77394: LD_EXP 32
77398: PPUSH
77399: LD_VAR 0 5
77403: PPUSH
77404: LD_EXP 32
77408: PUSH
77409: LD_VAR 0 5
77413: ARRAY
77414: PUSH
77415: LD_VAR 0 1
77419: DIFF
77420: PPUSH
77421: CALL_OW 1
77425: ST_TO_ADDR
// break ;
77426: GO 77430
// end ;
77428: GO 77248
77430: POP
77431: POP
// end ;
77432: LD_VAR 0 4
77436: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77437: LD_INT 0
77439: PPUSH
77440: PPUSH
77441: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77442: LD_EXP 23
77446: NOT
77447: PUSH
77448: LD_EXP 21
77452: NOT
77453: OR
77454: PUSH
77455: LD_VAR 0 3
77459: PUSH
77460: LD_EXP 49
77464: IN
77465: NOT
77466: OR
77467: IFFALSE 77471
// exit ;
77469: GO 77594
// for i = 1 to mc_vehicles do
77471: LD_ADDR_VAR 0 6
77475: PUSH
77476: DOUBLE
77477: LD_INT 1
77479: DEC
77480: ST_TO_ADDR
77481: LD_EXP 42
77485: PUSH
77486: FOR_TO
77487: IFFALSE 77592
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77489: LD_VAR 0 2
77493: PUSH
77494: LD_EXP 42
77498: PUSH
77499: LD_VAR 0 6
77503: ARRAY
77504: IN
77505: PUSH
77506: LD_VAR 0 1
77510: PUSH
77511: LD_EXP 42
77515: PUSH
77516: LD_VAR 0 6
77520: ARRAY
77521: IN
77522: OR
77523: IFFALSE 77590
// begin tmp := mc_vehicles [ i ] diff old ;
77525: LD_ADDR_VAR 0 7
77529: PUSH
77530: LD_EXP 42
77534: PUSH
77535: LD_VAR 0 6
77539: ARRAY
77540: PUSH
77541: LD_VAR 0 2
77545: DIFF
77546: ST_TO_ADDR
// tmp := tmp diff new ;
77547: LD_ADDR_VAR 0 7
77551: PUSH
77552: LD_VAR 0 7
77556: PUSH
77557: LD_VAR 0 1
77561: DIFF
77562: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77563: LD_ADDR_EXP 42
77567: PUSH
77568: LD_EXP 42
77572: PPUSH
77573: LD_VAR 0 6
77577: PPUSH
77578: LD_VAR 0 7
77582: PPUSH
77583: CALL_OW 1
77587: ST_TO_ADDR
// break ;
77588: GO 77592
// end ;
77590: GO 77486
77592: POP
77593: POP
// end ;
77594: LD_VAR 0 5
77598: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77599: LD_INT 0
77601: PPUSH
77602: PPUSH
77603: PPUSH
77604: PPUSH
// if not mc_bases or not skirmish then
77605: LD_EXP 23
77609: NOT
77610: PUSH
77611: LD_EXP 21
77615: NOT
77616: OR
77617: IFFALSE 77621
// exit ;
77619: GO 78013
// side := GetSide ( vehicle ) ;
77621: LD_ADDR_VAR 0 5
77625: PUSH
77626: LD_VAR 0 1
77630: PPUSH
77631: CALL_OW 255
77635: ST_TO_ADDR
// for i = 1 to mc_bases do
77636: LD_ADDR_VAR 0 4
77640: PUSH
77641: DOUBLE
77642: LD_INT 1
77644: DEC
77645: ST_TO_ADDR
77646: LD_EXP 23
77650: PUSH
77651: FOR_TO
77652: IFFALSE 78011
// begin if factory in mc_bases [ i ] then
77654: LD_VAR 0 2
77658: PUSH
77659: LD_EXP 23
77663: PUSH
77664: LD_VAR 0 4
77668: ARRAY
77669: IN
77670: IFFALSE 78009
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77672: LD_EXP 45
77676: PUSH
77677: LD_VAR 0 4
77681: ARRAY
77682: PUSH
77683: LD_EXP 34
77687: PUSH
77688: LD_VAR 0 4
77692: ARRAY
77693: LESS
77694: PUSH
77695: LD_VAR 0 1
77699: PPUSH
77700: CALL_OW 264
77704: PUSH
77705: LD_INT 31
77707: PUSH
77708: LD_INT 32
77710: PUSH
77711: LD_INT 51
77713: PUSH
77714: LD_EXP 68
77718: PUSH
77719: LD_INT 12
77721: PUSH
77722: LD_INT 30
77724: PUSH
77725: LD_EXP 67
77729: PUSH
77730: LD_INT 11
77732: PUSH
77733: LD_INT 53
77735: PUSH
77736: LD_INT 14
77738: PUSH
77739: LD_EXP 71
77743: PUSH
77744: LD_INT 29
77746: PUSH
77747: LD_EXP 69
77751: PUSH
77752: LD_INT 13
77754: PUSH
77755: LD_INT 52
77757: PUSH
77758: LD_EXP 73
77762: PUSH
77763: LD_INT 48
77765: PUSH
77766: LD_INT 8
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: LIST
77786: LIST
77787: LIST
77788: IN
77789: NOT
77790: AND
77791: IFFALSE 77839
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77793: LD_ADDR_EXP 45
77797: PUSH
77798: LD_EXP 45
77802: PPUSH
77803: LD_VAR 0 4
77807: PUSH
77808: LD_EXP 45
77812: PUSH
77813: LD_VAR 0 4
77817: ARRAY
77818: PUSH
77819: LD_INT 1
77821: PLUS
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PPUSH
77827: LD_VAR 0 1
77831: PPUSH
77832: CALL 16013 0 3
77836: ST_TO_ADDR
77837: GO 77883
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77839: LD_ADDR_EXP 42
77843: PUSH
77844: LD_EXP 42
77848: PPUSH
77849: LD_VAR 0 4
77853: PUSH
77854: LD_EXP 42
77858: PUSH
77859: LD_VAR 0 4
77863: ARRAY
77864: PUSH
77865: LD_INT 1
77867: PLUS
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PPUSH
77873: LD_VAR 0 1
77877: PPUSH
77878: CALL 16013 0 3
77882: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77883: LD_VAR 0 1
77887: PPUSH
77888: CALL_OW 263
77892: PUSH
77893: LD_INT 2
77895: EQUAL
77896: IFFALSE 77925
// begin repeat wait ( 0 0$3 ) ;
77898: LD_INT 105
77900: PPUSH
77901: CALL_OW 67
// Connect ( vehicle ) ;
77905: LD_VAR 0 1
77909: PPUSH
77910: CALL 18984 0 1
// until IsControledBy ( vehicle ) ;
77914: LD_VAR 0 1
77918: PPUSH
77919: CALL_OW 312
77923: IFFALSE 77898
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77925: LD_VAR 0 1
77929: PPUSH
77930: LD_EXP 47
77934: PUSH
77935: LD_VAR 0 4
77939: ARRAY
77940: PPUSH
77941: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77945: LD_VAR 0 1
77949: PPUSH
77950: CALL_OW 263
77954: PUSH
77955: LD_INT 1
77957: NONEQUAL
77958: IFFALSE 77962
// break ;
77960: GO 78011
// repeat wait ( 0 0$1 ) ;
77962: LD_INT 35
77964: PPUSH
77965: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77969: LD_VAR 0 1
77973: PPUSH
77974: LD_EXP 47
77978: PUSH
77979: LD_VAR 0 4
77983: ARRAY
77984: PPUSH
77985: CALL_OW 308
77989: IFFALSE 77962
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77991: LD_VAR 0 1
77995: PPUSH
77996: CALL_OW 311
78000: PPUSH
78001: CALL_OW 121
// exit ;
78005: POP
78006: POP
78007: GO 78013
// end ; end ;
78009: GO 77651
78011: POP
78012: POP
// end ;
78013: LD_VAR 0 3
78017: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78018: LD_INT 0
78020: PPUSH
78021: PPUSH
78022: PPUSH
78023: PPUSH
// if not mc_bases or not skirmish then
78024: LD_EXP 23
78028: NOT
78029: PUSH
78030: LD_EXP 21
78034: NOT
78035: OR
78036: IFFALSE 78040
// exit ;
78038: GO 78393
// repeat wait ( 0 0$1 ) ;
78040: LD_INT 35
78042: PPUSH
78043: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78047: LD_VAR 0 2
78051: PPUSH
78052: LD_VAR 0 3
78056: PPUSH
78057: CALL_OW 284
78061: IFFALSE 78040
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78063: LD_VAR 0 2
78067: PPUSH
78068: LD_VAR 0 3
78072: PPUSH
78073: CALL_OW 283
78077: PUSH
78078: LD_INT 4
78080: EQUAL
78081: IFFALSE 78085
// exit ;
78083: GO 78393
// for i = 1 to mc_bases do
78085: LD_ADDR_VAR 0 7
78089: PUSH
78090: DOUBLE
78091: LD_INT 1
78093: DEC
78094: ST_TO_ADDR
78095: LD_EXP 23
78099: PUSH
78100: FOR_TO
78101: IFFALSE 78391
// begin if mc_crates_area [ i ] then
78103: LD_EXP 41
78107: PUSH
78108: LD_VAR 0 7
78112: ARRAY
78113: IFFALSE 78224
// for j in mc_crates_area [ i ] do
78115: LD_ADDR_VAR 0 8
78119: PUSH
78120: LD_EXP 41
78124: PUSH
78125: LD_VAR 0 7
78129: ARRAY
78130: PUSH
78131: FOR_IN
78132: IFFALSE 78222
// if InArea ( x , y , j ) then
78134: LD_VAR 0 2
78138: PPUSH
78139: LD_VAR 0 3
78143: PPUSH
78144: LD_VAR 0 8
78148: PPUSH
78149: CALL_OW 309
78153: IFFALSE 78220
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78155: LD_ADDR_EXP 39
78159: PUSH
78160: LD_EXP 39
78164: PPUSH
78165: LD_VAR 0 7
78169: PUSH
78170: LD_EXP 39
78174: PUSH
78175: LD_VAR 0 7
78179: ARRAY
78180: PUSH
78181: LD_INT 1
78183: PLUS
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PPUSH
78189: LD_VAR 0 4
78193: PUSH
78194: LD_VAR 0 2
78198: PUSH
78199: LD_VAR 0 3
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: LIST
78208: PPUSH
78209: CALL 16013 0 3
78213: ST_TO_ADDR
// exit ;
78214: POP
78215: POP
78216: POP
78217: POP
78218: GO 78393
// end ;
78220: GO 78131
78222: POP
78223: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78224: LD_ADDR_VAR 0 9
78228: PUSH
78229: LD_EXP 23
78233: PUSH
78234: LD_VAR 0 7
78238: ARRAY
78239: PPUSH
78240: LD_INT 2
78242: PUSH
78243: LD_INT 30
78245: PUSH
78246: LD_INT 0
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 30
78255: PUSH
78256: LD_INT 1
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: LIST
78267: PPUSH
78268: CALL_OW 72
78272: ST_TO_ADDR
// if not depot then
78273: LD_VAR 0 9
78277: NOT
78278: IFFALSE 78282
// continue ;
78280: GO 78100
// for j in depot do
78282: LD_ADDR_VAR 0 8
78286: PUSH
78287: LD_VAR 0 9
78291: PUSH
78292: FOR_IN
78293: IFFALSE 78387
// if GetDistUnitXY ( j , x , y ) < 30 then
78295: LD_VAR 0 8
78299: PPUSH
78300: LD_VAR 0 2
78304: PPUSH
78305: LD_VAR 0 3
78309: PPUSH
78310: CALL_OW 297
78314: PUSH
78315: LD_INT 30
78317: LESS
78318: IFFALSE 78385
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78320: LD_ADDR_EXP 39
78324: PUSH
78325: LD_EXP 39
78329: PPUSH
78330: LD_VAR 0 7
78334: PUSH
78335: LD_EXP 39
78339: PUSH
78340: LD_VAR 0 7
78344: ARRAY
78345: PUSH
78346: LD_INT 1
78348: PLUS
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PPUSH
78354: LD_VAR 0 4
78358: PUSH
78359: LD_VAR 0 2
78363: PUSH
78364: LD_VAR 0 3
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: LIST
78373: PPUSH
78374: CALL 16013 0 3
78378: ST_TO_ADDR
// exit ;
78379: POP
78380: POP
78381: POP
78382: POP
78383: GO 78393
// end ;
78385: GO 78292
78387: POP
78388: POP
// end ;
78389: GO 78100
78391: POP
78392: POP
// end ;
78393: LD_VAR 0 6
78397: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78398: LD_INT 0
78400: PPUSH
78401: PPUSH
78402: PPUSH
78403: PPUSH
// if not mc_bases or not skirmish then
78404: LD_EXP 23
78408: NOT
78409: PUSH
78410: LD_EXP 21
78414: NOT
78415: OR
78416: IFFALSE 78420
// exit ;
78418: GO 78697
// side := GetSide ( lab ) ;
78420: LD_ADDR_VAR 0 4
78424: PUSH
78425: LD_VAR 0 2
78429: PPUSH
78430: CALL_OW 255
78434: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78435: LD_VAR 0 4
78439: PUSH
78440: LD_EXP 49
78444: IN
78445: NOT
78446: PUSH
78447: LD_EXP 50
78451: NOT
78452: OR
78453: PUSH
78454: LD_EXP 23
78458: NOT
78459: OR
78460: IFFALSE 78464
// exit ;
78462: GO 78697
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78464: LD_ADDR_EXP 50
78468: PUSH
78469: LD_EXP 50
78473: PPUSH
78474: LD_VAR 0 4
78478: PPUSH
78479: LD_EXP 50
78483: PUSH
78484: LD_VAR 0 4
78488: ARRAY
78489: PUSH
78490: LD_VAR 0 1
78494: DIFF
78495: PPUSH
78496: CALL_OW 1
78500: ST_TO_ADDR
// for i = 1 to mc_bases do
78501: LD_ADDR_VAR 0 5
78505: PUSH
78506: DOUBLE
78507: LD_INT 1
78509: DEC
78510: ST_TO_ADDR
78511: LD_EXP 23
78515: PUSH
78516: FOR_TO
78517: IFFALSE 78695
// begin if lab in mc_bases [ i ] then
78519: LD_VAR 0 2
78523: PUSH
78524: LD_EXP 23
78528: PUSH
78529: LD_VAR 0 5
78533: ARRAY
78534: IN
78535: IFFALSE 78693
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78537: LD_VAR 0 1
78541: PUSH
78542: LD_INT 11
78544: PUSH
78545: LD_INT 4
78547: PUSH
78548: LD_INT 3
78550: PUSH
78551: LD_INT 2
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: IN
78560: PUSH
78561: LD_EXP 53
78565: PUSH
78566: LD_VAR 0 5
78570: ARRAY
78571: AND
78572: IFFALSE 78693
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78574: LD_ADDR_VAR 0 6
78578: PUSH
78579: LD_EXP 53
78583: PUSH
78584: LD_VAR 0 5
78588: ARRAY
78589: PUSH
78590: LD_INT 1
78592: ARRAY
78593: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78594: LD_ADDR_EXP 53
78598: PUSH
78599: LD_EXP 53
78603: PPUSH
78604: LD_VAR 0 5
78608: PPUSH
78609: EMPTY
78610: PPUSH
78611: CALL_OW 1
78615: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78616: LD_VAR 0 6
78620: PPUSH
78621: LD_INT 0
78623: PPUSH
78624: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78628: LD_VAR 0 6
78632: PPUSH
78633: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78637: LD_ADDR_EXP 52
78641: PUSH
78642: LD_EXP 52
78646: PPUSH
78647: LD_VAR 0 5
78651: PPUSH
78652: LD_EXP 52
78656: PUSH
78657: LD_VAR 0 5
78661: ARRAY
78662: PPUSH
78663: LD_INT 1
78665: PPUSH
78666: LD_VAR 0 6
78670: PPUSH
78671: CALL_OW 2
78675: PPUSH
78676: CALL_OW 1
78680: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78681: LD_VAR 0 5
78685: PPUSH
78686: LD_INT 112
78688: PPUSH
78689: CALL 55216 0 2
// end ; end ; end ;
78693: GO 78516
78695: POP
78696: POP
// end ;
78697: LD_VAR 0 3
78701: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78702: LD_INT 0
78704: PPUSH
78705: PPUSH
78706: PPUSH
78707: PPUSH
78708: PPUSH
78709: PPUSH
78710: PPUSH
78711: PPUSH
// if not mc_bases or not skirmish then
78712: LD_EXP 23
78716: NOT
78717: PUSH
78718: LD_EXP 21
78722: NOT
78723: OR
78724: IFFALSE 78728
// exit ;
78726: GO 80099
// for i = 1 to mc_bases do
78728: LD_ADDR_VAR 0 3
78732: PUSH
78733: DOUBLE
78734: LD_INT 1
78736: DEC
78737: ST_TO_ADDR
78738: LD_EXP 23
78742: PUSH
78743: FOR_TO
78744: IFFALSE 80097
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78746: LD_VAR 0 1
78750: PUSH
78751: LD_EXP 23
78755: PUSH
78756: LD_VAR 0 3
78760: ARRAY
78761: IN
78762: PUSH
78763: LD_VAR 0 1
78767: PUSH
78768: LD_EXP 30
78772: PUSH
78773: LD_VAR 0 3
78777: ARRAY
78778: IN
78779: OR
78780: PUSH
78781: LD_VAR 0 1
78785: PUSH
78786: LD_EXP 45
78790: PUSH
78791: LD_VAR 0 3
78795: ARRAY
78796: IN
78797: OR
78798: PUSH
78799: LD_VAR 0 1
78803: PUSH
78804: LD_EXP 42
78808: PUSH
78809: LD_VAR 0 3
78813: ARRAY
78814: IN
78815: OR
78816: PUSH
78817: LD_VAR 0 1
78821: PUSH
78822: LD_EXP 52
78826: PUSH
78827: LD_VAR 0 3
78831: ARRAY
78832: IN
78833: OR
78834: PUSH
78835: LD_VAR 0 1
78839: PUSH
78840: LD_EXP 53
78844: PUSH
78845: LD_VAR 0 3
78849: ARRAY
78850: IN
78851: OR
78852: IFFALSE 80095
// begin if un in mc_ape [ i ] then
78854: LD_VAR 0 1
78858: PUSH
78859: LD_EXP 52
78863: PUSH
78864: LD_VAR 0 3
78868: ARRAY
78869: IN
78870: IFFALSE 78909
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78872: LD_ADDR_EXP 52
78876: PUSH
78877: LD_EXP 52
78881: PPUSH
78882: LD_VAR 0 3
78886: PPUSH
78887: LD_EXP 52
78891: PUSH
78892: LD_VAR 0 3
78896: ARRAY
78897: PUSH
78898: LD_VAR 0 1
78902: DIFF
78903: PPUSH
78904: CALL_OW 1
78908: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78909: LD_VAR 0 1
78913: PUSH
78914: LD_EXP 53
78918: PUSH
78919: LD_VAR 0 3
78923: ARRAY
78924: IN
78925: IFFALSE 78949
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78927: LD_ADDR_EXP 53
78931: PUSH
78932: LD_EXP 53
78936: PPUSH
78937: LD_VAR 0 3
78941: PPUSH
78942: EMPTY
78943: PPUSH
78944: CALL_OW 1
78948: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78949: LD_VAR 0 1
78953: PPUSH
78954: CALL_OW 247
78958: PUSH
78959: LD_INT 2
78961: EQUAL
78962: PUSH
78963: LD_VAR 0 1
78967: PPUSH
78968: CALL_OW 110
78972: PUSH
78973: LD_INT 20
78975: EQUAL
78976: PUSH
78977: LD_VAR 0 1
78981: PUSH
78982: LD_EXP 45
78986: PUSH
78987: LD_VAR 0 3
78991: ARRAY
78992: IN
78993: OR
78994: PUSH
78995: LD_VAR 0 1
78999: PPUSH
79000: CALL_OW 264
79004: PUSH
79005: LD_INT 12
79007: PUSH
79008: LD_INT 51
79010: PUSH
79011: LD_EXP 68
79015: PUSH
79016: LD_INT 32
79018: PUSH
79019: LD_INT 13
79021: PUSH
79022: LD_INT 52
79024: PUSH
79025: LD_INT 31
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: IN
79037: OR
79038: AND
79039: IFFALSE 79347
// begin if un in mc_defender [ i ] then
79041: LD_VAR 0 1
79045: PUSH
79046: LD_EXP 45
79050: PUSH
79051: LD_VAR 0 3
79055: ARRAY
79056: IN
79057: IFFALSE 79096
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79059: LD_ADDR_EXP 45
79063: PUSH
79064: LD_EXP 45
79068: PPUSH
79069: LD_VAR 0 3
79073: PPUSH
79074: LD_EXP 45
79078: PUSH
79079: LD_VAR 0 3
79083: ARRAY
79084: PUSH
79085: LD_VAR 0 1
79089: DIFF
79090: PPUSH
79091: CALL_OW 1
79095: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79096: LD_ADDR_VAR 0 8
79100: PUSH
79101: LD_VAR 0 3
79105: PPUSH
79106: LD_INT 3
79108: PPUSH
79109: CALL 75737 0 2
79113: ST_TO_ADDR
// if fac then
79114: LD_VAR 0 8
79118: IFFALSE 79347
// begin for j in fac do
79120: LD_ADDR_VAR 0 4
79124: PUSH
79125: LD_VAR 0 8
79129: PUSH
79130: FOR_IN
79131: IFFALSE 79345
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79133: LD_ADDR_VAR 0 9
79137: PUSH
79138: LD_VAR 0 8
79142: PPUSH
79143: LD_VAR 0 1
79147: PPUSH
79148: CALL_OW 265
79152: PPUSH
79153: LD_VAR 0 1
79157: PPUSH
79158: CALL_OW 262
79162: PPUSH
79163: LD_VAR 0 1
79167: PPUSH
79168: CALL_OW 263
79172: PPUSH
79173: LD_VAR 0 1
79177: PPUSH
79178: CALL_OW 264
79182: PPUSH
79183: CALL 13509 0 5
79187: ST_TO_ADDR
// if components then
79188: LD_VAR 0 9
79192: IFFALSE 79343
// begin if GetWeapon ( un ) = ar_control_tower then
79194: LD_VAR 0 1
79198: PPUSH
79199: CALL_OW 264
79203: PUSH
79204: LD_INT 31
79206: EQUAL
79207: IFFALSE 79324
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79209: LD_VAR 0 1
79213: PPUSH
79214: CALL_OW 311
79218: PPUSH
79219: LD_INT 0
79221: PPUSH
79222: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79226: LD_ADDR_EXP 63
79230: PUSH
79231: LD_EXP 63
79235: PPUSH
79236: LD_VAR 0 3
79240: PPUSH
79241: LD_EXP 63
79245: PUSH
79246: LD_VAR 0 3
79250: ARRAY
79251: PUSH
79252: LD_VAR 0 1
79256: PPUSH
79257: CALL_OW 311
79261: DIFF
79262: PPUSH
79263: CALL_OW 1
79267: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79268: LD_ADDR_VAR 0 7
79272: PUSH
79273: LD_EXP 44
79277: PUSH
79278: LD_VAR 0 3
79282: ARRAY
79283: PPUSH
79284: LD_INT 1
79286: PPUSH
79287: LD_VAR 0 9
79291: PPUSH
79292: CALL_OW 2
79296: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79297: LD_ADDR_EXP 44
79301: PUSH
79302: LD_EXP 44
79306: PPUSH
79307: LD_VAR 0 3
79311: PPUSH
79312: LD_VAR 0 7
79316: PPUSH
79317: CALL_OW 1
79321: ST_TO_ADDR
// end else
79322: GO 79341
// MC_InsertProduceList ( i , [ components ] ) ;
79324: LD_VAR 0 3
79328: PPUSH
79329: LD_VAR 0 9
79333: PUSH
79334: EMPTY
79335: LIST
79336: PPUSH
79337: CALL 75282 0 2
// break ;
79341: GO 79345
// end ; end ;
79343: GO 79130
79345: POP
79346: POP
// end ; end ; if GetType ( un ) = unit_building then
79347: LD_VAR 0 1
79351: PPUSH
79352: CALL_OW 247
79356: PUSH
79357: LD_INT 3
79359: EQUAL
79360: IFFALSE 79763
// begin btype := GetBType ( un ) ;
79362: LD_ADDR_VAR 0 5
79366: PUSH
79367: LD_VAR 0 1
79371: PPUSH
79372: CALL_OW 266
79376: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79377: LD_VAR 0 5
79381: PUSH
79382: LD_INT 29
79384: PUSH
79385: LD_INT 30
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: IN
79392: IFFALSE 79465
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79394: LD_VAR 0 1
79398: PPUSH
79399: CALL_OW 250
79403: PPUSH
79404: LD_VAR 0 1
79408: PPUSH
79409: CALL_OW 251
79413: PPUSH
79414: LD_VAR 0 1
79418: PPUSH
79419: CALL_OW 255
79423: PPUSH
79424: CALL_OW 440
79428: NOT
79429: IFFALSE 79465
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79431: LD_VAR 0 1
79435: PPUSH
79436: CALL_OW 250
79440: PPUSH
79441: LD_VAR 0 1
79445: PPUSH
79446: CALL_OW 251
79450: PPUSH
79451: LD_VAR 0 1
79455: PPUSH
79456: CALL_OW 255
79460: PPUSH
79461: CALL_OW 441
// end ; if btype = b_warehouse then
79465: LD_VAR 0 5
79469: PUSH
79470: LD_INT 1
79472: EQUAL
79473: IFFALSE 79491
// begin btype := b_depot ;
79475: LD_ADDR_VAR 0 5
79479: PUSH
79480: LD_INT 0
79482: ST_TO_ADDR
// pos := 1 ;
79483: LD_ADDR_VAR 0 6
79487: PUSH
79488: LD_INT 1
79490: ST_TO_ADDR
// end ; if btype = b_factory then
79491: LD_VAR 0 5
79495: PUSH
79496: LD_INT 3
79498: EQUAL
79499: IFFALSE 79517
// begin btype := b_workshop ;
79501: LD_ADDR_VAR 0 5
79505: PUSH
79506: LD_INT 2
79508: ST_TO_ADDR
// pos := 1 ;
79509: LD_ADDR_VAR 0 6
79513: PUSH
79514: LD_INT 1
79516: ST_TO_ADDR
// end ; if btype = b_barracks then
79517: LD_VAR 0 5
79521: PUSH
79522: LD_INT 5
79524: EQUAL
79525: IFFALSE 79535
// btype := b_armoury ;
79527: LD_ADDR_VAR 0 5
79531: PUSH
79532: LD_INT 4
79534: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79535: LD_VAR 0 5
79539: PUSH
79540: LD_INT 7
79542: PUSH
79543: LD_INT 8
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: IN
79550: IFFALSE 79560
// btype := b_lab ;
79552: LD_ADDR_VAR 0 5
79556: PUSH
79557: LD_INT 6
79559: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79560: LD_ADDR_EXP 28
79564: PUSH
79565: LD_EXP 28
79569: PPUSH
79570: LD_VAR 0 3
79574: PUSH
79575: LD_EXP 28
79579: PUSH
79580: LD_VAR 0 3
79584: ARRAY
79585: PUSH
79586: LD_INT 1
79588: PLUS
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PPUSH
79594: LD_VAR 0 5
79598: PUSH
79599: LD_VAR 0 1
79603: PPUSH
79604: CALL_OW 250
79608: PUSH
79609: LD_VAR 0 1
79613: PPUSH
79614: CALL_OW 251
79618: PUSH
79619: LD_VAR 0 1
79623: PPUSH
79624: CALL_OW 254
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: PPUSH
79635: CALL 16013 0 3
79639: ST_TO_ADDR
// if pos = 1 then
79640: LD_VAR 0 6
79644: PUSH
79645: LD_INT 1
79647: EQUAL
79648: IFFALSE 79763
// begin tmp := mc_build_list [ i ] ;
79650: LD_ADDR_VAR 0 7
79654: PUSH
79655: LD_EXP 28
79659: PUSH
79660: LD_VAR 0 3
79664: ARRAY
79665: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79666: LD_VAR 0 7
79670: PPUSH
79671: LD_INT 2
79673: PUSH
79674: LD_INT 30
79676: PUSH
79677: LD_INT 0
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 30
79686: PUSH
79687: LD_INT 1
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: LIST
79698: PPUSH
79699: CALL_OW 72
79703: IFFALSE 79713
// pos := 2 ;
79705: LD_ADDR_VAR 0 6
79709: PUSH
79710: LD_INT 2
79712: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79713: LD_ADDR_VAR 0 7
79717: PUSH
79718: LD_VAR 0 7
79722: PPUSH
79723: LD_VAR 0 6
79727: PPUSH
79728: LD_VAR 0 7
79732: PPUSH
79733: CALL 16339 0 3
79737: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79738: LD_ADDR_EXP 28
79742: PUSH
79743: LD_EXP 28
79747: PPUSH
79748: LD_VAR 0 3
79752: PPUSH
79753: LD_VAR 0 7
79757: PPUSH
79758: CALL_OW 1
79762: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79763: LD_VAR 0 1
79767: PUSH
79768: LD_EXP 23
79772: PUSH
79773: LD_VAR 0 3
79777: ARRAY
79778: IN
79779: IFFALSE 79818
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79781: LD_ADDR_EXP 23
79785: PUSH
79786: LD_EXP 23
79790: PPUSH
79791: LD_VAR 0 3
79795: PPUSH
79796: LD_EXP 23
79800: PUSH
79801: LD_VAR 0 3
79805: ARRAY
79806: PUSH
79807: LD_VAR 0 1
79811: DIFF
79812: PPUSH
79813: CALL_OW 1
79817: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79818: LD_VAR 0 1
79822: PUSH
79823: LD_EXP 30
79827: PUSH
79828: LD_VAR 0 3
79832: ARRAY
79833: IN
79834: IFFALSE 79873
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79836: LD_ADDR_EXP 30
79840: PUSH
79841: LD_EXP 30
79845: PPUSH
79846: LD_VAR 0 3
79850: PPUSH
79851: LD_EXP 30
79855: PUSH
79856: LD_VAR 0 3
79860: ARRAY
79861: PUSH
79862: LD_VAR 0 1
79866: DIFF
79867: PPUSH
79868: CALL_OW 1
79872: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79873: LD_VAR 0 1
79877: PUSH
79878: LD_EXP 42
79882: PUSH
79883: LD_VAR 0 3
79887: ARRAY
79888: IN
79889: IFFALSE 79928
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79891: LD_ADDR_EXP 42
79895: PUSH
79896: LD_EXP 42
79900: PPUSH
79901: LD_VAR 0 3
79905: PPUSH
79906: LD_EXP 42
79910: PUSH
79911: LD_VAR 0 3
79915: ARRAY
79916: PUSH
79917: LD_VAR 0 1
79921: DIFF
79922: PPUSH
79923: CALL_OW 1
79927: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79928: LD_VAR 0 1
79932: PUSH
79933: LD_EXP 45
79937: PUSH
79938: LD_VAR 0 3
79942: ARRAY
79943: IN
79944: IFFALSE 79983
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79946: LD_ADDR_EXP 45
79950: PUSH
79951: LD_EXP 45
79955: PPUSH
79956: LD_VAR 0 3
79960: PPUSH
79961: LD_EXP 45
79965: PUSH
79966: LD_VAR 0 3
79970: ARRAY
79971: PUSH
79972: LD_VAR 0 1
79976: DIFF
79977: PPUSH
79978: CALL_OW 1
79982: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79983: LD_VAR 0 1
79987: PUSH
79988: LD_EXP 32
79992: PUSH
79993: LD_VAR 0 3
79997: ARRAY
79998: IN
79999: IFFALSE 80038
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80001: LD_ADDR_EXP 32
80005: PUSH
80006: LD_EXP 32
80010: PPUSH
80011: LD_VAR 0 3
80015: PPUSH
80016: LD_EXP 32
80020: PUSH
80021: LD_VAR 0 3
80025: ARRAY
80026: PUSH
80027: LD_VAR 0 1
80031: DIFF
80032: PPUSH
80033: CALL_OW 1
80037: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80038: LD_VAR 0 1
80042: PUSH
80043: LD_EXP 31
80047: PUSH
80048: LD_VAR 0 3
80052: ARRAY
80053: IN
80054: IFFALSE 80093
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80056: LD_ADDR_EXP 31
80060: PUSH
80061: LD_EXP 31
80065: PPUSH
80066: LD_VAR 0 3
80070: PPUSH
80071: LD_EXP 31
80075: PUSH
80076: LD_VAR 0 3
80080: ARRAY
80081: PUSH
80082: LD_VAR 0 1
80086: DIFF
80087: PPUSH
80088: CALL_OW 1
80092: ST_TO_ADDR
// end ; break ;
80093: GO 80097
// end ;
80095: GO 78743
80097: POP
80098: POP
// end ;
80099: LD_VAR 0 2
80103: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80104: LD_INT 0
80106: PPUSH
80107: PPUSH
80108: PPUSH
// if not mc_bases or not skirmish then
80109: LD_EXP 23
80113: NOT
80114: PUSH
80115: LD_EXP 21
80119: NOT
80120: OR
80121: IFFALSE 80125
// exit ;
80123: GO 80340
// for i = 1 to mc_bases do
80125: LD_ADDR_VAR 0 3
80129: PUSH
80130: DOUBLE
80131: LD_INT 1
80133: DEC
80134: ST_TO_ADDR
80135: LD_EXP 23
80139: PUSH
80140: FOR_TO
80141: IFFALSE 80338
// begin if building in mc_construct_list [ i ] then
80143: LD_VAR 0 1
80147: PUSH
80148: LD_EXP 30
80152: PUSH
80153: LD_VAR 0 3
80157: ARRAY
80158: IN
80159: IFFALSE 80336
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80161: LD_ADDR_EXP 30
80165: PUSH
80166: LD_EXP 30
80170: PPUSH
80171: LD_VAR 0 3
80175: PPUSH
80176: LD_EXP 30
80180: PUSH
80181: LD_VAR 0 3
80185: ARRAY
80186: PUSH
80187: LD_VAR 0 1
80191: DIFF
80192: PPUSH
80193: CALL_OW 1
80197: ST_TO_ADDR
// if building in mc_lab [ i ] then
80198: LD_VAR 0 1
80202: PUSH
80203: LD_EXP 56
80207: PUSH
80208: LD_VAR 0 3
80212: ARRAY
80213: IN
80214: IFFALSE 80269
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80216: LD_ADDR_EXP 57
80220: PUSH
80221: LD_EXP 57
80225: PPUSH
80226: LD_VAR 0 3
80230: PPUSH
80231: LD_EXP 57
80235: PUSH
80236: LD_VAR 0 3
80240: ARRAY
80241: PPUSH
80242: LD_INT 1
80244: PPUSH
80245: LD_EXP 57
80249: PUSH
80250: LD_VAR 0 3
80254: ARRAY
80255: PPUSH
80256: LD_INT 0
80258: PPUSH
80259: CALL 15431 0 4
80263: PPUSH
80264: CALL_OW 1
80268: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80269: LD_VAR 0 1
80273: PUSH
80274: LD_EXP 23
80278: PUSH
80279: LD_VAR 0 3
80283: ARRAY
80284: IN
80285: NOT
80286: IFFALSE 80332
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80288: LD_ADDR_EXP 23
80292: PUSH
80293: LD_EXP 23
80297: PPUSH
80298: LD_VAR 0 3
80302: PUSH
80303: LD_EXP 23
80307: PUSH
80308: LD_VAR 0 3
80312: ARRAY
80313: PUSH
80314: LD_INT 1
80316: PLUS
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PPUSH
80322: LD_VAR 0 1
80326: PPUSH
80327: CALL 16013 0 3
80331: ST_TO_ADDR
// exit ;
80332: POP
80333: POP
80334: GO 80340
// end ; end ;
80336: GO 80140
80338: POP
80339: POP
// end ;
80340: LD_VAR 0 2
80344: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80345: LD_INT 0
80347: PPUSH
80348: PPUSH
80349: PPUSH
80350: PPUSH
80351: PPUSH
80352: PPUSH
80353: PPUSH
// if not mc_bases or not skirmish then
80354: LD_EXP 23
80358: NOT
80359: PUSH
80360: LD_EXP 21
80364: NOT
80365: OR
80366: IFFALSE 80370
// exit ;
80368: GO 81031
// for i = 1 to mc_bases do
80370: LD_ADDR_VAR 0 3
80374: PUSH
80375: DOUBLE
80376: LD_INT 1
80378: DEC
80379: ST_TO_ADDR
80380: LD_EXP 23
80384: PUSH
80385: FOR_TO
80386: IFFALSE 81029
// begin if building in mc_construct_list [ i ] then
80388: LD_VAR 0 1
80392: PUSH
80393: LD_EXP 30
80397: PUSH
80398: LD_VAR 0 3
80402: ARRAY
80403: IN
80404: IFFALSE 81027
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80406: LD_ADDR_EXP 30
80410: PUSH
80411: LD_EXP 30
80415: PPUSH
80416: LD_VAR 0 3
80420: PPUSH
80421: LD_EXP 30
80425: PUSH
80426: LD_VAR 0 3
80430: ARRAY
80431: PUSH
80432: LD_VAR 0 1
80436: DIFF
80437: PPUSH
80438: CALL_OW 1
80442: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80443: LD_ADDR_EXP 23
80447: PUSH
80448: LD_EXP 23
80452: PPUSH
80453: LD_VAR 0 3
80457: PUSH
80458: LD_EXP 23
80462: PUSH
80463: LD_VAR 0 3
80467: ARRAY
80468: PUSH
80469: LD_INT 1
80471: PLUS
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PPUSH
80477: LD_VAR 0 1
80481: PPUSH
80482: CALL 16013 0 3
80486: ST_TO_ADDR
// btype := GetBType ( building ) ;
80487: LD_ADDR_VAR 0 5
80491: PUSH
80492: LD_VAR 0 1
80496: PPUSH
80497: CALL_OW 266
80501: ST_TO_ADDR
// side := GetSide ( building ) ;
80502: LD_ADDR_VAR 0 8
80506: PUSH
80507: LD_VAR 0 1
80511: PPUSH
80512: CALL_OW 255
80516: ST_TO_ADDR
// if btype = b_lab then
80517: LD_VAR 0 5
80521: PUSH
80522: LD_INT 6
80524: EQUAL
80525: IFFALSE 80575
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80527: LD_ADDR_EXP 56
80531: PUSH
80532: LD_EXP 56
80536: PPUSH
80537: LD_VAR 0 3
80541: PUSH
80542: LD_EXP 56
80546: PUSH
80547: LD_VAR 0 3
80551: ARRAY
80552: PUSH
80553: LD_INT 1
80555: PLUS
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PPUSH
80561: LD_VAR 0 1
80565: PPUSH
80566: CALL 16013 0 3
80570: ST_TO_ADDR
// exit ;
80571: POP
80572: POP
80573: GO 81031
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80575: LD_VAR 0 5
80579: PUSH
80580: LD_INT 0
80582: PUSH
80583: LD_INT 2
80585: PUSH
80586: LD_INT 4
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: LIST
80593: IN
80594: IFFALSE 80718
// begin if btype = b_armoury then
80596: LD_VAR 0 5
80600: PUSH
80601: LD_INT 4
80603: EQUAL
80604: IFFALSE 80614
// btype := b_barracks ;
80606: LD_ADDR_VAR 0 5
80610: PUSH
80611: LD_INT 5
80613: ST_TO_ADDR
// if btype = b_depot then
80614: LD_VAR 0 5
80618: PUSH
80619: LD_INT 0
80621: EQUAL
80622: IFFALSE 80632
// btype := b_warehouse ;
80624: LD_ADDR_VAR 0 5
80628: PUSH
80629: LD_INT 1
80631: ST_TO_ADDR
// if btype = b_workshop then
80632: LD_VAR 0 5
80636: PUSH
80637: LD_INT 2
80639: EQUAL
80640: IFFALSE 80650
// btype := b_factory ;
80642: LD_ADDR_VAR 0 5
80646: PUSH
80647: LD_INT 3
80649: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80650: LD_VAR 0 5
80654: PPUSH
80655: LD_VAR 0 8
80659: PPUSH
80660: CALL_OW 323
80664: PUSH
80665: LD_INT 1
80667: EQUAL
80668: IFFALSE 80714
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80670: LD_ADDR_EXP 55
80674: PUSH
80675: LD_EXP 55
80679: PPUSH
80680: LD_VAR 0 3
80684: PUSH
80685: LD_EXP 55
80689: PUSH
80690: LD_VAR 0 3
80694: ARRAY
80695: PUSH
80696: LD_INT 1
80698: PLUS
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PPUSH
80704: LD_VAR 0 1
80708: PPUSH
80709: CALL 16013 0 3
80713: ST_TO_ADDR
// exit ;
80714: POP
80715: POP
80716: GO 81031
// end ; if btype in [ b_bunker , b_turret ] then
80718: LD_VAR 0 5
80722: PUSH
80723: LD_INT 32
80725: PUSH
80726: LD_INT 33
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: IN
80733: IFFALSE 81023
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80735: LD_ADDR_EXP 31
80739: PUSH
80740: LD_EXP 31
80744: PPUSH
80745: LD_VAR 0 3
80749: PUSH
80750: LD_EXP 31
80754: PUSH
80755: LD_VAR 0 3
80759: ARRAY
80760: PUSH
80761: LD_INT 1
80763: PLUS
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PPUSH
80769: LD_VAR 0 1
80773: PPUSH
80774: CALL 16013 0 3
80778: ST_TO_ADDR
// if btype = b_bunker then
80779: LD_VAR 0 5
80783: PUSH
80784: LD_INT 32
80786: EQUAL
80787: IFFALSE 81023
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80789: LD_ADDR_EXP 32
80793: PUSH
80794: LD_EXP 32
80798: PPUSH
80799: LD_VAR 0 3
80803: PUSH
80804: LD_EXP 32
80808: PUSH
80809: LD_VAR 0 3
80813: ARRAY
80814: PUSH
80815: LD_INT 1
80817: PLUS
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PPUSH
80823: LD_VAR 0 1
80827: PPUSH
80828: CALL 16013 0 3
80832: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80833: LD_ADDR_VAR 0 6
80837: PUSH
80838: LD_EXP 23
80842: PUSH
80843: LD_VAR 0 3
80847: ARRAY
80848: PPUSH
80849: LD_INT 25
80851: PUSH
80852: LD_INT 1
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 3
80861: PUSH
80862: LD_INT 54
80864: PUSH
80865: EMPTY
80866: LIST
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PPUSH
80876: CALL_OW 72
80880: ST_TO_ADDR
// if tmp then
80881: LD_VAR 0 6
80885: IFFALSE 80891
// exit ;
80887: POP
80888: POP
80889: GO 81031
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80891: LD_ADDR_VAR 0 6
80895: PUSH
80896: LD_EXP 23
80900: PUSH
80901: LD_VAR 0 3
80905: ARRAY
80906: PPUSH
80907: LD_INT 2
80909: PUSH
80910: LD_INT 30
80912: PUSH
80913: LD_INT 4
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 30
80922: PUSH
80923: LD_INT 5
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: LIST
80934: PPUSH
80935: CALL_OW 72
80939: ST_TO_ADDR
// if not tmp then
80940: LD_VAR 0 6
80944: NOT
80945: IFFALSE 80951
// exit ;
80947: POP
80948: POP
80949: GO 81031
// for j in tmp do
80951: LD_ADDR_VAR 0 4
80955: PUSH
80956: LD_VAR 0 6
80960: PUSH
80961: FOR_IN
80962: IFFALSE 81021
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80964: LD_ADDR_VAR 0 7
80968: PUSH
80969: LD_VAR 0 4
80973: PPUSH
80974: CALL_OW 313
80978: PPUSH
80979: LD_INT 25
80981: PUSH
80982: LD_INT 1
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PPUSH
80989: CALL_OW 72
80993: ST_TO_ADDR
// if units then
80994: LD_VAR 0 7
80998: IFFALSE 81019
// begin ComExitBuilding ( units [ 1 ] ) ;
81000: LD_VAR 0 7
81004: PUSH
81005: LD_INT 1
81007: ARRAY
81008: PPUSH
81009: CALL_OW 122
// exit ;
81013: POP
81014: POP
81015: POP
81016: POP
81017: GO 81031
// end ; end ;
81019: GO 80961
81021: POP
81022: POP
// end ; end ; exit ;
81023: POP
81024: POP
81025: GO 81031
// end ; end ;
81027: GO 80385
81029: POP
81030: POP
// end ;
81031: LD_VAR 0 2
81035: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81036: LD_INT 0
81038: PPUSH
81039: PPUSH
81040: PPUSH
81041: PPUSH
81042: PPUSH
81043: PPUSH
81044: PPUSH
// if not mc_bases or not skirmish then
81045: LD_EXP 23
81049: NOT
81050: PUSH
81051: LD_EXP 21
81055: NOT
81056: OR
81057: IFFALSE 81061
// exit ;
81059: GO 81326
// btype := GetBType ( building ) ;
81061: LD_ADDR_VAR 0 6
81065: PUSH
81066: LD_VAR 0 1
81070: PPUSH
81071: CALL_OW 266
81075: ST_TO_ADDR
// x := GetX ( building ) ;
81076: LD_ADDR_VAR 0 7
81080: PUSH
81081: LD_VAR 0 1
81085: PPUSH
81086: CALL_OW 250
81090: ST_TO_ADDR
// y := GetY ( building ) ;
81091: LD_ADDR_VAR 0 8
81095: PUSH
81096: LD_VAR 0 1
81100: PPUSH
81101: CALL_OW 251
81105: ST_TO_ADDR
// d := GetDir ( building ) ;
81106: LD_ADDR_VAR 0 9
81110: PUSH
81111: LD_VAR 0 1
81115: PPUSH
81116: CALL_OW 254
81120: ST_TO_ADDR
// for i = 1 to mc_bases do
81121: LD_ADDR_VAR 0 4
81125: PUSH
81126: DOUBLE
81127: LD_INT 1
81129: DEC
81130: ST_TO_ADDR
81131: LD_EXP 23
81135: PUSH
81136: FOR_TO
81137: IFFALSE 81324
// begin if not mc_build_list [ i ] then
81139: LD_EXP 28
81143: PUSH
81144: LD_VAR 0 4
81148: ARRAY
81149: NOT
81150: IFFALSE 81154
// continue ;
81152: GO 81136
// for j := 1 to mc_build_list [ i ] do
81154: LD_ADDR_VAR 0 5
81158: PUSH
81159: DOUBLE
81160: LD_INT 1
81162: DEC
81163: ST_TO_ADDR
81164: LD_EXP 28
81168: PUSH
81169: LD_VAR 0 4
81173: ARRAY
81174: PUSH
81175: FOR_TO
81176: IFFALSE 81320
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81178: LD_VAR 0 6
81182: PUSH
81183: LD_VAR 0 7
81187: PUSH
81188: LD_VAR 0 8
81192: PUSH
81193: LD_VAR 0 9
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: PPUSH
81204: LD_EXP 28
81208: PUSH
81209: LD_VAR 0 4
81213: ARRAY
81214: PUSH
81215: LD_VAR 0 5
81219: ARRAY
81220: PPUSH
81221: CALL 22195 0 2
81225: IFFALSE 81318
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81227: LD_ADDR_EXP 28
81231: PUSH
81232: LD_EXP 28
81236: PPUSH
81237: LD_VAR 0 4
81241: PPUSH
81242: LD_EXP 28
81246: PUSH
81247: LD_VAR 0 4
81251: ARRAY
81252: PPUSH
81253: LD_VAR 0 5
81257: PPUSH
81258: CALL_OW 3
81262: PPUSH
81263: CALL_OW 1
81267: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81268: LD_ADDR_EXP 30
81272: PUSH
81273: LD_EXP 30
81277: PPUSH
81278: LD_VAR 0 4
81282: PUSH
81283: LD_EXP 30
81287: PUSH
81288: LD_VAR 0 4
81292: ARRAY
81293: PUSH
81294: LD_INT 1
81296: PLUS
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PPUSH
81302: LD_VAR 0 1
81306: PPUSH
81307: CALL 16013 0 3
81311: ST_TO_ADDR
// exit ;
81312: POP
81313: POP
81314: POP
81315: POP
81316: GO 81326
// end ;
81318: GO 81175
81320: POP
81321: POP
// end ;
81322: GO 81136
81324: POP
81325: POP
// end ;
81326: LD_VAR 0 3
81330: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81331: LD_INT 0
81333: PPUSH
81334: PPUSH
81335: PPUSH
// if not mc_bases or not skirmish then
81336: LD_EXP 23
81340: NOT
81341: PUSH
81342: LD_EXP 21
81346: NOT
81347: OR
81348: IFFALSE 81352
// exit ;
81350: GO 81542
// for i = 1 to mc_bases do
81352: LD_ADDR_VAR 0 4
81356: PUSH
81357: DOUBLE
81358: LD_INT 1
81360: DEC
81361: ST_TO_ADDR
81362: LD_EXP 23
81366: PUSH
81367: FOR_TO
81368: IFFALSE 81455
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81370: LD_VAR 0 1
81374: PUSH
81375: LD_EXP 31
81379: PUSH
81380: LD_VAR 0 4
81384: ARRAY
81385: IN
81386: PUSH
81387: LD_VAR 0 1
81391: PUSH
81392: LD_EXP 32
81396: PUSH
81397: LD_VAR 0 4
81401: ARRAY
81402: IN
81403: NOT
81404: AND
81405: IFFALSE 81453
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81407: LD_ADDR_EXP 32
81411: PUSH
81412: LD_EXP 32
81416: PPUSH
81417: LD_VAR 0 4
81421: PUSH
81422: LD_EXP 32
81426: PUSH
81427: LD_VAR 0 4
81431: ARRAY
81432: PUSH
81433: LD_INT 1
81435: PLUS
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PPUSH
81441: LD_VAR 0 1
81445: PPUSH
81446: CALL 16013 0 3
81450: ST_TO_ADDR
// break ;
81451: GO 81455
// end ; end ;
81453: GO 81367
81455: POP
81456: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81457: LD_VAR 0 1
81461: PPUSH
81462: CALL_OW 257
81466: PUSH
81467: LD_EXP 49
81471: IN
81472: PUSH
81473: LD_VAR 0 1
81477: PPUSH
81478: CALL_OW 266
81482: PUSH
81483: LD_INT 5
81485: EQUAL
81486: AND
81487: PUSH
81488: LD_VAR 0 2
81492: PPUSH
81493: CALL_OW 110
81497: PUSH
81498: LD_INT 18
81500: NONEQUAL
81501: AND
81502: IFFALSE 81542
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81504: LD_VAR 0 2
81508: PPUSH
81509: CALL_OW 257
81513: PUSH
81514: LD_INT 5
81516: PUSH
81517: LD_INT 8
81519: PUSH
81520: LD_INT 9
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: LIST
81527: IN
81528: IFFALSE 81542
// SetClass ( unit , 1 ) ;
81530: LD_VAR 0 2
81534: PPUSH
81535: LD_INT 1
81537: PPUSH
81538: CALL_OW 336
// end ;
81542: LD_VAR 0 3
81546: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81547: LD_INT 0
81549: PPUSH
81550: PPUSH
// if not mc_bases or not skirmish then
81551: LD_EXP 23
81555: NOT
81556: PUSH
81557: LD_EXP 21
81561: NOT
81562: OR
81563: IFFALSE 81567
// exit ;
81565: GO 81683
// if GetLives ( abandoned_vehicle ) > 250 then
81567: LD_VAR 0 2
81571: PPUSH
81572: CALL_OW 256
81576: PUSH
81577: LD_INT 250
81579: GREATER
81580: IFFALSE 81584
// exit ;
81582: GO 81683
// for i = 1 to mc_bases do
81584: LD_ADDR_VAR 0 6
81588: PUSH
81589: DOUBLE
81590: LD_INT 1
81592: DEC
81593: ST_TO_ADDR
81594: LD_EXP 23
81598: PUSH
81599: FOR_TO
81600: IFFALSE 81681
// begin if driver in mc_bases [ i ] then
81602: LD_VAR 0 1
81606: PUSH
81607: LD_EXP 23
81611: PUSH
81612: LD_VAR 0 6
81616: ARRAY
81617: IN
81618: IFFALSE 81679
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81620: LD_VAR 0 1
81624: PPUSH
81625: LD_EXP 23
81629: PUSH
81630: LD_VAR 0 6
81634: ARRAY
81635: PPUSH
81636: LD_INT 2
81638: PUSH
81639: LD_INT 30
81641: PUSH
81642: LD_INT 0
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 30
81651: PUSH
81652: LD_INT 1
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: LIST
81663: PPUSH
81664: CALL_OW 72
81668: PUSH
81669: LD_INT 1
81671: ARRAY
81672: PPUSH
81673: CALL 48575 0 2
// break ;
81677: GO 81681
// end ; end ;
81679: GO 81599
81681: POP
81682: POP
// end ; end_of_file
81683: LD_VAR 0 5
81687: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
81688: LD_INT 0
81690: PPUSH
// ar_miner := 81 ;
81691: LD_ADDR_EXP 74
81695: PUSH
81696: LD_INT 81
81698: ST_TO_ADDR
// ar_crane := 88 ;
81699: LD_ADDR_EXP 73
81703: PUSH
81704: LD_INT 88
81706: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81707: LD_ADDR_EXP 68
81711: PUSH
81712: LD_INT 89
81714: ST_TO_ADDR
// us_hack := 99 ;
81715: LD_ADDR_EXP 69
81719: PUSH
81720: LD_INT 99
81722: ST_TO_ADDR
// us_artillery := 97 ;
81723: LD_ADDR_EXP 70
81727: PUSH
81728: LD_INT 97
81730: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81731: LD_ADDR_EXP 71
81735: PUSH
81736: LD_INT 91
81738: ST_TO_ADDR
// ar_mortar := 92 ;
81739: LD_ADDR_EXP 72
81743: PUSH
81744: LD_INT 92
81746: ST_TO_ADDR
// ru_radar := 98 ;
81747: LD_ADDR_EXP 67
81751: PUSH
81752: LD_INT 98
81754: ST_TO_ADDR
// tech_Artillery := 80 ;
81755: LD_ADDR_EXP 75
81759: PUSH
81760: LD_INT 80
81762: ST_TO_ADDR
// tech_RadMat := 81 ;
81763: LD_ADDR_EXP 76
81767: PUSH
81768: LD_INT 81
81770: ST_TO_ADDR
// tech_BasicTools := 82 ;
81771: LD_ADDR_EXP 77
81775: PUSH
81776: LD_INT 82
81778: ST_TO_ADDR
// tech_Cargo := 83 ;
81779: LD_ADDR_EXP 78
81783: PUSH
81784: LD_INT 83
81786: ST_TO_ADDR
// tech_Track := 84 ;
81787: LD_ADDR_EXP 79
81791: PUSH
81792: LD_INT 84
81794: ST_TO_ADDR
// tech_Crane := 85 ;
81795: LD_ADDR_EXP 80
81799: PUSH
81800: LD_INT 85
81802: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81803: LD_ADDR_EXP 81
81807: PUSH
81808: LD_INT 86
81810: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81811: LD_ADDR_EXP 82
81815: PUSH
81816: LD_INT 87
81818: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
81819: LD_ADDR_EXP 83
81823: PUSH
81824: LD_INT 88
81826: ST_TO_ADDR
// class_mastodont := 31 ;
81827: LD_ADDR_EXP 84
81831: PUSH
81832: LD_INT 31
81834: ST_TO_ADDR
// class_horse := 21 ;
81835: LD_ADDR_EXP 85
81839: PUSH
81840: LD_INT 21
81842: ST_TO_ADDR
// end ;
81843: LD_VAR 0 1
81847: RET
// every 1 do
81848: GO 81850
81850: DISABLE
// InitGlobalVariables ; end_of_file
81851: CALL 81688 0 0
81855: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81856: LD_INT 0
81858: PPUSH
81859: PPUSH
81860: PPUSH
81861: PPUSH
81862: PPUSH
81863: PPUSH
81864: PPUSH
81865: PPUSH
81866: PPUSH
81867: PPUSH
81868: PPUSH
81869: PPUSH
81870: PPUSH
81871: PPUSH
81872: PPUSH
81873: PPUSH
81874: PPUSH
81875: PPUSH
81876: PPUSH
81877: PPUSH
81878: PPUSH
81879: PPUSH
81880: PPUSH
81881: PPUSH
81882: PPUSH
81883: PPUSH
81884: PPUSH
81885: PPUSH
81886: PPUSH
81887: PPUSH
81888: PPUSH
81889: PPUSH
81890: PPUSH
81891: PPUSH
// if not list then
81892: LD_VAR 0 1
81896: NOT
81897: IFFALSE 81901
// exit ;
81899: GO 86560
// base := list [ 1 ] ;
81901: LD_ADDR_VAR 0 3
81905: PUSH
81906: LD_VAR 0 1
81910: PUSH
81911: LD_INT 1
81913: ARRAY
81914: ST_TO_ADDR
// group := list [ 2 ] ;
81915: LD_ADDR_VAR 0 4
81919: PUSH
81920: LD_VAR 0 1
81924: PUSH
81925: LD_INT 2
81927: ARRAY
81928: ST_TO_ADDR
// path := list [ 3 ] ;
81929: LD_ADDR_VAR 0 5
81933: PUSH
81934: LD_VAR 0 1
81938: PUSH
81939: LD_INT 3
81941: ARRAY
81942: ST_TO_ADDR
// flags := list [ 4 ] ;
81943: LD_ADDR_VAR 0 6
81947: PUSH
81948: LD_VAR 0 1
81952: PUSH
81953: LD_INT 4
81955: ARRAY
81956: ST_TO_ADDR
// mined := [ ] ;
81957: LD_ADDR_VAR 0 27
81961: PUSH
81962: EMPTY
81963: ST_TO_ADDR
// bombed := [ ] ;
81964: LD_ADDR_VAR 0 28
81968: PUSH
81969: EMPTY
81970: ST_TO_ADDR
// healers := [ ] ;
81971: LD_ADDR_VAR 0 31
81975: PUSH
81976: EMPTY
81977: ST_TO_ADDR
// to_heal := [ ] ;
81978: LD_ADDR_VAR 0 30
81982: PUSH
81983: EMPTY
81984: ST_TO_ADDR
// repairs := [ ] ;
81985: LD_ADDR_VAR 0 33
81989: PUSH
81990: EMPTY
81991: ST_TO_ADDR
// to_repair := [ ] ;
81992: LD_ADDR_VAR 0 32
81996: PUSH
81997: EMPTY
81998: ST_TO_ADDR
// if not group or not path then
81999: LD_VAR 0 4
82003: NOT
82004: PUSH
82005: LD_VAR 0 5
82009: NOT
82010: OR
82011: IFFALSE 82015
// exit ;
82013: GO 86560
// side := GetSide ( group [ 1 ] ) ;
82015: LD_ADDR_VAR 0 35
82019: PUSH
82020: LD_VAR 0 4
82024: PUSH
82025: LD_INT 1
82027: ARRAY
82028: PPUSH
82029: CALL_OW 255
82033: ST_TO_ADDR
// if flags then
82034: LD_VAR 0 6
82038: IFFALSE 82182
// begin f_ignore_area := flags [ 1 ] ;
82040: LD_ADDR_VAR 0 17
82044: PUSH
82045: LD_VAR 0 6
82049: PUSH
82050: LD_INT 1
82052: ARRAY
82053: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82054: LD_ADDR_VAR 0 18
82058: PUSH
82059: LD_VAR 0 6
82063: PUSH
82064: LD_INT 2
82066: ARRAY
82067: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82068: LD_ADDR_VAR 0 19
82072: PUSH
82073: LD_VAR 0 6
82077: PUSH
82078: LD_INT 3
82080: ARRAY
82081: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82082: LD_ADDR_VAR 0 20
82086: PUSH
82087: LD_VAR 0 6
82091: PUSH
82092: LD_INT 4
82094: ARRAY
82095: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82096: LD_ADDR_VAR 0 21
82100: PUSH
82101: LD_VAR 0 6
82105: PUSH
82106: LD_INT 5
82108: ARRAY
82109: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82110: LD_ADDR_VAR 0 22
82114: PUSH
82115: LD_VAR 0 6
82119: PUSH
82120: LD_INT 6
82122: ARRAY
82123: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82124: LD_ADDR_VAR 0 23
82128: PUSH
82129: LD_VAR 0 6
82133: PUSH
82134: LD_INT 7
82136: ARRAY
82137: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82138: LD_ADDR_VAR 0 24
82142: PUSH
82143: LD_VAR 0 6
82147: PUSH
82148: LD_INT 8
82150: ARRAY
82151: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82152: LD_ADDR_VAR 0 25
82156: PUSH
82157: LD_VAR 0 6
82161: PUSH
82162: LD_INT 9
82164: ARRAY
82165: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82166: LD_ADDR_VAR 0 26
82170: PUSH
82171: LD_VAR 0 6
82175: PUSH
82176: LD_INT 10
82178: ARRAY
82179: ST_TO_ADDR
// end else
82180: GO 82262
// begin f_ignore_area := false ;
82182: LD_ADDR_VAR 0 17
82186: PUSH
82187: LD_INT 0
82189: ST_TO_ADDR
// f_capture := false ;
82190: LD_ADDR_VAR 0 18
82194: PUSH
82195: LD_INT 0
82197: ST_TO_ADDR
// f_ignore_civ := false ;
82198: LD_ADDR_VAR 0 19
82202: PUSH
82203: LD_INT 0
82205: ST_TO_ADDR
// f_murder := false ;
82206: LD_ADDR_VAR 0 20
82210: PUSH
82211: LD_INT 0
82213: ST_TO_ADDR
// f_mines := false ;
82214: LD_ADDR_VAR 0 21
82218: PUSH
82219: LD_INT 0
82221: ST_TO_ADDR
// f_repair := false ;
82222: LD_ADDR_VAR 0 22
82226: PUSH
82227: LD_INT 0
82229: ST_TO_ADDR
// f_heal := false ;
82230: LD_ADDR_VAR 0 23
82234: PUSH
82235: LD_INT 0
82237: ST_TO_ADDR
// f_spacetime := false ;
82238: LD_ADDR_VAR 0 24
82242: PUSH
82243: LD_INT 0
82245: ST_TO_ADDR
// f_attack_depot := false ;
82246: LD_ADDR_VAR 0 25
82250: PUSH
82251: LD_INT 0
82253: ST_TO_ADDR
// f_crawl := false ;
82254: LD_ADDR_VAR 0 26
82258: PUSH
82259: LD_INT 0
82261: ST_TO_ADDR
// end ; if f_heal then
82262: LD_VAR 0 23
82266: IFFALSE 82293
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82268: LD_ADDR_VAR 0 31
82272: PUSH
82273: LD_VAR 0 4
82277: PPUSH
82278: LD_INT 25
82280: PUSH
82281: LD_INT 4
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PPUSH
82288: CALL_OW 72
82292: ST_TO_ADDR
// if f_repair then
82293: LD_VAR 0 22
82297: IFFALSE 82324
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82299: LD_ADDR_VAR 0 33
82303: PUSH
82304: LD_VAR 0 4
82308: PPUSH
82309: LD_INT 25
82311: PUSH
82312: LD_INT 3
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PPUSH
82319: CALL_OW 72
82323: ST_TO_ADDR
// units_path := [ ] ;
82324: LD_ADDR_VAR 0 16
82328: PUSH
82329: EMPTY
82330: ST_TO_ADDR
// for i = 1 to group do
82331: LD_ADDR_VAR 0 7
82335: PUSH
82336: DOUBLE
82337: LD_INT 1
82339: DEC
82340: ST_TO_ADDR
82341: LD_VAR 0 4
82345: PUSH
82346: FOR_TO
82347: IFFALSE 82376
// units_path := Replace ( units_path , i , path ) ;
82349: LD_ADDR_VAR 0 16
82353: PUSH
82354: LD_VAR 0 16
82358: PPUSH
82359: LD_VAR 0 7
82363: PPUSH
82364: LD_VAR 0 5
82368: PPUSH
82369: CALL_OW 1
82373: ST_TO_ADDR
82374: GO 82346
82376: POP
82377: POP
// repeat for i = group downto 1 do
82378: LD_ADDR_VAR 0 7
82382: PUSH
82383: DOUBLE
82384: LD_VAR 0 4
82388: INC
82389: ST_TO_ADDR
82390: LD_INT 1
82392: PUSH
82393: FOR_DOWNTO
82394: IFFALSE 86516
// begin wait ( 5 ) ;
82396: LD_INT 5
82398: PPUSH
82399: CALL_OW 67
// tmp := [ ] ;
82403: LD_ADDR_VAR 0 14
82407: PUSH
82408: EMPTY
82409: ST_TO_ADDR
// attacking := false ;
82410: LD_ADDR_VAR 0 29
82414: PUSH
82415: LD_INT 0
82417: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82418: LD_VAR 0 4
82422: PUSH
82423: LD_VAR 0 7
82427: ARRAY
82428: PPUSH
82429: CALL_OW 301
82433: PUSH
82434: LD_VAR 0 4
82438: PUSH
82439: LD_VAR 0 7
82443: ARRAY
82444: NOT
82445: OR
82446: IFFALSE 82555
// begin if GetType ( group [ i ] ) = unit_human then
82448: LD_VAR 0 4
82452: PUSH
82453: LD_VAR 0 7
82457: ARRAY
82458: PPUSH
82459: CALL_OW 247
82463: PUSH
82464: LD_INT 1
82466: EQUAL
82467: IFFALSE 82513
// begin to_heal := to_heal diff group [ i ] ;
82469: LD_ADDR_VAR 0 30
82473: PUSH
82474: LD_VAR 0 30
82478: PUSH
82479: LD_VAR 0 4
82483: PUSH
82484: LD_VAR 0 7
82488: ARRAY
82489: DIFF
82490: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82491: LD_ADDR_VAR 0 31
82495: PUSH
82496: LD_VAR 0 31
82500: PUSH
82501: LD_VAR 0 4
82505: PUSH
82506: LD_VAR 0 7
82510: ARRAY
82511: DIFF
82512: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82513: LD_ADDR_VAR 0 4
82517: PUSH
82518: LD_VAR 0 4
82522: PPUSH
82523: LD_VAR 0 7
82527: PPUSH
82528: CALL_OW 3
82532: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82533: LD_ADDR_VAR 0 16
82537: PUSH
82538: LD_VAR 0 16
82542: PPUSH
82543: LD_VAR 0 7
82547: PPUSH
82548: CALL_OW 3
82552: ST_TO_ADDR
// continue ;
82553: GO 82393
// end ; if f_repair then
82555: LD_VAR 0 22
82559: IFFALSE 83048
// begin if GetType ( group [ i ] ) = unit_vehicle then
82561: LD_VAR 0 4
82565: PUSH
82566: LD_VAR 0 7
82570: ARRAY
82571: PPUSH
82572: CALL_OW 247
82576: PUSH
82577: LD_INT 2
82579: EQUAL
82580: IFFALSE 82770
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82582: LD_VAR 0 4
82586: PUSH
82587: LD_VAR 0 7
82591: ARRAY
82592: PPUSH
82593: CALL_OW 256
82597: PUSH
82598: LD_INT 700
82600: LESS
82601: PUSH
82602: LD_VAR 0 4
82606: PUSH
82607: LD_VAR 0 7
82611: ARRAY
82612: PUSH
82613: LD_VAR 0 32
82617: IN
82618: NOT
82619: AND
82620: IFFALSE 82644
// to_repair := to_repair union group [ i ] ;
82622: LD_ADDR_VAR 0 32
82626: PUSH
82627: LD_VAR 0 32
82631: PUSH
82632: LD_VAR 0 4
82636: PUSH
82637: LD_VAR 0 7
82641: ARRAY
82642: UNION
82643: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82644: LD_VAR 0 4
82648: PUSH
82649: LD_VAR 0 7
82653: ARRAY
82654: PPUSH
82655: CALL_OW 256
82659: PUSH
82660: LD_INT 1000
82662: EQUAL
82663: PUSH
82664: LD_VAR 0 4
82668: PUSH
82669: LD_VAR 0 7
82673: ARRAY
82674: PUSH
82675: LD_VAR 0 32
82679: IN
82680: AND
82681: IFFALSE 82705
// to_repair := to_repair diff group [ i ] ;
82683: LD_ADDR_VAR 0 32
82687: PUSH
82688: LD_VAR 0 32
82692: PUSH
82693: LD_VAR 0 4
82697: PUSH
82698: LD_VAR 0 7
82702: ARRAY
82703: DIFF
82704: ST_TO_ADDR
// if group [ i ] in to_repair then
82705: LD_VAR 0 4
82709: PUSH
82710: LD_VAR 0 7
82714: ARRAY
82715: PUSH
82716: LD_VAR 0 32
82720: IN
82721: IFFALSE 82768
// begin if not IsInArea ( group [ i ] , f_repair ) then
82723: LD_VAR 0 4
82727: PUSH
82728: LD_VAR 0 7
82732: ARRAY
82733: PPUSH
82734: LD_VAR 0 22
82738: PPUSH
82739: CALL_OW 308
82743: NOT
82744: IFFALSE 82766
// ComMoveToArea ( group [ i ] , f_repair ) ;
82746: LD_VAR 0 4
82750: PUSH
82751: LD_VAR 0 7
82755: ARRAY
82756: PPUSH
82757: LD_VAR 0 22
82761: PPUSH
82762: CALL_OW 113
// continue ;
82766: GO 82393
// end ; end else
82768: GO 83048
// if group [ i ] in repairs then
82770: LD_VAR 0 4
82774: PUSH
82775: LD_VAR 0 7
82779: ARRAY
82780: PUSH
82781: LD_VAR 0 33
82785: IN
82786: IFFALSE 83048
// begin if IsInUnit ( group [ i ] ) then
82788: LD_VAR 0 4
82792: PUSH
82793: LD_VAR 0 7
82797: ARRAY
82798: PPUSH
82799: CALL_OW 310
82803: IFFALSE 82871
// begin z := IsInUnit ( group [ i ] ) ;
82805: LD_ADDR_VAR 0 13
82809: PUSH
82810: LD_VAR 0 4
82814: PUSH
82815: LD_VAR 0 7
82819: ARRAY
82820: PPUSH
82821: CALL_OW 310
82825: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82826: LD_VAR 0 13
82830: PUSH
82831: LD_VAR 0 32
82835: IN
82836: PUSH
82837: LD_VAR 0 13
82841: PPUSH
82842: LD_VAR 0 22
82846: PPUSH
82847: CALL_OW 308
82851: AND
82852: IFFALSE 82869
// ComExitVehicle ( group [ i ] ) ;
82854: LD_VAR 0 4
82858: PUSH
82859: LD_VAR 0 7
82863: ARRAY
82864: PPUSH
82865: CALL_OW 121
// end else
82869: GO 83048
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82871: LD_ADDR_VAR 0 13
82875: PUSH
82876: LD_VAR 0 4
82880: PPUSH
82881: LD_INT 95
82883: PUSH
82884: LD_VAR 0 22
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 58
82895: PUSH
82896: EMPTY
82897: LIST
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PPUSH
82903: CALL_OW 72
82907: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82908: LD_VAR 0 4
82912: PUSH
82913: LD_VAR 0 7
82917: ARRAY
82918: PPUSH
82919: CALL_OW 314
82923: NOT
82924: IFFALSE 83046
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82926: LD_ADDR_VAR 0 10
82930: PUSH
82931: LD_VAR 0 13
82935: PPUSH
82936: LD_VAR 0 4
82940: PUSH
82941: LD_VAR 0 7
82945: ARRAY
82946: PPUSH
82947: CALL_OW 74
82951: ST_TO_ADDR
// if not x then
82952: LD_VAR 0 10
82956: NOT
82957: IFFALSE 82961
// continue ;
82959: GO 82393
// if GetLives ( x ) < 1000 then
82961: LD_VAR 0 10
82965: PPUSH
82966: CALL_OW 256
82970: PUSH
82971: LD_INT 1000
82973: LESS
82974: IFFALSE 82998
// ComRepairVehicle ( group [ i ] , x ) else
82976: LD_VAR 0 4
82980: PUSH
82981: LD_VAR 0 7
82985: ARRAY
82986: PPUSH
82987: LD_VAR 0 10
82991: PPUSH
82992: CALL_OW 129
82996: GO 83046
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82998: LD_VAR 0 23
83002: PUSH
83003: LD_VAR 0 4
83007: PUSH
83008: LD_VAR 0 7
83012: ARRAY
83013: PPUSH
83014: CALL_OW 256
83018: PUSH
83019: LD_INT 1000
83021: LESS
83022: AND
83023: NOT
83024: IFFALSE 83046
// ComEnterUnit ( group [ i ] , x ) ;
83026: LD_VAR 0 4
83030: PUSH
83031: LD_VAR 0 7
83035: ARRAY
83036: PPUSH
83037: LD_VAR 0 10
83041: PPUSH
83042: CALL_OW 120
// end ; continue ;
83046: GO 82393
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83048: LD_VAR 0 23
83052: PUSH
83053: LD_VAR 0 4
83057: PUSH
83058: LD_VAR 0 7
83062: ARRAY
83063: PPUSH
83064: CALL_OW 247
83068: PUSH
83069: LD_INT 1
83071: EQUAL
83072: AND
83073: IFFALSE 83551
// begin if group [ i ] in healers then
83075: LD_VAR 0 4
83079: PUSH
83080: LD_VAR 0 7
83084: ARRAY
83085: PUSH
83086: LD_VAR 0 31
83090: IN
83091: IFFALSE 83364
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83093: LD_VAR 0 4
83097: PUSH
83098: LD_VAR 0 7
83102: ARRAY
83103: PPUSH
83104: LD_VAR 0 23
83108: PPUSH
83109: CALL_OW 308
83113: NOT
83114: PUSH
83115: LD_VAR 0 4
83119: PUSH
83120: LD_VAR 0 7
83124: ARRAY
83125: PPUSH
83126: CALL_OW 314
83130: NOT
83131: AND
83132: IFFALSE 83156
// ComMoveToArea ( group [ i ] , f_heal ) else
83134: LD_VAR 0 4
83138: PUSH
83139: LD_VAR 0 7
83143: ARRAY
83144: PPUSH
83145: LD_VAR 0 23
83149: PPUSH
83150: CALL_OW 113
83154: GO 83362
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83156: LD_VAR 0 4
83160: PUSH
83161: LD_VAR 0 7
83165: ARRAY
83166: PPUSH
83167: CALL 45093 0 1
83171: PPUSH
83172: CALL_OW 256
83176: PUSH
83177: LD_INT 1000
83179: EQUAL
83180: IFFALSE 83199
// ComStop ( group [ i ] ) else
83182: LD_VAR 0 4
83186: PUSH
83187: LD_VAR 0 7
83191: ARRAY
83192: PPUSH
83193: CALL_OW 141
83197: GO 83362
// if not HasTask ( group [ i ] ) and to_heal then
83199: LD_VAR 0 4
83203: PUSH
83204: LD_VAR 0 7
83208: ARRAY
83209: PPUSH
83210: CALL_OW 314
83214: NOT
83215: PUSH
83216: LD_VAR 0 30
83220: AND
83221: IFFALSE 83362
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83223: LD_ADDR_VAR 0 13
83227: PUSH
83228: LD_VAR 0 30
83232: PPUSH
83233: LD_INT 3
83235: PUSH
83236: LD_INT 54
83238: PUSH
83239: EMPTY
83240: LIST
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PPUSH
83246: CALL_OW 72
83250: PPUSH
83251: LD_VAR 0 4
83255: PUSH
83256: LD_VAR 0 7
83260: ARRAY
83261: PPUSH
83262: CALL_OW 74
83266: ST_TO_ADDR
// if z then
83267: LD_VAR 0 13
83271: IFFALSE 83362
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83273: LD_INT 91
83275: PUSH
83276: LD_VAR 0 13
83280: PUSH
83281: LD_INT 10
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 81
83291: PUSH
83292: LD_VAR 0 13
83296: PPUSH
83297: CALL_OW 255
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: EMPTY
83307: LIST
83308: LIST
83309: PPUSH
83310: CALL_OW 69
83314: PUSH
83315: LD_INT 0
83317: EQUAL
83318: IFFALSE 83342
// ComHeal ( group [ i ] , z ) else
83320: LD_VAR 0 4
83324: PUSH
83325: LD_VAR 0 7
83329: ARRAY
83330: PPUSH
83331: LD_VAR 0 13
83335: PPUSH
83336: CALL_OW 128
83340: GO 83362
// ComMoveToArea ( group [ i ] , f_heal ) ;
83342: LD_VAR 0 4
83346: PUSH
83347: LD_VAR 0 7
83351: ARRAY
83352: PPUSH
83353: LD_VAR 0 23
83357: PPUSH
83358: CALL_OW 113
// end ; continue ;
83362: GO 82393
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83364: LD_VAR 0 4
83368: PUSH
83369: LD_VAR 0 7
83373: ARRAY
83374: PPUSH
83375: CALL_OW 256
83379: PUSH
83380: LD_INT 700
83382: LESS
83383: PUSH
83384: LD_VAR 0 4
83388: PUSH
83389: LD_VAR 0 7
83393: ARRAY
83394: PUSH
83395: LD_VAR 0 30
83399: IN
83400: NOT
83401: AND
83402: IFFALSE 83426
// to_heal := to_heal union group [ i ] ;
83404: LD_ADDR_VAR 0 30
83408: PUSH
83409: LD_VAR 0 30
83413: PUSH
83414: LD_VAR 0 4
83418: PUSH
83419: LD_VAR 0 7
83423: ARRAY
83424: UNION
83425: ST_TO_ADDR
// if group [ i ] in to_heal then
83426: LD_VAR 0 4
83430: PUSH
83431: LD_VAR 0 7
83435: ARRAY
83436: PUSH
83437: LD_VAR 0 30
83441: IN
83442: IFFALSE 83551
// begin if GetLives ( group [ i ] ) = 1000 then
83444: LD_VAR 0 4
83448: PUSH
83449: LD_VAR 0 7
83453: ARRAY
83454: PPUSH
83455: CALL_OW 256
83459: PUSH
83460: LD_INT 1000
83462: EQUAL
83463: IFFALSE 83489
// to_heal := to_heal diff group [ i ] else
83465: LD_ADDR_VAR 0 30
83469: PUSH
83470: LD_VAR 0 30
83474: PUSH
83475: LD_VAR 0 4
83479: PUSH
83480: LD_VAR 0 7
83484: ARRAY
83485: DIFF
83486: ST_TO_ADDR
83487: GO 83551
// begin if not IsInArea ( group [ i ] , to_heal ) then
83489: LD_VAR 0 4
83493: PUSH
83494: LD_VAR 0 7
83498: ARRAY
83499: PPUSH
83500: LD_VAR 0 30
83504: PPUSH
83505: CALL_OW 308
83509: NOT
83510: IFFALSE 83534
// ComMoveToArea ( group [ i ] , f_heal ) else
83512: LD_VAR 0 4
83516: PUSH
83517: LD_VAR 0 7
83521: ARRAY
83522: PPUSH
83523: LD_VAR 0 23
83527: PPUSH
83528: CALL_OW 113
83532: GO 83549
// ComHold ( group [ i ] ) ;
83534: LD_VAR 0 4
83538: PUSH
83539: LD_VAR 0 7
83543: ARRAY
83544: PPUSH
83545: CALL_OW 140
// continue ;
83549: GO 82393
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83551: LD_VAR 0 4
83555: PUSH
83556: LD_VAR 0 7
83560: ARRAY
83561: PPUSH
83562: LD_INT 10
83564: PPUSH
83565: CALL 43513 0 2
83569: NOT
83570: PUSH
83571: LD_VAR 0 16
83575: PUSH
83576: LD_VAR 0 7
83580: ARRAY
83581: PUSH
83582: EMPTY
83583: EQUAL
83584: NOT
83585: AND
83586: IFFALSE 83852
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83588: LD_VAR 0 4
83592: PUSH
83593: LD_VAR 0 7
83597: ARRAY
83598: PPUSH
83599: CALL_OW 262
83603: PUSH
83604: LD_INT 1
83606: PUSH
83607: LD_INT 2
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: IN
83614: IFFALSE 83655
// if GetFuel ( group [ i ] ) < 10 then
83616: LD_VAR 0 4
83620: PUSH
83621: LD_VAR 0 7
83625: ARRAY
83626: PPUSH
83627: CALL_OW 261
83631: PUSH
83632: LD_INT 10
83634: LESS
83635: IFFALSE 83655
// SetFuel ( group [ i ] , 12 ) ;
83637: LD_VAR 0 4
83641: PUSH
83642: LD_VAR 0 7
83646: ARRAY
83647: PPUSH
83648: LD_INT 12
83650: PPUSH
83651: CALL_OW 240
// if units_path [ i ] then
83655: LD_VAR 0 16
83659: PUSH
83660: LD_VAR 0 7
83664: ARRAY
83665: IFFALSE 83850
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83667: LD_VAR 0 4
83671: PUSH
83672: LD_VAR 0 7
83676: ARRAY
83677: PPUSH
83678: LD_VAR 0 16
83682: PUSH
83683: LD_VAR 0 7
83687: ARRAY
83688: PUSH
83689: LD_INT 1
83691: ARRAY
83692: PUSH
83693: LD_INT 1
83695: ARRAY
83696: PPUSH
83697: LD_VAR 0 16
83701: PUSH
83702: LD_VAR 0 7
83706: ARRAY
83707: PUSH
83708: LD_INT 1
83710: ARRAY
83711: PUSH
83712: LD_INT 2
83714: ARRAY
83715: PPUSH
83716: CALL_OW 297
83720: PUSH
83721: LD_INT 6
83723: GREATER
83724: IFFALSE 83799
// begin if not HasTask ( group [ i ] ) then
83726: LD_VAR 0 4
83730: PUSH
83731: LD_VAR 0 7
83735: ARRAY
83736: PPUSH
83737: CALL_OW 314
83741: NOT
83742: IFFALSE 83797
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83744: LD_VAR 0 4
83748: PUSH
83749: LD_VAR 0 7
83753: ARRAY
83754: PPUSH
83755: LD_VAR 0 16
83759: PUSH
83760: LD_VAR 0 7
83764: ARRAY
83765: PUSH
83766: LD_INT 1
83768: ARRAY
83769: PUSH
83770: LD_INT 1
83772: ARRAY
83773: PPUSH
83774: LD_VAR 0 16
83778: PUSH
83779: LD_VAR 0 7
83783: ARRAY
83784: PUSH
83785: LD_INT 1
83787: ARRAY
83788: PUSH
83789: LD_INT 2
83791: ARRAY
83792: PPUSH
83793: CALL_OW 114
// end else
83797: GO 83850
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83799: LD_ADDR_VAR 0 15
83803: PUSH
83804: LD_VAR 0 16
83808: PUSH
83809: LD_VAR 0 7
83813: ARRAY
83814: PPUSH
83815: LD_INT 1
83817: PPUSH
83818: CALL_OW 3
83822: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83823: LD_ADDR_VAR 0 16
83827: PUSH
83828: LD_VAR 0 16
83832: PPUSH
83833: LD_VAR 0 7
83837: PPUSH
83838: LD_VAR 0 15
83842: PPUSH
83843: CALL_OW 1
83847: ST_TO_ADDR
// continue ;
83848: GO 82393
// end ; end ; end else
83850: GO 86514
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83852: LD_ADDR_VAR 0 14
83856: PUSH
83857: LD_INT 81
83859: PUSH
83860: LD_VAR 0 4
83864: PUSH
83865: LD_VAR 0 7
83869: ARRAY
83870: PPUSH
83871: CALL_OW 255
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PPUSH
83880: CALL_OW 69
83884: ST_TO_ADDR
// if not tmp then
83885: LD_VAR 0 14
83889: NOT
83890: IFFALSE 83894
// continue ;
83892: GO 82393
// if f_ignore_area then
83894: LD_VAR 0 17
83898: IFFALSE 83986
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83900: LD_ADDR_VAR 0 15
83904: PUSH
83905: LD_VAR 0 14
83909: PPUSH
83910: LD_INT 3
83912: PUSH
83913: LD_INT 92
83915: PUSH
83916: LD_VAR 0 17
83920: PUSH
83921: LD_INT 1
83923: ARRAY
83924: PUSH
83925: LD_VAR 0 17
83929: PUSH
83930: LD_INT 2
83932: ARRAY
83933: PUSH
83934: LD_VAR 0 17
83938: PUSH
83939: LD_INT 3
83941: ARRAY
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PPUSH
83953: CALL_OW 72
83957: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83958: LD_VAR 0 14
83962: PUSH
83963: LD_VAR 0 15
83967: DIFF
83968: IFFALSE 83986
// tmp := tmp diff tmp2 ;
83970: LD_ADDR_VAR 0 14
83974: PUSH
83975: LD_VAR 0 14
83979: PUSH
83980: LD_VAR 0 15
83984: DIFF
83985: ST_TO_ADDR
// end ; if not f_murder then
83986: LD_VAR 0 20
83990: NOT
83991: IFFALSE 84049
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83993: LD_ADDR_VAR 0 15
83997: PUSH
83998: LD_VAR 0 14
84002: PPUSH
84003: LD_INT 3
84005: PUSH
84006: LD_INT 50
84008: PUSH
84009: EMPTY
84010: LIST
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PPUSH
84016: CALL_OW 72
84020: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84021: LD_VAR 0 14
84025: PUSH
84026: LD_VAR 0 15
84030: DIFF
84031: IFFALSE 84049
// tmp := tmp diff tmp2 ;
84033: LD_ADDR_VAR 0 14
84037: PUSH
84038: LD_VAR 0 14
84042: PUSH
84043: LD_VAR 0 15
84047: DIFF
84048: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84049: LD_ADDR_VAR 0 14
84053: PUSH
84054: LD_VAR 0 4
84058: PUSH
84059: LD_VAR 0 7
84063: ARRAY
84064: PPUSH
84065: LD_VAR 0 14
84069: PPUSH
84070: LD_INT 1
84072: PPUSH
84073: LD_INT 1
84075: PPUSH
84076: CALL 16448 0 4
84080: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84081: LD_VAR 0 4
84085: PUSH
84086: LD_VAR 0 7
84090: ARRAY
84091: PPUSH
84092: CALL_OW 257
84096: PUSH
84097: LD_INT 1
84099: EQUAL
84100: IFFALSE 84548
// begin if WantPlant ( group [ i ] ) then
84102: LD_VAR 0 4
84106: PUSH
84107: LD_VAR 0 7
84111: ARRAY
84112: PPUSH
84113: CALL 15949 0 1
84117: IFFALSE 84121
// continue ;
84119: GO 82393
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84121: LD_VAR 0 18
84125: PUSH
84126: LD_VAR 0 4
84130: PUSH
84131: LD_VAR 0 7
84135: ARRAY
84136: PPUSH
84137: CALL_OW 310
84141: NOT
84142: AND
84143: PUSH
84144: LD_VAR 0 14
84148: PUSH
84149: LD_INT 1
84151: ARRAY
84152: PUSH
84153: LD_VAR 0 14
84157: PPUSH
84158: LD_INT 21
84160: PUSH
84161: LD_INT 2
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 58
84170: PUSH
84171: EMPTY
84172: LIST
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PPUSH
84178: CALL_OW 72
84182: IN
84183: AND
84184: IFFALSE 84220
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84186: LD_VAR 0 4
84190: PUSH
84191: LD_VAR 0 7
84195: ARRAY
84196: PPUSH
84197: LD_VAR 0 14
84201: PUSH
84202: LD_INT 1
84204: ARRAY
84205: PPUSH
84206: CALL_OW 120
// attacking := true ;
84210: LD_ADDR_VAR 0 29
84214: PUSH
84215: LD_INT 1
84217: ST_TO_ADDR
// continue ;
84218: GO 82393
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84220: LD_VAR 0 26
84224: PUSH
84225: LD_VAR 0 4
84229: PUSH
84230: LD_VAR 0 7
84234: ARRAY
84235: PPUSH
84236: CALL_OW 257
84240: PUSH
84241: LD_INT 1
84243: EQUAL
84244: AND
84245: PUSH
84246: LD_VAR 0 4
84250: PUSH
84251: LD_VAR 0 7
84255: ARRAY
84256: PPUSH
84257: CALL_OW 256
84261: PUSH
84262: LD_INT 800
84264: LESS
84265: AND
84266: PUSH
84267: LD_VAR 0 4
84271: PUSH
84272: LD_VAR 0 7
84276: ARRAY
84277: PPUSH
84278: CALL_OW 318
84282: NOT
84283: AND
84284: IFFALSE 84301
// ComCrawl ( group [ i ] ) ;
84286: LD_VAR 0 4
84290: PUSH
84291: LD_VAR 0 7
84295: ARRAY
84296: PPUSH
84297: CALL_OW 137
// if f_mines then
84301: LD_VAR 0 21
84305: IFFALSE 84548
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84307: LD_VAR 0 14
84311: PUSH
84312: LD_INT 1
84314: ARRAY
84315: PPUSH
84316: CALL_OW 247
84320: PUSH
84321: LD_INT 3
84323: EQUAL
84324: PUSH
84325: LD_VAR 0 14
84329: PUSH
84330: LD_INT 1
84332: ARRAY
84333: PUSH
84334: LD_VAR 0 27
84338: IN
84339: NOT
84340: AND
84341: IFFALSE 84548
// begin x := GetX ( tmp [ 1 ] ) ;
84343: LD_ADDR_VAR 0 10
84347: PUSH
84348: LD_VAR 0 14
84352: PUSH
84353: LD_INT 1
84355: ARRAY
84356: PPUSH
84357: CALL_OW 250
84361: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84362: LD_ADDR_VAR 0 11
84366: PUSH
84367: LD_VAR 0 14
84371: PUSH
84372: LD_INT 1
84374: ARRAY
84375: PPUSH
84376: CALL_OW 251
84380: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84381: LD_ADDR_VAR 0 12
84385: PUSH
84386: LD_VAR 0 4
84390: PUSH
84391: LD_VAR 0 7
84395: ARRAY
84396: PPUSH
84397: CALL 43598 0 1
84401: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84402: LD_VAR 0 4
84406: PUSH
84407: LD_VAR 0 7
84411: ARRAY
84412: PPUSH
84413: LD_VAR 0 10
84417: PPUSH
84418: LD_VAR 0 11
84422: PPUSH
84423: LD_VAR 0 14
84427: PUSH
84428: LD_INT 1
84430: ARRAY
84431: PPUSH
84432: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84436: LD_VAR 0 4
84440: PUSH
84441: LD_VAR 0 7
84445: ARRAY
84446: PPUSH
84447: LD_VAR 0 10
84451: PPUSH
84452: LD_VAR 0 12
84456: PPUSH
84457: LD_INT 7
84459: PPUSH
84460: CALL_OW 272
84464: PPUSH
84465: LD_VAR 0 11
84469: PPUSH
84470: LD_VAR 0 12
84474: PPUSH
84475: LD_INT 7
84477: PPUSH
84478: CALL_OW 273
84482: PPUSH
84483: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84487: LD_VAR 0 4
84491: PUSH
84492: LD_VAR 0 7
84496: ARRAY
84497: PPUSH
84498: LD_INT 71
84500: PPUSH
84501: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84505: LD_ADDR_VAR 0 27
84509: PUSH
84510: LD_VAR 0 27
84514: PPUSH
84515: LD_VAR 0 27
84519: PUSH
84520: LD_INT 1
84522: PLUS
84523: PPUSH
84524: LD_VAR 0 14
84528: PUSH
84529: LD_INT 1
84531: ARRAY
84532: PPUSH
84533: CALL_OW 1
84537: ST_TO_ADDR
// attacking := true ;
84538: LD_ADDR_VAR 0 29
84542: PUSH
84543: LD_INT 1
84545: ST_TO_ADDR
// continue ;
84546: GO 82393
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84548: LD_VAR 0 4
84552: PUSH
84553: LD_VAR 0 7
84557: ARRAY
84558: PPUSH
84559: CALL_OW 257
84563: PUSH
84564: LD_INT 17
84566: EQUAL
84567: PUSH
84568: LD_VAR 0 4
84572: PUSH
84573: LD_VAR 0 7
84577: ARRAY
84578: PPUSH
84579: CALL_OW 110
84583: PUSH
84584: LD_INT 71
84586: EQUAL
84587: NOT
84588: AND
84589: IFFALSE 84735
// begin attacking := false ;
84591: LD_ADDR_VAR 0 29
84595: PUSH
84596: LD_INT 0
84598: ST_TO_ADDR
// k := 5 ;
84599: LD_ADDR_VAR 0 9
84603: PUSH
84604: LD_INT 5
84606: ST_TO_ADDR
// if tmp < k then
84607: LD_VAR 0 14
84611: PUSH
84612: LD_VAR 0 9
84616: LESS
84617: IFFALSE 84629
// k := tmp ;
84619: LD_ADDR_VAR 0 9
84623: PUSH
84624: LD_VAR 0 14
84628: ST_TO_ADDR
// for j = 1 to k do
84629: LD_ADDR_VAR 0 8
84633: PUSH
84634: DOUBLE
84635: LD_INT 1
84637: DEC
84638: ST_TO_ADDR
84639: LD_VAR 0 9
84643: PUSH
84644: FOR_TO
84645: IFFALSE 84733
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84647: LD_VAR 0 14
84651: PUSH
84652: LD_VAR 0 8
84656: ARRAY
84657: PUSH
84658: LD_VAR 0 14
84662: PPUSH
84663: LD_INT 58
84665: PUSH
84666: EMPTY
84667: LIST
84668: PPUSH
84669: CALL_OW 72
84673: IN
84674: NOT
84675: IFFALSE 84731
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84677: LD_VAR 0 4
84681: PUSH
84682: LD_VAR 0 7
84686: ARRAY
84687: PPUSH
84688: LD_VAR 0 14
84692: PUSH
84693: LD_VAR 0 8
84697: ARRAY
84698: PPUSH
84699: CALL_OW 115
// attacking := true ;
84703: LD_ADDR_VAR 0 29
84707: PUSH
84708: LD_INT 1
84710: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84711: LD_VAR 0 4
84715: PUSH
84716: LD_VAR 0 7
84720: ARRAY
84721: PPUSH
84722: LD_INT 71
84724: PPUSH
84725: CALL_OW 109
// continue ;
84729: GO 84644
// end ; end ;
84731: GO 84644
84733: POP
84734: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84735: LD_VAR 0 4
84739: PUSH
84740: LD_VAR 0 7
84744: ARRAY
84745: PPUSH
84746: CALL_OW 257
84750: PUSH
84751: LD_INT 8
84753: EQUAL
84754: PUSH
84755: LD_VAR 0 4
84759: PUSH
84760: LD_VAR 0 7
84764: ARRAY
84765: PPUSH
84766: CALL_OW 264
84770: PUSH
84771: LD_INT 28
84773: PUSH
84774: LD_INT 45
84776: PUSH
84777: LD_INT 7
84779: PUSH
84780: LD_INT 47
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: IN
84789: OR
84790: IFFALSE 85046
// begin attacking := false ;
84792: LD_ADDR_VAR 0 29
84796: PUSH
84797: LD_INT 0
84799: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84800: LD_VAR 0 14
84804: PUSH
84805: LD_INT 1
84807: ARRAY
84808: PPUSH
84809: CALL_OW 266
84813: PUSH
84814: LD_INT 32
84816: PUSH
84817: LD_INT 31
84819: PUSH
84820: LD_INT 33
84822: PUSH
84823: LD_INT 4
84825: PUSH
84826: LD_INT 5
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: IN
84836: IFFALSE 85022
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84838: LD_ADDR_VAR 0 9
84842: PUSH
84843: LD_VAR 0 14
84847: PUSH
84848: LD_INT 1
84850: ARRAY
84851: PPUSH
84852: CALL_OW 266
84856: PPUSH
84857: LD_VAR 0 14
84861: PUSH
84862: LD_INT 1
84864: ARRAY
84865: PPUSH
84866: CALL_OW 250
84870: PPUSH
84871: LD_VAR 0 14
84875: PUSH
84876: LD_INT 1
84878: ARRAY
84879: PPUSH
84880: CALL_OW 251
84884: PPUSH
84885: LD_VAR 0 14
84889: PUSH
84890: LD_INT 1
84892: ARRAY
84893: PPUSH
84894: CALL_OW 254
84898: PPUSH
84899: LD_VAR 0 14
84903: PUSH
84904: LD_INT 1
84906: ARRAY
84907: PPUSH
84908: CALL_OW 248
84912: PPUSH
84913: LD_INT 0
84915: PPUSH
84916: CALL 24968 0 6
84920: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84921: LD_ADDR_VAR 0 8
84925: PUSH
84926: LD_VAR 0 4
84930: PUSH
84931: LD_VAR 0 7
84935: ARRAY
84936: PPUSH
84937: LD_VAR 0 9
84941: PPUSH
84942: CALL 43638 0 2
84946: ST_TO_ADDR
// if j then
84947: LD_VAR 0 8
84951: IFFALSE 85020
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84953: LD_VAR 0 8
84957: PUSH
84958: LD_INT 1
84960: ARRAY
84961: PPUSH
84962: LD_VAR 0 8
84966: PUSH
84967: LD_INT 2
84969: ARRAY
84970: PPUSH
84971: CALL_OW 488
84975: IFFALSE 85020
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84977: LD_VAR 0 4
84981: PUSH
84982: LD_VAR 0 7
84986: ARRAY
84987: PPUSH
84988: LD_VAR 0 8
84992: PUSH
84993: LD_INT 1
84995: ARRAY
84996: PPUSH
84997: LD_VAR 0 8
85001: PUSH
85002: LD_INT 2
85004: ARRAY
85005: PPUSH
85006: CALL_OW 116
// attacking := true ;
85010: LD_ADDR_VAR 0 29
85014: PUSH
85015: LD_INT 1
85017: ST_TO_ADDR
// continue ;
85018: GO 82393
// end ; end else
85020: GO 85046
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85022: LD_VAR 0 4
85026: PUSH
85027: LD_VAR 0 7
85031: ARRAY
85032: PPUSH
85033: LD_VAR 0 14
85037: PUSH
85038: LD_INT 1
85040: ARRAY
85041: PPUSH
85042: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85046: LD_VAR 0 4
85050: PUSH
85051: LD_VAR 0 7
85055: ARRAY
85056: PPUSH
85057: CALL_OW 265
85061: PUSH
85062: LD_INT 11
85064: EQUAL
85065: IFFALSE 85343
// begin k := 10 ;
85067: LD_ADDR_VAR 0 9
85071: PUSH
85072: LD_INT 10
85074: ST_TO_ADDR
// x := 0 ;
85075: LD_ADDR_VAR 0 10
85079: PUSH
85080: LD_INT 0
85082: ST_TO_ADDR
// if tmp < k then
85083: LD_VAR 0 14
85087: PUSH
85088: LD_VAR 0 9
85092: LESS
85093: IFFALSE 85105
// k := tmp ;
85095: LD_ADDR_VAR 0 9
85099: PUSH
85100: LD_VAR 0 14
85104: ST_TO_ADDR
// for j = k downto 1 do
85105: LD_ADDR_VAR 0 8
85109: PUSH
85110: DOUBLE
85111: LD_VAR 0 9
85115: INC
85116: ST_TO_ADDR
85117: LD_INT 1
85119: PUSH
85120: FOR_DOWNTO
85121: IFFALSE 85196
// begin if GetType ( tmp [ j ] ) = unit_human then
85123: LD_VAR 0 14
85127: PUSH
85128: LD_VAR 0 8
85132: ARRAY
85133: PPUSH
85134: CALL_OW 247
85138: PUSH
85139: LD_INT 1
85141: EQUAL
85142: IFFALSE 85194
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85144: LD_VAR 0 4
85148: PUSH
85149: LD_VAR 0 7
85153: ARRAY
85154: PPUSH
85155: LD_VAR 0 14
85159: PUSH
85160: LD_VAR 0 8
85164: ARRAY
85165: PPUSH
85166: CALL 43909 0 2
// x := tmp [ j ] ;
85170: LD_ADDR_VAR 0 10
85174: PUSH
85175: LD_VAR 0 14
85179: PUSH
85180: LD_VAR 0 8
85184: ARRAY
85185: ST_TO_ADDR
// attacking := true ;
85186: LD_ADDR_VAR 0 29
85190: PUSH
85191: LD_INT 1
85193: ST_TO_ADDR
// end ; end ;
85194: GO 85120
85196: POP
85197: POP
// if not x then
85198: LD_VAR 0 10
85202: NOT
85203: IFFALSE 85343
// begin attacking := true ;
85205: LD_ADDR_VAR 0 29
85209: PUSH
85210: LD_INT 1
85212: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85213: LD_VAR 0 4
85217: PUSH
85218: LD_VAR 0 7
85222: ARRAY
85223: PPUSH
85224: CALL_OW 250
85228: PPUSH
85229: LD_VAR 0 4
85233: PUSH
85234: LD_VAR 0 7
85238: ARRAY
85239: PPUSH
85240: CALL_OW 251
85244: PPUSH
85245: CALL_OW 546
85249: PUSH
85250: LD_INT 2
85252: ARRAY
85253: PUSH
85254: LD_VAR 0 14
85258: PUSH
85259: LD_INT 1
85261: ARRAY
85262: PPUSH
85263: CALL_OW 250
85267: PPUSH
85268: LD_VAR 0 14
85272: PUSH
85273: LD_INT 1
85275: ARRAY
85276: PPUSH
85277: CALL_OW 251
85281: PPUSH
85282: CALL_OW 546
85286: PUSH
85287: LD_INT 2
85289: ARRAY
85290: EQUAL
85291: IFFALSE 85319
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85293: LD_VAR 0 4
85297: PUSH
85298: LD_VAR 0 7
85302: ARRAY
85303: PPUSH
85304: LD_VAR 0 14
85308: PUSH
85309: LD_INT 1
85311: ARRAY
85312: PPUSH
85313: CALL 43909 0 2
85317: GO 85343
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85319: LD_VAR 0 4
85323: PUSH
85324: LD_VAR 0 7
85328: ARRAY
85329: PPUSH
85330: LD_VAR 0 14
85334: PUSH
85335: LD_INT 1
85337: ARRAY
85338: PPUSH
85339: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85343: LD_VAR 0 4
85347: PUSH
85348: LD_VAR 0 7
85352: ARRAY
85353: PPUSH
85354: CALL_OW 264
85358: PUSH
85359: LD_INT 29
85361: EQUAL
85362: IFFALSE 85728
// begin if WantsToAttack ( group [ i ] ) in bombed then
85364: LD_VAR 0 4
85368: PUSH
85369: LD_VAR 0 7
85373: ARRAY
85374: PPUSH
85375: CALL_OW 319
85379: PUSH
85380: LD_VAR 0 28
85384: IN
85385: IFFALSE 85389
// continue ;
85387: GO 82393
// k := 8 ;
85389: LD_ADDR_VAR 0 9
85393: PUSH
85394: LD_INT 8
85396: ST_TO_ADDR
// x := 0 ;
85397: LD_ADDR_VAR 0 10
85401: PUSH
85402: LD_INT 0
85404: ST_TO_ADDR
// if tmp < k then
85405: LD_VAR 0 14
85409: PUSH
85410: LD_VAR 0 9
85414: LESS
85415: IFFALSE 85427
// k := tmp ;
85417: LD_ADDR_VAR 0 9
85421: PUSH
85422: LD_VAR 0 14
85426: ST_TO_ADDR
// for j = 1 to k do
85427: LD_ADDR_VAR 0 8
85431: PUSH
85432: DOUBLE
85433: LD_INT 1
85435: DEC
85436: ST_TO_ADDR
85437: LD_VAR 0 9
85441: PUSH
85442: FOR_TO
85443: IFFALSE 85575
// begin if GetType ( tmp [ j ] ) = unit_building then
85445: LD_VAR 0 14
85449: PUSH
85450: LD_VAR 0 8
85454: ARRAY
85455: PPUSH
85456: CALL_OW 247
85460: PUSH
85461: LD_INT 3
85463: EQUAL
85464: IFFALSE 85573
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85466: LD_VAR 0 14
85470: PUSH
85471: LD_VAR 0 8
85475: ARRAY
85476: PUSH
85477: LD_VAR 0 28
85481: IN
85482: NOT
85483: PUSH
85484: LD_VAR 0 14
85488: PUSH
85489: LD_VAR 0 8
85493: ARRAY
85494: PPUSH
85495: CALL_OW 313
85499: AND
85500: IFFALSE 85573
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85502: LD_VAR 0 4
85506: PUSH
85507: LD_VAR 0 7
85511: ARRAY
85512: PPUSH
85513: LD_VAR 0 14
85517: PUSH
85518: LD_VAR 0 8
85522: ARRAY
85523: PPUSH
85524: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85528: LD_ADDR_VAR 0 28
85532: PUSH
85533: LD_VAR 0 28
85537: PPUSH
85538: LD_VAR 0 28
85542: PUSH
85543: LD_INT 1
85545: PLUS
85546: PPUSH
85547: LD_VAR 0 14
85551: PUSH
85552: LD_VAR 0 8
85556: ARRAY
85557: PPUSH
85558: CALL_OW 1
85562: ST_TO_ADDR
// attacking := true ;
85563: LD_ADDR_VAR 0 29
85567: PUSH
85568: LD_INT 1
85570: ST_TO_ADDR
// break ;
85571: GO 85575
// end ; end ;
85573: GO 85442
85575: POP
85576: POP
// if not attacking and f_attack_depot then
85577: LD_VAR 0 29
85581: NOT
85582: PUSH
85583: LD_VAR 0 25
85587: AND
85588: IFFALSE 85683
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85590: LD_ADDR_VAR 0 13
85594: PUSH
85595: LD_VAR 0 14
85599: PPUSH
85600: LD_INT 2
85602: PUSH
85603: LD_INT 30
85605: PUSH
85606: LD_INT 0
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 30
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: LIST
85627: PPUSH
85628: CALL_OW 72
85632: ST_TO_ADDR
// if z then
85633: LD_VAR 0 13
85637: IFFALSE 85683
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85639: LD_VAR 0 4
85643: PUSH
85644: LD_VAR 0 7
85648: ARRAY
85649: PPUSH
85650: LD_VAR 0 13
85654: PPUSH
85655: LD_VAR 0 4
85659: PUSH
85660: LD_VAR 0 7
85664: ARRAY
85665: PPUSH
85666: CALL_OW 74
85670: PPUSH
85671: CALL_OW 115
// attacking := true ;
85675: LD_ADDR_VAR 0 29
85679: PUSH
85680: LD_INT 1
85682: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85683: LD_VAR 0 4
85687: PUSH
85688: LD_VAR 0 7
85692: ARRAY
85693: PPUSH
85694: CALL_OW 256
85698: PUSH
85699: LD_INT 500
85701: LESS
85702: IFFALSE 85728
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85704: LD_VAR 0 4
85708: PUSH
85709: LD_VAR 0 7
85713: ARRAY
85714: PPUSH
85715: LD_VAR 0 14
85719: PUSH
85720: LD_INT 1
85722: ARRAY
85723: PPUSH
85724: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85728: LD_VAR 0 4
85732: PUSH
85733: LD_VAR 0 7
85737: ARRAY
85738: PPUSH
85739: CALL_OW 264
85743: PUSH
85744: LD_INT 49
85746: EQUAL
85747: IFFALSE 85868
// begin if not HasTask ( group [ i ] ) then
85749: LD_VAR 0 4
85753: PUSH
85754: LD_VAR 0 7
85758: ARRAY
85759: PPUSH
85760: CALL_OW 314
85764: NOT
85765: IFFALSE 85868
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85767: LD_ADDR_VAR 0 9
85771: PUSH
85772: LD_INT 81
85774: PUSH
85775: LD_VAR 0 4
85779: PUSH
85780: LD_VAR 0 7
85784: ARRAY
85785: PPUSH
85786: CALL_OW 255
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PPUSH
85795: CALL_OW 69
85799: PPUSH
85800: LD_VAR 0 4
85804: PUSH
85805: LD_VAR 0 7
85809: ARRAY
85810: PPUSH
85811: CALL_OW 74
85815: ST_TO_ADDR
// if k then
85816: LD_VAR 0 9
85820: IFFALSE 85868
// if GetDistUnits ( group [ i ] , k ) > 10 then
85822: LD_VAR 0 4
85826: PUSH
85827: LD_VAR 0 7
85831: ARRAY
85832: PPUSH
85833: LD_VAR 0 9
85837: PPUSH
85838: CALL_OW 296
85842: PUSH
85843: LD_INT 10
85845: GREATER
85846: IFFALSE 85868
// ComMoveUnit ( group [ i ] , k ) ;
85848: LD_VAR 0 4
85852: PUSH
85853: LD_VAR 0 7
85857: ARRAY
85858: PPUSH
85859: LD_VAR 0 9
85863: PPUSH
85864: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85868: LD_VAR 0 4
85872: PUSH
85873: LD_VAR 0 7
85877: ARRAY
85878: PPUSH
85879: CALL_OW 256
85883: PUSH
85884: LD_INT 250
85886: LESS
85887: PUSH
85888: LD_VAR 0 4
85892: PUSH
85893: LD_VAR 0 7
85897: ARRAY
85898: PUSH
85899: LD_INT 21
85901: PUSH
85902: LD_INT 2
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 23
85911: PUSH
85912: LD_INT 2
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PPUSH
85923: CALL_OW 69
85927: IN
85928: AND
85929: IFFALSE 86054
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85931: LD_ADDR_VAR 0 9
85935: PUSH
85936: LD_OWVAR 3
85940: PUSH
85941: LD_VAR 0 4
85945: PUSH
85946: LD_VAR 0 7
85950: ARRAY
85951: DIFF
85952: PPUSH
85953: LD_VAR 0 4
85957: PUSH
85958: LD_VAR 0 7
85962: ARRAY
85963: PPUSH
85964: CALL_OW 74
85968: ST_TO_ADDR
// if not k then
85969: LD_VAR 0 9
85973: NOT
85974: IFFALSE 85978
// continue ;
85976: GO 82393
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85978: LD_VAR 0 9
85982: PUSH
85983: LD_INT 81
85985: PUSH
85986: LD_VAR 0 4
85990: PUSH
85991: LD_VAR 0 7
85995: ARRAY
85996: PPUSH
85997: CALL_OW 255
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PPUSH
86006: CALL_OW 69
86010: IN
86011: PUSH
86012: LD_VAR 0 9
86016: PPUSH
86017: LD_VAR 0 4
86021: PUSH
86022: LD_VAR 0 7
86026: ARRAY
86027: PPUSH
86028: CALL_OW 296
86032: PUSH
86033: LD_INT 5
86035: LESS
86036: AND
86037: IFFALSE 86054
// ComAutodestruct ( group [ i ] ) ;
86039: LD_VAR 0 4
86043: PUSH
86044: LD_VAR 0 7
86048: ARRAY
86049: PPUSH
86050: CALL 43807 0 1
// end ; if f_attack_depot then
86054: LD_VAR 0 25
86058: IFFALSE 86170
// begin k := 6 ;
86060: LD_ADDR_VAR 0 9
86064: PUSH
86065: LD_INT 6
86067: ST_TO_ADDR
// if tmp < k then
86068: LD_VAR 0 14
86072: PUSH
86073: LD_VAR 0 9
86077: LESS
86078: IFFALSE 86090
// k := tmp ;
86080: LD_ADDR_VAR 0 9
86084: PUSH
86085: LD_VAR 0 14
86089: ST_TO_ADDR
// for j = 1 to k do
86090: LD_ADDR_VAR 0 8
86094: PUSH
86095: DOUBLE
86096: LD_INT 1
86098: DEC
86099: ST_TO_ADDR
86100: LD_VAR 0 9
86104: PUSH
86105: FOR_TO
86106: IFFALSE 86168
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86108: LD_VAR 0 8
86112: PPUSH
86113: CALL_OW 266
86117: PUSH
86118: LD_INT 0
86120: PUSH
86121: LD_INT 1
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: IN
86128: IFFALSE 86166
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86130: LD_VAR 0 4
86134: PUSH
86135: LD_VAR 0 7
86139: ARRAY
86140: PPUSH
86141: LD_VAR 0 14
86145: PUSH
86146: LD_VAR 0 8
86150: ARRAY
86151: PPUSH
86152: CALL_OW 115
// attacking := true ;
86156: LD_ADDR_VAR 0 29
86160: PUSH
86161: LD_INT 1
86163: ST_TO_ADDR
// break ;
86164: GO 86168
// end ;
86166: GO 86105
86168: POP
86169: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86170: LD_VAR 0 4
86174: PUSH
86175: LD_VAR 0 7
86179: ARRAY
86180: PPUSH
86181: CALL_OW 302
86185: PUSH
86186: LD_VAR 0 29
86190: NOT
86191: AND
86192: IFFALSE 86514
// begin if GetTag ( group [ i ] ) = 71 then
86194: LD_VAR 0 4
86198: PUSH
86199: LD_VAR 0 7
86203: ARRAY
86204: PPUSH
86205: CALL_OW 110
86209: PUSH
86210: LD_INT 71
86212: EQUAL
86213: IFFALSE 86254
// begin if HasTask ( group [ i ] ) then
86215: LD_VAR 0 4
86219: PUSH
86220: LD_VAR 0 7
86224: ARRAY
86225: PPUSH
86226: CALL_OW 314
86230: IFFALSE 86236
// continue else
86232: GO 82393
86234: GO 86254
// SetTag ( group [ i ] , 0 ) ;
86236: LD_VAR 0 4
86240: PUSH
86241: LD_VAR 0 7
86245: ARRAY
86246: PPUSH
86247: LD_INT 0
86249: PPUSH
86250: CALL_OW 109
// end ; k := 8 ;
86254: LD_ADDR_VAR 0 9
86258: PUSH
86259: LD_INT 8
86261: ST_TO_ADDR
// x := 0 ;
86262: LD_ADDR_VAR 0 10
86266: PUSH
86267: LD_INT 0
86269: ST_TO_ADDR
// if tmp < k then
86270: LD_VAR 0 14
86274: PUSH
86275: LD_VAR 0 9
86279: LESS
86280: IFFALSE 86292
// k := tmp ;
86282: LD_ADDR_VAR 0 9
86286: PUSH
86287: LD_VAR 0 14
86291: ST_TO_ADDR
// for j = 1 to k do
86292: LD_ADDR_VAR 0 8
86296: PUSH
86297: DOUBLE
86298: LD_INT 1
86300: DEC
86301: ST_TO_ADDR
86302: LD_VAR 0 9
86306: PUSH
86307: FOR_TO
86308: IFFALSE 86406
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86310: LD_VAR 0 14
86314: PUSH
86315: LD_VAR 0 8
86319: ARRAY
86320: PPUSH
86321: CALL_OW 247
86325: PUSH
86326: LD_INT 1
86328: EQUAL
86329: PUSH
86330: LD_VAR 0 14
86334: PUSH
86335: LD_VAR 0 8
86339: ARRAY
86340: PPUSH
86341: CALL_OW 256
86345: PUSH
86346: LD_INT 250
86348: LESS
86349: PUSH
86350: LD_VAR 0 20
86354: AND
86355: PUSH
86356: LD_VAR 0 20
86360: NOT
86361: PUSH
86362: LD_VAR 0 14
86366: PUSH
86367: LD_VAR 0 8
86371: ARRAY
86372: PPUSH
86373: CALL_OW 256
86377: PUSH
86378: LD_INT 250
86380: GREATEREQUAL
86381: AND
86382: OR
86383: AND
86384: IFFALSE 86404
// begin x := tmp [ j ] ;
86386: LD_ADDR_VAR 0 10
86390: PUSH
86391: LD_VAR 0 14
86395: PUSH
86396: LD_VAR 0 8
86400: ARRAY
86401: ST_TO_ADDR
// break ;
86402: GO 86406
// end ;
86404: GO 86307
86406: POP
86407: POP
// if x then
86408: LD_VAR 0 10
86412: IFFALSE 86436
// ComAttackUnit ( group [ i ] , x ) else
86414: LD_VAR 0 4
86418: PUSH
86419: LD_VAR 0 7
86423: ARRAY
86424: PPUSH
86425: LD_VAR 0 10
86429: PPUSH
86430: CALL_OW 115
86434: GO 86460
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86436: LD_VAR 0 4
86440: PUSH
86441: LD_VAR 0 7
86445: ARRAY
86446: PPUSH
86447: LD_VAR 0 14
86451: PUSH
86452: LD_INT 1
86454: ARRAY
86455: PPUSH
86456: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86460: LD_VAR 0 4
86464: PUSH
86465: LD_VAR 0 7
86469: ARRAY
86470: PPUSH
86471: CALL_OW 314
86475: NOT
86476: IFFALSE 86514
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86478: LD_VAR 0 4
86482: PUSH
86483: LD_VAR 0 7
86487: ARRAY
86488: PPUSH
86489: LD_VAR 0 14
86493: PPUSH
86494: LD_VAR 0 4
86498: PUSH
86499: LD_VAR 0 7
86503: ARRAY
86504: PPUSH
86505: CALL_OW 74
86509: PPUSH
86510: CALL_OW 115
// end ; end ; end ;
86514: GO 82393
86516: POP
86517: POP
// wait ( 0 0$2 ) ;
86518: LD_INT 70
86520: PPUSH
86521: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86525: LD_VAR 0 4
86529: NOT
86530: PUSH
86531: LD_VAR 0 4
86535: PUSH
86536: EMPTY
86537: EQUAL
86538: OR
86539: PUSH
86540: LD_INT 81
86542: PUSH
86543: LD_VAR 0 35
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PPUSH
86552: CALL_OW 69
86556: NOT
86557: OR
86558: IFFALSE 82378
// end ;
86560: LD_VAR 0 2
86564: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86565: LD_INT 0
86567: PPUSH
86568: PPUSH
86569: PPUSH
86570: PPUSH
86571: PPUSH
86572: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86573: LD_VAR 0 1
86577: NOT
86578: PUSH
86579: LD_EXP 23
86583: PUSH
86584: LD_VAR 0 1
86588: ARRAY
86589: NOT
86590: OR
86591: PUSH
86592: LD_VAR 0 2
86596: NOT
86597: OR
86598: IFFALSE 86602
// exit ;
86600: GO 87156
// side := mc_sides [ base ] ;
86602: LD_ADDR_VAR 0 6
86606: PUSH
86607: LD_EXP 49
86611: PUSH
86612: LD_VAR 0 1
86616: ARRAY
86617: ST_TO_ADDR
// if not side then
86618: LD_VAR 0 6
86622: NOT
86623: IFFALSE 86627
// exit ;
86625: GO 87156
// for i in solds do
86627: LD_ADDR_VAR 0 7
86631: PUSH
86632: LD_VAR 0 2
86636: PUSH
86637: FOR_IN
86638: IFFALSE 86699
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86640: LD_VAR 0 7
86644: PPUSH
86645: CALL_OW 310
86649: PPUSH
86650: CALL_OW 266
86654: PUSH
86655: LD_INT 32
86657: PUSH
86658: LD_INT 31
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: IN
86665: IFFALSE 86685
// solds := solds diff i else
86667: LD_ADDR_VAR 0 2
86671: PUSH
86672: LD_VAR 0 2
86676: PUSH
86677: LD_VAR 0 7
86681: DIFF
86682: ST_TO_ADDR
86683: GO 86697
// SetTag ( i , 18 ) ;
86685: LD_VAR 0 7
86689: PPUSH
86690: LD_INT 18
86692: PPUSH
86693: CALL_OW 109
86697: GO 86637
86699: POP
86700: POP
// if not solds then
86701: LD_VAR 0 2
86705: NOT
86706: IFFALSE 86710
// exit ;
86708: GO 87156
// repeat wait ( 0 0$2 ) ;
86710: LD_INT 70
86712: PPUSH
86713: CALL_OW 67
// enemy := mc_scan [ base ] ;
86717: LD_ADDR_VAR 0 4
86721: PUSH
86722: LD_EXP 46
86726: PUSH
86727: LD_VAR 0 1
86731: ARRAY
86732: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86733: LD_EXP 23
86737: PUSH
86738: LD_VAR 0 1
86742: ARRAY
86743: NOT
86744: PUSH
86745: LD_EXP 23
86749: PUSH
86750: LD_VAR 0 1
86754: ARRAY
86755: PUSH
86756: EMPTY
86757: EQUAL
86758: OR
86759: IFFALSE 86796
// begin for i in solds do
86761: LD_ADDR_VAR 0 7
86765: PUSH
86766: LD_VAR 0 2
86770: PUSH
86771: FOR_IN
86772: IFFALSE 86785
// ComStop ( i ) ;
86774: LD_VAR 0 7
86778: PPUSH
86779: CALL_OW 141
86783: GO 86771
86785: POP
86786: POP
// solds := [ ] ;
86787: LD_ADDR_VAR 0 2
86791: PUSH
86792: EMPTY
86793: ST_TO_ADDR
// exit ;
86794: GO 87156
// end ; for i in solds do
86796: LD_ADDR_VAR 0 7
86800: PUSH
86801: LD_VAR 0 2
86805: PUSH
86806: FOR_IN
86807: IFFALSE 87128
// begin if IsInUnit ( i ) then
86809: LD_VAR 0 7
86813: PPUSH
86814: CALL_OW 310
86818: IFFALSE 86829
// ComExitBuilding ( i ) ;
86820: LD_VAR 0 7
86824: PPUSH
86825: CALL_OW 122
// if GetLives ( i ) > 500 then
86829: LD_VAR 0 7
86833: PPUSH
86834: CALL_OW 256
86838: PUSH
86839: LD_INT 500
86841: GREATER
86842: IFFALSE 86895
// begin e := NearestUnitToUnit ( enemy , i ) ;
86844: LD_ADDR_VAR 0 5
86848: PUSH
86849: LD_VAR 0 4
86853: PPUSH
86854: LD_VAR 0 7
86858: PPUSH
86859: CALL_OW 74
86863: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86864: LD_VAR 0 7
86868: PPUSH
86869: LD_VAR 0 5
86873: PPUSH
86874: CALL_OW 250
86878: PPUSH
86879: LD_VAR 0 5
86883: PPUSH
86884: CALL_OW 251
86888: PPUSH
86889: CALL_OW 114
// end else
86893: GO 87126
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86895: LD_VAR 0 7
86899: PPUSH
86900: LD_EXP 23
86904: PUSH
86905: LD_VAR 0 1
86909: ARRAY
86910: PPUSH
86911: LD_INT 2
86913: PUSH
86914: LD_INT 30
86916: PUSH
86917: LD_INT 0
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: PUSH
86924: LD_INT 30
86926: PUSH
86927: LD_INT 1
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 30
86936: PUSH
86937: LD_INT 6
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: PPUSH
86950: CALL_OW 72
86954: PPUSH
86955: LD_VAR 0 7
86959: PPUSH
86960: CALL_OW 74
86964: PPUSH
86965: CALL_OW 296
86969: PUSH
86970: LD_INT 10
86972: GREATER
86973: IFFALSE 87126
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86975: LD_ADDR_VAR 0 8
86979: PUSH
86980: LD_EXP 23
86984: PUSH
86985: LD_VAR 0 1
86989: ARRAY
86990: PPUSH
86991: LD_INT 2
86993: PUSH
86994: LD_INT 30
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 30
87006: PUSH
87007: LD_INT 1
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 30
87016: PUSH
87017: LD_INT 6
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: PPUSH
87030: CALL_OW 72
87034: PPUSH
87035: LD_VAR 0 7
87039: PPUSH
87040: CALL_OW 74
87044: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87045: LD_VAR 0 7
87049: PPUSH
87050: LD_VAR 0 8
87054: PPUSH
87055: CALL_OW 250
87059: PPUSH
87060: LD_INT 3
87062: PPUSH
87063: LD_INT 5
87065: PPUSH
87066: CALL_OW 272
87070: PPUSH
87071: LD_VAR 0 8
87075: PPUSH
87076: CALL_OW 251
87080: PPUSH
87081: LD_INT 3
87083: PPUSH
87084: LD_INT 5
87086: PPUSH
87087: CALL_OW 273
87091: PPUSH
87092: CALL_OW 111
// SetTag ( i , 0 ) ;
87096: LD_VAR 0 7
87100: PPUSH
87101: LD_INT 0
87103: PPUSH
87104: CALL_OW 109
// solds := solds diff i ;
87108: LD_ADDR_VAR 0 2
87112: PUSH
87113: LD_VAR 0 2
87117: PUSH
87118: LD_VAR 0 7
87122: DIFF
87123: ST_TO_ADDR
// continue ;
87124: GO 86806
// end ; end ;
87126: GO 86806
87128: POP
87129: POP
// until not solds or not enemy ;
87130: LD_VAR 0 2
87134: NOT
87135: PUSH
87136: LD_VAR 0 4
87140: NOT
87141: OR
87142: IFFALSE 86710
// MC_Reset ( base , 18 ) ;
87144: LD_VAR 0 1
87148: PPUSH
87149: LD_INT 18
87151: PPUSH
87152: CALL 55216 0 2
// end ;
87156: LD_VAR 0 3
87160: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87161: LD_INT 0
87163: PPUSH
87164: PPUSH
87165: PPUSH
87166: PPUSH
87167: PPUSH
87168: PPUSH
87169: PPUSH
87170: PPUSH
87171: PPUSH
87172: PPUSH
87173: PPUSH
87174: PPUSH
87175: PPUSH
87176: PPUSH
87177: PPUSH
87178: PPUSH
87179: PPUSH
87180: PPUSH
87181: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87182: LD_ADDR_VAR 0 12
87186: PUSH
87187: LD_EXP 23
87191: PUSH
87192: LD_VAR 0 1
87196: ARRAY
87197: PPUSH
87198: LD_INT 25
87200: PUSH
87201: LD_INT 3
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PPUSH
87208: CALL_OW 72
87212: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87213: LD_EXP 63
87217: PUSH
87218: LD_VAR 0 1
87222: ARRAY
87223: IFFALSE 87247
// mechs := mechs diff mc_remote_driver [ base ] ;
87225: LD_ADDR_VAR 0 12
87229: PUSH
87230: LD_VAR 0 12
87234: PUSH
87235: LD_EXP 63
87239: PUSH
87240: LD_VAR 0 1
87244: ARRAY
87245: DIFF
87246: ST_TO_ADDR
// for i in mechs do
87247: LD_ADDR_VAR 0 4
87251: PUSH
87252: LD_VAR 0 12
87256: PUSH
87257: FOR_IN
87258: IFFALSE 87293
// if GetTag ( i ) > 0 then
87260: LD_VAR 0 4
87264: PPUSH
87265: CALL_OW 110
87269: PUSH
87270: LD_INT 0
87272: GREATER
87273: IFFALSE 87291
// mechs := mechs diff i ;
87275: LD_ADDR_VAR 0 12
87279: PUSH
87280: LD_VAR 0 12
87284: PUSH
87285: LD_VAR 0 4
87289: DIFF
87290: ST_TO_ADDR
87291: GO 87257
87293: POP
87294: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87295: LD_ADDR_VAR 0 8
87299: PUSH
87300: LD_EXP 23
87304: PUSH
87305: LD_VAR 0 1
87309: ARRAY
87310: PPUSH
87311: LD_INT 2
87313: PUSH
87314: LD_INT 25
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 25
87326: PUSH
87327: LD_INT 5
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PUSH
87334: LD_INT 25
87336: PUSH
87337: LD_INT 8
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 25
87346: PUSH
87347: LD_INT 9
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: PPUSH
87361: CALL_OW 72
87365: ST_TO_ADDR
// if not defenders and not solds then
87366: LD_VAR 0 2
87370: NOT
87371: PUSH
87372: LD_VAR 0 8
87376: NOT
87377: AND
87378: IFFALSE 87382
// exit ;
87380: GO 89152
// depot_under_attack := false ;
87382: LD_ADDR_VAR 0 16
87386: PUSH
87387: LD_INT 0
87389: ST_TO_ADDR
// sold_defenders := [ ] ;
87390: LD_ADDR_VAR 0 17
87394: PUSH
87395: EMPTY
87396: ST_TO_ADDR
// if mechs then
87397: LD_VAR 0 12
87401: IFFALSE 87554
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87403: LD_ADDR_VAR 0 4
87407: PUSH
87408: LD_VAR 0 2
87412: PPUSH
87413: LD_INT 21
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PPUSH
87423: CALL_OW 72
87427: PUSH
87428: FOR_IN
87429: IFFALSE 87552
// begin if GetTag ( i ) <> 20 then
87431: LD_VAR 0 4
87435: PPUSH
87436: CALL_OW 110
87440: PUSH
87441: LD_INT 20
87443: NONEQUAL
87444: IFFALSE 87458
// SetTag ( i , 20 ) ;
87446: LD_VAR 0 4
87450: PPUSH
87451: LD_INT 20
87453: PPUSH
87454: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87458: LD_VAR 0 4
87462: PPUSH
87463: CALL_OW 263
87467: PUSH
87468: LD_INT 1
87470: EQUAL
87471: PUSH
87472: LD_VAR 0 4
87476: PPUSH
87477: CALL_OW 311
87481: NOT
87482: AND
87483: IFFALSE 87550
// begin un := mechs [ 1 ] ;
87485: LD_ADDR_VAR 0 10
87489: PUSH
87490: LD_VAR 0 12
87494: PUSH
87495: LD_INT 1
87497: ARRAY
87498: ST_TO_ADDR
// ComExit ( un ) ;
87499: LD_VAR 0 10
87503: PPUSH
87504: CALL 48096 0 1
// AddComEnterUnit ( un , i ) ;
87508: LD_VAR 0 10
87512: PPUSH
87513: LD_VAR 0 4
87517: PPUSH
87518: CALL_OW 180
// SetTag ( un , 19 ) ;
87522: LD_VAR 0 10
87526: PPUSH
87527: LD_INT 19
87529: PPUSH
87530: CALL_OW 109
// mechs := mechs diff un ;
87534: LD_ADDR_VAR 0 12
87538: PUSH
87539: LD_VAR 0 12
87543: PUSH
87544: LD_VAR 0 10
87548: DIFF
87549: ST_TO_ADDR
// end ; end ;
87550: GO 87428
87552: POP
87553: POP
// if solds then
87554: LD_VAR 0 8
87558: IFFALSE 87617
// for i in solds do
87560: LD_ADDR_VAR 0 4
87564: PUSH
87565: LD_VAR 0 8
87569: PUSH
87570: FOR_IN
87571: IFFALSE 87615
// if not GetTag ( i ) then
87573: LD_VAR 0 4
87577: PPUSH
87578: CALL_OW 110
87582: NOT
87583: IFFALSE 87613
// begin defenders := defenders union i ;
87585: LD_ADDR_VAR 0 2
87589: PUSH
87590: LD_VAR 0 2
87594: PUSH
87595: LD_VAR 0 4
87599: UNION
87600: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87601: LD_VAR 0 4
87605: PPUSH
87606: LD_INT 18
87608: PPUSH
87609: CALL_OW 109
// end ;
87613: GO 87570
87615: POP
87616: POP
// repeat wait ( 0 0$2 ) ;
87617: LD_INT 70
87619: PPUSH
87620: CALL_OW 67
// enemy := mc_scan [ base ] ;
87624: LD_ADDR_VAR 0 21
87628: PUSH
87629: LD_EXP 46
87633: PUSH
87634: LD_VAR 0 1
87638: ARRAY
87639: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87640: LD_EXP 23
87644: PUSH
87645: LD_VAR 0 1
87649: ARRAY
87650: NOT
87651: PUSH
87652: LD_EXP 23
87656: PUSH
87657: LD_VAR 0 1
87661: ARRAY
87662: PUSH
87663: EMPTY
87664: EQUAL
87665: OR
87666: IFFALSE 87703
// begin for i in defenders do
87668: LD_ADDR_VAR 0 4
87672: PUSH
87673: LD_VAR 0 2
87677: PUSH
87678: FOR_IN
87679: IFFALSE 87692
// ComStop ( i ) ;
87681: LD_VAR 0 4
87685: PPUSH
87686: CALL_OW 141
87690: GO 87678
87692: POP
87693: POP
// defenders := [ ] ;
87694: LD_ADDR_VAR 0 2
87698: PUSH
87699: EMPTY
87700: ST_TO_ADDR
// exit ;
87701: GO 89152
// end ; for i in defenders do
87703: LD_ADDR_VAR 0 4
87707: PUSH
87708: LD_VAR 0 2
87712: PUSH
87713: FOR_IN
87714: IFFALSE 88612
// begin e := NearestUnitToUnit ( enemy , i ) ;
87716: LD_ADDR_VAR 0 13
87720: PUSH
87721: LD_VAR 0 21
87725: PPUSH
87726: LD_VAR 0 4
87730: PPUSH
87731: CALL_OW 74
87735: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87736: LD_ADDR_VAR 0 7
87740: PUSH
87741: LD_EXP 23
87745: PUSH
87746: LD_VAR 0 1
87750: ARRAY
87751: PPUSH
87752: LD_INT 2
87754: PUSH
87755: LD_INT 30
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PUSH
87765: LD_INT 30
87767: PUSH
87768: LD_INT 1
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: LIST
87779: PPUSH
87780: CALL_OW 72
87784: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87785: LD_ADDR_VAR 0 16
87789: PUSH
87790: LD_VAR 0 7
87794: NOT
87795: PUSH
87796: LD_VAR 0 7
87800: PPUSH
87801: LD_INT 3
87803: PUSH
87804: LD_INT 24
87806: PUSH
87807: LD_INT 600
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PPUSH
87818: CALL_OW 72
87822: OR
87823: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87824: LD_VAR 0 4
87828: PPUSH
87829: CALL_OW 247
87833: PUSH
87834: LD_INT 2
87836: DOUBLE
87837: EQUAL
87838: IFTRUE 87842
87840: GO 88238
87842: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87843: LD_VAR 0 4
87847: PPUSH
87848: CALL_OW 256
87852: PUSH
87853: LD_INT 1000
87855: EQUAL
87856: PUSH
87857: LD_VAR 0 4
87861: PPUSH
87862: LD_VAR 0 13
87866: PPUSH
87867: CALL_OW 296
87871: PUSH
87872: LD_INT 40
87874: LESS
87875: PUSH
87876: LD_VAR 0 13
87880: PPUSH
87881: LD_EXP 48
87885: PUSH
87886: LD_VAR 0 1
87890: ARRAY
87891: PPUSH
87892: CALL_OW 308
87896: OR
87897: AND
87898: IFFALSE 88020
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87900: LD_VAR 0 4
87904: PPUSH
87905: CALL_OW 262
87909: PUSH
87910: LD_INT 1
87912: EQUAL
87913: PUSH
87914: LD_VAR 0 4
87918: PPUSH
87919: CALL_OW 261
87923: PUSH
87924: LD_INT 30
87926: LESS
87927: AND
87928: PUSH
87929: LD_VAR 0 7
87933: AND
87934: IFFALSE 88004
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87936: LD_VAR 0 4
87940: PPUSH
87941: LD_VAR 0 7
87945: PPUSH
87946: LD_VAR 0 4
87950: PPUSH
87951: CALL_OW 74
87955: PPUSH
87956: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87960: LD_VAR 0 4
87964: PPUSH
87965: LD_VAR 0 7
87969: PPUSH
87970: LD_VAR 0 4
87974: PPUSH
87975: CALL_OW 74
87979: PPUSH
87980: CALL_OW 296
87984: PUSH
87985: LD_INT 6
87987: LESS
87988: IFFALSE 88002
// SetFuel ( i , 100 ) ;
87990: LD_VAR 0 4
87994: PPUSH
87995: LD_INT 100
87997: PPUSH
87998: CALL_OW 240
// end else
88002: GO 88018
// ComAttackUnit ( i , e ) ;
88004: LD_VAR 0 4
88008: PPUSH
88009: LD_VAR 0 13
88013: PPUSH
88014: CALL_OW 115
// end else
88018: GO 88121
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88020: LD_VAR 0 13
88024: PPUSH
88025: LD_EXP 48
88029: PUSH
88030: LD_VAR 0 1
88034: ARRAY
88035: PPUSH
88036: CALL_OW 308
88040: NOT
88041: PUSH
88042: LD_VAR 0 4
88046: PPUSH
88047: LD_VAR 0 13
88051: PPUSH
88052: CALL_OW 296
88056: PUSH
88057: LD_INT 40
88059: GREATEREQUAL
88060: AND
88061: PUSH
88062: LD_VAR 0 4
88066: PPUSH
88067: CALL_OW 256
88071: PUSH
88072: LD_INT 650
88074: LESSEQUAL
88075: OR
88076: PUSH
88077: LD_VAR 0 4
88081: PPUSH
88082: LD_EXP 47
88086: PUSH
88087: LD_VAR 0 1
88091: ARRAY
88092: PPUSH
88093: CALL_OW 308
88097: NOT
88098: AND
88099: IFFALSE 88121
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88101: LD_VAR 0 4
88105: PPUSH
88106: LD_EXP 47
88110: PUSH
88111: LD_VAR 0 1
88115: ARRAY
88116: PPUSH
88117: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88121: LD_VAR 0 4
88125: PPUSH
88126: CALL_OW 256
88130: PUSH
88131: LD_INT 1000
88133: LESS
88134: PUSH
88135: LD_VAR 0 4
88139: PPUSH
88140: CALL_OW 263
88144: PUSH
88145: LD_INT 1
88147: EQUAL
88148: AND
88149: PUSH
88150: LD_VAR 0 4
88154: PPUSH
88155: CALL_OW 311
88159: AND
88160: PUSH
88161: LD_VAR 0 4
88165: PPUSH
88166: LD_EXP 47
88170: PUSH
88171: LD_VAR 0 1
88175: ARRAY
88176: PPUSH
88177: CALL_OW 308
88181: AND
88182: IFFALSE 88236
// begin mech := IsDrivenBy ( i ) ;
88184: LD_ADDR_VAR 0 9
88188: PUSH
88189: LD_VAR 0 4
88193: PPUSH
88194: CALL_OW 311
88198: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88199: LD_VAR 0 9
88203: PPUSH
88204: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88208: LD_VAR 0 9
88212: PPUSH
88213: LD_VAR 0 4
88217: PPUSH
88218: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88222: LD_VAR 0 9
88226: PPUSH
88227: LD_VAR 0 4
88231: PPUSH
88232: CALL_OW 180
// end ; end ; unit_human :
88236: GO 88583
88238: LD_INT 1
88240: DOUBLE
88241: EQUAL
88242: IFTRUE 88246
88244: GO 88582
88246: POP
// begin b := IsInUnit ( i ) ;
88247: LD_ADDR_VAR 0 18
88251: PUSH
88252: LD_VAR 0 4
88256: PPUSH
88257: CALL_OW 310
88261: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88262: LD_ADDR_VAR 0 19
88266: PUSH
88267: LD_VAR 0 18
88271: NOT
88272: PUSH
88273: LD_VAR 0 18
88277: PPUSH
88278: CALL_OW 266
88282: PUSH
88283: LD_INT 32
88285: PUSH
88286: LD_INT 31
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: IN
88293: OR
88294: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88295: LD_VAR 0 18
88299: PPUSH
88300: CALL_OW 266
88304: PUSH
88305: LD_INT 5
88307: EQUAL
88308: PUSH
88309: LD_VAR 0 4
88313: PPUSH
88314: CALL_OW 257
88318: PUSH
88319: LD_INT 1
88321: PUSH
88322: LD_INT 2
88324: PUSH
88325: LD_INT 3
88327: PUSH
88328: LD_INT 4
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: IN
88337: AND
88338: IFFALSE 88375
// begin class := AllowSpecClass ( i ) ;
88340: LD_ADDR_VAR 0 20
88344: PUSH
88345: LD_VAR 0 4
88349: PPUSH
88350: CALL 12813 0 1
88354: ST_TO_ADDR
// if class then
88355: LD_VAR 0 20
88359: IFFALSE 88375
// ComChangeProfession ( i , class ) ;
88361: LD_VAR 0 4
88365: PPUSH
88366: LD_VAR 0 20
88370: PPUSH
88371: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88375: LD_VAR 0 16
88379: PUSH
88380: LD_VAR 0 2
88384: PPUSH
88385: LD_INT 21
88387: PUSH
88388: LD_INT 2
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PPUSH
88395: CALL_OW 72
88399: PUSH
88400: LD_INT 1
88402: LESSEQUAL
88403: OR
88404: PUSH
88405: LD_VAR 0 19
88409: AND
88410: PUSH
88411: LD_VAR 0 4
88415: PUSH
88416: LD_VAR 0 17
88420: IN
88421: NOT
88422: AND
88423: IFFALSE 88516
// begin if b then
88425: LD_VAR 0 18
88429: IFFALSE 88478
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88431: LD_VAR 0 18
88435: PPUSH
88436: LD_VAR 0 21
88440: PPUSH
88441: LD_VAR 0 18
88445: PPUSH
88446: CALL_OW 74
88450: PPUSH
88451: CALL_OW 296
88455: PUSH
88456: LD_INT 10
88458: LESS
88459: PUSH
88460: LD_VAR 0 18
88464: PPUSH
88465: CALL_OW 461
88469: PUSH
88470: LD_INT 7
88472: NONEQUAL
88473: AND
88474: IFFALSE 88478
// continue ;
88476: GO 87713
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88478: LD_ADDR_VAR 0 17
88482: PUSH
88483: LD_VAR 0 17
88487: PPUSH
88488: LD_VAR 0 17
88492: PUSH
88493: LD_INT 1
88495: PLUS
88496: PPUSH
88497: LD_VAR 0 4
88501: PPUSH
88502: CALL_OW 1
88506: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88507: LD_VAR 0 4
88511: PPUSH
88512: CALL_OW 122
// end ; if sold_defenders then
88516: LD_VAR 0 17
88520: IFFALSE 88580
// if i in sold_defenders then
88522: LD_VAR 0 4
88526: PUSH
88527: LD_VAR 0 17
88531: IN
88532: IFFALSE 88580
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88534: LD_VAR 0 4
88538: PPUSH
88539: CALL_OW 314
88543: NOT
88544: PUSH
88545: LD_VAR 0 4
88549: PPUSH
88550: LD_VAR 0 13
88554: PPUSH
88555: CALL_OW 296
88559: PUSH
88560: LD_INT 30
88562: LESS
88563: AND
88564: IFFALSE 88580
// ComAttackUnit ( i , e ) ;
88566: LD_VAR 0 4
88570: PPUSH
88571: LD_VAR 0 13
88575: PPUSH
88576: CALL_OW 115
// end ; end ; end ;
88580: GO 88583
88582: POP
// if IsDead ( i ) then
88583: LD_VAR 0 4
88587: PPUSH
88588: CALL_OW 301
88592: IFFALSE 88610
// defenders := defenders diff i ;
88594: LD_ADDR_VAR 0 2
88598: PUSH
88599: LD_VAR 0 2
88603: PUSH
88604: LD_VAR 0 4
88608: DIFF
88609: ST_TO_ADDR
// end ;
88610: GO 87713
88612: POP
88613: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88614: LD_VAR 0 21
88618: NOT
88619: PUSH
88620: LD_VAR 0 2
88624: NOT
88625: OR
88626: PUSH
88627: LD_EXP 23
88631: PUSH
88632: LD_VAR 0 1
88636: ARRAY
88637: NOT
88638: OR
88639: IFFALSE 87617
// MC_Reset ( base , 18 ) ;
88641: LD_VAR 0 1
88645: PPUSH
88646: LD_INT 18
88648: PPUSH
88649: CALL 55216 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88653: LD_ADDR_VAR 0 2
88657: PUSH
88658: LD_VAR 0 2
88662: PUSH
88663: LD_VAR 0 2
88667: PPUSH
88668: LD_INT 2
88670: PUSH
88671: LD_INT 25
88673: PUSH
88674: LD_INT 1
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 25
88683: PUSH
88684: LD_INT 5
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 25
88693: PUSH
88694: LD_INT 8
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: PUSH
88701: LD_INT 25
88703: PUSH
88704: LD_INT 9
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: PPUSH
88718: CALL_OW 72
88722: DIFF
88723: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88724: LD_VAR 0 21
88728: NOT
88729: PUSH
88730: LD_VAR 0 2
88734: PPUSH
88735: LD_INT 21
88737: PUSH
88738: LD_INT 2
88740: PUSH
88741: EMPTY
88742: LIST
88743: LIST
88744: PPUSH
88745: CALL_OW 72
88749: AND
88750: IFFALSE 89088
// begin tmp := FilterByTag ( defenders , 19 ) ;
88752: LD_ADDR_VAR 0 11
88756: PUSH
88757: LD_VAR 0 2
88761: PPUSH
88762: LD_INT 19
88764: PPUSH
88765: CALL 45282 0 2
88769: ST_TO_ADDR
// if tmp then
88770: LD_VAR 0 11
88774: IFFALSE 88844
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88776: LD_ADDR_VAR 0 11
88780: PUSH
88781: LD_VAR 0 11
88785: PPUSH
88786: LD_INT 25
88788: PUSH
88789: LD_INT 3
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PPUSH
88796: CALL_OW 72
88800: ST_TO_ADDR
// if tmp then
88801: LD_VAR 0 11
88805: IFFALSE 88844
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88807: LD_ADDR_EXP 35
88811: PUSH
88812: LD_EXP 35
88816: PPUSH
88817: LD_VAR 0 1
88821: PPUSH
88822: LD_EXP 35
88826: PUSH
88827: LD_VAR 0 1
88831: ARRAY
88832: PUSH
88833: LD_VAR 0 11
88837: UNION
88838: PPUSH
88839: CALL_OW 1
88843: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88844: LD_VAR 0 1
88848: PPUSH
88849: LD_INT 19
88851: PPUSH
88852: CALL 55216 0 2
// repeat wait ( 0 0$1 ) ;
88856: LD_INT 35
88858: PPUSH
88859: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88863: LD_EXP 23
88867: PUSH
88868: LD_VAR 0 1
88872: ARRAY
88873: NOT
88874: PUSH
88875: LD_EXP 23
88879: PUSH
88880: LD_VAR 0 1
88884: ARRAY
88885: PUSH
88886: EMPTY
88887: EQUAL
88888: OR
88889: IFFALSE 88926
// begin for i in defenders do
88891: LD_ADDR_VAR 0 4
88895: PUSH
88896: LD_VAR 0 2
88900: PUSH
88901: FOR_IN
88902: IFFALSE 88915
// ComStop ( i ) ;
88904: LD_VAR 0 4
88908: PPUSH
88909: CALL_OW 141
88913: GO 88901
88915: POP
88916: POP
// defenders := [ ] ;
88917: LD_ADDR_VAR 0 2
88921: PUSH
88922: EMPTY
88923: ST_TO_ADDR
// exit ;
88924: GO 89152
// end ; for i in defenders do
88926: LD_ADDR_VAR 0 4
88930: PUSH
88931: LD_VAR 0 2
88935: PUSH
88936: FOR_IN
88937: IFFALSE 89026
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88939: LD_VAR 0 4
88943: PPUSH
88944: LD_EXP 47
88948: PUSH
88949: LD_VAR 0 1
88953: ARRAY
88954: PPUSH
88955: CALL_OW 308
88959: NOT
88960: IFFALSE 88984
// ComMoveToArea ( i , mc_parking [ base ] ) else
88962: LD_VAR 0 4
88966: PPUSH
88967: LD_EXP 47
88971: PUSH
88972: LD_VAR 0 1
88976: ARRAY
88977: PPUSH
88978: CALL_OW 113
88982: GO 89024
// if GetControl ( i ) = control_manual then
88984: LD_VAR 0 4
88988: PPUSH
88989: CALL_OW 263
88993: PUSH
88994: LD_INT 1
88996: EQUAL
88997: IFFALSE 89024
// if IsDrivenBy ( i ) then
88999: LD_VAR 0 4
89003: PPUSH
89004: CALL_OW 311
89008: IFFALSE 89024
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89010: LD_VAR 0 4
89014: PPUSH
89015: CALL_OW 311
89019: PPUSH
89020: CALL_OW 121
// end ;
89024: GO 88936
89026: POP
89027: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89028: LD_VAR 0 2
89032: PPUSH
89033: LD_INT 95
89035: PUSH
89036: LD_EXP 47
89040: PUSH
89041: LD_VAR 0 1
89045: ARRAY
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PPUSH
89051: CALL_OW 72
89055: PUSH
89056: LD_VAR 0 2
89060: EQUAL
89061: PUSH
89062: LD_EXP 46
89066: PUSH
89067: LD_VAR 0 1
89071: ARRAY
89072: OR
89073: PUSH
89074: LD_EXP 23
89078: PUSH
89079: LD_VAR 0 1
89083: ARRAY
89084: NOT
89085: OR
89086: IFFALSE 88856
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89088: LD_ADDR_EXP 45
89092: PUSH
89093: LD_EXP 45
89097: PPUSH
89098: LD_VAR 0 1
89102: PPUSH
89103: LD_VAR 0 2
89107: PPUSH
89108: LD_INT 21
89110: PUSH
89111: LD_INT 2
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PPUSH
89118: CALL_OW 72
89122: PPUSH
89123: CALL_OW 1
89127: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89128: LD_VAR 0 1
89132: PPUSH
89133: LD_INT 19
89135: PPUSH
89136: CALL 55216 0 2
// MC_Reset ( base , 20 ) ;
89140: LD_VAR 0 1
89144: PPUSH
89145: LD_INT 20
89147: PPUSH
89148: CALL 55216 0 2
// end ; end_of_file
89152: LD_VAR 0 3
89156: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89157: LD_INT 0
89159: PPUSH
89160: PPUSH
89161: PPUSH
89162: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89163: LD_VAR 0 1
89167: PPUSH
89168: CALL_OW 264
89172: PUSH
89173: LD_EXP 71
89177: EQUAL
89178: IFFALSE 89250
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89180: LD_INT 68
89182: PPUSH
89183: LD_VAR 0 1
89187: PPUSH
89188: CALL_OW 255
89192: PPUSH
89193: CALL_OW 321
89197: PUSH
89198: LD_INT 2
89200: EQUAL
89201: IFFALSE 89213
// eff := 70 else
89203: LD_ADDR_VAR 0 4
89207: PUSH
89208: LD_INT 70
89210: ST_TO_ADDR
89211: GO 89221
// eff := 30 ;
89213: LD_ADDR_VAR 0 4
89217: PUSH
89218: LD_INT 30
89220: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89221: LD_VAR 0 1
89225: PPUSH
89226: CALL_OW 250
89230: PPUSH
89231: LD_VAR 0 1
89235: PPUSH
89236: CALL_OW 251
89240: PPUSH
89241: LD_VAR 0 4
89245: PPUSH
89246: CALL_OW 495
// end ; end ;
89250: LD_VAR 0 2
89254: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89255: LD_INT 0
89257: PPUSH
// end ;
89258: LD_VAR 0 4
89262: RET
// export function SOS_Command ( cmd ) ; begin
89263: LD_INT 0
89265: PPUSH
// end ;
89266: LD_VAR 0 2
89270: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89271: LD_INT 0
89273: PPUSH
// end ;
89274: LD_VAR 0 6
89278: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89279: LD_INT 0
89281: PPUSH
89282: PPUSH
// if not vehicle or not factory then
89283: LD_VAR 0 1
89287: NOT
89288: PUSH
89289: LD_VAR 0 2
89293: NOT
89294: OR
89295: IFFALSE 89299
// exit ;
89297: GO 89530
// if factoryWaypoints >= factory then
89299: LD_EXP 86
89303: PUSH
89304: LD_VAR 0 2
89308: GREATEREQUAL
89309: IFFALSE 89530
// if factoryWaypoints [ factory ] then
89311: LD_EXP 86
89315: PUSH
89316: LD_VAR 0 2
89320: ARRAY
89321: IFFALSE 89530
// begin if GetControl ( vehicle ) = control_manual then
89323: LD_VAR 0 1
89327: PPUSH
89328: CALL_OW 263
89332: PUSH
89333: LD_INT 1
89335: EQUAL
89336: IFFALSE 89417
// begin driver := IsDrivenBy ( vehicle ) ;
89338: LD_ADDR_VAR 0 4
89342: PUSH
89343: LD_VAR 0 1
89347: PPUSH
89348: CALL_OW 311
89352: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89353: LD_VAR 0 4
89357: PPUSH
89358: LD_EXP 86
89362: PUSH
89363: LD_VAR 0 2
89367: ARRAY
89368: PUSH
89369: LD_INT 3
89371: ARRAY
89372: PPUSH
89373: LD_EXP 86
89377: PUSH
89378: LD_VAR 0 2
89382: ARRAY
89383: PUSH
89384: LD_INT 4
89386: ARRAY
89387: PPUSH
89388: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89392: LD_VAR 0 4
89396: PPUSH
89397: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89401: LD_VAR 0 4
89405: PPUSH
89406: LD_VAR 0 2
89410: PPUSH
89411: CALL_OW 180
// end else
89415: GO 89530
// if GetControl ( vehicle ) = control_remote then
89417: LD_VAR 0 1
89421: PPUSH
89422: CALL_OW 263
89426: PUSH
89427: LD_INT 2
89429: EQUAL
89430: IFFALSE 89491
// begin wait ( 0 0$2 ) ;
89432: LD_INT 70
89434: PPUSH
89435: CALL_OW 67
// if Connect ( vehicle ) then
89439: LD_VAR 0 1
89443: PPUSH
89444: CALL 18984 0 1
89448: IFFALSE 89489
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89450: LD_VAR 0 1
89454: PPUSH
89455: LD_EXP 86
89459: PUSH
89460: LD_VAR 0 2
89464: ARRAY
89465: PUSH
89466: LD_INT 3
89468: ARRAY
89469: PPUSH
89470: LD_EXP 86
89474: PUSH
89475: LD_VAR 0 2
89479: ARRAY
89480: PUSH
89481: LD_INT 4
89483: ARRAY
89484: PPUSH
89485: CALL_OW 171
// end else
89489: GO 89530
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89491: LD_VAR 0 1
89495: PPUSH
89496: LD_EXP 86
89500: PUSH
89501: LD_VAR 0 2
89505: ARRAY
89506: PUSH
89507: LD_INT 3
89509: ARRAY
89510: PPUSH
89511: LD_EXP 86
89515: PUSH
89516: LD_VAR 0 2
89520: ARRAY
89521: PUSH
89522: LD_INT 4
89524: ARRAY
89525: PPUSH
89526: CALL_OW 171
// end ; end ;
89530: LD_VAR 0 3
89534: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89535: LD_INT 0
89537: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89538: LD_VAR 0 1
89542: PUSH
89543: LD_INT 250
89545: EQUAL
89546: PUSH
89547: LD_VAR 0 2
89551: PPUSH
89552: CALL_OW 264
89556: PUSH
89557: LD_EXP 74
89561: EQUAL
89562: AND
89563: IFFALSE 89584
// MinerPlaceMine ( unit , x , y ) ;
89565: LD_VAR 0 2
89569: PPUSH
89570: LD_VAR 0 4
89574: PPUSH
89575: LD_VAR 0 5
89579: PPUSH
89580: CALL 92312 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89584: LD_VAR 0 1
89588: PUSH
89589: LD_INT 251
89591: EQUAL
89592: PUSH
89593: LD_VAR 0 2
89597: PPUSH
89598: CALL_OW 264
89602: PUSH
89603: LD_EXP 74
89607: EQUAL
89608: AND
89609: IFFALSE 89630
// MinerDetonateMine ( unit , x , y ) ;
89611: LD_VAR 0 2
89615: PPUSH
89616: LD_VAR 0 4
89620: PPUSH
89621: LD_VAR 0 5
89625: PPUSH
89626: CALL 92589 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89630: LD_VAR 0 1
89634: PUSH
89635: LD_INT 252
89637: EQUAL
89638: PUSH
89639: LD_VAR 0 2
89643: PPUSH
89644: CALL_OW 264
89648: PUSH
89649: LD_EXP 74
89653: EQUAL
89654: AND
89655: IFFALSE 89676
// MinerCreateMinefield ( unit , x , y ) ;
89657: LD_VAR 0 2
89661: PPUSH
89662: LD_VAR 0 4
89666: PPUSH
89667: LD_VAR 0 5
89671: PPUSH
89672: CALL 93006 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89676: LD_VAR 0 1
89680: PUSH
89681: LD_INT 253
89683: EQUAL
89684: PUSH
89685: LD_VAR 0 2
89689: PPUSH
89690: CALL_OW 257
89694: PUSH
89695: LD_INT 5
89697: EQUAL
89698: AND
89699: IFFALSE 89720
// ComBinocular ( unit , x , y ) ;
89701: LD_VAR 0 2
89705: PPUSH
89706: LD_VAR 0 4
89710: PPUSH
89711: LD_VAR 0 5
89715: PPUSH
89716: CALL 93377 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89720: LD_VAR 0 1
89724: PUSH
89725: LD_INT 254
89727: EQUAL
89728: PUSH
89729: LD_VAR 0 2
89733: PPUSH
89734: CALL_OW 264
89738: PUSH
89739: LD_EXP 69
89743: EQUAL
89744: AND
89745: PUSH
89746: LD_VAR 0 3
89750: PPUSH
89751: CALL_OW 263
89755: PUSH
89756: LD_INT 3
89758: EQUAL
89759: AND
89760: IFFALSE 89776
// HackDestroyVehicle ( unit , selectedUnit ) ;
89762: LD_VAR 0 2
89766: PPUSH
89767: LD_VAR 0 3
89771: PPUSH
89772: CALL 91672 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89776: LD_VAR 0 1
89780: PUSH
89781: LD_INT 255
89783: EQUAL
89784: PUSH
89785: LD_VAR 0 2
89789: PPUSH
89790: CALL_OW 264
89794: PUSH
89795: LD_INT 14
89797: PUSH
89798: LD_INT 53
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: IN
89805: AND
89806: PUSH
89807: LD_VAR 0 4
89811: PPUSH
89812: LD_VAR 0 5
89816: PPUSH
89817: CALL_OW 488
89821: AND
89822: IFFALSE 89846
// CutTreeXYR ( unit , x , y , 12 ) ;
89824: LD_VAR 0 2
89828: PPUSH
89829: LD_VAR 0 4
89833: PPUSH
89834: LD_VAR 0 5
89838: PPUSH
89839: LD_INT 12
89841: PPUSH
89842: CALL 90238 0 4
// if cmd = 256 then
89846: LD_VAR 0 1
89850: PUSH
89851: LD_INT 256
89853: EQUAL
89854: IFFALSE 89875
// SetFactoryWaypoint ( unit , x , y ) ;
89856: LD_VAR 0 2
89860: PPUSH
89861: LD_VAR 0 4
89865: PPUSH
89866: LD_VAR 0 5
89870: PPUSH
89871: CALL 89880 0 3
// end ;
89875: LD_VAR 0 6
89879: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
89880: LD_INT 0
89882: PPUSH
89883: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
89884: LD_VAR 0 1
89888: NOT
89889: PUSH
89890: LD_VAR 0 2
89894: PPUSH
89895: LD_VAR 0 3
89899: PPUSH
89900: CALL_OW 488
89904: NOT
89905: OR
89906: PUSH
89907: LD_VAR 0 1
89911: PPUSH
89912: CALL_OW 266
89916: PUSH
89917: LD_INT 3
89919: NONEQUAL
89920: PUSH
89921: LD_VAR 0 1
89925: PPUSH
89926: CALL_OW 247
89930: PUSH
89931: LD_INT 1
89933: EQUAL
89934: NOT
89935: AND
89936: OR
89937: IFFALSE 89941
// exit ;
89939: GO 90090
// if GetType ( factory ) = unit_human then
89941: LD_VAR 0 1
89945: PPUSH
89946: CALL_OW 247
89950: PUSH
89951: LD_INT 1
89953: EQUAL
89954: IFFALSE 89971
// factory := IsInUnit ( factory ) ;
89956: LD_ADDR_VAR 0 1
89960: PUSH
89961: LD_VAR 0 1
89965: PPUSH
89966: CALL_OW 310
89970: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
89971: LD_VAR 0 1
89975: PPUSH
89976: CALL_OW 266
89980: PUSH
89981: LD_INT 3
89983: NONEQUAL
89984: IFFALSE 89988
// exit ;
89986: GO 90090
// if HexInfo ( x , y ) = factory then
89988: LD_VAR 0 2
89992: PPUSH
89993: LD_VAR 0 3
89997: PPUSH
89998: CALL_OW 428
90002: PUSH
90003: LD_VAR 0 1
90007: EQUAL
90008: IFFALSE 90035
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
90010: LD_ADDR_EXP 86
90014: PUSH
90015: LD_EXP 86
90019: PPUSH
90020: LD_VAR 0 1
90024: PPUSH
90025: LD_INT 0
90027: PPUSH
90028: CALL_OW 1
90032: ST_TO_ADDR
90033: GO 90086
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
90035: LD_ADDR_EXP 86
90039: PUSH
90040: LD_EXP 86
90044: PPUSH
90045: LD_VAR 0 1
90049: PPUSH
90050: LD_VAR 0 1
90054: PPUSH
90055: CALL_OW 255
90059: PUSH
90060: LD_VAR 0 1
90064: PUSH
90065: LD_VAR 0 2
90069: PUSH
90070: LD_VAR 0 3
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: PPUSH
90081: CALL_OW 1
90085: ST_TO_ADDR
// UpdateFactoryWaypoints ;
90086: CALL 90095 0 0
// end ;
90090: LD_VAR 0 4
90094: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
90095: LD_INT 0
90097: PPUSH
90098: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
90099: LD_STRING resetFactoryWaypoint();
90101: PPUSH
90102: CALL_OW 559
// if factoryWaypoints then
90106: LD_EXP 86
90110: IFFALSE 90233
// begin for i := 1 to factoryWaypoints do
90112: LD_ADDR_VAR 0 2
90116: PUSH
90117: DOUBLE
90118: LD_INT 1
90120: DEC
90121: ST_TO_ADDR
90122: LD_EXP 86
90126: PUSH
90127: FOR_TO
90128: IFFALSE 90231
// if factoryWaypoints [ i ] then
90130: LD_EXP 86
90134: PUSH
90135: LD_VAR 0 2
90139: ARRAY
90140: IFFALSE 90229
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
90142: LD_STRING setFactoryWaypointXY(
90144: PUSH
90145: LD_EXP 86
90149: PUSH
90150: LD_VAR 0 2
90154: ARRAY
90155: PUSH
90156: LD_INT 1
90158: ARRAY
90159: STR
90160: PUSH
90161: LD_STRING ,
90163: STR
90164: PUSH
90165: LD_EXP 86
90169: PUSH
90170: LD_VAR 0 2
90174: ARRAY
90175: PUSH
90176: LD_INT 2
90178: ARRAY
90179: STR
90180: PUSH
90181: LD_STRING ,
90183: STR
90184: PUSH
90185: LD_EXP 86
90189: PUSH
90190: LD_VAR 0 2
90194: ARRAY
90195: PUSH
90196: LD_INT 3
90198: ARRAY
90199: STR
90200: PUSH
90201: LD_STRING ,
90203: STR
90204: PUSH
90205: LD_EXP 86
90209: PUSH
90210: LD_VAR 0 2
90214: ARRAY
90215: PUSH
90216: LD_INT 4
90218: ARRAY
90219: STR
90220: PUSH
90221: LD_STRING )
90223: STR
90224: PPUSH
90225: CALL_OW 559
90229: GO 90127
90231: POP
90232: POP
// end ; end ;
90233: LD_VAR 0 1
90237: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90238: LD_INT 0
90240: PPUSH
90241: PPUSH
90242: PPUSH
90243: PPUSH
90244: PPUSH
90245: PPUSH
90246: PPUSH
90247: PPUSH
90248: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90249: LD_VAR 0 1
90253: NOT
90254: PUSH
90255: LD_VAR 0 2
90259: PPUSH
90260: LD_VAR 0 3
90264: PPUSH
90265: CALL_OW 488
90269: NOT
90270: OR
90271: PUSH
90272: LD_VAR 0 4
90276: NOT
90277: OR
90278: IFFALSE 90282
// exit ;
90280: GO 90622
// list := [ ] ;
90282: LD_ADDR_VAR 0 13
90286: PUSH
90287: EMPTY
90288: ST_TO_ADDR
// if x - r < 0 then
90289: LD_VAR 0 2
90293: PUSH
90294: LD_VAR 0 4
90298: MINUS
90299: PUSH
90300: LD_INT 0
90302: LESS
90303: IFFALSE 90315
// min_x := 0 else
90305: LD_ADDR_VAR 0 7
90309: PUSH
90310: LD_INT 0
90312: ST_TO_ADDR
90313: GO 90331
// min_x := x - r ;
90315: LD_ADDR_VAR 0 7
90319: PUSH
90320: LD_VAR 0 2
90324: PUSH
90325: LD_VAR 0 4
90329: MINUS
90330: ST_TO_ADDR
// if y - r < 0 then
90331: LD_VAR 0 3
90335: PUSH
90336: LD_VAR 0 4
90340: MINUS
90341: PUSH
90342: LD_INT 0
90344: LESS
90345: IFFALSE 90357
// min_y := 0 else
90347: LD_ADDR_VAR 0 8
90351: PUSH
90352: LD_INT 0
90354: ST_TO_ADDR
90355: GO 90373
// min_y := y - r ;
90357: LD_ADDR_VAR 0 8
90361: PUSH
90362: LD_VAR 0 3
90366: PUSH
90367: LD_VAR 0 4
90371: MINUS
90372: ST_TO_ADDR
// max_x := x + r ;
90373: LD_ADDR_VAR 0 9
90377: PUSH
90378: LD_VAR 0 2
90382: PUSH
90383: LD_VAR 0 4
90387: PLUS
90388: ST_TO_ADDR
// max_y := y + r ;
90389: LD_ADDR_VAR 0 10
90393: PUSH
90394: LD_VAR 0 3
90398: PUSH
90399: LD_VAR 0 4
90403: PLUS
90404: ST_TO_ADDR
// for _x = min_x to max_x do
90405: LD_ADDR_VAR 0 11
90409: PUSH
90410: DOUBLE
90411: LD_VAR 0 7
90415: DEC
90416: ST_TO_ADDR
90417: LD_VAR 0 9
90421: PUSH
90422: FOR_TO
90423: IFFALSE 90540
// for _y = min_y to max_y do
90425: LD_ADDR_VAR 0 12
90429: PUSH
90430: DOUBLE
90431: LD_VAR 0 8
90435: DEC
90436: ST_TO_ADDR
90437: LD_VAR 0 10
90441: PUSH
90442: FOR_TO
90443: IFFALSE 90536
// begin if not ValidHex ( _x , _y ) then
90445: LD_VAR 0 11
90449: PPUSH
90450: LD_VAR 0 12
90454: PPUSH
90455: CALL_OW 488
90459: NOT
90460: IFFALSE 90464
// continue ;
90462: GO 90442
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90464: LD_VAR 0 11
90468: PPUSH
90469: LD_VAR 0 12
90473: PPUSH
90474: CALL_OW 351
90478: PUSH
90479: LD_VAR 0 11
90483: PPUSH
90484: LD_VAR 0 12
90488: PPUSH
90489: CALL_OW 554
90493: AND
90494: IFFALSE 90534
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90496: LD_ADDR_VAR 0 13
90500: PUSH
90501: LD_VAR 0 13
90505: PPUSH
90506: LD_VAR 0 13
90510: PUSH
90511: LD_INT 1
90513: PLUS
90514: PPUSH
90515: LD_VAR 0 11
90519: PUSH
90520: LD_VAR 0 12
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PPUSH
90529: CALL_OW 2
90533: ST_TO_ADDR
// end ;
90534: GO 90442
90536: POP
90537: POP
90538: GO 90422
90540: POP
90541: POP
// if not list then
90542: LD_VAR 0 13
90546: NOT
90547: IFFALSE 90551
// exit ;
90549: GO 90622
// for i in list do
90551: LD_ADDR_VAR 0 6
90555: PUSH
90556: LD_VAR 0 13
90560: PUSH
90561: FOR_IN
90562: IFFALSE 90620
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90564: LD_VAR 0 1
90568: PPUSH
90569: LD_STRING M
90571: PUSH
90572: LD_VAR 0 6
90576: PUSH
90577: LD_INT 1
90579: ARRAY
90580: PUSH
90581: LD_VAR 0 6
90585: PUSH
90586: LD_INT 2
90588: ARRAY
90589: PUSH
90590: LD_INT 0
90592: PUSH
90593: LD_INT 0
90595: PUSH
90596: LD_INT 0
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: PUSH
90611: EMPTY
90612: LIST
90613: PPUSH
90614: CALL_OW 447
90618: GO 90561
90620: POP
90621: POP
// end ;
90622: LD_VAR 0 5
90626: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90627: LD_EXP 87
90631: NOT
90632: IFFALSE 90682
90634: GO 90636
90636: DISABLE
// begin initHack := true ;
90637: LD_ADDR_EXP 87
90641: PUSH
90642: LD_INT 1
90644: ST_TO_ADDR
// hackTanks := [ ] ;
90645: LD_ADDR_EXP 88
90649: PUSH
90650: EMPTY
90651: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90652: LD_ADDR_EXP 89
90656: PUSH
90657: EMPTY
90658: ST_TO_ADDR
// hackLimit := 3 ;
90659: LD_ADDR_EXP 90
90663: PUSH
90664: LD_INT 3
90666: ST_TO_ADDR
// hackDist := 12 ;
90667: LD_ADDR_EXP 91
90671: PUSH
90672: LD_INT 12
90674: ST_TO_ADDR
// hackCounter := [ ] ;
90675: LD_ADDR_EXP 92
90679: PUSH
90680: EMPTY
90681: ST_TO_ADDR
// end ;
90682: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90683: LD_EXP 87
90687: PUSH
90688: LD_INT 34
90690: PUSH
90691: LD_EXP 69
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PPUSH
90700: CALL_OW 69
90704: AND
90705: IFFALSE 90960
90707: GO 90709
90709: DISABLE
90710: LD_INT 0
90712: PPUSH
90713: PPUSH
// begin enable ;
90714: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90715: LD_ADDR_VAR 0 1
90719: PUSH
90720: LD_INT 34
90722: PUSH
90723: LD_EXP 69
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: PPUSH
90732: CALL_OW 69
90736: PUSH
90737: FOR_IN
90738: IFFALSE 90958
// begin if not i in hackTanks then
90740: LD_VAR 0 1
90744: PUSH
90745: LD_EXP 88
90749: IN
90750: NOT
90751: IFFALSE 90834
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90753: LD_ADDR_EXP 88
90757: PUSH
90758: LD_EXP 88
90762: PPUSH
90763: LD_EXP 88
90767: PUSH
90768: LD_INT 1
90770: PLUS
90771: PPUSH
90772: LD_VAR 0 1
90776: PPUSH
90777: CALL_OW 1
90781: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90782: LD_ADDR_EXP 89
90786: PUSH
90787: LD_EXP 89
90791: PPUSH
90792: LD_EXP 89
90796: PUSH
90797: LD_INT 1
90799: PLUS
90800: PPUSH
90801: EMPTY
90802: PPUSH
90803: CALL_OW 1
90807: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90808: LD_ADDR_EXP 92
90812: PUSH
90813: LD_EXP 92
90817: PPUSH
90818: LD_EXP 92
90822: PUSH
90823: LD_INT 1
90825: PLUS
90826: PPUSH
90827: EMPTY
90828: PPUSH
90829: CALL_OW 1
90833: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90834: LD_VAR 0 1
90838: PPUSH
90839: CALL_OW 302
90843: NOT
90844: IFFALSE 90857
// begin HackUnlinkAll ( i ) ;
90846: LD_VAR 0 1
90850: PPUSH
90851: CALL 90963 0 1
// continue ;
90855: GO 90737
// end ; HackCheckCapturedStatus ( i ) ;
90857: LD_VAR 0 1
90861: PPUSH
90862: CALL 91406 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90866: LD_ADDR_VAR 0 2
90870: PUSH
90871: LD_INT 81
90873: PUSH
90874: LD_VAR 0 1
90878: PPUSH
90879: CALL_OW 255
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: LD_INT 33
90890: PUSH
90891: LD_INT 3
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 91
90900: PUSH
90901: LD_VAR 0 1
90905: PUSH
90906: LD_EXP 91
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: LIST
90915: PUSH
90916: LD_INT 50
90918: PUSH
90919: EMPTY
90920: LIST
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: PPUSH
90928: CALL_OW 69
90932: ST_TO_ADDR
// if not tmp then
90933: LD_VAR 0 2
90937: NOT
90938: IFFALSE 90942
// continue ;
90940: GO 90737
// HackLink ( i , tmp ) ;
90942: LD_VAR 0 1
90946: PPUSH
90947: LD_VAR 0 2
90951: PPUSH
90952: CALL 91099 0 2
// end ;
90956: GO 90737
90958: POP
90959: POP
// end ;
90960: PPOPN 2
90962: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90963: LD_INT 0
90965: PPUSH
90966: PPUSH
90967: PPUSH
// if not hack in hackTanks then
90968: LD_VAR 0 1
90972: PUSH
90973: LD_EXP 88
90977: IN
90978: NOT
90979: IFFALSE 90983
// exit ;
90981: GO 91094
// index := GetElementIndex ( hackTanks , hack ) ;
90983: LD_ADDR_VAR 0 4
90987: PUSH
90988: LD_EXP 88
90992: PPUSH
90993: LD_VAR 0 1
90997: PPUSH
90998: CALL 15798 0 2
91002: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91003: LD_EXP 89
91007: PUSH
91008: LD_VAR 0 4
91012: ARRAY
91013: IFFALSE 91094
// begin for i in hackTanksCaptured [ index ] do
91015: LD_ADDR_VAR 0 3
91019: PUSH
91020: LD_EXP 89
91024: PUSH
91025: LD_VAR 0 4
91029: ARRAY
91030: PUSH
91031: FOR_IN
91032: IFFALSE 91058
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91034: LD_VAR 0 3
91038: PUSH
91039: LD_INT 1
91041: ARRAY
91042: PPUSH
91043: LD_VAR 0 3
91047: PUSH
91048: LD_INT 2
91050: ARRAY
91051: PPUSH
91052: CALL_OW 235
91056: GO 91031
91058: POP
91059: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91060: LD_ADDR_EXP 89
91064: PUSH
91065: LD_EXP 89
91069: PPUSH
91070: LD_VAR 0 4
91074: PPUSH
91075: EMPTY
91076: PPUSH
91077: CALL_OW 1
91081: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91082: LD_VAR 0 1
91086: PPUSH
91087: LD_INT 0
91089: PPUSH
91090: CALL_OW 505
// end ; end ;
91094: LD_VAR 0 2
91098: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91099: LD_INT 0
91101: PPUSH
91102: PPUSH
91103: PPUSH
// if not hack in hackTanks or not vehicles then
91104: LD_VAR 0 1
91108: PUSH
91109: LD_EXP 88
91113: IN
91114: NOT
91115: PUSH
91116: LD_VAR 0 2
91120: NOT
91121: OR
91122: IFFALSE 91126
// exit ;
91124: GO 91401
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91126: LD_ADDR_VAR 0 2
91130: PUSH
91131: LD_VAR 0 1
91135: PPUSH
91136: LD_VAR 0 2
91140: PPUSH
91141: LD_INT 1
91143: PPUSH
91144: LD_INT 1
91146: PPUSH
91147: CALL 16448 0 4
91151: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91152: LD_ADDR_VAR 0 5
91156: PUSH
91157: LD_EXP 88
91161: PPUSH
91162: LD_VAR 0 1
91166: PPUSH
91167: CALL 15798 0 2
91171: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
91172: LD_EXP 89
91176: PUSH
91177: LD_VAR 0 5
91181: ARRAY
91182: PUSH
91183: LD_EXP 90
91187: LESS
91188: IFFALSE 91377
// begin for i := 1 to vehicles do
91190: LD_ADDR_VAR 0 4
91194: PUSH
91195: DOUBLE
91196: LD_INT 1
91198: DEC
91199: ST_TO_ADDR
91200: LD_VAR 0 2
91204: PUSH
91205: FOR_TO
91206: IFFALSE 91375
// begin if hackTanksCaptured [ index ] = hackLimit then
91208: LD_EXP 89
91212: PUSH
91213: LD_VAR 0 5
91217: ARRAY
91218: PUSH
91219: LD_EXP 90
91223: EQUAL
91224: IFFALSE 91228
// break ;
91226: GO 91375
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
91228: LD_ADDR_EXP 92
91232: PUSH
91233: LD_EXP 92
91237: PPUSH
91238: LD_VAR 0 5
91242: PPUSH
91243: LD_EXP 92
91247: PUSH
91248: LD_VAR 0 5
91252: ARRAY
91253: PUSH
91254: LD_INT 1
91256: PLUS
91257: PPUSH
91258: CALL_OW 1
91262: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91263: LD_ADDR_EXP 89
91267: PUSH
91268: LD_EXP 89
91272: PPUSH
91273: LD_VAR 0 5
91277: PUSH
91278: LD_EXP 89
91282: PUSH
91283: LD_VAR 0 5
91287: ARRAY
91288: PUSH
91289: LD_INT 1
91291: PLUS
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PPUSH
91297: LD_VAR 0 2
91301: PUSH
91302: LD_VAR 0 4
91306: ARRAY
91307: PUSH
91308: LD_VAR 0 2
91312: PUSH
91313: LD_VAR 0 4
91317: ARRAY
91318: PPUSH
91319: CALL_OW 255
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: PPUSH
91328: CALL 16013 0 3
91332: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91333: LD_VAR 0 2
91337: PUSH
91338: LD_VAR 0 4
91342: ARRAY
91343: PPUSH
91344: LD_VAR 0 1
91348: PPUSH
91349: CALL_OW 255
91353: PPUSH
91354: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91358: LD_VAR 0 2
91362: PUSH
91363: LD_VAR 0 4
91367: ARRAY
91368: PPUSH
91369: CALL_OW 141
// end ;
91373: GO 91205
91375: POP
91376: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91377: LD_VAR 0 1
91381: PPUSH
91382: LD_EXP 89
91386: PUSH
91387: LD_VAR 0 5
91391: ARRAY
91392: PUSH
91393: LD_INT 0
91395: PLUS
91396: PPUSH
91397: CALL_OW 505
// end ;
91401: LD_VAR 0 3
91405: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91406: LD_INT 0
91408: PPUSH
91409: PPUSH
91410: PPUSH
91411: PPUSH
// if not hack in hackTanks then
91412: LD_VAR 0 1
91416: PUSH
91417: LD_EXP 88
91421: IN
91422: NOT
91423: IFFALSE 91427
// exit ;
91425: GO 91667
// index := GetElementIndex ( hackTanks , hack ) ;
91427: LD_ADDR_VAR 0 4
91431: PUSH
91432: LD_EXP 88
91436: PPUSH
91437: LD_VAR 0 1
91441: PPUSH
91442: CALL 15798 0 2
91446: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91447: LD_ADDR_VAR 0 3
91451: PUSH
91452: DOUBLE
91453: LD_EXP 89
91457: PUSH
91458: LD_VAR 0 4
91462: ARRAY
91463: INC
91464: ST_TO_ADDR
91465: LD_INT 1
91467: PUSH
91468: FOR_DOWNTO
91469: IFFALSE 91641
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91471: LD_ADDR_VAR 0 5
91475: PUSH
91476: LD_EXP 89
91480: PUSH
91481: LD_VAR 0 4
91485: ARRAY
91486: PUSH
91487: LD_VAR 0 3
91491: ARRAY
91492: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91493: LD_VAR 0 5
91497: PUSH
91498: LD_INT 1
91500: ARRAY
91501: PPUSH
91502: CALL_OW 302
91506: NOT
91507: PUSH
91508: LD_VAR 0 5
91512: PUSH
91513: LD_INT 1
91515: ARRAY
91516: PPUSH
91517: CALL_OW 255
91521: PUSH
91522: LD_VAR 0 1
91526: PPUSH
91527: CALL_OW 255
91531: NONEQUAL
91532: OR
91533: IFFALSE 91639
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91535: LD_VAR 0 5
91539: PUSH
91540: LD_INT 1
91542: ARRAY
91543: PPUSH
91544: CALL_OW 305
91548: PUSH
91549: LD_VAR 0 5
91553: PUSH
91554: LD_INT 1
91556: ARRAY
91557: PPUSH
91558: CALL_OW 255
91562: PUSH
91563: LD_VAR 0 1
91567: PPUSH
91568: CALL_OW 255
91572: EQUAL
91573: AND
91574: IFFALSE 91598
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91576: LD_VAR 0 5
91580: PUSH
91581: LD_INT 1
91583: ARRAY
91584: PPUSH
91585: LD_VAR 0 5
91589: PUSH
91590: LD_INT 2
91592: ARRAY
91593: PPUSH
91594: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91598: LD_ADDR_EXP 89
91602: PUSH
91603: LD_EXP 89
91607: PPUSH
91608: LD_VAR 0 4
91612: PPUSH
91613: LD_EXP 89
91617: PUSH
91618: LD_VAR 0 4
91622: ARRAY
91623: PPUSH
91624: LD_VAR 0 3
91628: PPUSH
91629: CALL_OW 3
91633: PPUSH
91634: CALL_OW 1
91638: ST_TO_ADDR
// end ; end ;
91639: GO 91468
91641: POP
91642: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91643: LD_VAR 0 1
91647: PPUSH
91648: LD_EXP 89
91652: PUSH
91653: LD_VAR 0 4
91657: ARRAY
91658: PUSH
91659: LD_INT 0
91661: PLUS
91662: PPUSH
91663: CALL_OW 505
// end ;
91667: LD_VAR 0 2
91671: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91672: LD_INT 0
91674: PPUSH
91675: PPUSH
91676: PPUSH
91677: PPUSH
// if not hack in hackTanks then
91678: LD_VAR 0 1
91682: PUSH
91683: LD_EXP 88
91687: IN
91688: NOT
91689: IFFALSE 91693
// exit ;
91691: GO 91778
// index := GetElementIndex ( hackTanks , hack ) ;
91693: LD_ADDR_VAR 0 5
91697: PUSH
91698: LD_EXP 88
91702: PPUSH
91703: LD_VAR 0 1
91707: PPUSH
91708: CALL 15798 0 2
91712: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91713: LD_ADDR_VAR 0 4
91717: PUSH
91718: DOUBLE
91719: LD_INT 1
91721: DEC
91722: ST_TO_ADDR
91723: LD_EXP 89
91727: PUSH
91728: LD_VAR 0 5
91732: ARRAY
91733: PUSH
91734: FOR_TO
91735: IFFALSE 91776
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91737: LD_EXP 89
91741: PUSH
91742: LD_VAR 0 5
91746: ARRAY
91747: PUSH
91748: LD_VAR 0 4
91752: ARRAY
91753: PUSH
91754: LD_INT 1
91756: ARRAY
91757: PUSH
91758: LD_VAR 0 2
91762: EQUAL
91763: IFFALSE 91774
// KillUnit ( vehicle ) ;
91765: LD_VAR 0 2
91769: PPUSH
91770: CALL_OW 66
91774: GO 91734
91776: POP
91777: POP
// end ;
91778: LD_VAR 0 3
91782: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91783: LD_EXP 93
91787: NOT
91788: IFFALSE 91823
91790: GO 91792
91792: DISABLE
// begin initMiner := true ;
91793: LD_ADDR_EXP 93
91797: PUSH
91798: LD_INT 1
91800: ST_TO_ADDR
// minersList := [ ] ;
91801: LD_ADDR_EXP 94
91805: PUSH
91806: EMPTY
91807: ST_TO_ADDR
// minerMinesList := [ ] ;
91808: LD_ADDR_EXP 95
91812: PUSH
91813: EMPTY
91814: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91815: LD_ADDR_EXP 96
91819: PUSH
91820: LD_INT 5
91822: ST_TO_ADDR
// end ;
91823: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91824: LD_EXP 93
91828: PUSH
91829: LD_INT 34
91831: PUSH
91832: LD_EXP 74
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PPUSH
91841: CALL_OW 69
91845: AND
91846: IFFALSE 92309
91848: GO 91850
91850: DISABLE
91851: LD_INT 0
91853: PPUSH
91854: PPUSH
91855: PPUSH
91856: PPUSH
// begin enable ;
91857: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91858: LD_ADDR_VAR 0 1
91862: PUSH
91863: LD_INT 34
91865: PUSH
91866: LD_EXP 74
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PPUSH
91875: CALL_OW 69
91879: PUSH
91880: FOR_IN
91881: IFFALSE 91953
// begin if not i in minersList then
91883: LD_VAR 0 1
91887: PUSH
91888: LD_EXP 94
91892: IN
91893: NOT
91894: IFFALSE 91951
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91896: LD_ADDR_EXP 94
91900: PUSH
91901: LD_EXP 94
91905: PPUSH
91906: LD_EXP 94
91910: PUSH
91911: LD_INT 1
91913: PLUS
91914: PPUSH
91915: LD_VAR 0 1
91919: PPUSH
91920: CALL_OW 1
91924: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91925: LD_ADDR_EXP 95
91929: PUSH
91930: LD_EXP 95
91934: PPUSH
91935: LD_EXP 95
91939: PUSH
91940: LD_INT 1
91942: PLUS
91943: PPUSH
91944: EMPTY
91945: PPUSH
91946: CALL_OW 1
91950: ST_TO_ADDR
// end end ;
91951: GO 91880
91953: POP
91954: POP
// for i := minerMinesList downto 1 do
91955: LD_ADDR_VAR 0 1
91959: PUSH
91960: DOUBLE
91961: LD_EXP 95
91965: INC
91966: ST_TO_ADDR
91967: LD_INT 1
91969: PUSH
91970: FOR_DOWNTO
91971: IFFALSE 92307
// begin if IsLive ( minersList [ i ] ) then
91973: LD_EXP 94
91977: PUSH
91978: LD_VAR 0 1
91982: ARRAY
91983: PPUSH
91984: CALL_OW 300
91988: IFFALSE 92016
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91990: LD_EXP 94
91994: PUSH
91995: LD_VAR 0 1
91999: ARRAY
92000: PPUSH
92001: LD_EXP 95
92005: PUSH
92006: LD_VAR 0 1
92010: ARRAY
92011: PPUSH
92012: CALL_OW 505
// if not minerMinesList [ i ] then
92016: LD_EXP 95
92020: PUSH
92021: LD_VAR 0 1
92025: ARRAY
92026: NOT
92027: IFFALSE 92031
// continue ;
92029: GO 91970
// for j := minerMinesList [ i ] downto 1 do
92031: LD_ADDR_VAR 0 2
92035: PUSH
92036: DOUBLE
92037: LD_EXP 95
92041: PUSH
92042: LD_VAR 0 1
92046: ARRAY
92047: INC
92048: ST_TO_ADDR
92049: LD_INT 1
92051: PUSH
92052: FOR_DOWNTO
92053: IFFALSE 92303
// begin side := GetSide ( minersList [ i ] ) ;
92055: LD_ADDR_VAR 0 3
92059: PUSH
92060: LD_EXP 94
92064: PUSH
92065: LD_VAR 0 1
92069: ARRAY
92070: PPUSH
92071: CALL_OW 255
92075: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92076: LD_ADDR_VAR 0 4
92080: PUSH
92081: LD_EXP 95
92085: PUSH
92086: LD_VAR 0 1
92090: ARRAY
92091: PUSH
92092: LD_VAR 0 2
92096: ARRAY
92097: PUSH
92098: LD_INT 1
92100: ARRAY
92101: PPUSH
92102: LD_EXP 95
92106: PUSH
92107: LD_VAR 0 1
92111: ARRAY
92112: PUSH
92113: LD_VAR 0 2
92117: ARRAY
92118: PUSH
92119: LD_INT 2
92121: ARRAY
92122: PPUSH
92123: CALL_OW 428
92127: ST_TO_ADDR
// if not tmp then
92128: LD_VAR 0 4
92132: NOT
92133: IFFALSE 92137
// continue ;
92135: GO 92052
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92137: LD_VAR 0 4
92141: PUSH
92142: LD_INT 81
92144: PUSH
92145: LD_VAR 0 3
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PPUSH
92154: CALL_OW 69
92158: IN
92159: PUSH
92160: LD_EXP 95
92164: PUSH
92165: LD_VAR 0 1
92169: ARRAY
92170: PUSH
92171: LD_VAR 0 2
92175: ARRAY
92176: PUSH
92177: LD_INT 1
92179: ARRAY
92180: PPUSH
92181: LD_EXP 95
92185: PUSH
92186: LD_VAR 0 1
92190: ARRAY
92191: PUSH
92192: LD_VAR 0 2
92196: ARRAY
92197: PUSH
92198: LD_INT 2
92200: ARRAY
92201: PPUSH
92202: CALL_OW 458
92206: AND
92207: IFFALSE 92301
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
92209: LD_EXP 95
92213: PUSH
92214: LD_VAR 0 1
92218: ARRAY
92219: PUSH
92220: LD_VAR 0 2
92224: ARRAY
92225: PUSH
92226: LD_INT 1
92228: ARRAY
92229: PPUSH
92230: LD_EXP 95
92234: PUSH
92235: LD_VAR 0 1
92239: ARRAY
92240: PUSH
92241: LD_VAR 0 2
92245: ARRAY
92246: PUSH
92247: LD_INT 2
92249: ARRAY
92250: PPUSH
92251: LD_VAR 0 3
92255: PPUSH
92256: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92260: LD_ADDR_EXP 95
92264: PUSH
92265: LD_EXP 95
92269: PPUSH
92270: LD_VAR 0 1
92274: PPUSH
92275: LD_EXP 95
92279: PUSH
92280: LD_VAR 0 1
92284: ARRAY
92285: PPUSH
92286: LD_VAR 0 2
92290: PPUSH
92291: CALL_OW 3
92295: PPUSH
92296: CALL_OW 1
92300: ST_TO_ADDR
// end ; end ;
92301: GO 92052
92303: POP
92304: POP
// end ;
92305: GO 91970
92307: POP
92308: POP
// end ;
92309: PPOPN 4
92311: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92312: LD_INT 0
92314: PPUSH
92315: PPUSH
// result := false ;
92316: LD_ADDR_VAR 0 4
92320: PUSH
92321: LD_INT 0
92323: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92324: LD_VAR 0 1
92328: PPUSH
92329: CALL_OW 264
92333: PUSH
92334: LD_EXP 74
92338: EQUAL
92339: NOT
92340: IFFALSE 92344
// exit ;
92342: GO 92584
// index := GetElementIndex ( minersList , unit ) ;
92344: LD_ADDR_VAR 0 5
92348: PUSH
92349: LD_EXP 94
92353: PPUSH
92354: LD_VAR 0 1
92358: PPUSH
92359: CALL 15798 0 2
92363: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92364: LD_EXP 95
92368: PUSH
92369: LD_VAR 0 5
92373: ARRAY
92374: PUSH
92375: LD_EXP 96
92379: GREATEREQUAL
92380: IFFALSE 92384
// exit ;
92382: GO 92584
// ComMoveXY ( unit , x , y ) ;
92384: LD_VAR 0 1
92388: PPUSH
92389: LD_VAR 0 2
92393: PPUSH
92394: LD_VAR 0 3
92398: PPUSH
92399: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92403: LD_INT 35
92405: PPUSH
92406: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92410: LD_VAR 0 1
92414: PPUSH
92415: LD_VAR 0 2
92419: PPUSH
92420: LD_VAR 0 3
92424: PPUSH
92425: CALL 46517 0 3
92429: NOT
92430: PUSH
92431: LD_VAR 0 1
92435: PPUSH
92436: CALL_OW 314
92440: AND
92441: IFFALSE 92445
// exit ;
92443: GO 92584
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92445: LD_VAR 0 2
92449: PPUSH
92450: LD_VAR 0 3
92454: PPUSH
92455: CALL_OW 428
92459: PUSH
92460: LD_VAR 0 1
92464: EQUAL
92465: PUSH
92466: LD_VAR 0 1
92470: PPUSH
92471: CALL_OW 314
92475: NOT
92476: AND
92477: IFFALSE 92403
// PlaySoundXY ( x , y , PlantMine ) ;
92479: LD_VAR 0 2
92483: PPUSH
92484: LD_VAR 0 3
92488: PPUSH
92489: LD_STRING PlantMine
92491: PPUSH
92492: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92496: LD_VAR 0 2
92500: PPUSH
92501: LD_VAR 0 3
92505: PPUSH
92506: LD_VAR 0 1
92510: PPUSH
92511: CALL_OW 255
92515: PPUSH
92516: LD_INT 0
92518: PPUSH
92519: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92523: LD_ADDR_EXP 95
92527: PUSH
92528: LD_EXP 95
92532: PPUSH
92533: LD_VAR 0 5
92537: PUSH
92538: LD_EXP 95
92542: PUSH
92543: LD_VAR 0 5
92547: ARRAY
92548: PUSH
92549: LD_INT 1
92551: PLUS
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PPUSH
92557: LD_VAR 0 2
92561: PUSH
92562: LD_VAR 0 3
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PPUSH
92571: CALL 16013 0 3
92575: ST_TO_ADDR
// result := true ;
92576: LD_ADDR_VAR 0 4
92580: PUSH
92581: LD_INT 1
92583: ST_TO_ADDR
// end ;
92584: LD_VAR 0 4
92588: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92589: LD_INT 0
92591: PPUSH
92592: PPUSH
92593: PPUSH
// if not unit in minersList then
92594: LD_VAR 0 1
92598: PUSH
92599: LD_EXP 94
92603: IN
92604: NOT
92605: IFFALSE 92609
// exit ;
92607: GO 93001
// index := GetElementIndex ( minersList , unit ) ;
92609: LD_ADDR_VAR 0 6
92613: PUSH
92614: LD_EXP 94
92618: PPUSH
92619: LD_VAR 0 1
92623: PPUSH
92624: CALL 15798 0 2
92628: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92629: LD_ADDR_VAR 0 5
92633: PUSH
92634: DOUBLE
92635: LD_EXP 95
92639: PUSH
92640: LD_VAR 0 6
92644: ARRAY
92645: INC
92646: ST_TO_ADDR
92647: LD_INT 1
92649: PUSH
92650: FOR_DOWNTO
92651: IFFALSE 92812
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92653: LD_EXP 95
92657: PUSH
92658: LD_VAR 0 6
92662: ARRAY
92663: PUSH
92664: LD_VAR 0 5
92668: ARRAY
92669: PUSH
92670: LD_INT 1
92672: ARRAY
92673: PUSH
92674: LD_VAR 0 2
92678: EQUAL
92679: PUSH
92680: LD_EXP 95
92684: PUSH
92685: LD_VAR 0 6
92689: ARRAY
92690: PUSH
92691: LD_VAR 0 5
92695: ARRAY
92696: PUSH
92697: LD_INT 2
92699: ARRAY
92700: PUSH
92701: LD_VAR 0 3
92705: EQUAL
92706: AND
92707: IFFALSE 92810
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92709: LD_EXP 95
92713: PUSH
92714: LD_VAR 0 6
92718: ARRAY
92719: PUSH
92720: LD_VAR 0 5
92724: ARRAY
92725: PUSH
92726: LD_INT 1
92728: ARRAY
92729: PPUSH
92730: LD_EXP 95
92734: PUSH
92735: LD_VAR 0 6
92739: ARRAY
92740: PUSH
92741: LD_VAR 0 5
92745: ARRAY
92746: PUSH
92747: LD_INT 2
92749: ARRAY
92750: PPUSH
92751: LD_VAR 0 1
92755: PPUSH
92756: CALL_OW 255
92760: PPUSH
92761: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92765: LD_ADDR_EXP 95
92769: PUSH
92770: LD_EXP 95
92774: PPUSH
92775: LD_VAR 0 6
92779: PPUSH
92780: LD_EXP 95
92784: PUSH
92785: LD_VAR 0 6
92789: ARRAY
92790: PPUSH
92791: LD_VAR 0 5
92795: PPUSH
92796: CALL_OW 3
92800: PPUSH
92801: CALL_OW 1
92805: ST_TO_ADDR
// exit ;
92806: POP
92807: POP
92808: GO 93001
// end ; end ;
92810: GO 92650
92812: POP
92813: POP
// for i := minerMinesList [ index ] downto 1 do
92814: LD_ADDR_VAR 0 5
92818: PUSH
92819: DOUBLE
92820: LD_EXP 95
92824: PUSH
92825: LD_VAR 0 6
92829: ARRAY
92830: INC
92831: ST_TO_ADDR
92832: LD_INT 1
92834: PUSH
92835: FOR_DOWNTO
92836: IFFALSE 92999
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92838: LD_EXP 95
92842: PUSH
92843: LD_VAR 0 6
92847: ARRAY
92848: PUSH
92849: LD_VAR 0 5
92853: ARRAY
92854: PUSH
92855: LD_INT 1
92857: ARRAY
92858: PPUSH
92859: LD_EXP 95
92863: PUSH
92864: LD_VAR 0 6
92868: ARRAY
92869: PUSH
92870: LD_VAR 0 5
92874: ARRAY
92875: PUSH
92876: LD_INT 2
92878: ARRAY
92879: PPUSH
92880: LD_VAR 0 2
92884: PPUSH
92885: LD_VAR 0 3
92889: PPUSH
92890: CALL_OW 298
92894: PUSH
92895: LD_INT 6
92897: LESS
92898: IFFALSE 92997
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92900: LD_EXP 95
92904: PUSH
92905: LD_VAR 0 6
92909: ARRAY
92910: PUSH
92911: LD_VAR 0 5
92915: ARRAY
92916: PUSH
92917: LD_INT 1
92919: ARRAY
92920: PPUSH
92921: LD_EXP 95
92925: PUSH
92926: LD_VAR 0 6
92930: ARRAY
92931: PUSH
92932: LD_VAR 0 5
92936: ARRAY
92937: PUSH
92938: LD_INT 2
92940: ARRAY
92941: PPUSH
92942: LD_VAR 0 1
92946: PPUSH
92947: CALL_OW 255
92951: PPUSH
92952: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92956: LD_ADDR_EXP 95
92960: PUSH
92961: LD_EXP 95
92965: PPUSH
92966: LD_VAR 0 6
92970: PPUSH
92971: LD_EXP 95
92975: PUSH
92976: LD_VAR 0 6
92980: ARRAY
92981: PPUSH
92982: LD_VAR 0 5
92986: PPUSH
92987: CALL_OW 3
92991: PPUSH
92992: CALL_OW 1
92996: ST_TO_ADDR
// end ; end ;
92997: GO 92835
92999: POP
93000: POP
// end ;
93001: LD_VAR 0 4
93005: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93006: LD_INT 0
93008: PPUSH
93009: PPUSH
93010: PPUSH
93011: PPUSH
93012: PPUSH
93013: PPUSH
93014: PPUSH
93015: PPUSH
93016: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93017: LD_VAR 0 1
93021: PPUSH
93022: CALL_OW 264
93026: PUSH
93027: LD_EXP 74
93031: EQUAL
93032: NOT
93033: PUSH
93034: LD_VAR 0 1
93038: PUSH
93039: LD_EXP 94
93043: IN
93044: NOT
93045: OR
93046: IFFALSE 93050
// exit ;
93048: GO 93372
// index := GetElementIndex ( minersList , unit ) ;
93050: LD_ADDR_VAR 0 6
93054: PUSH
93055: LD_EXP 94
93059: PPUSH
93060: LD_VAR 0 1
93064: PPUSH
93065: CALL 15798 0 2
93069: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93070: LD_ADDR_VAR 0 8
93074: PUSH
93075: LD_EXP 96
93079: PUSH
93080: LD_EXP 95
93084: PUSH
93085: LD_VAR 0 6
93089: ARRAY
93090: MINUS
93091: ST_TO_ADDR
// if not minesFreeAmount then
93092: LD_VAR 0 8
93096: NOT
93097: IFFALSE 93101
// exit ;
93099: GO 93372
// tmp := [ ] ;
93101: LD_ADDR_VAR 0 7
93105: PUSH
93106: EMPTY
93107: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93108: LD_ADDR_VAR 0 5
93112: PUSH
93113: DOUBLE
93114: LD_INT 1
93116: DEC
93117: ST_TO_ADDR
93118: LD_VAR 0 8
93122: PUSH
93123: FOR_TO
93124: IFFALSE 93319
// begin _d := rand ( 0 , 5 ) ;
93126: LD_ADDR_VAR 0 11
93130: PUSH
93131: LD_INT 0
93133: PPUSH
93134: LD_INT 5
93136: PPUSH
93137: CALL_OW 12
93141: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93142: LD_ADDR_VAR 0 12
93146: PUSH
93147: LD_INT 2
93149: PPUSH
93150: LD_INT 6
93152: PPUSH
93153: CALL_OW 12
93157: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93158: LD_ADDR_VAR 0 9
93162: PUSH
93163: LD_VAR 0 2
93167: PPUSH
93168: LD_VAR 0 11
93172: PPUSH
93173: LD_VAR 0 12
93177: PPUSH
93178: CALL_OW 272
93182: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
93183: LD_ADDR_VAR 0 10
93187: PUSH
93188: LD_VAR 0 3
93192: PPUSH
93193: LD_VAR 0 11
93197: PPUSH
93198: LD_VAR 0 12
93202: PPUSH
93203: CALL_OW 273
93207: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
93208: LD_VAR 0 9
93212: PPUSH
93213: LD_VAR 0 10
93217: PPUSH
93218: CALL_OW 488
93222: PUSH
93223: LD_VAR 0 9
93227: PUSH
93228: LD_VAR 0 10
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_VAR 0 7
93241: IN
93242: NOT
93243: AND
93244: PUSH
93245: LD_VAR 0 9
93249: PPUSH
93250: LD_VAR 0 10
93254: PPUSH
93255: CALL_OW 458
93259: NOT
93260: AND
93261: IFFALSE 93303
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93263: LD_ADDR_VAR 0 7
93267: PUSH
93268: LD_VAR 0 7
93272: PPUSH
93273: LD_VAR 0 7
93277: PUSH
93278: LD_INT 1
93280: PLUS
93281: PPUSH
93282: LD_VAR 0 9
93286: PUSH
93287: LD_VAR 0 10
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PPUSH
93296: CALL_OW 1
93300: ST_TO_ADDR
93301: GO 93317
// i := i - 1 ;
93303: LD_ADDR_VAR 0 5
93307: PUSH
93308: LD_VAR 0 5
93312: PUSH
93313: LD_INT 1
93315: MINUS
93316: ST_TO_ADDR
// end ;
93317: GO 93123
93319: POP
93320: POP
// for i in tmp do
93321: LD_ADDR_VAR 0 5
93325: PUSH
93326: LD_VAR 0 7
93330: PUSH
93331: FOR_IN
93332: IFFALSE 93370
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93334: LD_VAR 0 1
93338: PPUSH
93339: LD_VAR 0 5
93343: PUSH
93344: LD_INT 1
93346: ARRAY
93347: PPUSH
93348: LD_VAR 0 5
93352: PUSH
93353: LD_INT 2
93355: ARRAY
93356: PPUSH
93357: CALL 92312 0 3
93361: NOT
93362: IFFALSE 93368
// exit ;
93364: POP
93365: POP
93366: GO 93372
93368: GO 93331
93370: POP
93371: POP
// end ;
93372: LD_VAR 0 4
93376: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93377: LD_INT 0
93379: PPUSH
93380: PPUSH
93381: PPUSH
93382: PPUSH
93383: PPUSH
93384: PPUSH
93385: PPUSH
// if not GetClass ( unit ) = class_sniper then
93386: LD_VAR 0 1
93390: PPUSH
93391: CALL_OW 257
93395: PUSH
93396: LD_INT 5
93398: EQUAL
93399: NOT
93400: IFFALSE 93404
// exit ;
93402: GO 93792
// dist := 8 ;
93404: LD_ADDR_VAR 0 5
93408: PUSH
93409: LD_INT 8
93411: ST_TO_ADDR
// viewRange := 12 ;
93412: LD_ADDR_VAR 0 7
93416: PUSH
93417: LD_INT 12
93419: ST_TO_ADDR
// side := GetSide ( unit ) ;
93420: LD_ADDR_VAR 0 6
93424: PUSH
93425: LD_VAR 0 1
93429: PPUSH
93430: CALL_OW 255
93434: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93435: LD_INT 61
93437: PPUSH
93438: LD_VAR 0 6
93442: PPUSH
93443: CALL_OW 321
93447: PUSH
93448: LD_INT 2
93450: EQUAL
93451: IFFALSE 93461
// viewRange := 16 ;
93453: LD_ADDR_VAR 0 7
93457: PUSH
93458: LD_INT 16
93460: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93461: LD_VAR 0 1
93465: PPUSH
93466: LD_VAR 0 2
93470: PPUSH
93471: LD_VAR 0 3
93475: PPUSH
93476: CALL_OW 297
93480: PUSH
93481: LD_VAR 0 5
93485: GREATER
93486: IFFALSE 93565
// begin ComMoveXY ( unit , x , y ) ;
93488: LD_VAR 0 1
93492: PPUSH
93493: LD_VAR 0 2
93497: PPUSH
93498: LD_VAR 0 3
93502: PPUSH
93503: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93507: LD_INT 35
93509: PPUSH
93510: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
93514: LD_VAR 0 1
93518: PPUSH
93519: LD_VAR 0 2
93523: PPUSH
93524: LD_VAR 0 3
93528: PPUSH
93529: CALL 46517 0 3
93533: NOT
93534: IFFALSE 93538
// exit ;
93536: GO 93792
// until GetDistUnitXY ( unit , x , y ) < dist ;
93538: LD_VAR 0 1
93542: PPUSH
93543: LD_VAR 0 2
93547: PPUSH
93548: LD_VAR 0 3
93552: PPUSH
93553: CALL_OW 297
93557: PUSH
93558: LD_VAR 0 5
93562: LESS
93563: IFFALSE 93507
// end ; ComTurnXY ( unit , x , y ) ;
93565: LD_VAR 0 1
93569: PPUSH
93570: LD_VAR 0 2
93574: PPUSH
93575: LD_VAR 0 3
93579: PPUSH
93580: CALL_OW 118
// wait ( 5 ) ;
93584: LD_INT 5
93586: PPUSH
93587: CALL_OW 67
// _d := GetDir ( unit ) ;
93591: LD_ADDR_VAR 0 10
93595: PUSH
93596: LD_VAR 0 1
93600: PPUSH
93601: CALL_OW 254
93605: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93606: LD_ADDR_VAR 0 8
93610: PUSH
93611: LD_VAR 0 1
93615: PPUSH
93616: CALL_OW 250
93620: PPUSH
93621: LD_VAR 0 10
93625: PPUSH
93626: LD_VAR 0 5
93630: PPUSH
93631: CALL_OW 272
93635: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93636: LD_ADDR_VAR 0 9
93640: PUSH
93641: LD_VAR 0 1
93645: PPUSH
93646: CALL_OW 251
93650: PPUSH
93651: LD_VAR 0 10
93655: PPUSH
93656: LD_VAR 0 5
93660: PPUSH
93661: CALL_OW 273
93665: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93666: LD_VAR 0 8
93670: PPUSH
93671: LD_VAR 0 9
93675: PPUSH
93676: CALL_OW 488
93680: NOT
93681: IFFALSE 93685
// exit ;
93683: GO 93792
// ComAnimCustom ( unit , 1 ) ;
93685: LD_VAR 0 1
93689: PPUSH
93690: LD_INT 1
93692: PPUSH
93693: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93697: LD_VAR 0 8
93701: PPUSH
93702: LD_VAR 0 9
93706: PPUSH
93707: LD_VAR 0 6
93711: PPUSH
93712: LD_VAR 0 7
93716: PPUSH
93717: CALL_OW 330
// repeat wait ( 1 ) ;
93721: LD_INT 1
93723: PPUSH
93724: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93728: LD_VAR 0 1
93732: PPUSH
93733: CALL_OW 316
93737: PUSH
93738: LD_VAR 0 1
93742: PPUSH
93743: CALL_OW 314
93747: OR
93748: PUSH
93749: LD_VAR 0 1
93753: PPUSH
93754: CALL_OW 302
93758: NOT
93759: OR
93760: PUSH
93761: LD_VAR 0 1
93765: PPUSH
93766: CALL_OW 301
93770: OR
93771: IFFALSE 93721
// RemoveSeeing ( _x , _y , side ) ;
93773: LD_VAR 0 8
93777: PPUSH
93778: LD_VAR 0 9
93782: PPUSH
93783: LD_VAR 0 6
93787: PPUSH
93788: CALL_OW 331
// end ; end_of_file end_of_file
93792: LD_VAR 0 4
93796: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93797: LD_VAR 0 1
93801: PUSH
93802: LD_INT 200
93804: DOUBLE
93805: GREATEREQUAL
93806: IFFALSE 93814
93808: LD_INT 299
93810: DOUBLE
93811: LESSEQUAL
93812: IFTRUE 93816
93814: GO 93848
93816: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93817: LD_VAR 0 1
93821: PPUSH
93822: LD_VAR 0 2
93826: PPUSH
93827: LD_VAR 0 3
93831: PPUSH
93832: LD_VAR 0 4
93836: PPUSH
93837: LD_VAR 0 5
93841: PPUSH
93842: CALL 89535 0 5
93846: GO 93925
93848: LD_INT 300
93850: DOUBLE
93851: GREATEREQUAL
93852: IFFALSE 93860
93854: LD_INT 399
93856: DOUBLE
93857: LESSEQUAL
93858: IFTRUE 93862
93860: GO 93924
93862: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93863: LD_VAR 0 1
93867: PPUSH
93868: LD_VAR 0 2
93872: PPUSH
93873: LD_VAR 0 3
93877: PPUSH
93878: LD_VAR 0 4
93882: PPUSH
93883: LD_VAR 0 5
93887: PPUSH
93888: LD_VAR 0 6
93892: PPUSH
93893: LD_VAR 0 7
93897: PPUSH
93898: LD_VAR 0 8
93902: PPUSH
93903: LD_VAR 0 9
93907: PPUSH
93908: LD_VAR 0 10
93912: PPUSH
93913: LD_VAR 0 11
93917: PPUSH
93918: CALL 106314 0 11
93922: GO 93925
93924: POP
// end ;
93925: PPOPN 11
93927: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93928: LD_VAR 0 1
93932: PPUSH
93933: LD_VAR 0 2
93937: PPUSH
93938: LD_VAR 0 3
93942: PPUSH
93943: LD_VAR 0 4
93947: PPUSH
93948: LD_VAR 0 5
93952: PPUSH
93953: CALL 89271 0 5
// end ; end_of_file
93957: PPOPN 5
93959: END
// every 0 0$1 do
93960: GO 93962
93962: DISABLE
// begin enable ;
93963: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93964: LD_STRING updateTimer(
93966: PUSH
93967: LD_OWVAR 1
93971: STR
93972: PUSH
93973: LD_STRING );
93975: STR
93976: PPUSH
93977: CALL_OW 559
// end ;
93981: END
// export function SOS_MapStart ( ) ; begin
93982: LD_INT 0
93984: PPUSH
// if streamModeActive then
93985: LD_EXP 97
93989: IFFALSE 93998
// DefineStreamItems ( true ) ;
93991: LD_INT 1
93993: PPUSH
93994: CALL 95648 0 1
// UpdateFactoryWaypoints ( ) ;
93998: CALL 90095 0 0
// end ;
94002: LD_VAR 0 1
94006: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94007: LD_INT 0
94009: PPUSH
// if p2 = 100 then
94010: LD_VAR 0 2
94014: PUSH
94015: LD_INT 100
94017: EQUAL
94018: IFFALSE 95021
// begin if not StreamModeActive then
94020: LD_EXP 97
94024: NOT
94025: IFFALSE 94035
// StreamModeActive := true ;
94027: LD_ADDR_EXP 97
94031: PUSH
94032: LD_INT 1
94034: ST_TO_ADDR
// if p3 = 0 then
94035: LD_VAR 0 3
94039: PUSH
94040: LD_INT 0
94042: EQUAL
94043: IFFALSE 94049
// InitStreamMode ;
94045: CALL 95184 0 0
// if p3 = 1 then
94049: LD_VAR 0 3
94053: PUSH
94054: LD_INT 1
94056: EQUAL
94057: IFFALSE 94067
// sRocket := true ;
94059: LD_ADDR_EXP 102
94063: PUSH
94064: LD_INT 1
94066: ST_TO_ADDR
// if p3 = 2 then
94067: LD_VAR 0 3
94071: PUSH
94072: LD_INT 2
94074: EQUAL
94075: IFFALSE 94085
// sSpeed := true ;
94077: LD_ADDR_EXP 101
94081: PUSH
94082: LD_INT 1
94084: ST_TO_ADDR
// if p3 = 3 then
94085: LD_VAR 0 3
94089: PUSH
94090: LD_INT 3
94092: EQUAL
94093: IFFALSE 94103
// sEngine := true ;
94095: LD_ADDR_EXP 103
94099: PUSH
94100: LD_INT 1
94102: ST_TO_ADDR
// if p3 = 4 then
94103: LD_VAR 0 3
94107: PUSH
94108: LD_INT 4
94110: EQUAL
94111: IFFALSE 94121
// sSpec := true ;
94113: LD_ADDR_EXP 100
94117: PUSH
94118: LD_INT 1
94120: ST_TO_ADDR
// if p3 = 5 then
94121: LD_VAR 0 3
94125: PUSH
94126: LD_INT 5
94128: EQUAL
94129: IFFALSE 94139
// sLevel := true ;
94131: LD_ADDR_EXP 104
94135: PUSH
94136: LD_INT 1
94138: ST_TO_ADDR
// if p3 = 6 then
94139: LD_VAR 0 3
94143: PUSH
94144: LD_INT 6
94146: EQUAL
94147: IFFALSE 94157
// sArmoury := true ;
94149: LD_ADDR_EXP 105
94153: PUSH
94154: LD_INT 1
94156: ST_TO_ADDR
// if p3 = 7 then
94157: LD_VAR 0 3
94161: PUSH
94162: LD_INT 7
94164: EQUAL
94165: IFFALSE 94175
// sRadar := true ;
94167: LD_ADDR_EXP 106
94171: PUSH
94172: LD_INT 1
94174: ST_TO_ADDR
// if p3 = 8 then
94175: LD_VAR 0 3
94179: PUSH
94180: LD_INT 8
94182: EQUAL
94183: IFFALSE 94193
// sBunker := true ;
94185: LD_ADDR_EXP 107
94189: PUSH
94190: LD_INT 1
94192: ST_TO_ADDR
// if p3 = 9 then
94193: LD_VAR 0 3
94197: PUSH
94198: LD_INT 9
94200: EQUAL
94201: IFFALSE 94211
// sHack := true ;
94203: LD_ADDR_EXP 108
94207: PUSH
94208: LD_INT 1
94210: ST_TO_ADDR
// if p3 = 10 then
94211: LD_VAR 0 3
94215: PUSH
94216: LD_INT 10
94218: EQUAL
94219: IFFALSE 94229
// sFire := true ;
94221: LD_ADDR_EXP 109
94225: PUSH
94226: LD_INT 1
94228: ST_TO_ADDR
// if p3 = 11 then
94229: LD_VAR 0 3
94233: PUSH
94234: LD_INT 11
94236: EQUAL
94237: IFFALSE 94247
// sRefresh := true ;
94239: LD_ADDR_EXP 110
94243: PUSH
94244: LD_INT 1
94246: ST_TO_ADDR
// if p3 = 12 then
94247: LD_VAR 0 3
94251: PUSH
94252: LD_INT 12
94254: EQUAL
94255: IFFALSE 94265
// sExp := true ;
94257: LD_ADDR_EXP 111
94261: PUSH
94262: LD_INT 1
94264: ST_TO_ADDR
// if p3 = 13 then
94265: LD_VAR 0 3
94269: PUSH
94270: LD_INT 13
94272: EQUAL
94273: IFFALSE 94283
// sDepot := true ;
94275: LD_ADDR_EXP 112
94279: PUSH
94280: LD_INT 1
94282: ST_TO_ADDR
// if p3 = 14 then
94283: LD_VAR 0 3
94287: PUSH
94288: LD_INT 14
94290: EQUAL
94291: IFFALSE 94301
// sFlag := true ;
94293: LD_ADDR_EXP 113
94297: PUSH
94298: LD_INT 1
94300: ST_TO_ADDR
// if p3 = 15 then
94301: LD_VAR 0 3
94305: PUSH
94306: LD_INT 15
94308: EQUAL
94309: IFFALSE 94319
// sKamikadze := true ;
94311: LD_ADDR_EXP 121
94315: PUSH
94316: LD_INT 1
94318: ST_TO_ADDR
// if p3 = 16 then
94319: LD_VAR 0 3
94323: PUSH
94324: LD_INT 16
94326: EQUAL
94327: IFFALSE 94337
// sTroll := true ;
94329: LD_ADDR_EXP 122
94333: PUSH
94334: LD_INT 1
94336: ST_TO_ADDR
// if p3 = 17 then
94337: LD_VAR 0 3
94341: PUSH
94342: LD_INT 17
94344: EQUAL
94345: IFFALSE 94355
// sSlow := true ;
94347: LD_ADDR_EXP 123
94351: PUSH
94352: LD_INT 1
94354: ST_TO_ADDR
// if p3 = 18 then
94355: LD_VAR 0 3
94359: PUSH
94360: LD_INT 18
94362: EQUAL
94363: IFFALSE 94373
// sLack := true ;
94365: LD_ADDR_EXP 124
94369: PUSH
94370: LD_INT 1
94372: ST_TO_ADDR
// if p3 = 19 then
94373: LD_VAR 0 3
94377: PUSH
94378: LD_INT 19
94380: EQUAL
94381: IFFALSE 94391
// sTank := true ;
94383: LD_ADDR_EXP 126
94387: PUSH
94388: LD_INT 1
94390: ST_TO_ADDR
// if p3 = 20 then
94391: LD_VAR 0 3
94395: PUSH
94396: LD_INT 20
94398: EQUAL
94399: IFFALSE 94409
// sRemote := true ;
94401: LD_ADDR_EXP 127
94405: PUSH
94406: LD_INT 1
94408: ST_TO_ADDR
// if p3 = 21 then
94409: LD_VAR 0 3
94413: PUSH
94414: LD_INT 21
94416: EQUAL
94417: IFFALSE 94427
// sPowell := true ;
94419: LD_ADDR_EXP 128
94423: PUSH
94424: LD_INT 1
94426: ST_TO_ADDR
// if p3 = 22 then
94427: LD_VAR 0 3
94431: PUSH
94432: LD_INT 22
94434: EQUAL
94435: IFFALSE 94445
// sTeleport := true ;
94437: LD_ADDR_EXP 131
94441: PUSH
94442: LD_INT 1
94444: ST_TO_ADDR
// if p3 = 23 then
94445: LD_VAR 0 3
94449: PUSH
94450: LD_INT 23
94452: EQUAL
94453: IFFALSE 94463
// sOilTower := true ;
94455: LD_ADDR_EXP 133
94459: PUSH
94460: LD_INT 1
94462: ST_TO_ADDR
// if p3 = 24 then
94463: LD_VAR 0 3
94467: PUSH
94468: LD_INT 24
94470: EQUAL
94471: IFFALSE 94481
// sShovel := true ;
94473: LD_ADDR_EXP 134
94477: PUSH
94478: LD_INT 1
94480: ST_TO_ADDR
// if p3 = 25 then
94481: LD_VAR 0 3
94485: PUSH
94486: LD_INT 25
94488: EQUAL
94489: IFFALSE 94499
// sSheik := true ;
94491: LD_ADDR_EXP 135
94495: PUSH
94496: LD_INT 1
94498: ST_TO_ADDR
// if p3 = 26 then
94499: LD_VAR 0 3
94503: PUSH
94504: LD_INT 26
94506: EQUAL
94507: IFFALSE 94517
// sEarthquake := true ;
94509: LD_ADDR_EXP 137
94513: PUSH
94514: LD_INT 1
94516: ST_TO_ADDR
// if p3 = 27 then
94517: LD_VAR 0 3
94521: PUSH
94522: LD_INT 27
94524: EQUAL
94525: IFFALSE 94535
// sAI := true ;
94527: LD_ADDR_EXP 138
94531: PUSH
94532: LD_INT 1
94534: ST_TO_ADDR
// if p3 = 28 then
94535: LD_VAR 0 3
94539: PUSH
94540: LD_INT 28
94542: EQUAL
94543: IFFALSE 94553
// sCargo := true ;
94545: LD_ADDR_EXP 141
94549: PUSH
94550: LD_INT 1
94552: ST_TO_ADDR
// if p3 = 29 then
94553: LD_VAR 0 3
94557: PUSH
94558: LD_INT 29
94560: EQUAL
94561: IFFALSE 94571
// sDLaser := true ;
94563: LD_ADDR_EXP 142
94567: PUSH
94568: LD_INT 1
94570: ST_TO_ADDR
// if p3 = 30 then
94571: LD_VAR 0 3
94575: PUSH
94576: LD_INT 30
94578: EQUAL
94579: IFFALSE 94589
// sExchange := true ;
94581: LD_ADDR_EXP 143
94585: PUSH
94586: LD_INT 1
94588: ST_TO_ADDR
// if p3 = 31 then
94589: LD_VAR 0 3
94593: PUSH
94594: LD_INT 31
94596: EQUAL
94597: IFFALSE 94607
// sFac := true ;
94599: LD_ADDR_EXP 144
94603: PUSH
94604: LD_INT 1
94606: ST_TO_ADDR
// if p3 = 32 then
94607: LD_VAR 0 3
94611: PUSH
94612: LD_INT 32
94614: EQUAL
94615: IFFALSE 94625
// sPower := true ;
94617: LD_ADDR_EXP 145
94621: PUSH
94622: LD_INT 1
94624: ST_TO_ADDR
// if p3 = 33 then
94625: LD_VAR 0 3
94629: PUSH
94630: LD_INT 33
94632: EQUAL
94633: IFFALSE 94643
// sRandom := true ;
94635: LD_ADDR_EXP 146
94639: PUSH
94640: LD_INT 1
94642: ST_TO_ADDR
// if p3 = 34 then
94643: LD_VAR 0 3
94647: PUSH
94648: LD_INT 34
94650: EQUAL
94651: IFFALSE 94661
// sShield := true ;
94653: LD_ADDR_EXP 147
94657: PUSH
94658: LD_INT 1
94660: ST_TO_ADDR
// if p3 = 35 then
94661: LD_VAR 0 3
94665: PUSH
94666: LD_INT 35
94668: EQUAL
94669: IFFALSE 94679
// sTime := true ;
94671: LD_ADDR_EXP 148
94675: PUSH
94676: LD_INT 1
94678: ST_TO_ADDR
// if p3 = 36 then
94679: LD_VAR 0 3
94683: PUSH
94684: LD_INT 36
94686: EQUAL
94687: IFFALSE 94697
// sTools := true ;
94689: LD_ADDR_EXP 149
94693: PUSH
94694: LD_INT 1
94696: ST_TO_ADDR
// if p3 = 101 then
94697: LD_VAR 0 3
94701: PUSH
94702: LD_INT 101
94704: EQUAL
94705: IFFALSE 94715
// sSold := true ;
94707: LD_ADDR_EXP 114
94711: PUSH
94712: LD_INT 1
94714: ST_TO_ADDR
// if p3 = 102 then
94715: LD_VAR 0 3
94719: PUSH
94720: LD_INT 102
94722: EQUAL
94723: IFFALSE 94733
// sDiff := true ;
94725: LD_ADDR_EXP 115
94729: PUSH
94730: LD_INT 1
94732: ST_TO_ADDR
// if p3 = 103 then
94733: LD_VAR 0 3
94737: PUSH
94738: LD_INT 103
94740: EQUAL
94741: IFFALSE 94751
// sFog := true ;
94743: LD_ADDR_EXP 118
94747: PUSH
94748: LD_INT 1
94750: ST_TO_ADDR
// if p3 = 104 then
94751: LD_VAR 0 3
94755: PUSH
94756: LD_INT 104
94758: EQUAL
94759: IFFALSE 94769
// sReset := true ;
94761: LD_ADDR_EXP 119
94765: PUSH
94766: LD_INT 1
94768: ST_TO_ADDR
// if p3 = 105 then
94769: LD_VAR 0 3
94773: PUSH
94774: LD_INT 105
94776: EQUAL
94777: IFFALSE 94787
// sSun := true ;
94779: LD_ADDR_EXP 120
94783: PUSH
94784: LD_INT 1
94786: ST_TO_ADDR
// if p3 = 106 then
94787: LD_VAR 0 3
94791: PUSH
94792: LD_INT 106
94794: EQUAL
94795: IFFALSE 94805
// sTiger := true ;
94797: LD_ADDR_EXP 116
94801: PUSH
94802: LD_INT 1
94804: ST_TO_ADDR
// if p3 = 107 then
94805: LD_VAR 0 3
94809: PUSH
94810: LD_INT 107
94812: EQUAL
94813: IFFALSE 94823
// sBomb := true ;
94815: LD_ADDR_EXP 117
94819: PUSH
94820: LD_INT 1
94822: ST_TO_ADDR
// if p3 = 108 then
94823: LD_VAR 0 3
94827: PUSH
94828: LD_INT 108
94830: EQUAL
94831: IFFALSE 94841
// sWound := true ;
94833: LD_ADDR_EXP 125
94837: PUSH
94838: LD_INT 1
94840: ST_TO_ADDR
// if p3 = 109 then
94841: LD_VAR 0 3
94845: PUSH
94846: LD_INT 109
94848: EQUAL
94849: IFFALSE 94859
// sBetray := true ;
94851: LD_ADDR_EXP 129
94855: PUSH
94856: LD_INT 1
94858: ST_TO_ADDR
// if p3 = 110 then
94859: LD_VAR 0 3
94863: PUSH
94864: LD_INT 110
94866: EQUAL
94867: IFFALSE 94877
// sContamin := true ;
94869: LD_ADDR_EXP 130
94873: PUSH
94874: LD_INT 1
94876: ST_TO_ADDR
// if p3 = 111 then
94877: LD_VAR 0 3
94881: PUSH
94882: LD_INT 111
94884: EQUAL
94885: IFFALSE 94895
// sOil := true ;
94887: LD_ADDR_EXP 132
94891: PUSH
94892: LD_INT 1
94894: ST_TO_ADDR
// if p3 = 112 then
94895: LD_VAR 0 3
94899: PUSH
94900: LD_INT 112
94902: EQUAL
94903: IFFALSE 94913
// sStu := true ;
94905: LD_ADDR_EXP 136
94909: PUSH
94910: LD_INT 1
94912: ST_TO_ADDR
// if p3 = 113 then
94913: LD_VAR 0 3
94917: PUSH
94918: LD_INT 113
94920: EQUAL
94921: IFFALSE 94931
// sBazooka := true ;
94923: LD_ADDR_EXP 139
94927: PUSH
94928: LD_INT 1
94930: ST_TO_ADDR
// if p3 = 114 then
94931: LD_VAR 0 3
94935: PUSH
94936: LD_INT 114
94938: EQUAL
94939: IFFALSE 94949
// sMortar := true ;
94941: LD_ADDR_EXP 140
94945: PUSH
94946: LD_INT 1
94948: ST_TO_ADDR
// if p3 = 115 then
94949: LD_VAR 0 3
94953: PUSH
94954: LD_INT 115
94956: EQUAL
94957: IFFALSE 94967
// sRanger := true ;
94959: LD_ADDR_EXP 150
94963: PUSH
94964: LD_INT 1
94966: ST_TO_ADDR
// if p3 = 116 then
94967: LD_VAR 0 3
94971: PUSH
94972: LD_INT 116
94974: EQUAL
94975: IFFALSE 94985
// sComputer := true ;
94977: LD_ADDR_EXP 151
94981: PUSH
94982: LD_INT 1
94984: ST_TO_ADDR
// if p3 = 117 then
94985: LD_VAR 0 3
94989: PUSH
94990: LD_INT 117
94992: EQUAL
94993: IFFALSE 95003
// s30 := true ;
94995: LD_ADDR_EXP 152
94999: PUSH
95000: LD_INT 1
95002: ST_TO_ADDR
// if p3 = 118 then
95003: LD_VAR 0 3
95007: PUSH
95008: LD_INT 118
95010: EQUAL
95011: IFFALSE 95021
// s60 := true ;
95013: LD_ADDR_EXP 153
95017: PUSH
95018: LD_INT 1
95020: ST_TO_ADDR
// end ; if p2 = 101 then
95021: LD_VAR 0 2
95025: PUSH
95026: LD_INT 101
95028: EQUAL
95029: IFFALSE 95157
// begin case p3 of 1 :
95031: LD_VAR 0 3
95035: PUSH
95036: LD_INT 1
95038: DOUBLE
95039: EQUAL
95040: IFTRUE 95044
95042: GO 95051
95044: POP
// hHackUnlimitedResources ; 2 :
95045: CALL 107255 0 0
95049: GO 95157
95051: LD_INT 2
95053: DOUBLE
95054: EQUAL
95055: IFTRUE 95059
95057: GO 95066
95059: POP
// hHackSetLevel10 ; 3 :
95060: CALL 107388 0 0
95064: GO 95157
95066: LD_INT 3
95068: DOUBLE
95069: EQUAL
95070: IFTRUE 95074
95072: GO 95081
95074: POP
// hHackSetLevel10YourUnits ; 4 :
95075: CALL 107473 0 0
95079: GO 95157
95081: LD_INT 4
95083: DOUBLE
95084: EQUAL
95085: IFTRUE 95089
95087: GO 95096
95089: POP
// hHackInvincible ; 5 :
95090: CALL 107921 0 0
95094: GO 95157
95096: LD_INT 5
95098: DOUBLE
95099: EQUAL
95100: IFTRUE 95104
95102: GO 95111
95104: POP
// hHackInvisible ; 6 :
95105: CALL 108032 0 0
95109: GO 95157
95111: LD_INT 6
95113: DOUBLE
95114: EQUAL
95115: IFTRUE 95119
95117: GO 95126
95119: POP
// hHackChangeYourSide ; 7 :
95120: CALL 108089 0 0
95124: GO 95157
95126: LD_INT 7
95128: DOUBLE
95129: EQUAL
95130: IFTRUE 95134
95132: GO 95141
95134: POP
// hHackChangeUnitSide ; 8 :
95135: CALL 108131 0 0
95139: GO 95157
95141: LD_INT 8
95143: DOUBLE
95144: EQUAL
95145: IFTRUE 95149
95147: GO 95156
95149: POP
// hHackFog ; end ;
95150: CALL 108232 0 0
95154: GO 95157
95156: POP
// end ; end ;
95157: LD_VAR 0 7
95161: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
95162: GO 95164
95164: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
95165: LD_STRING initStreamRollete();
95167: PPUSH
95168: CALL_OW 559
// InitStreamMode ;
95172: CALL 95184 0 0
// DefineStreamItems ( false ) ;
95176: LD_INT 0
95178: PPUSH
95179: CALL 95648 0 1
// end ;
95183: END
// function InitStreamMode ; begin
95184: LD_INT 0
95186: PPUSH
// streamModeActive := false ;
95187: LD_ADDR_EXP 97
95191: PUSH
95192: LD_INT 0
95194: ST_TO_ADDR
// normalCounter := 36 ;
95195: LD_ADDR_EXP 98
95199: PUSH
95200: LD_INT 36
95202: ST_TO_ADDR
// hardcoreCounter := 18 ;
95203: LD_ADDR_EXP 99
95207: PUSH
95208: LD_INT 18
95210: ST_TO_ADDR
// sRocket := false ;
95211: LD_ADDR_EXP 102
95215: PUSH
95216: LD_INT 0
95218: ST_TO_ADDR
// sSpeed := false ;
95219: LD_ADDR_EXP 101
95223: PUSH
95224: LD_INT 0
95226: ST_TO_ADDR
// sEngine := false ;
95227: LD_ADDR_EXP 103
95231: PUSH
95232: LD_INT 0
95234: ST_TO_ADDR
// sSpec := false ;
95235: LD_ADDR_EXP 100
95239: PUSH
95240: LD_INT 0
95242: ST_TO_ADDR
// sLevel := false ;
95243: LD_ADDR_EXP 104
95247: PUSH
95248: LD_INT 0
95250: ST_TO_ADDR
// sArmoury := false ;
95251: LD_ADDR_EXP 105
95255: PUSH
95256: LD_INT 0
95258: ST_TO_ADDR
// sRadar := false ;
95259: LD_ADDR_EXP 106
95263: PUSH
95264: LD_INT 0
95266: ST_TO_ADDR
// sBunker := false ;
95267: LD_ADDR_EXP 107
95271: PUSH
95272: LD_INT 0
95274: ST_TO_ADDR
// sHack := false ;
95275: LD_ADDR_EXP 108
95279: PUSH
95280: LD_INT 0
95282: ST_TO_ADDR
// sFire := false ;
95283: LD_ADDR_EXP 109
95287: PUSH
95288: LD_INT 0
95290: ST_TO_ADDR
// sRefresh := false ;
95291: LD_ADDR_EXP 110
95295: PUSH
95296: LD_INT 0
95298: ST_TO_ADDR
// sExp := false ;
95299: LD_ADDR_EXP 111
95303: PUSH
95304: LD_INT 0
95306: ST_TO_ADDR
// sDepot := false ;
95307: LD_ADDR_EXP 112
95311: PUSH
95312: LD_INT 0
95314: ST_TO_ADDR
// sFlag := false ;
95315: LD_ADDR_EXP 113
95319: PUSH
95320: LD_INT 0
95322: ST_TO_ADDR
// sKamikadze := false ;
95323: LD_ADDR_EXP 121
95327: PUSH
95328: LD_INT 0
95330: ST_TO_ADDR
// sTroll := false ;
95331: LD_ADDR_EXP 122
95335: PUSH
95336: LD_INT 0
95338: ST_TO_ADDR
// sSlow := false ;
95339: LD_ADDR_EXP 123
95343: PUSH
95344: LD_INT 0
95346: ST_TO_ADDR
// sLack := false ;
95347: LD_ADDR_EXP 124
95351: PUSH
95352: LD_INT 0
95354: ST_TO_ADDR
// sTank := false ;
95355: LD_ADDR_EXP 126
95359: PUSH
95360: LD_INT 0
95362: ST_TO_ADDR
// sRemote := false ;
95363: LD_ADDR_EXP 127
95367: PUSH
95368: LD_INT 0
95370: ST_TO_ADDR
// sPowell := false ;
95371: LD_ADDR_EXP 128
95375: PUSH
95376: LD_INT 0
95378: ST_TO_ADDR
// sTeleport := false ;
95379: LD_ADDR_EXP 131
95383: PUSH
95384: LD_INT 0
95386: ST_TO_ADDR
// sOilTower := false ;
95387: LD_ADDR_EXP 133
95391: PUSH
95392: LD_INT 0
95394: ST_TO_ADDR
// sShovel := false ;
95395: LD_ADDR_EXP 134
95399: PUSH
95400: LD_INT 0
95402: ST_TO_ADDR
// sSheik := false ;
95403: LD_ADDR_EXP 135
95407: PUSH
95408: LD_INT 0
95410: ST_TO_ADDR
// sEarthquake := false ;
95411: LD_ADDR_EXP 137
95415: PUSH
95416: LD_INT 0
95418: ST_TO_ADDR
// sAI := false ;
95419: LD_ADDR_EXP 138
95423: PUSH
95424: LD_INT 0
95426: ST_TO_ADDR
// sCargo := false ;
95427: LD_ADDR_EXP 141
95431: PUSH
95432: LD_INT 0
95434: ST_TO_ADDR
// sDLaser := false ;
95435: LD_ADDR_EXP 142
95439: PUSH
95440: LD_INT 0
95442: ST_TO_ADDR
// sExchange := false ;
95443: LD_ADDR_EXP 143
95447: PUSH
95448: LD_INT 0
95450: ST_TO_ADDR
// sFac := false ;
95451: LD_ADDR_EXP 144
95455: PUSH
95456: LD_INT 0
95458: ST_TO_ADDR
// sPower := false ;
95459: LD_ADDR_EXP 145
95463: PUSH
95464: LD_INT 0
95466: ST_TO_ADDR
// sRandom := false ;
95467: LD_ADDR_EXP 146
95471: PUSH
95472: LD_INT 0
95474: ST_TO_ADDR
// sShield := false ;
95475: LD_ADDR_EXP 147
95479: PUSH
95480: LD_INT 0
95482: ST_TO_ADDR
// sTime := false ;
95483: LD_ADDR_EXP 148
95487: PUSH
95488: LD_INT 0
95490: ST_TO_ADDR
// sTools := false ;
95491: LD_ADDR_EXP 149
95495: PUSH
95496: LD_INT 0
95498: ST_TO_ADDR
// sSold := false ;
95499: LD_ADDR_EXP 114
95503: PUSH
95504: LD_INT 0
95506: ST_TO_ADDR
// sDiff := false ;
95507: LD_ADDR_EXP 115
95511: PUSH
95512: LD_INT 0
95514: ST_TO_ADDR
// sFog := false ;
95515: LD_ADDR_EXP 118
95519: PUSH
95520: LD_INT 0
95522: ST_TO_ADDR
// sReset := false ;
95523: LD_ADDR_EXP 119
95527: PUSH
95528: LD_INT 0
95530: ST_TO_ADDR
// sSun := false ;
95531: LD_ADDR_EXP 120
95535: PUSH
95536: LD_INT 0
95538: ST_TO_ADDR
// sTiger := false ;
95539: LD_ADDR_EXP 116
95543: PUSH
95544: LD_INT 0
95546: ST_TO_ADDR
// sBomb := false ;
95547: LD_ADDR_EXP 117
95551: PUSH
95552: LD_INT 0
95554: ST_TO_ADDR
// sWound := false ;
95555: LD_ADDR_EXP 125
95559: PUSH
95560: LD_INT 0
95562: ST_TO_ADDR
// sBetray := false ;
95563: LD_ADDR_EXP 129
95567: PUSH
95568: LD_INT 0
95570: ST_TO_ADDR
// sContamin := false ;
95571: LD_ADDR_EXP 130
95575: PUSH
95576: LD_INT 0
95578: ST_TO_ADDR
// sOil := false ;
95579: LD_ADDR_EXP 132
95583: PUSH
95584: LD_INT 0
95586: ST_TO_ADDR
// sStu := false ;
95587: LD_ADDR_EXP 136
95591: PUSH
95592: LD_INT 0
95594: ST_TO_ADDR
// sBazooka := false ;
95595: LD_ADDR_EXP 139
95599: PUSH
95600: LD_INT 0
95602: ST_TO_ADDR
// sMortar := false ;
95603: LD_ADDR_EXP 140
95607: PUSH
95608: LD_INT 0
95610: ST_TO_ADDR
// sRanger := false ;
95611: LD_ADDR_EXP 150
95615: PUSH
95616: LD_INT 0
95618: ST_TO_ADDR
// sComputer := false ;
95619: LD_ADDR_EXP 151
95623: PUSH
95624: LD_INT 0
95626: ST_TO_ADDR
// s30 := false ;
95627: LD_ADDR_EXP 152
95631: PUSH
95632: LD_INT 0
95634: ST_TO_ADDR
// s60 := false ;
95635: LD_ADDR_EXP 153
95639: PUSH
95640: LD_INT 0
95642: ST_TO_ADDR
// end ;
95643: LD_VAR 0 1
95647: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95648: LD_INT 0
95650: PPUSH
95651: PPUSH
95652: PPUSH
95653: PPUSH
95654: PPUSH
95655: PPUSH
95656: PPUSH
// result := [ ] ;
95657: LD_ADDR_VAR 0 2
95661: PUSH
95662: EMPTY
95663: ST_TO_ADDR
// if campaign_id = 1 then
95664: LD_OWVAR 69
95668: PUSH
95669: LD_INT 1
95671: EQUAL
95672: IFFALSE 98838
// begin case mission_number of 1 :
95674: LD_OWVAR 70
95678: PUSH
95679: LD_INT 1
95681: DOUBLE
95682: EQUAL
95683: IFTRUE 95687
95685: GO 95763
95687: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95688: LD_ADDR_VAR 0 2
95692: PUSH
95693: LD_INT 2
95695: PUSH
95696: LD_INT 4
95698: PUSH
95699: LD_INT 11
95701: PUSH
95702: LD_INT 12
95704: PUSH
95705: LD_INT 15
95707: PUSH
95708: LD_INT 16
95710: PUSH
95711: LD_INT 22
95713: PUSH
95714: LD_INT 23
95716: PUSH
95717: LD_INT 26
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: PUSH
95731: LD_INT 101
95733: PUSH
95734: LD_INT 102
95736: PUSH
95737: LD_INT 106
95739: PUSH
95740: LD_INT 116
95742: PUSH
95743: LD_INT 117
95745: PUSH
95746: LD_INT 118
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: ST_TO_ADDR
95761: GO 98836
95763: LD_INT 2
95765: DOUBLE
95766: EQUAL
95767: IFTRUE 95771
95769: GO 95855
95771: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95772: LD_ADDR_VAR 0 2
95776: PUSH
95777: LD_INT 2
95779: PUSH
95780: LD_INT 4
95782: PUSH
95783: LD_INT 11
95785: PUSH
95786: LD_INT 12
95788: PUSH
95789: LD_INT 15
95791: PUSH
95792: LD_INT 16
95794: PUSH
95795: LD_INT 22
95797: PUSH
95798: LD_INT 23
95800: PUSH
95801: LD_INT 26
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 101
95817: PUSH
95818: LD_INT 102
95820: PUSH
95821: LD_INT 105
95823: PUSH
95824: LD_INT 106
95826: PUSH
95827: LD_INT 108
95829: PUSH
95830: LD_INT 116
95832: PUSH
95833: LD_INT 117
95835: PUSH
95836: LD_INT 118
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: ST_TO_ADDR
95853: GO 98836
95855: LD_INT 3
95857: DOUBLE
95858: EQUAL
95859: IFTRUE 95863
95861: GO 95951
95863: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95864: LD_ADDR_VAR 0 2
95868: PUSH
95869: LD_INT 2
95871: PUSH
95872: LD_INT 4
95874: PUSH
95875: LD_INT 5
95877: PUSH
95878: LD_INT 11
95880: PUSH
95881: LD_INT 12
95883: PUSH
95884: LD_INT 15
95886: PUSH
95887: LD_INT 16
95889: PUSH
95890: LD_INT 22
95892: PUSH
95893: LD_INT 26
95895: PUSH
95896: LD_INT 36
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 101
95913: PUSH
95914: LD_INT 102
95916: PUSH
95917: LD_INT 105
95919: PUSH
95920: LD_INT 106
95922: PUSH
95923: LD_INT 108
95925: PUSH
95926: LD_INT 116
95928: PUSH
95929: LD_INT 117
95931: PUSH
95932: LD_INT 118
95934: PUSH
95935: EMPTY
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: ST_TO_ADDR
95949: GO 98836
95951: LD_INT 4
95953: DOUBLE
95954: EQUAL
95955: IFTRUE 95959
95957: GO 96055
95959: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95960: LD_ADDR_VAR 0 2
95964: PUSH
95965: LD_INT 2
95967: PUSH
95968: LD_INT 4
95970: PUSH
95971: LD_INT 5
95973: PUSH
95974: LD_INT 8
95976: PUSH
95977: LD_INT 11
95979: PUSH
95980: LD_INT 12
95982: PUSH
95983: LD_INT 15
95985: PUSH
95986: LD_INT 16
95988: PUSH
95989: LD_INT 22
95991: PUSH
95992: LD_INT 23
95994: PUSH
95995: LD_INT 26
95997: PUSH
95998: LD_INT 36
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: PUSH
96015: LD_INT 101
96017: PUSH
96018: LD_INT 102
96020: PUSH
96021: LD_INT 105
96023: PUSH
96024: LD_INT 106
96026: PUSH
96027: LD_INT 108
96029: PUSH
96030: LD_INT 116
96032: PUSH
96033: LD_INT 117
96035: PUSH
96036: LD_INT 118
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: ST_TO_ADDR
96053: GO 98836
96055: LD_INT 5
96057: DOUBLE
96058: EQUAL
96059: IFTRUE 96063
96061: GO 96175
96063: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96064: LD_ADDR_VAR 0 2
96068: PUSH
96069: LD_INT 2
96071: PUSH
96072: LD_INT 4
96074: PUSH
96075: LD_INT 5
96077: PUSH
96078: LD_INT 6
96080: PUSH
96081: LD_INT 8
96083: PUSH
96084: LD_INT 11
96086: PUSH
96087: LD_INT 12
96089: PUSH
96090: LD_INT 15
96092: PUSH
96093: LD_INT 16
96095: PUSH
96096: LD_INT 22
96098: PUSH
96099: LD_INT 23
96101: PUSH
96102: LD_INT 25
96104: PUSH
96105: LD_INT 26
96107: PUSH
96108: LD_INT 36
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: PUSH
96127: LD_INT 101
96129: PUSH
96130: LD_INT 102
96132: PUSH
96133: LD_INT 105
96135: PUSH
96136: LD_INT 106
96138: PUSH
96139: LD_INT 108
96141: PUSH
96142: LD_INT 109
96144: PUSH
96145: LD_INT 112
96147: PUSH
96148: LD_INT 116
96150: PUSH
96151: LD_INT 117
96153: PUSH
96154: LD_INT 118
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: ST_TO_ADDR
96173: GO 98836
96175: LD_INT 6
96177: DOUBLE
96178: EQUAL
96179: IFTRUE 96183
96181: GO 96315
96183: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96184: LD_ADDR_VAR 0 2
96188: PUSH
96189: LD_INT 2
96191: PUSH
96192: LD_INT 4
96194: PUSH
96195: LD_INT 5
96197: PUSH
96198: LD_INT 6
96200: PUSH
96201: LD_INT 8
96203: PUSH
96204: LD_INT 11
96206: PUSH
96207: LD_INT 12
96209: PUSH
96210: LD_INT 15
96212: PUSH
96213: LD_INT 16
96215: PUSH
96216: LD_INT 20
96218: PUSH
96219: LD_INT 21
96221: PUSH
96222: LD_INT 22
96224: PUSH
96225: LD_INT 23
96227: PUSH
96228: LD_INT 25
96230: PUSH
96231: LD_INT 26
96233: PUSH
96234: LD_INT 30
96236: PUSH
96237: LD_INT 31
96239: PUSH
96240: LD_INT 32
96242: PUSH
96243: LD_INT 36
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: PUSH
96267: LD_INT 101
96269: PUSH
96270: LD_INT 102
96272: PUSH
96273: LD_INT 105
96275: PUSH
96276: LD_INT 106
96278: PUSH
96279: LD_INT 108
96281: PUSH
96282: LD_INT 109
96284: PUSH
96285: LD_INT 112
96287: PUSH
96288: LD_INT 116
96290: PUSH
96291: LD_INT 117
96293: PUSH
96294: LD_INT 118
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: ST_TO_ADDR
96313: GO 98836
96315: LD_INT 7
96317: DOUBLE
96318: EQUAL
96319: IFTRUE 96323
96321: GO 96435
96323: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96324: LD_ADDR_VAR 0 2
96328: PUSH
96329: LD_INT 2
96331: PUSH
96332: LD_INT 4
96334: PUSH
96335: LD_INT 5
96337: PUSH
96338: LD_INT 7
96340: PUSH
96341: LD_INT 11
96343: PUSH
96344: LD_INT 12
96346: PUSH
96347: LD_INT 15
96349: PUSH
96350: LD_INT 16
96352: PUSH
96353: LD_INT 20
96355: PUSH
96356: LD_INT 21
96358: PUSH
96359: LD_INT 22
96361: PUSH
96362: LD_INT 23
96364: PUSH
96365: LD_INT 25
96367: PUSH
96368: LD_INT 26
96370: PUSH
96371: EMPTY
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: PUSH
96387: LD_INT 101
96389: PUSH
96390: LD_INT 102
96392: PUSH
96393: LD_INT 103
96395: PUSH
96396: LD_INT 105
96398: PUSH
96399: LD_INT 106
96401: PUSH
96402: LD_INT 108
96404: PUSH
96405: LD_INT 112
96407: PUSH
96408: LD_INT 116
96410: PUSH
96411: LD_INT 117
96413: PUSH
96414: LD_INT 118
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: ST_TO_ADDR
96433: GO 98836
96435: LD_INT 8
96437: DOUBLE
96438: EQUAL
96439: IFTRUE 96443
96441: GO 96583
96443: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96444: LD_ADDR_VAR 0 2
96448: PUSH
96449: LD_INT 2
96451: PUSH
96452: LD_INT 4
96454: PUSH
96455: LD_INT 5
96457: PUSH
96458: LD_INT 6
96460: PUSH
96461: LD_INT 7
96463: PUSH
96464: LD_INT 8
96466: PUSH
96467: LD_INT 11
96469: PUSH
96470: LD_INT 12
96472: PUSH
96473: LD_INT 15
96475: PUSH
96476: LD_INT 16
96478: PUSH
96479: LD_INT 20
96481: PUSH
96482: LD_INT 21
96484: PUSH
96485: LD_INT 22
96487: PUSH
96488: LD_INT 23
96490: PUSH
96491: LD_INT 25
96493: PUSH
96494: LD_INT 26
96496: PUSH
96497: LD_INT 30
96499: PUSH
96500: LD_INT 31
96502: PUSH
96503: LD_INT 32
96505: PUSH
96506: LD_INT 36
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 101
96533: PUSH
96534: LD_INT 102
96536: PUSH
96537: LD_INT 103
96539: PUSH
96540: LD_INT 105
96542: PUSH
96543: LD_INT 106
96545: PUSH
96546: LD_INT 108
96548: PUSH
96549: LD_INT 109
96551: PUSH
96552: LD_INT 112
96554: PUSH
96555: LD_INT 116
96557: PUSH
96558: LD_INT 117
96560: PUSH
96561: LD_INT 118
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: ST_TO_ADDR
96581: GO 98836
96583: LD_INT 9
96585: DOUBLE
96586: EQUAL
96587: IFTRUE 96591
96589: GO 96739
96591: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96592: LD_ADDR_VAR 0 2
96596: PUSH
96597: LD_INT 2
96599: PUSH
96600: LD_INT 4
96602: PUSH
96603: LD_INT 5
96605: PUSH
96606: LD_INT 6
96608: PUSH
96609: LD_INT 7
96611: PUSH
96612: LD_INT 8
96614: PUSH
96615: LD_INT 11
96617: PUSH
96618: LD_INT 12
96620: PUSH
96621: LD_INT 15
96623: PUSH
96624: LD_INT 16
96626: PUSH
96627: LD_INT 20
96629: PUSH
96630: LD_INT 21
96632: PUSH
96633: LD_INT 22
96635: PUSH
96636: LD_INT 23
96638: PUSH
96639: LD_INT 25
96641: PUSH
96642: LD_INT 26
96644: PUSH
96645: LD_INT 28
96647: PUSH
96648: LD_INT 30
96650: PUSH
96651: LD_INT 31
96653: PUSH
96654: LD_INT 32
96656: PUSH
96657: LD_INT 36
96659: PUSH
96660: EMPTY
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: PUSH
96683: LD_INT 101
96685: PUSH
96686: LD_INT 102
96688: PUSH
96689: LD_INT 103
96691: PUSH
96692: LD_INT 105
96694: PUSH
96695: LD_INT 106
96697: PUSH
96698: LD_INT 108
96700: PUSH
96701: LD_INT 109
96703: PUSH
96704: LD_INT 112
96706: PUSH
96707: LD_INT 114
96709: PUSH
96710: LD_INT 116
96712: PUSH
96713: LD_INT 117
96715: PUSH
96716: LD_INT 118
96718: PUSH
96719: EMPTY
96720: LIST
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: ST_TO_ADDR
96737: GO 98836
96739: LD_INT 10
96741: DOUBLE
96742: EQUAL
96743: IFTRUE 96747
96745: GO 96943
96747: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96748: LD_ADDR_VAR 0 2
96752: PUSH
96753: LD_INT 2
96755: PUSH
96756: LD_INT 4
96758: PUSH
96759: LD_INT 5
96761: PUSH
96762: LD_INT 6
96764: PUSH
96765: LD_INT 7
96767: PUSH
96768: LD_INT 8
96770: PUSH
96771: LD_INT 9
96773: PUSH
96774: LD_INT 10
96776: PUSH
96777: LD_INT 11
96779: PUSH
96780: LD_INT 12
96782: PUSH
96783: LD_INT 13
96785: PUSH
96786: LD_INT 14
96788: PUSH
96789: LD_INT 15
96791: PUSH
96792: LD_INT 16
96794: PUSH
96795: LD_INT 17
96797: PUSH
96798: LD_INT 18
96800: PUSH
96801: LD_INT 19
96803: PUSH
96804: LD_INT 20
96806: PUSH
96807: LD_INT 21
96809: PUSH
96810: LD_INT 22
96812: PUSH
96813: LD_INT 23
96815: PUSH
96816: LD_INT 24
96818: PUSH
96819: LD_INT 25
96821: PUSH
96822: LD_INT 26
96824: PUSH
96825: LD_INT 28
96827: PUSH
96828: LD_INT 30
96830: PUSH
96831: LD_INT 31
96833: PUSH
96834: LD_INT 32
96836: PUSH
96837: LD_INT 36
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 101
96873: PUSH
96874: LD_INT 102
96876: PUSH
96877: LD_INT 103
96879: PUSH
96880: LD_INT 104
96882: PUSH
96883: LD_INT 105
96885: PUSH
96886: LD_INT 106
96888: PUSH
96889: LD_INT 107
96891: PUSH
96892: LD_INT 108
96894: PUSH
96895: LD_INT 109
96897: PUSH
96898: LD_INT 110
96900: PUSH
96901: LD_INT 111
96903: PUSH
96904: LD_INT 112
96906: PUSH
96907: LD_INT 114
96909: PUSH
96910: LD_INT 116
96912: PUSH
96913: LD_INT 117
96915: PUSH
96916: LD_INT 118
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: ST_TO_ADDR
96941: GO 98836
96943: LD_INT 11
96945: DOUBLE
96946: EQUAL
96947: IFTRUE 96951
96949: GO 97155
96951: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96952: LD_ADDR_VAR 0 2
96956: PUSH
96957: LD_INT 2
96959: PUSH
96960: LD_INT 3
96962: PUSH
96963: LD_INT 4
96965: PUSH
96966: LD_INT 5
96968: PUSH
96969: LD_INT 6
96971: PUSH
96972: LD_INT 7
96974: PUSH
96975: LD_INT 8
96977: PUSH
96978: LD_INT 9
96980: PUSH
96981: LD_INT 10
96983: PUSH
96984: LD_INT 11
96986: PUSH
96987: LD_INT 12
96989: PUSH
96990: LD_INT 13
96992: PUSH
96993: LD_INT 14
96995: PUSH
96996: LD_INT 15
96998: PUSH
96999: LD_INT 16
97001: PUSH
97002: LD_INT 17
97004: PUSH
97005: LD_INT 18
97007: PUSH
97008: LD_INT 19
97010: PUSH
97011: LD_INT 20
97013: PUSH
97014: LD_INT 21
97016: PUSH
97017: LD_INT 22
97019: PUSH
97020: LD_INT 23
97022: PUSH
97023: LD_INT 24
97025: PUSH
97026: LD_INT 25
97028: PUSH
97029: LD_INT 26
97031: PUSH
97032: LD_INT 28
97034: PUSH
97035: LD_INT 30
97037: PUSH
97038: LD_INT 31
97040: PUSH
97041: LD_INT 32
97043: PUSH
97044: LD_INT 34
97046: PUSH
97047: LD_INT 36
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 101
97085: PUSH
97086: LD_INT 102
97088: PUSH
97089: LD_INT 103
97091: PUSH
97092: LD_INT 104
97094: PUSH
97095: LD_INT 105
97097: PUSH
97098: LD_INT 106
97100: PUSH
97101: LD_INT 107
97103: PUSH
97104: LD_INT 108
97106: PUSH
97107: LD_INT 109
97109: PUSH
97110: LD_INT 110
97112: PUSH
97113: LD_INT 111
97115: PUSH
97116: LD_INT 112
97118: PUSH
97119: LD_INT 114
97121: PUSH
97122: LD_INT 116
97124: PUSH
97125: LD_INT 117
97127: PUSH
97128: LD_INT 118
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: ST_TO_ADDR
97153: GO 98836
97155: LD_INT 12
97157: DOUBLE
97158: EQUAL
97159: IFTRUE 97163
97161: GO 97383
97163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97164: LD_ADDR_VAR 0 2
97168: PUSH
97169: LD_INT 1
97171: PUSH
97172: LD_INT 2
97174: PUSH
97175: LD_INT 3
97177: PUSH
97178: LD_INT 4
97180: PUSH
97181: LD_INT 5
97183: PUSH
97184: LD_INT 6
97186: PUSH
97187: LD_INT 7
97189: PUSH
97190: LD_INT 8
97192: PUSH
97193: LD_INT 9
97195: PUSH
97196: LD_INT 10
97198: PUSH
97199: LD_INT 11
97201: PUSH
97202: LD_INT 12
97204: PUSH
97205: LD_INT 13
97207: PUSH
97208: LD_INT 14
97210: PUSH
97211: LD_INT 15
97213: PUSH
97214: LD_INT 16
97216: PUSH
97217: LD_INT 17
97219: PUSH
97220: LD_INT 18
97222: PUSH
97223: LD_INT 19
97225: PUSH
97226: LD_INT 20
97228: PUSH
97229: LD_INT 21
97231: PUSH
97232: LD_INT 22
97234: PUSH
97235: LD_INT 23
97237: PUSH
97238: LD_INT 24
97240: PUSH
97241: LD_INT 25
97243: PUSH
97244: LD_INT 26
97246: PUSH
97247: LD_INT 27
97249: PUSH
97250: LD_INT 28
97252: PUSH
97253: LD_INT 30
97255: PUSH
97256: LD_INT 31
97258: PUSH
97259: LD_INT 32
97261: PUSH
97262: LD_INT 33
97264: PUSH
97265: LD_INT 34
97267: PUSH
97268: LD_INT 36
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 101
97309: PUSH
97310: LD_INT 102
97312: PUSH
97313: LD_INT 103
97315: PUSH
97316: LD_INT 104
97318: PUSH
97319: LD_INT 105
97321: PUSH
97322: LD_INT 106
97324: PUSH
97325: LD_INT 107
97327: PUSH
97328: LD_INT 108
97330: PUSH
97331: LD_INT 109
97333: PUSH
97334: LD_INT 110
97336: PUSH
97337: LD_INT 111
97339: PUSH
97340: LD_INT 112
97342: PUSH
97343: LD_INT 113
97345: PUSH
97346: LD_INT 114
97348: PUSH
97349: LD_INT 116
97351: PUSH
97352: LD_INT 117
97354: PUSH
97355: LD_INT 118
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: ST_TO_ADDR
97381: GO 98836
97383: LD_INT 13
97385: DOUBLE
97386: EQUAL
97387: IFTRUE 97391
97389: GO 97599
97391: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97392: LD_ADDR_VAR 0 2
97396: PUSH
97397: LD_INT 1
97399: PUSH
97400: LD_INT 2
97402: PUSH
97403: LD_INT 3
97405: PUSH
97406: LD_INT 4
97408: PUSH
97409: LD_INT 5
97411: PUSH
97412: LD_INT 8
97414: PUSH
97415: LD_INT 9
97417: PUSH
97418: LD_INT 10
97420: PUSH
97421: LD_INT 11
97423: PUSH
97424: LD_INT 12
97426: PUSH
97427: LD_INT 14
97429: PUSH
97430: LD_INT 15
97432: PUSH
97433: LD_INT 16
97435: PUSH
97436: LD_INT 17
97438: PUSH
97439: LD_INT 18
97441: PUSH
97442: LD_INT 19
97444: PUSH
97445: LD_INT 20
97447: PUSH
97448: LD_INT 21
97450: PUSH
97451: LD_INT 22
97453: PUSH
97454: LD_INT 23
97456: PUSH
97457: LD_INT 24
97459: PUSH
97460: LD_INT 25
97462: PUSH
97463: LD_INT 26
97465: PUSH
97466: LD_INT 27
97468: PUSH
97469: LD_INT 28
97471: PUSH
97472: LD_INT 30
97474: PUSH
97475: LD_INT 31
97477: PUSH
97478: LD_INT 32
97480: PUSH
97481: LD_INT 33
97483: PUSH
97484: LD_INT 34
97486: PUSH
97487: LD_INT 36
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: PUSH
97523: LD_INT 101
97525: PUSH
97526: LD_INT 102
97528: PUSH
97529: LD_INT 103
97531: PUSH
97532: LD_INT 104
97534: PUSH
97535: LD_INT 105
97537: PUSH
97538: LD_INT 106
97540: PUSH
97541: LD_INT 107
97543: PUSH
97544: LD_INT 108
97546: PUSH
97547: LD_INT 109
97549: PUSH
97550: LD_INT 110
97552: PUSH
97553: LD_INT 111
97555: PUSH
97556: LD_INT 112
97558: PUSH
97559: LD_INT 113
97561: PUSH
97562: LD_INT 114
97564: PUSH
97565: LD_INT 116
97567: PUSH
97568: LD_INT 117
97570: PUSH
97571: LD_INT 118
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: ST_TO_ADDR
97597: GO 98836
97599: LD_INT 14
97601: DOUBLE
97602: EQUAL
97603: IFTRUE 97607
97605: GO 97831
97607: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97608: LD_ADDR_VAR 0 2
97612: PUSH
97613: LD_INT 1
97615: PUSH
97616: LD_INT 2
97618: PUSH
97619: LD_INT 3
97621: PUSH
97622: LD_INT 4
97624: PUSH
97625: LD_INT 5
97627: PUSH
97628: LD_INT 6
97630: PUSH
97631: LD_INT 7
97633: PUSH
97634: LD_INT 8
97636: PUSH
97637: LD_INT 9
97639: PUSH
97640: LD_INT 10
97642: PUSH
97643: LD_INT 11
97645: PUSH
97646: LD_INT 12
97648: PUSH
97649: LD_INT 13
97651: PUSH
97652: LD_INT 14
97654: PUSH
97655: LD_INT 15
97657: PUSH
97658: LD_INT 16
97660: PUSH
97661: LD_INT 17
97663: PUSH
97664: LD_INT 18
97666: PUSH
97667: LD_INT 19
97669: PUSH
97670: LD_INT 20
97672: PUSH
97673: LD_INT 21
97675: PUSH
97676: LD_INT 22
97678: PUSH
97679: LD_INT 23
97681: PUSH
97682: LD_INT 24
97684: PUSH
97685: LD_INT 25
97687: PUSH
97688: LD_INT 26
97690: PUSH
97691: LD_INT 27
97693: PUSH
97694: LD_INT 28
97696: PUSH
97697: LD_INT 29
97699: PUSH
97700: LD_INT 30
97702: PUSH
97703: LD_INT 31
97705: PUSH
97706: LD_INT 32
97708: PUSH
97709: LD_INT 33
97711: PUSH
97712: LD_INT 34
97714: PUSH
97715: LD_INT 36
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: PUSH
97755: LD_INT 101
97757: PUSH
97758: LD_INT 102
97760: PUSH
97761: LD_INT 103
97763: PUSH
97764: LD_INT 104
97766: PUSH
97767: LD_INT 105
97769: PUSH
97770: LD_INT 106
97772: PUSH
97773: LD_INT 107
97775: PUSH
97776: LD_INT 108
97778: PUSH
97779: LD_INT 109
97781: PUSH
97782: LD_INT 110
97784: PUSH
97785: LD_INT 111
97787: PUSH
97788: LD_INT 112
97790: PUSH
97791: LD_INT 113
97793: PUSH
97794: LD_INT 114
97796: PUSH
97797: LD_INT 116
97799: PUSH
97800: LD_INT 117
97802: PUSH
97803: LD_INT 118
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: PUSH
97825: EMPTY
97826: LIST
97827: LIST
97828: ST_TO_ADDR
97829: GO 98836
97831: LD_INT 15
97833: DOUBLE
97834: EQUAL
97835: IFTRUE 97839
97837: GO 98063
97839: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97840: LD_ADDR_VAR 0 2
97844: PUSH
97845: LD_INT 1
97847: PUSH
97848: LD_INT 2
97850: PUSH
97851: LD_INT 3
97853: PUSH
97854: LD_INT 4
97856: PUSH
97857: LD_INT 5
97859: PUSH
97860: LD_INT 6
97862: PUSH
97863: LD_INT 7
97865: PUSH
97866: LD_INT 8
97868: PUSH
97869: LD_INT 9
97871: PUSH
97872: LD_INT 10
97874: PUSH
97875: LD_INT 11
97877: PUSH
97878: LD_INT 12
97880: PUSH
97881: LD_INT 13
97883: PUSH
97884: LD_INT 14
97886: PUSH
97887: LD_INT 15
97889: PUSH
97890: LD_INT 16
97892: PUSH
97893: LD_INT 17
97895: PUSH
97896: LD_INT 18
97898: PUSH
97899: LD_INT 19
97901: PUSH
97902: LD_INT 20
97904: PUSH
97905: LD_INT 21
97907: PUSH
97908: LD_INT 22
97910: PUSH
97911: LD_INT 23
97913: PUSH
97914: LD_INT 24
97916: PUSH
97917: LD_INT 25
97919: PUSH
97920: LD_INT 26
97922: PUSH
97923: LD_INT 27
97925: PUSH
97926: LD_INT 28
97928: PUSH
97929: LD_INT 29
97931: PUSH
97932: LD_INT 30
97934: PUSH
97935: LD_INT 31
97937: PUSH
97938: LD_INT 32
97940: PUSH
97941: LD_INT 33
97943: PUSH
97944: LD_INT 34
97946: PUSH
97947: LD_INT 36
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: PUSH
97987: LD_INT 101
97989: PUSH
97990: LD_INT 102
97992: PUSH
97993: LD_INT 103
97995: PUSH
97996: LD_INT 104
97998: PUSH
97999: LD_INT 105
98001: PUSH
98002: LD_INT 106
98004: PUSH
98005: LD_INT 107
98007: PUSH
98008: LD_INT 108
98010: PUSH
98011: LD_INT 109
98013: PUSH
98014: LD_INT 110
98016: PUSH
98017: LD_INT 111
98019: PUSH
98020: LD_INT 112
98022: PUSH
98023: LD_INT 113
98025: PUSH
98026: LD_INT 114
98028: PUSH
98029: LD_INT 116
98031: PUSH
98032: LD_INT 117
98034: PUSH
98035: LD_INT 118
98037: PUSH
98038: EMPTY
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: ST_TO_ADDR
98061: GO 98836
98063: LD_INT 16
98065: DOUBLE
98066: EQUAL
98067: IFTRUE 98071
98069: GO 98207
98071: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98072: LD_ADDR_VAR 0 2
98076: PUSH
98077: LD_INT 2
98079: PUSH
98080: LD_INT 4
98082: PUSH
98083: LD_INT 5
98085: PUSH
98086: LD_INT 7
98088: PUSH
98089: LD_INT 11
98091: PUSH
98092: LD_INT 12
98094: PUSH
98095: LD_INT 15
98097: PUSH
98098: LD_INT 16
98100: PUSH
98101: LD_INT 20
98103: PUSH
98104: LD_INT 21
98106: PUSH
98107: LD_INT 22
98109: PUSH
98110: LD_INT 23
98112: PUSH
98113: LD_INT 25
98115: PUSH
98116: LD_INT 26
98118: PUSH
98119: LD_INT 30
98121: PUSH
98122: LD_INT 31
98124: PUSH
98125: LD_INT 32
98127: PUSH
98128: LD_INT 33
98130: PUSH
98131: LD_INT 34
98133: PUSH
98134: EMPTY
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 101
98157: PUSH
98158: LD_INT 102
98160: PUSH
98161: LD_INT 103
98163: PUSH
98164: LD_INT 106
98166: PUSH
98167: LD_INT 108
98169: PUSH
98170: LD_INT 112
98172: PUSH
98173: LD_INT 113
98175: PUSH
98176: LD_INT 114
98178: PUSH
98179: LD_INT 116
98181: PUSH
98182: LD_INT 117
98184: PUSH
98185: LD_INT 118
98187: PUSH
98188: EMPTY
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: ST_TO_ADDR
98205: GO 98836
98207: LD_INT 17
98209: DOUBLE
98210: EQUAL
98211: IFTRUE 98215
98213: GO 98439
98215: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98216: LD_ADDR_VAR 0 2
98220: PUSH
98221: LD_INT 1
98223: PUSH
98224: LD_INT 2
98226: PUSH
98227: LD_INT 3
98229: PUSH
98230: LD_INT 4
98232: PUSH
98233: LD_INT 5
98235: PUSH
98236: LD_INT 6
98238: PUSH
98239: LD_INT 7
98241: PUSH
98242: LD_INT 8
98244: PUSH
98245: LD_INT 9
98247: PUSH
98248: LD_INT 10
98250: PUSH
98251: LD_INT 11
98253: PUSH
98254: LD_INT 12
98256: PUSH
98257: LD_INT 13
98259: PUSH
98260: LD_INT 14
98262: PUSH
98263: LD_INT 15
98265: PUSH
98266: LD_INT 16
98268: PUSH
98269: LD_INT 17
98271: PUSH
98272: LD_INT 18
98274: PUSH
98275: LD_INT 19
98277: PUSH
98278: LD_INT 20
98280: PUSH
98281: LD_INT 21
98283: PUSH
98284: LD_INT 22
98286: PUSH
98287: LD_INT 23
98289: PUSH
98290: LD_INT 24
98292: PUSH
98293: LD_INT 25
98295: PUSH
98296: LD_INT 26
98298: PUSH
98299: LD_INT 27
98301: PUSH
98302: LD_INT 28
98304: PUSH
98305: LD_INT 29
98307: PUSH
98308: LD_INT 30
98310: PUSH
98311: LD_INT 31
98313: PUSH
98314: LD_INT 32
98316: PUSH
98317: LD_INT 33
98319: PUSH
98320: LD_INT 34
98322: PUSH
98323: LD_INT 36
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: PUSH
98363: LD_INT 101
98365: PUSH
98366: LD_INT 102
98368: PUSH
98369: LD_INT 103
98371: PUSH
98372: LD_INT 104
98374: PUSH
98375: LD_INT 105
98377: PUSH
98378: LD_INT 106
98380: PUSH
98381: LD_INT 107
98383: PUSH
98384: LD_INT 108
98386: PUSH
98387: LD_INT 109
98389: PUSH
98390: LD_INT 110
98392: PUSH
98393: LD_INT 111
98395: PUSH
98396: LD_INT 112
98398: PUSH
98399: LD_INT 113
98401: PUSH
98402: LD_INT 114
98404: PUSH
98405: LD_INT 116
98407: PUSH
98408: LD_INT 117
98410: PUSH
98411: LD_INT 118
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: ST_TO_ADDR
98437: GO 98836
98439: LD_INT 18
98441: DOUBLE
98442: EQUAL
98443: IFTRUE 98447
98445: GO 98595
98447: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98448: LD_ADDR_VAR 0 2
98452: PUSH
98453: LD_INT 2
98455: PUSH
98456: LD_INT 4
98458: PUSH
98459: LD_INT 5
98461: PUSH
98462: LD_INT 7
98464: PUSH
98465: LD_INT 11
98467: PUSH
98468: LD_INT 12
98470: PUSH
98471: LD_INT 15
98473: PUSH
98474: LD_INT 16
98476: PUSH
98477: LD_INT 20
98479: PUSH
98480: LD_INT 21
98482: PUSH
98483: LD_INT 22
98485: PUSH
98486: LD_INT 23
98488: PUSH
98489: LD_INT 25
98491: PUSH
98492: LD_INT 26
98494: PUSH
98495: LD_INT 30
98497: PUSH
98498: LD_INT 31
98500: PUSH
98501: LD_INT 32
98503: PUSH
98504: LD_INT 33
98506: PUSH
98507: LD_INT 34
98509: PUSH
98510: LD_INT 35
98512: PUSH
98513: LD_INT 36
98515: PUSH
98516: EMPTY
98517: LIST
98518: LIST
98519: LIST
98520: LIST
98521: LIST
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: PUSH
98539: LD_INT 101
98541: PUSH
98542: LD_INT 102
98544: PUSH
98545: LD_INT 103
98547: PUSH
98548: LD_INT 106
98550: PUSH
98551: LD_INT 108
98553: PUSH
98554: LD_INT 112
98556: PUSH
98557: LD_INT 113
98559: PUSH
98560: LD_INT 114
98562: PUSH
98563: LD_INT 115
98565: PUSH
98566: LD_INT 116
98568: PUSH
98569: LD_INT 117
98571: PUSH
98572: LD_INT 118
98574: PUSH
98575: EMPTY
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: ST_TO_ADDR
98593: GO 98836
98595: LD_INT 19
98597: DOUBLE
98598: EQUAL
98599: IFTRUE 98603
98601: GO 98835
98603: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98604: LD_ADDR_VAR 0 2
98608: PUSH
98609: LD_INT 1
98611: PUSH
98612: LD_INT 2
98614: PUSH
98615: LD_INT 3
98617: PUSH
98618: LD_INT 4
98620: PUSH
98621: LD_INT 5
98623: PUSH
98624: LD_INT 6
98626: PUSH
98627: LD_INT 7
98629: PUSH
98630: LD_INT 8
98632: PUSH
98633: LD_INT 9
98635: PUSH
98636: LD_INT 10
98638: PUSH
98639: LD_INT 11
98641: PUSH
98642: LD_INT 12
98644: PUSH
98645: LD_INT 13
98647: PUSH
98648: LD_INT 14
98650: PUSH
98651: LD_INT 15
98653: PUSH
98654: LD_INT 16
98656: PUSH
98657: LD_INT 17
98659: PUSH
98660: LD_INT 18
98662: PUSH
98663: LD_INT 19
98665: PUSH
98666: LD_INT 20
98668: PUSH
98669: LD_INT 21
98671: PUSH
98672: LD_INT 22
98674: PUSH
98675: LD_INT 23
98677: PUSH
98678: LD_INT 24
98680: PUSH
98681: LD_INT 25
98683: PUSH
98684: LD_INT 26
98686: PUSH
98687: LD_INT 27
98689: PUSH
98690: LD_INT 28
98692: PUSH
98693: LD_INT 29
98695: PUSH
98696: LD_INT 30
98698: PUSH
98699: LD_INT 31
98701: PUSH
98702: LD_INT 32
98704: PUSH
98705: LD_INT 33
98707: PUSH
98708: LD_INT 34
98710: PUSH
98711: LD_INT 35
98713: PUSH
98714: LD_INT 36
98716: PUSH
98717: EMPTY
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: PUSH
98755: LD_INT 101
98757: PUSH
98758: LD_INT 102
98760: PUSH
98761: LD_INT 103
98763: PUSH
98764: LD_INT 104
98766: PUSH
98767: LD_INT 105
98769: PUSH
98770: LD_INT 106
98772: PUSH
98773: LD_INT 107
98775: PUSH
98776: LD_INT 108
98778: PUSH
98779: LD_INT 109
98781: PUSH
98782: LD_INT 110
98784: PUSH
98785: LD_INT 111
98787: PUSH
98788: LD_INT 112
98790: PUSH
98791: LD_INT 113
98793: PUSH
98794: LD_INT 114
98796: PUSH
98797: LD_INT 115
98799: PUSH
98800: LD_INT 116
98802: PUSH
98803: LD_INT 117
98805: PUSH
98806: LD_INT 118
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: PUSH
98829: EMPTY
98830: LIST
98831: LIST
98832: ST_TO_ADDR
98833: GO 98836
98835: POP
// end else
98836: GO 99067
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98838: LD_ADDR_VAR 0 2
98842: PUSH
98843: LD_INT 1
98845: PUSH
98846: LD_INT 2
98848: PUSH
98849: LD_INT 3
98851: PUSH
98852: LD_INT 4
98854: PUSH
98855: LD_INT 5
98857: PUSH
98858: LD_INT 6
98860: PUSH
98861: LD_INT 7
98863: PUSH
98864: LD_INT 8
98866: PUSH
98867: LD_INT 9
98869: PUSH
98870: LD_INT 10
98872: PUSH
98873: LD_INT 11
98875: PUSH
98876: LD_INT 12
98878: PUSH
98879: LD_INT 13
98881: PUSH
98882: LD_INT 14
98884: PUSH
98885: LD_INT 15
98887: PUSH
98888: LD_INT 16
98890: PUSH
98891: LD_INT 17
98893: PUSH
98894: LD_INT 18
98896: PUSH
98897: LD_INT 19
98899: PUSH
98900: LD_INT 20
98902: PUSH
98903: LD_INT 21
98905: PUSH
98906: LD_INT 22
98908: PUSH
98909: LD_INT 23
98911: PUSH
98912: LD_INT 24
98914: PUSH
98915: LD_INT 25
98917: PUSH
98918: LD_INT 26
98920: PUSH
98921: LD_INT 27
98923: PUSH
98924: LD_INT 28
98926: PUSH
98927: LD_INT 29
98929: PUSH
98930: LD_INT 30
98932: PUSH
98933: LD_INT 31
98935: PUSH
98936: LD_INT 32
98938: PUSH
98939: LD_INT 33
98941: PUSH
98942: LD_INT 34
98944: PUSH
98945: LD_INT 35
98947: PUSH
98948: LD_INT 36
98950: PUSH
98951: EMPTY
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: PUSH
98989: LD_INT 101
98991: PUSH
98992: LD_INT 102
98994: PUSH
98995: LD_INT 103
98997: PUSH
98998: LD_INT 104
99000: PUSH
99001: LD_INT 105
99003: PUSH
99004: LD_INT 106
99006: PUSH
99007: LD_INT 107
99009: PUSH
99010: LD_INT 108
99012: PUSH
99013: LD_INT 109
99015: PUSH
99016: LD_INT 110
99018: PUSH
99019: LD_INT 111
99021: PUSH
99022: LD_INT 112
99024: PUSH
99025: LD_INT 113
99027: PUSH
99028: LD_INT 114
99030: PUSH
99031: LD_INT 115
99033: PUSH
99034: LD_INT 116
99036: PUSH
99037: LD_INT 117
99039: PUSH
99040: LD_INT 118
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: PUSH
99063: EMPTY
99064: LIST
99065: LIST
99066: ST_TO_ADDR
// if result then
99067: LD_VAR 0 2
99071: IFFALSE 99857
// begin normal :=  ;
99073: LD_ADDR_VAR 0 5
99077: PUSH
99078: LD_STRING 
99080: ST_TO_ADDR
// hardcore :=  ;
99081: LD_ADDR_VAR 0 6
99085: PUSH
99086: LD_STRING 
99088: ST_TO_ADDR
// active :=  ;
99089: LD_ADDR_VAR 0 7
99093: PUSH
99094: LD_STRING 
99096: ST_TO_ADDR
// for i = 1 to normalCounter do
99097: LD_ADDR_VAR 0 8
99101: PUSH
99102: DOUBLE
99103: LD_INT 1
99105: DEC
99106: ST_TO_ADDR
99107: LD_EXP 98
99111: PUSH
99112: FOR_TO
99113: IFFALSE 99214
// begin tmp := 0 ;
99115: LD_ADDR_VAR 0 3
99119: PUSH
99120: LD_STRING 0
99122: ST_TO_ADDR
// if result [ 1 ] then
99123: LD_VAR 0 2
99127: PUSH
99128: LD_INT 1
99130: ARRAY
99131: IFFALSE 99196
// if result [ 1 ] [ 1 ] = i then
99133: LD_VAR 0 2
99137: PUSH
99138: LD_INT 1
99140: ARRAY
99141: PUSH
99142: LD_INT 1
99144: ARRAY
99145: PUSH
99146: LD_VAR 0 8
99150: EQUAL
99151: IFFALSE 99196
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99153: LD_ADDR_VAR 0 2
99157: PUSH
99158: LD_VAR 0 2
99162: PPUSH
99163: LD_INT 1
99165: PPUSH
99166: LD_VAR 0 2
99170: PUSH
99171: LD_INT 1
99173: ARRAY
99174: PPUSH
99175: LD_INT 1
99177: PPUSH
99178: CALL_OW 3
99182: PPUSH
99183: CALL_OW 1
99187: ST_TO_ADDR
// tmp := 1 ;
99188: LD_ADDR_VAR 0 3
99192: PUSH
99193: LD_STRING 1
99195: ST_TO_ADDR
// end ; normal := normal & tmp ;
99196: LD_ADDR_VAR 0 5
99200: PUSH
99201: LD_VAR 0 5
99205: PUSH
99206: LD_VAR 0 3
99210: STR
99211: ST_TO_ADDR
// end ;
99212: GO 99112
99214: POP
99215: POP
// for i = 1 to hardcoreCounter do
99216: LD_ADDR_VAR 0 8
99220: PUSH
99221: DOUBLE
99222: LD_INT 1
99224: DEC
99225: ST_TO_ADDR
99226: LD_EXP 99
99230: PUSH
99231: FOR_TO
99232: IFFALSE 99337
// begin tmp := 0 ;
99234: LD_ADDR_VAR 0 3
99238: PUSH
99239: LD_STRING 0
99241: ST_TO_ADDR
// if result [ 2 ] then
99242: LD_VAR 0 2
99246: PUSH
99247: LD_INT 2
99249: ARRAY
99250: IFFALSE 99319
// if result [ 2 ] [ 1 ] = 100 + i then
99252: LD_VAR 0 2
99256: PUSH
99257: LD_INT 2
99259: ARRAY
99260: PUSH
99261: LD_INT 1
99263: ARRAY
99264: PUSH
99265: LD_INT 100
99267: PUSH
99268: LD_VAR 0 8
99272: PLUS
99273: EQUAL
99274: IFFALSE 99319
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99276: LD_ADDR_VAR 0 2
99280: PUSH
99281: LD_VAR 0 2
99285: PPUSH
99286: LD_INT 2
99288: PPUSH
99289: LD_VAR 0 2
99293: PUSH
99294: LD_INT 2
99296: ARRAY
99297: PPUSH
99298: LD_INT 1
99300: PPUSH
99301: CALL_OW 3
99305: PPUSH
99306: CALL_OW 1
99310: ST_TO_ADDR
// tmp := 1 ;
99311: LD_ADDR_VAR 0 3
99315: PUSH
99316: LD_STRING 1
99318: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99319: LD_ADDR_VAR 0 6
99323: PUSH
99324: LD_VAR 0 6
99328: PUSH
99329: LD_VAR 0 3
99333: STR
99334: ST_TO_ADDR
// end ;
99335: GO 99231
99337: POP
99338: POP
// if isGameLoad then
99339: LD_VAR 0 1
99343: IFFALSE 99818
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99345: LD_ADDR_VAR 0 4
99349: PUSH
99350: LD_EXP 102
99354: PUSH
99355: LD_EXP 101
99359: PUSH
99360: LD_EXP 103
99364: PUSH
99365: LD_EXP 100
99369: PUSH
99370: LD_EXP 104
99374: PUSH
99375: LD_EXP 105
99379: PUSH
99380: LD_EXP 106
99384: PUSH
99385: LD_EXP 107
99389: PUSH
99390: LD_EXP 108
99394: PUSH
99395: LD_EXP 109
99399: PUSH
99400: LD_EXP 110
99404: PUSH
99405: LD_EXP 111
99409: PUSH
99410: LD_EXP 112
99414: PUSH
99415: LD_EXP 113
99419: PUSH
99420: LD_EXP 121
99424: PUSH
99425: LD_EXP 122
99429: PUSH
99430: LD_EXP 123
99434: PUSH
99435: LD_EXP 124
99439: PUSH
99440: LD_EXP 126
99444: PUSH
99445: LD_EXP 127
99449: PUSH
99450: LD_EXP 128
99454: PUSH
99455: LD_EXP 131
99459: PUSH
99460: LD_EXP 133
99464: PUSH
99465: LD_EXP 134
99469: PUSH
99470: LD_EXP 135
99474: PUSH
99475: LD_EXP 137
99479: PUSH
99480: LD_EXP 138
99484: PUSH
99485: LD_EXP 141
99489: PUSH
99490: LD_EXP 142
99494: PUSH
99495: LD_EXP 143
99499: PUSH
99500: LD_EXP 144
99504: PUSH
99505: LD_EXP 145
99509: PUSH
99510: LD_EXP 146
99514: PUSH
99515: LD_EXP 147
99519: PUSH
99520: LD_EXP 148
99524: PUSH
99525: LD_EXP 149
99529: PUSH
99530: LD_EXP 114
99534: PUSH
99535: LD_EXP 115
99539: PUSH
99540: LD_EXP 118
99544: PUSH
99545: LD_EXP 119
99549: PUSH
99550: LD_EXP 120
99554: PUSH
99555: LD_EXP 116
99559: PUSH
99560: LD_EXP 117
99564: PUSH
99565: LD_EXP 125
99569: PUSH
99570: LD_EXP 129
99574: PUSH
99575: LD_EXP 130
99579: PUSH
99580: LD_EXP 132
99584: PUSH
99585: LD_EXP 136
99589: PUSH
99590: LD_EXP 139
99594: PUSH
99595: LD_EXP 140
99599: PUSH
99600: LD_EXP 150
99604: PUSH
99605: LD_EXP 151
99609: PUSH
99610: LD_EXP 152
99614: PUSH
99615: LD_EXP 153
99619: PUSH
99620: EMPTY
99621: LIST
99622: LIST
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: ST_TO_ADDR
// tmp :=  ;
99676: LD_ADDR_VAR 0 3
99680: PUSH
99681: LD_STRING 
99683: ST_TO_ADDR
// for i = 1 to normalCounter do
99684: LD_ADDR_VAR 0 8
99688: PUSH
99689: DOUBLE
99690: LD_INT 1
99692: DEC
99693: ST_TO_ADDR
99694: LD_EXP 98
99698: PUSH
99699: FOR_TO
99700: IFFALSE 99736
// begin if flags [ i ] then
99702: LD_VAR 0 4
99706: PUSH
99707: LD_VAR 0 8
99711: ARRAY
99712: IFFALSE 99734
// tmp := tmp & i & ; ;
99714: LD_ADDR_VAR 0 3
99718: PUSH
99719: LD_VAR 0 3
99723: PUSH
99724: LD_VAR 0 8
99728: STR
99729: PUSH
99730: LD_STRING ;
99732: STR
99733: ST_TO_ADDR
// end ;
99734: GO 99699
99736: POP
99737: POP
// for i = 1 to hardcoreCounter do
99738: LD_ADDR_VAR 0 8
99742: PUSH
99743: DOUBLE
99744: LD_INT 1
99746: DEC
99747: ST_TO_ADDR
99748: LD_EXP 99
99752: PUSH
99753: FOR_TO
99754: IFFALSE 99800
// begin if flags [ normalCounter + i ] then
99756: LD_VAR 0 4
99760: PUSH
99761: LD_EXP 98
99765: PUSH
99766: LD_VAR 0 8
99770: PLUS
99771: ARRAY
99772: IFFALSE 99798
// tmp := tmp & ( 100 + i ) & ; ;
99774: LD_ADDR_VAR 0 3
99778: PUSH
99779: LD_VAR 0 3
99783: PUSH
99784: LD_INT 100
99786: PUSH
99787: LD_VAR 0 8
99791: PLUS
99792: STR
99793: PUSH
99794: LD_STRING ;
99796: STR
99797: ST_TO_ADDR
// end ;
99798: GO 99753
99800: POP
99801: POP
// if tmp then
99802: LD_VAR 0 3
99806: IFFALSE 99818
// active := tmp ;
99808: LD_ADDR_VAR 0 7
99812: PUSH
99813: LD_VAR 0 3
99817: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99818: LD_STRING getStreamItemsFromMission("
99820: PUSH
99821: LD_VAR 0 5
99825: STR
99826: PUSH
99827: LD_STRING ","
99829: STR
99830: PUSH
99831: LD_VAR 0 6
99835: STR
99836: PUSH
99837: LD_STRING ","
99839: STR
99840: PUSH
99841: LD_VAR 0 7
99845: STR
99846: PUSH
99847: LD_STRING ")
99849: STR
99850: PPUSH
99851: CALL_OW 559
// end else
99855: GO 99864
// ToLua ( getStreamItemsFromMission("","","") ) ;
99857: LD_STRING getStreamItemsFromMission("","","")
99859: PPUSH
99860: CALL_OW 559
// end ;
99864: LD_VAR 0 2
99868: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99869: LD_EXP 97
99873: PUSH
99874: LD_EXP 102
99878: AND
99879: IFFALSE 100003
99881: GO 99883
99883: DISABLE
99884: LD_INT 0
99886: PPUSH
99887: PPUSH
// begin enable ;
99888: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99889: LD_ADDR_VAR 0 2
99893: PUSH
99894: LD_INT 22
99896: PUSH
99897: LD_OWVAR 2
99901: PUSH
99902: EMPTY
99903: LIST
99904: LIST
99905: PUSH
99906: LD_INT 2
99908: PUSH
99909: LD_INT 34
99911: PUSH
99912: LD_INT 7
99914: PUSH
99915: EMPTY
99916: LIST
99917: LIST
99918: PUSH
99919: LD_INT 34
99921: PUSH
99922: LD_INT 45
99924: PUSH
99925: EMPTY
99926: LIST
99927: LIST
99928: PUSH
99929: LD_INT 34
99931: PUSH
99932: LD_INT 28
99934: PUSH
99935: EMPTY
99936: LIST
99937: LIST
99938: PUSH
99939: LD_INT 34
99941: PUSH
99942: LD_INT 47
99944: PUSH
99945: EMPTY
99946: LIST
99947: LIST
99948: PUSH
99949: EMPTY
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: PUSH
99956: EMPTY
99957: LIST
99958: LIST
99959: PPUSH
99960: CALL_OW 69
99964: ST_TO_ADDR
// if not tmp then
99965: LD_VAR 0 2
99969: NOT
99970: IFFALSE 99974
// exit ;
99972: GO 100003
// for i in tmp do
99974: LD_ADDR_VAR 0 1
99978: PUSH
99979: LD_VAR 0 2
99983: PUSH
99984: FOR_IN
99985: IFFALSE 100001
// begin SetLives ( i , 0 ) ;
99987: LD_VAR 0 1
99991: PPUSH
99992: LD_INT 0
99994: PPUSH
99995: CALL_OW 234
// end ;
99999: GO 99984
100001: POP
100002: POP
// end ;
100003: PPOPN 2
100005: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100006: LD_EXP 97
100010: PUSH
100011: LD_EXP 103
100015: AND
100016: IFFALSE 100100
100018: GO 100020
100020: DISABLE
100021: LD_INT 0
100023: PPUSH
100024: PPUSH
// begin enable ;
100025: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100026: LD_ADDR_VAR 0 2
100030: PUSH
100031: LD_INT 22
100033: PUSH
100034: LD_OWVAR 2
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 32
100045: PUSH
100046: LD_INT 3
100048: PUSH
100049: EMPTY
100050: LIST
100051: LIST
100052: PUSH
100053: EMPTY
100054: LIST
100055: LIST
100056: PPUSH
100057: CALL_OW 69
100061: ST_TO_ADDR
// if not tmp then
100062: LD_VAR 0 2
100066: NOT
100067: IFFALSE 100071
// exit ;
100069: GO 100100
// for i in tmp do
100071: LD_ADDR_VAR 0 1
100075: PUSH
100076: LD_VAR 0 2
100080: PUSH
100081: FOR_IN
100082: IFFALSE 100098
// begin SetLives ( i , 0 ) ;
100084: LD_VAR 0 1
100088: PPUSH
100089: LD_INT 0
100091: PPUSH
100092: CALL_OW 234
// end ;
100096: GO 100081
100098: POP
100099: POP
// end ;
100100: PPOPN 2
100102: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100103: LD_EXP 97
100107: PUSH
100108: LD_EXP 100
100112: AND
100113: IFFALSE 100206
100115: GO 100117
100117: DISABLE
100118: LD_INT 0
100120: PPUSH
// begin enable ;
100121: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100122: LD_ADDR_VAR 0 1
100126: PUSH
100127: LD_INT 22
100129: PUSH
100130: LD_OWVAR 2
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: PUSH
100139: LD_INT 2
100141: PUSH
100142: LD_INT 25
100144: PUSH
100145: LD_INT 5
100147: PUSH
100148: EMPTY
100149: LIST
100150: LIST
100151: PUSH
100152: LD_INT 25
100154: PUSH
100155: LD_INT 9
100157: PUSH
100158: EMPTY
100159: LIST
100160: LIST
100161: PUSH
100162: LD_INT 25
100164: PUSH
100165: LD_INT 8
100167: PUSH
100168: EMPTY
100169: LIST
100170: LIST
100171: PUSH
100172: EMPTY
100173: LIST
100174: LIST
100175: LIST
100176: LIST
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PPUSH
100182: CALL_OW 69
100186: PUSH
100187: FOR_IN
100188: IFFALSE 100204
// begin SetClass ( i , 1 ) ;
100190: LD_VAR 0 1
100194: PPUSH
100195: LD_INT 1
100197: PPUSH
100198: CALL_OW 336
// end ;
100202: GO 100187
100204: POP
100205: POP
// end ;
100206: PPOPN 1
100208: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100209: LD_EXP 97
100213: PUSH
100214: LD_EXP 101
100218: AND
100219: PUSH
100220: LD_OWVAR 65
100224: PUSH
100225: LD_INT 7
100227: LESS
100228: AND
100229: IFFALSE 100243
100231: GO 100233
100233: DISABLE
// begin enable ;
100234: ENABLE
// game_speed := 7 ;
100235: LD_ADDR_OWVAR 65
100239: PUSH
100240: LD_INT 7
100242: ST_TO_ADDR
// end ;
100243: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100244: LD_EXP 97
100248: PUSH
100249: LD_EXP 104
100253: AND
100254: IFFALSE 100456
100256: GO 100258
100258: DISABLE
100259: LD_INT 0
100261: PPUSH
100262: PPUSH
100263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100264: LD_ADDR_VAR 0 3
100268: PUSH
100269: LD_INT 81
100271: PUSH
100272: LD_OWVAR 2
100276: PUSH
100277: EMPTY
100278: LIST
100279: LIST
100280: PUSH
100281: LD_INT 21
100283: PUSH
100284: LD_INT 1
100286: PUSH
100287: EMPTY
100288: LIST
100289: LIST
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: PPUSH
100295: CALL_OW 69
100299: ST_TO_ADDR
// if not tmp then
100300: LD_VAR 0 3
100304: NOT
100305: IFFALSE 100309
// exit ;
100307: GO 100456
// if tmp > 5 then
100309: LD_VAR 0 3
100313: PUSH
100314: LD_INT 5
100316: GREATER
100317: IFFALSE 100329
// k := 5 else
100319: LD_ADDR_VAR 0 2
100323: PUSH
100324: LD_INT 5
100326: ST_TO_ADDR
100327: GO 100339
// k := tmp ;
100329: LD_ADDR_VAR 0 2
100333: PUSH
100334: LD_VAR 0 3
100338: ST_TO_ADDR
// for i := 1 to k do
100339: LD_ADDR_VAR 0 1
100343: PUSH
100344: DOUBLE
100345: LD_INT 1
100347: DEC
100348: ST_TO_ADDR
100349: LD_VAR 0 2
100353: PUSH
100354: FOR_TO
100355: IFFALSE 100454
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100357: LD_VAR 0 3
100361: PUSH
100362: LD_VAR 0 1
100366: ARRAY
100367: PPUSH
100368: LD_VAR 0 1
100372: PUSH
100373: LD_INT 4
100375: MOD
100376: PUSH
100377: LD_INT 1
100379: PLUS
100380: PPUSH
100381: CALL_OW 259
100385: PUSH
100386: LD_INT 10
100388: LESS
100389: IFFALSE 100452
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100391: LD_VAR 0 3
100395: PUSH
100396: LD_VAR 0 1
100400: ARRAY
100401: PPUSH
100402: LD_VAR 0 1
100406: PUSH
100407: LD_INT 4
100409: MOD
100410: PUSH
100411: LD_INT 1
100413: PLUS
100414: PPUSH
100415: LD_VAR 0 3
100419: PUSH
100420: LD_VAR 0 1
100424: ARRAY
100425: PPUSH
100426: LD_VAR 0 1
100430: PUSH
100431: LD_INT 4
100433: MOD
100434: PUSH
100435: LD_INT 1
100437: PLUS
100438: PPUSH
100439: CALL_OW 259
100443: PUSH
100444: LD_INT 1
100446: PLUS
100447: PPUSH
100448: CALL_OW 237
100452: GO 100354
100454: POP
100455: POP
// end ;
100456: PPOPN 3
100458: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100459: LD_EXP 97
100463: PUSH
100464: LD_EXP 105
100468: AND
100469: IFFALSE 100489
100471: GO 100473
100473: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100474: LD_INT 4
100476: PPUSH
100477: LD_OWVAR 2
100481: PPUSH
100482: LD_INT 0
100484: PPUSH
100485: CALL_OW 324
100489: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100490: LD_EXP 97
100494: PUSH
100495: LD_EXP 134
100499: AND
100500: IFFALSE 100520
100502: GO 100504
100504: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100505: LD_INT 19
100507: PPUSH
100508: LD_OWVAR 2
100512: PPUSH
100513: LD_INT 0
100515: PPUSH
100516: CALL_OW 324
100520: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100521: LD_EXP 97
100525: PUSH
100526: LD_EXP 106
100530: AND
100531: IFFALSE 100633
100533: GO 100535
100535: DISABLE
100536: LD_INT 0
100538: PPUSH
100539: PPUSH
// begin enable ;
100540: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100541: LD_ADDR_VAR 0 2
100545: PUSH
100546: LD_INT 22
100548: PUSH
100549: LD_OWVAR 2
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: PUSH
100558: LD_INT 2
100560: PUSH
100561: LD_INT 34
100563: PUSH
100564: LD_INT 11
100566: PUSH
100567: EMPTY
100568: LIST
100569: LIST
100570: PUSH
100571: LD_INT 34
100573: PUSH
100574: LD_INT 30
100576: PUSH
100577: EMPTY
100578: LIST
100579: LIST
100580: PUSH
100581: EMPTY
100582: LIST
100583: LIST
100584: LIST
100585: PUSH
100586: EMPTY
100587: LIST
100588: LIST
100589: PPUSH
100590: CALL_OW 69
100594: ST_TO_ADDR
// if not tmp then
100595: LD_VAR 0 2
100599: NOT
100600: IFFALSE 100604
// exit ;
100602: GO 100633
// for i in tmp do
100604: LD_ADDR_VAR 0 1
100608: PUSH
100609: LD_VAR 0 2
100613: PUSH
100614: FOR_IN
100615: IFFALSE 100631
// begin SetLives ( i , 0 ) ;
100617: LD_VAR 0 1
100621: PPUSH
100622: LD_INT 0
100624: PPUSH
100625: CALL_OW 234
// end ;
100629: GO 100614
100631: POP
100632: POP
// end ;
100633: PPOPN 2
100635: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100636: LD_EXP 97
100640: PUSH
100641: LD_EXP 107
100645: AND
100646: IFFALSE 100666
100648: GO 100650
100650: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100651: LD_INT 32
100653: PPUSH
100654: LD_OWVAR 2
100658: PPUSH
100659: LD_INT 0
100661: PPUSH
100662: CALL_OW 324
100666: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100667: LD_EXP 97
100671: PUSH
100672: LD_EXP 108
100676: AND
100677: IFFALSE 100858
100679: GO 100681
100681: DISABLE
100682: LD_INT 0
100684: PPUSH
100685: PPUSH
100686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100687: LD_ADDR_VAR 0 2
100691: PUSH
100692: LD_INT 22
100694: PUSH
100695: LD_OWVAR 2
100699: PUSH
100700: EMPTY
100701: LIST
100702: LIST
100703: PUSH
100704: LD_INT 33
100706: PUSH
100707: LD_INT 3
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: PUSH
100714: EMPTY
100715: LIST
100716: LIST
100717: PPUSH
100718: CALL_OW 69
100722: ST_TO_ADDR
// if not tmp then
100723: LD_VAR 0 2
100727: NOT
100728: IFFALSE 100732
// exit ;
100730: GO 100858
// side := 0 ;
100732: LD_ADDR_VAR 0 3
100736: PUSH
100737: LD_INT 0
100739: ST_TO_ADDR
// for i := 1 to 8 do
100740: LD_ADDR_VAR 0 1
100744: PUSH
100745: DOUBLE
100746: LD_INT 1
100748: DEC
100749: ST_TO_ADDR
100750: LD_INT 8
100752: PUSH
100753: FOR_TO
100754: IFFALSE 100802
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100756: LD_OWVAR 2
100760: PUSH
100761: LD_VAR 0 1
100765: NONEQUAL
100766: PUSH
100767: LD_OWVAR 2
100771: PPUSH
100772: LD_VAR 0 1
100776: PPUSH
100777: CALL_OW 81
100781: PUSH
100782: LD_INT 2
100784: EQUAL
100785: AND
100786: IFFALSE 100800
// begin side := i ;
100788: LD_ADDR_VAR 0 3
100792: PUSH
100793: LD_VAR 0 1
100797: ST_TO_ADDR
// break ;
100798: GO 100802
// end ;
100800: GO 100753
100802: POP
100803: POP
// if not side then
100804: LD_VAR 0 3
100808: NOT
100809: IFFALSE 100813
// exit ;
100811: GO 100858
// for i := 1 to tmp do
100813: LD_ADDR_VAR 0 1
100817: PUSH
100818: DOUBLE
100819: LD_INT 1
100821: DEC
100822: ST_TO_ADDR
100823: LD_VAR 0 2
100827: PUSH
100828: FOR_TO
100829: IFFALSE 100856
// if Prob ( 60 ) then
100831: LD_INT 60
100833: PPUSH
100834: CALL_OW 13
100838: IFFALSE 100854
// SetSide ( i , side ) ;
100840: LD_VAR 0 1
100844: PPUSH
100845: LD_VAR 0 3
100849: PPUSH
100850: CALL_OW 235
100854: GO 100828
100856: POP
100857: POP
// end ;
100858: PPOPN 3
100860: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100861: LD_EXP 97
100865: PUSH
100866: LD_EXP 110
100870: AND
100871: IFFALSE 100990
100873: GO 100875
100875: DISABLE
100876: LD_INT 0
100878: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100879: LD_ADDR_VAR 0 1
100883: PUSH
100884: LD_INT 22
100886: PUSH
100887: LD_OWVAR 2
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PUSH
100896: LD_INT 21
100898: PUSH
100899: LD_INT 1
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PUSH
100906: LD_INT 3
100908: PUSH
100909: LD_INT 23
100911: PUSH
100912: LD_INT 0
100914: PUSH
100915: EMPTY
100916: LIST
100917: LIST
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: LIST
100927: PPUSH
100928: CALL_OW 69
100932: PUSH
100933: FOR_IN
100934: IFFALSE 100988
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100936: LD_VAR 0 1
100940: PPUSH
100941: CALL_OW 257
100945: PUSH
100946: LD_INT 1
100948: PUSH
100949: LD_INT 2
100951: PUSH
100952: LD_INT 3
100954: PUSH
100955: LD_INT 4
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: LIST
100962: LIST
100963: IN
100964: IFFALSE 100986
// SetClass ( un , rand ( 1 , 4 ) ) ;
100966: LD_VAR 0 1
100970: PPUSH
100971: LD_INT 1
100973: PPUSH
100974: LD_INT 4
100976: PPUSH
100977: CALL_OW 12
100981: PPUSH
100982: CALL_OW 336
100986: GO 100933
100988: POP
100989: POP
// end ;
100990: PPOPN 1
100992: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100993: LD_EXP 97
100997: PUSH
100998: LD_EXP 109
101002: AND
101003: IFFALSE 101082
101005: GO 101007
101007: DISABLE
101008: LD_INT 0
101010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101011: LD_ADDR_VAR 0 1
101015: PUSH
101016: LD_INT 22
101018: PUSH
101019: LD_OWVAR 2
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: LD_INT 21
101030: PUSH
101031: LD_INT 3
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: PPUSH
101042: CALL_OW 69
101046: ST_TO_ADDR
// if not tmp then
101047: LD_VAR 0 1
101051: NOT
101052: IFFALSE 101056
// exit ;
101054: GO 101082
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101056: LD_VAR 0 1
101060: PUSH
101061: LD_INT 1
101063: PPUSH
101064: LD_VAR 0 1
101068: PPUSH
101069: CALL_OW 12
101073: ARRAY
101074: PPUSH
101075: LD_INT 100
101077: PPUSH
101078: CALL_OW 234
// end ;
101082: PPOPN 1
101084: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101085: LD_EXP 97
101089: PUSH
101090: LD_EXP 111
101094: AND
101095: IFFALSE 101193
101097: GO 101099
101099: DISABLE
101100: LD_INT 0
101102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101103: LD_ADDR_VAR 0 1
101107: PUSH
101108: LD_INT 22
101110: PUSH
101111: LD_OWVAR 2
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PUSH
101120: LD_INT 21
101122: PUSH
101123: LD_INT 1
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PUSH
101130: EMPTY
101131: LIST
101132: LIST
101133: PPUSH
101134: CALL_OW 69
101138: ST_TO_ADDR
// if not tmp then
101139: LD_VAR 0 1
101143: NOT
101144: IFFALSE 101148
// exit ;
101146: GO 101193
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101148: LD_VAR 0 1
101152: PUSH
101153: LD_INT 1
101155: PPUSH
101156: LD_VAR 0 1
101160: PPUSH
101161: CALL_OW 12
101165: ARRAY
101166: PPUSH
101167: LD_INT 1
101169: PPUSH
101170: LD_INT 4
101172: PPUSH
101173: CALL_OW 12
101177: PPUSH
101178: LD_INT 3000
101180: PPUSH
101181: LD_INT 9000
101183: PPUSH
101184: CALL_OW 12
101188: PPUSH
101189: CALL_OW 492
// end ;
101193: PPOPN 1
101195: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101196: LD_EXP 97
101200: PUSH
101201: LD_EXP 112
101205: AND
101206: IFFALSE 101226
101208: GO 101210
101210: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101211: LD_INT 1
101213: PPUSH
101214: LD_OWVAR 2
101218: PPUSH
101219: LD_INT 0
101221: PPUSH
101222: CALL_OW 324
101226: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101227: LD_EXP 97
101231: PUSH
101232: LD_EXP 113
101236: AND
101237: IFFALSE 101320
101239: GO 101241
101241: DISABLE
101242: LD_INT 0
101244: PPUSH
101245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101246: LD_ADDR_VAR 0 2
101250: PUSH
101251: LD_INT 22
101253: PUSH
101254: LD_OWVAR 2
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: LD_INT 21
101265: PUSH
101266: LD_INT 3
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: PPUSH
101277: CALL_OW 69
101281: ST_TO_ADDR
// if not tmp then
101282: LD_VAR 0 2
101286: NOT
101287: IFFALSE 101291
// exit ;
101289: GO 101320
// for i in tmp do
101291: LD_ADDR_VAR 0 1
101295: PUSH
101296: LD_VAR 0 2
101300: PUSH
101301: FOR_IN
101302: IFFALSE 101318
// SetBLevel ( i , 10 ) ;
101304: LD_VAR 0 1
101308: PPUSH
101309: LD_INT 10
101311: PPUSH
101312: CALL_OW 241
101316: GO 101301
101318: POP
101319: POP
// end ;
101320: PPOPN 2
101322: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101323: LD_EXP 97
101327: PUSH
101328: LD_EXP 114
101332: AND
101333: IFFALSE 101444
101335: GO 101337
101337: DISABLE
101338: LD_INT 0
101340: PPUSH
101341: PPUSH
101342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101343: LD_ADDR_VAR 0 3
101347: PUSH
101348: LD_INT 22
101350: PUSH
101351: LD_OWVAR 2
101355: PUSH
101356: EMPTY
101357: LIST
101358: LIST
101359: PUSH
101360: LD_INT 25
101362: PUSH
101363: LD_INT 1
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: PUSH
101370: EMPTY
101371: LIST
101372: LIST
101373: PPUSH
101374: CALL_OW 69
101378: ST_TO_ADDR
// if not tmp then
101379: LD_VAR 0 3
101383: NOT
101384: IFFALSE 101388
// exit ;
101386: GO 101444
// un := tmp [ rand ( 1 , tmp ) ] ;
101388: LD_ADDR_VAR 0 2
101392: PUSH
101393: LD_VAR 0 3
101397: PUSH
101398: LD_INT 1
101400: PPUSH
101401: LD_VAR 0 3
101405: PPUSH
101406: CALL_OW 12
101410: ARRAY
101411: ST_TO_ADDR
// if Crawls ( un ) then
101412: LD_VAR 0 2
101416: PPUSH
101417: CALL_OW 318
101421: IFFALSE 101432
// ComWalk ( un ) ;
101423: LD_VAR 0 2
101427: PPUSH
101428: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101432: LD_VAR 0 2
101436: PPUSH
101437: LD_INT 5
101439: PPUSH
101440: CALL_OW 336
// end ;
101444: PPOPN 3
101446: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101447: LD_EXP 97
101451: PUSH
101452: LD_EXP 115
101456: AND
101457: PUSH
101458: LD_OWVAR 67
101462: PUSH
101463: LD_INT 4
101465: LESS
101466: AND
101467: IFFALSE 101486
101469: GO 101471
101471: DISABLE
// begin Difficulty := Difficulty + 1 ;
101472: LD_ADDR_OWVAR 67
101476: PUSH
101477: LD_OWVAR 67
101481: PUSH
101482: LD_INT 1
101484: PLUS
101485: ST_TO_ADDR
// end ;
101486: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101487: LD_EXP 97
101491: PUSH
101492: LD_EXP 116
101496: AND
101497: IFFALSE 101600
101499: GO 101501
101501: DISABLE
101502: LD_INT 0
101504: PPUSH
// begin for i := 1 to 5 do
101505: LD_ADDR_VAR 0 1
101509: PUSH
101510: DOUBLE
101511: LD_INT 1
101513: DEC
101514: ST_TO_ADDR
101515: LD_INT 5
101517: PUSH
101518: FOR_TO
101519: IFFALSE 101598
// begin uc_nation := nation_nature ;
101521: LD_ADDR_OWVAR 21
101525: PUSH
101526: LD_INT 0
101528: ST_TO_ADDR
// uc_side := 0 ;
101529: LD_ADDR_OWVAR 20
101533: PUSH
101534: LD_INT 0
101536: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101537: LD_ADDR_OWVAR 29
101541: PUSH
101542: LD_INT 12
101544: PUSH
101545: LD_INT 12
101547: PUSH
101548: EMPTY
101549: LIST
101550: LIST
101551: ST_TO_ADDR
// hc_agressivity := 20 ;
101552: LD_ADDR_OWVAR 35
101556: PUSH
101557: LD_INT 20
101559: ST_TO_ADDR
// hc_class := class_tiger ;
101560: LD_ADDR_OWVAR 28
101564: PUSH
101565: LD_INT 14
101567: ST_TO_ADDR
// hc_gallery :=  ;
101568: LD_ADDR_OWVAR 33
101572: PUSH
101573: LD_STRING 
101575: ST_TO_ADDR
// hc_name :=  ;
101576: LD_ADDR_OWVAR 26
101580: PUSH
101581: LD_STRING 
101583: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101584: CALL_OW 44
101588: PPUSH
101589: LD_INT 0
101591: PPUSH
101592: CALL_OW 51
// end ;
101596: GO 101518
101598: POP
101599: POP
// end ;
101600: PPOPN 1
101602: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101603: LD_EXP 97
101607: PUSH
101608: LD_EXP 117
101612: AND
101613: IFFALSE 101622
101615: GO 101617
101617: DISABLE
// StreamSibBomb ;
101618: CALL 101623 0 0
101622: END
// export function StreamSibBomb ; var i , x , y ; begin
101623: LD_INT 0
101625: PPUSH
101626: PPUSH
101627: PPUSH
101628: PPUSH
// result := false ;
101629: LD_ADDR_VAR 0 1
101633: PUSH
101634: LD_INT 0
101636: ST_TO_ADDR
// for i := 1 to 16 do
101637: LD_ADDR_VAR 0 2
101641: PUSH
101642: DOUBLE
101643: LD_INT 1
101645: DEC
101646: ST_TO_ADDR
101647: LD_INT 16
101649: PUSH
101650: FOR_TO
101651: IFFALSE 101850
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101653: LD_ADDR_VAR 0 3
101657: PUSH
101658: LD_INT 10
101660: PUSH
101661: LD_INT 20
101663: PUSH
101664: LD_INT 30
101666: PUSH
101667: LD_INT 40
101669: PUSH
101670: LD_INT 50
101672: PUSH
101673: LD_INT 60
101675: PUSH
101676: LD_INT 70
101678: PUSH
101679: LD_INT 80
101681: PUSH
101682: LD_INT 90
101684: PUSH
101685: LD_INT 100
101687: PUSH
101688: LD_INT 110
101690: PUSH
101691: LD_INT 120
101693: PUSH
101694: LD_INT 130
101696: PUSH
101697: LD_INT 140
101699: PUSH
101700: LD_INT 150
101702: PUSH
101703: EMPTY
101704: LIST
101705: LIST
101706: LIST
101707: LIST
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: LIST
101716: LIST
101717: LIST
101718: LIST
101719: PUSH
101720: LD_INT 1
101722: PPUSH
101723: LD_INT 15
101725: PPUSH
101726: CALL_OW 12
101730: ARRAY
101731: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101732: LD_ADDR_VAR 0 4
101736: PUSH
101737: LD_INT 10
101739: PUSH
101740: LD_INT 20
101742: PUSH
101743: LD_INT 30
101745: PUSH
101746: LD_INT 40
101748: PUSH
101749: LD_INT 50
101751: PUSH
101752: LD_INT 60
101754: PUSH
101755: LD_INT 70
101757: PUSH
101758: LD_INT 80
101760: PUSH
101761: LD_INT 90
101763: PUSH
101764: LD_INT 100
101766: PUSH
101767: LD_INT 110
101769: PUSH
101770: LD_INT 120
101772: PUSH
101773: LD_INT 130
101775: PUSH
101776: LD_INT 140
101778: PUSH
101779: LD_INT 150
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: LIST
101786: LIST
101787: LIST
101788: LIST
101789: LIST
101790: LIST
101791: LIST
101792: LIST
101793: LIST
101794: LIST
101795: LIST
101796: LIST
101797: LIST
101798: PUSH
101799: LD_INT 1
101801: PPUSH
101802: LD_INT 15
101804: PPUSH
101805: CALL_OW 12
101809: ARRAY
101810: ST_TO_ADDR
// if ValidHex ( x , y ) then
101811: LD_VAR 0 3
101815: PPUSH
101816: LD_VAR 0 4
101820: PPUSH
101821: CALL_OW 488
101825: IFFALSE 101848
// begin result := [ x , y ] ;
101827: LD_ADDR_VAR 0 1
101831: PUSH
101832: LD_VAR 0 3
101836: PUSH
101837: LD_VAR 0 4
101841: PUSH
101842: EMPTY
101843: LIST
101844: LIST
101845: ST_TO_ADDR
// break ;
101846: GO 101850
// end ; end ;
101848: GO 101650
101850: POP
101851: POP
// if result then
101852: LD_VAR 0 1
101856: IFFALSE 101916
// begin ToLua ( playSibBomb() ) ;
101858: LD_STRING playSibBomb()
101860: PPUSH
101861: CALL_OW 559
// wait ( 0 0$14 ) ;
101865: LD_INT 490
101867: PPUSH
101868: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101872: LD_VAR 0 1
101876: PUSH
101877: LD_INT 1
101879: ARRAY
101880: PPUSH
101881: LD_VAR 0 1
101885: PUSH
101886: LD_INT 2
101888: ARRAY
101889: PPUSH
101890: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101894: LD_VAR 0 1
101898: PUSH
101899: LD_INT 1
101901: ARRAY
101902: PPUSH
101903: LD_VAR 0 1
101907: PUSH
101908: LD_INT 2
101910: ARRAY
101911: PPUSH
101912: CALL_OW 429
// end ; end ;
101916: LD_VAR 0 1
101920: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101921: LD_EXP 97
101925: PUSH
101926: LD_EXP 119
101930: AND
101931: IFFALSE 101943
101933: GO 101935
101935: DISABLE
// YouLost (  ) ;
101936: LD_STRING 
101938: PPUSH
101939: CALL_OW 104
101943: END
// every 0 0$1 trigger StreamModeActive and sFog do
101944: LD_EXP 97
101948: PUSH
101949: LD_EXP 118
101953: AND
101954: IFFALSE 101968
101956: GO 101958
101958: DISABLE
// FogOff ( your_side ) ;
101959: LD_OWVAR 2
101963: PPUSH
101964: CALL_OW 344
101968: END
// every 0 0$1 trigger StreamModeActive and sSun do
101969: LD_EXP 97
101973: PUSH
101974: LD_EXP 120
101978: AND
101979: IFFALSE 102007
101981: GO 101983
101983: DISABLE
// begin solar_recharge_percent := 0 ;
101984: LD_ADDR_OWVAR 79
101988: PUSH
101989: LD_INT 0
101991: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101992: LD_INT 10500
101994: PPUSH
101995: CALL_OW 67
// solar_recharge_percent := 100 ;
101999: LD_ADDR_OWVAR 79
102003: PUSH
102004: LD_INT 100
102006: ST_TO_ADDR
// end ;
102007: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102008: LD_EXP 97
102012: PUSH
102013: LD_EXP 121
102017: AND
102018: IFFALSE 102257
102020: GO 102022
102022: DISABLE
102023: LD_INT 0
102025: PPUSH
102026: PPUSH
102027: PPUSH
// begin tmp := [ ] ;
102028: LD_ADDR_VAR 0 3
102032: PUSH
102033: EMPTY
102034: ST_TO_ADDR
// for i := 1 to 6 do
102035: LD_ADDR_VAR 0 1
102039: PUSH
102040: DOUBLE
102041: LD_INT 1
102043: DEC
102044: ST_TO_ADDR
102045: LD_INT 6
102047: PUSH
102048: FOR_TO
102049: IFFALSE 102154
// begin uc_nation := nation_nature ;
102051: LD_ADDR_OWVAR 21
102055: PUSH
102056: LD_INT 0
102058: ST_TO_ADDR
// uc_side := 0 ;
102059: LD_ADDR_OWVAR 20
102063: PUSH
102064: LD_INT 0
102066: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102067: LD_ADDR_OWVAR 29
102071: PUSH
102072: LD_INT 12
102074: PUSH
102075: LD_INT 12
102077: PUSH
102078: EMPTY
102079: LIST
102080: LIST
102081: ST_TO_ADDR
// hc_agressivity := 20 ;
102082: LD_ADDR_OWVAR 35
102086: PUSH
102087: LD_INT 20
102089: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102090: LD_ADDR_OWVAR 28
102094: PUSH
102095: LD_INT 17
102097: ST_TO_ADDR
// hc_gallery :=  ;
102098: LD_ADDR_OWVAR 33
102102: PUSH
102103: LD_STRING 
102105: ST_TO_ADDR
// hc_name :=  ;
102106: LD_ADDR_OWVAR 26
102110: PUSH
102111: LD_STRING 
102113: ST_TO_ADDR
// un := CreateHuman ;
102114: LD_ADDR_VAR 0 2
102118: PUSH
102119: CALL_OW 44
102123: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102124: LD_VAR 0 2
102128: PPUSH
102129: LD_INT 1
102131: PPUSH
102132: CALL_OW 51
// tmp := tmp ^ un ;
102136: LD_ADDR_VAR 0 3
102140: PUSH
102141: LD_VAR 0 3
102145: PUSH
102146: LD_VAR 0 2
102150: ADD
102151: ST_TO_ADDR
// end ;
102152: GO 102048
102154: POP
102155: POP
// repeat wait ( 0 0$1 ) ;
102156: LD_INT 35
102158: PPUSH
102159: CALL_OW 67
// for un in tmp do
102163: LD_ADDR_VAR 0 2
102167: PUSH
102168: LD_VAR 0 3
102172: PUSH
102173: FOR_IN
102174: IFFALSE 102248
// begin if IsDead ( un ) then
102176: LD_VAR 0 2
102180: PPUSH
102181: CALL_OW 301
102185: IFFALSE 102205
// begin tmp := tmp diff un ;
102187: LD_ADDR_VAR 0 3
102191: PUSH
102192: LD_VAR 0 3
102196: PUSH
102197: LD_VAR 0 2
102201: DIFF
102202: ST_TO_ADDR
// continue ;
102203: GO 102173
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102205: LD_VAR 0 2
102209: PPUSH
102210: LD_INT 3
102212: PUSH
102213: LD_INT 22
102215: PUSH
102216: LD_INT 0
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: PPUSH
102227: CALL_OW 69
102231: PPUSH
102232: LD_VAR 0 2
102236: PPUSH
102237: CALL_OW 74
102241: PPUSH
102242: CALL_OW 115
// end ;
102246: GO 102173
102248: POP
102249: POP
// until not tmp ;
102250: LD_VAR 0 3
102254: NOT
102255: IFFALSE 102156
// end ;
102257: PPOPN 3
102259: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102260: LD_EXP 97
102264: PUSH
102265: LD_EXP 122
102269: AND
102270: IFFALSE 102324
102272: GO 102274
102274: DISABLE
// begin ToLua ( displayTroll(); ) ;
102275: LD_STRING displayTroll();
102277: PPUSH
102278: CALL_OW 559
// wait ( 3 3$00 ) ;
102282: LD_INT 6300
102284: PPUSH
102285: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102289: LD_STRING hideTroll();
102291: PPUSH
102292: CALL_OW 559
// wait ( 1 1$00 ) ;
102296: LD_INT 2100
102298: PPUSH
102299: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102303: LD_STRING displayTroll();
102305: PPUSH
102306: CALL_OW 559
// wait ( 1 1$00 ) ;
102310: LD_INT 2100
102312: PPUSH
102313: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102317: LD_STRING hideTroll();
102319: PPUSH
102320: CALL_OW 559
// end ;
102324: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102325: LD_EXP 97
102329: PUSH
102330: LD_EXP 123
102334: AND
102335: IFFALSE 102398
102337: GO 102339
102339: DISABLE
102340: LD_INT 0
102342: PPUSH
// begin p := 0 ;
102343: LD_ADDR_VAR 0 1
102347: PUSH
102348: LD_INT 0
102350: ST_TO_ADDR
// repeat game_speed := 1 ;
102351: LD_ADDR_OWVAR 65
102355: PUSH
102356: LD_INT 1
102358: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102359: LD_INT 35
102361: PPUSH
102362: CALL_OW 67
// p := p + 1 ;
102366: LD_ADDR_VAR 0 1
102370: PUSH
102371: LD_VAR 0 1
102375: PUSH
102376: LD_INT 1
102378: PLUS
102379: ST_TO_ADDR
// until p >= 60 ;
102380: LD_VAR 0 1
102384: PUSH
102385: LD_INT 60
102387: GREATEREQUAL
102388: IFFALSE 102351
// game_speed := 4 ;
102390: LD_ADDR_OWVAR 65
102394: PUSH
102395: LD_INT 4
102397: ST_TO_ADDR
// end ;
102398: PPOPN 1
102400: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102401: LD_EXP 97
102405: PUSH
102406: LD_EXP 124
102410: AND
102411: IFFALSE 102557
102413: GO 102415
102415: DISABLE
102416: LD_INT 0
102418: PPUSH
102419: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102420: LD_ADDR_VAR 0 1
102424: PUSH
102425: LD_INT 22
102427: PUSH
102428: LD_OWVAR 2
102432: PUSH
102433: EMPTY
102434: LIST
102435: LIST
102436: PUSH
102437: LD_INT 2
102439: PUSH
102440: LD_INT 30
102442: PUSH
102443: LD_INT 0
102445: PUSH
102446: EMPTY
102447: LIST
102448: LIST
102449: PUSH
102450: LD_INT 30
102452: PUSH
102453: LD_INT 1
102455: PUSH
102456: EMPTY
102457: LIST
102458: LIST
102459: PUSH
102460: EMPTY
102461: LIST
102462: LIST
102463: LIST
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: PPUSH
102469: CALL_OW 69
102473: ST_TO_ADDR
// if not depot then
102474: LD_VAR 0 1
102478: NOT
102479: IFFALSE 102483
// exit ;
102481: GO 102557
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102483: LD_ADDR_VAR 0 2
102487: PUSH
102488: LD_VAR 0 1
102492: PUSH
102493: LD_INT 1
102495: PPUSH
102496: LD_VAR 0 1
102500: PPUSH
102501: CALL_OW 12
102505: ARRAY
102506: PPUSH
102507: CALL_OW 274
102511: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102512: LD_VAR 0 2
102516: PPUSH
102517: LD_INT 1
102519: PPUSH
102520: LD_INT 0
102522: PPUSH
102523: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102527: LD_VAR 0 2
102531: PPUSH
102532: LD_INT 2
102534: PPUSH
102535: LD_INT 0
102537: PPUSH
102538: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102542: LD_VAR 0 2
102546: PPUSH
102547: LD_INT 3
102549: PPUSH
102550: LD_INT 0
102552: PPUSH
102553: CALL_OW 277
// end ;
102557: PPOPN 2
102559: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102560: LD_EXP 97
102564: PUSH
102565: LD_EXP 125
102569: AND
102570: IFFALSE 102667
102572: GO 102574
102574: DISABLE
102575: LD_INT 0
102577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102578: LD_ADDR_VAR 0 1
102582: PUSH
102583: LD_INT 22
102585: PUSH
102586: LD_OWVAR 2
102590: PUSH
102591: EMPTY
102592: LIST
102593: LIST
102594: PUSH
102595: LD_INT 21
102597: PUSH
102598: LD_INT 1
102600: PUSH
102601: EMPTY
102602: LIST
102603: LIST
102604: PUSH
102605: LD_INT 3
102607: PUSH
102608: LD_INT 23
102610: PUSH
102611: LD_INT 0
102613: PUSH
102614: EMPTY
102615: LIST
102616: LIST
102617: PUSH
102618: EMPTY
102619: LIST
102620: LIST
102621: PUSH
102622: EMPTY
102623: LIST
102624: LIST
102625: LIST
102626: PPUSH
102627: CALL_OW 69
102631: ST_TO_ADDR
// if not tmp then
102632: LD_VAR 0 1
102636: NOT
102637: IFFALSE 102641
// exit ;
102639: GO 102667
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102641: LD_VAR 0 1
102645: PUSH
102646: LD_INT 1
102648: PPUSH
102649: LD_VAR 0 1
102653: PPUSH
102654: CALL_OW 12
102658: ARRAY
102659: PPUSH
102660: LD_INT 200
102662: PPUSH
102663: CALL_OW 234
// end ;
102667: PPOPN 1
102669: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102670: LD_EXP 97
102674: PUSH
102675: LD_EXP 126
102679: AND
102680: IFFALSE 102759
102682: GO 102684
102684: DISABLE
102685: LD_INT 0
102687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102688: LD_ADDR_VAR 0 1
102692: PUSH
102693: LD_INT 22
102695: PUSH
102696: LD_OWVAR 2
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: PUSH
102705: LD_INT 21
102707: PUSH
102708: LD_INT 2
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: PUSH
102715: EMPTY
102716: LIST
102717: LIST
102718: PPUSH
102719: CALL_OW 69
102723: ST_TO_ADDR
// if not tmp then
102724: LD_VAR 0 1
102728: NOT
102729: IFFALSE 102733
// exit ;
102731: GO 102759
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102733: LD_VAR 0 1
102737: PUSH
102738: LD_INT 1
102740: PPUSH
102741: LD_VAR 0 1
102745: PPUSH
102746: CALL_OW 12
102750: ARRAY
102751: PPUSH
102752: LD_INT 60
102754: PPUSH
102755: CALL_OW 234
// end ;
102759: PPOPN 1
102761: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102762: LD_EXP 97
102766: PUSH
102767: LD_EXP 127
102771: AND
102772: IFFALSE 102871
102774: GO 102776
102776: DISABLE
102777: LD_INT 0
102779: PPUSH
102780: PPUSH
// begin enable ;
102781: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102782: LD_ADDR_VAR 0 1
102786: PUSH
102787: LD_INT 22
102789: PUSH
102790: LD_OWVAR 2
102794: PUSH
102795: EMPTY
102796: LIST
102797: LIST
102798: PUSH
102799: LD_INT 61
102801: PUSH
102802: EMPTY
102803: LIST
102804: PUSH
102805: LD_INT 33
102807: PUSH
102808: LD_INT 2
102810: PUSH
102811: EMPTY
102812: LIST
102813: LIST
102814: PUSH
102815: EMPTY
102816: LIST
102817: LIST
102818: LIST
102819: PPUSH
102820: CALL_OW 69
102824: ST_TO_ADDR
// if not tmp then
102825: LD_VAR 0 1
102829: NOT
102830: IFFALSE 102834
// exit ;
102832: GO 102871
// for i in tmp do
102834: LD_ADDR_VAR 0 2
102838: PUSH
102839: LD_VAR 0 1
102843: PUSH
102844: FOR_IN
102845: IFFALSE 102869
// if IsControledBy ( i ) then
102847: LD_VAR 0 2
102851: PPUSH
102852: CALL_OW 312
102856: IFFALSE 102867
// ComUnlink ( i ) ;
102858: LD_VAR 0 2
102862: PPUSH
102863: CALL_OW 136
102867: GO 102844
102869: POP
102870: POP
// end ;
102871: PPOPN 2
102873: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102874: LD_EXP 97
102878: PUSH
102879: LD_EXP 128
102883: AND
102884: IFFALSE 103024
102886: GO 102888
102888: DISABLE
102889: LD_INT 0
102891: PPUSH
102892: PPUSH
// begin ToLua ( displayPowell(); ) ;
102893: LD_STRING displayPowell();
102895: PPUSH
102896: CALL_OW 559
// uc_side := 0 ;
102900: LD_ADDR_OWVAR 20
102904: PUSH
102905: LD_INT 0
102907: ST_TO_ADDR
// uc_nation := 2 ;
102908: LD_ADDR_OWVAR 21
102912: PUSH
102913: LD_INT 2
102915: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102916: LD_ADDR_OWVAR 37
102920: PUSH
102921: LD_INT 14
102923: ST_TO_ADDR
// vc_engine := engine_siberite ;
102924: LD_ADDR_OWVAR 39
102928: PUSH
102929: LD_INT 3
102931: ST_TO_ADDR
// vc_control := control_apeman ;
102932: LD_ADDR_OWVAR 38
102936: PUSH
102937: LD_INT 5
102939: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102940: LD_ADDR_OWVAR 40
102944: PUSH
102945: LD_INT 29
102947: ST_TO_ADDR
// un := CreateVehicle ;
102948: LD_ADDR_VAR 0 2
102952: PUSH
102953: CALL_OW 45
102957: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102958: LD_VAR 0 2
102962: PPUSH
102963: LD_INT 1
102965: PPUSH
102966: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102970: LD_INT 35
102972: PPUSH
102973: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102977: LD_VAR 0 2
102981: PPUSH
102982: LD_INT 22
102984: PUSH
102985: LD_OWVAR 2
102989: PUSH
102990: EMPTY
102991: LIST
102992: LIST
102993: PPUSH
102994: CALL_OW 69
102998: PPUSH
102999: LD_VAR 0 2
103003: PPUSH
103004: CALL_OW 74
103008: PPUSH
103009: CALL_OW 115
// until IsDead ( un ) ;
103013: LD_VAR 0 2
103017: PPUSH
103018: CALL_OW 301
103022: IFFALSE 102970
// end ;
103024: PPOPN 2
103026: END
// every 0 0$1 trigger StreamModeActive and sStu do
103027: LD_EXP 97
103031: PUSH
103032: LD_EXP 136
103036: AND
103037: IFFALSE 103053
103039: GO 103041
103041: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103042: LD_STRING displayStucuk();
103044: PPUSH
103045: CALL_OW 559
// ResetFog ;
103049: CALL_OW 335
// end ;
103053: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103054: LD_EXP 97
103058: PUSH
103059: LD_EXP 129
103063: AND
103064: IFFALSE 103205
103066: GO 103068
103068: DISABLE
103069: LD_INT 0
103071: PPUSH
103072: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103073: LD_ADDR_VAR 0 2
103077: PUSH
103078: LD_INT 22
103080: PUSH
103081: LD_OWVAR 2
103085: PUSH
103086: EMPTY
103087: LIST
103088: LIST
103089: PUSH
103090: LD_INT 21
103092: PUSH
103093: LD_INT 1
103095: PUSH
103096: EMPTY
103097: LIST
103098: LIST
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: PPUSH
103104: CALL_OW 69
103108: ST_TO_ADDR
// if not tmp then
103109: LD_VAR 0 2
103113: NOT
103114: IFFALSE 103118
// exit ;
103116: GO 103205
// un := tmp [ rand ( 1 , tmp ) ] ;
103118: LD_ADDR_VAR 0 1
103122: PUSH
103123: LD_VAR 0 2
103127: PUSH
103128: LD_INT 1
103130: PPUSH
103131: LD_VAR 0 2
103135: PPUSH
103136: CALL_OW 12
103140: ARRAY
103141: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103142: LD_VAR 0 1
103146: PPUSH
103147: LD_INT 0
103149: PPUSH
103150: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103154: LD_VAR 0 1
103158: PPUSH
103159: LD_OWVAR 3
103163: PUSH
103164: LD_VAR 0 1
103168: DIFF
103169: PPUSH
103170: LD_VAR 0 1
103174: PPUSH
103175: CALL_OW 74
103179: PPUSH
103180: CALL_OW 115
// wait ( 0 0$20 ) ;
103184: LD_INT 700
103186: PPUSH
103187: CALL_OW 67
// SetSide ( un , your_side ) ;
103191: LD_VAR 0 1
103195: PPUSH
103196: LD_OWVAR 2
103200: PPUSH
103201: CALL_OW 235
// end ;
103205: PPOPN 2
103207: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103208: LD_EXP 97
103212: PUSH
103213: LD_EXP 130
103217: AND
103218: IFFALSE 103324
103220: GO 103222
103222: DISABLE
103223: LD_INT 0
103225: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103226: LD_ADDR_VAR 0 1
103230: PUSH
103231: LD_INT 22
103233: PUSH
103234: LD_OWVAR 2
103238: PUSH
103239: EMPTY
103240: LIST
103241: LIST
103242: PUSH
103243: LD_INT 2
103245: PUSH
103246: LD_INT 30
103248: PUSH
103249: LD_INT 0
103251: PUSH
103252: EMPTY
103253: LIST
103254: LIST
103255: PUSH
103256: LD_INT 30
103258: PUSH
103259: LD_INT 1
103261: PUSH
103262: EMPTY
103263: LIST
103264: LIST
103265: PUSH
103266: EMPTY
103267: LIST
103268: LIST
103269: LIST
103270: PUSH
103271: EMPTY
103272: LIST
103273: LIST
103274: PPUSH
103275: CALL_OW 69
103279: ST_TO_ADDR
// if not depot then
103280: LD_VAR 0 1
103284: NOT
103285: IFFALSE 103289
// exit ;
103287: GO 103324
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103289: LD_VAR 0 1
103293: PUSH
103294: LD_INT 1
103296: ARRAY
103297: PPUSH
103298: CALL_OW 250
103302: PPUSH
103303: LD_VAR 0 1
103307: PUSH
103308: LD_INT 1
103310: ARRAY
103311: PPUSH
103312: CALL_OW 251
103316: PPUSH
103317: LD_INT 70
103319: PPUSH
103320: CALL_OW 495
// end ;
103324: PPOPN 1
103326: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103327: LD_EXP 97
103331: PUSH
103332: LD_EXP 131
103336: AND
103337: IFFALSE 103548
103339: GO 103341
103341: DISABLE
103342: LD_INT 0
103344: PPUSH
103345: PPUSH
103346: PPUSH
103347: PPUSH
103348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103349: LD_ADDR_VAR 0 5
103353: PUSH
103354: LD_INT 22
103356: PUSH
103357: LD_OWVAR 2
103361: PUSH
103362: EMPTY
103363: LIST
103364: LIST
103365: PUSH
103366: LD_INT 21
103368: PUSH
103369: LD_INT 1
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: PUSH
103376: EMPTY
103377: LIST
103378: LIST
103379: PPUSH
103380: CALL_OW 69
103384: ST_TO_ADDR
// if not tmp then
103385: LD_VAR 0 5
103389: NOT
103390: IFFALSE 103394
// exit ;
103392: GO 103548
// for i in tmp do
103394: LD_ADDR_VAR 0 1
103398: PUSH
103399: LD_VAR 0 5
103403: PUSH
103404: FOR_IN
103405: IFFALSE 103546
// begin d := rand ( 0 , 5 ) ;
103407: LD_ADDR_VAR 0 4
103411: PUSH
103412: LD_INT 0
103414: PPUSH
103415: LD_INT 5
103417: PPUSH
103418: CALL_OW 12
103422: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103423: LD_ADDR_VAR 0 2
103427: PUSH
103428: LD_VAR 0 1
103432: PPUSH
103433: CALL_OW 250
103437: PPUSH
103438: LD_VAR 0 4
103442: PPUSH
103443: LD_INT 3
103445: PPUSH
103446: LD_INT 12
103448: PPUSH
103449: CALL_OW 12
103453: PPUSH
103454: CALL_OW 272
103458: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103459: LD_ADDR_VAR 0 3
103463: PUSH
103464: LD_VAR 0 1
103468: PPUSH
103469: CALL_OW 251
103473: PPUSH
103474: LD_VAR 0 4
103478: PPUSH
103479: LD_INT 3
103481: PPUSH
103482: LD_INT 12
103484: PPUSH
103485: CALL_OW 12
103489: PPUSH
103490: CALL_OW 273
103494: ST_TO_ADDR
// if ValidHex ( x , y ) then
103495: LD_VAR 0 2
103499: PPUSH
103500: LD_VAR 0 3
103504: PPUSH
103505: CALL_OW 488
103509: IFFALSE 103544
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103511: LD_VAR 0 1
103515: PPUSH
103516: LD_VAR 0 2
103520: PPUSH
103521: LD_VAR 0 3
103525: PPUSH
103526: LD_INT 3
103528: PPUSH
103529: LD_INT 6
103531: PPUSH
103532: CALL_OW 12
103536: PPUSH
103537: LD_INT 1
103539: PPUSH
103540: CALL_OW 483
// end ;
103544: GO 103404
103546: POP
103547: POP
// end ;
103548: PPOPN 5
103550: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103551: LD_EXP 97
103555: PUSH
103556: LD_EXP 132
103560: AND
103561: IFFALSE 103655
103563: GO 103565
103565: DISABLE
103566: LD_INT 0
103568: PPUSH
103569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103570: LD_ADDR_VAR 0 2
103574: PUSH
103575: LD_INT 22
103577: PUSH
103578: LD_OWVAR 2
103582: PUSH
103583: EMPTY
103584: LIST
103585: LIST
103586: PUSH
103587: LD_INT 32
103589: PUSH
103590: LD_INT 1
103592: PUSH
103593: EMPTY
103594: LIST
103595: LIST
103596: PUSH
103597: LD_INT 21
103599: PUSH
103600: LD_INT 2
103602: PUSH
103603: EMPTY
103604: LIST
103605: LIST
103606: PUSH
103607: EMPTY
103608: LIST
103609: LIST
103610: LIST
103611: PPUSH
103612: CALL_OW 69
103616: ST_TO_ADDR
// if not tmp then
103617: LD_VAR 0 2
103621: NOT
103622: IFFALSE 103626
// exit ;
103624: GO 103655
// for i in tmp do
103626: LD_ADDR_VAR 0 1
103630: PUSH
103631: LD_VAR 0 2
103635: PUSH
103636: FOR_IN
103637: IFFALSE 103653
// SetFuel ( i , 0 ) ;
103639: LD_VAR 0 1
103643: PPUSH
103644: LD_INT 0
103646: PPUSH
103647: CALL_OW 240
103651: GO 103636
103653: POP
103654: POP
// end ;
103655: PPOPN 2
103657: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103658: LD_EXP 97
103662: PUSH
103663: LD_EXP 133
103667: AND
103668: IFFALSE 103734
103670: GO 103672
103672: DISABLE
103673: LD_INT 0
103675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103676: LD_ADDR_VAR 0 1
103680: PUSH
103681: LD_INT 22
103683: PUSH
103684: LD_OWVAR 2
103688: PUSH
103689: EMPTY
103690: LIST
103691: LIST
103692: PUSH
103693: LD_INT 30
103695: PUSH
103696: LD_INT 29
103698: PUSH
103699: EMPTY
103700: LIST
103701: LIST
103702: PUSH
103703: EMPTY
103704: LIST
103705: LIST
103706: PPUSH
103707: CALL_OW 69
103711: ST_TO_ADDR
// if not tmp then
103712: LD_VAR 0 1
103716: NOT
103717: IFFALSE 103721
// exit ;
103719: GO 103734
// DestroyUnit ( tmp [ 1 ] ) ;
103721: LD_VAR 0 1
103725: PUSH
103726: LD_INT 1
103728: ARRAY
103729: PPUSH
103730: CALL_OW 65
// end ;
103734: PPOPN 1
103736: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103737: LD_EXP 97
103741: PUSH
103742: LD_EXP 135
103746: AND
103747: IFFALSE 103876
103749: GO 103751
103751: DISABLE
103752: LD_INT 0
103754: PPUSH
// begin uc_side := 0 ;
103755: LD_ADDR_OWVAR 20
103759: PUSH
103760: LD_INT 0
103762: ST_TO_ADDR
// uc_nation := nation_arabian ;
103763: LD_ADDR_OWVAR 21
103767: PUSH
103768: LD_INT 2
103770: ST_TO_ADDR
// hc_gallery :=  ;
103771: LD_ADDR_OWVAR 33
103775: PUSH
103776: LD_STRING 
103778: ST_TO_ADDR
// hc_name :=  ;
103779: LD_ADDR_OWVAR 26
103783: PUSH
103784: LD_STRING 
103786: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103787: LD_INT 1
103789: PPUSH
103790: LD_INT 11
103792: PPUSH
103793: LD_INT 10
103795: PPUSH
103796: CALL_OW 380
// un := CreateHuman ;
103800: LD_ADDR_VAR 0 1
103804: PUSH
103805: CALL_OW 44
103809: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103810: LD_VAR 0 1
103814: PPUSH
103815: LD_INT 1
103817: PPUSH
103818: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103822: LD_INT 35
103824: PPUSH
103825: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103829: LD_VAR 0 1
103833: PPUSH
103834: LD_INT 22
103836: PUSH
103837: LD_OWVAR 2
103841: PUSH
103842: EMPTY
103843: LIST
103844: LIST
103845: PPUSH
103846: CALL_OW 69
103850: PPUSH
103851: LD_VAR 0 1
103855: PPUSH
103856: CALL_OW 74
103860: PPUSH
103861: CALL_OW 115
// until IsDead ( un ) ;
103865: LD_VAR 0 1
103869: PPUSH
103870: CALL_OW 301
103874: IFFALSE 103822
// end ;
103876: PPOPN 1
103878: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103879: LD_EXP 97
103883: PUSH
103884: LD_EXP 137
103888: AND
103889: IFFALSE 103901
103891: GO 103893
103893: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103894: LD_STRING earthquake(getX(game), 0, 32)
103896: PPUSH
103897: CALL_OW 559
103901: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103902: LD_EXP 97
103906: PUSH
103907: LD_EXP 138
103911: AND
103912: IFFALSE 104003
103914: GO 103916
103916: DISABLE
103917: LD_INT 0
103919: PPUSH
// begin enable ;
103920: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103921: LD_ADDR_VAR 0 1
103925: PUSH
103926: LD_INT 22
103928: PUSH
103929: LD_OWVAR 2
103933: PUSH
103934: EMPTY
103935: LIST
103936: LIST
103937: PUSH
103938: LD_INT 21
103940: PUSH
103941: LD_INT 2
103943: PUSH
103944: EMPTY
103945: LIST
103946: LIST
103947: PUSH
103948: LD_INT 33
103950: PUSH
103951: LD_INT 3
103953: PUSH
103954: EMPTY
103955: LIST
103956: LIST
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: LIST
103962: PPUSH
103963: CALL_OW 69
103967: ST_TO_ADDR
// if not tmp then
103968: LD_VAR 0 1
103972: NOT
103973: IFFALSE 103977
// exit ;
103975: GO 104003
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103977: LD_VAR 0 1
103981: PUSH
103982: LD_INT 1
103984: PPUSH
103985: LD_VAR 0 1
103989: PPUSH
103990: CALL_OW 12
103994: ARRAY
103995: PPUSH
103996: LD_INT 1
103998: PPUSH
103999: CALL_OW 234
// end ;
104003: PPOPN 1
104005: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104006: LD_EXP 97
104010: PUSH
104011: LD_EXP 139
104015: AND
104016: IFFALSE 104157
104018: GO 104020
104020: DISABLE
104021: LD_INT 0
104023: PPUSH
104024: PPUSH
104025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104026: LD_ADDR_VAR 0 3
104030: PUSH
104031: LD_INT 22
104033: PUSH
104034: LD_OWVAR 2
104038: PUSH
104039: EMPTY
104040: LIST
104041: LIST
104042: PUSH
104043: LD_INT 25
104045: PUSH
104046: LD_INT 1
104048: PUSH
104049: EMPTY
104050: LIST
104051: LIST
104052: PUSH
104053: EMPTY
104054: LIST
104055: LIST
104056: PPUSH
104057: CALL_OW 69
104061: ST_TO_ADDR
// if not tmp then
104062: LD_VAR 0 3
104066: NOT
104067: IFFALSE 104071
// exit ;
104069: GO 104157
// un := tmp [ rand ( 1 , tmp ) ] ;
104071: LD_ADDR_VAR 0 2
104075: PUSH
104076: LD_VAR 0 3
104080: PUSH
104081: LD_INT 1
104083: PPUSH
104084: LD_VAR 0 3
104088: PPUSH
104089: CALL_OW 12
104093: ARRAY
104094: ST_TO_ADDR
// if Crawls ( un ) then
104095: LD_VAR 0 2
104099: PPUSH
104100: CALL_OW 318
104104: IFFALSE 104115
// ComWalk ( un ) ;
104106: LD_VAR 0 2
104110: PPUSH
104111: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104115: LD_VAR 0 2
104119: PPUSH
104120: LD_INT 9
104122: PPUSH
104123: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104127: LD_INT 28
104129: PPUSH
104130: LD_OWVAR 2
104134: PPUSH
104135: LD_INT 2
104137: PPUSH
104138: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104142: LD_INT 29
104144: PPUSH
104145: LD_OWVAR 2
104149: PPUSH
104150: LD_INT 2
104152: PPUSH
104153: CALL_OW 322
// end ;
104157: PPOPN 3
104159: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104160: LD_EXP 97
104164: PUSH
104165: LD_EXP 140
104169: AND
104170: IFFALSE 104281
104172: GO 104174
104174: DISABLE
104175: LD_INT 0
104177: PPUSH
104178: PPUSH
104179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104180: LD_ADDR_VAR 0 3
104184: PUSH
104185: LD_INT 22
104187: PUSH
104188: LD_OWVAR 2
104192: PUSH
104193: EMPTY
104194: LIST
104195: LIST
104196: PUSH
104197: LD_INT 25
104199: PUSH
104200: LD_INT 1
104202: PUSH
104203: EMPTY
104204: LIST
104205: LIST
104206: PUSH
104207: EMPTY
104208: LIST
104209: LIST
104210: PPUSH
104211: CALL_OW 69
104215: ST_TO_ADDR
// if not tmp then
104216: LD_VAR 0 3
104220: NOT
104221: IFFALSE 104225
// exit ;
104223: GO 104281
// un := tmp [ rand ( 1 , tmp ) ] ;
104225: LD_ADDR_VAR 0 2
104229: PUSH
104230: LD_VAR 0 3
104234: PUSH
104235: LD_INT 1
104237: PPUSH
104238: LD_VAR 0 3
104242: PPUSH
104243: CALL_OW 12
104247: ARRAY
104248: ST_TO_ADDR
// if Crawls ( un ) then
104249: LD_VAR 0 2
104253: PPUSH
104254: CALL_OW 318
104258: IFFALSE 104269
// ComWalk ( un ) ;
104260: LD_VAR 0 2
104264: PPUSH
104265: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104269: LD_VAR 0 2
104273: PPUSH
104274: LD_INT 8
104276: PPUSH
104277: CALL_OW 336
// end ;
104281: PPOPN 3
104283: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104284: LD_EXP 97
104288: PUSH
104289: LD_EXP 141
104293: AND
104294: IFFALSE 104438
104296: GO 104298
104298: DISABLE
104299: LD_INT 0
104301: PPUSH
104302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104303: LD_ADDR_VAR 0 2
104307: PUSH
104308: LD_INT 22
104310: PUSH
104311: LD_OWVAR 2
104315: PUSH
104316: EMPTY
104317: LIST
104318: LIST
104319: PUSH
104320: LD_INT 21
104322: PUSH
104323: LD_INT 2
104325: PUSH
104326: EMPTY
104327: LIST
104328: LIST
104329: PUSH
104330: LD_INT 2
104332: PUSH
104333: LD_INT 34
104335: PUSH
104336: LD_INT 12
104338: PUSH
104339: EMPTY
104340: LIST
104341: LIST
104342: PUSH
104343: LD_INT 34
104345: PUSH
104346: LD_INT 51
104348: PUSH
104349: EMPTY
104350: LIST
104351: LIST
104352: PUSH
104353: LD_INT 34
104355: PUSH
104356: LD_INT 32
104358: PUSH
104359: EMPTY
104360: LIST
104361: LIST
104362: PUSH
104363: EMPTY
104364: LIST
104365: LIST
104366: LIST
104367: LIST
104368: PUSH
104369: EMPTY
104370: LIST
104371: LIST
104372: LIST
104373: PPUSH
104374: CALL_OW 69
104378: ST_TO_ADDR
// if not tmp then
104379: LD_VAR 0 2
104383: NOT
104384: IFFALSE 104388
// exit ;
104386: GO 104438
// for i in tmp do
104388: LD_ADDR_VAR 0 1
104392: PUSH
104393: LD_VAR 0 2
104397: PUSH
104398: FOR_IN
104399: IFFALSE 104436
// if GetCargo ( i , mat_artifact ) = 0 then
104401: LD_VAR 0 1
104405: PPUSH
104406: LD_INT 4
104408: PPUSH
104409: CALL_OW 289
104413: PUSH
104414: LD_INT 0
104416: EQUAL
104417: IFFALSE 104434
// SetCargo ( i , mat_siberit , 100 ) ;
104419: LD_VAR 0 1
104423: PPUSH
104424: LD_INT 3
104426: PPUSH
104427: LD_INT 100
104429: PPUSH
104430: CALL_OW 290
104434: GO 104398
104436: POP
104437: POP
// end ;
104438: PPOPN 2
104440: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104441: LD_EXP 97
104445: PUSH
104446: LD_EXP 142
104450: AND
104451: IFFALSE 104634
104453: GO 104455
104455: DISABLE
104456: LD_INT 0
104458: PPUSH
104459: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104460: LD_ADDR_VAR 0 2
104464: PUSH
104465: LD_INT 22
104467: PUSH
104468: LD_OWVAR 2
104472: PUSH
104473: EMPTY
104474: LIST
104475: LIST
104476: PPUSH
104477: CALL_OW 69
104481: ST_TO_ADDR
// if not tmp then
104482: LD_VAR 0 2
104486: NOT
104487: IFFALSE 104491
// exit ;
104489: GO 104634
// for i := 1 to 2 do
104491: LD_ADDR_VAR 0 1
104495: PUSH
104496: DOUBLE
104497: LD_INT 1
104499: DEC
104500: ST_TO_ADDR
104501: LD_INT 2
104503: PUSH
104504: FOR_TO
104505: IFFALSE 104632
// begin uc_side := your_side ;
104507: LD_ADDR_OWVAR 20
104511: PUSH
104512: LD_OWVAR 2
104516: ST_TO_ADDR
// uc_nation := nation_american ;
104517: LD_ADDR_OWVAR 21
104521: PUSH
104522: LD_INT 1
104524: ST_TO_ADDR
// vc_chassis := us_morphling ;
104525: LD_ADDR_OWVAR 37
104529: PUSH
104530: LD_INT 5
104532: ST_TO_ADDR
// vc_engine := engine_siberite ;
104533: LD_ADDR_OWVAR 39
104537: PUSH
104538: LD_INT 3
104540: ST_TO_ADDR
// vc_control := control_computer ;
104541: LD_ADDR_OWVAR 38
104545: PUSH
104546: LD_INT 3
104548: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104549: LD_ADDR_OWVAR 40
104553: PUSH
104554: LD_INT 10
104556: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104557: LD_VAR 0 2
104561: PUSH
104562: LD_INT 1
104564: ARRAY
104565: PPUSH
104566: CALL_OW 310
104570: NOT
104571: IFFALSE 104618
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104573: CALL_OW 45
104577: PPUSH
104578: LD_VAR 0 2
104582: PUSH
104583: LD_INT 1
104585: ARRAY
104586: PPUSH
104587: CALL_OW 250
104591: PPUSH
104592: LD_VAR 0 2
104596: PUSH
104597: LD_INT 1
104599: ARRAY
104600: PPUSH
104601: CALL_OW 251
104605: PPUSH
104606: LD_INT 12
104608: PPUSH
104609: LD_INT 1
104611: PPUSH
104612: CALL_OW 50
104616: GO 104630
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104618: CALL_OW 45
104622: PPUSH
104623: LD_INT 1
104625: PPUSH
104626: CALL_OW 51
// end ;
104630: GO 104504
104632: POP
104633: POP
// end ;
104634: PPOPN 2
104636: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104637: LD_EXP 97
104641: PUSH
104642: LD_EXP 143
104646: AND
104647: IFFALSE 104869
104649: GO 104651
104651: DISABLE
104652: LD_INT 0
104654: PPUSH
104655: PPUSH
104656: PPUSH
104657: PPUSH
104658: PPUSH
104659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104660: LD_ADDR_VAR 0 6
104664: PUSH
104665: LD_INT 22
104667: PUSH
104668: LD_OWVAR 2
104672: PUSH
104673: EMPTY
104674: LIST
104675: LIST
104676: PUSH
104677: LD_INT 21
104679: PUSH
104680: LD_INT 1
104682: PUSH
104683: EMPTY
104684: LIST
104685: LIST
104686: PUSH
104687: LD_INT 3
104689: PUSH
104690: LD_INT 23
104692: PUSH
104693: LD_INT 0
104695: PUSH
104696: EMPTY
104697: LIST
104698: LIST
104699: PUSH
104700: EMPTY
104701: LIST
104702: LIST
104703: PUSH
104704: EMPTY
104705: LIST
104706: LIST
104707: LIST
104708: PPUSH
104709: CALL_OW 69
104713: ST_TO_ADDR
// if not tmp then
104714: LD_VAR 0 6
104718: NOT
104719: IFFALSE 104723
// exit ;
104721: GO 104869
// s1 := rand ( 1 , 4 ) ;
104723: LD_ADDR_VAR 0 2
104727: PUSH
104728: LD_INT 1
104730: PPUSH
104731: LD_INT 4
104733: PPUSH
104734: CALL_OW 12
104738: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104739: LD_ADDR_VAR 0 4
104743: PUSH
104744: LD_VAR 0 6
104748: PUSH
104749: LD_INT 1
104751: ARRAY
104752: PPUSH
104753: LD_VAR 0 2
104757: PPUSH
104758: CALL_OW 259
104762: ST_TO_ADDR
// if s1 = 1 then
104763: LD_VAR 0 2
104767: PUSH
104768: LD_INT 1
104770: EQUAL
104771: IFFALSE 104791
// s2 := rand ( 2 , 4 ) else
104773: LD_ADDR_VAR 0 3
104777: PUSH
104778: LD_INT 2
104780: PPUSH
104781: LD_INT 4
104783: PPUSH
104784: CALL_OW 12
104788: ST_TO_ADDR
104789: GO 104799
// s2 := 1 ;
104791: LD_ADDR_VAR 0 3
104795: PUSH
104796: LD_INT 1
104798: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104799: LD_ADDR_VAR 0 5
104803: PUSH
104804: LD_VAR 0 6
104808: PUSH
104809: LD_INT 1
104811: ARRAY
104812: PPUSH
104813: LD_VAR 0 3
104817: PPUSH
104818: CALL_OW 259
104822: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104823: LD_VAR 0 6
104827: PUSH
104828: LD_INT 1
104830: ARRAY
104831: PPUSH
104832: LD_VAR 0 2
104836: PPUSH
104837: LD_VAR 0 5
104841: PPUSH
104842: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104846: LD_VAR 0 6
104850: PUSH
104851: LD_INT 1
104853: ARRAY
104854: PPUSH
104855: LD_VAR 0 3
104859: PPUSH
104860: LD_VAR 0 4
104864: PPUSH
104865: CALL_OW 237
// end ;
104869: PPOPN 6
104871: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104872: LD_EXP 97
104876: PUSH
104877: LD_EXP 144
104881: AND
104882: IFFALSE 104961
104884: GO 104886
104886: DISABLE
104887: LD_INT 0
104889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104890: LD_ADDR_VAR 0 1
104894: PUSH
104895: LD_INT 22
104897: PUSH
104898: LD_OWVAR 2
104902: PUSH
104903: EMPTY
104904: LIST
104905: LIST
104906: PUSH
104907: LD_INT 30
104909: PUSH
104910: LD_INT 3
104912: PUSH
104913: EMPTY
104914: LIST
104915: LIST
104916: PUSH
104917: EMPTY
104918: LIST
104919: LIST
104920: PPUSH
104921: CALL_OW 69
104925: ST_TO_ADDR
// if not tmp then
104926: LD_VAR 0 1
104930: NOT
104931: IFFALSE 104935
// exit ;
104933: GO 104961
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104935: LD_VAR 0 1
104939: PUSH
104940: LD_INT 1
104942: PPUSH
104943: LD_VAR 0 1
104947: PPUSH
104948: CALL_OW 12
104952: ARRAY
104953: PPUSH
104954: LD_INT 1
104956: PPUSH
104957: CALL_OW 234
// end ;
104961: PPOPN 1
104963: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104964: LD_EXP 97
104968: PUSH
104969: LD_EXP 145
104973: AND
104974: IFFALSE 105086
104976: GO 104978
104978: DISABLE
104979: LD_INT 0
104981: PPUSH
104982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104983: LD_ADDR_VAR 0 2
104987: PUSH
104988: LD_INT 22
104990: PUSH
104991: LD_OWVAR 2
104995: PUSH
104996: EMPTY
104997: LIST
104998: LIST
104999: PUSH
105000: LD_INT 2
105002: PUSH
105003: LD_INT 30
105005: PUSH
105006: LD_INT 27
105008: PUSH
105009: EMPTY
105010: LIST
105011: LIST
105012: PUSH
105013: LD_INT 30
105015: PUSH
105016: LD_INT 26
105018: PUSH
105019: EMPTY
105020: LIST
105021: LIST
105022: PUSH
105023: LD_INT 30
105025: PUSH
105026: LD_INT 28
105028: PUSH
105029: EMPTY
105030: LIST
105031: LIST
105032: PUSH
105033: EMPTY
105034: LIST
105035: LIST
105036: LIST
105037: LIST
105038: PUSH
105039: EMPTY
105040: LIST
105041: LIST
105042: PPUSH
105043: CALL_OW 69
105047: ST_TO_ADDR
// if not tmp then
105048: LD_VAR 0 2
105052: NOT
105053: IFFALSE 105057
// exit ;
105055: GO 105086
// for i in tmp do
105057: LD_ADDR_VAR 0 1
105061: PUSH
105062: LD_VAR 0 2
105066: PUSH
105067: FOR_IN
105068: IFFALSE 105084
// SetLives ( i , 1 ) ;
105070: LD_VAR 0 1
105074: PPUSH
105075: LD_INT 1
105077: PPUSH
105078: CALL_OW 234
105082: GO 105067
105084: POP
105085: POP
// end ;
105086: PPOPN 2
105088: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105089: LD_EXP 97
105093: PUSH
105094: LD_EXP 146
105098: AND
105099: IFFALSE 105386
105101: GO 105103
105103: DISABLE
105104: LD_INT 0
105106: PPUSH
105107: PPUSH
105108: PPUSH
// begin i := rand ( 1 , 7 ) ;
105109: LD_ADDR_VAR 0 1
105113: PUSH
105114: LD_INT 1
105116: PPUSH
105117: LD_INT 7
105119: PPUSH
105120: CALL_OW 12
105124: ST_TO_ADDR
// case i of 1 :
105125: LD_VAR 0 1
105129: PUSH
105130: LD_INT 1
105132: DOUBLE
105133: EQUAL
105134: IFTRUE 105138
105136: GO 105148
105138: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105139: LD_STRING earthquake(getX(game), 0, 32)
105141: PPUSH
105142: CALL_OW 559
105146: GO 105386
105148: LD_INT 2
105150: DOUBLE
105151: EQUAL
105152: IFTRUE 105156
105154: GO 105170
105156: POP
// begin ToLua ( displayStucuk(); ) ;
105157: LD_STRING displayStucuk();
105159: PPUSH
105160: CALL_OW 559
// ResetFog ;
105164: CALL_OW 335
// end ; 3 :
105168: GO 105386
105170: LD_INT 3
105172: DOUBLE
105173: EQUAL
105174: IFTRUE 105178
105176: GO 105282
105178: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105179: LD_ADDR_VAR 0 2
105183: PUSH
105184: LD_INT 22
105186: PUSH
105187: LD_OWVAR 2
105191: PUSH
105192: EMPTY
105193: LIST
105194: LIST
105195: PUSH
105196: LD_INT 25
105198: PUSH
105199: LD_INT 1
105201: PUSH
105202: EMPTY
105203: LIST
105204: LIST
105205: PUSH
105206: EMPTY
105207: LIST
105208: LIST
105209: PPUSH
105210: CALL_OW 69
105214: ST_TO_ADDR
// if not tmp then
105215: LD_VAR 0 2
105219: NOT
105220: IFFALSE 105224
// exit ;
105222: GO 105386
// un := tmp [ rand ( 1 , tmp ) ] ;
105224: LD_ADDR_VAR 0 3
105228: PUSH
105229: LD_VAR 0 2
105233: PUSH
105234: LD_INT 1
105236: PPUSH
105237: LD_VAR 0 2
105241: PPUSH
105242: CALL_OW 12
105246: ARRAY
105247: ST_TO_ADDR
// if Crawls ( un ) then
105248: LD_VAR 0 3
105252: PPUSH
105253: CALL_OW 318
105257: IFFALSE 105268
// ComWalk ( un ) ;
105259: LD_VAR 0 3
105263: PPUSH
105264: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105268: LD_VAR 0 3
105272: PPUSH
105273: LD_INT 8
105275: PPUSH
105276: CALL_OW 336
// end ; 4 :
105280: GO 105386
105282: LD_INT 4
105284: DOUBLE
105285: EQUAL
105286: IFTRUE 105290
105288: GO 105364
105290: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105291: LD_ADDR_VAR 0 2
105295: PUSH
105296: LD_INT 22
105298: PUSH
105299: LD_OWVAR 2
105303: PUSH
105304: EMPTY
105305: LIST
105306: LIST
105307: PUSH
105308: LD_INT 30
105310: PUSH
105311: LD_INT 29
105313: PUSH
105314: EMPTY
105315: LIST
105316: LIST
105317: PUSH
105318: EMPTY
105319: LIST
105320: LIST
105321: PPUSH
105322: CALL_OW 69
105326: ST_TO_ADDR
// if not tmp then
105327: LD_VAR 0 2
105331: NOT
105332: IFFALSE 105336
// exit ;
105334: GO 105386
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105336: LD_VAR 0 2
105340: PUSH
105341: LD_INT 1
105343: ARRAY
105344: PPUSH
105345: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105349: LD_VAR 0 2
105353: PUSH
105354: LD_INT 1
105356: ARRAY
105357: PPUSH
105358: CALL_OW 65
// end ; 5 .. 7 :
105362: GO 105386
105364: LD_INT 5
105366: DOUBLE
105367: GREATEREQUAL
105368: IFFALSE 105376
105370: LD_INT 7
105372: DOUBLE
105373: LESSEQUAL
105374: IFTRUE 105378
105376: GO 105385
105378: POP
// StreamSibBomb ; end ;
105379: CALL 101623 0 0
105383: GO 105386
105385: POP
// end ;
105386: PPOPN 3
105388: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105389: LD_EXP 97
105393: PUSH
105394: LD_EXP 147
105398: AND
105399: IFFALSE 105555
105401: GO 105403
105403: DISABLE
105404: LD_INT 0
105406: PPUSH
105407: PPUSH
105408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105409: LD_ADDR_VAR 0 2
105413: PUSH
105414: LD_INT 81
105416: PUSH
105417: LD_OWVAR 2
105421: PUSH
105422: EMPTY
105423: LIST
105424: LIST
105425: PUSH
105426: LD_INT 2
105428: PUSH
105429: LD_INT 21
105431: PUSH
105432: LD_INT 1
105434: PUSH
105435: EMPTY
105436: LIST
105437: LIST
105438: PUSH
105439: LD_INT 21
105441: PUSH
105442: LD_INT 2
105444: PUSH
105445: EMPTY
105446: LIST
105447: LIST
105448: PUSH
105449: EMPTY
105450: LIST
105451: LIST
105452: LIST
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: PPUSH
105458: CALL_OW 69
105462: ST_TO_ADDR
// if not tmp then
105463: LD_VAR 0 2
105467: NOT
105468: IFFALSE 105472
// exit ;
105470: GO 105555
// p := 0 ;
105472: LD_ADDR_VAR 0 3
105476: PUSH
105477: LD_INT 0
105479: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105480: LD_INT 35
105482: PPUSH
105483: CALL_OW 67
// p := p + 1 ;
105487: LD_ADDR_VAR 0 3
105491: PUSH
105492: LD_VAR 0 3
105496: PUSH
105497: LD_INT 1
105499: PLUS
105500: ST_TO_ADDR
// for i in tmp do
105501: LD_ADDR_VAR 0 1
105505: PUSH
105506: LD_VAR 0 2
105510: PUSH
105511: FOR_IN
105512: IFFALSE 105543
// if GetLives ( i ) < 1000 then
105514: LD_VAR 0 1
105518: PPUSH
105519: CALL_OW 256
105523: PUSH
105524: LD_INT 1000
105526: LESS
105527: IFFALSE 105541
// SetLives ( i , 1000 ) ;
105529: LD_VAR 0 1
105533: PPUSH
105534: LD_INT 1000
105536: PPUSH
105537: CALL_OW 234
105541: GO 105511
105543: POP
105544: POP
// until p > 20 ;
105545: LD_VAR 0 3
105549: PUSH
105550: LD_INT 20
105552: GREATER
105553: IFFALSE 105480
// end ;
105555: PPOPN 3
105557: END
// every 0 0$1 trigger StreamModeActive and sTime do
105558: LD_EXP 97
105562: PUSH
105563: LD_EXP 148
105567: AND
105568: IFFALSE 105603
105570: GO 105572
105572: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105573: LD_INT 28
105575: PPUSH
105576: LD_OWVAR 2
105580: PPUSH
105581: LD_INT 2
105583: PPUSH
105584: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105588: LD_INT 30
105590: PPUSH
105591: LD_OWVAR 2
105595: PPUSH
105596: LD_INT 2
105598: PPUSH
105599: CALL_OW 322
// end ;
105603: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105604: LD_EXP 97
105608: PUSH
105609: LD_EXP 149
105613: AND
105614: IFFALSE 105735
105616: GO 105618
105618: DISABLE
105619: LD_INT 0
105621: PPUSH
105622: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105623: LD_ADDR_VAR 0 2
105627: PUSH
105628: LD_INT 22
105630: PUSH
105631: LD_OWVAR 2
105635: PUSH
105636: EMPTY
105637: LIST
105638: LIST
105639: PUSH
105640: LD_INT 21
105642: PUSH
105643: LD_INT 1
105645: PUSH
105646: EMPTY
105647: LIST
105648: LIST
105649: PUSH
105650: LD_INT 3
105652: PUSH
105653: LD_INT 23
105655: PUSH
105656: LD_INT 0
105658: PUSH
105659: EMPTY
105660: LIST
105661: LIST
105662: PUSH
105663: EMPTY
105664: LIST
105665: LIST
105666: PUSH
105667: EMPTY
105668: LIST
105669: LIST
105670: LIST
105671: PPUSH
105672: CALL_OW 69
105676: ST_TO_ADDR
// if not tmp then
105677: LD_VAR 0 2
105681: NOT
105682: IFFALSE 105686
// exit ;
105684: GO 105735
// for i in tmp do
105686: LD_ADDR_VAR 0 1
105690: PUSH
105691: LD_VAR 0 2
105695: PUSH
105696: FOR_IN
105697: IFFALSE 105733
// begin if Crawls ( i ) then
105699: LD_VAR 0 1
105703: PPUSH
105704: CALL_OW 318
105708: IFFALSE 105719
// ComWalk ( i ) ;
105710: LD_VAR 0 1
105714: PPUSH
105715: CALL_OW 138
// SetClass ( i , 2 ) ;
105719: LD_VAR 0 1
105723: PPUSH
105724: LD_INT 2
105726: PPUSH
105727: CALL_OW 336
// end ;
105731: GO 105696
105733: POP
105734: POP
// end ;
105735: PPOPN 2
105737: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105738: LD_EXP 97
105742: PUSH
105743: LD_EXP 150
105747: AND
105748: IFFALSE 106036
105750: GO 105752
105752: DISABLE
105753: LD_INT 0
105755: PPUSH
105756: PPUSH
105757: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105758: LD_OWVAR 2
105762: PPUSH
105763: LD_INT 9
105765: PPUSH
105766: LD_INT 1
105768: PPUSH
105769: LD_INT 1
105771: PPUSH
105772: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105776: LD_INT 9
105778: PPUSH
105779: LD_OWVAR 2
105783: PPUSH
105784: CALL_OW 343
// uc_side := 9 ;
105788: LD_ADDR_OWVAR 20
105792: PUSH
105793: LD_INT 9
105795: ST_TO_ADDR
// uc_nation := 2 ;
105796: LD_ADDR_OWVAR 21
105800: PUSH
105801: LD_INT 2
105803: ST_TO_ADDR
// hc_name := Dark Warrior ;
105804: LD_ADDR_OWVAR 26
105808: PUSH
105809: LD_STRING Dark Warrior
105811: ST_TO_ADDR
// hc_gallery :=  ;
105812: LD_ADDR_OWVAR 33
105816: PUSH
105817: LD_STRING 
105819: ST_TO_ADDR
// hc_noskilllimit := true ;
105820: LD_ADDR_OWVAR 76
105824: PUSH
105825: LD_INT 1
105827: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105828: LD_ADDR_OWVAR 31
105832: PUSH
105833: LD_INT 30
105835: PUSH
105836: LD_INT 30
105838: PUSH
105839: LD_INT 30
105841: PUSH
105842: LD_INT 30
105844: PUSH
105845: EMPTY
105846: LIST
105847: LIST
105848: LIST
105849: LIST
105850: ST_TO_ADDR
// un := CreateHuman ;
105851: LD_ADDR_VAR 0 3
105855: PUSH
105856: CALL_OW 44
105860: ST_TO_ADDR
// hc_noskilllimit := false ;
105861: LD_ADDR_OWVAR 76
105865: PUSH
105866: LD_INT 0
105868: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105869: LD_VAR 0 3
105873: PPUSH
105874: LD_INT 1
105876: PPUSH
105877: CALL_OW 51
// ToLua ( playRanger() ) ;
105881: LD_STRING playRanger()
105883: PPUSH
105884: CALL_OW 559
// p := 0 ;
105888: LD_ADDR_VAR 0 2
105892: PUSH
105893: LD_INT 0
105895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105896: LD_INT 35
105898: PPUSH
105899: CALL_OW 67
// p := p + 1 ;
105903: LD_ADDR_VAR 0 2
105907: PUSH
105908: LD_VAR 0 2
105912: PUSH
105913: LD_INT 1
105915: PLUS
105916: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105917: LD_VAR 0 3
105921: PPUSH
105922: CALL_OW 256
105926: PUSH
105927: LD_INT 1000
105929: LESS
105930: IFFALSE 105944
// SetLives ( un , 1000 ) ;
105932: LD_VAR 0 3
105936: PPUSH
105937: LD_INT 1000
105939: PPUSH
105940: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105944: LD_VAR 0 3
105948: PPUSH
105949: LD_INT 81
105951: PUSH
105952: LD_OWVAR 2
105956: PUSH
105957: EMPTY
105958: LIST
105959: LIST
105960: PUSH
105961: LD_INT 91
105963: PUSH
105964: LD_VAR 0 3
105968: PUSH
105969: LD_INT 30
105971: PUSH
105972: EMPTY
105973: LIST
105974: LIST
105975: LIST
105976: PUSH
105977: EMPTY
105978: LIST
105979: LIST
105980: PPUSH
105981: CALL_OW 69
105985: PPUSH
105986: LD_VAR 0 3
105990: PPUSH
105991: CALL_OW 74
105995: PPUSH
105996: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106000: LD_VAR 0 2
106004: PUSH
106005: LD_INT 80
106007: GREATER
106008: PUSH
106009: LD_VAR 0 3
106013: PPUSH
106014: CALL_OW 301
106018: OR
106019: IFFALSE 105896
// if un then
106021: LD_VAR 0 3
106025: IFFALSE 106036
// RemoveUnit ( un ) ;
106027: LD_VAR 0 3
106031: PPUSH
106032: CALL_OW 64
// end ;
106036: PPOPN 3
106038: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106039: LD_EXP 151
106043: IFFALSE 106159
106045: GO 106047
106047: DISABLE
106048: LD_INT 0
106050: PPUSH
106051: PPUSH
106052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106053: LD_ADDR_VAR 0 2
106057: PUSH
106058: LD_INT 81
106060: PUSH
106061: LD_OWVAR 2
106065: PUSH
106066: EMPTY
106067: LIST
106068: LIST
106069: PUSH
106070: LD_INT 21
106072: PUSH
106073: LD_INT 1
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: PUSH
106080: EMPTY
106081: LIST
106082: LIST
106083: PPUSH
106084: CALL_OW 69
106088: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106089: LD_STRING playComputer()
106091: PPUSH
106092: CALL_OW 559
// if not tmp then
106096: LD_VAR 0 2
106100: NOT
106101: IFFALSE 106105
// exit ;
106103: GO 106159
// for i in tmp do
106105: LD_ADDR_VAR 0 1
106109: PUSH
106110: LD_VAR 0 2
106114: PUSH
106115: FOR_IN
106116: IFFALSE 106157
// for j := 1 to 4 do
106118: LD_ADDR_VAR 0 3
106122: PUSH
106123: DOUBLE
106124: LD_INT 1
106126: DEC
106127: ST_TO_ADDR
106128: LD_INT 4
106130: PUSH
106131: FOR_TO
106132: IFFALSE 106153
// SetSkill ( i , j , 10 ) ;
106134: LD_VAR 0 1
106138: PPUSH
106139: LD_VAR 0 3
106143: PPUSH
106144: LD_INT 10
106146: PPUSH
106147: CALL_OW 237
106151: GO 106131
106153: POP
106154: POP
106155: GO 106115
106157: POP
106158: POP
// end ;
106159: PPOPN 3
106161: END
// every 0 0$1 trigger s30 do var i , tmp ;
106162: LD_EXP 152
106166: IFFALSE 106235
106168: GO 106170
106170: DISABLE
106171: LD_INT 0
106173: PPUSH
106174: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106175: LD_ADDR_VAR 0 2
106179: PUSH
106180: LD_INT 22
106182: PUSH
106183: LD_OWVAR 2
106187: PUSH
106188: EMPTY
106189: LIST
106190: LIST
106191: PPUSH
106192: CALL_OW 69
106196: ST_TO_ADDR
// if not tmp then
106197: LD_VAR 0 2
106201: NOT
106202: IFFALSE 106206
// exit ;
106204: GO 106235
// for i in tmp do
106206: LD_ADDR_VAR 0 1
106210: PUSH
106211: LD_VAR 0 2
106215: PUSH
106216: FOR_IN
106217: IFFALSE 106233
// SetLives ( i , 300 ) ;
106219: LD_VAR 0 1
106223: PPUSH
106224: LD_INT 300
106226: PPUSH
106227: CALL_OW 234
106231: GO 106216
106233: POP
106234: POP
// end ;
106235: PPOPN 2
106237: END
// every 0 0$1 trigger s60 do var i , tmp ;
106238: LD_EXP 153
106242: IFFALSE 106311
106244: GO 106246
106246: DISABLE
106247: LD_INT 0
106249: PPUSH
106250: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106251: LD_ADDR_VAR 0 2
106255: PUSH
106256: LD_INT 22
106258: PUSH
106259: LD_OWVAR 2
106263: PUSH
106264: EMPTY
106265: LIST
106266: LIST
106267: PPUSH
106268: CALL_OW 69
106272: ST_TO_ADDR
// if not tmp then
106273: LD_VAR 0 2
106277: NOT
106278: IFFALSE 106282
// exit ;
106280: GO 106311
// for i in tmp do
106282: LD_ADDR_VAR 0 1
106286: PUSH
106287: LD_VAR 0 2
106291: PUSH
106292: FOR_IN
106293: IFFALSE 106309
// SetLives ( i , 600 ) ;
106295: LD_VAR 0 1
106299: PPUSH
106300: LD_INT 600
106302: PPUSH
106303: CALL_OW 234
106307: GO 106292
106309: POP
106310: POP
// end ;
106311: PPOPN 2
106313: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106314: LD_INT 0
106316: PPUSH
// case cmd of 301 :
106317: LD_VAR 0 1
106321: PUSH
106322: LD_INT 301
106324: DOUBLE
106325: EQUAL
106326: IFTRUE 106330
106328: GO 106362
106330: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106331: LD_VAR 0 6
106335: PPUSH
106336: LD_VAR 0 7
106340: PPUSH
106341: LD_VAR 0 8
106345: PPUSH
106346: LD_VAR 0 4
106350: PPUSH
106351: LD_VAR 0 5
106355: PPUSH
106356: CALL 107563 0 5
106360: GO 106483
106362: LD_INT 302
106364: DOUBLE
106365: EQUAL
106366: IFTRUE 106370
106368: GO 106407
106370: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106371: LD_VAR 0 6
106375: PPUSH
106376: LD_VAR 0 7
106380: PPUSH
106381: LD_VAR 0 8
106385: PPUSH
106386: LD_VAR 0 9
106390: PPUSH
106391: LD_VAR 0 4
106395: PPUSH
106396: LD_VAR 0 5
106400: PPUSH
106401: CALL 107654 0 6
106405: GO 106483
106407: LD_INT 303
106409: DOUBLE
106410: EQUAL
106411: IFTRUE 106415
106413: GO 106452
106415: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106416: LD_VAR 0 6
106420: PPUSH
106421: LD_VAR 0 7
106425: PPUSH
106426: LD_VAR 0 8
106430: PPUSH
106431: LD_VAR 0 9
106435: PPUSH
106436: LD_VAR 0 4
106440: PPUSH
106441: LD_VAR 0 5
106445: PPUSH
106446: CALL 106488 0 6
106450: GO 106483
106452: LD_INT 304
106454: DOUBLE
106455: EQUAL
106456: IFTRUE 106460
106458: GO 106482
106460: POP
// hHackTeleport ( unit , x , y ) ; end ;
106461: LD_VAR 0 2
106465: PPUSH
106466: LD_VAR 0 4
106470: PPUSH
106471: LD_VAR 0 5
106475: PPUSH
106476: CALL 108247 0 3
106480: GO 106483
106482: POP
// end ;
106483: LD_VAR 0 12
106487: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106488: LD_INT 0
106490: PPUSH
106491: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106492: LD_VAR 0 1
106496: PUSH
106497: LD_INT 1
106499: LESS
106500: PUSH
106501: LD_VAR 0 1
106505: PUSH
106506: LD_INT 3
106508: GREATER
106509: OR
106510: PUSH
106511: LD_VAR 0 5
106515: PPUSH
106516: LD_VAR 0 6
106520: PPUSH
106521: CALL_OW 428
106525: OR
106526: IFFALSE 106530
// exit ;
106528: GO 107250
// uc_side := your_side ;
106530: LD_ADDR_OWVAR 20
106534: PUSH
106535: LD_OWVAR 2
106539: ST_TO_ADDR
// uc_nation := nation ;
106540: LD_ADDR_OWVAR 21
106544: PUSH
106545: LD_VAR 0 1
106549: ST_TO_ADDR
// bc_level = 1 ;
106550: LD_ADDR_OWVAR 43
106554: PUSH
106555: LD_INT 1
106557: ST_TO_ADDR
// case btype of 1 :
106558: LD_VAR 0 2
106562: PUSH
106563: LD_INT 1
106565: DOUBLE
106566: EQUAL
106567: IFTRUE 106571
106569: GO 106582
106571: POP
// bc_type := b_depot ; 2 :
106572: LD_ADDR_OWVAR 42
106576: PUSH
106577: LD_INT 0
106579: ST_TO_ADDR
106580: GO 107194
106582: LD_INT 2
106584: DOUBLE
106585: EQUAL
106586: IFTRUE 106590
106588: GO 106601
106590: POP
// bc_type := b_warehouse ; 3 :
106591: LD_ADDR_OWVAR 42
106595: PUSH
106596: LD_INT 1
106598: ST_TO_ADDR
106599: GO 107194
106601: LD_INT 3
106603: DOUBLE
106604: EQUAL
106605: IFTRUE 106609
106607: GO 106620
106609: POP
// bc_type := b_lab ; 4 .. 9 :
106610: LD_ADDR_OWVAR 42
106614: PUSH
106615: LD_INT 6
106617: ST_TO_ADDR
106618: GO 107194
106620: LD_INT 4
106622: DOUBLE
106623: GREATEREQUAL
106624: IFFALSE 106632
106626: LD_INT 9
106628: DOUBLE
106629: LESSEQUAL
106630: IFTRUE 106634
106632: GO 106686
106634: POP
// begin bc_type := b_lab_half ;
106635: LD_ADDR_OWVAR 42
106639: PUSH
106640: LD_INT 7
106642: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106643: LD_ADDR_OWVAR 44
106647: PUSH
106648: LD_INT 10
106650: PUSH
106651: LD_INT 11
106653: PUSH
106654: LD_INT 12
106656: PUSH
106657: LD_INT 15
106659: PUSH
106660: LD_INT 14
106662: PUSH
106663: LD_INT 13
106665: PUSH
106666: EMPTY
106667: LIST
106668: LIST
106669: LIST
106670: LIST
106671: LIST
106672: LIST
106673: PUSH
106674: LD_VAR 0 2
106678: PUSH
106679: LD_INT 3
106681: MINUS
106682: ARRAY
106683: ST_TO_ADDR
// end ; 10 .. 13 :
106684: GO 107194
106686: LD_INT 10
106688: DOUBLE
106689: GREATEREQUAL
106690: IFFALSE 106698
106692: LD_INT 13
106694: DOUBLE
106695: LESSEQUAL
106696: IFTRUE 106700
106698: GO 106777
106700: POP
// begin bc_type := b_lab_full ;
106701: LD_ADDR_OWVAR 42
106705: PUSH
106706: LD_INT 8
106708: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106709: LD_ADDR_OWVAR 44
106713: PUSH
106714: LD_INT 10
106716: PUSH
106717: LD_INT 12
106719: PUSH
106720: LD_INT 14
106722: PUSH
106723: LD_INT 13
106725: PUSH
106726: EMPTY
106727: LIST
106728: LIST
106729: LIST
106730: LIST
106731: PUSH
106732: LD_VAR 0 2
106736: PUSH
106737: LD_INT 9
106739: MINUS
106740: ARRAY
106741: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106742: LD_ADDR_OWVAR 45
106746: PUSH
106747: LD_INT 11
106749: PUSH
106750: LD_INT 15
106752: PUSH
106753: LD_INT 12
106755: PUSH
106756: LD_INT 15
106758: PUSH
106759: EMPTY
106760: LIST
106761: LIST
106762: LIST
106763: LIST
106764: PUSH
106765: LD_VAR 0 2
106769: PUSH
106770: LD_INT 9
106772: MINUS
106773: ARRAY
106774: ST_TO_ADDR
// end ; 14 :
106775: GO 107194
106777: LD_INT 14
106779: DOUBLE
106780: EQUAL
106781: IFTRUE 106785
106783: GO 106796
106785: POP
// bc_type := b_workshop ; 15 :
106786: LD_ADDR_OWVAR 42
106790: PUSH
106791: LD_INT 2
106793: ST_TO_ADDR
106794: GO 107194
106796: LD_INT 15
106798: DOUBLE
106799: EQUAL
106800: IFTRUE 106804
106802: GO 106815
106804: POP
// bc_type := b_factory ; 16 :
106805: LD_ADDR_OWVAR 42
106809: PUSH
106810: LD_INT 3
106812: ST_TO_ADDR
106813: GO 107194
106815: LD_INT 16
106817: DOUBLE
106818: EQUAL
106819: IFTRUE 106823
106821: GO 106834
106823: POP
// bc_type := b_ext_gun ; 17 :
106824: LD_ADDR_OWVAR 42
106828: PUSH
106829: LD_INT 17
106831: ST_TO_ADDR
106832: GO 107194
106834: LD_INT 17
106836: DOUBLE
106837: EQUAL
106838: IFTRUE 106842
106840: GO 106870
106842: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106843: LD_ADDR_OWVAR 42
106847: PUSH
106848: LD_INT 19
106850: PUSH
106851: LD_INT 23
106853: PUSH
106854: LD_INT 19
106856: PUSH
106857: EMPTY
106858: LIST
106859: LIST
106860: LIST
106861: PUSH
106862: LD_VAR 0 1
106866: ARRAY
106867: ST_TO_ADDR
106868: GO 107194
106870: LD_INT 18
106872: DOUBLE
106873: EQUAL
106874: IFTRUE 106878
106876: GO 106889
106878: POP
// bc_type := b_ext_radar ; 19 :
106879: LD_ADDR_OWVAR 42
106883: PUSH
106884: LD_INT 20
106886: ST_TO_ADDR
106887: GO 107194
106889: LD_INT 19
106891: DOUBLE
106892: EQUAL
106893: IFTRUE 106897
106895: GO 106908
106897: POP
// bc_type := b_ext_radio ; 20 :
106898: LD_ADDR_OWVAR 42
106902: PUSH
106903: LD_INT 22
106905: ST_TO_ADDR
106906: GO 107194
106908: LD_INT 20
106910: DOUBLE
106911: EQUAL
106912: IFTRUE 106916
106914: GO 106927
106916: POP
// bc_type := b_ext_siberium ; 21 :
106917: LD_ADDR_OWVAR 42
106921: PUSH
106922: LD_INT 21
106924: ST_TO_ADDR
106925: GO 107194
106927: LD_INT 21
106929: DOUBLE
106930: EQUAL
106931: IFTRUE 106935
106933: GO 106946
106935: POP
// bc_type := b_ext_computer ; 22 :
106936: LD_ADDR_OWVAR 42
106940: PUSH
106941: LD_INT 24
106943: ST_TO_ADDR
106944: GO 107194
106946: LD_INT 22
106948: DOUBLE
106949: EQUAL
106950: IFTRUE 106954
106952: GO 106965
106954: POP
// bc_type := b_ext_track ; 23 :
106955: LD_ADDR_OWVAR 42
106959: PUSH
106960: LD_INT 16
106962: ST_TO_ADDR
106963: GO 107194
106965: LD_INT 23
106967: DOUBLE
106968: EQUAL
106969: IFTRUE 106973
106971: GO 106984
106973: POP
// bc_type := b_ext_laser ; 24 :
106974: LD_ADDR_OWVAR 42
106978: PUSH
106979: LD_INT 25
106981: ST_TO_ADDR
106982: GO 107194
106984: LD_INT 24
106986: DOUBLE
106987: EQUAL
106988: IFTRUE 106992
106990: GO 107003
106992: POP
// bc_type := b_control_tower ; 25 :
106993: LD_ADDR_OWVAR 42
106997: PUSH
106998: LD_INT 36
107000: ST_TO_ADDR
107001: GO 107194
107003: LD_INT 25
107005: DOUBLE
107006: EQUAL
107007: IFTRUE 107011
107009: GO 107022
107011: POP
// bc_type := b_breastwork ; 26 :
107012: LD_ADDR_OWVAR 42
107016: PUSH
107017: LD_INT 31
107019: ST_TO_ADDR
107020: GO 107194
107022: LD_INT 26
107024: DOUBLE
107025: EQUAL
107026: IFTRUE 107030
107028: GO 107041
107030: POP
// bc_type := b_bunker ; 27 :
107031: LD_ADDR_OWVAR 42
107035: PUSH
107036: LD_INT 32
107038: ST_TO_ADDR
107039: GO 107194
107041: LD_INT 27
107043: DOUBLE
107044: EQUAL
107045: IFTRUE 107049
107047: GO 107060
107049: POP
// bc_type := b_turret ; 28 :
107050: LD_ADDR_OWVAR 42
107054: PUSH
107055: LD_INT 33
107057: ST_TO_ADDR
107058: GO 107194
107060: LD_INT 28
107062: DOUBLE
107063: EQUAL
107064: IFTRUE 107068
107066: GO 107079
107068: POP
// bc_type := b_armoury ; 29 :
107069: LD_ADDR_OWVAR 42
107073: PUSH
107074: LD_INT 4
107076: ST_TO_ADDR
107077: GO 107194
107079: LD_INT 29
107081: DOUBLE
107082: EQUAL
107083: IFTRUE 107087
107085: GO 107098
107087: POP
// bc_type := b_barracks ; 30 :
107088: LD_ADDR_OWVAR 42
107092: PUSH
107093: LD_INT 5
107095: ST_TO_ADDR
107096: GO 107194
107098: LD_INT 30
107100: DOUBLE
107101: EQUAL
107102: IFTRUE 107106
107104: GO 107117
107106: POP
// bc_type := b_solar_power ; 31 :
107107: LD_ADDR_OWVAR 42
107111: PUSH
107112: LD_INT 27
107114: ST_TO_ADDR
107115: GO 107194
107117: LD_INT 31
107119: DOUBLE
107120: EQUAL
107121: IFTRUE 107125
107123: GO 107136
107125: POP
// bc_type := b_oil_power ; 32 :
107126: LD_ADDR_OWVAR 42
107130: PUSH
107131: LD_INT 26
107133: ST_TO_ADDR
107134: GO 107194
107136: LD_INT 32
107138: DOUBLE
107139: EQUAL
107140: IFTRUE 107144
107142: GO 107155
107144: POP
// bc_type := b_siberite_power ; 33 :
107145: LD_ADDR_OWVAR 42
107149: PUSH
107150: LD_INT 28
107152: ST_TO_ADDR
107153: GO 107194
107155: LD_INT 33
107157: DOUBLE
107158: EQUAL
107159: IFTRUE 107163
107161: GO 107174
107163: POP
// bc_type := b_oil_mine ; 34 :
107164: LD_ADDR_OWVAR 42
107168: PUSH
107169: LD_INT 29
107171: ST_TO_ADDR
107172: GO 107194
107174: LD_INT 34
107176: DOUBLE
107177: EQUAL
107178: IFTRUE 107182
107180: GO 107193
107182: POP
// bc_type := b_siberite_mine ; end ;
107183: LD_ADDR_OWVAR 42
107187: PUSH
107188: LD_INT 30
107190: ST_TO_ADDR
107191: GO 107194
107193: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107194: LD_ADDR_VAR 0 8
107198: PUSH
107199: LD_VAR 0 5
107203: PPUSH
107204: LD_VAR 0 6
107208: PPUSH
107209: LD_VAR 0 3
107213: PPUSH
107214: CALL_OW 47
107218: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107219: LD_OWVAR 42
107223: PUSH
107224: LD_INT 32
107226: PUSH
107227: LD_INT 33
107229: PUSH
107230: EMPTY
107231: LIST
107232: LIST
107233: IN
107234: IFFALSE 107250
// PlaceWeaponTurret ( b , weapon ) ;
107236: LD_VAR 0 8
107240: PPUSH
107241: LD_VAR 0 4
107245: PPUSH
107246: CALL_OW 431
// end ;
107250: LD_VAR 0 7
107254: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107255: LD_INT 0
107257: PPUSH
107258: PPUSH
107259: PPUSH
107260: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107261: LD_ADDR_VAR 0 4
107265: PUSH
107266: LD_INT 22
107268: PUSH
107269: LD_OWVAR 2
107273: PUSH
107274: EMPTY
107275: LIST
107276: LIST
107277: PUSH
107278: LD_INT 2
107280: PUSH
107281: LD_INT 30
107283: PUSH
107284: LD_INT 0
107286: PUSH
107287: EMPTY
107288: LIST
107289: LIST
107290: PUSH
107291: LD_INT 30
107293: PUSH
107294: LD_INT 1
107296: PUSH
107297: EMPTY
107298: LIST
107299: LIST
107300: PUSH
107301: EMPTY
107302: LIST
107303: LIST
107304: LIST
107305: PUSH
107306: EMPTY
107307: LIST
107308: LIST
107309: PPUSH
107310: CALL_OW 69
107314: ST_TO_ADDR
// if not tmp then
107315: LD_VAR 0 4
107319: NOT
107320: IFFALSE 107324
// exit ;
107322: GO 107383
// for i in tmp do
107324: LD_ADDR_VAR 0 2
107328: PUSH
107329: LD_VAR 0 4
107333: PUSH
107334: FOR_IN
107335: IFFALSE 107381
// for j = 1 to 3 do
107337: LD_ADDR_VAR 0 3
107341: PUSH
107342: DOUBLE
107343: LD_INT 1
107345: DEC
107346: ST_TO_ADDR
107347: LD_INT 3
107349: PUSH
107350: FOR_TO
107351: IFFALSE 107377
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107353: LD_VAR 0 2
107357: PPUSH
107358: CALL_OW 274
107362: PPUSH
107363: LD_VAR 0 3
107367: PPUSH
107368: LD_INT 99999
107370: PPUSH
107371: CALL_OW 277
107375: GO 107350
107377: POP
107378: POP
107379: GO 107334
107381: POP
107382: POP
// end ;
107383: LD_VAR 0 1
107387: RET
// export function hHackSetLevel10 ; var i , j ; begin
107388: LD_INT 0
107390: PPUSH
107391: PPUSH
107392: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107393: LD_ADDR_VAR 0 2
107397: PUSH
107398: LD_INT 21
107400: PUSH
107401: LD_INT 1
107403: PUSH
107404: EMPTY
107405: LIST
107406: LIST
107407: PPUSH
107408: CALL_OW 69
107412: PUSH
107413: FOR_IN
107414: IFFALSE 107466
// if IsSelected ( i ) then
107416: LD_VAR 0 2
107420: PPUSH
107421: CALL_OW 306
107425: IFFALSE 107464
// begin for j := 1 to 4 do
107427: LD_ADDR_VAR 0 3
107431: PUSH
107432: DOUBLE
107433: LD_INT 1
107435: DEC
107436: ST_TO_ADDR
107437: LD_INT 4
107439: PUSH
107440: FOR_TO
107441: IFFALSE 107462
// SetSkill ( i , j , 10 ) ;
107443: LD_VAR 0 2
107447: PPUSH
107448: LD_VAR 0 3
107452: PPUSH
107453: LD_INT 10
107455: PPUSH
107456: CALL_OW 237
107460: GO 107440
107462: POP
107463: POP
// end ;
107464: GO 107413
107466: POP
107467: POP
// end ;
107468: LD_VAR 0 1
107472: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107473: LD_INT 0
107475: PPUSH
107476: PPUSH
107477: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107478: LD_ADDR_VAR 0 2
107482: PUSH
107483: LD_INT 22
107485: PUSH
107486: LD_OWVAR 2
107490: PUSH
107491: EMPTY
107492: LIST
107493: LIST
107494: PUSH
107495: LD_INT 21
107497: PUSH
107498: LD_INT 1
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: PUSH
107505: EMPTY
107506: LIST
107507: LIST
107508: PPUSH
107509: CALL_OW 69
107513: PUSH
107514: FOR_IN
107515: IFFALSE 107556
// begin for j := 1 to 4 do
107517: LD_ADDR_VAR 0 3
107521: PUSH
107522: DOUBLE
107523: LD_INT 1
107525: DEC
107526: ST_TO_ADDR
107527: LD_INT 4
107529: PUSH
107530: FOR_TO
107531: IFFALSE 107552
// SetSkill ( i , j , 10 ) ;
107533: LD_VAR 0 2
107537: PPUSH
107538: LD_VAR 0 3
107542: PPUSH
107543: LD_INT 10
107545: PPUSH
107546: CALL_OW 237
107550: GO 107530
107552: POP
107553: POP
// end ;
107554: GO 107514
107556: POP
107557: POP
// end ;
107558: LD_VAR 0 1
107562: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107563: LD_INT 0
107565: PPUSH
// uc_side := your_side ;
107566: LD_ADDR_OWVAR 20
107570: PUSH
107571: LD_OWVAR 2
107575: ST_TO_ADDR
// uc_nation := nation ;
107576: LD_ADDR_OWVAR 21
107580: PUSH
107581: LD_VAR 0 1
107585: ST_TO_ADDR
// InitHc ;
107586: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107590: LD_INT 0
107592: PPUSH
107593: LD_VAR 0 2
107597: PPUSH
107598: LD_VAR 0 3
107602: PPUSH
107603: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107607: LD_VAR 0 4
107611: PPUSH
107612: LD_VAR 0 5
107616: PPUSH
107617: CALL_OW 428
107621: PUSH
107622: LD_INT 0
107624: EQUAL
107625: IFFALSE 107649
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107627: CALL_OW 44
107631: PPUSH
107632: LD_VAR 0 4
107636: PPUSH
107637: LD_VAR 0 5
107641: PPUSH
107642: LD_INT 1
107644: PPUSH
107645: CALL_OW 48
// end ;
107649: LD_VAR 0 6
107653: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107654: LD_INT 0
107656: PPUSH
107657: PPUSH
// uc_side := your_side ;
107658: LD_ADDR_OWVAR 20
107662: PUSH
107663: LD_OWVAR 2
107667: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107668: LD_VAR 0 1
107672: PUSH
107673: LD_INT 1
107675: PUSH
107676: LD_INT 2
107678: PUSH
107679: LD_INT 3
107681: PUSH
107682: LD_INT 4
107684: PUSH
107685: LD_INT 5
107687: PUSH
107688: EMPTY
107689: LIST
107690: LIST
107691: LIST
107692: LIST
107693: LIST
107694: IN
107695: IFFALSE 107707
// uc_nation := nation_american else
107697: LD_ADDR_OWVAR 21
107701: PUSH
107702: LD_INT 1
107704: ST_TO_ADDR
107705: GO 107750
// if chassis in [ 11 , 12 , 13 , 14 ] then
107707: LD_VAR 0 1
107711: PUSH
107712: LD_INT 11
107714: PUSH
107715: LD_INT 12
107717: PUSH
107718: LD_INT 13
107720: PUSH
107721: LD_INT 14
107723: PUSH
107724: EMPTY
107725: LIST
107726: LIST
107727: LIST
107728: LIST
107729: IN
107730: IFFALSE 107742
// uc_nation := nation_arabian else
107732: LD_ADDR_OWVAR 21
107736: PUSH
107737: LD_INT 2
107739: ST_TO_ADDR
107740: GO 107750
// uc_nation := nation_russian ;
107742: LD_ADDR_OWVAR 21
107746: PUSH
107747: LD_INT 3
107749: ST_TO_ADDR
// vc_chassis := chassis ;
107750: LD_ADDR_OWVAR 37
107754: PUSH
107755: LD_VAR 0 1
107759: ST_TO_ADDR
// vc_engine := engine ;
107760: LD_ADDR_OWVAR 39
107764: PUSH
107765: LD_VAR 0 2
107769: ST_TO_ADDR
// vc_control := control ;
107770: LD_ADDR_OWVAR 38
107774: PUSH
107775: LD_VAR 0 3
107779: ST_TO_ADDR
// vc_weapon := weapon ;
107780: LD_ADDR_OWVAR 40
107784: PUSH
107785: LD_VAR 0 4
107789: ST_TO_ADDR
// un := CreateVehicle ;
107790: LD_ADDR_VAR 0 8
107794: PUSH
107795: CALL_OW 45
107799: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107800: LD_VAR 0 8
107804: PPUSH
107805: LD_INT 0
107807: PPUSH
107808: LD_INT 5
107810: PPUSH
107811: CALL_OW 12
107815: PPUSH
107816: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107820: LD_VAR 0 8
107824: PPUSH
107825: LD_VAR 0 5
107829: PPUSH
107830: LD_VAR 0 6
107834: PPUSH
107835: LD_INT 1
107837: PPUSH
107838: CALL_OW 48
// end ;
107842: LD_VAR 0 7
107846: RET
// export hInvincible ; every 1 do
107847: GO 107849
107849: DISABLE
// hInvincible := [ ] ;
107850: LD_ADDR_EXP 154
107854: PUSH
107855: EMPTY
107856: ST_TO_ADDR
107857: END
// every 10 do var i ;
107858: GO 107860
107860: DISABLE
107861: LD_INT 0
107863: PPUSH
// begin enable ;
107864: ENABLE
// if not hInvincible then
107865: LD_EXP 154
107869: NOT
107870: IFFALSE 107874
// exit ;
107872: GO 107918
// for i in hInvincible do
107874: LD_ADDR_VAR 0 1
107878: PUSH
107879: LD_EXP 154
107883: PUSH
107884: FOR_IN
107885: IFFALSE 107916
// if GetLives ( i ) < 1000 then
107887: LD_VAR 0 1
107891: PPUSH
107892: CALL_OW 256
107896: PUSH
107897: LD_INT 1000
107899: LESS
107900: IFFALSE 107914
// SetLives ( i , 1000 ) ;
107902: LD_VAR 0 1
107906: PPUSH
107907: LD_INT 1000
107909: PPUSH
107910: CALL_OW 234
107914: GO 107884
107916: POP
107917: POP
// end ;
107918: PPOPN 1
107920: END
// export function hHackInvincible ; var i ; begin
107921: LD_INT 0
107923: PPUSH
107924: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107925: LD_ADDR_VAR 0 2
107929: PUSH
107930: LD_INT 2
107932: PUSH
107933: LD_INT 21
107935: PUSH
107936: LD_INT 1
107938: PUSH
107939: EMPTY
107940: LIST
107941: LIST
107942: PUSH
107943: LD_INT 21
107945: PUSH
107946: LD_INT 2
107948: PUSH
107949: EMPTY
107950: LIST
107951: LIST
107952: PUSH
107953: EMPTY
107954: LIST
107955: LIST
107956: LIST
107957: PPUSH
107958: CALL_OW 69
107962: PUSH
107963: FOR_IN
107964: IFFALSE 108025
// if IsSelected ( i ) then
107966: LD_VAR 0 2
107970: PPUSH
107971: CALL_OW 306
107975: IFFALSE 108023
// begin if i in hInvincible then
107977: LD_VAR 0 2
107981: PUSH
107982: LD_EXP 154
107986: IN
107987: IFFALSE 108007
// hInvincible := hInvincible diff i else
107989: LD_ADDR_EXP 154
107993: PUSH
107994: LD_EXP 154
107998: PUSH
107999: LD_VAR 0 2
108003: DIFF
108004: ST_TO_ADDR
108005: GO 108023
// hInvincible := hInvincible union i ;
108007: LD_ADDR_EXP 154
108011: PUSH
108012: LD_EXP 154
108016: PUSH
108017: LD_VAR 0 2
108021: UNION
108022: ST_TO_ADDR
// end ;
108023: GO 107963
108025: POP
108026: POP
// end ;
108027: LD_VAR 0 1
108031: RET
// export function hHackInvisible ; var i , j ; begin
108032: LD_INT 0
108034: PPUSH
108035: PPUSH
108036: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108037: LD_ADDR_VAR 0 2
108041: PUSH
108042: LD_INT 21
108044: PUSH
108045: LD_INT 1
108047: PUSH
108048: EMPTY
108049: LIST
108050: LIST
108051: PPUSH
108052: CALL_OW 69
108056: PUSH
108057: FOR_IN
108058: IFFALSE 108082
// if IsSelected ( i ) then
108060: LD_VAR 0 2
108064: PPUSH
108065: CALL_OW 306
108069: IFFALSE 108080
// ComForceInvisible ( i ) ;
108071: LD_VAR 0 2
108075: PPUSH
108076: CALL_OW 496
108080: GO 108057
108082: POP
108083: POP
// end ;
108084: LD_VAR 0 1
108088: RET
// export function hHackChangeYourSide ; begin
108089: LD_INT 0
108091: PPUSH
// if your_side = 8 then
108092: LD_OWVAR 2
108096: PUSH
108097: LD_INT 8
108099: EQUAL
108100: IFFALSE 108112
// your_side := 0 else
108102: LD_ADDR_OWVAR 2
108106: PUSH
108107: LD_INT 0
108109: ST_TO_ADDR
108110: GO 108126
// your_side := your_side + 1 ;
108112: LD_ADDR_OWVAR 2
108116: PUSH
108117: LD_OWVAR 2
108121: PUSH
108122: LD_INT 1
108124: PLUS
108125: ST_TO_ADDR
// end ;
108126: LD_VAR 0 1
108130: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108131: LD_INT 0
108133: PPUSH
108134: PPUSH
108135: PPUSH
// for i in all_units do
108136: LD_ADDR_VAR 0 2
108140: PUSH
108141: LD_OWVAR 3
108145: PUSH
108146: FOR_IN
108147: IFFALSE 108225
// if IsSelected ( i ) then
108149: LD_VAR 0 2
108153: PPUSH
108154: CALL_OW 306
108158: IFFALSE 108223
// begin j := GetSide ( i ) ;
108160: LD_ADDR_VAR 0 3
108164: PUSH
108165: LD_VAR 0 2
108169: PPUSH
108170: CALL_OW 255
108174: ST_TO_ADDR
// if j = 8 then
108175: LD_VAR 0 3
108179: PUSH
108180: LD_INT 8
108182: EQUAL
108183: IFFALSE 108195
// j := 0 else
108185: LD_ADDR_VAR 0 3
108189: PUSH
108190: LD_INT 0
108192: ST_TO_ADDR
108193: GO 108209
// j := j + 1 ;
108195: LD_ADDR_VAR 0 3
108199: PUSH
108200: LD_VAR 0 3
108204: PUSH
108205: LD_INT 1
108207: PLUS
108208: ST_TO_ADDR
// SetSide ( i , j ) ;
108209: LD_VAR 0 2
108213: PPUSH
108214: LD_VAR 0 3
108218: PPUSH
108219: CALL_OW 235
// end ;
108223: GO 108146
108225: POP
108226: POP
// end ;
108227: LD_VAR 0 1
108231: RET
// export function hHackFog ; begin
108232: LD_INT 0
108234: PPUSH
// FogOff ( true ) ;
108235: LD_INT 1
108237: PPUSH
108238: CALL_OW 344
// end ;
108242: LD_VAR 0 1
108246: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108247: LD_INT 0
108249: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108250: LD_VAR 0 1
108254: PPUSH
108255: LD_VAR 0 2
108259: PPUSH
108260: LD_VAR 0 3
108264: PPUSH
108265: LD_INT 1
108267: PPUSH
108268: LD_INT 1
108270: PPUSH
108271: CALL_OW 483
// CenterOnXY ( x , y ) ;
108275: LD_VAR 0 2
108279: PPUSH
108280: LD_VAR 0 3
108284: PPUSH
108285: CALL_OW 84
// end ; end_of_file
108289: LD_VAR 0 4
108293: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
108294: LD_VAR 0 1
108298: PPUSH
108299: LD_VAR 0 2
108303: PPUSH
108304: LD_VAR 0 3
108308: PPUSH
108309: LD_VAR 0 4
108313: PPUSH
108314: LD_VAR 0 5
108318: PPUSH
108319: LD_VAR 0 6
108323: PPUSH
108324: CALL 94007 0 6
// end ;
108328: PPOPN 6
108330: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
108331: CALL 93982 0 0
// end ;
108335: PPOPN 1
108337: END
