// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 206 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45146 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45146 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45146 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45146 0 9
// PrepareGensher ;
 185: CALL 3152 0 0
// PreparePopov ;
 189: CALL 6359 0 0
// PreparePowell ;
 193: CALL 585 0 0
// PrepareSikorski ;
 197: CALL 9047 0 0
// MC_Start ( ) ;
 201: CALL 54555 0 0
// end ;
 205: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 206: LD_INT 0
 208: PPUSH
// debug := 1 ;
 209: LD_ADDR_EXP 1
 213: PUSH
 214: LD_INT 1
 216: ST_TO_ADDR
// game := true ;
 217: LD_ADDR_EXP 2
 221: PUSH
 222: LD_INT 1
 224: ST_TO_ADDR
// staticMines := [ ] ;
 225: LD_ADDR_EXP 3
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// arDestroyed := false ;
 232: LD_ADDR_EXP 4
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// ruDestroyed := false ;
 240: LD_ADDR_EXP 5
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// powellInTrouble := false ;
 248: LD_ADDR_EXP 8
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// sikorskiInTrouble := false ;
 256: LD_ADDR_EXP 9
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// end ;
 264: LD_VAR 0 1
 268: RET
// export function CustomInitMacro ; begin
 269: LD_INT 0
 271: PPUSH
// InitMC_Gensher ( ) ;
 272: CALL 4286 0 0
// InitMC_Powell ( ) ;
 276: CALL 1507 0 0
// InitMC_Popov ( ) ;
 280: CALL 7517 0 0
// end ;
 284: LD_VAR 0 1
 288: RET
// every 0 0$10 do var cr , time , i ;
 289: GO 291
 291: DISABLE
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
 296: PPUSH
// begin time := 0 0$20 ;
 297: LD_ADDR_VAR 0 2
 301: PUSH
 302: LD_INT 700
 304: ST_TO_ADDR
// repeat wait ( time ) ;
 305: LD_VAR 0 2
 309: PPUSH
 310: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 314: LD_ADDR_VAR 0 1
 318: PUSH
 319: LD_INT 1
 321: PPUSH
 322: LD_INT 5
 324: PPUSH
 325: CALL_OW 12
 329: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 330: LD_ADDR_VAR 0 3
 334: PUSH
 335: LD_INT 5
 337: PUSH
 338: LD_INT 8
 340: PUSH
 341: LD_INT 12
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: LIST
 352: PUSH
 353: FOR_IN
 354: IFFALSE 408
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 356: LD_VAR 0 3
 360: PPUSH
 361: LD_INT 1
 363: PPUSH
 364: CALL_OW 287
 368: PUSH
 369: LD_INT 40
 371: LESS
 372: IFFALSE 391
// CreateCratesArea ( cr , i , true ) ;
 374: LD_VAR 0 1
 378: PPUSH
 379: LD_VAR 0 3
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 391: LD_INT 175
 393: PPUSH
 394: LD_INT 525
 396: PPUSH
 397: CALL_OW 12
 401: PPUSH
 402: CALL_OW 67
// end ;
 406: GO 353
 408: POP
 409: POP
// time := time + 0 0$2 ;
 410: LD_ADDR_VAR 0 2
 414: PUSH
 415: LD_VAR 0 2
 419: PUSH
 420: LD_INT 70
 422: PLUS
 423: ST_TO_ADDR
// if time > 0 0$35 then
 424: LD_VAR 0 2
 428: PUSH
 429: LD_INT 1225
 431: GREATER
 432: IFFALSE 442
// time := 0 0$25 ;
 434: LD_ADDR_VAR 0 2
 438: PUSH
 439: LD_INT 875
 441: ST_TO_ADDR
// until not game ;
 442: LD_EXP 2
 446: NOT
 447: IFFALSE 305
// end ;
 449: PPOPN 3
 451: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 452: LD_INT 3
 454: PUSH
 455: LD_INT 22
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 1
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 69
 487: IFFALSE 582
 489: GO 491
 491: DISABLE
 492: LD_INT 0
 494: PPUSH
 495: PPUSH
// begin enable ;
 496: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 497: LD_ADDR_VAR 0 2
 501: PUSH
 502: LD_INT 3
 504: PUSH
 505: LD_INT 22
 507: PUSH
 508: LD_INT 1
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 32
 521: PUSH
 522: LD_INT 1
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: ST_TO_ADDR
// for i in tmp do
 538: LD_ADDR_VAR 0 1
 542: PUSH
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_IN
 549: IFFALSE 580
// if GetFuel ( i ) < 5 then
 551: LD_VAR 0 1
 555: PPUSH
 556: CALL_OW 261
 560: PUSH
 561: LD_INT 5
 563: LESS
 564: IFFALSE 578
// SetFuel ( i , 5 ) ;
 566: LD_VAR 0 1
 570: PPUSH
 571: LD_INT 5
 573: PPUSH
 574: CALL_OW 240
 578: GO 548
 580: POP
 581: POP
// end ; end_of_file
 582: PPOPN 2
 584: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 585: LD_INT 0
 587: PPUSH
 588: PPUSH
 589: PPUSH
 590: PPUSH
 591: PPUSH
// powell_side := 4 ;
 592: LD_ADDR_EXP 11
 596: PUSH
 597: LD_INT 4
 599: ST_TO_ADDR
// uc_side := powell_side ;
 600: LD_ADDR_OWVAR 20
 604: PUSH
 605: LD_EXP 11
 609: ST_TO_ADDR
// uc_nation := 1 ;
 610: LD_ADDR_OWVAR 21
 614: PUSH
 615: LD_INT 1
 617: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 618: LD_ADDR_EXP 10
 622: PUSH
 623: LD_STRING Powell
 625: PPUSH
 626: CALL_OW 25
 630: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 631: LD_EXP 10
 635: PPUSH
 636: LD_INT 1
 638: PPUSH
 639: LD_INT 7
 641: PPUSH
 642: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 646: LD_EXP 10
 650: PPUSH
 651: LD_INT 2
 653: PPUSH
 654: LD_INT 5
 656: PPUSH
 657: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 661: LD_EXP 10
 665: PPUSH
 666: LD_INT 3
 668: PPUSH
 669: LD_INT 6
 671: PPUSH
 672: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 676: LD_EXP 10
 680: PPUSH
 681: LD_INT 4
 683: PPUSH
 684: LD_INT 4
 686: PPUSH
 687: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 691: LD_EXP 10
 695: PPUSH
 696: LD_INT 4
 698: PPUSH
 699: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 703: LD_ADDR_VAR 0 3
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 178
 713: PUSH
 714: LD_INT 117
 716: PUSH
 717: LD_INT 2
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_INT 29
 728: PUSH
 729: LD_INT 167
 731: PUSH
 732: LD_INT 102
 734: PUSH
 735: LD_INT 0
 737: PUSH
 738: EMPTY
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 6
 746: PUSH
 747: LD_INT 200
 749: PUSH
 750: LD_INT 111
 752: PUSH
 753: LD_INT 4
 755: PUSH
 756: LD_INT 10
 758: PUSH
 759: LD_INT 11
 761: PUSH
 762: EMPTY
 763: LIST
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 3
 772: PUSH
 773: LD_INT 201
 775: PUSH
 776: LD_INT 140
 778: PUSH
 779: LD_INT 4
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 27
 790: PUSH
 791: LD_INT 206
 793: PUSH
 794: LD_INT 124
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 27
 808: PUSH
 809: LD_INT 209
 811: PUSH
 812: LD_INT 128
 814: PUSH
 815: LD_INT 3
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 27
 826: PUSH
 827: LD_INT 211
 829: PUSH
 830: LD_INT 132
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 30
 844: PUSH
 845: LD_INT 173
 847: PUSH
 848: LD_INT 83
 850: PUSH
 851: LD_INT 3
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PUSH
 860: LD_INT 6
 862: PUSH
 863: LD_INT 186
 865: PUSH
 866: LD_INT 103
 868: PUSH
 869: LD_INT 2
 871: PUSH
 872: LD_INT 12
 874: PUSH
 875: LD_INT 15
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 33
 888: PUSH
 889: LD_INT 173
 891: PUSH
 892: LD_INT 99
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 6
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 32
 910: PUSH
 911: LD_INT 174
 913: PUSH
 914: LD_INT 102
 916: PUSH
 917: LD_INT 2
 919: PUSH
 920: LD_INT 6
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PUSH
 930: LD_INT 32
 932: PUSH
 933: LD_INT 178
 935: PUSH
 936: LD_INT 100
 938: PUSH
 939: LD_INT 2
 941: PUSH
 942: LD_INT 6
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 33
 954: PUSH
 955: LD_INT 174
 957: PUSH
 958: LD_INT 108
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 7
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 33
 976: PUSH
 977: LD_INT 182
 979: PUSH
 980: LD_INT 122
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 7
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 36
 998: PUSH
 999: LD_INT 194
1001: PUSH
1002: LD_INT 124
1004: PUSH
1005: LD_INT 5
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 33
1016: PUSH
1017: LD_INT 184
1019: PUSH
1020: LD_INT 141
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 6
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 33
1038: PUSH
1039: LD_INT 183
1041: PUSH
1042: LD_INT 131
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 11
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 33
1060: PUSH
1061: LD_INT 194
1063: PUSH
1064: LD_INT 146
1066: PUSH
1067: LD_INT 4
1069: PUSH
1070: LD_INT 7
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: PUSH
1080: LD_INT 33
1082: PUSH
1083: LD_INT 190
1085: PUSH
1086: LD_INT 142
1088: PUSH
1089: LD_INT 4
1091: PUSH
1092: LD_INT 7
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PUSH
1102: LD_INT 28
1104: PUSH
1105: LD_INT 204
1107: PUSH
1108: LD_INT 133
1110: PUSH
1111: LD_INT 3
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PUSH
1120: LD_INT 27
1122: PUSH
1123: LD_INT 201
1125: PUSH
1126: LD_INT 133
1128: PUSH
1129: LD_INT 3
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PUSH
1138: LD_INT 28
1140: PUSH
1141: LD_INT 199
1143: PUSH
1144: LD_INT 119
1146: PUSH
1147: LD_INT 5
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: ST_TO_ADDR
// for i in list do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: LD_VAR 0 3
1189: PUSH
1190: FOR_IN
1191: IFFALSE 1369
// begin uc_side := 4 ;
1193: LD_ADDR_OWVAR 20
1197: PUSH
1198: LD_INT 4
1200: ST_TO_ADDR
// uc_nation := 1 ;
1201: LD_ADDR_OWVAR 21
1205: PUSH
1206: LD_INT 1
1208: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1209: LD_ADDR_OWVAR 42
1213: PUSH
1214: LD_VAR 0 2
1218: PUSH
1219: LD_INT 1
1221: ARRAY
1222: ST_TO_ADDR
// bc_kind1 := - 1 ;
1223: LD_ADDR_OWVAR 44
1227: PUSH
1228: LD_INT 1
1230: NEG
1231: ST_TO_ADDR
// bc_kind2 := - 1 ;
1232: LD_ADDR_OWVAR 45
1236: PUSH
1237: LD_INT 1
1239: NEG
1240: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1241: LD_VAR 0 2
1245: PUSH
1246: LD_INT 1
1248: ARRAY
1249: PUSH
1250: LD_INT 6
1252: EQUAL
1253: IFFALSE 1291
// begin bc_type := b_lab_full ;
1255: LD_ADDR_OWVAR 42
1259: PUSH
1260: LD_INT 8
1262: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1263: LD_ADDR_OWVAR 44
1267: PUSH
1268: LD_VAR 0 2
1272: PUSH
1273: LD_INT 5
1275: ARRAY
1276: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1277: LD_ADDR_OWVAR 45
1281: PUSH
1282: LD_VAR 0 2
1286: PUSH
1287: LD_INT 6
1289: ARRAY
1290: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1291: LD_ADDR_VAR 0 4
1295: PUSH
1296: LD_VAR 0 2
1300: PUSH
1301: LD_INT 2
1303: ARRAY
1304: PPUSH
1305: LD_VAR 0 2
1309: PUSH
1310: LD_INT 3
1312: ARRAY
1313: PPUSH
1314: LD_VAR 0 2
1318: PUSH
1319: LD_INT 4
1321: ARRAY
1322: PPUSH
1323: CALL_OW 47
1327: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1328: LD_VAR 0 2
1332: PUSH
1333: LD_INT 1
1335: ARRAY
1336: PUSH
1337: LD_INT 33
1339: PUSH
1340: LD_INT 32
1342: PUSH
1343: EMPTY
1344: LIST
1345: LIST
1346: IN
1347: IFFALSE 1367
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1349: LD_VAR 0 4
1353: PPUSH
1354: LD_VAR 0 2
1358: PUSH
1359: LD_INT 5
1361: ARRAY
1362: PPUSH
1363: CALL_OW 431
// end ;
1367: GO 1190
1369: POP
1370: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1371: LD_ADDR_VAR 0 5
1375: PUSH
1376: LD_INT 4
1378: PPUSH
1379: LD_INT 1
1381: PPUSH
1382: LD_STRING 
1384: PPUSH
1385: LD_INT 8
1387: PUSH
1388: LD_INT 7
1390: PUSH
1391: LD_INT 6
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: LIST
1398: PUSH
1399: LD_OWVAR 67
1403: ARRAY
1404: PPUSH
1405: LD_INT 5500
1407: PUSH
1408: LD_INT 500
1410: PUSH
1411: LD_INT 0
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: PPUSH
1419: LD_INT 6
1421: PUSH
1422: LD_INT 6
1424: PUSH
1425: LD_INT 6
1427: PUSH
1428: LD_INT 6
1430: PUSH
1431: EMPTY
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 19474 0 6
1441: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1442: LD_ADDR_EXP 23
1446: PUSH
1447: LD_EXP 23
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: LD_VAR 0 5
1459: PUSH
1460: LD_INT 22
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 21
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: EMPTY
1477: LIST
1478: LIST
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: PPUSH
1484: CALL_OW 69
1488: UNION
1489: PPUSH
1490: CALL_OW 1
1494: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1495: LD_ADDR_EXP 12
1499: PUSH
1500: EMPTY
1501: ST_TO_ADDR
// end ;
1502: LD_VAR 0 1
1506: RET
// export function InitMC_Powell ( ) ; begin
1507: LD_INT 0
1509: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1510: LD_INT 1
1512: PPUSH
1513: LD_INT 1
1515: PPUSH
1516: CALL 77932 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1520: LD_INT 1
1522: PPUSH
1523: LD_INT 6
1525: PPUSH
1526: CALL 77876 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1530: LD_INT 1
1532: PPUSH
1533: LD_INT 167
1535: PUSH
1536: LD_INT 102
1538: PUSH
1539: LD_INT 0
1541: PUSH
1542: EMPTY
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 173
1549: PUSH
1550: LD_INT 83
1552: PUSH
1553: LD_INT 1
1555: PUSH
1556: EMPTY
1557: LIST
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 171
1563: PUSH
1564: LD_INT 141
1566: PUSH
1567: LD_INT 0
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: LD_INT 178
1577: PUSH
1578: LD_INT 148
1580: PUSH
1581: LD_INT 1
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL 76935 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1599: LD_INT 1
1601: PPUSH
1602: LD_INT 11
1604: PUSH
1605: LD_INT 6
1607: PUSH
1608: LD_INT 7
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: PPUSH
1616: CALL 77764 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1620: LD_INT 1
1622: PPUSH
1623: LD_INT 5
1625: PPUSH
1626: CALL 77446 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1630: LD_INT 1
1632: PPUSH
1633: LD_INT 4
1635: PPUSH
1636: CALL 77177 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 4
1645: PPUSH
1646: CALL 76796 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1650: LD_INT 1
1652: PPUSH
1653: LD_INT 3
1655: PUSH
1656: LD_INT 1
1658: PUSH
1659: LD_INT 2
1661: PUSH
1662: LD_INT 5
1664: PUSH
1665: EMPTY
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_INT 4
1673: PUSH
1674: LD_INT 1
1676: PUSH
1677: LD_INT 2
1679: PUSH
1680: LD_INT 6
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: PUSH
1689: LD_INT 4
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 7
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: EMPTY
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: PPUSH
1731: CALL 76611 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1735: LD_INT 1
1737: PPUSH
1738: LD_INT 201
1740: PPUSH
1741: LD_INT 140
1743: PPUSH
1744: LD_INT 4
1746: PPUSH
1747: LD_INT 19
1749: PUSH
1750: LD_INT 16
1752: PUSH
1753: LD_INT 17
1755: PUSH
1756: LD_INT 18
1758: PUSH
1759: LD_INT 22
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: LIST
1767: LIST
1768: PPUSH
1769: CALL 77558 0 5
// end ;
1773: LD_VAR 0 1
1777: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1778: LD_INT 4
1780: PPUSH
1781: CALL_OW 302
1785: IFFALSE 2445
1787: GO 1789
1789: DISABLE
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
1796: PPUSH
// begin enable ;
1797: ENABLE
// base := 1 ;
1798: LD_ADDR_VAR 0 2
1802: PUSH
1803: LD_INT 1
1805: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1806: LD_ADDR_VAR 0 3
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 2
1819: PUSH
1820: LD_INT 6
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: PUSH
1829: LD_INT 4
1831: PUSH
1832: LD_INT 1
1834: PUSH
1835: LD_INT 2
1837: PUSH
1838: LD_INT 6
1840: PUSH
1841: EMPTY
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 7
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 3
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 7
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1889: LD_ADDR_VAR 0 5
1893: PUSH
1894: LD_VAR 0 5
1898: PUSH
1899: LD_OWVAR 1
1903: PUSH
1904: LD_INT 21000
1906: DIV
1907: PLUS
1908: ST_TO_ADDR
// if amount > 8 then
1909: LD_VAR 0 5
1913: PUSH
1914: LD_INT 8
1916: GREATER
1917: IFFALSE 1927
// amount := 8 ;
1919: LD_ADDR_VAR 0 5
1923: PUSH
1924: LD_INT 8
1926: ST_TO_ADDR
// for i = 1 to amount do
1927: LD_ADDR_VAR 0 1
1931: PUSH
1932: DOUBLE
1933: LD_INT 1
1935: DEC
1936: ST_TO_ADDR
1937: LD_VAR 0 5
1941: PUSH
1942: FOR_TO
1943: IFFALSE 2027
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1945: LD_ADDR_VAR 0 3
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: LD_VAR 0 3
1959: PUSH
1960: LD_INT 1
1962: PLUS
1963: PPUSH
1964: LD_INT 3
1966: PUSH
1967: LD_INT 4
1969: PUSH
1970: EMPTY
1971: LIST
1972: LIST
1973: PUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 2
1979: PPUSH
1980: CALL_OW 12
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: PUSH
1989: LD_INT 2
1991: PUSH
1992: LD_INT 7
1994: PUSH
1995: LD_INT 5
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PUSH
2014: EMPTY
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL_OW 2
2024: ST_TO_ADDR
2025: GO 1942
2027: POP
2028: POP
// MC_InsertProduceList ( base , tmp ) ;
2029: LD_VAR 0 2
2033: PPUSH
2034: LD_VAR 0 3
2038: PPUSH
2039: CALL 76659 0 2
// repeat wait ( 0 0$1 ) ;
2043: LD_INT 35
2045: PPUSH
2046: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2050: LD_VAR 0 2
2054: PPUSH
2055: LD_INT 1
2057: PPUSH
2058: CALL 78077 0 2
2062: PUSH
2063: LD_VAR 0 5
2067: GREATEREQUAL
2068: IFFALSE 2043
// wait ( 0 0$30 ) ;
2070: LD_INT 1050
2072: PPUSH
2073: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2077: LD_ADDR_VAR 0 4
2081: PUSH
2082: LD_EXP 42
2086: PUSH
2087: LD_VAR 0 2
2091: ARRAY
2092: PUSH
2093: LD_EXP 42
2097: PUSH
2098: LD_VAR 0 2
2102: ARRAY
2103: PPUSH
2104: LD_INT 2
2106: PUSH
2107: LD_INT 34
2109: PUSH
2110: LD_INT 12
2112: PUSH
2113: EMPTY
2114: LIST
2115: LIST
2116: PUSH
2117: LD_INT 34
2119: PUSH
2120: LD_INT 13
2122: PUSH
2123: EMPTY
2124: LIST
2125: LIST
2126: PUSH
2127: LD_INT 34
2129: PUSH
2130: LD_INT 14
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 72
2147: DIFF
2148: ST_TO_ADDR
// if not attackers then
2149: LD_VAR 0 4
2153: NOT
2154: IFFALSE 2158
// exit ;
2156: GO 2445
// DialogPowellsAttack ;
2158: CALL 9585 0 0
// powellAttackGroup := attackers ;
2162: LD_ADDR_EXP 12
2166: PUSH
2167: LD_VAR 0 4
2171: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2172: LD_ADDR_EXP 42
2176: PUSH
2177: LD_EXP 42
2181: PPUSH
2182: LD_VAR 0 2
2186: PPUSH
2187: LD_EXP 42
2191: PUSH
2192: LD_VAR 0 2
2196: ARRAY
2197: PUSH
2198: LD_VAR 0 4
2202: DIFF
2203: PPUSH
2204: CALL_OW 1
2208: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2209: LD_EXP 9
2213: PUSH
2214: LD_INT 16
2216: PPUSH
2217: LD_INT 81
2219: PUSH
2220: LD_INT 4
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: PPUSH
2227: CALL_OW 70
2231: AND
2232: IFFALSE 2251
// ComAgressiveMove ( attackers , 135 , 21 ) else
2234: LD_VAR 0 4
2238: PPUSH
2239: LD_INT 135
2241: PPUSH
2242: LD_INT 21
2244: PPUSH
2245: CALL_OW 114
2249: GO 2266
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2251: LD_VAR 0 4
2255: PPUSH
2256: LD_INT 146
2258: PPUSH
2259: LD_INT 103
2261: PPUSH
2262: CALL_OW 114
// wait ( 0 0$5 ) ;
2266: LD_INT 175
2268: PPUSH
2269: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2273: LD_INT 35
2275: PPUSH
2276: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2280: LD_VAR 0 4
2284: PPUSH
2285: LD_INT 60
2287: PUSH
2288: EMPTY
2289: LIST
2290: PPUSH
2291: CALL_OW 72
2295: NOT
2296: IFFALSE 2273
// if FilterAllUnits ( [ f_side , 3 ] ) then
2298: LD_INT 22
2300: PUSH
2301: LD_INT 3
2303: PUSH
2304: EMPTY
2305: LIST
2306: LIST
2307: PPUSH
2308: CALL_OW 69
2312: IFFALSE 2331
// ComAgressiveMove ( attackers , 102 , 116 ) else
2314: LD_VAR 0 4
2318: PPUSH
2319: LD_INT 102
2321: PPUSH
2322: LD_INT 116
2324: PPUSH
2325: CALL_OW 114
2329: GO 2346
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2331: LD_VAR 0 4
2335: PPUSH
2336: LD_INT 66
2338: PPUSH
2339: LD_INT 41
2341: PPUSH
2342: CALL_OW 114
// wait ( 0 0$10 ) ;
2346: LD_INT 350
2348: PPUSH
2349: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2353: LD_INT 35
2355: PPUSH
2356: CALL_OW 67
// for i in attackers do
2360: LD_ADDR_VAR 0 1
2364: PUSH
2365: LD_VAR 0 4
2369: PUSH
2370: FOR_IN
2371: IFFALSE 2421
// if not HasTask ( i ) then
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 314
2382: NOT
2383: IFFALSE 2419
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2385: LD_VAR 0 1
2389: PPUSH
2390: LD_INT 81
2392: PUSH
2393: LD_INT 4
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: PPUSH
2400: CALL_OW 69
2404: PPUSH
2405: LD_VAR 0 1
2409: PPUSH
2410: CALL_OW 74
2414: PPUSH
2415: CALL_OW 115
2419: GO 2370
2421: POP
2422: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2423: LD_VAR 0 4
2427: PPUSH
2428: LD_INT 50
2430: PUSH
2431: EMPTY
2432: LIST
2433: PPUSH
2434: CALL_OW 72
2438: NOT
2439: IFFALSE 2353
// DialogPowellsAttackFailed ;
2441: CALL 9850 0 0
// end ;
2445: PPOPN 5
2447: END
// every 0 0$2 do var vehicles , mechs , i ;
2448: GO 2450
2450: DISABLE
2451: LD_INT 0
2453: PPUSH
2454: PPUSH
2455: PPUSH
// begin enable ;
2456: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2457: LD_ADDR_VAR 0 1
2461: PUSH
2462: LD_INT 22
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: EMPTY
2469: LIST
2470: LIST
2471: PUSH
2472: LD_INT 21
2474: PUSH
2475: LD_INT 2
2477: PUSH
2478: EMPTY
2479: LIST
2480: LIST
2481: PUSH
2482: LD_INT 3
2484: PUSH
2485: LD_INT 24
2487: PUSH
2488: LD_INT 1000
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: PUSH
2499: LD_INT 92
2501: PUSH
2502: LD_INT 191
2504: PUSH
2505: LD_INT 140
2507: PUSH
2508: LD_INT 10
2510: PUSH
2511: EMPTY
2512: LIST
2513: LIST
2514: LIST
2515: LIST
2516: PUSH
2517: EMPTY
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: PPUSH
2523: CALL_OW 69
2527: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2528: LD_ADDR_VAR 0 2
2532: PUSH
2533: LD_INT 22
2535: PUSH
2536: LD_INT 4
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PUSH
2543: LD_INT 25
2545: PUSH
2546: LD_INT 3
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 69
2561: ST_TO_ADDR
// if not mechs then
2562: LD_VAR 0 2
2566: NOT
2567: IFFALSE 2571
// exit ;
2569: GO 2745
// if mc_remote_driver [ 1 ] then
2571: LD_EXP 63
2575: PUSH
2576: LD_INT 1
2578: ARRAY
2579: IFFALSE 2601
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2581: LD_ADDR_VAR 0 2
2585: PUSH
2586: LD_VAR 0 2
2590: PUSH
2591: LD_EXP 63
2595: PUSH
2596: LD_INT 1
2598: ARRAY
2599: DIFF
2600: ST_TO_ADDR
// if not mechs then
2601: LD_VAR 0 2
2605: NOT
2606: IFFALSE 2610
// exit ;
2608: GO 2745
// if vehicles then
2610: LD_VAR 0 1
2614: IFFALSE 2702
// begin for i in mechs do
2616: LD_ADDR_VAR 0 3
2620: PUSH
2621: LD_VAR 0 2
2625: PUSH
2626: FOR_IN
2627: IFFALSE 2698
// begin if GetTag ( i ) <> 120 then
2629: LD_VAR 0 3
2633: PPUSH
2634: CALL_OW 110
2638: PUSH
2639: LD_INT 120
2641: NONEQUAL
2642: IFFALSE 2656
// SetTag ( i , 120 ) ;
2644: LD_VAR 0 3
2648: PPUSH
2649: LD_INT 120
2651: PPUSH
2652: CALL_OW 109
// if IsInUnit ( i ) then
2656: LD_VAR 0 3
2660: PPUSH
2661: CALL_OW 310
2665: IFFALSE 2678
// ComExitBuilding ( i ) else
2667: LD_VAR 0 3
2671: PPUSH
2672: CALL_OW 122
2676: GO 2696
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2678: LD_VAR 0 3
2682: PPUSH
2683: LD_VAR 0 1
2687: PUSH
2688: LD_INT 1
2690: ARRAY
2691: PPUSH
2692: CALL_OW 129
// end ;
2696: GO 2626
2698: POP
2699: POP
// end else
2700: GO 2745
// if FilterByTag ( mechs , 120 ) then
2702: LD_VAR 0 2
2706: PPUSH
2707: LD_INT 120
2709: PPUSH
2710: CALL 46038 0 2
2714: IFFALSE 2745
// begin for i in mechs do
2716: LD_ADDR_VAR 0 3
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: FOR_IN
2727: IFFALSE 2743
// begin SetTag ( i , 0 ) ;
2729: LD_VAR 0 3
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 109
// end ;
2741: GO 2726
2743: POP
2744: POP
// end ; end ;
2745: PPOPN 3
2747: END
// every 0 0$2 do var people , sci , i ;
2748: GO 2750
2750: DISABLE
2751: LD_INT 0
2753: PPUSH
2754: PPUSH
2755: PPUSH
// begin enable ;
2756: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2757: LD_ADDR_VAR 0 1
2761: PUSH
2762: LD_INT 22
2764: PUSH
2765: LD_INT 1
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PUSH
2772: LD_INT 21
2774: PUSH
2775: LD_INT 1
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PUSH
2782: LD_INT 3
2784: PUSH
2785: LD_INT 24
2787: PUSH
2788: LD_INT 1000
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: PUSH
2799: LD_INT 92
2801: PUSH
2802: LD_INT 188
2804: PUSH
2805: LD_INT 112
2807: PUSH
2808: LD_INT 10
2810: PUSH
2811: EMPTY
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: PUSH
2817: EMPTY
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 69
2827: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 22
2835: PUSH
2836: LD_INT 4
2838: PUSH
2839: EMPTY
2840: LIST
2841: LIST
2842: PUSH
2843: LD_INT 25
2845: PUSH
2846: LD_INT 4
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PPUSH
2857: CALL_OW 69
2861: ST_TO_ADDR
// if not sci then
2862: LD_VAR 0 2
2866: NOT
2867: IFFALSE 2871
// exit ;
2869: GO 3006
// if people then
2871: LD_VAR 0 1
2875: IFFALSE 2963
// begin for i in sci do
2877: LD_ADDR_VAR 0 3
2881: PUSH
2882: LD_VAR 0 2
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2959
// begin if GetTag ( i ) <> 102 then
2890: LD_VAR 0 3
2894: PPUSH
2895: CALL_OW 110
2899: PUSH
2900: LD_INT 102
2902: NONEQUAL
2903: IFFALSE 2917
// SetTag ( i , 102 ) ;
2905: LD_VAR 0 3
2909: PPUSH
2910: LD_INT 102
2912: PPUSH
2913: CALL_OW 109
// if IsInUnit ( i ) then
2917: LD_VAR 0 3
2921: PPUSH
2922: CALL_OW 310
2926: IFFALSE 2939
// ComExitBuilding ( i ) else
2928: LD_VAR 0 3
2932: PPUSH
2933: CALL_OW 122
2937: GO 2957
// ComHeal ( i , people [ 1 ] ) ;
2939: LD_VAR 0 3
2943: PPUSH
2944: LD_VAR 0 1
2948: PUSH
2949: LD_INT 1
2951: ARRAY
2952: PPUSH
2953: CALL_OW 128
// end ;
2957: GO 2887
2959: POP
2960: POP
// end else
2961: GO 3006
// if FilterByTag ( sci , 102 ) then
2963: LD_VAR 0 2
2967: PPUSH
2968: LD_INT 102
2970: PPUSH
2971: CALL 46038 0 2
2975: IFFALSE 3006
// begin for i in sci do
2977: LD_ADDR_VAR 0 3
2981: PUSH
2982: LD_VAR 0 2
2986: PUSH
2987: FOR_IN
2988: IFFALSE 3004
// begin SetTag ( i , 0 ) ;
2990: LD_VAR 0 3
2994: PPUSH
2995: LD_INT 0
2997: PPUSH
2998: CALL_OW 109
// end ;
3002: GO 2987
3004: POP
3005: POP
// end ; end ;
3006: PPOPN 3
3008: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3009: LD_INT 22
3011: PUSH
3012: LD_INT 4
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 33
3021: PUSH
3022: LD_INT 2
3024: PUSH
3025: EMPTY
3026: LIST
3027: LIST
3028: PUSH
3029: LD_INT 50
3031: PUSH
3032: EMPTY
3033: LIST
3034: PUSH
3035: LD_INT 3
3037: PUSH
3038: LD_INT 61
3040: PUSH
3041: EMPTY
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: LIST
3052: LIST
3053: PPUSH
3054: CALL_OW 69
3058: IFFALSE 3149
3060: GO 3062
3062: DISABLE
3063: LD_INT 0
3065: PPUSH
3066: PPUSH
// begin enable ;
3067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: LD_INT 22
3075: PUSH
3076: LD_INT 4
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: PUSH
3083: LD_INT 33
3085: PUSH
3086: LD_INT 2
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PUSH
3093: LD_INT 50
3095: PUSH
3096: EMPTY
3097: LIST
3098: PUSH
3099: LD_INT 3
3101: PUSH
3102: LD_INT 61
3104: PUSH
3105: EMPTY
3106: LIST
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: PPUSH
3118: CALL_OW 69
3122: ST_TO_ADDR
// for i in tmp do
3123: LD_ADDR_VAR 0 1
3127: PUSH
3128: LD_VAR 0 2
3132: PUSH
3133: FOR_IN
3134: IFFALSE 3147
// Connect ( i ) ;
3136: LD_VAR 0 1
3140: PPUSH
3141: CALL 19121 0 1
3145: GO 3133
3147: POP
3148: POP
// end ; end_of_file
3149: PPOPN 2
3151: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3152: LD_INT 0
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
3159: PPUSH
// gensher_side := 2 ;
3160: LD_ADDR_EXP 14
3164: PUSH
3165: LD_INT 2
3167: ST_TO_ADDR
// uc_side := gensher_side ;
3168: LD_ADDR_OWVAR 20
3172: PUSH
3173: LD_EXP 14
3177: ST_TO_ADDR
// uc_nation := 2 ;
3178: LD_ADDR_OWVAR 21
3182: PUSH
3183: LD_INT 2
3185: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3186: LD_ADDR_VAR 0 6
3190: PUSH
3191: LD_INT 5
3193: PUSH
3194: LD_INT 42
3196: PUSH
3197: LD_INT 29
3199: PUSH
3200: LD_INT 5
3202: PUSH
3203: EMPTY
3204: LIST
3205: LIST
3206: LIST
3207: LIST
3208: PUSH
3209: LD_INT 5
3211: PUSH
3212: LD_INT 36
3214: PUSH
3215: LD_INT 40
3217: PUSH
3218: LD_INT 5
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 6
3229: PUSH
3230: LD_INT 13
3232: PUSH
3233: LD_INT 18
3235: PUSH
3236: LD_INT 1
3238: PUSH
3239: LD_INT 10
3241: PUSH
3242: LD_INT 15
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 27
3255: PUSH
3256: LD_INT 17
3258: PUSH
3259: LD_INT 3
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 29
3273: PUSH
3274: LD_INT 56
3276: PUSH
3277: LD_INT 23
3279: PUSH
3280: LD_INT 0
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 3
3291: PUSH
3292: LD_INT 11
3294: PUSH
3295: LD_INT 7
3297: PUSH
3298: LD_INT 2
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 27
3309: PUSH
3310: LD_INT 20
3312: PUSH
3313: LD_INT 3
3315: PUSH
3316: LD_INT 0
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 27
3327: PUSH
3328: LD_INT 23
3330: PUSH
3331: LD_INT 3
3333: PUSH
3334: LD_INT 0
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 27
3345: PUSH
3346: LD_INT 26
3348: PUSH
3349: LD_INT 3
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 6
3363: PUSH
3364: LD_INT 17
3366: PUSH
3367: LD_INT 27
3369: PUSH
3370: LD_INT 1
3372: PUSH
3373: LD_INT 13
3375: PUSH
3376: LD_INT 11
3378: PUSH
3379: EMPTY
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 32
3389: PUSH
3390: LD_INT 27
3392: PUSH
3393: LD_INT 44
3395: PUSH
3396: LD_INT 5
3398: PUSH
3399: LD_INT 27
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 32
3411: PUSH
3412: LD_INT 41
3414: PUSH
3415: LD_INT 41
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 27
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: PUSH
3431: LD_INT 32
3433: PUSH
3434: LD_INT 45
3436: PUSH
3437: LD_INT 24
3439: PUSH
3440: LD_INT 5
3442: PUSH
3443: LD_INT 28
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: LIST
3451: LIST
3452: PUSH
3453: LD_INT 32
3455: PUSH
3456: LD_INT 48
3458: PUSH
3459: LD_INT 19
3461: PUSH
3462: LD_INT 5
3464: PUSH
3465: LD_INT 28
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: LIST
3474: PUSH
3475: LD_INT 32
3477: PUSH
3478: LD_INT 41
3480: PUSH
3481: LD_INT 3
3483: PUSH
3484: LD_INT 4
3486: PUSH
3487: LD_INT 28
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: LIST
3496: PUSH
3497: LD_INT 5
3499: PUSH
3500: LD_INT 44
3502: PUSH
3503: LD_INT 9
3505: PUSH
3506: LD_INT 4
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: LIST
3513: LIST
3514: PUSH
3515: LD_INT 30
3517: PUSH
3518: LD_INT 52
3520: PUSH
3521: LD_INT 40
3523: PUSH
3524: LD_INT 3
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: ST_TO_ADDR
// for i in list do
3552: LD_ADDR_VAR 0 2
3556: PUSH
3557: LD_VAR 0 6
3561: PUSH
3562: FOR_IN
3563: IFFALSE 3741
// begin uc_side := 2 ;
3565: LD_ADDR_OWVAR 20
3569: PUSH
3570: LD_INT 2
3572: ST_TO_ADDR
// uc_nation := 2 ;
3573: LD_ADDR_OWVAR 21
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3581: LD_ADDR_OWVAR 42
3585: PUSH
3586: LD_VAR 0 2
3590: PUSH
3591: LD_INT 1
3593: ARRAY
3594: ST_TO_ADDR
// bc_kind1 := - 1 ;
3595: LD_ADDR_OWVAR 44
3599: PUSH
3600: LD_INT 1
3602: NEG
3603: ST_TO_ADDR
// bc_kind2 := - 1 ;
3604: LD_ADDR_OWVAR 45
3608: PUSH
3609: LD_INT 1
3611: NEG
3612: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3613: LD_VAR 0 2
3617: PUSH
3618: LD_INT 1
3620: ARRAY
3621: PUSH
3622: LD_INT 6
3624: EQUAL
3625: IFFALSE 3663
// begin bc_type := b_lab_full ;
3627: LD_ADDR_OWVAR 42
3631: PUSH
3632: LD_INT 8
3634: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3635: LD_ADDR_OWVAR 44
3639: PUSH
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 5
3647: ARRAY
3648: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3649: LD_ADDR_OWVAR 45
3653: PUSH
3654: LD_VAR 0 2
3658: PUSH
3659: LD_INT 6
3661: ARRAY
3662: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_VAR 0 2
3672: PUSH
3673: LD_INT 2
3675: ARRAY
3676: PPUSH
3677: LD_VAR 0 2
3681: PUSH
3682: LD_INT 3
3684: ARRAY
3685: PPUSH
3686: LD_VAR 0 2
3690: PUSH
3691: LD_INT 4
3693: ARRAY
3694: PPUSH
3695: CALL_OW 47
3699: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3700: LD_VAR 0 2
3704: PUSH
3705: LD_INT 1
3707: ARRAY
3708: PUSH
3709: LD_INT 33
3711: PUSH
3712: LD_INT 32
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: IN
3719: IFFALSE 3739
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_VAR 0 2
3730: PUSH
3731: LD_INT 5
3733: ARRAY
3734: PPUSH
3735: CALL_OW 431
// end ;
3739: GO 3562
3741: POP
3742: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3743: LD_ADDR_VAR 0 4
3747: PUSH
3748: LD_INT 7
3750: PPUSH
3751: LD_INT 2
3753: PPUSH
3754: LD_STRING 
3756: PPUSH
3757: LD_INT 8
3759: PUSH
3760: LD_INT 7
3762: PUSH
3763: LD_INT 6
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: LIST
3770: PUSH
3771: LD_OWVAR 67
3775: ARRAY
3776: PPUSH
3777: LD_INT 11500
3779: PUSH
3780: LD_INT 1100
3782: PUSH
3783: LD_INT 60
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: LIST
3790: PPUSH
3791: LD_INT 6
3793: PUSH
3794: LD_INT 6
3796: PUSH
3797: LD_INT 6
3799: PUSH
3800: LD_INT 6
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: PPUSH
3809: CALL 19474 0 6
3813: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3814: LD_ADDR_EXP 23
3818: PUSH
3819: LD_EXP 23
3823: PPUSH
3824: LD_INT 2
3826: PPUSH
3827: LD_VAR 0 4
3831: PUSH
3832: LD_INT 22
3834: PUSH
3835: LD_INT 2
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PUSH
3842: LD_INT 21
3844: PUSH
3845: LD_INT 3
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PPUSH
3856: CALL_OW 69
3860: UNION
3861: PPUSH
3862: CALL_OW 1
3866: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3867: LD_ADDR_VAR 0 4
3871: PUSH
3872: LD_INT 22
3874: PUSH
3875: LD_INT 2
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: LD_INT 30
3884: PUSH
3885: LD_INT 31
3887: PUSH
3888: EMPTY
3889: LIST
3890: LIST
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: PPUSH
3896: CALL_OW 69
3900: ST_TO_ADDR
// for i in tmp do
3901: LD_ADDR_VAR 0 2
3905: PUSH
3906: LD_VAR 0 4
3910: PUSH
3911: FOR_IN
3912: IFFALSE 3982
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3914: LD_INT 0
3916: PPUSH
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 4
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: LD_INT 3
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: LIST
3933: PUSH
3934: LD_OWVAR 67
3938: ARRAY
3939: PPUSH
3940: CALL_OW 380
// un := CreateHuman ;
3944: LD_ADDR_VAR 0 5
3948: PUSH
3949: CALL_OW 44
3953: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3954: LD_VAR 0 5
3958: PPUSH
3959: LD_INT 1
3961: PPUSH
3962: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3966: LD_VAR 0 5
3970: PPUSH
3971: LD_VAR 0 2
3975: PPUSH
3976: CALL_OW 52
// end ;
3980: GO 3911
3982: POP
3983: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3984: LD_ADDR_VAR 0 4
3988: PUSH
3989: LD_INT 15
3991: PPUSH
3992: LD_INT 0
3994: PPUSH
3995: CALL_OW 517
3999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: DOUBLE
4006: LD_INT 1
4008: DEC
4009: ST_TO_ADDR
4010: LD_VAR 0 4
4014: PUSH
4015: LD_INT 1
4017: ARRAY
4018: PUSH
4019: FOR_TO
4020: IFFALSE 4122
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4022: LD_VAR 0 4
4026: PUSH
4027: LD_INT 1
4029: ARRAY
4030: PUSH
4031: LD_VAR 0 2
4035: ARRAY
4036: PPUSH
4037: LD_VAR 0 4
4041: PUSH
4042: LD_INT 2
4044: ARRAY
4045: PUSH
4046: LD_VAR 0 2
4050: ARRAY
4051: PPUSH
4052: LD_INT 2
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4062: LD_ADDR_EXP 3
4066: PUSH
4067: LD_EXP 3
4071: PPUSH
4072: LD_EXP 3
4076: PUSH
4077: LD_INT 1
4079: PLUS
4080: PPUSH
4081: LD_VAR 0 4
4085: PUSH
4086: LD_INT 1
4088: ARRAY
4089: PUSH
4090: LD_VAR 0 2
4094: ARRAY
4095: PUSH
4096: LD_VAR 0 4
4100: PUSH
4101: LD_INT 2
4103: ARRAY
4104: PUSH
4105: LD_VAR 0 2
4109: ARRAY
4110: PUSH
4111: EMPTY
4112: LIST
4113: LIST
4114: PPUSH
4115: CALL_OW 2
4119: ST_TO_ADDR
// end ;
4120: GO 4019
4122: POP
4123: POP
// if Difficulty > 1 then
4124: LD_OWVAR 67
4128: PUSH
4129: LD_INT 1
4131: GREATER
4132: IFFALSE 4274
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4134: LD_ADDR_VAR 0 4
4138: PUSH
4139: LD_INT 19
4141: PPUSH
4142: LD_INT 0
4144: PPUSH
4145: CALL_OW 517
4149: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4150: LD_ADDR_VAR 0 2
4154: PUSH
4155: DOUBLE
4156: LD_INT 1
4158: DEC
4159: ST_TO_ADDR
4160: LD_VAR 0 4
4164: PUSH
4165: LD_INT 1
4167: ARRAY
4168: PUSH
4169: FOR_TO
4170: IFFALSE 4272
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4172: LD_VAR 0 4
4176: PUSH
4177: LD_INT 1
4179: ARRAY
4180: PUSH
4181: LD_VAR 0 2
4185: ARRAY
4186: PPUSH
4187: LD_VAR 0 4
4191: PUSH
4192: LD_INT 2
4194: ARRAY
4195: PUSH
4196: LD_VAR 0 2
4200: ARRAY
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_INT 0
4207: PPUSH
4208: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4212: LD_ADDR_EXP 3
4216: PUSH
4217: LD_EXP 3
4221: PPUSH
4222: LD_EXP 3
4226: PUSH
4227: LD_INT 1
4229: PLUS
4230: PPUSH
4231: LD_VAR 0 4
4235: PUSH
4236: LD_INT 1
4238: ARRAY
4239: PUSH
4240: LD_VAR 0 2
4244: ARRAY
4245: PUSH
4246: LD_VAR 0 4
4250: PUSH
4251: LD_INT 2
4253: ARRAY
4254: PUSH
4255: LD_VAR 0 2
4259: ARRAY
4260: PUSH
4261: EMPTY
4262: LIST
4263: LIST
4264: PPUSH
4265: CALL_OW 2
4269: ST_TO_ADDR
// end ;
4270: GO 4169
4272: POP
4273: POP
// end ; gensherAttackGroup := [ ] ;
4274: LD_ADDR_EXP 15
4278: PUSH
4279: EMPTY
4280: ST_TO_ADDR
// end ;
4281: LD_VAR 0 1
4285: RET
// export function InitMC_Gensher ( ) ; begin
4286: LD_INT 0
4288: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4289: LD_INT 2
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 77932 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4299: LD_INT 2
4301: PPUSH
4302: LD_INT 9
4304: PPUSH
4305: CALL 77876 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4309: LD_INT 2
4311: PPUSH
4312: LD_INT 56
4314: PUSH
4315: LD_INT 23
4317: PUSH
4318: LD_INT 0
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 52
4328: PUSH
4329: LD_INT 40
4331: PUSH
4332: LD_INT 1
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PPUSH
4344: CALL 76935 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4348: LD_INT 2
4350: PPUSH
4351: LD_INT 27
4353: PUSH
4354: LD_INT 28
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PPUSH
4361: CALL 77764 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4365: LD_INT 2
4367: PPUSH
4368: LD_INT 8
4370: PPUSH
4371: CALL 77446 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4375: LD_INT 2
4377: PPUSH
4378: LD_INT 7
4380: PPUSH
4381: CALL 77177 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4385: LD_INT 2
4387: PPUSH
4388: LD_INT 4
4390: PPUSH
4391: CALL 76796 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4395: LD_INT 2
4397: PPUSH
4398: LD_INT 13
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: LD_INT 1
4406: PUSH
4407: LD_INT 31
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 13
4418: PUSH
4419: LD_INT 2
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: LD_INT 31
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: PUSH
4434: LD_INT 14
4436: PUSH
4437: LD_INT 1
4439: PUSH
4440: LD_INT 2
4442: PUSH
4443: LD_INT 27
4445: PUSH
4446: EMPTY
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 14
4454: PUSH
4455: LD_INT 1
4457: PUSH
4458: LD_INT 2
4460: PUSH
4461: LD_INT 27
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: LD_INT 14
4472: PUSH
4473: LD_INT 1
4475: PUSH
4476: LD_INT 2
4478: PUSH
4479: LD_INT 28
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 14
4490: PUSH
4491: LD_INT 1
4493: PUSH
4494: LD_INT 2
4496: PUSH
4497: LD_INT 26
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: EMPTY
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PPUSH
4514: CALL 76611 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4518: LD_INT 2
4520: PPUSH
4521: LD_INT 11
4523: PPUSH
4524: LD_INT 7
4526: PPUSH
4527: LD_INT 2
4529: PPUSH
4530: LD_INT 23
4532: PUSH
4533: LD_INT 16
4535: PUSH
4536: LD_INT 17
4538: PUSH
4539: LD_INT 18
4541: PUSH
4542: LD_INT 22
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: PPUSH
4552: CALL 77558 0 5
// end ;
4556: LD_VAR 0 1
4560: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4561: LD_EXP 3
4565: PUSH
4566: LD_INT 15
4568: PPUSH
4569: LD_INT 81
4571: PUSH
4572: LD_INT 2
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PPUSH
4579: CALL_OW 70
4583: AND
4584: IFFALSE 4797
4586: GO 4588
4588: DISABLE
4589: LD_INT 0
4591: PPUSH
4592: PPUSH
4593: PPUSH
4594: PPUSH
4595: PPUSH
// begin enable ;
4596: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4597: LD_ADDR_VAR 0 3
4601: PUSH
4602: LD_INT 15
4604: PPUSH
4605: LD_INT 81
4607: PUSH
4608: LD_INT 2
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PPUSH
4615: CALL_OW 70
4619: ST_TO_ADDR
// if not tmp then
4620: LD_VAR 0 3
4624: NOT
4625: IFFALSE 4629
// exit ;
4627: GO 4797
// for i in tmp do
4629: LD_ADDR_VAR 0 1
4633: PUSH
4634: LD_VAR 0 3
4638: PUSH
4639: FOR_IN
4640: IFFALSE 4795
// begin x := GetX ( i ) ;
4642: LD_ADDR_VAR 0 4
4646: PUSH
4647: LD_VAR 0 1
4651: PPUSH
4652: CALL_OW 250
4656: ST_TO_ADDR
// y := GetY ( i ) ;
4657: LD_ADDR_VAR 0 5
4661: PUSH
4662: LD_VAR 0 1
4666: PPUSH
4667: CALL_OW 251
4671: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4672: LD_VAR 0 4
4676: PPUSH
4677: LD_VAR 0 5
4681: PPUSH
4682: CALL_OW 458
4686: IFFALSE 4793
// begin LaunchMineAtPos ( x , y , 2 ) ;
4688: LD_VAR 0 4
4692: PPUSH
4693: LD_VAR 0 5
4697: PPUSH
4698: LD_INT 2
4700: PPUSH
4701: CALL_OW 456
// for j = 1 to staticMines do
4705: LD_ADDR_VAR 0 2
4709: PUSH
4710: DOUBLE
4711: LD_INT 1
4713: DEC
4714: ST_TO_ADDR
4715: LD_EXP 3
4719: PUSH
4720: FOR_TO
4721: IFFALSE 4791
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4723: LD_EXP 3
4727: PUSH
4728: LD_VAR 0 2
4732: ARRAY
4733: PUSH
4734: LD_INT 1
4736: ARRAY
4737: PUSH
4738: LD_VAR 0 4
4742: EQUAL
4743: PUSH
4744: LD_EXP 3
4748: PUSH
4749: LD_VAR 0 2
4753: ARRAY
4754: PUSH
4755: LD_INT 2
4757: ARRAY
4758: PUSH
4759: LD_VAR 0 5
4763: EQUAL
4764: AND
4765: IFFALSE 4789
// begin staticMines := Delete ( staticMines , j ) ;
4767: LD_ADDR_EXP 3
4771: PUSH
4772: LD_EXP 3
4776: PPUSH
4777: LD_VAR 0 2
4781: PPUSH
4782: CALL_OW 3
4786: ST_TO_ADDR
// break ;
4787: GO 4791
// end ;
4789: GO 4720
4791: POP
4792: POP
// end ; end ;
4793: GO 4639
4795: POP
4796: POP
// end ;
4797: PPOPN 5
4799: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4800: LD_INT 7
4802: PPUSH
4803: CALL_OW 302
4807: PUSH
4808: LD_EXP 4
4812: NOT
4813: AND
4814: IFFALSE 5414
4816: GO 4818
4818: DISABLE
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
// begin enable ;
4826: ENABLE
// base := 2 ;
4827: LD_ADDR_VAR 0 2
4831: PUSH
4832: LD_INT 2
4834: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4835: LD_ADDR_VAR 0 3
4839: PUSH
4840: LD_INT 14
4842: PUSH
4843: LD_INT 1
4845: PUSH
4846: LD_INT 2
4848: PUSH
4849: LD_INT 27
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 14
4860: PUSH
4861: LD_INT 1
4863: PUSH
4864: LD_INT 2
4866: PUSH
4867: LD_INT 27
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 14
4878: PUSH
4879: LD_INT 1
4881: PUSH
4882: LD_INT 2
4884: PUSH
4885: LD_INT 92
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 14
4896: PUSH
4897: LD_INT 1
4899: PUSH
4900: LD_INT 2
4902: PUSH
4903: LD_INT 26
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: LIST
4917: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4918: LD_ADDR_VAR 0 5
4922: PUSH
4923: LD_VAR 0 5
4927: PUSH
4928: LD_OWVAR 1
4932: PUSH
4933: LD_INT 21000
4935: DIV
4936: PLUS
4937: ST_TO_ADDR
// if amount > 8 then
4938: LD_VAR 0 5
4942: PUSH
4943: LD_INT 8
4945: GREATER
4946: IFFALSE 4956
// amount := 8 ;
4948: LD_ADDR_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: ST_TO_ADDR
// for i = 1 to amount do
4956: LD_ADDR_VAR 0 1
4960: PUSH
4961: DOUBLE
4962: LD_INT 1
4964: DEC
4965: ST_TO_ADDR
4966: LD_VAR 0 5
4970: PUSH
4971: FOR_TO
4972: IFFALSE 5060
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4974: LD_ADDR_VAR 0 3
4978: PUSH
4979: LD_VAR 0 3
4983: PPUSH
4984: LD_VAR 0 3
4988: PUSH
4989: LD_INT 1
4991: PLUS
4992: PPUSH
4993: LD_INT 14
4995: PUSH
4996: LD_INT 13
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 1
5005: PPUSH
5006: LD_INT 2
5008: PPUSH
5009: CALL_OW 12
5013: ARRAY
5014: PUSH
5015: LD_INT 1
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: LD_INT 28
5023: PUSH
5024: LD_INT 25
5026: PUSH
5027: LD_INT 27
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: PUSH
5035: LD_INT 1
5037: PPUSH
5038: LD_INT 3
5040: PPUSH
5041: CALL_OW 12
5045: ARRAY
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 2
5057: ST_TO_ADDR
5058: GO 4971
5060: POP
5061: POP
// MC_InsertProduceList ( base , tmp ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_VAR 0 3
5071: PPUSH
5072: CALL 76659 0 2
// repeat wait ( 0 0$1 ) ;
5076: LD_INT 35
5078: PPUSH
5079: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5083: LD_VAR 0 2
5087: PPUSH
5088: LD_INT 1
5090: PPUSH
5091: CALL 78077 0 2
5095: PUSH
5096: LD_VAR 0 5
5100: GREATEREQUAL
5101: IFFALSE 5076
// wait ( 0 0$30 ) ;
5103: LD_INT 1050
5105: PPUSH
5106: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5110: LD_ADDR_VAR 0 4
5114: PUSH
5115: LD_EXP 42
5119: PUSH
5120: LD_VAR 0 2
5124: ARRAY
5125: PUSH
5126: LD_EXP 42
5130: PUSH
5131: LD_VAR 0 2
5135: ARRAY
5136: PPUSH
5137: LD_INT 2
5139: PUSH
5140: LD_INT 34
5142: PUSH
5143: LD_INT 31
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 32
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 88
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PPUSH
5176: CALL_OW 72
5180: DIFF
5181: ST_TO_ADDR
// if not attackers then
5182: LD_VAR 0 4
5186: NOT
5187: IFFALSE 5191
// exit ;
5189: GO 5414
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5191: LD_ADDR_EXP 42
5195: PUSH
5196: LD_EXP 42
5200: PPUSH
5201: LD_VAR 0 2
5205: PPUSH
5206: LD_EXP 42
5210: PUSH
5211: LD_VAR 0 2
5215: ARRAY
5216: PUSH
5217: LD_VAR 0 4
5221: DIFF
5222: PPUSH
5223: CALL_OW 1
5227: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5228: LD_VAR 0 4
5232: PPUSH
5233: LD_INT 107
5235: PPUSH
5236: LD_INT 74
5238: PPUSH
5239: CALL_OW 114
// wait ( 0 0$5 ) ;
5243: LD_INT 175
5245: PPUSH
5246: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5250: LD_INT 35
5252: PPUSH
5253: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5257: LD_VAR 0 4
5261: PPUSH
5262: LD_INT 60
5264: PUSH
5265: EMPTY
5266: LIST
5267: PPUSH
5268: CALL_OW 72
5272: NOT
5273: IFFALSE 5250
// if rand ( 0 , 1 ) then
5275: LD_INT 0
5277: PPUSH
5278: LD_INT 1
5280: PPUSH
5281: CALL_OW 12
5285: IFFALSE 5304
// ComAgressiveMove ( attackers , 155 , 108 ) else
5287: LD_VAR 0 4
5291: PPUSH
5292: LD_INT 155
5294: PPUSH
5295: LD_INT 108
5297: PPUSH
5298: CALL_OW 114
5302: GO 5319
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5304: LD_VAR 0 4
5308: PPUSH
5309: LD_INT 149
5311: PPUSH
5312: LD_INT 55
5314: PPUSH
5315: CALL_OW 114
// wait ( 0 0$10 ) ;
5319: LD_INT 350
5321: PPUSH
5322: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5326: LD_INT 35
5328: PPUSH
5329: CALL_OW 67
// for i in attackers do
5333: LD_ADDR_VAR 0 1
5337: PUSH
5338: LD_VAR 0 4
5342: PUSH
5343: FOR_IN
5344: IFFALSE 5394
// if not HasTask ( i ) then
5346: LD_VAR 0 1
5350: PPUSH
5351: CALL_OW 314
5355: NOT
5356: IFFALSE 5392
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5358: LD_VAR 0 1
5362: PPUSH
5363: LD_INT 81
5365: PUSH
5366: LD_INT 2
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PPUSH
5373: CALL_OW 69
5377: PPUSH
5378: LD_VAR 0 1
5382: PPUSH
5383: CALL_OW 74
5387: PPUSH
5388: CALL_OW 115
5392: GO 5343
5394: POP
5395: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5396: LD_VAR 0 4
5400: PPUSH
5401: LD_INT 50
5403: PUSH
5404: EMPTY
5405: LIST
5406: PPUSH
5407: CALL_OW 72
5411: NOT
5412: IFFALSE 5326
// end ;
5414: PPOPN 5
5416: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5417: LD_EXP 4
5421: NOT
5422: PUSH
5423: LD_OWVAR 1
5427: PUSH
5428: LD_INT 191100
5430: LESS
5431: AND
5432: IFFALSE 6104
5434: GO 5436
5436: DISABLE
5437: LD_INT 0
5439: PPUSH
5440: PPUSH
5441: PPUSH
// begin enable ;
5442: ENABLE
// tmp := [ ] ;
5443: LD_ADDR_VAR 0 3
5447: PUSH
5448: EMPTY
5449: ST_TO_ADDR
// if tick < 35 35$00 then
5450: LD_OWVAR 1
5454: PUSH
5455: LD_INT 73500
5457: LESS
5458: IFFALSE 5656
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5460: LD_ADDR_VAR 0 1
5464: PUSH
5465: DOUBLE
5466: LD_INT 1
5468: DEC
5469: ST_TO_ADDR
5470: LD_INT 4
5472: PUSH
5473: LD_INT 5
5475: PUSH
5476: LD_INT 5
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: LIST
5483: PUSH
5484: LD_OWVAR 67
5488: ARRAY
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5652
// begin uc_side := 2 ;
5493: LD_ADDR_OWVAR 20
5497: PUSH
5498: LD_INT 2
5500: ST_TO_ADDR
// uc_nation := 2 ;
5501: LD_ADDR_OWVAR 21
5505: PUSH
5506: LD_INT 2
5508: ST_TO_ADDR
// InitHC_All ( ) ;
5509: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5513: LD_INT 0
5515: PPUSH
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 5
5521: PUSH
5522: LD_INT 6
5524: PUSH
5525: LD_INT 7
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_OWVAR 67
5537: ARRAY
5538: PPUSH
5539: CALL_OW 380
// un := CreateHuman ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL_OW 44
5552: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5553: LD_VAR 0 2
5557: PPUSH
5558: LD_INT 17
5560: PPUSH
5561: LD_INT 0
5563: PPUSH
5564: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5568: LD_VAR 0 2
5572: PPUSH
5573: LD_INT 1
5575: PUSH
5576: LD_INT 8
5578: PUSH
5579: EMPTY
5580: LIST
5581: LIST
5582: PUSH
5583: LD_INT 1
5585: PPUSH
5586: LD_INT 2
5588: PPUSH
5589: CALL_OW 12
5593: ARRAY
5594: PPUSH
5595: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5599: LD_VAR 0 2
5603: PPUSH
5604: LD_INT 111
5606: PPUSH
5607: LD_INT 34
5609: PPUSH
5610: CALL_OW 114
// wait ( 0 0$2 ) ;
5614: LD_INT 70
5616: PPUSH
5617: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5621: LD_ADDR_VAR 0 3
5625: PUSH
5626: LD_VAR 0 3
5630: PPUSH
5631: LD_VAR 0 3
5635: PUSH
5636: LD_INT 1
5638: PLUS
5639: PPUSH
5640: LD_VAR 0 2
5644: PPUSH
5645: CALL_OW 1
5649: ST_TO_ADDR
// end ;
5650: GO 5490
5652: POP
5653: POP
// end else
5654: GO 5797
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5656: LD_ADDR_VAR 0 1
5660: PUSH
5661: DOUBLE
5662: LD_INT 1
5664: DEC
5665: ST_TO_ADDR
5666: LD_INT 4
5668: PUSH
5669: LD_INT 5
5671: PUSH
5672: LD_INT 5
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: PUSH
5680: LD_OWVAR 67
5684: ARRAY
5685: PUSH
5686: FOR_TO
5687: IFFALSE 5795
// begin uc_side := 2 ;
5689: LD_ADDR_OWVAR 20
5693: PUSH
5694: LD_INT 2
5696: ST_TO_ADDR
// uc_nation := 0 ;
5697: LD_ADDR_OWVAR 21
5701: PUSH
5702: LD_INT 0
5704: ST_TO_ADDR
// InitHC_All ( ) ;
5705: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5709: LD_ADDR_OWVAR 28
5713: PUSH
5714: LD_INT 17
5716: ST_TO_ADDR
// un := CreateHuman ;
5717: LD_ADDR_VAR 0 2
5721: PUSH
5722: CALL_OW 44
5726: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5727: LD_VAR 0 2
5731: PPUSH
5732: LD_INT 17
5734: PPUSH
5735: LD_INT 0
5737: PPUSH
5738: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5742: LD_VAR 0 2
5746: PPUSH
5747: LD_INT 110
5749: PPUSH
5750: LD_INT 33
5752: PPUSH
5753: CALL_OW 114
// wait ( 0 0$2 ) ;
5757: LD_INT 70
5759: PPUSH
5760: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5764: LD_ADDR_VAR 0 3
5768: PUSH
5769: LD_VAR 0 3
5773: PPUSH
5774: LD_VAR 0 3
5778: PUSH
5779: LD_INT 1
5781: PLUS
5782: PPUSH
5783: LD_VAR 0 2
5787: PPUSH
5788: CALL_OW 1
5792: ST_TO_ADDR
// end ;
5793: GO 5686
5795: POP
5796: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5797: LD_ADDR_VAR 0 1
5801: PUSH
5802: DOUBLE
5803: LD_INT 1
5805: DEC
5806: ST_TO_ADDR
5807: LD_INT 3
5809: PUSH
5810: LD_INT 4
5812: PUSH
5813: LD_INT 5
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: LIST
5820: PUSH
5821: LD_OWVAR 67
5825: ARRAY
5826: PUSH
5827: FOR_TO
5828: IFFALSE 5993
// begin uc_side := 2 ;
5830: LD_ADDR_OWVAR 20
5834: PUSH
5835: LD_INT 2
5837: ST_TO_ADDR
// uc_nation := 2 ;
5838: LD_ADDR_OWVAR 21
5842: PUSH
5843: LD_INT 2
5845: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5846: LD_INT 14
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: LD_INT 5
5854: PPUSH
5855: LD_INT 29
5857: PUSH
5858: LD_INT 28
5860: PUSH
5861: LD_INT 27
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 1
5871: PPUSH
5872: LD_INT 3
5874: PPUSH
5875: CALL_OW 12
5879: ARRAY
5880: PPUSH
5881: LD_INT 90
5883: PPUSH
5884: CALL 16030 0 5
// un := CreateVehicle ;
5888: LD_ADDR_VAR 0 2
5892: PUSH
5893: CALL_OW 45
5897: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5898: LD_VAR 0 2
5902: PPUSH
5903: LD_INT 2
5905: PPUSH
5906: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 17
5917: PPUSH
5918: LD_INT 0
5920: PPUSH
5921: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5925: LD_VAR 0 2
5929: PPUSH
5930: LD_INT 66
5932: PPUSH
5933: LD_INT 23
5935: PPUSH
5936: CALL_OW 111
// wait ( 0 0$3 ) ;
5940: LD_INT 105
5942: PPUSH
5943: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5947: LD_VAR 0 2
5951: PPUSH
5952: LD_INT 147
5954: PPUSH
5955: LD_INT 103
5957: PPUSH
5958: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5962: LD_ADDR_VAR 0 3
5966: PUSH
5967: LD_VAR 0 3
5971: PPUSH
5972: LD_VAR 0 3
5976: PUSH
5977: LD_INT 1
5979: PLUS
5980: PPUSH
5981: LD_VAR 0 2
5985: PPUSH
5986: CALL_OW 1
5990: ST_TO_ADDR
// end ;
5991: GO 5827
5993: POP
5994: POP
// if not tmp then
5995: LD_VAR 0 3
5999: NOT
6000: IFFALSE 6004
// exit ;
6002: GO 6104
// wait ( 0 0$5 ) ;
6004: LD_INT 175
6006: PPUSH
6007: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6011: LD_INT 70
6013: PPUSH
6014: CALL_OW 67
// for i in tmp do
6018: LD_ADDR_VAR 0 1
6022: PUSH
6023: LD_VAR 0 3
6027: PUSH
6028: FOR_IN
6029: IFFALSE 6095
// begin if not IsOk ( i ) then
6031: LD_VAR 0 1
6035: PPUSH
6036: CALL_OW 302
6040: NOT
6041: IFFALSE 6059
// tmp := tmp diff i ;
6043: LD_ADDR_VAR 0 3
6047: PUSH
6048: LD_VAR 0 3
6052: PUSH
6053: LD_VAR 0 1
6057: DIFF
6058: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6059: LD_VAR 0 1
6063: PPUSH
6064: LD_INT 81
6066: PUSH
6067: LD_INT 2
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PPUSH
6074: CALL_OW 69
6078: PPUSH
6079: LD_VAR 0 1
6083: PPUSH
6084: CALL_OW 74
6088: PPUSH
6089: CALL_OW 115
// end ;
6093: GO 6028
6095: POP
6096: POP
// until not tmp ;
6097: LD_VAR 0 3
6101: NOT
6102: IFFALSE 6011
// end ;
6104: PPOPN 3
6106: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6107: LD_OWVAR 67
6111: PUSH
6112: LD_INT 1
6114: GREATER
6115: IFFALSE 6213
6117: GO 6119
6119: DISABLE
6120: LD_INT 0
6122: PPUSH
// begin uc_side := 2 ;
6123: LD_ADDR_OWVAR 20
6127: PUSH
6128: LD_INT 2
6130: ST_TO_ADDR
// uc_nation := 2 ;
6131: LD_ADDR_OWVAR 21
6135: PUSH
6136: LD_INT 2
6138: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6139: LD_INT 0
6141: PPUSH
6142: LD_INT 4
6144: PPUSH
6145: LD_INT 6
6147: PPUSH
6148: CALL_OW 380
// un := CreateHuman ;
6152: LD_ADDR_VAR 0 1
6156: PUSH
6157: CALL_OW 44
6161: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6162: LD_VAR 0 1
6166: PPUSH
6167: LD_INT 88
6169: PPUSH
6170: LD_INT 1
6172: PPUSH
6173: LD_INT 2
6175: PPUSH
6176: LD_INT 0
6178: PPUSH
6179: CALL 50604 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6183: LD_VAR 0 1
6187: PPUSH
6188: LD_INT 130
6190: PPUSH
6191: LD_INT 35
6193: PPUSH
6194: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 132
6205: PPUSH
6206: LD_INT 39
6208: PPUSH
6209: CALL_OW 218
// end ;
6213: PPOPN 1
6215: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6216: LD_INT 22
6218: PUSH
6219: LD_INT 2
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 33
6228: PUSH
6229: LD_INT 2
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 50
6238: PUSH
6239: EMPTY
6240: LIST
6241: PUSH
6242: LD_INT 3
6244: PUSH
6245: LD_INT 61
6247: PUSH
6248: EMPTY
6249: LIST
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: LIST
6259: LIST
6260: PPUSH
6261: CALL_OW 69
6265: IFFALSE 6356
6267: GO 6269
6269: DISABLE
6270: LD_INT 0
6272: PPUSH
6273: PPUSH
// begin enable ;
6274: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6275: LD_ADDR_VAR 0 2
6279: PUSH
6280: LD_INT 22
6282: PUSH
6283: LD_INT 2
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 33
6292: PUSH
6293: LD_INT 2
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 50
6302: PUSH
6303: EMPTY
6304: LIST
6305: PUSH
6306: LD_INT 3
6308: PUSH
6309: LD_INT 61
6311: PUSH
6312: EMPTY
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 69
6329: ST_TO_ADDR
// for i in tmp do
6330: LD_ADDR_VAR 0 1
6334: PUSH
6335: LD_VAR 0 2
6339: PUSH
6340: FOR_IN
6341: IFFALSE 6354
// Connect ( i ) ;
6343: LD_VAR 0 1
6347: PPUSH
6348: CALL 19121 0 1
6352: GO 6340
6354: POP
6355: POP
// end ; end_of_file
6356: PPOPN 2
6358: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
6364: PPUSH
6365: PPUSH
6366: PPUSH
// popov_side := 3 ;
6367: LD_ADDR_EXP 17
6371: PUSH
6372: LD_INT 3
6374: ST_TO_ADDR
// uc_side := popov_side ;
6375: LD_ADDR_OWVAR 20
6379: PUSH
6380: LD_EXP 17
6384: ST_TO_ADDR
// uc_nation := 3 ;
6385: LD_ADDR_OWVAR 21
6389: PUSH
6390: LD_INT 3
6392: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6393: LD_ADDR_VAR 0 6
6397: PUSH
6398: LD_INT 5
6400: PUSH
6401: LD_INT 103
6403: PUSH
6404: LD_INT 147
6406: PUSH
6407: LD_INT 3
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: PUSH
6416: LD_INT 5
6418: PUSH
6419: LD_INT 70
6421: PUSH
6422: LD_INT 117
6424: PUSH
6425: LD_INT 3
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: LD_INT 76
6439: PUSH
6440: LD_INT 145
6442: PUSH
6443: LD_INT 1
6445: PUSH
6446: LD_INT 10
6448: PUSH
6449: LD_INT 11
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 26
6462: PUSH
6463: LD_INT 87
6465: PUSH
6466: LD_INT 144
6468: PUSH
6469: LD_INT 0
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_INT 29
6480: PUSH
6481: LD_INT 86
6483: PUSH
6484: LD_INT 118
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: LD_INT 29
6498: PUSH
6499: LD_INT 98
6501: PUSH
6502: LD_INT 121
6504: PUSH
6505: LD_INT 0
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 26
6516: PUSH
6517: LD_INT 87
6519: PUSH
6520: LD_INT 147
6522: PUSH
6523: LD_INT 1
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 30
6534: PUSH
6535: LD_INT 123
6537: PUSH
6538: LD_INT 151
6540: PUSH
6541: LD_INT 1
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 94
6555: PUSH
6556: LD_INT 161
6558: PUSH
6559: LD_INT 0
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: LIST
6566: LIST
6567: PUSH
6568: LD_INT 6
6570: PUSH
6571: LD_INT 81
6573: PUSH
6574: LD_INT 155
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: LD_INT 12
6582: PUSH
6583: LD_INT 14
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: LIST
6592: LIST
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 96
6599: PUSH
6600: LD_INT 152
6602: PUSH
6603: LD_INT 0
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 26
6614: PUSH
6615: LD_INT 96
6617: PUSH
6618: LD_INT 149
6620: PUSH
6621: LD_INT 3
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: PUSH
6630: LD_INT 32
6632: PUSH
6633: LD_INT 109
6635: PUSH
6636: LD_INT 142
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 46
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 32
6654: PUSH
6655: LD_INT 112
6657: PUSH
6658: LD_INT 148
6660: PUSH
6661: LD_INT 3
6663: PUSH
6664: LD_INT 46
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 33
6676: PUSH
6677: LD_INT 120
6679: PUSH
6680: LD_INT 159
6682: PUSH
6683: LD_INT 4
6685: PUSH
6686: LD_INT 45
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: LIST
6695: PUSH
6696: LD_INT 33
6698: PUSH
6699: LD_INT 122
6701: PUSH
6702: LD_INT 163
6704: PUSH
6705: LD_INT 4
6707: PUSH
6708: LD_INT 45
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: PUSH
6718: LD_INT 33
6720: PUSH
6721: LD_INT 123
6723: PUSH
6724: LD_INT 167
6726: PUSH
6727: LD_INT 4
6729: PUSH
6730: LD_INT 45
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: LIST
6738: LIST
6739: PUSH
6740: LD_INT 33
6742: PUSH
6743: LD_INT 59
6745: PUSH
6746: LD_INT 111
6748: PUSH
6749: LD_INT 3
6751: PUSH
6752: LD_INT 45
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_INT 33
6764: PUSH
6765: LD_INT 65
6767: PUSH
6768: LD_INT 111
6770: PUSH
6771: LD_INT 3
6773: PUSH
6774: LD_INT 46
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 33
6786: PUSH
6787: LD_INT 76
6789: PUSH
6790: LD_INT 117
6792: PUSH
6793: LD_INT 3
6795: PUSH
6796: LD_INT 45
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: LIST
6805: PUSH
6806: LD_INT 33
6808: PUSH
6809: LD_INT 80
6811: PUSH
6812: LD_INT 119
6814: PUSH
6815: LD_INT 3
6817: PUSH
6818: LD_INT 46
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: LIST
6827: PUSH
6828: LD_INT 33
6830: PUSH
6831: LD_INT 87
6833: PUSH
6834: LD_INT 125
6836: PUSH
6837: LD_INT 3
6839: PUSH
6840: LD_INT 45
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: LIST
6847: LIST
6848: LIST
6849: PUSH
6850: LD_INT 5
6852: PUSH
6853: LD_INT 92
6855: PUSH
6856: LD_INT 129
6858: PUSH
6859: LD_INT 3
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: LIST
6866: LIST
6867: PUSH
6868: LD_INT 28
6870: PUSH
6871: LD_INT 85
6873: PUSH
6874: LD_INT 165
6876: PUSH
6877: LD_INT 0
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: LIST
6884: LIST
6885: PUSH
6886: LD_INT 28
6888: PUSH
6889: LD_INT 83
6891: PUSH
6892: LD_INT 161
6894: PUSH
6895: LD_INT 4
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 28
6906: PUSH
6907: LD_INT 91
6909: PUSH
6910: LD_INT 166
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: PUSH
6922: LD_INT 28
6924: PUSH
6925: LD_INT 102
6927: PUSH
6928: LD_INT 166
6930: PUSH
6931: LD_INT 2
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: LIST
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: LIST
6945: LIST
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: ST_TO_ADDR
// for i in list do
6969: LD_ADDR_VAR 0 2
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: FOR_IN
6980: IFFALSE 7158
// begin uc_side := 3 ;
6982: LD_ADDR_OWVAR 20
6986: PUSH
6987: LD_INT 3
6989: ST_TO_ADDR
// uc_nation := 3 ;
6990: LD_ADDR_OWVAR 21
6994: PUSH
6995: LD_INT 3
6997: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6998: LD_ADDR_OWVAR 42
7002: PUSH
7003: LD_VAR 0 2
7007: PUSH
7008: LD_INT 1
7010: ARRAY
7011: ST_TO_ADDR
// bc_kind1 := - 1 ;
7012: LD_ADDR_OWVAR 44
7016: PUSH
7017: LD_INT 1
7019: NEG
7020: ST_TO_ADDR
// bc_kind2 := - 1 ;
7021: LD_ADDR_OWVAR 45
7025: PUSH
7026: LD_INT 1
7028: NEG
7029: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7030: LD_VAR 0 2
7034: PUSH
7035: LD_INT 1
7037: ARRAY
7038: PUSH
7039: LD_INT 6
7041: EQUAL
7042: IFFALSE 7080
// begin bc_type := b_lab_full ;
7044: LD_ADDR_OWVAR 42
7048: PUSH
7049: LD_INT 8
7051: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7052: LD_ADDR_OWVAR 44
7056: PUSH
7057: LD_VAR 0 2
7061: PUSH
7062: LD_INT 5
7064: ARRAY
7065: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7066: LD_ADDR_OWVAR 45
7070: PUSH
7071: LD_VAR 0 2
7075: PUSH
7076: LD_INT 6
7078: ARRAY
7079: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7080: LD_ADDR_VAR 0 5
7084: PUSH
7085: LD_VAR 0 2
7089: PUSH
7090: LD_INT 2
7092: ARRAY
7093: PPUSH
7094: LD_VAR 0 2
7098: PUSH
7099: LD_INT 3
7101: ARRAY
7102: PPUSH
7103: LD_VAR 0 2
7107: PUSH
7108: LD_INT 4
7110: ARRAY
7111: PPUSH
7112: CALL_OW 47
7116: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7117: LD_VAR 0 2
7121: PUSH
7122: LD_INT 1
7124: ARRAY
7125: PUSH
7126: LD_INT 33
7128: PUSH
7129: LD_INT 32
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: IN
7136: IFFALSE 7156
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7138: LD_VAR 0 5
7142: PPUSH
7143: LD_VAR 0 2
7147: PUSH
7148: LD_INT 5
7150: ARRAY
7151: PPUSH
7152: CALL_OW 431
// end ;
7156: GO 6979
7158: POP
7159: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7160: LD_ADDR_VAR 0 4
7164: PUSH
7165: LD_INT 9
7167: PPUSH
7168: LD_INT 3
7170: PPUSH
7171: LD_STRING 
7173: PPUSH
7174: LD_INT 8
7176: PUSH
7177: LD_INT 7
7179: PUSH
7180: LD_INT 6
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: LIST
7187: PUSH
7188: LD_OWVAR 67
7192: ARRAY
7193: PPUSH
7194: LD_INT 11500
7196: PUSH
7197: LD_INT 1100
7199: PUSH
7200: LD_INT 60
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_INT 6
7210: PUSH
7211: LD_INT 6
7213: PUSH
7214: LD_INT 6
7216: PUSH
7217: LD_INT 6
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: PPUSH
7226: CALL 19474 0 6
7230: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7231: LD_ADDR_EXP 23
7235: PUSH
7236: LD_EXP 23
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: LD_VAR 0 4
7248: PUSH
7249: LD_INT 22
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: LD_INT 21
7261: PUSH
7262: LD_INT 3
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: UNION
7278: PPUSH
7279: CALL_OW 1
7283: ST_TO_ADDR
// extraPopovForces := [ ] ;
7284: LD_ADDR_EXP 18
7288: PUSH
7289: EMPTY
7290: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7291: LD_ADDR_VAR 0 2
7295: PUSH
7296: DOUBLE
7297: LD_INT 1
7299: DEC
7300: ST_TO_ADDR
7301: LD_INT 8
7303: PUSH
7304: LD_INT 9
7306: PUSH
7307: LD_INT 10
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_OWVAR 67
7319: ARRAY
7320: PUSH
7321: FOR_TO
7322: IFFALSE 7451
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7324: LD_INT 0
7326: PPUSH
7327: LD_INT 1
7329: PPUSH
7330: LD_INT 4
7332: PUSH
7333: LD_INT 5
7335: PUSH
7336: LD_INT 6
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: PUSH
7344: LD_OWVAR 67
7348: ARRAY
7349: PPUSH
7350: CALL_OW 380
// un := CreateHuman ;
7354: LD_ADDR_VAR 0 3
7358: PUSH
7359: CALL_OW 44
7363: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7364: LD_INT 0
7366: PPUSH
7367: LD_INT 1
7369: PPUSH
7370: CALL_OW 12
7374: IFFALSE 7399
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7376: LD_VAR 0 3
7380: PPUSH
7381: LD_INT 131
7383: PPUSH
7384: LD_INT 110
7386: PPUSH
7387: LD_INT 8
7389: PPUSH
7390: LD_INT 0
7392: PPUSH
7393: CALL_OW 50
7397: GO 7420
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7399: LD_VAR 0 3
7403: PPUSH
7404: LD_INT 100
7406: PPUSH
7407: LD_INT 99
7409: PPUSH
7410: LD_INT 8
7412: PPUSH
7413: LD_INT 0
7415: PPUSH
7416: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7420: LD_ADDR_EXP 18
7424: PUSH
7425: LD_EXP 18
7429: PPUSH
7430: LD_EXP 18
7434: PUSH
7435: LD_INT 1
7437: PLUS
7438: PPUSH
7439: LD_VAR 0 3
7443: PPUSH
7444: CALL_OW 1
7448: ST_TO_ADDR
// end ;
7449: GO 7321
7451: POP
7452: POP
// PrepareSoldier ( false , 6 ) ;
7453: LD_INT 0
7455: PPUSH
7456: LD_INT 6
7458: PPUSH
7459: CALL_OW 381
// un := CreateHuman ;
7463: LD_ADDR_VAR 0 3
7467: PUSH
7468: CALL_OW 44
7472: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7473: LD_VAR 0 3
7477: PPUSH
7478: LD_INT 1
7480: PPUSH
7481: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 150
7492: PPUSH
7493: LD_INT 158
7495: PPUSH
7496: CALL_OW 428
7500: PPUSH
7501: CALL_OW 52
// popovAttackGroup := [ ] ;
7505: LD_ADDR_EXP 19
7509: PUSH
7510: EMPTY
7511: ST_TO_ADDR
// end ;
7512: LD_VAR 0 1
7516: RET
// export function InitMC_Popov ( ) ; begin
7517: LD_INT 0
7519: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7520: LD_INT 3
7522: PPUSH
7523: LD_INT 3
7525: PPUSH
7526: CALL 77932 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7530: LD_INT 3
7532: PPUSH
7533: LD_INT 10
7535: PPUSH
7536: CALL 77876 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7540: LD_INT 3
7542: PPUSH
7543: LD_INT 86
7545: PUSH
7546: LD_INT 118
7548: PUSH
7549: LD_INT 0
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 123
7559: PUSH
7560: LD_INT 151
7562: PUSH
7563: LD_INT 1
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 98
7573: PUSH
7574: LD_INT 121
7576: PUSH
7577: LD_INT 0
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: LIST
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PPUSH
7590: CALL 76935 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7594: LD_INT 3
7596: PPUSH
7597: LD_INT 46
7599: PUSH
7600: LD_INT 45
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL 77764 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7611: LD_INT 3
7613: PPUSH
7614: LD_INT 12
7616: PPUSH
7617: CALL 77446 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 11
7626: PPUSH
7627: CALL 77177 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7631: LD_INT 3
7633: PPUSH
7634: LD_INT 4
7636: PPUSH
7637: CALL 76796 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7641: LD_INT 3
7643: PPUSH
7644: LD_INT 23
7646: PUSH
7647: LD_INT 1
7649: PUSH
7650: LD_INT 3
7652: PUSH
7653: LD_INT 44
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 23
7664: PUSH
7665: LD_INT 1
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: LD_INT 45
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 21
7682: PUSH
7683: LD_INT 1
7685: PUSH
7686: LD_INT 3
7688: PUSH
7689: LD_INT 44
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 21
7700: PUSH
7701: LD_INT 1
7703: PUSH
7704: LD_INT 3
7706: PUSH
7707: LD_INT 45
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: PPUSH
7722: CALL 76611 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7726: LD_INT 3
7728: PPUSH
7729: LD_INT 94
7731: PPUSH
7732: LD_INT 161
7734: PPUSH
7735: LD_INT 0
7737: PPUSH
7738: LD_INT 19
7740: PUSH
7741: LD_INT 17
7743: PUSH
7744: LD_INT 18
7746: PUSH
7747: LD_INT 24
7749: PUSH
7750: LD_INT 21
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: PPUSH
7760: CALL 77558 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7764: LD_INT 3
7766: PPUSH
7767: LD_INT 21
7769: PUSH
7770: LD_INT 1
7772: PUSH
7773: LD_INT 3
7775: PUSH
7776: LD_INT 51
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: PPUSH
7788: CALL 76659 0 2
// end ;
7792: LD_VAR 0 1
7796: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7797: LD_EXP 18
7801: PUSH
7802: LD_EXP 5
7806: NOT
7807: AND
7808: IFFALSE 7868
7810: GO 7812
7812: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7813: LD_EXP 18
7817: PPUSH
7818: LD_INT 106
7820: PPUSH
7821: LD_INT 137
7823: PPUSH
7824: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7828: LD_ADDR_EXP 23
7832: PUSH
7833: LD_EXP 23
7837: PPUSH
7838: LD_INT 3
7840: PPUSH
7841: LD_EXP 23
7845: PUSH
7846: LD_INT 3
7848: ARRAY
7849: PUSH
7850: LD_EXP 18
7854: UNION
7855: PPUSH
7856: CALL_OW 1
7860: ST_TO_ADDR
// extraPopovForces := [ ] ;
7861: LD_ADDR_EXP 18
7865: PUSH
7866: EMPTY
7867: ST_TO_ADDR
// end ;
7868: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7869: LD_INT 9
7871: PPUSH
7872: CALL_OW 302
7876: PUSH
7877: LD_EXP 5
7881: NOT
7882: AND
7883: IFFALSE 8449
7885: GO 7887
7887: DISABLE
7888: LD_INT 0
7890: PPUSH
7891: PPUSH
7892: PPUSH
7893: PPUSH
7894: PPUSH
// begin enable ;
7895: ENABLE
// base := 3 ;
7896: LD_ADDR_VAR 0 2
7900: PUSH
7901: LD_INT 3
7903: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7904: LD_ADDR_VAR 0 3
7908: PUSH
7909: LD_INT 22
7911: PUSH
7912: LD_INT 1
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 44
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: LIST
7926: PUSH
7927: LD_INT 24
7929: PUSH
7930: LD_INT 1
7932: PUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 46
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 24
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: LD_INT 3
7953: PUSH
7954: LD_INT 46
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 24
7965: PUSH
7966: LD_INT 1
7968: PUSH
7969: LD_INT 3
7971: PUSH
7972: LD_INT 46
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: LIST
7985: LIST
7986: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7987: LD_ADDR_VAR 0 5
7991: PUSH
7992: LD_VAR 0 5
7996: PUSH
7997: LD_OWVAR 1
8001: PUSH
8002: LD_INT 21000
8004: DIV
8005: PLUS
8006: ST_TO_ADDR
// if amount > 8 then
8007: LD_VAR 0 5
8011: PUSH
8012: LD_INT 8
8014: GREATER
8015: IFFALSE 8025
// amount := 8 ;
8017: LD_ADDR_VAR 0 5
8021: PUSH
8022: LD_INT 8
8024: ST_TO_ADDR
// for i = 1 to amount do
8025: LD_ADDR_VAR 0 1
8029: PUSH
8030: DOUBLE
8031: LD_INT 1
8033: DEC
8034: ST_TO_ADDR
8035: LD_VAR 0 5
8039: PUSH
8040: FOR_TO
8041: IFFALSE 8106
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8043: LD_ADDR_VAR 0 3
8047: PUSH
8048: LD_VAR 0 3
8052: PPUSH
8053: LD_VAR 0 3
8057: PUSH
8058: LD_INT 1
8060: PLUS
8061: PPUSH
8062: LD_INT 24
8064: PUSH
8065: LD_INT 1
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: LD_INT 46
8073: PUSH
8074: LD_INT 45
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: PUSH
8081: LD_INT 1
8083: PPUSH
8084: LD_INT 2
8086: PPUSH
8087: CALL_OW 12
8091: ARRAY
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL_OW 2
8103: ST_TO_ADDR
8104: GO 8040
8106: POP
8107: POP
// MC_InsertProduceList ( base , tmp ) ;
8108: LD_VAR 0 2
8112: PPUSH
8113: LD_VAR 0 3
8117: PPUSH
8118: CALL 76659 0 2
// repeat wait ( 0 0$1 ) ;
8122: LD_INT 35
8124: PPUSH
8125: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8129: LD_VAR 0 2
8133: PPUSH
8134: LD_INT 1
8136: PPUSH
8137: CALL 78077 0 2
8141: PUSH
8142: LD_VAR 0 5
8146: GREATEREQUAL
8147: IFFALSE 8122
// wait ( 0 0$30 ) ;
8149: LD_INT 1050
8151: PPUSH
8152: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8156: LD_ADDR_VAR 0 4
8160: PUSH
8161: LD_EXP 42
8165: PUSH
8166: LD_VAR 0 2
8170: ARRAY
8171: PUSH
8172: LD_EXP 42
8176: PUSH
8177: LD_VAR 0 2
8181: ARRAY
8182: PPUSH
8183: LD_INT 2
8185: PUSH
8186: LD_INT 34
8188: PUSH
8189: LD_INT 51
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 34
8198: PUSH
8199: LD_INT 52
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PUSH
8206: EMPTY
8207: LIST
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: DIFF
8216: ST_TO_ADDR
// if not attackers then
8217: LD_VAR 0 4
8221: NOT
8222: IFFALSE 8226
// exit ;
8224: GO 8449
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8226: LD_ADDR_EXP 42
8230: PUSH
8231: LD_EXP 42
8235: PPUSH
8236: LD_VAR 0 2
8240: PPUSH
8241: LD_EXP 42
8245: PUSH
8246: LD_VAR 0 2
8250: ARRAY
8251: PUSH
8252: LD_VAR 0 4
8256: DIFF
8257: PPUSH
8258: CALL_OW 1
8262: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8263: LD_VAR 0 4
8267: PPUSH
8268: LD_INT 107
8270: PPUSH
8271: LD_INT 74
8273: PPUSH
8274: CALL_OW 114
// wait ( 0 0$5 ) ;
8278: LD_INT 175
8280: PPUSH
8281: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8285: LD_INT 35
8287: PPUSH
8288: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8292: LD_VAR 0 4
8296: PPUSH
8297: LD_INT 60
8299: PUSH
8300: EMPTY
8301: LIST
8302: PPUSH
8303: CALL_OW 72
8307: NOT
8308: IFFALSE 8285
// if rand ( 0 , 1 ) then
8310: LD_INT 0
8312: PPUSH
8313: LD_INT 1
8315: PPUSH
8316: CALL_OW 12
8320: IFFALSE 8339
// ComAgressiveMove ( attackers , 155 , 108 ) else
8322: LD_VAR 0 4
8326: PPUSH
8327: LD_INT 155
8329: PPUSH
8330: LD_INT 108
8332: PPUSH
8333: CALL_OW 114
8337: GO 8354
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8339: LD_VAR 0 4
8343: PPUSH
8344: LD_INT 149
8346: PPUSH
8347: LD_INT 55
8349: PPUSH
8350: CALL_OW 114
// wait ( 0 0$10 ) ;
8354: LD_INT 350
8356: PPUSH
8357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8361: LD_INT 35
8363: PPUSH
8364: CALL_OW 67
// for i in attackers do
8368: LD_ADDR_VAR 0 1
8372: PUSH
8373: LD_VAR 0 4
8377: PUSH
8378: FOR_IN
8379: IFFALSE 8429
// if not HasTask ( i ) then
8381: LD_VAR 0 1
8385: PPUSH
8386: CALL_OW 314
8390: NOT
8391: IFFALSE 8427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8393: LD_VAR 0 1
8397: PPUSH
8398: LD_INT 81
8400: PUSH
8401: LD_INT 3
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PPUSH
8408: CALL_OW 69
8412: PPUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 74
8422: PPUSH
8423: CALL_OW 115
8427: GO 8378
8429: POP
8430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8431: LD_VAR 0 4
8435: PPUSH
8436: LD_INT 50
8438: PUSH
8439: EMPTY
8440: LIST
8441: PPUSH
8442: CALL_OW 72
8446: NOT
8447: IFFALSE 8361
// end ;
8449: PPOPN 5
8451: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8452: LD_EXP 5
8456: NOT
8457: IFFALSE 9044
8459: GO 8461
8461: DISABLE
8462: LD_INT 0
8464: PPUSH
8465: PPUSH
8466: PPUSH
8467: PPUSH
// begin enable ;
8468: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8469: LD_OWVAR 67
8473: PUSH
8474: LD_INT 1
8476: EQUAL
8477: PUSH
8478: LD_OWVAR 1
8482: PUSH
8483: LD_INT 63000
8485: LESS
8486: AND
8487: IFFALSE 8491
// exit ;
8489: GO 9044
// tmp := [ ] ;
8491: LD_ADDR_VAR 0 3
8495: PUSH
8496: EMPTY
8497: ST_TO_ADDR
// if tick < 45 45$00 then
8498: LD_OWVAR 1
8502: PUSH
8503: LD_INT 94500
8505: LESS
8506: IFFALSE 8683
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8508: LD_ADDR_VAR 0 1
8512: PUSH
8513: DOUBLE
8514: LD_INT 1
8516: DEC
8517: ST_TO_ADDR
8518: LD_INT 2
8520: PUSH
8521: LD_INT 3
8523: PUSH
8524: LD_INT 4
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: LIST
8531: PUSH
8532: LD_OWVAR 67
8536: ARRAY
8537: PUSH
8538: FOR_TO
8539: IFFALSE 8681
// begin uc_side := 3 ;
8541: LD_ADDR_OWVAR 20
8545: PUSH
8546: LD_INT 3
8548: ST_TO_ADDR
// uc_nation := 3 ;
8549: LD_ADDR_OWVAR 21
8553: PUSH
8554: LD_INT 3
8556: ST_TO_ADDR
// InitHC_All ( ) ;
8557: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8561: LD_INT 0
8563: PPUSH
8564: LD_INT 1
8566: PPUSH
8567: LD_INT 5
8569: PUSH
8570: LD_INT 6
8572: PUSH
8573: LD_INT 7
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: PUSH
8581: LD_OWVAR 67
8585: ARRAY
8586: PPUSH
8587: CALL_OW 380
// un := CreateHuman ;
8591: LD_ADDR_VAR 0 2
8595: PUSH
8596: CALL_OW 44
8600: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8601: LD_VAR 0 2
8605: PPUSH
8606: LD_INT 18
8608: PPUSH
8609: LD_INT 0
8611: PPUSH
8612: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8616: LD_VAR 0 2
8620: PPUSH
8621: LD_INT 9
8623: PPUSH
8624: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 147
8635: PPUSH
8636: LD_INT 161
8638: PPUSH
8639: CALL_OW 111
// wait ( 0 0$2 ) ;
8643: LD_INT 70
8645: PPUSH
8646: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8650: LD_ADDR_VAR 0 3
8654: PUSH
8655: LD_VAR 0 3
8659: PPUSH
8660: LD_VAR 0 3
8664: PUSH
8665: LD_INT 1
8667: PLUS
8668: PPUSH
8669: LD_VAR 0 2
8673: PPUSH
8674: CALL_OW 1
8678: ST_TO_ADDR
// end ;
8679: GO 8538
8681: POP
8682: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8683: LD_ADDR_VAR 0 4
8687: PUSH
8688: LD_INT 3
8690: PUSH
8691: LD_INT 4
8693: PUSH
8694: LD_INT 5
8696: PUSH
8697: EMPTY
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: LD_OWVAR 67
8706: ARRAY
8707: PUSH
8708: LD_OWVAR 1
8712: PUSH
8713: LD_INT 21000
8715: DIV
8716: PLUS
8717: ST_TO_ADDR
// if amount > 15 then
8718: LD_VAR 0 4
8722: PUSH
8723: LD_INT 15
8725: GREATER
8726: IFFALSE 8736
// amount := 15 ;
8728: LD_ADDR_VAR 0 4
8732: PUSH
8733: LD_INT 15
8735: ST_TO_ADDR
// for i := 1 to amount do
8736: LD_ADDR_VAR 0 1
8740: PUSH
8741: DOUBLE
8742: LD_INT 1
8744: DEC
8745: ST_TO_ADDR
8746: LD_VAR 0 4
8750: PUSH
8751: FOR_TO
8752: IFFALSE 8898
// begin uc_side := 3 ;
8754: LD_ADDR_OWVAR 20
8758: PUSH
8759: LD_INT 3
8761: ST_TO_ADDR
// uc_nation := 3 ;
8762: LD_ADDR_OWVAR 21
8766: PUSH
8767: LD_INT 3
8769: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8770: LD_INT 24
8772: PPUSH
8773: LD_INT 1
8775: PPUSH
8776: LD_INT 3
8778: PPUSH
8779: LD_INT 46
8781: PUSH
8782: LD_INT 45
8784: PUSH
8785: LD_INT 44
8787: PUSH
8788: LD_INT 43
8790: PUSH
8791: LD_INT 42
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: LIST
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 5
8806: PPUSH
8807: CALL_OW 12
8811: ARRAY
8812: PPUSH
8813: LD_INT 90
8815: PPUSH
8816: CALL 16030 0 5
// un := CreateVehicle ;
8820: LD_ADDR_VAR 0 2
8824: PUSH
8825: CALL_OW 45
8829: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8830: LD_VAR 0 2
8834: PPUSH
8835: LD_INT 18
8837: PPUSH
8838: LD_INT 0
8840: PPUSH
8841: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8845: LD_VAR 0 2
8849: PPUSH
8850: LD_INT 147
8852: PPUSH
8853: LD_INT 161
8855: PPUSH
8856: CALL_OW 111
// wait ( 0 0$3 ) ;
8860: LD_INT 105
8862: PPUSH
8863: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8867: LD_ADDR_VAR 0 3
8871: PUSH
8872: LD_VAR 0 3
8876: PPUSH
8877: LD_VAR 0 3
8881: PUSH
8882: LD_INT 1
8884: PLUS
8885: PPUSH
8886: LD_VAR 0 2
8890: PPUSH
8891: CALL_OW 1
8895: ST_TO_ADDR
// end ;
8896: GO 8751
8898: POP
8899: POP
// if not tmp then
8900: LD_VAR 0 3
8904: NOT
8905: IFFALSE 8909
// exit ;
8907: GO 9044
// wait ( 0 0$5 ) ;
8909: LD_INT 175
8911: PPUSH
8912: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8916: LD_INT 70
8918: PPUSH
8919: CALL_OW 67
// for i in tmp do
8923: LD_ADDR_VAR 0 1
8927: PUSH
8928: LD_VAR 0 3
8932: PUSH
8933: FOR_IN
8934: IFFALSE 9035
// begin if not IsOk ( i ) or IsDead ( i ) then
8936: LD_VAR 0 1
8940: PPUSH
8941: CALL_OW 302
8945: NOT
8946: PUSH
8947: LD_VAR 0 1
8951: PPUSH
8952: CALL_OW 301
8956: OR
8957: IFFALSE 8975
// tmp := tmp diff i ;
8959: LD_ADDR_VAR 0 3
8963: PUSH
8964: LD_VAR 0 3
8968: PUSH
8969: LD_VAR 0 1
8973: DIFF
8974: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8975: LD_VAR 0 1
8979: PPUSH
8980: CALL_OW 257
8984: PUSH
8985: LD_INT 9
8987: EQUAL
8988: IFFALSE 8999
// ComSpaceTimeShoot ( i ) ;
8990: LD_VAR 0 1
8994: PPUSH
8995: CALL 11962 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_INT 81
9006: PUSH
9007: LD_INT 3
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 69
9018: PPUSH
9019: LD_VAR 0 1
9023: PPUSH
9024: CALL_OW 74
9028: PPUSH
9029: CALL_OW 115
// end ;
9033: GO 8933
9035: POP
9036: POP
// until not tmp ;
9037: LD_VAR 0 3
9041: NOT
9042: IFFALSE 8916
// end ; end_of_file
9044: PPOPN 4
9046: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9047: LD_INT 0
9049: PPUSH
9050: PPUSH
9051: PPUSH
9052: PPUSH
// uc_side := 1 ;
9053: LD_ADDR_OWVAR 20
9057: PUSH
9058: LD_INT 1
9060: ST_TO_ADDR
// uc_nation := 1 ;
9061: LD_ADDR_OWVAR 21
9065: PUSH
9066: LD_INT 1
9068: ST_TO_ADDR
// hc_importance := 100 ;
9069: LD_ADDR_OWVAR 32
9073: PUSH
9074: LD_INT 100
9076: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9077: LD_ADDR_OWVAR 26
9081: PUSH
9082: LD_STRING Jeremy Sikorski
9084: ST_TO_ADDR
// hc_gallery := us ;
9085: LD_ADDR_OWVAR 33
9089: PUSH
9090: LD_STRING us
9092: ST_TO_ADDR
// hc_face_number := 19 ;
9093: LD_ADDR_OWVAR 34
9097: PUSH
9098: LD_INT 19
9100: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 1
9106: PPUSH
9107: LD_INT 4
9109: PUSH
9110: LD_INT 4
9112: PUSH
9113: LD_INT 3
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: LIST
9120: PUSH
9121: LD_OWVAR 67
9125: ARRAY
9126: PPUSH
9127: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9131: LD_ADDR_OWVAR 29
9135: PUSH
9136: LD_INT 10
9138: PUSH
9139: LD_INT 12
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: ST_TO_ADDR
// Sikorski := CreateHuman ;
9146: LD_ADDR_EXP 20
9150: PUSH
9151: CALL_OW 44
9155: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9156: LD_EXP 20
9160: PPUSH
9161: LD_INT 133
9163: PPUSH
9164: LD_INT 19
9166: PPUSH
9167: LD_INT 2
9169: PPUSH
9170: LD_INT 0
9172: PPUSH
9173: CALL_OW 50
// InitHc_All ( ) ;
9177: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9181: LD_ADDR_VAR 0 2
9185: PUSH
9186: DOUBLE
9187: LD_INT 1
9189: DEC
9190: ST_TO_ADDR
9191: LD_INT 4
9193: PUSH
9194: LD_INT 3
9196: PUSH
9197: LD_INT 3
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: LIST
9204: PUSH
9205: LD_OWVAR 67
9209: ARRAY
9210: PUSH
9211: FOR_TO
9212: IFFALSE 9328
// for j := 1 to 4 do
9214: LD_ADDR_VAR 0 3
9218: PUSH
9219: DOUBLE
9220: LD_INT 1
9222: DEC
9223: ST_TO_ADDR
9224: LD_INT 4
9226: PUSH
9227: FOR_TO
9228: IFFALSE 9324
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9230: LD_INT 0
9232: PPUSH
9233: LD_VAR 0 3
9237: PPUSH
9238: LD_INT 5
9240: PUSH
9241: LD_INT 4
9243: PUSH
9244: LD_INT 3
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: LIST
9251: PUSH
9252: LD_OWVAR 67
9256: ARRAY
9257: PPUSH
9258: CALL_OW 380
// un := CreateHuman ;
9262: LD_ADDR_VAR 0 4
9266: PUSH
9267: CALL_OW 44
9271: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9272: LD_VAR 0 4
9276: PPUSH
9277: LD_INT 0
9279: PPUSH
9280: LD_INT 5
9282: PPUSH
9283: CALL_OW 12
9287: PPUSH
9288: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9292: LD_VAR 0 4
9296: PPUSH
9297: LD_INT 133
9299: PPUSH
9300: LD_INT 19
9302: PPUSH
9303: LD_INT 6
9305: PPUSH
9306: LD_INT 0
9308: PPUSH
9309: CALL_OW 50
// ComHold ( un ) ;
9313: LD_VAR 0 4
9317: PPUSH
9318: CALL_OW 140
// end ;
9322: GO 9227
9324: POP
9325: POP
9326: GO 9211
9328: POP
9329: POP
// vc_chassis := us_heavy_tracked ;
9330: LD_ADDR_OWVAR 37
9334: PUSH
9335: LD_INT 4
9337: ST_TO_ADDR
// vc_engine := engine_combustion ;
9338: LD_ADDR_OWVAR 39
9342: PUSH
9343: LD_INT 1
9345: ST_TO_ADDR
// vc_control := control_manual ;
9346: LD_ADDR_OWVAR 38
9350: PUSH
9351: LD_INT 1
9353: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9354: LD_ADDR_OWVAR 40
9358: PUSH
9359: LD_INT 14
9361: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9362: LD_ADDR_OWVAR 41
9366: PUSH
9367: LD_INT 60
9369: ST_TO_ADDR
// un := CreateVehicle ;
9370: LD_ADDR_VAR 0 4
9374: PUSH
9375: CALL_OW 45
9379: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9380: LD_VAR 0 4
9384: PPUSH
9385: LD_INT 2
9387: PPUSH
9388: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 128
9399: PPUSH
9400: LD_INT 12
9402: PPUSH
9403: LD_INT 0
9405: PPUSH
9406: CALL_OW 48
// for i := 1 to 3 do
9410: LD_ADDR_VAR 0 2
9414: PUSH
9415: DOUBLE
9416: LD_INT 1
9418: DEC
9419: ST_TO_ADDR
9420: LD_INT 3
9422: PUSH
9423: FOR_TO
9424: IFFALSE 9447
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9426: LD_INT 5
9428: PPUSH
9429: LD_INT 133
9431: PPUSH
9432: LD_INT 19
9434: PPUSH
9435: LD_INT 3
9437: PPUSH
9438: LD_INT 0
9440: PPUSH
9441: CALL_OW 56
9445: GO 9423
9447: POP
9448: POP
// end ; end_of_file
9449: LD_VAR 0 1
9453: RET
// export function Action ; begin
9454: LD_INT 0
9456: PPUSH
// InGameOn ;
9457: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9461: LD_INT 133
9463: PPUSH
9464: LD_INT 19
9466: PPUSH
9467: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9471: LD_EXP 20
9475: PPUSH
9476: LD_STRING WT-DS-1
9478: PPUSH
9479: CALL_OW 88
// InGameOff ;
9483: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9487: LD_STRING DestroyEnemy
9489: PPUSH
9490: CALL_OW 337
// wait ( 0 0$20 ) ;
9494: LD_INT 700
9496: PPUSH
9497: CALL_OW 67
// DialogueOn ;
9501: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9505: LD_INT 100
9507: PPUSH
9508: LD_INT 37
9510: PPUSH
9511: LD_INT 1
9513: PPUSH
9514: LD_INT 30
9516: NEG
9517: PPUSH
9518: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9522: LD_INT 100
9524: PPUSH
9525: LD_INT 37
9527: PPUSH
9528: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9532: LD_EXP 10
9536: PPUSH
9537: LD_STRING WT-PL-1
9539: PPUSH
9540: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9544: LD_EXP 20
9548: PPUSH
9549: LD_STRING WT-DS-2
9551: PPUSH
9552: CALL_OW 88
// DialogueOff ;
9556: CALL_OW 7
// wait ( 0 0$2 ) ;
9560: LD_INT 70
9562: PPUSH
9563: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9567: LD_INT 100
9569: PPUSH
9570: LD_INT 37
9572: PPUSH
9573: LD_INT 1
9575: PPUSH
9576: CALL_OW 331
// end ;
9580: LD_VAR 0 1
9584: RET
// export function DialogPowellsAttack ; begin
9585: LD_INT 0
9587: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9588: LD_EXP 10
9592: PPUSH
9593: LD_STRING WT-PL-8
9595: PPUSH
9596: CALL_OW 94
// end ;
9600: LD_VAR 0 1
9604: RET
// export function DialogContaminateSib ( x , y ) ; begin
9605: LD_INT 0
9607: PPUSH
// DialogueOn ;
9608: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9612: LD_VAR 0 1
9616: PPUSH
9617: LD_VAR 0 2
9621: PPUSH
9622: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9626: LD_EXP 20
9630: PPUSH
9631: LD_STRING WT-DS-3
9633: PPUSH
9634: CALL_OW 88
// DialogueOff ;
9638: CALL_OW 7
// end ;
9642: LD_VAR 0 3
9646: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9647: LD_EXP 8
9651: NOT
9652: PUSH
9653: LD_INT 1
9655: PPUSH
9656: LD_INT 81
9658: PUSH
9659: LD_INT 4
9661: PUSH
9662: EMPTY
9663: LIST
9664: LIST
9665: PPUSH
9666: CALL_OW 70
9670: PUSH
9671: LD_INT 3
9673: GREATER
9674: AND
9675: IFFALSE 9747
9677: GO 9679
9679: DISABLE
// begin powellInTrouble := true ;
9680: LD_ADDR_EXP 8
9684: PUSH
9685: LD_INT 1
9687: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9688: LD_EXP 20
9692: PPUSH
9693: LD_STRING WT-DS-6
9695: PPUSH
9696: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9700: LD_INT 1
9702: PPUSH
9703: LD_INT 22
9705: PUSH
9706: LD_INT 1
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PPUSH
9713: CALL_OW 70
9717: NOT
9718: IFFALSE 9732
// SayRadio ( Powell , WT-PL-6 ) ;
9720: LD_EXP 10
9724: PPUSH
9725: LD_STRING WT-PL-6
9727: PPUSH
9728: CALL_OW 94
// wait ( 1 1$30 ) ;
9732: LD_INT 3150
9734: PPUSH
9735: CALL_OW 67
// powellInTrouble := false ;
9739: LD_ADDR_EXP 8
9743: PUSH
9744: LD_INT 0
9746: ST_TO_ADDR
// end ;
9747: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9748: LD_EXP 9
9752: NOT
9753: PUSH
9754: LD_INT 16
9756: PPUSH
9757: LD_INT 81
9759: PUSH
9760: LD_INT 1
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 70
9771: PUSH
9772: LD_INT 6
9774: GREATER
9775: AND
9776: IFFALSE 9849
9778: GO 9780
9780: DISABLE
// begin sikorskiInTrouble := true ;
9781: LD_ADDR_EXP 9
9785: PUSH
9786: LD_INT 1
9788: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9789: LD_EXP 20
9793: PPUSH
9794: LD_STRING WT-DS-7
9796: PPUSH
9797: CALL_OW 88
// if not powellAttackGroup then
9801: LD_EXP 12
9805: NOT
9806: IFFALSE 9822
// SayRadio ( Powell , WT-PL-7n ) else
9808: LD_EXP 10
9812: PPUSH
9813: LD_STRING WT-PL-7n
9815: PPUSH
9816: CALL_OW 94
9820: GO 9834
// SayRadio ( Powell , WT-PL-7y ) ;
9822: LD_EXP 10
9826: PPUSH
9827: LD_STRING WT-PL-7y
9829: PPUSH
9830: CALL_OW 94
// wait ( 1 1$30 ) ;
9834: LD_INT 3150
9836: PPUSH
9837: CALL_OW 67
// sikorskiInTrouble := false ;
9841: LD_ADDR_EXP 9
9845: PUSH
9846: LD_INT 0
9848: ST_TO_ADDR
// end ;
9849: END
// export function DialogPowellsAttackFailed ; begin
9850: LD_INT 0
9852: PPUSH
// if not ruDestroyed then
9853: LD_EXP 5
9857: NOT
9858: IFFALSE 9874
// SayRadio ( Powell , WT-PL-9 ) else
9860: LD_EXP 10
9864: PPUSH
9865: LD_STRING WT-PL-9
9867: PPUSH
9868: CALL_OW 94
9872: GO 9886
// SayRadio ( Powell , WT-PL-10 ) ;
9874: LD_EXP 10
9878: PPUSH
9879: LD_STRING WT-PL-10
9881: PPUSH
9882: CALL_OW 94
// end ;
9886: LD_VAR 0 1
9890: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9891: LD_INT 22
9893: PUSH
9894: LD_INT 2
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PUSH
9901: LD_INT 21
9903: PUSH
9904: LD_INT 1
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: PPUSH
9915: CALL_OW 69
9919: PUSH
9920: LD_INT 0
9922: EQUAL
9923: IFFALSE 9967
9925: GO 9927
9927: DISABLE
// begin arDestroyed := true ;
9928: LD_ADDR_EXP 4
9932: PUSH
9933: LD_INT 1
9935: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9936: LD_INT 2
9938: PPUSH
9939: CALL 52632 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9943: LD_EXP 20
9947: PPUSH
9948: LD_STRING WT-DS-4
9950: PPUSH
9951: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9955: LD_EXP 10
9959: PPUSH
9960: LD_STRING WT-PL-4
9962: PPUSH
9963: CALL_OW 94
// end ;
9967: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9968: LD_INT 22
9970: PUSH
9971: LD_INT 3
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PUSH
9978: LD_INT 21
9980: PUSH
9981: LD_INT 1
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PPUSH
9992: CALL_OW 69
9996: PUSH
9997: LD_INT 0
9999: EQUAL
10000: IFFALSE 10044
10002: GO 10004
10004: DISABLE
// begin ruDestroyed := true ;
10005: LD_ADDR_EXP 5
10009: PUSH
10010: LD_INT 1
10012: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10013: LD_INT 3
10015: PPUSH
10016: CALL 52632 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10020: LD_EXP 20
10024: PPUSH
10025: LD_STRING WT-DS-5
10027: PPUSH
10028: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10032: LD_EXP 10
10036: PPUSH
10037: LD_STRING WT-PL-5
10039: PPUSH
10040: CALL_OW 94
// end ;
10044: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10045: LD_EXP 5
10049: PUSH
10050: LD_EXP 4
10054: AND
10055: IFFALSE 10228
10057: GO 10059
10059: DISABLE
// begin wait ( 0 0$3 ) ;
10060: LD_INT 105
10062: PPUSH
10063: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10067: LD_OWVAR 1
10071: PUSH
10072: LD_INT 126000
10074: PUSH
10075: LD_INT 105000
10077: PUSH
10078: LD_INT 94500
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: LIST
10085: PUSH
10086: LD_OWVAR 67
10090: ARRAY
10091: GREATEREQUAL
10092: IFFALSE 10107
// AddMedal ( WoT-med-1 , - 1 ) else
10094: LD_STRING WoT-med-1
10096: PPUSH
10097: LD_INT 1
10099: NEG
10100: PPUSH
10101: CALL_OW 101
10105: GO 10117
// AddMedal ( WoT-med-1 , 1 ) ;
10107: LD_STRING WoT-med-1
10109: PPUSH
10110: LD_INT 1
10112: PPUSH
10113: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10117: LD_EXP 6
10121: PUSH
10122: LD_INT 4
10124: PUSH
10125: LD_INT 3
10127: PUSH
10128: LD_INT 2
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: PUSH
10136: LD_OWVAR 67
10140: ARRAY
10141: GREATEREQUAL
10142: IFFALSE 10157
// AddMedal ( WoT-med-2 , - 1 ) else
10144: LD_STRING WoT-med-2
10146: PPUSH
10147: LD_INT 1
10149: NEG
10150: PPUSH
10151: CALL_OW 101
10155: GO 10167
// AddMedal ( WoT-med-2 , 1 ) ;
10157: LD_STRING WoT-med-2
10159: PPUSH
10160: LD_INT 1
10162: PPUSH
10163: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10167: LD_EXP 7
10171: PUSH
10172: LD_INT 8
10174: PUSH
10175: LD_INT 6
10177: PUSH
10178: LD_INT 5
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_OWVAR 67
10190: ARRAY
10191: GREATEREQUAL
10192: IFFALSE 10207
// AddMedal ( WoT-med-3 , - 1 ) else
10194: LD_STRING WoT-med-3
10196: PPUSH
10197: LD_INT 1
10199: NEG
10200: PPUSH
10201: CALL_OW 101
10205: GO 10217
// AddMedal ( WoT-med-3 , 1 ) ;
10207: LD_STRING WoT-med-3
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL_OW 101
// GiveMedals ( MAIN ) ;
10217: LD_STRING MAIN
10219: PPUSH
10220: CALL_OW 102
// YouWin ;
10224: CALL_OW 103
// end ; end_of_file
10228: END
// export function CustomEvent ( event ) ; begin
10229: LD_INT 0
10231: PPUSH
// end ;
10232: LD_VAR 0 2
10236: RET
// on Command ( com ) do var i , j , temp ;
10237: LD_INT 0
10239: PPUSH
10240: PPUSH
10241: PPUSH
// begin if com = 60 then
10242: LD_VAR 0 1
10246: PUSH
10247: LD_INT 60
10249: EQUAL
10250: IFFALSE 10429
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10252: LD_ADDR_VAR 0 2
10256: PUSH
10257: LD_INT 22
10259: PUSH
10260: LD_INT 1
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: PUSH
10267: LD_INT 2
10269: PUSH
10270: LD_INT 21
10272: PUSH
10273: LD_INT 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 34
10282: PUSH
10283: LD_INT 12
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: LIST
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PUSH
10304: FOR_IN
10305: IFFALSE 10427
// begin if GetTaskList ( i ) > 0 then
10307: LD_VAR 0 2
10311: PPUSH
10312: CALL_OW 437
10316: PUSH
10317: LD_INT 0
10319: GREATER
10320: IFFALSE 10425
// for j = 1 to GetTaskList ( i ) do
10322: LD_ADDR_VAR 0 3
10326: PUSH
10327: DOUBLE
10328: LD_INT 1
10330: DEC
10331: ST_TO_ADDR
10332: LD_VAR 0 2
10336: PPUSH
10337: CALL_OW 437
10341: PUSH
10342: FOR_TO
10343: IFFALSE 10423
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10345: LD_ADDR_VAR 0 4
10349: PUSH
10350: LD_VAR 0 2
10354: PPUSH
10355: CALL_OW 437
10359: PUSH
10360: LD_VAR 0 3
10364: ARRAY
10365: PUSH
10366: LD_INT 4
10368: ARRAY
10369: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10370: LD_VAR 0 4
10374: PPUSH
10375: CALL_OW 255
10379: PUSH
10380: LD_INT 4
10382: EQUAL
10383: PUSH
10384: LD_VAR 0 2
10388: PPUSH
10389: CALL_OW 437
10393: PUSH
10394: LD_VAR 0 3
10398: ARRAY
10399: PUSH
10400: LD_INT 1
10402: ARRAY
10403: PUSH
10404: LD_STRING <
10406: EQUAL
10407: AND
10408: IFFALSE 10421
// SetTaskList ( i , [ ] ) ;
10410: LD_VAR 0 2
10414: PPUSH
10415: EMPTY
10416: PPUSH
10417: CALL_OW 446
// end ;
10421: GO 10342
10423: POP
10424: POP
// end ;
10425: GO 10304
10427: POP
10428: POP
// end ; end ;
10429: PPOPN 4
10431: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10432: LD_VAR 0 2
10436: PPUSH
10437: LD_VAR 0 3
10441: PPUSH
10442: CALL_OW 428
10446: PPUSH
10447: CALL_OW 255
10451: PUSH
10452: LD_INT 1
10454: EQUAL
10455: PUSH
10456: LD_VAR 0 2
10460: PUSH
10461: LD_INT 132
10463: EQUAL
10464: PUSH
10465: LD_VAR 0 3
10469: PUSH
10470: LD_INT 39
10472: EQUAL
10473: AND
10474: OR
10475: IFFALSE 10491
// DialogContaminateSib ( x , y ) ;
10477: LD_VAR 0 2
10481: PPUSH
10482: LD_VAR 0 3
10486: PPUSH
10487: CALL 9605 0 2
// end ;
10491: PPOPN 3
10493: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10494: LD_VAR 0 1
10498: PPUSH
10499: CALL 90348 0 1
// MCE_UnitDestroyed ( un ) ;
10503: LD_VAR 0 1
10507: PPUSH
10508: CALL 80063 0 1
// if un = Powell then
10512: LD_VAR 0 1
10516: PUSH
10517: LD_EXP 10
10521: EQUAL
10522: IFFALSE 10531
// YouLost ( Powell ) ;
10524: LD_STRING Powell
10526: PPUSH
10527: CALL_OW 104
// if un = Sikorski then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 20
10540: EQUAL
10541: IFFALSE 10550
// YouLost ( Sikorski ) ;
10543: LD_STRING Sikorski
10545: PPUSH
10546: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10550: LD_VAR 0 1
10554: PUSH
10555: LD_INT 22
10557: PUSH
10558: LD_INT 1
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: PUSH
10565: LD_INT 21
10567: PUSH
10568: LD_INT 1
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: EMPTY
10576: LIST
10577: LIST
10578: PPUSH
10579: CALL_OW 69
10583: IN
10584: IFFALSE 10600
// loseCounter := loseCounter + 1 ;
10586: LD_ADDR_EXP 6
10590: PUSH
10591: LD_EXP 6
10595: PUSH
10596: LD_INT 1
10598: PLUS
10599: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10600: LD_VAR 0 1
10604: PUSH
10605: LD_INT 22
10607: PUSH
10608: LD_INT 4
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: PUSH
10615: LD_INT 21
10617: PUSH
10618: LD_INT 1
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: PPUSH
10629: CALL_OW 69
10633: IN
10634: IFFALSE 10650
// powellLoseCounter := powellLoseCounter + 1 ;
10636: LD_ADDR_EXP 7
10640: PUSH
10641: LD_EXP 7
10645: PUSH
10646: LD_INT 1
10648: PLUS
10649: ST_TO_ADDR
// if un in powellAttackGroup then
10650: LD_VAR 0 1
10654: PUSH
10655: LD_EXP 12
10659: IN
10660: IFFALSE 10678
// powellAttackGroup := powellAttackGroup diff un ;
10662: LD_ADDR_EXP 12
10666: PUSH
10667: LD_EXP 12
10671: PUSH
10672: LD_VAR 0 1
10676: DIFF
10677: ST_TO_ADDR
// if un in gensherAttackGroup then
10678: LD_VAR 0 1
10682: PUSH
10683: LD_EXP 15
10687: IN
10688: IFFALSE 10706
// gensherAttackGroup := gensherAttackGroup diff un ;
10690: LD_ADDR_EXP 15
10694: PUSH
10695: LD_EXP 15
10699: PUSH
10700: LD_VAR 0 1
10704: DIFF
10705: ST_TO_ADDR
// if un in popovAttackGroup then
10706: LD_VAR 0 1
10710: PUSH
10711: LD_EXP 19
10715: IN
10716: IFFALSE 10734
// popovAttackGroup := popovAttackGroup diff un ;
10718: LD_ADDR_EXP 19
10722: PUSH
10723: LD_EXP 19
10727: PUSH
10728: LD_VAR 0 1
10732: DIFF
10733: ST_TO_ADDR
// end ;
10734: PPOPN 1
10736: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10737: LD_VAR 0 1
10741: PPUSH
10742: LD_VAR 0 2
10746: PPUSH
10747: CALL 82395 0 2
// end ;
10751: PPOPN 2
10753: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10754: LD_VAR 0 1
10758: PPUSH
10759: CALL 81463 0 1
// end ;
10763: PPOPN 1
10765: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL 81704 0 1
// end ;
10775: PPOPN 1
10777: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10778: LD_VAR 0 1
10782: PPUSH
10783: LD_VAR 0 2
10787: PPUSH
10788: CALL 79759 0 2
// end ;
10792: PPOPN 2
10794: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: LD_VAR 0 3
10809: PPUSH
10810: LD_VAR 0 4
10814: PPUSH
10815: LD_VAR 0 5
10819: PPUSH
10820: CALL 79379 0 5
// end ;
10824: PPOPN 5
10826: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10827: LD_VAR 0 1
10831: PPUSH
10832: LD_VAR 0 2
10836: PPUSH
10837: CALL 90468 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 78970 0 2
// end ;
10855: PPOPN 2
10857: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: LD_VAR 0 3
10872: PPUSH
10873: LD_VAR 0 4
10877: PPUSH
10878: CALL 78808 0 4
// end ;
10882: PPOPN 4
10884: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10885: LD_VAR 0 1
10889: PPUSH
10890: LD_VAR 0 2
10894: PPUSH
10895: LD_VAR 0 3
10899: PPUSH
10900: CALL 78583 0 3
// end ;
10904: PPOPN 3
10906: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10907: LD_VAR 0 1
10911: PPUSH
10912: LD_VAR 0 2
10916: PPUSH
10917: CALL 78468 0 2
// end ;
10921: PPOPN 2
10923: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10924: LD_VAR 0 1
10928: PPUSH
10929: LD_VAR 0 2
10933: PPUSH
10934: CALL 82690 0 2
// end ;
10938: PPOPN 2
10940: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: LD_VAR 0 3
10955: PPUSH
10956: LD_VAR 0 4
10960: PPUSH
10961: CALL 82906 0 4
// end ;
10965: PPOPN 4
10967: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10968: LD_VAR 0 1
10972: PPUSH
10973: LD_VAR 0 2
10977: PPUSH
10978: CALL 78277 0 2
// end ;
10982: PPOPN 2
10984: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10985: LD_VAR 0 1
10989: PUSH
10990: LD_INT 1
10992: EQUAL
10993: PUSH
10994: LD_VAR 0 2
10998: PUSH
10999: LD_INT 4
11001: EQUAL
11002: AND
11003: IFFALSE 11012
// YouLost ( FriendlyFire ) ;
11005: LD_STRING FriendlyFire
11007: PPUSH
11008: CALL_OW 104
// end ; end_of_file
11012: PPOPN 2
11014: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11015: LD_INT 0
11017: PPUSH
11018: PPUSH
// if exist_mode then
11019: LD_VAR 0 2
11023: IFFALSE 11048
// unit := CreateCharacter ( prefix & ident ) else
11025: LD_ADDR_VAR 0 5
11029: PUSH
11030: LD_VAR 0 3
11034: PUSH
11035: LD_VAR 0 1
11039: STR
11040: PPUSH
11041: CALL_OW 34
11045: ST_TO_ADDR
11046: GO 11063
// unit := NewCharacter ( ident ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_VAR 0 1
11057: PPUSH
11058: CALL_OW 25
11062: ST_TO_ADDR
// result := unit ;
11063: LD_ADDR_VAR 0 4
11067: PUSH
11068: LD_VAR 0 5
11072: ST_TO_ADDR
// end ;
11073: LD_VAR 0 4
11077: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11078: LD_INT 0
11080: PPUSH
11081: PPUSH
// if not side or not nation then
11082: LD_VAR 0 1
11086: NOT
11087: PUSH
11088: LD_VAR 0 2
11092: NOT
11093: OR
11094: IFFALSE 11098
// exit ;
11096: GO 11866
// case nation of nation_american :
11098: LD_VAR 0 2
11102: PUSH
11103: LD_INT 1
11105: DOUBLE
11106: EQUAL
11107: IFTRUE 11111
11109: GO 11325
11111: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11112: LD_ADDR_VAR 0 4
11116: PUSH
11117: LD_INT 35
11119: PUSH
11120: LD_INT 45
11122: PUSH
11123: LD_INT 46
11125: PUSH
11126: LD_INT 47
11128: PUSH
11129: LD_INT 82
11131: PUSH
11132: LD_INT 83
11134: PUSH
11135: LD_INT 84
11137: PUSH
11138: LD_INT 85
11140: PUSH
11141: LD_INT 86
11143: PUSH
11144: LD_INT 1
11146: PUSH
11147: LD_INT 2
11149: PUSH
11150: LD_INT 6
11152: PUSH
11153: LD_INT 15
11155: PUSH
11156: LD_INT 16
11158: PUSH
11159: LD_INT 7
11161: PUSH
11162: LD_INT 12
11164: PUSH
11165: LD_INT 13
11167: PUSH
11168: LD_INT 10
11170: PUSH
11171: LD_INT 14
11173: PUSH
11174: LD_INT 20
11176: PUSH
11177: LD_INT 21
11179: PUSH
11180: LD_INT 22
11182: PUSH
11183: LD_INT 25
11185: PUSH
11186: LD_INT 32
11188: PUSH
11189: LD_INT 27
11191: PUSH
11192: LD_INT 36
11194: PUSH
11195: LD_INT 69
11197: PUSH
11198: LD_INT 39
11200: PUSH
11201: LD_INT 34
11203: PUSH
11204: LD_INT 40
11206: PUSH
11207: LD_INT 48
11209: PUSH
11210: LD_INT 49
11212: PUSH
11213: LD_INT 50
11215: PUSH
11216: LD_INT 51
11218: PUSH
11219: LD_INT 52
11221: PUSH
11222: LD_INT 53
11224: PUSH
11225: LD_INT 54
11227: PUSH
11228: LD_INT 55
11230: PUSH
11231: LD_INT 56
11233: PUSH
11234: LD_INT 57
11236: PUSH
11237: LD_INT 58
11239: PUSH
11240: LD_INT 59
11242: PUSH
11243: LD_INT 60
11245: PUSH
11246: LD_INT 61
11248: PUSH
11249: LD_INT 62
11251: PUSH
11252: LD_INT 80
11254: PUSH
11255: LD_INT 82
11257: PUSH
11258: LD_INT 83
11260: PUSH
11261: LD_INT 84
11263: PUSH
11264: LD_INT 85
11266: PUSH
11267: LD_INT 86
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: ST_TO_ADDR
11323: GO 11790
11325: LD_INT 2
11327: DOUBLE
11328: EQUAL
11329: IFTRUE 11333
11331: GO 11559
11333: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11334: LD_ADDR_VAR 0 4
11338: PUSH
11339: LD_INT 35
11341: PUSH
11342: LD_INT 45
11344: PUSH
11345: LD_INT 46
11347: PUSH
11348: LD_INT 47
11350: PUSH
11351: LD_INT 82
11353: PUSH
11354: LD_INT 83
11356: PUSH
11357: LD_INT 84
11359: PUSH
11360: LD_INT 85
11362: PUSH
11363: LD_INT 87
11365: PUSH
11366: LD_INT 70
11368: PUSH
11369: LD_INT 1
11371: PUSH
11372: LD_INT 11
11374: PUSH
11375: LD_INT 3
11377: PUSH
11378: LD_INT 4
11380: PUSH
11381: LD_INT 5
11383: PUSH
11384: LD_INT 6
11386: PUSH
11387: LD_INT 15
11389: PUSH
11390: LD_INT 18
11392: PUSH
11393: LD_INT 7
11395: PUSH
11396: LD_INT 17
11398: PUSH
11399: LD_INT 8
11401: PUSH
11402: LD_INT 20
11404: PUSH
11405: LD_INT 21
11407: PUSH
11408: LD_INT 22
11410: PUSH
11411: LD_INT 72
11413: PUSH
11414: LD_INT 26
11416: PUSH
11417: LD_INT 69
11419: PUSH
11420: LD_INT 39
11422: PUSH
11423: LD_INT 40
11425: PUSH
11426: LD_INT 41
11428: PUSH
11429: LD_INT 42
11431: PUSH
11432: LD_INT 43
11434: PUSH
11435: LD_INT 48
11437: PUSH
11438: LD_INT 49
11440: PUSH
11441: LD_INT 50
11443: PUSH
11444: LD_INT 51
11446: PUSH
11447: LD_INT 52
11449: PUSH
11450: LD_INT 53
11452: PUSH
11453: LD_INT 54
11455: PUSH
11456: LD_INT 55
11458: PUSH
11459: LD_INT 56
11461: PUSH
11462: LD_INT 60
11464: PUSH
11465: LD_INT 61
11467: PUSH
11468: LD_INT 62
11470: PUSH
11471: LD_INT 66
11473: PUSH
11474: LD_INT 67
11476: PUSH
11477: LD_INT 68
11479: PUSH
11480: LD_INT 81
11482: PUSH
11483: LD_INT 82
11485: PUSH
11486: LD_INT 83
11488: PUSH
11489: LD_INT 84
11491: PUSH
11492: LD_INT 85
11494: PUSH
11495: LD_INT 87
11497: PUSH
11498: LD_INT 88
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: ST_TO_ADDR
11557: GO 11790
11559: LD_INT 3
11561: DOUBLE
11562: EQUAL
11563: IFTRUE 11567
11565: GO 11789
11567: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11568: LD_ADDR_VAR 0 4
11572: PUSH
11573: LD_INT 46
11575: PUSH
11576: LD_INT 47
11578: PUSH
11579: LD_INT 1
11581: PUSH
11582: LD_INT 2
11584: PUSH
11585: LD_INT 82
11587: PUSH
11588: LD_INT 83
11590: PUSH
11591: LD_INT 84
11593: PUSH
11594: LD_INT 85
11596: PUSH
11597: LD_INT 86
11599: PUSH
11600: LD_INT 11
11602: PUSH
11603: LD_INT 9
11605: PUSH
11606: LD_INT 20
11608: PUSH
11609: LD_INT 19
11611: PUSH
11612: LD_INT 21
11614: PUSH
11615: LD_INT 24
11617: PUSH
11618: LD_INT 22
11620: PUSH
11621: LD_INT 25
11623: PUSH
11624: LD_INT 28
11626: PUSH
11627: LD_INT 29
11629: PUSH
11630: LD_INT 30
11632: PUSH
11633: LD_INT 31
11635: PUSH
11636: LD_INT 37
11638: PUSH
11639: LD_INT 38
11641: PUSH
11642: LD_INT 32
11644: PUSH
11645: LD_INT 27
11647: PUSH
11648: LD_INT 33
11650: PUSH
11651: LD_INT 69
11653: PUSH
11654: LD_INT 39
11656: PUSH
11657: LD_INT 34
11659: PUSH
11660: LD_INT 40
11662: PUSH
11663: LD_INT 71
11665: PUSH
11666: LD_INT 23
11668: PUSH
11669: LD_INT 44
11671: PUSH
11672: LD_INT 48
11674: PUSH
11675: LD_INT 49
11677: PUSH
11678: LD_INT 50
11680: PUSH
11681: LD_INT 51
11683: PUSH
11684: LD_INT 52
11686: PUSH
11687: LD_INT 53
11689: PUSH
11690: LD_INT 54
11692: PUSH
11693: LD_INT 55
11695: PUSH
11696: LD_INT 56
11698: PUSH
11699: LD_INT 57
11701: PUSH
11702: LD_INT 58
11704: PUSH
11705: LD_INT 59
11707: PUSH
11708: LD_INT 63
11710: PUSH
11711: LD_INT 64
11713: PUSH
11714: LD_INT 65
11716: PUSH
11717: LD_INT 82
11719: PUSH
11720: LD_INT 83
11722: PUSH
11723: LD_INT 84
11725: PUSH
11726: LD_INT 85
11728: PUSH
11729: LD_INT 86
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: ST_TO_ADDR
11787: GO 11790
11789: POP
// if state > - 1 and state < 3 then
11790: LD_VAR 0 3
11794: PUSH
11795: LD_INT 1
11797: NEG
11798: GREATER
11799: PUSH
11800: LD_VAR 0 3
11804: PUSH
11805: LD_INT 3
11807: LESS
11808: AND
11809: IFFALSE 11866
// for i in result do
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_VAR 0 4
11820: PUSH
11821: FOR_IN
11822: IFFALSE 11864
// if GetTech ( i , side ) <> state then
11824: LD_VAR 0 5
11828: PPUSH
11829: LD_VAR 0 1
11833: PPUSH
11834: CALL_OW 321
11838: PUSH
11839: LD_VAR 0 3
11843: NONEQUAL
11844: IFFALSE 11862
// result := result diff i ;
11846: LD_ADDR_VAR 0 4
11850: PUSH
11851: LD_VAR 0 4
11855: PUSH
11856: LD_VAR 0 5
11860: DIFF
11861: ST_TO_ADDR
11862: GO 11821
11864: POP
11865: POP
// end ;
11866: LD_VAR 0 4
11870: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11871: LD_INT 0
11873: PPUSH
11874: PPUSH
11875: PPUSH
// result := true ;
11876: LD_ADDR_VAR 0 3
11880: PUSH
11881: LD_INT 1
11883: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11884: LD_ADDR_VAR 0 5
11888: PUSH
11889: LD_VAR 0 2
11893: PPUSH
11894: CALL_OW 480
11898: ST_TO_ADDR
// if not tmp then
11899: LD_VAR 0 5
11903: NOT
11904: IFFALSE 11908
// exit ;
11906: GO 11957
// for i in tmp do
11908: LD_ADDR_VAR 0 4
11912: PUSH
11913: LD_VAR 0 5
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11955
// if GetTech ( i , side ) <> state_researched then
11921: LD_VAR 0 4
11925: PPUSH
11926: LD_VAR 0 1
11930: PPUSH
11931: CALL_OW 321
11935: PUSH
11936: LD_INT 2
11938: NONEQUAL
11939: IFFALSE 11953
// begin result := false ;
11941: LD_ADDR_VAR 0 3
11945: PUSH
11946: LD_INT 0
11948: ST_TO_ADDR
// exit ;
11949: POP
11950: POP
11951: GO 11957
// end ;
11953: GO 11918
11955: POP
11956: POP
// end ;
11957: LD_VAR 0 3
11961: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11962: LD_INT 0
11964: PPUSH
11965: PPUSH
11966: PPUSH
11967: PPUSH
11968: PPUSH
11969: PPUSH
11970: PPUSH
11971: PPUSH
11972: PPUSH
11973: PPUSH
11974: PPUSH
11975: PPUSH
11976: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11977: LD_VAR 0 1
11981: NOT
11982: PUSH
11983: LD_VAR 0 1
11987: PPUSH
11988: CALL_OW 257
11992: PUSH
11993: LD_INT 9
11995: NONEQUAL
11996: OR
11997: IFFALSE 12001
// exit ;
11999: GO 12574
// side := GetSide ( unit ) ;
12001: LD_ADDR_VAR 0 9
12005: PUSH
12006: LD_VAR 0 1
12010: PPUSH
12011: CALL_OW 255
12015: ST_TO_ADDR
// tech_space := tech_spacanom ;
12016: LD_ADDR_VAR 0 12
12020: PUSH
12021: LD_INT 29
12023: ST_TO_ADDR
// tech_time := tech_taurad ;
12024: LD_ADDR_VAR 0 13
12028: PUSH
12029: LD_INT 28
12031: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12032: LD_ADDR_VAR 0 11
12036: PUSH
12037: LD_VAR 0 1
12041: PPUSH
12042: CALL_OW 310
12046: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12047: LD_VAR 0 11
12051: PPUSH
12052: CALL_OW 247
12056: PUSH
12057: LD_INT 2
12059: EQUAL
12060: IFFALSE 12064
// exit ;
12062: GO 12574
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12064: LD_ADDR_VAR 0 8
12068: PUSH
12069: LD_INT 81
12071: PUSH
12072: LD_VAR 0 9
12076: PUSH
12077: EMPTY
12078: LIST
12079: LIST
12080: PUSH
12081: LD_INT 3
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 3
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PPUSH
12102: CALL_OW 69
12106: ST_TO_ADDR
// if not tmp then
12107: LD_VAR 0 8
12111: NOT
12112: IFFALSE 12116
// exit ;
12114: GO 12574
// if in_unit then
12116: LD_VAR 0 11
12120: IFFALSE 12144
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12122: LD_ADDR_VAR 0 10
12126: PUSH
12127: LD_VAR 0 8
12131: PPUSH
12132: LD_VAR 0 11
12136: PPUSH
12137: CALL_OW 74
12141: ST_TO_ADDR
12142: GO 12164
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12144: LD_ADDR_VAR 0 10
12148: PUSH
12149: LD_VAR 0 8
12153: PPUSH
12154: LD_VAR 0 1
12158: PPUSH
12159: CALL_OW 74
12163: ST_TO_ADDR
// if not enemy then
12164: LD_VAR 0 10
12168: NOT
12169: IFFALSE 12173
// exit ;
12171: GO 12574
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12173: LD_VAR 0 11
12177: PUSH
12178: LD_VAR 0 11
12182: PPUSH
12183: LD_VAR 0 10
12187: PPUSH
12188: CALL_OW 296
12192: PUSH
12193: LD_INT 13
12195: GREATER
12196: AND
12197: PUSH
12198: LD_VAR 0 1
12202: PPUSH
12203: LD_VAR 0 10
12207: PPUSH
12208: CALL_OW 296
12212: PUSH
12213: LD_INT 12
12215: GREATER
12216: OR
12217: IFFALSE 12221
// exit ;
12219: GO 12574
// missile := [ 1 ] ;
12221: LD_ADDR_VAR 0 14
12225: PUSH
12226: LD_INT 1
12228: PUSH
12229: EMPTY
12230: LIST
12231: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12232: LD_VAR 0 9
12236: PPUSH
12237: LD_VAR 0 12
12241: PPUSH
12242: CALL_OW 325
12246: IFFALSE 12275
// missile := Replace ( missile , missile + 1 , 2 ) ;
12248: LD_ADDR_VAR 0 14
12252: PUSH
12253: LD_VAR 0 14
12257: PPUSH
12258: LD_VAR 0 14
12262: PUSH
12263: LD_INT 1
12265: PLUS
12266: PPUSH
12267: LD_INT 2
12269: PPUSH
12270: CALL_OW 1
12274: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12275: LD_VAR 0 9
12279: PPUSH
12280: LD_VAR 0 13
12284: PPUSH
12285: CALL_OW 325
12289: PUSH
12290: LD_VAR 0 10
12294: PPUSH
12295: CALL_OW 255
12299: PPUSH
12300: LD_VAR 0 13
12304: PPUSH
12305: CALL_OW 325
12309: NOT
12310: AND
12311: IFFALSE 12340
// missile := Replace ( missile , missile + 1 , 3 ) ;
12313: LD_ADDR_VAR 0 14
12317: PUSH
12318: LD_VAR 0 14
12322: PPUSH
12323: LD_VAR 0 14
12327: PUSH
12328: LD_INT 1
12330: PLUS
12331: PPUSH
12332: LD_INT 3
12334: PPUSH
12335: CALL_OW 1
12339: ST_TO_ADDR
// if missile < 2 then
12340: LD_VAR 0 14
12344: PUSH
12345: LD_INT 2
12347: LESS
12348: IFFALSE 12352
// exit ;
12350: GO 12574
// x := GetX ( enemy ) ;
12352: LD_ADDR_VAR 0 4
12356: PUSH
12357: LD_VAR 0 10
12361: PPUSH
12362: CALL_OW 250
12366: ST_TO_ADDR
// y := GetY ( enemy ) ;
12367: LD_ADDR_VAR 0 5
12371: PUSH
12372: LD_VAR 0 10
12376: PPUSH
12377: CALL_OW 251
12381: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12382: LD_ADDR_VAR 0 6
12386: PUSH
12387: LD_VAR 0 4
12391: PUSH
12392: LD_INT 1
12394: NEG
12395: PPUSH
12396: LD_INT 1
12398: PPUSH
12399: CALL_OW 12
12403: PLUS
12404: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12405: LD_ADDR_VAR 0 7
12409: PUSH
12410: LD_VAR 0 5
12414: PUSH
12415: LD_INT 1
12417: NEG
12418: PPUSH
12419: LD_INT 1
12421: PPUSH
12422: CALL_OW 12
12426: PLUS
12427: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12428: LD_VAR 0 6
12432: PPUSH
12433: LD_VAR 0 7
12437: PPUSH
12438: CALL_OW 488
12442: NOT
12443: IFFALSE 12465
// begin _x := x ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 4
12454: ST_TO_ADDR
// _y := y ;
12455: LD_ADDR_VAR 0 7
12459: PUSH
12460: LD_VAR 0 5
12464: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12465: LD_ADDR_VAR 0 3
12469: PUSH
12470: LD_INT 1
12472: PPUSH
12473: LD_VAR 0 14
12477: PPUSH
12478: CALL_OW 12
12482: ST_TO_ADDR
// case i of 1 :
12483: LD_VAR 0 3
12487: PUSH
12488: LD_INT 1
12490: DOUBLE
12491: EQUAL
12492: IFTRUE 12496
12494: GO 12513
12496: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12497: LD_VAR 0 1
12501: PPUSH
12502: LD_VAR 0 10
12506: PPUSH
12507: CALL_OW 115
12511: GO 12574
12513: LD_INT 2
12515: DOUBLE
12516: EQUAL
12517: IFTRUE 12521
12519: GO 12543
12521: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12522: LD_VAR 0 1
12526: PPUSH
12527: LD_VAR 0 6
12531: PPUSH
12532: LD_VAR 0 7
12536: PPUSH
12537: CALL_OW 153
12541: GO 12574
12543: LD_INT 3
12545: DOUBLE
12546: EQUAL
12547: IFTRUE 12551
12549: GO 12573
12551: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12552: LD_VAR 0 1
12556: PPUSH
12557: LD_VAR 0 6
12561: PPUSH
12562: LD_VAR 0 7
12566: PPUSH
12567: CALL_OW 154
12571: GO 12574
12573: POP
// end ;
12574: LD_VAR 0 2
12578: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12579: LD_INT 0
12581: PPUSH
12582: PPUSH
12583: PPUSH
12584: PPUSH
12585: PPUSH
12586: PPUSH
// if not unit or not building then
12587: LD_VAR 0 1
12591: NOT
12592: PUSH
12593: LD_VAR 0 2
12597: NOT
12598: OR
12599: IFFALSE 12603
// exit ;
12601: GO 12761
// x := GetX ( building ) ;
12603: LD_ADDR_VAR 0 5
12607: PUSH
12608: LD_VAR 0 2
12612: PPUSH
12613: CALL_OW 250
12617: ST_TO_ADDR
// y := GetY ( building ) ;
12618: LD_ADDR_VAR 0 6
12622: PUSH
12623: LD_VAR 0 2
12627: PPUSH
12628: CALL_OW 251
12632: ST_TO_ADDR
// for i = 0 to 5 do
12633: LD_ADDR_VAR 0 4
12637: PUSH
12638: DOUBLE
12639: LD_INT 0
12641: DEC
12642: ST_TO_ADDR
12643: LD_INT 5
12645: PUSH
12646: FOR_TO
12647: IFFALSE 12759
// begin _x := ShiftX ( x , i , 3 ) ;
12649: LD_ADDR_VAR 0 7
12653: PUSH
12654: LD_VAR 0 5
12658: PPUSH
12659: LD_VAR 0 4
12663: PPUSH
12664: LD_INT 3
12666: PPUSH
12667: CALL_OW 272
12671: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12672: LD_ADDR_VAR 0 8
12676: PUSH
12677: LD_VAR 0 6
12681: PPUSH
12682: LD_VAR 0 4
12686: PPUSH
12687: LD_INT 3
12689: PPUSH
12690: CALL_OW 273
12694: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12695: LD_VAR 0 7
12699: PPUSH
12700: LD_VAR 0 8
12704: PPUSH
12705: CALL_OW 488
12709: NOT
12710: IFFALSE 12714
// continue ;
12712: GO 12646
// if HexInfo ( _x , _y ) = 0 then
12714: LD_VAR 0 7
12718: PPUSH
12719: LD_VAR 0 8
12723: PPUSH
12724: CALL_OW 428
12728: PUSH
12729: LD_INT 0
12731: EQUAL
12732: IFFALSE 12757
// begin ComMoveXY ( unit , _x , _y ) ;
12734: LD_VAR 0 1
12738: PPUSH
12739: LD_VAR 0 7
12743: PPUSH
12744: LD_VAR 0 8
12748: PPUSH
12749: CALL_OW 111
// exit ;
12753: POP
12754: POP
12755: GO 12761
// end ; end ;
12757: GO 12646
12759: POP
12760: POP
// end ;
12761: LD_VAR 0 3
12765: RET
// export function ScanBase ( side , base_area ) ; begin
12766: LD_INT 0
12768: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12769: LD_ADDR_VAR 0 3
12773: PUSH
12774: LD_VAR 0 2
12778: PPUSH
12779: LD_INT 81
12781: PUSH
12782: LD_VAR 0 1
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PPUSH
12791: CALL_OW 70
12795: ST_TO_ADDR
// end ;
12796: LD_VAR 0 3
12800: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12801: LD_INT 0
12803: PPUSH
12804: PPUSH
12805: PPUSH
12806: PPUSH
// result := false ;
12807: LD_ADDR_VAR 0 2
12811: PUSH
12812: LD_INT 0
12814: ST_TO_ADDR
// side := GetSide ( unit ) ;
12815: LD_ADDR_VAR 0 3
12819: PUSH
12820: LD_VAR 0 1
12824: PPUSH
12825: CALL_OW 255
12829: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12830: LD_ADDR_VAR 0 4
12834: PUSH
12835: LD_VAR 0 1
12839: PPUSH
12840: CALL_OW 248
12844: ST_TO_ADDR
// case nat of 1 :
12845: LD_VAR 0 4
12849: PUSH
12850: LD_INT 1
12852: DOUBLE
12853: EQUAL
12854: IFTRUE 12858
12856: GO 12869
12858: POP
// tech := tech_lassight ; 2 :
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_INT 12
12866: ST_TO_ADDR
12867: GO 12908
12869: LD_INT 2
12871: DOUBLE
12872: EQUAL
12873: IFTRUE 12877
12875: GO 12888
12877: POP
// tech := tech_mortar ; 3 :
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_INT 41
12885: ST_TO_ADDR
12886: GO 12908
12888: LD_INT 3
12890: DOUBLE
12891: EQUAL
12892: IFTRUE 12896
12894: GO 12907
12896: POP
// tech := tech_bazooka ; end ;
12897: LD_ADDR_VAR 0 5
12901: PUSH
12902: LD_INT 44
12904: ST_TO_ADDR
12905: GO 12908
12907: POP
// if Researched ( side , tech ) then
12908: LD_VAR 0 3
12912: PPUSH
12913: LD_VAR 0 5
12917: PPUSH
12918: CALL_OW 325
12922: IFFALSE 12949
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12924: LD_ADDR_VAR 0 2
12928: PUSH
12929: LD_INT 5
12931: PUSH
12932: LD_INT 8
12934: PUSH
12935: LD_INT 9
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: PUSH
12943: LD_VAR 0 4
12947: ARRAY
12948: ST_TO_ADDR
// end ;
12949: LD_VAR 0 2
12953: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12954: LD_INT 0
12956: PPUSH
12957: PPUSH
12958: PPUSH
// if not mines then
12959: LD_VAR 0 2
12963: NOT
12964: IFFALSE 12968
// exit ;
12966: GO 13112
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12968: LD_ADDR_VAR 0 5
12972: PUSH
12973: LD_INT 81
12975: PUSH
12976: LD_VAR 0 1
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: PUSH
12985: LD_INT 3
12987: PUSH
12988: LD_INT 21
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PPUSH
13006: CALL_OW 69
13010: ST_TO_ADDR
// for i in mines do
13011: LD_ADDR_VAR 0 4
13015: PUSH
13016: LD_VAR 0 2
13020: PUSH
13021: FOR_IN
13022: IFFALSE 13110
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13024: LD_VAR 0 4
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: PPUSH
13033: LD_VAR 0 4
13037: PUSH
13038: LD_INT 2
13040: ARRAY
13041: PPUSH
13042: CALL_OW 458
13046: NOT
13047: IFFALSE 13051
// continue ;
13049: GO 13021
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13051: LD_VAR 0 4
13055: PUSH
13056: LD_INT 1
13058: ARRAY
13059: PPUSH
13060: LD_VAR 0 4
13064: PUSH
13065: LD_INT 2
13067: ARRAY
13068: PPUSH
13069: CALL_OW 428
13073: PUSH
13074: LD_VAR 0 5
13078: IN
13079: IFFALSE 13108
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13081: LD_VAR 0 4
13085: PUSH
13086: LD_INT 1
13088: ARRAY
13089: PPUSH
13090: LD_VAR 0 4
13094: PUSH
13095: LD_INT 2
13097: ARRAY
13098: PPUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: CALL_OW 456
// end ;
13108: GO 13021
13110: POP
13111: POP
// end ;
13112: LD_VAR 0 3
13116: RET
// export function Count ( array ) ; var i ; begin
13117: LD_INT 0
13119: PPUSH
13120: PPUSH
// result := 0 ;
13121: LD_ADDR_VAR 0 2
13125: PUSH
13126: LD_INT 0
13128: ST_TO_ADDR
// for i in array do
13129: LD_ADDR_VAR 0 3
13133: PUSH
13134: LD_VAR 0 1
13138: PUSH
13139: FOR_IN
13140: IFFALSE 13164
// if i then
13142: LD_VAR 0 3
13146: IFFALSE 13162
// result := result + 1 ;
13148: LD_ADDR_VAR 0 2
13152: PUSH
13153: LD_VAR 0 2
13157: PUSH
13158: LD_INT 1
13160: PLUS
13161: ST_TO_ADDR
13162: GO 13139
13164: POP
13165: POP
// end ;
13166: LD_VAR 0 2
13170: RET
// export function IsEmpty ( building ) ; begin
13171: LD_INT 0
13173: PPUSH
// if not building then
13174: LD_VAR 0 1
13178: NOT
13179: IFFALSE 13183
// exit ;
13181: GO 13226
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13183: LD_ADDR_VAR 0 2
13187: PUSH
13188: LD_VAR 0 1
13192: PUSH
13193: LD_INT 22
13195: PUSH
13196: LD_VAR 0 1
13200: PPUSH
13201: CALL_OW 255
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: LD_INT 58
13212: PUSH
13213: EMPTY
13214: LIST
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PPUSH
13220: CALL_OW 69
13224: IN
13225: ST_TO_ADDR
// end ;
13226: LD_VAR 0 2
13230: RET
// export function IsNotFull ( building ) ; var places ; begin
13231: LD_INT 0
13233: PPUSH
13234: PPUSH
// if not building then
13235: LD_VAR 0 1
13239: NOT
13240: IFFALSE 13244
// exit ;
13242: GO 13415
// result := false ;
13244: LD_ADDR_VAR 0 2
13248: PUSH
13249: LD_INT 0
13251: ST_TO_ADDR
// places := 0 ;
13252: LD_ADDR_VAR 0 3
13256: PUSH
13257: LD_INT 0
13259: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13260: LD_VAR 0 1
13264: PPUSH
13265: CALL_OW 266
13269: PUSH
13270: LD_INT 0
13272: DOUBLE
13273: EQUAL
13274: IFTRUE 13332
13276: LD_INT 1
13278: DOUBLE
13279: EQUAL
13280: IFTRUE 13332
13282: LD_INT 6
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13332
13288: LD_INT 7
13290: DOUBLE
13291: EQUAL
13292: IFTRUE 13332
13294: LD_INT 8
13296: DOUBLE
13297: EQUAL
13298: IFTRUE 13332
13300: LD_INT 4
13302: DOUBLE
13303: EQUAL
13304: IFTRUE 13332
13306: LD_INT 5
13308: DOUBLE
13309: EQUAL
13310: IFTRUE 13332
13312: LD_INT 2
13314: DOUBLE
13315: EQUAL
13316: IFTRUE 13332
13318: LD_INT 3
13320: DOUBLE
13321: EQUAL
13322: IFTRUE 13332
13324: LD_INT 35
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13332
13330: GO 13343
13332: POP
// places := 6 ; b_bunker , b_breastwork :
13333: LD_ADDR_VAR 0 3
13337: PUSH
13338: LD_INT 6
13340: ST_TO_ADDR
13341: GO 13388
13343: LD_INT 32
13345: DOUBLE
13346: EQUAL
13347: IFTRUE 13357
13349: LD_INT 31
13351: DOUBLE
13352: EQUAL
13353: IFTRUE 13357
13355: GO 13368
13357: POP
// places := 1 ; b_control_tower :
13358: LD_ADDR_VAR 0 3
13362: PUSH
13363: LD_INT 1
13365: ST_TO_ADDR
13366: GO 13388
13368: LD_INT 36
13370: DOUBLE
13371: EQUAL
13372: IFTRUE 13376
13374: GO 13387
13376: POP
// places := 3 ; end ;
13377: LD_ADDR_VAR 0 3
13381: PUSH
13382: LD_INT 3
13384: ST_TO_ADDR
13385: GO 13388
13387: POP
// if places then
13388: LD_VAR 0 3
13392: IFFALSE 13415
// result := UnitsInside ( building ) < places ;
13394: LD_ADDR_VAR 0 2
13398: PUSH
13399: LD_VAR 0 1
13403: PPUSH
13404: CALL_OW 313
13408: PUSH
13409: LD_VAR 0 3
13413: LESS
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 2
13419: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
// tmp := [ ] ;
13426: LD_ADDR_VAR 0 3
13430: PUSH
13431: EMPTY
13432: ST_TO_ADDR
// list := [ ] ;
13433: LD_ADDR_VAR 0 5
13437: PUSH
13438: EMPTY
13439: ST_TO_ADDR
// for i = 16 to 25 do
13440: LD_ADDR_VAR 0 4
13444: PUSH
13445: DOUBLE
13446: LD_INT 16
13448: DEC
13449: ST_TO_ADDR
13450: LD_INT 25
13452: PUSH
13453: FOR_TO
13454: IFFALSE 13527
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13456: LD_ADDR_VAR 0 3
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_INT 22
13468: PUSH
13469: LD_VAR 0 1
13473: PPUSH
13474: CALL_OW 255
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PUSH
13483: LD_INT 91
13485: PUSH
13486: LD_VAR 0 1
13490: PUSH
13491: LD_INT 6
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: LIST
13498: PUSH
13499: LD_INT 30
13501: PUSH
13502: LD_VAR 0 4
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: LIST
13515: PUSH
13516: EMPTY
13517: LIST
13518: PPUSH
13519: CALL_OW 69
13523: ADD
13524: ST_TO_ADDR
13525: GO 13453
13527: POP
13528: POP
// for i = 1 to tmp do
13529: LD_ADDR_VAR 0 4
13533: PUSH
13534: DOUBLE
13535: LD_INT 1
13537: DEC
13538: ST_TO_ADDR
13539: LD_VAR 0 3
13543: PUSH
13544: FOR_TO
13545: IFFALSE 13633
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13547: LD_ADDR_VAR 0 5
13551: PUSH
13552: LD_VAR 0 5
13556: PUSH
13557: LD_VAR 0 3
13561: PUSH
13562: LD_VAR 0 4
13566: ARRAY
13567: PPUSH
13568: CALL_OW 266
13572: PUSH
13573: LD_VAR 0 3
13577: PUSH
13578: LD_VAR 0 4
13582: ARRAY
13583: PPUSH
13584: CALL_OW 250
13588: PUSH
13589: LD_VAR 0 3
13593: PUSH
13594: LD_VAR 0 4
13598: ARRAY
13599: PPUSH
13600: CALL_OW 251
13604: PUSH
13605: LD_VAR 0 3
13609: PUSH
13610: LD_VAR 0 4
13614: ARRAY
13615: PPUSH
13616: CALL_OW 254
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: PUSH
13627: EMPTY
13628: LIST
13629: ADD
13630: ST_TO_ADDR
13631: GO 13544
13633: POP
13634: POP
// result := list ;
13635: LD_ADDR_VAR 0 2
13639: PUSH
13640: LD_VAR 0 5
13644: ST_TO_ADDR
// end ;
13645: LD_VAR 0 2
13649: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13650: LD_INT 0
13652: PPUSH
13653: PPUSH
13654: PPUSH
13655: PPUSH
13656: PPUSH
13657: PPUSH
13658: PPUSH
// if not factory then
13659: LD_VAR 0 1
13663: NOT
13664: IFFALSE 13668
// exit ;
13666: GO 14261
// if control = control_apeman then
13668: LD_VAR 0 4
13672: PUSH
13673: LD_INT 5
13675: EQUAL
13676: IFFALSE 13785
// begin tmp := UnitsInside ( factory ) ;
13678: LD_ADDR_VAR 0 8
13682: PUSH
13683: LD_VAR 0 1
13687: PPUSH
13688: CALL_OW 313
13692: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13693: LD_VAR 0 8
13697: PPUSH
13698: LD_INT 25
13700: PUSH
13701: LD_INT 12
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: PPUSH
13708: CALL_OW 72
13712: NOT
13713: IFFALSE 13723
// control := control_manual ;
13715: LD_ADDR_VAR 0 4
13719: PUSH
13720: LD_INT 1
13722: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13723: LD_ADDR_VAR 0 8
13727: PUSH
13728: LD_VAR 0 1
13732: PPUSH
13733: CALL 13420 0 1
13737: ST_TO_ADDR
// if tmp then
13738: LD_VAR 0 8
13742: IFFALSE 13785
// begin for i in tmp do
13744: LD_ADDR_VAR 0 7
13748: PUSH
13749: LD_VAR 0 8
13753: PUSH
13754: FOR_IN
13755: IFFALSE 13783
// if i [ 1 ] = b_ext_radio then
13757: LD_VAR 0 7
13761: PUSH
13762: LD_INT 1
13764: ARRAY
13765: PUSH
13766: LD_INT 22
13768: EQUAL
13769: IFFALSE 13781
// begin control := control_remote ;
13771: LD_ADDR_VAR 0 4
13775: PUSH
13776: LD_INT 2
13778: ST_TO_ADDR
// break ;
13779: GO 13783
// end ;
13781: GO 13754
13783: POP
13784: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 2
13794: PPUSH
13795: LD_VAR 0 3
13799: PPUSH
13800: LD_VAR 0 4
13804: PPUSH
13805: LD_VAR 0 5
13809: PPUSH
13810: CALL_OW 448
13814: IFFALSE 13849
// begin result := [ chassis , engine , control , weapon ] ;
13816: LD_ADDR_VAR 0 6
13820: PUSH
13821: LD_VAR 0 2
13825: PUSH
13826: LD_VAR 0 3
13830: PUSH
13831: LD_VAR 0 4
13835: PUSH
13836: LD_VAR 0 5
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: ST_TO_ADDR
// exit ;
13847: GO 14261
// end ; _chassis := AvailableChassisList ( factory ) ;
13849: LD_ADDR_VAR 0 9
13853: PUSH
13854: LD_VAR 0 1
13858: PPUSH
13859: CALL_OW 475
13863: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13864: LD_ADDR_VAR 0 11
13868: PUSH
13869: LD_VAR 0 1
13873: PPUSH
13874: CALL_OW 476
13878: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13879: LD_ADDR_VAR 0 12
13883: PUSH
13884: LD_VAR 0 1
13888: PPUSH
13889: CALL_OW 477
13893: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13894: LD_ADDR_VAR 0 10
13898: PUSH
13899: LD_VAR 0 1
13903: PPUSH
13904: CALL_OW 478
13908: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13909: LD_VAR 0 9
13913: NOT
13914: PUSH
13915: LD_VAR 0 11
13919: NOT
13920: OR
13921: PUSH
13922: LD_VAR 0 12
13926: NOT
13927: OR
13928: PUSH
13929: LD_VAR 0 10
13933: NOT
13934: OR
13935: IFFALSE 13970
// begin result := [ chassis , engine , control , weapon ] ;
13937: LD_ADDR_VAR 0 6
13941: PUSH
13942: LD_VAR 0 2
13946: PUSH
13947: LD_VAR 0 3
13951: PUSH
13952: LD_VAR 0 4
13956: PUSH
13957: LD_VAR 0 5
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: ST_TO_ADDR
// exit ;
13968: GO 14261
// end ; if not chassis in _chassis then
13970: LD_VAR 0 2
13974: PUSH
13975: LD_VAR 0 9
13979: IN
13980: NOT
13981: IFFALSE 14007
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13983: LD_ADDR_VAR 0 2
13987: PUSH
13988: LD_VAR 0 9
13992: PUSH
13993: LD_INT 1
13995: PPUSH
13996: LD_VAR 0 9
14000: PPUSH
14001: CALL_OW 12
14005: ARRAY
14006: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14007: LD_VAR 0 2
14011: PPUSH
14012: LD_VAR 0 3
14016: PPUSH
14017: CALL 14266 0 2
14021: NOT
14022: IFFALSE 14081
// repeat engine := _engine [ 1 ] ;
14024: LD_ADDR_VAR 0 3
14028: PUSH
14029: LD_VAR 0 11
14033: PUSH
14034: LD_INT 1
14036: ARRAY
14037: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14038: LD_ADDR_VAR 0 11
14042: PUSH
14043: LD_VAR 0 11
14047: PPUSH
14048: LD_INT 1
14050: PPUSH
14051: CALL_OW 3
14055: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14056: LD_VAR 0 2
14060: PPUSH
14061: LD_VAR 0 3
14065: PPUSH
14066: CALL 14266 0 2
14070: PUSH
14071: LD_VAR 0 11
14075: PUSH
14076: EMPTY
14077: EQUAL
14078: OR
14079: IFFALSE 14024
// if not control in _control then
14081: LD_VAR 0 4
14085: PUSH
14086: LD_VAR 0 12
14090: IN
14091: NOT
14092: IFFALSE 14118
// control := _control [ rand ( 1 , _control ) ] ;
14094: LD_ADDR_VAR 0 4
14098: PUSH
14099: LD_VAR 0 12
14103: PUSH
14104: LD_INT 1
14106: PPUSH
14107: LD_VAR 0 12
14111: PPUSH
14112: CALL_OW 12
14116: ARRAY
14117: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14118: LD_VAR 0 2
14122: PPUSH
14123: LD_VAR 0 5
14127: PPUSH
14128: CALL 14486 0 2
14132: NOT
14133: IFFALSE 14192
// repeat weapon := _weapon [ 1 ] ;
14135: LD_ADDR_VAR 0 5
14139: PUSH
14140: LD_VAR 0 10
14144: PUSH
14145: LD_INT 1
14147: ARRAY
14148: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14149: LD_ADDR_VAR 0 10
14153: PUSH
14154: LD_VAR 0 10
14158: PPUSH
14159: LD_INT 1
14161: PPUSH
14162: CALL_OW 3
14166: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14167: LD_VAR 0 2
14171: PPUSH
14172: LD_VAR 0 5
14176: PPUSH
14177: CALL 14486 0 2
14181: PUSH
14182: LD_VAR 0 10
14186: PUSH
14187: EMPTY
14188: EQUAL
14189: OR
14190: IFFALSE 14135
// result := [ ] ;
14192: LD_ADDR_VAR 0 6
14196: PUSH
14197: EMPTY
14198: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14199: LD_VAR 0 1
14203: PPUSH
14204: LD_VAR 0 2
14208: PPUSH
14209: LD_VAR 0 3
14213: PPUSH
14214: LD_VAR 0 4
14218: PPUSH
14219: LD_VAR 0 5
14223: PPUSH
14224: CALL_OW 448
14228: IFFALSE 14261
// result := [ chassis , engine , control , weapon ] ;
14230: LD_ADDR_VAR 0 6
14234: PUSH
14235: LD_VAR 0 2
14239: PUSH
14240: LD_VAR 0 3
14244: PUSH
14245: LD_VAR 0 4
14249: PUSH
14250: LD_VAR 0 5
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: LIST
14259: LIST
14260: ST_TO_ADDR
// end ;
14261: LD_VAR 0 6
14265: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14266: LD_INT 0
14268: PPUSH
// if not chassis or not engine then
14269: LD_VAR 0 1
14273: NOT
14274: PUSH
14275: LD_VAR 0 2
14279: NOT
14280: OR
14281: IFFALSE 14285
// exit ;
14283: GO 14481
// case engine of engine_solar :
14285: LD_VAR 0 2
14289: PUSH
14290: LD_INT 2
14292: DOUBLE
14293: EQUAL
14294: IFTRUE 14298
14296: GO 14336
14298: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14299: LD_ADDR_VAR 0 3
14303: PUSH
14304: LD_INT 11
14306: PUSH
14307: LD_INT 12
14309: PUSH
14310: LD_INT 13
14312: PUSH
14313: LD_INT 14
14315: PUSH
14316: LD_INT 1
14318: PUSH
14319: LD_INT 2
14321: PUSH
14322: LD_INT 3
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: ST_TO_ADDR
14334: GO 14465
14336: LD_INT 1
14338: DOUBLE
14339: EQUAL
14340: IFTRUE 14344
14342: GO 14406
14344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14345: LD_ADDR_VAR 0 3
14349: PUSH
14350: LD_INT 11
14352: PUSH
14353: LD_INT 12
14355: PUSH
14356: LD_INT 13
14358: PUSH
14359: LD_INT 14
14361: PUSH
14362: LD_INT 1
14364: PUSH
14365: LD_INT 2
14367: PUSH
14368: LD_INT 3
14370: PUSH
14371: LD_INT 4
14373: PUSH
14374: LD_INT 5
14376: PUSH
14377: LD_INT 21
14379: PUSH
14380: LD_INT 23
14382: PUSH
14383: LD_INT 22
14385: PUSH
14386: LD_INT 24
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: ST_TO_ADDR
14404: GO 14465
14406: LD_INT 3
14408: DOUBLE
14409: EQUAL
14410: IFTRUE 14414
14412: GO 14464
14414: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14415: LD_ADDR_VAR 0 3
14419: PUSH
14420: LD_INT 13
14422: PUSH
14423: LD_INT 14
14425: PUSH
14426: LD_INT 2
14428: PUSH
14429: LD_INT 3
14431: PUSH
14432: LD_INT 4
14434: PUSH
14435: LD_INT 5
14437: PUSH
14438: LD_INT 21
14440: PUSH
14441: LD_INT 22
14443: PUSH
14444: LD_INT 23
14446: PUSH
14447: LD_INT 24
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: ST_TO_ADDR
14462: GO 14465
14464: POP
// result := ( chassis in result ) ;
14465: LD_ADDR_VAR 0 3
14469: PUSH
14470: LD_VAR 0 1
14474: PUSH
14475: LD_VAR 0 3
14479: IN
14480: ST_TO_ADDR
// end ;
14481: LD_VAR 0 3
14485: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14486: LD_INT 0
14488: PPUSH
// if not chassis or not weapon then
14489: LD_VAR 0 1
14493: NOT
14494: PUSH
14495: LD_VAR 0 2
14499: NOT
14500: OR
14501: IFFALSE 14505
// exit ;
14503: GO 15565
// case weapon of us_machine_gun :
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 2
14512: DOUBLE
14513: EQUAL
14514: IFTRUE 14518
14516: GO 14548
14518: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14519: LD_ADDR_VAR 0 3
14523: PUSH
14524: LD_INT 1
14526: PUSH
14527: LD_INT 2
14529: PUSH
14530: LD_INT 3
14532: PUSH
14533: LD_INT 4
14535: PUSH
14536: LD_INT 5
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: ST_TO_ADDR
14546: GO 15549
14548: LD_INT 3
14550: DOUBLE
14551: EQUAL
14552: IFTRUE 14556
14554: GO 14586
14556: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14557: LD_ADDR_VAR 0 3
14561: PUSH
14562: LD_INT 1
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: LD_INT 3
14570: PUSH
14571: LD_INT 4
14573: PUSH
14574: LD_INT 5
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: ST_TO_ADDR
14584: GO 15549
14586: LD_INT 11
14588: DOUBLE
14589: EQUAL
14590: IFTRUE 14594
14592: GO 14624
14594: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14595: LD_ADDR_VAR 0 3
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 2
14605: PUSH
14606: LD_INT 3
14608: PUSH
14609: LD_INT 4
14611: PUSH
14612: LD_INT 5
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: ST_TO_ADDR
14622: GO 15549
14624: LD_INT 4
14626: DOUBLE
14627: EQUAL
14628: IFTRUE 14632
14630: GO 14658
14632: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14633: LD_ADDR_VAR 0 3
14637: PUSH
14638: LD_INT 2
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: LD_INT 4
14646: PUSH
14647: LD_INT 5
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: ST_TO_ADDR
14656: GO 15549
14658: LD_INT 5
14660: DOUBLE
14661: EQUAL
14662: IFTRUE 14666
14664: GO 14692
14666: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14667: LD_ADDR_VAR 0 3
14671: PUSH
14672: LD_INT 2
14674: PUSH
14675: LD_INT 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: LIST
14688: LIST
14689: ST_TO_ADDR
14690: GO 15549
14692: LD_INT 9
14694: DOUBLE
14695: EQUAL
14696: IFTRUE 14700
14698: GO 14726
14700: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14701: LD_ADDR_VAR 0 3
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: LD_INT 3
14711: PUSH
14712: LD_INT 4
14714: PUSH
14715: LD_INT 5
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: ST_TO_ADDR
14724: GO 15549
14726: LD_INT 7
14728: DOUBLE
14729: EQUAL
14730: IFTRUE 14734
14732: GO 14760
14734: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14735: LD_ADDR_VAR 0 3
14739: PUSH
14740: LD_INT 2
14742: PUSH
14743: LD_INT 3
14745: PUSH
14746: LD_INT 4
14748: PUSH
14749: LD_INT 5
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: ST_TO_ADDR
14758: GO 15549
14760: LD_INT 12
14762: DOUBLE
14763: EQUAL
14764: IFTRUE 14768
14766: GO 14794
14768: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14769: LD_ADDR_VAR 0 3
14773: PUSH
14774: LD_INT 2
14776: PUSH
14777: LD_INT 3
14779: PUSH
14780: LD_INT 4
14782: PUSH
14783: LD_INT 5
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: ST_TO_ADDR
14792: GO 15549
14794: LD_INT 13
14796: DOUBLE
14797: EQUAL
14798: IFTRUE 14802
14800: GO 14828
14802: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14803: LD_ADDR_VAR 0 3
14807: PUSH
14808: LD_INT 2
14810: PUSH
14811: LD_INT 3
14813: PUSH
14814: LD_INT 4
14816: PUSH
14817: LD_INT 5
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: ST_TO_ADDR
14826: GO 15549
14828: LD_INT 14
14830: DOUBLE
14831: EQUAL
14832: IFTRUE 14836
14834: GO 14854
14836: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14837: LD_ADDR_VAR 0 3
14841: PUSH
14842: LD_INT 4
14844: PUSH
14845: LD_INT 5
14847: PUSH
14848: EMPTY
14849: LIST
14850: LIST
14851: ST_TO_ADDR
14852: GO 15549
14854: LD_INT 6
14856: DOUBLE
14857: EQUAL
14858: IFTRUE 14862
14860: GO 14880
14862: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14863: LD_ADDR_VAR 0 3
14867: PUSH
14868: LD_INT 4
14870: PUSH
14871: LD_INT 5
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: ST_TO_ADDR
14878: GO 15549
14880: LD_INT 10
14882: DOUBLE
14883: EQUAL
14884: IFTRUE 14888
14886: GO 14906
14888: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14889: LD_ADDR_VAR 0 3
14893: PUSH
14894: LD_INT 4
14896: PUSH
14897: LD_INT 5
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: ST_TO_ADDR
14904: GO 15549
14906: LD_INT 22
14908: DOUBLE
14909: EQUAL
14910: IFTRUE 14914
14912: GO 14940
14914: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14915: LD_ADDR_VAR 0 3
14919: PUSH
14920: LD_INT 11
14922: PUSH
14923: LD_INT 12
14925: PUSH
14926: LD_INT 13
14928: PUSH
14929: LD_INT 14
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: LIST
14936: LIST
14937: ST_TO_ADDR
14938: GO 15549
14940: LD_INT 23
14942: DOUBLE
14943: EQUAL
14944: IFTRUE 14948
14946: GO 14974
14948: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14949: LD_ADDR_VAR 0 3
14953: PUSH
14954: LD_INT 11
14956: PUSH
14957: LD_INT 12
14959: PUSH
14960: LD_INT 13
14962: PUSH
14963: LD_INT 14
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: ST_TO_ADDR
14972: GO 15549
14974: LD_INT 24
14976: DOUBLE
14977: EQUAL
14978: IFTRUE 14982
14980: GO 15008
14982: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14983: LD_ADDR_VAR 0 3
14987: PUSH
14988: LD_INT 11
14990: PUSH
14991: LD_INT 12
14993: PUSH
14994: LD_INT 13
14996: PUSH
14997: LD_INT 14
14999: PUSH
15000: EMPTY
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: ST_TO_ADDR
15006: GO 15549
15008: LD_INT 30
15010: DOUBLE
15011: EQUAL
15012: IFTRUE 15016
15014: GO 15042
15016: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15017: LD_ADDR_VAR 0 3
15021: PUSH
15022: LD_INT 11
15024: PUSH
15025: LD_INT 12
15027: PUSH
15028: LD_INT 13
15030: PUSH
15031: LD_INT 14
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: ST_TO_ADDR
15040: GO 15549
15042: LD_INT 25
15044: DOUBLE
15045: EQUAL
15046: IFTRUE 15050
15048: GO 15068
15050: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15051: LD_ADDR_VAR 0 3
15055: PUSH
15056: LD_INT 13
15058: PUSH
15059: LD_INT 14
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: ST_TO_ADDR
15066: GO 15549
15068: LD_INT 27
15070: DOUBLE
15071: EQUAL
15072: IFTRUE 15076
15074: GO 15094
15076: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15077: LD_ADDR_VAR 0 3
15081: PUSH
15082: LD_INT 13
15084: PUSH
15085: LD_INT 14
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: ST_TO_ADDR
15092: GO 15549
15094: LD_INT 92
15096: DOUBLE
15097: EQUAL
15098: IFTRUE 15102
15100: GO 15128
15102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15103: LD_ADDR_VAR 0 3
15107: PUSH
15108: LD_INT 11
15110: PUSH
15111: LD_INT 12
15113: PUSH
15114: LD_INT 13
15116: PUSH
15117: LD_INT 14
15119: PUSH
15120: EMPTY
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: ST_TO_ADDR
15126: GO 15549
15128: LD_INT 28
15130: DOUBLE
15131: EQUAL
15132: IFTRUE 15136
15134: GO 15154
15136: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15137: LD_ADDR_VAR 0 3
15141: PUSH
15142: LD_INT 13
15144: PUSH
15145: LD_INT 14
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: ST_TO_ADDR
15152: GO 15549
15154: LD_INT 29
15156: DOUBLE
15157: EQUAL
15158: IFTRUE 15162
15160: GO 15180
15162: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15163: LD_ADDR_VAR 0 3
15167: PUSH
15168: LD_INT 13
15170: PUSH
15171: LD_INT 14
15173: PUSH
15174: EMPTY
15175: LIST
15176: LIST
15177: ST_TO_ADDR
15178: GO 15549
15180: LD_INT 31
15182: DOUBLE
15183: EQUAL
15184: IFTRUE 15188
15186: GO 15206
15188: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15189: LD_ADDR_VAR 0 3
15193: PUSH
15194: LD_INT 13
15196: PUSH
15197: LD_INT 14
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: ST_TO_ADDR
15204: GO 15549
15206: LD_INT 26
15208: DOUBLE
15209: EQUAL
15210: IFTRUE 15214
15212: GO 15232
15214: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_INT 13
15222: PUSH
15223: LD_INT 14
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: ST_TO_ADDR
15230: GO 15549
15232: LD_INT 42
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15266
15240: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15241: LD_ADDR_VAR 0 3
15245: PUSH
15246: LD_INT 21
15248: PUSH
15249: LD_INT 22
15251: PUSH
15252: LD_INT 23
15254: PUSH
15255: LD_INT 24
15257: PUSH
15258: EMPTY
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: ST_TO_ADDR
15264: GO 15549
15266: LD_INT 43
15268: DOUBLE
15269: EQUAL
15270: IFTRUE 15274
15272: GO 15300
15274: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15275: LD_ADDR_VAR 0 3
15279: PUSH
15280: LD_INT 21
15282: PUSH
15283: LD_INT 22
15285: PUSH
15286: LD_INT 23
15288: PUSH
15289: LD_INT 24
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: LIST
15296: LIST
15297: ST_TO_ADDR
15298: GO 15549
15300: LD_INT 44
15302: DOUBLE
15303: EQUAL
15304: IFTRUE 15308
15306: GO 15334
15308: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15309: LD_ADDR_VAR 0 3
15313: PUSH
15314: LD_INT 21
15316: PUSH
15317: LD_INT 22
15319: PUSH
15320: LD_INT 23
15322: PUSH
15323: LD_INT 24
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: ST_TO_ADDR
15332: GO 15549
15334: LD_INT 45
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15368
15342: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15343: LD_ADDR_VAR 0 3
15347: PUSH
15348: LD_INT 21
15350: PUSH
15351: LD_INT 22
15353: PUSH
15354: LD_INT 23
15356: PUSH
15357: LD_INT 24
15359: PUSH
15360: EMPTY
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: ST_TO_ADDR
15366: GO 15549
15368: LD_INT 49
15370: DOUBLE
15371: EQUAL
15372: IFTRUE 15376
15374: GO 15402
15376: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15377: LD_ADDR_VAR 0 3
15381: PUSH
15382: LD_INT 21
15384: PUSH
15385: LD_INT 22
15387: PUSH
15388: LD_INT 23
15390: PUSH
15391: LD_INT 24
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: ST_TO_ADDR
15400: GO 15549
15402: LD_INT 51
15404: DOUBLE
15405: EQUAL
15406: IFTRUE 15410
15408: GO 15436
15410: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_INT 21
15418: PUSH
15419: LD_INT 22
15421: PUSH
15422: LD_INT 23
15424: PUSH
15425: LD_INT 24
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: ST_TO_ADDR
15434: GO 15549
15436: LD_INT 52
15438: DOUBLE
15439: EQUAL
15440: IFTRUE 15444
15442: GO 15470
15444: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15445: LD_ADDR_VAR 0 3
15449: PUSH
15450: LD_INT 21
15452: PUSH
15453: LD_INT 22
15455: PUSH
15456: LD_INT 23
15458: PUSH
15459: LD_INT 24
15461: PUSH
15462: EMPTY
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: ST_TO_ADDR
15468: GO 15549
15470: LD_INT 53
15472: DOUBLE
15473: EQUAL
15474: IFTRUE 15478
15476: GO 15496
15478: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15479: LD_ADDR_VAR 0 3
15483: PUSH
15484: LD_INT 23
15486: PUSH
15487: LD_INT 24
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: ST_TO_ADDR
15494: GO 15549
15496: LD_INT 46
15498: DOUBLE
15499: EQUAL
15500: IFTRUE 15504
15502: GO 15522
15504: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15505: LD_ADDR_VAR 0 3
15509: PUSH
15510: LD_INT 23
15512: PUSH
15513: LD_INT 24
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: ST_TO_ADDR
15520: GO 15549
15522: LD_INT 47
15524: DOUBLE
15525: EQUAL
15526: IFTRUE 15530
15528: GO 15548
15530: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15531: LD_ADDR_VAR 0 3
15535: PUSH
15536: LD_INT 23
15538: PUSH
15539: LD_INT 24
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: ST_TO_ADDR
15546: GO 15549
15548: POP
// result := ( chassis in result ) ;
15549: LD_ADDR_VAR 0 3
15553: PUSH
15554: LD_VAR 0 1
15558: PUSH
15559: LD_VAR 0 3
15563: IN
15564: ST_TO_ADDR
// end ;
15565: LD_VAR 0 3
15569: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15570: LD_INT 0
15572: PPUSH
15573: PPUSH
15574: PPUSH
15575: PPUSH
15576: PPUSH
15577: PPUSH
15578: PPUSH
// result := array ;
15579: LD_ADDR_VAR 0 5
15583: PUSH
15584: LD_VAR 0 1
15588: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15589: LD_VAR 0 1
15593: NOT
15594: PUSH
15595: LD_VAR 0 2
15599: NOT
15600: OR
15601: PUSH
15602: LD_VAR 0 3
15606: NOT
15607: OR
15608: PUSH
15609: LD_VAR 0 2
15613: PUSH
15614: LD_VAR 0 1
15618: GREATER
15619: OR
15620: PUSH
15621: LD_VAR 0 3
15625: PUSH
15626: LD_VAR 0 1
15630: GREATER
15631: OR
15632: IFFALSE 15636
// exit ;
15634: GO 15932
// if direction then
15636: LD_VAR 0 4
15640: IFFALSE 15704
// begin d := 1 ;
15642: LD_ADDR_VAR 0 9
15646: PUSH
15647: LD_INT 1
15649: ST_TO_ADDR
// if i_from > i_to then
15650: LD_VAR 0 2
15654: PUSH
15655: LD_VAR 0 3
15659: GREATER
15660: IFFALSE 15686
// length := ( array - i_from ) + i_to else
15662: LD_ADDR_VAR 0 11
15666: PUSH
15667: LD_VAR 0 1
15671: PUSH
15672: LD_VAR 0 2
15676: MINUS
15677: PUSH
15678: LD_VAR 0 3
15682: PLUS
15683: ST_TO_ADDR
15684: GO 15702
// length := i_to - i_from ;
15686: LD_ADDR_VAR 0 11
15690: PUSH
15691: LD_VAR 0 3
15695: PUSH
15696: LD_VAR 0 2
15700: MINUS
15701: ST_TO_ADDR
// end else
15702: GO 15765
// begin d := - 1 ;
15704: LD_ADDR_VAR 0 9
15708: PUSH
15709: LD_INT 1
15711: NEG
15712: ST_TO_ADDR
// if i_from > i_to then
15713: LD_VAR 0 2
15717: PUSH
15718: LD_VAR 0 3
15722: GREATER
15723: IFFALSE 15743
// length := i_from - i_to else
15725: LD_ADDR_VAR 0 11
15729: PUSH
15730: LD_VAR 0 2
15734: PUSH
15735: LD_VAR 0 3
15739: MINUS
15740: ST_TO_ADDR
15741: GO 15765
// length := ( array - i_to ) + i_from ;
15743: LD_ADDR_VAR 0 11
15747: PUSH
15748: LD_VAR 0 1
15752: PUSH
15753: LD_VAR 0 3
15757: MINUS
15758: PUSH
15759: LD_VAR 0 2
15763: PLUS
15764: ST_TO_ADDR
// end ; if not length then
15765: LD_VAR 0 11
15769: NOT
15770: IFFALSE 15774
// exit ;
15772: GO 15932
// tmp := array ;
15774: LD_ADDR_VAR 0 10
15778: PUSH
15779: LD_VAR 0 1
15783: ST_TO_ADDR
// for i = 1 to length do
15784: LD_ADDR_VAR 0 6
15788: PUSH
15789: DOUBLE
15790: LD_INT 1
15792: DEC
15793: ST_TO_ADDR
15794: LD_VAR 0 11
15798: PUSH
15799: FOR_TO
15800: IFFALSE 15920
// begin for j = 1 to array do
15802: LD_ADDR_VAR 0 7
15806: PUSH
15807: DOUBLE
15808: LD_INT 1
15810: DEC
15811: ST_TO_ADDR
15812: LD_VAR 0 1
15816: PUSH
15817: FOR_TO
15818: IFFALSE 15906
// begin k := j + d ;
15820: LD_ADDR_VAR 0 8
15824: PUSH
15825: LD_VAR 0 7
15829: PUSH
15830: LD_VAR 0 9
15834: PLUS
15835: ST_TO_ADDR
// if k > array then
15836: LD_VAR 0 8
15840: PUSH
15841: LD_VAR 0 1
15845: GREATER
15846: IFFALSE 15856
// k := 1 ;
15848: LD_ADDR_VAR 0 8
15852: PUSH
15853: LD_INT 1
15855: ST_TO_ADDR
// if not k then
15856: LD_VAR 0 8
15860: NOT
15861: IFFALSE 15873
// k := array ;
15863: LD_ADDR_VAR 0 8
15867: PUSH
15868: LD_VAR 0 1
15872: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15873: LD_ADDR_VAR 0 10
15877: PUSH
15878: LD_VAR 0 10
15882: PPUSH
15883: LD_VAR 0 8
15887: PPUSH
15888: LD_VAR 0 1
15892: PUSH
15893: LD_VAR 0 7
15897: ARRAY
15898: PPUSH
15899: CALL_OW 1
15903: ST_TO_ADDR
// end ;
15904: GO 15817
15906: POP
15907: POP
// array := tmp ;
15908: LD_ADDR_VAR 0 1
15912: PUSH
15913: LD_VAR 0 10
15917: ST_TO_ADDR
// end ;
15918: GO 15799
15920: POP
15921: POP
// result := array ;
15922: LD_ADDR_VAR 0 5
15926: PUSH
15927: LD_VAR 0 1
15931: ST_TO_ADDR
// end ;
15932: LD_VAR 0 5
15936: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15937: LD_INT 0
15939: PPUSH
15940: PPUSH
// result := 0 ;
15941: LD_ADDR_VAR 0 3
15945: PUSH
15946: LD_INT 0
15948: ST_TO_ADDR
// if not array or not value in array then
15949: LD_VAR 0 1
15953: NOT
15954: PUSH
15955: LD_VAR 0 2
15959: PUSH
15960: LD_VAR 0 1
15964: IN
15965: NOT
15966: OR
15967: IFFALSE 15971
// exit ;
15969: GO 16025
// for i = 1 to array do
15971: LD_ADDR_VAR 0 4
15975: PUSH
15976: DOUBLE
15977: LD_INT 1
15979: DEC
15980: ST_TO_ADDR
15981: LD_VAR 0 1
15985: PUSH
15986: FOR_TO
15987: IFFALSE 16023
// if value = array [ i ] then
15989: LD_VAR 0 2
15993: PUSH
15994: LD_VAR 0 1
15998: PUSH
15999: LD_VAR 0 4
16003: ARRAY
16004: EQUAL
16005: IFFALSE 16021
// begin result := i ;
16007: LD_ADDR_VAR 0 3
16011: PUSH
16012: LD_VAR 0 4
16016: ST_TO_ADDR
// exit ;
16017: POP
16018: POP
16019: GO 16025
// end ;
16021: GO 15986
16023: POP
16024: POP
// end ;
16025: LD_VAR 0 3
16029: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16030: LD_INT 0
16032: PPUSH
// vc_chassis := chassis ;
16033: LD_ADDR_OWVAR 37
16037: PUSH
16038: LD_VAR 0 1
16042: ST_TO_ADDR
// vc_engine := engine ;
16043: LD_ADDR_OWVAR 39
16047: PUSH
16048: LD_VAR 0 2
16052: ST_TO_ADDR
// vc_control := control ;
16053: LD_ADDR_OWVAR 38
16057: PUSH
16058: LD_VAR 0 3
16062: ST_TO_ADDR
// vc_weapon := weapon ;
16063: LD_ADDR_OWVAR 40
16067: PUSH
16068: LD_VAR 0 4
16072: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16073: LD_ADDR_OWVAR 41
16077: PUSH
16078: LD_VAR 0 5
16082: ST_TO_ADDR
// end ;
16083: LD_VAR 0 6
16087: RET
// export function WantPlant ( unit ) ; var task ; begin
16088: LD_INT 0
16090: PPUSH
16091: PPUSH
// result := false ;
16092: LD_ADDR_VAR 0 2
16096: PUSH
16097: LD_INT 0
16099: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16100: LD_ADDR_VAR 0 3
16104: PUSH
16105: LD_VAR 0 1
16109: PPUSH
16110: CALL_OW 437
16114: ST_TO_ADDR
// if task then
16115: LD_VAR 0 3
16119: IFFALSE 16147
// if task [ 1 ] [ 1 ] = p then
16121: LD_VAR 0 3
16125: PUSH
16126: LD_INT 1
16128: ARRAY
16129: PUSH
16130: LD_INT 1
16132: ARRAY
16133: PUSH
16134: LD_STRING p
16136: EQUAL
16137: IFFALSE 16147
// result := true ;
16139: LD_ADDR_VAR 0 2
16143: PUSH
16144: LD_INT 1
16146: ST_TO_ADDR
// end ;
16147: LD_VAR 0 2
16151: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16152: LD_INT 0
16154: PPUSH
16155: PPUSH
16156: PPUSH
16157: PPUSH
// if pos < 1 then
16158: LD_VAR 0 2
16162: PUSH
16163: LD_INT 1
16165: LESS
16166: IFFALSE 16170
// exit ;
16168: GO 16473
// if pos = 1 then
16170: LD_VAR 0 2
16174: PUSH
16175: LD_INT 1
16177: EQUAL
16178: IFFALSE 16211
// result := Replace ( arr , pos [ 1 ] , value ) else
16180: LD_ADDR_VAR 0 4
16184: PUSH
16185: LD_VAR 0 1
16189: PPUSH
16190: LD_VAR 0 2
16194: PUSH
16195: LD_INT 1
16197: ARRAY
16198: PPUSH
16199: LD_VAR 0 3
16203: PPUSH
16204: CALL_OW 1
16208: ST_TO_ADDR
16209: GO 16473
// begin tmp := arr ;
16211: LD_ADDR_VAR 0 6
16215: PUSH
16216: LD_VAR 0 1
16220: ST_TO_ADDR
// s_arr := [ tmp ] ;
16221: LD_ADDR_VAR 0 7
16225: PUSH
16226: LD_VAR 0 6
16230: PUSH
16231: EMPTY
16232: LIST
16233: ST_TO_ADDR
// for i = 1 to pos - 1 do
16234: LD_ADDR_VAR 0 5
16238: PUSH
16239: DOUBLE
16240: LD_INT 1
16242: DEC
16243: ST_TO_ADDR
16244: LD_VAR 0 2
16248: PUSH
16249: LD_INT 1
16251: MINUS
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16299
// begin tmp := tmp [ pos [ i ] ] ;
16256: LD_ADDR_VAR 0 6
16260: PUSH
16261: LD_VAR 0 6
16265: PUSH
16266: LD_VAR 0 2
16270: PUSH
16271: LD_VAR 0 5
16275: ARRAY
16276: ARRAY
16277: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16278: LD_ADDR_VAR 0 7
16282: PUSH
16283: LD_VAR 0 7
16287: PUSH
16288: LD_VAR 0 6
16292: PUSH
16293: EMPTY
16294: LIST
16295: ADD
16296: ST_TO_ADDR
// end ;
16297: GO 16253
16299: POP
16300: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16301: LD_ADDR_VAR 0 6
16305: PUSH
16306: LD_VAR 0 6
16310: PPUSH
16311: LD_VAR 0 2
16315: PUSH
16316: LD_VAR 0 2
16320: ARRAY
16321: PPUSH
16322: LD_VAR 0 3
16326: PPUSH
16327: CALL_OW 1
16331: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16332: LD_ADDR_VAR 0 7
16336: PUSH
16337: LD_VAR 0 7
16341: PPUSH
16342: LD_VAR 0 7
16346: PPUSH
16347: LD_VAR 0 6
16351: PPUSH
16352: CALL_OW 1
16356: ST_TO_ADDR
// for i = s_arr downto 2 do
16357: LD_ADDR_VAR 0 5
16361: PUSH
16362: DOUBLE
16363: LD_VAR 0 7
16367: INC
16368: ST_TO_ADDR
16369: LD_INT 2
16371: PUSH
16372: FOR_DOWNTO
16373: IFFALSE 16457
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16375: LD_ADDR_VAR 0 6
16379: PUSH
16380: LD_VAR 0 7
16384: PUSH
16385: LD_VAR 0 5
16389: PUSH
16390: LD_INT 1
16392: MINUS
16393: ARRAY
16394: PPUSH
16395: LD_VAR 0 2
16399: PUSH
16400: LD_VAR 0 5
16404: PUSH
16405: LD_INT 1
16407: MINUS
16408: ARRAY
16409: PPUSH
16410: LD_VAR 0 7
16414: PUSH
16415: LD_VAR 0 5
16419: ARRAY
16420: PPUSH
16421: CALL_OW 1
16425: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16426: LD_ADDR_VAR 0 7
16430: PUSH
16431: LD_VAR 0 7
16435: PPUSH
16436: LD_VAR 0 5
16440: PUSH
16441: LD_INT 1
16443: MINUS
16444: PPUSH
16445: LD_VAR 0 6
16449: PPUSH
16450: CALL_OW 1
16454: ST_TO_ADDR
// end ;
16455: GO 16372
16457: POP
16458: POP
// result := s_arr [ 1 ] ;
16459: LD_ADDR_VAR 0 4
16463: PUSH
16464: LD_VAR 0 7
16468: PUSH
16469: LD_INT 1
16471: ARRAY
16472: ST_TO_ADDR
// end ; end ;
16473: LD_VAR 0 4
16477: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
// if not list then
16482: LD_VAR 0 1
16486: NOT
16487: IFFALSE 16491
// exit ;
16489: GO 16582
// i := list [ pos1 ] ;
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: LD_VAR 0 1
16500: PUSH
16501: LD_VAR 0 2
16505: ARRAY
16506: ST_TO_ADDR
// if not i then
16507: LD_VAR 0 5
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16582
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16516: LD_ADDR_VAR 0 1
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: LD_VAR 0 2
16530: PPUSH
16531: LD_VAR 0 1
16535: PUSH
16536: LD_VAR 0 3
16540: ARRAY
16541: PPUSH
16542: CALL_OW 1
16546: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16547: LD_ADDR_VAR 0 1
16551: PUSH
16552: LD_VAR 0 1
16556: PPUSH
16557: LD_VAR 0 3
16561: PPUSH
16562: LD_VAR 0 5
16566: PPUSH
16567: CALL_OW 1
16571: ST_TO_ADDR
// result := list ;
16572: LD_ADDR_VAR 0 4
16576: PUSH
16577: LD_VAR 0 1
16581: ST_TO_ADDR
// end ;
16582: LD_VAR 0 4
16586: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16587: LD_INT 0
16589: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16590: LD_ADDR_VAR 0 5
16594: PUSH
16595: LD_VAR 0 1
16599: PPUSH
16600: CALL_OW 250
16604: PPUSH
16605: LD_VAR 0 1
16609: PPUSH
16610: CALL_OW 251
16614: PPUSH
16615: LD_VAR 0 2
16619: PPUSH
16620: LD_VAR 0 3
16624: PPUSH
16625: LD_VAR 0 4
16629: PPUSH
16630: CALL 16640 0 5
16634: ST_TO_ADDR
// end ;
16635: LD_VAR 0 5
16639: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16640: LD_INT 0
16642: PPUSH
16643: PPUSH
16644: PPUSH
16645: PPUSH
// if not list then
16646: LD_VAR 0 3
16650: NOT
16651: IFFALSE 16655
// exit ;
16653: GO 17043
// result := [ ] ;
16655: LD_ADDR_VAR 0 6
16659: PUSH
16660: EMPTY
16661: ST_TO_ADDR
// for i in list do
16662: LD_ADDR_VAR 0 7
16666: PUSH
16667: LD_VAR 0 3
16671: PUSH
16672: FOR_IN
16673: IFFALSE 16875
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16675: LD_ADDR_VAR 0 9
16679: PUSH
16680: LD_VAR 0 7
16684: PPUSH
16685: LD_VAR 0 1
16689: PPUSH
16690: LD_VAR 0 2
16694: PPUSH
16695: CALL_OW 297
16699: ST_TO_ADDR
// if not result then
16700: LD_VAR 0 6
16704: NOT
16705: IFFALSE 16731
// result := [ [ i , tmp ] ] else
16707: LD_ADDR_VAR 0 6
16711: PUSH
16712: LD_VAR 0 7
16716: PUSH
16717: LD_VAR 0 9
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: EMPTY
16727: LIST
16728: ST_TO_ADDR
16729: GO 16873
// begin if result [ result ] [ 2 ] < tmp then
16731: LD_VAR 0 6
16735: PUSH
16736: LD_VAR 0 6
16740: ARRAY
16741: PUSH
16742: LD_INT 2
16744: ARRAY
16745: PUSH
16746: LD_VAR 0 9
16750: LESS
16751: IFFALSE 16793
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16753: LD_ADDR_VAR 0 6
16757: PUSH
16758: LD_VAR 0 6
16762: PPUSH
16763: LD_VAR 0 6
16767: PUSH
16768: LD_INT 1
16770: PLUS
16771: PPUSH
16772: LD_VAR 0 7
16776: PUSH
16777: LD_VAR 0 9
16781: PUSH
16782: EMPTY
16783: LIST
16784: LIST
16785: PPUSH
16786: CALL_OW 2
16790: ST_TO_ADDR
16791: GO 16873
// for j = 1 to result do
16793: LD_ADDR_VAR 0 8
16797: PUSH
16798: DOUBLE
16799: LD_INT 1
16801: DEC
16802: ST_TO_ADDR
16803: LD_VAR 0 6
16807: PUSH
16808: FOR_TO
16809: IFFALSE 16871
// begin if tmp < result [ j ] [ 2 ] then
16811: LD_VAR 0 9
16815: PUSH
16816: LD_VAR 0 6
16820: PUSH
16821: LD_VAR 0 8
16825: ARRAY
16826: PUSH
16827: LD_INT 2
16829: ARRAY
16830: LESS
16831: IFFALSE 16869
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16833: LD_ADDR_VAR 0 6
16837: PUSH
16838: LD_VAR 0 6
16842: PPUSH
16843: LD_VAR 0 8
16847: PPUSH
16848: LD_VAR 0 7
16852: PUSH
16853: LD_VAR 0 9
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 2
16866: ST_TO_ADDR
// break ;
16867: GO 16871
// end ; end ;
16869: GO 16808
16871: POP
16872: POP
// end ; end ;
16873: GO 16672
16875: POP
16876: POP
// if result and not asc then
16877: LD_VAR 0 6
16881: PUSH
16882: LD_VAR 0 4
16886: NOT
16887: AND
16888: IFFALSE 16963
// begin tmp := result ;
16890: LD_ADDR_VAR 0 9
16894: PUSH
16895: LD_VAR 0 6
16899: ST_TO_ADDR
// for i = tmp downto 1 do
16900: LD_ADDR_VAR 0 7
16904: PUSH
16905: DOUBLE
16906: LD_VAR 0 9
16910: INC
16911: ST_TO_ADDR
16912: LD_INT 1
16914: PUSH
16915: FOR_DOWNTO
16916: IFFALSE 16961
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16918: LD_ADDR_VAR 0 6
16922: PUSH
16923: LD_VAR 0 6
16927: PPUSH
16928: LD_VAR 0 9
16932: PUSH
16933: LD_VAR 0 7
16937: MINUS
16938: PUSH
16939: LD_INT 1
16941: PLUS
16942: PPUSH
16943: LD_VAR 0 9
16947: PUSH
16948: LD_VAR 0 7
16952: ARRAY
16953: PPUSH
16954: CALL_OW 1
16958: ST_TO_ADDR
16959: GO 16915
16961: POP
16962: POP
// end ; tmp := [ ] ;
16963: LD_ADDR_VAR 0 9
16967: PUSH
16968: EMPTY
16969: ST_TO_ADDR
// if mode then
16970: LD_VAR 0 5
16974: IFFALSE 17043
// begin for i = 1 to result do
16976: LD_ADDR_VAR 0 7
16980: PUSH
16981: DOUBLE
16982: LD_INT 1
16984: DEC
16985: ST_TO_ADDR
16986: LD_VAR 0 6
16990: PUSH
16991: FOR_TO
16992: IFFALSE 17031
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16994: LD_ADDR_VAR 0 9
16998: PUSH
16999: LD_VAR 0 9
17003: PPUSH
17004: LD_VAR 0 7
17008: PPUSH
17009: LD_VAR 0 6
17013: PUSH
17014: LD_VAR 0 7
17018: ARRAY
17019: PUSH
17020: LD_INT 1
17022: ARRAY
17023: PPUSH
17024: CALL_OW 1
17028: ST_TO_ADDR
17029: GO 16991
17031: POP
17032: POP
// result := tmp ;
17033: LD_ADDR_VAR 0 6
17037: PUSH
17038: LD_VAR 0 9
17042: ST_TO_ADDR
// end ; end ;
17043: LD_VAR 0 6
17047: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17048: LD_INT 0
17050: PPUSH
17051: PPUSH
17052: PPUSH
17053: PPUSH
17054: PPUSH
17055: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17056: LD_ADDR_VAR 0 5
17060: PUSH
17061: LD_INT 0
17063: PUSH
17064: LD_INT 0
17066: PUSH
17067: LD_INT 0
17069: PUSH
17070: EMPTY
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: LIST
17076: LIST
17077: ST_TO_ADDR
// if not x or not y then
17078: LD_VAR 0 2
17082: NOT
17083: PUSH
17084: LD_VAR 0 3
17088: NOT
17089: OR
17090: IFFALSE 17094
// exit ;
17092: GO 18744
// if not range then
17094: LD_VAR 0 4
17098: NOT
17099: IFFALSE 17109
// range := 10 ;
17101: LD_ADDR_VAR 0 4
17105: PUSH
17106: LD_INT 10
17108: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17109: LD_ADDR_VAR 0 8
17113: PUSH
17114: LD_INT 81
17116: PUSH
17117: LD_VAR 0 1
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: PUSH
17126: LD_INT 92
17128: PUSH
17129: LD_VAR 0 2
17133: PUSH
17134: LD_VAR 0 3
17138: PUSH
17139: LD_VAR 0 4
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: LIST
17148: LIST
17149: PUSH
17150: LD_INT 3
17152: PUSH
17153: LD_INT 21
17155: PUSH
17156: LD_INT 3
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: LIST
17171: PPUSH
17172: CALL_OW 69
17176: ST_TO_ADDR
// if not tmp then
17177: LD_VAR 0 8
17181: NOT
17182: IFFALSE 17186
// exit ;
17184: GO 18744
// for i in tmp do
17186: LD_ADDR_VAR 0 6
17190: PUSH
17191: LD_VAR 0 8
17195: PUSH
17196: FOR_IN
17197: IFFALSE 18719
// begin points := [ 0 , 0 , 0 ] ;
17199: LD_ADDR_VAR 0 9
17203: PUSH
17204: LD_INT 0
17206: PUSH
17207: LD_INT 0
17209: PUSH
17210: LD_INT 0
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: LIST
17217: ST_TO_ADDR
// bpoints := 1 ;
17218: LD_ADDR_VAR 0 10
17222: PUSH
17223: LD_INT 1
17225: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17226: LD_VAR 0 6
17230: PPUSH
17231: CALL_OW 247
17235: PUSH
17236: LD_INT 1
17238: DOUBLE
17239: EQUAL
17240: IFTRUE 17244
17242: GO 17822
17244: POP
// begin if GetClass ( i ) = 1 then
17245: LD_VAR 0 6
17249: PPUSH
17250: CALL_OW 257
17254: PUSH
17255: LD_INT 1
17257: EQUAL
17258: IFFALSE 17279
// points := [ 10 , 5 , 3 ] ;
17260: LD_ADDR_VAR 0 9
17264: PUSH
17265: LD_INT 10
17267: PUSH
17268: LD_INT 5
17270: PUSH
17271: LD_INT 3
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: LIST
17278: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17279: LD_VAR 0 6
17283: PPUSH
17284: CALL_OW 257
17288: PUSH
17289: LD_INT 2
17291: PUSH
17292: LD_INT 3
17294: PUSH
17295: LD_INT 4
17297: PUSH
17298: EMPTY
17299: LIST
17300: LIST
17301: LIST
17302: IN
17303: IFFALSE 17324
// points := [ 3 , 2 , 1 ] ;
17305: LD_ADDR_VAR 0 9
17309: PUSH
17310: LD_INT 3
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 1
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: LIST
17323: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17324: LD_VAR 0 6
17328: PPUSH
17329: CALL_OW 257
17333: PUSH
17334: LD_INT 5
17336: EQUAL
17337: IFFALSE 17358
// points := [ 130 , 5 , 2 ] ;
17339: LD_ADDR_VAR 0 9
17343: PUSH
17344: LD_INT 130
17346: PUSH
17347: LD_INT 5
17349: PUSH
17350: LD_INT 2
17352: PUSH
17353: EMPTY
17354: LIST
17355: LIST
17356: LIST
17357: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17358: LD_VAR 0 6
17362: PPUSH
17363: CALL_OW 257
17367: PUSH
17368: LD_INT 8
17370: EQUAL
17371: IFFALSE 17392
// points := [ 35 , 35 , 30 ] ;
17373: LD_ADDR_VAR 0 9
17377: PUSH
17378: LD_INT 35
17380: PUSH
17381: LD_INT 35
17383: PUSH
17384: LD_INT 30
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: LIST
17391: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17392: LD_VAR 0 6
17396: PPUSH
17397: CALL_OW 257
17401: PUSH
17402: LD_INT 9
17404: EQUAL
17405: IFFALSE 17426
// points := [ 20 , 55 , 40 ] ;
17407: LD_ADDR_VAR 0 9
17411: PUSH
17412: LD_INT 20
17414: PUSH
17415: LD_INT 55
17417: PUSH
17418: LD_INT 40
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17426: LD_VAR 0 6
17430: PPUSH
17431: CALL_OW 257
17435: PUSH
17436: LD_INT 12
17438: PUSH
17439: LD_INT 16
17441: PUSH
17442: EMPTY
17443: LIST
17444: LIST
17445: IN
17446: IFFALSE 17467
// points := [ 5 , 3 , 2 ] ;
17448: LD_ADDR_VAR 0 9
17452: PUSH
17453: LD_INT 5
17455: PUSH
17456: LD_INT 3
17458: PUSH
17459: LD_INT 2
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: LIST
17466: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17467: LD_VAR 0 6
17471: PPUSH
17472: CALL_OW 257
17476: PUSH
17477: LD_INT 17
17479: EQUAL
17480: IFFALSE 17501
// points := [ 100 , 50 , 75 ] ;
17482: LD_ADDR_VAR 0 9
17486: PUSH
17487: LD_INT 100
17489: PUSH
17490: LD_INT 50
17492: PUSH
17493: LD_INT 75
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17501: LD_VAR 0 6
17505: PPUSH
17506: CALL_OW 257
17510: PUSH
17511: LD_INT 15
17513: EQUAL
17514: IFFALSE 17535
// points := [ 10 , 5 , 3 ] ;
17516: LD_ADDR_VAR 0 9
17520: PUSH
17521: LD_INT 10
17523: PUSH
17524: LD_INT 5
17526: PUSH
17527: LD_INT 3
17529: PUSH
17530: EMPTY
17531: LIST
17532: LIST
17533: LIST
17534: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17535: LD_VAR 0 6
17539: PPUSH
17540: CALL_OW 257
17544: PUSH
17545: LD_INT 14
17547: EQUAL
17548: IFFALSE 17569
// points := [ 10 , 0 , 0 ] ;
17550: LD_ADDR_VAR 0 9
17554: PUSH
17555: LD_INT 10
17557: PUSH
17558: LD_INT 0
17560: PUSH
17561: LD_INT 0
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: LIST
17568: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17569: LD_VAR 0 6
17573: PPUSH
17574: CALL_OW 257
17578: PUSH
17579: LD_INT 11
17581: EQUAL
17582: IFFALSE 17603
// points := [ 30 , 10 , 5 ] ;
17584: LD_ADDR_VAR 0 9
17588: PUSH
17589: LD_INT 30
17591: PUSH
17592: LD_INT 10
17594: PUSH
17595: LD_INT 5
17597: PUSH
17598: EMPTY
17599: LIST
17600: LIST
17601: LIST
17602: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17603: LD_VAR 0 1
17607: PPUSH
17608: LD_INT 5
17610: PPUSH
17611: CALL_OW 321
17615: PUSH
17616: LD_INT 2
17618: EQUAL
17619: IFFALSE 17636
// bpoints := bpoints * 1.8 ;
17621: LD_ADDR_VAR 0 10
17625: PUSH
17626: LD_VAR 0 10
17630: PUSH
17631: LD_REAL  1.80000000000000E+0000
17634: MUL
17635: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17636: LD_VAR 0 6
17640: PPUSH
17641: CALL_OW 257
17645: PUSH
17646: LD_INT 1
17648: PUSH
17649: LD_INT 2
17651: PUSH
17652: LD_INT 3
17654: PUSH
17655: LD_INT 4
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: LIST
17662: LIST
17663: IN
17664: PUSH
17665: LD_VAR 0 1
17669: PPUSH
17670: LD_INT 51
17672: PPUSH
17673: CALL_OW 321
17677: PUSH
17678: LD_INT 2
17680: EQUAL
17681: AND
17682: IFFALSE 17699
// bpoints := bpoints * 1.2 ;
17684: LD_ADDR_VAR 0 10
17688: PUSH
17689: LD_VAR 0 10
17693: PUSH
17694: LD_REAL  1.20000000000000E+0000
17697: MUL
17698: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17699: LD_VAR 0 6
17703: PPUSH
17704: CALL_OW 257
17708: PUSH
17709: LD_INT 5
17711: PUSH
17712: LD_INT 7
17714: PUSH
17715: LD_INT 9
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: LIST
17722: IN
17723: PUSH
17724: LD_VAR 0 1
17728: PPUSH
17729: LD_INT 52
17731: PPUSH
17732: CALL_OW 321
17736: PUSH
17737: LD_INT 2
17739: EQUAL
17740: AND
17741: IFFALSE 17758
// bpoints := bpoints * 1.5 ;
17743: LD_ADDR_VAR 0 10
17747: PUSH
17748: LD_VAR 0 10
17752: PUSH
17753: LD_REAL  1.50000000000000E+0000
17756: MUL
17757: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17758: LD_VAR 0 1
17762: PPUSH
17763: LD_INT 66
17765: PPUSH
17766: CALL_OW 321
17770: PUSH
17771: LD_INT 2
17773: EQUAL
17774: IFFALSE 17791
// bpoints := bpoints * 1.1 ;
17776: LD_ADDR_VAR 0 10
17780: PUSH
17781: LD_VAR 0 10
17785: PUSH
17786: LD_REAL  1.10000000000000E+0000
17789: MUL
17790: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17791: LD_ADDR_VAR 0 10
17795: PUSH
17796: LD_VAR 0 10
17800: PUSH
17801: LD_VAR 0 6
17805: PPUSH
17806: LD_INT 1
17808: PPUSH
17809: CALL_OW 259
17813: PUSH
17814: LD_REAL  1.15000000000000E+0000
17817: MUL
17818: MUL
17819: ST_TO_ADDR
// end ; unit_vehicle :
17820: GO 18648
17822: LD_INT 2
17824: DOUBLE
17825: EQUAL
17826: IFTRUE 17830
17828: GO 18636
17830: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17831: LD_VAR 0 6
17835: PPUSH
17836: CALL_OW 264
17840: PUSH
17841: LD_INT 2
17843: PUSH
17844: LD_INT 42
17846: PUSH
17847: LD_INT 24
17849: PUSH
17850: EMPTY
17851: LIST
17852: LIST
17853: LIST
17854: IN
17855: IFFALSE 17876
// points := [ 25 , 5 , 3 ] ;
17857: LD_ADDR_VAR 0 9
17861: PUSH
17862: LD_INT 25
17864: PUSH
17865: LD_INT 5
17867: PUSH
17868: LD_INT 3
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: LIST
17875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17876: LD_VAR 0 6
17880: PPUSH
17881: CALL_OW 264
17885: PUSH
17886: LD_INT 4
17888: PUSH
17889: LD_INT 43
17891: PUSH
17892: LD_INT 25
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: LIST
17899: IN
17900: IFFALSE 17921
// points := [ 40 , 15 , 5 ] ;
17902: LD_ADDR_VAR 0 9
17906: PUSH
17907: LD_INT 40
17909: PUSH
17910: LD_INT 15
17912: PUSH
17913: LD_INT 5
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: LIST
17920: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17921: LD_VAR 0 6
17925: PPUSH
17926: CALL_OW 264
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 23
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: IN
17941: IFFALSE 17962
// points := [ 7 , 25 , 8 ] ;
17943: LD_ADDR_VAR 0 9
17947: PUSH
17948: LD_INT 7
17950: PUSH
17951: LD_INT 25
17953: PUSH
17954: LD_INT 8
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: LIST
17961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17962: LD_VAR 0 6
17966: PPUSH
17967: CALL_OW 264
17971: PUSH
17972: LD_INT 5
17974: PUSH
17975: LD_INT 27
17977: PUSH
17978: LD_INT 44
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: LIST
17985: IN
17986: IFFALSE 18007
// points := [ 14 , 50 , 16 ] ;
17988: LD_ADDR_VAR 0 9
17992: PUSH
17993: LD_INT 14
17995: PUSH
17996: LD_INT 50
17998: PUSH
17999: LD_INT 16
18001: PUSH
18002: EMPTY
18003: LIST
18004: LIST
18005: LIST
18006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18007: LD_VAR 0 6
18011: PPUSH
18012: CALL_OW 264
18016: PUSH
18017: LD_INT 6
18019: PUSH
18020: LD_INT 46
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: IN
18027: IFFALSE 18048
// points := [ 32 , 120 , 70 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 32
18036: PUSH
18037: LD_INT 120
18039: PUSH
18040: LD_INT 70
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 264
18057: PUSH
18058: LD_INT 7
18060: PUSH
18061: LD_INT 28
18063: PUSH
18064: LD_INT 45
18066: PUSH
18067: LD_INT 92
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: LIST
18074: LIST
18075: IN
18076: IFFALSE 18097
// points := [ 35 , 20 , 45 ] ;
18078: LD_ADDR_VAR 0 9
18082: PUSH
18083: LD_INT 35
18085: PUSH
18086: LD_INT 20
18088: PUSH
18089: LD_INT 45
18091: PUSH
18092: EMPTY
18093: LIST
18094: LIST
18095: LIST
18096: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18097: LD_VAR 0 6
18101: PPUSH
18102: CALL_OW 264
18106: PUSH
18107: LD_INT 47
18109: PUSH
18110: EMPTY
18111: LIST
18112: IN
18113: IFFALSE 18134
// points := [ 67 , 45 , 75 ] ;
18115: LD_ADDR_VAR 0 9
18119: PUSH
18120: LD_INT 67
18122: PUSH
18123: LD_INT 45
18125: PUSH
18126: LD_INT 75
18128: PUSH
18129: EMPTY
18130: LIST
18131: LIST
18132: LIST
18133: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18134: LD_VAR 0 6
18138: PPUSH
18139: CALL_OW 264
18143: PUSH
18144: LD_INT 26
18146: PUSH
18147: EMPTY
18148: LIST
18149: IN
18150: IFFALSE 18171
// points := [ 120 , 30 , 80 ] ;
18152: LD_ADDR_VAR 0 9
18156: PUSH
18157: LD_INT 120
18159: PUSH
18160: LD_INT 30
18162: PUSH
18163: LD_INT 80
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18171: LD_VAR 0 6
18175: PPUSH
18176: CALL_OW 264
18180: PUSH
18181: LD_INT 22
18183: PUSH
18184: EMPTY
18185: LIST
18186: IN
18187: IFFALSE 18208
// points := [ 40 , 1 , 1 ] ;
18189: LD_ADDR_VAR 0 9
18193: PUSH
18194: LD_INT 40
18196: PUSH
18197: LD_INT 1
18199: PUSH
18200: LD_INT 1
18202: PUSH
18203: EMPTY
18204: LIST
18205: LIST
18206: LIST
18207: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18208: LD_VAR 0 6
18212: PPUSH
18213: CALL_OW 264
18217: PUSH
18218: LD_INT 29
18220: PUSH
18221: EMPTY
18222: LIST
18223: IN
18224: IFFALSE 18245
// points := [ 70 , 200 , 400 ] ;
18226: LD_ADDR_VAR 0 9
18230: PUSH
18231: LD_INT 70
18233: PUSH
18234: LD_INT 200
18236: PUSH
18237: LD_INT 400
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: LIST
18244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18245: LD_VAR 0 6
18249: PPUSH
18250: CALL_OW 264
18254: PUSH
18255: LD_INT 14
18257: PUSH
18258: LD_INT 53
18260: PUSH
18261: EMPTY
18262: LIST
18263: LIST
18264: IN
18265: IFFALSE 18286
// points := [ 40 , 10 , 20 ] ;
18267: LD_ADDR_VAR 0 9
18271: PUSH
18272: LD_INT 40
18274: PUSH
18275: LD_INT 10
18277: PUSH
18278: LD_INT 20
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: LIST
18285: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18286: LD_VAR 0 6
18290: PPUSH
18291: CALL_OW 264
18295: PUSH
18296: LD_INT 9
18298: PUSH
18299: EMPTY
18300: LIST
18301: IN
18302: IFFALSE 18323
// points := [ 5 , 70 , 20 ] ;
18304: LD_ADDR_VAR 0 9
18308: PUSH
18309: LD_INT 5
18311: PUSH
18312: LD_INT 70
18314: PUSH
18315: LD_INT 20
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: LIST
18322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18323: LD_VAR 0 6
18327: PPUSH
18328: CALL_OW 264
18332: PUSH
18333: LD_INT 10
18335: PUSH
18336: EMPTY
18337: LIST
18338: IN
18339: IFFALSE 18360
// points := [ 35 , 110 , 70 ] ;
18341: LD_ADDR_VAR 0 9
18345: PUSH
18346: LD_INT 35
18348: PUSH
18349: LD_INT 110
18351: PUSH
18352: LD_INT 70
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: LIST
18359: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18360: LD_VAR 0 6
18364: PPUSH
18365: CALL_OW 265
18369: PUSH
18370: LD_INT 25
18372: EQUAL
18373: IFFALSE 18394
// points := [ 80 , 65 , 100 ] ;
18375: LD_ADDR_VAR 0 9
18379: PUSH
18380: LD_INT 80
18382: PUSH
18383: LD_INT 65
18385: PUSH
18386: LD_INT 100
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: LIST
18393: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18394: LD_VAR 0 6
18398: PPUSH
18399: CALL_OW 263
18403: PUSH
18404: LD_INT 1
18406: EQUAL
18407: IFFALSE 18442
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18409: LD_ADDR_VAR 0 10
18413: PUSH
18414: LD_VAR 0 10
18418: PUSH
18419: LD_VAR 0 6
18423: PPUSH
18424: CALL_OW 311
18428: PPUSH
18429: LD_INT 3
18431: PPUSH
18432: CALL_OW 259
18436: PUSH
18437: LD_INT 4
18439: MUL
18440: MUL
18441: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18442: LD_VAR 0 6
18446: PPUSH
18447: CALL_OW 263
18451: PUSH
18452: LD_INT 2
18454: EQUAL
18455: IFFALSE 18506
// begin j := IsControledBy ( i ) ;
18457: LD_ADDR_VAR 0 7
18461: PUSH
18462: LD_VAR 0 6
18466: PPUSH
18467: CALL_OW 312
18471: ST_TO_ADDR
// if j then
18472: LD_VAR 0 7
18476: IFFALSE 18506
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18478: LD_ADDR_VAR 0 10
18482: PUSH
18483: LD_VAR 0 10
18487: PUSH
18488: LD_VAR 0 7
18492: PPUSH
18493: LD_INT 3
18495: PPUSH
18496: CALL_OW 259
18500: PUSH
18501: LD_INT 3
18503: MUL
18504: MUL
18505: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18506: LD_VAR 0 6
18510: PPUSH
18511: CALL_OW 264
18515: PUSH
18516: LD_INT 5
18518: PUSH
18519: LD_INT 6
18521: PUSH
18522: LD_INT 46
18524: PUSH
18525: LD_INT 44
18527: PUSH
18528: LD_INT 47
18530: PUSH
18531: LD_INT 45
18533: PUSH
18534: LD_INT 28
18536: PUSH
18537: LD_INT 7
18539: PUSH
18540: LD_INT 27
18542: PUSH
18543: LD_INT 29
18545: PUSH
18546: EMPTY
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: IN
18558: PUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: LD_INT 52
18566: PPUSH
18567: CALL_OW 321
18571: PUSH
18572: LD_INT 2
18574: EQUAL
18575: AND
18576: IFFALSE 18593
// bpoints := bpoints * 1.2 ;
18578: LD_ADDR_VAR 0 10
18582: PUSH
18583: LD_VAR 0 10
18587: PUSH
18588: LD_REAL  1.20000000000000E+0000
18591: MUL
18592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18593: LD_VAR 0 6
18597: PPUSH
18598: CALL_OW 264
18602: PUSH
18603: LD_INT 6
18605: PUSH
18606: LD_INT 46
18608: PUSH
18609: LD_INT 47
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: LIST
18616: IN
18617: IFFALSE 18634
// bpoints := bpoints * 1.2 ;
18619: LD_ADDR_VAR 0 10
18623: PUSH
18624: LD_VAR 0 10
18628: PUSH
18629: LD_REAL  1.20000000000000E+0000
18632: MUL
18633: ST_TO_ADDR
// end ; unit_building :
18634: GO 18648
18636: LD_INT 3
18638: DOUBLE
18639: EQUAL
18640: IFTRUE 18644
18642: GO 18647
18644: POP
// ; end ;
18645: GO 18648
18647: POP
// for j = 1 to 3 do
18648: LD_ADDR_VAR 0 7
18652: PUSH
18653: DOUBLE
18654: LD_INT 1
18656: DEC
18657: ST_TO_ADDR
18658: LD_INT 3
18660: PUSH
18661: FOR_TO
18662: IFFALSE 18715
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18664: LD_ADDR_VAR 0 5
18668: PUSH
18669: LD_VAR 0 5
18673: PPUSH
18674: LD_VAR 0 7
18678: PPUSH
18679: LD_VAR 0 5
18683: PUSH
18684: LD_VAR 0 7
18688: ARRAY
18689: PUSH
18690: LD_VAR 0 9
18694: PUSH
18695: LD_VAR 0 7
18699: ARRAY
18700: PUSH
18701: LD_VAR 0 10
18705: MUL
18706: PLUS
18707: PPUSH
18708: CALL_OW 1
18712: ST_TO_ADDR
18713: GO 18661
18715: POP
18716: POP
// end ;
18717: GO 17196
18719: POP
18720: POP
// result := Replace ( result , 4 , tmp ) ;
18721: LD_ADDR_VAR 0 5
18725: PUSH
18726: LD_VAR 0 5
18730: PPUSH
18731: LD_INT 4
18733: PPUSH
18734: LD_VAR 0 8
18738: PPUSH
18739: CALL_OW 1
18743: ST_TO_ADDR
// end ;
18744: LD_VAR 0 5
18748: RET
// export function DangerAtRange ( unit , range ) ; begin
18749: LD_INT 0
18751: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18752: LD_ADDR_VAR 0 3
18756: PUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: CALL_OW 255
18766: PPUSH
18767: LD_VAR 0 1
18771: PPUSH
18772: CALL_OW 250
18776: PPUSH
18777: LD_VAR 0 1
18781: PPUSH
18782: CALL_OW 251
18786: PPUSH
18787: LD_VAR 0 2
18791: PPUSH
18792: CALL 17048 0 4
18796: ST_TO_ADDR
// end ;
18797: LD_VAR 0 3
18801: RET
// export function DangerInArea ( side , area ) ; begin
18802: LD_INT 0
18804: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18805: LD_ADDR_VAR 0 3
18809: PUSH
18810: LD_VAR 0 2
18814: PPUSH
18815: LD_INT 81
18817: PUSH
18818: LD_VAR 0 1
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PPUSH
18827: CALL_OW 70
18831: ST_TO_ADDR
// end ;
18832: LD_VAR 0 3
18836: RET
// export function IsExtension ( b ) ; begin
18837: LD_INT 0
18839: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18840: LD_ADDR_VAR 0 2
18844: PUSH
18845: LD_VAR 0 1
18849: PUSH
18850: LD_INT 23
18852: PUSH
18853: LD_INT 20
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 17
18861: PUSH
18862: LD_INT 24
18864: PUSH
18865: LD_INT 21
18867: PUSH
18868: LD_INT 19
18870: PUSH
18871: LD_INT 16
18873: PUSH
18874: LD_INT 25
18876: PUSH
18877: LD_INT 18
18879: PUSH
18880: EMPTY
18881: LIST
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: IN
18892: ST_TO_ADDR
// end ;
18893: LD_VAR 0 2
18897: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18898: LD_INT 0
18900: PPUSH
18901: PPUSH
18902: PPUSH
// result := [ ] ;
18903: LD_ADDR_VAR 0 4
18907: PUSH
18908: EMPTY
18909: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18910: LD_ADDR_VAR 0 5
18914: PUSH
18915: LD_VAR 0 2
18919: PPUSH
18920: LD_INT 21
18922: PUSH
18923: LD_INT 3
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: PPUSH
18930: CALL_OW 70
18934: ST_TO_ADDR
// if not tmp then
18935: LD_VAR 0 5
18939: NOT
18940: IFFALSE 18944
// exit ;
18942: GO 19008
// if checkLink then
18944: LD_VAR 0 3
18948: IFFALSE 18998
// begin for i in tmp do
18950: LD_ADDR_VAR 0 6
18954: PUSH
18955: LD_VAR 0 5
18959: PUSH
18960: FOR_IN
18961: IFFALSE 18996
// if GetBase ( i ) <> base then
18963: LD_VAR 0 6
18967: PPUSH
18968: CALL_OW 274
18972: PUSH
18973: LD_VAR 0 1
18977: NONEQUAL
18978: IFFALSE 18994
// ComLinkToBase ( base , i ) ;
18980: LD_VAR 0 1
18984: PPUSH
18985: LD_VAR 0 6
18989: PPUSH
18990: CALL_OW 169
18994: GO 18960
18996: POP
18997: POP
// end ; result := tmp ;
18998: LD_ADDR_VAR 0 4
19002: PUSH
19003: LD_VAR 0 5
19007: ST_TO_ADDR
// end ;
19008: LD_VAR 0 4
19012: RET
// export function ComComplete ( units , b ) ; var i ; begin
19013: LD_INT 0
19015: PPUSH
19016: PPUSH
// if not units then
19017: LD_VAR 0 1
19021: NOT
19022: IFFALSE 19026
// exit ;
19024: GO 19116
// for i in units do
19026: LD_ADDR_VAR 0 4
19030: PUSH
19031: LD_VAR 0 1
19035: PUSH
19036: FOR_IN
19037: IFFALSE 19114
// if BuildingStatus ( b ) = bs_build then
19039: LD_VAR 0 2
19043: PPUSH
19044: CALL_OW 461
19048: PUSH
19049: LD_INT 1
19051: EQUAL
19052: IFFALSE 19112
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19054: LD_VAR 0 4
19058: PPUSH
19059: LD_STRING h
19061: PUSH
19062: LD_VAR 0 2
19066: PPUSH
19067: CALL_OW 250
19071: PUSH
19072: LD_VAR 0 2
19076: PPUSH
19077: CALL_OW 251
19081: PUSH
19082: LD_VAR 0 2
19086: PUSH
19087: LD_INT 0
19089: PUSH
19090: LD_INT 0
19092: PUSH
19093: LD_INT 0
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: LIST
19103: LIST
19104: PUSH
19105: EMPTY
19106: LIST
19107: PPUSH
19108: CALL_OW 446
19112: GO 19036
19114: POP
19115: POP
// end ;
19116: LD_VAR 0 3
19120: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19121: LD_INT 0
19123: PPUSH
19124: PPUSH
19125: PPUSH
19126: PPUSH
19127: PPUSH
19128: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19129: LD_VAR 0 1
19133: NOT
19134: PUSH
19135: LD_VAR 0 1
19139: PPUSH
19140: CALL_OW 263
19144: PUSH
19145: LD_INT 2
19147: NONEQUAL
19148: OR
19149: IFFALSE 19153
// exit ;
19151: GO 19469
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19153: LD_ADDR_VAR 0 6
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 255
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PUSH
19175: LD_INT 2
19177: PUSH
19178: LD_INT 30
19180: PUSH
19181: LD_INT 36
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: PUSH
19188: LD_INT 34
19190: PUSH
19191: LD_INT 31
19193: PUSH
19194: EMPTY
19195: LIST
19196: LIST
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: LIST
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PPUSH
19207: CALL_OW 69
19211: ST_TO_ADDR
// if not tmp then
19212: LD_VAR 0 6
19216: NOT
19217: IFFALSE 19221
// exit ;
19219: GO 19469
// result := [ ] ;
19221: LD_ADDR_VAR 0 2
19225: PUSH
19226: EMPTY
19227: ST_TO_ADDR
// for i in tmp do
19228: LD_ADDR_VAR 0 3
19232: PUSH
19233: LD_VAR 0 6
19237: PUSH
19238: FOR_IN
19239: IFFALSE 19310
// begin t := UnitsInside ( i ) ;
19241: LD_ADDR_VAR 0 4
19245: PUSH
19246: LD_VAR 0 3
19250: PPUSH
19251: CALL_OW 313
19255: ST_TO_ADDR
// if t then
19256: LD_VAR 0 4
19260: IFFALSE 19308
// for j in t do
19262: LD_ADDR_VAR 0 7
19266: PUSH
19267: LD_VAR 0 4
19271: PUSH
19272: FOR_IN
19273: IFFALSE 19306
// result := Replace ( result , result + 1 , j ) ;
19275: LD_ADDR_VAR 0 2
19279: PUSH
19280: LD_VAR 0 2
19284: PPUSH
19285: LD_VAR 0 2
19289: PUSH
19290: LD_INT 1
19292: PLUS
19293: PPUSH
19294: LD_VAR 0 7
19298: PPUSH
19299: CALL_OW 1
19303: ST_TO_ADDR
19304: GO 19272
19306: POP
19307: POP
// end ;
19308: GO 19238
19310: POP
19311: POP
// if not result then
19312: LD_VAR 0 2
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 19469
// mech := result [ 1 ] ;
19321: LD_ADDR_VAR 0 5
19325: PUSH
19326: LD_VAR 0 2
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: ST_TO_ADDR
// if result > 1 then
19335: LD_VAR 0 2
19339: PUSH
19340: LD_INT 1
19342: GREATER
19343: IFFALSE 19455
// begin for i = 2 to result do
19345: LD_ADDR_VAR 0 3
19349: PUSH
19350: DOUBLE
19351: LD_INT 2
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 2
19359: PUSH
19360: FOR_TO
19361: IFFALSE 19453
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19363: LD_ADDR_VAR 0 4
19367: PUSH
19368: LD_VAR 0 2
19372: PUSH
19373: LD_VAR 0 3
19377: ARRAY
19378: PPUSH
19379: LD_INT 3
19381: PPUSH
19382: CALL_OW 259
19386: PUSH
19387: LD_VAR 0 2
19391: PUSH
19392: LD_VAR 0 3
19396: ARRAY
19397: PPUSH
19398: CALL_OW 432
19402: MINUS
19403: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19404: LD_VAR 0 4
19408: PUSH
19409: LD_VAR 0 5
19413: PPUSH
19414: LD_INT 3
19416: PPUSH
19417: CALL_OW 259
19421: PUSH
19422: LD_VAR 0 5
19426: PPUSH
19427: CALL_OW 432
19431: MINUS
19432: GREATEREQUAL
19433: IFFALSE 19451
// mech := result [ i ] ;
19435: LD_ADDR_VAR 0 5
19439: PUSH
19440: LD_VAR 0 2
19444: PUSH
19445: LD_VAR 0 3
19449: ARRAY
19450: ST_TO_ADDR
// end ;
19451: GO 19360
19453: POP
19454: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19455: LD_VAR 0 1
19459: PPUSH
19460: LD_VAR 0 5
19464: PPUSH
19465: CALL_OW 135
// end ;
19469: LD_VAR 0 2
19473: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19474: LD_INT 0
19476: PPUSH
19477: PPUSH
19478: PPUSH
19479: PPUSH
19480: PPUSH
19481: PPUSH
19482: PPUSH
19483: PPUSH
19484: PPUSH
19485: PPUSH
19486: PPUSH
19487: PPUSH
19488: PPUSH
// result := [ ] ;
19489: LD_ADDR_VAR 0 7
19493: PUSH
19494: EMPTY
19495: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19496: LD_VAR 0 1
19500: PPUSH
19501: CALL_OW 266
19505: PUSH
19506: LD_INT 0
19508: PUSH
19509: LD_INT 1
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: IN
19516: NOT
19517: IFFALSE 19521
// exit ;
19519: GO 21155
// if name then
19521: LD_VAR 0 3
19525: IFFALSE 19541
// SetBName ( base_dep , name ) ;
19527: LD_VAR 0 1
19531: PPUSH
19532: LD_VAR 0 3
19536: PPUSH
19537: CALL_OW 500
// base := GetBase ( base_dep ) ;
19541: LD_ADDR_VAR 0 15
19545: PUSH
19546: LD_VAR 0 1
19550: PPUSH
19551: CALL_OW 274
19555: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19556: LD_ADDR_VAR 0 16
19560: PUSH
19561: LD_VAR 0 1
19565: PPUSH
19566: CALL_OW 255
19570: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19571: LD_ADDR_VAR 0 17
19575: PUSH
19576: LD_VAR 0 1
19580: PPUSH
19581: CALL_OW 248
19585: ST_TO_ADDR
// if sources then
19586: LD_VAR 0 5
19590: IFFALSE 19637
// for i = 1 to 3 do
19592: LD_ADDR_VAR 0 8
19596: PUSH
19597: DOUBLE
19598: LD_INT 1
19600: DEC
19601: ST_TO_ADDR
19602: LD_INT 3
19604: PUSH
19605: FOR_TO
19606: IFFALSE 19635
// AddResourceType ( base , i , sources [ i ] ) ;
19608: LD_VAR 0 15
19612: PPUSH
19613: LD_VAR 0 8
19617: PPUSH
19618: LD_VAR 0 5
19622: PUSH
19623: LD_VAR 0 8
19627: ARRAY
19628: PPUSH
19629: CALL_OW 276
19633: GO 19605
19635: POP
19636: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19637: LD_ADDR_VAR 0 18
19641: PUSH
19642: LD_VAR 0 15
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: LD_INT 1
19654: PPUSH
19655: CALL 18898 0 3
19659: ST_TO_ADDR
// InitHc ;
19660: CALL_OW 19
// InitUc ;
19664: CALL_OW 18
// uc_side := side ;
19668: LD_ADDR_OWVAR 20
19672: PUSH
19673: LD_VAR 0 16
19677: ST_TO_ADDR
// uc_nation := nation ;
19678: LD_ADDR_OWVAR 21
19682: PUSH
19683: LD_VAR 0 17
19687: ST_TO_ADDR
// if buildings then
19688: LD_VAR 0 18
19692: IFFALSE 21014
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19694: LD_ADDR_VAR 0 19
19698: PUSH
19699: LD_VAR 0 18
19703: PPUSH
19704: LD_INT 2
19706: PUSH
19707: LD_INT 30
19709: PUSH
19710: LD_INT 29
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: PUSH
19717: LD_INT 30
19719: PUSH
19720: LD_INT 30
19722: PUSH
19723: EMPTY
19724: LIST
19725: LIST
19726: PUSH
19727: EMPTY
19728: LIST
19729: LIST
19730: LIST
19731: PPUSH
19732: CALL_OW 72
19736: ST_TO_ADDR
// if tmp then
19737: LD_VAR 0 19
19741: IFFALSE 19789
// for i in tmp do
19743: LD_ADDR_VAR 0 8
19747: PUSH
19748: LD_VAR 0 19
19752: PUSH
19753: FOR_IN
19754: IFFALSE 19787
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19756: LD_VAR 0 8
19760: PPUSH
19761: CALL_OW 250
19765: PPUSH
19766: LD_VAR 0 8
19770: PPUSH
19771: CALL_OW 251
19775: PPUSH
19776: LD_VAR 0 16
19780: PPUSH
19781: CALL_OW 441
19785: GO 19753
19787: POP
19788: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19789: LD_VAR 0 18
19793: PPUSH
19794: LD_INT 2
19796: PUSH
19797: LD_INT 30
19799: PUSH
19800: LD_INT 32
19802: PUSH
19803: EMPTY
19804: LIST
19805: LIST
19806: PUSH
19807: LD_INT 30
19809: PUSH
19810: LD_INT 33
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: PPUSH
19822: CALL_OW 72
19826: IFFALSE 19914
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19828: LD_ADDR_VAR 0 8
19832: PUSH
19833: LD_VAR 0 18
19837: PPUSH
19838: LD_INT 2
19840: PUSH
19841: LD_INT 30
19843: PUSH
19844: LD_INT 32
19846: PUSH
19847: EMPTY
19848: LIST
19849: LIST
19850: PUSH
19851: LD_INT 30
19853: PUSH
19854: LD_INT 33
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: LIST
19865: PPUSH
19866: CALL_OW 72
19870: PUSH
19871: FOR_IN
19872: IFFALSE 19912
// begin if not GetBWeapon ( i ) then
19874: LD_VAR 0 8
19878: PPUSH
19879: CALL_OW 269
19883: NOT
19884: IFFALSE 19910
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19886: LD_VAR 0 8
19890: PPUSH
19891: LD_VAR 0 8
19895: PPUSH
19896: LD_VAR 0 2
19900: PPUSH
19901: CALL 21160 0 2
19905: PPUSH
19906: CALL_OW 431
// end ;
19910: GO 19871
19912: POP
19913: POP
// end ; for i = 1 to personel do
19914: LD_ADDR_VAR 0 8
19918: PUSH
19919: DOUBLE
19920: LD_INT 1
19922: DEC
19923: ST_TO_ADDR
19924: LD_VAR 0 6
19928: PUSH
19929: FOR_TO
19930: IFFALSE 20994
// begin if i > 4 then
19932: LD_VAR 0 8
19936: PUSH
19937: LD_INT 4
19939: GREATER
19940: IFFALSE 19944
// break ;
19942: GO 20994
// case i of 1 :
19944: LD_VAR 0 8
19948: PUSH
19949: LD_INT 1
19951: DOUBLE
19952: EQUAL
19953: IFTRUE 19957
19955: GO 20037
19957: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19958: LD_ADDR_VAR 0 12
19962: PUSH
19963: LD_VAR 0 18
19967: PPUSH
19968: LD_INT 22
19970: PUSH
19971: LD_VAR 0 16
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: PUSH
19980: LD_INT 58
19982: PUSH
19983: EMPTY
19984: LIST
19985: PUSH
19986: LD_INT 2
19988: PUSH
19989: LD_INT 30
19991: PUSH
19992: LD_INT 32
19994: PUSH
19995: EMPTY
19996: LIST
19997: LIST
19998: PUSH
19999: LD_INT 30
20001: PUSH
20002: LD_INT 4
20004: PUSH
20005: EMPTY
20006: LIST
20007: LIST
20008: PUSH
20009: LD_INT 30
20011: PUSH
20012: LD_INT 5
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: LIST
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: LIST
20029: PPUSH
20030: CALL_OW 72
20034: ST_TO_ADDR
20035: GO 20259
20037: LD_INT 2
20039: DOUBLE
20040: EQUAL
20041: IFTRUE 20045
20043: GO 20107
20045: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20046: LD_ADDR_VAR 0 12
20050: PUSH
20051: LD_VAR 0 18
20055: PPUSH
20056: LD_INT 22
20058: PUSH
20059: LD_VAR 0 16
20063: PUSH
20064: EMPTY
20065: LIST
20066: LIST
20067: PUSH
20068: LD_INT 2
20070: PUSH
20071: LD_INT 30
20073: PUSH
20074: LD_INT 0
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: LD_INT 30
20083: PUSH
20084: LD_INT 1
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: PUSH
20096: EMPTY
20097: LIST
20098: LIST
20099: PPUSH
20100: CALL_OW 72
20104: ST_TO_ADDR
20105: GO 20259
20107: LD_INT 3
20109: DOUBLE
20110: EQUAL
20111: IFTRUE 20115
20113: GO 20177
20115: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20116: LD_ADDR_VAR 0 12
20120: PUSH
20121: LD_VAR 0 18
20125: PPUSH
20126: LD_INT 22
20128: PUSH
20129: LD_VAR 0 16
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 2
20140: PUSH
20141: LD_INT 30
20143: PUSH
20144: LD_INT 2
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: PUSH
20151: LD_INT 30
20153: PUSH
20154: LD_INT 3
20156: PUSH
20157: EMPTY
20158: LIST
20159: LIST
20160: PUSH
20161: EMPTY
20162: LIST
20163: LIST
20164: LIST
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: PPUSH
20170: CALL_OW 72
20174: ST_TO_ADDR
20175: GO 20259
20177: LD_INT 4
20179: DOUBLE
20180: EQUAL
20181: IFTRUE 20185
20183: GO 20258
20185: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20186: LD_ADDR_VAR 0 12
20190: PUSH
20191: LD_VAR 0 18
20195: PPUSH
20196: LD_INT 22
20198: PUSH
20199: LD_VAR 0 16
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: PUSH
20208: LD_INT 2
20210: PUSH
20211: LD_INT 30
20213: PUSH
20214: LD_INT 6
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: PUSH
20221: LD_INT 30
20223: PUSH
20224: LD_INT 7
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: PUSH
20231: LD_INT 30
20233: PUSH
20234: LD_INT 8
20236: PUSH
20237: EMPTY
20238: LIST
20239: LIST
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PPUSH
20251: CALL_OW 72
20255: ST_TO_ADDR
20256: GO 20259
20258: POP
// if i = 1 then
20259: LD_VAR 0 8
20263: PUSH
20264: LD_INT 1
20266: EQUAL
20267: IFFALSE 20378
// begin tmp := [ ] ;
20269: LD_ADDR_VAR 0 19
20273: PUSH
20274: EMPTY
20275: ST_TO_ADDR
// for j in f do
20276: LD_ADDR_VAR 0 9
20280: PUSH
20281: LD_VAR 0 12
20285: PUSH
20286: FOR_IN
20287: IFFALSE 20360
// if GetBType ( j ) = b_bunker then
20289: LD_VAR 0 9
20293: PPUSH
20294: CALL_OW 266
20298: PUSH
20299: LD_INT 32
20301: EQUAL
20302: IFFALSE 20329
// tmp := Insert ( tmp , 1 , j ) else
20304: LD_ADDR_VAR 0 19
20308: PUSH
20309: LD_VAR 0 19
20313: PPUSH
20314: LD_INT 1
20316: PPUSH
20317: LD_VAR 0 9
20321: PPUSH
20322: CALL_OW 2
20326: ST_TO_ADDR
20327: GO 20358
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20329: LD_ADDR_VAR 0 19
20333: PUSH
20334: LD_VAR 0 19
20338: PPUSH
20339: LD_VAR 0 19
20343: PUSH
20344: LD_INT 1
20346: PLUS
20347: PPUSH
20348: LD_VAR 0 9
20352: PPUSH
20353: CALL_OW 2
20357: ST_TO_ADDR
20358: GO 20286
20360: POP
20361: POP
// if tmp then
20362: LD_VAR 0 19
20366: IFFALSE 20378
// f := tmp ;
20368: LD_ADDR_VAR 0 12
20372: PUSH
20373: LD_VAR 0 19
20377: ST_TO_ADDR
// end ; x := personel [ i ] ;
20378: LD_ADDR_VAR 0 13
20382: PUSH
20383: LD_VAR 0 6
20387: PUSH
20388: LD_VAR 0 8
20392: ARRAY
20393: ST_TO_ADDR
// if x = - 1 then
20394: LD_VAR 0 13
20398: PUSH
20399: LD_INT 1
20401: NEG
20402: EQUAL
20403: IFFALSE 20612
// begin for j in f do
20405: LD_ADDR_VAR 0 9
20409: PUSH
20410: LD_VAR 0 12
20414: PUSH
20415: FOR_IN
20416: IFFALSE 20608
// repeat InitHc ;
20418: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20422: LD_VAR 0 9
20426: PPUSH
20427: CALL_OW 266
20431: PUSH
20432: LD_INT 5
20434: EQUAL
20435: IFFALSE 20505
// begin if UnitsInside ( j ) < 3 then
20437: LD_VAR 0 9
20441: PPUSH
20442: CALL_OW 313
20446: PUSH
20447: LD_INT 3
20449: LESS
20450: IFFALSE 20486
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20452: LD_INT 0
20454: PPUSH
20455: LD_INT 5
20457: PUSH
20458: LD_INT 8
20460: PUSH
20461: LD_INT 9
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: PUSH
20469: LD_VAR 0 17
20473: ARRAY
20474: PPUSH
20475: LD_VAR 0 4
20479: PPUSH
20480: CALL_OW 380
20484: GO 20503
// PrepareHuman ( false , i , skill ) ;
20486: LD_INT 0
20488: PPUSH
20489: LD_VAR 0 8
20493: PPUSH
20494: LD_VAR 0 4
20498: PPUSH
20499: CALL_OW 380
// end else
20503: GO 20522
// PrepareHuman ( false , i , skill ) ;
20505: LD_INT 0
20507: PPUSH
20508: LD_VAR 0 8
20512: PPUSH
20513: LD_VAR 0 4
20517: PPUSH
20518: CALL_OW 380
// un := CreateHuman ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: CALL_OW 44
20531: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20532: LD_ADDR_VAR 0 7
20536: PUSH
20537: LD_VAR 0 7
20541: PPUSH
20542: LD_INT 1
20544: PPUSH
20545: LD_VAR 0 14
20549: PPUSH
20550: CALL_OW 2
20554: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20555: LD_VAR 0 14
20559: PPUSH
20560: LD_VAR 0 9
20564: PPUSH
20565: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20569: LD_VAR 0 9
20573: PPUSH
20574: CALL_OW 313
20578: PUSH
20579: LD_INT 6
20581: EQUAL
20582: PUSH
20583: LD_VAR 0 9
20587: PPUSH
20588: CALL_OW 266
20592: PUSH
20593: LD_INT 32
20595: PUSH
20596: LD_INT 31
20598: PUSH
20599: EMPTY
20600: LIST
20601: LIST
20602: IN
20603: OR
20604: IFFALSE 20418
20606: GO 20415
20608: POP
20609: POP
// end else
20610: GO 20992
// for j = 1 to x do
20612: LD_ADDR_VAR 0 9
20616: PUSH
20617: DOUBLE
20618: LD_INT 1
20620: DEC
20621: ST_TO_ADDR
20622: LD_VAR 0 13
20626: PUSH
20627: FOR_TO
20628: IFFALSE 20990
// begin InitHc ;
20630: CALL_OW 19
// if not f then
20634: LD_VAR 0 12
20638: NOT
20639: IFFALSE 20728
// begin PrepareHuman ( false , i , skill ) ;
20641: LD_INT 0
20643: PPUSH
20644: LD_VAR 0 8
20648: PPUSH
20649: LD_VAR 0 4
20653: PPUSH
20654: CALL_OW 380
// un := CreateHuman ;
20658: LD_ADDR_VAR 0 14
20662: PUSH
20663: CALL_OW 44
20667: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20668: LD_ADDR_VAR 0 7
20672: PUSH
20673: LD_VAR 0 7
20677: PPUSH
20678: LD_INT 1
20680: PPUSH
20681: LD_VAR 0 14
20685: PPUSH
20686: CALL_OW 2
20690: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20691: LD_VAR 0 14
20695: PPUSH
20696: LD_VAR 0 1
20700: PPUSH
20701: CALL_OW 250
20705: PPUSH
20706: LD_VAR 0 1
20710: PPUSH
20711: CALL_OW 251
20715: PPUSH
20716: LD_INT 10
20718: PPUSH
20719: LD_INT 0
20721: PPUSH
20722: CALL_OW 50
// continue ;
20726: GO 20627
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20728: LD_VAR 0 12
20732: PUSH
20733: LD_INT 1
20735: ARRAY
20736: PPUSH
20737: CALL_OW 313
20741: PUSH
20742: LD_VAR 0 12
20746: PUSH
20747: LD_INT 1
20749: ARRAY
20750: PPUSH
20751: CALL_OW 266
20755: PUSH
20756: LD_INT 32
20758: PUSH
20759: LD_INT 31
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: IN
20766: AND
20767: PUSH
20768: LD_VAR 0 12
20772: PUSH
20773: LD_INT 1
20775: ARRAY
20776: PPUSH
20777: CALL_OW 313
20781: PUSH
20782: LD_INT 6
20784: EQUAL
20785: OR
20786: IFFALSE 20806
// f := Delete ( f , 1 ) ;
20788: LD_ADDR_VAR 0 12
20792: PUSH
20793: LD_VAR 0 12
20797: PPUSH
20798: LD_INT 1
20800: PPUSH
20801: CALL_OW 3
20805: ST_TO_ADDR
// if not f then
20806: LD_VAR 0 12
20810: NOT
20811: IFFALSE 20829
// begin x := x + 2 ;
20813: LD_ADDR_VAR 0 13
20817: PUSH
20818: LD_VAR 0 13
20822: PUSH
20823: LD_INT 2
20825: PLUS
20826: ST_TO_ADDR
// continue ;
20827: GO 20627
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20829: LD_VAR 0 12
20833: PUSH
20834: LD_INT 1
20836: ARRAY
20837: PPUSH
20838: CALL_OW 266
20842: PUSH
20843: LD_INT 5
20845: EQUAL
20846: IFFALSE 20920
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20848: LD_VAR 0 12
20852: PUSH
20853: LD_INT 1
20855: ARRAY
20856: PPUSH
20857: CALL_OW 313
20861: PUSH
20862: LD_INT 3
20864: LESS
20865: IFFALSE 20901
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20867: LD_INT 0
20869: PPUSH
20870: LD_INT 5
20872: PUSH
20873: LD_INT 8
20875: PUSH
20876: LD_INT 9
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: LIST
20883: PUSH
20884: LD_VAR 0 17
20888: ARRAY
20889: PPUSH
20890: LD_VAR 0 4
20894: PPUSH
20895: CALL_OW 380
20899: GO 20918
// PrepareHuman ( false , i , skill ) ;
20901: LD_INT 0
20903: PPUSH
20904: LD_VAR 0 8
20908: PPUSH
20909: LD_VAR 0 4
20913: PPUSH
20914: CALL_OW 380
// end else
20918: GO 20937
// PrepareHuman ( false , i , skill ) ;
20920: LD_INT 0
20922: PPUSH
20923: LD_VAR 0 8
20927: PPUSH
20928: LD_VAR 0 4
20932: PPUSH
20933: CALL_OW 380
// un := CreateHuman ;
20937: LD_ADDR_VAR 0 14
20941: PUSH
20942: CALL_OW 44
20946: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20947: LD_ADDR_VAR 0 7
20951: PUSH
20952: LD_VAR 0 7
20956: PPUSH
20957: LD_INT 1
20959: PPUSH
20960: LD_VAR 0 14
20964: PPUSH
20965: CALL_OW 2
20969: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20970: LD_VAR 0 14
20974: PPUSH
20975: LD_VAR 0 12
20979: PUSH
20980: LD_INT 1
20982: ARRAY
20983: PPUSH
20984: CALL_OW 52
// end ;
20988: GO 20627
20990: POP
20991: POP
// end ;
20992: GO 19929
20994: POP
20995: POP
// result := result ^ buildings ;
20996: LD_ADDR_VAR 0 7
21000: PUSH
21001: LD_VAR 0 7
21005: PUSH
21006: LD_VAR 0 18
21010: ADD
21011: ST_TO_ADDR
// end else
21012: GO 21155
// begin for i = 1 to personel do
21014: LD_ADDR_VAR 0 8
21018: PUSH
21019: DOUBLE
21020: LD_INT 1
21022: DEC
21023: ST_TO_ADDR
21024: LD_VAR 0 6
21028: PUSH
21029: FOR_TO
21030: IFFALSE 21153
// begin if i > 4 then
21032: LD_VAR 0 8
21036: PUSH
21037: LD_INT 4
21039: GREATER
21040: IFFALSE 21044
// break ;
21042: GO 21153
// x := personel [ i ] ;
21044: LD_ADDR_VAR 0 13
21048: PUSH
21049: LD_VAR 0 6
21053: PUSH
21054: LD_VAR 0 8
21058: ARRAY
21059: ST_TO_ADDR
// if x = - 1 then
21060: LD_VAR 0 13
21064: PUSH
21065: LD_INT 1
21067: NEG
21068: EQUAL
21069: IFFALSE 21073
// continue ;
21071: GO 21029
// PrepareHuman ( false , i , skill ) ;
21073: LD_INT 0
21075: PPUSH
21076: LD_VAR 0 8
21080: PPUSH
21081: LD_VAR 0 4
21085: PPUSH
21086: CALL_OW 380
// un := CreateHuman ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: CALL_OW 44
21099: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21100: LD_VAR 0 14
21104: PPUSH
21105: LD_VAR 0 1
21109: PPUSH
21110: CALL_OW 250
21114: PPUSH
21115: LD_VAR 0 1
21119: PPUSH
21120: CALL_OW 251
21124: PPUSH
21125: LD_INT 10
21127: PPUSH
21128: LD_INT 0
21130: PPUSH
21131: CALL_OW 50
// result := result ^ un ;
21135: LD_ADDR_VAR 0 7
21139: PUSH
21140: LD_VAR 0 7
21144: PUSH
21145: LD_VAR 0 14
21149: ADD
21150: ST_TO_ADDR
// end ;
21151: GO 21029
21153: POP
21154: POP
// end ; end ;
21155: LD_VAR 0 7
21159: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21160: LD_INT 0
21162: PPUSH
21163: PPUSH
21164: PPUSH
21165: PPUSH
21166: PPUSH
21167: PPUSH
21168: PPUSH
21169: PPUSH
21170: PPUSH
21171: PPUSH
21172: PPUSH
21173: PPUSH
21174: PPUSH
21175: PPUSH
21176: PPUSH
21177: PPUSH
// result := false ;
21178: LD_ADDR_VAR 0 3
21182: PUSH
21183: LD_INT 0
21185: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21186: LD_VAR 0 1
21190: NOT
21191: PUSH
21192: LD_VAR 0 1
21196: PPUSH
21197: CALL_OW 266
21201: PUSH
21202: LD_INT 32
21204: PUSH
21205: LD_INT 33
21207: PUSH
21208: EMPTY
21209: LIST
21210: LIST
21211: IN
21212: NOT
21213: OR
21214: IFFALSE 21218
// exit ;
21216: GO 22327
// nat := GetNation ( tower ) ;
21218: LD_ADDR_VAR 0 12
21222: PUSH
21223: LD_VAR 0 1
21227: PPUSH
21228: CALL_OW 248
21232: ST_TO_ADDR
// side := GetSide ( tower ) ;
21233: LD_ADDR_VAR 0 16
21237: PUSH
21238: LD_VAR 0 1
21242: PPUSH
21243: CALL_OW 255
21247: ST_TO_ADDR
// x := GetX ( tower ) ;
21248: LD_ADDR_VAR 0 10
21252: PUSH
21253: LD_VAR 0 1
21257: PPUSH
21258: CALL_OW 250
21262: ST_TO_ADDR
// y := GetY ( tower ) ;
21263: LD_ADDR_VAR 0 11
21267: PUSH
21268: LD_VAR 0 1
21272: PPUSH
21273: CALL_OW 251
21277: ST_TO_ADDR
// if not x or not y then
21278: LD_VAR 0 10
21282: NOT
21283: PUSH
21284: LD_VAR 0 11
21288: NOT
21289: OR
21290: IFFALSE 21294
// exit ;
21292: GO 22327
// weapon := 0 ;
21294: LD_ADDR_VAR 0 18
21298: PUSH
21299: LD_INT 0
21301: ST_TO_ADDR
// fac_list := [ ] ;
21302: LD_ADDR_VAR 0 17
21306: PUSH
21307: EMPTY
21308: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21309: LD_ADDR_VAR 0 6
21313: PUSH
21314: LD_VAR 0 1
21318: PPUSH
21319: CALL_OW 274
21323: PPUSH
21324: LD_VAR 0 2
21328: PPUSH
21329: LD_INT 0
21331: PPUSH
21332: CALL 18898 0 3
21336: PPUSH
21337: LD_INT 30
21339: PUSH
21340: LD_INT 3
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: PPUSH
21347: CALL_OW 72
21351: ST_TO_ADDR
// if not factories then
21352: LD_VAR 0 6
21356: NOT
21357: IFFALSE 21361
// exit ;
21359: GO 22327
// for i in factories do
21361: LD_ADDR_VAR 0 8
21365: PUSH
21366: LD_VAR 0 6
21370: PUSH
21371: FOR_IN
21372: IFFALSE 21397
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21374: LD_ADDR_VAR 0 17
21378: PUSH
21379: LD_VAR 0 17
21383: PUSH
21384: LD_VAR 0 8
21388: PPUSH
21389: CALL_OW 478
21393: UNION
21394: ST_TO_ADDR
21395: GO 21371
21397: POP
21398: POP
// if not fac_list then
21399: LD_VAR 0 17
21403: NOT
21404: IFFALSE 21408
// exit ;
21406: GO 22327
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21408: LD_ADDR_VAR 0 5
21412: PUSH
21413: LD_INT 4
21415: PUSH
21416: LD_INT 5
21418: PUSH
21419: LD_INT 9
21421: PUSH
21422: LD_INT 10
21424: PUSH
21425: LD_INT 6
21427: PUSH
21428: LD_INT 7
21430: PUSH
21431: LD_INT 11
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: PUSH
21443: LD_INT 27
21445: PUSH
21446: LD_INT 28
21448: PUSH
21449: LD_INT 26
21451: PUSH
21452: LD_INT 30
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 43
21463: PUSH
21464: LD_INT 44
21466: PUSH
21467: LD_INT 46
21469: PUSH
21470: LD_INT 45
21472: PUSH
21473: LD_INT 47
21475: PUSH
21476: LD_INT 49
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: LIST
21491: PUSH
21492: LD_VAR 0 12
21496: ARRAY
21497: ST_TO_ADDR
// list := list isect fac_list ;
21498: LD_ADDR_VAR 0 5
21502: PUSH
21503: LD_VAR 0 5
21507: PUSH
21508: LD_VAR 0 17
21512: ISECT
21513: ST_TO_ADDR
// if not list then
21514: LD_VAR 0 5
21518: NOT
21519: IFFALSE 21523
// exit ;
21521: GO 22327
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21523: LD_VAR 0 12
21527: PUSH
21528: LD_INT 3
21530: EQUAL
21531: PUSH
21532: LD_INT 49
21534: PUSH
21535: LD_VAR 0 5
21539: IN
21540: AND
21541: PUSH
21542: LD_INT 31
21544: PPUSH
21545: LD_VAR 0 16
21549: PPUSH
21550: CALL_OW 321
21554: PUSH
21555: LD_INT 2
21557: EQUAL
21558: AND
21559: IFFALSE 21619
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21561: LD_INT 22
21563: PUSH
21564: LD_VAR 0 16
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: PUSH
21573: LD_INT 35
21575: PUSH
21576: LD_INT 49
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PUSH
21583: LD_INT 91
21585: PUSH
21586: LD_VAR 0 1
21590: PUSH
21591: LD_INT 10
21593: PUSH
21594: EMPTY
21595: LIST
21596: LIST
21597: LIST
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: PPUSH
21604: CALL_OW 69
21608: NOT
21609: IFFALSE 21619
// weapon := ru_time_lapser ;
21611: LD_ADDR_VAR 0 18
21615: PUSH
21616: LD_INT 49
21618: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21619: LD_VAR 0 12
21623: PUSH
21624: LD_INT 1
21626: PUSH
21627: LD_INT 2
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: IN
21634: PUSH
21635: LD_INT 11
21637: PUSH
21638: LD_VAR 0 5
21642: IN
21643: PUSH
21644: LD_INT 30
21646: PUSH
21647: LD_VAR 0 5
21651: IN
21652: OR
21653: AND
21654: PUSH
21655: LD_INT 6
21657: PPUSH
21658: LD_VAR 0 16
21662: PPUSH
21663: CALL_OW 321
21667: PUSH
21668: LD_INT 2
21670: EQUAL
21671: AND
21672: IFFALSE 21837
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21674: LD_INT 22
21676: PUSH
21677: LD_VAR 0 16
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: PUSH
21686: LD_INT 2
21688: PUSH
21689: LD_INT 35
21691: PUSH
21692: LD_INT 11
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: PUSH
21699: LD_INT 35
21701: PUSH
21702: LD_INT 30
21704: PUSH
21705: EMPTY
21706: LIST
21707: LIST
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: LIST
21713: PUSH
21714: LD_INT 91
21716: PUSH
21717: LD_VAR 0 1
21721: PUSH
21722: LD_INT 18
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: LIST
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: LIST
21734: PPUSH
21735: CALL_OW 69
21739: NOT
21740: PUSH
21741: LD_INT 22
21743: PUSH
21744: LD_VAR 0 16
21748: PUSH
21749: EMPTY
21750: LIST
21751: LIST
21752: PUSH
21753: LD_INT 2
21755: PUSH
21756: LD_INT 30
21758: PUSH
21759: LD_INT 32
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 30
21768: PUSH
21769: LD_INT 33
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 91
21783: PUSH
21784: LD_VAR 0 1
21788: PUSH
21789: LD_INT 12
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: PUSH
21797: EMPTY
21798: LIST
21799: LIST
21800: LIST
21801: PUSH
21802: EMPTY
21803: LIST
21804: PPUSH
21805: CALL_OW 69
21809: PUSH
21810: LD_INT 2
21812: GREATER
21813: AND
21814: IFFALSE 21837
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21816: LD_ADDR_VAR 0 18
21820: PUSH
21821: LD_INT 11
21823: PUSH
21824: LD_INT 30
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_VAR 0 12
21835: ARRAY
21836: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21837: LD_VAR 0 18
21841: NOT
21842: PUSH
21843: LD_INT 40
21845: PPUSH
21846: LD_VAR 0 16
21850: PPUSH
21851: CALL_OW 321
21855: PUSH
21856: LD_INT 2
21858: EQUAL
21859: AND
21860: PUSH
21861: LD_INT 7
21863: PUSH
21864: LD_VAR 0 5
21868: IN
21869: PUSH
21870: LD_INT 28
21872: PUSH
21873: LD_VAR 0 5
21877: IN
21878: OR
21879: PUSH
21880: LD_INT 45
21882: PUSH
21883: LD_VAR 0 5
21887: IN
21888: OR
21889: AND
21890: IFFALSE 22144
// begin hex := GetHexInfo ( x , y ) ;
21892: LD_ADDR_VAR 0 4
21896: PUSH
21897: LD_VAR 0 10
21901: PPUSH
21902: LD_VAR 0 11
21906: PPUSH
21907: CALL_OW 546
21911: ST_TO_ADDR
// if hex [ 1 ] then
21912: LD_VAR 0 4
21916: PUSH
21917: LD_INT 1
21919: ARRAY
21920: IFFALSE 21924
// exit ;
21922: GO 22327
// height := hex [ 2 ] ;
21924: LD_ADDR_VAR 0 15
21928: PUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21938: LD_ADDR_VAR 0 14
21942: PUSH
21943: LD_INT 0
21945: PUSH
21946: LD_INT 2
21948: PUSH
21949: LD_INT 3
21951: PUSH
21952: LD_INT 5
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: LIST
21959: LIST
21960: ST_TO_ADDR
// for i in tmp do
21961: LD_ADDR_VAR 0 8
21965: PUSH
21966: LD_VAR 0 14
21970: PUSH
21971: FOR_IN
21972: IFFALSE 22142
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21974: LD_ADDR_VAR 0 9
21978: PUSH
21979: LD_VAR 0 10
21983: PPUSH
21984: LD_VAR 0 8
21988: PPUSH
21989: LD_INT 5
21991: PPUSH
21992: CALL_OW 272
21996: PUSH
21997: LD_VAR 0 11
22001: PPUSH
22002: LD_VAR 0 8
22006: PPUSH
22007: LD_INT 5
22009: PPUSH
22010: CALL_OW 273
22014: PUSH
22015: EMPTY
22016: LIST
22017: LIST
22018: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22019: LD_VAR 0 9
22023: PUSH
22024: LD_INT 1
22026: ARRAY
22027: PPUSH
22028: LD_VAR 0 9
22032: PUSH
22033: LD_INT 2
22035: ARRAY
22036: PPUSH
22037: CALL_OW 488
22041: IFFALSE 22140
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22043: LD_ADDR_VAR 0 4
22047: PUSH
22048: LD_VAR 0 9
22052: PUSH
22053: LD_INT 1
22055: ARRAY
22056: PPUSH
22057: LD_VAR 0 9
22061: PUSH
22062: LD_INT 2
22064: ARRAY
22065: PPUSH
22066: CALL_OW 546
22070: ST_TO_ADDR
// if hex [ 1 ] then
22071: LD_VAR 0 4
22075: PUSH
22076: LD_INT 1
22078: ARRAY
22079: IFFALSE 22083
// continue ;
22081: GO 21971
// h := hex [ 2 ] ;
22083: LD_ADDR_VAR 0 13
22087: PUSH
22088: LD_VAR 0 4
22092: PUSH
22093: LD_INT 2
22095: ARRAY
22096: ST_TO_ADDR
// if h + 7 < height then
22097: LD_VAR 0 13
22101: PUSH
22102: LD_INT 7
22104: PLUS
22105: PUSH
22106: LD_VAR 0 15
22110: LESS
22111: IFFALSE 22140
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22113: LD_ADDR_VAR 0 18
22117: PUSH
22118: LD_INT 7
22120: PUSH
22121: LD_INT 28
22123: PUSH
22124: LD_INT 45
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: LIST
22131: PUSH
22132: LD_VAR 0 12
22136: ARRAY
22137: ST_TO_ADDR
// break ;
22138: GO 22142
// end ; end ; end ;
22140: GO 21971
22142: POP
22143: POP
// end ; if not weapon then
22144: LD_VAR 0 18
22148: NOT
22149: IFFALSE 22209
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22151: LD_ADDR_VAR 0 5
22155: PUSH
22156: LD_VAR 0 5
22160: PUSH
22161: LD_INT 11
22163: PUSH
22164: LD_INT 30
22166: PUSH
22167: LD_INT 49
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: LIST
22174: DIFF
22175: ST_TO_ADDR
// if not list then
22176: LD_VAR 0 5
22180: NOT
22181: IFFALSE 22185
// exit ;
22183: GO 22327
// weapon := list [ rand ( 1 , list ) ] ;
22185: LD_ADDR_VAR 0 18
22189: PUSH
22190: LD_VAR 0 5
22194: PUSH
22195: LD_INT 1
22197: PPUSH
22198: LD_VAR 0 5
22202: PPUSH
22203: CALL_OW 12
22207: ARRAY
22208: ST_TO_ADDR
// end ; if weapon then
22209: LD_VAR 0 18
22213: IFFALSE 22327
// begin tmp := CostOfWeapon ( weapon ) ;
22215: LD_ADDR_VAR 0 14
22219: PUSH
22220: LD_VAR 0 18
22224: PPUSH
22225: CALL_OW 451
22229: ST_TO_ADDR
// j := GetBase ( tower ) ;
22230: LD_ADDR_VAR 0 9
22234: PUSH
22235: LD_VAR 0 1
22239: PPUSH
22240: CALL_OW 274
22244: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22245: LD_VAR 0 9
22249: PPUSH
22250: LD_INT 1
22252: PPUSH
22253: CALL_OW 275
22257: PUSH
22258: LD_VAR 0 14
22262: PUSH
22263: LD_INT 1
22265: ARRAY
22266: GREATEREQUAL
22267: PUSH
22268: LD_VAR 0 9
22272: PPUSH
22273: LD_INT 2
22275: PPUSH
22276: CALL_OW 275
22280: PUSH
22281: LD_VAR 0 14
22285: PUSH
22286: LD_INT 2
22288: ARRAY
22289: GREATEREQUAL
22290: AND
22291: PUSH
22292: LD_VAR 0 9
22296: PPUSH
22297: LD_INT 3
22299: PPUSH
22300: CALL_OW 275
22304: PUSH
22305: LD_VAR 0 14
22309: PUSH
22310: LD_INT 3
22312: ARRAY
22313: GREATEREQUAL
22314: AND
22315: IFFALSE 22327
// result := weapon ;
22317: LD_ADDR_VAR 0 3
22321: PUSH
22322: LD_VAR 0 18
22326: ST_TO_ADDR
// end ; end ;
22327: LD_VAR 0 3
22331: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22332: LD_INT 0
22334: PPUSH
22335: PPUSH
// result := true ;
22336: LD_ADDR_VAR 0 3
22340: PUSH
22341: LD_INT 1
22343: ST_TO_ADDR
// if array1 = array2 then
22344: LD_VAR 0 1
22348: PUSH
22349: LD_VAR 0 2
22353: EQUAL
22354: IFFALSE 22414
// begin for i = 1 to array1 do
22356: LD_ADDR_VAR 0 4
22360: PUSH
22361: DOUBLE
22362: LD_INT 1
22364: DEC
22365: ST_TO_ADDR
22366: LD_VAR 0 1
22370: PUSH
22371: FOR_TO
22372: IFFALSE 22410
// if array1 [ i ] <> array2 [ i ] then
22374: LD_VAR 0 1
22378: PUSH
22379: LD_VAR 0 4
22383: ARRAY
22384: PUSH
22385: LD_VAR 0 2
22389: PUSH
22390: LD_VAR 0 4
22394: ARRAY
22395: NONEQUAL
22396: IFFALSE 22408
// begin result := false ;
22398: LD_ADDR_VAR 0 3
22402: PUSH
22403: LD_INT 0
22405: ST_TO_ADDR
// break ;
22406: GO 22410
// end ;
22408: GO 22371
22410: POP
22411: POP
// end else
22412: GO 22422
// result := false ;
22414: LD_ADDR_VAR 0 3
22418: PUSH
22419: LD_INT 0
22421: ST_TO_ADDR
// end ;
22422: LD_VAR 0 3
22426: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22427: LD_INT 0
22429: PPUSH
22430: PPUSH
// if not array1 or not array2 then
22431: LD_VAR 0 1
22435: NOT
22436: PUSH
22437: LD_VAR 0 2
22441: NOT
22442: OR
22443: IFFALSE 22447
// exit ;
22445: GO 22511
// result := true ;
22447: LD_ADDR_VAR 0 3
22451: PUSH
22452: LD_INT 1
22454: ST_TO_ADDR
// for i = 1 to array1 do
22455: LD_ADDR_VAR 0 4
22459: PUSH
22460: DOUBLE
22461: LD_INT 1
22463: DEC
22464: ST_TO_ADDR
22465: LD_VAR 0 1
22469: PUSH
22470: FOR_TO
22471: IFFALSE 22509
// if array1 [ i ] <> array2 [ i ] then
22473: LD_VAR 0 1
22477: PUSH
22478: LD_VAR 0 4
22482: ARRAY
22483: PUSH
22484: LD_VAR 0 2
22488: PUSH
22489: LD_VAR 0 4
22493: ARRAY
22494: NONEQUAL
22495: IFFALSE 22507
// begin result := false ;
22497: LD_ADDR_VAR 0 3
22501: PUSH
22502: LD_INT 0
22504: ST_TO_ADDR
// break ;
22505: GO 22509
// end ;
22507: GO 22470
22509: POP
22510: POP
// end ;
22511: LD_VAR 0 3
22515: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22516: LD_INT 0
22518: PPUSH
22519: PPUSH
22520: PPUSH
// pom := GetBase ( fac ) ;
22521: LD_ADDR_VAR 0 5
22525: PUSH
22526: LD_VAR 0 1
22530: PPUSH
22531: CALL_OW 274
22535: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22536: LD_ADDR_VAR 0 4
22540: PUSH
22541: LD_VAR 0 2
22545: PUSH
22546: LD_INT 1
22548: ARRAY
22549: PPUSH
22550: LD_VAR 0 2
22554: PUSH
22555: LD_INT 2
22557: ARRAY
22558: PPUSH
22559: LD_VAR 0 2
22563: PUSH
22564: LD_INT 3
22566: ARRAY
22567: PPUSH
22568: LD_VAR 0 2
22572: PUSH
22573: LD_INT 4
22575: ARRAY
22576: PPUSH
22577: CALL_OW 449
22581: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22582: LD_ADDR_VAR 0 3
22586: PUSH
22587: LD_VAR 0 5
22591: PPUSH
22592: LD_INT 1
22594: PPUSH
22595: CALL_OW 275
22599: PUSH
22600: LD_VAR 0 4
22604: PUSH
22605: LD_INT 1
22607: ARRAY
22608: GREATEREQUAL
22609: PUSH
22610: LD_VAR 0 5
22614: PPUSH
22615: LD_INT 2
22617: PPUSH
22618: CALL_OW 275
22622: PUSH
22623: LD_VAR 0 4
22627: PUSH
22628: LD_INT 2
22630: ARRAY
22631: GREATEREQUAL
22632: AND
22633: PUSH
22634: LD_VAR 0 5
22638: PPUSH
22639: LD_INT 3
22641: PPUSH
22642: CALL_OW 275
22646: PUSH
22647: LD_VAR 0 4
22651: PUSH
22652: LD_INT 3
22654: ARRAY
22655: GREATEREQUAL
22656: AND
22657: ST_TO_ADDR
// end ;
22658: LD_VAR 0 3
22662: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22663: LD_INT 0
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
// pom := GetBase ( building ) ;
22669: LD_ADDR_VAR 0 3
22673: PUSH
22674: LD_VAR 0 1
22678: PPUSH
22679: CALL_OW 274
22683: ST_TO_ADDR
// if not pom then
22684: LD_VAR 0 3
22688: NOT
22689: IFFALSE 22693
// exit ;
22691: GO 22863
// btype := GetBType ( building ) ;
22693: LD_ADDR_VAR 0 5
22697: PUSH
22698: LD_VAR 0 1
22702: PPUSH
22703: CALL_OW 266
22707: ST_TO_ADDR
// if btype = b_armoury then
22708: LD_VAR 0 5
22712: PUSH
22713: LD_INT 4
22715: EQUAL
22716: IFFALSE 22726
// btype := b_barracks ;
22718: LD_ADDR_VAR 0 5
22722: PUSH
22723: LD_INT 5
22725: ST_TO_ADDR
// if btype = b_depot then
22726: LD_VAR 0 5
22730: PUSH
22731: LD_INT 0
22733: EQUAL
22734: IFFALSE 22744
// btype := b_warehouse ;
22736: LD_ADDR_VAR 0 5
22740: PUSH
22741: LD_INT 1
22743: ST_TO_ADDR
// if btype = b_workshop then
22744: LD_VAR 0 5
22748: PUSH
22749: LD_INT 2
22751: EQUAL
22752: IFFALSE 22762
// btype := b_factory ;
22754: LD_ADDR_VAR 0 5
22758: PUSH
22759: LD_INT 3
22761: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22762: LD_ADDR_VAR 0 4
22766: PUSH
22767: LD_VAR 0 5
22771: PPUSH
22772: LD_VAR 0 1
22776: PPUSH
22777: CALL_OW 248
22781: PPUSH
22782: CALL_OW 450
22786: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22787: LD_ADDR_VAR 0 2
22791: PUSH
22792: LD_VAR 0 3
22796: PPUSH
22797: LD_INT 1
22799: PPUSH
22800: CALL_OW 275
22804: PUSH
22805: LD_VAR 0 4
22809: PUSH
22810: LD_INT 1
22812: ARRAY
22813: GREATEREQUAL
22814: PUSH
22815: LD_VAR 0 3
22819: PPUSH
22820: LD_INT 2
22822: PPUSH
22823: CALL_OW 275
22827: PUSH
22828: LD_VAR 0 4
22832: PUSH
22833: LD_INT 2
22835: ARRAY
22836: GREATEREQUAL
22837: AND
22838: PUSH
22839: LD_VAR 0 3
22843: PPUSH
22844: LD_INT 3
22846: PPUSH
22847: CALL_OW 275
22851: PUSH
22852: LD_VAR 0 4
22856: PUSH
22857: LD_INT 3
22859: ARRAY
22860: GREATEREQUAL
22861: AND
22862: ST_TO_ADDR
// end ;
22863: LD_VAR 0 2
22867: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22868: LD_INT 0
22870: PPUSH
22871: PPUSH
22872: PPUSH
// pom := GetBase ( building ) ;
22873: LD_ADDR_VAR 0 4
22877: PUSH
22878: LD_VAR 0 1
22882: PPUSH
22883: CALL_OW 274
22887: ST_TO_ADDR
// if not pom then
22888: LD_VAR 0 4
22892: NOT
22893: IFFALSE 22897
// exit ;
22895: GO 22998
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22897: LD_ADDR_VAR 0 5
22901: PUSH
22902: LD_VAR 0 2
22906: PPUSH
22907: LD_VAR 0 1
22911: PPUSH
22912: CALL_OW 248
22916: PPUSH
22917: CALL_OW 450
22921: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22922: LD_ADDR_VAR 0 3
22926: PUSH
22927: LD_VAR 0 4
22931: PPUSH
22932: LD_INT 1
22934: PPUSH
22935: CALL_OW 275
22939: PUSH
22940: LD_VAR 0 5
22944: PUSH
22945: LD_INT 1
22947: ARRAY
22948: GREATEREQUAL
22949: PUSH
22950: LD_VAR 0 4
22954: PPUSH
22955: LD_INT 2
22957: PPUSH
22958: CALL_OW 275
22962: PUSH
22963: LD_VAR 0 5
22967: PUSH
22968: LD_INT 2
22970: ARRAY
22971: GREATEREQUAL
22972: AND
22973: PUSH
22974: LD_VAR 0 4
22978: PPUSH
22979: LD_INT 3
22981: PPUSH
22982: CALL_OW 275
22986: PUSH
22987: LD_VAR 0 5
22991: PUSH
22992: LD_INT 3
22994: ARRAY
22995: GREATEREQUAL
22996: AND
22997: ST_TO_ADDR
// end ;
22998: LD_VAR 0 3
23002: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23003: LD_INT 0
23005: PPUSH
23006: PPUSH
23007: PPUSH
23008: PPUSH
23009: PPUSH
23010: PPUSH
23011: PPUSH
23012: PPUSH
23013: PPUSH
23014: PPUSH
23015: PPUSH
// result := false ;
23016: LD_ADDR_VAR 0 8
23020: PUSH
23021: LD_INT 0
23023: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23024: LD_VAR 0 5
23028: NOT
23029: PUSH
23030: LD_VAR 0 1
23034: NOT
23035: OR
23036: PUSH
23037: LD_VAR 0 2
23041: NOT
23042: OR
23043: PUSH
23044: LD_VAR 0 3
23048: NOT
23049: OR
23050: IFFALSE 23054
// exit ;
23052: GO 23868
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23054: LD_ADDR_VAR 0 14
23058: PUSH
23059: LD_VAR 0 1
23063: PPUSH
23064: LD_VAR 0 2
23068: PPUSH
23069: LD_VAR 0 3
23073: PPUSH
23074: LD_VAR 0 4
23078: PPUSH
23079: LD_VAR 0 5
23083: PUSH
23084: LD_INT 1
23086: ARRAY
23087: PPUSH
23088: CALL_OW 248
23092: PPUSH
23093: LD_INT 0
23095: PPUSH
23096: CALL 25101 0 6
23100: ST_TO_ADDR
// if not hexes then
23101: LD_VAR 0 14
23105: NOT
23106: IFFALSE 23110
// exit ;
23108: GO 23868
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23110: LD_ADDR_VAR 0 17
23114: PUSH
23115: LD_VAR 0 5
23119: PPUSH
23120: LD_INT 22
23122: PUSH
23123: LD_VAR 0 13
23127: PPUSH
23128: CALL_OW 255
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: PUSH
23137: LD_INT 2
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 0
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 30
23152: PUSH
23153: LD_INT 1
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PPUSH
23169: CALL_OW 72
23173: ST_TO_ADDR
// for i = 1 to hexes do
23174: LD_ADDR_VAR 0 9
23178: PUSH
23179: DOUBLE
23180: LD_INT 1
23182: DEC
23183: ST_TO_ADDR
23184: LD_VAR 0 14
23188: PUSH
23189: FOR_TO
23190: IFFALSE 23866
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23192: LD_ADDR_VAR 0 13
23196: PUSH
23197: LD_VAR 0 14
23201: PUSH
23202: LD_VAR 0 9
23206: ARRAY
23207: PUSH
23208: LD_INT 1
23210: ARRAY
23211: PPUSH
23212: LD_VAR 0 14
23216: PUSH
23217: LD_VAR 0 9
23221: ARRAY
23222: PUSH
23223: LD_INT 2
23225: ARRAY
23226: PPUSH
23227: CALL_OW 428
23231: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23232: LD_VAR 0 14
23236: PUSH
23237: LD_VAR 0 9
23241: ARRAY
23242: PUSH
23243: LD_INT 1
23245: ARRAY
23246: PPUSH
23247: LD_VAR 0 14
23251: PUSH
23252: LD_VAR 0 9
23256: ARRAY
23257: PUSH
23258: LD_INT 2
23260: ARRAY
23261: PPUSH
23262: CALL_OW 351
23266: PUSH
23267: LD_VAR 0 14
23271: PUSH
23272: LD_VAR 0 9
23276: ARRAY
23277: PUSH
23278: LD_INT 1
23280: ARRAY
23281: PPUSH
23282: LD_VAR 0 14
23286: PUSH
23287: LD_VAR 0 9
23291: ARRAY
23292: PUSH
23293: LD_INT 2
23295: ARRAY
23296: PPUSH
23297: CALL_OW 488
23301: NOT
23302: OR
23303: PUSH
23304: LD_VAR 0 13
23308: PPUSH
23309: CALL_OW 247
23313: PUSH
23314: LD_INT 3
23316: EQUAL
23317: OR
23318: IFFALSE 23324
// exit ;
23320: POP
23321: POP
23322: GO 23868
// if not tmp then
23324: LD_VAR 0 13
23328: NOT
23329: IFFALSE 23333
// continue ;
23331: GO 23189
// result := true ;
23333: LD_ADDR_VAR 0 8
23337: PUSH
23338: LD_INT 1
23340: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23341: LD_VAR 0 6
23345: PUSH
23346: LD_VAR 0 13
23350: PPUSH
23351: CALL_OW 247
23355: PUSH
23356: LD_INT 2
23358: EQUAL
23359: AND
23360: PUSH
23361: LD_VAR 0 13
23365: PPUSH
23366: CALL_OW 263
23370: PUSH
23371: LD_INT 1
23373: EQUAL
23374: AND
23375: IFFALSE 23539
// begin if IsDrivenBy ( tmp ) then
23377: LD_VAR 0 13
23381: PPUSH
23382: CALL_OW 311
23386: IFFALSE 23390
// continue ;
23388: GO 23189
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23390: LD_VAR 0 6
23394: PPUSH
23395: LD_INT 3
23397: PUSH
23398: LD_INT 60
23400: PUSH
23401: EMPTY
23402: LIST
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: LD_INT 3
23410: PUSH
23411: LD_INT 55
23413: PUSH
23414: EMPTY
23415: LIST
23416: PUSH
23417: EMPTY
23418: LIST
23419: LIST
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PPUSH
23425: CALL_OW 72
23429: IFFALSE 23537
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23431: LD_ADDR_VAR 0 18
23435: PUSH
23436: LD_VAR 0 6
23440: PPUSH
23441: LD_INT 3
23443: PUSH
23444: LD_INT 60
23446: PUSH
23447: EMPTY
23448: LIST
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 3
23456: PUSH
23457: LD_INT 55
23459: PUSH
23460: EMPTY
23461: LIST
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: PUSH
23476: LD_INT 1
23478: ARRAY
23479: ST_TO_ADDR
// if IsInUnit ( driver ) then
23480: LD_VAR 0 18
23484: PPUSH
23485: CALL_OW 310
23489: IFFALSE 23500
// ComExit ( driver ) ;
23491: LD_VAR 0 18
23495: PPUSH
23496: CALL 48862 0 1
// AddComEnterUnit ( driver , tmp ) ;
23500: LD_VAR 0 18
23504: PPUSH
23505: LD_VAR 0 13
23509: PPUSH
23510: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23514: LD_VAR 0 18
23518: PPUSH
23519: LD_VAR 0 7
23523: PPUSH
23524: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23528: LD_VAR 0 18
23532: PPUSH
23533: CALL_OW 181
// end ; continue ;
23537: GO 23189
// end ; if not cleaners or not tmp in cleaners then
23539: LD_VAR 0 6
23543: NOT
23544: PUSH
23545: LD_VAR 0 13
23549: PUSH
23550: LD_VAR 0 6
23554: IN
23555: NOT
23556: OR
23557: IFFALSE 23864
// begin if dep then
23559: LD_VAR 0 17
23563: IFFALSE 23699
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23565: LD_ADDR_VAR 0 16
23569: PUSH
23570: LD_VAR 0 17
23574: PUSH
23575: LD_INT 1
23577: ARRAY
23578: PPUSH
23579: CALL_OW 250
23583: PPUSH
23584: LD_VAR 0 17
23588: PUSH
23589: LD_INT 1
23591: ARRAY
23592: PPUSH
23593: CALL_OW 254
23597: PPUSH
23598: LD_INT 5
23600: PPUSH
23601: CALL_OW 272
23605: PUSH
23606: LD_VAR 0 17
23610: PUSH
23611: LD_INT 1
23613: ARRAY
23614: PPUSH
23615: CALL_OW 251
23619: PPUSH
23620: LD_VAR 0 17
23624: PUSH
23625: LD_INT 1
23627: ARRAY
23628: PPUSH
23629: CALL_OW 254
23633: PPUSH
23634: LD_INT 5
23636: PPUSH
23637: CALL_OW 273
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23646: LD_VAR 0 16
23650: PUSH
23651: LD_INT 1
23653: ARRAY
23654: PPUSH
23655: LD_VAR 0 16
23659: PUSH
23660: LD_INT 2
23662: ARRAY
23663: PPUSH
23664: CALL_OW 488
23668: IFFALSE 23699
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23670: LD_VAR 0 13
23674: PPUSH
23675: LD_VAR 0 16
23679: PUSH
23680: LD_INT 1
23682: ARRAY
23683: PPUSH
23684: LD_VAR 0 16
23688: PUSH
23689: LD_INT 2
23691: ARRAY
23692: PPUSH
23693: CALL_OW 111
// continue ;
23697: GO 23189
// end ; end ; r := GetDir ( tmp ) ;
23699: LD_ADDR_VAR 0 15
23703: PUSH
23704: LD_VAR 0 13
23708: PPUSH
23709: CALL_OW 254
23713: ST_TO_ADDR
// if r = 5 then
23714: LD_VAR 0 15
23718: PUSH
23719: LD_INT 5
23721: EQUAL
23722: IFFALSE 23732
// r := 0 ;
23724: LD_ADDR_VAR 0 15
23728: PUSH
23729: LD_INT 0
23731: ST_TO_ADDR
// for j = r to 5 do
23732: LD_ADDR_VAR 0 10
23736: PUSH
23737: DOUBLE
23738: LD_VAR 0 15
23742: DEC
23743: ST_TO_ADDR
23744: LD_INT 5
23746: PUSH
23747: FOR_TO
23748: IFFALSE 23862
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23750: LD_ADDR_VAR 0 11
23754: PUSH
23755: LD_VAR 0 13
23759: PPUSH
23760: CALL_OW 250
23764: PPUSH
23765: LD_VAR 0 10
23769: PPUSH
23770: LD_INT 2
23772: PPUSH
23773: CALL_OW 272
23777: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23778: LD_ADDR_VAR 0 12
23782: PUSH
23783: LD_VAR 0 13
23787: PPUSH
23788: CALL_OW 251
23792: PPUSH
23793: LD_VAR 0 10
23797: PPUSH
23798: LD_INT 2
23800: PPUSH
23801: CALL_OW 273
23805: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23806: LD_VAR 0 11
23810: PPUSH
23811: LD_VAR 0 12
23815: PPUSH
23816: CALL_OW 488
23820: PUSH
23821: LD_VAR 0 11
23825: PPUSH
23826: LD_VAR 0 12
23830: PPUSH
23831: CALL_OW 428
23835: NOT
23836: AND
23837: IFFALSE 23860
// begin ComMoveXY ( tmp , _x , _y ) ;
23839: LD_VAR 0 13
23843: PPUSH
23844: LD_VAR 0 11
23848: PPUSH
23849: LD_VAR 0 12
23853: PPUSH
23854: CALL_OW 111
// break ;
23858: GO 23862
// end ; end ;
23860: GO 23747
23862: POP
23863: POP
// end ; end ;
23864: GO 23189
23866: POP
23867: POP
// end ;
23868: LD_VAR 0 8
23872: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23873: LD_INT 0
23875: PPUSH
// result := true ;
23876: LD_ADDR_VAR 0 3
23880: PUSH
23881: LD_INT 1
23883: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23884: LD_VAR 0 2
23888: PUSH
23889: LD_INT 24
23891: DOUBLE
23892: EQUAL
23893: IFTRUE 23903
23895: LD_INT 33
23897: DOUBLE
23898: EQUAL
23899: IFTRUE 23903
23901: GO 23928
23903: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23904: LD_ADDR_VAR 0 3
23908: PUSH
23909: LD_INT 32
23911: PPUSH
23912: LD_VAR 0 1
23916: PPUSH
23917: CALL_OW 321
23921: PUSH
23922: LD_INT 2
23924: EQUAL
23925: ST_TO_ADDR
23926: GO 24244
23928: LD_INT 20
23930: DOUBLE
23931: EQUAL
23932: IFTRUE 23936
23934: GO 23961
23936: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23937: LD_ADDR_VAR 0 3
23941: PUSH
23942: LD_INT 6
23944: PPUSH
23945: LD_VAR 0 1
23949: PPUSH
23950: CALL_OW 321
23954: PUSH
23955: LD_INT 2
23957: EQUAL
23958: ST_TO_ADDR
23959: GO 24244
23961: LD_INT 22
23963: DOUBLE
23964: EQUAL
23965: IFTRUE 23975
23967: LD_INT 36
23969: DOUBLE
23970: EQUAL
23971: IFTRUE 23975
23973: GO 24000
23975: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23976: LD_ADDR_VAR 0 3
23980: PUSH
23981: LD_INT 15
23983: PPUSH
23984: LD_VAR 0 1
23988: PPUSH
23989: CALL_OW 321
23993: PUSH
23994: LD_INT 2
23996: EQUAL
23997: ST_TO_ADDR
23998: GO 24244
24000: LD_INT 30
24002: DOUBLE
24003: EQUAL
24004: IFTRUE 24008
24006: GO 24033
24008: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24009: LD_ADDR_VAR 0 3
24013: PUSH
24014: LD_INT 20
24016: PPUSH
24017: LD_VAR 0 1
24021: PPUSH
24022: CALL_OW 321
24026: PUSH
24027: LD_INT 2
24029: EQUAL
24030: ST_TO_ADDR
24031: GO 24244
24033: LD_INT 28
24035: DOUBLE
24036: EQUAL
24037: IFTRUE 24047
24039: LD_INT 21
24041: DOUBLE
24042: EQUAL
24043: IFTRUE 24047
24045: GO 24072
24047: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24048: LD_ADDR_VAR 0 3
24052: PUSH
24053: LD_INT 21
24055: PPUSH
24056: LD_VAR 0 1
24060: PPUSH
24061: CALL_OW 321
24065: PUSH
24066: LD_INT 2
24068: EQUAL
24069: ST_TO_ADDR
24070: GO 24244
24072: LD_INT 16
24074: DOUBLE
24075: EQUAL
24076: IFTRUE 24080
24078: GO 24105
24080: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24081: LD_ADDR_VAR 0 3
24085: PUSH
24086: LD_INT 84
24088: PPUSH
24089: LD_VAR 0 1
24093: PPUSH
24094: CALL_OW 321
24098: PUSH
24099: LD_INT 2
24101: EQUAL
24102: ST_TO_ADDR
24103: GO 24244
24105: LD_INT 19
24107: DOUBLE
24108: EQUAL
24109: IFTRUE 24119
24111: LD_INT 23
24113: DOUBLE
24114: EQUAL
24115: IFTRUE 24119
24117: GO 24144
24119: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24120: LD_ADDR_VAR 0 3
24124: PUSH
24125: LD_INT 83
24127: PPUSH
24128: LD_VAR 0 1
24132: PPUSH
24133: CALL_OW 321
24137: PUSH
24138: LD_INT 2
24140: EQUAL
24141: ST_TO_ADDR
24142: GO 24244
24144: LD_INT 17
24146: DOUBLE
24147: EQUAL
24148: IFTRUE 24152
24150: GO 24177
24152: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24153: LD_ADDR_VAR 0 3
24157: PUSH
24158: LD_INT 39
24160: PPUSH
24161: LD_VAR 0 1
24165: PPUSH
24166: CALL_OW 321
24170: PUSH
24171: LD_INT 2
24173: EQUAL
24174: ST_TO_ADDR
24175: GO 24244
24177: LD_INT 18
24179: DOUBLE
24180: EQUAL
24181: IFTRUE 24185
24183: GO 24210
24185: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24186: LD_ADDR_VAR 0 3
24190: PUSH
24191: LD_INT 40
24193: PPUSH
24194: LD_VAR 0 1
24198: PPUSH
24199: CALL_OW 321
24203: PUSH
24204: LD_INT 2
24206: EQUAL
24207: ST_TO_ADDR
24208: GO 24244
24210: LD_INT 27
24212: DOUBLE
24213: EQUAL
24214: IFTRUE 24218
24216: GO 24243
24218: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24219: LD_ADDR_VAR 0 3
24223: PUSH
24224: LD_INT 35
24226: PPUSH
24227: LD_VAR 0 1
24231: PPUSH
24232: CALL_OW 321
24236: PUSH
24237: LD_INT 2
24239: EQUAL
24240: ST_TO_ADDR
24241: GO 24244
24243: POP
// end ;
24244: LD_VAR 0 3
24248: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24249: LD_INT 0
24251: PPUSH
24252: PPUSH
24253: PPUSH
24254: PPUSH
24255: PPUSH
24256: PPUSH
24257: PPUSH
24258: PPUSH
24259: PPUSH
24260: PPUSH
24261: PPUSH
// result := false ;
24262: LD_ADDR_VAR 0 6
24266: PUSH
24267: LD_INT 0
24269: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24270: LD_VAR 0 1
24274: NOT
24275: PUSH
24276: LD_VAR 0 1
24280: PPUSH
24281: CALL_OW 266
24285: PUSH
24286: LD_INT 0
24288: PUSH
24289: LD_INT 1
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: IN
24296: NOT
24297: OR
24298: PUSH
24299: LD_VAR 0 2
24303: NOT
24304: OR
24305: PUSH
24306: LD_VAR 0 5
24310: PUSH
24311: LD_INT 0
24313: PUSH
24314: LD_INT 1
24316: PUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 3
24322: PUSH
24323: LD_INT 4
24325: PUSH
24326: LD_INT 5
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: IN
24337: NOT
24338: OR
24339: PUSH
24340: LD_VAR 0 3
24344: PPUSH
24345: LD_VAR 0 4
24349: PPUSH
24350: CALL_OW 488
24354: NOT
24355: OR
24356: IFFALSE 24360
// exit ;
24358: GO 25096
// side := GetSide ( depot ) ;
24360: LD_ADDR_VAR 0 9
24364: PUSH
24365: LD_VAR 0 1
24369: PPUSH
24370: CALL_OW 255
24374: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24375: LD_VAR 0 9
24379: PPUSH
24380: LD_VAR 0 2
24384: PPUSH
24385: CALL 23873 0 2
24389: NOT
24390: IFFALSE 24394
// exit ;
24392: GO 25096
// pom := GetBase ( depot ) ;
24394: LD_ADDR_VAR 0 10
24398: PUSH
24399: LD_VAR 0 1
24403: PPUSH
24404: CALL_OW 274
24408: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24409: LD_ADDR_VAR 0 11
24413: PUSH
24414: LD_VAR 0 2
24418: PPUSH
24419: LD_VAR 0 1
24423: PPUSH
24424: CALL_OW 248
24428: PPUSH
24429: CALL_OW 450
24433: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24434: LD_VAR 0 10
24438: PPUSH
24439: LD_INT 1
24441: PPUSH
24442: CALL_OW 275
24446: PUSH
24447: LD_VAR 0 11
24451: PUSH
24452: LD_INT 1
24454: ARRAY
24455: GREATEREQUAL
24456: PUSH
24457: LD_VAR 0 10
24461: PPUSH
24462: LD_INT 2
24464: PPUSH
24465: CALL_OW 275
24469: PUSH
24470: LD_VAR 0 11
24474: PUSH
24475: LD_INT 2
24477: ARRAY
24478: GREATEREQUAL
24479: AND
24480: PUSH
24481: LD_VAR 0 10
24485: PPUSH
24486: LD_INT 3
24488: PPUSH
24489: CALL_OW 275
24493: PUSH
24494: LD_VAR 0 11
24498: PUSH
24499: LD_INT 3
24501: ARRAY
24502: GREATEREQUAL
24503: AND
24504: NOT
24505: IFFALSE 24509
// exit ;
24507: GO 25096
// if GetBType ( depot ) = b_depot then
24509: LD_VAR 0 1
24513: PPUSH
24514: CALL_OW 266
24518: PUSH
24519: LD_INT 0
24521: EQUAL
24522: IFFALSE 24534
// dist := 28 else
24524: LD_ADDR_VAR 0 14
24528: PUSH
24529: LD_INT 28
24531: ST_TO_ADDR
24532: GO 24542
// dist := 36 ;
24534: LD_ADDR_VAR 0 14
24538: PUSH
24539: LD_INT 36
24541: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24542: LD_VAR 0 1
24546: PPUSH
24547: LD_VAR 0 3
24551: PPUSH
24552: LD_VAR 0 4
24556: PPUSH
24557: CALL_OW 297
24561: PUSH
24562: LD_VAR 0 14
24566: GREATER
24567: IFFALSE 24571
// exit ;
24569: GO 25096
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24571: LD_ADDR_VAR 0 12
24575: PUSH
24576: LD_VAR 0 2
24580: PPUSH
24581: LD_VAR 0 3
24585: PPUSH
24586: LD_VAR 0 4
24590: PPUSH
24591: LD_VAR 0 5
24595: PPUSH
24596: LD_VAR 0 1
24600: PPUSH
24601: CALL_OW 248
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL 25101 0 6
24613: ST_TO_ADDR
// if not hexes then
24614: LD_VAR 0 12
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 25096
// hex := GetHexInfo ( x , y ) ;
24623: LD_ADDR_VAR 0 15
24627: PUSH
24628: LD_VAR 0 3
24632: PPUSH
24633: LD_VAR 0 4
24637: PPUSH
24638: CALL_OW 546
24642: ST_TO_ADDR
// if hex [ 1 ] then
24643: LD_VAR 0 15
24647: PUSH
24648: LD_INT 1
24650: ARRAY
24651: IFFALSE 24655
// exit ;
24653: GO 25096
// height := hex [ 2 ] ;
24655: LD_ADDR_VAR 0 13
24659: PUSH
24660: LD_VAR 0 15
24664: PUSH
24665: LD_INT 2
24667: ARRAY
24668: ST_TO_ADDR
// for i = 1 to hexes do
24669: LD_ADDR_VAR 0 7
24673: PUSH
24674: DOUBLE
24675: LD_INT 1
24677: DEC
24678: ST_TO_ADDR
24679: LD_VAR 0 12
24683: PUSH
24684: FOR_TO
24685: IFFALSE 25015
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24687: LD_VAR 0 12
24691: PUSH
24692: LD_VAR 0 7
24696: ARRAY
24697: PUSH
24698: LD_INT 1
24700: ARRAY
24701: PPUSH
24702: LD_VAR 0 12
24706: PUSH
24707: LD_VAR 0 7
24711: ARRAY
24712: PUSH
24713: LD_INT 2
24715: ARRAY
24716: PPUSH
24717: CALL_OW 488
24721: NOT
24722: PUSH
24723: LD_VAR 0 12
24727: PUSH
24728: LD_VAR 0 7
24732: ARRAY
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: LD_VAR 0 12
24742: PUSH
24743: LD_VAR 0 7
24747: ARRAY
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PPUSH
24753: CALL_OW 428
24757: PUSH
24758: LD_INT 0
24760: GREATER
24761: OR
24762: PUSH
24763: LD_VAR 0 12
24767: PUSH
24768: LD_VAR 0 7
24772: ARRAY
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: PPUSH
24778: LD_VAR 0 12
24782: PUSH
24783: LD_VAR 0 7
24787: ARRAY
24788: PUSH
24789: LD_INT 2
24791: ARRAY
24792: PPUSH
24793: CALL_OW 351
24797: OR
24798: IFFALSE 24804
// exit ;
24800: POP
24801: POP
24802: GO 25096
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24804: LD_ADDR_VAR 0 8
24808: PUSH
24809: LD_VAR 0 12
24813: PUSH
24814: LD_VAR 0 7
24818: ARRAY
24819: PUSH
24820: LD_INT 1
24822: ARRAY
24823: PPUSH
24824: LD_VAR 0 12
24828: PUSH
24829: LD_VAR 0 7
24833: ARRAY
24834: PUSH
24835: LD_INT 2
24837: ARRAY
24838: PPUSH
24839: CALL_OW 546
24843: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24844: LD_VAR 0 8
24848: PUSH
24849: LD_INT 1
24851: ARRAY
24852: PUSH
24853: LD_VAR 0 8
24857: PUSH
24858: LD_INT 2
24860: ARRAY
24861: PUSH
24862: LD_VAR 0 13
24866: PUSH
24867: LD_INT 2
24869: PLUS
24870: GREATER
24871: OR
24872: PUSH
24873: LD_VAR 0 8
24877: PUSH
24878: LD_INT 2
24880: ARRAY
24881: PUSH
24882: LD_VAR 0 13
24886: PUSH
24887: LD_INT 2
24889: MINUS
24890: LESS
24891: OR
24892: PUSH
24893: LD_VAR 0 8
24897: PUSH
24898: LD_INT 3
24900: ARRAY
24901: PUSH
24902: LD_INT 0
24904: PUSH
24905: LD_INT 8
24907: PUSH
24908: LD_INT 9
24910: PUSH
24911: LD_INT 10
24913: PUSH
24914: LD_INT 11
24916: PUSH
24917: LD_INT 12
24919: PUSH
24920: LD_INT 13
24922: PUSH
24923: LD_INT 16
24925: PUSH
24926: LD_INT 17
24928: PUSH
24929: LD_INT 18
24931: PUSH
24932: LD_INT 19
24934: PUSH
24935: LD_INT 20
24937: PUSH
24938: LD_INT 21
24940: PUSH
24941: EMPTY
24942: LIST
24943: LIST
24944: LIST
24945: LIST
24946: LIST
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: IN
24956: NOT
24957: OR
24958: PUSH
24959: LD_VAR 0 8
24963: PUSH
24964: LD_INT 5
24966: ARRAY
24967: NOT
24968: OR
24969: PUSH
24970: LD_VAR 0 8
24974: PUSH
24975: LD_INT 6
24977: ARRAY
24978: PUSH
24979: LD_INT 1
24981: PUSH
24982: LD_INT 2
24984: PUSH
24985: LD_INT 7
24987: PUSH
24988: LD_INT 9
24990: PUSH
24991: LD_INT 10
24993: PUSH
24994: LD_INT 11
24996: PUSH
24997: EMPTY
24998: LIST
24999: LIST
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: IN
25005: NOT
25006: OR
25007: IFFALSE 25013
// exit ;
25009: POP
25010: POP
25011: GO 25096
// end ;
25013: GO 24684
25015: POP
25016: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25017: LD_VAR 0 9
25021: PPUSH
25022: LD_VAR 0 3
25026: PPUSH
25027: LD_VAR 0 4
25031: PPUSH
25032: LD_INT 20
25034: PPUSH
25035: CALL 17048 0 4
25039: PUSH
25040: LD_INT 4
25042: ARRAY
25043: IFFALSE 25047
// exit ;
25045: GO 25096
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25047: LD_VAR 0 2
25051: PUSH
25052: LD_INT 29
25054: PUSH
25055: LD_INT 30
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: IN
25062: PUSH
25063: LD_VAR 0 3
25067: PPUSH
25068: LD_VAR 0 4
25072: PPUSH
25073: LD_VAR 0 9
25077: PPUSH
25078: CALL_OW 440
25082: NOT
25083: AND
25084: IFFALSE 25088
// exit ;
25086: GO 25096
// result := true ;
25088: LD_ADDR_VAR 0 6
25092: PUSH
25093: LD_INT 1
25095: ST_TO_ADDR
// end ;
25096: LD_VAR 0 6
25100: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25101: LD_INT 0
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
25121: PPUSH
25122: PPUSH
25123: PPUSH
25124: PPUSH
25125: PPUSH
25126: PPUSH
25127: PPUSH
25128: PPUSH
25129: PPUSH
25130: PPUSH
25131: PPUSH
25132: PPUSH
25133: PPUSH
25134: PPUSH
25135: PPUSH
25136: PPUSH
25137: PPUSH
25138: PPUSH
25139: PPUSH
25140: PPUSH
25141: PPUSH
25142: PPUSH
25143: PPUSH
25144: PPUSH
25145: PPUSH
25146: PPUSH
25147: PPUSH
25148: PPUSH
25149: PPUSH
25150: PPUSH
25151: PPUSH
25152: PPUSH
25153: PPUSH
25154: PPUSH
25155: PPUSH
25156: PPUSH
25157: PPUSH
25158: PPUSH
25159: PPUSH
25160: PPUSH
// result = [ ] ;
25161: LD_ADDR_VAR 0 7
25165: PUSH
25166: EMPTY
25167: ST_TO_ADDR
// temp_list = [ ] ;
25168: LD_ADDR_VAR 0 9
25172: PUSH
25173: EMPTY
25174: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25175: LD_VAR 0 4
25179: PUSH
25180: LD_INT 0
25182: PUSH
25183: LD_INT 1
25185: PUSH
25186: LD_INT 2
25188: PUSH
25189: LD_INT 3
25191: PUSH
25192: LD_INT 4
25194: PUSH
25195: LD_INT 5
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: IN
25206: NOT
25207: PUSH
25208: LD_VAR 0 1
25212: PUSH
25213: LD_INT 0
25215: PUSH
25216: LD_INT 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: IN
25223: PUSH
25224: LD_VAR 0 5
25228: PUSH
25229: LD_INT 1
25231: PUSH
25232: LD_INT 2
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: LIST
25242: IN
25243: NOT
25244: AND
25245: OR
25246: IFFALSE 25250
// exit ;
25248: GO 43641
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25250: LD_VAR 0 1
25254: PUSH
25255: LD_INT 6
25257: PUSH
25258: LD_INT 7
25260: PUSH
25261: LD_INT 8
25263: PUSH
25264: LD_INT 13
25266: PUSH
25267: LD_INT 12
25269: PUSH
25270: LD_INT 15
25272: PUSH
25273: LD_INT 11
25275: PUSH
25276: LD_INT 14
25278: PUSH
25279: LD_INT 10
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: IN
25293: IFFALSE 25303
// btype = b_lab ;
25295: LD_ADDR_VAR 0 1
25299: PUSH
25300: LD_INT 6
25302: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25303: LD_VAR 0 6
25307: PUSH
25308: LD_INT 0
25310: PUSH
25311: LD_INT 1
25313: PUSH
25314: LD_INT 2
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: LIST
25321: IN
25322: NOT
25323: PUSH
25324: LD_VAR 0 1
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: LD_INT 2
25337: PUSH
25338: LD_INT 3
25340: PUSH
25341: LD_INT 6
25343: PUSH
25344: LD_INT 36
25346: PUSH
25347: LD_INT 4
25349: PUSH
25350: LD_INT 5
25352: PUSH
25353: LD_INT 31
25355: PUSH
25356: LD_INT 32
25358: PUSH
25359: LD_INT 33
25361: PUSH
25362: EMPTY
25363: LIST
25364: LIST
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: IN
25375: NOT
25376: PUSH
25377: LD_VAR 0 6
25381: PUSH
25382: LD_INT 1
25384: EQUAL
25385: AND
25386: OR
25387: PUSH
25388: LD_VAR 0 1
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: LD_INT 3
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: IN
25403: NOT
25404: PUSH
25405: LD_VAR 0 6
25409: PUSH
25410: LD_INT 2
25412: EQUAL
25413: AND
25414: OR
25415: IFFALSE 25425
// mode = 0 ;
25417: LD_ADDR_VAR 0 6
25421: PUSH
25422: LD_INT 0
25424: ST_TO_ADDR
// case mode of 0 :
25425: LD_VAR 0 6
25429: PUSH
25430: LD_INT 0
25432: DOUBLE
25433: EQUAL
25434: IFTRUE 25438
25436: GO 36891
25438: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25439: LD_ADDR_VAR 0 11
25443: PUSH
25444: LD_INT 0
25446: PUSH
25447: LD_INT 0
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 0
25456: PUSH
25457: LD_INT 1
25459: NEG
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 1
25467: PUSH
25468: LD_INT 0
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PUSH
25475: LD_INT 1
25477: PUSH
25478: LD_INT 1
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 0
25487: PUSH
25488: LD_INT 1
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 1
25497: NEG
25498: PUSH
25499: LD_INT 0
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: LD_INT 1
25508: NEG
25509: PUSH
25510: LD_INT 1
25512: NEG
25513: PUSH
25514: EMPTY
25515: LIST
25516: LIST
25517: PUSH
25518: LD_INT 1
25520: NEG
25521: PUSH
25522: LD_INT 2
25524: NEG
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 0
25532: PUSH
25533: LD_INT 2
25535: NEG
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 1
25543: PUSH
25544: LD_INT 1
25546: NEG
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 1
25554: PUSH
25555: LD_INT 2
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: LD_INT 0
25564: PUSH
25565: LD_INT 2
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: LD_INT 1
25574: NEG
25575: PUSH
25576: LD_INT 1
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: LD_INT 1
25585: PUSH
25586: LD_INT 3
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PUSH
25593: LD_INT 0
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 1
25605: NEG
25606: PUSH
25607: LD_INT 2
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: LIST
25628: LIST
25629: LIST
25630: LIST
25631: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25632: LD_ADDR_VAR 0 12
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: PUSH
25647: LD_INT 0
25649: PUSH
25650: LD_INT 1
25652: NEG
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 1
25660: PUSH
25661: LD_INT 0
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 1
25670: PUSH
25671: LD_INT 1
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 0
25680: PUSH
25681: LD_INT 1
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 1
25690: NEG
25691: PUSH
25692: LD_INT 0
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: LD_INT 1
25701: NEG
25702: PUSH
25703: LD_INT 1
25705: NEG
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: LD_INT 1
25716: NEG
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 2
25724: PUSH
25725: LD_INT 0
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 2
25734: PUSH
25735: LD_INT 1
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 1
25744: NEG
25745: PUSH
25746: LD_INT 1
25748: PUSH
25749: EMPTY
25750: LIST
25751: LIST
25752: PUSH
25753: LD_INT 2
25755: NEG
25756: PUSH
25757: LD_INT 0
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: LD_INT 2
25766: NEG
25767: PUSH
25768: LD_INT 1
25770: NEG
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 2
25778: NEG
25779: PUSH
25780: LD_INT 1
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 3
25789: NEG
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 3
25800: NEG
25801: PUSH
25802: LD_INT 1
25804: NEG
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: EMPTY
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: LIST
25817: LIST
25818: LIST
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: LIST
25824: LIST
25825: LIST
25826: LIST
25827: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25828: LD_ADDR_VAR 0 13
25832: PUSH
25833: LD_INT 0
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 0
25845: PUSH
25846: LD_INT 1
25848: NEG
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PUSH
25854: LD_INT 1
25856: PUSH
25857: LD_INT 0
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 1
25866: PUSH
25867: LD_INT 1
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: LD_INT 0
25876: PUSH
25877: LD_INT 1
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 1
25886: NEG
25887: PUSH
25888: LD_INT 0
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 1
25897: NEG
25898: PUSH
25899: LD_INT 1
25901: NEG
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: NEG
25910: PUSH
25911: LD_INT 2
25913: NEG
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 2
25921: PUSH
25922: LD_INT 1
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: LD_INT 2
25931: PUSH
25932: LD_INT 2
25934: PUSH
25935: EMPTY
25936: LIST
25937: LIST
25938: PUSH
25939: LD_INT 1
25941: PUSH
25942: LD_INT 2
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 2
25951: NEG
25952: PUSH
25953: LD_INT 1
25955: NEG
25956: PUSH
25957: EMPTY
25958: LIST
25959: LIST
25960: PUSH
25961: LD_INT 2
25963: NEG
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 2
25975: NEG
25976: PUSH
25977: LD_INT 3
25979: NEG
25980: PUSH
25981: EMPTY
25982: LIST
25983: LIST
25984: PUSH
25985: LD_INT 3
25987: NEG
25988: PUSH
25989: LD_INT 2
25991: NEG
25992: PUSH
25993: EMPTY
25994: LIST
25995: LIST
25996: PUSH
25997: LD_INT 3
25999: NEG
26000: PUSH
26001: LD_INT 3
26003: NEG
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: LIST
26013: LIST
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26027: LD_ADDR_VAR 0 14
26031: PUSH
26032: LD_INT 0
26034: PUSH
26035: LD_INT 0
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PUSH
26042: LD_INT 0
26044: PUSH
26045: LD_INT 1
26047: NEG
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 1
26055: PUSH
26056: LD_INT 0
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 1
26065: PUSH
26066: LD_INT 1
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 0
26075: PUSH
26076: LD_INT 1
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 1
26085: NEG
26086: PUSH
26087: LD_INT 0
26089: PUSH
26090: EMPTY
26091: LIST
26092: LIST
26093: PUSH
26094: LD_INT 1
26096: NEG
26097: PUSH
26098: LD_INT 1
26100: NEG
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: PUSH
26106: LD_INT 1
26108: NEG
26109: PUSH
26110: LD_INT 2
26112: NEG
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 0
26120: PUSH
26121: LD_INT 2
26123: NEG
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 1
26131: PUSH
26132: LD_INT 1
26134: NEG
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: LD_INT 1
26142: PUSH
26143: LD_INT 2
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PUSH
26150: LD_INT 0
26152: PUSH
26153: LD_INT 2
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 1
26162: NEG
26163: PUSH
26164: LD_INT 1
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 1
26173: NEG
26174: PUSH
26175: LD_INT 3
26177: NEG
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 0
26185: PUSH
26186: LD_INT 3
26188: NEG
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: LD_INT 1
26196: PUSH
26197: LD_INT 2
26199: NEG
26200: PUSH
26201: EMPTY
26202: LIST
26203: LIST
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: LIST
26220: LIST
26221: LIST
26222: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26223: LD_ADDR_VAR 0 15
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: LD_INT 0
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 0
26240: PUSH
26241: LD_INT 1
26243: NEG
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 1
26251: PUSH
26252: LD_INT 0
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 1
26261: PUSH
26262: LD_INT 1
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: LD_INT 0
26271: PUSH
26272: LD_INT 1
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 1
26281: NEG
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 1
26292: NEG
26293: PUSH
26294: LD_INT 1
26296: NEG
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 1
26304: PUSH
26305: LD_INT 1
26307: NEG
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: PUSH
26313: LD_INT 2
26315: PUSH
26316: LD_INT 0
26318: PUSH
26319: EMPTY
26320: LIST
26321: LIST
26322: PUSH
26323: LD_INT 2
26325: PUSH
26326: LD_INT 1
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 1
26335: NEG
26336: PUSH
26337: LD_INT 1
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 2
26346: NEG
26347: PUSH
26348: LD_INT 0
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 2
26357: NEG
26358: PUSH
26359: LD_INT 1
26361: NEG
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 2
26369: PUSH
26370: LD_INT 1
26372: NEG
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 3
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 3
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: LIST
26402: LIST
26403: LIST
26404: LIST
26405: LIST
26406: LIST
26407: LIST
26408: LIST
26409: LIST
26410: LIST
26411: LIST
26412: LIST
26413: LIST
26414: LIST
26415: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26416: LD_ADDR_VAR 0 16
26420: PUSH
26421: LD_INT 0
26423: PUSH
26424: LD_INT 0
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 0
26433: PUSH
26434: LD_INT 1
26436: NEG
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: LD_INT 0
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: LD_INT 1
26454: PUSH
26455: LD_INT 1
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 0
26464: PUSH
26465: LD_INT 1
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 1
26474: NEG
26475: PUSH
26476: LD_INT 0
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: PUSH
26483: LD_INT 1
26485: NEG
26486: PUSH
26487: LD_INT 1
26489: NEG
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: PUSH
26495: LD_INT 1
26497: NEG
26498: PUSH
26499: LD_INT 2
26501: NEG
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: LD_INT 2
26509: PUSH
26510: LD_INT 1
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 2
26519: PUSH
26520: LD_INT 2
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 1
26529: PUSH
26530: LD_INT 2
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: LD_INT 2
26539: NEG
26540: PUSH
26541: LD_INT 1
26543: NEG
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: LD_INT 2
26551: NEG
26552: PUSH
26553: LD_INT 2
26555: NEG
26556: PUSH
26557: EMPTY
26558: LIST
26559: LIST
26560: PUSH
26561: LD_INT 3
26563: PUSH
26564: LD_INT 2
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 3
26573: PUSH
26574: LD_INT 3
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 2
26583: PUSH
26584: LD_INT 3
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: LIST
26603: LIST
26604: LIST
26605: LIST
26606: LIST
26607: LIST
26608: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26609: LD_ADDR_VAR 0 17
26613: PUSH
26614: LD_INT 0
26616: PUSH
26617: LD_INT 0
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 0
26626: PUSH
26627: LD_INT 1
26629: NEG
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 1
26637: PUSH
26638: LD_INT 0
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 1
26647: PUSH
26648: LD_INT 1
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 0
26657: PUSH
26658: LD_INT 1
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: LD_INT 1
26667: NEG
26668: PUSH
26669: LD_INT 0
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: LD_INT 1
26678: NEG
26679: PUSH
26680: LD_INT 1
26682: NEG
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 1
26690: NEG
26691: PUSH
26692: LD_INT 2
26694: NEG
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 0
26702: PUSH
26703: LD_INT 2
26705: NEG
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 1
26713: PUSH
26714: LD_INT 1
26716: NEG
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 2
26724: PUSH
26725: LD_INT 0
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: PUSH
26732: LD_INT 2
26734: PUSH
26735: LD_INT 1
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 2
26744: PUSH
26745: LD_INT 2
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PUSH
26752: LD_INT 1
26754: PUSH
26755: LD_INT 2
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 0
26764: PUSH
26765: LD_INT 2
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 1
26774: NEG
26775: PUSH
26776: LD_INT 1
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 2
26785: NEG
26786: PUSH
26787: LD_INT 0
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 2
26796: NEG
26797: PUSH
26798: LD_INT 1
26800: NEG
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 2
26808: NEG
26809: PUSH
26810: LD_INT 2
26812: NEG
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26839: LD_ADDR_VAR 0 18
26843: PUSH
26844: LD_INT 0
26846: PUSH
26847: LD_INT 0
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: LD_INT 1
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 1
26867: PUSH
26868: LD_INT 0
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: LD_INT 1
26877: PUSH
26878: LD_INT 1
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 1
26897: NEG
26898: PUSH
26899: LD_INT 0
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 1
26908: NEG
26909: PUSH
26910: LD_INT 1
26912: NEG
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 1
26920: NEG
26921: PUSH
26922: LD_INT 2
26924: NEG
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: LD_INT 0
26932: PUSH
26933: LD_INT 2
26935: NEG
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 1
26943: PUSH
26944: LD_INT 1
26946: NEG
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: PUSH
26952: LD_INT 2
26954: PUSH
26955: LD_INT 0
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: PUSH
26962: LD_INT 2
26964: PUSH
26965: LD_INT 1
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 2
26974: PUSH
26975: LD_INT 2
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 0
26994: PUSH
26995: LD_INT 2
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PUSH
27002: LD_INT 1
27004: NEG
27005: PUSH
27006: LD_INT 1
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: LD_INT 2
27015: NEG
27016: PUSH
27017: LD_INT 0
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PUSH
27024: LD_INT 2
27026: NEG
27027: PUSH
27028: LD_INT 1
27030: NEG
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: NEG
27039: PUSH
27040: LD_INT 2
27042: NEG
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: LIST
27054: LIST
27055: LIST
27056: LIST
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: LIST
27066: LIST
27067: LIST
27068: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27069: LD_ADDR_VAR 0 19
27073: PUSH
27074: LD_INT 0
27076: PUSH
27077: LD_INT 0
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 0
27086: PUSH
27087: LD_INT 1
27089: NEG
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: LD_INT 1
27097: PUSH
27098: LD_INT 0
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: LD_INT 1
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: LD_INT 0
27117: PUSH
27118: LD_INT 1
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 1
27127: NEG
27128: PUSH
27129: LD_INT 0
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PUSH
27136: LD_INT 1
27138: NEG
27139: PUSH
27140: LD_INT 1
27142: NEG
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 1
27150: NEG
27151: PUSH
27152: LD_INT 2
27154: NEG
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 0
27162: PUSH
27163: LD_INT 2
27165: NEG
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: LD_INT 1
27176: NEG
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: LD_INT 2
27184: PUSH
27185: LD_INT 0
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 2
27194: PUSH
27195: LD_INT 1
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 2
27204: PUSH
27205: LD_INT 2
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 1
27214: PUSH
27215: LD_INT 2
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 0
27224: PUSH
27225: LD_INT 2
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: LD_INT 1
27234: NEG
27235: PUSH
27236: LD_INT 1
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 2
27245: NEG
27246: PUSH
27247: LD_INT 0
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: LD_INT 2
27256: NEG
27257: PUSH
27258: LD_INT 1
27260: NEG
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 2
27268: NEG
27269: PUSH
27270: LD_INT 2
27272: NEG
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: LIST
27282: LIST
27283: LIST
27284: LIST
27285: LIST
27286: LIST
27287: LIST
27288: LIST
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27299: LD_ADDR_VAR 0 20
27303: PUSH
27304: LD_INT 0
27306: PUSH
27307: LD_INT 0
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 0
27316: PUSH
27317: LD_INT 1
27319: NEG
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 1
27327: PUSH
27328: LD_INT 0
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 1
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 0
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: NEG
27358: PUSH
27359: LD_INT 0
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 1
27368: NEG
27369: PUSH
27370: LD_INT 1
27372: NEG
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 1
27380: NEG
27381: PUSH
27382: LD_INT 2
27384: NEG
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 0
27392: PUSH
27393: LD_INT 2
27395: NEG
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 1
27403: PUSH
27404: LD_INT 1
27406: NEG
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 2
27414: PUSH
27415: LD_INT 0
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 2
27424: PUSH
27425: LD_INT 1
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 2
27434: PUSH
27435: LD_INT 2
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 1
27444: PUSH
27445: LD_INT 2
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 0
27454: PUSH
27455: LD_INT 2
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: LD_INT 1
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 2
27475: NEG
27476: PUSH
27477: LD_INT 0
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 2
27486: NEG
27487: PUSH
27488: LD_INT 1
27490: NEG
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: NEG
27499: PUSH
27500: LD_INT 2
27502: NEG
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: LIST
27522: LIST
27523: LIST
27524: LIST
27525: LIST
27526: LIST
27527: LIST
27528: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27529: LD_ADDR_VAR 0 21
27533: PUSH
27534: LD_INT 0
27536: PUSH
27537: LD_INT 0
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 0
27546: PUSH
27547: LD_INT 1
27549: NEG
27550: PUSH
27551: EMPTY
27552: LIST
27553: LIST
27554: PUSH
27555: LD_INT 1
27557: PUSH
27558: LD_INT 0
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 1
27567: PUSH
27568: LD_INT 1
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: LD_INT 0
27577: PUSH
27578: LD_INT 1
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PUSH
27585: LD_INT 1
27587: NEG
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: PUSH
27596: LD_INT 1
27598: NEG
27599: PUSH
27600: LD_INT 1
27602: NEG
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 1
27610: NEG
27611: PUSH
27612: LD_INT 2
27614: NEG
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 0
27622: PUSH
27623: LD_INT 2
27625: NEG
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PUSH
27631: LD_INT 1
27633: PUSH
27634: LD_INT 1
27636: NEG
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: PUSH
27642: LD_INT 2
27644: PUSH
27645: LD_INT 0
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PUSH
27652: LD_INT 2
27654: PUSH
27655: LD_INT 1
27657: PUSH
27658: EMPTY
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 2
27664: PUSH
27665: LD_INT 2
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 1
27674: PUSH
27675: LD_INT 2
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 0
27684: PUSH
27685: LD_INT 2
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: PUSH
27692: LD_INT 1
27694: NEG
27695: PUSH
27696: LD_INT 1
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 2
27705: NEG
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 2
27716: NEG
27717: PUSH
27718: LD_INT 1
27720: NEG
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 2
27728: NEG
27729: PUSH
27730: LD_INT 2
27732: NEG
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: LIST
27742: LIST
27743: LIST
27744: LIST
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27759: LD_ADDR_VAR 0 22
27763: PUSH
27764: LD_INT 0
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 0
27776: PUSH
27777: LD_INT 1
27779: NEG
27780: PUSH
27781: EMPTY
27782: LIST
27783: LIST
27784: PUSH
27785: LD_INT 1
27787: PUSH
27788: LD_INT 0
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 1
27797: PUSH
27798: LD_INT 1
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PUSH
27805: LD_INT 0
27807: PUSH
27808: LD_INT 1
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: NEG
27818: PUSH
27819: LD_INT 0
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 1
27828: NEG
27829: PUSH
27830: LD_INT 1
27832: NEG
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 1
27840: NEG
27841: PUSH
27842: LD_INT 2
27844: NEG
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: PUSH
27850: LD_INT 0
27852: PUSH
27853: LD_INT 2
27855: NEG
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: LD_INT 1
27863: PUSH
27864: LD_INT 1
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 2
27874: PUSH
27875: LD_INT 0
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 2
27884: PUSH
27885: LD_INT 1
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 2
27894: PUSH
27895: LD_INT 2
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 1
27904: PUSH
27905: LD_INT 2
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 0
27914: PUSH
27915: LD_INT 2
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: LD_INT 1
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: LD_INT 2
27935: NEG
27936: PUSH
27937: LD_INT 0
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: PUSH
27944: LD_INT 2
27946: NEG
27947: PUSH
27948: LD_INT 1
27950: NEG
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: NEG
27959: PUSH
27960: LD_INT 2
27962: NEG
27963: PUSH
27964: EMPTY
27965: LIST
27966: LIST
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27989: LD_ADDR_VAR 0 23
27993: PUSH
27994: LD_INT 0
27996: PUSH
27997: LD_INT 0
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 1
28009: NEG
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: PUSH
28015: LD_INT 1
28017: PUSH
28018: LD_INT 0
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 1
28027: PUSH
28028: LD_INT 1
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 0
28037: PUSH
28038: LD_INT 1
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 1
28058: NEG
28059: PUSH
28060: LD_INT 1
28062: NEG
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 1
28070: NEG
28071: PUSH
28072: LD_INT 2
28074: NEG
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 0
28082: PUSH
28083: LD_INT 2
28085: NEG
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 1
28093: PUSH
28094: LD_INT 1
28096: NEG
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 2
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 2
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 2
28124: PUSH
28125: LD_INT 2
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 1
28134: PUSH
28135: LD_INT 2
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: LD_INT 2
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: PUSH
28163: LD_INT 2
28165: NEG
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 2
28176: NEG
28177: PUSH
28178: LD_INT 1
28180: NEG
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: LD_INT 2
28188: NEG
28189: PUSH
28190: LD_INT 2
28192: NEG
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 2
28200: NEG
28201: PUSH
28202: LD_INT 3
28204: NEG
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 1
28212: NEG
28213: PUSH
28214: LD_INT 3
28216: NEG
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 1
28224: PUSH
28225: LD_INT 2
28227: NEG
28228: PUSH
28229: EMPTY
28230: LIST
28231: LIST
28232: PUSH
28233: LD_INT 2
28235: PUSH
28236: LD_INT 1
28238: NEG
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28269: LD_ADDR_VAR 0 24
28273: PUSH
28274: LD_INT 0
28276: PUSH
28277: LD_INT 0
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: LD_INT 0
28286: PUSH
28287: LD_INT 1
28289: NEG
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: PUSH
28295: LD_INT 1
28297: PUSH
28298: LD_INT 0
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: PUSH
28305: LD_INT 1
28307: PUSH
28308: LD_INT 1
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 0
28317: PUSH
28318: LD_INT 1
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 1
28327: NEG
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 1
28350: NEG
28351: PUSH
28352: LD_INT 2
28354: NEG
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 0
28362: PUSH
28363: LD_INT 2
28365: NEG
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 1
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: PUSH
28385: LD_INT 0
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: LD_INT 2
28394: PUSH
28395: LD_INT 1
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 2
28404: PUSH
28405: LD_INT 2
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 1
28414: PUSH
28415: LD_INT 2
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: LD_INT 2
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 1
28434: NEG
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 2
28445: NEG
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 2
28456: NEG
28457: PUSH
28458: LD_INT 1
28460: NEG
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 2
28468: NEG
28469: PUSH
28470: LD_INT 2
28472: NEG
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: PUSH
28481: LD_INT 2
28483: NEG
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 2
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 3
28502: PUSH
28503: LD_INT 1
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 3
28512: PUSH
28513: LD_INT 2
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: LIST
28533: LIST
28534: LIST
28535: LIST
28536: LIST
28537: LIST
28538: LIST
28539: LIST
28540: LIST
28541: LIST
28542: LIST
28543: LIST
28544: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28545: LD_ADDR_VAR 0 25
28549: PUSH
28550: LD_INT 0
28552: PUSH
28553: LD_INT 0
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 0
28562: PUSH
28563: LD_INT 1
28565: NEG
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 1
28573: PUSH
28574: LD_INT 0
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 1
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 0
28593: PUSH
28594: LD_INT 1
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 1
28603: NEG
28604: PUSH
28605: LD_INT 0
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 1
28614: NEG
28615: PUSH
28616: LD_INT 1
28618: NEG
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 1
28626: NEG
28627: PUSH
28628: LD_INT 2
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 2
28641: NEG
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 1
28649: PUSH
28650: LD_INT 1
28652: NEG
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 2
28660: PUSH
28661: LD_INT 0
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 2
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 2
28680: PUSH
28681: LD_INT 2
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 1
28690: PUSH
28691: LD_INT 2
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: LD_INT 0
28700: PUSH
28701: LD_INT 2
28703: PUSH
28704: EMPTY
28705: LIST
28706: LIST
28707: PUSH
28708: LD_INT 1
28710: NEG
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 2
28721: NEG
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 2
28732: NEG
28733: PUSH
28734: LD_INT 1
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 2
28744: NEG
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 3
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 3
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 2
28776: PUSH
28777: LD_INT 3
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 1
28786: PUSH
28787: LD_INT 3
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28819: LD_ADDR_VAR 0 26
28823: PUSH
28824: LD_INT 0
28826: PUSH
28827: LD_INT 0
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 0
28836: PUSH
28837: LD_INT 1
28839: NEG
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 1
28847: PUSH
28848: LD_INT 0
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 1
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 0
28867: PUSH
28868: LD_INT 1
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: LD_INT 1
28877: NEG
28878: PUSH
28879: LD_INT 0
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: LD_INT 1
28892: NEG
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: LD_INT 1
28900: NEG
28901: PUSH
28902: LD_INT 2
28904: NEG
28905: PUSH
28906: EMPTY
28907: LIST
28908: LIST
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 2
28915: NEG
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 1
28923: PUSH
28924: LD_INT 1
28926: NEG
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: LD_INT 2
28934: PUSH
28935: LD_INT 0
28937: PUSH
28938: EMPTY
28939: LIST
28940: LIST
28941: PUSH
28942: LD_INT 2
28944: PUSH
28945: LD_INT 1
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PUSH
28952: LD_INT 2
28954: PUSH
28955: LD_INT 2
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 1
28964: PUSH
28965: LD_INT 2
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 0
28974: PUSH
28975: LD_INT 2
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 1
28984: NEG
28985: PUSH
28986: LD_INT 1
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: LD_INT 2
28995: NEG
28996: PUSH
28997: LD_INT 0
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 2
29006: NEG
29007: PUSH
29008: LD_INT 1
29010: NEG
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: LD_INT 2
29018: NEG
29019: PUSH
29020: LD_INT 2
29022: NEG
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: LD_INT 2
29030: PUSH
29031: LD_INT 3
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 1
29040: PUSH
29041: LD_INT 3
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 1
29050: NEG
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: PUSH
29059: LD_INT 2
29061: NEG
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: LIST
29074: LIST
29075: LIST
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: LIST
29093: LIST
29094: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29095: LD_ADDR_VAR 0 27
29099: PUSH
29100: LD_INT 0
29102: PUSH
29103: LD_INT 0
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: LD_INT 1
29115: NEG
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 1
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: PUSH
29134: LD_INT 1
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 0
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 1
29153: NEG
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 1
29164: NEG
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 1
29176: NEG
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 0
29188: PUSH
29189: LD_INT 2
29191: NEG
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 1
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 2
29210: PUSH
29211: LD_INT 0
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PUSH
29218: LD_INT 2
29220: PUSH
29221: LD_INT 1
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 2
29230: PUSH
29231: LD_INT 2
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: LD_INT 2
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: LD_INT 2
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 2
29271: NEG
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 2
29282: NEG
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 2
29294: NEG
29295: PUSH
29296: LD_INT 2
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: LD_INT 2
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: LD_INT 1
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 3
29328: NEG
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 3
29340: NEG
29341: PUSH
29342: LD_INT 2
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: LIST
29364: LIST
29365: LIST
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: LIST
29371: LIST
29372: LIST
29373: LIST
29374: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29375: LD_ADDR_VAR 0 28
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: LD_INT 0
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: LD_INT 0
29392: PUSH
29393: LD_INT 1
29395: NEG
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: LD_INT 0
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: LD_INT 1
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 0
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 1
29433: NEG
29434: PUSH
29435: LD_INT 0
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 1
29444: NEG
29445: PUSH
29446: LD_INT 1
29448: NEG
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: LD_INT 1
29456: NEG
29457: PUSH
29458: LD_INT 2
29460: NEG
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: LD_INT 2
29471: NEG
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 1
29479: PUSH
29480: LD_INT 1
29482: NEG
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 2
29490: PUSH
29491: LD_INT 0
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 2
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 2
29510: PUSH
29511: LD_INT 2
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 1
29520: PUSH
29521: LD_INT 2
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 0
29530: PUSH
29531: LD_INT 2
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: NEG
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 2
29551: NEG
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 2
29562: NEG
29563: PUSH
29564: LD_INT 1
29566: NEG
29567: PUSH
29568: EMPTY
29569: LIST
29570: LIST
29571: PUSH
29572: LD_INT 2
29574: NEG
29575: PUSH
29576: LD_INT 2
29578: NEG
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 2
29586: NEG
29587: PUSH
29588: LD_INT 3
29590: NEG
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: NEG
29599: PUSH
29600: LD_INT 3
29602: NEG
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: PUSH
29608: LD_INT 3
29610: NEG
29611: PUSH
29612: LD_INT 1
29614: NEG
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 3
29622: NEG
29623: PUSH
29624: LD_INT 2
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: LIST
29636: LIST
29637: LIST
29638: LIST
29639: LIST
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29657: LD_ADDR_VAR 0 29
29661: PUSH
29662: LD_INT 0
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 1
29685: PUSH
29686: LD_INT 0
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 1
29695: PUSH
29696: LD_INT 1
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 0
29705: PUSH
29706: LD_INT 1
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 1
29715: NEG
29716: PUSH
29717: LD_INT 0
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 1
29726: NEG
29727: PUSH
29728: LD_INT 1
29730: NEG
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 1
29738: NEG
29739: PUSH
29740: LD_INT 2
29742: NEG
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 0
29750: PUSH
29751: LD_INT 2
29753: NEG
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 2
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 2
29782: PUSH
29783: LD_INT 1
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 1
29792: PUSH
29793: LD_INT 2
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: LD_INT 2
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 1
29812: NEG
29813: PUSH
29814: LD_INT 1
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 2
29823: NEG
29824: PUSH
29825: LD_INT 1
29827: NEG
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 2
29835: NEG
29836: PUSH
29837: LD_INT 2
29839: NEG
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 2
29847: NEG
29848: PUSH
29849: LD_INT 3
29851: NEG
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: LD_INT 1
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: PUSH
29878: LD_INT 1
29880: PUSH
29881: LD_INT 3
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: NEG
29891: PUSH
29892: LD_INT 2
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 3
29901: NEG
29902: PUSH
29903: LD_INT 2
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: LIST
29915: LIST
29916: LIST
29917: LIST
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29936: LD_ADDR_VAR 0 30
29940: PUSH
29941: LD_INT 0
29943: PUSH
29944: LD_INT 0
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: LD_INT 0
29953: PUSH
29954: LD_INT 1
29956: NEG
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: LD_INT 0
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 1
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 0
29984: PUSH
29985: LD_INT 1
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: LD_INT 0
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: LD_INT 1
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: NEG
30018: PUSH
30019: LD_INT 2
30021: NEG
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 0
30029: PUSH
30030: LD_INT 2
30032: NEG
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: PUSH
30041: LD_INT 1
30043: NEG
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: LD_INT 0
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: LD_INT 2
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: PUSH
30082: LD_INT 2
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: NEG
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 2
30102: NEG
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 2
30113: NEG
30114: PUSH
30115: LD_INT 1
30117: NEG
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 1
30125: NEG
30126: PUSH
30127: LD_INT 3
30129: NEG
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 1
30137: PUSH
30138: LD_INT 2
30140: NEG
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PUSH
30146: LD_INT 3
30148: PUSH
30149: LD_INT 2
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 2
30158: PUSH
30159: LD_INT 3
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 2
30168: NEG
30169: PUSH
30170: LD_INT 1
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 3
30179: NEG
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30214: LD_ADDR_VAR 0 31
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 0
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 0
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: LD_INT 0
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: NEG
30273: PUSH
30274: LD_INT 0
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 1
30283: NEG
30284: PUSH
30285: LD_INT 1
30287: NEG
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: LD_INT 2
30299: NEG
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 1
30307: PUSH
30308: LD_INT 1
30310: NEG
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 2
30318: PUSH
30319: LD_INT 0
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 2
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 2
30338: PUSH
30339: LD_INT 2
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: LD_INT 2
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: LD_INT 2
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 1
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 2
30379: NEG
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: NEG
30392: PUSH
30393: LD_INT 2
30395: NEG
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 2
30403: NEG
30404: PUSH
30405: LD_INT 3
30407: NEG
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 2
30415: PUSH
30416: LD_INT 1
30418: NEG
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 3
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 3
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 1
30446: NEG
30447: PUSH
30448: LD_INT 2
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 3
30457: NEG
30458: PUSH
30459: LD_INT 2
30461: NEG
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: LIST
30471: LIST
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30492: LD_ADDR_VAR 0 32
30496: PUSH
30497: LD_INT 0
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 0
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 1
30520: PUSH
30521: LD_INT 0
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 1
30530: PUSH
30531: LD_INT 1
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 0
30540: PUSH
30541: LD_INT 1
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 1
30550: NEG
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: LD_INT 1
30565: NEG
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 1
30573: NEG
30574: PUSH
30575: LD_INT 2
30577: NEG
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 0
30585: PUSH
30586: LD_INT 2
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: PUSH
30597: LD_INT 1
30599: NEG
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: LD_INT 2
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 2
30617: PUSH
30618: LD_INT 2
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 1
30627: PUSH
30628: LD_INT 2
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: LD_INT 2
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 2
30658: NEG
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: NEG
30682: PUSH
30683: LD_INT 3
30685: NEG
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 1
30693: PUSH
30694: LD_INT 2
30696: NEG
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: LD_INT 3
30704: PUSH
30705: LD_INT 2
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: PUSH
30715: LD_INT 3
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 2
30724: NEG
30725: PUSH
30726: LD_INT 1
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 3
30735: NEG
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30770: LD_ADDR_VAR 0 33
30774: PUSH
30775: LD_INT 0
30777: PUSH
30778: LD_INT 0
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 1
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 0
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: LD_INT 1
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 0
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: NEG
30829: PUSH
30830: LD_INT 0
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 1
30839: NEG
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 1
30851: NEG
30852: PUSH
30853: LD_INT 2
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: LD_INT 1
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 2
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 2
30884: PUSH
30885: LD_INT 1
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 1
30894: PUSH
30895: LD_INT 2
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: LD_INT 2
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 1
30914: NEG
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 2
30925: NEG
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 2
30936: NEG
30937: PUSH
30938: LD_INT 1
30940: NEG
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 2
30948: NEG
30949: PUSH
30950: LD_INT 2
30952: NEG
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 2
30960: NEG
30961: PUSH
30962: LD_INT 3
30964: NEG
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 2
30972: PUSH
30973: LD_INT 1
30975: NEG
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 3
30983: PUSH
30984: LD_INT 1
30986: PUSH
30987: EMPTY
30988: LIST
30989: LIST
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: LD_INT 3
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 1
31003: NEG
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 3
31014: NEG
31015: PUSH
31016: LD_INT 2
31018: NEG
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31049: LD_ADDR_VAR 0 34
31053: PUSH
31054: LD_INT 0
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: EMPTY
31061: LIST
31062: LIST
31063: PUSH
31064: LD_INT 0
31066: PUSH
31067: LD_INT 1
31069: NEG
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 1
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 1
31087: PUSH
31088: LD_INT 1
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 0
31097: PUSH
31098: LD_INT 1
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: NEG
31108: PUSH
31109: LD_INT 0
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: LD_INT 1
31118: NEG
31119: PUSH
31120: LD_INT 1
31122: NEG
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: NEG
31131: PUSH
31132: LD_INT 2
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 1
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 2
31164: PUSH
31165: LD_INT 1
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: PUSH
31175: LD_INT 2
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: LD_INT 2
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: LD_INT 1
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 2
31205: NEG
31206: PUSH
31207: LD_INT 0
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 2
31216: NEG
31217: PUSH
31218: LD_INT 1
31220: NEG
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 2
31228: NEG
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 1
31240: NEG
31241: PUSH
31242: LD_INT 3
31244: NEG
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: LD_INT 2
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 3
31263: PUSH
31264: LD_INT 2
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 2
31273: PUSH
31274: LD_INT 3
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 2
31283: NEG
31284: PUSH
31285: LD_INT 1
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 3
31294: NEG
31295: PUSH
31296: LD_INT 1
31298: NEG
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31329: LD_ADDR_VAR 0 35
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 0
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: LD_INT 0
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 1
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31441: LD_ADDR_VAR 0 36
31445: PUSH
31446: LD_INT 0
31448: PUSH
31449: LD_INT 0
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: PUSH
31456: LD_INT 0
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 1
31469: PUSH
31470: LD_INT 0
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 1
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 0
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: LD_INT 0
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 1
31510: NEG
31511: PUSH
31512: LD_INT 1
31514: NEG
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: LD_INT 2
31526: NEG
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: PUSH
31535: LD_INT 2
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31553: LD_ADDR_VAR 0 37
31557: PUSH
31558: LD_INT 0
31560: PUSH
31561: LD_INT 0
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 0
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 1
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 1
31591: PUSH
31592: LD_INT 1
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 0
31601: PUSH
31602: LD_INT 1
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 1
31611: NEG
31612: PUSH
31613: LD_INT 0
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 1
31622: NEG
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: LD_INT 1
31637: NEG
31638: PUSH
31639: EMPTY
31640: LIST
31641: LIST
31642: PUSH
31643: LD_INT 1
31645: NEG
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31665: LD_ADDR_VAR 0 38
31669: PUSH
31670: LD_INT 0
31672: PUSH
31673: LD_INT 0
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 1
31685: NEG
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 1
31693: PUSH
31694: LD_INT 0
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: PUSH
31704: LD_INT 1
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 0
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 1
31723: NEG
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: PUSH
31747: LD_INT 1
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 2
31756: NEG
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31777: LD_ADDR_VAR 0 39
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 1
31797: NEG
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: LD_INT 0
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: PUSH
31816: LD_INT 1
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 1
31870: PUSH
31871: LD_INT 2
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31889: LD_ADDR_VAR 0 40
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 0
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 1
31917: PUSH
31918: LD_INT 0
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: LD_INT 1
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: LD_INT 1
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: NEG
31948: PUSH
31949: LD_INT 0
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: LD_INT 1
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: LD_INT 1
31973: NEG
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 1
31981: NEG
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: LIST
31994: LIST
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32001: LD_ADDR_VAR 0 41
32005: PUSH
32006: LD_INT 0
32008: PUSH
32009: LD_INT 0
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: LD_INT 1
32021: NEG
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 1
32029: PUSH
32030: LD_INT 0
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 1
32039: PUSH
32040: LD_INT 1
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 1
32059: NEG
32060: PUSH
32061: LD_INT 0
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: LD_INT 1
32074: NEG
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: LD_INT 2
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: LD_INT 1
32097: NEG
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 2
32105: PUSH
32106: LD_INT 0
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 2
32115: PUSH
32116: LD_INT 1
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 2
32125: PUSH
32126: LD_INT 2
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: LD_INT 2
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: NEG
32146: PUSH
32147: LD_INT 1
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: NEG
32157: PUSH
32158: LD_INT 0
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 2
32179: NEG
32180: PUSH
32181: LD_INT 2
32183: NEG
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: NEG
32192: PUSH
32193: LD_INT 3
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 2
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 3
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 3
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 3
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: PUSH
32245: LD_INT 3
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 2
32254: PUSH
32255: LD_INT 3
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 2
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 3
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 3
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 3
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 3
32310: NEG
32311: PUSH
32312: LD_INT 3
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32351: LD_ADDR_VAR 0 42
32355: PUSH
32356: LD_INT 0
32358: PUSH
32359: LD_INT 0
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 1
32371: NEG
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: LD_INT 1
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 0
32399: PUSH
32400: LD_INT 1
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 1
32409: NEG
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: NEG
32421: PUSH
32422: LD_INT 1
32424: NEG
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 1
32432: NEG
32433: PUSH
32434: LD_INT 2
32436: NEG
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 0
32444: PUSH
32445: LD_INT 2
32447: NEG
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 1
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 2
32466: PUSH
32467: LD_INT 1
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: LD_INT 2
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 1
32486: PUSH
32487: LD_INT 2
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 1
32506: NEG
32507: PUSH
32508: LD_INT 1
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 2
32517: NEG
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 2
32529: NEG
32530: PUSH
32531: LD_INT 2
32533: NEG
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 2
32541: NEG
32542: PUSH
32543: LD_INT 3
32545: NEG
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 1
32553: NEG
32554: PUSH
32555: LD_INT 3
32557: NEG
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 0
32565: PUSH
32566: LD_INT 3
32568: NEG
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 1
32576: PUSH
32577: LD_INT 2
32579: NEG
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 3
32587: PUSH
32588: LD_INT 2
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 3
32597: PUSH
32598: LD_INT 3
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 2
32607: PUSH
32608: LD_INT 3
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 1
32617: PUSH
32618: LD_INT 3
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 0
32627: PUSH
32628: LD_INT 3
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: LD_INT 2
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 3
32648: NEG
32649: PUSH
32650: LD_INT 2
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 3
32660: NEG
32661: PUSH
32662: LD_INT 3
32664: NEG
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32701: LD_ADDR_VAR 0 43
32705: PUSH
32706: LD_INT 0
32708: PUSH
32709: LD_INT 0
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: LD_INT 0
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: LD_INT 1
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: NEG
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: LD_INT 2
32786: NEG
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: LD_INT 2
32797: NEG
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 2
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 2
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 1
32836: PUSH
32837: LD_INT 2
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 0
32846: PUSH
32847: LD_INT 2
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: LD_INT 1
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 2
32867: NEG
32868: PUSH
32869: LD_INT 0
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 2
32878: NEG
32879: PUSH
32880: LD_INT 1
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: NEG
32891: PUSH
32892: LD_INT 3
32894: NEG
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 0
32902: PUSH
32903: LD_INT 3
32905: NEG
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 1
32913: PUSH
32914: LD_INT 2
32916: NEG
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: LD_INT 1
32927: NEG
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: LD_INT 3
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 3
32945: PUSH
32946: LD_INT 1
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 1
32955: PUSH
32956: LD_INT 3
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: LD_INT 3
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 2
32986: NEG
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 3
32997: NEG
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 3
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: LIST
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: LIST
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33049: LD_ADDR_VAR 0 44
33053: PUSH
33054: LD_INT 0
33056: PUSH
33057: LD_INT 0
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 0
33066: PUSH
33067: LD_INT 1
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 0
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 1
33087: PUSH
33088: LD_INT 1
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 0
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 1
33107: NEG
33108: PUSH
33109: LD_INT 0
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 1
33118: NEG
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: LD_INT 2
33134: NEG
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 1
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 2
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 2
33163: PUSH
33164: LD_INT 1
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: PUSH
33174: LD_INT 2
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: LD_INT 2
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 1
33193: NEG
33194: PUSH
33195: LD_INT 1
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 2
33204: NEG
33205: PUSH
33206: LD_INT 0
33208: PUSH
33209: EMPTY
33210: LIST
33211: LIST
33212: PUSH
33213: LD_INT 2
33215: NEG
33216: PUSH
33217: LD_INT 1
33219: NEG
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 2
33227: NEG
33228: PUSH
33229: LD_INT 2
33231: NEG
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: LD_INT 3
33243: NEG
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 2
33251: PUSH
33252: LD_INT 1
33254: NEG
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 3
33262: PUSH
33263: LD_INT 0
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 3
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 3
33282: PUSH
33283: LD_INT 2
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 3
33292: PUSH
33293: LD_INT 3
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 2
33302: PUSH
33303: LD_INT 3
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 2
33312: NEG
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 3
33323: NEG
33324: PUSH
33325: LD_INT 0
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 3
33334: NEG
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 3
33346: NEG
33347: PUSH
33348: LD_INT 2
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 3
33358: NEG
33359: PUSH
33360: LD_INT 3
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33399: LD_ADDR_VAR 0 45
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: LD_INT 0
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 0
33416: PUSH
33417: LD_INT 1
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 1
33427: PUSH
33428: LD_INT 0
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 0
33447: PUSH
33448: LD_INT 1
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 1
33457: NEG
33458: PUSH
33459: LD_INT 0
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: NEG
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 1
33480: NEG
33481: PUSH
33482: LD_INT 2
33484: NEG
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 0
33492: PUSH
33493: LD_INT 2
33495: NEG
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 1
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 1
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 2
33524: PUSH
33525: LD_INT 2
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 1
33534: PUSH
33535: LD_INT 2
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 2
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: NEG
33566: PUSH
33567: LD_INT 1
33569: NEG
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 2
33577: NEG
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 3
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 1
33601: NEG
33602: PUSH
33603: LD_INT 3
33605: NEG
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 0
33613: PUSH
33614: LD_INT 3
33616: NEG
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: LD_INT 2
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 3
33635: PUSH
33636: LD_INT 2
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 3
33645: PUSH
33646: LD_INT 3
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 2
33655: PUSH
33656: LD_INT 3
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: LD_INT 3
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: LD_INT 3
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: LD_INT 2
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 3
33696: NEG
33697: PUSH
33698: LD_INT 2
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 3
33708: NEG
33709: PUSH
33710: LD_INT 3
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33749: LD_ADDR_VAR 0 46
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: LD_INT 0
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 0
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 0
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: LD_INT 1
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 0
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: NEG
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 1
33830: NEG
33831: PUSH
33832: LD_INT 2
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 2
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 1
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 2
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 2
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: PUSH
33885: LD_INT 2
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 0
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: LD_INT 1
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 2
33915: NEG
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 2
33926: NEG
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: LD_INT 3
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 3
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 2
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: PUSH
33973: LD_INT 1
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 3
33983: PUSH
33984: LD_INT 0
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 3
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 1
34003: PUSH
34004: LD_INT 3
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 0
34013: PUSH
34014: LD_INT 3
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 2
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 2
34034: NEG
34035: PUSH
34036: LD_INT 1
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 3
34045: NEG
34046: PUSH
34047: LD_INT 0
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 3
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34097: LD_ADDR_VAR 0 47
34101: PUSH
34102: LD_INT 0
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 1
34117: NEG
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: LD_INT 0
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 0
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 0
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 1
34166: NEG
34167: PUSH
34168: LD_INT 1
34170: NEG
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 1
34178: NEG
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 0
34190: PUSH
34191: LD_INT 2
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: PUSH
34202: LD_INT 1
34204: NEG
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 2
34212: NEG
34213: PUSH
34214: LD_INT 1
34216: NEG
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 2
34224: NEG
34225: PUSH
34226: LD_INT 2
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34248: LD_ADDR_VAR 0 48
34252: PUSH
34253: LD_INT 0
34255: PUSH
34256: LD_INT 0
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 0
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: LD_INT 0
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: PUSH
34287: LD_INT 1
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 0
34296: PUSH
34297: LD_INT 1
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: LD_INT 0
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: LD_INT 1
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 1
34329: NEG
34330: PUSH
34331: LD_INT 2
34333: NEG
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: LD_INT 2
34344: NEG
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: PUSH
34353: LD_INT 1
34355: NEG
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 2
34373: PUSH
34374: LD_INT 1
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34395: LD_ADDR_VAR 0 49
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: LD_INT 1
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34539: LD_ADDR_VAR 0 50
34543: PUSH
34544: LD_INT 0
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 0
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 1
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: NEG
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: NEG
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 2
34620: PUSH
34621: LD_INT 1
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: LD_INT 2
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 1
34640: PUSH
34641: LD_INT 2
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 0
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: NEG
34661: PUSH
34662: LD_INT 1
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34683: LD_ADDR_VAR 0 51
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 0
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: LD_INT 0
34700: PUSH
34701: LD_INT 1
34703: NEG
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 0
34731: PUSH
34732: LD_INT 1
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 1
34752: NEG
34753: PUSH
34754: LD_INT 1
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 1
34764: PUSH
34765: LD_INT 2
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 0
34774: PUSH
34775: LD_INT 2
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 2
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34830: LD_ADDR_VAR 0 52
34834: PUSH
34835: LD_INT 0
34837: PUSH
34838: LD_INT 0
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 0
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 1
34858: PUSH
34859: LD_INT 0
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 1
34868: PUSH
34869: LD_INT 1
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: LD_INT 1
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 1
34888: NEG
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: NEG
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: LD_INT 1
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: LD_INT 1
34949: NEG
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: NEG
34958: PUSH
34959: LD_INT 2
34961: NEG
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34981: LD_ADDR_VAR 0 53
34985: PUSH
34986: LD_INT 0
34988: PUSH
34989: LD_INT 0
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 1
35009: PUSH
35010: LD_INT 0
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 1
35019: PUSH
35020: LD_INT 1
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: LD_INT 0
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: NEG
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: LD_INT 2
35066: NEG
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 0
35074: PUSH
35075: LD_INT 2
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: PUSH
35086: LD_INT 1
35088: NEG
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 2
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 2
35106: PUSH
35107: LD_INT 1
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 2
35116: PUSH
35117: LD_INT 2
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: LD_INT 2
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: LD_INT 2
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 2
35157: NEG
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 2
35168: NEG
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: NEG
35181: PUSH
35182: LD_INT 2
35184: NEG
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35211: LD_ADDR_VAR 0 54
35215: PUSH
35216: LD_INT 0
35218: PUSH
35219: LD_INT 0
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 1
35239: PUSH
35240: LD_INT 0
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: LD_INT 0
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: LD_INT 1
35284: NEG
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 2
35296: NEG
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 2
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 2
35326: PUSH
35327: LD_INT 0
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 2
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 2
35346: PUSH
35347: LD_INT 2
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: PUSH
35357: LD_INT 2
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 0
35366: PUSH
35367: LD_INT 2
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: LD_INT 1
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 2
35387: NEG
35388: PUSH
35389: LD_INT 0
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 2
35398: NEG
35399: PUSH
35400: LD_INT 1
35402: NEG
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 2
35410: NEG
35411: PUSH
35412: LD_INT 2
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35441: LD_ADDR_VAR 0 55
35445: PUSH
35446: LD_INT 0
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 1
35461: NEG
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 1
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: NEG
35523: PUSH
35524: LD_INT 2
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 0
35534: PUSH
35535: LD_INT 2
35537: NEG
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 1
35545: PUSH
35546: LD_INT 1
35548: NEG
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 2
35556: PUSH
35557: LD_INT 0
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 2
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 2
35576: PUSH
35577: LD_INT 2
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 1
35586: PUSH
35587: LD_INT 2
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: LD_INT 2
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: LD_INT 1
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 2
35617: NEG
35618: PUSH
35619: LD_INT 0
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 2
35628: NEG
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: LIST
35669: LIST
35670: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35671: LD_ADDR_VAR 0 56
35675: PUSH
35676: LD_INT 0
35678: PUSH
35679: LD_INT 0
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: LD_INT 1
35691: NEG
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 1
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 1
35709: PUSH
35710: LD_INT 1
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 0
35719: PUSH
35720: LD_INT 1
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: LD_INT 2
35756: NEG
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 0
35764: PUSH
35765: LD_INT 2
35767: NEG
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: LD_INT 1
35778: NEG
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 2
35786: PUSH
35787: LD_INT 0
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 2
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: LD_INT 2
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 1
35816: PUSH
35817: LD_INT 2
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: LD_INT 2
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: LD_INT 1
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 2
35847: NEG
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 2
35858: NEG
35859: PUSH
35860: LD_INT 1
35862: NEG
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 2
35870: NEG
35871: PUSH
35872: LD_INT 2
35874: NEG
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: LIST
35884: LIST
35885: LIST
35886: LIST
35887: LIST
35888: LIST
35889: LIST
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: LIST
35897: LIST
35898: LIST
35899: LIST
35900: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35901: LD_ADDR_VAR 0 57
35905: PUSH
35906: LD_INT 0
35908: PUSH
35909: LD_INT 0
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: LD_INT 1
35921: NEG
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 1
35929: PUSH
35930: LD_INT 0
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 1
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 1
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: NEG
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: NEG
35971: PUSH
35972: LD_INT 1
35974: NEG
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 1
35982: NEG
35983: PUSH
35984: LD_INT 2
35986: NEG
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 0
35994: PUSH
35995: LD_INT 2
35997: NEG
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 1
36005: PUSH
36006: LD_INT 1
36008: NEG
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 2
36016: PUSH
36017: LD_INT 0
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 2
36026: PUSH
36027: LD_INT 1
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 2
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: LD_INT 2
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: LD_INT 2
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: NEG
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 2
36077: NEG
36078: PUSH
36079: LD_INT 0
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 2
36088: NEG
36089: PUSH
36090: LD_INT 1
36092: NEG
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: NEG
36101: PUSH
36102: LD_INT 2
36104: NEG
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36131: LD_ADDR_VAR 0 58
36135: PUSH
36136: LD_INT 0
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 1
36151: NEG
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 1
36159: PUSH
36160: LD_INT 0
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 1
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 0
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: LD_INT 0
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 1
36200: NEG
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 1
36212: NEG
36213: PUSH
36214: LD_INT 2
36216: NEG
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 0
36224: PUSH
36225: LD_INT 2
36227: NEG
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 1
36235: PUSH
36236: LD_INT 1
36238: NEG
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 2
36246: PUSH
36247: LD_INT 0
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 2
36256: PUSH
36257: LD_INT 1
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 2
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: PUSH
36277: LD_INT 2
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: LD_INT 2
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 1
36296: NEG
36297: PUSH
36298: LD_INT 1
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 2
36307: NEG
36308: PUSH
36309: LD_INT 0
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 2
36318: NEG
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 2
36330: NEG
36331: PUSH
36332: LD_INT 2
36334: NEG
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: LIST
36359: LIST
36360: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36361: LD_ADDR_VAR 0 59
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: LD_INT 0
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 1
36399: PUSH
36400: LD_INT 1
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 0
36409: PUSH
36410: LD_INT 1
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: NEG
36420: PUSH
36421: LD_INT 0
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 1
36430: NEG
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36449: LD_ADDR_VAR 0 60
36453: PUSH
36454: LD_INT 0
36456: PUSH
36457: LD_INT 0
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 0
36466: PUSH
36467: LD_INT 1
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 1
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 1
36487: PUSH
36488: LD_INT 1
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 0
36497: PUSH
36498: LD_INT 1
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: NEG
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 1
36518: NEG
36519: PUSH
36520: LD_INT 1
36522: NEG
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36537: LD_ADDR_VAR 0 61
36541: PUSH
36542: LD_INT 0
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 1
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: LD_INT 1
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 0
36585: PUSH
36586: LD_INT 1
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: NEG
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 1
36606: NEG
36607: PUSH
36608: LD_INT 1
36610: NEG
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36625: LD_ADDR_VAR 0 62
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: LD_INT 0
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: LD_INT 1
36645: NEG
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 1
36653: PUSH
36654: LD_INT 0
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 1
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 0
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: NEG
36684: PUSH
36685: LD_INT 0
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 1
36694: NEG
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: LIST
36711: LIST
36712: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36713: LD_ADDR_VAR 0 63
36717: PUSH
36718: LD_INT 0
36720: PUSH
36721: LD_INT 0
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: LD_INT 0
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 1
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: LD_INT 1
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 1
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36801: LD_ADDR_VAR 0 64
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 0
36818: PUSH
36819: LD_INT 1
36821: NEG
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 1
36829: PUSH
36830: LD_INT 0
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 1
36839: PUSH
36840: LD_INT 1
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 1
36859: NEG
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: ST_TO_ADDR
// end ; 1 :
36889: GO 42786
36891: LD_INT 1
36893: DOUBLE
36894: EQUAL
36895: IFTRUE 36899
36897: GO 39522
36899: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36900: LD_ADDR_VAR 0 11
36904: PUSH
36905: LD_INT 1
36907: NEG
36908: PUSH
36909: LD_INT 3
36911: NEG
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: LD_INT 3
36922: NEG
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: LD_INT 2
36933: NEG
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: LIST
36943: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36944: LD_ADDR_VAR 0 12
36948: PUSH
36949: LD_INT 2
36951: PUSH
36952: LD_INT 1
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 3
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 3
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: LIST
36984: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36985: LD_ADDR_VAR 0 13
36989: PUSH
36990: LD_INT 3
36992: PUSH
36993: LD_INT 2
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 3
37002: PUSH
37003: LD_INT 3
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 2
37012: PUSH
37013: LD_INT 3
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: LIST
37024: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37025: LD_ADDR_VAR 0 14
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: LD_INT 3
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: LD_INT 3
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: LD_INT 2
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: LIST
37065: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37066: LD_ADDR_VAR 0 15
37070: PUSH
37071: LD_INT 2
37073: NEG
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 3
37084: NEG
37085: PUSH
37086: LD_INT 0
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 3
37095: NEG
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: LIST
37109: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37110: LD_ADDR_VAR 0 16
37114: PUSH
37115: LD_INT 2
37117: NEG
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 3
37129: NEG
37130: PUSH
37131: LD_INT 2
37133: NEG
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 3
37141: NEG
37142: PUSH
37143: LD_INT 3
37145: NEG
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: LIST
37155: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37156: LD_ADDR_VAR 0 17
37160: PUSH
37161: LD_INT 1
37163: NEG
37164: PUSH
37165: LD_INT 3
37167: NEG
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 0
37175: PUSH
37176: LD_INT 3
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: LD_INT 2
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: LIST
37199: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37200: LD_ADDR_VAR 0 18
37204: PUSH
37205: LD_INT 2
37207: PUSH
37208: LD_INT 1
37210: NEG
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 3
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 3
37228: PUSH
37229: LD_INT 1
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: LIST
37240: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37241: LD_ADDR_VAR 0 19
37245: PUSH
37246: LD_INT 3
37248: PUSH
37249: LD_INT 2
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 3
37258: PUSH
37259: LD_INT 3
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 2
37268: PUSH
37269: LD_INT 3
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: LIST
37280: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37281: LD_ADDR_VAR 0 20
37285: PUSH
37286: LD_INT 1
37288: PUSH
37289: LD_INT 3
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: LD_INT 3
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 2
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: LIST
37321: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37322: LD_ADDR_VAR 0 21
37326: PUSH
37327: LD_INT 2
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: LD_INT 1
37355: NEG
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: LIST
37365: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37366: LD_ADDR_VAR 0 22
37370: PUSH
37371: LD_INT 2
37373: NEG
37374: PUSH
37375: LD_INT 3
37377: NEG
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 3
37385: NEG
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 3
37397: NEG
37398: PUSH
37399: LD_INT 3
37401: NEG
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: LIST
37411: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37412: LD_ADDR_VAR 0 23
37416: PUSH
37417: LD_INT 0
37419: PUSH
37420: LD_INT 3
37422: NEG
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 1
37430: NEG
37431: PUSH
37432: LD_INT 4
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 3
37445: NEG
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: LIST
37455: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37456: LD_ADDR_VAR 0 24
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 0
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 3
37473: PUSH
37474: LD_INT 1
37476: NEG
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 4
37484: PUSH
37485: LD_INT 1
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: LIST
37496: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37497: LD_ADDR_VAR 0 25
37501: PUSH
37502: LD_INT 3
37504: PUSH
37505: LD_INT 3
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 4
37514: PUSH
37515: LD_INT 3
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 3
37524: PUSH
37525: LD_INT 4
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: LIST
37536: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37537: LD_ADDR_VAR 0 26
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: LD_INT 3
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 1
37554: PUSH
37555: LD_INT 4
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: NEG
37565: PUSH
37566: LD_INT 3
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: LIST
37577: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37578: LD_ADDR_VAR 0 27
37582: PUSH
37583: LD_INT 3
37585: NEG
37586: PUSH
37587: LD_INT 0
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 3
37596: NEG
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 4
37607: NEG
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: LIST
37621: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37622: LD_ADDR_VAR 0 28
37626: PUSH
37627: LD_INT 3
37629: NEG
37630: PUSH
37631: LD_INT 3
37633: NEG
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 3
37641: NEG
37642: PUSH
37643: LD_INT 4
37645: NEG
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 4
37653: NEG
37654: PUSH
37655: LD_INT 3
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: LIST
37667: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37668: LD_ADDR_VAR 0 29
37672: PUSH
37673: LD_INT 1
37675: NEG
37676: PUSH
37677: LD_INT 3
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 0
37687: PUSH
37688: LD_INT 3
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: LD_INT 2
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 1
37709: NEG
37710: PUSH
37711: LD_INT 4
37713: NEG
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 0
37721: PUSH
37722: LD_INT 4
37724: NEG
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 1
37732: PUSH
37733: LD_INT 3
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 1
37743: NEG
37744: PUSH
37745: LD_INT 5
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 0
37755: PUSH
37756: LD_INT 5
37758: NEG
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: LD_INT 1
37766: PUSH
37767: LD_INT 4
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 6
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 6
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: PUSH
37801: LD_INT 5
37803: NEG
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37823: LD_ADDR_VAR 0 30
37827: PUSH
37828: LD_INT 2
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 3
37841: PUSH
37842: LD_INT 0
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 3
37851: PUSH
37852: LD_INT 1
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 3
37861: PUSH
37862: LD_INT 1
37864: NEG
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: LD_INT 4
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 4
37882: PUSH
37883: LD_INT 1
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 4
37892: PUSH
37893: LD_INT 1
37895: NEG
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 5
37903: PUSH
37904: LD_INT 0
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 5
37913: PUSH
37914: LD_INT 1
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 5
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 6
37934: PUSH
37935: LD_INT 0
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 6
37944: PUSH
37945: LD_INT 1
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37966: LD_ADDR_VAR 0 31
37970: PUSH
37971: LD_INT 3
37973: PUSH
37974: LD_INT 2
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 3
37983: PUSH
37984: LD_INT 3
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 2
37993: PUSH
37994: LD_INT 3
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 4
38003: PUSH
38004: LD_INT 3
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 4
38013: PUSH
38014: LD_INT 4
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 3
38023: PUSH
38024: LD_INT 4
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 5
38033: PUSH
38034: LD_INT 4
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 5
38043: PUSH
38044: LD_INT 5
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 4
38053: PUSH
38054: LD_INT 5
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 6
38063: PUSH
38064: LD_INT 5
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 6
38073: PUSH
38074: LD_INT 6
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 5
38083: PUSH
38084: LD_INT 6
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38105: LD_ADDR_VAR 0 32
38109: PUSH
38110: LD_INT 1
38112: PUSH
38113: LD_INT 3
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: LD_INT 3
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: LD_INT 2
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: LD_INT 4
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: LD_INT 4
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: LD_INT 3
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: PUSH
38175: LD_INT 5
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: LD_INT 5
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: LD_INT 4
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: LD_INT 6
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: LD_INT 6
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: NEG
38226: PUSH
38227: LD_INT 5
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38248: LD_ADDR_VAR 0 33
38252: PUSH
38253: LD_INT 2
38255: NEG
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 3
38266: NEG
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 3
38277: NEG
38278: PUSH
38279: LD_INT 1
38281: NEG
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 3
38289: NEG
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 4
38300: NEG
38301: PUSH
38302: LD_INT 0
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 4
38311: NEG
38312: PUSH
38313: LD_INT 1
38315: NEG
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 4
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 5
38334: NEG
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 5
38345: NEG
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 5
38357: NEG
38358: PUSH
38359: LD_INT 1
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 6
38368: NEG
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 6
38379: NEG
38380: PUSH
38381: LD_INT 1
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38403: LD_ADDR_VAR 0 34
38407: PUSH
38408: LD_INT 2
38410: NEG
38411: PUSH
38412: LD_INT 3
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 3
38422: NEG
38423: PUSH
38424: LD_INT 2
38426: NEG
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 3
38434: NEG
38435: PUSH
38436: LD_INT 3
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 3
38446: NEG
38447: PUSH
38448: LD_INT 4
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 4
38458: NEG
38459: PUSH
38460: LD_INT 3
38462: NEG
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 4
38470: NEG
38471: PUSH
38472: LD_INT 4
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 4
38482: NEG
38483: PUSH
38484: LD_INT 5
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 5
38494: NEG
38495: PUSH
38496: LD_INT 4
38498: NEG
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 5
38506: NEG
38507: PUSH
38508: LD_INT 5
38510: NEG
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PUSH
38516: LD_INT 5
38518: NEG
38519: PUSH
38520: LD_INT 6
38522: NEG
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 6
38530: NEG
38531: PUSH
38532: LD_INT 5
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 6
38542: NEG
38543: PUSH
38544: LD_INT 6
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38566: LD_ADDR_VAR 0 41
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 2
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 3
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: LIST
38609: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38610: LD_ADDR_VAR 0 42
38614: PUSH
38615: LD_INT 2
38617: PUSH
38618: LD_INT 0
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: LD_INT 2
38627: PUSH
38628: LD_INT 1
38630: NEG
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 3
38638: PUSH
38639: LD_INT 1
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: LIST
38650: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38651: LD_ADDR_VAR 0 43
38655: PUSH
38656: LD_INT 2
38658: PUSH
38659: LD_INT 2
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 3
38668: PUSH
38669: LD_INT 2
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 2
38678: PUSH
38679: LD_INT 3
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: LIST
38690: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38691: LD_ADDR_VAR 0 44
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 2
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 1
38708: PUSH
38709: LD_INT 3
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: NEG
38719: PUSH
38720: LD_INT 2
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38732: LD_ADDR_VAR 0 45
38736: PUSH
38737: LD_INT 2
38739: NEG
38740: PUSH
38741: LD_INT 0
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: LD_INT 1
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 3
38761: NEG
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: LIST
38775: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38776: LD_ADDR_VAR 0 46
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: LD_INT 2
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 2
38795: NEG
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 3
38807: NEG
38808: PUSH
38809: LD_INT 2
38811: NEG
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: LIST
38821: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38822: LD_ADDR_VAR 0 47
38826: PUSH
38827: LD_INT 2
38829: NEG
38830: PUSH
38831: LD_INT 3
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 3
38845: NEG
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38855: LD_ADDR_VAR 0 48
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 2
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 2
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38886: LD_ADDR_VAR 0 49
38890: PUSH
38891: LD_INT 3
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 3
38903: PUSH
38904: LD_INT 2
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38915: LD_ADDR_VAR 0 50
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: LD_INT 3
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 1
38932: PUSH
38933: LD_INT 3
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38944: LD_ADDR_VAR 0 51
38948: PUSH
38949: LD_INT 1
38951: NEG
38952: PUSH
38953: LD_INT 2
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 2
38962: NEG
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38975: LD_ADDR_VAR 0 52
38979: PUSH
38980: LD_INT 3
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 3
38994: NEG
38995: PUSH
38996: LD_INT 2
38998: NEG
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39008: LD_ADDR_VAR 0 53
39012: PUSH
39013: LD_INT 1
39015: NEG
39016: PUSH
39017: LD_INT 3
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 3
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 1
39038: PUSH
39039: LD_INT 2
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: LIST
39051: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39052: LD_ADDR_VAR 0 54
39056: PUSH
39057: LD_INT 2
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 3
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 3
39080: PUSH
39081: LD_INT 1
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39093: LD_ADDR_VAR 0 55
39097: PUSH
39098: LD_INT 3
39100: PUSH
39101: LD_INT 2
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 3
39110: PUSH
39111: LD_INT 3
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 2
39120: PUSH
39121: LD_INT 3
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: LIST
39132: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39133: LD_ADDR_VAR 0 56
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: LD_INT 3
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: LD_INT 3
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 1
39160: NEG
39161: PUSH
39162: LD_INT 2
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: LIST
39173: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39174: LD_ADDR_VAR 0 57
39178: PUSH
39179: LD_INT 2
39181: NEG
39182: PUSH
39183: LD_INT 1
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 3
39192: NEG
39193: PUSH
39194: LD_INT 0
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 3
39203: NEG
39204: PUSH
39205: LD_INT 1
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: LIST
39217: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39218: LD_ADDR_VAR 0 58
39222: PUSH
39223: LD_INT 2
39225: NEG
39226: PUSH
39227: LD_INT 3
39229: NEG
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 3
39237: NEG
39238: PUSH
39239: LD_INT 2
39241: NEG
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 3
39249: NEG
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: LIST
39263: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39264: LD_ADDR_VAR 0 59
39268: PUSH
39269: LD_INT 1
39271: NEG
39272: PUSH
39273: LD_INT 2
39275: NEG
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 2
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: LD_INT 1
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: LIST
39307: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39308: LD_ADDR_VAR 0 60
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 1
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 2
39326: PUSH
39327: LD_INT 0
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 2
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: LIST
39348: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39349: LD_ADDR_VAR 0 61
39353: PUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 2
39366: PUSH
39367: LD_INT 2
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: LIST
39388: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39389: LD_ADDR_VAR 0 62
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 2
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: LD_INT 2
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: NEG
39417: PUSH
39418: LD_INT 1
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: LIST
39429: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39430: LD_ADDR_VAR 0 63
39434: PUSH
39435: LD_INT 1
39437: NEG
39438: PUSH
39439: LD_INT 1
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 2
39448: NEG
39449: PUSH
39450: LD_INT 0
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 2
39459: NEG
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: LIST
39473: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39474: LD_ADDR_VAR 0 64
39478: PUSH
39479: LD_INT 1
39481: NEG
39482: PUSH
39483: LD_INT 2
39485: NEG
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 2
39493: NEG
39494: PUSH
39495: LD_INT 1
39497: NEG
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 2
39505: NEG
39506: PUSH
39507: LD_INT 2
39509: NEG
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: LIST
39519: ST_TO_ADDR
// end ; 2 :
39520: GO 42786
39522: LD_INT 2
39524: DOUBLE
39525: EQUAL
39526: IFTRUE 39530
39528: GO 42785
39530: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39531: LD_ADDR_VAR 0 29
39535: PUSH
39536: LD_INT 4
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 4
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 5
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 5
39569: PUSH
39570: LD_INT 1
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 4
39579: PUSH
39580: LD_INT 1
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 3
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 3
39610: PUSH
39611: LD_INT 2
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 5
39621: PUSH
39622: LD_INT 2
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 3
39631: PUSH
39632: LD_INT 3
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 3
39641: PUSH
39642: LD_INT 2
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 4
39651: PUSH
39652: LD_INT 3
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 4
39661: PUSH
39662: LD_INT 4
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 3
39671: PUSH
39672: LD_INT 4
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: PUSH
39682: LD_INT 3
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 2
39691: PUSH
39692: LD_INT 2
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: LD_INT 4
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 2
39711: PUSH
39712: LD_INT 4
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 0
39721: PUSH
39722: LD_INT 4
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 0
39731: PUSH
39732: LD_INT 3
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 1
39741: PUSH
39742: LD_INT 4
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: LD_INT 5
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 0
39761: PUSH
39762: LD_INT 5
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: NEG
39772: PUSH
39773: LD_INT 4
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: LD_INT 3
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 2
39793: PUSH
39794: LD_INT 5
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 2
39803: NEG
39804: PUSH
39805: LD_INT 3
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 3
39814: NEG
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 3
39825: NEG
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 2
39848: NEG
39849: PUSH
39850: LD_INT 1
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 3
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 4
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 4
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 4
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 2
39905: NEG
39906: PUSH
39907: LD_INT 2
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 4
39916: NEG
39917: PUSH
39918: LD_INT 4
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 4
39928: NEG
39929: PUSH
39930: LD_INT 5
39932: NEG
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 3
39940: NEG
39941: PUSH
39942: LD_INT 4
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 3
39952: NEG
39953: PUSH
39954: LD_INT 3
39956: NEG
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 4
39964: NEG
39965: PUSH
39966: LD_INT 3
39968: NEG
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 5
39976: NEG
39977: PUSH
39978: LD_INT 4
39980: NEG
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 5
39988: NEG
39989: PUSH
39990: LD_INT 5
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 3
40000: NEG
40001: PUSH
40002: LD_INT 5
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 5
40012: NEG
40013: PUSH
40014: LD_INT 3
40016: NEG
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: LIST
40065: LIST
40066: LIST
40067: LIST
40068: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40069: LD_ADDR_VAR 0 30
40073: PUSH
40074: LD_INT 4
40076: PUSH
40077: LD_INT 4
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 4
40086: PUSH
40087: LD_INT 3
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 5
40096: PUSH
40097: LD_INT 4
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 5
40106: PUSH
40107: LD_INT 5
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 4
40116: PUSH
40117: LD_INT 5
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: PUSH
40127: LD_INT 4
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 3
40136: PUSH
40137: LD_INT 3
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 5
40146: PUSH
40147: LD_INT 3
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 3
40156: PUSH
40157: LD_INT 5
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: LD_INT 3
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 0
40176: PUSH
40177: LD_INT 2
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 1
40186: PUSH
40187: LD_INT 3
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 1
40196: PUSH
40197: LD_INT 4
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: LD_INT 4
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: NEG
40217: PUSH
40218: LD_INT 3
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 2
40238: PUSH
40239: LD_INT 4
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: NEG
40249: PUSH
40250: LD_INT 2
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 4
40259: NEG
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 4
40270: NEG
40271: PUSH
40272: LD_INT 1
40274: NEG
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 3
40282: NEG
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: NEG
40294: PUSH
40295: LD_INT 1
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 4
40304: NEG
40305: PUSH
40306: LD_INT 1
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 5
40315: NEG
40316: PUSH
40317: LD_INT 0
40319: PUSH
40320: EMPTY
40321: LIST
40322: LIST
40323: PUSH
40324: LD_INT 5
40326: NEG
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 5
40338: NEG
40339: PUSH
40340: LD_INT 2
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: NEG
40351: PUSH
40352: LD_INT 2
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 3
40361: NEG
40362: PUSH
40363: LD_INT 3
40365: NEG
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 3
40373: NEG
40374: PUSH
40375: LD_INT 4
40377: NEG
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 2
40385: NEG
40386: PUSH
40387: LD_INT 3
40389: NEG
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 2
40397: NEG
40398: PUSH
40399: LD_INT 2
40401: NEG
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 3
40409: NEG
40410: PUSH
40411: LD_INT 2
40413: NEG
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 4
40421: NEG
40422: PUSH
40423: LD_INT 3
40425: NEG
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 4
40433: NEG
40434: PUSH
40435: LD_INT 4
40437: NEG
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 2
40445: NEG
40446: PUSH
40447: LD_INT 4
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 4
40457: NEG
40458: PUSH
40459: LD_INT 2
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 0
40469: PUSH
40470: LD_INT 4
40472: NEG
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: LD_INT 5
40483: NEG
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: PUSH
40492: LD_INT 4
40494: NEG
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 1
40502: PUSH
40503: LD_INT 3
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: LD_INT 3
40516: NEG
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: LD_INT 4
40528: NEG
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 1
40536: NEG
40537: PUSH
40538: LD_INT 5
40540: NEG
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 2
40548: PUSH
40549: LD_INT 3
40551: NEG
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 2
40559: NEG
40560: PUSH
40561: LD_INT 5
40563: NEG
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40616: LD_ADDR_VAR 0 31
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: LD_INT 4
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: LD_INT 0
40633: PUSH
40634: LD_INT 3
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: LD_INT 4
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 1
40653: PUSH
40654: LD_INT 5
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 5
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 1
40673: NEG
40674: PUSH
40675: LD_INT 4
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: NEG
40685: PUSH
40686: LD_INT 3
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 2
40695: PUSH
40696: LD_INT 5
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 2
40705: NEG
40706: PUSH
40707: LD_INT 3
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 3
40716: NEG
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 3
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 2
40739: NEG
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 2
40750: NEG
40751: PUSH
40752: LD_INT 1
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 3
40761: NEG
40762: PUSH
40763: LD_INT 1
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 4
40772: NEG
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 4
40783: NEG
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 4
40795: NEG
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 2
40807: NEG
40808: PUSH
40809: LD_INT 2
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 4
40818: NEG
40819: PUSH
40820: LD_INT 4
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 4
40830: NEG
40831: PUSH
40832: LD_INT 5
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 3
40842: NEG
40843: PUSH
40844: LD_INT 4
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 3
40854: NEG
40855: PUSH
40856: LD_INT 3
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: LD_INT 3
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 5
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 5
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 3
40902: NEG
40903: PUSH
40904: LD_INT 5
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 5
40914: NEG
40915: PUSH
40916: LD_INT 3
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: LD_INT 3
40929: NEG
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 0
40937: PUSH
40938: LD_INT 4
40940: NEG
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 1
40948: PUSH
40949: LD_INT 3
40951: NEG
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: LD_INT 2
40962: NEG
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 0
40970: PUSH
40971: LD_INT 2
40973: NEG
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: LD_INT 1
40981: NEG
40982: PUSH
40983: LD_INT 3
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 1
40993: NEG
40994: PUSH
40995: LD_INT 4
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 2
41005: PUSH
41006: LD_INT 2
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 2
41016: NEG
41017: PUSH
41018: LD_INT 4
41020: NEG
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 4
41028: PUSH
41029: LD_INT 0
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 4
41038: PUSH
41039: LD_INT 1
41041: NEG
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 5
41049: PUSH
41050: LD_INT 0
41052: PUSH
41053: EMPTY
41054: LIST
41055: LIST
41056: PUSH
41057: LD_INT 5
41059: PUSH
41060: LD_INT 1
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 4
41069: PUSH
41070: LD_INT 1
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 3
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: LD_INT 3
41089: PUSH
41090: LD_INT 1
41092: NEG
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 3
41100: PUSH
41101: LD_INT 2
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 5
41111: PUSH
41112: LD_INT 2
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: LIST
41123: LIST
41124: LIST
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: LIST
41141: LIST
41142: LIST
41143: LIST
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: LIST
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41166: LD_ADDR_VAR 0 32
41170: PUSH
41171: LD_INT 4
41173: NEG
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 4
41184: NEG
41185: PUSH
41186: LD_INT 1
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: NEG
41197: PUSH
41198: LD_INT 0
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: PUSH
41205: LD_INT 3
41207: NEG
41208: PUSH
41209: LD_INT 1
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 4
41218: NEG
41219: PUSH
41220: LD_INT 1
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 5
41229: NEG
41230: PUSH
41231: LD_INT 0
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 5
41240: NEG
41241: PUSH
41242: LD_INT 1
41244: NEG
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 5
41252: NEG
41253: PUSH
41254: LD_INT 2
41256: NEG
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 3
41264: NEG
41265: PUSH
41266: LD_INT 2
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 3
41275: NEG
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: LD_INT 4
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 2
41299: NEG
41300: PUSH
41301: LD_INT 3
41303: NEG
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 2
41311: NEG
41312: PUSH
41313: LD_INT 2
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 3
41323: NEG
41324: PUSH
41325: LD_INT 2
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 4
41335: NEG
41336: PUSH
41337: LD_INT 3
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 4
41347: NEG
41348: PUSH
41349: LD_INT 4
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 2
41359: NEG
41360: PUSH
41361: LD_INT 4
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 4
41371: NEG
41372: PUSH
41373: LD_INT 2
41375: NEG
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: LD_INT 4
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 0
41394: PUSH
41395: LD_INT 5
41397: NEG
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 1
41405: PUSH
41406: LD_INT 4
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: LD_INT 3
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 0
41427: PUSH
41428: LD_INT 3
41430: NEG
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 1
41438: NEG
41439: PUSH
41440: LD_INT 4
41442: NEG
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: LD_INT 1
41450: NEG
41451: PUSH
41452: LD_INT 5
41454: NEG
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 2
41462: PUSH
41463: LD_INT 3
41465: NEG
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 2
41473: NEG
41474: PUSH
41475: LD_INT 5
41477: NEG
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: LD_INT 0
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: LD_INT 1
41498: NEG
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 4
41506: PUSH
41507: LD_INT 0
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 4
41516: PUSH
41517: LD_INT 1
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 3
41526: PUSH
41527: LD_INT 1
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 2
41536: PUSH
41537: LD_INT 0
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 2
41546: PUSH
41547: LD_INT 1
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 2
41557: PUSH
41558: LD_INT 2
41560: NEG
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 4
41568: PUSH
41569: LD_INT 2
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 4
41578: PUSH
41579: LD_INT 4
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 4
41588: PUSH
41589: LD_INT 3
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 5
41598: PUSH
41599: LD_INT 4
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 5
41608: PUSH
41609: LD_INT 5
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 4
41618: PUSH
41619: LD_INT 5
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 3
41628: PUSH
41629: LD_INT 4
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 3
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 5
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: LD_INT 5
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: LIST
41685: LIST
41686: LIST
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: LIST
41707: LIST
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41713: LD_ADDR_VAR 0 33
41717: PUSH
41718: LD_INT 4
41720: NEG
41721: PUSH
41722: LD_INT 4
41724: NEG
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 4
41732: NEG
41733: PUSH
41734: LD_INT 5
41736: NEG
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 3
41744: NEG
41745: PUSH
41746: LD_INT 4
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 3
41756: NEG
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 4
41768: NEG
41769: PUSH
41770: LD_INT 3
41772: NEG
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 5
41780: NEG
41781: PUSH
41782: LD_INT 4
41784: NEG
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 5
41792: NEG
41793: PUSH
41794: LD_INT 5
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: NEG
41805: PUSH
41806: LD_INT 5
41808: NEG
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 5
41816: NEG
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: LD_INT 3
41831: NEG
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 0
41839: PUSH
41840: LD_INT 4
41842: NEG
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 0
41872: PUSH
41873: LD_INT 2
41875: NEG
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 1
41883: NEG
41884: PUSH
41885: LD_INT 3
41887: NEG
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 1
41895: NEG
41896: PUSH
41897: LD_INT 4
41899: NEG
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 2
41907: PUSH
41908: LD_INT 2
41910: NEG
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 2
41918: NEG
41919: PUSH
41920: LD_INT 4
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 4
41930: PUSH
41931: LD_INT 0
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 4
41940: PUSH
41941: LD_INT 1
41943: NEG
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PUSH
41949: LD_INT 5
41951: PUSH
41952: LD_INT 0
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 5
41961: PUSH
41962: LD_INT 1
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 4
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 3
42002: PUSH
42003: LD_INT 2
42005: NEG
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: LD_INT 5
42013: PUSH
42014: LD_INT 2
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 3
42023: PUSH
42024: LD_INT 3
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: LD_INT 3
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 4
42043: PUSH
42044: LD_INT 3
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 4
42053: PUSH
42054: LD_INT 4
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 3
42063: PUSH
42064: LD_INT 4
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: PUSH
42074: LD_INT 3
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 2
42083: PUSH
42084: LD_INT 2
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: PUSH
42094: LD_INT 2
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 0
42123: PUSH
42124: LD_INT 3
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 1
42133: PUSH
42134: LD_INT 4
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 1
42143: PUSH
42144: LD_INT 5
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: LD_INT 5
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 1
42163: NEG
42164: PUSH
42165: LD_INT 4
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 1
42174: NEG
42175: PUSH
42176: LD_INT 3
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 2
42185: PUSH
42186: LD_INT 5
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 2
42195: NEG
42196: PUSH
42197: LD_INT 3
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: LIST
42208: LIST
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: LIST
42219: LIST
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42251: LD_ADDR_VAR 0 34
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: LD_INT 4
42261: NEG
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: LD_INT 0
42269: PUSH
42270: LD_INT 5
42272: NEG
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 1
42280: PUSH
42281: LD_INT 4
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 1
42291: PUSH
42292: LD_INT 3
42294: NEG
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 0
42302: PUSH
42303: LD_INT 3
42305: NEG
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 1
42313: NEG
42314: PUSH
42315: LD_INT 4
42317: NEG
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: LD_INT 5
42329: NEG
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 2
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 2
42348: NEG
42349: PUSH
42350: LD_INT 5
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: LD_INT 0
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: LD_INT 1
42373: NEG
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 4
42381: PUSH
42382: LD_INT 0
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PUSH
42389: LD_INT 4
42391: PUSH
42392: LD_INT 1
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 3
42401: PUSH
42402: LD_INT 1
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 2
42411: PUSH
42412: LD_INT 0
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 2
42421: PUSH
42422: LD_INT 1
42424: NEG
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: LD_INT 2
42432: PUSH
42433: LD_INT 2
42435: NEG
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 4
42443: PUSH
42444: LD_INT 2
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 4
42453: PUSH
42454: LD_INT 4
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: LD_INT 3
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 5
42473: PUSH
42474: LD_INT 4
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 5
42483: PUSH
42484: LD_INT 5
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 4
42493: PUSH
42494: LD_INT 5
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 3
42503: PUSH
42504: LD_INT 4
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 3
42513: PUSH
42514: LD_INT 3
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 5
42523: PUSH
42524: LD_INT 3
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: LD_INT 5
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 0
42543: PUSH
42544: LD_INT 3
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 0
42553: PUSH
42554: LD_INT 2
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 1
42563: PUSH
42564: LD_INT 3
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 1
42573: PUSH
42574: LD_INT 4
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 0
42583: PUSH
42584: LD_INT 4
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 1
42593: NEG
42594: PUSH
42595: LD_INT 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 1
42604: NEG
42605: PUSH
42606: LD_INT 2
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: LD_INT 4
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 2
42625: NEG
42626: PUSH
42627: LD_INT 2
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 4
42636: NEG
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 4
42647: NEG
42648: PUSH
42649: LD_INT 1
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: LD_INT 3
42659: NEG
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 3
42670: NEG
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 4
42681: NEG
42682: PUSH
42683: LD_INT 1
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 5
42692: NEG
42693: PUSH
42694: LD_INT 0
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 5
42703: NEG
42704: PUSH
42705: LD_INT 1
42707: NEG
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 5
42715: NEG
42716: PUSH
42717: LD_INT 2
42719: NEG
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 3
42727: NEG
42728: PUSH
42729: LD_INT 2
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: ST_TO_ADDR
// end ; end ;
42783: GO 42786
42785: POP
// case btype of b_depot , b_warehouse :
42786: LD_VAR 0 1
42790: PUSH
42791: LD_INT 0
42793: DOUBLE
42794: EQUAL
42795: IFTRUE 42805
42797: LD_INT 1
42799: DOUBLE
42800: EQUAL
42801: IFTRUE 42805
42803: GO 43006
42805: POP
// case nation of nation_american :
42806: LD_VAR 0 5
42810: PUSH
42811: LD_INT 1
42813: DOUBLE
42814: EQUAL
42815: IFTRUE 42819
42817: GO 42875
42819: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42820: LD_ADDR_VAR 0 9
42824: PUSH
42825: LD_VAR 0 11
42829: PUSH
42830: LD_VAR 0 12
42834: PUSH
42835: LD_VAR 0 13
42839: PUSH
42840: LD_VAR 0 14
42844: PUSH
42845: LD_VAR 0 15
42849: PUSH
42850: LD_VAR 0 16
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: PUSH
42863: LD_VAR 0 4
42867: PUSH
42868: LD_INT 1
42870: PLUS
42871: ARRAY
42872: ST_TO_ADDR
42873: GO 43004
42875: LD_INT 2
42877: DOUBLE
42878: EQUAL
42879: IFTRUE 42883
42881: GO 42939
42883: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42884: LD_ADDR_VAR 0 9
42888: PUSH
42889: LD_VAR 0 17
42893: PUSH
42894: LD_VAR 0 18
42898: PUSH
42899: LD_VAR 0 19
42903: PUSH
42904: LD_VAR 0 20
42908: PUSH
42909: LD_VAR 0 21
42913: PUSH
42914: LD_VAR 0 22
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: LIST
42923: LIST
42924: LIST
42925: LIST
42926: PUSH
42927: LD_VAR 0 4
42931: PUSH
42932: LD_INT 1
42934: PLUS
42935: ARRAY
42936: ST_TO_ADDR
42937: GO 43004
42939: LD_INT 3
42941: DOUBLE
42942: EQUAL
42943: IFTRUE 42947
42945: GO 43003
42947: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42948: LD_ADDR_VAR 0 9
42952: PUSH
42953: LD_VAR 0 23
42957: PUSH
42958: LD_VAR 0 24
42962: PUSH
42963: LD_VAR 0 25
42967: PUSH
42968: LD_VAR 0 26
42972: PUSH
42973: LD_VAR 0 27
42977: PUSH
42978: LD_VAR 0 28
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: PUSH
42991: LD_VAR 0 4
42995: PUSH
42996: LD_INT 1
42998: PLUS
42999: ARRAY
43000: ST_TO_ADDR
43001: GO 43004
43003: POP
43004: GO 43559
43006: LD_INT 2
43008: DOUBLE
43009: EQUAL
43010: IFTRUE 43020
43012: LD_INT 3
43014: DOUBLE
43015: EQUAL
43016: IFTRUE 43020
43018: GO 43076
43020: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43021: LD_ADDR_VAR 0 9
43025: PUSH
43026: LD_VAR 0 29
43030: PUSH
43031: LD_VAR 0 30
43035: PUSH
43036: LD_VAR 0 31
43040: PUSH
43041: LD_VAR 0 32
43045: PUSH
43046: LD_VAR 0 33
43050: PUSH
43051: LD_VAR 0 34
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: PUSH
43064: LD_VAR 0 4
43068: PUSH
43069: LD_INT 1
43071: PLUS
43072: ARRAY
43073: ST_TO_ADDR
43074: GO 43559
43076: LD_INT 16
43078: DOUBLE
43079: EQUAL
43080: IFTRUE 43138
43082: LD_INT 17
43084: DOUBLE
43085: EQUAL
43086: IFTRUE 43138
43088: LD_INT 18
43090: DOUBLE
43091: EQUAL
43092: IFTRUE 43138
43094: LD_INT 19
43096: DOUBLE
43097: EQUAL
43098: IFTRUE 43138
43100: LD_INT 22
43102: DOUBLE
43103: EQUAL
43104: IFTRUE 43138
43106: LD_INT 20
43108: DOUBLE
43109: EQUAL
43110: IFTRUE 43138
43112: LD_INT 21
43114: DOUBLE
43115: EQUAL
43116: IFTRUE 43138
43118: LD_INT 23
43120: DOUBLE
43121: EQUAL
43122: IFTRUE 43138
43124: LD_INT 24
43126: DOUBLE
43127: EQUAL
43128: IFTRUE 43138
43130: LD_INT 25
43132: DOUBLE
43133: EQUAL
43134: IFTRUE 43138
43136: GO 43194
43138: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43139: LD_ADDR_VAR 0 9
43143: PUSH
43144: LD_VAR 0 35
43148: PUSH
43149: LD_VAR 0 36
43153: PUSH
43154: LD_VAR 0 37
43158: PUSH
43159: LD_VAR 0 38
43163: PUSH
43164: LD_VAR 0 39
43168: PUSH
43169: LD_VAR 0 40
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: PUSH
43182: LD_VAR 0 4
43186: PUSH
43187: LD_INT 1
43189: PLUS
43190: ARRAY
43191: ST_TO_ADDR
43192: GO 43559
43194: LD_INT 6
43196: DOUBLE
43197: EQUAL
43198: IFTRUE 43250
43200: LD_INT 7
43202: DOUBLE
43203: EQUAL
43204: IFTRUE 43250
43206: LD_INT 8
43208: DOUBLE
43209: EQUAL
43210: IFTRUE 43250
43212: LD_INT 13
43214: DOUBLE
43215: EQUAL
43216: IFTRUE 43250
43218: LD_INT 12
43220: DOUBLE
43221: EQUAL
43222: IFTRUE 43250
43224: LD_INT 15
43226: DOUBLE
43227: EQUAL
43228: IFTRUE 43250
43230: LD_INT 11
43232: DOUBLE
43233: EQUAL
43234: IFTRUE 43250
43236: LD_INT 14
43238: DOUBLE
43239: EQUAL
43240: IFTRUE 43250
43242: LD_INT 10
43244: DOUBLE
43245: EQUAL
43246: IFTRUE 43250
43248: GO 43306
43250: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43251: LD_ADDR_VAR 0 9
43255: PUSH
43256: LD_VAR 0 41
43260: PUSH
43261: LD_VAR 0 42
43265: PUSH
43266: LD_VAR 0 43
43270: PUSH
43271: LD_VAR 0 44
43275: PUSH
43276: LD_VAR 0 45
43280: PUSH
43281: LD_VAR 0 46
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: LIST
43290: LIST
43291: LIST
43292: LIST
43293: PUSH
43294: LD_VAR 0 4
43298: PUSH
43299: LD_INT 1
43301: PLUS
43302: ARRAY
43303: ST_TO_ADDR
43304: GO 43559
43306: LD_INT 36
43308: DOUBLE
43309: EQUAL
43310: IFTRUE 43314
43312: GO 43370
43314: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43315: LD_ADDR_VAR 0 9
43319: PUSH
43320: LD_VAR 0 47
43324: PUSH
43325: LD_VAR 0 48
43329: PUSH
43330: LD_VAR 0 49
43334: PUSH
43335: LD_VAR 0 50
43339: PUSH
43340: LD_VAR 0 51
43344: PUSH
43345: LD_VAR 0 52
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: PUSH
43358: LD_VAR 0 4
43362: PUSH
43363: LD_INT 1
43365: PLUS
43366: ARRAY
43367: ST_TO_ADDR
43368: GO 43559
43370: LD_INT 4
43372: DOUBLE
43373: EQUAL
43374: IFTRUE 43396
43376: LD_INT 5
43378: DOUBLE
43379: EQUAL
43380: IFTRUE 43396
43382: LD_INT 34
43384: DOUBLE
43385: EQUAL
43386: IFTRUE 43396
43388: LD_INT 37
43390: DOUBLE
43391: EQUAL
43392: IFTRUE 43396
43394: GO 43452
43396: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43397: LD_ADDR_VAR 0 9
43401: PUSH
43402: LD_VAR 0 53
43406: PUSH
43407: LD_VAR 0 54
43411: PUSH
43412: LD_VAR 0 55
43416: PUSH
43417: LD_VAR 0 56
43421: PUSH
43422: LD_VAR 0 57
43426: PUSH
43427: LD_VAR 0 58
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: PUSH
43440: LD_VAR 0 4
43444: PUSH
43445: LD_INT 1
43447: PLUS
43448: ARRAY
43449: ST_TO_ADDR
43450: GO 43559
43452: LD_INT 31
43454: DOUBLE
43455: EQUAL
43456: IFTRUE 43502
43458: LD_INT 32
43460: DOUBLE
43461: EQUAL
43462: IFTRUE 43502
43464: LD_INT 33
43466: DOUBLE
43467: EQUAL
43468: IFTRUE 43502
43470: LD_INT 27
43472: DOUBLE
43473: EQUAL
43474: IFTRUE 43502
43476: LD_INT 26
43478: DOUBLE
43479: EQUAL
43480: IFTRUE 43502
43482: LD_INT 28
43484: DOUBLE
43485: EQUAL
43486: IFTRUE 43502
43488: LD_INT 29
43490: DOUBLE
43491: EQUAL
43492: IFTRUE 43502
43494: LD_INT 30
43496: DOUBLE
43497: EQUAL
43498: IFTRUE 43502
43500: GO 43558
43502: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43503: LD_ADDR_VAR 0 9
43507: PUSH
43508: LD_VAR 0 59
43512: PUSH
43513: LD_VAR 0 60
43517: PUSH
43518: LD_VAR 0 61
43522: PUSH
43523: LD_VAR 0 62
43527: PUSH
43528: LD_VAR 0 63
43532: PUSH
43533: LD_VAR 0 64
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: PUSH
43546: LD_VAR 0 4
43550: PUSH
43551: LD_INT 1
43553: PLUS
43554: ARRAY
43555: ST_TO_ADDR
43556: GO 43559
43558: POP
// temp_list2 = [ ] ;
43559: LD_ADDR_VAR 0 10
43563: PUSH
43564: EMPTY
43565: ST_TO_ADDR
// for i in temp_list do
43566: LD_ADDR_VAR 0 8
43570: PUSH
43571: LD_VAR 0 9
43575: PUSH
43576: FOR_IN
43577: IFFALSE 43629
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43579: LD_ADDR_VAR 0 10
43583: PUSH
43584: LD_VAR 0 10
43588: PUSH
43589: LD_VAR 0 8
43593: PUSH
43594: LD_INT 1
43596: ARRAY
43597: PUSH
43598: LD_VAR 0 2
43602: PLUS
43603: PUSH
43604: LD_VAR 0 8
43608: PUSH
43609: LD_INT 2
43611: ARRAY
43612: PUSH
43613: LD_VAR 0 3
43617: PLUS
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: EMPTY
43624: LIST
43625: ADD
43626: ST_TO_ADDR
43627: GO 43576
43629: POP
43630: POP
// result = temp_list2 ;
43631: LD_ADDR_VAR 0 7
43635: PUSH
43636: LD_VAR 0 10
43640: ST_TO_ADDR
// end ;
43641: LD_VAR 0 7
43645: RET
// export function EnemyInRange ( unit , dist ) ; begin
43646: LD_INT 0
43648: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43649: LD_ADDR_VAR 0 3
43653: PUSH
43654: LD_VAR 0 1
43658: PPUSH
43659: CALL_OW 255
43663: PPUSH
43664: LD_VAR 0 1
43668: PPUSH
43669: CALL_OW 250
43673: PPUSH
43674: LD_VAR 0 1
43678: PPUSH
43679: CALL_OW 251
43683: PPUSH
43684: LD_VAR 0 2
43688: PPUSH
43689: CALL 17048 0 4
43693: PUSH
43694: LD_INT 4
43696: ARRAY
43697: ST_TO_ADDR
// end ;
43698: LD_VAR 0 3
43702: RET
// export function PlayerSeeMe ( unit ) ; begin
43703: LD_INT 0
43705: PPUSH
// result := See ( your_side , unit ) ;
43706: LD_ADDR_VAR 0 2
43710: PUSH
43711: LD_OWVAR 2
43715: PPUSH
43716: LD_VAR 0 1
43720: PPUSH
43721: CALL_OW 292
43725: ST_TO_ADDR
// end ;
43726: LD_VAR 0 2
43730: RET
// export function ReverseDir ( unit ) ; begin
43731: LD_INT 0
43733: PPUSH
// if not unit then
43734: LD_VAR 0 1
43738: NOT
43739: IFFALSE 43743
// exit ;
43741: GO 43766
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43743: LD_ADDR_VAR 0 2
43747: PUSH
43748: LD_VAR 0 1
43752: PPUSH
43753: CALL_OW 254
43757: PUSH
43758: LD_INT 3
43760: PLUS
43761: PUSH
43762: LD_INT 6
43764: MOD
43765: ST_TO_ADDR
// end ;
43766: LD_VAR 0 2
43770: RET
// export function ReverseArray ( array ) ; var i ; begin
43771: LD_INT 0
43773: PPUSH
43774: PPUSH
// if not array then
43775: LD_VAR 0 1
43779: NOT
43780: IFFALSE 43784
// exit ;
43782: GO 43839
// result := [ ] ;
43784: LD_ADDR_VAR 0 2
43788: PUSH
43789: EMPTY
43790: ST_TO_ADDR
// for i := array downto 1 do
43791: LD_ADDR_VAR 0 3
43795: PUSH
43796: DOUBLE
43797: LD_VAR 0 1
43801: INC
43802: ST_TO_ADDR
43803: LD_INT 1
43805: PUSH
43806: FOR_DOWNTO
43807: IFFALSE 43837
// result := Join ( result , array [ i ] ) ;
43809: LD_ADDR_VAR 0 2
43813: PUSH
43814: LD_VAR 0 2
43818: PPUSH
43819: LD_VAR 0 1
43823: PUSH
43824: LD_VAR 0 3
43828: ARRAY
43829: PPUSH
43830: CALL 48464 0 2
43834: ST_TO_ADDR
43835: GO 43806
43837: POP
43838: POP
// end ;
43839: LD_VAR 0 2
43843: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43844: LD_INT 0
43846: PPUSH
43847: PPUSH
43848: PPUSH
43849: PPUSH
43850: PPUSH
43851: PPUSH
// if not unit or not hexes then
43852: LD_VAR 0 1
43856: NOT
43857: PUSH
43858: LD_VAR 0 2
43862: NOT
43863: OR
43864: IFFALSE 43868
// exit ;
43866: GO 43991
// dist := 9999 ;
43868: LD_ADDR_VAR 0 5
43872: PUSH
43873: LD_INT 9999
43875: ST_TO_ADDR
// for i = 1 to hexes do
43876: LD_ADDR_VAR 0 4
43880: PUSH
43881: DOUBLE
43882: LD_INT 1
43884: DEC
43885: ST_TO_ADDR
43886: LD_VAR 0 2
43890: PUSH
43891: FOR_TO
43892: IFFALSE 43979
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43894: LD_ADDR_VAR 0 6
43898: PUSH
43899: LD_VAR 0 1
43903: PPUSH
43904: LD_VAR 0 2
43908: PUSH
43909: LD_VAR 0 4
43913: ARRAY
43914: PUSH
43915: LD_INT 1
43917: ARRAY
43918: PPUSH
43919: LD_VAR 0 2
43923: PUSH
43924: LD_VAR 0 4
43928: ARRAY
43929: PUSH
43930: LD_INT 2
43932: ARRAY
43933: PPUSH
43934: CALL_OW 297
43938: ST_TO_ADDR
// if tdist < dist then
43939: LD_VAR 0 6
43943: PUSH
43944: LD_VAR 0 5
43948: LESS
43949: IFFALSE 43977
// begin hex := hexes [ i ] ;
43951: LD_ADDR_VAR 0 8
43955: PUSH
43956: LD_VAR 0 2
43960: PUSH
43961: LD_VAR 0 4
43965: ARRAY
43966: ST_TO_ADDR
// dist := tdist ;
43967: LD_ADDR_VAR 0 5
43971: PUSH
43972: LD_VAR 0 6
43976: ST_TO_ADDR
// end ; end ;
43977: GO 43891
43979: POP
43980: POP
// result := hex ;
43981: LD_ADDR_VAR 0 3
43985: PUSH
43986: LD_VAR 0 8
43990: ST_TO_ADDR
// end ;
43991: LD_VAR 0 3
43995: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43996: LD_INT 0
43998: PPUSH
43999: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44000: LD_VAR 0 1
44004: NOT
44005: PUSH
44006: LD_VAR 0 1
44010: PUSH
44011: LD_INT 21
44013: PUSH
44014: LD_INT 2
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 23
44023: PUSH
44024: LD_INT 2
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PPUSH
44035: CALL_OW 69
44039: IN
44040: NOT
44041: OR
44042: IFFALSE 44046
// exit ;
44044: GO 44093
// for i = 1 to 3 do
44046: LD_ADDR_VAR 0 3
44050: PUSH
44051: DOUBLE
44052: LD_INT 1
44054: DEC
44055: ST_TO_ADDR
44056: LD_INT 3
44058: PUSH
44059: FOR_TO
44060: IFFALSE 44091
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44062: LD_VAR 0 1
44066: PPUSH
44067: CALL_OW 250
44071: PPUSH
44072: LD_VAR 0 1
44076: PPUSH
44077: CALL_OW 251
44081: PPUSH
44082: LD_INT 1
44084: PPUSH
44085: CALL_OW 453
44089: GO 44059
44091: POP
44092: POP
// end ;
44093: LD_VAR 0 2
44097: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44098: LD_INT 0
44100: PPUSH
44101: PPUSH
44102: PPUSH
44103: PPUSH
44104: PPUSH
44105: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44106: LD_VAR 0 1
44110: NOT
44111: PUSH
44112: LD_VAR 0 2
44116: NOT
44117: OR
44118: PUSH
44119: LD_VAR 0 1
44123: PPUSH
44124: CALL_OW 314
44128: OR
44129: IFFALSE 44133
// exit ;
44131: GO 44574
// x := GetX ( enemy_unit ) ;
44133: LD_ADDR_VAR 0 7
44137: PUSH
44138: LD_VAR 0 2
44142: PPUSH
44143: CALL_OW 250
44147: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44148: LD_ADDR_VAR 0 8
44152: PUSH
44153: LD_VAR 0 2
44157: PPUSH
44158: CALL_OW 251
44162: ST_TO_ADDR
// if not x or not y then
44163: LD_VAR 0 7
44167: NOT
44168: PUSH
44169: LD_VAR 0 8
44173: NOT
44174: OR
44175: IFFALSE 44179
// exit ;
44177: GO 44574
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44179: LD_ADDR_VAR 0 6
44183: PUSH
44184: LD_VAR 0 7
44188: PPUSH
44189: LD_INT 0
44191: PPUSH
44192: LD_INT 4
44194: PPUSH
44195: CALL_OW 272
44199: PUSH
44200: LD_VAR 0 8
44204: PPUSH
44205: LD_INT 0
44207: PPUSH
44208: LD_INT 4
44210: PPUSH
44211: CALL_OW 273
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_VAR 0 7
44224: PPUSH
44225: LD_INT 1
44227: PPUSH
44228: LD_INT 4
44230: PPUSH
44231: CALL_OW 272
44235: PUSH
44236: LD_VAR 0 8
44240: PPUSH
44241: LD_INT 1
44243: PPUSH
44244: LD_INT 4
44246: PPUSH
44247: CALL_OW 273
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_VAR 0 7
44260: PPUSH
44261: LD_INT 2
44263: PPUSH
44264: LD_INT 4
44266: PPUSH
44267: CALL_OW 272
44271: PUSH
44272: LD_VAR 0 8
44276: PPUSH
44277: LD_INT 2
44279: PPUSH
44280: LD_INT 4
44282: PPUSH
44283: CALL_OW 273
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_VAR 0 7
44296: PPUSH
44297: LD_INT 3
44299: PPUSH
44300: LD_INT 4
44302: PPUSH
44303: CALL_OW 272
44307: PUSH
44308: LD_VAR 0 8
44312: PPUSH
44313: LD_INT 3
44315: PPUSH
44316: LD_INT 4
44318: PPUSH
44319: CALL_OW 273
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_VAR 0 7
44332: PPUSH
44333: LD_INT 4
44335: PPUSH
44336: LD_INT 4
44338: PPUSH
44339: CALL_OW 272
44343: PUSH
44344: LD_VAR 0 8
44348: PPUSH
44349: LD_INT 4
44351: PPUSH
44352: LD_INT 4
44354: PPUSH
44355: CALL_OW 273
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: LD_VAR 0 7
44368: PPUSH
44369: LD_INT 5
44371: PPUSH
44372: LD_INT 4
44374: PPUSH
44375: CALL_OW 272
44379: PUSH
44380: LD_VAR 0 8
44384: PPUSH
44385: LD_INT 5
44387: PPUSH
44388: LD_INT 4
44390: PPUSH
44391: CALL_OW 273
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: ST_TO_ADDR
// for i = tmp downto 1 do
44408: LD_ADDR_VAR 0 4
44412: PUSH
44413: DOUBLE
44414: LD_VAR 0 6
44418: INC
44419: ST_TO_ADDR
44420: LD_INT 1
44422: PUSH
44423: FOR_DOWNTO
44424: IFFALSE 44525
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44426: LD_VAR 0 6
44430: PUSH
44431: LD_VAR 0 4
44435: ARRAY
44436: PUSH
44437: LD_INT 1
44439: ARRAY
44440: PPUSH
44441: LD_VAR 0 6
44445: PUSH
44446: LD_VAR 0 4
44450: ARRAY
44451: PUSH
44452: LD_INT 2
44454: ARRAY
44455: PPUSH
44456: CALL_OW 488
44460: NOT
44461: PUSH
44462: LD_VAR 0 6
44466: PUSH
44467: LD_VAR 0 4
44471: ARRAY
44472: PUSH
44473: LD_INT 1
44475: ARRAY
44476: PPUSH
44477: LD_VAR 0 6
44481: PUSH
44482: LD_VAR 0 4
44486: ARRAY
44487: PUSH
44488: LD_INT 2
44490: ARRAY
44491: PPUSH
44492: CALL_OW 428
44496: PUSH
44497: LD_INT 0
44499: NONEQUAL
44500: OR
44501: IFFALSE 44523
// tmp := Delete ( tmp , i ) ;
44503: LD_ADDR_VAR 0 6
44507: PUSH
44508: LD_VAR 0 6
44512: PPUSH
44513: LD_VAR 0 4
44517: PPUSH
44518: CALL_OW 3
44522: ST_TO_ADDR
44523: GO 44423
44525: POP
44526: POP
// j := GetClosestHex ( unit , tmp ) ;
44527: LD_ADDR_VAR 0 5
44531: PUSH
44532: LD_VAR 0 1
44536: PPUSH
44537: LD_VAR 0 6
44541: PPUSH
44542: CALL 43844 0 2
44546: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44547: LD_VAR 0 1
44551: PPUSH
44552: LD_VAR 0 5
44556: PUSH
44557: LD_INT 1
44559: ARRAY
44560: PPUSH
44561: LD_VAR 0 5
44565: PUSH
44566: LD_INT 2
44568: ARRAY
44569: PPUSH
44570: CALL_OW 111
// end ;
44574: LD_VAR 0 3
44578: RET
// export function PrepareApemanSoldier ( ) ; begin
44579: LD_INT 0
44581: PPUSH
// uc_nation := 0 ;
44582: LD_ADDR_OWVAR 21
44586: PUSH
44587: LD_INT 0
44589: ST_TO_ADDR
// hc_sex := sex_male ;
44590: LD_ADDR_OWVAR 27
44594: PUSH
44595: LD_INT 1
44597: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44598: LD_ADDR_OWVAR 28
44602: PUSH
44603: LD_INT 15
44605: ST_TO_ADDR
// hc_gallery :=  ;
44606: LD_ADDR_OWVAR 33
44610: PUSH
44611: LD_STRING 
44613: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44614: LD_ADDR_OWVAR 31
44618: PUSH
44619: LD_INT 0
44621: PPUSH
44622: LD_INT 3
44624: PPUSH
44625: CALL_OW 12
44629: PUSH
44630: LD_INT 0
44632: PPUSH
44633: LD_INT 3
44635: PPUSH
44636: CALL_OW 12
44640: PUSH
44641: LD_INT 0
44643: PUSH
44644: LD_INT 0
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: ST_TO_ADDR
// end ;
44653: LD_VAR 0 1
44657: RET
// export function PrepareApemanEngineer ( ) ; begin
44658: LD_INT 0
44660: PPUSH
// uc_nation := 0 ;
44661: LD_ADDR_OWVAR 21
44665: PUSH
44666: LD_INT 0
44668: ST_TO_ADDR
// hc_sex := sex_male ;
44669: LD_ADDR_OWVAR 27
44673: PUSH
44674: LD_INT 1
44676: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44677: LD_ADDR_OWVAR 28
44681: PUSH
44682: LD_INT 16
44684: ST_TO_ADDR
// hc_gallery :=  ;
44685: LD_ADDR_OWVAR 33
44689: PUSH
44690: LD_STRING 
44692: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44693: LD_ADDR_OWVAR 31
44697: PUSH
44698: LD_INT 0
44700: PPUSH
44701: LD_INT 3
44703: PPUSH
44704: CALL_OW 12
44708: PUSH
44709: LD_INT 0
44711: PPUSH
44712: LD_INT 3
44714: PPUSH
44715: CALL_OW 12
44719: PUSH
44720: LD_INT 0
44722: PUSH
44723: LD_INT 0
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: ST_TO_ADDR
// end ;
44732: LD_VAR 0 1
44736: RET
// export function PrepareApeman ( agressivity ) ; begin
44737: LD_INT 0
44739: PPUSH
// uc_side := 0 ;
44740: LD_ADDR_OWVAR 20
44744: PUSH
44745: LD_INT 0
44747: ST_TO_ADDR
// uc_nation := 0 ;
44748: LD_ADDR_OWVAR 21
44752: PUSH
44753: LD_INT 0
44755: ST_TO_ADDR
// hc_sex := sex_male ;
44756: LD_ADDR_OWVAR 27
44760: PUSH
44761: LD_INT 1
44763: ST_TO_ADDR
// hc_class := class_apeman ;
44764: LD_ADDR_OWVAR 28
44768: PUSH
44769: LD_INT 12
44771: ST_TO_ADDR
// hc_gallery :=  ;
44772: LD_ADDR_OWVAR 33
44776: PUSH
44777: LD_STRING 
44779: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44780: LD_ADDR_OWVAR 35
44784: PUSH
44785: LD_VAR 0 1
44789: NEG
44790: PPUSH
44791: LD_VAR 0 1
44795: PPUSH
44796: CALL_OW 12
44800: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44801: LD_ADDR_OWVAR 31
44805: PUSH
44806: LD_INT 0
44808: PPUSH
44809: LD_INT 3
44811: PPUSH
44812: CALL_OW 12
44816: PUSH
44817: LD_INT 0
44819: PPUSH
44820: LD_INT 3
44822: PPUSH
44823: CALL_OW 12
44827: PUSH
44828: LD_INT 0
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: ST_TO_ADDR
// end ;
44840: LD_VAR 0 2
44844: RET
// export function PrepareTiger ( agressivity ) ; begin
44845: LD_INT 0
44847: PPUSH
// uc_side := 0 ;
44848: LD_ADDR_OWVAR 20
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// uc_nation := 0 ;
44856: LD_ADDR_OWVAR 21
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// hc_class := class_tiger ;
44864: LD_ADDR_OWVAR 28
44868: PUSH
44869: LD_INT 14
44871: ST_TO_ADDR
// hc_gallery :=  ;
44872: LD_ADDR_OWVAR 33
44876: PUSH
44877: LD_STRING 
44879: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44880: LD_ADDR_OWVAR 35
44884: PUSH
44885: LD_VAR 0 1
44889: NEG
44890: PPUSH
44891: LD_VAR 0 1
44895: PPUSH
44896: CALL_OW 12
44900: ST_TO_ADDR
// end ;
44901: LD_VAR 0 2
44905: RET
// export function PrepareEnchidna ( ) ; begin
44906: LD_INT 0
44908: PPUSH
// uc_side := 0 ;
44909: LD_ADDR_OWVAR 20
44913: PUSH
44914: LD_INT 0
44916: ST_TO_ADDR
// uc_nation := 0 ;
44917: LD_ADDR_OWVAR 21
44921: PUSH
44922: LD_INT 0
44924: ST_TO_ADDR
// hc_class := class_baggie ;
44925: LD_ADDR_OWVAR 28
44929: PUSH
44930: LD_INT 13
44932: ST_TO_ADDR
// hc_gallery :=  ;
44933: LD_ADDR_OWVAR 33
44937: PUSH
44938: LD_STRING 
44940: ST_TO_ADDR
// end ;
44941: LD_VAR 0 1
44945: RET
// export function PrepareFrog ( ) ; begin
44946: LD_INT 0
44948: PPUSH
// uc_side := 0 ;
44949: LD_ADDR_OWVAR 20
44953: PUSH
44954: LD_INT 0
44956: ST_TO_ADDR
// uc_nation := 0 ;
44957: LD_ADDR_OWVAR 21
44961: PUSH
44962: LD_INT 0
44964: ST_TO_ADDR
// hc_class := class_frog ;
44965: LD_ADDR_OWVAR 28
44969: PUSH
44970: LD_INT 19
44972: ST_TO_ADDR
// hc_gallery :=  ;
44973: LD_ADDR_OWVAR 33
44977: PUSH
44978: LD_STRING 
44980: ST_TO_ADDR
// end ;
44981: LD_VAR 0 1
44985: RET
// export function PrepareFish ( ) ; begin
44986: LD_INT 0
44988: PPUSH
// uc_side := 0 ;
44989: LD_ADDR_OWVAR 20
44993: PUSH
44994: LD_INT 0
44996: ST_TO_ADDR
// uc_nation := 0 ;
44997: LD_ADDR_OWVAR 21
45001: PUSH
45002: LD_INT 0
45004: ST_TO_ADDR
// hc_class := class_fish ;
45005: LD_ADDR_OWVAR 28
45009: PUSH
45010: LD_INT 20
45012: ST_TO_ADDR
// hc_gallery :=  ;
45013: LD_ADDR_OWVAR 33
45017: PUSH
45018: LD_STRING 
45020: ST_TO_ADDR
// end ;
45021: LD_VAR 0 1
45025: RET
// export function PrepareBird ( ) ; begin
45026: LD_INT 0
45028: PPUSH
// uc_side := 0 ;
45029: LD_ADDR_OWVAR 20
45033: PUSH
45034: LD_INT 0
45036: ST_TO_ADDR
// uc_nation := 0 ;
45037: LD_ADDR_OWVAR 21
45041: PUSH
45042: LD_INT 0
45044: ST_TO_ADDR
// hc_class := class_phororhacos ;
45045: LD_ADDR_OWVAR 28
45049: PUSH
45050: LD_INT 18
45052: ST_TO_ADDR
// hc_gallery :=  ;
45053: LD_ADDR_OWVAR 33
45057: PUSH
45058: LD_STRING 
45060: ST_TO_ADDR
// end ;
45061: LD_VAR 0 1
45065: RET
// export function PrepareHorse ( ) ; begin
45066: LD_INT 0
45068: PPUSH
// uc_side := 0 ;
45069: LD_ADDR_OWVAR 20
45073: PUSH
45074: LD_INT 0
45076: ST_TO_ADDR
// uc_nation := 0 ;
45077: LD_ADDR_OWVAR 21
45081: PUSH
45082: LD_INT 0
45084: ST_TO_ADDR
// hc_class := class_horse ;
45085: LD_ADDR_OWVAR 28
45089: PUSH
45090: LD_INT 21
45092: ST_TO_ADDR
// hc_gallery :=  ;
45093: LD_ADDR_OWVAR 33
45097: PUSH
45098: LD_STRING 
45100: ST_TO_ADDR
// end ;
45101: LD_VAR 0 1
45105: RET
// export function PrepareMastodont ( ) ; begin
45106: LD_INT 0
45108: PPUSH
// uc_side := 0 ;
45109: LD_ADDR_OWVAR 20
45113: PUSH
45114: LD_INT 0
45116: ST_TO_ADDR
// uc_nation := 0 ;
45117: LD_ADDR_OWVAR 21
45121: PUSH
45122: LD_INT 0
45124: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45125: LD_ADDR_OWVAR 37
45129: PUSH
45130: LD_INT 31
45132: ST_TO_ADDR
// vc_control := control_rider ;
45133: LD_ADDR_OWVAR 38
45137: PUSH
45138: LD_INT 4
45140: ST_TO_ADDR
// end ;
45141: LD_VAR 0 1
45145: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45146: LD_INT 0
45148: PPUSH
45149: PPUSH
45150: PPUSH
// uc_side = 0 ;
45151: LD_ADDR_OWVAR 20
45155: PUSH
45156: LD_INT 0
45158: ST_TO_ADDR
// uc_nation = 0 ;
45159: LD_ADDR_OWVAR 21
45163: PUSH
45164: LD_INT 0
45166: ST_TO_ADDR
// InitHc_All ( ) ;
45167: CALL_OW 584
// InitVc ;
45171: CALL_OW 20
// if mastodonts then
45175: LD_VAR 0 6
45179: IFFALSE 45246
// for i = 1 to mastodonts do
45181: LD_ADDR_VAR 0 11
45185: PUSH
45186: DOUBLE
45187: LD_INT 1
45189: DEC
45190: ST_TO_ADDR
45191: LD_VAR 0 6
45195: PUSH
45196: FOR_TO
45197: IFFALSE 45244
// begin vc_chassis := 31 ;
45199: LD_ADDR_OWVAR 37
45203: PUSH
45204: LD_INT 31
45206: ST_TO_ADDR
// vc_control := control_rider ;
45207: LD_ADDR_OWVAR 38
45211: PUSH
45212: LD_INT 4
45214: ST_TO_ADDR
// animal := CreateVehicle ;
45215: LD_ADDR_VAR 0 12
45219: PUSH
45220: CALL_OW 45
45224: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45225: LD_VAR 0 12
45229: PPUSH
45230: LD_VAR 0 8
45234: PPUSH
45235: LD_INT 0
45237: PPUSH
45238: CALL 47381 0 3
// end ;
45242: GO 45196
45244: POP
45245: POP
// if horses then
45246: LD_VAR 0 5
45250: IFFALSE 45317
// for i = 1 to horses do
45252: LD_ADDR_VAR 0 11
45256: PUSH
45257: DOUBLE
45258: LD_INT 1
45260: DEC
45261: ST_TO_ADDR
45262: LD_VAR 0 5
45266: PUSH
45267: FOR_TO
45268: IFFALSE 45315
// begin hc_class := 21 ;
45270: LD_ADDR_OWVAR 28
45274: PUSH
45275: LD_INT 21
45277: ST_TO_ADDR
// hc_gallery :=  ;
45278: LD_ADDR_OWVAR 33
45282: PUSH
45283: LD_STRING 
45285: ST_TO_ADDR
// animal := CreateHuman ;
45286: LD_ADDR_VAR 0 12
45290: PUSH
45291: CALL_OW 44
45295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45296: LD_VAR 0 12
45300: PPUSH
45301: LD_VAR 0 8
45305: PPUSH
45306: LD_INT 0
45308: PPUSH
45309: CALL 47381 0 3
// end ;
45313: GO 45267
45315: POP
45316: POP
// if birds then
45317: LD_VAR 0 1
45321: IFFALSE 45388
// for i = 1 to birds do
45323: LD_ADDR_VAR 0 11
45327: PUSH
45328: DOUBLE
45329: LD_INT 1
45331: DEC
45332: ST_TO_ADDR
45333: LD_VAR 0 1
45337: PUSH
45338: FOR_TO
45339: IFFALSE 45386
// begin hc_class = 18 ;
45341: LD_ADDR_OWVAR 28
45345: PUSH
45346: LD_INT 18
45348: ST_TO_ADDR
// hc_gallery =  ;
45349: LD_ADDR_OWVAR 33
45353: PUSH
45354: LD_STRING 
45356: ST_TO_ADDR
// animal := CreateHuman ;
45357: LD_ADDR_VAR 0 12
45361: PUSH
45362: CALL_OW 44
45366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45367: LD_VAR 0 12
45371: PPUSH
45372: LD_VAR 0 8
45376: PPUSH
45377: LD_INT 0
45379: PPUSH
45380: CALL 47381 0 3
// end ;
45384: GO 45338
45386: POP
45387: POP
// if tigers then
45388: LD_VAR 0 2
45392: IFFALSE 45476
// for i = 1 to tigers do
45394: LD_ADDR_VAR 0 11
45398: PUSH
45399: DOUBLE
45400: LD_INT 1
45402: DEC
45403: ST_TO_ADDR
45404: LD_VAR 0 2
45408: PUSH
45409: FOR_TO
45410: IFFALSE 45474
// begin hc_class = class_tiger ;
45412: LD_ADDR_OWVAR 28
45416: PUSH
45417: LD_INT 14
45419: ST_TO_ADDR
// hc_gallery =  ;
45420: LD_ADDR_OWVAR 33
45424: PUSH
45425: LD_STRING 
45427: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45428: LD_ADDR_OWVAR 35
45432: PUSH
45433: LD_INT 7
45435: NEG
45436: PPUSH
45437: LD_INT 7
45439: PPUSH
45440: CALL_OW 12
45444: ST_TO_ADDR
// animal := CreateHuman ;
45445: LD_ADDR_VAR 0 12
45449: PUSH
45450: CALL_OW 44
45454: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45455: LD_VAR 0 12
45459: PPUSH
45460: LD_VAR 0 8
45464: PPUSH
45465: LD_INT 0
45467: PPUSH
45468: CALL 47381 0 3
// end ;
45472: GO 45409
45474: POP
45475: POP
// if apemans then
45476: LD_VAR 0 3
45480: IFFALSE 45603
// for i = 1 to apemans do
45482: LD_ADDR_VAR 0 11
45486: PUSH
45487: DOUBLE
45488: LD_INT 1
45490: DEC
45491: ST_TO_ADDR
45492: LD_VAR 0 3
45496: PUSH
45497: FOR_TO
45498: IFFALSE 45601
// begin hc_class = class_apeman ;
45500: LD_ADDR_OWVAR 28
45504: PUSH
45505: LD_INT 12
45507: ST_TO_ADDR
// hc_gallery =  ;
45508: LD_ADDR_OWVAR 33
45512: PUSH
45513: LD_STRING 
45515: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45516: LD_ADDR_OWVAR 35
45520: PUSH
45521: LD_INT 2
45523: NEG
45524: PPUSH
45525: LD_INT 2
45527: PPUSH
45528: CALL_OW 12
45532: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45533: LD_ADDR_OWVAR 31
45537: PUSH
45538: LD_INT 1
45540: PPUSH
45541: LD_INT 3
45543: PPUSH
45544: CALL_OW 12
45548: PUSH
45549: LD_INT 1
45551: PPUSH
45552: LD_INT 3
45554: PPUSH
45555: CALL_OW 12
45559: PUSH
45560: LD_INT 0
45562: PUSH
45563: LD_INT 0
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: ST_TO_ADDR
// animal := CreateHuman ;
45572: LD_ADDR_VAR 0 12
45576: PUSH
45577: CALL_OW 44
45581: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45582: LD_VAR 0 12
45586: PPUSH
45587: LD_VAR 0 8
45591: PPUSH
45592: LD_INT 0
45594: PPUSH
45595: CALL 47381 0 3
// end ;
45599: GO 45497
45601: POP
45602: POP
// if enchidnas then
45603: LD_VAR 0 4
45607: IFFALSE 45674
// for i = 1 to enchidnas do
45609: LD_ADDR_VAR 0 11
45613: PUSH
45614: DOUBLE
45615: LD_INT 1
45617: DEC
45618: ST_TO_ADDR
45619: LD_VAR 0 4
45623: PUSH
45624: FOR_TO
45625: IFFALSE 45672
// begin hc_class = 13 ;
45627: LD_ADDR_OWVAR 28
45631: PUSH
45632: LD_INT 13
45634: ST_TO_ADDR
// hc_gallery =  ;
45635: LD_ADDR_OWVAR 33
45639: PUSH
45640: LD_STRING 
45642: ST_TO_ADDR
// animal := CreateHuman ;
45643: LD_ADDR_VAR 0 12
45647: PUSH
45648: CALL_OW 44
45652: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45653: LD_VAR 0 12
45657: PPUSH
45658: LD_VAR 0 8
45662: PPUSH
45663: LD_INT 0
45665: PPUSH
45666: CALL 47381 0 3
// end ;
45670: GO 45624
45672: POP
45673: POP
// if fishes then
45674: LD_VAR 0 7
45678: IFFALSE 45745
// for i = 1 to fishes do
45680: LD_ADDR_VAR 0 11
45684: PUSH
45685: DOUBLE
45686: LD_INT 1
45688: DEC
45689: ST_TO_ADDR
45690: LD_VAR 0 7
45694: PUSH
45695: FOR_TO
45696: IFFALSE 45743
// begin hc_class = 20 ;
45698: LD_ADDR_OWVAR 28
45702: PUSH
45703: LD_INT 20
45705: ST_TO_ADDR
// hc_gallery =  ;
45706: LD_ADDR_OWVAR 33
45710: PUSH
45711: LD_STRING 
45713: ST_TO_ADDR
// animal := CreateHuman ;
45714: LD_ADDR_VAR 0 12
45718: PUSH
45719: CALL_OW 44
45723: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45724: LD_VAR 0 12
45728: PPUSH
45729: LD_VAR 0 9
45733: PPUSH
45734: LD_INT 0
45736: PPUSH
45737: CALL 47381 0 3
// end ;
45741: GO 45695
45743: POP
45744: POP
// end ;
45745: LD_VAR 0 10
45749: RET
// export function WantHeal ( sci , unit ) ; begin
45750: LD_INT 0
45752: PPUSH
// if GetTaskList ( sci ) > 0 then
45753: LD_VAR 0 1
45757: PPUSH
45758: CALL_OW 437
45762: PUSH
45763: LD_INT 0
45765: GREATER
45766: IFFALSE 45836
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45768: LD_VAR 0 1
45772: PPUSH
45773: CALL_OW 437
45777: PUSH
45778: LD_INT 1
45780: ARRAY
45781: PUSH
45782: LD_INT 1
45784: ARRAY
45785: PUSH
45786: LD_STRING l
45788: EQUAL
45789: PUSH
45790: LD_VAR 0 1
45794: PPUSH
45795: CALL_OW 437
45799: PUSH
45800: LD_INT 1
45802: ARRAY
45803: PUSH
45804: LD_INT 4
45806: ARRAY
45807: PUSH
45808: LD_VAR 0 2
45812: EQUAL
45813: AND
45814: IFFALSE 45826
// result := true else
45816: LD_ADDR_VAR 0 3
45820: PUSH
45821: LD_INT 1
45823: ST_TO_ADDR
45824: GO 45834
// result := false ;
45826: LD_ADDR_VAR 0 3
45830: PUSH
45831: LD_INT 0
45833: ST_TO_ADDR
// end else
45834: GO 45844
// result := false ;
45836: LD_ADDR_VAR 0 3
45840: PUSH
45841: LD_INT 0
45843: ST_TO_ADDR
// end ;
45844: LD_VAR 0 3
45848: RET
// export function HealTarget ( sci ) ; begin
45849: LD_INT 0
45851: PPUSH
// if not sci then
45852: LD_VAR 0 1
45856: NOT
45857: IFFALSE 45861
// exit ;
45859: GO 45926
// result := 0 ;
45861: LD_ADDR_VAR 0 2
45865: PUSH
45866: LD_INT 0
45868: ST_TO_ADDR
// if GetTaskList ( sci ) then
45869: LD_VAR 0 1
45873: PPUSH
45874: CALL_OW 437
45878: IFFALSE 45926
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45880: LD_VAR 0 1
45884: PPUSH
45885: CALL_OW 437
45889: PUSH
45890: LD_INT 1
45892: ARRAY
45893: PUSH
45894: LD_INT 1
45896: ARRAY
45897: PUSH
45898: LD_STRING l
45900: EQUAL
45901: IFFALSE 45926
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45903: LD_ADDR_VAR 0 2
45907: PUSH
45908: LD_VAR 0 1
45912: PPUSH
45913: CALL_OW 437
45917: PUSH
45918: LD_INT 1
45920: ARRAY
45921: PUSH
45922: LD_INT 4
45924: ARRAY
45925: ST_TO_ADDR
// end ;
45926: LD_VAR 0 2
45930: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45931: LD_INT 0
45933: PPUSH
45934: PPUSH
45935: PPUSH
45936: PPUSH
// if not base_units then
45937: LD_VAR 0 1
45941: NOT
45942: IFFALSE 45946
// exit ;
45944: GO 46033
// result := false ;
45946: LD_ADDR_VAR 0 2
45950: PUSH
45951: LD_INT 0
45953: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45954: LD_ADDR_VAR 0 5
45958: PUSH
45959: LD_VAR 0 1
45963: PPUSH
45964: LD_INT 21
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PPUSH
45974: CALL_OW 72
45978: ST_TO_ADDR
// if not tmp then
45979: LD_VAR 0 5
45983: NOT
45984: IFFALSE 45988
// exit ;
45986: GO 46033
// for i in tmp do
45988: LD_ADDR_VAR 0 3
45992: PUSH
45993: LD_VAR 0 5
45997: PUSH
45998: FOR_IN
45999: IFFALSE 46031
// begin result := EnemyInRange ( i , 22 ) ;
46001: LD_ADDR_VAR 0 2
46005: PUSH
46006: LD_VAR 0 3
46010: PPUSH
46011: LD_INT 22
46013: PPUSH
46014: CALL 43646 0 2
46018: ST_TO_ADDR
// if result then
46019: LD_VAR 0 2
46023: IFFALSE 46029
// exit ;
46025: POP
46026: POP
46027: GO 46033
// end ;
46029: GO 45998
46031: POP
46032: POP
// end ;
46033: LD_VAR 0 2
46037: RET
// export function FilterByTag ( units , tag ) ; begin
46038: LD_INT 0
46040: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46041: LD_ADDR_VAR 0 3
46045: PUSH
46046: LD_VAR 0 1
46050: PPUSH
46051: LD_INT 120
46053: PUSH
46054: LD_VAR 0 2
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PPUSH
46063: CALL_OW 72
46067: ST_TO_ADDR
// end ;
46068: LD_VAR 0 3
46072: RET
// export function IsDriver ( un ) ; begin
46073: LD_INT 0
46075: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46076: LD_ADDR_VAR 0 2
46080: PUSH
46081: LD_VAR 0 1
46085: PUSH
46086: LD_INT 55
46088: PUSH
46089: EMPTY
46090: LIST
46091: PPUSH
46092: CALL_OW 69
46096: IN
46097: ST_TO_ADDR
// end ;
46098: LD_VAR 0 2
46102: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46103: LD_INT 0
46105: PPUSH
46106: PPUSH
// list := [ ] ;
46107: LD_ADDR_VAR 0 5
46111: PUSH
46112: EMPTY
46113: ST_TO_ADDR
// case d of 0 :
46114: LD_VAR 0 3
46118: PUSH
46119: LD_INT 0
46121: DOUBLE
46122: EQUAL
46123: IFTRUE 46127
46125: GO 46260
46127: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46128: LD_ADDR_VAR 0 5
46132: PUSH
46133: LD_VAR 0 1
46137: PUSH
46138: LD_INT 4
46140: MINUS
46141: PUSH
46142: LD_VAR 0 2
46146: PUSH
46147: LD_INT 4
46149: MINUS
46150: PUSH
46151: LD_INT 2
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: LIST
46158: PUSH
46159: LD_VAR 0 1
46163: PUSH
46164: LD_INT 3
46166: MINUS
46167: PUSH
46168: LD_VAR 0 2
46172: PUSH
46173: LD_INT 1
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: LIST
46180: PUSH
46181: LD_VAR 0 1
46185: PUSH
46186: LD_INT 4
46188: PLUS
46189: PUSH
46190: LD_VAR 0 2
46194: PUSH
46195: LD_INT 4
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: LIST
46202: PUSH
46203: LD_VAR 0 1
46207: PUSH
46208: LD_INT 3
46210: PLUS
46211: PUSH
46212: LD_VAR 0 2
46216: PUSH
46217: LD_INT 3
46219: PLUS
46220: PUSH
46221: LD_INT 5
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: LIST
46228: PUSH
46229: LD_VAR 0 1
46233: PUSH
46234: LD_VAR 0 2
46238: PUSH
46239: LD_INT 4
46241: PLUS
46242: PUSH
46243: LD_INT 0
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: LIST
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: ST_TO_ADDR
// end ; 1 :
46258: GO 46958
46260: LD_INT 1
46262: DOUBLE
46263: EQUAL
46264: IFTRUE 46268
46266: GO 46401
46268: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46269: LD_ADDR_VAR 0 5
46273: PUSH
46274: LD_VAR 0 1
46278: PUSH
46279: LD_VAR 0 2
46283: PUSH
46284: LD_INT 4
46286: MINUS
46287: PUSH
46288: LD_INT 3
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: LIST
46295: PUSH
46296: LD_VAR 0 1
46300: PUSH
46301: LD_INT 3
46303: MINUS
46304: PUSH
46305: LD_VAR 0 2
46309: PUSH
46310: LD_INT 3
46312: MINUS
46313: PUSH
46314: LD_INT 2
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: LIST
46321: PUSH
46322: LD_VAR 0 1
46326: PUSH
46327: LD_INT 4
46329: MINUS
46330: PUSH
46331: LD_VAR 0 2
46335: PUSH
46336: LD_INT 1
46338: PUSH
46339: EMPTY
46340: LIST
46341: LIST
46342: LIST
46343: PUSH
46344: LD_VAR 0 1
46348: PUSH
46349: LD_VAR 0 2
46353: PUSH
46354: LD_INT 3
46356: PLUS
46357: PUSH
46358: LD_INT 0
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: PUSH
46366: LD_VAR 0 1
46370: PUSH
46371: LD_INT 4
46373: PLUS
46374: PUSH
46375: LD_VAR 0 2
46379: PUSH
46380: LD_INT 4
46382: PLUS
46383: PUSH
46384: LD_INT 5
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: LIST
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: ST_TO_ADDR
// end ; 2 :
46399: GO 46958
46401: LD_INT 2
46403: DOUBLE
46404: EQUAL
46405: IFTRUE 46409
46407: GO 46538
46409: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46410: LD_ADDR_VAR 0 5
46414: PUSH
46415: LD_VAR 0 1
46419: PUSH
46420: LD_VAR 0 2
46424: PUSH
46425: LD_INT 3
46427: MINUS
46428: PUSH
46429: LD_INT 3
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: LIST
46436: PUSH
46437: LD_VAR 0 1
46441: PUSH
46442: LD_INT 4
46444: PLUS
46445: PUSH
46446: LD_VAR 0 2
46450: PUSH
46451: LD_INT 4
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: LIST
46458: PUSH
46459: LD_VAR 0 1
46463: PUSH
46464: LD_VAR 0 2
46468: PUSH
46469: LD_INT 4
46471: PLUS
46472: PUSH
46473: LD_INT 0
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: LIST
46480: PUSH
46481: LD_VAR 0 1
46485: PUSH
46486: LD_INT 3
46488: MINUS
46489: PUSH
46490: LD_VAR 0 2
46494: PUSH
46495: LD_INT 1
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: LIST
46502: PUSH
46503: LD_VAR 0 1
46507: PUSH
46508: LD_INT 4
46510: MINUS
46511: PUSH
46512: LD_VAR 0 2
46516: PUSH
46517: LD_INT 4
46519: MINUS
46520: PUSH
46521: LD_INT 2
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: LIST
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: ST_TO_ADDR
// end ; 3 :
46536: GO 46958
46538: LD_INT 3
46540: DOUBLE
46541: EQUAL
46542: IFTRUE 46546
46544: GO 46679
46546: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46547: LD_ADDR_VAR 0 5
46551: PUSH
46552: LD_VAR 0 1
46556: PUSH
46557: LD_INT 3
46559: PLUS
46560: PUSH
46561: LD_VAR 0 2
46565: PUSH
46566: LD_INT 4
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: LIST
46573: PUSH
46574: LD_VAR 0 1
46578: PUSH
46579: LD_INT 4
46581: PLUS
46582: PUSH
46583: LD_VAR 0 2
46587: PUSH
46588: LD_INT 4
46590: PLUS
46591: PUSH
46592: LD_INT 5
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: LIST
46599: PUSH
46600: LD_VAR 0 1
46604: PUSH
46605: LD_INT 4
46607: MINUS
46608: PUSH
46609: LD_VAR 0 2
46613: PUSH
46614: LD_INT 1
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: LIST
46621: PUSH
46622: LD_VAR 0 1
46626: PUSH
46627: LD_VAR 0 2
46631: PUSH
46632: LD_INT 4
46634: MINUS
46635: PUSH
46636: LD_INT 3
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: LIST
46643: PUSH
46644: LD_VAR 0 1
46648: PUSH
46649: LD_INT 3
46651: MINUS
46652: PUSH
46653: LD_VAR 0 2
46657: PUSH
46658: LD_INT 3
46660: MINUS
46661: PUSH
46662: LD_INT 2
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: LIST
46669: PUSH
46670: EMPTY
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: ST_TO_ADDR
// end ; 4 :
46677: GO 46958
46679: LD_INT 4
46681: DOUBLE
46682: EQUAL
46683: IFTRUE 46687
46685: GO 46820
46687: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46688: LD_ADDR_VAR 0 5
46692: PUSH
46693: LD_VAR 0 1
46697: PUSH
46698: LD_VAR 0 2
46702: PUSH
46703: LD_INT 4
46705: PLUS
46706: PUSH
46707: LD_INT 0
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: PUSH
46715: LD_VAR 0 1
46719: PUSH
46720: LD_INT 3
46722: PLUS
46723: PUSH
46724: LD_VAR 0 2
46728: PUSH
46729: LD_INT 3
46731: PLUS
46732: PUSH
46733: LD_INT 5
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: LIST
46740: PUSH
46741: LD_VAR 0 1
46745: PUSH
46746: LD_INT 4
46748: PLUS
46749: PUSH
46750: LD_VAR 0 2
46754: PUSH
46755: LD_INT 4
46757: PUSH
46758: EMPTY
46759: LIST
46760: LIST
46761: LIST
46762: PUSH
46763: LD_VAR 0 1
46767: PUSH
46768: LD_VAR 0 2
46772: PUSH
46773: LD_INT 3
46775: MINUS
46776: PUSH
46777: LD_INT 3
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: LIST
46784: PUSH
46785: LD_VAR 0 1
46789: PUSH
46790: LD_INT 4
46792: MINUS
46793: PUSH
46794: LD_VAR 0 2
46798: PUSH
46799: LD_INT 4
46801: MINUS
46802: PUSH
46803: LD_INT 2
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: LIST
46810: PUSH
46811: EMPTY
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: ST_TO_ADDR
// end ; 5 :
46818: GO 46958
46820: LD_INT 5
46822: DOUBLE
46823: EQUAL
46824: IFTRUE 46828
46826: GO 46957
46828: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46829: LD_ADDR_VAR 0 5
46833: PUSH
46834: LD_VAR 0 1
46838: PUSH
46839: LD_INT 4
46841: MINUS
46842: PUSH
46843: LD_VAR 0 2
46847: PUSH
46848: LD_INT 1
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: LIST
46855: PUSH
46856: LD_VAR 0 1
46860: PUSH
46861: LD_VAR 0 2
46865: PUSH
46866: LD_INT 4
46868: MINUS
46869: PUSH
46870: LD_INT 3
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: LIST
46877: PUSH
46878: LD_VAR 0 1
46882: PUSH
46883: LD_INT 4
46885: PLUS
46886: PUSH
46887: LD_VAR 0 2
46891: PUSH
46892: LD_INT 4
46894: PLUS
46895: PUSH
46896: LD_INT 5
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: LIST
46903: PUSH
46904: LD_VAR 0 1
46908: PUSH
46909: LD_INT 3
46911: PLUS
46912: PUSH
46913: LD_VAR 0 2
46917: PUSH
46918: LD_INT 4
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: LIST
46925: PUSH
46926: LD_VAR 0 1
46930: PUSH
46931: LD_VAR 0 2
46935: PUSH
46936: LD_INT 3
46938: PLUS
46939: PUSH
46940: LD_INT 0
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: ST_TO_ADDR
// end ; end ;
46955: GO 46958
46957: POP
// result := list ;
46958: LD_ADDR_VAR 0 4
46962: PUSH
46963: LD_VAR 0 5
46967: ST_TO_ADDR
// end ;
46968: LD_VAR 0 4
46972: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46973: LD_INT 0
46975: PPUSH
46976: PPUSH
46977: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46978: LD_VAR 0 1
46982: NOT
46983: PUSH
46984: LD_VAR 0 2
46988: PUSH
46989: LD_INT 1
46991: PUSH
46992: LD_INT 2
46994: PUSH
46995: LD_INT 3
46997: PUSH
46998: LD_INT 4
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: IN
47007: NOT
47008: OR
47009: IFFALSE 47013
// exit ;
47011: GO 47105
// tmp := [ ] ;
47013: LD_ADDR_VAR 0 5
47017: PUSH
47018: EMPTY
47019: ST_TO_ADDR
// for i in units do
47020: LD_ADDR_VAR 0 4
47024: PUSH
47025: LD_VAR 0 1
47029: PUSH
47030: FOR_IN
47031: IFFALSE 47074
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
47033: LD_ADDR_VAR 0 5
47037: PUSH
47038: LD_VAR 0 5
47042: PPUSH
47043: LD_VAR 0 5
47047: PUSH
47048: LD_INT 1
47050: PLUS
47051: PPUSH
47052: LD_VAR 0 4
47056: PPUSH
47057: LD_VAR 0 2
47061: PPUSH
47062: CALL_OW 259
47066: PPUSH
47067: CALL_OW 2
47071: ST_TO_ADDR
47072: GO 47030
47074: POP
47075: POP
// if not tmp then
47076: LD_VAR 0 5
47080: NOT
47081: IFFALSE 47085
// exit ;
47083: GO 47105
// result := SortListByListDesc ( units , tmp ) ;
47085: LD_ADDR_VAR 0 3
47089: PUSH
47090: LD_VAR 0 1
47094: PPUSH
47095: LD_VAR 0 5
47099: PPUSH
47100: CALL_OW 77
47104: ST_TO_ADDR
// end ;
47105: LD_VAR 0 3
47109: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47110: LD_INT 0
47112: PPUSH
47113: PPUSH
47114: PPUSH
// result := false ;
47115: LD_ADDR_VAR 0 3
47119: PUSH
47120: LD_INT 0
47122: ST_TO_ADDR
// x := GetX ( building ) ;
47123: LD_ADDR_VAR 0 4
47127: PUSH
47128: LD_VAR 0 2
47132: PPUSH
47133: CALL_OW 250
47137: ST_TO_ADDR
// y := GetY ( building ) ;
47138: LD_ADDR_VAR 0 5
47142: PUSH
47143: LD_VAR 0 2
47147: PPUSH
47148: CALL_OW 251
47152: ST_TO_ADDR
// if not building or not x or not y then
47153: LD_VAR 0 2
47157: NOT
47158: PUSH
47159: LD_VAR 0 4
47163: NOT
47164: OR
47165: PUSH
47166: LD_VAR 0 5
47170: NOT
47171: OR
47172: IFFALSE 47176
// exit ;
47174: GO 47268
// if GetTaskList ( unit ) then
47176: LD_VAR 0 1
47180: PPUSH
47181: CALL_OW 437
47185: IFFALSE 47268
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47187: LD_STRING e
47189: PUSH
47190: LD_VAR 0 1
47194: PPUSH
47195: CALL_OW 437
47199: PUSH
47200: LD_INT 1
47202: ARRAY
47203: PUSH
47204: LD_INT 1
47206: ARRAY
47207: EQUAL
47208: PUSH
47209: LD_VAR 0 4
47213: PUSH
47214: LD_VAR 0 1
47218: PPUSH
47219: CALL_OW 437
47223: PUSH
47224: LD_INT 1
47226: ARRAY
47227: PUSH
47228: LD_INT 2
47230: ARRAY
47231: EQUAL
47232: AND
47233: PUSH
47234: LD_VAR 0 5
47238: PUSH
47239: LD_VAR 0 1
47243: PPUSH
47244: CALL_OW 437
47248: PUSH
47249: LD_INT 1
47251: ARRAY
47252: PUSH
47253: LD_INT 3
47255: ARRAY
47256: EQUAL
47257: AND
47258: IFFALSE 47268
// result := true end ;
47260: LD_ADDR_VAR 0 3
47264: PUSH
47265: LD_INT 1
47267: ST_TO_ADDR
// end ;
47268: LD_VAR 0 3
47272: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47273: LD_INT 0
47275: PPUSH
// result := false ;
47276: LD_ADDR_VAR 0 4
47280: PUSH
47281: LD_INT 0
47283: ST_TO_ADDR
// if GetTaskList ( unit ) then
47284: LD_VAR 0 1
47288: PPUSH
47289: CALL_OW 437
47293: IFFALSE 47376
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47295: LD_STRING M
47297: PUSH
47298: LD_VAR 0 1
47302: PPUSH
47303: CALL_OW 437
47307: PUSH
47308: LD_INT 1
47310: ARRAY
47311: PUSH
47312: LD_INT 1
47314: ARRAY
47315: EQUAL
47316: PUSH
47317: LD_VAR 0 2
47321: PUSH
47322: LD_VAR 0 1
47326: PPUSH
47327: CALL_OW 437
47331: PUSH
47332: LD_INT 1
47334: ARRAY
47335: PUSH
47336: LD_INT 2
47338: ARRAY
47339: EQUAL
47340: AND
47341: PUSH
47342: LD_VAR 0 3
47346: PUSH
47347: LD_VAR 0 1
47351: PPUSH
47352: CALL_OW 437
47356: PUSH
47357: LD_INT 1
47359: ARRAY
47360: PUSH
47361: LD_INT 3
47363: ARRAY
47364: EQUAL
47365: AND
47366: IFFALSE 47376
// result := true ;
47368: LD_ADDR_VAR 0 4
47372: PUSH
47373: LD_INT 1
47375: ST_TO_ADDR
// end ; end ;
47376: LD_VAR 0 4
47380: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47381: LD_INT 0
47383: PPUSH
47384: PPUSH
47385: PPUSH
47386: PPUSH
// if not unit or not area then
47387: LD_VAR 0 1
47391: NOT
47392: PUSH
47393: LD_VAR 0 2
47397: NOT
47398: OR
47399: IFFALSE 47403
// exit ;
47401: GO 47567
// tmp := AreaToList ( area , i ) ;
47403: LD_ADDR_VAR 0 6
47407: PUSH
47408: LD_VAR 0 2
47412: PPUSH
47413: LD_VAR 0 5
47417: PPUSH
47418: CALL_OW 517
47422: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47423: LD_ADDR_VAR 0 5
47427: PUSH
47428: DOUBLE
47429: LD_INT 1
47431: DEC
47432: ST_TO_ADDR
47433: LD_VAR 0 6
47437: PUSH
47438: LD_INT 1
47440: ARRAY
47441: PUSH
47442: FOR_TO
47443: IFFALSE 47565
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47445: LD_ADDR_VAR 0 7
47449: PUSH
47450: LD_VAR 0 6
47454: PUSH
47455: LD_INT 1
47457: ARRAY
47458: PUSH
47459: LD_VAR 0 5
47463: ARRAY
47464: PUSH
47465: LD_VAR 0 6
47469: PUSH
47470: LD_INT 2
47472: ARRAY
47473: PUSH
47474: LD_VAR 0 5
47478: ARRAY
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47484: LD_VAR 0 7
47488: PUSH
47489: LD_INT 1
47491: ARRAY
47492: PPUSH
47493: LD_VAR 0 7
47497: PUSH
47498: LD_INT 2
47500: ARRAY
47501: PPUSH
47502: CALL_OW 428
47506: PUSH
47507: LD_INT 0
47509: EQUAL
47510: IFFALSE 47563
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47512: LD_VAR 0 1
47516: PPUSH
47517: LD_VAR 0 7
47521: PUSH
47522: LD_INT 1
47524: ARRAY
47525: PPUSH
47526: LD_VAR 0 7
47530: PUSH
47531: LD_INT 2
47533: ARRAY
47534: PPUSH
47535: LD_VAR 0 3
47539: PPUSH
47540: CALL_OW 48
// result := IsPlaced ( unit ) ;
47544: LD_ADDR_VAR 0 4
47548: PUSH
47549: LD_VAR 0 1
47553: PPUSH
47554: CALL_OW 305
47558: ST_TO_ADDR
// exit ;
47559: POP
47560: POP
47561: GO 47567
// end ; end ;
47563: GO 47442
47565: POP
47566: POP
// end ;
47567: LD_VAR 0 4
47571: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47572: LD_INT 0
47574: PPUSH
47575: PPUSH
47576: PPUSH
// if not side or side > 8 then
47577: LD_VAR 0 1
47581: NOT
47582: PUSH
47583: LD_VAR 0 1
47587: PUSH
47588: LD_INT 8
47590: GREATER
47591: OR
47592: IFFALSE 47596
// exit ;
47594: GO 47783
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47596: LD_ADDR_VAR 0 4
47600: PUSH
47601: LD_INT 22
47603: PUSH
47604: LD_VAR 0 1
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 21
47615: PUSH
47616: LD_INT 3
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PPUSH
47627: CALL_OW 69
47631: ST_TO_ADDR
// if not tmp then
47632: LD_VAR 0 4
47636: NOT
47637: IFFALSE 47641
// exit ;
47639: GO 47783
// enable_addtolog := true ;
47641: LD_ADDR_OWVAR 81
47645: PUSH
47646: LD_INT 1
47648: ST_TO_ADDR
// AddToLog ( [ ) ;
47649: LD_STRING [
47651: PPUSH
47652: CALL_OW 561
// for i in tmp do
47656: LD_ADDR_VAR 0 3
47660: PUSH
47661: LD_VAR 0 4
47665: PUSH
47666: FOR_IN
47667: IFFALSE 47774
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47669: LD_STRING [
47671: PUSH
47672: LD_VAR 0 3
47676: PPUSH
47677: CALL_OW 266
47681: STR
47682: PUSH
47683: LD_STRING , 
47685: STR
47686: PUSH
47687: LD_VAR 0 3
47691: PPUSH
47692: CALL_OW 250
47696: STR
47697: PUSH
47698: LD_STRING , 
47700: STR
47701: PUSH
47702: LD_VAR 0 3
47706: PPUSH
47707: CALL_OW 251
47711: STR
47712: PUSH
47713: LD_STRING , 
47715: STR
47716: PUSH
47717: LD_VAR 0 3
47721: PPUSH
47722: CALL_OW 254
47726: STR
47727: PUSH
47728: LD_STRING , 
47730: STR
47731: PUSH
47732: LD_VAR 0 3
47736: PPUSH
47737: LD_INT 1
47739: PPUSH
47740: CALL_OW 268
47744: STR
47745: PUSH
47746: LD_STRING , 
47748: STR
47749: PUSH
47750: LD_VAR 0 3
47754: PPUSH
47755: LD_INT 2
47757: PPUSH
47758: CALL_OW 268
47762: STR
47763: PUSH
47764: LD_STRING ],
47766: STR
47767: PPUSH
47768: CALL_OW 561
// end ;
47772: GO 47666
47774: POP
47775: POP
// AddToLog ( ]; ) ;
47776: LD_STRING ];
47778: PPUSH
47779: CALL_OW 561
// end ;
47783: LD_VAR 0 2
47787: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47788: LD_INT 0
47790: PPUSH
47791: PPUSH
47792: PPUSH
47793: PPUSH
47794: PPUSH
// if not area or not rate or not max then
47795: LD_VAR 0 1
47799: NOT
47800: PUSH
47801: LD_VAR 0 2
47805: NOT
47806: OR
47807: PUSH
47808: LD_VAR 0 4
47812: NOT
47813: OR
47814: IFFALSE 47818
// exit ;
47816: GO 48007
// while 1 do
47818: LD_INT 1
47820: IFFALSE 48007
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47822: LD_ADDR_VAR 0 9
47826: PUSH
47827: LD_VAR 0 1
47831: PPUSH
47832: LD_INT 1
47834: PPUSH
47835: CALL_OW 287
47839: PUSH
47840: LD_INT 10
47842: MUL
47843: ST_TO_ADDR
// r := rate / 10 ;
47844: LD_ADDR_VAR 0 7
47848: PUSH
47849: LD_VAR 0 2
47853: PUSH
47854: LD_INT 10
47856: DIVREAL
47857: ST_TO_ADDR
// time := 1 1$00 ;
47858: LD_ADDR_VAR 0 8
47862: PUSH
47863: LD_INT 2100
47865: ST_TO_ADDR
// if amount < min then
47866: LD_VAR 0 9
47870: PUSH
47871: LD_VAR 0 3
47875: LESS
47876: IFFALSE 47894
// r := r * 2 else
47878: LD_ADDR_VAR 0 7
47882: PUSH
47883: LD_VAR 0 7
47887: PUSH
47888: LD_INT 2
47890: MUL
47891: ST_TO_ADDR
47892: GO 47920
// if amount > max then
47894: LD_VAR 0 9
47898: PUSH
47899: LD_VAR 0 4
47903: GREATER
47904: IFFALSE 47920
// r := r / 2 ;
47906: LD_ADDR_VAR 0 7
47910: PUSH
47911: LD_VAR 0 7
47915: PUSH
47916: LD_INT 2
47918: DIVREAL
47919: ST_TO_ADDR
// time := time / r ;
47920: LD_ADDR_VAR 0 8
47924: PUSH
47925: LD_VAR 0 8
47929: PUSH
47930: LD_VAR 0 7
47934: DIVREAL
47935: ST_TO_ADDR
// if time < 0 then
47936: LD_VAR 0 8
47940: PUSH
47941: LD_INT 0
47943: LESS
47944: IFFALSE 47961
// time := time * - 1 ;
47946: LD_ADDR_VAR 0 8
47950: PUSH
47951: LD_VAR 0 8
47955: PUSH
47956: LD_INT 1
47958: NEG
47959: MUL
47960: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47961: LD_VAR 0 8
47965: PUSH
47966: LD_INT 35
47968: PPUSH
47969: LD_INT 875
47971: PPUSH
47972: CALL_OW 12
47976: PLUS
47977: PPUSH
47978: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47982: LD_INT 1
47984: PPUSH
47985: LD_INT 5
47987: PPUSH
47988: CALL_OW 12
47992: PPUSH
47993: LD_VAR 0 1
47997: PPUSH
47998: LD_INT 1
48000: PPUSH
48001: CALL_OW 55
// end ;
48005: GO 47818
// end ;
48007: LD_VAR 0 5
48011: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48012: LD_INT 0
48014: PPUSH
48015: PPUSH
48016: PPUSH
48017: PPUSH
48018: PPUSH
48019: PPUSH
48020: PPUSH
48021: PPUSH
// if not turrets or not factories then
48022: LD_VAR 0 1
48026: NOT
48027: PUSH
48028: LD_VAR 0 2
48032: NOT
48033: OR
48034: IFFALSE 48038
// exit ;
48036: GO 48345
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48038: LD_ADDR_VAR 0 10
48042: PUSH
48043: LD_INT 5
48045: PUSH
48046: LD_INT 6
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 2
48055: PUSH
48056: LD_INT 4
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: LD_INT 3
48065: PUSH
48066: LD_INT 5
48068: PUSH
48069: EMPTY
48070: LIST
48071: LIST
48072: PUSH
48073: EMPTY
48074: LIST
48075: LIST
48076: LIST
48077: PUSH
48078: LD_INT 24
48080: PUSH
48081: LD_INT 25
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: PUSH
48088: LD_INT 23
48090: PUSH
48091: LD_INT 27
48093: PUSH
48094: EMPTY
48095: LIST
48096: LIST
48097: PUSH
48098: EMPTY
48099: LIST
48100: LIST
48101: PUSH
48102: LD_INT 42
48104: PUSH
48105: LD_INT 43
48107: PUSH
48108: EMPTY
48109: LIST
48110: LIST
48111: PUSH
48112: LD_INT 44
48114: PUSH
48115: LD_INT 46
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: PUSH
48122: LD_INT 45
48124: PUSH
48125: LD_INT 47
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: LIST
48136: PUSH
48137: EMPTY
48138: LIST
48139: LIST
48140: LIST
48141: ST_TO_ADDR
// result := [ ] ;
48142: LD_ADDR_VAR 0 3
48146: PUSH
48147: EMPTY
48148: ST_TO_ADDR
// for i in turrets do
48149: LD_ADDR_VAR 0 4
48153: PUSH
48154: LD_VAR 0 1
48158: PUSH
48159: FOR_IN
48160: IFFALSE 48343
// begin nat := GetNation ( i ) ;
48162: LD_ADDR_VAR 0 7
48166: PUSH
48167: LD_VAR 0 4
48171: PPUSH
48172: CALL_OW 248
48176: ST_TO_ADDR
// weapon := 0 ;
48177: LD_ADDR_VAR 0 8
48181: PUSH
48182: LD_INT 0
48184: ST_TO_ADDR
// if not nat then
48185: LD_VAR 0 7
48189: NOT
48190: IFFALSE 48194
// continue ;
48192: GO 48159
// for j in list [ nat ] do
48194: LD_ADDR_VAR 0 5
48198: PUSH
48199: LD_VAR 0 10
48203: PUSH
48204: LD_VAR 0 7
48208: ARRAY
48209: PUSH
48210: FOR_IN
48211: IFFALSE 48252
// if GetBWeapon ( i ) = j [ 1 ] then
48213: LD_VAR 0 4
48217: PPUSH
48218: CALL_OW 269
48222: PUSH
48223: LD_VAR 0 5
48227: PUSH
48228: LD_INT 1
48230: ARRAY
48231: EQUAL
48232: IFFALSE 48250
// begin weapon := j [ 2 ] ;
48234: LD_ADDR_VAR 0 8
48238: PUSH
48239: LD_VAR 0 5
48243: PUSH
48244: LD_INT 2
48246: ARRAY
48247: ST_TO_ADDR
// break ;
48248: GO 48252
// end ;
48250: GO 48210
48252: POP
48253: POP
// if not weapon then
48254: LD_VAR 0 8
48258: NOT
48259: IFFALSE 48263
// continue ;
48261: GO 48159
// for k in factories do
48263: LD_ADDR_VAR 0 6
48267: PUSH
48268: LD_VAR 0 2
48272: PUSH
48273: FOR_IN
48274: IFFALSE 48339
// begin weapons := AvailableWeaponList ( k ) ;
48276: LD_ADDR_VAR 0 9
48280: PUSH
48281: LD_VAR 0 6
48285: PPUSH
48286: CALL_OW 478
48290: ST_TO_ADDR
// if not weapons then
48291: LD_VAR 0 9
48295: NOT
48296: IFFALSE 48300
// continue ;
48298: GO 48273
// if weapon in weapons then
48300: LD_VAR 0 8
48304: PUSH
48305: LD_VAR 0 9
48309: IN
48310: IFFALSE 48337
// begin result := [ i , weapon ] ;
48312: LD_ADDR_VAR 0 3
48316: PUSH
48317: LD_VAR 0 4
48321: PUSH
48322: LD_VAR 0 8
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: ST_TO_ADDR
// exit ;
48331: POP
48332: POP
48333: POP
48334: POP
48335: GO 48345
// end ; end ;
48337: GO 48273
48339: POP
48340: POP
// end ;
48341: GO 48159
48343: POP
48344: POP
// end ;
48345: LD_VAR 0 3
48349: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48350: LD_INT 0
48352: PPUSH
// if not side or side > 8 then
48353: LD_VAR 0 3
48357: NOT
48358: PUSH
48359: LD_VAR 0 3
48363: PUSH
48364: LD_INT 8
48366: GREATER
48367: OR
48368: IFFALSE 48372
// exit ;
48370: GO 48431
// if not range then
48372: LD_VAR 0 4
48376: NOT
48377: IFFALSE 48388
// range := - 12 ;
48379: LD_ADDR_VAR 0 4
48383: PUSH
48384: LD_INT 12
48386: NEG
48387: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48388: LD_VAR 0 1
48392: PPUSH
48393: LD_VAR 0 2
48397: PPUSH
48398: LD_VAR 0 3
48402: PPUSH
48403: LD_VAR 0 4
48407: PPUSH
48408: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48412: LD_VAR 0 1
48416: PPUSH
48417: LD_VAR 0 2
48421: PPUSH
48422: LD_VAR 0 3
48426: PPUSH
48427: CALL_OW 331
// end ;
48431: LD_VAR 0 5
48435: RET
// export function Video ( mode ) ; begin
48436: LD_INT 0
48438: PPUSH
// ingame_video = mode ;
48439: LD_ADDR_OWVAR 52
48443: PUSH
48444: LD_VAR 0 1
48448: ST_TO_ADDR
// interface_hidden = mode ;
48449: LD_ADDR_OWVAR 54
48453: PUSH
48454: LD_VAR 0 1
48458: ST_TO_ADDR
// end ;
48459: LD_VAR 0 2
48463: RET
// export function Join ( array , element ) ; begin
48464: LD_INT 0
48466: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48467: LD_ADDR_VAR 0 3
48471: PUSH
48472: LD_VAR 0 1
48476: PPUSH
48477: LD_VAR 0 1
48481: PUSH
48482: LD_INT 1
48484: PLUS
48485: PPUSH
48486: LD_VAR 0 2
48490: PPUSH
48491: CALL_OW 1
48495: ST_TO_ADDR
// end ;
48496: LD_VAR 0 3
48500: RET
// export function JoinUnion ( array , element ) ; begin
48501: LD_INT 0
48503: PPUSH
// result := array union element ;
48504: LD_ADDR_VAR 0 3
48508: PUSH
48509: LD_VAR 0 1
48513: PUSH
48514: LD_VAR 0 2
48518: UNION
48519: ST_TO_ADDR
// end ;
48520: LD_VAR 0 3
48524: RET
// export function GetBehemoths ( side ) ; begin
48525: LD_INT 0
48527: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48528: LD_ADDR_VAR 0 2
48532: PUSH
48533: LD_INT 22
48535: PUSH
48536: LD_VAR 0 1
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: PUSH
48545: LD_INT 31
48547: PUSH
48548: LD_INT 25
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: PPUSH
48559: CALL_OW 69
48563: ST_TO_ADDR
// end ;
48564: LD_VAR 0 2
48568: RET
// export function Shuffle ( array ) ; var i , index ; begin
48569: LD_INT 0
48571: PPUSH
48572: PPUSH
48573: PPUSH
// result := [ ] ;
48574: LD_ADDR_VAR 0 2
48578: PUSH
48579: EMPTY
48580: ST_TO_ADDR
// if not array then
48581: LD_VAR 0 1
48585: NOT
48586: IFFALSE 48590
// exit ;
48588: GO 48689
// Randomize ;
48590: CALL_OW 10
// for i = array downto 1 do
48594: LD_ADDR_VAR 0 3
48598: PUSH
48599: DOUBLE
48600: LD_VAR 0 1
48604: INC
48605: ST_TO_ADDR
48606: LD_INT 1
48608: PUSH
48609: FOR_DOWNTO
48610: IFFALSE 48687
// begin index := rand ( 1 , array ) ;
48612: LD_ADDR_VAR 0 4
48616: PUSH
48617: LD_INT 1
48619: PPUSH
48620: LD_VAR 0 1
48624: PPUSH
48625: CALL_OW 12
48629: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48630: LD_ADDR_VAR 0 2
48634: PUSH
48635: LD_VAR 0 2
48639: PPUSH
48640: LD_VAR 0 2
48644: PUSH
48645: LD_INT 1
48647: PLUS
48648: PPUSH
48649: LD_VAR 0 1
48653: PUSH
48654: LD_VAR 0 4
48658: ARRAY
48659: PPUSH
48660: CALL_OW 2
48664: ST_TO_ADDR
// array := Delete ( array , index ) ;
48665: LD_ADDR_VAR 0 1
48669: PUSH
48670: LD_VAR 0 1
48674: PPUSH
48675: LD_VAR 0 4
48679: PPUSH
48680: CALL_OW 3
48684: ST_TO_ADDR
// end ;
48685: GO 48609
48687: POP
48688: POP
// end ;
48689: LD_VAR 0 2
48693: RET
// export function GetBaseMaterials ( base ) ; begin
48694: LD_INT 0
48696: PPUSH
// result := [ 0 , 0 , 0 ] ;
48697: LD_ADDR_VAR 0 2
48701: PUSH
48702: LD_INT 0
48704: PUSH
48705: LD_INT 0
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: LIST
48715: ST_TO_ADDR
// if not base then
48716: LD_VAR 0 1
48720: NOT
48721: IFFALSE 48725
// exit ;
48723: GO 48774
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48725: LD_ADDR_VAR 0 2
48729: PUSH
48730: LD_VAR 0 1
48734: PPUSH
48735: LD_INT 1
48737: PPUSH
48738: CALL_OW 275
48742: PUSH
48743: LD_VAR 0 1
48747: PPUSH
48748: LD_INT 2
48750: PPUSH
48751: CALL_OW 275
48755: PUSH
48756: LD_VAR 0 1
48760: PPUSH
48761: LD_INT 3
48763: PPUSH
48764: CALL_OW 275
48768: PUSH
48769: EMPTY
48770: LIST
48771: LIST
48772: LIST
48773: ST_TO_ADDR
// end ;
48774: LD_VAR 0 2
48778: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48779: LD_INT 0
48781: PPUSH
48782: PPUSH
// result := array ;
48783: LD_ADDR_VAR 0 3
48787: PUSH
48788: LD_VAR 0 1
48792: ST_TO_ADDR
// if size >= result then
48793: LD_VAR 0 2
48797: PUSH
48798: LD_VAR 0 3
48802: GREATEREQUAL
48803: IFFALSE 48807
// exit ;
48805: GO 48857
// if size then
48807: LD_VAR 0 2
48811: IFFALSE 48857
// for i := array downto size do
48813: LD_ADDR_VAR 0 4
48817: PUSH
48818: DOUBLE
48819: LD_VAR 0 1
48823: INC
48824: ST_TO_ADDR
48825: LD_VAR 0 2
48829: PUSH
48830: FOR_DOWNTO
48831: IFFALSE 48855
// result := Delete ( result , result ) ;
48833: LD_ADDR_VAR 0 3
48837: PUSH
48838: LD_VAR 0 3
48842: PPUSH
48843: LD_VAR 0 3
48847: PPUSH
48848: CALL_OW 3
48852: ST_TO_ADDR
48853: GO 48830
48855: POP
48856: POP
// end ;
48857: LD_VAR 0 3
48861: RET
// export function ComExit ( unit ) ; var tmp ; begin
48862: LD_INT 0
48864: PPUSH
48865: PPUSH
// if not IsInUnit ( unit ) then
48866: LD_VAR 0 1
48870: PPUSH
48871: CALL_OW 310
48875: NOT
48876: IFFALSE 48880
// exit ;
48878: GO 48940
// tmp := IsInUnit ( unit ) ;
48880: LD_ADDR_VAR 0 3
48884: PUSH
48885: LD_VAR 0 1
48889: PPUSH
48890: CALL_OW 310
48894: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48895: LD_VAR 0 3
48899: PPUSH
48900: CALL_OW 247
48904: PUSH
48905: LD_INT 2
48907: EQUAL
48908: IFFALSE 48921
// ComExitVehicle ( unit ) else
48910: LD_VAR 0 1
48914: PPUSH
48915: CALL_OW 121
48919: GO 48930
// ComExitBuilding ( unit ) ;
48921: LD_VAR 0 1
48925: PPUSH
48926: CALL_OW 122
// result := tmp ;
48930: LD_ADDR_VAR 0 2
48934: PUSH
48935: LD_VAR 0 3
48939: ST_TO_ADDR
// end ;
48940: LD_VAR 0 2
48944: RET
// export function ComExitAll ( units ) ; var i ; begin
48945: LD_INT 0
48947: PPUSH
48948: PPUSH
// if not units then
48949: LD_VAR 0 1
48953: NOT
48954: IFFALSE 48958
// exit ;
48956: GO 48984
// for i in units do
48958: LD_ADDR_VAR 0 3
48962: PUSH
48963: LD_VAR 0 1
48967: PUSH
48968: FOR_IN
48969: IFFALSE 48982
// ComExit ( i ) ;
48971: LD_VAR 0 3
48975: PPUSH
48976: CALL 48862 0 1
48980: GO 48968
48982: POP
48983: POP
// end ;
48984: LD_VAR 0 2
48988: RET
// export function ResetHc ; begin
48989: LD_INT 0
48991: PPUSH
// InitHc ;
48992: CALL_OW 19
// hc_importance := 0 ;
48996: LD_ADDR_OWVAR 32
49000: PUSH
49001: LD_INT 0
49003: ST_TO_ADDR
// end ;
49004: LD_VAR 0 1
49008: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49009: LD_INT 0
49011: PPUSH
49012: PPUSH
49013: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49014: LD_ADDR_VAR 0 6
49018: PUSH
49019: LD_VAR 0 1
49023: PUSH
49024: LD_VAR 0 3
49028: PLUS
49029: PUSH
49030: LD_INT 2
49032: DIV
49033: ST_TO_ADDR
// if _x < 0 then
49034: LD_VAR 0 6
49038: PUSH
49039: LD_INT 0
49041: LESS
49042: IFFALSE 49059
// _x := _x * - 1 ;
49044: LD_ADDR_VAR 0 6
49048: PUSH
49049: LD_VAR 0 6
49053: PUSH
49054: LD_INT 1
49056: NEG
49057: MUL
49058: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49059: LD_ADDR_VAR 0 7
49063: PUSH
49064: LD_VAR 0 2
49068: PUSH
49069: LD_VAR 0 4
49073: PLUS
49074: PUSH
49075: LD_INT 2
49077: DIV
49078: ST_TO_ADDR
// if _y < 0 then
49079: LD_VAR 0 7
49083: PUSH
49084: LD_INT 0
49086: LESS
49087: IFFALSE 49104
// _y := _y * - 1 ;
49089: LD_ADDR_VAR 0 7
49093: PUSH
49094: LD_VAR 0 7
49098: PUSH
49099: LD_INT 1
49101: NEG
49102: MUL
49103: ST_TO_ADDR
// result := [ _x , _y ] ;
49104: LD_ADDR_VAR 0 5
49108: PUSH
49109: LD_VAR 0 6
49113: PUSH
49114: LD_VAR 0 7
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: ST_TO_ADDR
// end ;
49123: LD_VAR 0 5
49127: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49128: LD_INT 0
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
// task := GetTaskList ( unit ) ;
49134: LD_ADDR_VAR 0 7
49138: PUSH
49139: LD_VAR 0 1
49143: PPUSH
49144: CALL_OW 437
49148: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49149: LD_VAR 0 7
49153: NOT
49154: PUSH
49155: LD_VAR 0 1
49159: PPUSH
49160: LD_VAR 0 2
49164: PPUSH
49165: CALL_OW 308
49169: NOT
49170: AND
49171: IFFALSE 49175
// exit ;
49173: GO 49293
// if IsInArea ( unit , area ) then
49175: LD_VAR 0 1
49179: PPUSH
49180: LD_VAR 0 2
49184: PPUSH
49185: CALL_OW 308
49189: IFFALSE 49207
// begin ComMoveToArea ( unit , goAway ) ;
49191: LD_VAR 0 1
49195: PPUSH
49196: LD_VAR 0 3
49200: PPUSH
49201: CALL_OW 113
// exit ;
49205: GO 49293
// end ; if task [ 1 ] [ 1 ] <> M then
49207: LD_VAR 0 7
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: PUSH
49216: LD_INT 1
49218: ARRAY
49219: PUSH
49220: LD_STRING M
49222: NONEQUAL
49223: IFFALSE 49227
// exit ;
49225: GO 49293
// x := task [ 1 ] [ 2 ] ;
49227: LD_ADDR_VAR 0 5
49231: PUSH
49232: LD_VAR 0 7
49236: PUSH
49237: LD_INT 1
49239: ARRAY
49240: PUSH
49241: LD_INT 2
49243: ARRAY
49244: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49245: LD_ADDR_VAR 0 6
49249: PUSH
49250: LD_VAR 0 7
49254: PUSH
49255: LD_INT 1
49257: ARRAY
49258: PUSH
49259: LD_INT 3
49261: ARRAY
49262: ST_TO_ADDR
// if InArea ( x , y , area ) then
49263: LD_VAR 0 5
49267: PPUSH
49268: LD_VAR 0 6
49272: PPUSH
49273: LD_VAR 0 2
49277: PPUSH
49278: CALL_OW 309
49282: IFFALSE 49293
// ComStop ( unit ) ;
49284: LD_VAR 0 1
49288: PPUSH
49289: CALL_OW 141
// end ;
49293: LD_VAR 0 4
49297: RET
// export function Abs ( value ) ; begin
49298: LD_INT 0
49300: PPUSH
// result := value ;
49301: LD_ADDR_VAR 0 2
49305: PUSH
49306: LD_VAR 0 1
49310: ST_TO_ADDR
// if value < 0 then
49311: LD_VAR 0 1
49315: PUSH
49316: LD_INT 0
49318: LESS
49319: IFFALSE 49336
// result := value * - 1 ;
49321: LD_ADDR_VAR 0 2
49325: PUSH
49326: LD_VAR 0 1
49330: PUSH
49331: LD_INT 1
49333: NEG
49334: MUL
49335: ST_TO_ADDR
// end ;
49336: LD_VAR 0 2
49340: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49341: LD_INT 0
49343: PPUSH
49344: PPUSH
49345: PPUSH
49346: PPUSH
49347: PPUSH
49348: PPUSH
49349: PPUSH
49350: PPUSH
// if not unit or not building then
49351: LD_VAR 0 1
49355: NOT
49356: PUSH
49357: LD_VAR 0 2
49361: NOT
49362: OR
49363: IFFALSE 49367
// exit ;
49365: GO 49593
// x := GetX ( building ) ;
49367: LD_ADDR_VAR 0 4
49371: PUSH
49372: LD_VAR 0 2
49376: PPUSH
49377: CALL_OW 250
49381: ST_TO_ADDR
// y := GetY ( building ) ;
49382: LD_ADDR_VAR 0 6
49386: PUSH
49387: LD_VAR 0 2
49391: PPUSH
49392: CALL_OW 251
49396: ST_TO_ADDR
// d := GetDir ( building ) ;
49397: LD_ADDR_VAR 0 8
49401: PUSH
49402: LD_VAR 0 2
49406: PPUSH
49407: CALL_OW 254
49411: ST_TO_ADDR
// r := 4 ;
49412: LD_ADDR_VAR 0 9
49416: PUSH
49417: LD_INT 4
49419: ST_TO_ADDR
// for i := 1 to 5 do
49420: LD_ADDR_VAR 0 10
49424: PUSH
49425: DOUBLE
49426: LD_INT 1
49428: DEC
49429: ST_TO_ADDR
49430: LD_INT 5
49432: PUSH
49433: FOR_TO
49434: IFFALSE 49591
// begin _x := ShiftX ( x , d , r + i ) ;
49436: LD_ADDR_VAR 0 5
49440: PUSH
49441: LD_VAR 0 4
49445: PPUSH
49446: LD_VAR 0 8
49450: PPUSH
49451: LD_VAR 0 9
49455: PUSH
49456: LD_VAR 0 10
49460: PLUS
49461: PPUSH
49462: CALL_OW 272
49466: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49467: LD_ADDR_VAR 0 7
49471: PUSH
49472: LD_VAR 0 6
49476: PPUSH
49477: LD_VAR 0 8
49481: PPUSH
49482: LD_VAR 0 9
49486: PUSH
49487: LD_VAR 0 10
49491: PLUS
49492: PPUSH
49493: CALL_OW 273
49497: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49498: LD_VAR 0 5
49502: PPUSH
49503: LD_VAR 0 7
49507: PPUSH
49508: CALL_OW 488
49512: PUSH
49513: LD_VAR 0 5
49517: PPUSH
49518: LD_VAR 0 7
49522: PPUSH
49523: CALL_OW 428
49527: PPUSH
49528: CALL_OW 247
49532: PUSH
49533: LD_INT 3
49535: PUSH
49536: LD_INT 2
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: IN
49543: NOT
49544: AND
49545: IFFALSE 49589
// begin ComMoveXY ( unit , _x , _y ) ;
49547: LD_VAR 0 1
49551: PPUSH
49552: LD_VAR 0 5
49556: PPUSH
49557: LD_VAR 0 7
49561: PPUSH
49562: CALL_OW 111
// result := [ _x , _y ] ;
49566: LD_ADDR_VAR 0 3
49570: PUSH
49571: LD_VAR 0 5
49575: PUSH
49576: LD_VAR 0 7
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: ST_TO_ADDR
// exit ;
49585: POP
49586: POP
49587: GO 49593
// end ; end ;
49589: GO 49433
49591: POP
49592: POP
// end ;
49593: LD_VAR 0 3
49597: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49598: LD_INT 0
49600: PPUSH
49601: PPUSH
49602: PPUSH
// result := 0 ;
49603: LD_ADDR_VAR 0 3
49607: PUSH
49608: LD_INT 0
49610: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49611: LD_VAR 0 1
49615: PUSH
49616: LD_INT 0
49618: LESS
49619: PUSH
49620: LD_VAR 0 1
49624: PUSH
49625: LD_INT 8
49627: GREATER
49628: OR
49629: PUSH
49630: LD_VAR 0 2
49634: PUSH
49635: LD_INT 0
49637: LESS
49638: OR
49639: PUSH
49640: LD_VAR 0 2
49644: PUSH
49645: LD_INT 8
49647: GREATER
49648: OR
49649: IFFALSE 49653
// exit ;
49651: GO 49728
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49653: LD_ADDR_VAR 0 4
49657: PUSH
49658: LD_INT 22
49660: PUSH
49661: LD_VAR 0 2
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PPUSH
49670: CALL_OW 69
49674: PUSH
49675: FOR_IN
49676: IFFALSE 49726
// begin un := UnitShoot ( i ) ;
49678: LD_ADDR_VAR 0 5
49682: PUSH
49683: LD_VAR 0 4
49687: PPUSH
49688: CALL_OW 504
49692: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49693: LD_VAR 0 5
49697: PPUSH
49698: CALL_OW 255
49702: PUSH
49703: LD_VAR 0 1
49707: EQUAL
49708: IFFALSE 49724
// begin result := un ;
49710: LD_ADDR_VAR 0 3
49714: PUSH
49715: LD_VAR 0 5
49719: ST_TO_ADDR
// exit ;
49720: POP
49721: POP
49722: GO 49728
// end ; end ;
49724: GO 49675
49726: POP
49727: POP
// end ;
49728: LD_VAR 0 3
49732: RET
// export function GetCargoBay ( units ) ; begin
49733: LD_INT 0
49735: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49736: LD_ADDR_VAR 0 2
49740: PUSH
49741: LD_VAR 0 1
49745: PPUSH
49746: LD_INT 2
49748: PUSH
49749: LD_INT 34
49751: PUSH
49752: LD_INT 12
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: LD_INT 34
49761: PUSH
49762: LD_INT 51
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 34
49771: PUSH
49772: LD_INT 32
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: LD_INT 34
49781: PUSH
49782: LD_INT 89
49784: PUSH
49785: EMPTY
49786: LIST
49787: LIST
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: PPUSH
49796: CALL_OW 72
49800: ST_TO_ADDR
// end ;
49801: LD_VAR 0 2
49805: RET
// export function Negate ( value ) ; begin
49806: LD_INT 0
49808: PPUSH
// result := not value ;
49809: LD_ADDR_VAR 0 2
49813: PUSH
49814: LD_VAR 0 1
49818: NOT
49819: ST_TO_ADDR
// end ;
49820: LD_VAR 0 2
49824: RET
// export function Inc ( value ) ; begin
49825: LD_INT 0
49827: PPUSH
// result := value + 1 ;
49828: LD_ADDR_VAR 0 2
49832: PUSH
49833: LD_VAR 0 1
49837: PUSH
49838: LD_INT 1
49840: PLUS
49841: ST_TO_ADDR
// end ;
49842: LD_VAR 0 2
49846: RET
// export function Dec ( value ) ; begin
49847: LD_INT 0
49849: PPUSH
// result := value - 1 ;
49850: LD_ADDR_VAR 0 2
49854: PUSH
49855: LD_VAR 0 1
49859: PUSH
49860: LD_INT 1
49862: MINUS
49863: ST_TO_ADDR
// end ;
49864: LD_VAR 0 2
49868: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49869: LD_INT 0
49871: PPUSH
49872: PPUSH
49873: PPUSH
49874: PPUSH
49875: PPUSH
49876: PPUSH
49877: PPUSH
49878: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49879: LD_VAR 0 1
49883: PPUSH
49884: LD_VAR 0 2
49888: PPUSH
49889: CALL_OW 488
49893: NOT
49894: PUSH
49895: LD_VAR 0 3
49899: PPUSH
49900: LD_VAR 0 4
49904: PPUSH
49905: CALL_OW 488
49909: NOT
49910: OR
49911: IFFALSE 49924
// begin result := - 1 ;
49913: LD_ADDR_VAR 0 5
49917: PUSH
49918: LD_INT 1
49920: NEG
49921: ST_TO_ADDR
// exit ;
49922: GO 50159
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49924: LD_ADDR_VAR 0 12
49928: PUSH
49929: LD_VAR 0 1
49933: PPUSH
49934: LD_VAR 0 2
49938: PPUSH
49939: LD_VAR 0 3
49943: PPUSH
49944: LD_VAR 0 4
49948: PPUSH
49949: CALL 49009 0 4
49953: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49954: LD_ADDR_VAR 0 11
49958: PUSH
49959: LD_VAR 0 1
49963: PPUSH
49964: LD_VAR 0 2
49968: PPUSH
49969: LD_VAR 0 12
49973: PUSH
49974: LD_INT 1
49976: ARRAY
49977: PPUSH
49978: LD_VAR 0 12
49982: PUSH
49983: LD_INT 2
49985: ARRAY
49986: PPUSH
49987: CALL_OW 298
49991: ST_TO_ADDR
// distance := 9999 ;
49992: LD_ADDR_VAR 0 10
49996: PUSH
49997: LD_INT 9999
49999: ST_TO_ADDR
// for i := 0 to 5 do
50000: LD_ADDR_VAR 0 6
50004: PUSH
50005: DOUBLE
50006: LD_INT 0
50008: DEC
50009: ST_TO_ADDR
50010: LD_INT 5
50012: PUSH
50013: FOR_TO
50014: IFFALSE 50157
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50016: LD_ADDR_VAR 0 7
50020: PUSH
50021: LD_VAR 0 1
50025: PPUSH
50026: LD_VAR 0 6
50030: PPUSH
50031: LD_VAR 0 11
50035: PPUSH
50036: CALL_OW 272
50040: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50041: LD_ADDR_VAR 0 8
50045: PUSH
50046: LD_VAR 0 2
50050: PPUSH
50051: LD_VAR 0 6
50055: PPUSH
50056: LD_VAR 0 11
50060: PPUSH
50061: CALL_OW 273
50065: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50066: LD_VAR 0 7
50070: PPUSH
50071: LD_VAR 0 8
50075: PPUSH
50076: CALL_OW 488
50080: NOT
50081: IFFALSE 50085
// continue ;
50083: GO 50013
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50085: LD_ADDR_VAR 0 9
50089: PUSH
50090: LD_VAR 0 12
50094: PUSH
50095: LD_INT 1
50097: ARRAY
50098: PPUSH
50099: LD_VAR 0 12
50103: PUSH
50104: LD_INT 2
50106: ARRAY
50107: PPUSH
50108: LD_VAR 0 7
50112: PPUSH
50113: LD_VAR 0 8
50117: PPUSH
50118: CALL_OW 298
50122: ST_TO_ADDR
// if tmp < distance then
50123: LD_VAR 0 9
50127: PUSH
50128: LD_VAR 0 10
50132: LESS
50133: IFFALSE 50155
// begin result := i ;
50135: LD_ADDR_VAR 0 5
50139: PUSH
50140: LD_VAR 0 6
50144: ST_TO_ADDR
// distance := tmp ;
50145: LD_ADDR_VAR 0 10
50149: PUSH
50150: LD_VAR 0 9
50154: ST_TO_ADDR
// end ; end ;
50155: GO 50013
50157: POP
50158: POP
// end ;
50159: LD_VAR 0 5
50163: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50164: LD_INT 0
50166: PPUSH
50167: PPUSH
// if not driver or not IsInUnit ( driver ) then
50168: LD_VAR 0 1
50172: NOT
50173: PUSH
50174: LD_VAR 0 1
50178: PPUSH
50179: CALL_OW 310
50183: NOT
50184: OR
50185: IFFALSE 50189
// exit ;
50187: GO 50279
// vehicle := IsInUnit ( driver ) ;
50189: LD_ADDR_VAR 0 3
50193: PUSH
50194: LD_VAR 0 1
50198: PPUSH
50199: CALL_OW 310
50203: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50204: LD_VAR 0 1
50208: PPUSH
50209: LD_STRING \
50211: PUSH
50212: LD_INT 0
50214: PUSH
50215: LD_INT 0
50217: PUSH
50218: LD_INT 0
50220: PUSH
50221: LD_INT 0
50223: PUSH
50224: LD_INT 0
50226: PUSH
50227: LD_INT 0
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: LIST
50237: LIST
50238: PUSH
50239: LD_STRING E
50241: PUSH
50242: LD_INT 0
50244: PUSH
50245: LD_INT 0
50247: PUSH
50248: LD_VAR 0 3
50252: PUSH
50253: LD_INT 0
50255: PUSH
50256: LD_INT 0
50258: PUSH
50259: LD_INT 0
50261: PUSH
50262: EMPTY
50263: LIST
50264: LIST
50265: LIST
50266: LIST
50267: LIST
50268: LIST
50269: LIST
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PPUSH
50275: CALL_OW 446
// end ;
50279: LD_VAR 0 2
50283: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50284: LD_INT 0
50286: PPUSH
50287: PPUSH
// if not driver or not IsInUnit ( driver ) then
50288: LD_VAR 0 1
50292: NOT
50293: PUSH
50294: LD_VAR 0 1
50298: PPUSH
50299: CALL_OW 310
50303: NOT
50304: OR
50305: IFFALSE 50309
// exit ;
50307: GO 50399
// vehicle := IsInUnit ( driver ) ;
50309: LD_ADDR_VAR 0 3
50313: PUSH
50314: LD_VAR 0 1
50318: PPUSH
50319: CALL_OW 310
50323: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50324: LD_VAR 0 1
50328: PPUSH
50329: LD_STRING \
50331: PUSH
50332: LD_INT 0
50334: PUSH
50335: LD_INT 0
50337: PUSH
50338: LD_INT 0
50340: PUSH
50341: LD_INT 0
50343: PUSH
50344: LD_INT 0
50346: PUSH
50347: LD_INT 0
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: PUSH
50359: LD_STRING E
50361: PUSH
50362: LD_INT 0
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: LD_VAR 0 3
50372: PUSH
50373: LD_INT 0
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: LD_INT 0
50381: PUSH
50382: EMPTY
50383: LIST
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: LIST
50389: LIST
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: PPUSH
50395: CALL_OW 447
// end ;
50399: LD_VAR 0 2
50403: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50404: LD_INT 0
50406: PPUSH
50407: PPUSH
50408: PPUSH
// tmp := [ ] ;
50409: LD_ADDR_VAR 0 5
50413: PUSH
50414: EMPTY
50415: ST_TO_ADDR
// for i in units do
50416: LD_ADDR_VAR 0 4
50420: PUSH
50421: LD_VAR 0 1
50425: PUSH
50426: FOR_IN
50427: IFFALSE 50465
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50429: LD_ADDR_VAR 0 5
50433: PUSH
50434: LD_VAR 0 5
50438: PPUSH
50439: LD_VAR 0 5
50443: PUSH
50444: LD_INT 1
50446: PLUS
50447: PPUSH
50448: LD_VAR 0 4
50452: PPUSH
50453: CALL_OW 256
50457: PPUSH
50458: CALL_OW 2
50462: ST_TO_ADDR
50463: GO 50426
50465: POP
50466: POP
// if not tmp then
50467: LD_VAR 0 5
50471: NOT
50472: IFFALSE 50476
// exit ;
50474: GO 50524
// if asc then
50476: LD_VAR 0 2
50480: IFFALSE 50504
// result := SortListByListAsc ( units , tmp ) else
50482: LD_ADDR_VAR 0 3
50486: PUSH
50487: LD_VAR 0 1
50491: PPUSH
50492: LD_VAR 0 5
50496: PPUSH
50497: CALL_OW 76
50501: ST_TO_ADDR
50502: GO 50524
// result := SortListByListDesc ( units , tmp ) ;
50504: LD_ADDR_VAR 0 3
50508: PUSH
50509: LD_VAR 0 1
50513: PPUSH
50514: LD_VAR 0 5
50518: PPUSH
50519: CALL_OW 77
50523: ST_TO_ADDR
// end ;
50524: LD_VAR 0 3
50528: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50529: LD_INT 0
50531: PPUSH
50532: PPUSH
// task := GetTaskList ( mech ) ;
50533: LD_ADDR_VAR 0 4
50537: PUSH
50538: LD_VAR 0 1
50542: PPUSH
50543: CALL_OW 437
50547: ST_TO_ADDR
// if not task then
50548: LD_VAR 0 4
50552: NOT
50553: IFFALSE 50557
// exit ;
50555: GO 50599
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50557: LD_ADDR_VAR 0 3
50561: PUSH
50562: LD_VAR 0 4
50566: PUSH
50567: LD_INT 1
50569: ARRAY
50570: PUSH
50571: LD_INT 1
50573: ARRAY
50574: PUSH
50575: LD_STRING r
50577: EQUAL
50578: PUSH
50579: LD_VAR 0 4
50583: PUSH
50584: LD_INT 1
50586: ARRAY
50587: PUSH
50588: LD_INT 4
50590: ARRAY
50591: PUSH
50592: LD_VAR 0 2
50596: EQUAL
50597: AND
50598: ST_TO_ADDR
// end ;
50599: LD_VAR 0 3
50603: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50604: LD_INT 0
50606: PPUSH
// SetDir ( unit , d ) ;
50607: LD_VAR 0 1
50611: PPUSH
50612: LD_VAR 0 4
50616: PPUSH
50617: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50621: LD_VAR 0 1
50625: PPUSH
50626: LD_VAR 0 2
50630: PPUSH
50631: LD_VAR 0 3
50635: PPUSH
50636: LD_VAR 0 5
50640: PPUSH
50641: CALL_OW 48
// end ;
50645: LD_VAR 0 6
50649: RET
// export function ToNaturalNumber ( number ) ; begin
50650: LD_INT 0
50652: PPUSH
// result := number div 1 ;
50653: LD_ADDR_VAR 0 2
50657: PUSH
50658: LD_VAR 0 1
50662: PUSH
50663: LD_INT 1
50665: DIV
50666: ST_TO_ADDR
// if number < 0 then
50667: LD_VAR 0 1
50671: PUSH
50672: LD_INT 0
50674: LESS
50675: IFFALSE 50685
// result := 0 ;
50677: LD_ADDR_VAR 0 2
50681: PUSH
50682: LD_INT 0
50684: ST_TO_ADDR
// end ;
50685: LD_VAR 0 2
50689: RET
// export function SortByClass ( units , class ) ; var un ; begin
50690: LD_INT 0
50692: PPUSH
50693: PPUSH
// if not units or not class then
50694: LD_VAR 0 1
50698: NOT
50699: PUSH
50700: LD_VAR 0 2
50704: NOT
50705: OR
50706: IFFALSE 50710
// exit ;
50708: GO 50805
// result := [ ] ;
50710: LD_ADDR_VAR 0 3
50714: PUSH
50715: EMPTY
50716: ST_TO_ADDR
// for un in units do
50717: LD_ADDR_VAR 0 4
50721: PUSH
50722: LD_VAR 0 1
50726: PUSH
50727: FOR_IN
50728: IFFALSE 50803
// if GetClass ( un ) = class then
50730: LD_VAR 0 4
50734: PPUSH
50735: CALL_OW 257
50739: PUSH
50740: LD_VAR 0 2
50744: EQUAL
50745: IFFALSE 50772
// result := Insert ( result , 1 , un ) else
50747: LD_ADDR_VAR 0 3
50751: PUSH
50752: LD_VAR 0 3
50756: PPUSH
50757: LD_INT 1
50759: PPUSH
50760: LD_VAR 0 4
50764: PPUSH
50765: CALL_OW 2
50769: ST_TO_ADDR
50770: GO 50801
// result := Replace ( result , result + 1 , un ) ;
50772: LD_ADDR_VAR 0 3
50776: PUSH
50777: LD_VAR 0 3
50781: PPUSH
50782: LD_VAR 0 3
50786: PUSH
50787: LD_INT 1
50789: PLUS
50790: PPUSH
50791: LD_VAR 0 4
50795: PPUSH
50796: CALL_OW 1
50800: ST_TO_ADDR
50801: GO 50727
50803: POP
50804: POP
// end ;
50805: LD_VAR 0 3
50809: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
50814: PPUSH
50815: PPUSH
50816: PPUSH
50817: PPUSH
50818: PPUSH
// result := [ ] ;
50819: LD_ADDR_VAR 0 4
50823: PUSH
50824: EMPTY
50825: ST_TO_ADDR
// if x - r < 0 then
50826: LD_VAR 0 1
50830: PUSH
50831: LD_VAR 0 3
50835: MINUS
50836: PUSH
50837: LD_INT 0
50839: LESS
50840: IFFALSE 50852
// min_x := 0 else
50842: LD_ADDR_VAR 0 8
50846: PUSH
50847: LD_INT 0
50849: ST_TO_ADDR
50850: GO 50868
// min_x := x - r ;
50852: LD_ADDR_VAR 0 8
50856: PUSH
50857: LD_VAR 0 1
50861: PUSH
50862: LD_VAR 0 3
50866: MINUS
50867: ST_TO_ADDR
// if y - r < 0 then
50868: LD_VAR 0 2
50872: PUSH
50873: LD_VAR 0 3
50877: MINUS
50878: PUSH
50879: LD_INT 0
50881: LESS
50882: IFFALSE 50894
// min_y := 0 else
50884: LD_ADDR_VAR 0 7
50888: PUSH
50889: LD_INT 0
50891: ST_TO_ADDR
50892: GO 50910
// min_y := y - r ;
50894: LD_ADDR_VAR 0 7
50898: PUSH
50899: LD_VAR 0 2
50903: PUSH
50904: LD_VAR 0 3
50908: MINUS
50909: ST_TO_ADDR
// max_x := x + r ;
50910: LD_ADDR_VAR 0 9
50914: PUSH
50915: LD_VAR 0 1
50919: PUSH
50920: LD_VAR 0 3
50924: PLUS
50925: ST_TO_ADDR
// max_y := y + r ;
50926: LD_ADDR_VAR 0 10
50930: PUSH
50931: LD_VAR 0 2
50935: PUSH
50936: LD_VAR 0 3
50940: PLUS
50941: ST_TO_ADDR
// for _x = min_x to max_x do
50942: LD_ADDR_VAR 0 5
50946: PUSH
50947: DOUBLE
50948: LD_VAR 0 8
50952: DEC
50953: ST_TO_ADDR
50954: LD_VAR 0 9
50958: PUSH
50959: FOR_TO
50960: IFFALSE 51061
// for _y = min_y to max_y do
50962: LD_ADDR_VAR 0 6
50966: PUSH
50967: DOUBLE
50968: LD_VAR 0 7
50972: DEC
50973: ST_TO_ADDR
50974: LD_VAR 0 10
50978: PUSH
50979: FOR_TO
50980: IFFALSE 51057
// begin if not ValidHex ( _x , _y ) then
50982: LD_VAR 0 5
50986: PPUSH
50987: LD_VAR 0 6
50991: PPUSH
50992: CALL_OW 488
50996: NOT
50997: IFFALSE 51001
// continue ;
50999: GO 50979
// if GetResourceTypeXY ( _x , _y ) then
51001: LD_VAR 0 5
51005: PPUSH
51006: LD_VAR 0 6
51010: PPUSH
51011: CALL_OW 283
51015: IFFALSE 51055
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
51017: LD_ADDR_VAR 0 4
51021: PUSH
51022: LD_VAR 0 4
51026: PPUSH
51027: LD_VAR 0 4
51031: PUSH
51032: LD_INT 1
51034: PLUS
51035: PPUSH
51036: LD_VAR 0 5
51040: PUSH
51041: LD_VAR 0 6
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: PPUSH
51050: CALL_OW 1
51054: ST_TO_ADDR
// end ;
51055: GO 50979
51057: POP
51058: POP
51059: GO 50959
51061: POP
51062: POP
// end ;
51063: LD_VAR 0 4
51067: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51068: LD_INT 0
51070: PPUSH
51071: PPUSH
51072: PPUSH
51073: PPUSH
51074: PPUSH
51075: PPUSH
51076: PPUSH
51077: PPUSH
// if not units then
51078: LD_VAR 0 1
51082: NOT
51083: IFFALSE 51087
// exit ;
51085: GO 51611
// result := UnitFilter ( units , [ f_ok ] ) ;
51087: LD_ADDR_VAR 0 3
51091: PUSH
51092: LD_VAR 0 1
51096: PPUSH
51097: LD_INT 50
51099: PUSH
51100: EMPTY
51101: LIST
51102: PPUSH
51103: CALL_OW 72
51107: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51108: LD_ADDR_VAR 0 8
51112: PUSH
51113: LD_VAR 0 1
51117: PUSH
51118: LD_INT 1
51120: ARRAY
51121: PPUSH
51122: CALL_OW 255
51126: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51127: LD_ADDR_VAR 0 10
51131: PUSH
51132: LD_INT 29
51134: PUSH
51135: LD_INT 91
51137: PUSH
51138: LD_INT 49
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: LIST
51145: ST_TO_ADDR
// if not result then
51146: LD_VAR 0 3
51150: NOT
51151: IFFALSE 51155
// exit ;
51153: GO 51611
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51155: LD_ADDR_VAR 0 5
51159: PUSH
51160: LD_INT 81
51162: PUSH
51163: LD_VAR 0 8
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PPUSH
51172: CALL_OW 69
51176: ST_TO_ADDR
// for i in result do
51177: LD_ADDR_VAR 0 4
51181: PUSH
51182: LD_VAR 0 3
51186: PUSH
51187: FOR_IN
51188: IFFALSE 51609
// begin tag := GetTag ( i ) + 1 ;
51190: LD_ADDR_VAR 0 9
51194: PUSH
51195: LD_VAR 0 4
51199: PPUSH
51200: CALL_OW 110
51204: PUSH
51205: LD_INT 1
51207: PLUS
51208: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51209: LD_ADDR_VAR 0 7
51213: PUSH
51214: LD_VAR 0 4
51218: PPUSH
51219: CALL_OW 250
51223: PPUSH
51224: LD_VAR 0 4
51228: PPUSH
51229: CALL_OW 251
51233: PPUSH
51234: LD_INT 6
51236: PPUSH
51237: CALL 50810 0 3
51241: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51242: LD_VAR 0 4
51246: PPUSH
51247: CALL_OW 247
51251: PUSH
51252: LD_INT 2
51254: EQUAL
51255: PUSH
51256: LD_VAR 0 7
51260: AND
51261: PUSH
51262: LD_VAR 0 4
51266: PPUSH
51267: CALL_OW 264
51271: PUSH
51272: LD_VAR 0 10
51276: IN
51277: NOT
51278: AND
51279: IFFALSE 51318
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51281: LD_VAR 0 4
51285: PPUSH
51286: LD_VAR 0 7
51290: PUSH
51291: LD_INT 1
51293: ARRAY
51294: PUSH
51295: LD_INT 1
51297: ARRAY
51298: PPUSH
51299: LD_VAR 0 7
51303: PUSH
51304: LD_INT 1
51306: ARRAY
51307: PUSH
51308: LD_INT 2
51310: ARRAY
51311: PPUSH
51312: CALL_OW 116
51316: GO 51607
// if path > tag then
51318: LD_VAR 0 2
51322: PUSH
51323: LD_VAR 0 9
51327: GREATER
51328: IFFALSE 51536
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51330: LD_ADDR_VAR 0 6
51334: PUSH
51335: LD_VAR 0 5
51339: PPUSH
51340: LD_INT 91
51342: PUSH
51343: LD_VAR 0 4
51347: PUSH
51348: LD_INT 8
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: LIST
51355: PPUSH
51356: CALL_OW 72
51360: ST_TO_ADDR
// if nearEnemy then
51361: LD_VAR 0 6
51365: IFFALSE 51434
// begin if GetWeapon ( i ) = ru_time_lapser then
51367: LD_VAR 0 4
51371: PPUSH
51372: CALL_OW 264
51376: PUSH
51377: LD_INT 49
51379: EQUAL
51380: IFFALSE 51408
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51382: LD_VAR 0 4
51386: PPUSH
51387: LD_VAR 0 6
51391: PPUSH
51392: LD_VAR 0 4
51396: PPUSH
51397: CALL_OW 74
51401: PPUSH
51402: CALL_OW 112
51406: GO 51432
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51408: LD_VAR 0 4
51412: PPUSH
51413: LD_VAR 0 6
51417: PPUSH
51418: LD_VAR 0 4
51422: PPUSH
51423: CALL_OW 74
51427: PPUSH
51428: CALL_OW 115
// end else
51432: GO 51534
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51434: LD_VAR 0 4
51438: PPUSH
51439: LD_VAR 0 2
51443: PUSH
51444: LD_VAR 0 9
51448: ARRAY
51449: PUSH
51450: LD_INT 1
51452: ARRAY
51453: PPUSH
51454: LD_VAR 0 2
51458: PUSH
51459: LD_VAR 0 9
51463: ARRAY
51464: PUSH
51465: LD_INT 2
51467: ARRAY
51468: PPUSH
51469: CALL_OW 297
51473: PUSH
51474: LD_INT 6
51476: GREATER
51477: IFFALSE 51520
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51479: LD_VAR 0 4
51483: PPUSH
51484: LD_VAR 0 2
51488: PUSH
51489: LD_VAR 0 9
51493: ARRAY
51494: PUSH
51495: LD_INT 1
51497: ARRAY
51498: PPUSH
51499: LD_VAR 0 2
51503: PUSH
51504: LD_VAR 0 9
51508: ARRAY
51509: PUSH
51510: LD_INT 2
51512: ARRAY
51513: PPUSH
51514: CALL_OW 114
51518: GO 51534
// SetTag ( i , tag ) ;
51520: LD_VAR 0 4
51524: PPUSH
51525: LD_VAR 0 9
51529: PPUSH
51530: CALL_OW 109
// end else
51534: GO 51607
// if enemy then
51536: LD_VAR 0 5
51540: IFFALSE 51607
// begin if GetWeapon ( i ) = ru_time_lapser then
51542: LD_VAR 0 4
51546: PPUSH
51547: CALL_OW 264
51551: PUSH
51552: LD_INT 49
51554: EQUAL
51555: IFFALSE 51583
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51557: LD_VAR 0 4
51561: PPUSH
51562: LD_VAR 0 5
51566: PPUSH
51567: LD_VAR 0 4
51571: PPUSH
51572: CALL_OW 74
51576: PPUSH
51577: CALL_OW 112
51581: GO 51607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51583: LD_VAR 0 4
51587: PPUSH
51588: LD_VAR 0 5
51592: PPUSH
51593: LD_VAR 0 4
51597: PPUSH
51598: CALL_OW 74
51602: PPUSH
51603: CALL_OW 115
// end ; end ;
51607: GO 51187
51609: POP
51610: POP
// end ;
51611: LD_VAR 0 3
51615: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51616: LD_INT 0
51618: PPUSH
51619: PPUSH
51620: PPUSH
// if not unit or IsInUnit ( unit ) then
51621: LD_VAR 0 1
51625: NOT
51626: PUSH
51627: LD_VAR 0 1
51631: PPUSH
51632: CALL_OW 310
51636: OR
51637: IFFALSE 51641
// exit ;
51639: GO 51732
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51641: LD_ADDR_VAR 0 4
51645: PUSH
51646: LD_VAR 0 1
51650: PPUSH
51651: CALL_OW 250
51655: PPUSH
51656: LD_VAR 0 2
51660: PPUSH
51661: LD_INT 1
51663: PPUSH
51664: CALL_OW 272
51668: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51669: LD_ADDR_VAR 0 5
51673: PUSH
51674: LD_VAR 0 1
51678: PPUSH
51679: CALL_OW 251
51683: PPUSH
51684: LD_VAR 0 2
51688: PPUSH
51689: LD_INT 1
51691: PPUSH
51692: CALL_OW 273
51696: ST_TO_ADDR
// if ValidHex ( x , y ) then
51697: LD_VAR 0 4
51701: PPUSH
51702: LD_VAR 0 5
51706: PPUSH
51707: CALL_OW 488
51711: IFFALSE 51732
// ComTurnXY ( unit , x , y ) ;
51713: LD_VAR 0 1
51717: PPUSH
51718: LD_VAR 0 4
51722: PPUSH
51723: LD_VAR 0 5
51727: PPUSH
51728: CALL_OW 118
// end ;
51732: LD_VAR 0 3
51736: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51737: LD_INT 0
51739: PPUSH
51740: PPUSH
// result := false ;
51741: LD_ADDR_VAR 0 3
51745: PUSH
51746: LD_INT 0
51748: ST_TO_ADDR
// if not units then
51749: LD_VAR 0 2
51753: NOT
51754: IFFALSE 51758
// exit ;
51756: GO 51803
// for i in units do
51758: LD_ADDR_VAR 0 4
51762: PUSH
51763: LD_VAR 0 2
51767: PUSH
51768: FOR_IN
51769: IFFALSE 51801
// if See ( side , i ) then
51771: LD_VAR 0 1
51775: PPUSH
51776: LD_VAR 0 4
51780: PPUSH
51781: CALL_OW 292
51785: IFFALSE 51799
// begin result := true ;
51787: LD_ADDR_VAR 0 3
51791: PUSH
51792: LD_INT 1
51794: ST_TO_ADDR
// exit ;
51795: POP
51796: POP
51797: GO 51803
// end ;
51799: GO 51768
51801: POP
51802: POP
// end ;
51803: LD_VAR 0 3
51807: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51808: LD_INT 0
51810: PPUSH
51811: PPUSH
51812: PPUSH
51813: PPUSH
// if not unit or not points then
51814: LD_VAR 0 1
51818: NOT
51819: PUSH
51820: LD_VAR 0 2
51824: NOT
51825: OR
51826: IFFALSE 51830
// exit ;
51828: GO 51920
// dist := 99999 ;
51830: LD_ADDR_VAR 0 5
51834: PUSH
51835: LD_INT 99999
51837: ST_TO_ADDR
// for i in points do
51838: LD_ADDR_VAR 0 4
51842: PUSH
51843: LD_VAR 0 2
51847: PUSH
51848: FOR_IN
51849: IFFALSE 51918
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51851: LD_ADDR_VAR 0 6
51855: PUSH
51856: LD_VAR 0 1
51860: PPUSH
51861: LD_VAR 0 4
51865: PUSH
51866: LD_INT 1
51868: ARRAY
51869: PPUSH
51870: LD_VAR 0 4
51874: PUSH
51875: LD_INT 2
51877: ARRAY
51878: PPUSH
51879: CALL_OW 297
51883: ST_TO_ADDR
// if tmpDist < dist then
51884: LD_VAR 0 6
51888: PUSH
51889: LD_VAR 0 5
51893: LESS
51894: IFFALSE 51916
// begin result := i ;
51896: LD_ADDR_VAR 0 3
51900: PUSH
51901: LD_VAR 0 4
51905: ST_TO_ADDR
// dist := tmpDist ;
51906: LD_ADDR_VAR 0 5
51910: PUSH
51911: LD_VAR 0 6
51915: ST_TO_ADDR
// end ; end ;
51916: GO 51848
51918: POP
51919: POP
// end ;
51920: LD_VAR 0 3
51924: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51925: LD_INT 0
51927: PPUSH
// uc_side := side ;
51928: LD_ADDR_OWVAR 20
51932: PUSH
51933: LD_VAR 0 1
51937: ST_TO_ADDR
// uc_nation := 3 ;
51938: LD_ADDR_OWVAR 21
51942: PUSH
51943: LD_INT 3
51945: ST_TO_ADDR
// vc_chassis := 25 ;
51946: LD_ADDR_OWVAR 37
51950: PUSH
51951: LD_INT 25
51953: ST_TO_ADDR
// vc_engine := engine_siberite ;
51954: LD_ADDR_OWVAR 39
51958: PUSH
51959: LD_INT 3
51961: ST_TO_ADDR
// vc_control := control_computer ;
51962: LD_ADDR_OWVAR 38
51966: PUSH
51967: LD_INT 3
51969: ST_TO_ADDR
// vc_weapon := 59 ;
51970: LD_ADDR_OWVAR 40
51974: PUSH
51975: LD_INT 59
51977: ST_TO_ADDR
// result := CreateVehicle ;
51978: LD_ADDR_VAR 0 5
51982: PUSH
51983: CALL_OW 45
51987: ST_TO_ADDR
// SetDir ( result , d ) ;
51988: LD_VAR 0 5
51992: PPUSH
51993: LD_VAR 0 4
51997: PPUSH
51998: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
52002: LD_VAR 0 5
52006: PPUSH
52007: LD_VAR 0 2
52011: PPUSH
52012: LD_VAR 0 3
52016: PPUSH
52017: LD_INT 0
52019: PPUSH
52020: CALL_OW 48
// end ;
52024: LD_VAR 0 5
52028: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52029: LD_INT 0
52031: PPUSH
52032: PPUSH
52033: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52034: LD_ADDR_VAR 0 2
52038: PUSH
52039: LD_INT 0
52041: PUSH
52042: LD_INT 0
52044: PUSH
52045: LD_INT 0
52047: PUSH
52048: LD_INT 0
52050: PUSH
52051: EMPTY
52052: LIST
52053: LIST
52054: LIST
52055: LIST
52056: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52057: LD_VAR 0 1
52061: NOT
52062: PUSH
52063: LD_VAR 0 1
52067: PPUSH
52068: CALL_OW 264
52072: PUSH
52073: LD_INT 12
52075: PUSH
52076: LD_INT 51
52078: PUSH
52079: LD_INT 32
52081: PUSH
52082: LD_INT 89
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: LIST
52089: LIST
52090: IN
52091: NOT
52092: OR
52093: IFFALSE 52097
// exit ;
52095: GO 52195
// for i := 1 to 3 do
52097: LD_ADDR_VAR 0 3
52101: PUSH
52102: DOUBLE
52103: LD_INT 1
52105: DEC
52106: ST_TO_ADDR
52107: LD_INT 3
52109: PUSH
52110: FOR_TO
52111: IFFALSE 52193
// begin tmp := GetCargo ( cargo , i ) ;
52113: LD_ADDR_VAR 0 4
52117: PUSH
52118: LD_VAR 0 1
52122: PPUSH
52123: LD_VAR 0 3
52127: PPUSH
52128: CALL_OW 289
52132: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52133: LD_ADDR_VAR 0 2
52137: PUSH
52138: LD_VAR 0 2
52142: PPUSH
52143: LD_VAR 0 3
52147: PPUSH
52148: LD_VAR 0 4
52152: PPUSH
52153: CALL_OW 1
52157: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52158: LD_ADDR_VAR 0 2
52162: PUSH
52163: LD_VAR 0 2
52167: PPUSH
52168: LD_INT 4
52170: PPUSH
52171: LD_VAR 0 2
52175: PUSH
52176: LD_INT 4
52178: ARRAY
52179: PUSH
52180: LD_VAR 0 4
52184: PLUS
52185: PPUSH
52186: CALL_OW 1
52190: ST_TO_ADDR
// end ;
52191: GO 52110
52193: POP
52194: POP
// end ;
52195: LD_VAR 0 2
52199: RET
// export function Length ( array ) ; begin
52200: LD_INT 0
52202: PPUSH
// result := array + 0 ;
52203: LD_ADDR_VAR 0 2
52207: PUSH
52208: LD_VAR 0 1
52212: PUSH
52213: LD_INT 0
52215: PLUS
52216: ST_TO_ADDR
// end ;
52217: LD_VAR 0 2
52221: RET
// export function PrepareArray ( array ) ; begin
52222: LD_INT 0
52224: PPUSH
// result := array diff 0 ;
52225: LD_ADDR_VAR 0 2
52229: PUSH
52230: LD_VAR 0 1
52234: PUSH
52235: LD_INT 0
52237: DIFF
52238: ST_TO_ADDR
// if not result [ 1 ] then
52239: LD_VAR 0 2
52243: PUSH
52244: LD_INT 1
52246: ARRAY
52247: NOT
52248: IFFALSE 52268
// result := Delete ( result , 1 ) ;
52250: LD_ADDR_VAR 0 2
52254: PUSH
52255: LD_VAR 0 2
52259: PPUSH
52260: LD_INT 1
52262: PPUSH
52263: CALL_OW 3
52267: ST_TO_ADDR
// end ;
52268: LD_VAR 0 2
52272: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52273: LD_INT 0
52275: PPUSH
52276: PPUSH
52277: PPUSH
52278: PPUSH
// sibRocketRange := 25 ;
52279: LD_ADDR_VAR 0 6
52283: PUSH
52284: LD_INT 25
52286: ST_TO_ADDR
// result := false ;
52287: LD_ADDR_VAR 0 4
52291: PUSH
52292: LD_INT 0
52294: ST_TO_ADDR
// for i := 0 to 5 do
52295: LD_ADDR_VAR 0 5
52299: PUSH
52300: DOUBLE
52301: LD_INT 0
52303: DEC
52304: ST_TO_ADDR
52305: LD_INT 5
52307: PUSH
52308: FOR_TO
52309: IFFALSE 52376
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52311: LD_VAR 0 1
52315: PPUSH
52316: LD_VAR 0 5
52320: PPUSH
52321: LD_VAR 0 6
52325: PPUSH
52326: CALL_OW 272
52330: PPUSH
52331: LD_VAR 0 2
52335: PPUSH
52336: LD_VAR 0 5
52340: PPUSH
52341: LD_VAR 0 6
52345: PPUSH
52346: CALL_OW 273
52350: PPUSH
52351: LD_VAR 0 3
52355: PPUSH
52356: CALL_OW 309
52360: IFFALSE 52374
// begin result := true ;
52362: LD_ADDR_VAR 0 4
52366: PUSH
52367: LD_INT 1
52369: ST_TO_ADDR
// exit ;
52370: POP
52371: POP
52372: GO 52378
// end ;
52374: GO 52308
52376: POP
52377: POP
// end ; end_of_file
52378: LD_VAR 0 4
52382: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52383: LD_INT 0
52385: PPUSH
52386: PPUSH
// skirmish := false ;
52387: LD_ADDR_EXP 21
52391: PUSH
52392: LD_INT 0
52394: ST_TO_ADDR
// debug_mc := false ;
52395: LD_ADDR_EXP 22
52399: PUSH
52400: LD_INT 0
52402: ST_TO_ADDR
// mc_bases := [ ] ;
52403: LD_ADDR_EXP 23
52407: PUSH
52408: EMPTY
52409: ST_TO_ADDR
// mc_sides := [ ] ;
52410: LD_ADDR_EXP 49
52414: PUSH
52415: EMPTY
52416: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52417: LD_ADDR_EXP 24
52421: PUSH
52422: EMPTY
52423: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52424: LD_ADDR_EXP 25
52428: PUSH
52429: EMPTY
52430: ST_TO_ADDR
// mc_need_heal := [ ] ;
52431: LD_ADDR_EXP 26
52435: PUSH
52436: EMPTY
52437: ST_TO_ADDR
// mc_healers := [ ] ;
52438: LD_ADDR_EXP 27
52442: PUSH
52443: EMPTY
52444: ST_TO_ADDR
// mc_build_list := [ ] ;
52445: LD_ADDR_EXP 28
52449: PUSH
52450: EMPTY
52451: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52452: LD_ADDR_EXP 55
52456: PUSH
52457: EMPTY
52458: ST_TO_ADDR
// mc_builders := [ ] ;
52459: LD_ADDR_EXP 29
52463: PUSH
52464: EMPTY
52465: ST_TO_ADDR
// mc_construct_list := [ ] ;
52466: LD_ADDR_EXP 30
52470: PUSH
52471: EMPTY
52472: ST_TO_ADDR
// mc_turret_list := [ ] ;
52473: LD_ADDR_EXP 31
52477: PUSH
52478: EMPTY
52479: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52480: LD_ADDR_EXP 32
52484: PUSH
52485: EMPTY
52486: ST_TO_ADDR
// mc_miners := [ ] ;
52487: LD_ADDR_EXP 37
52491: PUSH
52492: EMPTY
52493: ST_TO_ADDR
// mc_mines := [ ] ;
52494: LD_ADDR_EXP 36
52498: PUSH
52499: EMPTY
52500: ST_TO_ADDR
// mc_minefields := [ ] ;
52501: LD_ADDR_EXP 38
52505: PUSH
52506: EMPTY
52507: ST_TO_ADDR
// mc_crates := [ ] ;
52508: LD_ADDR_EXP 39
52512: PUSH
52513: EMPTY
52514: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52515: LD_ADDR_EXP 40
52519: PUSH
52520: EMPTY
52521: ST_TO_ADDR
// mc_crates_area := [ ] ;
52522: LD_ADDR_EXP 41
52526: PUSH
52527: EMPTY
52528: ST_TO_ADDR
// mc_vehicles := [ ] ;
52529: LD_ADDR_EXP 42
52533: PUSH
52534: EMPTY
52535: ST_TO_ADDR
// mc_attack := [ ] ;
52536: LD_ADDR_EXP 43
52540: PUSH
52541: EMPTY
52542: ST_TO_ADDR
// mc_produce := [ ] ;
52543: LD_ADDR_EXP 44
52547: PUSH
52548: EMPTY
52549: ST_TO_ADDR
// mc_defender := [ ] ;
52550: LD_ADDR_EXP 45
52554: PUSH
52555: EMPTY
52556: ST_TO_ADDR
// mc_parking := [ ] ;
52557: LD_ADDR_EXP 47
52561: PUSH
52562: EMPTY
52563: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52564: LD_ADDR_EXP 33
52568: PUSH
52569: EMPTY
52570: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52571: LD_ADDR_EXP 35
52575: PUSH
52576: EMPTY
52577: ST_TO_ADDR
// mc_scan := [ ] ;
52578: LD_ADDR_EXP 46
52582: PUSH
52583: EMPTY
52584: ST_TO_ADDR
// mc_scan_area := [ ] ;
52585: LD_ADDR_EXP 48
52589: PUSH
52590: EMPTY
52591: ST_TO_ADDR
// mc_tech := [ ] ;
52592: LD_ADDR_EXP 50
52596: PUSH
52597: EMPTY
52598: ST_TO_ADDR
// mc_class := [ ] ;
52599: LD_ADDR_EXP 64
52603: PUSH
52604: EMPTY
52605: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52606: LD_ADDR_EXP 65
52610: PUSH
52611: EMPTY
52612: ST_TO_ADDR
// mc_is_defending := [ ] ;
52613: LD_ADDR_EXP 66
52617: PUSH
52618: EMPTY
52619: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
52620: LD_ADDR_EXP 57
52624: PUSH
52625: EMPTY
52626: ST_TO_ADDR
// end ;
52627: LD_VAR 0 1
52631: RET
// export function MC_Kill ( base ) ; begin
52632: LD_INT 0
52634: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52635: LD_ADDR_EXP 23
52639: PUSH
52640: LD_EXP 23
52644: PPUSH
52645: LD_VAR 0 1
52649: PPUSH
52650: EMPTY
52651: PPUSH
52652: CALL_OW 1
52656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52657: LD_ADDR_EXP 24
52661: PUSH
52662: LD_EXP 24
52666: PPUSH
52667: LD_VAR 0 1
52671: PPUSH
52672: EMPTY
52673: PPUSH
52674: CALL_OW 1
52678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52679: LD_ADDR_EXP 25
52683: PUSH
52684: LD_EXP 25
52688: PPUSH
52689: LD_VAR 0 1
52693: PPUSH
52694: EMPTY
52695: PPUSH
52696: CALL_OW 1
52700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52701: LD_ADDR_EXP 26
52705: PUSH
52706: LD_EXP 26
52710: PPUSH
52711: LD_VAR 0 1
52715: PPUSH
52716: EMPTY
52717: PPUSH
52718: CALL_OW 1
52722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52723: LD_ADDR_EXP 27
52727: PUSH
52728: LD_EXP 27
52732: PPUSH
52733: LD_VAR 0 1
52737: PPUSH
52738: EMPTY
52739: PPUSH
52740: CALL_OW 1
52744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52745: LD_ADDR_EXP 28
52749: PUSH
52750: LD_EXP 28
52754: PPUSH
52755: LD_VAR 0 1
52759: PPUSH
52760: EMPTY
52761: PPUSH
52762: CALL_OW 1
52766: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52767: LD_ADDR_EXP 29
52771: PUSH
52772: LD_EXP 29
52776: PPUSH
52777: LD_VAR 0 1
52781: PPUSH
52782: EMPTY
52783: PPUSH
52784: CALL_OW 1
52788: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52789: LD_ADDR_EXP 30
52793: PUSH
52794: LD_EXP 30
52798: PPUSH
52799: LD_VAR 0 1
52803: PPUSH
52804: EMPTY
52805: PPUSH
52806: CALL_OW 1
52810: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52811: LD_ADDR_EXP 31
52815: PUSH
52816: LD_EXP 31
52820: PPUSH
52821: LD_VAR 0 1
52825: PPUSH
52826: EMPTY
52827: PPUSH
52828: CALL_OW 1
52832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52833: LD_ADDR_EXP 32
52837: PUSH
52838: LD_EXP 32
52842: PPUSH
52843: LD_VAR 0 1
52847: PPUSH
52848: EMPTY
52849: PPUSH
52850: CALL_OW 1
52854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52855: LD_ADDR_EXP 33
52859: PUSH
52860: LD_EXP 33
52864: PPUSH
52865: LD_VAR 0 1
52869: PPUSH
52870: EMPTY
52871: PPUSH
52872: CALL_OW 1
52876: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52877: LD_ADDR_EXP 34
52881: PUSH
52882: LD_EXP 34
52886: PPUSH
52887: LD_VAR 0 1
52891: PPUSH
52892: LD_INT 0
52894: PPUSH
52895: CALL_OW 1
52899: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52900: LD_ADDR_EXP 35
52904: PUSH
52905: LD_EXP 35
52909: PPUSH
52910: LD_VAR 0 1
52914: PPUSH
52915: EMPTY
52916: PPUSH
52917: CALL_OW 1
52921: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52922: LD_ADDR_EXP 36
52926: PUSH
52927: LD_EXP 36
52931: PPUSH
52932: LD_VAR 0 1
52936: PPUSH
52937: EMPTY
52938: PPUSH
52939: CALL_OW 1
52943: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52944: LD_ADDR_EXP 37
52948: PUSH
52949: LD_EXP 37
52953: PPUSH
52954: LD_VAR 0 1
52958: PPUSH
52959: EMPTY
52960: PPUSH
52961: CALL_OW 1
52965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52966: LD_ADDR_EXP 38
52970: PUSH
52971: LD_EXP 38
52975: PPUSH
52976: LD_VAR 0 1
52980: PPUSH
52981: EMPTY
52982: PPUSH
52983: CALL_OW 1
52987: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52988: LD_ADDR_EXP 39
52992: PUSH
52993: LD_EXP 39
52997: PPUSH
52998: LD_VAR 0 1
53002: PPUSH
53003: EMPTY
53004: PPUSH
53005: CALL_OW 1
53009: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53010: LD_ADDR_EXP 40
53014: PUSH
53015: LD_EXP 40
53019: PPUSH
53020: LD_VAR 0 1
53024: PPUSH
53025: EMPTY
53026: PPUSH
53027: CALL_OW 1
53031: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53032: LD_ADDR_EXP 41
53036: PUSH
53037: LD_EXP 41
53041: PPUSH
53042: LD_VAR 0 1
53046: PPUSH
53047: EMPTY
53048: PPUSH
53049: CALL_OW 1
53053: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53054: LD_ADDR_EXP 42
53058: PUSH
53059: LD_EXP 42
53063: PPUSH
53064: LD_VAR 0 1
53068: PPUSH
53069: EMPTY
53070: PPUSH
53071: CALL_OW 1
53075: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53076: LD_ADDR_EXP 43
53080: PUSH
53081: LD_EXP 43
53085: PPUSH
53086: LD_VAR 0 1
53090: PPUSH
53091: EMPTY
53092: PPUSH
53093: CALL_OW 1
53097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53098: LD_ADDR_EXP 44
53102: PUSH
53103: LD_EXP 44
53107: PPUSH
53108: LD_VAR 0 1
53112: PPUSH
53113: EMPTY
53114: PPUSH
53115: CALL_OW 1
53119: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53120: LD_ADDR_EXP 45
53124: PUSH
53125: LD_EXP 45
53129: PPUSH
53130: LD_VAR 0 1
53134: PPUSH
53135: EMPTY
53136: PPUSH
53137: CALL_OW 1
53141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53142: LD_ADDR_EXP 46
53146: PUSH
53147: LD_EXP 46
53151: PPUSH
53152: LD_VAR 0 1
53156: PPUSH
53157: EMPTY
53158: PPUSH
53159: CALL_OW 1
53163: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53164: LD_ADDR_EXP 47
53168: PUSH
53169: LD_EXP 47
53173: PPUSH
53174: LD_VAR 0 1
53178: PPUSH
53179: EMPTY
53180: PPUSH
53181: CALL_OW 1
53185: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53186: LD_ADDR_EXP 48
53190: PUSH
53191: LD_EXP 48
53195: PPUSH
53196: LD_VAR 0 1
53200: PPUSH
53201: EMPTY
53202: PPUSH
53203: CALL_OW 1
53207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53208: LD_ADDR_EXP 50
53212: PUSH
53213: LD_EXP 50
53217: PPUSH
53218: LD_VAR 0 1
53222: PPUSH
53223: EMPTY
53224: PPUSH
53225: CALL_OW 1
53229: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53230: LD_ADDR_EXP 52
53234: PUSH
53235: LD_EXP 52
53239: PPUSH
53240: LD_VAR 0 1
53244: PPUSH
53245: EMPTY
53246: PPUSH
53247: CALL_OW 1
53251: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53252: LD_ADDR_EXP 53
53256: PUSH
53257: LD_EXP 53
53261: PPUSH
53262: LD_VAR 0 1
53266: PPUSH
53267: EMPTY
53268: PPUSH
53269: CALL_OW 1
53273: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53274: LD_ADDR_EXP 54
53278: PUSH
53279: LD_EXP 54
53283: PPUSH
53284: LD_VAR 0 1
53288: PPUSH
53289: EMPTY
53290: PPUSH
53291: CALL_OW 1
53295: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53296: LD_ADDR_EXP 55
53300: PUSH
53301: LD_EXP 55
53305: PPUSH
53306: LD_VAR 0 1
53310: PPUSH
53311: EMPTY
53312: PPUSH
53313: CALL_OW 1
53317: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53318: LD_ADDR_EXP 56
53322: PUSH
53323: LD_EXP 56
53327: PPUSH
53328: LD_VAR 0 1
53332: PPUSH
53333: EMPTY
53334: PPUSH
53335: CALL_OW 1
53339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53340: LD_ADDR_EXP 57
53344: PUSH
53345: LD_EXP 57
53349: PPUSH
53350: LD_VAR 0 1
53354: PPUSH
53355: EMPTY
53356: PPUSH
53357: CALL_OW 1
53361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53362: LD_ADDR_EXP 58
53366: PUSH
53367: LD_EXP 58
53371: PPUSH
53372: LD_VAR 0 1
53376: PPUSH
53377: EMPTY
53378: PPUSH
53379: CALL_OW 1
53383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53384: LD_ADDR_EXP 59
53388: PUSH
53389: LD_EXP 59
53393: PPUSH
53394: LD_VAR 0 1
53398: PPUSH
53399: EMPTY
53400: PPUSH
53401: CALL_OW 1
53405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53406: LD_ADDR_EXP 60
53410: PUSH
53411: LD_EXP 60
53415: PPUSH
53416: LD_VAR 0 1
53420: PPUSH
53421: EMPTY
53422: PPUSH
53423: CALL_OW 1
53427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53428: LD_ADDR_EXP 61
53432: PUSH
53433: LD_EXP 61
53437: PPUSH
53438: LD_VAR 0 1
53442: PPUSH
53443: EMPTY
53444: PPUSH
53445: CALL_OW 1
53449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53450: LD_ADDR_EXP 62
53454: PUSH
53455: LD_EXP 62
53459: PPUSH
53460: LD_VAR 0 1
53464: PPUSH
53465: EMPTY
53466: PPUSH
53467: CALL_OW 1
53471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53472: LD_ADDR_EXP 63
53476: PUSH
53477: LD_EXP 63
53481: PPUSH
53482: LD_VAR 0 1
53486: PPUSH
53487: EMPTY
53488: PPUSH
53489: CALL_OW 1
53493: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53494: LD_ADDR_EXP 64
53498: PUSH
53499: LD_EXP 64
53503: PPUSH
53504: LD_VAR 0 1
53508: PPUSH
53509: EMPTY
53510: PPUSH
53511: CALL_OW 1
53515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53516: LD_ADDR_EXP 65
53520: PUSH
53521: LD_EXP 65
53525: PPUSH
53526: LD_VAR 0 1
53530: PPUSH
53531: LD_INT 0
53533: PPUSH
53534: CALL_OW 1
53538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53539: LD_ADDR_EXP 66
53543: PUSH
53544: LD_EXP 66
53548: PPUSH
53549: LD_VAR 0 1
53553: PPUSH
53554: LD_INT 0
53556: PPUSH
53557: CALL_OW 1
53561: ST_TO_ADDR
// end ;
53562: LD_VAR 0 2
53566: RET
// export function MC_Add ( side , units ) ; var base ; begin
53567: LD_INT 0
53569: PPUSH
53570: PPUSH
// base := mc_bases + 1 ;
53571: LD_ADDR_VAR 0 4
53575: PUSH
53576: LD_EXP 23
53580: PUSH
53581: LD_INT 1
53583: PLUS
53584: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53585: LD_ADDR_EXP 49
53589: PUSH
53590: LD_EXP 49
53594: PPUSH
53595: LD_VAR 0 4
53599: PPUSH
53600: LD_VAR 0 1
53604: PPUSH
53605: CALL_OW 1
53609: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53610: LD_ADDR_EXP 23
53614: PUSH
53615: LD_EXP 23
53619: PPUSH
53620: LD_VAR 0 4
53624: PPUSH
53625: LD_VAR 0 2
53629: PPUSH
53630: CALL_OW 1
53634: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53635: LD_ADDR_EXP 24
53639: PUSH
53640: LD_EXP 24
53644: PPUSH
53645: LD_VAR 0 4
53649: PPUSH
53650: EMPTY
53651: PPUSH
53652: CALL_OW 1
53656: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53657: LD_ADDR_EXP 25
53661: PUSH
53662: LD_EXP 25
53666: PPUSH
53667: LD_VAR 0 4
53671: PPUSH
53672: EMPTY
53673: PPUSH
53674: CALL_OW 1
53678: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53679: LD_ADDR_EXP 26
53683: PUSH
53684: LD_EXP 26
53688: PPUSH
53689: LD_VAR 0 4
53693: PPUSH
53694: EMPTY
53695: PPUSH
53696: CALL_OW 1
53700: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53701: LD_ADDR_EXP 27
53705: PUSH
53706: LD_EXP 27
53710: PPUSH
53711: LD_VAR 0 4
53715: PPUSH
53716: EMPTY
53717: PPUSH
53718: CALL_OW 1
53722: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53723: LD_ADDR_EXP 28
53727: PUSH
53728: LD_EXP 28
53732: PPUSH
53733: LD_VAR 0 4
53737: PPUSH
53738: EMPTY
53739: PPUSH
53740: CALL_OW 1
53744: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53745: LD_ADDR_EXP 29
53749: PUSH
53750: LD_EXP 29
53754: PPUSH
53755: LD_VAR 0 4
53759: PPUSH
53760: EMPTY
53761: PPUSH
53762: CALL_OW 1
53766: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53767: LD_ADDR_EXP 30
53771: PUSH
53772: LD_EXP 30
53776: PPUSH
53777: LD_VAR 0 4
53781: PPUSH
53782: EMPTY
53783: PPUSH
53784: CALL_OW 1
53788: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53789: LD_ADDR_EXP 31
53793: PUSH
53794: LD_EXP 31
53798: PPUSH
53799: LD_VAR 0 4
53803: PPUSH
53804: EMPTY
53805: PPUSH
53806: CALL_OW 1
53810: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53811: LD_ADDR_EXP 32
53815: PUSH
53816: LD_EXP 32
53820: PPUSH
53821: LD_VAR 0 4
53825: PPUSH
53826: EMPTY
53827: PPUSH
53828: CALL_OW 1
53832: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53833: LD_ADDR_EXP 33
53837: PUSH
53838: LD_EXP 33
53842: PPUSH
53843: LD_VAR 0 4
53847: PPUSH
53848: EMPTY
53849: PPUSH
53850: CALL_OW 1
53854: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53855: LD_ADDR_EXP 34
53859: PUSH
53860: LD_EXP 34
53864: PPUSH
53865: LD_VAR 0 4
53869: PPUSH
53870: LD_INT 0
53872: PPUSH
53873: CALL_OW 1
53877: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53878: LD_ADDR_EXP 35
53882: PUSH
53883: LD_EXP 35
53887: PPUSH
53888: LD_VAR 0 4
53892: PPUSH
53893: EMPTY
53894: PPUSH
53895: CALL_OW 1
53899: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53900: LD_ADDR_EXP 36
53904: PUSH
53905: LD_EXP 36
53909: PPUSH
53910: LD_VAR 0 4
53914: PPUSH
53915: EMPTY
53916: PPUSH
53917: CALL_OW 1
53921: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53922: LD_ADDR_EXP 37
53926: PUSH
53927: LD_EXP 37
53931: PPUSH
53932: LD_VAR 0 4
53936: PPUSH
53937: EMPTY
53938: PPUSH
53939: CALL_OW 1
53943: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53944: LD_ADDR_EXP 38
53948: PUSH
53949: LD_EXP 38
53953: PPUSH
53954: LD_VAR 0 4
53958: PPUSH
53959: EMPTY
53960: PPUSH
53961: CALL_OW 1
53965: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53966: LD_ADDR_EXP 39
53970: PUSH
53971: LD_EXP 39
53975: PPUSH
53976: LD_VAR 0 4
53980: PPUSH
53981: EMPTY
53982: PPUSH
53983: CALL_OW 1
53987: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53988: LD_ADDR_EXP 40
53992: PUSH
53993: LD_EXP 40
53997: PPUSH
53998: LD_VAR 0 4
54002: PPUSH
54003: EMPTY
54004: PPUSH
54005: CALL_OW 1
54009: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54010: LD_ADDR_EXP 41
54014: PUSH
54015: LD_EXP 41
54019: PPUSH
54020: LD_VAR 0 4
54024: PPUSH
54025: EMPTY
54026: PPUSH
54027: CALL_OW 1
54031: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54032: LD_ADDR_EXP 42
54036: PUSH
54037: LD_EXP 42
54041: PPUSH
54042: LD_VAR 0 4
54046: PPUSH
54047: EMPTY
54048: PPUSH
54049: CALL_OW 1
54053: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54054: LD_ADDR_EXP 43
54058: PUSH
54059: LD_EXP 43
54063: PPUSH
54064: LD_VAR 0 4
54068: PPUSH
54069: EMPTY
54070: PPUSH
54071: CALL_OW 1
54075: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54076: LD_ADDR_EXP 44
54080: PUSH
54081: LD_EXP 44
54085: PPUSH
54086: LD_VAR 0 4
54090: PPUSH
54091: EMPTY
54092: PPUSH
54093: CALL_OW 1
54097: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54098: LD_ADDR_EXP 45
54102: PUSH
54103: LD_EXP 45
54107: PPUSH
54108: LD_VAR 0 4
54112: PPUSH
54113: EMPTY
54114: PPUSH
54115: CALL_OW 1
54119: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54120: LD_ADDR_EXP 46
54124: PUSH
54125: LD_EXP 46
54129: PPUSH
54130: LD_VAR 0 4
54134: PPUSH
54135: EMPTY
54136: PPUSH
54137: CALL_OW 1
54141: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54142: LD_ADDR_EXP 47
54146: PUSH
54147: LD_EXP 47
54151: PPUSH
54152: LD_VAR 0 4
54156: PPUSH
54157: EMPTY
54158: PPUSH
54159: CALL_OW 1
54163: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54164: LD_ADDR_EXP 48
54168: PUSH
54169: LD_EXP 48
54173: PPUSH
54174: LD_VAR 0 4
54178: PPUSH
54179: EMPTY
54180: PPUSH
54181: CALL_OW 1
54185: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54186: LD_ADDR_EXP 50
54190: PUSH
54191: LD_EXP 50
54195: PPUSH
54196: LD_VAR 0 4
54200: PPUSH
54201: EMPTY
54202: PPUSH
54203: CALL_OW 1
54207: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54208: LD_ADDR_EXP 52
54212: PUSH
54213: LD_EXP 52
54217: PPUSH
54218: LD_VAR 0 4
54222: PPUSH
54223: EMPTY
54224: PPUSH
54225: CALL_OW 1
54229: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54230: LD_ADDR_EXP 53
54234: PUSH
54235: LD_EXP 53
54239: PPUSH
54240: LD_VAR 0 4
54244: PPUSH
54245: EMPTY
54246: PPUSH
54247: CALL_OW 1
54251: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54252: LD_ADDR_EXP 54
54256: PUSH
54257: LD_EXP 54
54261: PPUSH
54262: LD_VAR 0 4
54266: PPUSH
54267: EMPTY
54268: PPUSH
54269: CALL_OW 1
54273: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54274: LD_ADDR_EXP 55
54278: PUSH
54279: LD_EXP 55
54283: PPUSH
54284: LD_VAR 0 4
54288: PPUSH
54289: EMPTY
54290: PPUSH
54291: CALL_OW 1
54295: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54296: LD_ADDR_EXP 56
54300: PUSH
54301: LD_EXP 56
54305: PPUSH
54306: LD_VAR 0 4
54310: PPUSH
54311: EMPTY
54312: PPUSH
54313: CALL_OW 1
54317: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54318: LD_ADDR_EXP 57
54322: PUSH
54323: LD_EXP 57
54327: PPUSH
54328: LD_VAR 0 4
54332: PPUSH
54333: EMPTY
54334: PPUSH
54335: CALL_OW 1
54339: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54340: LD_ADDR_EXP 58
54344: PUSH
54345: LD_EXP 58
54349: PPUSH
54350: LD_VAR 0 4
54354: PPUSH
54355: EMPTY
54356: PPUSH
54357: CALL_OW 1
54361: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54362: LD_ADDR_EXP 59
54366: PUSH
54367: LD_EXP 59
54371: PPUSH
54372: LD_VAR 0 4
54376: PPUSH
54377: EMPTY
54378: PPUSH
54379: CALL_OW 1
54383: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54384: LD_ADDR_EXP 60
54388: PUSH
54389: LD_EXP 60
54393: PPUSH
54394: LD_VAR 0 4
54398: PPUSH
54399: EMPTY
54400: PPUSH
54401: CALL_OW 1
54405: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54406: LD_ADDR_EXP 61
54410: PUSH
54411: LD_EXP 61
54415: PPUSH
54416: LD_VAR 0 4
54420: PPUSH
54421: EMPTY
54422: PPUSH
54423: CALL_OW 1
54427: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54428: LD_ADDR_EXP 62
54432: PUSH
54433: LD_EXP 62
54437: PPUSH
54438: LD_VAR 0 4
54442: PPUSH
54443: EMPTY
54444: PPUSH
54445: CALL_OW 1
54449: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54450: LD_ADDR_EXP 63
54454: PUSH
54455: LD_EXP 63
54459: PPUSH
54460: LD_VAR 0 4
54464: PPUSH
54465: EMPTY
54466: PPUSH
54467: CALL_OW 1
54471: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54472: LD_ADDR_EXP 64
54476: PUSH
54477: LD_EXP 64
54481: PPUSH
54482: LD_VAR 0 4
54486: PPUSH
54487: EMPTY
54488: PPUSH
54489: CALL_OW 1
54493: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54494: LD_ADDR_EXP 65
54498: PUSH
54499: LD_EXP 65
54503: PPUSH
54504: LD_VAR 0 4
54508: PPUSH
54509: LD_INT 0
54511: PPUSH
54512: CALL_OW 1
54516: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54517: LD_ADDR_EXP 66
54521: PUSH
54522: LD_EXP 66
54526: PPUSH
54527: LD_VAR 0 4
54531: PPUSH
54532: LD_INT 0
54534: PPUSH
54535: CALL_OW 1
54539: ST_TO_ADDR
// result := base ;
54540: LD_ADDR_VAR 0 3
54544: PUSH
54545: LD_VAR 0 4
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 3
54554: RET
// export function MC_Start ( ) ; var i ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
// for i = 1 to mc_bases do
54559: LD_ADDR_VAR 0 2
54563: PUSH
54564: DOUBLE
54565: LD_INT 1
54567: DEC
54568: ST_TO_ADDR
54569: LD_EXP 23
54573: PUSH
54574: FOR_TO
54575: IFFALSE 55675
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54577: LD_ADDR_EXP 23
54581: PUSH
54582: LD_EXP 23
54586: PPUSH
54587: LD_VAR 0 2
54591: PPUSH
54592: LD_EXP 23
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: PUSH
54603: LD_INT 0
54605: DIFF
54606: PPUSH
54607: CALL_OW 1
54611: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54612: LD_ADDR_EXP 24
54616: PUSH
54617: LD_EXP 24
54621: PPUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: EMPTY
54628: PPUSH
54629: CALL_OW 1
54633: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54634: LD_ADDR_EXP 25
54638: PUSH
54639: LD_EXP 25
54643: PPUSH
54644: LD_VAR 0 2
54648: PPUSH
54649: EMPTY
54650: PPUSH
54651: CALL_OW 1
54655: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54656: LD_ADDR_EXP 26
54660: PUSH
54661: LD_EXP 26
54665: PPUSH
54666: LD_VAR 0 2
54670: PPUSH
54671: EMPTY
54672: PPUSH
54673: CALL_OW 1
54677: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54678: LD_ADDR_EXP 27
54682: PUSH
54683: LD_EXP 27
54687: PPUSH
54688: LD_VAR 0 2
54692: PPUSH
54693: EMPTY
54694: PUSH
54695: EMPTY
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: PPUSH
54701: CALL_OW 1
54705: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54706: LD_ADDR_EXP 28
54710: PUSH
54711: LD_EXP 28
54715: PPUSH
54716: LD_VAR 0 2
54720: PPUSH
54721: EMPTY
54722: PPUSH
54723: CALL_OW 1
54727: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54728: LD_ADDR_EXP 55
54732: PUSH
54733: LD_EXP 55
54737: PPUSH
54738: LD_VAR 0 2
54742: PPUSH
54743: EMPTY
54744: PPUSH
54745: CALL_OW 1
54749: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54750: LD_ADDR_EXP 29
54754: PUSH
54755: LD_EXP 29
54759: PPUSH
54760: LD_VAR 0 2
54764: PPUSH
54765: EMPTY
54766: PPUSH
54767: CALL_OW 1
54771: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54772: LD_ADDR_EXP 30
54776: PUSH
54777: LD_EXP 30
54781: PPUSH
54782: LD_VAR 0 2
54786: PPUSH
54787: EMPTY
54788: PPUSH
54789: CALL_OW 1
54793: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54794: LD_ADDR_EXP 31
54798: PUSH
54799: LD_EXP 31
54803: PPUSH
54804: LD_VAR 0 2
54808: PPUSH
54809: LD_EXP 23
54813: PUSH
54814: LD_VAR 0 2
54818: ARRAY
54819: PPUSH
54820: LD_INT 2
54822: PUSH
54823: LD_INT 30
54825: PUSH
54826: LD_INT 32
54828: PUSH
54829: EMPTY
54830: LIST
54831: LIST
54832: PUSH
54833: LD_INT 30
54835: PUSH
54836: LD_INT 33
54838: PUSH
54839: EMPTY
54840: LIST
54841: LIST
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: LIST
54847: PPUSH
54848: CALL_OW 72
54852: PPUSH
54853: CALL_OW 1
54857: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54858: LD_ADDR_EXP 32
54862: PUSH
54863: LD_EXP 32
54867: PPUSH
54868: LD_VAR 0 2
54872: PPUSH
54873: LD_EXP 23
54877: PUSH
54878: LD_VAR 0 2
54882: ARRAY
54883: PPUSH
54884: LD_INT 2
54886: PUSH
54887: LD_INT 30
54889: PUSH
54890: LD_INT 32
54892: PUSH
54893: EMPTY
54894: LIST
54895: LIST
54896: PUSH
54897: LD_INT 30
54899: PUSH
54900: LD_INT 31
54902: PUSH
54903: EMPTY
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: LIST
54911: PUSH
54912: LD_INT 58
54914: PUSH
54915: EMPTY
54916: LIST
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: PPUSH
54922: CALL_OW 72
54926: PPUSH
54927: CALL_OW 1
54931: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54932: LD_ADDR_EXP 33
54936: PUSH
54937: LD_EXP 33
54941: PPUSH
54942: LD_VAR 0 2
54946: PPUSH
54947: EMPTY
54948: PPUSH
54949: CALL_OW 1
54953: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54954: LD_ADDR_EXP 37
54958: PUSH
54959: LD_EXP 37
54963: PPUSH
54964: LD_VAR 0 2
54968: PPUSH
54969: EMPTY
54970: PPUSH
54971: CALL_OW 1
54975: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54976: LD_ADDR_EXP 36
54980: PUSH
54981: LD_EXP 36
54985: PPUSH
54986: LD_VAR 0 2
54990: PPUSH
54991: EMPTY
54992: PPUSH
54993: CALL_OW 1
54997: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54998: LD_ADDR_EXP 38
55002: PUSH
55003: LD_EXP 38
55007: PPUSH
55008: LD_VAR 0 2
55012: PPUSH
55013: EMPTY
55014: PPUSH
55015: CALL_OW 1
55019: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55020: LD_ADDR_EXP 39
55024: PUSH
55025: LD_EXP 39
55029: PPUSH
55030: LD_VAR 0 2
55034: PPUSH
55035: EMPTY
55036: PPUSH
55037: CALL_OW 1
55041: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55042: LD_ADDR_EXP 40
55046: PUSH
55047: LD_EXP 40
55051: PPUSH
55052: LD_VAR 0 2
55056: PPUSH
55057: EMPTY
55058: PPUSH
55059: CALL_OW 1
55063: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55064: LD_ADDR_EXP 41
55068: PUSH
55069: LD_EXP 41
55073: PPUSH
55074: LD_VAR 0 2
55078: PPUSH
55079: EMPTY
55080: PPUSH
55081: CALL_OW 1
55085: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55086: LD_ADDR_EXP 42
55090: PUSH
55091: LD_EXP 42
55095: PPUSH
55096: LD_VAR 0 2
55100: PPUSH
55101: EMPTY
55102: PPUSH
55103: CALL_OW 1
55107: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55108: LD_ADDR_EXP 43
55112: PUSH
55113: LD_EXP 43
55117: PPUSH
55118: LD_VAR 0 2
55122: PPUSH
55123: EMPTY
55124: PPUSH
55125: CALL_OW 1
55129: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55130: LD_ADDR_EXP 44
55134: PUSH
55135: LD_EXP 44
55139: PPUSH
55140: LD_VAR 0 2
55144: PPUSH
55145: EMPTY
55146: PPUSH
55147: CALL_OW 1
55151: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55152: LD_ADDR_EXP 45
55156: PUSH
55157: LD_EXP 45
55161: PPUSH
55162: LD_VAR 0 2
55166: PPUSH
55167: EMPTY
55168: PPUSH
55169: CALL_OW 1
55173: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55174: LD_ADDR_EXP 34
55178: PUSH
55179: LD_EXP 34
55183: PPUSH
55184: LD_VAR 0 2
55188: PPUSH
55189: LD_INT 0
55191: PPUSH
55192: CALL_OW 1
55196: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55197: LD_ADDR_EXP 47
55201: PUSH
55202: LD_EXP 47
55206: PPUSH
55207: LD_VAR 0 2
55211: PPUSH
55212: LD_INT 0
55214: PPUSH
55215: CALL_OW 1
55219: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55220: LD_ADDR_EXP 35
55224: PUSH
55225: LD_EXP 35
55229: PPUSH
55230: LD_VAR 0 2
55234: PPUSH
55235: EMPTY
55236: PPUSH
55237: CALL_OW 1
55241: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55242: LD_ADDR_EXP 46
55246: PUSH
55247: LD_EXP 46
55251: PPUSH
55252: LD_VAR 0 2
55256: PPUSH
55257: LD_INT 0
55259: PPUSH
55260: CALL_OW 1
55264: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55265: LD_ADDR_EXP 48
55269: PUSH
55270: LD_EXP 48
55274: PPUSH
55275: LD_VAR 0 2
55279: PPUSH
55280: EMPTY
55281: PPUSH
55282: CALL_OW 1
55286: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55287: LD_ADDR_EXP 51
55291: PUSH
55292: LD_EXP 51
55296: PPUSH
55297: LD_VAR 0 2
55301: PPUSH
55302: LD_INT 0
55304: PPUSH
55305: CALL_OW 1
55309: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55310: LD_ADDR_EXP 52
55314: PUSH
55315: LD_EXP 52
55319: PPUSH
55320: LD_VAR 0 2
55324: PPUSH
55325: EMPTY
55326: PPUSH
55327: CALL_OW 1
55331: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55332: LD_ADDR_EXP 53
55336: PUSH
55337: LD_EXP 53
55341: PPUSH
55342: LD_VAR 0 2
55346: PPUSH
55347: EMPTY
55348: PPUSH
55349: CALL_OW 1
55353: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55354: LD_ADDR_EXP 54
55358: PUSH
55359: LD_EXP 54
55363: PPUSH
55364: LD_VAR 0 2
55368: PPUSH
55369: EMPTY
55370: PPUSH
55371: CALL_OW 1
55375: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55376: LD_ADDR_EXP 56
55380: PUSH
55381: LD_EXP 56
55385: PPUSH
55386: LD_VAR 0 2
55390: PPUSH
55391: LD_EXP 23
55395: PUSH
55396: LD_VAR 0 2
55400: ARRAY
55401: PPUSH
55402: LD_INT 2
55404: PUSH
55405: LD_INT 30
55407: PUSH
55408: LD_INT 6
55410: PUSH
55411: EMPTY
55412: LIST
55413: LIST
55414: PUSH
55415: LD_INT 30
55417: PUSH
55418: LD_INT 7
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: PUSH
55425: LD_INT 30
55427: PUSH
55428: LD_INT 8
55430: PUSH
55431: EMPTY
55432: LIST
55433: LIST
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: PPUSH
55441: CALL_OW 72
55445: PPUSH
55446: CALL_OW 1
55450: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55451: LD_ADDR_EXP 57
55455: PUSH
55456: LD_EXP 57
55460: PPUSH
55461: LD_VAR 0 2
55465: PPUSH
55466: EMPTY
55467: PPUSH
55468: CALL_OW 1
55472: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55473: LD_ADDR_EXP 58
55477: PUSH
55478: LD_EXP 58
55482: PPUSH
55483: LD_VAR 0 2
55487: PPUSH
55488: EMPTY
55489: PPUSH
55490: CALL_OW 1
55494: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55495: LD_ADDR_EXP 59
55499: PUSH
55500: LD_EXP 59
55504: PPUSH
55505: LD_VAR 0 2
55509: PPUSH
55510: EMPTY
55511: PPUSH
55512: CALL_OW 1
55516: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55517: LD_ADDR_EXP 60
55521: PUSH
55522: LD_EXP 60
55526: PPUSH
55527: LD_VAR 0 2
55531: PPUSH
55532: EMPTY
55533: PPUSH
55534: CALL_OW 1
55538: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55539: LD_ADDR_EXP 61
55543: PUSH
55544: LD_EXP 61
55548: PPUSH
55549: LD_VAR 0 2
55553: PPUSH
55554: EMPTY
55555: PPUSH
55556: CALL_OW 1
55560: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55561: LD_ADDR_EXP 62
55565: PUSH
55566: LD_EXP 62
55570: PPUSH
55571: LD_VAR 0 2
55575: PPUSH
55576: EMPTY
55577: PPUSH
55578: CALL_OW 1
55582: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55583: LD_ADDR_EXP 63
55587: PUSH
55588: LD_EXP 63
55592: PPUSH
55593: LD_VAR 0 2
55597: PPUSH
55598: EMPTY
55599: PPUSH
55600: CALL_OW 1
55604: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55605: LD_ADDR_EXP 64
55609: PUSH
55610: LD_EXP 64
55614: PPUSH
55615: LD_VAR 0 2
55619: PPUSH
55620: EMPTY
55621: PPUSH
55622: CALL_OW 1
55626: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55627: LD_ADDR_EXP 65
55631: PUSH
55632: LD_EXP 65
55636: PPUSH
55637: LD_VAR 0 2
55641: PPUSH
55642: LD_INT 0
55644: PPUSH
55645: CALL_OW 1
55649: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55650: LD_ADDR_EXP 66
55654: PUSH
55655: LD_EXP 66
55659: PPUSH
55660: LD_VAR 0 2
55664: PPUSH
55665: LD_INT 0
55667: PPUSH
55668: CALL_OW 1
55672: ST_TO_ADDR
// end ;
55673: GO 54574
55675: POP
55676: POP
// MC_InitSides ( ) ;
55677: CALL 55963 0 0
// MC_InitResearch ( ) ;
55681: CALL 55702 0 0
// CustomInitMacro ( ) ;
55685: CALL 269 0 0
// skirmish := true ;
55689: LD_ADDR_EXP 21
55693: PUSH
55694: LD_INT 1
55696: ST_TO_ADDR
// end ;
55697: LD_VAR 0 1
55701: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55702: LD_INT 0
55704: PPUSH
55705: PPUSH
55706: PPUSH
55707: PPUSH
55708: PPUSH
55709: PPUSH
// if not mc_bases then
55710: LD_EXP 23
55714: NOT
55715: IFFALSE 55719
// exit ;
55717: GO 55958
// for i = 1 to 8 do
55719: LD_ADDR_VAR 0 2
55723: PUSH
55724: DOUBLE
55725: LD_INT 1
55727: DEC
55728: ST_TO_ADDR
55729: LD_INT 8
55731: PUSH
55732: FOR_TO
55733: IFFALSE 55759
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55735: LD_ADDR_EXP 50
55739: PUSH
55740: LD_EXP 50
55744: PPUSH
55745: LD_VAR 0 2
55749: PPUSH
55750: EMPTY
55751: PPUSH
55752: CALL_OW 1
55756: ST_TO_ADDR
55757: GO 55732
55759: POP
55760: POP
// tmp := [ ] ;
55761: LD_ADDR_VAR 0 5
55765: PUSH
55766: EMPTY
55767: ST_TO_ADDR
// for i = 1 to mc_sides do
55768: LD_ADDR_VAR 0 2
55772: PUSH
55773: DOUBLE
55774: LD_INT 1
55776: DEC
55777: ST_TO_ADDR
55778: LD_EXP 49
55782: PUSH
55783: FOR_TO
55784: IFFALSE 55842
// if not mc_sides [ i ] in tmp then
55786: LD_EXP 49
55790: PUSH
55791: LD_VAR 0 2
55795: ARRAY
55796: PUSH
55797: LD_VAR 0 5
55801: IN
55802: NOT
55803: IFFALSE 55840
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55805: LD_ADDR_VAR 0 5
55809: PUSH
55810: LD_VAR 0 5
55814: PPUSH
55815: LD_VAR 0 5
55819: PUSH
55820: LD_INT 1
55822: PLUS
55823: PPUSH
55824: LD_EXP 49
55828: PUSH
55829: LD_VAR 0 2
55833: ARRAY
55834: PPUSH
55835: CALL_OW 2
55839: ST_TO_ADDR
55840: GO 55783
55842: POP
55843: POP
// if not tmp then
55844: LD_VAR 0 5
55848: NOT
55849: IFFALSE 55853
// exit ;
55851: GO 55958
// for j in tmp do
55853: LD_ADDR_VAR 0 3
55857: PUSH
55858: LD_VAR 0 5
55862: PUSH
55863: FOR_IN
55864: IFFALSE 55956
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55866: LD_ADDR_VAR 0 6
55870: PUSH
55871: LD_INT 22
55873: PUSH
55874: LD_VAR 0 3
55878: PUSH
55879: EMPTY
55880: LIST
55881: LIST
55882: PPUSH
55883: CALL_OW 69
55887: ST_TO_ADDR
// if not un then
55888: LD_VAR 0 6
55892: NOT
55893: IFFALSE 55897
// continue ;
55895: GO 55863
// nation := GetNation ( un [ 1 ] ) ;
55897: LD_ADDR_VAR 0 4
55901: PUSH
55902: LD_VAR 0 6
55906: PUSH
55907: LD_INT 1
55909: ARRAY
55910: PPUSH
55911: CALL_OW 248
55915: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55916: LD_ADDR_EXP 50
55920: PUSH
55921: LD_EXP 50
55925: PPUSH
55926: LD_VAR 0 3
55930: PPUSH
55931: LD_VAR 0 3
55935: PPUSH
55936: LD_VAR 0 4
55940: PPUSH
55941: LD_INT 1
55943: PPUSH
55944: CALL 11078 0 3
55948: PPUSH
55949: CALL_OW 1
55953: ST_TO_ADDR
// end ;
55954: GO 55863
55956: POP
55957: POP
// end ;
55958: LD_VAR 0 1
55962: RET
// export function MC_InitSides ( ) ; var i ; begin
55963: LD_INT 0
55965: PPUSH
55966: PPUSH
// if not mc_bases then
55967: LD_EXP 23
55971: NOT
55972: IFFALSE 55976
// exit ;
55974: GO 56050
// for i = 1 to mc_bases do
55976: LD_ADDR_VAR 0 2
55980: PUSH
55981: DOUBLE
55982: LD_INT 1
55984: DEC
55985: ST_TO_ADDR
55986: LD_EXP 23
55990: PUSH
55991: FOR_TO
55992: IFFALSE 56048
// if mc_bases [ i ] then
55994: LD_EXP 23
55998: PUSH
55999: LD_VAR 0 2
56003: ARRAY
56004: IFFALSE 56046
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56006: LD_ADDR_EXP 49
56010: PUSH
56011: LD_EXP 49
56015: PPUSH
56016: LD_VAR 0 2
56020: PPUSH
56021: LD_EXP 23
56025: PUSH
56026: LD_VAR 0 2
56030: ARRAY
56031: PUSH
56032: LD_INT 1
56034: ARRAY
56035: PPUSH
56036: CALL_OW 255
56040: PPUSH
56041: CALL_OW 1
56045: ST_TO_ADDR
56046: GO 55991
56048: POP
56049: POP
// end ;
56050: LD_VAR 0 1
56054: RET
// every 0 0$03 trigger skirmish do
56055: LD_EXP 21
56059: IFFALSE 56213
56061: GO 56063
56063: DISABLE
// begin enable ;
56064: ENABLE
// MC_CheckBuildings ( ) ;
56065: CALL 60711 0 0
// MC_CheckPeopleLife ( ) ;
56069: CALL 60872 0 0
// RaiseSailEvent ( 100 ) ;
56073: LD_INT 100
56075: PPUSH
56076: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56080: LD_INT 103
56082: PPUSH
56083: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56087: LD_INT 104
56089: PPUSH
56090: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56094: LD_INT 105
56096: PPUSH
56097: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56101: LD_INT 106
56103: PPUSH
56104: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56108: LD_INT 107
56110: PPUSH
56111: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56115: LD_INT 108
56117: PPUSH
56118: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56122: LD_INT 109
56124: PPUSH
56125: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56129: LD_INT 110
56131: PPUSH
56132: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56136: LD_INT 111
56138: PPUSH
56139: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56143: LD_INT 112
56145: PPUSH
56146: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56150: LD_INT 113
56152: PPUSH
56153: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56157: LD_INT 120
56159: PPUSH
56160: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56164: LD_INT 121
56166: PPUSH
56167: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56171: LD_INT 122
56173: PPUSH
56174: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56178: LD_INT 123
56180: PPUSH
56181: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56185: LD_INT 124
56187: PPUSH
56188: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56192: LD_INT 125
56194: PPUSH
56195: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56199: LD_INT 126
56201: PPUSH
56202: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56206: LD_INT 200
56208: PPUSH
56209: CALL_OW 427
// end ;
56213: END
// on SailEvent ( event ) do begin if event < 100 then
56214: LD_VAR 0 1
56218: PUSH
56219: LD_INT 100
56221: LESS
56222: IFFALSE 56233
// CustomEvent ( event ) ;
56224: LD_VAR 0 1
56228: PPUSH
56229: CALL 10229 0 1
// if event = 100 then
56233: LD_VAR 0 1
56237: PUSH
56238: LD_INT 100
56240: EQUAL
56241: IFFALSE 56247
// MC_ClassManager ( ) ;
56243: CALL 56639 0 0
// if event = 101 then
56247: LD_VAR 0 1
56251: PUSH
56252: LD_INT 101
56254: EQUAL
56255: IFFALSE 56261
// MC_RepairBuildings ( ) ;
56257: CALL 61457 0 0
// if event = 102 then
56261: LD_VAR 0 1
56265: PUSH
56266: LD_INT 102
56268: EQUAL
56269: IFFALSE 56275
// MC_Heal ( ) ;
56271: CALL 62392 0 0
// if event = 103 then
56275: LD_VAR 0 1
56279: PUSH
56280: LD_INT 103
56282: EQUAL
56283: IFFALSE 56289
// MC_Build ( ) ;
56285: CALL 62814 0 0
// if event = 104 then
56289: LD_VAR 0 1
56293: PUSH
56294: LD_INT 104
56296: EQUAL
56297: IFFALSE 56303
// MC_TurretWeapon ( ) ;
56299: CALL 64448 0 0
// if event = 105 then
56303: LD_VAR 0 1
56307: PUSH
56308: LD_INT 105
56310: EQUAL
56311: IFFALSE 56317
// MC_BuildUpgrade ( ) ;
56313: CALL 63999 0 0
// if event = 106 then
56317: LD_VAR 0 1
56321: PUSH
56322: LD_INT 106
56324: EQUAL
56325: IFFALSE 56331
// MC_PlantMines ( ) ;
56327: CALL 64878 0 0
// if event = 107 then
56331: LD_VAR 0 1
56335: PUSH
56336: LD_INT 107
56338: EQUAL
56339: IFFALSE 56345
// MC_CollectCrates ( ) ;
56341: CALL 65669 0 0
// if event = 108 then
56345: LD_VAR 0 1
56349: PUSH
56350: LD_INT 108
56352: EQUAL
56353: IFFALSE 56359
// MC_LinkRemoteControl ( ) ;
56355: CALL 67519 0 0
// if event = 109 then
56359: LD_VAR 0 1
56363: PUSH
56364: LD_INT 109
56366: EQUAL
56367: IFFALSE 56373
// MC_ProduceVehicle ( ) ;
56369: CALL 67700 0 0
// if event = 110 then
56373: LD_VAR 0 1
56377: PUSH
56378: LD_INT 110
56380: EQUAL
56381: IFFALSE 56387
// MC_SendAttack ( ) ;
56383: CALL 68166 0 0
// if event = 111 then
56387: LD_VAR 0 1
56391: PUSH
56392: LD_INT 111
56394: EQUAL
56395: IFFALSE 56401
// MC_Defend ( ) ;
56397: CALL 68274 0 0
// if event = 112 then
56401: LD_VAR 0 1
56405: PUSH
56406: LD_INT 112
56408: EQUAL
56409: IFFALSE 56415
// MC_Research ( ) ;
56411: CALL 69154 0 0
// if event = 113 then
56415: LD_VAR 0 1
56419: PUSH
56420: LD_INT 113
56422: EQUAL
56423: IFFALSE 56429
// MC_MinesTrigger ( ) ;
56425: CALL 70268 0 0
// if event = 120 then
56429: LD_VAR 0 1
56433: PUSH
56434: LD_INT 120
56436: EQUAL
56437: IFFALSE 56443
// MC_RepairVehicle ( ) ;
56439: CALL 70367 0 0
// if event = 121 then
56443: LD_VAR 0 1
56447: PUSH
56448: LD_INT 121
56450: EQUAL
56451: IFFALSE 56457
// MC_TameApe ( ) ;
56453: CALL 71136 0 0
// if event = 122 then
56457: LD_VAR 0 1
56461: PUSH
56462: LD_INT 122
56464: EQUAL
56465: IFFALSE 56471
// MC_ChangeApeClass ( ) ;
56467: CALL 71965 0 0
// if event = 123 then
56471: LD_VAR 0 1
56475: PUSH
56476: LD_INT 123
56478: EQUAL
56479: IFFALSE 56485
// MC_Bazooka ( ) ;
56481: CALL 72615 0 0
// if event = 124 then
56485: LD_VAR 0 1
56489: PUSH
56490: LD_INT 124
56492: EQUAL
56493: IFFALSE 56499
// MC_TeleportExit ( ) ;
56495: CALL 72813 0 0
// if event = 125 then
56499: LD_VAR 0 1
56503: PUSH
56504: LD_INT 125
56506: EQUAL
56507: IFFALSE 56513
// MC_Deposits ( ) ;
56509: CALL 73460 0 0
// if event = 126 then
56513: LD_VAR 0 1
56517: PUSH
56518: LD_INT 126
56520: EQUAL
56521: IFFALSE 56527
// MC_RemoteDriver ( ) ;
56523: CALL 74085 0 0
// if event = 200 then
56527: LD_VAR 0 1
56531: PUSH
56532: LD_INT 200
56534: EQUAL
56535: IFFALSE 56541
// MC_Idle ( ) ;
56537: CALL 76034 0 0
// end ;
56541: PPOPN 1
56543: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56544: LD_INT 0
56546: PPUSH
56547: PPUSH
// if not mc_bases [ base ] or not tag then
56548: LD_EXP 23
56552: PUSH
56553: LD_VAR 0 1
56557: ARRAY
56558: NOT
56559: PUSH
56560: LD_VAR 0 2
56564: NOT
56565: OR
56566: IFFALSE 56570
// exit ;
56568: GO 56634
// for i in mc_bases [ base ] union mc_ape [ base ] do
56570: LD_ADDR_VAR 0 4
56574: PUSH
56575: LD_EXP 23
56579: PUSH
56580: LD_VAR 0 1
56584: ARRAY
56585: PUSH
56586: LD_EXP 52
56590: PUSH
56591: LD_VAR 0 1
56595: ARRAY
56596: UNION
56597: PUSH
56598: FOR_IN
56599: IFFALSE 56632
// if GetTag ( i ) = tag then
56601: LD_VAR 0 4
56605: PPUSH
56606: CALL_OW 110
56610: PUSH
56611: LD_VAR 0 2
56615: EQUAL
56616: IFFALSE 56630
// SetTag ( i , 0 ) ;
56618: LD_VAR 0 4
56622: PPUSH
56623: LD_INT 0
56625: PPUSH
56626: CALL_OW 109
56630: GO 56598
56632: POP
56633: POP
// end ;
56634: LD_VAR 0 3
56638: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56639: LD_INT 0
56641: PPUSH
56642: PPUSH
56643: PPUSH
56644: PPUSH
56645: PPUSH
56646: PPUSH
56647: PPUSH
56648: PPUSH
// if not mc_bases then
56649: LD_EXP 23
56653: NOT
56654: IFFALSE 56658
// exit ;
56656: GO 57116
// for i = 1 to mc_bases do
56658: LD_ADDR_VAR 0 2
56662: PUSH
56663: DOUBLE
56664: LD_INT 1
56666: DEC
56667: ST_TO_ADDR
56668: LD_EXP 23
56672: PUSH
56673: FOR_TO
56674: IFFALSE 57114
// begin tmp := MC_ClassCheckReq ( i ) ;
56676: LD_ADDR_VAR 0 4
56680: PUSH
56681: LD_VAR 0 2
56685: PPUSH
56686: CALL 57121 0 1
56690: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56691: LD_ADDR_EXP 64
56695: PUSH
56696: LD_EXP 64
56700: PPUSH
56701: LD_VAR 0 2
56705: PPUSH
56706: LD_VAR 0 4
56710: PPUSH
56711: CALL_OW 1
56715: ST_TO_ADDR
// if not tmp then
56716: LD_VAR 0 4
56720: NOT
56721: IFFALSE 56725
// continue ;
56723: GO 56673
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56725: LD_ADDR_VAR 0 6
56729: PUSH
56730: LD_EXP 23
56734: PUSH
56735: LD_VAR 0 2
56739: ARRAY
56740: PPUSH
56741: LD_INT 2
56743: PUSH
56744: LD_INT 30
56746: PUSH
56747: LD_INT 4
56749: PUSH
56750: EMPTY
56751: LIST
56752: LIST
56753: PUSH
56754: LD_INT 30
56756: PUSH
56757: LD_INT 5
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: LIST
56768: PPUSH
56769: CALL_OW 72
56773: PUSH
56774: LD_EXP 23
56778: PUSH
56779: LD_VAR 0 2
56783: ARRAY
56784: PPUSH
56785: LD_INT 2
56787: PUSH
56788: LD_INT 30
56790: PUSH
56791: LD_INT 0
56793: PUSH
56794: EMPTY
56795: LIST
56796: LIST
56797: PUSH
56798: LD_INT 30
56800: PUSH
56801: LD_INT 1
56803: PUSH
56804: EMPTY
56805: LIST
56806: LIST
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: LIST
56812: PPUSH
56813: CALL_OW 72
56817: PUSH
56818: LD_EXP 23
56822: PUSH
56823: LD_VAR 0 2
56827: ARRAY
56828: PPUSH
56829: LD_INT 30
56831: PUSH
56832: LD_INT 3
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: PPUSH
56839: CALL_OW 72
56843: PUSH
56844: LD_EXP 23
56848: PUSH
56849: LD_VAR 0 2
56853: ARRAY
56854: PPUSH
56855: LD_INT 2
56857: PUSH
56858: LD_INT 30
56860: PUSH
56861: LD_INT 6
56863: PUSH
56864: EMPTY
56865: LIST
56866: LIST
56867: PUSH
56868: LD_INT 30
56870: PUSH
56871: LD_INT 7
56873: PUSH
56874: EMPTY
56875: LIST
56876: LIST
56877: PUSH
56878: LD_INT 30
56880: PUSH
56881: LD_INT 8
56883: PUSH
56884: EMPTY
56885: LIST
56886: LIST
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: LIST
56892: LIST
56893: PPUSH
56894: CALL_OW 72
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: ST_TO_ADDR
// for j = 1 to 4 do
56905: LD_ADDR_VAR 0 3
56909: PUSH
56910: DOUBLE
56911: LD_INT 1
56913: DEC
56914: ST_TO_ADDR
56915: LD_INT 4
56917: PUSH
56918: FOR_TO
56919: IFFALSE 57110
// begin if not tmp [ j ] then
56921: LD_VAR 0 4
56925: PUSH
56926: LD_VAR 0 3
56930: ARRAY
56931: NOT
56932: IFFALSE 56936
// continue ;
56934: GO 56918
// for p in tmp [ j ] do
56936: LD_ADDR_VAR 0 5
56940: PUSH
56941: LD_VAR 0 4
56945: PUSH
56946: LD_VAR 0 3
56950: ARRAY
56951: PUSH
56952: FOR_IN
56953: IFFALSE 57106
// begin if not b [ j ] then
56955: LD_VAR 0 6
56959: PUSH
56960: LD_VAR 0 3
56964: ARRAY
56965: NOT
56966: IFFALSE 56970
// break ;
56968: GO 57106
// e := 0 ;
56970: LD_ADDR_VAR 0 7
56974: PUSH
56975: LD_INT 0
56977: ST_TO_ADDR
// for k in b [ j ] do
56978: LD_ADDR_VAR 0 8
56982: PUSH
56983: LD_VAR 0 6
56987: PUSH
56988: LD_VAR 0 3
56992: ARRAY
56993: PUSH
56994: FOR_IN
56995: IFFALSE 57022
// if IsNotFull ( k ) then
56997: LD_VAR 0 8
57001: PPUSH
57002: CALL 13231 0 1
57006: IFFALSE 57020
// begin e := k ;
57008: LD_ADDR_VAR 0 7
57012: PUSH
57013: LD_VAR 0 8
57017: ST_TO_ADDR
// break ;
57018: GO 57022
// end ;
57020: GO 56994
57022: POP
57023: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57024: LD_VAR 0 7
57028: PUSH
57029: LD_VAR 0 5
57033: PPUSH
57034: LD_VAR 0 7
57038: PPUSH
57039: CALL 47110 0 2
57043: NOT
57044: AND
57045: IFFALSE 57104
// begin if IsInUnit ( p ) then
57047: LD_VAR 0 5
57051: PPUSH
57052: CALL_OW 310
57056: IFFALSE 57067
// ComExitBuilding ( p ) ;
57058: LD_VAR 0 5
57062: PPUSH
57063: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57067: LD_VAR 0 5
57071: PPUSH
57072: LD_VAR 0 7
57076: PPUSH
57077: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57081: LD_VAR 0 5
57085: PPUSH
57086: LD_VAR 0 3
57090: PPUSH
57091: CALL_OW 183
// AddComExitBuilding ( p ) ;
57095: LD_VAR 0 5
57099: PPUSH
57100: CALL_OW 182
// end ; end ;
57104: GO 56952
57106: POP
57107: POP
// end ;
57108: GO 56918
57110: POP
57111: POP
// end ;
57112: GO 56673
57114: POP
57115: POP
// end ;
57116: LD_VAR 0 1
57120: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57121: LD_INT 0
57123: PPUSH
57124: PPUSH
57125: PPUSH
57126: PPUSH
57127: PPUSH
57128: PPUSH
57129: PPUSH
57130: PPUSH
57131: PPUSH
57132: PPUSH
57133: PPUSH
57134: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57135: LD_VAR 0 1
57139: NOT
57140: PUSH
57141: LD_EXP 23
57145: PUSH
57146: LD_VAR 0 1
57150: ARRAY
57151: NOT
57152: OR
57153: PUSH
57154: LD_EXP 23
57158: PUSH
57159: LD_VAR 0 1
57163: ARRAY
57164: PPUSH
57165: LD_INT 2
57167: PUSH
57168: LD_INT 30
57170: PUSH
57171: LD_INT 0
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: PUSH
57178: LD_INT 30
57180: PUSH
57181: LD_INT 1
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: EMPTY
57189: LIST
57190: LIST
57191: LIST
57192: PPUSH
57193: CALL_OW 72
57197: NOT
57198: OR
57199: IFFALSE 57203
// exit ;
57201: GO 60706
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57203: LD_ADDR_VAR 0 4
57207: PUSH
57208: LD_EXP 23
57212: PUSH
57213: LD_VAR 0 1
57217: ARRAY
57218: PPUSH
57219: LD_INT 2
57221: PUSH
57222: LD_INT 25
57224: PUSH
57225: LD_INT 1
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 25
57234: PUSH
57235: LD_INT 2
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: LD_INT 25
57244: PUSH
57245: LD_INT 3
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: PUSH
57252: LD_INT 25
57254: PUSH
57255: LD_INT 4
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: PUSH
57262: LD_INT 25
57264: PUSH
57265: LD_INT 5
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PUSH
57272: LD_INT 25
57274: PUSH
57275: LD_INT 8
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: PUSH
57282: LD_INT 25
57284: PUSH
57285: LD_INT 9
57287: PUSH
57288: EMPTY
57289: LIST
57290: LIST
57291: PUSH
57292: EMPTY
57293: LIST
57294: LIST
57295: LIST
57296: LIST
57297: LIST
57298: LIST
57299: LIST
57300: LIST
57301: PPUSH
57302: CALL_OW 72
57306: ST_TO_ADDR
// if not tmp then
57307: LD_VAR 0 4
57311: NOT
57312: IFFALSE 57316
// exit ;
57314: GO 60706
// for i in tmp do
57316: LD_ADDR_VAR 0 3
57320: PUSH
57321: LD_VAR 0 4
57325: PUSH
57326: FOR_IN
57327: IFFALSE 57358
// if GetTag ( i ) then
57329: LD_VAR 0 3
57333: PPUSH
57334: CALL_OW 110
57338: IFFALSE 57356
// tmp := tmp diff i ;
57340: LD_ADDR_VAR 0 4
57344: PUSH
57345: LD_VAR 0 4
57349: PUSH
57350: LD_VAR 0 3
57354: DIFF
57355: ST_TO_ADDR
57356: GO 57326
57358: POP
57359: POP
// if not tmp then
57360: LD_VAR 0 4
57364: NOT
57365: IFFALSE 57369
// exit ;
57367: GO 60706
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57369: LD_ADDR_VAR 0 5
57373: PUSH
57374: LD_EXP 23
57378: PUSH
57379: LD_VAR 0 1
57383: ARRAY
57384: PPUSH
57385: LD_INT 2
57387: PUSH
57388: LD_INT 25
57390: PUSH
57391: LD_INT 1
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: PUSH
57398: LD_INT 25
57400: PUSH
57401: LD_INT 5
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: PUSH
57408: LD_INT 25
57410: PUSH
57411: LD_INT 8
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: PUSH
57418: LD_INT 25
57420: PUSH
57421: LD_INT 9
57423: PUSH
57424: EMPTY
57425: LIST
57426: LIST
57427: PUSH
57428: EMPTY
57429: LIST
57430: LIST
57431: LIST
57432: LIST
57433: LIST
57434: PPUSH
57435: CALL_OW 72
57439: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57440: LD_ADDR_VAR 0 6
57444: PUSH
57445: LD_EXP 23
57449: PUSH
57450: LD_VAR 0 1
57454: ARRAY
57455: PPUSH
57456: LD_INT 25
57458: PUSH
57459: LD_INT 2
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: PPUSH
57466: CALL_OW 72
57470: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57471: LD_ADDR_VAR 0 7
57475: PUSH
57476: LD_EXP 23
57480: PUSH
57481: LD_VAR 0 1
57485: ARRAY
57486: PPUSH
57487: LD_INT 25
57489: PUSH
57490: LD_INT 3
57492: PUSH
57493: EMPTY
57494: LIST
57495: LIST
57496: PPUSH
57497: CALL_OW 72
57501: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57502: LD_ADDR_VAR 0 8
57506: PUSH
57507: LD_EXP 23
57511: PUSH
57512: LD_VAR 0 1
57516: ARRAY
57517: PPUSH
57518: LD_INT 25
57520: PUSH
57521: LD_INT 4
57523: PUSH
57524: EMPTY
57525: LIST
57526: LIST
57527: PUSH
57528: LD_INT 24
57530: PUSH
57531: LD_INT 251
57533: PUSH
57534: EMPTY
57535: LIST
57536: LIST
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PPUSH
57542: CALL_OW 72
57546: ST_TO_ADDR
// if mc_is_defending [ base ] then
57547: LD_EXP 66
57551: PUSH
57552: LD_VAR 0 1
57556: ARRAY
57557: IFFALSE 58018
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57559: LD_ADDR_EXP 65
57563: PUSH
57564: LD_EXP 65
57568: PPUSH
57569: LD_VAR 0 1
57573: PPUSH
57574: LD_INT 4
57576: PPUSH
57577: CALL_OW 1
57581: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57582: LD_ADDR_VAR 0 12
57586: PUSH
57587: LD_EXP 23
57591: PUSH
57592: LD_VAR 0 1
57596: ARRAY
57597: PPUSH
57598: LD_INT 2
57600: PUSH
57601: LD_INT 30
57603: PUSH
57604: LD_INT 4
57606: PUSH
57607: EMPTY
57608: LIST
57609: LIST
57610: PUSH
57611: LD_INT 30
57613: PUSH
57614: LD_INT 5
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: PUSH
57621: EMPTY
57622: LIST
57623: LIST
57624: LIST
57625: PPUSH
57626: CALL_OW 72
57630: ST_TO_ADDR
// if not b then
57631: LD_VAR 0 12
57635: NOT
57636: IFFALSE 57640
// exit ;
57638: GO 60706
// p := [ ] ;
57640: LD_ADDR_VAR 0 11
57644: PUSH
57645: EMPTY
57646: ST_TO_ADDR
// if sci >= 2 then
57647: LD_VAR 0 8
57651: PUSH
57652: LD_INT 2
57654: GREATEREQUAL
57655: IFFALSE 57686
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57657: LD_ADDR_VAR 0 8
57661: PUSH
57662: LD_VAR 0 8
57666: PUSH
57667: LD_INT 1
57669: ARRAY
57670: PUSH
57671: LD_VAR 0 8
57675: PUSH
57676: LD_INT 2
57678: ARRAY
57679: PUSH
57680: EMPTY
57681: LIST
57682: LIST
57683: ST_TO_ADDR
57684: GO 57747
// if sci = 1 then
57686: LD_VAR 0 8
57690: PUSH
57691: LD_INT 1
57693: EQUAL
57694: IFFALSE 57715
// sci := [ sci [ 1 ] ] else
57696: LD_ADDR_VAR 0 8
57700: PUSH
57701: LD_VAR 0 8
57705: PUSH
57706: LD_INT 1
57708: ARRAY
57709: PUSH
57710: EMPTY
57711: LIST
57712: ST_TO_ADDR
57713: GO 57747
// if sci = 0 then
57715: LD_VAR 0 8
57719: PUSH
57720: LD_INT 0
57722: EQUAL
57723: IFFALSE 57747
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57725: LD_ADDR_VAR 0 11
57729: PUSH
57730: LD_VAR 0 4
57734: PPUSH
57735: LD_INT 4
57737: PPUSH
57738: CALL 46973 0 2
57742: PUSH
57743: LD_INT 1
57745: ARRAY
57746: ST_TO_ADDR
// if eng > 4 then
57747: LD_VAR 0 6
57751: PUSH
57752: LD_INT 4
57754: GREATER
57755: IFFALSE 57801
// for i = eng downto 4 do
57757: LD_ADDR_VAR 0 3
57761: PUSH
57762: DOUBLE
57763: LD_VAR 0 6
57767: INC
57768: ST_TO_ADDR
57769: LD_INT 4
57771: PUSH
57772: FOR_DOWNTO
57773: IFFALSE 57799
// eng := eng diff eng [ i ] ;
57775: LD_ADDR_VAR 0 6
57779: PUSH
57780: LD_VAR 0 6
57784: PUSH
57785: LD_VAR 0 6
57789: PUSH
57790: LD_VAR 0 3
57794: ARRAY
57795: DIFF
57796: ST_TO_ADDR
57797: GO 57772
57799: POP
57800: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57801: LD_ADDR_VAR 0 4
57805: PUSH
57806: LD_VAR 0 4
57810: PUSH
57811: LD_VAR 0 5
57815: PUSH
57816: LD_VAR 0 6
57820: UNION
57821: PUSH
57822: LD_VAR 0 7
57826: UNION
57827: PUSH
57828: LD_VAR 0 8
57832: UNION
57833: DIFF
57834: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57835: LD_ADDR_VAR 0 13
57839: PUSH
57840: LD_EXP 23
57844: PUSH
57845: LD_VAR 0 1
57849: ARRAY
57850: PPUSH
57851: LD_INT 2
57853: PUSH
57854: LD_INT 30
57856: PUSH
57857: LD_INT 32
57859: PUSH
57860: EMPTY
57861: LIST
57862: LIST
57863: PUSH
57864: LD_INT 30
57866: PUSH
57867: LD_INT 31
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: PUSH
57874: EMPTY
57875: LIST
57876: LIST
57877: LIST
57878: PPUSH
57879: CALL_OW 72
57883: PUSH
57884: LD_EXP 23
57888: PUSH
57889: LD_VAR 0 1
57893: ARRAY
57894: PPUSH
57895: LD_INT 2
57897: PUSH
57898: LD_INT 30
57900: PUSH
57901: LD_INT 4
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PUSH
57908: LD_INT 30
57910: PUSH
57911: LD_INT 5
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: PUSH
57918: EMPTY
57919: LIST
57920: LIST
57921: LIST
57922: PPUSH
57923: CALL_OW 72
57927: PUSH
57928: LD_INT 6
57930: MUL
57931: PLUS
57932: ST_TO_ADDR
// if bcount < tmp then
57933: LD_VAR 0 13
57937: PUSH
57938: LD_VAR 0 4
57942: LESS
57943: IFFALSE 57989
// for i = tmp downto bcount do
57945: LD_ADDR_VAR 0 3
57949: PUSH
57950: DOUBLE
57951: LD_VAR 0 4
57955: INC
57956: ST_TO_ADDR
57957: LD_VAR 0 13
57961: PUSH
57962: FOR_DOWNTO
57963: IFFALSE 57987
// tmp := Delete ( tmp , tmp ) ;
57965: LD_ADDR_VAR 0 4
57969: PUSH
57970: LD_VAR 0 4
57974: PPUSH
57975: LD_VAR 0 4
57979: PPUSH
57980: CALL_OW 3
57984: ST_TO_ADDR
57985: GO 57962
57987: POP
57988: POP
// result := [ tmp , 0 , 0 , p ] ;
57989: LD_ADDR_VAR 0 2
57993: PUSH
57994: LD_VAR 0 4
57998: PUSH
57999: LD_INT 0
58001: PUSH
58002: LD_INT 0
58004: PUSH
58005: LD_VAR 0 11
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: LIST
58014: LIST
58015: ST_TO_ADDR
// exit ;
58016: GO 60706
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58018: LD_EXP 23
58022: PUSH
58023: LD_VAR 0 1
58027: ARRAY
58028: PPUSH
58029: LD_INT 2
58031: PUSH
58032: LD_INT 30
58034: PUSH
58035: LD_INT 6
58037: PUSH
58038: EMPTY
58039: LIST
58040: LIST
58041: PUSH
58042: LD_INT 30
58044: PUSH
58045: LD_INT 7
58047: PUSH
58048: EMPTY
58049: LIST
58050: LIST
58051: PUSH
58052: LD_INT 30
58054: PUSH
58055: LD_INT 8
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: PUSH
58062: EMPTY
58063: LIST
58064: LIST
58065: LIST
58066: LIST
58067: PPUSH
58068: CALL_OW 72
58072: NOT
58073: PUSH
58074: LD_EXP 23
58078: PUSH
58079: LD_VAR 0 1
58083: ARRAY
58084: PPUSH
58085: LD_INT 30
58087: PUSH
58088: LD_INT 3
58090: PUSH
58091: EMPTY
58092: LIST
58093: LIST
58094: PPUSH
58095: CALL_OW 72
58099: NOT
58100: AND
58101: IFFALSE 58173
// begin if eng = tmp then
58103: LD_VAR 0 6
58107: PUSH
58108: LD_VAR 0 4
58112: EQUAL
58113: IFFALSE 58117
// exit ;
58115: GO 60706
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58117: LD_ADDR_EXP 65
58121: PUSH
58122: LD_EXP 65
58126: PPUSH
58127: LD_VAR 0 1
58131: PPUSH
58132: LD_INT 1
58134: PPUSH
58135: CALL_OW 1
58139: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58140: LD_ADDR_VAR 0 2
58144: PUSH
58145: LD_INT 0
58147: PUSH
58148: LD_VAR 0 4
58152: PUSH
58153: LD_VAR 0 6
58157: DIFF
58158: PUSH
58159: LD_INT 0
58161: PUSH
58162: LD_INT 0
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: LIST
58169: LIST
58170: ST_TO_ADDR
// exit ;
58171: GO 60706
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58173: LD_EXP 50
58177: PUSH
58178: LD_EXP 49
58182: PUSH
58183: LD_VAR 0 1
58187: ARRAY
58188: ARRAY
58189: PUSH
58190: LD_EXP 23
58194: PUSH
58195: LD_VAR 0 1
58199: ARRAY
58200: PPUSH
58201: LD_INT 2
58203: PUSH
58204: LD_INT 30
58206: PUSH
58207: LD_INT 6
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: PUSH
58214: LD_INT 30
58216: PUSH
58217: LD_INT 7
58219: PUSH
58220: EMPTY
58221: LIST
58222: LIST
58223: PUSH
58224: LD_INT 30
58226: PUSH
58227: LD_INT 8
58229: PUSH
58230: EMPTY
58231: LIST
58232: LIST
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: LIST
58238: LIST
58239: PPUSH
58240: CALL_OW 72
58244: AND
58245: PUSH
58246: LD_EXP 23
58250: PUSH
58251: LD_VAR 0 1
58255: ARRAY
58256: PPUSH
58257: LD_INT 30
58259: PUSH
58260: LD_INT 3
58262: PUSH
58263: EMPTY
58264: LIST
58265: LIST
58266: PPUSH
58267: CALL_OW 72
58271: NOT
58272: AND
58273: IFFALSE 58487
// begin if sci >= 6 then
58275: LD_VAR 0 8
58279: PUSH
58280: LD_INT 6
58282: GREATEREQUAL
58283: IFFALSE 58287
// exit ;
58285: GO 60706
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58287: LD_ADDR_EXP 65
58291: PUSH
58292: LD_EXP 65
58296: PPUSH
58297: LD_VAR 0 1
58301: PPUSH
58302: LD_INT 2
58304: PPUSH
58305: CALL_OW 1
58309: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58310: LD_ADDR_VAR 0 9
58314: PUSH
58315: LD_VAR 0 4
58319: PUSH
58320: LD_VAR 0 8
58324: DIFF
58325: PPUSH
58326: LD_INT 4
58328: PPUSH
58329: CALL 46973 0 2
58333: ST_TO_ADDR
// p := [ ] ;
58334: LD_ADDR_VAR 0 11
58338: PUSH
58339: EMPTY
58340: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58341: LD_VAR 0 8
58345: PUSH
58346: LD_INT 6
58348: LESS
58349: PUSH
58350: LD_VAR 0 9
58354: PUSH
58355: LD_INT 6
58357: GREATER
58358: AND
58359: IFFALSE 58440
// begin for i = 1 to 6 - sci do
58361: LD_ADDR_VAR 0 3
58365: PUSH
58366: DOUBLE
58367: LD_INT 1
58369: DEC
58370: ST_TO_ADDR
58371: LD_INT 6
58373: PUSH
58374: LD_VAR 0 8
58378: MINUS
58379: PUSH
58380: FOR_TO
58381: IFFALSE 58436
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58383: LD_ADDR_VAR 0 11
58387: PUSH
58388: LD_VAR 0 11
58392: PPUSH
58393: LD_VAR 0 11
58397: PUSH
58398: LD_INT 1
58400: PLUS
58401: PPUSH
58402: LD_VAR 0 9
58406: PUSH
58407: LD_INT 1
58409: ARRAY
58410: PPUSH
58411: CALL_OW 2
58415: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58416: LD_ADDR_VAR 0 9
58420: PUSH
58421: LD_VAR 0 9
58425: PPUSH
58426: LD_INT 1
58428: PPUSH
58429: CALL_OW 3
58433: ST_TO_ADDR
// end ;
58434: GO 58380
58436: POP
58437: POP
// end else
58438: GO 58460
// if sort then
58440: LD_VAR 0 9
58444: IFFALSE 58460
// p := sort [ 1 ] ;
58446: LD_ADDR_VAR 0 11
58450: PUSH
58451: LD_VAR 0 9
58455: PUSH
58456: LD_INT 1
58458: ARRAY
58459: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58460: LD_ADDR_VAR 0 2
58464: PUSH
58465: LD_INT 0
58467: PUSH
58468: LD_INT 0
58470: PUSH
58471: LD_INT 0
58473: PUSH
58474: LD_VAR 0 11
58478: PUSH
58479: EMPTY
58480: LIST
58481: LIST
58482: LIST
58483: LIST
58484: ST_TO_ADDR
// exit ;
58485: GO 60706
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58487: LD_EXP 50
58491: PUSH
58492: LD_EXP 49
58496: PUSH
58497: LD_VAR 0 1
58501: ARRAY
58502: ARRAY
58503: PUSH
58504: LD_EXP 23
58508: PUSH
58509: LD_VAR 0 1
58513: ARRAY
58514: PPUSH
58515: LD_INT 2
58517: PUSH
58518: LD_INT 30
58520: PUSH
58521: LD_INT 6
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: PUSH
58528: LD_INT 30
58530: PUSH
58531: LD_INT 7
58533: PUSH
58534: EMPTY
58535: LIST
58536: LIST
58537: PUSH
58538: LD_INT 30
58540: PUSH
58541: LD_INT 8
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: PUSH
58548: EMPTY
58549: LIST
58550: LIST
58551: LIST
58552: LIST
58553: PPUSH
58554: CALL_OW 72
58558: AND
58559: PUSH
58560: LD_EXP 23
58564: PUSH
58565: LD_VAR 0 1
58569: ARRAY
58570: PPUSH
58571: LD_INT 30
58573: PUSH
58574: LD_INT 3
58576: PUSH
58577: EMPTY
58578: LIST
58579: LIST
58580: PPUSH
58581: CALL_OW 72
58585: AND
58586: IFFALSE 59320
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58588: LD_ADDR_EXP 65
58592: PUSH
58593: LD_EXP 65
58597: PPUSH
58598: LD_VAR 0 1
58602: PPUSH
58603: LD_INT 3
58605: PPUSH
58606: CALL_OW 1
58610: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58611: LD_ADDR_VAR 0 2
58615: PUSH
58616: LD_INT 0
58618: PUSH
58619: LD_INT 0
58621: PUSH
58622: LD_INT 0
58624: PUSH
58625: LD_INT 0
58627: PUSH
58628: EMPTY
58629: LIST
58630: LIST
58631: LIST
58632: LIST
58633: ST_TO_ADDR
// if not eng then
58634: LD_VAR 0 6
58638: NOT
58639: IFFALSE 58702
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58641: LD_ADDR_VAR 0 11
58645: PUSH
58646: LD_VAR 0 4
58650: PPUSH
58651: LD_INT 2
58653: PPUSH
58654: CALL 46973 0 2
58658: PUSH
58659: LD_INT 1
58661: ARRAY
58662: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58663: LD_ADDR_VAR 0 2
58667: PUSH
58668: LD_VAR 0 2
58672: PPUSH
58673: LD_INT 2
58675: PPUSH
58676: LD_VAR 0 11
58680: PPUSH
58681: CALL_OW 1
58685: ST_TO_ADDR
// tmp := tmp diff p ;
58686: LD_ADDR_VAR 0 4
58690: PUSH
58691: LD_VAR 0 4
58695: PUSH
58696: LD_VAR 0 11
58700: DIFF
58701: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58702: LD_VAR 0 4
58706: PUSH
58707: LD_VAR 0 8
58711: PUSH
58712: LD_INT 6
58714: LESS
58715: AND
58716: IFFALSE 58904
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58718: LD_ADDR_VAR 0 9
58722: PUSH
58723: LD_VAR 0 4
58727: PUSH
58728: LD_VAR 0 8
58732: PUSH
58733: LD_VAR 0 7
58737: UNION
58738: DIFF
58739: PPUSH
58740: LD_INT 4
58742: PPUSH
58743: CALL 46973 0 2
58747: ST_TO_ADDR
// p := [ ] ;
58748: LD_ADDR_VAR 0 11
58752: PUSH
58753: EMPTY
58754: ST_TO_ADDR
// if sort then
58755: LD_VAR 0 9
58759: IFFALSE 58875
// for i = 1 to 6 - sci do
58761: LD_ADDR_VAR 0 3
58765: PUSH
58766: DOUBLE
58767: LD_INT 1
58769: DEC
58770: ST_TO_ADDR
58771: LD_INT 6
58773: PUSH
58774: LD_VAR 0 8
58778: MINUS
58779: PUSH
58780: FOR_TO
58781: IFFALSE 58873
// begin if i = sort then
58783: LD_VAR 0 3
58787: PUSH
58788: LD_VAR 0 9
58792: EQUAL
58793: IFFALSE 58797
// break ;
58795: GO 58873
// if GetClass ( i ) = 4 then
58797: LD_VAR 0 3
58801: PPUSH
58802: CALL_OW 257
58806: PUSH
58807: LD_INT 4
58809: EQUAL
58810: IFFALSE 58814
// continue ;
58812: GO 58780
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58814: LD_ADDR_VAR 0 11
58818: PUSH
58819: LD_VAR 0 11
58823: PPUSH
58824: LD_VAR 0 11
58828: PUSH
58829: LD_INT 1
58831: PLUS
58832: PPUSH
58833: LD_VAR 0 9
58837: PUSH
58838: LD_VAR 0 3
58842: ARRAY
58843: PPUSH
58844: CALL_OW 2
58848: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58849: LD_ADDR_VAR 0 4
58853: PUSH
58854: LD_VAR 0 4
58858: PUSH
58859: LD_VAR 0 9
58863: PUSH
58864: LD_VAR 0 3
58868: ARRAY
58869: DIFF
58870: ST_TO_ADDR
// end ;
58871: GO 58780
58873: POP
58874: POP
// if p then
58875: LD_VAR 0 11
58879: IFFALSE 58904
// result := Replace ( result , 4 , p ) ;
58881: LD_ADDR_VAR 0 2
58885: PUSH
58886: LD_VAR 0 2
58890: PPUSH
58891: LD_INT 4
58893: PPUSH
58894: LD_VAR 0 11
58898: PPUSH
58899: CALL_OW 1
58903: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58904: LD_VAR 0 4
58908: PUSH
58909: LD_VAR 0 7
58913: PUSH
58914: LD_INT 6
58916: LESS
58917: AND
58918: IFFALSE 59106
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58920: LD_ADDR_VAR 0 9
58924: PUSH
58925: LD_VAR 0 4
58929: PUSH
58930: LD_VAR 0 8
58934: PUSH
58935: LD_VAR 0 7
58939: UNION
58940: DIFF
58941: PPUSH
58942: LD_INT 3
58944: PPUSH
58945: CALL 46973 0 2
58949: ST_TO_ADDR
// p := [ ] ;
58950: LD_ADDR_VAR 0 11
58954: PUSH
58955: EMPTY
58956: ST_TO_ADDR
// if sort then
58957: LD_VAR 0 9
58961: IFFALSE 59077
// for i = 1 to 6 - mech do
58963: LD_ADDR_VAR 0 3
58967: PUSH
58968: DOUBLE
58969: LD_INT 1
58971: DEC
58972: ST_TO_ADDR
58973: LD_INT 6
58975: PUSH
58976: LD_VAR 0 7
58980: MINUS
58981: PUSH
58982: FOR_TO
58983: IFFALSE 59075
// begin if i = sort then
58985: LD_VAR 0 3
58989: PUSH
58990: LD_VAR 0 9
58994: EQUAL
58995: IFFALSE 58999
// break ;
58997: GO 59075
// if GetClass ( i ) = 3 then
58999: LD_VAR 0 3
59003: PPUSH
59004: CALL_OW 257
59008: PUSH
59009: LD_INT 3
59011: EQUAL
59012: IFFALSE 59016
// continue ;
59014: GO 58982
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59016: LD_ADDR_VAR 0 11
59020: PUSH
59021: LD_VAR 0 11
59025: PPUSH
59026: LD_VAR 0 11
59030: PUSH
59031: LD_INT 1
59033: PLUS
59034: PPUSH
59035: LD_VAR 0 9
59039: PUSH
59040: LD_VAR 0 3
59044: ARRAY
59045: PPUSH
59046: CALL_OW 2
59050: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59051: LD_ADDR_VAR 0 4
59055: PUSH
59056: LD_VAR 0 4
59060: PUSH
59061: LD_VAR 0 9
59065: PUSH
59066: LD_VAR 0 3
59070: ARRAY
59071: DIFF
59072: ST_TO_ADDR
// end ;
59073: GO 58982
59075: POP
59076: POP
// if p then
59077: LD_VAR 0 11
59081: IFFALSE 59106
// result := Replace ( result , 3 , p ) ;
59083: LD_ADDR_VAR 0 2
59087: PUSH
59088: LD_VAR 0 2
59092: PPUSH
59093: LD_INT 3
59095: PPUSH
59096: LD_VAR 0 11
59100: PPUSH
59101: CALL_OW 1
59105: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59106: LD_VAR 0 4
59110: PUSH
59111: LD_INT 6
59113: GREATER
59114: PUSH
59115: LD_VAR 0 6
59119: PUSH
59120: LD_INT 6
59122: LESS
59123: AND
59124: IFFALSE 59318
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59126: LD_ADDR_VAR 0 9
59130: PUSH
59131: LD_VAR 0 4
59135: PUSH
59136: LD_VAR 0 8
59140: PUSH
59141: LD_VAR 0 7
59145: UNION
59146: PUSH
59147: LD_VAR 0 6
59151: UNION
59152: DIFF
59153: PPUSH
59154: LD_INT 2
59156: PPUSH
59157: CALL 46973 0 2
59161: ST_TO_ADDR
// p := [ ] ;
59162: LD_ADDR_VAR 0 11
59166: PUSH
59167: EMPTY
59168: ST_TO_ADDR
// if sort then
59169: LD_VAR 0 9
59173: IFFALSE 59289
// for i = 1 to 6 - eng do
59175: LD_ADDR_VAR 0 3
59179: PUSH
59180: DOUBLE
59181: LD_INT 1
59183: DEC
59184: ST_TO_ADDR
59185: LD_INT 6
59187: PUSH
59188: LD_VAR 0 6
59192: MINUS
59193: PUSH
59194: FOR_TO
59195: IFFALSE 59287
// begin if i = sort then
59197: LD_VAR 0 3
59201: PUSH
59202: LD_VAR 0 9
59206: EQUAL
59207: IFFALSE 59211
// break ;
59209: GO 59287
// if GetClass ( i ) = 2 then
59211: LD_VAR 0 3
59215: PPUSH
59216: CALL_OW 257
59220: PUSH
59221: LD_INT 2
59223: EQUAL
59224: IFFALSE 59228
// continue ;
59226: GO 59194
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59228: LD_ADDR_VAR 0 11
59232: PUSH
59233: LD_VAR 0 11
59237: PPUSH
59238: LD_VAR 0 11
59242: PUSH
59243: LD_INT 1
59245: PLUS
59246: PPUSH
59247: LD_VAR 0 9
59251: PUSH
59252: LD_VAR 0 3
59256: ARRAY
59257: PPUSH
59258: CALL_OW 2
59262: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59263: LD_ADDR_VAR 0 4
59267: PUSH
59268: LD_VAR 0 4
59272: PUSH
59273: LD_VAR 0 9
59277: PUSH
59278: LD_VAR 0 3
59282: ARRAY
59283: DIFF
59284: ST_TO_ADDR
// end ;
59285: GO 59194
59287: POP
59288: POP
// if p then
59289: LD_VAR 0 11
59293: IFFALSE 59318
// result := Replace ( result , 2 , p ) ;
59295: LD_ADDR_VAR 0 2
59299: PUSH
59300: LD_VAR 0 2
59304: PPUSH
59305: LD_INT 2
59307: PPUSH
59308: LD_VAR 0 11
59312: PPUSH
59313: CALL_OW 1
59317: ST_TO_ADDR
// end ; exit ;
59318: GO 60706
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59320: LD_EXP 50
59324: PUSH
59325: LD_EXP 49
59329: PUSH
59330: LD_VAR 0 1
59334: ARRAY
59335: ARRAY
59336: NOT
59337: PUSH
59338: LD_EXP 23
59342: PUSH
59343: LD_VAR 0 1
59347: ARRAY
59348: PPUSH
59349: LD_INT 30
59351: PUSH
59352: LD_INT 3
59354: PUSH
59355: EMPTY
59356: LIST
59357: LIST
59358: PPUSH
59359: CALL_OW 72
59363: AND
59364: PUSH
59365: LD_EXP 28
59369: PUSH
59370: LD_VAR 0 1
59374: ARRAY
59375: AND
59376: IFFALSE 59984
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59378: LD_ADDR_EXP 65
59382: PUSH
59383: LD_EXP 65
59387: PPUSH
59388: LD_VAR 0 1
59392: PPUSH
59393: LD_INT 5
59395: PPUSH
59396: CALL_OW 1
59400: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59401: LD_ADDR_VAR 0 2
59405: PUSH
59406: LD_INT 0
59408: PUSH
59409: LD_INT 0
59411: PUSH
59412: LD_INT 0
59414: PUSH
59415: LD_INT 0
59417: PUSH
59418: EMPTY
59419: LIST
59420: LIST
59421: LIST
59422: LIST
59423: ST_TO_ADDR
// if sci > 1 then
59424: LD_VAR 0 8
59428: PUSH
59429: LD_INT 1
59431: GREATER
59432: IFFALSE 59460
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59434: LD_ADDR_VAR 0 4
59438: PUSH
59439: LD_VAR 0 4
59443: PUSH
59444: LD_VAR 0 8
59448: PUSH
59449: LD_VAR 0 8
59453: PUSH
59454: LD_INT 1
59456: ARRAY
59457: DIFF
59458: DIFF
59459: ST_TO_ADDR
// if tmp and not sci then
59460: LD_VAR 0 4
59464: PUSH
59465: LD_VAR 0 8
59469: NOT
59470: AND
59471: IFFALSE 59540
// begin sort := SortBySkill ( tmp , 4 ) ;
59473: LD_ADDR_VAR 0 9
59477: PUSH
59478: LD_VAR 0 4
59482: PPUSH
59483: LD_INT 4
59485: PPUSH
59486: CALL 46973 0 2
59490: ST_TO_ADDR
// if sort then
59491: LD_VAR 0 9
59495: IFFALSE 59511
// p := sort [ 1 ] ;
59497: LD_ADDR_VAR 0 11
59501: PUSH
59502: LD_VAR 0 9
59506: PUSH
59507: LD_INT 1
59509: ARRAY
59510: ST_TO_ADDR
// if p then
59511: LD_VAR 0 11
59515: IFFALSE 59540
// result := Replace ( result , 4 , p ) ;
59517: LD_ADDR_VAR 0 2
59521: PUSH
59522: LD_VAR 0 2
59526: PPUSH
59527: LD_INT 4
59529: PPUSH
59530: LD_VAR 0 11
59534: PPUSH
59535: CALL_OW 1
59539: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59540: LD_ADDR_VAR 0 4
59544: PUSH
59545: LD_VAR 0 4
59549: PUSH
59550: LD_VAR 0 7
59554: DIFF
59555: ST_TO_ADDR
// if tmp and mech < 6 then
59556: LD_VAR 0 4
59560: PUSH
59561: LD_VAR 0 7
59565: PUSH
59566: LD_INT 6
59568: LESS
59569: AND
59570: IFFALSE 59758
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59572: LD_ADDR_VAR 0 9
59576: PUSH
59577: LD_VAR 0 4
59581: PUSH
59582: LD_VAR 0 8
59586: PUSH
59587: LD_VAR 0 7
59591: UNION
59592: DIFF
59593: PPUSH
59594: LD_INT 3
59596: PPUSH
59597: CALL 46973 0 2
59601: ST_TO_ADDR
// p := [ ] ;
59602: LD_ADDR_VAR 0 11
59606: PUSH
59607: EMPTY
59608: ST_TO_ADDR
// if sort then
59609: LD_VAR 0 9
59613: IFFALSE 59729
// for i = 1 to 6 - mech do
59615: LD_ADDR_VAR 0 3
59619: PUSH
59620: DOUBLE
59621: LD_INT 1
59623: DEC
59624: ST_TO_ADDR
59625: LD_INT 6
59627: PUSH
59628: LD_VAR 0 7
59632: MINUS
59633: PUSH
59634: FOR_TO
59635: IFFALSE 59727
// begin if i = sort then
59637: LD_VAR 0 3
59641: PUSH
59642: LD_VAR 0 9
59646: EQUAL
59647: IFFALSE 59651
// break ;
59649: GO 59727
// if GetClass ( i ) = 3 then
59651: LD_VAR 0 3
59655: PPUSH
59656: CALL_OW 257
59660: PUSH
59661: LD_INT 3
59663: EQUAL
59664: IFFALSE 59668
// continue ;
59666: GO 59634
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59668: LD_ADDR_VAR 0 11
59672: PUSH
59673: LD_VAR 0 11
59677: PPUSH
59678: LD_VAR 0 11
59682: PUSH
59683: LD_INT 1
59685: PLUS
59686: PPUSH
59687: LD_VAR 0 9
59691: PUSH
59692: LD_VAR 0 3
59696: ARRAY
59697: PPUSH
59698: CALL_OW 2
59702: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59703: LD_ADDR_VAR 0 4
59707: PUSH
59708: LD_VAR 0 4
59712: PUSH
59713: LD_VAR 0 9
59717: PUSH
59718: LD_VAR 0 3
59722: ARRAY
59723: DIFF
59724: ST_TO_ADDR
// end ;
59725: GO 59634
59727: POP
59728: POP
// if p then
59729: LD_VAR 0 11
59733: IFFALSE 59758
// result := Replace ( result , 3 , p ) ;
59735: LD_ADDR_VAR 0 2
59739: PUSH
59740: LD_VAR 0 2
59744: PPUSH
59745: LD_INT 3
59747: PPUSH
59748: LD_VAR 0 11
59752: PPUSH
59753: CALL_OW 1
59757: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59758: LD_ADDR_VAR 0 4
59762: PUSH
59763: LD_VAR 0 4
59767: PUSH
59768: LD_VAR 0 6
59772: DIFF
59773: ST_TO_ADDR
// if tmp and eng < 6 then
59774: LD_VAR 0 4
59778: PUSH
59779: LD_VAR 0 6
59783: PUSH
59784: LD_INT 6
59786: LESS
59787: AND
59788: IFFALSE 59982
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59790: LD_ADDR_VAR 0 9
59794: PUSH
59795: LD_VAR 0 4
59799: PUSH
59800: LD_VAR 0 8
59804: PUSH
59805: LD_VAR 0 7
59809: UNION
59810: PUSH
59811: LD_VAR 0 6
59815: UNION
59816: DIFF
59817: PPUSH
59818: LD_INT 2
59820: PPUSH
59821: CALL 46973 0 2
59825: ST_TO_ADDR
// p := [ ] ;
59826: LD_ADDR_VAR 0 11
59830: PUSH
59831: EMPTY
59832: ST_TO_ADDR
// if sort then
59833: LD_VAR 0 9
59837: IFFALSE 59953
// for i = 1 to 6 - eng do
59839: LD_ADDR_VAR 0 3
59843: PUSH
59844: DOUBLE
59845: LD_INT 1
59847: DEC
59848: ST_TO_ADDR
59849: LD_INT 6
59851: PUSH
59852: LD_VAR 0 6
59856: MINUS
59857: PUSH
59858: FOR_TO
59859: IFFALSE 59951
// begin if i = sort then
59861: LD_VAR 0 3
59865: PUSH
59866: LD_VAR 0 9
59870: EQUAL
59871: IFFALSE 59875
// break ;
59873: GO 59951
// if GetClass ( i ) = 2 then
59875: LD_VAR 0 3
59879: PPUSH
59880: CALL_OW 257
59884: PUSH
59885: LD_INT 2
59887: EQUAL
59888: IFFALSE 59892
// continue ;
59890: GO 59858
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59892: LD_ADDR_VAR 0 11
59896: PUSH
59897: LD_VAR 0 11
59901: PPUSH
59902: LD_VAR 0 11
59906: PUSH
59907: LD_INT 1
59909: PLUS
59910: PPUSH
59911: LD_VAR 0 9
59915: PUSH
59916: LD_VAR 0 3
59920: ARRAY
59921: PPUSH
59922: CALL_OW 2
59926: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59927: LD_ADDR_VAR 0 4
59931: PUSH
59932: LD_VAR 0 4
59936: PUSH
59937: LD_VAR 0 9
59941: PUSH
59942: LD_VAR 0 3
59946: ARRAY
59947: DIFF
59948: ST_TO_ADDR
// end ;
59949: GO 59858
59951: POP
59952: POP
// if p then
59953: LD_VAR 0 11
59957: IFFALSE 59982
// result := Replace ( result , 2 , p ) ;
59959: LD_ADDR_VAR 0 2
59963: PUSH
59964: LD_VAR 0 2
59968: PPUSH
59969: LD_INT 2
59971: PPUSH
59972: LD_VAR 0 11
59976: PPUSH
59977: CALL_OW 1
59981: ST_TO_ADDR
// end ; exit ;
59982: GO 60706
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59984: LD_EXP 50
59988: PUSH
59989: LD_EXP 49
59993: PUSH
59994: LD_VAR 0 1
59998: ARRAY
59999: ARRAY
60000: NOT
60001: PUSH
60002: LD_EXP 23
60006: PUSH
60007: LD_VAR 0 1
60011: ARRAY
60012: PPUSH
60013: LD_INT 30
60015: PUSH
60016: LD_INT 3
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: PPUSH
60023: CALL_OW 72
60027: AND
60028: PUSH
60029: LD_EXP 28
60033: PUSH
60034: LD_VAR 0 1
60038: ARRAY
60039: NOT
60040: AND
60041: IFFALSE 60706
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60043: LD_ADDR_EXP 65
60047: PUSH
60048: LD_EXP 65
60052: PPUSH
60053: LD_VAR 0 1
60057: PPUSH
60058: LD_INT 6
60060: PPUSH
60061: CALL_OW 1
60065: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60066: LD_ADDR_VAR 0 2
60070: PUSH
60071: LD_INT 0
60073: PUSH
60074: LD_INT 0
60076: PUSH
60077: LD_INT 0
60079: PUSH
60080: LD_INT 0
60082: PUSH
60083: EMPTY
60084: LIST
60085: LIST
60086: LIST
60087: LIST
60088: ST_TO_ADDR
// if sci >= 1 then
60089: LD_VAR 0 8
60093: PUSH
60094: LD_INT 1
60096: GREATEREQUAL
60097: IFFALSE 60119
// tmp := tmp diff sci [ 1 ] ;
60099: LD_ADDR_VAR 0 4
60103: PUSH
60104: LD_VAR 0 4
60108: PUSH
60109: LD_VAR 0 8
60113: PUSH
60114: LD_INT 1
60116: ARRAY
60117: DIFF
60118: ST_TO_ADDR
// if tmp and not sci then
60119: LD_VAR 0 4
60123: PUSH
60124: LD_VAR 0 8
60128: NOT
60129: AND
60130: IFFALSE 60199
// begin sort := SortBySkill ( tmp , 4 ) ;
60132: LD_ADDR_VAR 0 9
60136: PUSH
60137: LD_VAR 0 4
60141: PPUSH
60142: LD_INT 4
60144: PPUSH
60145: CALL 46973 0 2
60149: ST_TO_ADDR
// if sort then
60150: LD_VAR 0 9
60154: IFFALSE 60170
// p := sort [ 1 ] ;
60156: LD_ADDR_VAR 0 11
60160: PUSH
60161: LD_VAR 0 9
60165: PUSH
60166: LD_INT 1
60168: ARRAY
60169: ST_TO_ADDR
// if p then
60170: LD_VAR 0 11
60174: IFFALSE 60199
// result := Replace ( result , 4 , p ) ;
60176: LD_ADDR_VAR 0 2
60180: PUSH
60181: LD_VAR 0 2
60185: PPUSH
60186: LD_INT 4
60188: PPUSH
60189: LD_VAR 0 11
60193: PPUSH
60194: CALL_OW 1
60198: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60199: LD_ADDR_VAR 0 4
60203: PUSH
60204: LD_VAR 0 4
60208: PUSH
60209: LD_VAR 0 7
60213: DIFF
60214: ST_TO_ADDR
// if tmp and mech < 6 then
60215: LD_VAR 0 4
60219: PUSH
60220: LD_VAR 0 7
60224: PUSH
60225: LD_INT 6
60227: LESS
60228: AND
60229: IFFALSE 60411
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60231: LD_ADDR_VAR 0 9
60235: PUSH
60236: LD_VAR 0 4
60240: PUSH
60241: LD_VAR 0 7
60245: DIFF
60246: PPUSH
60247: LD_INT 3
60249: PPUSH
60250: CALL 46973 0 2
60254: ST_TO_ADDR
// p := [ ] ;
60255: LD_ADDR_VAR 0 11
60259: PUSH
60260: EMPTY
60261: ST_TO_ADDR
// if sort then
60262: LD_VAR 0 9
60266: IFFALSE 60382
// for i = 1 to 6 - mech do
60268: LD_ADDR_VAR 0 3
60272: PUSH
60273: DOUBLE
60274: LD_INT 1
60276: DEC
60277: ST_TO_ADDR
60278: LD_INT 6
60280: PUSH
60281: LD_VAR 0 7
60285: MINUS
60286: PUSH
60287: FOR_TO
60288: IFFALSE 60380
// begin if i = sort then
60290: LD_VAR 0 3
60294: PUSH
60295: LD_VAR 0 9
60299: EQUAL
60300: IFFALSE 60304
// break ;
60302: GO 60380
// if GetClass ( i ) = 3 then
60304: LD_VAR 0 3
60308: PPUSH
60309: CALL_OW 257
60313: PUSH
60314: LD_INT 3
60316: EQUAL
60317: IFFALSE 60321
// continue ;
60319: GO 60287
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60321: LD_ADDR_VAR 0 11
60325: PUSH
60326: LD_VAR 0 11
60330: PPUSH
60331: LD_VAR 0 11
60335: PUSH
60336: LD_INT 1
60338: PLUS
60339: PPUSH
60340: LD_VAR 0 9
60344: PUSH
60345: LD_VAR 0 3
60349: ARRAY
60350: PPUSH
60351: CALL_OW 2
60355: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60356: LD_ADDR_VAR 0 4
60360: PUSH
60361: LD_VAR 0 4
60365: PUSH
60366: LD_VAR 0 9
60370: PUSH
60371: LD_VAR 0 3
60375: ARRAY
60376: DIFF
60377: ST_TO_ADDR
// end ;
60378: GO 60287
60380: POP
60381: POP
// if p then
60382: LD_VAR 0 11
60386: IFFALSE 60411
// result := Replace ( result , 3 , p ) ;
60388: LD_ADDR_VAR 0 2
60392: PUSH
60393: LD_VAR 0 2
60397: PPUSH
60398: LD_INT 3
60400: PPUSH
60401: LD_VAR 0 11
60405: PPUSH
60406: CALL_OW 1
60410: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60411: LD_ADDR_VAR 0 4
60415: PUSH
60416: LD_VAR 0 4
60420: PUSH
60421: LD_VAR 0 6
60425: DIFF
60426: ST_TO_ADDR
// if tmp and eng < 4 then
60427: LD_VAR 0 4
60431: PUSH
60432: LD_VAR 0 6
60436: PUSH
60437: LD_INT 4
60439: LESS
60440: AND
60441: IFFALSE 60631
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60443: LD_ADDR_VAR 0 9
60447: PUSH
60448: LD_VAR 0 4
60452: PUSH
60453: LD_VAR 0 7
60457: PUSH
60458: LD_VAR 0 6
60462: UNION
60463: DIFF
60464: PPUSH
60465: LD_INT 2
60467: PPUSH
60468: CALL 46973 0 2
60472: ST_TO_ADDR
// p := [ ] ;
60473: LD_ADDR_VAR 0 11
60477: PUSH
60478: EMPTY
60479: ST_TO_ADDR
// if sort then
60480: LD_VAR 0 9
60484: IFFALSE 60600
// for i = 1 to 4 - eng do
60486: LD_ADDR_VAR 0 3
60490: PUSH
60491: DOUBLE
60492: LD_INT 1
60494: DEC
60495: ST_TO_ADDR
60496: LD_INT 4
60498: PUSH
60499: LD_VAR 0 6
60503: MINUS
60504: PUSH
60505: FOR_TO
60506: IFFALSE 60598
// begin if i = sort then
60508: LD_VAR 0 3
60512: PUSH
60513: LD_VAR 0 9
60517: EQUAL
60518: IFFALSE 60522
// break ;
60520: GO 60598
// if GetClass ( i ) = 2 then
60522: LD_VAR 0 3
60526: PPUSH
60527: CALL_OW 257
60531: PUSH
60532: LD_INT 2
60534: EQUAL
60535: IFFALSE 60539
// continue ;
60537: GO 60505
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60539: LD_ADDR_VAR 0 11
60543: PUSH
60544: LD_VAR 0 11
60548: PPUSH
60549: LD_VAR 0 11
60553: PUSH
60554: LD_INT 1
60556: PLUS
60557: PPUSH
60558: LD_VAR 0 9
60562: PUSH
60563: LD_VAR 0 3
60567: ARRAY
60568: PPUSH
60569: CALL_OW 2
60573: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60574: LD_ADDR_VAR 0 4
60578: PUSH
60579: LD_VAR 0 4
60583: PUSH
60584: LD_VAR 0 9
60588: PUSH
60589: LD_VAR 0 3
60593: ARRAY
60594: DIFF
60595: ST_TO_ADDR
// end ;
60596: GO 60505
60598: POP
60599: POP
// if p then
60600: LD_VAR 0 11
60604: IFFALSE 60629
// result := Replace ( result , 2 , p ) ;
60606: LD_ADDR_VAR 0 2
60610: PUSH
60611: LD_VAR 0 2
60615: PPUSH
60616: LD_INT 2
60618: PPUSH
60619: LD_VAR 0 11
60623: PPUSH
60624: CALL_OW 1
60628: ST_TO_ADDR
// end else
60629: GO 60675
// for i = eng downto 5 do
60631: LD_ADDR_VAR 0 3
60635: PUSH
60636: DOUBLE
60637: LD_VAR 0 6
60641: INC
60642: ST_TO_ADDR
60643: LD_INT 5
60645: PUSH
60646: FOR_DOWNTO
60647: IFFALSE 60673
// tmp := tmp union eng [ i ] ;
60649: LD_ADDR_VAR 0 4
60653: PUSH
60654: LD_VAR 0 4
60658: PUSH
60659: LD_VAR 0 6
60663: PUSH
60664: LD_VAR 0 3
60668: ARRAY
60669: UNION
60670: ST_TO_ADDR
60671: GO 60646
60673: POP
60674: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60675: LD_ADDR_VAR 0 2
60679: PUSH
60680: LD_VAR 0 2
60684: PPUSH
60685: LD_INT 1
60687: PPUSH
60688: LD_VAR 0 4
60692: PUSH
60693: LD_VAR 0 5
60697: DIFF
60698: PPUSH
60699: CALL_OW 1
60703: ST_TO_ADDR
// exit ;
60704: GO 60706
// end ; end ;
60706: LD_VAR 0 2
60710: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60711: LD_INT 0
60713: PPUSH
60714: PPUSH
60715: PPUSH
// if not mc_bases then
60716: LD_EXP 23
60720: NOT
60721: IFFALSE 60725
// exit ;
60723: GO 60867
// for i = 1 to mc_bases do
60725: LD_ADDR_VAR 0 2
60729: PUSH
60730: DOUBLE
60731: LD_INT 1
60733: DEC
60734: ST_TO_ADDR
60735: LD_EXP 23
60739: PUSH
60740: FOR_TO
60741: IFFALSE 60858
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60743: LD_ADDR_VAR 0 3
60747: PUSH
60748: LD_EXP 23
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: PPUSH
60759: LD_INT 21
60761: PUSH
60762: LD_INT 3
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: LD_INT 3
60771: PUSH
60772: LD_INT 2
60774: PUSH
60775: LD_INT 30
60777: PUSH
60778: LD_INT 29
60780: PUSH
60781: EMPTY
60782: LIST
60783: LIST
60784: PUSH
60785: LD_INT 30
60787: PUSH
60788: LD_INT 30
60790: PUSH
60791: EMPTY
60792: LIST
60793: LIST
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: LIST
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: LD_INT 3
60806: PUSH
60807: LD_INT 24
60809: PUSH
60810: LD_INT 1000
60812: PUSH
60813: EMPTY
60814: LIST
60815: LIST
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PUSH
60821: EMPTY
60822: LIST
60823: LIST
60824: LIST
60825: PPUSH
60826: CALL_OW 72
60830: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60831: LD_ADDR_EXP 24
60835: PUSH
60836: LD_EXP 24
60840: PPUSH
60841: LD_VAR 0 2
60845: PPUSH
60846: LD_VAR 0 3
60850: PPUSH
60851: CALL_OW 1
60855: ST_TO_ADDR
// end ;
60856: GO 60740
60858: POP
60859: POP
// RaiseSailEvent ( 101 ) ;
60860: LD_INT 101
60862: PPUSH
60863: CALL_OW 427
// end ;
60867: LD_VAR 0 1
60871: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60872: LD_INT 0
60874: PPUSH
60875: PPUSH
60876: PPUSH
60877: PPUSH
60878: PPUSH
60879: PPUSH
60880: PPUSH
// if not mc_bases then
60881: LD_EXP 23
60885: NOT
60886: IFFALSE 60890
// exit ;
60888: GO 61452
// for i = 1 to mc_bases do
60890: LD_ADDR_VAR 0 2
60894: PUSH
60895: DOUBLE
60896: LD_INT 1
60898: DEC
60899: ST_TO_ADDR
60900: LD_EXP 23
60904: PUSH
60905: FOR_TO
60906: IFFALSE 61443
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60908: LD_ADDR_VAR 0 5
60912: PUSH
60913: LD_EXP 23
60917: PUSH
60918: LD_VAR 0 2
60922: ARRAY
60923: PUSH
60924: LD_EXP 52
60928: PUSH
60929: LD_VAR 0 2
60933: ARRAY
60934: UNION
60935: PPUSH
60936: LD_INT 21
60938: PUSH
60939: LD_INT 1
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: PUSH
60946: LD_INT 1
60948: PUSH
60949: LD_INT 3
60951: PUSH
60952: LD_INT 54
60954: PUSH
60955: EMPTY
60956: LIST
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: LD_INT 3
60964: PUSH
60965: LD_INT 24
60967: PUSH
60968: LD_INT 1000
60970: PUSH
60971: EMPTY
60972: LIST
60973: LIST
60974: PUSH
60975: EMPTY
60976: LIST
60977: LIST
60978: PUSH
60979: EMPTY
60980: LIST
60981: LIST
60982: LIST
60983: PUSH
60984: EMPTY
60985: LIST
60986: LIST
60987: PPUSH
60988: CALL_OW 72
60992: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60993: LD_ADDR_VAR 0 6
60997: PUSH
60998: LD_EXP 23
61002: PUSH
61003: LD_VAR 0 2
61007: ARRAY
61008: PPUSH
61009: LD_INT 21
61011: PUSH
61012: LD_INT 1
61014: PUSH
61015: EMPTY
61016: LIST
61017: LIST
61018: PUSH
61019: LD_INT 1
61021: PUSH
61022: LD_INT 3
61024: PUSH
61025: LD_INT 54
61027: PUSH
61028: EMPTY
61029: LIST
61030: PUSH
61031: EMPTY
61032: LIST
61033: LIST
61034: PUSH
61035: LD_INT 3
61037: PUSH
61038: LD_INT 24
61040: PUSH
61041: LD_INT 250
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: LIST
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: PPUSH
61061: CALL_OW 72
61065: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61066: LD_ADDR_VAR 0 7
61070: PUSH
61071: LD_VAR 0 5
61075: PUSH
61076: LD_VAR 0 6
61080: DIFF
61081: ST_TO_ADDR
// if not need_heal_1 then
61082: LD_VAR 0 6
61086: NOT
61087: IFFALSE 61120
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61089: LD_ADDR_EXP 26
61093: PUSH
61094: LD_EXP 26
61098: PPUSH
61099: LD_VAR 0 2
61103: PUSH
61104: LD_INT 1
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PPUSH
61111: EMPTY
61112: PPUSH
61113: CALL 16152 0 3
61117: ST_TO_ADDR
61118: GO 61190
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61120: LD_ADDR_EXP 26
61124: PUSH
61125: LD_EXP 26
61129: PPUSH
61130: LD_VAR 0 2
61134: PUSH
61135: LD_INT 1
61137: PUSH
61138: EMPTY
61139: LIST
61140: LIST
61141: PPUSH
61142: LD_EXP 26
61146: PUSH
61147: LD_VAR 0 2
61151: ARRAY
61152: PUSH
61153: LD_INT 1
61155: ARRAY
61156: PPUSH
61157: LD_INT 3
61159: PUSH
61160: LD_INT 24
61162: PUSH
61163: LD_INT 1000
61165: PUSH
61166: EMPTY
61167: LIST
61168: LIST
61169: PUSH
61170: EMPTY
61171: LIST
61172: LIST
61173: PPUSH
61174: CALL_OW 72
61178: PUSH
61179: LD_VAR 0 6
61183: UNION
61184: PPUSH
61185: CALL 16152 0 3
61189: ST_TO_ADDR
// if not need_heal_2 then
61190: LD_VAR 0 7
61194: NOT
61195: IFFALSE 61228
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61197: LD_ADDR_EXP 26
61201: PUSH
61202: LD_EXP 26
61206: PPUSH
61207: LD_VAR 0 2
61211: PUSH
61212: LD_INT 2
61214: PUSH
61215: EMPTY
61216: LIST
61217: LIST
61218: PPUSH
61219: EMPTY
61220: PPUSH
61221: CALL 16152 0 3
61225: ST_TO_ADDR
61226: GO 61260
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61228: LD_ADDR_EXP 26
61232: PUSH
61233: LD_EXP 26
61237: PPUSH
61238: LD_VAR 0 2
61242: PUSH
61243: LD_INT 2
61245: PUSH
61246: EMPTY
61247: LIST
61248: LIST
61249: PPUSH
61250: LD_VAR 0 7
61254: PPUSH
61255: CALL 16152 0 3
61259: ST_TO_ADDR
// if need_heal_2 then
61260: LD_VAR 0 7
61264: IFFALSE 61425
// for j in need_heal_2 do
61266: LD_ADDR_VAR 0 3
61270: PUSH
61271: LD_VAR 0 7
61275: PUSH
61276: FOR_IN
61277: IFFALSE 61423
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61279: LD_ADDR_VAR 0 5
61283: PUSH
61284: LD_EXP 23
61288: PUSH
61289: LD_VAR 0 2
61293: ARRAY
61294: PPUSH
61295: LD_INT 2
61297: PUSH
61298: LD_INT 30
61300: PUSH
61301: LD_INT 6
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: LD_INT 30
61310: PUSH
61311: LD_INT 7
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: PUSH
61318: LD_INT 30
61320: PUSH
61321: LD_INT 8
61323: PUSH
61324: EMPTY
61325: LIST
61326: LIST
61327: PUSH
61328: LD_INT 30
61330: PUSH
61331: LD_INT 0
61333: PUSH
61334: EMPTY
61335: LIST
61336: LIST
61337: PUSH
61338: LD_INT 30
61340: PUSH
61341: LD_INT 1
61343: PUSH
61344: EMPTY
61345: LIST
61346: LIST
61347: PUSH
61348: EMPTY
61349: LIST
61350: LIST
61351: LIST
61352: LIST
61353: LIST
61354: LIST
61355: PPUSH
61356: CALL_OW 72
61360: ST_TO_ADDR
// if tmp then
61361: LD_VAR 0 5
61365: IFFALSE 61421
// begin k := NearestUnitToUnit ( tmp , j ) ;
61367: LD_ADDR_VAR 0 4
61371: PUSH
61372: LD_VAR 0 5
61376: PPUSH
61377: LD_VAR 0 3
61381: PPUSH
61382: CALL_OW 74
61386: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61387: LD_VAR 0 3
61391: PPUSH
61392: LD_VAR 0 4
61396: PPUSH
61397: CALL_OW 296
61401: PUSH
61402: LD_INT 5
61404: GREATER
61405: IFFALSE 61421
// ComMoveToNearbyEntrance ( j , k ) ;
61407: LD_VAR 0 3
61411: PPUSH
61412: LD_VAR 0 4
61416: PPUSH
61417: CALL 49341 0 2
// end ; end ;
61421: GO 61276
61423: POP
61424: POP
// if not need_heal_1 and not need_heal_2 then
61425: LD_VAR 0 6
61429: NOT
61430: PUSH
61431: LD_VAR 0 7
61435: NOT
61436: AND
61437: IFFALSE 61441
// continue ;
61439: GO 60905
// end ;
61441: GO 60905
61443: POP
61444: POP
// RaiseSailEvent ( 102 ) ;
61445: LD_INT 102
61447: PPUSH
61448: CALL_OW 427
// end ;
61452: LD_VAR 0 1
61456: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61457: LD_INT 0
61459: PPUSH
61460: PPUSH
61461: PPUSH
61462: PPUSH
61463: PPUSH
61464: PPUSH
61465: PPUSH
61466: PPUSH
// if not mc_bases then
61467: LD_EXP 23
61471: NOT
61472: IFFALSE 61476
// exit ;
61474: GO 62387
// for i = 1 to mc_bases do
61476: LD_ADDR_VAR 0 2
61480: PUSH
61481: DOUBLE
61482: LD_INT 1
61484: DEC
61485: ST_TO_ADDR
61486: LD_EXP 23
61490: PUSH
61491: FOR_TO
61492: IFFALSE 62385
// begin if not mc_building_need_repair [ i ] then
61494: LD_EXP 24
61498: PUSH
61499: LD_VAR 0 2
61503: ARRAY
61504: NOT
61505: IFFALSE 61690
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61507: LD_ADDR_VAR 0 6
61511: PUSH
61512: LD_EXP 42
61516: PUSH
61517: LD_VAR 0 2
61521: ARRAY
61522: PPUSH
61523: LD_INT 3
61525: PUSH
61526: LD_INT 24
61528: PUSH
61529: LD_INT 1000
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 2
61542: PUSH
61543: LD_INT 34
61545: PUSH
61546: LD_INT 13
61548: PUSH
61549: EMPTY
61550: LIST
61551: LIST
61552: PUSH
61553: LD_INT 34
61555: PUSH
61556: LD_INT 52
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PUSH
61563: LD_INT 34
61565: PUSH
61566: LD_INT 88
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: EMPTY
61574: LIST
61575: LIST
61576: LIST
61577: LIST
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PPUSH
61583: CALL_OW 72
61587: ST_TO_ADDR
// if cranes then
61588: LD_VAR 0 6
61592: IFFALSE 61654
// for j in cranes do
61594: LD_ADDR_VAR 0 3
61598: PUSH
61599: LD_VAR 0 6
61603: PUSH
61604: FOR_IN
61605: IFFALSE 61652
// if not IsInArea ( j , mc_parking [ i ] ) then
61607: LD_VAR 0 3
61611: PPUSH
61612: LD_EXP 47
61616: PUSH
61617: LD_VAR 0 2
61621: ARRAY
61622: PPUSH
61623: CALL_OW 308
61627: NOT
61628: IFFALSE 61650
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61630: LD_VAR 0 3
61634: PPUSH
61635: LD_EXP 47
61639: PUSH
61640: LD_VAR 0 2
61644: ARRAY
61645: PPUSH
61646: CALL_OW 113
61650: GO 61604
61652: POP
61653: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61654: LD_ADDR_EXP 25
61658: PUSH
61659: LD_EXP 25
61663: PPUSH
61664: LD_VAR 0 2
61668: PPUSH
61669: EMPTY
61670: PPUSH
61671: CALL_OW 1
61675: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61676: LD_VAR 0 2
61680: PPUSH
61681: LD_INT 101
61683: PPUSH
61684: CALL 56544 0 2
// continue ;
61688: GO 61491
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61690: LD_ADDR_EXP 29
61694: PUSH
61695: LD_EXP 29
61699: PPUSH
61700: LD_VAR 0 2
61704: PPUSH
61705: EMPTY
61706: PPUSH
61707: CALL_OW 1
61711: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61712: LD_VAR 0 2
61716: PPUSH
61717: LD_INT 103
61719: PPUSH
61720: CALL 56544 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61724: LD_ADDR_VAR 0 5
61728: PUSH
61729: LD_EXP 23
61733: PUSH
61734: LD_VAR 0 2
61738: ARRAY
61739: PUSH
61740: LD_EXP 52
61744: PUSH
61745: LD_VAR 0 2
61749: ARRAY
61750: UNION
61751: PPUSH
61752: LD_INT 2
61754: PUSH
61755: LD_INT 25
61757: PUSH
61758: LD_INT 2
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PUSH
61765: LD_INT 25
61767: PUSH
61768: LD_INT 16
61770: PUSH
61771: EMPTY
61772: LIST
61773: LIST
61774: PUSH
61775: EMPTY
61776: LIST
61777: LIST
61778: LIST
61779: PUSH
61780: EMPTY
61781: LIST
61782: PPUSH
61783: CALL_OW 72
61787: ST_TO_ADDR
// if mc_need_heal [ i ] then
61788: LD_EXP 26
61792: PUSH
61793: LD_VAR 0 2
61797: ARRAY
61798: IFFALSE 61842
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61800: LD_ADDR_VAR 0 5
61804: PUSH
61805: LD_VAR 0 5
61809: PUSH
61810: LD_EXP 26
61814: PUSH
61815: LD_VAR 0 2
61819: ARRAY
61820: PUSH
61821: LD_INT 1
61823: ARRAY
61824: PUSH
61825: LD_EXP 26
61829: PUSH
61830: LD_VAR 0 2
61834: ARRAY
61835: PUSH
61836: LD_INT 2
61838: ARRAY
61839: UNION
61840: DIFF
61841: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61842: LD_ADDR_VAR 0 6
61846: PUSH
61847: LD_EXP 42
61851: PUSH
61852: LD_VAR 0 2
61856: ARRAY
61857: PPUSH
61858: LD_INT 2
61860: PUSH
61861: LD_INT 34
61863: PUSH
61864: LD_INT 13
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: PUSH
61871: LD_INT 34
61873: PUSH
61874: LD_INT 52
61876: PUSH
61877: EMPTY
61878: LIST
61879: LIST
61880: PUSH
61881: LD_INT 34
61883: PUSH
61884: LD_INT 88
61886: PUSH
61887: EMPTY
61888: LIST
61889: LIST
61890: PUSH
61891: EMPTY
61892: LIST
61893: LIST
61894: LIST
61895: LIST
61896: PPUSH
61897: CALL_OW 72
61901: ST_TO_ADDR
// if cranes then
61902: LD_VAR 0 6
61906: IFFALSE 62074
// begin for j in cranes do
61908: LD_ADDR_VAR 0 3
61912: PUSH
61913: LD_VAR 0 6
61917: PUSH
61918: FOR_IN
61919: IFFALSE 62072
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61921: LD_VAR 0 3
61925: PPUSH
61926: CALL_OW 256
61930: PUSH
61931: LD_INT 1000
61933: EQUAL
61934: PUSH
61935: LD_VAR 0 3
61939: PPUSH
61940: CALL_OW 314
61944: NOT
61945: AND
61946: IFFALSE 62012
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
61948: LD_ADDR_VAR 0 8
61952: PUSH
61953: LD_EXP 24
61957: PUSH
61958: LD_VAR 0 2
61962: ARRAY
61963: PPUSH
61964: LD_VAR 0 3
61968: PPUSH
61969: CALL_OW 74
61973: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61974: LD_VAR 0 8
61978: PPUSH
61979: LD_INT 16
61981: PPUSH
61982: CALL 18749 0 2
61986: PUSH
61987: LD_INT 4
61989: ARRAY
61990: PUSH
61991: LD_INT 10
61993: LESS
61994: IFFALSE 62010
// ComRepairBuilding ( j , to_repair ) ;
61996: LD_VAR 0 3
62000: PPUSH
62001: LD_VAR 0 8
62005: PPUSH
62006: CALL_OW 130
// end else
62010: GO 62070
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62012: LD_VAR 0 3
62016: PPUSH
62017: CALL_OW 256
62021: PUSH
62022: LD_INT 500
62024: LESS
62025: PUSH
62026: LD_VAR 0 3
62030: PPUSH
62031: LD_EXP 47
62035: PUSH
62036: LD_VAR 0 2
62040: ARRAY
62041: PPUSH
62042: CALL_OW 308
62046: NOT
62047: AND
62048: IFFALSE 62070
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62050: LD_VAR 0 3
62054: PPUSH
62055: LD_EXP 47
62059: PUSH
62060: LD_VAR 0 2
62064: ARRAY
62065: PPUSH
62066: CALL_OW 113
// end ;
62070: GO 61918
62072: POP
62073: POP
// end ; if tmp > 3 then
62074: LD_VAR 0 5
62078: PUSH
62079: LD_INT 3
62081: GREATER
62082: IFFALSE 62102
// tmp := ShrinkArray ( tmp , 4 ) ;
62084: LD_ADDR_VAR 0 5
62088: PUSH
62089: LD_VAR 0 5
62093: PPUSH
62094: LD_INT 4
62096: PPUSH
62097: CALL 48779 0 2
62101: ST_TO_ADDR
// if not tmp then
62102: LD_VAR 0 5
62106: NOT
62107: IFFALSE 62111
// continue ;
62109: GO 61491
// for j in tmp do
62111: LD_ADDR_VAR 0 3
62115: PUSH
62116: LD_VAR 0 5
62120: PUSH
62121: FOR_IN
62122: IFFALSE 62381
// begin if IsInUnit ( j ) then
62124: LD_VAR 0 3
62128: PPUSH
62129: CALL_OW 310
62133: IFFALSE 62144
// ComExitBuilding ( j ) ;
62135: LD_VAR 0 3
62139: PPUSH
62140: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62144: LD_VAR 0 3
62148: PUSH
62149: LD_EXP 25
62153: PUSH
62154: LD_VAR 0 2
62158: ARRAY
62159: IN
62160: NOT
62161: IFFALSE 62219
// begin SetTag ( j , 101 ) ;
62163: LD_VAR 0 3
62167: PPUSH
62168: LD_INT 101
62170: PPUSH
62171: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62175: LD_ADDR_EXP 25
62179: PUSH
62180: LD_EXP 25
62184: PPUSH
62185: LD_VAR 0 2
62189: PUSH
62190: LD_EXP 25
62194: PUSH
62195: LD_VAR 0 2
62199: ARRAY
62200: PUSH
62201: LD_INT 1
62203: PLUS
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: PPUSH
62209: LD_VAR 0 3
62213: PPUSH
62214: CALL 16152 0 3
62218: ST_TO_ADDR
// end ; wait ( 1 ) ;
62219: LD_INT 1
62221: PPUSH
62222: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62226: LD_ADDR_VAR 0 7
62230: PUSH
62231: LD_EXP 24
62235: PUSH
62236: LD_VAR 0 2
62240: ARRAY
62241: ST_TO_ADDR
// if mc_scan [ i ] then
62242: LD_EXP 46
62246: PUSH
62247: LD_VAR 0 2
62251: ARRAY
62252: IFFALSE 62314
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62254: LD_ADDR_VAR 0 7
62258: PUSH
62259: LD_EXP 24
62263: PUSH
62264: LD_VAR 0 2
62268: ARRAY
62269: PPUSH
62270: LD_INT 3
62272: PUSH
62273: LD_INT 30
62275: PUSH
62276: LD_INT 32
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: LD_INT 30
62285: PUSH
62286: LD_INT 33
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: PUSH
62293: LD_INT 30
62295: PUSH
62296: LD_INT 31
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PUSH
62303: EMPTY
62304: LIST
62305: LIST
62306: LIST
62307: LIST
62308: PPUSH
62309: CALL_OW 72
62313: ST_TO_ADDR
// if not to_repair_tmp then
62314: LD_VAR 0 7
62318: NOT
62319: IFFALSE 62323
// continue ;
62321: GO 62121
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62323: LD_ADDR_VAR 0 8
62327: PUSH
62328: LD_VAR 0 7
62332: PPUSH
62333: LD_VAR 0 3
62337: PPUSH
62338: CALL_OW 74
62342: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
62343: LD_VAR 0 8
62347: PPUSH
62348: LD_INT 16
62350: PPUSH
62351: CALL 18749 0 2
62355: PUSH
62356: LD_INT 4
62358: ARRAY
62359: PUSH
62360: LD_INT 14
62362: LESS
62363: IFFALSE 62379
// ComRepairBuilding ( j , to_repair ) ;
62365: LD_VAR 0 3
62369: PPUSH
62370: LD_VAR 0 8
62374: PPUSH
62375: CALL_OW 130
// end ;
62379: GO 62121
62381: POP
62382: POP
// end ;
62383: GO 61491
62385: POP
62386: POP
// end ;
62387: LD_VAR 0 1
62391: RET
// export function MC_Heal ; var i , j , tmp ; begin
62392: LD_INT 0
62394: PPUSH
62395: PPUSH
62396: PPUSH
62397: PPUSH
// if not mc_bases then
62398: LD_EXP 23
62402: NOT
62403: IFFALSE 62407
// exit ;
62405: GO 62809
// for i = 1 to mc_bases do
62407: LD_ADDR_VAR 0 2
62411: PUSH
62412: DOUBLE
62413: LD_INT 1
62415: DEC
62416: ST_TO_ADDR
62417: LD_EXP 23
62421: PUSH
62422: FOR_TO
62423: IFFALSE 62807
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62425: LD_EXP 26
62429: PUSH
62430: LD_VAR 0 2
62434: ARRAY
62435: PUSH
62436: LD_INT 1
62438: ARRAY
62439: NOT
62440: PUSH
62441: LD_EXP 26
62445: PUSH
62446: LD_VAR 0 2
62450: ARRAY
62451: PUSH
62452: LD_INT 2
62454: ARRAY
62455: NOT
62456: AND
62457: IFFALSE 62495
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62459: LD_ADDR_EXP 27
62463: PUSH
62464: LD_EXP 27
62468: PPUSH
62469: LD_VAR 0 2
62473: PPUSH
62474: EMPTY
62475: PPUSH
62476: CALL_OW 1
62480: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62481: LD_VAR 0 2
62485: PPUSH
62486: LD_INT 102
62488: PPUSH
62489: CALL 56544 0 2
// continue ;
62493: GO 62422
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62495: LD_ADDR_VAR 0 4
62499: PUSH
62500: LD_EXP 23
62504: PUSH
62505: LD_VAR 0 2
62509: ARRAY
62510: PPUSH
62511: LD_INT 25
62513: PUSH
62514: LD_INT 4
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: PPUSH
62521: CALL_OW 72
62525: ST_TO_ADDR
// if not tmp then
62526: LD_VAR 0 4
62530: NOT
62531: IFFALSE 62535
// continue ;
62533: GO 62422
// if mc_taming [ i ] then
62535: LD_EXP 54
62539: PUSH
62540: LD_VAR 0 2
62544: ARRAY
62545: IFFALSE 62569
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62547: LD_ADDR_EXP 54
62551: PUSH
62552: LD_EXP 54
62556: PPUSH
62557: LD_VAR 0 2
62561: PPUSH
62562: EMPTY
62563: PPUSH
62564: CALL_OW 1
62568: ST_TO_ADDR
// for j in tmp do
62569: LD_ADDR_VAR 0 3
62573: PUSH
62574: LD_VAR 0 4
62578: PUSH
62579: FOR_IN
62580: IFFALSE 62803
// begin if IsInUnit ( j ) then
62582: LD_VAR 0 3
62586: PPUSH
62587: CALL_OW 310
62591: IFFALSE 62602
// ComExitBuilding ( j ) ;
62593: LD_VAR 0 3
62597: PPUSH
62598: CALL_OW 122
// if not j in mc_healers [ i ] then
62602: LD_VAR 0 3
62606: PUSH
62607: LD_EXP 27
62611: PUSH
62612: LD_VAR 0 2
62616: ARRAY
62617: IN
62618: NOT
62619: IFFALSE 62665
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62621: LD_ADDR_EXP 27
62625: PUSH
62626: LD_EXP 27
62630: PPUSH
62631: LD_VAR 0 2
62635: PUSH
62636: LD_EXP 27
62640: PUSH
62641: LD_VAR 0 2
62645: ARRAY
62646: PUSH
62647: LD_INT 1
62649: PLUS
62650: PUSH
62651: EMPTY
62652: LIST
62653: LIST
62654: PPUSH
62655: LD_VAR 0 3
62659: PPUSH
62660: CALL 16152 0 3
62664: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62665: LD_VAR 0 3
62669: PPUSH
62670: CALL_OW 110
62674: PUSH
62675: LD_INT 102
62677: NONEQUAL
62678: IFFALSE 62692
// SetTag ( j , 102 ) ;
62680: LD_VAR 0 3
62684: PPUSH
62685: LD_INT 102
62687: PPUSH
62688: CALL_OW 109
// Wait ( 3 ) ;
62692: LD_INT 3
62694: PPUSH
62695: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62699: LD_EXP 26
62703: PUSH
62704: LD_VAR 0 2
62708: ARRAY
62709: PUSH
62710: LD_INT 1
62712: ARRAY
62713: IFFALSE 62745
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62715: LD_VAR 0 3
62719: PPUSH
62720: LD_EXP 26
62724: PUSH
62725: LD_VAR 0 2
62729: ARRAY
62730: PUSH
62731: LD_INT 1
62733: ARRAY
62734: PUSH
62735: LD_INT 1
62737: ARRAY
62738: PPUSH
62739: CALL_OW 128
62743: GO 62801
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62745: LD_VAR 0 3
62749: PPUSH
62750: CALL_OW 314
62754: NOT
62755: PUSH
62756: LD_EXP 26
62760: PUSH
62761: LD_VAR 0 2
62765: ARRAY
62766: PUSH
62767: LD_INT 2
62769: ARRAY
62770: AND
62771: IFFALSE 62801
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62773: LD_VAR 0 3
62777: PPUSH
62778: LD_EXP 26
62782: PUSH
62783: LD_VAR 0 2
62787: ARRAY
62788: PUSH
62789: LD_INT 2
62791: ARRAY
62792: PUSH
62793: LD_INT 1
62795: ARRAY
62796: PPUSH
62797: CALL_OW 128
// end ;
62801: GO 62579
62803: POP
62804: POP
// end ;
62805: GO 62422
62807: POP
62808: POP
// end ;
62809: LD_VAR 0 1
62813: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
62814: LD_INT 0
62816: PPUSH
62817: PPUSH
62818: PPUSH
62819: PPUSH
62820: PPUSH
62821: PPUSH
// if not mc_bases then
62822: LD_EXP 23
62826: NOT
62827: IFFALSE 62831
// exit ;
62829: GO 63994
// for i = 1 to mc_bases do
62831: LD_ADDR_VAR 0 2
62835: PUSH
62836: DOUBLE
62837: LD_INT 1
62839: DEC
62840: ST_TO_ADDR
62841: LD_EXP 23
62845: PUSH
62846: FOR_TO
62847: IFFALSE 63992
// begin if mc_scan [ i ] then
62849: LD_EXP 46
62853: PUSH
62854: LD_VAR 0 2
62858: ARRAY
62859: IFFALSE 62863
// continue ;
62861: GO 62846
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62863: LD_EXP 28
62867: PUSH
62868: LD_VAR 0 2
62872: ARRAY
62873: NOT
62874: PUSH
62875: LD_EXP 30
62879: PUSH
62880: LD_VAR 0 2
62884: ARRAY
62885: NOT
62886: AND
62887: PUSH
62888: LD_EXP 29
62892: PUSH
62893: LD_VAR 0 2
62897: ARRAY
62898: AND
62899: IFFALSE 62937
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62901: LD_ADDR_EXP 29
62905: PUSH
62906: LD_EXP 29
62910: PPUSH
62911: LD_VAR 0 2
62915: PPUSH
62916: EMPTY
62917: PPUSH
62918: CALL_OW 1
62922: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62923: LD_VAR 0 2
62927: PPUSH
62928: LD_INT 103
62930: PPUSH
62931: CALL 56544 0 2
// continue ;
62935: GO 62846
// end ; if mc_construct_list [ i ] then
62937: LD_EXP 30
62941: PUSH
62942: LD_VAR 0 2
62946: ARRAY
62947: IFFALSE 63167
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62949: LD_ADDR_VAR 0 5
62953: PUSH
62954: LD_EXP 23
62958: PUSH
62959: LD_VAR 0 2
62963: ARRAY
62964: PPUSH
62965: LD_INT 25
62967: PUSH
62968: LD_INT 2
62970: PUSH
62971: EMPTY
62972: LIST
62973: LIST
62974: PPUSH
62975: CALL_OW 72
62979: PUSH
62980: LD_EXP 25
62984: PUSH
62985: LD_VAR 0 2
62989: ARRAY
62990: DIFF
62991: ST_TO_ADDR
// if not tmp then
62992: LD_VAR 0 5
62996: NOT
62997: IFFALSE 63001
// continue ;
62999: GO 62846
// for j in tmp do
63001: LD_ADDR_VAR 0 3
63005: PUSH
63006: LD_VAR 0 5
63010: PUSH
63011: FOR_IN
63012: IFFALSE 63163
// begin if not mc_builders [ i ] then
63014: LD_EXP 29
63018: PUSH
63019: LD_VAR 0 2
63023: ARRAY
63024: NOT
63025: IFFALSE 63083
// begin SetTag ( j , 103 ) ;
63027: LD_VAR 0 3
63031: PPUSH
63032: LD_INT 103
63034: PPUSH
63035: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63039: LD_ADDR_EXP 29
63043: PUSH
63044: LD_EXP 29
63048: PPUSH
63049: LD_VAR 0 2
63053: PUSH
63054: LD_EXP 29
63058: PUSH
63059: LD_VAR 0 2
63063: ARRAY
63064: PUSH
63065: LD_INT 1
63067: PLUS
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: PPUSH
63073: LD_VAR 0 3
63077: PPUSH
63078: CALL 16152 0 3
63082: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63083: LD_VAR 0 3
63087: PPUSH
63088: CALL_OW 310
63092: IFFALSE 63103
// ComExitBuilding ( j ) ;
63094: LD_VAR 0 3
63098: PPUSH
63099: CALL_OW 122
// wait ( 3 ) ;
63103: LD_INT 3
63105: PPUSH
63106: CALL_OW 67
// if not mc_construct_list [ i ] then
63110: LD_EXP 30
63114: PUSH
63115: LD_VAR 0 2
63119: ARRAY
63120: NOT
63121: IFFALSE 63125
// break ;
63123: GO 63163
// if not HasTask ( j ) then
63125: LD_VAR 0 3
63129: PPUSH
63130: CALL_OW 314
63134: NOT
63135: IFFALSE 63161
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63137: LD_VAR 0 3
63141: PPUSH
63142: LD_EXP 30
63146: PUSH
63147: LD_VAR 0 2
63151: ARRAY
63152: PUSH
63153: LD_INT 1
63155: ARRAY
63156: PPUSH
63157: CALL 19013 0 2
// end ;
63161: GO 63011
63163: POP
63164: POP
// end else
63165: GO 63990
// if mc_build_list [ i ] then
63167: LD_EXP 28
63171: PUSH
63172: LD_VAR 0 2
63176: ARRAY
63177: IFFALSE 63990
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63179: LD_EXP 28
63183: PUSH
63184: LD_VAR 0 2
63188: ARRAY
63189: PUSH
63190: LD_INT 1
63192: ARRAY
63193: PUSH
63194: LD_INT 1
63196: ARRAY
63197: PPUSH
63198: CALL 18837 0 1
63202: PUSH
63203: LD_EXP 23
63207: PUSH
63208: LD_VAR 0 2
63212: ARRAY
63213: PPUSH
63214: LD_INT 2
63216: PUSH
63217: LD_INT 30
63219: PUSH
63220: LD_INT 2
63222: PUSH
63223: EMPTY
63224: LIST
63225: LIST
63226: PUSH
63227: LD_INT 30
63229: PUSH
63230: LD_INT 3
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: LIST
63241: PPUSH
63242: CALL_OW 72
63246: NOT
63247: AND
63248: IFFALSE 63353
// begin for j = 1 to mc_build_list [ i ] do
63250: LD_ADDR_VAR 0 3
63254: PUSH
63255: DOUBLE
63256: LD_INT 1
63258: DEC
63259: ST_TO_ADDR
63260: LD_EXP 28
63264: PUSH
63265: LD_VAR 0 2
63269: ARRAY
63270: PUSH
63271: FOR_TO
63272: IFFALSE 63351
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63274: LD_EXP 28
63278: PUSH
63279: LD_VAR 0 2
63283: ARRAY
63284: PUSH
63285: LD_VAR 0 3
63289: ARRAY
63290: PUSH
63291: LD_INT 1
63293: ARRAY
63294: PUSH
63295: LD_INT 2
63297: EQUAL
63298: IFFALSE 63349
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63300: LD_ADDR_EXP 28
63304: PUSH
63305: LD_EXP 28
63309: PPUSH
63310: LD_VAR 0 2
63314: PPUSH
63315: LD_EXP 28
63319: PUSH
63320: LD_VAR 0 2
63324: ARRAY
63325: PPUSH
63326: LD_VAR 0 3
63330: PPUSH
63331: LD_INT 1
63333: PPUSH
63334: LD_INT 0
63336: PPUSH
63337: CALL 15570 0 4
63341: PPUSH
63342: CALL_OW 1
63346: ST_TO_ADDR
// break ;
63347: GO 63351
// end ;
63349: GO 63271
63351: POP
63352: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63353: LD_ADDR_VAR 0 6
63357: PUSH
63358: LD_EXP 23
63362: PUSH
63363: LD_VAR 0 2
63367: ARRAY
63368: PPUSH
63369: LD_INT 2
63371: PUSH
63372: LD_INT 30
63374: PUSH
63375: LD_INT 0
63377: PUSH
63378: EMPTY
63379: LIST
63380: LIST
63381: PUSH
63382: LD_INT 30
63384: PUSH
63385: LD_INT 1
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: LIST
63396: PPUSH
63397: CALL_OW 72
63401: ST_TO_ADDR
// for k := 1 to depot do
63402: LD_ADDR_VAR 0 4
63406: PUSH
63407: DOUBLE
63408: LD_INT 1
63410: DEC
63411: ST_TO_ADDR
63412: LD_VAR 0 6
63416: PUSH
63417: FOR_TO
63418: IFFALSE 63988
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
63420: LD_EXP 28
63424: PUSH
63425: LD_VAR 0 2
63429: ARRAY
63430: PUSH
63431: LD_INT 1
63433: ARRAY
63434: PUSH
63435: LD_INT 1
63437: ARRAY
63438: PUSH
63439: LD_INT 0
63441: EQUAL
63442: PUSH
63443: LD_VAR 0 6
63447: PUSH
63448: LD_VAR 0 4
63452: ARRAY
63453: PPUSH
63454: LD_EXP 28
63458: PUSH
63459: LD_VAR 0 2
63463: ARRAY
63464: PUSH
63465: LD_INT 1
63467: ARRAY
63468: PUSH
63469: LD_INT 1
63471: ARRAY
63472: PPUSH
63473: LD_EXP 28
63477: PUSH
63478: LD_VAR 0 2
63482: ARRAY
63483: PUSH
63484: LD_INT 1
63486: ARRAY
63487: PUSH
63488: LD_INT 2
63490: ARRAY
63491: PPUSH
63492: LD_EXP 28
63496: PUSH
63497: LD_VAR 0 2
63501: ARRAY
63502: PUSH
63503: LD_INT 1
63505: ARRAY
63506: PUSH
63507: LD_INT 3
63509: ARRAY
63510: PPUSH
63511: LD_EXP 28
63515: PUSH
63516: LD_VAR 0 2
63520: ARRAY
63521: PUSH
63522: LD_INT 1
63524: ARRAY
63525: PUSH
63526: LD_INT 4
63528: ARRAY
63529: PPUSH
63530: CALL 24249 0 5
63534: OR
63535: IFFALSE 63816
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63537: LD_ADDR_VAR 0 5
63541: PUSH
63542: LD_EXP 23
63546: PUSH
63547: LD_VAR 0 2
63551: ARRAY
63552: PPUSH
63553: LD_INT 25
63555: PUSH
63556: LD_INT 2
63558: PUSH
63559: EMPTY
63560: LIST
63561: LIST
63562: PPUSH
63563: CALL_OW 72
63567: PUSH
63568: LD_EXP 25
63572: PUSH
63573: LD_VAR 0 2
63577: ARRAY
63578: DIFF
63579: ST_TO_ADDR
// if not tmp then
63580: LD_VAR 0 5
63584: NOT
63585: IFFALSE 63589
// continue ;
63587: GO 63417
// for j in tmp do
63589: LD_ADDR_VAR 0 3
63593: PUSH
63594: LD_VAR 0 5
63598: PUSH
63599: FOR_IN
63600: IFFALSE 63812
// begin if not mc_builders [ i ] then
63602: LD_EXP 29
63606: PUSH
63607: LD_VAR 0 2
63611: ARRAY
63612: NOT
63613: IFFALSE 63671
// begin SetTag ( j , 103 ) ;
63615: LD_VAR 0 3
63619: PPUSH
63620: LD_INT 103
63622: PPUSH
63623: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63627: LD_ADDR_EXP 29
63631: PUSH
63632: LD_EXP 29
63636: PPUSH
63637: LD_VAR 0 2
63641: PUSH
63642: LD_EXP 29
63646: PUSH
63647: LD_VAR 0 2
63651: ARRAY
63652: PUSH
63653: LD_INT 1
63655: PLUS
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: PPUSH
63661: LD_VAR 0 3
63665: PPUSH
63666: CALL 16152 0 3
63670: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63671: LD_VAR 0 3
63675: PPUSH
63676: CALL_OW 310
63680: IFFALSE 63691
// ComExitBuilding ( j ) ;
63682: LD_VAR 0 3
63686: PPUSH
63687: CALL_OW 122
// wait ( 3 ) ;
63691: LD_INT 3
63693: PPUSH
63694: CALL_OW 67
// if not mc_build_list [ i ] then
63698: LD_EXP 28
63702: PUSH
63703: LD_VAR 0 2
63707: ARRAY
63708: NOT
63709: IFFALSE 63713
// break ;
63711: GO 63812
// if not HasTask ( j ) then
63713: LD_VAR 0 3
63717: PPUSH
63718: CALL_OW 314
63722: NOT
63723: IFFALSE 63810
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63725: LD_VAR 0 3
63729: PPUSH
63730: LD_EXP 28
63734: PUSH
63735: LD_VAR 0 2
63739: ARRAY
63740: PUSH
63741: LD_INT 1
63743: ARRAY
63744: PUSH
63745: LD_INT 1
63747: ARRAY
63748: PPUSH
63749: LD_EXP 28
63753: PUSH
63754: LD_VAR 0 2
63758: ARRAY
63759: PUSH
63760: LD_INT 1
63762: ARRAY
63763: PUSH
63764: LD_INT 2
63766: ARRAY
63767: PPUSH
63768: LD_EXP 28
63772: PUSH
63773: LD_VAR 0 2
63777: ARRAY
63778: PUSH
63779: LD_INT 1
63781: ARRAY
63782: PUSH
63783: LD_INT 3
63785: ARRAY
63786: PPUSH
63787: LD_EXP 28
63791: PUSH
63792: LD_VAR 0 2
63796: ARRAY
63797: PUSH
63798: LD_INT 1
63800: ARRAY
63801: PUSH
63802: LD_INT 4
63804: ARRAY
63805: PPUSH
63806: CALL_OW 145
// end ;
63810: GO 63599
63812: POP
63813: POP
// end else
63814: GO 63986
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63816: LD_EXP 23
63820: PUSH
63821: LD_VAR 0 2
63825: ARRAY
63826: PPUSH
63827: LD_EXP 28
63831: PUSH
63832: LD_VAR 0 2
63836: ARRAY
63837: PUSH
63838: LD_INT 1
63840: ARRAY
63841: PUSH
63842: LD_INT 1
63844: ARRAY
63845: PPUSH
63846: LD_EXP 28
63850: PUSH
63851: LD_VAR 0 2
63855: ARRAY
63856: PUSH
63857: LD_INT 1
63859: ARRAY
63860: PUSH
63861: LD_INT 2
63863: ARRAY
63864: PPUSH
63865: LD_EXP 28
63869: PUSH
63870: LD_VAR 0 2
63874: ARRAY
63875: PUSH
63876: LD_INT 1
63878: ARRAY
63879: PUSH
63880: LD_INT 3
63882: ARRAY
63883: PPUSH
63884: LD_EXP 28
63888: PUSH
63889: LD_VAR 0 2
63893: ARRAY
63894: PUSH
63895: LD_INT 1
63897: ARRAY
63898: PUSH
63899: LD_INT 4
63901: ARRAY
63902: PPUSH
63903: LD_EXP 23
63907: PUSH
63908: LD_VAR 0 2
63912: ARRAY
63913: PPUSH
63914: LD_INT 21
63916: PUSH
63917: LD_INT 3
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PPUSH
63924: CALL_OW 72
63928: PPUSH
63929: EMPTY
63930: PPUSH
63931: CALL 23003 0 7
63935: NOT
63936: IFFALSE 63986
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63938: LD_ADDR_EXP 28
63942: PUSH
63943: LD_EXP 28
63947: PPUSH
63948: LD_VAR 0 2
63952: PPUSH
63953: LD_EXP 28
63957: PUSH
63958: LD_VAR 0 2
63962: ARRAY
63963: PPUSH
63964: LD_INT 1
63966: PPUSH
63967: LD_INT 1
63969: NEG
63970: PPUSH
63971: LD_INT 0
63973: PPUSH
63974: CALL 15570 0 4
63978: PPUSH
63979: CALL_OW 1
63983: ST_TO_ADDR
// continue ;
63984: GO 63417
// end ; end ;
63986: GO 63417
63988: POP
63989: POP
// end ; end ;
63990: GO 62846
63992: POP
63993: POP
// end ;
63994: LD_VAR 0 1
63998: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63999: LD_INT 0
64001: PPUSH
64002: PPUSH
64003: PPUSH
64004: PPUSH
64005: PPUSH
64006: PPUSH
// if not mc_bases then
64007: LD_EXP 23
64011: NOT
64012: IFFALSE 64016
// exit ;
64014: GO 64443
// for i = 1 to mc_bases do
64016: LD_ADDR_VAR 0 2
64020: PUSH
64021: DOUBLE
64022: LD_INT 1
64024: DEC
64025: ST_TO_ADDR
64026: LD_EXP 23
64030: PUSH
64031: FOR_TO
64032: IFFALSE 64441
// begin tmp := mc_build_upgrade [ i ] ;
64034: LD_ADDR_VAR 0 4
64038: PUSH
64039: LD_EXP 55
64043: PUSH
64044: LD_VAR 0 2
64048: ARRAY
64049: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64050: LD_ADDR_VAR 0 6
64054: PUSH
64055: LD_EXP 56
64059: PUSH
64060: LD_VAR 0 2
64064: ARRAY
64065: PPUSH
64066: LD_INT 2
64068: PUSH
64069: LD_INT 30
64071: PUSH
64072: LD_INT 6
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 30
64081: PUSH
64082: LD_INT 7
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: EMPTY
64090: LIST
64091: LIST
64092: LIST
64093: PPUSH
64094: CALL_OW 72
64098: ST_TO_ADDR
// if not tmp and not lab then
64099: LD_VAR 0 4
64103: NOT
64104: PUSH
64105: LD_VAR 0 6
64109: NOT
64110: AND
64111: IFFALSE 64115
// continue ;
64113: GO 64031
// if tmp then
64115: LD_VAR 0 4
64119: IFFALSE 64239
// for j in tmp do
64121: LD_ADDR_VAR 0 3
64125: PUSH
64126: LD_VAR 0 4
64130: PUSH
64131: FOR_IN
64132: IFFALSE 64237
// begin if UpgradeCost ( j ) then
64134: LD_VAR 0 3
64138: PPUSH
64139: CALL 22663 0 1
64143: IFFALSE 64235
// begin ComUpgrade ( j ) ;
64145: LD_VAR 0 3
64149: PPUSH
64150: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64154: LD_ADDR_EXP 55
64158: PUSH
64159: LD_EXP 55
64163: PPUSH
64164: LD_VAR 0 2
64168: PPUSH
64169: LD_EXP 55
64173: PUSH
64174: LD_VAR 0 2
64178: ARRAY
64179: PUSH
64180: LD_VAR 0 3
64184: DIFF
64185: PPUSH
64186: CALL_OW 1
64190: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64191: LD_ADDR_EXP 30
64195: PUSH
64196: LD_EXP 30
64200: PPUSH
64201: LD_VAR 0 2
64205: PUSH
64206: LD_EXP 30
64210: PUSH
64211: LD_VAR 0 2
64215: ARRAY
64216: PUSH
64217: LD_INT 1
64219: PLUS
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PPUSH
64225: LD_VAR 0 3
64229: PPUSH
64230: CALL 16152 0 3
64234: ST_TO_ADDR
// end ; end ;
64235: GO 64131
64237: POP
64238: POP
// if not lab or not mc_lab_upgrade [ i ] then
64239: LD_VAR 0 6
64243: NOT
64244: PUSH
64245: LD_EXP 57
64249: PUSH
64250: LD_VAR 0 2
64254: ARRAY
64255: NOT
64256: OR
64257: IFFALSE 64261
// continue ;
64259: GO 64031
// for j in lab do
64261: LD_ADDR_VAR 0 3
64265: PUSH
64266: LD_VAR 0 6
64270: PUSH
64271: FOR_IN
64272: IFFALSE 64437
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64274: LD_VAR 0 3
64278: PPUSH
64279: CALL_OW 266
64283: PUSH
64284: LD_INT 6
64286: PUSH
64287: LD_INT 7
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: IN
64294: PUSH
64295: LD_VAR 0 3
64299: PPUSH
64300: CALL_OW 461
64304: PUSH
64305: LD_INT 1
64307: NONEQUAL
64308: AND
64309: IFFALSE 64435
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64311: LD_VAR 0 3
64315: PPUSH
64316: LD_EXP 57
64320: PUSH
64321: LD_VAR 0 2
64325: ARRAY
64326: PUSH
64327: LD_INT 1
64329: ARRAY
64330: PPUSH
64331: CALL 22868 0 2
64335: IFFALSE 64435
// begin ComCancel ( j ) ;
64337: LD_VAR 0 3
64341: PPUSH
64342: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64346: LD_VAR 0 3
64350: PPUSH
64351: LD_EXP 57
64355: PUSH
64356: LD_VAR 0 2
64360: ARRAY
64361: PUSH
64362: LD_INT 1
64364: ARRAY
64365: PPUSH
64366: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64370: LD_VAR 0 3
64374: PUSH
64375: LD_EXP 30
64379: PUSH
64380: LD_VAR 0 2
64384: ARRAY
64385: IN
64386: NOT
64387: IFFALSE 64433
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64389: LD_ADDR_EXP 30
64393: PUSH
64394: LD_EXP 30
64398: PPUSH
64399: LD_VAR 0 2
64403: PUSH
64404: LD_EXP 30
64408: PUSH
64409: LD_VAR 0 2
64413: ARRAY
64414: PUSH
64415: LD_INT 1
64417: PLUS
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PPUSH
64423: LD_VAR 0 3
64427: PPUSH
64428: CALL 16152 0 3
64432: ST_TO_ADDR
// break ;
64433: GO 64437
// end ; end ; end ;
64435: GO 64271
64437: POP
64438: POP
// end ;
64439: GO 64031
64441: POP
64442: POP
// end ;
64443: LD_VAR 0 1
64447: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64448: LD_INT 0
64450: PPUSH
64451: PPUSH
64452: PPUSH
64453: PPUSH
64454: PPUSH
64455: PPUSH
64456: PPUSH
64457: PPUSH
64458: PPUSH
// if not mc_bases then
64459: LD_EXP 23
64463: NOT
64464: IFFALSE 64468
// exit ;
64466: GO 64873
// for i = 1 to mc_bases do
64468: LD_ADDR_VAR 0 2
64472: PUSH
64473: DOUBLE
64474: LD_INT 1
64476: DEC
64477: ST_TO_ADDR
64478: LD_EXP 23
64482: PUSH
64483: FOR_TO
64484: IFFALSE 64871
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64486: LD_EXP 31
64490: PUSH
64491: LD_VAR 0 2
64495: ARRAY
64496: NOT
64497: PUSH
64498: LD_EXP 23
64502: PUSH
64503: LD_VAR 0 2
64507: ARRAY
64508: PPUSH
64509: LD_INT 30
64511: PUSH
64512: LD_INT 3
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PPUSH
64519: CALL_OW 72
64523: NOT
64524: OR
64525: IFFALSE 64529
// continue ;
64527: GO 64483
// busy := false ;
64529: LD_ADDR_VAR 0 8
64533: PUSH
64534: LD_INT 0
64536: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64537: LD_ADDR_VAR 0 4
64541: PUSH
64542: LD_EXP 23
64546: PUSH
64547: LD_VAR 0 2
64551: ARRAY
64552: PPUSH
64553: LD_INT 30
64555: PUSH
64556: LD_INT 3
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PPUSH
64563: CALL_OW 72
64567: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64568: LD_ADDR_VAR 0 6
64572: PUSH
64573: LD_EXP 31
64577: PUSH
64578: LD_VAR 0 2
64582: ARRAY
64583: PPUSH
64584: LD_INT 2
64586: PUSH
64587: LD_INT 30
64589: PUSH
64590: LD_INT 32
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_INT 30
64599: PUSH
64600: LD_INT 33
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: LIST
64611: PPUSH
64612: CALL_OW 72
64616: ST_TO_ADDR
// if not t then
64617: LD_VAR 0 6
64621: NOT
64622: IFFALSE 64626
// continue ;
64624: GO 64483
// for j in tmp do
64626: LD_ADDR_VAR 0 3
64630: PUSH
64631: LD_VAR 0 4
64635: PUSH
64636: FOR_IN
64637: IFFALSE 64667
// if not BuildingStatus ( j ) = bs_idle then
64639: LD_VAR 0 3
64643: PPUSH
64644: CALL_OW 461
64648: PUSH
64649: LD_INT 2
64651: EQUAL
64652: NOT
64653: IFFALSE 64665
// begin busy := true ;
64655: LD_ADDR_VAR 0 8
64659: PUSH
64660: LD_INT 1
64662: ST_TO_ADDR
// break ;
64663: GO 64667
// end ;
64665: GO 64636
64667: POP
64668: POP
// if busy then
64669: LD_VAR 0 8
64673: IFFALSE 64677
// continue ;
64675: GO 64483
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64677: LD_ADDR_VAR 0 7
64681: PUSH
64682: LD_VAR 0 6
64686: PPUSH
64687: LD_INT 35
64689: PUSH
64690: LD_INT 0
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PPUSH
64697: CALL_OW 72
64701: ST_TO_ADDR
// if tw then
64702: LD_VAR 0 7
64706: IFFALSE 64783
// begin tw := tw [ 1 ] ;
64708: LD_ADDR_VAR 0 7
64712: PUSH
64713: LD_VAR 0 7
64717: PUSH
64718: LD_INT 1
64720: ARRAY
64721: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64722: LD_ADDR_VAR 0 9
64726: PUSH
64727: LD_VAR 0 7
64731: PPUSH
64732: LD_EXP 48
64736: PUSH
64737: LD_VAR 0 2
64741: ARRAY
64742: PPUSH
64743: CALL 21160 0 2
64747: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64748: LD_EXP 62
64752: PUSH
64753: LD_VAR 0 2
64757: ARRAY
64758: IFFALSE 64781
// if not weapon in mc_allowed_tower_weapons [ i ] then
64760: LD_VAR 0 9
64764: PUSH
64765: LD_EXP 62
64769: PUSH
64770: LD_VAR 0 2
64774: ARRAY
64775: IN
64776: NOT
64777: IFFALSE 64781
// continue ;
64779: GO 64483
// end else
64781: GO 64846
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64783: LD_ADDR_VAR 0 5
64787: PUSH
64788: LD_EXP 31
64792: PUSH
64793: LD_VAR 0 2
64797: ARRAY
64798: PPUSH
64799: LD_VAR 0 4
64803: PPUSH
64804: CALL 48012 0 2
64808: ST_TO_ADDR
// if not tmp2 then
64809: LD_VAR 0 5
64813: NOT
64814: IFFALSE 64818
// continue ;
64816: GO 64483
// tw := tmp2 [ 1 ] ;
64818: LD_ADDR_VAR 0 7
64822: PUSH
64823: LD_VAR 0 5
64827: PUSH
64828: LD_INT 1
64830: ARRAY
64831: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64832: LD_ADDR_VAR 0 9
64836: PUSH
64837: LD_VAR 0 5
64841: PUSH
64842: LD_INT 2
64844: ARRAY
64845: ST_TO_ADDR
// end ; if not weapon then
64846: LD_VAR 0 9
64850: NOT
64851: IFFALSE 64855
// continue ;
64853: GO 64483
// ComPlaceWeapon ( tw , weapon ) ;
64855: LD_VAR 0 7
64859: PPUSH
64860: LD_VAR 0 9
64864: PPUSH
64865: CALL_OW 148
// end ;
64869: GO 64483
64871: POP
64872: POP
// end ;
64873: LD_VAR 0 1
64877: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64878: LD_INT 0
64880: PPUSH
64881: PPUSH
64882: PPUSH
64883: PPUSH
64884: PPUSH
64885: PPUSH
64886: PPUSH
// if not mc_bases then
64887: LD_EXP 23
64891: NOT
64892: IFFALSE 64896
// exit ;
64894: GO 65664
// for i = 1 to mc_bases do
64896: LD_ADDR_VAR 0 2
64900: PUSH
64901: DOUBLE
64902: LD_INT 1
64904: DEC
64905: ST_TO_ADDR
64906: LD_EXP 23
64910: PUSH
64911: FOR_TO
64912: IFFALSE 65662
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64914: LD_EXP 36
64918: PUSH
64919: LD_VAR 0 2
64923: ARRAY
64924: NOT
64925: PUSH
64926: LD_EXP 36
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: PUSH
64937: LD_EXP 37
64941: PUSH
64942: LD_VAR 0 2
64946: ARRAY
64947: EQUAL
64948: OR
64949: PUSH
64950: LD_EXP 46
64954: PUSH
64955: LD_VAR 0 2
64959: ARRAY
64960: OR
64961: IFFALSE 64965
// continue ;
64963: GO 64911
// if mc_miners [ i ] then
64965: LD_EXP 37
64969: PUSH
64970: LD_VAR 0 2
64974: ARRAY
64975: IFFALSE 65349
// begin for j = mc_miners [ i ] downto 1 do
64977: LD_ADDR_VAR 0 3
64981: PUSH
64982: DOUBLE
64983: LD_EXP 37
64987: PUSH
64988: LD_VAR 0 2
64992: ARRAY
64993: INC
64994: ST_TO_ADDR
64995: LD_INT 1
64997: PUSH
64998: FOR_DOWNTO
64999: IFFALSE 65347
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65001: LD_EXP 37
65005: PUSH
65006: LD_VAR 0 2
65010: ARRAY
65011: PUSH
65012: LD_VAR 0 3
65016: ARRAY
65017: PPUSH
65018: CALL_OW 301
65022: PUSH
65023: LD_EXP 37
65027: PUSH
65028: LD_VAR 0 2
65032: ARRAY
65033: PUSH
65034: LD_VAR 0 3
65038: ARRAY
65039: PPUSH
65040: CALL_OW 257
65044: PUSH
65045: LD_INT 1
65047: NONEQUAL
65048: OR
65049: IFFALSE 65112
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65051: LD_ADDR_VAR 0 5
65055: PUSH
65056: LD_EXP 37
65060: PUSH
65061: LD_VAR 0 2
65065: ARRAY
65066: PUSH
65067: LD_EXP 37
65071: PUSH
65072: LD_VAR 0 2
65076: ARRAY
65077: PUSH
65078: LD_VAR 0 3
65082: ARRAY
65083: DIFF
65084: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65085: LD_ADDR_EXP 37
65089: PUSH
65090: LD_EXP 37
65094: PPUSH
65095: LD_VAR 0 2
65099: PPUSH
65100: LD_VAR 0 5
65104: PPUSH
65105: CALL_OW 1
65109: ST_TO_ADDR
// continue ;
65110: GO 64998
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65112: LD_EXP 37
65116: PUSH
65117: LD_VAR 0 2
65121: ARRAY
65122: PUSH
65123: LD_VAR 0 3
65127: ARRAY
65128: PPUSH
65129: CALL_OW 257
65133: PUSH
65134: LD_INT 1
65136: EQUAL
65137: PUSH
65138: LD_EXP 37
65142: PUSH
65143: LD_VAR 0 2
65147: ARRAY
65148: PUSH
65149: LD_VAR 0 3
65153: ARRAY
65154: PPUSH
65155: CALL_OW 459
65159: NOT
65160: AND
65161: PUSH
65162: LD_EXP 37
65166: PUSH
65167: LD_VAR 0 2
65171: ARRAY
65172: PUSH
65173: LD_VAR 0 3
65177: ARRAY
65178: PPUSH
65179: CALL_OW 314
65183: NOT
65184: AND
65185: IFFALSE 65345
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65187: LD_EXP 37
65191: PUSH
65192: LD_VAR 0 2
65196: ARRAY
65197: PUSH
65198: LD_VAR 0 3
65202: ARRAY
65203: PPUSH
65204: CALL_OW 310
65208: IFFALSE 65231
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65210: LD_EXP 37
65214: PUSH
65215: LD_VAR 0 2
65219: ARRAY
65220: PUSH
65221: LD_VAR 0 3
65225: ARRAY
65226: PPUSH
65227: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65231: LD_EXP 37
65235: PUSH
65236: LD_VAR 0 2
65240: ARRAY
65241: PUSH
65242: LD_VAR 0 3
65246: ARRAY
65247: PPUSH
65248: CALL_OW 314
65252: NOT
65253: IFFALSE 65345
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65255: LD_ADDR_VAR 0 7
65259: PUSH
65260: LD_INT 1
65262: PPUSH
65263: LD_EXP 36
65267: PUSH
65268: LD_VAR 0 2
65272: ARRAY
65273: PPUSH
65274: CALL_OW 12
65278: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65279: LD_EXP 37
65283: PUSH
65284: LD_VAR 0 2
65288: ARRAY
65289: PUSH
65290: LD_VAR 0 3
65294: ARRAY
65295: PPUSH
65296: LD_EXP 36
65300: PUSH
65301: LD_VAR 0 2
65305: ARRAY
65306: PUSH
65307: LD_VAR 0 7
65311: ARRAY
65312: PUSH
65313: LD_INT 1
65315: ARRAY
65316: PPUSH
65317: LD_EXP 36
65321: PUSH
65322: LD_VAR 0 2
65326: ARRAY
65327: PUSH
65328: LD_VAR 0 7
65332: ARRAY
65333: PUSH
65334: LD_INT 2
65336: ARRAY
65337: PPUSH
65338: LD_INT 0
65340: PPUSH
65341: CALL_OW 193
// end ; end ; end ;
65345: GO 64998
65347: POP
65348: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65349: LD_ADDR_VAR 0 5
65353: PUSH
65354: LD_EXP 23
65358: PUSH
65359: LD_VAR 0 2
65363: ARRAY
65364: PPUSH
65365: LD_INT 2
65367: PUSH
65368: LD_INT 30
65370: PUSH
65371: LD_INT 4
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: LD_INT 30
65380: PUSH
65381: LD_INT 5
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: PUSH
65388: LD_INT 30
65390: PUSH
65391: LD_INT 32
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: EMPTY
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: PPUSH
65404: CALL_OW 72
65408: ST_TO_ADDR
// if not tmp then
65409: LD_VAR 0 5
65413: NOT
65414: IFFALSE 65418
// continue ;
65416: GO 64911
// list := [ ] ;
65418: LD_ADDR_VAR 0 6
65422: PUSH
65423: EMPTY
65424: ST_TO_ADDR
// for j in tmp do
65425: LD_ADDR_VAR 0 3
65429: PUSH
65430: LD_VAR 0 5
65434: PUSH
65435: FOR_IN
65436: IFFALSE 65505
// begin for k in UnitsInside ( j ) do
65438: LD_ADDR_VAR 0 4
65442: PUSH
65443: LD_VAR 0 3
65447: PPUSH
65448: CALL_OW 313
65452: PUSH
65453: FOR_IN
65454: IFFALSE 65501
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65456: LD_VAR 0 4
65460: PPUSH
65461: CALL_OW 257
65465: PUSH
65466: LD_INT 1
65468: EQUAL
65469: PUSH
65470: LD_VAR 0 4
65474: PPUSH
65475: CALL_OW 459
65479: NOT
65480: AND
65481: IFFALSE 65499
// list := list ^ k ;
65483: LD_ADDR_VAR 0 6
65487: PUSH
65488: LD_VAR 0 6
65492: PUSH
65493: LD_VAR 0 4
65497: ADD
65498: ST_TO_ADDR
65499: GO 65453
65501: POP
65502: POP
// end ;
65503: GO 65435
65505: POP
65506: POP
// list := list diff mc_miners [ i ] ;
65507: LD_ADDR_VAR 0 6
65511: PUSH
65512: LD_VAR 0 6
65516: PUSH
65517: LD_EXP 37
65521: PUSH
65522: LD_VAR 0 2
65526: ARRAY
65527: DIFF
65528: ST_TO_ADDR
// if not list then
65529: LD_VAR 0 6
65533: NOT
65534: IFFALSE 65538
// continue ;
65536: GO 64911
// k := mc_mines [ i ] - mc_miners [ i ] ;
65538: LD_ADDR_VAR 0 4
65542: PUSH
65543: LD_EXP 36
65547: PUSH
65548: LD_VAR 0 2
65552: ARRAY
65553: PUSH
65554: LD_EXP 37
65558: PUSH
65559: LD_VAR 0 2
65563: ARRAY
65564: MINUS
65565: ST_TO_ADDR
// if k > list then
65566: LD_VAR 0 4
65570: PUSH
65571: LD_VAR 0 6
65575: GREATER
65576: IFFALSE 65588
// k := list ;
65578: LD_ADDR_VAR 0 4
65582: PUSH
65583: LD_VAR 0 6
65587: ST_TO_ADDR
// for j = 1 to k do
65588: LD_ADDR_VAR 0 3
65592: PUSH
65593: DOUBLE
65594: LD_INT 1
65596: DEC
65597: ST_TO_ADDR
65598: LD_VAR 0 4
65602: PUSH
65603: FOR_TO
65604: IFFALSE 65658
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65606: LD_ADDR_EXP 37
65610: PUSH
65611: LD_EXP 37
65615: PPUSH
65616: LD_VAR 0 2
65620: PUSH
65621: LD_EXP 37
65625: PUSH
65626: LD_VAR 0 2
65630: ARRAY
65631: PUSH
65632: LD_INT 1
65634: PLUS
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PPUSH
65640: LD_VAR 0 6
65644: PUSH
65645: LD_VAR 0 3
65649: ARRAY
65650: PPUSH
65651: CALL 16152 0 3
65655: ST_TO_ADDR
65656: GO 65603
65658: POP
65659: POP
// end ;
65660: GO 64911
65662: POP
65663: POP
// end ;
65664: LD_VAR 0 1
65668: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65669: LD_INT 0
65671: PPUSH
65672: PPUSH
65673: PPUSH
65674: PPUSH
65675: PPUSH
65676: PPUSH
65677: PPUSH
65678: PPUSH
65679: PPUSH
65680: PPUSH
65681: PPUSH
// if not mc_bases then
65682: LD_EXP 23
65686: NOT
65687: IFFALSE 65691
// exit ;
65689: GO 67514
// for i = 1 to mc_bases do
65691: LD_ADDR_VAR 0 2
65695: PUSH
65696: DOUBLE
65697: LD_INT 1
65699: DEC
65700: ST_TO_ADDR
65701: LD_EXP 23
65705: PUSH
65706: FOR_TO
65707: IFFALSE 67512
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65709: LD_EXP 23
65713: PUSH
65714: LD_VAR 0 2
65718: ARRAY
65719: NOT
65720: PUSH
65721: LD_EXP 30
65725: PUSH
65726: LD_VAR 0 2
65730: ARRAY
65731: OR
65732: IFFALSE 65736
// continue ;
65734: GO 65706
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65736: LD_EXP 39
65740: PUSH
65741: LD_VAR 0 2
65745: ARRAY
65746: NOT
65747: PUSH
65748: LD_EXP 40
65752: PUSH
65753: LD_VAR 0 2
65757: ARRAY
65758: AND
65759: IFFALSE 65797
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65761: LD_ADDR_EXP 40
65765: PUSH
65766: LD_EXP 40
65770: PPUSH
65771: LD_VAR 0 2
65775: PPUSH
65776: EMPTY
65777: PPUSH
65778: CALL_OW 1
65782: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65783: LD_VAR 0 2
65787: PPUSH
65788: LD_INT 107
65790: PPUSH
65791: CALL 56544 0 2
// continue ;
65795: GO 65706
// end ; target := [ ] ;
65797: LD_ADDR_VAR 0 7
65801: PUSH
65802: EMPTY
65803: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65804: LD_ADDR_VAR 0 6
65808: PUSH
65809: LD_EXP 23
65813: PUSH
65814: LD_VAR 0 2
65818: ARRAY
65819: PUSH
65820: LD_INT 1
65822: ARRAY
65823: PPUSH
65824: CALL_OW 255
65828: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65829: LD_ADDR_VAR 0 9
65833: PUSH
65834: LD_EXP 23
65838: PUSH
65839: LD_VAR 0 2
65843: ARRAY
65844: PPUSH
65845: LD_INT 2
65847: PUSH
65848: LD_INT 30
65850: PUSH
65851: LD_INT 0
65853: PUSH
65854: EMPTY
65855: LIST
65856: LIST
65857: PUSH
65858: LD_INT 30
65860: PUSH
65861: LD_INT 1
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: LIST
65872: PPUSH
65873: CALL_OW 72
65877: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65878: LD_ADDR_VAR 0 3
65882: PUSH
65883: DOUBLE
65884: LD_EXP 39
65888: PUSH
65889: LD_VAR 0 2
65893: ARRAY
65894: INC
65895: ST_TO_ADDR
65896: LD_INT 1
65898: PUSH
65899: FOR_DOWNTO
65900: IFFALSE 66145
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65902: LD_EXP 39
65906: PUSH
65907: LD_VAR 0 2
65911: ARRAY
65912: PUSH
65913: LD_VAR 0 3
65917: ARRAY
65918: PUSH
65919: LD_INT 2
65921: ARRAY
65922: PPUSH
65923: LD_EXP 39
65927: PUSH
65928: LD_VAR 0 2
65932: ARRAY
65933: PUSH
65934: LD_VAR 0 3
65938: ARRAY
65939: PUSH
65940: LD_INT 3
65942: ARRAY
65943: PPUSH
65944: CALL_OW 488
65948: PUSH
65949: LD_EXP 39
65953: PUSH
65954: LD_VAR 0 2
65958: ARRAY
65959: PUSH
65960: LD_VAR 0 3
65964: ARRAY
65965: PUSH
65966: LD_INT 2
65968: ARRAY
65969: PPUSH
65970: LD_EXP 39
65974: PUSH
65975: LD_VAR 0 2
65979: ARRAY
65980: PUSH
65981: LD_VAR 0 3
65985: ARRAY
65986: PUSH
65987: LD_INT 3
65989: ARRAY
65990: PPUSH
65991: CALL_OW 284
65995: PUSH
65996: LD_INT 0
65998: EQUAL
65999: AND
66000: IFFALSE 66055
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66002: LD_ADDR_VAR 0 5
66006: PUSH
66007: LD_EXP 39
66011: PUSH
66012: LD_VAR 0 2
66016: ARRAY
66017: PPUSH
66018: LD_VAR 0 3
66022: PPUSH
66023: CALL_OW 3
66027: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66028: LD_ADDR_EXP 39
66032: PUSH
66033: LD_EXP 39
66037: PPUSH
66038: LD_VAR 0 2
66042: PPUSH
66043: LD_VAR 0 5
66047: PPUSH
66048: CALL_OW 1
66052: ST_TO_ADDR
// continue ;
66053: GO 65899
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66055: LD_VAR 0 6
66059: PPUSH
66060: LD_EXP 39
66064: PUSH
66065: LD_VAR 0 2
66069: ARRAY
66070: PUSH
66071: LD_VAR 0 3
66075: ARRAY
66076: PUSH
66077: LD_INT 2
66079: ARRAY
66080: PPUSH
66081: LD_EXP 39
66085: PUSH
66086: LD_VAR 0 2
66090: ARRAY
66091: PUSH
66092: LD_VAR 0 3
66096: ARRAY
66097: PUSH
66098: LD_INT 3
66100: ARRAY
66101: PPUSH
66102: LD_INT 30
66104: PPUSH
66105: CALL 17048 0 4
66109: PUSH
66110: LD_INT 4
66112: ARRAY
66113: PUSH
66114: LD_INT 0
66116: EQUAL
66117: IFFALSE 66143
// begin target := mc_crates [ i ] [ j ] ;
66119: LD_ADDR_VAR 0 7
66123: PUSH
66124: LD_EXP 39
66128: PUSH
66129: LD_VAR 0 2
66133: ARRAY
66134: PUSH
66135: LD_VAR 0 3
66139: ARRAY
66140: ST_TO_ADDR
// break ;
66141: GO 66145
// end ; end ;
66143: GO 65899
66145: POP
66146: POP
// if not target then
66147: LD_VAR 0 7
66151: NOT
66152: IFFALSE 66156
// continue ;
66154: GO 65706
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66156: LD_ADDR_VAR 0 8
66160: PUSH
66161: LD_EXP 42
66165: PUSH
66166: LD_VAR 0 2
66170: ARRAY
66171: PPUSH
66172: LD_INT 2
66174: PUSH
66175: LD_INT 3
66177: PUSH
66178: LD_INT 58
66180: PUSH
66181: EMPTY
66182: LIST
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: LD_INT 61
66190: PUSH
66191: EMPTY
66192: LIST
66193: PUSH
66194: LD_INT 33
66196: PUSH
66197: LD_INT 5
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 33
66206: PUSH
66207: LD_INT 3
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: PUSH
66221: LD_INT 2
66223: PUSH
66224: LD_INT 34
66226: PUSH
66227: LD_INT 32
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 34
66236: PUSH
66237: LD_INT 51
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 34
66246: PUSH
66247: LD_INT 12
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PPUSH
66264: CALL_OW 72
66268: ST_TO_ADDR
// if not cargo then
66269: LD_VAR 0 8
66273: NOT
66274: IFFALSE 66980
// begin if mc_crates_collector [ i ] < 5 then
66276: LD_EXP 40
66280: PUSH
66281: LD_VAR 0 2
66285: ARRAY
66286: PUSH
66287: LD_INT 5
66289: LESS
66290: IFFALSE 66656
// begin if mc_ape [ i ] then
66292: LD_EXP 52
66296: PUSH
66297: LD_VAR 0 2
66301: ARRAY
66302: IFFALSE 66349
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66304: LD_ADDR_VAR 0 5
66308: PUSH
66309: LD_EXP 52
66313: PUSH
66314: LD_VAR 0 2
66318: ARRAY
66319: PPUSH
66320: LD_INT 25
66322: PUSH
66323: LD_INT 16
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 24
66332: PUSH
66333: LD_INT 750
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PUSH
66340: EMPTY
66341: LIST
66342: LIST
66343: PPUSH
66344: CALL_OW 72
66348: ST_TO_ADDR
// if not tmp then
66349: LD_VAR 0 5
66353: NOT
66354: IFFALSE 66401
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66356: LD_ADDR_VAR 0 5
66360: PUSH
66361: LD_EXP 23
66365: PUSH
66366: LD_VAR 0 2
66370: ARRAY
66371: PPUSH
66372: LD_INT 25
66374: PUSH
66375: LD_INT 2
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 24
66384: PUSH
66385: LD_INT 750
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PPUSH
66396: CALL_OW 72
66400: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66401: LD_EXP 52
66405: PUSH
66406: LD_VAR 0 2
66410: ARRAY
66411: PUSH
66412: LD_EXP 23
66416: PUSH
66417: LD_VAR 0 2
66421: ARRAY
66422: PPUSH
66423: LD_INT 25
66425: PUSH
66426: LD_INT 2
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 24
66435: PUSH
66436: LD_INT 750
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PPUSH
66447: CALL_OW 72
66451: AND
66452: PUSH
66453: LD_VAR 0 5
66457: PUSH
66458: LD_INT 5
66460: LESS
66461: AND
66462: IFFALSE 66544
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66464: LD_ADDR_VAR 0 3
66468: PUSH
66469: LD_EXP 23
66473: PUSH
66474: LD_VAR 0 2
66478: ARRAY
66479: PPUSH
66480: LD_INT 25
66482: PUSH
66483: LD_INT 2
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: PUSH
66490: LD_INT 24
66492: PUSH
66493: LD_INT 750
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PPUSH
66504: CALL_OW 72
66508: PUSH
66509: FOR_IN
66510: IFFALSE 66542
// begin tmp := tmp union j ;
66512: LD_ADDR_VAR 0 5
66516: PUSH
66517: LD_VAR 0 5
66521: PUSH
66522: LD_VAR 0 3
66526: UNION
66527: ST_TO_ADDR
// if tmp >= 5 then
66528: LD_VAR 0 5
66532: PUSH
66533: LD_INT 5
66535: GREATEREQUAL
66536: IFFALSE 66540
// break ;
66538: GO 66542
// end ;
66540: GO 66509
66542: POP
66543: POP
// end ; if not tmp then
66544: LD_VAR 0 5
66548: NOT
66549: IFFALSE 66553
// continue ;
66551: GO 65706
// for j in tmp do
66553: LD_ADDR_VAR 0 3
66557: PUSH
66558: LD_VAR 0 5
66562: PUSH
66563: FOR_IN
66564: IFFALSE 66654
// if not GetTag ( j ) then
66566: LD_VAR 0 3
66570: PPUSH
66571: CALL_OW 110
66575: NOT
66576: IFFALSE 66652
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66578: LD_ADDR_EXP 40
66582: PUSH
66583: LD_EXP 40
66587: PPUSH
66588: LD_VAR 0 2
66592: PUSH
66593: LD_EXP 40
66597: PUSH
66598: LD_VAR 0 2
66602: ARRAY
66603: PUSH
66604: LD_INT 1
66606: PLUS
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PPUSH
66612: LD_VAR 0 3
66616: PPUSH
66617: CALL 16152 0 3
66621: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66622: LD_VAR 0 3
66626: PPUSH
66627: LD_INT 107
66629: PPUSH
66630: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66634: LD_EXP 40
66638: PUSH
66639: LD_VAR 0 2
66643: ARRAY
66644: PUSH
66645: LD_INT 5
66647: GREATEREQUAL
66648: IFFALSE 66652
// break ;
66650: GO 66654
// end ;
66652: GO 66563
66654: POP
66655: POP
// end ; if mc_crates_collector [ i ] and target then
66656: LD_EXP 40
66660: PUSH
66661: LD_VAR 0 2
66665: ARRAY
66666: PUSH
66667: LD_VAR 0 7
66671: AND
66672: IFFALSE 66978
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66674: LD_EXP 40
66678: PUSH
66679: LD_VAR 0 2
66683: ARRAY
66684: PUSH
66685: LD_VAR 0 7
66689: PUSH
66690: LD_INT 1
66692: ARRAY
66693: LESS
66694: IFFALSE 66714
// tmp := mc_crates_collector [ i ] else
66696: LD_ADDR_VAR 0 5
66700: PUSH
66701: LD_EXP 40
66705: PUSH
66706: LD_VAR 0 2
66710: ARRAY
66711: ST_TO_ADDR
66712: GO 66728
// tmp := target [ 1 ] ;
66714: LD_ADDR_VAR 0 5
66718: PUSH
66719: LD_VAR 0 7
66723: PUSH
66724: LD_INT 1
66726: ARRAY
66727: ST_TO_ADDR
// k := 0 ;
66728: LD_ADDR_VAR 0 4
66732: PUSH
66733: LD_INT 0
66735: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66736: LD_ADDR_VAR 0 3
66740: PUSH
66741: LD_EXP 40
66745: PUSH
66746: LD_VAR 0 2
66750: ARRAY
66751: PUSH
66752: FOR_IN
66753: IFFALSE 66976
// begin k := k + 1 ;
66755: LD_ADDR_VAR 0 4
66759: PUSH
66760: LD_VAR 0 4
66764: PUSH
66765: LD_INT 1
66767: PLUS
66768: ST_TO_ADDR
// if k > tmp then
66769: LD_VAR 0 4
66773: PUSH
66774: LD_VAR 0 5
66778: GREATER
66779: IFFALSE 66783
// break ;
66781: GO 66976
// if not GetClass ( j ) in [ 2 , 16 ] then
66783: LD_VAR 0 3
66787: PPUSH
66788: CALL_OW 257
66792: PUSH
66793: LD_INT 2
66795: PUSH
66796: LD_INT 16
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: IN
66803: NOT
66804: IFFALSE 66857
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66806: LD_ADDR_EXP 40
66810: PUSH
66811: LD_EXP 40
66815: PPUSH
66816: LD_VAR 0 2
66820: PPUSH
66821: LD_EXP 40
66825: PUSH
66826: LD_VAR 0 2
66830: ARRAY
66831: PUSH
66832: LD_VAR 0 3
66836: DIFF
66837: PPUSH
66838: CALL_OW 1
66842: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66843: LD_VAR 0 3
66847: PPUSH
66848: LD_INT 0
66850: PPUSH
66851: CALL_OW 109
// continue ;
66855: GO 66752
// end ; if IsInUnit ( j ) then
66857: LD_VAR 0 3
66861: PPUSH
66862: CALL_OW 310
66866: IFFALSE 66877
// ComExitBuilding ( j ) ;
66868: LD_VAR 0 3
66872: PPUSH
66873: CALL_OW 122
// wait ( 3 ) ;
66877: LD_INT 3
66879: PPUSH
66880: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66884: LD_VAR 0 3
66888: PPUSH
66889: CALL_OW 314
66893: PUSH
66894: LD_VAR 0 6
66898: PPUSH
66899: LD_VAR 0 7
66903: PUSH
66904: LD_INT 2
66906: ARRAY
66907: PPUSH
66908: LD_VAR 0 7
66912: PUSH
66913: LD_INT 3
66915: ARRAY
66916: PPUSH
66917: LD_INT 30
66919: PPUSH
66920: CALL 17048 0 4
66924: PUSH
66925: LD_INT 4
66927: ARRAY
66928: AND
66929: IFFALSE 66947
// ComStandNearbyBuilding ( j , depot ) else
66931: LD_VAR 0 3
66935: PPUSH
66936: LD_VAR 0 9
66940: PPUSH
66941: CALL 12579 0 2
66945: GO 66974
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66947: LD_VAR 0 3
66951: PPUSH
66952: LD_VAR 0 7
66956: PUSH
66957: LD_INT 2
66959: ARRAY
66960: PPUSH
66961: LD_VAR 0 7
66965: PUSH
66966: LD_INT 3
66968: ARRAY
66969: PPUSH
66970: CALL_OW 117
// end ;
66974: GO 66752
66976: POP
66977: POP
// end ; end else
66978: GO 67510
// begin for j in cargo do
66980: LD_ADDR_VAR 0 3
66984: PUSH
66985: LD_VAR 0 8
66989: PUSH
66990: FOR_IN
66991: IFFALSE 67508
// begin if GetTag ( j ) <> 0 then
66993: LD_VAR 0 3
66997: PPUSH
66998: CALL_OW 110
67002: PUSH
67003: LD_INT 0
67005: NONEQUAL
67006: IFFALSE 67010
// continue ;
67008: GO 66990
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67010: LD_VAR 0 3
67014: PPUSH
67015: CALL_OW 256
67019: PUSH
67020: LD_INT 1000
67022: LESS
67023: PUSH
67024: LD_VAR 0 3
67028: PPUSH
67029: LD_EXP 47
67033: PUSH
67034: LD_VAR 0 2
67038: ARRAY
67039: PPUSH
67040: CALL_OW 308
67044: NOT
67045: AND
67046: IFFALSE 67068
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67048: LD_VAR 0 3
67052: PPUSH
67053: LD_EXP 47
67057: PUSH
67058: LD_VAR 0 2
67062: ARRAY
67063: PPUSH
67064: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67068: LD_VAR 0 3
67072: PPUSH
67073: CALL_OW 256
67077: PUSH
67078: LD_INT 1000
67080: LESS
67081: PUSH
67082: LD_VAR 0 3
67086: PPUSH
67087: LD_EXP 47
67091: PUSH
67092: LD_VAR 0 2
67096: ARRAY
67097: PPUSH
67098: CALL_OW 308
67102: AND
67103: IFFALSE 67107
// continue ;
67105: GO 66990
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67107: LD_VAR 0 3
67111: PPUSH
67112: CALL_OW 262
67116: PUSH
67117: LD_INT 2
67119: EQUAL
67120: PUSH
67121: LD_VAR 0 3
67125: PPUSH
67126: CALL_OW 261
67130: PUSH
67131: LD_INT 15
67133: LESS
67134: AND
67135: IFFALSE 67139
// continue ;
67137: GO 66990
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67139: LD_VAR 0 3
67143: PPUSH
67144: CALL_OW 262
67148: PUSH
67149: LD_INT 1
67151: EQUAL
67152: PUSH
67153: LD_VAR 0 3
67157: PPUSH
67158: CALL_OW 261
67162: PUSH
67163: LD_INT 10
67165: LESS
67166: AND
67167: IFFALSE 67447
// begin if not depot then
67169: LD_VAR 0 9
67173: NOT
67174: IFFALSE 67178
// continue ;
67176: GO 66990
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67178: LD_VAR 0 3
67182: PPUSH
67183: LD_VAR 0 9
67187: PPUSH
67188: LD_VAR 0 3
67192: PPUSH
67193: CALL_OW 74
67197: PPUSH
67198: CALL_OW 296
67202: PUSH
67203: LD_INT 6
67205: LESS
67206: IFFALSE 67222
// SetFuel ( j , 100 ) else
67208: LD_VAR 0 3
67212: PPUSH
67213: LD_INT 100
67215: PPUSH
67216: CALL_OW 240
67220: GO 67447
// if GetFuel ( j ) = 0 then
67222: LD_VAR 0 3
67226: PPUSH
67227: CALL_OW 261
67231: PUSH
67232: LD_INT 0
67234: EQUAL
67235: IFFALSE 67447
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67237: LD_ADDR_EXP 42
67241: PUSH
67242: LD_EXP 42
67246: PPUSH
67247: LD_VAR 0 2
67251: PPUSH
67252: LD_EXP 42
67256: PUSH
67257: LD_VAR 0 2
67261: ARRAY
67262: PUSH
67263: LD_VAR 0 3
67267: DIFF
67268: PPUSH
67269: CALL_OW 1
67273: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67274: LD_VAR 0 3
67278: PPUSH
67279: CALL_OW 263
67283: PUSH
67284: LD_INT 1
67286: EQUAL
67287: IFFALSE 67303
// ComExitVehicle ( IsInUnit ( j ) ) ;
67289: LD_VAR 0 3
67293: PPUSH
67294: CALL_OW 310
67298: PPUSH
67299: CALL_OW 121
// if GetControl ( j ) = control_remote then
67303: LD_VAR 0 3
67307: PPUSH
67308: CALL_OW 263
67312: PUSH
67313: LD_INT 2
67315: EQUAL
67316: IFFALSE 67327
// ComUnlink ( j ) ;
67318: LD_VAR 0 3
67322: PPUSH
67323: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67327: LD_ADDR_VAR 0 10
67331: PUSH
67332: LD_VAR 0 2
67336: PPUSH
67337: LD_INT 3
67339: PPUSH
67340: CALL 77114 0 2
67344: ST_TO_ADDR
// if fac then
67345: LD_VAR 0 10
67349: IFFALSE 67445
// begin for k in fac do
67351: LD_ADDR_VAR 0 4
67355: PUSH
67356: LD_VAR 0 10
67360: PUSH
67361: FOR_IN
67362: IFFALSE 67443
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67364: LD_ADDR_VAR 0 11
67368: PUSH
67369: LD_VAR 0 10
67373: PPUSH
67374: LD_VAR 0 3
67378: PPUSH
67379: CALL_OW 265
67383: PPUSH
67384: LD_VAR 0 3
67388: PPUSH
67389: CALL_OW 262
67393: PPUSH
67394: LD_VAR 0 3
67398: PPUSH
67399: CALL_OW 263
67403: PPUSH
67404: LD_VAR 0 3
67408: PPUSH
67409: CALL_OW 264
67413: PPUSH
67414: CALL 13650 0 5
67418: ST_TO_ADDR
// if components then
67419: LD_VAR 0 11
67423: IFFALSE 67441
// begin MC_InsertProduceList ( i , components ) ;
67425: LD_VAR 0 2
67429: PPUSH
67430: LD_VAR 0 11
67434: PPUSH
67435: CALL 76659 0 2
// break ;
67439: GO 67443
// end ; end ;
67441: GO 67361
67443: POP
67444: POP
// end ; continue ;
67445: GO 66990
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67447: LD_VAR 0 3
67451: PPUSH
67452: LD_INT 1
67454: PPUSH
67455: CALL_OW 289
67459: PUSH
67460: LD_INT 100
67462: LESS
67463: PUSH
67464: LD_VAR 0 3
67468: PPUSH
67469: CALL_OW 314
67473: NOT
67474: AND
67475: IFFALSE 67504
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67477: LD_VAR 0 3
67481: PPUSH
67482: LD_VAR 0 7
67486: PUSH
67487: LD_INT 2
67489: ARRAY
67490: PPUSH
67491: LD_VAR 0 7
67495: PUSH
67496: LD_INT 3
67498: ARRAY
67499: PPUSH
67500: CALL_OW 117
// break ;
67504: GO 67508
// end ;
67506: GO 66990
67508: POP
67509: POP
// end ; end ;
67510: GO 65706
67512: POP
67513: POP
// end ;
67514: LD_VAR 0 1
67518: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67519: LD_INT 0
67521: PPUSH
67522: PPUSH
67523: PPUSH
67524: PPUSH
// if not mc_bases then
67525: LD_EXP 23
67529: NOT
67530: IFFALSE 67534
// exit ;
67532: GO 67695
// for i = 1 to mc_bases do
67534: LD_ADDR_VAR 0 2
67538: PUSH
67539: DOUBLE
67540: LD_INT 1
67542: DEC
67543: ST_TO_ADDR
67544: LD_EXP 23
67548: PUSH
67549: FOR_TO
67550: IFFALSE 67693
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67552: LD_ADDR_VAR 0 4
67556: PUSH
67557: LD_EXP 42
67561: PUSH
67562: LD_VAR 0 2
67566: ARRAY
67567: PUSH
67568: LD_EXP 45
67572: PUSH
67573: LD_VAR 0 2
67577: ARRAY
67578: UNION
67579: PPUSH
67580: LD_INT 33
67582: PUSH
67583: LD_INT 2
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PPUSH
67590: CALL_OW 72
67594: ST_TO_ADDR
// if tmp then
67595: LD_VAR 0 4
67599: IFFALSE 67691
// for j in tmp do
67601: LD_ADDR_VAR 0 3
67605: PUSH
67606: LD_VAR 0 4
67610: PUSH
67611: FOR_IN
67612: IFFALSE 67689
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67614: LD_VAR 0 3
67618: PPUSH
67619: CALL_OW 312
67623: NOT
67624: PUSH
67625: LD_VAR 0 3
67629: PPUSH
67630: CALL_OW 256
67634: PUSH
67635: LD_INT 250
67637: GREATEREQUAL
67638: AND
67639: IFFALSE 67652
// Connect ( j ) else
67641: LD_VAR 0 3
67645: PPUSH
67646: CALL 19121 0 1
67650: GO 67687
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67652: LD_VAR 0 3
67656: PPUSH
67657: CALL_OW 256
67661: PUSH
67662: LD_INT 250
67664: LESS
67665: PUSH
67666: LD_VAR 0 3
67670: PPUSH
67671: CALL_OW 312
67675: AND
67676: IFFALSE 67687
// ComUnlink ( j ) ;
67678: LD_VAR 0 3
67682: PPUSH
67683: CALL_OW 136
67687: GO 67611
67689: POP
67690: POP
// end ;
67691: GO 67549
67693: POP
67694: POP
// end ;
67695: LD_VAR 0 1
67699: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67700: LD_INT 0
67702: PPUSH
67703: PPUSH
67704: PPUSH
67705: PPUSH
67706: PPUSH
// if not mc_bases then
67707: LD_EXP 23
67711: NOT
67712: IFFALSE 67716
// exit ;
67714: GO 68161
// for i = 1 to mc_bases do
67716: LD_ADDR_VAR 0 2
67720: PUSH
67721: DOUBLE
67722: LD_INT 1
67724: DEC
67725: ST_TO_ADDR
67726: LD_EXP 23
67730: PUSH
67731: FOR_TO
67732: IFFALSE 68159
// begin if not mc_produce [ i ] then
67734: LD_EXP 44
67738: PUSH
67739: LD_VAR 0 2
67743: ARRAY
67744: NOT
67745: IFFALSE 67749
// continue ;
67747: GO 67731
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67749: LD_ADDR_VAR 0 5
67753: PUSH
67754: LD_EXP 23
67758: PUSH
67759: LD_VAR 0 2
67763: ARRAY
67764: PPUSH
67765: LD_INT 30
67767: PUSH
67768: LD_INT 3
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: PPUSH
67775: CALL_OW 72
67779: ST_TO_ADDR
// if not fac then
67780: LD_VAR 0 5
67784: NOT
67785: IFFALSE 67789
// continue ;
67787: GO 67731
// for j in fac do
67789: LD_ADDR_VAR 0 3
67793: PUSH
67794: LD_VAR 0 5
67798: PUSH
67799: FOR_IN
67800: IFFALSE 68155
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67802: LD_VAR 0 3
67806: PPUSH
67807: CALL_OW 461
67811: PUSH
67812: LD_INT 2
67814: NONEQUAL
67815: PUSH
67816: LD_VAR 0 3
67820: PPUSH
67821: LD_INT 15
67823: PPUSH
67824: CALL 18749 0 2
67828: PUSH
67829: LD_INT 4
67831: ARRAY
67832: OR
67833: IFFALSE 67837
// continue ;
67835: GO 67799
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67837: LD_VAR 0 3
67841: PPUSH
67842: LD_EXP 44
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PUSH
67853: LD_INT 1
67855: ARRAY
67856: PUSH
67857: LD_INT 1
67859: ARRAY
67860: PPUSH
67861: LD_EXP 44
67865: PUSH
67866: LD_VAR 0 2
67870: ARRAY
67871: PUSH
67872: LD_INT 1
67874: ARRAY
67875: PUSH
67876: LD_INT 2
67878: ARRAY
67879: PPUSH
67880: LD_EXP 44
67884: PUSH
67885: LD_VAR 0 2
67889: ARRAY
67890: PUSH
67891: LD_INT 1
67893: ARRAY
67894: PUSH
67895: LD_INT 3
67897: ARRAY
67898: PPUSH
67899: LD_EXP 44
67903: PUSH
67904: LD_VAR 0 2
67908: ARRAY
67909: PUSH
67910: LD_INT 1
67912: ARRAY
67913: PUSH
67914: LD_INT 4
67916: ARRAY
67917: PPUSH
67918: CALL_OW 448
67922: PUSH
67923: LD_VAR 0 3
67927: PPUSH
67928: LD_EXP 44
67932: PUSH
67933: LD_VAR 0 2
67937: ARRAY
67938: PUSH
67939: LD_INT 1
67941: ARRAY
67942: PUSH
67943: LD_INT 1
67945: ARRAY
67946: PUSH
67947: LD_EXP 44
67951: PUSH
67952: LD_VAR 0 2
67956: ARRAY
67957: PUSH
67958: LD_INT 1
67960: ARRAY
67961: PUSH
67962: LD_INT 2
67964: ARRAY
67965: PUSH
67966: LD_EXP 44
67970: PUSH
67971: LD_VAR 0 2
67975: ARRAY
67976: PUSH
67977: LD_INT 1
67979: ARRAY
67980: PUSH
67981: LD_INT 3
67983: ARRAY
67984: PUSH
67985: LD_EXP 44
67989: PUSH
67990: LD_VAR 0 2
67994: ARRAY
67995: PUSH
67996: LD_INT 1
67998: ARRAY
67999: PUSH
68000: LD_INT 4
68002: ARRAY
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: PPUSH
68010: CALL 22516 0 2
68014: AND
68015: IFFALSE 68153
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68017: LD_VAR 0 3
68021: PPUSH
68022: LD_EXP 44
68026: PUSH
68027: LD_VAR 0 2
68031: ARRAY
68032: PUSH
68033: LD_INT 1
68035: ARRAY
68036: PUSH
68037: LD_INT 1
68039: ARRAY
68040: PPUSH
68041: LD_EXP 44
68045: PUSH
68046: LD_VAR 0 2
68050: ARRAY
68051: PUSH
68052: LD_INT 1
68054: ARRAY
68055: PUSH
68056: LD_INT 2
68058: ARRAY
68059: PPUSH
68060: LD_EXP 44
68064: PUSH
68065: LD_VAR 0 2
68069: ARRAY
68070: PUSH
68071: LD_INT 1
68073: ARRAY
68074: PUSH
68075: LD_INT 3
68077: ARRAY
68078: PPUSH
68079: LD_EXP 44
68083: PUSH
68084: LD_VAR 0 2
68088: ARRAY
68089: PUSH
68090: LD_INT 1
68092: ARRAY
68093: PUSH
68094: LD_INT 4
68096: ARRAY
68097: PPUSH
68098: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68102: LD_ADDR_VAR 0 4
68106: PUSH
68107: LD_EXP 44
68111: PUSH
68112: LD_VAR 0 2
68116: ARRAY
68117: PPUSH
68118: LD_INT 1
68120: PPUSH
68121: CALL_OW 3
68125: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68126: LD_ADDR_EXP 44
68130: PUSH
68131: LD_EXP 44
68135: PPUSH
68136: LD_VAR 0 2
68140: PPUSH
68141: LD_VAR 0 4
68145: PPUSH
68146: CALL_OW 1
68150: ST_TO_ADDR
// break ;
68151: GO 68155
// end ; end ;
68153: GO 67799
68155: POP
68156: POP
// end ;
68157: GO 67731
68159: POP
68160: POP
// end ;
68161: LD_VAR 0 1
68165: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68166: LD_INT 0
68168: PPUSH
68169: PPUSH
68170: PPUSH
// if not mc_bases then
68171: LD_EXP 23
68175: NOT
68176: IFFALSE 68180
// exit ;
68178: GO 68269
// for i = 1 to mc_bases do
68180: LD_ADDR_VAR 0 2
68184: PUSH
68185: DOUBLE
68186: LD_INT 1
68188: DEC
68189: ST_TO_ADDR
68190: LD_EXP 23
68194: PUSH
68195: FOR_TO
68196: IFFALSE 68267
// begin if mc_attack [ i ] then
68198: LD_EXP 43
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: IFFALSE 68265
// begin tmp := mc_attack [ i ] [ 1 ] ;
68210: LD_ADDR_VAR 0 3
68214: PUSH
68215: LD_EXP 43
68219: PUSH
68220: LD_VAR 0 2
68224: ARRAY
68225: PUSH
68226: LD_INT 1
68228: ARRAY
68229: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68230: LD_ADDR_EXP 43
68234: PUSH
68235: LD_EXP 43
68239: PPUSH
68240: LD_VAR 0 2
68244: PPUSH
68245: EMPTY
68246: PPUSH
68247: CALL_OW 1
68251: ST_TO_ADDR
// Attack ( tmp ) ;
68252: LD_VAR 0 3
68256: PPUSH
68257: CALL 83047 0 1
// exit ;
68261: POP
68262: POP
68263: GO 68269
// end ; end ;
68265: GO 68195
68267: POP
68268: POP
// end ;
68269: LD_VAR 0 1
68273: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68274: LD_INT 0
68276: PPUSH
68277: PPUSH
68278: PPUSH
68279: PPUSH
68280: PPUSH
68281: PPUSH
68282: PPUSH
// if not mc_bases then
68283: LD_EXP 23
68287: NOT
68288: IFFALSE 68292
// exit ;
68290: GO 69149
// for i = 1 to mc_bases do
68292: LD_ADDR_VAR 0 2
68296: PUSH
68297: DOUBLE
68298: LD_INT 1
68300: DEC
68301: ST_TO_ADDR
68302: LD_EXP 23
68306: PUSH
68307: FOR_TO
68308: IFFALSE 69147
// begin if not mc_bases [ i ] then
68310: LD_EXP 23
68314: PUSH
68315: LD_VAR 0 2
68319: ARRAY
68320: NOT
68321: IFFALSE 68325
// continue ;
68323: GO 68307
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68325: LD_ADDR_VAR 0 7
68329: PUSH
68330: LD_EXP 23
68334: PUSH
68335: LD_VAR 0 2
68339: ARRAY
68340: PUSH
68341: LD_INT 1
68343: ARRAY
68344: PPUSH
68345: CALL 12801 0 1
68349: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68350: LD_ADDR_EXP 46
68354: PUSH
68355: LD_EXP 46
68359: PPUSH
68360: LD_VAR 0 2
68364: PPUSH
68365: LD_EXP 23
68369: PUSH
68370: LD_VAR 0 2
68374: ARRAY
68375: PUSH
68376: LD_INT 1
68378: ARRAY
68379: PPUSH
68380: CALL_OW 255
68384: PPUSH
68385: LD_EXP 48
68389: PUSH
68390: LD_VAR 0 2
68394: ARRAY
68395: PPUSH
68396: CALL 12766 0 2
68400: PPUSH
68401: CALL_OW 1
68405: ST_TO_ADDR
// if not mc_scan [ i ] then
68406: LD_EXP 46
68410: PUSH
68411: LD_VAR 0 2
68415: ARRAY
68416: NOT
68417: IFFALSE 68595
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68419: LD_ADDR_EXP 66
68423: PUSH
68424: LD_EXP 66
68428: PPUSH
68429: LD_VAR 0 2
68433: PPUSH
68434: LD_INT 0
68436: PPUSH
68437: CALL_OW 1
68441: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68442: LD_ADDR_VAR 0 4
68446: PUSH
68447: LD_EXP 23
68451: PUSH
68452: LD_VAR 0 2
68456: ARRAY
68457: PPUSH
68458: LD_INT 2
68460: PUSH
68461: LD_INT 25
68463: PUSH
68464: LD_INT 5
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 25
68473: PUSH
68474: LD_INT 8
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PUSH
68481: LD_INT 25
68483: PUSH
68484: LD_INT 9
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: PPUSH
68497: CALL_OW 72
68501: ST_TO_ADDR
// if not tmp then
68502: LD_VAR 0 4
68506: NOT
68507: IFFALSE 68511
// continue ;
68509: GO 68307
// for j in tmp do
68511: LD_ADDR_VAR 0 3
68515: PUSH
68516: LD_VAR 0 4
68520: PUSH
68521: FOR_IN
68522: IFFALSE 68593
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68524: LD_VAR 0 3
68528: PPUSH
68529: CALL_OW 310
68533: PPUSH
68534: CALL_OW 266
68538: PUSH
68539: LD_INT 5
68541: EQUAL
68542: PUSH
68543: LD_VAR 0 3
68547: PPUSH
68548: CALL_OW 257
68552: PUSH
68553: LD_INT 1
68555: EQUAL
68556: AND
68557: PUSH
68558: LD_VAR 0 3
68562: PPUSH
68563: CALL_OW 459
68567: NOT
68568: AND
68569: PUSH
68570: LD_VAR 0 7
68574: AND
68575: IFFALSE 68591
// ComChangeProfession ( j , class ) ;
68577: LD_VAR 0 3
68581: PPUSH
68582: LD_VAR 0 7
68586: PPUSH
68587: CALL_OW 123
68591: GO 68521
68593: POP
68594: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68595: LD_EXP 46
68599: PUSH
68600: LD_VAR 0 2
68604: ARRAY
68605: PUSH
68606: LD_EXP 66
68610: PUSH
68611: LD_VAR 0 2
68615: ARRAY
68616: NOT
68617: AND
68618: PUSH
68619: LD_EXP 45
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: NOT
68630: AND
68631: PUSH
68632: LD_EXP 23
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: PPUSH
68643: LD_INT 50
68645: PUSH
68646: EMPTY
68647: LIST
68648: PUSH
68649: LD_INT 2
68651: PUSH
68652: LD_INT 30
68654: PUSH
68655: LD_INT 32
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 30
68664: PUSH
68665: LD_INT 33
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PUSH
68672: LD_INT 30
68674: PUSH
68675: LD_INT 4
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 30
68684: PUSH
68685: LD_INT 5
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PPUSH
68703: CALL_OW 72
68707: PUSH
68708: LD_INT 4
68710: LESS
68711: PUSH
68712: LD_EXP 23
68716: PUSH
68717: LD_VAR 0 2
68721: ARRAY
68722: PPUSH
68723: LD_INT 3
68725: PUSH
68726: LD_INT 24
68728: PUSH
68729: LD_INT 1000
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 2
68742: PUSH
68743: LD_INT 30
68745: PUSH
68746: LD_INT 0
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: LD_INT 30
68755: PUSH
68756: LD_INT 1
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: LIST
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PPUSH
68772: CALL_OW 72
68776: OR
68777: AND
68778: IFFALSE 69029
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68780: LD_ADDR_EXP 66
68784: PUSH
68785: LD_EXP 66
68789: PPUSH
68790: LD_VAR 0 2
68794: PPUSH
68795: LD_INT 1
68797: PPUSH
68798: CALL_OW 1
68802: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68803: LD_ADDR_VAR 0 4
68807: PUSH
68808: LD_EXP 23
68812: PUSH
68813: LD_VAR 0 2
68817: ARRAY
68818: PPUSH
68819: LD_INT 2
68821: PUSH
68822: LD_INT 25
68824: PUSH
68825: LD_INT 1
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 25
68834: PUSH
68835: LD_INT 5
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 25
68844: PUSH
68845: LD_INT 8
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 25
68854: PUSH
68855: LD_INT 9
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: PPUSH
68869: CALL_OW 72
68873: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68874: LD_ADDR_VAR 0 4
68878: PUSH
68879: LD_VAR 0 4
68883: PUSH
68884: LD_VAR 0 4
68888: PPUSH
68889: LD_INT 18
68891: PPUSH
68892: CALL 46038 0 2
68896: DIFF
68897: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68898: LD_VAR 0 4
68902: NOT
68903: PUSH
68904: LD_EXP 23
68908: PUSH
68909: LD_VAR 0 2
68913: ARRAY
68914: PPUSH
68915: LD_INT 2
68917: PUSH
68918: LD_INT 30
68920: PUSH
68921: LD_INT 4
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 30
68930: PUSH
68931: LD_INT 5
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: LIST
68942: PPUSH
68943: CALL_OW 72
68947: NOT
68948: AND
68949: IFFALSE 69011
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68951: LD_ADDR_VAR 0 4
68955: PUSH
68956: LD_EXP 23
68960: PUSH
68961: LD_VAR 0 2
68965: ARRAY
68966: PPUSH
68967: LD_INT 2
68969: PUSH
68970: LD_INT 25
68972: PUSH
68973: LD_INT 2
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 25
68982: PUSH
68983: LD_INT 3
68985: PUSH
68986: EMPTY
68987: LIST
68988: LIST
68989: PUSH
68990: LD_INT 25
68992: PUSH
68993: LD_INT 4
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: PPUSH
69006: CALL_OW 72
69010: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
69011: LD_VAR 0 2
69015: PPUSH
69016: LD_VAR 0 4
69020: PPUSH
69021: CALL 87756 0 2
// exit ;
69025: POP
69026: POP
69027: GO 69149
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69029: LD_EXP 46
69033: PUSH
69034: LD_VAR 0 2
69038: ARRAY
69039: PUSH
69040: LD_EXP 66
69044: PUSH
69045: LD_VAR 0 2
69049: ARRAY
69050: NOT
69051: AND
69052: PUSH
69053: LD_EXP 45
69057: PUSH
69058: LD_VAR 0 2
69062: ARRAY
69063: AND
69064: IFFALSE 69145
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69066: LD_ADDR_EXP 66
69070: PUSH
69071: LD_EXP 66
69075: PPUSH
69076: LD_VAR 0 2
69080: PPUSH
69081: LD_INT 1
69083: PPUSH
69084: CALL_OW 1
69088: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
69089: LD_ADDR_VAR 0 4
69093: PUSH
69094: LD_EXP 45
69098: PUSH
69099: LD_VAR 0 2
69103: ARRAY
69104: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69105: LD_ADDR_EXP 45
69109: PUSH
69110: LD_EXP 45
69114: PPUSH
69115: LD_VAR 0 2
69119: PPUSH
69120: EMPTY
69121: PPUSH
69122: CALL_OW 1
69126: ST_TO_ADDR
// Defend ( i , tmp ) ;
69127: LD_VAR 0 2
69131: PPUSH
69132: LD_VAR 0 4
69136: PPUSH
69137: CALL 88352 0 2
// exit ;
69141: POP
69142: POP
69143: GO 69149
// end ; end ;
69145: GO 68307
69147: POP
69148: POP
// end ;
69149: LD_VAR 0 1
69153: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69154: LD_INT 0
69156: PPUSH
69157: PPUSH
69158: PPUSH
69159: PPUSH
69160: PPUSH
69161: PPUSH
69162: PPUSH
69163: PPUSH
69164: PPUSH
69165: PPUSH
69166: PPUSH
// if not mc_bases then
69167: LD_EXP 23
69171: NOT
69172: IFFALSE 69176
// exit ;
69174: GO 70263
// for i = 1 to mc_bases do
69176: LD_ADDR_VAR 0 2
69180: PUSH
69181: DOUBLE
69182: LD_INT 1
69184: DEC
69185: ST_TO_ADDR
69186: LD_EXP 23
69190: PUSH
69191: FOR_TO
69192: IFFALSE 70261
// begin tmp := mc_lab [ i ] ;
69194: LD_ADDR_VAR 0 6
69198: PUSH
69199: LD_EXP 56
69203: PUSH
69204: LD_VAR 0 2
69208: ARRAY
69209: ST_TO_ADDR
// if not tmp then
69210: LD_VAR 0 6
69214: NOT
69215: IFFALSE 69219
// continue ;
69217: GO 69191
// idle_lab := 0 ;
69219: LD_ADDR_VAR 0 11
69223: PUSH
69224: LD_INT 0
69226: ST_TO_ADDR
// for j in tmp do
69227: LD_ADDR_VAR 0 3
69231: PUSH
69232: LD_VAR 0 6
69236: PUSH
69237: FOR_IN
69238: IFFALSE 70257
// begin researching := false ;
69240: LD_ADDR_VAR 0 10
69244: PUSH
69245: LD_INT 0
69247: ST_TO_ADDR
// side := GetSide ( j ) ;
69248: LD_ADDR_VAR 0 4
69252: PUSH
69253: LD_VAR 0 3
69257: PPUSH
69258: CALL_OW 255
69262: ST_TO_ADDR
// if not mc_tech [ side ] then
69263: LD_EXP 50
69267: PUSH
69268: LD_VAR 0 4
69272: ARRAY
69273: NOT
69274: IFFALSE 69278
// continue ;
69276: GO 69237
// if BuildingStatus ( j ) = bs_idle then
69278: LD_VAR 0 3
69282: PPUSH
69283: CALL_OW 461
69287: PUSH
69288: LD_INT 2
69290: EQUAL
69291: IFFALSE 69479
// begin if idle_lab and UnitsInside ( j ) < 6 then
69293: LD_VAR 0 11
69297: PUSH
69298: LD_VAR 0 3
69302: PPUSH
69303: CALL_OW 313
69307: PUSH
69308: LD_INT 6
69310: LESS
69311: AND
69312: IFFALSE 69383
// begin tmp2 := UnitsInside ( idle_lab ) ;
69314: LD_ADDR_VAR 0 9
69318: PUSH
69319: LD_VAR 0 11
69323: PPUSH
69324: CALL_OW 313
69328: ST_TO_ADDR
// if tmp2 then
69329: LD_VAR 0 9
69333: IFFALSE 69375
// for x in tmp2 do
69335: LD_ADDR_VAR 0 7
69339: PUSH
69340: LD_VAR 0 9
69344: PUSH
69345: FOR_IN
69346: IFFALSE 69373
// begin ComExitBuilding ( x ) ;
69348: LD_VAR 0 7
69352: PPUSH
69353: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69357: LD_VAR 0 7
69361: PPUSH
69362: LD_VAR 0 3
69366: PPUSH
69367: CALL_OW 180
// end ;
69371: GO 69345
69373: POP
69374: POP
// idle_lab := 0 ;
69375: LD_ADDR_VAR 0 11
69379: PUSH
69380: LD_INT 0
69382: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69383: LD_ADDR_VAR 0 5
69387: PUSH
69388: LD_EXP 50
69392: PUSH
69393: LD_VAR 0 4
69397: ARRAY
69398: PUSH
69399: FOR_IN
69400: IFFALSE 69460
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69402: LD_VAR 0 3
69406: PPUSH
69407: LD_VAR 0 5
69411: PPUSH
69412: CALL_OW 430
69416: PUSH
69417: LD_VAR 0 4
69421: PPUSH
69422: LD_VAR 0 5
69426: PPUSH
69427: CALL 11871 0 2
69431: AND
69432: IFFALSE 69458
// begin researching := true ;
69434: LD_ADDR_VAR 0 10
69438: PUSH
69439: LD_INT 1
69441: ST_TO_ADDR
// ComResearch ( j , t ) ;
69442: LD_VAR 0 3
69446: PPUSH
69447: LD_VAR 0 5
69451: PPUSH
69452: CALL_OW 124
// break ;
69456: GO 69460
// end ;
69458: GO 69399
69460: POP
69461: POP
// if not researching then
69462: LD_VAR 0 10
69466: NOT
69467: IFFALSE 69479
// idle_lab := j ;
69469: LD_ADDR_VAR 0 11
69473: PUSH
69474: LD_VAR 0 3
69478: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69479: LD_VAR 0 3
69483: PPUSH
69484: CALL_OW 461
69488: PUSH
69489: LD_INT 10
69491: EQUAL
69492: IFFALSE 70080
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69494: LD_EXP 52
69498: PUSH
69499: LD_VAR 0 2
69503: ARRAY
69504: NOT
69505: PUSH
69506: LD_EXP 53
69510: PUSH
69511: LD_VAR 0 2
69515: ARRAY
69516: NOT
69517: AND
69518: PUSH
69519: LD_EXP 50
69523: PUSH
69524: LD_VAR 0 4
69528: ARRAY
69529: PUSH
69530: LD_INT 1
69532: GREATER
69533: AND
69534: IFFALSE 69665
// begin ComCancel ( j ) ;
69536: LD_VAR 0 3
69540: PPUSH
69541: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69545: LD_ADDR_EXP 50
69549: PUSH
69550: LD_EXP 50
69554: PPUSH
69555: LD_VAR 0 4
69559: PPUSH
69560: LD_EXP 50
69564: PUSH
69565: LD_VAR 0 4
69569: ARRAY
69570: PPUSH
69571: LD_EXP 50
69575: PUSH
69576: LD_VAR 0 4
69580: ARRAY
69581: PUSH
69582: LD_INT 1
69584: MINUS
69585: PPUSH
69586: LD_EXP 50
69590: PUSH
69591: LD_VAR 0 4
69595: ARRAY
69596: PPUSH
69597: LD_INT 0
69599: PPUSH
69600: CALL 15570 0 4
69604: PPUSH
69605: CALL_OW 1
69609: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69610: LD_ADDR_EXP 50
69614: PUSH
69615: LD_EXP 50
69619: PPUSH
69620: LD_VAR 0 4
69624: PPUSH
69625: LD_EXP 50
69629: PUSH
69630: LD_VAR 0 4
69634: ARRAY
69635: PPUSH
69636: LD_EXP 50
69640: PUSH
69641: LD_VAR 0 4
69645: ARRAY
69646: PPUSH
69647: LD_INT 1
69649: PPUSH
69650: LD_INT 0
69652: PPUSH
69653: CALL 15570 0 4
69657: PPUSH
69658: CALL_OW 1
69662: ST_TO_ADDR
// continue ;
69663: GO 69237
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69665: LD_EXP 52
69669: PUSH
69670: LD_VAR 0 2
69674: ARRAY
69675: PUSH
69676: LD_EXP 53
69680: PUSH
69681: LD_VAR 0 2
69685: ARRAY
69686: NOT
69687: AND
69688: IFFALSE 69815
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69690: LD_ADDR_EXP 53
69694: PUSH
69695: LD_EXP 53
69699: PPUSH
69700: LD_VAR 0 2
69704: PUSH
69705: LD_EXP 53
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_INT 1
69718: PLUS
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PPUSH
69724: LD_EXP 52
69728: PUSH
69729: LD_VAR 0 2
69733: ARRAY
69734: PUSH
69735: LD_INT 1
69737: ARRAY
69738: PPUSH
69739: CALL 16152 0 3
69743: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69744: LD_EXP 52
69748: PUSH
69749: LD_VAR 0 2
69753: ARRAY
69754: PUSH
69755: LD_INT 1
69757: ARRAY
69758: PPUSH
69759: LD_INT 112
69761: PPUSH
69762: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69766: LD_ADDR_VAR 0 9
69770: PUSH
69771: LD_EXP 52
69775: PUSH
69776: LD_VAR 0 2
69780: ARRAY
69781: PPUSH
69782: LD_INT 1
69784: PPUSH
69785: CALL_OW 3
69789: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69790: LD_ADDR_EXP 52
69794: PUSH
69795: LD_EXP 52
69799: PPUSH
69800: LD_VAR 0 2
69804: PPUSH
69805: LD_VAR 0 9
69809: PPUSH
69810: CALL_OW 1
69814: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69815: LD_EXP 52
69819: PUSH
69820: LD_VAR 0 2
69824: ARRAY
69825: PUSH
69826: LD_EXP 53
69830: PUSH
69831: LD_VAR 0 2
69835: ARRAY
69836: AND
69837: PUSH
69838: LD_EXP 53
69842: PUSH
69843: LD_VAR 0 2
69847: ARRAY
69848: PUSH
69849: LD_INT 1
69851: ARRAY
69852: PPUSH
69853: CALL_OW 310
69857: NOT
69858: AND
69859: PUSH
69860: LD_VAR 0 3
69864: PPUSH
69865: CALL_OW 313
69869: PUSH
69870: LD_INT 6
69872: EQUAL
69873: AND
69874: IFFALSE 69930
// begin tmp2 := UnitsInside ( j ) ;
69876: LD_ADDR_VAR 0 9
69880: PUSH
69881: LD_VAR 0 3
69885: PPUSH
69886: CALL_OW 313
69890: ST_TO_ADDR
// if tmp2 = 6 then
69891: LD_VAR 0 9
69895: PUSH
69896: LD_INT 6
69898: EQUAL
69899: IFFALSE 69930
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69901: LD_VAR 0 9
69905: PUSH
69906: LD_INT 1
69908: ARRAY
69909: PPUSH
69910: LD_INT 112
69912: PPUSH
69913: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69917: LD_VAR 0 9
69921: PUSH
69922: LD_INT 1
69924: ARRAY
69925: PPUSH
69926: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69930: LD_EXP 53
69934: PUSH
69935: LD_VAR 0 2
69939: ARRAY
69940: PUSH
69941: LD_EXP 53
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PUSH
69952: LD_INT 1
69954: ARRAY
69955: PPUSH
69956: CALL_OW 314
69960: NOT
69961: AND
69962: PUSH
69963: LD_EXP 53
69967: PUSH
69968: LD_VAR 0 2
69972: ARRAY
69973: PUSH
69974: LD_INT 1
69976: ARRAY
69977: PPUSH
69978: CALL_OW 310
69982: NOT
69983: AND
69984: IFFALSE 70010
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69986: LD_EXP 53
69990: PUSH
69991: LD_VAR 0 2
69995: ARRAY
69996: PUSH
69997: LD_INT 1
69999: ARRAY
70000: PPUSH
70001: LD_VAR 0 3
70005: PPUSH
70006: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70010: LD_EXP 53
70014: PUSH
70015: LD_VAR 0 2
70019: ARRAY
70020: PUSH
70021: LD_INT 1
70023: ARRAY
70024: PPUSH
70025: CALL_OW 310
70029: PUSH
70030: LD_EXP 53
70034: PUSH
70035: LD_VAR 0 2
70039: ARRAY
70040: PUSH
70041: LD_INT 1
70043: ARRAY
70044: PPUSH
70045: CALL_OW 310
70049: PPUSH
70050: CALL_OW 461
70054: PUSH
70055: LD_INT 3
70057: NONEQUAL
70058: AND
70059: IFFALSE 70080
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70061: LD_EXP 53
70065: PUSH
70066: LD_VAR 0 2
70070: ARRAY
70071: PUSH
70072: LD_INT 1
70074: ARRAY
70075: PPUSH
70076: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70080: LD_VAR 0 3
70084: PPUSH
70085: CALL_OW 461
70089: PUSH
70090: LD_INT 6
70092: EQUAL
70093: PUSH
70094: LD_VAR 0 6
70098: PUSH
70099: LD_INT 1
70101: GREATER
70102: AND
70103: IFFALSE 70255
// begin sci := [ ] ;
70105: LD_ADDR_VAR 0 8
70109: PUSH
70110: EMPTY
70111: ST_TO_ADDR
// for x in ( tmp diff j ) do
70112: LD_ADDR_VAR 0 7
70116: PUSH
70117: LD_VAR 0 6
70121: PUSH
70122: LD_VAR 0 3
70126: DIFF
70127: PUSH
70128: FOR_IN
70129: IFFALSE 70181
// begin if sci = 6 then
70131: LD_VAR 0 8
70135: PUSH
70136: LD_INT 6
70138: EQUAL
70139: IFFALSE 70143
// break ;
70141: GO 70181
// if BuildingStatus ( x ) = bs_idle then
70143: LD_VAR 0 7
70147: PPUSH
70148: CALL_OW 461
70152: PUSH
70153: LD_INT 2
70155: EQUAL
70156: IFFALSE 70179
// sci := sci ^ UnitsInside ( x ) ;
70158: LD_ADDR_VAR 0 8
70162: PUSH
70163: LD_VAR 0 8
70167: PUSH
70168: LD_VAR 0 7
70172: PPUSH
70173: CALL_OW 313
70177: ADD
70178: ST_TO_ADDR
// end ;
70179: GO 70128
70181: POP
70182: POP
// if not sci then
70183: LD_VAR 0 8
70187: NOT
70188: IFFALSE 70192
// continue ;
70190: GO 69237
// for x in sci do
70192: LD_ADDR_VAR 0 7
70196: PUSH
70197: LD_VAR 0 8
70201: PUSH
70202: FOR_IN
70203: IFFALSE 70253
// if IsInUnit ( x ) and not HasTask ( x ) then
70205: LD_VAR 0 7
70209: PPUSH
70210: CALL_OW 310
70214: PUSH
70215: LD_VAR 0 7
70219: PPUSH
70220: CALL_OW 314
70224: NOT
70225: AND
70226: IFFALSE 70251
// begin ComExitBuilding ( x ) ;
70228: LD_VAR 0 7
70232: PPUSH
70233: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70237: LD_VAR 0 7
70241: PPUSH
70242: LD_VAR 0 3
70246: PPUSH
70247: CALL_OW 180
// end ;
70251: GO 70202
70253: POP
70254: POP
// end ; end ;
70255: GO 69237
70257: POP
70258: POP
// end ;
70259: GO 69191
70261: POP
70262: POP
// end ;
70263: LD_VAR 0 1
70267: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70268: LD_INT 0
70270: PPUSH
70271: PPUSH
// if not mc_bases then
70272: LD_EXP 23
70276: NOT
70277: IFFALSE 70281
// exit ;
70279: GO 70362
// for i = 1 to mc_bases do
70281: LD_ADDR_VAR 0 2
70285: PUSH
70286: DOUBLE
70287: LD_INT 1
70289: DEC
70290: ST_TO_ADDR
70291: LD_EXP 23
70295: PUSH
70296: FOR_TO
70297: IFFALSE 70360
// if mc_mines [ i ] and mc_miners [ i ] then
70299: LD_EXP 36
70303: PUSH
70304: LD_VAR 0 2
70308: ARRAY
70309: PUSH
70310: LD_EXP 37
70314: PUSH
70315: LD_VAR 0 2
70319: ARRAY
70320: AND
70321: IFFALSE 70358
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70323: LD_EXP 37
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: PUSH
70334: LD_INT 1
70336: ARRAY
70337: PPUSH
70338: CALL_OW 255
70342: PPUSH
70343: LD_EXP 36
70347: PUSH
70348: LD_VAR 0 2
70352: ARRAY
70353: PPUSH
70354: CALL 12954 0 2
70358: GO 70296
70360: POP
70361: POP
// end ;
70362: LD_VAR 0 1
70366: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70367: LD_INT 0
70369: PPUSH
70370: PPUSH
70371: PPUSH
70372: PPUSH
70373: PPUSH
70374: PPUSH
70375: PPUSH
70376: PPUSH
// if not mc_bases or not mc_parking then
70377: LD_EXP 23
70381: NOT
70382: PUSH
70383: LD_EXP 47
70387: NOT
70388: OR
70389: IFFALSE 70393
// exit ;
70391: GO 71131
// for i = 1 to mc_bases do
70393: LD_ADDR_VAR 0 2
70397: PUSH
70398: DOUBLE
70399: LD_INT 1
70401: DEC
70402: ST_TO_ADDR
70403: LD_EXP 23
70407: PUSH
70408: FOR_TO
70409: IFFALSE 71129
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70411: LD_EXP 23
70415: PUSH
70416: LD_VAR 0 2
70420: ARRAY
70421: NOT
70422: PUSH
70423: LD_EXP 47
70427: PUSH
70428: LD_VAR 0 2
70432: ARRAY
70433: NOT
70434: OR
70435: IFFALSE 70439
// continue ;
70437: GO 70408
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70439: LD_ADDR_VAR 0 5
70443: PUSH
70444: LD_EXP 23
70448: PUSH
70449: LD_VAR 0 2
70453: ARRAY
70454: PUSH
70455: LD_INT 1
70457: ARRAY
70458: PPUSH
70459: CALL_OW 255
70463: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70464: LD_ADDR_VAR 0 6
70468: PUSH
70469: LD_EXP 23
70473: PUSH
70474: LD_VAR 0 2
70478: ARRAY
70479: PPUSH
70480: LD_INT 30
70482: PUSH
70483: LD_INT 3
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PPUSH
70490: CALL_OW 72
70494: ST_TO_ADDR
// if not fac then
70495: LD_VAR 0 6
70499: NOT
70500: IFFALSE 70551
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70502: LD_ADDR_VAR 0 6
70506: PUSH
70507: LD_EXP 23
70511: PUSH
70512: LD_VAR 0 2
70516: ARRAY
70517: PPUSH
70518: LD_INT 2
70520: PUSH
70521: LD_INT 30
70523: PUSH
70524: LD_INT 0
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: LD_INT 30
70533: PUSH
70534: LD_INT 1
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: LIST
70545: PPUSH
70546: CALL_OW 72
70550: ST_TO_ADDR
// if not fac then
70551: LD_VAR 0 6
70555: NOT
70556: IFFALSE 70560
// continue ;
70558: GO 70408
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70560: LD_ADDR_VAR 0 7
70564: PUSH
70565: LD_EXP 47
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: PPUSH
70576: LD_INT 22
70578: PUSH
70579: LD_VAR 0 5
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 21
70590: PUSH
70591: LD_INT 2
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 3
70600: PUSH
70601: LD_INT 60
70603: PUSH
70604: EMPTY
70605: LIST
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 3
70613: PUSH
70614: LD_INT 24
70616: PUSH
70617: LD_INT 1000
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: PPUSH
70634: CALL_OW 70
70638: ST_TO_ADDR
// for j in fac do
70639: LD_ADDR_VAR 0 3
70643: PUSH
70644: LD_VAR 0 6
70648: PUSH
70649: FOR_IN
70650: IFFALSE 70745
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70652: LD_ADDR_VAR 0 7
70656: PUSH
70657: LD_VAR 0 7
70661: PUSH
70662: LD_INT 22
70664: PUSH
70665: LD_VAR 0 5
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 91
70676: PUSH
70677: LD_VAR 0 3
70681: PUSH
70682: LD_INT 15
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: LIST
70689: PUSH
70690: LD_INT 21
70692: PUSH
70693: LD_INT 2
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 3
70702: PUSH
70703: LD_INT 60
70705: PUSH
70706: EMPTY
70707: LIST
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: PUSH
70713: LD_INT 3
70715: PUSH
70716: LD_INT 24
70718: PUSH
70719: LD_INT 1000
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: PPUSH
70737: CALL_OW 69
70741: UNION
70742: ST_TO_ADDR
70743: GO 70649
70745: POP
70746: POP
// if not vehs then
70747: LD_VAR 0 7
70751: NOT
70752: IFFALSE 70778
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70754: LD_ADDR_EXP 35
70758: PUSH
70759: LD_EXP 35
70763: PPUSH
70764: LD_VAR 0 2
70768: PPUSH
70769: EMPTY
70770: PPUSH
70771: CALL_OW 1
70775: ST_TO_ADDR
// continue ;
70776: GO 70408
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70778: LD_ADDR_VAR 0 8
70782: PUSH
70783: LD_EXP 23
70787: PUSH
70788: LD_VAR 0 2
70792: ARRAY
70793: PPUSH
70794: LD_INT 30
70796: PUSH
70797: LD_INT 3
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PPUSH
70804: CALL_OW 72
70808: ST_TO_ADDR
// if tmp then
70809: LD_VAR 0 8
70813: IFFALSE 70916
// begin for j in tmp do
70815: LD_ADDR_VAR 0 3
70819: PUSH
70820: LD_VAR 0 8
70824: PUSH
70825: FOR_IN
70826: IFFALSE 70914
// for k in UnitsInside ( j ) do
70828: LD_ADDR_VAR 0 4
70832: PUSH
70833: LD_VAR 0 3
70837: PPUSH
70838: CALL_OW 313
70842: PUSH
70843: FOR_IN
70844: IFFALSE 70910
// if k then
70846: LD_VAR 0 4
70850: IFFALSE 70908
// if not k in mc_repair_vehicle [ i ] then
70852: LD_VAR 0 4
70856: PUSH
70857: LD_EXP 35
70861: PUSH
70862: LD_VAR 0 2
70866: ARRAY
70867: IN
70868: NOT
70869: IFFALSE 70908
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70871: LD_ADDR_EXP 35
70875: PUSH
70876: LD_EXP 35
70880: PPUSH
70881: LD_VAR 0 2
70885: PPUSH
70886: LD_EXP 35
70890: PUSH
70891: LD_VAR 0 2
70895: ARRAY
70896: PUSH
70897: LD_VAR 0 4
70901: UNION
70902: PPUSH
70903: CALL_OW 1
70907: ST_TO_ADDR
70908: GO 70843
70910: POP
70911: POP
70912: GO 70825
70914: POP
70915: POP
// end ; if not mc_repair_vehicle [ i ] then
70916: LD_EXP 35
70920: PUSH
70921: LD_VAR 0 2
70925: ARRAY
70926: NOT
70927: IFFALSE 70931
// continue ;
70929: GO 70408
// for j in mc_repair_vehicle [ i ] do
70931: LD_ADDR_VAR 0 3
70935: PUSH
70936: LD_EXP 35
70940: PUSH
70941: LD_VAR 0 2
70945: ARRAY
70946: PUSH
70947: FOR_IN
70948: IFFALSE 71125
// begin if GetClass ( j ) <> 3 then
70950: LD_VAR 0 3
70954: PPUSH
70955: CALL_OW 257
70959: PUSH
70960: LD_INT 3
70962: NONEQUAL
70963: IFFALSE 71004
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70965: LD_ADDR_EXP 35
70969: PUSH
70970: LD_EXP 35
70974: PPUSH
70975: LD_VAR 0 2
70979: PPUSH
70980: LD_EXP 35
70984: PUSH
70985: LD_VAR 0 2
70989: ARRAY
70990: PUSH
70991: LD_VAR 0 3
70995: DIFF
70996: PPUSH
70997: CALL_OW 1
71001: ST_TO_ADDR
// continue ;
71002: GO 70947
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71004: LD_VAR 0 3
71008: PPUSH
71009: CALL_OW 311
71013: NOT
71014: PUSH
71015: LD_VAR 0 3
71019: PUSH
71020: LD_EXP 26
71024: PUSH
71025: LD_VAR 0 2
71029: ARRAY
71030: PUSH
71031: LD_INT 1
71033: ARRAY
71034: IN
71035: NOT
71036: AND
71037: PUSH
71038: LD_VAR 0 3
71042: PUSH
71043: LD_EXP 26
71047: PUSH
71048: LD_VAR 0 2
71052: ARRAY
71053: PUSH
71054: LD_INT 2
71056: ARRAY
71057: IN
71058: NOT
71059: AND
71060: IFFALSE 71123
// begin if IsInUnit ( j ) then
71062: LD_VAR 0 3
71066: PPUSH
71067: CALL_OW 310
71071: IFFALSE 71084
// ComExitBuilding ( j ) else
71073: LD_VAR 0 3
71077: PPUSH
71078: CALL_OW 122
71082: GO 71123
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71084: LD_VAR 0 3
71088: PPUSH
71089: LD_VAR 0 7
71093: PUSH
71094: LD_INT 1
71096: ARRAY
71097: PPUSH
71098: CALL 50529 0 2
71102: NOT
71103: IFFALSE 71123
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71105: LD_VAR 0 3
71109: PPUSH
71110: LD_VAR 0 7
71114: PUSH
71115: LD_INT 1
71117: ARRAY
71118: PPUSH
71119: CALL_OW 129
// end ; end ;
71123: GO 70947
71125: POP
71126: POP
// end ;
71127: GO 70408
71129: POP
71130: POP
// end ;
71131: LD_VAR 0 1
71135: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71136: LD_INT 0
71138: PPUSH
71139: PPUSH
71140: PPUSH
71141: PPUSH
71142: PPUSH
71143: PPUSH
71144: PPUSH
71145: PPUSH
71146: PPUSH
71147: PPUSH
71148: PPUSH
// if not mc_bases then
71149: LD_EXP 23
71153: NOT
71154: IFFALSE 71158
// exit ;
71156: GO 71960
// for i = 1 to mc_bases do
71158: LD_ADDR_VAR 0 2
71162: PUSH
71163: DOUBLE
71164: LD_INT 1
71166: DEC
71167: ST_TO_ADDR
71168: LD_EXP 23
71172: PUSH
71173: FOR_TO
71174: IFFALSE 71958
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71176: LD_EXP 51
71180: PUSH
71181: LD_VAR 0 2
71185: ARRAY
71186: NOT
71187: PUSH
71188: LD_EXP 26
71192: PUSH
71193: LD_VAR 0 2
71197: ARRAY
71198: PUSH
71199: LD_INT 1
71201: ARRAY
71202: OR
71203: PUSH
71204: LD_EXP 26
71208: PUSH
71209: LD_VAR 0 2
71213: ARRAY
71214: PUSH
71215: LD_INT 2
71217: ARRAY
71218: OR
71219: PUSH
71220: LD_EXP 49
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: PPUSH
71231: LD_INT 1
71233: PPUSH
71234: CALL_OW 325
71238: NOT
71239: OR
71240: PUSH
71241: LD_EXP 46
71245: PUSH
71246: LD_VAR 0 2
71250: ARRAY
71251: OR
71252: IFFALSE 71256
// continue ;
71254: GO 71173
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71256: LD_ADDR_VAR 0 8
71260: PUSH
71261: LD_EXP 23
71265: PUSH
71266: LD_VAR 0 2
71270: ARRAY
71271: PPUSH
71272: LD_INT 25
71274: PUSH
71275: LD_INT 4
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 50
71284: PUSH
71285: EMPTY
71286: LIST
71287: PUSH
71288: LD_INT 3
71290: PUSH
71291: LD_INT 60
71293: PUSH
71294: EMPTY
71295: LIST
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: LIST
71305: PPUSH
71306: CALL_OW 72
71310: PUSH
71311: LD_EXP 27
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: DIFF
71322: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71323: LD_ADDR_VAR 0 9
71327: PUSH
71328: LD_EXP 23
71332: PUSH
71333: LD_VAR 0 2
71337: ARRAY
71338: PPUSH
71339: LD_INT 2
71341: PUSH
71342: LD_INT 30
71344: PUSH
71345: LD_INT 0
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 30
71354: PUSH
71355: LD_INT 1
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: LIST
71366: PPUSH
71367: CALL_OW 72
71371: ST_TO_ADDR
// if not tmp or not dep then
71372: LD_VAR 0 8
71376: NOT
71377: PUSH
71378: LD_VAR 0 9
71382: NOT
71383: OR
71384: IFFALSE 71388
// continue ;
71386: GO 71173
// side := GetSide ( tmp [ 1 ] ) ;
71388: LD_ADDR_VAR 0 11
71392: PUSH
71393: LD_VAR 0 8
71397: PUSH
71398: LD_INT 1
71400: ARRAY
71401: PPUSH
71402: CALL_OW 255
71406: ST_TO_ADDR
// dep := dep [ 1 ] ;
71407: LD_ADDR_VAR 0 9
71411: PUSH
71412: LD_VAR 0 9
71416: PUSH
71417: LD_INT 1
71419: ARRAY
71420: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71421: LD_ADDR_VAR 0 7
71425: PUSH
71426: LD_EXP 51
71430: PUSH
71431: LD_VAR 0 2
71435: ARRAY
71436: PPUSH
71437: LD_INT 22
71439: PUSH
71440: LD_INT 0
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 25
71449: PUSH
71450: LD_INT 12
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PPUSH
71461: CALL_OW 70
71465: PUSH
71466: LD_INT 22
71468: PUSH
71469: LD_INT 0
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 25
71478: PUSH
71479: LD_INT 12
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 91
71488: PUSH
71489: LD_VAR 0 9
71493: PUSH
71494: LD_INT 20
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: LIST
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: LIST
71506: PPUSH
71507: CALL_OW 69
71511: UNION
71512: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71513: LD_ADDR_VAR 0 10
71517: PUSH
71518: LD_EXP 51
71522: PUSH
71523: LD_VAR 0 2
71527: ARRAY
71528: PPUSH
71529: LD_INT 81
71531: PUSH
71532: LD_VAR 0 11
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PPUSH
71541: CALL_OW 70
71545: ST_TO_ADDR
// if not apes or danger_at_area then
71546: LD_VAR 0 7
71550: NOT
71551: PUSH
71552: LD_VAR 0 10
71556: OR
71557: IFFALSE 71607
// begin if mc_taming [ i ] then
71559: LD_EXP 54
71563: PUSH
71564: LD_VAR 0 2
71568: ARRAY
71569: IFFALSE 71605
// begin MC_Reset ( i , 121 ) ;
71571: LD_VAR 0 2
71575: PPUSH
71576: LD_INT 121
71578: PPUSH
71579: CALL 56544 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71583: LD_ADDR_EXP 54
71587: PUSH
71588: LD_EXP 54
71592: PPUSH
71593: LD_VAR 0 2
71597: PPUSH
71598: EMPTY
71599: PPUSH
71600: CALL_OW 1
71604: ST_TO_ADDR
// end ; continue ;
71605: GO 71173
// end ; for j in tmp do
71607: LD_ADDR_VAR 0 3
71611: PUSH
71612: LD_VAR 0 8
71616: PUSH
71617: FOR_IN
71618: IFFALSE 71954
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71620: LD_VAR 0 3
71624: PUSH
71625: LD_EXP 54
71629: PUSH
71630: LD_VAR 0 2
71634: ARRAY
71635: IN
71636: NOT
71637: PUSH
71638: LD_EXP 54
71642: PUSH
71643: LD_VAR 0 2
71647: ARRAY
71648: PUSH
71649: LD_INT 3
71651: LESS
71652: AND
71653: IFFALSE 71711
// begin SetTag ( j , 121 ) ;
71655: LD_VAR 0 3
71659: PPUSH
71660: LD_INT 121
71662: PPUSH
71663: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71667: LD_ADDR_EXP 54
71671: PUSH
71672: LD_EXP 54
71676: PPUSH
71677: LD_VAR 0 2
71681: PUSH
71682: LD_EXP 54
71686: PUSH
71687: LD_VAR 0 2
71691: ARRAY
71692: PUSH
71693: LD_INT 1
71695: PLUS
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PPUSH
71701: LD_VAR 0 3
71705: PPUSH
71706: CALL 16152 0 3
71710: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71711: LD_VAR 0 3
71715: PUSH
71716: LD_EXP 54
71720: PUSH
71721: LD_VAR 0 2
71725: ARRAY
71726: IN
71727: IFFALSE 71952
// begin if GetClass ( j ) <> 4 then
71729: LD_VAR 0 3
71733: PPUSH
71734: CALL_OW 257
71738: PUSH
71739: LD_INT 4
71741: NONEQUAL
71742: IFFALSE 71795
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71744: LD_ADDR_EXP 54
71748: PUSH
71749: LD_EXP 54
71753: PPUSH
71754: LD_VAR 0 2
71758: PPUSH
71759: LD_EXP 54
71763: PUSH
71764: LD_VAR 0 2
71768: ARRAY
71769: PUSH
71770: LD_VAR 0 3
71774: DIFF
71775: PPUSH
71776: CALL_OW 1
71780: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71781: LD_VAR 0 3
71785: PPUSH
71786: LD_INT 0
71788: PPUSH
71789: CALL_OW 109
// continue ;
71793: GO 71617
// end ; if IsInUnit ( j ) then
71795: LD_VAR 0 3
71799: PPUSH
71800: CALL_OW 310
71804: IFFALSE 71815
// ComExitBuilding ( j ) ;
71806: LD_VAR 0 3
71810: PPUSH
71811: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71815: LD_ADDR_VAR 0 6
71819: PUSH
71820: LD_VAR 0 7
71824: PPUSH
71825: LD_VAR 0 3
71829: PPUSH
71830: CALL_OW 74
71834: ST_TO_ADDR
// if not ape then
71835: LD_VAR 0 6
71839: NOT
71840: IFFALSE 71844
// break ;
71842: GO 71954
// x := GetX ( ape ) ;
71844: LD_ADDR_VAR 0 4
71848: PUSH
71849: LD_VAR 0 6
71853: PPUSH
71854: CALL_OW 250
71858: ST_TO_ADDR
// y := GetY ( ape ) ;
71859: LD_ADDR_VAR 0 5
71863: PUSH
71864: LD_VAR 0 6
71868: PPUSH
71869: CALL_OW 251
71873: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71874: LD_VAR 0 4
71878: PPUSH
71879: LD_VAR 0 5
71883: PPUSH
71884: CALL_OW 488
71888: NOT
71889: PUSH
71890: LD_VAR 0 11
71894: PPUSH
71895: LD_VAR 0 4
71899: PPUSH
71900: LD_VAR 0 5
71904: PPUSH
71905: LD_INT 20
71907: PPUSH
71908: CALL 17048 0 4
71912: PUSH
71913: LD_INT 4
71915: ARRAY
71916: OR
71917: IFFALSE 71921
// break ;
71919: GO 71954
// if not HasTask ( j ) then
71921: LD_VAR 0 3
71925: PPUSH
71926: CALL_OW 314
71930: NOT
71931: IFFALSE 71952
// ComTameXY ( j , x , y ) ;
71933: LD_VAR 0 3
71937: PPUSH
71938: LD_VAR 0 4
71942: PPUSH
71943: LD_VAR 0 5
71947: PPUSH
71948: CALL_OW 131
// end ; end ;
71952: GO 71617
71954: POP
71955: POP
// end ;
71956: GO 71173
71958: POP
71959: POP
// end ;
71960: LD_VAR 0 1
71964: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71965: LD_INT 0
71967: PPUSH
71968: PPUSH
71969: PPUSH
71970: PPUSH
71971: PPUSH
71972: PPUSH
71973: PPUSH
71974: PPUSH
// if not mc_bases then
71975: LD_EXP 23
71979: NOT
71980: IFFALSE 71984
// exit ;
71982: GO 72610
// for i = 1 to mc_bases do
71984: LD_ADDR_VAR 0 2
71988: PUSH
71989: DOUBLE
71990: LD_INT 1
71992: DEC
71993: ST_TO_ADDR
71994: LD_EXP 23
71998: PUSH
71999: FOR_TO
72000: IFFALSE 72608
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72002: LD_EXP 52
72006: PUSH
72007: LD_VAR 0 2
72011: ARRAY
72012: NOT
72013: PUSH
72014: LD_EXP 52
72018: PUSH
72019: LD_VAR 0 2
72023: ARRAY
72024: PPUSH
72025: LD_INT 25
72027: PUSH
72028: LD_INT 12
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PPUSH
72035: CALL_OW 72
72039: NOT
72040: OR
72041: IFFALSE 72045
// continue ;
72043: GO 71999
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72045: LD_ADDR_VAR 0 5
72049: PUSH
72050: LD_EXP 52
72054: PUSH
72055: LD_VAR 0 2
72059: ARRAY
72060: PUSH
72061: LD_INT 1
72063: ARRAY
72064: PPUSH
72065: CALL_OW 255
72069: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72070: LD_VAR 0 5
72074: PPUSH
72075: LD_INT 2
72077: PPUSH
72078: CALL_OW 325
72082: IFFALSE 72335
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72084: LD_ADDR_VAR 0 4
72088: PUSH
72089: LD_EXP 52
72093: PUSH
72094: LD_VAR 0 2
72098: ARRAY
72099: PPUSH
72100: LD_INT 25
72102: PUSH
72103: LD_INT 16
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PPUSH
72110: CALL_OW 72
72114: ST_TO_ADDR
// if tmp < 6 then
72115: LD_VAR 0 4
72119: PUSH
72120: LD_INT 6
72122: LESS
72123: IFFALSE 72335
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72125: LD_ADDR_VAR 0 6
72129: PUSH
72130: LD_EXP 23
72134: PUSH
72135: LD_VAR 0 2
72139: ARRAY
72140: PPUSH
72141: LD_INT 2
72143: PUSH
72144: LD_INT 30
72146: PUSH
72147: LD_INT 0
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 30
72156: PUSH
72157: LD_INT 1
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: LIST
72168: PPUSH
72169: CALL_OW 72
72173: ST_TO_ADDR
// if depot then
72174: LD_VAR 0 6
72178: IFFALSE 72335
// begin selected := 0 ;
72180: LD_ADDR_VAR 0 7
72184: PUSH
72185: LD_INT 0
72187: ST_TO_ADDR
// for j in depot do
72188: LD_ADDR_VAR 0 3
72192: PUSH
72193: LD_VAR 0 6
72197: PUSH
72198: FOR_IN
72199: IFFALSE 72230
// begin if UnitsInside ( j ) < 6 then
72201: LD_VAR 0 3
72205: PPUSH
72206: CALL_OW 313
72210: PUSH
72211: LD_INT 6
72213: LESS
72214: IFFALSE 72228
// begin selected := j ;
72216: LD_ADDR_VAR 0 7
72220: PUSH
72221: LD_VAR 0 3
72225: ST_TO_ADDR
// break ;
72226: GO 72230
// end ; end ;
72228: GO 72198
72230: POP
72231: POP
// if selected then
72232: LD_VAR 0 7
72236: IFFALSE 72335
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72238: LD_ADDR_VAR 0 3
72242: PUSH
72243: LD_EXP 52
72247: PUSH
72248: LD_VAR 0 2
72252: ARRAY
72253: PPUSH
72254: LD_INT 25
72256: PUSH
72257: LD_INT 12
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PPUSH
72264: CALL_OW 72
72268: PUSH
72269: FOR_IN
72270: IFFALSE 72333
// if not HasTask ( j ) then
72272: LD_VAR 0 3
72276: PPUSH
72277: CALL_OW 314
72281: NOT
72282: IFFALSE 72331
// begin if not IsInUnit ( j ) then
72284: LD_VAR 0 3
72288: PPUSH
72289: CALL_OW 310
72293: NOT
72294: IFFALSE 72310
// ComEnterUnit ( j , selected ) ;
72296: LD_VAR 0 3
72300: PPUSH
72301: LD_VAR 0 7
72305: PPUSH
72306: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72310: LD_VAR 0 3
72314: PPUSH
72315: LD_INT 16
72317: PPUSH
72318: CALL_OW 183
// AddComExitBuilding ( j ) ;
72322: LD_VAR 0 3
72326: PPUSH
72327: CALL_OW 182
// end ;
72331: GO 72269
72333: POP
72334: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72335: LD_VAR 0 5
72339: PPUSH
72340: LD_INT 11
72342: PPUSH
72343: CALL_OW 325
72347: IFFALSE 72606
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72349: LD_ADDR_VAR 0 4
72353: PUSH
72354: LD_EXP 52
72358: PUSH
72359: LD_VAR 0 2
72363: ARRAY
72364: PPUSH
72365: LD_INT 25
72367: PUSH
72368: LD_INT 16
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PPUSH
72375: CALL_OW 72
72379: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72380: LD_VAR 0 4
72384: PUSH
72385: LD_INT 6
72387: GREATEREQUAL
72388: PUSH
72389: LD_VAR 0 5
72393: PPUSH
72394: LD_INT 2
72396: PPUSH
72397: CALL_OW 325
72401: NOT
72402: OR
72403: IFFALSE 72606
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72405: LD_ADDR_VAR 0 8
72409: PUSH
72410: LD_EXP 23
72414: PUSH
72415: LD_VAR 0 2
72419: ARRAY
72420: PPUSH
72421: LD_INT 2
72423: PUSH
72424: LD_INT 30
72426: PUSH
72427: LD_INT 4
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 30
72436: PUSH
72437: LD_INT 5
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: PPUSH
72449: CALL_OW 72
72453: ST_TO_ADDR
// if barracks then
72454: LD_VAR 0 8
72458: IFFALSE 72606
// begin selected := 0 ;
72460: LD_ADDR_VAR 0 7
72464: PUSH
72465: LD_INT 0
72467: ST_TO_ADDR
// for j in barracks do
72468: LD_ADDR_VAR 0 3
72472: PUSH
72473: LD_VAR 0 8
72477: PUSH
72478: FOR_IN
72479: IFFALSE 72510
// begin if UnitsInside ( j ) < 6 then
72481: LD_VAR 0 3
72485: PPUSH
72486: CALL_OW 313
72490: PUSH
72491: LD_INT 6
72493: LESS
72494: IFFALSE 72508
// begin selected := j ;
72496: LD_ADDR_VAR 0 7
72500: PUSH
72501: LD_VAR 0 3
72505: ST_TO_ADDR
// break ;
72506: GO 72510
// end ; end ;
72508: GO 72478
72510: POP
72511: POP
// if selected then
72512: LD_VAR 0 7
72516: IFFALSE 72606
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72518: LD_ADDR_VAR 0 3
72522: PUSH
72523: LD_EXP 52
72527: PUSH
72528: LD_VAR 0 2
72532: ARRAY
72533: PPUSH
72534: LD_INT 25
72536: PUSH
72537: LD_INT 12
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PPUSH
72544: CALL_OW 72
72548: PUSH
72549: FOR_IN
72550: IFFALSE 72604
// if not IsInUnit ( j ) and not HasTask ( j ) then
72552: LD_VAR 0 3
72556: PPUSH
72557: CALL_OW 310
72561: NOT
72562: PUSH
72563: LD_VAR 0 3
72567: PPUSH
72568: CALL_OW 314
72572: NOT
72573: AND
72574: IFFALSE 72602
// begin ComEnterUnit ( j , selected ) ;
72576: LD_VAR 0 3
72580: PPUSH
72581: LD_VAR 0 7
72585: PPUSH
72586: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72590: LD_VAR 0 3
72594: PPUSH
72595: LD_INT 15
72597: PPUSH
72598: CALL_OW 183
// end ;
72602: GO 72549
72604: POP
72605: POP
// end ; end ; end ; end ; end ;
72606: GO 71999
72608: POP
72609: POP
// end ;
72610: LD_VAR 0 1
72614: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72615: LD_INT 0
72617: PPUSH
72618: PPUSH
72619: PPUSH
72620: PPUSH
// if not mc_bases then
72621: LD_EXP 23
72625: NOT
72626: IFFALSE 72630
// exit ;
72628: GO 72808
// for i = 1 to mc_bases do
72630: LD_ADDR_VAR 0 2
72634: PUSH
72635: DOUBLE
72636: LD_INT 1
72638: DEC
72639: ST_TO_ADDR
72640: LD_EXP 23
72644: PUSH
72645: FOR_TO
72646: IFFALSE 72806
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72648: LD_ADDR_VAR 0 4
72652: PUSH
72653: LD_EXP 23
72657: PUSH
72658: LD_VAR 0 2
72662: ARRAY
72663: PPUSH
72664: LD_INT 25
72666: PUSH
72667: LD_INT 9
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PPUSH
72674: CALL_OW 72
72678: ST_TO_ADDR
// if not tmp then
72679: LD_VAR 0 4
72683: NOT
72684: IFFALSE 72688
// continue ;
72686: GO 72645
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72688: LD_EXP 49
72692: PUSH
72693: LD_VAR 0 2
72697: ARRAY
72698: PPUSH
72699: LD_INT 29
72701: PPUSH
72702: CALL_OW 325
72706: NOT
72707: PUSH
72708: LD_EXP 49
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: PPUSH
72719: LD_INT 28
72721: PPUSH
72722: CALL_OW 325
72726: NOT
72727: AND
72728: IFFALSE 72732
// continue ;
72730: GO 72645
// for j in tmp do
72732: LD_ADDR_VAR 0 3
72736: PUSH
72737: LD_VAR 0 4
72741: PUSH
72742: FOR_IN
72743: IFFALSE 72802
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72745: LD_VAR 0 3
72749: PUSH
72750: LD_EXP 26
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: PUSH
72761: LD_INT 1
72763: ARRAY
72764: IN
72765: NOT
72766: PUSH
72767: LD_VAR 0 3
72771: PUSH
72772: LD_EXP 26
72776: PUSH
72777: LD_VAR 0 2
72781: ARRAY
72782: PUSH
72783: LD_INT 2
72785: ARRAY
72786: IN
72787: NOT
72788: AND
72789: IFFALSE 72800
// ComSpaceTimeShoot ( j ) ;
72791: LD_VAR 0 3
72795: PPUSH
72796: CALL 11962 0 1
72800: GO 72742
72802: POP
72803: POP
// end ;
72804: GO 72645
72806: POP
72807: POP
// end ;
72808: LD_VAR 0 1
72812: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72813: LD_INT 0
72815: PPUSH
72816: PPUSH
72817: PPUSH
72818: PPUSH
72819: PPUSH
72820: PPUSH
72821: PPUSH
72822: PPUSH
72823: PPUSH
// if not mc_bases then
72824: LD_EXP 23
72828: NOT
72829: IFFALSE 72833
// exit ;
72831: GO 73455
// for i = 1 to mc_bases do
72833: LD_ADDR_VAR 0 2
72837: PUSH
72838: DOUBLE
72839: LD_INT 1
72841: DEC
72842: ST_TO_ADDR
72843: LD_EXP 23
72847: PUSH
72848: FOR_TO
72849: IFFALSE 73453
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72851: LD_EXP 58
72855: PUSH
72856: LD_VAR 0 2
72860: ARRAY
72861: NOT
72862: PUSH
72863: LD_INT 38
72865: PPUSH
72866: LD_EXP 49
72870: PUSH
72871: LD_VAR 0 2
72875: ARRAY
72876: PPUSH
72877: CALL_OW 321
72881: PUSH
72882: LD_INT 2
72884: NONEQUAL
72885: OR
72886: IFFALSE 72890
// continue ;
72888: GO 72848
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72890: LD_ADDR_VAR 0 8
72894: PUSH
72895: LD_EXP 23
72899: PUSH
72900: LD_VAR 0 2
72904: ARRAY
72905: PPUSH
72906: LD_INT 30
72908: PUSH
72909: LD_INT 34
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PPUSH
72916: CALL_OW 72
72920: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72921: LD_ADDR_VAR 0 9
72925: PUSH
72926: LD_EXP 23
72930: PUSH
72931: LD_VAR 0 2
72935: ARRAY
72936: PPUSH
72937: LD_INT 25
72939: PUSH
72940: LD_INT 4
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PPUSH
72947: CALL_OW 72
72951: PPUSH
72952: LD_INT 0
72954: PPUSH
72955: CALL 46038 0 2
72959: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72960: LD_VAR 0 9
72964: NOT
72965: PUSH
72966: LD_VAR 0 8
72970: NOT
72971: OR
72972: PUSH
72973: LD_EXP 23
72977: PUSH
72978: LD_VAR 0 2
72982: ARRAY
72983: PPUSH
72984: LD_INT 124
72986: PPUSH
72987: CALL 46038 0 2
72991: OR
72992: IFFALSE 72996
// continue ;
72994: GO 72848
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72996: LD_EXP 59
73000: PUSH
73001: LD_VAR 0 2
73005: ARRAY
73006: PUSH
73007: LD_EXP 58
73011: PUSH
73012: LD_VAR 0 2
73016: ARRAY
73017: LESS
73018: PUSH
73019: LD_EXP 59
73023: PUSH
73024: LD_VAR 0 2
73028: ARRAY
73029: PUSH
73030: LD_VAR 0 8
73034: LESS
73035: AND
73036: IFFALSE 73451
// begin tmp := sci [ 1 ] ;
73038: LD_ADDR_VAR 0 7
73042: PUSH
73043: LD_VAR 0 9
73047: PUSH
73048: LD_INT 1
73050: ARRAY
73051: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73052: LD_VAR 0 7
73056: PPUSH
73057: LD_INT 124
73059: PPUSH
73060: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73064: LD_ADDR_VAR 0 3
73068: PUSH
73069: DOUBLE
73070: LD_EXP 58
73074: PUSH
73075: LD_VAR 0 2
73079: ARRAY
73080: INC
73081: ST_TO_ADDR
73082: LD_EXP 58
73086: PUSH
73087: LD_VAR 0 2
73091: ARRAY
73092: PUSH
73093: FOR_DOWNTO
73094: IFFALSE 73437
// begin if IsInUnit ( tmp ) then
73096: LD_VAR 0 7
73100: PPUSH
73101: CALL_OW 310
73105: IFFALSE 73116
// ComExitBuilding ( tmp ) ;
73107: LD_VAR 0 7
73111: PPUSH
73112: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73116: LD_INT 35
73118: PPUSH
73119: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73123: LD_VAR 0 7
73127: PPUSH
73128: CALL_OW 310
73132: NOT
73133: PUSH
73134: LD_VAR 0 7
73138: PPUSH
73139: CALL_OW 314
73143: NOT
73144: AND
73145: IFFALSE 73116
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73147: LD_ADDR_VAR 0 6
73151: PUSH
73152: LD_VAR 0 7
73156: PPUSH
73157: CALL_OW 250
73161: PUSH
73162: LD_VAR 0 7
73166: PPUSH
73167: CALL_OW 251
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73176: LD_INT 35
73178: PPUSH
73179: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73183: LD_ADDR_VAR 0 4
73187: PUSH
73188: LD_EXP 58
73192: PUSH
73193: LD_VAR 0 2
73197: ARRAY
73198: PUSH
73199: LD_VAR 0 3
73203: ARRAY
73204: PUSH
73205: LD_INT 1
73207: ARRAY
73208: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73209: LD_ADDR_VAR 0 5
73213: PUSH
73214: LD_EXP 58
73218: PUSH
73219: LD_VAR 0 2
73223: ARRAY
73224: PUSH
73225: LD_VAR 0 3
73229: ARRAY
73230: PUSH
73231: LD_INT 2
73233: ARRAY
73234: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73235: LD_VAR 0 7
73239: PPUSH
73240: LD_INT 10
73242: PPUSH
73243: CALL 18749 0 2
73247: PUSH
73248: LD_INT 4
73250: ARRAY
73251: IFFALSE 73289
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73253: LD_VAR 0 7
73257: PPUSH
73258: LD_VAR 0 6
73262: PUSH
73263: LD_INT 1
73265: ARRAY
73266: PPUSH
73267: LD_VAR 0 6
73271: PUSH
73272: LD_INT 2
73274: ARRAY
73275: PPUSH
73276: CALL_OW 111
// wait ( 0 0$10 ) ;
73280: LD_INT 350
73282: PPUSH
73283: CALL_OW 67
// end else
73287: GO 73315
// begin ComMoveXY ( tmp , x , y ) ;
73289: LD_VAR 0 7
73293: PPUSH
73294: LD_VAR 0 4
73298: PPUSH
73299: LD_VAR 0 5
73303: PPUSH
73304: CALL_OW 111
// wait ( 0 0$3 ) ;
73308: LD_INT 105
73310: PPUSH
73311: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73315: LD_VAR 0 7
73319: PPUSH
73320: LD_VAR 0 4
73324: PPUSH
73325: LD_VAR 0 5
73329: PPUSH
73330: CALL_OW 307
73334: IFFALSE 73176
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73336: LD_VAR 0 7
73340: PPUSH
73341: LD_VAR 0 4
73345: PPUSH
73346: LD_VAR 0 5
73350: PPUSH
73351: LD_VAR 0 8
73355: PUSH
73356: LD_VAR 0 3
73360: ARRAY
73361: PPUSH
73362: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73366: LD_INT 35
73368: PPUSH
73369: CALL_OW 67
// until not HasTask ( tmp ) ;
73373: LD_VAR 0 7
73377: PPUSH
73378: CALL_OW 314
73382: NOT
73383: IFFALSE 73366
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73385: LD_ADDR_EXP 59
73389: PUSH
73390: LD_EXP 59
73394: PPUSH
73395: LD_VAR 0 2
73399: PUSH
73400: LD_EXP 59
73404: PUSH
73405: LD_VAR 0 2
73409: ARRAY
73410: PUSH
73411: LD_INT 1
73413: PLUS
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PPUSH
73419: LD_VAR 0 8
73423: PUSH
73424: LD_VAR 0 3
73428: ARRAY
73429: PPUSH
73430: CALL 16152 0 3
73434: ST_TO_ADDR
// end ;
73435: GO 73093
73437: POP
73438: POP
// MC_Reset ( i , 124 ) ;
73439: LD_VAR 0 2
73443: PPUSH
73444: LD_INT 124
73446: PPUSH
73447: CALL 56544 0 2
// end ; end ;
73451: GO 72848
73453: POP
73454: POP
// end ;
73455: LD_VAR 0 1
73459: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73460: LD_INT 0
73462: PPUSH
73463: PPUSH
73464: PPUSH
// if not mc_bases then
73465: LD_EXP 23
73469: NOT
73470: IFFALSE 73474
// exit ;
73472: GO 74080
// for i = 1 to mc_bases do
73474: LD_ADDR_VAR 0 2
73478: PUSH
73479: DOUBLE
73480: LD_INT 1
73482: DEC
73483: ST_TO_ADDR
73484: LD_EXP 23
73488: PUSH
73489: FOR_TO
73490: IFFALSE 74078
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73492: LD_ADDR_VAR 0 3
73496: PUSH
73497: LD_EXP 23
73501: PUSH
73502: LD_VAR 0 2
73506: ARRAY
73507: PPUSH
73508: LD_INT 25
73510: PUSH
73511: LD_INT 4
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PPUSH
73518: CALL_OW 72
73522: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73523: LD_VAR 0 3
73527: NOT
73528: PUSH
73529: LD_EXP 60
73533: PUSH
73534: LD_VAR 0 2
73538: ARRAY
73539: NOT
73540: OR
73541: PUSH
73542: LD_EXP 23
73546: PUSH
73547: LD_VAR 0 2
73551: ARRAY
73552: PPUSH
73553: LD_INT 2
73555: PUSH
73556: LD_INT 30
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 30
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: LIST
73580: PPUSH
73581: CALL_OW 72
73585: NOT
73586: OR
73587: IFFALSE 73637
// begin if mc_deposits_finder [ i ] then
73589: LD_EXP 61
73593: PUSH
73594: LD_VAR 0 2
73598: ARRAY
73599: IFFALSE 73635
// begin MC_Reset ( i , 125 ) ;
73601: LD_VAR 0 2
73605: PPUSH
73606: LD_INT 125
73608: PPUSH
73609: CALL 56544 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73613: LD_ADDR_EXP 61
73617: PUSH
73618: LD_EXP 61
73622: PPUSH
73623: LD_VAR 0 2
73627: PPUSH
73628: EMPTY
73629: PPUSH
73630: CALL_OW 1
73634: ST_TO_ADDR
// end ; continue ;
73635: GO 73489
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73637: LD_EXP 60
73641: PUSH
73642: LD_VAR 0 2
73646: ARRAY
73647: PUSH
73648: LD_INT 1
73650: ARRAY
73651: PUSH
73652: LD_INT 3
73654: ARRAY
73655: PUSH
73656: LD_INT 1
73658: EQUAL
73659: PUSH
73660: LD_INT 20
73662: PPUSH
73663: LD_EXP 49
73667: PUSH
73668: LD_VAR 0 2
73672: ARRAY
73673: PPUSH
73674: CALL_OW 321
73678: PUSH
73679: LD_INT 2
73681: NONEQUAL
73682: AND
73683: IFFALSE 73733
// begin if mc_deposits_finder [ i ] then
73685: LD_EXP 61
73689: PUSH
73690: LD_VAR 0 2
73694: ARRAY
73695: IFFALSE 73731
// begin MC_Reset ( i , 125 ) ;
73697: LD_VAR 0 2
73701: PPUSH
73702: LD_INT 125
73704: PPUSH
73705: CALL 56544 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73709: LD_ADDR_EXP 61
73713: PUSH
73714: LD_EXP 61
73718: PPUSH
73719: LD_VAR 0 2
73723: PPUSH
73724: EMPTY
73725: PPUSH
73726: CALL_OW 1
73730: ST_TO_ADDR
// end ; continue ;
73731: GO 73489
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73733: LD_EXP 60
73737: PUSH
73738: LD_VAR 0 2
73742: ARRAY
73743: PUSH
73744: LD_INT 1
73746: ARRAY
73747: PUSH
73748: LD_INT 1
73750: ARRAY
73751: PPUSH
73752: LD_EXP 60
73756: PUSH
73757: LD_VAR 0 2
73761: ARRAY
73762: PUSH
73763: LD_INT 1
73765: ARRAY
73766: PUSH
73767: LD_INT 2
73769: ARRAY
73770: PPUSH
73771: LD_EXP 49
73775: PUSH
73776: LD_VAR 0 2
73780: ARRAY
73781: PPUSH
73782: CALL_OW 440
73786: IFFALSE 73829
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73788: LD_ADDR_EXP 60
73792: PUSH
73793: LD_EXP 60
73797: PPUSH
73798: LD_VAR 0 2
73802: PPUSH
73803: LD_EXP 60
73807: PUSH
73808: LD_VAR 0 2
73812: ARRAY
73813: PPUSH
73814: LD_INT 1
73816: PPUSH
73817: CALL_OW 3
73821: PPUSH
73822: CALL_OW 1
73826: ST_TO_ADDR
73827: GO 74076
// begin if not mc_deposits_finder [ i ] then
73829: LD_EXP 61
73833: PUSH
73834: LD_VAR 0 2
73838: ARRAY
73839: NOT
73840: IFFALSE 73892
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73842: LD_ADDR_EXP 61
73846: PUSH
73847: LD_EXP 61
73851: PPUSH
73852: LD_VAR 0 2
73856: PPUSH
73857: LD_VAR 0 3
73861: PUSH
73862: LD_INT 1
73864: ARRAY
73865: PUSH
73866: EMPTY
73867: LIST
73868: PPUSH
73869: CALL_OW 1
73873: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73874: LD_VAR 0 3
73878: PUSH
73879: LD_INT 1
73881: ARRAY
73882: PPUSH
73883: LD_INT 125
73885: PPUSH
73886: CALL_OW 109
// end else
73890: GO 74076
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73892: LD_EXP 61
73896: PUSH
73897: LD_VAR 0 2
73901: ARRAY
73902: PUSH
73903: LD_INT 1
73905: ARRAY
73906: PPUSH
73907: CALL_OW 310
73911: IFFALSE 73934
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73913: LD_EXP 61
73917: PUSH
73918: LD_VAR 0 2
73922: ARRAY
73923: PUSH
73924: LD_INT 1
73926: ARRAY
73927: PPUSH
73928: CALL_OW 122
73932: GO 74076
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73934: LD_EXP 61
73938: PUSH
73939: LD_VAR 0 2
73943: ARRAY
73944: PUSH
73945: LD_INT 1
73947: ARRAY
73948: PPUSH
73949: CALL_OW 314
73953: NOT
73954: PUSH
73955: LD_EXP 61
73959: PUSH
73960: LD_VAR 0 2
73964: ARRAY
73965: PUSH
73966: LD_INT 1
73968: ARRAY
73969: PPUSH
73970: LD_EXP 60
73974: PUSH
73975: LD_VAR 0 2
73979: ARRAY
73980: PUSH
73981: LD_INT 1
73983: ARRAY
73984: PUSH
73985: LD_INT 1
73987: ARRAY
73988: PPUSH
73989: LD_EXP 60
73993: PUSH
73994: LD_VAR 0 2
73998: ARRAY
73999: PUSH
74000: LD_INT 1
74002: ARRAY
74003: PUSH
74004: LD_INT 2
74006: ARRAY
74007: PPUSH
74008: CALL_OW 297
74012: PUSH
74013: LD_INT 6
74015: GREATER
74016: AND
74017: IFFALSE 74076
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74019: LD_EXP 61
74023: PUSH
74024: LD_VAR 0 2
74028: ARRAY
74029: PUSH
74030: LD_INT 1
74032: ARRAY
74033: PPUSH
74034: LD_EXP 60
74038: PUSH
74039: LD_VAR 0 2
74043: ARRAY
74044: PUSH
74045: LD_INT 1
74047: ARRAY
74048: PUSH
74049: LD_INT 1
74051: ARRAY
74052: PPUSH
74053: LD_EXP 60
74057: PUSH
74058: LD_VAR 0 2
74062: ARRAY
74063: PUSH
74064: LD_INT 1
74066: ARRAY
74067: PUSH
74068: LD_INT 2
74070: ARRAY
74071: PPUSH
74072: CALL_OW 111
// end ; end ; end ;
74076: GO 73489
74078: POP
74079: POP
// end ;
74080: LD_VAR 0 1
74084: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74085: LD_INT 0
74087: PPUSH
74088: PPUSH
74089: PPUSH
74090: PPUSH
74091: PPUSH
74092: PPUSH
74093: PPUSH
74094: PPUSH
74095: PPUSH
74096: PPUSH
74097: PPUSH
// if not mc_bases then
74098: LD_EXP 23
74102: NOT
74103: IFFALSE 74107
// exit ;
74105: GO 75047
// for i = 1 to mc_bases do
74107: LD_ADDR_VAR 0 2
74111: PUSH
74112: DOUBLE
74113: LD_INT 1
74115: DEC
74116: ST_TO_ADDR
74117: LD_EXP 23
74121: PUSH
74122: FOR_TO
74123: IFFALSE 75045
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74125: LD_EXP 23
74129: PUSH
74130: LD_VAR 0 2
74134: ARRAY
74135: NOT
74136: PUSH
74137: LD_EXP 46
74141: PUSH
74142: LD_VAR 0 2
74146: ARRAY
74147: OR
74148: IFFALSE 74152
// continue ;
74150: GO 74122
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74152: LD_ADDR_VAR 0 7
74156: PUSH
74157: LD_EXP 23
74161: PUSH
74162: LD_VAR 0 2
74166: ARRAY
74167: PUSH
74168: LD_INT 1
74170: ARRAY
74171: PPUSH
74172: CALL_OW 248
74176: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74177: LD_VAR 0 7
74181: PUSH
74182: LD_INT 3
74184: EQUAL
74185: PUSH
74186: LD_EXP 42
74190: PUSH
74191: LD_VAR 0 2
74195: ARRAY
74196: PUSH
74197: LD_EXP 45
74201: PUSH
74202: LD_VAR 0 2
74206: ARRAY
74207: UNION
74208: PPUSH
74209: LD_INT 33
74211: PUSH
74212: LD_INT 2
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PPUSH
74219: CALL_OW 72
74223: NOT
74224: OR
74225: IFFALSE 74229
// continue ;
74227: GO 74122
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74229: LD_ADDR_VAR 0 9
74233: PUSH
74234: LD_EXP 23
74238: PUSH
74239: LD_VAR 0 2
74243: ARRAY
74244: PPUSH
74245: LD_INT 30
74247: PUSH
74248: LD_INT 36
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: PPUSH
74255: CALL_OW 72
74259: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74260: LD_ADDR_VAR 0 10
74264: PUSH
74265: LD_EXP 42
74269: PUSH
74270: LD_VAR 0 2
74274: ARRAY
74275: PPUSH
74276: LD_INT 34
74278: PUSH
74279: LD_INT 31
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PPUSH
74286: CALL_OW 72
74290: ST_TO_ADDR
// if not cts and not mcts then
74291: LD_VAR 0 9
74295: NOT
74296: PUSH
74297: LD_VAR 0 10
74301: NOT
74302: AND
74303: IFFALSE 74307
// continue ;
74305: GO 74122
// x := cts ;
74307: LD_ADDR_VAR 0 11
74311: PUSH
74312: LD_VAR 0 9
74316: ST_TO_ADDR
// if not x then
74317: LD_VAR 0 11
74321: NOT
74322: IFFALSE 74334
// x := mcts ;
74324: LD_ADDR_VAR 0 11
74328: PUSH
74329: LD_VAR 0 10
74333: ST_TO_ADDR
// if not x then
74334: LD_VAR 0 11
74338: NOT
74339: IFFALSE 74343
// continue ;
74341: GO 74122
// if mc_remote_driver [ i ] then
74343: LD_EXP 63
74347: PUSH
74348: LD_VAR 0 2
74352: ARRAY
74353: IFFALSE 74740
// for j in mc_remote_driver [ i ] do
74355: LD_ADDR_VAR 0 3
74359: PUSH
74360: LD_EXP 63
74364: PUSH
74365: LD_VAR 0 2
74369: ARRAY
74370: PUSH
74371: FOR_IN
74372: IFFALSE 74738
// begin if GetClass ( j ) <> 3 then
74374: LD_VAR 0 3
74378: PPUSH
74379: CALL_OW 257
74383: PUSH
74384: LD_INT 3
74386: NONEQUAL
74387: IFFALSE 74440
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74389: LD_ADDR_EXP 63
74393: PUSH
74394: LD_EXP 63
74398: PPUSH
74399: LD_VAR 0 2
74403: PPUSH
74404: LD_EXP 63
74408: PUSH
74409: LD_VAR 0 2
74413: ARRAY
74414: PUSH
74415: LD_VAR 0 3
74419: DIFF
74420: PPUSH
74421: CALL_OW 1
74425: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74426: LD_VAR 0 3
74430: PPUSH
74431: LD_INT 0
74433: PPUSH
74434: CALL_OW 109
// continue ;
74438: GO 74371
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74440: LD_EXP 42
74444: PUSH
74445: LD_VAR 0 2
74449: ARRAY
74450: PPUSH
74451: LD_INT 34
74453: PUSH
74454: LD_INT 31
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 58
74463: PUSH
74464: EMPTY
74465: LIST
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PPUSH
74471: CALL_OW 72
74475: PUSH
74476: LD_VAR 0 3
74480: PPUSH
74481: CALL 46073 0 1
74485: NOT
74486: AND
74487: IFFALSE 74558
// begin if IsInUnit ( j ) then
74489: LD_VAR 0 3
74493: PPUSH
74494: CALL_OW 310
74498: IFFALSE 74509
// ComExitBuilding ( j ) ;
74500: LD_VAR 0 3
74504: PPUSH
74505: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74509: LD_VAR 0 3
74513: PPUSH
74514: LD_EXP 42
74518: PUSH
74519: LD_VAR 0 2
74523: ARRAY
74524: PPUSH
74525: LD_INT 34
74527: PUSH
74528: LD_INT 31
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: PUSH
74535: LD_INT 58
74537: PUSH
74538: EMPTY
74539: LIST
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PPUSH
74545: CALL_OW 72
74549: PUSH
74550: LD_INT 1
74552: ARRAY
74553: PPUSH
74554: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74558: LD_VAR 0 3
74562: PPUSH
74563: CALL_OW 310
74567: NOT
74568: PUSH
74569: LD_VAR 0 3
74573: PPUSH
74574: CALL_OW 310
74578: PPUSH
74579: CALL_OW 266
74583: PUSH
74584: LD_INT 36
74586: NONEQUAL
74587: PUSH
74588: LD_VAR 0 3
74592: PPUSH
74593: CALL 46073 0 1
74597: NOT
74598: AND
74599: OR
74600: IFFALSE 74736
// begin if IsInUnit ( j ) then
74602: LD_VAR 0 3
74606: PPUSH
74607: CALL_OW 310
74611: IFFALSE 74622
// ComExitBuilding ( j ) ;
74613: LD_VAR 0 3
74617: PPUSH
74618: CALL_OW 122
// ct := 0 ;
74622: LD_ADDR_VAR 0 8
74626: PUSH
74627: LD_INT 0
74629: ST_TO_ADDR
// for k in x do
74630: LD_ADDR_VAR 0 4
74634: PUSH
74635: LD_VAR 0 11
74639: PUSH
74640: FOR_IN
74641: IFFALSE 74714
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74643: LD_VAR 0 4
74647: PPUSH
74648: CALL_OW 264
74652: PUSH
74653: LD_INT 31
74655: EQUAL
74656: PUSH
74657: LD_VAR 0 4
74661: PPUSH
74662: CALL_OW 311
74666: NOT
74667: AND
74668: PUSH
74669: LD_VAR 0 4
74673: PPUSH
74674: CALL_OW 266
74678: PUSH
74679: LD_INT 36
74681: EQUAL
74682: PUSH
74683: LD_VAR 0 4
74687: PPUSH
74688: CALL_OW 313
74692: PUSH
74693: LD_INT 3
74695: LESS
74696: AND
74697: OR
74698: IFFALSE 74712
// begin ct := k ;
74700: LD_ADDR_VAR 0 8
74704: PUSH
74705: LD_VAR 0 4
74709: ST_TO_ADDR
// break ;
74710: GO 74714
// end ;
74712: GO 74640
74714: POP
74715: POP
// if ct then
74716: LD_VAR 0 8
74720: IFFALSE 74736
// ComEnterUnit ( j , ct ) ;
74722: LD_VAR 0 3
74726: PPUSH
74727: LD_VAR 0 8
74731: PPUSH
74732: CALL_OW 120
// end ; end ;
74736: GO 74371
74738: POP
74739: POP
// places := 0 ;
74740: LD_ADDR_VAR 0 5
74744: PUSH
74745: LD_INT 0
74747: ST_TO_ADDR
// for j = 1 to x do
74748: LD_ADDR_VAR 0 3
74752: PUSH
74753: DOUBLE
74754: LD_INT 1
74756: DEC
74757: ST_TO_ADDR
74758: LD_VAR 0 11
74762: PUSH
74763: FOR_TO
74764: IFFALSE 74840
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74766: LD_VAR 0 11
74770: PUSH
74771: LD_VAR 0 3
74775: ARRAY
74776: PPUSH
74777: CALL_OW 264
74781: PUSH
74782: LD_INT 31
74784: EQUAL
74785: IFFALSE 74803
// places := places + 1 else
74787: LD_ADDR_VAR 0 5
74791: PUSH
74792: LD_VAR 0 5
74796: PUSH
74797: LD_INT 1
74799: PLUS
74800: ST_TO_ADDR
74801: GO 74838
// if GetBType ( x [ j ] ) = b_control_tower then
74803: LD_VAR 0 11
74807: PUSH
74808: LD_VAR 0 3
74812: ARRAY
74813: PPUSH
74814: CALL_OW 266
74818: PUSH
74819: LD_INT 36
74821: EQUAL
74822: IFFALSE 74838
// places := places + 3 ;
74824: LD_ADDR_VAR 0 5
74828: PUSH
74829: LD_VAR 0 5
74833: PUSH
74834: LD_INT 3
74836: PLUS
74837: ST_TO_ADDR
74838: GO 74763
74840: POP
74841: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74842: LD_VAR 0 5
74846: PUSH
74847: LD_INT 0
74849: EQUAL
74850: PUSH
74851: LD_VAR 0 5
74855: PUSH
74856: LD_EXP 63
74860: PUSH
74861: LD_VAR 0 2
74865: ARRAY
74866: LESSEQUAL
74867: OR
74868: IFFALSE 74872
// continue ;
74870: GO 74122
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74872: LD_ADDR_VAR 0 6
74876: PUSH
74877: LD_EXP 23
74881: PUSH
74882: LD_VAR 0 2
74886: ARRAY
74887: PPUSH
74888: LD_INT 25
74890: PUSH
74891: LD_INT 3
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PPUSH
74898: CALL_OW 72
74902: PUSH
74903: LD_EXP 63
74907: PUSH
74908: LD_VAR 0 2
74912: ARRAY
74913: DIFF
74914: PPUSH
74915: LD_INT 3
74917: PPUSH
74918: CALL 46973 0 2
74922: ST_TO_ADDR
// for j in tmp do
74923: LD_ADDR_VAR 0 3
74927: PUSH
74928: LD_VAR 0 6
74932: PUSH
74933: FOR_IN
74934: IFFALSE 74969
// if GetTag ( j ) > 0 then
74936: LD_VAR 0 3
74940: PPUSH
74941: CALL_OW 110
74945: PUSH
74946: LD_INT 0
74948: GREATER
74949: IFFALSE 74967
// tmp := tmp diff j ;
74951: LD_ADDR_VAR 0 6
74955: PUSH
74956: LD_VAR 0 6
74960: PUSH
74961: LD_VAR 0 3
74965: DIFF
74966: ST_TO_ADDR
74967: GO 74933
74969: POP
74970: POP
// if not tmp then
74971: LD_VAR 0 6
74975: NOT
74976: IFFALSE 74980
// continue ;
74978: GO 74122
// if places then
74980: LD_VAR 0 5
74984: IFFALSE 75043
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74986: LD_ADDR_EXP 63
74990: PUSH
74991: LD_EXP 63
74995: PPUSH
74996: LD_VAR 0 2
75000: PPUSH
75001: LD_EXP 63
75005: PUSH
75006: LD_VAR 0 2
75010: ARRAY
75011: PUSH
75012: LD_VAR 0 6
75016: PUSH
75017: LD_INT 1
75019: ARRAY
75020: UNION
75021: PPUSH
75022: CALL_OW 1
75026: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75027: LD_VAR 0 6
75031: PUSH
75032: LD_INT 1
75034: ARRAY
75035: PPUSH
75036: LD_INT 126
75038: PPUSH
75039: CALL_OW 109
// end ; end ;
75043: GO 74122
75045: POP
75046: POP
// end ;
75047: LD_VAR 0 1
75051: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75052: LD_INT 0
75054: PPUSH
75055: PPUSH
75056: PPUSH
75057: PPUSH
75058: PPUSH
75059: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75060: LD_VAR 0 1
75064: NOT
75065: PUSH
75066: LD_VAR 0 2
75070: NOT
75071: OR
75072: PUSH
75073: LD_VAR 0 3
75077: NOT
75078: OR
75079: PUSH
75080: LD_VAR 0 4
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: LD_INT 2
75090: PUSH
75091: LD_INT 3
75093: PUSH
75094: LD_INT 4
75096: PUSH
75097: LD_INT 5
75099: PUSH
75100: LD_INT 8
75102: PUSH
75103: LD_INT 9
75105: PUSH
75106: LD_INT 15
75108: PUSH
75109: LD_INT 16
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: IN
75123: NOT
75124: OR
75125: IFFALSE 75129
// exit ;
75127: GO 76029
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75129: LD_ADDR_VAR 0 2
75133: PUSH
75134: LD_VAR 0 2
75138: PPUSH
75139: LD_INT 21
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 24
75151: PUSH
75152: LD_INT 250
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PPUSH
75163: CALL_OW 72
75167: ST_TO_ADDR
// case class of 1 , 15 :
75168: LD_VAR 0 4
75172: PUSH
75173: LD_INT 1
75175: DOUBLE
75176: EQUAL
75177: IFTRUE 75187
75179: LD_INT 15
75181: DOUBLE
75182: EQUAL
75183: IFTRUE 75187
75185: GO 75272
75187: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75188: LD_ADDR_VAR 0 8
75192: PUSH
75193: LD_VAR 0 2
75197: PPUSH
75198: LD_INT 2
75200: PUSH
75201: LD_INT 30
75203: PUSH
75204: LD_INT 32
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 30
75213: PUSH
75214: LD_INT 31
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: LIST
75225: PPUSH
75226: CALL_OW 72
75230: PUSH
75231: LD_VAR 0 2
75235: PPUSH
75236: LD_INT 2
75238: PUSH
75239: LD_INT 30
75241: PUSH
75242: LD_INT 4
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 30
75251: PUSH
75252: LD_INT 5
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: LIST
75263: PPUSH
75264: CALL_OW 72
75268: ADD
75269: ST_TO_ADDR
75270: GO 75518
75272: LD_INT 2
75274: DOUBLE
75275: EQUAL
75276: IFTRUE 75286
75278: LD_INT 16
75280: DOUBLE
75281: EQUAL
75282: IFTRUE 75286
75284: GO 75332
75286: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75287: LD_ADDR_VAR 0 8
75291: PUSH
75292: LD_VAR 0 2
75296: PPUSH
75297: LD_INT 2
75299: PUSH
75300: LD_INT 30
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 30
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: LIST
75324: PPUSH
75325: CALL_OW 72
75329: ST_TO_ADDR
75330: GO 75518
75332: LD_INT 3
75334: DOUBLE
75335: EQUAL
75336: IFTRUE 75340
75338: GO 75386
75340: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75341: LD_ADDR_VAR 0 8
75345: PUSH
75346: LD_VAR 0 2
75350: PPUSH
75351: LD_INT 2
75353: PUSH
75354: LD_INT 30
75356: PUSH
75357: LD_INT 2
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 30
75366: PUSH
75367: LD_INT 3
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: LIST
75378: PPUSH
75379: CALL_OW 72
75383: ST_TO_ADDR
75384: GO 75518
75386: LD_INT 4
75388: DOUBLE
75389: EQUAL
75390: IFTRUE 75394
75392: GO 75451
75394: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75395: LD_ADDR_VAR 0 8
75399: PUSH
75400: LD_VAR 0 2
75404: PPUSH
75405: LD_INT 2
75407: PUSH
75408: LD_INT 30
75410: PUSH
75411: LD_INT 6
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 30
75420: PUSH
75421: LD_INT 7
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 30
75430: PUSH
75431: LD_INT 8
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: PPUSH
75444: CALL_OW 72
75448: ST_TO_ADDR
75449: GO 75518
75451: LD_INT 5
75453: DOUBLE
75454: EQUAL
75455: IFTRUE 75471
75457: LD_INT 8
75459: DOUBLE
75460: EQUAL
75461: IFTRUE 75471
75463: LD_INT 9
75465: DOUBLE
75466: EQUAL
75467: IFTRUE 75471
75469: GO 75517
75471: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75472: LD_ADDR_VAR 0 8
75476: PUSH
75477: LD_VAR 0 2
75481: PPUSH
75482: LD_INT 2
75484: PUSH
75485: LD_INT 30
75487: PUSH
75488: LD_INT 4
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 30
75497: PUSH
75498: LD_INT 5
75500: PUSH
75501: EMPTY
75502: LIST
75503: LIST
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: LIST
75509: PPUSH
75510: CALL_OW 72
75514: ST_TO_ADDR
75515: GO 75518
75517: POP
// if not tmp then
75518: LD_VAR 0 8
75522: NOT
75523: IFFALSE 75527
// exit ;
75525: GO 76029
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75527: LD_VAR 0 4
75531: PUSH
75532: LD_INT 1
75534: PUSH
75535: LD_INT 15
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: IN
75542: PUSH
75543: LD_EXP 32
75547: PUSH
75548: LD_VAR 0 1
75552: ARRAY
75553: AND
75554: IFFALSE 75710
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75556: LD_ADDR_VAR 0 9
75560: PUSH
75561: LD_EXP 32
75565: PUSH
75566: LD_VAR 0 1
75570: ARRAY
75571: PUSH
75572: LD_INT 1
75574: ARRAY
75575: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75576: LD_VAR 0 9
75580: PUSH
75581: LD_EXP 33
75585: PUSH
75586: LD_VAR 0 1
75590: ARRAY
75591: IN
75592: NOT
75593: IFFALSE 75708
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75595: LD_ADDR_EXP 33
75599: PUSH
75600: LD_EXP 33
75604: PPUSH
75605: LD_VAR 0 1
75609: PUSH
75610: LD_EXP 33
75614: PUSH
75615: LD_VAR 0 1
75619: ARRAY
75620: PUSH
75621: LD_INT 1
75623: PLUS
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PPUSH
75629: LD_VAR 0 9
75633: PPUSH
75634: CALL 16152 0 3
75638: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75639: LD_ADDR_EXP 32
75643: PUSH
75644: LD_EXP 32
75648: PPUSH
75649: LD_VAR 0 1
75653: PPUSH
75654: LD_EXP 32
75658: PUSH
75659: LD_VAR 0 1
75663: ARRAY
75664: PUSH
75665: LD_VAR 0 9
75669: DIFF
75670: PPUSH
75671: CALL_OW 1
75675: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75676: LD_VAR 0 3
75680: PPUSH
75681: LD_EXP 33
75685: PUSH
75686: LD_VAR 0 1
75690: ARRAY
75691: PUSH
75692: LD_EXP 33
75696: PUSH
75697: LD_VAR 0 1
75701: ARRAY
75702: ARRAY
75703: PPUSH
75704: CALL_OW 120
// end ; exit ;
75708: GO 76029
// end ; if tmp > 1 then
75710: LD_VAR 0 8
75714: PUSH
75715: LD_INT 1
75717: GREATER
75718: IFFALSE 75822
// for i = 2 to tmp do
75720: LD_ADDR_VAR 0 6
75724: PUSH
75725: DOUBLE
75726: LD_INT 2
75728: DEC
75729: ST_TO_ADDR
75730: LD_VAR 0 8
75734: PUSH
75735: FOR_TO
75736: IFFALSE 75820
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75738: LD_VAR 0 8
75742: PUSH
75743: LD_VAR 0 6
75747: ARRAY
75748: PPUSH
75749: CALL_OW 461
75753: PUSH
75754: LD_INT 6
75756: EQUAL
75757: IFFALSE 75818
// begin x := tmp [ i ] ;
75759: LD_ADDR_VAR 0 9
75763: PUSH
75764: LD_VAR 0 8
75768: PUSH
75769: LD_VAR 0 6
75773: ARRAY
75774: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75775: LD_ADDR_VAR 0 8
75779: PUSH
75780: LD_VAR 0 8
75784: PPUSH
75785: LD_VAR 0 6
75789: PPUSH
75790: CALL_OW 3
75794: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75795: LD_ADDR_VAR 0 8
75799: PUSH
75800: LD_VAR 0 8
75804: PPUSH
75805: LD_INT 1
75807: PPUSH
75808: LD_VAR 0 9
75812: PPUSH
75813: CALL_OW 2
75817: ST_TO_ADDR
// end ;
75818: GO 75735
75820: POP
75821: POP
// for i in tmp do
75822: LD_ADDR_VAR 0 6
75826: PUSH
75827: LD_VAR 0 8
75831: PUSH
75832: FOR_IN
75833: IFFALSE 75902
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75835: LD_VAR 0 6
75839: PPUSH
75840: CALL_OW 313
75844: PUSH
75845: LD_INT 6
75847: LESS
75848: PUSH
75849: LD_VAR 0 6
75853: PPUSH
75854: CALL_OW 266
75858: PUSH
75859: LD_INT 31
75861: PUSH
75862: LD_INT 32
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: IN
75869: NOT
75870: AND
75871: PUSH
75872: LD_VAR 0 6
75876: PPUSH
75877: CALL_OW 313
75881: PUSH
75882: LD_INT 0
75884: EQUAL
75885: OR
75886: IFFALSE 75900
// begin j := i ;
75888: LD_ADDR_VAR 0 7
75892: PUSH
75893: LD_VAR 0 6
75897: ST_TO_ADDR
// break ;
75898: GO 75902
// end ; end ;
75900: GO 75832
75902: POP
75903: POP
// if j then
75904: LD_VAR 0 7
75908: IFFALSE 75926
// ComEnterUnit ( unit , j ) else
75910: LD_VAR 0 3
75914: PPUSH
75915: LD_VAR 0 7
75919: PPUSH
75920: CALL_OW 120
75924: GO 76029
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75926: LD_ADDR_VAR 0 10
75930: PUSH
75931: LD_VAR 0 2
75935: PPUSH
75936: LD_INT 2
75938: PUSH
75939: LD_INT 30
75941: PUSH
75942: LD_INT 0
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 30
75951: PUSH
75952: LD_INT 1
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: LIST
75963: PPUSH
75964: CALL_OW 72
75968: ST_TO_ADDR
// if depot then
75969: LD_VAR 0 10
75973: IFFALSE 76029
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75975: LD_ADDR_VAR 0 10
75979: PUSH
75980: LD_VAR 0 10
75984: PPUSH
75985: LD_VAR 0 3
75989: PPUSH
75990: CALL_OW 74
75994: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75995: LD_VAR 0 3
75999: PPUSH
76000: LD_VAR 0 10
76004: PPUSH
76005: CALL_OW 296
76009: PUSH
76010: LD_INT 10
76012: GREATER
76013: IFFALSE 76029
// ComStandNearbyBuilding ( unit , depot ) ;
76015: LD_VAR 0 3
76019: PPUSH
76020: LD_VAR 0 10
76024: PPUSH
76025: CALL 12579 0 2
// end ; end ; end ;
76029: LD_VAR 0 5
76033: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76034: LD_INT 0
76036: PPUSH
76037: PPUSH
76038: PPUSH
76039: PPUSH
// if not mc_bases then
76040: LD_EXP 23
76044: NOT
76045: IFFALSE 76049
// exit ;
76047: GO 76288
// for i = 1 to mc_bases do
76049: LD_ADDR_VAR 0 2
76053: PUSH
76054: DOUBLE
76055: LD_INT 1
76057: DEC
76058: ST_TO_ADDR
76059: LD_EXP 23
76063: PUSH
76064: FOR_TO
76065: IFFALSE 76286
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76067: LD_ADDR_VAR 0 4
76071: PUSH
76072: LD_EXP 23
76076: PUSH
76077: LD_VAR 0 2
76081: ARRAY
76082: PPUSH
76083: LD_INT 21
76085: PUSH
76086: LD_INT 1
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PPUSH
76093: CALL_OW 72
76097: PUSH
76098: LD_EXP 52
76102: PUSH
76103: LD_VAR 0 2
76107: ARRAY
76108: UNION
76109: ST_TO_ADDR
// if not tmp then
76110: LD_VAR 0 4
76114: NOT
76115: IFFALSE 76119
// continue ;
76117: GO 76064
// for j in tmp do
76119: LD_ADDR_VAR 0 3
76123: PUSH
76124: LD_VAR 0 4
76128: PUSH
76129: FOR_IN
76130: IFFALSE 76282
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76132: LD_VAR 0 3
76136: PPUSH
76137: CALL_OW 110
76141: NOT
76142: PUSH
76143: LD_VAR 0 3
76147: PPUSH
76148: CALL_OW 314
76152: NOT
76153: AND
76154: PUSH
76155: LD_VAR 0 3
76159: PPUSH
76160: CALL_OW 311
76164: NOT
76165: AND
76166: PUSH
76167: LD_VAR 0 3
76171: PPUSH
76172: CALL_OW 310
76176: NOT
76177: AND
76178: PUSH
76179: LD_VAR 0 3
76183: PUSH
76184: LD_EXP 26
76188: PUSH
76189: LD_VAR 0 2
76193: ARRAY
76194: PUSH
76195: LD_INT 1
76197: ARRAY
76198: IN
76199: NOT
76200: AND
76201: PUSH
76202: LD_VAR 0 3
76206: PUSH
76207: LD_EXP 26
76211: PUSH
76212: LD_VAR 0 2
76216: ARRAY
76217: PUSH
76218: LD_INT 2
76220: ARRAY
76221: IN
76222: NOT
76223: AND
76224: PUSH
76225: LD_VAR 0 3
76229: PUSH
76230: LD_EXP 35
76234: PUSH
76235: LD_VAR 0 2
76239: ARRAY
76240: IN
76241: NOT
76242: AND
76243: IFFALSE 76280
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76245: LD_VAR 0 2
76249: PPUSH
76250: LD_EXP 23
76254: PUSH
76255: LD_VAR 0 2
76259: ARRAY
76260: PPUSH
76261: LD_VAR 0 3
76265: PPUSH
76266: LD_VAR 0 3
76270: PPUSH
76271: CALL_OW 257
76275: PPUSH
76276: CALL 75052 0 4
// end ;
76280: GO 76129
76282: POP
76283: POP
// end ;
76284: GO 76064
76286: POP
76287: POP
// end ;
76288: LD_VAR 0 1
76292: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76293: LD_INT 0
76295: PPUSH
76296: PPUSH
76297: PPUSH
76298: PPUSH
76299: PPUSH
76300: PPUSH
// if not mc_bases [ base ] then
76301: LD_EXP 23
76305: PUSH
76306: LD_VAR 0 1
76310: ARRAY
76311: NOT
76312: IFFALSE 76316
// exit ;
76314: GO 76498
// tmp := [ ] ;
76316: LD_ADDR_VAR 0 6
76320: PUSH
76321: EMPTY
76322: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76323: LD_ADDR_VAR 0 7
76327: PUSH
76328: LD_VAR 0 3
76332: PPUSH
76333: LD_INT 0
76335: PPUSH
76336: CALL_OW 517
76340: ST_TO_ADDR
// if not list then
76341: LD_VAR 0 7
76345: NOT
76346: IFFALSE 76350
// exit ;
76348: GO 76498
// for i = 1 to amount do
76350: LD_ADDR_VAR 0 5
76354: PUSH
76355: DOUBLE
76356: LD_INT 1
76358: DEC
76359: ST_TO_ADDR
76360: LD_VAR 0 2
76364: PUSH
76365: FOR_TO
76366: IFFALSE 76446
// begin x := rand ( 1 , list [ 1 ] ) ;
76368: LD_ADDR_VAR 0 8
76372: PUSH
76373: LD_INT 1
76375: PPUSH
76376: LD_VAR 0 7
76380: PUSH
76381: LD_INT 1
76383: ARRAY
76384: PPUSH
76385: CALL_OW 12
76389: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76390: LD_ADDR_VAR 0 6
76394: PUSH
76395: LD_VAR 0 6
76399: PPUSH
76400: LD_VAR 0 5
76404: PPUSH
76405: LD_VAR 0 7
76409: PUSH
76410: LD_INT 1
76412: ARRAY
76413: PUSH
76414: LD_VAR 0 8
76418: ARRAY
76419: PUSH
76420: LD_VAR 0 7
76424: PUSH
76425: LD_INT 2
76427: ARRAY
76428: PUSH
76429: LD_VAR 0 8
76433: ARRAY
76434: PUSH
76435: EMPTY
76436: LIST
76437: LIST
76438: PPUSH
76439: CALL_OW 1
76443: ST_TO_ADDR
// end ;
76444: GO 76365
76446: POP
76447: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76448: LD_ADDR_EXP 36
76452: PUSH
76453: LD_EXP 36
76457: PPUSH
76458: LD_VAR 0 1
76462: PPUSH
76463: LD_VAR 0 6
76467: PPUSH
76468: CALL_OW 1
76472: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76473: LD_ADDR_EXP 38
76477: PUSH
76478: LD_EXP 38
76482: PPUSH
76483: LD_VAR 0 1
76487: PPUSH
76488: LD_VAR 0 3
76492: PPUSH
76493: CALL_OW 1
76497: ST_TO_ADDR
// end ;
76498: LD_VAR 0 4
76502: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76503: LD_INT 0
76505: PPUSH
// if not mc_bases [ base ] then
76506: LD_EXP 23
76510: PUSH
76511: LD_VAR 0 1
76515: ARRAY
76516: NOT
76517: IFFALSE 76521
// exit ;
76519: GO 76546
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76521: LD_ADDR_EXP 28
76525: PUSH
76526: LD_EXP 28
76530: PPUSH
76531: LD_VAR 0 1
76535: PPUSH
76536: LD_VAR 0 2
76540: PPUSH
76541: CALL_OW 1
76545: ST_TO_ADDR
// end ;
76546: LD_VAR 0 3
76550: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76551: LD_INT 0
76553: PPUSH
// if not mc_bases [ base ] then
76554: LD_EXP 23
76558: PUSH
76559: LD_VAR 0 1
76563: ARRAY
76564: NOT
76565: IFFALSE 76569
// exit ;
76567: GO 76606
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76569: LD_ADDR_EXP 28
76573: PUSH
76574: LD_EXP 28
76578: PPUSH
76579: LD_VAR 0 1
76583: PPUSH
76584: LD_EXP 28
76588: PUSH
76589: LD_VAR 0 1
76593: ARRAY
76594: PUSH
76595: LD_VAR 0 2
76599: UNION
76600: PPUSH
76601: CALL_OW 1
76605: ST_TO_ADDR
// end ;
76606: LD_VAR 0 3
76610: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76611: LD_INT 0
76613: PPUSH
// if not mc_bases [ base ] then
76614: LD_EXP 23
76618: PUSH
76619: LD_VAR 0 1
76623: ARRAY
76624: NOT
76625: IFFALSE 76629
// exit ;
76627: GO 76654
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76629: LD_ADDR_EXP 44
76633: PUSH
76634: LD_EXP 44
76638: PPUSH
76639: LD_VAR 0 1
76643: PPUSH
76644: LD_VAR 0 2
76648: PPUSH
76649: CALL_OW 1
76653: ST_TO_ADDR
// end ;
76654: LD_VAR 0 3
76658: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76659: LD_INT 0
76661: PPUSH
// if not mc_bases [ base ] then
76662: LD_EXP 23
76666: PUSH
76667: LD_VAR 0 1
76671: ARRAY
76672: NOT
76673: IFFALSE 76677
// exit ;
76675: GO 76714
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76677: LD_ADDR_EXP 44
76681: PUSH
76682: LD_EXP 44
76686: PPUSH
76687: LD_VAR 0 1
76691: PPUSH
76692: LD_EXP 44
76696: PUSH
76697: LD_VAR 0 1
76701: ARRAY
76702: PUSH
76703: LD_VAR 0 2
76707: ADD
76708: PPUSH
76709: CALL_OW 1
76713: ST_TO_ADDR
// end ;
76714: LD_VAR 0 3
76718: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76719: LD_INT 0
76721: PPUSH
// if not mc_bases [ base ] then
76722: LD_EXP 23
76726: PUSH
76727: LD_VAR 0 1
76731: ARRAY
76732: NOT
76733: IFFALSE 76737
// exit ;
76735: GO 76791
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76737: LD_ADDR_EXP 45
76741: PUSH
76742: LD_EXP 45
76746: PPUSH
76747: LD_VAR 0 1
76751: PPUSH
76752: LD_VAR 0 2
76756: PPUSH
76757: CALL_OW 1
76761: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76762: LD_ADDR_EXP 34
76766: PUSH
76767: LD_EXP 34
76771: PPUSH
76772: LD_VAR 0 1
76776: PPUSH
76777: LD_VAR 0 2
76781: PUSH
76782: LD_INT 0
76784: PLUS
76785: PPUSH
76786: CALL_OW 1
76790: ST_TO_ADDR
// end ;
76791: LD_VAR 0 3
76795: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76796: LD_INT 0
76798: PPUSH
// if not mc_bases [ base ] then
76799: LD_EXP 23
76803: PUSH
76804: LD_VAR 0 1
76808: ARRAY
76809: NOT
76810: IFFALSE 76814
// exit ;
76812: GO 76839
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76814: LD_ADDR_EXP 34
76818: PUSH
76819: LD_EXP 34
76823: PPUSH
76824: LD_VAR 0 1
76828: PPUSH
76829: LD_VAR 0 2
76833: PPUSH
76834: CALL_OW 1
76838: ST_TO_ADDR
// end ;
76839: LD_VAR 0 3
76843: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76844: LD_INT 0
76846: PPUSH
76847: PPUSH
76848: PPUSH
76849: PPUSH
// if not mc_bases [ base ] then
76850: LD_EXP 23
76854: PUSH
76855: LD_VAR 0 1
76859: ARRAY
76860: NOT
76861: IFFALSE 76865
// exit ;
76863: GO 76930
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76865: LD_ADDR_EXP 43
76869: PUSH
76870: LD_EXP 43
76874: PPUSH
76875: LD_VAR 0 1
76879: PUSH
76880: LD_EXP 43
76884: PUSH
76885: LD_VAR 0 1
76889: ARRAY
76890: PUSH
76891: LD_INT 1
76893: PLUS
76894: PUSH
76895: EMPTY
76896: LIST
76897: LIST
76898: PPUSH
76899: LD_VAR 0 1
76903: PUSH
76904: LD_VAR 0 2
76908: PUSH
76909: LD_VAR 0 3
76913: PUSH
76914: LD_VAR 0 4
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: PPUSH
76925: CALL 16152 0 3
76929: ST_TO_ADDR
// end ;
76930: LD_VAR 0 5
76934: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76935: LD_INT 0
76937: PPUSH
// if not mc_bases [ base ] then
76938: LD_EXP 23
76942: PUSH
76943: LD_VAR 0 1
76947: ARRAY
76948: NOT
76949: IFFALSE 76953
// exit ;
76951: GO 76978
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76953: LD_ADDR_EXP 60
76957: PUSH
76958: LD_EXP 60
76962: PPUSH
76963: LD_VAR 0 1
76967: PPUSH
76968: LD_VAR 0 2
76972: PPUSH
76973: CALL_OW 1
76977: ST_TO_ADDR
// end ;
76978: LD_VAR 0 3
76982: RET
// export function MC_GetMinesField ( base ) ; begin
76983: LD_INT 0
76985: PPUSH
// result := mc_mines [ base ] ;
76986: LD_ADDR_VAR 0 2
76990: PUSH
76991: LD_EXP 36
76995: PUSH
76996: LD_VAR 0 1
77000: ARRAY
77001: ST_TO_ADDR
// end ;
77002: LD_VAR 0 2
77006: RET
// export function MC_GetProduceList ( base ) ; begin
77007: LD_INT 0
77009: PPUSH
// result := mc_produce [ base ] ;
77010: LD_ADDR_VAR 0 2
77014: PUSH
77015: LD_EXP 44
77019: PUSH
77020: LD_VAR 0 1
77024: ARRAY
77025: ST_TO_ADDR
// end ;
77026: LD_VAR 0 2
77030: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77031: LD_INT 0
77033: PPUSH
77034: PPUSH
// if not mc_bases then
77035: LD_EXP 23
77039: NOT
77040: IFFALSE 77044
// exit ;
77042: GO 77109
// if mc_bases [ base ] then
77044: LD_EXP 23
77048: PUSH
77049: LD_VAR 0 1
77053: ARRAY
77054: IFFALSE 77109
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77056: LD_ADDR_VAR 0 3
77060: PUSH
77061: LD_EXP 23
77065: PUSH
77066: LD_VAR 0 1
77070: ARRAY
77071: PPUSH
77072: LD_INT 30
77074: PUSH
77075: LD_VAR 0 2
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PPUSH
77084: CALL_OW 72
77088: ST_TO_ADDR
// if result then
77089: LD_VAR 0 3
77093: IFFALSE 77109
// result := result [ 1 ] ;
77095: LD_ADDR_VAR 0 3
77099: PUSH
77100: LD_VAR 0 3
77104: PUSH
77105: LD_INT 1
77107: ARRAY
77108: ST_TO_ADDR
// end ; end ;
77109: LD_VAR 0 3
77113: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77114: LD_INT 0
77116: PPUSH
77117: PPUSH
// if not mc_bases then
77118: LD_EXP 23
77122: NOT
77123: IFFALSE 77127
// exit ;
77125: GO 77172
// if mc_bases [ base ] then
77127: LD_EXP 23
77131: PUSH
77132: LD_VAR 0 1
77136: ARRAY
77137: IFFALSE 77172
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77139: LD_ADDR_VAR 0 3
77143: PUSH
77144: LD_EXP 23
77148: PUSH
77149: LD_VAR 0 1
77153: ARRAY
77154: PPUSH
77155: LD_INT 30
77157: PUSH
77158: LD_VAR 0 2
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PPUSH
77167: CALL_OW 72
77171: ST_TO_ADDR
// end ;
77172: LD_VAR 0 3
77176: RET
// export function MC_SetTame ( base , area ) ; begin
77177: LD_INT 0
77179: PPUSH
// if not mc_bases or not base then
77180: LD_EXP 23
77184: NOT
77185: PUSH
77186: LD_VAR 0 1
77190: NOT
77191: OR
77192: IFFALSE 77196
// exit ;
77194: GO 77221
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77196: LD_ADDR_EXP 51
77200: PUSH
77201: LD_EXP 51
77205: PPUSH
77206: LD_VAR 0 1
77210: PPUSH
77211: LD_VAR 0 2
77215: PPUSH
77216: CALL_OW 1
77220: ST_TO_ADDR
// end ;
77221: LD_VAR 0 3
77225: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77226: LD_INT 0
77228: PPUSH
77229: PPUSH
// if not mc_bases or not base then
77230: LD_EXP 23
77234: NOT
77235: PUSH
77236: LD_VAR 0 1
77240: NOT
77241: OR
77242: IFFALSE 77246
// exit ;
77244: GO 77348
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77246: LD_ADDR_VAR 0 4
77250: PUSH
77251: LD_EXP 23
77255: PUSH
77256: LD_VAR 0 1
77260: ARRAY
77261: PPUSH
77262: LD_INT 30
77264: PUSH
77265: LD_VAR 0 2
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PPUSH
77274: CALL_OW 72
77278: ST_TO_ADDR
// if not tmp then
77279: LD_VAR 0 4
77283: NOT
77284: IFFALSE 77288
// exit ;
77286: GO 77348
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77288: LD_ADDR_EXP 55
77292: PUSH
77293: LD_EXP 55
77297: PPUSH
77298: LD_VAR 0 1
77302: PPUSH
77303: LD_EXP 55
77307: PUSH
77308: LD_VAR 0 1
77312: ARRAY
77313: PPUSH
77314: LD_EXP 55
77318: PUSH
77319: LD_VAR 0 1
77323: ARRAY
77324: PUSH
77325: LD_INT 1
77327: PLUS
77328: PPUSH
77329: LD_VAR 0 4
77333: PUSH
77334: LD_INT 1
77336: ARRAY
77337: PPUSH
77338: CALL_OW 2
77342: PPUSH
77343: CALL_OW 1
77347: ST_TO_ADDR
// end ;
77348: LD_VAR 0 3
77352: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77353: LD_INT 0
77355: PPUSH
77356: PPUSH
// if not mc_bases or not base or not kinds then
77357: LD_EXP 23
77361: NOT
77362: PUSH
77363: LD_VAR 0 1
77367: NOT
77368: OR
77369: PUSH
77370: LD_VAR 0 2
77374: NOT
77375: OR
77376: IFFALSE 77380
// exit ;
77378: GO 77441
// for i in kinds do
77380: LD_ADDR_VAR 0 4
77384: PUSH
77385: LD_VAR 0 2
77389: PUSH
77390: FOR_IN
77391: IFFALSE 77439
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77393: LD_ADDR_EXP 57
77397: PUSH
77398: LD_EXP 57
77402: PPUSH
77403: LD_VAR 0 1
77407: PUSH
77408: LD_EXP 57
77412: PUSH
77413: LD_VAR 0 1
77417: ARRAY
77418: PUSH
77419: LD_INT 1
77421: PLUS
77422: PUSH
77423: EMPTY
77424: LIST
77425: LIST
77426: PPUSH
77427: LD_VAR 0 4
77431: PPUSH
77432: CALL 16152 0 3
77436: ST_TO_ADDR
77437: GO 77390
77439: POP
77440: POP
// end ;
77441: LD_VAR 0 3
77445: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77446: LD_INT 0
77448: PPUSH
// if not mc_bases or not base or not areas then
77449: LD_EXP 23
77453: NOT
77454: PUSH
77455: LD_VAR 0 1
77459: NOT
77460: OR
77461: PUSH
77462: LD_VAR 0 2
77466: NOT
77467: OR
77468: IFFALSE 77472
// exit ;
77470: GO 77497
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77472: LD_ADDR_EXP 41
77476: PUSH
77477: LD_EXP 41
77481: PPUSH
77482: LD_VAR 0 1
77486: PPUSH
77487: LD_VAR 0 2
77491: PPUSH
77492: CALL_OW 1
77496: ST_TO_ADDR
// end ;
77497: LD_VAR 0 3
77501: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77502: LD_INT 0
77504: PPUSH
// if not mc_bases or not base or not teleports_exit then
77505: LD_EXP 23
77509: NOT
77510: PUSH
77511: LD_VAR 0 1
77515: NOT
77516: OR
77517: PUSH
77518: LD_VAR 0 2
77522: NOT
77523: OR
77524: IFFALSE 77528
// exit ;
77526: GO 77553
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77528: LD_ADDR_EXP 58
77532: PUSH
77533: LD_EXP 58
77537: PPUSH
77538: LD_VAR 0 1
77542: PPUSH
77543: LD_VAR 0 2
77547: PPUSH
77548: CALL_OW 1
77552: ST_TO_ADDR
// end ;
77553: LD_VAR 0 3
77557: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77558: LD_INT 0
77560: PPUSH
77561: PPUSH
77562: PPUSH
// if not mc_bases or not base or not ext_list then
77563: LD_EXP 23
77567: NOT
77568: PUSH
77569: LD_VAR 0 1
77573: NOT
77574: OR
77575: PUSH
77576: LD_VAR 0 5
77580: NOT
77581: OR
77582: IFFALSE 77586
// exit ;
77584: GO 77759
// tmp := GetFacExtXYD ( x , y , d ) ;
77586: LD_ADDR_VAR 0 8
77590: PUSH
77591: LD_VAR 0 2
77595: PPUSH
77596: LD_VAR 0 3
77600: PPUSH
77601: LD_VAR 0 4
77605: PPUSH
77606: CALL 46103 0 3
77610: ST_TO_ADDR
// if not tmp then
77611: LD_VAR 0 8
77615: NOT
77616: IFFALSE 77620
// exit ;
77618: GO 77759
// for i in tmp do
77620: LD_ADDR_VAR 0 7
77624: PUSH
77625: LD_VAR 0 8
77629: PUSH
77630: FOR_IN
77631: IFFALSE 77757
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77633: LD_ADDR_EXP 28
77637: PUSH
77638: LD_EXP 28
77642: PPUSH
77643: LD_VAR 0 1
77647: PPUSH
77648: LD_EXP 28
77652: PUSH
77653: LD_VAR 0 1
77657: ARRAY
77658: PPUSH
77659: LD_EXP 28
77663: PUSH
77664: LD_VAR 0 1
77668: ARRAY
77669: PUSH
77670: LD_INT 1
77672: PLUS
77673: PPUSH
77674: LD_VAR 0 5
77678: PUSH
77679: LD_INT 1
77681: ARRAY
77682: PUSH
77683: LD_VAR 0 7
77687: PUSH
77688: LD_INT 1
77690: ARRAY
77691: PUSH
77692: LD_VAR 0 7
77696: PUSH
77697: LD_INT 2
77699: ARRAY
77700: PUSH
77701: LD_VAR 0 7
77705: PUSH
77706: LD_INT 3
77708: ARRAY
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: PPUSH
77716: CALL_OW 2
77720: PPUSH
77721: CALL_OW 1
77725: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77726: LD_ADDR_VAR 0 5
77730: PUSH
77731: LD_VAR 0 5
77735: PPUSH
77736: LD_INT 1
77738: PPUSH
77739: CALL_OW 3
77743: ST_TO_ADDR
// if not ext_list then
77744: LD_VAR 0 5
77748: NOT
77749: IFFALSE 77755
// exit ;
77751: POP
77752: POP
77753: GO 77759
// end ;
77755: GO 77630
77757: POP
77758: POP
// end ;
77759: LD_VAR 0 6
77763: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77764: LD_INT 0
77766: PPUSH
// if not mc_bases or not base or not weapon_list then
77767: LD_EXP 23
77771: NOT
77772: PUSH
77773: LD_VAR 0 1
77777: NOT
77778: OR
77779: PUSH
77780: LD_VAR 0 2
77784: NOT
77785: OR
77786: IFFALSE 77790
// exit ;
77788: GO 77815
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77790: LD_ADDR_EXP 62
77794: PUSH
77795: LD_EXP 62
77799: PPUSH
77800: LD_VAR 0 1
77804: PPUSH
77805: LD_VAR 0 2
77809: PPUSH
77810: CALL_OW 1
77814: ST_TO_ADDR
// end ;
77815: LD_VAR 0 3
77819: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77820: LD_INT 0
77822: PPUSH
// if not mc_bases or not base or not tech_list then
77823: LD_EXP 23
77827: NOT
77828: PUSH
77829: LD_VAR 0 1
77833: NOT
77834: OR
77835: PUSH
77836: LD_VAR 0 2
77840: NOT
77841: OR
77842: IFFALSE 77846
// exit ;
77844: GO 77871
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77846: LD_ADDR_EXP 50
77850: PUSH
77851: LD_EXP 50
77855: PPUSH
77856: LD_VAR 0 1
77860: PPUSH
77861: LD_VAR 0 2
77865: PPUSH
77866: CALL_OW 1
77870: ST_TO_ADDR
// end ;
77871: LD_VAR 0 3
77875: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77876: LD_INT 0
77878: PPUSH
// if not mc_bases or not parking_area or not base then
77879: LD_EXP 23
77883: NOT
77884: PUSH
77885: LD_VAR 0 2
77889: NOT
77890: OR
77891: PUSH
77892: LD_VAR 0 1
77896: NOT
77897: OR
77898: IFFALSE 77902
// exit ;
77900: GO 77927
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77902: LD_ADDR_EXP 47
77906: PUSH
77907: LD_EXP 47
77911: PPUSH
77912: LD_VAR 0 1
77916: PPUSH
77917: LD_VAR 0 2
77921: PPUSH
77922: CALL_OW 1
77926: ST_TO_ADDR
// end ;
77927: LD_VAR 0 3
77931: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77932: LD_INT 0
77934: PPUSH
// if not mc_bases or not base or not scan_area then
77935: LD_EXP 23
77939: NOT
77940: PUSH
77941: LD_VAR 0 1
77945: NOT
77946: OR
77947: PUSH
77948: LD_VAR 0 2
77952: NOT
77953: OR
77954: IFFALSE 77958
// exit ;
77956: GO 77983
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77958: LD_ADDR_EXP 48
77962: PUSH
77963: LD_EXP 48
77967: PPUSH
77968: LD_VAR 0 1
77972: PPUSH
77973: LD_VAR 0 2
77977: PPUSH
77978: CALL_OW 1
77982: ST_TO_ADDR
// end ;
77983: LD_VAR 0 3
77987: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77988: LD_INT 0
77990: PPUSH
77991: PPUSH
// if not mc_bases or not base then
77992: LD_EXP 23
77996: NOT
77997: PUSH
77998: LD_VAR 0 1
78002: NOT
78003: OR
78004: IFFALSE 78008
// exit ;
78006: GO 78072
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78008: LD_ADDR_VAR 0 3
78012: PUSH
78013: LD_INT 1
78015: PUSH
78016: LD_INT 2
78018: PUSH
78019: LD_INT 3
78021: PUSH
78022: LD_INT 4
78024: PUSH
78025: LD_INT 11
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: LIST
78034: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78035: LD_ADDR_EXP 50
78039: PUSH
78040: LD_EXP 50
78044: PPUSH
78045: LD_VAR 0 1
78049: PPUSH
78050: LD_EXP 50
78054: PUSH
78055: LD_VAR 0 1
78059: ARRAY
78060: PUSH
78061: LD_VAR 0 3
78065: DIFF
78066: PPUSH
78067: CALL_OW 1
78071: ST_TO_ADDR
// end ;
78072: LD_VAR 0 2
78076: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78077: LD_INT 0
78079: PPUSH
// result := mc_vehicles [ base ] ;
78080: LD_ADDR_VAR 0 3
78084: PUSH
78085: LD_EXP 42
78089: PUSH
78090: LD_VAR 0 1
78094: ARRAY
78095: ST_TO_ADDR
// if onlyCombat then
78096: LD_VAR 0 2
78100: IFFALSE 78272
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78102: LD_ADDR_VAR 0 3
78106: PUSH
78107: LD_VAR 0 3
78111: PUSH
78112: LD_VAR 0 3
78116: PPUSH
78117: LD_INT 2
78119: PUSH
78120: LD_INT 34
78122: PUSH
78123: LD_INT 12
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 34
78132: PUSH
78133: LD_INT 51
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 34
78142: PUSH
78143: LD_INT 89
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 34
78152: PUSH
78153: LD_INT 32
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 34
78162: PUSH
78163: LD_INT 13
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 34
78172: PUSH
78173: LD_INT 52
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 34
78182: PUSH
78183: LD_INT 88
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 34
78192: PUSH
78193: LD_INT 14
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 34
78202: PUSH
78203: LD_INT 53
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: LD_INT 34
78212: PUSH
78213: LD_INT 98
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 34
78222: PUSH
78223: LD_INT 31
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 34
78232: PUSH
78233: LD_INT 48
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 34
78242: PUSH
78243: LD_INT 8
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: LIST
78265: PPUSH
78266: CALL_OW 72
78270: DIFF
78271: ST_TO_ADDR
// end ; end_of_file
78272: LD_VAR 0 3
78276: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78277: LD_INT 0
78279: PPUSH
78280: PPUSH
78281: PPUSH
// if not mc_bases or not skirmish then
78282: LD_EXP 23
78286: NOT
78287: PUSH
78288: LD_EXP 21
78292: NOT
78293: OR
78294: IFFALSE 78298
// exit ;
78296: GO 78463
// for i = 1 to mc_bases do
78298: LD_ADDR_VAR 0 4
78302: PUSH
78303: DOUBLE
78304: LD_INT 1
78306: DEC
78307: ST_TO_ADDR
78308: LD_EXP 23
78312: PUSH
78313: FOR_TO
78314: IFFALSE 78461
// begin if sci in mc_bases [ i ] then
78316: LD_VAR 0 2
78320: PUSH
78321: LD_EXP 23
78325: PUSH
78326: LD_VAR 0 4
78330: ARRAY
78331: IN
78332: IFFALSE 78459
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78334: LD_ADDR_EXP 52
78338: PUSH
78339: LD_EXP 52
78343: PPUSH
78344: LD_VAR 0 4
78348: PUSH
78349: LD_EXP 52
78353: PUSH
78354: LD_VAR 0 4
78358: ARRAY
78359: PUSH
78360: LD_INT 1
78362: PLUS
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PPUSH
78368: LD_VAR 0 1
78372: PPUSH
78373: CALL 16152 0 3
78377: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78378: LD_ADDR_VAR 0 5
78382: PUSH
78383: LD_EXP 23
78387: PUSH
78388: LD_VAR 0 4
78392: ARRAY
78393: PPUSH
78394: LD_INT 2
78396: PUSH
78397: LD_INT 30
78399: PUSH
78400: LD_INT 0
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 30
78409: PUSH
78410: LD_INT 1
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: LIST
78421: PPUSH
78422: CALL_OW 72
78426: PPUSH
78427: LD_VAR 0 1
78431: PPUSH
78432: CALL_OW 74
78436: ST_TO_ADDR
// if tmp then
78437: LD_VAR 0 5
78441: IFFALSE 78457
// ComStandNearbyBuilding ( ape , tmp ) ;
78443: LD_VAR 0 1
78447: PPUSH
78448: LD_VAR 0 5
78452: PPUSH
78453: CALL 12579 0 2
// break ;
78457: GO 78461
// end ; end ;
78459: GO 78313
78461: POP
78462: POP
// end ;
78463: LD_VAR 0 3
78467: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78468: LD_INT 0
78470: PPUSH
78471: PPUSH
78472: PPUSH
// if not mc_bases or not skirmish then
78473: LD_EXP 23
78477: NOT
78478: PUSH
78479: LD_EXP 21
78483: NOT
78484: OR
78485: IFFALSE 78489
// exit ;
78487: GO 78578
// for i = 1 to mc_bases do
78489: LD_ADDR_VAR 0 4
78493: PUSH
78494: DOUBLE
78495: LD_INT 1
78497: DEC
78498: ST_TO_ADDR
78499: LD_EXP 23
78503: PUSH
78504: FOR_TO
78505: IFFALSE 78576
// begin if building in mc_busy_turret_list [ i ] then
78507: LD_VAR 0 1
78511: PUSH
78512: LD_EXP 33
78516: PUSH
78517: LD_VAR 0 4
78521: ARRAY
78522: IN
78523: IFFALSE 78574
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78525: LD_ADDR_VAR 0 5
78529: PUSH
78530: LD_EXP 33
78534: PUSH
78535: LD_VAR 0 4
78539: ARRAY
78540: PUSH
78541: LD_VAR 0 1
78545: DIFF
78546: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78547: LD_ADDR_EXP 33
78551: PUSH
78552: LD_EXP 33
78556: PPUSH
78557: LD_VAR 0 4
78561: PPUSH
78562: LD_VAR 0 5
78566: PPUSH
78567: CALL_OW 1
78571: ST_TO_ADDR
// break ;
78572: GO 78576
// end ; end ;
78574: GO 78504
78576: POP
78577: POP
// end ;
78578: LD_VAR 0 3
78582: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78583: LD_INT 0
78585: PPUSH
78586: PPUSH
78587: PPUSH
// if not mc_bases or not skirmish then
78588: LD_EXP 23
78592: NOT
78593: PUSH
78594: LD_EXP 21
78598: NOT
78599: OR
78600: IFFALSE 78604
// exit ;
78602: GO 78803
// for i = 1 to mc_bases do
78604: LD_ADDR_VAR 0 5
78608: PUSH
78609: DOUBLE
78610: LD_INT 1
78612: DEC
78613: ST_TO_ADDR
78614: LD_EXP 23
78618: PUSH
78619: FOR_TO
78620: IFFALSE 78801
// if building in mc_bases [ i ] then
78622: LD_VAR 0 1
78626: PUSH
78627: LD_EXP 23
78631: PUSH
78632: LD_VAR 0 5
78636: ARRAY
78637: IN
78638: IFFALSE 78799
// begin tmp := mc_bases [ i ] diff building ;
78640: LD_ADDR_VAR 0 6
78644: PUSH
78645: LD_EXP 23
78649: PUSH
78650: LD_VAR 0 5
78654: ARRAY
78655: PUSH
78656: LD_VAR 0 1
78660: DIFF
78661: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78662: LD_ADDR_EXP 23
78666: PUSH
78667: LD_EXP 23
78671: PPUSH
78672: LD_VAR 0 5
78676: PPUSH
78677: LD_VAR 0 6
78681: PPUSH
78682: CALL_OW 1
78686: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78687: LD_VAR 0 1
78691: PUSH
78692: LD_EXP 31
78696: PUSH
78697: LD_VAR 0 5
78701: ARRAY
78702: IN
78703: IFFALSE 78742
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78705: LD_ADDR_EXP 31
78709: PUSH
78710: LD_EXP 31
78714: PPUSH
78715: LD_VAR 0 5
78719: PPUSH
78720: LD_EXP 31
78724: PUSH
78725: LD_VAR 0 5
78729: ARRAY
78730: PUSH
78731: LD_VAR 0 1
78735: DIFF
78736: PPUSH
78737: CALL_OW 1
78741: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78742: LD_VAR 0 1
78746: PUSH
78747: LD_EXP 32
78751: PUSH
78752: LD_VAR 0 5
78756: ARRAY
78757: IN
78758: IFFALSE 78797
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78760: LD_ADDR_EXP 32
78764: PUSH
78765: LD_EXP 32
78769: PPUSH
78770: LD_VAR 0 5
78774: PPUSH
78775: LD_EXP 32
78779: PUSH
78780: LD_VAR 0 5
78784: ARRAY
78785: PUSH
78786: LD_VAR 0 1
78790: DIFF
78791: PPUSH
78792: CALL_OW 1
78796: ST_TO_ADDR
// break ;
78797: GO 78801
// end ;
78799: GO 78619
78801: POP
78802: POP
// end ;
78803: LD_VAR 0 4
78807: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78808: LD_INT 0
78810: PPUSH
78811: PPUSH
78812: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78813: LD_EXP 23
78817: NOT
78818: PUSH
78819: LD_EXP 21
78823: NOT
78824: OR
78825: PUSH
78826: LD_VAR 0 3
78830: PUSH
78831: LD_EXP 49
78835: IN
78836: NOT
78837: OR
78838: IFFALSE 78842
// exit ;
78840: GO 78965
// for i = 1 to mc_vehicles do
78842: LD_ADDR_VAR 0 6
78846: PUSH
78847: DOUBLE
78848: LD_INT 1
78850: DEC
78851: ST_TO_ADDR
78852: LD_EXP 42
78856: PUSH
78857: FOR_TO
78858: IFFALSE 78963
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78860: LD_VAR 0 2
78864: PUSH
78865: LD_EXP 42
78869: PUSH
78870: LD_VAR 0 6
78874: ARRAY
78875: IN
78876: PUSH
78877: LD_VAR 0 1
78881: PUSH
78882: LD_EXP 42
78886: PUSH
78887: LD_VAR 0 6
78891: ARRAY
78892: IN
78893: OR
78894: IFFALSE 78961
// begin tmp := mc_vehicles [ i ] diff old ;
78896: LD_ADDR_VAR 0 7
78900: PUSH
78901: LD_EXP 42
78905: PUSH
78906: LD_VAR 0 6
78910: ARRAY
78911: PUSH
78912: LD_VAR 0 2
78916: DIFF
78917: ST_TO_ADDR
// tmp := tmp diff new ;
78918: LD_ADDR_VAR 0 7
78922: PUSH
78923: LD_VAR 0 7
78927: PUSH
78928: LD_VAR 0 1
78932: DIFF
78933: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78934: LD_ADDR_EXP 42
78938: PUSH
78939: LD_EXP 42
78943: PPUSH
78944: LD_VAR 0 6
78948: PPUSH
78949: LD_VAR 0 7
78953: PPUSH
78954: CALL_OW 1
78958: ST_TO_ADDR
// break ;
78959: GO 78963
// end ;
78961: GO 78857
78963: POP
78964: POP
// end ;
78965: LD_VAR 0 5
78969: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78970: LD_INT 0
78972: PPUSH
78973: PPUSH
78974: PPUSH
78975: PPUSH
// if not mc_bases or not skirmish then
78976: LD_EXP 23
78980: NOT
78981: PUSH
78982: LD_EXP 21
78986: NOT
78987: OR
78988: IFFALSE 78992
// exit ;
78990: GO 79374
// side := GetSide ( vehicle ) ;
78992: LD_ADDR_VAR 0 5
78996: PUSH
78997: LD_VAR 0 1
79001: PPUSH
79002: CALL_OW 255
79006: ST_TO_ADDR
// for i = 1 to mc_bases do
79007: LD_ADDR_VAR 0 4
79011: PUSH
79012: DOUBLE
79013: LD_INT 1
79015: DEC
79016: ST_TO_ADDR
79017: LD_EXP 23
79021: PUSH
79022: FOR_TO
79023: IFFALSE 79372
// begin if factory in mc_bases [ i ] then
79025: LD_VAR 0 2
79029: PUSH
79030: LD_EXP 23
79034: PUSH
79035: LD_VAR 0 4
79039: ARRAY
79040: IN
79041: IFFALSE 79370
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79043: LD_EXP 45
79047: PUSH
79048: LD_VAR 0 4
79052: ARRAY
79053: PUSH
79054: LD_EXP 34
79058: PUSH
79059: LD_VAR 0 4
79063: ARRAY
79064: LESS
79065: PUSH
79066: LD_VAR 0 1
79070: PPUSH
79071: CALL_OW 264
79075: PUSH
79076: LD_INT 31
79078: PUSH
79079: LD_INT 32
79081: PUSH
79082: LD_INT 51
79084: PUSH
79085: LD_INT 89
79087: PUSH
79088: LD_INT 12
79090: PUSH
79091: LD_INT 30
79093: PUSH
79094: LD_INT 98
79096: PUSH
79097: LD_INT 11
79099: PUSH
79100: LD_INT 53
79102: PUSH
79103: LD_INT 14
79105: PUSH
79106: LD_INT 91
79108: PUSH
79109: LD_INT 29
79111: PUSH
79112: LD_INT 99
79114: PUSH
79115: LD_INT 13
79117: PUSH
79118: LD_INT 52
79120: PUSH
79121: LD_INT 88
79123: PUSH
79124: LD_INT 48
79126: PUSH
79127: LD_INT 8
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: IN
79150: NOT
79151: AND
79152: IFFALSE 79200
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79154: LD_ADDR_EXP 45
79158: PUSH
79159: LD_EXP 45
79163: PPUSH
79164: LD_VAR 0 4
79168: PUSH
79169: LD_EXP 45
79173: PUSH
79174: LD_VAR 0 4
79178: ARRAY
79179: PUSH
79180: LD_INT 1
79182: PLUS
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PPUSH
79188: LD_VAR 0 1
79192: PPUSH
79193: CALL 16152 0 3
79197: ST_TO_ADDR
79198: GO 79244
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79200: LD_ADDR_EXP 42
79204: PUSH
79205: LD_EXP 42
79209: PPUSH
79210: LD_VAR 0 4
79214: PUSH
79215: LD_EXP 42
79219: PUSH
79220: LD_VAR 0 4
79224: ARRAY
79225: PUSH
79226: LD_INT 1
79228: PLUS
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PPUSH
79234: LD_VAR 0 1
79238: PPUSH
79239: CALL 16152 0 3
79243: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79244: LD_VAR 0 1
79248: PPUSH
79249: CALL_OW 263
79253: PUSH
79254: LD_INT 2
79256: EQUAL
79257: IFFALSE 79286
// begin repeat wait ( 0 0$3 ) ;
79259: LD_INT 105
79261: PPUSH
79262: CALL_OW 67
// Connect ( vehicle ) ;
79266: LD_VAR 0 1
79270: PPUSH
79271: CALL 19121 0 1
// until IsControledBy ( vehicle ) ;
79275: LD_VAR 0 1
79279: PPUSH
79280: CALL_OW 312
79284: IFFALSE 79259
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79286: LD_VAR 0 1
79290: PPUSH
79291: LD_EXP 47
79295: PUSH
79296: LD_VAR 0 4
79300: ARRAY
79301: PPUSH
79302: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79306: LD_VAR 0 1
79310: PPUSH
79311: CALL_OW 263
79315: PUSH
79316: LD_INT 1
79318: NONEQUAL
79319: IFFALSE 79323
// break ;
79321: GO 79372
// repeat wait ( 0 0$1 ) ;
79323: LD_INT 35
79325: PPUSH
79326: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79330: LD_VAR 0 1
79334: PPUSH
79335: LD_EXP 47
79339: PUSH
79340: LD_VAR 0 4
79344: ARRAY
79345: PPUSH
79346: CALL_OW 308
79350: IFFALSE 79323
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79352: LD_VAR 0 1
79356: PPUSH
79357: CALL_OW 311
79361: PPUSH
79362: CALL_OW 121
// exit ;
79366: POP
79367: POP
79368: GO 79374
// end ; end ;
79370: GO 79022
79372: POP
79373: POP
// end ;
79374: LD_VAR 0 3
79378: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79379: LD_INT 0
79381: PPUSH
79382: PPUSH
79383: PPUSH
79384: PPUSH
// if not mc_bases or not skirmish then
79385: LD_EXP 23
79389: NOT
79390: PUSH
79391: LD_EXP 21
79395: NOT
79396: OR
79397: IFFALSE 79401
// exit ;
79399: GO 79754
// repeat wait ( 0 0$1 ) ;
79401: LD_INT 35
79403: PPUSH
79404: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79408: LD_VAR 0 2
79412: PPUSH
79413: LD_VAR 0 3
79417: PPUSH
79418: CALL_OW 284
79422: IFFALSE 79401
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79424: LD_VAR 0 2
79428: PPUSH
79429: LD_VAR 0 3
79433: PPUSH
79434: CALL_OW 283
79438: PUSH
79439: LD_INT 4
79441: EQUAL
79442: IFFALSE 79446
// exit ;
79444: GO 79754
// for i = 1 to mc_bases do
79446: LD_ADDR_VAR 0 7
79450: PUSH
79451: DOUBLE
79452: LD_INT 1
79454: DEC
79455: ST_TO_ADDR
79456: LD_EXP 23
79460: PUSH
79461: FOR_TO
79462: IFFALSE 79752
// begin if mc_crates_area [ i ] then
79464: LD_EXP 41
79468: PUSH
79469: LD_VAR 0 7
79473: ARRAY
79474: IFFALSE 79585
// for j in mc_crates_area [ i ] do
79476: LD_ADDR_VAR 0 8
79480: PUSH
79481: LD_EXP 41
79485: PUSH
79486: LD_VAR 0 7
79490: ARRAY
79491: PUSH
79492: FOR_IN
79493: IFFALSE 79583
// if InArea ( x , y , j ) then
79495: LD_VAR 0 2
79499: PPUSH
79500: LD_VAR 0 3
79504: PPUSH
79505: LD_VAR 0 8
79509: PPUSH
79510: CALL_OW 309
79514: IFFALSE 79581
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79516: LD_ADDR_EXP 39
79520: PUSH
79521: LD_EXP 39
79525: PPUSH
79526: LD_VAR 0 7
79530: PUSH
79531: LD_EXP 39
79535: PUSH
79536: LD_VAR 0 7
79540: ARRAY
79541: PUSH
79542: LD_INT 1
79544: PLUS
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PPUSH
79550: LD_VAR 0 4
79554: PUSH
79555: LD_VAR 0 2
79559: PUSH
79560: LD_VAR 0 3
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: LIST
79569: PPUSH
79570: CALL 16152 0 3
79574: ST_TO_ADDR
// exit ;
79575: POP
79576: POP
79577: POP
79578: POP
79579: GO 79754
// end ;
79581: GO 79492
79583: POP
79584: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79585: LD_ADDR_VAR 0 9
79589: PUSH
79590: LD_EXP 23
79594: PUSH
79595: LD_VAR 0 7
79599: ARRAY
79600: PPUSH
79601: LD_INT 2
79603: PUSH
79604: LD_INT 30
79606: PUSH
79607: LD_INT 0
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 30
79616: PUSH
79617: LD_INT 1
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: LIST
79628: PPUSH
79629: CALL_OW 72
79633: ST_TO_ADDR
// if not depot then
79634: LD_VAR 0 9
79638: NOT
79639: IFFALSE 79643
// continue ;
79641: GO 79461
// for j in depot do
79643: LD_ADDR_VAR 0 8
79647: PUSH
79648: LD_VAR 0 9
79652: PUSH
79653: FOR_IN
79654: IFFALSE 79748
// if GetDistUnitXY ( j , x , y ) < 30 then
79656: LD_VAR 0 8
79660: PPUSH
79661: LD_VAR 0 2
79665: PPUSH
79666: LD_VAR 0 3
79670: PPUSH
79671: CALL_OW 297
79675: PUSH
79676: LD_INT 30
79678: LESS
79679: IFFALSE 79746
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79681: LD_ADDR_EXP 39
79685: PUSH
79686: LD_EXP 39
79690: PPUSH
79691: LD_VAR 0 7
79695: PUSH
79696: LD_EXP 39
79700: PUSH
79701: LD_VAR 0 7
79705: ARRAY
79706: PUSH
79707: LD_INT 1
79709: PLUS
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PPUSH
79715: LD_VAR 0 4
79719: PUSH
79720: LD_VAR 0 2
79724: PUSH
79725: LD_VAR 0 3
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: LIST
79734: PPUSH
79735: CALL 16152 0 3
79739: ST_TO_ADDR
// exit ;
79740: POP
79741: POP
79742: POP
79743: POP
79744: GO 79754
// end ;
79746: GO 79653
79748: POP
79749: POP
// end ;
79750: GO 79461
79752: POP
79753: POP
// end ;
79754: LD_VAR 0 6
79758: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79759: LD_INT 0
79761: PPUSH
79762: PPUSH
79763: PPUSH
79764: PPUSH
// if not mc_bases or not skirmish then
79765: LD_EXP 23
79769: NOT
79770: PUSH
79771: LD_EXP 21
79775: NOT
79776: OR
79777: IFFALSE 79781
// exit ;
79779: GO 80058
// side := GetSide ( lab ) ;
79781: LD_ADDR_VAR 0 4
79785: PUSH
79786: LD_VAR 0 2
79790: PPUSH
79791: CALL_OW 255
79795: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79796: LD_VAR 0 4
79800: PUSH
79801: LD_EXP 49
79805: IN
79806: NOT
79807: PUSH
79808: LD_EXP 50
79812: NOT
79813: OR
79814: PUSH
79815: LD_EXP 23
79819: NOT
79820: OR
79821: IFFALSE 79825
// exit ;
79823: GO 80058
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79825: LD_ADDR_EXP 50
79829: PUSH
79830: LD_EXP 50
79834: PPUSH
79835: LD_VAR 0 4
79839: PPUSH
79840: LD_EXP 50
79844: PUSH
79845: LD_VAR 0 4
79849: ARRAY
79850: PUSH
79851: LD_VAR 0 1
79855: DIFF
79856: PPUSH
79857: CALL_OW 1
79861: ST_TO_ADDR
// for i = 1 to mc_bases do
79862: LD_ADDR_VAR 0 5
79866: PUSH
79867: DOUBLE
79868: LD_INT 1
79870: DEC
79871: ST_TO_ADDR
79872: LD_EXP 23
79876: PUSH
79877: FOR_TO
79878: IFFALSE 80056
// begin if lab in mc_bases [ i ] then
79880: LD_VAR 0 2
79884: PUSH
79885: LD_EXP 23
79889: PUSH
79890: LD_VAR 0 5
79894: ARRAY
79895: IN
79896: IFFALSE 80054
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79898: LD_VAR 0 1
79902: PUSH
79903: LD_INT 11
79905: PUSH
79906: LD_INT 4
79908: PUSH
79909: LD_INT 3
79911: PUSH
79912: LD_INT 2
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: IN
79921: PUSH
79922: LD_EXP 53
79926: PUSH
79927: LD_VAR 0 5
79931: ARRAY
79932: AND
79933: IFFALSE 80054
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79935: LD_ADDR_VAR 0 6
79939: PUSH
79940: LD_EXP 53
79944: PUSH
79945: LD_VAR 0 5
79949: ARRAY
79950: PUSH
79951: LD_INT 1
79953: ARRAY
79954: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79955: LD_ADDR_EXP 53
79959: PUSH
79960: LD_EXP 53
79964: PPUSH
79965: LD_VAR 0 5
79969: PPUSH
79970: EMPTY
79971: PPUSH
79972: CALL_OW 1
79976: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79977: LD_VAR 0 6
79981: PPUSH
79982: LD_INT 0
79984: PPUSH
79985: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79989: LD_VAR 0 6
79993: PPUSH
79994: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79998: LD_ADDR_EXP 52
80002: PUSH
80003: LD_EXP 52
80007: PPUSH
80008: LD_VAR 0 5
80012: PPUSH
80013: LD_EXP 52
80017: PUSH
80018: LD_VAR 0 5
80022: ARRAY
80023: PPUSH
80024: LD_INT 1
80026: PPUSH
80027: LD_VAR 0 6
80031: PPUSH
80032: CALL_OW 2
80036: PPUSH
80037: CALL_OW 1
80041: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80042: LD_VAR 0 5
80046: PPUSH
80047: LD_INT 112
80049: PPUSH
80050: CALL 56544 0 2
// end ; end ; end ;
80054: GO 79877
80056: POP
80057: POP
// end ;
80058: LD_VAR 0 3
80062: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80063: LD_INT 0
80065: PPUSH
80066: PPUSH
80067: PPUSH
80068: PPUSH
80069: PPUSH
80070: PPUSH
80071: PPUSH
80072: PPUSH
// if not mc_bases or not skirmish then
80073: LD_EXP 23
80077: NOT
80078: PUSH
80079: LD_EXP 21
80083: NOT
80084: OR
80085: IFFALSE 80089
// exit ;
80087: GO 81458
// for i = 1 to mc_bases do
80089: LD_ADDR_VAR 0 3
80093: PUSH
80094: DOUBLE
80095: LD_INT 1
80097: DEC
80098: ST_TO_ADDR
80099: LD_EXP 23
80103: PUSH
80104: FOR_TO
80105: IFFALSE 81456
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80107: LD_VAR 0 1
80111: PUSH
80112: LD_EXP 23
80116: PUSH
80117: LD_VAR 0 3
80121: ARRAY
80122: IN
80123: PUSH
80124: LD_VAR 0 1
80128: PUSH
80129: LD_EXP 30
80133: PUSH
80134: LD_VAR 0 3
80138: ARRAY
80139: IN
80140: OR
80141: PUSH
80142: LD_VAR 0 1
80146: PUSH
80147: LD_EXP 45
80151: PUSH
80152: LD_VAR 0 3
80156: ARRAY
80157: IN
80158: OR
80159: PUSH
80160: LD_VAR 0 1
80164: PUSH
80165: LD_EXP 42
80169: PUSH
80170: LD_VAR 0 3
80174: ARRAY
80175: IN
80176: OR
80177: PUSH
80178: LD_VAR 0 1
80182: PUSH
80183: LD_EXP 52
80187: PUSH
80188: LD_VAR 0 3
80192: ARRAY
80193: IN
80194: OR
80195: PUSH
80196: LD_VAR 0 1
80200: PUSH
80201: LD_EXP 53
80205: PUSH
80206: LD_VAR 0 3
80210: ARRAY
80211: IN
80212: OR
80213: IFFALSE 81454
// begin if un in mc_ape [ i ] then
80215: LD_VAR 0 1
80219: PUSH
80220: LD_EXP 52
80224: PUSH
80225: LD_VAR 0 3
80229: ARRAY
80230: IN
80231: IFFALSE 80270
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80233: LD_ADDR_EXP 52
80237: PUSH
80238: LD_EXP 52
80242: PPUSH
80243: LD_VAR 0 3
80247: PPUSH
80248: LD_EXP 52
80252: PUSH
80253: LD_VAR 0 3
80257: ARRAY
80258: PUSH
80259: LD_VAR 0 1
80263: DIFF
80264: PPUSH
80265: CALL_OW 1
80269: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80270: LD_VAR 0 1
80274: PUSH
80275: LD_EXP 53
80279: PUSH
80280: LD_VAR 0 3
80284: ARRAY
80285: IN
80286: IFFALSE 80310
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80288: LD_ADDR_EXP 53
80292: PUSH
80293: LD_EXP 53
80297: PPUSH
80298: LD_VAR 0 3
80302: PPUSH
80303: EMPTY
80304: PPUSH
80305: CALL_OW 1
80309: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80310: LD_VAR 0 1
80314: PPUSH
80315: CALL_OW 247
80319: PUSH
80320: LD_INT 2
80322: EQUAL
80323: PUSH
80324: LD_VAR 0 1
80328: PPUSH
80329: CALL_OW 110
80333: PUSH
80334: LD_INT 20
80336: EQUAL
80337: PUSH
80338: LD_VAR 0 1
80342: PUSH
80343: LD_EXP 45
80347: PUSH
80348: LD_VAR 0 3
80352: ARRAY
80353: IN
80354: OR
80355: PUSH
80356: LD_VAR 0 1
80360: PPUSH
80361: CALL_OW 264
80365: PUSH
80366: LD_INT 12
80368: PUSH
80369: LD_INT 51
80371: PUSH
80372: LD_INT 89
80374: PUSH
80375: LD_INT 32
80377: PUSH
80378: LD_INT 13
80380: PUSH
80381: LD_INT 52
80383: PUSH
80384: LD_INT 31
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: IN
80396: OR
80397: AND
80398: IFFALSE 80706
// begin if un in mc_defender [ i ] then
80400: LD_VAR 0 1
80404: PUSH
80405: LD_EXP 45
80409: PUSH
80410: LD_VAR 0 3
80414: ARRAY
80415: IN
80416: IFFALSE 80455
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80418: LD_ADDR_EXP 45
80422: PUSH
80423: LD_EXP 45
80427: PPUSH
80428: LD_VAR 0 3
80432: PPUSH
80433: LD_EXP 45
80437: PUSH
80438: LD_VAR 0 3
80442: ARRAY
80443: PUSH
80444: LD_VAR 0 1
80448: DIFF
80449: PPUSH
80450: CALL_OW 1
80454: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80455: LD_ADDR_VAR 0 8
80459: PUSH
80460: LD_VAR 0 3
80464: PPUSH
80465: LD_INT 3
80467: PPUSH
80468: CALL 77114 0 2
80472: ST_TO_ADDR
// if fac then
80473: LD_VAR 0 8
80477: IFFALSE 80706
// begin for j in fac do
80479: LD_ADDR_VAR 0 4
80483: PUSH
80484: LD_VAR 0 8
80488: PUSH
80489: FOR_IN
80490: IFFALSE 80704
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80492: LD_ADDR_VAR 0 9
80496: PUSH
80497: LD_VAR 0 8
80501: PPUSH
80502: LD_VAR 0 1
80506: PPUSH
80507: CALL_OW 265
80511: PPUSH
80512: LD_VAR 0 1
80516: PPUSH
80517: CALL_OW 262
80521: PPUSH
80522: LD_VAR 0 1
80526: PPUSH
80527: CALL_OW 263
80531: PPUSH
80532: LD_VAR 0 1
80536: PPUSH
80537: CALL_OW 264
80541: PPUSH
80542: CALL 13650 0 5
80546: ST_TO_ADDR
// if components then
80547: LD_VAR 0 9
80551: IFFALSE 80702
// begin if GetWeapon ( un ) = ar_control_tower then
80553: LD_VAR 0 1
80557: PPUSH
80558: CALL_OW 264
80562: PUSH
80563: LD_INT 31
80565: EQUAL
80566: IFFALSE 80683
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80568: LD_VAR 0 1
80572: PPUSH
80573: CALL_OW 311
80577: PPUSH
80578: LD_INT 0
80580: PPUSH
80581: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80585: LD_ADDR_EXP 63
80589: PUSH
80590: LD_EXP 63
80594: PPUSH
80595: LD_VAR 0 3
80599: PPUSH
80600: LD_EXP 63
80604: PUSH
80605: LD_VAR 0 3
80609: ARRAY
80610: PUSH
80611: LD_VAR 0 1
80615: PPUSH
80616: CALL_OW 311
80620: DIFF
80621: PPUSH
80622: CALL_OW 1
80626: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80627: LD_ADDR_VAR 0 7
80631: PUSH
80632: LD_EXP 44
80636: PUSH
80637: LD_VAR 0 3
80641: ARRAY
80642: PPUSH
80643: LD_INT 1
80645: PPUSH
80646: LD_VAR 0 9
80650: PPUSH
80651: CALL_OW 2
80655: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80656: LD_ADDR_EXP 44
80660: PUSH
80661: LD_EXP 44
80665: PPUSH
80666: LD_VAR 0 3
80670: PPUSH
80671: LD_VAR 0 7
80675: PPUSH
80676: CALL_OW 1
80680: ST_TO_ADDR
// end else
80681: GO 80700
// MC_InsertProduceList ( i , [ components ] ) ;
80683: LD_VAR 0 3
80687: PPUSH
80688: LD_VAR 0 9
80692: PUSH
80693: EMPTY
80694: LIST
80695: PPUSH
80696: CALL 76659 0 2
// break ;
80700: GO 80704
// end ; end ;
80702: GO 80489
80704: POP
80705: POP
// end ; end ; if GetType ( un ) = unit_building then
80706: LD_VAR 0 1
80710: PPUSH
80711: CALL_OW 247
80715: PUSH
80716: LD_INT 3
80718: EQUAL
80719: IFFALSE 81122
// begin btype := GetBType ( un ) ;
80721: LD_ADDR_VAR 0 5
80725: PUSH
80726: LD_VAR 0 1
80730: PPUSH
80731: CALL_OW 266
80735: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80736: LD_VAR 0 5
80740: PUSH
80741: LD_INT 29
80743: PUSH
80744: LD_INT 30
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: IN
80751: IFFALSE 80824
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80753: LD_VAR 0 1
80757: PPUSH
80758: CALL_OW 250
80762: PPUSH
80763: LD_VAR 0 1
80767: PPUSH
80768: CALL_OW 251
80772: PPUSH
80773: LD_VAR 0 1
80777: PPUSH
80778: CALL_OW 255
80782: PPUSH
80783: CALL_OW 440
80787: NOT
80788: IFFALSE 80824
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80790: LD_VAR 0 1
80794: PPUSH
80795: CALL_OW 250
80799: PPUSH
80800: LD_VAR 0 1
80804: PPUSH
80805: CALL_OW 251
80809: PPUSH
80810: LD_VAR 0 1
80814: PPUSH
80815: CALL_OW 255
80819: PPUSH
80820: CALL_OW 441
// end ; if btype = b_warehouse then
80824: LD_VAR 0 5
80828: PUSH
80829: LD_INT 1
80831: EQUAL
80832: IFFALSE 80850
// begin btype := b_depot ;
80834: LD_ADDR_VAR 0 5
80838: PUSH
80839: LD_INT 0
80841: ST_TO_ADDR
// pos := 1 ;
80842: LD_ADDR_VAR 0 6
80846: PUSH
80847: LD_INT 1
80849: ST_TO_ADDR
// end ; if btype = b_factory then
80850: LD_VAR 0 5
80854: PUSH
80855: LD_INT 3
80857: EQUAL
80858: IFFALSE 80876
// begin btype := b_workshop ;
80860: LD_ADDR_VAR 0 5
80864: PUSH
80865: LD_INT 2
80867: ST_TO_ADDR
// pos := 1 ;
80868: LD_ADDR_VAR 0 6
80872: PUSH
80873: LD_INT 1
80875: ST_TO_ADDR
// end ; if btype = b_barracks then
80876: LD_VAR 0 5
80880: PUSH
80881: LD_INT 5
80883: EQUAL
80884: IFFALSE 80894
// btype := b_armoury ;
80886: LD_ADDR_VAR 0 5
80890: PUSH
80891: LD_INT 4
80893: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80894: LD_VAR 0 5
80898: PUSH
80899: LD_INT 7
80901: PUSH
80902: LD_INT 8
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: IN
80909: IFFALSE 80919
// btype := b_lab ;
80911: LD_ADDR_VAR 0 5
80915: PUSH
80916: LD_INT 6
80918: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80919: LD_ADDR_EXP 28
80923: PUSH
80924: LD_EXP 28
80928: PPUSH
80929: LD_VAR 0 3
80933: PUSH
80934: LD_EXP 28
80938: PUSH
80939: LD_VAR 0 3
80943: ARRAY
80944: PUSH
80945: LD_INT 1
80947: PLUS
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PPUSH
80953: LD_VAR 0 5
80957: PUSH
80958: LD_VAR 0 1
80962: PPUSH
80963: CALL_OW 250
80967: PUSH
80968: LD_VAR 0 1
80972: PPUSH
80973: CALL_OW 251
80977: PUSH
80978: LD_VAR 0 1
80982: PPUSH
80983: CALL_OW 254
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: PPUSH
80994: CALL 16152 0 3
80998: ST_TO_ADDR
// if pos = 1 then
80999: LD_VAR 0 6
81003: PUSH
81004: LD_INT 1
81006: EQUAL
81007: IFFALSE 81122
// begin tmp := mc_build_list [ i ] ;
81009: LD_ADDR_VAR 0 7
81013: PUSH
81014: LD_EXP 28
81018: PUSH
81019: LD_VAR 0 3
81023: ARRAY
81024: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81025: LD_VAR 0 7
81029: PPUSH
81030: LD_INT 2
81032: PUSH
81033: LD_INT 30
81035: PUSH
81036: LD_INT 0
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 30
81045: PUSH
81046: LD_INT 1
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: LIST
81057: PPUSH
81058: CALL_OW 72
81062: IFFALSE 81072
// pos := 2 ;
81064: LD_ADDR_VAR 0 6
81068: PUSH
81069: LD_INT 2
81071: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81072: LD_ADDR_VAR 0 7
81076: PUSH
81077: LD_VAR 0 7
81081: PPUSH
81082: LD_VAR 0 6
81086: PPUSH
81087: LD_VAR 0 7
81091: PPUSH
81092: CALL 16478 0 3
81096: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81097: LD_ADDR_EXP 28
81101: PUSH
81102: LD_EXP 28
81106: PPUSH
81107: LD_VAR 0 3
81111: PPUSH
81112: LD_VAR 0 7
81116: PPUSH
81117: CALL_OW 1
81121: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81122: LD_VAR 0 1
81126: PUSH
81127: LD_EXP 23
81131: PUSH
81132: LD_VAR 0 3
81136: ARRAY
81137: IN
81138: IFFALSE 81177
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81140: LD_ADDR_EXP 23
81144: PUSH
81145: LD_EXP 23
81149: PPUSH
81150: LD_VAR 0 3
81154: PPUSH
81155: LD_EXP 23
81159: PUSH
81160: LD_VAR 0 3
81164: ARRAY
81165: PUSH
81166: LD_VAR 0 1
81170: DIFF
81171: PPUSH
81172: CALL_OW 1
81176: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81177: LD_VAR 0 1
81181: PUSH
81182: LD_EXP 30
81186: PUSH
81187: LD_VAR 0 3
81191: ARRAY
81192: IN
81193: IFFALSE 81232
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81195: LD_ADDR_EXP 30
81199: PUSH
81200: LD_EXP 30
81204: PPUSH
81205: LD_VAR 0 3
81209: PPUSH
81210: LD_EXP 30
81214: PUSH
81215: LD_VAR 0 3
81219: ARRAY
81220: PUSH
81221: LD_VAR 0 1
81225: DIFF
81226: PPUSH
81227: CALL_OW 1
81231: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81232: LD_VAR 0 1
81236: PUSH
81237: LD_EXP 42
81241: PUSH
81242: LD_VAR 0 3
81246: ARRAY
81247: IN
81248: IFFALSE 81287
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81250: LD_ADDR_EXP 42
81254: PUSH
81255: LD_EXP 42
81259: PPUSH
81260: LD_VAR 0 3
81264: PPUSH
81265: LD_EXP 42
81269: PUSH
81270: LD_VAR 0 3
81274: ARRAY
81275: PUSH
81276: LD_VAR 0 1
81280: DIFF
81281: PPUSH
81282: CALL_OW 1
81286: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81287: LD_VAR 0 1
81291: PUSH
81292: LD_EXP 45
81296: PUSH
81297: LD_VAR 0 3
81301: ARRAY
81302: IN
81303: IFFALSE 81342
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81305: LD_ADDR_EXP 45
81309: PUSH
81310: LD_EXP 45
81314: PPUSH
81315: LD_VAR 0 3
81319: PPUSH
81320: LD_EXP 45
81324: PUSH
81325: LD_VAR 0 3
81329: ARRAY
81330: PUSH
81331: LD_VAR 0 1
81335: DIFF
81336: PPUSH
81337: CALL_OW 1
81341: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81342: LD_VAR 0 1
81346: PUSH
81347: LD_EXP 32
81351: PUSH
81352: LD_VAR 0 3
81356: ARRAY
81357: IN
81358: IFFALSE 81397
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81360: LD_ADDR_EXP 32
81364: PUSH
81365: LD_EXP 32
81369: PPUSH
81370: LD_VAR 0 3
81374: PPUSH
81375: LD_EXP 32
81379: PUSH
81380: LD_VAR 0 3
81384: ARRAY
81385: PUSH
81386: LD_VAR 0 1
81390: DIFF
81391: PPUSH
81392: CALL_OW 1
81396: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81397: LD_VAR 0 1
81401: PUSH
81402: LD_EXP 31
81406: PUSH
81407: LD_VAR 0 3
81411: ARRAY
81412: IN
81413: IFFALSE 81452
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81415: LD_ADDR_EXP 31
81419: PUSH
81420: LD_EXP 31
81424: PPUSH
81425: LD_VAR 0 3
81429: PPUSH
81430: LD_EXP 31
81434: PUSH
81435: LD_VAR 0 3
81439: ARRAY
81440: PUSH
81441: LD_VAR 0 1
81445: DIFF
81446: PPUSH
81447: CALL_OW 1
81451: ST_TO_ADDR
// end ; break ;
81452: GO 81456
// end ;
81454: GO 80104
81456: POP
81457: POP
// end ;
81458: LD_VAR 0 2
81462: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81463: LD_INT 0
81465: PPUSH
81466: PPUSH
81467: PPUSH
// if not mc_bases or not skirmish then
81468: LD_EXP 23
81472: NOT
81473: PUSH
81474: LD_EXP 21
81478: NOT
81479: OR
81480: IFFALSE 81484
// exit ;
81482: GO 81699
// for i = 1 to mc_bases do
81484: LD_ADDR_VAR 0 3
81488: PUSH
81489: DOUBLE
81490: LD_INT 1
81492: DEC
81493: ST_TO_ADDR
81494: LD_EXP 23
81498: PUSH
81499: FOR_TO
81500: IFFALSE 81697
// begin if building in mc_construct_list [ i ] then
81502: LD_VAR 0 1
81506: PUSH
81507: LD_EXP 30
81511: PUSH
81512: LD_VAR 0 3
81516: ARRAY
81517: IN
81518: IFFALSE 81695
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81520: LD_ADDR_EXP 30
81524: PUSH
81525: LD_EXP 30
81529: PPUSH
81530: LD_VAR 0 3
81534: PPUSH
81535: LD_EXP 30
81539: PUSH
81540: LD_VAR 0 3
81544: ARRAY
81545: PUSH
81546: LD_VAR 0 1
81550: DIFF
81551: PPUSH
81552: CALL_OW 1
81556: ST_TO_ADDR
// if building in mc_lab [ i ] then
81557: LD_VAR 0 1
81561: PUSH
81562: LD_EXP 56
81566: PUSH
81567: LD_VAR 0 3
81571: ARRAY
81572: IN
81573: IFFALSE 81628
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81575: LD_ADDR_EXP 57
81579: PUSH
81580: LD_EXP 57
81584: PPUSH
81585: LD_VAR 0 3
81589: PPUSH
81590: LD_EXP 57
81594: PUSH
81595: LD_VAR 0 3
81599: ARRAY
81600: PPUSH
81601: LD_INT 1
81603: PPUSH
81604: LD_EXP 57
81608: PUSH
81609: LD_VAR 0 3
81613: ARRAY
81614: PPUSH
81615: LD_INT 0
81617: PPUSH
81618: CALL 15570 0 4
81622: PPUSH
81623: CALL_OW 1
81627: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81628: LD_VAR 0 1
81632: PUSH
81633: LD_EXP 23
81637: PUSH
81638: LD_VAR 0 3
81642: ARRAY
81643: IN
81644: NOT
81645: IFFALSE 81691
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81647: LD_ADDR_EXP 23
81651: PUSH
81652: LD_EXP 23
81656: PPUSH
81657: LD_VAR 0 3
81661: PUSH
81662: LD_EXP 23
81666: PUSH
81667: LD_VAR 0 3
81671: ARRAY
81672: PUSH
81673: LD_INT 1
81675: PLUS
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PPUSH
81681: LD_VAR 0 1
81685: PPUSH
81686: CALL 16152 0 3
81690: ST_TO_ADDR
// exit ;
81691: POP
81692: POP
81693: GO 81699
// end ; end ;
81695: GO 81499
81697: POP
81698: POP
// end ;
81699: LD_VAR 0 2
81703: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81704: LD_INT 0
81706: PPUSH
81707: PPUSH
81708: PPUSH
81709: PPUSH
81710: PPUSH
81711: PPUSH
81712: PPUSH
// if not mc_bases or not skirmish then
81713: LD_EXP 23
81717: NOT
81718: PUSH
81719: LD_EXP 21
81723: NOT
81724: OR
81725: IFFALSE 81729
// exit ;
81727: GO 82390
// for i = 1 to mc_bases do
81729: LD_ADDR_VAR 0 3
81733: PUSH
81734: DOUBLE
81735: LD_INT 1
81737: DEC
81738: ST_TO_ADDR
81739: LD_EXP 23
81743: PUSH
81744: FOR_TO
81745: IFFALSE 82388
// begin if building in mc_construct_list [ i ] then
81747: LD_VAR 0 1
81751: PUSH
81752: LD_EXP 30
81756: PUSH
81757: LD_VAR 0 3
81761: ARRAY
81762: IN
81763: IFFALSE 82386
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81765: LD_ADDR_EXP 30
81769: PUSH
81770: LD_EXP 30
81774: PPUSH
81775: LD_VAR 0 3
81779: PPUSH
81780: LD_EXP 30
81784: PUSH
81785: LD_VAR 0 3
81789: ARRAY
81790: PUSH
81791: LD_VAR 0 1
81795: DIFF
81796: PPUSH
81797: CALL_OW 1
81801: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81802: LD_ADDR_EXP 23
81806: PUSH
81807: LD_EXP 23
81811: PPUSH
81812: LD_VAR 0 3
81816: PUSH
81817: LD_EXP 23
81821: PUSH
81822: LD_VAR 0 3
81826: ARRAY
81827: PUSH
81828: LD_INT 1
81830: PLUS
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PPUSH
81836: LD_VAR 0 1
81840: PPUSH
81841: CALL 16152 0 3
81845: ST_TO_ADDR
// btype := GetBType ( building ) ;
81846: LD_ADDR_VAR 0 5
81850: PUSH
81851: LD_VAR 0 1
81855: PPUSH
81856: CALL_OW 266
81860: ST_TO_ADDR
// side := GetSide ( building ) ;
81861: LD_ADDR_VAR 0 8
81865: PUSH
81866: LD_VAR 0 1
81870: PPUSH
81871: CALL_OW 255
81875: ST_TO_ADDR
// if btype = b_lab then
81876: LD_VAR 0 5
81880: PUSH
81881: LD_INT 6
81883: EQUAL
81884: IFFALSE 81934
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81886: LD_ADDR_EXP 56
81890: PUSH
81891: LD_EXP 56
81895: PPUSH
81896: LD_VAR 0 3
81900: PUSH
81901: LD_EXP 56
81905: PUSH
81906: LD_VAR 0 3
81910: ARRAY
81911: PUSH
81912: LD_INT 1
81914: PLUS
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PPUSH
81920: LD_VAR 0 1
81924: PPUSH
81925: CALL 16152 0 3
81929: ST_TO_ADDR
// exit ;
81930: POP
81931: POP
81932: GO 82390
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81934: LD_VAR 0 5
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: LD_INT 4
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: LIST
81952: IN
81953: IFFALSE 82077
// begin if btype = b_armoury then
81955: LD_VAR 0 5
81959: PUSH
81960: LD_INT 4
81962: EQUAL
81963: IFFALSE 81973
// btype := b_barracks ;
81965: LD_ADDR_VAR 0 5
81969: PUSH
81970: LD_INT 5
81972: ST_TO_ADDR
// if btype = b_depot then
81973: LD_VAR 0 5
81977: PUSH
81978: LD_INT 0
81980: EQUAL
81981: IFFALSE 81991
// btype := b_warehouse ;
81983: LD_ADDR_VAR 0 5
81987: PUSH
81988: LD_INT 1
81990: ST_TO_ADDR
// if btype = b_workshop then
81991: LD_VAR 0 5
81995: PUSH
81996: LD_INT 2
81998: EQUAL
81999: IFFALSE 82009
// btype := b_factory ;
82001: LD_ADDR_VAR 0 5
82005: PUSH
82006: LD_INT 3
82008: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82009: LD_VAR 0 5
82013: PPUSH
82014: LD_VAR 0 8
82018: PPUSH
82019: CALL_OW 323
82023: PUSH
82024: LD_INT 1
82026: EQUAL
82027: IFFALSE 82073
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82029: LD_ADDR_EXP 55
82033: PUSH
82034: LD_EXP 55
82038: PPUSH
82039: LD_VAR 0 3
82043: PUSH
82044: LD_EXP 55
82048: PUSH
82049: LD_VAR 0 3
82053: ARRAY
82054: PUSH
82055: LD_INT 1
82057: PLUS
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PPUSH
82063: LD_VAR 0 1
82067: PPUSH
82068: CALL 16152 0 3
82072: ST_TO_ADDR
// exit ;
82073: POP
82074: POP
82075: GO 82390
// end ; if btype in [ b_bunker , b_turret ] then
82077: LD_VAR 0 5
82081: PUSH
82082: LD_INT 32
82084: PUSH
82085: LD_INT 33
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: IN
82092: IFFALSE 82382
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82094: LD_ADDR_EXP 31
82098: PUSH
82099: LD_EXP 31
82103: PPUSH
82104: LD_VAR 0 3
82108: PUSH
82109: LD_EXP 31
82113: PUSH
82114: LD_VAR 0 3
82118: ARRAY
82119: PUSH
82120: LD_INT 1
82122: PLUS
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PPUSH
82128: LD_VAR 0 1
82132: PPUSH
82133: CALL 16152 0 3
82137: ST_TO_ADDR
// if btype = b_bunker then
82138: LD_VAR 0 5
82142: PUSH
82143: LD_INT 32
82145: EQUAL
82146: IFFALSE 82382
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82148: LD_ADDR_EXP 32
82152: PUSH
82153: LD_EXP 32
82157: PPUSH
82158: LD_VAR 0 3
82162: PUSH
82163: LD_EXP 32
82167: PUSH
82168: LD_VAR 0 3
82172: ARRAY
82173: PUSH
82174: LD_INT 1
82176: PLUS
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PPUSH
82182: LD_VAR 0 1
82186: PPUSH
82187: CALL 16152 0 3
82191: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82192: LD_ADDR_VAR 0 6
82196: PUSH
82197: LD_EXP 23
82201: PUSH
82202: LD_VAR 0 3
82206: ARRAY
82207: PPUSH
82208: LD_INT 25
82210: PUSH
82211: LD_INT 1
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 3
82220: PUSH
82221: LD_INT 54
82223: PUSH
82224: EMPTY
82225: LIST
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PPUSH
82235: CALL_OW 72
82239: ST_TO_ADDR
// if tmp then
82240: LD_VAR 0 6
82244: IFFALSE 82250
// exit ;
82246: POP
82247: POP
82248: GO 82390
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82250: LD_ADDR_VAR 0 6
82254: PUSH
82255: LD_EXP 23
82259: PUSH
82260: LD_VAR 0 3
82264: ARRAY
82265: PPUSH
82266: LD_INT 2
82268: PUSH
82269: LD_INT 30
82271: PUSH
82272: LD_INT 4
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 30
82281: PUSH
82282: LD_INT 5
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: LIST
82293: PPUSH
82294: CALL_OW 72
82298: ST_TO_ADDR
// if not tmp then
82299: LD_VAR 0 6
82303: NOT
82304: IFFALSE 82310
// exit ;
82306: POP
82307: POP
82308: GO 82390
// for j in tmp do
82310: LD_ADDR_VAR 0 4
82314: PUSH
82315: LD_VAR 0 6
82319: PUSH
82320: FOR_IN
82321: IFFALSE 82380
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82323: LD_ADDR_VAR 0 7
82327: PUSH
82328: LD_VAR 0 4
82332: PPUSH
82333: CALL_OW 313
82337: PPUSH
82338: LD_INT 25
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PPUSH
82348: CALL_OW 72
82352: ST_TO_ADDR
// if units then
82353: LD_VAR 0 7
82357: IFFALSE 82378
// begin ComExitBuilding ( units [ 1 ] ) ;
82359: LD_VAR 0 7
82363: PUSH
82364: LD_INT 1
82366: ARRAY
82367: PPUSH
82368: CALL_OW 122
// exit ;
82372: POP
82373: POP
82374: POP
82375: POP
82376: GO 82390
// end ; end ;
82378: GO 82320
82380: POP
82381: POP
// end ; end ; exit ;
82382: POP
82383: POP
82384: GO 82390
// end ; end ;
82386: GO 81744
82388: POP
82389: POP
// end ;
82390: LD_VAR 0 2
82394: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82395: LD_INT 0
82397: PPUSH
82398: PPUSH
82399: PPUSH
82400: PPUSH
82401: PPUSH
82402: PPUSH
82403: PPUSH
// if not mc_bases or not skirmish then
82404: LD_EXP 23
82408: NOT
82409: PUSH
82410: LD_EXP 21
82414: NOT
82415: OR
82416: IFFALSE 82420
// exit ;
82418: GO 82685
// btype := GetBType ( building ) ;
82420: LD_ADDR_VAR 0 6
82424: PUSH
82425: LD_VAR 0 1
82429: PPUSH
82430: CALL_OW 266
82434: ST_TO_ADDR
// x := GetX ( building ) ;
82435: LD_ADDR_VAR 0 7
82439: PUSH
82440: LD_VAR 0 1
82444: PPUSH
82445: CALL_OW 250
82449: ST_TO_ADDR
// y := GetY ( building ) ;
82450: LD_ADDR_VAR 0 8
82454: PUSH
82455: LD_VAR 0 1
82459: PPUSH
82460: CALL_OW 251
82464: ST_TO_ADDR
// d := GetDir ( building ) ;
82465: LD_ADDR_VAR 0 9
82469: PUSH
82470: LD_VAR 0 1
82474: PPUSH
82475: CALL_OW 254
82479: ST_TO_ADDR
// for i = 1 to mc_bases do
82480: LD_ADDR_VAR 0 4
82484: PUSH
82485: DOUBLE
82486: LD_INT 1
82488: DEC
82489: ST_TO_ADDR
82490: LD_EXP 23
82494: PUSH
82495: FOR_TO
82496: IFFALSE 82683
// begin if not mc_build_list [ i ] then
82498: LD_EXP 28
82502: PUSH
82503: LD_VAR 0 4
82507: ARRAY
82508: NOT
82509: IFFALSE 82513
// continue ;
82511: GO 82495
// for j := 1 to mc_build_list [ i ] do
82513: LD_ADDR_VAR 0 5
82517: PUSH
82518: DOUBLE
82519: LD_INT 1
82521: DEC
82522: ST_TO_ADDR
82523: LD_EXP 28
82527: PUSH
82528: LD_VAR 0 4
82532: ARRAY
82533: PUSH
82534: FOR_TO
82535: IFFALSE 82679
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82537: LD_VAR 0 6
82541: PUSH
82542: LD_VAR 0 7
82546: PUSH
82547: LD_VAR 0 8
82551: PUSH
82552: LD_VAR 0 9
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: PPUSH
82563: LD_EXP 28
82567: PUSH
82568: LD_VAR 0 4
82572: ARRAY
82573: PUSH
82574: LD_VAR 0 5
82578: ARRAY
82579: PPUSH
82580: CALL 22332 0 2
82584: IFFALSE 82677
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82586: LD_ADDR_EXP 28
82590: PUSH
82591: LD_EXP 28
82595: PPUSH
82596: LD_VAR 0 4
82600: PPUSH
82601: LD_EXP 28
82605: PUSH
82606: LD_VAR 0 4
82610: ARRAY
82611: PPUSH
82612: LD_VAR 0 5
82616: PPUSH
82617: CALL_OW 3
82621: PPUSH
82622: CALL_OW 1
82626: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82627: LD_ADDR_EXP 30
82631: PUSH
82632: LD_EXP 30
82636: PPUSH
82637: LD_VAR 0 4
82641: PUSH
82642: LD_EXP 30
82646: PUSH
82647: LD_VAR 0 4
82651: ARRAY
82652: PUSH
82653: LD_INT 1
82655: PLUS
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PPUSH
82661: LD_VAR 0 1
82665: PPUSH
82666: CALL 16152 0 3
82670: ST_TO_ADDR
// exit ;
82671: POP
82672: POP
82673: POP
82674: POP
82675: GO 82685
// end ;
82677: GO 82534
82679: POP
82680: POP
// end ;
82681: GO 82495
82683: POP
82684: POP
// end ;
82685: LD_VAR 0 3
82689: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82690: LD_INT 0
82692: PPUSH
82693: PPUSH
82694: PPUSH
// if not mc_bases or not skirmish then
82695: LD_EXP 23
82699: NOT
82700: PUSH
82701: LD_EXP 21
82705: NOT
82706: OR
82707: IFFALSE 82711
// exit ;
82709: GO 82901
// for i = 1 to mc_bases do
82711: LD_ADDR_VAR 0 4
82715: PUSH
82716: DOUBLE
82717: LD_INT 1
82719: DEC
82720: ST_TO_ADDR
82721: LD_EXP 23
82725: PUSH
82726: FOR_TO
82727: IFFALSE 82814
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82729: LD_VAR 0 1
82733: PUSH
82734: LD_EXP 31
82738: PUSH
82739: LD_VAR 0 4
82743: ARRAY
82744: IN
82745: PUSH
82746: LD_VAR 0 1
82750: PUSH
82751: LD_EXP 32
82755: PUSH
82756: LD_VAR 0 4
82760: ARRAY
82761: IN
82762: NOT
82763: AND
82764: IFFALSE 82812
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82766: LD_ADDR_EXP 32
82770: PUSH
82771: LD_EXP 32
82775: PPUSH
82776: LD_VAR 0 4
82780: PUSH
82781: LD_EXP 32
82785: PUSH
82786: LD_VAR 0 4
82790: ARRAY
82791: PUSH
82792: LD_INT 1
82794: PLUS
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PPUSH
82800: LD_VAR 0 1
82804: PPUSH
82805: CALL 16152 0 3
82809: ST_TO_ADDR
// break ;
82810: GO 82814
// end ; end ;
82812: GO 82726
82814: POP
82815: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82816: LD_VAR 0 1
82820: PPUSH
82821: CALL_OW 257
82825: PUSH
82826: LD_EXP 49
82830: IN
82831: PUSH
82832: LD_VAR 0 1
82836: PPUSH
82837: CALL_OW 266
82841: PUSH
82842: LD_INT 5
82844: EQUAL
82845: AND
82846: PUSH
82847: LD_VAR 0 2
82851: PPUSH
82852: CALL_OW 110
82856: PUSH
82857: LD_INT 18
82859: NONEQUAL
82860: AND
82861: IFFALSE 82901
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82863: LD_VAR 0 2
82867: PPUSH
82868: CALL_OW 257
82872: PUSH
82873: LD_INT 5
82875: PUSH
82876: LD_INT 8
82878: PUSH
82879: LD_INT 9
82881: PUSH
82882: EMPTY
82883: LIST
82884: LIST
82885: LIST
82886: IN
82887: IFFALSE 82901
// SetClass ( unit , 1 ) ;
82889: LD_VAR 0 2
82893: PPUSH
82894: LD_INT 1
82896: PPUSH
82897: CALL_OW 336
// end ;
82901: LD_VAR 0 3
82905: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82906: LD_INT 0
82908: PPUSH
82909: PPUSH
// if not mc_bases or not skirmish then
82910: LD_EXP 23
82914: NOT
82915: PUSH
82916: LD_EXP 21
82920: NOT
82921: OR
82922: IFFALSE 82926
// exit ;
82924: GO 83042
// if GetLives ( abandoned_vehicle ) > 250 then
82926: LD_VAR 0 2
82930: PPUSH
82931: CALL_OW 256
82935: PUSH
82936: LD_INT 250
82938: GREATER
82939: IFFALSE 82943
// exit ;
82941: GO 83042
// for i = 1 to mc_bases do
82943: LD_ADDR_VAR 0 6
82947: PUSH
82948: DOUBLE
82949: LD_INT 1
82951: DEC
82952: ST_TO_ADDR
82953: LD_EXP 23
82957: PUSH
82958: FOR_TO
82959: IFFALSE 83040
// begin if driver in mc_bases [ i ] then
82961: LD_VAR 0 1
82965: PUSH
82966: LD_EXP 23
82970: PUSH
82971: LD_VAR 0 6
82975: ARRAY
82976: IN
82977: IFFALSE 83038
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82979: LD_VAR 0 1
82983: PPUSH
82984: LD_EXP 23
82988: PUSH
82989: LD_VAR 0 6
82993: ARRAY
82994: PPUSH
82995: LD_INT 2
82997: PUSH
82998: LD_INT 30
83000: PUSH
83001: LD_INT 0
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: LD_INT 30
83010: PUSH
83011: LD_INT 1
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: LIST
83022: PPUSH
83023: CALL_OW 72
83027: PUSH
83028: LD_INT 1
83030: ARRAY
83031: PPUSH
83032: CALL 49341 0 2
// break ;
83036: GO 83040
// end ; end ;
83038: GO 82958
83040: POP
83041: POP
// end ; end_of_file
83042: LD_VAR 0 5
83046: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83047: LD_INT 0
83049: PPUSH
83050: PPUSH
83051: PPUSH
83052: PPUSH
83053: PPUSH
83054: PPUSH
83055: PPUSH
83056: PPUSH
83057: PPUSH
83058: PPUSH
83059: PPUSH
83060: PPUSH
83061: PPUSH
83062: PPUSH
83063: PPUSH
83064: PPUSH
83065: PPUSH
83066: PPUSH
83067: PPUSH
83068: PPUSH
83069: PPUSH
83070: PPUSH
83071: PPUSH
83072: PPUSH
83073: PPUSH
83074: PPUSH
83075: PPUSH
83076: PPUSH
83077: PPUSH
83078: PPUSH
83079: PPUSH
83080: PPUSH
83081: PPUSH
83082: PPUSH
// if not list then
83083: LD_VAR 0 1
83087: NOT
83088: IFFALSE 83092
// exit ;
83090: GO 87751
// base := list [ 1 ] ;
83092: LD_ADDR_VAR 0 3
83096: PUSH
83097: LD_VAR 0 1
83101: PUSH
83102: LD_INT 1
83104: ARRAY
83105: ST_TO_ADDR
// group := list [ 2 ] ;
83106: LD_ADDR_VAR 0 4
83110: PUSH
83111: LD_VAR 0 1
83115: PUSH
83116: LD_INT 2
83118: ARRAY
83119: ST_TO_ADDR
// path := list [ 3 ] ;
83120: LD_ADDR_VAR 0 5
83124: PUSH
83125: LD_VAR 0 1
83129: PUSH
83130: LD_INT 3
83132: ARRAY
83133: ST_TO_ADDR
// flags := list [ 4 ] ;
83134: LD_ADDR_VAR 0 6
83138: PUSH
83139: LD_VAR 0 1
83143: PUSH
83144: LD_INT 4
83146: ARRAY
83147: ST_TO_ADDR
// mined := [ ] ;
83148: LD_ADDR_VAR 0 27
83152: PUSH
83153: EMPTY
83154: ST_TO_ADDR
// bombed := [ ] ;
83155: LD_ADDR_VAR 0 28
83159: PUSH
83160: EMPTY
83161: ST_TO_ADDR
// healers := [ ] ;
83162: LD_ADDR_VAR 0 31
83166: PUSH
83167: EMPTY
83168: ST_TO_ADDR
// to_heal := [ ] ;
83169: LD_ADDR_VAR 0 30
83173: PUSH
83174: EMPTY
83175: ST_TO_ADDR
// repairs := [ ] ;
83176: LD_ADDR_VAR 0 33
83180: PUSH
83181: EMPTY
83182: ST_TO_ADDR
// to_repair := [ ] ;
83183: LD_ADDR_VAR 0 32
83187: PUSH
83188: EMPTY
83189: ST_TO_ADDR
// if not group or not path then
83190: LD_VAR 0 4
83194: NOT
83195: PUSH
83196: LD_VAR 0 5
83200: NOT
83201: OR
83202: IFFALSE 83206
// exit ;
83204: GO 87751
// side := GetSide ( group [ 1 ] ) ;
83206: LD_ADDR_VAR 0 35
83210: PUSH
83211: LD_VAR 0 4
83215: PUSH
83216: LD_INT 1
83218: ARRAY
83219: PPUSH
83220: CALL_OW 255
83224: ST_TO_ADDR
// if flags then
83225: LD_VAR 0 6
83229: IFFALSE 83373
// begin f_ignore_area := flags [ 1 ] ;
83231: LD_ADDR_VAR 0 17
83235: PUSH
83236: LD_VAR 0 6
83240: PUSH
83241: LD_INT 1
83243: ARRAY
83244: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83245: LD_ADDR_VAR 0 18
83249: PUSH
83250: LD_VAR 0 6
83254: PUSH
83255: LD_INT 2
83257: ARRAY
83258: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83259: LD_ADDR_VAR 0 19
83263: PUSH
83264: LD_VAR 0 6
83268: PUSH
83269: LD_INT 3
83271: ARRAY
83272: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83273: LD_ADDR_VAR 0 20
83277: PUSH
83278: LD_VAR 0 6
83282: PUSH
83283: LD_INT 4
83285: ARRAY
83286: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83287: LD_ADDR_VAR 0 21
83291: PUSH
83292: LD_VAR 0 6
83296: PUSH
83297: LD_INT 5
83299: ARRAY
83300: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83301: LD_ADDR_VAR 0 22
83305: PUSH
83306: LD_VAR 0 6
83310: PUSH
83311: LD_INT 6
83313: ARRAY
83314: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83315: LD_ADDR_VAR 0 23
83319: PUSH
83320: LD_VAR 0 6
83324: PUSH
83325: LD_INT 7
83327: ARRAY
83328: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83329: LD_ADDR_VAR 0 24
83333: PUSH
83334: LD_VAR 0 6
83338: PUSH
83339: LD_INT 8
83341: ARRAY
83342: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83343: LD_ADDR_VAR 0 25
83347: PUSH
83348: LD_VAR 0 6
83352: PUSH
83353: LD_INT 9
83355: ARRAY
83356: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83357: LD_ADDR_VAR 0 26
83361: PUSH
83362: LD_VAR 0 6
83366: PUSH
83367: LD_INT 10
83369: ARRAY
83370: ST_TO_ADDR
// end else
83371: GO 83453
// begin f_ignore_area := false ;
83373: LD_ADDR_VAR 0 17
83377: PUSH
83378: LD_INT 0
83380: ST_TO_ADDR
// f_capture := false ;
83381: LD_ADDR_VAR 0 18
83385: PUSH
83386: LD_INT 0
83388: ST_TO_ADDR
// f_ignore_civ := false ;
83389: LD_ADDR_VAR 0 19
83393: PUSH
83394: LD_INT 0
83396: ST_TO_ADDR
// f_murder := false ;
83397: LD_ADDR_VAR 0 20
83401: PUSH
83402: LD_INT 0
83404: ST_TO_ADDR
// f_mines := false ;
83405: LD_ADDR_VAR 0 21
83409: PUSH
83410: LD_INT 0
83412: ST_TO_ADDR
// f_repair := false ;
83413: LD_ADDR_VAR 0 22
83417: PUSH
83418: LD_INT 0
83420: ST_TO_ADDR
// f_heal := false ;
83421: LD_ADDR_VAR 0 23
83425: PUSH
83426: LD_INT 0
83428: ST_TO_ADDR
// f_spacetime := false ;
83429: LD_ADDR_VAR 0 24
83433: PUSH
83434: LD_INT 0
83436: ST_TO_ADDR
// f_attack_depot := false ;
83437: LD_ADDR_VAR 0 25
83441: PUSH
83442: LD_INT 0
83444: ST_TO_ADDR
// f_crawl := false ;
83445: LD_ADDR_VAR 0 26
83449: PUSH
83450: LD_INT 0
83452: ST_TO_ADDR
// end ; if f_heal then
83453: LD_VAR 0 23
83457: IFFALSE 83484
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83459: LD_ADDR_VAR 0 31
83463: PUSH
83464: LD_VAR 0 4
83468: PPUSH
83469: LD_INT 25
83471: PUSH
83472: LD_INT 4
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PPUSH
83479: CALL_OW 72
83483: ST_TO_ADDR
// if f_repair then
83484: LD_VAR 0 22
83488: IFFALSE 83515
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83490: LD_ADDR_VAR 0 33
83494: PUSH
83495: LD_VAR 0 4
83499: PPUSH
83500: LD_INT 25
83502: PUSH
83503: LD_INT 3
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PPUSH
83510: CALL_OW 72
83514: ST_TO_ADDR
// units_path := [ ] ;
83515: LD_ADDR_VAR 0 16
83519: PUSH
83520: EMPTY
83521: ST_TO_ADDR
// for i = 1 to group do
83522: LD_ADDR_VAR 0 7
83526: PUSH
83527: DOUBLE
83528: LD_INT 1
83530: DEC
83531: ST_TO_ADDR
83532: LD_VAR 0 4
83536: PUSH
83537: FOR_TO
83538: IFFALSE 83567
// units_path := Replace ( units_path , i , path ) ;
83540: LD_ADDR_VAR 0 16
83544: PUSH
83545: LD_VAR 0 16
83549: PPUSH
83550: LD_VAR 0 7
83554: PPUSH
83555: LD_VAR 0 5
83559: PPUSH
83560: CALL_OW 1
83564: ST_TO_ADDR
83565: GO 83537
83567: POP
83568: POP
// repeat for i = group downto 1 do
83569: LD_ADDR_VAR 0 7
83573: PUSH
83574: DOUBLE
83575: LD_VAR 0 4
83579: INC
83580: ST_TO_ADDR
83581: LD_INT 1
83583: PUSH
83584: FOR_DOWNTO
83585: IFFALSE 87707
// begin wait ( 5 ) ;
83587: LD_INT 5
83589: PPUSH
83590: CALL_OW 67
// tmp := [ ] ;
83594: LD_ADDR_VAR 0 14
83598: PUSH
83599: EMPTY
83600: ST_TO_ADDR
// attacking := false ;
83601: LD_ADDR_VAR 0 29
83605: PUSH
83606: LD_INT 0
83608: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83609: LD_VAR 0 4
83613: PUSH
83614: LD_VAR 0 7
83618: ARRAY
83619: PPUSH
83620: CALL_OW 301
83624: PUSH
83625: LD_VAR 0 4
83629: PUSH
83630: LD_VAR 0 7
83634: ARRAY
83635: NOT
83636: OR
83637: IFFALSE 83746
// begin if GetType ( group [ i ] ) = unit_human then
83639: LD_VAR 0 4
83643: PUSH
83644: LD_VAR 0 7
83648: ARRAY
83649: PPUSH
83650: CALL_OW 247
83654: PUSH
83655: LD_INT 1
83657: EQUAL
83658: IFFALSE 83704
// begin to_heal := to_heal diff group [ i ] ;
83660: LD_ADDR_VAR 0 30
83664: PUSH
83665: LD_VAR 0 30
83669: PUSH
83670: LD_VAR 0 4
83674: PUSH
83675: LD_VAR 0 7
83679: ARRAY
83680: DIFF
83681: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83682: LD_ADDR_VAR 0 31
83686: PUSH
83687: LD_VAR 0 31
83691: PUSH
83692: LD_VAR 0 4
83696: PUSH
83697: LD_VAR 0 7
83701: ARRAY
83702: DIFF
83703: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83704: LD_ADDR_VAR 0 4
83708: PUSH
83709: LD_VAR 0 4
83713: PPUSH
83714: LD_VAR 0 7
83718: PPUSH
83719: CALL_OW 3
83723: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83724: LD_ADDR_VAR 0 16
83728: PUSH
83729: LD_VAR 0 16
83733: PPUSH
83734: LD_VAR 0 7
83738: PPUSH
83739: CALL_OW 3
83743: ST_TO_ADDR
// continue ;
83744: GO 83584
// end ; if f_repair then
83746: LD_VAR 0 22
83750: IFFALSE 84239
// begin if GetType ( group [ i ] ) = unit_vehicle then
83752: LD_VAR 0 4
83756: PUSH
83757: LD_VAR 0 7
83761: ARRAY
83762: PPUSH
83763: CALL_OW 247
83767: PUSH
83768: LD_INT 2
83770: EQUAL
83771: IFFALSE 83961
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83773: LD_VAR 0 4
83777: PUSH
83778: LD_VAR 0 7
83782: ARRAY
83783: PPUSH
83784: CALL_OW 256
83788: PUSH
83789: LD_INT 700
83791: LESS
83792: PUSH
83793: LD_VAR 0 4
83797: PUSH
83798: LD_VAR 0 7
83802: ARRAY
83803: PUSH
83804: LD_VAR 0 32
83808: IN
83809: NOT
83810: AND
83811: IFFALSE 83835
// to_repair := to_repair union group [ i ] ;
83813: LD_ADDR_VAR 0 32
83817: PUSH
83818: LD_VAR 0 32
83822: PUSH
83823: LD_VAR 0 4
83827: PUSH
83828: LD_VAR 0 7
83832: ARRAY
83833: UNION
83834: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83835: LD_VAR 0 4
83839: PUSH
83840: LD_VAR 0 7
83844: ARRAY
83845: PPUSH
83846: CALL_OW 256
83850: PUSH
83851: LD_INT 1000
83853: EQUAL
83854: PUSH
83855: LD_VAR 0 4
83859: PUSH
83860: LD_VAR 0 7
83864: ARRAY
83865: PUSH
83866: LD_VAR 0 32
83870: IN
83871: AND
83872: IFFALSE 83896
// to_repair := to_repair diff group [ i ] ;
83874: LD_ADDR_VAR 0 32
83878: PUSH
83879: LD_VAR 0 32
83883: PUSH
83884: LD_VAR 0 4
83888: PUSH
83889: LD_VAR 0 7
83893: ARRAY
83894: DIFF
83895: ST_TO_ADDR
// if group [ i ] in to_repair then
83896: LD_VAR 0 4
83900: PUSH
83901: LD_VAR 0 7
83905: ARRAY
83906: PUSH
83907: LD_VAR 0 32
83911: IN
83912: IFFALSE 83959
// begin if not IsInArea ( group [ i ] , f_repair ) then
83914: LD_VAR 0 4
83918: PUSH
83919: LD_VAR 0 7
83923: ARRAY
83924: PPUSH
83925: LD_VAR 0 22
83929: PPUSH
83930: CALL_OW 308
83934: NOT
83935: IFFALSE 83957
// ComMoveToArea ( group [ i ] , f_repair ) ;
83937: LD_VAR 0 4
83941: PUSH
83942: LD_VAR 0 7
83946: ARRAY
83947: PPUSH
83948: LD_VAR 0 22
83952: PPUSH
83953: CALL_OW 113
// continue ;
83957: GO 83584
// end ; end else
83959: GO 84239
// if group [ i ] in repairs then
83961: LD_VAR 0 4
83965: PUSH
83966: LD_VAR 0 7
83970: ARRAY
83971: PUSH
83972: LD_VAR 0 33
83976: IN
83977: IFFALSE 84239
// begin if IsInUnit ( group [ i ] ) then
83979: LD_VAR 0 4
83983: PUSH
83984: LD_VAR 0 7
83988: ARRAY
83989: PPUSH
83990: CALL_OW 310
83994: IFFALSE 84062
// begin z := IsInUnit ( group [ i ] ) ;
83996: LD_ADDR_VAR 0 13
84000: PUSH
84001: LD_VAR 0 4
84005: PUSH
84006: LD_VAR 0 7
84010: ARRAY
84011: PPUSH
84012: CALL_OW 310
84016: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84017: LD_VAR 0 13
84021: PUSH
84022: LD_VAR 0 32
84026: IN
84027: PUSH
84028: LD_VAR 0 13
84032: PPUSH
84033: LD_VAR 0 22
84037: PPUSH
84038: CALL_OW 308
84042: AND
84043: IFFALSE 84060
// ComExitVehicle ( group [ i ] ) ;
84045: LD_VAR 0 4
84049: PUSH
84050: LD_VAR 0 7
84054: ARRAY
84055: PPUSH
84056: CALL_OW 121
// end else
84060: GO 84239
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84062: LD_ADDR_VAR 0 13
84066: PUSH
84067: LD_VAR 0 4
84071: PPUSH
84072: LD_INT 95
84074: PUSH
84075: LD_VAR 0 22
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 58
84086: PUSH
84087: EMPTY
84088: LIST
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PPUSH
84094: CALL_OW 72
84098: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84099: LD_VAR 0 4
84103: PUSH
84104: LD_VAR 0 7
84108: ARRAY
84109: PPUSH
84110: CALL_OW 314
84114: NOT
84115: IFFALSE 84237
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84117: LD_ADDR_VAR 0 10
84121: PUSH
84122: LD_VAR 0 13
84126: PPUSH
84127: LD_VAR 0 4
84131: PUSH
84132: LD_VAR 0 7
84136: ARRAY
84137: PPUSH
84138: CALL_OW 74
84142: ST_TO_ADDR
// if not x then
84143: LD_VAR 0 10
84147: NOT
84148: IFFALSE 84152
// continue ;
84150: GO 83584
// if GetLives ( x ) < 1000 then
84152: LD_VAR 0 10
84156: PPUSH
84157: CALL_OW 256
84161: PUSH
84162: LD_INT 1000
84164: LESS
84165: IFFALSE 84189
// ComRepairVehicle ( group [ i ] , x ) else
84167: LD_VAR 0 4
84171: PUSH
84172: LD_VAR 0 7
84176: ARRAY
84177: PPUSH
84178: LD_VAR 0 10
84182: PPUSH
84183: CALL_OW 129
84187: GO 84237
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84189: LD_VAR 0 23
84193: PUSH
84194: LD_VAR 0 4
84198: PUSH
84199: LD_VAR 0 7
84203: ARRAY
84204: PPUSH
84205: CALL_OW 256
84209: PUSH
84210: LD_INT 1000
84212: LESS
84213: AND
84214: NOT
84215: IFFALSE 84237
// ComEnterUnit ( group [ i ] , x ) ;
84217: LD_VAR 0 4
84221: PUSH
84222: LD_VAR 0 7
84226: ARRAY
84227: PPUSH
84228: LD_VAR 0 10
84232: PPUSH
84233: CALL_OW 120
// end ; continue ;
84237: GO 83584
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84239: LD_VAR 0 23
84243: PUSH
84244: LD_VAR 0 4
84248: PUSH
84249: LD_VAR 0 7
84253: ARRAY
84254: PPUSH
84255: CALL_OW 247
84259: PUSH
84260: LD_INT 1
84262: EQUAL
84263: AND
84264: IFFALSE 84742
// begin if group [ i ] in healers then
84266: LD_VAR 0 4
84270: PUSH
84271: LD_VAR 0 7
84275: ARRAY
84276: PUSH
84277: LD_VAR 0 31
84281: IN
84282: IFFALSE 84555
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84284: LD_VAR 0 4
84288: PUSH
84289: LD_VAR 0 7
84293: ARRAY
84294: PPUSH
84295: LD_VAR 0 23
84299: PPUSH
84300: CALL_OW 308
84304: NOT
84305: PUSH
84306: LD_VAR 0 4
84310: PUSH
84311: LD_VAR 0 7
84315: ARRAY
84316: PPUSH
84317: CALL_OW 314
84321: NOT
84322: AND
84323: IFFALSE 84347
// ComMoveToArea ( group [ i ] , f_heal ) else
84325: LD_VAR 0 4
84329: PUSH
84330: LD_VAR 0 7
84334: ARRAY
84335: PPUSH
84336: LD_VAR 0 23
84340: PPUSH
84341: CALL_OW 113
84345: GO 84553
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84347: LD_VAR 0 4
84351: PUSH
84352: LD_VAR 0 7
84356: ARRAY
84357: PPUSH
84358: CALL 45849 0 1
84362: PPUSH
84363: CALL_OW 256
84367: PUSH
84368: LD_INT 1000
84370: EQUAL
84371: IFFALSE 84390
// ComStop ( group [ i ] ) else
84373: LD_VAR 0 4
84377: PUSH
84378: LD_VAR 0 7
84382: ARRAY
84383: PPUSH
84384: CALL_OW 141
84388: GO 84553
// if not HasTask ( group [ i ] ) and to_heal then
84390: LD_VAR 0 4
84394: PUSH
84395: LD_VAR 0 7
84399: ARRAY
84400: PPUSH
84401: CALL_OW 314
84405: NOT
84406: PUSH
84407: LD_VAR 0 30
84411: AND
84412: IFFALSE 84553
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84414: LD_ADDR_VAR 0 13
84418: PUSH
84419: LD_VAR 0 30
84423: PPUSH
84424: LD_INT 3
84426: PUSH
84427: LD_INT 54
84429: PUSH
84430: EMPTY
84431: LIST
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PPUSH
84437: CALL_OW 72
84441: PPUSH
84442: LD_VAR 0 4
84446: PUSH
84447: LD_VAR 0 7
84451: ARRAY
84452: PPUSH
84453: CALL_OW 74
84457: ST_TO_ADDR
// if z then
84458: LD_VAR 0 13
84462: IFFALSE 84553
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84464: LD_INT 91
84466: PUSH
84467: LD_VAR 0 13
84471: PUSH
84472: LD_INT 10
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 81
84482: PUSH
84483: LD_VAR 0 13
84487: PPUSH
84488: CALL_OW 255
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PPUSH
84501: CALL_OW 69
84505: PUSH
84506: LD_INT 0
84508: EQUAL
84509: IFFALSE 84533
// ComHeal ( group [ i ] , z ) else
84511: LD_VAR 0 4
84515: PUSH
84516: LD_VAR 0 7
84520: ARRAY
84521: PPUSH
84522: LD_VAR 0 13
84526: PPUSH
84527: CALL_OW 128
84531: GO 84553
// ComMoveToArea ( group [ i ] , f_heal ) ;
84533: LD_VAR 0 4
84537: PUSH
84538: LD_VAR 0 7
84542: ARRAY
84543: PPUSH
84544: LD_VAR 0 23
84548: PPUSH
84549: CALL_OW 113
// end ; continue ;
84553: GO 83584
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84555: LD_VAR 0 4
84559: PUSH
84560: LD_VAR 0 7
84564: ARRAY
84565: PPUSH
84566: CALL_OW 256
84570: PUSH
84571: LD_INT 700
84573: LESS
84574: PUSH
84575: LD_VAR 0 4
84579: PUSH
84580: LD_VAR 0 7
84584: ARRAY
84585: PUSH
84586: LD_VAR 0 30
84590: IN
84591: NOT
84592: AND
84593: IFFALSE 84617
// to_heal := to_heal union group [ i ] ;
84595: LD_ADDR_VAR 0 30
84599: PUSH
84600: LD_VAR 0 30
84604: PUSH
84605: LD_VAR 0 4
84609: PUSH
84610: LD_VAR 0 7
84614: ARRAY
84615: UNION
84616: ST_TO_ADDR
// if group [ i ] in to_heal then
84617: LD_VAR 0 4
84621: PUSH
84622: LD_VAR 0 7
84626: ARRAY
84627: PUSH
84628: LD_VAR 0 30
84632: IN
84633: IFFALSE 84742
// begin if GetLives ( group [ i ] ) = 1000 then
84635: LD_VAR 0 4
84639: PUSH
84640: LD_VAR 0 7
84644: ARRAY
84645: PPUSH
84646: CALL_OW 256
84650: PUSH
84651: LD_INT 1000
84653: EQUAL
84654: IFFALSE 84680
// to_heal := to_heal diff group [ i ] else
84656: LD_ADDR_VAR 0 30
84660: PUSH
84661: LD_VAR 0 30
84665: PUSH
84666: LD_VAR 0 4
84670: PUSH
84671: LD_VAR 0 7
84675: ARRAY
84676: DIFF
84677: ST_TO_ADDR
84678: GO 84742
// begin if not IsInArea ( group [ i ] , to_heal ) then
84680: LD_VAR 0 4
84684: PUSH
84685: LD_VAR 0 7
84689: ARRAY
84690: PPUSH
84691: LD_VAR 0 30
84695: PPUSH
84696: CALL_OW 308
84700: NOT
84701: IFFALSE 84725
// ComMoveToArea ( group [ i ] , f_heal ) else
84703: LD_VAR 0 4
84707: PUSH
84708: LD_VAR 0 7
84712: ARRAY
84713: PPUSH
84714: LD_VAR 0 23
84718: PPUSH
84719: CALL_OW 113
84723: GO 84740
// ComHold ( group [ i ] ) ;
84725: LD_VAR 0 4
84729: PUSH
84730: LD_VAR 0 7
84734: ARRAY
84735: PPUSH
84736: CALL_OW 140
// continue ;
84740: GO 83584
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84742: LD_VAR 0 4
84746: PUSH
84747: LD_VAR 0 7
84751: ARRAY
84752: PPUSH
84753: LD_INT 10
84755: PPUSH
84756: CALL 43646 0 2
84760: NOT
84761: PUSH
84762: LD_VAR 0 16
84766: PUSH
84767: LD_VAR 0 7
84771: ARRAY
84772: PUSH
84773: EMPTY
84774: EQUAL
84775: NOT
84776: AND
84777: IFFALSE 85043
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84779: LD_VAR 0 4
84783: PUSH
84784: LD_VAR 0 7
84788: ARRAY
84789: PPUSH
84790: CALL_OW 262
84794: PUSH
84795: LD_INT 1
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: IN
84805: IFFALSE 84846
// if GetFuel ( group [ i ] ) < 10 then
84807: LD_VAR 0 4
84811: PUSH
84812: LD_VAR 0 7
84816: ARRAY
84817: PPUSH
84818: CALL_OW 261
84822: PUSH
84823: LD_INT 10
84825: LESS
84826: IFFALSE 84846
// SetFuel ( group [ i ] , 12 ) ;
84828: LD_VAR 0 4
84832: PUSH
84833: LD_VAR 0 7
84837: ARRAY
84838: PPUSH
84839: LD_INT 12
84841: PPUSH
84842: CALL_OW 240
// if units_path [ i ] then
84846: LD_VAR 0 16
84850: PUSH
84851: LD_VAR 0 7
84855: ARRAY
84856: IFFALSE 85041
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84858: LD_VAR 0 4
84862: PUSH
84863: LD_VAR 0 7
84867: ARRAY
84868: PPUSH
84869: LD_VAR 0 16
84873: PUSH
84874: LD_VAR 0 7
84878: ARRAY
84879: PUSH
84880: LD_INT 1
84882: ARRAY
84883: PUSH
84884: LD_INT 1
84886: ARRAY
84887: PPUSH
84888: LD_VAR 0 16
84892: PUSH
84893: LD_VAR 0 7
84897: ARRAY
84898: PUSH
84899: LD_INT 1
84901: ARRAY
84902: PUSH
84903: LD_INT 2
84905: ARRAY
84906: PPUSH
84907: CALL_OW 297
84911: PUSH
84912: LD_INT 6
84914: GREATER
84915: IFFALSE 84990
// begin if not HasTask ( group [ i ] ) then
84917: LD_VAR 0 4
84921: PUSH
84922: LD_VAR 0 7
84926: ARRAY
84927: PPUSH
84928: CALL_OW 314
84932: NOT
84933: IFFALSE 84988
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84935: LD_VAR 0 4
84939: PUSH
84940: LD_VAR 0 7
84944: ARRAY
84945: PPUSH
84946: LD_VAR 0 16
84950: PUSH
84951: LD_VAR 0 7
84955: ARRAY
84956: PUSH
84957: LD_INT 1
84959: ARRAY
84960: PUSH
84961: LD_INT 1
84963: ARRAY
84964: PPUSH
84965: LD_VAR 0 16
84969: PUSH
84970: LD_VAR 0 7
84974: ARRAY
84975: PUSH
84976: LD_INT 1
84978: ARRAY
84979: PUSH
84980: LD_INT 2
84982: ARRAY
84983: PPUSH
84984: CALL_OW 114
// end else
84988: GO 85041
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84990: LD_ADDR_VAR 0 15
84994: PUSH
84995: LD_VAR 0 16
84999: PUSH
85000: LD_VAR 0 7
85004: ARRAY
85005: PPUSH
85006: LD_INT 1
85008: PPUSH
85009: CALL_OW 3
85013: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
85014: LD_ADDR_VAR 0 16
85018: PUSH
85019: LD_VAR 0 16
85023: PPUSH
85024: LD_VAR 0 7
85028: PPUSH
85029: LD_VAR 0 15
85033: PPUSH
85034: CALL_OW 1
85038: ST_TO_ADDR
// continue ;
85039: GO 83584
// end ; end ; end else
85041: GO 87705
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85043: LD_ADDR_VAR 0 14
85047: PUSH
85048: LD_INT 81
85050: PUSH
85051: LD_VAR 0 4
85055: PUSH
85056: LD_VAR 0 7
85060: ARRAY
85061: PPUSH
85062: CALL_OW 255
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PPUSH
85071: CALL_OW 69
85075: ST_TO_ADDR
// if not tmp then
85076: LD_VAR 0 14
85080: NOT
85081: IFFALSE 85085
// continue ;
85083: GO 83584
// if f_ignore_area then
85085: LD_VAR 0 17
85089: IFFALSE 85177
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85091: LD_ADDR_VAR 0 15
85095: PUSH
85096: LD_VAR 0 14
85100: PPUSH
85101: LD_INT 3
85103: PUSH
85104: LD_INT 92
85106: PUSH
85107: LD_VAR 0 17
85111: PUSH
85112: LD_INT 1
85114: ARRAY
85115: PUSH
85116: LD_VAR 0 17
85120: PUSH
85121: LD_INT 2
85123: ARRAY
85124: PUSH
85125: LD_VAR 0 17
85129: PUSH
85130: LD_INT 3
85132: ARRAY
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PPUSH
85144: CALL_OW 72
85148: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85149: LD_VAR 0 14
85153: PUSH
85154: LD_VAR 0 15
85158: DIFF
85159: IFFALSE 85177
// tmp := tmp diff tmp2 ;
85161: LD_ADDR_VAR 0 14
85165: PUSH
85166: LD_VAR 0 14
85170: PUSH
85171: LD_VAR 0 15
85175: DIFF
85176: ST_TO_ADDR
// end ; if not f_murder then
85177: LD_VAR 0 20
85181: NOT
85182: IFFALSE 85240
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85184: LD_ADDR_VAR 0 15
85188: PUSH
85189: LD_VAR 0 14
85193: PPUSH
85194: LD_INT 3
85196: PUSH
85197: LD_INT 50
85199: PUSH
85200: EMPTY
85201: LIST
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PPUSH
85207: CALL_OW 72
85211: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85212: LD_VAR 0 14
85216: PUSH
85217: LD_VAR 0 15
85221: DIFF
85222: IFFALSE 85240
// tmp := tmp diff tmp2 ;
85224: LD_ADDR_VAR 0 14
85228: PUSH
85229: LD_VAR 0 14
85233: PUSH
85234: LD_VAR 0 15
85238: DIFF
85239: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85240: LD_ADDR_VAR 0 14
85244: PUSH
85245: LD_VAR 0 4
85249: PUSH
85250: LD_VAR 0 7
85254: ARRAY
85255: PPUSH
85256: LD_VAR 0 14
85260: PPUSH
85261: LD_INT 1
85263: PPUSH
85264: LD_INT 1
85266: PPUSH
85267: CALL 16587 0 4
85271: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85272: LD_VAR 0 4
85276: PUSH
85277: LD_VAR 0 7
85281: ARRAY
85282: PPUSH
85283: CALL_OW 257
85287: PUSH
85288: LD_INT 1
85290: EQUAL
85291: IFFALSE 85739
// begin if WantPlant ( group [ i ] ) then
85293: LD_VAR 0 4
85297: PUSH
85298: LD_VAR 0 7
85302: ARRAY
85303: PPUSH
85304: CALL 16088 0 1
85308: IFFALSE 85312
// continue ;
85310: GO 83584
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85312: LD_VAR 0 18
85316: PUSH
85317: LD_VAR 0 4
85321: PUSH
85322: LD_VAR 0 7
85326: ARRAY
85327: PPUSH
85328: CALL_OW 310
85332: NOT
85333: AND
85334: PUSH
85335: LD_VAR 0 14
85339: PUSH
85340: LD_INT 1
85342: ARRAY
85343: PUSH
85344: LD_VAR 0 14
85348: PPUSH
85349: LD_INT 21
85351: PUSH
85352: LD_INT 2
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: PUSH
85359: LD_INT 58
85361: PUSH
85362: EMPTY
85363: LIST
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PPUSH
85369: CALL_OW 72
85373: IN
85374: AND
85375: IFFALSE 85411
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85377: LD_VAR 0 4
85381: PUSH
85382: LD_VAR 0 7
85386: ARRAY
85387: PPUSH
85388: LD_VAR 0 14
85392: PUSH
85393: LD_INT 1
85395: ARRAY
85396: PPUSH
85397: CALL_OW 120
// attacking := true ;
85401: LD_ADDR_VAR 0 29
85405: PUSH
85406: LD_INT 1
85408: ST_TO_ADDR
// continue ;
85409: GO 83584
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85411: LD_VAR 0 26
85415: PUSH
85416: LD_VAR 0 4
85420: PUSH
85421: LD_VAR 0 7
85425: ARRAY
85426: PPUSH
85427: CALL_OW 257
85431: PUSH
85432: LD_INT 1
85434: EQUAL
85435: AND
85436: PUSH
85437: LD_VAR 0 4
85441: PUSH
85442: LD_VAR 0 7
85446: ARRAY
85447: PPUSH
85448: CALL_OW 256
85452: PUSH
85453: LD_INT 800
85455: LESS
85456: AND
85457: PUSH
85458: LD_VAR 0 4
85462: PUSH
85463: LD_VAR 0 7
85467: ARRAY
85468: PPUSH
85469: CALL_OW 318
85473: NOT
85474: AND
85475: IFFALSE 85492
// ComCrawl ( group [ i ] ) ;
85477: LD_VAR 0 4
85481: PUSH
85482: LD_VAR 0 7
85486: ARRAY
85487: PPUSH
85488: CALL_OW 137
// if f_mines then
85492: LD_VAR 0 21
85496: IFFALSE 85739
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85498: LD_VAR 0 14
85502: PUSH
85503: LD_INT 1
85505: ARRAY
85506: PPUSH
85507: CALL_OW 247
85511: PUSH
85512: LD_INT 3
85514: EQUAL
85515: PUSH
85516: LD_VAR 0 14
85520: PUSH
85521: LD_INT 1
85523: ARRAY
85524: PUSH
85525: LD_VAR 0 27
85529: IN
85530: NOT
85531: AND
85532: IFFALSE 85739
// begin x := GetX ( tmp [ 1 ] ) ;
85534: LD_ADDR_VAR 0 10
85538: PUSH
85539: LD_VAR 0 14
85543: PUSH
85544: LD_INT 1
85546: ARRAY
85547: PPUSH
85548: CALL_OW 250
85552: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85553: LD_ADDR_VAR 0 11
85557: PUSH
85558: LD_VAR 0 14
85562: PUSH
85563: LD_INT 1
85565: ARRAY
85566: PPUSH
85567: CALL_OW 251
85571: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85572: LD_ADDR_VAR 0 12
85576: PUSH
85577: LD_VAR 0 4
85581: PUSH
85582: LD_VAR 0 7
85586: ARRAY
85587: PPUSH
85588: CALL 43731 0 1
85592: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85593: LD_VAR 0 4
85597: PUSH
85598: LD_VAR 0 7
85602: ARRAY
85603: PPUSH
85604: LD_VAR 0 10
85608: PPUSH
85609: LD_VAR 0 11
85613: PPUSH
85614: LD_VAR 0 14
85618: PUSH
85619: LD_INT 1
85621: ARRAY
85622: PPUSH
85623: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85627: LD_VAR 0 4
85631: PUSH
85632: LD_VAR 0 7
85636: ARRAY
85637: PPUSH
85638: LD_VAR 0 10
85642: PPUSH
85643: LD_VAR 0 12
85647: PPUSH
85648: LD_INT 7
85650: PPUSH
85651: CALL_OW 272
85655: PPUSH
85656: LD_VAR 0 11
85660: PPUSH
85661: LD_VAR 0 12
85665: PPUSH
85666: LD_INT 7
85668: PPUSH
85669: CALL_OW 273
85673: PPUSH
85674: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85678: LD_VAR 0 4
85682: PUSH
85683: LD_VAR 0 7
85687: ARRAY
85688: PPUSH
85689: LD_INT 71
85691: PPUSH
85692: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85696: LD_ADDR_VAR 0 27
85700: PUSH
85701: LD_VAR 0 27
85705: PPUSH
85706: LD_VAR 0 27
85710: PUSH
85711: LD_INT 1
85713: PLUS
85714: PPUSH
85715: LD_VAR 0 14
85719: PUSH
85720: LD_INT 1
85722: ARRAY
85723: PPUSH
85724: CALL_OW 1
85728: ST_TO_ADDR
// attacking := true ;
85729: LD_ADDR_VAR 0 29
85733: PUSH
85734: LD_INT 1
85736: ST_TO_ADDR
// continue ;
85737: GO 83584
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85739: LD_VAR 0 4
85743: PUSH
85744: LD_VAR 0 7
85748: ARRAY
85749: PPUSH
85750: CALL_OW 257
85754: PUSH
85755: LD_INT 17
85757: EQUAL
85758: PUSH
85759: LD_VAR 0 4
85763: PUSH
85764: LD_VAR 0 7
85768: ARRAY
85769: PPUSH
85770: CALL_OW 110
85774: PUSH
85775: LD_INT 71
85777: EQUAL
85778: NOT
85779: AND
85780: IFFALSE 85926
// begin attacking := false ;
85782: LD_ADDR_VAR 0 29
85786: PUSH
85787: LD_INT 0
85789: ST_TO_ADDR
// k := 5 ;
85790: LD_ADDR_VAR 0 9
85794: PUSH
85795: LD_INT 5
85797: ST_TO_ADDR
// if tmp < k then
85798: LD_VAR 0 14
85802: PUSH
85803: LD_VAR 0 9
85807: LESS
85808: IFFALSE 85820
// k := tmp ;
85810: LD_ADDR_VAR 0 9
85814: PUSH
85815: LD_VAR 0 14
85819: ST_TO_ADDR
// for j = 1 to k do
85820: LD_ADDR_VAR 0 8
85824: PUSH
85825: DOUBLE
85826: LD_INT 1
85828: DEC
85829: ST_TO_ADDR
85830: LD_VAR 0 9
85834: PUSH
85835: FOR_TO
85836: IFFALSE 85924
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85838: LD_VAR 0 14
85842: PUSH
85843: LD_VAR 0 8
85847: ARRAY
85848: PUSH
85849: LD_VAR 0 14
85853: PPUSH
85854: LD_INT 58
85856: PUSH
85857: EMPTY
85858: LIST
85859: PPUSH
85860: CALL_OW 72
85864: IN
85865: NOT
85866: IFFALSE 85922
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85868: LD_VAR 0 4
85872: PUSH
85873: LD_VAR 0 7
85877: ARRAY
85878: PPUSH
85879: LD_VAR 0 14
85883: PUSH
85884: LD_VAR 0 8
85888: ARRAY
85889: PPUSH
85890: CALL_OW 115
// attacking := true ;
85894: LD_ADDR_VAR 0 29
85898: PUSH
85899: LD_INT 1
85901: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85902: LD_VAR 0 4
85906: PUSH
85907: LD_VAR 0 7
85911: ARRAY
85912: PPUSH
85913: LD_INT 71
85915: PPUSH
85916: CALL_OW 109
// continue ;
85920: GO 85835
// end ; end ;
85922: GO 85835
85924: POP
85925: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85926: LD_VAR 0 4
85930: PUSH
85931: LD_VAR 0 7
85935: ARRAY
85936: PPUSH
85937: CALL_OW 257
85941: PUSH
85942: LD_INT 8
85944: EQUAL
85945: PUSH
85946: LD_VAR 0 4
85950: PUSH
85951: LD_VAR 0 7
85955: ARRAY
85956: PPUSH
85957: CALL_OW 264
85961: PUSH
85962: LD_INT 28
85964: PUSH
85965: LD_INT 45
85967: PUSH
85968: LD_INT 7
85970: PUSH
85971: LD_INT 47
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: IN
85980: OR
85981: IFFALSE 86237
// begin attacking := false ;
85983: LD_ADDR_VAR 0 29
85987: PUSH
85988: LD_INT 0
85990: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85991: LD_VAR 0 14
85995: PUSH
85996: LD_INT 1
85998: ARRAY
85999: PPUSH
86000: CALL_OW 266
86004: PUSH
86005: LD_INT 32
86007: PUSH
86008: LD_INT 31
86010: PUSH
86011: LD_INT 33
86013: PUSH
86014: LD_INT 4
86016: PUSH
86017: LD_INT 5
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: IN
86027: IFFALSE 86213
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86029: LD_ADDR_VAR 0 9
86033: PUSH
86034: LD_VAR 0 14
86038: PUSH
86039: LD_INT 1
86041: ARRAY
86042: PPUSH
86043: CALL_OW 266
86047: PPUSH
86048: LD_VAR 0 14
86052: PUSH
86053: LD_INT 1
86055: ARRAY
86056: PPUSH
86057: CALL_OW 250
86061: PPUSH
86062: LD_VAR 0 14
86066: PUSH
86067: LD_INT 1
86069: ARRAY
86070: PPUSH
86071: CALL_OW 251
86075: PPUSH
86076: LD_VAR 0 14
86080: PUSH
86081: LD_INT 1
86083: ARRAY
86084: PPUSH
86085: CALL_OW 254
86089: PPUSH
86090: LD_VAR 0 14
86094: PUSH
86095: LD_INT 1
86097: ARRAY
86098: PPUSH
86099: CALL_OW 248
86103: PPUSH
86104: LD_INT 0
86106: PPUSH
86107: CALL 25101 0 6
86111: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86112: LD_ADDR_VAR 0 8
86116: PUSH
86117: LD_VAR 0 4
86121: PUSH
86122: LD_VAR 0 7
86126: ARRAY
86127: PPUSH
86128: LD_VAR 0 9
86132: PPUSH
86133: CALL 43844 0 2
86137: ST_TO_ADDR
// if j then
86138: LD_VAR 0 8
86142: IFFALSE 86211
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86144: LD_VAR 0 8
86148: PUSH
86149: LD_INT 1
86151: ARRAY
86152: PPUSH
86153: LD_VAR 0 8
86157: PUSH
86158: LD_INT 2
86160: ARRAY
86161: PPUSH
86162: CALL_OW 488
86166: IFFALSE 86211
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86168: LD_VAR 0 4
86172: PUSH
86173: LD_VAR 0 7
86177: ARRAY
86178: PPUSH
86179: LD_VAR 0 8
86183: PUSH
86184: LD_INT 1
86186: ARRAY
86187: PPUSH
86188: LD_VAR 0 8
86192: PUSH
86193: LD_INT 2
86195: ARRAY
86196: PPUSH
86197: CALL_OW 116
// attacking := true ;
86201: LD_ADDR_VAR 0 29
86205: PUSH
86206: LD_INT 1
86208: ST_TO_ADDR
// continue ;
86209: GO 83584
// end ; end else
86211: GO 86237
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86213: LD_VAR 0 4
86217: PUSH
86218: LD_VAR 0 7
86222: ARRAY
86223: PPUSH
86224: LD_VAR 0 14
86228: PUSH
86229: LD_INT 1
86231: ARRAY
86232: PPUSH
86233: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86237: LD_VAR 0 4
86241: PUSH
86242: LD_VAR 0 7
86246: ARRAY
86247: PPUSH
86248: CALL_OW 265
86252: PUSH
86253: LD_INT 11
86255: EQUAL
86256: IFFALSE 86534
// begin k := 10 ;
86258: LD_ADDR_VAR 0 9
86262: PUSH
86263: LD_INT 10
86265: ST_TO_ADDR
// x := 0 ;
86266: LD_ADDR_VAR 0 10
86270: PUSH
86271: LD_INT 0
86273: ST_TO_ADDR
// if tmp < k then
86274: LD_VAR 0 14
86278: PUSH
86279: LD_VAR 0 9
86283: LESS
86284: IFFALSE 86296
// k := tmp ;
86286: LD_ADDR_VAR 0 9
86290: PUSH
86291: LD_VAR 0 14
86295: ST_TO_ADDR
// for j = k downto 1 do
86296: LD_ADDR_VAR 0 8
86300: PUSH
86301: DOUBLE
86302: LD_VAR 0 9
86306: INC
86307: ST_TO_ADDR
86308: LD_INT 1
86310: PUSH
86311: FOR_DOWNTO
86312: IFFALSE 86387
// begin if GetType ( tmp [ j ] ) = unit_human then
86314: LD_VAR 0 14
86318: PUSH
86319: LD_VAR 0 8
86323: ARRAY
86324: PPUSH
86325: CALL_OW 247
86329: PUSH
86330: LD_INT 1
86332: EQUAL
86333: IFFALSE 86385
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86335: LD_VAR 0 4
86339: PUSH
86340: LD_VAR 0 7
86344: ARRAY
86345: PPUSH
86346: LD_VAR 0 14
86350: PUSH
86351: LD_VAR 0 8
86355: ARRAY
86356: PPUSH
86357: CALL 44098 0 2
// x := tmp [ j ] ;
86361: LD_ADDR_VAR 0 10
86365: PUSH
86366: LD_VAR 0 14
86370: PUSH
86371: LD_VAR 0 8
86375: ARRAY
86376: ST_TO_ADDR
// attacking := true ;
86377: LD_ADDR_VAR 0 29
86381: PUSH
86382: LD_INT 1
86384: ST_TO_ADDR
// end ; end ;
86385: GO 86311
86387: POP
86388: POP
// if not x then
86389: LD_VAR 0 10
86393: NOT
86394: IFFALSE 86534
// begin attacking := true ;
86396: LD_ADDR_VAR 0 29
86400: PUSH
86401: LD_INT 1
86403: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86404: LD_VAR 0 4
86408: PUSH
86409: LD_VAR 0 7
86413: ARRAY
86414: PPUSH
86415: CALL_OW 250
86419: PPUSH
86420: LD_VAR 0 4
86424: PUSH
86425: LD_VAR 0 7
86429: ARRAY
86430: PPUSH
86431: CALL_OW 251
86435: PPUSH
86436: CALL_OW 546
86440: PUSH
86441: LD_INT 2
86443: ARRAY
86444: PUSH
86445: LD_VAR 0 14
86449: PUSH
86450: LD_INT 1
86452: ARRAY
86453: PPUSH
86454: CALL_OW 250
86458: PPUSH
86459: LD_VAR 0 14
86463: PUSH
86464: LD_INT 1
86466: ARRAY
86467: PPUSH
86468: CALL_OW 251
86472: PPUSH
86473: CALL_OW 546
86477: PUSH
86478: LD_INT 2
86480: ARRAY
86481: EQUAL
86482: IFFALSE 86510
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86484: LD_VAR 0 4
86488: PUSH
86489: LD_VAR 0 7
86493: ARRAY
86494: PPUSH
86495: LD_VAR 0 14
86499: PUSH
86500: LD_INT 1
86502: ARRAY
86503: PPUSH
86504: CALL 44098 0 2
86508: GO 86534
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86510: LD_VAR 0 4
86514: PUSH
86515: LD_VAR 0 7
86519: ARRAY
86520: PPUSH
86521: LD_VAR 0 14
86525: PUSH
86526: LD_INT 1
86528: ARRAY
86529: PPUSH
86530: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86534: LD_VAR 0 4
86538: PUSH
86539: LD_VAR 0 7
86543: ARRAY
86544: PPUSH
86545: CALL_OW 264
86549: PUSH
86550: LD_INT 29
86552: EQUAL
86553: IFFALSE 86919
// begin if WantsToAttack ( group [ i ] ) in bombed then
86555: LD_VAR 0 4
86559: PUSH
86560: LD_VAR 0 7
86564: ARRAY
86565: PPUSH
86566: CALL_OW 319
86570: PUSH
86571: LD_VAR 0 28
86575: IN
86576: IFFALSE 86580
// continue ;
86578: GO 83584
// k := 8 ;
86580: LD_ADDR_VAR 0 9
86584: PUSH
86585: LD_INT 8
86587: ST_TO_ADDR
// x := 0 ;
86588: LD_ADDR_VAR 0 10
86592: PUSH
86593: LD_INT 0
86595: ST_TO_ADDR
// if tmp < k then
86596: LD_VAR 0 14
86600: PUSH
86601: LD_VAR 0 9
86605: LESS
86606: IFFALSE 86618
// k := tmp ;
86608: LD_ADDR_VAR 0 9
86612: PUSH
86613: LD_VAR 0 14
86617: ST_TO_ADDR
// for j = 1 to k do
86618: LD_ADDR_VAR 0 8
86622: PUSH
86623: DOUBLE
86624: LD_INT 1
86626: DEC
86627: ST_TO_ADDR
86628: LD_VAR 0 9
86632: PUSH
86633: FOR_TO
86634: IFFALSE 86766
// begin if GetType ( tmp [ j ] ) = unit_building then
86636: LD_VAR 0 14
86640: PUSH
86641: LD_VAR 0 8
86645: ARRAY
86646: PPUSH
86647: CALL_OW 247
86651: PUSH
86652: LD_INT 3
86654: EQUAL
86655: IFFALSE 86764
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86657: LD_VAR 0 14
86661: PUSH
86662: LD_VAR 0 8
86666: ARRAY
86667: PUSH
86668: LD_VAR 0 28
86672: IN
86673: NOT
86674: PUSH
86675: LD_VAR 0 14
86679: PUSH
86680: LD_VAR 0 8
86684: ARRAY
86685: PPUSH
86686: CALL_OW 313
86690: AND
86691: IFFALSE 86764
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86693: LD_VAR 0 4
86697: PUSH
86698: LD_VAR 0 7
86702: ARRAY
86703: PPUSH
86704: LD_VAR 0 14
86708: PUSH
86709: LD_VAR 0 8
86713: ARRAY
86714: PPUSH
86715: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86719: LD_ADDR_VAR 0 28
86723: PUSH
86724: LD_VAR 0 28
86728: PPUSH
86729: LD_VAR 0 28
86733: PUSH
86734: LD_INT 1
86736: PLUS
86737: PPUSH
86738: LD_VAR 0 14
86742: PUSH
86743: LD_VAR 0 8
86747: ARRAY
86748: PPUSH
86749: CALL_OW 1
86753: ST_TO_ADDR
// attacking := true ;
86754: LD_ADDR_VAR 0 29
86758: PUSH
86759: LD_INT 1
86761: ST_TO_ADDR
// break ;
86762: GO 86766
// end ; end ;
86764: GO 86633
86766: POP
86767: POP
// if not attacking and f_attack_depot then
86768: LD_VAR 0 29
86772: NOT
86773: PUSH
86774: LD_VAR 0 25
86778: AND
86779: IFFALSE 86874
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86781: LD_ADDR_VAR 0 13
86785: PUSH
86786: LD_VAR 0 14
86790: PPUSH
86791: LD_INT 2
86793: PUSH
86794: LD_INT 30
86796: PUSH
86797: LD_INT 0
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 30
86806: PUSH
86807: LD_INT 1
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: LIST
86818: PPUSH
86819: CALL_OW 72
86823: ST_TO_ADDR
// if z then
86824: LD_VAR 0 13
86828: IFFALSE 86874
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86830: LD_VAR 0 4
86834: PUSH
86835: LD_VAR 0 7
86839: ARRAY
86840: PPUSH
86841: LD_VAR 0 13
86845: PPUSH
86846: LD_VAR 0 4
86850: PUSH
86851: LD_VAR 0 7
86855: ARRAY
86856: PPUSH
86857: CALL_OW 74
86861: PPUSH
86862: CALL_OW 115
// attacking := true ;
86866: LD_ADDR_VAR 0 29
86870: PUSH
86871: LD_INT 1
86873: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86874: LD_VAR 0 4
86878: PUSH
86879: LD_VAR 0 7
86883: ARRAY
86884: PPUSH
86885: CALL_OW 256
86889: PUSH
86890: LD_INT 500
86892: LESS
86893: IFFALSE 86919
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86895: LD_VAR 0 4
86899: PUSH
86900: LD_VAR 0 7
86904: ARRAY
86905: PPUSH
86906: LD_VAR 0 14
86910: PUSH
86911: LD_INT 1
86913: ARRAY
86914: PPUSH
86915: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86919: LD_VAR 0 4
86923: PUSH
86924: LD_VAR 0 7
86928: ARRAY
86929: PPUSH
86930: CALL_OW 264
86934: PUSH
86935: LD_INT 49
86937: EQUAL
86938: IFFALSE 87059
// begin if not HasTask ( group [ i ] ) then
86940: LD_VAR 0 4
86944: PUSH
86945: LD_VAR 0 7
86949: ARRAY
86950: PPUSH
86951: CALL_OW 314
86955: NOT
86956: IFFALSE 87059
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86958: LD_ADDR_VAR 0 9
86962: PUSH
86963: LD_INT 81
86965: PUSH
86966: LD_VAR 0 4
86970: PUSH
86971: LD_VAR 0 7
86975: ARRAY
86976: PPUSH
86977: CALL_OW 255
86981: PUSH
86982: EMPTY
86983: LIST
86984: LIST
86985: PPUSH
86986: CALL_OW 69
86990: PPUSH
86991: LD_VAR 0 4
86995: PUSH
86996: LD_VAR 0 7
87000: ARRAY
87001: PPUSH
87002: CALL_OW 74
87006: ST_TO_ADDR
// if k then
87007: LD_VAR 0 9
87011: IFFALSE 87059
// if GetDistUnits ( group [ i ] , k ) > 10 then
87013: LD_VAR 0 4
87017: PUSH
87018: LD_VAR 0 7
87022: ARRAY
87023: PPUSH
87024: LD_VAR 0 9
87028: PPUSH
87029: CALL_OW 296
87033: PUSH
87034: LD_INT 10
87036: GREATER
87037: IFFALSE 87059
// ComMoveUnit ( group [ i ] , k ) ;
87039: LD_VAR 0 4
87043: PUSH
87044: LD_VAR 0 7
87048: ARRAY
87049: PPUSH
87050: LD_VAR 0 9
87054: PPUSH
87055: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87059: LD_VAR 0 4
87063: PUSH
87064: LD_VAR 0 7
87068: ARRAY
87069: PPUSH
87070: CALL_OW 256
87074: PUSH
87075: LD_INT 250
87077: LESS
87078: PUSH
87079: LD_VAR 0 4
87083: PUSH
87084: LD_VAR 0 7
87088: ARRAY
87089: PUSH
87090: LD_INT 21
87092: PUSH
87093: LD_INT 2
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 23
87102: PUSH
87103: LD_INT 2
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PPUSH
87114: CALL_OW 69
87118: IN
87119: AND
87120: IFFALSE 87245
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87122: LD_ADDR_VAR 0 9
87126: PUSH
87127: LD_OWVAR 3
87131: PUSH
87132: LD_VAR 0 4
87136: PUSH
87137: LD_VAR 0 7
87141: ARRAY
87142: DIFF
87143: PPUSH
87144: LD_VAR 0 4
87148: PUSH
87149: LD_VAR 0 7
87153: ARRAY
87154: PPUSH
87155: CALL_OW 74
87159: ST_TO_ADDR
// if not k then
87160: LD_VAR 0 9
87164: NOT
87165: IFFALSE 87169
// continue ;
87167: GO 83584
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87169: LD_VAR 0 9
87173: PUSH
87174: LD_INT 81
87176: PUSH
87177: LD_VAR 0 4
87181: PUSH
87182: LD_VAR 0 7
87186: ARRAY
87187: PPUSH
87188: CALL_OW 255
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PPUSH
87197: CALL_OW 69
87201: IN
87202: PUSH
87203: LD_VAR 0 9
87207: PPUSH
87208: LD_VAR 0 4
87212: PUSH
87213: LD_VAR 0 7
87217: ARRAY
87218: PPUSH
87219: CALL_OW 296
87223: PUSH
87224: LD_INT 5
87226: LESS
87227: AND
87228: IFFALSE 87245
// ComAutodestruct ( group [ i ] ) ;
87230: LD_VAR 0 4
87234: PUSH
87235: LD_VAR 0 7
87239: ARRAY
87240: PPUSH
87241: CALL 43996 0 1
// end ; if f_attack_depot then
87245: LD_VAR 0 25
87249: IFFALSE 87361
// begin k := 6 ;
87251: LD_ADDR_VAR 0 9
87255: PUSH
87256: LD_INT 6
87258: ST_TO_ADDR
// if tmp < k then
87259: LD_VAR 0 14
87263: PUSH
87264: LD_VAR 0 9
87268: LESS
87269: IFFALSE 87281
// k := tmp ;
87271: LD_ADDR_VAR 0 9
87275: PUSH
87276: LD_VAR 0 14
87280: ST_TO_ADDR
// for j = 1 to k do
87281: LD_ADDR_VAR 0 8
87285: PUSH
87286: DOUBLE
87287: LD_INT 1
87289: DEC
87290: ST_TO_ADDR
87291: LD_VAR 0 9
87295: PUSH
87296: FOR_TO
87297: IFFALSE 87359
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87299: LD_VAR 0 8
87303: PPUSH
87304: CALL_OW 266
87308: PUSH
87309: LD_INT 0
87311: PUSH
87312: LD_INT 1
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: IN
87319: IFFALSE 87357
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87321: LD_VAR 0 4
87325: PUSH
87326: LD_VAR 0 7
87330: ARRAY
87331: PPUSH
87332: LD_VAR 0 14
87336: PUSH
87337: LD_VAR 0 8
87341: ARRAY
87342: PPUSH
87343: CALL_OW 115
// attacking := true ;
87347: LD_ADDR_VAR 0 29
87351: PUSH
87352: LD_INT 1
87354: ST_TO_ADDR
// break ;
87355: GO 87359
// end ;
87357: GO 87296
87359: POP
87360: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87361: LD_VAR 0 4
87365: PUSH
87366: LD_VAR 0 7
87370: ARRAY
87371: PPUSH
87372: CALL_OW 302
87376: PUSH
87377: LD_VAR 0 29
87381: NOT
87382: AND
87383: IFFALSE 87705
// begin if GetTag ( group [ i ] ) = 71 then
87385: LD_VAR 0 4
87389: PUSH
87390: LD_VAR 0 7
87394: ARRAY
87395: PPUSH
87396: CALL_OW 110
87400: PUSH
87401: LD_INT 71
87403: EQUAL
87404: IFFALSE 87445
// begin if HasTask ( group [ i ] ) then
87406: LD_VAR 0 4
87410: PUSH
87411: LD_VAR 0 7
87415: ARRAY
87416: PPUSH
87417: CALL_OW 314
87421: IFFALSE 87427
// continue else
87423: GO 83584
87425: GO 87445
// SetTag ( group [ i ] , 0 ) ;
87427: LD_VAR 0 4
87431: PUSH
87432: LD_VAR 0 7
87436: ARRAY
87437: PPUSH
87438: LD_INT 0
87440: PPUSH
87441: CALL_OW 109
// end ; k := 8 ;
87445: LD_ADDR_VAR 0 9
87449: PUSH
87450: LD_INT 8
87452: ST_TO_ADDR
// x := 0 ;
87453: LD_ADDR_VAR 0 10
87457: PUSH
87458: LD_INT 0
87460: ST_TO_ADDR
// if tmp < k then
87461: LD_VAR 0 14
87465: PUSH
87466: LD_VAR 0 9
87470: LESS
87471: IFFALSE 87483
// k := tmp ;
87473: LD_ADDR_VAR 0 9
87477: PUSH
87478: LD_VAR 0 14
87482: ST_TO_ADDR
// for j = 1 to k do
87483: LD_ADDR_VAR 0 8
87487: PUSH
87488: DOUBLE
87489: LD_INT 1
87491: DEC
87492: ST_TO_ADDR
87493: LD_VAR 0 9
87497: PUSH
87498: FOR_TO
87499: IFFALSE 87597
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87501: LD_VAR 0 14
87505: PUSH
87506: LD_VAR 0 8
87510: ARRAY
87511: PPUSH
87512: CALL_OW 247
87516: PUSH
87517: LD_INT 1
87519: EQUAL
87520: PUSH
87521: LD_VAR 0 14
87525: PUSH
87526: LD_VAR 0 8
87530: ARRAY
87531: PPUSH
87532: CALL_OW 256
87536: PUSH
87537: LD_INT 250
87539: LESS
87540: PUSH
87541: LD_VAR 0 20
87545: AND
87546: PUSH
87547: LD_VAR 0 20
87551: NOT
87552: PUSH
87553: LD_VAR 0 14
87557: PUSH
87558: LD_VAR 0 8
87562: ARRAY
87563: PPUSH
87564: CALL_OW 256
87568: PUSH
87569: LD_INT 250
87571: GREATEREQUAL
87572: AND
87573: OR
87574: AND
87575: IFFALSE 87595
// begin x := tmp [ j ] ;
87577: LD_ADDR_VAR 0 10
87581: PUSH
87582: LD_VAR 0 14
87586: PUSH
87587: LD_VAR 0 8
87591: ARRAY
87592: ST_TO_ADDR
// break ;
87593: GO 87597
// end ;
87595: GO 87498
87597: POP
87598: POP
// if x then
87599: LD_VAR 0 10
87603: IFFALSE 87627
// ComAttackUnit ( group [ i ] , x ) else
87605: LD_VAR 0 4
87609: PUSH
87610: LD_VAR 0 7
87614: ARRAY
87615: PPUSH
87616: LD_VAR 0 10
87620: PPUSH
87621: CALL_OW 115
87625: GO 87651
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87627: LD_VAR 0 4
87631: PUSH
87632: LD_VAR 0 7
87636: ARRAY
87637: PPUSH
87638: LD_VAR 0 14
87642: PUSH
87643: LD_INT 1
87645: ARRAY
87646: PPUSH
87647: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87651: LD_VAR 0 4
87655: PUSH
87656: LD_VAR 0 7
87660: ARRAY
87661: PPUSH
87662: CALL_OW 314
87666: NOT
87667: IFFALSE 87705
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87669: LD_VAR 0 4
87673: PUSH
87674: LD_VAR 0 7
87678: ARRAY
87679: PPUSH
87680: LD_VAR 0 14
87684: PPUSH
87685: LD_VAR 0 4
87689: PUSH
87690: LD_VAR 0 7
87694: ARRAY
87695: PPUSH
87696: CALL_OW 74
87700: PPUSH
87701: CALL_OW 115
// end ; end ; end ;
87705: GO 83584
87707: POP
87708: POP
// wait ( 0 0$2 ) ;
87709: LD_INT 70
87711: PPUSH
87712: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87716: LD_VAR 0 4
87720: NOT
87721: PUSH
87722: LD_VAR 0 4
87726: PUSH
87727: EMPTY
87728: EQUAL
87729: OR
87730: PUSH
87731: LD_INT 81
87733: PUSH
87734: LD_VAR 0 35
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PPUSH
87743: CALL_OW 69
87747: NOT
87748: OR
87749: IFFALSE 83569
// end ;
87751: LD_VAR 0 2
87755: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87756: LD_INT 0
87758: PPUSH
87759: PPUSH
87760: PPUSH
87761: PPUSH
87762: PPUSH
87763: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87764: LD_VAR 0 1
87768: NOT
87769: PUSH
87770: LD_EXP 23
87774: PUSH
87775: LD_VAR 0 1
87779: ARRAY
87780: NOT
87781: OR
87782: PUSH
87783: LD_VAR 0 2
87787: NOT
87788: OR
87789: IFFALSE 87793
// exit ;
87791: GO 88347
// side := mc_sides [ base ] ;
87793: LD_ADDR_VAR 0 6
87797: PUSH
87798: LD_EXP 49
87802: PUSH
87803: LD_VAR 0 1
87807: ARRAY
87808: ST_TO_ADDR
// if not side then
87809: LD_VAR 0 6
87813: NOT
87814: IFFALSE 87818
// exit ;
87816: GO 88347
// for i in solds do
87818: LD_ADDR_VAR 0 7
87822: PUSH
87823: LD_VAR 0 2
87827: PUSH
87828: FOR_IN
87829: IFFALSE 87890
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87831: LD_VAR 0 7
87835: PPUSH
87836: CALL_OW 310
87840: PPUSH
87841: CALL_OW 266
87845: PUSH
87846: LD_INT 32
87848: PUSH
87849: LD_INT 31
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: IN
87856: IFFALSE 87876
// solds := solds diff i else
87858: LD_ADDR_VAR 0 2
87862: PUSH
87863: LD_VAR 0 2
87867: PUSH
87868: LD_VAR 0 7
87872: DIFF
87873: ST_TO_ADDR
87874: GO 87888
// SetTag ( i , 18 ) ;
87876: LD_VAR 0 7
87880: PPUSH
87881: LD_INT 18
87883: PPUSH
87884: CALL_OW 109
87888: GO 87828
87890: POP
87891: POP
// if not solds then
87892: LD_VAR 0 2
87896: NOT
87897: IFFALSE 87901
// exit ;
87899: GO 88347
// repeat wait ( 0 0$2 ) ;
87901: LD_INT 70
87903: PPUSH
87904: CALL_OW 67
// enemy := mc_scan [ base ] ;
87908: LD_ADDR_VAR 0 4
87912: PUSH
87913: LD_EXP 46
87917: PUSH
87918: LD_VAR 0 1
87922: ARRAY
87923: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87924: LD_EXP 23
87928: PUSH
87929: LD_VAR 0 1
87933: ARRAY
87934: NOT
87935: PUSH
87936: LD_EXP 23
87940: PUSH
87941: LD_VAR 0 1
87945: ARRAY
87946: PUSH
87947: EMPTY
87948: EQUAL
87949: OR
87950: IFFALSE 87987
// begin for i in solds do
87952: LD_ADDR_VAR 0 7
87956: PUSH
87957: LD_VAR 0 2
87961: PUSH
87962: FOR_IN
87963: IFFALSE 87976
// ComStop ( i ) ;
87965: LD_VAR 0 7
87969: PPUSH
87970: CALL_OW 141
87974: GO 87962
87976: POP
87977: POP
// solds := [ ] ;
87978: LD_ADDR_VAR 0 2
87982: PUSH
87983: EMPTY
87984: ST_TO_ADDR
// exit ;
87985: GO 88347
// end ; for i in solds do
87987: LD_ADDR_VAR 0 7
87991: PUSH
87992: LD_VAR 0 2
87996: PUSH
87997: FOR_IN
87998: IFFALSE 88319
// begin if IsInUnit ( i ) then
88000: LD_VAR 0 7
88004: PPUSH
88005: CALL_OW 310
88009: IFFALSE 88020
// ComExitBuilding ( i ) ;
88011: LD_VAR 0 7
88015: PPUSH
88016: CALL_OW 122
// if GetLives ( i ) > 500 then
88020: LD_VAR 0 7
88024: PPUSH
88025: CALL_OW 256
88029: PUSH
88030: LD_INT 500
88032: GREATER
88033: IFFALSE 88086
// begin e := NearestUnitToUnit ( enemy , i ) ;
88035: LD_ADDR_VAR 0 5
88039: PUSH
88040: LD_VAR 0 4
88044: PPUSH
88045: LD_VAR 0 7
88049: PPUSH
88050: CALL_OW 74
88054: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88055: LD_VAR 0 7
88059: PPUSH
88060: LD_VAR 0 5
88064: PPUSH
88065: CALL_OW 250
88069: PPUSH
88070: LD_VAR 0 5
88074: PPUSH
88075: CALL_OW 251
88079: PPUSH
88080: CALL_OW 114
// end else
88084: GO 88317
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88086: LD_VAR 0 7
88090: PPUSH
88091: LD_EXP 23
88095: PUSH
88096: LD_VAR 0 1
88100: ARRAY
88101: PPUSH
88102: LD_INT 2
88104: PUSH
88105: LD_INT 30
88107: PUSH
88108: LD_INT 0
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 30
88117: PUSH
88118: LD_INT 1
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 30
88127: PUSH
88128: LD_INT 6
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: PPUSH
88141: CALL_OW 72
88145: PPUSH
88146: LD_VAR 0 7
88150: PPUSH
88151: CALL_OW 74
88155: PPUSH
88156: CALL_OW 296
88160: PUSH
88161: LD_INT 10
88163: GREATER
88164: IFFALSE 88317
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88166: LD_ADDR_VAR 0 8
88170: PUSH
88171: LD_EXP 23
88175: PUSH
88176: LD_VAR 0 1
88180: ARRAY
88181: PPUSH
88182: LD_INT 2
88184: PUSH
88185: LD_INT 30
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 30
88197: PUSH
88198: LD_INT 1
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 30
88207: PUSH
88208: LD_INT 6
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: PPUSH
88221: CALL_OW 72
88225: PPUSH
88226: LD_VAR 0 7
88230: PPUSH
88231: CALL_OW 74
88235: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88236: LD_VAR 0 7
88240: PPUSH
88241: LD_VAR 0 8
88245: PPUSH
88246: CALL_OW 250
88250: PPUSH
88251: LD_INT 3
88253: PPUSH
88254: LD_INT 5
88256: PPUSH
88257: CALL_OW 272
88261: PPUSH
88262: LD_VAR 0 8
88266: PPUSH
88267: CALL_OW 251
88271: PPUSH
88272: LD_INT 3
88274: PPUSH
88275: LD_INT 5
88277: PPUSH
88278: CALL_OW 273
88282: PPUSH
88283: CALL_OW 111
// SetTag ( i , 0 ) ;
88287: LD_VAR 0 7
88291: PPUSH
88292: LD_INT 0
88294: PPUSH
88295: CALL_OW 109
// solds := solds diff i ;
88299: LD_ADDR_VAR 0 2
88303: PUSH
88304: LD_VAR 0 2
88308: PUSH
88309: LD_VAR 0 7
88313: DIFF
88314: ST_TO_ADDR
// continue ;
88315: GO 87997
// end ; end ;
88317: GO 87997
88319: POP
88320: POP
// until not solds or not enemy ;
88321: LD_VAR 0 2
88325: NOT
88326: PUSH
88327: LD_VAR 0 4
88331: NOT
88332: OR
88333: IFFALSE 87901
// MC_Reset ( base , 18 ) ;
88335: LD_VAR 0 1
88339: PPUSH
88340: LD_INT 18
88342: PPUSH
88343: CALL 56544 0 2
// end ;
88347: LD_VAR 0 3
88351: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88352: LD_INT 0
88354: PPUSH
88355: PPUSH
88356: PPUSH
88357: PPUSH
88358: PPUSH
88359: PPUSH
88360: PPUSH
88361: PPUSH
88362: PPUSH
88363: PPUSH
88364: PPUSH
88365: PPUSH
88366: PPUSH
88367: PPUSH
88368: PPUSH
88369: PPUSH
88370: PPUSH
88371: PPUSH
88372: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88373: LD_ADDR_VAR 0 12
88377: PUSH
88378: LD_EXP 23
88382: PUSH
88383: LD_VAR 0 1
88387: ARRAY
88388: PPUSH
88389: LD_INT 25
88391: PUSH
88392: LD_INT 3
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PPUSH
88399: CALL_OW 72
88403: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88404: LD_EXP 63
88408: PUSH
88409: LD_VAR 0 1
88413: ARRAY
88414: IFFALSE 88438
// mechs := mechs diff mc_remote_driver [ base ] ;
88416: LD_ADDR_VAR 0 12
88420: PUSH
88421: LD_VAR 0 12
88425: PUSH
88426: LD_EXP 63
88430: PUSH
88431: LD_VAR 0 1
88435: ARRAY
88436: DIFF
88437: ST_TO_ADDR
// for i in mechs do
88438: LD_ADDR_VAR 0 4
88442: PUSH
88443: LD_VAR 0 12
88447: PUSH
88448: FOR_IN
88449: IFFALSE 88484
// if GetTag ( i ) > 0 then
88451: LD_VAR 0 4
88455: PPUSH
88456: CALL_OW 110
88460: PUSH
88461: LD_INT 0
88463: GREATER
88464: IFFALSE 88482
// mechs := mechs diff i ;
88466: LD_ADDR_VAR 0 12
88470: PUSH
88471: LD_VAR 0 12
88475: PUSH
88476: LD_VAR 0 4
88480: DIFF
88481: ST_TO_ADDR
88482: GO 88448
88484: POP
88485: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88486: LD_ADDR_VAR 0 8
88490: PUSH
88491: LD_EXP 23
88495: PUSH
88496: LD_VAR 0 1
88500: ARRAY
88501: PPUSH
88502: LD_INT 2
88504: PUSH
88505: LD_INT 25
88507: PUSH
88508: LD_INT 1
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 25
88517: PUSH
88518: LD_INT 5
88520: PUSH
88521: EMPTY
88522: LIST
88523: LIST
88524: PUSH
88525: LD_INT 25
88527: PUSH
88528: LD_INT 8
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 25
88537: PUSH
88538: LD_INT 9
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: PPUSH
88552: CALL_OW 72
88556: ST_TO_ADDR
// if not defenders and not solds then
88557: LD_VAR 0 2
88561: NOT
88562: PUSH
88563: LD_VAR 0 8
88567: NOT
88568: AND
88569: IFFALSE 88573
// exit ;
88571: GO 90343
// depot_under_attack := false ;
88573: LD_ADDR_VAR 0 16
88577: PUSH
88578: LD_INT 0
88580: ST_TO_ADDR
// sold_defenders := [ ] ;
88581: LD_ADDR_VAR 0 17
88585: PUSH
88586: EMPTY
88587: ST_TO_ADDR
// if mechs then
88588: LD_VAR 0 12
88592: IFFALSE 88745
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88594: LD_ADDR_VAR 0 4
88598: PUSH
88599: LD_VAR 0 2
88603: PPUSH
88604: LD_INT 21
88606: PUSH
88607: LD_INT 2
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PPUSH
88614: CALL_OW 72
88618: PUSH
88619: FOR_IN
88620: IFFALSE 88743
// begin if GetTag ( i ) <> 20 then
88622: LD_VAR 0 4
88626: PPUSH
88627: CALL_OW 110
88631: PUSH
88632: LD_INT 20
88634: NONEQUAL
88635: IFFALSE 88649
// SetTag ( i , 20 ) ;
88637: LD_VAR 0 4
88641: PPUSH
88642: LD_INT 20
88644: PPUSH
88645: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88649: LD_VAR 0 4
88653: PPUSH
88654: CALL_OW 263
88658: PUSH
88659: LD_INT 1
88661: EQUAL
88662: PUSH
88663: LD_VAR 0 4
88667: PPUSH
88668: CALL_OW 311
88672: NOT
88673: AND
88674: IFFALSE 88741
// begin un := mechs [ 1 ] ;
88676: LD_ADDR_VAR 0 10
88680: PUSH
88681: LD_VAR 0 12
88685: PUSH
88686: LD_INT 1
88688: ARRAY
88689: ST_TO_ADDR
// ComExit ( un ) ;
88690: LD_VAR 0 10
88694: PPUSH
88695: CALL 48862 0 1
// AddComEnterUnit ( un , i ) ;
88699: LD_VAR 0 10
88703: PPUSH
88704: LD_VAR 0 4
88708: PPUSH
88709: CALL_OW 180
// SetTag ( un , 19 ) ;
88713: LD_VAR 0 10
88717: PPUSH
88718: LD_INT 19
88720: PPUSH
88721: CALL_OW 109
// mechs := mechs diff un ;
88725: LD_ADDR_VAR 0 12
88729: PUSH
88730: LD_VAR 0 12
88734: PUSH
88735: LD_VAR 0 10
88739: DIFF
88740: ST_TO_ADDR
// end ; end ;
88741: GO 88619
88743: POP
88744: POP
// if solds then
88745: LD_VAR 0 8
88749: IFFALSE 88808
// for i in solds do
88751: LD_ADDR_VAR 0 4
88755: PUSH
88756: LD_VAR 0 8
88760: PUSH
88761: FOR_IN
88762: IFFALSE 88806
// if not GetTag ( i ) then
88764: LD_VAR 0 4
88768: PPUSH
88769: CALL_OW 110
88773: NOT
88774: IFFALSE 88804
// begin defenders := defenders union i ;
88776: LD_ADDR_VAR 0 2
88780: PUSH
88781: LD_VAR 0 2
88785: PUSH
88786: LD_VAR 0 4
88790: UNION
88791: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88792: LD_VAR 0 4
88796: PPUSH
88797: LD_INT 18
88799: PPUSH
88800: CALL_OW 109
// end ;
88804: GO 88761
88806: POP
88807: POP
// repeat wait ( 0 0$2 ) ;
88808: LD_INT 70
88810: PPUSH
88811: CALL_OW 67
// enemy := mc_scan [ base ] ;
88815: LD_ADDR_VAR 0 21
88819: PUSH
88820: LD_EXP 46
88824: PUSH
88825: LD_VAR 0 1
88829: ARRAY
88830: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88831: LD_EXP 23
88835: PUSH
88836: LD_VAR 0 1
88840: ARRAY
88841: NOT
88842: PUSH
88843: LD_EXP 23
88847: PUSH
88848: LD_VAR 0 1
88852: ARRAY
88853: PUSH
88854: EMPTY
88855: EQUAL
88856: OR
88857: IFFALSE 88894
// begin for i in defenders do
88859: LD_ADDR_VAR 0 4
88863: PUSH
88864: LD_VAR 0 2
88868: PUSH
88869: FOR_IN
88870: IFFALSE 88883
// ComStop ( i ) ;
88872: LD_VAR 0 4
88876: PPUSH
88877: CALL_OW 141
88881: GO 88869
88883: POP
88884: POP
// defenders := [ ] ;
88885: LD_ADDR_VAR 0 2
88889: PUSH
88890: EMPTY
88891: ST_TO_ADDR
// exit ;
88892: GO 90343
// end ; for i in defenders do
88894: LD_ADDR_VAR 0 4
88898: PUSH
88899: LD_VAR 0 2
88903: PUSH
88904: FOR_IN
88905: IFFALSE 89803
// begin e := NearestUnitToUnit ( enemy , i ) ;
88907: LD_ADDR_VAR 0 13
88911: PUSH
88912: LD_VAR 0 21
88916: PPUSH
88917: LD_VAR 0 4
88921: PPUSH
88922: CALL_OW 74
88926: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88927: LD_ADDR_VAR 0 7
88931: PUSH
88932: LD_EXP 23
88936: PUSH
88937: LD_VAR 0 1
88941: ARRAY
88942: PPUSH
88943: LD_INT 2
88945: PUSH
88946: LD_INT 30
88948: PUSH
88949: LD_INT 0
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 30
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: LIST
88970: PPUSH
88971: CALL_OW 72
88975: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88976: LD_ADDR_VAR 0 16
88980: PUSH
88981: LD_VAR 0 7
88985: NOT
88986: PUSH
88987: LD_VAR 0 7
88991: PPUSH
88992: LD_INT 3
88994: PUSH
88995: LD_INT 24
88997: PUSH
88998: LD_INT 600
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PPUSH
89009: CALL_OW 72
89013: OR
89014: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
89015: LD_VAR 0 4
89019: PPUSH
89020: CALL_OW 247
89024: PUSH
89025: LD_INT 2
89027: DOUBLE
89028: EQUAL
89029: IFTRUE 89033
89031: GO 89429
89033: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89034: LD_VAR 0 4
89038: PPUSH
89039: CALL_OW 256
89043: PUSH
89044: LD_INT 1000
89046: EQUAL
89047: PUSH
89048: LD_VAR 0 4
89052: PPUSH
89053: LD_VAR 0 13
89057: PPUSH
89058: CALL_OW 296
89062: PUSH
89063: LD_INT 40
89065: LESS
89066: PUSH
89067: LD_VAR 0 13
89071: PPUSH
89072: LD_EXP 48
89076: PUSH
89077: LD_VAR 0 1
89081: ARRAY
89082: PPUSH
89083: CALL_OW 308
89087: OR
89088: AND
89089: IFFALSE 89211
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89091: LD_VAR 0 4
89095: PPUSH
89096: CALL_OW 262
89100: PUSH
89101: LD_INT 1
89103: EQUAL
89104: PUSH
89105: LD_VAR 0 4
89109: PPUSH
89110: CALL_OW 261
89114: PUSH
89115: LD_INT 30
89117: LESS
89118: AND
89119: PUSH
89120: LD_VAR 0 7
89124: AND
89125: IFFALSE 89195
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89127: LD_VAR 0 4
89131: PPUSH
89132: LD_VAR 0 7
89136: PPUSH
89137: LD_VAR 0 4
89141: PPUSH
89142: CALL_OW 74
89146: PPUSH
89147: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89151: LD_VAR 0 4
89155: PPUSH
89156: LD_VAR 0 7
89160: PPUSH
89161: LD_VAR 0 4
89165: PPUSH
89166: CALL_OW 74
89170: PPUSH
89171: CALL_OW 296
89175: PUSH
89176: LD_INT 6
89178: LESS
89179: IFFALSE 89193
// SetFuel ( i , 100 ) ;
89181: LD_VAR 0 4
89185: PPUSH
89186: LD_INT 100
89188: PPUSH
89189: CALL_OW 240
// end else
89193: GO 89209
// ComAttackUnit ( i , e ) ;
89195: LD_VAR 0 4
89199: PPUSH
89200: LD_VAR 0 13
89204: PPUSH
89205: CALL_OW 115
// end else
89209: GO 89312
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89211: LD_VAR 0 13
89215: PPUSH
89216: LD_EXP 48
89220: PUSH
89221: LD_VAR 0 1
89225: ARRAY
89226: PPUSH
89227: CALL_OW 308
89231: NOT
89232: PUSH
89233: LD_VAR 0 4
89237: PPUSH
89238: LD_VAR 0 13
89242: PPUSH
89243: CALL_OW 296
89247: PUSH
89248: LD_INT 40
89250: GREATEREQUAL
89251: AND
89252: PUSH
89253: LD_VAR 0 4
89257: PPUSH
89258: CALL_OW 256
89262: PUSH
89263: LD_INT 650
89265: LESSEQUAL
89266: OR
89267: PUSH
89268: LD_VAR 0 4
89272: PPUSH
89273: LD_EXP 47
89277: PUSH
89278: LD_VAR 0 1
89282: ARRAY
89283: PPUSH
89284: CALL_OW 308
89288: NOT
89289: AND
89290: IFFALSE 89312
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89292: LD_VAR 0 4
89296: PPUSH
89297: LD_EXP 47
89301: PUSH
89302: LD_VAR 0 1
89306: ARRAY
89307: PPUSH
89308: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89312: LD_VAR 0 4
89316: PPUSH
89317: CALL_OW 256
89321: PUSH
89322: LD_INT 1000
89324: LESS
89325: PUSH
89326: LD_VAR 0 4
89330: PPUSH
89331: CALL_OW 263
89335: PUSH
89336: LD_INT 1
89338: EQUAL
89339: AND
89340: PUSH
89341: LD_VAR 0 4
89345: PPUSH
89346: CALL_OW 311
89350: AND
89351: PUSH
89352: LD_VAR 0 4
89356: PPUSH
89357: LD_EXP 47
89361: PUSH
89362: LD_VAR 0 1
89366: ARRAY
89367: PPUSH
89368: CALL_OW 308
89372: AND
89373: IFFALSE 89427
// begin mech := IsDrivenBy ( i ) ;
89375: LD_ADDR_VAR 0 9
89379: PUSH
89380: LD_VAR 0 4
89384: PPUSH
89385: CALL_OW 311
89389: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89390: LD_VAR 0 9
89394: PPUSH
89395: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89399: LD_VAR 0 9
89403: PPUSH
89404: LD_VAR 0 4
89408: PPUSH
89409: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89413: LD_VAR 0 9
89417: PPUSH
89418: LD_VAR 0 4
89422: PPUSH
89423: CALL_OW 180
// end ; end ; unit_human :
89427: GO 89774
89429: LD_INT 1
89431: DOUBLE
89432: EQUAL
89433: IFTRUE 89437
89435: GO 89773
89437: POP
// begin b := IsInUnit ( i ) ;
89438: LD_ADDR_VAR 0 18
89442: PUSH
89443: LD_VAR 0 4
89447: PPUSH
89448: CALL_OW 310
89452: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89453: LD_ADDR_VAR 0 19
89457: PUSH
89458: LD_VAR 0 18
89462: NOT
89463: PUSH
89464: LD_VAR 0 18
89468: PPUSH
89469: CALL_OW 266
89473: PUSH
89474: LD_INT 32
89476: PUSH
89477: LD_INT 31
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: IN
89484: OR
89485: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89486: LD_VAR 0 18
89490: PPUSH
89491: CALL_OW 266
89495: PUSH
89496: LD_INT 5
89498: EQUAL
89499: PUSH
89500: LD_VAR 0 4
89504: PPUSH
89505: CALL_OW 257
89509: PUSH
89510: LD_INT 1
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: LD_INT 3
89518: PUSH
89519: LD_INT 4
89521: PUSH
89522: EMPTY
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: IN
89528: AND
89529: IFFALSE 89566
// begin class := AllowSpecClass ( i ) ;
89531: LD_ADDR_VAR 0 20
89535: PUSH
89536: LD_VAR 0 4
89540: PPUSH
89541: CALL 12801 0 1
89545: ST_TO_ADDR
// if class then
89546: LD_VAR 0 20
89550: IFFALSE 89566
// ComChangeProfession ( i , class ) ;
89552: LD_VAR 0 4
89556: PPUSH
89557: LD_VAR 0 20
89561: PPUSH
89562: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89566: LD_VAR 0 16
89570: PUSH
89571: LD_VAR 0 2
89575: PPUSH
89576: LD_INT 21
89578: PUSH
89579: LD_INT 2
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PPUSH
89586: CALL_OW 72
89590: PUSH
89591: LD_INT 1
89593: LESSEQUAL
89594: OR
89595: PUSH
89596: LD_VAR 0 19
89600: AND
89601: PUSH
89602: LD_VAR 0 4
89606: PUSH
89607: LD_VAR 0 17
89611: IN
89612: NOT
89613: AND
89614: IFFALSE 89707
// begin if b then
89616: LD_VAR 0 18
89620: IFFALSE 89669
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89622: LD_VAR 0 18
89626: PPUSH
89627: LD_VAR 0 21
89631: PPUSH
89632: LD_VAR 0 18
89636: PPUSH
89637: CALL_OW 74
89641: PPUSH
89642: CALL_OW 296
89646: PUSH
89647: LD_INT 10
89649: LESS
89650: PUSH
89651: LD_VAR 0 18
89655: PPUSH
89656: CALL_OW 461
89660: PUSH
89661: LD_INT 7
89663: NONEQUAL
89664: AND
89665: IFFALSE 89669
// continue ;
89667: GO 88904
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89669: LD_ADDR_VAR 0 17
89673: PUSH
89674: LD_VAR 0 17
89678: PPUSH
89679: LD_VAR 0 17
89683: PUSH
89684: LD_INT 1
89686: PLUS
89687: PPUSH
89688: LD_VAR 0 4
89692: PPUSH
89693: CALL_OW 1
89697: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89698: LD_VAR 0 4
89702: PPUSH
89703: CALL_OW 122
// end ; if sold_defenders then
89707: LD_VAR 0 17
89711: IFFALSE 89771
// if i in sold_defenders then
89713: LD_VAR 0 4
89717: PUSH
89718: LD_VAR 0 17
89722: IN
89723: IFFALSE 89771
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89725: LD_VAR 0 4
89729: PPUSH
89730: CALL_OW 314
89734: NOT
89735: PUSH
89736: LD_VAR 0 4
89740: PPUSH
89741: LD_VAR 0 13
89745: PPUSH
89746: CALL_OW 296
89750: PUSH
89751: LD_INT 30
89753: LESS
89754: AND
89755: IFFALSE 89771
// ComAttackUnit ( i , e ) ;
89757: LD_VAR 0 4
89761: PPUSH
89762: LD_VAR 0 13
89766: PPUSH
89767: CALL_OW 115
// end ; end ; end ;
89771: GO 89774
89773: POP
// if IsDead ( i ) then
89774: LD_VAR 0 4
89778: PPUSH
89779: CALL_OW 301
89783: IFFALSE 89801
// defenders := defenders diff i ;
89785: LD_ADDR_VAR 0 2
89789: PUSH
89790: LD_VAR 0 2
89794: PUSH
89795: LD_VAR 0 4
89799: DIFF
89800: ST_TO_ADDR
// end ;
89801: GO 88904
89803: POP
89804: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89805: LD_VAR 0 21
89809: NOT
89810: PUSH
89811: LD_VAR 0 2
89815: NOT
89816: OR
89817: PUSH
89818: LD_EXP 23
89822: PUSH
89823: LD_VAR 0 1
89827: ARRAY
89828: NOT
89829: OR
89830: IFFALSE 88808
// MC_Reset ( base , 18 ) ;
89832: LD_VAR 0 1
89836: PPUSH
89837: LD_INT 18
89839: PPUSH
89840: CALL 56544 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89844: LD_ADDR_VAR 0 2
89848: PUSH
89849: LD_VAR 0 2
89853: PUSH
89854: LD_VAR 0 2
89858: PPUSH
89859: LD_INT 2
89861: PUSH
89862: LD_INT 25
89864: PUSH
89865: LD_INT 1
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 25
89874: PUSH
89875: LD_INT 5
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 25
89884: PUSH
89885: LD_INT 8
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 25
89894: PUSH
89895: LD_INT 9
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: PPUSH
89909: CALL_OW 72
89913: DIFF
89914: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89915: LD_VAR 0 21
89919: NOT
89920: PUSH
89921: LD_VAR 0 2
89925: PPUSH
89926: LD_INT 21
89928: PUSH
89929: LD_INT 2
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PPUSH
89936: CALL_OW 72
89940: AND
89941: IFFALSE 90279
// begin tmp := FilterByTag ( defenders , 19 ) ;
89943: LD_ADDR_VAR 0 11
89947: PUSH
89948: LD_VAR 0 2
89952: PPUSH
89953: LD_INT 19
89955: PPUSH
89956: CALL 46038 0 2
89960: ST_TO_ADDR
// if tmp then
89961: LD_VAR 0 11
89965: IFFALSE 90035
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89967: LD_ADDR_VAR 0 11
89971: PUSH
89972: LD_VAR 0 11
89976: PPUSH
89977: LD_INT 25
89979: PUSH
89980: LD_INT 3
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PPUSH
89987: CALL_OW 72
89991: ST_TO_ADDR
// if tmp then
89992: LD_VAR 0 11
89996: IFFALSE 90035
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89998: LD_ADDR_EXP 35
90002: PUSH
90003: LD_EXP 35
90007: PPUSH
90008: LD_VAR 0 1
90012: PPUSH
90013: LD_EXP 35
90017: PUSH
90018: LD_VAR 0 1
90022: ARRAY
90023: PUSH
90024: LD_VAR 0 11
90028: UNION
90029: PPUSH
90030: CALL_OW 1
90034: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90035: LD_VAR 0 1
90039: PPUSH
90040: LD_INT 19
90042: PPUSH
90043: CALL 56544 0 2
// repeat wait ( 0 0$1 ) ;
90047: LD_INT 35
90049: PPUSH
90050: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90054: LD_EXP 23
90058: PUSH
90059: LD_VAR 0 1
90063: ARRAY
90064: NOT
90065: PUSH
90066: LD_EXP 23
90070: PUSH
90071: LD_VAR 0 1
90075: ARRAY
90076: PUSH
90077: EMPTY
90078: EQUAL
90079: OR
90080: IFFALSE 90117
// begin for i in defenders do
90082: LD_ADDR_VAR 0 4
90086: PUSH
90087: LD_VAR 0 2
90091: PUSH
90092: FOR_IN
90093: IFFALSE 90106
// ComStop ( i ) ;
90095: LD_VAR 0 4
90099: PPUSH
90100: CALL_OW 141
90104: GO 90092
90106: POP
90107: POP
// defenders := [ ] ;
90108: LD_ADDR_VAR 0 2
90112: PUSH
90113: EMPTY
90114: ST_TO_ADDR
// exit ;
90115: GO 90343
// end ; for i in defenders do
90117: LD_ADDR_VAR 0 4
90121: PUSH
90122: LD_VAR 0 2
90126: PUSH
90127: FOR_IN
90128: IFFALSE 90217
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90130: LD_VAR 0 4
90134: PPUSH
90135: LD_EXP 47
90139: PUSH
90140: LD_VAR 0 1
90144: ARRAY
90145: PPUSH
90146: CALL_OW 308
90150: NOT
90151: IFFALSE 90175
// ComMoveToArea ( i , mc_parking [ base ] ) else
90153: LD_VAR 0 4
90157: PPUSH
90158: LD_EXP 47
90162: PUSH
90163: LD_VAR 0 1
90167: ARRAY
90168: PPUSH
90169: CALL_OW 113
90173: GO 90215
// if GetControl ( i ) = control_manual then
90175: LD_VAR 0 4
90179: PPUSH
90180: CALL_OW 263
90184: PUSH
90185: LD_INT 1
90187: EQUAL
90188: IFFALSE 90215
// if IsDrivenBy ( i ) then
90190: LD_VAR 0 4
90194: PPUSH
90195: CALL_OW 311
90199: IFFALSE 90215
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90201: LD_VAR 0 4
90205: PPUSH
90206: CALL_OW 311
90210: PPUSH
90211: CALL_OW 121
// end ;
90215: GO 90127
90217: POP
90218: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90219: LD_VAR 0 2
90223: PPUSH
90224: LD_INT 95
90226: PUSH
90227: LD_EXP 47
90231: PUSH
90232: LD_VAR 0 1
90236: ARRAY
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: PPUSH
90242: CALL_OW 72
90246: PUSH
90247: LD_VAR 0 2
90251: EQUAL
90252: PUSH
90253: LD_EXP 46
90257: PUSH
90258: LD_VAR 0 1
90262: ARRAY
90263: OR
90264: PUSH
90265: LD_EXP 23
90269: PUSH
90270: LD_VAR 0 1
90274: ARRAY
90275: NOT
90276: OR
90277: IFFALSE 90047
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90279: LD_ADDR_EXP 45
90283: PUSH
90284: LD_EXP 45
90288: PPUSH
90289: LD_VAR 0 1
90293: PPUSH
90294: LD_VAR 0 2
90298: PPUSH
90299: LD_INT 21
90301: PUSH
90302: LD_INT 2
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PPUSH
90309: CALL_OW 72
90313: PPUSH
90314: CALL_OW 1
90318: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90319: LD_VAR 0 1
90323: PPUSH
90324: LD_INT 19
90326: PPUSH
90327: CALL 56544 0 2
// MC_Reset ( base , 20 ) ;
90331: LD_VAR 0 1
90335: PPUSH
90336: LD_INT 20
90338: PPUSH
90339: CALL 56544 0 2
// end ; end_of_file
90343: LD_VAR 0 3
90347: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90348: LD_INT 0
90350: PPUSH
90351: PPUSH
90352: PPUSH
90353: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90354: LD_VAR 0 1
90358: PPUSH
90359: CALL_OW 264
90363: PUSH
90364: LD_INT 91
90366: EQUAL
90367: IFFALSE 90439
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90369: LD_INT 68
90371: PPUSH
90372: LD_VAR 0 1
90376: PPUSH
90377: CALL_OW 255
90381: PPUSH
90382: CALL_OW 321
90386: PUSH
90387: LD_INT 2
90389: EQUAL
90390: IFFALSE 90402
// eff := 70 else
90392: LD_ADDR_VAR 0 4
90396: PUSH
90397: LD_INT 70
90399: ST_TO_ADDR
90400: GO 90410
// eff := 30 ;
90402: LD_ADDR_VAR 0 4
90406: PUSH
90407: LD_INT 30
90409: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90410: LD_VAR 0 1
90414: PPUSH
90415: CALL_OW 250
90419: PPUSH
90420: LD_VAR 0 1
90424: PPUSH
90425: CALL_OW 251
90429: PPUSH
90430: LD_VAR 0 4
90434: PPUSH
90435: CALL_OW 495
// end ; end ;
90439: LD_VAR 0 2
90443: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90444: LD_INT 0
90446: PPUSH
// end ;
90447: LD_VAR 0 4
90451: RET
// export function SOS_Command ( cmd ) ; begin
90452: LD_INT 0
90454: PPUSH
// end ;
90455: LD_VAR 0 2
90459: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90460: LD_INT 0
90462: PPUSH
// end ;
90463: LD_VAR 0 6
90467: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90468: LD_INT 0
90470: PPUSH
90471: PPUSH
// if not vehicle or not factory then
90472: LD_VAR 0 1
90476: NOT
90477: PUSH
90478: LD_VAR 0 2
90482: NOT
90483: OR
90484: IFFALSE 90488
// exit ;
90486: GO 90719
// if factoryWaypoints >= factory then
90488: LD_EXP 135
90492: PUSH
90493: LD_VAR 0 2
90497: GREATEREQUAL
90498: IFFALSE 90719
// if factoryWaypoints [ factory ] then
90500: LD_EXP 135
90504: PUSH
90505: LD_VAR 0 2
90509: ARRAY
90510: IFFALSE 90719
// begin if GetControl ( vehicle ) = control_manual then
90512: LD_VAR 0 1
90516: PPUSH
90517: CALL_OW 263
90521: PUSH
90522: LD_INT 1
90524: EQUAL
90525: IFFALSE 90606
// begin driver := IsDrivenBy ( vehicle ) ;
90527: LD_ADDR_VAR 0 4
90531: PUSH
90532: LD_VAR 0 1
90536: PPUSH
90537: CALL_OW 311
90541: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90542: LD_VAR 0 4
90546: PPUSH
90547: LD_EXP 135
90551: PUSH
90552: LD_VAR 0 2
90556: ARRAY
90557: PUSH
90558: LD_INT 3
90560: ARRAY
90561: PPUSH
90562: LD_EXP 135
90566: PUSH
90567: LD_VAR 0 2
90571: ARRAY
90572: PUSH
90573: LD_INT 4
90575: ARRAY
90576: PPUSH
90577: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90581: LD_VAR 0 4
90585: PPUSH
90586: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90590: LD_VAR 0 4
90594: PPUSH
90595: LD_VAR 0 2
90599: PPUSH
90600: CALL_OW 180
// end else
90604: GO 90719
// if GetControl ( vehicle ) = control_remote then
90606: LD_VAR 0 1
90610: PPUSH
90611: CALL_OW 263
90615: PUSH
90616: LD_INT 2
90618: EQUAL
90619: IFFALSE 90680
// begin wait ( 0 0$2 ) ;
90621: LD_INT 70
90623: PPUSH
90624: CALL_OW 67
// if Connect ( vehicle ) then
90628: LD_VAR 0 1
90632: PPUSH
90633: CALL 19121 0 1
90637: IFFALSE 90678
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90639: LD_VAR 0 1
90643: PPUSH
90644: LD_EXP 135
90648: PUSH
90649: LD_VAR 0 2
90653: ARRAY
90654: PUSH
90655: LD_INT 3
90657: ARRAY
90658: PPUSH
90659: LD_EXP 135
90663: PUSH
90664: LD_VAR 0 2
90668: ARRAY
90669: PUSH
90670: LD_INT 4
90672: ARRAY
90673: PPUSH
90674: CALL_OW 171
// end else
90678: GO 90719
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90680: LD_VAR 0 1
90684: PPUSH
90685: LD_EXP 135
90689: PUSH
90690: LD_VAR 0 2
90694: ARRAY
90695: PUSH
90696: LD_INT 3
90698: ARRAY
90699: PPUSH
90700: LD_EXP 135
90704: PUSH
90705: LD_VAR 0 2
90709: ARRAY
90710: PUSH
90711: LD_INT 4
90713: ARRAY
90714: PPUSH
90715: CALL_OW 171
// end ; end ;
90719: LD_VAR 0 3
90723: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90724: LD_INT 0
90726: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90727: LD_VAR 0 1
90731: PUSH
90732: LD_INT 250
90734: EQUAL
90735: PUSH
90736: LD_VAR 0 2
90740: PPUSH
90741: CALL_OW 264
90745: PUSH
90746: LD_INT 81
90748: EQUAL
90749: AND
90750: IFFALSE 90771
// MinerPlaceMine ( unit , x , y ) ;
90752: LD_VAR 0 2
90756: PPUSH
90757: LD_VAR 0 4
90761: PPUSH
90762: LD_VAR 0 5
90766: PPUSH
90767: CALL 93156 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90771: LD_VAR 0 1
90775: PUSH
90776: LD_INT 251
90778: EQUAL
90779: PUSH
90780: LD_VAR 0 2
90784: PPUSH
90785: CALL_OW 264
90789: PUSH
90790: LD_INT 81
90792: EQUAL
90793: AND
90794: IFFALSE 90815
// MinerDetonateMine ( unit , x , y ) ;
90796: LD_VAR 0 2
90800: PPUSH
90801: LD_VAR 0 4
90805: PPUSH
90806: LD_VAR 0 5
90810: PPUSH
90811: CALL 93431 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90815: LD_VAR 0 1
90819: PUSH
90820: LD_INT 252
90822: EQUAL
90823: PUSH
90824: LD_VAR 0 2
90828: PPUSH
90829: CALL_OW 264
90833: PUSH
90834: LD_INT 81
90836: EQUAL
90837: AND
90838: IFFALSE 90859
// MinerCreateMinefield ( unit , x , y ) ;
90840: LD_VAR 0 2
90844: PPUSH
90845: LD_VAR 0 4
90849: PPUSH
90850: LD_VAR 0 5
90854: PPUSH
90855: CALL 93848 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90859: LD_VAR 0 1
90863: PUSH
90864: LD_INT 253
90866: EQUAL
90867: PUSH
90868: LD_VAR 0 2
90872: PPUSH
90873: CALL_OW 257
90877: PUSH
90878: LD_INT 5
90880: EQUAL
90881: AND
90882: IFFALSE 90903
// ComBinocular ( unit , x , y ) ;
90884: LD_VAR 0 2
90888: PPUSH
90889: LD_VAR 0 4
90893: PPUSH
90894: LD_VAR 0 5
90898: PPUSH
90899: CALL 94217 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90903: LD_VAR 0 1
90907: PUSH
90908: LD_INT 254
90910: EQUAL
90911: PUSH
90912: LD_VAR 0 2
90916: PPUSH
90917: CALL_OW 264
90921: PUSH
90922: LD_INT 99
90924: EQUAL
90925: AND
90926: PUSH
90927: LD_VAR 0 3
90931: PPUSH
90932: CALL_OW 263
90936: PUSH
90937: LD_INT 3
90939: EQUAL
90940: AND
90941: IFFALSE 90957
// HackDestroyVehicle ( unit , selectedUnit ) ;
90943: LD_VAR 0 2
90947: PPUSH
90948: LD_VAR 0 3
90952: PPUSH
90953: CALL 92520 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90957: LD_VAR 0 1
90961: PUSH
90962: LD_INT 255
90964: EQUAL
90965: PUSH
90966: LD_VAR 0 2
90970: PPUSH
90971: CALL_OW 264
90975: PUSH
90976: LD_INT 14
90978: PUSH
90979: LD_INT 53
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: IN
90986: AND
90987: PUSH
90988: LD_VAR 0 4
90992: PPUSH
90993: LD_VAR 0 5
90997: PPUSH
90998: CALL_OW 488
91002: AND
91003: IFFALSE 91027
// CutTreeXYR ( unit , x , y , 12 ) ;
91005: LD_VAR 0 2
91009: PPUSH
91010: LD_VAR 0 4
91014: PPUSH
91015: LD_VAR 0 5
91019: PPUSH
91020: LD_INT 12
91022: PPUSH
91023: CALL 91090 0 4
// if cmd = 256 then
91027: LD_VAR 0 1
91031: PUSH
91032: LD_INT 256
91034: EQUAL
91035: IFFALSE 91056
// SetFactoryWaypoint ( unit , x , y ) ;
91037: LD_VAR 0 2
91041: PPUSH
91042: LD_VAR 0 4
91046: PPUSH
91047: LD_VAR 0 5
91051: PPUSH
91052: CALL 109138 0 3
// if cmd = 257 then
91056: LD_VAR 0 1
91060: PUSH
91061: LD_INT 257
91063: EQUAL
91064: IFFALSE 91085
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91066: LD_VAR 0 2
91070: PPUSH
91071: LD_VAR 0 4
91075: PPUSH
91076: LD_VAR 0 5
91080: PPUSH
91081: CALL 109500 0 3
// end ;
91085: LD_VAR 0 6
91089: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91090: LD_INT 0
91092: PPUSH
91093: PPUSH
91094: PPUSH
91095: PPUSH
91096: PPUSH
91097: PPUSH
91098: PPUSH
91099: PPUSH
91100: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91101: LD_VAR 0 1
91105: NOT
91106: PUSH
91107: LD_VAR 0 2
91111: PPUSH
91112: LD_VAR 0 3
91116: PPUSH
91117: CALL_OW 488
91121: NOT
91122: OR
91123: PUSH
91124: LD_VAR 0 4
91128: NOT
91129: OR
91130: IFFALSE 91134
// exit ;
91132: GO 91474
// list := [ ] ;
91134: LD_ADDR_VAR 0 13
91138: PUSH
91139: EMPTY
91140: ST_TO_ADDR
// if x - r < 0 then
91141: LD_VAR 0 2
91145: PUSH
91146: LD_VAR 0 4
91150: MINUS
91151: PUSH
91152: LD_INT 0
91154: LESS
91155: IFFALSE 91167
// min_x := 0 else
91157: LD_ADDR_VAR 0 7
91161: PUSH
91162: LD_INT 0
91164: ST_TO_ADDR
91165: GO 91183
// min_x := x - r ;
91167: LD_ADDR_VAR 0 7
91171: PUSH
91172: LD_VAR 0 2
91176: PUSH
91177: LD_VAR 0 4
91181: MINUS
91182: ST_TO_ADDR
// if y - r < 0 then
91183: LD_VAR 0 3
91187: PUSH
91188: LD_VAR 0 4
91192: MINUS
91193: PUSH
91194: LD_INT 0
91196: LESS
91197: IFFALSE 91209
// min_y := 0 else
91199: LD_ADDR_VAR 0 8
91203: PUSH
91204: LD_INT 0
91206: ST_TO_ADDR
91207: GO 91225
// min_y := y - r ;
91209: LD_ADDR_VAR 0 8
91213: PUSH
91214: LD_VAR 0 3
91218: PUSH
91219: LD_VAR 0 4
91223: MINUS
91224: ST_TO_ADDR
// max_x := x + r ;
91225: LD_ADDR_VAR 0 9
91229: PUSH
91230: LD_VAR 0 2
91234: PUSH
91235: LD_VAR 0 4
91239: PLUS
91240: ST_TO_ADDR
// max_y := y + r ;
91241: LD_ADDR_VAR 0 10
91245: PUSH
91246: LD_VAR 0 3
91250: PUSH
91251: LD_VAR 0 4
91255: PLUS
91256: ST_TO_ADDR
// for _x = min_x to max_x do
91257: LD_ADDR_VAR 0 11
91261: PUSH
91262: DOUBLE
91263: LD_VAR 0 7
91267: DEC
91268: ST_TO_ADDR
91269: LD_VAR 0 9
91273: PUSH
91274: FOR_TO
91275: IFFALSE 91392
// for _y = min_y to max_y do
91277: LD_ADDR_VAR 0 12
91281: PUSH
91282: DOUBLE
91283: LD_VAR 0 8
91287: DEC
91288: ST_TO_ADDR
91289: LD_VAR 0 10
91293: PUSH
91294: FOR_TO
91295: IFFALSE 91388
// begin if not ValidHex ( _x , _y ) then
91297: LD_VAR 0 11
91301: PPUSH
91302: LD_VAR 0 12
91306: PPUSH
91307: CALL_OW 488
91311: NOT
91312: IFFALSE 91316
// continue ;
91314: GO 91294
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91316: LD_VAR 0 11
91320: PPUSH
91321: LD_VAR 0 12
91325: PPUSH
91326: CALL_OW 351
91330: PUSH
91331: LD_VAR 0 11
91335: PPUSH
91336: LD_VAR 0 12
91340: PPUSH
91341: CALL_OW 554
91345: AND
91346: IFFALSE 91386
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91348: LD_ADDR_VAR 0 13
91352: PUSH
91353: LD_VAR 0 13
91357: PPUSH
91358: LD_VAR 0 13
91362: PUSH
91363: LD_INT 1
91365: PLUS
91366: PPUSH
91367: LD_VAR 0 11
91371: PUSH
91372: LD_VAR 0 12
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PPUSH
91381: CALL_OW 2
91385: ST_TO_ADDR
// end ;
91386: GO 91294
91388: POP
91389: POP
91390: GO 91274
91392: POP
91393: POP
// if not list then
91394: LD_VAR 0 13
91398: NOT
91399: IFFALSE 91403
// exit ;
91401: GO 91474
// for i in list do
91403: LD_ADDR_VAR 0 6
91407: PUSH
91408: LD_VAR 0 13
91412: PUSH
91413: FOR_IN
91414: IFFALSE 91472
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91416: LD_VAR 0 1
91420: PPUSH
91421: LD_STRING M
91423: PUSH
91424: LD_VAR 0 6
91428: PUSH
91429: LD_INT 1
91431: ARRAY
91432: PUSH
91433: LD_VAR 0 6
91437: PUSH
91438: LD_INT 2
91440: ARRAY
91441: PUSH
91442: LD_INT 0
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 0
91450: PUSH
91451: LD_INT 0
91453: PUSH
91454: EMPTY
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: PUSH
91463: EMPTY
91464: LIST
91465: PPUSH
91466: CALL_OW 447
91470: GO 91413
91472: POP
91473: POP
// end ;
91474: LD_VAR 0 5
91478: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91479: LD_EXP 67
91483: NOT
91484: IFFALSE 91534
91486: GO 91488
91488: DISABLE
// begin initHack := true ;
91489: LD_ADDR_EXP 67
91493: PUSH
91494: LD_INT 1
91496: ST_TO_ADDR
// hackTanks := [ ] ;
91497: LD_ADDR_EXP 68
91501: PUSH
91502: EMPTY
91503: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91504: LD_ADDR_EXP 69
91508: PUSH
91509: EMPTY
91510: ST_TO_ADDR
// hackLimit := 3 ;
91511: LD_ADDR_EXP 70
91515: PUSH
91516: LD_INT 3
91518: ST_TO_ADDR
// hackDist := 12 ;
91519: LD_ADDR_EXP 71
91523: PUSH
91524: LD_INT 12
91526: ST_TO_ADDR
// hackCounter := [ ] ;
91527: LD_ADDR_EXP 72
91531: PUSH
91532: EMPTY
91533: ST_TO_ADDR
// end ;
91534: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91535: LD_EXP 67
91539: PUSH
91540: LD_INT 34
91542: PUSH
91543: LD_INT 99
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PPUSH
91550: CALL_OW 69
91554: AND
91555: IFFALSE 91808
91557: GO 91559
91559: DISABLE
91560: LD_INT 0
91562: PPUSH
91563: PPUSH
// begin enable ;
91564: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91565: LD_ADDR_VAR 0 1
91569: PUSH
91570: LD_INT 34
91572: PUSH
91573: LD_INT 99
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: PPUSH
91580: CALL_OW 69
91584: PUSH
91585: FOR_IN
91586: IFFALSE 91806
// begin if not i in hackTanks then
91588: LD_VAR 0 1
91592: PUSH
91593: LD_EXP 68
91597: IN
91598: NOT
91599: IFFALSE 91682
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91601: LD_ADDR_EXP 68
91605: PUSH
91606: LD_EXP 68
91610: PPUSH
91611: LD_EXP 68
91615: PUSH
91616: LD_INT 1
91618: PLUS
91619: PPUSH
91620: LD_VAR 0 1
91624: PPUSH
91625: CALL_OW 1
91629: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91630: LD_ADDR_EXP 69
91634: PUSH
91635: LD_EXP 69
91639: PPUSH
91640: LD_EXP 69
91644: PUSH
91645: LD_INT 1
91647: PLUS
91648: PPUSH
91649: EMPTY
91650: PPUSH
91651: CALL_OW 1
91655: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91656: LD_ADDR_EXP 72
91660: PUSH
91661: LD_EXP 72
91665: PPUSH
91666: LD_EXP 72
91670: PUSH
91671: LD_INT 1
91673: PLUS
91674: PPUSH
91675: EMPTY
91676: PPUSH
91677: CALL_OW 1
91681: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91682: LD_VAR 0 1
91686: PPUSH
91687: CALL_OW 302
91691: NOT
91692: IFFALSE 91705
// begin HackUnlinkAll ( i ) ;
91694: LD_VAR 0 1
91698: PPUSH
91699: CALL 91811 0 1
// continue ;
91703: GO 91585
// end ; HackCheckCapturedStatus ( i ) ;
91705: LD_VAR 0 1
91709: PPUSH
91710: CALL 92254 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91714: LD_ADDR_VAR 0 2
91718: PUSH
91719: LD_INT 81
91721: PUSH
91722: LD_VAR 0 1
91726: PPUSH
91727: CALL_OW 255
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 33
91738: PUSH
91739: LD_INT 3
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 91
91748: PUSH
91749: LD_VAR 0 1
91753: PUSH
91754: LD_EXP 71
91758: PUSH
91759: EMPTY
91760: LIST
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 50
91766: PUSH
91767: EMPTY
91768: LIST
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: PPUSH
91776: CALL_OW 69
91780: ST_TO_ADDR
// if not tmp then
91781: LD_VAR 0 2
91785: NOT
91786: IFFALSE 91790
// continue ;
91788: GO 91585
// HackLink ( i , tmp ) ;
91790: LD_VAR 0 1
91794: PPUSH
91795: LD_VAR 0 2
91799: PPUSH
91800: CALL 91947 0 2
// end ;
91804: GO 91585
91806: POP
91807: POP
// end ;
91808: PPOPN 2
91810: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91811: LD_INT 0
91813: PPUSH
91814: PPUSH
91815: PPUSH
// if not hack in hackTanks then
91816: LD_VAR 0 1
91820: PUSH
91821: LD_EXP 68
91825: IN
91826: NOT
91827: IFFALSE 91831
// exit ;
91829: GO 91942
// index := GetElementIndex ( hackTanks , hack ) ;
91831: LD_ADDR_VAR 0 4
91835: PUSH
91836: LD_EXP 68
91840: PPUSH
91841: LD_VAR 0 1
91845: PPUSH
91846: CALL 15937 0 2
91850: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91851: LD_EXP 69
91855: PUSH
91856: LD_VAR 0 4
91860: ARRAY
91861: IFFALSE 91942
// begin for i in hackTanksCaptured [ index ] do
91863: LD_ADDR_VAR 0 3
91867: PUSH
91868: LD_EXP 69
91872: PUSH
91873: LD_VAR 0 4
91877: ARRAY
91878: PUSH
91879: FOR_IN
91880: IFFALSE 91906
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91882: LD_VAR 0 3
91886: PUSH
91887: LD_INT 1
91889: ARRAY
91890: PPUSH
91891: LD_VAR 0 3
91895: PUSH
91896: LD_INT 2
91898: ARRAY
91899: PPUSH
91900: CALL_OW 235
91904: GO 91879
91906: POP
91907: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91908: LD_ADDR_EXP 69
91912: PUSH
91913: LD_EXP 69
91917: PPUSH
91918: LD_VAR 0 4
91922: PPUSH
91923: EMPTY
91924: PPUSH
91925: CALL_OW 1
91929: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91930: LD_VAR 0 1
91934: PPUSH
91935: LD_INT 0
91937: PPUSH
91938: CALL_OW 505
// end ; end ;
91942: LD_VAR 0 2
91946: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91947: LD_INT 0
91949: PPUSH
91950: PPUSH
91951: PPUSH
// if not hack in hackTanks or not vehicles then
91952: LD_VAR 0 1
91956: PUSH
91957: LD_EXP 68
91961: IN
91962: NOT
91963: PUSH
91964: LD_VAR 0 2
91968: NOT
91969: OR
91970: IFFALSE 91974
// exit ;
91972: GO 92249
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91974: LD_ADDR_VAR 0 2
91978: PUSH
91979: LD_VAR 0 1
91983: PPUSH
91984: LD_VAR 0 2
91988: PPUSH
91989: LD_INT 1
91991: PPUSH
91992: LD_INT 1
91994: PPUSH
91995: CALL 16587 0 4
91999: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
92000: LD_ADDR_VAR 0 5
92004: PUSH
92005: LD_EXP 68
92009: PPUSH
92010: LD_VAR 0 1
92014: PPUSH
92015: CALL 15937 0 2
92019: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
92020: LD_EXP 69
92024: PUSH
92025: LD_VAR 0 5
92029: ARRAY
92030: PUSH
92031: LD_EXP 70
92035: LESS
92036: IFFALSE 92225
// begin for i := 1 to vehicles do
92038: LD_ADDR_VAR 0 4
92042: PUSH
92043: DOUBLE
92044: LD_INT 1
92046: DEC
92047: ST_TO_ADDR
92048: LD_VAR 0 2
92052: PUSH
92053: FOR_TO
92054: IFFALSE 92223
// begin if hackTanksCaptured [ index ] = hackLimit then
92056: LD_EXP 69
92060: PUSH
92061: LD_VAR 0 5
92065: ARRAY
92066: PUSH
92067: LD_EXP 70
92071: EQUAL
92072: IFFALSE 92076
// break ;
92074: GO 92223
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
92076: LD_ADDR_EXP 72
92080: PUSH
92081: LD_EXP 72
92085: PPUSH
92086: LD_VAR 0 5
92090: PPUSH
92091: LD_EXP 72
92095: PUSH
92096: LD_VAR 0 5
92100: ARRAY
92101: PUSH
92102: LD_INT 1
92104: PLUS
92105: PPUSH
92106: CALL_OW 1
92110: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92111: LD_ADDR_EXP 69
92115: PUSH
92116: LD_EXP 69
92120: PPUSH
92121: LD_VAR 0 5
92125: PUSH
92126: LD_EXP 69
92130: PUSH
92131: LD_VAR 0 5
92135: ARRAY
92136: PUSH
92137: LD_INT 1
92139: PLUS
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PPUSH
92145: LD_VAR 0 2
92149: PUSH
92150: LD_VAR 0 4
92154: ARRAY
92155: PUSH
92156: LD_VAR 0 2
92160: PUSH
92161: LD_VAR 0 4
92165: ARRAY
92166: PPUSH
92167: CALL_OW 255
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PPUSH
92176: CALL 16152 0 3
92180: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92181: LD_VAR 0 2
92185: PUSH
92186: LD_VAR 0 4
92190: ARRAY
92191: PPUSH
92192: LD_VAR 0 1
92196: PPUSH
92197: CALL_OW 255
92201: PPUSH
92202: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92206: LD_VAR 0 2
92210: PUSH
92211: LD_VAR 0 4
92215: ARRAY
92216: PPUSH
92217: CALL_OW 141
// end ;
92221: GO 92053
92223: POP
92224: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92225: LD_VAR 0 1
92229: PPUSH
92230: LD_EXP 69
92234: PUSH
92235: LD_VAR 0 5
92239: ARRAY
92240: PUSH
92241: LD_INT 0
92243: PLUS
92244: PPUSH
92245: CALL_OW 505
// end ;
92249: LD_VAR 0 3
92253: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92254: LD_INT 0
92256: PPUSH
92257: PPUSH
92258: PPUSH
92259: PPUSH
// if not hack in hackTanks then
92260: LD_VAR 0 1
92264: PUSH
92265: LD_EXP 68
92269: IN
92270: NOT
92271: IFFALSE 92275
// exit ;
92273: GO 92515
// index := GetElementIndex ( hackTanks , hack ) ;
92275: LD_ADDR_VAR 0 4
92279: PUSH
92280: LD_EXP 68
92284: PPUSH
92285: LD_VAR 0 1
92289: PPUSH
92290: CALL 15937 0 2
92294: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92295: LD_ADDR_VAR 0 3
92299: PUSH
92300: DOUBLE
92301: LD_EXP 69
92305: PUSH
92306: LD_VAR 0 4
92310: ARRAY
92311: INC
92312: ST_TO_ADDR
92313: LD_INT 1
92315: PUSH
92316: FOR_DOWNTO
92317: IFFALSE 92489
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92319: LD_ADDR_VAR 0 5
92323: PUSH
92324: LD_EXP 69
92328: PUSH
92329: LD_VAR 0 4
92333: ARRAY
92334: PUSH
92335: LD_VAR 0 3
92339: ARRAY
92340: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92341: LD_VAR 0 5
92345: PUSH
92346: LD_INT 1
92348: ARRAY
92349: PPUSH
92350: CALL_OW 302
92354: NOT
92355: PUSH
92356: LD_VAR 0 5
92360: PUSH
92361: LD_INT 1
92363: ARRAY
92364: PPUSH
92365: CALL_OW 255
92369: PUSH
92370: LD_VAR 0 1
92374: PPUSH
92375: CALL_OW 255
92379: NONEQUAL
92380: OR
92381: IFFALSE 92487
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92383: LD_VAR 0 5
92387: PUSH
92388: LD_INT 1
92390: ARRAY
92391: PPUSH
92392: CALL_OW 305
92396: PUSH
92397: LD_VAR 0 5
92401: PUSH
92402: LD_INT 1
92404: ARRAY
92405: PPUSH
92406: CALL_OW 255
92410: PUSH
92411: LD_VAR 0 1
92415: PPUSH
92416: CALL_OW 255
92420: EQUAL
92421: AND
92422: IFFALSE 92446
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92424: LD_VAR 0 5
92428: PUSH
92429: LD_INT 1
92431: ARRAY
92432: PPUSH
92433: LD_VAR 0 5
92437: PUSH
92438: LD_INT 2
92440: ARRAY
92441: PPUSH
92442: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92446: LD_ADDR_EXP 69
92450: PUSH
92451: LD_EXP 69
92455: PPUSH
92456: LD_VAR 0 4
92460: PPUSH
92461: LD_EXP 69
92465: PUSH
92466: LD_VAR 0 4
92470: ARRAY
92471: PPUSH
92472: LD_VAR 0 3
92476: PPUSH
92477: CALL_OW 3
92481: PPUSH
92482: CALL_OW 1
92486: ST_TO_ADDR
// end ; end ;
92487: GO 92316
92489: POP
92490: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92491: LD_VAR 0 1
92495: PPUSH
92496: LD_EXP 69
92500: PUSH
92501: LD_VAR 0 4
92505: ARRAY
92506: PUSH
92507: LD_INT 0
92509: PLUS
92510: PPUSH
92511: CALL_OW 505
// end ;
92515: LD_VAR 0 2
92519: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92520: LD_INT 0
92522: PPUSH
92523: PPUSH
92524: PPUSH
92525: PPUSH
// if not hack in hackTanks then
92526: LD_VAR 0 1
92530: PUSH
92531: LD_EXP 68
92535: IN
92536: NOT
92537: IFFALSE 92541
// exit ;
92539: GO 92626
// index := GetElementIndex ( hackTanks , hack ) ;
92541: LD_ADDR_VAR 0 5
92545: PUSH
92546: LD_EXP 68
92550: PPUSH
92551: LD_VAR 0 1
92555: PPUSH
92556: CALL 15937 0 2
92560: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92561: LD_ADDR_VAR 0 4
92565: PUSH
92566: DOUBLE
92567: LD_INT 1
92569: DEC
92570: ST_TO_ADDR
92571: LD_EXP 69
92575: PUSH
92576: LD_VAR 0 5
92580: ARRAY
92581: PUSH
92582: FOR_TO
92583: IFFALSE 92624
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92585: LD_EXP 69
92589: PUSH
92590: LD_VAR 0 5
92594: ARRAY
92595: PUSH
92596: LD_VAR 0 4
92600: ARRAY
92601: PUSH
92602: LD_INT 1
92604: ARRAY
92605: PUSH
92606: LD_VAR 0 2
92610: EQUAL
92611: IFFALSE 92622
// KillUnit ( vehicle ) ;
92613: LD_VAR 0 2
92617: PPUSH
92618: CALL_OW 66
92622: GO 92582
92624: POP
92625: POP
// end ;
92626: LD_VAR 0 3
92630: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92631: LD_EXP 73
92635: NOT
92636: IFFALSE 92671
92638: GO 92640
92640: DISABLE
// begin initMiner := true ;
92641: LD_ADDR_EXP 73
92645: PUSH
92646: LD_INT 1
92648: ST_TO_ADDR
// minersList := [ ] ;
92649: LD_ADDR_EXP 74
92653: PUSH
92654: EMPTY
92655: ST_TO_ADDR
// minerMinesList := [ ] ;
92656: LD_ADDR_EXP 75
92660: PUSH
92661: EMPTY
92662: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92663: LD_ADDR_EXP 76
92667: PUSH
92668: LD_INT 5
92670: ST_TO_ADDR
// end ;
92671: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92672: LD_EXP 73
92676: PUSH
92677: LD_INT 34
92679: PUSH
92680: LD_INT 81
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PPUSH
92687: CALL_OW 69
92691: AND
92692: IFFALSE 93153
92694: GO 92696
92696: DISABLE
92697: LD_INT 0
92699: PPUSH
92700: PPUSH
92701: PPUSH
92702: PPUSH
// begin enable ;
92703: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92704: LD_ADDR_VAR 0 1
92708: PUSH
92709: LD_INT 34
92711: PUSH
92712: LD_INT 81
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PPUSH
92719: CALL_OW 69
92723: PUSH
92724: FOR_IN
92725: IFFALSE 92797
// begin if not i in minersList then
92727: LD_VAR 0 1
92731: PUSH
92732: LD_EXP 74
92736: IN
92737: NOT
92738: IFFALSE 92795
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92740: LD_ADDR_EXP 74
92744: PUSH
92745: LD_EXP 74
92749: PPUSH
92750: LD_EXP 74
92754: PUSH
92755: LD_INT 1
92757: PLUS
92758: PPUSH
92759: LD_VAR 0 1
92763: PPUSH
92764: CALL_OW 1
92768: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92769: LD_ADDR_EXP 75
92773: PUSH
92774: LD_EXP 75
92778: PPUSH
92779: LD_EXP 75
92783: PUSH
92784: LD_INT 1
92786: PLUS
92787: PPUSH
92788: EMPTY
92789: PPUSH
92790: CALL_OW 1
92794: ST_TO_ADDR
// end end ;
92795: GO 92724
92797: POP
92798: POP
// for i := minerMinesList downto 1 do
92799: LD_ADDR_VAR 0 1
92803: PUSH
92804: DOUBLE
92805: LD_EXP 75
92809: INC
92810: ST_TO_ADDR
92811: LD_INT 1
92813: PUSH
92814: FOR_DOWNTO
92815: IFFALSE 93151
// begin if IsLive ( minersList [ i ] ) then
92817: LD_EXP 74
92821: PUSH
92822: LD_VAR 0 1
92826: ARRAY
92827: PPUSH
92828: CALL_OW 300
92832: IFFALSE 92860
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92834: LD_EXP 74
92838: PUSH
92839: LD_VAR 0 1
92843: ARRAY
92844: PPUSH
92845: LD_EXP 75
92849: PUSH
92850: LD_VAR 0 1
92854: ARRAY
92855: PPUSH
92856: CALL_OW 505
// if not minerMinesList [ i ] then
92860: LD_EXP 75
92864: PUSH
92865: LD_VAR 0 1
92869: ARRAY
92870: NOT
92871: IFFALSE 92875
// continue ;
92873: GO 92814
// for j := minerMinesList [ i ] downto 1 do
92875: LD_ADDR_VAR 0 2
92879: PUSH
92880: DOUBLE
92881: LD_EXP 75
92885: PUSH
92886: LD_VAR 0 1
92890: ARRAY
92891: INC
92892: ST_TO_ADDR
92893: LD_INT 1
92895: PUSH
92896: FOR_DOWNTO
92897: IFFALSE 93147
// begin side := GetSide ( minersList [ i ] ) ;
92899: LD_ADDR_VAR 0 3
92903: PUSH
92904: LD_EXP 74
92908: PUSH
92909: LD_VAR 0 1
92913: ARRAY
92914: PPUSH
92915: CALL_OW 255
92919: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92920: LD_ADDR_VAR 0 4
92924: PUSH
92925: LD_EXP 75
92929: PUSH
92930: LD_VAR 0 1
92934: ARRAY
92935: PUSH
92936: LD_VAR 0 2
92940: ARRAY
92941: PUSH
92942: LD_INT 1
92944: ARRAY
92945: PPUSH
92946: LD_EXP 75
92950: PUSH
92951: LD_VAR 0 1
92955: ARRAY
92956: PUSH
92957: LD_VAR 0 2
92961: ARRAY
92962: PUSH
92963: LD_INT 2
92965: ARRAY
92966: PPUSH
92967: CALL_OW 428
92971: ST_TO_ADDR
// if not tmp then
92972: LD_VAR 0 4
92976: NOT
92977: IFFALSE 92981
// continue ;
92979: GO 92896
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92981: LD_VAR 0 4
92985: PUSH
92986: LD_INT 81
92988: PUSH
92989: LD_VAR 0 3
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PPUSH
92998: CALL_OW 69
93002: IN
93003: PUSH
93004: LD_EXP 75
93008: PUSH
93009: LD_VAR 0 1
93013: ARRAY
93014: PUSH
93015: LD_VAR 0 2
93019: ARRAY
93020: PUSH
93021: LD_INT 1
93023: ARRAY
93024: PPUSH
93025: LD_EXP 75
93029: PUSH
93030: LD_VAR 0 1
93034: ARRAY
93035: PUSH
93036: LD_VAR 0 2
93040: ARRAY
93041: PUSH
93042: LD_INT 2
93044: ARRAY
93045: PPUSH
93046: CALL_OW 458
93050: AND
93051: IFFALSE 93145
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
93053: LD_EXP 75
93057: PUSH
93058: LD_VAR 0 1
93062: ARRAY
93063: PUSH
93064: LD_VAR 0 2
93068: ARRAY
93069: PUSH
93070: LD_INT 1
93072: ARRAY
93073: PPUSH
93074: LD_EXP 75
93078: PUSH
93079: LD_VAR 0 1
93083: ARRAY
93084: PUSH
93085: LD_VAR 0 2
93089: ARRAY
93090: PUSH
93091: LD_INT 2
93093: ARRAY
93094: PPUSH
93095: LD_VAR 0 3
93099: PPUSH
93100: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
93104: LD_ADDR_EXP 75
93108: PUSH
93109: LD_EXP 75
93113: PPUSH
93114: LD_VAR 0 1
93118: PPUSH
93119: LD_EXP 75
93123: PUSH
93124: LD_VAR 0 1
93128: ARRAY
93129: PPUSH
93130: LD_VAR 0 2
93134: PPUSH
93135: CALL_OW 3
93139: PPUSH
93140: CALL_OW 1
93144: ST_TO_ADDR
// end ; end ;
93145: GO 92896
93147: POP
93148: POP
// end ;
93149: GO 92814
93151: POP
93152: POP
// end ;
93153: PPOPN 4
93155: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93156: LD_INT 0
93158: PPUSH
93159: PPUSH
// result := false ;
93160: LD_ADDR_VAR 0 4
93164: PUSH
93165: LD_INT 0
93167: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93168: LD_VAR 0 1
93172: PPUSH
93173: CALL_OW 264
93177: PUSH
93178: LD_INT 81
93180: EQUAL
93181: NOT
93182: IFFALSE 93186
// exit ;
93184: GO 93426
// index := GetElementIndex ( minersList , unit ) ;
93186: LD_ADDR_VAR 0 5
93190: PUSH
93191: LD_EXP 74
93195: PPUSH
93196: LD_VAR 0 1
93200: PPUSH
93201: CALL 15937 0 2
93205: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93206: LD_EXP 75
93210: PUSH
93211: LD_VAR 0 5
93215: ARRAY
93216: PUSH
93217: LD_EXP 76
93221: GREATEREQUAL
93222: IFFALSE 93226
// exit ;
93224: GO 93426
// ComMoveXY ( unit , x , y ) ;
93226: LD_VAR 0 1
93230: PPUSH
93231: LD_VAR 0 2
93235: PPUSH
93236: LD_VAR 0 3
93240: PPUSH
93241: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93245: LD_INT 35
93247: PPUSH
93248: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93252: LD_VAR 0 1
93256: PPUSH
93257: LD_VAR 0 2
93261: PPUSH
93262: LD_VAR 0 3
93266: PPUSH
93267: CALL 47273 0 3
93271: NOT
93272: PUSH
93273: LD_VAR 0 1
93277: PPUSH
93278: CALL_OW 314
93282: AND
93283: IFFALSE 93287
// exit ;
93285: GO 93426
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93287: LD_VAR 0 2
93291: PPUSH
93292: LD_VAR 0 3
93296: PPUSH
93297: CALL_OW 428
93301: PUSH
93302: LD_VAR 0 1
93306: EQUAL
93307: PUSH
93308: LD_VAR 0 1
93312: PPUSH
93313: CALL_OW 314
93317: NOT
93318: AND
93319: IFFALSE 93245
// PlaySoundXY ( x , y , PlantMine ) ;
93321: LD_VAR 0 2
93325: PPUSH
93326: LD_VAR 0 3
93330: PPUSH
93331: LD_STRING PlantMine
93333: PPUSH
93334: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93338: LD_VAR 0 2
93342: PPUSH
93343: LD_VAR 0 3
93347: PPUSH
93348: LD_VAR 0 1
93352: PPUSH
93353: CALL_OW 255
93357: PPUSH
93358: LD_INT 0
93360: PPUSH
93361: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93365: LD_ADDR_EXP 75
93369: PUSH
93370: LD_EXP 75
93374: PPUSH
93375: LD_VAR 0 5
93379: PUSH
93380: LD_EXP 75
93384: PUSH
93385: LD_VAR 0 5
93389: ARRAY
93390: PUSH
93391: LD_INT 1
93393: PLUS
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PPUSH
93399: LD_VAR 0 2
93403: PUSH
93404: LD_VAR 0 3
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PPUSH
93413: CALL 16152 0 3
93417: ST_TO_ADDR
// result := true ;
93418: LD_ADDR_VAR 0 4
93422: PUSH
93423: LD_INT 1
93425: ST_TO_ADDR
// end ;
93426: LD_VAR 0 4
93430: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93431: LD_INT 0
93433: PPUSH
93434: PPUSH
93435: PPUSH
// if not unit in minersList then
93436: LD_VAR 0 1
93440: PUSH
93441: LD_EXP 74
93445: IN
93446: NOT
93447: IFFALSE 93451
// exit ;
93449: GO 93843
// index := GetElementIndex ( minersList , unit ) ;
93451: LD_ADDR_VAR 0 6
93455: PUSH
93456: LD_EXP 74
93460: PPUSH
93461: LD_VAR 0 1
93465: PPUSH
93466: CALL 15937 0 2
93470: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93471: LD_ADDR_VAR 0 5
93475: PUSH
93476: DOUBLE
93477: LD_EXP 75
93481: PUSH
93482: LD_VAR 0 6
93486: ARRAY
93487: INC
93488: ST_TO_ADDR
93489: LD_INT 1
93491: PUSH
93492: FOR_DOWNTO
93493: IFFALSE 93654
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93495: LD_EXP 75
93499: PUSH
93500: LD_VAR 0 6
93504: ARRAY
93505: PUSH
93506: LD_VAR 0 5
93510: ARRAY
93511: PUSH
93512: LD_INT 1
93514: ARRAY
93515: PUSH
93516: LD_VAR 0 2
93520: EQUAL
93521: PUSH
93522: LD_EXP 75
93526: PUSH
93527: LD_VAR 0 6
93531: ARRAY
93532: PUSH
93533: LD_VAR 0 5
93537: ARRAY
93538: PUSH
93539: LD_INT 2
93541: ARRAY
93542: PUSH
93543: LD_VAR 0 3
93547: EQUAL
93548: AND
93549: IFFALSE 93652
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93551: LD_EXP 75
93555: PUSH
93556: LD_VAR 0 6
93560: ARRAY
93561: PUSH
93562: LD_VAR 0 5
93566: ARRAY
93567: PUSH
93568: LD_INT 1
93570: ARRAY
93571: PPUSH
93572: LD_EXP 75
93576: PUSH
93577: LD_VAR 0 6
93581: ARRAY
93582: PUSH
93583: LD_VAR 0 5
93587: ARRAY
93588: PUSH
93589: LD_INT 2
93591: ARRAY
93592: PPUSH
93593: LD_VAR 0 1
93597: PPUSH
93598: CALL_OW 255
93602: PPUSH
93603: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93607: LD_ADDR_EXP 75
93611: PUSH
93612: LD_EXP 75
93616: PPUSH
93617: LD_VAR 0 6
93621: PPUSH
93622: LD_EXP 75
93626: PUSH
93627: LD_VAR 0 6
93631: ARRAY
93632: PPUSH
93633: LD_VAR 0 5
93637: PPUSH
93638: CALL_OW 3
93642: PPUSH
93643: CALL_OW 1
93647: ST_TO_ADDR
// exit ;
93648: POP
93649: POP
93650: GO 93843
// end ; end ;
93652: GO 93492
93654: POP
93655: POP
// for i := minerMinesList [ index ] downto 1 do
93656: LD_ADDR_VAR 0 5
93660: PUSH
93661: DOUBLE
93662: LD_EXP 75
93666: PUSH
93667: LD_VAR 0 6
93671: ARRAY
93672: INC
93673: ST_TO_ADDR
93674: LD_INT 1
93676: PUSH
93677: FOR_DOWNTO
93678: IFFALSE 93841
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93680: LD_EXP 75
93684: PUSH
93685: LD_VAR 0 6
93689: ARRAY
93690: PUSH
93691: LD_VAR 0 5
93695: ARRAY
93696: PUSH
93697: LD_INT 1
93699: ARRAY
93700: PPUSH
93701: LD_EXP 75
93705: PUSH
93706: LD_VAR 0 6
93710: ARRAY
93711: PUSH
93712: LD_VAR 0 5
93716: ARRAY
93717: PUSH
93718: LD_INT 2
93720: ARRAY
93721: PPUSH
93722: LD_VAR 0 2
93726: PPUSH
93727: LD_VAR 0 3
93731: PPUSH
93732: CALL_OW 298
93736: PUSH
93737: LD_INT 6
93739: LESS
93740: IFFALSE 93839
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93742: LD_EXP 75
93746: PUSH
93747: LD_VAR 0 6
93751: ARRAY
93752: PUSH
93753: LD_VAR 0 5
93757: ARRAY
93758: PUSH
93759: LD_INT 1
93761: ARRAY
93762: PPUSH
93763: LD_EXP 75
93767: PUSH
93768: LD_VAR 0 6
93772: ARRAY
93773: PUSH
93774: LD_VAR 0 5
93778: ARRAY
93779: PUSH
93780: LD_INT 2
93782: ARRAY
93783: PPUSH
93784: LD_VAR 0 1
93788: PPUSH
93789: CALL_OW 255
93793: PPUSH
93794: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93798: LD_ADDR_EXP 75
93802: PUSH
93803: LD_EXP 75
93807: PPUSH
93808: LD_VAR 0 6
93812: PPUSH
93813: LD_EXP 75
93817: PUSH
93818: LD_VAR 0 6
93822: ARRAY
93823: PPUSH
93824: LD_VAR 0 5
93828: PPUSH
93829: CALL_OW 3
93833: PPUSH
93834: CALL_OW 1
93838: ST_TO_ADDR
// end ; end ;
93839: GO 93677
93841: POP
93842: POP
// end ;
93843: LD_VAR 0 4
93847: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93848: LD_INT 0
93850: PPUSH
93851: PPUSH
93852: PPUSH
93853: PPUSH
93854: PPUSH
93855: PPUSH
93856: PPUSH
93857: PPUSH
93858: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93859: LD_VAR 0 1
93863: PPUSH
93864: CALL_OW 264
93868: PUSH
93869: LD_INT 81
93871: EQUAL
93872: NOT
93873: PUSH
93874: LD_VAR 0 1
93878: PUSH
93879: LD_EXP 74
93883: IN
93884: NOT
93885: OR
93886: IFFALSE 93890
// exit ;
93888: GO 94212
// index := GetElementIndex ( minersList , unit ) ;
93890: LD_ADDR_VAR 0 6
93894: PUSH
93895: LD_EXP 74
93899: PPUSH
93900: LD_VAR 0 1
93904: PPUSH
93905: CALL 15937 0 2
93909: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93910: LD_ADDR_VAR 0 8
93914: PUSH
93915: LD_EXP 76
93919: PUSH
93920: LD_EXP 75
93924: PUSH
93925: LD_VAR 0 6
93929: ARRAY
93930: MINUS
93931: ST_TO_ADDR
// if not minesFreeAmount then
93932: LD_VAR 0 8
93936: NOT
93937: IFFALSE 93941
// exit ;
93939: GO 94212
// tmp := [ ] ;
93941: LD_ADDR_VAR 0 7
93945: PUSH
93946: EMPTY
93947: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93948: LD_ADDR_VAR 0 5
93952: PUSH
93953: DOUBLE
93954: LD_INT 1
93956: DEC
93957: ST_TO_ADDR
93958: LD_VAR 0 8
93962: PUSH
93963: FOR_TO
93964: IFFALSE 94159
// begin _d := rand ( 0 , 5 ) ;
93966: LD_ADDR_VAR 0 11
93970: PUSH
93971: LD_INT 0
93973: PPUSH
93974: LD_INT 5
93976: PPUSH
93977: CALL_OW 12
93981: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93982: LD_ADDR_VAR 0 12
93986: PUSH
93987: LD_INT 2
93989: PPUSH
93990: LD_INT 6
93992: PPUSH
93993: CALL_OW 12
93997: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93998: LD_ADDR_VAR 0 9
94002: PUSH
94003: LD_VAR 0 2
94007: PPUSH
94008: LD_VAR 0 11
94012: PPUSH
94013: LD_VAR 0 12
94017: PPUSH
94018: CALL_OW 272
94022: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
94023: LD_ADDR_VAR 0 10
94027: PUSH
94028: LD_VAR 0 3
94032: PPUSH
94033: LD_VAR 0 11
94037: PPUSH
94038: LD_VAR 0 12
94042: PPUSH
94043: CALL_OW 273
94047: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
94048: LD_VAR 0 9
94052: PPUSH
94053: LD_VAR 0 10
94057: PPUSH
94058: CALL_OW 488
94062: PUSH
94063: LD_VAR 0 9
94067: PUSH
94068: LD_VAR 0 10
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_VAR 0 7
94081: IN
94082: NOT
94083: AND
94084: PUSH
94085: LD_VAR 0 9
94089: PPUSH
94090: LD_VAR 0 10
94094: PPUSH
94095: CALL_OW 458
94099: NOT
94100: AND
94101: IFFALSE 94143
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
94103: LD_ADDR_VAR 0 7
94107: PUSH
94108: LD_VAR 0 7
94112: PPUSH
94113: LD_VAR 0 7
94117: PUSH
94118: LD_INT 1
94120: PLUS
94121: PPUSH
94122: LD_VAR 0 9
94126: PUSH
94127: LD_VAR 0 10
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PPUSH
94136: CALL_OW 1
94140: ST_TO_ADDR
94141: GO 94157
// i := i - 1 ;
94143: LD_ADDR_VAR 0 5
94147: PUSH
94148: LD_VAR 0 5
94152: PUSH
94153: LD_INT 1
94155: MINUS
94156: ST_TO_ADDR
// end ;
94157: GO 93963
94159: POP
94160: POP
// for i in tmp do
94161: LD_ADDR_VAR 0 5
94165: PUSH
94166: LD_VAR 0 7
94170: PUSH
94171: FOR_IN
94172: IFFALSE 94210
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94174: LD_VAR 0 1
94178: PPUSH
94179: LD_VAR 0 5
94183: PUSH
94184: LD_INT 1
94186: ARRAY
94187: PPUSH
94188: LD_VAR 0 5
94192: PUSH
94193: LD_INT 2
94195: ARRAY
94196: PPUSH
94197: CALL 93156 0 3
94201: NOT
94202: IFFALSE 94208
// exit ;
94204: POP
94205: POP
94206: GO 94212
94208: GO 94171
94210: POP
94211: POP
// end ;
94212: LD_VAR 0 4
94216: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94217: LD_INT 0
94219: PPUSH
94220: PPUSH
94221: PPUSH
94222: PPUSH
94223: PPUSH
94224: PPUSH
94225: PPUSH
// if not GetClass ( unit ) = class_sniper then
94226: LD_VAR 0 1
94230: PPUSH
94231: CALL_OW 257
94235: PUSH
94236: LD_INT 5
94238: EQUAL
94239: NOT
94240: IFFALSE 94244
// exit ;
94242: GO 94632
// dist := 8 ;
94244: LD_ADDR_VAR 0 5
94248: PUSH
94249: LD_INT 8
94251: ST_TO_ADDR
// viewRange := 12 ;
94252: LD_ADDR_VAR 0 7
94256: PUSH
94257: LD_INT 12
94259: ST_TO_ADDR
// side := GetSide ( unit ) ;
94260: LD_ADDR_VAR 0 6
94264: PUSH
94265: LD_VAR 0 1
94269: PPUSH
94270: CALL_OW 255
94274: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94275: LD_INT 61
94277: PPUSH
94278: LD_VAR 0 6
94282: PPUSH
94283: CALL_OW 321
94287: PUSH
94288: LD_INT 2
94290: EQUAL
94291: IFFALSE 94301
// viewRange := 16 ;
94293: LD_ADDR_VAR 0 7
94297: PUSH
94298: LD_INT 16
94300: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94301: LD_VAR 0 1
94305: PPUSH
94306: LD_VAR 0 2
94310: PPUSH
94311: LD_VAR 0 3
94315: PPUSH
94316: CALL_OW 297
94320: PUSH
94321: LD_VAR 0 5
94325: GREATER
94326: IFFALSE 94405
// begin ComMoveXY ( unit , x , y ) ;
94328: LD_VAR 0 1
94332: PPUSH
94333: LD_VAR 0 2
94337: PPUSH
94338: LD_VAR 0 3
94342: PPUSH
94343: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94347: LD_INT 35
94349: PPUSH
94350: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94354: LD_VAR 0 1
94358: PPUSH
94359: LD_VAR 0 2
94363: PPUSH
94364: LD_VAR 0 3
94368: PPUSH
94369: CALL 47273 0 3
94373: NOT
94374: IFFALSE 94378
// exit ;
94376: GO 94632
// until GetDistUnitXY ( unit , x , y ) < dist ;
94378: LD_VAR 0 1
94382: PPUSH
94383: LD_VAR 0 2
94387: PPUSH
94388: LD_VAR 0 3
94392: PPUSH
94393: CALL_OW 297
94397: PUSH
94398: LD_VAR 0 5
94402: LESS
94403: IFFALSE 94347
// end ; ComTurnXY ( unit , x , y ) ;
94405: LD_VAR 0 1
94409: PPUSH
94410: LD_VAR 0 2
94414: PPUSH
94415: LD_VAR 0 3
94419: PPUSH
94420: CALL_OW 118
// wait ( 5 ) ;
94424: LD_INT 5
94426: PPUSH
94427: CALL_OW 67
// _d := GetDir ( unit ) ;
94431: LD_ADDR_VAR 0 10
94435: PUSH
94436: LD_VAR 0 1
94440: PPUSH
94441: CALL_OW 254
94445: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94446: LD_ADDR_VAR 0 8
94450: PUSH
94451: LD_VAR 0 1
94455: PPUSH
94456: CALL_OW 250
94460: PPUSH
94461: LD_VAR 0 10
94465: PPUSH
94466: LD_VAR 0 5
94470: PPUSH
94471: CALL_OW 272
94475: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94476: LD_ADDR_VAR 0 9
94480: PUSH
94481: LD_VAR 0 1
94485: PPUSH
94486: CALL_OW 251
94490: PPUSH
94491: LD_VAR 0 10
94495: PPUSH
94496: LD_VAR 0 5
94500: PPUSH
94501: CALL_OW 273
94505: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94506: LD_VAR 0 8
94510: PPUSH
94511: LD_VAR 0 9
94515: PPUSH
94516: CALL_OW 488
94520: NOT
94521: IFFALSE 94525
// exit ;
94523: GO 94632
// ComAnimCustom ( unit , 1 ) ;
94525: LD_VAR 0 1
94529: PPUSH
94530: LD_INT 1
94532: PPUSH
94533: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94537: LD_VAR 0 8
94541: PPUSH
94542: LD_VAR 0 9
94546: PPUSH
94547: LD_VAR 0 6
94551: PPUSH
94552: LD_VAR 0 7
94556: PPUSH
94557: CALL_OW 330
// repeat wait ( 1 ) ;
94561: LD_INT 1
94563: PPUSH
94564: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94568: LD_VAR 0 1
94572: PPUSH
94573: CALL_OW 316
94577: PUSH
94578: LD_VAR 0 1
94582: PPUSH
94583: CALL_OW 314
94587: OR
94588: PUSH
94589: LD_VAR 0 1
94593: PPUSH
94594: CALL_OW 302
94598: NOT
94599: OR
94600: PUSH
94601: LD_VAR 0 1
94605: PPUSH
94606: CALL_OW 301
94610: OR
94611: IFFALSE 94561
// RemoveSeeing ( _x , _y , side ) ;
94613: LD_VAR 0 8
94617: PPUSH
94618: LD_VAR 0 9
94622: PPUSH
94623: LD_VAR 0 6
94627: PPUSH
94628: CALL_OW 331
// end ; end_of_file end_of_file
94632: LD_VAR 0 4
94636: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94637: LD_VAR 0 1
94641: PUSH
94642: LD_INT 200
94644: DOUBLE
94645: GREATEREQUAL
94646: IFFALSE 94654
94648: LD_INT 299
94650: DOUBLE
94651: LESSEQUAL
94652: IFTRUE 94656
94654: GO 94688
94656: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94657: LD_VAR 0 1
94661: PPUSH
94662: LD_VAR 0 2
94666: PPUSH
94667: LD_VAR 0 3
94671: PPUSH
94672: LD_VAR 0 4
94676: PPUSH
94677: LD_VAR 0 5
94681: PPUSH
94682: CALL 90724 0 5
94686: GO 94765
94688: LD_INT 300
94690: DOUBLE
94691: GREATEREQUAL
94692: IFFALSE 94700
94694: LD_INT 399
94696: DOUBLE
94697: LESSEQUAL
94698: IFTRUE 94702
94700: GO 94764
94702: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94703: LD_VAR 0 1
94707: PPUSH
94708: LD_VAR 0 2
94712: PPUSH
94713: LD_VAR 0 3
94717: PPUSH
94718: LD_VAR 0 4
94722: PPUSH
94723: LD_VAR 0 5
94727: PPUSH
94728: LD_VAR 0 6
94732: PPUSH
94733: LD_VAR 0 7
94737: PPUSH
94738: LD_VAR 0 8
94742: PPUSH
94743: LD_VAR 0 9
94747: PPUSH
94748: LD_VAR 0 10
94752: PPUSH
94753: LD_VAR 0 11
94757: PPUSH
94758: CALL 107158 0 11
94762: GO 94765
94764: POP
// end ;
94765: PPOPN 11
94767: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94768: LD_VAR 0 1
94772: PPUSH
94773: LD_VAR 0 2
94777: PPUSH
94778: LD_VAR 0 3
94782: PPUSH
94783: LD_VAR 0 4
94787: PPUSH
94788: LD_VAR 0 5
94792: PPUSH
94793: CALL 90460 0 5
// end ; end_of_file
94797: PPOPN 5
94799: END
// every 0 0$1 do
94800: GO 94802
94802: DISABLE
// begin enable ;
94803: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94804: LD_STRING updateTimer(
94806: PUSH
94807: LD_OWVAR 1
94811: STR
94812: PUSH
94813: LD_STRING );
94815: STR
94816: PPUSH
94817: CALL_OW 559
// end ;
94821: END
// export function SOS_MapStart ( ) ; begin
94822: LD_INT 0
94824: PPUSH
// if streamModeActive then
94825: LD_EXP 77
94829: IFFALSE 94838
// DefineStreamItems ( true ) ;
94831: LD_INT 1
94833: PPUSH
94834: CALL 96492 0 1
// UpdateFactoryWaypoints ( ) ;
94838: CALL 109353 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94842: CALL 109610 0 0
// end ;
94846: LD_VAR 0 1
94850: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94851: LD_INT 0
94853: PPUSH
// if p2 = hack_mode then
94854: LD_VAR 0 2
94858: PUSH
94859: LD_INT 100
94861: EQUAL
94862: IFFALSE 95865
// begin if not StreamModeActive then
94864: LD_EXP 77
94868: NOT
94869: IFFALSE 94879
// StreamModeActive := true ;
94871: LD_ADDR_EXP 77
94875: PUSH
94876: LD_INT 1
94878: ST_TO_ADDR
// if p3 = 0 then
94879: LD_VAR 0 3
94883: PUSH
94884: LD_INT 0
94886: EQUAL
94887: IFFALSE 94893
// InitStreamMode ;
94889: CALL 96028 0 0
// if p3 = 1 then
94893: LD_VAR 0 3
94897: PUSH
94898: LD_INT 1
94900: EQUAL
94901: IFFALSE 94911
// sRocket := true ;
94903: LD_ADDR_EXP 82
94907: PUSH
94908: LD_INT 1
94910: ST_TO_ADDR
// if p3 = 2 then
94911: LD_VAR 0 3
94915: PUSH
94916: LD_INT 2
94918: EQUAL
94919: IFFALSE 94929
// sSpeed := true ;
94921: LD_ADDR_EXP 81
94925: PUSH
94926: LD_INT 1
94928: ST_TO_ADDR
// if p3 = 3 then
94929: LD_VAR 0 3
94933: PUSH
94934: LD_INT 3
94936: EQUAL
94937: IFFALSE 94947
// sEngine := true ;
94939: LD_ADDR_EXP 83
94943: PUSH
94944: LD_INT 1
94946: ST_TO_ADDR
// if p3 = 4 then
94947: LD_VAR 0 3
94951: PUSH
94952: LD_INT 4
94954: EQUAL
94955: IFFALSE 94965
// sSpec := true ;
94957: LD_ADDR_EXP 80
94961: PUSH
94962: LD_INT 1
94964: ST_TO_ADDR
// if p3 = 5 then
94965: LD_VAR 0 3
94969: PUSH
94970: LD_INT 5
94972: EQUAL
94973: IFFALSE 94983
// sLevel := true ;
94975: LD_ADDR_EXP 84
94979: PUSH
94980: LD_INT 1
94982: ST_TO_ADDR
// if p3 = 6 then
94983: LD_VAR 0 3
94987: PUSH
94988: LD_INT 6
94990: EQUAL
94991: IFFALSE 95001
// sArmoury := true ;
94993: LD_ADDR_EXP 85
94997: PUSH
94998: LD_INT 1
95000: ST_TO_ADDR
// if p3 = 7 then
95001: LD_VAR 0 3
95005: PUSH
95006: LD_INT 7
95008: EQUAL
95009: IFFALSE 95019
// sRadar := true ;
95011: LD_ADDR_EXP 86
95015: PUSH
95016: LD_INT 1
95018: ST_TO_ADDR
// if p3 = 8 then
95019: LD_VAR 0 3
95023: PUSH
95024: LD_INT 8
95026: EQUAL
95027: IFFALSE 95037
// sBunker := true ;
95029: LD_ADDR_EXP 87
95033: PUSH
95034: LD_INT 1
95036: ST_TO_ADDR
// if p3 = 9 then
95037: LD_VAR 0 3
95041: PUSH
95042: LD_INT 9
95044: EQUAL
95045: IFFALSE 95055
// sHack := true ;
95047: LD_ADDR_EXP 88
95051: PUSH
95052: LD_INT 1
95054: ST_TO_ADDR
// if p3 = 10 then
95055: LD_VAR 0 3
95059: PUSH
95060: LD_INT 10
95062: EQUAL
95063: IFFALSE 95073
// sFire := true ;
95065: LD_ADDR_EXP 89
95069: PUSH
95070: LD_INT 1
95072: ST_TO_ADDR
// if p3 = 11 then
95073: LD_VAR 0 3
95077: PUSH
95078: LD_INT 11
95080: EQUAL
95081: IFFALSE 95091
// sRefresh := true ;
95083: LD_ADDR_EXP 90
95087: PUSH
95088: LD_INT 1
95090: ST_TO_ADDR
// if p3 = 12 then
95091: LD_VAR 0 3
95095: PUSH
95096: LD_INT 12
95098: EQUAL
95099: IFFALSE 95109
// sExp := true ;
95101: LD_ADDR_EXP 91
95105: PUSH
95106: LD_INT 1
95108: ST_TO_ADDR
// if p3 = 13 then
95109: LD_VAR 0 3
95113: PUSH
95114: LD_INT 13
95116: EQUAL
95117: IFFALSE 95127
// sDepot := true ;
95119: LD_ADDR_EXP 92
95123: PUSH
95124: LD_INT 1
95126: ST_TO_ADDR
// if p3 = 14 then
95127: LD_VAR 0 3
95131: PUSH
95132: LD_INT 14
95134: EQUAL
95135: IFFALSE 95145
// sFlag := true ;
95137: LD_ADDR_EXP 93
95141: PUSH
95142: LD_INT 1
95144: ST_TO_ADDR
// if p3 = 15 then
95145: LD_VAR 0 3
95149: PUSH
95150: LD_INT 15
95152: EQUAL
95153: IFFALSE 95163
// sKamikadze := true ;
95155: LD_ADDR_EXP 101
95159: PUSH
95160: LD_INT 1
95162: ST_TO_ADDR
// if p3 = 16 then
95163: LD_VAR 0 3
95167: PUSH
95168: LD_INT 16
95170: EQUAL
95171: IFFALSE 95181
// sTroll := true ;
95173: LD_ADDR_EXP 102
95177: PUSH
95178: LD_INT 1
95180: ST_TO_ADDR
// if p3 = 17 then
95181: LD_VAR 0 3
95185: PUSH
95186: LD_INT 17
95188: EQUAL
95189: IFFALSE 95199
// sSlow := true ;
95191: LD_ADDR_EXP 103
95195: PUSH
95196: LD_INT 1
95198: ST_TO_ADDR
// if p3 = 18 then
95199: LD_VAR 0 3
95203: PUSH
95204: LD_INT 18
95206: EQUAL
95207: IFFALSE 95217
// sLack := true ;
95209: LD_ADDR_EXP 104
95213: PUSH
95214: LD_INT 1
95216: ST_TO_ADDR
// if p3 = 19 then
95217: LD_VAR 0 3
95221: PUSH
95222: LD_INT 19
95224: EQUAL
95225: IFFALSE 95235
// sTank := true ;
95227: LD_ADDR_EXP 106
95231: PUSH
95232: LD_INT 1
95234: ST_TO_ADDR
// if p3 = 20 then
95235: LD_VAR 0 3
95239: PUSH
95240: LD_INT 20
95242: EQUAL
95243: IFFALSE 95253
// sRemote := true ;
95245: LD_ADDR_EXP 107
95249: PUSH
95250: LD_INT 1
95252: ST_TO_ADDR
// if p3 = 21 then
95253: LD_VAR 0 3
95257: PUSH
95258: LD_INT 21
95260: EQUAL
95261: IFFALSE 95271
// sPowell := true ;
95263: LD_ADDR_EXP 108
95267: PUSH
95268: LD_INT 1
95270: ST_TO_ADDR
// if p3 = 22 then
95271: LD_VAR 0 3
95275: PUSH
95276: LD_INT 22
95278: EQUAL
95279: IFFALSE 95289
// sTeleport := true ;
95281: LD_ADDR_EXP 111
95285: PUSH
95286: LD_INT 1
95288: ST_TO_ADDR
// if p3 = 23 then
95289: LD_VAR 0 3
95293: PUSH
95294: LD_INT 23
95296: EQUAL
95297: IFFALSE 95307
// sOilTower := true ;
95299: LD_ADDR_EXP 113
95303: PUSH
95304: LD_INT 1
95306: ST_TO_ADDR
// if p3 = 24 then
95307: LD_VAR 0 3
95311: PUSH
95312: LD_INT 24
95314: EQUAL
95315: IFFALSE 95325
// sShovel := true ;
95317: LD_ADDR_EXP 114
95321: PUSH
95322: LD_INT 1
95324: ST_TO_ADDR
// if p3 = 25 then
95325: LD_VAR 0 3
95329: PUSH
95330: LD_INT 25
95332: EQUAL
95333: IFFALSE 95343
// sSheik := true ;
95335: LD_ADDR_EXP 115
95339: PUSH
95340: LD_INT 1
95342: ST_TO_ADDR
// if p3 = 26 then
95343: LD_VAR 0 3
95347: PUSH
95348: LD_INT 26
95350: EQUAL
95351: IFFALSE 95361
// sEarthquake := true ;
95353: LD_ADDR_EXP 117
95357: PUSH
95358: LD_INT 1
95360: ST_TO_ADDR
// if p3 = 27 then
95361: LD_VAR 0 3
95365: PUSH
95366: LD_INT 27
95368: EQUAL
95369: IFFALSE 95379
// sAI := true ;
95371: LD_ADDR_EXP 118
95375: PUSH
95376: LD_INT 1
95378: ST_TO_ADDR
// if p3 = 28 then
95379: LD_VAR 0 3
95383: PUSH
95384: LD_INT 28
95386: EQUAL
95387: IFFALSE 95397
// sCargo := true ;
95389: LD_ADDR_EXP 121
95393: PUSH
95394: LD_INT 1
95396: ST_TO_ADDR
// if p3 = 29 then
95397: LD_VAR 0 3
95401: PUSH
95402: LD_INT 29
95404: EQUAL
95405: IFFALSE 95415
// sDLaser := true ;
95407: LD_ADDR_EXP 122
95411: PUSH
95412: LD_INT 1
95414: ST_TO_ADDR
// if p3 = 30 then
95415: LD_VAR 0 3
95419: PUSH
95420: LD_INT 30
95422: EQUAL
95423: IFFALSE 95433
// sExchange := true ;
95425: LD_ADDR_EXP 123
95429: PUSH
95430: LD_INT 1
95432: ST_TO_ADDR
// if p3 = 31 then
95433: LD_VAR 0 3
95437: PUSH
95438: LD_INT 31
95440: EQUAL
95441: IFFALSE 95451
// sFac := true ;
95443: LD_ADDR_EXP 124
95447: PUSH
95448: LD_INT 1
95450: ST_TO_ADDR
// if p3 = 32 then
95451: LD_VAR 0 3
95455: PUSH
95456: LD_INT 32
95458: EQUAL
95459: IFFALSE 95469
// sPower := true ;
95461: LD_ADDR_EXP 125
95465: PUSH
95466: LD_INT 1
95468: ST_TO_ADDR
// if p3 = 33 then
95469: LD_VAR 0 3
95473: PUSH
95474: LD_INT 33
95476: EQUAL
95477: IFFALSE 95487
// sRandom := true ;
95479: LD_ADDR_EXP 126
95483: PUSH
95484: LD_INT 1
95486: ST_TO_ADDR
// if p3 = 34 then
95487: LD_VAR 0 3
95491: PUSH
95492: LD_INT 34
95494: EQUAL
95495: IFFALSE 95505
// sShield := true ;
95497: LD_ADDR_EXP 127
95501: PUSH
95502: LD_INT 1
95504: ST_TO_ADDR
// if p3 = 35 then
95505: LD_VAR 0 3
95509: PUSH
95510: LD_INT 35
95512: EQUAL
95513: IFFALSE 95523
// sTime := true ;
95515: LD_ADDR_EXP 128
95519: PUSH
95520: LD_INT 1
95522: ST_TO_ADDR
// if p3 = 36 then
95523: LD_VAR 0 3
95527: PUSH
95528: LD_INT 36
95530: EQUAL
95531: IFFALSE 95541
// sTools := true ;
95533: LD_ADDR_EXP 129
95537: PUSH
95538: LD_INT 1
95540: ST_TO_ADDR
// if p3 = 101 then
95541: LD_VAR 0 3
95545: PUSH
95546: LD_INT 101
95548: EQUAL
95549: IFFALSE 95559
// sSold := true ;
95551: LD_ADDR_EXP 94
95555: PUSH
95556: LD_INT 1
95558: ST_TO_ADDR
// if p3 = 102 then
95559: LD_VAR 0 3
95563: PUSH
95564: LD_INT 102
95566: EQUAL
95567: IFFALSE 95577
// sDiff := true ;
95569: LD_ADDR_EXP 95
95573: PUSH
95574: LD_INT 1
95576: ST_TO_ADDR
// if p3 = 103 then
95577: LD_VAR 0 3
95581: PUSH
95582: LD_INT 103
95584: EQUAL
95585: IFFALSE 95595
// sFog := true ;
95587: LD_ADDR_EXP 98
95591: PUSH
95592: LD_INT 1
95594: ST_TO_ADDR
// if p3 = 104 then
95595: LD_VAR 0 3
95599: PUSH
95600: LD_INT 104
95602: EQUAL
95603: IFFALSE 95613
// sReset := true ;
95605: LD_ADDR_EXP 99
95609: PUSH
95610: LD_INT 1
95612: ST_TO_ADDR
// if p3 = 105 then
95613: LD_VAR 0 3
95617: PUSH
95618: LD_INT 105
95620: EQUAL
95621: IFFALSE 95631
// sSun := true ;
95623: LD_ADDR_EXP 100
95627: PUSH
95628: LD_INT 1
95630: ST_TO_ADDR
// if p3 = 106 then
95631: LD_VAR 0 3
95635: PUSH
95636: LD_INT 106
95638: EQUAL
95639: IFFALSE 95649
// sTiger := true ;
95641: LD_ADDR_EXP 96
95645: PUSH
95646: LD_INT 1
95648: ST_TO_ADDR
// if p3 = 107 then
95649: LD_VAR 0 3
95653: PUSH
95654: LD_INT 107
95656: EQUAL
95657: IFFALSE 95667
// sBomb := true ;
95659: LD_ADDR_EXP 97
95663: PUSH
95664: LD_INT 1
95666: ST_TO_ADDR
// if p3 = 108 then
95667: LD_VAR 0 3
95671: PUSH
95672: LD_INT 108
95674: EQUAL
95675: IFFALSE 95685
// sWound := true ;
95677: LD_ADDR_EXP 105
95681: PUSH
95682: LD_INT 1
95684: ST_TO_ADDR
// if p3 = 109 then
95685: LD_VAR 0 3
95689: PUSH
95690: LD_INT 109
95692: EQUAL
95693: IFFALSE 95703
// sBetray := true ;
95695: LD_ADDR_EXP 109
95699: PUSH
95700: LD_INT 1
95702: ST_TO_ADDR
// if p3 = 110 then
95703: LD_VAR 0 3
95707: PUSH
95708: LD_INT 110
95710: EQUAL
95711: IFFALSE 95721
// sContamin := true ;
95713: LD_ADDR_EXP 110
95717: PUSH
95718: LD_INT 1
95720: ST_TO_ADDR
// if p3 = 111 then
95721: LD_VAR 0 3
95725: PUSH
95726: LD_INT 111
95728: EQUAL
95729: IFFALSE 95739
// sOil := true ;
95731: LD_ADDR_EXP 112
95735: PUSH
95736: LD_INT 1
95738: ST_TO_ADDR
// if p3 = 112 then
95739: LD_VAR 0 3
95743: PUSH
95744: LD_INT 112
95746: EQUAL
95747: IFFALSE 95757
// sStu := true ;
95749: LD_ADDR_EXP 116
95753: PUSH
95754: LD_INT 1
95756: ST_TO_ADDR
// if p3 = 113 then
95757: LD_VAR 0 3
95761: PUSH
95762: LD_INT 113
95764: EQUAL
95765: IFFALSE 95775
// sBazooka := true ;
95767: LD_ADDR_EXP 119
95771: PUSH
95772: LD_INT 1
95774: ST_TO_ADDR
// if p3 = 114 then
95775: LD_VAR 0 3
95779: PUSH
95780: LD_INT 114
95782: EQUAL
95783: IFFALSE 95793
// sMortar := true ;
95785: LD_ADDR_EXP 120
95789: PUSH
95790: LD_INT 1
95792: ST_TO_ADDR
// if p3 = 115 then
95793: LD_VAR 0 3
95797: PUSH
95798: LD_INT 115
95800: EQUAL
95801: IFFALSE 95811
// sRanger := true ;
95803: LD_ADDR_EXP 130
95807: PUSH
95808: LD_INT 1
95810: ST_TO_ADDR
// if p3 = 116 then
95811: LD_VAR 0 3
95815: PUSH
95816: LD_INT 116
95818: EQUAL
95819: IFFALSE 95829
// sComputer := true ;
95821: LD_ADDR_EXP 131
95825: PUSH
95826: LD_INT 1
95828: ST_TO_ADDR
// if p3 = 117 then
95829: LD_VAR 0 3
95833: PUSH
95834: LD_INT 117
95836: EQUAL
95837: IFFALSE 95847
// s30 := true ;
95839: LD_ADDR_EXP 132
95843: PUSH
95844: LD_INT 1
95846: ST_TO_ADDR
// if p3 = 118 then
95847: LD_VAR 0 3
95851: PUSH
95852: LD_INT 118
95854: EQUAL
95855: IFFALSE 95865
// s60 := true ;
95857: LD_ADDR_EXP 133
95861: PUSH
95862: LD_INT 1
95864: ST_TO_ADDR
// end ; if p2 = stream_mode then
95865: LD_VAR 0 2
95869: PUSH
95870: LD_INT 101
95872: EQUAL
95873: IFFALSE 96001
// begin case p3 of 1 :
95875: LD_VAR 0 3
95879: PUSH
95880: LD_INT 1
95882: DOUBLE
95883: EQUAL
95884: IFTRUE 95888
95886: GO 95895
95888: POP
// hHackUnlimitedResources ; 2 :
95889: CALL 108099 0 0
95893: GO 96001
95895: LD_INT 2
95897: DOUBLE
95898: EQUAL
95899: IFTRUE 95903
95901: GO 95910
95903: POP
// hHackSetLevel10 ; 3 :
95904: CALL 108232 0 0
95908: GO 96001
95910: LD_INT 3
95912: DOUBLE
95913: EQUAL
95914: IFTRUE 95918
95916: GO 95925
95918: POP
// hHackSetLevel10YourUnits ; 4 :
95919: CALL 108317 0 0
95923: GO 96001
95925: LD_INT 4
95927: DOUBLE
95928: EQUAL
95929: IFTRUE 95933
95931: GO 95940
95933: POP
// hHackInvincible ; 5 :
95934: CALL 108765 0 0
95938: GO 96001
95940: LD_INT 5
95942: DOUBLE
95943: EQUAL
95944: IFTRUE 95948
95946: GO 95955
95948: POP
// hHackInvisible ; 6 :
95949: CALL 108876 0 0
95953: GO 96001
95955: LD_INT 6
95957: DOUBLE
95958: EQUAL
95959: IFTRUE 95963
95961: GO 95970
95963: POP
// hHackChangeYourSide ; 7 :
95964: CALL 108933 0 0
95968: GO 96001
95970: LD_INT 7
95972: DOUBLE
95973: EQUAL
95974: IFTRUE 95978
95976: GO 95985
95978: POP
// hHackChangeUnitSide ; 8 :
95979: CALL 108975 0 0
95983: GO 96001
95985: LD_INT 8
95987: DOUBLE
95988: EQUAL
95989: IFTRUE 95993
95991: GO 96000
95993: POP
// hHackFog ; end ;
95994: CALL 109076 0 0
95998: GO 96001
96000: POP
// end ; end ;
96001: LD_VAR 0 7
96005: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
96006: GO 96008
96008: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
96009: LD_STRING initStreamRollete();
96011: PPUSH
96012: CALL_OW 559
// InitStreamMode ;
96016: CALL 96028 0 0
// DefineStreamItems ( false ) ;
96020: LD_INT 0
96022: PPUSH
96023: CALL 96492 0 1
// end ;
96027: END
// function InitStreamMode ; begin
96028: LD_INT 0
96030: PPUSH
// streamModeActive := false ;
96031: LD_ADDR_EXP 77
96035: PUSH
96036: LD_INT 0
96038: ST_TO_ADDR
// normalCounter := 36 ;
96039: LD_ADDR_EXP 78
96043: PUSH
96044: LD_INT 36
96046: ST_TO_ADDR
// hardcoreCounter := 18 ;
96047: LD_ADDR_EXP 79
96051: PUSH
96052: LD_INT 18
96054: ST_TO_ADDR
// sRocket := false ;
96055: LD_ADDR_EXP 82
96059: PUSH
96060: LD_INT 0
96062: ST_TO_ADDR
// sSpeed := false ;
96063: LD_ADDR_EXP 81
96067: PUSH
96068: LD_INT 0
96070: ST_TO_ADDR
// sEngine := false ;
96071: LD_ADDR_EXP 83
96075: PUSH
96076: LD_INT 0
96078: ST_TO_ADDR
// sSpec := false ;
96079: LD_ADDR_EXP 80
96083: PUSH
96084: LD_INT 0
96086: ST_TO_ADDR
// sLevel := false ;
96087: LD_ADDR_EXP 84
96091: PUSH
96092: LD_INT 0
96094: ST_TO_ADDR
// sArmoury := false ;
96095: LD_ADDR_EXP 85
96099: PUSH
96100: LD_INT 0
96102: ST_TO_ADDR
// sRadar := false ;
96103: LD_ADDR_EXP 86
96107: PUSH
96108: LD_INT 0
96110: ST_TO_ADDR
// sBunker := false ;
96111: LD_ADDR_EXP 87
96115: PUSH
96116: LD_INT 0
96118: ST_TO_ADDR
// sHack := false ;
96119: LD_ADDR_EXP 88
96123: PUSH
96124: LD_INT 0
96126: ST_TO_ADDR
// sFire := false ;
96127: LD_ADDR_EXP 89
96131: PUSH
96132: LD_INT 0
96134: ST_TO_ADDR
// sRefresh := false ;
96135: LD_ADDR_EXP 90
96139: PUSH
96140: LD_INT 0
96142: ST_TO_ADDR
// sExp := false ;
96143: LD_ADDR_EXP 91
96147: PUSH
96148: LD_INT 0
96150: ST_TO_ADDR
// sDepot := false ;
96151: LD_ADDR_EXP 92
96155: PUSH
96156: LD_INT 0
96158: ST_TO_ADDR
// sFlag := false ;
96159: LD_ADDR_EXP 93
96163: PUSH
96164: LD_INT 0
96166: ST_TO_ADDR
// sKamikadze := false ;
96167: LD_ADDR_EXP 101
96171: PUSH
96172: LD_INT 0
96174: ST_TO_ADDR
// sTroll := false ;
96175: LD_ADDR_EXP 102
96179: PUSH
96180: LD_INT 0
96182: ST_TO_ADDR
// sSlow := false ;
96183: LD_ADDR_EXP 103
96187: PUSH
96188: LD_INT 0
96190: ST_TO_ADDR
// sLack := false ;
96191: LD_ADDR_EXP 104
96195: PUSH
96196: LD_INT 0
96198: ST_TO_ADDR
// sTank := false ;
96199: LD_ADDR_EXP 106
96203: PUSH
96204: LD_INT 0
96206: ST_TO_ADDR
// sRemote := false ;
96207: LD_ADDR_EXP 107
96211: PUSH
96212: LD_INT 0
96214: ST_TO_ADDR
// sPowell := false ;
96215: LD_ADDR_EXP 108
96219: PUSH
96220: LD_INT 0
96222: ST_TO_ADDR
// sTeleport := false ;
96223: LD_ADDR_EXP 111
96227: PUSH
96228: LD_INT 0
96230: ST_TO_ADDR
// sOilTower := false ;
96231: LD_ADDR_EXP 113
96235: PUSH
96236: LD_INT 0
96238: ST_TO_ADDR
// sShovel := false ;
96239: LD_ADDR_EXP 114
96243: PUSH
96244: LD_INT 0
96246: ST_TO_ADDR
// sSheik := false ;
96247: LD_ADDR_EXP 115
96251: PUSH
96252: LD_INT 0
96254: ST_TO_ADDR
// sEarthquake := false ;
96255: LD_ADDR_EXP 117
96259: PUSH
96260: LD_INT 0
96262: ST_TO_ADDR
// sAI := false ;
96263: LD_ADDR_EXP 118
96267: PUSH
96268: LD_INT 0
96270: ST_TO_ADDR
// sCargo := false ;
96271: LD_ADDR_EXP 121
96275: PUSH
96276: LD_INT 0
96278: ST_TO_ADDR
// sDLaser := false ;
96279: LD_ADDR_EXP 122
96283: PUSH
96284: LD_INT 0
96286: ST_TO_ADDR
// sExchange := false ;
96287: LD_ADDR_EXP 123
96291: PUSH
96292: LD_INT 0
96294: ST_TO_ADDR
// sFac := false ;
96295: LD_ADDR_EXP 124
96299: PUSH
96300: LD_INT 0
96302: ST_TO_ADDR
// sPower := false ;
96303: LD_ADDR_EXP 125
96307: PUSH
96308: LD_INT 0
96310: ST_TO_ADDR
// sRandom := false ;
96311: LD_ADDR_EXP 126
96315: PUSH
96316: LD_INT 0
96318: ST_TO_ADDR
// sShield := false ;
96319: LD_ADDR_EXP 127
96323: PUSH
96324: LD_INT 0
96326: ST_TO_ADDR
// sTime := false ;
96327: LD_ADDR_EXP 128
96331: PUSH
96332: LD_INT 0
96334: ST_TO_ADDR
// sTools := false ;
96335: LD_ADDR_EXP 129
96339: PUSH
96340: LD_INT 0
96342: ST_TO_ADDR
// sSold := false ;
96343: LD_ADDR_EXP 94
96347: PUSH
96348: LD_INT 0
96350: ST_TO_ADDR
// sDiff := false ;
96351: LD_ADDR_EXP 95
96355: PUSH
96356: LD_INT 0
96358: ST_TO_ADDR
// sFog := false ;
96359: LD_ADDR_EXP 98
96363: PUSH
96364: LD_INT 0
96366: ST_TO_ADDR
// sReset := false ;
96367: LD_ADDR_EXP 99
96371: PUSH
96372: LD_INT 0
96374: ST_TO_ADDR
// sSun := false ;
96375: LD_ADDR_EXP 100
96379: PUSH
96380: LD_INT 0
96382: ST_TO_ADDR
// sTiger := false ;
96383: LD_ADDR_EXP 96
96387: PUSH
96388: LD_INT 0
96390: ST_TO_ADDR
// sBomb := false ;
96391: LD_ADDR_EXP 97
96395: PUSH
96396: LD_INT 0
96398: ST_TO_ADDR
// sWound := false ;
96399: LD_ADDR_EXP 105
96403: PUSH
96404: LD_INT 0
96406: ST_TO_ADDR
// sBetray := false ;
96407: LD_ADDR_EXP 109
96411: PUSH
96412: LD_INT 0
96414: ST_TO_ADDR
// sContamin := false ;
96415: LD_ADDR_EXP 110
96419: PUSH
96420: LD_INT 0
96422: ST_TO_ADDR
// sOil := false ;
96423: LD_ADDR_EXP 112
96427: PUSH
96428: LD_INT 0
96430: ST_TO_ADDR
// sStu := false ;
96431: LD_ADDR_EXP 116
96435: PUSH
96436: LD_INT 0
96438: ST_TO_ADDR
// sBazooka := false ;
96439: LD_ADDR_EXP 119
96443: PUSH
96444: LD_INT 0
96446: ST_TO_ADDR
// sMortar := false ;
96447: LD_ADDR_EXP 120
96451: PUSH
96452: LD_INT 0
96454: ST_TO_ADDR
// sRanger := false ;
96455: LD_ADDR_EXP 130
96459: PUSH
96460: LD_INT 0
96462: ST_TO_ADDR
// sComputer := false ;
96463: LD_ADDR_EXP 131
96467: PUSH
96468: LD_INT 0
96470: ST_TO_ADDR
// s30 := false ;
96471: LD_ADDR_EXP 132
96475: PUSH
96476: LD_INT 0
96478: ST_TO_ADDR
// s60 := false ;
96479: LD_ADDR_EXP 133
96483: PUSH
96484: LD_INT 0
96486: ST_TO_ADDR
// end ;
96487: LD_VAR 0 1
96491: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96492: LD_INT 0
96494: PPUSH
96495: PPUSH
96496: PPUSH
96497: PPUSH
96498: PPUSH
96499: PPUSH
96500: PPUSH
// result := [ ] ;
96501: LD_ADDR_VAR 0 2
96505: PUSH
96506: EMPTY
96507: ST_TO_ADDR
// if campaign_id = 1 then
96508: LD_OWVAR 69
96512: PUSH
96513: LD_INT 1
96515: EQUAL
96516: IFFALSE 99682
// begin case mission_number of 1 :
96518: LD_OWVAR 70
96522: PUSH
96523: LD_INT 1
96525: DOUBLE
96526: EQUAL
96527: IFTRUE 96531
96529: GO 96607
96531: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96532: LD_ADDR_VAR 0 2
96536: PUSH
96537: LD_INT 2
96539: PUSH
96540: LD_INT 4
96542: PUSH
96543: LD_INT 11
96545: PUSH
96546: LD_INT 12
96548: PUSH
96549: LD_INT 15
96551: PUSH
96552: LD_INT 16
96554: PUSH
96555: LD_INT 22
96557: PUSH
96558: LD_INT 23
96560: PUSH
96561: LD_INT 26
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 101
96577: PUSH
96578: LD_INT 102
96580: PUSH
96581: LD_INT 106
96583: PUSH
96584: LD_INT 116
96586: PUSH
96587: LD_INT 117
96589: PUSH
96590: LD_INT 118
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: ST_TO_ADDR
96605: GO 99680
96607: LD_INT 2
96609: DOUBLE
96610: EQUAL
96611: IFTRUE 96615
96613: GO 96699
96615: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96616: LD_ADDR_VAR 0 2
96620: PUSH
96621: LD_INT 2
96623: PUSH
96624: LD_INT 4
96626: PUSH
96627: LD_INT 11
96629: PUSH
96630: LD_INT 12
96632: PUSH
96633: LD_INT 15
96635: PUSH
96636: LD_INT 16
96638: PUSH
96639: LD_INT 22
96641: PUSH
96642: LD_INT 23
96644: PUSH
96645: LD_INT 26
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: PUSH
96659: LD_INT 101
96661: PUSH
96662: LD_INT 102
96664: PUSH
96665: LD_INT 105
96667: PUSH
96668: LD_INT 106
96670: PUSH
96671: LD_INT 108
96673: PUSH
96674: LD_INT 116
96676: PUSH
96677: LD_INT 117
96679: PUSH
96680: LD_INT 118
96682: PUSH
96683: EMPTY
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: ST_TO_ADDR
96697: GO 99680
96699: LD_INT 3
96701: DOUBLE
96702: EQUAL
96703: IFTRUE 96707
96705: GO 96795
96707: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96708: LD_ADDR_VAR 0 2
96712: PUSH
96713: LD_INT 2
96715: PUSH
96716: LD_INT 4
96718: PUSH
96719: LD_INT 5
96721: PUSH
96722: LD_INT 11
96724: PUSH
96725: LD_INT 12
96727: PUSH
96728: LD_INT 15
96730: PUSH
96731: LD_INT 16
96733: PUSH
96734: LD_INT 22
96736: PUSH
96737: LD_INT 26
96739: PUSH
96740: LD_INT 36
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 101
96757: PUSH
96758: LD_INT 102
96760: PUSH
96761: LD_INT 105
96763: PUSH
96764: LD_INT 106
96766: PUSH
96767: LD_INT 108
96769: PUSH
96770: LD_INT 116
96772: PUSH
96773: LD_INT 117
96775: PUSH
96776: LD_INT 118
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: ST_TO_ADDR
96793: GO 99680
96795: LD_INT 4
96797: DOUBLE
96798: EQUAL
96799: IFTRUE 96803
96801: GO 96899
96803: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96804: LD_ADDR_VAR 0 2
96808: PUSH
96809: LD_INT 2
96811: PUSH
96812: LD_INT 4
96814: PUSH
96815: LD_INT 5
96817: PUSH
96818: LD_INT 8
96820: PUSH
96821: LD_INT 11
96823: PUSH
96824: LD_INT 12
96826: PUSH
96827: LD_INT 15
96829: PUSH
96830: LD_INT 16
96832: PUSH
96833: LD_INT 22
96835: PUSH
96836: LD_INT 23
96838: PUSH
96839: LD_INT 26
96841: PUSH
96842: LD_INT 36
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 101
96861: PUSH
96862: LD_INT 102
96864: PUSH
96865: LD_INT 105
96867: PUSH
96868: LD_INT 106
96870: PUSH
96871: LD_INT 108
96873: PUSH
96874: LD_INT 116
96876: PUSH
96877: LD_INT 117
96879: PUSH
96880: LD_INT 118
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: ST_TO_ADDR
96897: GO 99680
96899: LD_INT 5
96901: DOUBLE
96902: EQUAL
96903: IFTRUE 96907
96905: GO 97019
96907: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96908: LD_ADDR_VAR 0 2
96912: PUSH
96913: LD_INT 2
96915: PUSH
96916: LD_INT 4
96918: PUSH
96919: LD_INT 5
96921: PUSH
96922: LD_INT 6
96924: PUSH
96925: LD_INT 8
96927: PUSH
96928: LD_INT 11
96930: PUSH
96931: LD_INT 12
96933: PUSH
96934: LD_INT 15
96936: PUSH
96937: LD_INT 16
96939: PUSH
96940: LD_INT 22
96942: PUSH
96943: LD_INT 23
96945: PUSH
96946: LD_INT 25
96948: PUSH
96949: LD_INT 26
96951: PUSH
96952: LD_INT 36
96954: PUSH
96955: EMPTY
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 101
96973: PUSH
96974: LD_INT 102
96976: PUSH
96977: LD_INT 105
96979: PUSH
96980: LD_INT 106
96982: PUSH
96983: LD_INT 108
96985: PUSH
96986: LD_INT 109
96988: PUSH
96989: LD_INT 112
96991: PUSH
96992: LD_INT 116
96994: PUSH
96995: LD_INT 117
96997: PUSH
96998: LD_INT 118
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: LIST
97005: LIST
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: ST_TO_ADDR
97017: GO 99680
97019: LD_INT 6
97021: DOUBLE
97022: EQUAL
97023: IFTRUE 97027
97025: GO 97159
97027: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97028: LD_ADDR_VAR 0 2
97032: PUSH
97033: LD_INT 2
97035: PUSH
97036: LD_INT 4
97038: PUSH
97039: LD_INT 5
97041: PUSH
97042: LD_INT 6
97044: PUSH
97045: LD_INT 8
97047: PUSH
97048: LD_INT 11
97050: PUSH
97051: LD_INT 12
97053: PUSH
97054: LD_INT 15
97056: PUSH
97057: LD_INT 16
97059: PUSH
97060: LD_INT 20
97062: PUSH
97063: LD_INT 21
97065: PUSH
97066: LD_INT 22
97068: PUSH
97069: LD_INT 23
97071: PUSH
97072: LD_INT 25
97074: PUSH
97075: LD_INT 26
97077: PUSH
97078: LD_INT 30
97080: PUSH
97081: LD_INT 31
97083: PUSH
97084: LD_INT 32
97086: PUSH
97087: LD_INT 36
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: PUSH
97111: LD_INT 101
97113: PUSH
97114: LD_INT 102
97116: PUSH
97117: LD_INT 105
97119: PUSH
97120: LD_INT 106
97122: PUSH
97123: LD_INT 108
97125: PUSH
97126: LD_INT 109
97128: PUSH
97129: LD_INT 112
97131: PUSH
97132: LD_INT 116
97134: PUSH
97135: LD_INT 117
97137: PUSH
97138: LD_INT 118
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: ST_TO_ADDR
97157: GO 99680
97159: LD_INT 7
97161: DOUBLE
97162: EQUAL
97163: IFTRUE 97167
97165: GO 97279
97167: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97168: LD_ADDR_VAR 0 2
97172: PUSH
97173: LD_INT 2
97175: PUSH
97176: LD_INT 4
97178: PUSH
97179: LD_INT 5
97181: PUSH
97182: LD_INT 7
97184: PUSH
97185: LD_INT 11
97187: PUSH
97188: LD_INT 12
97190: PUSH
97191: LD_INT 15
97193: PUSH
97194: LD_INT 16
97196: PUSH
97197: LD_INT 20
97199: PUSH
97200: LD_INT 21
97202: PUSH
97203: LD_INT 22
97205: PUSH
97206: LD_INT 23
97208: PUSH
97209: LD_INT 25
97211: PUSH
97212: LD_INT 26
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: PUSH
97231: LD_INT 101
97233: PUSH
97234: LD_INT 102
97236: PUSH
97237: LD_INT 103
97239: PUSH
97240: LD_INT 105
97242: PUSH
97243: LD_INT 106
97245: PUSH
97246: LD_INT 108
97248: PUSH
97249: LD_INT 112
97251: PUSH
97252: LD_INT 116
97254: PUSH
97255: LD_INT 117
97257: PUSH
97258: LD_INT 118
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: ST_TO_ADDR
97277: GO 99680
97279: LD_INT 8
97281: DOUBLE
97282: EQUAL
97283: IFTRUE 97287
97285: GO 97427
97287: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97288: LD_ADDR_VAR 0 2
97292: PUSH
97293: LD_INT 2
97295: PUSH
97296: LD_INT 4
97298: PUSH
97299: LD_INT 5
97301: PUSH
97302: LD_INT 6
97304: PUSH
97305: LD_INT 7
97307: PUSH
97308: LD_INT 8
97310: PUSH
97311: LD_INT 11
97313: PUSH
97314: LD_INT 12
97316: PUSH
97317: LD_INT 15
97319: PUSH
97320: LD_INT 16
97322: PUSH
97323: LD_INT 20
97325: PUSH
97326: LD_INT 21
97328: PUSH
97329: LD_INT 22
97331: PUSH
97332: LD_INT 23
97334: PUSH
97335: LD_INT 25
97337: PUSH
97338: LD_INT 26
97340: PUSH
97341: LD_INT 30
97343: PUSH
97344: LD_INT 31
97346: PUSH
97347: LD_INT 32
97349: PUSH
97350: LD_INT 36
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: PUSH
97375: LD_INT 101
97377: PUSH
97378: LD_INT 102
97380: PUSH
97381: LD_INT 103
97383: PUSH
97384: LD_INT 105
97386: PUSH
97387: LD_INT 106
97389: PUSH
97390: LD_INT 108
97392: PUSH
97393: LD_INT 109
97395: PUSH
97396: LD_INT 112
97398: PUSH
97399: LD_INT 116
97401: PUSH
97402: LD_INT 117
97404: PUSH
97405: LD_INT 118
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: PUSH
97421: EMPTY
97422: LIST
97423: LIST
97424: ST_TO_ADDR
97425: GO 99680
97427: LD_INT 9
97429: DOUBLE
97430: EQUAL
97431: IFTRUE 97435
97433: GO 97583
97435: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97436: LD_ADDR_VAR 0 2
97440: PUSH
97441: LD_INT 2
97443: PUSH
97444: LD_INT 4
97446: PUSH
97447: LD_INT 5
97449: PUSH
97450: LD_INT 6
97452: PUSH
97453: LD_INT 7
97455: PUSH
97456: LD_INT 8
97458: PUSH
97459: LD_INT 11
97461: PUSH
97462: LD_INT 12
97464: PUSH
97465: LD_INT 15
97467: PUSH
97468: LD_INT 16
97470: PUSH
97471: LD_INT 20
97473: PUSH
97474: LD_INT 21
97476: PUSH
97477: LD_INT 22
97479: PUSH
97480: LD_INT 23
97482: PUSH
97483: LD_INT 25
97485: PUSH
97486: LD_INT 26
97488: PUSH
97489: LD_INT 28
97491: PUSH
97492: LD_INT 30
97494: PUSH
97495: LD_INT 31
97497: PUSH
97498: LD_INT 32
97500: PUSH
97501: LD_INT 36
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: PUSH
97527: LD_INT 101
97529: PUSH
97530: LD_INT 102
97532: PUSH
97533: LD_INT 103
97535: PUSH
97536: LD_INT 105
97538: PUSH
97539: LD_INT 106
97541: PUSH
97542: LD_INT 108
97544: PUSH
97545: LD_INT 109
97547: PUSH
97548: LD_INT 112
97550: PUSH
97551: LD_INT 114
97553: PUSH
97554: LD_INT 116
97556: PUSH
97557: LD_INT 117
97559: PUSH
97560: LD_INT 118
97562: PUSH
97563: EMPTY
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: ST_TO_ADDR
97581: GO 99680
97583: LD_INT 10
97585: DOUBLE
97586: EQUAL
97587: IFTRUE 97591
97589: GO 97787
97591: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97592: LD_ADDR_VAR 0 2
97596: PUSH
97597: LD_INT 2
97599: PUSH
97600: LD_INT 4
97602: PUSH
97603: LD_INT 5
97605: PUSH
97606: LD_INT 6
97608: PUSH
97609: LD_INT 7
97611: PUSH
97612: LD_INT 8
97614: PUSH
97615: LD_INT 9
97617: PUSH
97618: LD_INT 10
97620: PUSH
97621: LD_INT 11
97623: PUSH
97624: LD_INT 12
97626: PUSH
97627: LD_INT 13
97629: PUSH
97630: LD_INT 14
97632: PUSH
97633: LD_INT 15
97635: PUSH
97636: LD_INT 16
97638: PUSH
97639: LD_INT 17
97641: PUSH
97642: LD_INT 18
97644: PUSH
97645: LD_INT 19
97647: PUSH
97648: LD_INT 20
97650: PUSH
97651: LD_INT 21
97653: PUSH
97654: LD_INT 22
97656: PUSH
97657: LD_INT 23
97659: PUSH
97660: LD_INT 24
97662: PUSH
97663: LD_INT 25
97665: PUSH
97666: LD_INT 26
97668: PUSH
97669: LD_INT 28
97671: PUSH
97672: LD_INT 30
97674: PUSH
97675: LD_INT 31
97677: PUSH
97678: LD_INT 32
97680: PUSH
97681: LD_INT 36
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: PUSH
97715: LD_INT 101
97717: PUSH
97718: LD_INT 102
97720: PUSH
97721: LD_INT 103
97723: PUSH
97724: LD_INT 104
97726: PUSH
97727: LD_INT 105
97729: PUSH
97730: LD_INT 106
97732: PUSH
97733: LD_INT 107
97735: PUSH
97736: LD_INT 108
97738: PUSH
97739: LD_INT 109
97741: PUSH
97742: LD_INT 110
97744: PUSH
97745: LD_INT 111
97747: PUSH
97748: LD_INT 112
97750: PUSH
97751: LD_INT 114
97753: PUSH
97754: LD_INT 116
97756: PUSH
97757: LD_INT 117
97759: PUSH
97760: LD_INT 118
97762: PUSH
97763: EMPTY
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: ST_TO_ADDR
97785: GO 99680
97787: LD_INT 11
97789: DOUBLE
97790: EQUAL
97791: IFTRUE 97795
97793: GO 97999
97795: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97796: LD_ADDR_VAR 0 2
97800: PUSH
97801: LD_INT 2
97803: PUSH
97804: LD_INT 3
97806: PUSH
97807: LD_INT 4
97809: PUSH
97810: LD_INT 5
97812: PUSH
97813: LD_INT 6
97815: PUSH
97816: LD_INT 7
97818: PUSH
97819: LD_INT 8
97821: PUSH
97822: LD_INT 9
97824: PUSH
97825: LD_INT 10
97827: PUSH
97828: LD_INT 11
97830: PUSH
97831: LD_INT 12
97833: PUSH
97834: LD_INT 13
97836: PUSH
97837: LD_INT 14
97839: PUSH
97840: LD_INT 15
97842: PUSH
97843: LD_INT 16
97845: PUSH
97846: LD_INT 17
97848: PUSH
97849: LD_INT 18
97851: PUSH
97852: LD_INT 19
97854: PUSH
97855: LD_INT 20
97857: PUSH
97858: LD_INT 21
97860: PUSH
97861: LD_INT 22
97863: PUSH
97864: LD_INT 23
97866: PUSH
97867: LD_INT 24
97869: PUSH
97870: LD_INT 25
97872: PUSH
97873: LD_INT 26
97875: PUSH
97876: LD_INT 28
97878: PUSH
97879: LD_INT 30
97881: PUSH
97882: LD_INT 31
97884: PUSH
97885: LD_INT 32
97887: PUSH
97888: LD_INT 34
97890: PUSH
97891: LD_INT 36
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: PUSH
97927: LD_INT 101
97929: PUSH
97930: LD_INT 102
97932: PUSH
97933: LD_INT 103
97935: PUSH
97936: LD_INT 104
97938: PUSH
97939: LD_INT 105
97941: PUSH
97942: LD_INT 106
97944: PUSH
97945: LD_INT 107
97947: PUSH
97948: LD_INT 108
97950: PUSH
97951: LD_INT 109
97953: PUSH
97954: LD_INT 110
97956: PUSH
97957: LD_INT 111
97959: PUSH
97960: LD_INT 112
97962: PUSH
97963: LD_INT 114
97965: PUSH
97966: LD_INT 116
97968: PUSH
97969: LD_INT 117
97971: PUSH
97972: LD_INT 118
97974: PUSH
97975: EMPTY
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: PUSH
97993: EMPTY
97994: LIST
97995: LIST
97996: ST_TO_ADDR
97997: GO 99680
97999: LD_INT 12
98001: DOUBLE
98002: EQUAL
98003: IFTRUE 98007
98005: GO 98227
98007: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98008: LD_ADDR_VAR 0 2
98012: PUSH
98013: LD_INT 1
98015: PUSH
98016: LD_INT 2
98018: PUSH
98019: LD_INT 3
98021: PUSH
98022: LD_INT 4
98024: PUSH
98025: LD_INT 5
98027: PUSH
98028: LD_INT 6
98030: PUSH
98031: LD_INT 7
98033: PUSH
98034: LD_INT 8
98036: PUSH
98037: LD_INT 9
98039: PUSH
98040: LD_INT 10
98042: PUSH
98043: LD_INT 11
98045: PUSH
98046: LD_INT 12
98048: PUSH
98049: LD_INT 13
98051: PUSH
98052: LD_INT 14
98054: PUSH
98055: LD_INT 15
98057: PUSH
98058: LD_INT 16
98060: PUSH
98061: LD_INT 17
98063: PUSH
98064: LD_INT 18
98066: PUSH
98067: LD_INT 19
98069: PUSH
98070: LD_INT 20
98072: PUSH
98073: LD_INT 21
98075: PUSH
98076: LD_INT 22
98078: PUSH
98079: LD_INT 23
98081: PUSH
98082: LD_INT 24
98084: PUSH
98085: LD_INT 25
98087: PUSH
98088: LD_INT 26
98090: PUSH
98091: LD_INT 27
98093: PUSH
98094: LD_INT 28
98096: PUSH
98097: LD_INT 30
98099: PUSH
98100: LD_INT 31
98102: PUSH
98103: LD_INT 32
98105: PUSH
98106: LD_INT 33
98108: PUSH
98109: LD_INT 34
98111: PUSH
98112: LD_INT 36
98114: PUSH
98115: EMPTY
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 101
98153: PUSH
98154: LD_INT 102
98156: PUSH
98157: LD_INT 103
98159: PUSH
98160: LD_INT 104
98162: PUSH
98163: LD_INT 105
98165: PUSH
98166: LD_INT 106
98168: PUSH
98169: LD_INT 107
98171: PUSH
98172: LD_INT 108
98174: PUSH
98175: LD_INT 109
98177: PUSH
98178: LD_INT 110
98180: PUSH
98181: LD_INT 111
98183: PUSH
98184: LD_INT 112
98186: PUSH
98187: LD_INT 113
98189: PUSH
98190: LD_INT 114
98192: PUSH
98193: LD_INT 116
98195: PUSH
98196: LD_INT 117
98198: PUSH
98199: LD_INT 118
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: ST_TO_ADDR
98225: GO 99680
98227: LD_INT 13
98229: DOUBLE
98230: EQUAL
98231: IFTRUE 98235
98233: GO 98443
98235: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98236: LD_ADDR_VAR 0 2
98240: PUSH
98241: LD_INT 1
98243: PUSH
98244: LD_INT 2
98246: PUSH
98247: LD_INT 3
98249: PUSH
98250: LD_INT 4
98252: PUSH
98253: LD_INT 5
98255: PUSH
98256: LD_INT 8
98258: PUSH
98259: LD_INT 9
98261: PUSH
98262: LD_INT 10
98264: PUSH
98265: LD_INT 11
98267: PUSH
98268: LD_INT 12
98270: PUSH
98271: LD_INT 14
98273: PUSH
98274: LD_INT 15
98276: PUSH
98277: LD_INT 16
98279: PUSH
98280: LD_INT 17
98282: PUSH
98283: LD_INT 18
98285: PUSH
98286: LD_INT 19
98288: PUSH
98289: LD_INT 20
98291: PUSH
98292: LD_INT 21
98294: PUSH
98295: LD_INT 22
98297: PUSH
98298: LD_INT 23
98300: PUSH
98301: LD_INT 24
98303: PUSH
98304: LD_INT 25
98306: PUSH
98307: LD_INT 26
98309: PUSH
98310: LD_INT 27
98312: PUSH
98313: LD_INT 28
98315: PUSH
98316: LD_INT 30
98318: PUSH
98319: LD_INT 31
98321: PUSH
98322: LD_INT 32
98324: PUSH
98325: LD_INT 33
98327: PUSH
98328: LD_INT 34
98330: PUSH
98331: LD_INT 36
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: PUSH
98367: LD_INT 101
98369: PUSH
98370: LD_INT 102
98372: PUSH
98373: LD_INT 103
98375: PUSH
98376: LD_INT 104
98378: PUSH
98379: LD_INT 105
98381: PUSH
98382: LD_INT 106
98384: PUSH
98385: LD_INT 107
98387: PUSH
98388: LD_INT 108
98390: PUSH
98391: LD_INT 109
98393: PUSH
98394: LD_INT 110
98396: PUSH
98397: LD_INT 111
98399: PUSH
98400: LD_INT 112
98402: PUSH
98403: LD_INT 113
98405: PUSH
98406: LD_INT 114
98408: PUSH
98409: LD_INT 116
98411: PUSH
98412: LD_INT 117
98414: PUSH
98415: LD_INT 118
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: LIST
98434: LIST
98435: LIST
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: ST_TO_ADDR
98441: GO 99680
98443: LD_INT 14
98445: DOUBLE
98446: EQUAL
98447: IFTRUE 98451
98449: GO 98675
98451: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98452: LD_ADDR_VAR 0 2
98456: PUSH
98457: LD_INT 1
98459: PUSH
98460: LD_INT 2
98462: PUSH
98463: LD_INT 3
98465: PUSH
98466: LD_INT 4
98468: PUSH
98469: LD_INT 5
98471: PUSH
98472: LD_INT 6
98474: PUSH
98475: LD_INT 7
98477: PUSH
98478: LD_INT 8
98480: PUSH
98481: LD_INT 9
98483: PUSH
98484: LD_INT 10
98486: PUSH
98487: LD_INT 11
98489: PUSH
98490: LD_INT 12
98492: PUSH
98493: LD_INT 13
98495: PUSH
98496: LD_INT 14
98498: PUSH
98499: LD_INT 15
98501: PUSH
98502: LD_INT 16
98504: PUSH
98505: LD_INT 17
98507: PUSH
98508: LD_INT 18
98510: PUSH
98511: LD_INT 19
98513: PUSH
98514: LD_INT 20
98516: PUSH
98517: LD_INT 21
98519: PUSH
98520: LD_INT 22
98522: PUSH
98523: LD_INT 23
98525: PUSH
98526: LD_INT 24
98528: PUSH
98529: LD_INT 25
98531: PUSH
98532: LD_INT 26
98534: PUSH
98535: LD_INT 27
98537: PUSH
98538: LD_INT 28
98540: PUSH
98541: LD_INT 29
98543: PUSH
98544: LD_INT 30
98546: PUSH
98547: LD_INT 31
98549: PUSH
98550: LD_INT 32
98552: PUSH
98553: LD_INT 33
98555: PUSH
98556: LD_INT 34
98558: PUSH
98559: LD_INT 36
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: LIST
98592: LIST
98593: LIST
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: PUSH
98599: LD_INT 101
98601: PUSH
98602: LD_INT 102
98604: PUSH
98605: LD_INT 103
98607: PUSH
98608: LD_INT 104
98610: PUSH
98611: LD_INT 105
98613: PUSH
98614: LD_INT 106
98616: PUSH
98617: LD_INT 107
98619: PUSH
98620: LD_INT 108
98622: PUSH
98623: LD_INT 109
98625: PUSH
98626: LD_INT 110
98628: PUSH
98629: LD_INT 111
98631: PUSH
98632: LD_INT 112
98634: PUSH
98635: LD_INT 113
98637: PUSH
98638: LD_INT 114
98640: PUSH
98641: LD_INT 116
98643: PUSH
98644: LD_INT 117
98646: PUSH
98647: LD_INT 118
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: LIST
98665: LIST
98666: LIST
98667: LIST
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: ST_TO_ADDR
98673: GO 99680
98675: LD_INT 15
98677: DOUBLE
98678: EQUAL
98679: IFTRUE 98683
98681: GO 98907
98683: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98684: LD_ADDR_VAR 0 2
98688: PUSH
98689: LD_INT 1
98691: PUSH
98692: LD_INT 2
98694: PUSH
98695: LD_INT 3
98697: PUSH
98698: LD_INT 4
98700: PUSH
98701: LD_INT 5
98703: PUSH
98704: LD_INT 6
98706: PUSH
98707: LD_INT 7
98709: PUSH
98710: LD_INT 8
98712: PUSH
98713: LD_INT 9
98715: PUSH
98716: LD_INT 10
98718: PUSH
98719: LD_INT 11
98721: PUSH
98722: LD_INT 12
98724: PUSH
98725: LD_INT 13
98727: PUSH
98728: LD_INT 14
98730: PUSH
98731: LD_INT 15
98733: PUSH
98734: LD_INT 16
98736: PUSH
98737: LD_INT 17
98739: PUSH
98740: LD_INT 18
98742: PUSH
98743: LD_INT 19
98745: PUSH
98746: LD_INT 20
98748: PUSH
98749: LD_INT 21
98751: PUSH
98752: LD_INT 22
98754: PUSH
98755: LD_INT 23
98757: PUSH
98758: LD_INT 24
98760: PUSH
98761: LD_INT 25
98763: PUSH
98764: LD_INT 26
98766: PUSH
98767: LD_INT 27
98769: PUSH
98770: LD_INT 28
98772: PUSH
98773: LD_INT 29
98775: PUSH
98776: LD_INT 30
98778: PUSH
98779: LD_INT 31
98781: PUSH
98782: LD_INT 32
98784: PUSH
98785: LD_INT 33
98787: PUSH
98788: LD_INT 34
98790: PUSH
98791: LD_INT 36
98793: PUSH
98794: EMPTY
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: PUSH
98831: LD_INT 101
98833: PUSH
98834: LD_INT 102
98836: PUSH
98837: LD_INT 103
98839: PUSH
98840: LD_INT 104
98842: PUSH
98843: LD_INT 105
98845: PUSH
98846: LD_INT 106
98848: PUSH
98849: LD_INT 107
98851: PUSH
98852: LD_INT 108
98854: PUSH
98855: LD_INT 109
98857: PUSH
98858: LD_INT 110
98860: PUSH
98861: LD_INT 111
98863: PUSH
98864: LD_INT 112
98866: PUSH
98867: LD_INT 113
98869: PUSH
98870: LD_INT 114
98872: PUSH
98873: LD_INT 116
98875: PUSH
98876: LD_INT 117
98878: PUSH
98879: LD_INT 118
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: LIST
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: LIST
98896: LIST
98897: LIST
98898: LIST
98899: LIST
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: ST_TO_ADDR
98905: GO 99680
98907: LD_INT 16
98909: DOUBLE
98910: EQUAL
98911: IFTRUE 98915
98913: GO 99051
98915: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98916: LD_ADDR_VAR 0 2
98920: PUSH
98921: LD_INT 2
98923: PUSH
98924: LD_INT 4
98926: PUSH
98927: LD_INT 5
98929: PUSH
98930: LD_INT 7
98932: PUSH
98933: LD_INT 11
98935: PUSH
98936: LD_INT 12
98938: PUSH
98939: LD_INT 15
98941: PUSH
98942: LD_INT 16
98944: PUSH
98945: LD_INT 20
98947: PUSH
98948: LD_INT 21
98950: PUSH
98951: LD_INT 22
98953: PUSH
98954: LD_INT 23
98956: PUSH
98957: LD_INT 25
98959: PUSH
98960: LD_INT 26
98962: PUSH
98963: LD_INT 30
98965: PUSH
98966: LD_INT 31
98968: PUSH
98969: LD_INT 32
98971: PUSH
98972: LD_INT 33
98974: PUSH
98975: LD_INT 34
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: PUSH
98999: LD_INT 101
99001: PUSH
99002: LD_INT 102
99004: PUSH
99005: LD_INT 103
99007: PUSH
99008: LD_INT 106
99010: PUSH
99011: LD_INT 108
99013: PUSH
99014: LD_INT 112
99016: PUSH
99017: LD_INT 113
99019: PUSH
99020: LD_INT 114
99022: PUSH
99023: LD_INT 116
99025: PUSH
99026: LD_INT 117
99028: PUSH
99029: LD_INT 118
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: LIST
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: PUSH
99045: EMPTY
99046: LIST
99047: LIST
99048: ST_TO_ADDR
99049: GO 99680
99051: LD_INT 17
99053: DOUBLE
99054: EQUAL
99055: IFTRUE 99059
99057: GO 99283
99059: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99060: LD_ADDR_VAR 0 2
99064: PUSH
99065: LD_INT 1
99067: PUSH
99068: LD_INT 2
99070: PUSH
99071: LD_INT 3
99073: PUSH
99074: LD_INT 4
99076: PUSH
99077: LD_INT 5
99079: PUSH
99080: LD_INT 6
99082: PUSH
99083: LD_INT 7
99085: PUSH
99086: LD_INT 8
99088: PUSH
99089: LD_INT 9
99091: PUSH
99092: LD_INT 10
99094: PUSH
99095: LD_INT 11
99097: PUSH
99098: LD_INT 12
99100: PUSH
99101: LD_INT 13
99103: PUSH
99104: LD_INT 14
99106: PUSH
99107: LD_INT 15
99109: PUSH
99110: LD_INT 16
99112: PUSH
99113: LD_INT 17
99115: PUSH
99116: LD_INT 18
99118: PUSH
99119: LD_INT 19
99121: PUSH
99122: LD_INT 20
99124: PUSH
99125: LD_INT 21
99127: PUSH
99128: LD_INT 22
99130: PUSH
99131: LD_INT 23
99133: PUSH
99134: LD_INT 24
99136: PUSH
99137: LD_INT 25
99139: PUSH
99140: LD_INT 26
99142: PUSH
99143: LD_INT 27
99145: PUSH
99146: LD_INT 28
99148: PUSH
99149: LD_INT 29
99151: PUSH
99152: LD_INT 30
99154: PUSH
99155: LD_INT 31
99157: PUSH
99158: LD_INT 32
99160: PUSH
99161: LD_INT 33
99163: PUSH
99164: LD_INT 34
99166: PUSH
99167: LD_INT 36
99169: PUSH
99170: EMPTY
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: LIST
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: LIST
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: LIST
99206: PUSH
99207: LD_INT 101
99209: PUSH
99210: LD_INT 102
99212: PUSH
99213: LD_INT 103
99215: PUSH
99216: LD_INT 104
99218: PUSH
99219: LD_INT 105
99221: PUSH
99222: LD_INT 106
99224: PUSH
99225: LD_INT 107
99227: PUSH
99228: LD_INT 108
99230: PUSH
99231: LD_INT 109
99233: PUSH
99234: LD_INT 110
99236: PUSH
99237: LD_INT 111
99239: PUSH
99240: LD_INT 112
99242: PUSH
99243: LD_INT 113
99245: PUSH
99246: LD_INT 114
99248: PUSH
99249: LD_INT 116
99251: PUSH
99252: LD_INT 117
99254: PUSH
99255: LD_INT 118
99257: PUSH
99258: EMPTY
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: PUSH
99277: EMPTY
99278: LIST
99279: LIST
99280: ST_TO_ADDR
99281: GO 99680
99283: LD_INT 18
99285: DOUBLE
99286: EQUAL
99287: IFTRUE 99291
99289: GO 99439
99291: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99292: LD_ADDR_VAR 0 2
99296: PUSH
99297: LD_INT 2
99299: PUSH
99300: LD_INT 4
99302: PUSH
99303: LD_INT 5
99305: PUSH
99306: LD_INT 7
99308: PUSH
99309: LD_INT 11
99311: PUSH
99312: LD_INT 12
99314: PUSH
99315: LD_INT 15
99317: PUSH
99318: LD_INT 16
99320: PUSH
99321: LD_INT 20
99323: PUSH
99324: LD_INT 21
99326: PUSH
99327: LD_INT 22
99329: PUSH
99330: LD_INT 23
99332: PUSH
99333: LD_INT 25
99335: PUSH
99336: LD_INT 26
99338: PUSH
99339: LD_INT 30
99341: PUSH
99342: LD_INT 31
99344: PUSH
99345: LD_INT 32
99347: PUSH
99348: LD_INT 33
99350: PUSH
99351: LD_INT 34
99353: PUSH
99354: LD_INT 35
99356: PUSH
99357: LD_INT 36
99359: PUSH
99360: EMPTY
99361: LIST
99362: LIST
99363: LIST
99364: LIST
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: LIST
99370: LIST
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: PUSH
99383: LD_INT 101
99385: PUSH
99386: LD_INT 102
99388: PUSH
99389: LD_INT 103
99391: PUSH
99392: LD_INT 106
99394: PUSH
99395: LD_INT 108
99397: PUSH
99398: LD_INT 112
99400: PUSH
99401: LD_INT 113
99403: PUSH
99404: LD_INT 114
99406: PUSH
99407: LD_INT 115
99409: PUSH
99410: LD_INT 116
99412: PUSH
99413: LD_INT 117
99415: PUSH
99416: LD_INT 118
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: ST_TO_ADDR
99437: GO 99680
99439: LD_INT 19
99441: DOUBLE
99442: EQUAL
99443: IFTRUE 99447
99445: GO 99679
99447: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99448: LD_ADDR_VAR 0 2
99452: PUSH
99453: LD_INT 1
99455: PUSH
99456: LD_INT 2
99458: PUSH
99459: LD_INT 3
99461: PUSH
99462: LD_INT 4
99464: PUSH
99465: LD_INT 5
99467: PUSH
99468: LD_INT 6
99470: PUSH
99471: LD_INT 7
99473: PUSH
99474: LD_INT 8
99476: PUSH
99477: LD_INT 9
99479: PUSH
99480: LD_INT 10
99482: PUSH
99483: LD_INT 11
99485: PUSH
99486: LD_INT 12
99488: PUSH
99489: LD_INT 13
99491: PUSH
99492: LD_INT 14
99494: PUSH
99495: LD_INT 15
99497: PUSH
99498: LD_INT 16
99500: PUSH
99501: LD_INT 17
99503: PUSH
99504: LD_INT 18
99506: PUSH
99507: LD_INT 19
99509: PUSH
99510: LD_INT 20
99512: PUSH
99513: LD_INT 21
99515: PUSH
99516: LD_INT 22
99518: PUSH
99519: LD_INT 23
99521: PUSH
99522: LD_INT 24
99524: PUSH
99525: LD_INT 25
99527: PUSH
99528: LD_INT 26
99530: PUSH
99531: LD_INT 27
99533: PUSH
99534: LD_INT 28
99536: PUSH
99537: LD_INT 29
99539: PUSH
99540: LD_INT 30
99542: PUSH
99543: LD_INT 31
99545: PUSH
99546: LD_INT 32
99548: PUSH
99549: LD_INT 33
99551: PUSH
99552: LD_INT 34
99554: PUSH
99555: LD_INT 35
99557: PUSH
99558: LD_INT 36
99560: PUSH
99561: EMPTY
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: PUSH
99599: LD_INT 101
99601: PUSH
99602: LD_INT 102
99604: PUSH
99605: LD_INT 103
99607: PUSH
99608: LD_INT 104
99610: PUSH
99611: LD_INT 105
99613: PUSH
99614: LD_INT 106
99616: PUSH
99617: LD_INT 107
99619: PUSH
99620: LD_INT 108
99622: PUSH
99623: LD_INT 109
99625: PUSH
99626: LD_INT 110
99628: PUSH
99629: LD_INT 111
99631: PUSH
99632: LD_INT 112
99634: PUSH
99635: LD_INT 113
99637: PUSH
99638: LD_INT 114
99640: PUSH
99641: LD_INT 115
99643: PUSH
99644: LD_INT 116
99646: PUSH
99647: LD_INT 117
99649: PUSH
99650: LD_INT 118
99652: PUSH
99653: EMPTY
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: PUSH
99673: EMPTY
99674: LIST
99675: LIST
99676: ST_TO_ADDR
99677: GO 99680
99679: POP
// end else
99680: GO 99911
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99682: LD_ADDR_VAR 0 2
99686: PUSH
99687: LD_INT 1
99689: PUSH
99690: LD_INT 2
99692: PUSH
99693: LD_INT 3
99695: PUSH
99696: LD_INT 4
99698: PUSH
99699: LD_INT 5
99701: PUSH
99702: LD_INT 6
99704: PUSH
99705: LD_INT 7
99707: PUSH
99708: LD_INT 8
99710: PUSH
99711: LD_INT 9
99713: PUSH
99714: LD_INT 10
99716: PUSH
99717: LD_INT 11
99719: PUSH
99720: LD_INT 12
99722: PUSH
99723: LD_INT 13
99725: PUSH
99726: LD_INT 14
99728: PUSH
99729: LD_INT 15
99731: PUSH
99732: LD_INT 16
99734: PUSH
99735: LD_INT 17
99737: PUSH
99738: LD_INT 18
99740: PUSH
99741: LD_INT 19
99743: PUSH
99744: LD_INT 20
99746: PUSH
99747: LD_INT 21
99749: PUSH
99750: LD_INT 22
99752: PUSH
99753: LD_INT 23
99755: PUSH
99756: LD_INT 24
99758: PUSH
99759: LD_INT 25
99761: PUSH
99762: LD_INT 26
99764: PUSH
99765: LD_INT 27
99767: PUSH
99768: LD_INT 28
99770: PUSH
99771: LD_INT 29
99773: PUSH
99774: LD_INT 30
99776: PUSH
99777: LD_INT 31
99779: PUSH
99780: LD_INT 32
99782: PUSH
99783: LD_INT 33
99785: PUSH
99786: LD_INT 34
99788: PUSH
99789: LD_INT 35
99791: PUSH
99792: LD_INT 36
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: PUSH
99833: LD_INT 101
99835: PUSH
99836: LD_INT 102
99838: PUSH
99839: LD_INT 103
99841: PUSH
99842: LD_INT 104
99844: PUSH
99845: LD_INT 105
99847: PUSH
99848: LD_INT 106
99850: PUSH
99851: LD_INT 107
99853: PUSH
99854: LD_INT 108
99856: PUSH
99857: LD_INT 109
99859: PUSH
99860: LD_INT 110
99862: PUSH
99863: LD_INT 111
99865: PUSH
99866: LD_INT 112
99868: PUSH
99869: LD_INT 113
99871: PUSH
99872: LD_INT 114
99874: PUSH
99875: LD_INT 115
99877: PUSH
99878: LD_INT 116
99880: PUSH
99881: LD_INT 117
99883: PUSH
99884: LD_INT 118
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: LIST
99902: LIST
99903: LIST
99904: LIST
99905: LIST
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: ST_TO_ADDR
// if result then
99911: LD_VAR 0 2
99915: IFFALSE 100701
// begin normal :=  ;
99917: LD_ADDR_VAR 0 5
99921: PUSH
99922: LD_STRING 
99924: ST_TO_ADDR
// hardcore :=  ;
99925: LD_ADDR_VAR 0 6
99929: PUSH
99930: LD_STRING 
99932: ST_TO_ADDR
// active :=  ;
99933: LD_ADDR_VAR 0 7
99937: PUSH
99938: LD_STRING 
99940: ST_TO_ADDR
// for i = 1 to normalCounter do
99941: LD_ADDR_VAR 0 8
99945: PUSH
99946: DOUBLE
99947: LD_INT 1
99949: DEC
99950: ST_TO_ADDR
99951: LD_EXP 78
99955: PUSH
99956: FOR_TO
99957: IFFALSE 100058
// begin tmp := 0 ;
99959: LD_ADDR_VAR 0 3
99963: PUSH
99964: LD_STRING 0
99966: ST_TO_ADDR
// if result [ 1 ] then
99967: LD_VAR 0 2
99971: PUSH
99972: LD_INT 1
99974: ARRAY
99975: IFFALSE 100040
// if result [ 1 ] [ 1 ] = i then
99977: LD_VAR 0 2
99981: PUSH
99982: LD_INT 1
99984: ARRAY
99985: PUSH
99986: LD_INT 1
99988: ARRAY
99989: PUSH
99990: LD_VAR 0 8
99994: EQUAL
99995: IFFALSE 100040
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99997: LD_ADDR_VAR 0 2
100001: PUSH
100002: LD_VAR 0 2
100006: PPUSH
100007: LD_INT 1
100009: PPUSH
100010: LD_VAR 0 2
100014: PUSH
100015: LD_INT 1
100017: ARRAY
100018: PPUSH
100019: LD_INT 1
100021: PPUSH
100022: CALL_OW 3
100026: PPUSH
100027: CALL_OW 1
100031: ST_TO_ADDR
// tmp := 1 ;
100032: LD_ADDR_VAR 0 3
100036: PUSH
100037: LD_STRING 1
100039: ST_TO_ADDR
// end ; normal := normal & tmp ;
100040: LD_ADDR_VAR 0 5
100044: PUSH
100045: LD_VAR 0 5
100049: PUSH
100050: LD_VAR 0 3
100054: STR
100055: ST_TO_ADDR
// end ;
100056: GO 99956
100058: POP
100059: POP
// for i = 1 to hardcoreCounter do
100060: LD_ADDR_VAR 0 8
100064: PUSH
100065: DOUBLE
100066: LD_INT 1
100068: DEC
100069: ST_TO_ADDR
100070: LD_EXP 79
100074: PUSH
100075: FOR_TO
100076: IFFALSE 100181
// begin tmp := 0 ;
100078: LD_ADDR_VAR 0 3
100082: PUSH
100083: LD_STRING 0
100085: ST_TO_ADDR
// if result [ 2 ] then
100086: LD_VAR 0 2
100090: PUSH
100091: LD_INT 2
100093: ARRAY
100094: IFFALSE 100163
// if result [ 2 ] [ 1 ] = 100 + i then
100096: LD_VAR 0 2
100100: PUSH
100101: LD_INT 2
100103: ARRAY
100104: PUSH
100105: LD_INT 1
100107: ARRAY
100108: PUSH
100109: LD_INT 100
100111: PUSH
100112: LD_VAR 0 8
100116: PLUS
100117: EQUAL
100118: IFFALSE 100163
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100120: LD_ADDR_VAR 0 2
100124: PUSH
100125: LD_VAR 0 2
100129: PPUSH
100130: LD_INT 2
100132: PPUSH
100133: LD_VAR 0 2
100137: PUSH
100138: LD_INT 2
100140: ARRAY
100141: PPUSH
100142: LD_INT 1
100144: PPUSH
100145: CALL_OW 3
100149: PPUSH
100150: CALL_OW 1
100154: ST_TO_ADDR
// tmp := 1 ;
100155: LD_ADDR_VAR 0 3
100159: PUSH
100160: LD_STRING 1
100162: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100163: LD_ADDR_VAR 0 6
100167: PUSH
100168: LD_VAR 0 6
100172: PUSH
100173: LD_VAR 0 3
100177: STR
100178: ST_TO_ADDR
// end ;
100179: GO 100075
100181: POP
100182: POP
// if isGameLoad then
100183: LD_VAR 0 1
100187: IFFALSE 100662
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100189: LD_ADDR_VAR 0 4
100193: PUSH
100194: LD_EXP 82
100198: PUSH
100199: LD_EXP 81
100203: PUSH
100204: LD_EXP 83
100208: PUSH
100209: LD_EXP 80
100213: PUSH
100214: LD_EXP 84
100218: PUSH
100219: LD_EXP 85
100223: PUSH
100224: LD_EXP 86
100228: PUSH
100229: LD_EXP 87
100233: PUSH
100234: LD_EXP 88
100238: PUSH
100239: LD_EXP 89
100243: PUSH
100244: LD_EXP 90
100248: PUSH
100249: LD_EXP 91
100253: PUSH
100254: LD_EXP 92
100258: PUSH
100259: LD_EXP 93
100263: PUSH
100264: LD_EXP 101
100268: PUSH
100269: LD_EXP 102
100273: PUSH
100274: LD_EXP 103
100278: PUSH
100279: LD_EXP 104
100283: PUSH
100284: LD_EXP 106
100288: PUSH
100289: LD_EXP 107
100293: PUSH
100294: LD_EXP 108
100298: PUSH
100299: LD_EXP 111
100303: PUSH
100304: LD_EXP 113
100308: PUSH
100309: LD_EXP 114
100313: PUSH
100314: LD_EXP 115
100318: PUSH
100319: LD_EXP 117
100323: PUSH
100324: LD_EXP 118
100328: PUSH
100329: LD_EXP 121
100333: PUSH
100334: LD_EXP 122
100338: PUSH
100339: LD_EXP 123
100343: PUSH
100344: LD_EXP 124
100348: PUSH
100349: LD_EXP 125
100353: PUSH
100354: LD_EXP 126
100358: PUSH
100359: LD_EXP 127
100363: PUSH
100364: LD_EXP 128
100368: PUSH
100369: LD_EXP 129
100373: PUSH
100374: LD_EXP 94
100378: PUSH
100379: LD_EXP 95
100383: PUSH
100384: LD_EXP 98
100388: PUSH
100389: LD_EXP 99
100393: PUSH
100394: LD_EXP 100
100398: PUSH
100399: LD_EXP 96
100403: PUSH
100404: LD_EXP 97
100408: PUSH
100409: LD_EXP 105
100413: PUSH
100414: LD_EXP 109
100418: PUSH
100419: LD_EXP 110
100423: PUSH
100424: LD_EXP 112
100428: PUSH
100429: LD_EXP 116
100433: PUSH
100434: LD_EXP 119
100438: PUSH
100439: LD_EXP 120
100443: PUSH
100444: LD_EXP 130
100448: PUSH
100449: LD_EXP 131
100453: PUSH
100454: LD_EXP 132
100458: PUSH
100459: LD_EXP 133
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: LIST
100509: LIST
100510: LIST
100511: LIST
100512: LIST
100513: LIST
100514: LIST
100515: LIST
100516: LIST
100517: LIST
100518: LIST
100519: ST_TO_ADDR
// tmp :=  ;
100520: LD_ADDR_VAR 0 3
100524: PUSH
100525: LD_STRING 
100527: ST_TO_ADDR
// for i = 1 to normalCounter do
100528: LD_ADDR_VAR 0 8
100532: PUSH
100533: DOUBLE
100534: LD_INT 1
100536: DEC
100537: ST_TO_ADDR
100538: LD_EXP 78
100542: PUSH
100543: FOR_TO
100544: IFFALSE 100580
// begin if flags [ i ] then
100546: LD_VAR 0 4
100550: PUSH
100551: LD_VAR 0 8
100555: ARRAY
100556: IFFALSE 100578
// tmp := tmp & i & ; ;
100558: LD_ADDR_VAR 0 3
100562: PUSH
100563: LD_VAR 0 3
100567: PUSH
100568: LD_VAR 0 8
100572: STR
100573: PUSH
100574: LD_STRING ;
100576: STR
100577: ST_TO_ADDR
// end ;
100578: GO 100543
100580: POP
100581: POP
// for i = 1 to hardcoreCounter do
100582: LD_ADDR_VAR 0 8
100586: PUSH
100587: DOUBLE
100588: LD_INT 1
100590: DEC
100591: ST_TO_ADDR
100592: LD_EXP 79
100596: PUSH
100597: FOR_TO
100598: IFFALSE 100644
// begin if flags [ normalCounter + i ] then
100600: LD_VAR 0 4
100604: PUSH
100605: LD_EXP 78
100609: PUSH
100610: LD_VAR 0 8
100614: PLUS
100615: ARRAY
100616: IFFALSE 100642
// tmp := tmp & ( 100 + i ) & ; ;
100618: LD_ADDR_VAR 0 3
100622: PUSH
100623: LD_VAR 0 3
100627: PUSH
100628: LD_INT 100
100630: PUSH
100631: LD_VAR 0 8
100635: PLUS
100636: STR
100637: PUSH
100638: LD_STRING ;
100640: STR
100641: ST_TO_ADDR
// end ;
100642: GO 100597
100644: POP
100645: POP
// if tmp then
100646: LD_VAR 0 3
100650: IFFALSE 100662
// active := tmp ;
100652: LD_ADDR_VAR 0 7
100656: PUSH
100657: LD_VAR 0 3
100661: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100662: LD_STRING getStreamItemsFromMission("
100664: PUSH
100665: LD_VAR 0 5
100669: STR
100670: PUSH
100671: LD_STRING ","
100673: STR
100674: PUSH
100675: LD_VAR 0 6
100679: STR
100680: PUSH
100681: LD_STRING ","
100683: STR
100684: PUSH
100685: LD_VAR 0 7
100689: STR
100690: PUSH
100691: LD_STRING ")
100693: STR
100694: PPUSH
100695: CALL_OW 559
// end else
100699: GO 100708
// ToLua ( getStreamItemsFromMission("","","") ) ;
100701: LD_STRING getStreamItemsFromMission("","","")
100703: PPUSH
100704: CALL_OW 559
// end ;
100708: LD_VAR 0 2
100712: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100713: LD_EXP 77
100717: PUSH
100718: LD_EXP 82
100722: AND
100723: IFFALSE 100847
100725: GO 100727
100727: DISABLE
100728: LD_INT 0
100730: PPUSH
100731: PPUSH
// begin enable ;
100732: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100733: LD_ADDR_VAR 0 2
100737: PUSH
100738: LD_INT 22
100740: PUSH
100741: LD_OWVAR 2
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: LD_INT 2
100752: PUSH
100753: LD_INT 34
100755: PUSH
100756: LD_INT 7
100758: PUSH
100759: EMPTY
100760: LIST
100761: LIST
100762: PUSH
100763: LD_INT 34
100765: PUSH
100766: LD_INT 45
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 34
100775: PUSH
100776: LD_INT 28
100778: PUSH
100779: EMPTY
100780: LIST
100781: LIST
100782: PUSH
100783: LD_INT 34
100785: PUSH
100786: LD_INT 47
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: LIST
100797: LIST
100798: LIST
100799: PUSH
100800: EMPTY
100801: LIST
100802: LIST
100803: PPUSH
100804: CALL_OW 69
100808: ST_TO_ADDR
// if not tmp then
100809: LD_VAR 0 2
100813: NOT
100814: IFFALSE 100818
// exit ;
100816: GO 100847
// for i in tmp do
100818: LD_ADDR_VAR 0 1
100822: PUSH
100823: LD_VAR 0 2
100827: PUSH
100828: FOR_IN
100829: IFFALSE 100845
// begin SetLives ( i , 0 ) ;
100831: LD_VAR 0 1
100835: PPUSH
100836: LD_INT 0
100838: PPUSH
100839: CALL_OW 234
// end ;
100843: GO 100828
100845: POP
100846: POP
// end ;
100847: PPOPN 2
100849: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100850: LD_EXP 77
100854: PUSH
100855: LD_EXP 83
100859: AND
100860: IFFALSE 100944
100862: GO 100864
100864: DISABLE
100865: LD_INT 0
100867: PPUSH
100868: PPUSH
// begin enable ;
100869: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100870: LD_ADDR_VAR 0 2
100874: PUSH
100875: LD_INT 22
100877: PUSH
100878: LD_OWVAR 2
100882: PUSH
100883: EMPTY
100884: LIST
100885: LIST
100886: PUSH
100887: LD_INT 32
100889: PUSH
100890: LD_INT 3
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PPUSH
100901: CALL_OW 69
100905: ST_TO_ADDR
// if not tmp then
100906: LD_VAR 0 2
100910: NOT
100911: IFFALSE 100915
// exit ;
100913: GO 100944
// for i in tmp do
100915: LD_ADDR_VAR 0 1
100919: PUSH
100920: LD_VAR 0 2
100924: PUSH
100925: FOR_IN
100926: IFFALSE 100942
// begin SetLives ( i , 0 ) ;
100928: LD_VAR 0 1
100932: PPUSH
100933: LD_INT 0
100935: PPUSH
100936: CALL_OW 234
// end ;
100940: GO 100925
100942: POP
100943: POP
// end ;
100944: PPOPN 2
100946: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100947: LD_EXP 77
100951: PUSH
100952: LD_EXP 80
100956: AND
100957: IFFALSE 101050
100959: GO 100961
100961: DISABLE
100962: LD_INT 0
100964: PPUSH
// begin enable ;
100965: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100966: LD_ADDR_VAR 0 1
100970: PUSH
100971: LD_INT 22
100973: PUSH
100974: LD_OWVAR 2
100978: PUSH
100979: EMPTY
100980: LIST
100981: LIST
100982: PUSH
100983: LD_INT 2
100985: PUSH
100986: LD_INT 25
100988: PUSH
100989: LD_INT 5
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: PUSH
100996: LD_INT 25
100998: PUSH
100999: LD_INT 9
101001: PUSH
101002: EMPTY
101003: LIST
101004: LIST
101005: PUSH
101006: LD_INT 25
101008: PUSH
101009: LD_INT 8
101011: PUSH
101012: EMPTY
101013: LIST
101014: LIST
101015: PUSH
101016: EMPTY
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: PUSH
101022: EMPTY
101023: LIST
101024: LIST
101025: PPUSH
101026: CALL_OW 69
101030: PUSH
101031: FOR_IN
101032: IFFALSE 101048
// begin SetClass ( i , 1 ) ;
101034: LD_VAR 0 1
101038: PPUSH
101039: LD_INT 1
101041: PPUSH
101042: CALL_OW 336
// end ;
101046: GO 101031
101048: POP
101049: POP
// end ;
101050: PPOPN 1
101052: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101053: LD_EXP 77
101057: PUSH
101058: LD_EXP 81
101062: AND
101063: PUSH
101064: LD_OWVAR 65
101068: PUSH
101069: LD_INT 7
101071: LESS
101072: AND
101073: IFFALSE 101087
101075: GO 101077
101077: DISABLE
// begin enable ;
101078: ENABLE
// game_speed := 7 ;
101079: LD_ADDR_OWVAR 65
101083: PUSH
101084: LD_INT 7
101086: ST_TO_ADDR
// end ;
101087: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101088: LD_EXP 77
101092: PUSH
101093: LD_EXP 84
101097: AND
101098: IFFALSE 101300
101100: GO 101102
101102: DISABLE
101103: LD_INT 0
101105: PPUSH
101106: PPUSH
101107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101108: LD_ADDR_VAR 0 3
101112: PUSH
101113: LD_INT 81
101115: PUSH
101116: LD_OWVAR 2
101120: PUSH
101121: EMPTY
101122: LIST
101123: LIST
101124: PUSH
101125: LD_INT 21
101127: PUSH
101128: LD_INT 1
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: PUSH
101135: EMPTY
101136: LIST
101137: LIST
101138: PPUSH
101139: CALL_OW 69
101143: ST_TO_ADDR
// if not tmp then
101144: LD_VAR 0 3
101148: NOT
101149: IFFALSE 101153
// exit ;
101151: GO 101300
// if tmp > 5 then
101153: LD_VAR 0 3
101157: PUSH
101158: LD_INT 5
101160: GREATER
101161: IFFALSE 101173
// k := 5 else
101163: LD_ADDR_VAR 0 2
101167: PUSH
101168: LD_INT 5
101170: ST_TO_ADDR
101171: GO 101183
// k := tmp ;
101173: LD_ADDR_VAR 0 2
101177: PUSH
101178: LD_VAR 0 3
101182: ST_TO_ADDR
// for i := 1 to k do
101183: LD_ADDR_VAR 0 1
101187: PUSH
101188: DOUBLE
101189: LD_INT 1
101191: DEC
101192: ST_TO_ADDR
101193: LD_VAR 0 2
101197: PUSH
101198: FOR_TO
101199: IFFALSE 101298
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101201: LD_VAR 0 3
101205: PUSH
101206: LD_VAR 0 1
101210: ARRAY
101211: PPUSH
101212: LD_VAR 0 1
101216: PUSH
101217: LD_INT 4
101219: MOD
101220: PUSH
101221: LD_INT 1
101223: PLUS
101224: PPUSH
101225: CALL_OW 259
101229: PUSH
101230: LD_INT 10
101232: LESS
101233: IFFALSE 101296
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101235: LD_VAR 0 3
101239: PUSH
101240: LD_VAR 0 1
101244: ARRAY
101245: PPUSH
101246: LD_VAR 0 1
101250: PUSH
101251: LD_INT 4
101253: MOD
101254: PUSH
101255: LD_INT 1
101257: PLUS
101258: PPUSH
101259: LD_VAR 0 3
101263: PUSH
101264: LD_VAR 0 1
101268: ARRAY
101269: PPUSH
101270: LD_VAR 0 1
101274: PUSH
101275: LD_INT 4
101277: MOD
101278: PUSH
101279: LD_INT 1
101281: PLUS
101282: PPUSH
101283: CALL_OW 259
101287: PUSH
101288: LD_INT 1
101290: PLUS
101291: PPUSH
101292: CALL_OW 237
101296: GO 101198
101298: POP
101299: POP
// end ;
101300: PPOPN 3
101302: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101303: LD_EXP 77
101307: PUSH
101308: LD_EXP 85
101312: AND
101313: IFFALSE 101333
101315: GO 101317
101317: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101318: LD_INT 4
101320: PPUSH
101321: LD_OWVAR 2
101325: PPUSH
101326: LD_INT 0
101328: PPUSH
101329: CALL_OW 324
101333: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101334: LD_EXP 77
101338: PUSH
101339: LD_EXP 114
101343: AND
101344: IFFALSE 101364
101346: GO 101348
101348: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101349: LD_INT 19
101351: PPUSH
101352: LD_OWVAR 2
101356: PPUSH
101357: LD_INT 0
101359: PPUSH
101360: CALL_OW 324
101364: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101365: LD_EXP 77
101369: PUSH
101370: LD_EXP 86
101374: AND
101375: IFFALSE 101477
101377: GO 101379
101379: DISABLE
101380: LD_INT 0
101382: PPUSH
101383: PPUSH
// begin enable ;
101384: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101385: LD_ADDR_VAR 0 2
101389: PUSH
101390: LD_INT 22
101392: PUSH
101393: LD_OWVAR 2
101397: PUSH
101398: EMPTY
101399: LIST
101400: LIST
101401: PUSH
101402: LD_INT 2
101404: PUSH
101405: LD_INT 34
101407: PUSH
101408: LD_INT 11
101410: PUSH
101411: EMPTY
101412: LIST
101413: LIST
101414: PUSH
101415: LD_INT 34
101417: PUSH
101418: LD_INT 30
101420: PUSH
101421: EMPTY
101422: LIST
101423: LIST
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: LIST
101429: PUSH
101430: EMPTY
101431: LIST
101432: LIST
101433: PPUSH
101434: CALL_OW 69
101438: ST_TO_ADDR
// if not tmp then
101439: LD_VAR 0 2
101443: NOT
101444: IFFALSE 101448
// exit ;
101446: GO 101477
// for i in tmp do
101448: LD_ADDR_VAR 0 1
101452: PUSH
101453: LD_VAR 0 2
101457: PUSH
101458: FOR_IN
101459: IFFALSE 101475
// begin SetLives ( i , 0 ) ;
101461: LD_VAR 0 1
101465: PPUSH
101466: LD_INT 0
101468: PPUSH
101469: CALL_OW 234
// end ;
101473: GO 101458
101475: POP
101476: POP
// end ;
101477: PPOPN 2
101479: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101480: LD_EXP 77
101484: PUSH
101485: LD_EXP 87
101489: AND
101490: IFFALSE 101510
101492: GO 101494
101494: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101495: LD_INT 32
101497: PPUSH
101498: LD_OWVAR 2
101502: PPUSH
101503: LD_INT 0
101505: PPUSH
101506: CALL_OW 324
101510: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101511: LD_EXP 77
101515: PUSH
101516: LD_EXP 88
101520: AND
101521: IFFALSE 101702
101523: GO 101525
101525: DISABLE
101526: LD_INT 0
101528: PPUSH
101529: PPUSH
101530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101531: LD_ADDR_VAR 0 2
101535: PUSH
101536: LD_INT 22
101538: PUSH
101539: LD_OWVAR 2
101543: PUSH
101544: EMPTY
101545: LIST
101546: LIST
101547: PUSH
101548: LD_INT 33
101550: PUSH
101551: LD_INT 3
101553: PUSH
101554: EMPTY
101555: LIST
101556: LIST
101557: PUSH
101558: EMPTY
101559: LIST
101560: LIST
101561: PPUSH
101562: CALL_OW 69
101566: ST_TO_ADDR
// if not tmp then
101567: LD_VAR 0 2
101571: NOT
101572: IFFALSE 101576
// exit ;
101574: GO 101702
// side := 0 ;
101576: LD_ADDR_VAR 0 3
101580: PUSH
101581: LD_INT 0
101583: ST_TO_ADDR
// for i := 1 to 8 do
101584: LD_ADDR_VAR 0 1
101588: PUSH
101589: DOUBLE
101590: LD_INT 1
101592: DEC
101593: ST_TO_ADDR
101594: LD_INT 8
101596: PUSH
101597: FOR_TO
101598: IFFALSE 101646
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101600: LD_OWVAR 2
101604: PUSH
101605: LD_VAR 0 1
101609: NONEQUAL
101610: PUSH
101611: LD_OWVAR 2
101615: PPUSH
101616: LD_VAR 0 1
101620: PPUSH
101621: CALL_OW 81
101625: PUSH
101626: LD_INT 2
101628: EQUAL
101629: AND
101630: IFFALSE 101644
// begin side := i ;
101632: LD_ADDR_VAR 0 3
101636: PUSH
101637: LD_VAR 0 1
101641: ST_TO_ADDR
// break ;
101642: GO 101646
// end ;
101644: GO 101597
101646: POP
101647: POP
// if not side then
101648: LD_VAR 0 3
101652: NOT
101653: IFFALSE 101657
// exit ;
101655: GO 101702
// for i := 1 to tmp do
101657: LD_ADDR_VAR 0 1
101661: PUSH
101662: DOUBLE
101663: LD_INT 1
101665: DEC
101666: ST_TO_ADDR
101667: LD_VAR 0 2
101671: PUSH
101672: FOR_TO
101673: IFFALSE 101700
// if Prob ( 60 ) then
101675: LD_INT 60
101677: PPUSH
101678: CALL_OW 13
101682: IFFALSE 101698
// SetSide ( i , side ) ;
101684: LD_VAR 0 1
101688: PPUSH
101689: LD_VAR 0 3
101693: PPUSH
101694: CALL_OW 235
101698: GO 101672
101700: POP
101701: POP
// end ;
101702: PPOPN 3
101704: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101705: LD_EXP 77
101709: PUSH
101710: LD_EXP 90
101714: AND
101715: IFFALSE 101834
101717: GO 101719
101719: DISABLE
101720: LD_INT 0
101722: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101723: LD_ADDR_VAR 0 1
101727: PUSH
101728: LD_INT 22
101730: PUSH
101731: LD_OWVAR 2
101735: PUSH
101736: EMPTY
101737: LIST
101738: LIST
101739: PUSH
101740: LD_INT 21
101742: PUSH
101743: LD_INT 1
101745: PUSH
101746: EMPTY
101747: LIST
101748: LIST
101749: PUSH
101750: LD_INT 3
101752: PUSH
101753: LD_INT 23
101755: PUSH
101756: LD_INT 0
101758: PUSH
101759: EMPTY
101760: LIST
101761: LIST
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: LIST
101771: PPUSH
101772: CALL_OW 69
101776: PUSH
101777: FOR_IN
101778: IFFALSE 101832
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101780: LD_VAR 0 1
101784: PPUSH
101785: CALL_OW 257
101789: PUSH
101790: LD_INT 1
101792: PUSH
101793: LD_INT 2
101795: PUSH
101796: LD_INT 3
101798: PUSH
101799: LD_INT 4
101801: PUSH
101802: EMPTY
101803: LIST
101804: LIST
101805: LIST
101806: LIST
101807: IN
101808: IFFALSE 101830
// SetClass ( un , rand ( 1 , 4 ) ) ;
101810: LD_VAR 0 1
101814: PPUSH
101815: LD_INT 1
101817: PPUSH
101818: LD_INT 4
101820: PPUSH
101821: CALL_OW 12
101825: PPUSH
101826: CALL_OW 336
101830: GO 101777
101832: POP
101833: POP
// end ;
101834: PPOPN 1
101836: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101837: LD_EXP 77
101841: PUSH
101842: LD_EXP 89
101846: AND
101847: IFFALSE 101926
101849: GO 101851
101851: DISABLE
101852: LD_INT 0
101854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101855: LD_ADDR_VAR 0 1
101859: PUSH
101860: LD_INT 22
101862: PUSH
101863: LD_OWVAR 2
101867: PUSH
101868: EMPTY
101869: LIST
101870: LIST
101871: PUSH
101872: LD_INT 21
101874: PUSH
101875: LD_INT 3
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: PUSH
101882: EMPTY
101883: LIST
101884: LIST
101885: PPUSH
101886: CALL_OW 69
101890: ST_TO_ADDR
// if not tmp then
101891: LD_VAR 0 1
101895: NOT
101896: IFFALSE 101900
// exit ;
101898: GO 101926
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101900: LD_VAR 0 1
101904: PUSH
101905: LD_INT 1
101907: PPUSH
101908: LD_VAR 0 1
101912: PPUSH
101913: CALL_OW 12
101917: ARRAY
101918: PPUSH
101919: LD_INT 100
101921: PPUSH
101922: CALL_OW 234
// end ;
101926: PPOPN 1
101928: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101929: LD_EXP 77
101933: PUSH
101934: LD_EXP 91
101938: AND
101939: IFFALSE 102037
101941: GO 101943
101943: DISABLE
101944: LD_INT 0
101946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101947: LD_ADDR_VAR 0 1
101951: PUSH
101952: LD_INT 22
101954: PUSH
101955: LD_OWVAR 2
101959: PUSH
101960: EMPTY
101961: LIST
101962: LIST
101963: PUSH
101964: LD_INT 21
101966: PUSH
101967: LD_INT 1
101969: PUSH
101970: EMPTY
101971: LIST
101972: LIST
101973: PUSH
101974: EMPTY
101975: LIST
101976: LIST
101977: PPUSH
101978: CALL_OW 69
101982: ST_TO_ADDR
// if not tmp then
101983: LD_VAR 0 1
101987: NOT
101988: IFFALSE 101992
// exit ;
101990: GO 102037
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101992: LD_VAR 0 1
101996: PUSH
101997: LD_INT 1
101999: PPUSH
102000: LD_VAR 0 1
102004: PPUSH
102005: CALL_OW 12
102009: ARRAY
102010: PPUSH
102011: LD_INT 1
102013: PPUSH
102014: LD_INT 4
102016: PPUSH
102017: CALL_OW 12
102021: PPUSH
102022: LD_INT 3000
102024: PPUSH
102025: LD_INT 9000
102027: PPUSH
102028: CALL_OW 12
102032: PPUSH
102033: CALL_OW 492
// end ;
102037: PPOPN 1
102039: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102040: LD_EXP 77
102044: PUSH
102045: LD_EXP 92
102049: AND
102050: IFFALSE 102070
102052: GO 102054
102054: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102055: LD_INT 1
102057: PPUSH
102058: LD_OWVAR 2
102062: PPUSH
102063: LD_INT 0
102065: PPUSH
102066: CALL_OW 324
102070: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102071: LD_EXP 77
102075: PUSH
102076: LD_EXP 93
102080: AND
102081: IFFALSE 102164
102083: GO 102085
102085: DISABLE
102086: LD_INT 0
102088: PPUSH
102089: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102090: LD_ADDR_VAR 0 2
102094: PUSH
102095: LD_INT 22
102097: PUSH
102098: LD_OWVAR 2
102102: PUSH
102103: EMPTY
102104: LIST
102105: LIST
102106: PUSH
102107: LD_INT 21
102109: PUSH
102110: LD_INT 3
102112: PUSH
102113: EMPTY
102114: LIST
102115: LIST
102116: PUSH
102117: EMPTY
102118: LIST
102119: LIST
102120: PPUSH
102121: CALL_OW 69
102125: ST_TO_ADDR
// if not tmp then
102126: LD_VAR 0 2
102130: NOT
102131: IFFALSE 102135
// exit ;
102133: GO 102164
// for i in tmp do
102135: LD_ADDR_VAR 0 1
102139: PUSH
102140: LD_VAR 0 2
102144: PUSH
102145: FOR_IN
102146: IFFALSE 102162
// SetBLevel ( i , 10 ) ;
102148: LD_VAR 0 1
102152: PPUSH
102153: LD_INT 10
102155: PPUSH
102156: CALL_OW 241
102160: GO 102145
102162: POP
102163: POP
// end ;
102164: PPOPN 2
102166: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102167: LD_EXP 77
102171: PUSH
102172: LD_EXP 94
102176: AND
102177: IFFALSE 102288
102179: GO 102181
102181: DISABLE
102182: LD_INT 0
102184: PPUSH
102185: PPUSH
102186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102187: LD_ADDR_VAR 0 3
102191: PUSH
102192: LD_INT 22
102194: PUSH
102195: LD_OWVAR 2
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PUSH
102204: LD_INT 25
102206: PUSH
102207: LD_INT 1
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: PPUSH
102218: CALL_OW 69
102222: ST_TO_ADDR
// if not tmp then
102223: LD_VAR 0 3
102227: NOT
102228: IFFALSE 102232
// exit ;
102230: GO 102288
// un := tmp [ rand ( 1 , tmp ) ] ;
102232: LD_ADDR_VAR 0 2
102236: PUSH
102237: LD_VAR 0 3
102241: PUSH
102242: LD_INT 1
102244: PPUSH
102245: LD_VAR 0 3
102249: PPUSH
102250: CALL_OW 12
102254: ARRAY
102255: ST_TO_ADDR
// if Crawls ( un ) then
102256: LD_VAR 0 2
102260: PPUSH
102261: CALL_OW 318
102265: IFFALSE 102276
// ComWalk ( un ) ;
102267: LD_VAR 0 2
102271: PPUSH
102272: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102276: LD_VAR 0 2
102280: PPUSH
102281: LD_INT 5
102283: PPUSH
102284: CALL_OW 336
// end ;
102288: PPOPN 3
102290: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102291: LD_EXP 77
102295: PUSH
102296: LD_EXP 95
102300: AND
102301: PUSH
102302: LD_OWVAR 67
102306: PUSH
102307: LD_INT 4
102309: LESS
102310: AND
102311: IFFALSE 102330
102313: GO 102315
102315: DISABLE
// begin Difficulty := Difficulty + 1 ;
102316: LD_ADDR_OWVAR 67
102320: PUSH
102321: LD_OWVAR 67
102325: PUSH
102326: LD_INT 1
102328: PLUS
102329: ST_TO_ADDR
// end ;
102330: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102331: LD_EXP 77
102335: PUSH
102336: LD_EXP 96
102340: AND
102341: IFFALSE 102444
102343: GO 102345
102345: DISABLE
102346: LD_INT 0
102348: PPUSH
// begin for i := 1 to 5 do
102349: LD_ADDR_VAR 0 1
102353: PUSH
102354: DOUBLE
102355: LD_INT 1
102357: DEC
102358: ST_TO_ADDR
102359: LD_INT 5
102361: PUSH
102362: FOR_TO
102363: IFFALSE 102442
// begin uc_nation := nation_nature ;
102365: LD_ADDR_OWVAR 21
102369: PUSH
102370: LD_INT 0
102372: ST_TO_ADDR
// uc_side := 0 ;
102373: LD_ADDR_OWVAR 20
102377: PUSH
102378: LD_INT 0
102380: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102381: LD_ADDR_OWVAR 29
102385: PUSH
102386: LD_INT 12
102388: PUSH
102389: LD_INT 12
102391: PUSH
102392: EMPTY
102393: LIST
102394: LIST
102395: ST_TO_ADDR
// hc_agressivity := 20 ;
102396: LD_ADDR_OWVAR 35
102400: PUSH
102401: LD_INT 20
102403: ST_TO_ADDR
// hc_class := class_tiger ;
102404: LD_ADDR_OWVAR 28
102408: PUSH
102409: LD_INT 14
102411: ST_TO_ADDR
// hc_gallery :=  ;
102412: LD_ADDR_OWVAR 33
102416: PUSH
102417: LD_STRING 
102419: ST_TO_ADDR
// hc_name :=  ;
102420: LD_ADDR_OWVAR 26
102424: PUSH
102425: LD_STRING 
102427: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102428: CALL_OW 44
102432: PPUSH
102433: LD_INT 0
102435: PPUSH
102436: CALL_OW 51
// end ;
102440: GO 102362
102442: POP
102443: POP
// end ;
102444: PPOPN 1
102446: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102447: LD_EXP 77
102451: PUSH
102452: LD_EXP 97
102456: AND
102457: IFFALSE 102466
102459: GO 102461
102461: DISABLE
// StreamSibBomb ;
102462: CALL 102467 0 0
102466: END
// export function StreamSibBomb ; var i , x , y ; begin
102467: LD_INT 0
102469: PPUSH
102470: PPUSH
102471: PPUSH
102472: PPUSH
// result := false ;
102473: LD_ADDR_VAR 0 1
102477: PUSH
102478: LD_INT 0
102480: ST_TO_ADDR
// for i := 1 to 16 do
102481: LD_ADDR_VAR 0 2
102485: PUSH
102486: DOUBLE
102487: LD_INT 1
102489: DEC
102490: ST_TO_ADDR
102491: LD_INT 16
102493: PUSH
102494: FOR_TO
102495: IFFALSE 102694
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102497: LD_ADDR_VAR 0 3
102501: PUSH
102502: LD_INT 10
102504: PUSH
102505: LD_INT 20
102507: PUSH
102508: LD_INT 30
102510: PUSH
102511: LD_INT 40
102513: PUSH
102514: LD_INT 50
102516: PUSH
102517: LD_INT 60
102519: PUSH
102520: LD_INT 70
102522: PUSH
102523: LD_INT 80
102525: PUSH
102526: LD_INT 90
102528: PUSH
102529: LD_INT 100
102531: PUSH
102532: LD_INT 110
102534: PUSH
102535: LD_INT 120
102537: PUSH
102538: LD_INT 130
102540: PUSH
102541: LD_INT 140
102543: PUSH
102544: LD_INT 150
102546: PUSH
102547: EMPTY
102548: LIST
102549: LIST
102550: LIST
102551: LIST
102552: LIST
102553: LIST
102554: LIST
102555: LIST
102556: LIST
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: LIST
102562: LIST
102563: PUSH
102564: LD_INT 1
102566: PPUSH
102567: LD_INT 15
102569: PPUSH
102570: CALL_OW 12
102574: ARRAY
102575: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102576: LD_ADDR_VAR 0 4
102580: PUSH
102581: LD_INT 10
102583: PUSH
102584: LD_INT 20
102586: PUSH
102587: LD_INT 30
102589: PUSH
102590: LD_INT 40
102592: PUSH
102593: LD_INT 50
102595: PUSH
102596: LD_INT 60
102598: PUSH
102599: LD_INT 70
102601: PUSH
102602: LD_INT 80
102604: PUSH
102605: LD_INT 90
102607: PUSH
102608: LD_INT 100
102610: PUSH
102611: LD_INT 110
102613: PUSH
102614: LD_INT 120
102616: PUSH
102617: LD_INT 130
102619: PUSH
102620: LD_INT 140
102622: PUSH
102623: LD_INT 150
102625: PUSH
102626: EMPTY
102627: LIST
102628: LIST
102629: LIST
102630: LIST
102631: LIST
102632: LIST
102633: LIST
102634: LIST
102635: LIST
102636: LIST
102637: LIST
102638: LIST
102639: LIST
102640: LIST
102641: LIST
102642: PUSH
102643: LD_INT 1
102645: PPUSH
102646: LD_INT 15
102648: PPUSH
102649: CALL_OW 12
102653: ARRAY
102654: ST_TO_ADDR
// if ValidHex ( x , y ) then
102655: LD_VAR 0 3
102659: PPUSH
102660: LD_VAR 0 4
102664: PPUSH
102665: CALL_OW 488
102669: IFFALSE 102692
// begin result := [ x , y ] ;
102671: LD_ADDR_VAR 0 1
102675: PUSH
102676: LD_VAR 0 3
102680: PUSH
102681: LD_VAR 0 4
102685: PUSH
102686: EMPTY
102687: LIST
102688: LIST
102689: ST_TO_ADDR
// break ;
102690: GO 102694
// end ; end ;
102692: GO 102494
102694: POP
102695: POP
// if result then
102696: LD_VAR 0 1
102700: IFFALSE 102760
// begin ToLua ( playSibBomb() ) ;
102702: LD_STRING playSibBomb()
102704: PPUSH
102705: CALL_OW 559
// wait ( 0 0$14 ) ;
102709: LD_INT 490
102711: PPUSH
102712: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102716: LD_VAR 0 1
102720: PUSH
102721: LD_INT 1
102723: ARRAY
102724: PPUSH
102725: LD_VAR 0 1
102729: PUSH
102730: LD_INT 2
102732: ARRAY
102733: PPUSH
102734: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102738: LD_VAR 0 1
102742: PUSH
102743: LD_INT 1
102745: ARRAY
102746: PPUSH
102747: LD_VAR 0 1
102751: PUSH
102752: LD_INT 2
102754: ARRAY
102755: PPUSH
102756: CALL_OW 429
// end ; end ;
102760: LD_VAR 0 1
102764: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102765: LD_EXP 77
102769: PUSH
102770: LD_EXP 99
102774: AND
102775: IFFALSE 102787
102777: GO 102779
102779: DISABLE
// YouLost (  ) ;
102780: LD_STRING 
102782: PPUSH
102783: CALL_OW 104
102787: END
// every 0 0$1 trigger StreamModeActive and sFog do
102788: LD_EXP 77
102792: PUSH
102793: LD_EXP 98
102797: AND
102798: IFFALSE 102812
102800: GO 102802
102802: DISABLE
// FogOff ( your_side ) ;
102803: LD_OWVAR 2
102807: PPUSH
102808: CALL_OW 344
102812: END
// every 0 0$1 trigger StreamModeActive and sSun do
102813: LD_EXP 77
102817: PUSH
102818: LD_EXP 100
102822: AND
102823: IFFALSE 102851
102825: GO 102827
102827: DISABLE
// begin solar_recharge_percent := 0 ;
102828: LD_ADDR_OWVAR 79
102832: PUSH
102833: LD_INT 0
102835: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102836: LD_INT 10500
102838: PPUSH
102839: CALL_OW 67
// solar_recharge_percent := 100 ;
102843: LD_ADDR_OWVAR 79
102847: PUSH
102848: LD_INT 100
102850: ST_TO_ADDR
// end ;
102851: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102852: LD_EXP 77
102856: PUSH
102857: LD_EXP 101
102861: AND
102862: IFFALSE 103101
102864: GO 102866
102866: DISABLE
102867: LD_INT 0
102869: PPUSH
102870: PPUSH
102871: PPUSH
// begin tmp := [ ] ;
102872: LD_ADDR_VAR 0 3
102876: PUSH
102877: EMPTY
102878: ST_TO_ADDR
// for i := 1 to 6 do
102879: LD_ADDR_VAR 0 1
102883: PUSH
102884: DOUBLE
102885: LD_INT 1
102887: DEC
102888: ST_TO_ADDR
102889: LD_INT 6
102891: PUSH
102892: FOR_TO
102893: IFFALSE 102998
// begin uc_nation := nation_nature ;
102895: LD_ADDR_OWVAR 21
102899: PUSH
102900: LD_INT 0
102902: ST_TO_ADDR
// uc_side := 0 ;
102903: LD_ADDR_OWVAR 20
102907: PUSH
102908: LD_INT 0
102910: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102911: LD_ADDR_OWVAR 29
102915: PUSH
102916: LD_INT 12
102918: PUSH
102919: LD_INT 12
102921: PUSH
102922: EMPTY
102923: LIST
102924: LIST
102925: ST_TO_ADDR
// hc_agressivity := 20 ;
102926: LD_ADDR_OWVAR 35
102930: PUSH
102931: LD_INT 20
102933: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102934: LD_ADDR_OWVAR 28
102938: PUSH
102939: LD_INT 17
102941: ST_TO_ADDR
// hc_gallery :=  ;
102942: LD_ADDR_OWVAR 33
102946: PUSH
102947: LD_STRING 
102949: ST_TO_ADDR
// hc_name :=  ;
102950: LD_ADDR_OWVAR 26
102954: PUSH
102955: LD_STRING 
102957: ST_TO_ADDR
// un := CreateHuman ;
102958: LD_ADDR_VAR 0 2
102962: PUSH
102963: CALL_OW 44
102967: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102968: LD_VAR 0 2
102972: PPUSH
102973: LD_INT 1
102975: PPUSH
102976: CALL_OW 51
// tmp := tmp ^ un ;
102980: LD_ADDR_VAR 0 3
102984: PUSH
102985: LD_VAR 0 3
102989: PUSH
102990: LD_VAR 0 2
102994: ADD
102995: ST_TO_ADDR
// end ;
102996: GO 102892
102998: POP
102999: POP
// repeat wait ( 0 0$1 ) ;
103000: LD_INT 35
103002: PPUSH
103003: CALL_OW 67
// for un in tmp do
103007: LD_ADDR_VAR 0 2
103011: PUSH
103012: LD_VAR 0 3
103016: PUSH
103017: FOR_IN
103018: IFFALSE 103092
// begin if IsDead ( un ) then
103020: LD_VAR 0 2
103024: PPUSH
103025: CALL_OW 301
103029: IFFALSE 103049
// begin tmp := tmp diff un ;
103031: LD_ADDR_VAR 0 3
103035: PUSH
103036: LD_VAR 0 3
103040: PUSH
103041: LD_VAR 0 2
103045: DIFF
103046: ST_TO_ADDR
// continue ;
103047: GO 103017
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103049: LD_VAR 0 2
103053: PPUSH
103054: LD_INT 3
103056: PUSH
103057: LD_INT 22
103059: PUSH
103060: LD_INT 0
103062: PUSH
103063: EMPTY
103064: LIST
103065: LIST
103066: PUSH
103067: EMPTY
103068: LIST
103069: LIST
103070: PPUSH
103071: CALL_OW 69
103075: PPUSH
103076: LD_VAR 0 2
103080: PPUSH
103081: CALL_OW 74
103085: PPUSH
103086: CALL_OW 115
// end ;
103090: GO 103017
103092: POP
103093: POP
// until not tmp ;
103094: LD_VAR 0 3
103098: NOT
103099: IFFALSE 103000
// end ;
103101: PPOPN 3
103103: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103104: LD_EXP 77
103108: PUSH
103109: LD_EXP 102
103113: AND
103114: IFFALSE 103168
103116: GO 103118
103118: DISABLE
// begin ToLua ( displayTroll(); ) ;
103119: LD_STRING displayTroll();
103121: PPUSH
103122: CALL_OW 559
// wait ( 3 3$00 ) ;
103126: LD_INT 6300
103128: PPUSH
103129: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103133: LD_STRING hideTroll();
103135: PPUSH
103136: CALL_OW 559
// wait ( 1 1$00 ) ;
103140: LD_INT 2100
103142: PPUSH
103143: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103147: LD_STRING displayTroll();
103149: PPUSH
103150: CALL_OW 559
// wait ( 1 1$00 ) ;
103154: LD_INT 2100
103156: PPUSH
103157: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103161: LD_STRING hideTroll();
103163: PPUSH
103164: CALL_OW 559
// end ;
103168: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103169: LD_EXP 77
103173: PUSH
103174: LD_EXP 103
103178: AND
103179: IFFALSE 103242
103181: GO 103183
103183: DISABLE
103184: LD_INT 0
103186: PPUSH
// begin p := 0 ;
103187: LD_ADDR_VAR 0 1
103191: PUSH
103192: LD_INT 0
103194: ST_TO_ADDR
// repeat game_speed := 1 ;
103195: LD_ADDR_OWVAR 65
103199: PUSH
103200: LD_INT 1
103202: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103203: LD_INT 35
103205: PPUSH
103206: CALL_OW 67
// p := p + 1 ;
103210: LD_ADDR_VAR 0 1
103214: PUSH
103215: LD_VAR 0 1
103219: PUSH
103220: LD_INT 1
103222: PLUS
103223: ST_TO_ADDR
// until p >= 60 ;
103224: LD_VAR 0 1
103228: PUSH
103229: LD_INT 60
103231: GREATEREQUAL
103232: IFFALSE 103195
// game_speed := 4 ;
103234: LD_ADDR_OWVAR 65
103238: PUSH
103239: LD_INT 4
103241: ST_TO_ADDR
// end ;
103242: PPOPN 1
103244: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103245: LD_EXP 77
103249: PUSH
103250: LD_EXP 104
103254: AND
103255: IFFALSE 103401
103257: GO 103259
103259: DISABLE
103260: LD_INT 0
103262: PPUSH
103263: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103264: LD_ADDR_VAR 0 1
103268: PUSH
103269: LD_INT 22
103271: PUSH
103272: LD_OWVAR 2
103276: PUSH
103277: EMPTY
103278: LIST
103279: LIST
103280: PUSH
103281: LD_INT 2
103283: PUSH
103284: LD_INT 30
103286: PUSH
103287: LD_INT 0
103289: PUSH
103290: EMPTY
103291: LIST
103292: LIST
103293: PUSH
103294: LD_INT 30
103296: PUSH
103297: LD_INT 1
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: PUSH
103304: EMPTY
103305: LIST
103306: LIST
103307: LIST
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: PPUSH
103313: CALL_OW 69
103317: ST_TO_ADDR
// if not depot then
103318: LD_VAR 0 1
103322: NOT
103323: IFFALSE 103327
// exit ;
103325: GO 103401
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103327: LD_ADDR_VAR 0 2
103331: PUSH
103332: LD_VAR 0 1
103336: PUSH
103337: LD_INT 1
103339: PPUSH
103340: LD_VAR 0 1
103344: PPUSH
103345: CALL_OW 12
103349: ARRAY
103350: PPUSH
103351: CALL_OW 274
103355: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103356: LD_VAR 0 2
103360: PPUSH
103361: LD_INT 1
103363: PPUSH
103364: LD_INT 0
103366: PPUSH
103367: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103371: LD_VAR 0 2
103375: PPUSH
103376: LD_INT 2
103378: PPUSH
103379: LD_INT 0
103381: PPUSH
103382: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103386: LD_VAR 0 2
103390: PPUSH
103391: LD_INT 3
103393: PPUSH
103394: LD_INT 0
103396: PPUSH
103397: CALL_OW 277
// end ;
103401: PPOPN 2
103403: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103404: LD_EXP 77
103408: PUSH
103409: LD_EXP 105
103413: AND
103414: IFFALSE 103511
103416: GO 103418
103418: DISABLE
103419: LD_INT 0
103421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103422: LD_ADDR_VAR 0 1
103426: PUSH
103427: LD_INT 22
103429: PUSH
103430: LD_OWVAR 2
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: PUSH
103439: LD_INT 21
103441: PUSH
103442: LD_INT 1
103444: PUSH
103445: EMPTY
103446: LIST
103447: LIST
103448: PUSH
103449: LD_INT 3
103451: PUSH
103452: LD_INT 23
103454: PUSH
103455: LD_INT 0
103457: PUSH
103458: EMPTY
103459: LIST
103460: LIST
103461: PUSH
103462: EMPTY
103463: LIST
103464: LIST
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: LIST
103470: PPUSH
103471: CALL_OW 69
103475: ST_TO_ADDR
// if not tmp then
103476: LD_VAR 0 1
103480: NOT
103481: IFFALSE 103485
// exit ;
103483: GO 103511
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103485: LD_VAR 0 1
103489: PUSH
103490: LD_INT 1
103492: PPUSH
103493: LD_VAR 0 1
103497: PPUSH
103498: CALL_OW 12
103502: ARRAY
103503: PPUSH
103504: LD_INT 200
103506: PPUSH
103507: CALL_OW 234
// end ;
103511: PPOPN 1
103513: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103514: LD_EXP 77
103518: PUSH
103519: LD_EXP 106
103523: AND
103524: IFFALSE 103603
103526: GO 103528
103528: DISABLE
103529: LD_INT 0
103531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103532: LD_ADDR_VAR 0 1
103536: PUSH
103537: LD_INT 22
103539: PUSH
103540: LD_OWVAR 2
103544: PUSH
103545: EMPTY
103546: LIST
103547: LIST
103548: PUSH
103549: LD_INT 21
103551: PUSH
103552: LD_INT 2
103554: PUSH
103555: EMPTY
103556: LIST
103557: LIST
103558: PUSH
103559: EMPTY
103560: LIST
103561: LIST
103562: PPUSH
103563: CALL_OW 69
103567: ST_TO_ADDR
// if not tmp then
103568: LD_VAR 0 1
103572: NOT
103573: IFFALSE 103577
// exit ;
103575: GO 103603
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103577: LD_VAR 0 1
103581: PUSH
103582: LD_INT 1
103584: PPUSH
103585: LD_VAR 0 1
103589: PPUSH
103590: CALL_OW 12
103594: ARRAY
103595: PPUSH
103596: LD_INT 60
103598: PPUSH
103599: CALL_OW 234
// end ;
103603: PPOPN 1
103605: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103606: LD_EXP 77
103610: PUSH
103611: LD_EXP 107
103615: AND
103616: IFFALSE 103715
103618: GO 103620
103620: DISABLE
103621: LD_INT 0
103623: PPUSH
103624: PPUSH
// begin enable ;
103625: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103626: LD_ADDR_VAR 0 1
103630: PUSH
103631: LD_INT 22
103633: PUSH
103634: LD_OWVAR 2
103638: PUSH
103639: EMPTY
103640: LIST
103641: LIST
103642: PUSH
103643: LD_INT 61
103645: PUSH
103646: EMPTY
103647: LIST
103648: PUSH
103649: LD_INT 33
103651: PUSH
103652: LD_INT 2
103654: PUSH
103655: EMPTY
103656: LIST
103657: LIST
103658: PUSH
103659: EMPTY
103660: LIST
103661: LIST
103662: LIST
103663: PPUSH
103664: CALL_OW 69
103668: ST_TO_ADDR
// if not tmp then
103669: LD_VAR 0 1
103673: NOT
103674: IFFALSE 103678
// exit ;
103676: GO 103715
// for i in tmp do
103678: LD_ADDR_VAR 0 2
103682: PUSH
103683: LD_VAR 0 1
103687: PUSH
103688: FOR_IN
103689: IFFALSE 103713
// if IsControledBy ( i ) then
103691: LD_VAR 0 2
103695: PPUSH
103696: CALL_OW 312
103700: IFFALSE 103711
// ComUnlink ( i ) ;
103702: LD_VAR 0 2
103706: PPUSH
103707: CALL_OW 136
103711: GO 103688
103713: POP
103714: POP
// end ;
103715: PPOPN 2
103717: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103718: LD_EXP 77
103722: PUSH
103723: LD_EXP 108
103727: AND
103728: IFFALSE 103868
103730: GO 103732
103732: DISABLE
103733: LD_INT 0
103735: PPUSH
103736: PPUSH
// begin ToLua ( displayPowell(); ) ;
103737: LD_STRING displayPowell();
103739: PPUSH
103740: CALL_OW 559
// uc_side := 0 ;
103744: LD_ADDR_OWVAR 20
103748: PUSH
103749: LD_INT 0
103751: ST_TO_ADDR
// uc_nation := 2 ;
103752: LD_ADDR_OWVAR 21
103756: PUSH
103757: LD_INT 2
103759: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103760: LD_ADDR_OWVAR 37
103764: PUSH
103765: LD_INT 14
103767: ST_TO_ADDR
// vc_engine := engine_siberite ;
103768: LD_ADDR_OWVAR 39
103772: PUSH
103773: LD_INT 3
103775: ST_TO_ADDR
// vc_control := control_apeman ;
103776: LD_ADDR_OWVAR 38
103780: PUSH
103781: LD_INT 5
103783: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103784: LD_ADDR_OWVAR 40
103788: PUSH
103789: LD_INT 29
103791: ST_TO_ADDR
// un := CreateVehicle ;
103792: LD_ADDR_VAR 0 2
103796: PUSH
103797: CALL_OW 45
103801: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103802: LD_VAR 0 2
103806: PPUSH
103807: LD_INT 1
103809: PPUSH
103810: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103814: LD_INT 35
103816: PPUSH
103817: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103821: LD_VAR 0 2
103825: PPUSH
103826: LD_INT 22
103828: PUSH
103829: LD_OWVAR 2
103833: PUSH
103834: EMPTY
103835: LIST
103836: LIST
103837: PPUSH
103838: CALL_OW 69
103842: PPUSH
103843: LD_VAR 0 2
103847: PPUSH
103848: CALL_OW 74
103852: PPUSH
103853: CALL_OW 115
// until IsDead ( un ) ;
103857: LD_VAR 0 2
103861: PPUSH
103862: CALL_OW 301
103866: IFFALSE 103814
// end ;
103868: PPOPN 2
103870: END
// every 0 0$1 trigger StreamModeActive and sStu do
103871: LD_EXP 77
103875: PUSH
103876: LD_EXP 116
103880: AND
103881: IFFALSE 103897
103883: GO 103885
103885: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103886: LD_STRING displayStucuk();
103888: PPUSH
103889: CALL_OW 559
// ResetFog ;
103893: CALL_OW 335
// end ;
103897: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103898: LD_EXP 77
103902: PUSH
103903: LD_EXP 109
103907: AND
103908: IFFALSE 104049
103910: GO 103912
103912: DISABLE
103913: LD_INT 0
103915: PPUSH
103916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103917: LD_ADDR_VAR 0 2
103921: PUSH
103922: LD_INT 22
103924: PUSH
103925: LD_OWVAR 2
103929: PUSH
103930: EMPTY
103931: LIST
103932: LIST
103933: PUSH
103934: LD_INT 21
103936: PUSH
103937: LD_INT 1
103939: PUSH
103940: EMPTY
103941: LIST
103942: LIST
103943: PUSH
103944: EMPTY
103945: LIST
103946: LIST
103947: PPUSH
103948: CALL_OW 69
103952: ST_TO_ADDR
// if not tmp then
103953: LD_VAR 0 2
103957: NOT
103958: IFFALSE 103962
// exit ;
103960: GO 104049
// un := tmp [ rand ( 1 , tmp ) ] ;
103962: LD_ADDR_VAR 0 1
103966: PUSH
103967: LD_VAR 0 2
103971: PUSH
103972: LD_INT 1
103974: PPUSH
103975: LD_VAR 0 2
103979: PPUSH
103980: CALL_OW 12
103984: ARRAY
103985: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103986: LD_VAR 0 1
103990: PPUSH
103991: LD_INT 0
103993: PPUSH
103994: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103998: LD_VAR 0 1
104002: PPUSH
104003: LD_OWVAR 3
104007: PUSH
104008: LD_VAR 0 1
104012: DIFF
104013: PPUSH
104014: LD_VAR 0 1
104018: PPUSH
104019: CALL_OW 74
104023: PPUSH
104024: CALL_OW 115
// wait ( 0 0$20 ) ;
104028: LD_INT 700
104030: PPUSH
104031: CALL_OW 67
// SetSide ( un , your_side ) ;
104035: LD_VAR 0 1
104039: PPUSH
104040: LD_OWVAR 2
104044: PPUSH
104045: CALL_OW 235
// end ;
104049: PPOPN 2
104051: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104052: LD_EXP 77
104056: PUSH
104057: LD_EXP 110
104061: AND
104062: IFFALSE 104168
104064: GO 104066
104066: DISABLE
104067: LD_INT 0
104069: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104070: LD_ADDR_VAR 0 1
104074: PUSH
104075: LD_INT 22
104077: PUSH
104078: LD_OWVAR 2
104082: PUSH
104083: EMPTY
104084: LIST
104085: LIST
104086: PUSH
104087: LD_INT 2
104089: PUSH
104090: LD_INT 30
104092: PUSH
104093: LD_INT 0
104095: PUSH
104096: EMPTY
104097: LIST
104098: LIST
104099: PUSH
104100: LD_INT 30
104102: PUSH
104103: LD_INT 1
104105: PUSH
104106: EMPTY
104107: LIST
104108: LIST
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: LIST
104114: PUSH
104115: EMPTY
104116: LIST
104117: LIST
104118: PPUSH
104119: CALL_OW 69
104123: ST_TO_ADDR
// if not depot then
104124: LD_VAR 0 1
104128: NOT
104129: IFFALSE 104133
// exit ;
104131: GO 104168
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104133: LD_VAR 0 1
104137: PUSH
104138: LD_INT 1
104140: ARRAY
104141: PPUSH
104142: CALL_OW 250
104146: PPUSH
104147: LD_VAR 0 1
104151: PUSH
104152: LD_INT 1
104154: ARRAY
104155: PPUSH
104156: CALL_OW 251
104160: PPUSH
104161: LD_INT 70
104163: PPUSH
104164: CALL_OW 495
// end ;
104168: PPOPN 1
104170: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104171: LD_EXP 77
104175: PUSH
104176: LD_EXP 111
104180: AND
104181: IFFALSE 104392
104183: GO 104185
104185: DISABLE
104186: LD_INT 0
104188: PPUSH
104189: PPUSH
104190: PPUSH
104191: PPUSH
104192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104193: LD_ADDR_VAR 0 5
104197: PUSH
104198: LD_INT 22
104200: PUSH
104201: LD_OWVAR 2
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: PUSH
104210: LD_INT 21
104212: PUSH
104213: LD_INT 1
104215: PUSH
104216: EMPTY
104217: LIST
104218: LIST
104219: PUSH
104220: EMPTY
104221: LIST
104222: LIST
104223: PPUSH
104224: CALL_OW 69
104228: ST_TO_ADDR
// if not tmp then
104229: LD_VAR 0 5
104233: NOT
104234: IFFALSE 104238
// exit ;
104236: GO 104392
// for i in tmp do
104238: LD_ADDR_VAR 0 1
104242: PUSH
104243: LD_VAR 0 5
104247: PUSH
104248: FOR_IN
104249: IFFALSE 104390
// begin d := rand ( 0 , 5 ) ;
104251: LD_ADDR_VAR 0 4
104255: PUSH
104256: LD_INT 0
104258: PPUSH
104259: LD_INT 5
104261: PPUSH
104262: CALL_OW 12
104266: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104267: LD_ADDR_VAR 0 2
104271: PUSH
104272: LD_VAR 0 1
104276: PPUSH
104277: CALL_OW 250
104281: PPUSH
104282: LD_VAR 0 4
104286: PPUSH
104287: LD_INT 3
104289: PPUSH
104290: LD_INT 12
104292: PPUSH
104293: CALL_OW 12
104297: PPUSH
104298: CALL_OW 272
104302: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104303: LD_ADDR_VAR 0 3
104307: PUSH
104308: LD_VAR 0 1
104312: PPUSH
104313: CALL_OW 251
104317: PPUSH
104318: LD_VAR 0 4
104322: PPUSH
104323: LD_INT 3
104325: PPUSH
104326: LD_INT 12
104328: PPUSH
104329: CALL_OW 12
104333: PPUSH
104334: CALL_OW 273
104338: ST_TO_ADDR
// if ValidHex ( x , y ) then
104339: LD_VAR 0 2
104343: PPUSH
104344: LD_VAR 0 3
104348: PPUSH
104349: CALL_OW 488
104353: IFFALSE 104388
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104355: LD_VAR 0 1
104359: PPUSH
104360: LD_VAR 0 2
104364: PPUSH
104365: LD_VAR 0 3
104369: PPUSH
104370: LD_INT 3
104372: PPUSH
104373: LD_INT 6
104375: PPUSH
104376: CALL_OW 12
104380: PPUSH
104381: LD_INT 1
104383: PPUSH
104384: CALL_OW 483
// end ;
104388: GO 104248
104390: POP
104391: POP
// end ;
104392: PPOPN 5
104394: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104395: LD_EXP 77
104399: PUSH
104400: LD_EXP 112
104404: AND
104405: IFFALSE 104499
104407: GO 104409
104409: DISABLE
104410: LD_INT 0
104412: PPUSH
104413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104414: LD_ADDR_VAR 0 2
104418: PUSH
104419: LD_INT 22
104421: PUSH
104422: LD_OWVAR 2
104426: PUSH
104427: EMPTY
104428: LIST
104429: LIST
104430: PUSH
104431: LD_INT 32
104433: PUSH
104434: LD_INT 1
104436: PUSH
104437: EMPTY
104438: LIST
104439: LIST
104440: PUSH
104441: LD_INT 21
104443: PUSH
104444: LD_INT 2
104446: PUSH
104447: EMPTY
104448: LIST
104449: LIST
104450: PUSH
104451: EMPTY
104452: LIST
104453: LIST
104454: LIST
104455: PPUSH
104456: CALL_OW 69
104460: ST_TO_ADDR
// if not tmp then
104461: LD_VAR 0 2
104465: NOT
104466: IFFALSE 104470
// exit ;
104468: GO 104499
// for i in tmp do
104470: LD_ADDR_VAR 0 1
104474: PUSH
104475: LD_VAR 0 2
104479: PUSH
104480: FOR_IN
104481: IFFALSE 104497
// SetFuel ( i , 0 ) ;
104483: LD_VAR 0 1
104487: PPUSH
104488: LD_INT 0
104490: PPUSH
104491: CALL_OW 240
104495: GO 104480
104497: POP
104498: POP
// end ;
104499: PPOPN 2
104501: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104502: LD_EXP 77
104506: PUSH
104507: LD_EXP 113
104511: AND
104512: IFFALSE 104578
104514: GO 104516
104516: DISABLE
104517: LD_INT 0
104519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104520: LD_ADDR_VAR 0 1
104524: PUSH
104525: LD_INT 22
104527: PUSH
104528: LD_OWVAR 2
104532: PUSH
104533: EMPTY
104534: LIST
104535: LIST
104536: PUSH
104537: LD_INT 30
104539: PUSH
104540: LD_INT 29
104542: PUSH
104543: EMPTY
104544: LIST
104545: LIST
104546: PUSH
104547: EMPTY
104548: LIST
104549: LIST
104550: PPUSH
104551: CALL_OW 69
104555: ST_TO_ADDR
// if not tmp then
104556: LD_VAR 0 1
104560: NOT
104561: IFFALSE 104565
// exit ;
104563: GO 104578
// DestroyUnit ( tmp [ 1 ] ) ;
104565: LD_VAR 0 1
104569: PUSH
104570: LD_INT 1
104572: ARRAY
104573: PPUSH
104574: CALL_OW 65
// end ;
104578: PPOPN 1
104580: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104581: LD_EXP 77
104585: PUSH
104586: LD_EXP 115
104590: AND
104591: IFFALSE 104720
104593: GO 104595
104595: DISABLE
104596: LD_INT 0
104598: PPUSH
// begin uc_side := 0 ;
104599: LD_ADDR_OWVAR 20
104603: PUSH
104604: LD_INT 0
104606: ST_TO_ADDR
// uc_nation := nation_arabian ;
104607: LD_ADDR_OWVAR 21
104611: PUSH
104612: LD_INT 2
104614: ST_TO_ADDR
// hc_gallery :=  ;
104615: LD_ADDR_OWVAR 33
104619: PUSH
104620: LD_STRING 
104622: ST_TO_ADDR
// hc_name :=  ;
104623: LD_ADDR_OWVAR 26
104627: PUSH
104628: LD_STRING 
104630: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104631: LD_INT 1
104633: PPUSH
104634: LD_INT 11
104636: PPUSH
104637: LD_INT 10
104639: PPUSH
104640: CALL_OW 380
// un := CreateHuman ;
104644: LD_ADDR_VAR 0 1
104648: PUSH
104649: CALL_OW 44
104653: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104654: LD_VAR 0 1
104658: PPUSH
104659: LD_INT 1
104661: PPUSH
104662: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104666: LD_INT 35
104668: PPUSH
104669: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104673: LD_VAR 0 1
104677: PPUSH
104678: LD_INT 22
104680: PUSH
104681: LD_OWVAR 2
104685: PUSH
104686: EMPTY
104687: LIST
104688: LIST
104689: PPUSH
104690: CALL_OW 69
104694: PPUSH
104695: LD_VAR 0 1
104699: PPUSH
104700: CALL_OW 74
104704: PPUSH
104705: CALL_OW 115
// until IsDead ( un ) ;
104709: LD_VAR 0 1
104713: PPUSH
104714: CALL_OW 301
104718: IFFALSE 104666
// end ;
104720: PPOPN 1
104722: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104723: LD_EXP 77
104727: PUSH
104728: LD_EXP 117
104732: AND
104733: IFFALSE 104745
104735: GO 104737
104737: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104738: LD_STRING earthquake(getX(game), 0, 32)
104740: PPUSH
104741: CALL_OW 559
104745: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104746: LD_EXP 77
104750: PUSH
104751: LD_EXP 118
104755: AND
104756: IFFALSE 104847
104758: GO 104760
104760: DISABLE
104761: LD_INT 0
104763: PPUSH
// begin enable ;
104764: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104765: LD_ADDR_VAR 0 1
104769: PUSH
104770: LD_INT 22
104772: PUSH
104773: LD_OWVAR 2
104777: PUSH
104778: EMPTY
104779: LIST
104780: LIST
104781: PUSH
104782: LD_INT 21
104784: PUSH
104785: LD_INT 2
104787: PUSH
104788: EMPTY
104789: LIST
104790: LIST
104791: PUSH
104792: LD_INT 33
104794: PUSH
104795: LD_INT 3
104797: PUSH
104798: EMPTY
104799: LIST
104800: LIST
104801: PUSH
104802: EMPTY
104803: LIST
104804: LIST
104805: LIST
104806: PPUSH
104807: CALL_OW 69
104811: ST_TO_ADDR
// if not tmp then
104812: LD_VAR 0 1
104816: NOT
104817: IFFALSE 104821
// exit ;
104819: GO 104847
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104821: LD_VAR 0 1
104825: PUSH
104826: LD_INT 1
104828: PPUSH
104829: LD_VAR 0 1
104833: PPUSH
104834: CALL_OW 12
104838: ARRAY
104839: PPUSH
104840: LD_INT 1
104842: PPUSH
104843: CALL_OW 234
// end ;
104847: PPOPN 1
104849: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104850: LD_EXP 77
104854: PUSH
104855: LD_EXP 119
104859: AND
104860: IFFALSE 105001
104862: GO 104864
104864: DISABLE
104865: LD_INT 0
104867: PPUSH
104868: PPUSH
104869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104870: LD_ADDR_VAR 0 3
104874: PUSH
104875: LD_INT 22
104877: PUSH
104878: LD_OWVAR 2
104882: PUSH
104883: EMPTY
104884: LIST
104885: LIST
104886: PUSH
104887: LD_INT 25
104889: PUSH
104890: LD_INT 1
104892: PUSH
104893: EMPTY
104894: LIST
104895: LIST
104896: PUSH
104897: EMPTY
104898: LIST
104899: LIST
104900: PPUSH
104901: CALL_OW 69
104905: ST_TO_ADDR
// if not tmp then
104906: LD_VAR 0 3
104910: NOT
104911: IFFALSE 104915
// exit ;
104913: GO 105001
// un := tmp [ rand ( 1 , tmp ) ] ;
104915: LD_ADDR_VAR 0 2
104919: PUSH
104920: LD_VAR 0 3
104924: PUSH
104925: LD_INT 1
104927: PPUSH
104928: LD_VAR 0 3
104932: PPUSH
104933: CALL_OW 12
104937: ARRAY
104938: ST_TO_ADDR
// if Crawls ( un ) then
104939: LD_VAR 0 2
104943: PPUSH
104944: CALL_OW 318
104948: IFFALSE 104959
// ComWalk ( un ) ;
104950: LD_VAR 0 2
104954: PPUSH
104955: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104959: LD_VAR 0 2
104963: PPUSH
104964: LD_INT 9
104966: PPUSH
104967: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104971: LD_INT 28
104973: PPUSH
104974: LD_OWVAR 2
104978: PPUSH
104979: LD_INT 2
104981: PPUSH
104982: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104986: LD_INT 29
104988: PPUSH
104989: LD_OWVAR 2
104993: PPUSH
104994: LD_INT 2
104996: PPUSH
104997: CALL_OW 322
// end ;
105001: PPOPN 3
105003: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105004: LD_EXP 77
105008: PUSH
105009: LD_EXP 120
105013: AND
105014: IFFALSE 105125
105016: GO 105018
105018: DISABLE
105019: LD_INT 0
105021: PPUSH
105022: PPUSH
105023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105024: LD_ADDR_VAR 0 3
105028: PUSH
105029: LD_INT 22
105031: PUSH
105032: LD_OWVAR 2
105036: PUSH
105037: EMPTY
105038: LIST
105039: LIST
105040: PUSH
105041: LD_INT 25
105043: PUSH
105044: LD_INT 1
105046: PUSH
105047: EMPTY
105048: LIST
105049: LIST
105050: PUSH
105051: EMPTY
105052: LIST
105053: LIST
105054: PPUSH
105055: CALL_OW 69
105059: ST_TO_ADDR
// if not tmp then
105060: LD_VAR 0 3
105064: NOT
105065: IFFALSE 105069
// exit ;
105067: GO 105125
// un := tmp [ rand ( 1 , tmp ) ] ;
105069: LD_ADDR_VAR 0 2
105073: PUSH
105074: LD_VAR 0 3
105078: PUSH
105079: LD_INT 1
105081: PPUSH
105082: LD_VAR 0 3
105086: PPUSH
105087: CALL_OW 12
105091: ARRAY
105092: ST_TO_ADDR
// if Crawls ( un ) then
105093: LD_VAR 0 2
105097: PPUSH
105098: CALL_OW 318
105102: IFFALSE 105113
// ComWalk ( un ) ;
105104: LD_VAR 0 2
105108: PPUSH
105109: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105113: LD_VAR 0 2
105117: PPUSH
105118: LD_INT 8
105120: PPUSH
105121: CALL_OW 336
// end ;
105125: PPOPN 3
105127: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105128: LD_EXP 77
105132: PUSH
105133: LD_EXP 121
105137: AND
105138: IFFALSE 105282
105140: GO 105142
105142: DISABLE
105143: LD_INT 0
105145: PPUSH
105146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105147: LD_ADDR_VAR 0 2
105151: PUSH
105152: LD_INT 22
105154: PUSH
105155: LD_OWVAR 2
105159: PUSH
105160: EMPTY
105161: LIST
105162: LIST
105163: PUSH
105164: LD_INT 21
105166: PUSH
105167: LD_INT 2
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: PUSH
105174: LD_INT 2
105176: PUSH
105177: LD_INT 34
105179: PUSH
105180: LD_INT 12
105182: PUSH
105183: EMPTY
105184: LIST
105185: LIST
105186: PUSH
105187: LD_INT 34
105189: PUSH
105190: LD_INT 51
105192: PUSH
105193: EMPTY
105194: LIST
105195: LIST
105196: PUSH
105197: LD_INT 34
105199: PUSH
105200: LD_INT 32
105202: PUSH
105203: EMPTY
105204: LIST
105205: LIST
105206: PUSH
105207: EMPTY
105208: LIST
105209: LIST
105210: LIST
105211: LIST
105212: PUSH
105213: EMPTY
105214: LIST
105215: LIST
105216: LIST
105217: PPUSH
105218: CALL_OW 69
105222: ST_TO_ADDR
// if not tmp then
105223: LD_VAR 0 2
105227: NOT
105228: IFFALSE 105232
// exit ;
105230: GO 105282
// for i in tmp do
105232: LD_ADDR_VAR 0 1
105236: PUSH
105237: LD_VAR 0 2
105241: PUSH
105242: FOR_IN
105243: IFFALSE 105280
// if GetCargo ( i , mat_artifact ) = 0 then
105245: LD_VAR 0 1
105249: PPUSH
105250: LD_INT 4
105252: PPUSH
105253: CALL_OW 289
105257: PUSH
105258: LD_INT 0
105260: EQUAL
105261: IFFALSE 105278
// SetCargo ( i , mat_siberit , 100 ) ;
105263: LD_VAR 0 1
105267: PPUSH
105268: LD_INT 3
105270: PPUSH
105271: LD_INT 100
105273: PPUSH
105274: CALL_OW 290
105278: GO 105242
105280: POP
105281: POP
// end ;
105282: PPOPN 2
105284: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105285: LD_EXP 77
105289: PUSH
105290: LD_EXP 122
105294: AND
105295: IFFALSE 105478
105297: GO 105299
105299: DISABLE
105300: LD_INT 0
105302: PPUSH
105303: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105304: LD_ADDR_VAR 0 2
105308: PUSH
105309: LD_INT 22
105311: PUSH
105312: LD_OWVAR 2
105316: PUSH
105317: EMPTY
105318: LIST
105319: LIST
105320: PPUSH
105321: CALL_OW 69
105325: ST_TO_ADDR
// if not tmp then
105326: LD_VAR 0 2
105330: NOT
105331: IFFALSE 105335
// exit ;
105333: GO 105478
// for i := 1 to 2 do
105335: LD_ADDR_VAR 0 1
105339: PUSH
105340: DOUBLE
105341: LD_INT 1
105343: DEC
105344: ST_TO_ADDR
105345: LD_INT 2
105347: PUSH
105348: FOR_TO
105349: IFFALSE 105476
// begin uc_side := your_side ;
105351: LD_ADDR_OWVAR 20
105355: PUSH
105356: LD_OWVAR 2
105360: ST_TO_ADDR
// uc_nation := nation_american ;
105361: LD_ADDR_OWVAR 21
105365: PUSH
105366: LD_INT 1
105368: ST_TO_ADDR
// vc_chassis := us_morphling ;
105369: LD_ADDR_OWVAR 37
105373: PUSH
105374: LD_INT 5
105376: ST_TO_ADDR
// vc_engine := engine_siberite ;
105377: LD_ADDR_OWVAR 39
105381: PUSH
105382: LD_INT 3
105384: ST_TO_ADDR
// vc_control := control_computer ;
105385: LD_ADDR_OWVAR 38
105389: PUSH
105390: LD_INT 3
105392: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105393: LD_ADDR_OWVAR 40
105397: PUSH
105398: LD_INT 10
105400: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105401: LD_VAR 0 2
105405: PUSH
105406: LD_INT 1
105408: ARRAY
105409: PPUSH
105410: CALL_OW 310
105414: NOT
105415: IFFALSE 105462
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105417: CALL_OW 45
105421: PPUSH
105422: LD_VAR 0 2
105426: PUSH
105427: LD_INT 1
105429: ARRAY
105430: PPUSH
105431: CALL_OW 250
105435: PPUSH
105436: LD_VAR 0 2
105440: PUSH
105441: LD_INT 1
105443: ARRAY
105444: PPUSH
105445: CALL_OW 251
105449: PPUSH
105450: LD_INT 12
105452: PPUSH
105453: LD_INT 1
105455: PPUSH
105456: CALL_OW 50
105460: GO 105474
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105462: CALL_OW 45
105466: PPUSH
105467: LD_INT 1
105469: PPUSH
105470: CALL_OW 51
// end ;
105474: GO 105348
105476: POP
105477: POP
// end ;
105478: PPOPN 2
105480: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105481: LD_EXP 77
105485: PUSH
105486: LD_EXP 123
105490: AND
105491: IFFALSE 105713
105493: GO 105495
105495: DISABLE
105496: LD_INT 0
105498: PPUSH
105499: PPUSH
105500: PPUSH
105501: PPUSH
105502: PPUSH
105503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105504: LD_ADDR_VAR 0 6
105508: PUSH
105509: LD_INT 22
105511: PUSH
105512: LD_OWVAR 2
105516: PUSH
105517: EMPTY
105518: LIST
105519: LIST
105520: PUSH
105521: LD_INT 21
105523: PUSH
105524: LD_INT 1
105526: PUSH
105527: EMPTY
105528: LIST
105529: LIST
105530: PUSH
105531: LD_INT 3
105533: PUSH
105534: LD_INT 23
105536: PUSH
105537: LD_INT 0
105539: PUSH
105540: EMPTY
105541: LIST
105542: LIST
105543: PUSH
105544: EMPTY
105545: LIST
105546: LIST
105547: PUSH
105548: EMPTY
105549: LIST
105550: LIST
105551: LIST
105552: PPUSH
105553: CALL_OW 69
105557: ST_TO_ADDR
// if not tmp then
105558: LD_VAR 0 6
105562: NOT
105563: IFFALSE 105567
// exit ;
105565: GO 105713
// s1 := rand ( 1 , 4 ) ;
105567: LD_ADDR_VAR 0 2
105571: PUSH
105572: LD_INT 1
105574: PPUSH
105575: LD_INT 4
105577: PPUSH
105578: CALL_OW 12
105582: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105583: LD_ADDR_VAR 0 4
105587: PUSH
105588: LD_VAR 0 6
105592: PUSH
105593: LD_INT 1
105595: ARRAY
105596: PPUSH
105597: LD_VAR 0 2
105601: PPUSH
105602: CALL_OW 259
105606: ST_TO_ADDR
// if s1 = 1 then
105607: LD_VAR 0 2
105611: PUSH
105612: LD_INT 1
105614: EQUAL
105615: IFFALSE 105635
// s2 := rand ( 2 , 4 ) else
105617: LD_ADDR_VAR 0 3
105621: PUSH
105622: LD_INT 2
105624: PPUSH
105625: LD_INT 4
105627: PPUSH
105628: CALL_OW 12
105632: ST_TO_ADDR
105633: GO 105643
// s2 := 1 ;
105635: LD_ADDR_VAR 0 3
105639: PUSH
105640: LD_INT 1
105642: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105643: LD_ADDR_VAR 0 5
105647: PUSH
105648: LD_VAR 0 6
105652: PUSH
105653: LD_INT 1
105655: ARRAY
105656: PPUSH
105657: LD_VAR 0 3
105661: PPUSH
105662: CALL_OW 259
105666: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105667: LD_VAR 0 6
105671: PUSH
105672: LD_INT 1
105674: ARRAY
105675: PPUSH
105676: LD_VAR 0 2
105680: PPUSH
105681: LD_VAR 0 5
105685: PPUSH
105686: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105690: LD_VAR 0 6
105694: PUSH
105695: LD_INT 1
105697: ARRAY
105698: PPUSH
105699: LD_VAR 0 3
105703: PPUSH
105704: LD_VAR 0 4
105708: PPUSH
105709: CALL_OW 237
// end ;
105713: PPOPN 6
105715: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105716: LD_EXP 77
105720: PUSH
105721: LD_EXP 124
105725: AND
105726: IFFALSE 105805
105728: GO 105730
105730: DISABLE
105731: LD_INT 0
105733: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105734: LD_ADDR_VAR 0 1
105738: PUSH
105739: LD_INT 22
105741: PUSH
105742: LD_OWVAR 2
105746: PUSH
105747: EMPTY
105748: LIST
105749: LIST
105750: PUSH
105751: LD_INT 30
105753: PUSH
105754: LD_INT 3
105756: PUSH
105757: EMPTY
105758: LIST
105759: LIST
105760: PUSH
105761: EMPTY
105762: LIST
105763: LIST
105764: PPUSH
105765: CALL_OW 69
105769: ST_TO_ADDR
// if not tmp then
105770: LD_VAR 0 1
105774: NOT
105775: IFFALSE 105779
// exit ;
105777: GO 105805
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105779: LD_VAR 0 1
105783: PUSH
105784: LD_INT 1
105786: PPUSH
105787: LD_VAR 0 1
105791: PPUSH
105792: CALL_OW 12
105796: ARRAY
105797: PPUSH
105798: LD_INT 1
105800: PPUSH
105801: CALL_OW 234
// end ;
105805: PPOPN 1
105807: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105808: LD_EXP 77
105812: PUSH
105813: LD_EXP 125
105817: AND
105818: IFFALSE 105930
105820: GO 105822
105822: DISABLE
105823: LD_INT 0
105825: PPUSH
105826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105827: LD_ADDR_VAR 0 2
105831: PUSH
105832: LD_INT 22
105834: PUSH
105835: LD_OWVAR 2
105839: PUSH
105840: EMPTY
105841: LIST
105842: LIST
105843: PUSH
105844: LD_INT 2
105846: PUSH
105847: LD_INT 30
105849: PUSH
105850: LD_INT 27
105852: PUSH
105853: EMPTY
105854: LIST
105855: LIST
105856: PUSH
105857: LD_INT 30
105859: PUSH
105860: LD_INT 26
105862: PUSH
105863: EMPTY
105864: LIST
105865: LIST
105866: PUSH
105867: LD_INT 30
105869: PUSH
105870: LD_INT 28
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: PUSH
105877: EMPTY
105878: LIST
105879: LIST
105880: LIST
105881: LIST
105882: PUSH
105883: EMPTY
105884: LIST
105885: LIST
105886: PPUSH
105887: CALL_OW 69
105891: ST_TO_ADDR
// if not tmp then
105892: LD_VAR 0 2
105896: NOT
105897: IFFALSE 105901
// exit ;
105899: GO 105930
// for i in tmp do
105901: LD_ADDR_VAR 0 1
105905: PUSH
105906: LD_VAR 0 2
105910: PUSH
105911: FOR_IN
105912: IFFALSE 105928
// SetLives ( i , 1 ) ;
105914: LD_VAR 0 1
105918: PPUSH
105919: LD_INT 1
105921: PPUSH
105922: CALL_OW 234
105926: GO 105911
105928: POP
105929: POP
// end ;
105930: PPOPN 2
105932: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105933: LD_EXP 77
105937: PUSH
105938: LD_EXP 126
105942: AND
105943: IFFALSE 106230
105945: GO 105947
105947: DISABLE
105948: LD_INT 0
105950: PPUSH
105951: PPUSH
105952: PPUSH
// begin i := rand ( 1 , 7 ) ;
105953: LD_ADDR_VAR 0 1
105957: PUSH
105958: LD_INT 1
105960: PPUSH
105961: LD_INT 7
105963: PPUSH
105964: CALL_OW 12
105968: ST_TO_ADDR
// case i of 1 :
105969: LD_VAR 0 1
105973: PUSH
105974: LD_INT 1
105976: DOUBLE
105977: EQUAL
105978: IFTRUE 105982
105980: GO 105992
105982: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105983: LD_STRING earthquake(getX(game), 0, 32)
105985: PPUSH
105986: CALL_OW 559
105990: GO 106230
105992: LD_INT 2
105994: DOUBLE
105995: EQUAL
105996: IFTRUE 106000
105998: GO 106014
106000: POP
// begin ToLua ( displayStucuk(); ) ;
106001: LD_STRING displayStucuk();
106003: PPUSH
106004: CALL_OW 559
// ResetFog ;
106008: CALL_OW 335
// end ; 3 :
106012: GO 106230
106014: LD_INT 3
106016: DOUBLE
106017: EQUAL
106018: IFTRUE 106022
106020: GO 106126
106022: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106023: LD_ADDR_VAR 0 2
106027: PUSH
106028: LD_INT 22
106030: PUSH
106031: LD_OWVAR 2
106035: PUSH
106036: EMPTY
106037: LIST
106038: LIST
106039: PUSH
106040: LD_INT 25
106042: PUSH
106043: LD_INT 1
106045: PUSH
106046: EMPTY
106047: LIST
106048: LIST
106049: PUSH
106050: EMPTY
106051: LIST
106052: LIST
106053: PPUSH
106054: CALL_OW 69
106058: ST_TO_ADDR
// if not tmp then
106059: LD_VAR 0 2
106063: NOT
106064: IFFALSE 106068
// exit ;
106066: GO 106230
// un := tmp [ rand ( 1 , tmp ) ] ;
106068: LD_ADDR_VAR 0 3
106072: PUSH
106073: LD_VAR 0 2
106077: PUSH
106078: LD_INT 1
106080: PPUSH
106081: LD_VAR 0 2
106085: PPUSH
106086: CALL_OW 12
106090: ARRAY
106091: ST_TO_ADDR
// if Crawls ( un ) then
106092: LD_VAR 0 3
106096: PPUSH
106097: CALL_OW 318
106101: IFFALSE 106112
// ComWalk ( un ) ;
106103: LD_VAR 0 3
106107: PPUSH
106108: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106112: LD_VAR 0 3
106116: PPUSH
106117: LD_INT 8
106119: PPUSH
106120: CALL_OW 336
// end ; 4 :
106124: GO 106230
106126: LD_INT 4
106128: DOUBLE
106129: EQUAL
106130: IFTRUE 106134
106132: GO 106208
106134: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106135: LD_ADDR_VAR 0 2
106139: PUSH
106140: LD_INT 22
106142: PUSH
106143: LD_OWVAR 2
106147: PUSH
106148: EMPTY
106149: LIST
106150: LIST
106151: PUSH
106152: LD_INT 30
106154: PUSH
106155: LD_INT 29
106157: PUSH
106158: EMPTY
106159: LIST
106160: LIST
106161: PUSH
106162: EMPTY
106163: LIST
106164: LIST
106165: PPUSH
106166: CALL_OW 69
106170: ST_TO_ADDR
// if not tmp then
106171: LD_VAR 0 2
106175: NOT
106176: IFFALSE 106180
// exit ;
106178: GO 106230
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106180: LD_VAR 0 2
106184: PUSH
106185: LD_INT 1
106187: ARRAY
106188: PPUSH
106189: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106193: LD_VAR 0 2
106197: PUSH
106198: LD_INT 1
106200: ARRAY
106201: PPUSH
106202: CALL_OW 65
// end ; 5 .. 7 :
106206: GO 106230
106208: LD_INT 5
106210: DOUBLE
106211: GREATEREQUAL
106212: IFFALSE 106220
106214: LD_INT 7
106216: DOUBLE
106217: LESSEQUAL
106218: IFTRUE 106222
106220: GO 106229
106222: POP
// StreamSibBomb ; end ;
106223: CALL 102467 0 0
106227: GO 106230
106229: POP
// end ;
106230: PPOPN 3
106232: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106233: LD_EXP 77
106237: PUSH
106238: LD_EXP 127
106242: AND
106243: IFFALSE 106399
106245: GO 106247
106247: DISABLE
106248: LD_INT 0
106250: PPUSH
106251: PPUSH
106252: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106253: LD_ADDR_VAR 0 2
106257: PUSH
106258: LD_INT 81
106260: PUSH
106261: LD_OWVAR 2
106265: PUSH
106266: EMPTY
106267: LIST
106268: LIST
106269: PUSH
106270: LD_INT 2
106272: PUSH
106273: LD_INT 21
106275: PUSH
106276: LD_INT 1
106278: PUSH
106279: EMPTY
106280: LIST
106281: LIST
106282: PUSH
106283: LD_INT 21
106285: PUSH
106286: LD_INT 2
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: LIST
106297: PUSH
106298: EMPTY
106299: LIST
106300: LIST
106301: PPUSH
106302: CALL_OW 69
106306: ST_TO_ADDR
// if not tmp then
106307: LD_VAR 0 2
106311: NOT
106312: IFFALSE 106316
// exit ;
106314: GO 106399
// p := 0 ;
106316: LD_ADDR_VAR 0 3
106320: PUSH
106321: LD_INT 0
106323: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106324: LD_INT 35
106326: PPUSH
106327: CALL_OW 67
// p := p + 1 ;
106331: LD_ADDR_VAR 0 3
106335: PUSH
106336: LD_VAR 0 3
106340: PUSH
106341: LD_INT 1
106343: PLUS
106344: ST_TO_ADDR
// for i in tmp do
106345: LD_ADDR_VAR 0 1
106349: PUSH
106350: LD_VAR 0 2
106354: PUSH
106355: FOR_IN
106356: IFFALSE 106387
// if GetLives ( i ) < 1000 then
106358: LD_VAR 0 1
106362: PPUSH
106363: CALL_OW 256
106367: PUSH
106368: LD_INT 1000
106370: LESS
106371: IFFALSE 106385
// SetLives ( i , 1000 ) ;
106373: LD_VAR 0 1
106377: PPUSH
106378: LD_INT 1000
106380: PPUSH
106381: CALL_OW 234
106385: GO 106355
106387: POP
106388: POP
// until p > 20 ;
106389: LD_VAR 0 3
106393: PUSH
106394: LD_INT 20
106396: GREATER
106397: IFFALSE 106324
// end ;
106399: PPOPN 3
106401: END
// every 0 0$1 trigger StreamModeActive and sTime do
106402: LD_EXP 77
106406: PUSH
106407: LD_EXP 128
106411: AND
106412: IFFALSE 106447
106414: GO 106416
106416: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106417: LD_INT 28
106419: PPUSH
106420: LD_OWVAR 2
106424: PPUSH
106425: LD_INT 2
106427: PPUSH
106428: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106432: LD_INT 30
106434: PPUSH
106435: LD_OWVAR 2
106439: PPUSH
106440: LD_INT 2
106442: PPUSH
106443: CALL_OW 322
// end ;
106447: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106448: LD_EXP 77
106452: PUSH
106453: LD_EXP 129
106457: AND
106458: IFFALSE 106579
106460: GO 106462
106462: DISABLE
106463: LD_INT 0
106465: PPUSH
106466: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106467: LD_ADDR_VAR 0 2
106471: PUSH
106472: LD_INT 22
106474: PUSH
106475: LD_OWVAR 2
106479: PUSH
106480: EMPTY
106481: LIST
106482: LIST
106483: PUSH
106484: LD_INT 21
106486: PUSH
106487: LD_INT 1
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: PUSH
106494: LD_INT 3
106496: PUSH
106497: LD_INT 23
106499: PUSH
106500: LD_INT 0
106502: PUSH
106503: EMPTY
106504: LIST
106505: LIST
106506: PUSH
106507: EMPTY
106508: LIST
106509: LIST
106510: PUSH
106511: EMPTY
106512: LIST
106513: LIST
106514: LIST
106515: PPUSH
106516: CALL_OW 69
106520: ST_TO_ADDR
// if not tmp then
106521: LD_VAR 0 2
106525: NOT
106526: IFFALSE 106530
// exit ;
106528: GO 106579
// for i in tmp do
106530: LD_ADDR_VAR 0 1
106534: PUSH
106535: LD_VAR 0 2
106539: PUSH
106540: FOR_IN
106541: IFFALSE 106577
// begin if Crawls ( i ) then
106543: LD_VAR 0 1
106547: PPUSH
106548: CALL_OW 318
106552: IFFALSE 106563
// ComWalk ( i ) ;
106554: LD_VAR 0 1
106558: PPUSH
106559: CALL_OW 138
// SetClass ( i , 2 ) ;
106563: LD_VAR 0 1
106567: PPUSH
106568: LD_INT 2
106570: PPUSH
106571: CALL_OW 336
// end ;
106575: GO 106540
106577: POP
106578: POP
// end ;
106579: PPOPN 2
106581: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106582: LD_EXP 77
106586: PUSH
106587: LD_EXP 130
106591: AND
106592: IFFALSE 106880
106594: GO 106596
106596: DISABLE
106597: LD_INT 0
106599: PPUSH
106600: PPUSH
106601: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106602: LD_OWVAR 2
106606: PPUSH
106607: LD_INT 9
106609: PPUSH
106610: LD_INT 1
106612: PPUSH
106613: LD_INT 1
106615: PPUSH
106616: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106620: LD_INT 9
106622: PPUSH
106623: LD_OWVAR 2
106627: PPUSH
106628: CALL_OW 343
// uc_side := 9 ;
106632: LD_ADDR_OWVAR 20
106636: PUSH
106637: LD_INT 9
106639: ST_TO_ADDR
// uc_nation := 2 ;
106640: LD_ADDR_OWVAR 21
106644: PUSH
106645: LD_INT 2
106647: ST_TO_ADDR
// hc_name := Dark Warrior ;
106648: LD_ADDR_OWVAR 26
106652: PUSH
106653: LD_STRING Dark Warrior
106655: ST_TO_ADDR
// hc_gallery :=  ;
106656: LD_ADDR_OWVAR 33
106660: PUSH
106661: LD_STRING 
106663: ST_TO_ADDR
// hc_noskilllimit := true ;
106664: LD_ADDR_OWVAR 76
106668: PUSH
106669: LD_INT 1
106671: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106672: LD_ADDR_OWVAR 31
106676: PUSH
106677: LD_INT 30
106679: PUSH
106680: LD_INT 30
106682: PUSH
106683: LD_INT 30
106685: PUSH
106686: LD_INT 30
106688: PUSH
106689: EMPTY
106690: LIST
106691: LIST
106692: LIST
106693: LIST
106694: ST_TO_ADDR
// un := CreateHuman ;
106695: LD_ADDR_VAR 0 3
106699: PUSH
106700: CALL_OW 44
106704: ST_TO_ADDR
// hc_noskilllimit := false ;
106705: LD_ADDR_OWVAR 76
106709: PUSH
106710: LD_INT 0
106712: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106713: LD_VAR 0 3
106717: PPUSH
106718: LD_INT 1
106720: PPUSH
106721: CALL_OW 51
// ToLua ( playRanger() ) ;
106725: LD_STRING playRanger()
106727: PPUSH
106728: CALL_OW 559
// p := 0 ;
106732: LD_ADDR_VAR 0 2
106736: PUSH
106737: LD_INT 0
106739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106740: LD_INT 35
106742: PPUSH
106743: CALL_OW 67
// p := p + 1 ;
106747: LD_ADDR_VAR 0 2
106751: PUSH
106752: LD_VAR 0 2
106756: PUSH
106757: LD_INT 1
106759: PLUS
106760: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106761: LD_VAR 0 3
106765: PPUSH
106766: CALL_OW 256
106770: PUSH
106771: LD_INT 1000
106773: LESS
106774: IFFALSE 106788
// SetLives ( un , 1000 ) ;
106776: LD_VAR 0 3
106780: PPUSH
106781: LD_INT 1000
106783: PPUSH
106784: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106788: LD_VAR 0 3
106792: PPUSH
106793: LD_INT 81
106795: PUSH
106796: LD_OWVAR 2
106800: PUSH
106801: EMPTY
106802: LIST
106803: LIST
106804: PUSH
106805: LD_INT 91
106807: PUSH
106808: LD_VAR 0 3
106812: PUSH
106813: LD_INT 30
106815: PUSH
106816: EMPTY
106817: LIST
106818: LIST
106819: LIST
106820: PUSH
106821: EMPTY
106822: LIST
106823: LIST
106824: PPUSH
106825: CALL_OW 69
106829: PPUSH
106830: LD_VAR 0 3
106834: PPUSH
106835: CALL_OW 74
106839: PPUSH
106840: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106844: LD_VAR 0 2
106848: PUSH
106849: LD_INT 80
106851: GREATER
106852: PUSH
106853: LD_VAR 0 3
106857: PPUSH
106858: CALL_OW 301
106862: OR
106863: IFFALSE 106740
// if un then
106865: LD_VAR 0 3
106869: IFFALSE 106880
// RemoveUnit ( un ) ;
106871: LD_VAR 0 3
106875: PPUSH
106876: CALL_OW 64
// end ;
106880: PPOPN 3
106882: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106883: LD_EXP 131
106887: IFFALSE 107003
106889: GO 106891
106891: DISABLE
106892: LD_INT 0
106894: PPUSH
106895: PPUSH
106896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106897: LD_ADDR_VAR 0 2
106901: PUSH
106902: LD_INT 81
106904: PUSH
106905: LD_OWVAR 2
106909: PUSH
106910: EMPTY
106911: LIST
106912: LIST
106913: PUSH
106914: LD_INT 21
106916: PUSH
106917: LD_INT 1
106919: PUSH
106920: EMPTY
106921: LIST
106922: LIST
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: PPUSH
106928: CALL_OW 69
106932: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106933: LD_STRING playComputer()
106935: PPUSH
106936: CALL_OW 559
// if not tmp then
106940: LD_VAR 0 2
106944: NOT
106945: IFFALSE 106949
// exit ;
106947: GO 107003
// for i in tmp do
106949: LD_ADDR_VAR 0 1
106953: PUSH
106954: LD_VAR 0 2
106958: PUSH
106959: FOR_IN
106960: IFFALSE 107001
// for j := 1 to 4 do
106962: LD_ADDR_VAR 0 3
106966: PUSH
106967: DOUBLE
106968: LD_INT 1
106970: DEC
106971: ST_TO_ADDR
106972: LD_INT 4
106974: PUSH
106975: FOR_TO
106976: IFFALSE 106997
// SetSkill ( i , j , 10 ) ;
106978: LD_VAR 0 1
106982: PPUSH
106983: LD_VAR 0 3
106987: PPUSH
106988: LD_INT 10
106990: PPUSH
106991: CALL_OW 237
106995: GO 106975
106997: POP
106998: POP
106999: GO 106959
107001: POP
107002: POP
// end ;
107003: PPOPN 3
107005: END
// every 0 0$1 trigger s30 do var i , tmp ;
107006: LD_EXP 132
107010: IFFALSE 107079
107012: GO 107014
107014: DISABLE
107015: LD_INT 0
107017: PPUSH
107018: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107019: LD_ADDR_VAR 0 2
107023: PUSH
107024: LD_INT 22
107026: PUSH
107027: LD_OWVAR 2
107031: PUSH
107032: EMPTY
107033: LIST
107034: LIST
107035: PPUSH
107036: CALL_OW 69
107040: ST_TO_ADDR
// if not tmp then
107041: LD_VAR 0 2
107045: NOT
107046: IFFALSE 107050
// exit ;
107048: GO 107079
// for i in tmp do
107050: LD_ADDR_VAR 0 1
107054: PUSH
107055: LD_VAR 0 2
107059: PUSH
107060: FOR_IN
107061: IFFALSE 107077
// SetLives ( i , 300 ) ;
107063: LD_VAR 0 1
107067: PPUSH
107068: LD_INT 300
107070: PPUSH
107071: CALL_OW 234
107075: GO 107060
107077: POP
107078: POP
// end ;
107079: PPOPN 2
107081: END
// every 0 0$1 trigger s60 do var i , tmp ;
107082: LD_EXP 133
107086: IFFALSE 107155
107088: GO 107090
107090: DISABLE
107091: LD_INT 0
107093: PPUSH
107094: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107095: LD_ADDR_VAR 0 2
107099: PUSH
107100: LD_INT 22
107102: PUSH
107103: LD_OWVAR 2
107107: PUSH
107108: EMPTY
107109: LIST
107110: LIST
107111: PPUSH
107112: CALL_OW 69
107116: ST_TO_ADDR
// if not tmp then
107117: LD_VAR 0 2
107121: NOT
107122: IFFALSE 107126
// exit ;
107124: GO 107155
// for i in tmp do
107126: LD_ADDR_VAR 0 1
107130: PUSH
107131: LD_VAR 0 2
107135: PUSH
107136: FOR_IN
107137: IFFALSE 107153
// SetLives ( i , 600 ) ;
107139: LD_VAR 0 1
107143: PPUSH
107144: LD_INT 600
107146: PPUSH
107147: CALL_OW 234
107151: GO 107136
107153: POP
107154: POP
// end ;
107155: PPOPN 2
107157: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107158: LD_INT 0
107160: PPUSH
// case cmd of 301 :
107161: LD_VAR 0 1
107165: PUSH
107166: LD_INT 301
107168: DOUBLE
107169: EQUAL
107170: IFTRUE 107174
107172: GO 107206
107174: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107175: LD_VAR 0 6
107179: PPUSH
107180: LD_VAR 0 7
107184: PPUSH
107185: LD_VAR 0 8
107189: PPUSH
107190: LD_VAR 0 4
107194: PPUSH
107195: LD_VAR 0 5
107199: PPUSH
107200: CALL 108407 0 5
107204: GO 107327
107206: LD_INT 302
107208: DOUBLE
107209: EQUAL
107210: IFTRUE 107214
107212: GO 107251
107214: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107215: LD_VAR 0 6
107219: PPUSH
107220: LD_VAR 0 7
107224: PPUSH
107225: LD_VAR 0 8
107229: PPUSH
107230: LD_VAR 0 9
107234: PPUSH
107235: LD_VAR 0 4
107239: PPUSH
107240: LD_VAR 0 5
107244: PPUSH
107245: CALL 108498 0 6
107249: GO 107327
107251: LD_INT 303
107253: DOUBLE
107254: EQUAL
107255: IFTRUE 107259
107257: GO 107296
107259: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107260: LD_VAR 0 6
107264: PPUSH
107265: LD_VAR 0 7
107269: PPUSH
107270: LD_VAR 0 8
107274: PPUSH
107275: LD_VAR 0 9
107279: PPUSH
107280: LD_VAR 0 4
107284: PPUSH
107285: LD_VAR 0 5
107289: PPUSH
107290: CALL 107332 0 6
107294: GO 107327
107296: LD_INT 304
107298: DOUBLE
107299: EQUAL
107300: IFTRUE 107304
107302: GO 107326
107304: POP
// hHackTeleport ( unit , x , y ) ; end ;
107305: LD_VAR 0 2
107309: PPUSH
107310: LD_VAR 0 4
107314: PPUSH
107315: LD_VAR 0 5
107319: PPUSH
107320: CALL 109091 0 3
107324: GO 107327
107326: POP
// end ;
107327: LD_VAR 0 12
107331: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107332: LD_INT 0
107334: PPUSH
107335: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107336: LD_VAR 0 1
107340: PUSH
107341: LD_INT 1
107343: LESS
107344: PUSH
107345: LD_VAR 0 1
107349: PUSH
107350: LD_INT 3
107352: GREATER
107353: OR
107354: PUSH
107355: LD_VAR 0 5
107359: PPUSH
107360: LD_VAR 0 6
107364: PPUSH
107365: CALL_OW 428
107369: OR
107370: IFFALSE 107374
// exit ;
107372: GO 108094
// uc_side := your_side ;
107374: LD_ADDR_OWVAR 20
107378: PUSH
107379: LD_OWVAR 2
107383: ST_TO_ADDR
// uc_nation := nation ;
107384: LD_ADDR_OWVAR 21
107388: PUSH
107389: LD_VAR 0 1
107393: ST_TO_ADDR
// bc_level = 1 ;
107394: LD_ADDR_OWVAR 43
107398: PUSH
107399: LD_INT 1
107401: ST_TO_ADDR
// case btype of 1 :
107402: LD_VAR 0 2
107406: PUSH
107407: LD_INT 1
107409: DOUBLE
107410: EQUAL
107411: IFTRUE 107415
107413: GO 107426
107415: POP
// bc_type := b_depot ; 2 :
107416: LD_ADDR_OWVAR 42
107420: PUSH
107421: LD_INT 0
107423: ST_TO_ADDR
107424: GO 108038
107426: LD_INT 2
107428: DOUBLE
107429: EQUAL
107430: IFTRUE 107434
107432: GO 107445
107434: POP
// bc_type := b_warehouse ; 3 :
107435: LD_ADDR_OWVAR 42
107439: PUSH
107440: LD_INT 1
107442: ST_TO_ADDR
107443: GO 108038
107445: LD_INT 3
107447: DOUBLE
107448: EQUAL
107449: IFTRUE 107453
107451: GO 107464
107453: POP
// bc_type := b_lab ; 4 .. 9 :
107454: LD_ADDR_OWVAR 42
107458: PUSH
107459: LD_INT 6
107461: ST_TO_ADDR
107462: GO 108038
107464: LD_INT 4
107466: DOUBLE
107467: GREATEREQUAL
107468: IFFALSE 107476
107470: LD_INT 9
107472: DOUBLE
107473: LESSEQUAL
107474: IFTRUE 107478
107476: GO 107530
107478: POP
// begin bc_type := b_lab_half ;
107479: LD_ADDR_OWVAR 42
107483: PUSH
107484: LD_INT 7
107486: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107487: LD_ADDR_OWVAR 44
107491: PUSH
107492: LD_INT 10
107494: PUSH
107495: LD_INT 11
107497: PUSH
107498: LD_INT 12
107500: PUSH
107501: LD_INT 15
107503: PUSH
107504: LD_INT 14
107506: PUSH
107507: LD_INT 13
107509: PUSH
107510: EMPTY
107511: LIST
107512: LIST
107513: LIST
107514: LIST
107515: LIST
107516: LIST
107517: PUSH
107518: LD_VAR 0 2
107522: PUSH
107523: LD_INT 3
107525: MINUS
107526: ARRAY
107527: ST_TO_ADDR
// end ; 10 .. 13 :
107528: GO 108038
107530: LD_INT 10
107532: DOUBLE
107533: GREATEREQUAL
107534: IFFALSE 107542
107536: LD_INT 13
107538: DOUBLE
107539: LESSEQUAL
107540: IFTRUE 107544
107542: GO 107621
107544: POP
// begin bc_type := b_lab_full ;
107545: LD_ADDR_OWVAR 42
107549: PUSH
107550: LD_INT 8
107552: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107553: LD_ADDR_OWVAR 44
107557: PUSH
107558: LD_INT 10
107560: PUSH
107561: LD_INT 12
107563: PUSH
107564: LD_INT 14
107566: PUSH
107567: LD_INT 13
107569: PUSH
107570: EMPTY
107571: LIST
107572: LIST
107573: LIST
107574: LIST
107575: PUSH
107576: LD_VAR 0 2
107580: PUSH
107581: LD_INT 9
107583: MINUS
107584: ARRAY
107585: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107586: LD_ADDR_OWVAR 45
107590: PUSH
107591: LD_INT 11
107593: PUSH
107594: LD_INT 15
107596: PUSH
107597: LD_INT 12
107599: PUSH
107600: LD_INT 15
107602: PUSH
107603: EMPTY
107604: LIST
107605: LIST
107606: LIST
107607: LIST
107608: PUSH
107609: LD_VAR 0 2
107613: PUSH
107614: LD_INT 9
107616: MINUS
107617: ARRAY
107618: ST_TO_ADDR
// end ; 14 :
107619: GO 108038
107621: LD_INT 14
107623: DOUBLE
107624: EQUAL
107625: IFTRUE 107629
107627: GO 107640
107629: POP
// bc_type := b_workshop ; 15 :
107630: LD_ADDR_OWVAR 42
107634: PUSH
107635: LD_INT 2
107637: ST_TO_ADDR
107638: GO 108038
107640: LD_INT 15
107642: DOUBLE
107643: EQUAL
107644: IFTRUE 107648
107646: GO 107659
107648: POP
// bc_type := b_factory ; 16 :
107649: LD_ADDR_OWVAR 42
107653: PUSH
107654: LD_INT 3
107656: ST_TO_ADDR
107657: GO 108038
107659: LD_INT 16
107661: DOUBLE
107662: EQUAL
107663: IFTRUE 107667
107665: GO 107678
107667: POP
// bc_type := b_ext_gun ; 17 :
107668: LD_ADDR_OWVAR 42
107672: PUSH
107673: LD_INT 17
107675: ST_TO_ADDR
107676: GO 108038
107678: LD_INT 17
107680: DOUBLE
107681: EQUAL
107682: IFTRUE 107686
107684: GO 107714
107686: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107687: LD_ADDR_OWVAR 42
107691: PUSH
107692: LD_INT 19
107694: PUSH
107695: LD_INT 23
107697: PUSH
107698: LD_INT 19
107700: PUSH
107701: EMPTY
107702: LIST
107703: LIST
107704: LIST
107705: PUSH
107706: LD_VAR 0 1
107710: ARRAY
107711: ST_TO_ADDR
107712: GO 108038
107714: LD_INT 18
107716: DOUBLE
107717: EQUAL
107718: IFTRUE 107722
107720: GO 107733
107722: POP
// bc_type := b_ext_radar ; 19 :
107723: LD_ADDR_OWVAR 42
107727: PUSH
107728: LD_INT 20
107730: ST_TO_ADDR
107731: GO 108038
107733: LD_INT 19
107735: DOUBLE
107736: EQUAL
107737: IFTRUE 107741
107739: GO 107752
107741: POP
// bc_type := b_ext_radio ; 20 :
107742: LD_ADDR_OWVAR 42
107746: PUSH
107747: LD_INT 22
107749: ST_TO_ADDR
107750: GO 108038
107752: LD_INT 20
107754: DOUBLE
107755: EQUAL
107756: IFTRUE 107760
107758: GO 107771
107760: POP
// bc_type := b_ext_siberium ; 21 :
107761: LD_ADDR_OWVAR 42
107765: PUSH
107766: LD_INT 21
107768: ST_TO_ADDR
107769: GO 108038
107771: LD_INT 21
107773: DOUBLE
107774: EQUAL
107775: IFTRUE 107779
107777: GO 107790
107779: POP
// bc_type := b_ext_computer ; 22 :
107780: LD_ADDR_OWVAR 42
107784: PUSH
107785: LD_INT 24
107787: ST_TO_ADDR
107788: GO 108038
107790: LD_INT 22
107792: DOUBLE
107793: EQUAL
107794: IFTRUE 107798
107796: GO 107809
107798: POP
// bc_type := b_ext_track ; 23 :
107799: LD_ADDR_OWVAR 42
107803: PUSH
107804: LD_INT 16
107806: ST_TO_ADDR
107807: GO 108038
107809: LD_INT 23
107811: DOUBLE
107812: EQUAL
107813: IFTRUE 107817
107815: GO 107828
107817: POP
// bc_type := b_ext_laser ; 24 :
107818: LD_ADDR_OWVAR 42
107822: PUSH
107823: LD_INT 25
107825: ST_TO_ADDR
107826: GO 108038
107828: LD_INT 24
107830: DOUBLE
107831: EQUAL
107832: IFTRUE 107836
107834: GO 107847
107836: POP
// bc_type := b_control_tower ; 25 :
107837: LD_ADDR_OWVAR 42
107841: PUSH
107842: LD_INT 36
107844: ST_TO_ADDR
107845: GO 108038
107847: LD_INT 25
107849: DOUBLE
107850: EQUAL
107851: IFTRUE 107855
107853: GO 107866
107855: POP
// bc_type := b_breastwork ; 26 :
107856: LD_ADDR_OWVAR 42
107860: PUSH
107861: LD_INT 31
107863: ST_TO_ADDR
107864: GO 108038
107866: LD_INT 26
107868: DOUBLE
107869: EQUAL
107870: IFTRUE 107874
107872: GO 107885
107874: POP
// bc_type := b_bunker ; 27 :
107875: LD_ADDR_OWVAR 42
107879: PUSH
107880: LD_INT 32
107882: ST_TO_ADDR
107883: GO 108038
107885: LD_INT 27
107887: DOUBLE
107888: EQUAL
107889: IFTRUE 107893
107891: GO 107904
107893: POP
// bc_type := b_turret ; 28 :
107894: LD_ADDR_OWVAR 42
107898: PUSH
107899: LD_INT 33
107901: ST_TO_ADDR
107902: GO 108038
107904: LD_INT 28
107906: DOUBLE
107907: EQUAL
107908: IFTRUE 107912
107910: GO 107923
107912: POP
// bc_type := b_armoury ; 29 :
107913: LD_ADDR_OWVAR 42
107917: PUSH
107918: LD_INT 4
107920: ST_TO_ADDR
107921: GO 108038
107923: LD_INT 29
107925: DOUBLE
107926: EQUAL
107927: IFTRUE 107931
107929: GO 107942
107931: POP
// bc_type := b_barracks ; 30 :
107932: LD_ADDR_OWVAR 42
107936: PUSH
107937: LD_INT 5
107939: ST_TO_ADDR
107940: GO 108038
107942: LD_INT 30
107944: DOUBLE
107945: EQUAL
107946: IFTRUE 107950
107948: GO 107961
107950: POP
// bc_type := b_solar_power ; 31 :
107951: LD_ADDR_OWVAR 42
107955: PUSH
107956: LD_INT 27
107958: ST_TO_ADDR
107959: GO 108038
107961: LD_INT 31
107963: DOUBLE
107964: EQUAL
107965: IFTRUE 107969
107967: GO 107980
107969: POP
// bc_type := b_oil_power ; 32 :
107970: LD_ADDR_OWVAR 42
107974: PUSH
107975: LD_INT 26
107977: ST_TO_ADDR
107978: GO 108038
107980: LD_INT 32
107982: DOUBLE
107983: EQUAL
107984: IFTRUE 107988
107986: GO 107999
107988: POP
// bc_type := b_siberite_power ; 33 :
107989: LD_ADDR_OWVAR 42
107993: PUSH
107994: LD_INT 28
107996: ST_TO_ADDR
107997: GO 108038
107999: LD_INT 33
108001: DOUBLE
108002: EQUAL
108003: IFTRUE 108007
108005: GO 108018
108007: POP
// bc_type := b_oil_mine ; 34 :
108008: LD_ADDR_OWVAR 42
108012: PUSH
108013: LD_INT 29
108015: ST_TO_ADDR
108016: GO 108038
108018: LD_INT 34
108020: DOUBLE
108021: EQUAL
108022: IFTRUE 108026
108024: GO 108037
108026: POP
// bc_type := b_siberite_mine ; end ;
108027: LD_ADDR_OWVAR 42
108031: PUSH
108032: LD_INT 30
108034: ST_TO_ADDR
108035: GO 108038
108037: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108038: LD_ADDR_VAR 0 8
108042: PUSH
108043: LD_VAR 0 5
108047: PPUSH
108048: LD_VAR 0 6
108052: PPUSH
108053: LD_VAR 0 3
108057: PPUSH
108058: CALL_OW 47
108062: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108063: LD_OWVAR 42
108067: PUSH
108068: LD_INT 32
108070: PUSH
108071: LD_INT 33
108073: PUSH
108074: EMPTY
108075: LIST
108076: LIST
108077: IN
108078: IFFALSE 108094
// PlaceWeaponTurret ( b , weapon ) ;
108080: LD_VAR 0 8
108084: PPUSH
108085: LD_VAR 0 4
108089: PPUSH
108090: CALL_OW 431
// end ;
108094: LD_VAR 0 7
108098: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108099: LD_INT 0
108101: PPUSH
108102: PPUSH
108103: PPUSH
108104: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108105: LD_ADDR_VAR 0 4
108109: PUSH
108110: LD_INT 22
108112: PUSH
108113: LD_OWVAR 2
108117: PUSH
108118: EMPTY
108119: LIST
108120: LIST
108121: PUSH
108122: LD_INT 2
108124: PUSH
108125: LD_INT 30
108127: PUSH
108128: LD_INT 0
108130: PUSH
108131: EMPTY
108132: LIST
108133: LIST
108134: PUSH
108135: LD_INT 30
108137: PUSH
108138: LD_INT 1
108140: PUSH
108141: EMPTY
108142: LIST
108143: LIST
108144: PUSH
108145: EMPTY
108146: LIST
108147: LIST
108148: LIST
108149: PUSH
108150: EMPTY
108151: LIST
108152: LIST
108153: PPUSH
108154: CALL_OW 69
108158: ST_TO_ADDR
// if not tmp then
108159: LD_VAR 0 4
108163: NOT
108164: IFFALSE 108168
// exit ;
108166: GO 108227
// for i in tmp do
108168: LD_ADDR_VAR 0 2
108172: PUSH
108173: LD_VAR 0 4
108177: PUSH
108178: FOR_IN
108179: IFFALSE 108225
// for j = 1 to 3 do
108181: LD_ADDR_VAR 0 3
108185: PUSH
108186: DOUBLE
108187: LD_INT 1
108189: DEC
108190: ST_TO_ADDR
108191: LD_INT 3
108193: PUSH
108194: FOR_TO
108195: IFFALSE 108221
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108197: LD_VAR 0 2
108201: PPUSH
108202: CALL_OW 274
108206: PPUSH
108207: LD_VAR 0 3
108211: PPUSH
108212: LD_INT 99999
108214: PPUSH
108215: CALL_OW 277
108219: GO 108194
108221: POP
108222: POP
108223: GO 108178
108225: POP
108226: POP
// end ;
108227: LD_VAR 0 1
108231: RET
// export function hHackSetLevel10 ; var i , j ; begin
108232: LD_INT 0
108234: PPUSH
108235: PPUSH
108236: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108237: LD_ADDR_VAR 0 2
108241: PUSH
108242: LD_INT 21
108244: PUSH
108245: LD_INT 1
108247: PUSH
108248: EMPTY
108249: LIST
108250: LIST
108251: PPUSH
108252: CALL_OW 69
108256: PUSH
108257: FOR_IN
108258: IFFALSE 108310
// if IsSelected ( i ) then
108260: LD_VAR 0 2
108264: PPUSH
108265: CALL_OW 306
108269: IFFALSE 108308
// begin for j := 1 to 4 do
108271: LD_ADDR_VAR 0 3
108275: PUSH
108276: DOUBLE
108277: LD_INT 1
108279: DEC
108280: ST_TO_ADDR
108281: LD_INT 4
108283: PUSH
108284: FOR_TO
108285: IFFALSE 108306
// SetSkill ( i , j , 10 ) ;
108287: LD_VAR 0 2
108291: PPUSH
108292: LD_VAR 0 3
108296: PPUSH
108297: LD_INT 10
108299: PPUSH
108300: CALL_OW 237
108304: GO 108284
108306: POP
108307: POP
// end ;
108308: GO 108257
108310: POP
108311: POP
// end ;
108312: LD_VAR 0 1
108316: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108317: LD_INT 0
108319: PPUSH
108320: PPUSH
108321: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108322: LD_ADDR_VAR 0 2
108326: PUSH
108327: LD_INT 22
108329: PUSH
108330: LD_OWVAR 2
108334: PUSH
108335: EMPTY
108336: LIST
108337: LIST
108338: PUSH
108339: LD_INT 21
108341: PUSH
108342: LD_INT 1
108344: PUSH
108345: EMPTY
108346: LIST
108347: LIST
108348: PUSH
108349: EMPTY
108350: LIST
108351: LIST
108352: PPUSH
108353: CALL_OW 69
108357: PUSH
108358: FOR_IN
108359: IFFALSE 108400
// begin for j := 1 to 4 do
108361: LD_ADDR_VAR 0 3
108365: PUSH
108366: DOUBLE
108367: LD_INT 1
108369: DEC
108370: ST_TO_ADDR
108371: LD_INT 4
108373: PUSH
108374: FOR_TO
108375: IFFALSE 108396
// SetSkill ( i , j , 10 ) ;
108377: LD_VAR 0 2
108381: PPUSH
108382: LD_VAR 0 3
108386: PPUSH
108387: LD_INT 10
108389: PPUSH
108390: CALL_OW 237
108394: GO 108374
108396: POP
108397: POP
// end ;
108398: GO 108358
108400: POP
108401: POP
// end ;
108402: LD_VAR 0 1
108406: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108407: LD_INT 0
108409: PPUSH
// uc_side := your_side ;
108410: LD_ADDR_OWVAR 20
108414: PUSH
108415: LD_OWVAR 2
108419: ST_TO_ADDR
// uc_nation := nation ;
108420: LD_ADDR_OWVAR 21
108424: PUSH
108425: LD_VAR 0 1
108429: ST_TO_ADDR
// InitHc ;
108430: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108434: LD_INT 0
108436: PPUSH
108437: LD_VAR 0 2
108441: PPUSH
108442: LD_VAR 0 3
108446: PPUSH
108447: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108451: LD_VAR 0 4
108455: PPUSH
108456: LD_VAR 0 5
108460: PPUSH
108461: CALL_OW 428
108465: PUSH
108466: LD_INT 0
108468: EQUAL
108469: IFFALSE 108493
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108471: CALL_OW 44
108475: PPUSH
108476: LD_VAR 0 4
108480: PPUSH
108481: LD_VAR 0 5
108485: PPUSH
108486: LD_INT 1
108488: PPUSH
108489: CALL_OW 48
// end ;
108493: LD_VAR 0 6
108497: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108498: LD_INT 0
108500: PPUSH
108501: PPUSH
// uc_side := your_side ;
108502: LD_ADDR_OWVAR 20
108506: PUSH
108507: LD_OWVAR 2
108511: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108512: LD_VAR 0 1
108516: PUSH
108517: LD_INT 1
108519: PUSH
108520: LD_INT 2
108522: PUSH
108523: LD_INT 3
108525: PUSH
108526: LD_INT 4
108528: PUSH
108529: LD_INT 5
108531: PUSH
108532: EMPTY
108533: LIST
108534: LIST
108535: LIST
108536: LIST
108537: LIST
108538: IN
108539: IFFALSE 108551
// uc_nation := nation_american else
108541: LD_ADDR_OWVAR 21
108545: PUSH
108546: LD_INT 1
108548: ST_TO_ADDR
108549: GO 108594
// if chassis in [ 11 , 12 , 13 , 14 ] then
108551: LD_VAR 0 1
108555: PUSH
108556: LD_INT 11
108558: PUSH
108559: LD_INT 12
108561: PUSH
108562: LD_INT 13
108564: PUSH
108565: LD_INT 14
108567: PUSH
108568: EMPTY
108569: LIST
108570: LIST
108571: LIST
108572: LIST
108573: IN
108574: IFFALSE 108586
// uc_nation := nation_arabian else
108576: LD_ADDR_OWVAR 21
108580: PUSH
108581: LD_INT 2
108583: ST_TO_ADDR
108584: GO 108594
// uc_nation := nation_russian ;
108586: LD_ADDR_OWVAR 21
108590: PUSH
108591: LD_INT 3
108593: ST_TO_ADDR
// vc_chassis := chassis ;
108594: LD_ADDR_OWVAR 37
108598: PUSH
108599: LD_VAR 0 1
108603: ST_TO_ADDR
// vc_engine := engine ;
108604: LD_ADDR_OWVAR 39
108608: PUSH
108609: LD_VAR 0 2
108613: ST_TO_ADDR
// vc_control := control ;
108614: LD_ADDR_OWVAR 38
108618: PUSH
108619: LD_VAR 0 3
108623: ST_TO_ADDR
// vc_weapon := weapon ;
108624: LD_ADDR_OWVAR 40
108628: PUSH
108629: LD_VAR 0 4
108633: ST_TO_ADDR
// un := CreateVehicle ;
108634: LD_ADDR_VAR 0 8
108638: PUSH
108639: CALL_OW 45
108643: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108644: LD_VAR 0 8
108648: PPUSH
108649: LD_INT 0
108651: PPUSH
108652: LD_INT 5
108654: PPUSH
108655: CALL_OW 12
108659: PPUSH
108660: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108664: LD_VAR 0 8
108668: PPUSH
108669: LD_VAR 0 5
108673: PPUSH
108674: LD_VAR 0 6
108678: PPUSH
108679: LD_INT 1
108681: PPUSH
108682: CALL_OW 48
// end ;
108686: LD_VAR 0 7
108690: RET
// export hInvincible ; every 1 do
108691: GO 108693
108693: DISABLE
// hInvincible := [ ] ;
108694: LD_ADDR_EXP 134
108698: PUSH
108699: EMPTY
108700: ST_TO_ADDR
108701: END
// every 10 do var i ;
108702: GO 108704
108704: DISABLE
108705: LD_INT 0
108707: PPUSH
// begin enable ;
108708: ENABLE
// if not hInvincible then
108709: LD_EXP 134
108713: NOT
108714: IFFALSE 108718
// exit ;
108716: GO 108762
// for i in hInvincible do
108718: LD_ADDR_VAR 0 1
108722: PUSH
108723: LD_EXP 134
108727: PUSH
108728: FOR_IN
108729: IFFALSE 108760
// if GetLives ( i ) < 1000 then
108731: LD_VAR 0 1
108735: PPUSH
108736: CALL_OW 256
108740: PUSH
108741: LD_INT 1000
108743: LESS
108744: IFFALSE 108758
// SetLives ( i , 1000 ) ;
108746: LD_VAR 0 1
108750: PPUSH
108751: LD_INT 1000
108753: PPUSH
108754: CALL_OW 234
108758: GO 108728
108760: POP
108761: POP
// end ;
108762: PPOPN 1
108764: END
// export function hHackInvincible ; var i ; begin
108765: LD_INT 0
108767: PPUSH
108768: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108769: LD_ADDR_VAR 0 2
108773: PUSH
108774: LD_INT 2
108776: PUSH
108777: LD_INT 21
108779: PUSH
108780: LD_INT 1
108782: PUSH
108783: EMPTY
108784: LIST
108785: LIST
108786: PUSH
108787: LD_INT 21
108789: PUSH
108790: LD_INT 2
108792: PUSH
108793: EMPTY
108794: LIST
108795: LIST
108796: PUSH
108797: EMPTY
108798: LIST
108799: LIST
108800: LIST
108801: PPUSH
108802: CALL_OW 69
108806: PUSH
108807: FOR_IN
108808: IFFALSE 108869
// if IsSelected ( i ) then
108810: LD_VAR 0 2
108814: PPUSH
108815: CALL_OW 306
108819: IFFALSE 108867
// begin if i in hInvincible then
108821: LD_VAR 0 2
108825: PUSH
108826: LD_EXP 134
108830: IN
108831: IFFALSE 108851
// hInvincible := hInvincible diff i else
108833: LD_ADDR_EXP 134
108837: PUSH
108838: LD_EXP 134
108842: PUSH
108843: LD_VAR 0 2
108847: DIFF
108848: ST_TO_ADDR
108849: GO 108867
// hInvincible := hInvincible union i ;
108851: LD_ADDR_EXP 134
108855: PUSH
108856: LD_EXP 134
108860: PUSH
108861: LD_VAR 0 2
108865: UNION
108866: ST_TO_ADDR
// end ;
108867: GO 108807
108869: POP
108870: POP
// end ;
108871: LD_VAR 0 1
108875: RET
// export function hHackInvisible ; var i , j ; begin
108876: LD_INT 0
108878: PPUSH
108879: PPUSH
108880: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108881: LD_ADDR_VAR 0 2
108885: PUSH
108886: LD_INT 21
108888: PUSH
108889: LD_INT 1
108891: PUSH
108892: EMPTY
108893: LIST
108894: LIST
108895: PPUSH
108896: CALL_OW 69
108900: PUSH
108901: FOR_IN
108902: IFFALSE 108926
// if IsSelected ( i ) then
108904: LD_VAR 0 2
108908: PPUSH
108909: CALL_OW 306
108913: IFFALSE 108924
// ComForceInvisible ( i ) ;
108915: LD_VAR 0 2
108919: PPUSH
108920: CALL_OW 496
108924: GO 108901
108926: POP
108927: POP
// end ;
108928: LD_VAR 0 1
108932: RET
// export function hHackChangeYourSide ; begin
108933: LD_INT 0
108935: PPUSH
// if your_side = 8 then
108936: LD_OWVAR 2
108940: PUSH
108941: LD_INT 8
108943: EQUAL
108944: IFFALSE 108956
// your_side := 0 else
108946: LD_ADDR_OWVAR 2
108950: PUSH
108951: LD_INT 0
108953: ST_TO_ADDR
108954: GO 108970
// your_side := your_side + 1 ;
108956: LD_ADDR_OWVAR 2
108960: PUSH
108961: LD_OWVAR 2
108965: PUSH
108966: LD_INT 1
108968: PLUS
108969: ST_TO_ADDR
// end ;
108970: LD_VAR 0 1
108974: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108975: LD_INT 0
108977: PPUSH
108978: PPUSH
108979: PPUSH
// for i in all_units do
108980: LD_ADDR_VAR 0 2
108984: PUSH
108985: LD_OWVAR 3
108989: PUSH
108990: FOR_IN
108991: IFFALSE 109069
// if IsSelected ( i ) then
108993: LD_VAR 0 2
108997: PPUSH
108998: CALL_OW 306
109002: IFFALSE 109067
// begin j := GetSide ( i ) ;
109004: LD_ADDR_VAR 0 3
109008: PUSH
109009: LD_VAR 0 2
109013: PPUSH
109014: CALL_OW 255
109018: ST_TO_ADDR
// if j = 8 then
109019: LD_VAR 0 3
109023: PUSH
109024: LD_INT 8
109026: EQUAL
109027: IFFALSE 109039
// j := 0 else
109029: LD_ADDR_VAR 0 3
109033: PUSH
109034: LD_INT 0
109036: ST_TO_ADDR
109037: GO 109053
// j := j + 1 ;
109039: LD_ADDR_VAR 0 3
109043: PUSH
109044: LD_VAR 0 3
109048: PUSH
109049: LD_INT 1
109051: PLUS
109052: ST_TO_ADDR
// SetSide ( i , j ) ;
109053: LD_VAR 0 2
109057: PPUSH
109058: LD_VAR 0 3
109062: PPUSH
109063: CALL_OW 235
// end ;
109067: GO 108990
109069: POP
109070: POP
// end ;
109071: LD_VAR 0 1
109075: RET
// export function hHackFog ; begin
109076: LD_INT 0
109078: PPUSH
// FogOff ( true ) ;
109079: LD_INT 1
109081: PPUSH
109082: CALL_OW 344
// end ;
109086: LD_VAR 0 1
109090: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109091: LD_INT 0
109093: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109094: LD_VAR 0 1
109098: PPUSH
109099: LD_VAR 0 2
109103: PPUSH
109104: LD_VAR 0 3
109108: PPUSH
109109: LD_INT 1
109111: PPUSH
109112: LD_INT 1
109114: PPUSH
109115: CALL_OW 483
// CenterOnXY ( x , y ) ;
109119: LD_VAR 0 2
109123: PPUSH
109124: LD_VAR 0 3
109128: PPUSH
109129: CALL_OW 84
// end ;
109133: LD_VAR 0 4
109137: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109138: LD_INT 0
109140: PPUSH
109141: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109142: LD_VAR 0 1
109146: NOT
109147: PUSH
109148: LD_VAR 0 2
109152: PPUSH
109153: LD_VAR 0 3
109157: PPUSH
109158: CALL_OW 488
109162: NOT
109163: OR
109164: PUSH
109165: LD_VAR 0 1
109169: PPUSH
109170: CALL_OW 266
109174: PUSH
109175: LD_INT 3
109177: NONEQUAL
109178: PUSH
109179: LD_VAR 0 1
109183: PPUSH
109184: CALL_OW 247
109188: PUSH
109189: LD_INT 1
109191: EQUAL
109192: NOT
109193: AND
109194: OR
109195: IFFALSE 109199
// exit ;
109197: GO 109348
// if GetType ( factory ) = unit_human then
109199: LD_VAR 0 1
109203: PPUSH
109204: CALL_OW 247
109208: PUSH
109209: LD_INT 1
109211: EQUAL
109212: IFFALSE 109229
// factory := IsInUnit ( factory ) ;
109214: LD_ADDR_VAR 0 1
109218: PUSH
109219: LD_VAR 0 1
109223: PPUSH
109224: CALL_OW 310
109228: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109229: LD_VAR 0 1
109233: PPUSH
109234: CALL_OW 266
109238: PUSH
109239: LD_INT 3
109241: NONEQUAL
109242: IFFALSE 109246
// exit ;
109244: GO 109348
// if HexInfo ( x , y ) = factory then
109246: LD_VAR 0 2
109250: PPUSH
109251: LD_VAR 0 3
109255: PPUSH
109256: CALL_OW 428
109260: PUSH
109261: LD_VAR 0 1
109265: EQUAL
109266: IFFALSE 109293
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109268: LD_ADDR_EXP 135
109272: PUSH
109273: LD_EXP 135
109277: PPUSH
109278: LD_VAR 0 1
109282: PPUSH
109283: LD_INT 0
109285: PPUSH
109286: CALL_OW 1
109290: ST_TO_ADDR
109291: GO 109344
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109293: LD_ADDR_EXP 135
109297: PUSH
109298: LD_EXP 135
109302: PPUSH
109303: LD_VAR 0 1
109307: PPUSH
109308: LD_VAR 0 1
109312: PPUSH
109313: CALL_OW 255
109317: PUSH
109318: LD_VAR 0 1
109322: PUSH
109323: LD_VAR 0 2
109327: PUSH
109328: LD_VAR 0 3
109332: PUSH
109333: EMPTY
109334: LIST
109335: LIST
109336: LIST
109337: LIST
109338: PPUSH
109339: CALL_OW 1
109343: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109344: CALL 109353 0 0
// end ;
109348: LD_VAR 0 4
109352: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109353: LD_INT 0
109355: PPUSH
109356: PPUSH
109357: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109358: LD_STRING resetFactoryWaypoint();
109360: PPUSH
109361: CALL_OW 559
// if factoryWaypoints then
109365: LD_EXP 135
109369: IFFALSE 109495
// begin list := PrepareArray ( factoryWaypoints ) ;
109371: LD_ADDR_VAR 0 3
109375: PUSH
109376: LD_EXP 135
109380: PPUSH
109381: CALL 52222 0 1
109385: ST_TO_ADDR
// for i := 1 to list do
109386: LD_ADDR_VAR 0 2
109390: PUSH
109391: DOUBLE
109392: LD_INT 1
109394: DEC
109395: ST_TO_ADDR
109396: LD_VAR 0 3
109400: PUSH
109401: FOR_TO
109402: IFFALSE 109493
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109404: LD_STRING setFactoryWaypointXY(
109406: PUSH
109407: LD_VAR 0 3
109411: PUSH
109412: LD_VAR 0 2
109416: ARRAY
109417: PUSH
109418: LD_INT 1
109420: ARRAY
109421: STR
109422: PUSH
109423: LD_STRING ,
109425: STR
109426: PUSH
109427: LD_VAR 0 3
109431: PUSH
109432: LD_VAR 0 2
109436: ARRAY
109437: PUSH
109438: LD_INT 2
109440: ARRAY
109441: STR
109442: PUSH
109443: LD_STRING ,
109445: STR
109446: PUSH
109447: LD_VAR 0 3
109451: PUSH
109452: LD_VAR 0 2
109456: ARRAY
109457: PUSH
109458: LD_INT 3
109460: ARRAY
109461: STR
109462: PUSH
109463: LD_STRING ,
109465: STR
109466: PUSH
109467: LD_VAR 0 3
109471: PUSH
109472: LD_VAR 0 2
109476: ARRAY
109477: PUSH
109478: LD_INT 4
109480: ARRAY
109481: STR
109482: PUSH
109483: LD_STRING )
109485: STR
109486: PPUSH
109487: CALL_OW 559
109491: GO 109401
109493: POP
109494: POP
// end ; end ;
109495: LD_VAR 0 1
109499: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109500: LD_INT 0
109502: PPUSH
// if HexInfo ( x , y ) = warehouse then
109503: LD_VAR 0 2
109507: PPUSH
109508: LD_VAR 0 3
109512: PPUSH
109513: CALL_OW 428
109517: PUSH
109518: LD_VAR 0 1
109522: EQUAL
109523: IFFALSE 109550
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109525: LD_ADDR_EXP 136
109529: PUSH
109530: LD_EXP 136
109534: PPUSH
109535: LD_VAR 0 1
109539: PPUSH
109540: LD_INT 0
109542: PPUSH
109543: CALL_OW 1
109547: ST_TO_ADDR
109548: GO 109601
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109550: LD_ADDR_EXP 136
109554: PUSH
109555: LD_EXP 136
109559: PPUSH
109560: LD_VAR 0 1
109564: PPUSH
109565: LD_VAR 0 1
109569: PPUSH
109570: CALL_OW 255
109574: PUSH
109575: LD_VAR 0 1
109579: PUSH
109580: LD_VAR 0 2
109584: PUSH
109585: LD_VAR 0 3
109589: PUSH
109590: EMPTY
109591: LIST
109592: LIST
109593: LIST
109594: LIST
109595: PPUSH
109596: CALL_OW 1
109600: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109601: CALL 109610 0 0
// end ;
109605: LD_VAR 0 4
109609: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109610: LD_INT 0
109612: PPUSH
109613: PPUSH
109614: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109615: LD_STRING resetWarehouseGatheringPoints();
109617: PPUSH
109618: CALL_OW 559
// if warehouseGatheringPoints then
109622: LD_EXP 136
109626: IFFALSE 109752
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109628: LD_ADDR_VAR 0 3
109632: PUSH
109633: LD_EXP 136
109637: PPUSH
109638: CALL 52222 0 1
109642: ST_TO_ADDR
// for i := 1 to list do
109643: LD_ADDR_VAR 0 2
109647: PUSH
109648: DOUBLE
109649: LD_INT 1
109651: DEC
109652: ST_TO_ADDR
109653: LD_VAR 0 3
109657: PUSH
109658: FOR_TO
109659: IFFALSE 109750
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109661: LD_STRING setWarehouseGatheringPointXY(
109663: PUSH
109664: LD_VAR 0 3
109668: PUSH
109669: LD_VAR 0 2
109673: ARRAY
109674: PUSH
109675: LD_INT 1
109677: ARRAY
109678: STR
109679: PUSH
109680: LD_STRING ,
109682: STR
109683: PUSH
109684: LD_VAR 0 3
109688: PUSH
109689: LD_VAR 0 2
109693: ARRAY
109694: PUSH
109695: LD_INT 2
109697: ARRAY
109698: STR
109699: PUSH
109700: LD_STRING ,
109702: STR
109703: PUSH
109704: LD_VAR 0 3
109708: PUSH
109709: LD_VAR 0 2
109713: ARRAY
109714: PUSH
109715: LD_INT 3
109717: ARRAY
109718: STR
109719: PUSH
109720: LD_STRING ,
109722: STR
109723: PUSH
109724: LD_VAR 0 3
109728: PUSH
109729: LD_VAR 0 2
109733: ARRAY
109734: PUSH
109735: LD_INT 4
109737: ARRAY
109738: STR
109739: PUSH
109740: LD_STRING )
109742: STR
109743: PPUSH
109744: CALL_OW 559
109748: GO 109658
109750: POP
109751: POP
// end ; end ;
109752: LD_VAR 0 1
109756: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109757: LD_EXP 136
109761: IFFALSE 110446
109763: GO 109765
109765: DISABLE
109766: LD_INT 0
109768: PPUSH
109769: PPUSH
109770: PPUSH
109771: PPUSH
109772: PPUSH
109773: PPUSH
109774: PPUSH
109775: PPUSH
109776: PPUSH
// begin enable ;
109777: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109778: LD_ADDR_VAR 0 3
109782: PUSH
109783: LD_EXP 136
109787: PPUSH
109788: CALL 52222 0 1
109792: ST_TO_ADDR
// if not list then
109793: LD_VAR 0 3
109797: NOT
109798: IFFALSE 109802
// exit ;
109800: GO 110446
// for i := 1 to list do
109802: LD_ADDR_VAR 0 1
109806: PUSH
109807: DOUBLE
109808: LD_INT 1
109810: DEC
109811: ST_TO_ADDR
109812: LD_VAR 0 3
109816: PUSH
109817: FOR_TO
109818: IFFALSE 110444
// begin depot := list [ i ] [ 2 ] ;
109820: LD_ADDR_VAR 0 8
109824: PUSH
109825: LD_VAR 0 3
109829: PUSH
109830: LD_VAR 0 1
109834: ARRAY
109835: PUSH
109836: LD_INT 2
109838: ARRAY
109839: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109840: LD_ADDR_VAR 0 5
109844: PUSH
109845: LD_VAR 0 3
109849: PUSH
109850: LD_VAR 0 1
109854: ARRAY
109855: PUSH
109856: LD_INT 1
109858: ARRAY
109859: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109860: LD_VAR 0 8
109864: PPUSH
109865: CALL_OW 301
109869: PUSH
109870: LD_VAR 0 5
109874: PUSH
109875: LD_VAR 0 8
109879: PPUSH
109880: CALL_OW 255
109884: NONEQUAL
109885: OR
109886: IFFALSE 109915
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109888: LD_ADDR_EXP 136
109892: PUSH
109893: LD_EXP 136
109897: PPUSH
109898: LD_VAR 0 8
109902: PPUSH
109903: LD_INT 0
109905: PPUSH
109906: CALL_OW 1
109910: ST_TO_ADDR
// exit ;
109911: POP
109912: POP
109913: GO 110446
// end ; x := list [ i ] [ 3 ] ;
109915: LD_ADDR_VAR 0 6
109919: PUSH
109920: LD_VAR 0 3
109924: PUSH
109925: LD_VAR 0 1
109929: ARRAY
109930: PUSH
109931: LD_INT 3
109933: ARRAY
109934: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109935: LD_ADDR_VAR 0 7
109939: PUSH
109940: LD_VAR 0 3
109944: PUSH
109945: LD_VAR 0 1
109949: ARRAY
109950: PUSH
109951: LD_INT 4
109953: ARRAY
109954: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109955: LD_ADDR_VAR 0 9
109959: PUSH
109960: LD_VAR 0 6
109964: PPUSH
109965: LD_VAR 0 7
109969: PPUSH
109970: LD_INT 16
109972: PPUSH
109973: CALL 50810 0 3
109977: ST_TO_ADDR
// if not cratesNearbyPoint then
109978: LD_VAR 0 9
109982: NOT
109983: IFFALSE 109989
// exit ;
109985: POP
109986: POP
109987: GO 110446
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109989: LD_ADDR_VAR 0 4
109993: PUSH
109994: LD_INT 22
109996: PUSH
109997: LD_VAR 0 5
110001: PUSH
110002: EMPTY
110003: LIST
110004: LIST
110005: PUSH
110006: LD_INT 3
110008: PUSH
110009: LD_INT 60
110011: PUSH
110012: EMPTY
110013: LIST
110014: PUSH
110015: EMPTY
110016: LIST
110017: LIST
110018: PUSH
110019: LD_INT 91
110021: PUSH
110022: LD_VAR 0 8
110026: PUSH
110027: LD_INT 6
110029: PUSH
110030: EMPTY
110031: LIST
110032: LIST
110033: LIST
110034: PUSH
110035: LD_INT 2
110037: PUSH
110038: LD_INT 25
110040: PUSH
110041: LD_INT 2
110043: PUSH
110044: EMPTY
110045: LIST
110046: LIST
110047: PUSH
110048: LD_INT 25
110050: PUSH
110051: LD_INT 16
110053: PUSH
110054: EMPTY
110055: LIST
110056: LIST
110057: PUSH
110058: EMPTY
110059: LIST
110060: LIST
110061: LIST
110062: PUSH
110063: EMPTY
110064: LIST
110065: LIST
110066: LIST
110067: LIST
110068: PPUSH
110069: CALL_OW 69
110073: PUSH
110074: LD_VAR 0 8
110078: PPUSH
110079: CALL_OW 313
110083: PPUSH
110084: LD_INT 3
110086: PUSH
110087: LD_INT 60
110089: PUSH
110090: EMPTY
110091: LIST
110092: PUSH
110093: EMPTY
110094: LIST
110095: LIST
110096: PUSH
110097: LD_INT 2
110099: PUSH
110100: LD_INT 25
110102: PUSH
110103: LD_INT 2
110105: PUSH
110106: EMPTY
110107: LIST
110108: LIST
110109: PUSH
110110: LD_INT 25
110112: PUSH
110113: LD_INT 16
110115: PUSH
110116: EMPTY
110117: LIST
110118: LIST
110119: PUSH
110120: EMPTY
110121: LIST
110122: LIST
110123: LIST
110124: PUSH
110125: EMPTY
110126: LIST
110127: LIST
110128: PPUSH
110129: CALL_OW 72
110133: UNION
110134: ST_TO_ADDR
// if tmp then
110135: LD_VAR 0 4
110139: IFFALSE 110219
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110141: LD_ADDR_VAR 0 4
110145: PUSH
110146: LD_VAR 0 4
110150: PPUSH
110151: LD_INT 3
110153: PPUSH
110154: CALL 48779 0 2
110158: ST_TO_ADDR
// for j in tmp do
110159: LD_ADDR_VAR 0 2
110163: PUSH
110164: LD_VAR 0 4
110168: PUSH
110169: FOR_IN
110170: IFFALSE 110213
// begin if IsInUnit ( j ) then
110172: LD_VAR 0 2
110176: PPUSH
110177: CALL_OW 310
110181: IFFALSE 110192
// ComExit ( j ) ;
110183: LD_VAR 0 2
110187: PPUSH
110188: CALL 48862 0 1
// AddComCollect ( j , x , y ) ;
110192: LD_VAR 0 2
110196: PPUSH
110197: LD_VAR 0 6
110201: PPUSH
110202: LD_VAR 0 7
110206: PPUSH
110207: CALL_OW 177
// end ;
110211: GO 110169
110213: POP
110214: POP
// exit ;
110215: POP
110216: POP
110217: GO 110446
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110219: LD_ADDR_VAR 0 4
110223: PUSH
110224: LD_INT 22
110226: PUSH
110227: LD_VAR 0 5
110231: PUSH
110232: EMPTY
110233: LIST
110234: LIST
110235: PUSH
110236: LD_INT 91
110238: PUSH
110239: LD_VAR 0 8
110243: PUSH
110244: LD_INT 8
110246: PUSH
110247: EMPTY
110248: LIST
110249: LIST
110250: LIST
110251: PUSH
110252: LD_INT 2
110254: PUSH
110255: LD_INT 34
110257: PUSH
110258: LD_INT 12
110260: PUSH
110261: EMPTY
110262: LIST
110263: LIST
110264: PUSH
110265: LD_INT 34
110267: PUSH
110268: LD_INT 51
110270: PUSH
110271: EMPTY
110272: LIST
110273: LIST
110274: PUSH
110275: LD_INT 34
110277: PUSH
110278: LD_INT 32
110280: PUSH
110281: EMPTY
110282: LIST
110283: LIST
110284: PUSH
110285: LD_INT 34
110287: PUSH
110288: LD_INT 89
110290: PUSH
110291: EMPTY
110292: LIST
110293: LIST
110294: PUSH
110295: EMPTY
110296: LIST
110297: LIST
110298: LIST
110299: LIST
110300: LIST
110301: PUSH
110302: EMPTY
110303: LIST
110304: LIST
110305: LIST
110306: PPUSH
110307: CALL_OW 69
110311: ST_TO_ADDR
// if tmp then
110312: LD_VAR 0 4
110316: IFFALSE 110442
// begin for j in tmp do
110318: LD_ADDR_VAR 0 2
110322: PUSH
110323: LD_VAR 0 4
110327: PUSH
110328: FOR_IN
110329: IFFALSE 110440
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110331: LD_VAR 0 2
110335: PPUSH
110336: CALL_OW 262
110340: PUSH
110341: LD_INT 3
110343: EQUAL
110344: PUSH
110345: LD_VAR 0 2
110349: PPUSH
110350: CALL_OW 261
110354: PUSH
110355: LD_INT 20
110357: GREATER
110358: OR
110359: PUSH
110360: LD_VAR 0 2
110364: PPUSH
110365: CALL_OW 314
110369: NOT
110370: AND
110371: PUSH
110372: LD_VAR 0 2
110376: PPUSH
110377: CALL_OW 263
110381: PUSH
110382: LD_INT 1
110384: NONEQUAL
110385: PUSH
110386: LD_VAR 0 2
110390: PPUSH
110391: CALL_OW 311
110395: OR
110396: AND
110397: IFFALSE 110438
// begin ComCollect ( j , x , y ) ;
110399: LD_VAR 0 2
110403: PPUSH
110404: LD_VAR 0 6
110408: PPUSH
110409: LD_VAR 0 7
110413: PPUSH
110414: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110418: LD_VAR 0 2
110422: PPUSH
110423: LD_VAR 0 8
110427: PPUSH
110428: CALL_OW 172
// exit ;
110432: POP
110433: POP
110434: POP
110435: POP
110436: GO 110446
// end ;
110438: GO 110328
110440: POP
110441: POP
// end ; end ;
110442: GO 109817
110444: POP
110445: POP
// end ; end_of_file
110446: PPOPN 9
110448: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110449: LD_VAR 0 1
110453: PPUSH
110454: LD_VAR 0 2
110458: PPUSH
110459: LD_VAR 0 3
110463: PPUSH
110464: LD_VAR 0 4
110468: PPUSH
110469: LD_VAR 0 5
110473: PPUSH
110474: LD_VAR 0 6
110478: PPUSH
110479: CALL 94851 0 6
// end ;
110483: PPOPN 6
110485: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110486: LD_INT 0
110488: PPUSH
// begin if not units then
110489: LD_VAR 0 1
110493: NOT
110494: IFFALSE 110498
// exit ;
110496: GO 110498
// end ;
110498: PPOPN 7
110500: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110501: CALL 94822 0 0
// end ;
110505: PPOPN 1
110507: END
