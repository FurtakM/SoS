// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitGlobalVar ;
   8: CALL 1550 0 0
// InitAction ;
  12: CALL 4555 0 0
// InitGame ;
  16: CALL 88 0 0
// MC_SetStrategy ( 1 ) ;
  20: LD_INT 1
  22: PPUSH
  23: CALL 295 0 1
// MC_SetStrategy ( 4 ) ;
  27: LD_INT 4
  29: PPUSH
  30: CALL 295 0 1
// if isEditor then
  34: LD_INT 1
  36: IFFALSE 47
// FogOff ( your_side ) ;
  38: LD_OWVAR 2
  42: PPUSH
  43: CALL_OW 344
// mc_mapname := TwoFronts ;
  47: LD_ADDR_EXP 27
  51: PUSH
  52: LD_STRING TwoFronts
  54: ST_TO_ADDR
// mc_game_live := 1 ;
  55: LD_ADDR_EXP 25
  59: PUSH
  60: LD_INT 1
  62: ST_TO_ADDR
// Dialog ;
  63: CALL 4878 0 0
// if isEditor then
  67: LD_INT 1
  69: IFFALSE 87
// Say ( all_units [ 1 ] , DJ1 ) ;
  71: LD_OWVAR 3
  75: PUSH
  76: LD_INT 1
  78: ARRAY
  79: PPUSH
  80: LD_STRING DJ1
  82: PPUSH
  83: CALL_OW 88
// end ;
  87: END
// export houten , brown ; function InitGame ; begin
  88: LD_INT 0
  90: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  91: LD_INT 5
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 2
  99: PPUSH
 100: LD_INT 9
 102: PPUSH
 103: CALL 2985 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 107: LD_INT 4
 109: PPUSH
 110: LD_INT 1
 112: PPUSH
 113: LD_INT 2
 115: PPUSH
 116: LD_STRING jakes
 118: PPUSH
 119: LD_INT 4
 121: PUSH
 122: LD_INT 5
 124: PUSH
 125: LD_INT 6
 127: PUSH
 128: EMPTY
 129: LIST
 130: LIST
 131: LIST
 132: PUSH
 133: LD_OWVAR 67
 137: ARRAY
 138: PPUSH
 139: LD_INT 21
 141: PPUSH
 142: CALL 2639 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 146: LD_INT 3
 148: PPUSH
 149: LD_INT 3
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 2
 157: PPUSH
 158: CALL 2985 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 162: LD_INT 1
 164: PPUSH
 165: LD_INT 1
 167: PPUSH
 168: LD_INT 3
 170: PPUSH
 171: LD_STRING sylvia
 173: PPUSH
 174: LD_INT 4
 176: PUSH
 177: LD_INT 5
 179: PUSH
 180: LD_INT 6
 182: PUSH
 183: EMPTY
 184: LIST
 185: LIST
 186: LIST
 187: PUSH
 188: LD_OWVAR 67
 192: ARRAY
 193: PPUSH
 194: LD_INT 21
 196: PPUSH
 197: CALL 2639 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 201: LD_INT 3
 203: PPUSH
 204: LD_INT 3
 206: PPUSH
 207: LD_INT 0
 209: PPUSH
 210: LD_INT 3
 212: PPUSH
 213: CALL 2985 0 4
// MC_Registry ( ) ;
 217: CALL 39434 0 0
// MC_RegistryInit ( ) ;
 221: CALL 39885 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 225: LD_ADDR_EXP 26
 229: PUSH
 230: LD_INT 4
 232: PUSH
 233: LD_INT 5
 235: PUSH
 236: LD_INT 10
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: ST_TO_ADDR
// if Difficulty > 1 then
 244: LD_OWVAR 67
 248: PUSH
 249: LD_INT 1
 251: GREATER
 252: IFFALSE 267
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 254: LD_INT 58
 256: PPUSH
 257: LD_INT 8
 259: PPUSH
 260: LD_INT 2
 262: PPUSH
 263: CALL_OW 322
// if Difficulty > 2 then
 267: LD_OWVAR 67
 271: PUSH
 272: LD_INT 2
 274: GREATER
 275: IFFALSE 290
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 277: LD_INT 59
 279: PPUSH
 280: LD_INT 8
 282: PPUSH
 283: LD_INT 2
 285: PPUSH
 286: CALL_OW 322
// end ;
 290: LD_VAR 0 1
 294: RET
// function MC_SetStrategy ( side ) ; begin
 295: LD_INT 0
 297: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 298: LD_INT 3500
 300: PPUSH
 301: LD_INT 500
 303: PPUSH
 304: LD_INT 0
 306: PPUSH
 307: CALL 20751 0 3
// case side of 1 :
 311: LD_VAR 0 1
 315: PUSH
 316: LD_INT 1
 318: DOUBLE
 319: EQUAL
 320: IFTRUE 324
 322: GO 927
 324: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 325: LD_INT 1
 327: PPUSH
 328: LD_INT 1
 330: PPUSH
 331: LD_INT 4
 333: PUSH
 334: EMPTY
 335: LIST
 336: PPUSH
 337: CALL 20687 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 341: LD_INT 13
 343: PPUSH
 344: LD_INT 5
 346: PPUSH
 347: LD_INT 1
 349: PPUSH
 350: CALL 17680 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 6
 359: PPUSH
 360: CALL 20587 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 8
 369: PPUSH
 370: CALL 21601 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 374: LD_INT 1
 376: PPUSH
 377: LD_INT 22
 379: PUSH
 380: LD_INT 17
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 57
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 2
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: PPUSH
 403: CALL 20828 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 407: LD_INT 1
 409: PPUSH
 410: LD_INT 3
 412: PPUSH
 413: CALL 20621 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 417: LD_INT 1
 419: PPUSH
 420: LD_INT 0
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 0
 428: PUSH
 429: LD_INT 0
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PPUSH
 438: CALL 20654 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 442: LD_INT 1
 444: PPUSH
 445: LD_INT 48
 447: PUSH
 448: LD_INT 49
 450: PUSH
 451: LD_INT 46
 453: PUSH
 454: LD_INT 47
 456: PUSH
 457: LD_INT 35
 459: PUSH
 460: LD_INT 45
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 50
 468: PUSH
 469: LD_INT 2
 471: PUSH
 472: LD_INT 51
 474: PUSH
 475: LD_INT 52
 477: PUSH
 478: LD_INT 69
 480: PUSH
 481: LD_INT 39
 483: PUSH
 484: LD_INT 60
 486: PUSH
 487: LD_INT 61
 489: PUSH
 490: LD_INT 12
 492: PUSH
 493: LD_INT 6
 495: PUSH
 496: LD_INT 15
 498: PUSH
 499: LD_INT 53
 501: PUSH
 502: LD_INT 40
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: LIST
 526: PPUSH
 527: CALL 17459 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 531: LD_INT 1
 533: PPUSH
 534: LD_INT 4
 536: PPUSH
 537: LD_INT 0
 539: PPUSH
 540: LD_INT 0
 542: PPUSH
 543: CALL 21509 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 547: LD_INT 1
 549: PPUSH
 550: LD_INT 35
 552: PUSH
 553: LD_INT 9
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: PPUSH
 564: CALL 19766 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 568: LD_INT 1
 570: PPUSH
 571: LD_INT 54
 573: PUSH
 574: LD_INT 19
 576: PUSH
 577: LD_INT 4
 579: PUSH
 580: EMPTY
 581: LIST
 582: LIST
 583: LIST
 584: PPUSH
 585: CALL 20341 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 589: LD_INT 1
 591: PPUSH
 592: LD_INT 34
 594: PUSH
 595: LD_INT 20
 597: PUSH
 598: LD_INT 0
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: PPUSH
 606: CALL 20341 0 2
// MCS_Mine ( 1 ) ;
 610: LD_INT 1
 612: PPUSH
 613: CALL 20138 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 617: LD_INT 1
 619: PPUSH
 620: LD_INT 29
 622: PUSH
 623: LD_INT 5
 625: PUSH
 626: LD_INT 2
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: LD_INT 10
 636: PUSH
 637: LD_INT 15
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: PPUSH
 644: CALL 19802 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 648: LD_INT 1
 650: PPUSH
 651: LD_INT 15
 653: PUSH
 654: LD_INT 8
 656: PUSH
 657: LD_INT 2
 659: PUSH
 660: LD_INT 14
 662: PUSH
 663: LD_INT 5
 665: PUSH
 666: LD_INT 2
 668: PUSH
 669: LD_INT 39
 671: PUSH
 672: LD_INT 12
 674: PUSH
 675: LD_INT 0
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: LD_INT 27
 691: PUSH
 692: LD_INT 27
 694: PUSH
 695: LD_INT 26
 697: PUSH
 698: EMPTY
 699: LIST
 700: LIST
 701: LIST
 702: PPUSH
 703: CALL 19978 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 5 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 707: LD_INT 1
 709: PPUSH
 710: LD_INT 32
 712: PPUSH
 713: LD_INT 18
 715: PUSH
 716: LD_INT 13
 718: PUSH
 719: LD_INT 0
 721: PUSH
 722: LD_INT 38
 724: PUSH
 725: LD_INT 22
 727: PUSH
 728: LD_INT 5
 730: PUSH
 731: LD_INT 50
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 4
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: LIST
 749: LIST
 750: PPUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 5
 756: PUSH
 757: LD_INT 5
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: PPUSH
 765: CALL 19262 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radar , b_ext_track , b_ext_rocket ] ) ;
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 23
 774: PUSH
 775: LD_INT 8
 777: PUSH
 778: LD_INT 2
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: PPUSH
 786: LD_INT 17
 788: PUSH
 789: LD_INT 19
 791: PUSH
 792: LD_INT 20
 794: PUSH
 795: LD_INT 16
 797: PUSH
 798: LD_INT 18
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PPUSH
 808: CALL 19876 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 812: LD_INT 1
 814: PPUSH
 815: LD_INT 1
 817: PPUSH
 818: LD_INT 40
 820: PUSH
 821: LD_INT 4
 823: PUSH
 824: LD_INT 3
 826: PUSH
 827: EMPTY
 828: LIST
 829: LIST
 830: LIST
 831: PPUSH
 832: CALL 20377 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 836: LD_INT 1
 838: PPUSH
 839: LD_INT 14
 841: PPUSH
 842: LD_INT 15
 844: PPUSH
 845: LD_INT 59
 847: PUSH
 848: LD_INT 20
 850: PUSH
 851: LD_INT 52
 853: PUSH
 854: LD_INT 5
 856: PUSH
 857: LD_INT 30
 859: PUSH
 860: LD_INT 29
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: LD_INT 3
 873: PUSH
 874: LD_INT 1
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 4
 882: PUSH
 883: LD_INT 3
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: LD_INT 1
 891: PUSH
 892: LD_INT 5
 894: PUSH
 895: LD_INT 3
 897: PUSH
 898: LD_INT 1
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 5
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: PPUSH
 921: CALL 21117 0 5
// end ; 4 :
 925: GO 1545
 927: LD_INT 4
 929: DOUBLE
 930: EQUAL
 931: IFTRUE 935
 933: GO 1544
 935: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 936: LD_INT 4
 938: PPUSH
 939: LD_INT 1
 941: PPUSH
 942: LD_INT 5
 944: PUSH
 945: EMPTY
 946: LIST
 947: PPUSH
 948: CALL 20687 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 952: LD_INT 12
 954: PPUSH
 955: LD_INT 5
 957: PPUSH
 958: LD_INT 1
 960: PPUSH
 961: CALL 17680 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 965: LD_INT 4
 967: PPUSH
 968: LD_INT 7
 970: PPUSH
 971: CALL 20587 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 975: LD_INT 4
 977: PPUSH
 978: LD_INT 72
 980: PUSH
 981: LD_INT 136
 983: PUSH
 984: LD_INT 2
 986: PUSH
 987: LD_INT 111
 989: PUSH
 990: LD_INT 162
 992: PUSH
 993: LD_INT 2
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL 20828 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1008: LD_INT 4
1010: PPUSH
1011: LD_INT 3
1013: PPUSH
1014: CALL 20621 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1018: LD_INT 4
1020: PPUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 0
1029: PUSH
1030: LD_INT 0
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PPUSH
1039: CALL 20654 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1043: LD_INT 4
1045: PPUSH
1046: LD_INT 48
1048: PUSH
1049: LD_INT 49
1051: PUSH
1052: LD_INT 46
1054: PUSH
1055: LD_INT 47
1057: PUSH
1058: LD_INT 35
1060: PUSH
1061: LD_INT 45
1063: PUSH
1064: LD_INT 1
1066: PUSH
1067: LD_INT 50
1069: PUSH
1070: LD_INT 2
1072: PUSH
1073: LD_INT 51
1075: PUSH
1076: LD_INT 52
1078: PUSH
1079: LD_INT 69
1081: PUSH
1082: LD_INT 39
1084: PUSH
1085: LD_INT 60
1087: PUSH
1088: LD_INT 61
1090: PUSH
1091: LD_INT 12
1093: PUSH
1094: LD_INT 6
1096: PUSH
1097: LD_INT 15
1099: PUSH
1100: LD_INT 53
1102: PUSH
1103: LD_INT 34
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 17459 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 4
1137: PPUSH
1138: LD_INT 0
1140: PPUSH
1141: LD_INT 0
1143: PPUSH
1144: CALL 21509 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 86
1153: PUSH
1154: LD_INT 146
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: PPUSH
1165: CALL 19766 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1169: LD_INT 4
1171: PPUSH
1172: LD_INT 106
1174: PUSH
1175: LD_INT 149
1177: PUSH
1178: LD_INT 4
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: PPUSH
1186: CALL 20341 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1190: LD_INT 4
1192: PPUSH
1193: LD_INT 84
1195: PUSH
1196: LD_INT 134
1198: PUSH
1199: LD_INT 2
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: LIST
1206: PPUSH
1207: CALL 20341 0 2
// MCS_Mine ( 4 ) ;
1211: LD_INT 4
1213: PPUSH
1214: CALL 20138 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1218: LD_INT 4
1220: PPUSH
1221: LD_INT 97
1223: PUSH
1224: LD_INT 163
1226: PUSH
1227: LD_INT 0
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: PPUSH
1235: LD_INT 10
1237: PUSH
1238: LD_INT 15
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL 19802 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1249: LD_INT 4
1251: PPUSH
1252: LD_INT 95
1254: PUSH
1255: LD_INT 166
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: LD_INT 82
1263: PUSH
1264: LD_INT 156
1266: PUSH
1267: LD_INT 2
1269: PUSH
1270: LD_INT 76
1272: PUSH
1273: LD_INT 146
1275: PUSH
1276: LD_INT 2
1278: PUSH
1279: EMPTY
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PPUSH
1290: LD_INT 27
1292: PUSH
1293: LD_INT 26
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PPUSH
1300: CALL 19978 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1304: LD_INT 4
1306: PPUSH
1307: LD_INT 32
1309: PPUSH
1310: LD_INT 109
1312: PUSH
1313: LD_INT 155
1315: PUSH
1316: LD_INT 4
1318: PUSH
1319: LD_INT 103
1321: PUSH
1322: LD_INT 143
1324: PUSH
1325: LD_INT 4
1327: PUSH
1328: LD_INT 75
1330: PUSH
1331: LD_INT 133
1333: PUSH
1334: LD_INT 2
1336: PUSH
1337: LD_INT 88
1339: PUSH
1340: LD_INT 133
1342: PUSH
1343: LD_INT 2
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: PPUSH
1360: LD_INT 4
1362: PUSH
1363: LD_INT 6
1365: PUSH
1366: LD_INT 5
1368: PUSH
1369: LD_INT 6
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 19262 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radar , b_ext_track ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 87
1387: PUSH
1388: LD_INT 153
1390: PUSH
1391: LD_INT 1
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: LIST
1398: PPUSH
1399: LD_INT 17
1401: PUSH
1402: LD_INT 19
1404: PUSH
1405: LD_INT 20
1407: PUSH
1408: LD_INT 16
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: PPUSH
1417: CALL 19876 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1421: LD_INT 4
1423: PPUSH
1424: LD_INT 1
1426: PPUSH
1427: LD_INT 105
1429: PUSH
1430: LD_INT 160
1432: PUSH
1433: LD_INT 5
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: PPUSH
1441: CALL 20377 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1445: LD_INT 4
1447: PPUSH
1448: LD_INT 11
1450: PPUSH
1451: LD_INT 16
1453: PPUSH
1454: LD_INT 69
1456: PUSH
1457: LD_INT 126
1459: PUSH
1460: LD_INT 80
1462: PUSH
1463: LD_INT 126
1465: PUSH
1466: LD_INT 108
1468: PUSH
1469: LD_INT 142
1471: PUSH
1472: LD_INT 118
1474: PUSH
1475: LD_INT 161
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PPUSH
1488: LD_INT 3
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 4
1499: PUSH
1500: LD_INT 3
1502: PUSH
1503: LD_INT 1
1505: PUSH
1506: LD_INT 1
1508: PUSH
1509: LD_INT 5
1511: PUSH
1512: LD_INT 3
1514: PUSH
1515: LD_INT 1
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 5
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: LIST
1535: LIST
1536: LIST
1537: PPUSH
1538: CALL 21117 0 5
// end ; end ;
1542: GO 1545
1544: POP
// end ;
1545: LD_VAR 0 2
1549: RET
// export ar_crane , ru_big_cargo_bay ; export dialog_north , dialog_south , dialog_popov , dialog_trans ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1550: LD_INT 0
1552: PPUSH
// ar_crane := 88 ;
1553: LD_ADDR_EXP 3
1557: PUSH
1558: LD_INT 88
1560: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
1561: LD_ADDR_EXP 4
1565: PUSH
1566: LD_INT 89
1568: ST_TO_ADDR
// dialog_north := true ;
1569: LD_ADDR_EXP 5
1573: PUSH
1574: LD_INT 1
1576: ST_TO_ADDR
// dialog_south := true ;
1577: LD_ADDR_EXP 6
1581: PUSH
1582: LD_INT 1
1584: ST_TO_ADDR
// dialog_popov := true ;
1585: LD_ADDR_EXP 7
1589: PUSH
1590: LD_INT 1
1592: ST_TO_ADDR
// dialog_trans := true ;
1593: LD_ADDR_EXP 8
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// call := true ;
1601: LD_ADDR_EXP 10
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// pink_attack := false ;
1609: LD_ADDR_EXP 11
1613: PUSH
1614: LD_INT 0
1616: ST_TO_ADDR
// alfa_support := false ;
1617: LD_ADDR_EXP 12
1621: PUSH
1622: LD_INT 0
1624: ST_TO_ADDR
// alfa_north_triggered := false ;
1625: LD_ADDR_EXP 13
1629: PUSH
1630: LD_INT 0
1632: ST_TO_ADDR
// alfa_south_triggered := false ;
1633: LD_ADDR_EXP 14
1637: PUSH
1638: LD_INT 0
1640: ST_TO_ADDR
// end ;
1641: LD_VAR 0 1
1645: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1646: LD_INT 8
1648: PPUSH
1649: CALL_OW 353
1653: PUSH
1654: LD_INT 0
1656: EQUAL
1657: IFFALSE 1692
1659: GO 1661
1661: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 32
1667: PPUSH
1668: LD_INT 50
1670: PUSH
1671: LD_INT 10
1673: PUSH
1674: LD_INT 4
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: PPUSH
1682: LD_INT 7
1684: PUSH
1685: EMPTY
1686: LIST
1687: PPUSH
1688: CALL 19262 0 4
// end ;
1692: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1693: LD_INT 1
1695: PPUSH
1696: LD_INT 30
1698: PUSH
1699: LD_INT 3
1701: PUSH
1702: EMPTY
1703: LIST
1704: LIST
1705: PPUSH
1706: CALL 10967 0 2
1710: IFFALSE 1804
1712: GO 1714
1714: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1715: LD_INT 1
1717: PPUSH
1718: LD_INT 3
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: LD_INT 2
1726: PUSH
1727: LD_INT 4
1729: PUSH
1730: LD_INT 3
1732: PUSH
1733: LD_INT 1
1735: PUSH
1736: LD_INT 2
1738: PUSH
1739: LD_INT 5
1741: PUSH
1742: LD_INT 3
1744: PUSH
1745: LD_INT 1
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 5
1753: PUSH
1754: LD_INT 3
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: LD_INT 2
1762: PUSH
1763: LD_INT 7
1765: PUSH
1766: LD_INT 3
1768: PUSH
1769: LD_INT 1
1771: PUSH
1772: LD_INT 2
1774: PUSH
1775: LD_INT 7
1777: PUSH
1778: EMPTY
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: PPUSH
1800: CALL 21335 0 2
// end ;
1804: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1805: LD_INT 4
1807: PPUSH
1808: LD_INT 30
1810: PUSH
1811: LD_INT 3
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: PPUSH
1818: CALL 10967 0 2
1822: IFFALSE 1916
1824: GO 1826
1826: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1827: LD_INT 4
1829: PPUSH
1830: LD_INT 3
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 2
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 3
1844: PUSH
1845: LD_INT 1
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 5
1853: PUSH
1854: LD_INT 3
1856: PUSH
1857: LD_INT 1
1859: PUSH
1860: LD_INT 2
1862: PUSH
1863: LD_INT 5
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 2
1874: PUSH
1875: LD_INT 6
1877: PUSH
1878: LD_INT 4
1880: PUSH
1881: LD_INT 1
1883: PUSH
1884: LD_INT 2
1886: PUSH
1887: LD_INT 6
1889: PUSH
1890: EMPTY
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: PPUSH
1912: CALL 21335 0 2
// end ;
1916: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1917: LD_INT 1
1919: PPUSH
1920: LD_INT 30
1922: PUSH
1923: LD_INT 3
1925: PUSH
1926: EMPTY
1927: LIST
1928: LIST
1929: PPUSH
1930: CALL 10967 0 2
1934: PUSH
1935: LD_EXP 64
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 1
1946: ARRAY
1947: PUSH
1948: LD_INT 0
1950: EQUAL
1951: AND
1952: IFFALSE 2063
1954: GO 1956
1956: DISABLE
// begin enable ;
1957: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1958: LD_INT 1
1960: PPUSH
1961: LD_INT 3
1963: PUSH
1964: LD_INT 1
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 4
1972: PUSH
1973: LD_INT 3
1975: PUSH
1976: LD_INT 1
1978: PUSH
1979: LD_INT 2
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: LD_INT 3
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 2
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: LD_INT 3
1999: PUSH
2000: LD_INT 1
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 7
2008: PUSH
2009: LD_INT 3
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 2
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: LD_INT 4
2023: PUSH
2024: LD_INT 1
2026: PUSH
2027: LD_INT 2
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: LIST
2056: LIST
2057: LIST
2058: PPUSH
2059: CALL 21335 0 2
// end ;
2063: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2064: LD_INT 4
2066: PPUSH
2067: LD_INT 30
2069: PUSH
2070: LD_INT 3
2072: PUSH
2073: EMPTY
2074: LIST
2075: LIST
2076: PPUSH
2077: CALL 10967 0 2
2081: PUSH
2082: LD_EXP 64
2086: PUSH
2087: LD_INT 4
2089: ARRAY
2090: PUSH
2091: LD_INT 1
2093: ARRAY
2094: PUSH
2095: LD_INT 0
2097: EQUAL
2098: AND
2099: IFFALSE 2210
2101: GO 2103
2103: DISABLE
// begin enable ;
2104: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2105: LD_INT 4
2107: PPUSH
2108: LD_INT 3
2110: PUSH
2111: LD_INT 1
2113: PUSH
2114: LD_INT 2
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 1
2125: PUSH
2126: LD_INT 2
2128: PUSH
2129: LD_INT 5
2131: PUSH
2132: LD_INT 3
2134: PUSH
2135: LD_INT 1
2137: PUSH
2138: LD_INT 2
2140: PUSH
2141: LD_INT 5
2143: PUSH
2144: LD_INT 4
2146: PUSH
2147: LD_INT 1
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: LD_INT 6
2155: PUSH
2156: LD_INT 4
2158: PUSH
2159: LD_INT 1
2161: PUSH
2162: LD_INT 2
2164: PUSH
2165: LD_INT 6
2167: PUSH
2168: LD_INT 3
2170: PUSH
2171: LD_INT 1
2173: PUSH
2174: LD_INT 2
2176: PUSH
2177: LD_INT 5
2179: PUSH
2180: EMPTY
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: PPUSH
2206: CALL 21335 0 2
// end ;
2210: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2211: LD_EXP 11
2215: PUSH
2216: LD_INT 22
2218: PUSH
2219: LD_INT 6
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PUSH
2226: LD_INT 21
2228: PUSH
2229: LD_INT 2
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: PUSH
2236: LD_INT 3
2238: PUSH
2239: LD_INT 34
2241: PUSH
2242: LD_INT 51
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: LIST
2257: PPUSH
2258: CALL_OW 69
2262: AND
2263: IFFALSE 2392
2265: GO 2267
2267: DISABLE
2268: LD_INT 0
2270: PPUSH
// begin enable ;
2271: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2272: LD_ADDR_VAR 0 1
2276: PUSH
2277: LD_INT 22
2279: PUSH
2280: LD_INT 6
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 21
2289: PUSH
2290: LD_INT 2
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 3
2299: PUSH
2300: LD_INT 34
2302: PUSH
2303: LD_INT 51
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: PPUSH
2319: CALL_OW 69
2323: PUSH
2324: FOR_IN
2325: IFFALSE 2390
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2327: LD_VAR 0 1
2331: PPUSH
2332: CALL_OW 314
2336: NOT
2337: PUSH
2338: LD_VAR 0 1
2342: PPUSH
2343: CALL_OW 256
2347: PUSH
2348: LD_INT 250
2350: GREATER
2351: AND
2352: IFFALSE 2388
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2354: LD_VAR 0 1
2358: PPUSH
2359: LD_INT 81
2361: PUSH
2362: LD_INT 6
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: PPUSH
2369: CALL_OW 69
2373: PPUSH
2374: LD_VAR 0 1
2378: PPUSH
2379: CALL_OW 74
2383: PPUSH
2384: CALL_OW 115
2388: GO 2324
2390: POP
2391: POP
// end ;
2392: PPOPN 1
2394: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2395: LD_EXP 11
2399: PUSH
2400: LD_INT 22
2402: PUSH
2403: LD_INT 6
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: PUSH
2410: LD_INT 21
2412: PUSH
2413: LD_INT 2
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 34
2425: PUSH
2426: LD_INT 51
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: PUSH
2447: LD_INT 0
2449: EQUAL
2450: AND
2451: IFFALSE 2465
2453: GO 2455
2455: DISABLE
// begin enable ;
2456: ENABLE
// pink_attack := false ;
2457: LD_ADDR_EXP 11
2461: PUSH
2462: LD_INT 0
2464: ST_TO_ADDR
// end ;
2465: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2466: LD_EXP 12
2470: PUSH
2471: LD_INT 22
2473: PUSH
2474: LD_INT 8
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PPUSH
2481: CALL_OW 69
2485: AND
2486: IFFALSE 2597
2488: GO 2490
2490: DISABLE
2491: LD_INT 0
2493: PPUSH
// begin enable ;
2494: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2495: LD_ADDR_VAR 0 1
2499: PUSH
2500: LD_INT 22
2502: PUSH
2503: LD_INT 8
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 21
2512: PUSH
2513: LD_INT 2
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: PPUSH
2524: CALL_OW 69
2528: PUSH
2529: FOR_IN
2530: IFFALSE 2595
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2532: LD_VAR 0 1
2536: PPUSH
2537: CALL_OW 314
2541: NOT
2542: PUSH
2543: LD_VAR 0 1
2547: PPUSH
2548: CALL_OW 256
2552: PUSH
2553: LD_INT 250
2555: GREATER
2556: AND
2557: IFFALSE 2593
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2559: LD_VAR 0 1
2563: PPUSH
2564: LD_INT 81
2566: PUSH
2567: LD_INT 8
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: CALL_OW 69
2578: PPUSH
2579: LD_VAR 0 1
2583: PPUSH
2584: CALL_OW 74
2588: PPUSH
2589: CALL_OW 115
2593: GO 2529
2595: POP
2596: POP
// end ;
2597: PPOPN 1
2599: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2600: LD_EXP 12
2604: PUSH
2605: LD_INT 22
2607: PUSH
2608: LD_INT 8
2610: PUSH
2611: EMPTY
2612: LIST
2613: LIST
2614: PPUSH
2615: CALL_OW 69
2619: PUSH
2620: LD_INT 0
2622: EQUAL
2623: AND
2624: IFFALSE 2638
2626: GO 2628
2628: DISABLE
// begin enable ;
2629: ENABLE
// alfa_support := false ;
2630: LD_ADDR_EXP 12
2634: PUSH
2635: LD_INT 0
2637: ST_TO_ADDR
// end ; end_of_file
2638: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2639: LD_INT 0
2641: PPUSH
2642: PPUSH
2643: PPUSH
2644: PPUSH
// uc_side := side ;
2645: LD_ADDR_OWVAR 20
2649: PUSH
2650: LD_VAR 0 1
2654: ST_TO_ADDR
// uc_nation := nat ;
2655: LD_ADDR_OWVAR 21
2659: PUSH
2660: LD_VAR 0 2
2664: ST_TO_ADDR
// team := [ ] ;
2665: LD_ADDR_VAR 0 10
2669: PUSH
2670: EMPTY
2671: ST_TO_ADDR
// hc_importance := 100 ;
2672: LD_ADDR_OWVAR 32
2676: PUSH
2677: LD_INT 100
2679: ST_TO_ADDR
// case commander of jakes :
2680: LD_VAR 0 4
2684: PUSH
2685: LD_STRING jakes
2687: DOUBLE
2688: EQUAL
2689: IFTRUE 2693
2691: GO 2761
2693: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2694: LD_INT 1
2696: PPUSH
2697: LD_INT 1
2699: PPUSH
2700: LD_VAR 0 5
2704: PPUSH
2705: CALL_OW 380
// hc_gallery := pkremaster ;
2709: LD_ADDR_OWVAR 33
2713: PUSH
2714: LD_STRING pkremaster
2716: ST_TO_ADDR
// hc_face_number := 12 ;
2717: LD_ADDR_OWVAR 34
2721: PUSH
2722: LD_INT 12
2724: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2725: LD_ADDR_OWVAR 26
2729: PUSH
2730: LD_STRING Jan van Jakes
2732: ST_TO_ADDR
// houten := CreateHuman ;
2733: LD_ADDR_EXP 1
2737: PUSH
2738: CALL_OW 44
2742: ST_TO_ADDR
// team := team ^ houten ;
2743: LD_ADDR_VAR 0 10
2747: PUSH
2748: LD_VAR 0 10
2752: PUSH
2753: LD_EXP 1
2757: ADD
2758: ST_TO_ADDR
// end ; sylvia :
2759: GO 2838
2761: LD_STRING sylvia
2763: DOUBLE
2764: EQUAL
2765: IFTRUE 2769
2767: GO 2837
2769: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2770: LD_INT 2
2772: PPUSH
2773: LD_INT 1
2775: PPUSH
2776: LD_VAR 0 5
2780: PPUSH
2781: CALL_OW 380
// hc_gallery := pkremaster ;
2785: LD_ADDR_OWVAR 33
2789: PUSH
2790: LD_STRING pkremaster
2792: ST_TO_ADDR
// hc_face_number := 13 ;
2793: LD_ADDR_OWVAR 34
2797: PUSH
2798: LD_INT 13
2800: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2801: LD_ADDR_OWVAR 26
2805: PUSH
2806: LD_STRING Sylvia Johnson
2808: ST_TO_ADDR
// brown := CreateHuman ;
2809: LD_ADDR_EXP 2
2813: PUSH
2814: CALL_OW 44
2818: ST_TO_ADDR
// team := team ^ brown ;
2819: LD_ADDR_VAR 0 10
2823: PUSH
2824: LD_VAR 0 10
2828: PUSH
2829: LD_EXP 2
2833: ADD
2834: ST_TO_ADDR
// end ; end ;
2835: GO 2838
2837: POP
// hc_gallery :=  ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING 
2845: ST_TO_ADDR
// hc_name :=  ;
2846: LD_ADDR_OWVAR 26
2850: PUSH
2851: LD_STRING 
2853: ST_TO_ADDR
// hc_importance := 0 ;
2854: LD_ADDR_OWVAR 32
2858: PUSH
2859: LD_INT 0
2861: ST_TO_ADDR
// for i = 1 to num do
2862: LD_ADDR_VAR 0 8
2866: PUSH
2867: DOUBLE
2868: LD_INT 1
2870: DEC
2871: ST_TO_ADDR
2872: LD_VAR 0 6
2876: PUSH
2877: FOR_TO
2878: IFFALSE 2933
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_VAR 0 8
2887: PUSH
2888: LD_INT 4
2890: MOD
2891: PUSH
2892: LD_INT 1
2894: PLUS
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateHuman ;
2905: LD_ADDR_VAR 0 9
2909: PUSH
2910: CALL_OW 44
2914: ST_TO_ADDR
// team := team ^ un ;
2915: LD_ADDR_VAR 0 10
2919: PUSH
2920: LD_VAR 0 10
2924: PUSH
2925: LD_VAR 0 9
2929: ADD
2930: ST_TO_ADDR
// end ;
2931: GO 2877
2933: POP
2934: POP
// for i = 1 to team do
2935: LD_ADDR_VAR 0 8
2939: PUSH
2940: DOUBLE
2941: LD_INT 1
2943: DEC
2944: ST_TO_ADDR
2945: LD_VAR 0 10
2949: PUSH
2950: FOR_TO
2951: IFFALSE 2978
// PlaceUnitArea ( team [ i ] , area , false ) ;
2953: LD_VAR 0 10
2957: PUSH
2958: LD_VAR 0 8
2962: ARRAY
2963: PPUSH
2964: LD_VAR 0 3
2968: PPUSH
2969: LD_INT 0
2971: PPUSH
2972: CALL_OW 49
2976: GO 2950
2978: POP
2979: POP
// end ;
2980: LD_VAR 0 7
2984: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2985: LD_INT 0
2987: PPUSH
2988: PPUSH
// for i = 1 to n1 do
2989: LD_ADDR_VAR 0 6
2993: PUSH
2994: DOUBLE
2995: LD_INT 1
2997: DEC
2998: ST_TO_ADDR
2999: LD_VAR 0 1
3003: PUSH
3004: FOR_TO
3005: IFFALSE 3027
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3007: LD_INT 1
3009: PPUSH
3010: LD_INT 1
3012: PPUSH
3013: LD_VAR 0 4
3017: PPUSH
3018: LD_INT 0
3020: PPUSH
3021: CALL_OW 59
3025: GO 3004
3027: POP
3028: POP
// for i = 1 to n2 do
3029: LD_ADDR_VAR 0 6
3033: PUSH
3034: DOUBLE
3035: LD_INT 1
3037: DEC
3038: ST_TO_ADDR
3039: LD_VAR 0 2
3043: PUSH
3044: FOR_TO
3045: IFFALSE 3067
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3047: LD_INT 2
3049: PPUSH
3050: LD_INT 1
3052: PPUSH
3053: LD_VAR 0 4
3057: PPUSH
3058: LD_INT 0
3060: PPUSH
3061: CALL_OW 59
3065: GO 3044
3067: POP
3068: POP
// for i = 1 to n3 do
3069: LD_ADDR_VAR 0 6
3073: PUSH
3074: DOUBLE
3075: LD_INT 1
3077: DEC
3078: ST_TO_ADDR
3079: LD_VAR 0 3
3083: PUSH
3084: FOR_TO
3085: IFFALSE 3107
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3087: LD_INT 3
3089: PPUSH
3090: LD_INT 1
3092: PPUSH
3093: LD_VAR 0 4
3097: PPUSH
3098: LD_INT 0
3100: PPUSH
3101: CALL_OW 59
3105: GO 3084
3107: POP
3108: POP
// end ; end_of_file
3109: LD_VAR 0 5
3113: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ; var i , skill , tmp , team , veh ; begin
3114: LD_INT 0
3116: PPUSH
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
// uc_side := your_side ;
3122: LD_ADDR_OWVAR 20
3126: PUSH
3127: LD_OWVAR 2
3131: ST_TO_ADDR
// uc_nation := nation_russian ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 3
3139: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3140: LD_ADDR_EXP 17
3144: PUSH
3145: LD_STRING Gladkov
3147: PPUSH
3148: CALL_OW 25
3152: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3153: LD_ADDR_EXP 18
3157: PUSH
3158: LD_STRING Davidov
3160: PPUSH
3161: CALL_OW 25
3165: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3166: LD_ADDR_EXP 19
3170: PUSH
3171: LD_STRING Burlak
3173: PPUSH
3174: CALL_OW 25
3178: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3179: LD_ADDR_EXP 20
3183: PUSH
3184: LD_STRING Stolypin
3186: PPUSH
3187: CALL_OW 25
3191: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3192: LD_ADDR_EXP 15
3196: PUSH
3197: LD_EXP 17
3201: PUSH
3202: LD_EXP 18
3206: PUSH
3207: LD_EXP 19
3211: PUSH
3212: LD_EXP 20
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: ST_TO_ADDR
// player := CharacterSelection ( text , 1 , 1 , [ sel_not_hired , sel_changeable ] ^ commanders , [ ] ) ;
3223: LD_ADDR_EXP 16
3227: PUSH
3228: LD_STRING text
3230: PPUSH
3231: LD_INT 1
3233: PPUSH
3234: LD_INT 1
3236: PPUSH
3237: LD_INT -2
3239: PUSH
3240: LD_INT -3
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: LD_EXP 15
3251: ADD
3252: PPUSH
3253: EMPTY
3254: PPUSH
3255: CALL_OW 42
3259: ST_TO_ADDR
// player_com := player [ 1 ] ;
3260: LD_ADDR_EXP 23
3264: PUSH
3265: LD_EXP 16
3269: PUSH
3270: LD_INT 1
3272: ARRAY
3273: ST_TO_ADDR
// team := [ ] ;
3274: LD_ADDR_VAR 0 5
3278: PUSH
3279: EMPTY
3280: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3281: LD_ADDR_VAR 0 3
3285: PUSH
3286: LD_INT 4
3288: PUSH
3289: LD_INT 3
3291: PUSH
3292: LD_INT 3
3294: PUSH
3295: EMPTY
3296: LIST
3297: LIST
3298: LIST
3299: PUSH
3300: LD_OWVAR 67
3304: ARRAY
3305: ST_TO_ADDR
// hc_gallery :=  ;
3306: LD_ADDR_OWVAR 33
3310: PUSH
3311: LD_STRING 
3313: ST_TO_ADDR
// hc_name :=  ;
3314: LD_ADDR_OWVAR 26
3318: PUSH
3319: LD_STRING 
3321: ST_TO_ADDR
// hc_importance := 0 ;
3322: LD_ADDR_OWVAR 32
3326: PUSH
3327: LD_INT 0
3329: ST_TO_ADDR
// case player [ 1 ] of gladkov :
3330: LD_EXP 16
3334: PUSH
3335: LD_INT 1
3337: ARRAY
3338: PUSH
3339: LD_EXP 17
3343: DOUBLE
3344: EQUAL
3345: IFTRUE 3349
3347: GO 3494
3349: POP
// begin for i = 1 to 10 do
3350: LD_ADDR_VAR 0 2
3354: PUSH
3355: DOUBLE
3356: LD_INT 1
3358: DEC
3359: ST_TO_ADDR
3360: LD_INT 10
3362: PUSH
3363: FOR_TO
3364: IFFALSE 3403
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3366: LD_INT 0
3368: PPUSH
3369: LD_INT 1
3371: PPUSH
3372: LD_VAR 0 3
3376: PUSH
3377: LD_INT 1
3379: PLUS
3380: PPUSH
3381: CALL_OW 380
// team := team ^ CreateHuman ;
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: LD_VAR 0 5
3394: PUSH
3395: CALL_OW 44
3399: ADD
3400: ST_TO_ADDR
// end ;
3401: GO 3363
3403: POP
3404: POP
// for i = 1 to 15 do
3405: LD_ADDR_VAR 0 2
3409: PUSH
3410: DOUBLE
3411: LD_INT 1
3413: DEC
3414: ST_TO_ADDR
3415: LD_INT 15
3417: PUSH
3418: FOR_TO
3419: IFFALSE 3464
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_VAR 0 2
3428: PUSH
3429: LD_INT 3
3431: MOD
3432: PUSH
3433: LD_INT 2
3435: PLUS
3436: PPUSH
3437: LD_VAR 0 3
3441: PPUSH
3442: CALL_OW 380
// team := team ^ CreateHuman ;
3446: LD_ADDR_VAR 0 5
3450: PUSH
3451: LD_VAR 0 5
3455: PUSH
3456: CALL_OW 44
3460: ADD
3461: ST_TO_ADDR
// end ;
3462: GO 3418
3464: POP
3465: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3466: LD_INT 44
3468: PPUSH
3469: LD_INT 3
3471: PPUSH
3472: LD_INT 1
3474: PPUSH
3475: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3479: LD_INT 34
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: CALL_OW 322
// end ; davidov :
3492: GO 4347
3494: LD_EXP 18
3498: DOUBLE
3499: EQUAL
3500: IFTRUE 3504
3502: GO 3779
3504: POP
// begin for i = 1 to 10 do
3505: LD_ADDR_VAR 0 2
3509: PUSH
3510: DOUBLE
3511: LD_INT 1
3513: DEC
3514: ST_TO_ADDR
3515: LD_INT 10
3517: PUSH
3518: FOR_TO
3519: IFFALSE 3558
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3521: LD_INT 0
3523: PPUSH
3524: LD_INT 4
3526: PPUSH
3527: LD_VAR 0 3
3531: PUSH
3532: LD_INT 1
3534: PLUS
3535: PPUSH
3536: CALL_OW 380
// team := team ^ CreateHuman ;
3540: LD_ADDR_VAR 0 5
3544: PUSH
3545: LD_VAR 0 5
3549: PUSH
3550: CALL_OW 44
3554: ADD
3555: ST_TO_ADDR
// end ;
3556: GO 3518
3558: POP
3559: POP
// for i = 1 to 15 do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: DOUBLE
3566: LD_INT 1
3568: DEC
3569: ST_TO_ADDR
3570: LD_INT 15
3572: PUSH
3573: FOR_TO
3574: IFFALSE 3619
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3576: LD_INT 0
3578: PPUSH
3579: LD_VAR 0 2
3583: PUSH
3584: LD_INT 3
3586: MOD
3587: PUSH
3588: LD_INT 1
3590: PLUS
3591: PPUSH
3592: LD_VAR 0 3
3596: PPUSH
3597: CALL_OW 380
// team := team ^ CreateHuman ;
3601: LD_ADDR_VAR 0 5
3605: PUSH
3606: LD_VAR 0 5
3610: PUSH
3611: CALL_OW 44
3615: ADD
3616: ST_TO_ADDR
// end ;
3617: GO 3573
3619: POP
3620: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3621: LD_INT 34
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 1
3629: PPUSH
3630: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3634: LD_INT 32
3636: PPUSH
3637: LD_INT 3
3639: PPUSH
3640: LD_INT 1
3642: PPUSH
3643: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3647: LD_INT 27
3649: PPUSH
3650: LD_INT 3
3652: PPUSH
3653: LD_INT 1
3655: PPUSH
3656: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3660: LD_INT 30
3662: PPUSH
3663: LD_INT 3
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3673: LD_INT 63
3675: PPUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3686: LD_INT 57
3688: PPUSH
3689: LD_INT 3
3691: PPUSH
3692: LD_INT 1
3694: PPUSH
3695: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3699: LD_INT 58
3701: PPUSH
3702: LD_INT 3
3704: PPUSH
3705: LD_INT 1
3707: PPUSH
3708: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3712: LD_INT 8
3714: PPUSH
3715: LD_INT 3
3717: PPUSH
3718: LD_INT 1
3720: PPUSH
3721: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3725: LD_INT 12
3727: PPUSH
3728: LD_INT 3
3730: PPUSH
3731: LD_INT 1
3733: PPUSH
3734: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3738: LD_INT 14
3740: PPUSH
3741: LD_INT 3
3743: PPUSH
3744: LD_INT 1
3746: PPUSH
3747: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3751: LD_INT 24
3753: PPUSH
3754: LD_INT 3
3756: PPUSH
3757: LD_INT 1
3759: PPUSH
3760: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3764: LD_INT 33
3766: PPUSH
3767: LD_INT 3
3769: PPUSH
3770: LD_INT 1
3772: PPUSH
3773: CALL_OW 324
// end ; gorki :
3777: GO 4347
3779: LD_EXP 19
3783: DOUBLE
3784: EQUAL
3785: IFTRUE 3789
3787: GO 4040
3789: POP
// begin for i = 1 to 10 do
3790: LD_ADDR_VAR 0 2
3794: PUSH
3795: DOUBLE
3796: LD_INT 1
3798: DEC
3799: ST_TO_ADDR
3800: LD_INT 10
3802: PUSH
3803: FOR_TO
3804: IFFALSE 3843
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3806: LD_INT 0
3808: PPUSH
3809: LD_INT 3
3811: PPUSH
3812: LD_VAR 0 3
3816: PUSH
3817: LD_INT 1
3819: PLUS
3820: PPUSH
3821: CALL_OW 380
// team := team ^ CreateHuman ;
3825: LD_ADDR_VAR 0 5
3829: PUSH
3830: LD_VAR 0 5
3834: PUSH
3835: CALL_OW 44
3839: ADD
3840: ST_TO_ADDR
// end ;
3841: GO 3803
3843: POP
3844: POP
// for i = 1 to 15 do
3845: LD_ADDR_VAR 0 2
3849: PUSH
3850: DOUBLE
3851: LD_INT 1
3853: DEC
3854: ST_TO_ADDR
3855: LD_INT 15
3857: PUSH
3858: FOR_TO
3859: IFFALSE 3917
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3861: LD_INT 0
3863: PPUSH
3864: LD_INT 1
3866: PUSH
3867: LD_INT 2
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: LIST
3877: PUSH
3878: LD_INT 1
3880: PPUSH
3881: LD_INT 3
3883: PPUSH
3884: CALL_OW 12
3888: ARRAY
3889: PPUSH
3890: LD_VAR 0 3
3894: PPUSH
3895: CALL_OW 380
// team := team ^ CreateHuman ;
3899: LD_ADDR_VAR 0 5
3903: PUSH
3904: LD_VAR 0 5
3908: PUSH
3909: CALL_OW 44
3913: ADD
3914: ST_TO_ADDR
// end ;
3915: GO 3858
3917: POP
3918: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3919: LD_INT 40
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3932: LD_INT 34
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3945: LD_INT 18
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3958: LD_ADDR_OWVAR 37
3962: PUSH
3963: LD_INT 22
3965: ST_TO_ADDR
// vc_engine := engine_combustion ;
3966: LD_ADDR_OWVAR 39
3970: PUSH
3971: LD_INT 1
3973: ST_TO_ADDR
// vc_control := control_manual ;
3974: LD_ADDR_OWVAR 38
3978: PUSH
3979: LD_INT 1
3981: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3982: LD_ADDR_OWVAR 40
3986: PUSH
3987: LD_INT 45
3989: ST_TO_ADDR
// vc_fuel_battery := 3 ;
3990: LD_ADDR_OWVAR 41
3994: PUSH
3995: LD_INT 3
3997: ST_TO_ADDR
// veh := CreateVehicle ;
3998: LD_ADDR_VAR 0 6
4002: PUSH
4003: CALL_OW 45
4007: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4008: LD_VAR 0 6
4012: PPUSH
4013: LD_INT 1
4015: PPUSH
4016: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4020: LD_VAR 0 6
4024: PPUSH
4025: LD_INT 107
4027: PPUSH
4028: LD_INT 83
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 48
// end ; stolypin :
4038: GO 4347
4040: LD_EXP 20
4044: DOUBLE
4045: EQUAL
4046: IFTRUE 4050
4048: GO 4346
4050: POP
// begin for i = 1 to 10 do
4051: LD_ADDR_VAR 0 2
4055: PUSH
4056: DOUBLE
4057: LD_INT 1
4059: DEC
4060: ST_TO_ADDR
4061: LD_INT 10
4063: PUSH
4064: FOR_TO
4065: IFFALSE 4104
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4067: LD_INT 0
4069: PPUSH
4070: LD_INT 2
4072: PPUSH
4073: LD_VAR 0 3
4077: PUSH
4078: LD_INT 1
4080: PLUS
4081: PPUSH
4082: CALL_OW 380
// team := team ^ CreateHuman ;
4086: LD_ADDR_VAR 0 5
4090: PUSH
4091: LD_VAR 0 5
4095: PUSH
4096: CALL_OW 44
4100: ADD
4101: ST_TO_ADDR
// end ;
4102: GO 4064
4104: POP
4105: POP
// for i = 1 to 15 do
4106: LD_ADDR_VAR 0 2
4110: PUSH
4111: DOUBLE
4112: LD_INT 1
4114: DEC
4115: ST_TO_ADDR
4116: LD_INT 15
4118: PUSH
4119: FOR_TO
4120: IFFALSE 4178
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4122: LD_INT 0
4124: PPUSH
4125: LD_INT 1
4127: PUSH
4128: LD_INT 3
4130: PUSH
4131: LD_INT 4
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: LIST
4138: PUSH
4139: LD_INT 1
4141: PPUSH
4142: LD_INT 3
4144: PPUSH
4145: CALL_OW 12
4149: ARRAY
4150: PPUSH
4151: LD_VAR 0 3
4155: PPUSH
4156: CALL_OW 380
// team := team ^ CreateHuman ;
4160: LD_ADDR_VAR 0 5
4164: PUSH
4165: LD_VAR 0 5
4169: PUSH
4170: CALL_OW 44
4174: ADD
4175: ST_TO_ADDR
// end ;
4176: GO 4119
4178: POP
4179: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4180: LD_INT 34
4182: PPUSH
4183: LD_INT 3
4185: PPUSH
4186: LD_INT 1
4188: PPUSH
4189: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4193: LD_ADDR_OWVAR 37
4197: PUSH
4198: LD_INT 22
4200: ST_TO_ADDR
// vc_engine := engine_combustion ;
4201: LD_ADDR_OWVAR 39
4205: PUSH
4206: LD_INT 1
4208: ST_TO_ADDR
// vc_control := control_manual ;
4209: LD_ADDR_OWVAR 38
4213: PUSH
4214: LD_INT 1
4216: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4217: LD_ADDR_OWVAR 40
4221: PUSH
4222: LD_INT 51
4224: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4225: LD_ADDR_OWVAR 41
4229: PUSH
4230: LD_INT 30
4232: ST_TO_ADDR
// veh := CreateVehicle ;
4233: LD_ADDR_VAR 0 6
4237: PUSH
4238: CALL_OW 45
4242: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4243: LD_VAR 0 6
4247: PPUSH
4248: LD_INT 1
4250: PPUSH
4251: LD_INT 100
4253: PPUSH
4254: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4258: LD_VAR 0 6
4262: PPUSH
4263: LD_INT 107
4265: PPUSH
4266: LD_INT 83
4268: PPUSH
4269: LD_INT 0
4271: PPUSH
4272: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4276: LD_ADDR_OWVAR 37
4280: PUSH
4281: LD_INT 22
4283: ST_TO_ADDR
// vc_engine := engine_combustion ;
4284: LD_ADDR_OWVAR 39
4288: PUSH
4289: LD_INT 1
4291: ST_TO_ADDR
// vc_control := control_manual ;
4292: LD_ADDR_OWVAR 38
4296: PUSH
4297: LD_INT 1
4299: ST_TO_ADDR
// vc_weapon := ru_crane ;
4300: LD_ADDR_OWVAR 40
4304: PUSH
4305: LD_INT 52
4307: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4308: LD_ADDR_OWVAR 41
4312: PUSH
4313: LD_INT 30
4315: ST_TO_ADDR
// veh := CreateVehicle ;
4316: LD_ADDR_VAR 0 6
4320: PUSH
4321: CALL_OW 45
4325: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4326: LD_VAR 0 6
4330: PPUSH
4331: LD_INT 115
4333: PPUSH
4334: LD_INT 96
4336: PPUSH
4337: LD_INT 0
4339: PPUSH
4340: CALL_OW 48
// end ; end ;
4344: GO 4347
4346: POP
// tmp := CharacterSelection ( text , 15 , 15 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4347: LD_ADDR_VAR 0 4
4351: PUSH
4352: LD_STRING text
4354: PPUSH
4355: LD_INT 15
4357: PPUSH
4358: LD_INT 15
4360: PPUSH
4361: LD_INT -2
4363: PUSH
4364: LD_INT -5
4366: PUSH
4367: LD_INT -3
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: LD_VAR 0 5
4379: ADD
4380: PPUSH
4381: LD_INT 1
4383: PUSH
4384: LD_INT 2
4386: PUSH
4387: LD_INT 1
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 3
4396: PUSH
4397: LD_INT 4
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PPUSH
4406: CALL_OW 42
4410: ST_TO_ADDR
// PlaceUnitArea ( player [ 1 ] , gaidar_base , false ) ;
4411: LD_EXP 16
4415: PUSH
4416: LD_INT 1
4418: ARRAY
4419: PPUSH
4420: LD_INT 9
4422: PPUSH
4423: LD_INT 0
4425: PPUSH
4426: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4430: LD_VAR 0 4
4434: PUSH
4435: LD_INT 1
4437: ARRAY
4438: PPUSH
4439: LD_INT 2
4441: PPUSH
4442: CALL_OW 336
// for i = 1 to tmp do
4446: LD_ADDR_VAR 0 2
4450: PUSH
4451: DOUBLE
4452: LD_INT 1
4454: DEC
4455: ST_TO_ADDR
4456: LD_VAR 0 4
4460: PUSH
4461: FOR_TO
4462: IFFALSE 4517
// if i < 4 then
4464: LD_VAR 0 2
4468: PUSH
4469: LD_INT 4
4471: LESS
4472: IFFALSE 4497
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4474: LD_VAR 0 4
4478: PUSH
4479: LD_VAR 0 2
4483: ARRAY
4484: PPUSH
4485: LD_INT 9
4487: PPUSH
4488: LD_INT 0
4490: PPUSH
4491: CALL_OW 49
4495: GO 4515
// SetSide ( tmp [ i ] , 6 ) ;
4497: LD_VAR 0 4
4501: PUSH
4502: LD_VAR 0 2
4506: ARRAY
4507: PPUSH
4508: LD_INT 6
4510: PPUSH
4511: CALL_OW 235
4515: GO 4461
4517: POP
4518: POP
// player_squad := tmp ;
4519: LD_ADDR_EXP 21
4523: PUSH
4524: LD_VAR 0 4
4528: ST_TO_ADDR
// pl_counter := 4 ;
4529: LD_ADDR_EXP 22
4533: PUSH
4534: LD_INT 4
4536: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4537: LD_INT 17
4539: PPUSH
4540: LD_INT 5
4542: PPUSH
4543: LD_INT 1
4545: PPUSH
4546: CALL 17680 0 3
// end ;
4550: LD_VAR 0 1
4554: RET
// export Popov ; export function InitAction ; begin
4555: LD_INT 0
4557: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4558: LD_INT 6
4560: PPUSH
4561: LD_INT 3
4563: PPUSH
4564: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4568: LD_INT 1
4570: PPUSH
4571: LD_INT 1
4573: PPUSH
4574: CALL_OW 86
// uc_side := 6 ;
4578: LD_ADDR_OWVAR 20
4582: PUSH
4583: LD_INT 6
4585: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4586: LD_ADDR_EXP 24
4590: PUSH
4591: LD_STRING Popov
4593: PPUSH
4594: CALL_OW 25
4598: ST_TO_ADDR
// case query ( textdiff ) of 1 :
4599: LD_STRING textdiff
4601: PPUSH
4602: CALL_OW 97
4606: PUSH
4607: LD_INT 1
4609: DOUBLE
4610: EQUAL
4611: IFTRUE 4615
4613: GO 4626
4615: POP
// Difficulty := 1 ; 2 :
4616: LD_ADDR_OWVAR 67
4620: PUSH
4621: LD_INT 1
4623: ST_TO_ADDR
4624: GO 4665
4626: LD_INT 2
4628: DOUBLE
4629: EQUAL
4630: IFTRUE 4634
4632: GO 4645
4634: POP
// Difficulty := 2 ; 3 :
4635: LD_ADDR_OWVAR 67
4639: PUSH
4640: LD_INT 2
4642: ST_TO_ADDR
4643: GO 4665
4645: LD_INT 3
4647: DOUBLE
4648: EQUAL
4649: IFTRUE 4653
4651: GO 4664
4653: POP
// Difficulty := 3 ; end ;
4654: LD_ADDR_OWVAR 67
4658: PUSH
4659: LD_INT 3
4661: ST_TO_ADDR
4662: GO 4665
4664: POP
// case query ( choosecom ) of 1 :
4665: LD_STRING choosecom
4667: PPUSH
4668: CALL_OW 97
4672: PUSH
4673: LD_INT 1
4675: DOUBLE
4676: EQUAL
4677: IFTRUE 4681
4679: GO 4688
4681: POP
// InitCommanders ; end ;
4682: CALL 3114 0 0
4686: GO 4689
4688: POP
// end ;
4689: LD_VAR 0 1
4693: RET
// every 1 1$45 trigger pl_counter < 15 do var i ;
4694: LD_EXP 22
4698: PUSH
4699: LD_INT 15
4701: LESS
4702: IFFALSE 4875
4704: GO 4706
4706: DISABLE
4707: LD_INT 0
4709: PPUSH
// begin enable ;
4710: ENABLE
// for i = pl_counter to pl_counter + 2 do
4711: LD_ADDR_VAR 0 1
4715: PUSH
4716: DOUBLE
4717: LD_EXP 22
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 22
4727: PUSH
4728: LD_INT 2
4730: PLUS
4731: PUSH
4732: FOR_TO
4733: IFFALSE 4779
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4735: LD_EXP 21
4739: PUSH
4740: LD_VAR 0 1
4744: ARRAY
4745: PPUSH
4746: LD_INT 18
4748: PPUSH
4749: LD_INT 0
4751: PPUSH
4752: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4756: LD_EXP 21
4760: PUSH
4761: LD_VAR 0 1
4765: ARRAY
4766: PPUSH
4767: LD_INT 107
4769: PPUSH
4770: LD_INT 88
4772: PPUSH
4773: CALL_OW 111
// end ;
4777: GO 4732
4779: POP
4780: POP
// for i = pl_counter to pl_counter + 2 do
4781: LD_ADDR_VAR 0 1
4785: PUSH
4786: DOUBLE
4787: LD_EXP 22
4791: DEC
4792: ST_TO_ADDR
4793: LD_EXP 22
4797: PUSH
4798: LD_INT 2
4800: PLUS
4801: PUSH
4802: FOR_TO
4803: IFFALSE 4859
// begin repeat wait ( 0 0$01 ) ;
4805: LD_INT 35
4807: PPUSH
4808: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4812: LD_EXP 21
4816: PUSH
4817: LD_VAR 0 1
4821: ARRAY
4822: PPUSH
4823: LD_INT 107
4825: PPUSH
4826: LD_INT 88
4828: PPUSH
4829: CALL_OW 297
4833: PUSH
4834: LD_INT 6
4836: LESS
4837: IFFALSE 4805
// SetSide ( player_squad [ i ] , 3 ) ;
4839: LD_EXP 21
4843: PUSH
4844: LD_VAR 0 1
4848: ARRAY
4849: PPUSH
4850: LD_INT 3
4852: PPUSH
4853: CALL_OW 235
// end ;
4857: GO 4802
4859: POP
4860: POP
// pl_counter := pl_counter + 3 ;
4861: LD_ADDR_EXP 22
4865: PUSH
4866: LD_EXP 22
4870: PUSH
4871: LD_INT 3
4873: PLUS
4874: ST_TO_ADDR
// end ;
4875: PPOPN 1
4877: END
// export function Dialog ; begin
4878: LD_INT 0
4880: PPUSH
// case query ( task ) of 1 :
4881: LD_STRING task
4883: PPUSH
4884: CALL_OW 97
4888: PUSH
4889: LD_INT 1
4891: DOUBLE
4892: EQUAL
4893: IFTRUE 4897
4895: GO 4900
4897: POP
// ; end ;
4898: GO 4901
4900: POP
// InGameOn ;
4901: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4905: LD_INT 107
4907: PPUSH
4908: LD_INT 84
4910: PPUSH
4911: CALL_OW 86
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4915: LD_ADDR_EXP 9
4919: PUSH
4920: LD_EXP 21
4924: PUSH
4925: LD_INT 1
4927: ARRAY
4928: PPUSH
4929: LD_INT 0
4931: PPUSH
4932: LD_INT 96
4934: PPUSH
4935: LD_INT 79
4937: PPUSH
4938: LD_INT 2
4940: PPUSH
4941: CALL_OW 145
4945: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4946: LD_INT 35
4948: PPUSH
4949: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// Wait ( 0 0$01 ) ;
4965: LD_INT 35
4967: PPUSH
4968: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4972: LD_EXP 24
4976: PPUSH
4977: LD_STRING DR2
4979: PPUSH
4980: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4984: LD_EXP 24
4988: PPUSH
4989: LD_STRING DR3
4991: PPUSH
4992: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
4996: LD_INT 35
4998: PPUSH
4999: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) ;
5003: LD_INT 3
5005: PPUSH
5006: LD_INT 30
5008: PUSH
5009: LD_INT 0
5011: PUSH
5012: EMPTY
5013: LIST
5014: LIST
5015: PPUSH
5016: CALL 10967 0 2
5020: IFFALSE 4996
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 2
5027: PPUSH
5028: LD_INT 2
5030: PPUSH
5031: LD_EXP 9
5035: PPUSH
5036: CALL_OW 468
// InGameOff ;
5040: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5044: LD_STRING C1
5046: PPUSH
5047: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5051: LD_INT 35
5053: PPUSH
5054: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5058: LD_EXP 9
5062: PPUSH
5063: CALL_OW 461
5067: PUSH
5068: LD_INT 2
5070: EQUAL
5071: IFFALSE 5051
// case query ( support ) of 1 :
5073: LD_STRING support
5075: PPUSH
5076: CALL_OW 97
5080: PUSH
5081: LD_INT 1
5083: DOUBLE
5084: EQUAL
5085: IFTRUE 5089
5087: GO 5092
5089: POP
// ; end ;
5090: GO 5093
5092: POP
// if player_com = stolypin then
5093: LD_EXP 23
5097: PUSH
5098: LD_EXP 20
5102: EQUAL
5103: IFFALSE 5132
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5105: LD_INT 18
5107: PPUSH
5108: LD_INT 3
5110: PUSH
5111: LD_INT 3
5113: PUSH
5114: LD_INT 2
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: LD_OWVAR 67
5126: ARRAY
5127: PPUSH
5128: CALL 6429 0 2
// end ;
5132: LD_VAR 0 1
5136: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5137: LD_EXP 10
5141: PUSH
5142: LD_OWVAR 1
5146: PUSH
5147: LD_INT 31500
5149: LESS
5150: AND
5151: IFFALSE 5319
// case query ( call1 ) of 1 :
5153: LD_STRING call1
5155: PPUSH
5156: CALL_OW 97
5160: PUSH
5161: LD_INT 1
5163: DOUBLE
5164: EQUAL
5165: IFTRUE 5169
5167: GO 5307
5169: POP
// begin SetArtifactUse ( 3 , art_exp_mid , art_gray , player_depot ) ;
5170: LD_INT 3
5172: PPUSH
5173: LD_INT 2
5175: PPUSH
5176: LD_INT 1
5178: PPUSH
5179: LD_EXP 9
5183: PPUSH
5184: CALL_OW 468
// call := false ;
5188: LD_ADDR_EXP 10
5192: PUSH
5193: LD_INT 0
5195: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5196: LD_EXP 24
5200: PPUSH
5201: LD_STRING DR6
5203: PPUSH
5204: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5208: LD_INT 6300
5210: PPUSH
5211: LD_INT 8400
5213: PPUSH
5214: CALL_OW 12
5218: PPUSH
5219: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , 2 - Rand ( 0 , 1 ) ) ;
5223: LD_INT 18
5225: PUSH
5226: LD_INT 19
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: LD_INT 1
5235: PPUSH
5236: LD_INT 2
5238: PPUSH
5239: CALL_OW 12
5243: ARRAY
5244: PPUSH
5245: LD_INT 2
5247: PUSH
5248: LD_INT 0
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 12
5258: MINUS
5259: PPUSH
5260: CALL 6429 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5264: LD_INT 25200
5266: PPUSH
5267: LD_INT 35700
5269: PPUSH
5270: CALL_OW 12
5274: PPUSH
5275: CALL_OW 67
// call := true ;
5279: LD_ADDR_EXP 10
5283: PUSH
5284: LD_INT 1
5286: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5287: LD_INT 3
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: LD_INT 2
5295: PPUSH
5296: LD_EXP 9
5300: PPUSH
5301: CALL_OW 468
// end ; 2 :
5305: GO 5319
5307: LD_INT 2
5309: DOUBLE
5310: EQUAL
5311: IFTRUE 5315
5313: GO 5318
5315: POP
// ; end ;
5316: GO 5319
5318: POP
// if call and tick >= 15 15$00 then
5319: LD_EXP 10
5323: PUSH
5324: LD_OWVAR 1
5328: PUSH
5329: LD_INT 31500
5331: GREATEREQUAL
5332: AND
5333: IFFALSE 5762
// case query ( call2 ) of 1 :
5335: LD_STRING call2
5337: PPUSH
5338: CALL_OW 97
5342: PUSH
5343: LD_INT 1
5345: DOUBLE
5346: EQUAL
5347: IFTRUE 5351
5349: GO 5587
5351: POP
// begin call := false ;
5352: LD_ADDR_EXP 10
5356: PUSH
5357: LD_INT 0
5359: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5360: LD_INT 1
5362: PPUSH
5363: LD_INT 21
5365: PUSH
5366: LD_INT 3
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PPUSH
5373: CALL 10967 0 2
5377: PUSH
5378: LD_INT 4
5380: PPUSH
5381: LD_INT 21
5383: PUSH
5384: LD_INT 3
5386: PUSH
5387: EMPTY
5388: LIST
5389: LIST
5390: PPUSH
5391: CALL 10967 0 2
5395: AND
5396: IFFALSE 5444
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
5398: LD_INT 18
5400: PUSH
5401: LD_INT 19
5403: PUSH
5404: EMPTY
5405: LIST
5406: LIST
5407: PUSH
5408: LD_INT 1
5410: PPUSH
5411: LD_INT 2
5413: PPUSH
5414: CALL_OW 12
5418: ARRAY
5419: PPUSH
5420: LD_INT 4
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: LD_INT 3
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: LIST
5433: PUSH
5434: LD_OWVAR 67
5438: ARRAY
5439: PPUSH
5440: CALL 6190 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5444: LD_INT 1
5446: PPUSH
5447: LD_INT 21
5449: PUSH
5450: LD_INT 3
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: PPUSH
5457: CALL 10967 0 2
5461: PUSH
5462: LD_INT 0
5464: EQUAL
5465: IFFALSE 5494
// PrepareAttack ( south_arr , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
5467: LD_INT 19
5469: PPUSH
5470: LD_INT 4
5472: PUSH
5473: LD_INT 3
5475: PUSH
5476: LD_INT 3
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: LIST
5483: PUSH
5484: LD_OWVAR 67
5488: ARRAY
5489: PPUSH
5490: CALL 6190 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5494: LD_INT 4
5496: PPUSH
5497: LD_INT 21
5499: PUSH
5500: LD_INT 3
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PPUSH
5507: CALL 10967 0 2
5511: PUSH
5512: LD_INT 0
5514: EQUAL
5515: IFFALSE 5544
// PrepareAttack ( east_arr , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
5517: LD_INT 18
5519: PPUSH
5520: LD_INT 4
5522: PUSH
5523: LD_INT 3
5525: PUSH
5526: LD_INT 3
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: LIST
5533: PUSH
5534: LD_OWVAR 67
5538: ARRAY
5539: PPUSH
5540: CALL 6190 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5544: LD_INT 10500
5546: PPUSH
5547: LD_INT 23100
5549: PPUSH
5550: CALL_OW 12
5554: PPUSH
5555: CALL_OW 67
// call := true ;
5559: LD_ADDR_EXP 10
5563: PUSH
5564: LD_INT 1
5566: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5567: LD_INT 3
5569: PPUSH
5570: LD_INT 2
5572: PPUSH
5573: LD_INT 2
5575: PPUSH
5576: LD_EXP 9
5580: PPUSH
5581: CALL_OW 468
// end ; 2 :
5585: GO 5762
5587: LD_INT 2
5589: DOUBLE
5590: EQUAL
5591: IFTRUE 5595
5593: GO 5750
5595: POP
// begin SetArtifactUse ( 3 , art_exp_mid , art_gray , player_depot ) ;
5596: LD_INT 3
5598: PPUSH
5599: LD_INT 2
5601: PPUSH
5602: LD_INT 1
5604: PPUSH
5605: LD_EXP 9
5609: PPUSH
5610: CALL_OW 468
// call := false ;
5614: LD_ADDR_EXP 10
5618: PUSH
5619: LD_INT 0
5621: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5622: LD_EXP 24
5626: PPUSH
5627: LD_STRING DR6
5629: PPUSH
5630: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5634: LD_INT 6300
5636: PPUSH
5637: LD_INT 8400
5639: PPUSH
5640: CALL_OW 12
5644: PPUSH
5645: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5649: LD_INT 18
5651: PUSH
5652: LD_INT 19
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 1
5661: PPUSH
5662: LD_INT 2
5664: PPUSH
5665: CALL_OW 12
5669: ARRAY
5670: PPUSH
5671: LD_INT 3
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_OWVAR 67
5689: ARRAY
5690: PUSH
5691: LD_INT 0
5693: PPUSH
5694: LD_INT 1
5696: PPUSH
5697: CALL_OW 12
5701: MINUS
5702: PPUSH
5703: CALL 6429 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5707: LD_INT 35700
5709: PPUSH
5710: LD_INT 44100
5712: PPUSH
5713: CALL_OW 12
5717: PPUSH
5718: CALL_OW 67
// call := true ;
5722: LD_ADDR_EXP 10
5726: PUSH
5727: LD_INT 1
5729: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5730: LD_INT 3
5732: PPUSH
5733: LD_INT 2
5735: PPUSH
5736: LD_INT 2
5738: PPUSH
5739: LD_EXP 9
5743: PPUSH
5744: CALL_OW 468
// end ; 3 :
5748: GO 5762
5750: LD_INT 3
5752: DOUBLE
5753: EQUAL
5754: IFTRUE 5758
5756: GO 5761
5758: POP
// ; end ;
5759: GO 5762
5761: POP
// end ;
5762: PPOPN 4
5764: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5765: LD_INT 22
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 21
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PPUSH
5789: CALL_OW 69
5793: PUSH
5794: LD_INT 0
5796: EQUAL
5797: PUSH
5798: LD_INT 22
5800: PUSH
5801: LD_INT 4
5803: PUSH
5804: EMPTY
5805: LIST
5806: LIST
5807: PUSH
5808: LD_INT 21
5810: PUSH
5811: LD_INT 1
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: PPUSH
5822: CALL_OW 69
5826: PUSH
5827: LD_INT 0
5829: EQUAL
5830: AND
5831: IFFALSE 6035
5833: GO 5835
5835: DISABLE
// begin DialogueOn ;
5836: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5840: LD_EXP 24
5844: PPUSH
5845: LD_STRING DR7
5847: PPUSH
5848: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5852: LD_OWVAR 1
5856: PUSH
5857: LD_INT 116550
5859: PUSH
5860: LD_INT 95550
5862: PUSH
5863: LD_INT 89250
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: LIST
5870: PUSH
5871: LD_OWVAR 67
5875: ARRAY
5876: LESS
5877: IFFALSE 5891
// AddMedal ( med1 , 1 ) else
5879: LD_STRING med1
5881: PPUSH
5882: LD_INT 1
5884: PPUSH
5885: CALL_OW 101
5889: GO 5902
// AddMedal ( med1 , - 1 ) ;
5891: LD_STRING med1
5893: PPUSH
5894: LD_INT 1
5896: NEG
5897: PPUSH
5898: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5902: LD_INT 81
5904: PUSH
5905: LD_INT 3
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: PUSH
5912: LD_INT 21
5914: PUSH
5915: LD_INT 3
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PPUSH
5926: CALL_OW 69
5930: PUSH
5931: LD_INT 0
5933: EQUAL
5934: IFFALSE 5948
// AddMedal ( med3 , 1 ) else
5936: LD_STRING med3
5938: PPUSH
5939: LD_INT 1
5941: PPUSH
5942: CALL_OW 101
5946: GO 5959
// AddMedal ( med3 , - 1 ) ;
5948: LD_STRING med3
5950: PPUSH
5951: LD_INT 1
5953: NEG
5954: PPUSH
5955: CALL_OW 101
// if player_squad = 15 then
5959: LD_EXP 21
5963: PUSH
5964: LD_INT 15
5966: EQUAL
5967: IFFALSE 5981
// AddMedal ( med2 , 1 ) else
5969: LD_STRING med2
5971: PPUSH
5972: LD_INT 1
5974: PPUSH
5975: CALL_OW 101
5979: GO 6024
// if player_squad > 12 and player_squad < 15 then
5981: LD_EXP 21
5985: PUSH
5986: LD_INT 12
5988: GREATER
5989: PUSH
5990: LD_EXP 21
5994: PUSH
5995: LD_INT 15
5997: LESS
5998: AND
5999: IFFALSE 6013
// AddMedal ( med2 , 2 ) else
6001: LD_STRING med2
6003: PPUSH
6004: LD_INT 2
6006: PPUSH
6007: CALL_OW 101
6011: GO 6024
// AddMedal ( med2 , - 1 ) ;
6013: LD_STRING med2
6015: PPUSH
6016: LD_INT 1
6018: NEG
6019: PPUSH
6020: CALL_OW 101
// GiveMedals ( MAIN ) ;
6024: LD_STRING MAIN
6026: PPUSH
6027: CALL_OW 102
// YouWin ;
6031: CALL_OW 103
// end ;
6035: END
// every 0 0$01 trigger IsDead ( player_com ) do
6036: LD_EXP 23
6040: PPUSH
6041: CALL_OW 301
6045: IFFALSE 6112
6047: GO 6049
6049: DISABLE
// begin if IsLive ( Houten ) then
6050: LD_EXP 1
6054: PPUSH
6055: CALL_OW 300
6059: IFFALSE 6075
// SayRadio ( Houten , DJ5 ) else
6061: LD_EXP 1
6065: PPUSH
6066: LD_STRING DJ5
6068: PPUSH
6069: CALL_OW 94
6073: GO 6098
// if IsLive ( Brown ) then
6075: LD_EXP 2
6079: PPUSH
6080: CALL_OW 300
6084: IFFALSE 6098
// SayRadio ( Brown , DS5 ) ;
6086: LD_EXP 2
6090: PPUSH
6091: LD_STRING DS5
6093: PPUSH
6094: CALL_OW 94
// Wait ( 0 0$01 ) ;
6098: LD_INT 35
6100: PPUSH
6101: CALL_OW 67
// YouLost ( dead ) ;
6105: LD_STRING dead
6107: PPUSH
6108: CALL_OW 104
// end ;
6112: END
// every 0 0$01 trigger IsDead ( player_depot ) do
6113: LD_EXP 9
6117: PPUSH
6118: CALL_OW 301
6122: IFFALSE 6189
6124: GO 6126
6126: DISABLE
// begin if IsLive ( Brown ) then
6127: LD_EXP 2
6131: PPUSH
6132: CALL_OW 300
6136: IFFALSE 6152
// SayRadio ( Brown , DS5 ) else
6138: LD_EXP 2
6142: PPUSH
6143: LD_STRING DS5
6145: PPUSH
6146: CALL_OW 94
6150: GO 6175
// if IsLive ( Houten ) then
6152: LD_EXP 1
6156: PPUSH
6157: CALL_OW 300
6161: IFFALSE 6175
// SayRadio ( Houten , DJ5 ) ;
6163: LD_EXP 1
6167: PPUSH
6168: LD_STRING DJ5
6170: PPUSH
6171: CALL_OW 94
// Wait ( 0 0$01 ) ;
6175: LD_INT 35
6177: PPUSH
6178: CALL_OW 67
// YouLost ( depot ) ;
6182: LD_STRING depot
6184: PPUSH
6185: CALL_OW 104
// end ;
6189: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6190: LD_INT 0
6192: PPUSH
6193: PPUSH
6194: PPUSH
// for i = 1 to n do
6195: LD_ADDR_VAR 0 4
6199: PUSH
6200: DOUBLE
6201: LD_INT 1
6203: DEC
6204: ST_TO_ADDR
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6414
// begin uc_side := 6 ;
6213: LD_ADDR_OWVAR 20
6217: PUSH
6218: LD_INT 6
6220: ST_TO_ADDR
// uc_nation := 3 ;
6221: LD_ADDR_OWVAR 21
6225: PUSH
6226: LD_INT 3
6228: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6229: LD_ADDR_OWVAR 37
6233: PUSH
6234: LD_INT 23
6236: PUSH
6237: LD_INT 22
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 1
6246: PPUSH
6247: LD_INT 2
6249: PPUSH
6250: CALL_OW 12
6254: ARRAY
6255: ST_TO_ADDR
// vc_control := control_computer ;
6256: LD_ADDR_OWVAR 38
6260: PUSH
6261: LD_INT 3
6263: ST_TO_ADDR
// vc_engine := engine_siberite ;
6264: LD_ADDR_OWVAR 39
6268: PUSH
6269: LD_INT 3
6271: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 3 ) ] ;
6272: LD_ADDR_OWVAR 40
6276: PUSH
6277: LD_INT 43
6279: PUSH
6280: LD_INT 44
6282: PUSH
6283: LD_INT 42
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: LIST
6290: PUSH
6291: LD_INT 1
6293: PPUSH
6294: LD_INT 3
6296: PPUSH
6297: CALL_OW 12
6301: ARRAY
6302: ST_TO_ADDR
// un := CreateVehicle ;
6303: LD_ADDR_VAR 0 5
6307: PUSH
6308: CALL_OW 45
6312: ST_TO_ADDR
// case area of east_arr :
6313: LD_VAR 0 1
6317: PUSH
6318: LD_INT 18
6320: DOUBLE
6321: EQUAL
6322: IFTRUE 6326
6324: GO 6361
6326: POP
// begin PlaceUnitArea ( un , area , false ) ;
6327: LD_VAR 0 5
6331: PPUSH
6332: LD_VAR 0 1
6336: PPUSH
6337: LD_INT 0
6339: PPUSH
6340: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6344: LD_VAR 0 5
6348: PPUSH
6349: LD_INT 79
6351: PPUSH
6352: LD_INT 33
6354: PPUSH
6355: CALL_OW 111
// end ; south_arr :
6359: GO 6405
6361: LD_INT 19
6363: DOUBLE
6364: EQUAL
6365: IFTRUE 6369
6367: GO 6404
6369: POP
// begin PlaceUnitArea ( un , area , false ) ;
6370: LD_VAR 0 5
6374: PPUSH
6375: LD_VAR 0 1
6379: PPUSH
6380: LD_INT 0
6382: PPUSH
6383: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6387: LD_VAR 0 5
6391: PPUSH
6392: LD_INT 131
6394: PPUSH
6395: LD_INT 148
6397: PPUSH
6398: CALL_OW 111
// end ; end ;
6402: GO 6405
6404: POP
// Wait ( 0 0$02 ) ;
6405: LD_INT 70
6407: PPUSH
6408: CALL_OW 67
// end ;
6412: GO 6210
6414: POP
6415: POP
// pink_attack := true ;
6416: LD_ADDR_EXP 11
6420: PUSH
6421: LD_INT 1
6423: ST_TO_ADDR
// end ;
6424: LD_VAR 0 3
6428: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
6433: PPUSH
// for i = 1 to n do
6434: LD_ADDR_VAR 0 4
6438: PUSH
6439: DOUBLE
6440: LD_INT 1
6442: DEC
6443: ST_TO_ADDR
6444: LD_VAR 0 2
6448: PUSH
6449: FOR_TO
6450: IFFALSE 6676
// begin uc_side := 6 ;
6452: LD_ADDR_OWVAR 20
6456: PUSH
6457: LD_INT 6
6459: ST_TO_ADDR
// uc_nation := 3 ;
6460: LD_ADDR_OWVAR 21
6464: PUSH
6465: LD_INT 3
6467: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6468: LD_INT 0
6470: PPUSH
6471: LD_INT 3
6473: PPUSH
6474: LD_INT 4
6476: PPUSH
6477: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6481: LD_ADDR_OWVAR 37
6485: PUSH
6486: LD_INT 22
6488: ST_TO_ADDR
// vc_control := control_manual ;
6489: LD_ADDR_OWVAR 38
6493: PUSH
6494: LD_INT 1
6496: ST_TO_ADDR
// vc_engine := engine_combustion ;
6497: LD_ADDR_OWVAR 39
6501: PUSH
6502: LD_INT 1
6504: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6505: LD_ADDR_OWVAR 40
6509: PUSH
6510: LD_INT 51
6512: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6513: LD_ADDR_OWVAR 41
6517: PUSH
6518: LD_INT 50
6520: ST_TO_ADDR
// un := CreateVehicle ;
6521: LD_ADDR_VAR 0 5
6525: PUSH
6526: CALL_OW 45
6530: ST_TO_ADDR
// case area of east_arr :
6531: LD_VAR 0 1
6535: PUSH
6536: LD_INT 18
6538: DOUBLE
6539: EQUAL
6540: IFTRUE 6544
6542: GO 6559
6544: POP
// SetDir ( un , 4 ) ; south_arr :
6545: LD_VAR 0 5
6549: PPUSH
6550: LD_INT 4
6552: PPUSH
6553: CALL_OW 233
6557: GO 6583
6559: LD_INT 19
6561: DOUBLE
6562: EQUAL
6563: IFTRUE 6567
6565: GO 6582
6567: POP
// SetDir ( un , 5 ) ; end ;
6568: LD_VAR 0 5
6572: PPUSH
6573: LD_INT 5
6575: PPUSH
6576: CALL_OW 233
6580: GO 6583
6582: POP
// PlaceUnitArea ( un , area , false ) ;
6583: LD_VAR 0 5
6587: PPUSH
6588: LD_VAR 0 1
6592: PPUSH
6593: LD_INT 0
6595: PPUSH
6596: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6600: CALL_OW 44
6604: PPUSH
6605: LD_VAR 0 5
6609: PPUSH
6610: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 1
6621: PPUSH
6622: LD_INT 100
6624: PPUSH
6625: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6629: LD_VAR 0 5
6633: PPUSH
6634: LD_INT 106
6636: PPUSH
6637: LD_INT 88
6639: PPUSH
6640: CALL_OW 111
// AddComUnload ( un ) ;
6644: LD_VAR 0 5
6648: PPUSH
6649: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6653: LD_VAR 0 5
6657: PPUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 173
// Wait ( 0 0$02 ) ;
6667: LD_INT 70
6669: PPUSH
6670: CALL_OW 67
// end ;
6674: GO 6449
6676: POP
6677: POP
// Wait ( 0 0$05 ) ;
6678: LD_INT 175
6680: PPUSH
6681: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6685: LD_INT 6
6687: PPUSH
6688: LD_INT 34
6690: PUSH
6691: LD_INT 51
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PPUSH
6698: CALL 10967 0 2
6702: IFFALSE 6890
// begin wait ( 0 0$01 ) ;
6704: LD_INT 35
6706: PPUSH
6707: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6711: LD_ADDR_VAR 0 4
6715: PUSH
6716: LD_INT 6
6718: PPUSH
6719: LD_INT 34
6721: PUSH
6722: LD_INT 51
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: PPUSH
6729: CALL 10967 0 2
6733: PUSH
6734: FOR_IN
6735: IFFALSE 6886
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6737: LD_VAR 0 4
6741: PPUSH
6742: LD_INT 9
6744: PPUSH
6745: CALL_OW 308
6749: PUSH
6750: LD_VAR 0 4
6754: PPUSH
6755: CALL 30475 0 1
6759: PPUSH
6760: CALL_OW 258
6764: PUSH
6765: LD_INT 1
6767: EQUAL
6768: AND
6769: PUSH
6770: LD_EXP 8
6774: AND
6775: IFFALSE 6802
// begin Say ( GetDriver ( i ) , Dtran ) ;
6777: LD_VAR 0 4
6781: PPUSH
6782: CALL 30475 0 1
6786: PPUSH
6787: LD_STRING Dtran
6789: PPUSH
6790: CALL_OW 88
// dialog_trans := false ;
6794: LD_ADDR_EXP 8
6798: PUSH
6799: LD_INT 0
6801: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6802: LD_VAR 0 4
6806: PPUSH
6807: CALL_OW 316
6811: IFFALSE 6827
// ComMoveToArea ( i , area ) ;
6813: LD_VAR 0 4
6817: PPUSH
6818: LD_VAR 0 1
6822: PPUSH
6823: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6827: LD_VAR 0 4
6831: PPUSH
6832: LD_VAR 0 1
6836: PPUSH
6837: CALL_OW 308
6841: PUSH
6842: LD_VAR 0 4
6846: PPUSH
6847: LD_INT 1
6849: PPUSH
6850: CALL_OW 289
6854: PUSH
6855: LD_INT 0
6857: EQUAL
6858: AND
6859: IFFALSE 6884
// begin RemoveUnit ( GetDriver ( i ) ) ;
6861: LD_VAR 0 4
6865: PPUSH
6866: CALL 30475 0 1
6870: PPUSH
6871: CALL_OW 64
// RemoveUnit ( i ) ;
6875: LD_VAR 0 4
6879: PPUSH
6880: CALL_OW 64
// end ; end ;
6884: GO 6734
6886: POP
6887: POP
// end ;
6888: GO 6685
// end ;
6890: LD_VAR 0 3
6894: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6895: LD_INT 0
6897: PPUSH
6898: PPUSH
6899: PPUSH
6900: PPUSH
// for i = 1 to n do
6901: LD_ADDR_VAR 0 4
6905: PUSH
6906: DOUBLE
6907: LD_INT 1
6909: DEC
6910: ST_TO_ADDR
6911: LD_VAR 0 2
6915: PUSH
6916: FOR_TO
6917: IFFALSE 7149
// begin uc_side := 8 ;
6919: LD_ADDR_OWVAR 20
6923: PUSH
6924: LD_INT 8
6926: ST_TO_ADDR
// uc_nation := 1 ;
6927: LD_ADDR_OWVAR 21
6931: PUSH
6932: LD_INT 1
6934: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
6935: LD_ADDR_VAR 0 6
6939: PUSH
6940: LD_INT 3
6942: PUSH
6943: LD_INT 4
6945: PUSH
6946: LD_INT 4
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 1
6956: PPUSH
6957: LD_OWVAR 67
6961: PPUSH
6962: CALL_OW 12
6966: ARRAY
6967: ST_TO_ADDR
// vc_chassis := ch ;
6968: LD_ADDR_OWVAR 37
6972: PUSH
6973: LD_VAR 0 6
6977: ST_TO_ADDR
// vc_control := control_computer ;
6978: LD_ADDR_OWVAR 38
6982: PUSH
6983: LD_INT 3
6985: ST_TO_ADDR
// vc_engine := engine_combustion ;
6986: LD_ADDR_OWVAR 39
6990: PUSH
6991: LD_INT 1
6993: ST_TO_ADDR
// if ch = us_medium_tracked then
6994: LD_VAR 0 6
6998: PUSH
6999: LD_INT 3
7001: EQUAL
7002: IFFALSE 7049
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7004: LD_ADDR_OWVAR 40
7008: PUSH
7009: LD_INT 3
7011: PUSH
7012: LD_INT 4
7014: PUSH
7015: LD_INT 5
7017: PUSH
7018: LD_INT 7
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: PUSH
7027: LD_OWVAR 67
7031: PPUSH
7032: LD_OWVAR 67
7036: PUSH
7037: LD_INT 1
7039: PLUS
7040: PPUSH
7041: CALL_OW 12
7045: ARRAY
7046: ST_TO_ADDR
7047: GO 7090
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7049: LD_ADDR_OWVAR 40
7053: PUSH
7054: LD_INT 5
7056: PUSH
7057: LD_INT 6
7059: PUSH
7060: LD_INT 7
7062: PUSH
7063: LD_INT 7
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_OWVAR 67
7079: PUSH
7080: LD_INT 1
7082: PLUS
7083: PPUSH
7084: CALL_OW 12
7088: ARRAY
7089: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7090: LD_ADDR_OWVAR 41
7094: PUSH
7095: LD_INT 70
7097: ST_TO_ADDR
// un := CreateVehicle ;
7098: LD_ADDR_VAR 0 5
7102: PUSH
7103: CALL_OW 45
7107: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7108: LD_VAR 0 5
7112: PPUSH
7113: LD_VAR 0 1
7117: PPUSH
7118: LD_INT 0
7120: PPUSH
7121: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7125: LD_VAR 0 5
7129: PPUSH
7130: LD_INT 65
7132: PPUSH
7133: LD_INT 9
7135: PPUSH
7136: CALL_OW 111
// Wait ( 0 0$02 ) ;
7140: LD_INT 70
7142: PPUSH
7143: CALL_OW 67
// end ;
7147: GO 6916
7149: POP
7150: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7151: LD_INT 90
7153: PUSH
7154: LD_INT 80
7156: PUSH
7157: LD_INT 70
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: LD_OWVAR 67
7169: ARRAY
7170: PPUSH
7171: CALL_OW 13
7175: IFFALSE 7282
// begin uc_side := 8 ;
7177: LD_ADDR_OWVAR 20
7181: PUSH
7182: LD_INT 8
7184: ST_TO_ADDR
// uc_nation := 1 ;
7185: LD_ADDR_OWVAR 21
7189: PUSH
7190: LD_INT 1
7192: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7193: LD_ADDR_OWVAR 37
7197: PUSH
7198: LD_INT 4
7200: ST_TO_ADDR
// vc_control := control_computer ;
7201: LD_ADDR_OWVAR 38
7205: PUSH
7206: LD_INT 3
7208: ST_TO_ADDR
// vc_engine := engine_combustion ;
7209: LD_ADDR_OWVAR 39
7213: PUSH
7214: LD_INT 1
7216: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7217: LD_ADDR_OWVAR 40
7221: PUSH
7222: LD_INT 14
7224: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7225: LD_ADDR_OWVAR 41
7229: PUSH
7230: LD_INT 70
7232: ST_TO_ADDR
// un := CreateVehicle ;
7233: LD_ADDR_VAR 0 5
7237: PUSH
7238: CALL_OW 45
7242: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7243: LD_VAR 0 5
7247: PPUSH
7248: LD_VAR 0 1
7252: PPUSH
7253: LD_INT 0
7255: PPUSH
7256: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7260: LD_VAR 0 5
7264: PPUSH
7265: LD_INT 65
7267: PPUSH
7268: LD_INT 9
7270: PPUSH
7271: CALL_OW 111
// Wait ( 0 0$02 ) ;
7275: LD_INT 70
7277: PPUSH
7278: CALL_OW 67
// end ; alfa_support := true ;
7282: LD_ADDR_EXP 12
7286: PUSH
7287: LD_INT 1
7289: ST_TO_ADDR
// end ;
7290: LD_VAR 0 3
7294: RET
// every 0 0$01 trigger tick mod [ 21 21$00 , 16 16$00 , 12 12$00 ] [ Difficulty ] = 0 do
7295: LD_OWVAR 1
7299: PUSH
7300: LD_INT 44100
7302: PUSH
7303: LD_INT 33600
7305: PUSH
7306: LD_INT 25200
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: LD_OWVAR 67
7318: ARRAY
7319: MOD
7320: PUSH
7321: LD_INT 0
7323: EQUAL
7324: IFFALSE 7384
7326: GO 7328
7328: DISABLE
// begin enable ;
7329: ENABLE
// SayRadio ( Popov , DR5 ) ;
7330: LD_EXP 24
7334: PPUSH
7335: LD_STRING DR5
7337: PPUSH
7338: CALL_OW 94
// Wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7342: LD_INT 1050
7344: PPUSH
7345: LD_INT 4200
7347: PPUSH
7348: CALL_OW 12
7352: PPUSH
7353: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7357: LD_INT 20
7359: PPUSH
7360: LD_INT 5
7362: PUSH
7363: LD_INT 6
7365: PUSH
7366: LD_INT 7
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: LIST
7373: PUSH
7374: LD_OWVAR 67
7378: ARRAY
7379: PPUSH
7380: CALL 6895 0 2
// end ; end_of_file
7384: END
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7385: LD_INT 0
7387: PPUSH
7388: PPUSH
7389: PPUSH
7390: PPUSH
7391: PPUSH
7392: PPUSH
7393: PPUSH
7394: PPUSH
// if unit then
7395: LD_VAR 0 1
7399: IFFALSE 7799
// begin if mode = 0 then
7401: LD_VAR 0 3
7405: PUSH
7406: LD_INT 0
7408: EQUAL
7409: IFFALSE 7557
// begin if coords then
7411: LD_VAR 0 2
7415: IFFALSE 7555
// while ( coords > 1 ) do
7417: LD_VAR 0 2
7421: PUSH
7422: LD_INT 1
7424: GREATER
7425: IFFALSE 7555
// if not HasTask ( unit ) then
7427: LD_VAR 0 1
7431: PPUSH
7432: CALL_OW 314
7436: NOT
7437: IFFALSE 7553
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7439: LD_VAR 0 1
7443: PPUSH
7444: LD_VAR 0 2
7448: PUSH
7449: LD_INT 1
7451: ARRAY
7452: PPUSH
7453: LD_VAR 0 2
7457: PUSH
7458: LD_INT 2
7460: ARRAY
7461: PPUSH
7462: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7466: LD_INT 35
7468: PPUSH
7469: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7473: LD_VAR 0 1
7477: PPUSH
7478: CALL_OW 250
7482: PUSH
7483: LD_VAR 0 2
7487: PUSH
7488: LD_INT 1
7490: ARRAY
7491: EQUAL
7492: PUSH
7493: LD_VAR 0 1
7497: PPUSH
7498: CALL_OW 251
7502: PUSH
7503: LD_VAR 0 2
7507: PUSH
7508: LD_INT 2
7510: ARRAY
7511: EQUAL
7512: AND
7513: IFFALSE 7466
// for i = 1 to 2 do
7515: LD_ADDR_VAR 0 5
7519: PUSH
7520: DOUBLE
7521: LD_INT 1
7523: DEC
7524: ST_TO_ADDR
7525: LD_INT 2
7527: PUSH
7528: FOR_TO
7529: IFFALSE 7551
// coords := Delete ( coords , 1 ) ;
7531: LD_ADDR_VAR 0 2
7535: PUSH
7536: LD_VAR 0 2
7540: PPUSH
7541: LD_INT 1
7543: PPUSH
7544: CALL_OW 3
7548: ST_TO_ADDR
7549: GO 7528
7551: POP
7552: POP
// end ;
7553: GO 7417
// end else
7555: GO 7799
// begin if coords then
7557: LD_VAR 0 2
7561: IFFALSE 7799
// begin x := GetX ( unit ) ;
7563: LD_ADDR_VAR 0 6
7567: PUSH
7568: LD_VAR 0 1
7572: PPUSH
7573: CALL_OW 250
7577: ST_TO_ADDR
// y := GetY ( unit ) ;
7578: LD_ADDR_VAR 0 7
7582: PUSH
7583: LD_VAR 0 1
7587: PPUSH
7588: CALL_OW 251
7592: ST_TO_ADDR
// while ( coords > 1 ) do
7593: LD_VAR 0 2
7597: PUSH
7598: LD_INT 1
7600: GREATER
7601: IFFALSE 7799
// begin Wait ( 0 0$0.3 ) ;
7603: LD_INT 10
7605: PPUSH
7606: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
7610: LD_VAR 0 1
7614: PPUSH
7615: CALL_OW 255
7619: PPUSH
7620: LD_VAR 0 1
7624: PPUSH
7625: CALL_OW 250
7629: PPUSH
7630: LD_VAR 0 1
7634: PPUSH
7635: CALL_OW 251
7639: PPUSH
7640: LD_INT 14
7642: PPUSH
7643: CALL 22137 0 4
7647: IFFALSE 7678
// begin ComMoveXY ( unit , x , y ) ;
7649: LD_VAR 0 1
7653: PPUSH
7654: LD_VAR 0 6
7658: PPUSH
7659: LD_VAR 0 7
7663: PPUSH
7664: CALL_OW 111
// result := false ;
7668: LD_ADDR_VAR 0 4
7672: PUSH
7673: LD_INT 0
7675: ST_TO_ADDR
// end else
7676: GO 7717
// if not HasTask ( unit ) then
7678: LD_VAR 0 1
7682: PPUSH
7683: CALL_OW 314
7687: NOT
7688: IFFALSE 7717
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7690: LD_VAR 0 1
7694: PPUSH
7695: LD_VAR 0 2
7699: PUSH
7700: LD_INT 1
7702: ARRAY
7703: PPUSH
7704: LD_VAR 0 2
7708: PUSH
7709: LD_INT 2
7711: ARRAY
7712: PPUSH
7713: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
7717: LD_VAR 0 1
7721: PPUSH
7722: CALL_OW 250
7726: PUSH
7727: LD_VAR 0 2
7731: PUSH
7732: LD_INT 1
7734: ARRAY
7735: EQUAL
7736: PUSH
7737: LD_VAR 0 1
7741: PPUSH
7742: CALL_OW 251
7746: PUSH
7747: LD_VAR 0 2
7751: PUSH
7752: LD_INT 2
7754: ARRAY
7755: EQUAL
7756: AND
7757: IFFALSE 7797
// for i = 1 to 2 do
7759: LD_ADDR_VAR 0 5
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: LD_INT 2
7771: PUSH
7772: FOR_TO
7773: IFFALSE 7795
// coords := Delete ( coords , 1 ) ;
7775: LD_ADDR_VAR 0 2
7779: PUSH
7780: LD_VAR 0 2
7784: PPUSH
7785: LD_INT 1
7787: PPUSH
7788: CALL_OW 3
7792: ST_TO_ADDR
7793: GO 7772
7795: POP
7796: POP
// end ;
7797: GO 7593
// end ; end ; end ; result := true ;
7799: LD_ADDR_VAR 0 4
7803: PUSH
7804: LD_INT 1
7806: ST_TO_ADDR
// end ;
7807: LD_VAR 0 4
7811: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
7812: LD_INT 0
7814: PPUSH
7815: PPUSH
7816: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
7817: LD_ADDR_VAR 0 5
7821: PUSH
7822: LD_INT 81
7824: PUSH
7825: LD_VAR 0 1
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: ST_TO_ADDR
// for i in units do
7839: LD_ADDR_VAR 0 4
7843: PUSH
7844: LD_VAR 0 2
7848: PUSH
7849: FOR_IN
7850: IFFALSE 7878
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
7852: LD_VAR 0 4
7856: PPUSH
7857: LD_VAR 0 5
7861: PPUSH
7862: LD_VAR 0 4
7866: PPUSH
7867: CALL_OW 74
7871: PPUSH
7872: CALL_OW 115
// end ;
7876: GO 7849
7878: POP
7879: POP
// end ;
7880: LD_VAR 0 3
7884: RET
// export function MC_Show ( string ) ; begin
7885: LD_INT 0
7887: PPUSH
// display_strings := string ;
7888: LD_ADDR_OWVAR 47
7892: PUSH
7893: LD_VAR 0 1
7897: ST_TO_ADDR
// end ; end_of_file
7898: LD_VAR 0 2
7902: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
7907: PPUSH
7908: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
7909: LD_ADDR_VAR 0 8
7913: PUSH
7914: LD_VAR 0 1
7918: PPUSH
7919: LD_INT 2
7921: PPUSH
7922: EMPTY
7923: PPUSH
7924: CALL 11050 0 3
7928: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
7929: LD_VAR 0 8
7933: PUSH
7934: LD_VAR 0 2
7938: PPUSH
7939: LD_VAR 0 3
7943: PPUSH
7944: CALL_OW 428
7948: PUSH
7949: LD_INT 0
7951: EQUAL
7952: AND
7953: IFFALSE 8027
// for i = 1 to plist do
7955: LD_ADDR_VAR 0 6
7959: PUSH
7960: DOUBLE
7961: LD_INT 1
7963: DEC
7964: ST_TO_ADDR
7965: LD_VAR 0 8
7969: PUSH
7970: FOR_TO
7971: IFFALSE 8025
// if NotTask ( plist [ i ] ) then
7973: LD_VAR 0 8
7977: PUSH
7978: LD_VAR 0 6
7982: ARRAY
7983: PPUSH
7984: CALL 31120 0 1
7988: IFFALSE 8023
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
7990: LD_VAR 0 8
7994: PUSH
7995: LD_VAR 0 6
7999: ARRAY
8000: PPUSH
8001: LD_INT 0
8003: PPUSH
8004: LD_VAR 0 2
8008: PPUSH
8009: LD_VAR 0 3
8013: PPUSH
8014: LD_VAR 0 4
8018: PPUSH
8019: CALL_OW 145
// end ;
8023: GO 7970
8025: POP
8026: POP
// end ;
8027: LD_VAR 0 5
8031: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8032: LD_INT 0
8034: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8035: LD_VAR 0 1
8039: PPUSH
8040: LD_INT 6
8042: PPUSH
8043: LD_VAR 0 2
8047: PPUSH
8048: LD_VAR 0 3
8052: PPUSH
8053: LD_VAR 0 4
8057: PPUSH
8058: CALL 9536 0 5
// end ;
8062: LD_VAR 0 5
8066: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8067: LD_INT 0
8069: PPUSH
8070: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8071: LD_ADDR_VAR 0 4
8075: PUSH
8076: LD_INT 22
8078: PUSH
8079: LD_VAR 0 1
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 2
8090: PUSH
8091: LD_INT 30
8093: PUSH
8094: LD_INT 0
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PUSH
8101: LD_INT 30
8103: PUSH
8104: LD_INT 1
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: EMPTY
8121: LIST
8122: PPUSH
8123: CALL_OW 69
8127: PPUSH
8128: LD_VAR 0 2
8132: PPUSH
8133: CALL_OW 250
8137: PPUSH
8138: LD_VAR 0 2
8142: PPUSH
8143: CALL_OW 251
8147: PPUSH
8148: CALL_OW 73
8152: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8153: LD_VAR 0 4
8157: PPUSH
8158: LD_VAR 0 2
8162: PPUSH
8163: CALL 9825 0 2
8167: IFFALSE 8226
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8169: LD_VAR 0 1
8173: PPUSH
8174: LD_INT 30
8176: PUSH
8177: LD_VAR 0 2
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL 10967 0 2
8190: PUSH
8191: LD_INT 1
8193: ARRAY
8194: PPUSH
8195: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8199: LD_ADDR_EXP 43
8203: PUSH
8204: LD_EXP 43
8208: PPUSH
8209: LD_VAR 0 1
8213: PPUSH
8214: LD_VAR 0 2
8218: PPUSH
8219: EMPTY
8220: PPUSH
8221: CALL 39804 0 4
8225: ST_TO_ADDR
// end ; end ;
8226: LD_VAR 0 3
8230: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8231: LD_INT 0
8233: PPUSH
8234: PPUSH
8235: PPUSH
8236: PPUSH
8237: PPUSH
8238: PPUSH
// result := false ;
8239: LD_ADDR_VAR 0 4
8243: PUSH
8244: LD_INT 0
8246: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8247: LD_VAR 0 1
8251: PPUSH
8252: LD_EXP 35
8256: PPUSH
8257: CALL 40752 0 2
8261: IFFALSE 8474
// for i = 1 to MREG_LabList do
8263: LD_ADDR_VAR 0 5
8267: PUSH
8268: DOUBLE
8269: LD_INT 1
8271: DEC
8272: ST_TO_ADDR
8273: LD_EXP 35
8277: PUSH
8278: FOR_TO
8279: IFFALSE 8472
// begin if MREG_LabList [ i ] [ 1 ] = side then
8281: LD_EXP 35
8285: PUSH
8286: LD_VAR 0 5
8290: ARRAY
8291: PUSH
8292: LD_INT 1
8294: ARRAY
8295: PUSH
8296: LD_VAR 0 1
8300: EQUAL
8301: IFFALSE 8470
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8303: LD_ADDR_VAR 0 7
8307: PUSH
8308: LD_EXP 35
8312: PUSH
8313: LD_VAR 0 5
8317: ARRAY
8318: PUSH
8319: LD_INT 2
8321: ARRAY
8322: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8323: LD_ADDR_VAR 0 9
8327: PUSH
8328: LD_INT 22
8330: PUSH
8331: LD_VAR 0 1
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: PUSH
8340: LD_INT 2
8342: PUSH
8343: LD_INT 30
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: PUSH
8353: LD_INT 30
8355: PUSH
8356: LD_INT 1
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: LIST
8367: PUSH
8368: EMPTY
8369: LIST
8370: LIST
8371: PUSH
8372: EMPTY
8373: LIST
8374: PPUSH
8375: CALL_OW 69
8379: PPUSH
8380: LD_VAR 0 7
8384: PPUSH
8385: CALL_OW 250
8389: PPUSH
8390: LD_VAR 0 7
8394: PPUSH
8395: CALL_OW 251
8399: PPUSH
8400: CALL_OW 73
8404: ST_TO_ADDR
// if dep then
8405: LD_VAR 0 9
8409: IFFALSE 8468
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8411: LD_VAR 0 9
8415: PPUSH
8416: LD_VAR 0 2
8420: PPUSH
8421: LD_VAR 0 3
8425: PPUSH
8426: CALL 9941 0 3
8430: IFFALSE 8468
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8432: LD_VAR 0 7
8436: PPUSH
8437: LD_VAR 0 2
8441: PPUSH
8442: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8446: LD_VAR 0 7
8450: PPUSH
8451: LD_VAR 0 3
8455: PPUSH
8456: CALL_OW 207
// result := true ;
8460: LD_ADDR_VAR 0 4
8464: PUSH
8465: LD_INT 1
8467: ST_TO_ADDR
// end ; end ; break ;
8468: GO 8472
// end ; end ;
8470: GO 8278
8472: POP
8473: POP
// end ;
8474: LD_VAR 0 4
8478: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8479: LD_INT 0
8481: PPUSH
8482: PPUSH
8483: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8484: LD_ADDR_VAR 0 7
8488: PUSH
8489: LD_VAR 0 2
8493: PPUSH
8494: LD_VAR 0 3
8498: PPUSH
8499: LD_VAR 0 4
8503: PPUSH
8504: CALL 8666 0 3
8508: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8509: LD_ADDR_EXP 41
8513: PUSH
8514: LD_EXP 41
8518: PPUSH
8519: LD_VAR 0 1
8523: PPUSH
8524: LD_INT 2
8526: PPUSH
8527: LD_VAR 0 2
8531: PUSH
8532: LD_VAR 0 3
8536: PUSH
8537: LD_VAR 0 4
8541: PUSH
8542: EMPTY
8543: LIST
8544: LIST
8545: LIST
8546: PPUSH
8547: CALL 39713 0 4
8551: ST_TO_ADDR
// if ext_list then
8552: LD_VAR 0 5
8556: IFFALSE 8661
// for i = 1 to ext_list do
8558: LD_ADDR_VAR 0 8
8562: PUSH
8563: DOUBLE
8564: LD_INT 1
8566: DEC
8567: ST_TO_ADDR
8568: LD_VAR 0 5
8572: PUSH
8573: FOR_TO
8574: IFFALSE 8659
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
8576: LD_ADDR_EXP 41
8580: PUSH
8581: LD_EXP 41
8585: PPUSH
8586: LD_VAR 0 1
8590: PPUSH
8591: LD_VAR 0 5
8595: PUSH
8596: LD_VAR 0 8
8600: ARRAY
8601: PPUSH
8602: LD_VAR 0 7
8606: PUSH
8607: LD_VAR 0 8
8611: ARRAY
8612: PUSH
8613: LD_INT 1
8615: ARRAY
8616: PUSH
8617: LD_VAR 0 7
8621: PUSH
8622: LD_VAR 0 8
8626: ARRAY
8627: PUSH
8628: LD_INT 2
8630: ARRAY
8631: PUSH
8632: LD_VAR 0 7
8636: PUSH
8637: LD_VAR 0 8
8641: ARRAY
8642: PUSH
8643: LD_INT 3
8645: ARRAY
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: LIST
8651: PPUSH
8652: CALL 39713 0 4
8656: ST_TO_ADDR
8657: GO 8573
8659: POP
8660: POP
// end ;
8661: LD_VAR 0 6
8665: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
8666: LD_INT 0
8668: PPUSH
8669: PPUSH
// list := [ ] ;
8670: LD_ADDR_VAR 0 5
8674: PUSH
8675: EMPTY
8676: ST_TO_ADDR
// case d of 0 :
8677: LD_VAR 0 3
8681: PUSH
8682: LD_INT 0
8684: DOUBLE
8685: EQUAL
8686: IFTRUE 8690
8688: GO 8823
8690: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_VAR 0 1
8700: PUSH
8701: LD_INT 4
8703: MINUS
8704: PUSH
8705: LD_VAR 0 2
8709: PUSH
8710: LD_INT 4
8712: MINUS
8713: PUSH
8714: LD_INT 2
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_VAR 0 1
8726: PUSH
8727: LD_INT 3
8729: MINUS
8730: PUSH
8731: LD_VAR 0 2
8735: PUSH
8736: LD_INT 1
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_VAR 0 1
8748: PUSH
8749: LD_INT 4
8751: PLUS
8752: PUSH
8753: LD_VAR 0 2
8757: PUSH
8758: LD_INT 4
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: PUSH
8766: LD_VAR 0 1
8770: PUSH
8771: LD_INT 3
8773: PLUS
8774: PUSH
8775: LD_VAR 0 2
8779: PUSH
8780: LD_INT 3
8782: PLUS
8783: PUSH
8784: LD_INT 5
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: LIST
8791: PUSH
8792: LD_VAR 0 1
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: LD_INT 4
8804: PLUS
8805: PUSH
8806: LD_INT 0
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: LIST
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: ST_TO_ADDR
// end ; 1 :
8821: GO 9521
8823: LD_INT 1
8825: DOUBLE
8826: EQUAL
8827: IFTRUE 8831
8829: GO 8964
8831: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
8832: LD_ADDR_VAR 0 5
8836: PUSH
8837: LD_VAR 0 1
8841: PUSH
8842: LD_VAR 0 2
8846: PUSH
8847: LD_INT 4
8849: MINUS
8850: PUSH
8851: LD_INT 3
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: LIST
8858: PUSH
8859: LD_VAR 0 1
8863: PUSH
8864: LD_INT 3
8866: MINUS
8867: PUSH
8868: LD_VAR 0 2
8872: PUSH
8873: LD_INT 3
8875: MINUS
8876: PUSH
8877: LD_INT 2
8879: PUSH
8880: EMPTY
8881: LIST
8882: LIST
8883: LIST
8884: PUSH
8885: LD_VAR 0 1
8889: PUSH
8890: LD_INT 4
8892: MINUS
8893: PUSH
8894: LD_VAR 0 2
8898: PUSH
8899: LD_INT 1
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: LIST
8906: PUSH
8907: LD_VAR 0 1
8911: PUSH
8912: LD_VAR 0 2
8916: PUSH
8917: LD_INT 3
8919: PLUS
8920: PUSH
8921: LD_INT 0
8923: PUSH
8924: EMPTY
8925: LIST
8926: LIST
8927: LIST
8928: PUSH
8929: LD_VAR 0 1
8933: PUSH
8934: LD_INT 4
8936: PLUS
8937: PUSH
8938: LD_VAR 0 2
8942: PUSH
8943: LD_INT 4
8945: PLUS
8946: PUSH
8947: LD_INT 5
8949: PUSH
8950: EMPTY
8951: LIST
8952: LIST
8953: LIST
8954: PUSH
8955: EMPTY
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: ST_TO_ADDR
// end ; 2 :
8962: GO 9521
8964: LD_INT 2
8966: DOUBLE
8967: EQUAL
8968: IFTRUE 8972
8970: GO 9101
8972: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
8973: LD_ADDR_VAR 0 5
8977: PUSH
8978: LD_VAR 0 1
8982: PUSH
8983: LD_VAR 0 2
8987: PUSH
8988: LD_INT 3
8990: MINUS
8991: PUSH
8992: LD_INT 3
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: LIST
8999: PUSH
9000: LD_VAR 0 1
9004: PUSH
9005: LD_INT 4
9007: PLUS
9008: PUSH
9009: LD_VAR 0 2
9013: PUSH
9014: LD_INT 4
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: LIST
9021: PUSH
9022: LD_VAR 0 1
9026: PUSH
9027: LD_VAR 0 2
9031: PUSH
9032: LD_INT 4
9034: PLUS
9035: PUSH
9036: LD_INT 0
9038: PUSH
9039: EMPTY
9040: LIST
9041: LIST
9042: LIST
9043: PUSH
9044: LD_VAR 0 1
9048: PUSH
9049: LD_INT 3
9051: MINUS
9052: PUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 1
9060: PUSH
9061: EMPTY
9062: LIST
9063: LIST
9064: LIST
9065: PUSH
9066: LD_VAR 0 1
9070: PUSH
9071: LD_INT 4
9073: MINUS
9074: PUSH
9075: LD_VAR 0 2
9079: PUSH
9080: LD_INT 4
9082: MINUS
9083: PUSH
9084: LD_INT 2
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: LIST
9096: LIST
9097: LIST
9098: ST_TO_ADDR
// end ; 3 :
9099: GO 9521
9101: LD_INT 3
9103: DOUBLE
9104: EQUAL
9105: IFTRUE 9109
9107: GO 9242
9109: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9110: LD_ADDR_VAR 0 5
9114: PUSH
9115: LD_VAR 0 1
9119: PUSH
9120: LD_INT 3
9122: PLUS
9123: PUSH
9124: LD_VAR 0 2
9128: PUSH
9129: LD_INT 4
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: LIST
9136: PUSH
9137: LD_VAR 0 1
9141: PUSH
9142: LD_INT 4
9144: PLUS
9145: PUSH
9146: LD_VAR 0 2
9150: PUSH
9151: LD_INT 4
9153: PLUS
9154: PUSH
9155: LD_INT 5
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_VAR 0 1
9167: PUSH
9168: LD_INT 4
9170: MINUS
9171: PUSH
9172: LD_VAR 0 2
9176: PUSH
9177: LD_INT 1
9179: PUSH
9180: EMPTY
9181: LIST
9182: LIST
9183: LIST
9184: PUSH
9185: LD_VAR 0 1
9189: PUSH
9190: LD_VAR 0 2
9194: PUSH
9195: LD_INT 4
9197: MINUS
9198: PUSH
9199: LD_INT 3
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: LIST
9206: PUSH
9207: LD_VAR 0 1
9211: PUSH
9212: LD_INT 3
9214: MINUS
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MINUS
9224: PUSH
9225: LD_INT 2
9227: PUSH
9228: EMPTY
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: ST_TO_ADDR
// end ; 4 :
9240: GO 9521
9242: LD_INT 4
9244: DOUBLE
9245: EQUAL
9246: IFTRUE 9250
9248: GO 9383
9250: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9251: LD_ADDR_VAR 0 5
9255: PUSH
9256: LD_VAR 0 1
9260: PUSH
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 4
9268: PLUS
9269: PUSH
9270: LD_INT 0
9272: PUSH
9273: EMPTY
9274: LIST
9275: LIST
9276: LIST
9277: PUSH
9278: LD_VAR 0 1
9282: PUSH
9283: LD_INT 3
9285: PLUS
9286: PUSH
9287: LD_VAR 0 2
9291: PUSH
9292: LD_INT 3
9294: PLUS
9295: PUSH
9296: LD_INT 5
9298: PUSH
9299: EMPTY
9300: LIST
9301: LIST
9302: LIST
9303: PUSH
9304: LD_VAR 0 1
9308: PUSH
9309: LD_INT 3
9311: PLUS
9312: PUSH
9313: LD_VAR 0 2
9317: PUSH
9318: LD_INT 4
9320: PUSH
9321: EMPTY
9322: LIST
9323: LIST
9324: LIST
9325: PUSH
9326: LD_VAR 0 1
9330: PUSH
9331: LD_VAR 0 2
9335: PUSH
9336: LD_INT 3
9338: MINUS
9339: PUSH
9340: LD_INT 3
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: LIST
9347: PUSH
9348: LD_VAR 0 1
9352: PUSH
9353: LD_INT 4
9355: MINUS
9356: PUSH
9357: LD_VAR 0 2
9361: PUSH
9362: LD_INT 4
9364: MINUS
9365: PUSH
9366: LD_INT 2
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: LIST
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: ST_TO_ADDR
// end ; 5 :
9381: GO 9521
9383: LD_INT 5
9385: DOUBLE
9386: EQUAL
9387: IFTRUE 9391
9389: GO 9520
9391: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9392: LD_ADDR_VAR 0 5
9396: PUSH
9397: LD_VAR 0 1
9401: PUSH
9402: LD_INT 4
9404: MINUS
9405: PUSH
9406: LD_VAR 0 2
9410: PUSH
9411: LD_INT 1
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: LIST
9418: PUSH
9419: LD_VAR 0 1
9423: PUSH
9424: LD_VAR 0 2
9428: PUSH
9429: LD_INT 4
9431: MINUS
9432: PUSH
9433: LD_INT 3
9435: PUSH
9436: EMPTY
9437: LIST
9438: LIST
9439: LIST
9440: PUSH
9441: LD_VAR 0 1
9445: PUSH
9446: LD_INT 4
9448: PLUS
9449: PUSH
9450: LD_VAR 0 2
9454: PUSH
9455: LD_INT 4
9457: PLUS
9458: PUSH
9459: LD_INT 5
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: LIST
9466: PUSH
9467: LD_VAR 0 1
9471: PUSH
9472: LD_INT 3
9474: PLUS
9475: PUSH
9476: LD_VAR 0 2
9480: PUSH
9481: LD_INT 4
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: LIST
9488: PUSH
9489: LD_VAR 0 1
9493: PUSH
9494: LD_VAR 0 2
9498: PUSH
9499: LD_INT 3
9501: PLUS
9502: PUSH
9503: LD_INT 0
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: LIST
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: ST_TO_ADDR
// end ; end ;
9518: GO 9521
9520: POP
// result := list ;
9521: LD_ADDR_VAR 0 4
9525: PUSH
9526: LD_VAR 0 5
9530: ST_TO_ADDR
// end ;
9531: LD_VAR 0 4
9535: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9536: LD_INT 0
9538: PPUSH
9539: PPUSH
9540: PPUSH
9541: PPUSH
9542: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9543: LD_ADDR_VAR 0 10
9547: PUSH
9548: LD_VAR 0 1
9552: PPUSH
9553: LD_INT 2
9555: PPUSH
9556: EMPTY
9557: PPUSH
9558: CALL 11050 0 3
9562: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
9563: LD_ADDR_VAR 0 9
9567: PUSH
9568: LD_INT 22
9570: PUSH
9571: LD_VAR 0 1
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 2
9582: PUSH
9583: LD_INT 30
9585: PUSH
9586: LD_INT 0
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: PUSH
9593: LD_INT 30
9595: PUSH
9596: LD_INT 1
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: LIST
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: PUSH
9612: EMPTY
9613: LIST
9614: PPUSH
9615: CALL_OW 69
9619: PPUSH
9620: LD_VAR 0 3
9624: PPUSH
9625: LD_VAR 0 4
9629: PPUSH
9630: CALL_OW 73
9634: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
9635: LD_ADDR_VAR 0 8
9639: PUSH
9640: LD_VAR 0 9
9644: PPUSH
9645: LD_VAR 0 2
9649: PPUSH
9650: CALL 9825 0 2
9654: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
9655: LD_VAR 0 10
9659: PUSH
9660: LD_VAR 0 8
9664: AND
9665: PUSH
9666: LD_VAR 0 9
9670: PPUSH
9671: LD_VAR 0 3
9675: PPUSH
9676: LD_VAR 0 4
9680: PPUSH
9681: CALL_OW 297
9685: PUSH
9686: LD_INT 26
9688: LESSEQUAL
9689: AND
9690: PUSH
9691: LD_VAR 0 3
9695: PPUSH
9696: LD_VAR 0 4
9700: PPUSH
9701: CALL_OW 428
9705: PUSH
9706: LD_INT 0
9708: EQUAL
9709: AND
9710: IFFALSE 9820
// for i = 1 to plist do
9712: LD_ADDR_VAR 0 7
9716: PUSH
9717: DOUBLE
9718: LD_INT 1
9720: DEC
9721: ST_TO_ADDR
9722: LD_VAR 0 10
9726: PUSH
9727: FOR_TO
9728: IFFALSE 9818
// if IsInUnit ( plist [ i ] ) then
9730: LD_VAR 0 10
9734: PUSH
9735: LD_VAR 0 7
9739: ARRAY
9740: PPUSH
9741: CALL_OW 310
9745: IFFALSE 9764
// ComExitBuilding ( plist [ i ] ) else
9747: LD_VAR 0 10
9751: PUSH
9752: LD_VAR 0 7
9756: ARRAY
9757: PPUSH
9758: CALL_OW 122
9762: GO 9816
// if NotTask ( plist [ i ] ) then
9764: LD_VAR 0 10
9768: PUSH
9769: LD_VAR 0 7
9773: ARRAY
9774: PPUSH
9775: CALL 31120 0 1
9779: IFFALSE 9816
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
9781: LD_VAR 0 10
9785: PUSH
9786: LD_VAR 0 7
9790: ARRAY
9791: PPUSH
9792: LD_VAR 0 2
9796: PPUSH
9797: LD_VAR 0 3
9801: PPUSH
9802: LD_VAR 0 4
9806: PPUSH
9807: LD_VAR 0 5
9811: PPUSH
9812: CALL_OW 145
// end ;
9816: GO 9727
9818: POP
9819: POP
// end ;
9820: LD_VAR 0 6
9824: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
9825: LD_INT 0
9827: PPUSH
9828: PPUSH
9829: PPUSH
// pom := GetBase ( bdepot ) ;
9830: LD_ADDR_VAR 0 4
9834: PUSH
9835: LD_VAR 0 1
9839: PPUSH
9840: CALL_OW 274
9844: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_VAR 0 2
9854: PPUSH
9855: LD_VAR 0 1
9859: PPUSH
9860: CALL_OW 248
9864: PPUSH
9865: CALL_OW 450
9869: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
9870: LD_VAR 0 4
9874: PPUSH
9875: LD_INT 1
9877: PPUSH
9878: CALL_OW 275
9882: PUSH
9883: LD_VAR 0 5
9887: PUSH
9888: LD_INT 1
9890: ARRAY
9891: GREATEREQUAL
9892: PUSH
9893: LD_VAR 0 4
9897: PPUSH
9898: LD_INT 3
9900: PPUSH
9901: CALL_OW 275
9905: PUSH
9906: LD_VAR 0 5
9910: PUSH
9911: LD_INT 3
9913: ARRAY
9914: GREATEREQUAL
9915: AND
9916: IFFALSE 9928
// result := true else
9918: LD_ADDR_VAR 0 3
9922: PUSH
9923: LD_INT 1
9925: ST_TO_ADDR
9926: GO 9936
// result := false ;
9928: LD_ADDR_VAR 0 3
9932: PUSH
9933: LD_INT 0
9935: ST_TO_ADDR
// end ;
9936: LD_VAR 0 3
9940: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
9941: LD_INT 0
9943: PPUSH
9944: PPUSH
9945: PPUSH
9946: PPUSH
9947: PPUSH
// pom := GetBase ( bdepot ) ;
9948: LD_ADDR_VAR 0 5
9952: PUSH
9953: LD_VAR 0 1
9957: PPUSH
9958: CALL_OW 274
9962: ST_TO_ADDR
// cost := [ ] ;
9963: LD_ADDR_VAR 0 8
9967: PUSH
9968: EMPTY
9969: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
9970: LD_ADDR_VAR 0 6
9974: PUSH
9975: LD_VAR 0 2
9979: PPUSH
9980: LD_VAR 0 1
9984: PPUSH
9985: CALL_OW 248
9989: PPUSH
9990: CALL_OW 450
9994: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
9995: LD_ADDR_VAR 0 7
9999: PUSH
10000: LD_VAR 0 3
10004: PPUSH
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 248
10014: PPUSH
10015: CALL_OW 450
10019: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10020: LD_ADDR_VAR 0 8
10024: PUSH
10025: LD_VAR 0 8
10029: PPUSH
10030: LD_INT 1
10032: PPUSH
10033: LD_VAR 0 6
10037: PUSH
10038: LD_INT 1
10040: ARRAY
10041: PUSH
10042: LD_VAR 0 7
10046: PUSH
10047: LD_INT 1
10049: ARRAY
10050: PLUS
10051: PPUSH
10052: CALL_OW 1
10056: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10057: LD_ADDR_VAR 0 8
10061: PUSH
10062: LD_VAR 0 8
10066: PPUSH
10067: LD_INT 2
10069: PPUSH
10070: LD_VAR 0 6
10074: PUSH
10075: LD_INT 2
10077: ARRAY
10078: PUSH
10079: LD_VAR 0 7
10083: PUSH
10084: LD_INT 2
10086: ARRAY
10087: PLUS
10088: PPUSH
10089: CALL_OW 1
10093: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10094: LD_ADDR_VAR 0 8
10098: PUSH
10099: LD_VAR 0 8
10103: PPUSH
10104: LD_INT 3
10106: PPUSH
10107: LD_VAR 0 6
10111: PUSH
10112: LD_INT 3
10114: ARRAY
10115: PUSH
10116: LD_VAR 0 7
10120: PUSH
10121: LD_INT 3
10123: ARRAY
10124: PLUS
10125: PPUSH
10126: CALL_OW 1
10130: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10131: LD_VAR 0 5
10135: PPUSH
10136: LD_INT 1
10138: PPUSH
10139: CALL_OW 275
10143: PUSH
10144: LD_VAR 0 8
10148: PUSH
10149: LD_INT 1
10151: ARRAY
10152: GREATEREQUAL
10153: PUSH
10154: LD_VAR 0 5
10158: PPUSH
10159: LD_INT 3
10161: PPUSH
10162: CALL_OW 275
10166: PUSH
10167: LD_VAR 0 8
10171: PUSH
10172: LD_INT 3
10174: ARRAY
10175: GREATEREQUAL
10176: AND
10177: IFFALSE 10189
// result := true else
10179: LD_ADDR_VAR 0 4
10183: PUSH
10184: LD_INT 1
10186: ST_TO_ADDR
10187: GO 10197
// result := false ;
10189: LD_ADDR_VAR 0 4
10193: PUSH
10194: LD_INT 0
10196: ST_TO_ADDR
// end ;
10197: LD_VAR 0 4
10201: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10202: LD_INT 0
10204: PPUSH
10205: PPUSH
10206: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10207: LD_ADDR_VAR 0 5
10211: PUSH
10212: LD_VAR 0 1
10216: PPUSH
10217: LD_INT 2
10219: PPUSH
10220: EMPTY
10221: PPUSH
10222: CALL 11050 0 3
10226: ST_TO_ADDR
// if unit and plist then
10227: LD_VAR 0 2
10231: PUSH
10232: LD_VAR 0 5
10236: AND
10237: IFFALSE 10298
// for i = 1 to plist do
10239: LD_ADDR_VAR 0 4
10243: PUSH
10244: DOUBLE
10245: LD_INT 1
10247: DEC
10248: ST_TO_ADDR
10249: LD_VAR 0 5
10253: PUSH
10254: FOR_TO
10255: IFFALSE 10296
// if NotTask ( plist [ i ] ) then
10257: LD_VAR 0 5
10261: PUSH
10262: LD_VAR 0 4
10266: ARRAY
10267: PPUSH
10268: CALL 31120 0 1
10272: IFFALSE 10294
// ComDismantle ( plist [ i ] , unit ) ;
10274: LD_VAR 0 5
10278: PUSH
10279: LD_VAR 0 4
10283: ARRAY
10284: PPUSH
10285: LD_VAR 0 2
10289: PPUSH
10290: CALL_OW 167
10294: GO 10254
10296: POP
10297: POP
// result := true ;
10298: LD_ADDR_VAR 0 3
10302: PUSH
10303: LD_INT 1
10305: ST_TO_ADDR
// end ;
10306: LD_VAR 0 3
10310: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10311: LD_INT 0
10313: PPUSH
10314: PPUSH
10315: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10316: LD_ADDR_VAR 0 5
10320: PUSH
10321: LD_VAR 0 1
10325: PPUSH
10326: LD_INT 2
10328: PPUSH
10329: EMPTY
10330: PPUSH
10331: CALL 11050 0 3
10335: ST_TO_ADDR
// if unit and plist then
10336: LD_VAR 0 2
10340: PUSH
10341: LD_VAR 0 5
10345: AND
10346: IFFALSE 10407
// for i = 1 to plist do
10348: LD_ADDR_VAR 0 4
10352: PUSH
10353: DOUBLE
10354: LD_INT 1
10356: DEC
10357: ST_TO_ADDR
10358: LD_VAR 0 5
10362: PUSH
10363: FOR_TO
10364: IFFALSE 10405
// if NotTask ( plist [ i ] ) then
10366: LD_VAR 0 5
10370: PUSH
10371: LD_VAR 0 4
10375: ARRAY
10376: PPUSH
10377: CALL 31120 0 1
10381: IFFALSE 10403
// ComComplete ( plist [ i ] , unit ) ;
10383: LD_VAR 0 5
10387: PUSH
10388: LD_VAR 0 4
10392: ARRAY
10393: PPUSH
10394: LD_VAR 0 2
10398: PPUSH
10399: CALL 30656 0 2
10403: GO 10363
10405: POP
10406: POP
// result := true ;
10407: LD_ADDR_VAR 0 3
10411: PUSH
10412: LD_INT 1
10414: ST_TO_ADDR
// end ;
10415: LD_VAR 0 3
10419: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10420: LD_INT 0
10422: PPUSH
10423: PPUSH
10424: PPUSH
10425: PPUSH
10426: PPUSH
10427: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10428: LD_ADDR_VAR 0 5
10432: PUSH
10433: LD_INT 22
10435: PUSH
10436: LD_VAR 0 1
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 21
10447: PUSH
10448: LD_INT 3
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PUSH
10455: LD_INT 3
10457: PUSH
10458: LD_INT 57
10460: PUSH
10461: EMPTY
10462: LIST
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 24
10473: PUSH
10474: LD_INT 1000
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: LIST
10489: LIST
10490: PPUSH
10491: CALL_OW 69
10495: ST_TO_ADDR
// r := [ ] ;
10496: LD_ADDR_VAR 0 6
10500: PUSH
10501: EMPTY
10502: ST_TO_ADDR
// if not tmp then
10503: LD_VAR 0 5
10507: NOT
10508: IFFALSE 10514
// exit else
10510: GO 10702
10512: GO 10682
// begin r := [ tmp [ 1 ] ] ;
10514: LD_ADDR_VAR 0 6
10518: PUSH
10519: LD_VAR 0 5
10523: PUSH
10524: LD_INT 1
10526: ARRAY
10527: PUSH
10528: EMPTY
10529: LIST
10530: ST_TO_ADDR
// for i = 2 to tmp do
10531: LD_ADDR_VAR 0 3
10535: PUSH
10536: DOUBLE
10537: LD_INT 2
10539: DEC
10540: ST_TO_ADDR
10541: LD_VAR 0 5
10545: PUSH
10546: FOR_TO
10547: IFFALSE 10680
// begin m := false ;
10549: LD_ADDR_VAR 0 7
10553: PUSH
10554: LD_INT 0
10556: ST_TO_ADDR
// for j = 1 to r do
10557: LD_ADDR_VAR 0 4
10561: PUSH
10562: DOUBLE
10563: LD_INT 1
10565: DEC
10566: ST_TO_ADDR
10567: LD_VAR 0 6
10571: PUSH
10572: FOR_TO
10573: IFFALSE 10647
// if GetLives ( tmp [ i ] ) < r [ j ] then
10575: LD_VAR 0 5
10579: PUSH
10580: LD_VAR 0 3
10584: ARRAY
10585: PPUSH
10586: CALL_OW 256
10590: PUSH
10591: LD_VAR 0 6
10595: PUSH
10596: LD_VAR 0 4
10600: ARRAY
10601: LESS
10602: IFFALSE 10645
// begin r := Insert ( r , j , tmp [ i ] ) ;
10604: LD_ADDR_VAR 0 6
10608: PUSH
10609: LD_VAR 0 6
10613: PPUSH
10614: LD_VAR 0 4
10618: PPUSH
10619: LD_VAR 0 5
10623: PUSH
10624: LD_VAR 0 3
10628: ARRAY
10629: PPUSH
10630: CALL_OW 2
10634: ST_TO_ADDR
// m := true ;
10635: LD_ADDR_VAR 0 7
10639: PUSH
10640: LD_INT 1
10642: ST_TO_ADDR
// break ;
10643: GO 10647
// end ;
10645: GO 10572
10647: POP
10648: POP
// if not m then
10649: LD_VAR 0 7
10653: NOT
10654: IFFALSE 10678
// r := r ^ tmp [ i ] ;
10656: LD_ADDR_VAR 0 6
10660: PUSH
10661: LD_VAR 0 6
10665: PUSH
10666: LD_VAR 0 5
10670: PUSH
10671: LD_VAR 0 3
10675: ARRAY
10676: ADD
10677: ST_TO_ADDR
// end ;
10678: GO 10546
10680: POP
10681: POP
// end ; if r then
10682: LD_VAR 0 6
10686: IFFALSE 10700
// result := r else
10688: LD_ADDR_VAR 0 2
10692: PUSH
10693: LD_VAR 0 6
10697: ST_TO_ADDR
10698: GO 10702
// exit ;
10700: GO 10702
// end ;
10702: LD_VAR 0 2
10706: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
10712: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
10713: LD_ADDR_VAR 0 5
10717: PUSH
10718: LD_INT 22
10720: PUSH
10721: LD_VAR 0 1
10725: PUSH
10726: EMPTY
10727: LIST
10728: LIST
10729: PUSH
10730: LD_INT 2
10732: PUSH
10733: LD_INT 25
10735: PUSH
10736: LD_INT 2
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: LD_INT 25
10745: PUSH
10746: LD_INT 16
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PUSH
10753: LD_INT 34
10755: PUSH
10756: LD_INT 13
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PUSH
10763: LD_INT 34
10765: PUSH
10766: LD_INT 52
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PUSH
10773: EMPTY
10774: LIST
10775: LIST
10776: LIST
10777: LIST
10778: LIST
10779: PUSH
10780: LD_INT 24
10782: PUSH
10783: LD_INT 650
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: LIST
10794: PPUSH
10795: CALL_OW 69
10799: ST_TO_ADDR
// p := 1 ;
10800: LD_ADDR_VAR 0 4
10804: PUSH
10805: LD_INT 1
10807: ST_TO_ADDR
// for i = 1 to repairs do
10808: LD_ADDR_VAR 0 3
10812: PUSH
10813: DOUBLE
10814: LD_INT 1
10816: DEC
10817: ST_TO_ADDR
10818: LD_VAR 0 5
10822: PUSH
10823: FOR_TO
10824: IFFALSE 10960
// begin if IsInUnit ( repairs [ i ] ) then
10826: LD_VAR 0 5
10830: PUSH
10831: LD_VAR 0 3
10835: ARRAY
10836: PPUSH
10837: CALL_OW 310
10841: IFFALSE 10860
// ComExitBuilding ( repairs [ i ] ) else
10843: LD_VAR 0 5
10847: PUSH
10848: LD_VAR 0 3
10852: ARRAY
10853: PPUSH
10854: CALL_OW 122
10858: GO 10958
// if not HasTask ( repairs [ i ] ) then
10860: LD_VAR 0 5
10864: PUSH
10865: LD_VAR 0 3
10869: ARRAY
10870: PPUSH
10871: CALL_OW 314
10875: NOT
10876: IFFALSE 10958
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
10878: LD_VAR 0 5
10882: PUSH
10883: LD_VAR 0 3
10887: ARRAY
10888: PPUSH
10889: LD_EXP 42
10893: PUSH
10894: LD_VAR 0 1
10898: ARRAY
10899: PUSH
10900: LD_VAR 0 4
10904: ARRAY
10905: PPUSH
10906: CALL_OW 130
// if i mod 3 = 0 then
10910: LD_VAR 0 3
10914: PUSH
10915: LD_INT 3
10917: MOD
10918: PUSH
10919: LD_INT 0
10921: EQUAL
10922: IFFALSE 10938
// p := p + 1 ;
10924: LD_ADDR_VAR 0 4
10928: PUSH
10929: LD_VAR 0 4
10933: PUSH
10934: LD_INT 1
10936: PLUS
10937: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
10938: LD_EXP 42
10942: PUSH
10943: LD_VAR 0 1
10947: ARRAY
10948: PUSH
10949: LD_VAR 0 4
10953: LESS
10954: IFFALSE 10958
// break ;
10956: GO 10960
// end ; end ;
10958: GO 10823
10960: POP
10961: POP
// end ; end_of_file
10962: LD_VAR 0 2
10966: RET
// export function MCF_Get ( side , filter ) ; begin
10967: LD_INT 0
10969: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
10970: LD_ADDR_VAR 0 3
10974: PUSH
10975: LD_INT 22
10977: PUSH
10978: LD_VAR 0 1
10982: PUSH
10983: EMPTY
10984: LIST
10985: LIST
10986: PUSH
10987: LD_VAR 0 2
10991: PUSH
10992: EMPTY
10993: LIST
10994: LIST
10995: PPUSH
10996: CALL_OW 69
11000: ST_TO_ADDR
// end ;
11001: LD_VAR 0 3
11005: RET
// export function MCF_Lab ( side ) ; begin
11006: LD_INT 0
11008: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11009: LD_ADDR_VAR 0 2
11013: PUSH
11014: LD_INT 22
11016: PUSH
11017: LD_VAR 0 1
11021: PUSH
11022: EMPTY
11023: LIST
11024: LIST
11025: PUSH
11026: LD_INT 30
11028: PUSH
11029: LD_INT 8
11031: PUSH
11032: EMPTY
11033: LIST
11034: LIST
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: PPUSH
11040: CALL_OW 69
11044: ST_TO_ADDR
// end ;
11045: LD_VAR 0 2
11049: RET
// export function MCF_Class ( side , class , filter ) ; begin
11050: LD_INT 0
11052: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11053: LD_ADDR_VAR 0 4
11057: PUSH
11058: LD_INT 22
11060: PUSH
11061: LD_VAR 0 1
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: PUSH
11070: LD_INT 25
11072: PUSH
11073: LD_VAR 0 2
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: PUSH
11082: LD_VAR 0 3
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: ST_TO_ADDR
// end ;
11097: LD_VAR 0 4
11101: RET
// export function MCF_All ( side , filter ) ; begin
11102: LD_INT 0
11104: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11105: LD_ADDR_VAR 0 3
11109: PUSH
11110: LD_INT 22
11112: PUSH
11113: LD_VAR 0 1
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PUSH
11122: LD_INT 2
11124: PUSH
11125: LD_INT 25
11127: PUSH
11128: LD_INT 1
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 25
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 25
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 25
11157: PUSH
11158: LD_INT 4
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: PUSH
11172: LD_VAR 0 2
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: LIST
11181: PPUSH
11182: CALL_OW 69
11186: ST_TO_ADDR
// end ;
11187: LD_VAR 0 3
11191: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11192: LD_INT 0
11194: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11195: LD_ADDR_VAR 0 4
11199: PUSH
11200: LD_INT 22
11202: PUSH
11203: LD_VAR 0 1
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: LD_INT 92
11214: PUSH
11215: LD_VAR 0 2
11219: PUSH
11220: LD_INT 1
11222: ARRAY
11223: PUSH
11224: LD_VAR 0 2
11228: PUSH
11229: LD_INT 2
11231: ARRAY
11232: PUSH
11233: LD_VAR 0 2
11237: PUSH
11238: LD_INT 3
11240: ARRAY
11241: PUSH
11242: EMPTY
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: PUSH
11248: LD_VAR 0 3
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: LIST
11257: PPUSH
11258: CALL_OW 69
11262: ST_TO_ADDR
// end ;
11263: LD_VAR 0 4
11267: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11268: LD_INT 0
11270: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11271: LD_ADDR_VAR 0 3
11275: PUSH
11276: LD_INT 22
11278: PUSH
11279: LD_VAR 0 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 21
11290: PUSH
11291: LD_INT 2
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: LD_VAR 0 2
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: ST_TO_ADDR
// end ;
11313: LD_VAR 0 3
11317: RET
// export function MCF_Cargo ( side ) ; begin
11318: LD_INT 0
11320: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11321: LD_ADDR_VAR 0 2
11325: PUSH
11326: LD_VAR 0 1
11330: PPUSH
11331: LD_INT 2
11333: PUSH
11334: LD_INT 34
11336: PUSH
11337: LD_INT 12
11339: PUSH
11340: EMPTY
11341: LIST
11342: LIST
11343: PUSH
11344: LD_INT 34
11346: PUSH
11347: LD_INT 32
11349: PUSH
11350: EMPTY
11351: LIST
11352: LIST
11353: PUSH
11354: LD_INT 34
11356: PUSH
11357: LD_INT 51
11359: PUSH
11360: EMPTY
11361: LIST
11362: LIST
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: LIST
11368: LIST
11369: PPUSH
11370: CALL 11268 0 2
11374: ST_TO_ADDR
// end ;
11375: LD_VAR 0 2
11379: RET
// export function MCF_Ape ( side ) ; begin
11380: LD_INT 0
11382: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11383: LD_ADDR_VAR 0 2
11387: PUSH
11388: LD_INT 22
11390: PUSH
11391: LD_VAR 0 1
11395: PUSH
11396: EMPTY
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 2
11402: PUSH
11403: LD_INT 25
11405: PUSH
11406: LD_INT 12
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: PUSH
11413: LD_INT 25
11415: PUSH
11416: LD_INT 15
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 25
11425: PUSH
11426: LD_INT 16
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 17
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: PPUSH
11454: CALL_OW 69
11458: ST_TO_ADDR
// end ;
11459: LD_VAR 0 2
11463: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11464: LD_INT 0
11466: PPUSH
11467: PPUSH
11468: PPUSH
11469: PPUSH
// result := [ ] ;
11470: LD_ADDR_VAR 0 3
11474: PUSH
11475: EMPTY
11476: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11477: LD_ADDR_VAR 0 4
11481: PUSH
11482: LD_VAR 0 1
11486: PPUSH
11487: CALL 11380 0 1
11491: ST_TO_ADDR
// case type of 0 , normal :
11492: LD_VAR 0 2
11496: PUSH
11497: LD_INT 0
11499: DOUBLE
11500: EQUAL
11501: IFTRUE 11511
11503: LD_STRING normal
11505: DOUBLE
11506: EQUAL
11507: IFTRUE 11511
11509: GO 11522
11511: POP
// cl := class_apeman ; 1 , soldier :
11512: LD_ADDR_VAR 0 5
11516: PUSH
11517: LD_INT 12
11519: ST_TO_ADDR
11520: GO 11598
11522: LD_INT 1
11524: DOUBLE
11525: EQUAL
11526: IFTRUE 11536
11528: LD_STRING soldier
11530: DOUBLE
11531: EQUAL
11532: IFTRUE 11536
11534: GO 11547
11536: POP
// cl := class_apeman_soldier ; 2 , engineer :
11537: LD_ADDR_VAR 0 5
11541: PUSH
11542: LD_INT 15
11544: ST_TO_ADDR
11545: GO 11598
11547: LD_INT 2
11549: DOUBLE
11550: EQUAL
11551: IFTRUE 11561
11553: LD_STRING engineer
11555: DOUBLE
11556: EQUAL
11557: IFTRUE 11561
11559: GO 11572
11561: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
11562: LD_ADDR_VAR 0 5
11566: PUSH
11567: LD_INT 16
11569: ST_TO_ADDR
11570: GO 11598
11572: LD_INT 3
11574: DOUBLE
11575: EQUAL
11576: IFTRUE 11586
11578: LD_STRING kamikaze
11580: DOUBLE
11581: EQUAL
11582: IFTRUE 11586
11584: GO 11597
11586: POP
// cl := class_apeman_kamikaze ; end ;
11587: LD_ADDR_VAR 0 5
11591: PUSH
11592: LD_INT 17
11594: ST_TO_ADDR
11595: GO 11598
11597: POP
// for i = 1 to tmp do
11598: LD_ADDR_VAR 0 6
11602: PUSH
11603: DOUBLE
11604: LD_INT 1
11606: DEC
11607: ST_TO_ADDR
11608: LD_VAR 0 4
11612: PUSH
11613: FOR_TO
11614: IFFALSE 11663
// if GetClass ( tmp [ i ] ) = cl then
11616: LD_VAR 0 4
11620: PUSH
11621: LD_VAR 0 6
11625: ARRAY
11626: PPUSH
11627: CALL_OW 257
11631: PUSH
11632: LD_VAR 0 5
11636: EQUAL
11637: IFFALSE 11661
// result := result ^ tmp [ i ] ;
11639: LD_ADDR_VAR 0 3
11643: PUSH
11644: LD_VAR 0 3
11648: PUSH
11649: LD_VAR 0 4
11653: PUSH
11654: LD_VAR 0 6
11658: ARRAY
11659: ADD
11660: ST_TO_ADDR
11661: GO 11613
11663: POP
11664: POP
// end ;
11665: LD_VAR 0 3
11669: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
11670: LD_INT 0
11672: PPUSH
11673: PPUSH
11674: PPUSH
11675: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11676: LD_ADDR_VAR 0 5
11680: PUSH
11681: LD_INT 22
11683: PUSH
11684: LD_VAR 0 1
11688: PUSH
11689: EMPTY
11690: LIST
11691: LIST
11692: PUSH
11693: LD_VAR 0 3
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PPUSH
11702: CALL_OW 69
11706: ST_TO_ADDR
// r := [ ] ;
11707: LD_ADDR_VAR 0 6
11711: PUSH
11712: EMPTY
11713: ST_TO_ADDR
// if tmp then
11714: LD_VAR 0 5
11718: IFFALSE 11787
// for i = 1 to tmp do
11720: LD_ADDR_VAR 0 7
11724: PUSH
11725: DOUBLE
11726: LD_INT 1
11728: DEC
11729: ST_TO_ADDR
11730: LD_VAR 0 5
11734: PUSH
11735: FOR_TO
11736: IFFALSE 11785
// if GetTag ( tmp [ i ] ) = tag then
11738: LD_VAR 0 5
11742: PUSH
11743: LD_VAR 0 7
11747: ARRAY
11748: PPUSH
11749: CALL_OW 110
11753: PUSH
11754: LD_VAR 0 2
11758: EQUAL
11759: IFFALSE 11783
// r := r ^ tmp [ i ] ;
11761: LD_ADDR_VAR 0 6
11765: PUSH
11766: LD_VAR 0 6
11770: PUSH
11771: LD_VAR 0 5
11775: PUSH
11776: LD_VAR 0 7
11780: ARRAY
11781: ADD
11782: ST_TO_ADDR
11783: GO 11735
11785: POP
11786: POP
// result := r ;
11787: LD_ADDR_VAR 0 4
11791: PUSH
11792: LD_VAR 0 6
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
11802: LD_INT 0
11804: PPUSH
11805: PPUSH
11806: PPUSH
// tmp := plist ;
11807: LD_ADDR_VAR 0 5
11811: PUSH
11812: LD_VAR 0 2
11816: ST_TO_ADDR
// if tmp then
11817: LD_VAR 0 5
11821: IFFALSE 11898
// begin for i = 1 to tmp do
11823: LD_ADDR_VAR 0 6
11827: PUSH
11828: DOUBLE
11829: LD_INT 1
11831: DEC
11832: ST_TO_ADDR
11833: LD_VAR 0 5
11837: PUSH
11838: FOR_TO
11839: IFFALSE 11886
// if GetTag ( tmp [ i ] ) <> tag then
11841: LD_VAR 0 5
11845: PUSH
11846: LD_VAR 0 6
11850: ARRAY
11851: PPUSH
11852: CALL_OW 110
11856: PUSH
11857: LD_VAR 0 3
11861: NONEQUAL
11862: IFFALSE 11884
// SetTag ( tmp [ i ] , tag ) ;
11864: LD_VAR 0 5
11868: PUSH
11869: LD_VAR 0 6
11873: ARRAY
11874: PPUSH
11875: LD_VAR 0 3
11879: PPUSH
11880: CALL_OW 109
11884: GO 11838
11886: POP
11887: POP
// result := true ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// end else
11896: GO 11906
// result := false ;
11898: LD_ADDR_VAR 0 4
11902: PUSH
11903: LD_INT 0
11905: ST_TO_ADDR
// end ;
11906: LD_VAR 0 4
11910: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
11911: LD_INT 0
11913: PPUSH
11914: PPUSH
11915: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
11916: LD_ADDR_VAR 0 4
11920: PUSH
11921: LD_VAR 0 1
11925: PPUSH
11926: LD_VAR 0 2
11930: PPUSH
11931: EMPTY
11932: PPUSH
11933: CALL 11670 0 3
11937: ST_TO_ADDR
// if tmp then
11938: LD_VAR 0 4
11942: IFFALSE 11994
// begin for i = 1 to tmp do
11944: LD_ADDR_VAR 0 5
11948: PUSH
11949: DOUBLE
11950: LD_INT 1
11952: DEC
11953: ST_TO_ADDR
11954: LD_VAR 0 4
11958: PUSH
11959: FOR_TO
11960: IFFALSE 11982
// SetTag ( tmp [ i ] , 0 ) ;
11962: LD_VAR 0 4
11966: PUSH
11967: LD_VAR 0 5
11971: ARRAY
11972: PPUSH
11973: LD_INT 0
11975: PPUSH
11976: CALL_OW 109
11980: GO 11959
11982: POP
11983: POP
// result := true ;
11984: LD_ADDR_VAR 0 3
11988: PUSH
11989: LD_INT 1
11991: ST_TO_ADDR
// end else
11992: GO 12002
// result := false ;
11994: LD_ADDR_VAR 0 3
11998: PUSH
11999: LD_INT 0
12001: ST_TO_ADDR
// end ;
12002: LD_VAR 0 3
12006: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12007: LD_INT 0
12009: PPUSH
12010: PPUSH
12011: PPUSH
12012: PPUSH
12013: PPUSH
// sort_list := [ ] ;
12014: LD_ADDR_VAR 0 5
12018: PUSH
12019: EMPTY
12020: ST_TO_ADDR
// for i = 1 to list do
12021: LD_ADDR_VAR 0 3
12025: PUSH
12026: DOUBLE
12027: LD_INT 1
12029: DEC
12030: ST_TO_ADDR
12031: LD_VAR 0 1
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12199
// begin if i = 1 then
12039: LD_VAR 0 3
12043: PUSH
12044: LD_INT 1
12046: EQUAL
12047: IFFALSE 12073
// sort_list := sort_list ^ list [ i ] else
12049: LD_ADDR_VAR 0 5
12053: PUSH
12054: LD_VAR 0 5
12058: PUSH
12059: LD_VAR 0 1
12063: PUSH
12064: LD_VAR 0 3
12068: ARRAY
12069: ADD
12070: ST_TO_ADDR
12071: GO 12197
// begin for j = 1 to sort_list do
12073: LD_ADDR_VAR 0 4
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_VAR 0 5
12087: PUSH
12088: FOR_TO
12089: IFFALSE 12166
// begin add := false ;
12091: LD_ADDR_VAR 0 6
12095: PUSH
12096: LD_INT 0
12098: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_VAR 0 3
12108: ARRAY
12109: PUSH
12110: LD_VAR 0 5
12114: PUSH
12115: LD_VAR 0 4
12119: ARRAY
12120: LESS
12121: IFFALSE 12164
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_VAR 0 5
12132: PPUSH
12133: LD_VAR 0 4
12137: PPUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_VAR 0 3
12147: ARRAY
12148: PPUSH
12149: CALL_OW 2
12153: ST_TO_ADDR
// add := true ;
12154: LD_ADDR_VAR 0 6
12158: PUSH
12159: LD_INT 1
12161: ST_TO_ADDR
// break ;
12162: GO 12166
// end ; end ;
12164: GO 12088
12166: POP
12167: POP
// if not add then
12168: LD_VAR 0 6
12172: NOT
12173: IFFALSE 12197
// sort_list := sort_list ^ list [ i ] ;
12175: LD_ADDR_VAR 0 5
12179: PUSH
12180: LD_VAR 0 5
12184: PUSH
12185: LD_VAR 0 1
12189: PUSH
12190: LD_VAR 0 3
12194: ARRAY
12195: ADD
12196: ST_TO_ADDR
// end ; end ;
12197: GO 12036
12199: POP
12200: POP
// result := sort_list ;
12201: LD_ADDR_VAR 0 2
12205: PUSH
12206: LD_VAR 0 5
12210: ST_TO_ADDR
// end ;
12211: LD_VAR 0 2
12215: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12216: LD_INT 0
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
12222: PPUSH
// sort_list := [ ] ;
12223: LD_ADDR_VAR 0 5
12227: PUSH
12228: EMPTY
12229: ST_TO_ADDR
// for i = 1 to list do
12230: LD_ADDR_VAR 0 3
12234: PUSH
12235: DOUBLE
12236: LD_INT 1
12238: DEC
12239: ST_TO_ADDR
12240: LD_VAR 0 1
12244: PUSH
12245: FOR_TO
12246: IFFALSE 12408
// begin if i = 1 then
12248: LD_VAR 0 3
12252: PUSH
12253: LD_INT 1
12255: EQUAL
12256: IFFALSE 12282
// sort_list := sort_list ^ list [ i ] else
12258: LD_ADDR_VAR 0 5
12262: PUSH
12263: LD_VAR 0 5
12267: PUSH
12268: LD_VAR 0 1
12272: PUSH
12273: LD_VAR 0 3
12277: ARRAY
12278: ADD
12279: ST_TO_ADDR
12280: GO 12406
// begin for j = 1 to sort_list do
12282: LD_ADDR_VAR 0 4
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 5
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12375
// begin add := false ;
12300: LD_ADDR_VAR 0 6
12304: PUSH
12305: LD_INT 0
12307: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12308: LD_VAR 0 1
12312: PUSH
12313: LD_VAR 0 3
12317: ARRAY
12318: PUSH
12319: LD_VAR 0 5
12323: PUSH
12324: LD_VAR 0 4
12328: ARRAY
12329: GREATER
12330: IFFALSE 12373
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12332: LD_ADDR_VAR 0 5
12336: PUSH
12337: LD_VAR 0 5
12341: PPUSH
12342: LD_VAR 0 4
12346: PPUSH
12347: LD_VAR 0 1
12351: PUSH
12352: LD_VAR 0 3
12356: ARRAY
12357: PPUSH
12358: CALL_OW 2
12362: ST_TO_ADDR
// add := true ;
12363: LD_ADDR_VAR 0 6
12367: PUSH
12368: LD_INT 1
12370: ST_TO_ADDR
// break ;
12371: GO 12375
// end ; end ;
12373: GO 12297
12375: POP
12376: POP
// if not add then
12377: LD_VAR 0 6
12381: NOT
12382: IFFALSE 12406
// sort_list := sort_list ^ list [ i ] ;
12384: LD_ADDR_VAR 0 5
12388: PUSH
12389: LD_VAR 0 5
12393: PUSH
12394: LD_VAR 0 1
12398: PUSH
12399: LD_VAR 0 3
12403: ARRAY
12404: ADD
12405: ST_TO_ADDR
// end ; end ;
12406: GO 12245
12408: POP
12409: POP
// result := sort_list ;
12410: LD_ADDR_VAR 0 2
12414: PUSH
12415: LD_VAR 0 5
12419: ST_TO_ADDR
// end ;
12420: LD_VAR 0 2
12424: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12425: LD_INT 0
12427: PPUSH
12428: PPUSH
12429: PPUSH
12430: PPUSH
12431: PPUSH
12432: PPUSH
// tmp := [ ] ;
12433: LD_ADDR_VAR 0 8
12437: PUSH
12438: EMPTY
12439: ST_TO_ADDR
// r := [ ] ;
12440: LD_ADDR_VAR 0 7
12444: PUSH
12445: EMPTY
12446: ST_TO_ADDR
// add := false ;
12447: LD_ADDR_VAR 0 9
12451: PUSH
12452: LD_INT 0
12454: ST_TO_ADDR
// if plist then
12455: LD_VAR 0 2
12459: IFFALSE 12535
// begin for i = 1 to plist do
12461: LD_ADDR_VAR 0 5
12465: PUSH
12466: DOUBLE
12467: LD_INT 1
12469: DEC
12470: ST_TO_ADDR
12471: LD_VAR 0 2
12475: PUSH
12476: FOR_TO
12477: IFFALSE 12531
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12479: LD_ADDR_VAR 0 8
12483: PUSH
12484: LD_VAR 0 8
12488: PUSH
12489: LD_VAR 0 2
12493: PUSH
12494: LD_VAR 0 5
12498: ARRAY
12499: PUSH
12500: LD_VAR 0 2
12504: PUSH
12505: LD_VAR 0 5
12509: ARRAY
12510: PPUSH
12511: LD_VAR 0 3
12515: PPUSH
12516: CALL_OW 259
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: EMPTY
12526: LIST
12527: ADD
12528: ST_TO_ADDR
// end ;
12529: GO 12476
12531: POP
12532: POP
// end else
12533: GO 12543
// result := false ;
12535: LD_ADDR_VAR 0 4
12539: PUSH
12540: LD_INT 0
12542: ST_TO_ADDR
// if tmp then
12543: LD_VAR 0 8
12547: IFFALSE 12721
// begin r := r ^ [ tmp [ 1 ] ] ;
12549: LD_ADDR_VAR 0 7
12553: PUSH
12554: LD_VAR 0 7
12558: PUSH
12559: LD_VAR 0 8
12563: PUSH
12564: LD_INT 1
12566: ARRAY
12567: PUSH
12568: EMPTY
12569: LIST
12570: ADD
12571: ST_TO_ADDR
// for i = 2 to tmp do
12572: LD_ADDR_VAR 0 5
12576: PUSH
12577: DOUBLE
12578: LD_INT 2
12580: DEC
12581: ST_TO_ADDR
12582: LD_VAR 0 8
12586: PUSH
12587: FOR_TO
12588: IFFALSE 12719
// begin for j = 1 to r do
12590: LD_ADDR_VAR 0 6
12594: PUSH
12595: DOUBLE
12596: LD_INT 1
12598: DEC
12599: ST_TO_ADDR
12600: LD_VAR 0 7
12604: PUSH
12605: FOR_TO
12606: IFFALSE 12683
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
12608: LD_VAR 0 8
12612: PUSH
12613: LD_VAR 0 5
12617: ARRAY
12618: PUSH
12619: LD_INT 2
12621: ARRAY
12622: PUSH
12623: LD_VAR 0 7
12627: PUSH
12628: LD_VAR 0 6
12632: ARRAY
12633: PUSH
12634: LD_INT 2
12636: ARRAY
12637: LESS
12638: IFFALSE 12681
// begin r := Insert ( r , j , tmp [ i ] ) ;
12640: LD_ADDR_VAR 0 7
12644: PUSH
12645: LD_VAR 0 7
12649: PPUSH
12650: LD_VAR 0 6
12654: PPUSH
12655: LD_VAR 0 8
12659: PUSH
12660: LD_VAR 0 5
12664: ARRAY
12665: PPUSH
12666: CALL_OW 2
12670: ST_TO_ADDR
// add := true ;
12671: LD_ADDR_VAR 0 9
12675: PUSH
12676: LD_INT 1
12678: ST_TO_ADDR
// break ;
12679: GO 12683
// end ; end ;
12681: GO 12605
12683: POP
12684: POP
// if not add then
12685: LD_VAR 0 9
12689: NOT
12690: IFFALSE 12717
// r := r ^ [ tmp [ i ] ] ;
12692: LD_ADDR_VAR 0 7
12696: PUSH
12697: LD_VAR 0 7
12701: PUSH
12702: LD_VAR 0 8
12706: PUSH
12707: LD_VAR 0 5
12711: ARRAY
12712: PUSH
12713: EMPTY
12714: LIST
12715: ADD
12716: ST_TO_ADDR
// end ;
12717: GO 12587
12719: POP
12720: POP
// end ; result := r ;
12721: LD_ADDR_VAR 0 4
12725: PUSH
12726: LD_VAR 0 7
12730: ST_TO_ADDR
// end ;
12731: LD_VAR 0 4
12735: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12736: LD_INT 0
12738: PPUSH
12739: PPUSH
12740: PPUSH
12741: PPUSH
12742: PPUSH
12743: PPUSH
// tmp := [ ] ;
12744: LD_ADDR_VAR 0 8
12748: PUSH
12749: EMPTY
12750: ST_TO_ADDR
// r := [ ] ;
12751: LD_ADDR_VAR 0 7
12755: PUSH
12756: EMPTY
12757: ST_TO_ADDR
// add := false ;
12758: LD_ADDR_VAR 0 9
12762: PUSH
12763: LD_INT 0
12765: ST_TO_ADDR
// if plist then
12766: LD_VAR 0 2
12770: IFFALSE 12846
// begin for i = 1 to plist do
12772: LD_ADDR_VAR 0 5
12776: PUSH
12777: DOUBLE
12778: LD_INT 1
12780: DEC
12781: ST_TO_ADDR
12782: LD_VAR 0 2
12786: PUSH
12787: FOR_TO
12788: IFFALSE 12842
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12790: LD_ADDR_VAR 0 8
12794: PUSH
12795: LD_VAR 0 8
12799: PUSH
12800: LD_VAR 0 2
12804: PUSH
12805: LD_VAR 0 5
12809: ARRAY
12810: PUSH
12811: LD_VAR 0 2
12815: PUSH
12816: LD_VAR 0 5
12820: ARRAY
12821: PPUSH
12822: LD_VAR 0 3
12826: PPUSH
12827: CALL_OW 259
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: EMPTY
12837: LIST
12838: ADD
12839: ST_TO_ADDR
// end ;
12840: GO 12787
12842: POP
12843: POP
// end else
12844: GO 12854
// result := false ;
12846: LD_ADDR_VAR 0 4
12850: PUSH
12851: LD_INT 0
12853: ST_TO_ADDR
// if tmp then
12854: LD_VAR 0 8
12858: IFFALSE 13032
// begin r := r ^ [ tmp [ 1 ] ] ;
12860: LD_ADDR_VAR 0 7
12864: PUSH
12865: LD_VAR 0 7
12869: PUSH
12870: LD_VAR 0 8
12874: PUSH
12875: LD_INT 1
12877: ARRAY
12878: PUSH
12879: EMPTY
12880: LIST
12881: ADD
12882: ST_TO_ADDR
// for i = 2 to tmp do
12883: LD_ADDR_VAR 0 5
12887: PUSH
12888: DOUBLE
12889: LD_INT 2
12891: DEC
12892: ST_TO_ADDR
12893: LD_VAR 0 8
12897: PUSH
12898: FOR_TO
12899: IFFALSE 13030
// begin for j = 1 to r do
12901: LD_ADDR_VAR 0 6
12905: PUSH
12906: DOUBLE
12907: LD_INT 1
12909: DEC
12910: ST_TO_ADDR
12911: LD_VAR 0 7
12915: PUSH
12916: FOR_TO
12917: IFFALSE 12994
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
12919: LD_VAR 0 8
12923: PUSH
12924: LD_VAR 0 5
12928: ARRAY
12929: PUSH
12930: LD_INT 2
12932: ARRAY
12933: PUSH
12934: LD_VAR 0 7
12938: PUSH
12939: LD_VAR 0 6
12943: ARRAY
12944: PUSH
12945: LD_INT 2
12947: ARRAY
12948: GREATER
12949: IFFALSE 12992
// begin r := Insert ( r , j , tmp [ i ] ) ;
12951: LD_ADDR_VAR 0 7
12955: PUSH
12956: LD_VAR 0 7
12960: PPUSH
12961: LD_VAR 0 6
12965: PPUSH
12966: LD_VAR 0 8
12970: PUSH
12971: LD_VAR 0 5
12975: ARRAY
12976: PPUSH
12977: CALL_OW 2
12981: ST_TO_ADDR
// add := true ;
12982: LD_ADDR_VAR 0 9
12986: PUSH
12987: LD_INT 1
12989: ST_TO_ADDR
// break ;
12990: GO 12994
// end ; end ;
12992: GO 12916
12994: POP
12995: POP
// if not add then
12996: LD_VAR 0 9
13000: NOT
13001: IFFALSE 13028
// r := r ^ [ tmp [ i ] ] ;
13003: LD_ADDR_VAR 0 7
13007: PUSH
13008: LD_VAR 0 7
13012: PUSH
13013: LD_VAR 0 8
13017: PUSH
13018: LD_VAR 0 5
13022: ARRAY
13023: PUSH
13024: EMPTY
13025: LIST
13026: ADD
13027: ST_TO_ADDR
// end ;
13028: GO 12898
13030: POP
13031: POP
// end ; result := r ;
13032: LD_ADDR_VAR 0 4
13036: PUSH
13037: LD_VAR 0 7
13041: ST_TO_ADDR
// end ;
13042: LD_VAR 0 4
13046: RET
// export function MCF_Clear ( side ) ; var i ; begin
13047: LD_INT 0
13049: PPUSH
13050: PPUSH
// for i = 1 to 100 do
13051: LD_ADDR_VAR 0 3
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_INT 100
13063: PUSH
13064: FOR_TO
13065: IFFALSE 13101
// if MCF_Tag ( side , i , [ ] ) then
13067: LD_VAR 0 1
13071: PPUSH
13072: LD_VAR 0 3
13076: PPUSH
13077: EMPTY
13078: PPUSH
13079: CALL 11670 0 3
13083: IFFALSE 13099
// MCF_ClearTag ( side , i ) ;
13085: LD_VAR 0 1
13089: PPUSH
13090: LD_VAR 0 3
13094: PPUSH
13095: CALL 11911 0 2
13099: GO 13064
13101: POP
13102: POP
// result := true ;
13103: LD_ADDR_VAR 0 2
13107: PUSH
13108: LD_INT 1
13110: ST_TO_ADDR
// end ;
13111: LD_VAR 0 2
13115: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13116: LD_INT 0
13118: PPUSH
13119: PPUSH
13120: PPUSH
// for i = 1 to plist do
13121: LD_ADDR_VAR 0 4
13125: PUSH
13126: DOUBLE
13127: LD_INT 1
13129: DEC
13130: ST_TO_ADDR
13131: LD_VAR 0 1
13135: PUSH
13136: FOR_TO
13137: IFFALSE 13186
// if MCF_HasClass ( plist [ i ] ) = n then
13139: LD_VAR 0 1
13143: PUSH
13144: LD_VAR 0 4
13148: ARRAY
13149: PPUSH
13150: CALL 13673 0 1
13154: PUSH
13155: LD_VAR 0 2
13159: EQUAL
13160: IFFALSE 13184
// tmp := tmp ^ plist [ i ] ;
13162: LD_ADDR_VAR 0 5
13166: PUSH
13167: LD_VAR 0 5
13171: PUSH
13172: LD_VAR 0 1
13176: PUSH
13177: LD_VAR 0 4
13181: ARRAY
13182: ADD
13183: ST_TO_ADDR
13184: GO 13136
13186: POP
13187: POP
// result := tmp ;
13188: LD_ADDR_VAR 0 3
13192: PUSH
13193: LD_VAR 0 5
13197: ST_TO_ADDR
// end ;
13198: LD_VAR 0 3
13202: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13203: LD_INT 0
13205: PPUSH
13206: PPUSH
13207: PPUSH
// if mreg = ToArm then
13208: LD_VAR 0 2
13212: PUSH
13213: LD_STRING ToArm
13215: EQUAL
13216: IFFALSE 13321
// begin tmp := MREG_ToArm [ side ] ;
13218: LD_ADDR_VAR 0 6
13222: PUSH
13223: LD_EXP 51
13227: PUSH
13228: LD_VAR 0 1
13232: ARRAY
13233: ST_TO_ADDR
// if tmp = 0 then
13234: LD_VAR 0 6
13238: PUSH
13239: LD_INT 0
13241: EQUAL
13242: IFFALSE 13248
// exit else
13244: GO 13668
13246: GO 13321
// begin for i = MREG_ToArm [ side ] downto n do
13248: LD_ADDR_VAR 0 5
13252: PUSH
13253: DOUBLE
13254: LD_EXP 51
13258: PUSH
13259: LD_VAR 0 1
13263: ARRAY
13264: INC
13265: ST_TO_ADDR
13266: LD_VAR 0 3
13270: PUSH
13271: FOR_DOWNTO
13272: IFFALSE 13294
// tmp := Delete ( tmp , 1 ) ;
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: LD_VAR 0 6
13283: PPUSH
13284: LD_INT 1
13286: PPUSH
13287: CALL_OW 3
13291: ST_TO_ADDR
13292: GO 13271
13294: POP
13295: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13296: LD_ADDR_EXP 51
13300: PUSH
13301: LD_EXP 51
13305: PPUSH
13306: LD_VAR 0 1
13310: PPUSH
13311: LD_VAR 0 6
13315: PPUSH
13316: CALL_OW 1
13320: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13321: LD_VAR 0 2
13325: PUSH
13326: LD_STRING ToDep
13328: EQUAL
13329: IFFALSE 13434
// begin tmp := MREG_ToDep [ side ] ;
13331: LD_ADDR_VAR 0 6
13335: PUSH
13336: LD_EXP 52
13340: PUSH
13341: LD_VAR 0 1
13345: ARRAY
13346: ST_TO_ADDR
// if tmp = 0 then
13347: LD_VAR 0 6
13351: PUSH
13352: LD_INT 0
13354: EQUAL
13355: IFFALSE 13361
// exit else
13357: GO 13668
13359: GO 13434
// begin for i = MREG_ToDep [ side ] downto n do
13361: LD_ADDR_VAR 0 5
13365: PUSH
13366: DOUBLE
13367: LD_EXP 52
13371: PUSH
13372: LD_VAR 0 1
13376: ARRAY
13377: INC
13378: ST_TO_ADDR
13379: LD_VAR 0 3
13383: PUSH
13384: FOR_DOWNTO
13385: IFFALSE 13407
// tmp := Delete ( tmp , 1 ) ;
13387: LD_ADDR_VAR 0 6
13391: PUSH
13392: LD_VAR 0 6
13396: PPUSH
13397: LD_INT 1
13399: PPUSH
13400: CALL_OW 3
13404: ST_TO_ADDR
13405: GO 13384
13407: POP
13408: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13409: LD_ADDR_EXP 52
13413: PUSH
13414: LD_EXP 52
13418: PPUSH
13419: LD_VAR 0 1
13423: PPUSH
13424: LD_VAR 0 6
13428: PPUSH
13429: CALL_OW 1
13433: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13434: LD_VAR 0 2
13438: PUSH
13439: LD_STRING ToFac
13441: EQUAL
13442: IFFALSE 13547
// begin tmp := MREG_ToFac [ side ] ;
13444: LD_ADDR_VAR 0 6
13448: PUSH
13449: LD_EXP 50
13453: PUSH
13454: LD_VAR 0 1
13458: ARRAY
13459: ST_TO_ADDR
// if tmp = 0 then
13460: LD_VAR 0 6
13464: PUSH
13465: LD_INT 0
13467: EQUAL
13468: IFFALSE 13474
// exit else
13470: GO 13668
13472: GO 13547
// begin for i = MREG_ToFac [ side ] downto n do
13474: LD_ADDR_VAR 0 5
13478: PUSH
13479: DOUBLE
13480: LD_EXP 50
13484: PUSH
13485: LD_VAR 0 1
13489: ARRAY
13490: INC
13491: ST_TO_ADDR
13492: LD_VAR 0 3
13496: PUSH
13497: FOR_DOWNTO
13498: IFFALSE 13520
// tmp := Delete ( tmp , 1 ) ;
13500: LD_ADDR_VAR 0 6
13504: PUSH
13505: LD_VAR 0 6
13509: PPUSH
13510: LD_INT 1
13512: PPUSH
13513: CALL_OW 3
13517: ST_TO_ADDR
13518: GO 13497
13520: POP
13521: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13522: LD_ADDR_EXP 50
13526: PUSH
13527: LD_EXP 50
13531: PPUSH
13532: LD_VAR 0 1
13536: PPUSH
13537: LD_VAR 0 6
13541: PPUSH
13542: CALL_OW 1
13546: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
13547: LD_VAR 0 2
13551: PUSH
13552: LD_STRING ToLab
13554: EQUAL
13555: IFFALSE 13660
// begin tmp := MREG_ToLab [ side ] ;
13557: LD_ADDR_VAR 0 6
13561: PUSH
13562: LD_EXP 49
13566: PUSH
13567: LD_VAR 0 1
13571: ARRAY
13572: ST_TO_ADDR
// if tmp = 0 then
13573: LD_VAR 0 6
13577: PUSH
13578: LD_INT 0
13580: EQUAL
13581: IFFALSE 13587
// exit else
13583: GO 13668
13585: GO 13660
// begin for i = MREG_ToLab [ side ] downto n do
13587: LD_ADDR_VAR 0 5
13591: PUSH
13592: DOUBLE
13593: LD_EXP 49
13597: PUSH
13598: LD_VAR 0 1
13602: ARRAY
13603: INC
13604: ST_TO_ADDR
13605: LD_VAR 0 3
13609: PUSH
13610: FOR_DOWNTO
13611: IFFALSE 13633
// tmp := Delete ( tmp , 1 ) ;
13613: LD_ADDR_VAR 0 6
13617: PUSH
13618: LD_VAR 0 6
13622: PPUSH
13623: LD_INT 1
13625: PPUSH
13626: CALL_OW 3
13630: ST_TO_ADDR
13631: GO 13610
13633: POP
13634: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
13635: LD_ADDR_EXP 49
13639: PUSH
13640: LD_EXP 49
13644: PPUSH
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 6
13654: PPUSH
13655: CALL_OW 1
13659: ST_TO_ADDR
// end ; end ; result := true ;
13660: LD_ADDR_VAR 0 4
13664: PUSH
13665: LD_INT 1
13667: ST_TO_ADDR
// end ;
13668: LD_VAR 0 4
13672: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
13673: LD_INT 0
13675: PPUSH
13676: PPUSH
13677: PPUSH
// side := GetSide ( unit ) ;
13678: LD_ADDR_VAR 0 4
13682: PUSH
13683: LD_VAR 0 1
13687: PPUSH
13688: CALL_OW 255
13692: ST_TO_ADDR
// tmp := 0 ;
13693: LD_ADDR_VAR 0 3
13697: PUSH
13698: LD_INT 0
13700: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
13701: LD_VAR 0 1
13705: PUSH
13706: LD_EXP 51
13710: PUSH
13711: LD_VAR 0 4
13715: ARRAY
13716: IN
13717: IFFALSE 13727
// tmp := 1 ;
13719: LD_ADDR_VAR 0 3
13723: PUSH
13724: LD_INT 1
13726: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
13727: LD_VAR 0 1
13731: PUSH
13732: LD_EXP 52
13736: PUSH
13737: LD_VAR 0 4
13741: ARRAY
13742: IN
13743: IFFALSE 13753
// tmp := 2 ;
13745: LD_ADDR_VAR 0 3
13749: PUSH
13750: LD_INT 2
13752: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
13753: LD_VAR 0 1
13757: PUSH
13758: LD_EXP 50
13762: PUSH
13763: LD_VAR 0 4
13767: ARRAY
13768: IN
13769: IFFALSE 13779
// tmp := 3 ;
13771: LD_ADDR_VAR 0 3
13775: PUSH
13776: LD_INT 3
13778: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
13779: LD_VAR 0 1
13783: PUSH
13784: LD_EXP 49
13788: PUSH
13789: LD_VAR 0 4
13793: ARRAY
13794: IN
13795: IFFALSE 13805
// tmp := 4 ;
13797: LD_ADDR_VAR 0 3
13801: PUSH
13802: LD_INT 4
13804: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
13805: LD_VAR 0 1
13809: PUSH
13810: LD_EXP 63
13814: PUSH
13815: LD_VAR 0 4
13819: ARRAY
13820: IN
13821: IFFALSE 13831
// tmp := 5 ;
13823: LD_ADDR_VAR 0 3
13827: PUSH
13828: LD_INT 5
13830: ST_TO_ADDR
// result := tmp ;
13831: LD_ADDR_VAR 0 2
13835: PUSH
13836: LD_VAR 0 3
13840: ST_TO_ADDR
// end ;
13841: LD_VAR 0 2
13845: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
13846: LD_INT 0
13848: PPUSH
13849: PPUSH
// if mreg = ToArm then
13850: LD_VAR 0 2
13854: PUSH
13855: LD_STRING ToArm
13857: EQUAL
13858: IFFALSE 13947
// for i = MREG_ToArm [ side ] downto 1 do
13860: LD_ADDR_VAR 0 5
13864: PUSH
13865: DOUBLE
13866: LD_EXP 51
13870: PUSH
13871: LD_VAR 0 1
13875: ARRAY
13876: INC
13877: ST_TO_ADDR
13878: LD_INT 1
13880: PUSH
13881: FOR_DOWNTO
13882: IFFALSE 13945
// if MREG_ToArm [ side ] [ i ] = unit then
13884: LD_EXP 51
13888: PUSH
13889: LD_VAR 0 1
13893: ARRAY
13894: PUSH
13895: LD_VAR 0 5
13899: ARRAY
13900: PUSH
13901: LD_VAR 0 3
13905: EQUAL
13906: IFFALSE 13943
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
13908: LD_ADDR_EXP 51
13912: PUSH
13913: LD_EXP 51
13917: PPUSH
13918: LD_EXP 51
13922: PUSH
13923: LD_VAR 0 1
13927: ARRAY
13928: PUSH
13929: LD_VAR 0 5
13933: ARRAY
13934: PPUSH
13935: LD_INT 1
13937: PPUSH
13938: CALL 29940 0 3
13942: ST_TO_ADDR
// end ;
13943: GO 13881
13945: POP
13946: POP
// if mreg = ToDep then
13947: LD_VAR 0 2
13951: PUSH
13952: LD_STRING ToDep
13954: EQUAL
13955: IFFALSE 14044
// for i = MREG_ToDep [ side ] downto 1 do
13957: LD_ADDR_VAR 0 5
13961: PUSH
13962: DOUBLE
13963: LD_EXP 52
13967: PUSH
13968: LD_VAR 0 1
13972: ARRAY
13973: INC
13974: ST_TO_ADDR
13975: LD_INT 1
13977: PUSH
13978: FOR_DOWNTO
13979: IFFALSE 14042
// if MREG_ToDep [ side ] [ i ] = unit then
13981: LD_EXP 52
13985: PUSH
13986: LD_VAR 0 1
13990: ARRAY
13991: PUSH
13992: LD_VAR 0 5
13996: ARRAY
13997: PUSH
13998: LD_VAR 0 3
14002: EQUAL
14003: IFFALSE 14040
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14005: LD_ADDR_EXP 52
14009: PUSH
14010: LD_EXP 52
14014: PPUSH
14015: LD_EXP 52
14019: PUSH
14020: LD_VAR 0 1
14024: ARRAY
14025: PUSH
14026: LD_VAR 0 5
14030: ARRAY
14031: PPUSH
14032: LD_INT 1
14034: PPUSH
14035: CALL 29940 0 3
14039: ST_TO_ADDR
// end ;
14040: GO 13978
14042: POP
14043: POP
// if mreg = ToFac then
14044: LD_VAR 0 2
14048: PUSH
14049: LD_STRING ToFac
14051: EQUAL
14052: IFFALSE 14141
// for i = MREG_ToFac [ side ] downto 1 do
14054: LD_ADDR_VAR 0 5
14058: PUSH
14059: DOUBLE
14060: LD_EXP 50
14064: PUSH
14065: LD_VAR 0 1
14069: ARRAY
14070: INC
14071: ST_TO_ADDR
14072: LD_INT 1
14074: PUSH
14075: FOR_DOWNTO
14076: IFFALSE 14139
// if MREG_ToFac [ side ] [ i ] = unit then
14078: LD_EXP 50
14082: PUSH
14083: LD_VAR 0 1
14087: ARRAY
14088: PUSH
14089: LD_VAR 0 5
14093: ARRAY
14094: PUSH
14095: LD_VAR 0 3
14099: EQUAL
14100: IFFALSE 14137
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14102: LD_ADDR_EXP 50
14106: PUSH
14107: LD_EXP 50
14111: PPUSH
14112: LD_EXP 50
14116: PUSH
14117: LD_VAR 0 1
14121: ARRAY
14122: PUSH
14123: LD_VAR 0 5
14127: ARRAY
14128: PPUSH
14129: LD_INT 1
14131: PPUSH
14132: CALL 29940 0 3
14136: ST_TO_ADDR
// end ;
14137: GO 14075
14139: POP
14140: POP
// if mreg = ToLab then
14141: LD_VAR 0 2
14145: PUSH
14146: LD_STRING ToLab
14148: EQUAL
14149: IFFALSE 14238
// for i = MREG_ToLab [ side ] downto 1 do
14151: LD_ADDR_VAR 0 5
14155: PUSH
14156: DOUBLE
14157: LD_EXP 49
14161: PUSH
14162: LD_VAR 0 1
14166: ARRAY
14167: INC
14168: ST_TO_ADDR
14169: LD_INT 1
14171: PUSH
14172: FOR_DOWNTO
14173: IFFALSE 14236
// if MREG_ToLab [ side ] [ i ] = unit then
14175: LD_EXP 49
14179: PUSH
14180: LD_VAR 0 1
14184: ARRAY
14185: PUSH
14186: LD_VAR 0 5
14190: ARRAY
14191: PUSH
14192: LD_VAR 0 3
14196: EQUAL
14197: IFFALSE 14234
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14199: LD_ADDR_EXP 49
14203: PUSH
14204: LD_EXP 49
14208: PPUSH
14209: LD_EXP 49
14213: PUSH
14214: LD_VAR 0 1
14218: ARRAY
14219: PUSH
14220: LD_VAR 0 5
14224: ARRAY
14225: PPUSH
14226: LD_INT 1
14228: PPUSH
14229: CALL 29940 0 3
14233: ST_TO_ADDR
// end ;
14234: GO 14172
14236: POP
14237: POP
// end ;
14238: LD_VAR 0 4
14242: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14243: LD_INT 0
14245: PPUSH
14246: PPUSH
// result := false ;
14247: LD_ADDR_VAR 0 2
14251: PUSH
14252: LD_INT 0
14254: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14255: LD_ADDR_VAR 0 3
14259: PUSH
14260: DOUBLE
14261: LD_INT 1
14263: DEC
14264: ST_TO_ADDR
14265: LD_EXP 41
14269: PUSH
14270: FOR_TO
14271: IFFALSE 14335
// if MREG_ToBuild [ i ] [ 1 ] = side then
14273: LD_EXP 41
14277: PUSH
14278: LD_VAR 0 3
14282: ARRAY
14283: PUSH
14284: LD_INT 1
14286: ARRAY
14287: PUSH
14288: LD_VAR 0 1
14292: EQUAL
14293: IFFALSE 14333
// begin if MREG_ToBuild [ i ] [ 1 ] then
14295: LD_EXP 41
14299: PUSH
14300: LD_VAR 0 3
14304: ARRAY
14305: PUSH
14306: LD_INT 1
14308: ARRAY
14309: IFFALSE 14333
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14311: LD_ADDR_VAR 0 2
14315: PUSH
14316: LD_EXP 41
14320: PUSH
14321: LD_VAR 0 3
14325: ARRAY
14326: PUSH
14327: LD_INT 1
14329: ARRAY
14330: ST_TO_ADDR
// break ;
14331: GO 14335
// end ; end ;
14333: GO 14270
14335: POP
14336: POP
// for i = 1 to MREG_ToRepair do
14337: LD_ADDR_VAR 0 3
14341: PUSH
14342: DOUBLE
14343: LD_INT 1
14345: DEC
14346: ST_TO_ADDR
14347: LD_EXP 42
14351: PUSH
14352: FOR_TO
14353: IFFALSE 14417
// if MREG_ToRepair [ i ] [ 1 ] = side then
14355: LD_EXP 42
14359: PUSH
14360: LD_VAR 0 3
14364: ARRAY
14365: PUSH
14366: LD_INT 1
14368: ARRAY
14369: PUSH
14370: LD_VAR 0 1
14374: EQUAL
14375: IFFALSE 14415
// begin if MREG_ToRepair [ i ] [ 1 ] then
14377: LD_EXP 42
14381: PUSH
14382: LD_VAR 0 3
14386: ARRAY
14387: PUSH
14388: LD_INT 1
14390: ARRAY
14391: IFFALSE 14415
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14393: LD_ADDR_VAR 0 2
14397: PUSH
14398: LD_EXP 42
14402: PUSH
14403: LD_VAR 0 3
14407: ARRAY
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: ST_TO_ADDR
// break ;
14413: GO 14417
// end ; end ;
14415: GO 14352
14417: POP
14418: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14419: LD_VAR 0 1
14423: PPUSH
14424: LD_INT 57
14426: PUSH
14427: EMPTY
14428: LIST
14429: PPUSH
14430: CALL 10967 0 2
14434: IFFALSE 14461
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14436: LD_ADDR_VAR 0 2
14440: PUSH
14441: LD_VAR 0 1
14445: PPUSH
14446: LD_INT 57
14448: PUSH
14449: EMPTY
14450: LIST
14451: PPUSH
14452: CALL 10967 0 2
14456: PUSH
14457: LD_INT 1
14459: ARRAY
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
14470: PPUSH
14471: PPUSH
14472: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14473: LD_ADDR_VAR 0 6
14477: PUSH
14478: LD_VAR 0 1
14482: PPUSH
14483: LD_INT 21
14485: PUSH
14486: LD_INT 3
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: PPUSH
14493: CALL 10967 0 2
14497: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14498: LD_ADDR_VAR 0 7
14502: PUSH
14503: LD_VAR 0 1
14507: PPUSH
14508: LD_INT 81
14510: PUSH
14511: LD_VAR 0 1
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PPUSH
14520: CALL 10967 0 2
14524: ST_TO_ADDR
// if not enemy then
14525: LD_VAR 0 7
14529: NOT
14530: IFFALSE 14542
// result := false else
14532: LD_ADDR_VAR 0 3
14536: PUSH
14537: LD_INT 0
14539: ST_TO_ADDR
14540: GO 14596
// begin scan := NearestUnit ( b , enemy ) ;
14542: LD_ADDR_VAR 0 5
14546: PUSH
14547: LD_VAR 0 6
14551: PPUSH
14552: LD_VAR 0 7
14556: PPUSH
14557: CALL 31265 0 2
14561: ST_TO_ADDR
// if scan [ 2 ] < dist then
14562: LD_VAR 0 5
14566: PUSH
14567: LD_INT 2
14569: ARRAY
14570: PUSH
14571: LD_VAR 0 2
14575: LESS
14576: IFFALSE 14588
// result := true else
14578: LD_ADDR_VAR 0 3
14582: PUSH
14583: LD_INT 1
14585: ST_TO_ADDR
14586: GO 14596
// result := false ;
14588: LD_ADDR_VAR 0 3
14592: PUSH
14593: LD_INT 0
14595: ST_TO_ADDR
// end ; end ;
14596: LD_VAR 0 3
14600: RET
// export function MCF_Info ( ) ; begin
14601: LD_INT 0
14603: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
14604: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
14606: PUSH
14607: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
14609: ADD
14610: PUSH
14611: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
14613: ADD
14614: PUSH
14615: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
14617: ADD
14618: PUSH
14619: LD_STRING - MCF_ClearTag -> Kasuje dany tag
14621: ADD
14622: PUSH
14623: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
14625: ADD
14626: PUSH
14627: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
14629: ADD
14630: PUSH
14631: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
14633: ADD
14634: PUSH
14635: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
14637: ADD
14638: PUSH
14639: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
14641: ADD
14642: PPUSH
14643: CALL 7885 0 1
// end ; end_of_file
14647: LD_VAR 0 1
14651: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
14652: LD_INT 0
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
14658: LD_ADDR_VAR 0 5
14662: PUSH
14663: LD_VAR 0 1
14667: PPUSH
14668: LD_INT 2
14670: PUSH
14671: LD_INT 25
14673: PUSH
14674: LD_INT 2
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: LD_INT 25
14683: PUSH
14684: LD_INT 3
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PUSH
14691: LD_INT 25
14693: PUSH
14694: LD_INT 4
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: PPUSH
14707: CALL 10967 0 2
14711: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
14712: LD_ADDR_VAR 0 5
14716: PUSH
14717: LD_VAR 0 5
14721: PPUSH
14722: LD_INT 0
14724: PPUSH
14725: CALL 13116 0 2
14729: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
14730: LD_ADDR_VAR 0 6
14734: PUSH
14735: LD_VAR 0 1
14739: PPUSH
14740: LD_VAR 0 5
14744: PPUSH
14745: LD_INT 1
14747: PPUSH
14748: CALL 12736 0 3
14752: ST_TO_ADDR
// if n > sk then
14753: LD_VAR 0 2
14757: PUSH
14758: LD_VAR 0 6
14762: GREATER
14763: IFFALSE 14775
// n := sk ;
14765: LD_ADDR_VAR 0 2
14769: PUSH
14770: LD_VAR 0 6
14774: ST_TO_ADDR
// for i = 1 to n do
14775: LD_ADDR_VAR 0 4
14779: PUSH
14780: DOUBLE
14781: LD_INT 1
14783: DEC
14784: ST_TO_ADDR
14785: LD_VAR 0 2
14789: PUSH
14790: FOR_TO
14791: IFFALSE 14903
// if ( sk [ i ] [ 1 ] ) <> 0 then
14793: LD_VAR 0 6
14797: PUSH
14798: LD_VAR 0 4
14802: ARRAY
14803: PUSH
14804: LD_INT 1
14806: ARRAY
14807: PUSH
14808: LD_INT 0
14810: NONEQUAL
14811: IFFALSE 14901
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
14813: LD_ADDR_EXP 48
14817: PUSH
14818: LD_EXP 48
14822: PPUSH
14823: LD_VAR 0 1
14827: PPUSH
14828: LD_VAR 0 6
14832: PUSH
14833: LD_VAR 0 4
14837: ARRAY
14838: PUSH
14839: LD_INT 1
14841: ARRAY
14842: PPUSH
14843: LD_INT 1
14845: PPUSH
14846: CALL 39713 0 4
14850: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
14851: LD_ADDR_EXP 51
14855: PUSH
14856: LD_EXP 51
14860: PPUSH
14861: LD_VAR 0 1
14865: PPUSH
14866: LD_EXP 51
14870: PUSH
14871: LD_VAR 0 1
14875: ARRAY
14876: PUSH
14877: LD_INT 1
14879: PLUS
14880: PPUSH
14881: LD_VAR 0 6
14885: PUSH
14886: LD_VAR 0 4
14890: ARRAY
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: PPUSH
14896: CALL 29864 0 4
14900: ST_TO_ADDR
// end ;
14901: GO 14790
14903: POP
14904: POP
// end ;
14905: LD_VAR 0 3
14909: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
14910: LD_INT 0
14912: PPUSH
14913: PPUSH
14914: PPUSH
14915: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
14916: LD_ADDR_VAR 0 5
14920: PUSH
14921: LD_VAR 0 1
14925: PPUSH
14926: LD_INT 2
14928: PUSH
14929: LD_INT 25
14931: PUSH
14932: LD_INT 1
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: LD_INT 25
14941: PUSH
14942: LD_INT 3
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PUSH
14949: LD_INT 25
14951: PUSH
14952: LD_INT 4
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: PPUSH
14965: CALL 10967 0 2
14969: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
14970: LD_ADDR_VAR 0 5
14974: PUSH
14975: LD_VAR 0 5
14979: PPUSH
14980: LD_INT 0
14982: PPUSH
14983: CALL 13116 0 2
14987: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
14988: LD_ADDR_VAR 0 6
14992: PUSH
14993: LD_VAR 0 1
14997: PPUSH
14998: LD_VAR 0 5
15002: PPUSH
15003: LD_INT 2
15005: PPUSH
15006: CALL 12736 0 3
15010: ST_TO_ADDR
// if n > sk then
15011: LD_VAR 0 2
15015: PUSH
15016: LD_VAR 0 6
15020: GREATER
15021: IFFALSE 15033
// n := sk ;
15023: LD_ADDR_VAR 0 2
15027: PUSH
15028: LD_VAR 0 6
15032: ST_TO_ADDR
// for i = 1 to n do
15033: LD_ADDR_VAR 0 4
15037: PUSH
15038: DOUBLE
15039: LD_INT 1
15041: DEC
15042: ST_TO_ADDR
15043: LD_VAR 0 2
15047: PUSH
15048: FOR_TO
15049: IFFALSE 15161
// if ( sk [ i ] [ 1 ] ) <> 0 then
15051: LD_VAR 0 6
15055: PUSH
15056: LD_VAR 0 4
15060: ARRAY
15061: PUSH
15062: LD_INT 1
15064: ARRAY
15065: PUSH
15066: LD_INT 0
15068: NONEQUAL
15069: IFFALSE 15159
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15071: LD_ADDR_EXP 48
15075: PUSH
15076: LD_EXP 48
15080: PPUSH
15081: LD_VAR 0 1
15085: PPUSH
15086: LD_VAR 0 6
15090: PUSH
15091: LD_VAR 0 4
15095: ARRAY
15096: PUSH
15097: LD_INT 1
15099: ARRAY
15100: PPUSH
15101: LD_INT 2
15103: PPUSH
15104: CALL 39713 0 4
15108: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15109: LD_ADDR_EXP 52
15113: PUSH
15114: LD_EXP 52
15118: PPUSH
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_EXP 52
15128: PUSH
15129: LD_VAR 0 1
15133: ARRAY
15134: PUSH
15135: LD_INT 1
15137: PLUS
15138: PPUSH
15139: LD_VAR 0 6
15143: PUSH
15144: LD_VAR 0 4
15148: ARRAY
15149: PUSH
15150: LD_INT 1
15152: ARRAY
15153: PPUSH
15154: CALL 29864 0 4
15158: ST_TO_ADDR
// end ;
15159: GO 15048
15161: POP
15162: POP
// end ;
15163: LD_VAR 0 3
15167: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15168: LD_INT 0
15170: PPUSH
15171: PPUSH
15172: PPUSH
15173: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15174: LD_ADDR_VAR 0 5
15178: PUSH
15179: LD_VAR 0 1
15183: PPUSH
15184: LD_INT 2
15186: PUSH
15187: LD_INT 25
15189: PUSH
15190: LD_INT 1
15192: PUSH
15193: EMPTY
15194: LIST
15195: LIST
15196: PUSH
15197: LD_INT 25
15199: PUSH
15200: LD_INT 2
15202: PUSH
15203: EMPTY
15204: LIST
15205: LIST
15206: PUSH
15207: LD_INT 25
15209: PUSH
15210: LD_INT 4
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: PPUSH
15223: CALL 10967 0 2
15227: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15228: LD_ADDR_VAR 0 5
15232: PUSH
15233: LD_VAR 0 5
15237: PPUSH
15238: LD_INT 0
15240: PPUSH
15241: CALL 13116 0 2
15245: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15246: LD_ADDR_VAR 0 6
15250: PUSH
15251: LD_VAR 0 1
15255: PPUSH
15256: LD_VAR 0 5
15260: PPUSH
15261: LD_INT 3
15263: PPUSH
15264: CALL 12736 0 3
15268: ST_TO_ADDR
// if n > sk then
15269: LD_VAR 0 2
15273: PUSH
15274: LD_VAR 0 6
15278: GREATER
15279: IFFALSE 15291
// n := sk ;
15281: LD_ADDR_VAR 0 2
15285: PUSH
15286: LD_VAR 0 6
15290: ST_TO_ADDR
// for i = 1 to n do
15291: LD_ADDR_VAR 0 4
15295: PUSH
15296: DOUBLE
15297: LD_INT 1
15299: DEC
15300: ST_TO_ADDR
15301: LD_VAR 0 2
15305: PUSH
15306: FOR_TO
15307: IFFALSE 15419
// if ( sk [ i ] [ 1 ] ) <> 0 then
15309: LD_VAR 0 6
15313: PUSH
15314: LD_VAR 0 4
15318: ARRAY
15319: PUSH
15320: LD_INT 1
15322: ARRAY
15323: PUSH
15324: LD_INT 0
15326: NONEQUAL
15327: IFFALSE 15417
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15329: LD_ADDR_EXP 48
15333: PUSH
15334: LD_EXP 48
15338: PPUSH
15339: LD_VAR 0 1
15343: PPUSH
15344: LD_VAR 0 6
15348: PUSH
15349: LD_VAR 0 4
15353: ARRAY
15354: PUSH
15355: LD_INT 1
15357: ARRAY
15358: PPUSH
15359: LD_INT 3
15361: PPUSH
15362: CALL 39713 0 4
15366: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15367: LD_ADDR_EXP 50
15371: PUSH
15372: LD_EXP 50
15376: PPUSH
15377: LD_VAR 0 1
15381: PPUSH
15382: LD_EXP 50
15386: PUSH
15387: LD_VAR 0 1
15391: ARRAY
15392: PUSH
15393: LD_INT 1
15395: PLUS
15396: PPUSH
15397: LD_VAR 0 6
15401: PUSH
15402: LD_VAR 0 4
15406: ARRAY
15407: PUSH
15408: LD_INT 1
15410: ARRAY
15411: PPUSH
15412: CALL 29864 0 4
15416: ST_TO_ADDR
// end ;
15417: GO 15306
15419: POP
15420: POP
// end ;
15421: LD_VAR 0 3
15425: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15426: LD_INT 0
15428: PPUSH
15429: PPUSH
15430: PPUSH
15431: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15432: LD_ADDR_VAR 0 5
15436: PUSH
15437: LD_VAR 0 1
15441: PPUSH
15442: LD_INT 2
15444: PUSH
15445: LD_INT 25
15447: PUSH
15448: LD_INT 1
15450: PUSH
15451: EMPTY
15452: LIST
15453: LIST
15454: PUSH
15455: LD_INT 25
15457: PUSH
15458: LD_INT 2
15460: PUSH
15461: EMPTY
15462: LIST
15463: LIST
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: LIST
15469: PPUSH
15470: CALL 10967 0 2
15474: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15475: LD_ADDR_VAR 0 5
15479: PUSH
15480: LD_VAR 0 5
15484: PPUSH
15485: LD_INT 0
15487: PPUSH
15488: CALL 13116 0 2
15492: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15493: LD_ADDR_VAR 0 6
15497: PUSH
15498: LD_VAR 0 1
15502: PPUSH
15503: LD_VAR 0 5
15507: PPUSH
15508: LD_INT 4
15510: PPUSH
15511: CALL 12736 0 3
15515: ST_TO_ADDR
// if n > sk then
15516: LD_VAR 0 2
15520: PUSH
15521: LD_VAR 0 6
15525: GREATER
15526: IFFALSE 15538
// n := sk ;
15528: LD_ADDR_VAR 0 2
15532: PUSH
15533: LD_VAR 0 6
15537: ST_TO_ADDR
// for i = 1 to n do
15538: LD_ADDR_VAR 0 4
15542: PUSH
15543: DOUBLE
15544: LD_INT 1
15546: DEC
15547: ST_TO_ADDR
15548: LD_VAR 0 2
15552: PUSH
15553: FOR_TO
15554: IFFALSE 15666
// if ( sk [ i ] [ 1 ] ) <> 0 then
15556: LD_VAR 0 6
15560: PUSH
15561: LD_VAR 0 4
15565: ARRAY
15566: PUSH
15567: LD_INT 1
15569: ARRAY
15570: PUSH
15571: LD_INT 0
15573: NONEQUAL
15574: IFFALSE 15664
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
15576: LD_ADDR_EXP 48
15580: PUSH
15581: LD_EXP 48
15585: PPUSH
15586: LD_VAR 0 1
15590: PPUSH
15591: LD_VAR 0 6
15595: PUSH
15596: LD_VAR 0 4
15600: ARRAY
15601: PUSH
15602: LD_INT 1
15604: ARRAY
15605: PPUSH
15606: LD_INT 4
15608: PPUSH
15609: CALL 39713 0 4
15613: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15614: LD_ADDR_EXP 49
15618: PUSH
15619: LD_EXP 49
15623: PPUSH
15624: LD_VAR 0 1
15628: PPUSH
15629: LD_EXP 49
15633: PUSH
15634: LD_VAR 0 1
15638: ARRAY
15639: PUSH
15640: LD_INT 1
15642: PLUS
15643: PPUSH
15644: LD_VAR 0 6
15648: PUSH
15649: LD_VAR 0 4
15653: ARRAY
15654: PUSH
15655: LD_INT 1
15657: ARRAY
15658: PPUSH
15659: CALL 29864 0 4
15663: ST_TO_ADDR
// end ;
15664: GO 15553
15666: POP
15667: POP
// end ;
15668: LD_VAR 0 3
15672: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
15673: LD_INT 0
15675: PPUSH
15676: PPUSH
15677: PPUSH
15678: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15679: LD_ADDR_VAR 0 6
15683: PUSH
15684: LD_VAR 0 1
15688: PPUSH
15689: LD_INT 2
15691: PUSH
15692: LD_INT 25
15694: PUSH
15695: LD_INT 1
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PUSH
15702: LD_INT 25
15704: PUSH
15705: LD_INT 2
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: PUSH
15712: LD_INT 25
15714: PUSH
15715: LD_INT 3
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PUSH
15722: LD_INT 25
15724: PUSH
15725: LD_INT 4
15727: PUSH
15728: EMPTY
15729: LIST
15730: LIST
15731: PUSH
15732: EMPTY
15733: LIST
15734: LIST
15735: LIST
15736: LIST
15737: LIST
15738: PPUSH
15739: CALL 10967 0 2
15743: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15744: LD_ADDR_VAR 0 6
15748: PUSH
15749: LD_VAR 0 6
15753: PPUSH
15754: LD_INT 0
15756: PPUSH
15757: CALL 13116 0 2
15761: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15762: LD_ADDR_VAR 0 7
15766: PUSH
15767: LD_VAR 0 1
15771: PPUSH
15772: LD_VAR 0 6
15776: PPUSH
15777: LD_INT 1
15779: PPUSH
15780: CALL 12736 0 3
15784: ST_TO_ADDR
// if n > sk then
15785: LD_VAR 0 2
15789: PUSH
15790: LD_VAR 0 7
15794: GREATER
15795: IFFALSE 15807
// n := sk ;
15797: LD_ADDR_VAR 0 2
15801: PUSH
15802: LD_VAR 0 7
15806: ST_TO_ADDR
// for i = 1 to n do
15807: LD_ADDR_VAR 0 5
15811: PUSH
15812: DOUBLE
15813: LD_INT 1
15815: DEC
15816: ST_TO_ADDR
15817: LD_VAR 0 2
15821: PUSH
15822: FOR_TO
15823: IFFALSE 15867
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
15825: LD_ADDR_EXP 48
15829: PUSH
15830: LD_EXP 48
15834: PPUSH
15835: LD_VAR 0 1
15839: PPUSH
15840: LD_VAR 0 7
15844: PUSH
15845: LD_VAR 0 5
15849: ARRAY
15850: PUSH
15851: LD_INT 1
15853: ARRAY
15854: PPUSH
15855: LD_VAR 0 3
15859: PPUSH
15860: CALL 39713 0 4
15864: ST_TO_ADDR
// end ;
15865: GO 15822
15867: POP
15868: POP
// end ;
15869: LD_VAR 0 4
15873: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
15874: LD_INT 0
15876: PPUSH
15877: PPUSH
15878: PPUSH
// b := false ;
15879: LD_ADDR_VAR 0 6
15883: PUSH
15884: LD_INT 0
15886: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
15887: LD_VAR 0 3
15891: PUSH
15892: LD_INT 1
15894: PUSH
15895: LD_INT 9
15897: PUSH
15898: LD_INT 5
15900: PUSH
15901: LD_INT 8
15903: PUSH
15904: EMPTY
15905: LIST
15906: LIST
15907: LIST
15908: LIST
15909: IN
15910: IFFALSE 15998
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
15912: LD_VAR 0 1
15916: PPUSH
15917: LD_INT 2
15919: PUSH
15920: LD_INT 30
15922: PUSH
15923: LD_INT 4
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: PUSH
15930: LD_INT 30
15932: PUSH
15933: LD_INT 5
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: LIST
15944: PPUSH
15945: CALL 10967 0 2
15949: IFFALSE 15998
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
15951: LD_ADDR_VAR 0 6
15955: PUSH
15956: LD_VAR 0 1
15960: PPUSH
15961: LD_INT 2
15963: PUSH
15964: LD_INT 30
15966: PUSH
15967: LD_INT 4
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: PUSH
15974: LD_INT 30
15976: PUSH
15977: LD_INT 5
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: PUSH
15984: EMPTY
15985: LIST
15986: LIST
15987: LIST
15988: PPUSH
15989: CALL 10967 0 2
15993: PUSH
15994: LD_INT 1
15996: ARRAY
15997: ST_TO_ADDR
// if class = class_engineer then
15998: LD_VAR 0 3
16002: PUSH
16003: LD_INT 2
16005: EQUAL
16006: IFFALSE 16094
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16008: LD_VAR 0 1
16012: PPUSH
16013: LD_INT 2
16015: PUSH
16016: LD_INT 30
16018: PUSH
16019: LD_INT 0
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: PUSH
16026: LD_INT 30
16028: PUSH
16029: LD_INT 1
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: PPUSH
16041: CALL 10967 0 2
16045: IFFALSE 16094
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16047: LD_ADDR_VAR 0 6
16051: PUSH
16052: LD_VAR 0 1
16056: PPUSH
16057: LD_INT 2
16059: PUSH
16060: LD_INT 30
16062: PUSH
16063: LD_INT 0
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: PUSH
16070: LD_INT 30
16072: PUSH
16073: LD_INT 1
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: PUSH
16080: EMPTY
16081: LIST
16082: LIST
16083: LIST
16084: PPUSH
16085: CALL 10967 0 2
16089: PUSH
16090: LD_INT 1
16092: ARRAY
16093: ST_TO_ADDR
// if class = class_mechanic then
16094: LD_VAR 0 3
16098: PUSH
16099: LD_INT 3
16101: EQUAL
16102: IFFALSE 16172
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16104: LD_VAR 0 1
16108: PPUSH
16109: LD_INT 30
16111: PUSH
16112: LD_INT 3
16114: PUSH
16115: EMPTY
16116: LIST
16117: LIST
16118: PPUSH
16119: CALL 10967 0 2
16123: IFFALSE 16172
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16125: LD_ADDR_VAR 0 6
16129: PUSH
16130: LD_VAR 0 1
16134: PPUSH
16135: LD_INT 2
16137: PUSH
16138: LD_INT 30
16140: PUSH
16141: LD_INT 2
16143: PUSH
16144: EMPTY
16145: LIST
16146: LIST
16147: PUSH
16148: LD_INT 30
16150: PUSH
16151: LD_INT 3
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: LIST
16162: PPUSH
16163: CALL 10967 0 2
16167: PUSH
16168: LD_INT 1
16170: ARRAY
16171: ST_TO_ADDR
// if class = class_scientistic then
16172: LD_VAR 0 3
16176: PUSH
16177: LD_INT 4
16179: EQUAL
16180: IFFALSE 16290
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_INT 2
16189: PUSH
16190: LD_INT 30
16192: PUSH
16193: LD_INT 6
16195: PUSH
16196: EMPTY
16197: LIST
16198: LIST
16199: PUSH
16200: LD_INT 30
16202: PUSH
16203: LD_INT 7
16205: PUSH
16206: EMPTY
16207: LIST
16208: LIST
16209: PUSH
16210: LD_INT 30
16212: PUSH
16213: LD_INT 8
16215: PUSH
16216: EMPTY
16217: LIST
16218: LIST
16219: PUSH
16220: EMPTY
16221: LIST
16222: LIST
16223: LIST
16224: LIST
16225: PPUSH
16226: CALL 10967 0 2
16230: IFFALSE 16290
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16232: LD_ADDR_VAR 0 6
16236: PUSH
16237: LD_VAR 0 1
16241: PPUSH
16242: LD_INT 2
16244: PUSH
16245: LD_INT 30
16247: PUSH
16248: LD_INT 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: PUSH
16255: LD_INT 30
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PUSH
16265: LD_INT 30
16267: PUSH
16268: LD_INT 8
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: LIST
16279: LIST
16280: PPUSH
16281: CALL 10967 0 2
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: ST_TO_ADDR
// if GetClass ( unit ) = class then
16290: LD_VAR 0 2
16294: PPUSH
16295: CALL_OW 257
16299: PUSH
16300: LD_VAR 0 3
16304: EQUAL
16305: IFFALSE 16339
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16307: LD_ADDR_EXP 48
16311: PUSH
16312: LD_EXP 48
16316: PPUSH
16317: LD_VAR 0 1
16321: PPUSH
16322: LD_VAR 0 2
16326: PPUSH
16327: LD_VAR 0 3
16331: PPUSH
16332: CALL 39804 0 4
16336: ST_TO_ADDR
// end else
16337: GO 16432
// if b then
16339: LD_VAR 0 6
16343: IFFALSE 16424
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16345: LD_VAR 0 2
16349: PPUSH
16350: CALL_OW 310
16354: PUSH
16355: LD_VAR 0 2
16359: PPUSH
16360: CALL_OW 310
16364: PUSH
16365: LD_VAR 0 6
16369: NONEQUAL
16370: AND
16371: IFFALSE 16382
// ComExitBuilding ( unit ) ;
16373: LD_VAR 0 2
16377: PPUSH
16378: CALL_OW 122
// if not IsInUnit ( unit ) then
16382: LD_VAR 0 2
16386: PPUSH
16387: CALL_OW 310
16391: NOT
16392: IFFALSE 16408
// ComEnterUnit ( unit , b ) ;
16394: LD_VAR 0 2
16398: PPUSH
16399: LD_VAR 0 6
16403: PPUSH
16404: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16408: LD_VAR 0 2
16412: PPUSH
16413: LD_VAR 0 3
16417: PPUSH
16418: CALL_OW 183
// end else
16422: GO 16432
// result := false ;
16424: LD_ADDR_VAR 0 4
16428: PUSH
16429: LD_INT 0
16431: ST_TO_ADDR
// end ; end_of_file
16432: LD_VAR 0 4
16436: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16437: LD_INT 0
16439: PPUSH
16440: PPUSH
16441: PPUSH
16442: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16443: LD_ADDR_VAR 0 5
16447: PUSH
16448: LD_INT 35
16450: PUSH
16451: LD_INT 45
16453: PUSH
16454: LD_INT 46
16456: PUSH
16457: LD_INT 47
16459: PUSH
16460: LD_INT 1
16462: PUSH
16463: LD_INT 2
16465: PUSH
16466: LD_INT 48
16468: PUSH
16469: LD_INT 49
16471: PUSH
16472: LD_INT 50
16474: PUSH
16475: LD_INT 20
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: LIST
16482: LIST
16483: LIST
16484: LIST
16485: LIST
16486: LIST
16487: LIST
16488: LIST
16489: ST_TO_ADDR
// if MCF_Lab ( side ) then
16490: LD_VAR 0 1
16494: PPUSH
16495: CALL 11006 0 1
16499: IFFALSE 16738
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16501: LD_VAR 0 1
16505: PPUSH
16506: CALL 11006 0 1
16510: PUSH
16511: LD_INT 1
16513: ARRAY
16514: PPUSH
16515: CALL_OW 461
16519: PUSH
16520: LD_INT 2
16522: EQUAL
16523: IFFALSE 16662
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16525: LD_VAR 0 1
16529: PPUSH
16530: CALL 11006 0 1
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 2
16543: PPUSH
16544: CALL 16834 0 2
16548: IFFALSE 16575
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
16550: LD_VAR 0 1
16554: PPUSH
16555: CALL 11006 0 1
16559: PUSH
16560: LD_INT 1
16562: ARRAY
16563: PPUSH
16564: LD_VAR 0 2
16568: PPUSH
16569: CALL_OW 124
16573: GO 16662
// if MCF_Lab ( side ) > 1 then
16575: LD_VAR 0 1
16579: PPUSH
16580: CALL 11006 0 1
16584: PUSH
16585: LD_INT 1
16587: GREATER
16588: IFFALSE 16662
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
16590: LD_VAR 0 1
16594: PPUSH
16595: CALL 11006 0 1
16599: PUSH
16600: LD_INT 2
16602: ARRAY
16603: PPUSH
16604: CALL_OW 461
16608: PUSH
16609: LD_INT 2
16611: EQUAL
16612: IFFALSE 16662
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
16614: LD_VAR 0 1
16618: PPUSH
16619: CALL 11006 0 1
16623: PUSH
16624: LD_INT 2
16626: ARRAY
16627: PPUSH
16628: LD_VAR 0 2
16632: PPUSH
16633: CALL 16834 0 2
16637: IFFALSE 16662
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
16639: LD_VAR 0 1
16643: PPUSH
16644: CALL 11006 0 1
16648: PUSH
16649: LD_INT 2
16651: ARRAY
16652: PPUSH
16653: LD_VAR 0 2
16657: PPUSH
16658: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
16662: LD_VAR 0 2
16666: PUSH
16667: LD_INT 2
16669: PUSH
16670: LD_INT 11
16672: PUSH
16673: LD_INT 4
16675: PUSH
16676: LD_INT 3
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: LIST
16683: LIST
16684: IN
16685: IFFALSE 16738
// begin for lab in MCF_Lab ( side ) do
16687: LD_ADDR_VAR 0 6
16691: PUSH
16692: LD_VAR 0 1
16696: PPUSH
16697: CALL 11006 0 1
16701: PUSH
16702: FOR_IN
16703: IFFALSE 16736
// if BuildingStatus ( lab ) = bs_need_ape then
16705: LD_VAR 0 6
16709: PPUSH
16710: CALL_OW 461
16714: PUSH
16715: LD_INT 10
16717: EQUAL
16718: IFFALSE 16734
// MCL_ResTame ( side , lab ) ;
16720: LD_VAR 0 1
16724: PPUSH
16725: LD_VAR 0 6
16729: PPUSH
16730: CALL 16959 0 2
16734: GO 16702
16736: POP
16737: POP
// end ; end ; end ;
16738: LD_VAR 0 3
16742: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
16743: LD_INT 0
16745: PPUSH
16746: PPUSH
// tmp := [ ] ;
16747: LD_ADDR_VAR 0 3
16751: PUSH
16752: EMPTY
16753: ST_TO_ADDR
// if not lab then
16754: LD_VAR 0 1
16758: NOT
16759: IFFALSE 16771
// result := false else
16761: LD_ADDR_VAR 0 2
16765: PUSH
16766: LD_INT 0
16768: ST_TO_ADDR
16769: GO 16829
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
16771: LD_ADDR_VAR 0 3
16775: PUSH
16776: LD_VAR 0 3
16780: PUSH
16781: LD_VAR 0 1
16785: PPUSH
16786: LD_INT 1
16788: PPUSH
16789: CALL_OW 268
16793: ADD
16794: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
16795: LD_ADDR_VAR 0 3
16799: PUSH
16800: LD_VAR 0 3
16804: PUSH
16805: LD_VAR 0 1
16809: PPUSH
16810: LD_INT 2
16812: PPUSH
16813: CALL_OW 268
16817: ADD
16818: ST_TO_ADDR
// result := tmp ;
16819: LD_ADDR_VAR 0 2
16823: PUSH
16824: LD_VAR 0 3
16828: ST_TO_ADDR
// end ; end ;
16829: LD_VAR 0 2
16833: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
16834: LD_INT 0
16836: PPUSH
16837: PPUSH
16838: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16839: LD_ADDR_VAR 0 5
16843: PUSH
16844: LD_INT 35
16846: PUSH
16847: LD_INT 45
16849: PUSH
16850: LD_INT 46
16852: PUSH
16853: LD_INT 47
16855: PUSH
16856: LD_INT 1
16858: PUSH
16859: LD_INT 2
16861: PUSH
16862: LD_INT 48
16864: PUSH
16865: LD_INT 49
16867: PUSH
16868: LD_INT 50
16870: PUSH
16871: LD_INT 20
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: LIST
16878: LIST
16879: LIST
16880: LIST
16881: LIST
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if lab then
16886: LD_VAR 0 1
16890: IFFALSE 16946
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
16892: LD_VAR 0 2
16896: PUSH
16897: LD_VAR 0 5
16901: IN
16902: PUSH
16903: LD_VAR 0 2
16907: PPUSH
16908: CALL_OW 481
16912: PUSH
16913: LD_VAR 0 1
16917: PPUSH
16918: CALL 16743 0 1
16922: IN
16923: OR
16924: IFFALSE 16936
// result := true else
16926: LD_ADDR_VAR 0 3
16930: PUSH
16931: LD_INT 1
16933: ST_TO_ADDR
16934: GO 16944
// result := false ;
16936: LD_ADDR_VAR 0 3
16940: PUSH
16941: LD_INT 0
16943: ST_TO_ADDR
// end else
16944: GO 16954
// result := false ;
16946: LD_ADDR_VAR 0 3
16950: PUSH
16951: LD_INT 0
16953: ST_TO_ADDR
// end ;
16954: LD_VAR 0 3
16958: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
16959: LD_INT 0
16961: PPUSH
16962: PPUSH
16963: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
16964: LD_ADDR_VAR 0 4
16968: PUSH
16969: LD_VAR 0 1
16973: PPUSH
16974: LD_INT 171
16976: PPUSH
16977: EMPTY
16978: PPUSH
16979: CALL 11670 0 3
16983: ST_TO_ADDR
// if not ape then
16984: LD_VAR 0 4
16988: NOT
16989: IFFALSE 17021
// if MCF_Ape ( side ) then
16991: LD_VAR 0 1
16995: PPUSH
16996: CALL 11380 0 1
17000: IFFALSE 17021
// ape := MCF_Ape ( side ) [ 1 ] ;
17002: LD_ADDR_VAR 0 4
17006: PUSH
17007: LD_VAR 0 1
17011: PPUSH
17012: CALL 11380 0 1
17016: PUSH
17017: LD_INT 1
17019: ARRAY
17020: ST_TO_ADDR
// if ape then
17021: LD_VAR 0 4
17025: IFFALSE 17076
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17027: LD_VAR 0 4
17031: PUSH
17032: LD_INT 1
17034: ARRAY
17035: PPUSH
17036: CALL_OW 310
17040: PUSH
17041: LD_VAR 0 4
17045: PUSH
17046: LD_INT 1
17048: ARRAY
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: NONEQUAL
17060: AND
17061: IFFALSE 17076
// ComExitBuilding ( ape [ 1 ] ) ;
17063: LD_VAR 0 4
17067: PUSH
17068: LD_INT 1
17070: ARRAY
17071: PPUSH
17072: CALL_OW 122
// if not lab then
17076: LD_VAR 0 2
17080: NOT
17081: IFFALSE 17087
// exit else
17083: GO 17235
17085: GO 17195
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17087: LD_VAR 0 1
17091: PPUSH
17092: LD_INT 16
17094: PPUSH
17095: LD_INT 25
17097: PUSH
17098: LD_INT 4
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: PPUSH
17105: CALL 11670 0 3
17109: PUSH
17110: LD_INT 0
17112: EQUAL
17113: PUSH
17114: LD_VAR 0 2
17118: PPUSH
17119: CALL_OW 313
17123: PUSH
17124: LD_INT 6
17126: EQUAL
17127: AND
17128: IFFALSE 17195
// begin tmp := UnitsInside ( lab ) ;
17130: LD_ADDR_VAR 0 5
17134: PUSH
17135: LD_VAR 0 2
17139: PPUSH
17140: CALL_OW 313
17144: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17145: LD_VAR 0 5
17149: PUSH
17150: LD_VAR 0 5
17154: ARRAY
17155: PPUSH
17156: LD_INT 16
17158: PPUSH
17159: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17163: LD_VAR 0 5
17167: PUSH
17168: LD_VAR 0 5
17172: ARRAY
17173: PPUSH
17174: CALL_OW 310
17178: IFFALSE 17195
// ComExitBuilding ( tmp [ tmp ] ) ;
17180: LD_VAR 0 5
17184: PUSH
17185: LD_VAR 0 5
17189: ARRAY
17190: PPUSH
17191: CALL_OW 122
// end ; if ape then
17195: LD_VAR 0 4
17199: IFFALSE 17235
// if not IsInUnit ( ape [ 1 ] ) then
17201: LD_VAR 0 4
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: PPUSH
17210: CALL_OW 310
17214: NOT
17215: IFFALSE 17235
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17217: LD_VAR 0 4
17221: PUSH
17222: LD_INT 1
17224: ARRAY
17225: PPUSH
17226: LD_VAR 0 2
17230: PPUSH
17231: CALL_OW 120
// end ;
17235: LD_VAR 0 3
17239: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17240: LD_INT 0
17242: PPUSH
17243: PPUSH
17244: PPUSH
// result := false ;
17245: LD_ADDR_VAR 0 2
17249: PUSH
17250: LD_INT 0
17252: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17253: LD_ADDR_VAR 0 3
17257: PUSH
17258: LD_VAR 0 1
17262: PPUSH
17263: CALL 17350 0 1
17267: ST_TO_ADDR
// if techs then
17268: LD_VAR 0 3
17272: IFFALSE 17302
// if techs [ 2 ] then
17274: LD_VAR 0 3
17278: PUSH
17279: LD_INT 2
17281: ARRAY
17282: IFFALSE 17294
// result := true else
17284: LD_ADDR_VAR 0 2
17288: PUSH
17289: LD_INT 1
17291: ST_TO_ADDR
17292: GO 17302
// result := false ;
17294: LD_ADDR_VAR 0 2
17298: PUSH
17299: LD_INT 0
17301: ST_TO_ADDR
// end ;
17302: LD_VAR 0 2
17306: RET
// export function MCL_Start ( side ) ; var i ; begin
17307: LD_INT 0
17309: PPUSH
17310: PPUSH
// if MCL_GetTechList ( side ) then
17311: LD_VAR 0 1
17315: PPUSH
17316: CALL 17350 0 1
17320: IFFALSE 17345
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17322: LD_VAR 0 1
17326: PPUSH
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL 17350 0 1
17336: PUSH
17337: LD_INT 1
17339: ARRAY
17340: PPUSH
17341: CALL 16437 0 2
// end ;
17345: LD_VAR 0 2
17349: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17350: LD_INT 0
17352: PPUSH
17353: PPUSH
17354: PPUSH
// if MREG_ToRes then
17355: LD_EXP 45
17359: IFFALSE 17444
// for i = 1 to MREG_ToRes do
17361: LD_ADDR_VAR 0 3
17365: PUSH
17366: DOUBLE
17367: LD_INT 1
17369: DEC
17370: ST_TO_ADDR
17371: LD_EXP 45
17375: PUSH
17376: FOR_TO
17377: IFFALSE 17442
// if MREG_ToRes [ i ] [ 1 ] = side then
17379: LD_EXP 45
17383: PUSH
17384: LD_VAR 0 3
17388: ARRAY
17389: PUSH
17390: LD_INT 1
17392: ARRAY
17393: PUSH
17394: LD_VAR 0 1
17398: EQUAL
17399: IFFALSE 17440
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17401: LD_ADDR_VAR 0 4
17405: PUSH
17406: LD_VAR 0 4
17410: PPUSH
17411: LD_VAR 0 4
17415: PUSH
17416: LD_INT 1
17418: PLUS
17419: PPUSH
17420: LD_EXP 45
17424: PUSH
17425: LD_VAR 0 3
17429: ARRAY
17430: PUSH
17431: LD_INT 2
17433: ARRAY
17434: PPUSH
17435: CALL_OW 1
17439: ST_TO_ADDR
// end ;
17440: GO 17376
17442: POP
17443: POP
// result := techs ;
17444: LD_ADDR_VAR 0 2
17448: PUSH
17449: LD_VAR 0 4
17453: ST_TO_ADDR
// end ;
17454: LD_VAR 0 2
17458: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17459: LD_INT 0
17461: PPUSH
17462: PPUSH
// for i = 1 to tech_list do
17463: LD_ADDR_VAR 0 4
17467: PUSH
17468: DOUBLE
17469: LD_INT 1
17471: DEC
17472: ST_TO_ADDR
17473: LD_VAR 0 2
17477: PUSH
17478: FOR_TO
17479: IFFALSE 17533
// if not tech_list [ i ] = 20 then
17481: LD_VAR 0 2
17485: PUSH
17486: LD_VAR 0 4
17490: ARRAY
17491: PUSH
17492: LD_INT 20
17494: EQUAL
17495: NOT
17496: IFFALSE 17531
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17498: LD_ADDR_EXP 45
17502: PUSH
17503: LD_EXP 45
17507: PPUSH
17508: LD_VAR 0 1
17512: PPUSH
17513: LD_VAR 0 2
17517: PUSH
17518: LD_VAR 0 4
17522: ARRAY
17523: PPUSH
17524: EMPTY
17525: PPUSH
17526: CALL 39713 0 4
17530: ST_TO_ADDR
17531: GO 17478
17533: POP
17534: POP
// result := true ;
17535: LD_ADDR_VAR 0 3
17539: PUSH
17540: LD_INT 1
17542: ST_TO_ADDR
// end ;
17543: LD_VAR 0 3
17547: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
17548: LD_INT 0
17550: PPUSH
17551: PPUSH
// for i = MREG_ToRes downto 1 do
17552: LD_ADDR_VAR 0 3
17556: PUSH
17557: DOUBLE
17558: LD_EXP 45
17562: INC
17563: ST_TO_ADDR
17564: LD_INT 1
17566: PUSH
17567: FOR_DOWNTO
17568: IFFALSE 17614
// if MREG_ToRes [ i ] [ 1 ] = side then
17570: LD_EXP 45
17574: PUSH
17575: LD_VAR 0 3
17579: ARRAY
17580: PUSH
17581: LD_INT 1
17583: ARRAY
17584: PUSH
17585: LD_VAR 0 1
17589: EQUAL
17590: IFFALSE 17612
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
17592: LD_ADDR_EXP 45
17596: PUSH
17597: LD_EXP 45
17601: PPUSH
17602: LD_VAR 0 3
17606: PPUSH
17607: CALL_OW 3
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// result := true ;
17616: LD_ADDR_VAR 0 2
17620: PUSH
17621: LD_INT 1
17623: ST_TO_ADDR
// end ;
17624: LD_VAR 0 2
17628: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
17629: LD_INT 0
17631: PPUSH
// result := GetTechProgress ( side , tech ) ;
17632: LD_ADDR_VAR 0 3
17636: PUSH
17637: LD_VAR 0 1
17641: PPUSH
17642: LD_VAR 0 2
17646: PPUSH
17647: CALL_OW 326
17651: ST_TO_ADDR
// end ;
17652: LD_VAR 0 3
17656: RET
// export function MCL_Require ( tech ) ; begin
17657: LD_INT 0
17659: PPUSH
// result := GetTechTechsReq ( tech ) ;
17660: LD_ADDR_VAR 0 2
17664: PUSH
17665: LD_VAR 0 1
17669: PPUSH
17670: CALL_OW 480
17674: ST_TO_ADDR
// end ; end_of_file
17675: LD_VAR 0 2
17679: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
17680: LD_INT 0
17682: PPUSH
17683: PPUSH
17684: PPUSH
// uc_side := 0 ;
17685: LD_ADDR_OWVAR 20
17689: PUSH
17690: LD_INT 0
17692: ST_TO_ADDR
// uc_nation := 0 ;
17693: LD_ADDR_OWVAR 21
17697: PUSH
17698: LD_INT 0
17700: ST_TO_ADDR
// for i = 1 to n do
17701: LD_ADDR_VAR 0 5
17705: PUSH
17706: DOUBLE
17707: LD_INT 1
17709: DEC
17710: ST_TO_ADDR
17711: LD_VAR 0 2
17715: PUSH
17716: FOR_TO
17717: IFFALSE 17862
// begin hc_importance := 0 ;
17719: LD_ADDR_OWVAR 32
17723: PUSH
17724: LD_INT 0
17726: ST_TO_ADDR
// hc_gallery :=  ;
17727: LD_ADDR_OWVAR 33
17731: PUSH
17732: LD_STRING 
17734: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
17735: LD_ADDR_OWVAR 35
17739: PUSH
17740: LD_VAR 0 3
17744: PUSH
17745: LD_INT 20
17747: MINUS
17748: PPUSH
17749: LD_VAR 0 3
17753: PUSH
17754: LD_INT 20
17756: PLUS
17757: PPUSH
17758: CALL_OW 12
17762: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
17763: LD_ADDR_OWVAR 31
17767: PUSH
17768: LD_INT 0
17770: PPUSH
17771: LD_INT 2
17773: PPUSH
17774: CALL_OW 12
17778: PUSH
17779: LD_INT 0
17781: PUSH
17782: LD_INT 0
17784: PUSH
17785: LD_INT 0
17787: PUSH
17788: EMPTY
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
17794: LD_ADDR_OWVAR 30
17798: PUSH
17799: LD_INT 0
17801: PUSH
17802: LD_INT 0
17804: PUSH
17805: LD_INT 0
17807: PUSH
17808: LD_INT 0
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: ST_TO_ADDR
// hc_name :=  ;
17817: LD_ADDR_OWVAR 26
17821: PUSH
17822: LD_STRING 
17824: ST_TO_ADDR
// hc_class := class_apeman ;
17825: LD_ADDR_OWVAR 28
17829: PUSH
17830: LD_INT 12
17832: ST_TO_ADDR
// ape := CreateHuman ;
17833: LD_ADDR_VAR 0 6
17837: PUSH
17838: CALL_OW 44
17842: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
17843: LD_VAR 0 6
17847: PPUSH
17848: LD_VAR 0 1
17852: PPUSH
17853: LD_INT 0
17855: PPUSH
17856: CALL_OW 49
// end ;
17860: GO 17716
17862: POP
17863: POP
// end ;
17864: LD_VAR 0 4
17868: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
17869: LD_INT 0
17871: PPUSH
17872: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
17873: LD_VAR 0 1
17877: PPUSH
17878: CALL 11380 0 1
17882: PUSH
17883: LD_EXP 32
17887: PUSH
17888: LD_VAR 0 1
17892: ARRAY
17893: GREATEREQUAL
17894: IFFALSE 18071
// begin if GetTag ( unit ) = 17 then
17896: LD_VAR 0 2
17900: PPUSH
17901: CALL_OW 110
17905: PUSH
17906: LD_INT 17
17908: EQUAL
17909: IFFALSE 18069
// begin SetTag ( unit , 0 ) ;
17911: LD_VAR 0 2
17915: PPUSH
17916: LD_INT 0
17918: PPUSH
17919: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
17923: LD_VAR 0 1
17927: PPUSH
17928: CALL 11006 0 1
17932: PUSH
17933: LD_VAR 0 1
17937: PPUSH
17938: CALL 17350 0 1
17942: NOT
17943: AND
17944: IFFALSE 17969
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
17946: LD_VAR 0 2
17950: PPUSH
17951: LD_VAR 0 1
17955: PPUSH
17956: CALL 11006 0 1
17960: PUSH
17961: LD_INT 1
17963: ARRAY
17964: PPUSH
17965: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
17969: LD_VAR 0 1
17973: PPUSH
17974: CALL 11006 0 1
17978: NOT
17979: PUSH
17980: LD_VAR 0 1
17984: PPUSH
17985: LD_INT 30
17987: PUSH
17988: LD_INT 1
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PPUSH
17995: CALL 10967 0 2
17999: AND
18000: IFFALSE 18069
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18002: LD_VAR 0 2
18006: PPUSH
18007: LD_VAR 0 1
18011: PPUSH
18012: LD_INT 30
18014: PUSH
18015: LD_INT 1
18017: PUSH
18018: EMPTY
18019: LIST
18020: LIST
18021: PPUSH
18022: CALL 10967 0 2
18026: PUSH
18027: LD_INT 1
18029: ARRAY
18030: PPUSH
18031: CALL_OW 250
18035: PPUSH
18036: LD_VAR 0 1
18040: PPUSH
18041: LD_INT 30
18043: PUSH
18044: LD_INT 1
18046: PUSH
18047: EMPTY
18048: LIST
18049: LIST
18050: PPUSH
18051: CALL 10967 0 2
18055: PUSH
18056: LD_INT 1
18058: ARRAY
18059: PPUSH
18060: CALL_OW 251
18064: PPUSH
18065: CALL_OW 111
// end ; end else
18069: GO 18255
// if GetClass ( unit ) <> 4 then
18071: LD_VAR 0 2
18075: PPUSH
18076: CALL_OW 257
18080: PUSH
18081: LD_INT 4
18083: NONEQUAL
18084: IFFALSE 18090
// exit else
18086: GO 18255
18088: GO 18255
// if GetTag ( unit ) = 0 then
18090: LD_VAR 0 2
18094: PPUSH
18095: CALL_OW 110
18099: PUSH
18100: LD_INT 0
18102: EQUAL
18103: IFFALSE 18119
// SetTag ( unit , 17 ) else
18105: LD_VAR 0 2
18109: PPUSH
18110: LD_INT 17
18112: PPUSH
18113: CALL_OW 109
18117: GO 18255
// begin if IsInUnit ( unit ) then
18119: LD_VAR 0 2
18123: PPUSH
18124: CALL_OW 310
18128: IFFALSE 18139
// ComExitBuilding ( unit ) ;
18130: LD_VAR 0 2
18134: PPUSH
18135: CALL_OW 122
// Wait ( 1 ) ;
18139: LD_INT 1
18141: PPUSH
18142: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18146: LD_ADDR_VAR 0 4
18150: PUSH
18151: LD_INT 22
18153: PUSH
18154: LD_INT 0
18156: PUSH
18157: EMPTY
18158: LIST
18159: LIST
18160: PUSH
18161: LD_INT 25
18163: PUSH
18164: LD_INT 12
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PPUSH
18175: CALL_OW 69
18179: PPUSH
18180: LD_VAR 0 2
18184: PPUSH
18185: CALL_OW 74
18189: ST_TO_ADDR
// if not ape then
18190: LD_VAR 0 4
18194: NOT
18195: IFFALSE 18201
// exit else
18197: GO 18255
18199: GO 18210
// ComHold ( ape ) ;
18201: LD_VAR 0 4
18205: PPUSH
18206: CALL_OW 140
// if not HasTask ( unit ) then
18210: LD_VAR 0 2
18214: PPUSH
18215: CALL_OW 314
18219: NOT
18220: IFFALSE 18253
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18222: LD_VAR 0 2
18226: PPUSH
18227: LD_VAR 0 4
18231: PPUSH
18232: CALL_OW 250
18236: PPUSH
18237: LD_VAR 0 4
18241: PPUSH
18242: CALL_OW 251
18246: PPUSH
18247: CALL_OW 131
18251: GO 18255
// exit ;
18253: GO 18255
// end ; end ;
18255: LD_VAR 0 3
18259: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18260: LD_INT 0
18262: PPUSH
18263: PPUSH
18264: PPUSH
18265: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18266: LD_ADDR_VAR 0 4
18270: PUSH
18271: LD_EXP 33
18275: PUSH
18276: LD_VAR 0 1
18280: ARRAY
18281: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18282: LD_ADDR_VAR 0 5
18286: PUSH
18287: LD_VAR 0 1
18291: PPUSH
18292: LD_STRING normal
18294: PPUSH
18295: CALL 11464 0 2
18299: ST_TO_ADDR
// if apes then
18300: LD_VAR 0 5
18304: IFFALSE 18532
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18306: LD_INT 2
18308: PPUSH
18309: LD_VAR 0 1
18313: PPUSH
18314: CALL_OW 321
18318: PUSH
18319: LD_INT 2
18321: EQUAL
18322: PUSH
18323: LD_VAR 0 4
18327: PUSH
18328: LD_INT 2
18330: ARRAY
18331: PUSH
18332: LD_INT 1
18334: EQUAL
18335: AND
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_STRING engineer
18344: PPUSH
18345: CALL 11464 0 2
18349: PUSH
18350: LD_INT 3
18352: LESS
18353: AND
18354: PUSH
18355: LD_VAR 0 1
18359: PPUSH
18360: LD_INT 30
18362: PUSH
18363: LD_INT 1
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: PPUSH
18370: CALL 10967 0 2
18374: AND
18375: IFFALSE 18429
// begin for i in apes do
18377: LD_ADDR_VAR 0 3
18381: PUSH
18382: LD_VAR 0 5
18386: PUSH
18387: FOR_IN
18388: IFFALSE 18425
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18390: LD_VAR 0 3
18394: PPUSH
18395: LD_VAR 0 1
18399: PPUSH
18400: LD_INT 30
18402: PUSH
18403: LD_INT 1
18405: PUSH
18406: EMPTY
18407: LIST
18408: LIST
18409: PPUSH
18410: CALL 10967 0 2
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// end ;
18423: GO 18387
18425: POP
18426: POP
// end else
18427: GO 18532
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18429: LD_INT 11
18431: PPUSH
18432: LD_VAR 0 1
18436: PPUSH
18437: CALL_OW 321
18441: PUSH
18442: LD_INT 2
18444: EQUAL
18445: PUSH
18446: LD_VAR 0 4
18450: PUSH
18451: LD_INT 1
18453: ARRAY
18454: PUSH
18455: LD_INT 1
18457: EQUAL
18458: AND
18459: PUSH
18460: LD_VAR 0 1
18464: PPUSH
18465: LD_INT 30
18467: PUSH
18468: LD_INT 5
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: PPUSH
18475: CALL 10967 0 2
18479: AND
18480: IFFALSE 18532
// begin for i in apes do
18482: LD_ADDR_VAR 0 3
18486: PUSH
18487: LD_VAR 0 5
18491: PUSH
18492: FOR_IN
18493: IFFALSE 18530
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18495: LD_VAR 0 3
18499: PPUSH
18500: LD_VAR 0 1
18504: PPUSH
18505: LD_INT 30
18507: PUSH
18508: LD_INT 5
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: PPUSH
18515: CALL 10967 0 2
18519: PUSH
18520: LD_INT 1
18522: ARRAY
18523: PPUSH
18524: CALL_OW 120
// end ;
18528: GO 18492
18530: POP
18531: POP
// end ; end ; end ; end_of_file
18532: LD_VAR 0 2
18536: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18537: LD_INT 0
18539: PPUSH
18540: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18541: LD_VAR 0 1
18545: PPUSH
18546: CALL_OW 257
18550: PUSH
18551: LD_INT 4
18553: EQUAL
18554: NOT
18555: PUSH
18556: LD_VAR 0 2
18560: NOT
18561: OR
18562: IFFALSE 18568
// exit else
18564: GO 18602
18566: GO 18602
// if not GetTag ( unit ) = 4 then
18568: LD_VAR 0 1
18572: PPUSH
18573: CALL_OW 110
18577: PUSH
18578: LD_INT 4
18580: EQUAL
18581: NOT
18582: IFFALSE 18588
// exit else
18584: GO 18602
18586: GO 18602
// ComHeal ( unit , target ) ;
18588: LD_VAR 0 1
18592: PPUSH
18593: LD_VAR 0 2
18597: PPUSH
18598: CALL_OW 128
// end ;
18602: LD_VAR 0 3
18606: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
18607: LD_INT 0
18609: PPUSH
18610: PPUSH
18611: PPUSH
18612: PPUSH
18613: PPUSH
18614: PPUSH
18615: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
18616: LD_ADDR_VAR 0 5
18620: PUSH
18621: LD_INT 22
18623: PUSH
18624: LD_VAR 0 1
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 21
18635: PUSH
18636: LD_INT 1
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: PUSH
18643: LD_INT 3
18645: PUSH
18646: LD_INT 55
18648: PUSH
18649: EMPTY
18650: LIST
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: PUSH
18656: LD_INT 3
18658: PUSH
18659: LD_INT 54
18661: PUSH
18662: EMPTY
18663: LIST
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: PUSH
18669: LD_INT 3
18671: PUSH
18672: LD_INT 24
18674: PUSH
18675: LD_INT 1000
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: PPUSH
18693: CALL_OW 69
18697: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
18698: LD_ADDR_VAR 0 8
18702: PUSH
18703: LD_VAR 0 1
18707: PPUSH
18708: LD_INT 30
18710: PUSH
18711: LD_INT 1
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PPUSH
18718: CALL 10967 0 2
18722: ST_TO_ADDR
// r := [ ] ;
18723: LD_ADDR_VAR 0 6
18727: PUSH
18728: EMPTY
18729: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
18730: LD_VAR 0 1
18734: PPUSH
18735: LD_INT 5
18737: PPUSH
18738: EMPTY
18739: PPUSH
18740: CALL 11670 0 3
18744: IFFALSE 18800
// for j in MCF_Tag ( side , 5 , [ ] ) do
18746: LD_ADDR_VAR 0 4
18750: PUSH
18751: LD_VAR 0 1
18755: PPUSH
18756: LD_INT 5
18758: PPUSH
18759: EMPTY
18760: PPUSH
18761: CALL 11670 0 3
18765: PUSH
18766: FOR_IN
18767: IFFALSE 18798
// if GetLives ( j ) = 1000 then
18769: LD_VAR 0 4
18773: PPUSH
18774: CALL_OW 256
18778: PUSH
18779: LD_INT 1000
18781: EQUAL
18782: IFFALSE 18796
// SetTag ( j , 0 ) ;
18784: LD_VAR 0 4
18788: PPUSH
18789: LD_INT 0
18791: PPUSH
18792: CALL_OW 109
18796: GO 18766
18798: POP
18799: POP
// if tmp then
18800: LD_VAR 0 5
18804: IFFALSE 19133
// begin r := [ tmp [ 1 ] ] ;
18806: LD_ADDR_VAR 0 6
18810: PUSH
18811: LD_VAR 0 5
18815: PUSH
18816: LD_INT 1
18818: ARRAY
18819: PUSH
18820: EMPTY
18821: LIST
18822: ST_TO_ADDR
// for i = 2 to tmp do
18823: LD_ADDR_VAR 0 3
18827: PUSH
18828: DOUBLE
18829: LD_INT 2
18831: DEC
18832: ST_TO_ADDR
18833: LD_VAR 0 5
18837: PUSH
18838: FOR_TO
18839: IFFALSE 19131
// begin m := false ;
18841: LD_ADDR_VAR 0 7
18845: PUSH
18846: LD_INT 0
18848: ST_TO_ADDR
// if d then
18849: LD_VAR 0 8
18853: IFFALSE 19008
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
18855: LD_VAR 0 5
18859: PUSH
18860: LD_VAR 0 3
18864: ARRAY
18865: PPUSH
18866: CALL_OW 256
18870: PUSH
18871: LD_INT 650
18873: LESS
18874: PUSH
18875: LD_VAR 0 5
18879: PUSH
18880: LD_VAR 0 3
18884: ARRAY
18885: PPUSH
18886: LD_VAR 0 8
18890: PUSH
18891: LD_INT 1
18893: ARRAY
18894: PPUSH
18895: CALL_OW 250
18899: PPUSH
18900: LD_VAR 0 8
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: PPUSH
18909: CALL_OW 251
18913: PPUSH
18914: CALL_OW 297
18918: PUSH
18919: LD_INT 10
18921: GREATER
18922: AND
18923: IFFALSE 19008
// begin if not GetTag ( tmp [ i ] ) = 5 then
18925: LD_VAR 0 5
18929: PUSH
18930: LD_VAR 0 3
18934: ARRAY
18935: PPUSH
18936: CALL_OW 110
18940: PUSH
18941: LD_INT 5
18943: EQUAL
18944: NOT
18945: IFFALSE 18965
// SetTag ( tmp [ i ] , 5 ) ;
18947: LD_VAR 0 5
18951: PUSH
18952: LD_VAR 0 3
18956: ARRAY
18957: PPUSH
18958: LD_INT 5
18960: PPUSH
18961: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
18965: LD_VAR 0 5
18969: PUSH
18970: LD_VAR 0 3
18974: ARRAY
18975: PPUSH
18976: LD_VAR 0 8
18980: PUSH
18981: LD_INT 1
18983: ARRAY
18984: PPUSH
18985: CALL_OW 250
18989: PPUSH
18990: LD_VAR 0 8
18994: PUSH
18995: LD_INT 1
18997: ARRAY
18998: PPUSH
18999: CALL_OW 251
19003: PPUSH
19004: CALL_OW 111
// end ; for j = 1 to r do
19008: LD_ADDR_VAR 0 4
19012: PUSH
19013: DOUBLE
19014: LD_INT 1
19016: DEC
19017: ST_TO_ADDR
19018: LD_VAR 0 6
19022: PUSH
19023: FOR_TO
19024: IFFALSE 19098
// if GetLives ( tmp [ i ] ) < r [ j ] then
19026: LD_VAR 0 5
19030: PUSH
19031: LD_VAR 0 3
19035: ARRAY
19036: PPUSH
19037: CALL_OW 256
19041: PUSH
19042: LD_VAR 0 6
19046: PUSH
19047: LD_VAR 0 4
19051: ARRAY
19052: LESS
19053: IFFALSE 19096
// begin r := Insert ( r , j , tmp [ i ] ) ;
19055: LD_ADDR_VAR 0 6
19059: PUSH
19060: LD_VAR 0 6
19064: PPUSH
19065: LD_VAR 0 4
19069: PPUSH
19070: LD_VAR 0 5
19074: PUSH
19075: LD_VAR 0 3
19079: ARRAY
19080: PPUSH
19081: CALL_OW 2
19085: ST_TO_ADDR
// m := true ;
19086: LD_ADDR_VAR 0 7
19090: PUSH
19091: LD_INT 1
19093: ST_TO_ADDR
// break ;
19094: GO 19098
// end ;
19096: GO 19023
19098: POP
19099: POP
// if not m then
19100: LD_VAR 0 7
19104: NOT
19105: IFFALSE 19129
// r := r ^ tmp [ i ] ;
19107: LD_ADDR_VAR 0 6
19111: PUSH
19112: LD_VAR 0 6
19116: PUSH
19117: LD_VAR 0 5
19121: PUSH
19122: LD_VAR 0 3
19126: ARRAY
19127: ADD
19128: ST_TO_ADDR
// end ;
19129: GO 18838
19131: POP
19132: POP
// end ; result := r end ; end_of_file
19133: LD_ADDR_VAR 0 2
19137: PUSH
19138: LD_VAR 0 6
19142: ST_TO_ADDR
19143: LD_VAR 0 2
19147: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19148: LD_INT 0
19150: PPUSH
19151: PPUSH
19152: PPUSH
// pom := GetBase ( bdepot ) ;
19153: LD_ADDR_VAR 0 3
19157: PUSH
19158: LD_VAR 0 1
19162: PPUSH
19163: CALL_OW 274
19167: ST_TO_ADDR
// sor := [ ] ;
19168: LD_ADDR_VAR 0 4
19172: PUSH
19173: EMPTY
19174: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19175: LD_ADDR_VAR 0 4
19179: PUSH
19180: LD_VAR 0 4
19184: PUSH
19185: LD_VAR 0 3
19189: PPUSH
19190: LD_INT 1
19192: PPUSH
19193: CALL_OW 275
19197: ADD
19198: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19199: LD_ADDR_VAR 0 4
19203: PUSH
19204: LD_VAR 0 4
19208: PUSH
19209: LD_VAR 0 3
19213: PPUSH
19214: LD_INT 2
19216: PPUSH
19217: CALL_OW 275
19221: ADD
19222: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19223: LD_ADDR_VAR 0 4
19227: PUSH
19228: LD_VAR 0 4
19232: PUSH
19233: LD_VAR 0 3
19237: PPUSH
19238: LD_INT 3
19240: PPUSH
19241: CALL_OW 275
19245: ADD
19246: ST_TO_ADDR
// result := sor ;
19247: LD_ADDR_VAR 0 2
19251: PUSH
19252: LD_VAR 0 4
19256: ST_TO_ADDR
// end ;
19257: LD_VAR 0 2
19261: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19262: LD_INT 0
19264: PPUSH
19265: PPUSH
// while ( coord_list ) do
19266: LD_VAR 0 3
19270: IFFALSE 19444
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19272: LD_ADDR_EXP 41
19276: PUSH
19277: LD_EXP 41
19281: PPUSH
19282: LD_VAR 0 1
19286: PPUSH
19287: LD_VAR 0 2
19291: PPUSH
19292: LD_VAR 0 3
19296: PUSH
19297: LD_INT 1
19299: ARRAY
19300: PUSH
19301: LD_VAR 0 3
19305: PUSH
19306: LD_INT 2
19308: ARRAY
19309: PUSH
19310: LD_VAR 0 3
19314: PUSH
19315: LD_INT 3
19317: ARRAY
19318: PUSH
19319: EMPTY
19320: LIST
19321: LIST
19322: LIST
19323: PPUSH
19324: CALL 39713 0 4
19328: ST_TO_ADDR
// if weapon_list then
19329: LD_VAR 0 4
19333: IFFALSE 19404
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19335: LD_ADDR_EXP 38
19339: PUSH
19340: LD_EXP 38
19344: PPUSH
19345: LD_VAR 0 1
19349: PPUSH
19350: LD_VAR 0 4
19354: PUSH
19355: LD_INT 1
19357: ARRAY
19358: PPUSH
19359: LD_VAR 0 3
19363: PUSH
19364: LD_INT 1
19366: ARRAY
19367: PUSH
19368: LD_VAR 0 3
19372: PUSH
19373: LD_INT 2
19375: ARRAY
19376: PUSH
19377: EMPTY
19378: LIST
19379: LIST
19380: PPUSH
19381: CALL 39713 0 4
19385: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19386: LD_ADDR_VAR 0 4
19390: PUSH
19391: LD_VAR 0 4
19395: PPUSH
19396: LD_INT 1
19398: PPUSH
19399: CALL_OW 3
19403: ST_TO_ADDR
// end ; for i = 1 to 3 do
19404: LD_ADDR_VAR 0 6
19408: PUSH
19409: DOUBLE
19410: LD_INT 1
19412: DEC
19413: ST_TO_ADDR
19414: LD_INT 3
19416: PUSH
19417: FOR_TO
19418: IFFALSE 19440
// coord_list := Delete ( coord_list , 1 ) ;
19420: LD_ADDR_VAR 0 3
19424: PUSH
19425: LD_VAR 0 3
19429: PPUSH
19430: LD_INT 1
19432: PPUSH
19433: CALL_OW 3
19437: ST_TO_ADDR
19438: GO 19417
19440: POP
19441: POP
// end ;
19442: GO 19266
// result := true ;
19444: LD_ADDR_VAR 0 5
19448: PUSH
19449: LD_INT 1
19451: ST_TO_ADDR
// end ;
19452: LD_VAR 0 5
19456: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19457: LD_INT 0
19459: PPUSH
19460: PPUSH
// if not weapon_list then
19461: LD_VAR 0 3
19465: NOT
19466: IFFALSE 19470
// exit ;
19468: GO 19585
// while ( coord_list ) do
19470: LD_VAR 0 2
19474: IFFALSE 19585
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19476: LD_ADDR_EXP 38
19480: PUSH
19481: LD_EXP 38
19485: PPUSH
19486: LD_VAR 0 1
19490: PPUSH
19491: LD_VAR 0 3
19495: PUSH
19496: LD_INT 1
19498: ARRAY
19499: PPUSH
19500: LD_VAR 0 2
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: LD_VAR 0 2
19513: PUSH
19514: LD_INT 2
19516: ARRAY
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PPUSH
19522: CALL 39713 0 4
19526: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19527: LD_ADDR_VAR 0 3
19531: PUSH
19532: LD_VAR 0 3
19536: PPUSH
19537: LD_INT 1
19539: PPUSH
19540: CALL_OW 3
19544: ST_TO_ADDR
// for i = 1 to 2 do
19545: LD_ADDR_VAR 0 5
19549: PUSH
19550: DOUBLE
19551: LD_INT 1
19553: DEC
19554: ST_TO_ADDR
19555: LD_INT 2
19557: PUSH
19558: FOR_TO
19559: IFFALSE 19581
// coord_list := Delete ( coord_list , 1 ) ;
19561: LD_ADDR_VAR 0 2
19565: PUSH
19566: LD_VAR 0 2
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: CALL_OW 3
19578: ST_TO_ADDR
19579: GO 19558
19581: POP
19582: POP
// end ;
19583: GO 19470
// end ;
19585: LD_VAR 0 4
19589: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
19590: LD_INT 0
19592: PPUSH
19593: PPUSH
// while ( coord_list ) do
19594: LD_VAR 0 2
19598: IFFALSE 19753
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
19600: LD_VAR 0 2
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: LD_VAR 0 2
19613: PUSH
19614: LD_INT 2
19616: ARRAY
19617: PPUSH
19618: CALL_OW 428
19622: IFFALSE 19713
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
19624: LD_VAR 0 2
19628: PUSH
19629: LD_INT 1
19631: ARRAY
19632: PPUSH
19633: LD_VAR 0 2
19637: PUSH
19638: LD_INT 2
19640: ARRAY
19641: PPUSH
19642: CALL_OW 428
19646: PPUSH
19647: CALL_OW 266
19651: PUSH
19652: LD_INT 31
19654: PUSH
19655: LD_INT 32
19657: PUSH
19658: LD_INT 33
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: LIST
19665: IN
19666: IFFALSE 19713
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
19668: LD_ADDR_EXP 47
19672: PUSH
19673: LD_EXP 47
19677: PPUSH
19678: LD_VAR 0 1
19682: PPUSH
19683: LD_VAR 0 2
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: LD_VAR 0 2
19696: PUSH
19697: LD_INT 2
19699: ARRAY
19700: PPUSH
19701: CALL_OW 428
19705: PPUSH
19706: EMPTY
19707: PPUSH
19708: CALL 39713 0 4
19712: ST_TO_ADDR
// for i = 1 to 3 do
19713: LD_ADDR_VAR 0 4
19717: PUSH
19718: DOUBLE
19719: LD_INT 1
19721: DEC
19722: ST_TO_ADDR
19723: LD_INT 3
19725: PUSH
19726: FOR_TO
19727: IFFALSE 19749
// coord_list := Delete ( coord_list , 1 ) ;
19729: LD_ADDR_VAR 0 2
19733: PUSH
19734: LD_VAR 0 2
19738: PPUSH
19739: LD_INT 1
19741: PPUSH
19742: CALL_OW 3
19746: ST_TO_ADDR
19747: GO 19726
19749: POP
19750: POP
// end ;
19751: GO 19594
// result := true ;
19753: LD_ADDR_VAR 0 3
19757: PUSH
19758: LD_INT 1
19760: ST_TO_ADDR
// end ;
19761: LD_VAR 0 3
19765: RET
// export function MCS_Depot ( side , coord_list ) ; begin
19766: LD_INT 0
19768: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
19769: LD_ADDR_EXP 41
19773: PUSH
19774: LD_EXP 41
19778: PPUSH
19779: LD_VAR 0 1
19783: PPUSH
19784: LD_INT 0
19786: PPUSH
19787: LD_VAR 0 2
19791: PPUSH
19792: CALL 39713 0 4
19796: ST_TO_ADDR
// end ;
19797: LD_VAR 0 3
19801: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
19802: LD_INT 0
19804: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
19805: LD_ADDR_EXP 41
19809: PUSH
19810: LD_EXP 41
19814: PPUSH
19815: LD_VAR 0 1
19819: PPUSH
19820: LD_INT 6
19822: PPUSH
19823: LD_VAR 0 2
19827: PPUSH
19828: CALL 39713 0 4
19832: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
19833: LD_ADDR_EXP 44
19837: PUSH
19838: LD_EXP 44
19842: PPUSH
19843: LD_VAR 0 1
19847: PPUSH
19848: LD_VAR 0 3
19852: PUSH
19853: LD_INT 1
19855: ARRAY
19856: PPUSH
19857: LD_VAR 0 3
19861: PUSH
19862: LD_INT 2
19864: ARRAY
19865: PPUSH
19866: CALL 39713 0 4
19870: ST_TO_ADDR
// end ;
19871: LD_VAR 0 4
19875: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
19876: LD_INT 0
19878: PPUSH
19879: PPUSH
// if ext_list > 5 then
19880: LD_VAR 0 3
19884: PUSH
19885: LD_INT 5
19887: GREATER
19888: IFFALSE 19932
// for i = 6 to ext_list do
19890: LD_ADDR_VAR 0 5
19894: PUSH
19895: DOUBLE
19896: LD_INT 6
19898: DEC
19899: ST_TO_ADDR
19900: LD_VAR 0 3
19904: PUSH
19905: FOR_TO
19906: IFFALSE 19930
// ext_list := Delete ( ext_list , ext_list ) ;
19908: LD_ADDR_VAR 0 3
19912: PUSH
19913: LD_VAR 0 3
19917: PPUSH
19918: LD_VAR 0 3
19922: PPUSH
19923: CALL_OW 3
19927: ST_TO_ADDR
19928: GO 19905
19930: POP
19931: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_VAR 0 2
19941: PUSH
19942: LD_INT 1
19944: ARRAY
19945: PPUSH
19946: LD_VAR 0 2
19950: PUSH
19951: LD_INT 2
19953: ARRAY
19954: PPUSH
19955: LD_VAR 0 2
19959: PUSH
19960: LD_INT 3
19962: ARRAY
19963: PPUSH
19964: LD_VAR 0 3
19968: PPUSH
19969: CALL 8479 0 5
// end ;
19973: LD_VAR 0 4
19977: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
19978: LD_INT 0
19980: PPUSH
19981: PPUSH
19982: PPUSH
// p := 1 ;
19983: LD_ADDR_VAR 0 6
19987: PUSH
19988: LD_INT 1
19990: ST_TO_ADDR
// if type_list = [ ] then
19991: LD_VAR 0 3
19995: PUSH
19996: EMPTY
19997: EQUAL
19998: IFFALSE 20008
// type_list := b_oil_power ;
20000: LD_ADDR_VAR 0 3
20004: PUSH
20005: LD_INT 26
20007: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20008: LD_ADDR_VAR 0 5
20012: PUSH
20013: DOUBLE
20014: LD_INT 1
20016: DEC
20017: ST_TO_ADDR
20018: LD_VAR 0 2
20022: PUSH
20023: LD_INT 3
20025: DIVREAL
20026: PUSH
20027: FOR_TO
20028: IFFALSE 20131
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20030: LD_ADDR_EXP 41
20034: PUSH
20035: LD_EXP 41
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: LD_VAR 0 3
20049: PUSH
20050: LD_INT 1
20052: PPUSH
20053: LD_VAR 0 3
20057: PPUSH
20058: CALL_OW 12
20062: ARRAY
20063: PPUSH
20064: LD_VAR 0 2
20068: PUSH
20069: LD_VAR 0 6
20073: ARRAY
20074: PUSH
20075: LD_VAR 0 2
20079: PUSH
20080: LD_VAR 0 6
20084: PUSH
20085: LD_INT 1
20087: PLUS
20088: ARRAY
20089: PUSH
20090: LD_VAR 0 2
20094: PUSH
20095: LD_VAR 0 6
20099: PUSH
20100: LD_INT 2
20102: PLUS
20103: ARRAY
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: LIST
20109: PPUSH
20110: CALL 39713 0 4
20114: ST_TO_ADDR
// p := p + 3 ;
20115: LD_ADDR_VAR 0 6
20119: PUSH
20120: LD_VAR 0 6
20124: PUSH
20125: LD_INT 3
20127: PLUS
20128: ST_TO_ADDR
// end ;
20129: GO 20027
20131: POP
20132: POP
// end ;
20133: LD_VAR 0 4
20137: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20138: LD_INT 0
20140: PPUSH
20141: PPUSH
20142: PPUSH
20143: PPUSH
// if not MREG_Deposit [ side ] then
20144: LD_EXP 56
20148: PUSH
20149: LD_VAR 0 1
20153: ARRAY
20154: NOT
20155: IFFALSE 20159
// exit ;
20157: GO 20336
// p := 1 ;
20159: LD_ADDR_VAR 0 4
20163: PUSH
20164: LD_INT 1
20166: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20167: LD_ADDR_VAR 0 3
20171: PUSH
20172: DOUBLE
20173: LD_INT 1
20175: DEC
20176: ST_TO_ADDR
20177: LD_EXP 56
20181: PUSH
20182: LD_VAR 0 1
20186: ARRAY
20187: PUSH
20188: LD_INT 3
20190: DIVREAL
20191: PUSH
20192: FOR_TO
20193: IFFALSE 20334
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20195: LD_EXP 56
20199: PUSH
20200: LD_VAR 0 1
20204: ARRAY
20205: PUSH
20206: LD_VAR 0 4
20210: PUSH
20211: LD_INT 2
20213: PLUS
20214: ARRAY
20215: PUSH
20216: LD_INT 2
20218: EQUAL
20219: IFFALSE 20231
// b := b_oil_mine else
20221: LD_ADDR_VAR 0 5
20225: PUSH
20226: LD_INT 29
20228: ST_TO_ADDR
20229: GO 20239
// b := b_siberite_mine ;
20231: LD_ADDR_VAR 0 5
20235: PUSH
20236: LD_INT 30
20238: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20239: LD_ADDR_EXP 41
20243: PUSH
20244: LD_EXP 41
20248: PPUSH
20249: LD_VAR 0 1
20253: PPUSH
20254: LD_VAR 0 5
20258: PPUSH
20259: LD_EXP 56
20263: PUSH
20264: LD_VAR 0 1
20268: ARRAY
20269: PUSH
20270: LD_VAR 0 4
20274: ARRAY
20275: PUSH
20276: LD_EXP 56
20280: PUSH
20281: LD_VAR 0 1
20285: ARRAY
20286: PUSH
20287: LD_VAR 0 4
20291: PUSH
20292: LD_INT 1
20294: PLUS
20295: ARRAY
20296: PUSH
20297: LD_INT 0
20299: PPUSH
20300: LD_INT 5
20302: PPUSH
20303: CALL_OW 12
20307: PUSH
20308: EMPTY
20309: LIST
20310: LIST
20311: LIST
20312: PPUSH
20313: CALL 39713 0 4
20317: ST_TO_ADDR
// p := p + 3 ;
20318: LD_ADDR_VAR 0 4
20322: PUSH
20323: LD_VAR 0 4
20327: PUSH
20328: LD_INT 3
20330: PLUS
20331: ST_TO_ADDR
// end ;
20332: GO 20192
20334: POP
20335: POP
// end ;
20336: LD_VAR 0 2
20340: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20341: LD_INT 0
20343: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20344: LD_ADDR_EXP 41
20348: PUSH
20349: LD_EXP 41
20353: PPUSH
20354: LD_VAR 0 1
20358: PPUSH
20359: LD_INT 4
20361: PPUSH
20362: LD_VAR 0 2
20366: PPUSH
20367: CALL 39713 0 4
20371: ST_TO_ADDR
// end ;
20372: LD_VAR 0 3
20376: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20377: LD_INT 0
20379: PPUSH
// case nation of 1 , us :
20380: LD_VAR 0 2
20384: PUSH
20385: LD_INT 1
20387: DOUBLE
20388: EQUAL
20389: IFTRUE 20399
20391: LD_STRING us
20393: DOUBLE
20394: EQUAL
20395: IFTRUE 20399
20397: GO 20430
20399: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20400: LD_ADDR_EXP 41
20404: PUSH
20405: LD_EXP 41
20409: PPUSH
20410: LD_VAR 0 1
20414: PPUSH
20415: LD_INT 36
20417: PPUSH
20418: LD_VAR 0 3
20422: PPUSH
20423: CALL 39713 0 4
20427: ST_TO_ADDR
20428: GO 20481
20430: LD_INT 2
20432: DOUBLE
20433: EQUAL
20434: IFTRUE 20444
20436: LD_STRING ar
20438: DOUBLE
20439: EQUAL
20440: IFTRUE 20444
20442: GO 20480
20444: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20445: LD_ADDR_EXP 41
20449: PUSH
20450: LD_VAR 0 1
20454: PPUSH
20455: LD_INT 14
20457: PUSH
20458: LD_INT 2
20460: PUSH
20461: LD_INT 1
20463: PUSH
20464: LD_INT 31
20466: PUSH
20467: EMPTY
20468: LIST
20469: LIST
20470: LIST
20471: LIST
20472: PPUSH
20473: CALL 20486 0 2
20477: ST_TO_ADDR
20478: GO 20481
20480: POP
// end ;
20481: LD_VAR 0 4
20485: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20486: LD_INT 0
20488: PPUSH
20489: PPUSH
// for i = 1 to list do
20490: LD_ADDR_VAR 0 4
20494: PUSH
20495: DOUBLE
20496: LD_INT 1
20498: DEC
20499: ST_TO_ADDR
20500: LD_VAR 0 2
20504: PUSH
20505: FOR_TO
20506: IFFALSE 20556
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20508: LD_ADDR_EXP 46
20512: PUSH
20513: LD_EXP 46
20517: PPUSH
20518: LD_VAR 0 1
20522: PPUSH
20523: LD_EXP 46
20527: PUSH
20528: LD_VAR 0 1
20532: ARRAY
20533: PUSH
20534: LD_INT 1
20536: PLUS
20537: PPUSH
20538: LD_VAR 0 2
20542: PUSH
20543: LD_VAR 0 4
20547: ARRAY
20548: PPUSH
20549: CALL 29864 0 4
20553: ST_TO_ADDR
20554: GO 20505
20556: POP
20557: POP
// end ;
20558: LD_VAR 0 3
20562: RET
// export function MCS_GetVehicleList ( side ) ; begin
20563: LD_INT 0
20565: PPUSH
// result := MREG_ToConstruct [ side ] ;
20566: LD_ADDR_VAR 0 2
20570: PUSH
20571: LD_EXP 46
20575: PUSH
20576: LD_VAR 0 1
20580: ARRAY
20581: ST_TO_ADDR
// end ;
20582: LD_VAR 0 2
20586: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
20587: LD_INT 0
20589: PPUSH
20590: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
20591: LD_ADDR_EXP 53
20595: PUSH
20596: LD_EXP 53
20600: PPUSH
20601: LD_VAR 0 1
20605: PPUSH
20606: LD_VAR 0 2
20610: PPUSH
20611: CALL_OW 1
20615: ST_TO_ADDR
// end ;
20616: LD_VAR 0 3
20620: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
20621: LD_INT 0
20623: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
20624: LD_ADDR_EXP 32
20628: PUSH
20629: LD_EXP 32
20633: PPUSH
20634: LD_VAR 0 1
20638: PPUSH
20639: LD_VAR 0 2
20643: PPUSH
20644: CALL_OW 1
20648: ST_TO_ADDR
// end ;
20649: LD_VAR 0 3
20653: RET
// export function MCS_ApeOptions ( side , options ) ; begin
20654: LD_INT 0
20656: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
20657: LD_ADDR_EXP 33
20661: PUSH
20662: LD_EXP 33
20666: PPUSH
20667: LD_VAR 0 1
20671: PPUSH
20672: LD_VAR 0 2
20676: PPUSH
20677: CALL_OW 1
20681: ST_TO_ADDR
// end ;
20682: LD_VAR 0 3
20686: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
20687: LD_INT 0
20689: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
20690: LD_ADDR_EXP 55
20694: PUSH
20695: LD_EXP 55
20699: PPUSH
20700: LD_VAR 0 1
20704: PPUSH
20705: LD_INT 1
20707: PPUSH
20708: LD_VAR 0 2
20712: PPUSH
20713: CALL 29864 0 4
20717: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
20718: LD_ADDR_EXP 55
20722: PUSH
20723: LD_EXP 55
20727: PPUSH
20728: LD_VAR 0 1
20732: PPUSH
20733: LD_INT 2
20735: PPUSH
20736: LD_VAR 0 3
20740: PPUSH
20741: CALL 29864 0 4
20745: ST_TO_ADDR
// end ;
20746: LD_VAR 0 4
20750: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
20751: LD_INT 0
20753: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
20754: LD_ADDR_EXP 67
20758: PUSH
20759: LD_EXP 67
20763: PPUSH
20764: LD_INT 1
20766: PPUSH
20767: LD_VAR 0 1
20771: PPUSH
20772: CALL_OW 1
20776: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
20777: LD_ADDR_EXP 67
20781: PUSH
20782: LD_EXP 67
20786: PPUSH
20787: LD_INT 2
20789: PPUSH
20790: LD_VAR 0 2
20794: PPUSH
20795: CALL_OW 1
20799: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
20800: LD_ADDR_EXP 67
20804: PUSH
20805: LD_EXP 67
20809: PPUSH
20810: LD_INT 3
20812: PPUSH
20813: LD_VAR 0 3
20817: PPUSH
20818: CALL_OW 1
20822: ST_TO_ADDR
// end ;
20823: LD_VAR 0 4
20827: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
20828: LD_INT 0
20830: PPUSH
20831: PPUSH
20832: PPUSH
// if not side or not list then
20833: LD_VAR 0 1
20837: NOT
20838: PUSH
20839: LD_VAR 0 2
20843: NOT
20844: OR
20845: IFFALSE 20849
// exit ;
20847: GO 21017
// SetTech ( 20 , side , state_researched ) ;
20849: LD_INT 20
20851: PPUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: LD_INT 2
20859: PPUSH
20860: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
20864: LD_ADDR_EXP 56
20868: PUSH
20869: LD_EXP 56
20873: PPUSH
20874: LD_VAR 0 1
20878: PPUSH
20879: LD_VAR 0 2
20883: PPUSH
20884: CALL_OW 2
20888: ST_TO_ADDR
// p := 1 ;
20889: LD_ADDR_VAR 0 5
20893: PUSH
20894: LD_INT 1
20896: ST_TO_ADDR
// for i = 1 to list / 3 do
20897: LD_ADDR_VAR 0 4
20901: PUSH
20902: DOUBLE
20903: LD_INT 1
20905: DEC
20906: ST_TO_ADDR
20907: LD_VAR 0 2
20911: PUSH
20912: LD_INT 3
20914: DIVREAL
20915: PUSH
20916: FOR_TO
20917: IFFALSE 21015
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
20919: LD_VAR 0 2
20923: PUSH
20924: LD_VAR 0 5
20928: ARRAY
20929: PPUSH
20930: LD_VAR 0 2
20934: PUSH
20935: LD_VAR 0 5
20939: PUSH
20940: LD_INT 1
20942: PLUS
20943: ARRAY
20944: PPUSH
20945: LD_VAR 0 2
20949: PUSH
20950: LD_VAR 0 5
20954: PUSH
20955: LD_INT 2
20957: PLUS
20958: ARRAY
20959: PPUSH
20960: CALL 21719 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
20964: LD_VAR 0 2
20968: PUSH
20969: LD_VAR 0 5
20973: ARRAY
20974: PPUSH
20975: LD_VAR 0 2
20979: PUSH
20980: LD_VAR 0 5
20984: PUSH
20985: LD_INT 1
20987: PLUS
20988: ARRAY
20989: PPUSH
20990: LD_VAR 0 1
20994: PPUSH
20995: CALL_OW 441
// p := p + 3 ;
20999: LD_ADDR_VAR 0 5
21003: PUSH
21004: LD_VAR 0 5
21008: PUSH
21009: LD_INT 3
21011: PLUS
21012: ST_TO_ADDR
// end ;
21013: GO 20916
21015: POP
21016: POP
// end ;
21017: LD_VAR 0 3
21021: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21022: LD_INT 0
21024: PPUSH
21025: PPUSH
// if nat = nation_arabian then
21026: LD_VAR 0 2
21030: PUSH
21031: LD_INT 2
21033: EQUAL
21034: IFFALSE 21040
// exit else
21036: GO 21112
21038: GO 21098
// if nat = nation_american then
21040: LD_VAR 0 2
21044: PUSH
21045: LD_INT 1
21047: EQUAL
21048: IFFALSE 21075
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21050: LD_ADDR_VAR 0 4
21054: PUSH
21055: LD_INT 4
21057: PUSH
21058: LD_INT 3
21060: PUSH
21061: LD_INT 1
21063: PUSH
21064: LD_INT 8
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: LIST
21071: LIST
21072: ST_TO_ADDR
21073: GO 21098
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21075: LD_ADDR_VAR 0 4
21079: PUSH
21080: LD_INT 24
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 1
21088: PUSH
21089: LD_INT 48
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: LIST
21096: LIST
21097: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21098: LD_VAR 0 1
21102: PPUSH
21103: LD_VAR 0 4
21107: PPUSH
21108: CALL 20486 0 2
// end ;
21112: LD_VAR 0 3
21116: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21117: LD_INT 0
21119: PPUSH
21120: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21121: LD_ADDR_EXP 58
21125: PUSH
21126: LD_EXP 58
21130: PPUSH
21131: LD_VAR 0 1
21135: PPUSH
21136: LD_INT 1
21138: PPUSH
21139: LD_VAR 0 4
21143: PPUSH
21144: CALL 29864 0 4
21148: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21149: LD_ADDR_EXP 59
21153: PUSH
21154: LD_EXP 59
21158: PPUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: LD_INT 1
21166: PPUSH
21167: LD_VAR 0 2
21171: PPUSH
21172: CALL 29864 0 4
21176: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21177: LD_ADDR_EXP 60
21181: PUSH
21182: LD_EXP 60
21186: PPUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: LD_INT 1
21194: PPUSH
21195: LD_VAR 0 3
21199: PPUSH
21200: CALL 29864 0 4
21204: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21205: LD_ADDR_EXP 61
21209: PUSH
21210: LD_EXP 61
21214: PPUSH
21215: LD_VAR 0 1
21219: PPUSH
21220: LD_INT 1
21222: PPUSH
21223: LD_VAR 0 5
21227: PPUSH
21228: CALL 29864 0 4
21232: ST_TO_ADDR
// while squad do
21233: LD_VAR 0 5
21237: IFFALSE 21330
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21239: LD_VAR 0 1
21243: PPUSH
21244: LD_VAR 0 5
21248: PUSH
21249: LD_INT 1
21251: ARRAY
21252: PUSH
21253: LD_VAR 0 5
21257: PUSH
21258: LD_INT 2
21260: ARRAY
21261: PUSH
21262: LD_VAR 0 5
21266: PUSH
21267: LD_INT 3
21269: ARRAY
21270: PUSH
21271: LD_VAR 0 5
21275: PUSH
21276: LD_INT 4
21278: ARRAY
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: LIST
21284: LIST
21285: PPUSH
21286: CALL 20486 0 2
// for i = 1 to 4 do
21290: LD_ADDR_VAR 0 7
21294: PUSH
21295: DOUBLE
21296: LD_INT 1
21298: DEC
21299: ST_TO_ADDR
21300: LD_INT 4
21302: PUSH
21303: FOR_TO
21304: IFFALSE 21326
// squad := Delete ( squad , 1 ) ;
21306: LD_ADDR_VAR 0 5
21310: PUSH
21311: LD_VAR 0 5
21315: PPUSH
21316: LD_INT 1
21318: PPUSH
21319: CALL_OW 3
21323: ST_TO_ADDR
21324: GO 21303
21326: POP
21327: POP
// end ;
21328: GO 21233
// end ;
21330: LD_VAR 0 6
21334: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21335: LD_INT 0
21337: PPUSH
21338: PPUSH
// for i = 1 to squad do
21339: LD_ADDR_VAR 0 4
21343: PUSH
21344: DOUBLE
21345: LD_INT 1
21347: DEC
21348: ST_TO_ADDR
21349: LD_VAR 0 2
21353: PUSH
21354: FOR_TO
21355: IFFALSE 21405
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21357: LD_ADDR_EXP 64
21361: PUSH
21362: LD_EXP 64
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_EXP 64
21376: PUSH
21377: LD_VAR 0 1
21381: ARRAY
21382: PUSH
21383: LD_INT 1
21385: PLUS
21386: PPUSH
21387: LD_VAR 0 2
21391: PUSH
21392: LD_VAR 0 4
21396: ARRAY
21397: PPUSH
21398: CALL 29864 0 4
21402: ST_TO_ADDR
21403: GO 21354
21405: POP
21406: POP
// while squad do
21407: LD_VAR 0 2
21411: IFFALSE 21504
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21413: LD_VAR 0 1
21417: PPUSH
21418: LD_VAR 0 2
21422: PUSH
21423: LD_INT 1
21425: ARRAY
21426: PUSH
21427: LD_VAR 0 2
21431: PUSH
21432: LD_INT 2
21434: ARRAY
21435: PUSH
21436: LD_VAR 0 2
21440: PUSH
21441: LD_INT 3
21443: ARRAY
21444: PUSH
21445: LD_VAR 0 2
21449: PUSH
21450: LD_INT 4
21452: ARRAY
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: LIST
21458: LIST
21459: PPUSH
21460: CALL 20486 0 2
// for i = 1 to 4 do
21464: LD_ADDR_VAR 0 4
21468: PUSH
21469: DOUBLE
21470: LD_INT 1
21472: DEC
21473: ST_TO_ADDR
21474: LD_INT 4
21476: PUSH
21477: FOR_TO
21478: IFFALSE 21500
// squad := Delete ( squad , 1 ) ;
21480: LD_ADDR_VAR 0 2
21484: PUSH
21485: LD_VAR 0 2
21489: PPUSH
21490: LD_INT 1
21492: PPUSH
21493: CALL_OW 3
21497: ST_TO_ADDR
21498: GO 21477
21500: POP
21501: POP
// end ;
21502: GO 21407
// end ;
21504: LD_VAR 0 3
21508: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21509: LD_INT 0
21511: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21512: LD_ADDR_EXP 57
21516: PUSH
21517: LD_EXP 57
21521: PPUSH
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_INT 1
21529: PPUSH
21530: LD_VAR 0 2
21534: PPUSH
21535: CALL 29864 0 4
21539: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21540: LD_ADDR_EXP 57
21544: PUSH
21545: LD_EXP 57
21549: PPUSH
21550: LD_VAR 0 1
21554: PPUSH
21555: LD_INT 2
21557: PPUSH
21558: LD_VAR 0 3
21562: PPUSH
21563: CALL 29864 0 4
21567: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
21568: LD_ADDR_EXP 57
21572: PUSH
21573: LD_EXP 57
21577: PPUSH
21578: LD_VAR 0 1
21582: PPUSH
21583: LD_INT 3
21585: PPUSH
21586: LD_VAR 0 4
21590: PPUSH
21591: CALL 29864 0 4
21595: ST_TO_ADDR
// end ; end_of_file
21596: LD_VAR 0 5
21600: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
21601: LD_INT 0
21603: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
21604: LD_ADDR_EXP 37
21608: PUSH
21609: LD_EXP 37
21613: PPUSH
21614: LD_VAR 0 1
21618: PPUSH
21619: LD_INT 1
21621: PPUSH
21622: LD_VAR 0 2
21626: PPUSH
21627: CALL 29864 0 4
21631: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
21632: LD_VAR 0 1
21636: PPUSH
21637: EMPTY
21638: PPUSH
21639: CALL 11102 0 2
21643: PUSH
21644: LD_INT 1
21646: ARRAY
21647: PPUSH
21648: CALL_OW 248
21652: PUSH
21653: LD_INT 1
21655: EQUAL
21656: IFFALSE 21687
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
21658: LD_VAR 0 1
21662: PPUSH
21663: LD_INT 4
21665: PUSH
21666: LD_INT 1
21668: PUSH
21669: LD_INT 1
21671: PUSH
21672: LD_INT 14
21674: PUSH
21675: EMPTY
21676: LIST
21677: LIST
21678: LIST
21679: LIST
21680: PPUSH
21681: CALL 20486 0 2
21685: GO 21714
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
21687: LD_VAR 0 1
21691: PPUSH
21692: LD_INT 24
21694: PUSH
21695: LD_INT 1
21697: PUSH
21698: LD_INT 1
21700: PUSH
21701: LD_INT 53
21703: PUSH
21704: EMPTY
21705: LIST
21706: LIST
21707: LIST
21708: LIST
21709: PPUSH
21710: CALL 20486 0 2
// end ;
21714: LD_VAR 0 3
21718: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
21719: LD_INT 0
21721: PPUSH
// CreateDepositXY ( x , y , t ) ;
21722: LD_VAR 0 1
21726: PPUSH
21727: LD_VAR 0 2
21731: PPUSH
21732: LD_VAR 0 3
21736: PPUSH
21737: CALL_OW 62
// end ;
21741: LD_VAR 0 4
21745: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
21746: LD_INT 0
21748: PPUSH
21749: PPUSH
// c := 1 ;
21750: LD_ADDR_VAR 0 5
21754: PUSH
21755: LD_INT 1
21757: ST_TO_ADDR
// case color of red :
21758: LD_VAR 0 3
21762: PUSH
21763: LD_STRING red
21765: DOUBLE
21766: EQUAL
21767: IFTRUE 21771
21769: GO 21782
21771: POP
// c = 1 ; dark-green :
21772: LD_ADDR_VAR 0 5
21776: PUSH
21777: LD_INT 1
21779: ST_TO_ADDR
21780: GO 22068
21782: LD_STRING dark-green
21784: DOUBLE
21785: EQUAL
21786: IFTRUE 21790
21788: GO 21801
21790: POP
// c = 2 ; purple :
21791: LD_ADDR_VAR 0 5
21795: PUSH
21796: LD_INT 2
21798: ST_TO_ADDR
21799: GO 22068
21801: LD_STRING purple
21803: DOUBLE
21804: EQUAL
21805: IFTRUE 21809
21807: GO 21820
21809: POP
// c = 3 ; aqua :
21810: LD_ADDR_VAR 0 5
21814: PUSH
21815: LD_INT 3
21817: ST_TO_ADDR
21818: GO 22068
21820: LD_STRING aqua
21822: DOUBLE
21823: EQUAL
21824: IFTRUE 21828
21826: GO 21839
21828: POP
// c = 4 ; grey :
21829: LD_ADDR_VAR 0 5
21833: PUSH
21834: LD_INT 4
21836: ST_TO_ADDR
21837: GO 22068
21839: LD_STRING grey
21841: DOUBLE
21842: EQUAL
21843: IFTRUE 21847
21845: GO 21858
21847: POP
// c = 5 ; lime :
21848: LD_ADDR_VAR 0 5
21852: PUSH
21853: LD_INT 5
21855: ST_TO_ADDR
21856: GO 22068
21858: LD_STRING lime
21860: DOUBLE
21861: EQUAL
21862: IFTRUE 21866
21864: GO 21877
21866: POP
// c = 6 ; tan :
21867: LD_ADDR_VAR 0 5
21871: PUSH
21872: LD_INT 6
21874: ST_TO_ADDR
21875: GO 22068
21877: LD_STRING tan
21879: DOUBLE
21880: EQUAL
21881: IFTRUE 21885
21883: GO 21896
21885: POP
// c = 7 ; pink :
21886: LD_ADDR_VAR 0 5
21890: PUSH
21891: LD_INT 7
21893: ST_TO_ADDR
21894: GO 22068
21896: LD_STRING pink
21898: DOUBLE
21899: EQUAL
21900: IFTRUE 21904
21902: GO 21915
21904: POP
// c = 8 ; green :
21905: LD_ADDR_VAR 0 5
21909: PUSH
21910: LD_INT 8
21912: ST_TO_ADDR
21913: GO 22068
21915: LD_STRING green
21917: DOUBLE
21918: EQUAL
21919: IFTRUE 21923
21921: GO 21934
21923: POP
// c = 9 ; blue :
21924: LD_ADDR_VAR 0 5
21928: PUSH
21929: LD_INT 9
21931: ST_TO_ADDR
21932: GO 22068
21934: LD_STRING blue
21936: DOUBLE
21937: EQUAL
21938: IFTRUE 21942
21940: GO 21953
21942: POP
// c = 10 ; yellow :
21943: LD_ADDR_VAR 0 5
21947: PUSH
21948: LD_INT 10
21950: ST_TO_ADDR
21951: GO 22068
21953: LD_STRING yellow
21955: DOUBLE
21956: EQUAL
21957: IFTRUE 21961
21959: GO 21972
21961: POP
// c = 11 ; brown :
21962: LD_ADDR_VAR 0 5
21966: PUSH
21967: LD_INT 11
21969: ST_TO_ADDR
21970: GO 22068
21972: LD_STRING brown
21974: DOUBLE
21975: EQUAL
21976: IFTRUE 21980
21978: GO 21991
21980: POP
// c = 12 ; black :
21981: LD_ADDR_VAR 0 5
21985: PUSH
21986: LD_INT 12
21988: ST_TO_ADDR
21989: GO 22068
21991: LD_STRING black
21993: DOUBLE
21994: EQUAL
21995: IFTRUE 21999
21997: GO 22010
21999: POP
// c = 13 ; aqua2 :
22000: LD_ADDR_VAR 0 5
22004: PUSH
22005: LD_INT 13
22007: ST_TO_ADDR
22008: GO 22068
22010: LD_STRING aqua2
22012: DOUBLE
22013: EQUAL
22014: IFTRUE 22018
22016: GO 22029
22018: POP
// c = 14 ; orange :
22019: LD_ADDR_VAR 0 5
22023: PUSH
22024: LD_INT 14
22026: ST_TO_ADDR
22027: GO 22068
22029: LD_STRING orange
22031: DOUBLE
22032: EQUAL
22033: IFTRUE 22037
22035: GO 22048
22037: POP
// c = 15 ; white :
22038: LD_ADDR_VAR 0 5
22042: PUSH
22043: LD_INT 15
22045: ST_TO_ADDR
22046: GO 22068
22048: LD_STRING white
22050: DOUBLE
22051: EQUAL
22052: IFTRUE 22056
22054: GO 22067
22056: POP
// c = 16 ; end ;
22057: LD_ADDR_VAR 0 5
22061: PUSH
22062: LD_INT 16
22064: ST_TO_ADDR
22065: GO 22068
22067: POP
// if HexInfo ( x , y ) = 0 then
22068: LD_VAR 0 1
22072: PPUSH
22073: LD_VAR 0 2
22077: PPUSH
22078: CALL_OW 428
22082: PUSH
22083: LD_INT 0
22085: EQUAL
22086: IFFALSE 22110
// PlaceEnvironment ( x , y , 58 , c ) ;
22088: LD_VAR 0 1
22092: PPUSH
22093: LD_VAR 0 2
22097: PPUSH
22098: LD_INT 58
22100: PPUSH
22101: LD_VAR 0 5
22105: PPUSH
22106: CALL_OW 349
// end ;
22110: LD_VAR 0 4
22114: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22115: LD_INT 0
22117: PPUSH
// RemoveEnvironment ( x , y ) ;
22118: LD_VAR 0 1
22122: PPUSH
22123: LD_VAR 0 2
22127: PPUSH
22128: CALL_OW 347
// end ;
22132: LD_VAR 0 3
22136: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22137: LD_INT 0
22139: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22140: LD_INT 81
22142: PUSH
22143: LD_VAR 0 1
22147: PUSH
22148: EMPTY
22149: LIST
22150: LIST
22151: PPUSH
22152: CALL_OW 69
22156: PUSH
22157: LD_INT 0
22159: EQUAL
22160: IFFALSE 22172
// result := false else
22162: LD_ADDR_VAR 0 5
22166: PUSH
22167: LD_INT 0
22169: ST_TO_ADDR
22170: GO 22236
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22172: LD_INT 81
22174: PUSH
22175: LD_VAR 0 1
22179: PUSH
22180: EMPTY
22181: LIST
22182: LIST
22183: PUSH
22184: LD_INT 92
22186: PUSH
22187: LD_VAR 0 2
22191: PUSH
22192: LD_VAR 0 3
22196: PUSH
22197: LD_VAR 0 4
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: LIST
22206: LIST
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PPUSH
22212: CALL_OW 69
22216: IFFALSE 22228
// result := true else
22218: LD_ADDR_VAR 0 5
22222: PUSH
22223: LD_INT 1
22225: ST_TO_ADDR
22226: GO 22236
// result := false ;
22228: LD_ADDR_VAR 0 5
22232: PUSH
22233: LD_INT 0
22235: ST_TO_ADDR
// end ;
22236: LD_VAR 0 5
22240: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22241: LD_INT 0
22243: PPUSH
22244: PPUSH
22245: PPUSH
22246: PPUSH
22247: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22248: LD_VAR 0 1
22252: PPUSH
22253: LD_INT 81
22255: PUSH
22256: LD_VAR 0 1
22260: PPUSH
22261: CALL_OW 255
22265: PUSH
22266: EMPTY
22267: LIST
22268: LIST
22269: PPUSH
22270: CALL_OW 69
22274: PPUSH
22275: LD_VAR 0 1
22279: PPUSH
22280: CALL_OW 74
22284: PPUSH
22285: CALL_OW 119
// dir := GetDir ( un ) ;
22289: LD_ADDR_VAR 0 4
22293: PUSH
22294: LD_VAR 0 1
22298: PPUSH
22299: CALL_OW 254
22303: ST_TO_ADDR
// dir := dir - 3 ;
22304: LD_ADDR_VAR 0 4
22308: PUSH
22309: LD_VAR 0 4
22313: PUSH
22314: LD_INT 3
22316: MINUS
22317: ST_TO_ADDR
// if dir < 0 then
22318: LD_VAR 0 4
22322: PUSH
22323: LD_INT 0
22325: LESS
22326: IFFALSE 22342
// dir := dir + 6 ;
22328: LD_ADDR_VAR 0 4
22332: PUSH
22333: LD_VAR 0 4
22337: PUSH
22338: LD_INT 6
22340: PLUS
22341: ST_TO_ADDR
// while true do
22342: LD_INT 1
22344: IFFALSE 22841
// begin coord_dist := 3 ;
22346: LD_ADDR_VAR 0 3
22350: PUSH
22351: LD_INT 3
22353: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22354: LD_ADDR_VAR 0 5
22358: PUSH
22359: LD_VAR 0 1
22363: PPUSH
22364: CALL_OW 250
22368: PPUSH
22369: LD_VAR 0 4
22373: PPUSH
22374: LD_VAR 0 3
22378: PPUSH
22379: CALL_OW 272
22383: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22384: LD_ADDR_VAR 0 6
22388: PUSH
22389: LD_VAR 0 1
22393: PPUSH
22394: CALL_OW 251
22398: PPUSH
22399: LD_VAR 0 4
22403: PPUSH
22404: LD_VAR 0 3
22408: PPUSH
22409: CALL_OW 273
22413: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22414: LD_VAR 0 1
22418: PPUSH
22419: CALL_OW 255
22423: PPUSH
22424: LD_VAR 0 1
22428: PPUSH
22429: CALL_OW 250
22433: PPUSH
22434: LD_VAR 0 1
22438: PPUSH
22439: CALL_OW 251
22443: PPUSH
22444: LD_INT 14
22446: PPUSH
22447: CALL 22137 0 4
22451: PUSH
22452: LD_VAR 0 5
22456: PPUSH
22457: LD_VAR 0 6
22461: PPUSH
22462: CALL_OW 351
22466: OR
22467: PUSH
22468: LD_VAR 0 5
22472: PPUSH
22473: LD_VAR 0 6
22477: PPUSH
22478: CALL_OW 488
22482: PUSH
22483: LD_INT 0
22485: EQUAL
22486: OR
22487: PUSH
22488: LD_VAR 0 5
22492: PPUSH
22493: LD_VAR 0 6
22497: PPUSH
22498: CALL_OW 546
22502: PUSH
22503: LD_INT 1
22505: EQUAL
22506: OR
22507: PUSH
22508: LD_VAR 0 5
22512: PPUSH
22513: LD_VAR 0 6
22517: PPUSH
22518: CALL_OW 428
22522: PUSH
22523: LD_INT 0
22525: NONEQUAL
22526: OR
22527: IFFALSE 22755
// begin repeat begin Wait ( 0 0$0.3 ) ;
22529: LD_INT 10
22531: PPUSH
22532: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22536: LD_ADDR_VAR 0 3
22540: PUSH
22541: LD_VAR 0 3
22545: PUSH
22546: LD_INT 1
22548: PLUS
22549: ST_TO_ADDR
// dir := dir + 1 ;
22550: LD_ADDR_VAR 0 4
22554: PUSH
22555: LD_VAR 0 4
22559: PUSH
22560: LD_INT 1
22562: PLUS
22563: ST_TO_ADDR
// if dir > 5 then
22564: LD_VAR 0 4
22568: PUSH
22569: LD_INT 5
22571: GREATER
22572: IFFALSE 22582
// dir = 0 ;
22574: LD_ADDR_VAR 0 4
22578: PUSH
22579: LD_INT 0
22581: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_VAR 0 1
22591: PPUSH
22592: CALL_OW 250
22596: PPUSH
22597: LD_VAR 0 4
22601: PPUSH
22602: LD_VAR 0 3
22606: PPUSH
22607: CALL_OW 272
22611: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22612: LD_ADDR_VAR 0 6
22616: PUSH
22617: LD_VAR 0 1
22621: PPUSH
22622: CALL_OW 251
22626: PPUSH
22627: LD_VAR 0 4
22631: PPUSH
22632: LD_VAR 0 3
22636: PPUSH
22637: CALL_OW 273
22641: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
22642: LD_VAR 0 1
22646: PPUSH
22647: CALL_OW 255
22651: PPUSH
22652: LD_VAR 0 1
22656: PPUSH
22657: CALL_OW 250
22661: PPUSH
22662: LD_VAR 0 1
22666: PPUSH
22667: CALL_OW 251
22671: PPUSH
22672: LD_INT 14
22674: PPUSH
22675: CALL 22137 0 4
22679: NOT
22680: PUSH
22681: LD_VAR 0 5
22685: PPUSH
22686: LD_VAR 0 6
22690: PPUSH
22691: CALL_OW 351
22695: NOT
22696: AND
22697: PUSH
22698: LD_VAR 0 5
22702: PPUSH
22703: LD_VAR 0 6
22707: PPUSH
22708: CALL_OW 488
22712: AND
22713: PUSH
22714: LD_VAR 0 5
22718: PPUSH
22719: LD_VAR 0 6
22723: PPUSH
22724: CALL_OW 546
22728: PUSH
22729: LD_INT 0
22731: EQUAL
22732: AND
22733: PUSH
22734: LD_VAR 0 5
22738: PPUSH
22739: LD_VAR 0 6
22743: PPUSH
22744: CALL_OW 428
22748: PUSH
22749: LD_INT 0
22751: EQUAL
22752: AND
22753: IFFALSE 22529
// end ; ComMoveXY ( un , x , y ) ;
22755: LD_VAR 0 1
22759: PPUSH
22760: LD_VAR 0 5
22764: PPUSH
22765: LD_VAR 0 6
22769: PPUSH
22770: CALL_OW 111
// Wait ( 0 0$1 ) ;
22774: LD_INT 35
22776: PPUSH
22777: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
22781: LD_VAR 0 1
22785: PPUSH
22786: LD_INT 81
22788: PUSH
22789: LD_VAR 0 1
22793: PPUSH
22794: CALL_OW 255
22798: PUSH
22799: EMPTY
22800: LIST
22801: LIST
22802: PPUSH
22803: CALL_OW 69
22807: PPUSH
22808: LD_VAR 0 1
22812: PPUSH
22813: CALL_OW 74
22817: PPUSH
22818: CALL_OW 296
22822: PUSH
22823: LD_INT 14
22825: GREATEREQUAL
22826: IFFALSE 22839
// begin ComStop ( un ) ;
22828: LD_VAR 0 1
22832: PPUSH
22833: CALL_OW 141
// break ;
22837: GO 22841
// end ; end ;
22839: GO 22342
// end ;
22841: LD_VAR 0 2
22845: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
22846: LD_INT 0
22848: PPUSH
22849: PPUSH
22850: PPUSH
22851: PPUSH
22852: PPUSH
22853: PPUSH
22854: PPUSH
22855: PPUSH
// x := GetX ( unit ) ;
22856: LD_ADDR_VAR 0 3
22860: PUSH
22861: LD_VAR 0 1
22865: PPUSH
22866: CALL_OW 250
22870: ST_TO_ADDR
// y := GetY ( unit ) ;
22871: LD_ADDR_VAR 0 4
22875: PUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 251
22885: ST_TO_ADDR
// i := 0 ;
22886: LD_ADDR_VAR 0 8
22890: PUSH
22891: LD_INT 0
22893: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
22894: LD_VAR 0 1
22898: PPUSH
22899: LD_INT 81
22901: PUSH
22902: LD_VAR 0 1
22906: PPUSH
22907: CALL_OW 255
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: PPUSH
22916: CALL_OW 69
22920: PPUSH
22921: LD_VAR 0 1
22925: PPUSH
22926: CALL_OW 74
22930: PPUSH
22931: CALL_OW 119
// dir := GetDir ( unit ) ;
22935: LD_ADDR_VAR 0 7
22939: PUSH
22940: LD_VAR 0 1
22944: PPUSH
22945: CALL_OW 254
22949: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
22950: LD_ADDR_VAR 0 9
22954: PUSH
22955: LD_INT 0
22957: PPUSH
22958: LD_INT 1
22960: PPUSH
22961: CALL_OW 12
22965: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
22966: LD_INT 10
22968: PPUSH
22969: CALL_OW 67
// if mode then
22973: LD_VAR 0 9
22977: IFFALSE 22995
// dir := dir + 1 else
22979: LD_ADDR_VAR 0 7
22983: PUSH
22984: LD_VAR 0 7
22988: PUSH
22989: LD_INT 1
22991: PLUS
22992: ST_TO_ADDR
22993: GO 23009
// dir := dir - 1 ;
22995: LD_ADDR_VAR 0 7
22999: PUSH
23000: LD_VAR 0 7
23004: PUSH
23005: LD_INT 1
23007: MINUS
23008: ST_TO_ADDR
// if ( dir < 0 ) then
23009: LD_VAR 0 7
23013: PUSH
23014: LD_INT 0
23016: LESS
23017: IFFALSE 23027
// dir := 5 ;
23019: LD_ADDR_VAR 0 7
23023: PUSH
23024: LD_INT 5
23026: ST_TO_ADDR
// if ( dir > 5 ) then
23027: LD_VAR 0 7
23031: PUSH
23032: LD_INT 5
23034: GREATER
23035: IFFALSE 23045
// dir := 0 ;
23037: LD_ADDR_VAR 0 7
23041: PUSH
23042: LD_INT 0
23044: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23045: LD_ADDR_VAR 0 5
23049: PUSH
23050: LD_VAR 0 3
23054: PPUSH
23055: LD_VAR 0 7
23059: PPUSH
23060: LD_INT 4
23062: PPUSH
23063: CALL_OW 272
23067: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23068: LD_ADDR_VAR 0 6
23072: PUSH
23073: LD_VAR 0 4
23077: PPUSH
23078: LD_VAR 0 7
23082: PPUSH
23083: LD_INT 4
23085: PPUSH
23086: CALL_OW 273
23090: ST_TO_ADDR
// i := i + 1 ;
23091: LD_ADDR_VAR 0 8
23095: PUSH
23096: LD_VAR 0 8
23100: PUSH
23101: LD_INT 1
23103: PLUS
23104: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23105: LD_VAR 0 1
23109: PPUSH
23110: CALL_OW 255
23114: PPUSH
23115: LD_VAR 0 5
23119: PPUSH
23120: LD_VAR 0 6
23124: PPUSH
23125: LD_INT 14
23127: PPUSH
23128: CALL 22137 0 4
23132: PUSH
23133: LD_INT 0
23135: EQUAL
23136: PUSH
23137: LD_VAR 0 5
23141: PPUSH
23142: LD_VAR 0 6
23146: PPUSH
23147: CALL_OW 546
23151: PUSH
23152: LD_INT 0
23154: EQUAL
23155: AND
23156: PUSH
23157: LD_VAR 0 5
23161: PPUSH
23162: LD_VAR 0 6
23166: PPUSH
23167: CALL_OW 428
23171: PUSH
23172: LD_INT 0
23174: EQUAL
23175: AND
23176: IFFALSE 23180
// break ;
23178: GO 23190
// end until i > 4 ;
23180: LD_VAR 0 8
23184: PUSH
23185: LD_INT 4
23187: GREATER
23188: IFFALSE 22966
// if x2 and y2 then
23190: LD_VAR 0 5
23194: PUSH
23195: LD_VAR 0 6
23199: AND
23200: IFFALSE 23223
// result := [ x2 , y2 ] else
23202: LD_ADDR_VAR 0 2
23206: PUSH
23207: LD_VAR 0 5
23211: PUSH
23212: LD_VAR 0 6
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: ST_TO_ADDR
23221: GO 23252
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23223: LD_ADDR_VAR 0 2
23227: PUSH
23228: LD_VAR 0 1
23232: PPUSH
23233: CALL_OW 250
23237: PUSH
23238: LD_VAR 0 1
23242: PPUSH
23243: CALL_OW 251
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: ST_TO_ADDR
// end ;
23252: LD_VAR 0 2
23256: RET
// export function MCT_Hex ( x , y ) ; begin
23257: LD_INT 0
23259: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23260: LD_ADDR_VAR 0 3
23264: PUSH
23265: LD_VAR 0 1
23269: PPUSH
23270: LD_VAR 0 2
23274: PPUSH
23275: CALL_OW 546
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: LD_VAR 0 2
23289: PPUSH
23290: CALL_OW 428
23294: PUSH
23295: EMPTY
23296: LIST
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: ST_TO_ADDR
// end ;
23302: LD_VAR 0 3
23306: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23307: LD_INT 0
23309: PPUSH
23310: PPUSH
23311: PPUSH
23312: PPUSH
23313: PPUSH
23314: PPUSH
23315: PPUSH
23316: PPUSH
23317: PPUSH
23318: PPUSH
23319: PPUSH
23320: PPUSH
23321: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23322: LD_ADDR_VAR 0 10
23326: PUSH
23327: LD_EXP 55
23331: PUSH
23332: LD_VAR 0 1
23336: ARRAY
23337: PUSH
23338: LD_INT 1
23340: ARRAY
23341: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23342: LD_ADDR_VAR 0 11
23346: PUSH
23347: LD_EXP 55
23351: PUSH
23352: LD_VAR 0 1
23356: ARRAY
23357: PUSH
23358: LD_INT 2
23360: ARRAY
23361: ST_TO_ADDR
// collectors := [ ] ;
23362: LD_ADDR_VAR 0 12
23366: PUSH
23367: EMPTY
23368: ST_TO_ADDR
// is_cargo := false ;
23369: LD_ADDR_VAR 0 13
23373: PUSH
23374: LD_INT 0
23376: ST_TO_ADDR
// if isEditor then
23377: LD_INT 1
23379: IFFALSE 23385
// TimerStart ( ) ;
23381: CALL_OW 548
// if MCF_Cargo ( side ) then
23385: LD_VAR 0 1
23389: PPUSH
23390: CALL 11318 0 1
23394: IFFALSE 23421
// begin collectors := MCF_Cargo ( side ) ;
23396: LD_ADDR_VAR 0 12
23400: PUSH
23401: LD_VAR 0 1
23405: PPUSH
23406: CALL 11318 0 1
23410: ST_TO_ADDR
// is_cargo := true ;
23411: LD_ADDR_VAR 0 13
23415: PUSH
23416: LD_INT 1
23418: ST_TO_ADDR
// end else
23419: GO 23570
// begin if MCF_ApeSpec ( side , engineer ) then
23421: LD_VAR 0 1
23425: PPUSH
23426: LD_STRING engineer
23428: PPUSH
23429: CALL 11464 0 2
23433: IFFALSE 23453
// collectors := MCF_ApeSpec ( side , engineer ) ;
23435: LD_ADDR_VAR 0 12
23439: PUSH
23440: LD_VAR 0 1
23444: PPUSH
23445: LD_STRING engineer
23447: PPUSH
23448: CALL 11464 0 2
23452: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23453: LD_VAR 0 1
23457: PPUSH
23458: LD_INT 2
23460: PPUSH
23461: EMPTY
23462: PPUSH
23463: CALL 11050 0 3
23467: IFFALSE 23570
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23469: LD_ADDR_VAR 0 7
23473: PUSH
23474: LD_VAR 0 1
23478: PPUSH
23479: LD_INT 2
23481: PPUSH
23482: EMPTY
23483: PPUSH
23484: CALL 11050 0 3
23488: ST_TO_ADDR
// if z > 5 then
23489: LD_VAR 0 7
23493: PUSH
23494: LD_INT 5
23496: GREATER
23497: IFFALSE 23509
// t1 := 5 else
23499: LD_ADDR_VAR 0 8
23503: PUSH
23504: LD_INT 5
23506: ST_TO_ADDR
23507: GO 23519
// t1 := z ;
23509: LD_ADDR_VAR 0 8
23513: PUSH
23514: LD_VAR 0 7
23518: ST_TO_ADDR
// for t2 = 1 to t1 do
23519: LD_ADDR_VAR 0 9
23523: PUSH
23524: DOUBLE
23525: LD_INT 1
23527: DEC
23528: ST_TO_ADDR
23529: LD_VAR 0 8
23533: PUSH
23534: FOR_TO
23535: IFFALSE 23568
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23537: LD_ADDR_VAR 0 12
23541: PUSH
23542: LD_VAR 0 12
23546: PPUSH
23547: LD_INT 1
23549: PPUSH
23550: LD_VAR 0 7
23554: PUSH
23555: LD_VAR 0 9
23559: ARRAY
23560: PPUSH
23561: CALL_OW 2
23565: ST_TO_ADDR
23566: GO 23534
23568: POP
23569: POP
// end ; end ; if not mode then
23570: LD_VAR 0 10
23574: NOT
23575: IFFALSE 23581
// exit else
23577: GO 23838
23579: GO 23838
// begin if collectors then
23581: LD_VAR 0 12
23585: IFFALSE 23838
// for i in areas do
23587: LD_ADDR_VAR 0 3
23591: PUSH
23592: LD_VAR 0 11
23596: PUSH
23597: FOR_IN
23598: IFFALSE 23836
// if GetListOfCratesInArea ( i ) then
23600: LD_VAR 0 3
23604: PPUSH
23605: CALL_OW 435
23609: IFFALSE 23834
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
23611: LD_ADDR_VAR 0 5
23615: PUSH
23616: LD_VAR 0 3
23620: PPUSH
23621: CALL_OW 435
23625: PUSH
23626: LD_INT 1
23628: ARRAY
23629: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
23630: LD_ADDR_VAR 0 6
23634: PUSH
23635: LD_VAR 0 3
23639: PPUSH
23640: CALL_OW 435
23644: PUSH
23645: LD_INT 2
23647: ARRAY
23648: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
23649: LD_VAR 0 13
23653: PUSH
23654: LD_VAR 0 12
23658: PUSH
23659: LD_INT 1
23661: ARRAY
23662: PPUSH
23663: CALL_OW 110
23667: PUSH
23668: LD_INT 0
23670: EQUAL
23671: AND
23672: IFFALSE 23734
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
23674: LD_VAR 0 12
23678: PUSH
23679: LD_INT 1
23681: ARRAY
23682: PPUSH
23683: CALL_OW 314
23687: NOT
23688: PUSH
23689: LD_VAR 0 12
23693: PUSH
23694: LD_INT 1
23696: ARRAY
23697: PPUSH
23698: CALL_OW 110
23702: PUSH
23703: LD_INT 0
23705: EQUAL
23706: AND
23707: IFFALSE 23732
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
23709: LD_VAR 0 12
23713: PUSH
23714: LD_INT 1
23716: ARRAY
23717: PPUSH
23718: LD_VAR 0 5
23722: PPUSH
23723: LD_VAR 0 6
23727: PPUSH
23728: CALL_OW 117
// end ; end else
23732: GO 23820
// begin for j = 1 to collectors do
23734: LD_ADDR_VAR 0 4
23738: PUSH
23739: DOUBLE
23740: LD_INT 1
23742: DEC
23743: ST_TO_ADDR
23744: LD_VAR 0 12
23748: PUSH
23749: FOR_TO
23750: IFFALSE 23818
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
23752: LD_VAR 0 12
23756: PUSH
23757: LD_VAR 0 4
23761: ARRAY
23762: PPUSH
23763: CALL_OW 314
23767: NOT
23768: PUSH
23769: LD_VAR 0 12
23773: PUSH
23774: LD_VAR 0 4
23778: ARRAY
23779: PPUSH
23780: CALL_OW 110
23784: PUSH
23785: LD_INT 0
23787: EQUAL
23788: AND
23789: IFFALSE 23816
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
23791: LD_VAR 0 12
23795: PUSH
23796: LD_VAR 0 4
23800: ARRAY
23801: PPUSH
23802: LD_VAR 0 5
23806: PPUSH
23807: LD_VAR 0 6
23811: PPUSH
23812: CALL 24209 0 3
// end ;
23816: GO 23749
23818: POP
23819: POP
// end ; if isEditor then
23820: LD_INT 1
23822: IFFALSE 23834
// begin debug_time := TimerEnd ( ) ;
23824: LD_ADDR_VAR 0 14
23828: PUSH
23829: CALL_OW 549
23833: ST_TO_ADDR
// end ; end ;
23834: GO 23597
23836: POP
23837: POP
// end ; end ;
23838: LD_VAR 0 2
23842: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
23843: LD_INT 0
23845: PPUSH
23846: PPUSH
23847: PPUSH
23848: PPUSH
23849: PPUSH
23850: PPUSH
// if not area then
23851: LD_VAR 0 1
23855: NOT
23856: IFFALSE 23862
// exit else
23858: GO 24124
23860: GO 24124
// if tick mod interval = 0 and Prob ( percent ) then
23862: LD_OWVAR 1
23866: PUSH
23867: LD_VAR 0 4
23871: MOD
23872: PUSH
23873: LD_INT 0
23875: EQUAL
23876: PUSH
23877: LD_VAR 0 3
23881: PPUSH
23882: CALL_OW 13
23886: AND
23887: IFFALSE 24124
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
23889: LD_VAR 0 1
23893: PPUSH
23894: CALL_OW 435
23898: PUSH
23899: LD_VAR 0 5
23903: LESS
23904: PUSH
23905: LD_VAR 0 5
23909: PUSH
23910: LD_INT 0
23912: EQUAL
23913: OR
23914: IFFALSE 24124
// begin Randomize ;
23916: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
23920: LD_ADDR_VAR 0 7
23924: PUSH
23925: LD_INT 1
23927: PPUSH
23928: LD_VAR 0 2
23932: PPUSH
23933: CALL_OW 12
23937: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
23938: LD_ADDR_VAR 0 9
23942: PUSH
23943: LD_VAR 0 1
23947: PPUSH
23948: LD_INT 0
23950: PPUSH
23951: CALL_OW 517
23955: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
23956: LD_ADDR_VAR 0 8
23960: PUSH
23961: LD_INT 1
23963: PPUSH
23964: LD_VAR 0 9
23968: PUSH
23969: LD_INT 1
23971: ARRAY
23972: PPUSH
23973: CALL_OW 12
23977: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
23978: LD_VAR 0 9
23982: PUSH
23983: LD_INT 1
23985: ARRAY
23986: PUSH
23987: LD_VAR 0 8
23991: ARRAY
23992: PPUSH
23993: LD_VAR 0 9
23997: PUSH
23998: LD_INT 2
24000: ARRAY
24001: PUSH
24002: LD_VAR 0 8
24006: ARRAY
24007: PPUSH
24008: CALL_OW 428
24012: PUSH
24013: LD_INT 0
24015: GREATER
24016: PUSH
24017: LD_VAR 0 9
24021: PUSH
24022: LD_INT 1
24024: ARRAY
24025: PUSH
24026: LD_VAR 0 8
24030: ARRAY
24031: PPUSH
24032: LD_VAR 0 9
24036: PUSH
24037: LD_INT 2
24039: ARRAY
24040: PUSH
24041: LD_VAR 0 8
24045: ARRAY
24046: PPUSH
24047: CALL_OW 284
24051: PUSH
24052: LD_INT 0
24054: GREATER
24055: AND
24056: IFFALSE 24082
// c := Rand ( 1 , tmp [ 1 ] ) ;
24058: LD_ADDR_VAR 0 8
24062: PUSH
24063: LD_INT 1
24065: PPUSH
24066: LD_VAR 0 9
24070: PUSH
24071: LD_INT 1
24073: ARRAY
24074: PPUSH
24075: CALL_OW 12
24079: ST_TO_ADDR
24080: GO 23978
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24082: LD_VAR 0 7
24086: PPUSH
24087: LD_VAR 0 9
24091: PUSH
24092: LD_INT 1
24094: ARRAY
24095: PUSH
24096: LD_VAR 0 8
24100: ARRAY
24101: PPUSH
24102: LD_VAR 0 9
24106: PUSH
24107: LD_INT 2
24109: ARRAY
24110: PUSH
24111: LD_VAR 0 8
24115: ARRAY
24116: PPUSH
24117: LD_INT 1
24119: PPUSH
24120: CALL_OW 54
// end ; end ; end ;
24124: LD_VAR 0 6
24128: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24129: LD_INT 0
24131: PPUSH
24132: PPUSH
// if not MREG_Crates then
24133: LD_EXP 29
24137: NOT
24138: IFFALSE 24142
// exit ;
24140: GO 24204
// for i = MREG_Crates downto 1 do
24142: LD_ADDR_VAR 0 2
24146: PUSH
24147: DOUBLE
24148: LD_EXP 29
24152: INC
24153: ST_TO_ADDR
24154: LD_INT 1
24156: PUSH
24157: FOR_DOWNTO
24158: IFFALSE 24202
// if MREG_Crates [ i ] [ 3 ] = 0 then
24160: LD_EXP 29
24164: PUSH
24165: LD_VAR 0 2
24169: ARRAY
24170: PUSH
24171: LD_INT 3
24173: ARRAY
24174: PUSH
24175: LD_INT 0
24177: EQUAL
24178: IFFALSE 24200
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24180: LD_ADDR_EXP 29
24184: PUSH
24185: LD_EXP 29
24189: PPUSH
24190: LD_VAR 0 2
24194: PPUSH
24195: CALL_OW 3
24199: ST_TO_ADDR
24200: GO 24157
24202: POP
24203: POP
// end ;
24204: LD_VAR 0 1
24208: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24209: LD_INT 0
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
// if not unit then
24215: LD_VAR 0 1
24219: NOT
24220: IFFALSE 24224
// exit ;
24222: GO 24359
// if HasTask ( unit ) or not CanCarry ( unit ) then
24224: LD_VAR 0 1
24228: PPUSH
24229: CALL_OW 314
24233: PUSH
24234: LD_VAR 0 1
24238: PPUSH
24239: CALL_OW 280
24243: NOT
24244: OR
24245: IFFALSE 24249
// exit ;
24247: GO 24359
// side := GetSide ( unit ) ;
24249: LD_ADDR_VAR 0 6
24253: PUSH
24254: LD_VAR 0 1
24258: PPUSH
24259: CALL_OW 255
24263: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24264: LD_ADDR_VAR 0 7
24268: PUSH
24269: LD_VAR 0 6
24273: PPUSH
24274: LD_INT 30
24276: PUSH
24277: LD_INT 1
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PPUSH
24284: CALL 10967 0 2
24288: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24289: LD_VAR 0 1
24293: PPUSH
24294: CALL_OW 281
24298: PUSH
24299: LD_VAR 0 7
24303: NOT
24304: OR
24305: IFFALSE 24311
// exit else
24307: GO 24359
24309: GO 24359
// if GetResourceAmountXY ( x , y ) then
24311: LD_VAR 0 2
24315: PPUSH
24316: LD_VAR 0 3
24320: PPUSH
24321: CALL_OW 284
24325: IFFALSE 24357
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24327: LD_VAR 0 1
24331: PPUSH
24332: LD_VAR 0 2
24336: PPUSH
24337: LD_VAR 0 3
24341: PPUSH
24342: LD_VAR 0 7
24346: PUSH
24347: LD_INT 1
24349: ARRAY
24350: PPUSH
24351: CALL 30945 0 4
// end else
24355: GO 24359
// exit ;
24357: GO 24359
// end ;
24359: LD_VAR 0 4
24363: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24364: LD_INT 0
24366: PPUSH
24367: PPUSH
24368: PPUSH
24369: PPUSH
24370: PPUSH
// result := 0 ;
24371: LD_ADDR_VAR 0 2
24375: PUSH
24376: LD_INT 0
24378: ST_TO_ADDR
// p := 1 ;
24379: LD_ADDR_VAR 0 4
24383: PUSH
24384: LD_INT 1
24386: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24387: LD_ADDR_VAR 0 3
24391: PUSH
24392: DOUBLE
24393: LD_INT 1
24395: DEC
24396: ST_TO_ADDR
24397: LD_EXP 58
24401: PUSH
24402: LD_VAR 0 1
24406: ARRAY
24407: PUSH
24408: LD_INT 1
24410: ARRAY
24411: PUSH
24412: LD_INT 2
24414: DIVREAL
24415: PUSH
24416: FOR_TO
24417: IFFALSE 24541
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24419: LD_ADDR_VAR 0 5
24423: PUSH
24424: LD_INT 81
24426: PUSH
24427: LD_VAR 0 1
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: PUSH
24436: LD_INT 92
24438: PUSH
24439: LD_EXP 58
24443: PUSH
24444: LD_VAR 0 1
24448: ARRAY
24449: PUSH
24450: LD_INT 1
24452: ARRAY
24453: PUSH
24454: LD_VAR 0 4
24458: ARRAY
24459: PUSH
24460: LD_EXP 58
24464: PUSH
24465: LD_VAR 0 1
24469: ARRAY
24470: PUSH
24471: LD_INT 1
24473: ARRAY
24474: PUSH
24475: LD_VAR 0 4
24479: PUSH
24480: LD_INT 1
24482: PLUS
24483: ARRAY
24484: PUSH
24485: LD_INT 12
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: LIST
24492: LIST
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: PPUSH
24498: CALL_OW 69
24502: ST_TO_ADDR
// if tmp then
24503: LD_VAR 0 5
24507: IFFALSE 24525
// result := result + tmp ;
24509: LD_ADDR_VAR 0 2
24513: PUSH
24514: LD_VAR 0 2
24518: PUSH
24519: LD_VAR 0 5
24523: PLUS
24524: ST_TO_ADDR
// p := p + 2 ;
24525: LD_ADDR_VAR 0 4
24529: PUSH
24530: LD_VAR 0 4
24534: PUSH
24535: LD_INT 2
24537: PLUS
24538: ST_TO_ADDR
// end ;
24539: GO 24416
24541: POP
24542: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
24543: LD_EXP 59
24547: PUSH
24548: LD_VAR 0 1
24552: ARRAY
24553: PPUSH
24554: LD_INT 81
24556: PUSH
24557: LD_VAR 0 1
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PPUSH
24566: CALL_OW 70
24570: IFFALSE 24611
// result := result + FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
24572: LD_ADDR_VAR 0 2
24576: PUSH
24577: LD_VAR 0 2
24581: PUSH
24582: LD_EXP 59
24586: PUSH
24587: LD_VAR 0 1
24591: ARRAY
24592: PPUSH
24593: LD_INT 81
24595: PUSH
24596: LD_VAR 0 1
24600: PUSH
24601: EMPTY
24602: LIST
24603: LIST
24604: PPUSH
24605: CALL_OW 70
24609: PLUS
24610: ST_TO_ADDR
// end ; end_of_file
24611: LD_VAR 0 2
24615: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
24616: LD_INT 0
24618: PPUSH
24619: PPUSH
24620: PPUSH
// pom := GetBase ( fac ) ;
24621: LD_ADDR_VAR 0 5
24625: PUSH
24626: LD_VAR 0 1
24630: PPUSH
24631: CALL_OW 274
24635: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24636: LD_ADDR_VAR 0 4
24640: PUSH
24641: LD_VAR 0 2
24645: PUSH
24646: LD_INT 1
24648: ARRAY
24649: PPUSH
24650: LD_VAR 0 2
24654: PUSH
24655: LD_INT 2
24657: ARRAY
24658: PPUSH
24659: LD_VAR 0 2
24663: PUSH
24664: LD_INT 3
24666: ARRAY
24667: PPUSH
24668: LD_VAR 0 2
24672: PUSH
24673: LD_INT 4
24675: ARRAY
24676: PPUSH
24677: CALL_OW 449
24681: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
24682: LD_VAR 0 5
24686: PPUSH
24687: LD_INT 1
24689: PPUSH
24690: CALL_OW 275
24694: PUSH
24695: LD_VAR 0 4
24699: PUSH
24700: LD_INT 1
24702: ARRAY
24703: GREATEREQUAL
24704: PUSH
24705: LD_VAR 0 5
24709: PPUSH
24710: LD_INT 2
24712: PPUSH
24713: CALL_OW 275
24717: PUSH
24718: LD_VAR 0 4
24722: PUSH
24723: LD_INT 2
24725: ARRAY
24726: GREATEREQUAL
24727: AND
24728: PUSH
24729: LD_VAR 0 5
24733: PPUSH
24734: LD_INT 3
24736: PPUSH
24737: CALL_OW 275
24741: PUSH
24742: LD_VAR 0 4
24746: PUSH
24747: LD_INT 3
24749: ARRAY
24750: GREATEREQUAL
24751: AND
24752: IFFALSE 24764
// result := true else
24754: LD_ADDR_VAR 0 3
24758: PUSH
24759: LD_INT 1
24761: ST_TO_ADDR
24762: GO 24772
// result := false ;
24764: LD_ADDR_VAR 0 3
24768: PUSH
24769: LD_INT 0
24771: ST_TO_ADDR
// end ;
24772: LD_VAR 0 3
24776: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
24777: LD_INT 0
24779: PPUSH
24780: PPUSH
24781: PPUSH
// result := false ;
24782: LD_ADDR_VAR 0 3
24786: PUSH
24787: LD_INT 0
24789: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
24790: LD_ADDR_VAR 0 4
24794: PUSH
24795: LD_EXP 46
24799: PUSH
24800: LD_VAR 0 1
24804: ARRAY
24805: ST_TO_ADDR
// if tmp then
24806: LD_VAR 0 4
24810: IFFALSE 24862
// for i = 1 to tmp do
24812: LD_ADDR_VAR 0 5
24816: PUSH
24817: DOUBLE
24818: LD_INT 1
24820: DEC
24821: ST_TO_ADDR
24822: LD_VAR 0 4
24826: PUSH
24827: FOR_TO
24828: IFFALSE 24860
// if component = tmp [ i ] then
24830: LD_VAR 0 2
24834: PUSH
24835: LD_VAR 0 4
24839: PUSH
24840: LD_VAR 0 5
24844: ARRAY
24845: EQUAL
24846: IFFALSE 24858
// begin result := true ;
24848: LD_ADDR_VAR 0 3
24852: PUSH
24853: LD_INT 1
24855: ST_TO_ADDR
// break ;
24856: GO 24860
// end ;
24858: GO 24827
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 3
24866: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
// if fac then
24872: LD_VAR 0 2
24876: IFFALSE 25111
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
24878: LD_VAR 0 2
24882: PPUSH
24883: LD_VAR 0 3
24887: PPUSH
24888: CALL 24616 0 2
24892: PUSH
24893: LD_VAR 0 2
24897: PPUSH
24898: CALL_OW 461
24902: PUSH
24903: LD_INT 2
24905: EQUAL
24906: AND
24907: PUSH
24908: LD_VAR 0 2
24912: PPUSH
24913: LD_VAR 0 3
24917: PUSH
24918: LD_INT 1
24920: ARRAY
24921: PPUSH
24922: LD_VAR 0 3
24926: PUSH
24927: LD_INT 2
24929: ARRAY
24930: PPUSH
24931: LD_VAR 0 3
24935: PUSH
24936: LD_INT 3
24938: ARRAY
24939: PPUSH
24940: LD_VAR 0 3
24944: PUSH
24945: LD_INT 4
24947: ARRAY
24948: PPUSH
24949: CALL_OW 448
24953: AND
24954: IFFALSE 25101
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24956: LD_VAR 0 2
24960: PPUSH
24961: LD_VAR 0 3
24965: PUSH
24966: LD_INT 1
24968: ARRAY
24969: PPUSH
24970: LD_VAR 0 3
24974: PUSH
24975: LD_INT 2
24977: ARRAY
24978: PPUSH
24979: LD_VAR 0 3
24983: PUSH
24984: LD_INT 3
24986: ARRAY
24987: PPUSH
24988: LD_VAR 0 3
24992: PUSH
24993: LD_INT 4
24995: ARRAY
24996: PPUSH
24997: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25001: LD_ADDR_VAR 0 6
25005: PUSH
25006: LD_EXP 46
25010: PUSH
25011: LD_VAR 0 1
25015: ARRAY
25016: ST_TO_ADDR
// for i = 4 downto 1 do
25017: LD_ADDR_VAR 0 5
25021: PUSH
25022: DOUBLE
25023: LD_INT 4
25025: INC
25026: ST_TO_ADDR
25027: LD_INT 1
25029: PUSH
25030: FOR_DOWNTO
25031: IFFALSE 25064
// tab := Remove ( tab , list [ i ] , true ) ;
25033: LD_ADDR_VAR 0 6
25037: PUSH
25038: LD_VAR 0 6
25042: PPUSH
25043: LD_VAR 0 3
25047: PUSH
25048: LD_VAR 0 5
25052: ARRAY
25053: PPUSH
25054: LD_INT 1
25056: PPUSH
25057: CALL 29940 0 3
25061: ST_TO_ADDR
25062: GO 25030
25064: POP
25065: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25066: LD_ADDR_EXP 46
25070: PUSH
25071: LD_EXP 46
25075: PPUSH
25076: LD_VAR 0 1
25080: PPUSH
25081: LD_VAR 0 6
25085: PPUSH
25086: CALL_OW 1
25090: ST_TO_ADDR
// result := true ;
25091: LD_ADDR_VAR 0 4
25095: PUSH
25096: LD_INT 1
25098: ST_TO_ADDR
// end else
25099: GO 25109
// result := false ;
25101: LD_ADDR_VAR 0 4
25105: PUSH
25106: LD_INT 0
25108: ST_TO_ADDR
// end else
25109: GO 25119
// result := false ;
25111: LD_ADDR_VAR 0 4
25115: PUSH
25116: LD_INT 0
25118: ST_TO_ADDR
// end ;
25119: LD_VAR 0 4
25123: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25124: LD_INT 0
25126: PPUSH
25127: PPUSH
// if MREG_Parking [ side ] then
25128: LD_EXP 53
25132: PUSH
25133: LD_VAR 0 1
25137: ARRAY
25138: IFFALSE 25291
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25140: LD_VAR 0 2
25144: PPUSH
25145: LD_EXP 53
25149: PUSH
25150: LD_VAR 0 1
25154: ARRAY
25155: PPUSH
25156: CALL_OW 308
25160: NOT
25161: IFFALSE 25291
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25163: LD_VAR 0 2
25167: PPUSH
25168: LD_EXP 53
25172: PUSH
25173: LD_VAR 0 1
25177: ARRAY
25178: PPUSH
25179: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25183: LD_VAR 0 2
25187: PPUSH
25188: CALL_OW 263
25192: PUSH
25193: LD_INT 1
25195: EQUAL
25196: IFFALSE 25291
// begin i := GetDriver ( veh ) ;
25198: LD_ADDR_VAR 0 4
25202: PUSH
25203: LD_VAR 0 2
25207: PPUSH
25208: CALL 30475 0 1
25212: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25213: LD_INT 35
25215: PPUSH
25216: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) ;
25220: LD_VAR 0 2
25224: PPUSH
25225: LD_EXP 53
25229: PUSH
25230: LD_VAR 0 1
25234: ARRAY
25235: PPUSH
25236: CALL_OW 308
25240: IFFALSE 25213
// ComExitVehicle ( i ) ;
25242: LD_VAR 0 4
25246: PPUSH
25247: CALL_OW 121
// Wait ( 1 ) ;
25251: LD_INT 1
25253: PPUSH
25254: CALL_OW 67
// ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25258: LD_VAR 0 4
25262: PPUSH
25263: LD_VAR 0 1
25267: PPUSH
25268: LD_INT 30
25270: PUSH
25271: LD_INT 3
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PPUSH
25278: CALL 10967 0 2
25282: PUSH
25283: LD_INT 1
25285: ARRAY
25286: PPUSH
25287: CALL_OW 120
// end ; end ; end ;
25291: LD_VAR 0 3
25295: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25296: LD_INT 0
25298: PPUSH
25299: PPUSH
25300: PPUSH
25301: PPUSH
25302: PPUSH
25303: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25304: LD_VAR 0 1
25308: PPUSH
25309: LD_INT 30
25311: PUSH
25312: LD_INT 3
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PPUSH
25319: CALL 10967 0 2
25323: IFFALSE 25507
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25325: LD_VAR 0 1
25329: PPUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 3
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PPUSH
25340: CALL 10967 0 2
25344: PUSH
25345: LD_INT 1
25347: ARRAY
25348: PPUSH
25349: CALL_OW 461
25353: PUSH
25354: LD_INT 2
25356: EQUAL
25357: IFFALSE 25507
// begin for i = 1 to MREG_TurretWeapon do
25359: LD_ADDR_VAR 0 3
25363: PUSH
25364: DOUBLE
25365: LD_INT 1
25367: DEC
25368: ST_TO_ADDR
25369: LD_EXP 38
25373: PUSH
25374: FOR_TO
25375: IFFALSE 25505
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25377: LD_EXP 38
25381: PUSH
25382: LD_VAR 0 3
25386: ARRAY
25387: PUSH
25388: LD_INT 1
25390: ARRAY
25391: PUSH
25392: LD_VAR 0 1
25396: EQUAL
25397: IFFALSE 25503
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25399: LD_ADDR_VAR 0 5
25403: PUSH
25404: LD_EXP 38
25408: PUSH
25409: LD_VAR 0 3
25413: ARRAY
25414: PUSH
25415: LD_INT 2
25417: ARRAY
25418: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25419: LD_ADDR_VAR 0 6
25423: PUSH
25424: LD_EXP 38
25428: PUSH
25429: LD_VAR 0 3
25433: ARRAY
25434: PUSH
25435: LD_INT 3
25437: ARRAY
25438: PUSH
25439: LD_INT 1
25441: ARRAY
25442: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25443: LD_ADDR_VAR 0 7
25447: PUSH
25448: LD_EXP 38
25452: PUSH
25453: LD_VAR 0 3
25457: ARRAY
25458: PUSH
25459: LD_INT 3
25461: ARRAY
25462: PUSH
25463: LD_INT 2
25465: ARRAY
25466: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25467: LD_ADDR_VAR 0 4
25471: PUSH
25472: LD_VAR 0 6
25476: PPUSH
25477: LD_VAR 0 7
25481: PPUSH
25482: CALL_OW 428
25486: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25487: LD_VAR 0 4
25491: PPUSH
25492: LD_VAR 0 5
25496: PPUSH
25497: CALL_OW 148
// break ;
25501: GO 25505
// end ;
25503: GO 25374
25505: POP
25506: POP
// end ; end ;
25507: LD_VAR 0 2
25511: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
25517: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25518: LD_ADDR_VAR 0 4
25522: PUSH
25523: LD_VAR 0 1
25527: PPUSH
25528: LD_INT 32
25530: PUSH
25531: LD_INT 1
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PPUSH
25538: CALL 10967 0 2
25542: ST_TO_ADDR
// if not tmp then
25543: LD_VAR 0 4
25547: NOT
25548: IFFALSE 25554
// exit else
25550: GO 25636
25552: GO 25636
// begin for i = 1 to tmp do
25554: LD_ADDR_VAR 0 3
25558: PUSH
25559: DOUBLE
25560: LD_INT 1
25562: DEC
25563: ST_TO_ADDR
25564: LD_VAR 0 4
25568: PUSH
25569: FOR_TO
25570: IFFALSE 25634
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
25572: LD_VAR 0 4
25576: PUSH
25577: LD_VAR 0 3
25581: ARRAY
25582: PPUSH
25583: CALL_OW 261
25587: PUSH
25588: LD_INT 20
25590: LESS
25591: PUSH
25592: LD_VAR 0 4
25596: PUSH
25597: LD_VAR 0 3
25601: ARRAY
25602: PPUSH
25603: CALL_OW 110
25607: PUSH
25608: LD_INT 0
25610: EQUAL
25611: AND
25612: IFFALSE 25632
// begin SetTag ( tmp [ i ] , 21 ) ;
25614: LD_VAR 0 4
25618: PUSH
25619: LD_VAR 0 3
25623: ARRAY
25624: PPUSH
25625: LD_INT 21
25627: PPUSH
25628: CALL_OW 109
// end ;
25632: GO 25569
25634: POP
25635: POP
// end ; end ;
25636: LD_VAR 0 2
25640: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
25641: LD_INT 0
25643: PPUSH
25644: PPUSH
25645: PPUSH
25646: PPUSH
25647: PPUSH
// if not unit then
25648: LD_VAR 0 1
25652: NOT
25653: IFFALSE 25657
// exit ;
25655: GO 25862
// side := GetSide ( unit ) ;
25657: LD_ADDR_VAR 0 3
25661: PUSH
25662: LD_VAR 0 1
25666: PPUSH
25667: CALL_OW 255
25671: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
25672: LD_ADDR_VAR 0 5
25676: PUSH
25677: LD_VAR 0 3
25681: PPUSH
25682: LD_INT 2
25684: PUSH
25685: LD_INT 30
25687: PUSH
25688: LD_INT 1
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: PUSH
25695: LD_INT 30
25697: PUSH
25698: LD_INT 3
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: PUSH
25705: LD_INT 30
25707: PUSH
25708: LD_INT 29
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: LIST
25719: LIST
25720: PPUSH
25721: CALL 10967 0 2
25725: ST_TO_ADDR
// if not b then
25726: LD_VAR 0 5
25730: NOT
25731: IFFALSE 25737
// exit else
25733: GO 25862
25735: GO 25862
// if GetTag ( unit ) = 21 then
25737: LD_VAR 0 1
25741: PPUSH
25742: CALL_OW 110
25746: PUSH
25747: LD_INT 21
25749: EQUAL
25750: IFFALSE 25862
// begin c := NearestUnitToUnit ( b , unit ) ;
25752: LD_ADDR_VAR 0 6
25756: PUSH
25757: LD_VAR 0 5
25761: PPUSH
25762: LD_VAR 0 1
25766: PPUSH
25767: CALL_OW 74
25771: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
25772: LD_VAR 0 1
25776: PPUSH
25777: LD_VAR 0 6
25781: PPUSH
25782: CALL_OW 250
25786: PPUSH
25787: LD_VAR 0 6
25791: PPUSH
25792: CALL_OW 251
25796: PPUSH
25797: CALL_OW 297
25801: PUSH
25802: LD_INT 6
25804: GREATER
25805: IFFALSE 25838
// ComMoveXY ( unit , GetX ( c ) , GetY ( c ) ) else
25807: LD_VAR 0 1
25811: PPUSH
25812: LD_VAR 0 6
25816: PPUSH
25817: CALL_OW 250
25821: PPUSH
25822: LD_VAR 0 6
25826: PPUSH
25827: CALL_OW 251
25831: PPUSH
25832: CALL_OW 111
25836: GO 25862
// begin SetFuel ( unit , 100 ) ;
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 100
25845: PPUSH
25846: CALL_OW 240
// SetTag ( unit , 0 ) ;
25850: LD_VAR 0 1
25854: PPUSH
25855: LD_INT 0
25857: PPUSH
25858: CALL_OW 109
// end ; end ; end ;
25862: LD_VAR 0 2
25866: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
25867: LD_INT 0
25869: PPUSH
25870: PPUSH
25871: PPUSH
25872: PPUSH
25873: PPUSH
25874: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
25875: LD_ADDR_VAR 0 7
25879: PUSH
25880: LD_VAR 0 1
25884: PPUSH
25885: LD_INT 33
25887: PUSH
25888: LD_INT 2
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 3
25897: PUSH
25898: LD_INT 61
25900: PUSH
25901: EMPTY
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PPUSH
25912: CALL 10967 0 2
25916: ST_TO_ADDR
// if not vehs then
25917: LD_VAR 0 7
25921: NOT
25922: IFFALSE 25926
// exit ;
25924: GO 26211
// if nation = 1 then
25926: LD_VAR 0 2
25930: PUSH
25931: LD_INT 1
25933: EQUAL
25934: IFFALSE 26104
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
25936: LD_VAR 0 1
25940: PPUSH
25941: LD_INT 30
25943: PUSH
25944: LD_INT 36
25946: PUSH
25947: EMPTY
25948: LIST
25949: LIST
25950: PPUSH
25951: CALL 10967 0 2
25955: NOT
25956: IFFALSE 25962
// exit else
25958: GO 26211
25960: GO 26102
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
25962: LD_ADDR_VAR 0 5
25966: PUSH
25967: LD_VAR 0 1
25971: PPUSH
25972: LD_INT 30
25974: PUSH
25975: LD_INT 36
25977: PUSH
25978: EMPTY
25979: LIST
25980: LIST
25981: PPUSH
25982: CALL 10967 0 2
25986: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
25987: LD_ADDR_VAR 0 6
25991: PUSH
25992: LD_VAR 0 5
25996: PUSH
25997: LD_INT 1
25999: ARRAY
26000: PPUSH
26001: CALL_OW 313
26005: ST_TO_ADDR
// for i = vehs downto 1 do
26006: LD_ADDR_VAR 0 4
26010: PUSH
26011: DOUBLE
26012: LD_VAR 0 7
26016: INC
26017: ST_TO_ADDR
26018: LD_INT 1
26020: PUSH
26021: FOR_DOWNTO
26022: IFFALSE 26100
// begin if not IsControledBy ( vehs [ i ] ) then
26024: LD_VAR 0 7
26028: PUSH
26029: LD_VAR 0 4
26033: ARRAY
26034: PPUSH
26035: CALL_OW 312
26039: NOT
26040: IFFALSE 26098
// begin tmp := MCV_RemoteDriver ( oper ) ;
26042: LD_ADDR_VAR 0 8
26046: PUSH
26047: LD_VAR 0 6
26051: PPUSH
26052: CALL 26216 0 1
26056: ST_TO_ADDR
// if not tmp then
26057: LD_VAR 0 8
26061: NOT
26062: IFFALSE 26070
// exit else
26064: POP
26065: POP
26066: GO 26211
26068: GO 26098
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26070: LD_VAR 0 7
26074: PUSH
26075: LD_VAR 0 4
26079: ARRAY
26080: PPUSH
26081: LD_VAR 0 8
26085: PUSH
26086: LD_INT 1
26088: ARRAY
26089: PUSH
26090: LD_INT 1
26092: ARRAY
26093: PPUSH
26094: CALL_OW 135
// end ; end ;
26098: GO 26021
26100: POP
26101: POP
// end ; end else
26102: GO 26211
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26104: LD_VAR 0 1
26108: PPUSH
26109: LD_INT 34
26111: PUSH
26112: LD_INT 31
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: PPUSH
26119: CALL 10967 0 2
26123: NOT
26124: IFFALSE 26130
// exit else
26126: GO 26211
26128: GO 26211
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26130: LD_ADDR_VAR 0 5
26134: PUSH
26135: LD_VAR 0 1
26139: PPUSH
26140: LD_INT 34
26142: PUSH
26143: LD_INT 31
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PPUSH
26150: CALL 10967 0 2
26154: ST_TO_ADDR
// oper := [ ] ;
26155: LD_ADDR_VAR 0 6
26159: PUSH
26160: EMPTY
26161: ST_TO_ADDR
// for i = 1 to ct do
26162: LD_ADDR_VAR 0 4
26166: PUSH
26167: DOUBLE
26168: LD_INT 1
26170: DEC
26171: ST_TO_ADDR
26172: LD_VAR 0 5
26176: PUSH
26177: FOR_TO
26178: IFFALSE 26209
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26180: LD_ADDR_VAR 0 6
26184: PUSH
26185: LD_VAR 0 6
26189: PUSH
26190: LD_VAR 0 5
26194: PUSH
26195: LD_VAR 0 4
26199: ARRAY
26200: PPUSH
26201: CALL 30475 0 1
26205: ADD
26206: ST_TO_ADDR
26207: GO 26177
26209: POP
26210: POP
// end ; end ; end ;
26211: LD_VAR 0 3
26215: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26216: LD_INT 0
26218: PPUSH
26219: PPUSH
26220: PPUSH
26221: PPUSH
26222: PPUSH
26223: PPUSH
// if not drivers then
26224: LD_VAR 0 1
26228: NOT
26229: IFFALSE 26235
// exit else
26231: GO 26515
26233: GO 26515
// begin linked := [ ] ;
26235: LD_ADDR_VAR 0 5
26239: PUSH
26240: EMPTY
26241: ST_TO_ADDR
// for i = 1 to drivers do
26242: LD_ADDR_VAR 0 3
26246: PUSH
26247: DOUBLE
26248: LD_INT 1
26250: DEC
26251: ST_TO_ADDR
26252: LD_VAR 0 1
26256: PUSH
26257: FOR_TO
26258: IFFALSE 26503
// begin if CanControl ( drivers [ i ] ) then
26260: LD_VAR 0 1
26264: PUSH
26265: LD_VAR 0 3
26269: ARRAY
26270: PPUSH
26271: CALL 31047 0 1
26275: IFFALSE 26501
// if i > 1 then
26277: LD_VAR 0 3
26281: PUSH
26282: LD_INT 1
26284: GREATER
26285: IFFALSE 26462
// begin m := false ;
26287: LD_ADDR_VAR 0 6
26291: PUSH
26292: LD_INT 0
26294: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26295: LD_ADDR_VAR 0 7
26299: PUSH
26300: LD_VAR 0 1
26304: PUSH
26305: LD_VAR 0 3
26309: ARRAY
26310: PPUSH
26311: CALL_OW 432
26315: ST_TO_ADDR
// for j = 1 to linked do
26316: LD_ADDR_VAR 0 4
26320: PUSH
26321: DOUBLE
26322: LD_INT 1
26324: DEC
26325: ST_TO_ADDR
26326: LD_VAR 0 5
26330: PUSH
26331: FOR_TO
26332: IFFALSE 26406
// begin if l < linked [ j ] [ 2 ] then
26334: LD_VAR 0 7
26338: PUSH
26339: LD_VAR 0 5
26343: PUSH
26344: LD_VAR 0 4
26348: ARRAY
26349: PUSH
26350: LD_INT 2
26352: ARRAY
26353: LESS
26354: IFFALSE 26404
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26356: LD_ADDR_VAR 0 5
26360: PUSH
26361: LD_VAR 0 5
26365: PPUSH
26366: LD_INT 1
26368: PPUSH
26369: LD_VAR 0 1
26373: PUSH
26374: LD_VAR 0 3
26378: ARRAY
26379: PUSH
26380: LD_VAR 0 7
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PPUSH
26389: CALL_OW 2
26393: ST_TO_ADDR
// m := true ;
26394: LD_ADDR_VAR 0 6
26398: PUSH
26399: LD_INT 1
26401: ST_TO_ADDR
// break ;
26402: GO 26406
// end ; end ;
26404: GO 26331
26406: POP
26407: POP
// if not m then
26408: LD_VAR 0 6
26412: NOT
26413: IFFALSE 26460
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26415: LD_ADDR_VAR 0 5
26419: PUSH
26420: LD_VAR 0 5
26424: PUSH
26425: LD_VAR 0 1
26429: PUSH
26430: LD_VAR 0 3
26434: ARRAY
26435: PUSH
26436: LD_VAR 0 1
26440: PUSH
26441: LD_VAR 0 3
26445: ARRAY
26446: PPUSH
26447: CALL_OW 432
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: EMPTY
26457: LIST
26458: ADD
26459: ST_TO_ADDR
// end else
26460: GO 26501
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26462: LD_ADDR_VAR 0 5
26466: PUSH
26467: LD_VAR 0 1
26471: PUSH
26472: LD_VAR 0 3
26476: ARRAY
26477: PUSH
26478: LD_VAR 0 1
26482: PUSH
26483: LD_VAR 0 3
26487: ARRAY
26488: PPUSH
26489: CALL_OW 432
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: EMPTY
26499: LIST
26500: ST_TO_ADDR
// end ;
26501: GO 26257
26503: POP
26504: POP
// result := linked ;
26505: LD_ADDR_VAR 0 2
26509: PUSH
26510: LD_VAR 0 5
26514: ST_TO_ADDR
// end ; end ;
26515: LD_VAR 0 2
26519: RET
// export function MCV_ToRepair ( unit ) ; begin
26520: LD_INT 0
26522: PPUSH
// if not unit then
26523: LD_VAR 0 1
26527: NOT
26528: IFFALSE 26534
// exit else
26530: GO 26565
26532: GO 26565
// begin SetTag ( unit , 6 ) ;
26534: LD_VAR 0 1
26538: PPUSH
26539: LD_INT 6
26541: PPUSH
26542: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
26546: LD_VAR 0 1
26550: PPUSH
26551: CALL_OW 255
26555: PPUSH
26556: LD_VAR 0 1
26560: PPUSH
26561: CALL 25124 0 2
// end ; end ;
26565: LD_VAR 0 2
26569: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
26570: LD_INT 0
26572: PPUSH
26573: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
26574: LD_VAR 0 1
26578: PPUSH
26579: LD_INT 6
26581: PPUSH
26582: EMPTY
26583: PPUSH
26584: CALL 11670 0 3
26588: IFFALSE 26681
// begin for i = MCF_Tag ( side , 6 , [ ] ) to 1 do
26590: LD_ADDR_VAR 0 3
26594: PUSH
26595: DOUBLE
26596: LD_VAR 0 1
26600: PPUSH
26601: LD_INT 6
26603: PPUSH
26604: EMPTY
26605: PPUSH
26606: CALL 11670 0 3
26610: DEC
26611: ST_TO_ADDR
26612: LD_INT 1
26614: PUSH
26615: FOR_TO
26616: IFFALSE 26679
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
26618: LD_VAR 0 1
26622: PPUSH
26623: LD_INT 6
26625: PPUSH
26626: EMPTY
26627: PPUSH
26628: CALL 11670 0 3
26632: PUSH
26633: LD_VAR 0 3
26637: ARRAY
26638: PPUSH
26639: CALL_OW 256
26643: PUSH
26644: LD_INT 1000
26646: EQUAL
26647: IFFALSE 26677
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
26649: LD_VAR 0 1
26653: PPUSH
26654: LD_INT 6
26656: PPUSH
26657: EMPTY
26658: PPUSH
26659: CALL 11670 0 3
26663: PUSH
26664: LD_VAR 0 3
26668: ARRAY
26669: PPUSH
26670: LD_INT 0
26672: PPUSH
26673: CALL_OW 109
26677: GO 26615
26679: POP
26680: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
26681: LD_ADDR_VAR 0 3
26685: PUSH
26686: LD_VAR 0 1
26690: PPUSH
26691: EMPTY
26692: PPUSH
26693: CALL 11268 0 2
26697: PUSH
26698: LD_VAR 0 1
26702: PPUSH
26703: LD_INT 7
26705: PPUSH
26706: EMPTY
26707: PPUSH
26708: CALL 11670 0 3
26712: DIFF
26713: PUSH
26714: FOR_IN
26715: IFFALSE 26759
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
26717: LD_VAR 0 3
26721: PPUSH
26722: CALL_OW 256
26726: PUSH
26727: LD_INT 650
26729: LESS
26730: PUSH
26731: LD_VAR 0 3
26735: PPUSH
26736: CALL_OW 110
26740: PUSH
26741: LD_INT 6
26743: EQUAL
26744: NOT
26745: AND
26746: IFFALSE 26757
// MCV_ToRepair ( i ) ;
26748: LD_VAR 0 3
26752: PPUSH
26753: CALL 26520 0 1
26757: GO 26714
26759: POP
26760: POP
// end ; end_of_file end_of_file
26761: LD_VAR 0 2
26765: RET
// on SailEvent ( event ) do begin if isEditor then
26766: LD_INT 1
26768: IFFALSE 26779
// MC_Show ( event ) ;
26770: LD_VAR 0 1
26774: PPUSH
26775: CALL 7885 0 1
// if event = 101 and dialog_north then
26779: LD_VAR 0 1
26783: PUSH
26784: LD_INT 101
26786: EQUAL
26787: PUSH
26788: LD_EXP 5
26792: AND
26793: IFFALSE 26857
// begin dialog_north := false ;
26795: LD_ADDR_EXP 5
26799: PUSH
26800: LD_INT 0
26802: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
26803: LD_EXP 2
26807: PPUSH
26808: LD_STRING DS1
26810: PUSH
26811: LD_STRING DS2
26813: PUSH
26814: LD_STRING DS3
26816: PUSH
26817: LD_STRING DS6
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: PPUSH
26829: LD_INT 4
26831: PPUSH
26832: CALL_OW 12
26836: ARRAY
26837: PPUSH
26838: CALL_OW 94
// Wait ( 4 4$00 ) ;
26842: LD_INT 8400
26844: PPUSH
26845: CALL_OW 67
// dialog_north := true ;
26849: LD_ADDR_EXP 5
26853: PUSH
26854: LD_INT 1
26856: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
26857: LD_VAR 0 1
26861: PUSH
26862: LD_INT 102
26864: EQUAL
26865: PUSH
26866: LD_EXP 6
26870: AND
26871: IFFALSE 26931
// begin dialog_south := false ;
26873: LD_ADDR_EXP 6
26877: PUSH
26878: LD_INT 0
26880: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
26881: LD_EXP 1
26885: PPUSH
26886: LD_STRING DJ1
26888: PUSH
26889: LD_STRING DJ4
26891: PUSH
26892: LD_STRING DJ6
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: PPUSH
26903: LD_INT 3
26905: PPUSH
26906: CALL_OW 12
26910: ARRAY
26911: PPUSH
26912: CALL_OW 94
// Wait ( 4 4$00 ) ;
26916: LD_INT 8400
26918: PPUSH
26919: CALL_OW 67
// dialog_south := true ;
26923: LD_ADDR_EXP 6
26927: PUSH
26928: LD_INT 1
26930: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
26931: LD_VAR 0 1
26935: PUSH
26936: LD_INT 104
26938: EQUAL
26939: PUSH
26940: LD_EXP 7
26944: AND
26945: IFFALSE 26967
// begin dialog_popov := false ;
26947: LD_ADDR_EXP 7
26951: PUSH
26952: LD_INT 0
26954: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
26955: LD_EXP 24
26959: PPUSH
26960: LD_STRING DR4
26962: PPUSH
26963: CALL_OW 94
// end ; end ;
26967: PPOPN 1
26969: END
// on BuildingStarted ( b , unit ) do var side , i ;
26970: LD_INT 0
26972: PPUSH
26973: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
26974: LD_EXP 34
26978: PUSH
26979: LD_VAR 0 1
26983: PPUSH
26984: CALL_OW 255
26988: ARRAY
26989: IFFALSE 27120
// begin side := GetSide ( b ) ;
26991: LD_ADDR_VAR 0 3
26995: PUSH
26996: LD_VAR 0 1
27000: PPUSH
27001: CALL_OW 255
27005: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27006: LD_VAR 0 3
27010: PPUSH
27011: LD_INT 21
27013: PUSH
27014: LD_INT 3
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: PPUSH
27021: CALL 10967 0 2
27025: PUSH
27026: LD_INT 1
27028: EQUAL
27029: IFFALSE 27120
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27031: LD_ADDR_VAR 0 4
27035: PUSH
27036: LD_VAR 0 3
27040: PPUSH
27041: LD_INT 21
27043: PUSH
27044: LD_INT 1
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PPUSH
27051: CALL 10967 0 2
27055: PUSH
27056: LD_VAR 0 3
27060: PPUSH
27061: LD_INT 2
27063: PPUSH
27064: EMPTY
27065: PPUSH
27066: CALL 11050 0 3
27070: DIFF
27071: PUSH
27072: FOR_IN
27073: IFFALSE 27118
// if not HasTask ( i ) then
27075: LD_VAR 0 4
27079: PPUSH
27080: CALL_OW 314
27084: NOT
27085: IFFALSE 27116
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27087: LD_VAR 0 4
27091: PPUSH
27092: LD_VAR 0 1
27096: PPUSH
27097: CALL_OW 250
27101: PPUSH
27102: LD_VAR 0 1
27106: PPUSH
27107: CALL_OW 251
27111: PPUSH
27112: CALL_OW 111
27116: GO 27072
27118: POP
27119: POP
// end ;
27120: PPOPN 4
27122: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27123: LD_EXP 34
27127: PUSH
27128: LD_VAR 0 1
27132: PPUSH
27133: CALL_OW 255
27137: ARRAY
27138: IFFALSE 27470
// begin MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27140: LD_ADDR_EXP 41
27144: PUSH
27145: LD_EXP 41
27149: PPUSH
27150: LD_VAR 0 1
27154: PPUSH
27155: CALL_OW 255
27159: PPUSH
27160: LD_VAR 0 1
27164: PPUSH
27165: CALL_OW 266
27169: PPUSH
27170: LD_VAR 0 1
27174: PPUSH
27175: CALL_OW 250
27179: PUSH
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 251
27189: PUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL_OW 254
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: LIST
27204: PPUSH
27205: CALL 39804 0 4
27209: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27210: LD_VAR 0 1
27214: PPUSH
27215: CALL_OW 266
27219: PUSH
27220: LD_INT 6
27222: EQUAL
27223: IFFALSE 27257
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27225: LD_ADDR_EXP 35
27229: PUSH
27230: LD_EXP 35
27234: PPUSH
27235: LD_VAR 0 1
27239: PPUSH
27240: CALL_OW 255
27244: PPUSH
27245: LD_VAR 0 1
27249: PPUSH
27250: EMPTY
27251: PPUSH
27252: CALL 39713 0 4
27256: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27257: LD_VAR 0 1
27261: PPUSH
27262: CALL_OW 266
27266: PUSH
27267: LD_INT 0
27269: EQUAL
27270: IFFALSE 27380
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27272: LD_ADDR_EXP 43
27276: PUSH
27277: LD_EXP 43
27281: PPUSH
27282: LD_VAR 0 1
27286: PPUSH
27287: CALL_OW 255
27291: PPUSH
27292: LD_INT 0
27294: PPUSH
27295: EMPTY
27296: PPUSH
27297: CALL 39713 0 4
27301: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27302: LD_VAR 0 1
27306: PPUSH
27307: CALL_OW 274
27311: PPUSH
27312: LD_INT 1
27314: PPUSH
27315: LD_EXP 67
27319: PUSH
27320: LD_INT 1
27322: ARRAY
27323: PPUSH
27324: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
27328: LD_VAR 0 1
27332: PPUSH
27333: CALL_OW 274
27337: PPUSH
27338: LD_INT 2
27340: PPUSH
27341: LD_EXP 67
27345: PUSH
27346: LD_INT 2
27348: ARRAY
27349: PPUSH
27350: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
27354: LD_VAR 0 1
27358: PPUSH
27359: CALL_OW 274
27363: PPUSH
27364: LD_INT 3
27366: PPUSH
27367: LD_EXP 67
27371: PUSH
27372: LD_INT 3
27374: ARRAY
27375: PPUSH
27376: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
27380: LD_VAR 0 1
27384: PPUSH
27385: CALL_OW 266
27389: PUSH
27390: LD_INT 2
27392: EQUAL
27393: IFFALSE 27425
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
27395: LD_ADDR_EXP 43
27399: PUSH
27400: LD_EXP 43
27404: PPUSH
27405: LD_VAR 0 1
27409: PPUSH
27410: CALL_OW 255
27414: PPUSH
27415: LD_INT 2
27417: PPUSH
27418: EMPTY
27419: PPUSH
27420: CALL 39713 0 4
27424: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
27425: LD_VAR 0 1
27429: PPUSH
27430: CALL_OW 266
27434: PUSH
27435: LD_INT 4
27437: EQUAL
27438: IFFALSE 27470
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
27440: LD_ADDR_EXP 43
27444: PUSH
27445: LD_EXP 43
27449: PPUSH
27450: LD_VAR 0 1
27454: PPUSH
27455: CALL_OW 255
27459: PPUSH
27460: LD_INT 4
27462: PPUSH
27463: EMPTY
27464: PPUSH
27465: CALL 39713 0 4
27469: ST_TO_ADDR
// end ;
27470: PPOPN 1
27472: END
// on ResearchComplete ( tech , lab ) do var i ;
27473: LD_INT 0
27475: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
27476: LD_EXP 34
27480: PUSH
27481: LD_VAR 0 2
27485: PPUSH
27486: CALL_OW 255
27490: ARRAY
27491: IFFALSE 27738
// begin for i = 1 to MREG_ToRes do
27493: LD_ADDR_VAR 0 3
27497: PUSH
27498: DOUBLE
27499: LD_INT 1
27501: DEC
27502: ST_TO_ADDR
27503: LD_EXP 45
27507: PUSH
27508: FOR_TO
27509: IFFALSE 27596
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
27511: LD_EXP 45
27515: PUSH
27516: LD_VAR 0 3
27520: ARRAY
27521: PUSH
27522: LD_INT 1
27524: ARRAY
27525: PUSH
27526: LD_VAR 0 2
27530: PPUSH
27531: CALL_OW 255
27535: EQUAL
27536: PUSH
27537: LD_EXP 45
27541: PUSH
27542: LD_VAR 0 3
27546: ARRAY
27547: PUSH
27548: LD_INT 2
27550: ARRAY
27551: PUSH
27552: LD_VAR 0 1
27556: EQUAL
27557: AND
27558: IFFALSE 27594
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
27560: LD_ADDR_EXP 45
27564: PUSH
27565: LD_EXP 45
27569: PPUSH
27570: LD_VAR 0 2
27574: PPUSH
27575: CALL_OW 255
27579: PPUSH
27580: LD_VAR 0 1
27584: PPUSH
27585: EMPTY
27586: PPUSH
27587: CALL 39804 0 4
27591: ST_TO_ADDR
// break ;
27592: GO 27596
// end ;
27594: GO 27508
27596: POP
27597: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
27598: LD_VAR 0 1
27602: PUSH
27603: LD_INT 2
27605: PUSH
27606: LD_INT 11
27608: PUSH
27609: LD_INT 4
27611: PUSH
27612: LD_INT 3
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: LIST
27619: LIST
27620: IN
27621: IFFALSE 27738
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
27623: LD_ADDR_VAR 0 3
27627: PUSH
27628: LD_VAR 0 2
27632: PPUSH
27633: CALL_OW 255
27637: PPUSH
27638: LD_INT 16
27640: PPUSH
27641: LD_INT 25
27643: PUSH
27644: LD_INT 4
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PPUSH
27651: CALL 11670 0 3
27655: ST_TO_ADDR
// if i then
27656: LD_VAR 0 3
27660: IFFALSE 27678
// SetTag ( i [ 1 ] , 0 ) ;
27662: LD_VAR 0 3
27666: PUSH
27667: LD_INT 1
27669: ARRAY
27670: PPUSH
27671: LD_INT 0
27673: PPUSH
27674: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
27678: LD_ADDR_VAR 0 3
27682: PUSH
27683: LD_VAR 0 2
27687: PPUSH
27688: CALL_OW 255
27692: PPUSH
27693: LD_INT 171
27695: PPUSH
27696: EMPTY
27697: PPUSH
27698: CALL 11670 0 3
27702: ST_TO_ADDR
// if i then
27703: LD_VAR 0 3
27707: IFFALSE 27738
// begin SetTag ( i [ 1 ] , 0 ) ;
27709: LD_VAR 0 3
27713: PUSH
27714: LD_INT 1
27716: ARRAY
27717: PPUSH
27718: LD_INT 0
27720: PPUSH
27721: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
27725: LD_VAR 0 3
27729: PUSH
27730: LD_INT 1
27732: ARRAY
27733: PPUSH
27734: CALL_OW 122
// end ; end ; end ;
27738: PPOPN 3
27740: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
27741: LD_INT 0
27743: PPUSH
27744: PPUSH
27745: PPUSH
27746: PPUSH
27747: PPUSH
27748: PPUSH
27749: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27750: LD_EXP 34
27754: PUSH
27755: LD_VAR 0 2
27759: PPUSH
27760: CALL_OW 255
27764: ARRAY
27765: IFFALSE 28425
// begin side := GetSide ( veh ) ;
27767: LD_ADDR_VAR 0 4
27771: PUSH
27772: LD_VAR 0 1
27776: PPUSH
27777: CALL_OW 255
27781: ST_TO_ADDR
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
27782: LD_VAR 0 1
27786: PPUSH
27787: CALL_OW 264
27791: PUSH
27792: LD_INT 13
27794: PUSH
27795: LD_INT 12
27797: PUSH
27798: LD_INT 14
27800: PUSH
27801: LD_INT 51
27803: PUSH
27804: LD_INT 53
27806: PUSH
27807: LD_INT 52
27809: PUSH
27810: LD_INT 32
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: IN
27822: NOT
27823: IFFALSE 27865
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
27825: LD_ADDR_EXP 54
27829: PUSH
27830: LD_EXP 54
27834: PPUSH
27835: LD_VAR 0 4
27839: PPUSH
27840: LD_EXP 54
27844: PUSH
27845: LD_VAR 0 4
27849: ARRAY
27850: PUSH
27851: LD_INT 1
27853: PLUS
27854: PPUSH
27855: LD_VAR 0 1
27859: PPUSH
27860: CALL 29864 0 4
27864: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
27865: LD_VAR 0 1
27869: PPUSH
27870: CALL_OW 264
27874: PUSH
27875: LD_INT 31
27877: EQUAL
27878: IFFALSE 27897
// SetTag ( GetDriver ( veh ) , 9 ) ;
27880: LD_VAR 0 1
27884: PPUSH
27885: CALL 30475 0 1
27889: PPUSH
27890: LD_INT 9
27892: PPUSH
27893: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
27897: LD_VAR 0 1
27901: PPUSH
27902: CALL_OW 264
27906: PUSH
27907: LD_INT 14
27909: PUSH
27910: LD_INT 53
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: IN
27917: IFFALSE 27954
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
27919: LD_ADDR_EXP 37
27923: PUSH
27924: LD_EXP 37
27928: PPUSH
27929: LD_VAR 0 1
27933: PPUSH
27934: CALL_OW 255
27938: PPUSH
27939: LD_INT 2
27941: PPUSH
27942: LD_VAR 0 1
27946: PPUSH
27947: CALL 29864 0 4
27951: ST_TO_ADDR
// exit ;
27952: GO 28425
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
27954: LD_VAR 0 1
27958: PPUSH
27959: CALL_OW 265
27963: PUSH
27964: LD_EXP 61
27968: PUSH
27969: LD_VAR 0 4
27973: ARRAY
27974: PUSH
27975: LD_INT 1
27977: ARRAY
27978: IN
27979: PUSH
27980: LD_VAR 0 1
27984: PPUSH
27985: CALL_OW 262
27989: PUSH
27990: LD_EXP 61
27994: PUSH
27995: LD_VAR 0 4
27999: ARRAY
28000: PUSH
28001: LD_INT 1
28003: ARRAY
28004: IN
28005: AND
28006: PUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 263
28016: PUSH
28017: LD_EXP 61
28021: PUSH
28022: LD_VAR 0 4
28026: ARRAY
28027: PUSH
28028: LD_INT 1
28030: ARRAY
28031: IN
28032: AND
28033: PUSH
28034: LD_VAR 0 1
28038: PPUSH
28039: CALL_OW 264
28043: PUSH
28044: LD_EXP 61
28048: PUSH
28049: LD_VAR 0 4
28053: ARRAY
28054: PUSH
28055: LD_INT 1
28057: ARRAY
28058: IN
28059: AND
28060: IFFALSE 28104
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28062: LD_ADDR_EXP 62
28066: PUSH
28067: LD_EXP 62
28071: PPUSH
28072: LD_VAR 0 4
28076: PPUSH
28077: LD_EXP 62
28081: PUSH
28082: LD_VAR 0 4
28086: ARRAY
28087: PUSH
28088: LD_INT 1
28090: PLUS
28091: PPUSH
28092: LD_VAR 0 1
28096: PPUSH
28097: CALL 29864 0 4
28101: ST_TO_ADDR
// exit ;
28102: GO 28425
// end ; c1 := GetChassis ( veh ) ;
28104: LD_ADDR_VAR 0 6
28108: PUSH
28109: LD_VAR 0 1
28113: PPUSH
28114: CALL_OW 265
28118: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28119: LD_ADDR_VAR 0 7
28123: PUSH
28124: LD_VAR 0 1
28128: PPUSH
28129: CALL_OW 262
28133: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28134: LD_ADDR_VAR 0 8
28138: PUSH
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 263
28148: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28149: LD_ADDR_VAR 0 9
28153: PUSH
28154: LD_VAR 0 1
28158: PPUSH
28159: CALL_OW 264
28163: ST_TO_ADDR
// if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28164: LD_VAR 0 6
28168: PUSH
28169: LD_EXP 64
28173: PUSH
28174: LD_VAR 0 4
28178: ARRAY
28179: PUSH
28180: LD_INT 1
28182: ARRAY
28183: EQUAL
28184: PUSH
28185: LD_VAR 0 7
28189: PUSH
28190: LD_EXP 64
28194: PUSH
28195: LD_VAR 0 4
28199: ARRAY
28200: PUSH
28201: LD_INT 2
28203: ARRAY
28204: EQUAL
28205: AND
28206: PUSH
28207: LD_VAR 0 8
28211: PUSH
28212: LD_EXP 64
28216: PUSH
28217: LD_VAR 0 4
28221: ARRAY
28222: PUSH
28223: LD_INT 3
28225: ARRAY
28226: EQUAL
28227: AND
28228: PUSH
28229: LD_VAR 0 9
28233: PUSH
28234: LD_EXP 64
28238: PUSH
28239: LD_VAR 0 4
28243: ARRAY
28244: PUSH
28245: LD_INT 4
28247: ARRAY
28248: EQUAL
28249: AND
28250: IFFALSE 28406
// begin tmp := MREG_ToAttack [ side ] ;
28252: LD_ADDR_VAR 0 5
28256: PUSH
28257: LD_EXP 64
28261: PUSH
28262: LD_VAR 0 4
28266: ARRAY
28267: ST_TO_ADDR
// for i = 1 to 4 do
28268: LD_ADDR_VAR 0 3
28272: PUSH
28273: DOUBLE
28274: LD_INT 1
28276: DEC
28277: ST_TO_ADDR
28278: LD_INT 4
28280: PUSH
28281: FOR_TO
28282: IFFALSE 28304
// tmp := Delete ( tmp , 1 ) ;
28284: LD_ADDR_VAR 0 5
28288: PUSH
28289: LD_VAR 0 5
28293: PPUSH
28294: LD_INT 1
28296: PPUSH
28297: CALL_OW 3
28301: ST_TO_ADDR
28302: GO 28281
28304: POP
28305: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
28306: LD_ADDR_EXP 64
28310: PUSH
28311: LD_EXP 64
28315: PPUSH
28316: LD_VAR 0 4
28320: PPUSH
28321: LD_VAR 0 5
28325: PPUSH
28326: CALL_OW 1
28330: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
28331: LD_ADDR_EXP 66
28335: PUSH
28336: LD_EXP 66
28340: PPUSH
28341: LD_VAR 0 4
28345: PPUSH
28346: LD_EXP 66
28350: PUSH
28351: LD_VAR 0 4
28355: ARRAY
28356: PUSH
28357: LD_INT 1
28359: PLUS
28360: PPUSH
28361: LD_VAR 0 1
28365: PPUSH
28366: CALL 29864 0 4
28370: ST_TO_ADDR
// if tmp = 0 then
28371: LD_VAR 0 5
28375: PUSH
28376: LD_INT 0
28378: EQUAL
28379: IFFALSE 28404
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
28381: LD_ADDR_EXP 64
28385: PUSH
28386: LD_EXP 64
28390: PPUSH
28391: LD_VAR 0 4
28395: PPUSH
28396: LD_INT 0
28398: PPUSH
28399: CALL_OW 1
28403: ST_TO_ADDR
// exit ;
28404: GO 28425
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
28406: LD_VAR 0 1
28410: PPUSH
28411: CALL_OW 255
28415: PPUSH
28416: LD_VAR 0 1
28420: PPUSH
28421: CALL 25124 0 2
// end ;
28425: PPOPN 9
28427: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
28428: LD_EXP 34
28432: PUSH
28433: LD_VAR 0 2
28437: PPUSH
28438: CALL_OW 255
28442: ARRAY
28443: IFFALSE 28633
// begin if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
28445: LD_INT 11
28447: PPUSH
28448: LD_VAR 0 2
28452: PPUSH
28453: CALL_OW 255
28457: PPUSH
28458: CALL_OW 321
28462: PUSH
28463: LD_INT 2
28465: EQUAL
28466: NOT
28467: PUSH
28468: LD_INT 2
28470: PPUSH
28471: LD_VAR 0 2
28475: PPUSH
28476: CALL_OW 255
28480: PPUSH
28481: CALL_OW 321
28485: PUSH
28486: LD_INT 2
28488: EQUAL
28489: NOT
28490: OR
28491: PUSH
28492: LD_VAR 0 2
28496: PPUSH
28497: CALL_OW 255
28501: PPUSH
28502: LD_INT 171
28504: PPUSH
28505: EMPTY
28506: PPUSH
28507: CALL 11670 0 3
28511: PUSH
28512: LD_INT 0
28514: EQUAL
28515: AND
28516: IFFALSE 28530
// begin SetTag ( ape , 171 ) ;
28518: LD_VAR 0 1
28522: PPUSH
28523: LD_INT 171
28525: PPUSH
28526: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
28530: LD_VAR 0 2
28534: PPUSH
28535: CALL_OW 255
28539: PPUSH
28540: LD_INT 30
28542: PUSH
28543: LD_INT 1
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PPUSH
28550: CALL 10967 0 2
28554: IFFALSE 28633
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
28556: LD_VAR 0 1
28560: PPUSH
28561: LD_VAR 0 2
28565: PPUSH
28566: CALL_OW 255
28570: PPUSH
28571: LD_INT 30
28573: PUSH
28574: LD_INT 1
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PPUSH
28581: CALL 10967 0 2
28585: PUSH
28586: LD_INT 1
28588: ARRAY
28589: PPUSH
28590: CALL_OW 250
28594: PPUSH
28595: LD_VAR 0 2
28599: PPUSH
28600: CALL_OW 255
28604: PPUSH
28605: LD_INT 30
28607: PUSH
28608: LD_INT 1
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PPUSH
28615: CALL 10967 0 2
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 251
28628: PPUSH
28629: CALL_OW 111
// end ;
28633: PPOPN 2
28635: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
28636: LD_EXP 34
28640: PUSH
28641: LD_VAR 0 1
28645: PPUSH
28646: CALL_OW 255
28650: ARRAY
28651: IFFALSE 28929
// begin if un in MCF_Ape ( GetSide ( un ) ) then
28653: LD_VAR 0 2
28657: PUSH
28658: LD_VAR 0 2
28662: PPUSH
28663: CALL_OW 255
28667: PPUSH
28668: CALL 11380 0 1
28672: IN
28673: IFFALSE 28814
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 266
28684: PUSH
28685: LD_INT 0
28687: PUSH
28688: LD_INT 1
28690: PUSH
28691: EMPTY
28692: LIST
28693: LIST
28694: IN
28695: IFFALSE 28725
// begin Wait ( 0 0$0.3 ) ;
28697: LD_INT 10
28699: PPUSH
28700: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
28704: LD_VAR 0 2
28708: PPUSH
28709: LD_INT 16
28711: PPUSH
28712: CALL_OW 336
// ComExitBuilding ( un ) ;
28716: LD_VAR 0 2
28720: PPUSH
28721: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
28725: LD_VAR 0 1
28729: PPUSH
28730: CALL_OW 266
28734: PUSH
28735: LD_INT 4
28737: PUSH
28738: LD_INT 5
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: IN
28745: IFFALSE 28814
// begin Wait ( 0 0$0.3 ) ;
28747: LD_INT 10
28749: PPUSH
28750: CALL_OW 67
// if GetTag ( un ) = 0 then
28754: LD_VAR 0 2
28758: PPUSH
28759: CALL_OW 110
28763: PUSH
28764: LD_INT 0
28766: EQUAL
28767: IFFALSE 28783
// SetClass ( un , class_apeman_soldier ) else
28769: LD_VAR 0 2
28773: PPUSH
28774: LD_INT 15
28776: PPUSH
28777: CALL_OW 336
28781: GO 28814
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
28783: LD_INT 3
28785: PPUSH
28786: LD_VAR 0 2
28790: PPUSH
28791: CALL_OW 255
28795: PPUSH
28796: CALL_OW 321
28800: IFFALSE 28814
// SetClass ( un , class_apeman_kamikaze ) ;
28802: LD_VAR 0 2
28806: PPUSH
28807: LD_INT 17
28809: PPUSH
28810: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
28814: LD_VAR 0 1
28818: PPUSH
28819: CALL_OW 266
28823: PUSH
28824: LD_INT 32
28826: EQUAL
28827: IFFALSE 28929
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
28829: LD_ADDR_EXP 63
28833: PUSH
28834: LD_EXP 63
28838: PPUSH
28839: LD_VAR 0 1
28843: PPUSH
28844: CALL_OW 255
28848: PPUSH
28849: LD_EXP 63
28853: PUSH
28854: LD_VAR 0 1
28858: PPUSH
28859: CALL_OW 255
28863: ARRAY
28864: PUSH
28865: LD_INT 1
28867: PLUS
28868: PPUSH
28869: LD_VAR 0 1
28873: PPUSH
28874: CALL 29864 0 4
28878: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
28879: LD_ADDR_EXP 63
28883: PUSH
28884: LD_EXP 63
28888: PPUSH
28889: LD_VAR 0 1
28893: PPUSH
28894: CALL_OW 255
28898: PPUSH
28899: LD_EXP 63
28903: PUSH
28904: LD_VAR 0 1
28908: PPUSH
28909: CALL_OW 255
28913: ARRAY
28914: PUSH
28915: LD_INT 1
28917: PLUS
28918: PPUSH
28919: LD_VAR 0 2
28923: PPUSH
28924: CALL 29864 0 4
28928: ST_TO_ADDR
// end ; end ;
28929: PPOPN 2
28931: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 and not alfa_north_triggered then
28932: LD_VAR 0 1
28936: PPUSH
28937: CALL_OW 255
28941: PUSH
28942: LD_INT 1
28944: EQUAL
28945: PUSH
28946: LD_EXP 13
28950: NOT
28951: AND
28952: IFFALSE 29008
// begin alfa_north_triggered := true ;
28954: LD_ADDR_EXP 13
28958: PUSH
28959: LD_INT 1
28961: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
28962: LD_EXP 2
28966: PPUSH
28967: LD_STRING DS4
28969: PPUSH
28970: CALL_OW 94
// Wait ( 1 1$25 ) ;
28974: LD_INT 2975
28976: PPUSH
28977: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
28981: LD_INT 20
28983: PPUSH
28984: LD_INT 5
28986: PUSH
28987: LD_INT 6
28989: PUSH
28990: LD_INT 7
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: LIST
28997: PUSH
28998: LD_OWVAR 67
29002: ARRAY
29003: PPUSH
29004: CALL 6895 0 2
// end ; if GetSide ( un ) = 4 and not alfa_south_triggered then
29008: LD_VAR 0 1
29012: PPUSH
29013: CALL_OW 255
29017: PUSH
29018: LD_INT 4
29020: EQUAL
29021: PUSH
29022: LD_EXP 14
29026: NOT
29027: AND
29028: IFFALSE 29084
// begin alfa_south_triggered := true ;
29030: LD_ADDR_EXP 14
29034: PUSH
29035: LD_INT 1
29037: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29038: LD_EXP 1
29042: PPUSH
29043: LD_STRING DJ3
29045: PPUSH
29046: CALL_OW 94
// Wait ( 0 0$45 ) ;
29050: LD_INT 1575
29052: PPUSH
29053: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29057: LD_INT 20
29059: PPUSH
29060: LD_INT 5
29062: PUSH
29063: LD_INT 6
29065: PUSH
29066: LD_INT 7
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: LIST
29073: PUSH
29074: LD_OWVAR 67
29078: ARRAY
29079: PPUSH
29080: CALL 6895 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
29084: LD_VAR 0 1
29088: PPUSH
29089: CALL_OW 266
29093: PUSH
29094: LD_INT 1
29096: EQUAL
29097: PUSH
29098: LD_VAR 0 1
29102: PPUSH
29103: CALL_OW 255
29107: PUSH
29108: LD_INT 1
29110: PUSH
29111: LD_INT 4
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: IN
29118: AND
29119: IFFALSE 29128
// RaiseSailEvent ( 104 ) ;
29121: LD_INT 104
29123: PPUSH
29124: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
29128: LD_EXP 34
29132: PUSH
29133: LD_VAR 0 1
29137: PPUSH
29138: CALL_OW 255
29142: ARRAY
29143: IFFALSE 29483
// begin if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
29145: LD_VAR 0 1
29149: PUSH
29150: LD_VAR 0 1
29154: PPUSH
29155: CALL_OW 255
29159: PPUSH
29160: LD_INT 21
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PPUSH
29170: CALL 10967 0 2
29174: IN
29175: IFFALSE 29331
// begin if MCF_HasClass ( un ) then
29177: LD_VAR 0 1
29181: PPUSH
29182: CALL 13673 0 1
29186: IFFALSE 29331
// case MCF_HasClass ( un ) of 1 :
29188: LD_VAR 0 1
29192: PPUSH
29193: CALL 13673 0 1
29197: PUSH
29198: LD_INT 1
29200: DOUBLE
29201: EQUAL
29202: IFTRUE 29206
29204: GO 29231
29206: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
29207: LD_VAR 0 1
29211: PPUSH
29212: CALL_OW 255
29216: PPUSH
29217: LD_STRING ToArm
29219: PPUSH
29220: LD_VAR 0 1
29224: PPUSH
29225: CALL 13846 0 3
29229: GO 29331
29231: LD_INT 2
29233: DOUBLE
29234: EQUAL
29235: IFTRUE 29239
29237: GO 29264
29239: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
29240: LD_VAR 0 1
29244: PPUSH
29245: CALL_OW 255
29249: PPUSH
29250: LD_STRING ToDep
29252: PPUSH
29253: LD_VAR 0 1
29257: PPUSH
29258: CALL 13846 0 3
29262: GO 29331
29264: LD_INT 3
29266: DOUBLE
29267: EQUAL
29268: IFTRUE 29272
29270: GO 29297
29272: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
29273: LD_VAR 0 1
29277: PPUSH
29278: CALL_OW 255
29282: PPUSH
29283: LD_STRING ToFac
29285: PPUSH
29286: LD_VAR 0 1
29290: PPUSH
29291: CALL 13846 0 3
29295: GO 29331
29297: LD_INT 4
29299: DOUBLE
29300: EQUAL
29301: IFTRUE 29305
29303: GO 29330
29305: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
29306: LD_VAR 0 1
29310: PPUSH
29311: CALL_OW 255
29315: PPUSH
29316: LD_STRING ToLab
29318: PPUSH
29319: LD_VAR 0 1
29323: PPUSH
29324: CALL 13846 0 3
29328: GO 29331
29330: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
29331: LD_VAR 0 1
29335: PUSH
29336: LD_EXP 62
29340: PUSH
29341: LD_VAR 0 1
29345: PPUSH
29346: CALL_OW 255
29350: ARRAY
29351: IN
29352: IFFALSE 29437
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
29354: LD_ADDR_EXP 62
29358: PUSH
29359: LD_EXP 62
29363: PPUSH
29364: LD_VAR 0 1
29368: PPUSH
29369: LD_INT 0
29371: PPUSH
29372: CALL 29940 0 3
29376: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
29377: LD_VAR 0 1
29381: PPUSH
29382: CALL_OW 255
29386: PPUSH
29387: LD_VAR 0 1
29391: PPUSH
29392: CALL_OW 265
29396: PUSH
29397: LD_VAR 0 1
29401: PPUSH
29402: CALL_OW 262
29406: PUSH
29407: LD_VAR 0 1
29411: PPUSH
29412: CALL_OW 263
29416: PUSH
29417: LD_VAR 0 1
29421: PPUSH
29422: CALL_OW 264
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: LIST
29431: LIST
29432: PPUSH
29433: CALL 20486 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
29437: LD_VAR 0 1
29441: PUSH
29442: LD_EXP 66
29446: PUSH
29447: LD_VAR 0 1
29451: PPUSH
29452: CALL_OW 255
29456: ARRAY
29457: IN
29458: IFFALSE 29483
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
29460: LD_ADDR_EXP 66
29464: PUSH
29465: LD_EXP 66
29469: PPUSH
29470: LD_VAR 0 1
29474: PPUSH
29475: LD_INT 0
29477: PPUSH
29478: CALL 29940 0 3
29482: ST_TO_ADDR
// end ; end ;
29483: PPOPN 1
29485: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
29486: LD_EXP 34
29490: PUSH
29491: LD_VAR 0 2
29495: PPUSH
29496: CALL_OW 255
29500: ARRAY
29501: IFFALSE 29673
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
29503: LD_VAR 0 2
29507: PUSH
29508: LD_EXP 63
29512: PUSH
29513: LD_VAR 0 2
29517: PPUSH
29518: CALL_OW 255
29522: ARRAY
29523: IN
29524: PUSH
29525: LD_VAR 0 1
29529: PPUSH
29530: CALL_OW 266
29534: PUSH
29535: LD_INT 32
29537: PUSH
29538: LD_INT 31
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: IN
29545: AND
29546: IFFALSE 29646
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
29548: LD_ADDR_EXP 63
29552: PUSH
29553: LD_EXP 63
29557: PPUSH
29558: LD_VAR 0 1
29562: PPUSH
29563: LD_INT 0
29565: PPUSH
29566: CALL 29940 0 3
29570: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
29571: LD_ADDR_EXP 63
29575: PUSH
29576: LD_EXP 63
29580: PPUSH
29581: LD_VAR 0 2
29585: PPUSH
29586: LD_INT 0
29588: PPUSH
29589: CALL 29940 0 3
29593: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
29594: LD_EXP 63
29598: PUSH
29599: LD_VAR 0 2
29603: PPUSH
29604: CALL_OW 255
29608: ARRAY
29609: PUSH
29610: LD_STRING 
29612: EQUAL
29613: IFFALSE 29646
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
29615: LD_ADDR_EXP 63
29619: PUSH
29620: LD_EXP 63
29624: PPUSH
29625: LD_VAR 0 2
29629: PPUSH
29630: CALL_OW 255
29634: PPUSH
29635: LD_INT 1
29637: PPUSH
29638: LD_INT 0
29640: PPUSH
29641: CALL 29864 0 4
29645: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
29646: LD_VAR 0 1
29650: PPUSH
29651: CALL_OW 266
29655: PUSH
29656: LD_INT 36
29658: IN
29659: IFFALSE 29673
// SetTag ( un , 0 ) ;
29661: LD_VAR 0 2
29665: PPUSH
29666: LD_INT 0
29668: PPUSH
29669: CALL_OW 109
// end ;
29673: PPOPN 2
29675: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
29676: LD_EXP 34
29680: PUSH
29681: LD_VAR 0 1
29685: PPUSH
29686: CALL_OW 255
29690: ARRAY
29691: IFFALSE 29717
// begin if GetControl ( un ) = control_remote then
29693: LD_VAR 0 1
29697: PPUSH
29698: CALL_OW 263
29702: PUSH
29703: LD_INT 2
29705: EQUAL
29706: IFFALSE 29717
// ComUnlink ( un ) ;
29708: LD_VAR 0 1
29712: PPUSH
29713: CALL_OW 136
// end ;
29717: PPOPN 1
29719: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
29720: LD_EXP 34
29724: PUSH
29725: LD_VAR 0 1
29729: PPUSH
29730: CALL_OW 255
29734: ARRAY
29735: IFFALSE 29764
// begin if GetWeapon ( vehicle ) in ar_control_tower then
29737: LD_VAR 0 2
29741: PPUSH
29742: CALL_OW 264
29746: PUSH
29747: LD_INT 31
29749: IN
29750: IFFALSE 29764
// SetTag ( driver , 0 ) ;
29752: LD_VAR 0 1
29756: PPUSH
29757: LD_INT 0
29759: PPUSH
29760: CALL_OW 109
// end ;
29764: PPOPN 4
29766: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
29767: LD_INT 0
29769: PPUSH
29770: PPUSH
29771: PPUSH
// begin weapon := GetBWeapon ( building ) ;
29772: LD_ADDR_VAR 0 3
29776: PUSH
29777: LD_VAR 0 1
29781: PPUSH
29782: CALL_OW 269
29786: ST_TO_ADDR
// x := GetX ( building ) ;
29787: LD_ADDR_VAR 0 4
29791: PUSH
29792: LD_VAR 0 1
29796: PPUSH
29797: CALL_OW 250
29801: ST_TO_ADDR
// y := GetY ( building ) ;
29802: LD_ADDR_VAR 0 5
29806: PUSH
29807: LD_VAR 0 1
29811: PPUSH
29812: CALL_OW 251
29816: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
29817: LD_ADDR_EXP 38
29821: PUSH
29822: LD_EXP 38
29826: PPUSH
29827: LD_VAR 0 1
29831: PPUSH
29832: CALL_OW 255
29836: PPUSH
29837: LD_VAR 0 3
29841: PPUSH
29842: LD_VAR 0 4
29846: PUSH
29847: LD_VAR 0 5
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PPUSH
29856: CALL 39804 0 4
29860: ST_TO_ADDR
// end ; end_of_file
29861: PPOPN 5
29863: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
29864: LD_INT 0
29866: PPUSH
29867: PPUSH
29868: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
29869: LD_ADDR_VAR 0 7
29873: PUSH
29874: LD_VAR 0 1
29878: PUSH
29879: LD_VAR 0 2
29883: ARRAY
29884: PPUSH
29885: LD_VAR 0 3
29889: PPUSH
29890: LD_VAR 0 4
29894: PPUSH
29895: CALL_OW 1
29899: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
29900: LD_ADDR_VAR 0 1
29904: PUSH
29905: LD_VAR 0 1
29909: PPUSH
29910: LD_VAR 0 2
29914: PPUSH
29915: LD_VAR 0 7
29919: PPUSH
29920: CALL_OW 1
29924: ST_TO_ADDR
// result := tab ;
29925: LD_ADDR_VAR 0 5
29929: PUSH
29930: LD_VAR 0 1
29934: ST_TO_ADDR
// end ;
29935: LD_VAR 0 5
29939: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
29940: LD_INT 0
29942: PPUSH
29943: PPUSH
29944: PPUSH
29945: PPUSH
// i := 1 ;
29946: LD_ADDR_VAR 0 5
29950: PUSH
29951: LD_INT 1
29953: ST_TO_ADDR
// while ( i <= tab ) do
29954: LD_VAR 0 5
29958: PUSH
29959: LD_VAR 0 1
29963: LESSEQUAL
29964: IFFALSE 30339
// begin if not tab [ i ] then
29966: LD_VAR 0 1
29970: PUSH
29971: LD_VAR 0 5
29975: ARRAY
29976: NOT
29977: IFFALSE 29981
// break ;
29979: GO 30339
// if value in tab then
29981: LD_VAR 0 2
29985: PUSH
29986: LD_VAR 0 1
29990: IN
29991: IFFALSE 30104
// begin if not mode then
29993: LD_VAR 0 3
29997: NOT
29998: IFFALSE 30018
// tab := tab diff value else
30000: LD_ADDR_VAR 0 1
30004: PUSH
30005: LD_VAR 0 1
30009: PUSH
30010: LD_VAR 0 2
30014: DIFF
30015: ST_TO_ADDR
30016: GO 30080
// for j = 1 to tab do
30018: LD_ADDR_VAR 0 6
30022: PUSH
30023: DOUBLE
30024: LD_INT 1
30026: DEC
30027: ST_TO_ADDR
30028: LD_VAR 0 1
30032: PUSH
30033: FOR_TO
30034: IFFALSE 30078
// if tab [ j ] = value then
30036: LD_VAR 0 1
30040: PUSH
30041: LD_VAR 0 6
30045: ARRAY
30046: PUSH
30047: LD_VAR 0 2
30051: EQUAL
30052: IFFALSE 30076
// begin tab := Delete ( tab , j ) ;
30054: LD_ADDR_VAR 0 1
30058: PUSH
30059: LD_VAR 0 1
30063: PPUSH
30064: LD_VAR 0 6
30068: PPUSH
30069: CALL_OW 3
30073: ST_TO_ADDR
// break ;
30074: GO 30078
// end ;
30076: GO 30033
30078: POP
30079: POP
// i := i - 1 ;
30080: LD_ADDR_VAR 0 5
30084: PUSH
30085: LD_VAR 0 5
30089: PUSH
30090: LD_INT 1
30092: MINUS
30093: ST_TO_ADDR
// if mode then
30094: LD_VAR 0 3
30098: IFFALSE 30102
// break ;
30100: GO 30339
// end else
30102: GO 30323
// if tab [ i ] and value in tab [ i ] then
30104: LD_VAR 0 1
30108: PUSH
30109: LD_VAR 0 5
30113: ARRAY
30114: PUSH
30115: LD_VAR 0 2
30119: PUSH
30120: LD_VAR 0 1
30124: PUSH
30125: LD_VAR 0 5
30129: ARRAY
30130: IN
30131: AND
30132: IFFALSE 30323
// begin if not mode then
30134: LD_VAR 0 3
30138: NOT
30139: IFFALSE 30165
// tmp := tab [ i ] diff value else
30141: LD_ADDR_VAR 0 7
30145: PUSH
30146: LD_VAR 0 1
30150: PUSH
30151: LD_VAR 0 5
30155: ARRAY
30156: PUSH
30157: LD_VAR 0 2
30161: DIFF
30162: ST_TO_ADDR
30163: GO 30245
// for j = 1 to tab [ i ] do
30165: LD_ADDR_VAR 0 6
30169: PUSH
30170: DOUBLE
30171: LD_INT 1
30173: DEC
30174: ST_TO_ADDR
30175: LD_VAR 0 1
30179: PUSH
30180: LD_VAR 0 5
30184: ARRAY
30185: PUSH
30186: FOR_TO
30187: IFFALSE 30243
// if value = tab [ i ] [ j ] then
30189: LD_VAR 0 2
30193: PUSH
30194: LD_VAR 0 1
30198: PUSH
30199: LD_VAR 0 5
30203: ARRAY
30204: PUSH
30205: LD_VAR 0 6
30209: ARRAY
30210: EQUAL
30211: IFFALSE 30241
// begin tmp := Delete ( tab [ i ] , j ) ;
30213: LD_ADDR_VAR 0 7
30217: PUSH
30218: LD_VAR 0 1
30222: PUSH
30223: LD_VAR 0 5
30227: ARRAY
30228: PPUSH
30229: LD_VAR 0 6
30233: PPUSH
30234: CALL_OW 3
30238: ST_TO_ADDR
// break ;
30239: GO 30243
// end ;
30241: GO 30186
30243: POP
30244: POP
// if tmp = [ ] then
30245: LD_VAR 0 7
30249: PUSH
30250: EMPTY
30251: EQUAL
30252: IFFALSE 30276
// begin tab := Delete ( tab , i ) ;
30254: LD_ADDR_VAR 0 1
30258: PUSH
30259: LD_VAR 0 1
30263: PPUSH
30264: LD_VAR 0 5
30268: PPUSH
30269: CALL_OW 3
30273: ST_TO_ADDR
// end else
30274: GO 30301
// tab := Replace ( tab , i , tmp ) ;
30276: LD_ADDR_VAR 0 1
30280: PUSH
30281: LD_VAR 0 1
30285: PPUSH
30286: LD_VAR 0 5
30290: PPUSH
30291: LD_VAR 0 7
30295: PPUSH
30296: CALL_OW 1
30300: ST_TO_ADDR
// i := i - 1 ;
30301: LD_ADDR_VAR 0 5
30305: PUSH
30306: LD_VAR 0 5
30310: PUSH
30311: LD_INT 1
30313: MINUS
30314: ST_TO_ADDR
// if mode then
30315: LD_VAR 0 3
30319: IFFALSE 30323
// break ;
30321: GO 30339
// end ; i := i + 1 ;
30323: LD_ADDR_VAR 0 5
30327: PUSH
30328: LD_VAR 0 5
30332: PUSH
30333: LD_INT 1
30335: PLUS
30336: ST_TO_ADDR
// end ;
30337: GO 29954
// result := tab ;
30339: LD_ADDR_VAR 0 4
30343: PUSH
30344: LD_VAR 0 1
30348: ST_TO_ADDR
// end ;
30349: LD_VAR 0 4
30353: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
30354: LD_INT 0
30356: PPUSH
30357: PPUSH
// for i = 1 to values do
30358: LD_ADDR_VAR 0 4
30362: PUSH
30363: DOUBLE
30364: LD_INT 1
30366: DEC
30367: ST_TO_ADDR
30368: LD_VAR 0 2
30372: PUSH
30373: FOR_TO
30374: IFFALSE 30407
// tab := Remove ( tab , values [ i ] , false ) ;
30376: LD_ADDR_VAR 0 1
30380: PUSH
30381: LD_VAR 0 1
30385: PPUSH
30386: LD_VAR 0 2
30390: PUSH
30391: LD_VAR 0 4
30395: ARRAY
30396: PPUSH
30397: LD_INT 0
30399: PPUSH
30400: CALL 29940 0 3
30404: ST_TO_ADDR
30405: GO 30373
30407: POP
30408: POP
// result := tab ;
30409: LD_ADDR_VAR 0 3
30413: PUSH
30414: LD_VAR 0 1
30418: ST_TO_ADDR
// end ;
30419: LD_VAR 0 3
30423: RET
// export function IsDriver ( unit ) ; begin
30424: LD_INT 0
30426: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
30427: LD_VAR 0 1
30431: PUSH
30432: LD_INT 55
30434: PUSH
30435: EMPTY
30436: LIST
30437: PPUSH
30438: CALL_OW 69
30442: IN
30443: IFFALSE 30462
// result := IsInUnit ( unit ) else
30445: LD_ADDR_VAR 0 2
30449: PUSH
30450: LD_VAR 0 1
30454: PPUSH
30455: CALL_OW 310
30459: ST_TO_ADDR
30460: GO 30470
// result := false ;
30462: LD_ADDR_VAR 0 2
30466: PUSH
30467: LD_INT 0
30469: ST_TO_ADDR
// end ;
30470: LD_VAR 0 2
30474: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
30475: LD_INT 0
30477: PPUSH
30478: PPUSH
30479: PPUSH
// if not GetControl ( veh ) = control_manual then
30480: LD_VAR 0 1
30484: PPUSH
30485: CALL_OW 263
30489: PUSH
30490: LD_INT 1
30492: EQUAL
30493: NOT
30494: IFFALSE 30506
// result := false else
30496: LD_ADDR_VAR 0 2
30500: PUSH
30501: LD_INT 0
30503: ST_TO_ADDR
30504: GO 30651
// if veh in FilterAllUnits ( [ f_empty ] ) then
30506: LD_VAR 0 1
30510: PUSH
30511: LD_INT 58
30513: PUSH
30514: EMPTY
30515: LIST
30516: PPUSH
30517: CALL_OW 69
30521: IN
30522: IFFALSE 30534
// result := false else
30524: LD_ADDR_VAR 0 2
30528: PUSH
30529: LD_INT 0
30531: ST_TO_ADDR
30532: GO 30651
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
30534: LD_ADDR_VAR 0 4
30538: PUSH
30539: LD_INT 22
30541: PUSH
30542: LD_VAR 0 1
30546: PPUSH
30547: CALL_OW 255
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 55
30558: PUSH
30559: EMPTY
30560: LIST
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PPUSH
30566: CALL_OW 69
30570: ST_TO_ADDR
// if not filter then
30571: LD_VAR 0 4
30575: NOT
30576: IFFALSE 30588
// result := false else
30578: LD_ADDR_VAR 0 2
30582: PUSH
30583: LD_INT 0
30585: ST_TO_ADDR
30586: GO 30651
// for i = 1 to filter do
30588: LD_ADDR_VAR 0 3
30592: PUSH
30593: DOUBLE
30594: LD_INT 1
30596: DEC
30597: ST_TO_ADDR
30598: LD_VAR 0 4
30602: PUSH
30603: FOR_TO
30604: IFFALSE 30649
// if IsDriver ( filter [ i ] ) = veh then
30606: LD_VAR 0 4
30610: PUSH
30611: LD_VAR 0 3
30615: ARRAY
30616: PPUSH
30617: CALL 30424 0 1
30621: PUSH
30622: LD_VAR 0 1
30626: EQUAL
30627: IFFALSE 30647
// begin result := filter [ i ] ;
30629: LD_ADDR_VAR 0 2
30633: PUSH
30634: LD_VAR 0 4
30638: PUSH
30639: LD_VAR 0 3
30643: ARRAY
30644: ST_TO_ADDR
// break ;
30645: GO 30649
// end ;
30647: GO 30603
30649: POP
30650: POP
// end ; end ;
30651: LD_VAR 0 2
30655: RET
// export function ComComplete ( unit , b ) ; var i ; begin
30656: LD_INT 0
30658: PPUSH
30659: PPUSH
// if BuildingStatus ( b ) = bs_build then
30660: LD_VAR 0 2
30664: PPUSH
30665: CALL_OW 461
30669: PUSH
30670: LD_INT 1
30672: EQUAL
30673: IFFALSE 30733
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
30675: LD_VAR 0 1
30679: PPUSH
30680: LD_STRING h
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 250
30692: PUSH
30693: LD_VAR 0 2
30697: PPUSH
30698: CALL_OW 251
30702: PUSH
30703: LD_VAR 0 2
30707: PUSH
30708: LD_INT 0
30710: PUSH
30711: LD_INT 0
30713: PUSH
30714: LD_INT 0
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: PUSH
30726: EMPTY
30727: LIST
30728: PPUSH
30729: CALL_OW 446
// end ;
30733: LD_VAR 0 3
30737: RET
// export function Compare ( val1 , val2 ) ; begin
30738: LD_INT 0
30740: PPUSH
// if val1 = val2 then
30741: LD_VAR 0 1
30745: PUSH
30746: LD_VAR 0 2
30750: EQUAL
30751: IFFALSE 30763
// result := true else
30753: LD_ADDR_VAR 0 3
30757: PUSH
30758: LD_INT 1
30760: ST_TO_ADDR
30761: GO 30771
// result := false ;
30763: LD_ADDR_VAR 0 3
30767: PUSH
30768: LD_INT 0
30770: ST_TO_ADDR
// end ;
30771: LD_VAR 0 3
30775: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30776: LD_INT 0
30778: PPUSH
30779: PPUSH
// result := true ;
30780: LD_ADDR_VAR 0 3
30784: PUSH
30785: LD_INT 1
30787: ST_TO_ADDR
// if array1 = array2 then
30788: LD_VAR 0 1
30792: PUSH
30793: LD_VAR 0 2
30797: EQUAL
30798: IFFALSE 30863
// begin for i = 1 to array1 do
30800: LD_ADDR_VAR 0 4
30804: PUSH
30805: DOUBLE
30806: LD_INT 1
30808: DEC
30809: ST_TO_ADDR
30810: LD_VAR 0 1
30814: PUSH
30815: FOR_TO
30816: IFFALSE 30859
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
30818: LD_VAR 0 1
30822: PUSH
30823: LD_VAR 0 4
30827: ARRAY
30828: PPUSH
30829: LD_VAR 0 2
30833: PUSH
30834: LD_VAR 0 4
30838: ARRAY
30839: PPUSH
30840: CALL 30738 0 2
30844: NOT
30845: IFFALSE 30857
// begin result := false ;
30847: LD_ADDR_VAR 0 3
30851: PUSH
30852: LD_INT 0
30854: ST_TO_ADDR
// break ;
30855: GO 30859
// end ;
30857: GO 30815
30859: POP
30860: POP
// end else
30861: GO 30871
// result := false ;
30863: LD_ADDR_VAR 0 3
30867: PUSH
30868: LD_INT 0
30870: ST_TO_ADDR
// end ;
30871: LD_VAR 0 3
30875: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
30876: LD_INT 0
30878: PPUSH
30879: PPUSH
// result := false ;
30880: LD_ADDR_VAR 0 3
30884: PUSH
30885: LD_INT 0
30887: ST_TO_ADDR
// for j = 1 to e2 do
30888: LD_ADDR_VAR 0 4
30892: PUSH
30893: DOUBLE
30894: LD_INT 1
30896: DEC
30897: ST_TO_ADDR
30898: LD_VAR 0 2
30902: PUSH
30903: FOR_TO
30904: IFFALSE 30938
// if Compare ( e1 , e2 [ j ] ) then
30906: LD_VAR 0 1
30910: PPUSH
30911: LD_VAR 0 2
30915: PUSH
30916: LD_VAR 0 4
30920: ARRAY
30921: PPUSH
30922: CALL 30738 0 2
30926: IFFALSE 30936
// result := true ;
30928: LD_ADDR_VAR 0 3
30932: PUSH
30933: LD_INT 1
30935: ST_TO_ADDR
30936: GO 30903
30938: POP
30939: POP
// end ;
30940: LD_VAR 0 3
30944: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
30945: LD_INT 0
30947: PPUSH
30948: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
30949: LD_VAR 0 1
30953: PPUSH
30954: LD_STRING C
30956: PUSH
30957: LD_VAR 0 2
30961: PUSH
30962: LD_VAR 0 3
30966: PUSH
30967: LD_INT 0
30969: PUSH
30970: LD_INT 0
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 0
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: PUSH
30988: LD_STRING v
30990: PUSH
30991: LD_VAR 0 4
30995: PPUSH
30996: CALL_OW 250
31000: PUSH
31001: LD_VAR 0 4
31005: PPUSH
31006: CALL_OW 251
31010: PUSH
31011: LD_VAR 0 4
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: LD_INT 0
31021: PUSH
31022: LD_INT 0
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PPUSH
31038: CALL_OW 446
// end ;
31042: LD_VAR 0 5
31046: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
31047: LD_INT 0
31049: PPUSH
31050: PPUSH
31051: PPUSH
// linked := UnitsLinked ( unit ) ;
31052: LD_ADDR_VAR 0 4
31056: PUSH
31057: LD_VAR 0 1
31061: PPUSH
31062: CALL_OW 432
31066: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
31067: LD_ADDR_VAR 0 3
31071: PUSH
31072: LD_VAR 0 1
31076: PPUSH
31077: LD_INT 3
31079: PPUSH
31080: CALL_OW 259
31084: ST_TO_ADDR
// if sk > linked then
31085: LD_VAR 0 3
31089: PUSH
31090: LD_VAR 0 4
31094: GREATER
31095: IFFALSE 31107
// result := true else
31097: LD_ADDR_VAR 0 2
31101: PUSH
31102: LD_INT 1
31104: ST_TO_ADDR
31105: GO 31115
// result := false ;
31107: LD_ADDR_VAR 0 2
31111: PUSH
31112: LD_INT 0
31114: ST_TO_ADDR
// end ;
31115: LD_VAR 0 2
31119: RET
// export function NotTask ( unit ) ; begin
31120: LD_INT 0
31122: PPUSH
// result := true ;
31123: LD_ADDR_VAR 0 2
31127: PUSH
31128: LD_INT 1
31130: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
31131: LD_VAR 0 1
31135: PPUSH
31136: CALL_OW 437
31140: PUSH
31141: LD_VAR 0 1
31145: PPUSH
31146: CALL_OW 314
31150: OR
31151: IFFALSE 31161
// result := false ;
31153: LD_ADDR_VAR 0 2
31157: PUSH
31158: LD_INT 0
31160: ST_TO_ADDR
// end ;
31161: LD_VAR 0 2
31165: RET
// export function WantHeal ( sci , unit ) ; begin
31166: LD_INT 0
31168: PPUSH
// if GetTaskList ( sci ) > 0 then
31169: LD_VAR 0 1
31173: PPUSH
31174: CALL_OW 437
31178: PUSH
31179: LD_INT 0
31181: GREATER
31182: IFFALSE 31252
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
31184: LD_VAR 0 1
31188: PPUSH
31189: CALL_OW 437
31193: PUSH
31194: LD_INT 1
31196: ARRAY
31197: PUSH
31198: LD_INT 1
31200: ARRAY
31201: PUSH
31202: LD_STRING l
31204: EQUAL
31205: PUSH
31206: LD_VAR 0 1
31210: PPUSH
31211: CALL_OW 437
31215: PUSH
31216: LD_INT 1
31218: ARRAY
31219: PUSH
31220: LD_INT 4
31222: ARRAY
31223: PUSH
31224: LD_VAR 0 2
31228: EQUAL
31229: AND
31230: IFFALSE 31242
// result := true else
31232: LD_ADDR_VAR 0 3
31236: PUSH
31237: LD_INT 1
31239: ST_TO_ADDR
31240: GO 31250
// result := false ;
31242: LD_ADDR_VAR 0 3
31246: PUSH
31247: LD_INT 0
31249: ST_TO_ADDR
// end else
31250: GO 31260
// result := false ;
31252: LD_ADDR_VAR 0 3
31256: PUSH
31257: LD_INT 0
31259: ST_TO_ADDR
// end ;
31260: LD_VAR 0 3
31264: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
31265: LD_INT 0
31267: PPUSH
31268: PPUSH
31269: PPUSH
31270: PPUSH
31271: PPUSH
// dist := 99999 ;
31272: LD_ADDR_VAR 0 7
31276: PUSH
31277: LD_INT 99999
31279: ST_TO_ADDR
// un := - 1 ;
31280: LD_ADDR_VAR 0 6
31284: PUSH
31285: LD_INT 1
31287: NEG
31288: ST_TO_ADDR
// if units1 and units2 then
31289: LD_VAR 0 1
31293: PUSH
31294: LD_VAR 0 2
31298: AND
31299: IFFALSE 31387
// for i in units1 do
31301: LD_ADDR_VAR 0 4
31305: PUSH
31306: LD_VAR 0 1
31310: PUSH
31311: FOR_IN
31312: IFFALSE 31385
// for j in units2 do
31314: LD_ADDR_VAR 0 5
31318: PUSH
31319: LD_VAR 0 2
31323: PUSH
31324: FOR_IN
31325: IFFALSE 31381
// if GetDistUnits ( i , j ) < dist then
31327: LD_VAR 0 4
31331: PPUSH
31332: LD_VAR 0 5
31336: PPUSH
31337: CALL_OW 296
31341: PUSH
31342: LD_VAR 0 7
31346: LESS
31347: IFFALSE 31379
// begin un := i ;
31349: LD_ADDR_VAR 0 6
31353: PUSH
31354: LD_VAR 0 4
31358: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
31359: LD_ADDR_VAR 0 7
31363: PUSH
31364: LD_VAR 0 4
31368: PPUSH
31369: LD_VAR 0 5
31373: PPUSH
31374: CALL_OW 296
31378: ST_TO_ADDR
// end ;
31379: GO 31324
31381: POP
31382: POP
31383: GO 31311
31385: POP
31386: POP
// result := [ un , dist ] ;
31387: LD_ADDR_VAR 0 3
31391: PUSH
31392: LD_VAR 0 6
31396: PUSH
31397: LD_VAR 0 7
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: ST_TO_ADDR
// end ;
31406: LD_VAR 0 3
31410: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
31411: LD_INT 0
31413: PPUSH
31414: PPUSH
// area = ListEnvironmentArea ( area ) ;
31415: LD_ADDR_VAR 0 2
31419: PUSH
31420: LD_VAR 0 2
31424: PPUSH
31425: CALL_OW 353
31429: ST_TO_ADDR
// if bulldozer > 0 then
31430: LD_VAR 0 1
31434: PUSH
31435: LD_INT 0
31437: GREATER
31438: IFFALSE 31549
// for i = area downto 1 do
31440: LD_ADDR_VAR 0 4
31444: PUSH
31445: DOUBLE
31446: LD_VAR 0 2
31450: INC
31451: ST_TO_ADDR
31452: LD_INT 1
31454: PUSH
31455: FOR_DOWNTO
31456: IFFALSE 31547
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
31458: LD_VAR 0 2
31462: PUSH
31463: LD_VAR 0 4
31467: ARRAY
31468: PUSH
31469: LD_INT 1
31471: ARRAY
31472: PPUSH
31473: LD_VAR 0 2
31477: PUSH
31478: LD_VAR 0 4
31482: ARRAY
31483: PUSH
31484: LD_INT 2
31486: ARRAY
31487: PPUSH
31488: CALL_OW 351
31492: IFFALSE 31545
// if not HasTask ( bulldozer ) then
31494: LD_VAR 0 1
31498: PPUSH
31499: CALL_OW 314
31503: NOT
31504: IFFALSE 31545
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
31506: LD_VAR 0 1
31510: PPUSH
31511: LD_VAR 0 2
31515: PUSH
31516: LD_VAR 0 4
31520: ARRAY
31521: PUSH
31522: LD_INT 1
31524: ARRAY
31525: PPUSH
31526: LD_VAR 0 2
31530: PUSH
31531: LD_VAR 0 4
31535: ARRAY
31536: PUSH
31537: LD_INT 2
31539: ARRAY
31540: PPUSH
31541: CALL_OW 171
31545: GO 31455
31547: POP
31548: POP
// end ;
31549: LD_VAR 0 3
31553: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
31554: LD_INT 0
31556: PPUSH
31557: PPUSH
31558: PPUSH
31559: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
31560: LD_ADDR_VAR 0 6
31564: PUSH
31565: LD_INT 22
31567: PUSH
31568: LD_VAR 0 1
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 21
31579: PUSH
31580: LD_VAR 0 2
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PPUSH
31593: CALL_OW 69
31597: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
31598: LD_ADDR_VAR 0 7
31602: PUSH
31603: LD_VAR 0 3
31607: PPUSH
31608: LD_INT 22
31610: PUSH
31611: LD_VAR 0 1
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 21
31622: PUSH
31623: LD_VAR 0 2
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PPUSH
31636: CALL_OW 70
31640: ST_TO_ADDR
// if tmp and pom then
31641: LD_VAR 0 6
31645: PUSH
31646: LD_VAR 0 7
31650: AND
31651: IFFALSE 31671
// result := tmp diff pom else
31653: LD_ADDR_VAR 0 4
31657: PUSH
31658: LD_VAR 0 6
31662: PUSH
31663: LD_VAR 0 7
31667: DIFF
31668: ST_TO_ADDR
31669: GO 31679
// result := false ;
31671: LD_ADDR_VAR 0 4
31675: PUSH
31676: LD_INT 0
31678: ST_TO_ADDR
// end ; end_of_file
31679: LD_VAR 0 4
31683: RET
// export mc_game_live , mc_crates_list , mc_mapname ; every 0 0$01 trigger mc_game_live do var i ;
31684: LD_EXP 25
31688: IFFALSE 31750
31690: GO 31692
31692: DISABLE
31693: LD_INT 0
31695: PPUSH
// begin enable ;
31696: ENABLE
// for i = 1 to mc_crates_list do
31697: LD_ADDR_VAR 0 1
31701: PUSH
31702: DOUBLE
31703: LD_INT 1
31705: DEC
31706: ST_TO_ADDR
31707: LD_EXP 26
31711: PUSH
31712: FOR_TO
31713: IFFALSE 31744
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
31715: LD_EXP 26
31719: PUSH
31720: LD_VAR 0 1
31724: ARRAY
31725: PPUSH
31726: LD_INT 5
31728: PPUSH
31729: LD_INT 50
31731: PPUSH
31732: LD_INT 700
31734: PPUSH
31735: LD_INT 20
31737: PPUSH
31738: CALL 23843 0 5
31742: GO 31712
31744: POP
31745: POP
// MC_Game ( ) ;
31746: CALL 31753 0 0
// end ;
31750: PPOPN 1
31752: END
// export function MC_Game ( ) ; var i , side , un ; begin
31753: LD_INT 0
31755: PPUSH
31756: PPUSH
31757: PPUSH
31758: PPUSH
// MC_Show ( [ #tick , tick ] ) ;
31759: LD_STRING #tick
31761: PUSH
31762: LD_OWVAR 1
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PPUSH
31771: CALL 7885 0 1
// for side = 1 to 8 do
31775: LD_ADDR_VAR 0 3
31779: PUSH
31780: DOUBLE
31781: LD_INT 1
31783: DEC
31784: ST_TO_ADDR
31785: LD_INT 8
31787: PUSH
31788: FOR_TO
31789: IFFALSE 33826
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
31791: LD_EXP 34
31795: PUSH
31796: LD_VAR 0 3
31800: ARRAY
31801: PUSH
31802: LD_INT 0
31804: EQUAL
31805: PUSH
31806: LD_VAR 0 3
31810: PPUSH
31811: EMPTY
31812: PPUSH
31813: CALL 11102 0 2
31817: PUSH
31818: LD_INT 0
31820: EQUAL
31821: OR
31822: IFFALSE 31826
// continue ;
31824: GO 31788
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
31826: LD_VAR 0 3
31830: PPUSH
31831: LD_VAR 0 3
31835: PPUSH
31836: CALL 24364 0 1
31840: PPUSH
31841: CALL 33833 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
31845: LD_EXP 66
31849: PUSH
31850: LD_VAR 0 3
31854: ARRAY
31855: PUSH
31856: LD_INT 1
31858: ARRAY
31859: PUSH
31860: LD_INT 0
31862: GREATER
31863: PUSH
31864: LD_EXP 64
31868: PUSH
31869: LD_VAR 0 3
31873: ARRAY
31874: PUSH
31875: LD_INT 1
31877: ARRAY
31878: PUSH
31879: LD_INT 0
31881: EQUAL
31882: AND
31883: PUSH
31884: LD_VAR 0 3
31888: PPUSH
31889: LD_INT 7
31891: PPUSH
31892: EMPTY
31893: PPUSH
31894: CALL 11670 0 3
31898: NOT
31899: AND
31900: IFFALSE 31981
// begin if mc_mapname = TwoFronts then
31902: LD_EXP 27
31906: PUSH
31907: LD_STRING TwoFronts
31909: EQUAL
31910: IFFALSE 31946
// begin if side = 1 then
31912: LD_VAR 0 3
31916: PUSH
31917: LD_INT 1
31919: EQUAL
31920: IFFALSE 31929
// RaiseSailEvent ( 101 ) ;
31922: LD_INT 101
31924: PPUSH
31925: CALL_OW 427
// if side = 4 then
31929: LD_VAR 0 3
31933: PUSH
31934: LD_INT 4
31936: EQUAL
31937: IFFALSE 31946
// RaiseSailEvent ( 102 ) ;
31939: LD_INT 102
31941: PPUSH
31942: CALL_OW 427
// end ; for i in MREG_Attackers [ side ] do
31946: LD_ADDR_VAR 0 2
31950: PUSH
31951: LD_EXP 66
31955: PUSH
31956: LD_VAR 0 3
31960: ARRAY
31961: PUSH
31962: FOR_IN
31963: IFFALSE 31979
// SetTag ( i , 7 ) ;
31965: LD_VAR 0 2
31969: PPUSH
31970: LD_INT 7
31972: PPUSH
31973: CALL_OW 109
31977: GO 31962
31979: POP
31980: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
31981: LD_VAR 0 3
31985: PPUSH
31986: LD_INT 7
31988: PPUSH
31989: EMPTY
31990: PPUSH
31991: CALL 11670 0 3
31995: IFFALSE 32021
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
31997: LD_VAR 0 3
32001: PPUSH
32002: LD_VAR 0 3
32006: PPUSH
32007: LD_INT 7
32009: PPUSH
32010: EMPTY
32011: PPUSH
32012: CALL 11670 0 3
32016: PPUSH
32017: CALL 7812 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
32021: LD_VAR 0 3
32025: PPUSH
32026: CALL 17350 0 1
32030: PUSH
32031: LD_VAR 0 3
32035: PPUSH
32036: CALL 11006 0 1
32040: AND
32041: IFFALSE 32052
// MCL_Start ( side ) ;
32043: LD_VAR 0 3
32047: PPUSH
32048: CALL 17307 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
32052: LD_ADDR_EXP 30
32056: PUSH
32057: LD_EXP 30
32061: PPUSH
32062: LD_VAR 0 3
32066: PPUSH
32067: LD_VAR 0 3
32071: PPUSH
32072: CALL 18607 0 1
32076: PPUSH
32077: CALL_OW 1
32081: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
32082: LD_ADDR_EXP 42
32086: PUSH
32087: LD_EXP 42
32091: PPUSH
32092: LD_VAR 0 3
32096: PPUSH
32097: LD_VAR 0 3
32101: PPUSH
32102: CALL 10420 0 1
32106: PPUSH
32107: CALL_OW 1
32111: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
32112: LD_VAR 0 3
32116: PPUSH
32117: LD_INT 21
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PPUSH
32127: CALL 10967 0 2
32131: IFFALSE 32142
// MCV_CheckStatus ( side ) ;
32133: LD_VAR 0 3
32137: PPUSH
32138: CALL 26570 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
32142: LD_VAR 0 3
32146: PPUSH
32147: LD_EXP 48
32151: PPUSH
32152: CALL 40752 0 2
32156: IFFALSE 32241
// begin for i = MREG_ToChangeClass downto 1 do
32158: LD_ADDR_VAR 0 2
32162: PUSH
32163: DOUBLE
32164: LD_EXP 48
32168: INC
32169: ST_TO_ADDR
32170: LD_INT 1
32172: PUSH
32173: FOR_DOWNTO
32174: IFFALSE 32239
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
32176: LD_EXP 48
32180: PUSH
32181: LD_VAR 0 2
32185: ARRAY
32186: PUSH
32187: LD_INT 1
32189: ARRAY
32190: PUSH
32191: LD_VAR 0 3
32195: EQUAL
32196: IFFALSE 32237
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
32198: LD_VAR 0 3
32202: PPUSH
32203: LD_EXP 48
32207: PUSH
32208: LD_VAR 0 2
32212: ARRAY
32213: PUSH
32214: LD_INT 2
32216: ARRAY
32217: PPUSH
32218: LD_EXP 48
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PUSH
32229: LD_INT 3
32231: ARRAY
32232: PPUSH
32233: CALL 15874 0 3
// end ; end ;
32237: GO 32173
32239: POP
32240: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
32241: LD_INT 1
32243: PUSH
32244: LD_EXP 33
32248: PUSH
32249: LD_VAR 0 3
32253: ARRAY
32254: IN
32255: IFFALSE 32266
// begin MCN_TrainApe ( side ) ;
32257: LD_VAR 0 3
32261: PPUSH
32262: CALL 18260 0 1
// end ; if MREG_ToConstruct [ side ] then
32266: LD_EXP 46
32270: PUSH
32271: LD_VAR 0 3
32275: ARRAY
32276: IFFALSE 32398
// begin if MCF_Get ( side , [ f_btype , b_factory ] ) then
32278: LD_VAR 0 3
32282: PPUSH
32283: LD_INT 30
32285: PUSH
32286: LD_INT 3
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PPUSH
32293: CALL 10967 0 2
32297: IFFALSE 32398
// MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
32299: LD_VAR 0 3
32303: PPUSH
32304: LD_VAR 0 3
32308: PPUSH
32309: LD_INT 30
32311: PUSH
32312: LD_INT 3
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PPUSH
32319: CALL 10967 0 2
32323: PUSH
32324: LD_INT 1
32326: ARRAY
32327: PPUSH
32328: LD_EXP 46
32332: PUSH
32333: LD_VAR 0 3
32337: ARRAY
32338: PUSH
32339: LD_INT 1
32341: ARRAY
32342: PUSH
32343: LD_EXP 46
32347: PUSH
32348: LD_VAR 0 3
32352: ARRAY
32353: PUSH
32354: LD_INT 2
32356: ARRAY
32357: PUSH
32358: LD_EXP 46
32362: PUSH
32363: LD_VAR 0 3
32367: ARRAY
32368: PUSH
32369: LD_INT 3
32371: ARRAY
32372: PUSH
32373: LD_EXP 46
32377: PUSH
32378: LD_VAR 0 3
32382: ARRAY
32383: PUSH
32384: LD_INT 4
32386: ARRAY
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: PPUSH
32394: CALL 24867 0 3
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
32398: LD_VAR 0 3
32402: PPUSH
32403: LD_INT 30
32405: PUSH
32406: LD_INT 3
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PPUSH
32413: CALL 10967 0 2
32417: PUSH
32418: LD_VAR 0 3
32422: PPUSH
32423: LD_EXP 38
32427: PPUSH
32428: CALL 40752 0 2
32432: AND
32433: PUSH
32434: LD_INT 22
32436: PUSH
32437: LD_VAR 0 3
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 2
32448: PUSH
32449: LD_INT 30
32451: PUSH
32452: LD_INT 33
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 30
32461: PUSH
32462: LD_INT 32
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 35
32476: PUSH
32477: LD_INT 0
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: LIST
32488: PPUSH
32489: CALL_OW 69
32493: AND
32494: IFFALSE 32505
// MCV_Turret ( side ) ;
32496: LD_VAR 0 3
32500: PPUSH
32501: CALL 25296 0 1
// if MCF_Get ( side , [ f_engine , engine_combustion ] ) then
32505: LD_VAR 0 3
32509: PPUSH
32510: LD_INT 32
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PPUSH
32520: CALL 10967 0 2
32524: IFFALSE 32574
// begin MCV_CheckFuel ( side ) ;
32526: LD_VAR 0 3
32530: PPUSH
32531: CALL 25512 0 1
// if MCF_Tag ( side , 21 , [ ] ) then
32535: LD_VAR 0 3
32539: PPUSH
32540: LD_INT 21
32542: PPUSH
32543: EMPTY
32544: PPUSH
32545: CALL 11670 0 3
32549: IFFALSE 32574
// MCV_Refuel ( MCF_Tag ( side , 21 , [ ] ) [ 1 ] ) ;
32551: LD_VAR 0 3
32555: PPUSH
32556: LD_INT 21
32558: PPUSH
32559: EMPTY
32560: PPUSH
32561: CALL 11670 0 3
32565: PUSH
32566: LD_INT 1
32568: ARRAY
32569: PPUSH
32570: CALL 25641 0 1
// end ; if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
32574: LD_EXP 37
32578: PUSH
32579: LD_VAR 0 3
32583: ARRAY
32584: PUSH
32585: LD_INT 1
32587: GREATER
32588: PUSH
32589: LD_VAR 0 3
32593: PPUSH
32594: CALL 24364 0 1
32598: PUSH
32599: LD_INT 0
32601: EQUAL
32602: AND
32603: IFFALSE 32786
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
32605: LD_EXP 37
32609: PUSH
32610: LD_VAR 0 3
32614: ARRAY
32615: PUSH
32616: LD_INT 1
32618: ARRAY
32619: PPUSH
32620: CALL_OW 353
32624: IFFALSE 32662
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
32626: LD_EXP 37
32630: PUSH
32631: LD_VAR 0 3
32635: ARRAY
32636: PUSH
32637: LD_INT 2
32639: ARRAY
32640: PPUSH
32641: LD_EXP 37
32645: PUSH
32646: LD_VAR 0 3
32650: ARRAY
32651: PUSH
32652: LD_INT 1
32654: ARRAY
32655: PPUSH
32656: CALL 31411 0 2
32660: GO 32786
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
32662: LD_VAR 0 3
32666: PPUSH
32667: LD_INT 30
32669: PUSH
32670: LD_INT 3
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PPUSH
32677: CALL 10967 0 2
32681: IFFALSE 32786
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
32683: LD_VAR 0 3
32687: PPUSH
32688: LD_INT 30
32690: PUSH
32691: LD_INT 3
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PPUSH
32698: CALL 10967 0 2
32702: PUSH
32703: LD_INT 1
32705: ARRAY
32706: PPUSH
32707: CALL_OW 461
32711: PUSH
32712: LD_INT 2
32714: EQUAL
32715: IFFALSE 32786
// begin ComRecycle ( MREG_Bulldozer [ side ] [ 2 ] , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
32717: LD_EXP 37
32721: PUSH
32722: LD_VAR 0 3
32726: ARRAY
32727: PUSH
32728: LD_INT 2
32730: ARRAY
32731: PPUSH
32732: LD_VAR 0 3
32736: PPUSH
32737: LD_INT 30
32739: PUSH
32740: LD_INT 3
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PPUSH
32747: CALL 10967 0 2
32751: PUSH
32752: LD_INT 1
32754: ARRAY
32755: PPUSH
32756: CALL_OW 168
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
32760: LD_ADDR_EXP 37
32764: PUSH
32765: LD_EXP 37
32769: PPUSH
32770: LD_VAR 0 3
32774: PPUSH
32775: LD_INT 0
32777: PUSH
32778: EMPTY
32779: LIST
32780: PPUSH
32781: CALL_OW 1
32785: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
32786: LD_VAR 0 3
32790: PPUSH
32791: LD_INT 33
32793: PUSH
32794: LD_INT 2
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PPUSH
32801: CALL 10967 0 2
32805: IFFALSE 32845
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
32807: LD_VAR 0 3
32811: PPUSH
32812: LD_VAR 0 3
32816: PPUSH
32817: LD_INT 33
32819: PUSH
32820: LD_INT 2
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PPUSH
32827: CALL 10967 0 2
32831: PUSH
32832: LD_INT 1
32834: ARRAY
32835: PPUSH
32836: CALL_OW 248
32840: PPUSH
32841: CALL 25867 0 2
// if MREG_ToRepair [ side ] then
32845: LD_EXP 42
32849: PUSH
32850: LD_VAR 0 3
32854: ARRAY
32855: IFFALSE 32868
// begin MCB_Repair ( side ) ;
32857: LD_VAR 0 3
32861: PPUSH
32862: CALL 10707 0 1
// end else
32866: GO 33779
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
32868: LD_VAR 0 3
32872: PPUSH
32873: LD_EXP 44
32877: PPUSH
32878: CALL 40752 0 2
32882: PUSH
32883: LD_VAR 0 3
32887: PPUSH
32888: LD_EXP 35
32892: PPUSH
32893: CALL 40752 0 2
32897: AND
32898: IFFALSE 33106
// begin for i = 1 to MREG_ToUpLab do
32900: LD_ADDR_VAR 0 2
32904: PUSH
32905: DOUBLE
32906: LD_INT 1
32908: DEC
32909: ST_TO_ADDR
32910: LD_EXP 44
32914: PUSH
32915: FOR_TO
32916: IFFALSE 33102
// if MREG_ToUpLab [ i ] [ 1 ] = side then
32918: LD_EXP 44
32922: PUSH
32923: LD_VAR 0 2
32927: ARRAY
32928: PUSH
32929: LD_INT 1
32931: ARRAY
32932: PUSH
32933: LD_VAR 0 3
32937: EQUAL
32938: IFFALSE 33100
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
32940: LD_EXP 44
32944: PUSH
32945: LD_VAR 0 2
32949: ARRAY
32950: PUSH
32951: LD_INT 2
32953: ARRAY
32954: PUSH
32955: LD_EXP 44
32959: PUSH
32960: LD_VAR 0 2
32964: ARRAY
32965: PUSH
32966: LD_INT 3
32968: ARRAY
32969: AND
32970: IFFALSE 33098
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
32972: LD_VAR 0 3
32976: PPUSH
32977: LD_EXP 44
32981: PUSH
32982: LD_VAR 0 2
32986: ARRAY
32987: PUSH
32988: LD_INT 2
32990: ARRAY
32991: PPUSH
32992: LD_EXP 44
32996: PUSH
32997: LD_VAR 0 2
33001: ARRAY
33002: PUSH
33003: LD_INT 3
33005: ARRAY
33006: PPUSH
33007: CALL 8231 0 3
33011: IFFALSE 33098
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
33013: LD_ADDR_EXP 44
33017: PUSH
33018: LD_EXP 44
33022: PPUSH
33023: LD_VAR 0 3
33027: PPUSH
33028: LD_EXP 44
33032: PUSH
33033: LD_VAR 0 2
33037: ARRAY
33038: PUSH
33039: LD_INT 2
33041: ARRAY
33042: PPUSH
33043: LD_EXP 44
33047: PUSH
33048: LD_VAR 0 2
33052: ARRAY
33053: PUSH
33054: LD_INT 3
33056: ARRAY
33057: PPUSH
33058: CALL 39804 0 4
33062: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
33063: LD_ADDR_EXP 35
33067: PUSH
33068: LD_EXP 35
33072: PPUSH
33073: LD_VAR 0 3
33077: PPUSH
33078: LD_EXP 35
33082: PUSH
33083: LD_INT 1
33085: ARRAY
33086: PUSH
33087: LD_INT 2
33089: ARRAY
33090: PPUSH
33091: EMPTY
33092: PPUSH
33093: CALL 39804 0 4
33097: ST_TO_ADDR
// end ; break ;
33098: GO 33102
// end ;
33100: GO 32915
33102: POP
33103: POP
// end else
33104: GO 33779
// if MREG_ForSide ( side , MREG_ToUpdate ) then
33106: LD_VAR 0 3
33110: PPUSH
33111: LD_EXP 43
33115: PPUSH
33116: CALL 40752 0 2
33120: IFFALSE 33194
// begin for i = 1 to MREG_ToUpdate do
33122: LD_ADDR_VAR 0 2
33126: PUSH
33127: DOUBLE
33128: LD_INT 1
33130: DEC
33131: ST_TO_ADDR
33132: LD_EXP 43
33136: PUSH
33137: FOR_TO
33138: IFFALSE 33190
// if MREG_ToUpdate [ i ] [ 1 ] = side then
33140: LD_EXP 43
33144: PUSH
33145: LD_VAR 0 2
33149: ARRAY
33150: PUSH
33151: LD_INT 1
33153: ARRAY
33154: PUSH
33155: LD_VAR 0 3
33159: EQUAL
33160: IFFALSE 33188
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
33162: LD_VAR 0 3
33166: PPUSH
33167: LD_EXP 43
33171: PUSH
33172: LD_VAR 0 2
33176: ARRAY
33177: PUSH
33178: LD_INT 2
33180: ARRAY
33181: PPUSH
33182: CALL 8067 0 2
// break ;
33186: GO 33190
// end ;
33188: GO 33137
33190: POP
33191: POP
// end else
33192: GO 33779
// if MCF_Get ( side , [ f_constructed ] ) then
33194: LD_VAR 0 3
33198: PPUSH
33199: LD_INT 57
33201: PUSH
33202: EMPTY
33203: LIST
33204: PPUSH
33205: CALL 10967 0 2
33209: IFFALSE 33242
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
33211: LD_VAR 0 3
33215: PPUSH
33216: LD_VAR 0 3
33220: PPUSH
33221: LD_INT 57
33223: PUSH
33224: EMPTY
33225: LIST
33226: PPUSH
33227: CALL 10967 0 2
33231: PUSH
33232: LD_INT 1
33234: ARRAY
33235: PPUSH
33236: CALL 10311 0 2
33240: GO 33779
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
33242: LD_VAR 0 3
33246: PPUSH
33247: LD_EXP 41
33251: PPUSH
33252: CALL 40752 0 2
33256: PUSH
33257: LD_VAR 0 3
33261: PPUSH
33262: CALL_OW 345
33266: NOT
33267: AND
33268: PUSH
33269: LD_VAR 0 3
33273: PPUSH
33274: CALL 24364 0 1
33278: PUSH
33279: LD_INT 0
33281: EQUAL
33282: AND
33283: IFFALSE 33680
// begin for i = 1 to MREG_ToBuild do
33285: LD_ADDR_VAR 0 2
33289: PUSH
33290: DOUBLE
33291: LD_INT 1
33293: DEC
33294: ST_TO_ADDR
33295: LD_EXP 41
33299: PUSH
33300: FOR_TO
33301: IFFALSE 33676
// if MREG_ToBuild [ i ] [ 1 ] = side then
33303: LD_EXP 41
33307: PUSH
33308: LD_VAR 0 2
33312: ARRAY
33313: PUSH
33314: LD_INT 1
33316: ARRAY
33317: PUSH
33318: LD_VAR 0 3
33322: EQUAL
33323: IFFALSE 33674
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
33325: LD_INT 1
33327: PUSH
33328: LD_EXP 41
33332: PUSH
33333: LD_VAR 0 2
33337: ARRAY
33338: PUSH
33339: LD_INT 3
33341: ARRAY
33342: PUSH
33343: LD_INT 1
33345: ARRAY
33346: PPUSH
33347: LD_EXP 41
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: PUSH
33358: LD_INT 3
33360: ARRAY
33361: PUSH
33362: LD_INT 2
33364: ARRAY
33365: PPUSH
33366: CALL_OW 351
33370: AND
33371: IFFALSE 33415
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
33373: LD_EXP 41
33377: PUSH
33378: LD_VAR 0 2
33382: ARRAY
33383: PUSH
33384: LD_INT 3
33386: ARRAY
33387: PUSH
33388: LD_INT 1
33390: ARRAY
33391: PPUSH
33392: LD_EXP 41
33396: PUSH
33397: LD_VAR 0 2
33401: ARRAY
33402: PUSH
33403: LD_INT 3
33405: ARRAY
33406: PUSH
33407: LD_INT 2
33409: ARRAY
33410: PPUSH
33411: CALL 22115 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
33415: LD_EXP 41
33419: PUSH
33420: LD_VAR 0 2
33424: ARRAY
33425: PUSH
33426: LD_INT 2
33428: ARRAY
33429: PUSH
33430: LD_INT 0
33432: EQUAL
33433: IFFALSE 33503
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
33435: LD_VAR 0 3
33439: PPUSH
33440: LD_EXP 41
33444: PUSH
33445: LD_VAR 0 2
33449: ARRAY
33450: PUSH
33451: LD_INT 3
33453: ARRAY
33454: PUSH
33455: LD_INT 1
33457: ARRAY
33458: PPUSH
33459: LD_EXP 41
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: PUSH
33470: LD_INT 3
33472: ARRAY
33473: PUSH
33474: LD_INT 2
33476: ARRAY
33477: PPUSH
33478: LD_EXP 41
33482: PUSH
33483: LD_VAR 0 2
33487: ARRAY
33488: PUSH
33489: LD_INT 3
33491: ARRAY
33492: PUSH
33493: LD_INT 3
33495: ARRAY
33496: PPUSH
33497: CALL 7903 0 4
33501: GO 33672
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
33503: LD_EXP 41
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: PUSH
33514: LD_INT 2
33516: ARRAY
33517: PUSH
33518: LD_INT 6
33520: EQUAL
33521: IFFALSE 33591
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
33523: LD_VAR 0 3
33527: PPUSH
33528: LD_EXP 41
33532: PUSH
33533: LD_VAR 0 2
33537: ARRAY
33538: PUSH
33539: LD_INT 3
33541: ARRAY
33542: PUSH
33543: LD_INT 1
33545: ARRAY
33546: PPUSH
33547: LD_EXP 41
33551: PUSH
33552: LD_VAR 0 2
33556: ARRAY
33557: PUSH
33558: LD_INT 3
33560: ARRAY
33561: PUSH
33562: LD_INT 2
33564: ARRAY
33565: PPUSH
33566: LD_EXP 41
33570: PUSH
33571: LD_VAR 0 2
33575: ARRAY
33576: PUSH
33577: LD_INT 3
33579: ARRAY
33580: PUSH
33581: LD_INT 3
33583: ARRAY
33584: PPUSH
33585: CALL 8032 0 4
33589: GO 33672
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
33591: LD_VAR 0 3
33595: PPUSH
33596: LD_EXP 41
33600: PUSH
33601: LD_VAR 0 2
33605: ARRAY
33606: PUSH
33607: LD_INT 2
33609: ARRAY
33610: PPUSH
33611: LD_EXP 41
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: PUSH
33622: LD_INT 3
33624: ARRAY
33625: PUSH
33626: LD_INT 1
33628: ARRAY
33629: PPUSH
33630: LD_EXP 41
33634: PUSH
33635: LD_VAR 0 2
33639: ARRAY
33640: PUSH
33641: LD_INT 3
33643: ARRAY
33644: PUSH
33645: LD_INT 2
33647: ARRAY
33648: PPUSH
33649: LD_EXP 41
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: PUSH
33660: LD_INT 3
33662: ARRAY
33663: PUSH
33664: LD_INT 3
33666: ARRAY
33667: PPUSH
33668: CALL 9536 0 5
// break ;
33672: GO 33676
// end ;
33674: GO 33300
33676: POP
33677: POP
// end else
33678: GO 33779
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
33680: LD_VAR 0 3
33684: PPUSH
33685: LD_EXP 47
33689: PPUSH
33690: CALL 40752 0 2
33694: PUSH
33695: LD_VAR 0 3
33699: PPUSH
33700: CALL 24364 0 1
33704: PUSH
33705: LD_INT 0
33707: EQUAL
33708: AND
33709: IFFALSE 33779
// begin for i = 1 to MREG_ToDismantle do
33711: LD_ADDR_VAR 0 2
33715: PUSH
33716: DOUBLE
33717: LD_INT 1
33719: DEC
33720: ST_TO_ADDR
33721: LD_EXP 47
33725: PUSH
33726: FOR_TO
33727: IFFALSE 33777
// if MREG_ToDismantle [ i ] [ 1 ] = side then
33729: LD_EXP 47
33733: PUSH
33734: LD_VAR 0 2
33738: ARRAY
33739: PUSH
33740: LD_INT 1
33742: ARRAY
33743: PUSH
33744: LD_VAR 0 3
33748: EQUAL
33749: IFFALSE 33775
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
33751: LD_VAR 0 3
33755: PPUSH
33756: LD_EXP 47
33760: PUSH
33761: LD_VAR 0 2
33765: ARRAY
33766: PUSH
33767: LD_INT 2
33769: ARRAY
33770: PPUSH
33771: CALL 10202 0 2
// end ;
33775: GO 33726
33777: POP
33778: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
33779: LD_VAR 0 3
33783: PPUSH
33784: LD_INT 30
33786: PUSH
33787: LD_INT 1
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PPUSH
33794: CALL 10967 0 2
33798: PUSH
33799: LD_VAR 0 3
33803: PPUSH
33804: CALL 24364 0 1
33808: PUSH
33809: LD_INT 0
33811: EQUAL
33812: AND
33813: IFFALSE 33824
// MCT_CollectCrates ( side ) ;
33815: LD_VAR 0 3
33819: PPUSH
33820: CALL 23307 0 1
// end ;
33824: GO 31788
33826: POP
33827: POP
// end ;
33828: LD_VAR 0 1
33832: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
33833: LD_INT 0
33835: PPUSH
33836: PPUSH
33837: PPUSH
33838: PPUSH
33839: PPUSH
33840: PPUSH
33841: PPUSH
33842: PPUSH
33843: PPUSH
33844: PPUSH
33845: PPUSH
33846: PPUSH
33847: PPUSH
33848: PPUSH
33849: PPUSH
// all := MCF_All ( side , [ ] ) ;
33850: LD_ADDR_VAR 0 17
33854: PUSH
33855: LD_VAR 0 1
33859: PPUSH
33860: EMPTY
33861: PPUSH
33862: CALL 11102 0 2
33866: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
33867: LD_ADDR_VAR 0 13
33871: PUSH
33872: LD_VAR 0 1
33876: PPUSH
33877: LD_INT 1
33879: PPUSH
33880: EMPTY
33881: PPUSH
33882: CALL 11050 0 3
33886: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
33887: LD_ADDR_VAR 0 14
33891: PUSH
33892: LD_VAR 0 1
33896: PPUSH
33897: LD_INT 2
33899: PPUSH
33900: EMPTY
33901: PPUSH
33902: CALL 11050 0 3
33906: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
33907: LD_ADDR_VAR 0 15
33911: PUSH
33912: LD_VAR 0 1
33916: PPUSH
33917: LD_INT 3
33919: PPUSH
33920: EMPTY
33921: PPUSH
33922: CALL 11050 0 3
33926: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
33927: LD_ADDR_VAR 0 16
33931: PUSH
33932: LD_VAR 0 1
33936: PPUSH
33937: LD_INT 4
33939: PPUSH
33940: EMPTY
33941: PPUSH
33942: CALL 11050 0 3
33946: ST_TO_ADDR
// if mech then
33947: LD_VAR 0 15
33951: IFFALSE 33968
// mech := MCF_SortListDesc ( mech ) ;
33953: LD_ADDR_VAR 0 15
33957: PUSH
33958: LD_VAR 0 15
33962: PPUSH
33963: CALL 12216 0 1
33967: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
33968: LD_EXP 51
33972: PUSH
33973: LD_VAR 0 1
33977: ARRAY
33978: PUSH
33979: LD_STRING 
33981: EQUAL
33982: NOT
33983: IFFALSE 34039
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
33985: LD_EXP 51
33989: PUSH
33990: LD_VAR 0 1
33994: ARRAY
33995: PUSH
33996: LD_INT 1
33998: ARRAY
33999: PPUSH
34000: CALL_OW 257
34004: PUSH
34005: LD_INT 1
34007: EQUAL
34008: IFFALSE 34037
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
34010: LD_VAR 0 1
34014: PPUSH
34015: LD_STRING ToArm
34017: PPUSH
34018: LD_EXP 51
34022: PUSH
34023: LD_VAR 0 1
34027: ARRAY
34028: PUSH
34029: LD_INT 1
34031: ARRAY
34032: PPUSH
34033: CALL 13846 0 3
// end else
34037: GO 34065
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
34039: LD_ADDR_EXP 51
34043: PUSH
34044: LD_EXP 51
34048: PPUSH
34049: LD_VAR 0 1
34053: PPUSH
34054: LD_INT 1
34056: PPUSH
34057: LD_INT 0
34059: PPUSH
34060: CALL 29864 0 4
34064: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
34065: LD_EXP 52
34069: PUSH
34070: LD_VAR 0 1
34074: ARRAY
34075: PUSH
34076: LD_STRING 
34078: EQUAL
34079: NOT
34080: IFFALSE 34136
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
34082: LD_EXP 52
34086: PUSH
34087: LD_VAR 0 1
34091: ARRAY
34092: PUSH
34093: LD_INT 1
34095: ARRAY
34096: PPUSH
34097: CALL_OW 257
34101: PUSH
34102: LD_INT 2
34104: EQUAL
34105: IFFALSE 34134
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
34107: LD_VAR 0 1
34111: PPUSH
34112: LD_STRING ToDep
34114: PPUSH
34115: LD_EXP 52
34119: PUSH
34120: LD_VAR 0 1
34124: ARRAY
34125: PUSH
34126: LD_INT 1
34128: ARRAY
34129: PPUSH
34130: CALL 13846 0 3
// end else
34134: GO 34162
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
34136: LD_ADDR_EXP 52
34140: PUSH
34141: LD_EXP 52
34145: PPUSH
34146: LD_VAR 0 1
34150: PPUSH
34151: LD_INT 1
34153: PPUSH
34154: LD_INT 0
34156: PPUSH
34157: CALL 29864 0 4
34161: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
34162: LD_EXP 50
34166: PUSH
34167: LD_VAR 0 1
34171: ARRAY
34172: PUSH
34173: LD_STRING 
34175: EQUAL
34176: NOT
34177: IFFALSE 34233
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
34179: LD_EXP 50
34183: PUSH
34184: LD_VAR 0 1
34188: ARRAY
34189: PUSH
34190: LD_INT 1
34192: ARRAY
34193: PPUSH
34194: CALL_OW 257
34198: PUSH
34199: LD_INT 3
34201: EQUAL
34202: IFFALSE 34231
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
34204: LD_VAR 0 1
34208: PPUSH
34209: LD_STRING ToFac
34211: PPUSH
34212: LD_EXP 50
34216: PUSH
34217: LD_VAR 0 1
34221: ARRAY
34222: PUSH
34223: LD_INT 1
34225: ARRAY
34226: PPUSH
34227: CALL 13846 0 3
// end else
34231: GO 34259
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
34233: LD_ADDR_EXP 50
34237: PUSH
34238: LD_EXP 50
34242: PPUSH
34243: LD_VAR 0 1
34247: PPUSH
34248: LD_INT 1
34250: PPUSH
34251: LD_INT 0
34253: PPUSH
34254: CALL 29864 0 4
34258: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
34259: LD_EXP 49
34263: PUSH
34264: LD_VAR 0 1
34268: ARRAY
34269: PUSH
34270: LD_STRING 
34272: EQUAL
34273: NOT
34274: IFFALSE 34330
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
34276: LD_EXP 49
34280: PUSH
34281: LD_VAR 0 1
34285: ARRAY
34286: PUSH
34287: LD_INT 1
34289: ARRAY
34290: PPUSH
34291: CALL_OW 257
34295: PUSH
34296: LD_INT 4
34298: EQUAL
34299: IFFALSE 34328
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
34301: LD_VAR 0 1
34305: PPUSH
34306: LD_STRING ToLab
34308: PPUSH
34309: LD_EXP 49
34313: PUSH
34314: LD_VAR 0 1
34318: ARRAY
34319: PUSH
34320: LD_INT 1
34322: ARRAY
34323: PPUSH
34324: CALL 13846 0 3
// end else
34328: GO 34356
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
34330: LD_ADDR_EXP 49
34334: PUSH
34335: LD_EXP 49
34339: PPUSH
34340: LD_VAR 0 1
34344: PPUSH
34345: LD_INT 1
34347: PPUSH
34348: LD_INT 0
34350: PPUSH
34351: CALL 29864 0 4
34355: ST_TO_ADDR
// if mode = 0 then
34356: LD_VAR 0 2
34360: PUSH
34361: LD_INT 0
34363: EQUAL
34364: IFFALSE 36190
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
34366: LD_VAR 0 1
34370: PPUSH
34371: LD_INT 30
34373: PUSH
34374: LD_INT 1
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PPUSH
34381: CALL 10967 0 2
34385: PUSH
34386: LD_VAR 0 1
34390: PPUSH
34391: LD_INT 21
34393: PUSH
34394: LD_INT 3
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PPUSH
34401: CALL 10967 0 2
34405: PUSH
34406: LD_INT 1
34408: EQUAL
34409: AND
34410: IFFALSE 34475
// begin if all then
34412: LD_VAR 0 17
34416: IFFALSE 34473
// for i in ( all diff eng ) do
34418: LD_ADDR_VAR 0 4
34422: PUSH
34423: LD_VAR 0 17
34427: PUSH
34428: LD_VAR 0 14
34432: DIFF
34433: PUSH
34434: FOR_IN
34435: IFFALSE 34471
// if GetTag ( i ) = 0 then
34437: LD_VAR 0 4
34441: PPUSH
34442: CALL_OW 110
34446: PUSH
34447: LD_INT 0
34449: EQUAL
34450: IFFALSE 34469
// MCH_ChangeClass ( side , i , 2 ) ;
34452: LD_VAR 0 1
34456: PPUSH
34457: LD_VAR 0 4
34461: PPUSH
34462: LD_INT 2
34464: PPUSH
34465: CALL 15874 0 3
34469: GO 34434
34471: POP
34472: POP
// end else
34473: GO 34794
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
34475: LD_VAR 0 13
34479: PUSH
34480: LD_EXP 51
34484: PUSH
34485: LD_VAR 0 1
34489: ARRAY
34490: PLUS
34491: PUSH
34492: LD_INT 22
34494: PUSH
34495: LD_VAR 0 1
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 30
34506: PUSH
34507: LD_INT 32
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PPUSH
34518: CALL_OW 69
34522: LESS
34523: IFFALSE 34548
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
34525: LD_VAR 0 1
34529: PPUSH
34530: LD_VAR 0 14
34534: PUSH
34535: LD_INT 1
34537: ARRAY
34538: PPUSH
34539: LD_INT 1
34541: PPUSH
34542: CALL 15874 0 3
// end else
34546: GO 34794
// if sci < 6 and MCF_Lab ( side ) then
34548: LD_VAR 0 16
34552: PUSH
34553: LD_INT 6
34555: LESS
34556: PUSH
34557: LD_VAR 0 1
34561: PPUSH
34562: CALL 11006 0 1
34566: AND
34567: IFFALSE 34672
// begin if MREG_ToBunker [ side ] then
34569: LD_EXP 63
34573: PUSH
34574: LD_VAR 0 1
34578: ARRAY
34579: IFFALSE 34605
// tmp := sol diff MREG_ToBunker [ side ] else
34581: LD_ADDR_VAR 0 12
34585: PUSH
34586: LD_VAR 0 13
34590: PUSH
34591: LD_EXP 63
34595: PUSH
34596: LD_VAR 0 1
34600: ARRAY
34601: DIFF
34602: ST_TO_ADDR
34603: GO 34615
// tmp := sol ;
34605: LD_ADDR_VAR 0 12
34609: PUSH
34610: LD_VAR 0 13
34614: ST_TO_ADDR
// if tmp then
34615: LD_VAR 0 12
34619: IFFALSE 34670
// for i in tmp do
34621: LD_ADDR_VAR 0 4
34625: PUSH
34626: LD_VAR 0 12
34630: PUSH
34631: FOR_IN
34632: IFFALSE 34668
// if GetTag ( i ) = 0 then
34634: LD_VAR 0 4
34638: PPUSH
34639: CALL_OW 110
34643: PUSH
34644: LD_INT 0
34646: EQUAL
34647: IFFALSE 34666
// MCH_ChangeClass ( side , i , 4 ) ;
34649: LD_VAR 0 1
34653: PPUSH
34654: LD_VAR 0 4
34658: PPUSH
34659: LD_INT 4
34661: PPUSH
34662: CALL 15874 0 3
34666: GO 34631
34668: POP
34669: POP
// end else
34670: GO 34794
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
34672: LD_VAR 0 1
34676: PPUSH
34677: LD_INT 30
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PPUSH
34687: CALL 10967 0 2
34691: IFFALSE 34794
// begin if MREG_ToBunker [ side ] then
34693: LD_EXP 63
34697: PUSH
34698: LD_VAR 0 1
34702: ARRAY
34703: IFFALSE 34729
// tmp := sol diff MREG_ToBunker [ side ] else
34705: LD_ADDR_VAR 0 12
34709: PUSH
34710: LD_VAR 0 13
34714: PUSH
34715: LD_EXP 63
34719: PUSH
34720: LD_VAR 0 1
34724: ARRAY
34725: DIFF
34726: ST_TO_ADDR
34727: GO 34739
// tmp := sol ;
34729: LD_ADDR_VAR 0 12
34733: PUSH
34734: LD_VAR 0 13
34738: ST_TO_ADDR
// if tmp then
34739: LD_VAR 0 12
34743: IFFALSE 34794
// for i in tmp do
34745: LD_ADDR_VAR 0 4
34749: PUSH
34750: LD_VAR 0 12
34754: PUSH
34755: FOR_IN
34756: IFFALSE 34792
// if GetTag ( i ) = 0 then
34758: LD_VAR 0 4
34762: PPUSH
34763: CALL_OW 110
34767: PUSH
34768: LD_INT 0
34770: EQUAL
34771: IFFALSE 34790
// MCH_ChangeClass ( side , i , 2 ) ;
34773: LD_VAR 0 1
34777: PPUSH
34778: LD_VAR 0 4
34782: PPUSH
34783: LD_INT 2
34785: PPUSH
34786: CALL 15874 0 3
34790: GO 34755
34792: POP
34793: POP
// end ; if MCF_Lab ( side ) then
34794: LD_VAR 0 1
34798: PPUSH
34799: CALL 11006 0 1
34803: IFFALSE 35343
// begin if MCL_GetTechList ( side ) then
34805: LD_VAR 0 1
34809: PPUSH
34810: CALL 17350 0 1
34814: IFFALSE 34940
// begin if MREG_ToLab [ side ] then
34816: LD_EXP 49
34820: PUSH
34821: LD_VAR 0 1
34825: ARRAY
34826: IFFALSE 34846
// k := MREG_ToLab [ side ] else
34828: LD_ADDR_VAR 0 8
34832: PUSH
34833: LD_EXP 49
34837: PUSH
34838: LD_VAR 0 1
34842: ARRAY
34843: ST_TO_ADDR
34844: GO 34854
// k := 0 ;
34846: LD_ADDR_VAR 0 8
34850: PUSH
34851: LD_INT 0
34853: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
34854: LD_VAR 0 16
34858: PUSH
34859: LD_VAR 0 8
34863: PLUS
34864: PUSH
34865: LD_INT 6
34867: LESSEQUAL
34868: PUSH
34869: LD_VAR 0 17
34873: PUSH
34874: LD_INT 6
34876: GREATER
34877: AND
34878: IFFALSE 34894
// MCH_TrainScientist ( side , 1 ) else
34880: LD_VAR 0 1
34884: PPUSH
34885: LD_INT 1
34887: PPUSH
34888: CALL 15426 0 2
34892: GO 34938
// if all < 6 then
34894: LD_VAR 0 17
34898: PUSH
34899: LD_INT 6
34901: LESS
34902: IFFALSE 34938
// if sci + k < all / 2 then
34904: LD_VAR 0 16
34908: PUSH
34909: LD_VAR 0 8
34913: PLUS
34914: PUSH
34915: LD_VAR 0 17
34919: PUSH
34920: LD_INT 2
34922: DIVREAL
34923: LESS
34924: IFFALSE 34938
// MCH_TrainScientist ( side , 1 ) ;
34926: LD_VAR 0 1
34930: PPUSH
34931: LD_INT 1
34933: PPUSH
34934: CALL 15426 0 2
// end else
34938: GO 35016
// begin if sci > 2 then
34940: LD_VAR 0 16
34944: PUSH
34945: LD_INT 2
34947: GREATER
34948: IFFALSE 35016
// for i = sci downto 2 do
34950: LD_ADDR_VAR 0 4
34954: PUSH
34955: DOUBLE
34956: LD_VAR 0 16
34960: INC
34961: ST_TO_ADDR
34962: LD_INT 2
34964: PUSH
34965: FOR_DOWNTO
34966: IFFALSE 35014
// if GetTag ( sci [ i ] ) = 0 then
34968: LD_VAR 0 16
34972: PUSH
34973: LD_VAR 0 4
34977: ARRAY
34978: PPUSH
34979: CALL_OW 110
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: IFFALSE 35012
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
34989: LD_VAR 0 1
34993: PPUSH
34994: LD_VAR 0 16
34998: PUSH
34999: LD_VAR 0 4
35003: ARRAY
35004: PPUSH
35005: LD_INT 2
35007: PPUSH
35008: CALL 15874 0 3
35012: GO 34965
35014: POP
35015: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
35016: LD_VAR 0 1
35020: PPUSH
35021: CALL 17350 0 1
35025: PUSH
35026: LD_VAR 0 1
35030: PPUSH
35031: CALL 11006 0 1
35035: AND
35036: PUSH
35037: LD_EXP 30
35041: PUSH
35042: LD_VAR 0 1
35046: ARRAY
35047: NOT
35048: AND
35049: IFFALSE 35343
// begin for j = 1 to MCF_Lab ( side ) do
35051: LD_ADDR_VAR 0 5
35055: PUSH
35056: DOUBLE
35057: LD_INT 1
35059: DEC
35060: ST_TO_ADDR
35061: LD_VAR 0 1
35065: PPUSH
35066: CALL 11006 0 1
35070: PUSH
35071: FOR_TO
35072: IFFALSE 35132
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
35074: LD_VAR 0 1
35078: PPUSH
35079: CALL 11006 0 1
35083: PUSH
35084: LD_VAR 0 5
35088: ARRAY
35089: PPUSH
35090: CALL_OW 461
35094: PUSH
35095: LD_INT 3
35097: PUSH
35098: LD_INT 6
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: IN
35105: IFFALSE 35130
// begin b := MCF_Lab ( side ) [ j ] ;
35107: LD_ADDR_VAR 0 11
35111: PUSH
35112: LD_VAR 0 1
35116: PPUSH
35117: CALL 11006 0 1
35121: PUSH
35122: LD_VAR 0 5
35126: ARRAY
35127: ST_TO_ADDR
// break ;
35128: GO 35132
// end ;
35130: GO 35071
35132: POP
35133: POP
// if MCF_Class ( side , 4 , [ ] ) then
35134: LD_VAR 0 1
35138: PPUSH
35139: LD_INT 4
35141: PPUSH
35142: EMPTY
35143: PPUSH
35144: CALL 11050 0 3
35148: IFFALSE 35343
// for j in MCF_Class ( side , 4 , [ ] ) do
35150: LD_ADDR_VAR 0 5
35154: PUSH
35155: LD_VAR 0 1
35159: PPUSH
35160: LD_INT 4
35162: PPUSH
35163: EMPTY
35164: PPUSH
35165: CALL 11050 0 3
35169: PUSH
35170: FOR_IN
35171: IFFALSE 35341
// begin if GetTag ( j ) = 0 then
35173: LD_VAR 0 5
35177: PPUSH
35178: CALL_OW 110
35182: PUSH
35183: LD_INT 0
35185: EQUAL
35186: IFFALSE 35277
// begin if IsInUnit ( j ) and b then
35188: LD_VAR 0 5
35192: PPUSH
35193: CALL_OW 310
35197: PUSH
35198: LD_VAR 0 11
35202: AND
35203: IFFALSE 35251
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
35205: LD_VAR 0 5
35209: PPUSH
35210: CALL_OW 310
35214: PPUSH
35215: CALL_OW 461
35219: PUSH
35220: LD_INT 2
35222: EQUAL
35223: PUSH
35224: LD_VAR 0 5
35228: PPUSH
35229: CALL_OW 310
35233: PUSH
35234: LD_VAR 0 11
35238: NONEQUAL
35239: AND
35240: IFFALSE 35251
// ComExitBuilding ( j ) ;
35242: LD_VAR 0 5
35246: PPUSH
35247: CALL_OW 122
// if not IsInUnit ( j ) then
35251: LD_VAR 0 5
35255: PPUSH
35256: CALL_OW 310
35260: NOT
35261: IFFALSE 35277
// ComEnterUnit ( j , b ) ;
35263: LD_VAR 0 5
35267: PPUSH
35268: LD_VAR 0 11
35272: PPUSH
35273: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
35277: LD_INT 1
35279: PPUSH
35280: LD_VAR 0 5
35284: PPUSH
35285: CALL_OW 255
35289: PPUSH
35290: CALL_OW 321
35294: PUSH
35295: LD_INT 2
35297: EQUAL
35298: PUSH
35299: LD_VAR 0 5
35303: PPUSH
35304: CALL_OW 255
35308: PPUSH
35309: CALL 24364 0 1
35313: PUSH
35314: LD_INT 0
35316: EQUAL
35317: AND
35318: IFFALSE 35339
// MCN_Tame ( GetSide ( j ) , j ) ;
35320: LD_VAR 0 5
35324: PPUSH
35325: CALL_OW 255
35329: PPUSH
35330: LD_VAR 0 5
35334: PPUSH
35335: CALL 17869 0 2
// end ;
35339: GO 35170
35341: POP
35342: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
35343: LD_VAR 0 1
35347: PPUSH
35348: LD_INT 30
35350: PUSH
35351: LD_INT 3
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PPUSH
35358: CALL 10967 0 2
35362: IFFALSE 35621
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
35364: LD_ADDR_VAR 0 11
35368: PUSH
35369: LD_VAR 0 1
35373: PPUSH
35374: LD_INT 30
35376: PUSH
35377: LD_INT 3
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PPUSH
35384: CALL 10967 0 2
35388: PUSH
35389: LD_INT 1
35391: ARRAY
35392: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
35393: LD_ADDR_VAR 0 12
35397: PUSH
35398: LD_VAR 0 1
35402: PPUSH
35403: LD_INT 0
35405: PPUSH
35406: LD_INT 25
35408: PUSH
35409: LD_INT 3
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PPUSH
35416: CALL 11670 0 3
35420: ST_TO_ADDR
// for i = 1 to tmp do
35421: LD_ADDR_VAR 0 4
35425: PUSH
35426: DOUBLE
35427: LD_INT 1
35429: DEC
35430: ST_TO_ADDR
35431: LD_VAR 0 12
35435: PUSH
35436: FOR_TO
35437: IFFALSE 35497
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
35439: LD_VAR 0 12
35443: PUSH
35444: LD_VAR 0 4
35448: ARRAY
35449: PPUSH
35450: CALL_OW 310
35454: NOT
35455: PUSH
35456: LD_VAR 0 12
35460: PUSH
35461: LD_VAR 0 4
35465: ARRAY
35466: PPUSH
35467: CALL_OW 314
35471: NOT
35472: AND
35473: IFFALSE 35495
// ComEnterUnit ( tmp [ i ] , b ) ;
35475: LD_VAR 0 12
35479: PUSH
35480: LD_VAR 0 4
35484: ARRAY
35485: PPUSH
35486: LD_VAR 0 11
35490: PPUSH
35491: CALL_OW 120
35495: GO 35436
35497: POP
35498: POP
// if MREG_ToFac [ side ] then
35499: LD_EXP 50
35503: PUSH
35504: LD_VAR 0 1
35508: ARRAY
35509: IFFALSE 35529
// k := MREG_ToFac [ side ] else
35511: LD_ADDR_VAR 0 8
35515: PUSH
35516: LD_EXP 50
35520: PUSH
35521: LD_VAR 0 1
35525: ARRAY
35526: ST_TO_ADDR
35527: GO 35537
// k := 0 ;
35529: LD_ADDR_VAR 0 8
35533: PUSH
35534: LD_INT 0
35536: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
35537: LD_VAR 0 15
35541: PUSH
35542: LD_VAR 0 8
35546: PLUS
35547: PUSH
35548: LD_INT 6
35550: LESSEQUAL
35551: PUSH
35552: LD_VAR 0 17
35556: PUSH
35557: LD_INT 6
35559: GREATER
35560: AND
35561: IFFALSE 35577
// MCH_TrainMechanic ( side , 1 ) else
35563: LD_VAR 0 1
35567: PPUSH
35568: LD_INT 1
35570: PPUSH
35571: CALL 15168 0 2
35575: GO 35621
// if all < 6 then
35577: LD_VAR 0 17
35581: PUSH
35582: LD_INT 6
35584: LESS
35585: IFFALSE 35621
// if mech + k < all / 2 then
35587: LD_VAR 0 15
35591: PUSH
35592: LD_VAR 0 8
35596: PLUS
35597: PUSH
35598: LD_VAR 0 17
35602: PUSH
35603: LD_INT 2
35605: DIVREAL
35606: LESS
35607: IFFALSE 35621
// MCH_TrainMechanic ( side , 1 ) ;
35609: LD_VAR 0 1
35613: PPUSH
35614: LD_INT 1
35616: PPUSH
35617: CALL 15168 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
35621: LD_ADDR_VAR 0 10
35625: PUSH
35626: LD_VAR 0 1
35630: PPUSH
35631: LD_INT 30
35633: PUSH
35634: LD_INT 36
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PPUSH
35641: CALL 10967 0 2
35645: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
35646: LD_VAR 0 10
35650: PUSH
35651: LD_VAR 0 15
35655: AND
35656: PUSH
35657: LD_VAR 0 1
35661: PPUSH
35662: LD_INT 3
35664: PPUSH
35665: EMPTY
35666: PPUSH
35667: CALL 11050 0 3
35671: AND
35672: IFFALSE 35830
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
35674: LD_VAR 0 1
35678: PPUSH
35679: LD_INT 9
35681: PPUSH
35682: EMPTY
35683: PPUSH
35684: CALL 11670 0 3
35688: PUSH
35689: LD_INT 3
35691: LESS
35692: IFFALSE 35830
// begin if mech < 3 then
35694: LD_VAR 0 15
35698: PUSH
35699: LD_INT 3
35701: LESS
35702: IFFALSE 35716
// k := mech else
35704: LD_ADDR_VAR 0 8
35708: PUSH
35709: LD_VAR 0 15
35713: ST_TO_ADDR
35714: GO 35724
// k := 3 ;
35716: LD_ADDR_VAR 0 8
35720: PUSH
35721: LD_INT 3
35723: ST_TO_ADDR
// for j = 1 to k do
35724: LD_ADDR_VAR 0 5
35728: PUSH
35729: DOUBLE
35730: LD_INT 1
35732: DEC
35733: ST_TO_ADDR
35734: LD_VAR 0 8
35738: PUSH
35739: FOR_TO
35740: IFFALSE 35798
// if GetClass ( mech [ j ] ) = 3 then
35742: LD_VAR 0 15
35746: PUSH
35747: LD_VAR 0 5
35751: ARRAY
35752: PPUSH
35753: CALL_OW 257
35757: PUSH
35758: LD_INT 3
35760: EQUAL
35761: IFFALSE 35796
// begin SetTag ( mech [ j ] , 9 ) ;
35763: LD_VAR 0 15
35767: PUSH
35768: LD_VAR 0 5
35772: ARRAY
35773: PPUSH
35774: LD_INT 9
35776: PPUSH
35777: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
35781: LD_VAR 0 15
35785: PUSH
35786: LD_VAR 0 5
35790: ARRAY
35791: PPUSH
35792: CALL_OW 122
// end ;
35796: GO 35739
35798: POP
35799: POP
// if mech < 6 + k then
35800: LD_VAR 0 15
35804: PUSH
35805: LD_INT 6
35807: PUSH
35808: LD_VAR 0 8
35812: PLUS
35813: LESS
35814: IFFALSE 35830
// MCH_TrainMechanic ( side , k ) ;
35816: LD_VAR 0 1
35820: PPUSH
35821: LD_VAR 0 8
35825: PPUSH
35826: CALL 15168 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
35830: LD_VAR 0 1
35834: PPUSH
35835: LD_INT 9
35837: PPUSH
35838: EMPTY
35839: PPUSH
35840: CALL 11670 0 3
35844: IFFALSE 35923
// for j in MCF_Tag ( side , 9 , [ ] ) do
35846: LD_ADDR_VAR 0 5
35850: PUSH
35851: LD_VAR 0 1
35855: PPUSH
35856: LD_INT 9
35858: PPUSH
35859: EMPTY
35860: PPUSH
35861: CALL 11670 0 3
35865: PUSH
35866: FOR_IN
35867: IFFALSE 35921
// if not IsInUnit ( j ) then
35869: LD_VAR 0 5
35873: PPUSH
35874: CALL_OW 310
35878: NOT
35879: IFFALSE 35919
// if ct then
35881: LD_VAR 0 10
35885: IFFALSE 35907
// ComEnterUnit ( j , ct [ 1 ] ) else
35887: LD_VAR 0 5
35891: PPUSH
35892: LD_VAR 0 10
35896: PUSH
35897: LD_INT 1
35899: ARRAY
35900: PPUSH
35901: CALL_OW 120
35905: GO 35919
// SetTag ( j , 0 ) ;
35907: LD_VAR 0 5
35911: PPUSH
35912: LD_INT 0
35914: PPUSH
35915: CALL_OW 109
35919: GO 35866
35921: POP
35922: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
35923: LD_INT 1
35925: PPUSH
35926: LD_VAR 0 1
35930: PPUSH
35931: CALL_OW 321
35935: PUSH
35936: LD_INT 2
35938: EQUAL
35939: PUSH
35940: LD_EXP 30
35944: PUSH
35945: LD_VAR 0 1
35949: ARRAY
35950: NOT
35951: AND
35952: PUSH
35953: LD_VAR 0 1
35957: PPUSH
35958: LD_INT 4
35960: PPUSH
35961: EMPTY
35962: PPUSH
35963: CALL 11050 0 3
35967: AND
35968: IFFALSE 36016
// for j in MCF_Class ( side , 4 , [ ] ) do
35970: LD_ADDR_VAR 0 5
35974: PUSH
35975: LD_VAR 0 1
35979: PPUSH
35980: LD_INT 4
35982: PPUSH
35983: EMPTY
35984: PPUSH
35985: CALL 11050 0 3
35989: PUSH
35990: FOR_IN
35991: IFFALSE 36014
// MCN_Tame ( GetSide ( j ) , j ) ;
35993: LD_VAR 0 5
35997: PPUSH
35998: CALL_OW 255
36002: PPUSH
36003: LD_VAR 0 5
36007: PPUSH
36008: CALL 17869 0 2
36012: GO 35990
36014: POP
36015: POP
// if MREG_DefVeh [ side ] then
36016: LD_EXP 62
36020: PUSH
36021: LD_VAR 0 1
36025: ARRAY
36026: IFFALSE 36190
// begin for i in MREG_DefVeh [ side ] do
36028: LD_ADDR_VAR 0 4
36032: PUSH
36033: LD_EXP 62
36037: PUSH
36038: LD_VAR 0 1
36042: ARRAY
36043: PUSH
36044: FOR_IN
36045: IFFALSE 36098
// begin SetTag ( i , 0 ) ;
36047: LD_VAR 0 4
36051: PPUSH
36052: LD_INT 0
36054: PPUSH
36055: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
36059: LD_VAR 0 4
36063: PPUSH
36064: LD_EXP 59
36068: PUSH
36069: LD_VAR 0 1
36073: ARRAY
36074: PPUSH
36075: CALL_OW 308
36079: NOT
36080: IFFALSE 36096
// MCV_Parking ( side , i ) ;
36082: LD_VAR 0 1
36086: PPUSH
36087: LD_VAR 0 4
36091: PPUSH
36092: CALL 25124 0 2
// end ;
36096: GO 36044
36098: POP
36099: POP
// if MCF_Tag ( side , 36 , [ ] ) then
36100: LD_VAR 0 1
36104: PPUSH
36105: LD_INT 36
36107: PPUSH
36108: EMPTY
36109: PPUSH
36110: CALL 11670 0 3
36114: IFFALSE 36155
// for i in MCF_Tag ( side , 36 , [ ] ) do
36116: LD_ADDR_VAR 0 4
36120: PUSH
36121: LD_VAR 0 1
36125: PPUSH
36126: LD_INT 36
36128: PPUSH
36129: EMPTY
36130: PPUSH
36131: CALL 11670 0 3
36135: PUSH
36136: FOR_IN
36137: IFFALSE 36153
// SetTag ( i , 0 ) ;
36139: LD_VAR 0 4
36143: PPUSH
36144: LD_INT 0
36146: PPUSH
36147: CALL_OW 109
36151: GO 36136
36153: POP
36154: POP
// if MREG_DefMobActive [ side ] then
36155: LD_EXP 65
36159: PUSH
36160: LD_VAR 0 1
36164: ARRAY
36165: IFFALSE 36190
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
36167: LD_ADDR_EXP 65
36171: PUSH
36172: LD_EXP 65
36176: PPUSH
36177: LD_VAR 0 1
36181: PPUSH
36182: LD_INT 0
36184: PPUSH
36185: CALL_OW 1
36189: ST_TO_ADDR
// end ; end ; if mode > 0 then
36190: LD_VAR 0 2
36194: PUSH
36195: LD_INT 0
36197: GREATER
36198: IFFALSE 38224
// begin if tick <= 15 15$00 then
36200: LD_OWVAR 1
36204: PUSH
36205: LD_INT 31500
36207: LESSEQUAL
36208: IFFALSE 36632
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
36210: LD_VAR 0 13
36214: PUSH
36215: LD_INT 4
36217: GREATER
36218: PUSH
36219: LD_VAR 0 1
36223: PPUSH
36224: CALL 24364 0 1
36228: PUSH
36229: LD_INT 4
36231: LESS
36232: AND
36233: IFFALSE 36344
// for i in sol do
36235: LD_ADDR_VAR 0 4
36239: PUSH
36240: LD_VAR 0 13
36244: PUSH
36245: FOR_IN
36246: IFFALSE 36342
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
36248: LD_ADDR_VAR 0 8
36252: PUSH
36253: LD_VAR 0 1
36257: PPUSH
36258: CALL 24364 0 1
36262: PPUSH
36263: LD_VAR 0 4
36267: PPUSH
36268: CALL_OW 74
36272: ST_TO_ADDR
// if IsInUnit ( i ) then
36273: LD_VAR 0 4
36277: PPUSH
36278: CALL_OW 310
36282: IFFALSE 36293
// ComExitBuilding ( i ) ;
36284: LD_VAR 0 4
36288: PPUSH
36289: CALL_OW 122
// if not HasTask ( i ) and k then
36293: LD_VAR 0 4
36297: PPUSH
36298: CALL_OW 314
36302: NOT
36303: PUSH
36304: LD_VAR 0 8
36308: AND
36309: IFFALSE 36340
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
36311: LD_VAR 0 4
36315: PPUSH
36316: LD_VAR 0 8
36320: PPUSH
36321: CALL_OW 250
36325: PPUSH
36326: LD_VAR 0 8
36330: PPUSH
36331: CALL_OW 251
36335: PPUSH
36336: CALL_OW 114
// end ;
36340: GO 36245
36342: POP
36343: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
36344: LD_VAR 0 1
36348: PPUSH
36349: LD_INT 30
36351: PUSH
36352: LD_INT 5
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PPUSH
36359: CALL 10967 0 2
36363: IFFALSE 36630
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
36365: LD_ADDR_VAR 0 11
36369: PUSH
36370: LD_VAR 0 1
36374: PPUSH
36375: LD_INT 30
36377: PUSH
36378: LD_INT 5
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PPUSH
36385: CALL 10967 0 2
36389: PUSH
36390: LD_INT 1
36392: ARRAY
36393: ST_TO_ADDR
// if mech then
36394: LD_VAR 0 15
36398: IFFALSE 36434
// for i in mech do
36400: LD_ADDR_VAR 0 4
36404: PUSH
36405: LD_VAR 0 15
36409: PUSH
36410: FOR_IN
36411: IFFALSE 36432
// MCH_ChangeClass ( side , i , 1 ) ;
36413: LD_VAR 0 1
36417: PPUSH
36418: LD_VAR 0 4
36422: PPUSH
36423: LD_INT 1
36425: PPUSH
36426: CALL 15874 0 3
36430: GO 36410
36432: POP
36433: POP
// if eng > 1 then
36434: LD_VAR 0 14
36438: PUSH
36439: LD_INT 1
36441: GREATER
36442: IFFALSE 36489
// for i = eng downto 2 do
36444: LD_ADDR_VAR 0 4
36448: PUSH
36449: DOUBLE
36450: LD_VAR 0 14
36454: INC
36455: ST_TO_ADDR
36456: LD_INT 2
36458: PUSH
36459: FOR_DOWNTO
36460: IFFALSE 36487
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
36462: LD_VAR 0 1
36466: PPUSH
36467: LD_VAR 0 14
36471: PUSH
36472: LD_VAR 0 4
36476: ARRAY
36477: PPUSH
36478: LD_INT 1
36480: PPUSH
36481: CALL 15874 0 3
36485: GO 36459
36487: POP
36488: POP
// if UnitsInside ( b ) = 6 then
36489: LD_VAR 0 11
36493: PPUSH
36494: CALL_OW 313
36498: PUSH
36499: LD_INT 6
36501: EQUAL
36502: IFFALSE 36630
// begin un := UnitsInside ( b ) [ 1 ] ;
36504: LD_ADDR_VAR 0 9
36508: PUSH
36509: LD_VAR 0 11
36513: PPUSH
36514: CALL_OW 313
36518: PUSH
36519: LD_INT 1
36521: ARRAY
36522: ST_TO_ADDR
// ComExitBuilding ( un ) ;
36523: LD_VAR 0 9
36527: PPUSH
36528: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
36532: LD_VAR 0 1
36536: PPUSH
36537: LD_INT 30
36539: PUSH
36540: LD_INT 5
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PPUSH
36547: CALL 10967 0 2
36551: PUSH
36552: LD_INT 1
36554: GREATER
36555: PUSH
36556: LD_VAR 0 1
36560: PPUSH
36561: CALL 24364 0 1
36565: PUSH
36566: LD_INT 4
36568: GREATEREQUAL
36569: AND
36570: IFFALSE 36630
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
36572: LD_ADDR_VAR 0 8
36576: PUSH
36577: LD_VAR 0 1
36581: PPUSH
36582: LD_INT 30
36584: PUSH
36585: LD_INT 5
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PPUSH
36592: CALL 10967 0 2
36596: PUSH
36597: LD_INT 2
36599: ARRAY
36600: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
36601: LD_VAR 0 8
36605: PPUSH
36606: CALL_OW 313
36610: PUSH
36611: LD_INT 6
36613: LESS
36614: IFFALSE 36630
// AddComEnterUnit ( un , k ) ;
36616: LD_VAR 0 9
36620: PPUSH
36621: LD_VAR 0 8
36625: PPUSH
36626: CALL_OW 180
// end ; end ; end ; end else
36630: GO 38224
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
36632: LD_VAR 0 1
36636: PPUSH
36637: LD_INT 1
36639: PPUSH
36640: LD_EXP 60
36644: PUSH
36645: LD_VAR 0 1
36649: ARRAY
36650: PUSH
36651: LD_INT 1
36653: ARRAY
36654: PPUSH
36655: CALL 31554 0 3
36659: IFFALSE 36798
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
36661: LD_ADDR_VAR 0 12
36665: PUSH
36666: LD_VAR 0 1
36670: PPUSH
36671: LD_INT 21
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PPUSH
36681: CALL 10967 0 2
36685: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
36686: LD_ADDR_VAR 0 11
36690: PUSH
36691: LD_VAR 0 1
36695: PPUSH
36696: LD_INT 30
36698: PUSH
36699: LD_INT 1
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PPUSH
36706: CALL 10967 0 2
36710: ST_TO_ADDR
// if b then
36711: LD_VAR 0 11
36715: IFFALSE 36798
// for i in tmp do
36717: LD_ADDR_VAR 0 4
36721: PUSH
36722: LD_VAR 0 12
36726: PUSH
36727: FOR_IN
36728: IFFALSE 36796
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
36730: LD_VAR 0 4
36734: PPUSH
36735: LD_EXP 60
36739: PUSH
36740: LD_VAR 0 1
36744: ARRAY
36745: PUSH
36746: LD_INT 1
36748: ARRAY
36749: PPUSH
36750: CALL_OW 308
36754: NOT
36755: IFFALSE 36794
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
36757: LD_VAR 0 4
36761: PPUSH
36762: LD_VAR 0 11
36766: PUSH
36767: LD_INT 1
36769: ARRAY
36770: PPUSH
36771: CALL_OW 250
36775: PPUSH
36776: LD_VAR 0 11
36780: PUSH
36781: LD_INT 1
36783: ARRAY
36784: PPUSH
36785: CALL_OW 251
36789: PPUSH
36790: CALL_OW 111
36794: GO 36727
36796: POP
36797: POP
// end ; if MREG_DefVeh [ side ] then
36798: LD_EXP 62
36802: PUSH
36803: LD_VAR 0 1
36807: ARRAY
36808: IFFALSE 37387
// begin tmp := [ ] ;
36810: LD_ADDR_VAR 0 12
36814: PUSH
36815: EMPTY
36816: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
36817: LD_EXP 65
36821: PUSH
36822: LD_VAR 0 1
36826: ARRAY
36827: PUSH
36828: LD_INT 0
36830: EQUAL
36831: IFFALSE 36971
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
36833: LD_ADDR_VAR 0 8
36837: PUSH
36838: LD_VAR 0 1
36842: PPUSH
36843: LD_INT 0
36845: PPUSH
36846: LD_INT 25
36848: PUSH
36849: LD_INT 3
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PPUSH
36856: CALL 11670 0 3
36860: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
36861: LD_VAR 0 8
36865: PUSH
36866: LD_EXP 62
36870: PUSH
36871: LD_VAR 0 1
36875: ARRAY
36876: GREATER
36877: IFFALSE 36938
// begin for i = 1 to MREG_DefVeh [ side ] do
36879: LD_ADDR_VAR 0 4
36883: PUSH
36884: DOUBLE
36885: LD_INT 1
36887: DEC
36888: ST_TO_ADDR
36889: LD_EXP 62
36893: PUSH
36894: LD_VAR 0 1
36898: ARRAY
36899: PUSH
36900: FOR_TO
36901: IFFALSE 36934
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
36903: LD_ADDR_VAR 0 12
36907: PUSH
36908: LD_VAR 0 12
36912: PPUSH
36913: LD_INT 1
36915: PPUSH
36916: LD_VAR 0 8
36920: PUSH
36921: LD_VAR 0 4
36925: ARRAY
36926: PPUSH
36927: CALL_OW 2
36931: ST_TO_ADDR
36932: GO 36900
36934: POP
36935: POP
// end else
36936: GO 36948
// tmp := k ;
36938: LD_ADDR_VAR 0 12
36942: PUSH
36943: LD_VAR 0 8
36947: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
36948: LD_ADDR_EXP 65
36952: PUSH
36953: LD_EXP 65
36957: PPUSH
36958: LD_VAR 0 1
36962: PPUSH
36963: LD_INT 1
36965: PPUSH
36966: CALL_OW 1
36970: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
36971: LD_ADDR_VAR 0 4
36975: PUSH
36976: LD_EXP 62
36980: PUSH
36981: LD_VAR 0 1
36985: ARRAY
36986: PUSH
36987: FOR_IN
36988: IFFALSE 37385
// begin if not GetDriver ( i ) then
36990: LD_VAR 0 4
36994: PPUSH
36995: CALL 30475 0 1
36999: NOT
37000: IFFALSE 37075
// begin if tmp then
37002: LD_VAR 0 12
37006: IFFALSE 37073
// begin ComExitBuilding ( tmp [ 1 ] ) ;
37008: LD_VAR 0 12
37012: PUSH
37013: LD_INT 1
37015: ARRAY
37016: PPUSH
37017: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
37021: LD_VAR 0 12
37025: PUSH
37026: LD_INT 1
37028: ARRAY
37029: PPUSH
37030: LD_VAR 0 4
37034: PPUSH
37035: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
37039: LD_VAR 0 12
37043: PUSH
37044: LD_INT 1
37046: ARRAY
37047: PPUSH
37048: LD_INT 36
37050: PPUSH
37051: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
37055: LD_ADDR_VAR 0 12
37059: PUSH
37060: LD_VAR 0 12
37064: PPUSH
37065: LD_INT 1
37067: PPUSH
37068: CALL_OW 3
37072: ST_TO_ADDR
// end ; end else
37073: GO 37383
// begin if GetTag ( i ) = 0 then
37075: LD_VAR 0 4
37079: PPUSH
37080: CALL_OW 110
37084: PUSH
37085: LD_INT 0
37087: EQUAL
37088: IFFALSE 37104
// SetTag ( i , 31 ) else
37090: LD_VAR 0 4
37094: PPUSH
37095: LD_INT 31
37097: PPUSH
37098: CALL_OW 109
37102: GO 37383
// if GetTag ( i ) = 31 then
37104: LD_VAR 0 4
37108: PPUSH
37109: CALL_OW 110
37113: PUSH
37114: LD_INT 31
37116: EQUAL
37117: IFFALSE 37383
// begin if GetFuel ( i ) < 20 then
37119: LD_VAR 0 4
37123: PPUSH
37124: CALL_OW 261
37128: PUSH
37129: LD_INT 20
37131: LESS
37132: IFFALSE 37168
// begin SetTag ( i , 21 ) ;
37134: LD_VAR 0 4
37138: PPUSH
37139: LD_INT 21
37141: PPUSH
37142: CALL_OW 109
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
37146: LD_VAR 0 4
37150: PPUSH
37151: LD_EXP 53
37155: PUSH
37156: LD_VAR 0 1
37160: ARRAY
37161: PPUSH
37162: CALL_OW 113
// continue ;
37166: GO 36987
// end ; if GetLives ( i ) < 700 then
37168: LD_VAR 0 4
37172: PPUSH
37173: CALL_OW 256
37177: PUSH
37178: LD_INT 700
37180: LESS
37181: IFFALSE 37293
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
37183: LD_VAR 0 4
37187: PPUSH
37188: LD_EXP 53
37192: PUSH
37193: LD_VAR 0 1
37197: ARRAY
37198: PPUSH
37199: CALL_OW 308
37203: NOT
37204: IFFALSE 37228
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
37206: LD_VAR 0 4
37210: PPUSH
37211: LD_EXP 53
37215: PUSH
37216: LD_VAR 0 1
37220: ARRAY
37221: PPUSH
37222: CALL_OW 113
37226: GO 37291
// if GetDriver ( i ) then
37228: LD_VAR 0 4
37232: PPUSH
37233: CALL 30475 0 1
37237: IFFALSE 37291
// begin k := GetDriver ( i ) ;
37239: LD_ADDR_VAR 0 8
37243: PUSH
37244: LD_VAR 0 4
37248: PPUSH
37249: CALL 30475 0 1
37253: ST_TO_ADDR
// ComExitVehicle ( k ) ;
37254: LD_VAR 0 8
37258: PPUSH
37259: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
37263: LD_VAR 0 8
37267: PPUSH
37268: LD_VAR 0 4
37272: PPUSH
37273: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
37277: LD_VAR 0 8
37281: PPUSH
37282: LD_VAR 0 4
37286: PPUSH
37287: CALL_OW 180
// end ; end else
37291: GO 37383
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
37293: LD_ADDR_VAR 0 8
37297: PUSH
37298: LD_VAR 0 1
37302: PPUSH
37303: CALL 24364 0 1
37307: PPUSH
37308: LD_VAR 0 4
37312: PPUSH
37313: CALL_OW 74
37317: ST_TO_ADDR
// if k then
37318: LD_VAR 0 8
37322: IFFALSE 37340
// ComAttackUnit ( i , k ) else
37324: LD_VAR 0 4
37328: PPUSH
37329: LD_VAR 0 8
37333: PPUSH
37334: CALL_OW 115
37338: GO 37383
// if not IsInArea ( i , MREG_Parking [ side ] ) then
37340: LD_VAR 0 4
37344: PPUSH
37345: LD_EXP 53
37349: PUSH
37350: LD_VAR 0 1
37354: ARRAY
37355: PPUSH
37356: CALL_OW 308
37360: NOT
37361: IFFALSE 37383
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
37363: LD_VAR 0 4
37367: PPUSH
37368: LD_EXP 53
37372: PUSH
37373: LD_VAR 0 1
37377: ARRAY
37378: PPUSH
37379: CALL_OW 113
// end ; end ; end ; end ;
37383: GO 36987
37385: POP
37386: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
37387: LD_VAR 0 1
37391: PPUSH
37392: LD_INT 30
37394: PUSH
37395: LD_INT 5
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PPUSH
37402: CALL 10967 0 2
37406: IFFALSE 38224
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
37408: LD_ADDR_VAR 0 11
37412: PUSH
37413: LD_VAR 0 1
37417: PPUSH
37418: LD_INT 30
37420: PUSH
37421: LD_INT 5
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PPUSH
37428: CALL 10967 0 2
37432: PUSH
37433: LD_INT 1
37435: ARRAY
37436: ST_TO_ADDR
// if eng > 1 then
37437: LD_VAR 0 14
37441: PUSH
37442: LD_INT 1
37444: GREATER
37445: IFFALSE 37492
// for i = eng downto 2 do
37447: LD_ADDR_VAR 0 4
37451: PUSH
37452: DOUBLE
37453: LD_VAR 0 14
37457: INC
37458: ST_TO_ADDR
37459: LD_INT 2
37461: PUSH
37462: FOR_DOWNTO
37463: IFFALSE 37490
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
37465: LD_VAR 0 1
37469: PPUSH
37470: LD_VAR 0 14
37474: PUSH
37475: LD_VAR 0 4
37479: ARRAY
37480: PPUSH
37481: LD_INT 1
37483: PPUSH
37484: CALL 15874 0 3
37488: GO 37462
37490: POP
37491: POP
// if sci > 1 then
37492: LD_VAR 0 16
37496: PUSH
37497: LD_INT 1
37499: GREATER
37500: IFFALSE 37547
// for i = sci downto 2 do
37502: LD_ADDR_VAR 0 4
37506: PUSH
37507: DOUBLE
37508: LD_VAR 0 16
37512: INC
37513: ST_TO_ADDR
37514: LD_INT 2
37516: PUSH
37517: FOR_DOWNTO
37518: IFFALSE 37545
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
37520: LD_VAR 0 1
37524: PPUSH
37525: LD_VAR 0 16
37529: PUSH
37530: LD_VAR 0 4
37534: ARRAY
37535: PPUSH
37536: LD_INT 1
37538: PPUSH
37539: CALL 15874 0 3
37543: GO 37517
37545: POP
37546: POP
// if sol then
37547: LD_VAR 0 13
37551: IFFALSE 38224
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
37553: LD_VAR 0 13
37557: PUSH
37558: LD_EXP 63
37562: PUSH
37563: LD_VAR 0 1
37567: ARRAY
37568: DIFF
37569: PUSH
37570: LD_INT 22
37572: PUSH
37573: LD_VAR 0 1
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 58
37584: PUSH
37585: EMPTY
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: LD_INT 30
37593: PUSH
37594: LD_INT 32
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 30
37603: PUSH
37604: LD_INT 31
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: EMPTY
37612: LIST
37613: LIST
37614: LIST
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: LIST
37620: PPUSH
37621: CALL_OW 69
37625: PUSH
37626: LD_INT 0
37628: EQUAL
37629: AND
37630: IFFALSE 38224
// begin tmp := sol diff MREG_ToBunker [ side ] ;
37632: LD_ADDR_VAR 0 12
37636: PUSH
37637: LD_VAR 0 13
37641: PUSH
37642: LD_EXP 63
37646: PUSH
37647: LD_VAR 0 1
37651: ARRAY
37652: DIFF
37653: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
37654: LD_VAR 0 1
37658: PPUSH
37659: LD_INT 30
37661: PUSH
37662: LD_INT 5
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PPUSH
37669: CALL 10967 0 2
37673: PUSH
37674: LD_INT 1
37676: GREATER
37677: IFFALSE 37708
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
37679: LD_ADDR_VAR 0 8
37683: PUSH
37684: LD_VAR 0 1
37688: PPUSH
37689: LD_INT 30
37691: PUSH
37692: LD_INT 5
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PPUSH
37699: CALL 10967 0 2
37703: PUSH
37704: LD_INT 2
37706: ARRAY
37707: ST_TO_ADDR
// for j in tmp do
37708: LD_ADDR_VAR 0 5
37712: PUSH
37713: LD_VAR 0 12
37717: PUSH
37718: FOR_IN
37719: IFFALSE 38222
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
37721: LD_VAR 0 5
37725: PUSH
37726: LD_VAR 0 11
37730: PPUSH
37731: CALL_OW 313
37735: IN
37736: PUSH
37737: LD_VAR 0 11
37741: PPUSH
37742: CALL_OW 313
37746: PUSH
37747: LD_INT 6
37749: EQUAL
37750: AND
37751: PUSH
37752: LD_VAR 0 8
37756: AND
37757: PUSH
37758: LD_VAR 0 8
37762: PPUSH
37763: CALL_OW 313
37767: PUSH
37768: LD_INT 6
37770: LESS
37771: AND
37772: IFFALSE 37799
// begin ComExitBuilding ( j ) ;
37774: LD_VAR 0 5
37778: PPUSH
37779: CALL_OW 122
// AddComEnterunit ( j , k ) ;
37783: LD_VAR 0 5
37787: PPUSH
37788: LD_VAR 0 8
37792: PPUSH
37793: CALL_OW 180
// continue ;
37797: GO 37718
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
37799: LD_VAR 0 5
37803: PPUSH
37804: CALL_OW 314
37808: NOT
37809: PUSH
37810: LD_VAR 0 5
37814: PPUSH
37815: CALL_OW 110
37819: PUSH
37820: LD_INT 0
37822: EQUAL
37823: AND
37824: PUSH
37825: LD_VAR 0 5
37829: PPUSH
37830: CALL_OW 310
37834: NOT
37835: AND
37836: IFFALSE 37942
// begin if k then
37838: LD_VAR 0 8
37842: IFFALSE 37913
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
37844: LD_VAR 0 8
37848: PPUSH
37849: CALL_OW 313
37853: PUSH
37854: LD_VAR 0 11
37858: PPUSH
37859: CALL_OW 313
37863: LESS
37864: IFFALSE 37882
// ComEnterUnit ( j , k ) else
37866: LD_VAR 0 5
37870: PPUSH
37871: LD_VAR 0 8
37875: PPUSH
37876: CALL_OW 120
37880: GO 37911
// if UnitsInside ( b ) < 6 then
37882: LD_VAR 0 11
37886: PPUSH
37887: CALL_OW 313
37891: PUSH
37892: LD_INT 6
37894: LESS
37895: IFFALSE 37911
// ComEnterUnit ( j , b ) ;
37897: LD_VAR 0 5
37901: PPUSH
37902: LD_VAR 0 11
37906: PPUSH
37907: CALL_OW 120
// end else
37911: GO 37942
// if UnitsInside ( b ) < 6 then
37913: LD_VAR 0 11
37917: PPUSH
37918: CALL_OW 313
37922: PUSH
37923: LD_INT 6
37925: LESS
37926: IFFALSE 37942
// ComEnterUnit ( j , b ) ;
37928: LD_VAR 0 5
37932: PPUSH
37933: LD_VAR 0 11
37937: PPUSH
37938: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
37942: LD_VAR 0 5
37946: PUSH
37947: LD_VAR 0 1
37951: PPUSH
37952: LD_INT 54
37954: PUSH
37955: EMPTY
37956: LIST
37957: PPUSH
37958: CALL 10967 0 2
37962: IN
37963: PUSH
37964: LD_VAR 0 5
37968: PPUSH
37969: CALL_OW 257
37973: PUSH
37974: LD_INT 1
37976: EQUAL
37977: AND
37978: IFFALSE 38220
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
37980: LD_EXP 57
37984: PUSH
37985: LD_VAR 0 1
37989: ARRAY
37990: PUSH
37991: LD_INT 1
37993: ARRAY
37994: PUSH
37995: LD_INT 12
37997: PPUSH
37998: LD_VAR 0 1
38002: PPUSH
38003: CALL_OW 321
38007: PUSH
38008: LD_INT 2
38010: EQUAL
38011: AND
38012: IFFALSE 38060
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
38014: LD_VAR 0 1
38018: PPUSH
38019: LD_INT 5
38021: PPUSH
38022: EMPTY
38023: PPUSH
38024: CALL 11050 0 3
38028: PUSH
38029: LD_EXP 57
38033: PUSH
38034: LD_VAR 0 1
38038: ARRAY
38039: PUSH
38040: LD_INT 1
38042: ARRAY
38043: LESS
38044: IFFALSE 38060
// begin SetClass ( j , class_sniper ) ;
38046: LD_VAR 0 5
38050: PPUSH
38051: LD_INT 5
38053: PPUSH
38054: CALL_OW 336
// continue ;
38058: GO 37718
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
38060: LD_EXP 57
38064: PUSH
38065: LD_VAR 0 1
38069: ARRAY
38070: PUSH
38071: LD_INT 2
38073: ARRAY
38074: PUSH
38075: LD_INT 41
38077: PPUSH
38078: LD_VAR 0 1
38082: PPUSH
38083: CALL_OW 321
38087: PUSH
38088: LD_INT 2
38090: EQUAL
38091: AND
38092: IFFALSE 38140
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
38094: LD_VAR 0 1
38098: PPUSH
38099: LD_INT 8
38101: PPUSH
38102: EMPTY
38103: PPUSH
38104: CALL 11050 0 3
38108: PUSH
38109: LD_EXP 57
38113: PUSH
38114: LD_VAR 0 1
38118: ARRAY
38119: PUSH
38120: LD_INT 2
38122: ARRAY
38123: LESS
38124: IFFALSE 38140
// begin SetClass ( j , class_mortar ) ;
38126: LD_VAR 0 5
38130: PPUSH
38131: LD_INT 8
38133: PPUSH
38134: CALL_OW 336
// continue ;
38138: GO 37718
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
38140: LD_EXP 57
38144: PUSH
38145: LD_VAR 0 1
38149: ARRAY
38150: PUSH
38151: LD_INT 3
38153: ARRAY
38154: PUSH
38155: LD_INT 44
38157: PPUSH
38158: LD_VAR 0 1
38162: PPUSH
38163: CALL_OW 321
38167: PUSH
38168: LD_INT 2
38170: EQUAL
38171: AND
38172: IFFALSE 38220
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
38174: LD_VAR 0 1
38178: PPUSH
38179: LD_INT 9
38181: PPUSH
38182: EMPTY
38183: PPUSH
38184: CALL 11050 0 3
38188: PUSH
38189: LD_EXP 57
38193: PUSH
38194: LD_VAR 0 1
38198: ARRAY
38199: PUSH
38200: LD_INT 3
38202: ARRAY
38203: LESS
38204: IFFALSE 38220
// begin SetClass ( j , class_bazooker ) ;
38206: LD_VAR 0 5
38210: PPUSH
38211: LD_INT 9
38213: PPUSH
38214: CALL_OW 336
// continue ;
38218: GO 37718
// end ; end ; end ;
38220: GO 37718
38222: POP
38223: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
38224: LD_INT 22
38226: PUSH
38227: LD_VAR 0 1
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 58
38238: PUSH
38239: EMPTY
38240: LIST
38241: PUSH
38242: LD_INT 30
38244: PUSH
38245: LD_INT 32
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: LIST
38256: PPUSH
38257: CALL_OW 69
38261: IFFALSE 38411
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
38263: LD_ADDR_VAR 0 12
38267: PUSH
38268: LD_INT 22
38270: PUSH
38271: LD_VAR 0 1
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 58
38282: PUSH
38283: EMPTY
38284: LIST
38285: PUSH
38286: LD_INT 30
38288: PUSH
38289: LD_INT 32
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: LIST
38300: PPUSH
38301: CALL_OW 69
38305: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
38306: LD_ADDR_VAR 0 8
38310: PUSH
38311: LD_VAR 0 13
38315: PUSH
38316: LD_EXP 63
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: DIFF
38327: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
38328: LD_VAR 0 12
38332: PUSH
38333: LD_INT 1
38335: ARRAY
38336: PPUSH
38337: CALL_OW 461
38341: PUSH
38342: LD_INT 2
38344: EQUAL
38345: PUSH
38346: LD_VAR 0 12
38350: PUSH
38351: LD_INT 1
38353: ARRAY
38354: PUSH
38355: LD_EXP 63
38359: PUSH
38360: LD_VAR 0 1
38364: ARRAY
38365: IN
38366: NOT
38367: AND
38368: PUSH
38369: LD_VAR 0 8
38373: AND
38374: IFFALSE 38411
// begin ComExitBuilding ( k [ 1 ] ) ;
38376: LD_VAR 0 8
38380: PUSH
38381: LD_INT 1
38383: ARRAY
38384: PPUSH
38385: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
38389: LD_VAR 0 8
38393: PUSH
38394: LD_INT 1
38396: ARRAY
38397: PPUSH
38398: LD_VAR 0 12
38402: PUSH
38403: LD_INT 1
38405: ARRAY
38406: PPUSH
38407: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
38411: LD_EXP 30
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: IFFALSE 38569
// begin if MCF_Class ( side , 4 , [ ] ) then
38423: LD_VAR 0 1
38427: PPUSH
38428: LD_INT 4
38430: PPUSH
38431: EMPTY
38432: PPUSH
38433: CALL 11050 0 3
38437: IFFALSE 38567
// for j in MCF_Class ( side , 4 , [ ] ) do
38439: LD_ADDR_VAR 0 5
38443: PUSH
38444: LD_VAR 0 1
38448: PPUSH
38449: LD_INT 4
38451: PPUSH
38452: EMPTY
38453: PPUSH
38454: CALL 11050 0 3
38458: PUSH
38459: FOR_IN
38460: IFFALSE 38565
// begin if not GetTag ( j ) = 4 then
38462: LD_VAR 0 5
38466: PPUSH
38467: CALL_OW 110
38471: PUSH
38472: LD_INT 4
38474: EQUAL
38475: NOT
38476: IFFALSE 38512
// begin SetTag ( j , 4 ) ;
38478: LD_VAR 0 5
38482: PPUSH
38483: LD_INT 4
38485: PPUSH
38486: CALL_OW 109
// if IsInUnit ( j ) then
38490: LD_VAR 0 5
38494: PPUSH
38495: CALL_OW 310
38499: IFFALSE 38510
// ComExitBuilding ( j ) ;
38501: LD_VAR 0 5
38505: PPUSH
38506: CALL_OW 122
// end else
38510: GO 38563
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
38512: LD_VAR 0 5
38516: PPUSH
38517: LD_EXP 30
38521: PUSH
38522: LD_VAR 0 1
38526: ARRAY
38527: PUSH
38528: LD_INT 1
38530: ARRAY
38531: PPUSH
38532: CALL 31166 0 2
38536: NOT
38537: IFFALSE 38563
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
38539: LD_VAR 0 5
38543: PPUSH
38544: LD_EXP 30
38548: PUSH
38549: LD_VAR 0 1
38553: ARRAY
38554: PUSH
38555: LD_INT 1
38557: ARRAY
38558: PPUSH
38559: CALL 18537 0 2
// end ;
38563: GO 38459
38565: POP
38566: POP
// end else
38567: GO 38801
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
38569: LD_VAR 0 1
38573: PPUSH
38574: LD_INT 4
38576: PPUSH
38577: EMPTY
38578: PPUSH
38579: CALL 11050 0 3
38583: PUSH
38584: LD_VAR 0 1
38588: PPUSH
38589: LD_INT 4
38591: PPUSH
38592: EMPTY
38593: PPUSH
38594: CALL 11670 0 3
38598: AND
38599: IFFALSE 38801
// for j in MCF_Class ( side , 4 , [ ] ) do
38601: LD_ADDR_VAR 0 5
38605: PUSH
38606: LD_VAR 0 1
38610: PPUSH
38611: LD_INT 4
38613: PPUSH
38614: EMPTY
38615: PPUSH
38616: CALL 11050 0 3
38620: PUSH
38621: FOR_IN
38622: IFFALSE 38799
// begin if GetTag ( j ) = 4 then
38624: LD_VAR 0 5
38628: PPUSH
38629: CALL_OW 110
38633: PUSH
38634: LD_INT 4
38636: EQUAL
38637: IFFALSE 38797
// begin SetTag ( j , 0 ) ;
38639: LD_VAR 0 5
38643: PPUSH
38644: LD_INT 0
38646: PPUSH
38647: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
38651: LD_VAR 0 1
38655: PPUSH
38656: CALL 11006 0 1
38660: PUSH
38661: LD_VAR 0 1
38665: PPUSH
38666: CALL 17350 0 1
38670: NOT
38671: AND
38672: IFFALSE 38697
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
38674: LD_VAR 0 5
38678: PPUSH
38679: LD_VAR 0 1
38683: PPUSH
38684: CALL 11006 0 1
38688: PUSH
38689: LD_INT 1
38691: ARRAY
38692: PPUSH
38693: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
38697: LD_VAR 0 1
38701: PPUSH
38702: CALL 11006 0 1
38706: NOT
38707: PUSH
38708: LD_VAR 0 1
38712: PPUSH
38713: LD_INT 30
38715: PUSH
38716: LD_INT 1
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PPUSH
38723: CALL 10967 0 2
38727: AND
38728: IFFALSE 38797
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
38730: LD_VAR 0 5
38734: PPUSH
38735: LD_VAR 0 1
38739: PPUSH
38740: LD_INT 30
38742: PUSH
38743: LD_INT 1
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PPUSH
38750: CALL 10967 0 2
38754: PUSH
38755: LD_INT 1
38757: ARRAY
38758: PPUSH
38759: CALL_OW 250
38763: PPUSH
38764: LD_VAR 0 1
38768: PPUSH
38769: LD_INT 30
38771: PUSH
38772: LD_INT 1
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PPUSH
38779: CALL 10967 0 2
38783: PUSH
38784: LD_INT 1
38786: ARRAY
38787: PPUSH
38788: CALL_OW 251
38792: PPUSH
38793: CALL_OW 111
// end ; end ;
38797: GO 38621
38799: POP
38800: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
38801: LD_VAR 0 1
38805: PPUSH
38806: LD_INT 3
38808: PPUSH
38809: EMPTY
38810: PPUSH
38811: CALL 11050 0 3
38815: PUSH
38816: LD_EXP 53
38820: PUSH
38821: LD_VAR 0 1
38825: ARRAY
38826: AND
38827: PUSH
38828: LD_VAR 0 1
38832: PPUSH
38833: LD_INT 6
38835: PPUSH
38836: EMPTY
38837: PPUSH
38838: CALL 11670 0 3
38842: AND
38843: IFFALSE 39374
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
38845: LD_ADDR_VAR 0 6
38849: PUSH
38850: LD_EXP 53
38854: PUSH
38855: LD_VAR 0 1
38859: ARRAY
38860: PPUSH
38861: LD_INT 0
38863: PPUSH
38864: CALL_OW 517
38868: PUSH
38869: LD_INT 1
38871: ARRAY
38872: PUSH
38873: LD_INT 1
38875: ARRAY
38876: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
38877: LD_ADDR_VAR 0 7
38881: PUSH
38882: LD_EXP 53
38886: PUSH
38887: LD_VAR 0 1
38891: ARRAY
38892: PPUSH
38893: LD_INT 0
38895: PPUSH
38896: CALL_OW 517
38900: PUSH
38901: LD_INT 2
38903: ARRAY
38904: PUSH
38905: LD_INT 1
38907: ARRAY
38908: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
38909: LD_VAR 0 1
38913: PPUSH
38914: LD_INT 6
38916: PPUSH
38917: EMPTY
38918: PPUSH
38919: CALL 11670 0 3
38923: IFFALSE 39372
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
38925: LD_ADDR_VAR 0 8
38929: PUSH
38930: LD_VAR 0 1
38934: PPUSH
38935: LD_INT 6
38937: PPUSH
38938: EMPTY
38939: PPUSH
38940: CALL 11670 0 3
38944: PUSH
38945: FOR_IN
38946: IFFALSE 38977
// if GetLives ( k ) = 1000 then
38948: LD_VAR 0 8
38952: PPUSH
38953: CALL_OW 256
38957: PUSH
38958: LD_INT 1000
38960: EQUAL
38961: IFFALSE 38975
// SetTag ( k , 0 ) ;
38963: LD_VAR 0 8
38967: PPUSH
38968: LD_INT 0
38970: PPUSH
38971: CALL_OW 109
38975: GO 38945
38977: POP
38978: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
38979: LD_VAR 0 1
38983: PPUSH
38984: LD_INT 0
38986: PPUSH
38987: LD_INT 25
38989: PUSH
38990: LD_INT 3
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PPUSH
38997: CALL 11670 0 3
39001: IFFALSE 39065
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
39003: LD_ADDR_VAR 0 8
39007: PUSH
39008: LD_VAR 0 4
39012: PPUSH
39013: LD_INT 0
39015: PPUSH
39016: LD_INT 25
39018: PUSH
39019: LD_INT 3
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PPUSH
39026: CALL 11670 0 3
39030: PUSH
39031: FOR_IN
39032: IFFALSE 39063
// if GetTag ( k ) = 0 then
39034: LD_VAR 0 8
39038: PPUSH
39039: CALL_OW 110
39043: PUSH
39044: LD_INT 0
39046: EQUAL
39047: IFFALSE 39061
// begin SetTag ( k , 8 ) ;
39049: LD_VAR 0 8
39053: PPUSH
39054: LD_INT 8
39056: PPUSH
39057: CALL_OW 109
// end ;
39061: GO 39031
39063: POP
39064: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
39065: LD_VAR 0 1
39069: PPUSH
39070: LD_INT 6
39072: PPUSH
39073: LD_INT 92
39075: PUSH
39076: LD_VAR 0 6
39080: PUSH
39081: LD_VAR 0 7
39085: PUSH
39086: LD_INT 10
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: PPUSH
39095: CALL 11670 0 3
39099: IFFALSE 39223
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
39101: LD_ADDR_VAR 0 5
39105: PUSH
39106: LD_VAR 0 4
39110: PPUSH
39111: LD_INT 6
39113: PPUSH
39114: LD_INT 92
39116: PUSH
39117: LD_VAR 0 6
39121: PUSH
39122: LD_VAR 0 7
39126: PUSH
39127: LD_INT 10
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: LIST
39134: LIST
39135: PPUSH
39136: CALL 11670 0 3
39140: PUSH
39141: FOR_IN
39142: IFFALSE 39221
// begin if not HasTask ( j ) and GetDriver ( j ) then
39144: LD_VAR 0 5
39148: PPUSH
39149: CALL_OW 314
39153: NOT
39154: PUSH
39155: LD_VAR 0 5
39159: PPUSH
39160: CALL 30475 0 1
39164: AND
39165: IFFALSE 39219
// begin ComExitVehicle ( GetDriver ( j ) ) ;
39167: LD_VAR 0 5
39171: PPUSH
39172: CALL 30475 0 1
39176: PPUSH
39177: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
39181: LD_VAR 0 5
39185: PPUSH
39186: CALL 30475 0 1
39190: PPUSH
39191: LD_VAR 0 5
39195: PPUSH
39196: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
39200: LD_VAR 0 5
39204: PPUSH
39205: CALL 30475 0 1
39209: PPUSH
39210: LD_VAR 0 5
39214: PPUSH
39215: CALL_OW 180
// end ; end ;
39219: GO 39141
39221: POP
39222: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
39223: LD_VAR 0 1
39227: PPUSH
39228: LD_INT 6
39230: PPUSH
39231: LD_INT 92
39233: PUSH
39234: LD_VAR 0 6
39238: PUSH
39239: LD_VAR 0 7
39243: PUSH
39244: LD_INT 10
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: PPUSH
39253: CALL 11670 0 3
39257: PUSH
39258: LD_VAR 0 1
39262: PPUSH
39263: LD_INT 8
39265: PPUSH
39266: EMPTY
39267: PPUSH
39268: CALL 11670 0 3
39272: AND
39273: IFFALSE 39372
// for j in MCF_Tag ( side , 8 , [ ] ) do
39275: LD_ADDR_VAR 0 5
39279: PUSH
39280: LD_VAR 0 1
39284: PPUSH
39285: LD_INT 8
39287: PPUSH
39288: EMPTY
39289: PPUSH
39290: CALL 11670 0 3
39294: PUSH
39295: FOR_IN
39296: IFFALSE 39370
// begin if IsInUnit ( j ) then
39298: LD_VAR 0 5
39302: PPUSH
39303: CALL_OW 310
39307: IFFALSE 39320
// ComExitBuilding ( j ) else
39309: LD_VAR 0 5
39313: PPUSH
39314: CALL_OW 122
39318: GO 39368
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
39320: LD_VAR 0 5
39324: PPUSH
39325: LD_VAR 0 1
39329: PPUSH
39330: LD_INT 6
39332: PPUSH
39333: LD_INT 92
39335: PUSH
39336: LD_VAR 0 6
39340: PUSH
39341: LD_VAR 0 7
39345: PUSH
39346: LD_INT 10
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: PPUSH
39355: CALL 11670 0 3
39359: PUSH
39360: LD_INT 1
39362: ARRAY
39363: PPUSH
39364: CALL_OW 129
// end ;
39368: GO 39295
39370: POP
39371: POP
// end ; end else
39372: GO 39429
// if MCF_Tag ( side , 8 , [ ] ) then
39374: LD_VAR 0 1
39378: PPUSH
39379: LD_INT 8
39381: PPUSH
39382: EMPTY
39383: PPUSH
39384: CALL 11670 0 3
39388: IFFALSE 39429
// for k in MCF_Tag ( side , 8 , [ ] ) do
39390: LD_ADDR_VAR 0 8
39394: PUSH
39395: LD_VAR 0 1
39399: PPUSH
39400: LD_INT 8
39402: PPUSH
39403: EMPTY
39404: PPUSH
39405: CALL 11670 0 3
39409: PUSH
39410: FOR_IN
39411: IFFALSE 39427
// SetTag ( k , 0 ) ;
39413: LD_VAR 0 8
39417: PPUSH
39418: LD_INT 0
39420: PPUSH
39421: CALL_OW 109
39425: GO 39410
39427: POP
39428: POP
// end ; end_of_file
39429: LD_VAR 0 3
39433: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
39434: LD_INT 0
39436: PPUSH
// MREG_Game := [ ] ;
39437: LD_ADDR_EXP 28
39441: PUSH
39442: EMPTY
39443: ST_TO_ADDR
// MREG_Crates := [ ] ;
39444: LD_ADDR_EXP 29
39448: PUSH
39449: EMPTY
39450: ST_TO_ADDR
// MREG_Heal := [ ] ;
39451: LD_ADDR_EXP 30
39455: PUSH
39456: EMPTY
39457: ST_TO_ADDR
// MREG_Tame := [ ] ;
39458: LD_ADDR_EXP 32
39462: PUSH
39463: EMPTY
39464: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
39465: LD_ADDR_EXP 33
39469: PUSH
39470: EMPTY
39471: ST_TO_ADDR
// MREG_SidesList := [ ] ;
39472: LD_ADDR_EXP 34
39476: PUSH
39477: EMPTY
39478: ST_TO_ADDR
// MREG_LabList := [ ] ;
39479: LD_ADDR_EXP 35
39483: PUSH
39484: EMPTY
39485: ST_TO_ADDR
// MREG_Cargo := [ ] ;
39486: LD_ADDR_EXP 36
39490: PUSH
39491: EMPTY
39492: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
39493: LD_ADDR_EXP 37
39497: PUSH
39498: EMPTY
39499: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
39500: LD_ADDR_EXP 38
39504: PUSH
39505: EMPTY
39506: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
39507: LD_ADDR_EXP 39
39511: PUSH
39512: EMPTY
39513: ST_TO_ADDR
// MREG_Status := [ ] ;
39514: LD_ADDR_EXP 40
39518: PUSH
39519: EMPTY
39520: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
39521: LD_ADDR_EXP 41
39525: PUSH
39526: EMPTY
39527: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
39528: LD_ADDR_EXP 42
39532: PUSH
39533: EMPTY
39534: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
39535: LD_ADDR_EXP 43
39539: PUSH
39540: EMPTY
39541: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
39542: LD_ADDR_EXP 44
39546: PUSH
39547: EMPTY
39548: ST_TO_ADDR
// MREG_ToRes := [ ] ;
39549: LD_ADDR_EXP 45
39553: PUSH
39554: EMPTY
39555: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
39556: LD_ADDR_EXP 46
39560: PUSH
39561: EMPTY
39562: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
39563: LD_ADDR_EXP 47
39567: PUSH
39568: EMPTY
39569: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
39570: LD_ADDR_EXP 48
39574: PUSH
39575: EMPTY
39576: ST_TO_ADDR
// MREG_ToLab := [ ] ;
39577: LD_ADDR_EXP 49
39581: PUSH
39582: EMPTY
39583: ST_TO_ADDR
// MREG_ToFac := [ ] ;
39584: LD_ADDR_EXP 50
39588: PUSH
39589: EMPTY
39590: ST_TO_ADDR
// MREG_ToArm := [ ] ;
39591: LD_ADDR_EXP 51
39595: PUSH
39596: EMPTY
39597: ST_TO_ADDR
// MREG_ToDep := [ ] ;
39598: LD_ADDR_EXP 52
39602: PUSH
39603: EMPTY
39604: ST_TO_ADDR
// MREG_Deposit := [ ] ;
39605: LD_ADDR_EXP 56
39609: PUSH
39610: EMPTY
39611: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
39612: LD_ADDR_EXP 57
39616: PUSH
39617: EMPTY
39618: ST_TO_ADDR
// MREG_Parking := [ ] ;
39619: LD_ADDR_EXP 53
39623: PUSH
39624: EMPTY
39625: ST_TO_ADDR
// MREG_VCombat := [ ] ;
39626: LD_ADDR_EXP 54
39630: PUSH
39631: EMPTY
39632: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
39633: LD_ADDR_EXP 58
39637: PUSH
39638: EMPTY
39639: ST_TO_ADDR
// MREG_DefArea := [ ] ;
39640: LD_ADDR_EXP 59
39644: PUSH
39645: EMPTY
39646: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
39647: LD_ADDR_EXP 60
39651: PUSH
39652: EMPTY
39653: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
39654: LD_ADDR_EXP 62
39658: PUSH
39659: EMPTY
39660: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
39661: LD_ADDR_EXP 63
39665: PUSH
39666: EMPTY
39667: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
39668: LD_ADDR_EXP 64
39672: PUSH
39673: EMPTY
39674: ST_TO_ADDR
// MREG_Attackers := [ ] ;
39675: LD_ADDR_EXP 66
39679: PUSH
39680: EMPTY
39681: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
39682: LD_ADDR_EXP 65
39686: PUSH
39687: EMPTY
39688: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
39689: LD_ADDR_EXP 67
39693: PUSH
39694: LD_INT 300
39696: PUSH
39697: LD_INT 100
39699: PUSH
39700: LD_INT 25
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: LIST
39707: ST_TO_ADDR
// end ;
39708: LD_VAR 0 1
39712: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
39713: LD_INT 0
39715: PPUSH
// if [ side , unit , mreg ] in mreg_list then
39716: LD_VAR 0 2
39720: PUSH
39721: LD_VAR 0 3
39725: PUSH
39726: LD_VAR 0 4
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: LIST
39735: PUSH
39736: LD_VAR 0 1
39740: IN
39741: IFFALSE 39755
// result := mreg_list else
39743: LD_ADDR_VAR 0 5
39747: PUSH
39748: LD_VAR 0 1
39752: ST_TO_ADDR
39753: GO 39789
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
39755: LD_ADDR_VAR 0 1
39759: PUSH
39760: LD_VAR 0 1
39764: PUSH
39765: LD_VAR 0 2
39769: PUSH
39770: LD_VAR 0 3
39774: PUSH
39775: LD_VAR 0 4
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: ADD
39788: ST_TO_ADDR
// result := mreg_list ;
39789: LD_ADDR_VAR 0 5
39793: PUSH
39794: LD_VAR 0 1
39798: ST_TO_ADDR
// end ;
39799: LD_VAR 0 5
39803: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
39804: LD_INT 0
39806: PPUSH
// if [ side , unit , mreg ] in mreg_list then
39807: LD_VAR 0 2
39811: PUSH
39812: LD_VAR 0 3
39816: PUSH
39817: LD_VAR 0 4
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: LIST
39826: PUSH
39827: LD_VAR 0 1
39831: IN
39832: IFFALSE 39870
// result := mreg_list diff [ [ side , unit , mreg ] ] else
39834: LD_ADDR_VAR 0 5
39838: PUSH
39839: LD_VAR 0 1
39843: PUSH
39844: LD_VAR 0 2
39848: PUSH
39849: LD_VAR 0 3
39853: PUSH
39854: LD_VAR 0 4
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: LIST
39863: PUSH
39864: EMPTY
39865: LIST
39866: DIFF
39867: ST_TO_ADDR
39868: GO 39880
// result := mreg_list ;
39870: LD_ADDR_VAR 0 5
39874: PUSH
39875: LD_VAR 0 1
39879: ST_TO_ADDR
// end ;
39880: LD_VAR 0 5
39884: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
39885: LD_INT 0
39887: PPUSH
39888: PPUSH
39889: PPUSH
// for j = 1 to 8 do
39890: LD_ADDR_VAR 0 3
39894: PUSH
39895: DOUBLE
39896: LD_INT 1
39898: DEC
39899: ST_TO_ADDR
39900: LD_INT 8
39902: PUSH
39903: FOR_TO
39904: IFFALSE 40745
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
39906: LD_VAR 0 3
39910: PPUSH
39911: LD_INT 51
39913: PUSH
39914: EMPTY
39915: LIST
39916: PPUSH
39917: CALL 10967 0 2
39921: PUSH
39922: LD_OWVAR 2
39926: PUSH
39927: LD_VAR 0 3
39931: EQUAL
39932: NOT
39933: AND
39934: IFFALSE 39952
// MREG_SidesList := MREG_SidesList ^ 1 else
39936: LD_ADDR_EXP 34
39940: PUSH
39941: LD_EXP 34
39945: PUSH
39946: LD_INT 1
39948: ADD
39949: ST_TO_ADDR
39950: GO 39966
// MREG_SidesList := MREG_SidesList ^ 0 ;
39952: LD_ADDR_EXP 34
39956: PUSH
39957: LD_EXP 34
39961: PUSH
39962: LD_INT 0
39964: ADD
39965: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
39966: LD_VAR 0 3
39970: PPUSH
39971: LD_INT 2
39973: PUSH
39974: LD_INT 34
39976: PUSH
39977: LD_INT 12
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 34
39986: PUSH
39987: LD_INT 32
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 34
39996: PUSH
39997: LD_INT 51
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: PUSH
40010: EMPTY
40011: LIST
40012: PPUSH
40013: CALL 11268 0 2
40017: IFFALSE 40118
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
40019: LD_ADDR_VAR 0 2
40023: PUSH
40024: LD_VAR 0 3
40028: PPUSH
40029: LD_INT 2
40031: PUSH
40032: LD_INT 34
40034: PUSH
40035: LD_INT 12
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 34
40044: PUSH
40045: LD_INT 32
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 34
40054: PUSH
40055: LD_INT 51
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: LIST
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PPUSH
40071: CALL 11268 0 2
40075: PUSH
40076: FOR_IN
40077: IFFALSE 40116
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
40079: LD_ADDR_EXP 36
40083: PUSH
40084: LD_EXP 36
40088: PPUSH
40089: LD_VAR 0 3
40093: PPUSH
40094: LD_VAR 0 2
40098: PPUSH
40099: LD_VAR 0 2
40103: PPUSH
40104: CALL_OW 264
40108: PPUSH
40109: CALL 39713 0 4
40113: ST_TO_ADDR
40114: GO 40076
40116: POP
40117: POP
// if MCF_Class ( j , 4 , [ ] ) then
40118: LD_VAR 0 3
40122: PPUSH
40123: LD_INT 4
40125: PPUSH
40126: EMPTY
40127: PPUSH
40128: CALL 11050 0 3
40132: IFFALSE 40165
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
40134: LD_ADDR_EXP 49
40138: PUSH
40139: LD_EXP 49
40143: PUSH
40144: LD_VAR 0 3
40148: PPUSH
40149: LD_INT 4
40151: PPUSH
40152: EMPTY
40153: PPUSH
40154: CALL 11050 0 3
40158: PUSH
40159: EMPTY
40160: LIST
40161: ADD
40162: ST_TO_ADDR
40163: GO 40182
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
40165: LD_ADDR_EXP 49
40169: PUSH
40170: LD_EXP 49
40174: PUSH
40175: LD_INT 0
40177: PUSH
40178: EMPTY
40179: LIST
40180: ADD
40181: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
40182: LD_VAR 0 3
40186: PPUSH
40187: LD_INT 3
40189: PPUSH
40190: EMPTY
40191: PPUSH
40192: CALL 11050 0 3
40196: IFFALSE 40229
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
40198: LD_ADDR_EXP 50
40202: PUSH
40203: LD_EXP 50
40207: PUSH
40208: LD_VAR 0 3
40212: PPUSH
40213: LD_INT 3
40215: PPUSH
40216: EMPTY
40217: PPUSH
40218: CALL 11050 0 3
40222: PUSH
40223: EMPTY
40224: LIST
40225: ADD
40226: ST_TO_ADDR
40227: GO 40246
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
40229: LD_ADDR_EXP 50
40233: PUSH
40234: LD_EXP 50
40238: PUSH
40239: LD_INT 0
40241: PUSH
40242: EMPTY
40243: LIST
40244: ADD
40245: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
40246: LD_VAR 0 3
40250: PPUSH
40251: LD_INT 1
40253: PPUSH
40254: EMPTY
40255: PPUSH
40256: CALL 11050 0 3
40260: IFFALSE 40293
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
40262: LD_ADDR_EXP 51
40266: PUSH
40267: LD_EXP 51
40271: PUSH
40272: LD_VAR 0 3
40276: PPUSH
40277: LD_INT 1
40279: PPUSH
40280: EMPTY
40281: PPUSH
40282: CALL 11050 0 3
40286: PUSH
40287: EMPTY
40288: LIST
40289: ADD
40290: ST_TO_ADDR
40291: GO 40310
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
40293: LD_ADDR_EXP 51
40297: PUSH
40298: LD_EXP 51
40302: PUSH
40303: LD_INT 0
40305: PUSH
40306: EMPTY
40307: LIST
40308: ADD
40309: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
40310: LD_VAR 0 3
40314: PPUSH
40315: LD_INT 2
40317: PPUSH
40318: EMPTY
40319: PPUSH
40320: CALL 11050 0 3
40324: IFFALSE 40357
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
40326: LD_ADDR_EXP 52
40330: PUSH
40331: LD_EXP 52
40335: PUSH
40336: LD_VAR 0 3
40340: PPUSH
40341: LD_INT 2
40343: PPUSH
40344: EMPTY
40345: PPUSH
40346: CALL 11050 0 3
40350: PUSH
40351: EMPTY
40352: LIST
40353: ADD
40354: ST_TO_ADDR
40355: GO 40374
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
40357: LD_ADDR_EXP 52
40361: PUSH
40362: LD_EXP 52
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: ADD
40373: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
40374: LD_ADDR_EXP 42
40378: PUSH
40379: LD_EXP 42
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: EMPTY
40388: LIST
40389: ADD
40390: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
40391: LD_ADDR_EXP 30
40395: PUSH
40396: LD_EXP 30
40400: PUSH
40401: LD_INT 0
40403: PUSH
40404: EMPTY
40405: LIST
40406: ADD
40407: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
40408: LD_ADDR_EXP 32
40412: PUSH
40413: LD_EXP 32
40417: PUSH
40418: LD_INT 0
40420: PUSH
40421: EMPTY
40422: LIST
40423: ADD
40424: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
40425: LD_ADDR_EXP 53
40429: PUSH
40430: LD_EXP 53
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: ADD
40441: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
40442: LD_ADDR_EXP 54
40446: PUSH
40447: LD_EXP 54
40451: PUSH
40452: LD_INT 0
40454: PUSH
40455: EMPTY
40456: LIST
40457: ADD
40458: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
40459: LD_ADDR_EXP 46
40463: PUSH
40464: LD_EXP 46
40468: PUSH
40469: LD_INT 0
40471: PUSH
40472: EMPTY
40473: LIST
40474: ADD
40475: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
40476: LD_ADDR_EXP 33
40480: PUSH
40481: LD_EXP 33
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: LD_INT 0
40491: PUSH
40492: LD_INT 0
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: PUSH
40504: EMPTY
40505: LIST
40506: ADD
40507: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
40508: LD_ADDR_EXP 55
40512: PUSH
40513: LD_EXP 55
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: EMPTY
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: EMPTY
40528: LIST
40529: ADD
40530: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
40531: LD_ADDR_EXP 56
40535: PUSH
40536: LD_EXP 56
40540: PUSH
40541: LD_INT 0
40543: PUSH
40544: EMPTY
40545: LIST
40546: PUSH
40547: EMPTY
40548: LIST
40549: ADD
40550: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
40551: LD_ADDR_EXP 37
40555: PUSH
40556: LD_EXP 37
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: EMPTY
40565: LIST
40566: ADD
40567: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
40568: LD_ADDR_EXP 58
40572: PUSH
40573: LD_EXP 58
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: ADD
40584: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
40585: LD_ADDR_EXP 59
40589: PUSH
40590: LD_EXP 59
40594: PUSH
40595: LD_INT 0
40597: PUSH
40598: EMPTY
40599: LIST
40600: ADD
40601: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
40602: LD_ADDR_EXP 60
40606: PUSH
40607: LD_EXP 60
40611: PUSH
40612: LD_INT 0
40614: PUSH
40615: EMPTY
40616: LIST
40617: ADD
40618: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
40619: LD_ADDR_EXP 61
40623: PUSH
40624: LD_EXP 61
40628: PUSH
40629: LD_INT 0
40631: PUSH
40632: EMPTY
40633: LIST
40634: ADD
40635: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
40636: LD_ADDR_EXP 62
40640: PUSH
40641: LD_EXP 62
40645: PUSH
40646: LD_INT 0
40648: PUSH
40649: EMPTY
40650: LIST
40651: ADD
40652: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
40653: LD_ADDR_EXP 63
40657: PUSH
40658: LD_EXP 63
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: EMPTY
40667: LIST
40668: ADD
40669: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
40670: LD_ADDR_EXP 64
40674: PUSH
40675: LD_EXP 64
40679: PUSH
40680: LD_INT 0
40682: PUSH
40683: EMPTY
40684: LIST
40685: ADD
40686: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
40687: LD_ADDR_EXP 66
40691: PUSH
40692: LD_EXP 66
40696: PUSH
40697: LD_INT 0
40699: PUSH
40700: EMPTY
40701: LIST
40702: ADD
40703: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
40704: LD_ADDR_EXP 65
40708: PUSH
40709: LD_EXP 65
40713: PUSH
40714: LD_INT 0
40716: ADD
40717: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
40718: LD_ADDR_EXP 57
40722: PUSH
40723: LD_EXP 57
40727: PUSH
40728: LD_INT 0
40730: PUSH
40731: LD_INT 0
40733: PUSH
40734: LD_INT 0
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: LIST
40741: ADD
40742: ST_TO_ADDR
// end ;
40743: GO 39903
40745: POP
40746: POP
// end ;
40747: LD_VAR 0 1
40751: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
40752: LD_INT 0
40754: PPUSH
40755: PPUSH
40756: PPUSH
// m := false ;
40757: LD_ADDR_VAR 0 5
40761: PUSH
40762: LD_INT 0
40764: ST_TO_ADDR
// for i = 1 to mreg do
40765: LD_ADDR_VAR 0 4
40769: PUSH
40770: DOUBLE
40771: LD_INT 1
40773: DEC
40774: ST_TO_ADDR
40775: LD_VAR 0 2
40779: PUSH
40780: FOR_TO
40781: IFFALSE 40817
// if mreg [ i ] [ 1 ] = side then
40783: LD_VAR 0 2
40787: PUSH
40788: LD_VAR 0 4
40792: ARRAY
40793: PUSH
40794: LD_INT 1
40796: ARRAY
40797: PUSH
40798: LD_VAR 0 1
40802: EQUAL
40803: IFFALSE 40815
// begin m := true ;
40805: LD_ADDR_VAR 0 5
40809: PUSH
40810: LD_INT 1
40812: ST_TO_ADDR
// break ;
40813: GO 40817
// end ;
40815: GO 40780
40817: POP
40818: POP
// result := m ;
40819: LD_ADDR_VAR 0 3
40823: PUSH
40824: LD_VAR 0 5
40828: ST_TO_ADDR
// end ;
40829: LD_VAR 0 3
40833: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
40834: LD_INT 0
40836: PPUSH
40837: PPUSH
40838: PPUSH
// m := 0 ;
40839: LD_ADDR_VAR 0 5
40843: PUSH
40844: LD_INT 0
40846: ST_TO_ADDR
// for i = 1 to mreg do
40847: LD_ADDR_VAR 0 4
40851: PUSH
40852: DOUBLE
40853: LD_INT 1
40855: DEC
40856: ST_TO_ADDR
40857: LD_VAR 0 2
40861: PUSH
40862: FOR_TO
40863: IFFALSE 40903
// if mreg [ i ] [ 1 ] = side then
40865: LD_VAR 0 2
40869: PUSH
40870: LD_VAR 0 4
40874: ARRAY
40875: PUSH
40876: LD_INT 1
40878: ARRAY
40879: PUSH
40880: LD_VAR 0 1
40884: EQUAL
40885: IFFALSE 40901
// begin m := m + 1 ;
40887: LD_ADDR_VAR 0 5
40891: PUSH
40892: LD_VAR 0 5
40896: PUSH
40897: LD_INT 1
40899: PLUS
40900: ST_TO_ADDR
// end ;
40901: GO 40862
40903: POP
40904: POP
// result := m ;
40905: LD_ADDR_VAR 0 3
40909: PUSH
40910: LD_VAR 0 5
40914: ST_TO_ADDR
// end ;
40915: LD_VAR 0 3
40919: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
40920: LD_INT 0
40922: PPUSH
40923: PPUSH
// result := 0 ;
40924: LD_ADDR_VAR 0 3
40928: PUSH
40929: LD_INT 0
40931: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
40932: LD_ADDR_VAR 0 4
40936: PUSH
40937: DOUBLE
40938: LD_INT 1
40940: DEC
40941: ST_TO_ADDR
40942: LD_EXP 48
40946: PUSH
40947: FOR_TO
40948: IFFALSE 41010
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
40950: LD_EXP 48
40954: PUSH
40955: LD_VAR 0 4
40959: ARRAY
40960: PUSH
40961: LD_INT 1
40963: ARRAY
40964: PUSH
40965: LD_VAR 0 1
40969: EQUAL
40970: PUSH
40971: LD_EXP 48
40975: PUSH
40976: LD_VAR 0 4
40980: ARRAY
40981: PUSH
40982: LD_INT 2
40984: ARRAY
40985: PUSH
40986: LD_VAR 0 2
40990: EQUAL
40991: AND
40992: IFFALSE 41008
// begin result := result + 1 ;
40994: LD_ADDR_VAR 0 3
40998: PUSH
40999: LD_VAR 0 3
41003: PUSH
41004: LD_INT 1
41006: PLUS
41007: ST_TO_ADDR
// end ;
41008: GO 40947
41010: POP
41011: POP
// end ;
41012: LD_VAR 0 3
41016: RET
