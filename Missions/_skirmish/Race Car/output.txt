// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 200 , 148 ) ;
   4: LD_INT 200
   6: PPUSH
   7: LD_INT 148
   9: PPUSH
  10: CALL_OW 86
// NewGame ;
  14: CALL 19 0 0
// end ;
  18: END
// export function NewGame ; var i , sides ; begin
  19: LD_INT 0
  21: PPUSH
  22: PPUSH
  23: PPUSH
// sides := [ 1 , 2 , 3 , 5 , 6 , 7 ] ;
  24: LD_ADDR_VAR 0 3
  28: PUSH
  29: LD_INT 1
  31: PUSH
  32: LD_INT 2
  34: PUSH
  35: LD_INT 3
  37: PUSH
  38: LD_INT 5
  40: PUSH
  41: LD_INT 6
  43: PUSH
  44: LD_INT 7
  46: PUSH
  47: EMPTY
  48: LIST
  49: LIST
  50: LIST
  51: LIST
  52: LIST
  53: LIST
  54: ST_TO_ADDR
// for i = 1 to 6 do
  55: LD_ADDR_VAR 0 2
  59: PUSH
  60: DOUBLE
  61: LD_INT 1
  63: DEC
  64: ST_TO_ADDR
  65: LD_INT 6
  67: PUSH
  68: FOR_TO
  69: IFFALSE 128
// if FilterAllUnits ( [ f_side , sides [ i ] ] ) > 0 then
  71: LD_INT 22
  73: PUSH
  74: LD_VAR 0 3
  78: PUSH
  79: LD_VAR 0 2
  83: ARRAY
  84: PUSH
  85: EMPTY
  86: LIST
  87: LIST
  88: PPUSH
  89: CALL_OW 69
  93: PUSH
  94: LD_INT 0
  96: GREATER
  97: IFFALSE 126
// RemoveUnit ( FilterAllUnits ( [ f_side , sides [ i ] ] ) ) ;
  99: LD_INT 22
 101: PUSH
 102: LD_VAR 0 3
 106: PUSH
 107: LD_VAR 0 2
 111: ARRAY
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: PPUSH
 117: CALL_OW 69
 121: PPUSH
 122: CALL_OW 64
 126: GO 68
 128: POP
 129: POP
// Query_race ;
 130: CALL 2638 0 0
// PrepareRace ;
 134: CALL 1671 0 0
// Race_Info ( 2 ) ;
 138: LD_INT 2
 140: PPUSH
 141: CALL 150 0 1
// end ; end_of_file
 145: LD_VAR 0 1
 149: RET
// export claps , c0 , c1l , c2l , c3l , c4l , c5l ; export function race_info ( time ) ; var chkpts , points , p , c1 , c2 , c3 , c4 , c5 , i , a1 , a2 , a3 , a4 , a5 ; begin
 150: LD_INT 0
 152: PPUSH
 153: PPUSH
 154: PPUSH
 155: PPUSH
 156: PPUSH
 157: PPUSH
 158: PPUSH
 159: PPUSH
 160: PPUSH
 161: PPUSH
 162: PPUSH
 163: PPUSH
 164: PPUSH
 165: PPUSH
 166: PPUSH
// chkpts := [ start_end , chp1 , chp2 , chp3 , chp4 , chp5 , chp6 , chp7 , chp8 , chp9 , chp10 , chp11 , chp12 , chp13 , chp14 ] ;
 167: LD_ADDR_VAR 0 3
 171: PUSH
 172: LD_INT 7
 174: PUSH
 175: LD_INT 8
 177: PUSH
 178: LD_INT 9
 180: PUSH
 181: LD_INT 10
 183: PUSH
 184: LD_INT 11
 186: PUSH
 187: LD_INT 12
 189: PUSH
 190: LD_INT 13
 192: PUSH
 193: LD_INT 14
 195: PUSH
 196: LD_INT 15
 198: PUSH
 199: LD_INT 16
 201: PUSH
 202: LD_INT 17
 204: PUSH
 205: LD_INT 18
 207: PUSH
 208: LD_INT 19
 210: PUSH
 211: LD_INT 20
 213: PUSH
 214: LD_INT 21
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: LIST
 224: LIST
 225: LIST
 226: LIST
 227: LIST
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: ST_TO_ADDR
// points := 1 ;
 234: LD_ADDR_VAR 0 4
 238: PUSH
 239: LD_INT 1
 241: ST_TO_ADDR
// claps := 0 ;
 242: LD_ADDR_EXP 1
 246: PUSH
 247: LD_INT 0
 249: ST_TO_ADDR
// SetAreaMapShow ( chkpts [ points ] , 1 ) ;
 250: LD_VAR 0 3
 254: PUSH
 255: LD_VAR 0 4
 259: ARRAY
 260: PPUSH
 261: LD_INT 1
 263: PPUSH
 264: CALL_OW 424
// p := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
 268: LD_ADDR_VAR 0 5
 272: PUSH
 273: LD_INT 22
 275: PUSH
 276: LD_INT 1
 278: PUSH
 279: EMPTY
 280: LIST
 281: LIST
 282: PUSH
 283: LD_INT 21
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: EMPTY
 290: LIST
 291: LIST
 292: PUSH
 293: EMPTY
 294: LIST
 295: LIST
 296: PPUSH
 297: CALL_OW 69
 301: PUSH
 302: LD_INT 1
 304: ARRAY
 305: ST_TO_ADDR
// c1 := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
 306: LD_ADDR_VAR 0 6
 310: PUSH
 311: LD_INT 22
 313: PUSH
 314: LD_INT 2
 316: PUSH
 317: EMPTY
 318: LIST
 319: LIST
 320: PUSH
 321: LD_INT 21
 323: PUSH
 324: LD_INT 2
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PPUSH
 335: CALL_OW 69
 339: PUSH
 340: LD_INT 1
 342: ARRAY
 343: ST_TO_ADDR
// c2 := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
 344: LD_ADDR_VAR 0 7
 348: PUSH
 349: LD_INT 22
 351: PUSH
 352: LD_INT 3
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: PUSH
 359: LD_INT 21
 361: PUSH
 362: LD_INT 2
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: PPUSH
 373: CALL_OW 69
 377: PUSH
 378: LD_INT 1
 380: ARRAY
 381: ST_TO_ADDR
// c3 := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
 382: LD_ADDR_VAR 0 8
 386: PUSH
 387: LD_INT 22
 389: PUSH
 390: LD_INT 5
 392: PUSH
 393: EMPTY
 394: LIST
 395: LIST
 396: PUSH
 397: LD_INT 21
 399: PUSH
 400: LD_INT 2
 402: PUSH
 403: EMPTY
 404: LIST
 405: LIST
 406: PUSH
 407: EMPTY
 408: LIST
 409: LIST
 410: PPUSH
 411: CALL_OW 69
 415: PUSH
 416: LD_INT 1
 418: ARRAY
 419: ST_TO_ADDR
// c4 := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
 420: LD_ADDR_VAR 0 9
 424: PUSH
 425: LD_INT 22
 427: PUSH
 428: LD_INT 6
 430: PUSH
 431: EMPTY
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 21
 437: PUSH
 438: LD_INT 2
 440: PUSH
 441: EMPTY
 442: LIST
 443: LIST
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: PPUSH
 449: CALL_OW 69
 453: PUSH
 454: LD_INT 1
 456: ARRAY
 457: ST_TO_ADDR
// c5 := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
 458: LD_ADDR_VAR 0 10
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 7
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 21
 475: PUSH
 476: LD_INT 2
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: PUSH
 492: LD_INT 1
 494: ARRAY
 495: ST_TO_ADDR
// c0 := 1 ;
 496: LD_ADDR_EXP 2
 500: PUSH
 501: LD_INT 1
 503: ST_TO_ADDR
// c1l := 1 ;
 504: LD_ADDR_EXP 3
 508: PUSH
 509: LD_INT 1
 511: ST_TO_ADDR
// c2l := 1 ;
 512: LD_ADDR_EXP 4
 516: PUSH
 517: LD_INT 1
 519: ST_TO_ADDR
// c3l := 1 ;
 520: LD_ADDR_EXP 5
 524: PUSH
 525: LD_INT 1
 527: ST_TO_ADDR
// c4l := 1 ;
 528: LD_ADDR_EXP 6
 532: PUSH
 533: LD_INT 1
 535: ST_TO_ADDR
// c5l := 1 ;
 536: LD_ADDR_EXP 7
 540: PUSH
 541: LD_INT 1
 543: ST_TO_ADDR
// a1 := 1 ;
 544: LD_ADDR_VAR 0 12
 548: PUSH
 549: LD_INT 1
 551: ST_TO_ADDR
// a2 := 1 ;
 552: LD_ADDR_VAR 0 13
 556: PUSH
 557: LD_INT 1
 559: ST_TO_ADDR
// a3 := 1 ;
 560: LD_ADDR_VAR 0 14
 564: PUSH
 565: LD_INT 1
 567: ST_TO_ADDR
// a4 := 1 ;
 568: LD_ADDR_VAR 0 15
 572: PUSH
 573: LD_INT 1
 575: ST_TO_ADDR
// a5 := 1 ;
 576: LD_ADDR_VAR 0 16
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// ComMoveToArea ( [ c1 , c2 , c3 , c4 , c5 ] , chkpts [ 1 ] ) ;
 584: LD_VAR 0 6
 588: PUSH
 589: LD_VAR 0 7
 593: PUSH
 594: LD_VAR 0 8
 598: PUSH
 599: LD_VAR 0 9
 603: PUSH
 604: LD_VAR 0 10
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: LIST
 614: LIST
 615: PPUSH
 616: LD_VAR 0 3
 620: PUSH
 621: LD_INT 1
 623: ARRAY
 624: PPUSH
 625: CALL_OW 113
// while ( true ) do
 629: LD_INT 1
 631: IFFALSE 1596
// begin Wait ( time ) ;
 633: LD_VAR 0 1
 637: PPUSH
 638: CALL_OW 67
// if IsInArea ( p , chkpts [ points ] ) then
 642: LD_VAR 0 5
 646: PPUSH
 647: LD_VAR 0 3
 651: PUSH
 652: LD_VAR 0 4
 656: ARRAY
 657: PPUSH
 658: CALL_OW 308
 662: IFFALSE 732
// begin points := points + 1 ;
 664: LD_ADDR_VAR 0 4
 668: PUSH
 669: LD_VAR 0 4
 673: PUSH
 674: LD_INT 1
 676: PLUS
 677: ST_TO_ADDR
// c0 := c0 + 1 ;
 678: LD_ADDR_EXP 2
 682: PUSH
 683: LD_EXP 2
 687: PUSH
 688: LD_INT 1
 690: PLUS
 691: ST_TO_ADDR
// SetAreaMapShow ( chkpts [ points ] , 1 ) ;
 692: LD_VAR 0 3
 696: PUSH
 697: LD_VAR 0 4
 701: ARRAY
 702: PPUSH
 703: LD_INT 1
 705: PPUSH
 706: CALL_OW 424
// SetAreaMapShow ( chkpts [ points - 1 ] , 0 ) ;
 710: LD_VAR 0 3
 714: PUSH
 715: LD_VAR 0 4
 719: PUSH
 720: LD_INT 1
 722: MINUS
 723: ARRAY
 724: PPUSH
 725: LD_INT 0
 727: PPUSH
 728: CALL_OW 424
// end ; if IsInArea ( c1 , chkpts [ a1 ] ) then
 732: LD_VAR 0 6
 736: PPUSH
 737: LD_VAR 0 3
 741: PUSH
 742: LD_VAR 0 12
 746: ARRAY
 747: PPUSH
 748: CALL_OW 308
 752: IFFALSE 898
// begin c1l := c1l + 1 ;
 754: LD_ADDR_EXP 3
 758: PUSH
 759: LD_EXP 3
 763: PUSH
 764: LD_INT 1
 766: PLUS
 767: ST_TO_ADDR
// a1 := a1 + 1 ;
 768: LD_ADDR_VAR 0 12
 772: PUSH
 773: LD_VAR 0 12
 777: PUSH
 778: LD_INT 1
 780: PLUS
 781: ST_TO_ADDR
// if a1 > 15 then
 782: LD_VAR 0 12
 786: PUSH
 787: LD_INT 15
 789: GREATER
 790: IFFALSE 800
// a1 := 1 ;
 792: LD_ADDR_VAR 0 12
 796: PUSH
 797: LD_INT 1
 799: ST_TO_ADDR
// ComMoveToArea ( c1 , chkpts [ a1 ] ) ;
 800: LD_VAR 0 6
 804: PPUSH
 805: LD_VAR 0 3
 809: PUSH
 810: LD_VAR 0 12
 814: ARRAY
 815: PPUSH
 816: CALL_OW 113
// if a1 > 11 and a1 < 13 and GetFuel ( c1 ) < Rand ( 50 , 60 ) then
 820: LD_VAR 0 12
 824: PUSH
 825: LD_INT 11
 827: GREATER
 828: PUSH
 829: LD_VAR 0 12
 833: PUSH
 834: LD_INT 13
 836: LESS
 837: AND
 838: PUSH
 839: LD_VAR 0 6
 843: PPUSH
 844: CALL_OW 261
 848: PUSH
 849: LD_INT 50
 851: PPUSH
 852: LD_INT 60
 854: PPUSH
 855: CALL_OW 12
 859: LESS
 860: AND
 861: IFFALSE 898
// begin ComMoveXY ( c1 , 149 , 54 ) ;
 863: LD_VAR 0 6
 867: PPUSH
 868: LD_INT 149
 870: PPUSH
 871: LD_INT 54
 873: PPUSH
 874: CALL_OW 111
// AddComMoveToArea ( c1 , chkpts [ a1 ] ) ;
 878: LD_VAR 0 6
 882: PPUSH
 883: LD_VAR 0 3
 887: PUSH
 888: LD_VAR 0 12
 892: ARRAY
 893: PPUSH
 894: CALL_OW 173
// end ; end ; if IsInArea ( c2 , chkpts [ a2 ] ) then
 898: LD_VAR 0 7
 902: PPUSH
 903: LD_VAR 0 3
 907: PUSH
 908: LD_VAR 0 13
 912: ARRAY
 913: PPUSH
 914: CALL_OW 308
 918: IFFALSE 1064
// begin c2l := c2l + 1 ;
 920: LD_ADDR_EXP 4
 924: PUSH
 925: LD_EXP 4
 929: PUSH
 930: LD_INT 1
 932: PLUS
 933: ST_TO_ADDR
// a2 := a2 + 1 ;
 934: LD_ADDR_VAR 0 13
 938: PUSH
 939: LD_VAR 0 13
 943: PUSH
 944: LD_INT 1
 946: PLUS
 947: ST_TO_ADDR
// if a2 > 15 then
 948: LD_VAR 0 13
 952: PUSH
 953: LD_INT 15
 955: GREATER
 956: IFFALSE 966
// a2 := 1 ;
 958: LD_ADDR_VAR 0 13
 962: PUSH
 963: LD_INT 1
 965: ST_TO_ADDR
// ComMoveToArea ( c2 , chkpts [ a2 ] ) ;
 966: LD_VAR 0 7
 970: PPUSH
 971: LD_VAR 0 3
 975: PUSH
 976: LD_VAR 0 13
 980: ARRAY
 981: PPUSH
 982: CALL_OW 113
// if a2 > 11 and a2 < 13 and GetFuel ( c2 ) < Rand ( 50 , 60 ) then
 986: LD_VAR 0 13
 990: PUSH
 991: LD_INT 11
 993: GREATER
 994: PUSH
 995: LD_VAR 0 13
 999: PUSH
1000: LD_INT 13
1002: LESS
1003: AND
1004: PUSH
1005: LD_VAR 0 7
1009: PPUSH
1010: CALL_OW 261
1014: PUSH
1015: LD_INT 50
1017: PPUSH
1018: LD_INT 60
1020: PPUSH
1021: CALL_OW 12
1025: LESS
1026: AND
1027: IFFALSE 1064
// begin ComMoveXY ( c2 , 149 , 54 ) ;
1029: LD_VAR 0 7
1033: PPUSH
1034: LD_INT 149
1036: PPUSH
1037: LD_INT 54
1039: PPUSH
1040: CALL_OW 111
// AddComMoveToArea ( c2 , chkpts [ a2 ] ) ;
1044: LD_VAR 0 7
1048: PPUSH
1049: LD_VAR 0 3
1053: PUSH
1054: LD_VAR 0 13
1058: ARRAY
1059: PPUSH
1060: CALL_OW 173
// end ; end ; if IsInArea ( c3 , chkpts [ a3 ] ) then
1064: LD_VAR 0 8
1068: PPUSH
1069: LD_VAR 0 3
1073: PUSH
1074: LD_VAR 0 14
1078: ARRAY
1079: PPUSH
1080: CALL_OW 308
1084: IFFALSE 1230
// begin c3l := c3l + 1 ;
1086: LD_ADDR_EXP 5
1090: PUSH
1091: LD_EXP 5
1095: PUSH
1096: LD_INT 1
1098: PLUS
1099: ST_TO_ADDR
// a3 := a3 + 1 ;
1100: LD_ADDR_VAR 0 14
1104: PUSH
1105: LD_VAR 0 14
1109: PUSH
1110: LD_INT 1
1112: PLUS
1113: ST_TO_ADDR
// if a3 > 15 then
1114: LD_VAR 0 14
1118: PUSH
1119: LD_INT 15
1121: GREATER
1122: IFFALSE 1132
// a3 := 1 ;
1124: LD_ADDR_VAR 0 14
1128: PUSH
1129: LD_INT 1
1131: ST_TO_ADDR
// ComMoveToArea ( c3 , chkpts [ a3 ] ) ;
1132: LD_VAR 0 8
1136: PPUSH
1137: LD_VAR 0 3
1141: PUSH
1142: LD_VAR 0 14
1146: ARRAY
1147: PPUSH
1148: CALL_OW 113
// if a3 > 11 and a3 < 13 and GetFuel ( c3 ) < Rand ( 50 , 60 ) then
1152: LD_VAR 0 14
1156: PUSH
1157: LD_INT 11
1159: GREATER
1160: PUSH
1161: LD_VAR 0 14
1165: PUSH
1166: LD_INT 13
1168: LESS
1169: AND
1170: PUSH
1171: LD_VAR 0 8
1175: PPUSH
1176: CALL_OW 261
1180: PUSH
1181: LD_INT 50
1183: PPUSH
1184: LD_INT 60
1186: PPUSH
1187: CALL_OW 12
1191: LESS
1192: AND
1193: IFFALSE 1230
// begin ComMoveXY ( c3 , 149 , 54 ) ;
1195: LD_VAR 0 8
1199: PPUSH
1200: LD_INT 149
1202: PPUSH
1203: LD_INT 54
1205: PPUSH
1206: CALL_OW 111
// AddComMoveToArea ( c3 , chkpts [ a3 ] ) ;
1210: LD_VAR 0 8
1214: PPUSH
1215: LD_VAR 0 3
1219: PUSH
1220: LD_VAR 0 14
1224: ARRAY
1225: PPUSH
1226: CALL_OW 173
// end ; end ; if IsInArea ( c4 , chkpts [ a4 ] ) then
1230: LD_VAR 0 9
1234: PPUSH
1235: LD_VAR 0 3
1239: PUSH
1240: LD_VAR 0 15
1244: ARRAY
1245: PPUSH
1246: CALL_OW 308
1250: IFFALSE 1396
// begin c4l := c4l + 1 ;
1252: LD_ADDR_EXP 6
1256: PUSH
1257: LD_EXP 6
1261: PUSH
1262: LD_INT 1
1264: PLUS
1265: ST_TO_ADDR
// a4 := a4 + 1 ;
1266: LD_ADDR_VAR 0 15
1270: PUSH
1271: LD_VAR 0 15
1275: PUSH
1276: LD_INT 1
1278: PLUS
1279: ST_TO_ADDR
// if a4 > 15 then
1280: LD_VAR 0 15
1284: PUSH
1285: LD_INT 15
1287: GREATER
1288: IFFALSE 1298
// a4 := 1 ;
1290: LD_ADDR_VAR 0 15
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// ComMoveToArea ( c4 , chkpts [ a4 ] ) ;
1298: LD_VAR 0 9
1302: PPUSH
1303: LD_VAR 0 3
1307: PUSH
1308: LD_VAR 0 15
1312: ARRAY
1313: PPUSH
1314: CALL_OW 113
// if a4 > 11 and a4 < 13 and GetFuel ( c4 ) < Rand ( 50 , 60 ) then
1318: LD_VAR 0 15
1322: PUSH
1323: LD_INT 11
1325: GREATER
1326: PUSH
1327: LD_VAR 0 15
1331: PUSH
1332: LD_INT 13
1334: LESS
1335: AND
1336: PUSH
1337: LD_VAR 0 9
1341: PPUSH
1342: CALL_OW 261
1346: PUSH
1347: LD_INT 50
1349: PPUSH
1350: LD_INT 60
1352: PPUSH
1353: CALL_OW 12
1357: LESS
1358: AND
1359: IFFALSE 1396
// begin ComMoveXY ( c4 , 149 , 54 ) ;
1361: LD_VAR 0 9
1365: PPUSH
1366: LD_INT 149
1368: PPUSH
1369: LD_INT 54
1371: PPUSH
1372: CALL_OW 111
// AddComMoveToArea ( c4 , chkpts [ a4 ] ) ;
1376: LD_VAR 0 9
1380: PPUSH
1381: LD_VAR 0 3
1385: PUSH
1386: LD_VAR 0 15
1390: ARRAY
1391: PPUSH
1392: CALL_OW 173
// end ; end ; if IsInArea ( c5 , chkpts [ a5 ] ) then
1396: LD_VAR 0 10
1400: PPUSH
1401: LD_VAR 0 3
1405: PUSH
1406: LD_VAR 0 16
1410: ARRAY
1411: PPUSH
1412: CALL_OW 308
1416: IFFALSE 1562
// begin c5l := c5l + 1 ;
1418: LD_ADDR_EXP 7
1422: PUSH
1423: LD_EXP 7
1427: PUSH
1428: LD_INT 1
1430: PLUS
1431: ST_TO_ADDR
// a5 := a5 + 1 ;
1432: LD_ADDR_VAR 0 16
1436: PUSH
1437: LD_VAR 0 16
1441: PUSH
1442: LD_INT 1
1444: PLUS
1445: ST_TO_ADDR
// if a5 > 15 then
1446: LD_VAR 0 16
1450: PUSH
1451: LD_INT 15
1453: GREATER
1454: IFFALSE 1464
// a5 := 1 ;
1456: LD_ADDR_VAR 0 16
1460: PUSH
1461: LD_INT 1
1463: ST_TO_ADDR
// ComMoveToArea ( c5 , chkpts [ a5 ] ) ;
1464: LD_VAR 0 10
1468: PPUSH
1469: LD_VAR 0 3
1473: PUSH
1474: LD_VAR 0 16
1478: ARRAY
1479: PPUSH
1480: CALL_OW 113
// if a5 > 11 and a5 < 13 and GetFuel ( c5 ) < Rand ( 50 , 60 ) then
1484: LD_VAR 0 16
1488: PUSH
1489: LD_INT 11
1491: GREATER
1492: PUSH
1493: LD_VAR 0 16
1497: PUSH
1498: LD_INT 13
1500: LESS
1501: AND
1502: PUSH
1503: LD_VAR 0 10
1507: PPUSH
1508: CALL_OW 261
1512: PUSH
1513: LD_INT 50
1515: PPUSH
1516: LD_INT 60
1518: PPUSH
1519: CALL_OW 12
1523: LESS
1524: AND
1525: IFFALSE 1562
// begin ComMoveXY ( c5 , 149 , 54 ) ;
1527: LD_VAR 0 10
1531: PPUSH
1532: LD_INT 149
1534: PPUSH
1535: LD_INT 54
1537: PPUSH
1538: CALL_OW 111
// AddComMoveToArea ( c5 , chkpts [ a5 ] ) ;
1542: LD_VAR 0 10
1546: PPUSH
1547: LD_VAR 0 3
1551: PUSH
1552: LD_VAR 0 16
1556: ARRAY
1557: PPUSH
1558: CALL_OW 173
// end ; end ; if points > 15 then
1562: LD_VAR 0 4
1566: PUSH
1567: LD_INT 15
1569: GREATER
1570: IFFALSE 1594
// begin points := 1 ;
1572: LD_ADDR_VAR 0 4
1576: PUSH
1577: LD_INT 1
1579: ST_TO_ADDR
// claps := claps + 1 ;
1580: LD_ADDR_EXP 1
1584: PUSH
1585: LD_EXP 1
1589: PUSH
1590: LD_INT 1
1592: PLUS
1593: ST_TO_ADDR
// end ; end ;
1594: GO 629
// end ;
1596: LD_VAR 0 2
1600: RET
// every 0 0$0.5 do var i ;
1601: GO 1603
1603: DISABLE
1604: LD_INT 0
1606: PPUSH
// begin enable ;
1607: ENABLE
// for i = 1 to all_units do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: DOUBLE
1614: LD_INT 1
1616: DEC
1617: ST_TO_ADDR
1618: LD_OWVAR 3
1622: PUSH
1623: FOR_TO
1624: IFFALSE 1666
// if IsInArea ( all_units [ i ] , fuel_area ) then
1626: LD_OWVAR 3
1630: PUSH
1631: LD_VAR 0 1
1635: ARRAY
1636: PPUSH
1637: LD_INT 22
1639: PPUSH
1640: CALL_OW 308
1644: IFFALSE 1664
// SetFuel ( all_units [ i ] , 100 ) ;
1646: LD_OWVAR 3
1650: PUSH
1651: LD_VAR 0 1
1655: ARRAY
1656: PPUSH
1657: LD_INT 100
1659: PPUSH
1660: CALL_OW 240
1664: GO 1623
1666: POP
1667: POP
// end ; end_of_file
1668: PPOPN 1
1670: END
// export function PrepareRace ; var race_side , race_place , race_user , i , un , veh , area ; begin
1671: LD_INT 0
1673: PPUSH
1674: PPUSH
1675: PPUSH
1676: PPUSH
1677: PPUSH
1678: PPUSH
1679: PPUSH
1680: PPUSH
// race_side := [ 1 , 2 , 3 , 5 , 6 , 7 ] ;
1681: LD_ADDR_VAR 0 2
1685: PUSH
1686: LD_INT 1
1688: PUSH
1689: LD_INT 2
1691: PUSH
1692: LD_INT 3
1694: PUSH
1695: LD_INT 5
1697: PUSH
1698: LD_INT 6
1700: PUSH
1701: LD_INT 7
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: ST_TO_ADDR
// race_place := [ start_1 , start_2 , start_3 , start_4 , start_5 , start_6 ] ;
1712: LD_ADDR_VAR 0 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 3
1725: PUSH
1726: LD_INT 4
1728: PUSH
1729: LD_INT 5
1731: PUSH
1732: LD_INT 6
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: ST_TO_ADDR
// race_user := 6 ;
1743: LD_ADDR_VAR 0 4
1747: PUSH
1748: LD_INT 6
1750: ST_TO_ADDR
// RandomizeAll ;
1751: CALL_OW 11
// for i := 1 to race_user do
1755: LD_ADDR_VAR 0 5
1759: PUSH
1760: DOUBLE
1761: LD_INT 1
1763: DEC
1764: ST_TO_ADDR
1765: LD_VAR 0 4
1769: PUSH
1770: FOR_TO
1771: IFFALSE 2065
// begin uc_side := race_side [ i ] ;
1773: LD_ADDR_OWVAR 20
1777: PUSH
1778: LD_VAR 0 2
1782: PUSH
1783: LD_VAR 0 5
1787: ARRAY
1788: ST_TO_ADDR
// uc_nation := 1 ;
1789: LD_ADDR_OWVAR 21
1793: PUSH
1794: LD_INT 1
1796: ST_TO_ADDR
// hc_gallery :=  ;
1797: LD_ADDR_OWVAR 33
1801: PUSH
1802: LD_STRING 
1804: ST_TO_ADDR
// hc_name :=  ;
1805: LD_ADDR_OWVAR 26
1809: PUSH
1810: LD_STRING 
1812: ST_TO_ADDR
// if i = 1 then
1813: LD_VAR 0 5
1817: PUSH
1818: LD_INT 1
1820: EQUAL
1821: IFFALSE 1848
// hc_skills := [ 10 , 10 , 10 , 10 ] else
1823: LD_ADDR_OWVAR 31
1827: PUSH
1828: LD_INT 10
1830: PUSH
1831: LD_INT 10
1833: PUSH
1834: LD_INT 10
1836: PUSH
1837: LD_INT 10
1839: PUSH
1840: EMPTY
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: ST_TO_ADDR
1846: GO 1893
// hc_skills := [ query_lvl , query_lvl , Rand ( query_lvl - 2 , query_lvl ) , query_lvl ] ;
1848: LD_ADDR_OWVAR 31
1852: PUSH
1853: LD_EXP 9
1857: PUSH
1858: LD_EXP 9
1862: PUSH
1863: LD_EXP 9
1867: PUSH
1868: LD_INT 2
1870: MINUS
1871: PPUSH
1872: LD_EXP 9
1876: PPUSH
1877: CALL_OW 12
1881: PUSH
1882: LD_EXP 9
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: ST_TO_ADDR
// hc_sex := sex_male ;
1893: LD_ADDR_OWVAR 27
1897: PUSH
1898: LD_INT 1
1900: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1901: LD_ADDR_OWVAR 29
1905: PUSH
1906: LD_INT 10
1908: PUSH
1909: LD_INT 10
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: ST_TO_ADDR
// hc_class := 3 ;
1916: LD_ADDR_OWVAR 28
1920: PUSH
1921: LD_INT 3
1923: ST_TO_ADDR
// un := CreateHuman ;
1924: LD_ADDR_VAR 0 6
1928: PUSH
1929: CALL_OW 44
1933: ST_TO_ADDR
// vc_chassis := us_morphling ;
1934: LD_ADDR_OWVAR 37
1938: PUSH
1939: LD_INT 5
1941: ST_TO_ADDR
// vc_control := control_manual ;
1942: LD_ADDR_OWVAR 38
1946: PUSH
1947: LD_INT 1
1949: ST_TO_ADDR
// vc_engine := engine_combustion ;
1950: LD_ADDR_OWVAR 39
1954: PUSH
1955: LD_INT 1
1957: ST_TO_ADDR
// vc_weapon := 80 ;
1958: LD_ADDR_OWVAR 40
1962: PUSH
1963: LD_INT 80
1965: ST_TO_ADDR
// veh := CreateVehicle ;
1966: LD_ADDR_VAR 0 7
1970: PUSH
1971: CALL_OW 45
1975: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
1976: LD_VAR 0 7
1980: PPUSH
1981: LD_INT 4
1983: PPUSH
1984: CALL_OW 233
// area := Rand ( 1 , race_place ) ;
1988: LD_ADDR_VAR 0 8
1992: PUSH
1993: LD_INT 1
1995: PPUSH
1996: LD_VAR 0 3
2000: PPUSH
2001: CALL_OW 12
2005: ST_TO_ADDR
// PlaceUnitArea ( veh , race_place [ area ] , false ) ;
2006: LD_VAR 0 7
2010: PPUSH
2011: LD_VAR 0 3
2015: PUSH
2016: LD_VAR 0 8
2020: ARRAY
2021: PPUSH
2022: LD_INT 0
2024: PPUSH
2025: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
2029: LD_VAR 0 6
2033: PPUSH
2034: LD_VAR 0 7
2038: PPUSH
2039: CALL_OW 52
// race_place := Delete ( race_place , area ) ;
2043: LD_ADDR_VAR 0 3
2047: PUSH
2048: LD_VAR 0 3
2052: PPUSH
2053: LD_VAR 0 8
2057: PPUSH
2058: CALL_OW 3
2062: ST_TO_ADDR
// end ;
2063: GO 1770
2065: POP
2066: POP
// end ; end_of_file
2067: LD_VAR 0 1
2071: RET
// export query_laps , query_lvl , ok ; every 0 0$01 trigger ok = false do var i , p , c ;
2072: LD_EXP 10
2076: PUSH
2077: LD_INT 0
2079: EQUAL
2080: IFFALSE 2635
2082: GO 2084
2084: DISABLE
2085: LD_INT 0
2087: PPUSH
2088: PPUSH
2089: PPUSH
// begin enable ;
2090: ENABLE
// if c0 > c1l and c0 > c2l and c0 > c3l and c0 > c4l and c0 > c5l then
2091: LD_EXP 2
2095: PUSH
2096: LD_EXP 3
2100: GREATER
2101: PUSH
2102: LD_EXP 2
2106: PUSH
2107: LD_EXP 4
2111: GREATER
2112: AND
2113: PUSH
2114: LD_EXP 2
2118: PUSH
2119: LD_EXP 5
2123: GREATER
2124: AND
2125: PUSH
2126: LD_EXP 2
2130: PUSH
2131: LD_EXP 6
2135: GREATER
2136: AND
2137: PUSH
2138: LD_EXP 2
2142: PUSH
2143: LD_EXP 7
2147: GREATER
2148: AND
2149: IFFALSE 2159
// c := 1 ;
2151: LD_ADDR_VAR 0 3
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// if c1l > c0 and c1l > c2l and c1l > c3l and c1l > c4l and c1l > c5l then
2159: LD_EXP 3
2163: PUSH
2164: LD_EXP 2
2168: GREATER
2169: PUSH
2170: LD_EXP 3
2174: PUSH
2175: LD_EXP 4
2179: GREATER
2180: AND
2181: PUSH
2182: LD_EXP 3
2186: PUSH
2187: LD_EXP 5
2191: GREATER
2192: AND
2193: PUSH
2194: LD_EXP 3
2198: PUSH
2199: LD_EXP 6
2203: GREATER
2204: AND
2205: PUSH
2206: LD_EXP 3
2210: PUSH
2211: LD_EXP 7
2215: GREATER
2216: AND
2217: IFFALSE 2227
// c := 2 ;
2219: LD_ADDR_VAR 0 3
2223: PUSH
2224: LD_INT 2
2226: ST_TO_ADDR
// if c2l > c0 and c2l > c1l and c2l > c3l and c2l > c4l and c2l > c5l then
2227: LD_EXP 4
2231: PUSH
2232: LD_EXP 2
2236: GREATER
2237: PUSH
2238: LD_EXP 4
2242: PUSH
2243: LD_EXP 3
2247: GREATER
2248: AND
2249: PUSH
2250: LD_EXP 4
2254: PUSH
2255: LD_EXP 5
2259: GREATER
2260: AND
2261: PUSH
2262: LD_EXP 4
2266: PUSH
2267: LD_EXP 6
2271: GREATER
2272: AND
2273: PUSH
2274: LD_EXP 4
2278: PUSH
2279: LD_EXP 7
2283: GREATER
2284: AND
2285: IFFALSE 2295
// c := 3 ;
2287: LD_ADDR_VAR 0 3
2291: PUSH
2292: LD_INT 3
2294: ST_TO_ADDR
// if c3l > c0 and c3l > c2l and c3l > c1l and c3l > c4l and c3l > c5l then
2295: LD_EXP 5
2299: PUSH
2300: LD_EXP 2
2304: GREATER
2305: PUSH
2306: LD_EXP 5
2310: PUSH
2311: LD_EXP 4
2315: GREATER
2316: AND
2317: PUSH
2318: LD_EXP 5
2322: PUSH
2323: LD_EXP 3
2327: GREATER
2328: AND
2329: PUSH
2330: LD_EXP 5
2334: PUSH
2335: LD_EXP 6
2339: GREATER
2340: AND
2341: PUSH
2342: LD_EXP 5
2346: PUSH
2347: LD_EXP 7
2351: GREATER
2352: AND
2353: IFFALSE 2363
// c := 5 ;
2355: LD_ADDR_VAR 0 3
2359: PUSH
2360: LD_INT 5
2362: ST_TO_ADDR
// if c4l > c0 and c4l > c2l and c4l > c3l and c4l > c1l and c4l > c5l then
2363: LD_EXP 6
2367: PUSH
2368: LD_EXP 2
2372: GREATER
2373: PUSH
2374: LD_EXP 6
2378: PUSH
2379: LD_EXP 4
2383: GREATER
2384: AND
2385: PUSH
2386: LD_EXP 6
2390: PUSH
2391: LD_EXP 5
2395: GREATER
2396: AND
2397: PUSH
2398: LD_EXP 6
2402: PUSH
2403: LD_EXP 3
2407: GREATER
2408: AND
2409: PUSH
2410: LD_EXP 6
2414: PUSH
2415: LD_EXP 7
2419: GREATER
2420: AND
2421: IFFALSE 2431
// c := 6 ;
2423: LD_ADDR_VAR 0 3
2427: PUSH
2428: LD_INT 6
2430: ST_TO_ADDR
// if c5l > c0 and c5l > c2l and c5l > c3l and c5l > c4l and c5l > c1l then
2431: LD_EXP 7
2435: PUSH
2436: LD_EXP 2
2440: GREATER
2441: PUSH
2442: LD_EXP 7
2446: PUSH
2447: LD_EXP 4
2451: GREATER
2452: AND
2453: PUSH
2454: LD_EXP 7
2458: PUSH
2459: LD_EXP 5
2463: GREATER
2464: AND
2465: PUSH
2466: LD_EXP 7
2470: PUSH
2471: LD_EXP 6
2475: GREATER
2476: AND
2477: PUSH
2478: LD_EXP 7
2482: PUSH
2483: LD_EXP 3
2487: GREATER
2488: AND
2489: IFFALSE 2499
// c := 7 ;
2491: LD_ADDR_VAR 0 3
2495: PUSH
2496: LD_INT 7
2498: ST_TO_ADDR
// if c > 0 then
2499: LD_VAR 0 3
2503: PUSH
2504: LD_INT 0
2506: GREATER
2507: IFFALSE 2544
// Display_Strings := [ #race , c , c , #racelap , claps ] else
2509: LD_ADDR_OWVAR 47
2513: PUSH
2514: LD_STRING #race
2516: PUSH
2517: LD_VAR 0 3
2521: PUSH
2522: LD_VAR 0 3
2526: PUSH
2527: LD_STRING #racelap
2529: PUSH
2530: LD_EXP 1
2534: PUSH
2535: EMPTY
2536: LIST
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: ST_TO_ADDR
2542: GO 2565
// Display_Strings := [ #raced , #racelap , claps ] ;
2544: LD_ADDR_OWVAR 47
2548: PUSH
2549: LD_STRING #raced
2551: PUSH
2552: LD_STRING #racelap
2554: PUSH
2555: LD_EXP 1
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: LIST
2564: ST_TO_ADDR
// if claps = query_laps then
2565: LD_EXP 1
2569: PUSH
2570: LD_EXP 8
2574: EQUAL
2575: IFFALSE 2635
// if c = 1 then
2577: LD_VAR 0 3
2581: PUSH
2582: LD_INT 1
2584: EQUAL
2585: IFFALSE 2628
// begin case Query ( YouWi ) of 1 :
2587: LD_STRING YouWi
2589: PPUSH
2590: CALL_OW 97
2594: PUSH
2595: LD_INT 1
2597: DOUBLE
2598: EQUAL
2599: IFTRUE 2603
2601: GO 2610
2603: POP
// NewGame ; 2 :
2604: CALL 19 0 0
2608: GO 2626
2610: LD_INT 2
2612: DOUBLE
2613: EQUAL
2614: IFTRUE 2618
2616: GO 2625
2618: POP
// YouWin ; end ;
2619: CALL_OW 103
2623: GO 2626
2625: POP
// end else
2626: GO 2635
// begin YouLost ( YouLos ) ;
2628: LD_STRING YouLos
2630: PPUSH
2631: CALL_OW 104
// end ; end ;
2635: PPOPN 3
2637: END
// export function query_race ; begin
2638: LD_INT 0
2640: PPUSH
// case Query ( start ) of 1 :
2641: LD_STRING start
2643: PPUSH
2644: CALL_OW 97
2648: PUSH
2649: LD_INT 1
2651: DOUBLE
2652: EQUAL
2653: IFTRUE 2657
2655: GO 2680
2657: POP
// case Query ( info ) of 1 :
2658: LD_STRING info
2660: PPUSH
2661: CALL_OW 97
2665: PUSH
2666: LD_INT 1
2668: DOUBLE
2669: EQUAL
2670: IFTRUE 2674
2672: GO 2677
2674: POP
// ; end ; 2 :
2675: GO 2678
2677: POP
2678: GO 2692
2680: LD_INT 2
2682: DOUBLE
2683: EQUAL
2684: IFTRUE 2688
2686: GO 2691
2688: POP
// ; end ;
2689: GO 2692
2691: POP
// case Query ( lvl ) of 1 :
2692: LD_STRING lvl
2694: PPUSH
2695: CALL_OW 97
2699: PUSH
2700: LD_INT 1
2702: DOUBLE
2703: EQUAL
2704: IFTRUE 2708
2706: GO 2719
2708: POP
// query_lvl := 6 ; 2 :
2709: LD_ADDR_EXP 9
2713: PUSH
2714: LD_INT 6
2716: ST_TO_ADDR
2717: GO 2758
2719: LD_INT 2
2721: DOUBLE
2722: EQUAL
2723: IFTRUE 2727
2725: GO 2738
2727: POP
// query_lvl := 8 ; 3 :
2728: LD_ADDR_EXP 9
2732: PUSH
2733: LD_INT 8
2735: ST_TO_ADDR
2736: GO 2758
2738: LD_INT 3
2740: DOUBLE
2741: EQUAL
2742: IFTRUE 2746
2744: GO 2757
2746: POP
// query_lvl := 10 ; end ;
2747: LD_ADDR_EXP 9
2751: PUSH
2752: LD_INT 10
2754: ST_TO_ADDR
2755: GO 2758
2757: POP
// case Query ( laps ) of 1 :
2758: LD_STRING laps
2760: PPUSH
2761: CALL_OW 97
2765: PUSH
2766: LD_INT 1
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2785
2774: POP
// query_laps := 1 ; 2 :
2775: LD_ADDR_EXP 8
2779: PUSH
2780: LD_INT 1
2782: ST_TO_ADDR
2783: GO 2824
2785: LD_INT 2
2787: DOUBLE
2788: EQUAL
2789: IFTRUE 2793
2791: GO 2804
2793: POP
// query_laps := 3 ; 3 :
2794: LD_ADDR_EXP 8
2798: PUSH
2799: LD_INT 3
2801: ST_TO_ADDR
2802: GO 2824
2804: LD_INT 3
2806: DOUBLE
2807: EQUAL
2808: IFTRUE 2812
2810: GO 2823
2812: POP
// query_laps := 5 ; end ;
2813: LD_ADDR_EXP 8
2817: PUSH
2818: LD_INT 5
2820: ST_TO_ADDR
2821: GO 2824
2823: POP
// claps := 0 ;
2824: LD_ADDR_EXP 1
2828: PUSH
2829: LD_INT 0
2831: ST_TO_ADDR
// ok := false ;
2832: LD_ADDR_EXP 10
2836: PUSH
2837: LD_INT 0
2839: ST_TO_ADDR
// end ;
2840: LD_VAR 0 1
2844: RET
