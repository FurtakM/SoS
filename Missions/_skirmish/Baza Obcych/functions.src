 // Inicjalizacja

// Dodaje pomocnicze sta³e
Export tech_weap, tech_opto, tech_sib, tech_time,
       tech_comp, tech_bio, tech_lab;
Export Function lab_variable();
begin
tech_lab  := [35, 48, 49, 45, 46, 47, 1, {2,} 50, 20];
tech_weap := [51, 69, 52, 39, 70];
End;

// Funkcja dodajaca z³oza na mapie
Export Function AddDeposits(bool);
var i, j, normal_oil, extra_oil, normal_sib, extra_sib;
begin

  normal_oil                   :=[ [28,22], [69,3], [138,27], [180,104], [138,137], [76,115] ];

  extra_oil                    :=[ [ [31,38],   [34,21]   ],
                                   [ [58,4],    [82,4]    ],
                                   [ [122,18],  [152,43]  ],
                                   [ [174,90],  [180,120] ],
                                   [ [152,136], [130,136] ],
                                   [ [89,116],  [59,89]   ] ];

  normal_sib                   :=[ [28,26], [73,3], [133,22], [180,110], [142,137], [72,112] ];

  extra_sib                    :=[ [ [27,39],   [30,16]   ],
                                   [ [57,8],    [87,8]    ],
                                   [ [128,19],  [146,36]  ],
                                   [ [176,121], [179,96]  ],
                                   [ [153,132], [124,133] ],
                                   [ [85,117],  [62,96]   ] ];

  if bool then
     begin
     for i = 1 to 6 do
         for j = 1 to 2 do
             begin
             CreateDepositXY(extra_sib[i][j][1], extra_sib[i][j][2], mat_siberit);
             CreateDepositXY(extra_oil[i][j][1], extra_oil[i][j][2], mat_oil);
             end;
     end
      else
       begin
         for j = 1 to 6 do
             begin
             CreateDepositXY(normal_sib[j][1], normal_sib[j][2], mat_siberit);
             CreateDepositXY(normal_oil[j][1], normal_oil[j][2], mat_oil);
             end;
       end;

       super_source := bool;

End;





// Rozbudowy fabryki (Nieuzywane!) ZWRACA ZLE WARTOSCI!
{Export Function GetExtXYD(b); // b - factory ident
var x, y, d, ext;
begin
x := GetX(b);
y := GetY(b);
d := GetDir(b);

if d < 3 then
   d = d + 3;

ext := [];

ext := [x, y+3, d-3-1] ^ [x-4, y, d-3] ^
       [x+4, y+4, d+1] ^ [x-3, y-3, d-3+1] ^
       [x, y-4, d-1];

result := ext;
display_strings := result;
End;}



// Funkcje sprawdzajace
Export Function UnitExist(id, val);
begin

     if GetLives(id) >= val then
        result := true
         else
          result := false;

End;

Export Function AnyBuildingExist(side, typ);
begin

     if FilterAllUnits([[f_side, side], [f_btype, typ]]) > 0 then
        result := true
         else
          result := false;

End;



// Odwrót
Export Function ComRetreat(un);
var coord_dist, dir, x, y;
begin

    ComTurnUnit(un, NearestUnitToUnit(FilterAllUnits([f_enemy, GetSide(un)]), un));
    dir := GetDir(un);

    dir := dir - 3;

    if dir < 0 then
       dir := dir + 6;

    While true do
    begin
        coord_dist := 3;

        x := ShiftX(GetX(un), dir, coord_dist);
        y := ShiftY(GetY(un), dir, coord_dist);

        if IsEnvironment(x, y) or ValidHex(x, y) = 0 or InArea(x, y, HexEmpty) = 0 or HexInfo(x, y) <> 0 then
           begin

           Repeat
            begin
              coord_dist := coord_dist + 1;
              dir := dir + 1;

              if dir > 5 then
                 dir = 0;

              x := ShiftX(GetX(un), dir, coord_dist);
              y := ShiftY(GetY(un), dir, coord_dist);
            end
           Until not IsEnvironment(x, y) and ValidHex(x, y) and InArea(x, y, HexEmpty) and HexInfo(x, y) = 0;

           end;

        AddComMoveXY(un, x, y);
        Wait(0$1);

        if GetDistUnits(un, NearestUnitToUnit(FilterAllUnits([f_enemy, GetSide(un)]), un)) >= 16 then
           begin
            ComStop(un);
            break;
           end;

      end;


End;


Export Function CreateHumanWithClass(clas, lvl);
var skill_com, skill_eng, skill_mech, skill_sci, bonus;
begin

     hc_class := clas;

     // randomize lvl
        skill_com  := (lvl + Rand(-1, 1));
        skill_eng  := (lvl + Rand(-1, 1));
        skill_mech := (lvl + Rand(-1, 1));
        skill_sci  := (lvl + Rand(-1, 1));

     // add bonus level for class
        If clas = 1 or clas = class_bazooker or clas = class_sniper or clas = class_mortar then
        bonus := [2,0,0,0];
        If clas = 2 then
        bonus := [0,2,0,0];
        If clas = 3 then
        bonus := [0,0,2,0];
        If clas = 4 then
        bonus := [0,0,0,2];
        If clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
        bonus := [0,0,0,0];

     // set main skills
        hc_basic_skills := [Rand(0,2), Rand(0,2), Rand(0,2), Rand(0,2)];
        hc_skills := [skill_com + bonus[1], skill_eng + bonus[2], skill_mech + bonus[3], skill_sci + bonus[4] ];

     // other hc_
        hc_sex     := Rand(sex_male, sex_female); // random
        hc_gallery := ''; // random gall
        hc_attr    := [Rand(8,12), Rand(9,11)];
        hc_name    := '';
        { place for rest hc_'s }

     // final result
        result := CreateHuman;

End;



Export Function scs_create_squad(side, nation, people, skill, area);
var i, num, un;
begin

     num := people/4;


     // tworzenie ludzi
        uc_side   := side;
        uc_nation := nation;

        // dowódca
           hc_importance := 100;
           un := CreateHumanWithClass(1, skill);
           PlaceUnitArea(un, area, false);

           // reset importance
              hc_importance := 0;

       // reszta
          for i = 1 to num do
              PlaceUnitArea(CreateHumanWithClass(1, skill), area, false);
          for i = 1 to num do
              PlaceUnitArea(CreateHumanWithClass(2, skill), area, false);
          for i = 1 to num do
              PlaceUnitArea(CreateHumanWithClass(3, skill), area, false);
          for i = 1 to num do
              PlaceUnitArea(CreateHumanWithClass(4, skill), area, false);


End;


Export Function scs_scan_side(side);
begin
result := FilterAllUnits([f_side, side]);
End;

Export Function scs_clear_side(side);
var i, filter;
begin
filter := scs_scan_side(side);

for i = 1 to filter do
    RemoveUnit(filter[i]);
End;


Export Function scs_scan_class(side, clas, bool);
begin
if bool = false then
   result := FilterAllUnits([[f_side, side], [f_class, clas]])
    else
     result := FilterAllUnits([[f_side, side], [f_class, clas], [f_ok]])
End;


Export Function scs_scan_damage(side, value);
begin
result := FilterAllUnits([[f_side, side], [f_not, [f_lives, value]]]);
End;


Export Function scs_scan_area(side, x, y, dist);
var enemy;
begin
enemy := FilterAllUnits([[f_enemy, side], [f_distxy, x, y, dist]]);

if enemy > 0 then
   result := true
    else
     result := false;

End;

Export Function scs_scan_lab(side);
begin
result := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_lab], [f_btype, b_lab_half], [f_btype, b_lab_full]]]);
End;


Export Function scs_scan_buildings(side, typ);
begin
result := FilterAllUnits([[f_side, side], [f_btype, typ]]);
End;

Export Function scs_change_side(side, new_side);
var filter, i;
begin
filter := FilterAllUnits([[f_side, side], [f_type, unit_human]]);

for i = 1 to filter do
    SetSide(filter[i], new_side);

End;


Export Function Build(engs, build, x, y, d, cost);
var i, dep;
begin

dep := FilterAllUnits([[[f_side, GetSide(engs[1])], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]]);

if GetResourceType(GetBase(dep[1]), mat_cans) >= cost then
   for i = 1 to engs do
       if not HasTask(engs[i]) and not Carry(engs[i]) then
          ComBuild(engs[i], build, x, y, d);

End;


Export Function Upgrade(side, typ, cost);
var i, dep, b;
begin

b := FilterAllUnits([[f_side, side], [f_btype, typ]])[1];
dep := FilterAllUnits([[[f_side, side], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]]);

if GetResourceType(GetBase(dep[1]), mat_cans) >= cost then
   ComUpgrade(b);

End;


Export Function UpgradeLab(lab, typ1, cost);
var dep;
begin
dep := FilterAllUnits([[[f_side, GetSide(lab)], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]]);

if GetResourceType(GetBase(dep[1]), mat_cans) >= cost then
   ComUpgradeLab(lab, typ1);

End;


Export Function BuildPowerPlant(engs, typ, x, y, d);
var i, b, dep, source, source2, side;
begin
side := GetSide(engs[1]);
dep := FilterAllUnits([[[f_side, side], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]]);
source  := GetResourceType(GetBase(dep[1]), mat_cans);
source2 := GetResourceType(GetBase(dep[1]), mat_siberit);


        Case typ of
        b_solar_power:  begin
                        if GetTech(tech_solpow, side) = state_researched and source >= 35 then
                           ComBuild(engs, typ, x, y, d);
                        end;

        b_oil_power:    begin
                        if GetTech(tech_oilpow, side) = state_researched and source >= 20 then
                           ComBuild(engs, typ, x, y, d);
                        end;

        b_siberite_power:begin
                        if GetTech(tech_sibpow, side) = state_researched and source >= 20 and source2 >= 10 then
                           ComBuild(engs, typ, x, y, d);
                        end;


        End;

End;

Export Function SortFilter(filter, skill);
var skill_list, i, list;
begin
for i in filter do
skill_list = skill_list ^ GetSkill(i, skill);

result = SortListByListDesc(filter, skill_list);
End;

Export Function scs_change_class(unit, clas);
var side;
begin

     side := GetSide(unit);
     
  if not HasTask(unit) then
     Case clas of
     1: begin // ¿o³nierz
        if IsInUnit(unit) then
           ComExitBuilding(unit);

        Wait(1);

        ComEnterUnit(unit, scs_find_barracks(side));
        AddComChangeProfession(unit, clas);
        end;
     2: begin // in¿ynier
        if IsInUnit(unit) then
           ComExitBuilding(unit);

        Wait(1);

        ComEnterUnit(unit, scs_find_depot(side));
        AddComChangeProfession(unit, clas);
        end;
     3: begin // mechanik
        if IsInUnit(unit) then
           ComExitBuilding(unit);

        Wait(1);

        ComEnterUnit(unit, scs_find_factory(side));
        AddComChangeProfession(unit, clas);
        end;
     4: begin // ¿o³nierz
        if IsInUnit(unit) then
           ComExitBuilding(unit);

        Wait(1);

        ComEnterUnit(unit, scs_find_lab(side));
        AddComChangeProfession(unit, clas);
        end;

        end;

End;


Export Function scs_find_barracks(side);
var filter, i;
begin

     filter := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_armoury], [f_btype, b_barracks]]]);

     if filter > 0 then
        for i = 1 to filter do
            if UnitsInside(filter[i]) < 6 then
               begin
               result := filter[i];
               break;
               end;

End;

Export Function scs_find_lab(side);
var filter, i;
begin

     filter := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_lab], [f_btype, b_lab_full], [f_btype, b_lab_half]]]);

     if filter > 0 then
        for i = 1 to filter do
            if UnitsInside(filter[i]) < 6 then
               begin
               result := filter[i];
               break;
               end;

End;

Export Function scs_find_factory(side);
var filter, i;
begin

     filter := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_workshop], [f_btype, b_factory]]]);

     if filter > 0 then
        for i = 1 to filter do
            if UnitsInside(filter[i]) < 6 then
               begin
               result := filter[i];
               break;
               end;

End;

Export Function scs_find_depot(side);
var filter, i;
begin

     filter := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_depot], [f_btype, b_warehouse]]]);

     if filter > 0 then
        for i = 1 to filter do
            if UnitsInside(filter[i]) < 6 then
               begin
               result := filter[i];
               break;
               end;

End;


Export Function IsInTower(unit);
var i, filter;
begin
filter := FilterAllUnits([[f_side, GetSide(unit)], [f_btype, b_bunker]]);

for i in filter do
    if unit in UnitsInside(i) then
       result := true
        else
         result := false;
End;


Export Function FillTowers(side);
var filter, sold, sold_q, i;
begin
filter := FilterAllUnits([[f_side, side], [f_or, [f_btype, b_breastwork], [f_btype, b_bunker]]]);
sold   := scs_scan_class(side, 1, true);

if UnitFilter(filter, [f_empty]) > 0 and sold then
   for i = 1 to sold do
       if not IsInTower(sold[i]) then
          begin
          if IsInUnit(sold[i]) then
             ComExitBuilding(sold[i]);

          ComEnterUnit(sold[i], UnitFilter(filter, [f_empty])[1]);
          break;
          end;

End;



Export Function CanBExt(side, ext);
begin

     Case ext of
     b_ext_noncombat, b_ext_track: result := true; // niewymaga techow!
     b_ext_gun:
               if GetTech(39, side) = state_researched then
                  result := true
                   else
                    result := false;

     b_ext_rocket:
               if GetTech(40, side) = state_researched then
                  result := true
                   else
                    result := false;
        
     b_ext_laser:
               if GetTech(10, side) = state_researched then
                  result := true
                   else
                    result := false;

     b_ext_siberium:
               if GetTech(21, side) = state_researched then
                  result := true
                   else
                    result := false;

     b_ext_radar:
               if GetTech(6, side) = state_researched then
                  result := true
                   else
                    result := false;

     b_ext_radio:
               if GetTech(15, side) = state_researched then
                  result := true
                   else
                    result := false;
     end;

End;



