// starting begin lab_variable ;
   0: CALL 1064 0 0
// main_settings ;
   4: CALL 19 0 0
// if test then
   8: LD_EXP 84
  12: IFFALSE 18
// var_test ;
  14: CALL 11460 0 0
// end ;
  18: END
// export function main_settings ; begin
  19: LD_INT 0
  21: PPUSH
// test := true ;
  22: LD_ADDR_EXP 84
  26: PUSH
  27: LD_INT 1
  29: ST_TO_ADDR
// AddDeposits ( true ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL 1142 0 1
// end ; end_of_file
  37: LD_VAR 0 1
  41: RET
// export b1_act , b2_act , b3_act , b4_act , b5_act ; export b1_side , b1_nation , b1_area , b1_people , b1_skill , b1_cr_dep , b1_cr_lab , b1_cr_fab , b1_cr_ext , b1_cr_pow , b1_cr_tw , b1_cr_br , b1_cr_add ; export b2_side , b2_nation , b2_area , b2_people , b2_skill , b2_cr_dep , b2_cr_lab , b2_cr_fab , b2_cr_ext , b2_cr_pow , b2_cr_tw , b2_cr_br , b2_cr_add ; export b3_side , b3_nation , b3_area , b3_people , b3_skill , b3_cr_dep , b3_cr_lab , b3_cr_fab , b3_cr_ext , b3_cr_pow , b3_cr_tw , b3_cr_br , b3_cr_add ; export b4_side , b4_nation , b4_area , b4_people , b4_skill , b4_cr_dep , b4_cr_lab , b4_cr_fab , b4_cr_ext , b4_cr_pow , b4_cr_tw , b4_cr_br , b4_cr_add ; export b5_side , b5_nation , b5_area , b5_people , b5_skill , b5_cr_dep , b5_cr_lab , b5_cr_fab , b5_cr_ext , b5_cr_pow , b5_cr_tw , b5_cr_br , b5_cr_add ; export super_source ; export b1_tech , b2_tech , b3_tech , b4_tech , b5_tech ; export function scs_init ( num , side , nation , area , people , skill , cr_dep , cr_lab , cr_fab , cr_ext , cr_pow , cr_tw , cr_br , cr_add ) ; begin
  42: LD_INT 0
  44: PPUSH
// case num of 1 :
  45: LD_VAR 0 1
  49: PUSH
  50: LD_INT 1
  52: DOUBLE
  53: EQUAL
  54: IFTRUE 58
  56: GO 191
  58: POP
// begin b1_side := side ;
  59: LD_ADDR_EXP 6
  63: PUSH
  64: LD_VAR 0 2
  68: ST_TO_ADDR
// b1_nation := nation ;
  69: LD_ADDR_EXP 7
  73: PUSH
  74: LD_VAR 0 3
  78: ST_TO_ADDR
// b1_area := area ;
  79: LD_ADDR_EXP 8
  83: PUSH
  84: LD_VAR 0 4
  88: ST_TO_ADDR
// b1_people := people ;
  89: LD_ADDR_EXP 9
  93: PUSH
  94: LD_VAR 0 5
  98: ST_TO_ADDR
// b1_skill := skill ;
  99: LD_ADDR_EXP 10
 103: PUSH
 104: LD_VAR 0 6
 108: ST_TO_ADDR
// b1_cr_dep := cr_dep ;
 109: LD_ADDR_EXP 11
 113: PUSH
 114: LD_VAR 0 7
 118: ST_TO_ADDR
// b1_cr_lab := cr_lab ;
 119: LD_ADDR_EXP 12
 123: PUSH
 124: LD_VAR 0 8
 128: ST_TO_ADDR
// b1_cr_fab := cr_fab ;
 129: LD_ADDR_EXP 13
 133: PUSH
 134: LD_VAR 0 9
 138: ST_TO_ADDR
// b1_cr_ext := cr_ext ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_VAR 0 10
 148: ST_TO_ADDR
// b1_cr_pow := cr_pow ;
 149: LD_ADDR_EXP 15
 153: PUSH
 154: LD_VAR 0 11
 158: ST_TO_ADDR
// b1_cr_tw := cr_tw ;
 159: LD_ADDR_EXP 16
 163: PUSH
 164: LD_VAR 0 12
 168: ST_TO_ADDR
// b1_cr_br := cr_br ;
 169: LD_ADDR_EXP 17
 173: PUSH
 174: LD_VAR 0 13
 178: ST_TO_ADDR
// b1_cr_add := cr_add ;
 179: LD_ADDR_EXP 18
 183: PUSH
 184: LD_VAR 0 14
 188: ST_TO_ADDR
// end ; 2 :
 189: GO 333
 191: LD_INT 2
 193: DOUBLE
 194: EQUAL
 195: IFTRUE 199
 197: GO 332
 199: POP
// begin b2_side := side ;
 200: LD_ADDR_EXP 19
 204: PUSH
 205: LD_VAR 0 2
 209: ST_TO_ADDR
// b2_nation := nation ;
 210: LD_ADDR_EXP 20
 214: PUSH
 215: LD_VAR 0 3
 219: ST_TO_ADDR
// b2_area := area ;
 220: LD_ADDR_EXP 21
 224: PUSH
 225: LD_VAR 0 4
 229: ST_TO_ADDR
// b2_people := people ;
 230: LD_ADDR_EXP 22
 234: PUSH
 235: LD_VAR 0 5
 239: ST_TO_ADDR
// b2_skill := skill ;
 240: LD_ADDR_EXP 23
 244: PUSH
 245: LD_VAR 0 6
 249: ST_TO_ADDR
// b2_cr_dep := cr_dep ;
 250: LD_ADDR_EXP 24
 254: PUSH
 255: LD_VAR 0 7
 259: ST_TO_ADDR
// b2_cr_lab := cr_lab ;
 260: LD_ADDR_EXP 25
 264: PUSH
 265: LD_VAR 0 8
 269: ST_TO_ADDR
// b2_cr_fab := cr_fab ;
 270: LD_ADDR_EXP 26
 274: PUSH
 275: LD_VAR 0 9
 279: ST_TO_ADDR
// b2_cr_ext := cr_ext ;
 280: LD_ADDR_EXP 27
 284: PUSH
 285: LD_VAR 0 10
 289: ST_TO_ADDR
// b2_cr_pow := cr_pow ;
 290: LD_ADDR_EXP 28
 294: PUSH
 295: LD_VAR 0 11
 299: ST_TO_ADDR
// b2_cr_tw := cr_tw ;
 300: LD_ADDR_EXP 29
 304: PUSH
 305: LD_VAR 0 12
 309: ST_TO_ADDR
// b2_cr_br := cr_br ;
 310: LD_ADDR_EXP 30
 314: PUSH
 315: LD_VAR 0 13
 319: ST_TO_ADDR
// b2_cr_add := cr_add ;
 320: LD_ADDR_EXP 31
 324: PUSH
 325: LD_VAR 0 14
 329: ST_TO_ADDR
// end ; end ;
 330: GO 333
 332: POP
// end ;
 333: LD_VAR 0 15
 337: RET
// export function scs_create_bots ( ) ; var i , c , s , filter , side , tmp ; begin
 338: LD_INT 0
 340: PPUSH
 341: PPUSH
 342: PPUSH
 343: PPUSH
 344: PPUSH
 345: PPUSH
 346: PPUSH
// tmp := [ b1_side , b2_side , b3_side , b4_side , b5_side ] ;
 347: LD_ADDR_VAR 0 7
 351: PUSH
 352: LD_EXP 6
 356: PUSH
 357: LD_EXP 19
 361: PUSH
 362: LD_EXP 32
 366: PUSH
 367: LD_EXP 45
 371: PUSH
 372: LD_EXP 58
 376: PUSH
 377: EMPTY
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: LIST
 383: ST_TO_ADDR
// side := [ ] ;
 384: LD_ADDR_VAR 0 6
 388: PUSH
 389: EMPTY
 390: ST_TO_ADDR
// s := [ ] ;
 391: LD_ADDR_VAR 0 4
 395: PUSH
 396: EMPTY
 397: ST_TO_ADDR
// for i = 1 to tmp do
 398: LD_ADDR_VAR 0 2
 402: PUSH
 403: DOUBLE
 404: LD_INT 1
 406: DEC
 407: ST_TO_ADDR
 408: LD_VAR 0 7
 412: PUSH
 413: FOR_TO
 414: IFFALSE 470
// if tmp [ i ] > 0 then
 416: LD_VAR 0 7
 420: PUSH
 421: LD_VAR 0 2
 425: ARRAY
 426: PUSH
 427: LD_INT 0
 429: GREATER
 430: IFFALSE 454
// side := side ^ 0 + i else
 432: LD_ADDR_VAR 0 6
 436: PUSH
 437: LD_VAR 0 6
 441: PUSH
 442: LD_INT 0
 444: PUSH
 445: LD_VAR 0 2
 449: PLUS
 450: ADD
 451: ST_TO_ADDR
 452: GO 468
// side := side ^ 0 ;
 454: LD_ADDR_VAR 0 6
 458: PUSH
 459: LD_VAR 0 6
 463: PUSH
 464: LD_INT 0
 466: ADD
 467: ST_TO_ADDR
 468: GO 413
 470: POP
 471: POP
// if side [ 1 ] > 0 then
 472: LD_VAR 0 6
 476: PUSH
 477: LD_INT 1
 479: ARRAY
 480: PUSH
 481: LD_INT 0
 483: GREATER
 484: IFFALSE 580
// begin b1_act := true ;
 486: LD_ADDR_EXP 1
 490: PUSH
 491: LD_INT 1
 493: ST_TO_ADDR
// s := [ b1_side , b1_nation , b1_people , b1_skill , b1_area ] ;
 494: LD_ADDR_VAR 0 4
 498: PUSH
 499: LD_EXP 6
 503: PUSH
 504: LD_EXP 7
 508: PUSH
 509: LD_EXP 9
 513: PUSH
 514: LD_EXP 10
 518: PUSH
 519: LD_EXP 8
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 531: LD_VAR 0 4
 535: PUSH
 536: LD_INT 1
 538: ARRAY
 539: PPUSH
 540: LD_VAR 0 4
 544: PUSH
 545: LD_INT 2
 547: ARRAY
 548: PPUSH
 549: LD_VAR 0 4
 553: PUSH
 554: LD_INT 3
 556: ARRAY
 557: PPUSH
 558: LD_VAR 0 4
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PPUSH
 567: LD_VAR 0 4
 571: PUSH
 572: LD_INT 5
 574: ARRAY
 575: PPUSH
 576: CALL 3033 0 5
// end ; if side [ 2 ] > 0 then
 580: LD_VAR 0 6
 584: PUSH
 585: LD_INT 2
 587: ARRAY
 588: PUSH
 589: LD_INT 0
 591: GREATER
 592: IFFALSE 688
// begin b2_act := true ;
 594: LD_ADDR_EXP 2
 598: PUSH
 599: LD_INT 1
 601: ST_TO_ADDR
// s := [ b2_side , b2_nation , b2_people , b2_skill , b2_area ] ;
 602: LD_ADDR_VAR 0 4
 606: PUSH
 607: LD_EXP 19
 611: PUSH
 612: LD_EXP 20
 616: PUSH
 617: LD_EXP 22
 621: PUSH
 622: LD_EXP 23
 626: PUSH
 627: LD_EXP 21
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 639: LD_VAR 0 4
 643: PUSH
 644: LD_INT 1
 646: ARRAY
 647: PPUSH
 648: LD_VAR 0 4
 652: PUSH
 653: LD_INT 2
 655: ARRAY
 656: PPUSH
 657: LD_VAR 0 4
 661: PUSH
 662: LD_INT 3
 664: ARRAY
 665: PPUSH
 666: LD_VAR 0 4
 670: PUSH
 671: LD_INT 4
 673: ARRAY
 674: PPUSH
 675: LD_VAR 0 4
 679: PUSH
 680: LD_INT 5
 682: ARRAY
 683: PPUSH
 684: CALL 3033 0 5
// end ; if side [ 3 ] > 0 then
 688: LD_VAR 0 6
 692: PUSH
 693: LD_INT 3
 695: ARRAY
 696: PUSH
 697: LD_INT 0
 699: GREATER
 700: IFFALSE 796
// begin b3_act := true ;
 702: LD_ADDR_EXP 3
 706: PUSH
 707: LD_INT 1
 709: ST_TO_ADDR
// s := [ b3_side , b3_nation , b3_people , b3_skill , b3_area ] ;
 710: LD_ADDR_VAR 0 4
 714: PUSH
 715: LD_EXP 32
 719: PUSH
 720: LD_EXP 33
 724: PUSH
 725: LD_EXP 35
 729: PUSH
 730: LD_EXP 36
 734: PUSH
 735: LD_EXP 34
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 747: LD_VAR 0 4
 751: PUSH
 752: LD_INT 1
 754: ARRAY
 755: PPUSH
 756: LD_VAR 0 4
 760: PUSH
 761: LD_INT 2
 763: ARRAY
 764: PPUSH
 765: LD_VAR 0 4
 769: PUSH
 770: LD_INT 3
 772: ARRAY
 773: PPUSH
 774: LD_VAR 0 4
 778: PUSH
 779: LD_INT 4
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 4
 787: PUSH
 788: LD_INT 5
 790: ARRAY
 791: PPUSH
 792: CALL 3033 0 5
// end ; if side [ 4 ] > 0 then
 796: LD_VAR 0 6
 800: PUSH
 801: LD_INT 4
 803: ARRAY
 804: PUSH
 805: LD_INT 0
 807: GREATER
 808: IFFALSE 904
// begin b4_act := true ;
 810: LD_ADDR_EXP 4
 814: PUSH
 815: LD_INT 1
 817: ST_TO_ADDR
// s := [ b4_side , b4_nation , b4_people , b4_skill , b4_area ] ;
 818: LD_ADDR_VAR 0 4
 822: PUSH
 823: LD_EXP 45
 827: PUSH
 828: LD_EXP 46
 832: PUSH
 833: LD_EXP 48
 837: PUSH
 838: LD_EXP 49
 842: PUSH
 843: LD_EXP 47
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 855: LD_VAR 0 4
 859: PUSH
 860: LD_INT 1
 862: ARRAY
 863: PPUSH
 864: LD_VAR 0 4
 868: PUSH
 869: LD_INT 2
 871: ARRAY
 872: PPUSH
 873: LD_VAR 0 4
 877: PUSH
 878: LD_INT 3
 880: ARRAY
 881: PPUSH
 882: LD_VAR 0 4
 886: PUSH
 887: LD_INT 4
 889: ARRAY
 890: PPUSH
 891: LD_VAR 0 4
 895: PUSH
 896: LD_INT 5
 898: ARRAY
 899: PPUSH
 900: CALL 3033 0 5
// end ; if side [ 5 ] > 0 then
 904: LD_VAR 0 6
 908: PUSH
 909: LD_INT 5
 911: ARRAY
 912: PUSH
 913: LD_INT 0
 915: GREATER
 916: IFFALSE 1012
// begin b5_act := true ;
 918: LD_ADDR_EXP 5
 922: PUSH
 923: LD_INT 1
 925: ST_TO_ADDR
// s := [ b5_side , b5_nation , b5_people , b5_skill , b5_area ] ;
 926: LD_ADDR_VAR 0 4
 930: PUSH
 931: LD_EXP 58
 935: PUSH
 936: LD_EXP 59
 940: PUSH
 941: LD_EXP 61
 945: PUSH
 946: LD_EXP 62
 950: PUSH
 951: LD_EXP 60
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: LIST
 962: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 963: LD_VAR 0 4
 967: PUSH
 968: LD_INT 1
 970: ARRAY
 971: PPUSH
 972: LD_VAR 0 4
 976: PUSH
 977: LD_INT 2
 979: ARRAY
 980: PPUSH
 981: LD_VAR 0 4
 985: PUSH
 986: LD_INT 3
 988: ARRAY
 989: PPUSH
 990: LD_VAR 0 4
 994: PUSH
 995: LD_INT 4
 997: ARRAY
 998: PPUSH
 999: LD_VAR 0 4
1003: PUSH
1004: LD_INT 5
1006: ARRAY
1007: PPUSH
1008: CALL 3033 0 5
// end ; InitBotTech ( ) ;
1012: CALL 1021 0 0
// end ;
1016: LD_VAR 0 1
1020: RET
// export function InitBotTech ( ) ; begin
1021: LD_INT 0
1023: PPUSH
// b1_tech := [ ] ;
1024: LD_ADDR_EXP 72
1028: PUSH
1029: EMPTY
1030: ST_TO_ADDR
// b2_tech := [ ] ;
1031: LD_ADDR_EXP 73
1035: PUSH
1036: EMPTY
1037: ST_TO_ADDR
// b3_tech := [ ] ;
1038: LD_ADDR_EXP 74
1042: PUSH
1043: EMPTY
1044: ST_TO_ADDR
// b4_tech := [ ] ;
1045: LD_ADDR_EXP 75
1049: PUSH
1050: EMPTY
1051: ST_TO_ADDR
// b5_tech := [ ] ;
1052: LD_ADDR_EXP 76
1056: PUSH
1057: EMPTY
1058: ST_TO_ADDR
// end ; end_of_file
1059: LD_VAR 0 1
1063: RET
// export tech_weap , tech_opto , tech_sib , tech_time , tech_comp , tech_bio , tech_lab ; export function lab_variable ( ) ; begin
1064: LD_INT 0
1066: PPUSH
// tech_lab := [ 35 , 48 , 49 , 45 , 46 , 47 , 1 , 50 , 20 ] ;
1067: LD_ADDR_EXP 83
1071: PUSH
1072: LD_INT 35
1074: PUSH
1075: LD_INT 48
1077: PUSH
1078: LD_INT 49
1080: PUSH
1081: LD_INT 45
1083: PUSH
1084: LD_INT 46
1086: PUSH
1087: LD_INT 47
1089: PUSH
1090: LD_INT 1
1092: PUSH
1093: LD_INT 50
1095: PUSH
1096: LD_INT 20
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: ST_TO_ADDR
// tech_weap := [ 51 , 69 , 52 , 39 , 70 ] ;
1110: LD_ADDR_EXP 77
1114: PUSH
1115: LD_INT 51
1117: PUSH
1118: LD_INT 69
1120: PUSH
1121: LD_INT 52
1123: PUSH
1124: LD_INT 39
1126: PUSH
1127: LD_INT 70
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: ST_TO_ADDR
// end ;
1137: LD_VAR 0 1
1141: RET
// export function AddDeposits ( bool ) ; var i , j , normal_oil , extra_oil , normal_sib , extra_sib ; begin
1142: LD_INT 0
1144: PPUSH
1145: PPUSH
1146: PPUSH
1147: PPUSH
1148: PPUSH
1149: PPUSH
1150: PPUSH
// normal_oil := [ [ 28 , 22 ] , [ 69 , 3 ] , [ 138 , 27 ] , [ 180 , 104 ] , [ 138 , 137 ] , [ 76 , 115 ] ] ;
1151: LD_ADDR_VAR 0 5
1155: PUSH
1156: LD_INT 28
1158: PUSH
1159: LD_INT 22
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: PUSH
1166: LD_INT 69
1168: PUSH
1169: LD_INT 3
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 138
1178: PUSH
1179: LD_INT 27
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 180
1188: PUSH
1189: LD_INT 104
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: PUSH
1196: LD_INT 138
1198: PUSH
1199: LD_INT 137
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PUSH
1206: LD_INT 76
1208: PUSH
1209: LD_INT 115
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: ST_TO_ADDR
// extra_oil := [ [ [ 31 , 38 ] , [ 34 , 21 ] ] , [ [ 58 , 4 ] , [ 82 , 4 ] ] , [ [ 122 , 18 ] , [ 152 , 43 ] ] , [ [ 174 , 90 ] , [ 180 , 120 ] ] , [ [ 152 , 136 ] , [ 130 , 136 ] ] , [ [ 89 , 116 ] , [ 59 , 89 ] ] ] ;
1224: LD_ADDR_VAR 0 6
1228: PUSH
1229: LD_INT 31
1231: PUSH
1232: LD_INT 38
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: PUSH
1239: LD_INT 34
1241: PUSH
1242: LD_INT 21
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: PUSH
1253: LD_INT 58
1255: PUSH
1256: LD_INT 4
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 82
1265: PUSH
1266: LD_INT 4
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 122
1279: PUSH
1280: LD_INT 18
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: PUSH
1287: LD_INT 152
1289: PUSH
1290: LD_INT 43
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: PUSH
1301: LD_INT 174
1303: PUSH
1304: LD_INT 90
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: PUSH
1311: LD_INT 180
1313: PUSH
1314: LD_INT 120
1316: PUSH
1317: EMPTY
1318: LIST
1319: LIST
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 152
1327: PUSH
1328: LD_INT 136
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: PUSH
1335: LD_INT 130
1337: PUSH
1338: LD_INT 136
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: PUSH
1349: LD_INT 89
1351: PUSH
1352: LD_INT 116
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 59
1361: PUSH
1362: LD_INT 89
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: ST_TO_ADDR
// normal_sib := [ [ 28 , 26 ] , [ 73 , 3 ] , [ 133 , 22 ] , [ 180 , 110 ] , [ 142 , 137 ] , [ 72 , 112 ] ] ;
1381: LD_ADDR_VAR 0 7
1385: PUSH
1386: LD_INT 28
1388: PUSH
1389: LD_INT 26
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: PUSH
1396: LD_INT 73
1398: PUSH
1399: LD_INT 3
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: PUSH
1406: LD_INT 133
1408: PUSH
1409: LD_INT 22
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PUSH
1416: LD_INT 180
1418: PUSH
1419: LD_INT 110
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: PUSH
1426: LD_INT 142
1428: PUSH
1429: LD_INT 137
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: PUSH
1436: LD_INT 72
1438: PUSH
1439: LD_INT 112
1441: PUSH
1442: EMPTY
1443: LIST
1444: LIST
1445: PUSH
1446: EMPTY
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: ST_TO_ADDR
// extra_sib := [ [ [ 27 , 39 ] , [ 30 , 16 ] ] , [ [ 57 , 8 ] , [ 87 , 8 ] ] , [ [ 128 , 19 ] , [ 146 , 36 ] ] , [ [ 176 , 121 ] , [ 179 , 96 ] ] , [ [ 153 , 132 ] , [ 124 , 133 ] ] , [ [ 85 , 117 ] , [ 62 , 96 ] ] ] ;
1454: LD_ADDR_VAR 0 8
1458: PUSH
1459: LD_INT 27
1461: PUSH
1462: LD_INT 39
1464: PUSH
1465: EMPTY
1466: LIST
1467: LIST
1468: PUSH
1469: LD_INT 30
1471: PUSH
1472: LD_INT 16
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 57
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: PUSH
1493: LD_INT 87
1495: PUSH
1496: LD_INT 8
1498: PUSH
1499: EMPTY
1500: LIST
1501: LIST
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: PUSH
1507: LD_INT 128
1509: PUSH
1510: LD_INT 19
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 146
1519: PUSH
1520: LD_INT 36
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 176
1533: PUSH
1534: LD_INT 121
1536: PUSH
1537: EMPTY
1538: LIST
1539: LIST
1540: PUSH
1541: LD_INT 179
1543: PUSH
1544: LD_INT 96
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 153
1557: PUSH
1558: LD_INT 132
1560: PUSH
1561: EMPTY
1562: LIST
1563: LIST
1564: PUSH
1565: LD_INT 124
1567: PUSH
1568: LD_INT 133
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: PUSH
1579: LD_INT 85
1581: PUSH
1582: LD_INT 117
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: LD_INT 62
1591: PUSH
1592: LD_INT 96
1594: PUSH
1595: EMPTY
1596: LIST
1597: LIST
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// if bool then
1611: LD_VAR 0 1
1615: IFFALSE 1757
// begin for i = 1 to 6 do
1617: LD_ADDR_VAR 0 3
1621: PUSH
1622: DOUBLE
1623: LD_INT 1
1625: DEC
1626: ST_TO_ADDR
1627: LD_INT 6
1629: PUSH
1630: FOR_TO
1631: IFFALSE 1753
// for j = 1 to 2 do
1633: LD_ADDR_VAR 0 4
1637: PUSH
1638: DOUBLE
1639: LD_INT 1
1641: DEC
1642: ST_TO_ADDR
1643: LD_INT 2
1645: PUSH
1646: FOR_TO
1647: IFFALSE 1749
// begin CreateDepositXY ( extra_sib [ i ] [ j ] [ 1 ] , extra_sib [ i ] [ j ] [ 2 ] , mat_siberit ) ;
1649: LD_VAR 0 8
1653: PUSH
1654: LD_VAR 0 3
1658: ARRAY
1659: PUSH
1660: LD_VAR 0 4
1664: ARRAY
1665: PUSH
1666: LD_INT 1
1668: ARRAY
1669: PPUSH
1670: LD_VAR 0 8
1674: PUSH
1675: LD_VAR 0 3
1679: ARRAY
1680: PUSH
1681: LD_VAR 0 4
1685: ARRAY
1686: PUSH
1687: LD_INT 2
1689: ARRAY
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: CALL_OW 62
// CreateDepositXY ( extra_oil [ i ] [ j ] [ 1 ] , extra_oil [ i ] [ j ] [ 2 ] , mat_oil ) ;
1698: LD_VAR 0 6
1702: PUSH
1703: LD_VAR 0 3
1707: ARRAY
1708: PUSH
1709: LD_VAR 0 4
1713: ARRAY
1714: PUSH
1715: LD_INT 1
1717: ARRAY
1718: PPUSH
1719: LD_VAR 0 6
1723: PUSH
1724: LD_VAR 0 3
1728: ARRAY
1729: PUSH
1730: LD_VAR 0 4
1734: ARRAY
1735: PUSH
1736: LD_INT 2
1738: ARRAY
1739: PPUSH
1740: LD_INT 2
1742: PPUSH
1743: CALL_OW 62
// end ;
1747: GO 1646
1749: POP
1750: POP
1751: GO 1630
1753: POP
1754: POP
// end else
1755: GO 1851
// begin for j = 1 to 6 do
1757: LD_ADDR_VAR 0 4
1761: PUSH
1762: DOUBLE
1763: LD_INT 1
1765: DEC
1766: ST_TO_ADDR
1767: LD_INT 6
1769: PUSH
1770: FOR_TO
1771: IFFALSE 1849
// begin CreateDepositXY ( normal_sib [ j ] [ 1 ] , normal_sib [ j ] [ 2 ] , mat_siberit ) ;
1773: LD_VAR 0 7
1777: PUSH
1778: LD_VAR 0 4
1782: ARRAY
1783: PUSH
1784: LD_INT 1
1786: ARRAY
1787: PPUSH
1788: LD_VAR 0 7
1792: PUSH
1793: LD_VAR 0 4
1797: ARRAY
1798: PUSH
1799: LD_INT 2
1801: ARRAY
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: CALL_OW 62
// CreateDepositXY ( normal_oil [ j ] [ 1 ] , normal_oil [ j ] [ 2 ] , mat_oil ) ;
1810: LD_VAR 0 5
1814: PUSH
1815: LD_VAR 0 4
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_VAR 0 5
1829: PUSH
1830: LD_VAR 0 4
1834: ARRAY
1835: PUSH
1836: LD_INT 2
1838: ARRAY
1839: PPUSH
1840: LD_INT 2
1842: PPUSH
1843: CALL_OW 62
// end ;
1847: GO 1770
1849: POP
1850: POP
// end ; super_source := bool ;
1851: LD_ADDR_EXP 71
1855: PUSH
1856: LD_VAR 0 1
1860: ST_TO_ADDR
// end ;
1861: LD_VAR 0 2
1865: RET
// export function UnitExist ( id , val ) ; begin
1866: LD_INT 0
1868: PPUSH
// if GetLives ( id ) >= val then
1869: LD_VAR 0 1
1873: PPUSH
1874: CALL_OW 256
1878: PUSH
1879: LD_VAR 0 2
1883: GREATEREQUAL
1884: IFFALSE 1896
// result := true else
1886: LD_ADDR_VAR 0 3
1890: PUSH
1891: LD_INT 1
1893: ST_TO_ADDR
1894: GO 1904
// result := false ;
1896: LD_ADDR_VAR 0 3
1900: PUSH
1901: LD_INT 0
1903: ST_TO_ADDR
// end ;
1904: LD_VAR 0 3
1908: RET
// export function AnyBuildingExist ( side , typ ) ; begin
1909: LD_INT 0
1911: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , typ ] ] ) > 0 then
1912: LD_INT 22
1914: PUSH
1915: LD_VAR 0 1
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: PUSH
1924: LD_INT 30
1926: PUSH
1927: LD_VAR 0 2
1931: PUSH
1932: EMPTY
1933: LIST
1934: LIST
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: PPUSH
1940: CALL_OW 69
1944: PUSH
1945: LD_INT 0
1947: GREATER
1948: IFFALSE 1960
// result := true else
1950: LD_ADDR_VAR 0 3
1954: PUSH
1955: LD_INT 1
1957: ST_TO_ADDR
1958: GO 1968
// result := false ;
1960: LD_ADDR_VAR 0 3
1964: PUSH
1965: LD_INT 0
1967: ST_TO_ADDR
// end ;
1968: LD_VAR 0 3
1972: RET
// export function ComRetreat ( un ) ; var coord_dist , dir , x , y ; begin
1973: LD_INT 0
1975: PPUSH
1976: PPUSH
1977: PPUSH
1978: PPUSH
1979: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
1980: LD_VAR 0 1
1984: PPUSH
1985: LD_INT 81
1987: PUSH
1988: LD_VAR 0 1
1992: PPUSH
1993: CALL_OW 255
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PPUSH
2002: CALL_OW 69
2006: PPUSH
2007: LD_VAR 0 1
2011: PPUSH
2012: CALL_OW 74
2016: PPUSH
2017: CALL_OW 119
// dir := GetDir ( un ) ;
2021: LD_ADDR_VAR 0 4
2025: PUSH
2026: LD_VAR 0 1
2030: PPUSH
2031: CALL_OW 254
2035: ST_TO_ADDR
// dir := dir - 3 ;
2036: LD_ADDR_VAR 0 4
2040: PUSH
2041: LD_VAR 0 4
2045: PUSH
2046: LD_INT 3
2048: MINUS
2049: ST_TO_ADDR
// if dir < 0 then
2050: LD_VAR 0 4
2054: PUSH
2055: LD_INT 0
2057: LESS
2058: IFFALSE 2074
// dir := dir + 6 ;
2060: LD_ADDR_VAR 0 4
2064: PUSH
2065: LD_VAR 0 4
2069: PUSH
2070: LD_INT 6
2072: PLUS
2073: ST_TO_ADDR
// while true do
2074: LD_INT 1
2076: IFFALSE 2489
// begin coord_dist := 3 ;
2078: LD_ADDR_VAR 0 3
2082: PUSH
2083: LD_INT 3
2085: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
2086: LD_ADDR_VAR 0 5
2090: PUSH
2091: LD_VAR 0 1
2095: PPUSH
2096: CALL_OW 250
2100: PPUSH
2101: LD_VAR 0 4
2105: PPUSH
2106: LD_VAR 0 3
2110: PPUSH
2111: CALL_OW 272
2115: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
2116: LD_ADDR_VAR 0 6
2120: PUSH
2121: LD_VAR 0 1
2125: PPUSH
2126: CALL_OW 251
2130: PPUSH
2131: LD_VAR 0 4
2135: PPUSH
2136: LD_VAR 0 3
2140: PPUSH
2141: CALL_OW 273
2145: ST_TO_ADDR
// if IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or InArea ( x , y , HexEmpty ) = 0 or HexInfo ( x , y ) <> 0 then
2146: LD_VAR 0 5
2150: PPUSH
2151: LD_VAR 0 6
2155: PPUSH
2156: CALL_OW 351
2160: PUSH
2161: LD_VAR 0 5
2165: PPUSH
2166: LD_VAR 0 6
2170: PPUSH
2171: CALL_OW 488
2175: PUSH
2176: LD_INT 0
2178: EQUAL
2179: OR
2180: PUSH
2181: LD_VAR 0 5
2185: PPUSH
2186: LD_VAR 0 6
2190: PPUSH
2191: LD_INT 15
2193: PPUSH
2194: CALL_OW 309
2198: PUSH
2199: LD_INT 0
2201: EQUAL
2202: OR
2203: PUSH
2204: LD_VAR 0 5
2208: PPUSH
2209: LD_VAR 0 6
2213: PPUSH
2214: CALL_OW 428
2218: PUSH
2219: LD_INT 0
2221: NONEQUAL
2222: OR
2223: IFFALSE 2403
// begin repeat begin coord_dist := coord_dist + 1 ;
2225: LD_ADDR_VAR 0 3
2229: PUSH
2230: LD_VAR 0 3
2234: PUSH
2235: LD_INT 1
2237: PLUS
2238: ST_TO_ADDR
// dir := dir + 1 ;
2239: LD_ADDR_VAR 0 4
2243: PUSH
2244: LD_VAR 0 4
2248: PUSH
2249: LD_INT 1
2251: PLUS
2252: ST_TO_ADDR
// if dir > 5 then
2253: LD_VAR 0 4
2257: PUSH
2258: LD_INT 5
2260: GREATER
2261: IFFALSE 2271
// dir = 0 ;
2263: LD_ADDR_VAR 0 4
2267: PUSH
2268: LD_INT 0
2270: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
2271: LD_ADDR_VAR 0 5
2275: PUSH
2276: LD_VAR 0 1
2280: PPUSH
2281: CALL_OW 250
2285: PPUSH
2286: LD_VAR 0 4
2290: PPUSH
2291: LD_VAR 0 3
2295: PPUSH
2296: CALL_OW 272
2300: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
2301: LD_ADDR_VAR 0 6
2305: PUSH
2306: LD_VAR 0 1
2310: PPUSH
2311: CALL_OW 251
2315: PPUSH
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_VAR 0 3
2325: PPUSH
2326: CALL_OW 273
2330: ST_TO_ADDR
// end until not IsEnvironment ( x , y ) and ValidHex ( x , y ) and InArea ( x , y , HexEmpty ) and HexInfo ( x , y ) = 0 ;
2331: LD_VAR 0 5
2335: PPUSH
2336: LD_VAR 0 6
2340: PPUSH
2341: CALL_OW 351
2345: NOT
2346: PUSH
2347: LD_VAR 0 5
2351: PPUSH
2352: LD_VAR 0 6
2356: PPUSH
2357: CALL_OW 488
2361: AND
2362: PUSH
2363: LD_VAR 0 5
2367: PPUSH
2368: LD_VAR 0 6
2372: PPUSH
2373: LD_INT 15
2375: PPUSH
2376: CALL_OW 309
2380: AND
2381: PUSH
2382: LD_VAR 0 5
2386: PPUSH
2387: LD_VAR 0 6
2391: PPUSH
2392: CALL_OW 428
2396: PUSH
2397: LD_INT 0
2399: EQUAL
2400: AND
2401: IFFALSE 2225
// end ; AddComMoveXY ( un , x , y ) ;
2403: LD_VAR 0 1
2407: PPUSH
2408: LD_VAR 0 5
2412: PPUSH
2413: LD_VAR 0 6
2417: PPUSH
2418: CALL_OW 171
// Wait ( 0 0$1 ) ;
2422: LD_INT 35
2424: PPUSH
2425: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 16 then
2429: LD_VAR 0 1
2433: PPUSH
2434: LD_INT 81
2436: PUSH
2437: LD_VAR 0 1
2441: PPUSH
2442: CALL_OW 255
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PPUSH
2451: CALL_OW 69
2455: PPUSH
2456: LD_VAR 0 1
2460: PPUSH
2461: CALL_OW 74
2465: PPUSH
2466: CALL_OW 296
2470: PUSH
2471: LD_INT 16
2473: GREATEREQUAL
2474: IFFALSE 2487
// begin ComStop ( un ) ;
2476: LD_VAR 0 1
2480: PPUSH
2481: CALL_OW 141
// break ;
2485: GO 2489
// end ; end ;
2487: GO 2074
// end ;
2489: LD_VAR 0 2
2493: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
2494: LD_INT 0
2496: PPUSH
2497: PPUSH
2498: PPUSH
2499: PPUSH
2500: PPUSH
2501: PPUSH
// hc_class := clas ;
2502: LD_ADDR_OWVAR 28
2506: PUSH
2507: LD_VAR 0 1
2511: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
2512: LD_ADDR_VAR 0 4
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_INT 1
2524: NEG
2525: PPUSH
2526: LD_INT 1
2528: PPUSH
2529: CALL_OW 12
2533: PLUS
2534: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
2535: LD_ADDR_VAR 0 5
2539: PUSH
2540: LD_VAR 0 2
2544: PUSH
2545: LD_INT 1
2547: NEG
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 12
2556: PLUS
2557: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
2558: LD_ADDR_VAR 0 6
2562: PUSH
2563: LD_VAR 0 2
2567: PUSH
2568: LD_INT 1
2570: NEG
2571: PPUSH
2572: LD_INT 1
2574: PPUSH
2575: CALL_OW 12
2579: PLUS
2580: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
2581: LD_ADDR_VAR 0 7
2585: PUSH
2586: LD_VAR 0 2
2590: PUSH
2591: LD_INT 1
2593: NEG
2594: PPUSH
2595: LD_INT 1
2597: PPUSH
2598: CALL_OW 12
2602: PLUS
2603: ST_TO_ADDR
// if clas = 1 or clas = class_bazooker or clas = class_sniper or clas = class_mortar then
2604: LD_VAR 0 1
2608: PUSH
2609: LD_INT 1
2611: EQUAL
2612: PUSH
2613: LD_VAR 0 1
2617: PUSH
2618: LD_INT 9
2620: EQUAL
2621: OR
2622: PUSH
2623: LD_VAR 0 1
2627: PUSH
2628: LD_INT 5
2630: EQUAL
2631: OR
2632: PUSH
2633: LD_VAR 0 1
2637: PUSH
2638: LD_INT 8
2640: EQUAL
2641: OR
2642: IFFALSE 2667
// bonus := [ 2 , 0 , 0 , 0 ] ;
2644: LD_ADDR_VAR 0 8
2648: PUSH
2649: LD_INT 2
2651: PUSH
2652: LD_INT 0
2654: PUSH
2655: LD_INT 0
2657: PUSH
2658: LD_INT 0
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// if clas = 2 then
2667: LD_VAR 0 1
2671: PUSH
2672: LD_INT 2
2674: EQUAL
2675: IFFALSE 2700
// bonus := [ 0 , 2 , 0 , 0 ] ;
2677: LD_ADDR_VAR 0 8
2681: PUSH
2682: LD_INT 0
2684: PUSH
2685: LD_INT 2
2687: PUSH
2688: LD_INT 0
2690: PUSH
2691: LD_INT 0
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: LIST
2698: LIST
2699: ST_TO_ADDR
// if clas = 3 then
2700: LD_VAR 0 1
2704: PUSH
2705: LD_INT 3
2707: EQUAL
2708: IFFALSE 2733
// bonus := [ 0 , 0 , 2 , 0 ] ;
2710: LD_ADDR_VAR 0 8
2714: PUSH
2715: LD_INT 0
2717: PUSH
2718: LD_INT 0
2720: PUSH
2721: LD_INT 2
2723: PUSH
2724: LD_INT 0
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: ST_TO_ADDR
// if clas = 4 then
2733: LD_VAR 0 1
2737: PUSH
2738: LD_INT 4
2740: EQUAL
2741: IFFALSE 2766
// bonus := [ 0 , 0 , 0 , 2 ] ;
2743: LD_ADDR_VAR 0 8
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: LD_INT 0
2753: PUSH
2754: LD_INT 0
2756: PUSH
2757: LD_INT 2
2759: PUSH
2760: EMPTY
2761: LIST
2762: LIST
2763: LIST
2764: LIST
2765: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
2766: LD_VAR 0 1
2770: PUSH
2771: LD_INT 4
2773: GREATER
2774: PUSH
2775: LD_VAR 0 1
2779: PUSH
2780: LD_INT 9
2782: NONEQUAL
2783: AND
2784: PUSH
2785: LD_VAR 0 1
2789: PUSH
2790: LD_INT 5
2792: NONEQUAL
2793: AND
2794: PUSH
2795: LD_VAR 0 1
2799: PUSH
2800: LD_INT 8
2802: NONEQUAL
2803: AND
2804: IFFALSE 2829
// bonus := [ 0 , 0 , 0 , 0 ] ;
2806: LD_ADDR_VAR 0 8
2810: PUSH
2811: LD_INT 0
2813: PUSH
2814: LD_INT 0
2816: PUSH
2817: LD_INT 0
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: EMPTY
2824: LIST
2825: LIST
2826: LIST
2827: LIST
2828: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2829: LD_ADDR_OWVAR 30
2833: PUSH
2834: LD_INT 0
2836: PPUSH
2837: LD_INT 2
2839: PPUSH
2840: CALL_OW 12
2844: PUSH
2845: LD_INT 0
2847: PPUSH
2848: LD_INT 2
2850: PPUSH
2851: CALL_OW 12
2855: PUSH
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 2
2861: PPUSH
2862: CALL_OW 12
2866: PUSH
2867: LD_INT 0
2869: PPUSH
2870: LD_INT 2
2872: PPUSH
2873: CALL_OW 12
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: LIST
2882: LIST
2883: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
2884: LD_ADDR_OWVAR 31
2888: PUSH
2889: LD_VAR 0 4
2893: PUSH
2894: LD_VAR 0 8
2898: PUSH
2899: LD_INT 1
2901: ARRAY
2902: PLUS
2903: PUSH
2904: LD_VAR 0 5
2908: PUSH
2909: LD_VAR 0 8
2913: PUSH
2914: LD_INT 2
2916: ARRAY
2917: PLUS
2918: PUSH
2919: LD_VAR 0 6
2923: PUSH
2924: LD_VAR 0 8
2928: PUSH
2929: LD_INT 3
2931: ARRAY
2932: PLUS
2933: PUSH
2934: LD_VAR 0 7
2938: PUSH
2939: LD_VAR 0 8
2943: PUSH
2944: LD_INT 4
2946: ARRAY
2947: PLUS
2948: PUSH
2949: EMPTY
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
2955: LD_ADDR_OWVAR 27
2959: PUSH
2960: LD_INT 1
2962: PPUSH
2963: LD_INT 2
2965: PPUSH
2966: CALL_OW 12
2970: ST_TO_ADDR
// hc_gallery :=  ;
2971: LD_ADDR_OWVAR 33
2975: PUSH
2976: LD_STRING 
2978: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
2979: LD_ADDR_OWVAR 29
2983: PUSH
2984: LD_INT 8
2986: PPUSH
2987: LD_INT 12
2989: PPUSH
2990: CALL_OW 12
2994: PUSH
2995: LD_INT 9
2997: PPUSH
2998: LD_INT 11
3000: PPUSH
3001: CALL_OW 12
3005: PUSH
3006: EMPTY
3007: LIST
3008: LIST
3009: ST_TO_ADDR
// hc_name :=  ;
3010: LD_ADDR_OWVAR 26
3014: PUSH
3015: LD_STRING 
3017: ST_TO_ADDR
// result := CreateHuman ;
3018: LD_ADDR_VAR 0 3
3022: PUSH
3023: CALL_OW 44
3027: ST_TO_ADDR
// end ;
3028: LD_VAR 0 3
3032: RET
// export function scs_create_squad ( side , nation , people , skill , area ) ; var i , num , un ; begin
3033: LD_INT 0
3035: PPUSH
3036: PPUSH
3037: PPUSH
3038: PPUSH
// num := people / 4 ;
3039: LD_ADDR_VAR 0 8
3043: PUSH
3044: LD_VAR 0 3
3048: PUSH
3049: LD_INT 4
3051: DIVREAL
3052: ST_TO_ADDR
// uc_side := side ;
3053: LD_ADDR_OWVAR 20
3057: PUSH
3058: LD_VAR 0 1
3062: ST_TO_ADDR
// uc_nation := nation ;
3063: LD_ADDR_OWVAR 21
3067: PUSH
3068: LD_VAR 0 2
3072: ST_TO_ADDR
// hc_importance := 100 ;
3073: LD_ADDR_OWVAR 32
3077: PUSH
3078: LD_INT 100
3080: ST_TO_ADDR
// un := CreateHumanWithClass ( 1 , skill ) ;
3081: LD_ADDR_VAR 0 9
3085: PUSH
3086: LD_INT 1
3088: PPUSH
3089: LD_VAR 0 4
3093: PPUSH
3094: CALL 2494 0 2
3098: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
3099: LD_VAR 0 9
3103: PPUSH
3104: LD_VAR 0 5
3108: PPUSH
3109: LD_INT 0
3111: PPUSH
3112: CALL_OW 49
// hc_importance := 0 ;
3116: LD_ADDR_OWVAR 32
3120: PUSH
3121: LD_INT 0
3123: ST_TO_ADDR
// for i = 1 to num do
3124: LD_ADDR_VAR 0 7
3128: PUSH
3129: DOUBLE
3130: LD_INT 1
3132: DEC
3133: ST_TO_ADDR
3134: LD_VAR 0 8
3138: PUSH
3139: FOR_TO
3140: IFFALSE 3169
// PlaceUnitArea ( CreateHumanWithClass ( 1 , skill ) , area , false ) ;
3142: LD_INT 1
3144: PPUSH
3145: LD_VAR 0 4
3149: PPUSH
3150: CALL 2494 0 2
3154: PPUSH
3155: LD_VAR 0 5
3159: PPUSH
3160: LD_INT 0
3162: PPUSH
3163: CALL_OW 49
3167: GO 3139
3169: POP
3170: POP
// for i = 1 to num do
3171: LD_ADDR_VAR 0 7
3175: PUSH
3176: DOUBLE
3177: LD_INT 1
3179: DEC
3180: ST_TO_ADDR
3181: LD_VAR 0 8
3185: PUSH
3186: FOR_TO
3187: IFFALSE 3216
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , area , false ) ;
3189: LD_INT 2
3191: PPUSH
3192: LD_VAR 0 4
3196: PPUSH
3197: CALL 2494 0 2
3201: PPUSH
3202: LD_VAR 0 5
3206: PPUSH
3207: LD_INT 0
3209: PPUSH
3210: CALL_OW 49
3214: GO 3186
3216: POP
3217: POP
// for i = 1 to num do
3218: LD_ADDR_VAR 0 7
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_VAR 0 8
3232: PUSH
3233: FOR_TO
3234: IFFALSE 3263
// PlaceUnitArea ( CreateHumanWithClass ( 3 , skill ) , area , false ) ;
3236: LD_INT 3
3238: PPUSH
3239: LD_VAR 0 4
3243: PPUSH
3244: CALL 2494 0 2
3248: PPUSH
3249: LD_VAR 0 5
3253: PPUSH
3254: LD_INT 0
3256: PPUSH
3257: CALL_OW 49
3261: GO 3233
3263: POP
3264: POP
// for i = 1 to num do
3265: LD_ADDR_VAR 0 7
3269: PUSH
3270: DOUBLE
3271: LD_INT 1
3273: DEC
3274: ST_TO_ADDR
3275: LD_VAR 0 8
3279: PUSH
3280: FOR_TO
3281: IFFALSE 3310
// PlaceUnitArea ( CreateHumanWithClass ( 4 , skill ) , area , false ) ;
3283: LD_INT 4
3285: PPUSH
3286: LD_VAR 0 4
3290: PPUSH
3291: CALL 2494 0 2
3295: PPUSH
3296: LD_VAR 0 5
3300: PPUSH
3301: LD_INT 0
3303: PPUSH
3304: CALL_OW 49
3308: GO 3280
3310: POP
3311: POP
// end ;
3312: LD_VAR 0 6
3316: RET
// export function scs_scan_side ( side ) ; begin
3317: LD_INT 0
3319: PPUSH
// result := FilterAllUnits ( [ f_side , side ] ) ;
3320: LD_ADDR_VAR 0 2
3324: PUSH
3325: LD_INT 22
3327: PUSH
3328: LD_VAR 0 1
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PPUSH
3337: CALL_OW 69
3341: ST_TO_ADDR
// end ;
3342: LD_VAR 0 2
3346: RET
// export function scs_clear_side ( side ) ; var i , filter ; begin
3347: LD_INT 0
3349: PPUSH
3350: PPUSH
3351: PPUSH
// filter := scs_scan_side ( side ) ;
3352: LD_ADDR_VAR 0 4
3356: PUSH
3357: LD_VAR 0 1
3361: PPUSH
3362: CALL 3317 0 1
3366: ST_TO_ADDR
// for i = 1 to filter do
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: DOUBLE
3373: LD_INT 1
3375: DEC
3376: ST_TO_ADDR
3377: LD_VAR 0 4
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3402
// RemoveUnit ( filter [ i ] ) ;
3385: LD_VAR 0 4
3389: PUSH
3390: LD_VAR 0 3
3394: ARRAY
3395: PPUSH
3396: CALL_OW 64
3400: GO 3382
3402: POP
3403: POP
// end ;
3404: LD_VAR 0 2
3408: RET
// export function scs_scan_class ( side , clas , bool ) ; begin
3409: LD_INT 0
3411: PPUSH
// if bool = false then
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 0
3419: EQUAL
3420: IFFALSE 3462
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , clas ] ] ) else
3422: LD_ADDR_VAR 0 4
3426: PUSH
3427: LD_INT 22
3429: PUSH
3430: LD_VAR 0 1
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 25
3441: PUSH
3442: LD_VAR 0 2
3446: PUSH
3447: EMPTY
3448: LIST
3449: LIST
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: PPUSH
3455: CALL_OW 69
3459: ST_TO_ADDR
3460: GO 3507
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , clas ] , [ f_ok ] ] ) end ;
3462: LD_ADDR_VAR 0 4
3466: PUSH
3467: LD_INT 22
3469: PUSH
3470: LD_VAR 0 1
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: PUSH
3479: LD_INT 25
3481: PUSH
3482: LD_VAR 0 2
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PUSH
3491: LD_INT 50
3493: PUSH
3494: EMPTY
3495: LIST
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: LIST
3501: PPUSH
3502: CALL_OW 69
3506: ST_TO_ADDR
3507: LD_VAR 0 4
3511: RET
// export function scs_scan_damage ( side , value ) ; begin
3512: LD_INT 0
3514: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_lives , value ] ] ] ) ;
3515: LD_ADDR_VAR 0 3
3519: PUSH
3520: LD_INT 22
3522: PUSH
3523: LD_VAR 0 1
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: LD_INT 24
3537: PUSH
3538: LD_VAR 0 2
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: PPUSH
3555: CALL_OW 69
3559: ST_TO_ADDR
// end ;
3560: LD_VAR 0 3
3564: RET
// export function scs_scan_area ( side , x , y , dist ) ; var enemy ; begin
3565: LD_INT 0
3567: PPUSH
3568: PPUSH
// enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
3569: LD_ADDR_VAR 0 6
3573: PUSH
3574: LD_INT 81
3576: PUSH
3577: LD_VAR 0 1
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 92
3588: PUSH
3589: LD_VAR 0 2
3593: PUSH
3594: LD_VAR 0 3
3598: PUSH
3599: LD_VAR 0 4
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 69
3618: ST_TO_ADDR
// if enemy > 0 then
3619: LD_VAR 0 6
3623: PUSH
3624: LD_INT 0
3626: GREATER
3627: IFFALSE 3639
// result := true else
3629: LD_ADDR_VAR 0 5
3633: PUSH
3634: LD_INT 1
3636: ST_TO_ADDR
3637: GO 3647
// result := false ;
3639: LD_ADDR_VAR 0 5
3643: PUSH
3644: LD_INT 0
3646: ST_TO_ADDR
// end ;
3647: LD_VAR 0 5
3651: RET
// export function scs_scan_lab ( side ) ; begin
3652: LD_INT 0
3654: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3655: LD_ADDR_VAR 0 2
3659: PUSH
3660: LD_INT 22
3662: PUSH
3663: LD_VAR 0 1
3667: PUSH
3668: EMPTY
3669: LIST
3670: LIST
3671: PUSH
3672: LD_INT 2
3674: PUSH
3675: LD_INT 30
3677: PUSH
3678: LD_INT 6
3680: PUSH
3681: EMPTY
3682: LIST
3683: LIST
3684: PUSH
3685: LD_INT 30
3687: PUSH
3688: LD_INT 7
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 30
3697: PUSH
3698: LD_INT 8
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: LIST
3709: LIST
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PPUSH
3715: CALL_OW 69
3719: ST_TO_ADDR
// end ;
3720: LD_VAR 0 2
3724: RET
// export function scs_scan_buildings ( side , typ ) ; begin
3725: LD_INT 0
3727: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , typ ] ] ) ;
3728: LD_ADDR_VAR 0 3
3732: PUSH
3733: LD_INT 22
3735: PUSH
3736: LD_VAR 0 1
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PUSH
3745: LD_INT 30
3747: PUSH
3748: LD_VAR 0 2
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: EMPTY
3758: LIST
3759: LIST
3760: PPUSH
3761: CALL_OW 69
3765: ST_TO_ADDR
// end ;
3766: LD_VAR 0 3
3770: RET
// export function scs_change_side ( side , new_side ) ; var filter , i ; begin
3771: LD_INT 0
3773: PPUSH
3774: PPUSH
3775: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
3776: LD_ADDR_VAR 0 4
3780: PUSH
3781: LD_INT 22
3783: PUSH
3784: LD_VAR 0 1
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: LD_INT 21
3795: PUSH
3796: LD_INT 1
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PPUSH
3807: CALL_OW 69
3811: ST_TO_ADDR
// for i = 1 to filter do
3812: LD_ADDR_VAR 0 5
3816: PUSH
3817: DOUBLE
3818: LD_INT 1
3820: DEC
3821: ST_TO_ADDR
3822: LD_VAR 0 4
3826: PUSH
3827: FOR_TO
3828: IFFALSE 3852
// SetSide ( filter [ i ] , new_side ) ;
3830: LD_VAR 0 4
3834: PUSH
3835: LD_VAR 0 5
3839: ARRAY
3840: PPUSH
3841: LD_VAR 0 2
3845: PPUSH
3846: CALL_OW 235
3850: GO 3827
3852: POP
3853: POP
// end ;
3854: LD_VAR 0 3
3858: RET
// export function Build ( engs , build , x , y , d , cost ) ; var i , dep ; begin
3859: LD_INT 0
3861: PPUSH
3862: PPUSH
3863: PPUSH
// dep := FilterAllUnits ( [ [ [ f_side , GetSide ( engs [ 1 ] ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
3864: LD_ADDR_VAR 0 9
3868: PUSH
3869: LD_INT 22
3871: PUSH
3872: LD_VAR 0 1
3876: PUSH
3877: LD_INT 1
3879: ARRAY
3880: PPUSH
3881: CALL_OW 255
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 2
3892: PUSH
3893: LD_INT 30
3895: PUSH
3896: LD_INT 0
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 30
3905: PUSH
3906: LD_INT 1
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: LIST
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: EMPTY
3923: LIST
3924: PPUSH
3925: CALL_OW 69
3929: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) >= cost then
3930: LD_VAR 0 9
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: CALL_OW 274
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: CALL_OW 275
3951: PUSH
3952: LD_VAR 0 6
3956: GREATEREQUAL
3957: IFFALSE 4052
// for i = 1 to engs do
3959: LD_ADDR_VAR 0 8
3963: PUSH
3964: DOUBLE
3965: LD_INT 1
3967: DEC
3968: ST_TO_ADDR
3969: LD_VAR 0 1
3973: PUSH
3974: FOR_TO
3975: IFFALSE 4050
// if not HasTask ( engs [ i ] ) and not Carry ( engs [ i ] ) then
3977: LD_VAR 0 1
3981: PUSH
3982: LD_VAR 0 8
3986: ARRAY
3987: PPUSH
3988: CALL_OW 314
3992: NOT
3993: PUSH
3994: LD_VAR 0 1
3998: PUSH
3999: LD_VAR 0 8
4003: ARRAY
4004: PPUSH
4005: CALL_OW 281
4009: NOT
4010: AND
4011: IFFALSE 4048
// ComBuild ( engs [ i ] , build , x , y , d ) ;
4013: LD_VAR 0 1
4017: PUSH
4018: LD_VAR 0 8
4022: ARRAY
4023: PPUSH
4024: LD_VAR 0 2
4028: PPUSH
4029: LD_VAR 0 3
4033: PPUSH
4034: LD_VAR 0 4
4038: PPUSH
4039: LD_VAR 0 5
4043: PPUSH
4044: CALL_OW 145
4048: GO 3974
4050: POP
4051: POP
// end ;
4052: LD_VAR 0 7
4056: RET
// export function Upgrade ( side , typ , cost ) ; var i , dep , b ; begin
4057: LD_INT 0
4059: PPUSH
4060: PPUSH
4061: PPUSH
4062: PPUSH
// b := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , typ ] ] ) [ 1 ] ;
4063: LD_ADDR_VAR 0 7
4067: PUSH
4068: LD_INT 22
4070: PUSH
4071: LD_VAR 0 1
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: LD_INT 30
4082: PUSH
4083: LD_VAR 0 2
4087: PUSH
4088: EMPTY
4089: LIST
4090: LIST
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PPUSH
4096: CALL_OW 69
4100: PUSH
4101: LD_INT 1
4103: ARRAY
4104: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
4105: LD_ADDR_VAR 0 6
4109: PUSH
4110: LD_INT 22
4112: PUSH
4113: LD_VAR 0 1
4117: PUSH
4118: EMPTY
4119: LIST
4120: LIST
4121: PUSH
4122: LD_INT 2
4124: PUSH
4125: LD_INT 30
4127: PUSH
4128: LD_INT 0
4130: PUSH
4131: EMPTY
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 30
4137: PUSH
4138: LD_INT 1
4140: PUSH
4141: EMPTY
4142: LIST
4143: LIST
4144: PUSH
4145: EMPTY
4146: LIST
4147: LIST
4148: LIST
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: PPUSH
4157: CALL_OW 69
4161: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) >= cost then
4162: LD_VAR 0 6
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PPUSH
4171: CALL_OW 274
4175: PPUSH
4176: LD_INT 1
4178: PPUSH
4179: CALL_OW 275
4183: PUSH
4184: LD_VAR 0 3
4188: GREATEREQUAL
4189: IFFALSE 4200
// ComUpgrade ( b ) ;
4191: LD_VAR 0 7
4195: PPUSH
4196: CALL_OW 146
// end ;
4200: LD_VAR 0 4
4204: RET
// export function UpgradeLab ( lab , typ1 , cost ) ; var dep ; begin
4205: LD_INT 0
4207: PPUSH
4208: PPUSH
// dep := FilterAllUnits ( [ [ [ f_side , GetSide ( lab ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
4209: LD_ADDR_VAR 0 5
4213: PUSH
4214: LD_INT 22
4216: PUSH
4217: LD_VAR 0 1
4221: PPUSH
4222: CALL_OW 255
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 2
4233: PUSH
4234: LD_INT 30
4236: PUSH
4237: LD_INT 0
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: LD_INT 30
4246: PUSH
4247: LD_INT 1
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: PPUSH
4266: CALL_OW 69
4270: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) >= cost then
4271: LD_VAR 0 5
4275: PUSH
4276: LD_INT 1
4278: ARRAY
4279: PPUSH
4280: CALL_OW 274
4284: PPUSH
4285: LD_INT 1
4287: PPUSH
4288: CALL_OW 275
4292: PUSH
4293: LD_VAR 0 3
4297: GREATEREQUAL
4298: IFFALSE 4314
// ComUpgradeLab ( lab , typ1 ) ;
4300: LD_VAR 0 1
4304: PPUSH
4305: LD_VAR 0 2
4309: PPUSH
4310: CALL_OW 147
// end ;
4314: LD_VAR 0 4
4318: RET
// export function BuildPowerPlant ( engs , typ , x , y , d ) ; var i , b , dep , source , source2 , side ; begin
4319: LD_INT 0
4321: PPUSH
4322: PPUSH
4323: PPUSH
4324: PPUSH
4325: PPUSH
4326: PPUSH
4327: PPUSH
// side := GetSide ( engs [ 1 ] ) ;
4328: LD_ADDR_VAR 0 12
4332: PUSH
4333: LD_VAR 0 1
4337: PUSH
4338: LD_INT 1
4340: ARRAY
4341: PPUSH
4342: CALL_OW 255
4346: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
4347: LD_ADDR_VAR 0 9
4351: PUSH
4352: LD_INT 22
4354: PUSH
4355: LD_VAR 0 12
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PUSH
4364: LD_INT 2
4366: PUSH
4367: LD_INT 30
4369: PUSH
4370: LD_INT 0
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: LD_INT 30
4379: PUSH
4380: LD_INT 1
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: PPUSH
4399: CALL_OW 69
4403: ST_TO_ADDR
// source := GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) ;
4404: LD_ADDR_VAR 0 10
4408: PUSH
4409: LD_VAR 0 9
4413: PUSH
4414: LD_INT 1
4416: ARRAY
4417: PPUSH
4418: CALL_OW 274
4422: PPUSH
4423: LD_INT 1
4425: PPUSH
4426: CALL_OW 275
4430: ST_TO_ADDR
// source2 := GetResourceType ( GetBase ( dep [ 1 ] ) , mat_siberit ) ;
4431: LD_ADDR_VAR 0 11
4435: PUSH
4436: LD_VAR 0 9
4440: PUSH
4441: LD_INT 1
4443: ARRAY
4444: PPUSH
4445: CALL_OW 274
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: CALL_OW 275
4457: ST_TO_ADDR
// case typ of b_solar_power :
4458: LD_VAR 0 2
4462: PUSH
4463: LD_INT 27
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4531
4471: POP
// begin if GetTech ( tech_solpow , side ) = state_researched and source >= 35 then
4472: LD_INT 35
4474: PPUSH
4475: LD_VAR 0 12
4479: PPUSH
4480: CALL_OW 321
4484: PUSH
4485: LD_INT 2
4487: EQUAL
4488: PUSH
4489: LD_VAR 0 10
4493: PUSH
4494: LD_INT 35
4496: GREATEREQUAL
4497: AND
4498: IFFALSE 4529
// ComBuild ( engs , typ , x , y , d ) ;
4500: LD_VAR 0 1
4504: PPUSH
4505: LD_VAR 0 2
4509: PPUSH
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_VAR 0 4
4519: PPUSH
4520: LD_VAR 0 5
4524: PPUSH
4525: CALL_OW 145
// end ; b_oil_power :
4529: GO 4678
4531: LD_INT 26
4533: DOUBLE
4534: EQUAL
4535: IFTRUE 4539
4537: GO 4599
4539: POP
// begin if GetTech ( tech_oilpow , side ) = state_researched and source >= 20 then
4540: LD_INT 46
4542: PPUSH
4543: LD_VAR 0 12
4547: PPUSH
4548: CALL_OW 321
4552: PUSH
4553: LD_INT 2
4555: EQUAL
4556: PUSH
4557: LD_VAR 0 10
4561: PUSH
4562: LD_INT 20
4564: GREATEREQUAL
4565: AND
4566: IFFALSE 4597
// ComBuild ( engs , typ , x , y , d ) ;
4568: LD_VAR 0 1
4572: PPUSH
4573: LD_VAR 0 2
4577: PPUSH
4578: LD_VAR 0 3
4582: PPUSH
4583: LD_VAR 0 4
4587: PPUSH
4588: LD_VAR 0 5
4592: PPUSH
4593: CALL_OW 145
// end ; b_siberite_power :
4597: GO 4678
4599: LD_INT 28
4601: DOUBLE
4602: EQUAL
4603: IFTRUE 4607
4605: GO 4677
4607: POP
// begin if GetTech ( tech_sibpow , side ) = state_researched and source >= 20 and source2 >= 10 then
4608: LD_INT 21
4610: PPUSH
4611: LD_VAR 0 12
4615: PPUSH
4616: CALL_OW 321
4620: PUSH
4621: LD_INT 2
4623: EQUAL
4624: PUSH
4625: LD_VAR 0 10
4629: PUSH
4630: LD_INT 20
4632: GREATEREQUAL
4633: AND
4634: PUSH
4635: LD_VAR 0 11
4639: PUSH
4640: LD_INT 10
4642: GREATEREQUAL
4643: AND
4644: IFFALSE 4675
// ComBuild ( engs , typ , x , y , d ) ;
4646: LD_VAR 0 1
4650: PPUSH
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_VAR 0 3
4660: PPUSH
4661: LD_VAR 0 4
4665: PPUSH
4666: LD_VAR 0 5
4670: PPUSH
4671: CALL_OW 145
// end ; end ;
4675: GO 4678
4677: POP
// end ;
4678: LD_VAR 0 6
4682: RET
// export function SortFilter ( filter , skill ) ; var skill_list , i , list ; begin
4683: LD_INT 0
4685: PPUSH
4686: PPUSH
4687: PPUSH
4688: PPUSH
// for i in filter do
4689: LD_ADDR_VAR 0 5
4693: PUSH
4694: LD_VAR 0 1
4698: PUSH
4699: FOR_IN
4700: IFFALSE 4730
// skill_list = skill_list ^ GetSkill ( i , skill ) ;
4702: LD_ADDR_VAR 0 4
4706: PUSH
4707: LD_VAR 0 4
4711: PUSH
4712: LD_VAR 0 5
4716: PPUSH
4717: LD_VAR 0 2
4721: PPUSH
4722: CALL_OW 259
4726: ADD
4727: ST_TO_ADDR
4728: GO 4699
4730: POP
4731: POP
// result = SortListByListDesc ( filter , skill_list ) ;
4732: LD_ADDR_VAR 0 3
4736: PUSH
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_VAR 0 4
4746: PPUSH
4747: CALL_OW 77
4751: ST_TO_ADDR
// end ;
4752: LD_VAR 0 3
4756: RET
// export function scs_change_class ( unit , clas ) ; var side ; begin
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
// side := GetSide ( unit ) ;
4761: LD_ADDR_VAR 0 4
4765: PUSH
4766: LD_VAR 0 1
4770: PPUSH
4771: CALL_OW 255
4775: ST_TO_ADDR
// if not HasTask ( unit ) then
4776: LD_VAR 0 1
4780: PPUSH
4781: CALL_OW 314
4785: NOT
4786: IFFALSE 5078
// case clas of 1 :
4788: LD_VAR 0 2
4792: PUSH
4793: LD_INT 1
4795: DOUBLE
4796: EQUAL
4797: IFTRUE 4801
4799: GO 4864
4801: POP
// begin if IsInUnit ( unit ) then
4802: LD_VAR 0 1
4806: PPUSH
4807: CALL_OW 310
4811: IFFALSE 4822
// ComExitBuilding ( unit ) ;
4813: LD_VAR 0 1
4817: PPUSH
4818: CALL_OW 122
// Wait ( 1 ) ;
4822: LD_INT 1
4824: PPUSH
4825: CALL_OW 67
// ComEnterUnit ( unit , scs_find_barracks ( side ) ) ;
4829: LD_VAR 0 1
4833: PPUSH
4834: LD_VAR 0 4
4838: PPUSH
4839: CALL 5083 0 1
4843: PPUSH
4844: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
4848: LD_VAR 0 1
4852: PPUSH
4853: LD_VAR 0 2
4857: PPUSH
4858: CALL_OW 183
// end ; 2 :
4862: GO 5078
4864: LD_INT 2
4866: DOUBLE
4867: EQUAL
4868: IFTRUE 4872
4870: GO 4935
4872: POP
// begin if IsInUnit ( unit ) then
4873: LD_VAR 0 1
4877: PPUSH
4878: CALL_OW 310
4882: IFFALSE 4893
// ComExitBuilding ( unit ) ;
4884: LD_VAR 0 1
4888: PPUSH
4889: CALL_OW 122
// Wait ( 1 ) ;
4893: LD_INT 1
4895: PPUSH
4896: CALL_OW 67
// ComEnterUnit ( unit , scs_find_depot ( side ) ) ;
4900: LD_VAR 0 1
4904: PPUSH
4905: LD_VAR 0 4
4909: PPUSH
4910: CALL 5499 0 1
4914: PPUSH
4915: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
4919: LD_VAR 0 1
4923: PPUSH
4924: LD_VAR 0 2
4928: PPUSH
4929: CALL_OW 183
// end ; 3 :
4933: GO 5078
4935: LD_INT 3
4937: DOUBLE
4938: EQUAL
4939: IFTRUE 4943
4941: GO 5006
4943: POP
// begin if IsInUnit ( unit ) then
4944: LD_VAR 0 1
4948: PPUSH
4949: CALL_OW 310
4953: IFFALSE 4964
// ComExitBuilding ( unit ) ;
4955: LD_VAR 0 1
4959: PPUSH
4960: CALL_OW 122
// Wait ( 1 ) ;
4964: LD_INT 1
4966: PPUSH
4967: CALL_OW 67
// ComEnterUnit ( unit , scs_find_factory ( side ) ) ;
4971: LD_VAR 0 1
4975: PPUSH
4976: LD_VAR 0 4
4980: PPUSH
4981: CALL 5364 0 1
4985: PPUSH
4986: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
4990: LD_VAR 0 1
4994: PPUSH
4995: LD_VAR 0 2
4999: PPUSH
5000: CALL_OW 183
// end ; 4 :
5004: GO 5078
5006: LD_INT 4
5008: DOUBLE
5009: EQUAL
5010: IFTRUE 5014
5012: GO 5077
5014: POP
// begin if IsInUnit ( unit ) then
5015: LD_VAR 0 1
5019: PPUSH
5020: CALL_OW 310
5024: IFFALSE 5035
// ComExitBuilding ( unit ) ;
5026: LD_VAR 0 1
5030: PPUSH
5031: CALL_OW 122
// Wait ( 1 ) ;
5035: LD_INT 1
5037: PPUSH
5038: CALL_OW 67
// ComEnterUnit ( unit , scs_find_lab ( side ) ) ;
5042: LD_VAR 0 1
5046: PPUSH
5047: LD_VAR 0 4
5051: PPUSH
5052: CALL 5218 0 1
5056: PPUSH
5057: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
5061: LD_VAR 0 1
5065: PPUSH
5066: LD_VAR 0 2
5070: PPUSH
5071: CALL_OW 183
// end ; end ;
5075: GO 5078
5077: POP
// end ;
5078: LD_VAR 0 3
5082: RET
// export function scs_find_barracks ( side ) ; var filter , i ; begin
5083: LD_INT 0
5085: PPUSH
5086: PPUSH
5087: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
5088: LD_ADDR_VAR 0 3
5092: PUSH
5093: LD_INT 22
5095: PUSH
5096: LD_VAR 0 1
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 2
5107: PUSH
5108: LD_INT 30
5110: PUSH
5111: LD_INT 4
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PUSH
5118: LD_INT 30
5120: PUSH
5121: LD_INT 5
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: LIST
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PPUSH
5137: CALL_OW 69
5141: ST_TO_ADDR
// if filter > 0 then
5142: LD_VAR 0 3
5146: PUSH
5147: LD_INT 0
5149: GREATER
5150: IFFALSE 5213
// for i = 1 to filter do
5152: LD_ADDR_VAR 0 4
5156: PUSH
5157: DOUBLE
5158: LD_INT 1
5160: DEC
5161: ST_TO_ADDR
5162: LD_VAR 0 3
5166: PUSH
5167: FOR_TO
5168: IFFALSE 5211
// if UnitsInside ( filter [ i ] ) < 6 then
5170: LD_VAR 0 3
5174: PUSH
5175: LD_VAR 0 4
5179: ARRAY
5180: PPUSH
5181: CALL_OW 313
5185: PUSH
5186: LD_INT 6
5188: LESS
5189: IFFALSE 5209
// begin result := filter [ i ] ;
5191: LD_ADDR_VAR 0 2
5195: PUSH
5196: LD_VAR 0 3
5200: PUSH
5201: LD_VAR 0 4
5205: ARRAY
5206: ST_TO_ADDR
// break ;
5207: GO 5211
// end ;
5209: GO 5167
5211: POP
5212: POP
// end ;
5213: LD_VAR 0 2
5217: RET
// export function scs_find_lab ( side ) ; var filter , i ; begin
5218: LD_INT 0
5220: PPUSH
5221: PPUSH
5222: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ) ;
5223: LD_ADDR_VAR 0 3
5227: PUSH
5228: LD_INT 22
5230: PUSH
5231: LD_VAR 0 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 2
5242: PUSH
5243: LD_INT 30
5245: PUSH
5246: LD_INT 6
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 8
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 30
5265: PUSH
5266: LD_INT 7
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PPUSH
5283: CALL_OW 69
5287: ST_TO_ADDR
// if filter > 0 then
5288: LD_VAR 0 3
5292: PUSH
5293: LD_INT 0
5295: GREATER
5296: IFFALSE 5359
// for i = 1 to filter do
5298: LD_ADDR_VAR 0 4
5302: PUSH
5303: DOUBLE
5304: LD_INT 1
5306: DEC
5307: ST_TO_ADDR
5308: LD_VAR 0 3
5312: PUSH
5313: FOR_TO
5314: IFFALSE 5357
// if UnitsInside ( filter [ i ] ) < 6 then
5316: LD_VAR 0 3
5320: PUSH
5321: LD_VAR 0 4
5325: ARRAY
5326: PPUSH
5327: CALL_OW 313
5331: PUSH
5332: LD_INT 6
5334: LESS
5335: IFFALSE 5355
// begin result := filter [ i ] ;
5337: LD_ADDR_VAR 0 2
5341: PUSH
5342: LD_VAR 0 3
5346: PUSH
5347: LD_VAR 0 4
5351: ARRAY
5352: ST_TO_ADDR
// break ;
5353: GO 5357
// end ;
5355: GO 5313
5357: POP
5358: POP
// end ;
5359: LD_VAR 0 2
5363: RET
// export function scs_find_factory ( side ) ; var filter , i ; begin
5364: LD_INT 0
5366: PPUSH
5367: PPUSH
5368: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5369: LD_ADDR_VAR 0 3
5373: PUSH
5374: LD_INT 22
5376: PUSH
5377: LD_VAR 0 1
5381: PUSH
5382: EMPTY
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 2
5388: PUSH
5389: LD_INT 30
5391: PUSH
5392: LD_INT 2
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PUSH
5399: LD_INT 30
5401: PUSH
5402: LD_INT 3
5404: PUSH
5405: EMPTY
5406: LIST
5407: LIST
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: PUSH
5414: EMPTY
5415: LIST
5416: LIST
5417: PPUSH
5418: CALL_OW 69
5422: ST_TO_ADDR
// if filter > 0 then
5423: LD_VAR 0 3
5427: PUSH
5428: LD_INT 0
5430: GREATER
5431: IFFALSE 5494
// for i = 1 to filter do
5433: LD_ADDR_VAR 0 4
5437: PUSH
5438: DOUBLE
5439: LD_INT 1
5441: DEC
5442: ST_TO_ADDR
5443: LD_VAR 0 3
5447: PUSH
5448: FOR_TO
5449: IFFALSE 5492
// if UnitsInside ( filter [ i ] ) < 6 then
5451: LD_VAR 0 3
5455: PUSH
5456: LD_VAR 0 4
5460: ARRAY
5461: PPUSH
5462: CALL_OW 313
5466: PUSH
5467: LD_INT 6
5469: LESS
5470: IFFALSE 5490
// begin result := filter [ i ] ;
5472: LD_ADDR_VAR 0 2
5476: PUSH
5477: LD_VAR 0 3
5481: PUSH
5482: LD_VAR 0 4
5486: ARRAY
5487: ST_TO_ADDR
// break ;
5488: GO 5492
// end ;
5490: GO 5448
5492: POP
5493: POP
// end ;
5494: LD_VAR 0 2
5498: RET
// export function scs_find_depot ( side ) ; var filter , i ; begin
5499: LD_INT 0
5501: PPUSH
5502: PPUSH
5503: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5504: LD_ADDR_VAR 0 3
5508: PUSH
5509: LD_INT 22
5511: PUSH
5512: LD_VAR 0 1
5516: PUSH
5517: EMPTY
5518: LIST
5519: LIST
5520: PUSH
5521: LD_INT 2
5523: PUSH
5524: LD_INT 30
5526: PUSH
5527: LD_INT 0
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: PUSH
5534: LD_INT 30
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 69
5557: ST_TO_ADDR
// if filter > 0 then
5558: LD_VAR 0 3
5562: PUSH
5563: LD_INT 0
5565: GREATER
5566: IFFALSE 5629
// for i = 1 to filter do
5568: LD_ADDR_VAR 0 4
5572: PUSH
5573: DOUBLE
5574: LD_INT 1
5576: DEC
5577: ST_TO_ADDR
5578: LD_VAR 0 3
5582: PUSH
5583: FOR_TO
5584: IFFALSE 5627
// if UnitsInside ( filter [ i ] ) < 6 then
5586: LD_VAR 0 3
5590: PUSH
5591: LD_VAR 0 4
5595: ARRAY
5596: PPUSH
5597: CALL_OW 313
5601: PUSH
5602: LD_INT 6
5604: LESS
5605: IFFALSE 5625
// begin result := filter [ i ] ;
5607: LD_ADDR_VAR 0 2
5611: PUSH
5612: LD_VAR 0 3
5616: PUSH
5617: LD_VAR 0 4
5621: ARRAY
5622: ST_TO_ADDR
// break ;
5623: GO 5627
// end ;
5625: GO 5583
5627: POP
5628: POP
// end ;
5629: LD_VAR 0 2
5633: RET
// export function IsInTower ( unit ) ; var i , filter ; begin
5634: LD_INT 0
5636: PPUSH
5637: PPUSH
5638: PPUSH
// filter := FilterAllUnits ( [ [ f_side , GetSide ( unit ) ] , [ f_btype , b_bunker ] ] ) ;
5639: LD_ADDR_VAR 0 4
5643: PUSH
5644: LD_INT 22
5646: PUSH
5647: LD_VAR 0 1
5651: PPUSH
5652: CALL_OW 255
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: PUSH
5661: LD_INT 30
5663: PUSH
5664: LD_INT 32
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PPUSH
5675: CALL_OW 69
5679: ST_TO_ADDR
// for i in filter do
5680: LD_ADDR_VAR 0 3
5684: PUSH
5685: LD_VAR 0 4
5689: PUSH
5690: FOR_IN
5691: IFFALSE 5730
// if unit in UnitsInside ( i ) then
5693: LD_VAR 0 1
5697: PUSH
5698: LD_VAR 0 3
5702: PPUSH
5703: CALL_OW 313
5707: IN
5708: IFFALSE 5720
// result := true else
5710: LD_ADDR_VAR 0 2
5714: PUSH
5715: LD_INT 1
5717: ST_TO_ADDR
5718: GO 5728
// result := false ;
5720: LD_ADDR_VAR 0 2
5724: PUSH
5725: LD_INT 0
5727: ST_TO_ADDR
5728: GO 5690
5730: POP
5731: POP
// end ;
5732: LD_VAR 0 2
5736: RET
// export function FillTowers ( side ) ; var filter , sold , sold_q , i ; begin
5737: LD_INT 0
5739: PPUSH
5740: PPUSH
5741: PPUSH
5742: PPUSH
5743: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
5744: LD_ADDR_VAR 0 3
5748: PUSH
5749: LD_INT 22
5751: PUSH
5752: LD_VAR 0 1
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: PUSH
5761: LD_INT 2
5763: PUSH
5764: LD_INT 30
5766: PUSH
5767: LD_INT 31
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PUSH
5774: LD_INT 30
5776: PUSH
5777: LD_INT 32
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PPUSH
5793: CALL_OW 69
5797: ST_TO_ADDR
// sold := scs_scan_class ( side , 1 , true ) ;
5798: LD_ADDR_VAR 0 4
5802: PUSH
5803: LD_VAR 0 1
5807: PPUSH
5808: LD_INT 1
5810: PPUSH
5811: LD_INT 1
5813: PPUSH
5814: CALL 3409 0 3
5818: ST_TO_ADDR
// if UnitFilter ( filter , [ f_empty ] ) > 0 and sold then
5819: LD_VAR 0 3
5823: PPUSH
5824: LD_INT 58
5826: PUSH
5827: EMPTY
5828: LIST
5829: PPUSH
5830: CALL_OW 72
5834: PUSH
5835: LD_INT 0
5837: GREATER
5838: PUSH
5839: LD_VAR 0 4
5843: AND
5844: IFFALSE 5955
// for i = 1 to sold do
5846: LD_ADDR_VAR 0 6
5850: PUSH
5851: DOUBLE
5852: LD_INT 1
5854: DEC
5855: ST_TO_ADDR
5856: LD_VAR 0 4
5860: PUSH
5861: FOR_TO
5862: IFFALSE 5953
// if not IsInTower ( sold [ i ] ) then
5864: LD_VAR 0 4
5868: PUSH
5869: LD_VAR 0 6
5873: ARRAY
5874: PPUSH
5875: CALL 5634 0 1
5879: NOT
5880: IFFALSE 5951
// begin if IsInUnit ( sold [ i ] ) then
5882: LD_VAR 0 4
5886: PUSH
5887: LD_VAR 0 6
5891: ARRAY
5892: PPUSH
5893: CALL_OW 310
5897: IFFALSE 5914
// ComExitBuilding ( sold [ i ] ) ;
5899: LD_VAR 0 4
5903: PUSH
5904: LD_VAR 0 6
5908: ARRAY
5909: PPUSH
5910: CALL_OW 122
// ComEnterUnit ( sold [ i ] , UnitFilter ( filter , [ f_empty ] ) [ 1 ] ) ;
5914: LD_VAR 0 4
5918: PUSH
5919: LD_VAR 0 6
5923: ARRAY
5924: PPUSH
5925: LD_VAR 0 3
5929: PPUSH
5930: LD_INT 58
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: PUSH
5941: LD_INT 1
5943: ARRAY
5944: PPUSH
5945: CALL_OW 120
// break ;
5949: GO 5953
// end ;
5951: GO 5861
5953: POP
5954: POP
// end ;
5955: LD_VAR 0 2
5959: RET
// export function CanBExt ( side , ext ) ; begin
5960: LD_INT 0
5962: PPUSH
// case ext of b_ext_noncombat , b_ext_track :
5963: LD_VAR 0 2
5967: PUSH
5968: LD_INT 19
5970: DOUBLE
5971: EQUAL
5972: IFTRUE 5982
5974: LD_INT 16
5976: DOUBLE
5977: EQUAL
5978: IFTRUE 5982
5980: GO 5993
5982: POP
// result := true ; b_ext_gun :
5983: LD_ADDR_VAR 0 3
5987: PUSH
5988: LD_INT 1
5990: ST_TO_ADDR
5991: GO 6276
5993: LD_INT 17
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6040
6001: POP
// if GetTech ( 39 , side ) = state_researched then
6002: LD_INT 39
6004: PPUSH
6005: LD_VAR 0 1
6009: PPUSH
6010: CALL_OW 321
6014: PUSH
6015: LD_INT 2
6017: EQUAL
6018: IFFALSE 6030
// result := true else
6020: LD_ADDR_VAR 0 3
6024: PUSH
6025: LD_INT 1
6027: ST_TO_ADDR
6028: GO 6038
// result := false ; b_ext_rocket :
6030: LD_ADDR_VAR 0 3
6034: PUSH
6035: LD_INT 0
6037: ST_TO_ADDR
6038: GO 6276
6040: LD_INT 18
6042: DOUBLE
6043: EQUAL
6044: IFTRUE 6048
6046: GO 6087
6048: POP
// if GetTech ( 40 , side ) = state_researched then
6049: LD_INT 40
6051: PPUSH
6052: LD_VAR 0 1
6056: PPUSH
6057: CALL_OW 321
6061: PUSH
6062: LD_INT 2
6064: EQUAL
6065: IFFALSE 6077
// result := true else
6067: LD_ADDR_VAR 0 3
6071: PUSH
6072: LD_INT 1
6074: ST_TO_ADDR
6075: GO 6085
// result := false ; b_ext_laser :
6077: LD_ADDR_VAR 0 3
6081: PUSH
6082: LD_INT 0
6084: ST_TO_ADDR
6085: GO 6276
6087: LD_INT 25
6089: DOUBLE
6090: EQUAL
6091: IFTRUE 6095
6093: GO 6134
6095: POP
// if GetTech ( 10 , side ) = state_researched then
6096: LD_INT 10
6098: PPUSH
6099: LD_VAR 0 1
6103: PPUSH
6104: CALL_OW 321
6108: PUSH
6109: LD_INT 2
6111: EQUAL
6112: IFFALSE 6124
// result := true else
6114: LD_ADDR_VAR 0 3
6118: PUSH
6119: LD_INT 1
6121: ST_TO_ADDR
6122: GO 6132
// result := false ; b_ext_siberium :
6124: LD_ADDR_VAR 0 3
6128: PUSH
6129: LD_INT 0
6131: ST_TO_ADDR
6132: GO 6276
6134: LD_INT 21
6136: DOUBLE
6137: EQUAL
6138: IFTRUE 6142
6140: GO 6181
6142: POP
// if GetTech ( 21 , side ) = state_researched then
6143: LD_INT 21
6145: PPUSH
6146: LD_VAR 0 1
6150: PPUSH
6151: CALL_OW 321
6155: PUSH
6156: LD_INT 2
6158: EQUAL
6159: IFFALSE 6171
// result := true else
6161: LD_ADDR_VAR 0 3
6165: PUSH
6166: LD_INT 1
6168: ST_TO_ADDR
6169: GO 6179
// result := false ; b_ext_radar :
6171: LD_ADDR_VAR 0 3
6175: PUSH
6176: LD_INT 0
6178: ST_TO_ADDR
6179: GO 6276
6181: LD_INT 20
6183: DOUBLE
6184: EQUAL
6185: IFTRUE 6189
6187: GO 6228
6189: POP
// if GetTech ( 6 , side ) = state_researched then
6190: LD_INT 6
6192: PPUSH
6193: LD_VAR 0 1
6197: PPUSH
6198: CALL_OW 321
6202: PUSH
6203: LD_INT 2
6205: EQUAL
6206: IFFALSE 6218
// result := true else
6208: LD_ADDR_VAR 0 3
6212: PUSH
6213: LD_INT 1
6215: ST_TO_ADDR
6216: GO 6226
// result := false ; b_ext_radio :
6218: LD_ADDR_VAR 0 3
6222: PUSH
6223: LD_INT 0
6225: ST_TO_ADDR
6226: GO 6276
6228: LD_INT 22
6230: DOUBLE
6231: EQUAL
6232: IFTRUE 6236
6234: GO 6275
6236: POP
// if GetTech ( 15 , side ) = state_researched then
6237: LD_INT 15
6239: PPUSH
6240: LD_VAR 0 1
6244: PPUSH
6245: CALL_OW 321
6249: PUSH
6250: LD_INT 2
6252: EQUAL
6253: IFFALSE 6265
// result := true else
6255: LD_ADDR_VAR 0 3
6259: PUSH
6260: LD_INT 1
6262: ST_TO_ADDR
6263: GO 6273
// result := false ; end ;
6265: LD_ADDR_VAR 0 3
6269: PUSH
6270: LD_INT 0
6272: ST_TO_ADDR
6273: GO 6276
6275: POP
// end ; end_of_file
6276: LD_VAR 0 3
6280: RET
// every 0 0$01 trigger b1_act do var sol , eng , mech , sci , bazz , snip , mort , apeng , apsol , apkami , i , p , b , un , veh , bul , x , y , d , side , nation , area , people , skill , tech , lab , cr_dep , cr_lab , cr_fab , cr_ext , cr_pow , cr_tw , cr_br , cr_add , ally , enemy , skr , c , fac , filter , filter_c , x_a , x_b , x_c , x_d , x_e , x_f , x_g , x_h , x_j ;
6281: LD_EXP 1
6285: IFFALSE 11457
6287: GO 6289
6289: DISABLE
6290: LD_INT 0
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
6296: PPUSH
6297: PPUSH
6298: PPUSH
6299: PPUSH
6300: PPUSH
6301: PPUSH
6302: PPUSH
6303: PPUSH
6304: PPUSH
6305: PPUSH
6306: PPUSH
6307: PPUSH
6308: PPUSH
6309: PPUSH
6310: PPUSH
6311: PPUSH
6312: PPUSH
6313: PPUSH
6314: PPUSH
6315: PPUSH
6316: PPUSH
6317: PPUSH
6318: PPUSH
6319: PPUSH
6320: PPUSH
6321: PPUSH
6322: PPUSH
6323: PPUSH
6324: PPUSH
6325: PPUSH
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
6331: PPUSH
6332: PPUSH
6333: PPUSH
6334: PPUSH
6335: PPUSH
6336: PPUSH
6337: PPUSH
6338: PPUSH
6339: PPUSH
6340: PPUSH
6341: PPUSH
// begin if scs_scan_side ( b1_side ) then
6342: LD_EXP 6
6346: PPUSH
6347: CALL 3317 0 1
6351: IFFALSE 6356
// enable else
6353: ENABLE
6354: GO 6357
// disable ;
6356: DISABLE
// if side = 0 then
6357: LD_VAR 0 20
6361: PUSH
6362: LD_INT 0
6364: EQUAL
6365: IFFALSE 6377
// side := b1_side ;
6367: LD_ADDR_VAR 0 20
6371: PUSH
6372: LD_EXP 6
6376: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
6377: LD_ADDR_VAR 0 36
6381: PUSH
6382: LD_INT 81
6384: PUSH
6385: LD_VAR 0 20
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: PPUSH
6394: CALL_OW 69
6398: ST_TO_ADDR
// ally := FilterAllUnits ( [ f_ally , side ] ) diff scs_scan_side ( side ) ;
6399: LD_ADDR_VAR 0 35
6403: PUSH
6404: LD_INT 82
6406: PUSH
6407: LD_VAR 0 20
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: PPUSH
6416: CALL_OW 69
6420: PUSH
6421: LD_VAR 0 20
6425: PPUSH
6426: CALL 3317 0 1
6430: DIFF
6431: ST_TO_ADDR
// nation := b1_nation ;
6432: LD_ADDR_VAR 0 21
6436: PUSH
6437: LD_EXP 7
6441: ST_TO_ADDR
// area := b1_area ;
6442: LD_ADDR_VAR 0 22
6446: PUSH
6447: LD_EXP 8
6451: ST_TO_ADDR
// people := b1_people ;
6452: LD_ADDR_VAR 0 23
6456: PUSH
6457: LD_EXP 9
6461: ST_TO_ADDR
// skill := b1_skill ;
6462: LD_ADDR_VAR 0 24
6466: PUSH
6467: LD_EXP 10
6471: ST_TO_ADDR
// cr_dep := b1_cr_dep ;
6472: LD_ADDR_VAR 0 27
6476: PUSH
6477: LD_EXP 11
6481: ST_TO_ADDR
// cr_lab := b1_cr_lab ;
6482: LD_ADDR_VAR 0 28
6486: PUSH
6487: LD_EXP 12
6491: ST_TO_ADDR
// cr_fab := b1_cr_fab ;
6492: LD_ADDR_VAR 0 29
6496: PUSH
6497: LD_EXP 13
6501: ST_TO_ADDR
// cr_ext := b1_cr_ext ;
6502: LD_ADDR_VAR 0 30
6506: PUSH
6507: LD_EXP 14
6511: ST_TO_ADDR
// cr_pow := b1_cr_pow ;
6512: LD_ADDR_VAR 0 31
6516: PUSH
6517: LD_EXP 15
6521: ST_TO_ADDR
// cr_tw := b1_cr_tw ;
6522: LD_ADDR_VAR 0 32
6526: PUSH
6527: LD_EXP 16
6531: ST_TO_ADDR
// cr_br := b1_cr_br ;
6532: LD_ADDR_VAR 0 33
6536: PUSH
6537: LD_EXP 17
6541: ST_TO_ADDR
// cr_add := b1_cr_add ;
6542: LD_ADDR_VAR 0 34
6546: PUSH
6547: LD_EXP 18
6551: ST_TO_ADDR
// sol := scs_scan_class ( side , 1 , true ) ;
6552: LD_ADDR_VAR 0 1
6556: PUSH
6557: LD_VAR 0 20
6561: PPUSH
6562: LD_INT 1
6564: PPUSH
6565: LD_INT 1
6567: PPUSH
6568: CALL 3409 0 3
6572: ST_TO_ADDR
// eng := scs_scan_class ( side , 2 , true ) ;
6573: LD_ADDR_VAR 0 2
6577: PUSH
6578: LD_VAR 0 20
6582: PPUSH
6583: LD_INT 2
6585: PPUSH
6586: LD_INT 1
6588: PPUSH
6589: CALL 3409 0 3
6593: ST_TO_ADDR
// mech := scs_scan_class ( side , 3 , true ) ;
6594: LD_ADDR_VAR 0 3
6598: PUSH
6599: LD_VAR 0 20
6603: PPUSH
6604: LD_INT 3
6606: PPUSH
6607: LD_INT 1
6609: PPUSH
6610: CALL 3409 0 3
6614: ST_TO_ADDR
// sci := scs_scan_class ( side , 4 , true ) ;
6615: LD_ADDR_VAR 0 4
6619: PUSH
6620: LD_VAR 0 20
6624: PPUSH
6625: LD_INT 4
6627: PPUSH
6628: LD_INT 1
6630: PPUSH
6631: CALL 3409 0 3
6635: ST_TO_ADDR
// if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
6636: LD_VAR 0 20
6640: PPUSH
6641: LD_INT 0
6643: PPUSH
6644: CALL 1909 0 2
6648: PUSH
6649: LD_VAR 0 20
6653: PPUSH
6654: LD_INT 1
6656: PPUSH
6657: CALL 1909 0 2
6661: OR
6662: IFFALSE 8938
// begin if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 20 ) then
6664: LD_VAR 0 20
6668: PPUSH
6669: LD_VAR 0 27
6673: PUSH
6674: LD_INT 1
6676: ARRAY
6677: PPUSH
6678: LD_VAR 0 27
6682: PUSH
6683: LD_INT 2
6685: ARRAY
6686: PPUSH
6687: LD_INT 20
6689: PPUSH
6690: CALL 3565 0 4
6694: IFFALSE 6700
// exit else
6696: GO 11457
6698: GO 8141
// begin x_a := cr_br / 3 ;
6700: LD_ADDR_VAR 0 42
6704: PUSH
6705: LD_VAR 0 33
6709: PUSH
6710: LD_INT 3
6712: DIVREAL
6713: ST_TO_ADDR
// if scs_scan_buildings ( side , b_armoury ) ^ scs_scan_buildings ( side , b_barracks ) < ( x_a - 1 ) then
6714: LD_VAR 0 20
6718: PPUSH
6719: LD_INT 4
6721: PPUSH
6722: CALL 3725 0 2
6726: PUSH
6727: LD_VAR 0 20
6731: PPUSH
6732: LD_INT 5
6734: PPUSH
6735: CALL 3725 0 2
6739: ADD
6740: PUSH
6741: LD_VAR 0 42
6745: PUSH
6746: LD_INT 1
6748: MINUS
6749: LESS
6750: IFFALSE 6966
// begin if HexInfo ( cr_br [ 1 ] , cr_br [ 2 ] ) = 0 then
6752: LD_VAR 0 33
6756: PUSH
6757: LD_INT 1
6759: ARRAY
6760: PPUSH
6761: LD_VAR 0 33
6765: PUSH
6766: LD_INT 2
6768: ARRAY
6769: PPUSH
6770: CALL_OW 428
6774: PUSH
6775: LD_INT 0
6777: EQUAL
6778: IFFALSE 6824
// Build ( eng , b_armoury , cr_br [ 1 ] , cr_br [ 2 ] , cr_br [ 3 ] , 30 ) else
6780: LD_VAR 0 2
6784: PPUSH
6785: LD_INT 4
6787: PPUSH
6788: LD_VAR 0 33
6792: PUSH
6793: LD_INT 1
6795: ARRAY
6796: PPUSH
6797: LD_VAR 0 33
6801: PUSH
6802: LD_INT 2
6804: ARRAY
6805: PPUSH
6806: LD_VAR 0 33
6810: PUSH
6811: LD_INT 3
6813: ARRAY
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: CALL 3859 0 6
6822: GO 6966
// if HexInfo ( cr_br [ 4 ] , cr_br [ 5 ] ) = 0 then
6824: LD_VAR 0 33
6828: PUSH
6829: LD_INT 4
6831: ARRAY
6832: PPUSH
6833: LD_VAR 0 33
6837: PUSH
6838: LD_INT 5
6840: ARRAY
6841: PPUSH
6842: CALL_OW 428
6846: PUSH
6847: LD_INT 0
6849: EQUAL
6850: IFFALSE 6896
// Build ( eng , b_armoury , cr_br [ 4 ] , cr_br [ 5 ] , cr_br [ 6 ] , 30 ) else
6852: LD_VAR 0 2
6856: PPUSH
6857: LD_INT 4
6859: PPUSH
6860: LD_VAR 0 33
6864: PUSH
6865: LD_INT 4
6867: ARRAY
6868: PPUSH
6869: LD_VAR 0 33
6873: PUSH
6874: LD_INT 5
6876: ARRAY
6877: PPUSH
6878: LD_VAR 0 33
6882: PUSH
6883: LD_INT 6
6885: ARRAY
6886: PPUSH
6887: LD_INT 30
6889: PPUSH
6890: CALL 3859 0 6
6894: GO 6966
// if HexInfo ( cr_br [ 7 ] , cr_br [ 8 ] ) = 0 then
6896: LD_VAR 0 33
6900: PUSH
6901: LD_INT 7
6903: ARRAY
6904: PPUSH
6905: LD_VAR 0 33
6909: PUSH
6910: LD_INT 8
6912: ARRAY
6913: PPUSH
6914: CALL_OW 428
6918: PUSH
6919: LD_INT 0
6921: EQUAL
6922: IFFALSE 6966
// Build ( eng , b_armoury , cr_br [ 7 ] , cr_br [ 8 ] , cr_br [ 9 ] , 30 ) ;
6924: LD_VAR 0 2
6928: PPUSH
6929: LD_INT 4
6931: PPUSH
6932: LD_VAR 0 33
6936: PUSH
6937: LD_INT 7
6939: ARRAY
6940: PPUSH
6941: LD_VAR 0 33
6945: PUSH
6946: LD_INT 8
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 33
6954: PUSH
6955: LD_INT 9
6957: ARRAY
6958: PPUSH
6959: LD_INT 30
6961: PPUSH
6962: CALL 3859 0 6
// end ; if AnyBuildingExist ( side , b_armoury ) then
6966: LD_VAR 0 20
6970: PPUSH
6971: LD_INT 4
6973: PPUSH
6974: CALL 1909 0 2
6978: IFFALSE 6995
// Upgrade ( side , b_armoury , 30 ) ;
6980: LD_VAR 0 20
6984: PPUSH
6985: LD_INT 4
6987: PPUSH
6988: LD_INT 30
6990: PPUSH
6991: CALL 4057 0 3
// x_b := ( cr_lab ) / 5 ;
6995: LD_ADDR_VAR 0 43
6999: PUSH
7000: LD_VAR 0 28
7004: PUSH
7005: LD_INT 5
7007: DIVREAL
7008: ST_TO_ADDR
// if scs_scan_lab ( side ) < ( x_b - 1 ) then
7009: LD_VAR 0 20
7013: PPUSH
7014: CALL 3652 0 1
7018: PUSH
7019: LD_VAR 0 43
7023: PUSH
7024: LD_INT 1
7026: MINUS
7027: LESS
7028: IFFALSE 7244
// begin if HexInfo ( cr_lab [ 1 ] , cr_lab [ 2 ] ) = 0 then
7030: LD_VAR 0 28
7034: PUSH
7035: LD_INT 1
7037: ARRAY
7038: PPUSH
7039: LD_VAR 0 28
7043: PUSH
7044: LD_INT 2
7046: ARRAY
7047: PPUSH
7048: CALL_OW 428
7052: PUSH
7053: LD_INT 0
7055: EQUAL
7056: IFFALSE 7102
// Build ( eng , b_lab , cr_lab [ 1 ] , cr_lab [ 2 ] , cr_lab [ 3 ] , 20 ) else
7058: LD_VAR 0 2
7062: PPUSH
7063: LD_INT 6
7065: PPUSH
7066: LD_VAR 0 28
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PPUSH
7075: LD_VAR 0 28
7079: PUSH
7080: LD_INT 2
7082: ARRAY
7083: PPUSH
7084: LD_VAR 0 28
7088: PUSH
7089: LD_INT 3
7091: ARRAY
7092: PPUSH
7093: LD_INT 20
7095: PPUSH
7096: CALL 3859 0 6
7100: GO 7244
// if HexInfo ( cr_lab [ 6 ] , cr_lab [ 7 ] ) = 0 then
7102: LD_VAR 0 28
7106: PUSH
7107: LD_INT 6
7109: ARRAY
7110: PPUSH
7111: LD_VAR 0 28
7115: PUSH
7116: LD_INT 7
7118: ARRAY
7119: PPUSH
7120: CALL_OW 428
7124: PUSH
7125: LD_INT 0
7127: EQUAL
7128: IFFALSE 7174
// Build ( eng , b_lab , cr_lab [ 6 ] , cr_lab [ 7 ] , cr_lab [ 8 ] , 20 ) else
7130: LD_VAR 0 2
7134: PPUSH
7135: LD_INT 6
7137: PPUSH
7138: LD_VAR 0 28
7142: PUSH
7143: LD_INT 6
7145: ARRAY
7146: PPUSH
7147: LD_VAR 0 28
7151: PUSH
7152: LD_INT 7
7154: ARRAY
7155: PPUSH
7156: LD_VAR 0 28
7160: PUSH
7161: LD_INT 8
7163: ARRAY
7164: PPUSH
7165: LD_INT 20
7167: PPUSH
7168: CALL 3859 0 6
7172: GO 7244
// if HexInfo ( cr_lab [ 11 ] , cr_lab [ 12 ] ) = 0 then
7174: LD_VAR 0 28
7178: PUSH
7179: LD_INT 11
7181: ARRAY
7182: PPUSH
7183: LD_VAR 0 28
7187: PUSH
7188: LD_INT 12
7190: ARRAY
7191: PPUSH
7192: CALL_OW 428
7196: PUSH
7197: LD_INT 0
7199: EQUAL
7200: IFFALSE 7244
// Build ( eng , b_lab , cr_lab [ 11 ] , cr_lab [ 12 ] , cr_lab [ 13 ] , 20 ) ;
7202: LD_VAR 0 2
7206: PPUSH
7207: LD_INT 6
7209: PPUSH
7210: LD_VAR 0 28
7214: PUSH
7215: LD_INT 11
7217: ARRAY
7218: PPUSH
7219: LD_VAR 0 28
7223: PUSH
7224: LD_INT 12
7226: ARRAY
7227: PPUSH
7228: LD_VAR 0 28
7232: PUSH
7233: LD_INT 13
7235: ARRAY
7236: PPUSH
7237: LD_INT 20
7239: PPUSH
7240: CALL 3859 0 6
// end ; if scs_scan_lab ( side ) = 2 then
7244: LD_VAR 0 20
7248: PPUSH
7249: CALL 3652 0 1
7253: PUSH
7254: LD_INT 2
7256: EQUAL
7257: IFFALSE 7523
// begin if scs_scan_buildings ( side , 6 ) <= 2 and scs_scan_buildings ( side , 7 ) = 0 then
7259: LD_VAR 0 20
7263: PPUSH
7264: LD_INT 6
7266: PPUSH
7267: CALL 3725 0 2
7271: PUSH
7272: LD_INT 2
7274: LESSEQUAL
7275: PUSH
7276: LD_VAR 0 20
7280: PPUSH
7281: LD_INT 7
7283: PPUSH
7284: CALL 3725 0 2
7288: PUSH
7289: LD_INT 0
7291: EQUAL
7292: AND
7293: IFFALSE 7325
// UpgradeLab ( scs_scan_lab ( side ) [ 1 ] , cr_lab [ 4 ] , 50 ) ;
7295: LD_VAR 0 20
7299: PPUSH
7300: CALL 3652 0 1
7304: PUSH
7305: LD_INT 1
7307: ARRAY
7308: PPUSH
7309: LD_VAR 0 28
7313: PUSH
7314: LD_INT 4
7316: ARRAY
7317: PPUSH
7318: LD_INT 50
7320: PPUSH
7321: CALL 4205 0 3
// if scs_scan_buildings ( side , 6 ) = 1 and scs_scan_buildings ( side , 7 ) = 1 then
7325: LD_VAR 0 20
7329: PPUSH
7330: LD_INT 6
7332: PPUSH
7333: CALL 3725 0 2
7337: PUSH
7338: LD_INT 1
7340: EQUAL
7341: PUSH
7342: LD_VAR 0 20
7346: PPUSH
7347: LD_INT 7
7349: PPUSH
7350: CALL 3725 0 2
7354: PUSH
7355: LD_INT 1
7357: EQUAL
7358: AND
7359: IFFALSE 7391
// UpgradeLab ( scs_scan_lab ( side ) [ 2 ] , cr_lab [ 9 ] , 20 ) ;
7361: LD_VAR 0 20
7365: PPUSH
7366: CALL 3652 0 1
7370: PUSH
7371: LD_INT 2
7373: ARRAY
7374: PPUSH
7375: LD_VAR 0 28
7379: PUSH
7380: LD_INT 9
7382: ARRAY
7383: PPUSH
7384: LD_INT 20
7386: PPUSH
7387: CALL 4205 0 3
// if scs_scan_buildings ( side , 7 ) = 1 and scs_scan_buildings ( side , 8 ) = 0 then
7391: LD_VAR 0 20
7395: PPUSH
7396: LD_INT 7
7398: PPUSH
7399: CALL 3725 0 2
7403: PUSH
7404: LD_INT 1
7406: EQUAL
7407: PUSH
7408: LD_VAR 0 20
7412: PPUSH
7413: LD_INT 8
7415: PPUSH
7416: CALL 3725 0 2
7420: PUSH
7421: LD_INT 0
7423: EQUAL
7424: AND
7425: IFFALSE 7457
// UpgradeLab ( scs_scan_lab ( side ) [ 1 ] , cr_lab [ 5 ] , 20 ) ;
7427: LD_VAR 0 20
7431: PPUSH
7432: CALL 3652 0 1
7436: PUSH
7437: LD_INT 1
7439: ARRAY
7440: PPUSH
7441: LD_VAR 0 28
7445: PUSH
7446: LD_INT 5
7448: ARRAY
7449: PPUSH
7450: LD_INT 20
7452: PPUSH
7453: CALL 4205 0 3
// if scs_scan_buildings ( side , 7 ) = 1 and scs_scan_buildings ( side , 8 ) = 1 then
7457: LD_VAR 0 20
7461: PPUSH
7462: LD_INT 7
7464: PPUSH
7465: CALL 3725 0 2
7469: PUSH
7470: LD_INT 1
7472: EQUAL
7473: PUSH
7474: LD_VAR 0 20
7478: PPUSH
7479: LD_INT 8
7481: PPUSH
7482: CALL 3725 0 2
7486: PUSH
7487: LD_INT 1
7489: EQUAL
7490: AND
7491: IFFALSE 7523
// UpgradeLab ( scs_scan_lab ( side ) [ 2 ] , cr_lab [ 10 ] , 20 ) ;
7493: LD_VAR 0 20
7497: PPUSH
7498: CALL 3652 0 1
7502: PUSH
7503: LD_INT 2
7505: ARRAY
7506: PPUSH
7507: LD_VAR 0 28
7511: PUSH
7512: LD_INT 10
7514: ARRAY
7515: PPUSH
7516: LD_INT 20
7518: PPUSH
7519: CALL 4205 0 3
// end ; x_c := cr_pow / 4 ;
7523: LD_ADDR_VAR 0 44
7527: PUSH
7528: LD_VAR 0 31
7532: PUSH
7533: LD_INT 4
7535: DIVREAL
7536: ST_TO_ADDR
// if scs_scan_buildings ( side , b_solar_power ) + scs_scan_buildings ( side , b_oil_power ) + scs_scan_buildings ( side , b_siberite_power ) < ( x_c - 1 ) then
7537: LD_VAR 0 20
7541: PPUSH
7542: LD_INT 27
7544: PPUSH
7545: CALL 3725 0 2
7549: PUSH
7550: LD_VAR 0 20
7554: PPUSH
7555: LD_INT 26
7557: PPUSH
7558: CALL 3725 0 2
7562: PLUS
7563: PUSH
7564: LD_VAR 0 20
7568: PPUSH
7569: LD_INT 28
7571: PPUSH
7572: CALL 3725 0 2
7576: PLUS
7577: PUSH
7578: LD_VAR 0 44
7582: PUSH
7583: LD_INT 1
7585: MINUS
7586: LESS
7587: IFFALSE 7709
// begin if HexInfo ( cr_pow [ 1 ] , cr_pow [ 2 ] ) = 0 then
7589: LD_VAR 0 31
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: LD_VAR 0 31
7602: PUSH
7603: LD_INT 2
7605: ARRAY
7606: PPUSH
7607: CALL_OW 428
7611: PUSH
7612: LD_INT 0
7614: EQUAL
7615: IFFALSE 7664
// BuildPowerPlant ( eng , cr_pow [ 4 ] , cr_pow [ 1 ] , cr_pow [ 2 ] , cr_pow [ 3 ] ) else
7617: LD_VAR 0 2
7621: PPUSH
7622: LD_VAR 0 31
7626: PUSH
7627: LD_INT 4
7629: ARRAY
7630: PPUSH
7631: LD_VAR 0 31
7635: PUSH
7636: LD_INT 1
7638: ARRAY
7639: PPUSH
7640: LD_VAR 0 31
7644: PUSH
7645: LD_INT 2
7647: ARRAY
7648: PPUSH
7649: LD_VAR 0 31
7653: PUSH
7654: LD_INT 3
7656: ARRAY
7657: PPUSH
7658: CALL 4319 0 5
7662: GO 7709
// BuildPowerPlant ( eng , cr_pow [ 8 ] , cr_pow [ 5 ] , cr_pow [ 6 ] , cr_pow [ 7 ] ) ;
7664: LD_VAR 0 2
7668: PPUSH
7669: LD_VAR 0 31
7673: PUSH
7674: LD_INT 8
7676: ARRAY
7677: PPUSH
7678: LD_VAR 0 31
7682: PUSH
7683: LD_INT 5
7685: ARRAY
7686: PPUSH
7687: LD_VAR 0 31
7691: PUSH
7692: LD_INT 6
7694: ARRAY
7695: PPUSH
7696: LD_VAR 0 31
7700: PUSH
7701: LD_INT 7
7703: ARRAY
7704: PPUSH
7705: CALL 4319 0 5
// end ; x_d := ( cr_add / 3 ) / 2 ;
7709: LD_ADDR_VAR 0 45
7713: PUSH
7714: LD_VAR 0 34
7718: PUSH
7719: LD_INT 3
7721: DIVREAL
7722: PUSH
7723: LD_INT 2
7725: DIVREAL
7726: ST_TO_ADDR
// if super_source = false then
7727: LD_EXP 71
7731: PUSH
7732: LD_INT 0
7734: EQUAL
7735: IFFALSE 7751
// x_d := x_d - 1 ;
7737: LD_ADDR_VAR 0 45
7741: PUSH
7742: LD_VAR 0 45
7746: PUSH
7747: LD_INT 1
7749: MINUS
7750: ST_TO_ADDR
// if scs_scan_buildings ( side , b_oil_mine ) < x_d then
7751: LD_VAR 0 20
7755: PPUSH
7756: LD_INT 29
7758: PPUSH
7759: CALL 3725 0 2
7763: PUSH
7764: LD_VAR 0 45
7768: LESS
7769: IFFALSE 8141
// begin if GetResourceVisibility ( cr_add [ 1 ] , cr_add [ 2 ] , side ) = false then
7771: LD_VAR 0 34
7775: PUSH
7776: LD_INT 1
7778: ARRAY
7779: PPUSH
7780: LD_VAR 0 34
7784: PUSH
7785: LD_INT 2
7787: ARRAY
7788: PPUSH
7789: LD_VAR 0 20
7793: PPUSH
7794: CALL_OW 440
7798: PUSH
7799: LD_INT 0
7801: EQUAL
7802: IFFALSE 7881
// begin if IsInUnit ( sci [ 1 ] ) then
7804: LD_VAR 0 4
7808: PUSH
7809: LD_INT 1
7811: ARRAY
7812: PPUSH
7813: CALL_OW 310
7817: IFFALSE 7832
// ComExitBuilding ( sci [ 1 ] ) ;
7819: LD_VAR 0 4
7823: PUSH
7824: LD_INT 1
7826: ARRAY
7827: PPUSH
7828: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
7832: LD_VAR 0 4
7836: PUSH
7837: LD_INT 1
7839: ARRAY
7840: PPUSH
7841: CALL_OW 314
7845: NOT
7846: IFFALSE 7879
// ComMoveXY ( sci [ 1 ] , cr_add [ 1 ] , cr_add [ 2 ] ) ;
7848: LD_VAR 0 4
7852: PUSH
7853: LD_INT 1
7855: ARRAY
7856: PPUSH
7857: LD_VAR 0 34
7861: PUSH
7862: LD_INT 1
7864: ARRAY
7865: PPUSH
7866: LD_VAR 0 34
7870: PUSH
7871: LD_INT 2
7873: ARRAY
7874: PPUSH
7875: CALL_OW 111
// end else
7879: GO 7953
// begin if HexInfo ( cr_add [ 1 ] , cr_add [ 2 ] ) = 0 then
7881: LD_VAR 0 34
7885: PUSH
7886: LD_INT 1
7888: ARRAY
7889: PPUSH
7890: LD_VAR 0 34
7894: PUSH
7895: LD_INT 2
7897: ARRAY
7898: PPUSH
7899: CALL_OW 428
7903: PUSH
7904: LD_INT 0
7906: EQUAL
7907: IFFALSE 7953
// Build ( eng , b_oil_mine , cr_add [ 1 ] , cr_add [ 2 ] , Rand ( 0 , 5 ) , 10 ) ;
7909: LD_VAR 0 2
7913: PPUSH
7914: LD_INT 29
7916: PPUSH
7917: LD_VAR 0 34
7921: PUSH
7922: LD_INT 1
7924: ARRAY
7925: PPUSH
7926: LD_VAR 0 34
7930: PUSH
7931: LD_INT 2
7933: ARRAY
7934: PPUSH
7935: LD_INT 0
7937: PPUSH
7938: LD_INT 5
7940: PPUSH
7941: CALL_OW 12
7945: PPUSH
7946: LD_INT 10
7948: PPUSH
7949: CALL 3859 0 6
// end ; if GetResourceVisibility ( cr_add [ 4 ] , cr_add [ 5 ] , side ) = false and super_source then
7953: LD_VAR 0 34
7957: PUSH
7958: LD_INT 4
7960: ARRAY
7961: PPUSH
7962: LD_VAR 0 34
7966: PUSH
7967: LD_INT 5
7969: ARRAY
7970: PPUSH
7971: LD_VAR 0 20
7975: PPUSH
7976: CALL_OW 440
7980: PUSH
7981: LD_INT 0
7983: EQUAL
7984: PUSH
7985: LD_EXP 71
7989: AND
7990: IFFALSE 8069
// begin if IsInUnit ( sci [ 1 ] ) then
7992: LD_VAR 0 4
7996: PUSH
7997: LD_INT 1
7999: ARRAY
8000: PPUSH
8001: CALL_OW 310
8005: IFFALSE 8020
// ComExitBuilding ( sci [ 1 ] ) ;
8007: LD_VAR 0 4
8011: PUSH
8012: LD_INT 1
8014: ARRAY
8015: PPUSH
8016: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
8020: LD_VAR 0 4
8024: PUSH
8025: LD_INT 1
8027: ARRAY
8028: PPUSH
8029: CALL_OW 314
8033: NOT
8034: IFFALSE 8067
// ComMoveXY ( sci [ 1 ] , cr_add [ 4 ] , cr_add [ 5 ] ) ;
8036: LD_VAR 0 4
8040: PUSH
8041: LD_INT 1
8043: ARRAY
8044: PPUSH
8045: LD_VAR 0 34
8049: PUSH
8050: LD_INT 4
8052: ARRAY
8053: PPUSH
8054: LD_VAR 0 34
8058: PUSH
8059: LD_INT 5
8061: ARRAY
8062: PPUSH
8063: CALL_OW 111
// end else
8067: GO 8141
// begin if HexInfo ( cr_add [ 4 ] , cr_add [ 5 ] ) = 0 then
8069: LD_VAR 0 34
8073: PUSH
8074: LD_INT 4
8076: ARRAY
8077: PPUSH
8078: LD_VAR 0 34
8082: PUSH
8083: LD_INT 5
8085: ARRAY
8086: PPUSH
8087: CALL_OW 428
8091: PUSH
8092: LD_INT 0
8094: EQUAL
8095: IFFALSE 8141
// Build ( eng , b_oil_mine , cr_add [ 4 ] , cr_add [ 5 ] , Rand ( 0 , 5 ) , 10 ) ;
8097: LD_VAR 0 2
8101: PPUSH
8102: LD_INT 29
8104: PPUSH
8105: LD_VAR 0 34
8109: PUSH
8110: LD_INT 4
8112: ARRAY
8113: PPUSH
8114: LD_VAR 0 34
8118: PUSH
8119: LD_INT 5
8121: ARRAY
8122: PPUSH
8123: LD_INT 0
8125: PPUSH
8126: LD_INT 5
8128: PPUSH
8129: CALL_OW 12
8133: PPUSH
8134: LD_INT 10
8136: PPUSH
8137: CALL 3859 0 6
// end ; end ; end ; if scs_scan_buildings ( side , b_siberite_mine ) < x_d and GetTech ( 20 , side ) = state_researched then
8141: LD_VAR 0 20
8145: PPUSH
8146: LD_INT 30
8148: PPUSH
8149: CALL 3725 0 2
8153: PUSH
8154: LD_VAR 0 45
8158: LESS
8159: PUSH
8160: LD_INT 20
8162: PPUSH
8163: LD_VAR 0 20
8167: PPUSH
8168: CALL_OW 321
8172: PUSH
8173: LD_INT 2
8175: EQUAL
8176: AND
8177: IFFALSE 8549
// begin if GetResourceVisibility ( cr_add [ 7 ] , cr_add [ 8 ] , side ) = false then
8179: LD_VAR 0 34
8183: PUSH
8184: LD_INT 7
8186: ARRAY
8187: PPUSH
8188: LD_VAR 0 34
8192: PUSH
8193: LD_INT 8
8195: ARRAY
8196: PPUSH
8197: LD_VAR 0 20
8201: PPUSH
8202: CALL_OW 440
8206: PUSH
8207: LD_INT 0
8209: EQUAL
8210: IFFALSE 8289
// begin if IsInUnit ( sci [ 1 ] ) then
8212: LD_VAR 0 4
8216: PUSH
8217: LD_INT 1
8219: ARRAY
8220: PPUSH
8221: CALL_OW 310
8225: IFFALSE 8240
// ComExitBuilding ( sci [ 1 ] ) ;
8227: LD_VAR 0 4
8231: PUSH
8232: LD_INT 1
8234: ARRAY
8235: PPUSH
8236: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
8240: LD_VAR 0 4
8244: PUSH
8245: LD_INT 1
8247: ARRAY
8248: PPUSH
8249: CALL_OW 314
8253: NOT
8254: IFFALSE 8287
// ComMoveXY ( sci [ 1 ] , cr_add [ 7 ] , cr_add [ 8 ] ) ;
8256: LD_VAR 0 4
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_VAR 0 34
8269: PUSH
8270: LD_INT 7
8272: ARRAY
8273: PPUSH
8274: LD_VAR 0 34
8278: PUSH
8279: LD_INT 8
8281: ARRAY
8282: PPUSH
8283: CALL_OW 111
// end else
8287: GO 8361
// begin if HexInfo ( cr_add [ 7 ] , cr_add [ 8 ] ) = 0 then
8289: LD_VAR 0 34
8293: PUSH
8294: LD_INT 7
8296: ARRAY
8297: PPUSH
8298: LD_VAR 0 34
8302: PUSH
8303: LD_INT 8
8305: ARRAY
8306: PPUSH
8307: CALL_OW 428
8311: PUSH
8312: LD_INT 0
8314: EQUAL
8315: IFFALSE 8361
// Build ( eng , b_siberite_mine , cr_add [ 7 ] , cr_add [ 8 ] , Rand ( 0 , 5 ) , 10 ) ;
8317: LD_VAR 0 2
8321: PPUSH
8322: LD_INT 30
8324: PPUSH
8325: LD_VAR 0 34
8329: PUSH
8330: LD_INT 7
8332: ARRAY
8333: PPUSH
8334: LD_VAR 0 34
8338: PUSH
8339: LD_INT 8
8341: ARRAY
8342: PPUSH
8343: LD_INT 0
8345: PPUSH
8346: LD_INT 5
8348: PPUSH
8349: CALL_OW 12
8353: PPUSH
8354: LD_INT 10
8356: PPUSH
8357: CALL 3859 0 6
// end ; if GetResourceVisibility ( cr_add [ 10 ] , cr_add [ 11 ] , side ) = false and super_source then
8361: LD_VAR 0 34
8365: PUSH
8366: LD_INT 10
8368: ARRAY
8369: PPUSH
8370: LD_VAR 0 34
8374: PUSH
8375: LD_INT 11
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 20
8383: PPUSH
8384: CALL_OW 440
8388: PUSH
8389: LD_INT 0
8391: EQUAL
8392: PUSH
8393: LD_EXP 71
8397: AND
8398: IFFALSE 8477
// begin if IsInUnit ( sci [ 1 ] ) then
8400: LD_VAR 0 4
8404: PUSH
8405: LD_INT 1
8407: ARRAY
8408: PPUSH
8409: CALL_OW 310
8413: IFFALSE 8428
// ComExitBuilding ( sci [ 1 ] ) ;
8415: LD_VAR 0 4
8419: PUSH
8420: LD_INT 1
8422: ARRAY
8423: PPUSH
8424: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
8428: LD_VAR 0 4
8432: PUSH
8433: LD_INT 1
8435: ARRAY
8436: PPUSH
8437: CALL_OW 314
8441: NOT
8442: IFFALSE 8475
// ComMoveXY ( sci [ 1 ] , cr_add [ 10 ] , cr_add [ 11 ] ) ;
8444: LD_VAR 0 4
8448: PUSH
8449: LD_INT 1
8451: ARRAY
8452: PPUSH
8453: LD_VAR 0 34
8457: PUSH
8458: LD_INT 10
8460: ARRAY
8461: PPUSH
8462: LD_VAR 0 34
8466: PUSH
8467: LD_INT 11
8469: ARRAY
8470: PPUSH
8471: CALL_OW 111
// end else
8475: GO 8549
// begin if HexInfo ( cr_add [ 10 ] , cr_add [ 11 ] ) = 0 then
8477: LD_VAR 0 34
8481: PUSH
8482: LD_INT 10
8484: ARRAY
8485: PPUSH
8486: LD_VAR 0 34
8490: PUSH
8491: LD_INT 11
8493: ARRAY
8494: PPUSH
8495: CALL_OW 428
8499: PUSH
8500: LD_INT 0
8502: EQUAL
8503: IFFALSE 8549
// Build ( eng , b_siberite_mine , cr_add [ 10 ] , cr_add [ 11 ] , Rand ( 0 , 5 ) , 10 ) ;
8505: LD_VAR 0 2
8509: PPUSH
8510: LD_INT 30
8512: PPUSH
8513: LD_VAR 0 34
8517: PUSH
8518: LD_INT 10
8520: ARRAY
8521: PPUSH
8522: LD_VAR 0 34
8526: PUSH
8527: LD_INT 11
8529: ARRAY
8530: PPUSH
8531: LD_INT 0
8533: PPUSH
8534: LD_INT 5
8536: PPUSH
8537: CALL_OW 12
8541: PPUSH
8542: LD_INT 10
8544: PPUSH
8545: CALL 3859 0 6
// end ; end ; if AnyBuildingExist ( side , b_workshop ) = false and AnyBuildingExist ( side , b_factory ) = false then
8549: LD_VAR 0 20
8553: PPUSH
8554: LD_INT 2
8556: PPUSH
8557: CALL 1909 0 2
8561: PUSH
8562: LD_INT 0
8564: EQUAL
8565: PUSH
8566: LD_VAR 0 20
8570: PPUSH
8571: LD_INT 3
8573: PPUSH
8574: CALL 1909 0 2
8578: PUSH
8579: LD_INT 0
8581: EQUAL
8582: AND
8583: IFFALSE 8655
// begin if HexInfo ( cr_fab [ 1 ] , cr_fab [ 2 ] ) = 0 then
8585: LD_VAR 0 29
8589: PUSH
8590: LD_INT 1
8592: ARRAY
8593: PPUSH
8594: LD_VAR 0 29
8598: PUSH
8599: LD_INT 2
8601: ARRAY
8602: PPUSH
8603: CALL_OW 428
8607: PUSH
8608: LD_INT 0
8610: EQUAL
8611: IFFALSE 8655
// Build ( eng , b_workshop , cr_fab [ 1 ] , cr_fab [ 2 ] , cr_fab [ 3 ] , 40 ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 2
8620: PPUSH
8621: LD_VAR 0 29
8625: PUSH
8626: LD_INT 1
8628: ARRAY
8629: PPUSH
8630: LD_VAR 0 29
8634: PUSH
8635: LD_INT 2
8637: ARRAY
8638: PPUSH
8639: LD_VAR 0 29
8643: PUSH
8644: LD_INT 3
8646: ARRAY
8647: PPUSH
8648: LD_INT 40
8650: PPUSH
8651: CALL 3859 0 6
// end ; if AnyBuildingExist ( side , b_workshop ) then
8655: LD_VAR 0 20
8659: PPUSH
8660: LD_INT 2
8662: PPUSH
8663: CALL 1909 0 2
8667: IFFALSE 8684
// Upgrade ( side , b_workshop , 40 ) ;
8669: LD_VAR 0 20
8673: PPUSH
8674: LD_INT 2
8676: PPUSH
8677: LD_INT 40
8679: PPUSH
8680: CALL 4057 0 3
// if AnyBuildingExist ( side , b_factory ) then
8684: LD_VAR 0 20
8688: PPUSH
8689: LD_INT 3
8691: PPUSH
8692: CALL 1909 0 2
8696: IFFALSE 8936
// begin fac := scs_scan_buildings ( side , b_factory ) [ 1 ] ;
8698: LD_ADDR_VAR 0 39
8702: PUSH
8703: LD_VAR 0 20
8707: PPUSH
8708: LD_INT 3
8710: PPUSH
8711: CALL 3725 0 2
8715: PUSH
8716: LD_INT 1
8718: ARRAY
8719: ST_TO_ADDR
// if AnyBuildingExist ( side , cr_ext [ 4 ] ) = 0 then
8720: LD_VAR 0 20
8724: PPUSH
8725: LD_VAR 0 30
8729: PUSH
8730: LD_INT 4
8732: ARRAY
8733: PPUSH
8734: CALL 1909 0 2
8738: PUSH
8739: LD_INT 0
8741: EQUAL
8742: IFFALSE 8792
// Build ( eng , cr_ext [ 4 ] , cr_ext [ 1 ] , cr_ext [ 2 ] , cr_ext [ 3 ] , 30 ) ;
8744: LD_VAR 0 2
8748: PPUSH
8749: LD_VAR 0 30
8753: PUSH
8754: LD_INT 4
8756: ARRAY
8757: PPUSH
8758: LD_VAR 0 30
8762: PUSH
8763: LD_INT 1
8765: ARRAY
8766: PPUSH
8767: LD_VAR 0 30
8771: PUSH
8772: LD_INT 2
8774: ARRAY
8775: PPUSH
8776: LD_VAR 0 30
8780: PUSH
8781: LD_INT 3
8783: ARRAY
8784: PPUSH
8785: LD_INT 30
8787: PPUSH
8788: CALL 3859 0 6
// if AnyBuildingExist ( side , cr_ext [ 8 ] ) = 0 then
8792: LD_VAR 0 20
8796: PPUSH
8797: LD_VAR 0 30
8801: PUSH
8802: LD_INT 8
8804: ARRAY
8805: PPUSH
8806: CALL 1909 0 2
8810: PUSH
8811: LD_INT 0
8813: EQUAL
8814: IFFALSE 8864
// Build ( eng , cr_ext [ 8 ] , cr_ext [ 5 ] , cr_ext [ 6 ] , cr_ext [ 7 ] , 30 ) ;
8816: LD_VAR 0 2
8820: PPUSH
8821: LD_VAR 0 30
8825: PUSH
8826: LD_INT 8
8828: ARRAY
8829: PPUSH
8830: LD_VAR 0 30
8834: PUSH
8835: LD_INT 5
8837: ARRAY
8838: PPUSH
8839: LD_VAR 0 30
8843: PUSH
8844: LD_INT 6
8846: ARRAY
8847: PPUSH
8848: LD_VAR 0 30
8852: PUSH
8853: LD_INT 7
8855: ARRAY
8856: PPUSH
8857: LD_INT 30
8859: PPUSH
8860: CALL 3859 0 6
// if AnyBuildingExist ( side , cr_ext [ 12 ] ) = 0 then
8864: LD_VAR 0 20
8868: PPUSH
8869: LD_VAR 0 30
8873: PUSH
8874: LD_INT 12
8876: ARRAY
8877: PPUSH
8878: CALL 1909 0 2
8882: PUSH
8883: LD_INT 0
8885: EQUAL
8886: IFFALSE 8936
// Build ( eng , cr_ext [ 12 ] , cr_ext [ 9 ] , cr_ext [ 10 ] , cr_ext [ 11 ] , 35 ) ;
8888: LD_VAR 0 2
8892: PPUSH
8893: LD_VAR 0 30
8897: PUSH
8898: LD_INT 12
8900: ARRAY
8901: PPUSH
8902: LD_VAR 0 30
8906: PUSH
8907: LD_INT 9
8909: ARRAY
8910: PPUSH
8911: LD_VAR 0 30
8915: PUSH
8916: LD_INT 10
8918: ARRAY
8919: PPUSH
8920: LD_VAR 0 30
8924: PUSH
8925: LD_INT 11
8927: ARRAY
8928: PPUSH
8929: LD_INT 35
8931: PPUSH
8932: CALL 3859 0 6
// end ; end else
8936: GO 9294
// begin if eng > 0 then
8938: LD_VAR 0 2
8942: PUSH
8943: LD_INT 0
8945: GREATER
8946: IFFALSE 9172
// begin for i = 1 to eng do
8948: LD_ADDR_VAR 0 11
8952: PUSH
8953: DOUBLE
8954: LD_INT 1
8956: DEC
8957: ST_TO_ADDR
8958: LD_VAR 0 2
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9067
// if not HasTask ( eng [ i ] ) and scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 15 ) = false then
8966: LD_VAR 0 2
8970: PUSH
8971: LD_VAR 0 11
8975: ARRAY
8976: PPUSH
8977: CALL_OW 314
8981: NOT
8982: PUSH
8983: LD_VAR 0 20
8987: PPUSH
8988: LD_VAR 0 27
8992: PUSH
8993: LD_INT 1
8995: ARRAY
8996: PPUSH
8997: LD_VAR 0 27
9001: PUSH
9002: LD_INT 2
9004: ARRAY
9005: PPUSH
9006: LD_INT 15
9008: PPUSH
9009: CALL 3565 0 4
9013: PUSH
9014: LD_INT 0
9016: EQUAL
9017: AND
9018: IFFALSE 9065
// ComBuild ( eng [ i ] , b_depot , cr_dep [ 1 ] , cr_dep [ 2 ] , cr_dep [ 3 ] ) ;
9020: LD_VAR 0 2
9024: PUSH
9025: LD_VAR 0 11
9029: ARRAY
9030: PPUSH
9031: LD_INT 0
9033: PPUSH
9034: LD_VAR 0 27
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_VAR 0 27
9047: PUSH
9048: LD_INT 2
9050: ARRAY
9051: PPUSH
9052: LD_VAR 0 27
9056: PUSH
9057: LD_INT 3
9059: ARRAY
9060: PPUSH
9061: CALL_OW 145
9065: GO 8963
9067: POP
9068: POP
// for un in sol ^ mech ^ sci do
9069: LD_ADDR_VAR 0 14
9073: PUSH
9074: LD_VAR 0 1
9078: PUSH
9079: LD_VAR 0 3
9083: ADD
9084: PUSH
9085: LD_VAR 0 4
9089: ADD
9090: PUSH
9091: FOR_IN
9092: IFFALSE 9168
// begin if not HasTask ( un ) and GetDistUnitXY ( un , cr_dep [ 1 ] , cr_dep [ 2 ] ) > 7 then
9094: LD_VAR 0 14
9098: PPUSH
9099: CALL_OW 314
9103: NOT
9104: PUSH
9105: LD_VAR 0 14
9109: PPUSH
9110: LD_VAR 0 27
9114: PUSH
9115: LD_INT 1
9117: ARRAY
9118: PPUSH
9119: LD_VAR 0 27
9123: PUSH
9124: LD_INT 2
9126: ARRAY
9127: PPUSH
9128: CALL_OW 297
9132: PUSH
9133: LD_INT 7
9135: GREATER
9136: AND
9137: IFFALSE 9166
// ComMoveXY ( un , cr_dep [ 1 ] , cr_dep [ 2 ] ) ;
9139: LD_VAR 0 14
9143: PPUSH
9144: LD_VAR 0 27
9148: PUSH
9149: LD_INT 1
9151: ARRAY
9152: PPUSH
9153: LD_VAR 0 27
9157: PUSH
9158: LD_INT 2
9160: ARRAY
9161: PPUSH
9162: CALL_OW 111
// end ;
9166: GO 9091
9168: POP
9169: POP
// end else
9170: GO 9294
// begin if sol ^ mech ^ sci = 0 then
9172: LD_VAR 0 1
9176: PUSH
9177: LD_VAR 0 3
9181: ADD
9182: PUSH
9183: LD_VAR 0 4
9187: ADD
9188: PUSH
9189: LD_INT 0
9191: EQUAL
9192: IFFALSE 9198
// exit else
9194: GO 11457
9196: GO 9294
// if ally then
9198: LD_VAR 0 35
9202: IFFALSE 9229
// scs_change_side ( side , GetSide ( ally [ 1 ] ) ) else
9204: LD_VAR 0 20
9208: PPUSH
9209: LD_VAR 0 35
9213: PUSH
9214: LD_INT 1
9216: ARRAY
9217: PPUSH
9218: CALL_OW 255
9222: PPUSH
9223: CALL 3771 0 2
9227: GO 9294
// begin for un in sol ^ mech ^ sci do
9229: LD_ADDR_VAR 0 14
9233: PUSH
9234: LD_VAR 0 1
9238: PUSH
9239: LD_VAR 0 3
9243: ADD
9244: PUSH
9245: LD_VAR 0 4
9249: ADD
9250: PUSH
9251: FOR_IN
9252: IFFALSE 9292
// if not HasTask ( un ) then
9254: LD_VAR 0 14
9258: PPUSH
9259: CALL_OW 314
9263: NOT
9264: IFFALSE 9290
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
9266: LD_VAR 0 14
9270: PPUSH
9271: LD_VAR 0 36
9275: PPUSH
9276: LD_VAR 0 14
9280: PPUSH
9281: CALL_OW 74
9285: PPUSH
9286: CALL_OW 115
9290: GO 9251
9292: POP
9293: POP
// end ; end ; end ; if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 45 ) then
9294: LD_VAR 0 20
9298: PPUSH
9299: LD_VAR 0 27
9303: PUSH
9304: LD_INT 1
9306: ARRAY
9307: PPUSH
9308: LD_VAR 0 27
9312: PUSH
9313: LD_INT 2
9315: ARRAY
9316: PPUSH
9317: LD_INT 45
9319: PPUSH
9320: CALL 3565 0 4
9324: IFFALSE 9711
// begin if AnyBuildingExist ( side , b_armoury ) or AnyBuildingExist ( side , b_barracks ) then
9326: LD_VAR 0 20
9330: PPUSH
9331: LD_INT 4
9333: PPUSH
9334: CALL 1909 0 2
9338: PUSH
9339: LD_VAR 0 20
9343: PPUSH
9344: LD_INT 5
9346: PPUSH
9347: CALL 1909 0 2
9351: OR
9352: IFFALSE 9711
// begin if test then
9354: LD_EXP 84
9358: IFFALSE 9368
// display_strings := sold_1 ;
9360: LD_ADDR_OWVAR 47
9364: PUSH
9365: LD_STRING sold_1
9367: ST_TO_ADDR
// if scs_find_barracks ( side ) > 0 then
9368: LD_VAR 0 20
9372: PPUSH
9373: CALL 5083 0 1
9377: PUSH
9378: LD_INT 0
9380: GREATER
9381: IFFALSE 9711
// begin if ( sol < FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) * 6 + FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ) then
9383: LD_VAR 0 1
9387: PUSH
9388: LD_INT 22
9390: PUSH
9391: LD_VAR 0 20
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: PUSH
9400: LD_INT 2
9402: PUSH
9403: LD_INT 30
9405: PUSH
9406: LD_INT 4
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: LD_INT 30
9415: PUSH
9416: LD_INT 5
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PPUSH
9432: CALL_OW 69
9436: PUSH
9437: LD_INT 6
9439: MUL
9440: PUSH
9441: LD_INT 22
9443: PUSH
9444: LD_VAR 0 20
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: PUSH
9453: LD_INT 30
9455: PUSH
9456: LD_INT 32
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: PUSH
9463: LD_INT 58
9465: PUSH
9466: EMPTY
9467: LIST
9468: PUSH
9469: EMPTY
9470: LIST
9471: LIST
9472: LIST
9473: PPUSH
9474: CALL_OW 69
9478: PLUS
9479: LESS
9480: IFFALSE 9560
// begin if filter_c = 0 then
9482: LD_VAR 0 41
9486: PUSH
9487: LD_INT 0
9489: EQUAL
9490: IFFALSE 9532
// begin filter_c := eng ^ mech ^ sci ;
9492: LD_ADDR_VAR 0 41
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_VAR 0 3
9506: ADD
9507: PUSH
9508: LD_VAR 0 4
9512: ADD
9513: ST_TO_ADDR
// filter_c := SortFilter ( filter_c , 1 ) ;
9514: LD_ADDR_VAR 0 41
9518: PUSH
9519: LD_VAR 0 41
9523: PPUSH
9524: LD_INT 1
9526: PPUSH
9527: CALL 4683 0 2
9531: ST_TO_ADDR
// end ; if filter_c > 0 then
9532: LD_VAR 0 41
9536: PUSH
9537: LD_INT 0
9539: GREATER
9540: IFFALSE 9560
// scs_change_class ( filter_c [ filter_c ] , 1 ) ;
9542: LD_VAR 0 41
9546: PUSH
9547: LD_VAR 0 41
9551: ARRAY
9552: PPUSH
9553: LD_INT 1
9555: PPUSH
9556: CALL 4757 0 2
// end ; if sol > 0 then
9560: LD_VAR 0 1
9564: PUSH
9565: LD_INT 0
9567: GREATER
9568: IFFALSE 9711
// begin if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) > 0 then
9570: LD_INT 22
9572: PUSH
9573: LD_VAR 0 20
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: LD_INT 32
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: LD_INT 58
9594: PUSH
9595: EMPTY
9596: LIST
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 69
9607: PUSH
9608: LD_INT 0
9610: GREATER
9611: IFFALSE 9624
// FillTowers ( side ) else
9613: LD_VAR 0 20
9617: PPUSH
9618: CALL 5737 0 1
9622: GO 9711
// for i = 1 to sol do
9624: LD_ADDR_VAR 0 11
9628: PUSH
9629: DOUBLE
9630: LD_INT 1
9632: DEC
9633: ST_TO_ADDR
9634: LD_VAR 0 1
9638: PUSH
9639: FOR_TO
9640: IFFALSE 9709
// if not IsInUnit ( sol [ i ] ) and not HasTask ( sol [ i ] ) then
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 11
9651: ARRAY
9652: PPUSH
9653: CALL_OW 310
9657: NOT
9658: PUSH
9659: LD_VAR 0 1
9663: PUSH
9664: LD_VAR 0 11
9668: ARRAY
9669: PPUSH
9670: CALL_OW 314
9674: NOT
9675: AND
9676: IFFALSE 9707
// ComEnterUnit ( sol [ i ] , scs_find_barracks ( side ) [ 1 ] ) ;
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 11
9687: ARRAY
9688: PPUSH
9689: LD_VAR 0 20
9693: PPUSH
9694: CALL 5083 0 1
9698: PUSH
9699: LD_INT 1
9701: ARRAY
9702: PPUSH
9703: CALL_OW 120
9707: GO 9639
9709: POP
9710: POP
// end ; end ; end ; end ; if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
9711: LD_VAR 0 20
9715: PPUSH
9716: LD_INT 0
9718: PPUSH
9719: CALL 1909 0 2
9723: PUSH
9724: LD_VAR 0 20
9728: PPUSH
9729: LD_INT 1
9731: PPUSH
9732: CALL 1909 0 2
9736: OR
9737: IFFALSE 9909
// begin if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 45 ) = false then
9739: LD_VAR 0 20
9743: PPUSH
9744: LD_VAR 0 27
9748: PUSH
9749: LD_INT 1
9751: ARRAY
9752: PPUSH
9753: LD_VAR 0 27
9757: PUSH
9758: LD_INT 2
9760: ARRAY
9761: PPUSH
9762: LD_INT 45
9764: PPUSH
9765: CALL 3565 0 4
9769: PUSH
9770: LD_INT 0
9772: EQUAL
9773: IFFALSE 9909
// begin for i = 1 to sol do
9775: LD_ADDR_VAR 0 11
9779: PUSH
9780: DOUBLE
9781: LD_INT 1
9783: DEC
9784: ST_TO_ADDR
9785: LD_VAR 0 1
9789: PUSH
9790: FOR_TO
9791: IFFALSE 9907
// begin if IsInUnit ( sol [ i ] ) then
9793: LD_VAR 0 1
9797: PUSH
9798: LD_VAR 0 11
9802: ARRAY
9803: PPUSH
9804: CALL_OW 310
9808: IFFALSE 9825
// ComExitBuilding ( sol [ i ] ) ;
9810: LD_VAR 0 1
9814: PUSH
9815: LD_VAR 0 11
9819: ARRAY
9820: PPUSH
9821: CALL_OW 122
// if mech <= 5 and AnyBuildingExist ( side , b_factory ) then
9825: LD_VAR 0 3
9829: PUSH
9830: LD_INT 5
9832: LESSEQUAL
9833: PUSH
9834: LD_VAR 0 20
9838: PPUSH
9839: LD_INT 3
9841: PPUSH
9842: CALL 1909 0 2
9846: AND
9847: IFFALSE 9887
// begin sol := SortFilter ( sol , skill_mechanical ) ;
9849: LD_ADDR_VAR 0 1
9853: PUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: CALL 4683 0 2
9866: ST_TO_ADDR
// scs_change_class ( sol [ sol ] , class_mechanic ) ;
9867: LD_VAR 0 1
9871: PUSH
9872: LD_VAR 0 1
9876: ARRAY
9877: PPUSH
9878: LD_INT 3
9880: PPUSH
9881: CALL 4757 0 2
// end else
9885: GO 9905
// scs_change_class ( sol [ sol ] , class_engineer ) ;
9887: LD_VAR 0 1
9891: PUSH
9892: LD_VAR 0 1
9896: ARRAY
9897: PPUSH
9898: LD_INT 2
9900: PPUSH
9901: CALL 4757 0 2
// end ;
9905: GO 9790
9907: POP
9908: POP
// end ; end ; if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
9909: LD_VAR 0 20
9913: PPUSH
9914: LD_INT 0
9916: PPUSH
9917: CALL 1909 0 2
9921: PUSH
9922: LD_VAR 0 20
9926: PPUSH
9927: LD_INT 1
9929: PPUSH
9930: CALL 1909 0 2
9934: OR
9935: IFFALSE 10226
// begin if AnyBuildingExist ( side , b_factory ) = false then
9937: LD_VAR 0 20
9941: PPUSH
9942: LD_INT 3
9944: PPUSH
9945: CALL 1909 0 2
9949: PUSH
9950: LD_INT 0
9952: EQUAL
9953: IFFALSE 9997
// begin for i = 1 to mech do
9955: LD_ADDR_VAR 0 11
9959: PUSH
9960: DOUBLE
9961: LD_INT 1
9963: DEC
9964: ST_TO_ADDR
9965: LD_VAR 0 3
9969: PUSH
9970: FOR_TO
9971: IFFALSE 9993
// scs_change_class ( mech [ i ] , 2 ) ;
9973: LD_VAR 0 3
9977: PUSH
9978: LD_VAR 0 11
9982: ARRAY
9983: PPUSH
9984: LD_INT 2
9986: PPUSH
9987: CALL 4757 0 2
9991: GO 9970
9993: POP
9994: POP
// end else
9995: GO 10090
// if mech > 0 then
9997: LD_VAR 0 3
10001: PUSH
10002: LD_INT 0
10004: GREATER
10005: IFFALSE 10090
// for i = 1 to mech do
10007: LD_ADDR_VAR 0 11
10011: PUSH
10012: DOUBLE
10013: LD_INT 1
10015: DEC
10016: ST_TO_ADDR
10017: LD_VAR 0 3
10021: PUSH
10022: FOR_TO
10023: IFFALSE 10088
// if not IsInUnit ( mech [ i ] ) and not HasTask ( mech [ i ] ) then
10025: LD_VAR 0 3
10029: PUSH
10030: LD_VAR 0 11
10034: ARRAY
10035: PPUSH
10036: CALL_OW 310
10040: NOT
10041: PUSH
10042: LD_VAR 0 3
10046: PUSH
10047: LD_VAR 0 11
10051: ARRAY
10052: PPUSH
10053: CALL_OW 314
10057: NOT
10058: AND
10059: IFFALSE 10086
// ComEnterUnit ( mech [ i ] , scs_find_factory ( side ) ) ;
10061: LD_VAR 0 3
10065: PUSH
10066: LD_VAR 0 11
10070: ARRAY
10071: PPUSH
10072: LD_VAR 0 20
10076: PPUSH
10077: CALL 5364 0 1
10081: PPUSH
10082: CALL_OW 120
10086: GO 10022
10088: POP
10089: POP
// if scs_scan_buildings ( side , b_factory ) > 0 then
10090: LD_VAR 0 20
10094: PPUSH
10095: LD_INT 3
10097: PPUSH
10098: CALL 3725 0 2
10102: PUSH
10103: LD_INT 0
10105: GREATER
10106: IFFALSE 10226
// begin fac := scs_scan_buildings ( side , b_factory ) [ 1 ] ;
10108: LD_ADDR_VAR 0 39
10112: PUSH
10113: LD_VAR 0 20
10117: PPUSH
10118: LD_INT 3
10120: PPUSH
10121: CALL 3725 0 2
10125: PUSH
10126: LD_INT 1
10128: ARRAY
10129: ST_TO_ADDR
// if BuildingStatus ( fac ) = bs_working and mech < 6 then
10130: LD_VAR 0 39
10134: PPUSH
10135: CALL_OW 461
10139: PUSH
10140: LD_INT 3
10142: EQUAL
10143: PUSH
10144: LD_VAR 0 3
10148: PUSH
10149: LD_INT 6
10151: LESS
10152: AND
10153: IFFALSE 10226
// begin filter := eng ^ sci ;
10155: LD_ADDR_VAR 0 40
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_VAR 0 4
10169: ADD
10170: ST_TO_ADDR
// filter := SortFilter ( filter , 3 ) ;
10171: LD_ADDR_VAR 0 40
10175: PUSH
10176: LD_VAR 0 40
10180: PPUSH
10181: LD_INT 3
10183: PPUSH
10184: CALL 4683 0 2
10188: ST_TO_ADDR
// while ( mech < 6 ) do
10189: LD_VAR 0 3
10193: PUSH
10194: LD_INT 6
10196: LESS
10197: IFFALSE 10226
// begin scs_change_class ( filter [ filter ] , 3 ) ;
10199: LD_VAR 0 40
10203: PUSH
10204: LD_VAR 0 40
10208: ARRAY
10209: PPUSH
10210: LD_INT 3
10212: PPUSH
10213: CALL 4757 0 2
// wait ( 0 0$0.1 ) ;
10217: LD_INT 4
10219: PPUSH
10220: CALL_OW 67
// end ;
10224: GO 10189
// end ; end ; end ; if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
10226: LD_VAR 0 20
10230: PPUSH
10231: LD_INT 0
10233: PPUSH
10234: CALL 1909 0 2
10238: PUSH
10239: LD_VAR 0 20
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL 1909 0 2
10251: OR
10252: IFFALSE 10580
// begin if scs_scan_lab ( side ) = 0 then
10254: LD_VAR 0 20
10258: PPUSH
10259: CALL 3652 0 1
10263: PUSH
10264: LD_INT 0
10266: EQUAL
10267: IFFALSE 10329
// begin for i = 1 to sci do
10269: LD_ADDR_VAR 0 11
10273: PUSH
10274: DOUBLE
10275: LD_INT 1
10277: DEC
10278: ST_TO_ADDR
10279: LD_VAR 0 4
10283: PUSH
10284: FOR_TO
10285: IFFALSE 10325
// if not HasTask ( sci [ i ] ) then
10287: LD_VAR 0 4
10291: PUSH
10292: LD_VAR 0 11
10296: ARRAY
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10323
// scs_change_class ( sci [ i ] , 2 ) ;
10305: LD_VAR 0 4
10309: PUSH
10310: LD_VAR 0 11
10314: ARRAY
10315: PPUSH
10316: LD_INT 2
10318: PPUSH
10319: CALL 4757 0 2
10323: GO 10284
10325: POP
10326: POP
// end else
10327: GO 10481
// if sci < 6 then
10329: LD_VAR 0 4
10333: PUSH
10334: LD_INT 6
10336: LESS
10337: IFFALSE 10481
// begin eng := SortFilter ( eng , 4 ) ;
10339: LD_ADDR_VAR 0 2
10343: PUSH
10344: LD_VAR 0 2
10348: PPUSH
10349: LD_INT 4
10351: PPUSH
10352: CALL 4683 0 2
10356: ST_TO_ADDR
// if eng > 7 then
10357: LD_VAR 0 2
10361: PUSH
10362: LD_INT 7
10364: GREATER
10365: IFFALSE 10407
// begin for i = 1 to 6 do
10367: LD_ADDR_VAR 0 11
10371: PUSH
10372: DOUBLE
10373: LD_INT 1
10375: DEC
10376: ST_TO_ADDR
10377: LD_INT 6
10379: PUSH
10380: FOR_TO
10381: IFFALSE 10403
// scs_change_class ( eng [ i ] , 4 ) ;
10383: LD_VAR 0 2
10387: PUSH
10388: LD_VAR 0 11
10392: ARRAY
10393: PPUSH
10394: LD_INT 4
10396: PPUSH
10397: CALL 4757 0 2
10401: GO 10380
10403: POP
10404: POP
// end else
10405: GO 10481
// if eng > 2 and eng <= 7 and sci < 6 then
10407: LD_VAR 0 2
10411: PUSH
10412: LD_INT 2
10414: GREATER
10415: PUSH
10416: LD_VAR 0 2
10420: PUSH
10421: LD_INT 7
10423: LESSEQUAL
10424: AND
10425: PUSH
10426: LD_VAR 0 4
10430: PUSH
10431: LD_INT 6
10433: LESS
10434: AND
10435: IFFALSE 10481
// for i = 1 to ( eng - 2 ) do
10437: LD_ADDR_VAR 0 11
10441: PUSH
10442: DOUBLE
10443: LD_INT 1
10445: DEC
10446: ST_TO_ADDR
10447: LD_VAR 0 2
10451: PUSH
10452: LD_INT 2
10454: MINUS
10455: PUSH
10456: FOR_TO
10457: IFFALSE 10479
// scs_change_class ( eng [ i ] , 4 ) ;
10459: LD_VAR 0 2
10463: PUSH
10464: LD_VAR 0 11
10468: ARRAY
10469: PPUSH
10470: LD_INT 4
10472: PPUSH
10473: CALL 4757 0 2
10477: GO 10456
10479: POP
10480: POP
// end ; for i = 1 to sci do
10481: LD_ADDR_VAR 0 11
10485: PUSH
10486: DOUBLE
10487: LD_INT 1
10489: DEC
10490: ST_TO_ADDR
10491: LD_VAR 0 4
10495: PUSH
10496: FOR_TO
10497: IFFALSE 10578
// if not IsInUnit ( sci [ i ] ) and ( not HasTask ( sci [ i ] ) ) then
10499: LD_VAR 0 4
10503: PUSH
10504: LD_VAR 0 11
10508: ARRAY
10509: PPUSH
10510: CALL_OW 310
10514: NOT
10515: PUSH
10516: LD_VAR 0 4
10520: PUSH
10521: LD_VAR 0 11
10525: ARRAY
10526: PPUSH
10527: CALL_OW 314
10531: NOT
10532: AND
10533: IFFALSE 10576
// ComEnterUnit ( sci [ i ] , NearestUnitToUnit ( scs_scan_lab ( side ) , sci [ i ] ) ) ;
10535: LD_VAR 0 4
10539: PUSH
10540: LD_VAR 0 11
10544: ARRAY
10545: PPUSH
10546: LD_VAR 0 20
10550: PPUSH
10551: CALL 3652 0 1
10555: PPUSH
10556: LD_VAR 0 4
10560: PUSH
10561: LD_VAR 0 11
10565: ARRAY
10566: PPUSH
10567: CALL_OW 74
10571: PPUSH
10572: CALL_OW 120
10576: GO 10496
10578: POP
10579: POP
// end ; if scs_scan_lab ( side ) > 0 then
10580: LD_VAR 0 20
10584: PPUSH
10585: CALL 3652 0 1
10589: PUSH
10590: LD_INT 0
10592: GREATER
10593: IFFALSE 10977
// begin for i = 1 to scs_scan_lab ( side ) do
10595: LD_ADDR_VAR 0 11
10599: PUSH
10600: DOUBLE
10601: LD_INT 1
10603: DEC
10604: ST_TO_ADDR
10605: LD_VAR 0 20
10609: PPUSH
10610: CALL 3652 0 1
10614: PUSH
10615: FOR_TO
10616: IFFALSE 10975
// begin if b_lab_basic in [ GetLabKind ( scs_scan_lab ( side ) [ i ] , 1 ) , GetLabKind ( scs_scan_lab ( side ) [ i ] , 2 ) ] then
10618: LD_INT 9
10620: PUSH
10621: LD_VAR 0 20
10625: PPUSH
10626: CALL 3652 0 1
10630: PUSH
10631: LD_VAR 0 11
10635: ARRAY
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: CALL_OW 268
10644: PUSH
10645: LD_VAR 0 20
10649: PPUSH
10650: CALL 3652 0 1
10654: PUSH
10655: LD_VAR 0 11
10659: ARRAY
10660: PPUSH
10661: LD_INT 2
10663: PPUSH
10664: CALL_OW 268
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: IN
10673: IFFALSE 10724
// if b1_tech = [ ] and GetTech ( tech_lab [ 1 ] , side ) <> state_researched then
10675: LD_EXP 72
10679: PUSH
10680: EMPTY
10681: EQUAL
10682: PUSH
10683: LD_EXP 83
10687: PUSH
10688: LD_INT 1
10690: ARRAY
10691: PPUSH
10692: LD_VAR 0 20
10696: PPUSH
10697: CALL_OW 321
10701: PUSH
10702: LD_INT 2
10704: NONEQUAL
10705: AND
10706: IFFALSE 10724
// b1_tech = b1_tech ^ tech_lab ;
10708: LD_ADDR_EXP 72
10712: PUSH
10713: LD_EXP 72
10717: PUSH
10718: LD_EXP 83
10722: ADD
10723: ST_TO_ADDR
// if b_lab_weapon in [ GetLabKind ( scs_scan_lab ( side ) [ i ] , 1 ) , GetLabKind ( scs_scan_lab ( side ) [ i ] , 2 ) ] then
10724: LD_INT 10
10726: PUSH
10727: LD_VAR 0 20
10731: PPUSH
10732: CALL 3652 0 1
10736: PUSH
10737: LD_VAR 0 11
10741: ARRAY
10742: PPUSH
10743: LD_INT 1
10745: PPUSH
10746: CALL_OW 268
10750: PUSH
10751: LD_VAR 0 20
10755: PPUSH
10756: CALL 3652 0 1
10760: PUSH
10761: LD_VAR 0 11
10765: ARRAY
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: CALL_OW 268
10774: PUSH
10775: EMPTY
10776: LIST
10777: LIST
10778: IN
10779: IFFALSE 10830
// if b1_tech = [ ] and GetTech ( tech_weap [ 1 ] , side ) <> state_researched then
10781: LD_EXP 72
10785: PUSH
10786: EMPTY
10787: EQUAL
10788: PUSH
10789: LD_EXP 77
10793: PUSH
10794: LD_INT 1
10796: ARRAY
10797: PPUSH
10798: LD_VAR 0 20
10802: PPUSH
10803: CALL_OW 321
10807: PUSH
10808: LD_INT 2
10810: NONEQUAL
10811: AND
10812: IFFALSE 10830
// b1_tech = b1_tech ^ tech_weap ;
10814: LD_ADDR_EXP 72
10818: PUSH
10819: LD_EXP 72
10823: PUSH
10824: LD_EXP 77
10828: ADD
10829: ST_TO_ADDR
// display_strings := b1_tech ;
10830: LD_ADDR_OWVAR 47
10834: PUSH
10835: LD_EXP 72
10839: ST_TO_ADDR
// if BuildingStatus ( scs_scan_lab ( side ) [ i ] ) = bs_idle and b1_tech > 0 then
10840: LD_VAR 0 20
10844: PPUSH
10845: CALL 3652 0 1
10849: PUSH
10850: LD_VAR 0 11
10854: ARRAY
10855: PPUSH
10856: CALL_OW 461
10860: PUSH
10861: LD_INT 2
10863: EQUAL
10864: PUSH
10865: LD_EXP 72
10869: PUSH
10870: LD_INT 0
10872: GREATER
10873: AND
10874: IFFALSE 10973
// begin if GetTech ( b1_tech [ 1 ] , side ) = state_enabled then
10876: LD_EXP 72
10880: PUSH
10881: LD_INT 1
10883: ARRAY
10884: PPUSH
10885: LD_VAR 0 20
10889: PPUSH
10890: CALL_OW 321
10894: PUSH
10895: LD_INT 1
10897: EQUAL
10898: IFFALSE 10931
// ComResearch ( scs_scan_lab ( side ) [ i ] , b1_tech [ 1 ] ) else
10900: LD_VAR 0 20
10904: PPUSH
10905: CALL 3652 0 1
10909: PUSH
10910: LD_VAR 0 11
10914: ARRAY
10915: PPUSH
10916: LD_EXP 72
10920: PUSH
10921: LD_INT 1
10923: ARRAY
10924: PPUSH
10925: CALL_OW 124
10929: GO 10973
// if GetTech ( b1_tech [ 1 ] , side ) = state_researched then
10931: LD_EXP 72
10935: PUSH
10936: LD_INT 1
10938: ARRAY
10939: PPUSH
10940: LD_VAR 0 20
10944: PPUSH
10945: CALL_OW 321
10949: PUSH
10950: LD_INT 2
10952: EQUAL
10953: IFFALSE 10973
// b1_tech := Delete ( b1_tech , 1 ) ;
10955: LD_ADDR_EXP 72
10959: PUSH
10960: LD_EXP 72
10964: PPUSH
10965: LD_INT 1
10967: PPUSH
10968: CALL_OW 3
10972: ST_TO_ADDR
// end ; end ;
10973: GO 10615
10975: POP
10976: POP
// end ; if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 45 ) = false and ( AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) ) then
10977: LD_VAR 0 20
10981: PPUSH
10982: LD_VAR 0 27
10986: PUSH
10987: LD_INT 1
10989: ARRAY
10990: PPUSH
10991: LD_VAR 0 27
10995: PUSH
10996: LD_INT 2
10998: ARRAY
10999: PPUSH
11000: LD_INT 45
11002: PPUSH
11003: CALL 3565 0 4
11007: PUSH
11008: LD_INT 0
11010: EQUAL
11011: PUSH
11012: LD_VAR 0 20
11016: PPUSH
11017: LD_INT 0
11019: PPUSH
11020: CALL 1909 0 2
11024: PUSH
11025: LD_VAR 0 20
11029: PPUSH
11030: LD_INT 1
11032: PPUSH
11033: CALL 1909 0 2
11037: OR
11038: AND
11039: IFFALSE 11457
// begin skr = GetListOfCratesInArea ( CratesArea ) ;
11041: LD_ADDR_VAR 0 37
11045: PUSH
11046: LD_INT 17
11048: PPUSH
11049: CALL_OW 435
11053: ST_TO_ADDR
// c = 1 ;
11054: LD_ADDR_VAR 0 38
11058: PUSH
11059: LD_INT 1
11061: ST_TO_ADDR
// while c < skr do
11062: LD_VAR 0 38
11066: PUSH
11067: LD_VAR 0 37
11071: LESS
11072: IFFALSE 11457
// begin if FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 then
11074: LD_INT 22
11076: PUSH
11077: LD_VAR 0 20
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: PUSH
11086: LD_INT 2
11088: PUSH
11089: LD_INT 34
11091: PUSH
11092: LD_INT 12
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: PUSH
11099: LD_INT 34
11101: PUSH
11102: LD_INT 32
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: PUSH
11109: LD_INT 34
11111: PUSH
11112: LD_INT 51
11114: PUSH
11115: EMPTY
11116: LIST
11117: LIST
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: LIST
11123: LIST
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PPUSH
11129: CALL_OW 69
11133: PUSH
11134: LD_INT 0
11136: EQUAL
11137: IFFALSE 11287
// begin for p = 1 to ( eng / 3 ) do
11139: LD_ADDR_VAR 0 12
11143: PUSH
11144: DOUBLE
11145: LD_INT 1
11147: DEC
11148: ST_TO_ADDR
11149: LD_VAR 0 2
11153: PUSH
11154: LD_INT 3
11156: DIVREAL
11157: PUSH
11158: FOR_TO
11159: IFFALSE 11269
// if not HasTask ( eng [ p ] ) and GetDistUnitXY ( eng [ p ] , skr [ c ] , skr [ c + 1 ] ) <= 25 then
11161: LD_VAR 0 2
11165: PUSH
11166: LD_VAR 0 12
11170: ARRAY
11171: PPUSH
11172: CALL_OW 314
11176: NOT
11177: PUSH
11178: LD_VAR 0 2
11182: PUSH
11183: LD_VAR 0 12
11187: ARRAY
11188: PPUSH
11189: LD_VAR 0 37
11193: PUSH
11194: LD_VAR 0 38
11198: ARRAY
11199: PPUSH
11200: LD_VAR 0 37
11204: PUSH
11205: LD_VAR 0 38
11209: PUSH
11210: LD_INT 1
11212: PLUS
11213: ARRAY
11214: PPUSH
11215: CALL_OW 297
11219: PUSH
11220: LD_INT 25
11222: LESSEQUAL
11223: AND
11224: IFFALSE 11267
// ComCollect ( eng [ p ] , skr [ c ] , skr [ c + 1 ] ) ;
11226: LD_VAR 0 2
11230: PUSH
11231: LD_VAR 0 12
11235: ARRAY
11236: PPUSH
11237: LD_VAR 0 37
11241: PUSH
11242: LD_VAR 0 38
11246: ARRAY
11247: PPUSH
11248: LD_VAR 0 37
11252: PUSH
11253: LD_VAR 0 38
11257: PUSH
11258: LD_INT 1
11260: PLUS
11261: ARRAY
11262: PPUSH
11263: CALL_OW 117
11267: GO 11158
11269: POP
11270: POP
// c = c + 2 ;
11271: LD_ADDR_VAR 0 38
11275: PUSH
11276: LD_VAR 0 38
11280: PUSH
11281: LD_INT 2
11283: PLUS
11284: ST_TO_ADDR
// end else
11285: GO 11455
// begin if GetLives ( veh [ 1 ] ) > 300 and GetDistUnitXY ( veh [ 1 ] , skr [ c ] , skr [ c + 1 ] ) <= 45 then
11287: LD_VAR 0 15
11291: PUSH
11292: LD_INT 1
11294: ARRAY
11295: PPUSH
11296: CALL_OW 256
11300: PUSH
11301: LD_INT 300
11303: GREATER
11304: PUSH
11305: LD_VAR 0 15
11309: PUSH
11310: LD_INT 1
11312: ARRAY
11313: PPUSH
11314: LD_VAR 0 37
11318: PUSH
11319: LD_VAR 0 38
11323: ARRAY
11324: PPUSH
11325: LD_VAR 0 37
11329: PUSH
11330: LD_VAR 0 38
11334: PUSH
11335: LD_INT 1
11337: PLUS
11338: ARRAY
11339: PPUSH
11340: CALL_OW 297
11344: PUSH
11345: LD_INT 45
11347: LESSEQUAL
11348: AND
11349: IFFALSE 11455
// begin veh := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) ;
11351: LD_ADDR_VAR 0 15
11355: PUSH
11356: LD_INT 22
11358: PUSH
11359: LD_VAR 0 20
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 2
11370: PUSH
11371: LD_INT 34
11373: PUSH
11374: LD_INT 12
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PUSH
11381: LD_INT 34
11383: PUSH
11384: LD_INT 32
11386: PUSH
11387: EMPTY
11388: LIST
11389: LIST
11390: PUSH
11391: LD_INT 34
11393: PUSH
11394: LD_INT 51
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: PUSH
11401: EMPTY
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PPUSH
11411: CALL_OW 69
11415: ST_TO_ADDR
// ComCollect ( veh [ 1 ] , skr [ c ] , skr [ c + 1 ] ) ;
11416: LD_VAR 0 15
11420: PUSH
11421: LD_INT 1
11423: ARRAY
11424: PPUSH
11425: LD_VAR 0 37
11429: PUSH
11430: LD_VAR 0 38
11434: ARRAY
11435: PPUSH
11436: LD_VAR 0 37
11440: PUSH
11441: LD_VAR 0 38
11445: PUSH
11446: LD_INT 1
11448: PLUS
11449: ARRAY
11450: PPUSH
11451: CALL_OW 117
// end ; end ; end ;
11455: GO 11062
// end ; end ; end_of_file end_of_file
11457: PPOPN 50
11459: END
// export test ; export function var_test ( ) ; var a ; begin
11460: LD_INT 0
11462: PPUSH
11463: PPUSH
// scs_create_squad ( 1 , 2 , 3 , 0 , MZBaseArea ) ;
11464: LD_INT 1
11466: PPUSH
11467: LD_INT 2
11469: PPUSH
11470: LD_INT 3
11472: PPUSH
11473: LD_INT 0
11475: PPUSH
11476: LD_INT 1
11478: PPUSH
11479: CALL 3033 0 5
// b1_side := 2 ;
11483: LD_ADDR_EXP 6
11487: PUSH
11488: LD_INT 2
11490: ST_TO_ADDR
// b1_nation := 1 ;
11491: LD_ADDR_EXP 7
11495: PUSH
11496: LD_INT 1
11498: ST_TO_ADDR
// b1_people := 16 ;
11499: LD_ADDR_EXP 9
11503: PUSH
11504: LD_INT 16
11506: ST_TO_ADDR
// b1_skill := 5 ;
11507: LD_ADDR_EXP 10
11511: PUSH
11512: LD_INT 5
11514: ST_TO_ADDR
// b1_area := SouthSpawn ;
11515: LD_ADDR_EXP 8
11519: PUSH
11520: LD_INT 16
11522: ST_TO_ADDR
// b1_cr_dep := [ 130 , 120 , 2 ] ;
11523: LD_ADDR_EXP 11
11527: PUSH
11528: LD_INT 130
11530: PUSH
11531: LD_INT 120
11533: PUSH
11534: LD_INT 2
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: ST_TO_ADDR
// b1_cr_br := [ 123 , 106 , 3 , 134 , 111 , 3 , 114 , 110 , 2 ] ;
11542: LD_ADDR_EXP 17
11546: PUSH
11547: LD_INT 123
11549: PUSH
11550: LD_INT 106
11552: PUSH
11553: LD_INT 3
11555: PUSH
11556: LD_INT 134
11558: PUSH
11559: LD_INT 111
11561: PUSH
11562: LD_INT 3
11564: PUSH
11565: LD_INT 114
11567: PUSH
11568: LD_INT 110
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: LIST
11578: LIST
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: ST_TO_ADDR
// b1_cr_lab := [ 122 , 122 , 1 , b_lab_weapon , b_lab_opto , 145 , 130 , 4 , b_lab_opto , b_lab_computer , 118 , 128 , 4 , b_lab_opto , b_lab_computer ] ;
11585: LD_ADDR_EXP 12
11589: PUSH
11590: LD_INT 122
11592: PUSH
11593: LD_INT 122
11595: PUSH
11596: LD_INT 1
11598: PUSH
11599: LD_INT 10
11601: PUSH
11602: LD_INT 15
11604: PUSH
11605: LD_INT 145
11607: PUSH
11608: LD_INT 130
11610: PUSH
11611: LD_INT 4
11613: PUSH
11614: LD_INT 15
11616: PUSH
11617: LD_INT 12
11619: PUSH
11620: LD_INT 118
11622: PUSH
11623: LD_INT 128
11625: PUSH
11626: LD_INT 4
11628: PUSH
11629: LD_INT 15
11631: PUSH
11632: LD_INT 12
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: ST_TO_ADDR
// b1_cr_pow := [ 123 , 132 , 0 , b_oil_power , 131 , 135 , 5 , b_oil_power ] ;
11652: LD_ADDR_EXP 15
11656: PUSH
11657: LD_INT 123
11659: PUSH
11660: LD_INT 132
11662: PUSH
11663: LD_INT 0
11665: PUSH
11666: LD_INT 26
11668: PUSH
11669: LD_INT 131
11671: PUSH
11672: LD_INT 135
11674: PUSH
11675: LD_INT 5
11677: PUSH
11678: LD_INT 26
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: ST_TO_ADDR
// if super_source = false then
11691: LD_EXP 71
11695: PUSH
11696: LD_INT 0
11698: EQUAL
11699: IFFALSE 11758
// b1_cr_add := [ 138 , 137 , b_oil_mine , 0 , 0 , 0 , 142 , 137 , b_siberite_mine , 0 , 0 , 0 ] else
11701: LD_ADDR_EXP 18
11705: PUSH
11706: LD_INT 138
11708: PUSH
11709: LD_INT 137
11711: PUSH
11712: LD_INT 29
11714: PUSH
11715: LD_INT 0
11717: PUSH
11718: LD_INT 0
11720: PUSH
11721: LD_INT 0
11723: PUSH
11724: LD_INT 142
11726: PUSH
11727: LD_INT 137
11729: PUSH
11730: LD_INT 30
11732: PUSH
11733: LD_INT 0
11735: PUSH
11736: LD_INT 0
11738: PUSH
11739: LD_INT 0
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: ST_TO_ADDR
11756: GO 11813
// b1_cr_add := [ 152 , 136 , b_oil_mine , 130 , 136 , b_oil_mine , 153 , 132 , b_siberite_mine , 124 , 133 , b_siberite_mine ] ;
11758: LD_ADDR_EXP 18
11762: PUSH
11763: LD_INT 152
11765: PUSH
11766: LD_INT 136
11768: PUSH
11769: LD_INT 29
11771: PUSH
11772: LD_INT 130
11774: PUSH
11775: LD_INT 136
11777: PUSH
11778: LD_INT 29
11780: PUSH
11781: LD_INT 153
11783: PUSH
11784: LD_INT 132
11786: PUSH
11787: LD_INT 30
11789: PUSH
11790: LD_INT 124
11792: PUSH
11793: LD_INT 133
11795: PUSH
11796: LD_INT 30
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: ST_TO_ADDR
// b1_cr_fab := [ 135 , 130 , 0 ] ;
11813: LD_ADDR_EXP 13
11817: PUSH
11818: LD_INT 135
11820: PUSH
11821: LD_INT 130
11823: PUSH
11824: LD_INT 0
11826: PUSH
11827: EMPTY
11828: LIST
11829: LIST
11830: LIST
11831: ST_TO_ADDR
// b1_cr_ext := [ 135 , 134 , 0 , b_ext_noncombat , 131 , 126 , 2 , b_ext_track ] ;
11832: LD_ADDR_EXP 14
11836: PUSH
11837: LD_INT 135
11839: PUSH
11840: LD_INT 134
11842: PUSH
11843: LD_INT 0
11845: PUSH
11846: LD_INT 19
11848: PUSH
11849: LD_INT 131
11851: PUSH
11852: LD_INT 126
11854: PUSH
11855: LD_INT 2
11857: PUSH
11858: LD_INT 16
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: ST_TO_ADDR
// SetTech ( tech_oilpow , b1_side , state_researched ) ;
11871: LD_INT 46
11873: PPUSH
11874: LD_EXP 6
11878: PPUSH
11879: LD_INT 2
11881: PPUSH
11882: CALL_OW 322
// scs_create_bots ( ) ;
11886: CALL 338 0 0
// Wait ( 0 0$03 ) ;
11890: LD_INT 105
11892: PPUSH
11893: CALL_OW 67
// CreateCratesArea ( 5 , buildup5 , true ) ;
11897: LD_INT 5
11899: PPUSH
11900: LD_INT 12
11902: PPUSH
11903: LD_INT 1
11905: PPUSH
11906: CALL_OW 55
// CreateCratesArea ( 5 , buildup5 , true ) ;
11910: LD_INT 5
11912: PPUSH
11913: LD_INT 12
11915: PPUSH
11916: LD_INT 1
11918: PPUSH
11919: CALL_OW 55
// end ;
11923: LD_VAR 0 1
11927: RET
// every 1 1$25 trigger test do
11928: LD_EXP 84
11932: IFFALSE 11964
11934: GO 11936
11936: DISABLE
// begin enable ;
11937: ENABLE
// CreateCratesArea ( 5 , buildup5 , true ) ;
11938: LD_INT 5
11940: PPUSH
11941: LD_INT 12
11943: PPUSH
11944: LD_INT 1
11946: PPUSH
11947: CALL_OW 55
// CreateCratesArea ( 5 , buildup5 , true ) ;
11951: LD_INT 5
11953: PPUSH
11954: LD_INT 12
11956: PPUSH
11957: LD_INT 1
11959: PPUSH
11960: CALL_OW 55
// end ;
11964: END
