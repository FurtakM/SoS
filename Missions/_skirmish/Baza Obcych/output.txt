// starting begin end ;
   0: END
// export function main_settings ; begin
   1: LD_INT 0
   3: PPUSH
// test := true ;
   4: LD_ADDR_EXP 84
   8: PUSH
   9: LD_INT 1
  11: ST_TO_ADDR
// AddDeposits ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL 1124 0 1
// end ; end_of_file
  19: LD_VAR 0 1
  23: RET
// export b1_act , b2_act , b3_act , b4_act , b5_act ; export b1_side , b1_nation , b1_area , b1_people , b1_skill , b1_cr_dep , b1_cr_lab , b1_cr_fab , b1_cr_ext , b1_cr_pow , b1_cr_tw , b1_cr_br , b1_cr_add ; export b2_side , b2_nation , b2_area , b2_people , b2_skill , b2_cr_dep , b2_cr_lab , b2_cr_fab , b2_cr_ext , b2_cr_pow , b2_cr_tw , b2_cr_br , b2_cr_add ; export b3_side , b3_nation , b3_area , b3_people , b3_skill , b3_cr_dep , b3_cr_lab , b3_cr_fab , b3_cr_ext , b3_cr_pow , b3_cr_tw , b3_cr_br , b3_cr_add ; export b4_side , b4_nation , b4_area , b4_people , b4_skill , b4_cr_dep , b4_cr_lab , b4_cr_fab , b4_cr_ext , b4_cr_pow , b4_cr_tw , b4_cr_br , b4_cr_add ; export b5_side , b5_nation , b5_area , b5_people , b5_skill , b5_cr_dep , b5_cr_lab , b5_cr_fab , b5_cr_ext , b5_cr_pow , b5_cr_tw , b5_cr_br , b5_cr_add ; export super_source ; export b1_tech , b2_tech , b3_tech , b4_tech , b5_tech ; export function scs_init ( num , side , nation , area , people , skill , cr_dep , cr_lab , cr_fab , cr_ext , cr_pow , cr_tw , cr_br , cr_add ) ; begin
  24: LD_INT 0
  26: PPUSH
// case num of 1 :
  27: LD_VAR 0 1
  31: PUSH
  32: LD_INT 1
  34: DOUBLE
  35: EQUAL
  36: IFTRUE 40
  38: GO 173
  40: POP
// begin b1_side := side ;
  41: LD_ADDR_EXP 6
  45: PUSH
  46: LD_VAR 0 2
  50: ST_TO_ADDR
// b1_nation := nation ;
  51: LD_ADDR_EXP 7
  55: PUSH
  56: LD_VAR 0 3
  60: ST_TO_ADDR
// b1_area := area ;
  61: LD_ADDR_EXP 8
  65: PUSH
  66: LD_VAR 0 4
  70: ST_TO_ADDR
// b1_people := people ;
  71: LD_ADDR_EXP 9
  75: PUSH
  76: LD_VAR 0 5
  80: ST_TO_ADDR
// b1_skill := skill ;
  81: LD_ADDR_EXP 10
  85: PUSH
  86: LD_VAR 0 6
  90: ST_TO_ADDR
// b1_cr_dep := cr_dep ;
  91: LD_ADDR_EXP 11
  95: PUSH
  96: LD_VAR 0 7
 100: ST_TO_ADDR
// b1_cr_lab := cr_lab ;
 101: LD_ADDR_EXP 12
 105: PUSH
 106: LD_VAR 0 8
 110: ST_TO_ADDR
// b1_cr_fab := cr_fab ;
 111: LD_ADDR_EXP 13
 115: PUSH
 116: LD_VAR 0 9
 120: ST_TO_ADDR
// b1_cr_ext := cr_ext ;
 121: LD_ADDR_EXP 14
 125: PUSH
 126: LD_VAR 0 10
 130: ST_TO_ADDR
// b1_cr_pow := cr_pow ;
 131: LD_ADDR_EXP 15
 135: PUSH
 136: LD_VAR 0 11
 140: ST_TO_ADDR
// b1_cr_tw := cr_tw ;
 141: LD_ADDR_EXP 16
 145: PUSH
 146: LD_VAR 0 12
 150: ST_TO_ADDR
// b1_cr_br := cr_br ;
 151: LD_ADDR_EXP 17
 155: PUSH
 156: LD_VAR 0 13
 160: ST_TO_ADDR
// b1_cr_add := cr_add ;
 161: LD_ADDR_EXP 18
 165: PUSH
 166: LD_VAR 0 14
 170: ST_TO_ADDR
// end ; 2 :
 171: GO 315
 173: LD_INT 2
 175: DOUBLE
 176: EQUAL
 177: IFTRUE 181
 179: GO 314
 181: POP
// begin b2_side := side ;
 182: LD_ADDR_EXP 19
 186: PUSH
 187: LD_VAR 0 2
 191: ST_TO_ADDR
// b2_nation := nation ;
 192: LD_ADDR_EXP 20
 196: PUSH
 197: LD_VAR 0 3
 201: ST_TO_ADDR
// b2_area := area ;
 202: LD_ADDR_EXP 21
 206: PUSH
 207: LD_VAR 0 4
 211: ST_TO_ADDR
// b2_people := people ;
 212: LD_ADDR_EXP 22
 216: PUSH
 217: LD_VAR 0 5
 221: ST_TO_ADDR
// b2_skill := skill ;
 222: LD_ADDR_EXP 23
 226: PUSH
 227: LD_VAR 0 6
 231: ST_TO_ADDR
// b2_cr_dep := cr_dep ;
 232: LD_ADDR_EXP 24
 236: PUSH
 237: LD_VAR 0 7
 241: ST_TO_ADDR
// b2_cr_lab := cr_lab ;
 242: LD_ADDR_EXP 25
 246: PUSH
 247: LD_VAR 0 8
 251: ST_TO_ADDR
// b2_cr_fab := cr_fab ;
 252: LD_ADDR_EXP 26
 256: PUSH
 257: LD_VAR 0 9
 261: ST_TO_ADDR
// b2_cr_ext := cr_ext ;
 262: LD_ADDR_EXP 27
 266: PUSH
 267: LD_VAR 0 10
 271: ST_TO_ADDR
// b2_cr_pow := cr_pow ;
 272: LD_ADDR_EXP 28
 276: PUSH
 277: LD_VAR 0 11
 281: ST_TO_ADDR
// b2_cr_tw := cr_tw ;
 282: LD_ADDR_EXP 29
 286: PUSH
 287: LD_VAR 0 12
 291: ST_TO_ADDR
// b2_cr_br := cr_br ;
 292: LD_ADDR_EXP 30
 296: PUSH
 297: LD_VAR 0 13
 301: ST_TO_ADDR
// b2_cr_add := cr_add ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_VAR 0 14
 311: ST_TO_ADDR
// end ; end ;
 312: GO 315
 314: POP
// end ;
 315: LD_VAR 0 15
 319: RET
// export function scs_create_bots ( ) ; var i , c , s , filter , side , tmp ; begin
 320: LD_INT 0
 322: PPUSH
 323: PPUSH
 324: PPUSH
 325: PPUSH
 326: PPUSH
 327: PPUSH
 328: PPUSH
// tmp := [ b1_side , b2_side , b3_side , b4_side , b5_side ] ;
 329: LD_ADDR_VAR 0 7
 333: PUSH
 334: LD_EXP 6
 338: PUSH
 339: LD_EXP 19
 343: PUSH
 344: LD_EXP 32
 348: PUSH
 349: LD_EXP 45
 353: PUSH
 354: LD_EXP 58
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: LIST
 363: LIST
 364: LIST
 365: ST_TO_ADDR
// side := [ ] ;
 366: LD_ADDR_VAR 0 6
 370: PUSH
 371: EMPTY
 372: ST_TO_ADDR
// s := [ ] ;
 373: LD_ADDR_VAR 0 4
 377: PUSH
 378: EMPTY
 379: ST_TO_ADDR
// for i = 1 to tmp do
 380: LD_ADDR_VAR 0 2
 384: PUSH
 385: DOUBLE
 386: LD_INT 1
 388: DEC
 389: ST_TO_ADDR
 390: LD_VAR 0 7
 394: PUSH
 395: FOR_TO
 396: IFFALSE 452
// if tmp [ i ] > 0 then
 398: LD_VAR 0 7
 402: PUSH
 403: LD_VAR 0 2
 407: ARRAY
 408: PUSH
 409: LD_INT 0
 411: GREATER
 412: IFFALSE 436
// side := side ^ 0 + i else
 414: LD_ADDR_VAR 0 6
 418: PUSH
 419: LD_VAR 0 6
 423: PUSH
 424: LD_INT 0
 426: PUSH
 427: LD_VAR 0 2
 431: PLUS
 432: ADD
 433: ST_TO_ADDR
 434: GO 450
// side := side ^ 0 ;
 436: LD_ADDR_VAR 0 6
 440: PUSH
 441: LD_VAR 0 6
 445: PUSH
 446: LD_INT 0
 448: ADD
 449: ST_TO_ADDR
 450: GO 395
 452: POP
 453: POP
// if side [ 1 ] > 0 then
 454: LD_VAR 0 6
 458: PUSH
 459: LD_INT 1
 461: ARRAY
 462: PUSH
 463: LD_INT 0
 465: GREATER
 466: IFFALSE 562
// begin b1_act := true ;
 468: LD_ADDR_EXP 1
 472: PUSH
 473: LD_INT 1
 475: ST_TO_ADDR
// s := [ b1_side , b1_nation , b1_people , b1_skill , b1_area ] ;
 476: LD_ADDR_VAR 0 4
 480: PUSH
 481: LD_EXP 6
 485: PUSH
 486: LD_EXP 7
 490: PUSH
 491: LD_EXP 9
 495: PUSH
 496: LD_EXP 10
 500: PUSH
 501: LD_EXP 8
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 513: LD_VAR 0 4
 517: PUSH
 518: LD_INT 1
 520: ARRAY
 521: PPUSH
 522: LD_VAR 0 4
 526: PUSH
 527: LD_INT 2
 529: ARRAY
 530: PPUSH
 531: LD_VAR 0 4
 535: PUSH
 536: LD_INT 3
 538: ARRAY
 539: PPUSH
 540: LD_VAR 0 4
 544: PUSH
 545: LD_INT 4
 547: ARRAY
 548: PPUSH
 549: LD_VAR 0 4
 553: PUSH
 554: LD_INT 5
 556: ARRAY
 557: PPUSH
 558: CALL 3015 0 5
// end ; if side [ 2 ] > 0 then
 562: LD_VAR 0 6
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PUSH
 571: LD_INT 0
 573: GREATER
 574: IFFALSE 670
// begin b2_act := true ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// s := [ b2_side , b2_nation , b2_people , b2_skill , b2_area ] ;
 584: LD_ADDR_VAR 0 4
 588: PUSH
 589: LD_EXP 19
 593: PUSH
 594: LD_EXP 20
 598: PUSH
 599: LD_EXP 22
 603: PUSH
 604: LD_EXP 23
 608: PUSH
 609: LD_EXP 21
 613: PUSH
 614: EMPTY
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 621: LD_VAR 0 4
 625: PUSH
 626: LD_INT 1
 628: ARRAY
 629: PPUSH
 630: LD_VAR 0 4
 634: PUSH
 635: LD_INT 2
 637: ARRAY
 638: PPUSH
 639: LD_VAR 0 4
 643: PUSH
 644: LD_INT 3
 646: ARRAY
 647: PPUSH
 648: LD_VAR 0 4
 652: PUSH
 653: LD_INT 4
 655: ARRAY
 656: PPUSH
 657: LD_VAR 0 4
 661: PUSH
 662: LD_INT 5
 664: ARRAY
 665: PPUSH
 666: CALL 3015 0 5
// end ; if side [ 3 ] > 0 then
 670: LD_VAR 0 6
 674: PUSH
 675: LD_INT 3
 677: ARRAY
 678: PUSH
 679: LD_INT 0
 681: GREATER
 682: IFFALSE 778
// begin b3_act := true ;
 684: LD_ADDR_EXP 3
 688: PUSH
 689: LD_INT 1
 691: ST_TO_ADDR
// s := [ b3_side , b3_nation , b3_people , b3_skill , b3_area ] ;
 692: LD_ADDR_VAR 0 4
 696: PUSH
 697: LD_EXP 32
 701: PUSH
 702: LD_EXP 33
 706: PUSH
 707: LD_EXP 35
 711: PUSH
 712: LD_EXP 36
 716: PUSH
 717: LD_EXP 34
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 729: LD_VAR 0 4
 733: PUSH
 734: LD_INT 1
 736: ARRAY
 737: PPUSH
 738: LD_VAR 0 4
 742: PUSH
 743: LD_INT 2
 745: ARRAY
 746: PPUSH
 747: LD_VAR 0 4
 751: PUSH
 752: LD_INT 3
 754: ARRAY
 755: PPUSH
 756: LD_VAR 0 4
 760: PUSH
 761: LD_INT 4
 763: ARRAY
 764: PPUSH
 765: LD_VAR 0 4
 769: PUSH
 770: LD_INT 5
 772: ARRAY
 773: PPUSH
 774: CALL 3015 0 5
// end ; if side [ 4 ] > 0 then
 778: LD_VAR 0 6
 782: PUSH
 783: LD_INT 4
 785: ARRAY
 786: PUSH
 787: LD_INT 0
 789: GREATER
 790: IFFALSE 886
// begin b4_act := true ;
 792: LD_ADDR_EXP 4
 796: PUSH
 797: LD_INT 1
 799: ST_TO_ADDR
// s := [ b4_side , b4_nation , b4_people , b4_skill , b4_area ] ;
 800: LD_ADDR_VAR 0 4
 804: PUSH
 805: LD_EXP 45
 809: PUSH
 810: LD_EXP 46
 814: PUSH
 815: LD_EXP 48
 819: PUSH
 820: LD_EXP 49
 824: PUSH
 825: LD_EXP 47
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: LIST
 836: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 837: LD_VAR 0 4
 841: PUSH
 842: LD_INT 1
 844: ARRAY
 845: PPUSH
 846: LD_VAR 0 4
 850: PUSH
 851: LD_INT 2
 853: ARRAY
 854: PPUSH
 855: LD_VAR 0 4
 859: PUSH
 860: LD_INT 3
 862: ARRAY
 863: PPUSH
 864: LD_VAR 0 4
 868: PUSH
 869: LD_INT 4
 871: ARRAY
 872: PPUSH
 873: LD_VAR 0 4
 877: PUSH
 878: LD_INT 5
 880: ARRAY
 881: PPUSH
 882: CALL 3015 0 5
// end ; if side [ 5 ] > 0 then
 886: LD_VAR 0 6
 890: PUSH
 891: LD_INT 5
 893: ARRAY
 894: PUSH
 895: LD_INT 0
 897: GREATER
 898: IFFALSE 994
// begin b5_act := true ;
 900: LD_ADDR_EXP 5
 904: PUSH
 905: LD_INT 1
 907: ST_TO_ADDR
// s := [ b5_side , b5_nation , b5_people , b5_skill , b5_area ] ;
 908: LD_ADDR_VAR 0 4
 912: PUSH
 913: LD_EXP 58
 917: PUSH
 918: LD_EXP 59
 922: PUSH
 923: LD_EXP 61
 927: PUSH
 928: LD_EXP 62
 932: PUSH
 933: LD_EXP 60
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// scs_create_squad ( s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) ;
 945: LD_VAR 0 4
 949: PUSH
 950: LD_INT 1
 952: ARRAY
 953: PPUSH
 954: LD_VAR 0 4
 958: PUSH
 959: LD_INT 2
 961: ARRAY
 962: PPUSH
 963: LD_VAR 0 4
 967: PUSH
 968: LD_INT 3
 970: ARRAY
 971: PPUSH
 972: LD_VAR 0 4
 976: PUSH
 977: LD_INT 4
 979: ARRAY
 980: PPUSH
 981: LD_VAR 0 4
 985: PUSH
 986: LD_INT 5
 988: ARRAY
 989: PPUSH
 990: CALL 3015 0 5
// end ; InitBotTech ( ) ;
 994: CALL 1003 0 0
// end ;
 998: LD_VAR 0 1
1002: RET
// export function InitBotTech ( ) ; begin
1003: LD_INT 0
1005: PPUSH
// b1_tech := [ ] ;
1006: LD_ADDR_EXP 72
1010: PUSH
1011: EMPTY
1012: ST_TO_ADDR
// b2_tech := [ ] ;
1013: LD_ADDR_EXP 73
1017: PUSH
1018: EMPTY
1019: ST_TO_ADDR
// b3_tech := [ ] ;
1020: LD_ADDR_EXP 74
1024: PUSH
1025: EMPTY
1026: ST_TO_ADDR
// b4_tech := [ ] ;
1027: LD_ADDR_EXP 75
1031: PUSH
1032: EMPTY
1033: ST_TO_ADDR
// b5_tech := [ ] ;
1034: LD_ADDR_EXP 76
1038: PUSH
1039: EMPTY
1040: ST_TO_ADDR
// end ; end_of_file
1041: LD_VAR 0 1
1045: RET
// export tech_weap , tech_opto , tech_sib , tech_time , tech_comp , tech_bio , tech_lab ; export function lab_variable ( ) ; begin
1046: LD_INT 0
1048: PPUSH
// tech_lab := [ 35 , 48 , 49 , 45 , 46 , 47 , 1 , 50 , 20 ] ;
1049: LD_ADDR_EXP 83
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 48
1059: PUSH
1060: LD_INT 49
1062: PUSH
1063: LD_INT 45
1065: PUSH
1066: LD_INT 46
1068: PUSH
1069: LD_INT 47
1071: PUSH
1072: LD_INT 1
1074: PUSH
1075: LD_INT 50
1077: PUSH
1078: LD_INT 20
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: ST_TO_ADDR
// tech_weap := [ 51 , 69 , 52 , 39 , 70 ] ;
1092: LD_ADDR_EXP 77
1096: PUSH
1097: LD_INT 51
1099: PUSH
1100: LD_INT 69
1102: PUSH
1103: LD_INT 52
1105: PUSH
1106: LD_INT 39
1108: PUSH
1109: LD_INT 70
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: ST_TO_ADDR
// end ;
1119: LD_VAR 0 1
1123: RET
// export function AddDeposits ( bool ) ; var i , j , normal_oil , extra_oil , normal_sib , extra_sib ; begin
1124: LD_INT 0
1126: PPUSH
1127: PPUSH
1128: PPUSH
1129: PPUSH
1130: PPUSH
1131: PPUSH
1132: PPUSH
// normal_oil := [ [ 28 , 22 ] , [ 69 , 3 ] , [ 138 , 27 ] , [ 180 , 104 ] , [ 138 , 137 ] , [ 76 , 115 ] ] ;
1133: LD_ADDR_VAR 0 5
1137: PUSH
1138: LD_INT 28
1140: PUSH
1141: LD_INT 22
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: PUSH
1148: LD_INT 69
1150: PUSH
1151: LD_INT 3
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 138
1160: PUSH
1161: LD_INT 27
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 180
1170: PUSH
1171: LD_INT 104
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: PUSH
1178: LD_INT 138
1180: PUSH
1181: LD_INT 137
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: PUSH
1188: LD_INT 76
1190: PUSH
1191: LD_INT 115
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: LIST
1205: ST_TO_ADDR
// extra_oil := [ [ [ 31 , 38 ] , [ 34 , 21 ] ] , [ [ 58 , 4 ] , [ 82 , 4 ] ] , [ [ 122 , 18 ] , [ 152 , 43 ] ] , [ [ 174 , 90 ] , [ 180 , 120 ] ] , [ [ 152 , 136 ] , [ 130 , 136 ] ] , [ [ 89 , 116 ] , [ 59 , 89 ] ] ] ;
1206: LD_ADDR_VAR 0 6
1210: PUSH
1211: LD_INT 31
1213: PUSH
1214: LD_INT 38
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: PUSH
1221: LD_INT 34
1223: PUSH
1224: LD_INT 21
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: PUSH
1235: LD_INT 58
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 82
1247: PUSH
1248: LD_INT 4
1250: PUSH
1251: EMPTY
1252: LIST
1253: LIST
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 122
1261: PUSH
1262: LD_INT 18
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PUSH
1269: LD_INT 152
1271: PUSH
1272: LD_INT 43
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: PUSH
1279: EMPTY
1280: LIST
1281: LIST
1282: PUSH
1283: LD_INT 174
1285: PUSH
1286: LD_INT 90
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: PUSH
1293: LD_INT 180
1295: PUSH
1296: LD_INT 120
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: PUSH
1307: LD_INT 152
1309: PUSH
1310: LD_INT 136
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: PUSH
1317: LD_INT 130
1319: PUSH
1320: LD_INT 136
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 89
1333: PUSH
1334: LD_INT 116
1336: PUSH
1337: EMPTY
1338: LIST
1339: LIST
1340: PUSH
1341: LD_INT 59
1343: PUSH
1344: LD_INT 89
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: ST_TO_ADDR
// normal_sib := [ [ 28 , 26 ] , [ 73 , 3 ] , [ 133 , 22 ] , [ 180 , 110 ] , [ 142 , 137 ] , [ 72 , 112 ] ] ;
1363: LD_ADDR_VAR 0 7
1367: PUSH
1368: LD_INT 28
1370: PUSH
1371: LD_INT 26
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: PUSH
1378: LD_INT 73
1380: PUSH
1381: LD_INT 3
1383: PUSH
1384: EMPTY
1385: LIST
1386: LIST
1387: PUSH
1388: LD_INT 133
1390: PUSH
1391: LD_INT 22
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 180
1400: PUSH
1401: LD_INT 110
1403: PUSH
1404: EMPTY
1405: LIST
1406: LIST
1407: PUSH
1408: LD_INT 142
1410: PUSH
1411: LD_INT 137
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: PUSH
1418: LD_INT 72
1420: PUSH
1421: LD_INT 112
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: PUSH
1428: EMPTY
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: ST_TO_ADDR
// extra_sib := [ [ [ 27 , 39 ] , [ 30 , 16 ] ] , [ [ 57 , 8 ] , [ 87 , 8 ] ] , [ [ 128 , 19 ] , [ 146 , 36 ] ] , [ [ 176 , 121 ] , [ 179 , 96 ] ] , [ [ 153 , 132 ] , [ 124 , 133 ] ] , [ [ 85 , 117 ] , [ 62 , 96 ] ] ] ;
1436: LD_ADDR_VAR 0 8
1440: PUSH
1441: LD_INT 27
1443: PUSH
1444: LD_INT 39
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: PUSH
1451: LD_INT 30
1453: PUSH
1454: LD_INT 16
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: PUSH
1461: EMPTY
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 57
1467: PUSH
1468: LD_INT 8
1470: PUSH
1471: EMPTY
1472: LIST
1473: LIST
1474: PUSH
1475: LD_INT 87
1477: PUSH
1478: LD_INT 8
1480: PUSH
1481: EMPTY
1482: LIST
1483: LIST
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: PUSH
1489: LD_INT 128
1491: PUSH
1492: LD_INT 19
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 146
1501: PUSH
1502: LD_INT 36
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: EMPTY
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 176
1515: PUSH
1516: LD_INT 121
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: PUSH
1523: LD_INT 179
1525: PUSH
1526: LD_INT 96
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: PUSH
1537: LD_INT 153
1539: PUSH
1540: LD_INT 132
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 124
1549: PUSH
1550: LD_INT 133
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: PUSH
1557: EMPTY
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 85
1563: PUSH
1564: LD_INT 117
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 62
1573: PUSH
1574: LD_INT 96
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: ST_TO_ADDR
// if bool then
1593: LD_VAR 0 1
1597: IFFALSE 1739
// begin for i = 1 to 6 do
1599: LD_ADDR_VAR 0 3
1603: PUSH
1604: DOUBLE
1605: LD_INT 1
1607: DEC
1608: ST_TO_ADDR
1609: LD_INT 6
1611: PUSH
1612: FOR_TO
1613: IFFALSE 1735
// for j = 1 to 2 do
1615: LD_ADDR_VAR 0 4
1619: PUSH
1620: DOUBLE
1621: LD_INT 1
1623: DEC
1624: ST_TO_ADDR
1625: LD_INT 2
1627: PUSH
1628: FOR_TO
1629: IFFALSE 1731
// begin CreateDepositXY ( extra_sib [ i ] [ j ] [ 1 ] , extra_sib [ i ] [ j ] [ 2 ] , mat_siberit ) ;
1631: LD_VAR 0 8
1635: PUSH
1636: LD_VAR 0 3
1640: ARRAY
1641: PUSH
1642: LD_VAR 0 4
1646: ARRAY
1647: PUSH
1648: LD_INT 1
1650: ARRAY
1651: PPUSH
1652: LD_VAR 0 8
1656: PUSH
1657: LD_VAR 0 3
1661: ARRAY
1662: PUSH
1663: LD_VAR 0 4
1667: ARRAY
1668: PUSH
1669: LD_INT 2
1671: ARRAY
1672: PPUSH
1673: LD_INT 3
1675: PPUSH
1676: CALL_OW 62
// CreateDepositXY ( extra_oil [ i ] [ j ] [ 1 ] , extra_oil [ i ] [ j ] [ 2 ] , mat_oil ) ;
1680: LD_VAR 0 6
1684: PUSH
1685: LD_VAR 0 3
1689: ARRAY
1690: PUSH
1691: LD_VAR 0 4
1695: ARRAY
1696: PUSH
1697: LD_INT 1
1699: ARRAY
1700: PPUSH
1701: LD_VAR 0 6
1705: PUSH
1706: LD_VAR 0 3
1710: ARRAY
1711: PUSH
1712: LD_VAR 0 4
1716: ARRAY
1717: PUSH
1718: LD_INT 2
1720: ARRAY
1721: PPUSH
1722: LD_INT 2
1724: PPUSH
1725: CALL_OW 62
// end ;
1729: GO 1628
1731: POP
1732: POP
1733: GO 1612
1735: POP
1736: POP
// end else
1737: GO 1833
// begin for j = 1 to 6 do
1739: LD_ADDR_VAR 0 4
1743: PUSH
1744: DOUBLE
1745: LD_INT 1
1747: DEC
1748: ST_TO_ADDR
1749: LD_INT 6
1751: PUSH
1752: FOR_TO
1753: IFFALSE 1831
// begin CreateDepositXY ( normal_sib [ j ] [ 1 ] , normal_sib [ j ] [ 2 ] , mat_siberit ) ;
1755: LD_VAR 0 7
1759: PUSH
1760: LD_VAR 0 4
1764: ARRAY
1765: PUSH
1766: LD_INT 1
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 7
1774: PUSH
1775: LD_VAR 0 4
1779: ARRAY
1780: PUSH
1781: LD_INT 2
1783: ARRAY
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: CALL_OW 62
// CreateDepositXY ( normal_oil [ j ] [ 1 ] , normal_oil [ j ] [ 2 ] , mat_oil ) ;
1792: LD_VAR 0 5
1796: PUSH
1797: LD_VAR 0 4
1801: ARRAY
1802: PUSH
1803: LD_INT 1
1805: ARRAY
1806: PPUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_VAR 0 4
1816: ARRAY
1817: PUSH
1818: LD_INT 2
1820: ARRAY
1821: PPUSH
1822: LD_INT 2
1824: PPUSH
1825: CALL_OW 62
// end ;
1829: GO 1752
1831: POP
1832: POP
// end ; super_source := bool ;
1833: LD_ADDR_EXP 71
1837: PUSH
1838: LD_VAR 0 1
1842: ST_TO_ADDR
// end ;
1843: LD_VAR 0 2
1847: RET
// export function UnitExist ( id , val ) ; begin
1848: LD_INT 0
1850: PPUSH
// if GetLives ( id ) >= val then
1851: LD_VAR 0 1
1855: PPUSH
1856: CALL_OW 256
1860: PUSH
1861: LD_VAR 0 2
1865: GREATEREQUAL
1866: IFFALSE 1878
// result := true else
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_INT 1
1875: ST_TO_ADDR
1876: GO 1886
// result := false ;
1878: LD_ADDR_VAR 0 3
1882: PUSH
1883: LD_INT 0
1885: ST_TO_ADDR
// end ;
1886: LD_VAR 0 3
1890: RET
// export function AnyBuildingExist ( side , typ ) ; begin
1891: LD_INT 0
1893: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , typ ] ] ) > 0 then
1894: LD_INT 22
1896: PUSH
1897: LD_VAR 0 1
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: PUSH
1906: LD_INT 30
1908: PUSH
1909: LD_VAR 0 2
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: PPUSH
1922: CALL_OW 69
1926: PUSH
1927: LD_INT 0
1929: GREATER
1930: IFFALSE 1942
// result := true else
1932: LD_ADDR_VAR 0 3
1936: PUSH
1937: LD_INT 1
1939: ST_TO_ADDR
1940: GO 1950
// result := false ;
1942: LD_ADDR_VAR 0 3
1946: PUSH
1947: LD_INT 0
1949: ST_TO_ADDR
// end ;
1950: LD_VAR 0 3
1954: RET
// export function ComRetreat ( un ) ; var coord_dist , dir , x , y ; begin
1955: LD_INT 0
1957: PPUSH
1958: PPUSH
1959: PPUSH
1960: PPUSH
1961: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
1962: LD_VAR 0 1
1966: PPUSH
1967: LD_INT 81
1969: PUSH
1970: LD_VAR 0 1
1974: PPUSH
1975: CALL_OW 255
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: PPUSH
1984: CALL_OW 69
1988: PPUSH
1989: LD_VAR 0 1
1993: PPUSH
1994: CALL_OW 74
1998: PPUSH
1999: CALL_OW 119
// dir := GetDir ( un ) ;
2003: LD_ADDR_VAR 0 4
2007: PUSH
2008: LD_VAR 0 1
2012: PPUSH
2013: CALL_OW 254
2017: ST_TO_ADDR
// dir := dir - 3 ;
2018: LD_ADDR_VAR 0 4
2022: PUSH
2023: LD_VAR 0 4
2027: PUSH
2028: LD_INT 3
2030: MINUS
2031: ST_TO_ADDR
// if dir < 0 then
2032: LD_VAR 0 4
2036: PUSH
2037: LD_INT 0
2039: LESS
2040: IFFALSE 2056
// dir := dir + 6 ;
2042: LD_ADDR_VAR 0 4
2046: PUSH
2047: LD_VAR 0 4
2051: PUSH
2052: LD_INT 6
2054: PLUS
2055: ST_TO_ADDR
// while true do
2056: LD_INT 1
2058: IFFALSE 2471
// begin coord_dist := 3 ;
2060: LD_ADDR_VAR 0 3
2064: PUSH
2065: LD_INT 3
2067: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
2068: LD_ADDR_VAR 0 5
2072: PUSH
2073: LD_VAR 0 1
2077: PPUSH
2078: CALL_OW 250
2082: PPUSH
2083: LD_VAR 0 4
2087: PPUSH
2088: LD_VAR 0 3
2092: PPUSH
2093: CALL_OW 272
2097: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
2098: LD_ADDR_VAR 0 6
2102: PUSH
2103: LD_VAR 0 1
2107: PPUSH
2108: CALL_OW 251
2112: PPUSH
2113: LD_VAR 0 4
2117: PPUSH
2118: LD_VAR 0 3
2122: PPUSH
2123: CALL_OW 273
2127: ST_TO_ADDR
// if IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or InArea ( x , y , HexEmpty ) = 0 or HexInfo ( x , y ) <> 0 then
2128: LD_VAR 0 5
2132: PPUSH
2133: LD_VAR 0 6
2137: PPUSH
2138: CALL_OW 351
2142: PUSH
2143: LD_VAR 0 5
2147: PPUSH
2148: LD_VAR 0 6
2152: PPUSH
2153: CALL_OW 488
2157: PUSH
2158: LD_INT 0
2160: EQUAL
2161: OR
2162: PUSH
2163: LD_VAR 0 5
2167: PPUSH
2168: LD_VAR 0 6
2172: PPUSH
2173: LD_INT 15
2175: PPUSH
2176: CALL_OW 309
2180: PUSH
2181: LD_INT 0
2183: EQUAL
2184: OR
2185: PUSH
2186: LD_VAR 0 5
2190: PPUSH
2191: LD_VAR 0 6
2195: PPUSH
2196: CALL_OW 428
2200: PUSH
2201: LD_INT 0
2203: NONEQUAL
2204: OR
2205: IFFALSE 2385
// begin repeat begin coord_dist := coord_dist + 1 ;
2207: LD_ADDR_VAR 0 3
2211: PUSH
2212: LD_VAR 0 3
2216: PUSH
2217: LD_INT 1
2219: PLUS
2220: ST_TO_ADDR
// dir := dir + 1 ;
2221: LD_ADDR_VAR 0 4
2225: PUSH
2226: LD_VAR 0 4
2230: PUSH
2231: LD_INT 1
2233: PLUS
2234: ST_TO_ADDR
// if dir > 5 then
2235: LD_VAR 0 4
2239: PUSH
2240: LD_INT 5
2242: GREATER
2243: IFFALSE 2253
// dir = 0 ;
2245: LD_ADDR_VAR 0 4
2249: PUSH
2250: LD_INT 0
2252: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
2253: LD_ADDR_VAR 0 5
2257: PUSH
2258: LD_VAR 0 1
2262: PPUSH
2263: CALL_OW 250
2267: PPUSH
2268: LD_VAR 0 4
2272: PPUSH
2273: LD_VAR 0 3
2277: PPUSH
2278: CALL_OW 272
2282: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
2283: LD_ADDR_VAR 0 6
2287: PUSH
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 251
2297: PPUSH
2298: LD_VAR 0 4
2302: PPUSH
2303: LD_VAR 0 3
2307: PPUSH
2308: CALL_OW 273
2312: ST_TO_ADDR
// end until not IsEnvironment ( x , y ) and ValidHex ( x , y ) and InArea ( x , y , HexEmpty ) and HexInfo ( x , y ) = 0 ;
2313: LD_VAR 0 5
2317: PPUSH
2318: LD_VAR 0 6
2322: PPUSH
2323: CALL_OW 351
2327: NOT
2328: PUSH
2329: LD_VAR 0 5
2333: PPUSH
2334: LD_VAR 0 6
2338: PPUSH
2339: CALL_OW 488
2343: AND
2344: PUSH
2345: LD_VAR 0 5
2349: PPUSH
2350: LD_VAR 0 6
2354: PPUSH
2355: LD_INT 15
2357: PPUSH
2358: CALL_OW 309
2362: AND
2363: PUSH
2364: LD_VAR 0 5
2368: PPUSH
2369: LD_VAR 0 6
2373: PPUSH
2374: CALL_OW 428
2378: PUSH
2379: LD_INT 0
2381: EQUAL
2382: AND
2383: IFFALSE 2207
// end ; AddComMoveXY ( un , x , y ) ;
2385: LD_VAR 0 1
2389: PPUSH
2390: LD_VAR 0 5
2394: PPUSH
2395: LD_VAR 0 6
2399: PPUSH
2400: CALL_OW 171
// Wait ( 0 0$1 ) ;
2404: LD_INT 35
2406: PPUSH
2407: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 16 then
2411: LD_VAR 0 1
2415: PPUSH
2416: LD_INT 81
2418: PUSH
2419: LD_VAR 0 1
2423: PPUSH
2424: CALL_OW 255
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PPUSH
2433: CALL_OW 69
2437: PPUSH
2438: LD_VAR 0 1
2442: PPUSH
2443: CALL_OW 74
2447: PPUSH
2448: CALL_OW 296
2452: PUSH
2453: LD_INT 16
2455: GREATEREQUAL
2456: IFFALSE 2469
// begin ComStop ( un ) ;
2458: LD_VAR 0 1
2462: PPUSH
2463: CALL_OW 141
// break ;
2467: GO 2471
// end ; end ;
2469: GO 2056
// end ;
2471: LD_VAR 0 2
2475: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
2476: LD_INT 0
2478: PPUSH
2479: PPUSH
2480: PPUSH
2481: PPUSH
2482: PPUSH
2483: PPUSH
// hc_class := clas ;
2484: LD_ADDR_OWVAR 28
2488: PUSH
2489: LD_VAR 0 1
2493: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
2494: LD_ADDR_VAR 0 4
2498: PUSH
2499: LD_VAR 0 2
2503: PUSH
2504: LD_INT 1
2506: NEG
2507: PPUSH
2508: LD_INT 1
2510: PPUSH
2511: CALL_OW 12
2515: PLUS
2516: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 2
2526: PUSH
2527: LD_INT 1
2529: NEG
2530: PPUSH
2531: LD_INT 1
2533: PPUSH
2534: CALL_OW 12
2538: PLUS
2539: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
2540: LD_ADDR_VAR 0 6
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_INT 1
2552: NEG
2553: PPUSH
2554: LD_INT 1
2556: PPUSH
2557: CALL_OW 12
2561: PLUS
2562: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
2563: LD_ADDR_VAR 0 7
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_INT 1
2575: NEG
2576: PPUSH
2577: LD_INT 1
2579: PPUSH
2580: CALL_OW 12
2584: PLUS
2585: ST_TO_ADDR
// if clas = 1 or clas = class_bazooker or clas = class_sniper or clas = class_mortar then
2586: LD_VAR 0 1
2590: PUSH
2591: LD_INT 1
2593: EQUAL
2594: PUSH
2595: LD_VAR 0 1
2599: PUSH
2600: LD_INT 9
2602: EQUAL
2603: OR
2604: PUSH
2605: LD_VAR 0 1
2609: PUSH
2610: LD_INT 5
2612: EQUAL
2613: OR
2614: PUSH
2615: LD_VAR 0 1
2619: PUSH
2620: LD_INT 8
2622: EQUAL
2623: OR
2624: IFFALSE 2649
// bonus := [ 2 , 0 , 0 , 0 ] ;
2626: LD_ADDR_VAR 0 8
2630: PUSH
2631: LD_INT 2
2633: PUSH
2634: LD_INT 0
2636: PUSH
2637: LD_INT 0
2639: PUSH
2640: LD_INT 0
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: ST_TO_ADDR
// if clas = 2 then
2649: LD_VAR 0 1
2653: PUSH
2654: LD_INT 2
2656: EQUAL
2657: IFFALSE 2682
// bonus := [ 0 , 2 , 0 , 0 ] ;
2659: LD_ADDR_VAR 0 8
2663: PUSH
2664: LD_INT 0
2666: PUSH
2667: LD_INT 2
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: LD_INT 0
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: LIST
2680: LIST
2681: ST_TO_ADDR
// if clas = 3 then
2682: LD_VAR 0 1
2686: PUSH
2687: LD_INT 3
2689: EQUAL
2690: IFFALSE 2715
// bonus := [ 0 , 0 , 2 , 0 ] ;
2692: LD_ADDR_VAR 0 8
2696: PUSH
2697: LD_INT 0
2699: PUSH
2700: LD_INT 0
2702: PUSH
2703: LD_INT 2
2705: PUSH
2706: LD_INT 0
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: LIST
2713: LIST
2714: ST_TO_ADDR
// if clas = 4 then
2715: LD_VAR 0 1
2719: PUSH
2720: LD_INT 4
2722: EQUAL
2723: IFFALSE 2748
// bonus := [ 0 , 0 , 0 , 2 ] ;
2725: LD_ADDR_VAR 0 8
2729: PUSH
2730: LD_INT 0
2732: PUSH
2733: LD_INT 0
2735: PUSH
2736: LD_INT 0
2738: PUSH
2739: LD_INT 2
2741: PUSH
2742: EMPTY
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
2748: LD_VAR 0 1
2752: PUSH
2753: LD_INT 4
2755: GREATER
2756: PUSH
2757: LD_VAR 0 1
2761: PUSH
2762: LD_INT 9
2764: NONEQUAL
2765: AND
2766: PUSH
2767: LD_VAR 0 1
2771: PUSH
2772: LD_INT 5
2774: NONEQUAL
2775: AND
2776: PUSH
2777: LD_VAR 0 1
2781: PUSH
2782: LD_INT 8
2784: NONEQUAL
2785: AND
2786: IFFALSE 2811
// bonus := [ 0 , 0 , 0 , 0 ] ;
2788: LD_ADDR_VAR 0 8
2792: PUSH
2793: LD_INT 0
2795: PUSH
2796: LD_INT 0
2798: PUSH
2799: LD_INT 0
2801: PUSH
2802: LD_INT 0
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2811: LD_ADDR_OWVAR 30
2815: PUSH
2816: LD_INT 0
2818: PPUSH
2819: LD_INT 2
2821: PPUSH
2822: CALL_OW 12
2826: PUSH
2827: LD_INT 0
2829: PPUSH
2830: LD_INT 2
2832: PPUSH
2833: CALL_OW 12
2837: PUSH
2838: LD_INT 0
2840: PPUSH
2841: LD_INT 2
2843: PPUSH
2844: CALL_OW 12
2848: PUSH
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: CALL_OW 12
2859: PUSH
2860: EMPTY
2861: LIST
2862: LIST
2863: LIST
2864: LIST
2865: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
2866: LD_ADDR_OWVAR 31
2870: PUSH
2871: LD_VAR 0 4
2875: PUSH
2876: LD_VAR 0 8
2880: PUSH
2881: LD_INT 1
2883: ARRAY
2884: PLUS
2885: PUSH
2886: LD_VAR 0 5
2890: PUSH
2891: LD_VAR 0 8
2895: PUSH
2896: LD_INT 2
2898: ARRAY
2899: PLUS
2900: PUSH
2901: LD_VAR 0 6
2905: PUSH
2906: LD_VAR 0 8
2910: PUSH
2911: LD_INT 3
2913: ARRAY
2914: PLUS
2915: PUSH
2916: LD_VAR 0 7
2920: PUSH
2921: LD_VAR 0 8
2925: PUSH
2926: LD_INT 4
2928: ARRAY
2929: PLUS
2930: PUSH
2931: EMPTY
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
2937: LD_ADDR_OWVAR 27
2941: PUSH
2942: LD_INT 1
2944: PPUSH
2945: LD_INT 2
2947: PPUSH
2948: CALL_OW 12
2952: ST_TO_ADDR
// hc_gallery :=  ;
2953: LD_ADDR_OWVAR 33
2957: PUSH
2958: LD_STRING 
2960: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
2961: LD_ADDR_OWVAR 29
2965: PUSH
2966: LD_INT 8
2968: PPUSH
2969: LD_INT 12
2971: PPUSH
2972: CALL_OW 12
2976: PUSH
2977: LD_INT 9
2979: PPUSH
2980: LD_INT 11
2982: PPUSH
2983: CALL_OW 12
2987: PUSH
2988: EMPTY
2989: LIST
2990: LIST
2991: ST_TO_ADDR
// hc_name :=  ;
2992: LD_ADDR_OWVAR 26
2996: PUSH
2997: LD_STRING 
2999: ST_TO_ADDR
// result := CreateHuman ;
3000: LD_ADDR_VAR 0 3
3004: PUSH
3005: CALL_OW 44
3009: ST_TO_ADDR
// end ;
3010: LD_VAR 0 3
3014: RET
// export function scs_create_squad ( side , nation , people , skill , area ) ; var i , num , un ; begin
3015: LD_INT 0
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
// num := people / 4 ;
3021: LD_ADDR_VAR 0 8
3025: PUSH
3026: LD_VAR 0 3
3030: PUSH
3031: LD_INT 4
3033: DIVREAL
3034: ST_TO_ADDR
// uc_side := side ;
3035: LD_ADDR_OWVAR 20
3039: PUSH
3040: LD_VAR 0 1
3044: ST_TO_ADDR
// uc_nation := nation ;
3045: LD_ADDR_OWVAR 21
3049: PUSH
3050: LD_VAR 0 2
3054: ST_TO_ADDR
// hc_importance := 100 ;
3055: LD_ADDR_OWVAR 32
3059: PUSH
3060: LD_INT 100
3062: ST_TO_ADDR
// un := CreateHumanWithClass ( 1 , skill ) ;
3063: LD_ADDR_VAR 0 9
3067: PUSH
3068: LD_INT 1
3070: PPUSH
3071: LD_VAR 0 4
3075: PPUSH
3076: CALL 2476 0 2
3080: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
3081: LD_VAR 0 9
3085: PPUSH
3086: LD_VAR 0 5
3090: PPUSH
3091: LD_INT 0
3093: PPUSH
3094: CALL_OW 49
// hc_importance := 0 ;
3098: LD_ADDR_OWVAR 32
3102: PUSH
3103: LD_INT 0
3105: ST_TO_ADDR
// for i = 1 to num do
3106: LD_ADDR_VAR 0 7
3110: PUSH
3111: DOUBLE
3112: LD_INT 1
3114: DEC
3115: ST_TO_ADDR
3116: LD_VAR 0 8
3120: PUSH
3121: FOR_TO
3122: IFFALSE 3151
// PlaceUnitArea ( CreateHumanWithClass ( 1 , skill ) , area , false ) ;
3124: LD_INT 1
3126: PPUSH
3127: LD_VAR 0 4
3131: PPUSH
3132: CALL 2476 0 2
3136: PPUSH
3137: LD_VAR 0 5
3141: PPUSH
3142: LD_INT 0
3144: PPUSH
3145: CALL_OW 49
3149: GO 3121
3151: POP
3152: POP
// for i = 1 to num do
3153: LD_ADDR_VAR 0 7
3157: PUSH
3158: DOUBLE
3159: LD_INT 1
3161: DEC
3162: ST_TO_ADDR
3163: LD_VAR 0 8
3167: PUSH
3168: FOR_TO
3169: IFFALSE 3198
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , area , false ) ;
3171: LD_INT 2
3173: PPUSH
3174: LD_VAR 0 4
3178: PPUSH
3179: CALL 2476 0 2
3183: PPUSH
3184: LD_VAR 0 5
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
3196: GO 3168
3198: POP
3199: POP
// for i = 1 to num do
3200: LD_ADDR_VAR 0 7
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_VAR 0 8
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3245
// PlaceUnitArea ( CreateHumanWithClass ( 3 , skill ) , area , false ) ;
3218: LD_INT 3
3220: PPUSH
3221: LD_VAR 0 4
3225: PPUSH
3226: CALL 2476 0 2
3230: PPUSH
3231: LD_VAR 0 5
3235: PPUSH
3236: LD_INT 0
3238: PPUSH
3239: CALL_OW 49
3243: GO 3215
3245: POP
3246: POP
// for i = 1 to num do
3247: LD_ADDR_VAR 0 7
3251: PUSH
3252: DOUBLE
3253: LD_INT 1
3255: DEC
3256: ST_TO_ADDR
3257: LD_VAR 0 8
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3292
// PlaceUnitArea ( CreateHumanWithClass ( 4 , skill ) , area , false ) ;
3265: LD_INT 4
3267: PPUSH
3268: LD_VAR 0 4
3272: PPUSH
3273: CALL 2476 0 2
3277: PPUSH
3278: LD_VAR 0 5
3282: PPUSH
3283: LD_INT 0
3285: PPUSH
3286: CALL_OW 49
3290: GO 3262
3292: POP
3293: POP
// end ;
3294: LD_VAR 0 6
3298: RET
// export function scs_scan_side ( side ) ; begin
3299: LD_INT 0
3301: PPUSH
// result := FilterAllUnits ( [ f_side , side ] ) ;
3302: LD_ADDR_VAR 0 2
3306: PUSH
3307: LD_INT 22
3309: PUSH
3310: LD_VAR 0 1
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PPUSH
3319: CALL_OW 69
3323: ST_TO_ADDR
// end ;
3324: LD_VAR 0 2
3328: RET
// export function scs_clear_side ( side ) ; var i , filter ; begin
3329: LD_INT 0
3331: PPUSH
3332: PPUSH
3333: PPUSH
// filter := scs_scan_side ( side ) ;
3334: LD_ADDR_VAR 0 4
3338: PUSH
3339: LD_VAR 0 1
3343: PPUSH
3344: CALL 3299 0 1
3348: ST_TO_ADDR
// for i = 1 to filter do
3349: LD_ADDR_VAR 0 3
3353: PUSH
3354: DOUBLE
3355: LD_INT 1
3357: DEC
3358: ST_TO_ADDR
3359: LD_VAR 0 4
3363: PUSH
3364: FOR_TO
3365: IFFALSE 3384
// RemoveUnit ( filter [ i ] ) ;
3367: LD_VAR 0 4
3371: PUSH
3372: LD_VAR 0 3
3376: ARRAY
3377: PPUSH
3378: CALL_OW 64
3382: GO 3364
3384: POP
3385: POP
// end ;
3386: LD_VAR 0 2
3390: RET
// export function scs_scan_class ( side , clas , bool ) ; begin
3391: LD_INT 0
3393: PPUSH
// if bool = false then
3394: LD_VAR 0 3
3398: PUSH
3399: LD_INT 0
3401: EQUAL
3402: IFFALSE 3444
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , clas ] ] ) else
3404: LD_ADDR_VAR 0 4
3408: PUSH
3409: LD_INT 22
3411: PUSH
3412: LD_VAR 0 1
3416: PUSH
3417: EMPTY
3418: LIST
3419: LIST
3420: PUSH
3421: LD_INT 25
3423: PUSH
3424: LD_VAR 0 2
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: PUSH
3433: EMPTY
3434: LIST
3435: LIST
3436: PPUSH
3437: CALL_OW 69
3441: ST_TO_ADDR
3442: GO 3489
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , clas ] , [ f_ok ] ] ) end ;
3444: LD_ADDR_VAR 0 4
3448: PUSH
3449: LD_INT 22
3451: PUSH
3452: LD_VAR 0 1
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 25
3463: PUSH
3464: LD_VAR 0 2
3468: PUSH
3469: EMPTY
3470: LIST
3471: LIST
3472: PUSH
3473: LD_INT 50
3475: PUSH
3476: EMPTY
3477: LIST
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: PPUSH
3484: CALL_OW 69
3488: ST_TO_ADDR
3489: LD_VAR 0 4
3493: RET
// export function scs_scan_damage ( side , value ) ; begin
3494: LD_INT 0
3496: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_lives , value ] ] ] ) ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: LD_INT 22
3504: PUSH
3505: LD_VAR 0 1
3509: PUSH
3510: EMPTY
3511: LIST
3512: LIST
3513: PUSH
3514: LD_INT 3
3516: PUSH
3517: LD_INT 24
3519: PUSH
3520: LD_VAR 0 2
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: PPUSH
3537: CALL_OW 69
3541: ST_TO_ADDR
// end ;
3542: LD_VAR 0 3
3546: RET
// export function scs_scan_area ( side , x , y , dist ) ; var enemy ; begin
3547: LD_INT 0
3549: PPUSH
3550: PPUSH
// enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
3551: LD_ADDR_VAR 0 6
3555: PUSH
3556: LD_INT 81
3558: PUSH
3559: LD_VAR 0 1
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: PUSH
3568: LD_INT 92
3570: PUSH
3571: LD_VAR 0 2
3575: PUSH
3576: LD_VAR 0 3
3580: PUSH
3581: LD_VAR 0 4
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: PUSH
3592: EMPTY
3593: LIST
3594: LIST
3595: PPUSH
3596: CALL_OW 69
3600: ST_TO_ADDR
// if enemy > 0 then
3601: LD_VAR 0 6
3605: PUSH
3606: LD_INT 0
3608: GREATER
3609: IFFALSE 3621
// result := true else
3611: LD_ADDR_VAR 0 5
3615: PUSH
3616: LD_INT 1
3618: ST_TO_ADDR
3619: GO 3629
// result := false ;
3621: LD_ADDR_VAR 0 5
3625: PUSH
3626: LD_INT 0
3628: ST_TO_ADDR
// end ;
3629: LD_VAR 0 5
3633: RET
// export function scs_scan_lab ( side ) ; begin
3634: LD_INT 0
3636: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3637: LD_ADDR_VAR 0 2
3641: PUSH
3642: LD_INT 22
3644: PUSH
3645: LD_VAR 0 1
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PUSH
3654: LD_INT 2
3656: PUSH
3657: LD_INT 30
3659: PUSH
3660: LD_INT 6
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: PUSH
3667: LD_INT 30
3669: PUSH
3670: LD_INT 7
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: PUSH
3677: LD_INT 30
3679: PUSH
3680: LD_INT 8
3682: PUSH
3683: EMPTY
3684: LIST
3685: LIST
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PPUSH
3697: CALL_OW 69
3701: ST_TO_ADDR
// end ;
3702: LD_VAR 0 2
3706: RET
// export function scs_scan_buildings ( side , typ ) ; begin
3707: LD_INT 0
3709: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , typ ] ] ) ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: LD_INT 22
3717: PUSH
3718: LD_VAR 0 1
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: LD_INT 30
3729: PUSH
3730: LD_VAR 0 2
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: PPUSH
3743: CALL_OW 69
3747: ST_TO_ADDR
// end ;
3748: LD_VAR 0 3
3752: RET
// export function scs_change_side ( side , new_side ) ; var filter , i ; begin
3753: LD_INT 0
3755: PPUSH
3756: PPUSH
3757: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
3758: LD_ADDR_VAR 0 4
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_VAR 0 1
3770: PUSH
3771: EMPTY
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 21
3777: PUSH
3778: LD_INT 1
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: PPUSH
3789: CALL_OW 69
3793: ST_TO_ADDR
// for i = 1 to filter do
3794: LD_ADDR_VAR 0 5
3798: PUSH
3799: DOUBLE
3800: LD_INT 1
3802: DEC
3803: ST_TO_ADDR
3804: LD_VAR 0 4
3808: PUSH
3809: FOR_TO
3810: IFFALSE 3834
// SetSide ( filter [ i ] , new_side ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_VAR 0 5
3821: ARRAY
3822: PPUSH
3823: LD_VAR 0 2
3827: PPUSH
3828: CALL_OW 235
3832: GO 3809
3834: POP
3835: POP
// end ;
3836: LD_VAR 0 3
3840: RET
// export function Build ( engs , build , x , y , d , cost ) ; var i , dep ; begin
3841: LD_INT 0
3843: PPUSH
3844: PPUSH
3845: PPUSH
// dep := FilterAllUnits ( [ [ [ f_side , GetSide ( engs [ 1 ] ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
3846: LD_ADDR_VAR 0 9
3850: PUSH
3851: LD_INT 22
3853: PUSH
3854: LD_VAR 0 1
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: CALL_OW 255
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 2
3874: PUSH
3875: LD_INT 30
3877: PUSH
3878: LD_INT 0
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: PUSH
3885: LD_INT 30
3887: PUSH
3888: LD_INT 1
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PUSH
3904: EMPTY
3905: LIST
3906: PPUSH
3907: CALL_OW 69
3911: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) >= cost then
3912: LD_VAR 0 9
3916: PUSH
3917: LD_INT 1
3919: ARRAY
3920: PPUSH
3921: CALL_OW 274
3925: PPUSH
3926: LD_INT 1
3928: PPUSH
3929: CALL_OW 275
3933: PUSH
3934: LD_VAR 0 6
3938: GREATEREQUAL
3939: IFFALSE 4034
// for i = 1 to engs do
3941: LD_ADDR_VAR 0 8
3945: PUSH
3946: DOUBLE
3947: LD_INT 1
3949: DEC
3950: ST_TO_ADDR
3951: LD_VAR 0 1
3955: PUSH
3956: FOR_TO
3957: IFFALSE 4032
// if not HasTask ( engs [ i ] ) and not Carry ( engs [ i ] ) then
3959: LD_VAR 0 1
3963: PUSH
3964: LD_VAR 0 8
3968: ARRAY
3969: PPUSH
3970: CALL_OW 314
3974: NOT
3975: PUSH
3976: LD_VAR 0 1
3980: PUSH
3981: LD_VAR 0 8
3985: ARRAY
3986: PPUSH
3987: CALL_OW 281
3991: NOT
3992: AND
3993: IFFALSE 4030
// ComBuild ( engs [ i ] , build , x , y , d ) ;
3995: LD_VAR 0 1
3999: PUSH
4000: LD_VAR 0 8
4004: ARRAY
4005: PPUSH
4006: LD_VAR 0 2
4010: PPUSH
4011: LD_VAR 0 3
4015: PPUSH
4016: LD_VAR 0 4
4020: PPUSH
4021: LD_VAR 0 5
4025: PPUSH
4026: CALL_OW 145
4030: GO 3956
4032: POP
4033: POP
// end ;
4034: LD_VAR 0 7
4038: RET
// export function Upgrade ( side , typ , cost ) ; var i , dep , b ; begin
4039: LD_INT 0
4041: PPUSH
4042: PPUSH
4043: PPUSH
4044: PPUSH
// b := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , typ ] ] ) [ 1 ] ;
4045: LD_ADDR_VAR 0 7
4049: PUSH
4050: LD_INT 22
4052: PUSH
4053: LD_VAR 0 1
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: PUSH
4062: LD_INT 30
4064: PUSH
4065: LD_VAR 0 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PPUSH
4078: CALL_OW 69
4082: PUSH
4083: LD_INT 1
4085: ARRAY
4086: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
4087: LD_ADDR_VAR 0 6
4091: PUSH
4092: LD_INT 22
4094: PUSH
4095: LD_VAR 0 1
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: PUSH
4104: LD_INT 2
4106: PUSH
4107: LD_INT 30
4109: PUSH
4110: LD_INT 0
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: LD_INT 30
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: EMPTY
4128: LIST
4129: LIST
4130: LIST
4131: PUSH
4132: EMPTY
4133: LIST
4134: LIST
4135: PUSH
4136: EMPTY
4137: LIST
4138: PPUSH
4139: CALL_OW 69
4143: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) >= cost then
4144: LD_VAR 0 6
4148: PUSH
4149: LD_INT 1
4151: ARRAY
4152: PPUSH
4153: CALL_OW 274
4157: PPUSH
4158: LD_INT 1
4160: PPUSH
4161: CALL_OW 275
4165: PUSH
4166: LD_VAR 0 3
4170: GREATEREQUAL
4171: IFFALSE 4182
// ComUpgrade ( b ) ;
4173: LD_VAR 0 7
4177: PPUSH
4178: CALL_OW 146
// end ;
4182: LD_VAR 0 4
4186: RET
// export function UpgradeLab ( lab , typ1 , cost ) ; var dep ; begin
4187: LD_INT 0
4189: PPUSH
4190: PPUSH
// dep := FilterAllUnits ( [ [ [ f_side , GetSide ( lab ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
4191: LD_ADDR_VAR 0 5
4195: PUSH
4196: LD_INT 22
4198: PUSH
4199: LD_VAR 0 1
4203: PPUSH
4204: CALL_OW 255
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 2
4215: PUSH
4216: LD_INT 30
4218: PUSH
4219: LD_INT 0
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PUSH
4226: LD_INT 30
4228: PUSH
4229: LD_INT 1
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PUSH
4245: EMPTY
4246: LIST
4247: PPUSH
4248: CALL_OW 69
4252: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) >= cost then
4253: LD_VAR 0 5
4257: PUSH
4258: LD_INT 1
4260: ARRAY
4261: PPUSH
4262: CALL_OW 274
4266: PPUSH
4267: LD_INT 1
4269: PPUSH
4270: CALL_OW 275
4274: PUSH
4275: LD_VAR 0 3
4279: GREATEREQUAL
4280: IFFALSE 4296
// ComUpgradeLab ( lab , typ1 ) ;
4282: LD_VAR 0 1
4286: PPUSH
4287: LD_VAR 0 2
4291: PPUSH
4292: CALL_OW 147
// end ;
4296: LD_VAR 0 4
4300: RET
// export function BuildPowerPlant ( engs , typ , x , y , d ) ; var i , b , dep , source , source2 , side ; begin
4301: LD_INT 0
4303: PPUSH
4304: PPUSH
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
4309: PPUSH
// side := GetSide ( engs [ 1 ] ) ;
4310: LD_ADDR_VAR 0 12
4314: PUSH
4315: LD_VAR 0 1
4319: PUSH
4320: LD_INT 1
4322: ARRAY
4323: PPUSH
4324: CALL_OW 255
4328: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
4329: LD_ADDR_VAR 0 9
4333: PUSH
4334: LD_INT 22
4336: PUSH
4337: LD_VAR 0 12
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: PUSH
4346: LD_INT 2
4348: PUSH
4349: LD_INT 30
4351: PUSH
4352: LD_INT 0
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 30
4361: PUSH
4362: LD_INT 1
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: LIST
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: PUSH
4378: EMPTY
4379: LIST
4380: PPUSH
4381: CALL_OW 69
4385: ST_TO_ADDR
// source := GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) ;
4386: LD_ADDR_VAR 0 10
4390: PUSH
4391: LD_VAR 0 9
4395: PUSH
4396: LD_INT 1
4398: ARRAY
4399: PPUSH
4400: CALL_OW 274
4404: PPUSH
4405: LD_INT 1
4407: PPUSH
4408: CALL_OW 275
4412: ST_TO_ADDR
// source2 := GetResourceType ( GetBase ( dep [ 1 ] ) , mat_siberit ) ;
4413: LD_ADDR_VAR 0 11
4417: PUSH
4418: LD_VAR 0 9
4422: PUSH
4423: LD_INT 1
4425: ARRAY
4426: PPUSH
4427: CALL_OW 274
4431: PPUSH
4432: LD_INT 3
4434: PPUSH
4435: CALL_OW 275
4439: ST_TO_ADDR
// case typ of b_solar_power :
4440: LD_VAR 0 2
4444: PUSH
4445: LD_INT 27
4447: DOUBLE
4448: EQUAL
4449: IFTRUE 4453
4451: GO 4513
4453: POP
// begin if GetTech ( tech_solpow , side ) = state_researched and source >= 35 then
4454: LD_INT 35
4456: PPUSH
4457: LD_VAR 0 12
4461: PPUSH
4462: CALL_OW 321
4466: PUSH
4467: LD_INT 2
4469: EQUAL
4470: PUSH
4471: LD_VAR 0 10
4475: PUSH
4476: LD_INT 35
4478: GREATEREQUAL
4479: AND
4480: IFFALSE 4511
// ComBuild ( engs , typ , x , y , d ) ;
4482: LD_VAR 0 1
4486: PPUSH
4487: LD_VAR 0 2
4491: PPUSH
4492: LD_VAR 0 3
4496: PPUSH
4497: LD_VAR 0 4
4501: PPUSH
4502: LD_VAR 0 5
4506: PPUSH
4507: CALL_OW 145
// end ; b_oil_power :
4511: GO 4660
4513: LD_INT 26
4515: DOUBLE
4516: EQUAL
4517: IFTRUE 4521
4519: GO 4581
4521: POP
// begin if GetTech ( tech_oilpow , side ) = state_researched and source >= 20 then
4522: LD_INT 46
4524: PPUSH
4525: LD_VAR 0 12
4529: PPUSH
4530: CALL_OW 321
4534: PUSH
4535: LD_INT 2
4537: EQUAL
4538: PUSH
4539: LD_VAR 0 10
4543: PUSH
4544: LD_INT 20
4546: GREATEREQUAL
4547: AND
4548: IFFALSE 4579
// ComBuild ( engs , typ , x , y , d ) ;
4550: LD_VAR 0 1
4554: PPUSH
4555: LD_VAR 0 2
4559: PPUSH
4560: LD_VAR 0 3
4564: PPUSH
4565: LD_VAR 0 4
4569: PPUSH
4570: LD_VAR 0 5
4574: PPUSH
4575: CALL_OW 145
// end ; b_siberite_power :
4579: GO 4660
4581: LD_INT 28
4583: DOUBLE
4584: EQUAL
4585: IFTRUE 4589
4587: GO 4659
4589: POP
// begin if GetTech ( tech_sibpow , side ) = state_researched and source >= 20 and source2 >= 10 then
4590: LD_INT 21
4592: PPUSH
4593: LD_VAR 0 12
4597: PPUSH
4598: CALL_OW 321
4602: PUSH
4603: LD_INT 2
4605: EQUAL
4606: PUSH
4607: LD_VAR 0 10
4611: PUSH
4612: LD_INT 20
4614: GREATEREQUAL
4615: AND
4616: PUSH
4617: LD_VAR 0 11
4621: PUSH
4622: LD_INT 10
4624: GREATEREQUAL
4625: AND
4626: IFFALSE 4657
// ComBuild ( engs , typ , x , y , d ) ;
4628: LD_VAR 0 1
4632: PPUSH
4633: LD_VAR 0 2
4637: PPUSH
4638: LD_VAR 0 3
4642: PPUSH
4643: LD_VAR 0 4
4647: PPUSH
4648: LD_VAR 0 5
4652: PPUSH
4653: CALL_OW 145
// end ; end ;
4657: GO 4660
4659: POP
// end ;
4660: LD_VAR 0 6
4664: RET
// export function SortFilter ( filter , skill ) ; var skill_list , i , list ; begin
4665: LD_INT 0
4667: PPUSH
4668: PPUSH
4669: PPUSH
4670: PPUSH
// for i in filter do
4671: LD_ADDR_VAR 0 5
4675: PUSH
4676: LD_VAR 0 1
4680: PUSH
4681: FOR_IN
4682: IFFALSE 4712
// skill_list = skill_list ^ GetSkill ( i , skill ) ;
4684: LD_ADDR_VAR 0 4
4688: PUSH
4689: LD_VAR 0 4
4693: PUSH
4694: LD_VAR 0 5
4698: PPUSH
4699: LD_VAR 0 2
4703: PPUSH
4704: CALL_OW 259
4708: ADD
4709: ST_TO_ADDR
4710: GO 4681
4712: POP
4713: POP
// result = SortListByListDesc ( filter , skill_list ) ;
4714: LD_ADDR_VAR 0 3
4718: PUSH
4719: LD_VAR 0 1
4723: PPUSH
4724: LD_VAR 0 4
4728: PPUSH
4729: CALL_OW 77
4733: ST_TO_ADDR
// end ;
4734: LD_VAR 0 3
4738: RET
// export function scs_change_class ( unit , clas ) ; var side ; begin
4739: LD_INT 0
4741: PPUSH
4742: PPUSH
// side := GetSide ( unit ) ;
4743: LD_ADDR_VAR 0 4
4747: PUSH
4748: LD_VAR 0 1
4752: PPUSH
4753: CALL_OW 255
4757: ST_TO_ADDR
// if not HasTask ( unit ) then
4758: LD_VAR 0 1
4762: PPUSH
4763: CALL_OW 314
4767: NOT
4768: IFFALSE 5060
// case clas of 1 :
4770: LD_VAR 0 2
4774: PUSH
4775: LD_INT 1
4777: DOUBLE
4778: EQUAL
4779: IFTRUE 4783
4781: GO 4846
4783: POP
// begin if IsInUnit ( unit ) then
4784: LD_VAR 0 1
4788: PPUSH
4789: CALL_OW 310
4793: IFFALSE 4804
// ComExitBuilding ( unit ) ;
4795: LD_VAR 0 1
4799: PPUSH
4800: CALL_OW 122
// Wait ( 1 ) ;
4804: LD_INT 1
4806: PPUSH
4807: CALL_OW 67
// ComEnterUnit ( unit , scs_find_barracks ( side ) ) ;
4811: LD_VAR 0 1
4815: PPUSH
4816: LD_VAR 0 4
4820: PPUSH
4821: CALL 5065 0 1
4825: PPUSH
4826: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
4830: LD_VAR 0 1
4834: PPUSH
4835: LD_VAR 0 2
4839: PPUSH
4840: CALL_OW 183
// end ; 2 :
4844: GO 5060
4846: LD_INT 2
4848: DOUBLE
4849: EQUAL
4850: IFTRUE 4854
4852: GO 4917
4854: POP
// begin if IsInUnit ( unit ) then
4855: LD_VAR 0 1
4859: PPUSH
4860: CALL_OW 310
4864: IFFALSE 4875
// ComExitBuilding ( unit ) ;
4866: LD_VAR 0 1
4870: PPUSH
4871: CALL_OW 122
// Wait ( 1 ) ;
4875: LD_INT 1
4877: PPUSH
4878: CALL_OW 67
// ComEnterUnit ( unit , scs_find_depot ( side ) ) ;
4882: LD_VAR 0 1
4886: PPUSH
4887: LD_VAR 0 4
4891: PPUSH
4892: CALL 5481 0 1
4896: PPUSH
4897: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
4901: LD_VAR 0 1
4905: PPUSH
4906: LD_VAR 0 2
4910: PPUSH
4911: CALL_OW 183
// end ; 3 :
4915: GO 5060
4917: LD_INT 3
4919: DOUBLE
4920: EQUAL
4921: IFTRUE 4925
4923: GO 4988
4925: POP
// begin if IsInUnit ( unit ) then
4926: LD_VAR 0 1
4930: PPUSH
4931: CALL_OW 310
4935: IFFALSE 4946
// ComExitBuilding ( unit ) ;
4937: LD_VAR 0 1
4941: PPUSH
4942: CALL_OW 122
// Wait ( 1 ) ;
4946: LD_INT 1
4948: PPUSH
4949: CALL_OW 67
// ComEnterUnit ( unit , scs_find_factory ( side ) ) ;
4953: LD_VAR 0 1
4957: PPUSH
4958: LD_VAR 0 4
4962: PPUSH
4963: CALL 5346 0 1
4967: PPUSH
4968: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
4972: LD_VAR 0 1
4976: PPUSH
4977: LD_VAR 0 2
4981: PPUSH
4982: CALL_OW 183
// end ; 4 :
4986: GO 5060
4988: LD_INT 4
4990: DOUBLE
4991: EQUAL
4992: IFTRUE 4996
4994: GO 5059
4996: POP
// begin if IsInUnit ( unit ) then
4997: LD_VAR 0 1
5001: PPUSH
5002: CALL_OW 310
5006: IFFALSE 5017
// ComExitBuilding ( unit ) ;
5008: LD_VAR 0 1
5012: PPUSH
5013: CALL_OW 122
// Wait ( 1 ) ;
5017: LD_INT 1
5019: PPUSH
5020: CALL_OW 67
// ComEnterUnit ( unit , scs_find_lab ( side ) ) ;
5024: LD_VAR 0 1
5028: PPUSH
5029: LD_VAR 0 4
5033: PPUSH
5034: CALL 5200 0 1
5038: PPUSH
5039: CALL_OW 120
// AddComChangeProfession ( unit , clas ) ;
5043: LD_VAR 0 1
5047: PPUSH
5048: LD_VAR 0 2
5052: PPUSH
5053: CALL_OW 183
// end ; end ;
5057: GO 5060
5059: POP
// end ;
5060: LD_VAR 0 3
5064: RET
// export function scs_find_barracks ( side ) ; var filter , i ; begin
5065: LD_INT 0
5067: PPUSH
5068: PPUSH
5069: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
5070: LD_ADDR_VAR 0 3
5074: PUSH
5075: LD_INT 22
5077: PUSH
5078: LD_VAR 0 1
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 2
5089: PUSH
5090: LD_INT 30
5092: PUSH
5093: LD_INT 4
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: PUSH
5100: LD_INT 30
5102: PUSH
5103: LD_INT 5
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 69
5123: ST_TO_ADDR
// if filter > 0 then
5124: LD_VAR 0 3
5128: PUSH
5129: LD_INT 0
5131: GREATER
5132: IFFALSE 5195
// for i = 1 to filter do
5134: LD_ADDR_VAR 0 4
5138: PUSH
5139: DOUBLE
5140: LD_INT 1
5142: DEC
5143: ST_TO_ADDR
5144: LD_VAR 0 3
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5193
// if UnitsInside ( filter [ i ] ) < 6 then
5152: LD_VAR 0 3
5156: PUSH
5157: LD_VAR 0 4
5161: ARRAY
5162: PPUSH
5163: CALL_OW 313
5167: PUSH
5168: LD_INT 6
5170: LESS
5171: IFFALSE 5191
// begin result := filter [ i ] ;
5173: LD_ADDR_VAR 0 2
5177: PUSH
5178: LD_VAR 0 3
5182: PUSH
5183: LD_VAR 0 4
5187: ARRAY
5188: ST_TO_ADDR
// break ;
5189: GO 5193
// end ;
5191: GO 5149
5193: POP
5194: POP
// end ;
5195: LD_VAR 0 2
5199: RET
// export function scs_find_lab ( side ) ; var filter , i ; begin
5200: LD_INT 0
5202: PPUSH
5203: PPUSH
5204: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ) ;
5205: LD_ADDR_VAR 0 3
5209: PUSH
5210: LD_INT 22
5212: PUSH
5213: LD_VAR 0 1
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PUSH
5222: LD_INT 2
5224: PUSH
5225: LD_INT 30
5227: PUSH
5228: LD_INT 6
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 8
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: LD_INT 30
5247: PUSH
5248: LD_INT 7
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: LIST
5259: LIST
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PPUSH
5265: CALL_OW 69
5269: ST_TO_ADDR
// if filter > 0 then
5270: LD_VAR 0 3
5274: PUSH
5275: LD_INT 0
5277: GREATER
5278: IFFALSE 5341
// for i = 1 to filter do
5280: LD_ADDR_VAR 0 4
5284: PUSH
5285: DOUBLE
5286: LD_INT 1
5288: DEC
5289: ST_TO_ADDR
5290: LD_VAR 0 3
5294: PUSH
5295: FOR_TO
5296: IFFALSE 5339
// if UnitsInside ( filter [ i ] ) < 6 then
5298: LD_VAR 0 3
5302: PUSH
5303: LD_VAR 0 4
5307: ARRAY
5308: PPUSH
5309: CALL_OW 313
5313: PUSH
5314: LD_INT 6
5316: LESS
5317: IFFALSE 5337
// begin result := filter [ i ] ;
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: LD_VAR 0 3
5328: PUSH
5329: LD_VAR 0 4
5333: ARRAY
5334: ST_TO_ADDR
// break ;
5335: GO 5339
// end ;
5337: GO 5295
5339: POP
5340: POP
// end ;
5341: LD_VAR 0 2
5345: RET
// export function scs_find_factory ( side ) ; var filter , i ; begin
5346: LD_INT 0
5348: PPUSH
5349: PPUSH
5350: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5351: LD_ADDR_VAR 0 3
5355: PUSH
5356: LD_INT 22
5358: PUSH
5359: LD_VAR 0 1
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: PUSH
5368: LD_INT 2
5370: PUSH
5371: LD_INT 30
5373: PUSH
5374: LD_INT 2
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: PUSH
5381: LD_INT 30
5383: PUSH
5384: LD_INT 3
5386: PUSH
5387: EMPTY
5388: LIST
5389: LIST
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: LIST
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 69
5404: ST_TO_ADDR
// if filter > 0 then
5405: LD_VAR 0 3
5409: PUSH
5410: LD_INT 0
5412: GREATER
5413: IFFALSE 5476
// for i = 1 to filter do
5415: LD_ADDR_VAR 0 4
5419: PUSH
5420: DOUBLE
5421: LD_INT 1
5423: DEC
5424: ST_TO_ADDR
5425: LD_VAR 0 3
5429: PUSH
5430: FOR_TO
5431: IFFALSE 5474
// if UnitsInside ( filter [ i ] ) < 6 then
5433: LD_VAR 0 3
5437: PUSH
5438: LD_VAR 0 4
5442: ARRAY
5443: PPUSH
5444: CALL_OW 313
5448: PUSH
5449: LD_INT 6
5451: LESS
5452: IFFALSE 5472
// begin result := filter [ i ] ;
5454: LD_ADDR_VAR 0 2
5458: PUSH
5459: LD_VAR 0 3
5463: PUSH
5464: LD_VAR 0 4
5468: ARRAY
5469: ST_TO_ADDR
// break ;
5470: GO 5474
// end ;
5472: GO 5430
5474: POP
5475: POP
// end ;
5476: LD_VAR 0 2
5480: RET
// export function scs_find_depot ( side ) ; var filter , i ; begin
5481: LD_INT 0
5483: PPUSH
5484: PPUSH
5485: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5486: LD_ADDR_VAR 0 3
5490: PUSH
5491: LD_INT 22
5493: PUSH
5494: LD_VAR 0 1
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PUSH
5503: LD_INT 2
5505: PUSH
5506: LD_INT 30
5508: PUSH
5509: LD_INT 0
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 30
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL_OW 69
5539: ST_TO_ADDR
// if filter > 0 then
5540: LD_VAR 0 3
5544: PUSH
5545: LD_INT 0
5547: GREATER
5548: IFFALSE 5611
// for i = 1 to filter do
5550: LD_ADDR_VAR 0 4
5554: PUSH
5555: DOUBLE
5556: LD_INT 1
5558: DEC
5559: ST_TO_ADDR
5560: LD_VAR 0 3
5564: PUSH
5565: FOR_TO
5566: IFFALSE 5609
// if UnitsInside ( filter [ i ] ) < 6 then
5568: LD_VAR 0 3
5572: PUSH
5573: LD_VAR 0 4
5577: ARRAY
5578: PPUSH
5579: CALL_OW 313
5583: PUSH
5584: LD_INT 6
5586: LESS
5587: IFFALSE 5607
// begin result := filter [ i ] ;
5589: LD_ADDR_VAR 0 2
5593: PUSH
5594: LD_VAR 0 3
5598: PUSH
5599: LD_VAR 0 4
5603: ARRAY
5604: ST_TO_ADDR
// break ;
5605: GO 5609
// end ;
5607: GO 5565
5609: POP
5610: POP
// end ;
5611: LD_VAR 0 2
5615: RET
// export function IsInTower ( unit ) ; var i , filter ; begin
5616: LD_INT 0
5618: PPUSH
5619: PPUSH
5620: PPUSH
// filter := FilterAllUnits ( [ [ f_side , GetSide ( unit ) ] , [ f_btype , b_bunker ] ] ) ;
5621: LD_ADDR_VAR 0 4
5625: PUSH
5626: LD_INT 22
5628: PUSH
5629: LD_VAR 0 1
5633: PPUSH
5634: CALL_OW 255
5638: PUSH
5639: EMPTY
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 30
5645: PUSH
5646: LD_INT 32
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: CALL_OW 69
5661: ST_TO_ADDR
// for i in filter do
5662: LD_ADDR_VAR 0 3
5666: PUSH
5667: LD_VAR 0 4
5671: PUSH
5672: FOR_IN
5673: IFFALSE 5712
// if unit in UnitsInside ( i ) then
5675: LD_VAR 0 1
5679: PUSH
5680: LD_VAR 0 3
5684: PPUSH
5685: CALL_OW 313
5689: IN
5690: IFFALSE 5702
// result := true else
5692: LD_ADDR_VAR 0 2
5696: PUSH
5697: LD_INT 1
5699: ST_TO_ADDR
5700: GO 5710
// result := false ;
5702: LD_ADDR_VAR 0 2
5706: PUSH
5707: LD_INT 0
5709: ST_TO_ADDR
5710: GO 5672
5712: POP
5713: POP
// end ;
5714: LD_VAR 0 2
5718: RET
// export function FillTowers ( side ) ; var filter , sold , sold_q , i ; begin
5719: LD_INT 0
5721: PPUSH
5722: PPUSH
5723: PPUSH
5724: PPUSH
5725: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
5726: LD_ADDR_VAR 0 3
5730: PUSH
5731: LD_INT 22
5733: PUSH
5734: LD_VAR 0 1
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: PUSH
5743: LD_INT 2
5745: PUSH
5746: LD_INT 30
5748: PUSH
5749: LD_INT 31
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 30
5758: PUSH
5759: LD_INT 32
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PPUSH
5775: CALL_OW 69
5779: ST_TO_ADDR
// sold := scs_scan_class ( side , 1 , true ) ;
5780: LD_ADDR_VAR 0 4
5784: PUSH
5785: LD_VAR 0 1
5789: PPUSH
5790: LD_INT 1
5792: PPUSH
5793: LD_INT 1
5795: PPUSH
5796: CALL 3391 0 3
5800: ST_TO_ADDR
// if UnitFilter ( filter , [ f_empty ] ) > 0 and sold then
5801: LD_VAR 0 3
5805: PPUSH
5806: LD_INT 58
5808: PUSH
5809: EMPTY
5810: LIST
5811: PPUSH
5812: CALL_OW 72
5816: PUSH
5817: LD_INT 0
5819: GREATER
5820: PUSH
5821: LD_VAR 0 4
5825: AND
5826: IFFALSE 5937
// for i = 1 to sold do
5828: LD_ADDR_VAR 0 6
5832: PUSH
5833: DOUBLE
5834: LD_INT 1
5836: DEC
5837: ST_TO_ADDR
5838: LD_VAR 0 4
5842: PUSH
5843: FOR_TO
5844: IFFALSE 5935
// if not IsInTower ( sold [ i ] ) then
5846: LD_VAR 0 4
5850: PUSH
5851: LD_VAR 0 6
5855: ARRAY
5856: PPUSH
5857: CALL 5616 0 1
5861: NOT
5862: IFFALSE 5933
// begin if IsInUnit ( sold [ i ] ) then
5864: LD_VAR 0 4
5868: PUSH
5869: LD_VAR 0 6
5873: ARRAY
5874: PPUSH
5875: CALL_OW 310
5879: IFFALSE 5896
// ComExitBuilding ( sold [ i ] ) ;
5881: LD_VAR 0 4
5885: PUSH
5886: LD_VAR 0 6
5890: ARRAY
5891: PPUSH
5892: CALL_OW 122
// ComEnterUnit ( sold [ i ] , UnitFilter ( filter , [ f_empty ] ) [ 1 ] ) ;
5896: LD_VAR 0 4
5900: PUSH
5901: LD_VAR 0 6
5905: ARRAY
5906: PPUSH
5907: LD_VAR 0 3
5911: PPUSH
5912: LD_INT 58
5914: PUSH
5915: EMPTY
5916: LIST
5917: PPUSH
5918: CALL_OW 72
5922: PUSH
5923: LD_INT 1
5925: ARRAY
5926: PPUSH
5927: CALL_OW 120
// break ;
5931: GO 5935
// end ;
5933: GO 5843
5935: POP
5936: POP
// end ;
5937: LD_VAR 0 2
5941: RET
// export function CanBExt ( side , ext ) ; begin
5942: LD_INT 0
5944: PPUSH
// case ext of b_ext_noncombat , b_ext_track :
5945: LD_VAR 0 2
5949: PUSH
5950: LD_INT 19
5952: DOUBLE
5953: EQUAL
5954: IFTRUE 5964
5956: LD_INT 16
5958: DOUBLE
5959: EQUAL
5960: IFTRUE 5964
5962: GO 5975
5964: POP
// result := true ; b_ext_gun :
5965: LD_ADDR_VAR 0 3
5969: PUSH
5970: LD_INT 1
5972: ST_TO_ADDR
5973: GO 6258
5975: LD_INT 17
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 6022
5983: POP
// if GetTech ( 39 , side ) = state_researched then
5984: LD_INT 39
5986: PPUSH
5987: LD_VAR 0 1
5991: PPUSH
5992: CALL_OW 321
5996: PUSH
5997: LD_INT 2
5999: EQUAL
6000: IFFALSE 6012
// result := true else
6002: LD_ADDR_VAR 0 3
6006: PUSH
6007: LD_INT 1
6009: ST_TO_ADDR
6010: GO 6020
// result := false ; b_ext_rocket :
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: ST_TO_ADDR
6020: GO 6258
6022: LD_INT 18
6024: DOUBLE
6025: EQUAL
6026: IFTRUE 6030
6028: GO 6069
6030: POP
// if GetTech ( 40 , side ) = state_researched then
6031: LD_INT 40
6033: PPUSH
6034: LD_VAR 0 1
6038: PPUSH
6039: CALL_OW 321
6043: PUSH
6044: LD_INT 2
6046: EQUAL
6047: IFFALSE 6059
// result := true else
6049: LD_ADDR_VAR 0 3
6053: PUSH
6054: LD_INT 1
6056: ST_TO_ADDR
6057: GO 6067
// result := false ; b_ext_laser :
6059: LD_ADDR_VAR 0 3
6063: PUSH
6064: LD_INT 0
6066: ST_TO_ADDR
6067: GO 6258
6069: LD_INT 25
6071: DOUBLE
6072: EQUAL
6073: IFTRUE 6077
6075: GO 6116
6077: POP
// if GetTech ( 10 , side ) = state_researched then
6078: LD_INT 10
6080: PPUSH
6081: LD_VAR 0 1
6085: PPUSH
6086: CALL_OW 321
6090: PUSH
6091: LD_INT 2
6093: EQUAL
6094: IFFALSE 6106
// result := true else
6096: LD_ADDR_VAR 0 3
6100: PUSH
6101: LD_INT 1
6103: ST_TO_ADDR
6104: GO 6114
// result := false ; b_ext_siberium :
6106: LD_ADDR_VAR 0 3
6110: PUSH
6111: LD_INT 0
6113: ST_TO_ADDR
6114: GO 6258
6116: LD_INT 21
6118: DOUBLE
6119: EQUAL
6120: IFTRUE 6124
6122: GO 6163
6124: POP
// if GetTech ( 21 , side ) = state_researched then
6125: LD_INT 21
6127: PPUSH
6128: LD_VAR 0 1
6132: PPUSH
6133: CALL_OW 321
6137: PUSH
6138: LD_INT 2
6140: EQUAL
6141: IFFALSE 6153
// result := true else
6143: LD_ADDR_VAR 0 3
6147: PUSH
6148: LD_INT 1
6150: ST_TO_ADDR
6151: GO 6161
// result := false ; b_ext_radar :
6153: LD_ADDR_VAR 0 3
6157: PUSH
6158: LD_INT 0
6160: ST_TO_ADDR
6161: GO 6258
6163: LD_INT 20
6165: DOUBLE
6166: EQUAL
6167: IFTRUE 6171
6169: GO 6210
6171: POP
// if GetTech ( 6 , side ) = state_researched then
6172: LD_INT 6
6174: PPUSH
6175: LD_VAR 0 1
6179: PPUSH
6180: CALL_OW 321
6184: PUSH
6185: LD_INT 2
6187: EQUAL
6188: IFFALSE 6200
// result := true else
6190: LD_ADDR_VAR 0 3
6194: PUSH
6195: LD_INT 1
6197: ST_TO_ADDR
6198: GO 6208
// result := false ; b_ext_radio :
6200: LD_ADDR_VAR 0 3
6204: PUSH
6205: LD_INT 0
6207: ST_TO_ADDR
6208: GO 6258
6210: LD_INT 22
6212: DOUBLE
6213: EQUAL
6214: IFTRUE 6218
6216: GO 6257
6218: POP
// if GetTech ( 15 , side ) = state_researched then
6219: LD_INT 15
6221: PPUSH
6222: LD_VAR 0 1
6226: PPUSH
6227: CALL_OW 321
6231: PUSH
6232: LD_INT 2
6234: EQUAL
6235: IFFALSE 6247
// result := true else
6237: LD_ADDR_VAR 0 3
6241: PUSH
6242: LD_INT 1
6244: ST_TO_ADDR
6245: GO 6255
// result := false ; end ;
6247: LD_ADDR_VAR 0 3
6251: PUSH
6252: LD_INT 0
6254: ST_TO_ADDR
6255: GO 6258
6257: POP
// end ; end_of_file
6258: LD_VAR 0 3
6262: RET
// every 0 0$01 trigger b1_act do var sol , eng , mech , sci , bazz , snip , mort , apeng , apsol , apkami , i , p , b , un , veh , bul , x , y , d , side , nation , area , people , skill , tech , lab , cr_dep , cr_lab , cr_fab , cr_ext , cr_pow , cr_tw , cr_br , cr_add , ally , enemy , skr , c , fac , filter , filter_c , x_a , x_b , x_c , x_d , x_e , x_f , x_g , x_h , x_j ;
6263: LD_EXP 1
6267: IFFALSE 11439
6269: GO 6271
6271: DISABLE
6272: LD_INT 0
6274: PPUSH
6275: PPUSH
6276: PPUSH
6277: PPUSH
6278: PPUSH
6279: PPUSH
6280: PPUSH
6281: PPUSH
6282: PPUSH
6283: PPUSH
6284: PPUSH
6285: PPUSH
6286: PPUSH
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
6291: PPUSH
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
6296: PPUSH
6297: PPUSH
6298: PPUSH
6299: PPUSH
6300: PPUSH
6301: PPUSH
6302: PPUSH
6303: PPUSH
6304: PPUSH
6305: PPUSH
6306: PPUSH
6307: PPUSH
6308: PPUSH
6309: PPUSH
6310: PPUSH
6311: PPUSH
6312: PPUSH
6313: PPUSH
6314: PPUSH
6315: PPUSH
6316: PPUSH
6317: PPUSH
6318: PPUSH
6319: PPUSH
6320: PPUSH
6321: PPUSH
6322: PPUSH
6323: PPUSH
// begin if scs_scan_side ( b1_side ) then
6324: LD_EXP 6
6328: PPUSH
6329: CALL 3299 0 1
6333: IFFALSE 6338
// enable else
6335: ENABLE
6336: GO 6339
// disable ;
6338: DISABLE
// if side = 0 then
6339: LD_VAR 0 20
6343: PUSH
6344: LD_INT 0
6346: EQUAL
6347: IFFALSE 6359
// side := b1_side ;
6349: LD_ADDR_VAR 0 20
6353: PUSH
6354: LD_EXP 6
6358: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
6359: LD_ADDR_VAR 0 36
6363: PUSH
6364: LD_INT 81
6366: PUSH
6367: LD_VAR 0 20
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PPUSH
6376: CALL_OW 69
6380: ST_TO_ADDR
// ally := FilterAllUnits ( [ f_ally , side ] ) diff scs_scan_side ( side ) ;
6381: LD_ADDR_VAR 0 35
6385: PUSH
6386: LD_INT 82
6388: PUSH
6389: LD_VAR 0 20
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: PPUSH
6398: CALL_OW 69
6402: PUSH
6403: LD_VAR 0 20
6407: PPUSH
6408: CALL 3299 0 1
6412: DIFF
6413: ST_TO_ADDR
// nation := b1_nation ;
6414: LD_ADDR_VAR 0 21
6418: PUSH
6419: LD_EXP 7
6423: ST_TO_ADDR
// area := b1_area ;
6424: LD_ADDR_VAR 0 22
6428: PUSH
6429: LD_EXP 8
6433: ST_TO_ADDR
// people := b1_people ;
6434: LD_ADDR_VAR 0 23
6438: PUSH
6439: LD_EXP 9
6443: ST_TO_ADDR
// skill := b1_skill ;
6444: LD_ADDR_VAR 0 24
6448: PUSH
6449: LD_EXP 10
6453: ST_TO_ADDR
// cr_dep := b1_cr_dep ;
6454: LD_ADDR_VAR 0 27
6458: PUSH
6459: LD_EXP 11
6463: ST_TO_ADDR
// cr_lab := b1_cr_lab ;
6464: LD_ADDR_VAR 0 28
6468: PUSH
6469: LD_EXP 12
6473: ST_TO_ADDR
// cr_fab := b1_cr_fab ;
6474: LD_ADDR_VAR 0 29
6478: PUSH
6479: LD_EXP 13
6483: ST_TO_ADDR
// cr_ext := b1_cr_ext ;
6484: LD_ADDR_VAR 0 30
6488: PUSH
6489: LD_EXP 14
6493: ST_TO_ADDR
// cr_pow := b1_cr_pow ;
6494: LD_ADDR_VAR 0 31
6498: PUSH
6499: LD_EXP 15
6503: ST_TO_ADDR
// cr_tw := b1_cr_tw ;
6504: LD_ADDR_VAR 0 32
6508: PUSH
6509: LD_EXP 16
6513: ST_TO_ADDR
// cr_br := b1_cr_br ;
6514: LD_ADDR_VAR 0 33
6518: PUSH
6519: LD_EXP 17
6523: ST_TO_ADDR
// cr_add := b1_cr_add ;
6524: LD_ADDR_VAR 0 34
6528: PUSH
6529: LD_EXP 18
6533: ST_TO_ADDR
// sol := scs_scan_class ( side , 1 , true ) ;
6534: LD_ADDR_VAR 0 1
6538: PUSH
6539: LD_VAR 0 20
6543: PPUSH
6544: LD_INT 1
6546: PPUSH
6547: LD_INT 1
6549: PPUSH
6550: CALL 3391 0 3
6554: ST_TO_ADDR
// eng := scs_scan_class ( side , 2 , true ) ;
6555: LD_ADDR_VAR 0 2
6559: PUSH
6560: LD_VAR 0 20
6564: PPUSH
6565: LD_INT 2
6567: PPUSH
6568: LD_INT 1
6570: PPUSH
6571: CALL 3391 0 3
6575: ST_TO_ADDR
// mech := scs_scan_class ( side , 3 , true ) ;
6576: LD_ADDR_VAR 0 3
6580: PUSH
6581: LD_VAR 0 20
6585: PPUSH
6586: LD_INT 3
6588: PPUSH
6589: LD_INT 1
6591: PPUSH
6592: CALL 3391 0 3
6596: ST_TO_ADDR
// sci := scs_scan_class ( side , 4 , true ) ;
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: LD_VAR 0 20
6606: PPUSH
6607: LD_INT 4
6609: PPUSH
6610: LD_INT 1
6612: PPUSH
6613: CALL 3391 0 3
6617: ST_TO_ADDR
// if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
6618: LD_VAR 0 20
6622: PPUSH
6623: LD_INT 0
6625: PPUSH
6626: CALL 1891 0 2
6630: PUSH
6631: LD_VAR 0 20
6635: PPUSH
6636: LD_INT 1
6638: PPUSH
6639: CALL 1891 0 2
6643: OR
6644: IFFALSE 8920
// begin if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 20 ) then
6646: LD_VAR 0 20
6650: PPUSH
6651: LD_VAR 0 27
6655: PUSH
6656: LD_INT 1
6658: ARRAY
6659: PPUSH
6660: LD_VAR 0 27
6664: PUSH
6665: LD_INT 2
6667: ARRAY
6668: PPUSH
6669: LD_INT 20
6671: PPUSH
6672: CALL 3547 0 4
6676: IFFALSE 6682
// exit else
6678: GO 11439
6680: GO 8123
// begin x_a := cr_br / 3 ;
6682: LD_ADDR_VAR 0 42
6686: PUSH
6687: LD_VAR 0 33
6691: PUSH
6692: LD_INT 3
6694: DIVREAL
6695: ST_TO_ADDR
// if scs_scan_buildings ( side , b_armoury ) ^ scs_scan_buildings ( side , b_barracks ) < ( x_a - 1 ) then
6696: LD_VAR 0 20
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL 3707 0 2
6708: PUSH
6709: LD_VAR 0 20
6713: PPUSH
6714: LD_INT 5
6716: PPUSH
6717: CALL 3707 0 2
6721: ADD
6722: PUSH
6723: LD_VAR 0 42
6727: PUSH
6728: LD_INT 1
6730: MINUS
6731: LESS
6732: IFFALSE 6948
// begin if HexInfo ( cr_br [ 1 ] , cr_br [ 2 ] ) = 0 then
6734: LD_VAR 0 33
6738: PUSH
6739: LD_INT 1
6741: ARRAY
6742: PPUSH
6743: LD_VAR 0 33
6747: PUSH
6748: LD_INT 2
6750: ARRAY
6751: PPUSH
6752: CALL_OW 428
6756: PUSH
6757: LD_INT 0
6759: EQUAL
6760: IFFALSE 6806
// Build ( eng , b_armoury , cr_br [ 1 ] , cr_br [ 2 ] , cr_br [ 3 ] , 30 ) else
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 4
6769: PPUSH
6770: LD_VAR 0 33
6774: PUSH
6775: LD_INT 1
6777: ARRAY
6778: PPUSH
6779: LD_VAR 0 33
6783: PUSH
6784: LD_INT 2
6786: ARRAY
6787: PPUSH
6788: LD_VAR 0 33
6792: PUSH
6793: LD_INT 3
6795: ARRAY
6796: PPUSH
6797: LD_INT 30
6799: PPUSH
6800: CALL 3841 0 6
6804: GO 6948
// if HexInfo ( cr_br [ 4 ] , cr_br [ 5 ] ) = 0 then
6806: LD_VAR 0 33
6810: PUSH
6811: LD_INT 4
6813: ARRAY
6814: PPUSH
6815: LD_VAR 0 33
6819: PUSH
6820: LD_INT 5
6822: ARRAY
6823: PPUSH
6824: CALL_OW 428
6828: PUSH
6829: LD_INT 0
6831: EQUAL
6832: IFFALSE 6878
// Build ( eng , b_armoury , cr_br [ 4 ] , cr_br [ 5 ] , cr_br [ 6 ] , 30 ) else
6834: LD_VAR 0 2
6838: PPUSH
6839: LD_INT 4
6841: PPUSH
6842: LD_VAR 0 33
6846: PUSH
6847: LD_INT 4
6849: ARRAY
6850: PPUSH
6851: LD_VAR 0 33
6855: PUSH
6856: LD_INT 5
6858: ARRAY
6859: PPUSH
6860: LD_VAR 0 33
6864: PUSH
6865: LD_INT 6
6867: ARRAY
6868: PPUSH
6869: LD_INT 30
6871: PPUSH
6872: CALL 3841 0 6
6876: GO 6948
// if HexInfo ( cr_br [ 7 ] , cr_br [ 8 ] ) = 0 then
6878: LD_VAR 0 33
6882: PUSH
6883: LD_INT 7
6885: ARRAY
6886: PPUSH
6887: LD_VAR 0 33
6891: PUSH
6892: LD_INT 8
6894: ARRAY
6895: PPUSH
6896: CALL_OW 428
6900: PUSH
6901: LD_INT 0
6903: EQUAL
6904: IFFALSE 6948
// Build ( eng , b_armoury , cr_br [ 7 ] , cr_br [ 8 ] , cr_br [ 9 ] , 30 ) ;
6906: LD_VAR 0 2
6910: PPUSH
6911: LD_INT 4
6913: PPUSH
6914: LD_VAR 0 33
6918: PUSH
6919: LD_INT 7
6921: ARRAY
6922: PPUSH
6923: LD_VAR 0 33
6927: PUSH
6928: LD_INT 8
6930: ARRAY
6931: PPUSH
6932: LD_VAR 0 33
6936: PUSH
6937: LD_INT 9
6939: ARRAY
6940: PPUSH
6941: LD_INT 30
6943: PPUSH
6944: CALL 3841 0 6
// end ; if AnyBuildingExist ( side , b_armoury ) then
6948: LD_VAR 0 20
6952: PPUSH
6953: LD_INT 4
6955: PPUSH
6956: CALL 1891 0 2
6960: IFFALSE 6977
// Upgrade ( side , b_armoury , 30 ) ;
6962: LD_VAR 0 20
6966: PPUSH
6967: LD_INT 4
6969: PPUSH
6970: LD_INT 30
6972: PPUSH
6973: CALL 4039 0 3
// x_b := ( cr_lab ) / 5 ;
6977: LD_ADDR_VAR 0 43
6981: PUSH
6982: LD_VAR 0 28
6986: PUSH
6987: LD_INT 5
6989: DIVREAL
6990: ST_TO_ADDR
// if scs_scan_lab ( side ) < ( x_b - 1 ) then
6991: LD_VAR 0 20
6995: PPUSH
6996: CALL 3634 0 1
7000: PUSH
7001: LD_VAR 0 43
7005: PUSH
7006: LD_INT 1
7008: MINUS
7009: LESS
7010: IFFALSE 7226
// begin if HexInfo ( cr_lab [ 1 ] , cr_lab [ 2 ] ) = 0 then
7012: LD_VAR 0 28
7016: PUSH
7017: LD_INT 1
7019: ARRAY
7020: PPUSH
7021: LD_VAR 0 28
7025: PUSH
7026: LD_INT 2
7028: ARRAY
7029: PPUSH
7030: CALL_OW 428
7034: PUSH
7035: LD_INT 0
7037: EQUAL
7038: IFFALSE 7084
// Build ( eng , b_lab , cr_lab [ 1 ] , cr_lab [ 2 ] , cr_lab [ 3 ] , 20 ) else
7040: LD_VAR 0 2
7044: PPUSH
7045: LD_INT 6
7047: PPUSH
7048: LD_VAR 0 28
7052: PUSH
7053: LD_INT 1
7055: ARRAY
7056: PPUSH
7057: LD_VAR 0 28
7061: PUSH
7062: LD_INT 2
7064: ARRAY
7065: PPUSH
7066: LD_VAR 0 28
7070: PUSH
7071: LD_INT 3
7073: ARRAY
7074: PPUSH
7075: LD_INT 20
7077: PPUSH
7078: CALL 3841 0 6
7082: GO 7226
// if HexInfo ( cr_lab [ 6 ] , cr_lab [ 7 ] ) = 0 then
7084: LD_VAR 0 28
7088: PUSH
7089: LD_INT 6
7091: ARRAY
7092: PPUSH
7093: LD_VAR 0 28
7097: PUSH
7098: LD_INT 7
7100: ARRAY
7101: PPUSH
7102: CALL_OW 428
7106: PUSH
7107: LD_INT 0
7109: EQUAL
7110: IFFALSE 7156
// Build ( eng , b_lab , cr_lab [ 6 ] , cr_lab [ 7 ] , cr_lab [ 8 ] , 20 ) else
7112: LD_VAR 0 2
7116: PPUSH
7117: LD_INT 6
7119: PPUSH
7120: LD_VAR 0 28
7124: PUSH
7125: LD_INT 6
7127: ARRAY
7128: PPUSH
7129: LD_VAR 0 28
7133: PUSH
7134: LD_INT 7
7136: ARRAY
7137: PPUSH
7138: LD_VAR 0 28
7142: PUSH
7143: LD_INT 8
7145: ARRAY
7146: PPUSH
7147: LD_INT 20
7149: PPUSH
7150: CALL 3841 0 6
7154: GO 7226
// if HexInfo ( cr_lab [ 11 ] , cr_lab [ 12 ] ) = 0 then
7156: LD_VAR 0 28
7160: PUSH
7161: LD_INT 11
7163: ARRAY
7164: PPUSH
7165: LD_VAR 0 28
7169: PUSH
7170: LD_INT 12
7172: ARRAY
7173: PPUSH
7174: CALL_OW 428
7178: PUSH
7179: LD_INT 0
7181: EQUAL
7182: IFFALSE 7226
// Build ( eng , b_lab , cr_lab [ 11 ] , cr_lab [ 12 ] , cr_lab [ 13 ] , 20 ) ;
7184: LD_VAR 0 2
7188: PPUSH
7189: LD_INT 6
7191: PPUSH
7192: LD_VAR 0 28
7196: PUSH
7197: LD_INT 11
7199: ARRAY
7200: PPUSH
7201: LD_VAR 0 28
7205: PUSH
7206: LD_INT 12
7208: ARRAY
7209: PPUSH
7210: LD_VAR 0 28
7214: PUSH
7215: LD_INT 13
7217: ARRAY
7218: PPUSH
7219: LD_INT 20
7221: PPUSH
7222: CALL 3841 0 6
// end ; if scs_scan_lab ( side ) = 2 then
7226: LD_VAR 0 20
7230: PPUSH
7231: CALL 3634 0 1
7235: PUSH
7236: LD_INT 2
7238: EQUAL
7239: IFFALSE 7505
// begin if scs_scan_buildings ( side , 6 ) <= 2 and scs_scan_buildings ( side , 7 ) = 0 then
7241: LD_VAR 0 20
7245: PPUSH
7246: LD_INT 6
7248: PPUSH
7249: CALL 3707 0 2
7253: PUSH
7254: LD_INT 2
7256: LESSEQUAL
7257: PUSH
7258: LD_VAR 0 20
7262: PPUSH
7263: LD_INT 7
7265: PPUSH
7266: CALL 3707 0 2
7270: PUSH
7271: LD_INT 0
7273: EQUAL
7274: AND
7275: IFFALSE 7307
// UpgradeLab ( scs_scan_lab ( side ) [ 1 ] , cr_lab [ 4 ] , 50 ) ;
7277: LD_VAR 0 20
7281: PPUSH
7282: CALL 3634 0 1
7286: PUSH
7287: LD_INT 1
7289: ARRAY
7290: PPUSH
7291: LD_VAR 0 28
7295: PUSH
7296: LD_INT 4
7298: ARRAY
7299: PPUSH
7300: LD_INT 50
7302: PPUSH
7303: CALL 4187 0 3
// if scs_scan_buildings ( side , 6 ) = 1 and scs_scan_buildings ( side , 7 ) = 1 then
7307: LD_VAR 0 20
7311: PPUSH
7312: LD_INT 6
7314: PPUSH
7315: CALL 3707 0 2
7319: PUSH
7320: LD_INT 1
7322: EQUAL
7323: PUSH
7324: LD_VAR 0 20
7328: PPUSH
7329: LD_INT 7
7331: PPUSH
7332: CALL 3707 0 2
7336: PUSH
7337: LD_INT 1
7339: EQUAL
7340: AND
7341: IFFALSE 7373
// UpgradeLab ( scs_scan_lab ( side ) [ 2 ] , cr_lab [ 9 ] , 20 ) ;
7343: LD_VAR 0 20
7347: PPUSH
7348: CALL 3634 0 1
7352: PUSH
7353: LD_INT 2
7355: ARRAY
7356: PPUSH
7357: LD_VAR 0 28
7361: PUSH
7362: LD_INT 9
7364: ARRAY
7365: PPUSH
7366: LD_INT 20
7368: PPUSH
7369: CALL 4187 0 3
// if scs_scan_buildings ( side , 7 ) = 1 and scs_scan_buildings ( side , 8 ) = 0 then
7373: LD_VAR 0 20
7377: PPUSH
7378: LD_INT 7
7380: PPUSH
7381: CALL 3707 0 2
7385: PUSH
7386: LD_INT 1
7388: EQUAL
7389: PUSH
7390: LD_VAR 0 20
7394: PPUSH
7395: LD_INT 8
7397: PPUSH
7398: CALL 3707 0 2
7402: PUSH
7403: LD_INT 0
7405: EQUAL
7406: AND
7407: IFFALSE 7439
// UpgradeLab ( scs_scan_lab ( side ) [ 1 ] , cr_lab [ 5 ] , 20 ) ;
7409: LD_VAR 0 20
7413: PPUSH
7414: CALL 3634 0 1
7418: PUSH
7419: LD_INT 1
7421: ARRAY
7422: PPUSH
7423: LD_VAR 0 28
7427: PUSH
7428: LD_INT 5
7430: ARRAY
7431: PPUSH
7432: LD_INT 20
7434: PPUSH
7435: CALL 4187 0 3
// if scs_scan_buildings ( side , 7 ) = 1 and scs_scan_buildings ( side , 8 ) = 1 then
7439: LD_VAR 0 20
7443: PPUSH
7444: LD_INT 7
7446: PPUSH
7447: CALL 3707 0 2
7451: PUSH
7452: LD_INT 1
7454: EQUAL
7455: PUSH
7456: LD_VAR 0 20
7460: PPUSH
7461: LD_INT 8
7463: PPUSH
7464: CALL 3707 0 2
7468: PUSH
7469: LD_INT 1
7471: EQUAL
7472: AND
7473: IFFALSE 7505
// UpgradeLab ( scs_scan_lab ( side ) [ 2 ] , cr_lab [ 10 ] , 20 ) ;
7475: LD_VAR 0 20
7479: PPUSH
7480: CALL 3634 0 1
7484: PUSH
7485: LD_INT 2
7487: ARRAY
7488: PPUSH
7489: LD_VAR 0 28
7493: PUSH
7494: LD_INT 10
7496: ARRAY
7497: PPUSH
7498: LD_INT 20
7500: PPUSH
7501: CALL 4187 0 3
// end ; x_c := cr_pow / 4 ;
7505: LD_ADDR_VAR 0 44
7509: PUSH
7510: LD_VAR 0 31
7514: PUSH
7515: LD_INT 4
7517: DIVREAL
7518: ST_TO_ADDR
// if scs_scan_buildings ( side , b_solar_power ) + scs_scan_buildings ( side , b_oil_power ) + scs_scan_buildings ( side , b_siberite_power ) < ( x_c - 1 ) then
7519: LD_VAR 0 20
7523: PPUSH
7524: LD_INT 27
7526: PPUSH
7527: CALL 3707 0 2
7531: PUSH
7532: LD_VAR 0 20
7536: PPUSH
7537: LD_INT 26
7539: PPUSH
7540: CALL 3707 0 2
7544: PLUS
7545: PUSH
7546: LD_VAR 0 20
7550: PPUSH
7551: LD_INT 28
7553: PPUSH
7554: CALL 3707 0 2
7558: PLUS
7559: PUSH
7560: LD_VAR 0 44
7564: PUSH
7565: LD_INT 1
7567: MINUS
7568: LESS
7569: IFFALSE 7691
// begin if HexInfo ( cr_pow [ 1 ] , cr_pow [ 2 ] ) = 0 then
7571: LD_VAR 0 31
7575: PUSH
7576: LD_INT 1
7578: ARRAY
7579: PPUSH
7580: LD_VAR 0 31
7584: PUSH
7585: LD_INT 2
7587: ARRAY
7588: PPUSH
7589: CALL_OW 428
7593: PUSH
7594: LD_INT 0
7596: EQUAL
7597: IFFALSE 7646
// BuildPowerPlant ( eng , cr_pow [ 4 ] , cr_pow [ 1 ] , cr_pow [ 2 ] , cr_pow [ 3 ] ) else
7599: LD_VAR 0 2
7603: PPUSH
7604: LD_VAR 0 31
7608: PUSH
7609: LD_INT 4
7611: ARRAY
7612: PPUSH
7613: LD_VAR 0 31
7617: PUSH
7618: LD_INT 1
7620: ARRAY
7621: PPUSH
7622: LD_VAR 0 31
7626: PUSH
7627: LD_INT 2
7629: ARRAY
7630: PPUSH
7631: LD_VAR 0 31
7635: PUSH
7636: LD_INT 3
7638: ARRAY
7639: PPUSH
7640: CALL 4301 0 5
7644: GO 7691
// BuildPowerPlant ( eng , cr_pow [ 8 ] , cr_pow [ 5 ] , cr_pow [ 6 ] , cr_pow [ 7 ] ) ;
7646: LD_VAR 0 2
7650: PPUSH
7651: LD_VAR 0 31
7655: PUSH
7656: LD_INT 8
7658: ARRAY
7659: PPUSH
7660: LD_VAR 0 31
7664: PUSH
7665: LD_INT 5
7667: ARRAY
7668: PPUSH
7669: LD_VAR 0 31
7673: PUSH
7674: LD_INT 6
7676: ARRAY
7677: PPUSH
7678: LD_VAR 0 31
7682: PUSH
7683: LD_INT 7
7685: ARRAY
7686: PPUSH
7687: CALL 4301 0 5
// end ; x_d := ( cr_add / 3 ) / 2 ;
7691: LD_ADDR_VAR 0 45
7695: PUSH
7696: LD_VAR 0 34
7700: PUSH
7701: LD_INT 3
7703: DIVREAL
7704: PUSH
7705: LD_INT 2
7707: DIVREAL
7708: ST_TO_ADDR
// if super_source = false then
7709: LD_EXP 71
7713: PUSH
7714: LD_INT 0
7716: EQUAL
7717: IFFALSE 7733
// x_d := x_d - 1 ;
7719: LD_ADDR_VAR 0 45
7723: PUSH
7724: LD_VAR 0 45
7728: PUSH
7729: LD_INT 1
7731: MINUS
7732: ST_TO_ADDR
// if scs_scan_buildings ( side , b_oil_mine ) < x_d then
7733: LD_VAR 0 20
7737: PPUSH
7738: LD_INT 29
7740: PPUSH
7741: CALL 3707 0 2
7745: PUSH
7746: LD_VAR 0 45
7750: LESS
7751: IFFALSE 8123
// begin if GetResourceVisibility ( cr_add [ 1 ] , cr_add [ 2 ] , side ) = false then
7753: LD_VAR 0 34
7757: PUSH
7758: LD_INT 1
7760: ARRAY
7761: PPUSH
7762: LD_VAR 0 34
7766: PUSH
7767: LD_INT 2
7769: ARRAY
7770: PPUSH
7771: LD_VAR 0 20
7775: PPUSH
7776: CALL_OW 440
7780: PUSH
7781: LD_INT 0
7783: EQUAL
7784: IFFALSE 7863
// begin if IsInUnit ( sci [ 1 ] ) then
7786: LD_VAR 0 4
7790: PUSH
7791: LD_INT 1
7793: ARRAY
7794: PPUSH
7795: CALL_OW 310
7799: IFFALSE 7814
// ComExitBuilding ( sci [ 1 ] ) ;
7801: LD_VAR 0 4
7805: PUSH
7806: LD_INT 1
7808: ARRAY
7809: PPUSH
7810: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
7814: LD_VAR 0 4
7818: PUSH
7819: LD_INT 1
7821: ARRAY
7822: PPUSH
7823: CALL_OW 314
7827: NOT
7828: IFFALSE 7861
// ComMoveXY ( sci [ 1 ] , cr_add [ 1 ] , cr_add [ 2 ] ) ;
7830: LD_VAR 0 4
7834: PUSH
7835: LD_INT 1
7837: ARRAY
7838: PPUSH
7839: LD_VAR 0 34
7843: PUSH
7844: LD_INT 1
7846: ARRAY
7847: PPUSH
7848: LD_VAR 0 34
7852: PUSH
7853: LD_INT 2
7855: ARRAY
7856: PPUSH
7857: CALL_OW 111
// end else
7861: GO 7935
// begin if HexInfo ( cr_add [ 1 ] , cr_add [ 2 ] ) = 0 then
7863: LD_VAR 0 34
7867: PUSH
7868: LD_INT 1
7870: ARRAY
7871: PPUSH
7872: LD_VAR 0 34
7876: PUSH
7877: LD_INT 2
7879: ARRAY
7880: PPUSH
7881: CALL_OW 428
7885: PUSH
7886: LD_INT 0
7888: EQUAL
7889: IFFALSE 7935
// Build ( eng , b_oil_mine , cr_add [ 1 ] , cr_add [ 2 ] , Rand ( 0 , 5 ) , 10 ) ;
7891: LD_VAR 0 2
7895: PPUSH
7896: LD_INT 29
7898: PPUSH
7899: LD_VAR 0 34
7903: PUSH
7904: LD_INT 1
7906: ARRAY
7907: PPUSH
7908: LD_VAR 0 34
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PPUSH
7917: LD_INT 0
7919: PPUSH
7920: LD_INT 5
7922: PPUSH
7923: CALL_OW 12
7927: PPUSH
7928: LD_INT 10
7930: PPUSH
7931: CALL 3841 0 6
// end ; if GetResourceVisibility ( cr_add [ 4 ] , cr_add [ 5 ] , side ) = false and super_source then
7935: LD_VAR 0 34
7939: PUSH
7940: LD_INT 4
7942: ARRAY
7943: PPUSH
7944: LD_VAR 0 34
7948: PUSH
7949: LD_INT 5
7951: ARRAY
7952: PPUSH
7953: LD_VAR 0 20
7957: PPUSH
7958: CALL_OW 440
7962: PUSH
7963: LD_INT 0
7965: EQUAL
7966: PUSH
7967: LD_EXP 71
7971: AND
7972: IFFALSE 8051
// begin if IsInUnit ( sci [ 1 ] ) then
7974: LD_VAR 0 4
7978: PUSH
7979: LD_INT 1
7981: ARRAY
7982: PPUSH
7983: CALL_OW 310
7987: IFFALSE 8002
// ComExitBuilding ( sci [ 1 ] ) ;
7989: LD_VAR 0 4
7993: PUSH
7994: LD_INT 1
7996: ARRAY
7997: PPUSH
7998: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
8002: LD_VAR 0 4
8006: PUSH
8007: LD_INT 1
8009: ARRAY
8010: PPUSH
8011: CALL_OW 314
8015: NOT
8016: IFFALSE 8049
// ComMoveXY ( sci [ 1 ] , cr_add [ 4 ] , cr_add [ 5 ] ) ;
8018: LD_VAR 0 4
8022: PUSH
8023: LD_INT 1
8025: ARRAY
8026: PPUSH
8027: LD_VAR 0 34
8031: PUSH
8032: LD_INT 4
8034: ARRAY
8035: PPUSH
8036: LD_VAR 0 34
8040: PUSH
8041: LD_INT 5
8043: ARRAY
8044: PPUSH
8045: CALL_OW 111
// end else
8049: GO 8123
// begin if HexInfo ( cr_add [ 4 ] , cr_add [ 5 ] ) = 0 then
8051: LD_VAR 0 34
8055: PUSH
8056: LD_INT 4
8058: ARRAY
8059: PPUSH
8060: LD_VAR 0 34
8064: PUSH
8065: LD_INT 5
8067: ARRAY
8068: PPUSH
8069: CALL_OW 428
8073: PUSH
8074: LD_INT 0
8076: EQUAL
8077: IFFALSE 8123
// Build ( eng , b_oil_mine , cr_add [ 4 ] , cr_add [ 5 ] , Rand ( 0 , 5 ) , 10 ) ;
8079: LD_VAR 0 2
8083: PPUSH
8084: LD_INT 29
8086: PPUSH
8087: LD_VAR 0 34
8091: PUSH
8092: LD_INT 4
8094: ARRAY
8095: PPUSH
8096: LD_VAR 0 34
8100: PUSH
8101: LD_INT 5
8103: ARRAY
8104: PPUSH
8105: LD_INT 0
8107: PPUSH
8108: LD_INT 5
8110: PPUSH
8111: CALL_OW 12
8115: PPUSH
8116: LD_INT 10
8118: PPUSH
8119: CALL 3841 0 6
// end ; end ; end ; if scs_scan_buildings ( side , b_siberite_mine ) < x_d and GetTech ( 20 , side ) = state_researched then
8123: LD_VAR 0 20
8127: PPUSH
8128: LD_INT 30
8130: PPUSH
8131: CALL 3707 0 2
8135: PUSH
8136: LD_VAR 0 45
8140: LESS
8141: PUSH
8142: LD_INT 20
8144: PPUSH
8145: LD_VAR 0 20
8149: PPUSH
8150: CALL_OW 321
8154: PUSH
8155: LD_INT 2
8157: EQUAL
8158: AND
8159: IFFALSE 8531
// begin if GetResourceVisibility ( cr_add [ 7 ] , cr_add [ 8 ] , side ) = false then
8161: LD_VAR 0 34
8165: PUSH
8166: LD_INT 7
8168: ARRAY
8169: PPUSH
8170: LD_VAR 0 34
8174: PUSH
8175: LD_INT 8
8177: ARRAY
8178: PPUSH
8179: LD_VAR 0 20
8183: PPUSH
8184: CALL_OW 440
8188: PUSH
8189: LD_INT 0
8191: EQUAL
8192: IFFALSE 8271
// begin if IsInUnit ( sci [ 1 ] ) then
8194: LD_VAR 0 4
8198: PUSH
8199: LD_INT 1
8201: ARRAY
8202: PPUSH
8203: CALL_OW 310
8207: IFFALSE 8222
// ComExitBuilding ( sci [ 1 ] ) ;
8209: LD_VAR 0 4
8213: PUSH
8214: LD_INT 1
8216: ARRAY
8217: PPUSH
8218: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
8222: LD_VAR 0 4
8226: PUSH
8227: LD_INT 1
8229: ARRAY
8230: PPUSH
8231: CALL_OW 314
8235: NOT
8236: IFFALSE 8269
// ComMoveXY ( sci [ 1 ] , cr_add [ 7 ] , cr_add [ 8 ] ) ;
8238: LD_VAR 0 4
8242: PUSH
8243: LD_INT 1
8245: ARRAY
8246: PPUSH
8247: LD_VAR 0 34
8251: PUSH
8252: LD_INT 7
8254: ARRAY
8255: PPUSH
8256: LD_VAR 0 34
8260: PUSH
8261: LD_INT 8
8263: ARRAY
8264: PPUSH
8265: CALL_OW 111
// end else
8269: GO 8343
// begin if HexInfo ( cr_add [ 7 ] , cr_add [ 8 ] ) = 0 then
8271: LD_VAR 0 34
8275: PUSH
8276: LD_INT 7
8278: ARRAY
8279: PPUSH
8280: LD_VAR 0 34
8284: PUSH
8285: LD_INT 8
8287: ARRAY
8288: PPUSH
8289: CALL_OW 428
8293: PUSH
8294: LD_INT 0
8296: EQUAL
8297: IFFALSE 8343
// Build ( eng , b_siberite_mine , cr_add [ 7 ] , cr_add [ 8 ] , Rand ( 0 , 5 ) , 10 ) ;
8299: LD_VAR 0 2
8303: PPUSH
8304: LD_INT 30
8306: PPUSH
8307: LD_VAR 0 34
8311: PUSH
8312: LD_INT 7
8314: ARRAY
8315: PPUSH
8316: LD_VAR 0 34
8320: PUSH
8321: LD_INT 8
8323: ARRAY
8324: PPUSH
8325: LD_INT 0
8327: PPUSH
8328: LD_INT 5
8330: PPUSH
8331: CALL_OW 12
8335: PPUSH
8336: LD_INT 10
8338: PPUSH
8339: CALL 3841 0 6
// end ; if GetResourceVisibility ( cr_add [ 10 ] , cr_add [ 11 ] , side ) = false and super_source then
8343: LD_VAR 0 34
8347: PUSH
8348: LD_INT 10
8350: ARRAY
8351: PPUSH
8352: LD_VAR 0 34
8356: PUSH
8357: LD_INT 11
8359: ARRAY
8360: PPUSH
8361: LD_VAR 0 20
8365: PPUSH
8366: CALL_OW 440
8370: PUSH
8371: LD_INT 0
8373: EQUAL
8374: PUSH
8375: LD_EXP 71
8379: AND
8380: IFFALSE 8459
// begin if IsInUnit ( sci [ 1 ] ) then
8382: LD_VAR 0 4
8386: PUSH
8387: LD_INT 1
8389: ARRAY
8390: PPUSH
8391: CALL_OW 310
8395: IFFALSE 8410
// ComExitBuilding ( sci [ 1 ] ) ;
8397: LD_VAR 0 4
8401: PUSH
8402: LD_INT 1
8404: ARRAY
8405: PPUSH
8406: CALL_OW 122
// if not HasTask ( sci [ 1 ] ) then
8410: LD_VAR 0 4
8414: PUSH
8415: LD_INT 1
8417: ARRAY
8418: PPUSH
8419: CALL_OW 314
8423: NOT
8424: IFFALSE 8457
// ComMoveXY ( sci [ 1 ] , cr_add [ 10 ] , cr_add [ 11 ] ) ;
8426: LD_VAR 0 4
8430: PUSH
8431: LD_INT 1
8433: ARRAY
8434: PPUSH
8435: LD_VAR 0 34
8439: PUSH
8440: LD_INT 10
8442: ARRAY
8443: PPUSH
8444: LD_VAR 0 34
8448: PUSH
8449: LD_INT 11
8451: ARRAY
8452: PPUSH
8453: CALL_OW 111
// end else
8457: GO 8531
// begin if HexInfo ( cr_add [ 10 ] , cr_add [ 11 ] ) = 0 then
8459: LD_VAR 0 34
8463: PUSH
8464: LD_INT 10
8466: ARRAY
8467: PPUSH
8468: LD_VAR 0 34
8472: PUSH
8473: LD_INT 11
8475: ARRAY
8476: PPUSH
8477: CALL_OW 428
8481: PUSH
8482: LD_INT 0
8484: EQUAL
8485: IFFALSE 8531
// Build ( eng , b_siberite_mine , cr_add [ 10 ] , cr_add [ 11 ] , Rand ( 0 , 5 ) , 10 ) ;
8487: LD_VAR 0 2
8491: PPUSH
8492: LD_INT 30
8494: PPUSH
8495: LD_VAR 0 34
8499: PUSH
8500: LD_INT 10
8502: ARRAY
8503: PPUSH
8504: LD_VAR 0 34
8508: PUSH
8509: LD_INT 11
8511: ARRAY
8512: PPUSH
8513: LD_INT 0
8515: PPUSH
8516: LD_INT 5
8518: PPUSH
8519: CALL_OW 12
8523: PPUSH
8524: LD_INT 10
8526: PPUSH
8527: CALL 3841 0 6
// end ; end ; if AnyBuildingExist ( side , b_workshop ) = false and AnyBuildingExist ( side , b_factory ) = false then
8531: LD_VAR 0 20
8535: PPUSH
8536: LD_INT 2
8538: PPUSH
8539: CALL 1891 0 2
8543: PUSH
8544: LD_INT 0
8546: EQUAL
8547: PUSH
8548: LD_VAR 0 20
8552: PPUSH
8553: LD_INT 3
8555: PPUSH
8556: CALL 1891 0 2
8560: PUSH
8561: LD_INT 0
8563: EQUAL
8564: AND
8565: IFFALSE 8637
// begin if HexInfo ( cr_fab [ 1 ] , cr_fab [ 2 ] ) = 0 then
8567: LD_VAR 0 29
8571: PUSH
8572: LD_INT 1
8574: ARRAY
8575: PPUSH
8576: LD_VAR 0 29
8580: PUSH
8581: LD_INT 2
8583: ARRAY
8584: PPUSH
8585: CALL_OW 428
8589: PUSH
8590: LD_INT 0
8592: EQUAL
8593: IFFALSE 8637
// Build ( eng , b_workshop , cr_fab [ 1 ] , cr_fab [ 2 ] , cr_fab [ 3 ] , 40 ) ;
8595: LD_VAR 0 2
8599: PPUSH
8600: LD_INT 2
8602: PPUSH
8603: LD_VAR 0 29
8607: PUSH
8608: LD_INT 1
8610: ARRAY
8611: PPUSH
8612: LD_VAR 0 29
8616: PUSH
8617: LD_INT 2
8619: ARRAY
8620: PPUSH
8621: LD_VAR 0 29
8625: PUSH
8626: LD_INT 3
8628: ARRAY
8629: PPUSH
8630: LD_INT 40
8632: PPUSH
8633: CALL 3841 0 6
// end ; if AnyBuildingExist ( side , b_workshop ) then
8637: LD_VAR 0 20
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL 1891 0 2
8649: IFFALSE 8666
// Upgrade ( side , b_workshop , 40 ) ;
8651: LD_VAR 0 20
8655: PPUSH
8656: LD_INT 2
8658: PPUSH
8659: LD_INT 40
8661: PPUSH
8662: CALL 4039 0 3
// if AnyBuildingExist ( side , b_factory ) then
8666: LD_VAR 0 20
8670: PPUSH
8671: LD_INT 3
8673: PPUSH
8674: CALL 1891 0 2
8678: IFFALSE 8918
// begin fac := scs_scan_buildings ( side , b_factory ) [ 1 ] ;
8680: LD_ADDR_VAR 0 39
8684: PUSH
8685: LD_VAR 0 20
8689: PPUSH
8690: LD_INT 3
8692: PPUSH
8693: CALL 3707 0 2
8697: PUSH
8698: LD_INT 1
8700: ARRAY
8701: ST_TO_ADDR
// if AnyBuildingExist ( side , cr_ext [ 4 ] ) = 0 then
8702: LD_VAR 0 20
8706: PPUSH
8707: LD_VAR 0 30
8711: PUSH
8712: LD_INT 4
8714: ARRAY
8715: PPUSH
8716: CALL 1891 0 2
8720: PUSH
8721: LD_INT 0
8723: EQUAL
8724: IFFALSE 8774
// Build ( eng , cr_ext [ 4 ] , cr_ext [ 1 ] , cr_ext [ 2 ] , cr_ext [ 3 ] , 30 ) ;
8726: LD_VAR 0 2
8730: PPUSH
8731: LD_VAR 0 30
8735: PUSH
8736: LD_INT 4
8738: ARRAY
8739: PPUSH
8740: LD_VAR 0 30
8744: PUSH
8745: LD_INT 1
8747: ARRAY
8748: PPUSH
8749: LD_VAR 0 30
8753: PUSH
8754: LD_INT 2
8756: ARRAY
8757: PPUSH
8758: LD_VAR 0 30
8762: PUSH
8763: LD_INT 3
8765: ARRAY
8766: PPUSH
8767: LD_INT 30
8769: PPUSH
8770: CALL 3841 0 6
// if AnyBuildingExist ( side , cr_ext [ 8 ] ) = 0 then
8774: LD_VAR 0 20
8778: PPUSH
8779: LD_VAR 0 30
8783: PUSH
8784: LD_INT 8
8786: ARRAY
8787: PPUSH
8788: CALL 1891 0 2
8792: PUSH
8793: LD_INT 0
8795: EQUAL
8796: IFFALSE 8846
// Build ( eng , cr_ext [ 8 ] , cr_ext [ 5 ] , cr_ext [ 6 ] , cr_ext [ 7 ] , 30 ) ;
8798: LD_VAR 0 2
8802: PPUSH
8803: LD_VAR 0 30
8807: PUSH
8808: LD_INT 8
8810: ARRAY
8811: PPUSH
8812: LD_VAR 0 30
8816: PUSH
8817: LD_INT 5
8819: ARRAY
8820: PPUSH
8821: LD_VAR 0 30
8825: PUSH
8826: LD_INT 6
8828: ARRAY
8829: PPUSH
8830: LD_VAR 0 30
8834: PUSH
8835: LD_INT 7
8837: ARRAY
8838: PPUSH
8839: LD_INT 30
8841: PPUSH
8842: CALL 3841 0 6
// if AnyBuildingExist ( side , cr_ext [ 12 ] ) = 0 then
8846: LD_VAR 0 20
8850: PPUSH
8851: LD_VAR 0 30
8855: PUSH
8856: LD_INT 12
8858: ARRAY
8859: PPUSH
8860: CALL 1891 0 2
8864: PUSH
8865: LD_INT 0
8867: EQUAL
8868: IFFALSE 8918
// Build ( eng , cr_ext [ 12 ] , cr_ext [ 9 ] , cr_ext [ 10 ] , cr_ext [ 11 ] , 35 ) ;
8870: LD_VAR 0 2
8874: PPUSH
8875: LD_VAR 0 30
8879: PUSH
8880: LD_INT 12
8882: ARRAY
8883: PPUSH
8884: LD_VAR 0 30
8888: PUSH
8889: LD_INT 9
8891: ARRAY
8892: PPUSH
8893: LD_VAR 0 30
8897: PUSH
8898: LD_INT 10
8900: ARRAY
8901: PPUSH
8902: LD_VAR 0 30
8906: PUSH
8907: LD_INT 11
8909: ARRAY
8910: PPUSH
8911: LD_INT 35
8913: PPUSH
8914: CALL 3841 0 6
// end ; end else
8918: GO 9276
// begin if eng > 0 then
8920: LD_VAR 0 2
8924: PUSH
8925: LD_INT 0
8927: GREATER
8928: IFFALSE 9154
// begin for i = 1 to eng do
8930: LD_ADDR_VAR 0 11
8934: PUSH
8935: DOUBLE
8936: LD_INT 1
8938: DEC
8939: ST_TO_ADDR
8940: LD_VAR 0 2
8944: PUSH
8945: FOR_TO
8946: IFFALSE 9049
// if not HasTask ( eng [ i ] ) and scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 15 ) = false then
8948: LD_VAR 0 2
8952: PUSH
8953: LD_VAR 0 11
8957: ARRAY
8958: PPUSH
8959: CALL_OW 314
8963: NOT
8964: PUSH
8965: LD_VAR 0 20
8969: PPUSH
8970: LD_VAR 0 27
8974: PUSH
8975: LD_INT 1
8977: ARRAY
8978: PPUSH
8979: LD_VAR 0 27
8983: PUSH
8984: LD_INT 2
8986: ARRAY
8987: PPUSH
8988: LD_INT 15
8990: PPUSH
8991: CALL 3547 0 4
8995: PUSH
8996: LD_INT 0
8998: EQUAL
8999: AND
9000: IFFALSE 9047
// ComBuild ( eng [ i ] , b_depot , cr_dep [ 1 ] , cr_dep [ 2 ] , cr_dep [ 3 ] ) ;
9002: LD_VAR 0 2
9006: PUSH
9007: LD_VAR 0 11
9011: ARRAY
9012: PPUSH
9013: LD_INT 0
9015: PPUSH
9016: LD_VAR 0 27
9020: PUSH
9021: LD_INT 1
9023: ARRAY
9024: PPUSH
9025: LD_VAR 0 27
9029: PUSH
9030: LD_INT 2
9032: ARRAY
9033: PPUSH
9034: LD_VAR 0 27
9038: PUSH
9039: LD_INT 3
9041: ARRAY
9042: PPUSH
9043: CALL_OW 145
9047: GO 8945
9049: POP
9050: POP
// for un in sol ^ mech ^ sci do
9051: LD_ADDR_VAR 0 14
9055: PUSH
9056: LD_VAR 0 1
9060: PUSH
9061: LD_VAR 0 3
9065: ADD
9066: PUSH
9067: LD_VAR 0 4
9071: ADD
9072: PUSH
9073: FOR_IN
9074: IFFALSE 9150
// begin if not HasTask ( un ) and GetDistUnitXY ( un , cr_dep [ 1 ] , cr_dep [ 2 ] ) > 7 then
9076: LD_VAR 0 14
9080: PPUSH
9081: CALL_OW 314
9085: NOT
9086: PUSH
9087: LD_VAR 0 14
9091: PPUSH
9092: LD_VAR 0 27
9096: PUSH
9097: LD_INT 1
9099: ARRAY
9100: PPUSH
9101: LD_VAR 0 27
9105: PUSH
9106: LD_INT 2
9108: ARRAY
9109: PPUSH
9110: CALL_OW 297
9114: PUSH
9115: LD_INT 7
9117: GREATER
9118: AND
9119: IFFALSE 9148
// ComMoveXY ( un , cr_dep [ 1 ] , cr_dep [ 2 ] ) ;
9121: LD_VAR 0 14
9125: PPUSH
9126: LD_VAR 0 27
9130: PUSH
9131: LD_INT 1
9133: ARRAY
9134: PPUSH
9135: LD_VAR 0 27
9139: PUSH
9140: LD_INT 2
9142: ARRAY
9143: PPUSH
9144: CALL_OW 111
// end ;
9148: GO 9073
9150: POP
9151: POP
// end else
9152: GO 9276
// begin if sol ^ mech ^ sci = 0 then
9154: LD_VAR 0 1
9158: PUSH
9159: LD_VAR 0 3
9163: ADD
9164: PUSH
9165: LD_VAR 0 4
9169: ADD
9170: PUSH
9171: LD_INT 0
9173: EQUAL
9174: IFFALSE 9180
// exit else
9176: GO 11439
9178: GO 9276
// if ally then
9180: LD_VAR 0 35
9184: IFFALSE 9211
// scs_change_side ( side , GetSide ( ally [ 1 ] ) ) else
9186: LD_VAR 0 20
9190: PPUSH
9191: LD_VAR 0 35
9195: PUSH
9196: LD_INT 1
9198: ARRAY
9199: PPUSH
9200: CALL_OW 255
9204: PPUSH
9205: CALL 3753 0 2
9209: GO 9276
// begin for un in sol ^ mech ^ sci do
9211: LD_ADDR_VAR 0 14
9215: PUSH
9216: LD_VAR 0 1
9220: PUSH
9221: LD_VAR 0 3
9225: ADD
9226: PUSH
9227: LD_VAR 0 4
9231: ADD
9232: PUSH
9233: FOR_IN
9234: IFFALSE 9274
// if not HasTask ( un ) then
9236: LD_VAR 0 14
9240: PPUSH
9241: CALL_OW 314
9245: NOT
9246: IFFALSE 9272
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
9248: LD_VAR 0 14
9252: PPUSH
9253: LD_VAR 0 36
9257: PPUSH
9258: LD_VAR 0 14
9262: PPUSH
9263: CALL_OW 74
9267: PPUSH
9268: CALL_OW 115
9272: GO 9233
9274: POP
9275: POP
// end ; end ; end ; if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 45 ) then
9276: LD_VAR 0 20
9280: PPUSH
9281: LD_VAR 0 27
9285: PUSH
9286: LD_INT 1
9288: ARRAY
9289: PPUSH
9290: LD_VAR 0 27
9294: PUSH
9295: LD_INT 2
9297: ARRAY
9298: PPUSH
9299: LD_INT 45
9301: PPUSH
9302: CALL 3547 0 4
9306: IFFALSE 9693
// begin if AnyBuildingExist ( side , b_armoury ) or AnyBuildingExist ( side , b_barracks ) then
9308: LD_VAR 0 20
9312: PPUSH
9313: LD_INT 4
9315: PPUSH
9316: CALL 1891 0 2
9320: PUSH
9321: LD_VAR 0 20
9325: PPUSH
9326: LD_INT 5
9328: PPUSH
9329: CALL 1891 0 2
9333: OR
9334: IFFALSE 9693
// begin if test then
9336: LD_EXP 84
9340: IFFALSE 9350
// display_strings := sold_1 ;
9342: LD_ADDR_OWVAR 47
9346: PUSH
9347: LD_STRING sold_1
9349: ST_TO_ADDR
// if scs_find_barracks ( side ) > 0 then
9350: LD_VAR 0 20
9354: PPUSH
9355: CALL 5065 0 1
9359: PUSH
9360: LD_INT 0
9362: GREATER
9363: IFFALSE 9693
// begin if ( sol < FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) * 6 + FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ) then
9365: LD_VAR 0 1
9369: PUSH
9370: LD_INT 22
9372: PUSH
9373: LD_VAR 0 20
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: PUSH
9382: LD_INT 2
9384: PUSH
9385: LD_INT 30
9387: PUSH
9388: LD_INT 4
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PUSH
9395: LD_INT 30
9397: PUSH
9398: LD_INT 5
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: LIST
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PPUSH
9414: CALL_OW 69
9418: PUSH
9419: LD_INT 6
9421: MUL
9422: PUSH
9423: LD_INT 22
9425: PUSH
9426: LD_VAR 0 20
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 30
9437: PUSH
9438: LD_INT 32
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 58
9447: PUSH
9448: EMPTY
9449: LIST
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: LIST
9455: PPUSH
9456: CALL_OW 69
9460: PLUS
9461: LESS
9462: IFFALSE 9542
// begin if filter_c = 0 then
9464: LD_VAR 0 41
9468: PUSH
9469: LD_INT 0
9471: EQUAL
9472: IFFALSE 9514
// begin filter_c := eng ^ mech ^ sci ;
9474: LD_ADDR_VAR 0 41
9478: PUSH
9479: LD_VAR 0 2
9483: PUSH
9484: LD_VAR 0 3
9488: ADD
9489: PUSH
9490: LD_VAR 0 4
9494: ADD
9495: ST_TO_ADDR
// filter_c := SortFilter ( filter_c , 1 ) ;
9496: LD_ADDR_VAR 0 41
9500: PUSH
9501: LD_VAR 0 41
9505: PPUSH
9506: LD_INT 1
9508: PPUSH
9509: CALL 4665 0 2
9513: ST_TO_ADDR
// end ; if filter_c > 0 then
9514: LD_VAR 0 41
9518: PUSH
9519: LD_INT 0
9521: GREATER
9522: IFFALSE 9542
// scs_change_class ( filter_c [ filter_c ] , 1 ) ;
9524: LD_VAR 0 41
9528: PUSH
9529: LD_VAR 0 41
9533: ARRAY
9534: PPUSH
9535: LD_INT 1
9537: PPUSH
9538: CALL 4739 0 2
// end ; if sol > 0 then
9542: LD_VAR 0 1
9546: PUSH
9547: LD_INT 0
9549: GREATER
9550: IFFALSE 9693
// begin if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) > 0 then
9552: LD_INT 22
9554: PUSH
9555: LD_VAR 0 20
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 30
9566: PUSH
9567: LD_INT 32
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 58
9576: PUSH
9577: EMPTY
9578: LIST
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PPUSH
9585: CALL_OW 69
9589: PUSH
9590: LD_INT 0
9592: GREATER
9593: IFFALSE 9606
// FillTowers ( side ) else
9595: LD_VAR 0 20
9599: PPUSH
9600: CALL 5719 0 1
9604: GO 9693
// for i = 1 to sol do
9606: LD_ADDR_VAR 0 11
9610: PUSH
9611: DOUBLE
9612: LD_INT 1
9614: DEC
9615: ST_TO_ADDR
9616: LD_VAR 0 1
9620: PUSH
9621: FOR_TO
9622: IFFALSE 9691
// if not IsInUnit ( sol [ i ] ) and not HasTask ( sol [ i ] ) then
9624: LD_VAR 0 1
9628: PUSH
9629: LD_VAR 0 11
9633: ARRAY
9634: PPUSH
9635: CALL_OW 310
9639: NOT
9640: PUSH
9641: LD_VAR 0 1
9645: PUSH
9646: LD_VAR 0 11
9650: ARRAY
9651: PPUSH
9652: CALL_OW 314
9656: NOT
9657: AND
9658: IFFALSE 9689
// ComEnterUnit ( sol [ i ] , scs_find_barracks ( side ) [ 1 ] ) ;
9660: LD_VAR 0 1
9664: PUSH
9665: LD_VAR 0 11
9669: ARRAY
9670: PPUSH
9671: LD_VAR 0 20
9675: PPUSH
9676: CALL 5065 0 1
9680: PUSH
9681: LD_INT 1
9683: ARRAY
9684: PPUSH
9685: CALL_OW 120
9689: GO 9621
9691: POP
9692: POP
// end ; end ; end ; end ; if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
9693: LD_VAR 0 20
9697: PPUSH
9698: LD_INT 0
9700: PPUSH
9701: CALL 1891 0 2
9705: PUSH
9706: LD_VAR 0 20
9710: PPUSH
9711: LD_INT 1
9713: PPUSH
9714: CALL 1891 0 2
9718: OR
9719: IFFALSE 9891
// begin if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 45 ) = false then
9721: LD_VAR 0 20
9725: PPUSH
9726: LD_VAR 0 27
9730: PUSH
9731: LD_INT 1
9733: ARRAY
9734: PPUSH
9735: LD_VAR 0 27
9739: PUSH
9740: LD_INT 2
9742: ARRAY
9743: PPUSH
9744: LD_INT 45
9746: PPUSH
9747: CALL 3547 0 4
9751: PUSH
9752: LD_INT 0
9754: EQUAL
9755: IFFALSE 9891
// begin for i = 1 to sol do
9757: LD_ADDR_VAR 0 11
9761: PUSH
9762: DOUBLE
9763: LD_INT 1
9765: DEC
9766: ST_TO_ADDR
9767: LD_VAR 0 1
9771: PUSH
9772: FOR_TO
9773: IFFALSE 9889
// begin if IsInUnit ( sol [ i ] ) then
9775: LD_VAR 0 1
9779: PUSH
9780: LD_VAR 0 11
9784: ARRAY
9785: PPUSH
9786: CALL_OW 310
9790: IFFALSE 9807
// ComExitBuilding ( sol [ i ] ) ;
9792: LD_VAR 0 1
9796: PUSH
9797: LD_VAR 0 11
9801: ARRAY
9802: PPUSH
9803: CALL_OW 122
// if mech <= 5 and AnyBuildingExist ( side , b_factory ) then
9807: LD_VAR 0 3
9811: PUSH
9812: LD_INT 5
9814: LESSEQUAL
9815: PUSH
9816: LD_VAR 0 20
9820: PPUSH
9821: LD_INT 3
9823: PPUSH
9824: CALL 1891 0 2
9828: AND
9829: IFFALSE 9869
// begin sol := SortFilter ( sol , skill_mechanical ) ;
9831: LD_ADDR_VAR 0 1
9835: PUSH
9836: LD_VAR 0 1
9840: PPUSH
9841: LD_INT 3
9843: PPUSH
9844: CALL 4665 0 2
9848: ST_TO_ADDR
// scs_change_class ( sol [ sol ] , class_mechanic ) ;
9849: LD_VAR 0 1
9853: PUSH
9854: LD_VAR 0 1
9858: ARRAY
9859: PPUSH
9860: LD_INT 3
9862: PPUSH
9863: CALL 4739 0 2
// end else
9867: GO 9887
// scs_change_class ( sol [ sol ] , class_engineer ) ;
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 1
9878: ARRAY
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: CALL 4739 0 2
// end ;
9887: GO 9772
9889: POP
9890: POP
// end ; end ; if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
9891: LD_VAR 0 20
9895: PPUSH
9896: LD_INT 0
9898: PPUSH
9899: CALL 1891 0 2
9903: PUSH
9904: LD_VAR 0 20
9908: PPUSH
9909: LD_INT 1
9911: PPUSH
9912: CALL 1891 0 2
9916: OR
9917: IFFALSE 10208
// begin if AnyBuildingExist ( side , b_factory ) = false then
9919: LD_VAR 0 20
9923: PPUSH
9924: LD_INT 3
9926: PPUSH
9927: CALL 1891 0 2
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
// begin for i = 1 to mech do
9937: LD_ADDR_VAR 0 11
9941: PUSH
9942: DOUBLE
9943: LD_INT 1
9945: DEC
9946: ST_TO_ADDR
9947: LD_VAR 0 3
9951: PUSH
9952: FOR_TO
9953: IFFALSE 9975
// scs_change_class ( mech [ i ] , 2 ) ;
9955: LD_VAR 0 3
9959: PUSH
9960: LD_VAR 0 11
9964: ARRAY
9965: PPUSH
9966: LD_INT 2
9968: PPUSH
9969: CALL 4739 0 2
9973: GO 9952
9975: POP
9976: POP
// end else
9977: GO 10072
// if mech > 0 then
9979: LD_VAR 0 3
9983: PUSH
9984: LD_INT 0
9986: GREATER
9987: IFFALSE 10072
// for i = 1 to mech do
9989: LD_ADDR_VAR 0 11
9993: PUSH
9994: DOUBLE
9995: LD_INT 1
9997: DEC
9998: ST_TO_ADDR
9999: LD_VAR 0 3
10003: PUSH
10004: FOR_TO
10005: IFFALSE 10070
// if not IsInUnit ( mech [ i ] ) and not HasTask ( mech [ i ] ) then
10007: LD_VAR 0 3
10011: PUSH
10012: LD_VAR 0 11
10016: ARRAY
10017: PPUSH
10018: CALL_OW 310
10022: NOT
10023: PUSH
10024: LD_VAR 0 3
10028: PUSH
10029: LD_VAR 0 11
10033: ARRAY
10034: PPUSH
10035: CALL_OW 314
10039: NOT
10040: AND
10041: IFFALSE 10068
// ComEnterUnit ( mech [ i ] , scs_find_factory ( side ) ) ;
10043: LD_VAR 0 3
10047: PUSH
10048: LD_VAR 0 11
10052: ARRAY
10053: PPUSH
10054: LD_VAR 0 20
10058: PPUSH
10059: CALL 5346 0 1
10063: PPUSH
10064: CALL_OW 120
10068: GO 10004
10070: POP
10071: POP
// if scs_scan_buildings ( side , b_factory ) > 0 then
10072: LD_VAR 0 20
10076: PPUSH
10077: LD_INT 3
10079: PPUSH
10080: CALL 3707 0 2
10084: PUSH
10085: LD_INT 0
10087: GREATER
10088: IFFALSE 10208
// begin fac := scs_scan_buildings ( side , b_factory ) [ 1 ] ;
10090: LD_ADDR_VAR 0 39
10094: PUSH
10095: LD_VAR 0 20
10099: PPUSH
10100: LD_INT 3
10102: PPUSH
10103: CALL 3707 0 2
10107: PUSH
10108: LD_INT 1
10110: ARRAY
10111: ST_TO_ADDR
// if BuildingStatus ( fac ) = bs_working and mech < 6 then
10112: LD_VAR 0 39
10116: PPUSH
10117: CALL_OW 461
10121: PUSH
10122: LD_INT 3
10124: EQUAL
10125: PUSH
10126: LD_VAR 0 3
10130: PUSH
10131: LD_INT 6
10133: LESS
10134: AND
10135: IFFALSE 10208
// begin filter := eng ^ sci ;
10137: LD_ADDR_VAR 0 40
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_VAR 0 4
10151: ADD
10152: ST_TO_ADDR
// filter := SortFilter ( filter , 3 ) ;
10153: LD_ADDR_VAR 0 40
10157: PUSH
10158: LD_VAR 0 40
10162: PPUSH
10163: LD_INT 3
10165: PPUSH
10166: CALL 4665 0 2
10170: ST_TO_ADDR
// while ( mech < 6 ) do
10171: LD_VAR 0 3
10175: PUSH
10176: LD_INT 6
10178: LESS
10179: IFFALSE 10208
// begin scs_change_class ( filter [ filter ] , 3 ) ;
10181: LD_VAR 0 40
10185: PUSH
10186: LD_VAR 0 40
10190: ARRAY
10191: PPUSH
10192: LD_INT 3
10194: PPUSH
10195: CALL 4739 0 2
// wait ( 0 0$0.1 ) ;
10199: LD_INT 4
10201: PPUSH
10202: CALL_OW 67
// end ;
10206: GO 10171
// end ; end ; end ; if AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) then
10208: LD_VAR 0 20
10212: PPUSH
10213: LD_INT 0
10215: PPUSH
10216: CALL 1891 0 2
10220: PUSH
10221: LD_VAR 0 20
10225: PPUSH
10226: LD_INT 1
10228: PPUSH
10229: CALL 1891 0 2
10233: OR
10234: IFFALSE 10562
// begin if scs_scan_lab ( side ) = 0 then
10236: LD_VAR 0 20
10240: PPUSH
10241: CALL 3634 0 1
10245: PUSH
10246: LD_INT 0
10248: EQUAL
10249: IFFALSE 10311
// begin for i = 1 to sci do
10251: LD_ADDR_VAR 0 11
10255: PUSH
10256: DOUBLE
10257: LD_INT 1
10259: DEC
10260: ST_TO_ADDR
10261: LD_VAR 0 4
10265: PUSH
10266: FOR_TO
10267: IFFALSE 10307
// if not HasTask ( sci [ i ] ) then
10269: LD_VAR 0 4
10273: PUSH
10274: LD_VAR 0 11
10278: ARRAY
10279: PPUSH
10280: CALL_OW 314
10284: NOT
10285: IFFALSE 10305
// scs_change_class ( sci [ i ] , 2 ) ;
10287: LD_VAR 0 4
10291: PUSH
10292: LD_VAR 0 11
10296: ARRAY
10297: PPUSH
10298: LD_INT 2
10300: PPUSH
10301: CALL 4739 0 2
10305: GO 10266
10307: POP
10308: POP
// end else
10309: GO 10463
// if sci < 6 then
10311: LD_VAR 0 4
10315: PUSH
10316: LD_INT 6
10318: LESS
10319: IFFALSE 10463
// begin eng := SortFilter ( eng , 4 ) ;
10321: LD_ADDR_VAR 0 2
10325: PUSH
10326: LD_VAR 0 2
10330: PPUSH
10331: LD_INT 4
10333: PPUSH
10334: CALL 4665 0 2
10338: ST_TO_ADDR
// if eng > 7 then
10339: LD_VAR 0 2
10343: PUSH
10344: LD_INT 7
10346: GREATER
10347: IFFALSE 10389
// begin for i = 1 to 6 do
10349: LD_ADDR_VAR 0 11
10353: PUSH
10354: DOUBLE
10355: LD_INT 1
10357: DEC
10358: ST_TO_ADDR
10359: LD_INT 6
10361: PUSH
10362: FOR_TO
10363: IFFALSE 10385
// scs_change_class ( eng [ i ] , 4 ) ;
10365: LD_VAR 0 2
10369: PUSH
10370: LD_VAR 0 11
10374: ARRAY
10375: PPUSH
10376: LD_INT 4
10378: PPUSH
10379: CALL 4739 0 2
10383: GO 10362
10385: POP
10386: POP
// end else
10387: GO 10463
// if eng > 2 and eng <= 7 and sci < 6 then
10389: LD_VAR 0 2
10393: PUSH
10394: LD_INT 2
10396: GREATER
10397: PUSH
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 7
10405: LESSEQUAL
10406: AND
10407: PUSH
10408: LD_VAR 0 4
10412: PUSH
10413: LD_INT 6
10415: LESS
10416: AND
10417: IFFALSE 10463
// for i = 1 to ( eng - 2 ) do
10419: LD_ADDR_VAR 0 11
10423: PUSH
10424: DOUBLE
10425: LD_INT 1
10427: DEC
10428: ST_TO_ADDR
10429: LD_VAR 0 2
10433: PUSH
10434: LD_INT 2
10436: MINUS
10437: PUSH
10438: FOR_TO
10439: IFFALSE 10461
// scs_change_class ( eng [ i ] , 4 ) ;
10441: LD_VAR 0 2
10445: PUSH
10446: LD_VAR 0 11
10450: ARRAY
10451: PPUSH
10452: LD_INT 4
10454: PPUSH
10455: CALL 4739 0 2
10459: GO 10438
10461: POP
10462: POP
// end ; for i = 1 to sci do
10463: LD_ADDR_VAR 0 11
10467: PUSH
10468: DOUBLE
10469: LD_INT 1
10471: DEC
10472: ST_TO_ADDR
10473: LD_VAR 0 4
10477: PUSH
10478: FOR_TO
10479: IFFALSE 10560
// if not IsInUnit ( sci [ i ] ) and ( not HasTask ( sci [ i ] ) ) then
10481: LD_VAR 0 4
10485: PUSH
10486: LD_VAR 0 11
10490: ARRAY
10491: PPUSH
10492: CALL_OW 310
10496: NOT
10497: PUSH
10498: LD_VAR 0 4
10502: PUSH
10503: LD_VAR 0 11
10507: ARRAY
10508: PPUSH
10509: CALL_OW 314
10513: NOT
10514: AND
10515: IFFALSE 10558
// ComEnterUnit ( sci [ i ] , NearestUnitToUnit ( scs_scan_lab ( side ) , sci [ i ] ) ) ;
10517: LD_VAR 0 4
10521: PUSH
10522: LD_VAR 0 11
10526: ARRAY
10527: PPUSH
10528: LD_VAR 0 20
10532: PPUSH
10533: CALL 3634 0 1
10537: PPUSH
10538: LD_VAR 0 4
10542: PUSH
10543: LD_VAR 0 11
10547: ARRAY
10548: PPUSH
10549: CALL_OW 74
10553: PPUSH
10554: CALL_OW 120
10558: GO 10478
10560: POP
10561: POP
// end ; if scs_scan_lab ( side ) > 0 then
10562: LD_VAR 0 20
10566: PPUSH
10567: CALL 3634 0 1
10571: PUSH
10572: LD_INT 0
10574: GREATER
10575: IFFALSE 10959
// begin for i = 1 to scs_scan_lab ( side ) do
10577: LD_ADDR_VAR 0 11
10581: PUSH
10582: DOUBLE
10583: LD_INT 1
10585: DEC
10586: ST_TO_ADDR
10587: LD_VAR 0 20
10591: PPUSH
10592: CALL 3634 0 1
10596: PUSH
10597: FOR_TO
10598: IFFALSE 10957
// begin if b_lab_basic in [ GetLabKind ( scs_scan_lab ( side ) [ i ] , 1 ) , GetLabKind ( scs_scan_lab ( side ) [ i ] , 2 ) ] then
10600: LD_INT 9
10602: PUSH
10603: LD_VAR 0 20
10607: PPUSH
10608: CALL 3634 0 1
10612: PUSH
10613: LD_VAR 0 11
10617: ARRAY
10618: PPUSH
10619: LD_INT 1
10621: PPUSH
10622: CALL_OW 268
10626: PUSH
10627: LD_VAR 0 20
10631: PPUSH
10632: CALL 3634 0 1
10636: PUSH
10637: LD_VAR 0 11
10641: ARRAY
10642: PPUSH
10643: LD_INT 2
10645: PPUSH
10646: CALL_OW 268
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: IN
10655: IFFALSE 10706
// if b1_tech = [ ] and GetTech ( tech_lab [ 1 ] , side ) <> state_researched then
10657: LD_EXP 72
10661: PUSH
10662: EMPTY
10663: EQUAL
10664: PUSH
10665: LD_EXP 83
10669: PUSH
10670: LD_INT 1
10672: ARRAY
10673: PPUSH
10674: LD_VAR 0 20
10678: PPUSH
10679: CALL_OW 321
10683: PUSH
10684: LD_INT 2
10686: NONEQUAL
10687: AND
10688: IFFALSE 10706
// b1_tech = b1_tech ^ tech_lab ;
10690: LD_ADDR_EXP 72
10694: PUSH
10695: LD_EXP 72
10699: PUSH
10700: LD_EXP 83
10704: ADD
10705: ST_TO_ADDR
// if b_lab_weapon in [ GetLabKind ( scs_scan_lab ( side ) [ i ] , 1 ) , GetLabKind ( scs_scan_lab ( side ) [ i ] , 2 ) ] then
10706: LD_INT 10
10708: PUSH
10709: LD_VAR 0 20
10713: PPUSH
10714: CALL 3634 0 1
10718: PUSH
10719: LD_VAR 0 11
10723: ARRAY
10724: PPUSH
10725: LD_INT 1
10727: PPUSH
10728: CALL_OW 268
10732: PUSH
10733: LD_VAR 0 20
10737: PPUSH
10738: CALL 3634 0 1
10742: PUSH
10743: LD_VAR 0 11
10747: ARRAY
10748: PPUSH
10749: LD_INT 2
10751: PPUSH
10752: CALL_OW 268
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: IN
10761: IFFALSE 10812
// if b1_tech = [ ] and GetTech ( tech_weap [ 1 ] , side ) <> state_researched then
10763: LD_EXP 72
10767: PUSH
10768: EMPTY
10769: EQUAL
10770: PUSH
10771: LD_EXP 77
10775: PUSH
10776: LD_INT 1
10778: ARRAY
10779: PPUSH
10780: LD_VAR 0 20
10784: PPUSH
10785: CALL_OW 321
10789: PUSH
10790: LD_INT 2
10792: NONEQUAL
10793: AND
10794: IFFALSE 10812
// b1_tech = b1_tech ^ tech_weap ;
10796: LD_ADDR_EXP 72
10800: PUSH
10801: LD_EXP 72
10805: PUSH
10806: LD_EXP 77
10810: ADD
10811: ST_TO_ADDR
// display_strings := b1_tech ;
10812: LD_ADDR_OWVAR 47
10816: PUSH
10817: LD_EXP 72
10821: ST_TO_ADDR
// if BuildingStatus ( scs_scan_lab ( side ) [ i ] ) = bs_idle and b1_tech > 0 then
10822: LD_VAR 0 20
10826: PPUSH
10827: CALL 3634 0 1
10831: PUSH
10832: LD_VAR 0 11
10836: ARRAY
10837: PPUSH
10838: CALL_OW 461
10842: PUSH
10843: LD_INT 2
10845: EQUAL
10846: PUSH
10847: LD_EXP 72
10851: PUSH
10852: LD_INT 0
10854: GREATER
10855: AND
10856: IFFALSE 10955
// begin if GetTech ( b1_tech [ 1 ] , side ) = state_enabled then
10858: LD_EXP 72
10862: PUSH
10863: LD_INT 1
10865: ARRAY
10866: PPUSH
10867: LD_VAR 0 20
10871: PPUSH
10872: CALL_OW 321
10876: PUSH
10877: LD_INT 1
10879: EQUAL
10880: IFFALSE 10913
// ComResearch ( scs_scan_lab ( side ) [ i ] , b1_tech [ 1 ] ) else
10882: LD_VAR 0 20
10886: PPUSH
10887: CALL 3634 0 1
10891: PUSH
10892: LD_VAR 0 11
10896: ARRAY
10897: PPUSH
10898: LD_EXP 72
10902: PUSH
10903: LD_INT 1
10905: ARRAY
10906: PPUSH
10907: CALL_OW 124
10911: GO 10955
// if GetTech ( b1_tech [ 1 ] , side ) = state_researched then
10913: LD_EXP 72
10917: PUSH
10918: LD_INT 1
10920: ARRAY
10921: PPUSH
10922: LD_VAR 0 20
10926: PPUSH
10927: CALL_OW 321
10931: PUSH
10932: LD_INT 2
10934: EQUAL
10935: IFFALSE 10955
// b1_tech := Delete ( b1_tech , 1 ) ;
10937: LD_ADDR_EXP 72
10941: PUSH
10942: LD_EXP 72
10946: PPUSH
10947: LD_INT 1
10949: PPUSH
10950: CALL_OW 3
10954: ST_TO_ADDR
// end ; end ;
10955: GO 10597
10957: POP
10958: POP
// end ; if scs_scan_area ( side , cr_dep [ 1 ] , cr_dep [ 2 ] , 45 ) = false and ( AnyBuildingExist ( side , b_depot ) or AnyBuildingExist ( side , b_warehouse ) ) then
10959: LD_VAR 0 20
10963: PPUSH
10964: LD_VAR 0 27
10968: PUSH
10969: LD_INT 1
10971: ARRAY
10972: PPUSH
10973: LD_VAR 0 27
10977: PUSH
10978: LD_INT 2
10980: ARRAY
10981: PPUSH
10982: LD_INT 45
10984: PPUSH
10985: CALL 3547 0 4
10989: PUSH
10990: LD_INT 0
10992: EQUAL
10993: PUSH
10994: LD_VAR 0 20
10998: PPUSH
10999: LD_INT 0
11001: PPUSH
11002: CALL 1891 0 2
11006: PUSH
11007: LD_VAR 0 20
11011: PPUSH
11012: LD_INT 1
11014: PPUSH
11015: CALL 1891 0 2
11019: OR
11020: AND
11021: IFFALSE 11439
// begin skr = GetListOfCratesInArea ( CratesArea ) ;
11023: LD_ADDR_VAR 0 37
11027: PUSH
11028: LD_INT 17
11030: PPUSH
11031: CALL_OW 435
11035: ST_TO_ADDR
// c = 1 ;
11036: LD_ADDR_VAR 0 38
11040: PUSH
11041: LD_INT 1
11043: ST_TO_ADDR
// while c < skr do
11044: LD_VAR 0 38
11048: PUSH
11049: LD_VAR 0 37
11053: LESS
11054: IFFALSE 11439
// begin if FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 then
11056: LD_INT 22
11058: PUSH
11059: LD_VAR 0 20
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: PUSH
11068: LD_INT 2
11070: PUSH
11071: LD_INT 34
11073: PUSH
11074: LD_INT 12
11076: PUSH
11077: EMPTY
11078: LIST
11079: LIST
11080: PUSH
11081: LD_INT 34
11083: PUSH
11084: LD_INT 32
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: LD_INT 34
11093: PUSH
11094: LD_INT 51
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: PUSH
11116: LD_INT 0
11118: EQUAL
11119: IFFALSE 11269
// begin for p = 1 to ( eng / 3 ) do
11121: LD_ADDR_VAR 0 12
11125: PUSH
11126: DOUBLE
11127: LD_INT 1
11129: DEC
11130: ST_TO_ADDR
11131: LD_VAR 0 2
11135: PUSH
11136: LD_INT 3
11138: DIVREAL
11139: PUSH
11140: FOR_TO
11141: IFFALSE 11251
// if not HasTask ( eng [ p ] ) and GetDistUnitXY ( eng [ p ] , skr [ c ] , skr [ c + 1 ] ) <= 25 then
11143: LD_VAR 0 2
11147: PUSH
11148: LD_VAR 0 12
11152: ARRAY
11153: PPUSH
11154: CALL_OW 314
11158: NOT
11159: PUSH
11160: LD_VAR 0 2
11164: PUSH
11165: LD_VAR 0 12
11169: ARRAY
11170: PPUSH
11171: LD_VAR 0 37
11175: PUSH
11176: LD_VAR 0 38
11180: ARRAY
11181: PPUSH
11182: LD_VAR 0 37
11186: PUSH
11187: LD_VAR 0 38
11191: PUSH
11192: LD_INT 1
11194: PLUS
11195: ARRAY
11196: PPUSH
11197: CALL_OW 297
11201: PUSH
11202: LD_INT 25
11204: LESSEQUAL
11205: AND
11206: IFFALSE 11249
// ComCollect ( eng [ p ] , skr [ c ] , skr [ c + 1 ] ) ;
11208: LD_VAR 0 2
11212: PUSH
11213: LD_VAR 0 12
11217: ARRAY
11218: PPUSH
11219: LD_VAR 0 37
11223: PUSH
11224: LD_VAR 0 38
11228: ARRAY
11229: PPUSH
11230: LD_VAR 0 37
11234: PUSH
11235: LD_VAR 0 38
11239: PUSH
11240: LD_INT 1
11242: PLUS
11243: ARRAY
11244: PPUSH
11245: CALL_OW 117
11249: GO 11140
11251: POP
11252: POP
// c = c + 2 ;
11253: LD_ADDR_VAR 0 38
11257: PUSH
11258: LD_VAR 0 38
11262: PUSH
11263: LD_INT 2
11265: PLUS
11266: ST_TO_ADDR
// end else
11267: GO 11437
// begin if GetLives ( veh [ 1 ] ) > 300 and GetDistUnitXY ( veh [ 1 ] , skr [ c ] , skr [ c + 1 ] ) <= 45 then
11269: LD_VAR 0 15
11273: PUSH
11274: LD_INT 1
11276: ARRAY
11277: PPUSH
11278: CALL_OW 256
11282: PUSH
11283: LD_INT 300
11285: GREATER
11286: PUSH
11287: LD_VAR 0 15
11291: PUSH
11292: LD_INT 1
11294: ARRAY
11295: PPUSH
11296: LD_VAR 0 37
11300: PUSH
11301: LD_VAR 0 38
11305: ARRAY
11306: PPUSH
11307: LD_VAR 0 37
11311: PUSH
11312: LD_VAR 0 38
11316: PUSH
11317: LD_INT 1
11319: PLUS
11320: ARRAY
11321: PPUSH
11322: CALL_OW 297
11326: PUSH
11327: LD_INT 45
11329: LESSEQUAL
11330: AND
11331: IFFALSE 11437
// begin veh := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) ;
11333: LD_ADDR_VAR 0 15
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 20
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 34
11355: PUSH
11356: LD_INT 12
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 34
11365: PUSH
11366: LD_INT 32
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 51
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: CALL_OW 69
11397: ST_TO_ADDR
// ComCollect ( veh [ 1 ] , skr [ c ] , skr [ c + 1 ] ) ;
11398: LD_VAR 0 15
11402: PUSH
11403: LD_INT 1
11405: ARRAY
11406: PPUSH
11407: LD_VAR 0 37
11411: PUSH
11412: LD_VAR 0 38
11416: ARRAY
11417: PPUSH
11418: LD_VAR 0 37
11422: PUSH
11423: LD_VAR 0 38
11427: PUSH
11428: LD_INT 1
11430: PLUS
11431: ARRAY
11432: PPUSH
11433: CALL_OW 117
// end ; end ; end ;
11437: GO 11044
// end ; end ; end_of_file end_of_file
11439: PPOPN 50
11441: END
// export test ; export function var_test ( ) ; var a ; begin
11442: LD_INT 0
11444: PPUSH
11445: PPUSH
// scs_create_squad ( 1 , 2 , 3 , 0 , MZBaseArea ) ;
11446: LD_INT 1
11448: PPUSH
11449: LD_INT 2
11451: PPUSH
11452: LD_INT 3
11454: PPUSH
11455: LD_INT 0
11457: PPUSH
11458: LD_INT 1
11460: PPUSH
11461: CALL 3015 0 5
// b1_side := 2 ;
11465: LD_ADDR_EXP 6
11469: PUSH
11470: LD_INT 2
11472: ST_TO_ADDR
// b1_nation := 1 ;
11473: LD_ADDR_EXP 7
11477: PUSH
11478: LD_INT 1
11480: ST_TO_ADDR
// b1_people := 16 ;
11481: LD_ADDR_EXP 9
11485: PUSH
11486: LD_INT 16
11488: ST_TO_ADDR
// b1_skill := 5 ;
11489: LD_ADDR_EXP 10
11493: PUSH
11494: LD_INT 5
11496: ST_TO_ADDR
// b1_area := SouthSpawn ;
11497: LD_ADDR_EXP 8
11501: PUSH
11502: LD_INT 16
11504: ST_TO_ADDR
// b1_cr_dep := [ 130 , 120 , 2 ] ;
11505: LD_ADDR_EXP 11
11509: PUSH
11510: LD_INT 130
11512: PUSH
11513: LD_INT 120
11515: PUSH
11516: LD_INT 2
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: LIST
11523: ST_TO_ADDR
// b1_cr_br := [ 123 , 106 , 3 , 134 , 111 , 3 , 114 , 110 , 2 ] ;
11524: LD_ADDR_EXP 17
11528: PUSH
11529: LD_INT 123
11531: PUSH
11532: LD_INT 106
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: LD_INT 134
11540: PUSH
11541: LD_INT 111
11543: PUSH
11544: LD_INT 3
11546: PUSH
11547: LD_INT 114
11549: PUSH
11550: LD_INT 110
11552: PUSH
11553: LD_INT 2
11555: PUSH
11556: EMPTY
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: LIST
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: ST_TO_ADDR
// b1_cr_lab := [ 122 , 122 , 1 , b_lab_weapon , b_lab_opto , 145 , 130 , 4 , b_lab_opto , b_lab_computer , 118 , 128 , 4 , b_lab_opto , b_lab_computer ] ;
11567: LD_ADDR_EXP 12
11571: PUSH
11572: LD_INT 122
11574: PUSH
11575: LD_INT 122
11577: PUSH
11578: LD_INT 1
11580: PUSH
11581: LD_INT 10
11583: PUSH
11584: LD_INT 15
11586: PUSH
11587: LD_INT 145
11589: PUSH
11590: LD_INT 130
11592: PUSH
11593: LD_INT 4
11595: PUSH
11596: LD_INT 15
11598: PUSH
11599: LD_INT 12
11601: PUSH
11602: LD_INT 118
11604: PUSH
11605: LD_INT 128
11607: PUSH
11608: LD_INT 4
11610: PUSH
11611: LD_INT 15
11613: PUSH
11614: LD_INT 12
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: ST_TO_ADDR
// b1_cr_pow := [ 123 , 132 , 0 , b_oil_power , 131 , 135 , 5 , b_oil_power ] ;
11634: LD_ADDR_EXP 15
11638: PUSH
11639: LD_INT 123
11641: PUSH
11642: LD_INT 132
11644: PUSH
11645: LD_INT 0
11647: PUSH
11648: LD_INT 26
11650: PUSH
11651: LD_INT 131
11653: PUSH
11654: LD_INT 135
11656: PUSH
11657: LD_INT 5
11659: PUSH
11660: LD_INT 26
11662: PUSH
11663: EMPTY
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: LIST
11672: ST_TO_ADDR
// if super_source = false then
11673: LD_EXP 71
11677: PUSH
11678: LD_INT 0
11680: EQUAL
11681: IFFALSE 11740
// b1_cr_add := [ 138 , 137 , b_oil_mine , 0 , 0 , 0 , 142 , 137 , b_siberite_mine , 0 , 0 , 0 ] else
11683: LD_ADDR_EXP 18
11687: PUSH
11688: LD_INT 138
11690: PUSH
11691: LD_INT 137
11693: PUSH
11694: LD_INT 29
11696: PUSH
11697: LD_INT 0
11699: PUSH
11700: LD_INT 0
11702: PUSH
11703: LD_INT 0
11705: PUSH
11706: LD_INT 142
11708: PUSH
11709: LD_INT 137
11711: PUSH
11712: LD_INT 30
11714: PUSH
11715: LD_INT 0
11717: PUSH
11718: LD_INT 0
11720: PUSH
11721: LD_INT 0
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: ST_TO_ADDR
11738: GO 11795
// b1_cr_add := [ 152 , 136 , b_oil_mine , 130 , 136 , b_oil_mine , 153 , 132 , b_siberite_mine , 124 , 133 , b_siberite_mine ] ;
11740: LD_ADDR_EXP 18
11744: PUSH
11745: LD_INT 152
11747: PUSH
11748: LD_INT 136
11750: PUSH
11751: LD_INT 29
11753: PUSH
11754: LD_INT 130
11756: PUSH
11757: LD_INT 136
11759: PUSH
11760: LD_INT 29
11762: PUSH
11763: LD_INT 153
11765: PUSH
11766: LD_INT 132
11768: PUSH
11769: LD_INT 30
11771: PUSH
11772: LD_INT 124
11774: PUSH
11775: LD_INT 133
11777: PUSH
11778: LD_INT 30
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: ST_TO_ADDR
// b1_cr_fab := [ 135 , 130 , 0 ] ;
11795: LD_ADDR_EXP 13
11799: PUSH
11800: LD_INT 135
11802: PUSH
11803: LD_INT 130
11805: PUSH
11806: LD_INT 0
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: LIST
11813: ST_TO_ADDR
// b1_cr_ext := [ 135 , 134 , 0 , b_ext_noncombat , 131 , 126 , 2 , b_ext_track ] ;
11814: LD_ADDR_EXP 14
11818: PUSH
11819: LD_INT 135
11821: PUSH
11822: LD_INT 134
11824: PUSH
11825: LD_INT 0
11827: PUSH
11828: LD_INT 19
11830: PUSH
11831: LD_INT 131
11833: PUSH
11834: LD_INT 126
11836: PUSH
11837: LD_INT 2
11839: PUSH
11840: LD_INT 16
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: ST_TO_ADDR
// SetTech ( tech_oilpow , b1_side , state_researched ) ;
11853: LD_INT 46
11855: PPUSH
11856: LD_EXP 6
11860: PPUSH
11861: LD_INT 2
11863: PPUSH
11864: CALL_OW 322
// scs_create_bots ( ) ;
11868: CALL 320 0 0
// Wait ( 0 0$03 ) ;
11872: LD_INT 105
11874: PPUSH
11875: CALL_OW 67
// CreateCratesArea ( 5 , buildup5 , true ) ;
11879: LD_INT 5
11881: PPUSH
11882: LD_INT 12
11884: PPUSH
11885: LD_INT 1
11887: PPUSH
11888: CALL_OW 55
// CreateCratesArea ( 5 , buildup5 , true ) ;
11892: LD_INT 5
11894: PPUSH
11895: LD_INT 12
11897: PPUSH
11898: LD_INT 1
11900: PPUSH
11901: CALL_OW 55
// end ;
11905: LD_VAR 0 1
11909: RET
// every 1 1$25 trigger test do
11910: LD_EXP 84
11914: IFFALSE 11946
11916: GO 11918
11918: DISABLE
// begin enable ;
11919: ENABLE
// CreateCratesArea ( 5 , buildup5 , true ) ;
11920: LD_INT 5
11922: PPUSH
11923: LD_INT 12
11925: PPUSH
11926: LD_INT 1
11928: PPUSH
11929: CALL_OW 55
// CreateCratesArea ( 5 , buildup5 , true ) ;
11933: LD_INT 5
11935: PPUSH
11936: LD_INT 12
11938: PPUSH
11939: LD_INT 1
11941: PPUSH
11942: CALL_OW 55
// end ;
11946: END
