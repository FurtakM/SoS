// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 61 , 121 ) ;
   4: LD_INT 61
   6: PPUSH
   7: LD_INT 121
   9: PPUSH
  10: CALL_OW 86
// AnimateTrees ( true ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 573
// GameType ;
  21: CALL 314 0 0
// PrepareAmerican ;
  25: CALL 684 0 0
// if game_type = 2 then
  29: LD_EXP 1
  33: PUSH
  34: LD_INT 2
  36: EQUAL
  37: IFFALSE 43
// PrepareRussian ;
  39: CALL 6959 0 0
// GameStarted ;
  43: CALL 488 0 0
// end ;
  47: END
// every 0 0$01 trigger game_type do var sib , side ;
  48: LD_EXP 1
  52: IFFALSE 170
  54: GO 56
  56: DISABLE
  57: LD_INT 0
  59: PPUSH
  60: PPUSH
// begin enable ;
  61: ENABLE
// if game_type = 1 then
  62: LD_EXP 1
  66: PUSH
  67: LD_INT 1
  69: EQUAL
  70: IFFALSE 82
// side := 1 else
  72: LD_ADDR_VAR 0 2
  76: PUSH
  77: LD_INT 1
  79: ST_TO_ADDR
  80: GO 90
// side := 3 ;
  82: LD_ADDR_VAR 0 2
  86: PUSH
  87: LD_INT 3
  89: ST_TO_ADDR
// sib := GetSibAmount ( side ) ;
  90: LD_ADDR_VAR 0 1
  94: PUSH
  95: LD_VAR 0 2
  99: PPUSH
 100: CALL 10494 0 1
 104: ST_TO_ADDR
// if sib < 0 then
 105: LD_VAR 0 1
 109: PUSH
 110: LD_INT 0
 112: LESS
 113: IFFALSE 123
// sib := 0 ;
 115: LD_ADDR_VAR 0 1
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// display_strings := [ #tick , timer , #sib , sib , need_to_win ] ;
 123: LD_ADDR_OWVAR 47
 127: PUSH
 128: LD_STRING #tick
 130: PUSH
 131: LD_EXP 6
 135: PUSH
 136: LD_STRING #sib
 138: PUSH
 139: LD_VAR 0 1
 143: PUSH
 144: LD_EXP 5
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: LIST
 153: LIST
 154: LIST
 155: ST_TO_ADDR
// timer := timer + 0 0$01 ;
 156: LD_ADDR_EXP 6
 160: PUSH
 161: LD_EXP 6
 165: PUSH
 166: LD_INT 35
 168: PLUS
 169: ST_TO_ADDR
// end ;
 170: PPOPN 2
 172: END
// every 1 do
 173: GO 175
 175: DISABLE
// begin while ( true ) do
 176: LD_INT 1
 178: IFFALSE 313
// begin music_nat := 1 ;
 180: LD_ADDR_OWVAR 71
 184: PUSH
 185: LD_INT 1
 187: ST_TO_ADDR
// music_class := 5 ;
 188: LD_ADDR_OWVAR 72
 192: PUSH
 193: LD_INT 5
 195: ST_TO_ADDR
// Wait ( Rand ( 3 3$30 , 5 5$00 ) ) ;
 196: LD_INT 7350
 198: PPUSH
 199: LD_INT 10500
 201: PPUSH
 202: CALL_OW 12
 206: PPUSH
 207: CALL_OW 67
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 211: LD_ADDR_OWVAR 71
 215: PUSH
 216: LD_INT 1
 218: PUSH
 219: LD_INT 3
 221: PUSH
 222: EMPTY
 223: LIST
 224: LIST
 225: PUSH
 226: LD_INT 1
 228: PPUSH
 229: LD_INT 2
 231: PPUSH
 232: CALL_OW 12
 236: ARRAY
 237: ST_TO_ADDR
// music_class := 0 ;
 238: LD_ADDR_OWVAR 72
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// Wait ( Rand ( 3 3$30 , 5 5$00 ) ) ;
 246: LD_INT 7350
 248: PPUSH
 249: LD_INT 10500
 251: PPUSH
 252: CALL_OW 12
 256: PPUSH
 257: CALL_OW 67
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 261: LD_ADDR_OWVAR 71
 265: PUSH
 266: LD_INT 1
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: PUSH
 276: LD_INT 1
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 12
 286: ARRAY
 287: ST_TO_ADDR
// music_class := 0 ;
 288: LD_ADDR_OWVAR 72
 292: PUSH
 293: LD_INT 0
 295: ST_TO_ADDR
// Wait ( Rand ( 3 3$30 , 5 5$00 ) ) ;
 296: LD_INT 7350
 298: PPUSH
 299: LD_INT 10500
 301: PPUSH
 302: CALL_OW 12
 306: PPUSH
 307: CALL_OW 67
// end ;
 311: GO 176
// end ; end_of_file
 313: END
// export game_type , game_diff , game_skill , game_eskill ; export function GameType ; begin
 314: LD_INT 0
 316: PPUSH
// game_diff := GetMultiplayerSetting ( 0 ) ;
 317: LD_ADDR_EXP 2
 321: PUSH
 322: LD_INT 0
 324: PPUSH
 325: CALL_OW 426
 329: ST_TO_ADDR
// game_type := GetMultiplayerSetting ( 1 ) ;
 330: LD_ADDR_EXP 1
 334: PUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 426
 342: ST_TO_ADDR
// if not game_diff then
 343: LD_EXP 2
 347: NOT
 348: IFFALSE 358
// game_diff := 2 ;
 350: LD_ADDR_EXP 2
 354: PUSH
 355: LD_INT 2
 357: ST_TO_ADDR
// if not game_type then
 358: LD_EXP 1
 362: NOT
 363: IFFALSE 373
// game_type := 1 ;
 365: LD_ADDR_EXP 1
 369: PUSH
 370: LD_INT 1
 372: ST_TO_ADDR
// if game_type = 1 then
 373: LD_EXP 1
 377: PUSH
 378: LD_INT 1
 380: EQUAL
 381: IFFALSE 403
// case Query ( GameRulesAm ) of 1 :
 383: LD_STRING GameRulesAm
 385: PPUSH
 386: CALL_OW 97
 390: PUSH
 391: LD_INT 1
 393: DOUBLE
 394: EQUAL
 395: IFTRUE 399
 397: GO 402
 399: POP
// ; end ;
 400: GO 403
 402: POP
// if game_type = 2 then
 403: LD_EXP 1
 407: PUSH
 408: LD_INT 2
 410: EQUAL
 411: IFFALSE 433
// case Query ( GameRulesRu ) of 1 :
 413: LD_STRING GameRulesRu
 415: PPUSH
 416: CALL_OW 97
 420: PUSH
 421: LD_INT 1
 423: DOUBLE
 424: EQUAL
 425: IFTRUE 429
 427: GO 432
 429: POP
// ; end ;
 430: GO 433
 432: POP
// game_skill := [ 6 , 4 , 2 ] [ game_diff ] ;
 433: LD_ADDR_EXP 3
 437: PUSH
 438: LD_INT 6
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_EXP 2
 456: ARRAY
 457: ST_TO_ADDR
// game_eskill := [ 4 , 5 , 6 ] [ game_diff ] ;
 458: LD_ADDR_EXP 4
 462: PUSH
 463: LD_INT 4
 465: PUSH
 466: LD_INT 5
 468: PUSH
 469: LD_INT 6
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_EXP 2
 481: ARRAY
 482: ST_TO_ADDR
// end ;
 483: LD_VAR 0 1
 487: RET
// export need_to_win , timer , force_timer , depot_captured ; export function GameStarted ; begin
 488: LD_INT 0
 490: PPUSH
// if game_type = 1 then
 491: LD_EXP 1
 495: PUSH
 496: LD_INT 1
 498: EQUAL
 499: IFFALSE 568
// begin need_to_win := [ 350 , 375 , 400 ] [ game_diff ] ;
 501: LD_ADDR_EXP 5
 505: PUSH
 506: LD_INT 350
 508: PUSH
 509: LD_INT 375
 511: PUSH
 512: LD_INT 400
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: PUSH
 520: LD_EXP 2
 524: ARRAY
 525: ST_TO_ADDR
// force_timer := [ 95 , 100 , 105 ] [ game_diff ] ;
 526: LD_ADDR_EXP 7
 530: PUSH
 531: LD_INT 95
 533: PUSH
 534: LD_INT 100
 536: PUSH
 537: LD_INT 105
 539: PUSH
 540: EMPTY
 541: LIST
 542: LIST
 543: LIST
 544: PUSH
 545: LD_EXP 2
 549: ARRAY
 550: ST_TO_ADDR
// CenterNowOnXY ( 84 , 45 ) ;
 551: LD_INT 84
 553: PPUSH
 554: LD_INT 45
 556: PPUSH
 557: CALL_OW 86
// ChangeMissionObjectives ( GType1 ) ;
 561: LD_STRING GType1
 563: PPUSH
 564: CALL_OW 337
// end ; if game_type = 2 then
 568: LD_EXP 1
 572: PUSH
 573: LD_INT 2
 575: EQUAL
 576: IFFALSE 658
// begin need_to_win := [ 300 , 350 , 400 ] [ game_diff ] ;
 578: LD_ADDR_EXP 5
 582: PUSH
 583: LD_INT 300
 585: PUSH
 586: LD_INT 350
 588: PUSH
 589: LD_INT 400
 591: PUSH
 592: EMPTY
 593: LIST
 594: LIST
 595: LIST
 596: PUSH
 597: LD_EXP 2
 601: ARRAY
 602: ST_TO_ADDR
// depot_captured := false ;
 603: LD_ADDR_EXP 8
 607: PUSH
 608: LD_INT 0
 610: ST_TO_ADDR
// CenterNowOnUnits ( ru_dow ) ;
 611: LD_EXP 18
 615: PPUSH
 616: CALL_OW 87
// ChangeMissionObjectives ( GType2 ) ;
 620: LD_STRING GType2
 622: PPUSH
 623: CALL_OW 337
// Wait ( 0 0$03 ) ;
 627: LD_INT 105
 629: PPUSH
 630: CALL_OW 67
// SayRadio ( gorki , D-gorky1 ) ;
 634: LD_EXP 19
 638: PPUSH
 639: LD_STRING D-gorky1
 641: PPUSH
 642: CALL_OW 94
// Say ( ru_dow , D-rudow1 ) ;
 646: LD_EXP 18
 650: PPUSH
 651: LD_STRING D-rudow1
 653: PPUSH
 654: CALL_OW 88
// end ; timer := 0 0$00 ;
 658: LD_ADDR_EXP 6
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// SetWeather ( 2 , 300 , 30 ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 300
 671: PPUSH
 672: LD_INT 30
 674: PPUSH
 675: CALL_OW 550
// end ; end_of_file
 679: LD_VAR 0 1
 683: RET
// export am_comander ; export ai_build , ai_vehs , ai_tech ; export function PrepareAmerican ; var i , un , filter , list , p ; begin
 684: LD_INT 0
 686: PPUSH
 687: PPUSH
 688: PPUSH
 689: PPUSH
 690: PPUSH
 691: PPUSH
// SetBName ( jota_base , jota ) ;
 692: LD_INT 1
 694: PPUSH
 695: LD_STRING jota
 697: PPUSH
 698: CALL_OW 500
// if game_type = 1 then
 702: LD_EXP 1
 706: PUSH
 707: LD_INT 1
 709: EQUAL
 710: IFFALSE 1230
// begin your_side := 1 ;
 712: LD_ADDR_OWVAR 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// list := [ west_bun1 , east_bun , am_gun ] ;
 720: LD_ADDR_VAR 0 5
 724: PUSH
 725: LD_INT 29
 727: PUSH
 728: LD_INT 35
 730: PUSH
 731: LD_INT 21
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: ST_TO_ADDR
// if game_diff = 1 then
 739: LD_EXP 2
 743: PUSH
 744: LD_INT 1
 746: EQUAL
 747: IFFALSE 762
// SetTech ( tech_comp1 , 3 , state_researched ) ;
 749: LD_INT 57
 751: PPUSH
 752: LD_INT 3
 754: PPUSH
 755: LD_INT 2
 757: PPUSH
 758: CALL_OW 322
// if game_diff = 2 then
 762: LD_EXP 2
 766: PUSH
 767: LD_INT 2
 769: EQUAL
 770: IFFALSE 785
// SetTech ( tech_comp2 , 3 , state_researched ) ;
 772: LD_INT 58
 774: PPUSH
 775: LD_INT 3
 777: PPUSH
 778: LD_INT 2
 780: PPUSH
 781: CALL_OW 322
// if game_diff = 3 then
 785: LD_EXP 2
 789: PUSH
 790: LD_INT 3
 792: EQUAL
 793: IFFALSE 808
// SetTech ( tech_comp3 , 3 , state_researched ) ;
 795: LD_INT 59
 797: PPUSH
 798: LD_INT 3
 800: PPUSH
 801: LD_INT 2
 803: PPUSH
 804: CALL_OW 322
// for i = 1 to list do
 808: LD_ADDR_VAR 0 2
 812: PUSH
 813: DOUBLE
 814: LD_INT 1
 816: DEC
 817: ST_TO_ADDR
 818: LD_VAR 0 5
 822: PUSH
 823: FOR_TO
 824: IFFALSE 843
// RemoveUnit ( list [ i ] ) ;
 826: LD_VAR 0 5
 830: PUSH
 831: LD_VAR 0 2
 835: ARRAY
 836: PPUSH
 837: CALL_OW 64
 841: GO 823
 843: POP
 844: POP
// ResetFog ;
 845: CALL_OW 335
// uc_side := 1 ;
 849: LD_ADDR_OWVAR 20
 853: PUSH
 854: LD_INT 1
 856: ST_TO_ADDR
// uc_nation := 1 ;
 857: LD_ADDR_OWVAR 21
 861: PUSH
 862: LD_INT 1
 864: ST_TO_ADDR
// for i = 1 to 4 - ( game_diff ) do
 865: LD_ADDR_VAR 0 2
 869: PUSH
 870: DOUBLE
 871: LD_INT 1
 873: DEC
 874: ST_TO_ADDR
 875: LD_INT 4
 877: PUSH
 878: LD_EXP 2
 882: MINUS
 883: PUSH
 884: FOR_TO
 885: IFFALSE 938
// begin uc_side := 1 ;
 887: LD_ADDR_OWVAR 20
 891: PUSH
 892: LD_INT 1
 894: ST_TO_ADDR
// uc_nation := 1 ;
 895: LD_ADDR_OWVAR 21
 899: PUSH
 900: LD_INT 1
 902: ST_TO_ADDR
// un := CreateHumanWithClass ( 1 , game_skill ) ;
 903: LD_ADDR_VAR 0 3
 907: PUSH
 908: LD_INT 1
 910: PPUSH
 911: LD_EXP 3
 915: PPUSH
 916: CALL 9249 0 2
 920: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
 921: LD_VAR 0 3
 925: PPUSH
 926: LD_INT 1
 928: PPUSH
 929: LD_INT 0
 931: PPUSH
 932: CALL_OW 49
// end ;
 936: GO 884
 938: POP
 939: POP
// for i = 1 to 5 - ( game_diff ) do
 940: LD_ADDR_VAR 0 2
 944: PUSH
 945: DOUBLE
 946: LD_INT 1
 948: DEC
 949: ST_TO_ADDR
 950: LD_INT 5
 952: PUSH
 953: LD_EXP 2
 957: MINUS
 958: PUSH
 959: FOR_TO
 960: IFFALSE 1013
// begin uc_side := 1 ;
 962: LD_ADDR_OWVAR 20
 966: PUSH
 967: LD_INT 1
 969: ST_TO_ADDR
// uc_nation := 1 ;
 970: LD_ADDR_OWVAR 21
 974: PUSH
 975: LD_INT 1
 977: ST_TO_ADDR
// un := CreateHumanWithClass ( 2 , game_skill ) ;
 978: LD_ADDR_VAR 0 3
 982: PUSH
 983: LD_INT 2
 985: PPUSH
 986: LD_EXP 3
 990: PPUSH
 991: CALL 9249 0 2
 995: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
 996: LD_VAR 0 3
1000: PPUSH
1001: LD_INT 1
1003: PPUSH
1004: LD_INT 0
1006: PPUSH
1007: CALL_OW 49
// end ;
1011: GO 959
1013: POP
1014: POP
// for i = 1 to 5 - ( game_diff ) do
1015: LD_ADDR_VAR 0 2
1019: PUSH
1020: DOUBLE
1021: LD_INT 1
1023: DEC
1024: ST_TO_ADDR
1025: LD_INT 5
1027: PUSH
1028: LD_EXP 2
1032: MINUS
1033: PUSH
1034: FOR_TO
1035: IFFALSE 1088
// begin uc_side := 1 ;
1037: LD_ADDR_OWVAR 20
1041: PUSH
1042: LD_INT 1
1044: ST_TO_ADDR
// uc_nation := 1 ;
1045: LD_ADDR_OWVAR 21
1049: PUSH
1050: LD_INT 1
1052: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , game_skill ) ;
1053: LD_ADDR_VAR 0 3
1057: PUSH
1058: LD_INT 3
1060: PPUSH
1061: LD_EXP 3
1065: PPUSH
1066: CALL 9249 0 2
1070: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1071: LD_VAR 0 3
1075: PPUSH
1076: LD_INT 1
1078: PPUSH
1079: LD_INT 0
1081: PPUSH
1082: CALL_OW 49
// end ;
1086: GO 1034
1088: POP
1089: POP
// for i = 1 to 5 - ( game_diff ) do
1090: LD_ADDR_VAR 0 2
1094: PUSH
1095: DOUBLE
1096: LD_INT 1
1098: DEC
1099: ST_TO_ADDR
1100: LD_INT 5
1102: PUSH
1103: LD_EXP 2
1107: MINUS
1108: PUSH
1109: FOR_TO
1110: IFFALSE 1163
// begin uc_side := 1 ;
1112: LD_ADDR_OWVAR 20
1116: PUSH
1117: LD_INT 1
1119: ST_TO_ADDR
// uc_nation := 1 ;
1120: LD_ADDR_OWVAR 21
1124: PUSH
1125: LD_INT 1
1127: ST_TO_ADDR
// un := CreateHumanWithClass ( 4 , game_skill ) ;
1128: LD_ADDR_VAR 0 3
1132: PUSH
1133: LD_INT 4
1135: PPUSH
1136: LD_EXP 3
1140: PPUSH
1141: CALL 9249 0 2
1145: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1146: LD_VAR 0 3
1150: PPUSH
1151: LD_INT 1
1153: PPUSH
1154: LD_INT 0
1156: PPUSH
1157: CALL_OW 49
// end ;
1161: GO 1109
1163: POP
1164: POP
// hc_importance := 100 ;
1165: LD_ADDR_OWVAR 32
1169: PUSH
1170: LD_INT 100
1172: ST_TO_ADDR
// uc_side := 1 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// uc_nation := 1 ;
1181: LD_ADDR_OWVAR 21
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// am_comander := CreateHumanWithClass ( 1 , game_skill ) ;
1189: LD_ADDR_EXP 9
1193: PUSH
1194: LD_INT 1
1196: PPUSH
1197: LD_EXP 3
1201: PPUSH
1202: CALL 9249 0 2
1206: ST_TO_ADDR
// PlaceUnitArea ( am_comander , am_base , false ) ;
1207: LD_EXP 9
1211: PPUSH
1212: LD_INT 1
1214: PPUSH
1215: LD_INT 0
1217: PPUSH
1218: CALL_OW 49
// hc_importance := 0 ;
1222: LD_ADDR_OWVAR 32
1226: PUSH
1227: LD_INT 0
1229: ST_TO_ADDR
// end ; if game_type = 2 then
1230: LD_EXP 1
1234: PUSH
1235: LD_INT 2
1237: EQUAL
1238: IFFALSE 2403
// begin uc_side := 1 ;
1240: LD_ADDR_OWVAR 20
1244: PUSH
1245: LD_INT 1
1247: ST_TO_ADDR
// uc_nation := 1 ;
1248: LD_ADDR_OWVAR 21
1252: PUSH
1253: LD_INT 1
1255: ST_TO_ADDR
// SetResourceType ( GetBase ( jota_base ) , mat_cans , 1000 ) ;
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 274
1263: PPUSH
1264: LD_INT 1
1266: PPUSH
1267: LD_INT 1000
1269: PPUSH
1270: CALL_OW 277
// SetTech ( tech_sibdet , 1 , state_researched ) ;
1274: LD_INT 20
1276: PPUSH
1277: LD_INT 1
1279: PPUSH
1280: LD_INT 2
1282: PPUSH
1283: CALL_OW 322
// for i = 1 to 4 do
1287: LD_ADDR_VAR 0 2
1291: PUSH
1292: DOUBLE
1293: LD_INT 1
1295: DEC
1296: ST_TO_ADDR
1297: LD_INT 4
1299: PUSH
1300: FOR_TO
1301: IFFALSE 1360
// begin for p = 1 to 5 do
1303: LD_ADDR_VAR 0 6
1307: PUSH
1308: DOUBLE
1309: LD_INT 1
1311: DEC
1312: ST_TO_ADDR
1313: LD_INT 5
1315: PUSH
1316: FOR_TO
1317: IFFALSE 1356
// begin un := CreateHumanWithClass ( i , game_eskill ) ;
1319: LD_ADDR_VAR 0 3
1323: PUSH
1324: LD_VAR 0 2
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 9249 0 2
1338: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1339: LD_VAR 0 3
1343: PPUSH
1344: LD_INT 1
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 49
// end ;
1354: GO 1316
1356: POP
1357: POP
// end ;
1358: GO 1300
1360: POP
1361: POP
// un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1362: LD_ADDR_VAR 0 3
1366: PUSH
1367: LD_INT 5
1369: PPUSH
1370: LD_EXP 4
1374: PPUSH
1375: CALL 9249 0 2
1379: ST_TO_ADDR
// PlaceUnitArea ( un , am_sniper_1 , false ) ;
1380: LD_VAR 0 3
1384: PPUSH
1385: LD_INT 2
1387: PPUSH
1388: LD_INT 0
1390: PPUSH
1391: CALL_OW 49
// ComEnterUnit ( un , west_bun1 ) ;
1395: LD_VAR 0 3
1399: PPUSH
1400: LD_INT 29
1402: PPUSH
1403: CALL_OW 120
// un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1407: LD_ADDR_VAR 0 3
1411: PUSH
1412: LD_INT 5
1414: PPUSH
1415: LD_EXP 4
1419: PPUSH
1420: CALL 9249 0 2
1424: ST_TO_ADDR
// PlaceUnitArea ( un , am_sniper_3 , false ) ;
1425: LD_VAR 0 3
1429: PPUSH
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 49
// ComEnterUnit ( un , base_bun ) ;
1440: LD_VAR 0 3
1444: PPUSH
1445: LD_INT 20
1447: PPUSH
1448: CALL_OW 120
// if game_diff > 1 then
1452: LD_EXP 2
1456: PUSH
1457: LD_INT 1
1459: GREATER
1460: IFFALSE 1604
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1462: LD_ADDR_VAR 0 3
1466: PUSH
1467: LD_INT 5
1469: PPUSH
1470: LD_EXP 4
1474: PPUSH
1475: CALL 9249 0 2
1479: ST_TO_ADDR
// PlaceUnitArea ( un , am_sniper_2 , false ) ;
1480: LD_VAR 0 3
1484: PPUSH
1485: LD_INT 3
1487: PPUSH
1488: LD_INT 0
1490: PPUSH
1491: CALL_OW 49
// for i = 1 to 2 do
1495: LD_ADDR_VAR 0 2
1499: PUSH
1500: DOUBLE
1501: LD_INT 1
1503: DEC
1504: ST_TO_ADDR
1505: LD_INT 2
1507: PUSH
1508: FOR_TO
1509: IFFALSE 1602
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1511: LD_ADDR_VAR 0 3
1515: PUSH
1516: LD_INT 5
1518: PPUSH
1519: LD_EXP 4
1523: PPUSH
1524: CALL 9249 0 2
1528: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1529: LD_VAR 0 3
1533: PPUSH
1534: LD_INT 1
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 49
// ComEnterUnit ( un , FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_armoury ] , [ f_lives , 251 ] ] ] ) [ 1 ] ) ;
1544: LD_VAR 0 3
1548: PPUSH
1549: LD_INT 22
1551: PUSH
1552: LD_INT 1
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: PUSH
1559: LD_INT 30
1561: PUSH
1562: LD_INT 4
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 24
1571: PUSH
1572: LD_INT 251
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: PUSH
1579: EMPTY
1580: LIST
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: PUSH
1592: LD_INT 1
1594: ARRAY
1595: PPUSH
1596: CALL_OW 120
// end ;
1600: GO 1508
1602: POP
1603: POP
// end ; if game_diff > 1 then
1604: LD_EXP 2
1608: PUSH
1609: LD_INT 1
1611: GREATER
1612: IFFALSE 1650
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1614: LD_ADDR_VAR 0 3
1618: PUSH
1619: LD_INT 5
1621: PPUSH
1622: LD_EXP 4
1626: PPUSH
1627: CALL 9249 0 2
1631: ST_TO_ADDR
// PlaceUnitXY ( un , 37 , 44 , false ) ;
1632: LD_VAR 0 3
1636: PPUSH
1637: LD_INT 37
1639: PPUSH
1640: LD_INT 44
1642: PPUSH
1643: LD_INT 0
1645: PPUSH
1646: CALL_OW 48
// end ; if game_diff > 2 then
1650: LD_EXP 2
1654: PUSH
1655: LD_INT 2
1657: GREATER
1658: IFFALSE 1708
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1660: LD_ADDR_VAR 0 3
1664: PUSH
1665: LD_INT 5
1667: PPUSH
1668: LD_EXP 4
1672: PPUSH
1673: CALL 9249 0 2
1677: ST_TO_ADDR
// PlaceUnitXY ( un , 106 , 45 , false ) ;
1678: LD_VAR 0 3
1682: PPUSH
1683: LD_INT 106
1685: PPUSH
1686: LD_INT 45
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// ComEnterUnit ( un , east_bun ) ;
1696: LD_VAR 0 3
1700: PPUSH
1701: LD_INT 35
1703: PPUSH
1704: CALL_OW 120
// end ; if game_diff < 3 then
1708: LD_EXP 2
1712: PUSH
1713: LD_INT 3
1715: LESS
1716: IFFALSE 1725
// RemoveUnit ( east_bun ) ;
1718: LD_INT 35
1720: PPUSH
1721: CALL_OW 64
// if game_diff > 1 then
1725: LD_EXP 2
1729: PUSH
1730: LD_INT 1
1732: GREATER
1733: IFFALSE 1748
// SetTech ( tech_rocket , 1 , state_researched ) ;
1735: LD_INT 40
1737: PPUSH
1738: LD_INT 1
1740: PPUSH
1741: LD_INT 2
1743: PPUSH
1744: CALL_OW 322
// case game_diff of 1 :
1748: LD_EXP 2
1752: PUSH
1753: LD_INT 1
1755: DOUBLE
1756: EQUAL
1757: IFTRUE 1761
1759: GO 1835
1761: POP
// begin ai_build := [ b_oil_power , 78 , 52 , 3 , b_oil_power , 96 , 58 , 0 , b_bunker , 72 , 34 , 3 , b_bunker , 83 , 54 , 0 ] ;
1762: LD_ADDR_EXP 10
1766: PUSH
1767: LD_INT 26
1769: PUSH
1770: LD_INT 78
1772: PUSH
1773: LD_INT 52
1775: PUSH
1776: LD_INT 3
1778: PUSH
1779: LD_INT 26
1781: PUSH
1782: LD_INT 96
1784: PUSH
1785: LD_INT 58
1787: PUSH
1788: LD_INT 0
1790: PUSH
1791: LD_INT 32
1793: PUSH
1794: LD_INT 72
1796: PUSH
1797: LD_INT 34
1799: PUSH
1800: LD_INT 3
1802: PUSH
1803: LD_INT 32
1805: PUSH
1806: LD_INT 83
1808: PUSH
1809: LD_INT 54
1811: PUSH
1812: LD_INT 0
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: ST_TO_ADDR
// end ; 2 :
1833: GO 2112
1835: LD_INT 2
1837: DOUBLE
1838: EQUAL
1839: IFTRUE 1843
1841: GO 1965
1843: POP
// begin ai_build := [ b_ext_rocket , 73 , 42 , 2 , b_oil_power , 78 , 52 , 3 , b_oil_power , 96 , 58 , 0 , b_bunker , 72 , 34 , 3 , b_bunker , 83 , 54 , 0 , b_bunker , 82 , 38 , 2 , b_oil_power , 69 , 39 , 3 ] ;
1844: LD_ADDR_EXP 10
1848: PUSH
1849: LD_INT 18
1851: PUSH
1852: LD_INT 73
1854: PUSH
1855: LD_INT 42
1857: PUSH
1858: LD_INT 2
1860: PUSH
1861: LD_INT 26
1863: PUSH
1864: LD_INT 78
1866: PUSH
1867: LD_INT 52
1869: PUSH
1870: LD_INT 3
1872: PUSH
1873: LD_INT 26
1875: PUSH
1876: LD_INT 96
1878: PUSH
1879: LD_INT 58
1881: PUSH
1882: LD_INT 0
1884: PUSH
1885: LD_INT 32
1887: PUSH
1888: LD_INT 72
1890: PUSH
1891: LD_INT 34
1893: PUSH
1894: LD_INT 3
1896: PUSH
1897: LD_INT 32
1899: PUSH
1900: LD_INT 83
1902: PUSH
1903: LD_INT 54
1905: PUSH
1906: LD_INT 0
1908: PUSH
1909: LD_INT 32
1911: PUSH
1912: LD_INT 82
1914: PUSH
1915: LD_INT 38
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 26
1923: PUSH
1924: LD_INT 69
1926: PUSH
1927: LD_INT 39
1929: PUSH
1930: LD_INT 3
1932: PUSH
1933: EMPTY
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: LIST
1954: LIST
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: ST_TO_ADDR
// end ; 3 :
1963: GO 2112
1965: LD_INT 3
1967: DOUBLE
1968: EQUAL
1969: IFTRUE 1973
1971: GO 2111
1973: POP
// begin ai_build := [ b_ext_rocket , 73 , 42 , 2 , b_oil_power , 78 , 52 , 3 , b_oil_power , 96 , 58 , 0 , b_bunker , 72 , 34 , 3 , b_bunker , 83 , 54 , 0 , b_bunker , 82 , 38 , 2 , b_bunker , 103 , 59 , 3 , b_oil_power , 69 , 39 , 3 ] ;
1974: LD_ADDR_EXP 10
1978: PUSH
1979: LD_INT 18
1981: PUSH
1982: LD_INT 73
1984: PUSH
1985: LD_INT 42
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 26
1993: PUSH
1994: LD_INT 78
1996: PUSH
1997: LD_INT 52
1999: PUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 26
2005: PUSH
2006: LD_INT 96
2008: PUSH
2009: LD_INT 58
2011: PUSH
2012: LD_INT 0
2014: PUSH
2015: LD_INT 32
2017: PUSH
2018: LD_INT 72
2020: PUSH
2021: LD_INT 34
2023: PUSH
2024: LD_INT 3
2026: PUSH
2027: LD_INT 32
2029: PUSH
2030: LD_INT 83
2032: PUSH
2033: LD_INT 54
2035: PUSH
2036: LD_INT 0
2038: PUSH
2039: LD_INT 32
2041: PUSH
2042: LD_INT 82
2044: PUSH
2045: LD_INT 38
2047: PUSH
2048: LD_INT 2
2050: PUSH
2051: LD_INT 32
2053: PUSH
2054: LD_INT 103
2056: PUSH
2057: LD_INT 59
2059: PUSH
2060: LD_INT 3
2062: PUSH
2063: LD_INT 26
2065: PUSH
2066: LD_INT 69
2068: PUSH
2069: LD_INT 39
2071: PUSH
2072: LD_INT 3
2074: PUSH
2075: EMPTY
2076: LIST
2077: LIST
2078: LIST
2079: LIST
2080: LIST
2081: LIST
2082: LIST
2083: LIST
2084: LIST
2085: LIST
2086: LIST
2087: LIST
2088: LIST
2089: LIST
2090: LIST
2091: LIST
2092: LIST
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: LIST
2098: LIST
2099: LIST
2100: LIST
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: ST_TO_ADDR
// end ; end ;
2109: GO 2112
2111: POP
// ai_tech := [ tech_tech1 , tech_oileng , tech_tech2 , tech_weap1 , tech_gatling , tech_weap2 , tech_gun , tech_tech3 ] ;
2112: LD_ADDR_EXP 12
2116: PUSH
2117: LD_INT 48
2119: PUSH
2120: LD_INT 47
2122: PUSH
2123: LD_INT 49
2125: PUSH
2126: LD_INT 51
2128: PUSH
2129: LD_INT 69
2131: PUSH
2132: LD_INT 52
2134: PUSH
2135: LD_INT 39
2137: PUSH
2138: LD_INT 50
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: ST_TO_ADDR
// case game_diff of 1 :
2151: LD_EXP 2
2155: PUSH
2156: LD_INT 1
2158: DOUBLE
2159: EQUAL
2160: IFTRUE 2164
2162: GO 2238
2164: POP
// begin ai_vehs := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , us_heavy_tracked , engine_combustion , control_manual , us_gatling_gun , us_heavy_tracked , engine_combustion , control_manual , us_double_gun , us_heavy_tracked , engine_combustion , control_manual , us_gatling_gun ] ;
2165: LD_ADDR_EXP 11
2169: PUSH
2170: LD_INT 3
2172: PUSH
2173: LD_INT 1
2175: PUSH
2176: LD_INT 1
2178: PUSH
2179: LD_INT 12
2181: PUSH
2182: LD_INT 4
2184: PUSH
2185: LD_INT 1
2187: PUSH
2188: LD_INT 1
2190: PUSH
2191: LD_INT 4
2193: PUSH
2194: LD_INT 4
2196: PUSH
2197: LD_INT 1
2199: PUSH
2200: LD_INT 1
2202: PUSH
2203: LD_INT 5
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: LD_INT 1
2211: PUSH
2212: LD_INT 1
2214: PUSH
2215: LD_INT 4
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: LIST
2222: LIST
2223: LIST
2224: LIST
2225: LIST
2226: LIST
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: LIST
2232: LIST
2233: LIST
2234: LIST
2235: ST_TO_ADDR
// end ; 2 :
2236: GO 2403
2238: LD_INT 2
2240: DOUBLE
2241: EQUAL
2242: IFTRUE 2246
2244: GO 2320
2246: POP
// begin ai_vehs := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_manual , us_double_gun , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] ;
2247: LD_ADDR_EXP 11
2251: PUSH
2252: LD_INT 3
2254: PUSH
2255: LD_INT 1
2257: PUSH
2258: LD_INT 1
2260: PUSH
2261: LD_INT 12
2263: PUSH
2264: LD_INT 4
2266: PUSH
2267: LD_INT 1
2269: PUSH
2270: LD_INT 1
2272: PUSH
2273: LD_INT 7
2275: PUSH
2276: LD_INT 4
2278: PUSH
2279: LD_INT 1
2281: PUSH
2282: LD_INT 1
2284: PUSH
2285: LD_INT 5
2287: PUSH
2288: LD_INT 4
2290: PUSH
2291: LD_INT 1
2293: PUSH
2294: LD_INT 1
2296: PUSH
2297: LD_INT 7
2299: PUSH
2300: EMPTY
2301: LIST
2302: LIST
2303: LIST
2304: LIST
2305: LIST
2306: LIST
2307: LIST
2308: LIST
2309: LIST
2310: LIST
2311: LIST
2312: LIST
2313: LIST
2314: LIST
2315: LIST
2316: LIST
2317: ST_TO_ADDR
// end ; 3 :
2318: GO 2403
2320: LD_INT 3
2322: DOUBLE
2323: EQUAL
2324: IFTRUE 2328
2326: GO 2402
2328: POP
// begin ai_vehs := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] ;
2329: LD_ADDR_EXP 11
2333: PUSH
2334: LD_INT 3
2336: PUSH
2337: LD_INT 1
2339: PUSH
2340: LD_INT 1
2342: PUSH
2343: LD_INT 12
2345: PUSH
2346: LD_INT 4
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 1
2354: PUSH
2355: LD_INT 7
2357: PUSH
2358: LD_INT 4
2360: PUSH
2361: LD_INT 1
2363: PUSH
2364: LD_INT 1
2366: PUSH
2367: LD_INT 7
2369: PUSH
2370: LD_INT 4
2372: PUSH
2373: LD_INT 1
2375: PUSH
2376: LD_INT 1
2378: PUSH
2379: LD_INT 7
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: ST_TO_ADDR
// end ; end ;
2400: GO 2403
2402: POP
// end ; end ;
2403: LD_VAR 0 1
2407: RET
// export sold_ocp ; export tower_list ; every 0 0$01 do
2408: GO 2410
2410: DISABLE
// begin sold_ocp := [ ] ;
2411: LD_ADDR_EXP 13
2415: PUSH
2416: EMPTY
2417: ST_TO_ADDR
// tower_list := [ ] ;
2418: LD_ADDR_EXP 14
2422: PUSH
2423: EMPTY
2424: ST_TO_ADDR
// end ;
2425: END
// every 0 0$01 trigger game_type = 2 and depot_captured = false do var i , un , sold , filter , sold_em , engs , mechs , sci , empty_towers , towers , damage_pep , damage_build , damage_vehs ;
2426: LD_EXP 1
2430: PUSH
2431: LD_INT 2
2433: EQUAL
2434: PUSH
2435: LD_EXP 8
2439: PUSH
2440: LD_INT 0
2442: EQUAL
2443: AND
2444: IFFALSE 4121
2446: GO 2448
2448: DISABLE
2449: LD_INT 0
2451: PPUSH
2452: PPUSH
2453: PPUSH
2454: PPUSH
2455: PPUSH
2456: PPUSH
2457: PPUSH
2458: PPUSH
2459: PPUSH
2460: PPUSH
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// sold := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 1 ] , [ f_lives , 650 ] ] ] ) ;
2465: LD_ADDR_VAR 0 3
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 25
2482: PUSH
2483: LD_INT 1
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 24
2492: PUSH
2493: LD_INT 650
2495: PUSH
2496: EMPTY
2497: LIST
2498: LIST
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: LIST
2504: PUSH
2505: EMPTY
2506: LIST
2507: PPUSH
2508: CALL_OW 69
2512: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ] ) ;
2513: LD_ADDR_VAR 0 6
2517: PUSH
2518: LD_INT 22
2520: PUSH
2521: LD_INT 1
2523: PUSH
2524: EMPTY
2525: LIST
2526: LIST
2527: PUSH
2528: LD_INT 25
2530: PUSH
2531: LD_INT 2
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: LD_INT 24
2540: PUSH
2541: LD_INT 650
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: PPUSH
2556: CALL_OW 69
2560: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_lives , 650 ] ] ] ) ;
2561: LD_ADDR_VAR 0 7
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 1
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PUSH
2576: LD_INT 25
2578: PUSH
2579: LD_INT 3
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: PUSH
2586: LD_INT 24
2588: PUSH
2589: LD_INT 650
2591: PUSH
2592: EMPTY
2593: LIST
2594: LIST
2595: PUSH
2596: EMPTY
2597: LIST
2598: LIST
2599: LIST
2600: PUSH
2601: EMPTY
2602: LIST
2603: PPUSH
2604: CALL_OW 69
2608: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_lives , 650 ] ] ] ) ;
2609: LD_ADDR_VAR 0 8
2613: PUSH
2614: LD_INT 22
2616: PUSH
2617: LD_INT 1
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 25
2626: PUSH
2627: LD_INT 4
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: LD_INT 24
2636: PUSH
2637: LD_INT 650
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: LIST
2648: PUSH
2649: EMPTY
2650: LIST
2651: PPUSH
2652: CALL_OW 69
2656: ST_TO_ADDR
// empty_towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] , [ f_lives , 251 ] ] ) ;
2657: LD_ADDR_VAR 0 9
2661: PUSH
2662: LD_INT 22
2664: PUSH
2665: LD_INT 1
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PUSH
2672: LD_INT 30
2674: PUSH
2675: LD_INT 32
2677: PUSH
2678: EMPTY
2679: LIST
2680: LIST
2681: PUSH
2682: LD_INT 58
2684: PUSH
2685: EMPTY
2686: LIST
2687: PUSH
2688: LD_INT 24
2690: PUSH
2691: LD_INT 251
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: LIST
2702: LIST
2703: PPUSH
2704: CALL_OW 69
2708: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_gatling_gun ] ] , [ f_lives , 251 ] ] ] ) ;
2709: LD_ADDR_VAR 0 10
2713: PUSH
2714: LD_INT 22
2716: PUSH
2717: LD_INT 1
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: PUSH
2724: LD_INT 30
2726: PUSH
2727: LD_INT 32
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PUSH
2734: LD_INT 2
2736: PUSH
2737: LD_INT 35
2739: PUSH
2740: LD_INT 7
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: PUSH
2747: LD_INT 35
2749: PUSH
2750: LD_INT 4
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 24
2764: PUSH
2765: LD_INT 251
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: PPUSH
2781: CALL_OW 69
2785: ST_TO_ADDR
// damage_pep := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 650 ] ] ] ] ) ;
2786: LD_ADDR_VAR 0 11
2790: PUSH
2791: LD_INT 22
2793: PUSH
2794: LD_INT 1
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: PUSH
2801: LD_INT 21
2803: PUSH
2804: LD_INT 1
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 3
2813: PUSH
2814: LD_INT 24
2816: PUSH
2817: LD_INT 650
2819: PUSH
2820: EMPTY
2821: LIST
2822: LIST
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: LIST
2832: PUSH
2833: EMPTY
2834: LIST
2835: PPUSH
2836: CALL_OW 69
2840: ST_TO_ADDR
// damage_build := FilterUnitsInArea ( def_area , [ [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
2841: LD_ADDR_VAR 0 12
2845: PUSH
2846: LD_INT 11
2848: PPUSH
2849: LD_INT 22
2851: PUSH
2852: LD_INT 1
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 21
2861: PUSH
2862: LD_INT 3
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PUSH
2869: LD_INT 3
2871: PUSH
2872: LD_INT 24
2874: PUSH
2875: LD_INT 1000
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: LIST
2890: PUSH
2891: EMPTY
2892: LIST
2893: PPUSH
2894: CALL_OW 70
2898: ST_TO_ADDR
// damage_vehs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 650 ] ] ] ] ) ;
2899: LD_ADDR_VAR 0 13
2903: PUSH
2904: LD_INT 22
2906: PUSH
2907: LD_INT 1
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: PUSH
2914: LD_INT 21
2916: PUSH
2917: LD_INT 2
2919: PUSH
2920: EMPTY
2921: LIST
2922: LIST
2923: PUSH
2924: LD_INT 3
2926: PUSH
2927: LD_INT 24
2929: PUSH
2930: LD_INT 650
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PUSH
2941: EMPTY
2942: LIST
2943: LIST
2944: LIST
2945: PUSH
2946: EMPTY
2947: LIST
2948: PPUSH
2949: CALL_OW 69
2953: ST_TO_ADDR
// if GetResourceType ( GetBase ( jota_base ) , mat_oil ) <= 30 then
2954: LD_INT 1
2956: PPUSH
2957: CALL_OW 274
2961: PPUSH
2962: LD_INT 2
2964: PPUSH
2965: CALL_OW 275
2969: PUSH
2970: LD_INT 30
2972: LESSEQUAL
2973: IFFALSE 2993
// SetResourceType ( GetBase ( jota_base ) , mat_oil , 100 ) ;
2975: LD_INT 1
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 2
2985: PPUSH
2986: LD_INT 100
2988: PPUSH
2989: CALL_OW 277
// sold_em := ( sold diff sold_ocp ) ;
2993: LD_ADDR_VAR 0 5
2997: PUSH
2998: LD_VAR 0 3
3002: PUSH
3003: LD_EXP 13
3007: DIFF
3008: ST_TO_ADDR
// if sold > 0 then
3009: LD_VAR 0 3
3013: PUSH
3014: LD_INT 0
3016: GREATER
3017: IFFALSE 3139
// for i = 1 to sold_em do
3019: LD_ADDR_VAR 0 1
3023: PUSH
3024: DOUBLE
3025: LD_INT 1
3027: DEC
3028: ST_TO_ADDR
3029: LD_VAR 0 5
3033: PUSH
3034: FOR_TO
3035: IFFALSE 3137
// if empty_towers > 0 then
3037: LD_VAR 0 9
3041: PUSH
3042: LD_INT 0
3044: GREATER
3045: IFFALSE 3073
// ComEnterUnit ( sold_em [ i ] , empty_towers [ 1 ] ) else
3047: LD_VAR 0 5
3051: PUSH
3052: LD_VAR 0 1
3056: ARRAY
3057: PPUSH
3058: LD_VAR 0 9
3062: PUSH
3063: LD_INT 1
3065: ARRAY
3066: PPUSH
3067: CALL_OW 120
3071: GO 3135
// ComEnterUnit ( sold_em [ i ] , FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_armoury ] , [ f_lives , 251 ] ] ] ) [ 1 ] ) ;
3073: LD_VAR 0 5
3077: PUSH
3078: LD_VAR 0 1
3082: ARRAY
3083: PPUSH
3084: LD_INT 22
3086: PUSH
3087: LD_INT 1
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 30
3096: PUSH
3097: LD_INT 4
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 24
3106: PUSH
3107: LD_INT 251
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: PUSH
3119: EMPTY
3120: LIST
3121: PPUSH
3122: CALL_OW 69
3126: PUSH
3127: LD_INT 1
3129: ARRAY
3130: PPUSH
3131: CALL_OW 120
3135: GO 3034
3137: POP
3138: POP
// if mechs > 0 then
3139: LD_VAR 0 7
3143: PUSH
3144: LD_INT 0
3146: GREATER
3147: IFFALSE 3225
// for i = 1 to mechs do
3149: LD_ADDR_VAR 0 1
3153: PUSH
3154: DOUBLE
3155: LD_INT 1
3157: DEC
3158: ST_TO_ADDR
3159: LD_VAR 0 7
3163: PUSH
3164: FOR_TO
3165: IFFALSE 3223
// if not IsInUnit ( mechs [ i ] ) and not HasTask ( mechs [ i ] ) then
3167: LD_VAR 0 7
3171: PUSH
3172: LD_VAR 0 1
3176: ARRAY
3177: PPUSH
3178: CALL_OW 310
3182: NOT
3183: PUSH
3184: LD_VAR 0 7
3188: PUSH
3189: LD_VAR 0 1
3193: ARRAY
3194: PPUSH
3195: CALL_OW 314
3199: NOT
3200: AND
3201: IFFALSE 3221
// ComEnterUnit ( mechs [ i ] , am_fac ) ;
3203: LD_VAR 0 7
3207: PUSH
3208: LD_VAR 0 1
3212: ARRAY
3213: PPUSH
3214: LD_INT 14
3216: PPUSH
3217: CALL_OW 120
3221: GO 3164
3223: POP
3224: POP
// if sci > 0 then
3225: LD_VAR 0 8
3229: PUSH
3230: LD_INT 0
3232: GREATER
3233: IFFALSE 3303
// for i = 1 to sci do
3235: LD_ADDR_VAR 0 1
3239: PUSH
3240: DOUBLE
3241: LD_INT 1
3243: DEC
3244: ST_TO_ADDR
3245: LD_VAR 0 8
3249: PUSH
3250: FOR_TO
3251: IFFALSE 3301
// if damage_pep = 0 and not HasTask ( sci [ i ] ) then
3253: LD_VAR 0 11
3257: PUSH
3258: LD_INT 0
3260: EQUAL
3261: PUSH
3262: LD_VAR 0 8
3266: PUSH
3267: LD_VAR 0 1
3271: ARRAY
3272: PPUSH
3273: CALL_OW 314
3277: NOT
3278: AND
3279: IFFALSE 3299
// ComEnterUnit ( sci [ i ] , am_lab ) ;
3281: LD_VAR 0 8
3285: PUSH
3286: LD_VAR 0 1
3290: ARRAY
3291: PPUSH
3292: LD_INT 9
3294: PPUSH
3295: CALL_OW 120
3299: GO 3250
3301: POP
3302: POP
// if damage_build > 0 then
3303: LD_VAR 0 12
3307: PUSH
3308: LD_INT 0
3310: GREATER
3311: IFFALSE 3359
// for i = 1 to engs do
3313: LD_ADDR_VAR 0 1
3317: PUSH
3318: DOUBLE
3319: LD_INT 1
3321: DEC
3322: ST_TO_ADDR
3323: LD_VAR 0 6
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3357
// ComRepairBuilding ( engs [ i ] , damage_build [ 1 ] ) ;
3331: LD_VAR 0 6
3335: PUSH
3336: LD_VAR 0 1
3340: ARRAY
3341: PPUSH
3342: LD_VAR 0 12
3346: PUSH
3347: LD_INT 1
3349: ARRAY
3350: PPUSH
3351: CALL_OW 130
3355: GO 3328
3357: POP
3358: POP
// if ai_build > 0 then
3359: LD_EXP 10
3363: PUSH
3364: LD_INT 0
3366: GREATER
3367: IFFALSE 3460
// for i = 1 to engs do
3369: LD_ADDR_VAR 0 1
3373: PUSH
3374: DOUBLE
3375: LD_INT 1
3377: DEC
3378: ST_TO_ADDR
3379: LD_VAR 0 6
3383: PUSH
3384: FOR_TO
3385: IFFALSE 3458
// if not HasTask ( engs [ i ] ) then
3387: LD_VAR 0 6
3391: PUSH
3392: LD_VAR 0 1
3396: ARRAY
3397: PPUSH
3398: CALL_OW 314
3402: NOT
3403: IFFALSE 3456
// ComBuild ( engs [ i ] , ai_build [ 1 ] , ai_build [ 2 ] , ai_build [ 3 ] , ai_build [ 4 ] ) ;
3405: LD_VAR 0 6
3409: PUSH
3410: LD_VAR 0 1
3414: ARRAY
3415: PPUSH
3416: LD_EXP 10
3420: PUSH
3421: LD_INT 1
3423: ARRAY
3424: PPUSH
3425: LD_EXP 10
3429: PUSH
3430: LD_INT 2
3432: ARRAY
3433: PPUSH
3434: LD_EXP 10
3438: PUSH
3439: LD_INT 3
3441: ARRAY
3442: PPUSH
3443: LD_EXP 10
3447: PUSH
3448: LD_INT 4
3450: ARRAY
3451: PPUSH
3452: CALL_OW 145
3456: GO 3384
3458: POP
3459: POP
// if damage_pep > 0 and sci > 0 then
3460: LD_VAR 0 11
3464: PUSH
3465: LD_INT 0
3467: GREATER
3468: PUSH
3469: LD_VAR 0 8
3473: PUSH
3474: LD_INT 0
3476: GREATER
3477: AND
3478: IFFALSE 3664
// begin for i = 1 to sci do
3480: LD_ADDR_VAR 0 1
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_VAR 0 8
3494: PUSH
3495: FOR_TO
3496: IFFALSE 3515
// ComExitBuilding ( sci [ i ] ) ;
3498: LD_VAR 0 8
3502: PUSH
3503: LD_VAR 0 1
3507: ARRAY
3508: PPUSH
3509: CALL_OW 122
3513: GO 3495
3515: POP
3516: POP
// for i = 1 to damage_pep do
3517: LD_ADDR_VAR 0 1
3521: PUSH
3522: DOUBLE
3523: LD_INT 1
3525: DEC
3526: ST_TO_ADDR
3527: LD_VAR 0 11
3531: PUSH
3532: FOR_TO
3533: IFFALSE 3612
// begin if not IsInUnit ( damage_pep [ i ] ) then
3535: LD_VAR 0 11
3539: PUSH
3540: LD_VAR 0 1
3544: ARRAY
3545: PPUSH
3546: CALL_OW 310
3550: NOT
3551: IFFALSE 3568
// ComExitBuilding ( damage_pep [ i ] ) ;
3553: LD_VAR 0 11
3557: PUSH
3558: LD_VAR 0 1
3562: ARRAY
3563: PPUSH
3564: CALL_OW 122
// if not IsInArea ( damage_pep [ i ] , heal_area ) then
3568: LD_VAR 0 11
3572: PUSH
3573: LD_VAR 0 1
3577: ARRAY
3578: PPUSH
3579: LD_INT 9
3581: PPUSH
3582: CALL_OW 308
3586: NOT
3587: IFFALSE 3610
// ComMoveXY ( damage_pep [ i ] , 96 , 52 ) ;
3589: LD_VAR 0 11
3593: PUSH
3594: LD_VAR 0 1
3598: ARRAY
3599: PPUSH
3600: LD_INT 96
3602: PPUSH
3603: LD_INT 52
3605: PPUSH
3606: CALL_OW 111
// end ;
3610: GO 3532
3612: POP
3613: POP
// if damage_pep = 0 then
3614: LD_VAR 0 11
3618: PUSH
3619: LD_INT 0
3621: EQUAL
3622: IFFALSE 3664
// for i = 1 to sci do
3624: LD_ADDR_VAR 0 1
3628: PUSH
3629: DOUBLE
3630: LD_INT 1
3632: DEC
3633: ST_TO_ADDR
3634: LD_VAR 0 8
3638: PUSH
3639: FOR_TO
3640: IFFALSE 3662
// ComEnterUnit ( sci [ i ] , am_lab ) ;
3642: LD_VAR 0 8
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_INT 9
3655: PPUSH
3656: CALL_OW 120
3660: GO 3639
3662: POP
3663: POP
// end ; if ai_tech > 0 then
3664: LD_EXP 12
3668: PUSH
3669: LD_INT 0
3671: GREATER
3672: IFFALSE 3690
// ComResearch ( am_lab , ai_tech [ 1 ] ) ;
3674: LD_INT 9
3676: PPUSH
3677: LD_EXP 12
3681: PUSH
3682: LD_INT 1
3684: ARRAY
3685: PPUSH
3686: CALL_OW 124
// if ai_vehs > 0 then
3690: LD_EXP 11
3694: PUSH
3695: LD_INT 0
3697: GREATER
3698: IFFALSE 3826
// if CanBeConstructed ( am_fac , ai_vehs [ 1 ] , ai_vehs [ 2 ] , ai_vehs [ 3 ] , ai_vehs [ 4 ] ) then
3700: LD_INT 14
3702: PPUSH
3703: LD_EXP 11
3707: PUSH
3708: LD_INT 1
3710: ARRAY
3711: PPUSH
3712: LD_EXP 11
3716: PUSH
3717: LD_INT 2
3719: ARRAY
3720: PPUSH
3721: LD_EXP 11
3725: PUSH
3726: LD_INT 3
3728: ARRAY
3729: PPUSH
3730: LD_EXP 11
3734: PUSH
3735: LD_INT 4
3737: ARRAY
3738: PPUSH
3739: CALL_OW 448
3743: IFFALSE 3826
// begin ComConstruct ( am_fac , ai_vehs [ 1 ] , ai_vehs [ 2 ] , ai_vehs [ 3 ] , ai_vehs [ 4 ] ) ;
3745: LD_INT 14
3747: PPUSH
3748: LD_EXP 11
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: PPUSH
3757: LD_EXP 11
3761: PUSH
3762: LD_INT 2
3764: ARRAY
3765: PPUSH
3766: LD_EXP 11
3770: PUSH
3771: LD_INT 3
3773: ARRAY
3774: PPUSH
3775: LD_EXP 11
3779: PUSH
3780: LD_INT 4
3782: ARRAY
3783: PPUSH
3784: CALL_OW 125
// for i = 1 to 4 do
3788: LD_ADDR_VAR 0 1
3792: PUSH
3793: DOUBLE
3794: LD_INT 1
3796: DEC
3797: ST_TO_ADDR
3798: LD_INT 4
3800: PUSH
3801: FOR_TO
3802: IFFALSE 3824
// ai_vehs := Delete ( ai_vehs , 1 ) ;
3804: LD_ADDR_EXP 11
3808: PUSH
3809: LD_EXP 11
3813: PPUSH
3814: LD_INT 1
3816: PPUSH
3817: CALL_OW 3
3821: ST_TO_ADDR
3822: GO 3801
3824: POP
3825: POP
// end ; if tower_list > 0 then
3826: LD_EXP 14
3830: PUSH
3831: LD_INT 0
3833: GREATER
3834: IFFALSE 3938
// begin if GetTech ( tech_rocket , 1 ) = state_researched then
3836: LD_INT 40
3838: PPUSH
3839: LD_INT 1
3841: PPUSH
3842: CALL_OW 321
3846: PUSH
3847: LD_INT 2
3849: EQUAL
3850: IFFALSE 3888
// begin ComPlaceWeapon ( tower_list [ 1 ] , us_rocket_launcher ) ;
3852: LD_EXP 14
3856: PUSH
3857: LD_INT 1
3859: ARRAY
3860: PPUSH
3861: LD_INT 7
3863: PPUSH
3864: CALL_OW 148
// tower_list := Delete ( tower_list , 1 ) ;
3868: LD_ADDR_EXP 14
3872: PUSH
3873: LD_EXP 14
3877: PPUSH
3878: LD_INT 1
3880: PPUSH
3881: CALL_OW 3
3885: ST_TO_ADDR
// end else
3886: GO 3938
// if GetTech ( tech_gatling , 1 ) = state_researched then
3888: LD_INT 69
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: CALL_OW 321
3898: PUSH
3899: LD_INT 2
3901: EQUAL
3902: IFFALSE 3938
// begin ComPlaceWeapon ( tower_list [ 1 ] , us_gatling_gun ) ;
3904: LD_EXP 14
3908: PUSH
3909: LD_INT 1
3911: ARRAY
3912: PPUSH
3913: LD_INT 4
3915: PPUSH
3916: CALL_OW 148
// tower_list := Delete ( tower_list , 1 ) ;
3920: LD_ADDR_EXP 14
3924: PUSH
3925: LD_EXP 14
3929: PPUSH
3930: LD_INT 1
3932: PPUSH
3933: CALL_OW 3
3937: ST_TO_ADDR
// end ; end ; if damage_vehs > 0 then
3938: LD_VAR 0 13
3942: PUSH
3943: LD_INT 0
3945: GREATER
3946: IFFALSE 4121
// begin for i = 1 to damage_vehs do
3948: LD_ADDR_VAR 0 1
3952: PUSH
3953: DOUBLE
3954: LD_INT 1
3956: DEC
3957: ST_TO_ADDR
3958: LD_VAR 0 13
3962: PUSH
3963: FOR_TO
3964: IFFALSE 4119
// begin un := IsDrivenBy ( damage_vehs [ i ] ) ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_VAR 0 13
3975: PUSH
3976: LD_VAR 0 1
3980: ARRAY
3981: PPUSH
3982: CALL_OW 311
3986: ST_TO_ADDR
// if not IsInArea ( damage_vehs [ i ] , repair_area ) then
3987: LD_VAR 0 13
3991: PUSH
3992: LD_VAR 0 1
3996: ARRAY
3997: PPUSH
3998: LD_INT 10
4000: PPUSH
4001: CALL_OW 308
4005: NOT
4006: IFFALSE 4022
// ComMoveToArea ( un , repair_area ) else
4008: LD_VAR 0 2
4012: PPUSH
4013: LD_INT 10
4015: PPUSH
4016: CALL_OW 113
4020: GO 4117
// begin if IsInUnit ( un ) then
4022: LD_VAR 0 2
4026: PPUSH
4027: CALL_OW 310
4031: IFFALSE 4042
// ComExitVehicle ( un ) ;
4033: LD_VAR 0 2
4037: PPUSH
4038: CALL_OW 121
// Wait ( 0 0$01 ) ;
4042: LD_INT 35
4044: PPUSH
4045: CALL_OW 67
// repeat begin ComRepairVehicle ( un , damage_vehs [ i ] ) ;
4049: LD_VAR 0 2
4053: PPUSH
4054: LD_VAR 0 13
4058: PUSH
4059: LD_VAR 0 1
4063: ARRAY
4064: PPUSH
4065: CALL_OW 129
// Wait ( 0 0$01 ) ;
4069: LD_INT 35
4071: PPUSH
4072: CALL_OW 67
// end ; until GetLives ( damage_vehs [ i ] ) = 1000 ;
4076: LD_VAR 0 13
4080: PUSH
4081: LD_VAR 0 1
4085: ARRAY
4086: PPUSH
4087: CALL_OW 256
4091: PUSH
4092: LD_INT 1000
4094: EQUAL
4095: IFFALSE 4049
// ComEnterUnit ( un , damage_vehs [ i ] ) ;
4097: LD_VAR 0 2
4101: PPUSH
4102: LD_VAR 0 13
4106: PUSH
4107: LD_VAR 0 1
4111: ARRAY
4112: PPUSH
4113: CALL_OW 120
// end ; end ;
4117: GO 3963
4119: POP
4120: POP
// end ; end ;
4121: PPOPN 13
4123: END
// every 0 0$01 trigger game_type = 2 and depot_captured = false do var i , un , filter , enemy ;
4124: LD_EXP 1
4128: PUSH
4129: LD_INT 2
4131: EQUAL
4132: PUSH
4133: LD_EXP 8
4137: PUSH
4138: LD_INT 0
4140: EQUAL
4141: AND
4142: IFFALSE 4321
4144: GO 4146
4146: DISABLE
4147: LD_INT 0
4149: PPUSH
4150: PPUSH
4151: PPUSH
4152: PPUSH
// begin enable ;
4153: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ] ) ;
4154: LD_ADDR_VAR 0 3
4158: PUSH
4159: LD_INT 22
4161: PUSH
4162: LD_INT 1
4164: PUSH
4165: EMPTY
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 21
4171: PUSH
4172: LD_INT 2
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PUSH
4179: LD_INT 24
4181: PUSH
4182: LD_INT 650
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 3
4191: PUSH
4192: LD_INT 34
4194: PUSH
4195: LD_INT 12
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: PUSH
4212: EMPTY
4213: LIST
4214: PPUSH
4215: CALL_OW 69
4219: ST_TO_ADDR
// enemy := FilterUnitsInArea ( def_area , [ f_side , 3 ] ) ;
4220: LD_ADDR_VAR 0 4
4224: PUSH
4225: LD_INT 11
4227: PPUSH
4228: LD_INT 22
4230: PUSH
4231: LD_INT 3
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: PPUSH
4238: CALL_OW 70
4242: ST_TO_ADDR
// if filter > 0 then
4243: LD_VAR 0 3
4247: PUSH
4248: LD_INT 0
4250: GREATER
4251: IFFALSE 4321
// for i = 1 to filter do
4253: LD_ADDR_VAR 0 1
4257: PUSH
4258: DOUBLE
4259: LD_INT 1
4261: DEC
4262: ST_TO_ADDR
4263: LD_VAR 0 3
4267: PUSH
4268: FOR_TO
4269: IFFALSE 4319
// if enemy > 0 then
4271: LD_VAR 0 4
4275: PUSH
4276: LD_INT 0
4278: GREATER
4279: IFFALSE 4317
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
4281: LD_VAR 0 3
4285: PUSH
4286: LD_VAR 0 1
4290: ARRAY
4291: PPUSH
4292: LD_VAR 0 4
4296: PPUSH
4297: LD_VAR 0 3
4301: PUSH
4302: LD_VAR 0 1
4306: ARRAY
4307: PPUSH
4308: CALL_OW 74
4312: PPUSH
4313: CALL_OW 115
4317: GO 4268
4319: POP
4320: POP
// end ;
4321: PPOPN 4
4323: END
// every 0 0$03 trigger game_type = 2 and depot_captured = false do var i , c , p , skr , filter , cargo , dep ;
4324: LD_EXP 1
4328: PUSH
4329: LD_INT 2
4331: EQUAL
4332: PUSH
4333: LD_EXP 8
4337: PUSH
4338: LD_INT 0
4340: EQUAL
4341: AND
4342: IFFALSE 4789
4344: GO 4346
4346: DISABLE
4347: LD_INT 0
4349: PPUSH
4350: PPUSH
4351: PPUSH
4352: PPUSH
4353: PPUSH
4354: PPUSH
4355: PPUSH
// begin enable ;
4356: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 1 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
4357: LD_ADDR_VAR 0 5
4361: PUSH
4362: LD_INT 50
4364: PUSH
4365: EMPTY
4366: LIST
4367: PUSH
4368: LD_INT 22
4370: PUSH
4371: LD_INT 1
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: PUSH
4378: LD_INT 2
4380: PUSH
4381: LD_INT 25
4383: PUSH
4384: LD_INT 2
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: LD_INT 25
4393: PUSH
4394: LD_INT 16
4396: PUSH
4397: EMPTY
4398: LIST
4399: LIST
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: LIST
4410: PPUSH
4411: CALL_OW 69
4415: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_cargo_bay ] , [ f_lives , 650 ] ] ) ;
4416: LD_ADDR_VAR 0 6
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 1
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 34
4433: PUSH
4434: LD_INT 12
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 24
4443: PUSH
4444: LD_INT 650
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: LIST
4455: PPUSH
4456: CALL_OW 69
4460: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4461: LD_ADDR_VAR 0 7
4465: PUSH
4466: LD_INT 22
4468: PUSH
4469: LD_INT 1
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 2
4478: PUSH
4479: LD_INT 30
4481: PUSH
4482: LD_INT 0
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: PUSH
4489: LD_INT 30
4491: PUSH
4492: LD_INT 1
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: LIST
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PPUSH
4508: CALL_OW 69
4512: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_spawn ) ;
4513: LD_ADDR_VAR 0 4
4517: PUSH
4518: LD_INT 7
4520: PPUSH
4521: CALL_OW 435
4525: ST_TO_ADDR
// c = 1 ;
4526: LD_ADDR_VAR 0 2
4530: PUSH
4531: LD_INT 1
4533: ST_TO_ADDR
// if cargo > 0 then
4534: LD_VAR 0 6
4538: PUSH
4539: LD_INT 0
4541: GREATER
4542: IFFALSE 4789
// while c < skr do
4544: LD_VAR 0 2
4548: PUSH
4549: LD_VAR 0 4
4553: LESS
4554: IFFALSE 4789
// begin if cargo > 0 then
4556: LD_VAR 0 6
4560: PUSH
4561: LD_INT 0
4563: GREATER
4564: IFFALSE 4787
// begin if GetFuel ( cargo [ 1 ] ) > 40 then
4566: LD_VAR 0 6
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: CALL_OW 261
4579: PUSH
4580: LD_INT 40
4582: GREATER
4583: IFFALSE 4681
// begin if GetDistXYToSide ( skr [ c ] , skr [ c + 1 ] , 3 ) > 15 and not HasTask ( cargo [ 1 ] ) then
4585: LD_VAR 0 4
4589: PUSH
4590: LD_VAR 0 2
4594: ARRAY
4595: PPUSH
4596: LD_VAR 0 4
4600: PUSH
4601: LD_VAR 0 2
4605: PUSH
4606: LD_INT 1
4608: PLUS
4609: ARRAY
4610: PPUSH
4611: LD_INT 3
4613: PPUSH
4614: CALL 10412 0 3
4618: PUSH
4619: LD_INT 15
4621: GREATER
4622: PUSH
4623: LD_VAR 0 6
4627: PUSH
4628: LD_INT 1
4630: ARRAY
4631: PPUSH
4632: CALL_OW 314
4636: NOT
4637: AND
4638: IFFALSE 4679
// ComCollect ( cargo [ 1 ] , skr [ c ] , skr [ c + 1 ] ) ;
4640: LD_VAR 0 6
4644: PUSH
4645: LD_INT 1
4647: ARRAY
4648: PPUSH
4649: LD_VAR 0 4
4653: PUSH
4654: LD_VAR 0 2
4658: ARRAY
4659: PPUSH
4660: LD_VAR 0 4
4664: PUSH
4665: LD_VAR 0 2
4669: PUSH
4670: LD_INT 1
4672: PLUS
4673: ARRAY
4674: PPUSH
4675: CALL_OW 117
// end else
4679: GO 4773
// begin repeat begin ComMoveXY ( cargo [ 1 ] , GetX ( dep [ 1 ] ) , GetY ( dep [ 1 ] ) ) ;
4681: LD_VAR 0 6
4685: PUSH
4686: LD_INT 1
4688: ARRAY
4689: PPUSH
4690: LD_VAR 0 7
4694: PUSH
4695: LD_INT 1
4697: ARRAY
4698: PPUSH
4699: CALL_OW 250
4703: PPUSH
4704: LD_VAR 0 7
4708: PUSH
4709: LD_INT 1
4711: ARRAY
4712: PPUSH
4713: CALL_OW 251
4717: PPUSH
4718: CALL_OW 111
// Wait ( 0 0$01 ) ;
4722: LD_INT 35
4724: PPUSH
4725: CALL_OW 67
// end until GetDistUnits ( cargo [ 1 ] , dep [ 1 ] ) < 7 ;
4729: LD_VAR 0 6
4733: PUSH
4734: LD_INT 1
4736: ARRAY
4737: PPUSH
4738: LD_VAR 0 7
4742: PUSH
4743: LD_INT 1
4745: ARRAY
4746: PPUSH
4747: CALL_OW 296
4751: PUSH
4752: LD_INT 7
4754: LESS
4755: IFFALSE 4681
// SetFuel ( cargo [ 1 ] , 100 ) ;
4757: LD_VAR 0 6
4761: PUSH
4762: LD_INT 1
4764: ARRAY
4765: PPUSH
4766: LD_INT 100
4768: PPUSH
4769: CALL_OW 240
// end ; c = c + 2 ;
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: LD_VAR 0 2
4782: PUSH
4783: LD_INT 2
4785: PLUS
4786: ST_TO_ADDR
// end ; end ;
4787: GO 4544
// end ;
4789: PPOPN 7
4791: END
// on EnterBuilding ( b , un ) do var i , filter ;
4792: LD_INT 0
4794: PPUSH
4795: PPUSH
// begin if game_type = 2 and depot_captured = false then
4796: LD_EXP 1
4800: PUSH
4801: LD_INT 2
4803: EQUAL
4804: PUSH
4805: LD_EXP 8
4809: PUSH
4810: LD_INT 0
4812: EQUAL
4813: AND
4814: IFFALSE 4868
// begin if b in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
4816: LD_VAR 0 1
4820: PUSH
4821: LD_INT 22
4823: PUSH
4824: LD_INT 1
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: LD_INT 30
4833: PUSH
4834: LD_INT 32
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PPUSH
4845: CALL_OW 69
4849: IN
4850: IFFALSE 4868
// sold_ocp := sold_ocp ^ un ;
4852: LD_ADDR_EXP 13
4856: PUSH
4857: LD_EXP 13
4861: PUSH
4862: LD_VAR 0 2
4866: ADD
4867: ST_TO_ADDR
// end ; end ;
4868: PPOPN 4
4870: END
// on LeaveBuilding ( b , un ) do var i , filter ;
4871: LD_INT 0
4873: PPUSH
4874: PPUSH
// begin if un in sold_ocp then
4875: LD_VAR 0 2
4879: PUSH
4880: LD_EXP 13
4884: IN
4885: IFFALSE 4907
// sold_ocp := Delete ( sold_ocp , un ) ;
4887: LD_ADDR_EXP 13
4891: PUSH
4892: LD_EXP 13
4896: PPUSH
4897: LD_VAR 0 2
4901: PPUSH
4902: CALL_OW 3
4906: ST_TO_ADDR
// end ;
4907: PPOPN 4
4909: END
// on ResearchComplete ( tech , lab ) do var i , filter , un ;
4910: LD_INT 0
4912: PPUSH
4913: PPUSH
4914: PPUSH
// begin if game_type = 2 then
4915: LD_EXP 1
4919: PUSH
4920: LD_INT 2
4922: EQUAL
4923: IFFALSE 4970
// begin if GetSide ( lab ) = 1 then
4925: LD_VAR 0 2
4929: PPUSH
4930: CALL_OW 255
4934: PUSH
4935: LD_INT 1
4937: EQUAL
4938: IFFALSE 4970
// if tech in ai_tech then
4940: LD_VAR 0 1
4944: PUSH
4945: LD_EXP 12
4949: IN
4950: IFFALSE 4970
// ai_tech := Delete ( ai_tech , 1 ) ;
4952: LD_ADDR_EXP 12
4956: PUSH
4957: LD_EXP 12
4961: PPUSH
4962: LD_INT 1
4964: PPUSH
4965: CALL_OW 3
4969: ST_TO_ADDR
// end ; end ;
4970: PPOPN 5
4972: END
// on BuildingComplete ( b ) do var i , side , un ;
4973: LD_INT 0
4975: PPUSH
4976: PPUSH
4977: PPUSH
// begin if game_type = 2 and depot_captured = false then
4978: LD_EXP 1
4982: PUSH
4983: LD_INT 2
4985: EQUAL
4986: PUSH
4987: LD_EXP 8
4991: PUSH
4992: LD_INT 0
4994: EQUAL
4995: AND
4996: IFFALSE 5103
// begin if GetSide ( b ) = 1 then
4998: LD_VAR 0 1
5002: PPUSH
5003: CALL_OW 255
5007: PUSH
5008: LD_INT 1
5010: EQUAL
5011: IFFALSE 5051
// for i = 1 to 4 do
5013: LD_ADDR_VAR 0 2
5017: PUSH
5018: DOUBLE
5019: LD_INT 1
5021: DEC
5022: ST_TO_ADDR
5023: LD_INT 4
5025: PUSH
5026: FOR_TO
5027: IFFALSE 5049
// ai_build := Delete ( ai_build , 1 ) ;
5029: LD_ADDR_EXP 10
5033: PUSH
5034: LD_EXP 10
5038: PPUSH
5039: LD_INT 1
5041: PPUSH
5042: CALL_OW 3
5046: ST_TO_ADDR
5047: GO 5026
5049: POP
5050: POP
// if b in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
5051: LD_VAR 0 1
5055: PUSH
5056: LD_INT 22
5058: PUSH
5059: LD_INT 1
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 30
5068: PUSH
5069: LD_INT 32
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: IN
5085: IFFALSE 5103
// tower_list := tower_list ^ b ;
5087: LD_ADDR_EXP 14
5091: PUSH
5092: LD_EXP 14
5096: PUSH
5097: LD_VAR 0 1
5101: ADD
5102: ST_TO_ADDR
// end ; end ;
5103: PPOPN 4
5105: END
// export enemy_count , enemy_typ ; every 1 1$30 trigger game_type = 1 do
5106: LD_EXP 1
5110: PUSH
5111: LD_INT 1
5113: EQUAL
5114: IFFALSE 5312
5116: GO 5118
5118: DISABLE
// begin enable ;
5119: ENABLE
// if timer <= 20 20$00 then
5120: LD_EXP 6
5124: PUSH
5125: LD_INT 42000
5127: LESSEQUAL
5128: IFFALSE 5163
// begin enemy_count := [ 5 , 6 , 7 ] [ game_diff ] ;
5130: LD_ADDR_EXP 15
5134: PUSH
5135: LD_INT 5
5137: PUSH
5138: LD_INT 6
5140: PUSH
5141: LD_INT 7
5143: PUSH
5144: EMPTY
5145: LIST
5146: LIST
5147: LIST
5148: PUSH
5149: LD_EXP 2
5153: ARRAY
5154: ST_TO_ADDR
// enemy_typ := 1 ;
5155: LD_ADDR_EXP 16
5159: PUSH
5160: LD_INT 1
5162: ST_TO_ADDR
// end ; if timer > 20 20$00 and timer <= 40 40$00 then
5163: LD_EXP 6
5167: PUSH
5168: LD_INT 42000
5170: GREATER
5171: PUSH
5172: LD_EXP 6
5176: PUSH
5177: LD_INT 84000
5179: LESSEQUAL
5180: AND
5181: IFFALSE 5216
// begin enemy_count := [ 6 , 8 , 9 ] [ game_diff ] ;
5183: LD_ADDR_EXP 15
5187: PUSH
5188: LD_INT 6
5190: PUSH
5191: LD_INT 8
5193: PUSH
5194: LD_INT 9
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: PUSH
5202: LD_EXP 2
5206: ARRAY
5207: ST_TO_ADDR
// enemy_typ := 2 ;
5208: LD_ADDR_EXP 16
5212: PUSH
5213: LD_INT 2
5215: ST_TO_ADDR
// end ; if timer > 40 40$00 and timer <= 60 60$00 then
5216: LD_EXP 6
5220: PUSH
5221: LD_INT 84000
5223: GREATER
5224: PUSH
5225: LD_EXP 6
5229: PUSH
5230: LD_INT 126000
5232: LESSEQUAL
5233: AND
5234: IFFALSE 5269
// begin enemy_count := [ 8 , 9 , 10 ] [ game_diff ] ;
5236: LD_ADDR_EXP 15
5240: PUSH
5241: LD_INT 8
5243: PUSH
5244: LD_INT 9
5246: PUSH
5247: LD_INT 10
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: PUSH
5255: LD_EXP 2
5259: ARRAY
5260: ST_TO_ADDR
// enemy_typ := 3 ;
5261: LD_ADDR_EXP 16
5265: PUSH
5266: LD_INT 3
5268: ST_TO_ADDR
// end ; if timer > 60 60$00 then
5269: LD_EXP 6
5273: PUSH
5274: LD_INT 126000
5276: GREATER
5277: IFFALSE 5312
// begin enemy_count := [ 10 , 12 , 14 ] [ game_diff ] ;
5279: LD_ADDR_EXP 15
5283: PUSH
5284: LD_INT 10
5286: PUSH
5287: LD_INT 12
5289: PUSH
5290: LD_INT 14
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: LIST
5297: PUSH
5298: LD_EXP 2
5302: ARRAY
5303: ST_TO_ADDR
// enemy_typ := 3 ;
5304: LD_ADDR_EXP 16
5308: PUSH
5309: LD_INT 3
5311: ST_TO_ADDR
// end ; end ;
5312: END
// export am_com2 ; every 0 0$01 trigger timer >= [ 8 8$00 , 8 8$30 , 9 9$00 ] [ game_diff ] and game_type = 1 do var area ;
5313: LD_EXP 6
5317: PUSH
5318: LD_INT 16800
5320: PUSH
5321: LD_INT 17850
5323: PUSH
5324: LD_INT 18900
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: LIST
5331: PUSH
5332: LD_EXP 2
5336: ARRAY
5337: GREATEREQUAL
5338: PUSH
5339: LD_EXP 1
5343: PUSH
5344: LD_INT 1
5346: EQUAL
5347: AND
5348: IFFALSE 5552
5350: GO 5352
5352: DISABLE
5353: LD_INT 0
5355: PPUSH
// begin uc_nation := 1 ;
5356: LD_ADDR_OWVAR 21
5360: PUSH
5361: LD_INT 1
5363: ST_TO_ADDR
// uc_side := 4 ;
5364: LD_ADDR_OWVAR 20
5368: PUSH
5369: LD_INT 4
5371: ST_TO_ADDR
// hc_sex := sex_male ;
5372: LD_ADDR_OWVAR 27
5376: PUSH
5377: LD_INT 1
5379: ST_TO_ADDR
// hc_class := 1 ;
5380: LD_ADDR_OWVAR 28
5384: PUSH
5385: LD_INT 1
5387: ST_TO_ADDR
// hc_gallery :=  ;
5388: LD_ADDR_OWVAR 33
5392: PUSH
5393: LD_STRING 
5395: ST_TO_ADDR
// hc_name :=  ;
5396: LD_ADDR_OWVAR 26
5400: PUSH
5401: LD_STRING 
5403: ST_TO_ADDR
// am_com2 := CreateHuman ;
5404: LD_ADDR_EXP 17
5408: PUSH
5409: CALL_OW 44
5413: ST_TO_ADDR
// SayRadio ( am_com2 , D-rus ) ;
5414: LD_EXP 17
5418: PPUSH
5419: LD_STRING D-rus
5421: PPUSH
5422: CALL_OW 94
// area := [ north_spawn , south_spawn ] ;
5426: LD_ADDR_VAR 0 1
5430: PUSH
5431: LD_INT 6
5433: PUSH
5434: LD_INT 5
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: ST_TO_ADDR
// while ( true ) do
5441: LD_INT 1
5443: IFFALSE 5552
// begin Wait ( Rand ( 6 6$30 , 8 8$32 ) ) ;
5445: LD_INT 13650
5447: PPUSH
5448: LD_INT 17920
5450: PPUSH
5451: CALL_OW 12
5455: PPUSH
5456: CALL_OW 67
// RussianAttack ( 3 , enemy_count , enemy_typ , area ) ;
5460: LD_INT 3
5462: PPUSH
5463: LD_EXP 15
5467: PPUSH
5468: LD_EXP 16
5472: PPUSH
5473: LD_VAR 0 1
5477: PPUSH
5478: CALL 7994 0 4
// if ( timer > [ 55 55$00 , 45 45$00 , 35 35$00 ] [ Difficulty ] ) then
5482: LD_EXP 6
5486: PUSH
5487: LD_INT 115500
5489: PUSH
5490: LD_INT 94500
5492: PUSH
5493: LD_INT 73500
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_OWVAR 67
5505: ARRAY
5506: GREATER
5507: IFFALSE 5550
// begin Wait ( Rand ( 0 0$30 , 1 1$30 ) ) ;
5509: LD_INT 1050
5511: PPUSH
5512: LD_INT 3150
5514: PPUSH
5515: CALL_OW 12
5519: PPUSH
5520: CALL_OW 67
// RussianAttack ( 3 , enemy_count / 2 , enemy_typ , area ) ;
5524: LD_INT 3
5526: PPUSH
5527: LD_EXP 15
5531: PUSH
5532: LD_INT 2
5534: DIVREAL
5535: PPUSH
5536: LD_EXP 16
5540: PPUSH
5541: LD_VAR 0 1
5545: PPUSH
5546: CALL 7994 0 4
// end ; end ;
5550: GO 5441
// end ;
5552: PPOPN 1
5554: END
// every 0 0$01 trigger GetResourceType ( GetBase ( jota_base ) , mat_siberit ) = force_timer do var i , un ;
5555: LD_INT 1
5557: PPUSH
5558: CALL_OW 274
5562: PPUSH
5563: LD_INT 3
5565: PPUSH
5566: CALL_OW 275
5570: PUSH
5571: LD_EXP 7
5575: EQUAL
5576: IFFALSE 5858
5578: GO 5580
5580: DISABLE
5581: LD_INT 0
5583: PPUSH
5584: PPUSH
// begin SayRadio ( am_com2 , D-help ) ;
5585: LD_EXP 17
5589: PPUSH
5590: LD_STRING D-help
5592: PPUSH
5593: CALL_OW 94
// Wait ( Rand ( 3 3$21 , 7 7$39 ) ) ;
5597: LD_INT 7035
5599: PPUSH
5600: LD_INT 16065
5602: PPUSH
5603: CALL_OW 12
5607: PPUSH
5608: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5612: LD_INT 35
5614: PPUSH
5615: CALL_OW 67
// until FilterAllUnits ( [ f_side , 3 ] ) = 0 ;
5619: LD_INT 22
5621: PUSH
5622: LD_INT 3
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: PPUSH
5629: CALL_OW 69
5633: PUSH
5634: LD_INT 0
5636: EQUAL
5637: IFFALSE 5612
// uc_side := 1 ;
5639: LD_ADDR_OWVAR 20
5643: PUSH
5644: LD_INT 1
5646: ST_TO_ADDR
// uc_nation := 1 ;
5647: LD_ADDR_OWVAR 21
5651: PUSH
5652: LD_INT 1
5654: ST_TO_ADDR
// for i = 1 to ( 3 + game_diff ) do
5655: LD_ADDR_VAR 0 1
5659: PUSH
5660: DOUBLE
5661: LD_INT 1
5663: DEC
5664: ST_TO_ADDR
5665: LD_INT 3
5667: PUSH
5668: LD_EXP 2
5672: PLUS
5673: PUSH
5674: FOR_TO
5675: IFFALSE 5720
// begin un := CreateHumanWithClass ( Rand ( 1 , 4 ) , game_skill ) ;
5677: LD_ADDR_VAR 0 2
5681: PUSH
5682: LD_INT 1
5684: PPUSH
5685: LD_INT 4
5687: PPUSH
5688: CALL_OW 12
5692: PPUSH
5693: LD_EXP 3
5697: PPUSH
5698: CALL 9249 0 2
5702: ST_TO_ADDR
// PlaceUnitArea ( un , south_spawn , false ) ;
5703: LD_VAR 0 2
5707: PPUSH
5708: LD_INT 5
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 49
// end ;
5718: GO 5674
5720: POP
5721: POP
// case game_diff of 1 :
5722: LD_EXP 2
5726: PUSH
5727: LD_INT 1
5729: DOUBLE
5730: EQUAL
5731: IFTRUE 5735
5733: GO 5762
5735: POP
// CreateVehicleWithDriver ( us_heavy_tracked , engine_combustion , us_double_gun , south_spawn , 0 , game_skill ) ; 2 :
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 1
5741: PPUSH
5742: LD_INT 5
5744: PPUSH
5745: LD_INT 5
5747: PPUSH
5748: LD_INT 0
5750: PPUSH
5751: LD_EXP 3
5755: PPUSH
5756: CALL 9788 0 6
5760: GO 5833
5762: LD_INT 2
5764: DOUBLE
5765: EQUAL
5766: IFTRUE 5770
5768: GO 5797
5770: POP
// CreateVehicleWithDriver ( us_medium_tracked , engine_combustion , us_double_gun , south_spawn , 0 , game_skill ) ; 3 :
5771: LD_INT 3
5773: PPUSH
5774: LD_INT 1
5776: PPUSH
5777: LD_INT 5
5779: PPUSH
5780: LD_INT 5
5782: PPUSH
5783: LD_INT 0
5785: PPUSH
5786: LD_EXP 3
5790: PPUSH
5791: CALL 9788 0 6
5795: GO 5833
5797: LD_INT 3
5799: DOUBLE
5800: EQUAL
5801: IFTRUE 5805
5803: GO 5832
5805: POP
// CreateVehicleWithDriver ( us_medium_tracked , engine_combustion , us_light_gun , south_spawn , 0 , game_skill ) ; end ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 1
5811: PPUSH
5812: LD_INT 3
5814: PPUSH
5815: LD_INT 5
5817: PPUSH
5818: LD_INT 0
5820: PPUSH
5821: LD_EXP 3
5825: PPUSH
5826: CALL 9788 0 6
5830: GO 5833
5832: POP
// DialogueOn ;
5833: CALL_OW 6
// CenterOnXY ( 91 , 115 ) ;
5837: LD_INT 91
5839: PPUSH
5840: LD_INT 115
5842: PPUSH
5843: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
5847: LD_INT 10
5849: PPUSH
5850: CALL_OW 67
// DialogueOff ;
5854: CALL_OW 7
// end ;
5858: PPOPN 2
5860: END
// export function AmericanAttack ( side , num , typ , list ) ; var i , un , filter , veh , chassis , weapon , f ; begin
5861: LD_INT 0
5863: PPUSH
5864: PPUSH
5865: PPUSH
5866: PPUSH
5867: PPUSH
5868: PPUSH
5869: PPUSH
5870: PPUSH
// uc_side := side ;
5871: LD_ADDR_OWVAR 20
5875: PUSH
5876: LD_VAR 0 1
5880: ST_TO_ADDR
// uc_nation := nation_american ;
5881: LD_ADDR_OWVAR 21
5885: PUSH
5886: LD_INT 1
5888: ST_TO_ADDR
// chassis := [ us_medium_tracked , us_heavy_tracked ] ;
5889: LD_ADDR_VAR 0 10
5893: PUSH
5894: LD_INT 3
5896: PUSH
5897: LD_INT 4
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: ST_TO_ADDR
// weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_heavy_gun , us_rocket_launcher , 97 ] ;
5904: LD_ADDR_VAR 0 11
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 4
5914: PUSH
5915: LD_INT 5
5917: PUSH
5918: LD_INT 6
5920: PUSH
5921: LD_INT 7
5923: PUSH
5924: LD_INT 97
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: ST_TO_ADDR
// case typ of 1 :
5935: LD_VAR 0 3
5939: PUSH
5940: LD_INT 1
5942: DOUBLE
5943: EQUAL
5944: IFTRUE 5948
5946: GO 6142
5948: POP
// begin for i = 1 to num do
5949: LD_ADDR_VAR 0 6
5953: PUSH
5954: DOUBLE
5955: LD_INT 1
5957: DEC
5958: ST_TO_ADDR
5959: LD_VAR 0 2
5963: PUSH
5964: FOR_TO
5965: IFFALSE 6138
// begin vc_chassis := chassis [ 1 ] ;
5967: LD_ADDR_OWVAR 37
5971: PUSH
5972: LD_VAR 0 10
5976: PUSH
5977: LD_INT 1
5979: ARRAY
5980: ST_TO_ADDR
// vc_engine := engine_combustion ;
5981: LD_ADDR_OWVAR 39
5985: PUSH
5986: LD_INT 1
5988: ST_TO_ADDR
// vc_control := control_manual ;
5989: LD_ADDR_OWVAR 38
5993: PUSH
5994: LD_INT 1
5996: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
5997: LD_ADDR_OWVAR 40
6001: PUSH
6002: LD_VAR 0 11
6006: PUSH
6007: LD_INT 1
6009: PPUSH
6010: LD_INT 3
6012: PPUSH
6013: CALL_OW 12
6017: ARRAY
6018: ST_TO_ADDR
// veh := CreateVehicle ;
6019: LD_ADDR_VAR 0 9
6023: PUSH
6024: CALL_OW 45
6028: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
6029: LD_ADDR_VAR 0 12
6033: PUSH
6034: LD_INT 1
6036: PPUSH
6037: LD_INT 2
6039: PPUSH
6040: CALL_OW 12
6044: ST_TO_ADDR
// if f = 1 then
6045: LD_VAR 0 12
6049: PUSH
6050: LD_INT 1
6052: EQUAL
6053: IFFALSE 6069
// SetDir ( veh , 3 ) else
6055: LD_VAR 0 9
6059: PPUSH
6060: LD_INT 3
6062: PPUSH
6063: CALL_OW 233
6067: GO 6081
// SetDir ( veh , 1 ) ;
6069: LD_VAR 0 9
6073: PPUSH
6074: LD_INT 1
6076: PPUSH
6077: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
6081: LD_VAR 0 9
6085: PPUSH
6086: LD_VAR 0 4
6090: PUSH
6091: LD_VAR 0 12
6095: ARRAY
6096: PPUSH
6097: LD_INT 0
6099: PPUSH
6100: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
6104: LD_ADDR_VAR 0 7
6108: PUSH
6109: LD_INT 1
6111: PPUSH
6112: LD_EXP 4
6116: PPUSH
6117: CALL 9249 0 2
6121: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6122: LD_VAR 0 7
6126: PPUSH
6127: LD_VAR 0 9
6131: PPUSH
6132: CALL_OW 52
// end ;
6136: GO 5964
6138: POP
6139: POP
// end ; 2 :
6140: GO 6616
6142: LD_INT 2
6144: DOUBLE
6145: EQUAL
6146: IFTRUE 6150
6148: GO 6413
6150: POP
// begin for i = 1 to num do
6151: LD_ADDR_VAR 0 6
6155: PUSH
6156: DOUBLE
6157: LD_INT 1
6159: DEC
6160: ST_TO_ADDR
6161: LD_VAR 0 2
6165: PUSH
6166: FOR_TO
6167: IFFALSE 6348
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
6169: LD_ADDR_OWVAR 37
6173: PUSH
6174: LD_VAR 0 10
6178: PUSH
6179: LD_INT 1
6181: PPUSH
6182: LD_INT 2
6184: PPUSH
6185: CALL_OW 12
6189: ARRAY
6190: ST_TO_ADDR
// vc_engine := engine_combustion ;
6191: LD_ADDR_OWVAR 39
6195: PUSH
6196: LD_INT 1
6198: ST_TO_ADDR
// vc_control := control_manual ;
6199: LD_ADDR_OWVAR 38
6203: PUSH
6204: LD_INT 1
6206: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
6207: LD_ADDR_OWVAR 40
6211: PUSH
6212: LD_VAR 0 11
6216: PUSH
6217: LD_INT 1
6219: PPUSH
6220: LD_INT 3
6222: PPUSH
6223: CALL_OW 12
6227: ARRAY
6228: ST_TO_ADDR
// veh := CreateVehicle ;
6229: LD_ADDR_VAR 0 9
6233: PUSH
6234: CALL_OW 45
6238: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
6239: LD_ADDR_VAR 0 12
6243: PUSH
6244: LD_INT 1
6246: PPUSH
6247: LD_INT 2
6249: PPUSH
6250: CALL_OW 12
6254: ST_TO_ADDR
// if f = 1 then
6255: LD_VAR 0 12
6259: PUSH
6260: LD_INT 1
6262: EQUAL
6263: IFFALSE 6279
// SetDir ( veh , 3 ) else
6265: LD_VAR 0 9
6269: PPUSH
6270: LD_INT 3
6272: PPUSH
6273: CALL_OW 233
6277: GO 6291
// SetDir ( veh , 1 ) ;
6279: LD_VAR 0 9
6283: PPUSH
6284: LD_INT 1
6286: PPUSH
6287: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
6291: LD_VAR 0 9
6295: PPUSH
6296: LD_VAR 0 4
6300: PUSH
6301: LD_VAR 0 12
6305: ARRAY
6306: PPUSH
6307: LD_INT 0
6309: PPUSH
6310: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
6314: LD_ADDR_VAR 0 7
6318: PUSH
6319: LD_INT 1
6321: PPUSH
6322: LD_EXP 4
6326: PPUSH
6327: CALL 9249 0 2
6331: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6332: LD_VAR 0 7
6336: PPUSH
6337: LD_VAR 0 9
6341: PPUSH
6342: CALL_OW 52
// end ;
6346: GO 6166
6348: POP
6349: POP
// for i = 1 to 3 do
6350: LD_ADDR_VAR 0 6
6354: PUSH
6355: DOUBLE
6356: LD_INT 1
6358: DEC
6359: ST_TO_ADDR
6360: LD_INT 3
6362: PUSH
6363: FOR_TO
6364: IFFALSE 6409
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
6366: LD_ADDR_VAR 0 7
6370: PUSH
6371: LD_INT 5
6373: PPUSH
6374: LD_EXP 4
6378: PPUSH
6379: CALL 9249 0 2
6383: ST_TO_ADDR
// PlaceUnitArea ( un , list [ f ] , false ) ;
6384: LD_VAR 0 7
6388: PPUSH
6389: LD_VAR 0 4
6393: PUSH
6394: LD_VAR 0 12
6398: ARRAY
6399: PPUSH
6400: LD_INT 0
6402: PPUSH
6403: CALL_OW 49
// end ;
6407: GO 6363
6409: POP
6410: POP
// end ; 3 :
6411: GO 6616
6413: LD_INT 3
6415: DOUBLE
6416: EQUAL
6417: IFTRUE 6421
6419: GO 6615
6421: POP
// begin for i = 1 to num do
6422: LD_ADDR_VAR 0 6
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6611
// begin vc_chassis := chassis [ 2 ] ;
6440: LD_ADDR_OWVAR 37
6444: PUSH
6445: LD_VAR 0 10
6449: PUSH
6450: LD_INT 2
6452: ARRAY
6453: ST_TO_ADDR
// vc_engine := engine_combustion ;
6454: LD_ADDR_OWVAR 39
6458: PUSH
6459: LD_INT 1
6461: ST_TO_ADDR
// vc_control := control_manual ;
6462: LD_ADDR_OWVAR 38
6466: PUSH
6467: LD_INT 1
6469: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 6 ) ] ;
6470: LD_ADDR_OWVAR 40
6474: PUSH
6475: LD_VAR 0 11
6479: PUSH
6480: LD_INT 3
6482: PPUSH
6483: LD_INT 6
6485: PPUSH
6486: CALL_OW 12
6490: ARRAY
6491: ST_TO_ADDR
// veh := CreateVehicle ;
6492: LD_ADDR_VAR 0 9
6496: PUSH
6497: CALL_OW 45
6501: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
6502: LD_ADDR_VAR 0 12
6506: PUSH
6507: LD_INT 1
6509: PPUSH
6510: LD_INT 2
6512: PPUSH
6513: CALL_OW 12
6517: ST_TO_ADDR
// if f = 1 then
6518: LD_VAR 0 12
6522: PUSH
6523: LD_INT 1
6525: EQUAL
6526: IFFALSE 6542
// SetDir ( veh , 3 ) else
6528: LD_VAR 0 9
6532: PPUSH
6533: LD_INT 3
6535: PPUSH
6536: CALL_OW 233
6540: GO 6554
// SetDir ( veh , 1 ) ;
6542: LD_VAR 0 9
6546: PPUSH
6547: LD_INT 1
6549: PPUSH
6550: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
6554: LD_VAR 0 9
6558: PPUSH
6559: LD_VAR 0 4
6563: PUSH
6564: LD_VAR 0 12
6568: ARRAY
6569: PPUSH
6570: LD_INT 0
6572: PPUSH
6573: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
6577: LD_ADDR_VAR 0 7
6581: PUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_EXP 4
6589: PPUSH
6590: CALL 9249 0 2
6594: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6595: LD_VAR 0 7
6599: PPUSH
6600: LD_VAR 0 9
6604: PPUSH
6605: CALL_OW 52
// end ;
6609: GO 6437
6611: POP
6612: POP
// end ; end ;
6613: GO 6616
6615: POP
// end ;
6616: LD_VAR 0 5
6620: RET
// every 0 0$01 trigger game_type = 2 and depot_captured do var filter , enemy , i ;
6621: LD_EXP 1
6625: PUSH
6626: LD_INT 2
6628: EQUAL
6629: PUSH
6630: LD_EXP 8
6634: AND
6635: IFFALSE 6790
6637: GO 6639
6639: DISABLE
6640: LD_INT 0
6642: PPUSH
6643: PPUSH
6644: PPUSH
// begin enable ;
6645: ENABLE
// filter := FilterAllUnits ( [ f_side , 1 ] ) ;
6646: LD_ADDR_VAR 0 1
6650: PUSH
6651: LD_INT 22
6653: PUSH
6654: LD_INT 1
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: PPUSH
6661: CALL_OW 69
6665: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
6666: LD_ADDR_VAR 0 2
6670: PUSH
6671: LD_INT 2
6673: PUSH
6674: LD_INT 22
6676: PUSH
6677: LD_INT 3
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: LD_INT 22
6686: PUSH
6687: LD_INT 6
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: LIST
6698: PPUSH
6699: CALL_OW 69
6703: ST_TO_ADDR
// if filter > 0 then
6704: LD_VAR 0 1
6708: PUSH
6709: LD_INT 0
6711: GREATER
6712: IFFALSE 6790
// for i = 1 to filter do
6714: LD_ADDR_VAR 0 3
6718: PUSH
6719: DOUBLE
6720: LD_INT 1
6722: DEC
6723: ST_TO_ADDR
6724: LD_VAR 0 1
6728: PUSH
6729: FOR_TO
6730: IFFALSE 6788
// if not HasTask ( filter [ i ] ) then
6732: LD_VAR 0 1
6736: PUSH
6737: LD_VAR 0 3
6741: ARRAY
6742: PPUSH
6743: CALL_OW 314
6747: NOT
6748: IFFALSE 6786
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
6750: LD_VAR 0 1
6754: PUSH
6755: LD_VAR 0 3
6759: ARRAY
6760: PPUSH
6761: LD_VAR 0 2
6765: PPUSH
6766: LD_VAR 0 1
6770: PUSH
6771: LD_VAR 0 3
6775: ARRAY
6776: PPUSH
6777: CALL_OW 74
6781: PPUSH
6782: CALL_OW 115
6786: GO 6729
6788: POP
6789: POP
// end ;
6790: PPOPN 3
6792: END
// every 0 0$01 trigger game_type = 2 do var filter , enemy , i ;
6793: LD_EXP 1
6797: PUSH
6798: LD_INT 2
6800: EQUAL
6801: IFFALSE 6956
6803: GO 6805
6805: DISABLE
6806: LD_INT 0
6808: PPUSH
6809: PPUSH
6810: PPUSH
// begin enable ;
6811: ENABLE
// filter := FilterAllUnits ( [ f_side , 8 ] ) ;
6812: LD_ADDR_VAR 0 1
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_INT 8
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL_OW 69
6831: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
6832: LD_ADDR_VAR 0 2
6836: PUSH
6837: LD_INT 2
6839: PUSH
6840: LD_INT 22
6842: PUSH
6843: LD_INT 3
6845: PUSH
6846: EMPTY
6847: LIST
6848: LIST
6849: PUSH
6850: LD_INT 22
6852: PUSH
6853: LD_INT 6
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: EMPTY
6861: LIST
6862: LIST
6863: LIST
6864: PPUSH
6865: CALL_OW 69
6869: ST_TO_ADDR
// if filter > 0 then
6870: LD_VAR 0 1
6874: PUSH
6875: LD_INT 0
6877: GREATER
6878: IFFALSE 6956
// for i = 1 to filter do
6880: LD_ADDR_VAR 0 3
6884: PUSH
6885: DOUBLE
6886: LD_INT 1
6888: DEC
6889: ST_TO_ADDR
6890: LD_VAR 0 1
6894: PUSH
6895: FOR_TO
6896: IFFALSE 6954
// if not HasTask ( filter [ i ] ) then
6898: LD_VAR 0 1
6902: PUSH
6903: LD_VAR 0 3
6907: ARRAY
6908: PPUSH
6909: CALL_OW 314
6913: NOT
6914: IFFALSE 6952
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
6916: LD_VAR 0 1
6920: PUSH
6921: LD_VAR 0 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 2
6931: PPUSH
6932: LD_VAR 0 1
6936: PUSH
6937: LD_VAR 0 3
6941: ARRAY
6942: PPUSH
6943: CALL_OW 74
6947: PPUSH
6948: CALL_OW 115
6952: GO 6895
6954: POP
6955: POP
// end ; end_of_file
6956: PPOPN 3
6958: END
// export ru_dow , gorki ; export function PrepareRussian ; var un , i , filter , team ; begin
6959: LD_INT 0
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
// Your_Side := 3 ;
6966: LD_ADDR_OWVAR 2
6970: PUSH
6971: LD_INT 3
6973: ST_TO_ADDR
// ChangeSideFog ( 3 , 3 ) ;
6974: LD_INT 3
6976: PPUSH
6977: LD_INT 3
6979: PPUSH
6980: CALL_OW 343
// ResetFog ;
6984: CALL_OW 335
// uc_side := 6 ;
6988: LD_ADDR_OWVAR 20
6992: PUSH
6993: LD_INT 6
6995: ST_TO_ADDR
// uc_nation := 3 ;
6996: LD_ADDR_OWVAR 21
7000: PUSH
7001: LD_INT 3
7003: ST_TO_ADDR
// hc_gallery := ru ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING ru
7011: ST_TO_ADDR
// hc_face_number := 1 ;
7012: LD_ADDR_OWVAR 34
7016: PUSH
7017: LD_INT 1
7019: ST_TO_ADDR
// hc_name := J. I. Gorki ;
7020: LD_ADDR_OWVAR 26
7024: PUSH
7025: LD_STRING J. I. Gorki
7027: ST_TO_ADDR
// hc_class := 3 ;
7028: LD_ADDR_OWVAR 28
7032: PUSH
7033: LD_INT 3
7035: ST_TO_ADDR
// hc_sex := sex_male ;
7036: LD_ADDR_OWVAR 27
7040: PUSH
7041: LD_INT 1
7043: ST_TO_ADDR
// gorki := CreateHuman ;
7044: LD_ADDR_EXP 19
7048: PUSH
7049: CALL_OW 44
7053: ST_TO_ADDR
// uc_side := 3 ;
7054: LD_ADDR_OWVAR 20
7058: PUSH
7059: LD_INT 3
7061: ST_TO_ADDR
// uc_nation := 3 ;
7062: LD_ADDR_OWVAR 21
7066: PUSH
7067: LD_INT 3
7069: ST_TO_ADDR
// hc_importance := 100 ;
7070: LD_ADDR_OWVAR 32
7074: PUSH
7075: LD_INT 100
7077: ST_TO_ADDR
// hc_name :=  ;
7078: LD_ADDR_OWVAR 26
7082: PUSH
7083: LD_STRING 
7085: ST_TO_ADDR
// hc_gallery :=  ;
7086: LD_ADDR_OWVAR 33
7090: PUSH
7091: LD_STRING 
7093: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , game_skill + 3 ) ;
7094: LD_INT 1
7096: PPUSH
7097: LD_INT 1
7099: PPUSH
7100: LD_EXP 3
7104: PUSH
7105: LD_INT 3
7107: PLUS
7108: PPUSH
7109: CALL_OW 380
// ru_dow := CreateHuman ;
7113: LD_ADDR_EXP 18
7117: PUSH
7118: CALL_OW 44
7122: ST_TO_ADDR
// hc_importance := 0 ;
7123: LD_ADDR_OWVAR 32
7127: PUSH
7128: LD_INT 0
7130: ST_TO_ADDR
// for i = 1 to 20 do
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: DOUBLE
7137: LD_INT 1
7139: DEC
7140: ST_TO_ADDR
7141: LD_INT 20
7143: PUSH
7144: FOR_TO
7145: IFFALSE 7207
// begin uc_side := 3 ;
7147: LD_ADDR_OWVAR 20
7151: PUSH
7152: LD_INT 3
7154: ST_TO_ADDR
// uc_nation := 3 ;
7155: LD_ADDR_OWVAR 21
7159: PUSH
7160: LD_INT 3
7162: ST_TO_ADDR
// un := CreateHumanWithClass ( Rand ( 1 , 4 ) , game_skill ) ;
7163: LD_ADDR_VAR 0 2
7167: PUSH
7168: LD_INT 1
7170: PPUSH
7171: LD_INT 4
7173: PPUSH
7174: CALL_OW 12
7178: PPUSH
7179: LD_EXP 3
7183: PPUSH
7184: CALL 9249 0 2
7188: ST_TO_ADDR
// filter := filter ^ un ;
7189: LD_ADDR_VAR 0 4
7193: PUSH
7194: LD_VAR 0 4
7198: PUSH
7199: LD_VAR 0 2
7203: ADD
7204: ST_TO_ADDR
// end ;
7205: GO 7144
7207: POP
7208: POP
// team := CharacterSelection ( text , [ 9 , 8 , 7 ] [ game_diff ] , [ 9 , 8 , 7 ] [ game_diff ] , [ sel_change_class , ru_dow , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ class_bazooker , 0 , [ 6 , 4 , 3 ] [ game_diff ] ] ] ) ;
7209: LD_ADDR_VAR 0 5
7213: PUSH
7214: LD_STRING text
7216: PPUSH
7217: LD_INT 9
7219: PUSH
7220: LD_INT 8
7222: PUSH
7223: LD_INT 7
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: PUSH
7231: LD_EXP 2
7235: ARRAY
7236: PPUSH
7237: LD_INT 9
7239: PUSH
7240: LD_INT 8
7242: PUSH
7243: LD_INT 7
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: LIST
7250: PUSH
7251: LD_EXP 2
7255: ARRAY
7256: PPUSH
7257: LD_INT -5
7259: PUSH
7260: LD_EXP 18
7264: PUSH
7265: LD_INT -3
7267: PUSH
7268: LD_INT -2
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: PUSH
7277: LD_VAR 0 4
7281: ADD
7282: PPUSH
7283: LD_INT 1
7285: PUSH
7286: LD_INT 3
7288: PUSH
7289: LD_INT 2
7291: PUSH
7292: LD_INT 1
7294: PUSH
7295: EMPTY
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 4
7301: PUSH
7302: LD_INT 1
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: PUSH
7309: LD_INT 9
7311: PUSH
7312: LD_INT 0
7314: PUSH
7315: LD_INT 6
7317: PUSH
7318: LD_INT 4
7320: PUSH
7321: LD_INT 3
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: PUSH
7329: LD_EXP 2
7333: ARRAY
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: PPUSH
7347: CALL_OW 42
7351: ST_TO_ADDR
// team := team ^ ru_dow ;
7352: LD_ADDR_VAR 0 5
7356: PUSH
7357: LD_VAR 0 5
7361: PUSH
7362: LD_EXP 18
7366: ADD
7367: ST_TO_ADDR
// for i = 1 to team do
7368: LD_ADDR_VAR 0 3
7372: PUSH
7373: DOUBLE
7374: LD_INT 1
7376: DEC
7377: ST_TO_ADDR
7378: LD_VAR 0 5
7382: PUSH
7383: FOR_TO
7384: IFFALSE 7409
// PlaceUnitArea ( team [ i ] , south_spawn , false ) ;
7386: LD_VAR 0 5
7390: PUSH
7391: LD_VAR 0 3
7395: ARRAY
7396: PPUSH
7397: LD_INT 5
7399: PPUSH
7400: LD_INT 0
7402: PPUSH
7403: CALL_OW 49
7407: GO 7383
7409: POP
7410: POP
// end ;
7411: LD_VAR 0 1
7415: RET
// every 0 0$01 trigger GetSide ( jota_base ) = 3 do var area ;
7416: LD_INT 1
7418: PPUSH
7419: CALL_OW 255
7423: PUSH
7424: LD_INT 3
7426: EQUAL
7427: IFFALSE 7537
7429: GO 7431
7431: DISABLE
7432: LD_INT 0
7434: PPUSH
// begin depot_captured := true ;
7435: LD_ADDR_EXP 8
7439: PUSH
7440: LD_INT 1
7442: ST_TO_ADDR
// ChangeMissionObjectives ( GType2b ) ;
7443: LD_STRING GType2b
7445: PPUSH
7446: CALL_OW 337
// Say ( ru_dow , D-rudow2 ) ;
7450: LD_EXP 18
7454: PPUSH
7455: LD_STRING D-rudow2
7457: PPUSH
7458: CALL_OW 88
// SayRadio ( gorki , D-gorky2 ) ;
7462: LD_EXP 19
7466: PPUSH
7467: LD_STRING D-gorky2
7469: PPUSH
7470: CALL_OW 94
// while ( true ) do
7474: LD_INT 1
7476: IFFALSE 7537
// begin Wait ( Rand ( 6 6$20 , 9 9$31 ) ) ;
7478: LD_INT 13300
7480: PPUSH
7481: LD_INT 19985
7483: PPUSH
7484: CALL_OW 12
7488: PPUSH
7489: CALL_OW 67
// area := [ north_spawn , south_spawn ] ;
7493: LD_ADDR_VAR 0 1
7497: PUSH
7498: LD_INT 6
7500: PUSH
7501: LD_INT 5
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: ST_TO_ADDR
// AmericanAttack ( 1 , enemy_count , enemy_typ , [ north_spawn , south_spawn ] ) ;
7508: LD_INT 1
7510: PPUSH
7511: LD_EXP 15
7515: PPUSH
7516: LD_EXP 16
7520: PPUSH
7521: LD_INT 6
7523: PUSH
7524: LD_INT 5
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: PPUSH
7531: CALL 5861 0 4
// end ;
7535: GO 7474
// end ;
7537: PPOPN 1
7539: END
// every 1 1$30 trigger game_type = 2 do
7540: LD_EXP 1
7544: PUSH
7545: LD_INT 2
7547: EQUAL
7548: IFFALSE 7693
7550: GO 7552
7552: DISABLE
// begin enable ;
7553: ENABLE
// if timer <= 45 45$00 then
7554: LD_EXP 6
7558: PUSH
7559: LD_INT 94500
7561: LESSEQUAL
7562: IFFALSE 7597
// begin enemy_count := [ 5 , 6 , 7 ] [ game_diff ] ;
7564: LD_ADDR_EXP 15
7568: PUSH
7569: LD_INT 5
7571: PUSH
7572: LD_INT 6
7574: PUSH
7575: LD_INT 7
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_EXP 2
7587: ARRAY
7588: ST_TO_ADDR
// enemy_typ := 1 ;
7589: LD_ADDR_EXP 16
7593: PUSH
7594: LD_INT 1
7596: ST_TO_ADDR
// end ; if timer > 60 60$00 and timer <= 80 80$00 then
7597: LD_EXP 6
7601: PUSH
7602: LD_INT 126000
7604: GREATER
7605: PUSH
7606: LD_EXP 6
7610: PUSH
7611: LD_INT 168000
7613: LESSEQUAL
7614: AND
7615: IFFALSE 7650
// begin enemy_count := [ 6 , 8 , 9 ] [ game_diff ] ;
7617: LD_ADDR_EXP 15
7621: PUSH
7622: LD_INT 6
7624: PUSH
7625: LD_INT 8
7627: PUSH
7628: LD_INT 9
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_EXP 2
7640: ARRAY
7641: ST_TO_ADDR
// enemy_typ := 2 ;
7642: LD_ADDR_EXP 16
7646: PUSH
7647: LD_INT 2
7649: ST_TO_ADDR
// end ; if timer > 80 80$00 then
7650: LD_EXP 6
7654: PUSH
7655: LD_INT 168000
7657: GREATER
7658: IFFALSE 7693
// begin enemy_count := [ 8 , 9 , 10 ] [ game_diff ] ;
7660: LD_ADDR_EXP 15
7664: PUSH
7665: LD_INT 8
7667: PUSH
7668: LD_INT 9
7670: PUSH
7671: LD_INT 10
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: PUSH
7679: LD_EXP 2
7683: ARRAY
7684: ST_TO_ADDR
// enemy_typ := 3 ;
7685: LD_ADDR_EXP 16
7689: PUSH
7690: LD_INT 3
7692: ST_TO_ADDR
// end ; end ;
7693: END
// export farmer ; every 20 20$00 trigger game_type = 2 do
7694: LD_EXP 1
7698: PUSH
7699: LD_INT 2
7701: EQUAL
7702: IFFALSE 7827
7704: GO 7706
7706: DISABLE
// begin LegionAttack ( 8 , enemy_count , 1 , north_spawn ) ;
7707: LD_INT 8
7709: PPUSH
7710: LD_EXP 15
7714: PPUSH
7715: LD_INT 1
7717: PPUSH
7718: LD_INT 6
7720: PPUSH
7721: CALL 9898 0 4
// Wait ( 20 20$00 ) ;
7725: LD_INT 42000
7727: PPUSH
7728: CALL_OW 67
// LegionAttack ( 8 , enemy_count , 2 , north_spawn ) ;
7732: LD_INT 8
7734: PPUSH
7735: LD_EXP 15
7739: PPUSH
7740: LD_INT 2
7742: PPUSH
7743: LD_INT 6
7745: PPUSH
7746: CALL 9898 0 4
// Wait ( 4 4$00 ) ;
7750: LD_INT 8400
7752: PPUSH
7753: CALL_OW 67
// uc_side := 8 ;
7757: LD_ADDR_OWVAR 20
7761: PUSH
7762: LD_INT 8
7764: ST_TO_ADDR
// uc_nation := 2 ;
7765: LD_ADDR_OWVAR 21
7769: PUSH
7770: LD_INT 2
7772: ST_TO_ADDR
// hc_class := 1 ;
7773: LD_ADDR_OWVAR 28
7777: PUSH
7778: LD_INT 1
7780: ST_TO_ADDR
// hc_gallery := sandar ;
7781: LD_ADDR_OWVAR 33
7785: PUSH
7786: LD_STRING sandar
7788: ST_TO_ADDR
// hc_face_number := 4 ;
7789: LD_ADDR_OWVAR 34
7793: PUSH
7794: LD_INT 4
7796: ST_TO_ADDR
// hc_sex := sex_male ;
7797: LD_ADDR_OWVAR 27
7801: PUSH
7802: LD_INT 1
7804: ST_TO_ADDR
// farmer := CreateHuman ;
7805: LD_ADDR_EXP 20
7809: PUSH
7810: CALL_OW 44
7814: ST_TO_ADDR
// SayRadio ( farmer , D-farmer ) ;
7815: LD_EXP 20
7819: PPUSH
7820: LD_STRING D-farmer
7822: PPUSH
7823: CALL_OW 94
// end ;
7827: END
// every 0 0$01 trigger game_type = 1 do var filter , enemy , i ;
7828: LD_EXP 1
7832: PUSH
7833: LD_INT 1
7835: EQUAL
7836: IFFALSE 7991
7838: GO 7840
7840: DISABLE
7841: LD_INT 0
7843: PPUSH
7844: PPUSH
7845: PPUSH
// begin enable ;
7846: ENABLE
// filter := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
7847: LD_ADDR_VAR 0 1
7851: PUSH
7852: LD_INT 2
7854: PUSH
7855: LD_INT 22
7857: PUSH
7858: LD_INT 3
7860: PUSH
7861: EMPTY
7862: LIST
7863: LIST
7864: PUSH
7865: LD_INT 22
7867: PUSH
7868: LD_INT 6
7870: PUSH
7871: EMPTY
7872: LIST
7873: LIST
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: LIST
7879: PPUSH
7880: CALL_OW 69
7884: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) ;
7885: LD_ADDR_VAR 0 2
7889: PUSH
7890: LD_INT 2
7892: PUSH
7893: LD_INT 22
7895: PUSH
7896: LD_INT 1
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 22
7905: PUSH
7906: LD_INT 2
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 69
7922: ST_TO_ADDR
// if filter > 0 then
7923: LD_VAR 0 1
7927: PUSH
7928: LD_INT 0
7930: GREATER
7931: IFFALSE 7991
// for i = 1 to filter do
7933: LD_ADDR_VAR 0 3
7937: PUSH
7938: DOUBLE
7939: LD_INT 1
7941: DEC
7942: ST_TO_ADDR
7943: LD_VAR 0 1
7947: PUSH
7948: FOR_TO
7949: IFFALSE 7989
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
7951: LD_VAR 0 1
7955: PUSH
7956: LD_VAR 0 3
7960: ARRAY
7961: PPUSH
7962: LD_VAR 0 2
7966: PPUSH
7967: LD_VAR 0 1
7971: PUSH
7972: LD_VAR 0 3
7976: ARRAY
7977: PPUSH
7978: CALL_OW 74
7982: PPUSH
7983: CALL_OW 115
7987: GO 7948
7989: POP
7990: POP
// end ;
7991: PPOPN 3
7993: END
// export function RussianAttack ( side , num , typ , list ) ; var i , un , filter , veh , chassis , weapon , f ; begin
7994: LD_INT 0
7996: PPUSH
7997: PPUSH
7998: PPUSH
7999: PPUSH
8000: PPUSH
8001: PPUSH
8002: PPUSH
8003: PPUSH
// Randomize ;
8004: CALL_OW 10
// uc_side := side ;
8008: LD_ADDR_OWVAR 20
8012: PUSH
8013: LD_VAR 0 1
8017: ST_TO_ADDR
// uc_nation := nation_russian ;
8018: LD_ADDR_OWVAR 21
8022: PUSH
8023: LD_INT 3
8025: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] ;
8026: LD_ADDR_VAR 0 10
8030: PUSH
8031: LD_INT 22
8033: PUSH
8034: LD_INT 24
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: ST_TO_ADDR
// weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
8041: LD_ADDR_VAR 0 11
8045: PUSH
8046: LD_INT 42
8048: PUSH
8049: LD_INT 43
8051: PUSH
8052: LD_INT 44
8054: PUSH
8055: LD_INT 46
8057: PUSH
8058: LD_INT 45
8060: PUSH
8061: LD_INT 47
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: ST_TO_ADDR
// case typ of 1 :
8072: LD_VAR 0 3
8076: PUSH
8077: LD_INT 1
8079: DOUBLE
8080: EQUAL
8081: IFTRUE 8085
8083: GO 8279
8085: POP
// begin for i = 1 to num do
8086: LD_ADDR_VAR 0 6
8090: PUSH
8091: DOUBLE
8092: LD_INT 1
8094: DEC
8095: ST_TO_ADDR
8096: LD_VAR 0 2
8100: PUSH
8101: FOR_TO
8102: IFFALSE 8275
// begin vc_chassis := chassis [ 1 ] ;
8104: LD_ADDR_OWVAR 37
8108: PUSH
8109: LD_VAR 0 10
8113: PUSH
8114: LD_INT 1
8116: ARRAY
8117: ST_TO_ADDR
// vc_engine := engine_combustion ;
8118: LD_ADDR_OWVAR 39
8122: PUSH
8123: LD_INT 1
8125: ST_TO_ADDR
// vc_control := control_manual ;
8126: LD_ADDR_OWVAR 38
8130: PUSH
8131: LD_INT 1
8133: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
8134: LD_ADDR_OWVAR 40
8138: PUSH
8139: LD_VAR 0 11
8143: PUSH
8144: LD_INT 1
8146: PPUSH
8147: LD_INT 3
8149: PPUSH
8150: CALL_OW 12
8154: ARRAY
8155: ST_TO_ADDR
// veh := CreateVehicle ;
8156: LD_ADDR_VAR 0 9
8160: PUSH
8161: CALL_OW 45
8165: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
8166: LD_ADDR_VAR 0 12
8170: PUSH
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 2
8176: PPUSH
8177: CALL_OW 12
8181: ST_TO_ADDR
// if f = 1 then
8182: LD_VAR 0 12
8186: PUSH
8187: LD_INT 1
8189: EQUAL
8190: IFFALSE 8206
// SetDir ( veh , 3 ) else
8192: LD_VAR 0 9
8196: PPUSH
8197: LD_INT 3
8199: PPUSH
8200: CALL_OW 233
8204: GO 8218
// SetDir ( veh , 1 ) ;
8206: LD_VAR 0 9
8210: PPUSH
8211: LD_INT 1
8213: PPUSH
8214: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
8218: LD_VAR 0 9
8222: PPUSH
8223: LD_VAR 0 4
8227: PUSH
8228: LD_VAR 0 12
8232: ARRAY
8233: PPUSH
8234: LD_INT 0
8236: PPUSH
8237: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
8241: LD_ADDR_VAR 0 7
8245: PUSH
8246: LD_INT 1
8248: PPUSH
8249: LD_EXP 4
8253: PPUSH
8254: CALL 9249 0 2
8258: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8259: LD_VAR 0 7
8263: PPUSH
8264: LD_VAR 0 9
8268: PPUSH
8269: CALL_OW 52
// end ;
8273: GO 8101
8275: POP
8276: POP
// end ; 2 :
8277: GO 8821
8279: LD_INT 2
8281: DOUBLE
8282: EQUAL
8283: IFTRUE 8287
8285: GO 8584
8287: POP
// begin for i = 1 to num do
8288: LD_ADDR_VAR 0 6
8292: PUSH
8293: DOUBLE
8294: LD_INT 1
8296: DEC
8297: ST_TO_ADDR
8298: LD_VAR 0 2
8302: PUSH
8303: FOR_TO
8304: IFFALSE 8519
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
8306: LD_ADDR_OWVAR 37
8310: PUSH
8311: LD_VAR 0 10
8315: PUSH
8316: LD_INT 1
8318: PPUSH
8319: LD_INT 2
8321: PPUSH
8322: CALL_OW 12
8326: ARRAY
8327: ST_TO_ADDR
// vc_engine := engine_combustion ;
8328: LD_ADDR_OWVAR 39
8332: PUSH
8333: LD_INT 1
8335: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ Rand ( 1 , 2 ) ] ;
8336: LD_ADDR_OWVAR 38
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: LD_INT 3
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PUSH
8351: LD_INT 1
8353: PPUSH
8354: LD_INT 2
8356: PPUSH
8357: CALL_OW 12
8361: ARRAY
8362: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
8363: LD_ADDR_OWVAR 40
8367: PUSH
8368: LD_VAR 0 11
8372: PUSH
8373: LD_INT 1
8375: PPUSH
8376: LD_INT 3
8378: PPUSH
8379: CALL_OW 12
8383: ARRAY
8384: ST_TO_ADDR
// veh := CreateVehicle ;
8385: LD_ADDR_VAR 0 9
8389: PUSH
8390: CALL_OW 45
8394: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
8395: LD_ADDR_VAR 0 12
8399: PUSH
8400: LD_INT 1
8402: PPUSH
8403: LD_INT 2
8405: PPUSH
8406: CALL_OW 12
8410: ST_TO_ADDR
// if f = 1 then
8411: LD_VAR 0 12
8415: PUSH
8416: LD_INT 1
8418: EQUAL
8419: IFFALSE 8435
// SetDir ( veh , 3 ) else
8421: LD_VAR 0 9
8425: PPUSH
8426: LD_INT 3
8428: PPUSH
8429: CALL_OW 233
8433: GO 8447
// SetDir ( veh , 1 ) ;
8435: LD_VAR 0 9
8439: PPUSH
8440: LD_INT 1
8442: PPUSH
8443: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
8447: LD_VAR 0 9
8451: PPUSH
8452: LD_VAR 0 4
8456: PUSH
8457: LD_VAR 0 12
8461: ARRAY
8462: PPUSH
8463: LD_INT 0
8465: PPUSH
8466: CALL_OW 49
// if GetControl ( veh ) = control_manual then
8470: LD_VAR 0 9
8474: PPUSH
8475: CALL_OW 263
8479: PUSH
8480: LD_INT 1
8482: EQUAL
8483: IFFALSE 8517
// begin un := CreateHumanWithClass ( 1 , game_eskill ) ;
8485: LD_ADDR_VAR 0 7
8489: PUSH
8490: LD_INT 1
8492: PPUSH
8493: LD_EXP 4
8497: PPUSH
8498: CALL 9249 0 2
8502: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8503: LD_VAR 0 7
8507: PPUSH
8508: LD_VAR 0 9
8512: PPUSH
8513: CALL_OW 52
// end ; end ;
8517: GO 8303
8519: POP
8520: POP
// for i = 1 to 2 do
8521: LD_ADDR_VAR 0 6
8525: PUSH
8526: DOUBLE
8527: LD_INT 1
8529: DEC
8530: ST_TO_ADDR
8531: LD_INT 2
8533: PUSH
8534: FOR_TO
8535: IFFALSE 8580
// begin un := CreateHumanWithClass ( class_bazooker , game_eskill ) ;
8537: LD_ADDR_VAR 0 7
8541: PUSH
8542: LD_INT 9
8544: PPUSH
8545: LD_EXP 4
8549: PPUSH
8550: CALL 9249 0 2
8554: ST_TO_ADDR
// PlaceUnitArea ( un , list [ f ] , false ) ;
8555: LD_VAR 0 7
8559: PPUSH
8560: LD_VAR 0 4
8564: PUSH
8565: LD_VAR 0 12
8569: ARRAY
8570: PPUSH
8571: LD_INT 0
8573: PPUSH
8574: CALL_OW 49
// end ;
8578: GO 8534
8580: POP
8581: POP
// end ; 3 :
8582: GO 8821
8584: LD_INT 3
8586: DOUBLE
8587: EQUAL
8588: IFTRUE 8592
8590: GO 8820
8592: POP
// begin for i = 1 to num do
8593: LD_ADDR_VAR 0 6
8597: PUSH
8598: DOUBLE
8599: LD_INT 1
8601: DEC
8602: ST_TO_ADDR
8603: LD_VAR 0 2
8607: PUSH
8608: FOR_TO
8609: IFFALSE 8816
// begin vc_chassis := chassis [ 2 ] ;
8611: LD_ADDR_OWVAR 37
8615: PUSH
8616: LD_VAR 0 10
8620: PUSH
8621: LD_INT 2
8623: ARRAY
8624: ST_TO_ADDR
// vc_engine := engine_combustion ;
8625: LD_ADDR_OWVAR 39
8629: PUSH
8630: LD_INT 1
8632: ST_TO_ADDR
// vc_control := [ control_computer , control_manual ] [ Rand ( 1 , 2 ) ] ;
8633: LD_ADDR_OWVAR 38
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 1
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: PUSH
8648: LD_INT 1
8650: PPUSH
8651: LD_INT 2
8653: PPUSH
8654: CALL_OW 12
8658: ARRAY
8659: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 6 ) ] ;
8660: LD_ADDR_OWVAR 40
8664: PUSH
8665: LD_VAR 0 11
8669: PUSH
8670: LD_INT 3
8672: PPUSH
8673: LD_INT 6
8675: PPUSH
8676: CALL_OW 12
8680: ARRAY
8681: ST_TO_ADDR
// veh := CreateVehicle ;
8682: LD_ADDR_VAR 0 9
8686: PUSH
8687: CALL_OW 45
8691: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
8692: LD_ADDR_VAR 0 12
8696: PUSH
8697: LD_INT 1
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: CALL_OW 12
8707: ST_TO_ADDR
// if f = 1 then
8708: LD_VAR 0 12
8712: PUSH
8713: LD_INT 1
8715: EQUAL
8716: IFFALSE 8732
// SetDir ( veh , 3 ) else
8718: LD_VAR 0 9
8722: PPUSH
8723: LD_INT 3
8725: PPUSH
8726: CALL_OW 233
8730: GO 8744
// SetDir ( veh , 1 ) ;
8732: LD_VAR 0 9
8736: PPUSH
8737: LD_INT 1
8739: PPUSH
8740: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
8744: LD_VAR 0 9
8748: PPUSH
8749: LD_VAR 0 4
8753: PUSH
8754: LD_VAR 0 12
8758: ARRAY
8759: PPUSH
8760: LD_INT 0
8762: PPUSH
8763: CALL_OW 49
// if GetControl ( veh ) = control_manual then
8767: LD_VAR 0 9
8771: PPUSH
8772: CALL_OW 263
8776: PUSH
8777: LD_INT 1
8779: EQUAL
8780: IFFALSE 8814
// begin un := CreateHumanWithClass ( 1 , game_eskill ) ;
8782: LD_ADDR_VAR 0 7
8786: PUSH
8787: LD_INT 1
8789: PPUSH
8790: LD_EXP 4
8794: PPUSH
8795: CALL 9249 0 2
8799: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8800: LD_VAR 0 7
8804: PPUSH
8805: LD_VAR 0 9
8809: PPUSH
8810: CALL_OW 52
// end ; end ;
8814: GO 8608
8816: POP
8817: POP
// end ; end ;
8818: GO 8821
8820: POP
// end ; end_of_file
8821: LD_VAR 0 5
8825: RET
// every 0 0$01 do
8826: GO 8828
8828: DISABLE
// PrepareAnimals ( 6 + game_diff , 5 , 4 , nature_area ) ; end_of_file
8829: LD_INT 6
8831: PUSH
8832: LD_EXP 2
8836: PLUS
8837: PPUSH
8838: LD_INT 5
8840: PPUSH
8841: LD_INT 4
8843: PPUSH
8844: LD_INT 8
8846: PPUSH
8847: CALL 8852 0 4
8851: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
8852: LD_INT 0
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// uc_nation = nation_nature ;
8859: LD_ADDR_OWVAR 21
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// uc_side = 0 ;
8867: LD_ADDR_OWVAR 20
8871: PUSH
8872: LD_INT 0
8874: ST_TO_ADDR
// l = 0 ;
8875: LD_ADDR_VAR 0 6
8879: PUSH
8880: LD_INT 0
8882: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
8883: LD_ADDR_OWVAR 24
8887: PUSH
8888: LD_INT 0
8890: PPUSH
8891: LD_INT 5
8893: PPUSH
8894: CALL_OW 12
8898: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
8899: LD_ADDR_OWVAR 35
8903: PUSH
8904: LD_INT 5
8906: NEG
8907: PPUSH
8908: LD_INT 5
8910: PPUSH
8911: CALL_OW 12
8915: ST_TO_ADDR
// hc_gallery =  ;
8916: LD_ADDR_OWVAR 33
8920: PUSH
8921: LD_STRING 
8923: ST_TO_ADDR
// hc_class = class_apeman ;
8924: LD_ADDR_OWVAR 28
8928: PUSH
8929: LD_INT 12
8931: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8932: LD_ADDR_OWVAR 29
8936: PUSH
8937: LD_INT 11
8939: PPUSH
8940: LD_INT 13
8942: PPUSH
8943: CALL_OW 12
8947: PUSH
8948: LD_INT 10
8950: PPUSH
8951: LD_INT 11
8953: PPUSH
8954: CALL_OW 12
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: ST_TO_ADDR
// hc_sex = sex_male ;
8963: LD_ADDR_OWVAR 27
8967: PUSH
8968: LD_INT 1
8970: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
8971: LD_ADDR_OWVAR 31
8975: PUSH
8976: LD_INT 0
8978: PPUSH
8979: LD_INT 2
8981: PPUSH
8982: CALL_OW 12
8986: PUSH
8987: LD_INT 0
8989: PUSH
8990: LD_INT 0
8992: PUSH
8993: LD_INT 0
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: LIST
9001: ST_TO_ADDR
// apeman = CreateHuman ;
9002: LD_ADDR_VAR 0 7
9006: PUSH
9007: CALL_OW 44
9011: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
9012: LD_VAR 0 7
9016: PPUSH
9017: LD_VAR 0 4
9021: PPUSH
9022: LD_INT 0
9024: PPUSH
9025: CALL_OW 49
// l = l + 1 ;
9029: LD_ADDR_VAR 0 6
9033: PUSH
9034: LD_VAR 0 6
9038: PUSH
9039: LD_INT 1
9041: PLUS
9042: ST_TO_ADDR
// end until l = num1 ;
9043: LD_VAR 0 6
9047: PUSH
9048: LD_VAR 0 1
9052: EQUAL
9053: IFFALSE 8883
// l = 0 ;
9055: LD_ADDR_VAR 0 6
9059: PUSH
9060: LD_INT 0
9062: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
9063: LD_ADDR_OWVAR 35
9067: PUSH
9068: LD_INT 0
9070: PPUSH
9071: LD_INT 25
9073: PPUSH
9074: CALL_OW 12
9078: ST_TO_ADDR
// hc_class = class_tiger ;
9079: LD_ADDR_OWVAR 28
9083: PUSH
9084: LD_INT 14
9086: ST_TO_ADDR
// hc_sex = sex_male ;
9087: LD_ADDR_OWVAR 27
9091: PUSH
9092: LD_INT 1
9094: ST_TO_ADDR
// hc_gallery = sandnature ;
9095: LD_ADDR_OWVAR 33
9099: PUSH
9100: LD_STRING sandnature
9102: ST_TO_ADDR
// hc_face_number = 3 ;
9103: LD_ADDR_OWVAR 34
9107: PUSH
9108: LD_INT 3
9110: ST_TO_ADDR
// tiger = CreateHuman ;
9111: LD_ADDR_VAR 0 8
9115: PUSH
9116: CALL_OW 44
9120: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
9121: LD_VAR 0 8
9125: PPUSH
9126: LD_VAR 0 4
9130: PPUSH
9131: LD_INT 0
9133: PPUSH
9134: CALL_OW 49
// l = l + 1 ;
9138: LD_ADDR_VAR 0 6
9142: PUSH
9143: LD_VAR 0 6
9147: PUSH
9148: LD_INT 1
9150: PLUS
9151: ST_TO_ADDR
// end until l = num2 ;
9152: LD_VAR 0 6
9156: PUSH
9157: LD_VAR 0 2
9161: EQUAL
9162: IFFALSE 9063
// l = 0 ;
9164: LD_ADDR_VAR 0 6
9168: PUSH
9169: LD_INT 0
9171: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
9172: LD_ADDR_OWVAR 28
9176: PUSH
9177: LD_INT 18
9179: ST_TO_ADDR
// hc_gallery = sandnature ;
9180: LD_ADDR_OWVAR 33
9184: PUSH
9185: LD_STRING sandnature
9187: ST_TO_ADDR
// hc_face_number = 1 ;
9188: LD_ADDR_OWVAR 34
9192: PUSH
9193: LD_INT 1
9195: ST_TO_ADDR
// bird = CreateHuman ;
9196: LD_ADDR_VAR 0 9
9200: PUSH
9201: CALL_OW 44
9205: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
9206: LD_VAR 0 9
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 51
// l = l + 1 ;
9218: LD_ADDR_VAR 0 6
9222: PUSH
9223: LD_VAR 0 6
9227: PUSH
9228: LD_INT 1
9230: PLUS
9231: ST_TO_ADDR
// end until l = num3 ;
9232: LD_VAR 0 6
9236: PUSH
9237: LD_VAR 0 3
9241: EQUAL
9242: IFFALSE 9172
// end ;
9244: LD_VAR 0 5
9248: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
9249: LD_INT 0
9251: PPUSH
9252: PPUSH
9253: PPUSH
9254: PPUSH
9255: PPUSH
9256: PPUSH
// hc_class := clas ;
9257: LD_ADDR_OWVAR 28
9261: PUSH
9262: LD_VAR 0 1
9266: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
9267: LD_ADDR_VAR 0 4
9271: PUSH
9272: LD_VAR 0 2
9276: PUSH
9277: LD_INT 1
9279: NEG
9280: PPUSH
9281: LD_INT 1
9283: PPUSH
9284: CALL_OW 12
9288: PLUS
9289: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: LD_VAR 0 2
9299: PUSH
9300: LD_INT 1
9302: NEG
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: CALL_OW 12
9311: PLUS
9312: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
9313: LD_ADDR_VAR 0 6
9317: PUSH
9318: LD_VAR 0 2
9322: PUSH
9323: LD_INT 1
9325: NEG
9326: PPUSH
9327: LD_INT 1
9329: PPUSH
9330: CALL_OW 12
9334: PLUS
9335: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
9336: LD_ADDR_VAR 0 7
9340: PUSH
9341: LD_VAR 0 2
9345: PUSH
9346: LD_INT 1
9348: NEG
9349: PPUSH
9350: LD_INT 1
9352: PPUSH
9353: CALL_OW 12
9357: PLUS
9358: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
9359: LD_VAR 0 1
9363: PUSH
9364: LD_INT 1
9366: EQUAL
9367: PUSH
9368: LD_VAR 0 1
9372: PUSH
9373: LD_INT 9
9375: EQUAL
9376: OR
9377: PUSH
9378: LD_VAR 0 1
9382: PUSH
9383: LD_INT 5
9385: EQUAL
9386: OR
9387: PUSH
9388: LD_VAR 0 1
9392: PUSH
9393: LD_INT 8
9395: EQUAL
9396: OR
9397: IFFALSE 9422
// bonus := [ 2 , 0 , 0 , 0 ] ;
9399: LD_ADDR_VAR 0 8
9403: PUSH
9404: LD_INT 2
9406: PUSH
9407: LD_INT 0
9409: PUSH
9410: LD_INT 0
9412: PUSH
9413: LD_INT 0
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: ST_TO_ADDR
// if clas = 2 then
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 2
9429: EQUAL
9430: IFFALSE 9455
// bonus := [ 0 , 2 , 0 , 0 ] ;
9432: LD_ADDR_VAR 0 8
9436: PUSH
9437: LD_INT 0
9439: PUSH
9440: LD_INT 2
9442: PUSH
9443: LD_INT 0
9445: PUSH
9446: LD_INT 0
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: ST_TO_ADDR
// if clas = 3 then
9455: LD_VAR 0 1
9459: PUSH
9460: LD_INT 3
9462: EQUAL
9463: IFFALSE 9488
// bonus := [ 0 , 0 , 2 , 0 ] ;
9465: LD_ADDR_VAR 0 8
9469: PUSH
9470: LD_INT 0
9472: PUSH
9473: LD_INT 0
9475: PUSH
9476: LD_INT 2
9478: PUSH
9479: LD_INT 0
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: LIST
9487: ST_TO_ADDR
// if clas = 4 then
9488: LD_VAR 0 1
9492: PUSH
9493: LD_INT 4
9495: EQUAL
9496: IFFALSE 9521
// bonus := [ 0 , 0 , 0 , 2 ] ;
9498: LD_ADDR_VAR 0 8
9502: PUSH
9503: LD_INT 0
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: LD_INT 0
9511: PUSH
9512: LD_INT 2
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
9521: LD_VAR 0 1
9525: PUSH
9526: LD_INT 4
9528: GREATER
9529: PUSH
9530: LD_VAR 0 1
9534: PUSH
9535: LD_INT 9
9537: NONEQUAL
9538: AND
9539: PUSH
9540: LD_VAR 0 1
9544: PUSH
9545: LD_INT 5
9547: NONEQUAL
9548: AND
9549: PUSH
9550: LD_VAR 0 1
9554: PUSH
9555: LD_INT 8
9557: NONEQUAL
9558: AND
9559: IFFALSE 9584
// bonus := [ 0 , 0 , 0 , 0 ] ;
9561: LD_ADDR_VAR 0 8
9565: PUSH
9566: LD_INT 0
9568: PUSH
9569: LD_INT 0
9571: PUSH
9572: LD_INT 0
9574: PUSH
9575: LD_INT 0
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
9584: LD_ADDR_OWVAR 30
9588: PUSH
9589: LD_INT 0
9591: PPUSH
9592: LD_INT 2
9594: PPUSH
9595: CALL_OW 12
9599: PUSH
9600: LD_INT 0
9602: PPUSH
9603: LD_INT 2
9605: PPUSH
9606: CALL_OW 12
9610: PUSH
9611: LD_INT 0
9613: PPUSH
9614: LD_INT 2
9616: PPUSH
9617: CALL_OW 12
9621: PUSH
9622: LD_INT 0
9624: PPUSH
9625: LD_INT 2
9627: PPUSH
9628: CALL_OW 12
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
9639: LD_ADDR_OWVAR 31
9643: PUSH
9644: LD_VAR 0 4
9648: PUSH
9649: LD_VAR 0 8
9653: PUSH
9654: LD_INT 1
9656: ARRAY
9657: PLUS
9658: PUSH
9659: LD_VAR 0 5
9663: PUSH
9664: LD_VAR 0 8
9668: PUSH
9669: LD_INT 2
9671: ARRAY
9672: PLUS
9673: PUSH
9674: LD_VAR 0 6
9678: PUSH
9679: LD_VAR 0 8
9683: PUSH
9684: LD_INT 3
9686: ARRAY
9687: PLUS
9688: PUSH
9689: LD_VAR 0 7
9693: PUSH
9694: LD_VAR 0 8
9698: PUSH
9699: LD_INT 4
9701: ARRAY
9702: PLUS
9703: PUSH
9704: EMPTY
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
9710: LD_ADDR_OWVAR 27
9714: PUSH
9715: LD_INT 1
9717: PPUSH
9718: LD_INT 2
9720: PPUSH
9721: CALL_OW 12
9725: ST_TO_ADDR
// hc_gallery :=  ;
9726: LD_ADDR_OWVAR 33
9730: PUSH
9731: LD_STRING 
9733: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
9734: LD_ADDR_OWVAR 29
9738: PUSH
9739: LD_INT 8
9741: PPUSH
9742: LD_INT 12
9744: PPUSH
9745: CALL_OW 12
9749: PUSH
9750: LD_INT 9
9752: PPUSH
9753: LD_INT 11
9755: PPUSH
9756: CALL_OW 12
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: ST_TO_ADDR
// hc_name :=  ;
9765: LD_ADDR_OWVAR 26
9769: PUSH
9770: LD_STRING 
9772: ST_TO_ADDR
// result := CreateHuman ;
9773: LD_ADDR_VAR 0 3
9777: PUSH
9778: CALL_OW 44
9782: ST_TO_ADDR
// end ;
9783: LD_VAR 0 3
9787: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
9788: LD_INT 0
9790: PPUSH
9791: PPUSH
// vc_chassis := chassis ;
9792: LD_ADDR_OWVAR 37
9796: PUSH
9797: LD_VAR 0 1
9801: ST_TO_ADDR
// vc_engine := engine ;
9802: LD_ADDR_OWVAR 39
9806: PUSH
9807: LD_VAR 0 2
9811: ST_TO_ADDR
// vc_weapon := weapon ;
9812: LD_ADDR_OWVAR 40
9816: PUSH
9817: LD_VAR 0 3
9821: ST_TO_ADDR
// vc_control := control_manual ;
9822: LD_ADDR_OWVAR 38
9826: PUSH
9827: LD_INT 1
9829: ST_TO_ADDR
// veh := CreateVehicle ;
9830: LD_ADDR_VAR 0 8
9834: PUSH
9835: CALL_OW 45
9839: ST_TO_ADDR
// SetDir ( veh , dir ) ;
9840: LD_VAR 0 8
9844: PPUSH
9845: LD_VAR 0 5
9849: PPUSH
9850: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
9854: LD_VAR 0 8
9858: PPUSH
9859: LD_VAR 0 4
9863: PPUSH
9864: LD_INT 0
9866: PPUSH
9867: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
9871: LD_INT 3
9873: PPUSH
9874: LD_VAR 0 6
9878: PPUSH
9879: CALL 9249 0 2
9883: PPUSH
9884: LD_VAR 0 8
9888: PPUSH
9889: CALL_OW 52
// end ;
9893: LD_VAR 0 7
9897: RET
// export function LegionAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
9898: LD_INT 0
9900: PPUSH
9901: PPUSH
9902: PPUSH
9903: PPUSH
9904: PPUSH
9905: PPUSH
9906: PPUSH
// uc_side := side ;
9907: LD_ADDR_OWVAR 20
9911: PUSH
9912: LD_VAR 0 1
9916: ST_TO_ADDR
// uc_nation := nation_arabian ;
9917: LD_ADDR_OWVAR 21
9921: PUSH
9922: LD_INT 2
9924: ST_TO_ADDR
// chassis := [ ar_half_tracked ] ;
9925: LD_ADDR_VAR 0 10
9929: PUSH
9930: LD_INT 14
9932: PUSH
9933: EMPTY
9934: LIST
9935: ST_TO_ADDR
// weapon := [ ar_double_machine_gun , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
9936: LD_ADDR_VAR 0 11
9940: PUSH
9941: LD_INT 24
9943: PUSH
9944: LD_INT 25
9946: PUSH
9947: LD_INT 27
9949: PUSH
9950: LD_INT 28
9952: PUSH
9953: LD_INT 29
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: LIST
9960: LIST
9961: LIST
9962: ST_TO_ADDR
// case typ of 1 :
9963: LD_VAR 0 3
9967: PUSH
9968: LD_INT 1
9970: DOUBLE
9971: EQUAL
9972: IFTRUE 9976
9974: GO 10148
9976: POP
// begin for i = 1 to num do
9977: LD_ADDR_VAR 0 6
9981: PUSH
9982: DOUBLE
9983: LD_INT 1
9985: DEC
9986: ST_TO_ADDR
9987: LD_VAR 0 2
9991: PUSH
9992: FOR_TO
9993: IFFALSE 10144
// begin vc_chassis := chassis [ 1 ] ;
9995: LD_ADDR_OWVAR 37
9999: PUSH
10000: LD_VAR 0 10
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: ST_TO_ADDR
// vc_engine := engine_combustion ;
10009: LD_ADDR_OWVAR 39
10013: PUSH
10014: LD_INT 1
10016: ST_TO_ADDR
// vc_control := control_manual ;
10017: LD_ADDR_OWVAR 38
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
10025: LD_ADDR_OWVAR 40
10029: PUSH
10030: LD_VAR 0 11
10034: PUSH
10035: LD_INT 1
10037: PPUSH
10038: LD_INT 3
10040: PPUSH
10041: CALL_OW 12
10045: ARRAY
10046: ST_TO_ADDR
// veh := CreateVehicle ;
10047: LD_ADDR_VAR 0 9
10051: PUSH
10052: CALL_OW 45
10056: ST_TO_ADDR
// if area = north_spawn then
10057: LD_VAR 0 4
10061: PUSH
10062: LD_INT 6
10064: EQUAL
10065: IFFALSE 10081
// SetDir ( veh , 3 ) else
10067: LD_VAR 0 9
10071: PPUSH
10072: LD_INT 3
10074: PPUSH
10075: CALL_OW 233
10079: GO 10093
// SetDir ( veh , 1 ) ;
10081: LD_VAR 0 9
10085: PPUSH
10086: LD_INT 1
10088: PPUSH
10089: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
10093: LD_VAR 0 9
10097: PPUSH
10098: LD_VAR 0 4
10102: PPUSH
10103: LD_INT 0
10105: PPUSH
10106: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
10110: LD_ADDR_VAR 0 7
10114: PUSH
10115: LD_INT 1
10117: PPUSH
10118: LD_EXP 4
10122: PPUSH
10123: CALL 9249 0 2
10127: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10128: LD_VAR 0 7
10132: PPUSH
10133: LD_VAR 0 9
10137: PPUSH
10138: CALL_OW 52
// end ;
10142: GO 9992
10144: POP
10145: POP
// end ; 2 :
10146: GO 10407
10148: LD_INT 2
10150: DOUBLE
10151: EQUAL
10152: IFTRUE 10156
10154: GO 10406
10156: POP
// begin for i = 1 to num do
10157: LD_ADDR_VAR 0 6
10161: PUSH
10162: DOUBLE
10163: LD_INT 1
10165: DEC
10166: ST_TO_ADDR
10167: LD_VAR 0 2
10171: PUSH
10172: FOR_TO
10173: IFFALSE 10324
// begin vc_chassis := chassis [ 1 ] ;
10175: LD_ADDR_OWVAR 37
10179: PUSH
10180: LD_VAR 0 10
10184: PUSH
10185: LD_INT 1
10187: ARRAY
10188: ST_TO_ADDR
// vc_engine := engine_combustion ;
10189: LD_ADDR_OWVAR 39
10193: PUSH
10194: LD_INT 1
10196: ST_TO_ADDR
// vc_control := control_manual ;
10197: LD_ADDR_OWVAR 38
10201: PUSH
10202: LD_INT 1
10204: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 5 ) ] ;
10205: LD_ADDR_OWVAR 40
10209: PUSH
10210: LD_VAR 0 11
10214: PUSH
10215: LD_INT 3
10217: PPUSH
10218: LD_INT 5
10220: PPUSH
10221: CALL_OW 12
10225: ARRAY
10226: ST_TO_ADDR
// veh := CreateVehicle ;
10227: LD_ADDR_VAR 0 9
10231: PUSH
10232: CALL_OW 45
10236: ST_TO_ADDR
// if area = north_spawn then
10237: LD_VAR 0 4
10241: PUSH
10242: LD_INT 6
10244: EQUAL
10245: IFFALSE 10261
// SetDir ( veh , 3 ) else
10247: LD_VAR 0 9
10251: PPUSH
10252: LD_INT 3
10254: PPUSH
10255: CALL_OW 233
10259: GO 10273
// SetDir ( veh , 1 ) ;
10261: LD_VAR 0 9
10265: PPUSH
10266: LD_INT 1
10268: PPUSH
10269: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
10273: LD_VAR 0 9
10277: PPUSH
10278: LD_VAR 0 4
10282: PPUSH
10283: LD_INT 0
10285: PPUSH
10286: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
10290: LD_ADDR_VAR 0 7
10294: PUSH
10295: LD_INT 1
10297: PPUSH
10298: LD_EXP 4
10302: PPUSH
10303: CALL 9249 0 2
10307: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10308: LD_VAR 0 7
10312: PPUSH
10313: LD_VAR 0 9
10317: PPUSH
10318: CALL_OW 52
// end ;
10322: GO 10172
10324: POP
10325: POP
// for i = 1 to 4 do
10326: LD_ADDR_VAR 0 6
10330: PUSH
10331: DOUBLE
10332: LD_INT 1
10334: DEC
10335: ST_TO_ADDR
10336: LD_INT 4
10338: PUSH
10339: FOR_TO
10340: IFFALSE 10402
// begin uc_nation := 0 ;
10342: LD_ADDR_OWVAR 21
10346: PUSH
10347: LD_INT 0
10349: ST_TO_ADDR
// hc_class := 17 ;
10350: LD_ADDR_OWVAR 28
10354: PUSH
10355: LD_INT 17
10357: ST_TO_ADDR
// hc_attr := [ 11 , 13 ] ;
10358: LD_ADDR_OWVAR 29
10362: PUSH
10363: LD_INT 11
10365: PUSH
10366: LD_INT 13
10368: PUSH
10369: EMPTY
10370: LIST
10371: LIST
10372: ST_TO_ADDR
// un := CreateHuman ;
10373: LD_ADDR_VAR 0 7
10377: PUSH
10378: CALL_OW 44
10382: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
10383: LD_VAR 0 7
10387: PPUSH
10388: LD_VAR 0 4
10392: PPUSH
10393: LD_INT 0
10395: PPUSH
10396: CALL_OW 49
// end ;
10400: GO 10339
10402: POP
10403: POP
// end ; end ;
10404: GO 10407
10406: POP
// end ;
10407: LD_VAR 0 5
10411: RET
// export function GetDistXYToSide ( x , y , side ) ; var tmp , dist ; begin
10412: LD_INT 0
10414: PPUSH
10415: PPUSH
10416: PPUSH
// tmp := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
10417: LD_ADDR_VAR 0 5
10421: PUSH
10422: LD_INT 22
10424: PUSH
10425: LD_VAR 0 3
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PPUSH
10434: CALL_OW 69
10438: PPUSH
10439: LD_VAR 0 1
10443: PPUSH
10444: LD_VAR 0 2
10448: PPUSH
10449: CALL_OW 73
10453: ST_TO_ADDR
// dist := GetDistUnitXY ( tmp , x , y ) ;
10454: LD_ADDR_VAR 0 6
10458: PUSH
10459: LD_VAR 0 5
10463: PPUSH
10464: LD_VAR 0 1
10468: PPUSH
10469: LD_VAR 0 2
10473: PPUSH
10474: CALL_OW 297
10478: ST_TO_ADDR
// result := dist ;
10479: LD_ADDR_VAR 0 4
10483: PUSH
10484: LD_VAR 0 6
10488: ST_TO_ADDR
// end ;
10489: LD_VAR 0 4
10493: RET
// export function GetSibAmount ( side ) ; var i , bases ; begin
10494: LD_INT 0
10496: PPUSH
10497: PPUSH
10498: PPUSH
// result := 0 ;
10499: LD_ADDR_VAR 0 2
10503: PUSH
10504: LD_INT 0
10506: ST_TO_ADDR
// bases := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10507: LD_ADDR_VAR 0 4
10511: PUSH
10512: LD_INT 22
10514: PUSH
10515: LD_VAR 0 1
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 2
10526: PUSH
10527: LD_INT 30
10529: PUSH
10530: LD_INT 0
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PUSH
10537: LD_INT 30
10539: PUSH
10540: LD_INT 1
10542: PUSH
10543: EMPTY
10544: LIST
10545: LIST
10546: PUSH
10547: EMPTY
10548: LIST
10549: LIST
10550: LIST
10551: PUSH
10552: EMPTY
10553: LIST
10554: LIST
10555: PPUSH
10556: CALL_OW 69
10560: ST_TO_ADDR
// if not bases then
10561: LD_VAR 0 4
10565: NOT
10566: IFFALSE 10570
// exit ;
10568: GO 10616
// for i in bases do
10570: LD_ADDR_VAR 0 3
10574: PUSH
10575: LD_VAR 0 4
10579: PUSH
10580: FOR_IN
10581: IFFALSE 10614
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
10583: LD_ADDR_VAR 0 2
10587: PUSH
10588: LD_VAR 0 2
10592: PUSH
10593: LD_VAR 0 3
10597: PPUSH
10598: CALL_OW 274
10602: PPUSH
10603: LD_INT 3
10605: PPUSH
10606: CALL_OW 275
10610: PLUS
10611: ST_TO_ADDR
10612: GO 10580
10614: POP
10615: POP
// end ; end_of_file
10616: LD_VAR 0 2
10620: RET
// on UnitDestroyed ( un ) do begin if un = jota_base then
10621: LD_VAR 0 1
10625: PUSH
10626: LD_INT 1
10628: EQUAL
10629: IFFALSE 10638
// YouLost ( jota-lose ) ;
10631: LD_STRING jota-lose
10633: PPUSH
10634: CALL_OW 104
// if game_type = 2 and depot_captured = false then
10638: LD_EXP 1
10642: PUSH
10643: LD_INT 2
10645: EQUAL
10646: PUSH
10647: LD_EXP 8
10651: PUSH
10652: LD_INT 0
10654: EQUAL
10655: AND
10656: IFFALSE 10971
// begin if GetSide ( un ) = 1 and un in FilterUnitsInArea ( def_area , [ f_type , unit_building ] ) diff FilterAllUnits ( [ [ [ [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_weapon ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ] ] ] ) then
10658: LD_VAR 0 1
10662: PPUSH
10663: CALL_OW 255
10667: PUSH
10668: LD_INT 1
10670: EQUAL
10671: PUSH
10672: LD_VAR 0 1
10676: PUSH
10677: LD_INT 11
10679: PPUSH
10680: LD_INT 21
10682: PUSH
10683: LD_INT 3
10685: PUSH
10686: EMPTY
10687: LIST
10688: LIST
10689: PPUSH
10690: CALL_OW 70
10694: PUSH
10695: LD_INT 2
10697: PUSH
10698: LD_INT 30
10700: PUSH
10701: LD_INT 6
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: PUSH
10708: LD_INT 30
10710: PUSH
10711: LD_INT 10
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PUSH
10718: LD_INT 30
10720: PUSH
10721: LD_INT 7
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PUSH
10728: LD_INT 30
10730: PUSH
10731: LD_INT 8
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: LIST
10742: LIST
10743: LIST
10744: PUSH
10745: EMPTY
10746: LIST
10747: PUSH
10748: EMPTY
10749: LIST
10750: PUSH
10751: EMPTY
10752: LIST
10753: PUSH
10754: EMPTY
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: DIFF
10762: IN
10763: AND
10764: IFFALSE 10850
// begin ai_build := ai_build ^ GetBType ( un ) ;
10766: LD_ADDR_EXP 10
10770: PUSH
10771: LD_EXP 10
10775: PUSH
10776: LD_VAR 0 1
10780: PPUSH
10781: CALL_OW 266
10785: ADD
10786: ST_TO_ADDR
// ai_build := ai_build ^ GetX ( un ) ;
10787: LD_ADDR_EXP 10
10791: PUSH
10792: LD_EXP 10
10796: PUSH
10797: LD_VAR 0 1
10801: PPUSH
10802: CALL_OW 250
10806: ADD
10807: ST_TO_ADDR
// ai_build := ai_build ^ GetY ( un ) ;
10808: LD_ADDR_EXP 10
10812: PUSH
10813: LD_EXP 10
10817: PUSH
10818: LD_VAR 0 1
10822: PPUSH
10823: CALL_OW 251
10827: ADD
10828: ST_TO_ADDR
// ai_build := ai_build ^ GetDir ( un ) ;
10829: LD_ADDR_EXP 10
10833: PUSH
10834: LD_EXP 10
10838: PUSH
10839: LD_VAR 0 1
10843: PPUSH
10844: CALL_OW 254
10848: ADD
10849: ST_TO_ADDR
// end ; if GetSide ( un ) = 1 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) then
10850: LD_VAR 0 1
10854: PPUSH
10855: CALL_OW 255
10859: PUSH
10860: LD_INT 1
10862: EQUAL
10863: PUSH
10864: LD_VAR 0 1
10868: PUSH
10869: LD_INT 21
10871: PUSH
10872: LD_INT 2
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PPUSH
10879: CALL_OW 69
10883: IN
10884: AND
10885: IFFALSE 10971
// begin ai_vehs := ai_vehs ^ GetChassis ( un ) ;
10887: LD_ADDR_EXP 11
10891: PUSH
10892: LD_EXP 11
10896: PUSH
10897: LD_VAR 0 1
10901: PPUSH
10902: CALL_OW 265
10906: ADD
10907: ST_TO_ADDR
// ai_vehs := ai_vehs ^ GetEngine ( un ) ;
10908: LD_ADDR_EXP 11
10912: PUSH
10913: LD_EXP 11
10917: PUSH
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 262
10927: ADD
10928: ST_TO_ADDR
// ai_vehs := ai_vehs ^ GetControl ( un ) ;
10929: LD_ADDR_EXP 11
10933: PUSH
10934: LD_EXP 11
10938: PUSH
10939: LD_VAR 0 1
10943: PPUSH
10944: CALL_OW 263
10948: ADD
10949: ST_TO_ADDR
// ai_vehs := ai_vehs ^ GetWeapon ( un ) ;
10950: LD_ADDR_EXP 11
10954: PUSH
10955: LD_EXP 11
10959: PUSH
10960: LD_VAR 0 1
10964: PPUSH
10965: CALL_OW 264
10969: ADD
10970: ST_TO_ADDR
// end ; end ; end ;
10971: PPOPN 1
10973: END
// every 0 0$03 trigger game_type = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
10974: LD_EXP 1
10978: PUSH
10979: LD_INT 1
10981: EQUAL
10982: PUSH
10983: LD_INT 22
10985: PUSH
10986: LD_INT 1
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: PUSH
10993: LD_INT 21
10995: PUSH
10996: LD_INT 1
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: PPUSH
11007: CALL_OW 69
11011: PUSH
11012: LD_INT 0
11014: EQUAL
11015: AND
11016: IFFALSE 11028
11018: GO 11020
11020: DISABLE
// YouLost ( peo-lose ) ;
11021: LD_STRING peo-lose
11023: PPUSH
11024: CALL_OW 104
11028: END
// every 0 0$03 trigger game_type = 2 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11029: LD_EXP 1
11033: PUSH
11034: LD_INT 2
11036: EQUAL
11037: PUSH
11038: LD_INT 22
11040: PUSH
11041: LD_INT 3
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 21
11050: PUSH
11051: LD_INT 1
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PPUSH
11062: CALL_OW 69
11066: PUSH
11067: LD_INT 0
11069: EQUAL
11070: AND
11071: IFFALSE 11083
11073: GO 11075
11075: DISABLE
// YouLost ( peo-lose ) ;
11076: LD_STRING peo-lose
11078: PPUSH
11079: CALL_OW 104
11083: END
// every 0 0$03 trigger GetSibAmount ( your_side ) >= need_to_win do var i ;
11084: LD_OWVAR 2
11088: PPUSH
11089: CALL 10494 0 1
11093: PUSH
11094: LD_EXP 5
11098: GREATEREQUAL
11099: IFFALSE 11185
11101: GO 11103
11103: DISABLE
11104: LD_INT 0
11106: PPUSH
// begin if GetSide ( jota_base ) = your_side then
11107: LD_INT 1
11109: PPUSH
11110: CALL_OW 255
11114: PUSH
11115: LD_OWVAR 2
11119: EQUAL
11120: IFFALSE 11163
// begin for i = 1 to 3 do
11122: LD_ADDR_VAR 0 1
11126: PUSH
11127: DOUBLE
11128: LD_INT 1
11130: DEC
11131: ST_TO_ADDR
11132: LD_INT 3
11134: PUSH
11135: FOR_TO
11136: IFFALSE 11150
// AddMedal ( med , 1 ) ;
11138: LD_STRING med
11140: PPUSH
11141: LD_INT 1
11143: PPUSH
11144: CALL_OW 101
11148: GO 11135
11150: POP
11151: POP
// GiveMedals ( MAIN ) ;
11152: LD_STRING MAIN
11154: PPUSH
11155: CALL_OW 102
// YouWin ;
11159: CALL_OW 103
// end ; if GetSide ( jota_base ) <> your_side then
11163: LD_INT 1
11165: PPUSH
11166: CALL_OW 255
11170: PUSH
11171: LD_OWVAR 2
11175: NONEQUAL
11176: IFFALSE 11185
// YouLost ( source ) ;
11178: LD_STRING source
11180: PPUSH
11181: CALL_OW 104
// end ; end_of_file
11185: PPOPN 1
11187: END
// every 2 2$05 + 0 0$11 do
11188: GO 11190
11190: DISABLE
// begin enable ;
11191: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
11192: LD_INT 1
11194: PPUSH
11195: LD_INT 5
11197: PPUSH
11198: CALL_OW 12
11202: PPUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
11213: LD_INT 350
11215: PPUSH
11216: LD_INT 1295
11218: PPUSH
11219: CALL_OW 12
11223: PPUSH
11224: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
11228: LD_INT 1
11230: PPUSH
11231: LD_INT 5
11233: PPUSH
11234: CALL_OW 12
11238: PPUSH
11239: LD_INT 1
11241: PPUSH
11242: CALL_OW 57
// end ;
11246: END
// every 1 1$09 trigger game_type = 2 and depot_captured = false do
11247: LD_EXP 1
11251: PUSH
11252: LD_INT 2
11254: EQUAL
11255: PUSH
11256: LD_EXP 8
11260: PUSH
11261: LD_INT 0
11263: EQUAL
11264: AND
11265: IFFALSE 11355
11267: GO 11269
11269: DISABLE
// begin enable ;
11270: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
11271: LD_INT 1
11273: PPUSH
11274: LD_INT 5
11276: PPUSH
11277: CALL_OW 12
11281: PPUSH
11282: LD_INT 7
11284: PPUSH
11285: LD_INT 1
11287: PPUSH
11288: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$50 ) ) ;
11292: LD_INT 350
11294: PPUSH
11295: LD_INT 1750
11297: PPUSH
11298: CALL_OW 12
11302: PPUSH
11303: CALL_OW 67
// if timer <= [ 35 35$00 , 30 30$00 , 25 25$00 ] [ game_diff ] then
11307: LD_EXP 6
11311: PUSH
11312: LD_INT 73500
11314: PUSH
11315: LD_INT 63000
11317: PUSH
11318: LD_INT 52500
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: LIST
11325: PUSH
11326: LD_EXP 2
11330: ARRAY
11331: LESSEQUAL
11332: IFFALSE 11355
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crate , true ) ;
11334: LD_INT 1
11336: PPUSH
11337: LD_INT 5
11339: PPUSH
11340: CALL_OW 12
11344: PPUSH
11345: LD_INT 12
11347: PPUSH
11348: LD_INT 1
11350: PPUSH
11351: CALL_OW 55
// end ; end_of_file
11355: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
11356: LD_VAR 0 1
11360: PPUSH
11361: LD_VAR 0 2
11365: PPUSH
11366: LD_VAR 0 3
11370: PPUSH
11371: CALL 11434 0 3
// end ;
11375: PPOPN 3
11377: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11378: LD_VAR 0 1
11382: PPUSH
11383: CALL 11532 0 1
// end ; end_of_file
11387: PPOPN 1
11389: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11390: GO 11392
11392: DISABLE
// begin ru_radar := 98 ;
11393: LD_ADDR_EXP 21
11397: PUSH
11398: LD_INT 98
11400: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11401: LD_ADDR_EXP 22
11405: PUSH
11406: LD_INT 89
11408: ST_TO_ADDR
// us_hack := 99 ;
11409: LD_ADDR_EXP 23
11413: PUSH
11414: LD_INT 99
11416: ST_TO_ADDR
// us_artillery := 97 ;
11417: LD_ADDR_EXP 24
11421: PUSH
11422: LD_INT 97
11424: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11425: LD_ADDR_EXP 25
11429: PUSH
11430: LD_INT 91
11432: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
11433: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11434: LD_INT 0
11436: PPUSH
11437: PPUSH
11438: PPUSH
11439: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11440: LD_VAR 0 1
11444: PPUSH
11445: CALL_OW 264
11449: PUSH
11450: LD_EXP 25
11454: EQUAL
11455: IFFALSE 11527
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11457: LD_INT 68
11459: PPUSH
11460: LD_VAR 0 1
11464: PPUSH
11465: CALL_OW 255
11469: PPUSH
11470: CALL_OW 321
11474: PUSH
11475: LD_INT 2
11477: EQUAL
11478: IFFALSE 11490
// eff := 70 else
11480: LD_ADDR_VAR 0 6
11484: PUSH
11485: LD_INT 70
11487: ST_TO_ADDR
11488: GO 11498
// eff := 30 ;
11490: LD_ADDR_VAR 0 6
11494: PUSH
11495: LD_INT 30
11497: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11498: LD_VAR 0 1
11502: PPUSH
11503: CALL_OW 250
11507: PPUSH
11508: LD_VAR 0 1
11512: PPUSH
11513: CALL_OW 251
11517: PPUSH
11518: LD_VAR 0 6
11522: PPUSH
11523: CALL_OW 495
// end ; end ;
11527: LD_VAR 0 4
11531: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11532: LD_INT 0
11534: PPUSH
11535: PPUSH
11536: PPUSH
11537: PPUSH
11538: PPUSH
11539: PPUSH
// if cmd = 124 then
11540: LD_VAR 0 1
11544: PUSH
11545: LD_INT 124
11547: EQUAL
11548: IFFALSE 11754
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11550: LD_ADDR_VAR 0 5
11554: PUSH
11555: LD_INT 2
11557: PUSH
11558: LD_INT 34
11560: PUSH
11561: LD_INT 53
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: PUSH
11568: LD_INT 34
11570: PUSH
11571: LD_INT 14
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: PPUSH
11583: CALL_OW 69
11587: ST_TO_ADDR
// if not tmp then
11588: LD_VAR 0 5
11592: NOT
11593: IFFALSE 11597
// exit ;
11595: GO 11754
// for i in tmp do
11597: LD_ADDR_VAR 0 3
11601: PUSH
11602: LD_VAR 0 5
11606: PUSH
11607: FOR_IN
11608: IFFALSE 11752
// begin taskList := GetTaskList ( i ) ;
11610: LD_ADDR_VAR 0 6
11614: PUSH
11615: LD_VAR 0 3
11619: PPUSH
11620: CALL_OW 437
11624: ST_TO_ADDR
// if not taskList then
11625: LD_VAR 0 6
11629: NOT
11630: IFFALSE 11634
// continue ;
11632: GO 11607
// for j = 1 to taskList do
11634: LD_ADDR_VAR 0 4
11638: PUSH
11639: DOUBLE
11640: LD_INT 1
11642: DEC
11643: ST_TO_ADDR
11644: LD_VAR 0 6
11648: PUSH
11649: FOR_TO
11650: IFFALSE 11748
// if taskList [ j ] [ 1 ] = | then
11652: LD_VAR 0 6
11656: PUSH
11657: LD_VAR 0 4
11661: ARRAY
11662: PUSH
11663: LD_INT 1
11665: ARRAY
11666: PUSH
11667: LD_STRING |
11669: EQUAL
11670: IFFALSE 11746
// begin _taskList := Delete ( taskList , 1 ) ;
11672: LD_ADDR_VAR 0 7
11676: PUSH
11677: LD_VAR 0 6
11681: PPUSH
11682: LD_INT 1
11684: PPUSH
11685: CALL_OW 3
11689: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11690: LD_VAR 0 3
11694: PPUSH
11695: LD_VAR 0 7
11699: PPUSH
11700: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11704: LD_VAR 0 3
11708: PPUSH
11709: LD_VAR 0 6
11713: PUSH
11714: LD_VAR 0 4
11718: ARRAY
11719: PUSH
11720: LD_INT 2
11722: ARRAY
11723: PPUSH
11724: LD_VAR 0 6
11728: PUSH
11729: LD_VAR 0 4
11733: ARRAY
11734: PUSH
11735: LD_INT 3
11737: ARRAY
11738: PPUSH
11739: LD_INT 8
11741: PPUSH
11742: CALL 11759 0 4
// end ;
11746: GO 11649
11748: POP
11749: POP
// end ;
11750: GO 11607
11752: POP
11753: POP
// end ; end ;
11754: LD_VAR 0 2
11758: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11759: LD_INT 0
11761: PPUSH
11762: PPUSH
11763: PPUSH
11764: PPUSH
11765: PPUSH
11766: PPUSH
11767: PPUSH
11768: PPUSH
11769: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11770: LD_VAR 0 1
11774: NOT
11775: PUSH
11776: LD_VAR 0 2
11780: PPUSH
11781: LD_VAR 0 3
11785: PPUSH
11786: CALL_OW 488
11790: NOT
11791: OR
11792: PUSH
11793: LD_VAR 0 4
11797: NOT
11798: OR
11799: IFFALSE 11803
// exit ;
11801: GO 12143
// list := [ ] ;
11803: LD_ADDR_VAR 0 13
11807: PUSH
11808: EMPTY
11809: ST_TO_ADDR
// if x - r < 0 then
11810: LD_VAR 0 2
11814: PUSH
11815: LD_VAR 0 4
11819: MINUS
11820: PUSH
11821: LD_INT 0
11823: LESS
11824: IFFALSE 11836
// min_x := 0 else
11826: LD_ADDR_VAR 0 7
11830: PUSH
11831: LD_INT 0
11833: ST_TO_ADDR
11834: GO 11852
// min_x := x - r ;
11836: LD_ADDR_VAR 0 7
11840: PUSH
11841: LD_VAR 0 2
11845: PUSH
11846: LD_VAR 0 4
11850: MINUS
11851: ST_TO_ADDR
// if y - r < 0 then
11852: LD_VAR 0 3
11856: PUSH
11857: LD_VAR 0 4
11861: MINUS
11862: PUSH
11863: LD_INT 0
11865: LESS
11866: IFFALSE 11878
// min_y := 0 else
11868: LD_ADDR_VAR 0 8
11872: PUSH
11873: LD_INT 0
11875: ST_TO_ADDR
11876: GO 11894
// min_y := y - r ;
11878: LD_ADDR_VAR 0 8
11882: PUSH
11883: LD_VAR 0 3
11887: PUSH
11888: LD_VAR 0 4
11892: MINUS
11893: ST_TO_ADDR
// max_x := x + r ;
11894: LD_ADDR_VAR 0 9
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_VAR 0 4
11908: PLUS
11909: ST_TO_ADDR
// max_y := y + r ;
11910: LD_ADDR_VAR 0 10
11914: PUSH
11915: LD_VAR 0 3
11919: PUSH
11920: LD_VAR 0 4
11924: PLUS
11925: ST_TO_ADDR
// for _x = min_x to max_x do
11926: LD_ADDR_VAR 0 11
11930: PUSH
11931: DOUBLE
11932: LD_VAR 0 7
11936: DEC
11937: ST_TO_ADDR
11938: LD_VAR 0 9
11942: PUSH
11943: FOR_TO
11944: IFFALSE 12061
// for _y = min_y to max_y do
11946: LD_ADDR_VAR 0 12
11950: PUSH
11951: DOUBLE
11952: LD_VAR 0 8
11956: DEC
11957: ST_TO_ADDR
11958: LD_VAR 0 10
11962: PUSH
11963: FOR_TO
11964: IFFALSE 12057
// begin if not ValidHex ( _x , _y ) then
11966: LD_VAR 0 11
11970: PPUSH
11971: LD_VAR 0 12
11975: PPUSH
11976: CALL_OW 488
11980: NOT
11981: IFFALSE 11985
// continue ;
11983: GO 11963
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11985: LD_VAR 0 11
11989: PPUSH
11990: LD_VAR 0 12
11994: PPUSH
11995: CALL_OW 351
11999: PUSH
12000: LD_VAR 0 11
12004: PPUSH
12005: LD_VAR 0 12
12009: PPUSH
12010: CALL_OW 554
12014: AND
12015: IFFALSE 12055
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12017: LD_ADDR_VAR 0 13
12021: PUSH
12022: LD_VAR 0 13
12026: PPUSH
12027: LD_VAR 0 13
12031: PUSH
12032: LD_INT 1
12034: PLUS
12035: PPUSH
12036: LD_VAR 0 11
12040: PUSH
12041: LD_VAR 0 12
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PPUSH
12050: CALL_OW 2
12054: ST_TO_ADDR
// end ;
12055: GO 11963
12057: POP
12058: POP
12059: GO 11943
12061: POP
12062: POP
// if not list then
12063: LD_VAR 0 13
12067: NOT
12068: IFFALSE 12072
// exit ;
12070: GO 12143
// for i in list do
12072: LD_ADDR_VAR 0 6
12076: PUSH
12077: LD_VAR 0 13
12081: PUSH
12082: FOR_IN
12083: IFFALSE 12141
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12085: LD_VAR 0 1
12089: PPUSH
12090: LD_STRING M
12092: PUSH
12093: LD_VAR 0 6
12097: PUSH
12098: LD_INT 1
12100: ARRAY
12101: PUSH
12102: LD_VAR 0 6
12106: PUSH
12107: LD_INT 2
12109: ARRAY
12110: PUSH
12111: LD_INT 0
12113: PUSH
12114: LD_INT 0
12116: PUSH
12117: LD_INT 0
12119: PUSH
12120: LD_INT 0
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: PUSH
12132: EMPTY
12133: LIST
12134: PPUSH
12135: CALL_OW 447
12139: GO 12082
12141: POP
12142: POP
// end ;
12143: LD_VAR 0 5
12147: RET
