// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 61 , 121 ) ;
   4: LD_INT 61
   6: PPUSH
   7: LD_INT 121
   9: PPUSH
  10: CALL_OW 86
// SetWeather ( 2 , 300 , 30 ) ;
  14: LD_INT 2
  16: PPUSH
  17: LD_INT 300
  19: PPUSH
  20: LD_INT 30
  22: PPUSH
  23: CALL_OW 550
// AnimateTrees ( true ) ;
  27: LD_INT 1
  29: PPUSH
  30: CALL_OW 573
// GameType ;
  34: CALL 282 0 0
// PrepareAmerican ;
  38: CALL 609 0 0
// if game_type = 2 then
  42: LD_EXP 1
  46: PUSH
  47: LD_INT 2
  49: EQUAL
  50: IFFALSE 56
// PrepareRussian ;
  52: CALL 6884 0 0
// GameStarted ;
  56: CALL 426 0 0
// end ;
  60: END
// every 0 0$01 do var sib ;
  61: GO 63
  63: DISABLE
  64: LD_INT 0
  66: PPUSH
// begin enable ;
  67: ENABLE
// sib := GetResourceType ( GetSibAmount ( your_side ) , mat_siberit ) ;
  68: LD_ADDR_VAR 0 1
  72: PUSH
  73: LD_OWVAR 2
  77: PPUSH
  78: CALL 10419 0 1
  82: PPUSH
  83: LD_INT 3
  85: PPUSH
  86: CALL_OW 275
  90: ST_TO_ADDR
// Display_Strings := [ #tick , timer , #sib , sib , need_to_win ] ;
  91: LD_ADDR_OWVAR 47
  95: PUSH
  96: LD_STRING #tick
  98: PUSH
  99: LD_EXP 6
 103: PUSH
 104: LD_STRING #sib
 106: PUSH
 107: LD_VAR 0 1
 111: PUSH
 112: LD_EXP 5
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: LIST
 121: LIST
 122: LIST
 123: ST_TO_ADDR
// timer := timer + 0 0$01 ;
 124: LD_ADDR_EXP 6
 128: PUSH
 129: LD_EXP 6
 133: PUSH
 134: LD_INT 35
 136: PLUS
 137: ST_TO_ADDR
// end ;
 138: PPOPN 1
 140: END
// every 1 do
 141: GO 143
 143: DISABLE
// begin while ( true ) do
 144: LD_INT 1
 146: IFFALSE 281
// begin music_nat := 1 ;
 148: LD_ADDR_OWVAR 71
 152: PUSH
 153: LD_INT 1
 155: ST_TO_ADDR
// music_class := 5 ;
 156: LD_ADDR_OWVAR 72
 160: PUSH
 161: LD_INT 5
 163: ST_TO_ADDR
// Wait ( Rand ( 3 3$30 , 5 5$00 ) ) ;
 164: LD_INT 7350
 166: PPUSH
 167: LD_INT 10500
 169: PPUSH
 170: CALL_OW 12
 174: PPUSH
 175: CALL_OW 67
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 179: LD_ADDR_OWVAR 71
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 3
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: PUSH
 194: LD_INT 1
 196: PPUSH
 197: LD_INT 2
 199: PPUSH
 200: CALL_OW 12
 204: ARRAY
 205: ST_TO_ADDR
// music_class := 0 ;
 206: LD_ADDR_OWVAR 72
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// Wait ( Rand ( 3 3$30 , 5 5$00 ) ) ;
 214: LD_INT 7350
 216: PPUSH
 217: LD_INT 10500
 219: PPUSH
 220: CALL_OW 12
 224: PPUSH
 225: CALL_OW 67
// music_nat := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 229: LD_ADDR_OWVAR 71
 233: PUSH
 234: LD_INT 1
 236: PUSH
 237: LD_INT 3
 239: PUSH
 240: EMPTY
 241: LIST
 242: LIST
 243: PUSH
 244: LD_INT 1
 246: PPUSH
 247: LD_INT 2
 249: PPUSH
 250: CALL_OW 12
 254: ARRAY
 255: ST_TO_ADDR
// music_class := 0 ;
 256: LD_ADDR_OWVAR 72
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// Wait ( Rand ( 3 3$30 , 5 5$00 ) ) ;
 264: LD_INT 7350
 266: PPUSH
 267: LD_INT 10500
 269: PPUSH
 270: CALL_OW 12
 274: PPUSH
 275: CALL_OW 67
// end ;
 279: GO 144
// end ; end_of_file
 281: END
// export game_type , game_diff , game_skill , game_eskill ; export function GameType ; begin
 282: LD_INT 0
 284: PPUSH
// game_diff := GetMultiplayerSetting ( 0 ) ;
 285: LD_ADDR_EXP 2
 289: PUSH
 290: LD_INT 0
 292: PPUSH
 293: CALL_OW 426
 297: ST_TO_ADDR
// game_type := GetMultiplayerSetting ( 1 ) ;
 298: LD_ADDR_EXP 1
 302: PUSH
 303: LD_INT 1
 305: PPUSH
 306: CALL_OW 426
 310: ST_TO_ADDR
// if game_type = 1 then
 311: LD_EXP 1
 315: PUSH
 316: LD_INT 1
 318: EQUAL
 319: IFFALSE 341
// case Query ( GameRulesAm ) of 1 :
 321: LD_STRING GameRulesAm
 323: PPUSH
 324: CALL_OW 97
 328: PUSH
 329: LD_INT 1
 331: DOUBLE
 332: EQUAL
 333: IFTRUE 337
 335: GO 340
 337: POP
// ; end ;
 338: GO 341
 340: POP
// if game_type = 2 then
 341: LD_EXP 1
 345: PUSH
 346: LD_INT 2
 348: EQUAL
 349: IFFALSE 371
// case Query ( GameRulesRu ) of 1 :
 351: LD_STRING GameRulesRu
 353: PPUSH
 354: CALL_OW 97
 358: PUSH
 359: LD_INT 1
 361: DOUBLE
 362: EQUAL
 363: IFTRUE 367
 365: GO 370
 367: POP
// ; end ;
 368: GO 371
 370: POP
// game_skill := [ 6 , 4 , 2 ] [ game_diff ] ;
 371: LD_ADDR_EXP 3
 375: PUSH
 376: LD_INT 6
 378: PUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 2
 384: PUSH
 385: EMPTY
 386: LIST
 387: LIST
 388: LIST
 389: PUSH
 390: LD_EXP 2
 394: ARRAY
 395: ST_TO_ADDR
// game_eskill := [ 4 , 5 , 6 ] [ game_diff ] ;
 396: LD_ADDR_EXP 4
 400: PUSH
 401: LD_INT 4
 403: PUSH
 404: LD_INT 5
 406: PUSH
 407: LD_INT 6
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: PUSH
 415: LD_EXP 2
 419: ARRAY
 420: ST_TO_ADDR
// end ;
 421: LD_VAR 0 1
 425: RET
// export need_to_win , timer , force_timer , depot_captured ; export function GameStarted ; begin
 426: LD_INT 0
 428: PPUSH
// if game_type = 1 then
 429: LD_EXP 1
 433: PUSH
 434: LD_INT 1
 436: EQUAL
 437: IFFALSE 506
// begin need_to_win := [ 350 , 375 , 400 ] [ game_diff ] ;
 439: LD_ADDR_EXP 5
 443: PUSH
 444: LD_INT 350
 446: PUSH
 447: LD_INT 375
 449: PUSH
 450: LD_INT 400
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: PUSH
 458: LD_EXP 2
 462: ARRAY
 463: ST_TO_ADDR
// force_timer := [ 95 , 100 , 105 ] [ game_diff ] ;
 464: LD_ADDR_EXP 7
 468: PUSH
 469: LD_INT 95
 471: PUSH
 472: LD_INT 100
 474: PUSH
 475: LD_INT 105
 477: PUSH
 478: EMPTY
 479: LIST
 480: LIST
 481: LIST
 482: PUSH
 483: LD_EXP 2
 487: ARRAY
 488: ST_TO_ADDR
// CenterNowOnXY ( 84 , 45 ) ;
 489: LD_INT 84
 491: PPUSH
 492: LD_INT 45
 494: PPUSH
 495: CALL_OW 86
// ChangeMissionObjectives ( GType1 ) ;
 499: LD_STRING GType1
 501: PPUSH
 502: CALL_OW 337
// end ; if game_type = 2 then
 506: LD_EXP 1
 510: PUSH
 511: LD_INT 2
 513: EQUAL
 514: IFFALSE 596
// begin need_to_win := [ 300 , 350 , 400 ] [ game_diff ] ;
 516: LD_ADDR_EXP 5
 520: PUSH
 521: LD_INT 300
 523: PUSH
 524: LD_INT 350
 526: PUSH
 527: LD_INT 400
 529: PUSH
 530: EMPTY
 531: LIST
 532: LIST
 533: LIST
 534: PUSH
 535: LD_EXP 2
 539: ARRAY
 540: ST_TO_ADDR
// depot_captured := false ;
 541: LD_ADDR_EXP 8
 545: PUSH
 546: LD_INT 0
 548: ST_TO_ADDR
// CenterNowOnUnits ( ru_dow ) ;
 549: LD_EXP 18
 553: PPUSH
 554: CALL_OW 87
// ChangeMissionObjectives ( GType2 ) ;
 558: LD_STRING GType2
 560: PPUSH
 561: CALL_OW 337
// Wait ( 0 0$03 ) ;
 565: LD_INT 105
 567: PPUSH
 568: CALL_OW 67
// SayRadio ( gorki , D-gorky1 ) ;
 572: LD_EXP 19
 576: PPUSH
 577: LD_STRING D-gorky1
 579: PPUSH
 580: CALL_OW 94
// Say ( ru_dow , D-rudow1 ) ;
 584: LD_EXP 18
 588: PPUSH
 589: LD_STRING D-rudow1
 591: PPUSH
 592: CALL_OW 88
// end ; timer := 0 0$00 ;
 596: LD_ADDR_EXP 6
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ; end_of_file
 604: LD_VAR 0 1
 608: RET
// export am_comander ; export ai_build , ai_vehs , ai_tech ; export function PrepareAmerican ; var i , un , filter , list , p ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
// SetBName ( jota_base , jota ) ;
 617: LD_INT 1
 619: PPUSH
 620: LD_STRING jota
 622: PPUSH
 623: CALL_OW 500
// if game_type = 1 then
 627: LD_EXP 1
 631: PUSH
 632: LD_INT 1
 634: EQUAL
 635: IFFALSE 1155
// begin your_side := 1 ;
 637: LD_ADDR_OWVAR 2
 641: PUSH
 642: LD_INT 1
 644: ST_TO_ADDR
// list := [ west_bun1 , east_bun , am_gun ] ;
 645: LD_ADDR_VAR 0 5
 649: PUSH
 650: LD_INT 29
 652: PUSH
 653: LD_INT 35
 655: PUSH
 656: LD_INT 21
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: ST_TO_ADDR
// if game_diff = 1 then
 664: LD_EXP 2
 668: PUSH
 669: LD_INT 1
 671: EQUAL
 672: IFFALSE 687
// SetTech ( tech_comp1 , 3 , state_researched ) ;
 674: LD_INT 57
 676: PPUSH
 677: LD_INT 3
 679: PPUSH
 680: LD_INT 2
 682: PPUSH
 683: CALL_OW 322
// if game_diff = 2 then
 687: LD_EXP 2
 691: PUSH
 692: LD_INT 2
 694: EQUAL
 695: IFFALSE 710
// SetTech ( tech_comp2 , 3 , state_researched ) ;
 697: LD_INT 58
 699: PPUSH
 700: LD_INT 3
 702: PPUSH
 703: LD_INT 2
 705: PPUSH
 706: CALL_OW 322
// if game_diff = 3 then
 710: LD_EXP 2
 714: PUSH
 715: LD_INT 3
 717: EQUAL
 718: IFFALSE 733
// SetTech ( tech_comp3 , 3 , state_researched ) ;
 720: LD_INT 59
 722: PPUSH
 723: LD_INT 3
 725: PPUSH
 726: LD_INT 2
 728: PPUSH
 729: CALL_OW 322
// for i = 1 to list do
 733: LD_ADDR_VAR 0 2
 737: PUSH
 738: DOUBLE
 739: LD_INT 1
 741: DEC
 742: ST_TO_ADDR
 743: LD_VAR 0 5
 747: PUSH
 748: FOR_TO
 749: IFFALSE 768
// RemoveUnit ( list [ i ] ) ;
 751: LD_VAR 0 5
 755: PUSH
 756: LD_VAR 0 2
 760: ARRAY
 761: PPUSH
 762: CALL_OW 64
 766: GO 748
 768: POP
 769: POP
// ResetFog ;
 770: CALL_OW 335
// uc_side := 1 ;
 774: LD_ADDR_OWVAR 20
 778: PUSH
 779: LD_INT 1
 781: ST_TO_ADDR
// uc_nation := 1 ;
 782: LD_ADDR_OWVAR 21
 786: PUSH
 787: LD_INT 1
 789: ST_TO_ADDR
// for i = 1 to 4 - ( game_diff ) do
 790: LD_ADDR_VAR 0 2
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 4
 802: PUSH
 803: LD_EXP 2
 807: MINUS
 808: PUSH
 809: FOR_TO
 810: IFFALSE 863
// begin uc_side := 1 ;
 812: LD_ADDR_OWVAR 20
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// uc_nation := 1 ;
 820: LD_ADDR_OWVAR 21
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// un := CreateHumanWithClass ( 1 , game_skill ) ;
 828: LD_ADDR_VAR 0 3
 832: PUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_EXP 3
 840: PPUSH
 841: CALL 9174 0 2
 845: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
 846: LD_VAR 0 3
 850: PPUSH
 851: LD_INT 1
 853: PPUSH
 854: LD_INT 0
 856: PPUSH
 857: CALL_OW 49
// end ;
 861: GO 809
 863: POP
 864: POP
// for i = 1 to 5 - ( game_diff ) do
 865: LD_ADDR_VAR 0 2
 869: PUSH
 870: DOUBLE
 871: LD_INT 1
 873: DEC
 874: ST_TO_ADDR
 875: LD_INT 5
 877: PUSH
 878: LD_EXP 2
 882: MINUS
 883: PUSH
 884: FOR_TO
 885: IFFALSE 938
// begin uc_side := 1 ;
 887: LD_ADDR_OWVAR 20
 891: PUSH
 892: LD_INT 1
 894: ST_TO_ADDR
// uc_nation := 1 ;
 895: LD_ADDR_OWVAR 21
 899: PUSH
 900: LD_INT 1
 902: ST_TO_ADDR
// un := CreateHumanWithClass ( 2 , game_skill ) ;
 903: LD_ADDR_VAR 0 3
 907: PUSH
 908: LD_INT 2
 910: PPUSH
 911: LD_EXP 3
 915: PPUSH
 916: CALL 9174 0 2
 920: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
 921: LD_VAR 0 3
 925: PPUSH
 926: LD_INT 1
 928: PPUSH
 929: LD_INT 0
 931: PPUSH
 932: CALL_OW 49
// end ;
 936: GO 884
 938: POP
 939: POP
// for i = 1 to 5 - ( game_diff ) do
 940: LD_ADDR_VAR 0 2
 944: PUSH
 945: DOUBLE
 946: LD_INT 1
 948: DEC
 949: ST_TO_ADDR
 950: LD_INT 5
 952: PUSH
 953: LD_EXP 2
 957: MINUS
 958: PUSH
 959: FOR_TO
 960: IFFALSE 1013
// begin uc_side := 1 ;
 962: LD_ADDR_OWVAR 20
 966: PUSH
 967: LD_INT 1
 969: ST_TO_ADDR
// uc_nation := 1 ;
 970: LD_ADDR_OWVAR 21
 974: PUSH
 975: LD_INT 1
 977: ST_TO_ADDR
// un := CreateHumanWithClass ( 3 , game_skill ) ;
 978: LD_ADDR_VAR 0 3
 982: PUSH
 983: LD_INT 3
 985: PPUSH
 986: LD_EXP 3
 990: PPUSH
 991: CALL 9174 0 2
 995: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
 996: LD_VAR 0 3
1000: PPUSH
1001: LD_INT 1
1003: PPUSH
1004: LD_INT 0
1006: PPUSH
1007: CALL_OW 49
// end ;
1011: GO 959
1013: POP
1014: POP
// for i = 1 to 5 - ( game_diff ) do
1015: LD_ADDR_VAR 0 2
1019: PUSH
1020: DOUBLE
1021: LD_INT 1
1023: DEC
1024: ST_TO_ADDR
1025: LD_INT 5
1027: PUSH
1028: LD_EXP 2
1032: MINUS
1033: PUSH
1034: FOR_TO
1035: IFFALSE 1088
// begin uc_side := 1 ;
1037: LD_ADDR_OWVAR 20
1041: PUSH
1042: LD_INT 1
1044: ST_TO_ADDR
// uc_nation := 1 ;
1045: LD_ADDR_OWVAR 21
1049: PUSH
1050: LD_INT 1
1052: ST_TO_ADDR
// un := CreateHumanWithClass ( 4 , game_skill ) ;
1053: LD_ADDR_VAR 0 3
1057: PUSH
1058: LD_INT 4
1060: PPUSH
1061: LD_EXP 3
1065: PPUSH
1066: CALL 9174 0 2
1070: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1071: LD_VAR 0 3
1075: PPUSH
1076: LD_INT 1
1078: PPUSH
1079: LD_INT 0
1081: PPUSH
1082: CALL_OW 49
// end ;
1086: GO 1034
1088: POP
1089: POP
// hc_importance := 100 ;
1090: LD_ADDR_OWVAR 32
1094: PUSH
1095: LD_INT 100
1097: ST_TO_ADDR
// uc_side := 1 ;
1098: LD_ADDR_OWVAR 20
1102: PUSH
1103: LD_INT 1
1105: ST_TO_ADDR
// uc_nation := 1 ;
1106: LD_ADDR_OWVAR 21
1110: PUSH
1111: LD_INT 1
1113: ST_TO_ADDR
// am_comander := CreateHumanWithClass ( 1 , game_skill ) ;
1114: LD_ADDR_EXP 9
1118: PUSH
1119: LD_INT 1
1121: PPUSH
1122: LD_EXP 3
1126: PPUSH
1127: CALL 9174 0 2
1131: ST_TO_ADDR
// PlaceUnitArea ( am_comander , am_base , false ) ;
1132: LD_EXP 9
1136: PPUSH
1137: LD_INT 1
1139: PPUSH
1140: LD_INT 0
1142: PPUSH
1143: CALL_OW 49
// hc_importance := 0 ;
1147: LD_ADDR_OWVAR 32
1151: PUSH
1152: LD_INT 0
1154: ST_TO_ADDR
// end ; if game_type = 2 then
1155: LD_EXP 1
1159: PUSH
1160: LD_INT 2
1162: EQUAL
1163: IFFALSE 2328
// begin uc_side := 1 ;
1165: LD_ADDR_OWVAR 20
1169: PUSH
1170: LD_INT 1
1172: ST_TO_ADDR
// uc_nation := 1 ;
1173: LD_ADDR_OWVAR 21
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// SetResourceType ( GetBase ( jota_base ) , mat_cans , 1000 ) ;
1181: LD_INT 1
1183: PPUSH
1184: CALL_OW 274
1188: PPUSH
1189: LD_INT 1
1191: PPUSH
1192: LD_INT 1000
1194: PPUSH
1195: CALL_OW 277
// SetTech ( tech_sibdet , 1 , state_researched ) ;
1199: LD_INT 20
1201: PPUSH
1202: LD_INT 1
1204: PPUSH
1205: LD_INT 2
1207: PPUSH
1208: CALL_OW 322
// for i = 1 to 4 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 4
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1285
// begin for p = 1 to 5 do
1228: LD_ADDR_VAR 0 6
1232: PUSH
1233: DOUBLE
1234: LD_INT 1
1236: DEC
1237: ST_TO_ADDR
1238: LD_INT 5
1240: PUSH
1241: FOR_TO
1242: IFFALSE 1281
// begin un := CreateHumanWithClass ( i , game_eskill ) ;
1244: LD_ADDR_VAR 0 3
1248: PUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: LD_EXP 4
1258: PPUSH
1259: CALL 9174 0 2
1263: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1264: LD_VAR 0 3
1268: PPUSH
1269: LD_INT 1
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 49
// end ;
1279: GO 1241
1281: POP
1282: POP
// end ;
1283: GO 1225
1285: POP
1286: POP
// un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1287: LD_ADDR_VAR 0 3
1291: PUSH
1292: LD_INT 5
1294: PPUSH
1295: LD_EXP 4
1299: PPUSH
1300: CALL 9174 0 2
1304: ST_TO_ADDR
// PlaceUnitArea ( un , am_sniper_1 , false ) ;
1305: LD_VAR 0 3
1309: PPUSH
1310: LD_INT 2
1312: PPUSH
1313: LD_INT 0
1315: PPUSH
1316: CALL_OW 49
// ComEnterUnit ( un , west_bun1 ) ;
1320: LD_VAR 0 3
1324: PPUSH
1325: LD_INT 29
1327: PPUSH
1328: CALL_OW 120
// un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1332: LD_ADDR_VAR 0 3
1336: PUSH
1337: LD_INT 5
1339: PPUSH
1340: LD_EXP 4
1344: PPUSH
1345: CALL 9174 0 2
1349: ST_TO_ADDR
// PlaceUnitArea ( un , am_sniper_3 , false ) ;
1350: LD_VAR 0 3
1354: PPUSH
1355: LD_INT 4
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// ComEnterUnit ( un , base_bun ) ;
1365: LD_VAR 0 3
1369: PPUSH
1370: LD_INT 20
1372: PPUSH
1373: CALL_OW 120
// if game_diff > 1 then
1377: LD_EXP 2
1381: PUSH
1382: LD_INT 1
1384: GREATER
1385: IFFALSE 1529
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1387: LD_ADDR_VAR 0 3
1391: PUSH
1392: LD_INT 5
1394: PPUSH
1395: LD_EXP 4
1399: PPUSH
1400: CALL 9174 0 2
1404: ST_TO_ADDR
// PlaceUnitArea ( un , am_sniper_2 , false ) ;
1405: LD_VAR 0 3
1409: PPUSH
1410: LD_INT 3
1412: PPUSH
1413: LD_INT 0
1415: PPUSH
1416: CALL_OW 49
// for i = 1 to 2 do
1420: LD_ADDR_VAR 0 2
1424: PUSH
1425: DOUBLE
1426: LD_INT 1
1428: DEC
1429: ST_TO_ADDR
1430: LD_INT 2
1432: PUSH
1433: FOR_TO
1434: IFFALSE 1527
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1436: LD_ADDR_VAR 0 3
1440: PUSH
1441: LD_INT 5
1443: PPUSH
1444: LD_EXP 4
1448: PPUSH
1449: CALL 9174 0 2
1453: ST_TO_ADDR
// PlaceUnitArea ( un , am_base , false ) ;
1454: LD_VAR 0 3
1458: PPUSH
1459: LD_INT 1
1461: PPUSH
1462: LD_INT 0
1464: PPUSH
1465: CALL_OW 49
// ComEnterUnit ( un , FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_armoury ] , [ f_lives , 251 ] ] ] ) [ 1 ] ) ;
1469: LD_VAR 0 3
1473: PPUSH
1474: LD_INT 22
1476: PUSH
1477: LD_INT 1
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: PUSH
1484: LD_INT 30
1486: PUSH
1487: LD_INT 4
1489: PUSH
1490: EMPTY
1491: LIST
1492: LIST
1493: PUSH
1494: LD_INT 24
1496: PUSH
1497: LD_INT 251
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: PUSH
1504: EMPTY
1505: LIST
1506: LIST
1507: LIST
1508: PUSH
1509: EMPTY
1510: LIST
1511: PPUSH
1512: CALL_OW 69
1516: PUSH
1517: LD_INT 1
1519: ARRAY
1520: PPUSH
1521: CALL_OW 120
// end ;
1525: GO 1433
1527: POP
1528: POP
// end ; if game_diff > 1 then
1529: LD_EXP 2
1533: PUSH
1534: LD_INT 1
1536: GREATER
1537: IFFALSE 1575
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1539: LD_ADDR_VAR 0 3
1543: PUSH
1544: LD_INT 5
1546: PPUSH
1547: LD_EXP 4
1551: PPUSH
1552: CALL 9174 0 2
1556: ST_TO_ADDR
// PlaceUnitXY ( un , 37 , 44 , false ) ;
1557: LD_VAR 0 3
1561: PPUSH
1562: LD_INT 37
1564: PPUSH
1565: LD_INT 44
1567: PPUSH
1568: LD_INT 0
1570: PPUSH
1571: CALL_OW 48
// end ; if game_diff > 2 then
1575: LD_EXP 2
1579: PUSH
1580: LD_INT 2
1582: GREATER
1583: IFFALSE 1633
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
1585: LD_ADDR_VAR 0 3
1589: PUSH
1590: LD_INT 5
1592: PPUSH
1593: LD_EXP 4
1597: PPUSH
1598: CALL 9174 0 2
1602: ST_TO_ADDR
// PlaceUnitXY ( un , 106 , 45 , false ) ;
1603: LD_VAR 0 3
1607: PPUSH
1608: LD_INT 106
1610: PPUSH
1611: LD_INT 45
1613: PPUSH
1614: LD_INT 0
1616: PPUSH
1617: CALL_OW 48
// ComEnterUnit ( un , east_bun ) ;
1621: LD_VAR 0 3
1625: PPUSH
1626: LD_INT 35
1628: PPUSH
1629: CALL_OW 120
// end ; if game_diff < 3 then
1633: LD_EXP 2
1637: PUSH
1638: LD_INT 3
1640: LESS
1641: IFFALSE 1650
// RemoveUnit ( east_bun ) ;
1643: LD_INT 35
1645: PPUSH
1646: CALL_OW 64
// if game_diff > 1 then
1650: LD_EXP 2
1654: PUSH
1655: LD_INT 1
1657: GREATER
1658: IFFALSE 1673
// SetTech ( tech_rocket , 1 , state_researched ) ;
1660: LD_INT 40
1662: PPUSH
1663: LD_INT 1
1665: PPUSH
1666: LD_INT 2
1668: PPUSH
1669: CALL_OW 322
// case game_diff of 1 :
1673: LD_EXP 2
1677: PUSH
1678: LD_INT 1
1680: DOUBLE
1681: EQUAL
1682: IFTRUE 1686
1684: GO 1760
1686: POP
// begin ai_build := [ b_oil_power , 78 , 52 , 3 , b_oil_power , 96 , 58 , 0 , b_bunker , 72 , 34 , 3 , b_bunker , 83 , 54 , 0 ] ;
1687: LD_ADDR_EXP 10
1691: PUSH
1692: LD_INT 26
1694: PUSH
1695: LD_INT 78
1697: PUSH
1698: LD_INT 52
1700: PUSH
1701: LD_INT 3
1703: PUSH
1704: LD_INT 26
1706: PUSH
1707: LD_INT 96
1709: PUSH
1710: LD_INT 58
1712: PUSH
1713: LD_INT 0
1715: PUSH
1716: LD_INT 32
1718: PUSH
1719: LD_INT 72
1721: PUSH
1722: LD_INT 34
1724: PUSH
1725: LD_INT 3
1727: PUSH
1728: LD_INT 32
1730: PUSH
1731: LD_INT 83
1733: PUSH
1734: LD_INT 54
1736: PUSH
1737: LD_INT 0
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: ST_TO_ADDR
// end ; 2 :
1758: GO 2037
1760: LD_INT 2
1762: DOUBLE
1763: EQUAL
1764: IFTRUE 1768
1766: GO 1890
1768: POP
// begin ai_build := [ b_ext_rocket , 73 , 42 , 2 , b_oil_power , 78 , 52 , 3 , b_oil_power , 96 , 58 , 0 , b_bunker , 72 , 34 , 3 , b_bunker , 83 , 54 , 0 , b_bunker , 82 , 38 , 2 , b_oil_power , 69 , 39 , 3 ] ;
1769: LD_ADDR_EXP 10
1773: PUSH
1774: LD_INT 18
1776: PUSH
1777: LD_INT 73
1779: PUSH
1780: LD_INT 42
1782: PUSH
1783: LD_INT 2
1785: PUSH
1786: LD_INT 26
1788: PUSH
1789: LD_INT 78
1791: PUSH
1792: LD_INT 52
1794: PUSH
1795: LD_INT 3
1797: PUSH
1798: LD_INT 26
1800: PUSH
1801: LD_INT 96
1803: PUSH
1804: LD_INT 58
1806: PUSH
1807: LD_INT 0
1809: PUSH
1810: LD_INT 32
1812: PUSH
1813: LD_INT 72
1815: PUSH
1816: LD_INT 34
1818: PUSH
1819: LD_INT 3
1821: PUSH
1822: LD_INT 32
1824: PUSH
1825: LD_INT 83
1827: PUSH
1828: LD_INT 54
1830: PUSH
1831: LD_INT 0
1833: PUSH
1834: LD_INT 32
1836: PUSH
1837: LD_INT 82
1839: PUSH
1840: LD_INT 38
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 26
1848: PUSH
1849: LD_INT 69
1851: PUSH
1852: LD_INT 39
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: ST_TO_ADDR
// end ; 3 :
1888: GO 2037
1890: LD_INT 3
1892: DOUBLE
1893: EQUAL
1894: IFTRUE 1898
1896: GO 2036
1898: POP
// begin ai_build := [ b_ext_rocket , 73 , 42 , 2 , b_oil_power , 78 , 52 , 3 , b_oil_power , 96 , 58 , 0 , b_bunker , 72 , 34 , 3 , b_bunker , 83 , 54 , 0 , b_bunker , 82 , 38 , 2 , b_bunker , 103 , 59 , 3 , b_oil_power , 69 , 39 , 3 ] ;
1899: LD_ADDR_EXP 10
1903: PUSH
1904: LD_INT 18
1906: PUSH
1907: LD_INT 73
1909: PUSH
1910: LD_INT 42
1912: PUSH
1913: LD_INT 2
1915: PUSH
1916: LD_INT 26
1918: PUSH
1919: LD_INT 78
1921: PUSH
1922: LD_INT 52
1924: PUSH
1925: LD_INT 3
1927: PUSH
1928: LD_INT 26
1930: PUSH
1931: LD_INT 96
1933: PUSH
1934: LD_INT 58
1936: PUSH
1937: LD_INT 0
1939: PUSH
1940: LD_INT 32
1942: PUSH
1943: LD_INT 72
1945: PUSH
1946: LD_INT 34
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 32
1954: PUSH
1955: LD_INT 83
1957: PUSH
1958: LD_INT 54
1960: PUSH
1961: LD_INT 0
1963: PUSH
1964: LD_INT 32
1966: PUSH
1967: LD_INT 82
1969: PUSH
1970: LD_INT 38
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 32
1978: PUSH
1979: LD_INT 103
1981: PUSH
1982: LD_INT 59
1984: PUSH
1985: LD_INT 3
1987: PUSH
1988: LD_INT 26
1990: PUSH
1991: LD_INT 69
1993: PUSH
1994: LD_INT 39
1996: PUSH
1997: LD_INT 3
1999: PUSH
2000: EMPTY
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: LIST
2021: LIST
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: LIST
2028: LIST
2029: LIST
2030: LIST
2031: LIST
2032: LIST
2033: ST_TO_ADDR
// end ; end ;
2034: GO 2037
2036: POP
// ai_tech := [ tech_tech1 , tech_oileng , tech_tech2 , tech_weap1 , tech_gatling , tech_weap2 , tech_gun , tech_tech3 ] ;
2037: LD_ADDR_EXP 12
2041: PUSH
2042: LD_INT 48
2044: PUSH
2045: LD_INT 47
2047: PUSH
2048: LD_INT 49
2050: PUSH
2051: LD_INT 51
2053: PUSH
2054: LD_INT 69
2056: PUSH
2057: LD_INT 52
2059: PUSH
2060: LD_INT 39
2062: PUSH
2063: LD_INT 50
2065: PUSH
2066: EMPTY
2067: LIST
2068: LIST
2069: LIST
2070: LIST
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// case game_diff of 1 :
2076: LD_EXP 2
2080: PUSH
2081: LD_INT 1
2083: DOUBLE
2084: EQUAL
2085: IFTRUE 2089
2087: GO 2163
2089: POP
// begin ai_vehs := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , us_heavy_tracked , engine_combustion , control_manual , us_gatling_gun , us_heavy_tracked , engine_combustion , control_manual , us_double_gun , us_heavy_tracked , engine_combustion , control_manual , us_gatling_gun ] ;
2090: LD_ADDR_EXP 11
2094: PUSH
2095: LD_INT 3
2097: PUSH
2098: LD_INT 1
2100: PUSH
2101: LD_INT 1
2103: PUSH
2104: LD_INT 12
2106: PUSH
2107: LD_INT 4
2109: PUSH
2110: LD_INT 1
2112: PUSH
2113: LD_INT 1
2115: PUSH
2116: LD_INT 4
2118: PUSH
2119: LD_INT 4
2121: PUSH
2122: LD_INT 1
2124: PUSH
2125: LD_INT 1
2127: PUSH
2128: LD_INT 5
2130: PUSH
2131: LD_INT 4
2133: PUSH
2134: LD_INT 1
2136: PUSH
2137: LD_INT 1
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: ST_TO_ADDR
// end ; 2 :
2161: GO 2328
2163: LD_INT 2
2165: DOUBLE
2166: EQUAL
2167: IFTRUE 2171
2169: GO 2245
2171: POP
// begin ai_vehs := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_manual , us_double_gun , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] ;
2172: LD_ADDR_EXP 11
2176: PUSH
2177: LD_INT 3
2179: PUSH
2180: LD_INT 1
2182: PUSH
2183: LD_INT 1
2185: PUSH
2186: LD_INT 12
2188: PUSH
2189: LD_INT 4
2191: PUSH
2192: LD_INT 1
2194: PUSH
2195: LD_INT 1
2197: PUSH
2198: LD_INT 7
2200: PUSH
2201: LD_INT 4
2203: PUSH
2204: LD_INT 1
2206: PUSH
2207: LD_INT 1
2209: PUSH
2210: LD_INT 5
2212: PUSH
2213: LD_INT 4
2215: PUSH
2216: LD_INT 1
2218: PUSH
2219: LD_INT 1
2221: PUSH
2222: LD_INT 7
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: LIST
2232: LIST
2233: LIST
2234: LIST
2235: LIST
2236: LIST
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: ST_TO_ADDR
// end ; 3 :
2243: GO 2328
2245: LD_INT 3
2247: DOUBLE
2248: EQUAL
2249: IFTRUE 2253
2251: GO 2327
2253: POP
// begin ai_vehs := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] ;
2254: LD_ADDR_EXP 11
2258: PUSH
2259: LD_INT 3
2261: PUSH
2262: LD_INT 1
2264: PUSH
2265: LD_INT 1
2267: PUSH
2268: LD_INT 12
2270: PUSH
2271: LD_INT 4
2273: PUSH
2274: LD_INT 1
2276: PUSH
2277: LD_INT 1
2279: PUSH
2280: LD_INT 7
2282: PUSH
2283: LD_INT 4
2285: PUSH
2286: LD_INT 1
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: LD_INT 7
2294: PUSH
2295: LD_INT 4
2297: PUSH
2298: LD_INT 1
2300: PUSH
2301: LD_INT 1
2303: PUSH
2304: LD_INT 7
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: LIST
2311: LIST
2312: LIST
2313: LIST
2314: LIST
2315: LIST
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: LIST
2321: LIST
2322: LIST
2323: LIST
2324: ST_TO_ADDR
// end ; end ;
2325: GO 2328
2327: POP
// end ; end ;
2328: LD_VAR 0 1
2332: RET
// export sold_ocp ; export tower_list ; every 0 0$01 do
2333: GO 2335
2335: DISABLE
// begin sold_ocp := [ ] ;
2336: LD_ADDR_EXP 13
2340: PUSH
2341: EMPTY
2342: ST_TO_ADDR
// tower_list := [ ] ;
2343: LD_ADDR_EXP 14
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// end ;
2350: END
// every 0 0$01 trigger game_type = 2 and depot_captured = false do var i , un , sold , filter , sold_em , engs , mechs , sci , empty_towers , towers , damage_pep , damage_build , damage_vehs ;
2351: LD_EXP 1
2355: PUSH
2356: LD_INT 2
2358: EQUAL
2359: PUSH
2360: LD_EXP 8
2364: PUSH
2365: LD_INT 0
2367: EQUAL
2368: AND
2369: IFFALSE 4046
2371: GO 2373
2373: DISABLE
2374: LD_INT 0
2376: PPUSH
2377: PPUSH
2378: PPUSH
2379: PPUSH
2380: PPUSH
2381: PPUSH
2382: PPUSH
2383: PPUSH
2384: PPUSH
2385: PPUSH
2386: PPUSH
2387: PPUSH
2388: PPUSH
// begin enable ;
2389: ENABLE
// sold := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 1 ] , [ f_lives , 650 ] ] ] ) ;
2390: LD_ADDR_VAR 0 3
2394: PUSH
2395: LD_INT 22
2397: PUSH
2398: LD_INT 1
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: LD_INT 25
2407: PUSH
2408: LD_INT 1
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: PUSH
2415: LD_INT 24
2417: PUSH
2418: LD_INT 650
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: LIST
2429: PUSH
2430: EMPTY
2431: LIST
2432: PPUSH
2433: CALL_OW 69
2437: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ] ) ;
2438: LD_ADDR_VAR 0 6
2442: PUSH
2443: LD_INT 22
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 25
2455: PUSH
2456: LD_INT 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: LD_INT 24
2465: PUSH
2466: LD_INT 650
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: LIST
2477: PUSH
2478: EMPTY
2479: LIST
2480: PPUSH
2481: CALL_OW 69
2485: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_lives , 650 ] ] ] ) ;
2486: LD_ADDR_VAR 0 7
2490: PUSH
2491: LD_INT 22
2493: PUSH
2494: LD_INT 1
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: PUSH
2501: LD_INT 25
2503: PUSH
2504: LD_INT 3
2506: PUSH
2507: EMPTY
2508: LIST
2509: LIST
2510: PUSH
2511: LD_INT 24
2513: PUSH
2514: LD_INT 650
2516: PUSH
2517: EMPTY
2518: LIST
2519: LIST
2520: PUSH
2521: EMPTY
2522: LIST
2523: LIST
2524: LIST
2525: PUSH
2526: EMPTY
2527: LIST
2528: PPUSH
2529: CALL_OW 69
2533: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_lives , 650 ] ] ] ) ;
2534: LD_ADDR_VAR 0 8
2538: PUSH
2539: LD_INT 22
2541: PUSH
2542: LD_INT 1
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: PUSH
2549: LD_INT 25
2551: PUSH
2552: LD_INT 4
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: PUSH
2559: LD_INT 24
2561: PUSH
2562: LD_INT 650
2564: PUSH
2565: EMPTY
2566: LIST
2567: LIST
2568: PUSH
2569: EMPTY
2570: LIST
2571: LIST
2572: LIST
2573: PUSH
2574: EMPTY
2575: LIST
2576: PPUSH
2577: CALL_OW 69
2581: ST_TO_ADDR
// empty_towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_empty ] , [ f_lives , 251 ] ] ) ;
2582: LD_ADDR_VAR 0 9
2586: PUSH
2587: LD_INT 22
2589: PUSH
2590: LD_INT 1
2592: PUSH
2593: EMPTY
2594: LIST
2595: LIST
2596: PUSH
2597: LD_INT 30
2599: PUSH
2600: LD_INT 32
2602: PUSH
2603: EMPTY
2604: LIST
2605: LIST
2606: PUSH
2607: LD_INT 58
2609: PUSH
2610: EMPTY
2611: LIST
2612: PUSH
2613: LD_INT 24
2615: PUSH
2616: LD_INT 251
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PPUSH
2629: CALL_OW 69
2633: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_bunker ] , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_gatling_gun ] ] , [ f_lives , 251 ] ] ] ) ;
2634: LD_ADDR_VAR 0 10
2638: PUSH
2639: LD_INT 22
2641: PUSH
2642: LD_INT 1
2644: PUSH
2645: EMPTY
2646: LIST
2647: LIST
2648: PUSH
2649: LD_INT 30
2651: PUSH
2652: LD_INT 32
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: LD_INT 2
2661: PUSH
2662: LD_INT 35
2664: PUSH
2665: LD_INT 7
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PUSH
2672: LD_INT 35
2674: PUSH
2675: LD_INT 4
2677: PUSH
2678: EMPTY
2679: LIST
2680: LIST
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: LIST
2686: PUSH
2687: LD_INT 24
2689: PUSH
2690: LD_INT 251
2692: PUSH
2693: EMPTY
2694: LIST
2695: LIST
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: PUSH
2703: EMPTY
2704: LIST
2705: PPUSH
2706: CALL_OW 69
2710: ST_TO_ADDR
// damage_pep := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 650 ] ] ] ] ) ;
2711: LD_ADDR_VAR 0 11
2715: PUSH
2716: LD_INT 22
2718: PUSH
2719: LD_INT 1
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PUSH
2726: LD_INT 21
2728: PUSH
2729: LD_INT 1
2731: PUSH
2732: EMPTY
2733: LIST
2734: LIST
2735: PUSH
2736: LD_INT 3
2738: PUSH
2739: LD_INT 24
2741: PUSH
2742: LD_INT 650
2744: PUSH
2745: EMPTY
2746: LIST
2747: LIST
2748: PUSH
2749: EMPTY
2750: LIST
2751: LIST
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: LIST
2757: PUSH
2758: EMPTY
2759: LIST
2760: PPUSH
2761: CALL_OW 69
2765: ST_TO_ADDR
// damage_build := FilterUnitsInArea ( def_area , [ [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
2766: LD_ADDR_VAR 0 12
2770: PUSH
2771: LD_INT 11
2773: PPUSH
2774: LD_INT 22
2776: PUSH
2777: LD_INT 1
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PUSH
2784: LD_INT 21
2786: PUSH
2787: LD_INT 3
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 24
2799: PUSH
2800: LD_INT 1000
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: PUSH
2811: EMPTY
2812: LIST
2813: LIST
2814: LIST
2815: PUSH
2816: EMPTY
2817: LIST
2818: PPUSH
2819: CALL_OW 70
2823: ST_TO_ADDR
// damage_vehs := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 650 ] ] ] ] ) ;
2824: LD_ADDR_VAR 0 13
2828: PUSH
2829: LD_INT 22
2831: PUSH
2832: LD_INT 1
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PUSH
2839: LD_INT 21
2841: PUSH
2842: LD_INT 2
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: PUSH
2849: LD_INT 3
2851: PUSH
2852: LD_INT 24
2854: PUSH
2855: LD_INT 650
2857: PUSH
2858: EMPTY
2859: LIST
2860: LIST
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: LIST
2870: PUSH
2871: EMPTY
2872: LIST
2873: PPUSH
2874: CALL_OW 69
2878: ST_TO_ADDR
// if GetResourceType ( GetBase ( jota_base ) , mat_oil ) <= 30 then
2879: LD_INT 1
2881: PPUSH
2882: CALL_OW 274
2886: PPUSH
2887: LD_INT 2
2889: PPUSH
2890: CALL_OW 275
2894: PUSH
2895: LD_INT 30
2897: LESSEQUAL
2898: IFFALSE 2918
// SetResourceType ( GetBase ( jota_base ) , mat_oil , 100 ) ;
2900: LD_INT 1
2902: PPUSH
2903: CALL_OW 274
2907: PPUSH
2908: LD_INT 2
2910: PPUSH
2911: LD_INT 100
2913: PPUSH
2914: CALL_OW 277
// sold_em := ( sold diff sold_ocp ) ;
2918: LD_ADDR_VAR 0 5
2922: PUSH
2923: LD_VAR 0 3
2927: PUSH
2928: LD_EXP 13
2932: DIFF
2933: ST_TO_ADDR
// if sold > 0 then
2934: LD_VAR 0 3
2938: PUSH
2939: LD_INT 0
2941: GREATER
2942: IFFALSE 3064
// for i = 1 to sold_em do
2944: LD_ADDR_VAR 0 1
2948: PUSH
2949: DOUBLE
2950: LD_INT 1
2952: DEC
2953: ST_TO_ADDR
2954: LD_VAR 0 5
2958: PUSH
2959: FOR_TO
2960: IFFALSE 3062
// if empty_towers > 0 then
2962: LD_VAR 0 9
2966: PUSH
2967: LD_INT 0
2969: GREATER
2970: IFFALSE 2998
// ComEnterUnit ( sold_em [ i ] , empty_towers [ 1 ] ) else
2972: LD_VAR 0 5
2976: PUSH
2977: LD_VAR 0 1
2981: ARRAY
2982: PPUSH
2983: LD_VAR 0 9
2987: PUSH
2988: LD_INT 1
2990: ARRAY
2991: PPUSH
2992: CALL_OW 120
2996: GO 3060
// ComEnterUnit ( sold_em [ i ] , FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_btype , b_armoury ] , [ f_lives , 251 ] ] ] ) [ 1 ] ) ;
2998: LD_VAR 0 5
3002: PUSH
3003: LD_VAR 0 1
3007: ARRAY
3008: PPUSH
3009: LD_INT 22
3011: PUSH
3012: LD_INT 1
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 30
3021: PUSH
3022: LD_INT 4
3024: PUSH
3025: EMPTY
3026: LIST
3027: LIST
3028: PUSH
3029: LD_INT 24
3031: PUSH
3032: LD_INT 251
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: PUSH
3039: EMPTY
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: PPUSH
3047: CALL_OW 69
3051: PUSH
3052: LD_INT 1
3054: ARRAY
3055: PPUSH
3056: CALL_OW 120
3060: GO 2959
3062: POP
3063: POP
// if mechs > 0 then
3064: LD_VAR 0 7
3068: PUSH
3069: LD_INT 0
3071: GREATER
3072: IFFALSE 3150
// for i = 1 to mechs do
3074: LD_ADDR_VAR 0 1
3078: PUSH
3079: DOUBLE
3080: LD_INT 1
3082: DEC
3083: ST_TO_ADDR
3084: LD_VAR 0 7
3088: PUSH
3089: FOR_TO
3090: IFFALSE 3148
// if not IsInUnit ( mechs [ i ] ) and not HasTask ( mechs [ i ] ) then
3092: LD_VAR 0 7
3096: PUSH
3097: LD_VAR 0 1
3101: ARRAY
3102: PPUSH
3103: CALL_OW 310
3107: NOT
3108: PUSH
3109: LD_VAR 0 7
3113: PUSH
3114: LD_VAR 0 1
3118: ARRAY
3119: PPUSH
3120: CALL_OW 314
3124: NOT
3125: AND
3126: IFFALSE 3146
// ComEnterUnit ( mechs [ i ] , am_fac ) ;
3128: LD_VAR 0 7
3132: PUSH
3133: LD_VAR 0 1
3137: ARRAY
3138: PPUSH
3139: LD_INT 14
3141: PPUSH
3142: CALL_OW 120
3146: GO 3089
3148: POP
3149: POP
// if sci > 0 then
3150: LD_VAR 0 8
3154: PUSH
3155: LD_INT 0
3157: GREATER
3158: IFFALSE 3228
// for i = 1 to sci do
3160: LD_ADDR_VAR 0 1
3164: PUSH
3165: DOUBLE
3166: LD_INT 1
3168: DEC
3169: ST_TO_ADDR
3170: LD_VAR 0 8
3174: PUSH
3175: FOR_TO
3176: IFFALSE 3226
// if damage_pep = 0 and not HasTask ( sci [ i ] ) then
3178: LD_VAR 0 11
3182: PUSH
3183: LD_INT 0
3185: EQUAL
3186: PUSH
3187: LD_VAR 0 8
3191: PUSH
3192: LD_VAR 0 1
3196: ARRAY
3197: PPUSH
3198: CALL_OW 314
3202: NOT
3203: AND
3204: IFFALSE 3224
// ComEnterUnit ( sci [ i ] , am_lab ) ;
3206: LD_VAR 0 8
3210: PUSH
3211: LD_VAR 0 1
3215: ARRAY
3216: PPUSH
3217: LD_INT 9
3219: PPUSH
3220: CALL_OW 120
3224: GO 3175
3226: POP
3227: POP
// if damage_build > 0 then
3228: LD_VAR 0 12
3232: PUSH
3233: LD_INT 0
3235: GREATER
3236: IFFALSE 3284
// for i = 1 to engs do
3238: LD_ADDR_VAR 0 1
3242: PUSH
3243: DOUBLE
3244: LD_INT 1
3246: DEC
3247: ST_TO_ADDR
3248: LD_VAR 0 6
3252: PUSH
3253: FOR_TO
3254: IFFALSE 3282
// ComRepairBuilding ( engs [ i ] , damage_build [ 1 ] ) ;
3256: LD_VAR 0 6
3260: PUSH
3261: LD_VAR 0 1
3265: ARRAY
3266: PPUSH
3267: LD_VAR 0 12
3271: PUSH
3272: LD_INT 1
3274: ARRAY
3275: PPUSH
3276: CALL_OW 130
3280: GO 3253
3282: POP
3283: POP
// if ai_build > 0 then
3284: LD_EXP 10
3288: PUSH
3289: LD_INT 0
3291: GREATER
3292: IFFALSE 3385
// for i = 1 to engs do
3294: LD_ADDR_VAR 0 1
3298: PUSH
3299: DOUBLE
3300: LD_INT 1
3302: DEC
3303: ST_TO_ADDR
3304: LD_VAR 0 6
3308: PUSH
3309: FOR_TO
3310: IFFALSE 3383
// if not HasTask ( engs [ i ] ) then
3312: LD_VAR 0 6
3316: PUSH
3317: LD_VAR 0 1
3321: ARRAY
3322: PPUSH
3323: CALL_OW 314
3327: NOT
3328: IFFALSE 3381
// ComBuild ( engs [ i ] , ai_build [ 1 ] , ai_build [ 2 ] , ai_build [ 3 ] , ai_build [ 4 ] ) ;
3330: LD_VAR 0 6
3334: PUSH
3335: LD_VAR 0 1
3339: ARRAY
3340: PPUSH
3341: LD_EXP 10
3345: PUSH
3346: LD_INT 1
3348: ARRAY
3349: PPUSH
3350: LD_EXP 10
3354: PUSH
3355: LD_INT 2
3357: ARRAY
3358: PPUSH
3359: LD_EXP 10
3363: PUSH
3364: LD_INT 3
3366: ARRAY
3367: PPUSH
3368: LD_EXP 10
3372: PUSH
3373: LD_INT 4
3375: ARRAY
3376: PPUSH
3377: CALL_OW 145
3381: GO 3309
3383: POP
3384: POP
// if damage_pep > 0 and sci > 0 then
3385: LD_VAR 0 11
3389: PUSH
3390: LD_INT 0
3392: GREATER
3393: PUSH
3394: LD_VAR 0 8
3398: PUSH
3399: LD_INT 0
3401: GREATER
3402: AND
3403: IFFALSE 3589
// begin for i = 1 to sci do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_INT 1
3413: DEC
3414: ST_TO_ADDR
3415: LD_VAR 0 8
3419: PUSH
3420: FOR_TO
3421: IFFALSE 3440
// ComExitBuilding ( sci [ i ] ) ;
3423: LD_VAR 0 8
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: CALL_OW 122
3438: GO 3420
3440: POP
3441: POP
// for i = 1 to damage_pep do
3442: LD_ADDR_VAR 0 1
3446: PUSH
3447: DOUBLE
3448: LD_INT 1
3450: DEC
3451: ST_TO_ADDR
3452: LD_VAR 0 11
3456: PUSH
3457: FOR_TO
3458: IFFALSE 3537
// begin if not IsInUnit ( damage_pep [ i ] ) then
3460: LD_VAR 0 11
3464: PUSH
3465: LD_VAR 0 1
3469: ARRAY
3470: PPUSH
3471: CALL_OW 310
3475: NOT
3476: IFFALSE 3493
// ComExitBuilding ( damage_pep [ i ] ) ;
3478: LD_VAR 0 11
3482: PUSH
3483: LD_VAR 0 1
3487: ARRAY
3488: PPUSH
3489: CALL_OW 122
// if not IsInArea ( damage_pep [ i ] , heal_area ) then
3493: LD_VAR 0 11
3497: PUSH
3498: LD_VAR 0 1
3502: ARRAY
3503: PPUSH
3504: LD_INT 9
3506: PPUSH
3507: CALL_OW 308
3511: NOT
3512: IFFALSE 3535
// ComMoveXY ( damage_pep [ i ] , 96 , 52 ) ;
3514: LD_VAR 0 11
3518: PUSH
3519: LD_VAR 0 1
3523: ARRAY
3524: PPUSH
3525: LD_INT 96
3527: PPUSH
3528: LD_INT 52
3530: PPUSH
3531: CALL_OW 111
// end ;
3535: GO 3457
3537: POP
3538: POP
// if damage_pep = 0 then
3539: LD_VAR 0 11
3543: PUSH
3544: LD_INT 0
3546: EQUAL
3547: IFFALSE 3589
// for i = 1 to sci do
3549: LD_ADDR_VAR 0 1
3553: PUSH
3554: DOUBLE
3555: LD_INT 1
3557: DEC
3558: ST_TO_ADDR
3559: LD_VAR 0 8
3563: PUSH
3564: FOR_TO
3565: IFFALSE 3587
// ComEnterUnit ( sci [ i ] , am_lab ) ;
3567: LD_VAR 0 8
3571: PUSH
3572: LD_VAR 0 1
3576: ARRAY
3577: PPUSH
3578: LD_INT 9
3580: PPUSH
3581: CALL_OW 120
3585: GO 3564
3587: POP
3588: POP
// end ; if ai_tech > 0 then
3589: LD_EXP 12
3593: PUSH
3594: LD_INT 0
3596: GREATER
3597: IFFALSE 3615
// ComResearch ( am_lab , ai_tech [ 1 ] ) ;
3599: LD_INT 9
3601: PPUSH
3602: LD_EXP 12
3606: PUSH
3607: LD_INT 1
3609: ARRAY
3610: PPUSH
3611: CALL_OW 124
// if ai_vehs > 0 then
3615: LD_EXP 11
3619: PUSH
3620: LD_INT 0
3622: GREATER
3623: IFFALSE 3751
// if CanBeConstructed ( am_fac , ai_vehs [ 1 ] , ai_vehs [ 2 ] , ai_vehs [ 3 ] , ai_vehs [ 4 ] ) then
3625: LD_INT 14
3627: PPUSH
3628: LD_EXP 11
3632: PUSH
3633: LD_INT 1
3635: ARRAY
3636: PPUSH
3637: LD_EXP 11
3641: PUSH
3642: LD_INT 2
3644: ARRAY
3645: PPUSH
3646: LD_EXP 11
3650: PUSH
3651: LD_INT 3
3653: ARRAY
3654: PPUSH
3655: LD_EXP 11
3659: PUSH
3660: LD_INT 4
3662: ARRAY
3663: PPUSH
3664: CALL_OW 448
3668: IFFALSE 3751
// begin ComConstruct ( am_fac , ai_vehs [ 1 ] , ai_vehs [ 2 ] , ai_vehs [ 3 ] , ai_vehs [ 4 ] ) ;
3670: LD_INT 14
3672: PPUSH
3673: LD_EXP 11
3677: PUSH
3678: LD_INT 1
3680: ARRAY
3681: PPUSH
3682: LD_EXP 11
3686: PUSH
3687: LD_INT 2
3689: ARRAY
3690: PPUSH
3691: LD_EXP 11
3695: PUSH
3696: LD_INT 3
3698: ARRAY
3699: PPUSH
3700: LD_EXP 11
3704: PUSH
3705: LD_INT 4
3707: ARRAY
3708: PPUSH
3709: CALL_OW 125
// for i = 1 to 4 do
3713: LD_ADDR_VAR 0 1
3717: PUSH
3718: DOUBLE
3719: LD_INT 1
3721: DEC
3722: ST_TO_ADDR
3723: LD_INT 4
3725: PUSH
3726: FOR_TO
3727: IFFALSE 3749
// ai_vehs := Delete ( ai_vehs , 1 ) ;
3729: LD_ADDR_EXP 11
3733: PUSH
3734: LD_EXP 11
3738: PPUSH
3739: LD_INT 1
3741: PPUSH
3742: CALL_OW 3
3746: ST_TO_ADDR
3747: GO 3726
3749: POP
3750: POP
// end ; if tower_list > 0 then
3751: LD_EXP 14
3755: PUSH
3756: LD_INT 0
3758: GREATER
3759: IFFALSE 3863
// begin if GetTech ( tech_rocket , 1 ) = state_researched then
3761: LD_INT 40
3763: PPUSH
3764: LD_INT 1
3766: PPUSH
3767: CALL_OW 321
3771: PUSH
3772: LD_INT 2
3774: EQUAL
3775: IFFALSE 3813
// begin ComPlaceWeapon ( tower_list [ 1 ] , us_rocket_launcher ) ;
3777: LD_EXP 14
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: PPUSH
3786: LD_INT 7
3788: PPUSH
3789: CALL_OW 148
// tower_list := Delete ( tower_list , 1 ) ;
3793: LD_ADDR_EXP 14
3797: PUSH
3798: LD_EXP 14
3802: PPUSH
3803: LD_INT 1
3805: PPUSH
3806: CALL_OW 3
3810: ST_TO_ADDR
// end else
3811: GO 3863
// if GetTech ( tech_gatling , 1 ) = state_researched then
3813: LD_INT 69
3815: PPUSH
3816: LD_INT 1
3818: PPUSH
3819: CALL_OW 321
3823: PUSH
3824: LD_INT 2
3826: EQUAL
3827: IFFALSE 3863
// begin ComPlaceWeapon ( tower_list [ 1 ] , us_gatling_gun ) ;
3829: LD_EXP 14
3833: PUSH
3834: LD_INT 1
3836: ARRAY
3837: PPUSH
3838: LD_INT 4
3840: PPUSH
3841: CALL_OW 148
// tower_list := Delete ( tower_list , 1 ) ;
3845: LD_ADDR_EXP 14
3849: PUSH
3850: LD_EXP 14
3854: PPUSH
3855: LD_INT 1
3857: PPUSH
3858: CALL_OW 3
3862: ST_TO_ADDR
// end ; end ; if damage_vehs > 0 then
3863: LD_VAR 0 13
3867: PUSH
3868: LD_INT 0
3870: GREATER
3871: IFFALSE 4046
// begin for i = 1 to damage_vehs do
3873: LD_ADDR_VAR 0 1
3877: PUSH
3878: DOUBLE
3879: LD_INT 1
3881: DEC
3882: ST_TO_ADDR
3883: LD_VAR 0 13
3887: PUSH
3888: FOR_TO
3889: IFFALSE 4044
// begin un := IsDrivenBy ( damage_vehs [ i ] ) ;
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: LD_VAR 0 13
3900: PUSH
3901: LD_VAR 0 1
3905: ARRAY
3906: PPUSH
3907: CALL_OW 311
3911: ST_TO_ADDR
// if not IsInArea ( damage_vehs [ i ] , repair_area ) then
3912: LD_VAR 0 13
3916: PUSH
3917: LD_VAR 0 1
3921: ARRAY
3922: PPUSH
3923: LD_INT 10
3925: PPUSH
3926: CALL_OW 308
3930: NOT
3931: IFFALSE 3947
// ComMoveToArea ( un , repair_area ) else
3933: LD_VAR 0 2
3937: PPUSH
3938: LD_INT 10
3940: PPUSH
3941: CALL_OW 113
3945: GO 4042
// begin if IsInUnit ( un ) then
3947: LD_VAR 0 2
3951: PPUSH
3952: CALL_OW 310
3956: IFFALSE 3967
// ComExitVehicle ( un ) ;
3958: LD_VAR 0 2
3962: PPUSH
3963: CALL_OW 121
// Wait ( 0 0$01 ) ;
3967: LD_INT 35
3969: PPUSH
3970: CALL_OW 67
// repeat begin ComRepairVehicle ( un , damage_vehs [ i ] ) ;
3974: LD_VAR 0 2
3978: PPUSH
3979: LD_VAR 0 13
3983: PUSH
3984: LD_VAR 0 1
3988: ARRAY
3989: PPUSH
3990: CALL_OW 129
// Wait ( 0 0$01 ) ;
3994: LD_INT 35
3996: PPUSH
3997: CALL_OW 67
// end ; until GetLives ( damage_vehs [ i ] ) = 1000 ;
4001: LD_VAR 0 13
4005: PUSH
4006: LD_VAR 0 1
4010: ARRAY
4011: PPUSH
4012: CALL_OW 256
4016: PUSH
4017: LD_INT 1000
4019: EQUAL
4020: IFFALSE 3974
// ComEnterUnit ( un , damage_vehs [ i ] ) ;
4022: LD_VAR 0 2
4026: PPUSH
4027: LD_VAR 0 13
4031: PUSH
4032: LD_VAR 0 1
4036: ARRAY
4037: PPUSH
4038: CALL_OW 120
// end ; end ;
4042: GO 3888
4044: POP
4045: POP
// end ; end ;
4046: PPOPN 13
4048: END
// every 0 0$01 trigger game_type = 2 and depot_captured = false do var i , un , filter , enemy ;
4049: LD_EXP 1
4053: PUSH
4054: LD_INT 2
4056: EQUAL
4057: PUSH
4058: LD_EXP 8
4062: PUSH
4063: LD_INT 0
4065: EQUAL
4066: AND
4067: IFFALSE 4246
4069: GO 4071
4071: DISABLE
4072: LD_INT 0
4074: PPUSH
4075: PPUSH
4076: PPUSH
4077: PPUSH
// begin enable ;
4078: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_lives , 650 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ] ) ;
4079: LD_ADDR_VAR 0 3
4083: PUSH
4084: LD_INT 22
4086: PUSH
4087: LD_INT 1
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: PUSH
4094: LD_INT 21
4096: PUSH
4097: LD_INT 2
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: PUSH
4104: LD_INT 24
4106: PUSH
4107: LD_INT 650
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PUSH
4114: LD_INT 3
4116: PUSH
4117: LD_INT 34
4119: PUSH
4120: LD_INT 12
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: EMPTY
4128: LIST
4129: LIST
4130: PUSH
4131: EMPTY
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: EMPTY
4138: LIST
4139: PPUSH
4140: CALL_OW 69
4144: ST_TO_ADDR
// enemy := FilterUnitsInArea ( def_area , [ f_side , 3 ] ) ;
4145: LD_ADDR_VAR 0 4
4149: PUSH
4150: LD_INT 11
4152: PPUSH
4153: LD_INT 22
4155: PUSH
4156: LD_INT 3
4158: PUSH
4159: EMPTY
4160: LIST
4161: LIST
4162: PPUSH
4163: CALL_OW 70
4167: ST_TO_ADDR
// if filter > 0 then
4168: LD_VAR 0 3
4172: PUSH
4173: LD_INT 0
4175: GREATER
4176: IFFALSE 4246
// for i = 1 to filter do
4178: LD_ADDR_VAR 0 1
4182: PUSH
4183: DOUBLE
4184: LD_INT 1
4186: DEC
4187: ST_TO_ADDR
4188: LD_VAR 0 3
4192: PUSH
4193: FOR_TO
4194: IFFALSE 4244
// if enemy > 0 then
4196: LD_VAR 0 4
4200: PUSH
4201: LD_INT 0
4203: GREATER
4204: IFFALSE 4242
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
4206: LD_VAR 0 3
4210: PUSH
4211: LD_VAR 0 1
4215: ARRAY
4216: PPUSH
4217: LD_VAR 0 4
4221: PPUSH
4222: LD_VAR 0 3
4226: PUSH
4227: LD_VAR 0 1
4231: ARRAY
4232: PPUSH
4233: CALL_OW 74
4237: PPUSH
4238: CALL_OW 115
4242: GO 4193
4244: POP
4245: POP
// end ;
4246: PPOPN 4
4248: END
// every 0 0$03 trigger game_type = 2 and depot_captured = false do var i , c , p , skr , filter , cargo , dep ;
4249: LD_EXP 1
4253: PUSH
4254: LD_INT 2
4256: EQUAL
4257: PUSH
4258: LD_EXP 8
4262: PUSH
4263: LD_INT 0
4265: EQUAL
4266: AND
4267: IFFALSE 4714
4269: GO 4271
4271: DISABLE
4272: LD_INT 0
4274: PPUSH
4275: PPUSH
4276: PPUSH
4277: PPUSH
4278: PPUSH
4279: PPUSH
4280: PPUSH
// begin enable ;
4281: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 1 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
4282: LD_ADDR_VAR 0 5
4286: PUSH
4287: LD_INT 50
4289: PUSH
4290: EMPTY
4291: LIST
4292: PUSH
4293: LD_INT 22
4295: PUSH
4296: LD_INT 1
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: LD_INT 2
4305: PUSH
4306: LD_INT 25
4308: PUSH
4309: LD_INT 2
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 25
4318: PUSH
4319: LD_INT 16
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: LIST
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: LIST
4335: PPUSH
4336: CALL_OW 69
4340: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_cargo_bay ] , [ f_lives , 650 ] ] ) ;
4341: LD_ADDR_VAR 0 6
4345: PUSH
4346: LD_INT 22
4348: PUSH
4349: LD_INT 1
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PUSH
4356: LD_INT 34
4358: PUSH
4359: LD_INT 12
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: PUSH
4366: LD_INT 24
4368: PUSH
4369: LD_INT 650
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: LIST
4380: PPUSH
4381: CALL_OW 69
4385: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4386: LD_ADDR_VAR 0 7
4390: PUSH
4391: LD_INT 22
4393: PUSH
4394: LD_INT 1
4396: PUSH
4397: EMPTY
4398: LIST
4399: LIST
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: LD_INT 30
4406: PUSH
4407: LD_INT 0
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PUSH
4414: LD_INT 30
4416: PUSH
4417: LD_INT 1
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_spawn ) ;
4438: LD_ADDR_VAR 0 4
4442: PUSH
4443: LD_INT 7
4445: PPUSH
4446: CALL_OW 435
4450: ST_TO_ADDR
// c = 1 ;
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: LD_INT 1
4458: ST_TO_ADDR
// if cargo > 0 then
4459: LD_VAR 0 6
4463: PUSH
4464: LD_INT 0
4466: GREATER
4467: IFFALSE 4714
// while c < skr do
4469: LD_VAR 0 2
4473: PUSH
4474: LD_VAR 0 4
4478: LESS
4479: IFFALSE 4714
// begin if cargo > 0 then
4481: LD_VAR 0 6
4485: PUSH
4486: LD_INT 0
4488: GREATER
4489: IFFALSE 4712
// begin if GetFuel ( cargo [ 1 ] ) > 40 then
4491: LD_VAR 0 6
4495: PUSH
4496: LD_INT 1
4498: ARRAY
4499: PPUSH
4500: CALL_OW 261
4504: PUSH
4505: LD_INT 40
4507: GREATER
4508: IFFALSE 4606
// begin if GetDistXYToSide ( skr [ c ] , skr [ c + 1 ] , 3 ) > 15 and not HasTask ( cargo [ 1 ] ) then
4510: LD_VAR 0 4
4514: PUSH
4515: LD_VAR 0 2
4519: ARRAY
4520: PPUSH
4521: LD_VAR 0 4
4525: PUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_INT 1
4533: PLUS
4534: ARRAY
4535: PPUSH
4536: LD_INT 3
4538: PPUSH
4539: CALL 10337 0 3
4543: PUSH
4544: LD_INT 15
4546: GREATER
4547: PUSH
4548: LD_VAR 0 6
4552: PUSH
4553: LD_INT 1
4555: ARRAY
4556: PPUSH
4557: CALL_OW 314
4561: NOT
4562: AND
4563: IFFALSE 4604
// ComCollect ( cargo [ 1 ] , skr [ c ] , skr [ c + 1 ] ) ;
4565: LD_VAR 0 6
4569: PUSH
4570: LD_INT 1
4572: ARRAY
4573: PPUSH
4574: LD_VAR 0 4
4578: PUSH
4579: LD_VAR 0 2
4583: ARRAY
4584: PPUSH
4585: LD_VAR 0 4
4589: PUSH
4590: LD_VAR 0 2
4594: PUSH
4595: LD_INT 1
4597: PLUS
4598: ARRAY
4599: PPUSH
4600: CALL_OW 117
// end else
4604: GO 4698
// begin repeat begin ComMoveXY ( cargo [ 1 ] , GetX ( dep [ 1 ] ) , GetY ( dep [ 1 ] ) ) ;
4606: LD_VAR 0 6
4610: PUSH
4611: LD_INT 1
4613: ARRAY
4614: PPUSH
4615: LD_VAR 0 7
4619: PUSH
4620: LD_INT 1
4622: ARRAY
4623: PPUSH
4624: CALL_OW 250
4628: PPUSH
4629: LD_VAR 0 7
4633: PUSH
4634: LD_INT 1
4636: ARRAY
4637: PPUSH
4638: CALL_OW 251
4642: PPUSH
4643: CALL_OW 111
// Wait ( 0 0$01 ) ;
4647: LD_INT 35
4649: PPUSH
4650: CALL_OW 67
// end until GetDistUnits ( cargo [ 1 ] , dep [ 1 ] ) < 7 ;
4654: LD_VAR 0 6
4658: PUSH
4659: LD_INT 1
4661: ARRAY
4662: PPUSH
4663: LD_VAR 0 7
4667: PUSH
4668: LD_INT 1
4670: ARRAY
4671: PPUSH
4672: CALL_OW 296
4676: PUSH
4677: LD_INT 7
4679: LESS
4680: IFFALSE 4606
// SetFuel ( cargo [ 1 ] , 100 ) ;
4682: LD_VAR 0 6
4686: PUSH
4687: LD_INT 1
4689: ARRAY
4690: PPUSH
4691: LD_INT 100
4693: PPUSH
4694: CALL_OW 240
// end ; c = c + 2 ;
4698: LD_ADDR_VAR 0 2
4702: PUSH
4703: LD_VAR 0 2
4707: PUSH
4708: LD_INT 2
4710: PLUS
4711: ST_TO_ADDR
// end ; end ;
4712: GO 4469
// end ;
4714: PPOPN 7
4716: END
// on EnterBuilding ( b , un ) do var i , filter ;
4717: LD_INT 0
4719: PPUSH
4720: PPUSH
// begin if game_type = 2 and depot_captured = false then
4721: LD_EXP 1
4725: PUSH
4726: LD_INT 2
4728: EQUAL
4729: PUSH
4730: LD_EXP 8
4734: PUSH
4735: LD_INT 0
4737: EQUAL
4738: AND
4739: IFFALSE 4793
// begin if b in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
4741: LD_VAR 0 1
4745: PUSH
4746: LD_INT 22
4748: PUSH
4749: LD_INT 1
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: PUSH
4756: LD_INT 30
4758: PUSH
4759: LD_INT 32
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PPUSH
4770: CALL_OW 69
4774: IN
4775: IFFALSE 4793
// sold_ocp := sold_ocp ^ un ;
4777: LD_ADDR_EXP 13
4781: PUSH
4782: LD_EXP 13
4786: PUSH
4787: LD_VAR 0 2
4791: ADD
4792: ST_TO_ADDR
// end ; end ;
4793: PPOPN 4
4795: END
// on LeaveBuilding ( b , un ) do var i , filter ;
4796: LD_INT 0
4798: PPUSH
4799: PPUSH
// begin if un in sold_ocp then
4800: LD_VAR 0 2
4804: PUSH
4805: LD_EXP 13
4809: IN
4810: IFFALSE 4832
// sold_ocp := Delete ( sold_ocp , un ) ;
4812: LD_ADDR_EXP 13
4816: PUSH
4817: LD_EXP 13
4821: PPUSH
4822: LD_VAR 0 2
4826: PPUSH
4827: CALL_OW 3
4831: ST_TO_ADDR
// end ;
4832: PPOPN 4
4834: END
// on ResearchComplete ( tech , lab ) do var i , filter , un ;
4835: LD_INT 0
4837: PPUSH
4838: PPUSH
4839: PPUSH
// begin if game_type = 2 then
4840: LD_EXP 1
4844: PUSH
4845: LD_INT 2
4847: EQUAL
4848: IFFALSE 4895
// begin if GetSide ( lab ) = 1 then
4850: LD_VAR 0 2
4854: PPUSH
4855: CALL_OW 255
4859: PUSH
4860: LD_INT 1
4862: EQUAL
4863: IFFALSE 4895
// if tech in ai_tech then
4865: LD_VAR 0 1
4869: PUSH
4870: LD_EXP 12
4874: IN
4875: IFFALSE 4895
// ai_tech := Delete ( ai_tech , 1 ) ;
4877: LD_ADDR_EXP 12
4881: PUSH
4882: LD_EXP 12
4886: PPUSH
4887: LD_INT 1
4889: PPUSH
4890: CALL_OW 3
4894: ST_TO_ADDR
// end ; end ;
4895: PPOPN 5
4897: END
// on BuildingComplete ( b ) do var i , side , un ;
4898: LD_INT 0
4900: PPUSH
4901: PPUSH
4902: PPUSH
// begin if game_type = 2 and depot_captured = false then
4903: LD_EXP 1
4907: PUSH
4908: LD_INT 2
4910: EQUAL
4911: PUSH
4912: LD_EXP 8
4916: PUSH
4917: LD_INT 0
4919: EQUAL
4920: AND
4921: IFFALSE 5028
// begin if GetSide ( b ) = 1 then
4923: LD_VAR 0 1
4927: PPUSH
4928: CALL_OW 255
4932: PUSH
4933: LD_INT 1
4935: EQUAL
4936: IFFALSE 4976
// for i = 1 to 4 do
4938: LD_ADDR_VAR 0 2
4942: PUSH
4943: DOUBLE
4944: LD_INT 1
4946: DEC
4947: ST_TO_ADDR
4948: LD_INT 4
4950: PUSH
4951: FOR_TO
4952: IFFALSE 4974
// ai_build := Delete ( ai_build , 1 ) ;
4954: LD_ADDR_EXP 10
4958: PUSH
4959: LD_EXP 10
4963: PPUSH
4964: LD_INT 1
4966: PPUSH
4967: CALL_OW 3
4971: ST_TO_ADDR
4972: GO 4951
4974: POP
4975: POP
// if b in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) then
4976: LD_VAR 0 1
4980: PUSH
4981: LD_INT 22
4983: PUSH
4984: LD_INT 1
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 32
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PPUSH
5005: CALL_OW 69
5009: IN
5010: IFFALSE 5028
// tower_list := tower_list ^ b ;
5012: LD_ADDR_EXP 14
5016: PUSH
5017: LD_EXP 14
5021: PUSH
5022: LD_VAR 0 1
5026: ADD
5027: ST_TO_ADDR
// end ; end ;
5028: PPOPN 4
5030: END
// export enemy_count , enemy_typ ; every 1 1$30 trigger game_type = 1 do
5031: LD_EXP 1
5035: PUSH
5036: LD_INT 1
5038: EQUAL
5039: IFFALSE 5237
5041: GO 5043
5043: DISABLE
// begin enable ;
5044: ENABLE
// if timer <= 20 20$00 then
5045: LD_EXP 6
5049: PUSH
5050: LD_INT 42000
5052: LESSEQUAL
5053: IFFALSE 5088
// begin enemy_count := [ 5 , 6 , 7 ] [ game_diff ] ;
5055: LD_ADDR_EXP 15
5059: PUSH
5060: LD_INT 5
5062: PUSH
5063: LD_INT 6
5065: PUSH
5066: LD_INT 7
5068: PUSH
5069: EMPTY
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: LD_EXP 2
5078: ARRAY
5079: ST_TO_ADDR
// enemy_typ := 1 ;
5080: LD_ADDR_EXP 16
5084: PUSH
5085: LD_INT 1
5087: ST_TO_ADDR
// end ; if timer > 20 20$00 and timer <= 40 40$00 then
5088: LD_EXP 6
5092: PUSH
5093: LD_INT 42000
5095: GREATER
5096: PUSH
5097: LD_EXP 6
5101: PUSH
5102: LD_INT 84000
5104: LESSEQUAL
5105: AND
5106: IFFALSE 5141
// begin enemy_count := [ 6 , 8 , 9 ] [ game_diff ] ;
5108: LD_ADDR_EXP 15
5112: PUSH
5113: LD_INT 6
5115: PUSH
5116: LD_INT 8
5118: PUSH
5119: LD_INT 9
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: LIST
5126: PUSH
5127: LD_EXP 2
5131: ARRAY
5132: ST_TO_ADDR
// enemy_typ := 2 ;
5133: LD_ADDR_EXP 16
5137: PUSH
5138: LD_INT 2
5140: ST_TO_ADDR
// end ; if timer > 40 40$00 and timer <= 60 60$00 then
5141: LD_EXP 6
5145: PUSH
5146: LD_INT 84000
5148: GREATER
5149: PUSH
5150: LD_EXP 6
5154: PUSH
5155: LD_INT 126000
5157: LESSEQUAL
5158: AND
5159: IFFALSE 5194
// begin enemy_count := [ 8 , 9 , 10 ] [ game_diff ] ;
5161: LD_ADDR_EXP 15
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: LD_INT 9
5171: PUSH
5172: LD_INT 10
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_EXP 2
5184: ARRAY
5185: ST_TO_ADDR
// enemy_typ := 3 ;
5186: LD_ADDR_EXP 16
5190: PUSH
5191: LD_INT 3
5193: ST_TO_ADDR
// end ; if timer > 60 60$00 then
5194: LD_EXP 6
5198: PUSH
5199: LD_INT 126000
5201: GREATER
5202: IFFALSE 5237
// begin enemy_count := [ 10 , 12 , 14 ] [ game_diff ] ;
5204: LD_ADDR_EXP 15
5208: PUSH
5209: LD_INT 10
5211: PUSH
5212: LD_INT 12
5214: PUSH
5215: LD_INT 14
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_EXP 2
5227: ARRAY
5228: ST_TO_ADDR
// enemy_typ := 3 ;
5229: LD_ADDR_EXP 16
5233: PUSH
5234: LD_INT 3
5236: ST_TO_ADDR
// end ; end ;
5237: END
// export am_com2 ; every 0 0$01 trigger timer >= [ 8 8$00 , 8 8$30 , 9 9$00 ] [ game_diff ] and game_type = 1 do var area ;
5238: LD_EXP 6
5242: PUSH
5243: LD_INT 16800
5245: PUSH
5246: LD_INT 17850
5248: PUSH
5249: LD_INT 18900
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_EXP 2
5261: ARRAY
5262: GREATEREQUAL
5263: PUSH
5264: LD_EXP 1
5268: PUSH
5269: LD_INT 1
5271: EQUAL
5272: AND
5273: IFFALSE 5477
5275: GO 5277
5277: DISABLE
5278: LD_INT 0
5280: PPUSH
// begin uc_nation := 1 ;
5281: LD_ADDR_OWVAR 21
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// uc_side := 4 ;
5289: LD_ADDR_OWVAR 20
5293: PUSH
5294: LD_INT 4
5296: ST_TO_ADDR
// hc_sex := sex_male ;
5297: LD_ADDR_OWVAR 27
5301: PUSH
5302: LD_INT 1
5304: ST_TO_ADDR
// hc_class := 1 ;
5305: LD_ADDR_OWVAR 28
5309: PUSH
5310: LD_INT 1
5312: ST_TO_ADDR
// hc_gallery :=  ;
5313: LD_ADDR_OWVAR 33
5317: PUSH
5318: LD_STRING 
5320: ST_TO_ADDR
// hc_name :=  ;
5321: LD_ADDR_OWVAR 26
5325: PUSH
5326: LD_STRING 
5328: ST_TO_ADDR
// am_com2 := CreateHuman ;
5329: LD_ADDR_EXP 17
5333: PUSH
5334: CALL_OW 44
5338: ST_TO_ADDR
// SayRadio ( am_com2 , D-rus ) ;
5339: LD_EXP 17
5343: PPUSH
5344: LD_STRING D-rus
5346: PPUSH
5347: CALL_OW 94
// area := [ north_spawn , south_spawn ] ;
5351: LD_ADDR_VAR 0 1
5355: PUSH
5356: LD_INT 6
5358: PUSH
5359: LD_INT 5
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: ST_TO_ADDR
// while ( true ) do
5366: LD_INT 1
5368: IFFALSE 5477
// begin Wait ( Rand ( 6 6$30 , 8 8$32 ) ) ;
5370: LD_INT 13650
5372: PPUSH
5373: LD_INT 17920
5375: PPUSH
5376: CALL_OW 12
5380: PPUSH
5381: CALL_OW 67
// RussianAttack ( 3 , enemy_count , enemy_typ , area ) ;
5385: LD_INT 3
5387: PPUSH
5388: LD_EXP 15
5392: PPUSH
5393: LD_EXP 16
5397: PPUSH
5398: LD_VAR 0 1
5402: PPUSH
5403: CALL 7919 0 4
// if ( timer > [ 55 55$00 , 45 45$00 , 35 35$00 ] [ Difficulty ] ) then
5407: LD_EXP 6
5411: PUSH
5412: LD_INT 115500
5414: PUSH
5415: LD_INT 94500
5417: PUSH
5418: LD_INT 73500
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: LIST
5425: PUSH
5426: LD_OWVAR 67
5430: ARRAY
5431: GREATER
5432: IFFALSE 5475
// begin Wait ( Rand ( 0 0$30 , 1 1$30 ) ) ;
5434: LD_INT 1050
5436: PPUSH
5437: LD_INT 3150
5439: PPUSH
5440: CALL_OW 12
5444: PPUSH
5445: CALL_OW 67
// RussianAttack ( 3 , enemy_count / 2 , enemy_typ , area ) ;
5449: LD_INT 3
5451: PPUSH
5452: LD_EXP 15
5456: PUSH
5457: LD_INT 2
5459: DIVREAL
5460: PPUSH
5461: LD_EXP 16
5465: PPUSH
5466: LD_VAR 0 1
5470: PPUSH
5471: CALL 7919 0 4
// end ; end ;
5475: GO 5366
// end ;
5477: PPOPN 1
5479: END
// every 0 0$01 trigger GetResourceType ( GetBase ( jota_base ) , mat_siberit ) = force_timer do var i , un ;
5480: LD_INT 1
5482: PPUSH
5483: CALL_OW 274
5487: PPUSH
5488: LD_INT 3
5490: PPUSH
5491: CALL_OW 275
5495: PUSH
5496: LD_EXP 7
5500: EQUAL
5501: IFFALSE 5783
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
// begin SayRadio ( am_com2 , D-help ) ;
5510: LD_EXP 17
5514: PPUSH
5515: LD_STRING D-help
5517: PPUSH
5518: CALL_OW 94
// Wait ( Rand ( 3 3$21 , 7 7$39 ) ) ;
5522: LD_INT 7035
5524: PPUSH
5525: LD_INT 16065
5527: PPUSH
5528: CALL_OW 12
5532: PPUSH
5533: CALL_OW 67
// repeat Wait ( 0 0$01 ) ;
5537: LD_INT 35
5539: PPUSH
5540: CALL_OW 67
// until FilterAllUnits ( [ f_side , 3 ] ) = 0 ;
5544: LD_INT 22
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PPUSH
5554: CALL_OW 69
5558: PUSH
5559: LD_INT 0
5561: EQUAL
5562: IFFALSE 5537
// uc_side := 1 ;
5564: LD_ADDR_OWVAR 20
5568: PUSH
5569: LD_INT 1
5571: ST_TO_ADDR
// uc_nation := 1 ;
5572: LD_ADDR_OWVAR 21
5576: PUSH
5577: LD_INT 1
5579: ST_TO_ADDR
// for i = 1 to ( 3 + game_diff ) do
5580: LD_ADDR_VAR 0 1
5584: PUSH
5585: DOUBLE
5586: LD_INT 1
5588: DEC
5589: ST_TO_ADDR
5590: LD_INT 3
5592: PUSH
5593: LD_EXP 2
5597: PLUS
5598: PUSH
5599: FOR_TO
5600: IFFALSE 5645
// begin un := CreateHumanWithClass ( Rand ( 1 , 4 ) , game_skill ) ;
5602: LD_ADDR_VAR 0 2
5606: PUSH
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 4
5612: PPUSH
5613: CALL_OW 12
5617: PPUSH
5618: LD_EXP 3
5622: PPUSH
5623: CALL 9174 0 2
5627: ST_TO_ADDR
// PlaceUnitArea ( un , south_spawn , false ) ;
5628: LD_VAR 0 2
5632: PPUSH
5633: LD_INT 5
5635: PPUSH
5636: LD_INT 0
5638: PPUSH
5639: CALL_OW 49
// end ;
5643: GO 5599
5645: POP
5646: POP
// case game_diff of 1 :
5647: LD_EXP 2
5651: PUSH
5652: LD_INT 1
5654: DOUBLE
5655: EQUAL
5656: IFTRUE 5660
5658: GO 5687
5660: POP
// CreateVehicleWithDriver ( us_heavy_tracked , engine_combustion , us_double_gun , south_spawn , 0 , game_skill ) ; 2 :
5661: LD_INT 4
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 5
5669: PPUSH
5670: LD_INT 5
5672: PPUSH
5673: LD_INT 0
5675: PPUSH
5676: LD_EXP 3
5680: PPUSH
5681: CALL 9713 0 6
5685: GO 5758
5687: LD_INT 2
5689: DOUBLE
5690: EQUAL
5691: IFTRUE 5695
5693: GO 5722
5695: POP
// CreateVehicleWithDriver ( us_medium_tracked , engine_combustion , us_double_gun , south_spawn , 0 , game_skill ) ; 3 :
5696: LD_INT 3
5698: PPUSH
5699: LD_INT 1
5701: PPUSH
5702: LD_INT 5
5704: PPUSH
5705: LD_INT 5
5707: PPUSH
5708: LD_INT 0
5710: PPUSH
5711: LD_EXP 3
5715: PPUSH
5716: CALL 9713 0 6
5720: GO 5758
5722: LD_INT 3
5724: DOUBLE
5725: EQUAL
5726: IFTRUE 5730
5728: GO 5757
5730: POP
// CreateVehicleWithDriver ( us_medium_tracked , engine_combustion , us_light_gun , south_spawn , 0 , game_skill ) ; end ;
5731: LD_INT 3
5733: PPUSH
5734: LD_INT 1
5736: PPUSH
5737: LD_INT 3
5739: PPUSH
5740: LD_INT 5
5742: PPUSH
5743: LD_INT 0
5745: PPUSH
5746: LD_EXP 3
5750: PPUSH
5751: CALL 9713 0 6
5755: GO 5758
5757: POP
// DialogueOn ;
5758: CALL_OW 6
// CenterOnXY ( 91 , 115 ) ;
5762: LD_INT 91
5764: PPUSH
5765: LD_INT 115
5767: PPUSH
5768: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
5772: LD_INT 10
5774: PPUSH
5775: CALL_OW 67
// DialogueOff ;
5779: CALL_OW 7
// end ;
5783: PPOPN 2
5785: END
// export function AmericanAttack ( side , num , typ , list ) ; var i , un , filter , veh , chassis , weapon , f ; begin
5786: LD_INT 0
5788: PPUSH
5789: PPUSH
5790: PPUSH
5791: PPUSH
5792: PPUSH
5793: PPUSH
5794: PPUSH
5795: PPUSH
// uc_side := side ;
5796: LD_ADDR_OWVAR 20
5800: PUSH
5801: LD_VAR 0 1
5805: ST_TO_ADDR
// uc_nation := nation_american ;
5806: LD_ADDR_OWVAR 21
5810: PUSH
5811: LD_INT 1
5813: ST_TO_ADDR
// chassis := [ us_medium_tracked , us_heavy_tracked ] ;
5814: LD_ADDR_VAR 0 10
5818: PUSH
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: ST_TO_ADDR
// weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_heavy_gun , us_rocket_launcher , 97 ] ;
5829: LD_ADDR_VAR 0 11
5833: PUSH
5834: LD_INT 2
5836: PUSH
5837: LD_INT 4
5839: PUSH
5840: LD_INT 5
5842: PUSH
5843: LD_INT 6
5845: PUSH
5846: LD_INT 7
5848: PUSH
5849: LD_INT 97
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: ST_TO_ADDR
// case typ of 1 :
5860: LD_VAR 0 3
5864: PUSH
5865: LD_INT 1
5867: DOUBLE
5868: EQUAL
5869: IFTRUE 5873
5871: GO 6067
5873: POP
// begin for i = 1 to num do
5874: LD_ADDR_VAR 0 6
5878: PUSH
5879: DOUBLE
5880: LD_INT 1
5882: DEC
5883: ST_TO_ADDR
5884: LD_VAR 0 2
5888: PUSH
5889: FOR_TO
5890: IFFALSE 6063
// begin vc_chassis := chassis [ 1 ] ;
5892: LD_ADDR_OWVAR 37
5896: PUSH
5897: LD_VAR 0 10
5901: PUSH
5902: LD_INT 1
5904: ARRAY
5905: ST_TO_ADDR
// vc_engine := engine_combustion ;
5906: LD_ADDR_OWVAR 39
5910: PUSH
5911: LD_INT 1
5913: ST_TO_ADDR
// vc_control := control_manual ;
5914: LD_ADDR_OWVAR 38
5918: PUSH
5919: LD_INT 1
5921: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
5922: LD_ADDR_OWVAR 40
5926: PUSH
5927: LD_VAR 0 11
5931: PUSH
5932: LD_INT 1
5934: PPUSH
5935: LD_INT 3
5937: PPUSH
5938: CALL_OW 12
5942: ARRAY
5943: ST_TO_ADDR
// veh := CreateVehicle ;
5944: LD_ADDR_VAR 0 9
5948: PUSH
5949: CALL_OW 45
5953: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
5954: LD_ADDR_VAR 0 12
5958: PUSH
5959: LD_INT 1
5961: PPUSH
5962: LD_INT 2
5964: PPUSH
5965: CALL_OW 12
5969: ST_TO_ADDR
// if f = 1 then
5970: LD_VAR 0 12
5974: PUSH
5975: LD_INT 1
5977: EQUAL
5978: IFFALSE 5994
// SetDir ( veh , 3 ) else
5980: LD_VAR 0 9
5984: PPUSH
5985: LD_INT 3
5987: PPUSH
5988: CALL_OW 233
5992: GO 6006
// SetDir ( veh , 1 ) ;
5994: LD_VAR 0 9
5998: PPUSH
5999: LD_INT 1
6001: PPUSH
6002: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
6006: LD_VAR 0 9
6010: PPUSH
6011: LD_VAR 0 4
6015: PUSH
6016: LD_VAR 0 12
6020: ARRAY
6021: PPUSH
6022: LD_INT 0
6024: PPUSH
6025: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
6029: LD_ADDR_VAR 0 7
6033: PUSH
6034: LD_INT 1
6036: PPUSH
6037: LD_EXP 4
6041: PPUSH
6042: CALL 9174 0 2
6046: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6047: LD_VAR 0 7
6051: PPUSH
6052: LD_VAR 0 9
6056: PPUSH
6057: CALL_OW 52
// end ;
6061: GO 5889
6063: POP
6064: POP
// end ; 2 :
6065: GO 6541
6067: LD_INT 2
6069: DOUBLE
6070: EQUAL
6071: IFTRUE 6075
6073: GO 6338
6075: POP
// begin for i = 1 to num do
6076: LD_ADDR_VAR 0 6
6080: PUSH
6081: DOUBLE
6082: LD_INT 1
6084: DEC
6085: ST_TO_ADDR
6086: LD_VAR 0 2
6090: PUSH
6091: FOR_TO
6092: IFFALSE 6273
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
6094: LD_ADDR_OWVAR 37
6098: PUSH
6099: LD_VAR 0 10
6103: PUSH
6104: LD_INT 1
6106: PPUSH
6107: LD_INT 2
6109: PPUSH
6110: CALL_OW 12
6114: ARRAY
6115: ST_TO_ADDR
// vc_engine := engine_combustion ;
6116: LD_ADDR_OWVAR 39
6120: PUSH
6121: LD_INT 1
6123: ST_TO_ADDR
// vc_control := control_manual ;
6124: LD_ADDR_OWVAR 38
6128: PUSH
6129: LD_INT 1
6131: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
6132: LD_ADDR_OWVAR 40
6136: PUSH
6137: LD_VAR 0 11
6141: PUSH
6142: LD_INT 1
6144: PPUSH
6145: LD_INT 3
6147: PPUSH
6148: CALL_OW 12
6152: ARRAY
6153: ST_TO_ADDR
// veh := CreateVehicle ;
6154: LD_ADDR_VAR 0 9
6158: PUSH
6159: CALL_OW 45
6163: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
6164: LD_ADDR_VAR 0 12
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ST_TO_ADDR
// if f = 1 then
6180: LD_VAR 0 12
6184: PUSH
6185: LD_INT 1
6187: EQUAL
6188: IFFALSE 6204
// SetDir ( veh , 3 ) else
6190: LD_VAR 0 9
6194: PPUSH
6195: LD_INT 3
6197: PPUSH
6198: CALL_OW 233
6202: GO 6216
// SetDir ( veh , 1 ) ;
6204: LD_VAR 0 9
6208: PPUSH
6209: LD_INT 1
6211: PPUSH
6212: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
6216: LD_VAR 0 9
6220: PPUSH
6221: LD_VAR 0 4
6225: PUSH
6226: LD_VAR 0 12
6230: ARRAY
6231: PPUSH
6232: LD_INT 0
6234: PPUSH
6235: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
6239: LD_ADDR_VAR 0 7
6243: PUSH
6244: LD_INT 1
6246: PPUSH
6247: LD_EXP 4
6251: PPUSH
6252: CALL 9174 0 2
6256: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6257: LD_VAR 0 7
6261: PPUSH
6262: LD_VAR 0 9
6266: PPUSH
6267: CALL_OW 52
// end ;
6271: GO 6091
6273: POP
6274: POP
// for i = 1 to 3 do
6275: LD_ADDR_VAR 0 6
6279: PUSH
6280: DOUBLE
6281: LD_INT 1
6283: DEC
6284: ST_TO_ADDR
6285: LD_INT 3
6287: PUSH
6288: FOR_TO
6289: IFFALSE 6334
// begin un := CreateHumanWithClass ( class_sniper , game_eskill ) ;
6291: LD_ADDR_VAR 0 7
6295: PUSH
6296: LD_INT 5
6298: PPUSH
6299: LD_EXP 4
6303: PPUSH
6304: CALL 9174 0 2
6308: ST_TO_ADDR
// PlaceUnitArea ( un , list [ f ] , false ) ;
6309: LD_VAR 0 7
6313: PPUSH
6314: LD_VAR 0 4
6318: PUSH
6319: LD_VAR 0 12
6323: ARRAY
6324: PPUSH
6325: LD_INT 0
6327: PPUSH
6328: CALL_OW 49
// end ;
6332: GO 6288
6334: POP
6335: POP
// end ; 3 :
6336: GO 6541
6338: LD_INT 3
6340: DOUBLE
6341: EQUAL
6342: IFTRUE 6346
6344: GO 6540
6346: POP
// begin for i = 1 to num do
6347: LD_ADDR_VAR 0 6
6351: PUSH
6352: DOUBLE
6353: LD_INT 1
6355: DEC
6356: ST_TO_ADDR
6357: LD_VAR 0 2
6361: PUSH
6362: FOR_TO
6363: IFFALSE 6536
// begin vc_chassis := chassis [ 2 ] ;
6365: LD_ADDR_OWVAR 37
6369: PUSH
6370: LD_VAR 0 10
6374: PUSH
6375: LD_INT 2
6377: ARRAY
6378: ST_TO_ADDR
// vc_engine := engine_combustion ;
6379: LD_ADDR_OWVAR 39
6383: PUSH
6384: LD_INT 1
6386: ST_TO_ADDR
// vc_control := control_manual ;
6387: LD_ADDR_OWVAR 38
6391: PUSH
6392: LD_INT 1
6394: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 6 ) ] ;
6395: LD_ADDR_OWVAR 40
6399: PUSH
6400: LD_VAR 0 11
6404: PUSH
6405: LD_INT 3
6407: PPUSH
6408: LD_INT 6
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: ST_TO_ADDR
// veh := CreateVehicle ;
6417: LD_ADDR_VAR 0 9
6421: PUSH
6422: CALL_OW 45
6426: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
6427: LD_ADDR_VAR 0 12
6431: PUSH
6432: LD_INT 1
6434: PPUSH
6435: LD_INT 2
6437: PPUSH
6438: CALL_OW 12
6442: ST_TO_ADDR
// if f = 1 then
6443: LD_VAR 0 12
6447: PUSH
6448: LD_INT 1
6450: EQUAL
6451: IFFALSE 6467
// SetDir ( veh , 3 ) else
6453: LD_VAR 0 9
6457: PPUSH
6458: LD_INT 3
6460: PPUSH
6461: CALL_OW 233
6465: GO 6479
// SetDir ( veh , 1 ) ;
6467: LD_VAR 0 9
6471: PPUSH
6472: LD_INT 1
6474: PPUSH
6475: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
6479: LD_VAR 0 9
6483: PPUSH
6484: LD_VAR 0 4
6488: PUSH
6489: LD_VAR 0 12
6493: ARRAY
6494: PPUSH
6495: LD_INT 0
6497: PPUSH
6498: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
6502: LD_ADDR_VAR 0 7
6506: PUSH
6507: LD_INT 1
6509: PPUSH
6510: LD_EXP 4
6514: PPUSH
6515: CALL 9174 0 2
6519: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6520: LD_VAR 0 7
6524: PPUSH
6525: LD_VAR 0 9
6529: PPUSH
6530: CALL_OW 52
// end ;
6534: GO 6362
6536: POP
6537: POP
// end ; end ;
6538: GO 6541
6540: POP
// end ;
6541: LD_VAR 0 5
6545: RET
// every 0 0$01 trigger game_type = 2 and depot_captured do var filter , enemy , i ;
6546: LD_EXP 1
6550: PUSH
6551: LD_INT 2
6553: EQUAL
6554: PUSH
6555: LD_EXP 8
6559: AND
6560: IFFALSE 6715
6562: GO 6564
6564: DISABLE
6565: LD_INT 0
6567: PPUSH
6568: PPUSH
6569: PPUSH
// begin enable ;
6570: ENABLE
// filter := FilterAllUnits ( [ f_side , 1 ] ) ;
6571: LD_ADDR_VAR 0 1
6575: PUSH
6576: LD_INT 22
6578: PUSH
6579: LD_INT 1
6581: PUSH
6582: EMPTY
6583: LIST
6584: LIST
6585: PPUSH
6586: CALL_OW 69
6590: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
6591: LD_ADDR_VAR 0 2
6595: PUSH
6596: LD_INT 2
6598: PUSH
6599: LD_INT 22
6601: PUSH
6602: LD_INT 3
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: LD_INT 22
6611: PUSH
6612: LD_INT 6
6614: PUSH
6615: EMPTY
6616: LIST
6617: LIST
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: LIST
6623: PPUSH
6624: CALL_OW 69
6628: ST_TO_ADDR
// if filter > 0 then
6629: LD_VAR 0 1
6633: PUSH
6634: LD_INT 0
6636: GREATER
6637: IFFALSE 6715
// for i = 1 to filter do
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: DOUBLE
6645: LD_INT 1
6647: DEC
6648: ST_TO_ADDR
6649: LD_VAR 0 1
6653: PUSH
6654: FOR_TO
6655: IFFALSE 6713
// if not HasTask ( filter [ i ] ) then
6657: LD_VAR 0 1
6661: PUSH
6662: LD_VAR 0 3
6666: ARRAY
6667: PPUSH
6668: CALL_OW 314
6672: NOT
6673: IFFALSE 6711
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
6675: LD_VAR 0 1
6679: PUSH
6680: LD_VAR 0 3
6684: ARRAY
6685: PPUSH
6686: LD_VAR 0 2
6690: PPUSH
6691: LD_VAR 0 1
6695: PUSH
6696: LD_VAR 0 3
6700: ARRAY
6701: PPUSH
6702: CALL_OW 74
6706: PPUSH
6707: CALL_OW 115
6711: GO 6654
6713: POP
6714: POP
// end ;
6715: PPOPN 3
6717: END
// every 0 0$01 trigger game_type = 2 do var filter , enemy , i ;
6718: LD_EXP 1
6722: PUSH
6723: LD_INT 2
6725: EQUAL
6726: IFFALSE 6881
6728: GO 6730
6730: DISABLE
6731: LD_INT 0
6733: PPUSH
6734: PPUSH
6735: PPUSH
// begin enable ;
6736: ENABLE
// filter := FilterAllUnits ( [ f_side , 8 ] ) ;
6737: LD_ADDR_VAR 0 1
6741: PUSH
6742: LD_INT 22
6744: PUSH
6745: LD_INT 8
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: PPUSH
6752: CALL_OW 69
6756: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
6757: LD_ADDR_VAR 0 2
6761: PUSH
6762: LD_INT 2
6764: PUSH
6765: LD_INT 22
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: LD_INT 22
6777: PUSH
6778: LD_INT 6
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: EMPTY
6786: LIST
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 69
6794: ST_TO_ADDR
// if filter > 0 then
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 0
6802: GREATER
6803: IFFALSE 6881
// for i = 1 to filter do
6805: LD_ADDR_VAR 0 3
6809: PUSH
6810: DOUBLE
6811: LD_INT 1
6813: DEC
6814: ST_TO_ADDR
6815: LD_VAR 0 1
6819: PUSH
6820: FOR_TO
6821: IFFALSE 6879
// if not HasTask ( filter [ i ] ) then
6823: LD_VAR 0 1
6827: PUSH
6828: LD_VAR 0 3
6832: ARRAY
6833: PPUSH
6834: CALL_OW 314
6838: NOT
6839: IFFALSE 6877
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
6841: LD_VAR 0 1
6845: PUSH
6846: LD_VAR 0 3
6850: ARRAY
6851: PPUSH
6852: LD_VAR 0 2
6856: PPUSH
6857: LD_VAR 0 1
6861: PUSH
6862: LD_VAR 0 3
6866: ARRAY
6867: PPUSH
6868: CALL_OW 74
6872: PPUSH
6873: CALL_OW 115
6877: GO 6820
6879: POP
6880: POP
// end ; end_of_file
6881: PPOPN 3
6883: END
// export ru_dow , gorki ; export function PrepareRussian ; var un , i , filter , team ; begin
6884: LD_INT 0
6886: PPUSH
6887: PPUSH
6888: PPUSH
6889: PPUSH
6890: PPUSH
// Your_Side := 3 ;
6891: LD_ADDR_OWVAR 2
6895: PUSH
6896: LD_INT 3
6898: ST_TO_ADDR
// ChangeSideFog ( 3 , 3 ) ;
6899: LD_INT 3
6901: PPUSH
6902: LD_INT 3
6904: PPUSH
6905: CALL_OW 343
// ResetFog ;
6909: CALL_OW 335
// uc_side := 6 ;
6913: LD_ADDR_OWVAR 20
6917: PUSH
6918: LD_INT 6
6920: ST_TO_ADDR
// uc_nation := 3 ;
6921: LD_ADDR_OWVAR 21
6925: PUSH
6926: LD_INT 3
6928: ST_TO_ADDR
// hc_gallery := ru ;
6929: LD_ADDR_OWVAR 33
6933: PUSH
6934: LD_STRING ru
6936: ST_TO_ADDR
// hc_face_number := 1 ;
6937: LD_ADDR_OWVAR 34
6941: PUSH
6942: LD_INT 1
6944: ST_TO_ADDR
// hc_name := J. I. Gorki ;
6945: LD_ADDR_OWVAR 26
6949: PUSH
6950: LD_STRING J. I. Gorki
6952: ST_TO_ADDR
// hc_class := 3 ;
6953: LD_ADDR_OWVAR 28
6957: PUSH
6958: LD_INT 3
6960: ST_TO_ADDR
// hc_sex := sex_male ;
6961: LD_ADDR_OWVAR 27
6965: PUSH
6966: LD_INT 1
6968: ST_TO_ADDR
// gorki := CreateHuman ;
6969: LD_ADDR_EXP 19
6973: PUSH
6974: CALL_OW 44
6978: ST_TO_ADDR
// uc_side := 3 ;
6979: LD_ADDR_OWVAR 20
6983: PUSH
6984: LD_INT 3
6986: ST_TO_ADDR
// uc_nation := 3 ;
6987: LD_ADDR_OWVAR 21
6991: PUSH
6992: LD_INT 3
6994: ST_TO_ADDR
// hc_importance := 100 ;
6995: LD_ADDR_OWVAR 32
6999: PUSH
7000: LD_INT 100
7002: ST_TO_ADDR
// hc_name :=  ;
7003: LD_ADDR_OWVAR 26
7007: PUSH
7008: LD_STRING 
7010: ST_TO_ADDR
// hc_gallery :=  ;
7011: LD_ADDR_OWVAR 33
7015: PUSH
7016: LD_STRING 
7018: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , game_skill + 3 ) ;
7019: LD_INT 1
7021: PPUSH
7022: LD_INT 1
7024: PPUSH
7025: LD_EXP 3
7029: PUSH
7030: LD_INT 3
7032: PLUS
7033: PPUSH
7034: CALL_OW 380
// ru_dow := CreateHuman ;
7038: LD_ADDR_EXP 18
7042: PUSH
7043: CALL_OW 44
7047: ST_TO_ADDR
// hc_importance := 0 ;
7048: LD_ADDR_OWVAR 32
7052: PUSH
7053: LD_INT 0
7055: ST_TO_ADDR
// for i = 1 to 20 do
7056: LD_ADDR_VAR 0 3
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 20
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7132
// begin uc_side := 3 ;
7072: LD_ADDR_OWVAR 20
7076: PUSH
7077: LD_INT 3
7079: ST_TO_ADDR
// uc_nation := 3 ;
7080: LD_ADDR_OWVAR 21
7084: PUSH
7085: LD_INT 3
7087: ST_TO_ADDR
// un := CreateHumanWithClass ( Rand ( 1 , 4 ) , game_skill ) ;
7088: LD_ADDR_VAR 0 2
7092: PUSH
7093: LD_INT 1
7095: PPUSH
7096: LD_INT 4
7098: PPUSH
7099: CALL_OW 12
7103: PPUSH
7104: LD_EXP 3
7108: PPUSH
7109: CALL 9174 0 2
7113: ST_TO_ADDR
// filter := filter ^ un ;
7114: LD_ADDR_VAR 0 4
7118: PUSH
7119: LD_VAR 0 4
7123: PUSH
7124: LD_VAR 0 2
7128: ADD
7129: ST_TO_ADDR
// end ;
7130: GO 7069
7132: POP
7133: POP
// team := CharacterSelection ( text , [ 9 , 8 , 7 ] [ game_diff ] , [ 9 , 8 , 7 ] [ game_diff ] , [ sel_change_class , ru_dow , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , [ class_engineer , 1 ] , [ class_scientistic , 1 ] , [ class_bazooker , 0 , [ 6 , 4 , 3 ] [ game_diff ] ] ] ) ;
7134: LD_ADDR_VAR 0 5
7138: PUSH
7139: LD_STRING text
7141: PPUSH
7142: LD_INT 9
7144: PUSH
7145: LD_INT 8
7147: PUSH
7148: LD_INT 7
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: PUSH
7156: LD_EXP 2
7160: ARRAY
7161: PPUSH
7162: LD_INT 9
7164: PUSH
7165: LD_INT 8
7167: PUSH
7168: LD_INT 7
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: PUSH
7176: LD_EXP 2
7180: ARRAY
7181: PPUSH
7182: LD_INT -5
7184: PUSH
7185: LD_EXP 18
7189: PUSH
7190: LD_INT -3
7192: PUSH
7193: LD_INT -2
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: LIST
7200: LIST
7201: PUSH
7202: LD_VAR 0 4
7206: ADD
7207: PPUSH
7208: LD_INT 1
7210: PUSH
7211: LD_INT 3
7213: PUSH
7214: LD_INT 2
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 4
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 9
7236: PUSH
7237: LD_INT 0
7239: PUSH
7240: LD_INT 6
7242: PUSH
7243: LD_INT 4
7245: PUSH
7246: LD_INT 3
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_EXP 2
7258: ARRAY
7259: PUSH
7260: EMPTY
7261: LIST
7262: LIST
7263: LIST
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 42
7276: ST_TO_ADDR
// team := team ^ ru_dow ;
7277: LD_ADDR_VAR 0 5
7281: PUSH
7282: LD_VAR 0 5
7286: PUSH
7287: LD_EXP 18
7291: ADD
7292: ST_TO_ADDR
// for i = 1 to team do
7293: LD_ADDR_VAR 0 3
7297: PUSH
7298: DOUBLE
7299: LD_INT 1
7301: DEC
7302: ST_TO_ADDR
7303: LD_VAR 0 5
7307: PUSH
7308: FOR_TO
7309: IFFALSE 7334
// PlaceUnitArea ( team [ i ] , south_spawn , false ) ;
7311: LD_VAR 0 5
7315: PUSH
7316: LD_VAR 0 3
7320: ARRAY
7321: PPUSH
7322: LD_INT 5
7324: PPUSH
7325: LD_INT 0
7327: PPUSH
7328: CALL_OW 49
7332: GO 7308
7334: POP
7335: POP
// end ;
7336: LD_VAR 0 1
7340: RET
// every 0 0$01 trigger GetSide ( jota_base ) = 3 do var area ;
7341: LD_INT 1
7343: PPUSH
7344: CALL_OW 255
7348: PUSH
7349: LD_INT 3
7351: EQUAL
7352: IFFALSE 7462
7354: GO 7356
7356: DISABLE
7357: LD_INT 0
7359: PPUSH
// begin depot_captured := true ;
7360: LD_ADDR_EXP 8
7364: PUSH
7365: LD_INT 1
7367: ST_TO_ADDR
// ChangeMissionObjectives ( GType2b ) ;
7368: LD_STRING GType2b
7370: PPUSH
7371: CALL_OW 337
// Say ( ru_dow , D-rudow2 ) ;
7375: LD_EXP 18
7379: PPUSH
7380: LD_STRING D-rudow2
7382: PPUSH
7383: CALL_OW 88
// SayRadio ( gorki , D-gorky2 ) ;
7387: LD_EXP 19
7391: PPUSH
7392: LD_STRING D-gorky2
7394: PPUSH
7395: CALL_OW 94
// while ( true ) do
7399: LD_INT 1
7401: IFFALSE 7462
// begin Wait ( Rand ( 6 6$20 , 9 9$31 ) ) ;
7403: LD_INT 13300
7405: PPUSH
7406: LD_INT 19985
7408: PPUSH
7409: CALL_OW 12
7413: PPUSH
7414: CALL_OW 67
// area := [ north_spawn , south_spawn ] ;
7418: LD_ADDR_VAR 0 1
7422: PUSH
7423: LD_INT 6
7425: PUSH
7426: LD_INT 5
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: ST_TO_ADDR
// AmericanAttack ( 1 , enemy_count , enemy_typ , [ north_spawn , south_spawn ] ) ;
7433: LD_INT 1
7435: PPUSH
7436: LD_EXP 15
7440: PPUSH
7441: LD_EXP 16
7445: PPUSH
7446: LD_INT 6
7448: PUSH
7449: LD_INT 5
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PPUSH
7456: CALL 5786 0 4
// end ;
7460: GO 7399
// end ;
7462: PPOPN 1
7464: END
// every 1 1$30 trigger game_type = 2 do
7465: LD_EXP 1
7469: PUSH
7470: LD_INT 2
7472: EQUAL
7473: IFFALSE 7618
7475: GO 7477
7477: DISABLE
// begin enable ;
7478: ENABLE
// if timer <= 45 45$00 then
7479: LD_EXP 6
7483: PUSH
7484: LD_INT 94500
7486: LESSEQUAL
7487: IFFALSE 7522
// begin enemy_count := [ 5 , 6 , 7 ] [ game_diff ] ;
7489: LD_ADDR_EXP 15
7493: PUSH
7494: LD_INT 5
7496: PUSH
7497: LD_INT 6
7499: PUSH
7500: LD_INT 7
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: PUSH
7508: LD_EXP 2
7512: ARRAY
7513: ST_TO_ADDR
// enemy_typ := 1 ;
7514: LD_ADDR_EXP 16
7518: PUSH
7519: LD_INT 1
7521: ST_TO_ADDR
// end ; if timer > 60 60$00 and timer <= 80 80$00 then
7522: LD_EXP 6
7526: PUSH
7527: LD_INT 126000
7529: GREATER
7530: PUSH
7531: LD_EXP 6
7535: PUSH
7536: LD_INT 168000
7538: LESSEQUAL
7539: AND
7540: IFFALSE 7575
// begin enemy_count := [ 6 , 8 , 9 ] [ game_diff ] ;
7542: LD_ADDR_EXP 15
7546: PUSH
7547: LD_INT 6
7549: PUSH
7550: LD_INT 8
7552: PUSH
7553: LD_INT 9
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: LD_EXP 2
7565: ARRAY
7566: ST_TO_ADDR
// enemy_typ := 2 ;
7567: LD_ADDR_EXP 16
7571: PUSH
7572: LD_INT 2
7574: ST_TO_ADDR
// end ; if timer > 80 80$00 then
7575: LD_EXP 6
7579: PUSH
7580: LD_INT 168000
7582: GREATER
7583: IFFALSE 7618
// begin enemy_count := [ 8 , 9 , 10 ] [ game_diff ] ;
7585: LD_ADDR_EXP 15
7589: PUSH
7590: LD_INT 8
7592: PUSH
7593: LD_INT 9
7595: PUSH
7596: LD_INT 10
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_EXP 2
7608: ARRAY
7609: ST_TO_ADDR
// enemy_typ := 3 ;
7610: LD_ADDR_EXP 16
7614: PUSH
7615: LD_INT 3
7617: ST_TO_ADDR
// end ; end ;
7618: END
// export farmer ; every 20 20$00 trigger game_type = 2 do
7619: LD_EXP 1
7623: PUSH
7624: LD_INT 2
7626: EQUAL
7627: IFFALSE 7752
7629: GO 7631
7631: DISABLE
// begin LegionAttack ( 8 , enemy_count , 1 , north_spawn ) ;
7632: LD_INT 8
7634: PPUSH
7635: LD_EXP 15
7639: PPUSH
7640: LD_INT 1
7642: PPUSH
7643: LD_INT 6
7645: PPUSH
7646: CALL 9823 0 4
// Wait ( 20 20$00 ) ;
7650: LD_INT 42000
7652: PPUSH
7653: CALL_OW 67
// LegionAttack ( 8 , enemy_count , 2 , north_spawn ) ;
7657: LD_INT 8
7659: PPUSH
7660: LD_EXP 15
7664: PPUSH
7665: LD_INT 2
7667: PPUSH
7668: LD_INT 6
7670: PPUSH
7671: CALL 9823 0 4
// Wait ( 4 4$00 ) ;
7675: LD_INT 8400
7677: PPUSH
7678: CALL_OW 67
// uc_side := 8 ;
7682: LD_ADDR_OWVAR 20
7686: PUSH
7687: LD_INT 8
7689: ST_TO_ADDR
// uc_nation := 2 ;
7690: LD_ADDR_OWVAR 21
7694: PUSH
7695: LD_INT 2
7697: ST_TO_ADDR
// hc_class := 1 ;
7698: LD_ADDR_OWVAR 28
7702: PUSH
7703: LD_INT 1
7705: ST_TO_ADDR
// hc_gallery := sandar ;
7706: LD_ADDR_OWVAR 33
7710: PUSH
7711: LD_STRING sandar
7713: ST_TO_ADDR
// hc_face_number := 4 ;
7714: LD_ADDR_OWVAR 34
7718: PUSH
7719: LD_INT 4
7721: ST_TO_ADDR
// hc_sex := sex_male ;
7722: LD_ADDR_OWVAR 27
7726: PUSH
7727: LD_INT 1
7729: ST_TO_ADDR
// farmer := CreateHuman ;
7730: LD_ADDR_EXP 20
7734: PUSH
7735: CALL_OW 44
7739: ST_TO_ADDR
// SayRadio ( farmer , D-farmer ) ;
7740: LD_EXP 20
7744: PPUSH
7745: LD_STRING D-farmer
7747: PPUSH
7748: CALL_OW 94
// end ;
7752: END
// every 0 0$01 trigger game_type = 1 do var filter , enemy , i ;
7753: LD_EXP 1
7757: PUSH
7758: LD_INT 1
7760: EQUAL
7761: IFFALSE 7916
7763: GO 7765
7765: DISABLE
7766: LD_INT 0
7768: PPUSH
7769: PPUSH
7770: PPUSH
// begin enable ;
7771: ENABLE
// filter := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
7772: LD_ADDR_VAR 0 1
7776: PUSH
7777: LD_INT 2
7779: PUSH
7780: LD_INT 22
7782: PUSH
7783: LD_INT 3
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 22
7792: PUSH
7793: LD_INT 6
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 2 ] ] ) ;
7810: LD_ADDR_VAR 0 2
7814: PUSH
7815: LD_INT 2
7817: PUSH
7818: LD_INT 22
7820: PUSH
7821: LD_INT 1
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PUSH
7828: LD_INT 22
7830: PUSH
7831: LD_INT 2
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 69
7847: ST_TO_ADDR
// if filter > 0 then
7848: LD_VAR 0 1
7852: PUSH
7853: LD_INT 0
7855: GREATER
7856: IFFALSE 7916
// for i = 1 to filter do
7858: LD_ADDR_VAR 0 3
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 1
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7914
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
7876: LD_VAR 0 1
7880: PUSH
7881: LD_VAR 0 3
7885: ARRAY
7886: PPUSH
7887: LD_VAR 0 2
7891: PPUSH
7892: LD_VAR 0 1
7896: PUSH
7897: LD_VAR 0 3
7901: ARRAY
7902: PPUSH
7903: CALL_OW 74
7907: PPUSH
7908: CALL_OW 115
7912: GO 7873
7914: POP
7915: POP
// end ;
7916: PPOPN 3
7918: END
// export function RussianAttack ( side , num , typ , list ) ; var i , un , filter , veh , chassis , weapon , f ; begin
7919: LD_INT 0
7921: PPUSH
7922: PPUSH
7923: PPUSH
7924: PPUSH
7925: PPUSH
7926: PPUSH
7927: PPUSH
7928: PPUSH
// Randomize ;
7929: CALL_OW 10
// uc_side := side ;
7933: LD_ADDR_OWVAR 20
7937: PUSH
7938: LD_VAR 0 1
7942: ST_TO_ADDR
// uc_nation := nation_russian ;
7943: LD_ADDR_OWVAR 21
7947: PUSH
7948: LD_INT 3
7950: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] ;
7951: LD_ADDR_VAR 0 10
7955: PUSH
7956: LD_INT 22
7958: PUSH
7959: LD_INT 24
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: ST_TO_ADDR
// weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket ] ;
7966: LD_ADDR_VAR 0 11
7970: PUSH
7971: LD_INT 42
7973: PUSH
7974: LD_INT 43
7976: PUSH
7977: LD_INT 44
7979: PUSH
7980: LD_INT 46
7982: PUSH
7983: LD_INT 45
7985: PUSH
7986: LD_INT 47
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: LIST
7996: ST_TO_ADDR
// case typ of 1 :
7997: LD_VAR 0 3
8001: PUSH
8002: LD_INT 1
8004: DOUBLE
8005: EQUAL
8006: IFTRUE 8010
8008: GO 8204
8010: POP
// begin for i = 1 to num do
8011: LD_ADDR_VAR 0 6
8015: PUSH
8016: DOUBLE
8017: LD_INT 1
8019: DEC
8020: ST_TO_ADDR
8021: LD_VAR 0 2
8025: PUSH
8026: FOR_TO
8027: IFFALSE 8200
// begin vc_chassis := chassis [ 1 ] ;
8029: LD_ADDR_OWVAR 37
8033: PUSH
8034: LD_VAR 0 10
8038: PUSH
8039: LD_INT 1
8041: ARRAY
8042: ST_TO_ADDR
// vc_engine := engine_combustion ;
8043: LD_ADDR_OWVAR 39
8047: PUSH
8048: LD_INT 1
8050: ST_TO_ADDR
// vc_control := control_manual ;
8051: LD_ADDR_OWVAR 38
8055: PUSH
8056: LD_INT 1
8058: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
8059: LD_ADDR_OWVAR 40
8063: PUSH
8064: LD_VAR 0 11
8068: PUSH
8069: LD_INT 1
8071: PPUSH
8072: LD_INT 3
8074: PPUSH
8075: CALL_OW 12
8079: ARRAY
8080: ST_TO_ADDR
// veh := CreateVehicle ;
8081: LD_ADDR_VAR 0 9
8085: PUSH
8086: CALL_OW 45
8090: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
8091: LD_ADDR_VAR 0 12
8095: PUSH
8096: LD_INT 1
8098: PPUSH
8099: LD_INT 2
8101: PPUSH
8102: CALL_OW 12
8106: ST_TO_ADDR
// if f = 1 then
8107: LD_VAR 0 12
8111: PUSH
8112: LD_INT 1
8114: EQUAL
8115: IFFALSE 8131
// SetDir ( veh , 3 ) else
8117: LD_VAR 0 9
8121: PPUSH
8122: LD_INT 3
8124: PPUSH
8125: CALL_OW 233
8129: GO 8143
// SetDir ( veh , 1 ) ;
8131: LD_VAR 0 9
8135: PPUSH
8136: LD_INT 1
8138: PPUSH
8139: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
8143: LD_VAR 0 9
8147: PPUSH
8148: LD_VAR 0 4
8152: PUSH
8153: LD_VAR 0 12
8157: ARRAY
8158: PPUSH
8159: LD_INT 0
8161: PPUSH
8162: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
8166: LD_ADDR_VAR 0 7
8170: PUSH
8171: LD_INT 1
8173: PPUSH
8174: LD_EXP 4
8178: PPUSH
8179: CALL 9174 0 2
8183: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8184: LD_VAR 0 7
8188: PPUSH
8189: LD_VAR 0 9
8193: PPUSH
8194: CALL_OW 52
// end ;
8198: GO 8026
8200: POP
8201: POP
// end ; 2 :
8202: GO 8746
8204: LD_INT 2
8206: DOUBLE
8207: EQUAL
8208: IFTRUE 8212
8210: GO 8509
8212: POP
// begin for i = 1 to num do
8213: LD_ADDR_VAR 0 6
8217: PUSH
8218: DOUBLE
8219: LD_INT 1
8221: DEC
8222: ST_TO_ADDR
8223: LD_VAR 0 2
8227: PUSH
8228: FOR_TO
8229: IFFALSE 8444
// begin vc_chassis := chassis [ Rand ( 1 , 2 ) ] ;
8231: LD_ADDR_OWVAR 37
8235: PUSH
8236: LD_VAR 0 10
8240: PUSH
8241: LD_INT 1
8243: PPUSH
8244: LD_INT 2
8246: PPUSH
8247: CALL_OW 12
8251: ARRAY
8252: ST_TO_ADDR
// vc_engine := engine_combustion ;
8253: LD_ADDR_OWVAR 39
8257: PUSH
8258: LD_INT 1
8260: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ Rand ( 1 , 2 ) ] ;
8261: LD_ADDR_OWVAR 38
8265: PUSH
8266: LD_INT 1
8268: PUSH
8269: LD_INT 3
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: PUSH
8276: LD_INT 1
8278: PPUSH
8279: LD_INT 2
8281: PPUSH
8282: CALL_OW 12
8286: ARRAY
8287: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
8288: LD_ADDR_OWVAR 40
8292: PUSH
8293: LD_VAR 0 11
8297: PUSH
8298: LD_INT 1
8300: PPUSH
8301: LD_INT 3
8303: PPUSH
8304: CALL_OW 12
8308: ARRAY
8309: ST_TO_ADDR
// veh := CreateVehicle ;
8310: LD_ADDR_VAR 0 9
8314: PUSH
8315: CALL_OW 45
8319: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
8320: LD_ADDR_VAR 0 12
8324: PUSH
8325: LD_INT 1
8327: PPUSH
8328: LD_INT 2
8330: PPUSH
8331: CALL_OW 12
8335: ST_TO_ADDR
// if f = 1 then
8336: LD_VAR 0 12
8340: PUSH
8341: LD_INT 1
8343: EQUAL
8344: IFFALSE 8360
// SetDir ( veh , 3 ) else
8346: LD_VAR 0 9
8350: PPUSH
8351: LD_INT 3
8353: PPUSH
8354: CALL_OW 233
8358: GO 8372
// SetDir ( veh , 1 ) ;
8360: LD_VAR 0 9
8364: PPUSH
8365: LD_INT 1
8367: PPUSH
8368: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
8372: LD_VAR 0 9
8376: PPUSH
8377: LD_VAR 0 4
8381: PUSH
8382: LD_VAR 0 12
8386: ARRAY
8387: PPUSH
8388: LD_INT 0
8390: PPUSH
8391: CALL_OW 49
// if GetControl ( veh ) = control_manual then
8395: LD_VAR 0 9
8399: PPUSH
8400: CALL_OW 263
8404: PUSH
8405: LD_INT 1
8407: EQUAL
8408: IFFALSE 8442
// begin un := CreateHumanWithClass ( 1 , game_eskill ) ;
8410: LD_ADDR_VAR 0 7
8414: PUSH
8415: LD_INT 1
8417: PPUSH
8418: LD_EXP 4
8422: PPUSH
8423: CALL 9174 0 2
8427: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8428: LD_VAR 0 7
8432: PPUSH
8433: LD_VAR 0 9
8437: PPUSH
8438: CALL_OW 52
// end ; end ;
8442: GO 8228
8444: POP
8445: POP
// for i = 1 to 2 do
8446: LD_ADDR_VAR 0 6
8450: PUSH
8451: DOUBLE
8452: LD_INT 1
8454: DEC
8455: ST_TO_ADDR
8456: LD_INT 2
8458: PUSH
8459: FOR_TO
8460: IFFALSE 8505
// begin un := CreateHumanWithClass ( class_bazooker , game_eskill ) ;
8462: LD_ADDR_VAR 0 7
8466: PUSH
8467: LD_INT 9
8469: PPUSH
8470: LD_EXP 4
8474: PPUSH
8475: CALL 9174 0 2
8479: ST_TO_ADDR
// PlaceUnitArea ( un , list [ f ] , false ) ;
8480: LD_VAR 0 7
8484: PPUSH
8485: LD_VAR 0 4
8489: PUSH
8490: LD_VAR 0 12
8494: ARRAY
8495: PPUSH
8496: LD_INT 0
8498: PPUSH
8499: CALL_OW 49
// end ;
8503: GO 8459
8505: POP
8506: POP
// end ; 3 :
8507: GO 8746
8509: LD_INT 3
8511: DOUBLE
8512: EQUAL
8513: IFTRUE 8517
8515: GO 8745
8517: POP
// begin for i = 1 to num do
8518: LD_ADDR_VAR 0 6
8522: PUSH
8523: DOUBLE
8524: LD_INT 1
8526: DEC
8527: ST_TO_ADDR
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_TO
8534: IFFALSE 8741
// begin vc_chassis := chassis [ 2 ] ;
8536: LD_ADDR_OWVAR 37
8540: PUSH
8541: LD_VAR 0 10
8545: PUSH
8546: LD_INT 2
8548: ARRAY
8549: ST_TO_ADDR
// vc_engine := engine_combustion ;
8550: LD_ADDR_OWVAR 39
8554: PUSH
8555: LD_INT 1
8557: ST_TO_ADDR
// vc_control := [ control_computer , control_manual ] [ Rand ( 1 , 2 ) ] ;
8558: LD_ADDR_OWVAR 38
8562: PUSH
8563: LD_INT 3
8565: PUSH
8566: LD_INT 1
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: LD_INT 1
8575: PPUSH
8576: LD_INT 2
8578: PPUSH
8579: CALL_OW 12
8583: ARRAY
8584: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 6 ) ] ;
8585: LD_ADDR_OWVAR 40
8589: PUSH
8590: LD_VAR 0 11
8594: PUSH
8595: LD_INT 3
8597: PPUSH
8598: LD_INT 6
8600: PPUSH
8601: CALL_OW 12
8605: ARRAY
8606: ST_TO_ADDR
// veh := CreateVehicle ;
8607: LD_ADDR_VAR 0 9
8611: PUSH
8612: CALL_OW 45
8616: ST_TO_ADDR
// f := Rand ( 1 , 2 ) ;
8617: LD_ADDR_VAR 0 12
8621: PUSH
8622: LD_INT 1
8624: PPUSH
8625: LD_INT 2
8627: PPUSH
8628: CALL_OW 12
8632: ST_TO_ADDR
// if f = 1 then
8633: LD_VAR 0 12
8637: PUSH
8638: LD_INT 1
8640: EQUAL
8641: IFFALSE 8657
// SetDir ( veh , 3 ) else
8643: LD_VAR 0 9
8647: PPUSH
8648: LD_INT 3
8650: PPUSH
8651: CALL_OW 233
8655: GO 8669
// SetDir ( veh , 1 ) ;
8657: LD_VAR 0 9
8661: PPUSH
8662: LD_INT 1
8664: PPUSH
8665: CALL_OW 233
// PlaceUnitArea ( veh , list [ f ] , false ) ;
8669: LD_VAR 0 9
8673: PPUSH
8674: LD_VAR 0 4
8678: PUSH
8679: LD_VAR 0 12
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: CALL_OW 49
// if GetControl ( veh ) = control_manual then
8692: LD_VAR 0 9
8696: PPUSH
8697: CALL_OW 263
8701: PUSH
8702: LD_INT 1
8704: EQUAL
8705: IFFALSE 8739
// begin un := CreateHumanWithClass ( 1 , game_eskill ) ;
8707: LD_ADDR_VAR 0 7
8711: PUSH
8712: LD_INT 1
8714: PPUSH
8715: LD_EXP 4
8719: PPUSH
8720: CALL 9174 0 2
8724: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
8725: LD_VAR 0 7
8729: PPUSH
8730: LD_VAR 0 9
8734: PPUSH
8735: CALL_OW 52
// end ; end ;
8739: GO 8533
8741: POP
8742: POP
// end ; end ;
8743: GO 8746
8745: POP
// end ; end_of_file
8746: LD_VAR 0 5
8750: RET
// every 0 0$01 do
8751: GO 8753
8753: DISABLE
// PrepareAnimals ( 6 + game_diff , 5 , 4 , nature_area ) ; end_of_file
8754: LD_INT 6
8756: PUSH
8757: LD_EXP 2
8761: PLUS
8762: PPUSH
8763: LD_INT 5
8765: PPUSH
8766: LD_INT 4
8768: PPUSH
8769: LD_INT 8
8771: PPUSH
8772: CALL 8777 0 4
8776: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
8777: LD_INT 0
8779: PPUSH
8780: PPUSH
8781: PPUSH
8782: PPUSH
8783: PPUSH
// uc_nation = nation_nature ;
8784: LD_ADDR_OWVAR 21
8788: PUSH
8789: LD_INT 0
8791: ST_TO_ADDR
// uc_side = 0 ;
8792: LD_ADDR_OWVAR 20
8796: PUSH
8797: LD_INT 0
8799: ST_TO_ADDR
// l = 0 ;
8800: LD_ADDR_VAR 0 6
8804: PUSH
8805: LD_INT 0
8807: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
8808: LD_ADDR_OWVAR 24
8812: PUSH
8813: LD_INT 0
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
8824: LD_ADDR_OWVAR 35
8828: PUSH
8829: LD_INT 5
8831: NEG
8832: PPUSH
8833: LD_INT 5
8835: PPUSH
8836: CALL_OW 12
8840: ST_TO_ADDR
// hc_gallery =  ;
8841: LD_ADDR_OWVAR 33
8845: PUSH
8846: LD_STRING 
8848: ST_TO_ADDR
// hc_class = class_apeman ;
8849: LD_ADDR_OWVAR 28
8853: PUSH
8854: LD_INT 12
8856: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
8857: LD_ADDR_OWVAR 29
8861: PUSH
8862: LD_INT 11
8864: PPUSH
8865: LD_INT 13
8867: PPUSH
8868: CALL_OW 12
8872: PUSH
8873: LD_INT 10
8875: PPUSH
8876: LD_INT 11
8878: PPUSH
8879: CALL_OW 12
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: ST_TO_ADDR
// hc_sex = sex_male ;
8888: LD_ADDR_OWVAR 27
8892: PUSH
8893: LD_INT 1
8895: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
8896: LD_ADDR_OWVAR 31
8900: PUSH
8901: LD_INT 0
8903: PPUSH
8904: LD_INT 2
8906: PPUSH
8907: CALL_OW 12
8911: PUSH
8912: LD_INT 0
8914: PUSH
8915: LD_INT 0
8917: PUSH
8918: LD_INT 0
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: ST_TO_ADDR
// apeman = CreateHuman ;
8927: LD_ADDR_VAR 0 7
8931: PUSH
8932: CALL_OW 44
8936: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8937: LD_VAR 0 7
8941: PPUSH
8942: LD_VAR 0 4
8946: PPUSH
8947: LD_INT 0
8949: PPUSH
8950: CALL_OW 49
// l = l + 1 ;
8954: LD_ADDR_VAR 0 6
8958: PUSH
8959: LD_VAR 0 6
8963: PUSH
8964: LD_INT 1
8966: PLUS
8967: ST_TO_ADDR
// end until l = num1 ;
8968: LD_VAR 0 6
8972: PUSH
8973: LD_VAR 0 1
8977: EQUAL
8978: IFFALSE 8808
// l = 0 ;
8980: LD_ADDR_VAR 0 6
8984: PUSH
8985: LD_INT 0
8987: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8988: LD_ADDR_OWVAR 35
8992: PUSH
8993: LD_INT 0
8995: PPUSH
8996: LD_INT 25
8998: PPUSH
8999: CALL_OW 12
9003: ST_TO_ADDR
// hc_class = class_tiger ;
9004: LD_ADDR_OWVAR 28
9008: PUSH
9009: LD_INT 14
9011: ST_TO_ADDR
// hc_sex = sex_male ;
9012: LD_ADDR_OWVAR 27
9016: PUSH
9017: LD_INT 1
9019: ST_TO_ADDR
// hc_gallery = sandnature ;
9020: LD_ADDR_OWVAR 33
9024: PUSH
9025: LD_STRING sandnature
9027: ST_TO_ADDR
// hc_face_number = 3 ;
9028: LD_ADDR_OWVAR 34
9032: PUSH
9033: LD_INT 3
9035: ST_TO_ADDR
// tiger = CreateHuman ;
9036: LD_ADDR_VAR 0 8
9040: PUSH
9041: CALL_OW 44
9045: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
9046: LD_VAR 0 8
9050: PPUSH
9051: LD_VAR 0 4
9055: PPUSH
9056: LD_INT 0
9058: PPUSH
9059: CALL_OW 49
// l = l + 1 ;
9063: LD_ADDR_VAR 0 6
9067: PUSH
9068: LD_VAR 0 6
9072: PUSH
9073: LD_INT 1
9075: PLUS
9076: ST_TO_ADDR
// end until l = num2 ;
9077: LD_VAR 0 6
9081: PUSH
9082: LD_VAR 0 2
9086: EQUAL
9087: IFFALSE 8988
// l = 0 ;
9089: LD_ADDR_VAR 0 6
9093: PUSH
9094: LD_INT 0
9096: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
9097: LD_ADDR_OWVAR 28
9101: PUSH
9102: LD_INT 18
9104: ST_TO_ADDR
// hc_gallery = sandnature ;
9105: LD_ADDR_OWVAR 33
9109: PUSH
9110: LD_STRING sandnature
9112: ST_TO_ADDR
// hc_face_number = 1 ;
9113: LD_ADDR_OWVAR 34
9117: PUSH
9118: LD_INT 1
9120: ST_TO_ADDR
// bird = CreateHuman ;
9121: LD_ADDR_VAR 0 9
9125: PUSH
9126: CALL_OW 44
9130: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
9131: LD_VAR 0 9
9135: PPUSH
9136: LD_INT 0
9138: PPUSH
9139: CALL_OW 51
// l = l + 1 ;
9143: LD_ADDR_VAR 0 6
9147: PUSH
9148: LD_VAR 0 6
9152: PUSH
9153: LD_INT 1
9155: PLUS
9156: ST_TO_ADDR
// end until l = num3 ;
9157: LD_VAR 0 6
9161: PUSH
9162: LD_VAR 0 3
9166: EQUAL
9167: IFFALSE 9097
// end ;
9169: LD_VAR 0 5
9173: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
9174: LD_INT 0
9176: PPUSH
9177: PPUSH
9178: PPUSH
9179: PPUSH
9180: PPUSH
9181: PPUSH
// hc_class := clas ;
9182: LD_ADDR_OWVAR 28
9186: PUSH
9187: LD_VAR 0 1
9191: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
9192: LD_ADDR_VAR 0 4
9196: PUSH
9197: LD_VAR 0 2
9201: PUSH
9202: LD_INT 1
9204: NEG
9205: PPUSH
9206: LD_INT 1
9208: PPUSH
9209: CALL_OW 12
9213: PLUS
9214: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
9215: LD_ADDR_VAR 0 5
9219: PUSH
9220: LD_VAR 0 2
9224: PUSH
9225: LD_INT 1
9227: NEG
9228: PPUSH
9229: LD_INT 1
9231: PPUSH
9232: CALL_OW 12
9236: PLUS
9237: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
9238: LD_ADDR_VAR 0 6
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_INT 1
9250: NEG
9251: PPUSH
9252: LD_INT 1
9254: PPUSH
9255: CALL_OW 12
9259: PLUS
9260: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
9261: LD_ADDR_VAR 0 7
9265: PUSH
9266: LD_VAR 0 2
9270: PUSH
9271: LD_INT 1
9273: NEG
9274: PPUSH
9275: LD_INT 1
9277: PPUSH
9278: CALL_OW 12
9282: PLUS
9283: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
9284: LD_VAR 0 1
9288: PUSH
9289: LD_INT 1
9291: EQUAL
9292: PUSH
9293: LD_VAR 0 1
9297: PUSH
9298: LD_INT 9
9300: EQUAL
9301: OR
9302: PUSH
9303: LD_VAR 0 1
9307: PUSH
9308: LD_INT 5
9310: EQUAL
9311: OR
9312: PUSH
9313: LD_VAR 0 1
9317: PUSH
9318: LD_INT 8
9320: EQUAL
9321: OR
9322: IFFALSE 9347
// bonus := [ 2 , 0 , 0 , 0 ] ;
9324: LD_ADDR_VAR 0 8
9328: PUSH
9329: LD_INT 2
9331: PUSH
9332: LD_INT 0
9334: PUSH
9335: LD_INT 0
9337: PUSH
9338: LD_INT 0
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: ST_TO_ADDR
// if clas = 2 then
9347: LD_VAR 0 1
9351: PUSH
9352: LD_INT 2
9354: EQUAL
9355: IFFALSE 9380
// bonus := [ 0 , 2 , 0 , 0 ] ;
9357: LD_ADDR_VAR 0 8
9361: PUSH
9362: LD_INT 0
9364: PUSH
9365: LD_INT 2
9367: PUSH
9368: LD_INT 0
9370: PUSH
9371: LD_INT 0
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: ST_TO_ADDR
// if clas = 3 then
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 3
9387: EQUAL
9388: IFFALSE 9413
// bonus := [ 0 , 0 , 2 , 0 ] ;
9390: LD_ADDR_VAR 0 8
9394: PUSH
9395: LD_INT 0
9397: PUSH
9398: LD_INT 0
9400: PUSH
9401: LD_INT 2
9403: PUSH
9404: LD_INT 0
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: ST_TO_ADDR
// if clas = 4 then
9413: LD_VAR 0 1
9417: PUSH
9418: LD_INT 4
9420: EQUAL
9421: IFFALSE 9446
// bonus := [ 0 , 0 , 0 , 2 ] ;
9423: LD_ADDR_VAR 0 8
9427: PUSH
9428: LD_INT 0
9430: PUSH
9431: LD_INT 0
9433: PUSH
9434: LD_INT 0
9436: PUSH
9437: LD_INT 2
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
9446: LD_VAR 0 1
9450: PUSH
9451: LD_INT 4
9453: GREATER
9454: PUSH
9455: LD_VAR 0 1
9459: PUSH
9460: LD_INT 9
9462: NONEQUAL
9463: AND
9464: PUSH
9465: LD_VAR 0 1
9469: PUSH
9470: LD_INT 5
9472: NONEQUAL
9473: AND
9474: PUSH
9475: LD_VAR 0 1
9479: PUSH
9480: LD_INT 8
9482: NONEQUAL
9483: AND
9484: IFFALSE 9509
// bonus := [ 0 , 0 , 0 , 0 ] ;
9486: LD_ADDR_VAR 0 8
9490: PUSH
9491: LD_INT 0
9493: PUSH
9494: LD_INT 0
9496: PUSH
9497: LD_INT 0
9499: PUSH
9500: LD_INT 0
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
9509: LD_ADDR_OWVAR 30
9513: PUSH
9514: LD_INT 0
9516: PPUSH
9517: LD_INT 2
9519: PPUSH
9520: CALL_OW 12
9524: PUSH
9525: LD_INT 0
9527: PPUSH
9528: LD_INT 2
9530: PPUSH
9531: CALL_OW 12
9535: PUSH
9536: LD_INT 0
9538: PPUSH
9539: LD_INT 2
9541: PPUSH
9542: CALL_OW 12
9546: PUSH
9547: LD_INT 0
9549: PPUSH
9550: LD_INT 2
9552: PPUSH
9553: CALL_OW 12
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
9564: LD_ADDR_OWVAR 31
9568: PUSH
9569: LD_VAR 0 4
9573: PUSH
9574: LD_VAR 0 8
9578: PUSH
9579: LD_INT 1
9581: ARRAY
9582: PLUS
9583: PUSH
9584: LD_VAR 0 5
9588: PUSH
9589: LD_VAR 0 8
9593: PUSH
9594: LD_INT 2
9596: ARRAY
9597: PLUS
9598: PUSH
9599: LD_VAR 0 6
9603: PUSH
9604: LD_VAR 0 8
9608: PUSH
9609: LD_INT 3
9611: ARRAY
9612: PLUS
9613: PUSH
9614: LD_VAR 0 7
9618: PUSH
9619: LD_VAR 0 8
9623: PUSH
9624: LD_INT 4
9626: ARRAY
9627: PLUS
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: LIST
9633: LIST
9634: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
9635: LD_ADDR_OWVAR 27
9639: PUSH
9640: LD_INT 1
9642: PPUSH
9643: LD_INT 2
9645: PPUSH
9646: CALL_OW 12
9650: ST_TO_ADDR
// hc_gallery :=  ;
9651: LD_ADDR_OWVAR 33
9655: PUSH
9656: LD_STRING 
9658: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
9659: LD_ADDR_OWVAR 29
9663: PUSH
9664: LD_INT 8
9666: PPUSH
9667: LD_INT 12
9669: PPUSH
9670: CALL_OW 12
9674: PUSH
9675: LD_INT 9
9677: PPUSH
9678: LD_INT 11
9680: PPUSH
9681: CALL_OW 12
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: ST_TO_ADDR
// hc_name :=  ;
9690: LD_ADDR_OWVAR 26
9694: PUSH
9695: LD_STRING 
9697: ST_TO_ADDR
// result := CreateHuman ;
9698: LD_ADDR_VAR 0 3
9702: PUSH
9703: CALL_OW 44
9707: ST_TO_ADDR
// end ;
9708: LD_VAR 0 3
9712: RET
// export function CreateVehicleWithDriver ( chassis , engine , weapon , area , dir , lvl ) ; var veh ; begin
9713: LD_INT 0
9715: PPUSH
9716: PPUSH
// vc_chassis := chassis ;
9717: LD_ADDR_OWVAR 37
9721: PUSH
9722: LD_VAR 0 1
9726: ST_TO_ADDR
// vc_engine := engine ;
9727: LD_ADDR_OWVAR 39
9731: PUSH
9732: LD_VAR 0 2
9736: ST_TO_ADDR
// vc_weapon := weapon ;
9737: LD_ADDR_OWVAR 40
9741: PUSH
9742: LD_VAR 0 3
9746: ST_TO_ADDR
// vc_control := control_manual ;
9747: LD_ADDR_OWVAR 38
9751: PUSH
9752: LD_INT 1
9754: ST_TO_ADDR
// veh := CreateVehicle ;
9755: LD_ADDR_VAR 0 8
9759: PUSH
9760: CALL_OW 45
9764: ST_TO_ADDR
// SetDir ( veh , dir ) ;
9765: LD_VAR 0 8
9769: PPUSH
9770: LD_VAR 0 5
9774: PPUSH
9775: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
9779: LD_VAR 0 8
9783: PPUSH
9784: LD_VAR 0 4
9788: PPUSH
9789: LD_INT 0
9791: PPUSH
9792: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , lvl ) , veh ) ;
9796: LD_INT 3
9798: PPUSH
9799: LD_VAR 0 6
9803: PPUSH
9804: CALL 9174 0 2
9808: PPUSH
9809: LD_VAR 0 8
9813: PPUSH
9814: CALL_OW 52
// end ;
9818: LD_VAR 0 7
9822: RET
// export function LegionAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
9823: LD_INT 0
9825: PPUSH
9826: PPUSH
9827: PPUSH
9828: PPUSH
9829: PPUSH
9830: PPUSH
9831: PPUSH
// uc_side := side ;
9832: LD_ADDR_OWVAR 20
9836: PUSH
9837: LD_VAR 0 1
9841: ST_TO_ADDR
// uc_nation := nation_arabian ;
9842: LD_ADDR_OWVAR 21
9846: PUSH
9847: LD_INT 2
9849: ST_TO_ADDR
// chassis := [ ar_half_tracked ] ;
9850: LD_ADDR_VAR 0 10
9854: PUSH
9855: LD_INT 14
9857: PUSH
9858: EMPTY
9859: LIST
9860: ST_TO_ADDR
// weapon := [ ar_double_machine_gun , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] ;
9861: LD_ADDR_VAR 0 11
9865: PUSH
9866: LD_INT 24
9868: PUSH
9869: LD_INT 25
9871: PUSH
9872: LD_INT 27
9874: PUSH
9875: LD_INT 28
9877: PUSH
9878: LD_INT 29
9880: PUSH
9881: EMPTY
9882: LIST
9883: LIST
9884: LIST
9885: LIST
9886: LIST
9887: ST_TO_ADDR
// case typ of 1 :
9888: LD_VAR 0 3
9892: PUSH
9893: LD_INT 1
9895: DOUBLE
9896: EQUAL
9897: IFTRUE 9901
9899: GO 10073
9901: POP
// begin for i = 1 to num do
9902: LD_ADDR_VAR 0 6
9906: PUSH
9907: DOUBLE
9908: LD_INT 1
9910: DEC
9911: ST_TO_ADDR
9912: LD_VAR 0 2
9916: PUSH
9917: FOR_TO
9918: IFFALSE 10069
// begin vc_chassis := chassis [ 1 ] ;
9920: LD_ADDR_OWVAR 37
9924: PUSH
9925: LD_VAR 0 10
9929: PUSH
9930: LD_INT 1
9932: ARRAY
9933: ST_TO_ADDR
// vc_engine := engine_combustion ;
9934: LD_ADDR_OWVAR 39
9938: PUSH
9939: LD_INT 1
9941: ST_TO_ADDR
// vc_control := control_manual ;
9942: LD_ADDR_OWVAR 38
9946: PUSH
9947: LD_INT 1
9949: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 3 ) ] ;
9950: LD_ADDR_OWVAR 40
9954: PUSH
9955: LD_VAR 0 11
9959: PUSH
9960: LD_INT 1
9962: PPUSH
9963: LD_INT 3
9965: PPUSH
9966: CALL_OW 12
9970: ARRAY
9971: ST_TO_ADDR
// veh := CreateVehicle ;
9972: LD_ADDR_VAR 0 9
9976: PUSH
9977: CALL_OW 45
9981: ST_TO_ADDR
// if area = north_spawn then
9982: LD_VAR 0 4
9986: PUSH
9987: LD_INT 6
9989: EQUAL
9990: IFFALSE 10006
// SetDir ( veh , 3 ) else
9992: LD_VAR 0 9
9996: PPUSH
9997: LD_INT 3
9999: PPUSH
10000: CALL_OW 233
10004: GO 10018
// SetDir ( veh , 1 ) ;
10006: LD_VAR 0 9
10010: PPUSH
10011: LD_INT 1
10013: PPUSH
10014: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
10018: LD_VAR 0 9
10022: PPUSH
10023: LD_VAR 0 4
10027: PPUSH
10028: LD_INT 0
10030: PPUSH
10031: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
10035: LD_ADDR_VAR 0 7
10039: PUSH
10040: LD_INT 1
10042: PPUSH
10043: LD_EXP 4
10047: PPUSH
10048: CALL 9174 0 2
10052: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10053: LD_VAR 0 7
10057: PPUSH
10058: LD_VAR 0 9
10062: PPUSH
10063: CALL_OW 52
// end ;
10067: GO 9917
10069: POP
10070: POP
// end ; 2 :
10071: GO 10332
10073: LD_INT 2
10075: DOUBLE
10076: EQUAL
10077: IFTRUE 10081
10079: GO 10331
10081: POP
// begin for i = 1 to num do
10082: LD_ADDR_VAR 0 6
10086: PUSH
10087: DOUBLE
10088: LD_INT 1
10090: DEC
10091: ST_TO_ADDR
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_TO
10098: IFFALSE 10249
// begin vc_chassis := chassis [ 1 ] ;
10100: LD_ADDR_OWVAR 37
10104: PUSH
10105: LD_VAR 0 10
10109: PUSH
10110: LD_INT 1
10112: ARRAY
10113: ST_TO_ADDR
// vc_engine := engine_combustion ;
10114: LD_ADDR_OWVAR 39
10118: PUSH
10119: LD_INT 1
10121: ST_TO_ADDR
// vc_control := control_manual ;
10122: LD_ADDR_OWVAR 38
10126: PUSH
10127: LD_INT 1
10129: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 5 ) ] ;
10130: LD_ADDR_OWVAR 40
10134: PUSH
10135: LD_VAR 0 11
10139: PUSH
10140: LD_INT 3
10142: PPUSH
10143: LD_INT 5
10145: PPUSH
10146: CALL_OW 12
10150: ARRAY
10151: ST_TO_ADDR
// veh := CreateVehicle ;
10152: LD_ADDR_VAR 0 9
10156: PUSH
10157: CALL_OW 45
10161: ST_TO_ADDR
// if area = north_spawn then
10162: LD_VAR 0 4
10166: PUSH
10167: LD_INT 6
10169: EQUAL
10170: IFFALSE 10186
// SetDir ( veh , 3 ) else
10172: LD_VAR 0 9
10176: PPUSH
10177: LD_INT 3
10179: PPUSH
10180: CALL_OW 233
10184: GO 10198
// SetDir ( veh , 1 ) ;
10186: LD_VAR 0 9
10190: PPUSH
10191: LD_INT 1
10193: PPUSH
10194: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
10198: LD_VAR 0 9
10202: PPUSH
10203: LD_VAR 0 4
10207: PPUSH
10208: LD_INT 0
10210: PPUSH
10211: CALL_OW 49
// un := CreateHumanWithClass ( 1 , game_eskill ) ;
10215: LD_ADDR_VAR 0 7
10219: PUSH
10220: LD_INT 1
10222: PPUSH
10223: LD_EXP 4
10227: PPUSH
10228: CALL 9174 0 2
10232: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10233: LD_VAR 0 7
10237: PPUSH
10238: LD_VAR 0 9
10242: PPUSH
10243: CALL_OW 52
// end ;
10247: GO 10097
10249: POP
10250: POP
// for i = 1 to 4 do
10251: LD_ADDR_VAR 0 6
10255: PUSH
10256: DOUBLE
10257: LD_INT 1
10259: DEC
10260: ST_TO_ADDR
10261: LD_INT 4
10263: PUSH
10264: FOR_TO
10265: IFFALSE 10327
// begin uc_nation := 0 ;
10267: LD_ADDR_OWVAR 21
10271: PUSH
10272: LD_INT 0
10274: ST_TO_ADDR
// hc_class := 17 ;
10275: LD_ADDR_OWVAR 28
10279: PUSH
10280: LD_INT 17
10282: ST_TO_ADDR
// hc_attr := [ 11 , 13 ] ;
10283: LD_ADDR_OWVAR 29
10287: PUSH
10288: LD_INT 11
10290: PUSH
10291: LD_INT 13
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: ST_TO_ADDR
// un := CreateHuman ;
10298: LD_ADDR_VAR 0 7
10302: PUSH
10303: CALL_OW 44
10307: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
10308: LD_VAR 0 7
10312: PPUSH
10313: LD_VAR 0 4
10317: PPUSH
10318: LD_INT 0
10320: PPUSH
10321: CALL_OW 49
// end ;
10325: GO 10264
10327: POP
10328: POP
// end ; end ;
10329: GO 10332
10331: POP
// end ;
10332: LD_VAR 0 5
10336: RET
// export function GetDistXYToSide ( x , y , side ) ; var tmp , dist ; begin
10337: LD_INT 0
10339: PPUSH
10340: PPUSH
10341: PPUSH
// tmp := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
10342: LD_ADDR_VAR 0 5
10346: PUSH
10347: LD_INT 22
10349: PUSH
10350: LD_VAR 0 3
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: PPUSH
10359: CALL_OW 69
10363: PPUSH
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_VAR 0 2
10373: PPUSH
10374: CALL_OW 73
10378: ST_TO_ADDR
// dist := GetDistUnitXY ( tmp , x , y ) ;
10379: LD_ADDR_VAR 0 6
10383: PUSH
10384: LD_VAR 0 5
10388: PPUSH
10389: LD_VAR 0 1
10393: PPUSH
10394: LD_VAR 0 2
10398: PPUSH
10399: CALL_OW 297
10403: ST_TO_ADDR
// result := dist ;
10404: LD_ADDR_VAR 0 4
10408: PUSH
10409: LD_VAR 0 6
10413: ST_TO_ADDR
// end ;
10414: LD_VAR 0 4
10418: RET
// export function GetSibAmount ( side ) ; var i , bases ; begin
10419: LD_INT 0
10421: PPUSH
10422: PPUSH
10423: PPUSH
// result := 0 ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_INT 0
10431: ST_TO_ADDR
// bases := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10432: LD_ADDR_VAR 0 4
10436: PUSH
10437: LD_INT 22
10439: PUSH
10440: LD_VAR 0 1
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 2
10451: PUSH
10452: LD_INT 30
10454: PUSH
10455: LD_INT 0
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 30
10464: PUSH
10465: LD_INT 1
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: LIST
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PPUSH
10481: CALL_OW 69
10485: ST_TO_ADDR
// if not bases then
10486: LD_VAR 0 4
10490: NOT
10491: IFFALSE 10495
// exit ;
10493: GO 10541
// for i in bases do
10495: LD_ADDR_VAR 0 3
10499: PUSH
10500: LD_VAR 0 4
10504: PUSH
10505: FOR_IN
10506: IFFALSE 10539
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
10508: LD_ADDR_VAR 0 2
10512: PUSH
10513: LD_VAR 0 2
10517: PUSH
10518: LD_VAR 0 3
10522: PPUSH
10523: CALL_OW 274
10527: PPUSH
10528: LD_INT 3
10530: PPUSH
10531: CALL_OW 275
10535: PLUS
10536: ST_TO_ADDR
10537: GO 10505
10539: POP
10540: POP
// end ; end_of_file
10541: LD_VAR 0 2
10545: RET
// on UnitDestroyed ( un ) do begin if un = jota_base then
10546: LD_VAR 0 1
10550: PUSH
10551: LD_INT 1
10553: EQUAL
10554: IFFALSE 10563
// YouLost ( jota-lose ) ;
10556: LD_STRING jota-lose
10558: PPUSH
10559: CALL_OW 104
// if game_type = 2 and depot_captured = false then
10563: LD_EXP 1
10567: PUSH
10568: LD_INT 2
10570: EQUAL
10571: PUSH
10572: LD_EXP 8
10576: PUSH
10577: LD_INT 0
10579: EQUAL
10580: AND
10581: IFFALSE 10896
// begin if GetSide ( un ) = 1 and un in FilterUnitsInArea ( def_area , [ f_type , unit_building ] ) diff FilterAllUnits ( [ [ [ [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_weapon ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ] ] ] ) then
10583: LD_VAR 0 1
10587: PPUSH
10588: CALL_OW 255
10592: PUSH
10593: LD_INT 1
10595: EQUAL
10596: PUSH
10597: LD_VAR 0 1
10601: PUSH
10602: LD_INT 11
10604: PPUSH
10605: LD_INT 21
10607: PUSH
10608: LD_INT 3
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: PPUSH
10615: CALL_OW 70
10619: PUSH
10620: LD_INT 2
10622: PUSH
10623: LD_INT 30
10625: PUSH
10626: LD_INT 6
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 30
10635: PUSH
10636: LD_INT 10
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 30
10645: PUSH
10646: LD_INT 7
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 30
10655: PUSH
10656: LD_INT 8
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: PUSH
10670: EMPTY
10671: LIST
10672: PUSH
10673: EMPTY
10674: LIST
10675: PUSH
10676: EMPTY
10677: LIST
10678: PUSH
10679: EMPTY
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: DIFF
10687: IN
10688: AND
10689: IFFALSE 10775
// begin ai_build := ai_build ^ GetBType ( un ) ;
10691: LD_ADDR_EXP 10
10695: PUSH
10696: LD_EXP 10
10700: PUSH
10701: LD_VAR 0 1
10705: PPUSH
10706: CALL_OW 266
10710: ADD
10711: ST_TO_ADDR
// ai_build := ai_build ^ GetX ( un ) ;
10712: LD_ADDR_EXP 10
10716: PUSH
10717: LD_EXP 10
10721: PUSH
10722: LD_VAR 0 1
10726: PPUSH
10727: CALL_OW 250
10731: ADD
10732: ST_TO_ADDR
// ai_build := ai_build ^ GetY ( un ) ;
10733: LD_ADDR_EXP 10
10737: PUSH
10738: LD_EXP 10
10742: PUSH
10743: LD_VAR 0 1
10747: PPUSH
10748: CALL_OW 251
10752: ADD
10753: ST_TO_ADDR
// ai_build := ai_build ^ GetDir ( un ) ;
10754: LD_ADDR_EXP 10
10758: PUSH
10759: LD_EXP 10
10763: PUSH
10764: LD_VAR 0 1
10768: PPUSH
10769: CALL_OW 254
10773: ADD
10774: ST_TO_ADDR
// end ; if GetSide ( un ) = 1 and un in FilterAllUnits ( [ f_type , unit_vehicle ] ) then
10775: LD_VAR 0 1
10779: PPUSH
10780: CALL_OW 255
10784: PUSH
10785: LD_INT 1
10787: EQUAL
10788: PUSH
10789: LD_VAR 0 1
10793: PUSH
10794: LD_INT 21
10796: PUSH
10797: LD_INT 2
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PPUSH
10804: CALL_OW 69
10808: IN
10809: AND
10810: IFFALSE 10896
// begin ai_vehs := ai_vehs ^ GetChassis ( un ) ;
10812: LD_ADDR_EXP 11
10816: PUSH
10817: LD_EXP 11
10821: PUSH
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 265
10831: ADD
10832: ST_TO_ADDR
// ai_vehs := ai_vehs ^ GetEngine ( un ) ;
10833: LD_ADDR_EXP 11
10837: PUSH
10838: LD_EXP 11
10842: PUSH
10843: LD_VAR 0 1
10847: PPUSH
10848: CALL_OW 262
10852: ADD
10853: ST_TO_ADDR
// ai_vehs := ai_vehs ^ GetControl ( un ) ;
10854: LD_ADDR_EXP 11
10858: PUSH
10859: LD_EXP 11
10863: PUSH
10864: LD_VAR 0 1
10868: PPUSH
10869: CALL_OW 263
10873: ADD
10874: ST_TO_ADDR
// ai_vehs := ai_vehs ^ GetWeapon ( un ) ;
10875: LD_ADDR_EXP 11
10879: PUSH
10880: LD_EXP 11
10884: PUSH
10885: LD_VAR 0 1
10889: PPUSH
10890: CALL_OW 264
10894: ADD
10895: ST_TO_ADDR
// end ; end ; end ;
10896: PPOPN 1
10898: END
// every 0 0$03 trigger game_type = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
10899: LD_EXP 1
10903: PUSH
10904: LD_INT 1
10906: EQUAL
10907: PUSH
10908: LD_INT 22
10910: PUSH
10911: LD_INT 1
10913: PUSH
10914: EMPTY
10915: LIST
10916: LIST
10917: PUSH
10918: LD_INT 21
10920: PUSH
10921: LD_INT 1
10923: PUSH
10924: EMPTY
10925: LIST
10926: LIST
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL_OW 69
10936: PUSH
10937: LD_INT 0
10939: EQUAL
10940: AND
10941: IFFALSE 10953
10943: GO 10945
10945: DISABLE
// YouLost ( peo-lose ) ;
10946: LD_STRING peo-lose
10948: PPUSH
10949: CALL_OW 104
10953: END
// every 0 0$03 trigger game_type = 2 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10954: LD_EXP 1
10958: PUSH
10959: LD_INT 2
10961: EQUAL
10962: PUSH
10963: LD_INT 22
10965: PUSH
10966: LD_INT 3
10968: PUSH
10969: EMPTY
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 21
10975: PUSH
10976: LD_INT 1
10978: PUSH
10979: EMPTY
10980: LIST
10981: LIST
10982: PUSH
10983: EMPTY
10984: LIST
10985: LIST
10986: PPUSH
10987: CALL_OW 69
10991: PUSH
10992: LD_INT 0
10994: EQUAL
10995: AND
10996: IFFALSE 11008
10998: GO 11000
11000: DISABLE
// YouLost ( peo-lose ) ;
11001: LD_STRING peo-lose
11003: PPUSH
11004: CALL_OW 104
11008: END
// every 0 0$03 trigger GetSibAmount ( your_side ) >= need_to_win do var i ;
11009: LD_OWVAR 2
11013: PPUSH
11014: CALL 10419 0 1
11018: PUSH
11019: LD_EXP 5
11023: GREATEREQUAL
11024: IFFALSE 11110
11026: GO 11028
11028: DISABLE
11029: LD_INT 0
11031: PPUSH
// begin if GetSide ( jota_base ) = your_side then
11032: LD_INT 1
11034: PPUSH
11035: CALL_OW 255
11039: PUSH
11040: LD_OWVAR 2
11044: EQUAL
11045: IFFALSE 11088
// begin for i = 1 to 3 do
11047: LD_ADDR_VAR 0 1
11051: PUSH
11052: DOUBLE
11053: LD_INT 1
11055: DEC
11056: ST_TO_ADDR
11057: LD_INT 3
11059: PUSH
11060: FOR_TO
11061: IFFALSE 11075
// AddMedal ( med , 1 ) ;
11063: LD_STRING med
11065: PPUSH
11066: LD_INT 1
11068: PPUSH
11069: CALL_OW 101
11073: GO 11060
11075: POP
11076: POP
// GiveMedals ( MAIN ) ;
11077: LD_STRING MAIN
11079: PPUSH
11080: CALL_OW 102
// YouWin ;
11084: CALL_OW 103
// end ; if GetSide ( jota_base ) <> your_side then
11088: LD_INT 1
11090: PPUSH
11091: CALL_OW 255
11095: PUSH
11096: LD_OWVAR 2
11100: NONEQUAL
11101: IFFALSE 11110
// YouLost ( source ) ;
11103: LD_STRING source
11105: PPUSH
11106: CALL_OW 104
// end ; end_of_file
11110: PPOPN 1
11112: END
// every 2 2$05 + 0 0$11 do
11113: GO 11115
11115: DISABLE
// begin enable ;
11116: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
11117: LD_INT 1
11119: PPUSH
11120: LD_INT 5
11122: PPUSH
11123: CALL_OW 12
11127: PPUSH
11128: LD_INT 7
11130: PPUSH
11131: LD_INT 1
11133: PPUSH
11134: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$37 ) ) ;
11138: LD_INT 350
11140: PPUSH
11141: LD_INT 1295
11143: PPUSH
11144: CALL_OW 12
11148: PPUSH
11149: CALL_OW 67
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
11153: LD_INT 1
11155: PPUSH
11156: LD_INT 5
11158: PPUSH
11159: CALL_OW 12
11163: PPUSH
11164: LD_INT 1
11166: PPUSH
11167: CALL_OW 57
// end ;
11171: END
// every 1 1$09 trigger game_type = 2 and depot_captured = false do
11172: LD_EXP 1
11176: PUSH
11177: LD_INT 2
11179: EQUAL
11180: PUSH
11181: LD_EXP 8
11185: PUSH
11186: LD_INT 0
11188: EQUAL
11189: AND
11190: IFFALSE 11280
11192: GO 11194
11194: DISABLE
// begin enable ;
11195: ENABLE
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
11196: LD_INT 1
11198: PPUSH
11199: LD_INT 5
11201: PPUSH
11202: CALL_OW 12
11206: PPUSH
11207: LD_INT 7
11209: PPUSH
11210: LD_INT 1
11212: PPUSH
11213: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$50 ) ) ;
11217: LD_INT 350
11219: PPUSH
11220: LD_INT 1750
11222: PPUSH
11223: CALL_OW 12
11227: PPUSH
11228: CALL_OW 67
// if timer <= [ 35 35$00 , 30 30$00 , 25 25$00 ] [ game_diff ] then
11232: LD_EXP 6
11236: PUSH
11237: LD_INT 73500
11239: PUSH
11240: LD_INT 63000
11242: PUSH
11243: LD_INT 52500
11245: PUSH
11246: EMPTY
11247: LIST
11248: LIST
11249: LIST
11250: PUSH
11251: LD_EXP 2
11255: ARRAY
11256: LESSEQUAL
11257: IFFALSE 11280
// CreateCratesArea ( Rand ( 1 , 5 ) , ru_crate , true ) ;
11259: LD_INT 1
11261: PPUSH
11262: LD_INT 5
11264: PPUSH
11265: CALL_OW 12
11269: PPUSH
11270: LD_INT 12
11272: PPUSH
11273: LD_INT 1
11275: PPUSH
11276: CALL_OW 55
// end ; end_of_file
11280: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
11281: LD_VAR 0 1
11285: PPUSH
11286: LD_VAR 0 2
11290: PPUSH
11291: LD_VAR 0 3
11295: PPUSH
11296: CALL 11359 0 3
// end ;
11300: PPOPN 3
11302: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11303: LD_VAR 0 1
11307: PPUSH
11308: CALL 11457 0 1
// end ; end_of_file
11312: PPOPN 1
11314: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11315: GO 11317
11317: DISABLE
// begin ru_radar := 98 ;
11318: LD_ADDR_EXP 21
11322: PUSH
11323: LD_INT 98
11325: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11326: LD_ADDR_EXP 22
11330: PUSH
11331: LD_INT 89
11333: ST_TO_ADDR
// us_hack := 99 ;
11334: LD_ADDR_EXP 23
11338: PUSH
11339: LD_INT 99
11341: ST_TO_ADDR
// us_artillery := 97 ;
11342: LD_ADDR_EXP 24
11346: PUSH
11347: LD_INT 97
11349: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11350: LD_ADDR_EXP 25
11354: PUSH
11355: LD_INT 91
11357: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
11358: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11359: LD_INT 0
11361: PPUSH
11362: PPUSH
11363: PPUSH
11364: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11365: LD_VAR 0 1
11369: PPUSH
11370: CALL_OW 264
11374: PUSH
11375: LD_EXP 25
11379: EQUAL
11380: IFFALSE 11452
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11382: LD_INT 68
11384: PPUSH
11385: LD_VAR 0 1
11389: PPUSH
11390: CALL_OW 255
11394: PPUSH
11395: CALL_OW 321
11399: PUSH
11400: LD_INT 2
11402: EQUAL
11403: IFFALSE 11415
// eff := 70 else
11405: LD_ADDR_VAR 0 6
11409: PUSH
11410: LD_INT 70
11412: ST_TO_ADDR
11413: GO 11423
// eff := 30 ;
11415: LD_ADDR_VAR 0 6
11419: PUSH
11420: LD_INT 30
11422: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11423: LD_VAR 0 1
11427: PPUSH
11428: CALL_OW 250
11432: PPUSH
11433: LD_VAR 0 1
11437: PPUSH
11438: CALL_OW 251
11442: PPUSH
11443: LD_VAR 0 6
11447: PPUSH
11448: CALL_OW 495
// end ; end ;
11452: LD_VAR 0 4
11456: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11457: LD_INT 0
11459: PPUSH
11460: PPUSH
11461: PPUSH
11462: PPUSH
11463: PPUSH
11464: PPUSH
// if cmd = 124 then
11465: LD_VAR 0 1
11469: PUSH
11470: LD_INT 124
11472: EQUAL
11473: IFFALSE 11679
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11475: LD_ADDR_VAR 0 5
11479: PUSH
11480: LD_INT 2
11482: PUSH
11483: LD_INT 34
11485: PUSH
11486: LD_INT 53
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PUSH
11493: LD_INT 34
11495: PUSH
11496: LD_INT 14
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: PUSH
11503: EMPTY
11504: LIST
11505: LIST
11506: LIST
11507: PPUSH
11508: CALL_OW 69
11512: ST_TO_ADDR
// if not tmp then
11513: LD_VAR 0 5
11517: NOT
11518: IFFALSE 11522
// exit ;
11520: GO 11679
// for i in tmp do
11522: LD_ADDR_VAR 0 3
11526: PUSH
11527: LD_VAR 0 5
11531: PUSH
11532: FOR_IN
11533: IFFALSE 11677
// begin taskList := GetTaskList ( i ) ;
11535: LD_ADDR_VAR 0 6
11539: PUSH
11540: LD_VAR 0 3
11544: PPUSH
11545: CALL_OW 437
11549: ST_TO_ADDR
// if not taskList then
11550: LD_VAR 0 6
11554: NOT
11555: IFFALSE 11559
// continue ;
11557: GO 11532
// for j = 1 to taskList do
11559: LD_ADDR_VAR 0 4
11563: PUSH
11564: DOUBLE
11565: LD_INT 1
11567: DEC
11568: ST_TO_ADDR
11569: LD_VAR 0 6
11573: PUSH
11574: FOR_TO
11575: IFFALSE 11673
// if taskList [ j ] [ 1 ] = | then
11577: LD_VAR 0 6
11581: PUSH
11582: LD_VAR 0 4
11586: ARRAY
11587: PUSH
11588: LD_INT 1
11590: ARRAY
11591: PUSH
11592: LD_STRING |
11594: EQUAL
11595: IFFALSE 11671
// begin _taskList := Delete ( taskList , 1 ) ;
11597: LD_ADDR_VAR 0 7
11601: PUSH
11602: LD_VAR 0 6
11606: PPUSH
11607: LD_INT 1
11609: PPUSH
11610: CALL_OW 3
11614: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11615: LD_VAR 0 3
11619: PPUSH
11620: LD_VAR 0 7
11624: PPUSH
11625: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11629: LD_VAR 0 3
11633: PPUSH
11634: LD_VAR 0 6
11638: PUSH
11639: LD_VAR 0 4
11643: ARRAY
11644: PUSH
11645: LD_INT 2
11647: ARRAY
11648: PPUSH
11649: LD_VAR 0 6
11653: PUSH
11654: LD_VAR 0 4
11658: ARRAY
11659: PUSH
11660: LD_INT 3
11662: ARRAY
11663: PPUSH
11664: LD_INT 8
11666: PPUSH
11667: CALL 11684 0 4
// end ;
11671: GO 11574
11673: POP
11674: POP
// end ;
11675: GO 11532
11677: POP
11678: POP
// end ; end ;
11679: LD_VAR 0 2
11683: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11684: LD_INT 0
11686: PPUSH
11687: PPUSH
11688: PPUSH
11689: PPUSH
11690: PPUSH
11691: PPUSH
11692: PPUSH
11693: PPUSH
11694: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11695: LD_VAR 0 1
11699: NOT
11700: PUSH
11701: LD_VAR 0 2
11705: PPUSH
11706: LD_VAR 0 3
11710: PPUSH
11711: CALL_OW 488
11715: NOT
11716: OR
11717: PUSH
11718: LD_VAR 0 4
11722: NOT
11723: OR
11724: IFFALSE 11728
// exit ;
11726: GO 12068
// list := [ ] ;
11728: LD_ADDR_VAR 0 13
11732: PUSH
11733: EMPTY
11734: ST_TO_ADDR
// if x - r < 0 then
11735: LD_VAR 0 2
11739: PUSH
11740: LD_VAR 0 4
11744: MINUS
11745: PUSH
11746: LD_INT 0
11748: LESS
11749: IFFALSE 11761
// min_x := 0 else
11751: LD_ADDR_VAR 0 7
11755: PUSH
11756: LD_INT 0
11758: ST_TO_ADDR
11759: GO 11777
// min_x := x - r ;
11761: LD_ADDR_VAR 0 7
11765: PUSH
11766: LD_VAR 0 2
11770: PUSH
11771: LD_VAR 0 4
11775: MINUS
11776: ST_TO_ADDR
// if y - r < 0 then
11777: LD_VAR 0 3
11781: PUSH
11782: LD_VAR 0 4
11786: MINUS
11787: PUSH
11788: LD_INT 0
11790: LESS
11791: IFFALSE 11803
// min_y := 0 else
11793: LD_ADDR_VAR 0 8
11797: PUSH
11798: LD_INT 0
11800: ST_TO_ADDR
11801: GO 11819
// min_y := y - r ;
11803: LD_ADDR_VAR 0 8
11807: PUSH
11808: LD_VAR 0 3
11812: PUSH
11813: LD_VAR 0 4
11817: MINUS
11818: ST_TO_ADDR
// max_x := x + r ;
11819: LD_ADDR_VAR 0 9
11823: PUSH
11824: LD_VAR 0 2
11828: PUSH
11829: LD_VAR 0 4
11833: PLUS
11834: ST_TO_ADDR
// max_y := y + r ;
11835: LD_ADDR_VAR 0 10
11839: PUSH
11840: LD_VAR 0 3
11844: PUSH
11845: LD_VAR 0 4
11849: PLUS
11850: ST_TO_ADDR
// for _x = min_x to max_x do
11851: LD_ADDR_VAR 0 11
11855: PUSH
11856: DOUBLE
11857: LD_VAR 0 7
11861: DEC
11862: ST_TO_ADDR
11863: LD_VAR 0 9
11867: PUSH
11868: FOR_TO
11869: IFFALSE 11986
// for _y = min_y to max_y do
11871: LD_ADDR_VAR 0 12
11875: PUSH
11876: DOUBLE
11877: LD_VAR 0 8
11881: DEC
11882: ST_TO_ADDR
11883: LD_VAR 0 10
11887: PUSH
11888: FOR_TO
11889: IFFALSE 11982
// begin if not ValidHex ( _x , _y ) then
11891: LD_VAR 0 11
11895: PPUSH
11896: LD_VAR 0 12
11900: PPUSH
11901: CALL_OW 488
11905: NOT
11906: IFFALSE 11910
// continue ;
11908: GO 11888
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11910: LD_VAR 0 11
11914: PPUSH
11915: LD_VAR 0 12
11919: PPUSH
11920: CALL_OW 351
11924: PUSH
11925: LD_VAR 0 11
11929: PPUSH
11930: LD_VAR 0 12
11934: PPUSH
11935: CALL_OW 554
11939: AND
11940: IFFALSE 11980
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11942: LD_ADDR_VAR 0 13
11946: PUSH
11947: LD_VAR 0 13
11951: PPUSH
11952: LD_VAR 0 13
11956: PUSH
11957: LD_INT 1
11959: PLUS
11960: PPUSH
11961: LD_VAR 0 11
11965: PUSH
11966: LD_VAR 0 12
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PPUSH
11975: CALL_OW 2
11979: ST_TO_ADDR
// end ;
11980: GO 11888
11982: POP
11983: POP
11984: GO 11868
11986: POP
11987: POP
// if not list then
11988: LD_VAR 0 13
11992: NOT
11993: IFFALSE 11997
// exit ;
11995: GO 12068
// for i in list do
11997: LD_ADDR_VAR 0 6
12001: PUSH
12002: LD_VAR 0 13
12006: PUSH
12007: FOR_IN
12008: IFFALSE 12066
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_STRING M
12017: PUSH
12018: LD_VAR 0 6
12022: PUSH
12023: LD_INT 1
12025: ARRAY
12026: PUSH
12027: LD_VAR 0 6
12031: PUSH
12032: LD_INT 2
12034: ARRAY
12035: PUSH
12036: LD_INT 0
12038: PUSH
12039: LD_INT 0
12041: PUSH
12042: LD_INT 0
12044: PUSH
12045: LD_INT 0
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: LIST
12056: PUSH
12057: EMPTY
12058: LIST
12059: PPUSH
12060: CALL_OW 447
12064: GO 12007
12066: POP
12067: POP
// end ;
12068: LD_VAR 0 5
12072: RET
