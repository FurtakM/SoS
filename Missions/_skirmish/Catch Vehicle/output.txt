// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareGame ;
   4: CALL 13 0 0
// PrepareUnits ;
   8: CALL 299 0 0
// end ;
  12: END
// export mechanics , time_to_destroy , players , sib_bomb , time , veh_amount ; export p1 , p2 , p3 , p4 , p5 ; function PrepareGame ; var debug , i ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
// debug := false ;
  18: LD_ADDR_VAR 0 2
  22: PUSH
  23: LD_INT 0
  25: ST_TO_ADDR
// if debug then
  26: LD_VAR 0 2
  30: IFFALSE 81
// begin mechanics := 5 ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 5
  39: ST_TO_ADDR
// time_to_destroy := 45 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 45
  47: ST_TO_ADDR
// players := 4 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 4
  55: ST_TO_ADDR
// sib_bomb := true ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 1
  63: ST_TO_ADDR
// time := 3 3$00 ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 6300
  71: ST_TO_ADDR
// FogOff ( 1 ) ;
  72: LD_INT 1
  74: PPUSH
  75: CALL_OW 344
// end else
  79: GO 214
// begin time := 3 3$00 ;
  81: LD_ADDR_EXP 5
  85: PUSH
  86: LD_INT 6300
  88: ST_TO_ADDR
// players := 4 ;
  89: LD_ADDR_EXP 3
  93: PUSH
  94: LD_INT 4
  96: ST_TO_ADDR
// sib_bomb := true ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 1
 104: ST_TO_ADDR
// mechanics := 4 ;
 105: LD_ADDR_EXP 1
 109: PUSH
 110: LD_INT 4
 112: ST_TO_ADDR
// mechanics := [ 3 , 4 , 5 ] [ GetMultiplayerSetting ( 0 ) ] ;
 113: LD_ADDR_EXP 1
 117: PUSH
 118: LD_INT 3
 120: PUSH
 121: LD_INT 4
 123: PUSH
 124: LD_INT 5
 126: PUSH
 127: EMPTY
 128: LIST
 129: LIST
 130: LIST
 131: PUSH
 132: LD_INT 0
 134: PPUSH
 135: CALL_OW 426
 139: ARRAY
 140: ST_TO_ADDR
// players := [ 3 , 4 , 5 ] [ GetMultiplayerSetting ( 1 ) ] ;
 141: LD_ADDR_EXP 3
 145: PUSH
 146: LD_INT 3
 148: PUSH
 149: LD_INT 4
 151: PUSH
 152: LD_INT 5
 154: PUSH
 155: EMPTY
 156: LIST
 157: LIST
 158: LIST
 159: PUSH
 160: LD_INT 1
 162: PPUSH
 163: CALL_OW 426
 167: ARRAY
 168: ST_TO_ADDR
// time := [ 3 3$00 , 5 5$00 , 10 10$00 ] [ GetMultiplayerSetting ( 2 ) ] ;
 169: LD_ADDR_EXP 5
 173: PUSH
 174: LD_INT 6300
 176: PUSH
 177: LD_INT 10500
 179: PUSH
 180: LD_INT 21000
 182: PUSH
 183: EMPTY
 184: LIST
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 2
 190: PPUSH
 191: CALL_OW 426
 195: ARRAY
 196: ST_TO_ADDR
// sib_bomb := GetMultiplayerSetting ( 3 ) - 1 ;
 197: LD_ADDR_EXP 4
 201: PUSH
 202: LD_INT 3
 204: PPUSH
 205: CALL_OW 426
 209: PUSH
 210: LD_INT 1
 212: MINUS
 213: ST_TO_ADDR
// end ; p1 := 0 ;
 214: LD_ADDR_EXP 7
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// p2 := 0 ;
 222: LD_ADDR_EXP 8
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// p3 := 0 ;
 230: LD_ADDR_EXP 9
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// p4 := 0 ;
 238: LD_ADDR_EXP 10
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// p5 := 0 ;
 246: LD_ADDR_EXP 11
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// veh_amount := 12 ;
 254: LD_ADDR_EXP 6
 258: PUSH
 259: LD_INT 12
 261: ST_TO_ADDR
// for i = 1 to 7 do
 262: LD_ADDR_VAR 0 3
 266: PUSH
 267: DOUBLE
 268: LD_INT 1
 270: DEC
 271: ST_TO_ADDR
 272: LD_INT 7
 274: PUSH
 275: FOR_TO
 276: IFFALSE 292
// ChangeSideFog ( i , 8 ) ;
 278: LD_VAR 0 3
 282: PPUSH
 283: LD_INT 8
 285: PPUSH
 286: CALL_OW 343
 290: GO 275
 292: POP
 293: POP
// end ; end_of_file
 294: LD_VAR 0 1
 298: RET
// export function PrepareUnits ; var i , side ; begin
 299: LD_INT 0
 301: PPUSH
 302: PPUSH
 303: PPUSH
// side := players ;
 304: LD_ADDR_VAR 0 3
 308: PUSH
 309: LD_EXP 3
 313: ST_TO_ADDR
// uc_nation := 1 ;
 314: LD_ADDR_OWVAR 21
 318: PUSH
 319: LD_INT 1
 321: ST_TO_ADDR
// for i = 1 to mechanics do
 322: LD_ADDR_VAR 0 2
 326: PUSH
 327: DOUBLE
 328: LD_INT 1
 330: DEC
 331: ST_TO_ADDR
 332: LD_EXP 1
 336: PUSH
 337: FOR_TO
 338: IFFALSE 402
// for side = 1 to players do
 340: LD_ADDR_VAR 0 3
 344: PUSH
 345: DOUBLE
 346: LD_INT 1
 348: DEC
 349: ST_TO_ADDR
 350: LD_EXP 3
 354: PUSH
 355: FOR_TO
 356: IFFALSE 398
// begin uc_side := side ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_VAR 0 3
 367: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 368: LD_INT 0
 370: PPUSH
 371: LD_INT 3
 373: PPUSH
 374: LD_INT 10
 376: PPUSH
 377: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 381: CALL_OW 44
 385: PPUSH
 386: LD_INT 6
 388: PPUSH
 389: LD_INT 0
 391: PPUSH
 392: CALL_OW 49
// end ;
 396: GO 355
 398: POP
 399: POP
 400: GO 337
 402: POP
 403: POP
// end ;
 404: LD_VAR 0 1
 408: RET
// function ToSpawn ( side ) ; begin
 409: LD_INT 0
 411: PPUSH
// uc_side := side ;
 412: LD_ADDR_OWVAR 20
 416: PUSH
 417: LD_VAR 0 1
 421: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 422: LD_INT 0
 424: PPUSH
 425: LD_INT 3
 427: PPUSH
 428: LD_INT 10
 430: PPUSH
 431: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 435: CALL_OW 44
 439: PPUSH
 440: LD_INT 6
 442: PPUSH
 443: LD_INT 0
 445: PPUSH
 446: CALL_OW 49
// end ;
 450: LD_VAR 0 2
 454: RET
// every 0 0$13 trigger time do var i , filter ;
 455: LD_EXP 5
 459: IFFALSE 569
 461: GO 463
 463: DISABLE
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// begin enable ;
 468: ENABLE
// for i = 1 to players do
 469: LD_ADDR_VAR 0 1
 473: PUSH
 474: DOUBLE
 475: LD_INT 1
 477: DEC
 478: ST_TO_ADDR
 479: LD_EXP 3
 483: PUSH
 484: FOR_TO
 485: IFFALSE 567
// begin filter := FilterAllUnits ( [ [ [ f_side , i ] , [ f_class , 3 ] , [ f_type , unit_human ] ] ] ) ;
 487: LD_ADDR_VAR 0 2
 491: PUSH
 492: LD_INT 22
 494: PUSH
 495: LD_VAR 0 1
 499: PUSH
 500: EMPTY
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 25
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: PUSH
 514: LD_INT 21
 516: PUSH
 517: LD_INT 1
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: PPUSH
 532: CALL_OW 69
 536: ST_TO_ADDR
// if filter < mechanics then
 537: LD_VAR 0 2
 541: PUSH
 542: LD_EXP 1
 546: LESS
 547: IFFALSE 565
// begin Wait ( 0 0$03 ) ;
 549: LD_INT 105
 551: PPUSH
 552: CALL_OW 67
// ToSpawn ( i ) ;
 556: LD_VAR 0 1
 560: PPUSH
 561: CALL 409 0 1
// end ; end ;
 565: GO 484
 567: POP
 568: POP
// end ;
 569: PPOPN 2
 571: END
// every 0 0$01 trigger time do var i , filter , filter2 , vehicles ;
 572: LD_EXP 5
 576: IFFALSE 943
 578: GO 580
 580: DISABLE
 581: LD_INT 0
 583: PPUSH
 584: PPUSH
 585: PPUSH
 586: PPUSH
// begin enable ;
 587: ENABLE
// filter2 := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_not , [ f_side , 0 ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 588: LD_ADDR_VAR 0 3
 592: PUSH
 593: LD_INT 21
 595: PUSH
 596: LD_INT 2
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 3
 605: PUSH
 606: LD_INT 22
 608: PUSH
 609: LD_INT 0
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: PUSH
 616: EMPTY
 617: LIST
 618: LIST
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 22
 625: PUSH
 626: LD_INT 1
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: PPUSH
 642: CALL_OW 69
 646: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 647: LD_ADDR_VAR 0 2
 651: PUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 54
 667: PUSH
 668: EMPTY
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 3
 677: PUSH
 678: LD_INT 22
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL_OW 69
 701: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 702: LD_ADDR_VAR 0 4
 706: PUSH
 707: LD_INT 21
 709: PUSH
 710: LD_INT 2
 712: PUSH
 713: EMPTY
 714: LIST
 715: LIST
 716: PUSH
 717: LD_INT 58
 719: PUSH
 720: EMPTY
 721: LIST
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: PPUSH
 727: CALL_OW 69
 731: ST_TO_ADDR
// if filter and vehicles then
 732: LD_VAR 0 2
 736: PUSH
 737: LD_VAR 0 4
 741: AND
 742: IFFALSE 879
// for i = 1 to filter do
 744: LD_ADDR_VAR 0 1
 748: PUSH
 749: DOUBLE
 750: LD_INT 1
 752: DEC
 753: ST_TO_ADDR
 754: LD_VAR 0 2
 758: PUSH
 759: FOR_TO
 760: IFFALSE 877
// if not HasTask ( filter [ i ] ) and IsOk ( filter [ i ] ) then
 762: LD_VAR 0 2
 766: PUSH
 767: LD_VAR 0 1
 771: ARRAY
 772: PPUSH
 773: CALL_OW 314
 777: NOT
 778: PUSH
 779: LD_VAR 0 2
 783: PUSH
 784: LD_VAR 0 1
 788: ARRAY
 789: PPUSH
 790: CALL_OW 302
 794: AND
 795: IFFALSE 875
// if GetDistUnits ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) < 45 then
 797: LD_VAR 0 2
 801: PUSH
 802: LD_VAR 0 1
 806: ARRAY
 807: PPUSH
 808: LD_VAR 0 4
 812: PPUSH
 813: LD_VAR 0 2
 817: PUSH
 818: LD_VAR 0 1
 822: ARRAY
 823: PPUSH
 824: CALL_OW 74
 828: PPUSH
 829: CALL_OW 296
 833: PUSH
 834: LD_INT 45
 836: LESS
 837: IFFALSE 875
// ComEnterUnit ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) ;
 839: LD_VAR 0 2
 843: PUSH
 844: LD_VAR 0 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 4
 854: PPUSH
 855: LD_VAR 0 2
 859: PUSH
 860: LD_VAR 0 1
 864: ARRAY
 865: PPUSH
 866: CALL_OW 74
 870: PPUSH
 871: CALL_OW 120
 875: GO 759
 877: POP
 878: POP
// if filter2 then
 879: LD_VAR 0 3
 883: IFFALSE 943
// for i = 1 to filter2 do
 885: LD_ADDR_VAR 0 1
 889: PUSH
 890: DOUBLE
 891: LD_INT 1
 893: DEC
 894: ST_TO_ADDR
 895: LD_VAR 0 3
 899: PUSH
 900: FOR_TO
 901: IFFALSE 941
// if not HasTask ( filter2 [ i ] ) then
 903: LD_VAR 0 3
 907: PUSH
 908: LD_VAR 0 1
 912: ARRAY
 913: PPUSH
 914: CALL_OW 314
 918: NOT
 919: IFFALSE 939
// ComMoveToArea ( filter2 [ i ] , exit_area ) ;
 921: LD_VAR 0 3
 925: PUSH
 926: LD_VAR 0 1
 930: ARRAY
 931: PPUSH
 932: LD_INT 4
 934: PPUSH
 935: CALL_OW 113
 939: GO 900
 941: POP
 942: POP
// end ; end_of_file
 943: PPOPN 4
 945: END
// export function SpawnCar ( chas , area ) ; var i , e , veh , ar_chassis , ru_chassis , us_chassis , ar_weapons , ru_weapons , us_weapons , chassis , engine , weapon ; begin
 946: LD_INT 0
 948: PPUSH
 949: PPUSH
 950: PPUSH
 951: PPUSH
 952: PPUSH
 953: PPUSH
 954: PPUSH
 955: PPUSH
 956: PPUSH
 957: PPUSH
 958: PPUSH
 959: PPUSH
 960: PPUSH
// uc_side := 0 ;
 961: LD_ADDR_OWVAR 20
 965: PUSH
 966: LD_INT 0
 968: ST_TO_ADDR
// uc_nation := Rand ( 1 , 3 ) ;
 969: LD_ADDR_OWVAR 21
 973: PUSH
 974: LD_INT 1
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: CALL_OW 12
 984: ST_TO_ADDR
// ar_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
 985: LD_ADDR_VAR 0 7
 989: PUSH
 990: LD_INT 11
 992: PUSH
 993: LD_INT 12
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 14
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: ST_TO_ADDR
// ru_chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ;
1008: LD_ADDR_VAR 0 8
1012: PUSH
1013: LD_INT 21
1015: PUSH
1016: LD_INT 22
1018: PUSH
1019: LD_INT 23
1021: PUSH
1022: LD_INT 24
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: LIST
1029: LIST
1030: ST_TO_ADDR
// us_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ;
1031: LD_ADDR_VAR 0 9
1035: PUSH
1036: LD_INT 1
1038: PUSH
1039: LD_INT 2
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: LD_INT 4
1047: PUSH
1048: LD_INT 5
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: ST_TO_ADDR
// if chas > 0 then
1058: LD_VAR 0 1
1062: PUSH
1063: LD_INT 0
1065: GREATER
1066: IFFALSE 1080
// vc_chassis := chas else
1068: LD_ADDR_OWVAR 37
1072: PUSH
1073: LD_VAR 0 1
1077: ST_TO_ADDR
1078: GO 1173
// begin case uc_nation of 1 :
1080: LD_OWVAR 21
1084: PUSH
1085: LD_INT 1
1087: DOUBLE
1088: EQUAL
1089: IFTRUE 1093
1091: GO 1106
1093: POP
// chassis := us_chassis ; 2 :
1094: LD_ADDR_VAR 0 13
1098: PUSH
1099: LD_VAR 0 9
1103: ST_TO_ADDR
1104: GO 1149
1106: LD_INT 2
1108: DOUBLE
1109: EQUAL
1110: IFTRUE 1114
1112: GO 1127
1114: POP
// chassis := ar_chassis ; 3 :
1115: LD_ADDR_VAR 0 13
1119: PUSH
1120: LD_VAR 0 7
1124: ST_TO_ADDR
1125: GO 1149
1127: LD_INT 3
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1148
1135: POP
// chassis := ru_chassis ; end ;
1136: LD_ADDR_VAR 0 13
1140: PUSH
1141: LD_VAR 0 8
1145: ST_TO_ADDR
1146: GO 1149
1148: POP
// vc_chassis := chassis [ Rand ( 1 , chassis ) ] ;
1149: LD_ADDR_OWVAR 37
1153: PUSH
1154: LD_VAR 0 13
1158: PUSH
1159: LD_INT 1
1161: PPUSH
1162: LD_VAR 0 13
1166: PPUSH
1167: CALL_OW 12
1171: ARRAY
1172: ST_TO_ADDR
// end ; if vc_chassis in [ ar_hovercraft , ar_light_trike , us_light_wheeled ] then
1173: LD_OWVAR 37
1177: PUSH
1178: LD_INT 11
1180: PUSH
1181: LD_INT 12
1183: PUSH
1184: LD_INT 1
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: LIST
1191: IN
1192: IFFALSE 1212
// engine := Rand ( 1 , 2 ) else
1194: LD_ADDR_VAR 0 14
1198: PUSH
1199: LD_INT 1
1201: PPUSH
1202: LD_INT 2
1204: PPUSH
1205: CALL_OW 12
1209: ST_TO_ADDR
1210: GO 1324
// begin if not vc_chassis in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked , us_morphling ] then
1212: LD_OWVAR 37
1216: PUSH
1217: LD_INT 21
1219: PUSH
1220: LD_INT 22
1222: PUSH
1223: LD_INT 23
1225: PUSH
1226: LD_INT 24
1228: PUSH
1229: LD_INT 4
1231: PUSH
1232: LD_INT 5
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: IN
1243: NOT
1244: IFFALSE 1264
// engine := Rand ( 1 , 3 ) else
1246: LD_ADDR_VAR 0 14
1250: PUSH
1251: LD_INT 1
1253: PPUSH
1254: LD_INT 3
1256: PPUSH
1257: CALL_OW 12
1261: ST_TO_ADDR
1262: GO 1280
// e := Rand ( 1 , 2 ) ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_INT 1
1271: PPUSH
1272: LD_INT 2
1274: PPUSH
1275: CALL_OW 12
1279: ST_TO_ADDR
// case e of 1 :
1280: LD_VAR 0 5
1284: PUSH
1285: LD_INT 1
1287: DOUBLE
1288: EQUAL
1289: IFTRUE 1293
1291: GO 1304
1293: POP
// engine := engine_combustion ; 2 :
1294: LD_ADDR_VAR 0 14
1298: PUSH
1299: LD_INT 1
1301: ST_TO_ADDR
1302: GO 1324
1304: LD_INT 2
1306: DOUBLE
1307: EQUAL
1308: IFTRUE 1312
1310: GO 1323
1312: POP
// engine := engine_siberite ; end ;
1313: LD_ADDR_VAR 0 14
1317: PUSH
1318: LD_INT 3
1320: ST_TO_ADDR
1321: GO 1324
1323: POP
// end ; vc_engine := engine ;
1324: LD_ADDR_OWVAR 39
1328: PUSH
1329: LD_VAR 0 14
1333: ST_TO_ADDR
// vc_control := control_manual ;
1334: LD_ADDR_OWVAR 38
1338: PUSH
1339: LD_INT 1
1341: ST_TO_ADDR
// ar_weapons := [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ar_radar , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb , ar_flame_thrower ] ;
1342: LD_ADDR_VAR 0 10
1346: PUSH
1347: LD_INT 22
1349: PUSH
1350: LD_INT 24
1352: PUSH
1353: LD_INT 23
1355: PUSH
1356: LD_INT 30
1358: PUSH
1359: LD_INT 25
1361: PUSH
1362: LD_INT 27
1364: PUSH
1365: LD_INT 28
1367: PUSH
1368: LD_INT 29
1370: PUSH
1371: LD_INT 26
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// ru_weapons := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , 98 , ru_rocket_launcher , ru_heavy_gun , ru_rocket , ru_bulldozer , ru_time_lapser ] ;
1385: LD_ADDR_VAR 0 11
1389: PUSH
1390: LD_INT 42
1392: PUSH
1393: LD_INT 43
1395: PUSH
1396: LD_INT 44
1398: PUSH
1399: LD_INT 98
1401: PUSH
1402: LD_INT 45
1404: PUSH
1405: LD_INT 46
1407: PUSH
1408: LD_INT 47
1410: PUSH
1411: LD_INT 53
1413: PUSH
1414: LD_INT 49
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: ST_TO_ADDR
// us_weapons := [ us_machine_gun , us_light_gun , us_radar , us_gatling_gun , us_double_gun , us_rocket_launcher , us_laser , us_heavy_gun , us_bulldozer , us_double_laser ] ;
1428: LD_ADDR_VAR 0 12
1432: PUSH
1433: LD_INT 2
1435: PUSH
1436: LD_INT 3
1438: PUSH
1439: LD_INT 11
1441: PUSH
1442: LD_INT 4
1444: PUSH
1445: LD_INT 5
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: LD_INT 9
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: LD_INT 14
1459: PUSH
1460: LD_INT 10
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: ST_TO_ADDR
// if uc_nation = nation_arabian then
1475: LD_OWVAR 21
1479: PUSH
1480: LD_INT 2
1482: EQUAL
1483: IFFALSE 1550
// begin if vc_chassis in [ ar_hovercraft , ar_light_trike ] then
1485: LD_OWVAR 37
1489: PUSH
1490: LD_INT 11
1492: PUSH
1493: LD_INT 12
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: IN
1500: IFFALSE 1526
// weapon := ar_weapons [ Rand ( 1 , 3 ) ] else
1502: LD_ADDR_VAR 0 15
1506: PUSH
1507: LD_VAR 0 10
1511: PUSH
1512: LD_INT 1
1514: PPUSH
1515: LD_INT 3
1517: PPUSH
1518: CALL_OW 12
1522: ARRAY
1523: ST_TO_ADDR
1524: GO 1550
// weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
1526: LD_ADDR_VAR 0 15
1530: PUSH
1531: LD_VAR 0 10
1535: PUSH
1536: LD_INT 1
1538: PPUSH
1539: LD_VAR 0 10
1543: PPUSH
1544: CALL_OW 12
1548: ARRAY
1549: ST_TO_ADDR
// end ; if uc_nation = nation_russian then
1550: LD_OWVAR 21
1554: PUSH
1555: LD_INT 3
1557: EQUAL
1558: IFFALSE 1625
// begin if vc_chassis in [ ru_medium_wheeled , ru_medium_tracked ] then
1560: LD_OWVAR 37
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: IN
1575: IFFALSE 1601
// weapon := ru_weapons [ Rand ( 1 , 5 ) ] else
1577: LD_ADDR_VAR 0 15
1581: PUSH
1582: LD_VAR 0 11
1586: PUSH
1587: LD_INT 1
1589: PPUSH
1590: LD_INT 5
1592: PPUSH
1593: CALL_OW 12
1597: ARRAY
1598: ST_TO_ADDR
1599: GO 1625
// weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
1601: LD_ADDR_VAR 0 15
1605: PUSH
1606: LD_VAR 0 11
1610: PUSH
1611: LD_INT 1
1613: PPUSH
1614: LD_VAR 0 11
1618: PPUSH
1619: CALL_OW 12
1623: ARRAY
1624: ST_TO_ADDR
// end ; if uc_nation = nation_american then
1625: LD_OWVAR 21
1629: PUSH
1630: LD_INT 1
1632: EQUAL
1633: IFFALSE 1742
// begin if vc_chassis = us_light_wheeled then
1635: LD_OWVAR 37
1639: PUSH
1640: LD_INT 1
1642: EQUAL
1643: IFFALSE 1667
// weapon := us_weapons [ Rand ( 1 , 3 ) ] ;
1645: LD_ADDR_VAR 0 15
1649: PUSH
1650: LD_VAR 0 12
1654: PUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 3
1660: PPUSH
1661: CALL_OW 12
1665: ARRAY
1666: ST_TO_ADDR
// if vc_chassis in [ us_medium_tracked , us_medium_wheeled ] then
1667: LD_OWVAR 37
1671: PUSH
1672: LD_INT 3
1674: PUSH
1675: LD_INT 2
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: IN
1682: IFFALSE 1708
// weapon := us_weapons [ Rand ( 1 , 7 ) ] else
1684: LD_ADDR_VAR 0 15
1688: PUSH
1689: LD_VAR 0 12
1693: PUSH
1694: LD_INT 1
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL_OW 12
1704: ARRAY
1705: ST_TO_ADDR
1706: GO 1742
// if vc_chassis <> us_light_wheeled then
1708: LD_OWVAR 37
1712: PUSH
1713: LD_INT 1
1715: NONEQUAL
1716: IFFALSE 1742
// weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
1718: LD_ADDR_VAR 0 15
1722: PUSH
1723: LD_VAR 0 12
1727: PUSH
1728: LD_INT 1
1730: PPUSH
1731: LD_VAR 0 12
1735: PPUSH
1736: CALL_OW 12
1740: ARRAY
1741: ST_TO_ADDR
// end ; vc_weapon := weapon ;
1742: LD_ADDR_OWVAR 40
1746: PUSH
1747: LD_VAR 0 15
1751: ST_TO_ADDR
// veh := CreateVehicle ;
1752: LD_ADDR_VAR 0 6
1756: PUSH
1757: CALL_OW 45
1761: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1762: LD_VAR 0 6
1766: PPUSH
1767: LD_VAR 0 2
1771: PPUSH
1772: LD_INT 1
1774: PPUSH
1775: CALL_OW 49
// end ;
1779: LD_VAR 0 3
1783: RET
// export function SpawnSibRocket ( area ) ; var veh , p ; begin
1784: LD_INT 0
1786: PPUSH
1787: PPUSH
1788: PPUSH
// uc_side := 0 ;
1789: LD_ADDR_OWVAR 20
1793: PUSH
1794: LD_INT 0
1796: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
1797: LD_ADDR_VAR 0 4
1801: PUSH
1802: LD_INT 1
1804: PPUSH
1805: LD_INT 2
1807: PPUSH
1808: CALL_OW 12
1812: ST_TO_ADDR
// case p of 1 :
1813: LD_VAR 0 4
1817: PUSH
1818: LD_INT 1
1820: DOUBLE
1821: EQUAL
1822: IFTRUE 1826
1824: GO 1869
1826: POP
// begin uc_nation := nation_american ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
1835: LD_ADDR_OWVAR 37
1839: PUSH
1840: LD_INT 4
1842: ST_TO_ADDR
// vc_engine := engine_siberite ;
1843: LD_ADDR_OWVAR 39
1847: PUSH
1848: LD_INT 3
1850: ST_TO_ADDR
// vc_control := control_manual ;
1851: LD_ADDR_OWVAR 38
1855: PUSH
1856: LD_INT 1
1858: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
1859: LD_ADDR_OWVAR 40
1863: PUSH
1864: LD_INT 8
1866: ST_TO_ADDR
// end ; 2 :
1867: GO 1921
1869: LD_INT 2
1871: DOUBLE
1872: EQUAL
1873: IFTRUE 1877
1875: GO 1920
1877: POP
// begin uc_nation := nation_russian ;
1878: LD_ADDR_OWVAR 21
1882: PUSH
1883: LD_INT 3
1885: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
1886: LD_ADDR_OWVAR 37
1890: PUSH
1891: LD_INT 24
1893: ST_TO_ADDR
// vc_engine := engine_siberite ;
1894: LD_ADDR_OWVAR 39
1898: PUSH
1899: LD_INT 3
1901: ST_TO_ADDR
// vc_control := control_manual ;
1902: LD_ADDR_OWVAR 38
1906: PUSH
1907: LD_INT 1
1909: ST_TO_ADDR
// vc_weapon := ru_siberium_rocket ;
1910: LD_ADDR_OWVAR 40
1914: PUSH
1915: LD_INT 48
1917: ST_TO_ADDR
// end ; end ;
1918: GO 1921
1920: POP
// veh := CreateVehicle ;
1921: LD_ADDR_VAR 0 3
1925: PUSH
1926: CALL_OW 45
1930: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1931: LD_VAR 0 3
1935: PPUSH
1936: LD_VAR 0 1
1940: PPUSH
1941: LD_INT 1
1943: PPUSH
1944: CALL_OW 49
// end ;
1948: LD_VAR 0 2
1952: RET
// export function ScoreBoard ( veh ) ; var points ; begin
1953: LD_INT 0
1955: PPUSH
1956: PPUSH
// points := 0 ;
1957: LD_ADDR_VAR 0 3
1961: PUSH
1962: LD_INT 0
1964: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_light_trike , us_light_wheeled ] then
1965: LD_VAR 0 1
1969: PPUSH
1970: CALL_OW 265
1974: PUSH
1975: LD_INT 12
1977: PUSH
1978: LD_INT 1
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: IN
1985: IFFALSE 2001
// points := points + 10 ;
1987: LD_ADDR_VAR 0 3
1991: PUSH
1992: LD_VAR 0 3
1996: PUSH
1997: LD_INT 10
1999: PLUS
2000: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_medium_trike , ru_medium_wheeled , us_medium_wheeled ] then
2001: LD_VAR 0 1
2005: PPUSH
2006: CALL_OW 265
2010: PUSH
2011: LD_INT 13
2013: PUSH
2014: LD_INT 21
2016: PUSH
2017: LD_INT 2
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: IN
2025: IFFALSE 2041
// points := points + 15 ;
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: LD_VAR 0 3
2036: PUSH
2037: LD_INT 15
2039: PLUS
2040: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_half_tracked , ru_medium_tracked , us_medium_tracked ] then
2041: LD_VAR 0 1
2045: PPUSH
2046: CALL_OW 265
2050: PUSH
2051: LD_INT 14
2053: PUSH
2054: LD_INT 22
2056: PUSH
2057: LD_INT 3
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: LIST
2064: IN
2065: IFFALSE 2081
// points := points + 20 ;
2067: LD_ADDR_VAR 0 3
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 20
2079: PLUS
2080: ST_TO_ADDR
// if GetChassis ( veh ) in [ ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked ] then
2081: LD_VAR 0 1
2085: PPUSH
2086: CALL_OW 265
2090: PUSH
2091: LD_INT 23
2093: PUSH
2094: LD_INT 24
2096: PUSH
2097: LD_INT 4
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: IN
2105: IFFALSE 2121
// points := points + 25 ;
2107: LD_ADDR_VAR 0 3
2111: PUSH
2112: LD_VAR 0 3
2116: PUSH
2117: LD_INT 25
2119: PLUS
2120: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_hovercraft , us_morphling ] then
2121: LD_VAR 0 1
2125: PPUSH
2126: CALL_OW 265
2130: PUSH
2131: LD_INT 11
2133: PUSH
2134: LD_INT 5
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: IN
2141: IFFALSE 2157
// points := points + 30 ;
2143: LD_ADDR_VAR 0 3
2147: PUSH
2148: LD_VAR 0 3
2152: PUSH
2153: LD_INT 30
2155: PLUS
2156: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_combustion ] then
2157: LD_VAR 0 1
2161: PPUSH
2162: CALL_OW 262
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: EMPTY
2171: LIST
2172: EQUAL
2173: IFFALSE 2189
// points := points + 5 ;
2175: LD_ADDR_VAR 0 3
2179: PUSH
2180: LD_VAR 0 3
2184: PUSH
2185: LD_INT 5
2187: PLUS
2188: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_solar ] then
2189: LD_VAR 0 1
2193: PPUSH
2194: CALL_OW 262
2198: PUSH
2199: LD_INT 2
2201: PUSH
2202: EMPTY
2203: LIST
2204: EQUAL
2205: IFFALSE 2221
// points := points + 15 ;
2207: LD_ADDR_VAR 0 3
2211: PUSH
2212: LD_VAR 0 3
2216: PUSH
2217: LD_INT 15
2219: PLUS
2220: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_siberite ] then
2221: LD_VAR 0 1
2225: PPUSH
2226: CALL_OW 262
2230: PUSH
2231: LD_INT 3
2233: PUSH
2234: EMPTY
2235: LIST
2236: EQUAL
2237: IFFALSE 2253
// points := points + 25 ;
2239: LD_ADDR_VAR 0 3
2243: PUSH
2244: LD_VAR 0 3
2248: PUSH
2249: LD_INT 25
2251: PLUS
2252: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ru_heavy_machine_gun , us_machine_gun , us_light_gun ] then
2253: LD_VAR 0 1
2257: PPUSH
2258: CALL_OW 264
2262: PUSH
2263: LD_INT 22
2265: PUSH
2266: LD_INT 24
2268: PUSH
2269: LD_INT 23
2271: PUSH
2272: LD_INT 42
2274: PUSH
2275: LD_INT 2
2277: PUSH
2278: LD_INT 3
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: LIST
2288: IN
2289: IFFALSE 2305
// points := points + 5 ;
2291: LD_ADDR_VAR 0 3
2295: PUSH
2296: LD_VAR 0 3
2300: PUSH
2301: LD_INT 5
2303: PLUS
2304: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_gatling_gun , ar_gun , ru_gatling_gun , ru_gun , us_gatling_gun , us_double_gun ] then
2305: LD_VAR 0 1
2309: PPUSH
2310: CALL_OW 264
2314: PUSH
2315: LD_INT 25
2317: PUSH
2318: LD_INT 27
2320: PUSH
2321: LD_INT 43
2323: PUSH
2324: LD_INT 44
2326: PUSH
2327: LD_INT 4
2329: PUSH
2330: LD_INT 5
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: LIST
2337: LIST
2338: LIST
2339: LIST
2340: IN
2341: IFFALSE 2357
// points := points + 10 ;
2343: LD_ADDR_VAR 0 3
2347: PUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 10
2355: PLUS
2356: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher ] then
2357: LD_VAR 0 1
2361: PPUSH
2362: CALL_OW 264
2366: PUSH
2367: LD_INT 28
2369: PUSH
2370: LD_INT 45
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: IN
2381: IFFALSE 2397
// points := points + 20 ;
2383: LD_ADDR_VAR 0 3
2387: PUSH
2388: LD_VAR 0 3
2392: PUSH
2393: LD_INT 20
2395: PLUS
2396: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_heavy_gun , us_heavy_gun ] then
2397: LD_VAR 0 1
2401: PPUSH
2402: CALL_OW 264
2406: PUSH
2407: LD_INT 46
2409: PUSH
2410: LD_INT 6
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: IN
2417: IFFALSE 2433
// points := points + 25 ;
2419: LD_ADDR_VAR 0 3
2423: PUSH
2424: LD_VAR 0 3
2428: PUSH
2429: LD_INT 25
2431: PLUS
2432: ST_TO_ADDR
// if GetWeapon ( veh ) in [ us_laser , us_radar , ar_radar ] then
2433: LD_VAR 0 1
2437: PPUSH
2438: CALL_OW 264
2442: PUSH
2443: LD_INT 9
2445: PUSH
2446: LD_INT 11
2448: PUSH
2449: LD_INT 30
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: IN
2457: IFFALSE 2473
// points := points + 30 ;
2459: LD_ADDR_VAR 0 3
2463: PUSH
2464: LD_VAR 0 3
2468: PUSH
2469: LD_INT 30
2471: PLUS
2472: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_selfpropelled_bomb , ru_time_lapser , ru_rocket , us_double_laser ] then
2473: LD_VAR 0 1
2477: PPUSH
2478: CALL_OW 264
2482: PUSH
2483: LD_INT 29
2485: PUSH
2486: LD_INT 49
2488: PUSH
2489: LD_INT 47
2491: PUSH
2492: LD_INT 10
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: LIST
2499: LIST
2500: IN
2501: IFFALSE 2517
// points := points + 50 ;
2503: LD_ADDR_VAR 0 3
2507: PUSH
2508: LD_VAR 0 3
2512: PUSH
2513: LD_INT 50
2515: PLUS
2516: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_siberium_rocket , us_siberium_rocket ] then
2517: LD_VAR 0 1
2521: PPUSH
2522: CALL_OW 264
2526: PUSH
2527: LD_INT 48
2529: PUSH
2530: LD_INT 8
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: IN
2537: IFFALSE 2553
// points := points + 100 ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_VAR 0 3
2548: PUSH
2549: LD_INT 100
2551: PLUS
2552: ST_TO_ADDR
// result := points ;
2553: LD_ADDR_VAR 0 2
2557: PUSH
2558: LD_VAR 0 3
2562: ST_TO_ADDR
// end ; end_of_file
2563: LD_VAR 0 2
2567: RET
// every 0 0$01 trigger time do var filter , i , side , driver , un ;
2568: LD_EXP 5
2572: IFFALSE 3217
2574: GO 2576
2576: DISABLE
2577: LD_INT 0
2579: PPUSH
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
// begin enable ;
2584: ENABLE
// if tick < 36 then
2585: LD_OWVAR 1
2589: PUSH
2590: LD_INT 36
2592: LESS
2593: IFFALSE 2605
// SetAreaMapShow ( exit_area , 1 ) ;
2595: LD_INT 4
2597: PPUSH
2598: LD_INT 1
2600: PPUSH
2601: CALL_OW 424
// time := time - 0 0$01 ;
2605: LD_ADDR_EXP 5
2609: PUSH
2610: LD_EXP 5
2614: PUSH
2615: LD_INT 35
2617: MINUS
2618: ST_TO_ADDR
// if time = 0 0$00 then
2619: LD_EXP 5
2623: PUSH
2624: LD_INT 0
2626: EQUAL
2627: IFFALSE 2690
// if p1 > p2 and p1 > p3 and p1 > p4 and p1 > p5 then
2629: LD_EXP 7
2633: PUSH
2634: LD_EXP 8
2638: GREATER
2639: PUSH
2640: LD_EXP 7
2644: PUSH
2645: LD_EXP 9
2649: GREATER
2650: AND
2651: PUSH
2652: LD_EXP 7
2656: PUSH
2657: LD_EXP 10
2661: GREATER
2662: AND
2663: PUSH
2664: LD_EXP 7
2668: PUSH
2669: LD_EXP 11
2673: GREATER
2674: AND
2675: IFFALSE 2683
// YouWin else
2677: CALL_OW 103
2681: GO 2690
// YouLost (  ) ;
2683: LD_STRING 
2685: PPUSH
2686: CALL_OW 104
// filter := FilterUnitsInArea ( exit_area , [ f_type , unit_vehicle ] ) ;
2690: LD_ADDR_VAR 0 1
2694: PUSH
2695: LD_INT 4
2697: PPUSH
2698: LD_INT 21
2700: PUSH
2701: LD_INT 2
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 70
2712: ST_TO_ADDR
// if filter then
2713: LD_VAR 0 1
2717: IFFALSE 3007
// for i = 1 to filter do
2719: LD_ADDR_VAR 0 2
2723: PUSH
2724: DOUBLE
2725: LD_INT 1
2727: DEC
2728: ST_TO_ADDR
2729: LD_VAR 0 1
2733: PUSH
2734: FOR_TO
2735: IFFALSE 3005
// begin side := GetSide ( filter [ i ] ) ;
2737: LD_ADDR_VAR 0 3
2741: PUSH
2742: LD_VAR 0 1
2746: PUSH
2747: LD_VAR 0 2
2751: ARRAY
2752: PPUSH
2753: CALL_OW 255
2757: ST_TO_ADDR
// driver := IsDrivenBy ( filter [ i ] ) ;
2758: LD_ADDR_VAR 0 4
2762: PUSH
2763: LD_VAR 0 1
2767: PUSH
2768: LD_VAR 0 2
2772: ARRAY
2773: PPUSH
2774: CALL_OW 311
2778: ST_TO_ADDR
// un := filter [ i ] ;
2779: LD_ADDR_VAR 0 5
2783: PUSH
2784: LD_VAR 0 1
2788: PUSH
2789: LD_VAR 0 2
2793: ARRAY
2794: ST_TO_ADDR
// if IsInUnit ( driver ) then
2795: LD_VAR 0 4
2799: PPUSH
2800: CALL_OW 310
2804: IFFALSE 2815
// ComExitVehicle ( driver ) ;
2806: LD_VAR 0 4
2810: PPUSH
2811: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
2815: LD_INT 10
2817: PPUSH
2818: CALL_OW 67
// RemoveUnit ( filter [ i ] ) ;
2822: LD_VAR 0 1
2826: PUSH
2827: LD_VAR 0 2
2831: ARRAY
2832: PPUSH
2833: CALL_OW 64
// case side of 1 :
2837: LD_VAR 0 3
2841: PUSH
2842: LD_INT 1
2844: DOUBLE
2845: EQUAL
2846: IFTRUE 2850
2848: GO 2874
2850: POP
// p1 := p1 + ScoreBoard ( un ) ; 2 :
2851: LD_ADDR_EXP 7
2855: PUSH
2856: LD_EXP 7
2860: PUSH
2861: LD_VAR 0 5
2865: PPUSH
2866: CALL 1953 0 1
2870: PLUS
2871: ST_TO_ADDR
2872: GO 3003
2874: LD_INT 2
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2906
2882: POP
// p2 := p2 + ScoreBoard ( un ) ; 3 :
2883: LD_ADDR_EXP 8
2887: PUSH
2888: LD_EXP 8
2892: PUSH
2893: LD_VAR 0 5
2897: PPUSH
2898: CALL 1953 0 1
2902: PLUS
2903: ST_TO_ADDR
2904: GO 3003
2906: LD_INT 3
2908: DOUBLE
2909: EQUAL
2910: IFTRUE 2914
2912: GO 2938
2914: POP
// p3 := p3 + ScoreBoard ( un ) ; 4 :
2915: LD_ADDR_EXP 9
2919: PUSH
2920: LD_EXP 9
2924: PUSH
2925: LD_VAR 0 5
2929: PPUSH
2930: CALL 1953 0 1
2934: PLUS
2935: ST_TO_ADDR
2936: GO 3003
2938: LD_INT 4
2940: DOUBLE
2941: EQUAL
2942: IFTRUE 2946
2944: GO 2970
2946: POP
// p4 := p4 + ScoreBoard ( un ) ; 5 :
2947: LD_ADDR_EXP 10
2951: PUSH
2952: LD_EXP 10
2956: PUSH
2957: LD_VAR 0 5
2961: PPUSH
2962: CALL 1953 0 1
2966: PLUS
2967: ST_TO_ADDR
2968: GO 3003
2970: LD_INT 5
2972: DOUBLE
2973: EQUAL
2974: IFTRUE 2978
2976: GO 3002
2978: POP
// p5 := p5 + ScoreBoard ( un ) ; end ;
2979: LD_ADDR_EXP 11
2983: PUSH
2984: LD_EXP 11
2988: PUSH
2989: LD_VAR 0 5
2993: PPUSH
2994: CALL 1953 0 1
2998: PLUS
2999: ST_TO_ADDR
3000: GO 3003
3002: POP
// end ;
3003: GO 2734
3005: POP
3006: POP
// case players of 3 :
3007: LD_EXP 3
3011: PUSH
3012: LD_INT 3
3014: DOUBLE
3015: EQUAL
3016: IFTRUE 3020
3018: GO 3070
3020: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 ] ;
3021: LD_ADDR_OWVAR 47
3025: PUSH
3026: LD_STRING #tick
3028: PUSH
3029: LD_EXP 5
3033: PUSH
3034: LD_STRING #player1
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_STRING #player2
3044: PUSH
3045: LD_EXP 8
3049: PUSH
3050: LD_STRING #player3
3052: PUSH
3053: LD_EXP 9
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: ST_TO_ADDR
// end ; 4 :
3068: GO 3217
3070: LD_INT 4
3072: DOUBLE
3073: EQUAL
3074: IFTRUE 3078
3076: GO 3138
3078: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 ] ;
3079: LD_ADDR_OWVAR 47
3083: PUSH
3084: LD_STRING #tick
3086: PUSH
3087: LD_EXP 5
3091: PUSH
3092: LD_STRING #player1
3094: PUSH
3095: LD_EXP 7
3099: PUSH
3100: LD_STRING #player2
3102: PUSH
3103: LD_EXP 8
3107: PUSH
3108: LD_STRING #player3
3110: PUSH
3111: LD_EXP 9
3115: PUSH
3116: LD_STRING #player4
3118: PUSH
3119: LD_EXP 10
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: ST_TO_ADDR
// end ; 5 :
3136: GO 3217
3138: LD_INT 5
3140: DOUBLE
3141: EQUAL
3142: IFTRUE 3146
3144: GO 3216
3146: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 , #player5 , p5 ] ;
3147: LD_ADDR_OWVAR 47
3151: PUSH
3152: LD_STRING #tick
3154: PUSH
3155: LD_EXP 5
3159: PUSH
3160: LD_STRING #player1
3162: PUSH
3163: LD_EXP 7
3167: PUSH
3168: LD_STRING #player2
3170: PUSH
3171: LD_EXP 8
3175: PUSH
3176: LD_STRING #player3
3178: PUSH
3179: LD_EXP 9
3183: PUSH
3184: LD_STRING #player4
3186: PUSH
3187: LD_EXP 10
3191: PUSH
3192: LD_STRING #player5
3194: PUSH
3195: LD_EXP 11
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: ST_TO_ADDR
// end ; end ;
3214: GO 3217
3216: POP
// end ;
3217: PPOPN 5
3219: END
// every 0 0$05 trigger time do var chance , p ;
3220: LD_EXP 5
3224: IFFALSE 3371
3226: GO 3228
3228: DISABLE
3229: LD_INT 0
3231: PPUSH
3232: PPUSH
// begin enable ;
3233: ENABLE
// Wait ( Rand ( 0 0$01 , 0 0$06 ) ) ;
3234: LD_INT 35
3236: PPUSH
3237: LD_INT 210
3239: PPUSH
3240: CALL_OW 12
3244: PPUSH
3245: CALL_OW 67
// if FilterAllUnits ( [ f_type , unit_vehicle ] ) < veh_amount then
3249: LD_INT 21
3251: PUSH
3252: LD_INT 2
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PPUSH
3259: CALL_OW 69
3263: PUSH
3264: LD_EXP 6
3268: LESS
3269: IFFALSE 3371
// begin SpawnCar ( false , veh_spawn ) ;
3271: LD_INT 0
3273: PPUSH
3274: LD_INT 5
3276: PPUSH
3277: CALL 946 0 2
// if sib_bomb and FilterAllUnits ( [ f_or , [ [ f_weapon , us_siberium_rocket ] , [ f_weapon , ru_siberium_rocket ] ] ] ) = 0 then
3281: LD_EXP 4
3285: PUSH
3286: LD_INT 2
3288: PUSH
3289: LD_INT 34
3291: PUSH
3292: LD_INT 8
3294: PUSH
3295: EMPTY
3296: LIST
3297: LIST
3298: PUSH
3299: LD_INT 34
3301: PUSH
3302: LD_INT 48
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PPUSH
3317: CALL_OW 69
3321: PUSH
3322: LD_INT 0
3324: EQUAL
3325: AND
3326: IFFALSE 3371
// begin chance := 23 ;
3328: LD_ADDR_VAR 0 1
3332: PUSH
3333: LD_INT 23
3335: ST_TO_ADDR
// p := Rand ( 0 , 100 ) ;
3336: LD_ADDR_VAR 0 2
3340: PUSH
3341: LD_INT 0
3343: PPUSH
3344: LD_INT 100
3346: PPUSH
3347: CALL_OW 12
3351: ST_TO_ADDR
// if p < chance then
3352: LD_VAR 0 2
3356: PUSH
3357: LD_VAR 0 1
3361: LESS
3362: IFFALSE 3371
// SpawnSibRocket ( veh_spawn ) ;
3364: LD_INT 5
3366: PPUSH
3367: CALL 1784 0 1
// end ; end ; end ; end_of_file
3371: PPOPN 2
3373: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
3374: LD_INT 0
3376: PPUSH
3377: PPUSH
3378: PPUSH
3379: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
3380: LD_VAR 0 1
3384: PPUSH
3385: CALL_OW 264
3389: PUSH
3390: LD_EXP 70
3394: EQUAL
3395: IFFALSE 3467
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
3397: LD_INT 68
3399: PPUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 255
3409: PPUSH
3410: CALL_OW 321
3414: PUSH
3415: LD_INT 2
3417: EQUAL
3418: IFFALSE 3430
// eff := 70 else
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: LD_INT 70
3427: ST_TO_ADDR
3428: GO 3438
// eff := 30 ;
3430: LD_ADDR_VAR 0 4
3434: PUSH
3435: LD_INT 30
3437: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
3438: LD_VAR 0 1
3442: PPUSH
3443: CALL_OW 250
3447: PPUSH
3448: LD_VAR 0 1
3452: PPUSH
3453: CALL_OW 251
3457: PPUSH
3458: LD_VAR 0 4
3462: PPUSH
3463: CALL_OW 495
// end ; end ;
3467: LD_VAR 0 2
3471: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
3472: LD_INT 0
3474: PPUSH
// end ;
3475: LD_VAR 0 4
3479: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
3480: LD_INT 0
3482: PPUSH
3483: PPUSH
3484: PPUSH
3485: PPUSH
3486: PPUSH
3487: PPUSH
// if cmd = 124 then
3488: LD_VAR 0 1
3492: PUSH
3493: LD_INT 124
3495: EQUAL
3496: IFFALSE 3702
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
3498: LD_ADDR_VAR 0 5
3502: PUSH
3503: LD_INT 2
3505: PUSH
3506: LD_INT 34
3508: PUSH
3509: LD_INT 53
3511: PUSH
3512: EMPTY
3513: LIST
3514: LIST
3515: PUSH
3516: LD_INT 34
3518: PUSH
3519: LD_INT 14
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: PUSH
3526: EMPTY
3527: LIST
3528: LIST
3529: LIST
3530: PPUSH
3531: CALL_OW 69
3535: ST_TO_ADDR
// if not tmp then
3536: LD_VAR 0 5
3540: NOT
3541: IFFALSE 3545
// exit ;
3543: GO 3702
// for i in tmp do
3545: LD_ADDR_VAR 0 3
3549: PUSH
3550: LD_VAR 0 5
3554: PUSH
3555: FOR_IN
3556: IFFALSE 3700
// begin taskList := GetTaskList ( i ) ;
3558: LD_ADDR_VAR 0 6
3562: PUSH
3563: LD_VAR 0 3
3567: PPUSH
3568: CALL_OW 437
3572: ST_TO_ADDR
// if not taskList then
3573: LD_VAR 0 6
3577: NOT
3578: IFFALSE 3582
// continue ;
3580: GO 3555
// for j = 1 to taskList do
3582: LD_ADDR_VAR 0 4
3586: PUSH
3587: DOUBLE
3588: LD_INT 1
3590: DEC
3591: ST_TO_ADDR
3592: LD_VAR 0 6
3596: PUSH
3597: FOR_TO
3598: IFFALSE 3696
// if taskList [ j ] [ 1 ] = | then
3600: LD_VAR 0 6
3604: PUSH
3605: LD_VAR 0 4
3609: ARRAY
3610: PUSH
3611: LD_INT 1
3613: ARRAY
3614: PUSH
3615: LD_STRING |
3617: EQUAL
3618: IFFALSE 3694
// begin _taskList := Delete ( taskList , 1 ) ;
3620: LD_ADDR_VAR 0 7
3624: PUSH
3625: LD_VAR 0 6
3629: PPUSH
3630: LD_INT 1
3632: PPUSH
3633: CALL_OW 3
3637: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
3638: LD_VAR 0 3
3642: PPUSH
3643: LD_VAR 0 7
3647: PPUSH
3648: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
3652: LD_VAR 0 3
3656: PPUSH
3657: LD_VAR 0 6
3661: PUSH
3662: LD_VAR 0 4
3666: ARRAY
3667: PUSH
3668: LD_INT 2
3670: ARRAY
3671: PPUSH
3672: LD_VAR 0 6
3676: PUSH
3677: LD_VAR 0 4
3681: ARRAY
3682: PUSH
3683: LD_INT 3
3685: ARRAY
3686: PPUSH
3687: LD_INT 8
3689: PPUSH
3690: CALL 3707 0 4
// end ;
3694: GO 3597
3696: POP
3697: POP
// end ;
3698: GO 3555
3700: POP
3701: POP
// end ; end ;
3702: LD_VAR 0 2
3706: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
3707: LD_INT 0
3709: PPUSH
3710: PPUSH
3711: PPUSH
3712: PPUSH
3713: PPUSH
3714: PPUSH
3715: PPUSH
3716: PPUSH
3717: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
3718: LD_VAR 0 1
3722: NOT
3723: PUSH
3724: LD_VAR 0 2
3728: PPUSH
3729: LD_VAR 0 3
3733: PPUSH
3734: CALL_OW 488
3738: NOT
3739: OR
3740: PUSH
3741: LD_VAR 0 4
3745: NOT
3746: OR
3747: IFFALSE 3751
// exit ;
3749: GO 4091
// list := [ ] ;
3751: LD_ADDR_VAR 0 13
3755: PUSH
3756: EMPTY
3757: ST_TO_ADDR
// if x - r < 0 then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_VAR 0 4
3767: MINUS
3768: PUSH
3769: LD_INT 0
3771: LESS
3772: IFFALSE 3784
// min_x := 0 else
3774: LD_ADDR_VAR 0 7
3778: PUSH
3779: LD_INT 0
3781: ST_TO_ADDR
3782: GO 3800
// min_x := x - r ;
3784: LD_ADDR_VAR 0 7
3788: PUSH
3789: LD_VAR 0 2
3793: PUSH
3794: LD_VAR 0 4
3798: MINUS
3799: ST_TO_ADDR
// if y - r < 0 then
3800: LD_VAR 0 3
3804: PUSH
3805: LD_VAR 0 4
3809: MINUS
3810: PUSH
3811: LD_INT 0
3813: LESS
3814: IFFALSE 3826
// min_y := 0 else
3816: LD_ADDR_VAR 0 8
3820: PUSH
3821: LD_INT 0
3823: ST_TO_ADDR
3824: GO 3842
// min_y := y - r ;
3826: LD_ADDR_VAR 0 8
3830: PUSH
3831: LD_VAR 0 3
3835: PUSH
3836: LD_VAR 0 4
3840: MINUS
3841: ST_TO_ADDR
// max_x := x + r ;
3842: LD_ADDR_VAR 0 9
3846: PUSH
3847: LD_VAR 0 2
3851: PUSH
3852: LD_VAR 0 4
3856: PLUS
3857: ST_TO_ADDR
// max_y := y + r ;
3858: LD_ADDR_VAR 0 10
3862: PUSH
3863: LD_VAR 0 3
3867: PUSH
3868: LD_VAR 0 4
3872: PLUS
3873: ST_TO_ADDR
// for _x = min_x to max_x do
3874: LD_ADDR_VAR 0 11
3878: PUSH
3879: DOUBLE
3880: LD_VAR 0 7
3884: DEC
3885: ST_TO_ADDR
3886: LD_VAR 0 9
3890: PUSH
3891: FOR_TO
3892: IFFALSE 4009
// for _y = min_y to max_y do
3894: LD_ADDR_VAR 0 12
3898: PUSH
3899: DOUBLE
3900: LD_VAR 0 8
3904: DEC
3905: ST_TO_ADDR
3906: LD_VAR 0 10
3910: PUSH
3911: FOR_TO
3912: IFFALSE 4005
// begin if not ValidHex ( _x , _y ) then
3914: LD_VAR 0 11
3918: PPUSH
3919: LD_VAR 0 12
3923: PPUSH
3924: CALL_OW 488
3928: NOT
3929: IFFALSE 3933
// continue ;
3931: GO 3911
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
3933: LD_VAR 0 11
3937: PPUSH
3938: LD_VAR 0 12
3942: PPUSH
3943: CALL_OW 351
3947: PUSH
3948: LD_VAR 0 11
3952: PPUSH
3953: LD_VAR 0 12
3957: PPUSH
3958: CALL_OW 554
3962: AND
3963: IFFALSE 4003
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
3965: LD_ADDR_VAR 0 13
3969: PUSH
3970: LD_VAR 0 13
3974: PPUSH
3975: LD_VAR 0 13
3979: PUSH
3980: LD_INT 1
3982: PLUS
3983: PPUSH
3984: LD_VAR 0 11
3988: PUSH
3989: LD_VAR 0 12
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: PPUSH
3998: CALL_OW 2
4002: ST_TO_ADDR
// end ;
4003: GO 3911
4005: POP
4006: POP
4007: GO 3891
4009: POP
4010: POP
// if not list then
4011: LD_VAR 0 13
4015: NOT
4016: IFFALSE 4020
// exit ;
4018: GO 4091
// for i in list do
4020: LD_ADDR_VAR 0 6
4024: PUSH
4025: LD_VAR 0 13
4029: PUSH
4030: FOR_IN
4031: IFFALSE 4089
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
4033: LD_VAR 0 1
4037: PPUSH
4038: LD_STRING M
4040: PUSH
4041: LD_VAR 0 6
4045: PUSH
4046: LD_INT 1
4048: ARRAY
4049: PUSH
4050: LD_VAR 0 6
4054: PUSH
4055: LD_INT 2
4057: ARRAY
4058: PUSH
4059: LD_INT 0
4061: PUSH
4062: LD_INT 0
4064: PUSH
4065: LD_INT 0
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: LIST
4078: LIST
4079: PUSH
4080: EMPTY
4081: LIST
4082: PPUSH
4083: CALL_OW 447
4087: GO 4030
4089: POP
4090: POP
// end ; end_of_file
4091: LD_VAR 0 5
4095: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
4096: GO 4098
4098: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4099: LD_STRING initStreamRollete();
4101: PPUSH
4102: CALL_OW 559
// InitStreamMode ;
4106: CALL 4115 0 0
// DefineStreamItems ( ) ;
4110: CALL 4555 0 0
// end ;
4114: END
// function InitStreamMode ; begin
4115: LD_INT 0
4117: PPUSH
// streamModeActive := false ;
4118: LD_ADDR_EXP 12
4122: PUSH
4123: LD_INT 0
4125: ST_TO_ADDR
// normalCounter := 36 ;
4126: LD_ADDR_EXP 13
4130: PUSH
4131: LD_INT 36
4133: ST_TO_ADDR
// hardcoreCounter := 16 ;
4134: LD_ADDR_EXP 14
4138: PUSH
4139: LD_INT 16
4141: ST_TO_ADDR
// sRocket := false ;
4142: LD_ADDR_EXP 17
4146: PUSH
4147: LD_INT 0
4149: ST_TO_ADDR
// sSpeed := false ;
4150: LD_ADDR_EXP 16
4154: PUSH
4155: LD_INT 0
4157: ST_TO_ADDR
// sEngine := false ;
4158: LD_ADDR_EXP 18
4162: PUSH
4163: LD_INT 0
4165: ST_TO_ADDR
// sSpec := false ;
4166: LD_ADDR_EXP 15
4170: PUSH
4171: LD_INT 0
4173: ST_TO_ADDR
// sLevel := false ;
4174: LD_ADDR_EXP 19
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// sArmoury := false ;
4182: LD_ADDR_EXP 20
4186: PUSH
4187: LD_INT 0
4189: ST_TO_ADDR
// sRadar := false ;
4190: LD_ADDR_EXP 21
4194: PUSH
4195: LD_INT 0
4197: ST_TO_ADDR
// sBunker := false ;
4198: LD_ADDR_EXP 22
4202: PUSH
4203: LD_INT 0
4205: ST_TO_ADDR
// sHack := false ;
4206: LD_ADDR_EXP 23
4210: PUSH
4211: LD_INT 0
4213: ST_TO_ADDR
// sFire := false ;
4214: LD_ADDR_EXP 24
4218: PUSH
4219: LD_INT 0
4221: ST_TO_ADDR
// sRefresh := false ;
4222: LD_ADDR_EXP 25
4226: PUSH
4227: LD_INT 0
4229: ST_TO_ADDR
// sExp := false ;
4230: LD_ADDR_EXP 26
4234: PUSH
4235: LD_INT 0
4237: ST_TO_ADDR
// sDepot := false ;
4238: LD_ADDR_EXP 27
4242: PUSH
4243: LD_INT 0
4245: ST_TO_ADDR
// sFlag := false ;
4246: LD_ADDR_EXP 28
4250: PUSH
4251: LD_INT 0
4253: ST_TO_ADDR
// sKamikadze := false ;
4254: LD_ADDR_EXP 36
4258: PUSH
4259: LD_INT 0
4261: ST_TO_ADDR
// sTroll := false ;
4262: LD_ADDR_EXP 37
4266: PUSH
4267: LD_INT 0
4269: ST_TO_ADDR
// sSlow := false ;
4270: LD_ADDR_EXP 38
4274: PUSH
4275: LD_INT 0
4277: ST_TO_ADDR
// sLack := false ;
4278: LD_ADDR_EXP 39
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// sTank := false ;
4286: LD_ADDR_EXP 41
4290: PUSH
4291: LD_INT 0
4293: ST_TO_ADDR
// sRemote := false ;
4294: LD_ADDR_EXP 42
4298: PUSH
4299: LD_INT 0
4301: ST_TO_ADDR
// sPowell := false ;
4302: LD_ADDR_EXP 43
4306: PUSH
4307: LD_INT 0
4309: ST_TO_ADDR
// sTeleport := false ;
4310: LD_ADDR_EXP 46
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// sOilTower := false ;
4318: LD_ADDR_EXP 48
4322: PUSH
4323: LD_INT 0
4325: ST_TO_ADDR
// sShovel := false ;
4326: LD_ADDR_EXP 49
4330: PUSH
4331: LD_INT 0
4333: ST_TO_ADDR
// sSheik := false ;
4334: LD_ADDR_EXP 50
4338: PUSH
4339: LD_INT 0
4341: ST_TO_ADDR
// sEarthquake := false ;
4342: LD_ADDR_EXP 52
4346: PUSH
4347: LD_INT 0
4349: ST_TO_ADDR
// sAI := false ;
4350: LD_ADDR_EXP 53
4354: PUSH
4355: LD_INT 0
4357: ST_TO_ADDR
// sCargo := false ;
4358: LD_ADDR_EXP 56
4362: PUSH
4363: LD_INT 0
4365: ST_TO_ADDR
// sDLaser := false ;
4366: LD_ADDR_EXP 57
4370: PUSH
4371: LD_INT 0
4373: ST_TO_ADDR
// sExchange := false ;
4374: LD_ADDR_EXP 58
4378: PUSH
4379: LD_INT 0
4381: ST_TO_ADDR
// sFac := false ;
4382: LD_ADDR_EXP 59
4386: PUSH
4387: LD_INT 0
4389: ST_TO_ADDR
// sPower := false ;
4390: LD_ADDR_EXP 60
4394: PUSH
4395: LD_INT 0
4397: ST_TO_ADDR
// sRandom := false ;
4398: LD_ADDR_EXP 61
4402: PUSH
4403: LD_INT 0
4405: ST_TO_ADDR
// sShield := false ;
4406: LD_ADDR_EXP 62
4410: PUSH
4411: LD_INT 0
4413: ST_TO_ADDR
// sTime := false ;
4414: LD_ADDR_EXP 63
4418: PUSH
4419: LD_INT 0
4421: ST_TO_ADDR
// sTools := false ;
4422: LD_ADDR_EXP 64
4426: PUSH
4427: LD_INT 0
4429: ST_TO_ADDR
// sSold := false ;
4430: LD_ADDR_EXP 29
4434: PUSH
4435: LD_INT 0
4437: ST_TO_ADDR
// sDiff := false ;
4438: LD_ADDR_EXP 30
4442: PUSH
4443: LD_INT 0
4445: ST_TO_ADDR
// sFog := false ;
4446: LD_ADDR_EXP 33
4450: PUSH
4451: LD_INT 0
4453: ST_TO_ADDR
// sReset := false ;
4454: LD_ADDR_EXP 34
4458: PUSH
4459: LD_INT 0
4461: ST_TO_ADDR
// sSun := false ;
4462: LD_ADDR_EXP 35
4466: PUSH
4467: LD_INT 0
4469: ST_TO_ADDR
// sTiger := false ;
4470: LD_ADDR_EXP 31
4474: PUSH
4475: LD_INT 0
4477: ST_TO_ADDR
// sBomb := false ;
4478: LD_ADDR_EXP 32
4482: PUSH
4483: LD_INT 0
4485: ST_TO_ADDR
// sWound := false ;
4486: LD_ADDR_EXP 40
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// sBetray := false ;
4494: LD_ADDR_EXP 44
4498: PUSH
4499: LD_INT 0
4501: ST_TO_ADDR
// sContamin := false ;
4502: LD_ADDR_EXP 45
4506: PUSH
4507: LD_INT 0
4509: ST_TO_ADDR
// sOil := false ;
4510: LD_ADDR_EXP 47
4514: PUSH
4515: LD_INT 0
4517: ST_TO_ADDR
// sStu := false ;
4518: LD_ADDR_EXP 51
4522: PUSH
4523: LD_INT 0
4525: ST_TO_ADDR
// sBazooka := false ;
4526: LD_ADDR_EXP 54
4530: PUSH
4531: LD_INT 0
4533: ST_TO_ADDR
// sMortar := false ;
4534: LD_ADDR_EXP 55
4538: PUSH
4539: LD_INT 0
4541: ST_TO_ADDR
// sRanger := false ;
4542: LD_ADDR_EXP 65
4546: PUSH
4547: LD_INT 0
4549: ST_TO_ADDR
// end ;
4550: LD_VAR 0 1
4554: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
4555: LD_INT 0
4557: PPUSH
4558: PPUSH
4559: PPUSH
4560: PPUSH
4561: PPUSH
// result := [ ] ;
4562: LD_ADDR_VAR 0 1
4566: PUSH
4567: EMPTY
4568: ST_TO_ADDR
// if campaign_id = 1 then
4569: LD_OWVAR 69
4573: PUSH
4574: LD_INT 1
4576: EQUAL
4577: IFFALSE 7515
// begin case mission_number of 1 :
4579: LD_OWVAR 70
4583: PUSH
4584: LD_INT 1
4586: DOUBLE
4587: EQUAL
4588: IFTRUE 4592
4590: GO 4656
4592: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
4593: LD_ADDR_VAR 0 1
4597: PUSH
4598: LD_INT 2
4600: PUSH
4601: LD_INT 4
4603: PUSH
4604: LD_INT 11
4606: PUSH
4607: LD_INT 12
4609: PUSH
4610: LD_INT 15
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 23
4621: PUSH
4622: LD_INT 26
4624: PUSH
4625: EMPTY
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: PUSH
4636: LD_INT 101
4638: PUSH
4639: LD_INT 102
4641: PUSH
4642: LD_INT 106
4644: PUSH
4645: EMPTY
4646: LIST
4647: LIST
4648: LIST
4649: PUSH
4650: EMPTY
4651: LIST
4652: LIST
4653: ST_TO_ADDR
4654: GO 7513
4656: LD_INT 2
4658: DOUBLE
4659: EQUAL
4660: IFTRUE 4664
4662: GO 4736
4664: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
4665: LD_ADDR_VAR 0 1
4669: PUSH
4670: LD_INT 2
4672: PUSH
4673: LD_INT 4
4675: PUSH
4676: LD_INT 11
4678: PUSH
4679: LD_INT 12
4681: PUSH
4682: LD_INT 15
4684: PUSH
4685: LD_INT 16
4687: PUSH
4688: LD_INT 22
4690: PUSH
4691: LD_INT 23
4693: PUSH
4694: LD_INT 26
4696: PUSH
4697: EMPTY
4698: LIST
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: PUSH
4708: LD_INT 101
4710: PUSH
4711: LD_INT 102
4713: PUSH
4714: LD_INT 105
4716: PUSH
4717: LD_INT 106
4719: PUSH
4720: LD_INT 108
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: ST_TO_ADDR
4734: GO 7513
4736: LD_INT 3
4738: DOUBLE
4739: EQUAL
4740: IFTRUE 4744
4742: GO 4820
4744: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
4745: LD_ADDR_VAR 0 1
4749: PUSH
4750: LD_INT 2
4752: PUSH
4753: LD_INT 4
4755: PUSH
4756: LD_INT 5
4758: PUSH
4759: LD_INT 11
4761: PUSH
4762: LD_INT 12
4764: PUSH
4765: LD_INT 15
4767: PUSH
4768: LD_INT 16
4770: PUSH
4771: LD_INT 22
4773: PUSH
4774: LD_INT 26
4776: PUSH
4777: LD_INT 36
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: PUSH
4792: LD_INT 101
4794: PUSH
4795: LD_INT 102
4797: PUSH
4798: LD_INT 105
4800: PUSH
4801: LD_INT 106
4803: PUSH
4804: LD_INT 108
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: ST_TO_ADDR
4818: GO 7513
4820: LD_INT 4
4822: DOUBLE
4823: EQUAL
4824: IFTRUE 4828
4826: GO 4912
4828: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
4829: LD_ADDR_VAR 0 1
4833: PUSH
4834: LD_INT 2
4836: PUSH
4837: LD_INT 4
4839: PUSH
4840: LD_INT 5
4842: PUSH
4843: LD_INT 8
4845: PUSH
4846: LD_INT 11
4848: PUSH
4849: LD_INT 12
4851: PUSH
4852: LD_INT 15
4854: PUSH
4855: LD_INT 16
4857: PUSH
4858: LD_INT 22
4860: PUSH
4861: LD_INT 23
4863: PUSH
4864: LD_INT 26
4866: PUSH
4867: LD_INT 36
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 101
4886: PUSH
4887: LD_INT 102
4889: PUSH
4890: LD_INT 105
4892: PUSH
4893: LD_INT 106
4895: PUSH
4896: LD_INT 108
4898: PUSH
4899: EMPTY
4900: LIST
4901: LIST
4902: LIST
4903: LIST
4904: LIST
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: ST_TO_ADDR
4910: GO 7513
4912: LD_INT 5
4914: DOUBLE
4915: EQUAL
4916: IFTRUE 4920
4918: GO 5020
4920: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
4921: LD_ADDR_VAR 0 1
4925: PUSH
4926: LD_INT 2
4928: PUSH
4929: LD_INT 4
4931: PUSH
4932: LD_INT 5
4934: PUSH
4935: LD_INT 6
4937: PUSH
4938: LD_INT 8
4940: PUSH
4941: LD_INT 11
4943: PUSH
4944: LD_INT 12
4946: PUSH
4947: LD_INT 15
4949: PUSH
4950: LD_INT 16
4952: PUSH
4953: LD_INT 22
4955: PUSH
4956: LD_INT 23
4958: PUSH
4959: LD_INT 25
4961: PUSH
4962: LD_INT 26
4964: PUSH
4965: LD_INT 36
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: LIST
4983: PUSH
4984: LD_INT 101
4986: PUSH
4987: LD_INT 102
4989: PUSH
4990: LD_INT 105
4992: PUSH
4993: LD_INT 106
4995: PUSH
4996: LD_INT 108
4998: PUSH
4999: LD_INT 109
5001: PUSH
5002: LD_INT 112
5004: PUSH
5005: EMPTY
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: ST_TO_ADDR
5018: GO 7513
5020: LD_INT 6
5022: DOUBLE
5023: EQUAL
5024: IFTRUE 5028
5026: GO 5148
5028: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
5029: LD_ADDR_VAR 0 1
5033: PUSH
5034: LD_INT 2
5036: PUSH
5037: LD_INT 4
5039: PUSH
5040: LD_INT 5
5042: PUSH
5043: LD_INT 6
5045: PUSH
5046: LD_INT 8
5048: PUSH
5049: LD_INT 11
5051: PUSH
5052: LD_INT 12
5054: PUSH
5055: LD_INT 15
5057: PUSH
5058: LD_INT 16
5060: PUSH
5061: LD_INT 20
5063: PUSH
5064: LD_INT 21
5066: PUSH
5067: LD_INT 22
5069: PUSH
5070: LD_INT 23
5072: PUSH
5073: LD_INT 25
5075: PUSH
5076: LD_INT 26
5078: PUSH
5079: LD_INT 30
5081: PUSH
5082: LD_INT 31
5084: PUSH
5085: LD_INT 32
5087: PUSH
5088: LD_INT 36
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: LIST
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: PUSH
5112: LD_INT 101
5114: PUSH
5115: LD_INT 102
5117: PUSH
5118: LD_INT 105
5120: PUSH
5121: LD_INT 106
5123: PUSH
5124: LD_INT 108
5126: PUSH
5127: LD_INT 109
5129: PUSH
5130: LD_INT 112
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: LIST
5137: LIST
5138: LIST
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: ST_TO_ADDR
5146: GO 7513
5148: LD_INT 7
5150: DOUBLE
5151: EQUAL
5152: IFTRUE 5156
5154: GO 5256
5156: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
5157: LD_ADDR_VAR 0 1
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: LD_INT 4
5167: PUSH
5168: LD_INT 5
5170: PUSH
5171: LD_INT 7
5173: PUSH
5174: LD_INT 11
5176: PUSH
5177: LD_INT 12
5179: PUSH
5180: LD_INT 15
5182: PUSH
5183: LD_INT 16
5185: PUSH
5186: LD_INT 20
5188: PUSH
5189: LD_INT 21
5191: PUSH
5192: LD_INT 22
5194: PUSH
5195: LD_INT 23
5197: PUSH
5198: LD_INT 25
5200: PUSH
5201: LD_INT 26
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: LIST
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 101
5222: PUSH
5223: LD_INT 102
5225: PUSH
5226: LD_INT 103
5228: PUSH
5229: LD_INT 105
5231: PUSH
5232: LD_INT 106
5234: PUSH
5235: LD_INT 108
5237: PUSH
5238: LD_INT 112
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: ST_TO_ADDR
5254: GO 7513
5256: LD_INT 8
5258: DOUBLE
5259: EQUAL
5260: IFTRUE 5264
5262: GO 5392
5264: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
5265: LD_ADDR_VAR 0 1
5269: PUSH
5270: LD_INT 2
5272: PUSH
5273: LD_INT 4
5275: PUSH
5276: LD_INT 5
5278: PUSH
5279: LD_INT 6
5281: PUSH
5282: LD_INT 7
5284: PUSH
5285: LD_INT 8
5287: PUSH
5288: LD_INT 11
5290: PUSH
5291: LD_INT 12
5293: PUSH
5294: LD_INT 15
5296: PUSH
5297: LD_INT 16
5299: PUSH
5300: LD_INT 20
5302: PUSH
5303: LD_INT 21
5305: PUSH
5306: LD_INT 22
5308: PUSH
5309: LD_INT 23
5311: PUSH
5312: LD_INT 25
5314: PUSH
5315: LD_INT 26
5317: PUSH
5318: LD_INT 30
5320: PUSH
5321: LD_INT 31
5323: PUSH
5324: LD_INT 32
5326: PUSH
5327: LD_INT 36
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: LIST
5335: LIST
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: PUSH
5352: LD_INT 101
5354: PUSH
5355: LD_INT 102
5357: PUSH
5358: LD_INT 103
5360: PUSH
5361: LD_INT 105
5363: PUSH
5364: LD_INT 106
5366: PUSH
5367: LD_INT 108
5369: PUSH
5370: LD_INT 109
5372: PUSH
5373: LD_INT 112
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: LIST
5380: LIST
5381: LIST
5382: LIST
5383: LIST
5384: LIST
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: ST_TO_ADDR
5390: GO 7513
5392: LD_INT 9
5394: DOUBLE
5395: EQUAL
5396: IFTRUE 5400
5398: GO 5536
5400: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
5401: LD_ADDR_VAR 0 1
5405: PUSH
5406: LD_INT 2
5408: PUSH
5409: LD_INT 4
5411: PUSH
5412: LD_INT 5
5414: PUSH
5415: LD_INT 6
5417: PUSH
5418: LD_INT 7
5420: PUSH
5421: LD_INT 8
5423: PUSH
5424: LD_INT 11
5426: PUSH
5427: LD_INT 12
5429: PUSH
5430: LD_INT 15
5432: PUSH
5433: LD_INT 16
5435: PUSH
5436: LD_INT 20
5438: PUSH
5439: LD_INT 21
5441: PUSH
5442: LD_INT 22
5444: PUSH
5445: LD_INT 23
5447: PUSH
5448: LD_INT 25
5450: PUSH
5451: LD_INT 26
5453: PUSH
5454: LD_INT 28
5456: PUSH
5457: LD_INT 30
5459: PUSH
5460: LD_INT 31
5462: PUSH
5463: LD_INT 32
5465: PUSH
5466: LD_INT 36
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: LIST
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: LIST
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: LIST
5491: PUSH
5492: LD_INT 101
5494: PUSH
5495: LD_INT 102
5497: PUSH
5498: LD_INT 103
5500: PUSH
5501: LD_INT 105
5503: PUSH
5504: LD_INT 106
5506: PUSH
5507: LD_INT 108
5509: PUSH
5510: LD_INT 109
5512: PUSH
5513: LD_INT 112
5515: PUSH
5516: LD_INT 114
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: ST_TO_ADDR
5534: GO 7513
5536: LD_INT 10
5538: DOUBLE
5539: EQUAL
5540: IFTRUE 5544
5542: GO 5728
5544: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
5545: LD_ADDR_VAR 0 1
5549: PUSH
5550: LD_INT 2
5552: PUSH
5553: LD_INT 4
5555: PUSH
5556: LD_INT 5
5558: PUSH
5559: LD_INT 6
5561: PUSH
5562: LD_INT 7
5564: PUSH
5565: LD_INT 8
5567: PUSH
5568: LD_INT 9
5570: PUSH
5571: LD_INT 10
5573: PUSH
5574: LD_INT 11
5576: PUSH
5577: LD_INT 12
5579: PUSH
5580: LD_INT 13
5582: PUSH
5583: LD_INT 14
5585: PUSH
5586: LD_INT 15
5588: PUSH
5589: LD_INT 16
5591: PUSH
5592: LD_INT 17
5594: PUSH
5595: LD_INT 18
5597: PUSH
5598: LD_INT 19
5600: PUSH
5601: LD_INT 20
5603: PUSH
5604: LD_INT 21
5606: PUSH
5607: LD_INT 22
5609: PUSH
5610: LD_INT 23
5612: PUSH
5613: LD_INT 24
5615: PUSH
5616: LD_INT 25
5618: PUSH
5619: LD_INT 26
5621: PUSH
5622: LD_INT 28
5624: PUSH
5625: LD_INT 30
5627: PUSH
5628: LD_INT 31
5630: PUSH
5631: LD_INT 32
5633: PUSH
5634: LD_INT 36
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 101
5670: PUSH
5671: LD_INT 102
5673: PUSH
5674: LD_INT 103
5676: PUSH
5677: LD_INT 104
5679: PUSH
5680: LD_INT 105
5682: PUSH
5683: LD_INT 106
5685: PUSH
5686: LD_INT 107
5688: PUSH
5689: LD_INT 108
5691: PUSH
5692: LD_INT 109
5694: PUSH
5695: LD_INT 110
5697: PUSH
5698: LD_INT 111
5700: PUSH
5701: LD_INT 112
5703: PUSH
5704: LD_INT 114
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: ST_TO_ADDR
5726: GO 7513
5728: LD_INT 11
5730: DOUBLE
5731: EQUAL
5732: IFTRUE 5736
5734: GO 5928
5736: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
5737: LD_ADDR_VAR 0 1
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 3
5747: PUSH
5748: LD_INT 4
5750: PUSH
5751: LD_INT 5
5753: PUSH
5754: LD_INT 6
5756: PUSH
5757: LD_INT 7
5759: PUSH
5760: LD_INT 8
5762: PUSH
5763: LD_INT 9
5765: PUSH
5766: LD_INT 10
5768: PUSH
5769: LD_INT 11
5771: PUSH
5772: LD_INT 12
5774: PUSH
5775: LD_INT 13
5777: PUSH
5778: LD_INT 14
5780: PUSH
5781: LD_INT 15
5783: PUSH
5784: LD_INT 16
5786: PUSH
5787: LD_INT 17
5789: PUSH
5790: LD_INT 18
5792: PUSH
5793: LD_INT 19
5795: PUSH
5796: LD_INT 20
5798: PUSH
5799: LD_INT 21
5801: PUSH
5802: LD_INT 22
5804: PUSH
5805: LD_INT 23
5807: PUSH
5808: LD_INT 24
5810: PUSH
5811: LD_INT 25
5813: PUSH
5814: LD_INT 26
5816: PUSH
5817: LD_INT 28
5819: PUSH
5820: LD_INT 30
5822: PUSH
5823: LD_INT 31
5825: PUSH
5826: LD_INT 32
5828: PUSH
5829: LD_INT 34
5831: PUSH
5832: LD_INT 36
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: LIST
5839: LIST
5840: LIST
5841: LIST
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 101
5870: PUSH
5871: LD_INT 102
5873: PUSH
5874: LD_INT 103
5876: PUSH
5877: LD_INT 104
5879: PUSH
5880: LD_INT 105
5882: PUSH
5883: LD_INT 106
5885: PUSH
5886: LD_INT 107
5888: PUSH
5889: LD_INT 108
5891: PUSH
5892: LD_INT 109
5894: PUSH
5895: LD_INT 110
5897: PUSH
5898: LD_INT 111
5900: PUSH
5901: LD_INT 112
5903: PUSH
5904: LD_INT 114
5906: PUSH
5907: EMPTY
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: LIST
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: ST_TO_ADDR
5926: GO 7513
5928: LD_INT 12
5930: DOUBLE
5931: EQUAL
5932: IFTRUE 5936
5934: GO 6144
5936: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
5937: LD_ADDR_VAR 0 1
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 2
5947: PUSH
5948: LD_INT 3
5950: PUSH
5951: LD_INT 4
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 6
5959: PUSH
5960: LD_INT 7
5962: PUSH
5963: LD_INT 8
5965: PUSH
5966: LD_INT 9
5968: PUSH
5969: LD_INT 10
5971: PUSH
5972: LD_INT 11
5974: PUSH
5975: LD_INT 12
5977: PUSH
5978: LD_INT 13
5980: PUSH
5981: LD_INT 14
5983: PUSH
5984: LD_INT 15
5986: PUSH
5987: LD_INT 16
5989: PUSH
5990: LD_INT 17
5992: PUSH
5993: LD_INT 18
5995: PUSH
5996: LD_INT 19
5998: PUSH
5999: LD_INT 20
6001: PUSH
6002: LD_INT 21
6004: PUSH
6005: LD_INT 22
6007: PUSH
6008: LD_INT 23
6010: PUSH
6011: LD_INT 24
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: LD_INT 26
6019: PUSH
6020: LD_INT 27
6022: PUSH
6023: LD_INT 28
6025: PUSH
6026: LD_INT 30
6028: PUSH
6029: LD_INT 31
6031: PUSH
6032: LD_INT 32
6034: PUSH
6035: LD_INT 33
6037: PUSH
6038: LD_INT 34
6040: PUSH
6041: LD_INT 36
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: PUSH
6080: LD_INT 101
6082: PUSH
6083: LD_INT 102
6085: PUSH
6086: LD_INT 103
6088: PUSH
6089: LD_INT 104
6091: PUSH
6092: LD_INT 105
6094: PUSH
6095: LD_INT 106
6097: PUSH
6098: LD_INT 107
6100: PUSH
6101: LD_INT 108
6103: PUSH
6104: LD_INT 109
6106: PUSH
6107: LD_INT 110
6109: PUSH
6110: LD_INT 111
6112: PUSH
6113: LD_INT 112
6115: PUSH
6116: LD_INT 113
6118: PUSH
6119: LD_INT 114
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: ST_TO_ADDR
6142: GO 7513
6144: LD_INT 13
6146: DOUBLE
6147: EQUAL
6148: IFTRUE 6152
6150: GO 6348
6152: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
6153: LD_ADDR_VAR 0 1
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: LD_INT 3
6166: PUSH
6167: LD_INT 4
6169: PUSH
6170: LD_INT 5
6172: PUSH
6173: LD_INT 8
6175: PUSH
6176: LD_INT 9
6178: PUSH
6179: LD_INT 10
6181: PUSH
6182: LD_INT 11
6184: PUSH
6185: LD_INT 12
6187: PUSH
6188: LD_INT 14
6190: PUSH
6191: LD_INT 15
6193: PUSH
6194: LD_INT 16
6196: PUSH
6197: LD_INT 17
6199: PUSH
6200: LD_INT 18
6202: PUSH
6203: LD_INT 19
6205: PUSH
6206: LD_INT 20
6208: PUSH
6209: LD_INT 21
6211: PUSH
6212: LD_INT 22
6214: PUSH
6215: LD_INT 23
6217: PUSH
6218: LD_INT 24
6220: PUSH
6221: LD_INT 25
6223: PUSH
6224: LD_INT 26
6226: PUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 28
6232: PUSH
6233: LD_INT 30
6235: PUSH
6236: LD_INT 31
6238: PUSH
6239: LD_INT 32
6241: PUSH
6242: LD_INT 33
6244: PUSH
6245: LD_INT 34
6247: PUSH
6248: LD_INT 36
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: LIST
6255: LIST
6256: LIST
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: LIST
6283: PUSH
6284: LD_INT 101
6286: PUSH
6287: LD_INT 102
6289: PUSH
6290: LD_INT 103
6292: PUSH
6293: LD_INT 104
6295: PUSH
6296: LD_INT 105
6298: PUSH
6299: LD_INT 106
6301: PUSH
6302: LD_INT 107
6304: PUSH
6305: LD_INT 108
6307: PUSH
6308: LD_INT 109
6310: PUSH
6311: LD_INT 110
6313: PUSH
6314: LD_INT 111
6316: PUSH
6317: LD_INT 112
6319: PUSH
6320: LD_INT 113
6322: PUSH
6323: LD_INT 114
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: ST_TO_ADDR
6346: GO 7513
6348: LD_INT 14
6350: DOUBLE
6351: EQUAL
6352: IFTRUE 6356
6354: GO 6568
6356: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
6357: LD_ADDR_VAR 0 1
6361: PUSH
6362: LD_INT 1
6364: PUSH
6365: LD_INT 2
6367: PUSH
6368: LD_INT 3
6370: PUSH
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: LD_INT 7
6382: PUSH
6383: LD_INT 8
6385: PUSH
6386: LD_INT 9
6388: PUSH
6389: LD_INT 10
6391: PUSH
6392: LD_INT 11
6394: PUSH
6395: LD_INT 12
6397: PUSH
6398: LD_INT 13
6400: PUSH
6401: LD_INT 14
6403: PUSH
6404: LD_INT 15
6406: PUSH
6407: LD_INT 16
6409: PUSH
6410: LD_INT 17
6412: PUSH
6413: LD_INT 18
6415: PUSH
6416: LD_INT 19
6418: PUSH
6419: LD_INT 20
6421: PUSH
6422: LD_INT 21
6424: PUSH
6425: LD_INT 22
6427: PUSH
6428: LD_INT 23
6430: PUSH
6431: LD_INT 24
6433: PUSH
6434: LD_INT 25
6436: PUSH
6437: LD_INT 26
6439: PUSH
6440: LD_INT 27
6442: PUSH
6443: LD_INT 28
6445: PUSH
6446: LD_INT 29
6448: PUSH
6449: LD_INT 30
6451: PUSH
6452: LD_INT 31
6454: PUSH
6455: LD_INT 32
6457: PUSH
6458: LD_INT 33
6460: PUSH
6461: LD_INT 34
6463: PUSH
6464: LD_INT 36
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: PUSH
6504: LD_INT 101
6506: PUSH
6507: LD_INT 102
6509: PUSH
6510: LD_INT 103
6512: PUSH
6513: LD_INT 104
6515: PUSH
6516: LD_INT 105
6518: PUSH
6519: LD_INT 106
6521: PUSH
6522: LD_INT 107
6524: PUSH
6525: LD_INT 108
6527: PUSH
6528: LD_INT 109
6530: PUSH
6531: LD_INT 110
6533: PUSH
6534: LD_INT 111
6536: PUSH
6537: LD_INT 112
6539: PUSH
6540: LD_INT 113
6542: PUSH
6543: LD_INT 114
6545: PUSH
6546: EMPTY
6547: LIST
6548: LIST
6549: LIST
6550: LIST
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: ST_TO_ADDR
6566: GO 7513
6568: LD_INT 15
6570: DOUBLE
6571: EQUAL
6572: IFTRUE 6576
6574: GO 6788
6576: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
6577: LD_ADDR_VAR 0 1
6581: PUSH
6582: LD_INT 1
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 3
6590: PUSH
6591: LD_INT 4
6593: PUSH
6594: LD_INT 5
6596: PUSH
6597: LD_INT 6
6599: PUSH
6600: LD_INT 7
6602: PUSH
6603: LD_INT 8
6605: PUSH
6606: LD_INT 9
6608: PUSH
6609: LD_INT 10
6611: PUSH
6612: LD_INT 11
6614: PUSH
6615: LD_INT 12
6617: PUSH
6618: LD_INT 13
6620: PUSH
6621: LD_INT 14
6623: PUSH
6624: LD_INT 15
6626: PUSH
6627: LD_INT 16
6629: PUSH
6630: LD_INT 17
6632: PUSH
6633: LD_INT 18
6635: PUSH
6636: LD_INT 19
6638: PUSH
6639: LD_INT 20
6641: PUSH
6642: LD_INT 21
6644: PUSH
6645: LD_INT 22
6647: PUSH
6648: LD_INT 23
6650: PUSH
6651: LD_INT 24
6653: PUSH
6654: LD_INT 25
6656: PUSH
6657: LD_INT 26
6659: PUSH
6660: LD_INT 27
6662: PUSH
6663: LD_INT 28
6665: PUSH
6666: LD_INT 29
6668: PUSH
6669: LD_INT 30
6671: PUSH
6672: LD_INT 31
6674: PUSH
6675: LD_INT 32
6677: PUSH
6678: LD_INT 33
6680: PUSH
6681: LD_INT 34
6683: PUSH
6684: LD_INT 36
6686: PUSH
6687: EMPTY
6688: LIST
6689: LIST
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: PUSH
6724: LD_INT 101
6726: PUSH
6727: LD_INT 102
6729: PUSH
6730: LD_INT 103
6732: PUSH
6733: LD_INT 104
6735: PUSH
6736: LD_INT 105
6738: PUSH
6739: LD_INT 106
6741: PUSH
6742: LD_INT 107
6744: PUSH
6745: LD_INT 108
6747: PUSH
6748: LD_INT 109
6750: PUSH
6751: LD_INT 110
6753: PUSH
6754: LD_INT 111
6756: PUSH
6757: LD_INT 112
6759: PUSH
6760: LD_INT 113
6762: PUSH
6763: LD_INT 114
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: LIST
6778: LIST
6779: LIST
6780: LIST
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: ST_TO_ADDR
6786: GO 7513
6788: LD_INT 16
6790: DOUBLE
6791: EQUAL
6792: IFTRUE 6796
6794: GO 6920
6796: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_INT 2
6804: PUSH
6805: LD_INT 4
6807: PUSH
6808: LD_INT 5
6810: PUSH
6811: LD_INT 7
6813: PUSH
6814: LD_INT 11
6816: PUSH
6817: LD_INT 12
6819: PUSH
6820: LD_INT 15
6822: PUSH
6823: LD_INT 16
6825: PUSH
6826: LD_INT 20
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 22
6834: PUSH
6835: LD_INT 23
6837: PUSH
6838: LD_INT 25
6840: PUSH
6841: LD_INT 26
6843: PUSH
6844: LD_INT 30
6846: PUSH
6847: LD_INT 31
6849: PUSH
6850: LD_INT 32
6852: PUSH
6853: LD_INT 33
6855: PUSH
6856: LD_INT 34
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 101
6882: PUSH
6883: LD_INT 102
6885: PUSH
6886: LD_INT 103
6888: PUSH
6889: LD_INT 106
6891: PUSH
6892: LD_INT 108
6894: PUSH
6895: LD_INT 112
6897: PUSH
6898: LD_INT 113
6900: PUSH
6901: LD_INT 114
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: LIST
6909: LIST
6910: LIST
6911: LIST
6912: LIST
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: ST_TO_ADDR
6918: GO 7513
6920: LD_INT 17
6922: DOUBLE
6923: EQUAL
6924: IFTRUE 6928
6926: GO 7140
6928: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
6929: LD_ADDR_VAR 0 1
6933: PUSH
6934: LD_INT 1
6936: PUSH
6937: LD_INT 2
6939: PUSH
6940: LD_INT 3
6942: PUSH
6943: LD_INT 4
6945: PUSH
6946: LD_INT 5
6948: PUSH
6949: LD_INT 6
6951: PUSH
6952: LD_INT 7
6954: PUSH
6955: LD_INT 8
6957: PUSH
6958: LD_INT 9
6960: PUSH
6961: LD_INT 10
6963: PUSH
6964: LD_INT 11
6966: PUSH
6967: LD_INT 12
6969: PUSH
6970: LD_INT 13
6972: PUSH
6973: LD_INT 14
6975: PUSH
6976: LD_INT 15
6978: PUSH
6979: LD_INT 16
6981: PUSH
6982: LD_INT 17
6984: PUSH
6985: LD_INT 18
6987: PUSH
6988: LD_INT 19
6990: PUSH
6991: LD_INT 20
6993: PUSH
6994: LD_INT 21
6996: PUSH
6997: LD_INT 22
6999: PUSH
7000: LD_INT 23
7002: PUSH
7003: LD_INT 24
7005: PUSH
7006: LD_INT 25
7008: PUSH
7009: LD_INT 26
7011: PUSH
7012: LD_INT 27
7014: PUSH
7015: LD_INT 28
7017: PUSH
7018: LD_INT 29
7020: PUSH
7021: LD_INT 30
7023: PUSH
7024: LD_INT 31
7026: PUSH
7027: LD_INT 32
7029: PUSH
7030: LD_INT 33
7032: PUSH
7033: LD_INT 34
7035: PUSH
7036: LD_INT 36
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: LIST
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: LIST
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: LIST
7058: LIST
7059: LIST
7060: LIST
7061: LIST
7062: LIST
7063: LIST
7064: LIST
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 101
7078: PUSH
7079: LD_INT 102
7081: PUSH
7082: LD_INT 103
7084: PUSH
7085: LD_INT 104
7087: PUSH
7088: LD_INT 105
7090: PUSH
7091: LD_INT 106
7093: PUSH
7094: LD_INT 107
7096: PUSH
7097: LD_INT 108
7099: PUSH
7100: LD_INT 109
7102: PUSH
7103: LD_INT 110
7105: PUSH
7106: LD_INT 111
7108: PUSH
7109: LD_INT 112
7111: PUSH
7112: LD_INT 113
7114: PUSH
7115: LD_INT 114
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: ST_TO_ADDR
7138: GO 7513
7140: LD_INT 18
7142: DOUBLE
7143: EQUAL
7144: IFTRUE 7148
7146: GO 7284
7148: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
7149: LD_ADDR_VAR 0 1
7153: PUSH
7154: LD_INT 2
7156: PUSH
7157: LD_INT 4
7159: PUSH
7160: LD_INT 5
7162: PUSH
7163: LD_INT 7
7165: PUSH
7166: LD_INT 11
7168: PUSH
7169: LD_INT 12
7171: PUSH
7172: LD_INT 15
7174: PUSH
7175: LD_INT 16
7177: PUSH
7178: LD_INT 20
7180: PUSH
7181: LD_INT 21
7183: PUSH
7184: LD_INT 22
7186: PUSH
7187: LD_INT 23
7189: PUSH
7190: LD_INT 25
7192: PUSH
7193: LD_INT 26
7195: PUSH
7196: LD_INT 30
7198: PUSH
7199: LD_INT 31
7201: PUSH
7202: LD_INT 32
7204: PUSH
7205: LD_INT 33
7207: PUSH
7208: LD_INT 34
7210: PUSH
7211: LD_INT 35
7213: PUSH
7214: LD_INT 36
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: PUSH
7240: LD_INT 101
7242: PUSH
7243: LD_INT 102
7245: PUSH
7246: LD_INT 103
7248: PUSH
7249: LD_INT 106
7251: PUSH
7252: LD_INT 108
7254: PUSH
7255: LD_INT 112
7257: PUSH
7258: LD_INT 113
7260: PUSH
7261: LD_INT 114
7263: PUSH
7264: LD_INT 115
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: ST_TO_ADDR
7282: GO 7513
7284: LD_INT 19
7286: DOUBLE
7287: EQUAL
7288: IFTRUE 7292
7290: GO 7512
7292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
7293: LD_ADDR_VAR 0 1
7297: PUSH
7298: LD_INT 1
7300: PUSH
7301: LD_INT 2
7303: PUSH
7304: LD_INT 3
7306: PUSH
7307: LD_INT 4
7309: PUSH
7310: LD_INT 5
7312: PUSH
7313: LD_INT 6
7315: PUSH
7316: LD_INT 7
7318: PUSH
7319: LD_INT 8
7321: PUSH
7322: LD_INT 9
7324: PUSH
7325: LD_INT 10
7327: PUSH
7328: LD_INT 11
7330: PUSH
7331: LD_INT 12
7333: PUSH
7334: LD_INT 13
7336: PUSH
7337: LD_INT 14
7339: PUSH
7340: LD_INT 15
7342: PUSH
7343: LD_INT 16
7345: PUSH
7346: LD_INT 17
7348: PUSH
7349: LD_INT 18
7351: PUSH
7352: LD_INT 19
7354: PUSH
7355: LD_INT 20
7357: PUSH
7358: LD_INT 21
7360: PUSH
7361: LD_INT 22
7363: PUSH
7364: LD_INT 23
7366: PUSH
7367: LD_INT 24
7369: PUSH
7370: LD_INT 25
7372: PUSH
7373: LD_INT 26
7375: PUSH
7376: LD_INT 27
7378: PUSH
7379: LD_INT 28
7381: PUSH
7382: LD_INT 29
7384: PUSH
7385: LD_INT 30
7387: PUSH
7388: LD_INT 31
7390: PUSH
7391: LD_INT 32
7393: PUSH
7394: LD_INT 33
7396: PUSH
7397: LD_INT 34
7399: PUSH
7400: LD_INT 35
7402: PUSH
7403: LD_INT 36
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: LIST
7416: LIST
7417: LIST
7418: LIST
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: LIST
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: LIST
7442: LIST
7443: PUSH
7444: LD_INT 101
7446: PUSH
7447: LD_INT 102
7449: PUSH
7450: LD_INT 103
7452: PUSH
7453: LD_INT 104
7455: PUSH
7456: LD_INT 105
7458: PUSH
7459: LD_INT 106
7461: PUSH
7462: LD_INT 107
7464: PUSH
7465: LD_INT 108
7467: PUSH
7468: LD_INT 109
7470: PUSH
7471: LD_INT 110
7473: PUSH
7474: LD_INT 111
7476: PUSH
7477: LD_INT 112
7479: PUSH
7480: LD_INT 113
7482: PUSH
7483: LD_INT 114
7485: PUSH
7486: LD_INT 115
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: ST_TO_ADDR
7510: GO 7513
7512: POP
// end else
7513: GO 7550
// if campaign_id = 5 then
7515: LD_OWVAR 69
7519: PUSH
7520: LD_INT 5
7522: EQUAL
7523: IFFALSE 7550
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
7525: LD_ADDR_VAR 0 1
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 2
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: LD_INT 100
7542: PUSH
7543: EMPTY
7544: LIST
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: ST_TO_ADDR
// end ; if result then
7550: LD_VAR 0 1
7554: IFFALSE 7843
// begin normal :=  ;
7556: LD_ADDR_VAR 0 3
7560: PUSH
7561: LD_STRING 
7563: ST_TO_ADDR
// hardcore :=  ;
7564: LD_ADDR_VAR 0 4
7568: PUSH
7569: LD_STRING 
7571: ST_TO_ADDR
// for i = 1 to normalCounter do
7572: LD_ADDR_VAR 0 5
7576: PUSH
7577: DOUBLE
7578: LD_INT 1
7580: DEC
7581: ST_TO_ADDR
7582: LD_EXP 13
7586: PUSH
7587: FOR_TO
7588: IFFALSE 7689
// begin tmp := 0 ;
7590: LD_ADDR_VAR 0 2
7594: PUSH
7595: LD_STRING 0
7597: ST_TO_ADDR
// if result [ 1 ] then
7598: LD_VAR 0 1
7602: PUSH
7603: LD_INT 1
7605: ARRAY
7606: IFFALSE 7671
// if result [ 1 ] [ 1 ] = i then
7608: LD_VAR 0 1
7612: PUSH
7613: LD_INT 1
7615: ARRAY
7616: PUSH
7617: LD_INT 1
7619: ARRAY
7620: PUSH
7621: LD_VAR 0 5
7625: EQUAL
7626: IFFALSE 7671
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
7628: LD_ADDR_VAR 0 1
7632: PUSH
7633: LD_VAR 0 1
7637: PPUSH
7638: LD_INT 1
7640: PPUSH
7641: LD_VAR 0 1
7645: PUSH
7646: LD_INT 1
7648: ARRAY
7649: PPUSH
7650: LD_INT 1
7652: PPUSH
7653: CALL_OW 3
7657: PPUSH
7658: CALL_OW 1
7662: ST_TO_ADDR
// tmp := 1 ;
7663: LD_ADDR_VAR 0 2
7667: PUSH
7668: LD_STRING 1
7670: ST_TO_ADDR
// end ; normal := normal & tmp ;
7671: LD_ADDR_VAR 0 3
7675: PUSH
7676: LD_VAR 0 3
7680: PUSH
7681: LD_VAR 0 2
7685: STR
7686: ST_TO_ADDR
// end ;
7687: GO 7587
7689: POP
7690: POP
// for i = 1 to hardcoreCounter do
7691: LD_ADDR_VAR 0 5
7695: PUSH
7696: DOUBLE
7697: LD_INT 1
7699: DEC
7700: ST_TO_ADDR
7701: LD_EXP 14
7705: PUSH
7706: FOR_TO
7707: IFFALSE 7812
// begin tmp := 0 ;
7709: LD_ADDR_VAR 0 2
7713: PUSH
7714: LD_STRING 0
7716: ST_TO_ADDR
// if result [ 2 ] then
7717: LD_VAR 0 1
7721: PUSH
7722: LD_INT 2
7724: ARRAY
7725: IFFALSE 7794
// if result [ 2 ] [ 1 ] = 100 + i then
7727: LD_VAR 0 1
7731: PUSH
7732: LD_INT 2
7734: ARRAY
7735: PUSH
7736: LD_INT 1
7738: ARRAY
7739: PUSH
7740: LD_INT 100
7742: PUSH
7743: LD_VAR 0 5
7747: PLUS
7748: EQUAL
7749: IFFALSE 7794
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
7751: LD_ADDR_VAR 0 1
7755: PUSH
7756: LD_VAR 0 1
7760: PPUSH
7761: LD_INT 2
7763: PPUSH
7764: LD_VAR 0 1
7768: PUSH
7769: LD_INT 2
7771: ARRAY
7772: PPUSH
7773: LD_INT 1
7775: PPUSH
7776: CALL_OW 3
7780: PPUSH
7781: CALL_OW 1
7785: ST_TO_ADDR
// tmp := 1 ;
7786: LD_ADDR_VAR 0 2
7790: PUSH
7791: LD_STRING 1
7793: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
7794: LD_ADDR_VAR 0 4
7798: PUSH
7799: LD_VAR 0 4
7803: PUSH
7804: LD_VAR 0 2
7808: STR
7809: ST_TO_ADDR
// end ;
7810: GO 7706
7812: POP
7813: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
7814: LD_STRING getStreamItemsFromMission("
7816: PUSH
7817: LD_VAR 0 3
7821: STR
7822: PUSH
7823: LD_STRING ","
7825: STR
7826: PUSH
7827: LD_VAR 0 4
7831: STR
7832: PUSH
7833: LD_STRING ")
7835: STR
7836: PPUSH
7837: CALL_OW 559
// end else
7841: GO 7850
// ToLua ( getStreamItemsFromMission("","") ) ;
7843: LD_STRING getStreamItemsFromMission("","")
7845: PPUSH
7846: CALL_OW 559
// end ;
7850: LD_VAR 0 1
7854: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
7855: LD_VAR 0 2
7859: PUSH
7860: LD_INT 100
7862: EQUAL
7863: IFFALSE 8812
// begin if not StreamModeActive then
7865: LD_EXP 12
7869: NOT
7870: IFFALSE 7880
// StreamModeActive := true ;
7872: LD_ADDR_EXP 12
7876: PUSH
7877: LD_INT 1
7879: ST_TO_ADDR
// if p3 = 0 then
7880: LD_VAR 0 3
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7894
// InitStreamMode ;
7890: CALL 4115 0 0
// if p3 = 1 then
7894: LD_VAR 0 3
7898: PUSH
7899: LD_INT 1
7901: EQUAL
7902: IFFALSE 7912
// sRocket := true ;
7904: LD_ADDR_EXP 17
7908: PUSH
7909: LD_INT 1
7911: ST_TO_ADDR
// if p3 = 2 then
7912: LD_VAR 0 3
7916: PUSH
7917: LD_INT 2
7919: EQUAL
7920: IFFALSE 7930
// sSpeed := true ;
7922: LD_ADDR_EXP 16
7926: PUSH
7927: LD_INT 1
7929: ST_TO_ADDR
// if p3 = 3 then
7930: LD_VAR 0 3
7934: PUSH
7935: LD_INT 3
7937: EQUAL
7938: IFFALSE 7948
// sEngine := true ;
7940: LD_ADDR_EXP 18
7944: PUSH
7945: LD_INT 1
7947: ST_TO_ADDR
// if p3 = 4 then
7948: LD_VAR 0 3
7952: PUSH
7953: LD_INT 4
7955: EQUAL
7956: IFFALSE 7966
// sSpec := true ;
7958: LD_ADDR_EXP 15
7962: PUSH
7963: LD_INT 1
7965: ST_TO_ADDR
// if p3 = 5 then
7966: LD_VAR 0 3
7970: PUSH
7971: LD_INT 5
7973: EQUAL
7974: IFFALSE 7984
// sLevel := true ;
7976: LD_ADDR_EXP 19
7980: PUSH
7981: LD_INT 1
7983: ST_TO_ADDR
// if p3 = 6 then
7984: LD_VAR 0 3
7988: PUSH
7989: LD_INT 6
7991: EQUAL
7992: IFFALSE 8002
// sArmoury := true ;
7994: LD_ADDR_EXP 20
7998: PUSH
7999: LD_INT 1
8001: ST_TO_ADDR
// if p3 = 7 then
8002: LD_VAR 0 3
8006: PUSH
8007: LD_INT 7
8009: EQUAL
8010: IFFALSE 8020
// sRadar := true ;
8012: LD_ADDR_EXP 21
8016: PUSH
8017: LD_INT 1
8019: ST_TO_ADDR
// if p3 = 8 then
8020: LD_VAR 0 3
8024: PUSH
8025: LD_INT 8
8027: EQUAL
8028: IFFALSE 8038
// sBunker := true ;
8030: LD_ADDR_EXP 22
8034: PUSH
8035: LD_INT 1
8037: ST_TO_ADDR
// if p3 = 9 then
8038: LD_VAR 0 3
8042: PUSH
8043: LD_INT 9
8045: EQUAL
8046: IFFALSE 8056
// sHack := true ;
8048: LD_ADDR_EXP 23
8052: PUSH
8053: LD_INT 1
8055: ST_TO_ADDR
// if p3 = 10 then
8056: LD_VAR 0 3
8060: PUSH
8061: LD_INT 10
8063: EQUAL
8064: IFFALSE 8074
// sFire := true ;
8066: LD_ADDR_EXP 24
8070: PUSH
8071: LD_INT 1
8073: ST_TO_ADDR
// if p3 = 11 then
8074: LD_VAR 0 3
8078: PUSH
8079: LD_INT 11
8081: EQUAL
8082: IFFALSE 8092
// sRefresh := true ;
8084: LD_ADDR_EXP 25
8088: PUSH
8089: LD_INT 1
8091: ST_TO_ADDR
// if p3 = 12 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 12
8099: EQUAL
8100: IFFALSE 8110
// sExp := true ;
8102: LD_ADDR_EXP 26
8106: PUSH
8107: LD_INT 1
8109: ST_TO_ADDR
// if p3 = 13 then
8110: LD_VAR 0 3
8114: PUSH
8115: LD_INT 13
8117: EQUAL
8118: IFFALSE 8128
// sDepot := true ;
8120: LD_ADDR_EXP 27
8124: PUSH
8125: LD_INT 1
8127: ST_TO_ADDR
// if p3 = 14 then
8128: LD_VAR 0 3
8132: PUSH
8133: LD_INT 14
8135: EQUAL
8136: IFFALSE 8146
// sFlag := true ;
8138: LD_ADDR_EXP 28
8142: PUSH
8143: LD_INT 1
8145: ST_TO_ADDR
// if p3 = 15 then
8146: LD_VAR 0 3
8150: PUSH
8151: LD_INT 15
8153: EQUAL
8154: IFFALSE 8164
// sKamikadze := true ;
8156: LD_ADDR_EXP 36
8160: PUSH
8161: LD_INT 1
8163: ST_TO_ADDR
// if p3 = 16 then
8164: LD_VAR 0 3
8168: PUSH
8169: LD_INT 16
8171: EQUAL
8172: IFFALSE 8182
// sTroll := true ;
8174: LD_ADDR_EXP 37
8178: PUSH
8179: LD_INT 1
8181: ST_TO_ADDR
// if p3 = 17 then
8182: LD_VAR 0 3
8186: PUSH
8187: LD_INT 17
8189: EQUAL
8190: IFFALSE 8200
// sSlow := true ;
8192: LD_ADDR_EXP 38
8196: PUSH
8197: LD_INT 1
8199: ST_TO_ADDR
// if p3 = 18 then
8200: LD_VAR 0 3
8204: PUSH
8205: LD_INT 18
8207: EQUAL
8208: IFFALSE 8218
// sLack := true ;
8210: LD_ADDR_EXP 39
8214: PUSH
8215: LD_INT 1
8217: ST_TO_ADDR
// if p3 = 19 then
8218: LD_VAR 0 3
8222: PUSH
8223: LD_INT 19
8225: EQUAL
8226: IFFALSE 8236
// sTank := true ;
8228: LD_ADDR_EXP 41
8232: PUSH
8233: LD_INT 1
8235: ST_TO_ADDR
// if p3 = 20 then
8236: LD_VAR 0 3
8240: PUSH
8241: LD_INT 20
8243: EQUAL
8244: IFFALSE 8254
// sRemote := true ;
8246: LD_ADDR_EXP 42
8250: PUSH
8251: LD_INT 1
8253: ST_TO_ADDR
// if p3 = 21 then
8254: LD_VAR 0 3
8258: PUSH
8259: LD_INT 21
8261: EQUAL
8262: IFFALSE 8272
// sPowell := true ;
8264: LD_ADDR_EXP 43
8268: PUSH
8269: LD_INT 1
8271: ST_TO_ADDR
// if p3 = 22 then
8272: LD_VAR 0 3
8276: PUSH
8277: LD_INT 22
8279: EQUAL
8280: IFFALSE 8290
// sTeleport := true ;
8282: LD_ADDR_EXP 46
8286: PUSH
8287: LD_INT 1
8289: ST_TO_ADDR
// if p3 = 23 then
8290: LD_VAR 0 3
8294: PUSH
8295: LD_INT 23
8297: EQUAL
8298: IFFALSE 8308
// sOilTower := true ;
8300: LD_ADDR_EXP 48
8304: PUSH
8305: LD_INT 1
8307: ST_TO_ADDR
// if p3 = 24 then
8308: LD_VAR 0 3
8312: PUSH
8313: LD_INT 24
8315: EQUAL
8316: IFFALSE 8326
// sShovel := true ;
8318: LD_ADDR_EXP 49
8322: PUSH
8323: LD_INT 1
8325: ST_TO_ADDR
// if p3 = 25 then
8326: LD_VAR 0 3
8330: PUSH
8331: LD_INT 25
8333: EQUAL
8334: IFFALSE 8344
// sSheik := true ;
8336: LD_ADDR_EXP 50
8340: PUSH
8341: LD_INT 1
8343: ST_TO_ADDR
// if p3 = 26 then
8344: LD_VAR 0 3
8348: PUSH
8349: LD_INT 26
8351: EQUAL
8352: IFFALSE 8362
// sEarthquake := true ;
8354: LD_ADDR_EXP 52
8358: PUSH
8359: LD_INT 1
8361: ST_TO_ADDR
// if p3 = 27 then
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 27
8369: EQUAL
8370: IFFALSE 8380
// sAI := true ;
8372: LD_ADDR_EXP 53
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// if p3 = 28 then
8380: LD_VAR 0 3
8384: PUSH
8385: LD_INT 28
8387: EQUAL
8388: IFFALSE 8398
// sCargo := true ;
8390: LD_ADDR_EXP 56
8394: PUSH
8395: LD_INT 1
8397: ST_TO_ADDR
// if p3 = 29 then
8398: LD_VAR 0 3
8402: PUSH
8403: LD_INT 29
8405: EQUAL
8406: IFFALSE 8416
// sDLaser := true ;
8408: LD_ADDR_EXP 57
8412: PUSH
8413: LD_INT 1
8415: ST_TO_ADDR
// if p3 = 30 then
8416: LD_VAR 0 3
8420: PUSH
8421: LD_INT 30
8423: EQUAL
8424: IFFALSE 8434
// sExchange := true ;
8426: LD_ADDR_EXP 58
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// if p3 = 31 then
8434: LD_VAR 0 3
8438: PUSH
8439: LD_INT 31
8441: EQUAL
8442: IFFALSE 8452
// sFac := true ;
8444: LD_ADDR_EXP 59
8448: PUSH
8449: LD_INT 1
8451: ST_TO_ADDR
// if p3 = 32 then
8452: LD_VAR 0 3
8456: PUSH
8457: LD_INT 32
8459: EQUAL
8460: IFFALSE 8470
// sPower := true ;
8462: LD_ADDR_EXP 60
8466: PUSH
8467: LD_INT 1
8469: ST_TO_ADDR
// if p3 = 33 then
8470: LD_VAR 0 3
8474: PUSH
8475: LD_INT 33
8477: EQUAL
8478: IFFALSE 8488
// sRandom := true ;
8480: LD_ADDR_EXP 61
8484: PUSH
8485: LD_INT 1
8487: ST_TO_ADDR
// if p3 = 34 then
8488: LD_VAR 0 3
8492: PUSH
8493: LD_INT 34
8495: EQUAL
8496: IFFALSE 8506
// sShield := true ;
8498: LD_ADDR_EXP 62
8502: PUSH
8503: LD_INT 1
8505: ST_TO_ADDR
// if p3 = 35 then
8506: LD_VAR 0 3
8510: PUSH
8511: LD_INT 35
8513: EQUAL
8514: IFFALSE 8524
// sTime := true ;
8516: LD_ADDR_EXP 63
8520: PUSH
8521: LD_INT 1
8523: ST_TO_ADDR
// if p3 = 36 then
8524: LD_VAR 0 3
8528: PUSH
8529: LD_INT 36
8531: EQUAL
8532: IFFALSE 8542
// sTools := true ;
8534: LD_ADDR_EXP 64
8538: PUSH
8539: LD_INT 1
8541: ST_TO_ADDR
// if p3 = 101 then
8542: LD_VAR 0 3
8546: PUSH
8547: LD_INT 101
8549: EQUAL
8550: IFFALSE 8560
// sSold := true ;
8552: LD_ADDR_EXP 29
8556: PUSH
8557: LD_INT 1
8559: ST_TO_ADDR
// if p3 = 102 then
8560: LD_VAR 0 3
8564: PUSH
8565: LD_INT 102
8567: EQUAL
8568: IFFALSE 8578
// sDiff := true ;
8570: LD_ADDR_EXP 30
8574: PUSH
8575: LD_INT 1
8577: ST_TO_ADDR
// if p3 = 103 then
8578: LD_VAR 0 3
8582: PUSH
8583: LD_INT 103
8585: EQUAL
8586: IFFALSE 8596
// sFog := true ;
8588: LD_ADDR_EXP 33
8592: PUSH
8593: LD_INT 1
8595: ST_TO_ADDR
// if p3 = 104 then
8596: LD_VAR 0 3
8600: PUSH
8601: LD_INT 104
8603: EQUAL
8604: IFFALSE 8614
// sReset := true ;
8606: LD_ADDR_EXP 34
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// if p3 = 105 then
8614: LD_VAR 0 3
8618: PUSH
8619: LD_INT 105
8621: EQUAL
8622: IFFALSE 8632
// sSun := true ;
8624: LD_ADDR_EXP 35
8628: PUSH
8629: LD_INT 1
8631: ST_TO_ADDR
// if p3 = 106 then
8632: LD_VAR 0 3
8636: PUSH
8637: LD_INT 106
8639: EQUAL
8640: IFFALSE 8650
// sTiger := true ;
8642: LD_ADDR_EXP 31
8646: PUSH
8647: LD_INT 1
8649: ST_TO_ADDR
// if p3 = 107 then
8650: LD_VAR 0 3
8654: PUSH
8655: LD_INT 107
8657: EQUAL
8658: IFFALSE 8668
// sBomb := true ;
8660: LD_ADDR_EXP 32
8664: PUSH
8665: LD_INT 1
8667: ST_TO_ADDR
// if p3 = 108 then
8668: LD_VAR 0 3
8672: PUSH
8673: LD_INT 108
8675: EQUAL
8676: IFFALSE 8686
// sWound := true ;
8678: LD_ADDR_EXP 40
8682: PUSH
8683: LD_INT 1
8685: ST_TO_ADDR
// if p3 = 109 then
8686: LD_VAR 0 3
8690: PUSH
8691: LD_INT 109
8693: EQUAL
8694: IFFALSE 8704
// sBetray := true ;
8696: LD_ADDR_EXP 44
8700: PUSH
8701: LD_INT 1
8703: ST_TO_ADDR
// if p3 = 110 then
8704: LD_VAR 0 3
8708: PUSH
8709: LD_INT 110
8711: EQUAL
8712: IFFALSE 8722
// sContamin := true ;
8714: LD_ADDR_EXP 45
8718: PUSH
8719: LD_INT 1
8721: ST_TO_ADDR
// if p3 = 111 then
8722: LD_VAR 0 3
8726: PUSH
8727: LD_INT 111
8729: EQUAL
8730: IFFALSE 8740
// sOil := true ;
8732: LD_ADDR_EXP 47
8736: PUSH
8737: LD_INT 1
8739: ST_TO_ADDR
// if p3 = 112 then
8740: LD_VAR 0 3
8744: PUSH
8745: LD_INT 112
8747: EQUAL
8748: IFFALSE 8758
// sStu := true ;
8750: LD_ADDR_EXP 51
8754: PUSH
8755: LD_INT 1
8757: ST_TO_ADDR
// if p3 = 113 then
8758: LD_VAR 0 3
8762: PUSH
8763: LD_INT 113
8765: EQUAL
8766: IFFALSE 8776
// sBazooka := true ;
8768: LD_ADDR_EXP 54
8772: PUSH
8773: LD_INT 1
8775: ST_TO_ADDR
// if p3 = 114 then
8776: LD_VAR 0 3
8780: PUSH
8781: LD_INT 114
8783: EQUAL
8784: IFFALSE 8794
// sMortar := true ;
8786: LD_ADDR_EXP 55
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// if p3 = 115 then
8794: LD_VAR 0 3
8798: PUSH
8799: LD_INT 115
8801: EQUAL
8802: IFFALSE 8812
// sRanger := true ;
8804: LD_ADDR_EXP 65
8808: PUSH
8809: LD_INT 1
8811: ST_TO_ADDR
// end ; end ;
8812: PPOPN 6
8814: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
8815: LD_EXP 12
8819: PUSH
8820: LD_EXP 17
8824: AND
8825: IFFALSE 8949
8827: GO 8829
8829: DISABLE
8830: LD_INT 0
8832: PPUSH
8833: PPUSH
// begin enable ;
8834: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_INT 22
8842: PUSH
8843: LD_OWVAR 2
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: PUSH
8852: LD_INT 2
8854: PUSH
8855: LD_INT 34
8857: PUSH
8858: LD_INT 7
8860: PUSH
8861: EMPTY
8862: LIST
8863: LIST
8864: PUSH
8865: LD_INT 34
8867: PUSH
8868: LD_INT 45
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: LD_INT 34
8877: PUSH
8878: LD_INT 28
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: PUSH
8885: LD_INT 34
8887: PUSH
8888: LD_INT 47
8890: PUSH
8891: EMPTY
8892: LIST
8893: LIST
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: LIST
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PPUSH
8906: CALL_OW 69
8910: ST_TO_ADDR
// if not tmp then
8911: LD_VAR 0 2
8915: NOT
8916: IFFALSE 8920
// exit ;
8918: GO 8949
// for i in tmp do
8920: LD_ADDR_VAR 0 1
8924: PUSH
8925: LD_VAR 0 2
8929: PUSH
8930: FOR_IN
8931: IFFALSE 8947
// begin SetLives ( i , 0 ) ;
8933: LD_VAR 0 1
8937: PPUSH
8938: LD_INT 0
8940: PPUSH
8941: CALL_OW 234
// end ;
8945: GO 8930
8947: POP
8948: POP
// end ;
8949: PPOPN 2
8951: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8952: LD_EXP 12
8956: PUSH
8957: LD_EXP 18
8961: AND
8962: IFFALSE 9046
8964: GO 8966
8966: DISABLE
8967: LD_INT 0
8969: PPUSH
8970: PPUSH
// begin enable ;
8971: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
8972: LD_ADDR_VAR 0 2
8976: PUSH
8977: LD_INT 22
8979: PUSH
8980: LD_OWVAR 2
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PUSH
8989: LD_INT 32
8991: PUSH
8992: LD_INT 3
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: PPUSH
9003: CALL_OW 69
9007: ST_TO_ADDR
// if not tmp then
9008: LD_VAR 0 2
9012: NOT
9013: IFFALSE 9017
// exit ;
9015: GO 9046
// for i in tmp do
9017: LD_ADDR_VAR 0 1
9021: PUSH
9022: LD_VAR 0 2
9026: PUSH
9027: FOR_IN
9028: IFFALSE 9044
// begin SetLives ( i , 0 ) ;
9030: LD_VAR 0 1
9034: PPUSH
9035: LD_INT 0
9037: PPUSH
9038: CALL_OW 234
// end ;
9042: GO 9027
9044: POP
9045: POP
// end ;
9046: PPOPN 2
9048: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9049: LD_EXP 12
9053: PUSH
9054: LD_EXP 15
9058: AND
9059: IFFALSE 9152
9061: GO 9063
9063: DISABLE
9064: LD_INT 0
9066: PPUSH
// begin enable ;
9067: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9068: LD_ADDR_VAR 0 1
9072: PUSH
9073: LD_INT 22
9075: PUSH
9076: LD_OWVAR 2
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: PUSH
9085: LD_INT 2
9087: PUSH
9088: LD_INT 25
9090: PUSH
9091: LD_INT 5
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 25
9100: PUSH
9101: LD_INT 9
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: LD_INT 25
9110: PUSH
9111: LD_INT 8
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: LIST
9122: LIST
9123: PUSH
9124: EMPTY
9125: LIST
9126: LIST
9127: PPUSH
9128: CALL_OW 69
9132: PUSH
9133: FOR_IN
9134: IFFALSE 9150
// begin SetClass ( i , 1 ) ;
9136: LD_VAR 0 1
9140: PPUSH
9141: LD_INT 1
9143: PPUSH
9144: CALL_OW 336
// end ;
9148: GO 9133
9150: POP
9151: POP
// end ;
9152: PPOPN 1
9154: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9155: LD_EXP 12
9159: PUSH
9160: LD_EXP 16
9164: AND
9165: PUSH
9166: LD_OWVAR 65
9170: PUSH
9171: LD_INT 7
9173: LESS
9174: AND
9175: IFFALSE 9189
9177: GO 9179
9179: DISABLE
// begin enable ;
9180: ENABLE
// game_speed := 7 ;
9181: LD_ADDR_OWVAR 65
9185: PUSH
9186: LD_INT 7
9188: ST_TO_ADDR
// end ;
9189: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9190: LD_EXP 12
9194: PUSH
9195: LD_EXP 19
9199: AND
9200: IFFALSE 9402
9202: GO 9204
9204: DISABLE
9205: LD_INT 0
9207: PPUSH
9208: PPUSH
9209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9210: LD_ADDR_VAR 0 3
9214: PUSH
9215: LD_INT 81
9217: PUSH
9218: LD_OWVAR 2
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PUSH
9227: LD_INT 21
9229: PUSH
9230: LD_INT 1
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: PPUSH
9241: CALL_OW 69
9245: ST_TO_ADDR
// if not tmp then
9246: LD_VAR 0 3
9250: NOT
9251: IFFALSE 9255
// exit ;
9253: GO 9402
// if tmp > 5 then
9255: LD_VAR 0 3
9259: PUSH
9260: LD_INT 5
9262: GREATER
9263: IFFALSE 9275
// k := 5 else
9265: LD_ADDR_VAR 0 2
9269: PUSH
9270: LD_INT 5
9272: ST_TO_ADDR
9273: GO 9285
// k := tmp ;
9275: LD_ADDR_VAR 0 2
9279: PUSH
9280: LD_VAR 0 3
9284: ST_TO_ADDR
// for i := 1 to k do
9285: LD_ADDR_VAR 0 1
9289: PUSH
9290: DOUBLE
9291: LD_INT 1
9293: DEC
9294: ST_TO_ADDR
9295: LD_VAR 0 2
9299: PUSH
9300: FOR_TO
9301: IFFALSE 9400
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9303: LD_VAR 0 3
9307: PUSH
9308: LD_VAR 0 1
9312: ARRAY
9313: PPUSH
9314: LD_VAR 0 1
9318: PUSH
9319: LD_INT 4
9321: MOD
9322: PUSH
9323: LD_INT 1
9325: PLUS
9326: PPUSH
9327: CALL_OW 259
9331: PUSH
9332: LD_INT 10
9334: LESS
9335: IFFALSE 9398
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9337: LD_VAR 0 3
9341: PUSH
9342: LD_VAR 0 1
9346: ARRAY
9347: PPUSH
9348: LD_VAR 0 1
9352: PUSH
9353: LD_INT 4
9355: MOD
9356: PUSH
9357: LD_INT 1
9359: PLUS
9360: PPUSH
9361: LD_VAR 0 3
9365: PUSH
9366: LD_VAR 0 1
9370: ARRAY
9371: PPUSH
9372: LD_VAR 0 1
9376: PUSH
9377: LD_INT 4
9379: MOD
9380: PUSH
9381: LD_INT 1
9383: PLUS
9384: PPUSH
9385: CALL_OW 259
9389: PUSH
9390: LD_INT 1
9392: PLUS
9393: PPUSH
9394: CALL_OW 237
9398: GO 9300
9400: POP
9401: POP
// end ;
9402: PPOPN 3
9404: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9405: LD_EXP 12
9409: PUSH
9410: LD_EXP 20
9414: AND
9415: IFFALSE 9435
9417: GO 9419
9419: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9420: LD_INT 4
9422: PPUSH
9423: LD_OWVAR 2
9427: PPUSH
9428: LD_INT 0
9430: PPUSH
9431: CALL_OW 324
9435: END
// every 0 0$1 trigger StreamModeActive and sShovel do
9436: LD_EXP 12
9440: PUSH
9441: LD_EXP 49
9445: AND
9446: IFFALSE 9466
9448: GO 9450
9450: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
9451: LD_INT 19
9453: PPUSH
9454: LD_OWVAR 2
9458: PPUSH
9459: LD_INT 0
9461: PPUSH
9462: CALL_OW 324
9466: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9467: LD_EXP 12
9471: PUSH
9472: LD_EXP 21
9476: AND
9477: IFFALSE 9579
9479: GO 9481
9481: DISABLE
9482: LD_INT 0
9484: PPUSH
9485: PPUSH
// begin enable ;
9486: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9487: LD_ADDR_VAR 0 2
9491: PUSH
9492: LD_INT 22
9494: PUSH
9495: LD_OWVAR 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 2
9506: PUSH
9507: LD_INT 34
9509: PUSH
9510: LD_INT 11
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: LD_INT 34
9519: PUSH
9520: LD_INT 30
9522: PUSH
9523: EMPTY
9524: LIST
9525: LIST
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PPUSH
9536: CALL_OW 69
9540: ST_TO_ADDR
// if not tmp then
9541: LD_VAR 0 2
9545: NOT
9546: IFFALSE 9550
// exit ;
9548: GO 9579
// for i in tmp do
9550: LD_ADDR_VAR 0 1
9554: PUSH
9555: LD_VAR 0 2
9559: PUSH
9560: FOR_IN
9561: IFFALSE 9577
// begin SetLives ( i , 0 ) ;
9563: LD_VAR 0 1
9567: PPUSH
9568: LD_INT 0
9570: PPUSH
9571: CALL_OW 234
// end ;
9575: GO 9560
9577: POP
9578: POP
// end ;
9579: PPOPN 2
9581: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9582: LD_EXP 12
9586: PUSH
9587: LD_EXP 22
9591: AND
9592: IFFALSE 9612
9594: GO 9596
9596: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9597: LD_INT 32
9599: PPUSH
9600: LD_OWVAR 2
9604: PPUSH
9605: LD_INT 0
9607: PPUSH
9608: CALL_OW 324
9612: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
9613: LD_EXP 12
9617: PUSH
9618: LD_EXP 23
9622: AND
9623: IFFALSE 9804
9625: GO 9627
9627: DISABLE
9628: LD_INT 0
9630: PPUSH
9631: PPUSH
9632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
9633: LD_ADDR_VAR 0 2
9637: PUSH
9638: LD_INT 22
9640: PUSH
9641: LD_OWVAR 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 33
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PPUSH
9664: CALL_OW 69
9668: ST_TO_ADDR
// if not tmp then
9669: LD_VAR 0 2
9673: NOT
9674: IFFALSE 9678
// exit ;
9676: GO 9804
// side := 0 ;
9678: LD_ADDR_VAR 0 3
9682: PUSH
9683: LD_INT 0
9685: ST_TO_ADDR
// for i := 1 to 8 do
9686: LD_ADDR_VAR 0 1
9690: PUSH
9691: DOUBLE
9692: LD_INT 1
9694: DEC
9695: ST_TO_ADDR
9696: LD_INT 8
9698: PUSH
9699: FOR_TO
9700: IFFALSE 9748
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
9702: LD_OWVAR 2
9706: PUSH
9707: LD_VAR 0 1
9711: NONEQUAL
9712: PUSH
9713: LD_OWVAR 2
9717: PPUSH
9718: LD_VAR 0 1
9722: PPUSH
9723: CALL_OW 81
9727: PUSH
9728: LD_INT 2
9730: EQUAL
9731: AND
9732: IFFALSE 9746
// begin side := i ;
9734: LD_ADDR_VAR 0 3
9738: PUSH
9739: LD_VAR 0 1
9743: ST_TO_ADDR
// break ;
9744: GO 9748
// end ;
9746: GO 9699
9748: POP
9749: POP
// if not side then
9750: LD_VAR 0 3
9754: NOT
9755: IFFALSE 9759
// exit ;
9757: GO 9804
// for i := 1 to tmp do
9759: LD_ADDR_VAR 0 1
9763: PUSH
9764: DOUBLE
9765: LD_INT 1
9767: DEC
9768: ST_TO_ADDR
9769: LD_VAR 0 2
9773: PUSH
9774: FOR_TO
9775: IFFALSE 9802
// if Prob ( 60 ) then
9777: LD_INT 60
9779: PPUSH
9780: CALL_OW 13
9784: IFFALSE 9800
// SetSide ( i , side ) ;
9786: LD_VAR 0 1
9790: PPUSH
9791: LD_VAR 0 3
9795: PPUSH
9796: CALL_OW 235
9800: GO 9774
9802: POP
9803: POP
// end ;
9804: PPOPN 3
9806: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
9807: LD_EXP 12
9811: PUSH
9812: LD_EXP 25
9816: AND
9817: IFFALSE 9936
9819: GO 9821
9821: DISABLE
9822: LD_INT 0
9824: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
9825: LD_ADDR_VAR 0 1
9829: PUSH
9830: LD_INT 22
9832: PUSH
9833: LD_OWVAR 2
9837: PUSH
9838: EMPTY
9839: LIST
9840: LIST
9841: PUSH
9842: LD_INT 21
9844: PUSH
9845: LD_INT 1
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: PUSH
9852: LD_INT 3
9854: PUSH
9855: LD_INT 23
9857: PUSH
9858: LD_INT 0
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PUSH
9879: FOR_IN
9880: IFFALSE 9934
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
9882: LD_VAR 0 1
9886: PPUSH
9887: CALL_OW 257
9891: PUSH
9892: LD_INT 1
9894: PUSH
9895: LD_INT 2
9897: PUSH
9898: LD_INT 3
9900: PUSH
9901: LD_INT 4
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: IN
9910: IFFALSE 9932
// SetClass ( un , rand ( 1 , 4 ) ) ;
9912: LD_VAR 0 1
9916: PPUSH
9917: LD_INT 1
9919: PPUSH
9920: LD_INT 4
9922: PPUSH
9923: CALL_OW 12
9927: PPUSH
9928: CALL_OW 336
9932: GO 9879
9934: POP
9935: POP
// end ;
9936: PPOPN 1
9938: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9939: LD_EXP 12
9943: PUSH
9944: LD_EXP 24
9948: AND
9949: IFFALSE 10028
9951: GO 9953
9953: DISABLE
9954: LD_INT 0
9956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9957: LD_ADDR_VAR 0 1
9961: PUSH
9962: LD_INT 22
9964: PUSH
9965: LD_OWVAR 2
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: LD_INT 21
9976: PUSH
9977: LD_INT 3
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: PPUSH
9988: CALL_OW 69
9992: ST_TO_ADDR
// if not tmp then
9993: LD_VAR 0 1
9997: NOT
9998: IFFALSE 10002
// exit ;
10000: GO 10028
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
10002: LD_VAR 0 1
10006: PUSH
10007: LD_INT 1
10009: PPUSH
10010: LD_VAR 0 1
10014: PPUSH
10015: CALL_OW 12
10019: ARRAY
10020: PPUSH
10021: LD_INT 100
10023: PPUSH
10024: CALL_OW 234
// end ;
10028: PPOPN 1
10030: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10031: LD_EXP 12
10035: PUSH
10036: LD_EXP 26
10040: AND
10041: IFFALSE 10139
10043: GO 10045
10045: DISABLE
10046: LD_INT 0
10048: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10049: LD_ADDR_VAR 0 1
10053: PUSH
10054: LD_INT 22
10056: PUSH
10057: LD_OWVAR 2
10061: PUSH
10062: EMPTY
10063: LIST
10064: LIST
10065: PUSH
10066: LD_INT 21
10068: PUSH
10069: LD_INT 1
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PUSH
10076: EMPTY
10077: LIST
10078: LIST
10079: PPUSH
10080: CALL_OW 69
10084: ST_TO_ADDR
// if not tmp then
10085: LD_VAR 0 1
10089: NOT
10090: IFFALSE 10094
// exit ;
10092: GO 10139
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10094: LD_VAR 0 1
10098: PUSH
10099: LD_INT 1
10101: PPUSH
10102: LD_VAR 0 1
10106: PPUSH
10107: CALL_OW 12
10111: ARRAY
10112: PPUSH
10113: LD_INT 1
10115: PPUSH
10116: LD_INT 4
10118: PPUSH
10119: CALL_OW 12
10123: PPUSH
10124: LD_INT 3000
10126: PPUSH
10127: LD_INT 9000
10129: PPUSH
10130: CALL_OW 12
10134: PPUSH
10135: CALL_OW 492
// end ;
10139: PPOPN 1
10141: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10142: LD_EXP 12
10146: PUSH
10147: LD_EXP 27
10151: AND
10152: IFFALSE 10172
10154: GO 10156
10156: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10157: LD_INT 1
10159: PPUSH
10160: LD_OWVAR 2
10164: PPUSH
10165: LD_INT 0
10167: PPUSH
10168: CALL_OW 324
10172: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10173: LD_EXP 12
10177: PUSH
10178: LD_EXP 28
10182: AND
10183: IFFALSE 10266
10185: GO 10187
10187: DISABLE
10188: LD_INT 0
10190: PPUSH
10191: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10192: LD_ADDR_VAR 0 2
10196: PUSH
10197: LD_INT 22
10199: PUSH
10200: LD_OWVAR 2
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: PUSH
10209: LD_INT 21
10211: PUSH
10212: LD_INT 3
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PPUSH
10223: CALL_OW 69
10227: ST_TO_ADDR
// if not tmp then
10228: LD_VAR 0 2
10232: NOT
10233: IFFALSE 10237
// exit ;
10235: GO 10266
// for i in tmp do
10237: LD_ADDR_VAR 0 1
10241: PUSH
10242: LD_VAR 0 2
10246: PUSH
10247: FOR_IN
10248: IFFALSE 10264
// SetBLevel ( i , 10 ) ;
10250: LD_VAR 0 1
10254: PPUSH
10255: LD_INT 10
10257: PPUSH
10258: CALL_OW 241
10262: GO 10247
10264: POP
10265: POP
// end ;
10266: PPOPN 2
10268: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
10269: LD_EXP 12
10273: PUSH
10274: LD_EXP 29
10278: AND
10279: IFFALSE 10390
10281: GO 10283
10283: DISABLE
10284: LD_INT 0
10286: PPUSH
10287: PPUSH
10288: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10289: LD_ADDR_VAR 0 3
10293: PUSH
10294: LD_INT 22
10296: PUSH
10297: LD_OWVAR 2
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PUSH
10306: LD_INT 25
10308: PUSH
10309: LD_INT 1
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL_OW 69
10324: ST_TO_ADDR
// if not tmp then
10325: LD_VAR 0 3
10329: NOT
10330: IFFALSE 10334
// exit ;
10332: GO 10390
// un := tmp [ rand ( 1 , tmp ) ] ;
10334: LD_ADDR_VAR 0 2
10338: PUSH
10339: LD_VAR 0 3
10343: PUSH
10344: LD_INT 1
10346: PPUSH
10347: LD_VAR 0 3
10351: PPUSH
10352: CALL_OW 12
10356: ARRAY
10357: ST_TO_ADDR
// if Crawls ( un ) then
10358: LD_VAR 0 2
10362: PPUSH
10363: CALL_OW 318
10367: IFFALSE 10378
// ComWalk ( un ) ;
10369: LD_VAR 0 2
10373: PPUSH
10374: CALL_OW 138
// SetClass ( un , class_sniper ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 5
10385: PPUSH
10386: CALL_OW 336
// end ;
10390: PPOPN 3
10392: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10393: LD_EXP 12
10397: PUSH
10398: LD_EXP 30
10402: AND
10403: PUSH
10404: LD_OWVAR 67
10408: PUSH
10409: LD_INT 3
10411: LESS
10412: AND
10413: IFFALSE 10432
10415: GO 10417
10417: DISABLE
// Difficulty := Difficulty + 1 ;
10418: LD_ADDR_OWVAR 67
10422: PUSH
10423: LD_OWVAR 67
10427: PUSH
10428: LD_INT 1
10430: PLUS
10431: ST_TO_ADDR
10432: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10433: LD_EXP 12
10437: PUSH
10438: LD_EXP 31
10442: AND
10443: IFFALSE 10546
10445: GO 10447
10447: DISABLE
10448: LD_INT 0
10450: PPUSH
// begin for i := 1 to 5 do
10451: LD_ADDR_VAR 0 1
10455: PUSH
10456: DOUBLE
10457: LD_INT 1
10459: DEC
10460: ST_TO_ADDR
10461: LD_INT 5
10463: PUSH
10464: FOR_TO
10465: IFFALSE 10544
// begin uc_nation := nation_nature ;
10467: LD_ADDR_OWVAR 21
10471: PUSH
10472: LD_INT 0
10474: ST_TO_ADDR
// uc_side := 0 ;
10475: LD_ADDR_OWVAR 20
10479: PUSH
10480: LD_INT 0
10482: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10483: LD_ADDR_OWVAR 29
10487: PUSH
10488: LD_INT 12
10490: PUSH
10491: LD_INT 12
10493: PUSH
10494: EMPTY
10495: LIST
10496: LIST
10497: ST_TO_ADDR
// hc_agressivity := 20 ;
10498: LD_ADDR_OWVAR 35
10502: PUSH
10503: LD_INT 20
10505: ST_TO_ADDR
// hc_class := class_tiger ;
10506: LD_ADDR_OWVAR 28
10510: PUSH
10511: LD_INT 14
10513: ST_TO_ADDR
// hc_gallery :=  ;
10514: LD_ADDR_OWVAR 33
10518: PUSH
10519: LD_STRING 
10521: ST_TO_ADDR
// hc_name :=  ;
10522: LD_ADDR_OWVAR 26
10526: PUSH
10527: LD_STRING 
10529: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10530: CALL_OW 44
10534: PPUSH
10535: LD_INT 0
10537: PPUSH
10538: CALL_OW 51
// end ;
10542: GO 10464
10544: POP
10545: POP
// end ;
10546: PPOPN 1
10548: END
// every 0 0$1 trigger StreamModeActive and sBomb do
10549: LD_EXP 12
10553: PUSH
10554: LD_EXP 32
10558: AND
10559: IFFALSE 10568
10561: GO 10563
10563: DISABLE
// StreamSibBomb ;
10564: CALL 10569 0 0
10568: END
// export function StreamSibBomb ; var i , x , y ; begin
10569: LD_INT 0
10571: PPUSH
10572: PPUSH
10573: PPUSH
10574: PPUSH
// result := false ;
10575: LD_ADDR_VAR 0 1
10579: PUSH
10580: LD_INT 0
10582: ST_TO_ADDR
// for i := 1 to 16 do
10583: LD_ADDR_VAR 0 2
10587: PUSH
10588: DOUBLE
10589: LD_INT 1
10591: DEC
10592: ST_TO_ADDR
10593: LD_INT 16
10595: PUSH
10596: FOR_TO
10597: IFFALSE 10796
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10599: LD_ADDR_VAR 0 3
10603: PUSH
10604: LD_INT 10
10606: PUSH
10607: LD_INT 20
10609: PUSH
10610: LD_INT 30
10612: PUSH
10613: LD_INT 40
10615: PUSH
10616: LD_INT 50
10618: PUSH
10619: LD_INT 60
10621: PUSH
10622: LD_INT 70
10624: PUSH
10625: LD_INT 80
10627: PUSH
10628: LD_INT 90
10630: PUSH
10631: LD_INT 100
10633: PUSH
10634: LD_INT 110
10636: PUSH
10637: LD_INT 120
10639: PUSH
10640: LD_INT 130
10642: PUSH
10643: LD_INT 140
10645: PUSH
10646: LD_INT 150
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: LIST
10653: LIST
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: PUSH
10666: LD_INT 1
10668: PPUSH
10669: LD_INT 15
10671: PPUSH
10672: CALL_OW 12
10676: ARRAY
10677: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10678: LD_ADDR_VAR 0 4
10682: PUSH
10683: LD_INT 10
10685: PUSH
10686: LD_INT 20
10688: PUSH
10689: LD_INT 30
10691: PUSH
10692: LD_INT 40
10694: PUSH
10695: LD_INT 50
10697: PUSH
10698: LD_INT 60
10700: PUSH
10701: LD_INT 70
10703: PUSH
10704: LD_INT 80
10706: PUSH
10707: LD_INT 90
10709: PUSH
10710: LD_INT 100
10712: PUSH
10713: LD_INT 110
10715: PUSH
10716: LD_INT 120
10718: PUSH
10719: LD_INT 130
10721: PUSH
10722: LD_INT 140
10724: PUSH
10725: LD_INT 150
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: LIST
10743: LIST
10744: PUSH
10745: LD_INT 1
10747: PPUSH
10748: LD_INT 15
10750: PPUSH
10751: CALL_OW 12
10755: ARRAY
10756: ST_TO_ADDR
// if ValidHex ( x , y ) then
10757: LD_VAR 0 3
10761: PPUSH
10762: LD_VAR 0 4
10766: PPUSH
10767: CALL_OW 488
10771: IFFALSE 10794
// begin result := [ x , y ] ;
10773: LD_ADDR_VAR 0 1
10777: PUSH
10778: LD_VAR 0 3
10782: PUSH
10783: LD_VAR 0 4
10787: PUSH
10788: EMPTY
10789: LIST
10790: LIST
10791: ST_TO_ADDR
// break ;
10792: GO 10796
// end ; end ;
10794: GO 10596
10796: POP
10797: POP
// if result then
10798: LD_VAR 0 1
10802: IFFALSE 10862
// begin ToLua ( playSibBomb() ) ;
10804: LD_STRING playSibBomb()
10806: PPUSH
10807: CALL_OW 559
// wait ( 0 0$14 ) ;
10811: LD_INT 490
10813: PPUSH
10814: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
10818: LD_VAR 0 1
10822: PUSH
10823: LD_INT 1
10825: ARRAY
10826: PPUSH
10827: LD_VAR 0 1
10831: PUSH
10832: LD_INT 2
10834: ARRAY
10835: PPUSH
10836: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10840: LD_VAR 0 1
10844: PUSH
10845: LD_INT 1
10847: ARRAY
10848: PPUSH
10849: LD_VAR 0 1
10853: PUSH
10854: LD_INT 2
10856: ARRAY
10857: PPUSH
10858: CALL_OW 429
// end ; end ;
10862: LD_VAR 0 1
10866: RET
// every 0 0$1 trigger StreamModeActive and sReset do
10867: LD_EXP 12
10871: PUSH
10872: LD_EXP 34
10876: AND
10877: IFFALSE 10889
10879: GO 10881
10881: DISABLE
// YouLost (  ) ;
10882: LD_STRING 
10884: PPUSH
10885: CALL_OW 104
10889: END
// every 0 0$1 trigger StreamModeActive and sFog do
10890: LD_EXP 12
10894: PUSH
10895: LD_EXP 33
10899: AND
10900: IFFALSE 10914
10902: GO 10904
10904: DISABLE
// FogOff ( your_side ) ;
10905: LD_OWVAR 2
10909: PPUSH
10910: CALL_OW 344
10914: END
// every 0 0$1 trigger StreamModeActive and sSun do
10915: LD_EXP 12
10919: PUSH
10920: LD_EXP 35
10924: AND
10925: IFFALSE 10953
10927: GO 10929
10929: DISABLE
// begin solar_recharge_percent := 0 ;
10930: LD_ADDR_OWVAR 79
10934: PUSH
10935: LD_INT 0
10937: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10938: LD_INT 10500
10940: PPUSH
10941: CALL_OW 67
// solar_recharge_percent := 100 ;
10945: LD_ADDR_OWVAR 79
10949: PUSH
10950: LD_INT 100
10952: ST_TO_ADDR
// end ;
10953: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
10954: LD_EXP 12
10958: PUSH
10959: LD_EXP 36
10963: AND
10964: IFFALSE 11203
10966: GO 10968
10968: DISABLE
10969: LD_INT 0
10971: PPUSH
10972: PPUSH
10973: PPUSH
// begin tmp := [ ] ;
10974: LD_ADDR_VAR 0 3
10978: PUSH
10979: EMPTY
10980: ST_TO_ADDR
// for i := 1 to 6 do
10981: LD_ADDR_VAR 0 1
10985: PUSH
10986: DOUBLE
10987: LD_INT 1
10989: DEC
10990: ST_TO_ADDR
10991: LD_INT 6
10993: PUSH
10994: FOR_TO
10995: IFFALSE 11100
// begin uc_nation := nation_nature ;
10997: LD_ADDR_OWVAR 21
11001: PUSH
11002: LD_INT 0
11004: ST_TO_ADDR
// uc_side := 0 ;
11005: LD_ADDR_OWVAR 20
11009: PUSH
11010: LD_INT 0
11012: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11013: LD_ADDR_OWVAR 29
11017: PUSH
11018: LD_INT 12
11020: PUSH
11021: LD_INT 12
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: ST_TO_ADDR
// hc_agressivity := 20 ;
11028: LD_ADDR_OWVAR 35
11032: PUSH
11033: LD_INT 20
11035: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11036: LD_ADDR_OWVAR 28
11040: PUSH
11041: LD_INT 17
11043: ST_TO_ADDR
// hc_gallery :=  ;
11044: LD_ADDR_OWVAR 33
11048: PUSH
11049: LD_STRING 
11051: ST_TO_ADDR
// hc_name :=  ;
11052: LD_ADDR_OWVAR 26
11056: PUSH
11057: LD_STRING 
11059: ST_TO_ADDR
// un := CreateHuman ;
11060: LD_ADDR_VAR 0 2
11064: PUSH
11065: CALL_OW 44
11069: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11070: LD_VAR 0 2
11074: PPUSH
11075: LD_INT 1
11077: PPUSH
11078: CALL_OW 51
// tmp := tmp ^ un ;
11082: LD_ADDR_VAR 0 3
11086: PUSH
11087: LD_VAR 0 3
11091: PUSH
11092: LD_VAR 0 2
11096: ADD
11097: ST_TO_ADDR
// end ;
11098: GO 10994
11100: POP
11101: POP
// repeat wait ( 0 0$1 ) ;
11102: LD_INT 35
11104: PPUSH
11105: CALL_OW 67
// for un in tmp do
11109: LD_ADDR_VAR 0 2
11113: PUSH
11114: LD_VAR 0 3
11118: PUSH
11119: FOR_IN
11120: IFFALSE 11194
// begin if IsDead ( un ) then
11122: LD_VAR 0 2
11126: PPUSH
11127: CALL_OW 301
11131: IFFALSE 11151
// begin tmp := tmp diff un ;
11133: LD_ADDR_VAR 0 3
11137: PUSH
11138: LD_VAR 0 3
11142: PUSH
11143: LD_VAR 0 2
11147: DIFF
11148: ST_TO_ADDR
// continue ;
11149: GO 11119
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11151: LD_VAR 0 2
11155: PPUSH
11156: LD_INT 3
11158: PUSH
11159: LD_INT 22
11161: PUSH
11162: LD_INT 0
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PPUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: CALL_OW 74
11187: PPUSH
11188: CALL_OW 115
// end ;
11192: GO 11119
11194: POP
11195: POP
// until not tmp ;
11196: LD_VAR 0 3
11200: NOT
11201: IFFALSE 11102
// end ;
11203: PPOPN 3
11205: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11206: LD_EXP 12
11210: PUSH
11211: LD_EXP 37
11215: AND
11216: IFFALSE 11270
11218: GO 11220
11220: DISABLE
// begin ToLua ( displayTroll(); ) ;
11221: LD_STRING displayTroll();
11223: PPUSH
11224: CALL_OW 559
// wait ( 3 3$00 ) ;
11228: LD_INT 6300
11230: PPUSH
11231: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11235: LD_STRING hideTroll();
11237: PPUSH
11238: CALL_OW 559
// wait ( 1 1$00 ) ;
11242: LD_INT 2100
11244: PPUSH
11245: CALL_OW 67
// ToLua ( displayTroll(); ) ;
11249: LD_STRING displayTroll();
11251: PPUSH
11252: CALL_OW 559
// wait ( 1 1$00 ) ;
11256: LD_INT 2100
11258: PPUSH
11259: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11263: LD_STRING hideTroll();
11265: PPUSH
11266: CALL_OW 559
// end ;
11270: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11271: LD_EXP 12
11275: PUSH
11276: LD_EXP 38
11280: AND
11281: IFFALSE 11344
11283: GO 11285
11285: DISABLE
11286: LD_INT 0
11288: PPUSH
// begin p := 0 ;
11289: LD_ADDR_VAR 0 1
11293: PUSH
11294: LD_INT 0
11296: ST_TO_ADDR
// repeat game_speed := 1 ;
11297: LD_ADDR_OWVAR 65
11301: PUSH
11302: LD_INT 1
11304: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11305: LD_INT 35
11307: PPUSH
11308: CALL_OW 67
// p := p + 1 ;
11312: LD_ADDR_VAR 0 1
11316: PUSH
11317: LD_VAR 0 1
11321: PUSH
11322: LD_INT 1
11324: PLUS
11325: ST_TO_ADDR
// until p >= 60 ;
11326: LD_VAR 0 1
11330: PUSH
11331: LD_INT 60
11333: GREATEREQUAL
11334: IFFALSE 11297
// game_speed := 4 ;
11336: LD_ADDR_OWVAR 65
11340: PUSH
11341: LD_INT 4
11343: ST_TO_ADDR
// end ;
11344: PPOPN 1
11346: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11347: LD_EXP 12
11351: PUSH
11352: LD_EXP 39
11356: AND
11357: IFFALSE 11503
11359: GO 11361
11361: DISABLE
11362: LD_INT 0
11364: PPUSH
11365: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11366: LD_ADDR_VAR 0 1
11370: PUSH
11371: LD_INT 22
11373: PUSH
11374: LD_OWVAR 2
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 2
11385: PUSH
11386: LD_INT 30
11388: PUSH
11389: LD_INT 0
11391: PUSH
11392: EMPTY
11393: LIST
11394: LIST
11395: PUSH
11396: LD_INT 30
11398: PUSH
11399: LD_INT 1
11401: PUSH
11402: EMPTY
11403: LIST
11404: LIST
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: LIST
11410: PUSH
11411: EMPTY
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// if not depot then
11420: LD_VAR 0 1
11424: NOT
11425: IFFALSE 11429
// exit ;
11427: GO 11503
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11429: LD_ADDR_VAR 0 2
11433: PUSH
11434: LD_VAR 0 1
11438: PUSH
11439: LD_INT 1
11441: PPUSH
11442: LD_VAR 0 1
11446: PPUSH
11447: CALL_OW 12
11451: ARRAY
11452: PPUSH
11453: CALL_OW 274
11457: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11458: LD_VAR 0 2
11462: PPUSH
11463: LD_INT 1
11465: PPUSH
11466: LD_INT 0
11468: PPUSH
11469: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11473: LD_VAR 0 2
11477: PPUSH
11478: LD_INT 2
11480: PPUSH
11481: LD_INT 0
11483: PPUSH
11484: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11488: LD_VAR 0 2
11492: PPUSH
11493: LD_INT 3
11495: PPUSH
11496: LD_INT 0
11498: PPUSH
11499: CALL_OW 277
// end ;
11503: PPOPN 2
11505: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
11506: LD_EXP 12
11510: PUSH
11511: LD_EXP 40
11515: AND
11516: IFFALSE 11613
11518: GO 11520
11520: DISABLE
11521: LD_INT 0
11523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11524: LD_ADDR_VAR 0 1
11528: PUSH
11529: LD_INT 22
11531: PUSH
11532: LD_OWVAR 2
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: PUSH
11541: LD_INT 21
11543: PUSH
11544: LD_INT 1
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: PUSH
11551: LD_INT 3
11553: PUSH
11554: LD_INT 23
11556: PUSH
11557: LD_INT 0
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: LIST
11572: PPUSH
11573: CALL_OW 69
11577: ST_TO_ADDR
// if not tmp then
11578: LD_VAR 0 1
11582: NOT
11583: IFFALSE 11587
// exit ;
11585: GO 11613
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11587: LD_VAR 0 1
11591: PUSH
11592: LD_INT 1
11594: PPUSH
11595: LD_VAR 0 1
11599: PPUSH
11600: CALL_OW 12
11604: ARRAY
11605: PPUSH
11606: LD_INT 200
11608: PPUSH
11609: CALL_OW 234
// end ;
11613: PPOPN 1
11615: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11616: LD_EXP 12
11620: PUSH
11621: LD_EXP 41
11625: AND
11626: IFFALSE 11705
11628: GO 11630
11630: DISABLE
11631: LD_INT 0
11633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11634: LD_ADDR_VAR 0 1
11638: PUSH
11639: LD_INT 22
11641: PUSH
11642: LD_OWVAR 2
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: PUSH
11651: LD_INT 21
11653: PUSH
11654: LD_INT 2
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PPUSH
11665: CALL_OW 69
11669: ST_TO_ADDR
// if not tmp then
11670: LD_VAR 0 1
11674: NOT
11675: IFFALSE 11679
// exit ;
11677: GO 11705
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
11679: LD_VAR 0 1
11683: PUSH
11684: LD_INT 1
11686: PPUSH
11687: LD_VAR 0 1
11691: PPUSH
11692: CALL_OW 12
11696: ARRAY
11697: PPUSH
11698: LD_INT 60
11700: PPUSH
11701: CALL_OW 234
// end ;
11705: PPOPN 1
11707: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11708: LD_EXP 12
11712: PUSH
11713: LD_EXP 42
11717: AND
11718: IFFALSE 11817
11720: GO 11722
11722: DISABLE
11723: LD_INT 0
11725: PPUSH
11726: PPUSH
// begin enable ;
11727: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11728: LD_ADDR_VAR 0 1
11732: PUSH
11733: LD_INT 22
11735: PUSH
11736: LD_OWVAR 2
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PUSH
11745: LD_INT 61
11747: PUSH
11748: EMPTY
11749: LIST
11750: PUSH
11751: LD_INT 33
11753: PUSH
11754: LD_INT 2
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: LIST
11765: PPUSH
11766: CALL_OW 69
11770: ST_TO_ADDR
// if not tmp then
11771: LD_VAR 0 1
11775: NOT
11776: IFFALSE 11780
// exit ;
11778: GO 11817
// for i in tmp do
11780: LD_ADDR_VAR 0 2
11784: PUSH
11785: LD_VAR 0 1
11789: PUSH
11790: FOR_IN
11791: IFFALSE 11815
// if IsControledBy ( i ) then
11793: LD_VAR 0 2
11797: PPUSH
11798: CALL_OW 312
11802: IFFALSE 11813
// ComUnlink ( i ) ;
11804: LD_VAR 0 2
11808: PPUSH
11809: CALL_OW 136
11813: GO 11790
11815: POP
11816: POP
// end ;
11817: PPOPN 2
11819: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
11820: LD_EXP 12
11824: PUSH
11825: LD_EXP 43
11829: AND
11830: IFFALSE 11970
11832: GO 11834
11834: DISABLE
11835: LD_INT 0
11837: PPUSH
11838: PPUSH
// begin ToLua ( displayPowell(); ) ;
11839: LD_STRING displayPowell();
11841: PPUSH
11842: CALL_OW 559
// uc_side := 0 ;
11846: LD_ADDR_OWVAR 20
11850: PUSH
11851: LD_INT 0
11853: ST_TO_ADDR
// uc_nation := 2 ;
11854: LD_ADDR_OWVAR 21
11858: PUSH
11859: LD_INT 2
11861: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
11862: LD_ADDR_OWVAR 37
11866: PUSH
11867: LD_INT 14
11869: ST_TO_ADDR
// vc_engine := engine_siberite ;
11870: LD_ADDR_OWVAR 39
11874: PUSH
11875: LD_INT 3
11877: ST_TO_ADDR
// vc_control := control_apeman ;
11878: LD_ADDR_OWVAR 38
11882: PUSH
11883: LD_INT 5
11885: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
11886: LD_ADDR_OWVAR 40
11890: PUSH
11891: LD_INT 29
11893: ST_TO_ADDR
// un := CreateVehicle ;
11894: LD_ADDR_VAR 0 2
11898: PUSH
11899: CALL_OW 45
11903: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11904: LD_VAR 0 2
11908: PPUSH
11909: LD_INT 1
11911: PPUSH
11912: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11916: LD_INT 35
11918: PPUSH
11919: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11923: LD_VAR 0 2
11927: PPUSH
11928: LD_INT 22
11930: PUSH
11931: LD_OWVAR 2
11935: PUSH
11936: EMPTY
11937: LIST
11938: LIST
11939: PPUSH
11940: CALL_OW 69
11944: PPUSH
11945: LD_VAR 0 2
11949: PPUSH
11950: CALL_OW 74
11954: PPUSH
11955: CALL_OW 115
// until IsDead ( un ) ;
11959: LD_VAR 0 2
11963: PPUSH
11964: CALL_OW 301
11968: IFFALSE 11916
// end ;
11970: PPOPN 2
11972: END
// every 0 0$1 trigger StreamModeActive and sStu do
11973: LD_EXP 12
11977: PUSH
11978: LD_EXP 51
11982: AND
11983: IFFALSE 11999
11985: GO 11987
11987: DISABLE
// begin ToLua ( displayStucuk(); ) ;
11988: LD_STRING displayStucuk();
11990: PPUSH
11991: CALL_OW 559
// ResetFog ;
11995: CALL_OW 335
// end ;
11999: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
12000: LD_EXP 12
12004: PUSH
12005: LD_EXP 44
12009: AND
12010: IFFALSE 12151
12012: GO 12014
12014: DISABLE
12015: LD_INT 0
12017: PPUSH
12018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12019: LD_ADDR_VAR 0 2
12023: PUSH
12024: LD_INT 22
12026: PUSH
12027: LD_OWVAR 2
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: LD_INT 21
12038: PUSH
12039: LD_INT 1
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PPUSH
12050: CALL_OW 69
12054: ST_TO_ADDR
// if not tmp then
12055: LD_VAR 0 2
12059: NOT
12060: IFFALSE 12064
// exit ;
12062: GO 12151
// un := tmp [ rand ( 1 , tmp ) ] ;
12064: LD_ADDR_VAR 0 1
12068: PUSH
12069: LD_VAR 0 2
12073: PUSH
12074: LD_INT 1
12076: PPUSH
12077: LD_VAR 0 2
12081: PPUSH
12082: CALL_OW 12
12086: ARRAY
12087: ST_TO_ADDR
// SetSide ( un , 0 ) ;
12088: LD_VAR 0 1
12092: PPUSH
12093: LD_INT 0
12095: PPUSH
12096: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
12100: LD_VAR 0 1
12104: PPUSH
12105: LD_OWVAR 3
12109: PUSH
12110: LD_VAR 0 1
12114: DIFF
12115: PPUSH
12116: LD_VAR 0 1
12120: PPUSH
12121: CALL_OW 74
12125: PPUSH
12126: CALL_OW 115
// wait ( 0 0$20 ) ;
12130: LD_INT 700
12132: PPUSH
12133: CALL_OW 67
// SetSide ( un , your_side ) ;
12137: LD_VAR 0 1
12141: PPUSH
12142: LD_OWVAR 2
12146: PPUSH
12147: CALL_OW 235
// end ;
12151: PPOPN 2
12153: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
12154: LD_EXP 12
12158: PUSH
12159: LD_EXP 45
12163: AND
12164: IFFALSE 12270
12166: GO 12168
12168: DISABLE
12169: LD_INT 0
12171: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12172: LD_ADDR_VAR 0 1
12176: PUSH
12177: LD_INT 22
12179: PUSH
12180: LD_OWVAR 2
12184: PUSH
12185: EMPTY
12186: LIST
12187: LIST
12188: PUSH
12189: LD_INT 2
12191: PUSH
12192: LD_INT 30
12194: PUSH
12195: LD_INT 0
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: LD_INT 30
12204: PUSH
12205: LD_INT 1
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: LIST
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PPUSH
12221: CALL_OW 69
12225: ST_TO_ADDR
// if not depot then
12226: LD_VAR 0 1
12230: NOT
12231: IFFALSE 12235
// exit ;
12233: GO 12270
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
12235: LD_VAR 0 1
12239: PUSH
12240: LD_INT 1
12242: ARRAY
12243: PPUSH
12244: CALL_OW 250
12248: PPUSH
12249: LD_VAR 0 1
12253: PUSH
12254: LD_INT 1
12256: ARRAY
12257: PPUSH
12258: CALL_OW 251
12262: PPUSH
12263: LD_INT 70
12265: PPUSH
12266: CALL_OW 495
// end ;
12270: PPOPN 1
12272: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
12273: LD_EXP 12
12277: PUSH
12278: LD_EXP 46
12282: AND
12283: IFFALSE 12494
12285: GO 12287
12287: DISABLE
12288: LD_INT 0
12290: PPUSH
12291: PPUSH
12292: PPUSH
12293: PPUSH
12294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12295: LD_ADDR_VAR 0 5
12299: PUSH
12300: LD_INT 22
12302: PUSH
12303: LD_OWVAR 2
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: PUSH
12312: LD_INT 21
12314: PUSH
12315: LD_INT 1
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PPUSH
12326: CALL_OW 69
12330: ST_TO_ADDR
// if not tmp then
12331: LD_VAR 0 5
12335: NOT
12336: IFFALSE 12340
// exit ;
12338: GO 12494
// for i in tmp do
12340: LD_ADDR_VAR 0 1
12344: PUSH
12345: LD_VAR 0 5
12349: PUSH
12350: FOR_IN
12351: IFFALSE 12492
// begin d := rand ( 0 , 5 ) ;
12353: LD_ADDR_VAR 0 4
12357: PUSH
12358: LD_INT 0
12360: PPUSH
12361: LD_INT 5
12363: PPUSH
12364: CALL_OW 12
12368: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
12369: LD_ADDR_VAR 0 2
12373: PUSH
12374: LD_VAR 0 1
12378: PPUSH
12379: CALL_OW 250
12383: PPUSH
12384: LD_VAR 0 4
12388: PPUSH
12389: LD_INT 3
12391: PPUSH
12392: LD_INT 12
12394: PPUSH
12395: CALL_OW 12
12399: PPUSH
12400: CALL_OW 272
12404: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
12405: LD_ADDR_VAR 0 3
12409: PUSH
12410: LD_VAR 0 1
12414: PPUSH
12415: CALL_OW 251
12419: PPUSH
12420: LD_VAR 0 4
12424: PPUSH
12425: LD_INT 3
12427: PPUSH
12428: LD_INT 12
12430: PPUSH
12431: CALL_OW 12
12435: PPUSH
12436: CALL_OW 273
12440: ST_TO_ADDR
// if ValidHex ( x , y ) then
12441: LD_VAR 0 2
12445: PPUSH
12446: LD_VAR 0 3
12450: PPUSH
12451: CALL_OW 488
12455: IFFALSE 12490
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
12457: LD_VAR 0 1
12461: PPUSH
12462: LD_VAR 0 2
12466: PPUSH
12467: LD_VAR 0 3
12471: PPUSH
12472: LD_INT 3
12474: PPUSH
12475: LD_INT 6
12477: PPUSH
12478: CALL_OW 12
12482: PPUSH
12483: LD_INT 1
12485: PPUSH
12486: CALL_OW 483
// end ;
12490: GO 12350
12492: POP
12493: POP
// end ;
12494: PPOPN 5
12496: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
12497: LD_EXP 12
12501: PUSH
12502: LD_EXP 47
12506: AND
12507: IFFALSE 12601
12509: GO 12511
12511: DISABLE
12512: LD_INT 0
12514: PPUSH
12515: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
12516: LD_ADDR_VAR 0 2
12520: PUSH
12521: LD_INT 22
12523: PUSH
12524: LD_OWVAR 2
12528: PUSH
12529: EMPTY
12530: LIST
12531: LIST
12532: PUSH
12533: LD_INT 32
12535: PUSH
12536: LD_INT 1
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: PUSH
12543: LD_INT 21
12545: PUSH
12546: LD_INT 2
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: LIST
12557: PPUSH
12558: CALL_OW 69
12562: ST_TO_ADDR
// if not tmp then
12563: LD_VAR 0 2
12567: NOT
12568: IFFALSE 12572
// exit ;
12570: GO 12601
// for i in tmp do
12572: LD_ADDR_VAR 0 1
12576: PUSH
12577: LD_VAR 0 2
12581: PUSH
12582: FOR_IN
12583: IFFALSE 12599
// SetFuel ( i , 0 ) ;
12585: LD_VAR 0 1
12589: PPUSH
12590: LD_INT 0
12592: PPUSH
12593: CALL_OW 240
12597: GO 12582
12599: POP
12600: POP
// end ;
12601: PPOPN 2
12603: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
12604: LD_EXP 12
12608: PUSH
12609: LD_EXP 48
12613: AND
12614: IFFALSE 12680
12616: GO 12618
12618: DISABLE
12619: LD_INT 0
12621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12622: LD_ADDR_VAR 0 1
12626: PUSH
12627: LD_INT 22
12629: PUSH
12630: LD_OWVAR 2
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 30
12641: PUSH
12642: LD_INT 29
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: EMPTY
12650: LIST
12651: LIST
12652: PPUSH
12653: CALL_OW 69
12657: ST_TO_ADDR
// if not tmp then
12658: LD_VAR 0 1
12662: NOT
12663: IFFALSE 12667
// exit ;
12665: GO 12680
// DestroyUnit ( tmp [ 1 ] ) ;
12667: LD_VAR 0 1
12671: PUSH
12672: LD_INT 1
12674: ARRAY
12675: PPUSH
12676: CALL_OW 65
// end ;
12680: PPOPN 1
12682: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
12683: LD_EXP 12
12687: PUSH
12688: LD_EXP 50
12692: AND
12693: IFFALSE 12822
12695: GO 12697
12697: DISABLE
12698: LD_INT 0
12700: PPUSH
// begin uc_side := 0 ;
12701: LD_ADDR_OWVAR 20
12705: PUSH
12706: LD_INT 0
12708: ST_TO_ADDR
// uc_nation := nation_arabian ;
12709: LD_ADDR_OWVAR 21
12713: PUSH
12714: LD_INT 2
12716: ST_TO_ADDR
// hc_gallery :=  ;
12717: LD_ADDR_OWVAR 33
12721: PUSH
12722: LD_STRING 
12724: ST_TO_ADDR
// hc_name :=  ;
12725: LD_ADDR_OWVAR 26
12729: PUSH
12730: LD_STRING 
12732: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
12733: LD_INT 1
12735: PPUSH
12736: LD_INT 11
12738: PPUSH
12739: LD_INT 10
12741: PPUSH
12742: CALL_OW 380
// un := CreateHuman ;
12746: LD_ADDR_VAR 0 1
12750: PUSH
12751: CALL_OW 44
12755: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12756: LD_VAR 0 1
12760: PPUSH
12761: LD_INT 1
12763: PPUSH
12764: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12768: LD_INT 35
12770: PPUSH
12771: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: LD_INT 22
12782: PUSH
12783: LD_OWVAR 2
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: PPUSH
12792: CALL_OW 69
12796: PPUSH
12797: LD_VAR 0 1
12801: PPUSH
12802: CALL_OW 74
12806: PPUSH
12807: CALL_OW 115
// until IsDead ( un ) ;
12811: LD_VAR 0 1
12815: PPUSH
12816: CALL_OW 301
12820: IFFALSE 12768
// end ;
12822: PPOPN 1
12824: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
12825: LD_EXP 12
12829: PUSH
12830: LD_EXP 52
12834: AND
12835: IFFALSE 12847
12837: GO 12839
12839: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
12840: LD_STRING earthquake(getX(game), 0, 32)
12842: PPUSH
12843: CALL_OW 559
12847: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
12848: LD_EXP 12
12852: PUSH
12853: LD_EXP 53
12857: AND
12858: IFFALSE 12949
12860: GO 12862
12862: DISABLE
12863: LD_INT 0
12865: PPUSH
// begin enable ;
12866: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
12867: LD_ADDR_VAR 0 1
12871: PUSH
12872: LD_INT 22
12874: PUSH
12875: LD_OWVAR 2
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: PUSH
12884: LD_INT 21
12886: PUSH
12887: LD_INT 2
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: PUSH
12894: LD_INT 33
12896: PUSH
12897: LD_INT 3
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: LIST
12908: PPUSH
12909: CALL_OW 69
12913: ST_TO_ADDR
// if not tmp then
12914: LD_VAR 0 1
12918: NOT
12919: IFFALSE 12923
// exit ;
12921: GO 12949
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
12923: LD_VAR 0 1
12927: PUSH
12928: LD_INT 1
12930: PPUSH
12931: LD_VAR 0 1
12935: PPUSH
12936: CALL_OW 12
12940: ARRAY
12941: PPUSH
12942: LD_INT 1
12944: PPUSH
12945: CALL_OW 234
// end ;
12949: PPOPN 1
12951: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
12952: LD_EXP 12
12956: PUSH
12957: LD_EXP 54
12961: AND
12962: IFFALSE 13103
12964: GO 12966
12966: DISABLE
12967: LD_INT 0
12969: PPUSH
12970: PPUSH
12971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12972: LD_ADDR_VAR 0 3
12976: PUSH
12977: LD_INT 22
12979: PUSH
12980: LD_OWVAR 2
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 25
12991: PUSH
12992: LD_INT 1
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PPUSH
13003: CALL_OW 69
13007: ST_TO_ADDR
// if not tmp then
13008: LD_VAR 0 3
13012: NOT
13013: IFFALSE 13017
// exit ;
13015: GO 13103
// un := tmp [ rand ( 1 , tmp ) ] ;
13017: LD_ADDR_VAR 0 2
13021: PUSH
13022: LD_VAR 0 3
13026: PUSH
13027: LD_INT 1
13029: PPUSH
13030: LD_VAR 0 3
13034: PPUSH
13035: CALL_OW 12
13039: ARRAY
13040: ST_TO_ADDR
// if Crawls ( un ) then
13041: LD_VAR 0 2
13045: PPUSH
13046: CALL_OW 318
13050: IFFALSE 13061
// ComWalk ( un ) ;
13052: LD_VAR 0 2
13056: PPUSH
13057: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
13061: LD_VAR 0 2
13065: PPUSH
13066: LD_INT 9
13068: PPUSH
13069: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
13073: LD_INT 28
13075: PPUSH
13076: LD_OWVAR 2
13080: PPUSH
13081: LD_INT 2
13083: PPUSH
13084: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
13088: LD_INT 29
13090: PPUSH
13091: LD_OWVAR 2
13095: PPUSH
13096: LD_INT 2
13098: PPUSH
13099: CALL_OW 322
// end ;
13103: PPOPN 3
13105: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
13106: LD_EXP 12
13110: PUSH
13111: LD_EXP 55
13115: AND
13116: IFFALSE 13227
13118: GO 13120
13120: DISABLE
13121: LD_INT 0
13123: PPUSH
13124: PPUSH
13125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13126: LD_ADDR_VAR 0 3
13130: PUSH
13131: LD_INT 22
13133: PUSH
13134: LD_OWVAR 2
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 25
13145: PUSH
13146: LD_INT 1
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: PPUSH
13157: CALL_OW 69
13161: ST_TO_ADDR
// if not tmp then
13162: LD_VAR 0 3
13166: NOT
13167: IFFALSE 13171
// exit ;
13169: GO 13227
// un := tmp [ rand ( 1 , tmp ) ] ;
13171: LD_ADDR_VAR 0 2
13175: PUSH
13176: LD_VAR 0 3
13180: PUSH
13181: LD_INT 1
13183: PPUSH
13184: LD_VAR 0 3
13188: PPUSH
13189: CALL_OW 12
13193: ARRAY
13194: ST_TO_ADDR
// if Crawls ( un ) then
13195: LD_VAR 0 2
13199: PPUSH
13200: CALL_OW 318
13204: IFFALSE 13215
// ComWalk ( un ) ;
13206: LD_VAR 0 2
13210: PPUSH
13211: CALL_OW 138
// SetClass ( un , class_mortar ) ;
13215: LD_VAR 0 2
13219: PPUSH
13220: LD_INT 8
13222: PPUSH
13223: CALL_OW 336
// end ;
13227: PPOPN 3
13229: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
13230: LD_EXP 12
13234: PUSH
13235: LD_EXP 56
13239: AND
13240: IFFALSE 13384
13242: GO 13244
13244: DISABLE
13245: LD_INT 0
13247: PPUSH
13248: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
13249: LD_ADDR_VAR 0 2
13253: PUSH
13254: LD_INT 22
13256: PUSH
13257: LD_OWVAR 2
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: PUSH
13266: LD_INT 21
13268: PUSH
13269: LD_INT 2
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: PUSH
13276: LD_INT 2
13278: PUSH
13279: LD_INT 34
13281: PUSH
13282: LD_INT 12
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: PUSH
13289: LD_INT 34
13291: PUSH
13292: LD_INT 51
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PUSH
13299: LD_INT 34
13301: PUSH
13302: LD_INT 32
13304: PUSH
13305: EMPTY
13306: LIST
13307: LIST
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: LIST
13319: PPUSH
13320: CALL_OW 69
13324: ST_TO_ADDR
// if not tmp then
13325: LD_VAR 0 2
13329: NOT
13330: IFFALSE 13334
// exit ;
13332: GO 13384
// for i in tmp do
13334: LD_ADDR_VAR 0 1
13338: PUSH
13339: LD_VAR 0 2
13343: PUSH
13344: FOR_IN
13345: IFFALSE 13382
// if GetCargo ( i , mat_artifact ) = 0 then
13347: LD_VAR 0 1
13351: PPUSH
13352: LD_INT 4
13354: PPUSH
13355: CALL_OW 289
13359: PUSH
13360: LD_INT 0
13362: EQUAL
13363: IFFALSE 13380
// SetCargo ( i , mat_siberit , 100 ) ;
13365: LD_VAR 0 1
13369: PPUSH
13370: LD_INT 3
13372: PPUSH
13373: LD_INT 100
13375: PPUSH
13376: CALL_OW 290
13380: GO 13344
13382: POP
13383: POP
// end ;
13384: PPOPN 2
13386: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
13387: LD_EXP 12
13391: PUSH
13392: LD_EXP 57
13396: AND
13397: IFFALSE 13550
13399: GO 13401
13401: DISABLE
13402: LD_INT 0
13404: PPUSH
13405: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
13406: LD_ADDR_VAR 0 2
13410: PUSH
13411: LD_INT 22
13413: PUSH
13414: LD_OWVAR 2
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: PPUSH
13423: CALL_OW 69
13427: ST_TO_ADDR
// if not tmp then
13428: LD_VAR 0 2
13432: NOT
13433: IFFALSE 13437
// exit ;
13435: GO 13550
// for i := 1 to 2 do
13437: LD_ADDR_VAR 0 1
13441: PUSH
13442: DOUBLE
13443: LD_INT 1
13445: DEC
13446: ST_TO_ADDR
13447: LD_INT 2
13449: PUSH
13450: FOR_TO
13451: IFFALSE 13548
// begin uc_side := your_side ;
13453: LD_ADDR_OWVAR 20
13457: PUSH
13458: LD_OWVAR 2
13462: ST_TO_ADDR
// uc_nation := nation_american ;
13463: LD_ADDR_OWVAR 21
13467: PUSH
13468: LD_INT 1
13470: ST_TO_ADDR
// vc_chassis := us_morphling ;
13471: LD_ADDR_OWVAR 37
13475: PUSH
13476: LD_INT 5
13478: ST_TO_ADDR
// vc_engine := engine_siberite ;
13479: LD_ADDR_OWVAR 39
13483: PUSH
13484: LD_INT 3
13486: ST_TO_ADDR
// vc_control := control_computer ;
13487: LD_ADDR_OWVAR 38
13491: PUSH
13492: LD_INT 3
13494: ST_TO_ADDR
// vc_weapon := us_double_laser ;
13495: LD_ADDR_OWVAR 40
13499: PUSH
13500: LD_INT 10
13502: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
13503: CALL_OW 45
13507: PPUSH
13508: LD_VAR 0 2
13512: PUSH
13513: LD_INT 1
13515: ARRAY
13516: PPUSH
13517: CALL_OW 250
13521: PPUSH
13522: LD_VAR 0 2
13526: PUSH
13527: LD_INT 1
13529: ARRAY
13530: PPUSH
13531: CALL_OW 251
13535: PPUSH
13536: LD_INT 12
13538: PPUSH
13539: LD_INT 1
13541: PPUSH
13542: CALL_OW 50
// end ;
13546: GO 13450
13548: POP
13549: POP
// end ;
13550: PPOPN 2
13552: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
13553: LD_EXP 12
13557: PUSH
13558: LD_EXP 58
13562: AND
13563: IFFALSE 13785
13565: GO 13567
13567: DISABLE
13568: LD_INT 0
13570: PPUSH
13571: PPUSH
13572: PPUSH
13573: PPUSH
13574: PPUSH
13575: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13576: LD_ADDR_VAR 0 6
13580: PUSH
13581: LD_INT 22
13583: PUSH
13584: LD_OWVAR 2
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: LD_INT 21
13595: PUSH
13596: LD_INT 1
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: PUSH
13603: LD_INT 3
13605: PUSH
13606: LD_INT 23
13608: PUSH
13609: LD_INT 0
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: LIST
13619: PUSH
13620: EMPTY
13621: LIST
13622: LIST
13623: LIST
13624: PPUSH
13625: CALL_OW 69
13629: ST_TO_ADDR
// if not tmp then
13630: LD_VAR 0 6
13634: NOT
13635: IFFALSE 13639
// exit ;
13637: GO 13785
// s1 := rand ( 1 , 4 ) ;
13639: LD_ADDR_VAR 0 2
13643: PUSH
13644: LD_INT 1
13646: PPUSH
13647: LD_INT 4
13649: PPUSH
13650: CALL_OW 12
13654: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
13655: LD_ADDR_VAR 0 4
13659: PUSH
13660: LD_VAR 0 6
13664: PUSH
13665: LD_INT 1
13667: ARRAY
13668: PPUSH
13669: LD_VAR 0 2
13673: PPUSH
13674: CALL_OW 259
13678: ST_TO_ADDR
// if s1 = 1 then
13679: LD_VAR 0 2
13683: PUSH
13684: LD_INT 1
13686: EQUAL
13687: IFFALSE 13707
// s2 := rand ( 2 , 4 ) else
13689: LD_ADDR_VAR 0 3
13693: PUSH
13694: LD_INT 2
13696: PPUSH
13697: LD_INT 4
13699: PPUSH
13700: CALL_OW 12
13704: ST_TO_ADDR
13705: GO 13715
// s2 := 1 ;
13707: LD_ADDR_VAR 0 3
13711: PUSH
13712: LD_INT 1
13714: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
13715: LD_ADDR_VAR 0 5
13719: PUSH
13720: LD_VAR 0 6
13724: PUSH
13725: LD_INT 1
13727: ARRAY
13728: PPUSH
13729: LD_VAR 0 3
13733: PPUSH
13734: CALL_OW 259
13738: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
13739: LD_VAR 0 6
13743: PUSH
13744: LD_INT 1
13746: ARRAY
13747: PPUSH
13748: LD_VAR 0 2
13752: PPUSH
13753: LD_VAR 0 5
13757: PPUSH
13758: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
13762: LD_VAR 0 6
13766: PUSH
13767: LD_INT 1
13769: ARRAY
13770: PPUSH
13771: LD_VAR 0 3
13775: PPUSH
13776: LD_VAR 0 4
13780: PPUSH
13781: CALL_OW 237
// end ;
13785: PPOPN 6
13787: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
13788: LD_EXP 12
13792: PUSH
13793: LD_EXP 59
13797: AND
13798: IFFALSE 13877
13800: GO 13802
13802: DISABLE
13803: LD_INT 0
13805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
13806: LD_ADDR_VAR 0 1
13810: PUSH
13811: LD_INT 22
13813: PUSH
13814: LD_OWVAR 2
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: PUSH
13823: LD_INT 30
13825: PUSH
13826: LD_INT 3
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: PPUSH
13837: CALL_OW 69
13841: ST_TO_ADDR
// if not tmp then
13842: LD_VAR 0 1
13846: NOT
13847: IFFALSE 13851
// exit ;
13849: GO 13877
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
13851: LD_VAR 0 1
13855: PUSH
13856: LD_INT 1
13858: PPUSH
13859: LD_VAR 0 1
13863: PPUSH
13864: CALL_OW 12
13868: ARRAY
13869: PPUSH
13870: LD_INT 1
13872: PPUSH
13873: CALL_OW 234
// end ;
13877: PPOPN 1
13879: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
13880: LD_EXP 12
13884: PUSH
13885: LD_EXP 60
13889: AND
13890: IFFALSE 14002
13892: GO 13894
13894: DISABLE
13895: LD_INT 0
13897: PPUSH
13898: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
13899: LD_ADDR_VAR 0 2
13903: PUSH
13904: LD_INT 22
13906: PUSH
13907: LD_OWVAR 2
13911: PUSH
13912: EMPTY
13913: LIST
13914: LIST
13915: PUSH
13916: LD_INT 2
13918: PUSH
13919: LD_INT 30
13921: PUSH
13922: LD_INT 27
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: LD_INT 30
13931: PUSH
13932: LD_INT 26
13934: PUSH
13935: EMPTY
13936: LIST
13937: LIST
13938: PUSH
13939: LD_INT 30
13941: PUSH
13942: LD_INT 28
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: ST_TO_ADDR
// if not tmp then
13964: LD_VAR 0 2
13968: NOT
13969: IFFALSE 13973
// exit ;
13971: GO 14002
// for i in tmp do
13973: LD_ADDR_VAR 0 1
13977: PUSH
13978: LD_VAR 0 2
13982: PUSH
13983: FOR_IN
13984: IFFALSE 14000
// SetLives ( i , 1 ) ;
13986: LD_VAR 0 1
13990: PPUSH
13991: LD_INT 1
13993: PPUSH
13994: CALL_OW 234
13998: GO 13983
14000: POP
14001: POP
// end ;
14002: PPOPN 2
14004: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
14005: LD_EXP 12
14009: PUSH
14010: LD_EXP 61
14014: AND
14015: IFFALSE 14289
14017: GO 14019
14019: DISABLE
14020: LD_INT 0
14022: PPUSH
14023: PPUSH
14024: PPUSH
// begin i := rand ( 1 , 7 ) ;
14025: LD_ADDR_VAR 0 1
14029: PUSH
14030: LD_INT 1
14032: PPUSH
14033: LD_INT 7
14035: PPUSH
14036: CALL_OW 12
14040: ST_TO_ADDR
// case i of 1 :
14041: LD_VAR 0 1
14045: PUSH
14046: LD_INT 1
14048: DOUBLE
14049: EQUAL
14050: IFTRUE 14054
14052: GO 14064
14054: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
14055: LD_STRING earthquake(getX(game), 0, 32)
14057: PPUSH
14058: CALL_OW 559
14062: GO 14289
14064: LD_INT 2
14066: DOUBLE
14067: EQUAL
14068: IFTRUE 14072
14070: GO 14086
14072: POP
// begin ToLua ( displayStucuk(); ) ;
14073: LD_STRING displayStucuk();
14075: PPUSH
14076: CALL_OW 559
// ResetFog ;
14080: CALL_OW 335
// end ; 3 :
14084: GO 14289
14086: LD_INT 3
14088: DOUBLE
14089: EQUAL
14090: IFTRUE 14094
14092: GO 14198
14094: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14095: LD_ADDR_VAR 0 2
14099: PUSH
14100: LD_INT 22
14102: PUSH
14103: LD_OWVAR 2
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PUSH
14112: LD_INT 25
14114: PUSH
14115: LD_INT 1
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: PPUSH
14126: CALL_OW 69
14130: ST_TO_ADDR
// if not tmp then
14131: LD_VAR 0 2
14135: NOT
14136: IFFALSE 14140
// exit ;
14138: GO 14289
// un := tmp [ rand ( 1 , tmp ) ] ;
14140: LD_ADDR_VAR 0 3
14144: PUSH
14145: LD_VAR 0 2
14149: PUSH
14150: LD_INT 1
14152: PPUSH
14153: LD_VAR 0 2
14157: PPUSH
14158: CALL_OW 12
14162: ARRAY
14163: ST_TO_ADDR
// if Crawls ( un ) then
14164: LD_VAR 0 3
14168: PPUSH
14169: CALL_OW 318
14173: IFFALSE 14184
// ComWalk ( un ) ;
14175: LD_VAR 0 3
14179: PPUSH
14180: CALL_OW 138
// SetClass ( un , class_mortar ) ;
14184: LD_VAR 0 3
14188: PPUSH
14189: LD_INT 8
14191: PPUSH
14192: CALL_OW 336
// end ; 4 :
14196: GO 14289
14198: LD_INT 4
14200: DOUBLE
14201: EQUAL
14202: IFTRUE 14206
14204: GO 14267
14206: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14207: LD_ADDR_VAR 0 2
14211: PUSH
14212: LD_INT 22
14214: PUSH
14215: LD_OWVAR 2
14219: PUSH
14220: EMPTY
14221: LIST
14222: LIST
14223: PUSH
14224: LD_INT 30
14226: PUSH
14227: LD_INT 29
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PPUSH
14238: CALL_OW 69
14242: ST_TO_ADDR
// if not tmp then
14243: LD_VAR 0 2
14247: NOT
14248: IFFALSE 14252
// exit ;
14250: GO 14289
// DestroyUnit ( tmp [ 1 ] ) ;
14252: LD_VAR 0 2
14256: PUSH
14257: LD_INT 1
14259: ARRAY
14260: PPUSH
14261: CALL_OW 65
// end ; 5 .. 7 :
14265: GO 14289
14267: LD_INT 5
14269: DOUBLE
14270: GREATEREQUAL
14271: IFFALSE 14279
14273: LD_INT 7
14275: DOUBLE
14276: LESSEQUAL
14277: IFTRUE 14281
14279: GO 14288
14281: POP
// StreamSibBomb ; end ;
14282: CALL 10569 0 0
14286: GO 14289
14288: POP
// end ;
14289: PPOPN 3
14291: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
14292: LD_EXP 12
14296: PUSH
14297: LD_EXP 62
14301: AND
14302: IFFALSE 14458
14304: GO 14306
14306: DISABLE
14307: LD_INT 0
14309: PPUSH
14310: PPUSH
14311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
14312: LD_ADDR_VAR 0 2
14316: PUSH
14317: LD_INT 81
14319: PUSH
14320: LD_OWVAR 2
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PUSH
14329: LD_INT 2
14331: PUSH
14332: LD_INT 21
14334: PUSH
14335: LD_INT 1
14337: PUSH
14338: EMPTY
14339: LIST
14340: LIST
14341: PUSH
14342: LD_INT 21
14344: PUSH
14345: LD_INT 2
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: LIST
14356: PUSH
14357: EMPTY
14358: LIST
14359: LIST
14360: PPUSH
14361: CALL_OW 69
14365: ST_TO_ADDR
// if not tmp then
14366: LD_VAR 0 2
14370: NOT
14371: IFFALSE 14375
// exit ;
14373: GO 14458
// p := 0 ;
14375: LD_ADDR_VAR 0 3
14379: PUSH
14380: LD_INT 0
14382: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14383: LD_INT 35
14385: PPUSH
14386: CALL_OW 67
// p := p + 1 ;
14390: LD_ADDR_VAR 0 3
14394: PUSH
14395: LD_VAR 0 3
14399: PUSH
14400: LD_INT 1
14402: PLUS
14403: ST_TO_ADDR
// for i in tmp do
14404: LD_ADDR_VAR 0 1
14408: PUSH
14409: LD_VAR 0 2
14413: PUSH
14414: FOR_IN
14415: IFFALSE 14446
// if GetLives ( i ) < 1000 then
14417: LD_VAR 0 1
14421: PPUSH
14422: CALL_OW 256
14426: PUSH
14427: LD_INT 1000
14429: LESS
14430: IFFALSE 14444
// SetLives ( i , 1000 ) ;
14432: LD_VAR 0 1
14436: PPUSH
14437: LD_INT 1000
14439: PPUSH
14440: CALL_OW 234
14444: GO 14414
14446: POP
14447: POP
// until p > 20 ;
14448: LD_VAR 0 3
14452: PUSH
14453: LD_INT 20
14455: GREATER
14456: IFFALSE 14383
// end ;
14458: PPOPN 3
14460: END
// every 0 0$1 trigger StreamModeActive and sTime do
14461: LD_EXP 12
14465: PUSH
14466: LD_EXP 63
14470: AND
14471: IFFALSE 14506
14473: GO 14475
14475: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
14476: LD_INT 28
14478: PPUSH
14479: LD_OWVAR 2
14483: PPUSH
14484: LD_INT 2
14486: PPUSH
14487: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
14491: LD_INT 30
14493: PPUSH
14494: LD_OWVAR 2
14498: PPUSH
14499: LD_INT 2
14501: PPUSH
14502: CALL_OW 322
// end ;
14506: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
14507: LD_EXP 12
14511: PUSH
14512: LD_EXP 64
14516: AND
14517: IFFALSE 14638
14519: GO 14521
14521: DISABLE
14522: LD_INT 0
14524: PPUSH
14525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14526: LD_ADDR_VAR 0 2
14530: PUSH
14531: LD_INT 22
14533: PUSH
14534: LD_OWVAR 2
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: LD_INT 21
14545: PUSH
14546: LD_INT 1
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: PUSH
14553: LD_INT 3
14555: PUSH
14556: LD_INT 23
14558: PUSH
14559: LD_INT 0
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: PUSH
14566: EMPTY
14567: LIST
14568: LIST
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: LIST
14574: PPUSH
14575: CALL_OW 69
14579: ST_TO_ADDR
// if not tmp then
14580: LD_VAR 0 2
14584: NOT
14585: IFFALSE 14589
// exit ;
14587: GO 14638
// for i in tmp do
14589: LD_ADDR_VAR 0 1
14593: PUSH
14594: LD_VAR 0 2
14598: PUSH
14599: FOR_IN
14600: IFFALSE 14636
// begin if Crawls ( i ) then
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 318
14611: IFFALSE 14622
// ComWalk ( i ) ;
14613: LD_VAR 0 1
14617: PPUSH
14618: CALL_OW 138
// SetClass ( i , 2 ) ;
14622: LD_VAR 0 1
14626: PPUSH
14627: LD_INT 2
14629: PPUSH
14630: CALL_OW 336
// end ;
14634: GO 14599
14636: POP
14637: POP
// end ;
14638: PPOPN 2
14640: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
14641: LD_EXP 12
14645: PUSH
14646: LD_EXP 65
14650: AND
14651: IFFALSE 14932
14653: GO 14655
14655: DISABLE
14656: LD_INT 0
14658: PPUSH
14659: PPUSH
14660: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
14661: LD_OWVAR 2
14665: PPUSH
14666: LD_INT 9
14668: PPUSH
14669: LD_INT 1
14671: PPUSH
14672: LD_INT 1
14674: PPUSH
14675: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
14679: LD_INT 9
14681: PPUSH
14682: LD_OWVAR 2
14686: PPUSH
14687: CALL_OW 343
// uc_side := 9 ;
14691: LD_ADDR_OWVAR 20
14695: PUSH
14696: LD_INT 9
14698: ST_TO_ADDR
// uc_nation := 2 ;
14699: LD_ADDR_OWVAR 21
14703: PUSH
14704: LD_INT 2
14706: ST_TO_ADDR
// hc_name := Dark Warrior ;
14707: LD_ADDR_OWVAR 26
14711: PUSH
14712: LD_STRING Dark Warrior
14714: ST_TO_ADDR
// hc_gallery :=  ;
14715: LD_ADDR_OWVAR 33
14719: PUSH
14720: LD_STRING 
14722: ST_TO_ADDR
// hc_noskilllimit := true ;
14723: LD_ADDR_OWVAR 76
14727: PUSH
14728: LD_INT 1
14730: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
14731: LD_ADDR_OWVAR 31
14735: PUSH
14736: LD_INT 30
14738: PUSH
14739: LD_INT 30
14741: PUSH
14742: LD_INT 30
14744: PUSH
14745: LD_INT 30
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: ST_TO_ADDR
// un := CreateHuman ;
14754: LD_ADDR_VAR 0 3
14758: PUSH
14759: CALL_OW 44
14763: ST_TO_ADDR
// hc_noskilllimit := false ;
14764: LD_ADDR_OWVAR 76
14768: PUSH
14769: LD_INT 0
14771: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14772: LD_VAR 0 3
14776: PPUSH
14777: LD_INT 1
14779: PPUSH
14780: CALL_OW 51
// p := 0 ;
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: LD_INT 0
14791: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14792: LD_INT 35
14794: PPUSH
14795: CALL_OW 67
// p := p + 1 ;
14799: LD_ADDR_VAR 0 2
14803: PUSH
14804: LD_VAR 0 2
14808: PUSH
14809: LD_INT 1
14811: PLUS
14812: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
14813: LD_VAR 0 3
14817: PPUSH
14818: CALL_OW 256
14822: PUSH
14823: LD_INT 1000
14825: LESS
14826: IFFALSE 14840
// SetLives ( un , 1000 ) ;
14828: LD_VAR 0 3
14832: PPUSH
14833: LD_INT 1000
14835: PPUSH
14836: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
14840: LD_VAR 0 3
14844: PPUSH
14845: LD_INT 81
14847: PUSH
14848: LD_OWVAR 2
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: LD_INT 91
14859: PUSH
14860: LD_VAR 0 3
14864: PUSH
14865: LD_INT 30
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: LIST
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PPUSH
14877: CALL_OW 69
14881: PPUSH
14882: LD_VAR 0 3
14886: PPUSH
14887: CALL_OW 74
14891: PPUSH
14892: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
14896: LD_VAR 0 2
14900: PUSH
14901: LD_INT 60
14903: GREATER
14904: PUSH
14905: LD_VAR 0 3
14909: PPUSH
14910: CALL_OW 301
14914: OR
14915: IFFALSE 14792
// if un then
14917: LD_VAR 0 3
14921: IFFALSE 14932
// RemoveUnit ( un ) ;
14923: LD_VAR 0 3
14927: PPUSH
14928: CALL_OW 64
// end ; end_of_file end_of_file
14932: PPOPN 3
14934: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
14935: GO 14937
14937: DISABLE
// begin ru_radar := 98 ;
14938: LD_ADDR_EXP 66
14942: PUSH
14943: LD_INT 98
14945: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
14946: LD_ADDR_EXP 67
14950: PUSH
14951: LD_INT 89
14953: ST_TO_ADDR
// us_hack := 99 ;
14954: LD_ADDR_EXP 68
14958: PUSH
14959: LD_INT 99
14961: ST_TO_ADDR
// us_artillery := 97 ;
14962: LD_ADDR_EXP 69
14966: PUSH
14967: LD_INT 97
14969: ST_TO_ADDR
// ar_bio_bomb := 91 ;
14970: LD_ADDR_EXP 70
14974: PUSH
14975: LD_INT 91
14977: ST_TO_ADDR
// end ;
14978: END
