// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareGame ;
   4: CALL 13 0 0
// PrepareUnits ;
   8: CALL 299 0 0
// end ;
  12: END
// export mechanics , time_to_destroy , players , sib_bomb , time , veh_amount ; export p1 , p2 , p3 , p4 , p5 ; function PrepareGame ; var debug , i ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
// debug := false ;
  18: LD_ADDR_VAR 0 2
  22: PUSH
  23: LD_INT 0
  25: ST_TO_ADDR
// if debug then
  26: LD_VAR 0 2
  30: IFFALSE 81
// begin mechanics := 5 ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 5
  39: ST_TO_ADDR
// time_to_destroy := 45 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 45
  47: ST_TO_ADDR
// players := 4 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 4
  55: ST_TO_ADDR
// sib_bomb := true ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 1
  63: ST_TO_ADDR
// time := 3 3$00 ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 6300
  71: ST_TO_ADDR
// FogOff ( 1 ) ;
  72: LD_INT 1
  74: PPUSH
  75: CALL_OW 344
// end else
  79: GO 214
// begin time := 3 3$00 ;
  81: LD_ADDR_EXP 5
  85: PUSH
  86: LD_INT 6300
  88: ST_TO_ADDR
// players := 4 ;
  89: LD_ADDR_EXP 3
  93: PUSH
  94: LD_INT 4
  96: ST_TO_ADDR
// sib_bomb := true ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 1
 104: ST_TO_ADDR
// mechanics := 4 ;
 105: LD_ADDR_EXP 1
 109: PUSH
 110: LD_INT 4
 112: ST_TO_ADDR
// mechanics := [ 3 , 4 , 5 ] [ GetMultiplayerSetting ( 0 ) ] ;
 113: LD_ADDR_EXP 1
 117: PUSH
 118: LD_INT 3
 120: PUSH
 121: LD_INT 4
 123: PUSH
 124: LD_INT 5
 126: PUSH
 127: EMPTY
 128: LIST
 129: LIST
 130: LIST
 131: PUSH
 132: LD_INT 0
 134: PPUSH
 135: CALL_OW 426
 139: ARRAY
 140: ST_TO_ADDR
// players := [ 3 , 4 , 5 ] [ GetMultiplayerSetting ( 1 ) ] ;
 141: LD_ADDR_EXP 3
 145: PUSH
 146: LD_INT 3
 148: PUSH
 149: LD_INT 4
 151: PUSH
 152: LD_INT 5
 154: PUSH
 155: EMPTY
 156: LIST
 157: LIST
 158: LIST
 159: PUSH
 160: LD_INT 1
 162: PPUSH
 163: CALL_OW 426
 167: ARRAY
 168: ST_TO_ADDR
// time := [ 3 3$00 , 5 5$00 , 10 10$00 ] [ GetMultiplayerSetting ( 2 ) ] ;
 169: LD_ADDR_EXP 5
 173: PUSH
 174: LD_INT 6300
 176: PUSH
 177: LD_INT 10500
 179: PUSH
 180: LD_INT 21000
 182: PUSH
 183: EMPTY
 184: LIST
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 2
 190: PPUSH
 191: CALL_OW 426
 195: ARRAY
 196: ST_TO_ADDR
// sib_bomb := GetMultiplayerSetting ( 3 ) - 1 ;
 197: LD_ADDR_EXP 4
 201: PUSH
 202: LD_INT 3
 204: PPUSH
 205: CALL_OW 426
 209: PUSH
 210: LD_INT 1
 212: MINUS
 213: ST_TO_ADDR
// end ; p1 := 0 ;
 214: LD_ADDR_EXP 7
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// p2 := 0 ;
 222: LD_ADDR_EXP 8
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// p3 := 0 ;
 230: LD_ADDR_EXP 9
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// p4 := 0 ;
 238: LD_ADDR_EXP 10
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// p5 := 0 ;
 246: LD_ADDR_EXP 11
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// veh_amount := 12 ;
 254: LD_ADDR_EXP 6
 258: PUSH
 259: LD_INT 12
 261: ST_TO_ADDR
// for i = 1 to 7 do
 262: LD_ADDR_VAR 0 3
 266: PUSH
 267: DOUBLE
 268: LD_INT 1
 270: DEC
 271: ST_TO_ADDR
 272: LD_INT 7
 274: PUSH
 275: FOR_TO
 276: IFFALSE 292
// ChangeSideFog ( i , 8 ) ;
 278: LD_VAR 0 3
 282: PPUSH
 283: LD_INT 8
 285: PPUSH
 286: CALL_OW 343
 290: GO 275
 292: POP
 293: POP
// end ; end_of_file
 294: LD_VAR 0 1
 298: RET
// export function PrepareUnits ; var i , side ; begin
 299: LD_INT 0
 301: PPUSH
 302: PPUSH
 303: PPUSH
// side := players ;
 304: LD_ADDR_VAR 0 3
 308: PUSH
 309: LD_EXP 3
 313: ST_TO_ADDR
// uc_nation := 1 ;
 314: LD_ADDR_OWVAR 21
 318: PUSH
 319: LD_INT 1
 321: ST_TO_ADDR
// for i = 1 to mechanics do
 322: LD_ADDR_VAR 0 2
 326: PUSH
 327: DOUBLE
 328: LD_INT 1
 330: DEC
 331: ST_TO_ADDR
 332: LD_EXP 1
 336: PUSH
 337: FOR_TO
 338: IFFALSE 402
// for side = 1 to players do
 340: LD_ADDR_VAR 0 3
 344: PUSH
 345: DOUBLE
 346: LD_INT 1
 348: DEC
 349: ST_TO_ADDR
 350: LD_EXP 3
 354: PUSH
 355: FOR_TO
 356: IFFALSE 398
// begin uc_side := side ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_VAR 0 3
 367: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 368: LD_INT 0
 370: PPUSH
 371: LD_INT 3
 373: PPUSH
 374: LD_INT 10
 376: PPUSH
 377: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 381: CALL_OW 44
 385: PPUSH
 386: LD_INT 6
 388: PPUSH
 389: LD_INT 0
 391: PPUSH
 392: CALL_OW 49
// end ;
 396: GO 355
 398: POP
 399: POP
 400: GO 337
 402: POP
 403: POP
// end ;
 404: LD_VAR 0 1
 408: RET
// function ToSpawn ( side ) ; begin
 409: LD_INT 0
 411: PPUSH
// uc_side := side ;
 412: LD_ADDR_OWVAR 20
 416: PUSH
 417: LD_VAR 0 1
 421: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 422: LD_INT 0
 424: PPUSH
 425: LD_INT 3
 427: PPUSH
 428: LD_INT 10
 430: PPUSH
 431: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 435: CALL_OW 44
 439: PPUSH
 440: LD_INT 6
 442: PPUSH
 443: LD_INT 0
 445: PPUSH
 446: CALL_OW 49
// end ;
 450: LD_VAR 0 2
 454: RET
// every 0 0$13 trigger time do var i , filter ;
 455: LD_EXP 5
 459: IFFALSE 569
 461: GO 463
 463: DISABLE
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// begin enable ;
 468: ENABLE
// for i = 1 to players do
 469: LD_ADDR_VAR 0 1
 473: PUSH
 474: DOUBLE
 475: LD_INT 1
 477: DEC
 478: ST_TO_ADDR
 479: LD_EXP 3
 483: PUSH
 484: FOR_TO
 485: IFFALSE 567
// begin filter := FilterAllUnits ( [ [ [ f_side , i ] , [ f_class , 3 ] , [ f_type , unit_human ] ] ] ) ;
 487: LD_ADDR_VAR 0 2
 491: PUSH
 492: LD_INT 22
 494: PUSH
 495: LD_VAR 0 1
 499: PUSH
 500: EMPTY
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 25
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: PUSH
 514: LD_INT 21
 516: PUSH
 517: LD_INT 1
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: PPUSH
 532: CALL_OW 69
 536: ST_TO_ADDR
// if filter < mechanics then
 537: LD_VAR 0 2
 541: PUSH
 542: LD_EXP 1
 546: LESS
 547: IFFALSE 565
// begin Wait ( 0 0$03 ) ;
 549: LD_INT 105
 551: PPUSH
 552: CALL_OW 67
// ToSpawn ( i ) ;
 556: LD_VAR 0 1
 560: PPUSH
 561: CALL 409 0 1
// end ; end ;
 565: GO 484
 567: POP
 568: POP
// end ;
 569: PPOPN 2
 571: END
// every 0 0$01 trigger time do var i , filter , filter2 , vehicles ;
 572: LD_EXP 5
 576: IFFALSE 943
 578: GO 580
 580: DISABLE
 581: LD_INT 0
 583: PPUSH
 584: PPUSH
 585: PPUSH
 586: PPUSH
// begin enable ;
 587: ENABLE
// filter2 := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_not , [ f_side , 0 ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 588: LD_ADDR_VAR 0 3
 592: PUSH
 593: LD_INT 21
 595: PUSH
 596: LD_INT 2
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 3
 605: PUSH
 606: LD_INT 22
 608: PUSH
 609: LD_INT 0
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: PUSH
 616: EMPTY
 617: LIST
 618: LIST
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 22
 625: PUSH
 626: LD_INT 1
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: PPUSH
 642: CALL_OW 69
 646: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 647: LD_ADDR_VAR 0 2
 651: PUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 54
 667: PUSH
 668: EMPTY
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 3
 677: PUSH
 678: LD_INT 22
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL_OW 69
 701: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 702: LD_ADDR_VAR 0 4
 706: PUSH
 707: LD_INT 21
 709: PUSH
 710: LD_INT 2
 712: PUSH
 713: EMPTY
 714: LIST
 715: LIST
 716: PUSH
 717: LD_INT 58
 719: PUSH
 720: EMPTY
 721: LIST
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: PPUSH
 727: CALL_OW 69
 731: ST_TO_ADDR
// if filter and vehicles then
 732: LD_VAR 0 2
 736: PUSH
 737: LD_VAR 0 4
 741: AND
 742: IFFALSE 879
// for i = 1 to filter do
 744: LD_ADDR_VAR 0 1
 748: PUSH
 749: DOUBLE
 750: LD_INT 1
 752: DEC
 753: ST_TO_ADDR
 754: LD_VAR 0 2
 758: PUSH
 759: FOR_TO
 760: IFFALSE 877
// if not HasTask ( filter [ i ] ) and IsOk ( filter [ i ] ) then
 762: LD_VAR 0 2
 766: PUSH
 767: LD_VAR 0 1
 771: ARRAY
 772: PPUSH
 773: CALL_OW 314
 777: NOT
 778: PUSH
 779: LD_VAR 0 2
 783: PUSH
 784: LD_VAR 0 1
 788: ARRAY
 789: PPUSH
 790: CALL_OW 302
 794: AND
 795: IFFALSE 875
// if GetDistUnits ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) < 45 then
 797: LD_VAR 0 2
 801: PUSH
 802: LD_VAR 0 1
 806: ARRAY
 807: PPUSH
 808: LD_VAR 0 4
 812: PPUSH
 813: LD_VAR 0 2
 817: PUSH
 818: LD_VAR 0 1
 822: ARRAY
 823: PPUSH
 824: CALL_OW 74
 828: PPUSH
 829: CALL_OW 296
 833: PUSH
 834: LD_INT 45
 836: LESS
 837: IFFALSE 875
// ComEnterUnit ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) ;
 839: LD_VAR 0 2
 843: PUSH
 844: LD_VAR 0 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 4
 854: PPUSH
 855: LD_VAR 0 2
 859: PUSH
 860: LD_VAR 0 1
 864: ARRAY
 865: PPUSH
 866: CALL_OW 74
 870: PPUSH
 871: CALL_OW 120
 875: GO 759
 877: POP
 878: POP
// if filter2 then
 879: LD_VAR 0 3
 883: IFFALSE 943
// for i = 1 to filter2 do
 885: LD_ADDR_VAR 0 1
 889: PUSH
 890: DOUBLE
 891: LD_INT 1
 893: DEC
 894: ST_TO_ADDR
 895: LD_VAR 0 3
 899: PUSH
 900: FOR_TO
 901: IFFALSE 941
// if not HasTask ( filter2 [ i ] ) then
 903: LD_VAR 0 3
 907: PUSH
 908: LD_VAR 0 1
 912: ARRAY
 913: PPUSH
 914: CALL_OW 314
 918: NOT
 919: IFFALSE 939
// ComMoveToArea ( filter2 [ i ] , exit_area ) ;
 921: LD_VAR 0 3
 925: PUSH
 926: LD_VAR 0 1
 930: ARRAY
 931: PPUSH
 932: LD_INT 4
 934: PPUSH
 935: CALL_OW 113
 939: GO 900
 941: POP
 942: POP
// end ; end_of_file
 943: PPOPN 4
 945: END
// export function SpawnCar ( chas , area ) ; var i , e , veh , ar_chassis , ru_chassis , us_chassis , ar_weapons , ru_weapons , us_weapons , chassis , engine , weapon ; begin
 946: LD_INT 0
 948: PPUSH
 949: PPUSH
 950: PPUSH
 951: PPUSH
 952: PPUSH
 953: PPUSH
 954: PPUSH
 955: PPUSH
 956: PPUSH
 957: PPUSH
 958: PPUSH
 959: PPUSH
 960: PPUSH
// uc_side := 0 ;
 961: LD_ADDR_OWVAR 20
 965: PUSH
 966: LD_INT 0
 968: ST_TO_ADDR
// uc_nation := Rand ( 1 , 3 ) ;
 969: LD_ADDR_OWVAR 21
 973: PUSH
 974: LD_INT 1
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: CALL_OW 12
 984: ST_TO_ADDR
// ar_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
 985: LD_ADDR_VAR 0 7
 989: PUSH
 990: LD_INT 11
 992: PUSH
 993: LD_INT 12
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 14
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: ST_TO_ADDR
// ru_chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ;
1008: LD_ADDR_VAR 0 8
1012: PUSH
1013: LD_INT 21
1015: PUSH
1016: LD_INT 22
1018: PUSH
1019: LD_INT 23
1021: PUSH
1022: LD_INT 24
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: LIST
1029: LIST
1030: ST_TO_ADDR
// us_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ;
1031: LD_ADDR_VAR 0 9
1035: PUSH
1036: LD_INT 1
1038: PUSH
1039: LD_INT 2
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: LD_INT 4
1047: PUSH
1048: LD_INT 5
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: ST_TO_ADDR
// if chas > 0 then
1058: LD_VAR 0 1
1062: PUSH
1063: LD_INT 0
1065: GREATER
1066: IFFALSE 1080
// vc_chassis := chas else
1068: LD_ADDR_OWVAR 37
1072: PUSH
1073: LD_VAR 0 1
1077: ST_TO_ADDR
1078: GO 1173
// begin case uc_nation of 1 :
1080: LD_OWVAR 21
1084: PUSH
1085: LD_INT 1
1087: DOUBLE
1088: EQUAL
1089: IFTRUE 1093
1091: GO 1106
1093: POP
// chassis := us_chassis ; 2 :
1094: LD_ADDR_VAR 0 13
1098: PUSH
1099: LD_VAR 0 9
1103: ST_TO_ADDR
1104: GO 1149
1106: LD_INT 2
1108: DOUBLE
1109: EQUAL
1110: IFTRUE 1114
1112: GO 1127
1114: POP
// chassis := ar_chassis ; 3 :
1115: LD_ADDR_VAR 0 13
1119: PUSH
1120: LD_VAR 0 7
1124: ST_TO_ADDR
1125: GO 1149
1127: LD_INT 3
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1148
1135: POP
// chassis := ru_chassis ; end ;
1136: LD_ADDR_VAR 0 13
1140: PUSH
1141: LD_VAR 0 8
1145: ST_TO_ADDR
1146: GO 1149
1148: POP
// vc_chassis := chassis [ Rand ( 1 , chassis ) ] ;
1149: LD_ADDR_OWVAR 37
1153: PUSH
1154: LD_VAR 0 13
1158: PUSH
1159: LD_INT 1
1161: PPUSH
1162: LD_VAR 0 13
1166: PPUSH
1167: CALL_OW 12
1171: ARRAY
1172: ST_TO_ADDR
// end ; if vc_chassis in [ ar_hovercraft , ar_light_trike , us_light_wheeled ] then
1173: LD_OWVAR 37
1177: PUSH
1178: LD_INT 11
1180: PUSH
1181: LD_INT 12
1183: PUSH
1184: LD_INT 1
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: LIST
1191: IN
1192: IFFALSE 1212
// engine := Rand ( 1 , 2 ) else
1194: LD_ADDR_VAR 0 14
1198: PUSH
1199: LD_INT 1
1201: PPUSH
1202: LD_INT 2
1204: PPUSH
1205: CALL_OW 12
1209: ST_TO_ADDR
1210: GO 1324
// begin if not vc_chassis in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked , us_morphling ] then
1212: LD_OWVAR 37
1216: PUSH
1217: LD_INT 21
1219: PUSH
1220: LD_INT 22
1222: PUSH
1223: LD_INT 23
1225: PUSH
1226: LD_INT 24
1228: PUSH
1229: LD_INT 4
1231: PUSH
1232: LD_INT 5
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: IN
1243: NOT
1244: IFFALSE 1264
// engine := Rand ( 1 , 3 ) else
1246: LD_ADDR_VAR 0 14
1250: PUSH
1251: LD_INT 1
1253: PPUSH
1254: LD_INT 3
1256: PPUSH
1257: CALL_OW 12
1261: ST_TO_ADDR
1262: GO 1280
// e := Rand ( 1 , 2 ) ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_INT 1
1271: PPUSH
1272: LD_INT 2
1274: PPUSH
1275: CALL_OW 12
1279: ST_TO_ADDR
// case e of 1 :
1280: LD_VAR 0 5
1284: PUSH
1285: LD_INT 1
1287: DOUBLE
1288: EQUAL
1289: IFTRUE 1293
1291: GO 1304
1293: POP
// engine := engine_combustion ; 2 :
1294: LD_ADDR_VAR 0 14
1298: PUSH
1299: LD_INT 1
1301: ST_TO_ADDR
1302: GO 1324
1304: LD_INT 2
1306: DOUBLE
1307: EQUAL
1308: IFTRUE 1312
1310: GO 1323
1312: POP
// engine := engine_siberite ; end ;
1313: LD_ADDR_VAR 0 14
1317: PUSH
1318: LD_INT 3
1320: ST_TO_ADDR
1321: GO 1324
1323: POP
// end ; vc_engine := engine ;
1324: LD_ADDR_OWVAR 39
1328: PUSH
1329: LD_VAR 0 14
1333: ST_TO_ADDR
// vc_control := control_manual ;
1334: LD_ADDR_OWVAR 38
1338: PUSH
1339: LD_INT 1
1341: ST_TO_ADDR
// ar_weapons := [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ar_radar , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb , ar_flame_thrower ] ;
1342: LD_ADDR_VAR 0 10
1346: PUSH
1347: LD_INT 22
1349: PUSH
1350: LD_INT 24
1352: PUSH
1353: LD_INT 23
1355: PUSH
1356: LD_INT 30
1358: PUSH
1359: LD_INT 25
1361: PUSH
1362: LD_INT 27
1364: PUSH
1365: LD_INT 28
1367: PUSH
1368: LD_INT 29
1370: PUSH
1371: LD_INT 26
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// ru_weapons := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , 98 , ru_rocket_launcher , ru_heavy_gun , ru_rocket , ru_bulldozer , ru_time_lapser ] ;
1385: LD_ADDR_VAR 0 11
1389: PUSH
1390: LD_INT 42
1392: PUSH
1393: LD_INT 43
1395: PUSH
1396: LD_INT 44
1398: PUSH
1399: LD_INT 98
1401: PUSH
1402: LD_INT 45
1404: PUSH
1405: LD_INT 46
1407: PUSH
1408: LD_INT 47
1410: PUSH
1411: LD_INT 53
1413: PUSH
1414: LD_INT 49
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: ST_TO_ADDR
// us_weapons := [ us_machine_gun , us_light_gun , us_radar , us_gatling_gun , us_double_gun , us_rocket_launcher , us_laser , us_heavy_gun , us_bulldozer , us_double_laser ] ;
1428: LD_ADDR_VAR 0 12
1432: PUSH
1433: LD_INT 2
1435: PUSH
1436: LD_INT 3
1438: PUSH
1439: LD_INT 11
1441: PUSH
1442: LD_INT 4
1444: PUSH
1445: LD_INT 5
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: LD_INT 9
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: LD_INT 14
1459: PUSH
1460: LD_INT 10
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: ST_TO_ADDR
// if uc_nation = nation_arabian then
1475: LD_OWVAR 21
1479: PUSH
1480: LD_INT 2
1482: EQUAL
1483: IFFALSE 1550
// begin if vc_chassis in [ ar_hovercraft , ar_light_trike ] then
1485: LD_OWVAR 37
1489: PUSH
1490: LD_INT 11
1492: PUSH
1493: LD_INT 12
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: IN
1500: IFFALSE 1526
// weapon := ar_weapons [ Rand ( 1 , 3 ) ] else
1502: LD_ADDR_VAR 0 15
1506: PUSH
1507: LD_VAR 0 10
1511: PUSH
1512: LD_INT 1
1514: PPUSH
1515: LD_INT 3
1517: PPUSH
1518: CALL_OW 12
1522: ARRAY
1523: ST_TO_ADDR
1524: GO 1550
// weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
1526: LD_ADDR_VAR 0 15
1530: PUSH
1531: LD_VAR 0 10
1535: PUSH
1536: LD_INT 1
1538: PPUSH
1539: LD_VAR 0 10
1543: PPUSH
1544: CALL_OW 12
1548: ARRAY
1549: ST_TO_ADDR
// end ; if uc_nation = nation_russian then
1550: LD_OWVAR 21
1554: PUSH
1555: LD_INT 3
1557: EQUAL
1558: IFFALSE 1625
// begin if vc_chassis in [ ru_medium_wheeled , ru_medium_tracked ] then
1560: LD_OWVAR 37
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: IN
1575: IFFALSE 1601
// weapon := ru_weapons [ Rand ( 1 , 5 ) ] else
1577: LD_ADDR_VAR 0 15
1581: PUSH
1582: LD_VAR 0 11
1586: PUSH
1587: LD_INT 1
1589: PPUSH
1590: LD_INT 5
1592: PPUSH
1593: CALL_OW 12
1597: ARRAY
1598: ST_TO_ADDR
1599: GO 1625
// weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
1601: LD_ADDR_VAR 0 15
1605: PUSH
1606: LD_VAR 0 11
1610: PUSH
1611: LD_INT 1
1613: PPUSH
1614: LD_VAR 0 11
1618: PPUSH
1619: CALL_OW 12
1623: ARRAY
1624: ST_TO_ADDR
// end ; if uc_nation = nation_american then
1625: LD_OWVAR 21
1629: PUSH
1630: LD_INT 1
1632: EQUAL
1633: IFFALSE 1742
// begin if vc_chassis = us_light_wheeled then
1635: LD_OWVAR 37
1639: PUSH
1640: LD_INT 1
1642: EQUAL
1643: IFFALSE 1667
// weapon := us_weapons [ Rand ( 1 , 3 ) ] ;
1645: LD_ADDR_VAR 0 15
1649: PUSH
1650: LD_VAR 0 12
1654: PUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 3
1660: PPUSH
1661: CALL_OW 12
1665: ARRAY
1666: ST_TO_ADDR
// if vc_chassis in [ us_medium_tracked , us_medium_wheeled ] then
1667: LD_OWVAR 37
1671: PUSH
1672: LD_INT 3
1674: PUSH
1675: LD_INT 2
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: IN
1682: IFFALSE 1708
// weapon := us_weapons [ Rand ( 1 , 7 ) ] else
1684: LD_ADDR_VAR 0 15
1688: PUSH
1689: LD_VAR 0 12
1693: PUSH
1694: LD_INT 1
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL_OW 12
1704: ARRAY
1705: ST_TO_ADDR
1706: GO 1742
// if vc_chassis <> us_light_wheeled then
1708: LD_OWVAR 37
1712: PUSH
1713: LD_INT 1
1715: NONEQUAL
1716: IFFALSE 1742
// weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
1718: LD_ADDR_VAR 0 15
1722: PUSH
1723: LD_VAR 0 12
1727: PUSH
1728: LD_INT 1
1730: PPUSH
1731: LD_VAR 0 12
1735: PPUSH
1736: CALL_OW 12
1740: ARRAY
1741: ST_TO_ADDR
// end ; vc_weapon := weapon ;
1742: LD_ADDR_OWVAR 40
1746: PUSH
1747: LD_VAR 0 15
1751: ST_TO_ADDR
// veh := CreateVehicle ;
1752: LD_ADDR_VAR 0 6
1756: PUSH
1757: CALL_OW 45
1761: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1762: LD_VAR 0 6
1766: PPUSH
1767: LD_VAR 0 2
1771: PPUSH
1772: LD_INT 1
1774: PPUSH
1775: CALL_OW 49
// end ;
1779: LD_VAR 0 3
1783: RET
// export function SpawnSibRocket ( area ) ; var veh , p ; begin
1784: LD_INT 0
1786: PPUSH
1787: PPUSH
1788: PPUSH
// uc_side := 0 ;
1789: LD_ADDR_OWVAR 20
1793: PUSH
1794: LD_INT 0
1796: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
1797: LD_ADDR_VAR 0 4
1801: PUSH
1802: LD_INT 1
1804: PPUSH
1805: LD_INT 2
1807: PPUSH
1808: CALL_OW 12
1812: ST_TO_ADDR
// case p of 1 :
1813: LD_VAR 0 4
1817: PUSH
1818: LD_INT 1
1820: DOUBLE
1821: EQUAL
1822: IFTRUE 1826
1824: GO 1869
1826: POP
// begin uc_nation := nation_american ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
1835: LD_ADDR_OWVAR 37
1839: PUSH
1840: LD_INT 4
1842: ST_TO_ADDR
// vc_engine := engine_siberite ;
1843: LD_ADDR_OWVAR 39
1847: PUSH
1848: LD_INT 3
1850: ST_TO_ADDR
// vc_control := control_manual ;
1851: LD_ADDR_OWVAR 38
1855: PUSH
1856: LD_INT 1
1858: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
1859: LD_ADDR_OWVAR 40
1863: PUSH
1864: LD_INT 8
1866: ST_TO_ADDR
// end ; 2 :
1867: GO 1921
1869: LD_INT 2
1871: DOUBLE
1872: EQUAL
1873: IFTRUE 1877
1875: GO 1920
1877: POP
// begin uc_nation := nation_russian ;
1878: LD_ADDR_OWVAR 21
1882: PUSH
1883: LD_INT 3
1885: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
1886: LD_ADDR_OWVAR 37
1890: PUSH
1891: LD_INT 24
1893: ST_TO_ADDR
// vc_engine := engine_siberite ;
1894: LD_ADDR_OWVAR 39
1898: PUSH
1899: LD_INT 3
1901: ST_TO_ADDR
// vc_control := control_manual ;
1902: LD_ADDR_OWVAR 38
1906: PUSH
1907: LD_INT 1
1909: ST_TO_ADDR
// vc_weapon := ru_siberium_rocket ;
1910: LD_ADDR_OWVAR 40
1914: PUSH
1915: LD_INT 48
1917: ST_TO_ADDR
// end ; end ;
1918: GO 1921
1920: POP
// veh := CreateVehicle ;
1921: LD_ADDR_VAR 0 3
1925: PUSH
1926: CALL_OW 45
1930: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1931: LD_VAR 0 3
1935: PPUSH
1936: LD_VAR 0 1
1940: PPUSH
1941: LD_INT 1
1943: PPUSH
1944: CALL_OW 49
// end ;
1948: LD_VAR 0 2
1952: RET
// export function ScoreBoard ( veh ) ; var points ; begin
1953: LD_INT 0
1955: PPUSH
1956: PPUSH
// points := 0 ;
1957: LD_ADDR_VAR 0 3
1961: PUSH
1962: LD_INT 0
1964: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_light_trike , us_light_wheeled ] then
1965: LD_VAR 0 1
1969: PPUSH
1970: CALL_OW 265
1974: PUSH
1975: LD_INT 12
1977: PUSH
1978: LD_INT 1
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: IN
1985: IFFALSE 2001
// points := points + 10 ;
1987: LD_ADDR_VAR 0 3
1991: PUSH
1992: LD_VAR 0 3
1996: PUSH
1997: LD_INT 10
1999: PLUS
2000: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_medium_trike , ru_medium_wheeled , us_medium_wheeled ] then
2001: LD_VAR 0 1
2005: PPUSH
2006: CALL_OW 265
2010: PUSH
2011: LD_INT 13
2013: PUSH
2014: LD_INT 21
2016: PUSH
2017: LD_INT 2
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: IN
2025: IFFALSE 2041
// points := points + 15 ;
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: LD_VAR 0 3
2036: PUSH
2037: LD_INT 15
2039: PLUS
2040: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_half_tracked , ru_medium_tracked , us_medium_tracked ] then
2041: LD_VAR 0 1
2045: PPUSH
2046: CALL_OW 265
2050: PUSH
2051: LD_INT 14
2053: PUSH
2054: LD_INT 22
2056: PUSH
2057: LD_INT 3
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: LIST
2064: IN
2065: IFFALSE 2081
// points := points + 20 ;
2067: LD_ADDR_VAR 0 3
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 20
2079: PLUS
2080: ST_TO_ADDR
// if GetChassis ( veh ) in [ ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked ] then
2081: LD_VAR 0 1
2085: PPUSH
2086: CALL_OW 265
2090: PUSH
2091: LD_INT 23
2093: PUSH
2094: LD_INT 24
2096: PUSH
2097: LD_INT 4
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: IN
2105: IFFALSE 2121
// points := points + 25 ;
2107: LD_ADDR_VAR 0 3
2111: PUSH
2112: LD_VAR 0 3
2116: PUSH
2117: LD_INT 25
2119: PLUS
2120: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_hovercraft , us_morphling ] then
2121: LD_VAR 0 1
2125: PPUSH
2126: CALL_OW 265
2130: PUSH
2131: LD_INT 11
2133: PUSH
2134: LD_INT 5
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: IN
2141: IFFALSE 2157
// points := points + 30 ;
2143: LD_ADDR_VAR 0 3
2147: PUSH
2148: LD_VAR 0 3
2152: PUSH
2153: LD_INT 30
2155: PLUS
2156: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_combustion ] then
2157: LD_VAR 0 1
2161: PPUSH
2162: CALL_OW 262
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: EMPTY
2171: LIST
2172: EQUAL
2173: IFFALSE 2189
// points := points + 5 ;
2175: LD_ADDR_VAR 0 3
2179: PUSH
2180: LD_VAR 0 3
2184: PUSH
2185: LD_INT 5
2187: PLUS
2188: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_solar ] then
2189: LD_VAR 0 1
2193: PPUSH
2194: CALL_OW 262
2198: PUSH
2199: LD_INT 2
2201: PUSH
2202: EMPTY
2203: LIST
2204: EQUAL
2205: IFFALSE 2221
// points := points + 15 ;
2207: LD_ADDR_VAR 0 3
2211: PUSH
2212: LD_VAR 0 3
2216: PUSH
2217: LD_INT 15
2219: PLUS
2220: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_siberite ] then
2221: LD_VAR 0 1
2225: PPUSH
2226: CALL_OW 262
2230: PUSH
2231: LD_INT 3
2233: PUSH
2234: EMPTY
2235: LIST
2236: EQUAL
2237: IFFALSE 2253
// points := points + 25 ;
2239: LD_ADDR_VAR 0 3
2243: PUSH
2244: LD_VAR 0 3
2248: PUSH
2249: LD_INT 25
2251: PLUS
2252: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ru_heavy_machine_gun , us_machine_gun , us_light_gun ] then
2253: LD_VAR 0 1
2257: PPUSH
2258: CALL_OW 264
2262: PUSH
2263: LD_INT 22
2265: PUSH
2266: LD_INT 24
2268: PUSH
2269: LD_INT 23
2271: PUSH
2272: LD_INT 42
2274: PUSH
2275: LD_INT 2
2277: PUSH
2278: LD_INT 3
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: LIST
2288: IN
2289: IFFALSE 2305
// points := points + 5 ;
2291: LD_ADDR_VAR 0 3
2295: PUSH
2296: LD_VAR 0 3
2300: PUSH
2301: LD_INT 5
2303: PLUS
2304: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_gatling_gun , ar_gun , ru_gatling_gun , ru_gun , us_gatling_gun , us_double_gun ] then
2305: LD_VAR 0 1
2309: PPUSH
2310: CALL_OW 264
2314: PUSH
2315: LD_INT 25
2317: PUSH
2318: LD_INT 27
2320: PUSH
2321: LD_INT 43
2323: PUSH
2324: LD_INT 44
2326: PUSH
2327: LD_INT 4
2329: PUSH
2330: LD_INT 5
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: LIST
2337: LIST
2338: LIST
2339: LIST
2340: IN
2341: IFFALSE 2357
// points := points + 10 ;
2343: LD_ADDR_VAR 0 3
2347: PUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 10
2355: PLUS
2356: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher ] then
2357: LD_VAR 0 1
2361: PPUSH
2362: CALL_OW 264
2366: PUSH
2367: LD_INT 28
2369: PUSH
2370: LD_INT 45
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: IN
2381: IFFALSE 2397
// points := points + 20 ;
2383: LD_ADDR_VAR 0 3
2387: PUSH
2388: LD_VAR 0 3
2392: PUSH
2393: LD_INT 20
2395: PLUS
2396: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_heavy_gun , us_heavy_gun ] then
2397: LD_VAR 0 1
2401: PPUSH
2402: CALL_OW 264
2406: PUSH
2407: LD_INT 46
2409: PUSH
2410: LD_INT 6
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: IN
2417: IFFALSE 2433
// points := points + 25 ;
2419: LD_ADDR_VAR 0 3
2423: PUSH
2424: LD_VAR 0 3
2428: PUSH
2429: LD_INT 25
2431: PLUS
2432: ST_TO_ADDR
// if GetWeapon ( veh ) in [ us_laser , us_radar , ar_radar ] then
2433: LD_VAR 0 1
2437: PPUSH
2438: CALL_OW 264
2442: PUSH
2443: LD_INT 9
2445: PUSH
2446: LD_INT 11
2448: PUSH
2449: LD_INT 30
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: IN
2457: IFFALSE 2473
// points := points + 30 ;
2459: LD_ADDR_VAR 0 3
2463: PUSH
2464: LD_VAR 0 3
2468: PUSH
2469: LD_INT 30
2471: PLUS
2472: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_selfpropelled_bomb , ru_time_lapser , ru_rocket , us_double_laser ] then
2473: LD_VAR 0 1
2477: PPUSH
2478: CALL_OW 264
2482: PUSH
2483: LD_INT 29
2485: PUSH
2486: LD_INT 49
2488: PUSH
2489: LD_INT 47
2491: PUSH
2492: LD_INT 10
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: LIST
2499: LIST
2500: IN
2501: IFFALSE 2517
// points := points + 50 ;
2503: LD_ADDR_VAR 0 3
2507: PUSH
2508: LD_VAR 0 3
2512: PUSH
2513: LD_INT 50
2515: PLUS
2516: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_siberium_rocket , us_siberium_rocket ] then
2517: LD_VAR 0 1
2521: PPUSH
2522: CALL_OW 264
2526: PUSH
2527: LD_INT 48
2529: PUSH
2530: LD_INT 8
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: IN
2537: IFFALSE 2553
// points := points + 100 ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_VAR 0 3
2548: PUSH
2549: LD_INT 100
2551: PLUS
2552: ST_TO_ADDR
// result := points ;
2553: LD_ADDR_VAR 0 2
2557: PUSH
2558: LD_VAR 0 3
2562: ST_TO_ADDR
// end ; end_of_file
2563: LD_VAR 0 2
2567: RET
// every 0 0$01 trigger time do var filter , i , side , driver , un ;
2568: LD_EXP 5
2572: IFFALSE 3217
2574: GO 2576
2576: DISABLE
2577: LD_INT 0
2579: PPUSH
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
// begin enable ;
2584: ENABLE
// if tick < 36 then
2585: LD_OWVAR 1
2589: PUSH
2590: LD_INT 36
2592: LESS
2593: IFFALSE 2605
// SetAreaMapShow ( exit_area , 1 ) ;
2595: LD_INT 4
2597: PPUSH
2598: LD_INT 1
2600: PPUSH
2601: CALL_OW 424
// time := time - 0 0$01 ;
2605: LD_ADDR_EXP 5
2609: PUSH
2610: LD_EXP 5
2614: PUSH
2615: LD_INT 35
2617: MINUS
2618: ST_TO_ADDR
// if time = 0 0$00 then
2619: LD_EXP 5
2623: PUSH
2624: LD_INT 0
2626: EQUAL
2627: IFFALSE 2690
// if p1 > p2 and p1 > p3 and p1 > p4 and p1 > p5 then
2629: LD_EXP 7
2633: PUSH
2634: LD_EXP 8
2638: GREATER
2639: PUSH
2640: LD_EXP 7
2644: PUSH
2645: LD_EXP 9
2649: GREATER
2650: AND
2651: PUSH
2652: LD_EXP 7
2656: PUSH
2657: LD_EXP 10
2661: GREATER
2662: AND
2663: PUSH
2664: LD_EXP 7
2668: PUSH
2669: LD_EXP 11
2673: GREATER
2674: AND
2675: IFFALSE 2683
// YouWin else
2677: CALL_OW 103
2681: GO 2690
// YouLost (  ) ;
2683: LD_STRING 
2685: PPUSH
2686: CALL_OW 104
// filter := FilterUnitsInArea ( exit_area , [ f_type , unit_vehicle ] ) ;
2690: LD_ADDR_VAR 0 1
2694: PUSH
2695: LD_INT 4
2697: PPUSH
2698: LD_INT 21
2700: PUSH
2701: LD_INT 2
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 70
2712: ST_TO_ADDR
// if filter then
2713: LD_VAR 0 1
2717: IFFALSE 3007
// for i = 1 to filter do
2719: LD_ADDR_VAR 0 2
2723: PUSH
2724: DOUBLE
2725: LD_INT 1
2727: DEC
2728: ST_TO_ADDR
2729: LD_VAR 0 1
2733: PUSH
2734: FOR_TO
2735: IFFALSE 3005
// begin side := GetSide ( filter [ i ] ) ;
2737: LD_ADDR_VAR 0 3
2741: PUSH
2742: LD_VAR 0 1
2746: PUSH
2747: LD_VAR 0 2
2751: ARRAY
2752: PPUSH
2753: CALL_OW 255
2757: ST_TO_ADDR
// driver := IsDrivenBy ( filter [ i ] ) ;
2758: LD_ADDR_VAR 0 4
2762: PUSH
2763: LD_VAR 0 1
2767: PUSH
2768: LD_VAR 0 2
2772: ARRAY
2773: PPUSH
2774: CALL_OW 311
2778: ST_TO_ADDR
// un := filter [ i ] ;
2779: LD_ADDR_VAR 0 5
2783: PUSH
2784: LD_VAR 0 1
2788: PUSH
2789: LD_VAR 0 2
2793: ARRAY
2794: ST_TO_ADDR
// if IsInUnit ( driver ) then
2795: LD_VAR 0 4
2799: PPUSH
2800: CALL_OW 310
2804: IFFALSE 2815
// ComExitVehicle ( driver ) ;
2806: LD_VAR 0 4
2810: PPUSH
2811: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
2815: LD_INT 10
2817: PPUSH
2818: CALL_OW 67
// RemoveUnit ( filter [ i ] ) ;
2822: LD_VAR 0 1
2826: PUSH
2827: LD_VAR 0 2
2831: ARRAY
2832: PPUSH
2833: CALL_OW 64
// case side of 1 :
2837: LD_VAR 0 3
2841: PUSH
2842: LD_INT 1
2844: DOUBLE
2845: EQUAL
2846: IFTRUE 2850
2848: GO 2874
2850: POP
// p1 := p1 + ScoreBoard ( un ) ; 2 :
2851: LD_ADDR_EXP 7
2855: PUSH
2856: LD_EXP 7
2860: PUSH
2861: LD_VAR 0 5
2865: PPUSH
2866: CALL 1953 0 1
2870: PLUS
2871: ST_TO_ADDR
2872: GO 3003
2874: LD_INT 2
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2906
2882: POP
// p2 := p2 + ScoreBoard ( un ) ; 3 :
2883: LD_ADDR_EXP 8
2887: PUSH
2888: LD_EXP 8
2892: PUSH
2893: LD_VAR 0 5
2897: PPUSH
2898: CALL 1953 0 1
2902: PLUS
2903: ST_TO_ADDR
2904: GO 3003
2906: LD_INT 3
2908: DOUBLE
2909: EQUAL
2910: IFTRUE 2914
2912: GO 2938
2914: POP
// p3 := p3 + ScoreBoard ( un ) ; 4 :
2915: LD_ADDR_EXP 9
2919: PUSH
2920: LD_EXP 9
2924: PUSH
2925: LD_VAR 0 5
2929: PPUSH
2930: CALL 1953 0 1
2934: PLUS
2935: ST_TO_ADDR
2936: GO 3003
2938: LD_INT 4
2940: DOUBLE
2941: EQUAL
2942: IFTRUE 2946
2944: GO 2970
2946: POP
// p4 := p4 + ScoreBoard ( un ) ; 5 :
2947: LD_ADDR_EXP 10
2951: PUSH
2952: LD_EXP 10
2956: PUSH
2957: LD_VAR 0 5
2961: PPUSH
2962: CALL 1953 0 1
2966: PLUS
2967: ST_TO_ADDR
2968: GO 3003
2970: LD_INT 5
2972: DOUBLE
2973: EQUAL
2974: IFTRUE 2978
2976: GO 3002
2978: POP
// p5 := p5 + ScoreBoard ( un ) ; end ;
2979: LD_ADDR_EXP 11
2983: PUSH
2984: LD_EXP 11
2988: PUSH
2989: LD_VAR 0 5
2993: PPUSH
2994: CALL 1953 0 1
2998: PLUS
2999: ST_TO_ADDR
3000: GO 3003
3002: POP
// end ;
3003: GO 2734
3005: POP
3006: POP
// case players of 3 :
3007: LD_EXP 3
3011: PUSH
3012: LD_INT 3
3014: DOUBLE
3015: EQUAL
3016: IFTRUE 3020
3018: GO 3070
3020: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 ] ;
3021: LD_ADDR_OWVAR 47
3025: PUSH
3026: LD_STRING #tick
3028: PUSH
3029: LD_EXP 5
3033: PUSH
3034: LD_STRING #player1
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_STRING #player2
3044: PUSH
3045: LD_EXP 8
3049: PUSH
3050: LD_STRING #player3
3052: PUSH
3053: LD_EXP 9
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: ST_TO_ADDR
// end ; 4 :
3068: GO 3217
3070: LD_INT 4
3072: DOUBLE
3073: EQUAL
3074: IFTRUE 3078
3076: GO 3138
3078: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 ] ;
3079: LD_ADDR_OWVAR 47
3083: PUSH
3084: LD_STRING #tick
3086: PUSH
3087: LD_EXP 5
3091: PUSH
3092: LD_STRING #player1
3094: PUSH
3095: LD_EXP 7
3099: PUSH
3100: LD_STRING #player2
3102: PUSH
3103: LD_EXP 8
3107: PUSH
3108: LD_STRING #player3
3110: PUSH
3111: LD_EXP 9
3115: PUSH
3116: LD_STRING #player4
3118: PUSH
3119: LD_EXP 10
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: ST_TO_ADDR
// end ; 5 :
3136: GO 3217
3138: LD_INT 5
3140: DOUBLE
3141: EQUAL
3142: IFTRUE 3146
3144: GO 3216
3146: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 , #player5 , p5 ] ;
3147: LD_ADDR_OWVAR 47
3151: PUSH
3152: LD_STRING #tick
3154: PUSH
3155: LD_EXP 5
3159: PUSH
3160: LD_STRING #player1
3162: PUSH
3163: LD_EXP 7
3167: PUSH
3168: LD_STRING #player2
3170: PUSH
3171: LD_EXP 8
3175: PUSH
3176: LD_STRING #player3
3178: PUSH
3179: LD_EXP 9
3183: PUSH
3184: LD_STRING #player4
3186: PUSH
3187: LD_EXP 10
3191: PUSH
3192: LD_STRING #player5
3194: PUSH
3195: LD_EXP 11
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: ST_TO_ADDR
// end ; end ;
3214: GO 3217
3216: POP
// end ;
3217: PPOPN 5
3219: END
// every 0 0$05 trigger time do var chance , p ;
3220: LD_EXP 5
3224: IFFALSE 3371
3226: GO 3228
3228: DISABLE
3229: LD_INT 0
3231: PPUSH
3232: PPUSH
// begin enable ;
3233: ENABLE
// Wait ( Rand ( 0 0$01 , 0 0$06 ) ) ;
3234: LD_INT 35
3236: PPUSH
3237: LD_INT 210
3239: PPUSH
3240: CALL_OW 12
3244: PPUSH
3245: CALL_OW 67
// if FilterAllUnits ( [ f_type , unit_vehicle ] ) < veh_amount then
3249: LD_INT 21
3251: PUSH
3252: LD_INT 2
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PPUSH
3259: CALL_OW 69
3263: PUSH
3264: LD_EXP 6
3268: LESS
3269: IFFALSE 3371
// begin SpawnCar ( false , veh_spawn ) ;
3271: LD_INT 0
3273: PPUSH
3274: LD_INT 5
3276: PPUSH
3277: CALL 946 0 2
// if sib_bomb and FilterAllUnits ( [ f_or , [ [ f_weapon , us_siberium_rocket ] , [ f_weapon , ru_siberium_rocket ] ] ] ) = 0 then
3281: LD_EXP 4
3285: PUSH
3286: LD_INT 2
3288: PUSH
3289: LD_INT 34
3291: PUSH
3292: LD_INT 8
3294: PUSH
3295: EMPTY
3296: LIST
3297: LIST
3298: PUSH
3299: LD_INT 34
3301: PUSH
3302: LD_INT 48
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PPUSH
3317: CALL_OW 69
3321: PUSH
3322: LD_INT 0
3324: EQUAL
3325: AND
3326: IFFALSE 3371
// begin chance := 23 ;
3328: LD_ADDR_VAR 0 1
3332: PUSH
3333: LD_INT 23
3335: ST_TO_ADDR
// p := Rand ( 0 , 100 ) ;
3336: LD_ADDR_VAR 0 2
3340: PUSH
3341: LD_INT 0
3343: PPUSH
3344: LD_INT 100
3346: PPUSH
3347: CALL_OW 12
3351: ST_TO_ADDR
// if p < chance then
3352: LD_VAR 0 2
3356: PUSH
3357: LD_VAR 0 1
3361: LESS
3362: IFFALSE 3371
// SpawnSibRocket ( veh_spawn ) ;
3364: LD_INT 5
3366: PPUSH
3367: CALL 1784 0 1
// end ; end ; end ; end_of_file
3371: PPOPN 2
3373: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
3374: LD_INT 0
3376: PPUSH
3377: PPUSH
3378: PPUSH
3379: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
3380: LD_VAR 0 1
3384: PPUSH
3385: CALL_OW 264
3389: PUSH
3390: LD_EXP 70
3394: EQUAL
3395: IFFALSE 3467
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
3397: LD_INT 68
3399: PPUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 255
3409: PPUSH
3410: CALL_OW 321
3414: PUSH
3415: LD_INT 2
3417: EQUAL
3418: IFFALSE 3430
// eff := 70 else
3420: LD_ADDR_VAR 0 6
3424: PUSH
3425: LD_INT 70
3427: ST_TO_ADDR
3428: GO 3438
// eff := 30 ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_INT 30
3437: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
3438: LD_VAR 0 1
3442: PPUSH
3443: CALL_OW 250
3447: PPUSH
3448: LD_VAR 0 1
3452: PPUSH
3453: CALL_OW 251
3457: PPUSH
3458: LD_VAR 0 6
3462: PPUSH
3463: CALL_OW 495
// end ; end ;
3467: LD_VAR 0 4
3471: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
3472: LD_INT 0
3474: PPUSH
3475: PPUSH
3476: PPUSH
3477: PPUSH
3478: PPUSH
3479: PPUSH
// if cmd = 124 then
3480: LD_VAR 0 1
3484: PUSH
3485: LD_INT 124
3487: EQUAL
3488: IFFALSE 3694
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
3490: LD_ADDR_VAR 0 5
3494: PUSH
3495: LD_INT 2
3497: PUSH
3498: LD_INT 34
3500: PUSH
3501: LD_INT 53
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: PUSH
3508: LD_INT 34
3510: PUSH
3511: LD_INT 14
3513: PUSH
3514: EMPTY
3515: LIST
3516: LIST
3517: PUSH
3518: EMPTY
3519: LIST
3520: LIST
3521: LIST
3522: PPUSH
3523: CALL_OW 69
3527: ST_TO_ADDR
// if not tmp then
3528: LD_VAR 0 5
3532: NOT
3533: IFFALSE 3537
// exit ;
3535: GO 3694
// for i in tmp do
3537: LD_ADDR_VAR 0 3
3541: PUSH
3542: LD_VAR 0 5
3546: PUSH
3547: FOR_IN
3548: IFFALSE 3692
// begin taskList := GetTaskList ( i ) ;
3550: LD_ADDR_VAR 0 6
3554: PUSH
3555: LD_VAR 0 3
3559: PPUSH
3560: CALL_OW 437
3564: ST_TO_ADDR
// if not taskList then
3565: LD_VAR 0 6
3569: NOT
3570: IFFALSE 3574
// continue ;
3572: GO 3547
// for j = 1 to taskList do
3574: LD_ADDR_VAR 0 4
3578: PUSH
3579: DOUBLE
3580: LD_INT 1
3582: DEC
3583: ST_TO_ADDR
3584: LD_VAR 0 6
3588: PUSH
3589: FOR_TO
3590: IFFALSE 3688
// if taskList [ j ] [ 1 ] = | then
3592: LD_VAR 0 6
3596: PUSH
3597: LD_VAR 0 4
3601: ARRAY
3602: PUSH
3603: LD_INT 1
3605: ARRAY
3606: PUSH
3607: LD_STRING |
3609: EQUAL
3610: IFFALSE 3686
// begin _taskList := Delete ( taskList , 1 ) ;
3612: LD_ADDR_VAR 0 7
3616: PUSH
3617: LD_VAR 0 6
3621: PPUSH
3622: LD_INT 1
3624: PPUSH
3625: CALL_OW 3
3629: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_VAR 0 7
3639: PPUSH
3640: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_VAR 0 6
3653: PUSH
3654: LD_VAR 0 4
3658: ARRAY
3659: PUSH
3660: LD_INT 2
3662: ARRAY
3663: PPUSH
3664: LD_VAR 0 6
3668: PUSH
3669: LD_VAR 0 4
3673: ARRAY
3674: PUSH
3675: LD_INT 3
3677: ARRAY
3678: PPUSH
3679: LD_INT 8
3681: PPUSH
3682: CALL 3699 0 4
// end ;
3686: GO 3589
3688: POP
3689: POP
// end ;
3690: GO 3547
3692: POP
3693: POP
// end ; end ;
3694: LD_VAR 0 2
3698: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
3699: LD_INT 0
3701: PPUSH
3702: PPUSH
3703: PPUSH
3704: PPUSH
3705: PPUSH
3706: PPUSH
3707: PPUSH
3708: PPUSH
3709: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
3710: LD_VAR 0 1
3714: NOT
3715: PUSH
3716: LD_VAR 0 2
3720: PPUSH
3721: LD_VAR 0 3
3725: PPUSH
3726: CALL_OW 488
3730: NOT
3731: OR
3732: PUSH
3733: LD_VAR 0 4
3737: NOT
3738: OR
3739: IFFALSE 3743
// exit ;
3741: GO 4083
// list := [ ] ;
3743: LD_ADDR_VAR 0 13
3747: PUSH
3748: EMPTY
3749: ST_TO_ADDR
// if x - r < 0 then
3750: LD_VAR 0 2
3754: PUSH
3755: LD_VAR 0 4
3759: MINUS
3760: PUSH
3761: LD_INT 0
3763: LESS
3764: IFFALSE 3776
// min_x := 0 else
3766: LD_ADDR_VAR 0 7
3770: PUSH
3771: LD_INT 0
3773: ST_TO_ADDR
3774: GO 3792
// min_x := x - r ;
3776: LD_ADDR_VAR 0 7
3780: PUSH
3781: LD_VAR 0 2
3785: PUSH
3786: LD_VAR 0 4
3790: MINUS
3791: ST_TO_ADDR
// if y - r < 0 then
3792: LD_VAR 0 3
3796: PUSH
3797: LD_VAR 0 4
3801: MINUS
3802: PUSH
3803: LD_INT 0
3805: LESS
3806: IFFALSE 3818
// min_y := 0 else
3808: LD_ADDR_VAR 0 8
3812: PUSH
3813: LD_INT 0
3815: ST_TO_ADDR
3816: GO 3834
// min_y := y - r ;
3818: LD_ADDR_VAR 0 8
3822: PUSH
3823: LD_VAR 0 3
3827: PUSH
3828: LD_VAR 0 4
3832: MINUS
3833: ST_TO_ADDR
// max_x := x + r ;
3834: LD_ADDR_VAR 0 9
3838: PUSH
3839: LD_VAR 0 2
3843: PUSH
3844: LD_VAR 0 4
3848: PLUS
3849: ST_TO_ADDR
// max_y := y + r ;
3850: LD_ADDR_VAR 0 10
3854: PUSH
3855: LD_VAR 0 3
3859: PUSH
3860: LD_VAR 0 4
3864: PLUS
3865: ST_TO_ADDR
// for _x = min_x to max_x do
3866: LD_ADDR_VAR 0 11
3870: PUSH
3871: DOUBLE
3872: LD_VAR 0 7
3876: DEC
3877: ST_TO_ADDR
3878: LD_VAR 0 9
3882: PUSH
3883: FOR_TO
3884: IFFALSE 4001
// for _y = min_y to max_y do
3886: LD_ADDR_VAR 0 12
3890: PUSH
3891: DOUBLE
3892: LD_VAR 0 8
3896: DEC
3897: ST_TO_ADDR
3898: LD_VAR 0 10
3902: PUSH
3903: FOR_TO
3904: IFFALSE 3997
// begin if not ValidHex ( _x , _y ) then
3906: LD_VAR 0 11
3910: PPUSH
3911: LD_VAR 0 12
3915: PPUSH
3916: CALL_OW 488
3920: NOT
3921: IFFALSE 3925
// continue ;
3923: GO 3903
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
3925: LD_VAR 0 11
3929: PPUSH
3930: LD_VAR 0 12
3934: PPUSH
3935: CALL_OW 351
3939: PUSH
3940: LD_VAR 0 11
3944: PPUSH
3945: LD_VAR 0 12
3949: PPUSH
3950: CALL_OW 554
3954: AND
3955: IFFALSE 3995
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
3957: LD_ADDR_VAR 0 13
3961: PUSH
3962: LD_VAR 0 13
3966: PPUSH
3967: LD_VAR 0 13
3971: PUSH
3972: LD_INT 1
3974: PLUS
3975: PPUSH
3976: LD_VAR 0 11
3980: PUSH
3981: LD_VAR 0 12
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PPUSH
3990: CALL_OW 2
3994: ST_TO_ADDR
// end ;
3995: GO 3903
3997: POP
3998: POP
3999: GO 3883
4001: POP
4002: POP
// if not list then
4003: LD_VAR 0 13
4007: NOT
4008: IFFALSE 4012
// exit ;
4010: GO 4083
// for i in list do
4012: LD_ADDR_VAR 0 6
4016: PUSH
4017: LD_VAR 0 13
4021: PUSH
4022: FOR_IN
4023: IFFALSE 4081
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
4025: LD_VAR 0 1
4029: PPUSH
4030: LD_STRING M
4032: PUSH
4033: LD_VAR 0 6
4037: PUSH
4038: LD_INT 1
4040: ARRAY
4041: PUSH
4042: LD_VAR 0 6
4046: PUSH
4047: LD_INT 2
4049: ARRAY
4050: PUSH
4051: LD_INT 0
4053: PUSH
4054: LD_INT 0
4056: PUSH
4057: LD_INT 0
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: LIST
4067: LIST
4068: LIST
4069: LIST
4070: LIST
4071: PUSH
4072: EMPTY
4073: LIST
4074: PPUSH
4075: CALL_OW 447
4079: GO 4022
4081: POP
4082: POP
// end ; end_of_file
4083: LD_VAR 0 5
4087: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
4088: GO 4090
4090: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
4091: LD_STRING initStreamRollete();
4093: PPUSH
4094: CALL_OW 559
// InitStreamMode ;
4098: CALL 4107 0 0
// DefineStreamItems ( ) ;
4102: CALL 4547 0 0
// end ;
4106: END
// function InitStreamMode ; begin
4107: LD_INT 0
4109: PPUSH
// streamModeActive := false ;
4110: LD_ADDR_EXP 12
4114: PUSH
4115: LD_INT 0
4117: ST_TO_ADDR
// normalCounter := 26 ;
4118: LD_ADDR_EXP 13
4122: PUSH
4123: LD_INT 26
4125: ST_TO_ADDR
// hardcoreCounter := 12 ;
4126: LD_ADDR_EXP 14
4130: PUSH
4131: LD_INT 12
4133: ST_TO_ADDR
// sRocket := false ;
4134: LD_ADDR_EXP 17
4138: PUSH
4139: LD_INT 0
4141: ST_TO_ADDR
// sSpeed := false ;
4142: LD_ADDR_EXP 16
4146: PUSH
4147: LD_INT 0
4149: ST_TO_ADDR
// sEngine := false ;
4150: LD_ADDR_EXP 18
4154: PUSH
4155: LD_INT 0
4157: ST_TO_ADDR
// sSpec := false ;
4158: LD_ADDR_EXP 15
4162: PUSH
4163: LD_INT 0
4165: ST_TO_ADDR
// sLevel := false ;
4166: LD_ADDR_EXP 19
4170: PUSH
4171: LD_INT 0
4173: ST_TO_ADDR
// sArmoury := false ;
4174: LD_ADDR_EXP 20
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// sRadar := false ;
4182: LD_ADDR_EXP 21
4186: PUSH
4187: LD_INT 0
4189: ST_TO_ADDR
// sBunker := false ;
4190: LD_ADDR_EXP 22
4194: PUSH
4195: LD_INT 0
4197: ST_TO_ADDR
// sHack := false ;
4198: LD_ADDR_EXP 23
4202: PUSH
4203: LD_INT 0
4205: ST_TO_ADDR
// sFire := false ;
4206: LD_ADDR_EXP 24
4210: PUSH
4211: LD_INT 0
4213: ST_TO_ADDR
// sRefresh := false ;
4214: LD_ADDR_EXP 25
4218: PUSH
4219: LD_INT 0
4221: ST_TO_ADDR
// sExp := false ;
4222: LD_ADDR_EXP 26
4226: PUSH
4227: LD_INT 0
4229: ST_TO_ADDR
// sDepot := false ;
4230: LD_ADDR_EXP 27
4234: PUSH
4235: LD_INT 0
4237: ST_TO_ADDR
// sFlag := false ;
4238: LD_ADDR_EXP 28
4242: PUSH
4243: LD_INT 0
4245: ST_TO_ADDR
// sKamikadze := false ;
4246: LD_ADDR_EXP 36
4250: PUSH
4251: LD_INT 0
4253: ST_TO_ADDR
// sTroll := false ;
4254: LD_ADDR_EXP 37
4258: PUSH
4259: LD_INT 0
4261: ST_TO_ADDR
// sSlow := false ;
4262: LD_ADDR_EXP 38
4266: PUSH
4267: LD_INT 0
4269: ST_TO_ADDR
// sLack := false ;
4270: LD_ADDR_EXP 39
4274: PUSH
4275: LD_INT 0
4277: ST_TO_ADDR
// sTank := false ;
4278: LD_ADDR_EXP 41
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// sRemote := false ;
4286: LD_ADDR_EXP 42
4290: PUSH
4291: LD_INT 0
4293: ST_TO_ADDR
// sPowell := false ;
4294: LD_ADDR_EXP 43
4298: PUSH
4299: LD_INT 0
4301: ST_TO_ADDR
// sTeleport := false ;
4302: LD_ADDR_EXP 46
4306: PUSH
4307: LD_INT 0
4309: ST_TO_ADDR
// sOilTower := false ;
4310: LD_ADDR_EXP 48
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// sShovel := false ;
4318: LD_ADDR_EXP 49
4322: PUSH
4323: LD_INT 0
4325: ST_TO_ADDR
// sSheik := false ;
4326: LD_ADDR_EXP 50
4330: PUSH
4331: LD_INT 0
4333: ST_TO_ADDR
// sEarthquake := false ;
4334: LD_ADDR_EXP 52
4338: PUSH
4339: LD_INT 0
4341: ST_TO_ADDR
// sAI := false ;
4342: LD_ADDR_EXP 53
4346: PUSH
4347: LD_INT 0
4349: ST_TO_ADDR
// sCargo := false ;
4350: LD_ADDR_EXP 56
4354: PUSH
4355: LD_INT 0
4357: ST_TO_ADDR
// sDLaser := false ;
4358: LD_ADDR_EXP 57
4362: PUSH
4363: LD_INT 0
4365: ST_TO_ADDR
// sExchange := false ;
4366: LD_ADDR_EXP 58
4370: PUSH
4371: LD_INT 0
4373: ST_TO_ADDR
// sFac := false ;
4374: LD_ADDR_EXP 59
4378: PUSH
4379: LD_INT 0
4381: ST_TO_ADDR
// sPower := false ;
4382: LD_ADDR_EXP 60
4386: PUSH
4387: LD_INT 0
4389: ST_TO_ADDR
// sRandom := false ;
4390: LD_ADDR_EXP 61
4394: PUSH
4395: LD_INT 0
4397: ST_TO_ADDR
// sShield := false ;
4398: LD_ADDR_EXP 62
4402: PUSH
4403: LD_INT 0
4405: ST_TO_ADDR
// sTime := false ;
4406: LD_ADDR_EXP 63
4410: PUSH
4411: LD_INT 0
4413: ST_TO_ADDR
// sTools := false ;
4414: LD_ADDR_EXP 64
4418: PUSH
4419: LD_INT 0
4421: ST_TO_ADDR
// sSold := false ;
4422: LD_ADDR_EXP 29
4426: PUSH
4427: LD_INT 0
4429: ST_TO_ADDR
// sDiff := false ;
4430: LD_ADDR_EXP 30
4434: PUSH
4435: LD_INT 0
4437: ST_TO_ADDR
// sFog := false ;
4438: LD_ADDR_EXP 33
4442: PUSH
4443: LD_INT 0
4445: ST_TO_ADDR
// sReset := false ;
4446: LD_ADDR_EXP 34
4450: PUSH
4451: LD_INT 0
4453: ST_TO_ADDR
// sSun := false ;
4454: LD_ADDR_EXP 35
4458: PUSH
4459: LD_INT 0
4461: ST_TO_ADDR
// sTiger := false ;
4462: LD_ADDR_EXP 31
4466: PUSH
4467: LD_INT 0
4469: ST_TO_ADDR
// sBomb := false ;
4470: LD_ADDR_EXP 32
4474: PUSH
4475: LD_INT 0
4477: ST_TO_ADDR
// sWound := false ;
4478: LD_ADDR_EXP 40
4482: PUSH
4483: LD_INT 0
4485: ST_TO_ADDR
// sBetray := false ;
4486: LD_ADDR_EXP 44
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// sContamin := false ;
4494: LD_ADDR_EXP 45
4498: PUSH
4499: LD_INT 0
4501: ST_TO_ADDR
// sOil := false ;
4502: LD_ADDR_EXP 47
4506: PUSH
4507: LD_INT 0
4509: ST_TO_ADDR
// sStu := false ;
4510: LD_ADDR_EXP 51
4514: PUSH
4515: LD_INT 0
4517: ST_TO_ADDR
// sBazooka := false ;
4518: LD_ADDR_EXP 54
4522: PUSH
4523: LD_INT 0
4525: ST_TO_ADDR
// sMortar := false ;
4526: LD_ADDR_EXP 55
4530: PUSH
4531: LD_INT 0
4533: ST_TO_ADDR
// sRanger := false ;
4534: LD_ADDR_EXP 65
4538: PUSH
4539: LD_INT 0
4541: ST_TO_ADDR
// end ;
4542: LD_VAR 0 1
4546: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
4551: PPUSH
4552: PPUSH
4553: PPUSH
// result := [ ] ;
4554: LD_ADDR_VAR 0 1
4558: PUSH
4559: EMPTY
4560: ST_TO_ADDR
// if campaign_id = 1 then
4561: LD_OWVAR 69
4565: PUSH
4566: LD_INT 1
4568: EQUAL
4569: IFFALSE 7517
// begin case mission_number of 1 :
4571: LD_OWVAR 70
4575: PUSH
4576: LD_INT 1
4578: DOUBLE
4579: EQUAL
4580: IFTRUE 4584
4582: GO 4648
4584: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
4585: LD_ADDR_VAR 0 1
4589: PUSH
4590: LD_INT 2
4592: PUSH
4593: LD_INT 4
4595: PUSH
4596: LD_INT 11
4598: PUSH
4599: LD_INT 12
4601: PUSH
4602: LD_INT 15
4604: PUSH
4605: LD_INT 16
4607: PUSH
4608: LD_INT 22
4610: PUSH
4611: LD_INT 23
4613: PUSH
4614: LD_INT 26
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: PUSH
4628: LD_INT 101
4630: PUSH
4631: LD_INT 102
4633: PUSH
4634: LD_INT 106
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: LIST
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: ST_TO_ADDR
4646: GO 7517
4648: LD_INT 2
4650: DOUBLE
4651: EQUAL
4652: IFTRUE 4656
4654: GO 4728
4656: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
4657: LD_ADDR_VAR 0 1
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: LD_INT 4
4667: PUSH
4668: LD_INT 11
4670: PUSH
4671: LD_INT 12
4673: PUSH
4674: LD_INT 15
4676: PUSH
4677: LD_INT 16
4679: PUSH
4680: LD_INT 22
4682: PUSH
4683: LD_INT 23
4685: PUSH
4686: LD_INT 26
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: LIST
4693: LIST
4694: LIST
4695: LIST
4696: LIST
4697: LIST
4698: LIST
4699: PUSH
4700: LD_INT 101
4702: PUSH
4703: LD_INT 102
4705: PUSH
4706: LD_INT 105
4708: PUSH
4709: LD_INT 106
4711: PUSH
4712: LD_INT 108
4714: PUSH
4715: EMPTY
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: ST_TO_ADDR
4726: GO 7517
4728: LD_INT 3
4730: DOUBLE
4731: EQUAL
4732: IFTRUE 4736
4734: GO 4812
4736: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
4737: LD_ADDR_VAR 0 1
4741: PUSH
4742: LD_INT 2
4744: PUSH
4745: LD_INT 4
4747: PUSH
4748: LD_INT 5
4750: PUSH
4751: LD_INT 11
4753: PUSH
4754: LD_INT 12
4756: PUSH
4757: LD_INT 15
4759: PUSH
4760: LD_INT 16
4762: PUSH
4763: LD_INT 22
4765: PUSH
4766: LD_INT 26
4768: PUSH
4769: LD_INT 36
4771: PUSH
4772: EMPTY
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 101
4786: PUSH
4787: LD_INT 102
4789: PUSH
4790: LD_INT 105
4792: PUSH
4793: LD_INT 106
4795: PUSH
4796: LD_INT 108
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: ST_TO_ADDR
4810: GO 7517
4812: LD_INT 4
4814: DOUBLE
4815: EQUAL
4816: IFTRUE 4820
4818: GO 4904
4820: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
4821: LD_ADDR_VAR 0 1
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: LD_INT 4
4831: PUSH
4832: LD_INT 5
4834: PUSH
4835: LD_INT 8
4837: PUSH
4838: LD_INT 11
4840: PUSH
4841: LD_INT 12
4843: PUSH
4844: LD_INT 15
4846: PUSH
4847: LD_INT 16
4849: PUSH
4850: LD_INT 22
4852: PUSH
4853: LD_INT 23
4855: PUSH
4856: LD_INT 26
4858: PUSH
4859: LD_INT 36
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 101
4878: PUSH
4879: LD_INT 102
4881: PUSH
4882: LD_INT 105
4884: PUSH
4885: LD_INT 106
4887: PUSH
4888: LD_INT 108
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: ST_TO_ADDR
4902: GO 7517
4904: LD_INT 5
4906: DOUBLE
4907: EQUAL
4908: IFTRUE 4912
4910: GO 5012
4912: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
4913: LD_ADDR_VAR 0 1
4917: PUSH
4918: LD_INT 2
4920: PUSH
4921: LD_INT 4
4923: PUSH
4924: LD_INT 5
4926: PUSH
4927: LD_INT 6
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: LD_INT 11
4935: PUSH
4936: LD_INT 12
4938: PUSH
4939: LD_INT 15
4941: PUSH
4942: LD_INT 16
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_INT 23
4950: PUSH
4951: LD_INT 25
4953: PUSH
4954: LD_INT 26
4956: PUSH
4957: LD_INT 36
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: PUSH
4976: LD_INT 101
4978: PUSH
4979: LD_INT 102
4981: PUSH
4982: LD_INT 105
4984: PUSH
4985: LD_INT 106
4987: PUSH
4988: LD_INT 108
4990: PUSH
4991: LD_INT 109
4993: PUSH
4994: LD_INT 112
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: ST_TO_ADDR
5010: GO 7517
5012: LD_INT 6
5014: DOUBLE
5015: EQUAL
5016: IFTRUE 5020
5018: GO 5140
5020: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
5021: LD_ADDR_VAR 0 1
5025: PUSH
5026: LD_INT 2
5028: PUSH
5029: LD_INT 4
5031: PUSH
5032: LD_INT 5
5034: PUSH
5035: LD_INT 6
5037: PUSH
5038: LD_INT 8
5040: PUSH
5041: LD_INT 11
5043: PUSH
5044: LD_INT 12
5046: PUSH
5047: LD_INT 15
5049: PUSH
5050: LD_INT 16
5052: PUSH
5053: LD_INT 20
5055: PUSH
5056: LD_INT 21
5058: PUSH
5059: LD_INT 22
5061: PUSH
5062: LD_INT 23
5064: PUSH
5065: LD_INT 25
5067: PUSH
5068: LD_INT 26
5070: PUSH
5071: LD_INT 30
5073: PUSH
5074: LD_INT 31
5076: PUSH
5077: LD_INT 32
5079: PUSH
5080: LD_INT 36
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 101
5106: PUSH
5107: LD_INT 102
5109: PUSH
5110: LD_INT 105
5112: PUSH
5113: LD_INT 106
5115: PUSH
5116: LD_INT 108
5118: PUSH
5119: LD_INT 109
5121: PUSH
5122: LD_INT 112
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: ST_TO_ADDR
5138: GO 7517
5140: LD_INT 7
5142: DOUBLE
5143: EQUAL
5144: IFTRUE 5148
5146: GO 5248
5148: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
5149: LD_ADDR_VAR 0 1
5153: PUSH
5154: LD_INT 2
5156: PUSH
5157: LD_INT 4
5159: PUSH
5160: LD_INT 5
5162: PUSH
5163: LD_INT 7
5165: PUSH
5166: LD_INT 11
5168: PUSH
5169: LD_INT 12
5171: PUSH
5172: LD_INT 15
5174: PUSH
5175: LD_INT 16
5177: PUSH
5178: LD_INT 20
5180: PUSH
5181: LD_INT 21
5183: PUSH
5184: LD_INT 22
5186: PUSH
5187: LD_INT 23
5189: PUSH
5190: LD_INT 25
5192: PUSH
5193: LD_INT 26
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 101
5214: PUSH
5215: LD_INT 102
5217: PUSH
5218: LD_INT 103
5220: PUSH
5221: LD_INT 105
5223: PUSH
5224: LD_INT 106
5226: PUSH
5227: LD_INT 108
5229: PUSH
5230: LD_INT 112
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: ST_TO_ADDR
5246: GO 7517
5248: LD_INT 8
5250: DOUBLE
5251: EQUAL
5252: IFTRUE 5256
5254: GO 5384
5256: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
5257: LD_ADDR_VAR 0 1
5261: PUSH
5262: LD_INT 2
5264: PUSH
5265: LD_INT 4
5267: PUSH
5268: LD_INT 5
5270: PUSH
5271: LD_INT 6
5273: PUSH
5274: LD_INT 7
5276: PUSH
5277: LD_INT 8
5279: PUSH
5280: LD_INT 11
5282: PUSH
5283: LD_INT 12
5285: PUSH
5286: LD_INT 15
5288: PUSH
5289: LD_INT 16
5291: PUSH
5292: LD_INT 20
5294: PUSH
5295: LD_INT 21
5297: PUSH
5298: LD_INT 22
5300: PUSH
5301: LD_INT 23
5303: PUSH
5304: LD_INT 25
5306: PUSH
5307: LD_INT 26
5309: PUSH
5310: LD_INT 30
5312: PUSH
5313: LD_INT 31
5315: PUSH
5316: LD_INT 32
5318: PUSH
5319: LD_INT 36
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: LIST
5332: LIST
5333: LIST
5334: LIST
5335: LIST
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: LIST
5343: PUSH
5344: LD_INT 101
5346: PUSH
5347: LD_INT 102
5349: PUSH
5350: LD_INT 103
5352: PUSH
5353: LD_INT 105
5355: PUSH
5356: LD_INT 106
5358: PUSH
5359: LD_INT 108
5361: PUSH
5362: LD_INT 109
5364: PUSH
5365: LD_INT 112
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: ST_TO_ADDR
5382: GO 7517
5384: LD_INT 9
5386: DOUBLE
5387: EQUAL
5388: IFTRUE 5392
5390: GO 5528
5392: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: LD_INT 2
5400: PUSH
5401: LD_INT 4
5403: PUSH
5404: LD_INT 5
5406: PUSH
5407: LD_INT 6
5409: PUSH
5410: LD_INT 7
5412: PUSH
5413: LD_INT 8
5415: PUSH
5416: LD_INT 11
5418: PUSH
5419: LD_INT 12
5421: PUSH
5422: LD_INT 15
5424: PUSH
5425: LD_INT 16
5427: PUSH
5428: LD_INT 20
5430: PUSH
5431: LD_INT 21
5433: PUSH
5434: LD_INT 22
5436: PUSH
5437: LD_INT 23
5439: PUSH
5440: LD_INT 25
5442: PUSH
5443: LD_INT 26
5445: PUSH
5446: LD_INT 28
5448: PUSH
5449: LD_INT 30
5451: PUSH
5452: LD_INT 31
5454: PUSH
5455: LD_INT 32
5457: PUSH
5458: LD_INT 36
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: LIST
5465: LIST
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: LIST
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: LIST
5483: PUSH
5484: LD_INT 101
5486: PUSH
5487: LD_INT 102
5489: PUSH
5490: LD_INT 103
5492: PUSH
5493: LD_INT 105
5495: PUSH
5496: LD_INT 106
5498: PUSH
5499: LD_INT 108
5501: PUSH
5502: LD_INT 109
5504: PUSH
5505: LD_INT 112
5507: PUSH
5508: LD_INT 114
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: ST_TO_ADDR
5526: GO 7517
5528: LD_INT 10
5530: DOUBLE
5531: EQUAL
5532: IFTRUE 5536
5534: GO 5720
5536: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
5537: LD_ADDR_VAR 0 1
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 5
5550: PUSH
5551: LD_INT 6
5553: PUSH
5554: LD_INT 7
5556: PUSH
5557: LD_INT 8
5559: PUSH
5560: LD_INT 9
5562: PUSH
5563: LD_INT 10
5565: PUSH
5566: LD_INT 11
5568: PUSH
5569: LD_INT 12
5571: PUSH
5572: LD_INT 13
5574: PUSH
5575: LD_INT 14
5577: PUSH
5578: LD_INT 15
5580: PUSH
5581: LD_INT 16
5583: PUSH
5584: LD_INT 17
5586: PUSH
5587: LD_INT 18
5589: PUSH
5590: LD_INT 19
5592: PUSH
5593: LD_INT 20
5595: PUSH
5596: LD_INT 21
5598: PUSH
5599: LD_INT 22
5601: PUSH
5602: LD_INT 23
5604: PUSH
5605: LD_INT 24
5607: PUSH
5608: LD_INT 25
5610: PUSH
5611: LD_INT 26
5613: PUSH
5614: LD_INT 28
5616: PUSH
5617: LD_INT 30
5619: PUSH
5620: LD_INT 31
5622: PUSH
5623: LD_INT 32
5625: PUSH
5626: LD_INT 36
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 101
5662: PUSH
5663: LD_INT 102
5665: PUSH
5666: LD_INT 103
5668: PUSH
5669: LD_INT 104
5671: PUSH
5672: LD_INT 105
5674: PUSH
5675: LD_INT 106
5677: PUSH
5678: LD_INT 107
5680: PUSH
5681: LD_INT 108
5683: PUSH
5684: LD_INT 109
5686: PUSH
5687: LD_INT 110
5689: PUSH
5690: LD_INT 111
5692: PUSH
5693: LD_INT 112
5695: PUSH
5696: LD_INT 114
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: ST_TO_ADDR
5718: GO 7517
5720: LD_INT 11
5722: DOUBLE
5723: EQUAL
5724: IFTRUE 5728
5726: GO 5920
5728: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
5729: LD_ADDR_VAR 0 1
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 3
5739: PUSH
5740: LD_INT 4
5742: PUSH
5743: LD_INT 5
5745: PUSH
5746: LD_INT 6
5748: PUSH
5749: LD_INT 7
5751: PUSH
5752: LD_INT 8
5754: PUSH
5755: LD_INT 9
5757: PUSH
5758: LD_INT 10
5760: PUSH
5761: LD_INT 11
5763: PUSH
5764: LD_INT 12
5766: PUSH
5767: LD_INT 13
5769: PUSH
5770: LD_INT 14
5772: PUSH
5773: LD_INT 15
5775: PUSH
5776: LD_INT 16
5778: PUSH
5779: LD_INT 17
5781: PUSH
5782: LD_INT 18
5784: PUSH
5785: LD_INT 19
5787: PUSH
5788: LD_INT 20
5790: PUSH
5791: LD_INT 21
5793: PUSH
5794: LD_INT 22
5796: PUSH
5797: LD_INT 23
5799: PUSH
5800: LD_INT 24
5802: PUSH
5803: LD_INT 25
5805: PUSH
5806: LD_INT 26
5808: PUSH
5809: LD_INT 28
5811: PUSH
5812: LD_INT 30
5814: PUSH
5815: LD_INT 31
5817: PUSH
5818: LD_INT 32
5820: PUSH
5821: LD_INT 34
5823: PUSH
5824: LD_INT 36
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: LIST
5836: LIST
5837: LIST
5838: LIST
5839: LIST
5840: LIST
5841: LIST
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 101
5862: PUSH
5863: LD_INT 102
5865: PUSH
5866: LD_INT 103
5868: PUSH
5869: LD_INT 104
5871: PUSH
5872: LD_INT 105
5874: PUSH
5875: LD_INT 106
5877: PUSH
5878: LD_INT 107
5880: PUSH
5881: LD_INT 108
5883: PUSH
5884: LD_INT 109
5886: PUSH
5887: LD_INT 110
5889: PUSH
5890: LD_INT 111
5892: PUSH
5893: LD_INT 112
5895: PUSH
5896: LD_INT 114
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: ST_TO_ADDR
5918: GO 7517
5920: LD_INT 12
5922: DOUBLE
5923: EQUAL
5924: IFTRUE 5928
5926: GO 6136
5928: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
5929: LD_ADDR_VAR 0 1
5933: PUSH
5934: LD_INT 1
5936: PUSH
5937: LD_INT 2
5939: PUSH
5940: LD_INT 3
5942: PUSH
5943: LD_INT 4
5945: PUSH
5946: LD_INT 5
5948: PUSH
5949: LD_INT 6
5951: PUSH
5952: LD_INT 7
5954: PUSH
5955: LD_INT 8
5957: PUSH
5958: LD_INT 9
5960: PUSH
5961: LD_INT 10
5963: PUSH
5964: LD_INT 11
5966: PUSH
5967: LD_INT 12
5969: PUSH
5970: LD_INT 13
5972: PUSH
5973: LD_INT 14
5975: PUSH
5976: LD_INT 15
5978: PUSH
5979: LD_INT 16
5981: PUSH
5982: LD_INT 17
5984: PUSH
5985: LD_INT 18
5987: PUSH
5988: LD_INT 19
5990: PUSH
5991: LD_INT 20
5993: PUSH
5994: LD_INT 21
5996: PUSH
5997: LD_INT 22
5999: PUSH
6000: LD_INT 23
6002: PUSH
6003: LD_INT 24
6005: PUSH
6006: LD_INT 25
6008: PUSH
6009: LD_INT 26
6011: PUSH
6012: LD_INT 27
6014: PUSH
6015: LD_INT 28
6017: PUSH
6018: LD_INT 30
6020: PUSH
6021: LD_INT 31
6023: PUSH
6024: LD_INT 32
6026: PUSH
6027: LD_INT 33
6029: PUSH
6030: LD_INT 34
6032: PUSH
6033: LD_INT 36
6035: PUSH
6036: EMPTY
6037: LIST
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: LIST
6071: PUSH
6072: LD_INT 101
6074: PUSH
6075: LD_INT 102
6077: PUSH
6078: LD_INT 103
6080: PUSH
6081: LD_INT 104
6083: PUSH
6084: LD_INT 105
6086: PUSH
6087: LD_INT 106
6089: PUSH
6090: LD_INT 107
6092: PUSH
6093: LD_INT 108
6095: PUSH
6096: LD_INT 109
6098: PUSH
6099: LD_INT 110
6101: PUSH
6102: LD_INT 111
6104: PUSH
6105: LD_INT 112
6107: PUSH
6108: LD_INT 113
6110: PUSH
6111: LD_INT 114
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: ST_TO_ADDR
6134: GO 7517
6136: LD_INT 13
6138: DOUBLE
6139: EQUAL
6140: IFTRUE 6144
6142: GO 6352
6144: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
6145: LD_ADDR_VAR 0 1
6149: PUSH
6150: LD_INT 1
6152: PUSH
6153: LD_INT 2
6155: PUSH
6156: LD_INT 3
6158: PUSH
6159: LD_INT 4
6161: PUSH
6162: LD_INT 5
6164: PUSH
6165: LD_INT 6
6167: PUSH
6168: LD_INT 7
6170: PUSH
6171: LD_INT 8
6173: PUSH
6174: LD_INT 9
6176: PUSH
6177: LD_INT 10
6179: PUSH
6180: LD_INT 11
6182: PUSH
6183: LD_INT 12
6185: PUSH
6186: LD_INT 13
6188: PUSH
6189: LD_INT 14
6191: PUSH
6192: LD_INT 15
6194: PUSH
6195: LD_INT 16
6197: PUSH
6198: LD_INT 17
6200: PUSH
6201: LD_INT 18
6203: PUSH
6204: LD_INT 19
6206: PUSH
6207: LD_INT 20
6209: PUSH
6210: LD_INT 21
6212: PUSH
6213: LD_INT 22
6215: PUSH
6216: LD_INT 23
6218: PUSH
6219: LD_INT 24
6221: PUSH
6222: LD_INT 25
6224: PUSH
6225: LD_INT 26
6227: PUSH
6228: LD_INT 27
6230: PUSH
6231: LD_INT 28
6233: PUSH
6234: LD_INT 30
6236: PUSH
6237: LD_INT 31
6239: PUSH
6240: LD_INT 32
6242: PUSH
6243: LD_INT 33
6245: PUSH
6246: LD_INT 34
6248: PUSH
6249: LD_INT 36
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: LIST
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: PUSH
6288: LD_INT 101
6290: PUSH
6291: LD_INT 102
6293: PUSH
6294: LD_INT 103
6296: PUSH
6297: LD_INT 104
6299: PUSH
6300: LD_INT 105
6302: PUSH
6303: LD_INT 106
6305: PUSH
6306: LD_INT 107
6308: PUSH
6309: LD_INT 108
6311: PUSH
6312: LD_INT 109
6314: PUSH
6315: LD_INT 110
6317: PUSH
6318: LD_INT 111
6320: PUSH
6321: LD_INT 112
6323: PUSH
6324: LD_INT 113
6326: PUSH
6327: LD_INT 114
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: ST_TO_ADDR
6350: GO 7517
6352: LD_INT 14
6354: DOUBLE
6355: EQUAL
6356: IFTRUE 6360
6358: GO 6572
6360: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: LD_INT 1
6368: PUSH
6369: LD_INT 2
6371: PUSH
6372: LD_INT 3
6374: PUSH
6375: LD_INT 4
6377: PUSH
6378: LD_INT 5
6380: PUSH
6381: LD_INT 6
6383: PUSH
6384: LD_INT 7
6386: PUSH
6387: LD_INT 8
6389: PUSH
6390: LD_INT 9
6392: PUSH
6393: LD_INT 10
6395: PUSH
6396: LD_INT 11
6398: PUSH
6399: LD_INT 12
6401: PUSH
6402: LD_INT 13
6404: PUSH
6405: LD_INT 14
6407: PUSH
6408: LD_INT 15
6410: PUSH
6411: LD_INT 16
6413: PUSH
6414: LD_INT 17
6416: PUSH
6417: LD_INT 18
6419: PUSH
6420: LD_INT 19
6422: PUSH
6423: LD_INT 20
6425: PUSH
6426: LD_INT 21
6428: PUSH
6429: LD_INT 22
6431: PUSH
6432: LD_INT 23
6434: PUSH
6435: LD_INT 24
6437: PUSH
6438: LD_INT 25
6440: PUSH
6441: LD_INT 26
6443: PUSH
6444: LD_INT 27
6446: PUSH
6447: LD_INT 28
6449: PUSH
6450: LD_INT 29
6452: PUSH
6453: LD_INT 30
6455: PUSH
6456: LD_INT 31
6458: PUSH
6459: LD_INT 32
6461: PUSH
6462: LD_INT 33
6464: PUSH
6465: LD_INT 34
6467: PUSH
6468: LD_INT 36
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 101
6510: PUSH
6511: LD_INT 102
6513: PUSH
6514: LD_INT 103
6516: PUSH
6517: LD_INT 104
6519: PUSH
6520: LD_INT 105
6522: PUSH
6523: LD_INT 106
6525: PUSH
6526: LD_INT 107
6528: PUSH
6529: LD_INT 108
6531: PUSH
6532: LD_INT 109
6534: PUSH
6535: LD_INT 110
6537: PUSH
6538: LD_INT 111
6540: PUSH
6541: LD_INT 112
6543: PUSH
6544: LD_INT 113
6546: PUSH
6547: LD_INT 114
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: LIST
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: ST_TO_ADDR
6570: GO 7517
6572: LD_INT 15
6574: DOUBLE
6575: EQUAL
6576: IFTRUE 6580
6578: GO 6792
6580: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
6581: LD_ADDR_VAR 0 1
6585: PUSH
6586: LD_INT 1
6588: PUSH
6589: LD_INT 2
6591: PUSH
6592: LD_INT 3
6594: PUSH
6595: LD_INT 4
6597: PUSH
6598: LD_INT 5
6600: PUSH
6601: LD_INT 6
6603: PUSH
6604: LD_INT 7
6606: PUSH
6607: LD_INT 8
6609: PUSH
6610: LD_INT 9
6612: PUSH
6613: LD_INT 10
6615: PUSH
6616: LD_INT 11
6618: PUSH
6619: LD_INT 12
6621: PUSH
6622: LD_INT 13
6624: PUSH
6625: LD_INT 14
6627: PUSH
6628: LD_INT 15
6630: PUSH
6631: LD_INT 16
6633: PUSH
6634: LD_INT 17
6636: PUSH
6637: LD_INT 18
6639: PUSH
6640: LD_INT 19
6642: PUSH
6643: LD_INT 20
6645: PUSH
6646: LD_INT 21
6648: PUSH
6649: LD_INT 22
6651: PUSH
6652: LD_INT 23
6654: PUSH
6655: LD_INT 24
6657: PUSH
6658: LD_INT 25
6660: PUSH
6661: LD_INT 26
6663: PUSH
6664: LD_INT 27
6666: PUSH
6667: LD_INT 28
6669: PUSH
6670: LD_INT 29
6672: PUSH
6673: LD_INT 30
6675: PUSH
6676: LD_INT 31
6678: PUSH
6679: LD_INT 32
6681: PUSH
6682: LD_INT 33
6684: PUSH
6685: LD_INT 34
6687: PUSH
6688: LD_INT 36
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 101
6730: PUSH
6731: LD_INT 102
6733: PUSH
6734: LD_INT 103
6736: PUSH
6737: LD_INT 104
6739: PUSH
6740: LD_INT 105
6742: PUSH
6743: LD_INT 106
6745: PUSH
6746: LD_INT 107
6748: PUSH
6749: LD_INT 108
6751: PUSH
6752: LD_INT 109
6754: PUSH
6755: LD_INT 110
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 112
6763: PUSH
6764: LD_INT 113
6766: PUSH
6767: LD_INT 114
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: LIST
6778: LIST
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: ST_TO_ADDR
6790: GO 7517
6792: LD_INT 16
6794: DOUBLE
6795: EQUAL
6796: IFTRUE 6800
6798: GO 6924
6800: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: LD_INT 2
6808: PUSH
6809: LD_INT 4
6811: PUSH
6812: LD_INT 5
6814: PUSH
6815: LD_INT 7
6817: PUSH
6818: LD_INT 11
6820: PUSH
6821: LD_INT 12
6823: PUSH
6824: LD_INT 15
6826: PUSH
6827: LD_INT 16
6829: PUSH
6830: LD_INT 20
6832: PUSH
6833: LD_INT 21
6835: PUSH
6836: LD_INT 22
6838: PUSH
6839: LD_INT 23
6841: PUSH
6842: LD_INT 25
6844: PUSH
6845: LD_INT 26
6847: PUSH
6848: LD_INT 30
6850: PUSH
6851: LD_INT 31
6853: PUSH
6854: LD_INT 32
6856: PUSH
6857: LD_INT 33
6859: PUSH
6860: LD_INT 34
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: LD_INT 101
6886: PUSH
6887: LD_INT 102
6889: PUSH
6890: LD_INT 103
6892: PUSH
6893: LD_INT 106
6895: PUSH
6896: LD_INT 108
6898: PUSH
6899: LD_INT 112
6901: PUSH
6902: LD_INT 113
6904: PUSH
6905: LD_INT 114
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: ST_TO_ADDR
6922: GO 7517
6924: LD_INT 17
6926: DOUBLE
6927: EQUAL
6928: IFTRUE 6932
6930: GO 7144
6932: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
6933: LD_ADDR_VAR 0 1
6937: PUSH
6938: LD_INT 1
6940: PUSH
6941: LD_INT 2
6943: PUSH
6944: LD_INT 3
6946: PUSH
6947: LD_INT 4
6949: PUSH
6950: LD_INT 5
6952: PUSH
6953: LD_INT 6
6955: PUSH
6956: LD_INT 7
6958: PUSH
6959: LD_INT 8
6961: PUSH
6962: LD_INT 9
6964: PUSH
6965: LD_INT 10
6967: PUSH
6968: LD_INT 11
6970: PUSH
6971: LD_INT 12
6973: PUSH
6974: LD_INT 13
6976: PUSH
6977: LD_INT 14
6979: PUSH
6980: LD_INT 15
6982: PUSH
6983: LD_INT 16
6985: PUSH
6986: LD_INT 17
6988: PUSH
6989: LD_INT 18
6991: PUSH
6992: LD_INT 19
6994: PUSH
6995: LD_INT 20
6997: PUSH
6998: LD_INT 21
7000: PUSH
7001: LD_INT 22
7003: PUSH
7004: LD_INT 23
7006: PUSH
7007: LD_INT 24
7009: PUSH
7010: LD_INT 25
7012: PUSH
7013: LD_INT 26
7015: PUSH
7016: LD_INT 27
7018: PUSH
7019: LD_INT 28
7021: PUSH
7022: LD_INT 29
7024: PUSH
7025: LD_INT 30
7027: PUSH
7028: LD_INT 31
7030: PUSH
7031: LD_INT 32
7033: PUSH
7034: LD_INT 33
7036: PUSH
7037: LD_INT 34
7039: PUSH
7040: LD_INT 36
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: LIST
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: LIST
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: LIST
7058: LIST
7059: LIST
7060: LIST
7061: LIST
7062: LIST
7063: LIST
7064: LIST
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: LIST
7076: LIST
7077: LIST
7078: LIST
7079: PUSH
7080: LD_INT 101
7082: PUSH
7083: LD_INT 102
7085: PUSH
7086: LD_INT 103
7088: PUSH
7089: LD_INT 104
7091: PUSH
7092: LD_INT 105
7094: PUSH
7095: LD_INT 106
7097: PUSH
7098: LD_INT 107
7100: PUSH
7101: LD_INT 108
7103: PUSH
7104: LD_INT 109
7106: PUSH
7107: LD_INT 110
7109: PUSH
7110: LD_INT 111
7112: PUSH
7113: LD_INT 112
7115: PUSH
7116: LD_INT 113
7118: PUSH
7119: LD_INT 114
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: ST_TO_ADDR
7142: GO 7517
7144: LD_INT 18
7146: DOUBLE
7147: EQUAL
7148: IFTRUE 7152
7150: GO 7288
7152: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
7153: LD_ADDR_VAR 0 1
7157: PUSH
7158: LD_INT 2
7160: PUSH
7161: LD_INT 4
7163: PUSH
7164: LD_INT 5
7166: PUSH
7167: LD_INT 7
7169: PUSH
7170: LD_INT 11
7172: PUSH
7173: LD_INT 12
7175: PUSH
7176: LD_INT 15
7178: PUSH
7179: LD_INT 16
7181: PUSH
7182: LD_INT 20
7184: PUSH
7185: LD_INT 21
7187: PUSH
7188: LD_INT 22
7190: PUSH
7191: LD_INT 23
7193: PUSH
7194: LD_INT 25
7196: PUSH
7197: LD_INT 26
7199: PUSH
7200: LD_INT 30
7202: PUSH
7203: LD_INT 31
7205: PUSH
7206: LD_INT 32
7208: PUSH
7209: LD_INT 33
7211: PUSH
7212: LD_INT 34
7214: PUSH
7215: LD_INT 35
7217: PUSH
7218: LD_INT 36
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 101
7246: PUSH
7247: LD_INT 102
7249: PUSH
7250: LD_INT 103
7252: PUSH
7253: LD_INT 106
7255: PUSH
7256: LD_INT 108
7258: PUSH
7259: LD_INT 112
7261: PUSH
7262: LD_INT 113
7264: PUSH
7265: LD_INT 114
7267: PUSH
7268: LD_INT 115
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: LIST
7281: PUSH
7282: EMPTY
7283: LIST
7284: LIST
7285: ST_TO_ADDR
7286: GO 7517
7288: LD_INT 19
7290: DOUBLE
7291: EQUAL
7292: IFTRUE 7296
7294: GO 7516
7296: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
7297: LD_ADDR_VAR 0 1
7301: PUSH
7302: LD_INT 1
7304: PUSH
7305: LD_INT 2
7307: PUSH
7308: LD_INT 3
7310: PUSH
7311: LD_INT 4
7313: PUSH
7314: LD_INT 5
7316: PUSH
7317: LD_INT 6
7319: PUSH
7320: LD_INT 7
7322: PUSH
7323: LD_INT 8
7325: PUSH
7326: LD_INT 9
7328: PUSH
7329: LD_INT 10
7331: PUSH
7332: LD_INT 11
7334: PUSH
7335: LD_INT 12
7337: PUSH
7338: LD_INT 13
7340: PUSH
7341: LD_INT 14
7343: PUSH
7344: LD_INT 15
7346: PUSH
7347: LD_INT 16
7349: PUSH
7350: LD_INT 17
7352: PUSH
7353: LD_INT 18
7355: PUSH
7356: LD_INT 19
7358: PUSH
7359: LD_INT 20
7361: PUSH
7362: LD_INT 21
7364: PUSH
7365: LD_INT 22
7367: PUSH
7368: LD_INT 23
7370: PUSH
7371: LD_INT 24
7373: PUSH
7374: LD_INT 25
7376: PUSH
7377: LD_INT 26
7379: PUSH
7380: LD_INT 27
7382: PUSH
7383: LD_INT 28
7385: PUSH
7386: LD_INT 29
7388: PUSH
7389: LD_INT 30
7391: PUSH
7392: LD_INT 31
7394: PUSH
7395: LD_INT 32
7397: PUSH
7398: LD_INT 33
7400: PUSH
7401: LD_INT 34
7403: PUSH
7404: LD_INT 35
7406: PUSH
7407: LD_INT 36
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: LIST
7416: LIST
7417: LIST
7418: LIST
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: LIST
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: LIST
7442: LIST
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 101
7450: PUSH
7451: LD_INT 102
7453: PUSH
7454: LD_INT 103
7456: PUSH
7457: LD_INT 104
7459: PUSH
7460: LD_INT 105
7462: PUSH
7463: LD_INT 106
7465: PUSH
7466: LD_INT 107
7468: PUSH
7469: LD_INT 108
7471: PUSH
7472: LD_INT 109
7474: PUSH
7475: LD_INT 110
7477: PUSH
7478: LD_INT 111
7480: PUSH
7481: LD_INT 112
7483: PUSH
7484: LD_INT 113
7486: PUSH
7487: LD_INT 114
7489: PUSH
7490: LD_INT 115
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: ST_TO_ADDR
7514: GO 7517
7516: POP
// end ; if result then
7517: LD_VAR 0 1
7521: IFFALSE 7810
// begin normal :=  ;
7523: LD_ADDR_VAR 0 3
7527: PUSH
7528: LD_STRING 
7530: ST_TO_ADDR
// hardcore :=  ;
7531: LD_ADDR_VAR 0 4
7535: PUSH
7536: LD_STRING 
7538: ST_TO_ADDR
// for i = 1 to normalCounter do
7539: LD_ADDR_VAR 0 5
7543: PUSH
7544: DOUBLE
7545: LD_INT 1
7547: DEC
7548: ST_TO_ADDR
7549: LD_EXP 13
7553: PUSH
7554: FOR_TO
7555: IFFALSE 7656
// begin tmp := 0 ;
7557: LD_ADDR_VAR 0 2
7561: PUSH
7562: LD_STRING 0
7564: ST_TO_ADDR
// if result [ 1 ] then
7565: LD_VAR 0 1
7569: PUSH
7570: LD_INT 1
7572: ARRAY
7573: IFFALSE 7638
// if result [ 1 ] [ 1 ] = i then
7575: LD_VAR 0 1
7579: PUSH
7580: LD_INT 1
7582: ARRAY
7583: PUSH
7584: LD_INT 1
7586: ARRAY
7587: PUSH
7588: LD_VAR 0 5
7592: EQUAL
7593: IFFALSE 7638
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
7595: LD_ADDR_VAR 0 1
7599: PUSH
7600: LD_VAR 0 1
7604: PPUSH
7605: LD_INT 1
7607: PPUSH
7608: LD_VAR 0 1
7612: PUSH
7613: LD_INT 1
7615: ARRAY
7616: PPUSH
7617: LD_INT 1
7619: PPUSH
7620: CALL_OW 3
7624: PPUSH
7625: CALL_OW 1
7629: ST_TO_ADDR
// tmp := 1 ;
7630: LD_ADDR_VAR 0 2
7634: PUSH
7635: LD_STRING 1
7637: ST_TO_ADDR
// end ; normal := normal & tmp ;
7638: LD_ADDR_VAR 0 3
7642: PUSH
7643: LD_VAR 0 3
7647: PUSH
7648: LD_VAR 0 2
7652: STR
7653: ST_TO_ADDR
// end ;
7654: GO 7554
7656: POP
7657: POP
// for i = 1 to hardcoreCounter do
7658: LD_ADDR_VAR 0 5
7662: PUSH
7663: DOUBLE
7664: LD_INT 1
7666: DEC
7667: ST_TO_ADDR
7668: LD_EXP 14
7672: PUSH
7673: FOR_TO
7674: IFFALSE 7779
// begin tmp := 0 ;
7676: LD_ADDR_VAR 0 2
7680: PUSH
7681: LD_STRING 0
7683: ST_TO_ADDR
// if result [ 2 ] then
7684: LD_VAR 0 1
7688: PUSH
7689: LD_INT 2
7691: ARRAY
7692: IFFALSE 7761
// if result [ 2 ] [ 1 ] = 100 + i then
7694: LD_VAR 0 1
7698: PUSH
7699: LD_INT 2
7701: ARRAY
7702: PUSH
7703: LD_INT 1
7705: ARRAY
7706: PUSH
7707: LD_INT 100
7709: PUSH
7710: LD_VAR 0 5
7714: PLUS
7715: EQUAL
7716: IFFALSE 7761
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
7718: LD_ADDR_VAR 0 1
7722: PUSH
7723: LD_VAR 0 1
7727: PPUSH
7728: LD_INT 2
7730: PPUSH
7731: LD_VAR 0 1
7735: PUSH
7736: LD_INT 2
7738: ARRAY
7739: PPUSH
7740: LD_INT 1
7742: PPUSH
7743: CALL_OW 3
7747: PPUSH
7748: CALL_OW 1
7752: ST_TO_ADDR
// tmp := 1 ;
7753: LD_ADDR_VAR 0 2
7757: PUSH
7758: LD_STRING 1
7760: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
7761: LD_ADDR_VAR 0 4
7765: PUSH
7766: LD_VAR 0 4
7770: PUSH
7771: LD_VAR 0 2
7775: STR
7776: ST_TO_ADDR
// end ;
7777: GO 7673
7779: POP
7780: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
7781: LD_STRING getStreamItemsFromMission("
7783: PUSH
7784: LD_VAR 0 3
7788: STR
7789: PUSH
7790: LD_STRING ","
7792: STR
7793: PUSH
7794: LD_VAR 0 4
7798: STR
7799: PUSH
7800: LD_STRING ")
7802: STR
7803: PPUSH
7804: CALL_OW 559
// end else
7808: GO 7817
// ToLua ( getStreamItemsFromMission("","") ) ;
7810: LD_STRING getStreamItemsFromMission("","")
7812: PPUSH
7813: CALL_OW 559
// end ;
7817: LD_VAR 0 1
7821: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
7822: LD_VAR 0 2
7826: PUSH
7827: LD_INT 100
7829: EQUAL
7830: IFFALSE 8779
// begin if not StreamModeActive then
7832: LD_EXP 12
7836: NOT
7837: IFFALSE 7847
// StreamModeActive := true ;
7839: LD_ADDR_EXP 12
7843: PUSH
7844: LD_INT 1
7846: ST_TO_ADDR
// if p3 = 0 then
7847: LD_VAR 0 3
7851: PUSH
7852: LD_INT 0
7854: EQUAL
7855: IFFALSE 7861
// InitStreamMode ;
7857: CALL 4107 0 0
// if p3 = 1 then
7861: LD_VAR 0 3
7865: PUSH
7866: LD_INT 1
7868: EQUAL
7869: IFFALSE 7879
// sRocket := true ;
7871: LD_ADDR_EXP 17
7875: PUSH
7876: LD_INT 1
7878: ST_TO_ADDR
// if p3 = 2 then
7879: LD_VAR 0 3
7883: PUSH
7884: LD_INT 2
7886: EQUAL
7887: IFFALSE 7897
// sSpeed := true ;
7889: LD_ADDR_EXP 16
7893: PUSH
7894: LD_INT 1
7896: ST_TO_ADDR
// if p3 = 3 then
7897: LD_VAR 0 3
7901: PUSH
7902: LD_INT 3
7904: EQUAL
7905: IFFALSE 7915
// sEngine := true ;
7907: LD_ADDR_EXP 18
7911: PUSH
7912: LD_INT 1
7914: ST_TO_ADDR
// if p3 = 4 then
7915: LD_VAR 0 3
7919: PUSH
7920: LD_INT 4
7922: EQUAL
7923: IFFALSE 7933
// sSpec := true ;
7925: LD_ADDR_EXP 15
7929: PUSH
7930: LD_INT 1
7932: ST_TO_ADDR
// if p3 = 5 then
7933: LD_VAR 0 3
7937: PUSH
7938: LD_INT 5
7940: EQUAL
7941: IFFALSE 7951
// sLevel := true ;
7943: LD_ADDR_EXP 19
7947: PUSH
7948: LD_INT 1
7950: ST_TO_ADDR
// if p3 = 6 then
7951: LD_VAR 0 3
7955: PUSH
7956: LD_INT 6
7958: EQUAL
7959: IFFALSE 7969
// sArmoury := true ;
7961: LD_ADDR_EXP 20
7965: PUSH
7966: LD_INT 1
7968: ST_TO_ADDR
// if p3 = 7 then
7969: LD_VAR 0 3
7973: PUSH
7974: LD_INT 7
7976: EQUAL
7977: IFFALSE 7987
// sRadar := true ;
7979: LD_ADDR_EXP 21
7983: PUSH
7984: LD_INT 1
7986: ST_TO_ADDR
// if p3 = 8 then
7987: LD_VAR 0 3
7991: PUSH
7992: LD_INT 8
7994: EQUAL
7995: IFFALSE 8005
// sBunker := true ;
7997: LD_ADDR_EXP 22
8001: PUSH
8002: LD_INT 1
8004: ST_TO_ADDR
// if p3 = 9 then
8005: LD_VAR 0 3
8009: PUSH
8010: LD_INT 9
8012: EQUAL
8013: IFFALSE 8023
// sHack := true ;
8015: LD_ADDR_EXP 23
8019: PUSH
8020: LD_INT 1
8022: ST_TO_ADDR
// if p3 = 10 then
8023: LD_VAR 0 3
8027: PUSH
8028: LD_INT 10
8030: EQUAL
8031: IFFALSE 8041
// sFire := true ;
8033: LD_ADDR_EXP 24
8037: PUSH
8038: LD_INT 1
8040: ST_TO_ADDR
// if p3 = 11 then
8041: LD_VAR 0 3
8045: PUSH
8046: LD_INT 11
8048: EQUAL
8049: IFFALSE 8059
// sRefresh := true ;
8051: LD_ADDR_EXP 25
8055: PUSH
8056: LD_INT 1
8058: ST_TO_ADDR
// if p3 = 12 then
8059: LD_VAR 0 3
8063: PUSH
8064: LD_INT 12
8066: EQUAL
8067: IFFALSE 8077
// sExp := true ;
8069: LD_ADDR_EXP 26
8073: PUSH
8074: LD_INT 1
8076: ST_TO_ADDR
// if p3 = 13 then
8077: LD_VAR 0 3
8081: PUSH
8082: LD_INT 13
8084: EQUAL
8085: IFFALSE 8095
// sDepot := true ;
8087: LD_ADDR_EXP 27
8091: PUSH
8092: LD_INT 1
8094: ST_TO_ADDR
// if p3 = 14 then
8095: LD_VAR 0 3
8099: PUSH
8100: LD_INT 14
8102: EQUAL
8103: IFFALSE 8113
// sFlag := true ;
8105: LD_ADDR_EXP 28
8109: PUSH
8110: LD_INT 1
8112: ST_TO_ADDR
// if p3 = 15 then
8113: LD_VAR 0 3
8117: PUSH
8118: LD_INT 15
8120: EQUAL
8121: IFFALSE 8131
// sKamikadze := true ;
8123: LD_ADDR_EXP 36
8127: PUSH
8128: LD_INT 1
8130: ST_TO_ADDR
// if p3 = 16 then
8131: LD_VAR 0 3
8135: PUSH
8136: LD_INT 16
8138: EQUAL
8139: IFFALSE 8149
// sTroll := true ;
8141: LD_ADDR_EXP 37
8145: PUSH
8146: LD_INT 1
8148: ST_TO_ADDR
// if p3 = 17 then
8149: LD_VAR 0 3
8153: PUSH
8154: LD_INT 17
8156: EQUAL
8157: IFFALSE 8167
// sSlow := true ;
8159: LD_ADDR_EXP 38
8163: PUSH
8164: LD_INT 1
8166: ST_TO_ADDR
// if p3 = 18 then
8167: LD_VAR 0 3
8171: PUSH
8172: LD_INT 18
8174: EQUAL
8175: IFFALSE 8185
// sLack := true ;
8177: LD_ADDR_EXP 39
8181: PUSH
8182: LD_INT 1
8184: ST_TO_ADDR
// if p3 = 19 then
8185: LD_VAR 0 3
8189: PUSH
8190: LD_INT 19
8192: EQUAL
8193: IFFALSE 8203
// sTank := true ;
8195: LD_ADDR_EXP 41
8199: PUSH
8200: LD_INT 1
8202: ST_TO_ADDR
// if p3 = 20 then
8203: LD_VAR 0 3
8207: PUSH
8208: LD_INT 20
8210: EQUAL
8211: IFFALSE 8221
// sRemote := true ;
8213: LD_ADDR_EXP 42
8217: PUSH
8218: LD_INT 1
8220: ST_TO_ADDR
// if p3 = 21 then
8221: LD_VAR 0 3
8225: PUSH
8226: LD_INT 21
8228: EQUAL
8229: IFFALSE 8239
// sPowell := true ;
8231: LD_ADDR_EXP 43
8235: PUSH
8236: LD_INT 1
8238: ST_TO_ADDR
// if p3 = 22 then
8239: LD_VAR 0 3
8243: PUSH
8244: LD_INT 22
8246: EQUAL
8247: IFFALSE 8257
// sTeleport := true ;
8249: LD_ADDR_EXP 46
8253: PUSH
8254: LD_INT 1
8256: ST_TO_ADDR
// if p3 = 23 then
8257: LD_VAR 0 3
8261: PUSH
8262: LD_INT 23
8264: EQUAL
8265: IFFALSE 8275
// sOilTower := true ;
8267: LD_ADDR_EXP 48
8271: PUSH
8272: LD_INT 1
8274: ST_TO_ADDR
// if p3 = 24 then
8275: LD_VAR 0 3
8279: PUSH
8280: LD_INT 24
8282: EQUAL
8283: IFFALSE 8293
// sShovel := true ;
8285: LD_ADDR_EXP 49
8289: PUSH
8290: LD_INT 1
8292: ST_TO_ADDR
// if p3 = 25 then
8293: LD_VAR 0 3
8297: PUSH
8298: LD_INT 25
8300: EQUAL
8301: IFFALSE 8311
// sSheik := true ;
8303: LD_ADDR_EXP 50
8307: PUSH
8308: LD_INT 1
8310: ST_TO_ADDR
// if p3 = 26 then
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 26
8318: EQUAL
8319: IFFALSE 8329
// sEarthquake := true ;
8321: LD_ADDR_EXP 52
8325: PUSH
8326: LD_INT 1
8328: ST_TO_ADDR
// if p3 = 27 then
8329: LD_VAR 0 3
8333: PUSH
8334: LD_INT 27
8336: EQUAL
8337: IFFALSE 8347
// sAI := true ;
8339: LD_ADDR_EXP 53
8343: PUSH
8344: LD_INT 1
8346: ST_TO_ADDR
// if p3 = 28 then
8347: LD_VAR 0 3
8351: PUSH
8352: LD_INT 28
8354: EQUAL
8355: IFFALSE 8365
// sCargo := true ;
8357: LD_ADDR_EXP 56
8361: PUSH
8362: LD_INT 1
8364: ST_TO_ADDR
// if p3 = 29 then
8365: LD_VAR 0 3
8369: PUSH
8370: LD_INT 29
8372: EQUAL
8373: IFFALSE 8383
// sDLaser := true ;
8375: LD_ADDR_EXP 57
8379: PUSH
8380: LD_INT 1
8382: ST_TO_ADDR
// if p3 = 30 then
8383: LD_VAR 0 3
8387: PUSH
8388: LD_INT 30
8390: EQUAL
8391: IFFALSE 8401
// sExchange := true ;
8393: LD_ADDR_EXP 58
8397: PUSH
8398: LD_INT 1
8400: ST_TO_ADDR
// if p3 = 31 then
8401: LD_VAR 0 3
8405: PUSH
8406: LD_INT 31
8408: EQUAL
8409: IFFALSE 8419
// sFac := true ;
8411: LD_ADDR_EXP 59
8415: PUSH
8416: LD_INT 1
8418: ST_TO_ADDR
// if p3 = 32 then
8419: LD_VAR 0 3
8423: PUSH
8424: LD_INT 32
8426: EQUAL
8427: IFFALSE 8437
// sPower := true ;
8429: LD_ADDR_EXP 60
8433: PUSH
8434: LD_INT 1
8436: ST_TO_ADDR
// if p3 = 33 then
8437: LD_VAR 0 3
8441: PUSH
8442: LD_INT 33
8444: EQUAL
8445: IFFALSE 8455
// sRandom := true ;
8447: LD_ADDR_EXP 61
8451: PUSH
8452: LD_INT 1
8454: ST_TO_ADDR
// if p3 = 34 then
8455: LD_VAR 0 3
8459: PUSH
8460: LD_INT 34
8462: EQUAL
8463: IFFALSE 8473
// sShield := true ;
8465: LD_ADDR_EXP 62
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// if p3 = 35 then
8473: LD_VAR 0 3
8477: PUSH
8478: LD_INT 35
8480: EQUAL
8481: IFFALSE 8491
// sTime := true ;
8483: LD_ADDR_EXP 63
8487: PUSH
8488: LD_INT 1
8490: ST_TO_ADDR
// if p3 = 36 then
8491: LD_VAR 0 3
8495: PUSH
8496: LD_INT 36
8498: EQUAL
8499: IFFALSE 8509
// sTools := true ;
8501: LD_ADDR_EXP 64
8505: PUSH
8506: LD_INT 1
8508: ST_TO_ADDR
// if p3 = 101 then
8509: LD_VAR 0 3
8513: PUSH
8514: LD_INT 101
8516: EQUAL
8517: IFFALSE 8527
// sSold := true ;
8519: LD_ADDR_EXP 29
8523: PUSH
8524: LD_INT 1
8526: ST_TO_ADDR
// if p3 = 102 then
8527: LD_VAR 0 3
8531: PUSH
8532: LD_INT 102
8534: EQUAL
8535: IFFALSE 8545
// sDiff := true ;
8537: LD_ADDR_EXP 30
8541: PUSH
8542: LD_INT 1
8544: ST_TO_ADDR
// if p3 = 103 then
8545: LD_VAR 0 3
8549: PUSH
8550: LD_INT 103
8552: EQUAL
8553: IFFALSE 8563
// sFog := true ;
8555: LD_ADDR_EXP 33
8559: PUSH
8560: LD_INT 1
8562: ST_TO_ADDR
// if p3 = 104 then
8563: LD_VAR 0 3
8567: PUSH
8568: LD_INT 104
8570: EQUAL
8571: IFFALSE 8581
// sReset := true ;
8573: LD_ADDR_EXP 34
8577: PUSH
8578: LD_INT 1
8580: ST_TO_ADDR
// if p3 = 105 then
8581: LD_VAR 0 3
8585: PUSH
8586: LD_INT 105
8588: EQUAL
8589: IFFALSE 8599
// sSun := true ;
8591: LD_ADDR_EXP 35
8595: PUSH
8596: LD_INT 1
8598: ST_TO_ADDR
// if p3 = 106 then
8599: LD_VAR 0 3
8603: PUSH
8604: LD_INT 106
8606: EQUAL
8607: IFFALSE 8617
// sTiger := true ;
8609: LD_ADDR_EXP 31
8613: PUSH
8614: LD_INT 1
8616: ST_TO_ADDR
// if p3 = 107 then
8617: LD_VAR 0 3
8621: PUSH
8622: LD_INT 107
8624: EQUAL
8625: IFFALSE 8635
// sBomb := true ;
8627: LD_ADDR_EXP 32
8631: PUSH
8632: LD_INT 1
8634: ST_TO_ADDR
// if p3 = 108 then
8635: LD_VAR 0 3
8639: PUSH
8640: LD_INT 108
8642: EQUAL
8643: IFFALSE 8653
// sWound := true ;
8645: LD_ADDR_EXP 40
8649: PUSH
8650: LD_INT 1
8652: ST_TO_ADDR
// if p3 = 109 then
8653: LD_VAR 0 3
8657: PUSH
8658: LD_INT 109
8660: EQUAL
8661: IFFALSE 8671
// sBetray := true ;
8663: LD_ADDR_EXP 44
8667: PUSH
8668: LD_INT 1
8670: ST_TO_ADDR
// if p3 = 110 then
8671: LD_VAR 0 3
8675: PUSH
8676: LD_INT 110
8678: EQUAL
8679: IFFALSE 8689
// sContamin := true ;
8681: LD_ADDR_EXP 45
8685: PUSH
8686: LD_INT 1
8688: ST_TO_ADDR
// if p3 = 111 then
8689: LD_VAR 0 3
8693: PUSH
8694: LD_INT 111
8696: EQUAL
8697: IFFALSE 8707
// sOil := true ;
8699: LD_ADDR_EXP 47
8703: PUSH
8704: LD_INT 1
8706: ST_TO_ADDR
// if p3 = 112 then
8707: LD_VAR 0 3
8711: PUSH
8712: LD_INT 112
8714: EQUAL
8715: IFFALSE 8725
// sStu := true ;
8717: LD_ADDR_EXP 51
8721: PUSH
8722: LD_INT 1
8724: ST_TO_ADDR
// if p3 = 113 then
8725: LD_VAR 0 3
8729: PUSH
8730: LD_INT 113
8732: EQUAL
8733: IFFALSE 8743
// sBazooka := true ;
8735: LD_ADDR_EXP 54
8739: PUSH
8740: LD_INT 1
8742: ST_TO_ADDR
// if p3 = 114 then
8743: LD_VAR 0 3
8747: PUSH
8748: LD_INT 114
8750: EQUAL
8751: IFFALSE 8761
// sMortar := true ;
8753: LD_ADDR_EXP 55
8757: PUSH
8758: LD_INT 1
8760: ST_TO_ADDR
// if p3 = 115 then
8761: LD_VAR 0 3
8765: PUSH
8766: LD_INT 115
8768: EQUAL
8769: IFFALSE 8779
// sRanger := true ;
8771: LD_ADDR_EXP 65
8775: PUSH
8776: LD_INT 1
8778: ST_TO_ADDR
// end ; end ;
8779: PPOPN 6
8781: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
8782: LD_EXP 12
8786: PUSH
8787: LD_EXP 17
8791: AND
8792: IFFALSE 8916
8794: GO 8796
8796: DISABLE
8797: LD_INT 0
8799: PPUSH
8800: PPUSH
// begin enable ;
8801: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8802: LD_ADDR_VAR 0 2
8806: PUSH
8807: LD_INT 22
8809: PUSH
8810: LD_OWVAR 2
8814: PUSH
8815: EMPTY
8816: LIST
8817: LIST
8818: PUSH
8819: LD_INT 2
8821: PUSH
8822: LD_INT 34
8824: PUSH
8825: LD_INT 7
8827: PUSH
8828: EMPTY
8829: LIST
8830: LIST
8831: PUSH
8832: LD_INT 34
8834: PUSH
8835: LD_INT 45
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: PUSH
8842: LD_INT 34
8844: PUSH
8845: LD_INT 28
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: PUSH
8852: LD_INT 34
8854: PUSH
8855: LD_INT 47
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: ST_TO_ADDR
// if not tmp then
8878: LD_VAR 0 2
8882: NOT
8883: IFFALSE 8887
// exit ;
8885: GO 8916
// for i in tmp do
8887: LD_ADDR_VAR 0 1
8891: PUSH
8892: LD_VAR 0 2
8896: PUSH
8897: FOR_IN
8898: IFFALSE 8914
// begin SetLives ( i , 0 ) ;
8900: LD_VAR 0 1
8904: PPUSH
8905: LD_INT 0
8907: PPUSH
8908: CALL_OW 234
// end ;
8912: GO 8897
8914: POP
8915: POP
// end ;
8916: PPOPN 2
8918: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8919: LD_EXP 12
8923: PUSH
8924: LD_EXP 18
8928: AND
8929: IFFALSE 9013
8931: GO 8933
8933: DISABLE
8934: LD_INT 0
8936: PPUSH
8937: PPUSH
// begin enable ;
8938: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
8939: LD_ADDR_VAR 0 2
8943: PUSH
8944: LD_INT 22
8946: PUSH
8947: LD_OWVAR 2
8951: PUSH
8952: EMPTY
8953: LIST
8954: LIST
8955: PUSH
8956: LD_INT 32
8958: PUSH
8959: LD_INT 3
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: PPUSH
8970: CALL_OW 69
8974: ST_TO_ADDR
// if not tmp then
8975: LD_VAR 0 2
8979: NOT
8980: IFFALSE 8984
// exit ;
8982: GO 9013
// for i in tmp do
8984: LD_ADDR_VAR 0 1
8988: PUSH
8989: LD_VAR 0 2
8993: PUSH
8994: FOR_IN
8995: IFFALSE 9011
// begin SetLives ( i , 0 ) ;
8997: LD_VAR 0 1
9001: PPUSH
9002: LD_INT 0
9004: PPUSH
9005: CALL_OW 234
// end ;
9009: GO 8994
9011: POP
9012: POP
// end ;
9013: PPOPN 2
9015: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9016: LD_EXP 12
9020: PUSH
9021: LD_EXP 15
9025: AND
9026: IFFALSE 9119
9028: GO 9030
9030: DISABLE
9031: LD_INT 0
9033: PPUSH
// begin enable ;
9034: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: LD_INT 22
9042: PUSH
9043: LD_OWVAR 2
9047: PUSH
9048: EMPTY
9049: LIST
9050: LIST
9051: PUSH
9052: LD_INT 2
9054: PUSH
9055: LD_INT 25
9057: PUSH
9058: LD_INT 5
9060: PUSH
9061: EMPTY
9062: LIST
9063: LIST
9064: PUSH
9065: LD_INT 25
9067: PUSH
9068: LD_INT 9
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: PUSH
9075: LD_INT 25
9077: PUSH
9078: LD_INT 8
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: PUSH
9085: EMPTY
9086: LIST
9087: LIST
9088: LIST
9089: LIST
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: PPUSH
9095: CALL_OW 69
9099: PUSH
9100: FOR_IN
9101: IFFALSE 9117
// begin SetClass ( i , 1 ) ;
9103: LD_VAR 0 1
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 336
// end ;
9115: GO 9100
9117: POP
9118: POP
// end ;
9119: PPOPN 1
9121: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9122: LD_EXP 12
9126: PUSH
9127: LD_EXP 16
9131: AND
9132: PUSH
9133: LD_OWVAR 65
9137: PUSH
9138: LD_INT 7
9140: LESS
9141: AND
9142: IFFALSE 9156
9144: GO 9146
9146: DISABLE
// begin enable ;
9147: ENABLE
// game_speed := 7 ;
9148: LD_ADDR_OWVAR 65
9152: PUSH
9153: LD_INT 7
9155: ST_TO_ADDR
// end ;
9156: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9157: LD_EXP 12
9161: PUSH
9162: LD_EXP 19
9166: AND
9167: IFFALSE 9369
9169: GO 9171
9171: DISABLE
9172: LD_INT 0
9174: PPUSH
9175: PPUSH
9176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9177: LD_ADDR_VAR 0 3
9181: PUSH
9182: LD_INT 81
9184: PUSH
9185: LD_OWVAR 2
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PUSH
9194: LD_INT 21
9196: PUSH
9197: LD_INT 1
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: PUSH
9204: EMPTY
9205: LIST
9206: LIST
9207: PPUSH
9208: CALL_OW 69
9212: ST_TO_ADDR
// if not tmp then
9213: LD_VAR 0 3
9217: NOT
9218: IFFALSE 9222
// exit ;
9220: GO 9369
// if tmp > 5 then
9222: LD_VAR 0 3
9226: PUSH
9227: LD_INT 5
9229: GREATER
9230: IFFALSE 9242
// k := 5 else
9232: LD_ADDR_VAR 0 2
9236: PUSH
9237: LD_INT 5
9239: ST_TO_ADDR
9240: GO 9252
// k := tmp ;
9242: LD_ADDR_VAR 0 2
9246: PUSH
9247: LD_VAR 0 3
9251: ST_TO_ADDR
// for i := 1 to k do
9252: LD_ADDR_VAR 0 1
9256: PUSH
9257: DOUBLE
9258: LD_INT 1
9260: DEC
9261: ST_TO_ADDR
9262: LD_VAR 0 2
9266: PUSH
9267: FOR_TO
9268: IFFALSE 9367
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9270: LD_VAR 0 3
9274: PUSH
9275: LD_VAR 0 1
9279: ARRAY
9280: PPUSH
9281: LD_VAR 0 1
9285: PUSH
9286: LD_INT 4
9288: MOD
9289: PUSH
9290: LD_INT 1
9292: PLUS
9293: PPUSH
9294: CALL_OW 259
9298: PUSH
9299: LD_INT 10
9301: LESS
9302: IFFALSE 9365
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9304: LD_VAR 0 3
9308: PUSH
9309: LD_VAR 0 1
9313: ARRAY
9314: PPUSH
9315: LD_VAR 0 1
9319: PUSH
9320: LD_INT 4
9322: MOD
9323: PUSH
9324: LD_INT 1
9326: PLUS
9327: PPUSH
9328: LD_VAR 0 3
9332: PUSH
9333: LD_VAR 0 1
9337: ARRAY
9338: PPUSH
9339: LD_VAR 0 1
9343: PUSH
9344: LD_INT 4
9346: MOD
9347: PUSH
9348: LD_INT 1
9350: PLUS
9351: PPUSH
9352: CALL_OW 259
9356: PUSH
9357: LD_INT 1
9359: PLUS
9360: PPUSH
9361: CALL_OW 237
9365: GO 9267
9367: POP
9368: POP
// end ;
9369: PPOPN 3
9371: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9372: LD_EXP 12
9376: PUSH
9377: LD_EXP 20
9381: AND
9382: IFFALSE 9402
9384: GO 9386
9386: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9387: LD_INT 4
9389: PPUSH
9390: LD_OWVAR 2
9394: PPUSH
9395: LD_INT 0
9397: PPUSH
9398: CALL_OW 324
9402: END
// every 0 0$1 trigger StreamModeActive and sShovel do
9403: LD_EXP 12
9407: PUSH
9408: LD_EXP 49
9412: AND
9413: IFFALSE 9433
9415: GO 9417
9417: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
9418: LD_INT 19
9420: PPUSH
9421: LD_OWVAR 2
9425: PPUSH
9426: LD_INT 0
9428: PPUSH
9429: CALL_OW 324
9433: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9434: LD_EXP 12
9438: PUSH
9439: LD_EXP 21
9443: AND
9444: IFFALSE 9546
9446: GO 9448
9448: DISABLE
9449: LD_INT 0
9451: PPUSH
9452: PPUSH
// begin enable ;
9453: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9454: LD_ADDR_VAR 0 2
9458: PUSH
9459: LD_INT 22
9461: PUSH
9462: LD_OWVAR 2
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 2
9473: PUSH
9474: LD_INT 34
9476: PUSH
9477: LD_INT 11
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: PUSH
9484: LD_INT 34
9486: PUSH
9487: LD_INT 30
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: LIST
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PPUSH
9503: CALL_OW 69
9507: ST_TO_ADDR
// if not tmp then
9508: LD_VAR 0 2
9512: NOT
9513: IFFALSE 9517
// exit ;
9515: GO 9546
// for i in tmp do
9517: LD_ADDR_VAR 0 1
9521: PUSH
9522: LD_VAR 0 2
9526: PUSH
9527: FOR_IN
9528: IFFALSE 9544
// begin SetLives ( i , 0 ) ;
9530: LD_VAR 0 1
9534: PPUSH
9535: LD_INT 0
9537: PPUSH
9538: CALL_OW 234
// end ;
9542: GO 9527
9544: POP
9545: POP
// end ;
9546: PPOPN 2
9548: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9549: LD_EXP 12
9553: PUSH
9554: LD_EXP 22
9558: AND
9559: IFFALSE 9579
9561: GO 9563
9563: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9564: LD_INT 32
9566: PPUSH
9567: LD_OWVAR 2
9571: PPUSH
9572: LD_INT 0
9574: PPUSH
9575: CALL_OW 324
9579: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
9580: LD_EXP 12
9584: PUSH
9585: LD_EXP 23
9589: AND
9590: IFFALSE 9771
9592: GO 9594
9594: DISABLE
9595: LD_INT 0
9597: PPUSH
9598: PPUSH
9599: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
9600: LD_ADDR_VAR 0 2
9604: PUSH
9605: LD_INT 22
9607: PUSH
9608: LD_OWVAR 2
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PUSH
9617: LD_INT 33
9619: PUSH
9620: LD_INT 3
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: PPUSH
9631: CALL_OW 69
9635: ST_TO_ADDR
// if not tmp then
9636: LD_VAR 0 2
9640: NOT
9641: IFFALSE 9645
// exit ;
9643: GO 9771
// side := 0 ;
9645: LD_ADDR_VAR 0 3
9649: PUSH
9650: LD_INT 0
9652: ST_TO_ADDR
// for i := 1 to 8 do
9653: LD_ADDR_VAR 0 1
9657: PUSH
9658: DOUBLE
9659: LD_INT 1
9661: DEC
9662: ST_TO_ADDR
9663: LD_INT 8
9665: PUSH
9666: FOR_TO
9667: IFFALSE 9715
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
9669: LD_OWVAR 2
9673: PUSH
9674: LD_VAR 0 1
9678: NONEQUAL
9679: PUSH
9680: LD_OWVAR 2
9684: PPUSH
9685: LD_VAR 0 1
9689: PPUSH
9690: CALL_OW 81
9694: PUSH
9695: LD_INT 2
9697: EQUAL
9698: AND
9699: IFFALSE 9713
// begin side := i ;
9701: LD_ADDR_VAR 0 3
9705: PUSH
9706: LD_VAR 0 1
9710: ST_TO_ADDR
// break ;
9711: GO 9715
// end ;
9713: GO 9666
9715: POP
9716: POP
// if not side then
9717: LD_VAR 0 3
9721: NOT
9722: IFFALSE 9726
// exit ;
9724: GO 9771
// for i := 1 to tmp do
9726: LD_ADDR_VAR 0 1
9730: PUSH
9731: DOUBLE
9732: LD_INT 1
9734: DEC
9735: ST_TO_ADDR
9736: LD_VAR 0 2
9740: PUSH
9741: FOR_TO
9742: IFFALSE 9769
// if Prob ( 30 ) then
9744: LD_INT 30
9746: PPUSH
9747: CALL_OW 13
9751: IFFALSE 9767
// SetSide ( i , side ) ;
9753: LD_VAR 0 1
9757: PPUSH
9758: LD_VAR 0 3
9762: PPUSH
9763: CALL_OW 235
9767: GO 9741
9769: POP
9770: POP
// end ;
9771: PPOPN 3
9773: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
9774: LD_EXP 12
9778: PUSH
9779: LD_EXP 25
9783: AND
9784: IFFALSE 9903
9786: GO 9788
9788: DISABLE
9789: LD_INT 0
9791: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
9792: LD_ADDR_VAR 0 1
9796: PUSH
9797: LD_INT 22
9799: PUSH
9800: LD_OWVAR 2
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PUSH
9809: LD_INT 21
9811: PUSH
9812: LD_INT 1
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: LD_INT 23
9824: PUSH
9825: LD_INT 0
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: LIST
9840: PPUSH
9841: CALL_OW 69
9845: PUSH
9846: FOR_IN
9847: IFFALSE 9901
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
9849: LD_VAR 0 1
9853: PPUSH
9854: CALL_OW 257
9858: PUSH
9859: LD_INT 1
9861: PUSH
9862: LD_INT 2
9864: PUSH
9865: LD_INT 3
9867: PUSH
9868: LD_INT 4
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: IN
9877: IFFALSE 9899
// SetClass ( un , rand ( 1 , 4 ) ) ;
9879: LD_VAR 0 1
9883: PPUSH
9884: LD_INT 1
9886: PPUSH
9887: LD_INT 4
9889: PPUSH
9890: CALL_OW 12
9894: PPUSH
9895: CALL_OW 336
9899: GO 9846
9901: POP
9902: POP
// end ;
9903: PPOPN 1
9905: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9906: LD_EXP 12
9910: PUSH
9911: LD_EXP 24
9915: AND
9916: IFFALSE 9995
9918: GO 9920
9920: DISABLE
9921: LD_INT 0
9923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9924: LD_ADDR_VAR 0 1
9928: PUSH
9929: LD_INT 22
9931: PUSH
9932: LD_OWVAR 2
9936: PUSH
9937: EMPTY
9938: LIST
9939: LIST
9940: PUSH
9941: LD_INT 21
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: EMPTY
9948: LIST
9949: LIST
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: PPUSH
9955: CALL_OW 69
9959: ST_TO_ADDR
// if not tmp then
9960: LD_VAR 0 1
9964: NOT
9965: IFFALSE 9969
// exit ;
9967: GO 9995
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
9969: LD_VAR 0 1
9973: PUSH
9974: LD_INT 1
9976: PPUSH
9977: LD_VAR 0 1
9981: PPUSH
9982: CALL_OW 12
9986: ARRAY
9987: PPUSH
9988: LD_INT 100
9990: PPUSH
9991: CALL_OW 234
// end ;
9995: PPOPN 1
9997: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
9998: LD_EXP 12
10002: PUSH
10003: LD_EXP 26
10007: AND
10008: IFFALSE 10106
10010: GO 10012
10012: DISABLE
10013: LD_INT 0
10015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10016: LD_ADDR_VAR 0 1
10020: PUSH
10021: LD_INT 22
10023: PUSH
10024: LD_OWVAR 2
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PUSH
10033: LD_INT 21
10035: PUSH
10036: LD_INT 1
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PPUSH
10047: CALL_OW 69
10051: ST_TO_ADDR
// if not tmp then
10052: LD_VAR 0 1
10056: NOT
10057: IFFALSE 10061
// exit ;
10059: GO 10106
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 1
10068: PPUSH
10069: LD_VAR 0 1
10073: PPUSH
10074: CALL_OW 12
10078: ARRAY
10079: PPUSH
10080: LD_INT 1
10082: PPUSH
10083: LD_INT 4
10085: PPUSH
10086: CALL_OW 12
10090: PPUSH
10091: LD_INT 3000
10093: PPUSH
10094: LD_INT 9000
10096: PPUSH
10097: CALL_OW 12
10101: PPUSH
10102: CALL_OW 492
// end ;
10106: PPOPN 1
10108: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10109: LD_EXP 12
10113: PUSH
10114: LD_EXP 27
10118: AND
10119: IFFALSE 10139
10121: GO 10123
10123: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10124: LD_INT 1
10126: PPUSH
10127: LD_OWVAR 2
10131: PPUSH
10132: LD_INT 0
10134: PPUSH
10135: CALL_OW 324
10139: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10140: LD_EXP 12
10144: PUSH
10145: LD_EXP 28
10149: AND
10150: IFFALSE 10233
10152: GO 10154
10154: DISABLE
10155: LD_INT 0
10157: PPUSH
10158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10159: LD_ADDR_VAR 0 2
10163: PUSH
10164: LD_INT 22
10166: PUSH
10167: LD_OWVAR 2
10171: PUSH
10172: EMPTY
10173: LIST
10174: LIST
10175: PUSH
10176: LD_INT 21
10178: PUSH
10179: LD_INT 3
10181: PUSH
10182: EMPTY
10183: LIST
10184: LIST
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: PPUSH
10190: CALL_OW 69
10194: ST_TO_ADDR
// if not tmp then
10195: LD_VAR 0 2
10199: NOT
10200: IFFALSE 10204
// exit ;
10202: GO 10233
// for i in tmp do
10204: LD_ADDR_VAR 0 1
10208: PUSH
10209: LD_VAR 0 2
10213: PUSH
10214: FOR_IN
10215: IFFALSE 10231
// SetBLevel ( i , 10 ) ;
10217: LD_VAR 0 1
10221: PPUSH
10222: LD_INT 10
10224: PPUSH
10225: CALL_OW 241
10229: GO 10214
10231: POP
10232: POP
// end ;
10233: PPOPN 2
10235: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
10236: LD_EXP 12
10240: PUSH
10241: LD_EXP 29
10245: AND
10246: IFFALSE 10357
10248: GO 10250
10250: DISABLE
10251: LD_INT 0
10253: PPUSH
10254: PPUSH
10255: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10256: LD_ADDR_VAR 0 3
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_OWVAR 2
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: PUSH
10273: LD_INT 25
10275: PUSH
10276: LD_INT 1
10278: PUSH
10279: EMPTY
10280: LIST
10281: LIST
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PPUSH
10287: CALL_OW 69
10291: ST_TO_ADDR
// if not tmp then
10292: LD_VAR 0 3
10296: NOT
10297: IFFALSE 10301
// exit ;
10299: GO 10357
// un := tmp [ rand ( 1 , tmp ) ] ;
10301: LD_ADDR_VAR 0 2
10305: PUSH
10306: LD_VAR 0 3
10310: PUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_VAR 0 3
10318: PPUSH
10319: CALL_OW 12
10323: ARRAY
10324: ST_TO_ADDR
// if Crawls ( un ) then
10325: LD_VAR 0 2
10329: PPUSH
10330: CALL_OW 318
10334: IFFALSE 10345
// ComWalk ( un ) ;
10336: LD_VAR 0 2
10340: PPUSH
10341: CALL_OW 138
// SetClass ( un , class_sniper ) ;
10345: LD_VAR 0 2
10349: PPUSH
10350: LD_INT 5
10352: PPUSH
10353: CALL_OW 336
// end ;
10357: PPOPN 3
10359: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10360: LD_EXP 12
10364: PUSH
10365: LD_EXP 30
10369: AND
10370: PUSH
10371: LD_OWVAR 67
10375: PUSH
10376: LD_INT 3
10378: LESS
10379: AND
10380: IFFALSE 10399
10382: GO 10384
10384: DISABLE
// Difficulty := Difficulty + 1 ;
10385: LD_ADDR_OWVAR 67
10389: PUSH
10390: LD_OWVAR 67
10394: PUSH
10395: LD_INT 1
10397: PLUS
10398: ST_TO_ADDR
10399: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10400: LD_EXP 12
10404: PUSH
10405: LD_EXP 31
10409: AND
10410: IFFALSE 10513
10412: GO 10414
10414: DISABLE
10415: LD_INT 0
10417: PPUSH
// begin for i := 1 to 5 do
10418: LD_ADDR_VAR 0 1
10422: PUSH
10423: DOUBLE
10424: LD_INT 1
10426: DEC
10427: ST_TO_ADDR
10428: LD_INT 5
10430: PUSH
10431: FOR_TO
10432: IFFALSE 10511
// begin uc_nation := nation_nature ;
10434: LD_ADDR_OWVAR 21
10438: PUSH
10439: LD_INT 0
10441: ST_TO_ADDR
// uc_side := 0 ;
10442: LD_ADDR_OWVAR 20
10446: PUSH
10447: LD_INT 0
10449: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10450: LD_ADDR_OWVAR 29
10454: PUSH
10455: LD_INT 12
10457: PUSH
10458: LD_INT 12
10460: PUSH
10461: EMPTY
10462: LIST
10463: LIST
10464: ST_TO_ADDR
// hc_agressivity := 20 ;
10465: LD_ADDR_OWVAR 35
10469: PUSH
10470: LD_INT 20
10472: ST_TO_ADDR
// hc_class := class_tiger ;
10473: LD_ADDR_OWVAR 28
10477: PUSH
10478: LD_INT 14
10480: ST_TO_ADDR
// hc_gallery :=  ;
10481: LD_ADDR_OWVAR 33
10485: PUSH
10486: LD_STRING 
10488: ST_TO_ADDR
// hc_name :=  ;
10489: LD_ADDR_OWVAR 26
10493: PUSH
10494: LD_STRING 
10496: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10497: CALL_OW 44
10501: PPUSH
10502: LD_INT 0
10504: PPUSH
10505: CALL_OW 51
// end ;
10509: GO 10431
10511: POP
10512: POP
// end ;
10513: PPOPN 1
10515: END
// every 0 0$1 trigger StreamModeActive and sBomb do
10516: LD_EXP 12
10520: PUSH
10521: LD_EXP 32
10525: AND
10526: IFFALSE 10535
10528: GO 10530
10530: DISABLE
// StreamSibBomb ;
10531: CALL 10536 0 0
10535: END
// export function StreamSibBomb ; var i , x , y ; begin
10536: LD_INT 0
10538: PPUSH
10539: PPUSH
10540: PPUSH
10541: PPUSH
// result := false ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// for i := 1 to 16 do
10550: LD_ADDR_VAR 0 2
10554: PUSH
10555: DOUBLE
10556: LD_INT 1
10558: DEC
10559: ST_TO_ADDR
10560: LD_INT 16
10562: PUSH
10563: FOR_TO
10564: IFFALSE 10763
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10566: LD_ADDR_VAR 0 3
10570: PUSH
10571: LD_INT 10
10573: PUSH
10574: LD_INT 20
10576: PUSH
10577: LD_INT 30
10579: PUSH
10580: LD_INT 40
10582: PUSH
10583: LD_INT 50
10585: PUSH
10586: LD_INT 60
10588: PUSH
10589: LD_INT 70
10591: PUSH
10592: LD_INT 80
10594: PUSH
10595: LD_INT 90
10597: PUSH
10598: LD_INT 100
10600: PUSH
10601: LD_INT 110
10603: PUSH
10604: LD_INT 120
10606: PUSH
10607: LD_INT 130
10609: PUSH
10610: LD_INT 140
10612: PUSH
10613: LD_INT 150
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 1
10635: PPUSH
10636: LD_INT 15
10638: PPUSH
10639: CALL_OW 12
10643: ARRAY
10644: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10645: LD_ADDR_VAR 0 4
10649: PUSH
10650: LD_INT 10
10652: PUSH
10653: LD_INT 20
10655: PUSH
10656: LD_INT 30
10658: PUSH
10659: LD_INT 40
10661: PUSH
10662: LD_INT 50
10664: PUSH
10665: LD_INT 60
10667: PUSH
10668: LD_INT 70
10670: PUSH
10671: LD_INT 80
10673: PUSH
10674: LD_INT 90
10676: PUSH
10677: LD_INT 100
10679: PUSH
10680: LD_INT 110
10682: PUSH
10683: LD_INT 120
10685: PUSH
10686: LD_INT 130
10688: PUSH
10689: LD_INT 140
10691: PUSH
10692: LD_INT 150
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: LIST
10699: LIST
10700: LIST
10701: LIST
10702: LIST
10703: LIST
10704: LIST
10705: LIST
10706: LIST
10707: LIST
10708: LIST
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 1
10714: PPUSH
10715: LD_INT 15
10717: PPUSH
10718: CALL_OW 12
10722: ARRAY
10723: ST_TO_ADDR
// if ValidHex ( x , y ) then
10724: LD_VAR 0 3
10728: PPUSH
10729: LD_VAR 0 4
10733: PPUSH
10734: CALL_OW 488
10738: IFFALSE 10761
// begin result := [ x , y ] ;
10740: LD_ADDR_VAR 0 1
10744: PUSH
10745: LD_VAR 0 3
10749: PUSH
10750: LD_VAR 0 4
10754: PUSH
10755: EMPTY
10756: LIST
10757: LIST
10758: ST_TO_ADDR
// break ;
10759: GO 10763
// end ; end ;
10761: GO 10563
10763: POP
10764: POP
// if result then
10765: LD_VAR 0 1
10769: IFFALSE 10829
// begin ToLua ( playSibBomb() ) ;
10771: LD_STRING playSibBomb()
10773: PPUSH
10774: CALL_OW 559
// wait ( 0 0$14 ) ;
10778: LD_INT 490
10780: PPUSH
10781: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
10785: LD_VAR 0 1
10789: PUSH
10790: LD_INT 1
10792: ARRAY
10793: PPUSH
10794: LD_VAR 0 1
10798: PUSH
10799: LD_INT 2
10801: ARRAY
10802: PPUSH
10803: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10807: LD_VAR 0 1
10811: PUSH
10812: LD_INT 1
10814: ARRAY
10815: PPUSH
10816: LD_VAR 0 1
10820: PUSH
10821: LD_INT 2
10823: ARRAY
10824: PPUSH
10825: CALL_OW 429
// end ; end ;
10829: LD_VAR 0 1
10833: RET
// every 0 0$1 trigger StreamModeActive and sReset do
10834: LD_EXP 12
10838: PUSH
10839: LD_EXP 34
10843: AND
10844: IFFALSE 10856
10846: GO 10848
10848: DISABLE
// YouLost (  ) ;
10849: LD_STRING 
10851: PPUSH
10852: CALL_OW 104
10856: END
// every 0 0$1 trigger StreamModeActive and sFog do
10857: LD_EXP 12
10861: PUSH
10862: LD_EXP 33
10866: AND
10867: IFFALSE 10881
10869: GO 10871
10871: DISABLE
// FogOff ( your_side ) ;
10872: LD_OWVAR 2
10876: PPUSH
10877: CALL_OW 344
10881: END
// every 0 0$1 trigger StreamModeActive and sSun do
10882: LD_EXP 12
10886: PUSH
10887: LD_EXP 35
10891: AND
10892: IFFALSE 10920
10894: GO 10896
10896: DISABLE
// begin solar_recharge_percent := 0 ;
10897: LD_ADDR_OWVAR 79
10901: PUSH
10902: LD_INT 0
10904: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10905: LD_INT 10500
10907: PPUSH
10908: CALL_OW 67
// solar_recharge_percent := 100 ;
10912: LD_ADDR_OWVAR 79
10916: PUSH
10917: LD_INT 100
10919: ST_TO_ADDR
// end ;
10920: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
10921: LD_EXP 12
10925: PUSH
10926: LD_EXP 36
10930: AND
10931: IFFALSE 11170
10933: GO 10935
10935: DISABLE
10936: LD_INT 0
10938: PPUSH
10939: PPUSH
10940: PPUSH
// begin tmp := [ ] ;
10941: LD_ADDR_VAR 0 3
10945: PUSH
10946: EMPTY
10947: ST_TO_ADDR
// for i := 1 to 6 do
10948: LD_ADDR_VAR 0 1
10952: PUSH
10953: DOUBLE
10954: LD_INT 1
10956: DEC
10957: ST_TO_ADDR
10958: LD_INT 6
10960: PUSH
10961: FOR_TO
10962: IFFALSE 11067
// begin uc_nation := nation_nature ;
10964: LD_ADDR_OWVAR 21
10968: PUSH
10969: LD_INT 0
10971: ST_TO_ADDR
// uc_side := 0 ;
10972: LD_ADDR_OWVAR 20
10976: PUSH
10977: LD_INT 0
10979: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10980: LD_ADDR_OWVAR 29
10984: PUSH
10985: LD_INT 12
10987: PUSH
10988: LD_INT 12
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: ST_TO_ADDR
// hc_agressivity := 20 ;
10995: LD_ADDR_OWVAR 35
10999: PUSH
11000: LD_INT 20
11002: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11003: LD_ADDR_OWVAR 28
11007: PUSH
11008: LD_INT 17
11010: ST_TO_ADDR
// hc_gallery :=  ;
11011: LD_ADDR_OWVAR 33
11015: PUSH
11016: LD_STRING 
11018: ST_TO_ADDR
// hc_name :=  ;
11019: LD_ADDR_OWVAR 26
11023: PUSH
11024: LD_STRING 
11026: ST_TO_ADDR
// un := CreateHuman ;
11027: LD_ADDR_VAR 0 2
11031: PUSH
11032: CALL_OW 44
11036: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11037: LD_VAR 0 2
11041: PPUSH
11042: LD_INT 1
11044: PPUSH
11045: CALL_OW 51
// tmp := tmp ^ un ;
11049: LD_ADDR_VAR 0 3
11053: PUSH
11054: LD_VAR 0 3
11058: PUSH
11059: LD_VAR 0 2
11063: ADD
11064: ST_TO_ADDR
// end ;
11065: GO 10961
11067: POP
11068: POP
// repeat wait ( 0 0$1 ) ;
11069: LD_INT 35
11071: PPUSH
11072: CALL_OW 67
// for un in tmp do
11076: LD_ADDR_VAR 0 2
11080: PUSH
11081: LD_VAR 0 3
11085: PUSH
11086: FOR_IN
11087: IFFALSE 11161
// begin if IsDead ( un ) then
11089: LD_VAR 0 2
11093: PPUSH
11094: CALL_OW 301
11098: IFFALSE 11118
// begin tmp := tmp diff un ;
11100: LD_ADDR_VAR 0 3
11104: PUSH
11105: LD_VAR 0 3
11109: PUSH
11110: LD_VAR 0 2
11114: DIFF
11115: ST_TO_ADDR
// continue ;
11116: GO 11086
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11118: LD_VAR 0 2
11122: PPUSH
11123: LD_INT 3
11125: PUSH
11126: LD_INT 22
11128: PUSH
11129: LD_INT 0
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PPUSH
11145: LD_VAR 0 2
11149: PPUSH
11150: CALL_OW 74
11154: PPUSH
11155: CALL_OW 115
// end ;
11159: GO 11086
11161: POP
11162: POP
// until not tmp ;
11163: LD_VAR 0 3
11167: NOT
11168: IFFALSE 11069
// end ;
11170: PPOPN 3
11172: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11173: LD_EXP 12
11177: PUSH
11178: LD_EXP 37
11182: AND
11183: IFFALSE 11237
11185: GO 11187
11187: DISABLE
// begin ToLua ( displayTroll(); ) ;
11188: LD_STRING displayTroll();
11190: PPUSH
11191: CALL_OW 559
// wait ( 3 3$00 ) ;
11195: LD_INT 6300
11197: PPUSH
11198: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11202: LD_STRING hideTroll();
11204: PPUSH
11205: CALL_OW 559
// wait ( 1 1$00 ) ;
11209: LD_INT 2100
11211: PPUSH
11212: CALL_OW 67
// ToLua ( displayTroll(); ) ;
11216: LD_STRING displayTroll();
11218: PPUSH
11219: CALL_OW 559
// wait ( 1 1$00 ) ;
11223: LD_INT 2100
11225: PPUSH
11226: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11230: LD_STRING hideTroll();
11232: PPUSH
11233: CALL_OW 559
// end ;
11237: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11238: LD_EXP 12
11242: PUSH
11243: LD_EXP 38
11247: AND
11248: IFFALSE 11311
11250: GO 11252
11252: DISABLE
11253: LD_INT 0
11255: PPUSH
// begin p := 0 ;
11256: LD_ADDR_VAR 0 1
11260: PUSH
11261: LD_INT 0
11263: ST_TO_ADDR
// repeat game_speed := 1 ;
11264: LD_ADDR_OWVAR 65
11268: PUSH
11269: LD_INT 1
11271: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11272: LD_INT 35
11274: PPUSH
11275: CALL_OW 67
// p := p + 1 ;
11279: LD_ADDR_VAR 0 1
11283: PUSH
11284: LD_VAR 0 1
11288: PUSH
11289: LD_INT 1
11291: PLUS
11292: ST_TO_ADDR
// until p >= 60 ;
11293: LD_VAR 0 1
11297: PUSH
11298: LD_INT 60
11300: GREATEREQUAL
11301: IFFALSE 11264
// game_speed := 4 ;
11303: LD_ADDR_OWVAR 65
11307: PUSH
11308: LD_INT 4
11310: ST_TO_ADDR
// end ;
11311: PPOPN 1
11313: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11314: LD_EXP 12
11318: PUSH
11319: LD_EXP 39
11323: AND
11324: IFFALSE 11470
11326: GO 11328
11328: DISABLE
11329: LD_INT 0
11331: PPUSH
11332: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11333: LD_ADDR_VAR 0 1
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_OWVAR 2
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 30
11355: PUSH
11356: LD_INT 0
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 30
11365: PUSH
11366: LD_INT 1
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: PPUSH
11382: CALL_OW 69
11386: ST_TO_ADDR
// if not depot then
11387: LD_VAR 0 1
11391: NOT
11392: IFFALSE 11396
// exit ;
11394: GO 11470
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11396: LD_ADDR_VAR 0 2
11400: PUSH
11401: LD_VAR 0 1
11405: PUSH
11406: LD_INT 1
11408: PPUSH
11409: LD_VAR 0 1
11413: PPUSH
11414: CALL_OW 12
11418: ARRAY
11419: PPUSH
11420: CALL_OW 274
11424: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11425: LD_VAR 0 2
11429: PPUSH
11430: LD_INT 1
11432: PPUSH
11433: LD_INT 0
11435: PPUSH
11436: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11440: LD_VAR 0 2
11444: PPUSH
11445: LD_INT 2
11447: PPUSH
11448: LD_INT 0
11450: PPUSH
11451: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11455: LD_VAR 0 2
11459: PPUSH
11460: LD_INT 3
11462: PPUSH
11463: LD_INT 0
11465: PPUSH
11466: CALL_OW 277
// end ;
11470: PPOPN 2
11472: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
11473: LD_EXP 12
11477: PUSH
11478: LD_EXP 40
11482: AND
11483: IFFALSE 11580
11485: GO 11487
11487: DISABLE
11488: LD_INT 0
11490: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11491: LD_ADDR_VAR 0 1
11495: PUSH
11496: LD_INT 22
11498: PUSH
11499: LD_OWVAR 2
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: LD_INT 21
11510: PUSH
11511: LD_INT 1
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: PUSH
11518: LD_INT 3
11520: PUSH
11521: LD_INT 23
11523: PUSH
11524: LD_INT 0
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PUSH
11531: EMPTY
11532: LIST
11533: LIST
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: LIST
11539: PPUSH
11540: CALL_OW 69
11544: ST_TO_ADDR
// if not tmp then
11545: LD_VAR 0 1
11549: NOT
11550: IFFALSE 11554
// exit ;
11552: GO 11580
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11554: LD_VAR 0 1
11558: PUSH
11559: LD_INT 1
11561: PPUSH
11562: LD_VAR 0 1
11566: PPUSH
11567: CALL_OW 12
11571: ARRAY
11572: PPUSH
11573: LD_INT 200
11575: PPUSH
11576: CALL_OW 234
// end ;
11580: PPOPN 1
11582: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11583: LD_EXP 12
11587: PUSH
11588: LD_EXP 41
11592: AND
11593: IFFALSE 11672
11595: GO 11597
11597: DISABLE
11598: LD_INT 0
11600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11601: LD_ADDR_VAR 0 1
11605: PUSH
11606: LD_INT 22
11608: PUSH
11609: LD_OWVAR 2
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: PUSH
11618: LD_INT 21
11620: PUSH
11621: LD_INT 2
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PPUSH
11632: CALL_OW 69
11636: ST_TO_ADDR
// if not tmp then
11637: LD_VAR 0 1
11641: NOT
11642: IFFALSE 11646
// exit ;
11644: GO 11672
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
11646: LD_VAR 0 1
11650: PUSH
11651: LD_INT 1
11653: PPUSH
11654: LD_VAR 0 1
11658: PPUSH
11659: CALL_OW 12
11663: ARRAY
11664: PPUSH
11665: LD_INT 60
11667: PPUSH
11668: CALL_OW 234
// end ;
11672: PPOPN 1
11674: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11675: LD_EXP 12
11679: PUSH
11680: LD_EXP 42
11684: AND
11685: IFFALSE 11784
11687: GO 11689
11689: DISABLE
11690: LD_INT 0
11692: PPUSH
11693: PPUSH
// begin enable ;
11694: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11695: LD_ADDR_VAR 0 1
11699: PUSH
11700: LD_INT 22
11702: PUSH
11703: LD_OWVAR 2
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: PUSH
11712: LD_INT 61
11714: PUSH
11715: EMPTY
11716: LIST
11717: PUSH
11718: LD_INT 33
11720: PUSH
11721: LD_INT 2
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: LIST
11732: PPUSH
11733: CALL_OW 69
11737: ST_TO_ADDR
// if not tmp then
11738: LD_VAR 0 1
11742: NOT
11743: IFFALSE 11747
// exit ;
11745: GO 11784
// for i in tmp do
11747: LD_ADDR_VAR 0 2
11751: PUSH
11752: LD_VAR 0 1
11756: PUSH
11757: FOR_IN
11758: IFFALSE 11782
// if IsControledBy ( i ) then
11760: LD_VAR 0 2
11764: PPUSH
11765: CALL_OW 312
11769: IFFALSE 11780
// ComUnlink ( i ) ;
11771: LD_VAR 0 2
11775: PPUSH
11776: CALL_OW 136
11780: GO 11757
11782: POP
11783: POP
// end ;
11784: PPOPN 2
11786: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
11787: LD_EXP 12
11791: PUSH
11792: LD_EXP 43
11796: AND
11797: IFFALSE 11931
11799: GO 11801
11801: DISABLE
11802: LD_INT 0
11804: PPUSH
11805: PPUSH
// begin ToLua ( displayPowell(); ) ;
11806: LD_STRING displayPowell();
11808: PPUSH
11809: CALL_OW 559
// uc_side := 0 ;
11813: LD_ADDR_OWVAR 20
11817: PUSH
11818: LD_INT 0
11820: ST_TO_ADDR
// uc_nation := 2 ;
11821: LD_ADDR_OWVAR 21
11825: PUSH
11826: LD_INT 2
11828: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
11829: LD_ADDR_OWVAR 37
11833: PUSH
11834: LD_INT 14
11836: ST_TO_ADDR
// vc_engine := engine_siberite ;
11837: LD_ADDR_OWVAR 39
11841: PUSH
11842: LD_INT 3
11844: ST_TO_ADDR
// vc_control := control_apeman ;
11845: LD_ADDR_OWVAR 38
11849: PUSH
11850: LD_INT 5
11852: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
11853: LD_ADDR_OWVAR 40
11857: PUSH
11858: LD_INT 29
11860: ST_TO_ADDR
// un := CreateVehicle ;
11861: LD_ADDR_VAR 0 2
11865: PUSH
11866: CALL_OW 45
11870: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11871: LD_VAR 0 2
11875: PPUSH
11876: LD_INT 1
11878: PPUSH
11879: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11883: LD_INT 35
11885: PPUSH
11886: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
11890: LD_VAR 0 2
11894: PPUSH
11895: LD_OWVAR 3
11899: PUSH
11900: LD_VAR 0 2
11904: DIFF
11905: PPUSH
11906: LD_VAR 0 2
11910: PPUSH
11911: CALL_OW 74
11915: PPUSH
11916: CALL_OW 115
// until IsOk ( un ) ;
11920: LD_VAR 0 2
11924: PPUSH
11925: CALL_OW 302
11929: IFFALSE 11883
// end ;
11931: PPOPN 2
11933: END
// every 0 0$1 trigger StreamModeActive and sStu do
11934: LD_EXP 12
11938: PUSH
11939: LD_EXP 51
11943: AND
11944: IFFALSE 11956
11946: GO 11948
11948: DISABLE
// begin ToLua ( displayStucuk(); ) ;
11949: LD_STRING displayStucuk();
11951: PPUSH
11952: CALL_OW 559
// end ;
11956: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
11957: LD_EXP 12
11961: PUSH
11962: LD_EXP 44
11966: AND
11967: IFFALSE 12108
11969: GO 11971
11971: DISABLE
11972: LD_INT 0
11974: PPUSH
11975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
11976: LD_ADDR_VAR 0 2
11980: PUSH
11981: LD_INT 22
11983: PUSH
11984: LD_OWVAR 2
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: PUSH
11993: LD_INT 21
11995: PUSH
11996: LD_INT 1
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PPUSH
12007: CALL_OW 69
12011: ST_TO_ADDR
// if not tmp then
12012: LD_VAR 0 2
12016: NOT
12017: IFFALSE 12021
// exit ;
12019: GO 12108
// un := tmp [ rand ( 1 , tmp ) ] ;
12021: LD_ADDR_VAR 0 1
12025: PUSH
12026: LD_VAR 0 2
12030: PUSH
12031: LD_INT 1
12033: PPUSH
12034: LD_VAR 0 2
12038: PPUSH
12039: CALL_OW 12
12043: ARRAY
12044: ST_TO_ADDR
// SetSide ( un , 0 ) ;
12045: LD_VAR 0 1
12049: PPUSH
12050: LD_INT 0
12052: PPUSH
12053: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
12057: LD_VAR 0 1
12061: PPUSH
12062: LD_OWVAR 3
12066: PUSH
12067: LD_VAR 0 1
12071: DIFF
12072: PPUSH
12073: LD_VAR 0 1
12077: PPUSH
12078: CALL_OW 74
12082: PPUSH
12083: CALL_OW 115
// wait ( 0 0$20 ) ;
12087: LD_INT 700
12089: PPUSH
12090: CALL_OW 67
// SetSide ( un , your_side ) ;
12094: LD_VAR 0 1
12098: PPUSH
12099: LD_OWVAR 2
12103: PPUSH
12104: CALL_OW 235
// end ;
12108: PPOPN 2
12110: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
12111: LD_EXP 12
12115: PUSH
12116: LD_EXP 45
12120: AND
12121: IFFALSE 12227
12123: GO 12125
12125: DISABLE
12126: LD_INT 0
12128: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12129: LD_ADDR_VAR 0 1
12133: PUSH
12134: LD_INT 22
12136: PUSH
12137: LD_OWVAR 2
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PUSH
12146: LD_INT 2
12148: PUSH
12149: LD_INT 30
12151: PUSH
12152: LD_INT 0
12154: PUSH
12155: EMPTY
12156: LIST
12157: LIST
12158: PUSH
12159: LD_INT 30
12161: PUSH
12162: LD_INT 1
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: EMPTY
12170: LIST
12171: LIST
12172: LIST
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PPUSH
12178: CALL_OW 69
12182: ST_TO_ADDR
// if not depot then
12183: LD_VAR 0 1
12187: NOT
12188: IFFALSE 12192
// exit ;
12190: GO 12227
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
12192: LD_VAR 0 1
12196: PUSH
12197: LD_INT 1
12199: ARRAY
12200: PPUSH
12201: CALL_OW 250
12205: PPUSH
12206: LD_VAR 0 1
12210: PUSH
12211: LD_INT 1
12213: ARRAY
12214: PPUSH
12215: CALL_OW 251
12219: PPUSH
12220: LD_INT 70
12222: PPUSH
12223: CALL_OW 495
// end ;
12227: PPOPN 1
12229: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
12230: LD_EXP 12
12234: PUSH
12235: LD_EXP 46
12239: AND
12240: IFFALSE 12451
12242: GO 12244
12244: DISABLE
12245: LD_INT 0
12247: PPUSH
12248: PPUSH
12249: PPUSH
12250: PPUSH
12251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12252: LD_ADDR_VAR 0 5
12256: PUSH
12257: LD_INT 22
12259: PUSH
12260: LD_OWVAR 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PUSH
12269: LD_INT 21
12271: PUSH
12272: LD_INT 1
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: PPUSH
12283: CALL_OW 69
12287: ST_TO_ADDR
// if not tmp then
12288: LD_VAR 0 5
12292: NOT
12293: IFFALSE 12297
// exit ;
12295: GO 12451
// for i in tmp do
12297: LD_ADDR_VAR 0 1
12301: PUSH
12302: LD_VAR 0 5
12306: PUSH
12307: FOR_IN
12308: IFFALSE 12449
// begin d := rand ( 0 , 5 ) ;
12310: LD_ADDR_VAR 0 4
12314: PUSH
12315: LD_INT 0
12317: PPUSH
12318: LD_INT 5
12320: PPUSH
12321: CALL_OW 12
12325: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
12326: LD_ADDR_VAR 0 2
12330: PUSH
12331: LD_VAR 0 1
12335: PPUSH
12336: CALL_OW 250
12340: PPUSH
12341: LD_VAR 0 4
12345: PPUSH
12346: LD_INT 3
12348: PPUSH
12349: LD_INT 12
12351: PPUSH
12352: CALL_OW 12
12356: PPUSH
12357: CALL_OW 272
12361: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
12362: LD_ADDR_VAR 0 3
12366: PUSH
12367: LD_VAR 0 1
12371: PPUSH
12372: CALL_OW 251
12376: PPUSH
12377: LD_VAR 0 4
12381: PPUSH
12382: LD_INT 3
12384: PPUSH
12385: LD_INT 12
12387: PPUSH
12388: CALL_OW 12
12392: PPUSH
12393: CALL_OW 273
12397: ST_TO_ADDR
// if ValidHex ( x , y ) then
12398: LD_VAR 0 2
12402: PPUSH
12403: LD_VAR 0 3
12407: PPUSH
12408: CALL_OW 488
12412: IFFALSE 12447
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
12414: LD_VAR 0 1
12418: PPUSH
12419: LD_VAR 0 2
12423: PPUSH
12424: LD_VAR 0 3
12428: PPUSH
12429: LD_INT 3
12431: PPUSH
12432: LD_INT 6
12434: PPUSH
12435: CALL_OW 12
12439: PPUSH
12440: LD_INT 1
12442: PPUSH
12443: CALL_OW 483
// end ;
12447: GO 12307
12449: POP
12450: POP
// end ;
12451: PPOPN 5
12453: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
12454: LD_EXP 12
12458: PUSH
12459: LD_EXP 47
12463: AND
12464: IFFALSE 12558
12466: GO 12468
12468: DISABLE
12469: LD_INT 0
12471: PPUSH
12472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
12473: LD_ADDR_VAR 0 2
12477: PUSH
12478: LD_INT 22
12480: PUSH
12481: LD_OWVAR 2
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 32
12492: PUSH
12493: LD_INT 1
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: LD_INT 21
12502: PUSH
12503: LD_INT 2
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: LIST
12514: PPUSH
12515: CALL_OW 69
12519: ST_TO_ADDR
// if not tmp then
12520: LD_VAR 0 2
12524: NOT
12525: IFFALSE 12529
// exit ;
12527: GO 12558
// for i in tmp do
12529: LD_ADDR_VAR 0 1
12533: PUSH
12534: LD_VAR 0 2
12538: PUSH
12539: FOR_IN
12540: IFFALSE 12556
// SetFuel ( i , 0 ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: LD_INT 0
12549: PPUSH
12550: CALL_OW 240
12554: GO 12539
12556: POP
12557: POP
// end ;
12558: PPOPN 2
12560: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
12561: LD_EXP 12
12565: PUSH
12566: LD_EXP 48
12570: AND
12571: IFFALSE 12637
12573: GO 12575
12575: DISABLE
12576: LD_INT 0
12578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12579: LD_ADDR_VAR 0 1
12583: PUSH
12584: LD_INT 22
12586: PUSH
12587: LD_OWVAR 2
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: LD_INT 30
12598: PUSH
12599: LD_INT 29
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: PPUSH
12610: CALL_OW 69
12614: ST_TO_ADDR
// if not tmp then
12615: LD_VAR 0 1
12619: NOT
12620: IFFALSE 12624
// exit ;
12622: GO 12637
// DestroyUnit ( tmp [ 1 ] ) ;
12624: LD_VAR 0 1
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 65
// end ;
12637: PPOPN 1
12639: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
12640: LD_EXP 12
12644: PUSH
12645: LD_EXP 50
12649: AND
12650: IFFALSE 12779
12652: GO 12654
12654: DISABLE
12655: LD_INT 0
12657: PPUSH
// begin uc_side := 0 ;
12658: LD_ADDR_OWVAR 20
12662: PUSH
12663: LD_INT 0
12665: ST_TO_ADDR
// uc_nation := nation_arabian ;
12666: LD_ADDR_OWVAR 21
12670: PUSH
12671: LD_INT 2
12673: ST_TO_ADDR
// hc_gallery :=  ;
12674: LD_ADDR_OWVAR 33
12678: PUSH
12679: LD_STRING 
12681: ST_TO_ADDR
// hc_name :=  ;
12682: LD_ADDR_OWVAR 26
12686: PUSH
12687: LD_STRING 
12689: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
12690: LD_INT 1
12692: PPUSH
12693: LD_INT 11
12695: PPUSH
12696: LD_INT 10
12698: PPUSH
12699: CALL_OW 380
// un := CreateHuman ;
12703: LD_ADDR_VAR 0 1
12707: PUSH
12708: CALL_OW 44
12712: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12713: LD_VAR 0 1
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12725: LD_INT 35
12727: PPUSH
12728: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12732: LD_VAR 0 1
12736: PPUSH
12737: LD_INT 22
12739: PUSH
12740: LD_OWVAR 2
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PPUSH
12749: CALL_OW 69
12753: PPUSH
12754: LD_VAR 0 1
12758: PPUSH
12759: CALL_OW 74
12763: PPUSH
12764: CALL_OW 115
// until IsDead ( un ) ;
12768: LD_VAR 0 1
12772: PPUSH
12773: CALL_OW 301
12777: IFFALSE 12725
// end ;
12779: PPOPN 1
12781: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
12782: LD_EXP 12
12786: PUSH
12787: LD_EXP 52
12791: AND
12792: IFFALSE 12804
12794: GO 12796
12796: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
12797: LD_STRING earthquake(getX(game), 0, 32)
12799: PPUSH
12800: CALL_OW 559
12804: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
12805: LD_EXP 12
12809: PUSH
12810: LD_EXP 53
12814: AND
12815: IFFALSE 12906
12817: GO 12819
12819: DISABLE
12820: LD_INT 0
12822: PPUSH
// begin enable ;
12823: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
12824: LD_ADDR_VAR 0 1
12828: PUSH
12829: LD_INT 22
12831: PUSH
12832: LD_OWVAR 2
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 21
12843: PUSH
12844: LD_INT 2
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 33
12853: PUSH
12854: LD_INT 3
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: LIST
12865: PPUSH
12866: CALL_OW 69
12870: ST_TO_ADDR
// if not tmp then
12871: LD_VAR 0 1
12875: NOT
12876: IFFALSE 12880
// exit ;
12878: GO 12906
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
12880: LD_VAR 0 1
12884: PUSH
12885: LD_INT 1
12887: PPUSH
12888: LD_VAR 0 1
12892: PPUSH
12893: CALL_OW 12
12897: ARRAY
12898: PPUSH
12899: LD_INT 1
12901: PPUSH
12902: CALL_OW 234
// end ;
12906: PPOPN 1
12908: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
12909: LD_EXP 12
12913: PUSH
12914: LD_EXP 54
12918: AND
12919: IFFALSE 13060
12921: GO 12923
12923: DISABLE
12924: LD_INT 0
12926: PPUSH
12927: PPUSH
12928: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12929: LD_ADDR_VAR 0 3
12933: PUSH
12934: LD_INT 22
12936: PUSH
12937: LD_OWVAR 2
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 25
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PPUSH
12960: CALL_OW 69
12964: ST_TO_ADDR
// if not tmp then
12965: LD_VAR 0 3
12969: NOT
12970: IFFALSE 12974
// exit ;
12972: GO 13060
// un := tmp [ rand ( 1 , tmp ) ] ;
12974: LD_ADDR_VAR 0 2
12978: PUSH
12979: LD_VAR 0 3
12983: PUSH
12984: LD_INT 1
12986: PPUSH
12987: LD_VAR 0 3
12991: PPUSH
12992: CALL_OW 12
12996: ARRAY
12997: ST_TO_ADDR
// if Crawls ( un ) then
12998: LD_VAR 0 2
13002: PPUSH
13003: CALL_OW 318
13007: IFFALSE 13018
// ComWalk ( un ) ;
13009: LD_VAR 0 2
13013: PPUSH
13014: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
13018: LD_VAR 0 2
13022: PPUSH
13023: LD_INT 9
13025: PPUSH
13026: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
13030: LD_INT 28
13032: PPUSH
13033: LD_OWVAR 2
13037: PPUSH
13038: LD_INT 2
13040: PPUSH
13041: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
13045: LD_INT 29
13047: PPUSH
13048: LD_OWVAR 2
13052: PPUSH
13053: LD_INT 2
13055: PPUSH
13056: CALL_OW 322
// end ;
13060: PPOPN 3
13062: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
13063: LD_EXP 12
13067: PUSH
13068: LD_EXP 55
13072: AND
13073: IFFALSE 13184
13075: GO 13077
13077: DISABLE
13078: LD_INT 0
13080: PPUSH
13081: PPUSH
13082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13083: LD_ADDR_VAR 0 3
13087: PUSH
13088: LD_INT 22
13090: PUSH
13091: LD_OWVAR 2
13095: PUSH
13096: EMPTY
13097: LIST
13098: LIST
13099: PUSH
13100: LD_INT 25
13102: PUSH
13103: LD_INT 1
13105: PUSH
13106: EMPTY
13107: LIST
13108: LIST
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: PPUSH
13114: CALL_OW 69
13118: ST_TO_ADDR
// if not tmp then
13119: LD_VAR 0 3
13123: NOT
13124: IFFALSE 13128
// exit ;
13126: GO 13184
// un := tmp [ rand ( 1 , tmp ) ] ;
13128: LD_ADDR_VAR 0 2
13132: PUSH
13133: LD_VAR 0 3
13137: PUSH
13138: LD_INT 1
13140: PPUSH
13141: LD_VAR 0 3
13145: PPUSH
13146: CALL_OW 12
13150: ARRAY
13151: ST_TO_ADDR
// if Crawls ( un ) then
13152: LD_VAR 0 2
13156: PPUSH
13157: CALL_OW 318
13161: IFFALSE 13172
// ComWalk ( un ) ;
13163: LD_VAR 0 2
13167: PPUSH
13168: CALL_OW 138
// SetClass ( un , class_mortar ) ;
13172: LD_VAR 0 2
13176: PPUSH
13177: LD_INT 8
13179: PPUSH
13180: CALL_OW 336
// end ;
13184: PPOPN 3
13186: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
13187: LD_EXP 12
13191: PUSH
13192: LD_EXP 56
13196: AND
13197: IFFALSE 13341
13199: GO 13201
13201: DISABLE
13202: LD_INT 0
13204: PPUSH
13205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
13206: LD_ADDR_VAR 0 2
13210: PUSH
13211: LD_INT 22
13213: PUSH
13214: LD_OWVAR 2
13218: PUSH
13219: EMPTY
13220: LIST
13221: LIST
13222: PUSH
13223: LD_INT 21
13225: PUSH
13226: LD_INT 2
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: PUSH
13233: LD_INT 2
13235: PUSH
13236: LD_INT 34
13238: PUSH
13239: LD_INT 12
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: LD_INT 34
13248: PUSH
13249: LD_INT 51
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: LD_INT 34
13258: PUSH
13259: LD_INT 32
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: PPUSH
13277: CALL_OW 69
13281: ST_TO_ADDR
// if not tmp then
13282: LD_VAR 0 2
13286: NOT
13287: IFFALSE 13291
// exit ;
13289: GO 13341
// for i in tmp do
13291: LD_ADDR_VAR 0 1
13295: PUSH
13296: LD_VAR 0 2
13300: PUSH
13301: FOR_IN
13302: IFFALSE 13339
// if GetCargo ( i , mat_artifact ) = 0 then
13304: LD_VAR 0 1
13308: PPUSH
13309: LD_INT 4
13311: PPUSH
13312: CALL_OW 289
13316: PUSH
13317: LD_INT 0
13319: EQUAL
13320: IFFALSE 13337
// SetCargo ( i , mat_siberit , 100 ) ;
13322: LD_VAR 0 1
13326: PPUSH
13327: LD_INT 3
13329: PPUSH
13330: LD_INT 100
13332: PPUSH
13333: CALL_OW 290
13337: GO 13301
13339: POP
13340: POP
// end ;
13341: PPOPN 2
13343: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
13344: LD_EXP 12
13348: PUSH
13349: LD_EXP 57
13353: AND
13354: IFFALSE 13507
13356: GO 13358
13358: DISABLE
13359: LD_INT 0
13361: PPUSH
13362: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
13363: LD_ADDR_VAR 0 2
13367: PUSH
13368: LD_INT 22
13370: PUSH
13371: LD_OWVAR 2
13375: PUSH
13376: EMPTY
13377: LIST
13378: LIST
13379: PPUSH
13380: CALL_OW 69
13384: ST_TO_ADDR
// if not tmp then
13385: LD_VAR 0 2
13389: NOT
13390: IFFALSE 13394
// exit ;
13392: GO 13507
// for i := 1 to 2 do
13394: LD_ADDR_VAR 0 1
13398: PUSH
13399: DOUBLE
13400: LD_INT 1
13402: DEC
13403: ST_TO_ADDR
13404: LD_INT 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13505
// begin uc_side := your_side ;
13410: LD_ADDR_OWVAR 20
13414: PUSH
13415: LD_OWVAR 2
13419: ST_TO_ADDR
// uc_nation := nation_american ;
13420: LD_ADDR_OWVAR 21
13424: PUSH
13425: LD_INT 1
13427: ST_TO_ADDR
// vc_chassis := us_morphling ;
13428: LD_ADDR_OWVAR 37
13432: PUSH
13433: LD_INT 5
13435: ST_TO_ADDR
// vc_engine := engine_siberite ;
13436: LD_ADDR_OWVAR 39
13440: PUSH
13441: LD_INT 3
13443: ST_TO_ADDR
// vc_control := control_computer ;
13444: LD_ADDR_OWVAR 38
13448: PUSH
13449: LD_INT 3
13451: ST_TO_ADDR
// vc_weapon := us_double_laser ;
13452: LD_ADDR_OWVAR 40
13456: PUSH
13457: LD_INT 10
13459: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
13460: CALL_OW 45
13464: PPUSH
13465: LD_VAR 0 2
13469: PUSH
13470: LD_INT 1
13472: ARRAY
13473: PPUSH
13474: CALL_OW 250
13478: PPUSH
13479: LD_VAR 0 2
13483: PUSH
13484: LD_INT 1
13486: ARRAY
13487: PPUSH
13488: CALL_OW 251
13492: PPUSH
13493: LD_INT 12
13495: PPUSH
13496: LD_INT 1
13498: PPUSH
13499: CALL_OW 50
// end ;
13503: GO 13407
13505: POP
13506: POP
// end ;
13507: PPOPN 2
13509: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
13510: LD_EXP 12
13514: PUSH
13515: LD_EXP 58
13519: AND
13520: IFFALSE 13742
13522: GO 13524
13524: DISABLE
13525: LD_INT 0
13527: PPUSH
13528: PPUSH
13529: PPUSH
13530: PPUSH
13531: PPUSH
13532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13533: LD_ADDR_VAR 0 6
13537: PUSH
13538: LD_INT 22
13540: PUSH
13541: LD_OWVAR 2
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PUSH
13550: LD_INT 21
13552: PUSH
13553: LD_INT 1
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PUSH
13560: LD_INT 3
13562: PUSH
13563: LD_INT 23
13565: PUSH
13566: LD_INT 0
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: LIST
13581: PPUSH
13582: CALL_OW 69
13586: ST_TO_ADDR
// if not tmp then
13587: LD_VAR 0 6
13591: NOT
13592: IFFALSE 13596
// exit ;
13594: GO 13742
// s1 := rand ( 1 , 4 ) ;
13596: LD_ADDR_VAR 0 2
13600: PUSH
13601: LD_INT 1
13603: PPUSH
13604: LD_INT 4
13606: PPUSH
13607: CALL_OW 12
13611: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
13612: LD_ADDR_VAR 0 4
13616: PUSH
13617: LD_VAR 0 6
13621: PUSH
13622: LD_INT 1
13624: ARRAY
13625: PPUSH
13626: LD_VAR 0 2
13630: PPUSH
13631: CALL_OW 259
13635: ST_TO_ADDR
// if s1 = 1 then
13636: LD_VAR 0 2
13640: PUSH
13641: LD_INT 1
13643: EQUAL
13644: IFFALSE 13664
// s2 := rand ( 2 , 4 ) else
13646: LD_ADDR_VAR 0 3
13650: PUSH
13651: LD_INT 2
13653: PPUSH
13654: LD_INT 4
13656: PPUSH
13657: CALL_OW 12
13661: ST_TO_ADDR
13662: GO 13672
// s2 := 1 ;
13664: LD_ADDR_VAR 0 3
13668: PUSH
13669: LD_INT 1
13671: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
13672: LD_ADDR_VAR 0 5
13676: PUSH
13677: LD_VAR 0 6
13681: PUSH
13682: LD_INT 1
13684: ARRAY
13685: PPUSH
13686: LD_VAR 0 3
13690: PPUSH
13691: CALL_OW 259
13695: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
13696: LD_VAR 0 6
13700: PUSH
13701: LD_INT 1
13703: ARRAY
13704: PPUSH
13705: LD_VAR 0 2
13709: PPUSH
13710: LD_VAR 0 5
13714: PPUSH
13715: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
13719: LD_VAR 0 6
13723: PUSH
13724: LD_INT 1
13726: ARRAY
13727: PPUSH
13728: LD_VAR 0 3
13732: PPUSH
13733: LD_VAR 0 4
13737: PPUSH
13738: CALL_OW 237
// end ;
13742: PPOPN 6
13744: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
13745: LD_EXP 12
13749: PUSH
13750: LD_EXP 59
13754: AND
13755: IFFALSE 13834
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
13763: LD_ADDR_VAR 0 1
13767: PUSH
13768: LD_INT 22
13770: PUSH
13771: LD_OWVAR 2
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: LD_INT 30
13782: PUSH
13783: LD_INT 3
13785: PUSH
13786: EMPTY
13787: LIST
13788: LIST
13789: PUSH
13790: EMPTY
13791: LIST
13792: LIST
13793: PPUSH
13794: CALL_OW 69
13798: ST_TO_ADDR
// if not tmp then
13799: LD_VAR 0 1
13803: NOT
13804: IFFALSE 13808
// exit ;
13806: GO 13834
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
13808: LD_VAR 0 1
13812: PUSH
13813: LD_INT 1
13815: PPUSH
13816: LD_VAR 0 1
13820: PPUSH
13821: CALL_OW 12
13825: ARRAY
13826: PPUSH
13827: LD_INT 1
13829: PPUSH
13830: CALL_OW 234
// end ;
13834: PPOPN 1
13836: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
13837: LD_EXP 12
13841: PUSH
13842: LD_EXP 60
13846: AND
13847: IFFALSE 13959
13849: GO 13851
13851: DISABLE
13852: LD_INT 0
13854: PPUSH
13855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
13856: LD_ADDR_VAR 0 2
13860: PUSH
13861: LD_INT 22
13863: PUSH
13864: LD_OWVAR 2
13868: PUSH
13869: EMPTY
13870: LIST
13871: LIST
13872: PUSH
13873: LD_INT 2
13875: PUSH
13876: LD_INT 30
13878: PUSH
13879: LD_INT 27
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PUSH
13886: LD_INT 30
13888: PUSH
13889: LD_INT 26
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_INT 30
13898: PUSH
13899: LD_INT 28
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: PUSH
13912: EMPTY
13913: LIST
13914: LIST
13915: PPUSH
13916: CALL_OW 69
13920: ST_TO_ADDR
// if not tmp then
13921: LD_VAR 0 2
13925: NOT
13926: IFFALSE 13930
// exit ;
13928: GO 13959
// for i in tmp do
13930: LD_ADDR_VAR 0 1
13934: PUSH
13935: LD_VAR 0 2
13939: PUSH
13940: FOR_IN
13941: IFFALSE 13957
// SetLives ( i , 1 ) ;
13943: LD_VAR 0 1
13947: PPUSH
13948: LD_INT 1
13950: PPUSH
13951: CALL_OW 234
13955: GO 13940
13957: POP
13958: POP
// end ;
13959: PPOPN 2
13961: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
13962: LD_EXP 12
13966: PUSH
13967: LD_EXP 61
13971: AND
13972: IFFALSE 14242
13974: GO 13976
13976: DISABLE
13977: LD_INT 0
13979: PPUSH
13980: PPUSH
13981: PPUSH
// begin i := rand ( 1 , 7 ) ;
13982: LD_ADDR_VAR 0 1
13986: PUSH
13987: LD_INT 1
13989: PPUSH
13990: LD_INT 7
13992: PPUSH
13993: CALL_OW 12
13997: ST_TO_ADDR
// case i of 1 :
13998: LD_VAR 0 1
14002: PUSH
14003: LD_INT 1
14005: DOUBLE
14006: EQUAL
14007: IFTRUE 14011
14009: GO 14021
14011: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
14012: LD_STRING earthquake(getX(game), 0, 32)
14014: PPUSH
14015: CALL_OW 559
14019: GO 14242
14021: LD_INT 2
14023: DOUBLE
14024: EQUAL
14025: IFTRUE 14029
14027: GO 14039
14029: POP
// ToLua ( displayStucuk(); ) ; 3 :
14030: LD_STRING displayStucuk();
14032: PPUSH
14033: CALL_OW 559
14037: GO 14242
14039: LD_INT 3
14041: DOUBLE
14042: EQUAL
14043: IFTRUE 14047
14045: GO 14151
14047: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14048: LD_ADDR_VAR 0 2
14052: PUSH
14053: LD_INT 22
14055: PUSH
14056: LD_OWVAR 2
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: PUSH
14065: LD_INT 25
14067: PUSH
14068: LD_INT 1
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PPUSH
14079: CALL_OW 69
14083: ST_TO_ADDR
// if not tmp then
14084: LD_VAR 0 2
14088: NOT
14089: IFFALSE 14093
// exit ;
14091: GO 14242
// un := tmp [ rand ( 1 , tmp ) ] ;
14093: LD_ADDR_VAR 0 3
14097: PUSH
14098: LD_VAR 0 2
14102: PUSH
14103: LD_INT 1
14105: PPUSH
14106: LD_VAR 0 2
14110: PPUSH
14111: CALL_OW 12
14115: ARRAY
14116: ST_TO_ADDR
// if Crawls ( un ) then
14117: LD_VAR 0 3
14121: PPUSH
14122: CALL_OW 318
14126: IFFALSE 14137
// ComWalk ( un ) ;
14128: LD_VAR 0 3
14132: PPUSH
14133: CALL_OW 138
// SetClass ( un , class_mortar ) ;
14137: LD_VAR 0 3
14141: PPUSH
14142: LD_INT 8
14144: PPUSH
14145: CALL_OW 336
// end ; 4 :
14149: GO 14242
14151: LD_INT 4
14153: DOUBLE
14154: EQUAL
14155: IFTRUE 14159
14157: GO 14220
14159: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14160: LD_ADDR_VAR 0 2
14164: PUSH
14165: LD_INT 22
14167: PUSH
14168: LD_OWVAR 2
14172: PUSH
14173: EMPTY
14174: LIST
14175: LIST
14176: PUSH
14177: LD_INT 30
14179: PUSH
14180: LD_INT 29
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: PPUSH
14191: CALL_OW 69
14195: ST_TO_ADDR
// if not tmp then
14196: LD_VAR 0 2
14200: NOT
14201: IFFALSE 14205
// exit ;
14203: GO 14242
// DestroyUnit ( tmp [ 1 ] ) ;
14205: LD_VAR 0 2
14209: PUSH
14210: LD_INT 1
14212: ARRAY
14213: PPUSH
14214: CALL_OW 65
// end ; 5 .. 7 :
14218: GO 14242
14220: LD_INT 5
14222: DOUBLE
14223: GREATEREQUAL
14224: IFFALSE 14232
14226: LD_INT 7
14228: DOUBLE
14229: LESSEQUAL
14230: IFTRUE 14234
14232: GO 14241
14234: POP
// StreamSibBomb ; end ;
14235: CALL 10536 0 0
14239: GO 14242
14241: POP
// end ;
14242: PPOPN 3
14244: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
14245: LD_EXP 12
14249: PUSH
14250: LD_EXP 62
14254: AND
14255: IFFALSE 14411
14257: GO 14259
14259: DISABLE
14260: LD_INT 0
14262: PPUSH
14263: PPUSH
14264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
14265: LD_ADDR_VAR 0 2
14269: PUSH
14270: LD_INT 81
14272: PUSH
14273: LD_OWVAR 2
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PUSH
14282: LD_INT 2
14284: PUSH
14285: LD_INT 21
14287: PUSH
14288: LD_INT 1
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PUSH
14295: LD_INT 21
14297: PUSH
14298: LD_INT 2
14300: PUSH
14301: EMPTY
14302: LIST
14303: LIST
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: LIST
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: PPUSH
14314: CALL_OW 69
14318: ST_TO_ADDR
// if not tmp then
14319: LD_VAR 0 2
14323: NOT
14324: IFFALSE 14328
// exit ;
14326: GO 14411
// p := 0 ;
14328: LD_ADDR_VAR 0 3
14332: PUSH
14333: LD_INT 0
14335: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14336: LD_INT 35
14338: PPUSH
14339: CALL_OW 67
// p := p + 1 ;
14343: LD_ADDR_VAR 0 3
14347: PUSH
14348: LD_VAR 0 3
14352: PUSH
14353: LD_INT 1
14355: PLUS
14356: ST_TO_ADDR
// for i in tmp do
14357: LD_ADDR_VAR 0 1
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: FOR_IN
14368: IFFALSE 14399
// if GetLives ( i ) < 1000 then
14370: LD_VAR 0 1
14374: PPUSH
14375: CALL_OW 256
14379: PUSH
14380: LD_INT 1000
14382: LESS
14383: IFFALSE 14397
// SetLives ( i , 1000 ) ;
14385: LD_VAR 0 1
14389: PPUSH
14390: LD_INT 1000
14392: PPUSH
14393: CALL_OW 234
14397: GO 14367
14399: POP
14400: POP
// until p > 20 ;
14401: LD_VAR 0 3
14405: PUSH
14406: LD_INT 20
14408: GREATER
14409: IFFALSE 14336
// end ;
14411: PPOPN 3
14413: END
// every 0 0$1 trigger StreamModeActive and sTime do
14414: LD_EXP 12
14418: PUSH
14419: LD_EXP 63
14423: AND
14424: IFFALSE 14459
14426: GO 14428
14428: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
14429: LD_INT 28
14431: PPUSH
14432: LD_OWVAR 2
14436: PPUSH
14437: LD_INT 2
14439: PPUSH
14440: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
14444: LD_INT 30
14446: PPUSH
14447: LD_OWVAR 2
14451: PPUSH
14452: LD_INT 2
14454: PPUSH
14455: CALL_OW 322
// end ;
14459: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
14460: LD_EXP 12
14464: PUSH
14465: LD_EXP 64
14469: AND
14470: IFFALSE 14591
14472: GO 14474
14474: DISABLE
14475: LD_INT 0
14477: PPUSH
14478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14479: LD_ADDR_VAR 0 2
14483: PUSH
14484: LD_INT 22
14486: PUSH
14487: LD_OWVAR 2
14491: PUSH
14492: EMPTY
14493: LIST
14494: LIST
14495: PUSH
14496: LD_INT 21
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: PUSH
14506: LD_INT 3
14508: PUSH
14509: LD_INT 23
14511: PUSH
14512: LD_INT 0
14514: PUSH
14515: EMPTY
14516: LIST
14517: LIST
14518: PUSH
14519: EMPTY
14520: LIST
14521: LIST
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: LIST
14527: PPUSH
14528: CALL_OW 69
14532: ST_TO_ADDR
// if not tmp then
14533: LD_VAR 0 2
14537: NOT
14538: IFFALSE 14542
// exit ;
14540: GO 14591
// for i in tmp do
14542: LD_ADDR_VAR 0 1
14546: PUSH
14547: LD_VAR 0 2
14551: PUSH
14552: FOR_IN
14553: IFFALSE 14589
// begin if Crawls ( i ) then
14555: LD_VAR 0 1
14559: PPUSH
14560: CALL_OW 318
14564: IFFALSE 14575
// ComWalk ( i ) ;
14566: LD_VAR 0 1
14570: PPUSH
14571: CALL_OW 138
// SetClass ( i , 2 ) ;
14575: LD_VAR 0 1
14579: PPUSH
14580: LD_INT 2
14582: PPUSH
14583: CALL_OW 336
// end ;
14587: GO 14552
14589: POP
14590: POP
// end ;
14591: PPOPN 2
14593: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
14594: LD_EXP 12
14598: PUSH
14599: LD_EXP 65
14603: AND
14604: IFFALSE 14809
14606: GO 14608
14608: DISABLE
14609: LD_INT 0
14611: PPUSH
14612: PPUSH
14613: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
14614: LD_OWVAR 2
14618: PPUSH
14619: LD_INT 9
14621: PPUSH
14622: LD_INT 1
14624: PPUSH
14625: LD_INT 1
14627: PPUSH
14628: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
14632: LD_INT 9
14634: PPUSH
14635: LD_OWVAR 2
14639: PPUSH
14640: CALL_OW 343
// hc_name := Dark Warrior ;
14644: LD_ADDR_OWVAR 26
14648: PUSH
14649: LD_STRING Dark Warrior
14651: ST_TO_ADDR
// hc_gallery :=  ;
14652: LD_ADDR_OWVAR 33
14656: PUSH
14657: LD_STRING 
14659: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
14660: LD_INT 1
14662: PPUSH
14663: LD_INT 1
14665: PPUSH
14666: LD_INT 10
14668: PPUSH
14669: CALL_OW 380
// un := CreateHuman ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: CALL_OW 44
14682: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14683: LD_VAR 0 3
14687: PPUSH
14688: LD_INT 1
14690: PPUSH
14691: CALL_OW 51
// p := 0 ;
14695: LD_ADDR_VAR 0 2
14699: PUSH
14700: LD_INT 0
14702: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14703: LD_INT 35
14705: PPUSH
14706: CALL_OW 67
// if GetLives ( un ) < 1000 then
14710: LD_VAR 0 3
14714: PPUSH
14715: CALL_OW 256
14719: PUSH
14720: LD_INT 1000
14722: LESS
14723: IFFALSE 14737
// SetLives ( un , 1000 ) ;
14725: LD_VAR 0 3
14729: PPUSH
14730: LD_INT 1000
14732: PPUSH
14733: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
14737: LD_VAR 0 3
14741: PPUSH
14742: LD_INT 81
14744: PUSH
14745: LD_OWVAR 2
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: PPUSH
14754: CALL_OW 69
14758: PPUSH
14759: LD_VAR 0 3
14763: PPUSH
14764: CALL_OW 74
14768: PPUSH
14769: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
14773: LD_VAR 0 2
14777: PUSH
14778: LD_INT 60
14780: GREATER
14781: PUSH
14782: LD_VAR 0 3
14786: PPUSH
14787: CALL_OW 301
14791: OR
14792: IFFALSE 14703
// if un then
14794: LD_VAR 0 3
14798: IFFALSE 14809
// RemoveUnit ( un ) ;
14800: LD_VAR 0 3
14804: PPUSH
14805: CALL_OW 64
// end ; end_of_file end_of_file
14809: PPOPN 3
14811: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
14812: GO 14814
14814: DISABLE
// begin ru_radar := 98 ;
14815: LD_ADDR_EXP 66
14819: PUSH
14820: LD_INT 98
14822: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
14823: LD_ADDR_EXP 67
14827: PUSH
14828: LD_INT 89
14830: ST_TO_ADDR
// us_hack := 99 ;
14831: LD_ADDR_EXP 68
14835: PUSH
14836: LD_INT 99
14838: ST_TO_ADDR
// us_artillery := 97 ;
14839: LD_ADDR_EXP 69
14843: PUSH
14844: LD_INT 97
14846: ST_TO_ADDR
// ar_bio_bomb := 91 ;
14847: LD_ADDR_EXP 70
14851: PUSH
14852: LD_INT 91
14854: ST_TO_ADDR
// end ;
14855: END
