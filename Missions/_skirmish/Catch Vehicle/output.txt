// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareGame ;
   4: CALL 13 0 0
// PrepareUnits ;
   8: CALL 299 0 0
// end ;
  12: END
// export mechanics , time_to_destroy , players , sib_bomb , time , veh_amount ; export p1 , p2 , p3 , p4 , p5 ; function PrepareGame ; var debug , i ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
// debug := false ;
  18: LD_ADDR_VAR 0 2
  22: PUSH
  23: LD_INT 0
  25: ST_TO_ADDR
// if debug then
  26: LD_VAR 0 2
  30: IFFALSE 81
// begin mechanics := 5 ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 5
  39: ST_TO_ADDR
// time_to_destroy := 45 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 45
  47: ST_TO_ADDR
// players := 4 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 4
  55: ST_TO_ADDR
// sib_bomb := true ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 1
  63: ST_TO_ADDR
// time := 3 3$00 ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 6300
  71: ST_TO_ADDR
// FogOff ( 1 ) ;
  72: LD_INT 1
  74: PPUSH
  75: CALL_OW 344
// end else
  79: GO 214
// begin time := 3 3$00 ;
  81: LD_ADDR_EXP 5
  85: PUSH
  86: LD_INT 6300
  88: ST_TO_ADDR
// players := 4 ;
  89: LD_ADDR_EXP 3
  93: PUSH
  94: LD_INT 4
  96: ST_TO_ADDR
// sib_bomb := true ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 1
 104: ST_TO_ADDR
// mechanics := 4 ;
 105: LD_ADDR_EXP 1
 109: PUSH
 110: LD_INT 4
 112: ST_TO_ADDR
// mechanics := [ 3 , 4 , 5 ] [ GetMultiplayerSetting ( 0 ) ] ;
 113: LD_ADDR_EXP 1
 117: PUSH
 118: LD_INT 3
 120: PUSH
 121: LD_INT 4
 123: PUSH
 124: LD_INT 5
 126: PUSH
 127: EMPTY
 128: LIST
 129: LIST
 130: LIST
 131: PUSH
 132: LD_INT 0
 134: PPUSH
 135: CALL_OW 426
 139: ARRAY
 140: ST_TO_ADDR
// players := [ 3 , 4 , 5 ] [ GetMultiplayerSetting ( 1 ) ] ;
 141: LD_ADDR_EXP 3
 145: PUSH
 146: LD_INT 3
 148: PUSH
 149: LD_INT 4
 151: PUSH
 152: LD_INT 5
 154: PUSH
 155: EMPTY
 156: LIST
 157: LIST
 158: LIST
 159: PUSH
 160: LD_INT 1
 162: PPUSH
 163: CALL_OW 426
 167: ARRAY
 168: ST_TO_ADDR
// time := [ 3 3$00 , 5 5$00 , 10 10$00 ] [ GetMultiplayerSetting ( 2 ) ] ;
 169: LD_ADDR_EXP 5
 173: PUSH
 174: LD_INT 6300
 176: PUSH
 177: LD_INT 10500
 179: PUSH
 180: LD_INT 21000
 182: PUSH
 183: EMPTY
 184: LIST
 185: LIST
 186: LIST
 187: PUSH
 188: LD_INT 2
 190: PPUSH
 191: CALL_OW 426
 195: ARRAY
 196: ST_TO_ADDR
// sib_bomb := GetMultiplayerSetting ( 3 ) - 1 ;
 197: LD_ADDR_EXP 4
 201: PUSH
 202: LD_INT 3
 204: PPUSH
 205: CALL_OW 426
 209: PUSH
 210: LD_INT 1
 212: MINUS
 213: ST_TO_ADDR
// end ; p1 := 0 ;
 214: LD_ADDR_EXP 7
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// p2 := 0 ;
 222: LD_ADDR_EXP 8
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// p3 := 0 ;
 230: LD_ADDR_EXP 9
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// p4 := 0 ;
 238: LD_ADDR_EXP 10
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// p5 := 0 ;
 246: LD_ADDR_EXP 11
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// veh_amount := 12 ;
 254: LD_ADDR_EXP 6
 258: PUSH
 259: LD_INT 12
 261: ST_TO_ADDR
// for i = 1 to 7 do
 262: LD_ADDR_VAR 0 3
 266: PUSH
 267: DOUBLE
 268: LD_INT 1
 270: DEC
 271: ST_TO_ADDR
 272: LD_INT 7
 274: PUSH
 275: FOR_TO
 276: IFFALSE 292
// ChangeSideFog ( i , 8 ) ;
 278: LD_VAR 0 3
 282: PPUSH
 283: LD_INT 8
 285: PPUSH
 286: CALL_OW 343
 290: GO 275
 292: POP
 293: POP
// end ; end_of_file
 294: LD_VAR 0 1
 298: RET
// export function PrepareUnits ; var i , side ; begin
 299: LD_INT 0
 301: PPUSH
 302: PPUSH
 303: PPUSH
// side := players ;
 304: LD_ADDR_VAR 0 3
 308: PUSH
 309: LD_EXP 3
 313: ST_TO_ADDR
// uc_nation := 1 ;
 314: LD_ADDR_OWVAR 21
 318: PUSH
 319: LD_INT 1
 321: ST_TO_ADDR
// for i = 1 to mechanics do
 322: LD_ADDR_VAR 0 2
 326: PUSH
 327: DOUBLE
 328: LD_INT 1
 330: DEC
 331: ST_TO_ADDR
 332: LD_EXP 1
 336: PUSH
 337: FOR_TO
 338: IFFALSE 402
// for side = 1 to players do
 340: LD_ADDR_VAR 0 3
 344: PUSH
 345: DOUBLE
 346: LD_INT 1
 348: DEC
 349: ST_TO_ADDR
 350: LD_EXP 3
 354: PUSH
 355: FOR_TO
 356: IFFALSE 398
// begin uc_side := side ;
 358: LD_ADDR_OWVAR 20
 362: PUSH
 363: LD_VAR 0 3
 367: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 368: LD_INT 0
 370: PPUSH
 371: LD_INT 3
 373: PPUSH
 374: LD_INT 10
 376: PPUSH
 377: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 381: CALL_OW 44
 385: PPUSH
 386: LD_INT 6
 388: PPUSH
 389: LD_INT 0
 391: PPUSH
 392: CALL_OW 49
// end ;
 396: GO 355
 398: POP
 399: POP
 400: GO 337
 402: POP
 403: POP
// end ;
 404: LD_VAR 0 1
 408: RET
// function ToSpawn ( side ) ; begin
 409: LD_INT 0
 411: PPUSH
// uc_side := side ;
 412: LD_ADDR_OWVAR 20
 416: PUSH
 417: LD_VAR 0 1
 421: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 422: LD_INT 0
 424: PPUSH
 425: LD_INT 3
 427: PPUSH
 428: LD_INT 10
 430: PPUSH
 431: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 435: CALL_OW 44
 439: PPUSH
 440: LD_INT 6
 442: PPUSH
 443: LD_INT 0
 445: PPUSH
 446: CALL_OW 49
// end ;
 450: LD_VAR 0 2
 454: RET
// every 0 0$13 trigger time do var i , filter ;
 455: LD_EXP 5
 459: IFFALSE 569
 461: GO 463
 463: DISABLE
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// begin enable ;
 468: ENABLE
// for i = 1 to players do
 469: LD_ADDR_VAR 0 1
 473: PUSH
 474: DOUBLE
 475: LD_INT 1
 477: DEC
 478: ST_TO_ADDR
 479: LD_EXP 3
 483: PUSH
 484: FOR_TO
 485: IFFALSE 567
// begin filter := FilterAllUnits ( [ [ [ f_side , i ] , [ f_class , 3 ] , [ f_type , unit_human ] ] ] ) ;
 487: LD_ADDR_VAR 0 2
 491: PUSH
 492: LD_INT 22
 494: PUSH
 495: LD_VAR 0 1
 499: PUSH
 500: EMPTY
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 25
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: PUSH
 514: LD_INT 21
 516: PUSH
 517: LD_INT 1
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: PPUSH
 532: CALL_OW 69
 536: ST_TO_ADDR
// if filter < mechanics then
 537: LD_VAR 0 2
 541: PUSH
 542: LD_EXP 1
 546: LESS
 547: IFFALSE 565
// begin Wait ( 0 0$03 ) ;
 549: LD_INT 105
 551: PPUSH
 552: CALL_OW 67
// ToSpawn ( i ) ;
 556: LD_VAR 0 1
 560: PPUSH
 561: CALL 409 0 1
// end ; end ;
 565: GO 484
 567: POP
 568: POP
// end ;
 569: PPOPN 2
 571: END
// every 0 0$01 trigger time do var i , filter , filter2 , vehicles ;
 572: LD_EXP 5
 576: IFFALSE 943
 578: GO 580
 580: DISABLE
 581: LD_INT 0
 583: PPUSH
 584: PPUSH
 585: PPUSH
 586: PPUSH
// begin enable ;
 587: ENABLE
// filter2 := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_not , [ f_side , 0 ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 588: LD_ADDR_VAR 0 3
 592: PUSH
 593: LD_INT 21
 595: PUSH
 596: LD_INT 2
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 3
 605: PUSH
 606: LD_INT 22
 608: PUSH
 609: LD_INT 0
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: PUSH
 616: EMPTY
 617: LIST
 618: LIST
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 22
 625: PUSH
 626: LD_INT 1
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: PPUSH
 642: CALL_OW 69
 646: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 647: LD_ADDR_VAR 0 2
 651: PUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 54
 667: PUSH
 668: EMPTY
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PUSH
 675: LD_INT 3
 677: PUSH
 678: LD_INT 22
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL_OW 69
 701: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 702: LD_ADDR_VAR 0 4
 706: PUSH
 707: LD_INT 21
 709: PUSH
 710: LD_INT 2
 712: PUSH
 713: EMPTY
 714: LIST
 715: LIST
 716: PUSH
 717: LD_INT 58
 719: PUSH
 720: EMPTY
 721: LIST
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: PPUSH
 727: CALL_OW 69
 731: ST_TO_ADDR
// if filter and vehicles then
 732: LD_VAR 0 2
 736: PUSH
 737: LD_VAR 0 4
 741: AND
 742: IFFALSE 879
// for i = 1 to filter do
 744: LD_ADDR_VAR 0 1
 748: PUSH
 749: DOUBLE
 750: LD_INT 1
 752: DEC
 753: ST_TO_ADDR
 754: LD_VAR 0 2
 758: PUSH
 759: FOR_TO
 760: IFFALSE 877
// if not HasTask ( filter [ i ] ) and IsOk ( filter [ i ] ) then
 762: LD_VAR 0 2
 766: PUSH
 767: LD_VAR 0 1
 771: ARRAY
 772: PPUSH
 773: CALL_OW 314
 777: NOT
 778: PUSH
 779: LD_VAR 0 2
 783: PUSH
 784: LD_VAR 0 1
 788: ARRAY
 789: PPUSH
 790: CALL_OW 302
 794: AND
 795: IFFALSE 875
// if GetDistUnits ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) < 45 then
 797: LD_VAR 0 2
 801: PUSH
 802: LD_VAR 0 1
 806: ARRAY
 807: PPUSH
 808: LD_VAR 0 4
 812: PPUSH
 813: LD_VAR 0 2
 817: PUSH
 818: LD_VAR 0 1
 822: ARRAY
 823: PPUSH
 824: CALL_OW 74
 828: PPUSH
 829: CALL_OW 296
 833: PUSH
 834: LD_INT 45
 836: LESS
 837: IFFALSE 875
// ComEnterUnit ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) ;
 839: LD_VAR 0 2
 843: PUSH
 844: LD_VAR 0 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 4
 854: PPUSH
 855: LD_VAR 0 2
 859: PUSH
 860: LD_VAR 0 1
 864: ARRAY
 865: PPUSH
 866: CALL_OW 74
 870: PPUSH
 871: CALL_OW 120
 875: GO 759
 877: POP
 878: POP
// if filter2 then
 879: LD_VAR 0 3
 883: IFFALSE 943
// for i = 1 to filter2 do
 885: LD_ADDR_VAR 0 1
 889: PUSH
 890: DOUBLE
 891: LD_INT 1
 893: DEC
 894: ST_TO_ADDR
 895: LD_VAR 0 3
 899: PUSH
 900: FOR_TO
 901: IFFALSE 941
// if not HasTask ( filter2 [ i ] ) then
 903: LD_VAR 0 3
 907: PUSH
 908: LD_VAR 0 1
 912: ARRAY
 913: PPUSH
 914: CALL_OW 314
 918: NOT
 919: IFFALSE 939
// ComMoveToArea ( filter2 [ i ] , exit_area ) ;
 921: LD_VAR 0 3
 925: PUSH
 926: LD_VAR 0 1
 930: ARRAY
 931: PPUSH
 932: LD_INT 4
 934: PPUSH
 935: CALL_OW 113
 939: GO 900
 941: POP
 942: POP
// end ; end_of_file
 943: PPOPN 4
 945: END
// export function SpawnCar ( chas , area ) ; var i , e , veh , ar_chassis , ru_chassis , us_chassis , ar_weapons , ru_weapons , us_weapons , chassis , engine , weapon ; begin
 946: LD_INT 0
 948: PPUSH
 949: PPUSH
 950: PPUSH
 951: PPUSH
 952: PPUSH
 953: PPUSH
 954: PPUSH
 955: PPUSH
 956: PPUSH
 957: PPUSH
 958: PPUSH
 959: PPUSH
 960: PPUSH
// uc_side := 0 ;
 961: LD_ADDR_OWVAR 20
 965: PUSH
 966: LD_INT 0
 968: ST_TO_ADDR
// uc_nation := Rand ( 1 , 3 ) ;
 969: LD_ADDR_OWVAR 21
 973: PUSH
 974: LD_INT 1
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: CALL_OW 12
 984: ST_TO_ADDR
// ar_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
 985: LD_ADDR_VAR 0 7
 989: PUSH
 990: LD_INT 11
 992: PUSH
 993: LD_INT 12
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 14
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: ST_TO_ADDR
// ru_chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ;
1008: LD_ADDR_VAR 0 8
1012: PUSH
1013: LD_INT 21
1015: PUSH
1016: LD_INT 22
1018: PUSH
1019: LD_INT 23
1021: PUSH
1022: LD_INT 24
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: LIST
1029: LIST
1030: ST_TO_ADDR
// us_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ;
1031: LD_ADDR_VAR 0 9
1035: PUSH
1036: LD_INT 1
1038: PUSH
1039: LD_INT 2
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: LD_INT 4
1047: PUSH
1048: LD_INT 5
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: ST_TO_ADDR
// if chas > 0 then
1058: LD_VAR 0 1
1062: PUSH
1063: LD_INT 0
1065: GREATER
1066: IFFALSE 1080
// vc_chassis := chas else
1068: LD_ADDR_OWVAR 37
1072: PUSH
1073: LD_VAR 0 1
1077: ST_TO_ADDR
1078: GO 1173
// begin case uc_nation of 1 :
1080: LD_OWVAR 21
1084: PUSH
1085: LD_INT 1
1087: DOUBLE
1088: EQUAL
1089: IFTRUE 1093
1091: GO 1106
1093: POP
// chassis := us_chassis ; 2 :
1094: LD_ADDR_VAR 0 13
1098: PUSH
1099: LD_VAR 0 9
1103: ST_TO_ADDR
1104: GO 1149
1106: LD_INT 2
1108: DOUBLE
1109: EQUAL
1110: IFTRUE 1114
1112: GO 1127
1114: POP
// chassis := ar_chassis ; 3 :
1115: LD_ADDR_VAR 0 13
1119: PUSH
1120: LD_VAR 0 7
1124: ST_TO_ADDR
1125: GO 1149
1127: LD_INT 3
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1148
1135: POP
// chassis := ru_chassis ; end ;
1136: LD_ADDR_VAR 0 13
1140: PUSH
1141: LD_VAR 0 8
1145: ST_TO_ADDR
1146: GO 1149
1148: POP
// vc_chassis := chassis [ Rand ( 1 , chassis ) ] ;
1149: LD_ADDR_OWVAR 37
1153: PUSH
1154: LD_VAR 0 13
1158: PUSH
1159: LD_INT 1
1161: PPUSH
1162: LD_VAR 0 13
1166: PPUSH
1167: CALL_OW 12
1171: ARRAY
1172: ST_TO_ADDR
// end ; if vc_chassis in [ ar_hovercraft , ar_light_trike , us_light_wheeled ] then
1173: LD_OWVAR 37
1177: PUSH
1178: LD_INT 11
1180: PUSH
1181: LD_INT 12
1183: PUSH
1184: LD_INT 1
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: LIST
1191: IN
1192: IFFALSE 1212
// engine := Rand ( 1 , 2 ) else
1194: LD_ADDR_VAR 0 14
1198: PUSH
1199: LD_INT 1
1201: PPUSH
1202: LD_INT 2
1204: PPUSH
1205: CALL_OW 12
1209: ST_TO_ADDR
1210: GO 1324
// begin if not vc_chassis in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked , us_morphling ] then
1212: LD_OWVAR 37
1216: PUSH
1217: LD_INT 21
1219: PUSH
1220: LD_INT 22
1222: PUSH
1223: LD_INT 23
1225: PUSH
1226: LD_INT 24
1228: PUSH
1229: LD_INT 4
1231: PUSH
1232: LD_INT 5
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: IN
1243: NOT
1244: IFFALSE 1264
// engine := Rand ( 1 , 3 ) else
1246: LD_ADDR_VAR 0 14
1250: PUSH
1251: LD_INT 1
1253: PPUSH
1254: LD_INT 3
1256: PPUSH
1257: CALL_OW 12
1261: ST_TO_ADDR
1262: GO 1280
// e := Rand ( 1 , 2 ) ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_INT 1
1271: PPUSH
1272: LD_INT 2
1274: PPUSH
1275: CALL_OW 12
1279: ST_TO_ADDR
// case e of 1 :
1280: LD_VAR 0 5
1284: PUSH
1285: LD_INT 1
1287: DOUBLE
1288: EQUAL
1289: IFTRUE 1293
1291: GO 1304
1293: POP
// engine := engine_combustion ; 2 :
1294: LD_ADDR_VAR 0 14
1298: PUSH
1299: LD_INT 1
1301: ST_TO_ADDR
1302: GO 1324
1304: LD_INT 2
1306: DOUBLE
1307: EQUAL
1308: IFTRUE 1312
1310: GO 1323
1312: POP
// engine := engine_siberite ; end ;
1313: LD_ADDR_VAR 0 14
1317: PUSH
1318: LD_INT 3
1320: ST_TO_ADDR
1321: GO 1324
1323: POP
// end ; vc_engine := engine ;
1324: LD_ADDR_OWVAR 39
1328: PUSH
1329: LD_VAR 0 14
1333: ST_TO_ADDR
// vc_control := control_manual ;
1334: LD_ADDR_OWVAR 38
1338: PUSH
1339: LD_INT 1
1341: ST_TO_ADDR
// ar_weapons := [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ar_radar , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb , ar_flame_thrower ] ;
1342: LD_ADDR_VAR 0 10
1346: PUSH
1347: LD_INT 22
1349: PUSH
1350: LD_INT 24
1352: PUSH
1353: LD_INT 23
1355: PUSH
1356: LD_INT 30
1358: PUSH
1359: LD_INT 25
1361: PUSH
1362: LD_INT 27
1364: PUSH
1365: LD_INT 28
1367: PUSH
1368: LD_INT 29
1370: PUSH
1371: LD_INT 26
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: ST_TO_ADDR
// ru_weapons := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , 98 , ru_rocket_launcher , ru_heavy_gun , ru_rocket , ru_bulldozer , ru_time_lapser ] ;
1385: LD_ADDR_VAR 0 11
1389: PUSH
1390: LD_INT 42
1392: PUSH
1393: LD_INT 43
1395: PUSH
1396: LD_INT 44
1398: PUSH
1399: LD_INT 98
1401: PUSH
1402: LD_INT 45
1404: PUSH
1405: LD_INT 46
1407: PUSH
1408: LD_INT 47
1410: PUSH
1411: LD_INT 53
1413: PUSH
1414: LD_INT 49
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: ST_TO_ADDR
// us_weapons := [ us_machine_gun , us_light_gun , us_radar , us_gatling_gun , us_double_gun , us_rocket_launcher , us_laser , us_heavy_gun , us_bulldozer , us_double_laser ] ;
1428: LD_ADDR_VAR 0 12
1432: PUSH
1433: LD_INT 2
1435: PUSH
1436: LD_INT 3
1438: PUSH
1439: LD_INT 11
1441: PUSH
1442: LD_INT 4
1444: PUSH
1445: LD_INT 5
1447: PUSH
1448: LD_INT 7
1450: PUSH
1451: LD_INT 9
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: LD_INT 14
1459: PUSH
1460: LD_INT 10
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: ST_TO_ADDR
// if uc_nation = nation_arabian then
1475: LD_OWVAR 21
1479: PUSH
1480: LD_INT 2
1482: EQUAL
1483: IFFALSE 1550
// begin if vc_chassis in [ ar_hovercraft , ar_light_trike ] then
1485: LD_OWVAR 37
1489: PUSH
1490: LD_INT 11
1492: PUSH
1493: LD_INT 12
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: IN
1500: IFFALSE 1526
// weapon := ar_weapons [ Rand ( 1 , 3 ) ] else
1502: LD_ADDR_VAR 0 15
1506: PUSH
1507: LD_VAR 0 10
1511: PUSH
1512: LD_INT 1
1514: PPUSH
1515: LD_INT 3
1517: PPUSH
1518: CALL_OW 12
1522: ARRAY
1523: ST_TO_ADDR
1524: GO 1550
// weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
1526: LD_ADDR_VAR 0 15
1530: PUSH
1531: LD_VAR 0 10
1535: PUSH
1536: LD_INT 1
1538: PPUSH
1539: LD_VAR 0 10
1543: PPUSH
1544: CALL_OW 12
1548: ARRAY
1549: ST_TO_ADDR
// end ; if uc_nation = nation_russian then
1550: LD_OWVAR 21
1554: PUSH
1555: LD_INT 3
1557: EQUAL
1558: IFFALSE 1625
// begin if vc_chassis in [ ru_medium_wheeled , ru_medium_tracked ] then
1560: LD_OWVAR 37
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: IN
1575: IFFALSE 1601
// weapon := ru_weapons [ Rand ( 1 , 5 ) ] else
1577: LD_ADDR_VAR 0 15
1581: PUSH
1582: LD_VAR 0 11
1586: PUSH
1587: LD_INT 1
1589: PPUSH
1590: LD_INT 5
1592: PPUSH
1593: CALL_OW 12
1597: ARRAY
1598: ST_TO_ADDR
1599: GO 1625
// weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
1601: LD_ADDR_VAR 0 15
1605: PUSH
1606: LD_VAR 0 11
1610: PUSH
1611: LD_INT 1
1613: PPUSH
1614: LD_VAR 0 11
1618: PPUSH
1619: CALL_OW 12
1623: ARRAY
1624: ST_TO_ADDR
// end ; if uc_nation = nation_american then
1625: LD_OWVAR 21
1629: PUSH
1630: LD_INT 1
1632: EQUAL
1633: IFFALSE 1742
// begin if vc_chassis = us_light_wheeled then
1635: LD_OWVAR 37
1639: PUSH
1640: LD_INT 1
1642: EQUAL
1643: IFFALSE 1667
// weapon := us_weapons [ Rand ( 1 , 3 ) ] ;
1645: LD_ADDR_VAR 0 15
1649: PUSH
1650: LD_VAR 0 12
1654: PUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 3
1660: PPUSH
1661: CALL_OW 12
1665: ARRAY
1666: ST_TO_ADDR
// if vc_chassis in [ us_medium_tracked , us_medium_wheeled ] then
1667: LD_OWVAR 37
1671: PUSH
1672: LD_INT 3
1674: PUSH
1675: LD_INT 2
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: IN
1682: IFFALSE 1708
// weapon := us_weapons [ Rand ( 1 , 7 ) ] else
1684: LD_ADDR_VAR 0 15
1688: PUSH
1689: LD_VAR 0 12
1693: PUSH
1694: LD_INT 1
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL_OW 12
1704: ARRAY
1705: ST_TO_ADDR
1706: GO 1742
// if vc_chassis <> us_light_wheeled then
1708: LD_OWVAR 37
1712: PUSH
1713: LD_INT 1
1715: NONEQUAL
1716: IFFALSE 1742
// weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
1718: LD_ADDR_VAR 0 15
1722: PUSH
1723: LD_VAR 0 12
1727: PUSH
1728: LD_INT 1
1730: PPUSH
1731: LD_VAR 0 12
1735: PPUSH
1736: CALL_OW 12
1740: ARRAY
1741: ST_TO_ADDR
// end ; vc_weapon := weapon ;
1742: LD_ADDR_OWVAR 40
1746: PUSH
1747: LD_VAR 0 15
1751: ST_TO_ADDR
// veh := CreateVehicle ;
1752: LD_ADDR_VAR 0 6
1756: PUSH
1757: CALL_OW 45
1761: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1762: LD_VAR 0 6
1766: PPUSH
1767: LD_VAR 0 2
1771: PPUSH
1772: LD_INT 1
1774: PPUSH
1775: CALL_OW 49
// end ;
1779: LD_VAR 0 3
1783: RET
// export function SpawnSibRocket ( area ) ; var veh , p ; begin
1784: LD_INT 0
1786: PPUSH
1787: PPUSH
1788: PPUSH
// uc_side := 0 ;
1789: LD_ADDR_OWVAR 20
1793: PUSH
1794: LD_INT 0
1796: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
1797: LD_ADDR_VAR 0 4
1801: PUSH
1802: LD_INT 1
1804: PPUSH
1805: LD_INT 2
1807: PPUSH
1808: CALL_OW 12
1812: ST_TO_ADDR
// case p of 1 :
1813: LD_VAR 0 4
1817: PUSH
1818: LD_INT 1
1820: DOUBLE
1821: EQUAL
1822: IFTRUE 1826
1824: GO 1869
1826: POP
// begin uc_nation := nation_american ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
1835: LD_ADDR_OWVAR 37
1839: PUSH
1840: LD_INT 4
1842: ST_TO_ADDR
// vc_engine := engine_siberite ;
1843: LD_ADDR_OWVAR 39
1847: PUSH
1848: LD_INT 3
1850: ST_TO_ADDR
// vc_control := control_manual ;
1851: LD_ADDR_OWVAR 38
1855: PUSH
1856: LD_INT 1
1858: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
1859: LD_ADDR_OWVAR 40
1863: PUSH
1864: LD_INT 8
1866: ST_TO_ADDR
// end ; 2 :
1867: GO 1921
1869: LD_INT 2
1871: DOUBLE
1872: EQUAL
1873: IFTRUE 1877
1875: GO 1920
1877: POP
// begin uc_nation := nation_russian ;
1878: LD_ADDR_OWVAR 21
1882: PUSH
1883: LD_INT 3
1885: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
1886: LD_ADDR_OWVAR 37
1890: PUSH
1891: LD_INT 24
1893: ST_TO_ADDR
// vc_engine := engine_siberite ;
1894: LD_ADDR_OWVAR 39
1898: PUSH
1899: LD_INT 3
1901: ST_TO_ADDR
// vc_control := control_manual ;
1902: LD_ADDR_OWVAR 38
1906: PUSH
1907: LD_INT 1
1909: ST_TO_ADDR
// vc_weapon := ru_siberium_rocket ;
1910: LD_ADDR_OWVAR 40
1914: PUSH
1915: LD_INT 48
1917: ST_TO_ADDR
// end ; end ;
1918: GO 1921
1920: POP
// veh := CreateVehicle ;
1921: LD_ADDR_VAR 0 3
1925: PUSH
1926: CALL_OW 45
1930: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1931: LD_VAR 0 3
1935: PPUSH
1936: LD_VAR 0 1
1940: PPUSH
1941: LD_INT 1
1943: PPUSH
1944: CALL_OW 49
// end ;
1948: LD_VAR 0 2
1952: RET
// export function ScoreBoard ( veh ) ; var points ; begin
1953: LD_INT 0
1955: PPUSH
1956: PPUSH
// points := 0 ;
1957: LD_ADDR_VAR 0 3
1961: PUSH
1962: LD_INT 0
1964: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_light_trike , us_light_wheeled ] then
1965: LD_VAR 0 1
1969: PPUSH
1970: CALL_OW 265
1974: PUSH
1975: LD_INT 12
1977: PUSH
1978: LD_INT 1
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: IN
1985: IFFALSE 2001
// points := points + 10 ;
1987: LD_ADDR_VAR 0 3
1991: PUSH
1992: LD_VAR 0 3
1996: PUSH
1997: LD_INT 10
1999: PLUS
2000: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_medium_trike , ru_medium_wheeled , us_medium_wheeled ] then
2001: LD_VAR 0 1
2005: PPUSH
2006: CALL_OW 265
2010: PUSH
2011: LD_INT 13
2013: PUSH
2014: LD_INT 21
2016: PUSH
2017: LD_INT 2
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: IN
2025: IFFALSE 2041
// points := points + 15 ;
2027: LD_ADDR_VAR 0 3
2031: PUSH
2032: LD_VAR 0 3
2036: PUSH
2037: LD_INT 15
2039: PLUS
2040: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_half_tracked , ru_medium_tracked , us_medium_tracked ] then
2041: LD_VAR 0 1
2045: PPUSH
2046: CALL_OW 265
2050: PUSH
2051: LD_INT 14
2053: PUSH
2054: LD_INT 22
2056: PUSH
2057: LD_INT 3
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: LIST
2064: IN
2065: IFFALSE 2081
// points := points + 20 ;
2067: LD_ADDR_VAR 0 3
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 20
2079: PLUS
2080: ST_TO_ADDR
// if GetChassis ( veh ) in [ ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked ] then
2081: LD_VAR 0 1
2085: PPUSH
2086: CALL_OW 265
2090: PUSH
2091: LD_INT 23
2093: PUSH
2094: LD_INT 24
2096: PUSH
2097: LD_INT 4
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: IN
2105: IFFALSE 2121
// points := points + 25 ;
2107: LD_ADDR_VAR 0 3
2111: PUSH
2112: LD_VAR 0 3
2116: PUSH
2117: LD_INT 25
2119: PLUS
2120: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_hovercraft , us_morphling ] then
2121: LD_VAR 0 1
2125: PPUSH
2126: CALL_OW 265
2130: PUSH
2131: LD_INT 11
2133: PUSH
2134: LD_INT 5
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: IN
2141: IFFALSE 2157
// points := points + 30 ;
2143: LD_ADDR_VAR 0 3
2147: PUSH
2148: LD_VAR 0 3
2152: PUSH
2153: LD_INT 30
2155: PLUS
2156: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_combustion ] then
2157: LD_VAR 0 1
2161: PPUSH
2162: CALL_OW 262
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: EMPTY
2171: LIST
2172: EQUAL
2173: IFFALSE 2189
// points := points + 5 ;
2175: LD_ADDR_VAR 0 3
2179: PUSH
2180: LD_VAR 0 3
2184: PUSH
2185: LD_INT 5
2187: PLUS
2188: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_solar ] then
2189: LD_VAR 0 1
2193: PPUSH
2194: CALL_OW 262
2198: PUSH
2199: LD_INT 2
2201: PUSH
2202: EMPTY
2203: LIST
2204: EQUAL
2205: IFFALSE 2221
// points := points + 15 ;
2207: LD_ADDR_VAR 0 3
2211: PUSH
2212: LD_VAR 0 3
2216: PUSH
2217: LD_INT 15
2219: PLUS
2220: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_siberite ] then
2221: LD_VAR 0 1
2225: PPUSH
2226: CALL_OW 262
2230: PUSH
2231: LD_INT 3
2233: PUSH
2234: EMPTY
2235: LIST
2236: EQUAL
2237: IFFALSE 2253
// points := points + 25 ;
2239: LD_ADDR_VAR 0 3
2243: PUSH
2244: LD_VAR 0 3
2248: PUSH
2249: LD_INT 25
2251: PLUS
2252: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ru_heavy_machine_gun , us_machine_gun , us_light_gun ] then
2253: LD_VAR 0 1
2257: PPUSH
2258: CALL_OW 264
2262: PUSH
2263: LD_INT 22
2265: PUSH
2266: LD_INT 24
2268: PUSH
2269: LD_INT 23
2271: PUSH
2272: LD_INT 42
2274: PUSH
2275: LD_INT 2
2277: PUSH
2278: LD_INT 3
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: LIST
2288: IN
2289: IFFALSE 2305
// points := points + 5 ;
2291: LD_ADDR_VAR 0 3
2295: PUSH
2296: LD_VAR 0 3
2300: PUSH
2301: LD_INT 5
2303: PLUS
2304: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_gatling_gun , ar_gun , ru_gatling_gun , ru_gun , us_gatling_gun , us_double_gun ] then
2305: LD_VAR 0 1
2309: PPUSH
2310: CALL_OW 264
2314: PUSH
2315: LD_INT 25
2317: PUSH
2318: LD_INT 27
2320: PUSH
2321: LD_INT 43
2323: PUSH
2324: LD_INT 44
2326: PUSH
2327: LD_INT 4
2329: PUSH
2330: LD_INT 5
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: LIST
2337: LIST
2338: LIST
2339: LIST
2340: IN
2341: IFFALSE 2357
// points := points + 10 ;
2343: LD_ADDR_VAR 0 3
2347: PUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 10
2355: PLUS
2356: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher ] then
2357: LD_VAR 0 1
2361: PPUSH
2362: CALL_OW 264
2366: PUSH
2367: LD_INT 28
2369: PUSH
2370: LD_INT 45
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: IN
2381: IFFALSE 2397
// points := points + 20 ;
2383: LD_ADDR_VAR 0 3
2387: PUSH
2388: LD_VAR 0 3
2392: PUSH
2393: LD_INT 20
2395: PLUS
2396: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_heavy_gun , us_heavy_gun ] then
2397: LD_VAR 0 1
2401: PPUSH
2402: CALL_OW 264
2406: PUSH
2407: LD_INT 46
2409: PUSH
2410: LD_INT 6
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: IN
2417: IFFALSE 2433
// points := points + 25 ;
2419: LD_ADDR_VAR 0 3
2423: PUSH
2424: LD_VAR 0 3
2428: PUSH
2429: LD_INT 25
2431: PLUS
2432: ST_TO_ADDR
// if GetWeapon ( veh ) in [ us_laser , us_radar , ar_radar ] then
2433: LD_VAR 0 1
2437: PPUSH
2438: CALL_OW 264
2442: PUSH
2443: LD_INT 9
2445: PUSH
2446: LD_INT 11
2448: PUSH
2449: LD_INT 30
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: IN
2457: IFFALSE 2473
// points := points + 30 ;
2459: LD_ADDR_VAR 0 3
2463: PUSH
2464: LD_VAR 0 3
2468: PUSH
2469: LD_INT 30
2471: PLUS
2472: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_selfpropelled_bomb , ru_time_lapser , ru_rocket , us_double_laser ] then
2473: LD_VAR 0 1
2477: PPUSH
2478: CALL_OW 264
2482: PUSH
2483: LD_INT 29
2485: PUSH
2486: LD_INT 49
2488: PUSH
2489: LD_INT 47
2491: PUSH
2492: LD_INT 10
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: LIST
2499: LIST
2500: IN
2501: IFFALSE 2517
// points := points + 50 ;
2503: LD_ADDR_VAR 0 3
2507: PUSH
2508: LD_VAR 0 3
2512: PUSH
2513: LD_INT 50
2515: PLUS
2516: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_siberium_rocket , us_siberium_rocket ] then
2517: LD_VAR 0 1
2521: PPUSH
2522: CALL_OW 264
2526: PUSH
2527: LD_INT 48
2529: PUSH
2530: LD_INT 8
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: IN
2537: IFFALSE 2553
// points := points + 100 ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_VAR 0 3
2548: PUSH
2549: LD_INT 100
2551: PLUS
2552: ST_TO_ADDR
// result := points ;
2553: LD_ADDR_VAR 0 2
2557: PUSH
2558: LD_VAR 0 3
2562: ST_TO_ADDR
// end ; end_of_file
2563: LD_VAR 0 2
2567: RET
// every 0 0$01 trigger time do var filter , i , side , driver , un ;
2568: LD_EXP 5
2572: IFFALSE 3217
2574: GO 2576
2576: DISABLE
2577: LD_INT 0
2579: PPUSH
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
// begin enable ;
2584: ENABLE
// if tick < 36 then
2585: LD_OWVAR 1
2589: PUSH
2590: LD_INT 36
2592: LESS
2593: IFFALSE 2605
// SetAreaMapShow ( exit_area , 1 ) ;
2595: LD_INT 4
2597: PPUSH
2598: LD_INT 1
2600: PPUSH
2601: CALL_OW 424
// time := time - 0 0$01 ;
2605: LD_ADDR_EXP 5
2609: PUSH
2610: LD_EXP 5
2614: PUSH
2615: LD_INT 35
2617: MINUS
2618: ST_TO_ADDR
// if time = 0 0$00 then
2619: LD_EXP 5
2623: PUSH
2624: LD_INT 0
2626: EQUAL
2627: IFFALSE 2690
// if p1 > p2 and p1 > p3 and p1 > p4 and p1 > p5 then
2629: LD_EXP 7
2633: PUSH
2634: LD_EXP 8
2638: GREATER
2639: PUSH
2640: LD_EXP 7
2644: PUSH
2645: LD_EXP 9
2649: GREATER
2650: AND
2651: PUSH
2652: LD_EXP 7
2656: PUSH
2657: LD_EXP 10
2661: GREATER
2662: AND
2663: PUSH
2664: LD_EXP 7
2668: PUSH
2669: LD_EXP 11
2673: GREATER
2674: AND
2675: IFFALSE 2683
// YouWin else
2677: CALL_OW 103
2681: GO 2690
// YouLost (  ) ;
2683: LD_STRING 
2685: PPUSH
2686: CALL_OW 104
// filter := FilterUnitsInArea ( exit_area , [ f_type , unit_vehicle ] ) ;
2690: LD_ADDR_VAR 0 1
2694: PUSH
2695: LD_INT 4
2697: PPUSH
2698: LD_INT 21
2700: PUSH
2701: LD_INT 2
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 70
2712: ST_TO_ADDR
// if filter then
2713: LD_VAR 0 1
2717: IFFALSE 3007
// for i = 1 to filter do
2719: LD_ADDR_VAR 0 2
2723: PUSH
2724: DOUBLE
2725: LD_INT 1
2727: DEC
2728: ST_TO_ADDR
2729: LD_VAR 0 1
2733: PUSH
2734: FOR_TO
2735: IFFALSE 3005
// begin side := GetSide ( filter [ i ] ) ;
2737: LD_ADDR_VAR 0 3
2741: PUSH
2742: LD_VAR 0 1
2746: PUSH
2747: LD_VAR 0 2
2751: ARRAY
2752: PPUSH
2753: CALL_OW 255
2757: ST_TO_ADDR
// driver := IsDrivenBy ( filter [ i ] ) ;
2758: LD_ADDR_VAR 0 4
2762: PUSH
2763: LD_VAR 0 1
2767: PUSH
2768: LD_VAR 0 2
2772: ARRAY
2773: PPUSH
2774: CALL_OW 311
2778: ST_TO_ADDR
// un := filter [ i ] ;
2779: LD_ADDR_VAR 0 5
2783: PUSH
2784: LD_VAR 0 1
2788: PUSH
2789: LD_VAR 0 2
2793: ARRAY
2794: ST_TO_ADDR
// if IsInUnit ( driver ) then
2795: LD_VAR 0 4
2799: PPUSH
2800: CALL_OW 310
2804: IFFALSE 2815
// ComExitVehicle ( driver ) ;
2806: LD_VAR 0 4
2810: PPUSH
2811: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
2815: LD_INT 10
2817: PPUSH
2818: CALL_OW 67
// RemoveUnit ( filter [ i ] ) ;
2822: LD_VAR 0 1
2826: PUSH
2827: LD_VAR 0 2
2831: ARRAY
2832: PPUSH
2833: CALL_OW 64
// case side of 1 :
2837: LD_VAR 0 3
2841: PUSH
2842: LD_INT 1
2844: DOUBLE
2845: EQUAL
2846: IFTRUE 2850
2848: GO 2874
2850: POP
// p1 := p1 + ScoreBoard ( un ) ; 2 :
2851: LD_ADDR_EXP 7
2855: PUSH
2856: LD_EXP 7
2860: PUSH
2861: LD_VAR 0 5
2865: PPUSH
2866: CALL 1953 0 1
2870: PLUS
2871: ST_TO_ADDR
2872: GO 3003
2874: LD_INT 2
2876: DOUBLE
2877: EQUAL
2878: IFTRUE 2882
2880: GO 2906
2882: POP
// p2 := p2 + ScoreBoard ( un ) ; 3 :
2883: LD_ADDR_EXP 8
2887: PUSH
2888: LD_EXP 8
2892: PUSH
2893: LD_VAR 0 5
2897: PPUSH
2898: CALL 1953 0 1
2902: PLUS
2903: ST_TO_ADDR
2904: GO 3003
2906: LD_INT 3
2908: DOUBLE
2909: EQUAL
2910: IFTRUE 2914
2912: GO 2938
2914: POP
// p3 := p3 + ScoreBoard ( un ) ; 4 :
2915: LD_ADDR_EXP 9
2919: PUSH
2920: LD_EXP 9
2924: PUSH
2925: LD_VAR 0 5
2929: PPUSH
2930: CALL 1953 0 1
2934: PLUS
2935: ST_TO_ADDR
2936: GO 3003
2938: LD_INT 4
2940: DOUBLE
2941: EQUAL
2942: IFTRUE 2946
2944: GO 2970
2946: POP
// p4 := p4 + ScoreBoard ( un ) ; 5 :
2947: LD_ADDR_EXP 10
2951: PUSH
2952: LD_EXP 10
2956: PUSH
2957: LD_VAR 0 5
2961: PPUSH
2962: CALL 1953 0 1
2966: PLUS
2967: ST_TO_ADDR
2968: GO 3003
2970: LD_INT 5
2972: DOUBLE
2973: EQUAL
2974: IFTRUE 2978
2976: GO 3002
2978: POP
// p5 := p5 + ScoreBoard ( un ) ; end ;
2979: LD_ADDR_EXP 11
2983: PUSH
2984: LD_EXP 11
2988: PUSH
2989: LD_VAR 0 5
2993: PPUSH
2994: CALL 1953 0 1
2998: PLUS
2999: ST_TO_ADDR
3000: GO 3003
3002: POP
// end ;
3003: GO 2734
3005: POP
3006: POP
// case players of 3 :
3007: LD_EXP 3
3011: PUSH
3012: LD_INT 3
3014: DOUBLE
3015: EQUAL
3016: IFTRUE 3020
3018: GO 3070
3020: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 ] ;
3021: LD_ADDR_OWVAR 47
3025: PUSH
3026: LD_STRING #tick
3028: PUSH
3029: LD_EXP 5
3033: PUSH
3034: LD_STRING #player1
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_STRING #player2
3044: PUSH
3045: LD_EXP 8
3049: PUSH
3050: LD_STRING #player3
3052: PUSH
3053: LD_EXP 9
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: ST_TO_ADDR
// end ; 4 :
3068: GO 3217
3070: LD_INT 4
3072: DOUBLE
3073: EQUAL
3074: IFTRUE 3078
3076: GO 3138
3078: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 ] ;
3079: LD_ADDR_OWVAR 47
3083: PUSH
3084: LD_STRING #tick
3086: PUSH
3087: LD_EXP 5
3091: PUSH
3092: LD_STRING #player1
3094: PUSH
3095: LD_EXP 7
3099: PUSH
3100: LD_STRING #player2
3102: PUSH
3103: LD_EXP 8
3107: PUSH
3108: LD_STRING #player3
3110: PUSH
3111: LD_EXP 9
3115: PUSH
3116: LD_STRING #player4
3118: PUSH
3119: LD_EXP 10
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: LIST
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: ST_TO_ADDR
// end ; 5 :
3136: GO 3217
3138: LD_INT 5
3140: DOUBLE
3141: EQUAL
3142: IFTRUE 3146
3144: GO 3216
3146: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 , #player5 , p5 ] ;
3147: LD_ADDR_OWVAR 47
3151: PUSH
3152: LD_STRING #tick
3154: PUSH
3155: LD_EXP 5
3159: PUSH
3160: LD_STRING #player1
3162: PUSH
3163: LD_EXP 7
3167: PUSH
3168: LD_STRING #player2
3170: PUSH
3171: LD_EXP 8
3175: PUSH
3176: LD_STRING #player3
3178: PUSH
3179: LD_EXP 9
3183: PUSH
3184: LD_STRING #player4
3186: PUSH
3187: LD_EXP 10
3191: PUSH
3192: LD_STRING #player5
3194: PUSH
3195: LD_EXP 11
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: ST_TO_ADDR
// end ; end ;
3214: GO 3217
3216: POP
// end ;
3217: PPOPN 5
3219: END
// every 0 0$05 trigger time do var chance , p ;
3220: LD_EXP 5
3224: IFFALSE 3371
3226: GO 3228
3228: DISABLE
3229: LD_INT 0
3231: PPUSH
3232: PPUSH
// begin enable ;
3233: ENABLE
// Wait ( Rand ( 0 0$01 , 0 0$06 ) ) ;
3234: LD_INT 35
3236: PPUSH
3237: LD_INT 210
3239: PPUSH
3240: CALL_OW 12
3244: PPUSH
3245: CALL_OW 67
// if FilterAllUnits ( [ f_type , unit_vehicle ] ) < veh_amount then
3249: LD_INT 21
3251: PUSH
3252: LD_INT 2
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: PPUSH
3259: CALL_OW 69
3263: PUSH
3264: LD_EXP 6
3268: LESS
3269: IFFALSE 3371
// begin SpawnCar ( false , veh_spawn ) ;
3271: LD_INT 0
3273: PPUSH
3274: LD_INT 5
3276: PPUSH
3277: CALL 946 0 2
// if sib_bomb and FilterAllUnits ( [ f_or , [ [ f_weapon , us_siberium_rocket ] , [ f_weapon , ru_siberium_rocket ] ] ] ) = 0 then
3281: LD_EXP 4
3285: PUSH
3286: LD_INT 2
3288: PUSH
3289: LD_INT 34
3291: PUSH
3292: LD_INT 8
3294: PUSH
3295: EMPTY
3296: LIST
3297: LIST
3298: PUSH
3299: LD_INT 34
3301: PUSH
3302: LD_INT 48
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PPUSH
3317: CALL_OW 69
3321: PUSH
3322: LD_INT 0
3324: EQUAL
3325: AND
3326: IFFALSE 3371
// begin chance := 23 ;
3328: LD_ADDR_VAR 0 1
3332: PUSH
3333: LD_INT 23
3335: ST_TO_ADDR
// p := Rand ( 0 , 100 ) ;
3336: LD_ADDR_VAR 0 2
3340: PUSH
3341: LD_INT 0
3343: PPUSH
3344: LD_INT 100
3346: PPUSH
3347: CALL_OW 12
3351: ST_TO_ADDR
// if p < chance then
3352: LD_VAR 0 2
3356: PUSH
3357: LD_VAR 0 1
3361: LESS
3362: IFFALSE 3371
// SpawnSibRocket ( veh_spawn ) ;
3364: LD_INT 5
3366: PPUSH
3367: CALL 1784 0 1
// end ; end ; end ; end_of_file
3371: PPOPN 2
3373: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
3374: LD_INT 0
3376: PPUSH
3377: PPUSH
3378: PPUSH
3379: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
3380: LD_VAR 0 1
3384: PPUSH
3385: CALL_OW 264
3389: PUSH
3390: LD_EXP 70
3394: EQUAL
3395: IFFALSE 3467
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
3397: LD_INT 68
3399: PPUSH
3400: LD_VAR 0 1
3404: PPUSH
3405: CALL_OW 255
3409: PPUSH
3410: CALL_OW 321
3414: PUSH
3415: LD_INT 2
3417: EQUAL
3418: IFFALSE 3430
// eff := 70 else
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: LD_INT 70
3427: ST_TO_ADDR
3428: GO 3438
// eff := 30 ;
3430: LD_ADDR_VAR 0 4
3434: PUSH
3435: LD_INT 30
3437: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
3438: LD_VAR 0 1
3442: PPUSH
3443: CALL_OW 250
3447: PPUSH
3448: LD_VAR 0 1
3452: PPUSH
3453: CALL_OW 251
3457: PPUSH
3458: LD_VAR 0 4
3462: PPUSH
3463: CALL_OW 495
// end ; end ;
3467: LD_VAR 0 2
3471: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
3472: LD_INT 0
3474: PPUSH
// end ;
3475: LD_VAR 0 4
3479: RET
// export function SOS_Command ( cmd ) ; begin
3480: LD_INT 0
3482: PPUSH
// end ;
3483: LD_VAR 0 2
3487: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
3488: LD_VAR 0 1
3492: PUSH
3493: LD_INT 255
3495: EQUAL
3496: PUSH
3497: LD_VAR 0 2
3501: PPUSH
3502: CALL_OW 264
3506: PUSH
3507: LD_INT 14
3509: PUSH
3510: LD_INT 53
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: IN
3517: AND
3518: PUSH
3519: LD_VAR 0 4
3523: PPUSH
3524: LD_VAR 0 5
3528: PPUSH
3529: CALL_OW 488
3533: AND
3534: IFFALSE 3558
// CutTreeXYR ( unit , x , y , 12 ) ;
3536: LD_VAR 0 2
3540: PPUSH
3541: LD_VAR 0 4
3545: PPUSH
3546: LD_VAR 0 5
3550: PPUSH
3551: LD_INT 12
3553: PPUSH
3554: CALL 3561 0 4
// end ;
3558: PPOPN 5
3560: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
3561: LD_INT 0
3563: PPUSH
3564: PPUSH
3565: PPUSH
3566: PPUSH
3567: PPUSH
3568: PPUSH
3569: PPUSH
3570: PPUSH
3571: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
3572: LD_VAR 0 1
3576: NOT
3577: PUSH
3578: LD_VAR 0 2
3582: PPUSH
3583: LD_VAR 0 3
3587: PPUSH
3588: CALL_OW 488
3592: NOT
3593: OR
3594: PUSH
3595: LD_VAR 0 4
3599: NOT
3600: OR
3601: IFFALSE 3605
// exit ;
3603: GO 3945
// list := [ ] ;
3605: LD_ADDR_VAR 0 13
3609: PUSH
3610: EMPTY
3611: ST_TO_ADDR
// if x - r < 0 then
3612: LD_VAR 0 2
3616: PUSH
3617: LD_VAR 0 4
3621: MINUS
3622: PUSH
3623: LD_INT 0
3625: LESS
3626: IFFALSE 3638
// min_x := 0 else
3628: LD_ADDR_VAR 0 7
3632: PUSH
3633: LD_INT 0
3635: ST_TO_ADDR
3636: GO 3654
// min_x := x - r ;
3638: LD_ADDR_VAR 0 7
3642: PUSH
3643: LD_VAR 0 2
3647: PUSH
3648: LD_VAR 0 4
3652: MINUS
3653: ST_TO_ADDR
// if y - r < 0 then
3654: LD_VAR 0 3
3658: PUSH
3659: LD_VAR 0 4
3663: MINUS
3664: PUSH
3665: LD_INT 0
3667: LESS
3668: IFFALSE 3680
// min_y := 0 else
3670: LD_ADDR_VAR 0 8
3674: PUSH
3675: LD_INT 0
3677: ST_TO_ADDR
3678: GO 3696
// min_y := y - r ;
3680: LD_ADDR_VAR 0 8
3684: PUSH
3685: LD_VAR 0 3
3689: PUSH
3690: LD_VAR 0 4
3694: MINUS
3695: ST_TO_ADDR
// max_x := x + r ;
3696: LD_ADDR_VAR 0 9
3700: PUSH
3701: LD_VAR 0 2
3705: PUSH
3706: LD_VAR 0 4
3710: PLUS
3711: ST_TO_ADDR
// max_y := y + r ;
3712: LD_ADDR_VAR 0 10
3716: PUSH
3717: LD_VAR 0 3
3721: PUSH
3722: LD_VAR 0 4
3726: PLUS
3727: ST_TO_ADDR
// for _x = min_x to max_x do
3728: LD_ADDR_VAR 0 11
3732: PUSH
3733: DOUBLE
3734: LD_VAR 0 7
3738: DEC
3739: ST_TO_ADDR
3740: LD_VAR 0 9
3744: PUSH
3745: FOR_TO
3746: IFFALSE 3863
// for _y = min_y to max_y do
3748: LD_ADDR_VAR 0 12
3752: PUSH
3753: DOUBLE
3754: LD_VAR 0 8
3758: DEC
3759: ST_TO_ADDR
3760: LD_VAR 0 10
3764: PUSH
3765: FOR_TO
3766: IFFALSE 3859
// begin if not ValidHex ( _x , _y ) then
3768: LD_VAR 0 11
3772: PPUSH
3773: LD_VAR 0 12
3777: PPUSH
3778: CALL_OW 488
3782: NOT
3783: IFFALSE 3787
// continue ;
3785: GO 3765
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
3787: LD_VAR 0 11
3791: PPUSH
3792: LD_VAR 0 12
3796: PPUSH
3797: CALL_OW 351
3801: PUSH
3802: LD_VAR 0 11
3806: PPUSH
3807: LD_VAR 0 12
3811: PPUSH
3812: CALL_OW 554
3816: AND
3817: IFFALSE 3857
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
3819: LD_ADDR_VAR 0 13
3823: PUSH
3824: LD_VAR 0 13
3828: PPUSH
3829: LD_VAR 0 13
3833: PUSH
3834: LD_INT 1
3836: PLUS
3837: PPUSH
3838: LD_VAR 0 11
3842: PUSH
3843: LD_VAR 0 12
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PPUSH
3852: CALL_OW 2
3856: ST_TO_ADDR
// end ;
3857: GO 3765
3859: POP
3860: POP
3861: GO 3745
3863: POP
3864: POP
// if not list then
3865: LD_VAR 0 13
3869: NOT
3870: IFFALSE 3874
// exit ;
3872: GO 3945
// for i in list do
3874: LD_ADDR_VAR 0 6
3878: PUSH
3879: LD_VAR 0 13
3883: PUSH
3884: FOR_IN
3885: IFFALSE 3943
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
3887: LD_VAR 0 1
3891: PPUSH
3892: LD_STRING M
3894: PUSH
3895: LD_VAR 0 6
3899: PUSH
3900: LD_INT 1
3902: ARRAY
3903: PUSH
3904: LD_VAR 0 6
3908: PUSH
3909: LD_INT 2
3911: ARRAY
3912: PUSH
3913: LD_INT 0
3915: PUSH
3916: LD_INT 0
3918: PUSH
3919: LD_INT 0
3921: PUSH
3922: LD_INT 0
3924: PUSH
3925: EMPTY
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: LIST
3932: LIST
3933: PUSH
3934: EMPTY
3935: LIST
3936: PPUSH
3937: CALL_OW 447
3941: GO 3884
3943: POP
3944: POP
// end ; end_of_file
3945: LD_VAR 0 5
3949: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
3950: GO 3952
3952: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
3953: LD_STRING initStreamRollete();
3955: PPUSH
3956: CALL_OW 559
// InitStreamMode ;
3960: CALL 3969 0 0
// DefineStreamItems ( ) ;
3964: CALL 4409 0 0
// end ;
3968: END
// function InitStreamMode ; begin
3969: LD_INT 0
3971: PPUSH
// streamModeActive := false ;
3972: LD_ADDR_EXP 12
3976: PUSH
3977: LD_INT 0
3979: ST_TO_ADDR
// normalCounter := 36 ;
3980: LD_ADDR_EXP 13
3984: PUSH
3985: LD_INT 36
3987: ST_TO_ADDR
// hardcoreCounter := 16 ;
3988: LD_ADDR_EXP 14
3992: PUSH
3993: LD_INT 16
3995: ST_TO_ADDR
// sRocket := false ;
3996: LD_ADDR_EXP 17
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// sSpeed := false ;
4004: LD_ADDR_EXP 16
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// sEngine := false ;
4012: LD_ADDR_EXP 18
4016: PUSH
4017: LD_INT 0
4019: ST_TO_ADDR
// sSpec := false ;
4020: LD_ADDR_EXP 15
4024: PUSH
4025: LD_INT 0
4027: ST_TO_ADDR
// sLevel := false ;
4028: LD_ADDR_EXP 19
4032: PUSH
4033: LD_INT 0
4035: ST_TO_ADDR
// sArmoury := false ;
4036: LD_ADDR_EXP 20
4040: PUSH
4041: LD_INT 0
4043: ST_TO_ADDR
// sRadar := false ;
4044: LD_ADDR_EXP 21
4048: PUSH
4049: LD_INT 0
4051: ST_TO_ADDR
// sBunker := false ;
4052: LD_ADDR_EXP 22
4056: PUSH
4057: LD_INT 0
4059: ST_TO_ADDR
// sHack := false ;
4060: LD_ADDR_EXP 23
4064: PUSH
4065: LD_INT 0
4067: ST_TO_ADDR
// sFire := false ;
4068: LD_ADDR_EXP 24
4072: PUSH
4073: LD_INT 0
4075: ST_TO_ADDR
// sRefresh := false ;
4076: LD_ADDR_EXP 25
4080: PUSH
4081: LD_INT 0
4083: ST_TO_ADDR
// sExp := false ;
4084: LD_ADDR_EXP 26
4088: PUSH
4089: LD_INT 0
4091: ST_TO_ADDR
// sDepot := false ;
4092: LD_ADDR_EXP 27
4096: PUSH
4097: LD_INT 0
4099: ST_TO_ADDR
// sFlag := false ;
4100: LD_ADDR_EXP 28
4104: PUSH
4105: LD_INT 0
4107: ST_TO_ADDR
// sKamikadze := false ;
4108: LD_ADDR_EXP 36
4112: PUSH
4113: LD_INT 0
4115: ST_TO_ADDR
// sTroll := false ;
4116: LD_ADDR_EXP 37
4120: PUSH
4121: LD_INT 0
4123: ST_TO_ADDR
// sSlow := false ;
4124: LD_ADDR_EXP 38
4128: PUSH
4129: LD_INT 0
4131: ST_TO_ADDR
// sLack := false ;
4132: LD_ADDR_EXP 39
4136: PUSH
4137: LD_INT 0
4139: ST_TO_ADDR
// sTank := false ;
4140: LD_ADDR_EXP 41
4144: PUSH
4145: LD_INT 0
4147: ST_TO_ADDR
// sRemote := false ;
4148: LD_ADDR_EXP 42
4152: PUSH
4153: LD_INT 0
4155: ST_TO_ADDR
// sPowell := false ;
4156: LD_ADDR_EXP 43
4160: PUSH
4161: LD_INT 0
4163: ST_TO_ADDR
// sTeleport := false ;
4164: LD_ADDR_EXP 46
4168: PUSH
4169: LD_INT 0
4171: ST_TO_ADDR
// sOilTower := false ;
4172: LD_ADDR_EXP 48
4176: PUSH
4177: LD_INT 0
4179: ST_TO_ADDR
// sShovel := false ;
4180: LD_ADDR_EXP 49
4184: PUSH
4185: LD_INT 0
4187: ST_TO_ADDR
// sSheik := false ;
4188: LD_ADDR_EXP 50
4192: PUSH
4193: LD_INT 0
4195: ST_TO_ADDR
// sEarthquake := false ;
4196: LD_ADDR_EXP 52
4200: PUSH
4201: LD_INT 0
4203: ST_TO_ADDR
// sAI := false ;
4204: LD_ADDR_EXP 53
4208: PUSH
4209: LD_INT 0
4211: ST_TO_ADDR
// sCargo := false ;
4212: LD_ADDR_EXP 56
4216: PUSH
4217: LD_INT 0
4219: ST_TO_ADDR
// sDLaser := false ;
4220: LD_ADDR_EXP 57
4224: PUSH
4225: LD_INT 0
4227: ST_TO_ADDR
// sExchange := false ;
4228: LD_ADDR_EXP 58
4232: PUSH
4233: LD_INT 0
4235: ST_TO_ADDR
// sFac := false ;
4236: LD_ADDR_EXP 59
4240: PUSH
4241: LD_INT 0
4243: ST_TO_ADDR
// sPower := false ;
4244: LD_ADDR_EXP 60
4248: PUSH
4249: LD_INT 0
4251: ST_TO_ADDR
// sRandom := false ;
4252: LD_ADDR_EXP 61
4256: PUSH
4257: LD_INT 0
4259: ST_TO_ADDR
// sShield := false ;
4260: LD_ADDR_EXP 62
4264: PUSH
4265: LD_INT 0
4267: ST_TO_ADDR
// sTime := false ;
4268: LD_ADDR_EXP 63
4272: PUSH
4273: LD_INT 0
4275: ST_TO_ADDR
// sTools := false ;
4276: LD_ADDR_EXP 64
4280: PUSH
4281: LD_INT 0
4283: ST_TO_ADDR
// sSold := false ;
4284: LD_ADDR_EXP 29
4288: PUSH
4289: LD_INT 0
4291: ST_TO_ADDR
// sDiff := false ;
4292: LD_ADDR_EXP 30
4296: PUSH
4297: LD_INT 0
4299: ST_TO_ADDR
// sFog := false ;
4300: LD_ADDR_EXP 33
4304: PUSH
4305: LD_INT 0
4307: ST_TO_ADDR
// sReset := false ;
4308: LD_ADDR_EXP 34
4312: PUSH
4313: LD_INT 0
4315: ST_TO_ADDR
// sSun := false ;
4316: LD_ADDR_EXP 35
4320: PUSH
4321: LD_INT 0
4323: ST_TO_ADDR
// sTiger := false ;
4324: LD_ADDR_EXP 31
4328: PUSH
4329: LD_INT 0
4331: ST_TO_ADDR
// sBomb := false ;
4332: LD_ADDR_EXP 32
4336: PUSH
4337: LD_INT 0
4339: ST_TO_ADDR
// sWound := false ;
4340: LD_ADDR_EXP 40
4344: PUSH
4345: LD_INT 0
4347: ST_TO_ADDR
// sBetray := false ;
4348: LD_ADDR_EXP 44
4352: PUSH
4353: LD_INT 0
4355: ST_TO_ADDR
// sContamin := false ;
4356: LD_ADDR_EXP 45
4360: PUSH
4361: LD_INT 0
4363: ST_TO_ADDR
// sOil := false ;
4364: LD_ADDR_EXP 47
4368: PUSH
4369: LD_INT 0
4371: ST_TO_ADDR
// sStu := false ;
4372: LD_ADDR_EXP 51
4376: PUSH
4377: LD_INT 0
4379: ST_TO_ADDR
// sBazooka := false ;
4380: LD_ADDR_EXP 54
4384: PUSH
4385: LD_INT 0
4387: ST_TO_ADDR
// sMortar := false ;
4388: LD_ADDR_EXP 55
4392: PUSH
4393: LD_INT 0
4395: ST_TO_ADDR
// sRanger := false ;
4396: LD_ADDR_EXP 65
4400: PUSH
4401: LD_INT 0
4403: ST_TO_ADDR
// end ;
4404: LD_VAR 0 1
4408: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
4409: LD_INT 0
4411: PPUSH
4412: PPUSH
4413: PPUSH
4414: PPUSH
4415: PPUSH
// result := [ ] ;
4416: LD_ADDR_VAR 0 1
4420: PUSH
4421: EMPTY
4422: ST_TO_ADDR
// if campaign_id = 1 then
4423: LD_OWVAR 69
4427: PUSH
4428: LD_INT 1
4430: EQUAL
4431: IFFALSE 7369
// begin case mission_number of 1 :
4433: LD_OWVAR 70
4437: PUSH
4438: LD_INT 1
4440: DOUBLE
4441: EQUAL
4442: IFTRUE 4446
4444: GO 4510
4446: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
4447: LD_ADDR_VAR 0 1
4451: PUSH
4452: LD_INT 2
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: LD_INT 11
4460: PUSH
4461: LD_INT 12
4463: PUSH
4464: LD_INT 15
4466: PUSH
4467: LD_INT 16
4469: PUSH
4470: LD_INT 22
4472: PUSH
4473: LD_INT 23
4475: PUSH
4476: LD_INT 26
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: LIST
4488: LIST
4489: PUSH
4490: LD_INT 101
4492: PUSH
4493: LD_INT 102
4495: PUSH
4496: LD_INT 106
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: LIST
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: ST_TO_ADDR
4508: GO 7367
4510: LD_INT 2
4512: DOUBLE
4513: EQUAL
4514: IFTRUE 4518
4516: GO 4590
4518: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
4519: LD_ADDR_VAR 0 1
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: LD_INT 4
4529: PUSH
4530: LD_INT 11
4532: PUSH
4533: LD_INT 12
4535: PUSH
4536: LD_INT 15
4538: PUSH
4539: LD_INT 16
4541: PUSH
4542: LD_INT 22
4544: PUSH
4545: LD_INT 23
4547: PUSH
4548: LD_INT 26
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: LIST
4560: LIST
4561: PUSH
4562: LD_INT 101
4564: PUSH
4565: LD_INT 102
4567: PUSH
4568: LD_INT 105
4570: PUSH
4571: LD_INT 106
4573: PUSH
4574: LD_INT 108
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: ST_TO_ADDR
4588: GO 7367
4590: LD_INT 3
4592: DOUBLE
4593: EQUAL
4594: IFTRUE 4598
4596: GO 4674
4598: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
4599: LD_ADDR_VAR 0 1
4603: PUSH
4604: LD_INT 2
4606: PUSH
4607: LD_INT 4
4609: PUSH
4610: LD_INT 5
4612: PUSH
4613: LD_INT 11
4615: PUSH
4616: LD_INT 12
4618: PUSH
4619: LD_INT 15
4621: PUSH
4622: LD_INT 16
4624: PUSH
4625: LD_INT 22
4627: PUSH
4628: LD_INT 26
4630: PUSH
4631: LD_INT 36
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: LIST
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 101
4648: PUSH
4649: LD_INT 102
4651: PUSH
4652: LD_INT 105
4654: PUSH
4655: LD_INT 106
4657: PUSH
4658: LD_INT 108
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: ST_TO_ADDR
4672: GO 7367
4674: LD_INT 4
4676: DOUBLE
4677: EQUAL
4678: IFTRUE 4682
4680: GO 4766
4682: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
4683: LD_ADDR_VAR 0 1
4687: PUSH
4688: LD_INT 2
4690: PUSH
4691: LD_INT 4
4693: PUSH
4694: LD_INT 5
4696: PUSH
4697: LD_INT 8
4699: PUSH
4700: LD_INT 11
4702: PUSH
4703: LD_INT 12
4705: PUSH
4706: LD_INT 15
4708: PUSH
4709: LD_INT 16
4711: PUSH
4712: LD_INT 22
4714: PUSH
4715: LD_INT 23
4717: PUSH
4718: LD_INT 26
4720: PUSH
4721: LD_INT 36
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: LIST
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 101
4740: PUSH
4741: LD_INT 102
4743: PUSH
4744: LD_INT 105
4746: PUSH
4747: LD_INT 106
4749: PUSH
4750: LD_INT 108
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: ST_TO_ADDR
4764: GO 7367
4766: LD_INT 5
4768: DOUBLE
4769: EQUAL
4770: IFTRUE 4774
4772: GO 4874
4774: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
4775: LD_ADDR_VAR 0 1
4779: PUSH
4780: LD_INT 2
4782: PUSH
4783: LD_INT 4
4785: PUSH
4786: LD_INT 5
4788: PUSH
4789: LD_INT 6
4791: PUSH
4792: LD_INT 8
4794: PUSH
4795: LD_INT 11
4797: PUSH
4798: LD_INT 12
4800: PUSH
4801: LD_INT 15
4803: PUSH
4804: LD_INT 16
4806: PUSH
4807: LD_INT 22
4809: PUSH
4810: LD_INT 23
4812: PUSH
4813: LD_INT 25
4815: PUSH
4816: LD_INT 26
4818: PUSH
4819: LD_INT 36
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 101
4840: PUSH
4841: LD_INT 102
4843: PUSH
4844: LD_INT 105
4846: PUSH
4847: LD_INT 106
4849: PUSH
4850: LD_INT 108
4852: PUSH
4853: LD_INT 109
4855: PUSH
4856: LD_INT 112
4858: PUSH
4859: EMPTY
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: ST_TO_ADDR
4872: GO 7367
4874: LD_INT 6
4876: DOUBLE
4877: EQUAL
4878: IFTRUE 4882
4880: GO 5002
4882: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
4883: LD_ADDR_VAR 0 1
4887: PUSH
4888: LD_INT 2
4890: PUSH
4891: LD_INT 4
4893: PUSH
4894: LD_INT 5
4896: PUSH
4897: LD_INT 6
4899: PUSH
4900: LD_INT 8
4902: PUSH
4903: LD_INT 11
4905: PUSH
4906: LD_INT 12
4908: PUSH
4909: LD_INT 15
4911: PUSH
4912: LD_INT 16
4914: PUSH
4915: LD_INT 20
4917: PUSH
4918: LD_INT 21
4920: PUSH
4921: LD_INT 22
4923: PUSH
4924: LD_INT 23
4926: PUSH
4927: LD_INT 25
4929: PUSH
4930: LD_INT 26
4932: PUSH
4933: LD_INT 30
4935: PUSH
4936: LD_INT 31
4938: PUSH
4939: LD_INT 32
4941: PUSH
4942: LD_INT 36
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: LIST
4952: LIST
4953: LIST
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 101
4968: PUSH
4969: LD_INT 102
4971: PUSH
4972: LD_INT 105
4974: PUSH
4975: LD_INT 106
4977: PUSH
4978: LD_INT 108
4980: PUSH
4981: LD_INT 109
4983: PUSH
4984: LD_INT 112
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: ST_TO_ADDR
5000: GO 7367
5002: LD_INT 7
5004: DOUBLE
5005: EQUAL
5006: IFTRUE 5010
5008: GO 5110
5010: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
5011: LD_ADDR_VAR 0 1
5015: PUSH
5016: LD_INT 2
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 5
5024: PUSH
5025: LD_INT 7
5027: PUSH
5028: LD_INT 11
5030: PUSH
5031: LD_INT 12
5033: PUSH
5034: LD_INT 15
5036: PUSH
5037: LD_INT 16
5039: PUSH
5040: LD_INT 20
5042: PUSH
5043: LD_INT 21
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 23
5051: PUSH
5052: LD_INT 25
5054: PUSH
5055: LD_INT 26
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: LIST
5062: LIST
5063: LIST
5064: LIST
5065: LIST
5066: LIST
5067: LIST
5068: LIST
5069: LIST
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: LD_INT 101
5076: PUSH
5077: LD_INT 102
5079: PUSH
5080: LD_INT 103
5082: PUSH
5083: LD_INT 105
5085: PUSH
5086: LD_INT 106
5088: PUSH
5089: LD_INT 108
5091: PUSH
5092: LD_INT 112
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: ST_TO_ADDR
5108: GO 7367
5110: LD_INT 8
5112: DOUBLE
5113: EQUAL
5114: IFTRUE 5118
5116: GO 5246
5118: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
5119: LD_ADDR_VAR 0 1
5123: PUSH
5124: LD_INT 2
5126: PUSH
5127: LD_INT 4
5129: PUSH
5130: LD_INT 5
5132: PUSH
5133: LD_INT 6
5135: PUSH
5136: LD_INT 7
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: LD_INT 11
5144: PUSH
5145: LD_INT 12
5147: PUSH
5148: LD_INT 15
5150: PUSH
5151: LD_INT 16
5153: PUSH
5154: LD_INT 20
5156: PUSH
5157: LD_INT 21
5159: PUSH
5160: LD_INT 22
5162: PUSH
5163: LD_INT 23
5165: PUSH
5166: LD_INT 25
5168: PUSH
5169: LD_INT 26
5171: PUSH
5172: LD_INT 30
5174: PUSH
5175: LD_INT 31
5177: PUSH
5178: LD_INT 32
5180: PUSH
5181: LD_INT 36
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: PUSH
5206: LD_INT 101
5208: PUSH
5209: LD_INT 102
5211: PUSH
5212: LD_INT 103
5214: PUSH
5215: LD_INT 105
5217: PUSH
5218: LD_INT 106
5220: PUSH
5221: LD_INT 108
5223: PUSH
5224: LD_INT 109
5226: PUSH
5227: LD_INT 112
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: ST_TO_ADDR
5244: GO 7367
5246: LD_INT 9
5248: DOUBLE
5249: EQUAL
5250: IFTRUE 5254
5252: GO 5390
5254: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
5255: LD_ADDR_VAR 0 1
5259: PUSH
5260: LD_INT 2
5262: PUSH
5263: LD_INT 4
5265: PUSH
5266: LD_INT 5
5268: PUSH
5269: LD_INT 6
5271: PUSH
5272: LD_INT 7
5274: PUSH
5275: LD_INT 8
5277: PUSH
5278: LD_INT 11
5280: PUSH
5281: LD_INT 12
5283: PUSH
5284: LD_INT 15
5286: PUSH
5287: LD_INT 16
5289: PUSH
5290: LD_INT 20
5292: PUSH
5293: LD_INT 21
5295: PUSH
5296: LD_INT 22
5298: PUSH
5299: LD_INT 23
5301: PUSH
5302: LD_INT 25
5304: PUSH
5305: LD_INT 26
5307: PUSH
5308: LD_INT 28
5310: PUSH
5311: LD_INT 30
5313: PUSH
5314: LD_INT 31
5316: PUSH
5317: LD_INT 32
5319: PUSH
5320: LD_INT 36
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: LIST
5332: LIST
5333: LIST
5334: LIST
5335: LIST
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: LIST
5343: LIST
5344: LIST
5345: PUSH
5346: LD_INT 101
5348: PUSH
5349: LD_INT 102
5351: PUSH
5352: LD_INT 103
5354: PUSH
5355: LD_INT 105
5357: PUSH
5358: LD_INT 106
5360: PUSH
5361: LD_INT 108
5363: PUSH
5364: LD_INT 109
5366: PUSH
5367: LD_INT 112
5369: PUSH
5370: LD_INT 114
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: LIST
5379: LIST
5380: LIST
5381: LIST
5382: LIST
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: ST_TO_ADDR
5388: GO 7367
5390: LD_INT 10
5392: DOUBLE
5393: EQUAL
5394: IFTRUE 5398
5396: GO 5582
5398: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
5399: LD_ADDR_VAR 0 1
5403: PUSH
5404: LD_INT 2
5406: PUSH
5407: LD_INT 4
5409: PUSH
5410: LD_INT 5
5412: PUSH
5413: LD_INT 6
5415: PUSH
5416: LD_INT 7
5418: PUSH
5419: LD_INT 8
5421: PUSH
5422: LD_INT 9
5424: PUSH
5425: LD_INT 10
5427: PUSH
5428: LD_INT 11
5430: PUSH
5431: LD_INT 12
5433: PUSH
5434: LD_INT 13
5436: PUSH
5437: LD_INT 14
5439: PUSH
5440: LD_INT 15
5442: PUSH
5443: LD_INT 16
5445: PUSH
5446: LD_INT 17
5448: PUSH
5449: LD_INT 18
5451: PUSH
5452: LD_INT 19
5454: PUSH
5455: LD_INT 20
5457: PUSH
5458: LD_INT 21
5460: PUSH
5461: LD_INT 22
5463: PUSH
5464: LD_INT 23
5466: PUSH
5467: LD_INT 24
5469: PUSH
5470: LD_INT 25
5472: PUSH
5473: LD_INT 26
5475: PUSH
5476: LD_INT 28
5478: PUSH
5479: LD_INT 30
5481: PUSH
5482: LD_INT 31
5484: PUSH
5485: LD_INT 32
5487: PUSH
5488: LD_INT 36
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: LIST
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 101
5524: PUSH
5525: LD_INT 102
5527: PUSH
5528: LD_INT 103
5530: PUSH
5531: LD_INT 104
5533: PUSH
5534: LD_INT 105
5536: PUSH
5537: LD_INT 106
5539: PUSH
5540: LD_INT 107
5542: PUSH
5543: LD_INT 108
5545: PUSH
5546: LD_INT 109
5548: PUSH
5549: LD_INT 110
5551: PUSH
5552: LD_INT 111
5554: PUSH
5555: LD_INT 112
5557: PUSH
5558: LD_INT 114
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: ST_TO_ADDR
5580: GO 7367
5582: LD_INT 11
5584: DOUBLE
5585: EQUAL
5586: IFTRUE 5590
5588: GO 5782
5590: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
5591: LD_ADDR_VAR 0 1
5595: PUSH
5596: LD_INT 2
5598: PUSH
5599: LD_INT 3
5601: PUSH
5602: LD_INT 4
5604: PUSH
5605: LD_INT 5
5607: PUSH
5608: LD_INT 6
5610: PUSH
5611: LD_INT 7
5613: PUSH
5614: LD_INT 8
5616: PUSH
5617: LD_INT 9
5619: PUSH
5620: LD_INT 10
5622: PUSH
5623: LD_INT 11
5625: PUSH
5626: LD_INT 12
5628: PUSH
5629: LD_INT 13
5631: PUSH
5632: LD_INT 14
5634: PUSH
5635: LD_INT 15
5637: PUSH
5638: LD_INT 16
5640: PUSH
5641: LD_INT 17
5643: PUSH
5644: LD_INT 18
5646: PUSH
5647: LD_INT 19
5649: PUSH
5650: LD_INT 20
5652: PUSH
5653: LD_INT 21
5655: PUSH
5656: LD_INT 22
5658: PUSH
5659: LD_INT 23
5661: PUSH
5662: LD_INT 24
5664: PUSH
5665: LD_INT 25
5667: PUSH
5668: LD_INT 26
5670: PUSH
5671: LD_INT 28
5673: PUSH
5674: LD_INT 30
5676: PUSH
5677: LD_INT 31
5679: PUSH
5680: LD_INT 32
5682: PUSH
5683: LD_INT 34
5685: PUSH
5686: LD_INT 36
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: LD_INT 101
5724: PUSH
5725: LD_INT 102
5727: PUSH
5728: LD_INT 103
5730: PUSH
5731: LD_INT 104
5733: PUSH
5734: LD_INT 105
5736: PUSH
5737: LD_INT 106
5739: PUSH
5740: LD_INT 107
5742: PUSH
5743: LD_INT 108
5745: PUSH
5746: LD_INT 109
5748: PUSH
5749: LD_INT 110
5751: PUSH
5752: LD_INT 111
5754: PUSH
5755: LD_INT 112
5757: PUSH
5758: LD_INT 114
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: ST_TO_ADDR
5780: GO 7367
5782: LD_INT 12
5784: DOUBLE
5785: EQUAL
5786: IFTRUE 5790
5788: GO 5998
5790: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
5791: LD_ADDR_VAR 0 1
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 3
5804: PUSH
5805: LD_INT 4
5807: PUSH
5808: LD_INT 5
5810: PUSH
5811: LD_INT 6
5813: PUSH
5814: LD_INT 7
5816: PUSH
5817: LD_INT 8
5819: PUSH
5820: LD_INT 9
5822: PUSH
5823: LD_INT 10
5825: PUSH
5826: LD_INT 11
5828: PUSH
5829: LD_INT 12
5831: PUSH
5832: LD_INT 13
5834: PUSH
5835: LD_INT 14
5837: PUSH
5838: LD_INT 15
5840: PUSH
5841: LD_INT 16
5843: PUSH
5844: LD_INT 17
5846: PUSH
5847: LD_INT 18
5849: PUSH
5850: LD_INT 19
5852: PUSH
5853: LD_INT 20
5855: PUSH
5856: LD_INT 21
5858: PUSH
5859: LD_INT 22
5861: PUSH
5862: LD_INT 23
5864: PUSH
5865: LD_INT 24
5867: PUSH
5868: LD_INT 25
5870: PUSH
5871: LD_INT 26
5873: PUSH
5874: LD_INT 27
5876: PUSH
5877: LD_INT 28
5879: PUSH
5880: LD_INT 30
5882: PUSH
5883: LD_INT 31
5885: PUSH
5886: LD_INT 32
5888: PUSH
5889: LD_INT 33
5891: PUSH
5892: LD_INT 34
5894: PUSH
5895: LD_INT 36
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: PUSH
5934: LD_INT 101
5936: PUSH
5937: LD_INT 102
5939: PUSH
5940: LD_INT 103
5942: PUSH
5943: LD_INT 104
5945: PUSH
5946: LD_INT 105
5948: PUSH
5949: LD_INT 106
5951: PUSH
5952: LD_INT 107
5954: PUSH
5955: LD_INT 108
5957: PUSH
5958: LD_INT 109
5960: PUSH
5961: LD_INT 110
5963: PUSH
5964: LD_INT 111
5966: PUSH
5967: LD_INT 112
5969: PUSH
5970: LD_INT 113
5972: PUSH
5973: LD_INT 114
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: ST_TO_ADDR
5996: GO 7367
5998: LD_INT 13
6000: DOUBLE
6001: EQUAL
6002: IFTRUE 6006
6004: GO 6202
6006: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
6007: LD_ADDR_VAR 0 1
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: LD_INT 2
6017: PUSH
6018: LD_INT 3
6020: PUSH
6021: LD_INT 4
6023: PUSH
6024: LD_INT 5
6026: PUSH
6027: LD_INT 8
6029: PUSH
6030: LD_INT 9
6032: PUSH
6033: LD_INT 10
6035: PUSH
6036: LD_INT 11
6038: PUSH
6039: LD_INT 12
6041: PUSH
6042: LD_INT 14
6044: PUSH
6045: LD_INT 15
6047: PUSH
6048: LD_INT 16
6050: PUSH
6051: LD_INT 17
6053: PUSH
6054: LD_INT 18
6056: PUSH
6057: LD_INT 19
6059: PUSH
6060: LD_INT 20
6062: PUSH
6063: LD_INT 21
6065: PUSH
6066: LD_INT 22
6068: PUSH
6069: LD_INT 23
6071: PUSH
6072: LD_INT 24
6074: PUSH
6075: LD_INT 25
6077: PUSH
6078: LD_INT 26
6080: PUSH
6081: LD_INT 27
6083: PUSH
6084: LD_INT 28
6086: PUSH
6087: LD_INT 30
6089: PUSH
6090: LD_INT 31
6092: PUSH
6093: LD_INT 32
6095: PUSH
6096: LD_INT 33
6098: PUSH
6099: LD_INT 34
6101: PUSH
6102: LD_INT 36
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 101
6140: PUSH
6141: LD_INT 102
6143: PUSH
6144: LD_INT 103
6146: PUSH
6147: LD_INT 104
6149: PUSH
6150: LD_INT 105
6152: PUSH
6153: LD_INT 106
6155: PUSH
6156: LD_INT 107
6158: PUSH
6159: LD_INT 108
6161: PUSH
6162: LD_INT 109
6164: PUSH
6165: LD_INT 110
6167: PUSH
6168: LD_INT 111
6170: PUSH
6171: LD_INT 112
6173: PUSH
6174: LD_INT 113
6176: PUSH
6177: LD_INT 114
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: LIST
6194: LIST
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: ST_TO_ADDR
6200: GO 7367
6202: LD_INT 14
6204: DOUBLE
6205: EQUAL
6206: IFTRUE 6210
6208: GO 6422
6210: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
6211: LD_ADDR_VAR 0 1
6215: PUSH
6216: LD_INT 1
6218: PUSH
6219: LD_INT 2
6221: PUSH
6222: LD_INT 3
6224: PUSH
6225: LD_INT 4
6227: PUSH
6228: LD_INT 5
6230: PUSH
6231: LD_INT 6
6233: PUSH
6234: LD_INT 7
6236: PUSH
6237: LD_INT 8
6239: PUSH
6240: LD_INT 9
6242: PUSH
6243: LD_INT 10
6245: PUSH
6246: LD_INT 11
6248: PUSH
6249: LD_INT 12
6251: PUSH
6252: LD_INT 13
6254: PUSH
6255: LD_INT 14
6257: PUSH
6258: LD_INT 15
6260: PUSH
6261: LD_INT 16
6263: PUSH
6264: LD_INT 17
6266: PUSH
6267: LD_INT 18
6269: PUSH
6270: LD_INT 19
6272: PUSH
6273: LD_INT 20
6275: PUSH
6276: LD_INT 21
6278: PUSH
6279: LD_INT 22
6281: PUSH
6282: LD_INT 23
6284: PUSH
6285: LD_INT 24
6287: PUSH
6288: LD_INT 25
6290: PUSH
6291: LD_INT 26
6293: PUSH
6294: LD_INT 27
6296: PUSH
6297: LD_INT 28
6299: PUSH
6300: LD_INT 29
6302: PUSH
6303: LD_INT 30
6305: PUSH
6306: LD_INT 31
6308: PUSH
6309: LD_INT 32
6311: PUSH
6312: LD_INT 33
6314: PUSH
6315: LD_INT 34
6317: PUSH
6318: LD_INT 36
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: LIST
6345: LIST
6346: LIST
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 101
6360: PUSH
6361: LD_INT 102
6363: PUSH
6364: LD_INT 103
6366: PUSH
6367: LD_INT 104
6369: PUSH
6370: LD_INT 105
6372: PUSH
6373: LD_INT 106
6375: PUSH
6376: LD_INT 107
6378: PUSH
6379: LD_INT 108
6381: PUSH
6382: LD_INT 109
6384: PUSH
6385: LD_INT 110
6387: PUSH
6388: LD_INT 111
6390: PUSH
6391: LD_INT 112
6393: PUSH
6394: LD_INT 113
6396: PUSH
6397: LD_INT 114
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: LIST
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: ST_TO_ADDR
6420: GO 7367
6422: LD_INT 15
6424: DOUBLE
6425: EQUAL
6426: IFTRUE 6430
6428: GO 6642
6430: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
6431: LD_ADDR_VAR 0 1
6435: PUSH
6436: LD_INT 1
6438: PUSH
6439: LD_INT 2
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 4
6447: PUSH
6448: LD_INT 5
6450: PUSH
6451: LD_INT 6
6453: PUSH
6454: LD_INT 7
6456: PUSH
6457: LD_INT 8
6459: PUSH
6460: LD_INT 9
6462: PUSH
6463: LD_INT 10
6465: PUSH
6466: LD_INT 11
6468: PUSH
6469: LD_INT 12
6471: PUSH
6472: LD_INT 13
6474: PUSH
6475: LD_INT 14
6477: PUSH
6478: LD_INT 15
6480: PUSH
6481: LD_INT 16
6483: PUSH
6484: LD_INT 17
6486: PUSH
6487: LD_INT 18
6489: PUSH
6490: LD_INT 19
6492: PUSH
6493: LD_INT 20
6495: PUSH
6496: LD_INT 21
6498: PUSH
6499: LD_INT 22
6501: PUSH
6502: LD_INT 23
6504: PUSH
6505: LD_INT 24
6507: PUSH
6508: LD_INT 25
6510: PUSH
6511: LD_INT 26
6513: PUSH
6514: LD_INT 27
6516: PUSH
6517: LD_INT 28
6519: PUSH
6520: LD_INT 29
6522: PUSH
6523: LD_INT 30
6525: PUSH
6526: LD_INT 31
6528: PUSH
6529: LD_INT 32
6531: PUSH
6532: LD_INT 33
6534: PUSH
6535: LD_INT 34
6537: PUSH
6538: LD_INT 36
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: LIST
6550: LIST
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: LIST
6565: LIST
6566: LIST
6567: LIST
6568: LIST
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: LIST
6576: LIST
6577: PUSH
6578: LD_INT 101
6580: PUSH
6581: LD_INT 102
6583: PUSH
6584: LD_INT 103
6586: PUSH
6587: LD_INT 104
6589: PUSH
6590: LD_INT 105
6592: PUSH
6593: LD_INT 106
6595: PUSH
6596: LD_INT 107
6598: PUSH
6599: LD_INT 108
6601: PUSH
6602: LD_INT 109
6604: PUSH
6605: LD_INT 110
6607: PUSH
6608: LD_INT 111
6610: PUSH
6611: LD_INT 112
6613: PUSH
6614: LD_INT 113
6616: PUSH
6617: LD_INT 114
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: ST_TO_ADDR
6640: GO 7367
6642: LD_INT 16
6644: DOUBLE
6645: EQUAL
6646: IFTRUE 6650
6648: GO 6774
6650: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
6651: LD_ADDR_VAR 0 1
6655: PUSH
6656: LD_INT 2
6658: PUSH
6659: LD_INT 4
6661: PUSH
6662: LD_INT 5
6664: PUSH
6665: LD_INT 7
6667: PUSH
6668: LD_INT 11
6670: PUSH
6671: LD_INT 12
6673: PUSH
6674: LD_INT 15
6676: PUSH
6677: LD_INT 16
6679: PUSH
6680: LD_INT 20
6682: PUSH
6683: LD_INT 21
6685: PUSH
6686: LD_INT 22
6688: PUSH
6689: LD_INT 23
6691: PUSH
6692: LD_INT 25
6694: PUSH
6695: LD_INT 26
6697: PUSH
6698: LD_INT 30
6700: PUSH
6701: LD_INT 31
6703: PUSH
6704: LD_INT 32
6706: PUSH
6707: LD_INT 33
6709: PUSH
6710: LD_INT 34
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: PUSH
6734: LD_INT 101
6736: PUSH
6737: LD_INT 102
6739: PUSH
6740: LD_INT 103
6742: PUSH
6743: LD_INT 106
6745: PUSH
6746: LD_INT 108
6748: PUSH
6749: LD_INT 112
6751: PUSH
6752: LD_INT 113
6754: PUSH
6755: LD_INT 114
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: PUSH
6768: EMPTY
6769: LIST
6770: LIST
6771: ST_TO_ADDR
6772: GO 7367
6774: LD_INT 17
6776: DOUBLE
6777: EQUAL
6778: IFTRUE 6782
6780: GO 6994
6782: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: LD_INT 1
6790: PUSH
6791: LD_INT 2
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 4
6799: PUSH
6800: LD_INT 5
6802: PUSH
6803: LD_INT 6
6805: PUSH
6806: LD_INT 7
6808: PUSH
6809: LD_INT 8
6811: PUSH
6812: LD_INT 9
6814: PUSH
6815: LD_INT 10
6817: PUSH
6818: LD_INT 11
6820: PUSH
6821: LD_INT 12
6823: PUSH
6824: LD_INT 13
6826: PUSH
6827: LD_INT 14
6829: PUSH
6830: LD_INT 15
6832: PUSH
6833: LD_INT 16
6835: PUSH
6836: LD_INT 17
6838: PUSH
6839: LD_INT 18
6841: PUSH
6842: LD_INT 19
6844: PUSH
6845: LD_INT 20
6847: PUSH
6848: LD_INT 21
6850: PUSH
6851: LD_INT 22
6853: PUSH
6854: LD_INT 23
6856: PUSH
6857: LD_INT 24
6859: PUSH
6860: LD_INT 25
6862: PUSH
6863: LD_INT 26
6865: PUSH
6866: LD_INT 27
6868: PUSH
6869: LD_INT 28
6871: PUSH
6872: LD_INT 29
6874: PUSH
6875: LD_INT 30
6877: PUSH
6878: LD_INT 31
6880: PUSH
6881: LD_INT 32
6883: PUSH
6884: LD_INT 33
6886: PUSH
6887: LD_INT 34
6889: PUSH
6890: LD_INT 36
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: LIST
6901: LIST
6902: LIST
6903: LIST
6904: LIST
6905: LIST
6906: LIST
6907: LIST
6908: LIST
6909: LIST
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: LIST
6928: LIST
6929: PUSH
6930: LD_INT 101
6932: PUSH
6933: LD_INT 102
6935: PUSH
6936: LD_INT 103
6938: PUSH
6939: LD_INT 104
6941: PUSH
6942: LD_INT 105
6944: PUSH
6945: LD_INT 106
6947: PUSH
6948: LD_INT 107
6950: PUSH
6951: LD_INT 108
6953: PUSH
6954: LD_INT 109
6956: PUSH
6957: LD_INT 110
6959: PUSH
6960: LD_INT 111
6962: PUSH
6963: LD_INT 112
6965: PUSH
6966: LD_INT 113
6968: PUSH
6969: LD_INT 114
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: LIST
6981: LIST
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: LIST
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: ST_TO_ADDR
6992: GO 7367
6994: LD_INT 18
6996: DOUBLE
6997: EQUAL
6998: IFTRUE 7002
7000: GO 7138
7002: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
7003: LD_ADDR_VAR 0 1
7007: PUSH
7008: LD_INT 2
7010: PUSH
7011: LD_INT 4
7013: PUSH
7014: LD_INT 5
7016: PUSH
7017: LD_INT 7
7019: PUSH
7020: LD_INT 11
7022: PUSH
7023: LD_INT 12
7025: PUSH
7026: LD_INT 15
7028: PUSH
7029: LD_INT 16
7031: PUSH
7032: LD_INT 20
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_INT 23
7043: PUSH
7044: LD_INT 25
7046: PUSH
7047: LD_INT 26
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 31
7055: PUSH
7056: LD_INT 32
7058: PUSH
7059: LD_INT 33
7061: PUSH
7062: LD_INT 34
7064: PUSH
7065: LD_INT 35
7067: PUSH
7068: LD_INT 36
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: LIST
7076: LIST
7077: LIST
7078: LIST
7079: LIST
7080: LIST
7081: LIST
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 101
7096: PUSH
7097: LD_INT 102
7099: PUSH
7100: LD_INT 103
7102: PUSH
7103: LD_INT 106
7105: PUSH
7106: LD_INT 108
7108: PUSH
7109: LD_INT 112
7111: PUSH
7112: LD_INT 113
7114: PUSH
7115: LD_INT 114
7117: PUSH
7118: LD_INT 115
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: ST_TO_ADDR
7136: GO 7367
7138: LD_INT 19
7140: DOUBLE
7141: EQUAL
7142: IFTRUE 7146
7144: GO 7366
7146: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
7147: LD_ADDR_VAR 0 1
7151: PUSH
7152: LD_INT 1
7154: PUSH
7155: LD_INT 2
7157: PUSH
7158: LD_INT 3
7160: PUSH
7161: LD_INT 4
7163: PUSH
7164: LD_INT 5
7166: PUSH
7167: LD_INT 6
7169: PUSH
7170: LD_INT 7
7172: PUSH
7173: LD_INT 8
7175: PUSH
7176: LD_INT 9
7178: PUSH
7179: LD_INT 10
7181: PUSH
7182: LD_INT 11
7184: PUSH
7185: LD_INT 12
7187: PUSH
7188: LD_INT 13
7190: PUSH
7191: LD_INT 14
7193: PUSH
7194: LD_INT 15
7196: PUSH
7197: LD_INT 16
7199: PUSH
7200: LD_INT 17
7202: PUSH
7203: LD_INT 18
7205: PUSH
7206: LD_INT 19
7208: PUSH
7209: LD_INT 20
7211: PUSH
7212: LD_INT 21
7214: PUSH
7215: LD_INT 22
7217: PUSH
7218: LD_INT 23
7220: PUSH
7221: LD_INT 24
7223: PUSH
7224: LD_INT 25
7226: PUSH
7227: LD_INT 26
7229: PUSH
7230: LD_INT 27
7232: PUSH
7233: LD_INT 28
7235: PUSH
7236: LD_INT 29
7238: PUSH
7239: LD_INT 30
7241: PUSH
7242: LD_INT 31
7244: PUSH
7245: LD_INT 32
7247: PUSH
7248: LD_INT 33
7250: PUSH
7251: LD_INT 34
7253: PUSH
7254: LD_INT 35
7256: PUSH
7257: LD_INT 36
7259: PUSH
7260: EMPTY
7261: LIST
7262: LIST
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: LIST
7281: LIST
7282: LIST
7283: LIST
7284: LIST
7285: LIST
7286: LIST
7287: LIST
7288: LIST
7289: LIST
7290: LIST
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: LIST
7296: LIST
7297: PUSH
7298: LD_INT 101
7300: PUSH
7301: LD_INT 102
7303: PUSH
7304: LD_INT 103
7306: PUSH
7307: LD_INT 104
7309: PUSH
7310: LD_INT 105
7312: PUSH
7313: LD_INT 106
7315: PUSH
7316: LD_INT 107
7318: PUSH
7319: LD_INT 108
7321: PUSH
7322: LD_INT 109
7324: PUSH
7325: LD_INT 110
7327: PUSH
7328: LD_INT 111
7330: PUSH
7331: LD_INT 112
7333: PUSH
7334: LD_INT 113
7336: PUSH
7337: LD_INT 114
7339: PUSH
7340: LD_INT 115
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: ST_TO_ADDR
7364: GO 7367
7366: POP
// end else
7367: GO 7586
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
7369: LD_ADDR_VAR 0 1
7373: PUSH
7374: LD_INT 1
7376: PUSH
7377: LD_INT 2
7379: PUSH
7380: LD_INT 3
7382: PUSH
7383: LD_INT 4
7385: PUSH
7386: LD_INT 5
7388: PUSH
7389: LD_INT 6
7391: PUSH
7392: LD_INT 7
7394: PUSH
7395: LD_INT 8
7397: PUSH
7398: LD_INT 9
7400: PUSH
7401: LD_INT 10
7403: PUSH
7404: LD_INT 11
7406: PUSH
7407: LD_INT 12
7409: PUSH
7410: LD_INT 13
7412: PUSH
7413: LD_INT 14
7415: PUSH
7416: LD_INT 15
7418: PUSH
7419: LD_INT 16
7421: PUSH
7422: LD_INT 17
7424: PUSH
7425: LD_INT 18
7427: PUSH
7428: LD_INT 19
7430: PUSH
7431: LD_INT 20
7433: PUSH
7434: LD_INT 21
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 23
7442: PUSH
7443: LD_INT 24
7445: PUSH
7446: LD_INT 25
7448: PUSH
7449: LD_INT 26
7451: PUSH
7452: LD_INT 27
7454: PUSH
7455: LD_INT 28
7457: PUSH
7458: LD_INT 29
7460: PUSH
7461: LD_INT 30
7463: PUSH
7464: LD_INT 31
7466: PUSH
7467: LD_INT 32
7469: PUSH
7470: LD_INT 33
7472: PUSH
7473: LD_INT 34
7475: PUSH
7476: LD_INT 35
7478: PUSH
7479: LD_INT 36
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: LIST
7510: LIST
7511: LIST
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: LIST
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 101
7522: PUSH
7523: LD_INT 102
7525: PUSH
7526: LD_INT 103
7528: PUSH
7529: LD_INT 104
7531: PUSH
7532: LD_INT 105
7534: PUSH
7535: LD_INT 106
7537: PUSH
7538: LD_INT 107
7540: PUSH
7541: LD_INT 108
7543: PUSH
7544: LD_INT 109
7546: PUSH
7547: LD_INT 110
7549: PUSH
7550: LD_INT 111
7552: PUSH
7553: LD_INT 112
7555: PUSH
7556: LD_INT 113
7558: PUSH
7559: LD_INT 114
7561: PUSH
7562: LD_INT 115
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: ST_TO_ADDR
// if result then
7586: LD_VAR 0 1
7590: IFFALSE 7879
// begin normal :=  ;
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_STRING 
7599: ST_TO_ADDR
// hardcore :=  ;
7600: LD_ADDR_VAR 0 4
7604: PUSH
7605: LD_STRING 
7607: ST_TO_ADDR
// for i = 1 to normalCounter do
7608: LD_ADDR_VAR 0 5
7612: PUSH
7613: DOUBLE
7614: LD_INT 1
7616: DEC
7617: ST_TO_ADDR
7618: LD_EXP 13
7622: PUSH
7623: FOR_TO
7624: IFFALSE 7725
// begin tmp := 0 ;
7626: LD_ADDR_VAR 0 2
7630: PUSH
7631: LD_STRING 0
7633: ST_TO_ADDR
// if result [ 1 ] then
7634: LD_VAR 0 1
7638: PUSH
7639: LD_INT 1
7641: ARRAY
7642: IFFALSE 7707
// if result [ 1 ] [ 1 ] = i then
7644: LD_VAR 0 1
7648: PUSH
7649: LD_INT 1
7651: ARRAY
7652: PUSH
7653: LD_INT 1
7655: ARRAY
7656: PUSH
7657: LD_VAR 0 5
7661: EQUAL
7662: IFFALSE 7707
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
7664: LD_ADDR_VAR 0 1
7668: PUSH
7669: LD_VAR 0 1
7673: PPUSH
7674: LD_INT 1
7676: PPUSH
7677: LD_VAR 0 1
7681: PUSH
7682: LD_INT 1
7684: ARRAY
7685: PPUSH
7686: LD_INT 1
7688: PPUSH
7689: CALL_OW 3
7693: PPUSH
7694: CALL_OW 1
7698: ST_TO_ADDR
// tmp := 1 ;
7699: LD_ADDR_VAR 0 2
7703: PUSH
7704: LD_STRING 1
7706: ST_TO_ADDR
// end ; normal := normal & tmp ;
7707: LD_ADDR_VAR 0 3
7711: PUSH
7712: LD_VAR 0 3
7716: PUSH
7717: LD_VAR 0 2
7721: STR
7722: ST_TO_ADDR
// end ;
7723: GO 7623
7725: POP
7726: POP
// for i = 1 to hardcoreCounter do
7727: LD_ADDR_VAR 0 5
7731: PUSH
7732: DOUBLE
7733: LD_INT 1
7735: DEC
7736: ST_TO_ADDR
7737: LD_EXP 14
7741: PUSH
7742: FOR_TO
7743: IFFALSE 7848
// begin tmp := 0 ;
7745: LD_ADDR_VAR 0 2
7749: PUSH
7750: LD_STRING 0
7752: ST_TO_ADDR
// if result [ 2 ] then
7753: LD_VAR 0 1
7757: PUSH
7758: LD_INT 2
7760: ARRAY
7761: IFFALSE 7830
// if result [ 2 ] [ 1 ] = 100 + i then
7763: LD_VAR 0 1
7767: PUSH
7768: LD_INT 2
7770: ARRAY
7771: PUSH
7772: LD_INT 1
7774: ARRAY
7775: PUSH
7776: LD_INT 100
7778: PUSH
7779: LD_VAR 0 5
7783: PLUS
7784: EQUAL
7785: IFFALSE 7830
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
7787: LD_ADDR_VAR 0 1
7791: PUSH
7792: LD_VAR 0 1
7796: PPUSH
7797: LD_INT 2
7799: PPUSH
7800: LD_VAR 0 1
7804: PUSH
7805: LD_INT 2
7807: ARRAY
7808: PPUSH
7809: LD_INT 1
7811: PPUSH
7812: CALL_OW 3
7816: PPUSH
7817: CALL_OW 1
7821: ST_TO_ADDR
// tmp := 1 ;
7822: LD_ADDR_VAR 0 2
7826: PUSH
7827: LD_STRING 1
7829: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
7830: LD_ADDR_VAR 0 4
7834: PUSH
7835: LD_VAR 0 4
7839: PUSH
7840: LD_VAR 0 2
7844: STR
7845: ST_TO_ADDR
// end ;
7846: GO 7742
7848: POP
7849: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
7850: LD_STRING getStreamItemsFromMission("
7852: PUSH
7853: LD_VAR 0 3
7857: STR
7858: PUSH
7859: LD_STRING ","
7861: STR
7862: PUSH
7863: LD_VAR 0 4
7867: STR
7868: PUSH
7869: LD_STRING ")
7871: STR
7872: PPUSH
7873: CALL_OW 559
// end else
7877: GO 7886
// ToLua ( getStreamItemsFromMission("","") ) ;
7879: LD_STRING getStreamItemsFromMission("","")
7881: PPUSH
7882: CALL_OW 559
// end ;
7886: LD_VAR 0 1
7890: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
7891: LD_VAR 0 2
7895: PUSH
7896: LD_INT 100
7898: EQUAL
7899: IFFALSE 8848
// begin if not StreamModeActive then
7901: LD_EXP 12
7905: NOT
7906: IFFALSE 7916
// StreamModeActive := true ;
7908: LD_ADDR_EXP 12
7912: PUSH
7913: LD_INT 1
7915: ST_TO_ADDR
// if p3 = 0 then
7916: LD_VAR 0 3
7920: PUSH
7921: LD_INT 0
7923: EQUAL
7924: IFFALSE 7930
// InitStreamMode ;
7926: CALL 3969 0 0
// if p3 = 1 then
7930: LD_VAR 0 3
7934: PUSH
7935: LD_INT 1
7937: EQUAL
7938: IFFALSE 7948
// sRocket := true ;
7940: LD_ADDR_EXP 17
7944: PUSH
7945: LD_INT 1
7947: ST_TO_ADDR
// if p3 = 2 then
7948: LD_VAR 0 3
7952: PUSH
7953: LD_INT 2
7955: EQUAL
7956: IFFALSE 7966
// sSpeed := true ;
7958: LD_ADDR_EXP 16
7962: PUSH
7963: LD_INT 1
7965: ST_TO_ADDR
// if p3 = 3 then
7966: LD_VAR 0 3
7970: PUSH
7971: LD_INT 3
7973: EQUAL
7974: IFFALSE 7984
// sEngine := true ;
7976: LD_ADDR_EXP 18
7980: PUSH
7981: LD_INT 1
7983: ST_TO_ADDR
// if p3 = 4 then
7984: LD_VAR 0 3
7988: PUSH
7989: LD_INT 4
7991: EQUAL
7992: IFFALSE 8002
// sSpec := true ;
7994: LD_ADDR_EXP 15
7998: PUSH
7999: LD_INT 1
8001: ST_TO_ADDR
// if p3 = 5 then
8002: LD_VAR 0 3
8006: PUSH
8007: LD_INT 5
8009: EQUAL
8010: IFFALSE 8020
// sLevel := true ;
8012: LD_ADDR_EXP 19
8016: PUSH
8017: LD_INT 1
8019: ST_TO_ADDR
// if p3 = 6 then
8020: LD_VAR 0 3
8024: PUSH
8025: LD_INT 6
8027: EQUAL
8028: IFFALSE 8038
// sArmoury := true ;
8030: LD_ADDR_EXP 20
8034: PUSH
8035: LD_INT 1
8037: ST_TO_ADDR
// if p3 = 7 then
8038: LD_VAR 0 3
8042: PUSH
8043: LD_INT 7
8045: EQUAL
8046: IFFALSE 8056
// sRadar := true ;
8048: LD_ADDR_EXP 21
8052: PUSH
8053: LD_INT 1
8055: ST_TO_ADDR
// if p3 = 8 then
8056: LD_VAR 0 3
8060: PUSH
8061: LD_INT 8
8063: EQUAL
8064: IFFALSE 8074
// sBunker := true ;
8066: LD_ADDR_EXP 22
8070: PUSH
8071: LD_INT 1
8073: ST_TO_ADDR
// if p3 = 9 then
8074: LD_VAR 0 3
8078: PUSH
8079: LD_INT 9
8081: EQUAL
8082: IFFALSE 8092
// sHack := true ;
8084: LD_ADDR_EXP 23
8088: PUSH
8089: LD_INT 1
8091: ST_TO_ADDR
// if p3 = 10 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 10
8099: EQUAL
8100: IFFALSE 8110
// sFire := true ;
8102: LD_ADDR_EXP 24
8106: PUSH
8107: LD_INT 1
8109: ST_TO_ADDR
// if p3 = 11 then
8110: LD_VAR 0 3
8114: PUSH
8115: LD_INT 11
8117: EQUAL
8118: IFFALSE 8128
// sRefresh := true ;
8120: LD_ADDR_EXP 25
8124: PUSH
8125: LD_INT 1
8127: ST_TO_ADDR
// if p3 = 12 then
8128: LD_VAR 0 3
8132: PUSH
8133: LD_INT 12
8135: EQUAL
8136: IFFALSE 8146
// sExp := true ;
8138: LD_ADDR_EXP 26
8142: PUSH
8143: LD_INT 1
8145: ST_TO_ADDR
// if p3 = 13 then
8146: LD_VAR 0 3
8150: PUSH
8151: LD_INT 13
8153: EQUAL
8154: IFFALSE 8164
// sDepot := true ;
8156: LD_ADDR_EXP 27
8160: PUSH
8161: LD_INT 1
8163: ST_TO_ADDR
// if p3 = 14 then
8164: LD_VAR 0 3
8168: PUSH
8169: LD_INT 14
8171: EQUAL
8172: IFFALSE 8182
// sFlag := true ;
8174: LD_ADDR_EXP 28
8178: PUSH
8179: LD_INT 1
8181: ST_TO_ADDR
// if p3 = 15 then
8182: LD_VAR 0 3
8186: PUSH
8187: LD_INT 15
8189: EQUAL
8190: IFFALSE 8200
// sKamikadze := true ;
8192: LD_ADDR_EXP 36
8196: PUSH
8197: LD_INT 1
8199: ST_TO_ADDR
// if p3 = 16 then
8200: LD_VAR 0 3
8204: PUSH
8205: LD_INT 16
8207: EQUAL
8208: IFFALSE 8218
// sTroll := true ;
8210: LD_ADDR_EXP 37
8214: PUSH
8215: LD_INT 1
8217: ST_TO_ADDR
// if p3 = 17 then
8218: LD_VAR 0 3
8222: PUSH
8223: LD_INT 17
8225: EQUAL
8226: IFFALSE 8236
// sSlow := true ;
8228: LD_ADDR_EXP 38
8232: PUSH
8233: LD_INT 1
8235: ST_TO_ADDR
// if p3 = 18 then
8236: LD_VAR 0 3
8240: PUSH
8241: LD_INT 18
8243: EQUAL
8244: IFFALSE 8254
// sLack := true ;
8246: LD_ADDR_EXP 39
8250: PUSH
8251: LD_INT 1
8253: ST_TO_ADDR
// if p3 = 19 then
8254: LD_VAR 0 3
8258: PUSH
8259: LD_INT 19
8261: EQUAL
8262: IFFALSE 8272
// sTank := true ;
8264: LD_ADDR_EXP 41
8268: PUSH
8269: LD_INT 1
8271: ST_TO_ADDR
// if p3 = 20 then
8272: LD_VAR 0 3
8276: PUSH
8277: LD_INT 20
8279: EQUAL
8280: IFFALSE 8290
// sRemote := true ;
8282: LD_ADDR_EXP 42
8286: PUSH
8287: LD_INT 1
8289: ST_TO_ADDR
// if p3 = 21 then
8290: LD_VAR 0 3
8294: PUSH
8295: LD_INT 21
8297: EQUAL
8298: IFFALSE 8308
// sPowell := true ;
8300: LD_ADDR_EXP 43
8304: PUSH
8305: LD_INT 1
8307: ST_TO_ADDR
// if p3 = 22 then
8308: LD_VAR 0 3
8312: PUSH
8313: LD_INT 22
8315: EQUAL
8316: IFFALSE 8326
// sTeleport := true ;
8318: LD_ADDR_EXP 46
8322: PUSH
8323: LD_INT 1
8325: ST_TO_ADDR
// if p3 = 23 then
8326: LD_VAR 0 3
8330: PUSH
8331: LD_INT 23
8333: EQUAL
8334: IFFALSE 8344
// sOilTower := true ;
8336: LD_ADDR_EXP 48
8340: PUSH
8341: LD_INT 1
8343: ST_TO_ADDR
// if p3 = 24 then
8344: LD_VAR 0 3
8348: PUSH
8349: LD_INT 24
8351: EQUAL
8352: IFFALSE 8362
// sShovel := true ;
8354: LD_ADDR_EXP 49
8358: PUSH
8359: LD_INT 1
8361: ST_TO_ADDR
// if p3 = 25 then
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 25
8369: EQUAL
8370: IFFALSE 8380
// sSheik := true ;
8372: LD_ADDR_EXP 50
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// if p3 = 26 then
8380: LD_VAR 0 3
8384: PUSH
8385: LD_INT 26
8387: EQUAL
8388: IFFALSE 8398
// sEarthquake := true ;
8390: LD_ADDR_EXP 52
8394: PUSH
8395: LD_INT 1
8397: ST_TO_ADDR
// if p3 = 27 then
8398: LD_VAR 0 3
8402: PUSH
8403: LD_INT 27
8405: EQUAL
8406: IFFALSE 8416
// sAI := true ;
8408: LD_ADDR_EXP 53
8412: PUSH
8413: LD_INT 1
8415: ST_TO_ADDR
// if p3 = 28 then
8416: LD_VAR 0 3
8420: PUSH
8421: LD_INT 28
8423: EQUAL
8424: IFFALSE 8434
// sCargo := true ;
8426: LD_ADDR_EXP 56
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// if p3 = 29 then
8434: LD_VAR 0 3
8438: PUSH
8439: LD_INT 29
8441: EQUAL
8442: IFFALSE 8452
// sDLaser := true ;
8444: LD_ADDR_EXP 57
8448: PUSH
8449: LD_INT 1
8451: ST_TO_ADDR
// if p3 = 30 then
8452: LD_VAR 0 3
8456: PUSH
8457: LD_INT 30
8459: EQUAL
8460: IFFALSE 8470
// sExchange := true ;
8462: LD_ADDR_EXP 58
8466: PUSH
8467: LD_INT 1
8469: ST_TO_ADDR
// if p3 = 31 then
8470: LD_VAR 0 3
8474: PUSH
8475: LD_INT 31
8477: EQUAL
8478: IFFALSE 8488
// sFac := true ;
8480: LD_ADDR_EXP 59
8484: PUSH
8485: LD_INT 1
8487: ST_TO_ADDR
// if p3 = 32 then
8488: LD_VAR 0 3
8492: PUSH
8493: LD_INT 32
8495: EQUAL
8496: IFFALSE 8506
// sPower := true ;
8498: LD_ADDR_EXP 60
8502: PUSH
8503: LD_INT 1
8505: ST_TO_ADDR
// if p3 = 33 then
8506: LD_VAR 0 3
8510: PUSH
8511: LD_INT 33
8513: EQUAL
8514: IFFALSE 8524
// sRandom := true ;
8516: LD_ADDR_EXP 61
8520: PUSH
8521: LD_INT 1
8523: ST_TO_ADDR
// if p3 = 34 then
8524: LD_VAR 0 3
8528: PUSH
8529: LD_INT 34
8531: EQUAL
8532: IFFALSE 8542
// sShield := true ;
8534: LD_ADDR_EXP 62
8538: PUSH
8539: LD_INT 1
8541: ST_TO_ADDR
// if p3 = 35 then
8542: LD_VAR 0 3
8546: PUSH
8547: LD_INT 35
8549: EQUAL
8550: IFFALSE 8560
// sTime := true ;
8552: LD_ADDR_EXP 63
8556: PUSH
8557: LD_INT 1
8559: ST_TO_ADDR
// if p3 = 36 then
8560: LD_VAR 0 3
8564: PUSH
8565: LD_INT 36
8567: EQUAL
8568: IFFALSE 8578
// sTools := true ;
8570: LD_ADDR_EXP 64
8574: PUSH
8575: LD_INT 1
8577: ST_TO_ADDR
// if p3 = 101 then
8578: LD_VAR 0 3
8582: PUSH
8583: LD_INT 101
8585: EQUAL
8586: IFFALSE 8596
// sSold := true ;
8588: LD_ADDR_EXP 29
8592: PUSH
8593: LD_INT 1
8595: ST_TO_ADDR
// if p3 = 102 then
8596: LD_VAR 0 3
8600: PUSH
8601: LD_INT 102
8603: EQUAL
8604: IFFALSE 8614
// sDiff := true ;
8606: LD_ADDR_EXP 30
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// if p3 = 103 then
8614: LD_VAR 0 3
8618: PUSH
8619: LD_INT 103
8621: EQUAL
8622: IFFALSE 8632
// sFog := true ;
8624: LD_ADDR_EXP 33
8628: PUSH
8629: LD_INT 1
8631: ST_TO_ADDR
// if p3 = 104 then
8632: LD_VAR 0 3
8636: PUSH
8637: LD_INT 104
8639: EQUAL
8640: IFFALSE 8650
// sReset := true ;
8642: LD_ADDR_EXP 34
8646: PUSH
8647: LD_INT 1
8649: ST_TO_ADDR
// if p3 = 105 then
8650: LD_VAR 0 3
8654: PUSH
8655: LD_INT 105
8657: EQUAL
8658: IFFALSE 8668
// sSun := true ;
8660: LD_ADDR_EXP 35
8664: PUSH
8665: LD_INT 1
8667: ST_TO_ADDR
// if p3 = 106 then
8668: LD_VAR 0 3
8672: PUSH
8673: LD_INT 106
8675: EQUAL
8676: IFFALSE 8686
// sTiger := true ;
8678: LD_ADDR_EXP 31
8682: PUSH
8683: LD_INT 1
8685: ST_TO_ADDR
// if p3 = 107 then
8686: LD_VAR 0 3
8690: PUSH
8691: LD_INT 107
8693: EQUAL
8694: IFFALSE 8704
// sBomb := true ;
8696: LD_ADDR_EXP 32
8700: PUSH
8701: LD_INT 1
8703: ST_TO_ADDR
// if p3 = 108 then
8704: LD_VAR 0 3
8708: PUSH
8709: LD_INT 108
8711: EQUAL
8712: IFFALSE 8722
// sWound := true ;
8714: LD_ADDR_EXP 40
8718: PUSH
8719: LD_INT 1
8721: ST_TO_ADDR
// if p3 = 109 then
8722: LD_VAR 0 3
8726: PUSH
8727: LD_INT 109
8729: EQUAL
8730: IFFALSE 8740
// sBetray := true ;
8732: LD_ADDR_EXP 44
8736: PUSH
8737: LD_INT 1
8739: ST_TO_ADDR
// if p3 = 110 then
8740: LD_VAR 0 3
8744: PUSH
8745: LD_INT 110
8747: EQUAL
8748: IFFALSE 8758
// sContamin := true ;
8750: LD_ADDR_EXP 45
8754: PUSH
8755: LD_INT 1
8757: ST_TO_ADDR
// if p3 = 111 then
8758: LD_VAR 0 3
8762: PUSH
8763: LD_INT 111
8765: EQUAL
8766: IFFALSE 8776
// sOil := true ;
8768: LD_ADDR_EXP 47
8772: PUSH
8773: LD_INT 1
8775: ST_TO_ADDR
// if p3 = 112 then
8776: LD_VAR 0 3
8780: PUSH
8781: LD_INT 112
8783: EQUAL
8784: IFFALSE 8794
// sStu := true ;
8786: LD_ADDR_EXP 51
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// if p3 = 113 then
8794: LD_VAR 0 3
8798: PUSH
8799: LD_INT 113
8801: EQUAL
8802: IFFALSE 8812
// sBazooka := true ;
8804: LD_ADDR_EXP 54
8808: PUSH
8809: LD_INT 1
8811: ST_TO_ADDR
// if p3 = 114 then
8812: LD_VAR 0 3
8816: PUSH
8817: LD_INT 114
8819: EQUAL
8820: IFFALSE 8830
// sMortar := true ;
8822: LD_ADDR_EXP 55
8826: PUSH
8827: LD_INT 1
8829: ST_TO_ADDR
// if p3 = 115 then
8830: LD_VAR 0 3
8834: PUSH
8835: LD_INT 115
8837: EQUAL
8838: IFFALSE 8848
// sRanger := true ;
8840: LD_ADDR_EXP 65
8844: PUSH
8845: LD_INT 1
8847: ST_TO_ADDR
// end ; end ;
8848: PPOPN 6
8850: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
8851: LD_EXP 12
8855: PUSH
8856: LD_EXP 17
8860: AND
8861: IFFALSE 8985
8863: GO 8865
8865: DISABLE
8866: LD_INT 0
8868: PPUSH
8869: PPUSH
// begin enable ;
8870: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8871: LD_ADDR_VAR 0 2
8875: PUSH
8876: LD_INT 22
8878: PUSH
8879: LD_OWVAR 2
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PUSH
8888: LD_INT 2
8890: PUSH
8891: LD_INT 34
8893: PUSH
8894: LD_INT 7
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 34
8903: PUSH
8904: LD_INT 45
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PUSH
8911: LD_INT 34
8913: PUSH
8914: LD_INT 28
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PUSH
8921: LD_INT 34
8923: PUSH
8924: LD_INT 47
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PPUSH
8942: CALL_OW 69
8946: ST_TO_ADDR
// if not tmp then
8947: LD_VAR 0 2
8951: NOT
8952: IFFALSE 8956
// exit ;
8954: GO 8985
// for i in tmp do
8956: LD_ADDR_VAR 0 1
8960: PUSH
8961: LD_VAR 0 2
8965: PUSH
8966: FOR_IN
8967: IFFALSE 8983
// begin SetLives ( i , 0 ) ;
8969: LD_VAR 0 1
8973: PPUSH
8974: LD_INT 0
8976: PPUSH
8977: CALL_OW 234
// end ;
8981: GO 8966
8983: POP
8984: POP
// end ;
8985: PPOPN 2
8987: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8988: LD_EXP 12
8992: PUSH
8993: LD_EXP 18
8997: AND
8998: IFFALSE 9082
9000: GO 9002
9002: DISABLE
9003: LD_INT 0
9005: PPUSH
9006: PPUSH
// begin enable ;
9007: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
9008: LD_ADDR_VAR 0 2
9012: PUSH
9013: LD_INT 22
9015: PUSH
9016: LD_OWVAR 2
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: PUSH
9025: LD_INT 32
9027: PUSH
9028: LD_INT 3
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PPUSH
9039: CALL_OW 69
9043: ST_TO_ADDR
// if not tmp then
9044: LD_VAR 0 2
9048: NOT
9049: IFFALSE 9053
// exit ;
9051: GO 9082
// for i in tmp do
9053: LD_ADDR_VAR 0 1
9057: PUSH
9058: LD_VAR 0 2
9062: PUSH
9063: FOR_IN
9064: IFFALSE 9080
// begin SetLives ( i , 0 ) ;
9066: LD_VAR 0 1
9070: PPUSH
9071: LD_INT 0
9073: PPUSH
9074: CALL_OW 234
// end ;
9078: GO 9063
9080: POP
9081: POP
// end ;
9082: PPOPN 2
9084: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9085: LD_EXP 12
9089: PUSH
9090: LD_EXP 15
9094: AND
9095: IFFALSE 9188
9097: GO 9099
9099: DISABLE
9100: LD_INT 0
9102: PPUSH
// begin enable ;
9103: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9104: LD_ADDR_VAR 0 1
9108: PUSH
9109: LD_INT 22
9111: PUSH
9112: LD_OWVAR 2
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: PUSH
9121: LD_INT 2
9123: PUSH
9124: LD_INT 25
9126: PUSH
9127: LD_INT 5
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 25
9136: PUSH
9137: LD_INT 9
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 25
9146: PUSH
9147: LD_INT 8
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: PUSH
9169: FOR_IN
9170: IFFALSE 9186
// begin SetClass ( i , 1 ) ;
9172: LD_VAR 0 1
9176: PPUSH
9177: LD_INT 1
9179: PPUSH
9180: CALL_OW 336
// end ;
9184: GO 9169
9186: POP
9187: POP
// end ;
9188: PPOPN 1
9190: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9191: LD_EXP 12
9195: PUSH
9196: LD_EXP 16
9200: AND
9201: PUSH
9202: LD_OWVAR 65
9206: PUSH
9207: LD_INT 7
9209: LESS
9210: AND
9211: IFFALSE 9225
9213: GO 9215
9215: DISABLE
// begin enable ;
9216: ENABLE
// game_speed := 7 ;
9217: LD_ADDR_OWVAR 65
9221: PUSH
9222: LD_INT 7
9224: ST_TO_ADDR
// end ;
9225: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9226: LD_EXP 12
9230: PUSH
9231: LD_EXP 19
9235: AND
9236: IFFALSE 9438
9238: GO 9240
9240: DISABLE
9241: LD_INT 0
9243: PPUSH
9244: PPUSH
9245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9246: LD_ADDR_VAR 0 3
9250: PUSH
9251: LD_INT 81
9253: PUSH
9254: LD_OWVAR 2
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: PUSH
9263: LD_INT 21
9265: PUSH
9266: LD_INT 1
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: PUSH
9273: EMPTY
9274: LIST
9275: LIST
9276: PPUSH
9277: CALL_OW 69
9281: ST_TO_ADDR
// if not tmp then
9282: LD_VAR 0 3
9286: NOT
9287: IFFALSE 9291
// exit ;
9289: GO 9438
// if tmp > 5 then
9291: LD_VAR 0 3
9295: PUSH
9296: LD_INT 5
9298: GREATER
9299: IFFALSE 9311
// k := 5 else
9301: LD_ADDR_VAR 0 2
9305: PUSH
9306: LD_INT 5
9308: ST_TO_ADDR
9309: GO 9321
// k := tmp ;
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: LD_VAR 0 3
9320: ST_TO_ADDR
// for i := 1 to k do
9321: LD_ADDR_VAR 0 1
9325: PUSH
9326: DOUBLE
9327: LD_INT 1
9329: DEC
9330: ST_TO_ADDR
9331: LD_VAR 0 2
9335: PUSH
9336: FOR_TO
9337: IFFALSE 9436
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9339: LD_VAR 0 3
9343: PUSH
9344: LD_VAR 0 1
9348: ARRAY
9349: PPUSH
9350: LD_VAR 0 1
9354: PUSH
9355: LD_INT 4
9357: MOD
9358: PUSH
9359: LD_INT 1
9361: PLUS
9362: PPUSH
9363: CALL_OW 259
9367: PUSH
9368: LD_INT 10
9370: LESS
9371: IFFALSE 9434
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9373: LD_VAR 0 3
9377: PUSH
9378: LD_VAR 0 1
9382: ARRAY
9383: PPUSH
9384: LD_VAR 0 1
9388: PUSH
9389: LD_INT 4
9391: MOD
9392: PUSH
9393: LD_INT 1
9395: PLUS
9396: PPUSH
9397: LD_VAR 0 3
9401: PUSH
9402: LD_VAR 0 1
9406: ARRAY
9407: PPUSH
9408: LD_VAR 0 1
9412: PUSH
9413: LD_INT 4
9415: MOD
9416: PUSH
9417: LD_INT 1
9419: PLUS
9420: PPUSH
9421: CALL_OW 259
9425: PUSH
9426: LD_INT 1
9428: PLUS
9429: PPUSH
9430: CALL_OW 237
9434: GO 9336
9436: POP
9437: POP
// end ;
9438: PPOPN 3
9440: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9441: LD_EXP 12
9445: PUSH
9446: LD_EXP 20
9450: AND
9451: IFFALSE 9471
9453: GO 9455
9455: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9456: LD_INT 4
9458: PPUSH
9459: LD_OWVAR 2
9463: PPUSH
9464: LD_INT 0
9466: PPUSH
9467: CALL_OW 324
9471: END
// every 0 0$1 trigger StreamModeActive and sShovel do
9472: LD_EXP 12
9476: PUSH
9477: LD_EXP 49
9481: AND
9482: IFFALSE 9502
9484: GO 9486
9486: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
9487: LD_INT 19
9489: PPUSH
9490: LD_OWVAR 2
9494: PPUSH
9495: LD_INT 0
9497: PPUSH
9498: CALL_OW 324
9502: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9503: LD_EXP 12
9507: PUSH
9508: LD_EXP 21
9512: AND
9513: IFFALSE 9615
9515: GO 9517
9517: DISABLE
9518: LD_INT 0
9520: PPUSH
9521: PPUSH
// begin enable ;
9522: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9523: LD_ADDR_VAR 0 2
9527: PUSH
9528: LD_INT 22
9530: PUSH
9531: LD_OWVAR 2
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 2
9542: PUSH
9543: LD_INT 34
9545: PUSH
9546: LD_INT 11
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: PUSH
9553: LD_INT 34
9555: PUSH
9556: LD_INT 30
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: PPUSH
9572: CALL_OW 69
9576: ST_TO_ADDR
// if not tmp then
9577: LD_VAR 0 2
9581: NOT
9582: IFFALSE 9586
// exit ;
9584: GO 9615
// for i in tmp do
9586: LD_ADDR_VAR 0 1
9590: PUSH
9591: LD_VAR 0 2
9595: PUSH
9596: FOR_IN
9597: IFFALSE 9613
// begin SetLives ( i , 0 ) ;
9599: LD_VAR 0 1
9603: PPUSH
9604: LD_INT 0
9606: PPUSH
9607: CALL_OW 234
// end ;
9611: GO 9596
9613: POP
9614: POP
// end ;
9615: PPOPN 2
9617: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9618: LD_EXP 12
9622: PUSH
9623: LD_EXP 22
9627: AND
9628: IFFALSE 9648
9630: GO 9632
9632: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9633: LD_INT 32
9635: PPUSH
9636: LD_OWVAR 2
9640: PPUSH
9641: LD_INT 0
9643: PPUSH
9644: CALL_OW 324
9648: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
9649: LD_EXP 12
9653: PUSH
9654: LD_EXP 23
9658: AND
9659: IFFALSE 9840
9661: GO 9663
9663: DISABLE
9664: LD_INT 0
9666: PPUSH
9667: PPUSH
9668: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
9669: LD_ADDR_VAR 0 2
9673: PUSH
9674: LD_INT 22
9676: PUSH
9677: LD_OWVAR 2
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PUSH
9686: LD_INT 33
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: PUSH
9696: EMPTY
9697: LIST
9698: LIST
9699: PPUSH
9700: CALL_OW 69
9704: ST_TO_ADDR
// if not tmp then
9705: LD_VAR 0 2
9709: NOT
9710: IFFALSE 9714
// exit ;
9712: GO 9840
// side := 0 ;
9714: LD_ADDR_VAR 0 3
9718: PUSH
9719: LD_INT 0
9721: ST_TO_ADDR
// for i := 1 to 8 do
9722: LD_ADDR_VAR 0 1
9726: PUSH
9727: DOUBLE
9728: LD_INT 1
9730: DEC
9731: ST_TO_ADDR
9732: LD_INT 8
9734: PUSH
9735: FOR_TO
9736: IFFALSE 9784
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
9738: LD_OWVAR 2
9742: PUSH
9743: LD_VAR 0 1
9747: NONEQUAL
9748: PUSH
9749: LD_OWVAR 2
9753: PPUSH
9754: LD_VAR 0 1
9758: PPUSH
9759: CALL_OW 81
9763: PUSH
9764: LD_INT 2
9766: EQUAL
9767: AND
9768: IFFALSE 9782
// begin side := i ;
9770: LD_ADDR_VAR 0 3
9774: PUSH
9775: LD_VAR 0 1
9779: ST_TO_ADDR
// break ;
9780: GO 9784
// end ;
9782: GO 9735
9784: POP
9785: POP
// if not side then
9786: LD_VAR 0 3
9790: NOT
9791: IFFALSE 9795
// exit ;
9793: GO 9840
// for i := 1 to tmp do
9795: LD_ADDR_VAR 0 1
9799: PUSH
9800: DOUBLE
9801: LD_INT 1
9803: DEC
9804: ST_TO_ADDR
9805: LD_VAR 0 2
9809: PUSH
9810: FOR_TO
9811: IFFALSE 9838
// if Prob ( 60 ) then
9813: LD_INT 60
9815: PPUSH
9816: CALL_OW 13
9820: IFFALSE 9836
// SetSide ( i , side ) ;
9822: LD_VAR 0 1
9826: PPUSH
9827: LD_VAR 0 3
9831: PPUSH
9832: CALL_OW 235
9836: GO 9810
9838: POP
9839: POP
// end ;
9840: PPOPN 3
9842: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
9843: LD_EXP 12
9847: PUSH
9848: LD_EXP 25
9852: AND
9853: IFFALSE 9972
9855: GO 9857
9857: DISABLE
9858: LD_INT 0
9860: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
9861: LD_ADDR_VAR 0 1
9865: PUSH
9866: LD_INT 22
9868: PUSH
9869: LD_OWVAR 2
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PUSH
9878: LD_INT 21
9880: PUSH
9881: LD_INT 1
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PUSH
9888: LD_INT 3
9890: PUSH
9891: LD_INT 23
9893: PUSH
9894: LD_INT 0
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: PUSH
9905: EMPTY
9906: LIST
9907: LIST
9908: LIST
9909: PPUSH
9910: CALL_OW 69
9914: PUSH
9915: FOR_IN
9916: IFFALSE 9970
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
9918: LD_VAR 0 1
9922: PPUSH
9923: CALL_OW 257
9927: PUSH
9928: LD_INT 1
9930: PUSH
9931: LD_INT 2
9933: PUSH
9934: LD_INT 3
9936: PUSH
9937: LD_INT 4
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: LIST
9944: LIST
9945: IN
9946: IFFALSE 9968
// SetClass ( un , rand ( 1 , 4 ) ) ;
9948: LD_VAR 0 1
9952: PPUSH
9953: LD_INT 1
9955: PPUSH
9956: LD_INT 4
9958: PPUSH
9959: CALL_OW 12
9963: PPUSH
9964: CALL_OW 336
9968: GO 9915
9970: POP
9971: POP
// end ;
9972: PPOPN 1
9974: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9975: LD_EXP 12
9979: PUSH
9980: LD_EXP 24
9984: AND
9985: IFFALSE 10064
9987: GO 9989
9989: DISABLE
9990: LD_INT 0
9992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9993: LD_ADDR_VAR 0 1
9997: PUSH
9998: LD_INT 22
10000: PUSH
10001: LD_OWVAR 2
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PUSH
10010: LD_INT 21
10012: PUSH
10013: LD_INT 3
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: EMPTY
10021: LIST
10022: LIST
10023: PPUSH
10024: CALL_OW 69
10028: ST_TO_ADDR
// if not tmp then
10029: LD_VAR 0 1
10033: NOT
10034: IFFALSE 10038
// exit ;
10036: GO 10064
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
10038: LD_VAR 0 1
10042: PUSH
10043: LD_INT 1
10045: PPUSH
10046: LD_VAR 0 1
10050: PPUSH
10051: CALL_OW 12
10055: ARRAY
10056: PPUSH
10057: LD_INT 100
10059: PPUSH
10060: CALL_OW 234
// end ;
10064: PPOPN 1
10066: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10067: LD_EXP 12
10071: PUSH
10072: LD_EXP 26
10076: AND
10077: IFFALSE 10175
10079: GO 10081
10081: DISABLE
10082: LD_INT 0
10084: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10085: LD_ADDR_VAR 0 1
10089: PUSH
10090: LD_INT 22
10092: PUSH
10093: LD_OWVAR 2
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: PUSH
10102: LD_INT 21
10104: PUSH
10105: LD_INT 1
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: PPUSH
10116: CALL_OW 69
10120: ST_TO_ADDR
// if not tmp then
10121: LD_VAR 0 1
10125: NOT
10126: IFFALSE 10130
// exit ;
10128: GO 10175
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10130: LD_VAR 0 1
10134: PUSH
10135: LD_INT 1
10137: PPUSH
10138: LD_VAR 0 1
10142: PPUSH
10143: CALL_OW 12
10147: ARRAY
10148: PPUSH
10149: LD_INT 1
10151: PPUSH
10152: LD_INT 4
10154: PPUSH
10155: CALL_OW 12
10159: PPUSH
10160: LD_INT 3000
10162: PPUSH
10163: LD_INT 9000
10165: PPUSH
10166: CALL_OW 12
10170: PPUSH
10171: CALL_OW 492
// end ;
10175: PPOPN 1
10177: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10178: LD_EXP 12
10182: PUSH
10183: LD_EXP 27
10187: AND
10188: IFFALSE 10208
10190: GO 10192
10192: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10193: LD_INT 1
10195: PPUSH
10196: LD_OWVAR 2
10200: PPUSH
10201: LD_INT 0
10203: PPUSH
10204: CALL_OW 324
10208: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10209: LD_EXP 12
10213: PUSH
10214: LD_EXP 28
10218: AND
10219: IFFALSE 10302
10221: GO 10223
10223: DISABLE
10224: LD_INT 0
10226: PPUSH
10227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10228: LD_ADDR_VAR 0 2
10232: PUSH
10233: LD_INT 22
10235: PUSH
10236: LD_OWVAR 2
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 21
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 69
10263: ST_TO_ADDR
// if not tmp then
10264: LD_VAR 0 2
10268: NOT
10269: IFFALSE 10273
// exit ;
10271: GO 10302
// for i in tmp do
10273: LD_ADDR_VAR 0 1
10277: PUSH
10278: LD_VAR 0 2
10282: PUSH
10283: FOR_IN
10284: IFFALSE 10300
// SetBLevel ( i , 10 ) ;
10286: LD_VAR 0 1
10290: PPUSH
10291: LD_INT 10
10293: PPUSH
10294: CALL_OW 241
10298: GO 10283
10300: POP
10301: POP
// end ;
10302: PPOPN 2
10304: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
10305: LD_EXP 12
10309: PUSH
10310: LD_EXP 29
10314: AND
10315: IFFALSE 10426
10317: GO 10319
10319: DISABLE
10320: LD_INT 0
10322: PPUSH
10323: PPUSH
10324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10325: LD_ADDR_VAR 0 3
10329: PUSH
10330: LD_INT 22
10332: PUSH
10333: LD_OWVAR 2
10337: PUSH
10338: EMPTY
10339: LIST
10340: LIST
10341: PUSH
10342: LD_INT 25
10344: PUSH
10345: LD_INT 1
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PPUSH
10356: CALL_OW 69
10360: ST_TO_ADDR
// if not tmp then
10361: LD_VAR 0 3
10365: NOT
10366: IFFALSE 10370
// exit ;
10368: GO 10426
// un := tmp [ rand ( 1 , tmp ) ] ;
10370: LD_ADDR_VAR 0 2
10374: PUSH
10375: LD_VAR 0 3
10379: PUSH
10380: LD_INT 1
10382: PPUSH
10383: LD_VAR 0 3
10387: PPUSH
10388: CALL_OW 12
10392: ARRAY
10393: ST_TO_ADDR
// if Crawls ( un ) then
10394: LD_VAR 0 2
10398: PPUSH
10399: CALL_OW 318
10403: IFFALSE 10414
// ComWalk ( un ) ;
10405: LD_VAR 0 2
10409: PPUSH
10410: CALL_OW 138
// SetClass ( un , class_sniper ) ;
10414: LD_VAR 0 2
10418: PPUSH
10419: LD_INT 5
10421: PPUSH
10422: CALL_OW 336
// end ;
10426: PPOPN 3
10428: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10429: LD_EXP 12
10433: PUSH
10434: LD_EXP 30
10438: AND
10439: PUSH
10440: LD_OWVAR 67
10444: PUSH
10445: LD_INT 3
10447: LESS
10448: AND
10449: IFFALSE 10468
10451: GO 10453
10453: DISABLE
// Difficulty := Difficulty + 1 ;
10454: LD_ADDR_OWVAR 67
10458: PUSH
10459: LD_OWVAR 67
10463: PUSH
10464: LD_INT 1
10466: PLUS
10467: ST_TO_ADDR
10468: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10469: LD_EXP 12
10473: PUSH
10474: LD_EXP 31
10478: AND
10479: IFFALSE 10582
10481: GO 10483
10483: DISABLE
10484: LD_INT 0
10486: PPUSH
// begin for i := 1 to 5 do
10487: LD_ADDR_VAR 0 1
10491: PUSH
10492: DOUBLE
10493: LD_INT 1
10495: DEC
10496: ST_TO_ADDR
10497: LD_INT 5
10499: PUSH
10500: FOR_TO
10501: IFFALSE 10580
// begin uc_nation := nation_nature ;
10503: LD_ADDR_OWVAR 21
10507: PUSH
10508: LD_INT 0
10510: ST_TO_ADDR
// uc_side := 0 ;
10511: LD_ADDR_OWVAR 20
10515: PUSH
10516: LD_INT 0
10518: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10519: LD_ADDR_OWVAR 29
10523: PUSH
10524: LD_INT 12
10526: PUSH
10527: LD_INT 12
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: ST_TO_ADDR
// hc_agressivity := 20 ;
10534: LD_ADDR_OWVAR 35
10538: PUSH
10539: LD_INT 20
10541: ST_TO_ADDR
// hc_class := class_tiger ;
10542: LD_ADDR_OWVAR 28
10546: PUSH
10547: LD_INT 14
10549: ST_TO_ADDR
// hc_gallery :=  ;
10550: LD_ADDR_OWVAR 33
10554: PUSH
10555: LD_STRING 
10557: ST_TO_ADDR
// hc_name :=  ;
10558: LD_ADDR_OWVAR 26
10562: PUSH
10563: LD_STRING 
10565: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10566: CALL_OW 44
10570: PPUSH
10571: LD_INT 0
10573: PPUSH
10574: CALL_OW 51
// end ;
10578: GO 10500
10580: POP
10581: POP
// end ;
10582: PPOPN 1
10584: END
// every 0 0$1 trigger StreamModeActive and sBomb do
10585: LD_EXP 12
10589: PUSH
10590: LD_EXP 32
10594: AND
10595: IFFALSE 10604
10597: GO 10599
10599: DISABLE
// StreamSibBomb ;
10600: CALL 10605 0 0
10604: END
// export function StreamSibBomb ; var i , x , y ; begin
10605: LD_INT 0
10607: PPUSH
10608: PPUSH
10609: PPUSH
10610: PPUSH
// result := false ;
10611: LD_ADDR_VAR 0 1
10615: PUSH
10616: LD_INT 0
10618: ST_TO_ADDR
// for i := 1 to 16 do
10619: LD_ADDR_VAR 0 2
10623: PUSH
10624: DOUBLE
10625: LD_INT 1
10627: DEC
10628: ST_TO_ADDR
10629: LD_INT 16
10631: PUSH
10632: FOR_TO
10633: IFFALSE 10832
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10635: LD_ADDR_VAR 0 3
10639: PUSH
10640: LD_INT 10
10642: PUSH
10643: LD_INT 20
10645: PUSH
10646: LD_INT 30
10648: PUSH
10649: LD_INT 40
10651: PUSH
10652: LD_INT 50
10654: PUSH
10655: LD_INT 60
10657: PUSH
10658: LD_INT 70
10660: PUSH
10661: LD_INT 80
10663: PUSH
10664: LD_INT 90
10666: PUSH
10667: LD_INT 100
10669: PUSH
10670: LD_INT 110
10672: PUSH
10673: LD_INT 120
10675: PUSH
10676: LD_INT 130
10678: PUSH
10679: LD_INT 140
10681: PUSH
10682: LD_INT 150
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: LIST
10689: LIST
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: LIST
10700: LIST
10701: PUSH
10702: LD_INT 1
10704: PPUSH
10705: LD_INT 15
10707: PPUSH
10708: CALL_OW 12
10712: ARRAY
10713: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
10714: LD_ADDR_VAR 0 4
10718: PUSH
10719: LD_INT 10
10721: PUSH
10722: LD_INT 20
10724: PUSH
10725: LD_INT 30
10727: PUSH
10728: LD_INT 40
10730: PUSH
10731: LD_INT 50
10733: PUSH
10734: LD_INT 60
10736: PUSH
10737: LD_INT 70
10739: PUSH
10740: LD_INT 80
10742: PUSH
10743: LD_INT 90
10745: PUSH
10746: LD_INT 100
10748: PUSH
10749: LD_INT 110
10751: PUSH
10752: LD_INT 120
10754: PUSH
10755: LD_INT 130
10757: PUSH
10758: LD_INT 140
10760: PUSH
10761: LD_INT 150
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: LIST
10768: LIST
10769: LIST
10770: LIST
10771: LIST
10772: LIST
10773: LIST
10774: LIST
10775: LIST
10776: LIST
10777: LIST
10778: LIST
10779: LIST
10780: PUSH
10781: LD_INT 1
10783: PPUSH
10784: LD_INT 15
10786: PPUSH
10787: CALL_OW 12
10791: ARRAY
10792: ST_TO_ADDR
// if ValidHex ( x , y ) then
10793: LD_VAR 0 3
10797: PPUSH
10798: LD_VAR 0 4
10802: PPUSH
10803: CALL_OW 488
10807: IFFALSE 10830
// begin result := [ x , y ] ;
10809: LD_ADDR_VAR 0 1
10813: PUSH
10814: LD_VAR 0 3
10818: PUSH
10819: LD_VAR 0 4
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: ST_TO_ADDR
// break ;
10828: GO 10832
// end ; end ;
10830: GO 10632
10832: POP
10833: POP
// if result then
10834: LD_VAR 0 1
10838: IFFALSE 10898
// begin ToLua ( playSibBomb() ) ;
10840: LD_STRING playSibBomb()
10842: PPUSH
10843: CALL_OW 559
// wait ( 0 0$14 ) ;
10847: LD_INT 490
10849: PPUSH
10850: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
10854: LD_VAR 0 1
10858: PUSH
10859: LD_INT 1
10861: ARRAY
10862: PPUSH
10863: LD_VAR 0 1
10867: PUSH
10868: LD_INT 2
10870: ARRAY
10871: PPUSH
10872: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10876: LD_VAR 0 1
10880: PUSH
10881: LD_INT 1
10883: ARRAY
10884: PPUSH
10885: LD_VAR 0 1
10889: PUSH
10890: LD_INT 2
10892: ARRAY
10893: PPUSH
10894: CALL_OW 429
// end ; end ;
10898: LD_VAR 0 1
10902: RET
// every 0 0$1 trigger StreamModeActive and sReset do
10903: LD_EXP 12
10907: PUSH
10908: LD_EXP 34
10912: AND
10913: IFFALSE 10925
10915: GO 10917
10917: DISABLE
// YouLost (  ) ;
10918: LD_STRING 
10920: PPUSH
10921: CALL_OW 104
10925: END
// every 0 0$1 trigger StreamModeActive and sFog do
10926: LD_EXP 12
10930: PUSH
10931: LD_EXP 33
10935: AND
10936: IFFALSE 10950
10938: GO 10940
10940: DISABLE
// FogOff ( your_side ) ;
10941: LD_OWVAR 2
10945: PPUSH
10946: CALL_OW 344
10950: END
// every 0 0$1 trigger StreamModeActive and sSun do
10951: LD_EXP 12
10955: PUSH
10956: LD_EXP 35
10960: AND
10961: IFFALSE 10989
10963: GO 10965
10965: DISABLE
// begin solar_recharge_percent := 0 ;
10966: LD_ADDR_OWVAR 79
10970: PUSH
10971: LD_INT 0
10973: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10974: LD_INT 10500
10976: PPUSH
10977: CALL_OW 67
// solar_recharge_percent := 100 ;
10981: LD_ADDR_OWVAR 79
10985: PUSH
10986: LD_INT 100
10988: ST_TO_ADDR
// end ;
10989: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
10990: LD_EXP 12
10994: PUSH
10995: LD_EXP 36
10999: AND
11000: IFFALSE 11239
11002: GO 11004
11004: DISABLE
11005: LD_INT 0
11007: PPUSH
11008: PPUSH
11009: PPUSH
// begin tmp := [ ] ;
11010: LD_ADDR_VAR 0 3
11014: PUSH
11015: EMPTY
11016: ST_TO_ADDR
// for i := 1 to 6 do
11017: LD_ADDR_VAR 0 1
11021: PUSH
11022: DOUBLE
11023: LD_INT 1
11025: DEC
11026: ST_TO_ADDR
11027: LD_INT 6
11029: PUSH
11030: FOR_TO
11031: IFFALSE 11136
// begin uc_nation := nation_nature ;
11033: LD_ADDR_OWVAR 21
11037: PUSH
11038: LD_INT 0
11040: ST_TO_ADDR
// uc_side := 0 ;
11041: LD_ADDR_OWVAR 20
11045: PUSH
11046: LD_INT 0
11048: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11049: LD_ADDR_OWVAR 29
11053: PUSH
11054: LD_INT 12
11056: PUSH
11057: LD_INT 12
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: ST_TO_ADDR
// hc_agressivity := 20 ;
11064: LD_ADDR_OWVAR 35
11068: PUSH
11069: LD_INT 20
11071: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11072: LD_ADDR_OWVAR 28
11076: PUSH
11077: LD_INT 17
11079: ST_TO_ADDR
// hc_gallery :=  ;
11080: LD_ADDR_OWVAR 33
11084: PUSH
11085: LD_STRING 
11087: ST_TO_ADDR
// hc_name :=  ;
11088: LD_ADDR_OWVAR 26
11092: PUSH
11093: LD_STRING 
11095: ST_TO_ADDR
// un := CreateHuman ;
11096: LD_ADDR_VAR 0 2
11100: PUSH
11101: CALL_OW 44
11105: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11106: LD_VAR 0 2
11110: PPUSH
11111: LD_INT 1
11113: PPUSH
11114: CALL_OW 51
// tmp := tmp ^ un ;
11118: LD_ADDR_VAR 0 3
11122: PUSH
11123: LD_VAR 0 3
11127: PUSH
11128: LD_VAR 0 2
11132: ADD
11133: ST_TO_ADDR
// end ;
11134: GO 11030
11136: POP
11137: POP
// repeat wait ( 0 0$1 ) ;
11138: LD_INT 35
11140: PPUSH
11141: CALL_OW 67
// for un in tmp do
11145: LD_ADDR_VAR 0 2
11149: PUSH
11150: LD_VAR 0 3
11154: PUSH
11155: FOR_IN
11156: IFFALSE 11230
// begin if IsDead ( un ) then
11158: LD_VAR 0 2
11162: PPUSH
11163: CALL_OW 301
11167: IFFALSE 11187
// begin tmp := tmp diff un ;
11169: LD_ADDR_VAR 0 3
11173: PUSH
11174: LD_VAR 0 3
11178: PUSH
11179: LD_VAR 0 2
11183: DIFF
11184: ST_TO_ADDR
// continue ;
11185: GO 11155
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11187: LD_VAR 0 2
11191: PPUSH
11192: LD_INT 3
11194: PUSH
11195: LD_INT 22
11197: PUSH
11198: LD_INT 0
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: PPUSH
11209: CALL_OW 69
11213: PPUSH
11214: LD_VAR 0 2
11218: PPUSH
11219: CALL_OW 74
11223: PPUSH
11224: CALL_OW 115
// end ;
11228: GO 11155
11230: POP
11231: POP
// until not tmp ;
11232: LD_VAR 0 3
11236: NOT
11237: IFFALSE 11138
// end ;
11239: PPOPN 3
11241: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11242: LD_EXP 12
11246: PUSH
11247: LD_EXP 37
11251: AND
11252: IFFALSE 11306
11254: GO 11256
11256: DISABLE
// begin ToLua ( displayTroll(); ) ;
11257: LD_STRING displayTroll();
11259: PPUSH
11260: CALL_OW 559
// wait ( 3 3$00 ) ;
11264: LD_INT 6300
11266: PPUSH
11267: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11271: LD_STRING hideTroll();
11273: PPUSH
11274: CALL_OW 559
// wait ( 1 1$00 ) ;
11278: LD_INT 2100
11280: PPUSH
11281: CALL_OW 67
// ToLua ( displayTroll(); ) ;
11285: LD_STRING displayTroll();
11287: PPUSH
11288: CALL_OW 559
// wait ( 1 1$00 ) ;
11292: LD_INT 2100
11294: PPUSH
11295: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11299: LD_STRING hideTroll();
11301: PPUSH
11302: CALL_OW 559
// end ;
11306: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11307: LD_EXP 12
11311: PUSH
11312: LD_EXP 38
11316: AND
11317: IFFALSE 11380
11319: GO 11321
11321: DISABLE
11322: LD_INT 0
11324: PPUSH
// begin p := 0 ;
11325: LD_ADDR_VAR 0 1
11329: PUSH
11330: LD_INT 0
11332: ST_TO_ADDR
// repeat game_speed := 1 ;
11333: LD_ADDR_OWVAR 65
11337: PUSH
11338: LD_INT 1
11340: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11341: LD_INT 35
11343: PPUSH
11344: CALL_OW 67
// p := p + 1 ;
11348: LD_ADDR_VAR 0 1
11352: PUSH
11353: LD_VAR 0 1
11357: PUSH
11358: LD_INT 1
11360: PLUS
11361: ST_TO_ADDR
// until p >= 60 ;
11362: LD_VAR 0 1
11366: PUSH
11367: LD_INT 60
11369: GREATEREQUAL
11370: IFFALSE 11333
// game_speed := 4 ;
11372: LD_ADDR_OWVAR 65
11376: PUSH
11377: LD_INT 4
11379: ST_TO_ADDR
// end ;
11380: PPOPN 1
11382: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11383: LD_EXP 12
11387: PUSH
11388: LD_EXP 39
11392: AND
11393: IFFALSE 11539
11395: GO 11397
11397: DISABLE
11398: LD_INT 0
11400: PPUSH
11401: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11402: LD_ADDR_VAR 0 1
11406: PUSH
11407: LD_INT 22
11409: PUSH
11410: LD_OWVAR 2
11414: PUSH
11415: EMPTY
11416: LIST
11417: LIST
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 30
11424: PUSH
11425: LD_INT 0
11427: PUSH
11428: EMPTY
11429: LIST
11430: LIST
11431: PUSH
11432: LD_INT 30
11434: PUSH
11435: LD_INT 1
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: LIST
11446: PUSH
11447: EMPTY
11448: LIST
11449: LIST
11450: PPUSH
11451: CALL_OW 69
11455: ST_TO_ADDR
// if not depot then
11456: LD_VAR 0 1
11460: NOT
11461: IFFALSE 11465
// exit ;
11463: GO 11539
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11465: LD_ADDR_VAR 0 2
11469: PUSH
11470: LD_VAR 0 1
11474: PUSH
11475: LD_INT 1
11477: PPUSH
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL_OW 12
11487: ARRAY
11488: PPUSH
11489: CALL_OW 274
11493: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11494: LD_VAR 0 2
11498: PPUSH
11499: LD_INT 1
11501: PPUSH
11502: LD_INT 0
11504: PPUSH
11505: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11509: LD_VAR 0 2
11513: PPUSH
11514: LD_INT 2
11516: PPUSH
11517: LD_INT 0
11519: PPUSH
11520: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11524: LD_VAR 0 2
11528: PPUSH
11529: LD_INT 3
11531: PPUSH
11532: LD_INT 0
11534: PPUSH
11535: CALL_OW 277
// end ;
11539: PPOPN 2
11541: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
11542: LD_EXP 12
11546: PUSH
11547: LD_EXP 40
11551: AND
11552: IFFALSE 11649
11554: GO 11556
11556: DISABLE
11557: LD_INT 0
11559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11560: LD_ADDR_VAR 0 1
11564: PUSH
11565: LD_INT 22
11567: PUSH
11568: LD_OWVAR 2
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 21
11579: PUSH
11580: LD_INT 1
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 3
11589: PUSH
11590: LD_INT 23
11592: PUSH
11593: LD_INT 0
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: LIST
11608: PPUSH
11609: CALL_OW 69
11613: ST_TO_ADDR
// if not tmp then
11614: LD_VAR 0 1
11618: NOT
11619: IFFALSE 11623
// exit ;
11621: GO 11649
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11623: LD_VAR 0 1
11627: PUSH
11628: LD_INT 1
11630: PPUSH
11631: LD_VAR 0 1
11635: PPUSH
11636: CALL_OW 12
11640: ARRAY
11641: PPUSH
11642: LD_INT 200
11644: PPUSH
11645: CALL_OW 234
// end ;
11649: PPOPN 1
11651: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11652: LD_EXP 12
11656: PUSH
11657: LD_EXP 41
11661: AND
11662: IFFALSE 11741
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_OWVAR 2
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PPUSH
11701: CALL_OW 69
11705: ST_TO_ADDR
// if not tmp then
11706: LD_VAR 0 1
11710: NOT
11711: IFFALSE 11715
// exit ;
11713: GO 11741
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
11715: LD_VAR 0 1
11719: PUSH
11720: LD_INT 1
11722: PPUSH
11723: LD_VAR 0 1
11727: PPUSH
11728: CALL_OW 12
11732: ARRAY
11733: PPUSH
11734: LD_INT 60
11736: PPUSH
11737: CALL_OW 234
// end ;
11741: PPOPN 1
11743: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11744: LD_EXP 12
11748: PUSH
11749: LD_EXP 42
11753: AND
11754: IFFALSE 11853
11756: GO 11758
11758: DISABLE
11759: LD_INT 0
11761: PPUSH
11762: PPUSH
// begin enable ;
11763: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11764: LD_ADDR_VAR 0 1
11768: PUSH
11769: LD_INT 22
11771: PUSH
11772: LD_OWVAR 2
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: LD_INT 61
11783: PUSH
11784: EMPTY
11785: LIST
11786: PUSH
11787: LD_INT 33
11789: PUSH
11790: LD_INT 2
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// if not tmp then
11807: LD_VAR 0 1
11811: NOT
11812: IFFALSE 11816
// exit ;
11814: GO 11853
// for i in tmp do
11816: LD_ADDR_VAR 0 2
11820: PUSH
11821: LD_VAR 0 1
11825: PUSH
11826: FOR_IN
11827: IFFALSE 11851
// if IsControledBy ( i ) then
11829: LD_VAR 0 2
11833: PPUSH
11834: CALL_OW 312
11838: IFFALSE 11849
// ComUnlink ( i ) ;
11840: LD_VAR 0 2
11844: PPUSH
11845: CALL_OW 136
11849: GO 11826
11851: POP
11852: POP
// end ;
11853: PPOPN 2
11855: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
11856: LD_EXP 12
11860: PUSH
11861: LD_EXP 43
11865: AND
11866: IFFALSE 12006
11868: GO 11870
11870: DISABLE
11871: LD_INT 0
11873: PPUSH
11874: PPUSH
// begin ToLua ( displayPowell(); ) ;
11875: LD_STRING displayPowell();
11877: PPUSH
11878: CALL_OW 559
// uc_side := 0 ;
11882: LD_ADDR_OWVAR 20
11886: PUSH
11887: LD_INT 0
11889: ST_TO_ADDR
// uc_nation := 2 ;
11890: LD_ADDR_OWVAR 21
11894: PUSH
11895: LD_INT 2
11897: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
11898: LD_ADDR_OWVAR 37
11902: PUSH
11903: LD_INT 14
11905: ST_TO_ADDR
// vc_engine := engine_siberite ;
11906: LD_ADDR_OWVAR 39
11910: PUSH
11911: LD_INT 3
11913: ST_TO_ADDR
// vc_control := control_apeman ;
11914: LD_ADDR_OWVAR 38
11918: PUSH
11919: LD_INT 5
11921: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
11922: LD_ADDR_OWVAR 40
11926: PUSH
11927: LD_INT 29
11929: ST_TO_ADDR
// un := CreateVehicle ;
11930: LD_ADDR_VAR 0 2
11934: PUSH
11935: CALL_OW 45
11939: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11940: LD_VAR 0 2
11944: PPUSH
11945: LD_INT 1
11947: PPUSH
11948: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11952: LD_INT 35
11954: PPUSH
11955: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11959: LD_VAR 0 2
11963: PPUSH
11964: LD_INT 22
11966: PUSH
11967: LD_OWVAR 2
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PPUSH
11976: CALL_OW 69
11980: PPUSH
11981: LD_VAR 0 2
11985: PPUSH
11986: CALL_OW 74
11990: PPUSH
11991: CALL_OW 115
// until IsDead ( un ) ;
11995: LD_VAR 0 2
11999: PPUSH
12000: CALL_OW 301
12004: IFFALSE 11952
// end ;
12006: PPOPN 2
12008: END
// every 0 0$1 trigger StreamModeActive and sStu do
12009: LD_EXP 12
12013: PUSH
12014: LD_EXP 51
12018: AND
12019: IFFALSE 12035
12021: GO 12023
12023: DISABLE
// begin ToLua ( displayStucuk(); ) ;
12024: LD_STRING displayStucuk();
12026: PPUSH
12027: CALL_OW 559
// ResetFog ;
12031: CALL_OW 335
// end ;
12035: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
12036: LD_EXP 12
12040: PUSH
12041: LD_EXP 44
12045: AND
12046: IFFALSE 12187
12048: GO 12050
12050: DISABLE
12051: LD_INT 0
12053: PPUSH
12054: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12055: LD_ADDR_VAR 0 2
12059: PUSH
12060: LD_INT 22
12062: PUSH
12063: LD_OWVAR 2
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: LD_INT 21
12074: PUSH
12075: LD_INT 1
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PPUSH
12086: CALL_OW 69
12090: ST_TO_ADDR
// if not tmp then
12091: LD_VAR 0 2
12095: NOT
12096: IFFALSE 12100
// exit ;
12098: GO 12187
// un := tmp [ rand ( 1 , tmp ) ] ;
12100: LD_ADDR_VAR 0 1
12104: PUSH
12105: LD_VAR 0 2
12109: PUSH
12110: LD_INT 1
12112: PPUSH
12113: LD_VAR 0 2
12117: PPUSH
12118: CALL_OW 12
12122: ARRAY
12123: ST_TO_ADDR
// SetSide ( un , 0 ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_INT 0
12131: PPUSH
12132: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
12136: LD_VAR 0 1
12140: PPUSH
12141: LD_OWVAR 3
12145: PUSH
12146: LD_VAR 0 1
12150: DIFF
12151: PPUSH
12152: LD_VAR 0 1
12156: PPUSH
12157: CALL_OW 74
12161: PPUSH
12162: CALL_OW 115
// wait ( 0 0$20 ) ;
12166: LD_INT 700
12168: PPUSH
12169: CALL_OW 67
// SetSide ( un , your_side ) ;
12173: LD_VAR 0 1
12177: PPUSH
12178: LD_OWVAR 2
12182: PPUSH
12183: CALL_OW 235
// end ;
12187: PPOPN 2
12189: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
12190: LD_EXP 12
12194: PUSH
12195: LD_EXP 45
12199: AND
12200: IFFALSE 12306
12202: GO 12204
12204: DISABLE
12205: LD_INT 0
12207: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12208: LD_ADDR_VAR 0 1
12212: PUSH
12213: LD_INT 22
12215: PUSH
12216: LD_OWVAR 2
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: PUSH
12225: LD_INT 2
12227: PUSH
12228: LD_INT 30
12230: PUSH
12231: LD_INT 0
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PUSH
12238: LD_INT 30
12240: PUSH
12241: LD_INT 1
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: PPUSH
12257: CALL_OW 69
12261: ST_TO_ADDR
// if not depot then
12262: LD_VAR 0 1
12266: NOT
12267: IFFALSE 12271
// exit ;
12269: GO 12306
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
12271: LD_VAR 0 1
12275: PUSH
12276: LD_INT 1
12278: ARRAY
12279: PPUSH
12280: CALL_OW 250
12284: PPUSH
12285: LD_VAR 0 1
12289: PUSH
12290: LD_INT 1
12292: ARRAY
12293: PPUSH
12294: CALL_OW 251
12298: PPUSH
12299: LD_INT 70
12301: PPUSH
12302: CALL_OW 495
// end ;
12306: PPOPN 1
12308: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
12309: LD_EXP 12
12313: PUSH
12314: LD_EXP 46
12318: AND
12319: IFFALSE 12530
12321: GO 12323
12323: DISABLE
12324: LD_INT 0
12326: PPUSH
12327: PPUSH
12328: PPUSH
12329: PPUSH
12330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12331: LD_ADDR_VAR 0 5
12335: PUSH
12336: LD_INT 22
12338: PUSH
12339: LD_OWVAR 2
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 21
12350: PUSH
12351: LD_INT 1
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PPUSH
12362: CALL_OW 69
12366: ST_TO_ADDR
// if not tmp then
12367: LD_VAR 0 5
12371: NOT
12372: IFFALSE 12376
// exit ;
12374: GO 12530
// for i in tmp do
12376: LD_ADDR_VAR 0 1
12380: PUSH
12381: LD_VAR 0 5
12385: PUSH
12386: FOR_IN
12387: IFFALSE 12528
// begin d := rand ( 0 , 5 ) ;
12389: LD_ADDR_VAR 0 4
12393: PUSH
12394: LD_INT 0
12396: PPUSH
12397: LD_INT 5
12399: PPUSH
12400: CALL_OW 12
12404: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
12405: LD_ADDR_VAR 0 2
12409: PUSH
12410: LD_VAR 0 1
12414: PPUSH
12415: CALL_OW 250
12419: PPUSH
12420: LD_VAR 0 4
12424: PPUSH
12425: LD_INT 3
12427: PPUSH
12428: LD_INT 12
12430: PPUSH
12431: CALL_OW 12
12435: PPUSH
12436: CALL_OW 272
12440: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
12441: LD_ADDR_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: PPUSH
12451: CALL_OW 251
12455: PPUSH
12456: LD_VAR 0 4
12460: PPUSH
12461: LD_INT 3
12463: PPUSH
12464: LD_INT 12
12466: PPUSH
12467: CALL_OW 12
12471: PPUSH
12472: CALL_OW 273
12476: ST_TO_ADDR
// if ValidHex ( x , y ) then
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_VAR 0 3
12486: PPUSH
12487: CALL_OW 488
12491: IFFALSE 12526
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
12493: LD_VAR 0 1
12497: PPUSH
12498: LD_VAR 0 2
12502: PPUSH
12503: LD_VAR 0 3
12507: PPUSH
12508: LD_INT 3
12510: PPUSH
12511: LD_INT 6
12513: PPUSH
12514: CALL_OW 12
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: CALL_OW 483
// end ;
12526: GO 12386
12528: POP
12529: POP
// end ;
12530: PPOPN 5
12532: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
12533: LD_EXP 12
12537: PUSH
12538: LD_EXP 47
12542: AND
12543: IFFALSE 12637
12545: GO 12547
12547: DISABLE
12548: LD_INT 0
12550: PPUSH
12551: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
12552: LD_ADDR_VAR 0 2
12556: PUSH
12557: LD_INT 22
12559: PUSH
12560: LD_OWVAR 2
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 32
12571: PUSH
12572: LD_INT 1
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 21
12581: PUSH
12582: LD_INT 2
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: LIST
12593: PPUSH
12594: CALL_OW 69
12598: ST_TO_ADDR
// if not tmp then
12599: LD_VAR 0 2
12603: NOT
12604: IFFALSE 12608
// exit ;
12606: GO 12637
// for i in tmp do
12608: LD_ADDR_VAR 0 1
12612: PUSH
12613: LD_VAR 0 2
12617: PUSH
12618: FOR_IN
12619: IFFALSE 12635
// SetFuel ( i , 0 ) ;
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_INT 0
12628: PPUSH
12629: CALL_OW 240
12633: GO 12618
12635: POP
12636: POP
// end ;
12637: PPOPN 2
12639: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
12640: LD_EXP 12
12644: PUSH
12645: LD_EXP 48
12649: AND
12650: IFFALSE 12716
12652: GO 12654
12654: DISABLE
12655: LD_INT 0
12657: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_INT 22
12665: PUSH
12666: LD_OWVAR 2
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: LD_INT 30
12677: PUSH
12678: LD_INT 29
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL_OW 69
12693: ST_TO_ADDR
// if not tmp then
12694: LD_VAR 0 1
12698: NOT
12699: IFFALSE 12703
// exit ;
12701: GO 12716
// DestroyUnit ( tmp [ 1 ] ) ;
12703: LD_VAR 0 1
12707: PUSH
12708: LD_INT 1
12710: ARRAY
12711: PPUSH
12712: CALL_OW 65
// end ;
12716: PPOPN 1
12718: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
12719: LD_EXP 12
12723: PUSH
12724: LD_EXP 50
12728: AND
12729: IFFALSE 12858
12731: GO 12733
12733: DISABLE
12734: LD_INT 0
12736: PPUSH
// begin uc_side := 0 ;
12737: LD_ADDR_OWVAR 20
12741: PUSH
12742: LD_INT 0
12744: ST_TO_ADDR
// uc_nation := nation_arabian ;
12745: LD_ADDR_OWVAR 21
12749: PUSH
12750: LD_INT 2
12752: ST_TO_ADDR
// hc_gallery :=  ;
12753: LD_ADDR_OWVAR 33
12757: PUSH
12758: LD_STRING 
12760: ST_TO_ADDR
// hc_name :=  ;
12761: LD_ADDR_OWVAR 26
12765: PUSH
12766: LD_STRING 
12768: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
12769: LD_INT 1
12771: PPUSH
12772: LD_INT 11
12774: PPUSH
12775: LD_INT 10
12777: PPUSH
12778: CALL_OW 380
// un := CreateHuman ;
12782: LD_ADDR_VAR 0 1
12786: PUSH
12787: CALL_OW 44
12791: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12792: LD_VAR 0 1
12796: PPUSH
12797: LD_INT 1
12799: PPUSH
12800: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
12804: LD_INT 35
12806: PPUSH
12807: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
12811: LD_VAR 0 1
12815: PPUSH
12816: LD_INT 22
12818: PUSH
12819: LD_OWVAR 2
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: PPUSH
12828: CALL_OW 69
12832: PPUSH
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 74
12842: PPUSH
12843: CALL_OW 115
// until IsDead ( un ) ;
12847: LD_VAR 0 1
12851: PPUSH
12852: CALL_OW 301
12856: IFFALSE 12804
// end ;
12858: PPOPN 1
12860: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
12861: LD_EXP 12
12865: PUSH
12866: LD_EXP 52
12870: AND
12871: IFFALSE 12883
12873: GO 12875
12875: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
12876: LD_STRING earthquake(getX(game), 0, 32)
12878: PPUSH
12879: CALL_OW 559
12883: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
12884: LD_EXP 12
12888: PUSH
12889: LD_EXP 53
12893: AND
12894: IFFALSE 12985
12896: GO 12898
12898: DISABLE
12899: LD_INT 0
12901: PPUSH
// begin enable ;
12902: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
12903: LD_ADDR_VAR 0 1
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_OWVAR 2
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: PUSH
12920: LD_INT 21
12922: PUSH
12923: LD_INT 2
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: LD_INT 33
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: LIST
12944: PPUSH
12945: CALL_OW 69
12949: ST_TO_ADDR
// if not tmp then
12950: LD_VAR 0 1
12954: NOT
12955: IFFALSE 12959
// exit ;
12957: GO 12985
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
12959: LD_VAR 0 1
12963: PUSH
12964: LD_INT 1
12966: PPUSH
12967: LD_VAR 0 1
12971: PPUSH
12972: CALL_OW 12
12976: ARRAY
12977: PPUSH
12978: LD_INT 1
12980: PPUSH
12981: CALL_OW 234
// end ;
12985: PPOPN 1
12987: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
12988: LD_EXP 12
12992: PUSH
12993: LD_EXP 54
12997: AND
12998: IFFALSE 13139
13000: GO 13002
13002: DISABLE
13003: LD_INT 0
13005: PPUSH
13006: PPUSH
13007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13008: LD_ADDR_VAR 0 3
13012: PUSH
13013: LD_INT 22
13015: PUSH
13016: LD_OWVAR 2
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: PUSH
13025: LD_INT 25
13027: PUSH
13028: LD_INT 1
13030: PUSH
13031: EMPTY
13032: LIST
13033: LIST
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PPUSH
13039: CALL_OW 69
13043: ST_TO_ADDR
// if not tmp then
13044: LD_VAR 0 3
13048: NOT
13049: IFFALSE 13053
// exit ;
13051: GO 13139
// un := tmp [ rand ( 1 , tmp ) ] ;
13053: LD_ADDR_VAR 0 2
13057: PUSH
13058: LD_VAR 0 3
13062: PUSH
13063: LD_INT 1
13065: PPUSH
13066: LD_VAR 0 3
13070: PPUSH
13071: CALL_OW 12
13075: ARRAY
13076: ST_TO_ADDR
// if Crawls ( un ) then
13077: LD_VAR 0 2
13081: PPUSH
13082: CALL_OW 318
13086: IFFALSE 13097
// ComWalk ( un ) ;
13088: LD_VAR 0 2
13092: PPUSH
13093: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
13097: LD_VAR 0 2
13101: PPUSH
13102: LD_INT 9
13104: PPUSH
13105: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
13109: LD_INT 28
13111: PPUSH
13112: LD_OWVAR 2
13116: PPUSH
13117: LD_INT 2
13119: PPUSH
13120: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
13124: LD_INT 29
13126: PPUSH
13127: LD_OWVAR 2
13131: PPUSH
13132: LD_INT 2
13134: PPUSH
13135: CALL_OW 322
// end ;
13139: PPOPN 3
13141: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
13142: LD_EXP 12
13146: PUSH
13147: LD_EXP 55
13151: AND
13152: IFFALSE 13263
13154: GO 13156
13156: DISABLE
13157: LD_INT 0
13159: PPUSH
13160: PPUSH
13161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13162: LD_ADDR_VAR 0 3
13166: PUSH
13167: LD_INT 22
13169: PUSH
13170: LD_OWVAR 2
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: PUSH
13179: LD_INT 25
13181: PUSH
13182: LD_INT 1
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: PUSH
13189: EMPTY
13190: LIST
13191: LIST
13192: PPUSH
13193: CALL_OW 69
13197: ST_TO_ADDR
// if not tmp then
13198: LD_VAR 0 3
13202: NOT
13203: IFFALSE 13207
// exit ;
13205: GO 13263
// un := tmp [ rand ( 1 , tmp ) ] ;
13207: LD_ADDR_VAR 0 2
13211: PUSH
13212: LD_VAR 0 3
13216: PUSH
13217: LD_INT 1
13219: PPUSH
13220: LD_VAR 0 3
13224: PPUSH
13225: CALL_OW 12
13229: ARRAY
13230: ST_TO_ADDR
// if Crawls ( un ) then
13231: LD_VAR 0 2
13235: PPUSH
13236: CALL_OW 318
13240: IFFALSE 13251
// ComWalk ( un ) ;
13242: LD_VAR 0 2
13246: PPUSH
13247: CALL_OW 138
// SetClass ( un , class_mortar ) ;
13251: LD_VAR 0 2
13255: PPUSH
13256: LD_INT 8
13258: PPUSH
13259: CALL_OW 336
// end ;
13263: PPOPN 3
13265: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
13266: LD_EXP 12
13270: PUSH
13271: LD_EXP 56
13275: AND
13276: IFFALSE 13420
13278: GO 13280
13280: DISABLE
13281: LD_INT 0
13283: PPUSH
13284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
13285: LD_ADDR_VAR 0 2
13289: PUSH
13290: LD_INT 22
13292: PUSH
13293: LD_OWVAR 2
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: PUSH
13302: LD_INT 21
13304: PUSH
13305: LD_INT 2
13307: PUSH
13308: EMPTY
13309: LIST
13310: LIST
13311: PUSH
13312: LD_INT 2
13314: PUSH
13315: LD_INT 34
13317: PUSH
13318: LD_INT 12
13320: PUSH
13321: EMPTY
13322: LIST
13323: LIST
13324: PUSH
13325: LD_INT 34
13327: PUSH
13328: LD_INT 51
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 34
13337: PUSH
13338: LD_INT 32
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: EMPTY
13346: LIST
13347: LIST
13348: LIST
13349: LIST
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: LIST
13355: PPUSH
13356: CALL_OW 69
13360: ST_TO_ADDR
// if not tmp then
13361: LD_VAR 0 2
13365: NOT
13366: IFFALSE 13370
// exit ;
13368: GO 13420
// for i in tmp do
13370: LD_ADDR_VAR 0 1
13374: PUSH
13375: LD_VAR 0 2
13379: PUSH
13380: FOR_IN
13381: IFFALSE 13418
// if GetCargo ( i , mat_artifact ) = 0 then
13383: LD_VAR 0 1
13387: PPUSH
13388: LD_INT 4
13390: PPUSH
13391: CALL_OW 289
13395: PUSH
13396: LD_INT 0
13398: EQUAL
13399: IFFALSE 13416
// SetCargo ( i , mat_siberit , 100 ) ;
13401: LD_VAR 0 1
13405: PPUSH
13406: LD_INT 3
13408: PPUSH
13409: LD_INT 100
13411: PPUSH
13412: CALL_OW 290
13416: GO 13380
13418: POP
13419: POP
// end ;
13420: PPOPN 2
13422: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
13423: LD_EXP 12
13427: PUSH
13428: LD_EXP 57
13432: AND
13433: IFFALSE 13586
13435: GO 13437
13437: DISABLE
13438: LD_INT 0
13440: PPUSH
13441: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
13442: LD_ADDR_VAR 0 2
13446: PUSH
13447: LD_INT 22
13449: PUSH
13450: LD_OWVAR 2
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PPUSH
13459: CALL_OW 69
13463: ST_TO_ADDR
// if not tmp then
13464: LD_VAR 0 2
13468: NOT
13469: IFFALSE 13473
// exit ;
13471: GO 13586
// for i := 1 to 2 do
13473: LD_ADDR_VAR 0 1
13477: PUSH
13478: DOUBLE
13479: LD_INT 1
13481: DEC
13482: ST_TO_ADDR
13483: LD_INT 2
13485: PUSH
13486: FOR_TO
13487: IFFALSE 13584
// begin uc_side := your_side ;
13489: LD_ADDR_OWVAR 20
13493: PUSH
13494: LD_OWVAR 2
13498: ST_TO_ADDR
// uc_nation := nation_american ;
13499: LD_ADDR_OWVAR 21
13503: PUSH
13504: LD_INT 1
13506: ST_TO_ADDR
// vc_chassis := us_morphling ;
13507: LD_ADDR_OWVAR 37
13511: PUSH
13512: LD_INT 5
13514: ST_TO_ADDR
// vc_engine := engine_siberite ;
13515: LD_ADDR_OWVAR 39
13519: PUSH
13520: LD_INT 3
13522: ST_TO_ADDR
// vc_control := control_computer ;
13523: LD_ADDR_OWVAR 38
13527: PUSH
13528: LD_INT 3
13530: ST_TO_ADDR
// vc_weapon := us_double_laser ;
13531: LD_ADDR_OWVAR 40
13535: PUSH
13536: LD_INT 10
13538: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
13539: CALL_OW 45
13543: PPUSH
13544: LD_VAR 0 2
13548: PUSH
13549: LD_INT 1
13551: ARRAY
13552: PPUSH
13553: CALL_OW 250
13557: PPUSH
13558: LD_VAR 0 2
13562: PUSH
13563: LD_INT 1
13565: ARRAY
13566: PPUSH
13567: CALL_OW 251
13571: PPUSH
13572: LD_INT 12
13574: PPUSH
13575: LD_INT 1
13577: PPUSH
13578: CALL_OW 50
// end ;
13582: GO 13486
13584: POP
13585: POP
// end ;
13586: PPOPN 2
13588: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
13589: LD_EXP 12
13593: PUSH
13594: LD_EXP 58
13598: AND
13599: IFFALSE 13821
13601: GO 13603
13603: DISABLE
13604: LD_INT 0
13606: PPUSH
13607: PPUSH
13608: PPUSH
13609: PPUSH
13610: PPUSH
13611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13612: LD_ADDR_VAR 0 6
13616: PUSH
13617: LD_INT 22
13619: PUSH
13620: LD_OWVAR 2
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: PUSH
13629: LD_INT 21
13631: PUSH
13632: LD_INT 1
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: PUSH
13639: LD_INT 3
13641: PUSH
13642: LD_INT 23
13644: PUSH
13645: LD_INT 0
13647: PUSH
13648: EMPTY
13649: LIST
13650: LIST
13651: PUSH
13652: EMPTY
13653: LIST
13654: LIST
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: PPUSH
13661: CALL_OW 69
13665: ST_TO_ADDR
// if not tmp then
13666: LD_VAR 0 6
13670: NOT
13671: IFFALSE 13675
// exit ;
13673: GO 13821
// s1 := rand ( 1 , 4 ) ;
13675: LD_ADDR_VAR 0 2
13679: PUSH
13680: LD_INT 1
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: CALL_OW 12
13690: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
13691: LD_ADDR_VAR 0 4
13695: PUSH
13696: LD_VAR 0 6
13700: PUSH
13701: LD_INT 1
13703: ARRAY
13704: PPUSH
13705: LD_VAR 0 2
13709: PPUSH
13710: CALL_OW 259
13714: ST_TO_ADDR
// if s1 = 1 then
13715: LD_VAR 0 2
13719: PUSH
13720: LD_INT 1
13722: EQUAL
13723: IFFALSE 13743
// s2 := rand ( 2 , 4 ) else
13725: LD_ADDR_VAR 0 3
13729: PUSH
13730: LD_INT 2
13732: PPUSH
13733: LD_INT 4
13735: PPUSH
13736: CALL_OW 12
13740: ST_TO_ADDR
13741: GO 13751
// s2 := 1 ;
13743: LD_ADDR_VAR 0 3
13747: PUSH
13748: LD_INT 1
13750: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
13751: LD_ADDR_VAR 0 5
13755: PUSH
13756: LD_VAR 0 6
13760: PUSH
13761: LD_INT 1
13763: ARRAY
13764: PPUSH
13765: LD_VAR 0 3
13769: PPUSH
13770: CALL_OW 259
13774: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
13775: LD_VAR 0 6
13779: PUSH
13780: LD_INT 1
13782: ARRAY
13783: PPUSH
13784: LD_VAR 0 2
13788: PPUSH
13789: LD_VAR 0 5
13793: PPUSH
13794: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
13798: LD_VAR 0 6
13802: PUSH
13803: LD_INT 1
13805: ARRAY
13806: PPUSH
13807: LD_VAR 0 3
13811: PPUSH
13812: LD_VAR 0 4
13816: PPUSH
13817: CALL_OW 237
// end ;
13821: PPOPN 6
13823: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
13824: LD_EXP 12
13828: PUSH
13829: LD_EXP 59
13833: AND
13834: IFFALSE 13913
13836: GO 13838
13838: DISABLE
13839: LD_INT 0
13841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
13842: LD_ADDR_VAR 0 1
13846: PUSH
13847: LD_INT 22
13849: PUSH
13850: LD_OWVAR 2
13854: PUSH
13855: EMPTY
13856: LIST
13857: LIST
13858: PUSH
13859: LD_INT 30
13861: PUSH
13862: LD_INT 3
13864: PUSH
13865: EMPTY
13866: LIST
13867: LIST
13868: PUSH
13869: EMPTY
13870: LIST
13871: LIST
13872: PPUSH
13873: CALL_OW 69
13877: ST_TO_ADDR
// if not tmp then
13878: LD_VAR 0 1
13882: NOT
13883: IFFALSE 13887
// exit ;
13885: GO 13913
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
13887: LD_VAR 0 1
13891: PUSH
13892: LD_INT 1
13894: PPUSH
13895: LD_VAR 0 1
13899: PPUSH
13900: CALL_OW 12
13904: ARRAY
13905: PPUSH
13906: LD_INT 1
13908: PPUSH
13909: CALL_OW 234
// end ;
13913: PPOPN 1
13915: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
13916: LD_EXP 12
13920: PUSH
13921: LD_EXP 60
13925: AND
13926: IFFALSE 14038
13928: GO 13930
13930: DISABLE
13931: LD_INT 0
13933: PPUSH
13934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
13935: LD_ADDR_VAR 0 2
13939: PUSH
13940: LD_INT 22
13942: PUSH
13943: LD_OWVAR 2
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 2
13954: PUSH
13955: LD_INT 30
13957: PUSH
13958: LD_INT 27
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: PUSH
13965: LD_INT 30
13967: PUSH
13968: LD_INT 26
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PUSH
13975: LD_INT 30
13977: PUSH
13978: LD_INT 28
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: LIST
13989: LIST
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PPUSH
13995: CALL_OW 69
13999: ST_TO_ADDR
// if not tmp then
14000: LD_VAR 0 2
14004: NOT
14005: IFFALSE 14009
// exit ;
14007: GO 14038
// for i in tmp do
14009: LD_ADDR_VAR 0 1
14013: PUSH
14014: LD_VAR 0 2
14018: PUSH
14019: FOR_IN
14020: IFFALSE 14036
// SetLives ( i , 1 ) ;
14022: LD_VAR 0 1
14026: PPUSH
14027: LD_INT 1
14029: PPUSH
14030: CALL_OW 234
14034: GO 14019
14036: POP
14037: POP
// end ;
14038: PPOPN 2
14040: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
14041: LD_EXP 12
14045: PUSH
14046: LD_EXP 61
14050: AND
14051: IFFALSE 14325
14053: GO 14055
14055: DISABLE
14056: LD_INT 0
14058: PPUSH
14059: PPUSH
14060: PPUSH
// begin i := rand ( 1 , 7 ) ;
14061: LD_ADDR_VAR 0 1
14065: PUSH
14066: LD_INT 1
14068: PPUSH
14069: LD_INT 7
14071: PPUSH
14072: CALL_OW 12
14076: ST_TO_ADDR
// case i of 1 :
14077: LD_VAR 0 1
14081: PUSH
14082: LD_INT 1
14084: DOUBLE
14085: EQUAL
14086: IFTRUE 14090
14088: GO 14100
14090: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
14091: LD_STRING earthquake(getX(game), 0, 32)
14093: PPUSH
14094: CALL_OW 559
14098: GO 14325
14100: LD_INT 2
14102: DOUBLE
14103: EQUAL
14104: IFTRUE 14108
14106: GO 14122
14108: POP
// begin ToLua ( displayStucuk(); ) ;
14109: LD_STRING displayStucuk();
14111: PPUSH
14112: CALL_OW 559
// ResetFog ;
14116: CALL_OW 335
// end ; 3 :
14120: GO 14325
14122: LD_INT 3
14124: DOUBLE
14125: EQUAL
14126: IFTRUE 14130
14128: GO 14234
14130: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14131: LD_ADDR_VAR 0 2
14135: PUSH
14136: LD_INT 22
14138: PUSH
14139: LD_OWVAR 2
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_INT 25
14150: PUSH
14151: LD_INT 1
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: PUSH
14158: EMPTY
14159: LIST
14160: LIST
14161: PPUSH
14162: CALL_OW 69
14166: ST_TO_ADDR
// if not tmp then
14167: LD_VAR 0 2
14171: NOT
14172: IFFALSE 14176
// exit ;
14174: GO 14325
// un := tmp [ rand ( 1 , tmp ) ] ;
14176: LD_ADDR_VAR 0 3
14180: PUSH
14181: LD_VAR 0 2
14185: PUSH
14186: LD_INT 1
14188: PPUSH
14189: LD_VAR 0 2
14193: PPUSH
14194: CALL_OW 12
14198: ARRAY
14199: ST_TO_ADDR
// if Crawls ( un ) then
14200: LD_VAR 0 3
14204: PPUSH
14205: CALL_OW 318
14209: IFFALSE 14220
// ComWalk ( un ) ;
14211: LD_VAR 0 3
14215: PPUSH
14216: CALL_OW 138
// SetClass ( un , class_mortar ) ;
14220: LD_VAR 0 3
14224: PPUSH
14225: LD_INT 8
14227: PPUSH
14228: CALL_OW 336
// end ; 4 :
14232: GO 14325
14234: LD_INT 4
14236: DOUBLE
14237: EQUAL
14238: IFTRUE 14242
14240: GO 14303
14242: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14243: LD_ADDR_VAR 0 2
14247: PUSH
14248: LD_INT 22
14250: PUSH
14251: LD_OWVAR 2
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 29
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PPUSH
14274: CALL_OW 69
14278: ST_TO_ADDR
// if not tmp then
14279: LD_VAR 0 2
14283: NOT
14284: IFFALSE 14288
// exit ;
14286: GO 14325
// DestroyUnit ( tmp [ 1 ] ) ;
14288: LD_VAR 0 2
14292: PUSH
14293: LD_INT 1
14295: ARRAY
14296: PPUSH
14297: CALL_OW 65
// end ; 5 .. 7 :
14301: GO 14325
14303: LD_INT 5
14305: DOUBLE
14306: GREATEREQUAL
14307: IFFALSE 14315
14309: LD_INT 7
14311: DOUBLE
14312: LESSEQUAL
14313: IFTRUE 14317
14315: GO 14324
14317: POP
// StreamSibBomb ; end ;
14318: CALL 10605 0 0
14322: GO 14325
14324: POP
// end ;
14325: PPOPN 3
14327: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
14328: LD_EXP 12
14332: PUSH
14333: LD_EXP 62
14337: AND
14338: IFFALSE 14494
14340: GO 14342
14342: DISABLE
14343: LD_INT 0
14345: PPUSH
14346: PPUSH
14347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
14348: LD_ADDR_VAR 0 2
14352: PUSH
14353: LD_INT 81
14355: PUSH
14356: LD_OWVAR 2
14360: PUSH
14361: EMPTY
14362: LIST
14363: LIST
14364: PUSH
14365: LD_INT 2
14367: PUSH
14368: LD_INT 21
14370: PUSH
14371: LD_INT 1
14373: PUSH
14374: EMPTY
14375: LIST
14376: LIST
14377: PUSH
14378: LD_INT 21
14380: PUSH
14381: LD_INT 2
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: LIST
14392: PUSH
14393: EMPTY
14394: LIST
14395: LIST
14396: PPUSH
14397: CALL_OW 69
14401: ST_TO_ADDR
// if not tmp then
14402: LD_VAR 0 2
14406: NOT
14407: IFFALSE 14411
// exit ;
14409: GO 14494
// p := 0 ;
14411: LD_ADDR_VAR 0 3
14415: PUSH
14416: LD_INT 0
14418: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14419: LD_INT 35
14421: PPUSH
14422: CALL_OW 67
// p := p + 1 ;
14426: LD_ADDR_VAR 0 3
14430: PUSH
14431: LD_VAR 0 3
14435: PUSH
14436: LD_INT 1
14438: PLUS
14439: ST_TO_ADDR
// for i in tmp do
14440: LD_ADDR_VAR 0 1
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: FOR_IN
14451: IFFALSE 14482
// if GetLives ( i ) < 1000 then
14453: LD_VAR 0 1
14457: PPUSH
14458: CALL_OW 256
14462: PUSH
14463: LD_INT 1000
14465: LESS
14466: IFFALSE 14480
// SetLives ( i , 1000 ) ;
14468: LD_VAR 0 1
14472: PPUSH
14473: LD_INT 1000
14475: PPUSH
14476: CALL_OW 234
14480: GO 14450
14482: POP
14483: POP
// until p > 20 ;
14484: LD_VAR 0 3
14488: PUSH
14489: LD_INT 20
14491: GREATER
14492: IFFALSE 14419
// end ;
14494: PPOPN 3
14496: END
// every 0 0$1 trigger StreamModeActive and sTime do
14497: LD_EXP 12
14501: PUSH
14502: LD_EXP 63
14506: AND
14507: IFFALSE 14542
14509: GO 14511
14511: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
14512: LD_INT 28
14514: PPUSH
14515: LD_OWVAR 2
14519: PPUSH
14520: LD_INT 2
14522: PPUSH
14523: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
14527: LD_INT 30
14529: PPUSH
14530: LD_OWVAR 2
14534: PPUSH
14535: LD_INT 2
14537: PPUSH
14538: CALL_OW 322
// end ;
14542: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
14543: LD_EXP 12
14547: PUSH
14548: LD_EXP 64
14552: AND
14553: IFFALSE 14674
14555: GO 14557
14557: DISABLE
14558: LD_INT 0
14560: PPUSH
14561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14562: LD_ADDR_VAR 0 2
14566: PUSH
14567: LD_INT 22
14569: PUSH
14570: LD_OWVAR 2
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: PUSH
14579: LD_INT 21
14581: PUSH
14582: LD_INT 1
14584: PUSH
14585: EMPTY
14586: LIST
14587: LIST
14588: PUSH
14589: LD_INT 3
14591: PUSH
14592: LD_INT 23
14594: PUSH
14595: LD_INT 0
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PUSH
14606: EMPTY
14607: LIST
14608: LIST
14609: LIST
14610: PPUSH
14611: CALL_OW 69
14615: ST_TO_ADDR
// if not tmp then
14616: LD_VAR 0 2
14620: NOT
14621: IFFALSE 14625
// exit ;
14623: GO 14674
// for i in tmp do
14625: LD_ADDR_VAR 0 1
14629: PUSH
14630: LD_VAR 0 2
14634: PUSH
14635: FOR_IN
14636: IFFALSE 14672
// begin if Crawls ( i ) then
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 318
14647: IFFALSE 14658
// ComWalk ( i ) ;
14649: LD_VAR 0 1
14653: PPUSH
14654: CALL_OW 138
// SetClass ( i , 2 ) ;
14658: LD_VAR 0 1
14662: PPUSH
14663: LD_INT 2
14665: PPUSH
14666: CALL_OW 336
// end ;
14670: GO 14635
14672: POP
14673: POP
// end ;
14674: PPOPN 2
14676: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
14677: LD_EXP 12
14681: PUSH
14682: LD_EXP 65
14686: AND
14687: IFFALSE 14968
14689: GO 14691
14691: DISABLE
14692: LD_INT 0
14694: PPUSH
14695: PPUSH
14696: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
14697: LD_OWVAR 2
14701: PPUSH
14702: LD_INT 9
14704: PPUSH
14705: LD_INT 1
14707: PPUSH
14708: LD_INT 1
14710: PPUSH
14711: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
14715: LD_INT 9
14717: PPUSH
14718: LD_OWVAR 2
14722: PPUSH
14723: CALL_OW 343
// uc_side := 9 ;
14727: LD_ADDR_OWVAR 20
14731: PUSH
14732: LD_INT 9
14734: ST_TO_ADDR
// uc_nation := 2 ;
14735: LD_ADDR_OWVAR 21
14739: PUSH
14740: LD_INT 2
14742: ST_TO_ADDR
// hc_name := Dark Warrior ;
14743: LD_ADDR_OWVAR 26
14747: PUSH
14748: LD_STRING Dark Warrior
14750: ST_TO_ADDR
// hc_gallery :=  ;
14751: LD_ADDR_OWVAR 33
14755: PUSH
14756: LD_STRING 
14758: ST_TO_ADDR
// hc_noskilllimit := true ;
14759: LD_ADDR_OWVAR 76
14763: PUSH
14764: LD_INT 1
14766: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
14767: LD_ADDR_OWVAR 31
14771: PUSH
14772: LD_INT 30
14774: PUSH
14775: LD_INT 30
14777: PUSH
14778: LD_INT 30
14780: PUSH
14781: LD_INT 30
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: ST_TO_ADDR
// un := CreateHuman ;
14790: LD_ADDR_VAR 0 3
14794: PUSH
14795: CALL_OW 44
14799: ST_TO_ADDR
// hc_noskilllimit := false ;
14800: LD_ADDR_OWVAR 76
14804: PUSH
14805: LD_INT 0
14807: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14808: LD_VAR 0 3
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL_OW 51
// p := 0 ;
14820: LD_ADDR_VAR 0 2
14824: PUSH
14825: LD_INT 0
14827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14828: LD_INT 35
14830: PPUSH
14831: CALL_OW 67
// p := p + 1 ;
14835: LD_ADDR_VAR 0 2
14839: PUSH
14840: LD_VAR 0 2
14844: PUSH
14845: LD_INT 1
14847: PLUS
14848: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
14849: LD_VAR 0 3
14853: PPUSH
14854: CALL_OW 256
14858: PUSH
14859: LD_INT 1000
14861: LESS
14862: IFFALSE 14876
// SetLives ( un , 1000 ) ;
14864: LD_VAR 0 3
14868: PPUSH
14869: LD_INT 1000
14871: PPUSH
14872: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
14876: LD_VAR 0 3
14880: PPUSH
14881: LD_INT 81
14883: PUSH
14884: LD_OWVAR 2
14888: PUSH
14889: EMPTY
14890: LIST
14891: LIST
14892: PUSH
14893: LD_INT 91
14895: PUSH
14896: LD_VAR 0 3
14900: PUSH
14901: LD_INT 30
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PPUSH
14913: CALL_OW 69
14917: PPUSH
14918: LD_VAR 0 3
14922: PPUSH
14923: CALL_OW 74
14927: PPUSH
14928: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
14932: LD_VAR 0 2
14936: PUSH
14937: LD_INT 60
14939: GREATER
14940: PUSH
14941: LD_VAR 0 3
14945: PPUSH
14946: CALL_OW 301
14950: OR
14951: IFFALSE 14828
// if un then
14953: LD_VAR 0 3
14957: IFFALSE 14968
// RemoveUnit ( un ) ;
14959: LD_VAR 0 3
14963: PPUSH
14964: CALL_OW 64
// end ; end_of_file end_of_file
14968: PPOPN 3
14970: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
14971: GO 14973
14973: DISABLE
// begin ru_radar := 98 ;
14974: LD_ADDR_EXP 66
14978: PUSH
14979: LD_INT 98
14981: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
14982: LD_ADDR_EXP 67
14986: PUSH
14987: LD_INT 89
14989: ST_TO_ADDR
// us_hack := 99 ;
14990: LD_ADDR_EXP 68
14994: PUSH
14995: LD_INT 99
14997: ST_TO_ADDR
// us_artillery := 97 ;
14998: LD_ADDR_EXP 69
15002: PUSH
15003: LD_INT 97
15005: ST_TO_ADDR
// ar_bio_bomb := 91 ;
15006: LD_ADDR_EXP 70
15010: PUSH
15011: LD_INT 91
15013: ST_TO_ADDR
// tech_Artillery := 80 ;
15014: LD_ADDR_EXP 71
15018: PUSH
15019: LD_INT 80
15021: ST_TO_ADDR
// tech_RadMat := 81 ;
15022: LD_ADDR_EXP 72
15026: PUSH
15027: LD_INT 81
15029: ST_TO_ADDR
// tech_BasicTools := 82 ;
15030: LD_ADDR_EXP 73
15034: PUSH
15035: LD_INT 82
15037: ST_TO_ADDR
// tech_Cargo := 83 ;
15038: LD_ADDR_EXP 74
15042: PUSH
15043: LD_INT 83
15045: ST_TO_ADDR
// tech_Track := 84 ;
15046: LD_ADDR_EXP 75
15050: PUSH
15051: LD_INT 84
15053: ST_TO_ADDR
// tech_Crane := 85 ;
15054: LD_ADDR_EXP 76
15058: PUSH
15059: LD_INT 85
15061: ST_TO_ADDR
// tech_Bulldozer := 86 ;
15062: LD_ADDR_EXP 77
15066: PUSH
15067: LD_INT 86
15069: ST_TO_ADDR
// tech_Hovercraft := 87 ;
15070: LD_ADDR_EXP 78
15074: PUSH
15075: LD_INT 87
15077: ST_TO_ADDR
// end ;
15078: END
