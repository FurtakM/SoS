// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareGame ;
   4: CALL 13 0 0
// PrepareUnits ;
   8: CALL 250 0 0
// end ;
  12: END
// export mechanics , time_to_destroy , players , sib_bomb , time , veh_amount ; export p1 , p2 , p3 , p4 , p5 ; function PrepareGame ; var debug , i ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
// debug := false ;
  18: LD_ADDR_VAR 0 2
  22: PUSH
  23: LD_INT 0
  25: ST_TO_ADDR
// if debug then
  26: LD_VAR 0 2
  30: IFFALSE 81
// begin mechanics := 5 ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 5
  39: ST_TO_ADDR
// time_to_destroy := 45 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 45
  47: ST_TO_ADDR
// players := 4 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 4
  55: ST_TO_ADDR
// sib_bomb := true ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 1
  63: ST_TO_ADDR
// time := 3 3$00 ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 6300
  71: ST_TO_ADDR
// FogOff ( 1 ) ;
  72: LD_INT 1
  74: PPUSH
  75: CALL_OW 344
// end else
  79: GO 165
// begin time := 3 3$00 ;
  81: LD_ADDR_EXP 5
  85: PUSH
  86: LD_INT 6300
  88: ST_TO_ADDR
// players := 4 ;
  89: LD_ADDR_EXP 3
  93: PUSH
  94: LD_INT 4
  96: ST_TO_ADDR
// sib_bomb := true ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 1
 104: ST_TO_ADDR
// mechanics := 4 ;
 105: LD_ADDR_EXP 1
 109: PUSH
 110: LD_INT 4
 112: ST_TO_ADDR
// mechanics := GetMultiplayerSetting ( 0 ) ;
 113: LD_ADDR_EXP 1
 117: PUSH
 118: LD_INT 0
 120: PPUSH
 121: CALL_OW 426
 125: ST_TO_ADDR
// players := GetMultiplayerSetting ( 1 ) ;
 126: LD_ADDR_EXP 3
 130: PUSH
 131: LD_INT 1
 133: PPUSH
 134: CALL_OW 426
 138: ST_TO_ADDR
// time := GetMultiplayerSetting ( 2 ) ;
 139: LD_ADDR_EXP 5
 143: PUSH
 144: LD_INT 2
 146: PPUSH
 147: CALL_OW 426
 151: ST_TO_ADDR
// sib_bomb := GetMultiplayerSetting ( 3 ) ;
 152: LD_ADDR_EXP 4
 156: PUSH
 157: LD_INT 3
 159: PPUSH
 160: CALL_OW 426
 164: ST_TO_ADDR
// end ; p1 := 0 ;
 165: LD_ADDR_EXP 7
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// p2 := 0 ;
 173: LD_ADDR_EXP 8
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// p3 := 0 ;
 181: LD_ADDR_EXP 9
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// p4 := 0 ;
 189: LD_ADDR_EXP 10
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// p5 := 0 ;
 197: LD_ADDR_EXP 11
 201: PUSH
 202: LD_INT 0
 204: ST_TO_ADDR
// veh_amount := 12 ;
 205: LD_ADDR_EXP 6
 209: PUSH
 210: LD_INT 12
 212: ST_TO_ADDR
// for i = 1 to 7 do
 213: LD_ADDR_VAR 0 3
 217: PUSH
 218: DOUBLE
 219: LD_INT 1
 221: DEC
 222: ST_TO_ADDR
 223: LD_INT 7
 225: PUSH
 226: FOR_TO
 227: IFFALSE 243
// ChangeSideFog ( i , 8 ) ;
 229: LD_VAR 0 3
 233: PPUSH
 234: LD_INT 8
 236: PPUSH
 237: CALL_OW 343
 241: GO 226
 243: POP
 244: POP
// end ; end_of_file
 245: LD_VAR 0 1
 249: RET
// export function PrepareUnits ; var i , side ; begin
 250: LD_INT 0
 252: PPUSH
 253: PPUSH
 254: PPUSH
// side := players ;
 255: LD_ADDR_VAR 0 3
 259: PUSH
 260: LD_EXP 3
 264: ST_TO_ADDR
// uc_nation := 1 ;
 265: LD_ADDR_OWVAR 21
 269: PUSH
 270: LD_INT 1
 272: ST_TO_ADDR
// for i = 1 to mechanics do
 273: LD_ADDR_VAR 0 2
 277: PUSH
 278: DOUBLE
 279: LD_INT 1
 281: DEC
 282: ST_TO_ADDR
 283: LD_EXP 1
 287: PUSH
 288: FOR_TO
 289: IFFALSE 353
// for side = 1 to players do
 291: LD_ADDR_VAR 0 3
 295: PUSH
 296: DOUBLE
 297: LD_INT 1
 299: DEC
 300: ST_TO_ADDR
 301: LD_EXP 3
 305: PUSH
 306: FOR_TO
 307: IFFALSE 349
// begin uc_side := side ;
 309: LD_ADDR_OWVAR 20
 313: PUSH
 314: LD_VAR 0 3
 318: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 319: LD_INT 0
 321: PPUSH
 322: LD_INT 3
 324: PPUSH
 325: LD_INT 10
 327: PPUSH
 328: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 332: CALL_OW 44
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: LD_INT 0
 342: PPUSH
 343: CALL_OW 49
// end ;
 347: GO 306
 349: POP
 350: POP
 351: GO 288
 353: POP
 354: POP
// end ;
 355: LD_VAR 0 1
 359: RET
// function ToSpawn ( side ) ; begin
 360: LD_INT 0
 362: PPUSH
// uc_side := side ;
 363: LD_ADDR_OWVAR 20
 367: PUSH
 368: LD_VAR 0 1
 372: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 373: LD_INT 0
 375: PPUSH
 376: LD_INT 3
 378: PPUSH
 379: LD_INT 10
 381: PPUSH
 382: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 386: CALL_OW 44
 390: PPUSH
 391: LD_INT 6
 393: PPUSH
 394: LD_INT 0
 396: PPUSH
 397: CALL_OW 49
// end ;
 401: LD_VAR 0 2
 405: RET
// every 0 0$13 trigger time do var i , filter ;
 406: LD_EXP 5
 410: IFFALSE 520
 412: GO 414
 414: DISABLE
 415: LD_INT 0
 417: PPUSH
 418: PPUSH
// begin enable ;
 419: ENABLE
// for i = 1 to players do
 420: LD_ADDR_VAR 0 1
 424: PUSH
 425: DOUBLE
 426: LD_INT 1
 428: DEC
 429: ST_TO_ADDR
 430: LD_EXP 3
 434: PUSH
 435: FOR_TO
 436: IFFALSE 518
// begin filter := FilterAllUnits ( [ [ [ f_side , i ] , [ f_class , 3 ] , [ f_type , unit_human ] ] ] ) ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 22
 445: PUSH
 446: LD_VAR 0 1
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: PUSH
 455: LD_INT 25
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: PUSH
 465: LD_INT 21
 467: PUSH
 468: LD_INT 1
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: LIST
 479: PUSH
 480: EMPTY
 481: LIST
 482: PPUSH
 483: CALL_OW 69
 487: ST_TO_ADDR
// if filter < mechanics then
 488: LD_VAR 0 2
 492: PUSH
 493: LD_EXP 1
 497: LESS
 498: IFFALSE 516
// begin Wait ( 0 0$03 ) ;
 500: LD_INT 105
 502: PPUSH
 503: CALL_OW 67
// ToSpawn ( i ) ;
 507: LD_VAR 0 1
 511: PPUSH
 512: CALL 360 0 1
// end ; end ;
 516: GO 435
 518: POP
 519: POP
// end ;
 520: PPOPN 2
 522: END
// every 0 0$01 trigger time do var i , filter , filter2 , vehicles ;
 523: LD_EXP 5
 527: IFFALSE 894
 529: GO 531
 531: DISABLE
 532: LD_INT 0
 534: PPUSH
 535: PPUSH
 536: PPUSH
 537: PPUSH
// begin enable ;
 538: ENABLE
// filter2 := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_not , [ f_side , 0 ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 539: LD_ADDR_VAR 0 3
 543: PUSH
 544: LD_INT 21
 546: PUSH
 547: LD_INT 2
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 22
 559: PUSH
 560: LD_INT 0
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: PUSH
 567: EMPTY
 568: LIST
 569: LIST
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 22
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: EMPTY
 581: LIST
 582: LIST
 583: PUSH
 584: EMPTY
 585: LIST
 586: LIST
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL_OW 69
 597: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 598: LD_ADDR_VAR 0 2
 602: PUSH
 603: LD_INT 21
 605: PUSH
 606: LD_INT 1
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 54
 618: PUSH
 619: EMPTY
 620: LIST
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 22
 631: PUSH
 632: LD_INT 1
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: PUSH
 639: EMPTY
 640: LIST
 641: LIST
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: PPUSH
 648: CALL_OW 69
 652: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 653: LD_ADDR_VAR 0 4
 657: PUSH
 658: LD_INT 21
 660: PUSH
 661: LD_INT 2
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: PUSH
 668: LD_INT 58
 670: PUSH
 671: EMPTY
 672: LIST
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL_OW 69
 682: ST_TO_ADDR
// if filter and vehicles then
 683: LD_VAR 0 2
 687: PUSH
 688: LD_VAR 0 4
 692: AND
 693: IFFALSE 830
// for i = 1 to filter do
 695: LD_ADDR_VAR 0 1
 699: PUSH
 700: DOUBLE
 701: LD_INT 1
 703: DEC
 704: ST_TO_ADDR
 705: LD_VAR 0 2
 709: PUSH
 710: FOR_TO
 711: IFFALSE 828
// if not HasTask ( filter [ i ] ) and IsOk ( filter [ i ] ) then
 713: LD_VAR 0 2
 717: PUSH
 718: LD_VAR 0 1
 722: ARRAY
 723: PPUSH
 724: CALL_OW 314
 728: NOT
 729: PUSH
 730: LD_VAR 0 2
 734: PUSH
 735: LD_VAR 0 1
 739: ARRAY
 740: PPUSH
 741: CALL_OW 302
 745: AND
 746: IFFALSE 826
// if GetDistUnits ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) < 45 then
 748: LD_VAR 0 2
 752: PUSH
 753: LD_VAR 0 1
 757: ARRAY
 758: PPUSH
 759: LD_VAR 0 4
 763: PPUSH
 764: LD_VAR 0 2
 768: PUSH
 769: LD_VAR 0 1
 773: ARRAY
 774: PPUSH
 775: CALL_OW 74
 779: PPUSH
 780: CALL_OW 296
 784: PUSH
 785: LD_INT 45
 787: LESS
 788: IFFALSE 826
// ComEnterUnit ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) ;
 790: LD_VAR 0 2
 794: PUSH
 795: LD_VAR 0 1
 799: ARRAY
 800: PPUSH
 801: LD_VAR 0 4
 805: PPUSH
 806: LD_VAR 0 2
 810: PUSH
 811: LD_VAR 0 1
 815: ARRAY
 816: PPUSH
 817: CALL_OW 74
 821: PPUSH
 822: CALL_OW 120
 826: GO 710
 828: POP
 829: POP
// if filter2 then
 830: LD_VAR 0 3
 834: IFFALSE 894
// for i = 1 to filter2 do
 836: LD_ADDR_VAR 0 1
 840: PUSH
 841: DOUBLE
 842: LD_INT 1
 844: DEC
 845: ST_TO_ADDR
 846: LD_VAR 0 3
 850: PUSH
 851: FOR_TO
 852: IFFALSE 892
// if not HasTask ( filter2 [ i ] ) then
 854: LD_VAR 0 3
 858: PUSH
 859: LD_VAR 0 1
 863: ARRAY
 864: PPUSH
 865: CALL_OW 314
 869: NOT
 870: IFFALSE 890
// ComMoveToArea ( filter2 [ i ] , exit_area ) ;
 872: LD_VAR 0 3
 876: PUSH
 877: LD_VAR 0 1
 881: ARRAY
 882: PPUSH
 883: LD_INT 4
 885: PPUSH
 886: CALL_OW 113
 890: GO 851
 892: POP
 893: POP
// end ; end_of_file
 894: PPOPN 4
 896: END
// export function SpawnCar ( chas , area ) ; var i , e , veh , ar_chassis , ru_chassis , us_chassis , ar_weapons , ru_weapons , us_weapons , chassis , engine , weapon ; begin
 897: LD_INT 0
 899: PPUSH
 900: PPUSH
 901: PPUSH
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
 906: PPUSH
 907: PPUSH
 908: PPUSH
 909: PPUSH
 910: PPUSH
 911: PPUSH
// uc_side := 0 ;
 912: LD_ADDR_OWVAR 20
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// uc_nation := Rand ( 1 , 3 ) ;
 920: LD_ADDR_OWVAR 21
 924: PUSH
 925: LD_INT 1
 927: PPUSH
 928: LD_INT 3
 930: PPUSH
 931: CALL_OW 12
 935: ST_TO_ADDR
// ar_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
 936: LD_ADDR_VAR 0 7
 940: PUSH
 941: LD_INT 11
 943: PUSH
 944: LD_INT 12
 946: PUSH
 947: LD_INT 13
 949: PUSH
 950: LD_INT 14
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: ST_TO_ADDR
// ru_chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ;
 959: LD_ADDR_VAR 0 8
 963: PUSH
 964: LD_INT 21
 966: PUSH
 967: LD_INT 22
 969: PUSH
 970: LD_INT 23
 972: PUSH
 973: LD_INT 24
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: ST_TO_ADDR
// us_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ;
 982: LD_ADDR_VAR 0 9
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 2
 992: PUSH
 993: LD_INT 3
 995: PUSH
 996: LD_INT 4
 998: PUSH
 999: LD_INT 5
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: ST_TO_ADDR
// if chas > 0 then
1009: LD_VAR 0 1
1013: PUSH
1014: LD_INT 0
1016: GREATER
1017: IFFALSE 1031
// vc_chassis := chas else
1019: LD_ADDR_OWVAR 37
1023: PUSH
1024: LD_VAR 0 1
1028: ST_TO_ADDR
1029: GO 1124
// begin case uc_nation of 1 :
1031: LD_OWVAR 21
1035: PUSH
1036: LD_INT 1
1038: DOUBLE
1039: EQUAL
1040: IFTRUE 1044
1042: GO 1057
1044: POP
// chassis := us_chassis ; 2 :
1045: LD_ADDR_VAR 0 13
1049: PUSH
1050: LD_VAR 0 9
1054: ST_TO_ADDR
1055: GO 1100
1057: LD_INT 2
1059: DOUBLE
1060: EQUAL
1061: IFTRUE 1065
1063: GO 1078
1065: POP
// chassis := ar_chassis ; 3 :
1066: LD_ADDR_VAR 0 13
1070: PUSH
1071: LD_VAR 0 7
1075: ST_TO_ADDR
1076: GO 1100
1078: LD_INT 3
1080: DOUBLE
1081: EQUAL
1082: IFTRUE 1086
1084: GO 1099
1086: POP
// chassis := ru_chassis ; end ;
1087: LD_ADDR_VAR 0 13
1091: PUSH
1092: LD_VAR 0 8
1096: ST_TO_ADDR
1097: GO 1100
1099: POP
// vc_chassis := chassis [ Rand ( 1 , chassis ) ] ;
1100: LD_ADDR_OWVAR 37
1104: PUSH
1105: LD_VAR 0 13
1109: PUSH
1110: LD_INT 1
1112: PPUSH
1113: LD_VAR 0 13
1117: PPUSH
1118: CALL_OW 12
1122: ARRAY
1123: ST_TO_ADDR
// end ; if vc_chassis in [ ar_hovercraft , ar_light_trike , us_light_wheeled ] then
1124: LD_OWVAR 37
1128: PUSH
1129: LD_INT 11
1131: PUSH
1132: LD_INT 12
1134: PUSH
1135: LD_INT 1
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: IN
1143: IFFALSE 1163
// engine := Rand ( 1 , 2 ) else
1145: LD_ADDR_VAR 0 14
1149: PUSH
1150: LD_INT 1
1152: PPUSH
1153: LD_INT 2
1155: PPUSH
1156: CALL_OW 12
1160: ST_TO_ADDR
1161: GO 1275
// begin if not vc_chassis in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked , us_morphling ] then
1163: LD_OWVAR 37
1167: PUSH
1168: LD_INT 21
1170: PUSH
1171: LD_INT 22
1173: PUSH
1174: LD_INT 23
1176: PUSH
1177: LD_INT 24
1179: PUSH
1180: LD_INT 4
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: IN
1194: NOT
1195: IFFALSE 1215
// engine := Rand ( 1 , 3 ) else
1197: LD_ADDR_VAR 0 14
1201: PUSH
1202: LD_INT 1
1204: PPUSH
1205: LD_INT 3
1207: PPUSH
1208: CALL_OW 12
1212: ST_TO_ADDR
1213: GO 1231
// e := Rand ( 1 , 2 ) ;
1215: LD_ADDR_VAR 0 5
1219: PUSH
1220: LD_INT 1
1222: PPUSH
1223: LD_INT 2
1225: PPUSH
1226: CALL_OW 12
1230: ST_TO_ADDR
// case e of 1 :
1231: LD_VAR 0 5
1235: PUSH
1236: LD_INT 1
1238: DOUBLE
1239: EQUAL
1240: IFTRUE 1244
1242: GO 1255
1244: POP
// engine := engine_combustion ; 2 :
1245: LD_ADDR_VAR 0 14
1249: PUSH
1250: LD_INT 1
1252: ST_TO_ADDR
1253: GO 1275
1255: LD_INT 2
1257: DOUBLE
1258: EQUAL
1259: IFTRUE 1263
1261: GO 1274
1263: POP
// engine := engine_siberite ; end ;
1264: LD_ADDR_VAR 0 14
1268: PUSH
1269: LD_INT 3
1271: ST_TO_ADDR
1272: GO 1275
1274: POP
// end ; vc_engine := engine ;
1275: LD_ADDR_OWVAR 39
1279: PUSH
1280: LD_VAR 0 14
1284: ST_TO_ADDR
// vc_control := control_manual ;
1285: LD_ADDR_OWVAR 38
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// ar_weapons := [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ar_radar , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb , ar_flame_thrower ] ;
1293: LD_ADDR_VAR 0 10
1297: PUSH
1298: LD_INT 22
1300: PUSH
1301: LD_INT 24
1303: PUSH
1304: LD_INT 23
1306: PUSH
1307: LD_INT 30
1309: PUSH
1310: LD_INT 25
1312: PUSH
1313: LD_INT 27
1315: PUSH
1316: LD_INT 28
1318: PUSH
1319: LD_INT 29
1321: PUSH
1322: LD_INT 26
1324: PUSH
1325: EMPTY
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: LIST
1334: LIST
1335: ST_TO_ADDR
// ru_weapons := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , 98 , ru_rocket_launcher , ru_heavy_gun , ru_rocket , ru_bulldozer , ru_time_lapser ] ;
1336: LD_ADDR_VAR 0 11
1340: PUSH
1341: LD_INT 42
1343: PUSH
1344: LD_INT 43
1346: PUSH
1347: LD_INT 44
1349: PUSH
1350: LD_INT 98
1352: PUSH
1353: LD_INT 45
1355: PUSH
1356: LD_INT 46
1358: PUSH
1359: LD_INT 47
1361: PUSH
1362: LD_INT 53
1364: PUSH
1365: LD_INT 49
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: ST_TO_ADDR
// us_weapons := [ us_machine_gun , us_light_gun , us_radar , us_gatling_gun , us_double_gun , us_rocket_launcher , us_laser , us_heavy_gun , us_bulldozer , us_double_laser ] ;
1379: LD_ADDR_VAR 0 12
1383: PUSH
1384: LD_INT 2
1386: PUSH
1387: LD_INT 3
1389: PUSH
1390: LD_INT 11
1392: PUSH
1393: LD_INT 4
1395: PUSH
1396: LD_INT 5
1398: PUSH
1399: LD_INT 7
1401: PUSH
1402: LD_INT 9
1404: PUSH
1405: LD_INT 6
1407: PUSH
1408: LD_INT 14
1410: PUSH
1411: LD_INT 10
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// if uc_nation = nation_arabian then
1426: LD_OWVAR 21
1430: PUSH
1431: LD_INT 2
1433: EQUAL
1434: IFFALSE 1501
// begin if vc_chassis in [ ar_hovercraft , ar_light_trike ] then
1436: LD_OWVAR 37
1440: PUSH
1441: LD_INT 11
1443: PUSH
1444: LD_INT 12
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: IN
1451: IFFALSE 1477
// weapon := ar_weapons [ Rand ( 1 , 3 ) ] else
1453: LD_ADDR_VAR 0 15
1457: PUSH
1458: LD_VAR 0 10
1462: PUSH
1463: LD_INT 1
1465: PPUSH
1466: LD_INT 3
1468: PPUSH
1469: CALL_OW 12
1473: ARRAY
1474: ST_TO_ADDR
1475: GO 1501
// weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
1477: LD_ADDR_VAR 0 15
1481: PUSH
1482: LD_VAR 0 10
1486: PUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_VAR 0 10
1494: PPUSH
1495: CALL_OW 12
1499: ARRAY
1500: ST_TO_ADDR
// end ; if uc_nation = nation_russian then
1501: LD_OWVAR 21
1505: PUSH
1506: LD_INT 3
1508: EQUAL
1509: IFFALSE 1576
// begin if vc_chassis in [ ru_medium_wheeled , ru_medium_tracked ] then
1511: LD_OWVAR 37
1515: PUSH
1516: LD_INT 21
1518: PUSH
1519: LD_INT 22
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: IN
1526: IFFALSE 1552
// weapon := ru_weapons [ Rand ( 1 , 5 ) ] else
1528: LD_ADDR_VAR 0 15
1532: PUSH
1533: LD_VAR 0 11
1537: PUSH
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 5
1543: PPUSH
1544: CALL_OW 12
1548: ARRAY
1549: ST_TO_ADDR
1550: GO 1576
// weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
1552: LD_ADDR_VAR 0 15
1556: PUSH
1557: LD_VAR 0 11
1561: PUSH
1562: LD_INT 1
1564: PPUSH
1565: LD_VAR 0 11
1569: PPUSH
1570: CALL_OW 12
1574: ARRAY
1575: ST_TO_ADDR
// end ; if uc_nation = nation_american then
1576: LD_OWVAR 21
1580: PUSH
1581: LD_INT 1
1583: EQUAL
1584: IFFALSE 1693
// begin if vc_chassis = us_light_wheeled then
1586: LD_OWVAR 37
1590: PUSH
1591: LD_INT 1
1593: EQUAL
1594: IFFALSE 1618
// weapon := us_weapons [ Rand ( 1 , 3 ) ] ;
1596: LD_ADDR_VAR 0 15
1600: PUSH
1601: LD_VAR 0 12
1605: PUSH
1606: LD_INT 1
1608: PPUSH
1609: LD_INT 3
1611: PPUSH
1612: CALL_OW 12
1616: ARRAY
1617: ST_TO_ADDR
// if vc_chassis in [ us_medium_tracked , us_medium_wheeled ] then
1618: LD_OWVAR 37
1622: PUSH
1623: LD_INT 3
1625: PUSH
1626: LD_INT 2
1628: PUSH
1629: EMPTY
1630: LIST
1631: LIST
1632: IN
1633: IFFALSE 1659
// weapon := us_weapons [ Rand ( 1 , 7 ) ] else
1635: LD_ADDR_VAR 0 15
1639: PUSH
1640: LD_VAR 0 12
1644: PUSH
1645: LD_INT 1
1647: PPUSH
1648: LD_INT 7
1650: PPUSH
1651: CALL_OW 12
1655: ARRAY
1656: ST_TO_ADDR
1657: GO 1693
// if vc_chassis <> us_light_wheeled then
1659: LD_OWVAR 37
1663: PUSH
1664: LD_INT 1
1666: NONEQUAL
1667: IFFALSE 1693
// weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
1669: LD_ADDR_VAR 0 15
1673: PUSH
1674: LD_VAR 0 12
1678: PUSH
1679: LD_INT 1
1681: PPUSH
1682: LD_VAR 0 12
1686: PPUSH
1687: CALL_OW 12
1691: ARRAY
1692: ST_TO_ADDR
// end ; vc_weapon := weapon ;
1693: LD_ADDR_OWVAR 40
1697: PUSH
1698: LD_VAR 0 15
1702: ST_TO_ADDR
// veh := CreateVehicle ;
1703: LD_ADDR_VAR 0 6
1707: PUSH
1708: CALL_OW 45
1712: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1713: LD_VAR 0 6
1717: PPUSH
1718: LD_VAR 0 2
1722: PPUSH
1723: LD_INT 1
1725: PPUSH
1726: CALL_OW 49
// end ;
1730: LD_VAR 0 3
1734: RET
// export function SpawnSibRocket ( area ) ; var veh , p ; begin
1735: LD_INT 0
1737: PPUSH
1738: PPUSH
1739: PPUSH
// uc_side := 0 ;
1740: LD_ADDR_OWVAR 20
1744: PUSH
1745: LD_INT 0
1747: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
1748: LD_ADDR_VAR 0 4
1752: PUSH
1753: LD_INT 1
1755: PPUSH
1756: LD_INT 2
1758: PPUSH
1759: CALL_OW 12
1763: ST_TO_ADDR
// case p of 1 :
1764: LD_VAR 0 4
1768: PUSH
1769: LD_INT 1
1771: DOUBLE
1772: EQUAL
1773: IFTRUE 1777
1775: GO 1820
1777: POP
// begin uc_nation := nation_american ;
1778: LD_ADDR_OWVAR 21
1782: PUSH
1783: LD_INT 1
1785: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
1786: LD_ADDR_OWVAR 37
1790: PUSH
1791: LD_INT 4
1793: ST_TO_ADDR
// vc_engine := engine_siberite ;
1794: LD_ADDR_OWVAR 39
1798: PUSH
1799: LD_INT 3
1801: ST_TO_ADDR
// vc_control := control_manual ;
1802: LD_ADDR_OWVAR 38
1806: PUSH
1807: LD_INT 1
1809: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
1810: LD_ADDR_OWVAR 40
1814: PUSH
1815: LD_INT 8
1817: ST_TO_ADDR
// end ; 2 :
1818: GO 1872
1820: LD_INT 2
1822: DOUBLE
1823: EQUAL
1824: IFTRUE 1828
1826: GO 1871
1828: POP
// begin uc_nation := nation_russian ;
1829: LD_ADDR_OWVAR 21
1833: PUSH
1834: LD_INT 3
1836: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
1837: LD_ADDR_OWVAR 37
1841: PUSH
1842: LD_INT 24
1844: ST_TO_ADDR
// vc_engine := engine_siberite ;
1845: LD_ADDR_OWVAR 39
1849: PUSH
1850: LD_INT 3
1852: ST_TO_ADDR
// vc_control := control_manual ;
1853: LD_ADDR_OWVAR 38
1857: PUSH
1858: LD_INT 1
1860: ST_TO_ADDR
// vc_weapon := ru_siberium_rocket ;
1861: LD_ADDR_OWVAR 40
1865: PUSH
1866: LD_INT 48
1868: ST_TO_ADDR
// end ; end ;
1869: GO 1872
1871: POP
// veh := CreateVehicle ;
1872: LD_ADDR_VAR 0 3
1876: PUSH
1877: CALL_OW 45
1881: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1882: LD_VAR 0 3
1886: PPUSH
1887: LD_VAR 0 1
1891: PPUSH
1892: LD_INT 1
1894: PPUSH
1895: CALL_OW 49
// end ;
1899: LD_VAR 0 2
1903: RET
// export function ScoreBoard ( veh ) ; var points ; begin
1904: LD_INT 0
1906: PPUSH
1907: PPUSH
// points := 0 ;
1908: LD_ADDR_VAR 0 3
1912: PUSH
1913: LD_INT 0
1915: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_light_trike , us_light_wheeled ] then
1916: LD_VAR 0 1
1920: PPUSH
1921: CALL_OW 265
1925: PUSH
1926: LD_INT 12
1928: PUSH
1929: LD_INT 1
1931: PUSH
1932: EMPTY
1933: LIST
1934: LIST
1935: IN
1936: IFFALSE 1952
// points := points + 10 ;
1938: LD_ADDR_VAR 0 3
1942: PUSH
1943: LD_VAR 0 3
1947: PUSH
1948: LD_INT 10
1950: PLUS
1951: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_medium_trike , ru_medium_wheeled , us_medium_wheeled ] then
1952: LD_VAR 0 1
1956: PPUSH
1957: CALL_OW 265
1961: PUSH
1962: LD_INT 13
1964: PUSH
1965: LD_INT 21
1967: PUSH
1968: LD_INT 2
1970: PUSH
1971: EMPTY
1972: LIST
1973: LIST
1974: LIST
1975: IN
1976: IFFALSE 1992
// points := points + 15 ;
1978: LD_ADDR_VAR 0 3
1982: PUSH
1983: LD_VAR 0 3
1987: PUSH
1988: LD_INT 15
1990: PLUS
1991: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_half_tracked , ru_medium_tracked , us_medium_tracked ] then
1992: LD_VAR 0 1
1996: PPUSH
1997: CALL_OW 265
2001: PUSH
2002: LD_INT 14
2004: PUSH
2005: LD_INT 22
2007: PUSH
2008: LD_INT 3
2010: PUSH
2011: EMPTY
2012: LIST
2013: LIST
2014: LIST
2015: IN
2016: IFFALSE 2032
// points := points + 20 ;
2018: LD_ADDR_VAR 0 3
2022: PUSH
2023: LD_VAR 0 3
2027: PUSH
2028: LD_INT 20
2030: PLUS
2031: ST_TO_ADDR
// if GetChassis ( veh ) in [ ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked ] then
2032: LD_VAR 0 1
2036: PPUSH
2037: CALL_OW 265
2041: PUSH
2042: LD_INT 23
2044: PUSH
2045: LD_INT 24
2047: PUSH
2048: LD_INT 4
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: LIST
2055: IN
2056: IFFALSE 2072
// points := points + 25 ;
2058: LD_ADDR_VAR 0 3
2062: PUSH
2063: LD_VAR 0 3
2067: PUSH
2068: LD_INT 25
2070: PLUS
2071: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_hovercraft , us_morphling ] then
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 265
2081: PUSH
2082: LD_INT 11
2084: PUSH
2085: LD_INT 5
2087: PUSH
2088: EMPTY
2089: LIST
2090: LIST
2091: IN
2092: IFFALSE 2108
// points := points + 30 ;
2094: LD_ADDR_VAR 0 3
2098: PUSH
2099: LD_VAR 0 3
2103: PUSH
2104: LD_INT 30
2106: PLUS
2107: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_combustion ] then
2108: LD_VAR 0 1
2112: PPUSH
2113: CALL_OW 262
2117: PUSH
2118: LD_INT 1
2120: PUSH
2121: EMPTY
2122: LIST
2123: EQUAL
2124: IFFALSE 2140
// points := points + 5 ;
2126: LD_ADDR_VAR 0 3
2130: PUSH
2131: LD_VAR 0 3
2135: PUSH
2136: LD_INT 5
2138: PLUS
2139: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_solar ] then
2140: LD_VAR 0 1
2144: PPUSH
2145: CALL_OW 262
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: EMPTY
2154: LIST
2155: EQUAL
2156: IFFALSE 2172
// points := points + 15 ;
2158: LD_ADDR_VAR 0 3
2162: PUSH
2163: LD_VAR 0 3
2167: PUSH
2168: LD_INT 15
2170: PLUS
2171: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_siberite ] then
2172: LD_VAR 0 1
2176: PPUSH
2177: CALL_OW 262
2181: PUSH
2182: LD_INT 3
2184: PUSH
2185: EMPTY
2186: LIST
2187: EQUAL
2188: IFFALSE 2204
// points := points + 25 ;
2190: LD_ADDR_VAR 0 3
2194: PUSH
2195: LD_VAR 0 3
2199: PUSH
2200: LD_INT 25
2202: PLUS
2203: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ru_heavy_machine_gun , us_machine_gun , us_light_gun ] then
2204: LD_VAR 0 1
2208: PPUSH
2209: CALL_OW 264
2213: PUSH
2214: LD_INT 22
2216: PUSH
2217: LD_INT 24
2219: PUSH
2220: LD_INT 23
2222: PUSH
2223: LD_INT 42
2225: PUSH
2226: LD_INT 2
2228: PUSH
2229: LD_INT 3
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: LIST
2236: LIST
2237: LIST
2238: LIST
2239: IN
2240: IFFALSE 2256
// points := points + 5 ;
2242: LD_ADDR_VAR 0 3
2246: PUSH
2247: LD_VAR 0 3
2251: PUSH
2252: LD_INT 5
2254: PLUS
2255: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_gatling_gun , ar_gun , ru_gatling_gun , ru_gun , us_gatling_gun , us_double_gun ] then
2256: LD_VAR 0 1
2260: PPUSH
2261: CALL_OW 264
2265: PUSH
2266: LD_INT 25
2268: PUSH
2269: LD_INT 27
2271: PUSH
2272: LD_INT 43
2274: PUSH
2275: LD_INT 44
2277: PUSH
2278: LD_INT 4
2280: PUSH
2281: LD_INT 5
2283: PUSH
2284: EMPTY
2285: LIST
2286: LIST
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: IN
2292: IFFALSE 2308
// points := points + 10 ;
2294: LD_ADDR_VAR 0 3
2298: PUSH
2299: LD_VAR 0 3
2303: PUSH
2304: LD_INT 10
2306: PLUS
2307: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher ] then
2308: LD_VAR 0 1
2312: PPUSH
2313: CALL_OW 264
2317: PUSH
2318: LD_INT 28
2320: PUSH
2321: LD_INT 45
2323: PUSH
2324: LD_INT 7
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: LIST
2331: IN
2332: IFFALSE 2348
// points := points + 20 ;
2334: LD_ADDR_VAR 0 3
2338: PUSH
2339: LD_VAR 0 3
2343: PUSH
2344: LD_INT 20
2346: PLUS
2347: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_heavy_gun , us_heavy_gun ] then
2348: LD_VAR 0 1
2352: PPUSH
2353: CALL_OW 264
2357: PUSH
2358: LD_INT 46
2360: PUSH
2361: LD_INT 6
2363: PUSH
2364: EMPTY
2365: LIST
2366: LIST
2367: IN
2368: IFFALSE 2384
// points := points + 25 ;
2370: LD_ADDR_VAR 0 3
2374: PUSH
2375: LD_VAR 0 3
2379: PUSH
2380: LD_INT 25
2382: PLUS
2383: ST_TO_ADDR
// if GetWeapon ( veh ) in [ us_laser , us_radar , ar_radar ] then
2384: LD_VAR 0 1
2388: PPUSH
2389: CALL_OW 264
2393: PUSH
2394: LD_INT 9
2396: PUSH
2397: LD_INT 11
2399: PUSH
2400: LD_INT 30
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: LIST
2407: IN
2408: IFFALSE 2424
// points := points + 30 ;
2410: LD_ADDR_VAR 0 3
2414: PUSH
2415: LD_VAR 0 3
2419: PUSH
2420: LD_INT 30
2422: PLUS
2423: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_selfpropelled_bomb , ru_time_lapser , ru_rocket , us_double_laser ] then
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 264
2433: PUSH
2434: LD_INT 29
2436: PUSH
2437: LD_INT 49
2439: PUSH
2440: LD_INT 47
2442: PUSH
2443: LD_INT 10
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: IN
2452: IFFALSE 2468
// points := points + 50 ;
2454: LD_ADDR_VAR 0 3
2458: PUSH
2459: LD_VAR 0 3
2463: PUSH
2464: LD_INT 50
2466: PLUS
2467: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_siberium_rocket , us_siberium_rocket ] then
2468: LD_VAR 0 1
2472: PPUSH
2473: CALL_OW 264
2477: PUSH
2478: LD_INT 48
2480: PUSH
2481: LD_INT 8
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: IN
2488: IFFALSE 2504
// points := points + 100 ;
2490: LD_ADDR_VAR 0 3
2494: PUSH
2495: LD_VAR 0 3
2499: PUSH
2500: LD_INT 100
2502: PLUS
2503: ST_TO_ADDR
// result := points ;
2504: LD_ADDR_VAR 0 2
2508: PUSH
2509: LD_VAR 0 3
2513: ST_TO_ADDR
// end ; end_of_file
2514: LD_VAR 0 2
2518: RET
// every 0 0$01 trigger time do var filter , i , side , driver , un ;
2519: LD_EXP 5
2523: IFFALSE 3168
2525: GO 2527
2527: DISABLE
2528: LD_INT 0
2530: PPUSH
2531: PPUSH
2532: PPUSH
2533: PPUSH
2534: PPUSH
// begin enable ;
2535: ENABLE
// if tick < 36 then
2536: LD_OWVAR 1
2540: PUSH
2541: LD_INT 36
2543: LESS
2544: IFFALSE 2556
// SetAreaMapShow ( exit_area , 1 ) ;
2546: LD_INT 4
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 424
// time := time - 0 0$01 ;
2556: LD_ADDR_EXP 5
2560: PUSH
2561: LD_EXP 5
2565: PUSH
2566: LD_INT 35
2568: MINUS
2569: ST_TO_ADDR
// if time = 0 0$00 then
2570: LD_EXP 5
2574: PUSH
2575: LD_INT 0
2577: EQUAL
2578: IFFALSE 2641
// if p1 > p2 and p1 > p3 and p1 > p4 and p1 > p5 then
2580: LD_EXP 7
2584: PUSH
2585: LD_EXP 8
2589: GREATER
2590: PUSH
2591: LD_EXP 7
2595: PUSH
2596: LD_EXP 9
2600: GREATER
2601: AND
2602: PUSH
2603: LD_EXP 7
2607: PUSH
2608: LD_EXP 10
2612: GREATER
2613: AND
2614: PUSH
2615: LD_EXP 7
2619: PUSH
2620: LD_EXP 11
2624: GREATER
2625: AND
2626: IFFALSE 2634
// YouWin else
2628: CALL_OW 103
2632: GO 2641
// YouLost (  ) ;
2634: LD_STRING 
2636: PPUSH
2637: CALL_OW 104
// filter := FilterUnitsInArea ( exit_area , [ f_type , unit_vehicle ] ) ;
2641: LD_ADDR_VAR 0 1
2645: PUSH
2646: LD_INT 4
2648: PPUSH
2649: LD_INT 21
2651: PUSH
2652: LD_INT 2
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PPUSH
2659: CALL_OW 70
2663: ST_TO_ADDR
// if filter then
2664: LD_VAR 0 1
2668: IFFALSE 2958
// for i = 1 to filter do
2670: LD_ADDR_VAR 0 2
2674: PUSH
2675: DOUBLE
2676: LD_INT 1
2678: DEC
2679: ST_TO_ADDR
2680: LD_VAR 0 1
2684: PUSH
2685: FOR_TO
2686: IFFALSE 2956
// begin side := GetSide ( filter [ i ] ) ;
2688: LD_ADDR_VAR 0 3
2692: PUSH
2693: LD_VAR 0 1
2697: PUSH
2698: LD_VAR 0 2
2702: ARRAY
2703: PPUSH
2704: CALL_OW 255
2708: ST_TO_ADDR
// driver := IsDrivenBy ( filter [ i ] ) ;
2709: LD_ADDR_VAR 0 4
2713: PUSH
2714: LD_VAR 0 1
2718: PUSH
2719: LD_VAR 0 2
2723: ARRAY
2724: PPUSH
2725: CALL_OW 311
2729: ST_TO_ADDR
// un := filter [ i ] ;
2730: LD_ADDR_VAR 0 5
2734: PUSH
2735: LD_VAR 0 1
2739: PUSH
2740: LD_VAR 0 2
2744: ARRAY
2745: ST_TO_ADDR
// if IsInUnit ( driver ) then
2746: LD_VAR 0 4
2750: PPUSH
2751: CALL_OW 310
2755: IFFALSE 2766
// ComExitVehicle ( driver ) ;
2757: LD_VAR 0 4
2761: PPUSH
2762: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
2766: LD_INT 10
2768: PPUSH
2769: CALL_OW 67
// RemoveUnit ( filter [ i ] ) ;
2773: LD_VAR 0 1
2777: PUSH
2778: LD_VAR 0 2
2782: ARRAY
2783: PPUSH
2784: CALL_OW 64
// case side of 1 :
2788: LD_VAR 0 3
2792: PUSH
2793: LD_INT 1
2795: DOUBLE
2796: EQUAL
2797: IFTRUE 2801
2799: GO 2825
2801: POP
// p1 := p1 + ScoreBoard ( un ) ; 2 :
2802: LD_ADDR_EXP 7
2806: PUSH
2807: LD_EXP 7
2811: PUSH
2812: LD_VAR 0 5
2816: PPUSH
2817: CALL 1904 0 1
2821: PLUS
2822: ST_TO_ADDR
2823: GO 2954
2825: LD_INT 2
2827: DOUBLE
2828: EQUAL
2829: IFTRUE 2833
2831: GO 2857
2833: POP
// p2 := p2 + ScoreBoard ( un ) ; 3 :
2834: LD_ADDR_EXP 8
2838: PUSH
2839: LD_EXP 8
2843: PUSH
2844: LD_VAR 0 5
2848: PPUSH
2849: CALL 1904 0 1
2853: PLUS
2854: ST_TO_ADDR
2855: GO 2954
2857: LD_INT 3
2859: DOUBLE
2860: EQUAL
2861: IFTRUE 2865
2863: GO 2889
2865: POP
// p3 := p3 + ScoreBoard ( un ) ; 4 :
2866: LD_ADDR_EXP 9
2870: PUSH
2871: LD_EXP 9
2875: PUSH
2876: LD_VAR 0 5
2880: PPUSH
2881: CALL 1904 0 1
2885: PLUS
2886: ST_TO_ADDR
2887: GO 2954
2889: LD_INT 4
2891: DOUBLE
2892: EQUAL
2893: IFTRUE 2897
2895: GO 2921
2897: POP
// p4 := p4 + ScoreBoard ( un ) ; 5 :
2898: LD_ADDR_EXP 10
2902: PUSH
2903: LD_EXP 10
2907: PUSH
2908: LD_VAR 0 5
2912: PPUSH
2913: CALL 1904 0 1
2917: PLUS
2918: ST_TO_ADDR
2919: GO 2954
2921: LD_INT 5
2923: DOUBLE
2924: EQUAL
2925: IFTRUE 2929
2927: GO 2953
2929: POP
// p5 := p5 + ScoreBoard ( un ) ; end ;
2930: LD_ADDR_EXP 11
2934: PUSH
2935: LD_EXP 11
2939: PUSH
2940: LD_VAR 0 5
2944: PPUSH
2945: CALL 1904 0 1
2949: PLUS
2950: ST_TO_ADDR
2951: GO 2954
2953: POP
// end ;
2954: GO 2685
2956: POP
2957: POP
// case players of 3 :
2958: LD_EXP 3
2962: PUSH
2963: LD_INT 3
2965: DOUBLE
2966: EQUAL
2967: IFTRUE 2971
2969: GO 3021
2971: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 ] ;
2972: LD_ADDR_OWVAR 47
2976: PUSH
2977: LD_STRING #tick
2979: PUSH
2980: LD_EXP 5
2984: PUSH
2985: LD_STRING #player1
2987: PUSH
2988: LD_EXP 7
2992: PUSH
2993: LD_STRING #player2
2995: PUSH
2996: LD_EXP 8
3000: PUSH
3001: LD_STRING #player3
3003: PUSH
3004: LD_EXP 9
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: ST_TO_ADDR
// end ; 4 :
3019: GO 3168
3021: LD_INT 4
3023: DOUBLE
3024: EQUAL
3025: IFTRUE 3029
3027: GO 3089
3029: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 ] ;
3030: LD_ADDR_OWVAR 47
3034: PUSH
3035: LD_STRING #tick
3037: PUSH
3038: LD_EXP 5
3042: PUSH
3043: LD_STRING #player1
3045: PUSH
3046: LD_EXP 7
3050: PUSH
3051: LD_STRING #player2
3053: PUSH
3054: LD_EXP 8
3058: PUSH
3059: LD_STRING #player3
3061: PUSH
3062: LD_EXP 9
3066: PUSH
3067: LD_STRING #player4
3069: PUSH
3070: LD_EXP 10
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: ST_TO_ADDR
// end ; 5 :
3087: GO 3168
3089: LD_INT 5
3091: DOUBLE
3092: EQUAL
3093: IFTRUE 3097
3095: GO 3167
3097: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 , #player5 , p5 ] ;
3098: LD_ADDR_OWVAR 47
3102: PUSH
3103: LD_STRING #tick
3105: PUSH
3106: LD_EXP 5
3110: PUSH
3111: LD_STRING #player1
3113: PUSH
3114: LD_EXP 7
3118: PUSH
3119: LD_STRING #player2
3121: PUSH
3122: LD_EXP 8
3126: PUSH
3127: LD_STRING #player3
3129: PUSH
3130: LD_EXP 9
3134: PUSH
3135: LD_STRING #player4
3137: PUSH
3138: LD_EXP 10
3142: PUSH
3143: LD_STRING #player5
3145: PUSH
3146: LD_EXP 11
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: LIST
3163: LIST
3164: ST_TO_ADDR
// end ; end ;
3165: GO 3168
3167: POP
// end ;
3168: PPOPN 5
3170: END
// every 0 0$05 trigger time do var chance , p ;
3171: LD_EXP 5
3175: IFFALSE 3322
3177: GO 3179
3179: DISABLE
3180: LD_INT 0
3182: PPUSH
3183: PPUSH
// begin enable ;
3184: ENABLE
// Wait ( Rand ( 0 0$01 , 0 0$06 ) ) ;
3185: LD_INT 35
3187: PPUSH
3188: LD_INT 210
3190: PPUSH
3191: CALL_OW 12
3195: PPUSH
3196: CALL_OW 67
// if FilterAllUnits ( [ f_type , unit_vehicle ] ) < veh_amount then
3200: LD_INT 21
3202: PUSH
3203: LD_INT 2
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PPUSH
3210: CALL_OW 69
3214: PUSH
3215: LD_EXP 6
3219: LESS
3220: IFFALSE 3322
// begin SpawnCar ( false , veh_spawn ) ;
3222: LD_INT 0
3224: PPUSH
3225: LD_INT 5
3227: PPUSH
3228: CALL 897 0 2
// if sib_bomb and FilterAllUnits ( [ f_or , [ [ f_weapon , us_siberium_rocket ] , [ f_weapon , ru_siberium_rocket ] ] ] ) = 0 then
3232: LD_EXP 4
3236: PUSH
3237: LD_INT 2
3239: PUSH
3240: LD_INT 34
3242: PUSH
3243: LD_INT 8
3245: PUSH
3246: EMPTY
3247: LIST
3248: LIST
3249: PUSH
3250: LD_INT 34
3252: PUSH
3253: LD_INT 48
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 69
3272: PUSH
3273: LD_INT 0
3275: EQUAL
3276: AND
3277: IFFALSE 3322
// begin chance := 23 ;
3279: LD_ADDR_VAR 0 1
3283: PUSH
3284: LD_INT 23
3286: ST_TO_ADDR
// p := Rand ( 0 , 100 ) ;
3287: LD_ADDR_VAR 0 2
3291: PUSH
3292: LD_INT 0
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL_OW 12
3302: ST_TO_ADDR
// if p < chance then
3303: LD_VAR 0 2
3307: PUSH
3308: LD_VAR 0 1
3312: LESS
3313: IFFALSE 3322
// SpawnSibRocket ( veh_spawn ) ;
3315: LD_INT 5
3317: PPUSH
3318: CALL 1735 0 1
// end ; end ; end ;
3322: PPOPN 2
3324: END
