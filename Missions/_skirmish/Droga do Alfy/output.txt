// starting begin game_difficulty := 1 ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// PrepareNature ( nature , 3 , 2 , 1 , 2 ) ;
  12: LD_INT 12
  14: PPUSH
  15: LD_INT 3
  17: PPUSH
  18: LD_INT 2
  20: PPUSH
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 2
  26: PPUSH
  27: CALL 2498 0 5
// PrepareRussian ;
  31: CALL 40 0 0
// PrepareAmerican ;
  35: CALL 2981 0 0
// end ;
  39: END
// export game_difficulty ; end_of_file export ru_force , ru_skill ; export ru_patrol , ru_vehs ; export ru_cont_base , ru_blist ; export function PrepareRussian ; var i , un , veh ; begin
  40: LD_INT 0
  42: PPUSH
  43: PPUSH
  44: PPUSH
  45: PPUSH
// uc_side := 3 ;
  46: LD_ADDR_OWVAR 20
  50: PUSH
  51: LD_INT 3
  53: ST_TO_ADDR
// uc_nation := 3 ;
  54: LD_ADDR_OWVAR 21
  58: PUSH
  59: LD_INT 3
  61: ST_TO_ADDR
// ru_skill := [ 1 , 2 , 3 ] [ game_difficulty ] ;
  62: LD_ADDR_EXP 3
  66: PUSH
  67: LD_INT 1
  69: PUSH
  70: LD_INT 2
  72: PUSH
  73: LD_INT 3
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: LIST
  80: PUSH
  81: LD_EXP 1
  85: ARRAY
  86: ST_TO_ADDR
// ru_patrol := [ ] ;
  87: LD_ADDR_EXP 4
  91: PUSH
  92: EMPTY
  93: ST_TO_ADDR
// ru_force := [ ] ;
  94: LD_ADDR_EXP 2
  98: PUSH
  99: EMPTY
 100: ST_TO_ADDR
// ru_vehs := [ ] ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: EMPTY
 107: ST_TO_ADDR
// ru_blist := [ ] ;
 108: LD_ADDR_EXP 7
 112: PUSH
 113: EMPTY
 114: ST_TO_ADDR
// ru_cont_base := true ;
 115: LD_ADDR_EXP 6
 119: PUSH
 120: LD_INT 1
 122: ST_TO_ADDR
// for i = 1 to 7 do
 123: LD_ADDR_VAR 0 2
 127: PUSH
 128: DOUBLE
 129: LD_INT 1
 131: DEC
 132: ST_TO_ADDR
 133: LD_INT 7
 135: PUSH
 136: FOR_TO
 137: IFFALSE 226
// begin un := CreateHumanWithClass ( 1 , ru_skill ) ;
 139: LD_ADDR_VAR 0 3
 143: PUSH
 144: LD_INT 1
 146: PPUSH
 147: LD_EXP 3
 151: PPUSH
 152: CALL 1951 0 2
 156: ST_TO_ADDR
// PlaceUnitArea ( un , ru_bun , false ) ;
 157: LD_VAR 0 3
 161: PPUSH
 162: LD_INT 1
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) , un ) ) ;
 172: LD_VAR 0 3
 176: PPUSH
 177: LD_INT 2
 179: PUSH
 180: LD_INT 30
 182: PUSH
 183: LD_INT 32
 185: PUSH
 186: EMPTY
 187: LIST
 188: LIST
 189: PUSH
 190: LD_INT 30
 192: PUSH
 193: LD_INT 31
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: LIST
 204: PPUSH
 205: CALL_OW 69
 209: PPUSH
 210: LD_VAR 0 3
 214: PPUSH
 215: CALL_OW 74
 219: PPUSH
 220: CALL_OW 120
// end ;
 224: GO 136
 226: POP
 227: POP
// for i = 1 to 2 do
 228: LD_ADDR_VAR 0 2
 232: PUSH
 233: DOUBLE
 234: LD_INT 1
 236: DEC
 237: ST_TO_ADDR
 238: LD_INT 2
 240: PUSH
 241: FOR_TO
 242: IFFALSE 266
// PlaceHumanInUnit ( CreateHumanWithClass ( 1 , ru_skill ) , ru_arm ) ;
 244: LD_INT 1
 246: PPUSH
 247: LD_EXP 3
 251: PPUSH
 252: CALL 1951 0 2
 256: PPUSH
 257: LD_INT 7
 259: PPUSH
 260: CALL_OW 52
 264: GO 241
 266: POP
 267: POP
// for i = 1 to 4 do
 268: LD_ADDR_VAR 0 2
 272: PUSH
 273: DOUBLE
 274: LD_INT 1
 276: DEC
 277: ST_TO_ADDR
 278: LD_INT 4
 280: PUSH
 281: FOR_TO
 282: IFFALSE 356
// begin PlaceHumanInUnit ( CreateHumanWithClass ( 2 , ru_skill ) , ru_dep ) ;
 284: LD_INT 2
 286: PPUSH
 287: LD_EXP 3
 291: PPUSH
 292: CALL 1951 0 2
 296: PPUSH
 297: LD_INT 2
 299: PPUSH
 300: CALL_OW 52
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_skill ) , ru_fac ) ;
 304: LD_INT 3
 306: PPUSH
 307: LD_EXP 3
 311: PPUSH
 312: CALL 1951 0 2
 316: PPUSH
 317: LD_INT 10
 319: PPUSH
 320: CALL_OW 52
// if i > 2 then
 324: LD_VAR 0 2
 328: PUSH
 329: LD_INT 2
 331: GREATER
 332: IFFALSE 354
// PlaceHumanInUnit ( CreateHumanWithClass ( 4 , ru_skill ) , ru_lab ) ;
 334: LD_INT 4
 336: PPUSH
 337: LD_EXP 3
 341: PPUSH
 342: CALL 1951 0 2
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL_OW 52
// end ;
 354: GO 281
 356: POP
 357: POP
// vc_chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_medium_tracked ] [ game_difficulty ] ;
 358: LD_ADDR_OWVAR 37
 362: PUSH
 363: LD_INT 21
 365: PUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 22
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: LIST
 376: PUSH
 377: LD_EXP 1
 381: ARRAY
 382: ST_TO_ADDR
// vc_engine := engine_combustion ;
 383: LD_ADDR_OWVAR 39
 387: PUSH
 388: LD_INT 1
 390: ST_TO_ADDR
// vc_control := control_manual ;
 391: LD_ADDR_OWVAR 38
 395: PUSH
 396: LD_INT 1
 398: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ game_difficulty ] ;
 399: LD_ADDR_OWVAR 40
 403: PUSH
 404: LD_INT 42
 406: PUSH
 407: LD_INT 42
 409: PUSH
 410: LD_INT 43
 412: PUSH
 413: EMPTY
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_EXP 1
 422: ARRAY
 423: ST_TO_ADDR
// veh := CreateVehicle ;
 424: LD_ADDR_VAR 0 4
 428: PUSH
 429: CALL_OW 45
 433: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
 434: LD_VAR 0 4
 438: PPUSH
 439: LD_INT 2
 441: PPUSH
 442: CALL_OW 233
// PlaceUnitXY ( veh , 39 , 38 , false ) ;
 446: LD_VAR 0 4
 450: PPUSH
 451: LD_INT 39
 453: PPUSH
 454: LD_INT 38
 456: PPUSH
 457: LD_INT 0
 459: PPUSH
 460: CALL_OW 48
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_skill ) , veh ) ;
 464: LD_INT 3
 466: PPUSH
 467: LD_EXP 3
 471: PPUSH
 472: CALL 1951 0 2
 476: PPUSH
 477: LD_VAR 0 4
 481: PPUSH
 482: CALL_OW 52
// for i = 1 to FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) do
 486: LD_ADDR_VAR 0 2
 490: PUSH
 491: DOUBLE
 492: LD_INT 1
 494: DEC
 495: ST_TO_ADDR
 496: LD_INT 21
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: PUSH
 506: LD_INT 58
 508: PUSH
 509: EMPTY
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: PPUSH
 516: CALL_OW 69
 520: PUSH
 521: FOR_TO
 522: IFFALSE 572
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , ru_skill ) , FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) [ 1 ] ) ;
 524: LD_INT 3
 526: PPUSH
 527: LD_EXP 3
 531: PPUSH
 532: CALL 1951 0 2
 536: PPUSH
 537: LD_INT 21
 539: PUSH
 540: LD_INT 2
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 58
 549: PUSH
 550: EMPTY
 551: LIST
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: PPUSH
 557: CALL_OW 69
 561: PUSH
 562: LD_INT 1
 564: ARRAY
 565: PPUSH
 566: CALL_OW 52
 570: GO 521
 572: POP
 573: POP
// ru_vehs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
 574: LD_ADDR_EXP 5
 578: PUSH
 579: LD_INT 22
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: PUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 2
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: PPUSH
 603: CALL_OW 69
 607: ST_TO_ADDR
// end ;
 608: LD_VAR 0 1
 612: RET
// every 0 0$01 trigger ru_cont_base do var i , engs , filter , dmg_b , b , heal , sci , tower , sol ;
 613: LD_EXP 6
 617: IFFALSE 1586
 619: GO 621
 621: DISABLE
 622: LD_INT 0
 624: PPUSH
 625: PPUSH
 626: PPUSH
 627: PPUSH
 628: PPUSH
 629: PPUSH
 630: PPUSH
 631: PPUSH
 632: PPUSH
// begin enable ;
 633: ENABLE
// engs := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ] ) ;
 634: LD_ADDR_VAR 0 2
 638: PUSH
 639: LD_INT 22
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 25
 651: PUSH
 652: LD_INT 2
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 50
 661: PUSH
 662: EMPTY
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: EMPTY
 671: LIST
 672: PPUSH
 673: CALL_OW 69
 677: ST_TO_ADDR
// dmg_b := FilterUnitsInArea ( ru_base , [ [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
 678: LD_ADDR_VAR 0 4
 682: PUSH
 683: LD_INT 14
 685: PPUSH
 686: LD_INT 22
 688: PUSH
 689: LD_INT 3
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: PUSH
 696: LD_INT 21
 698: PUSH
 699: LD_INT 3
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 24
 711: PUSH
 712: LD_INT 1000
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: PUSH
 728: EMPTY
 729: LIST
 730: PPUSH
 731: CALL_OW 70
 735: ST_TO_ADDR
// heal := FilterUnitsInArea ( ru_base , [ [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 880 ] ] ] ] ) ;
 736: LD_ADDR_VAR 0 6
 740: PUSH
 741: LD_INT 14
 743: PPUSH
 744: LD_INT 22
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 21
 756: PUSH
 757: LD_INT 1
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: PUSH
 764: LD_INT 3
 766: PUSH
 767: LD_INT 24
 769: PUSH
 770: LD_INT 880
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: PUSH
 786: EMPTY
 787: LIST
 788: PPUSH
 789: CALL_OW 70
 793: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
 794: LD_ADDR_VAR 0 7
 798: PUSH
 799: LD_INT 22
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: PUSH
 809: LD_INT 25
 811: PUSH
 812: LD_INT 4
 814: PUSH
 815: EMPTY
 816: LIST
 817: LIST
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] , [ f_empty ] ] ] ) ;
 828: LD_ADDR_VAR 0 8
 832: PUSH
 833: LD_INT 22
 835: PUSH
 836: LD_INT 3
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 2
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 31
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: PUSH
 856: LD_INT 30
 858: PUSH
 859: LD_INT 32
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: PUSH
 866: EMPTY
 867: LIST
 868: LIST
 869: LIST
 870: PUSH
 871: LD_INT 58
 873: PUSH
 874: EMPTY
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: PUSH
 882: EMPTY
 883: LIST
 884: PPUSH
 885: CALL_OW 69
 889: ST_TO_ADDR
// sol := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) diff ru_patrol ;
 890: LD_ADDR_VAR 0 9
 894: PUSH
 895: LD_INT 22
 897: PUSH
 898: LD_INT 3
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 25
 907: PUSH
 908: LD_INT 1
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 56
 917: PUSH
 918: EMPTY
 919: LIST
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: EMPTY
 927: LIST
 928: PPUSH
 929: CALL_OW 69
 933: PUSH
 934: LD_EXP 4
 938: DIFF
 939: ST_TO_ADDR
// if tower then
 940: LD_VAR 0 8
 944: IFFALSE 984
// if not HasTask ( sol [ 1 ] ) then
 946: LD_VAR 0 9
 950: PUSH
 951: LD_INT 1
 953: ARRAY
 954: PPUSH
 955: CALL_OW 314
 959: NOT
 960: IFFALSE 984
// ComEnterUnit ( sol [ 1 ] , tower [ 1 ] ) ;
 962: LD_VAR 0 9
 966: PUSH
 967: LD_INT 1
 969: ARRAY
 970: PPUSH
 971: LD_VAR 0 8
 975: PUSH
 976: LD_INT 1
 978: ARRAY
 979: PPUSH
 980: CALL_OW 120
// if heal then
 984: LD_VAR 0 6
 988: IFFALSE 1090
// begin for i = 1 to sci do
 990: LD_ADDR_VAR 0 1
 994: PUSH
 995: DOUBLE
 996: LD_INT 1
 998: DEC
 999: ST_TO_ADDR
1000: LD_VAR 0 7
1004: PUSH
1005: FOR_TO
1006: IFFALSE 1086
// if IsInUnit ( sci [ i ] ) then
1008: LD_VAR 0 7
1012: PUSH
1013: LD_VAR 0 1
1017: ARRAY
1018: PPUSH
1019: CALL_OW 310
1023: IFFALSE 1042
// ComExitBuilding ( sci [ i ] ) else
1025: LD_VAR 0 7
1029: PUSH
1030: LD_VAR 0 1
1034: ARRAY
1035: PPUSH
1036: CALL_OW 122
1040: GO 1084
// if not HasTask ( sci [ i ] ) then
1042: LD_VAR 0 7
1046: PUSH
1047: LD_VAR 0 1
1051: ARRAY
1052: PPUSH
1053: CALL_OW 314
1057: NOT
1058: IFFALSE 1084
// ComHeal ( sci [ i ] , heal [ 1 ] ) ;
1060: LD_VAR 0 7
1064: PUSH
1065: LD_VAR 0 1
1069: ARRAY
1070: PPUSH
1071: LD_VAR 0 6
1075: PUSH
1076: LD_INT 1
1078: ARRAY
1079: PPUSH
1080: CALL_OW 128
1084: GO 1005
1086: POP
1087: POP
// end else
1088: GO 1178
// for i = 1 to sci do
1090: LD_ADDR_VAR 0 1
1094: PUSH
1095: DOUBLE
1096: LD_INT 1
1098: DEC
1099: ST_TO_ADDR
1100: LD_VAR 0 7
1104: PUSH
1105: FOR_TO
1106: IFFALSE 1176
// if not IsInUnit ( sci [ i ] ) then
1108: LD_VAR 0 7
1112: PUSH
1113: LD_VAR 0 1
1117: ARRAY
1118: PPUSH
1119: CALL_OW 310
1123: NOT
1124: IFFALSE 1174
// ComEnterUnit ( sci [ i ] , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) [ 1 ] ) ;
1126: LD_VAR 0 7
1130: PUSH
1131: LD_VAR 0 1
1135: ARRAY
1136: PPUSH
1137: LD_INT 22
1139: PUSH
1140: LD_INT 3
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: PUSH
1147: LD_INT 30
1149: PUSH
1150: LD_INT 6
1152: PUSH
1153: EMPTY
1154: LIST
1155: LIST
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL_OW 69
1165: PUSH
1166: LD_INT 1
1168: ARRAY
1169: PPUSH
1170: CALL_OW 120
1174: GO 1105
1176: POP
1177: POP
// if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ] ) and BuildingStatus ( ru_fac ) = bs_idle then
1178: LD_INT 22
1180: PUSH
1181: LD_INT 3
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 32
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 35
1200: PUSH
1201: LD_INT 0
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: PPUSH
1216: CALL_OW 69
1220: PUSH
1221: LD_INT 10
1223: PPUSH
1224: CALL_OW 461
1228: PUSH
1229: LD_INT 2
1231: EQUAL
1232: AND
1233: IFFALSE 1289
// ComPlaceWeapon ( FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_btype , b_bunker ] , [ f_bweapon , 0 ] ] ] ) [ 1 ] , ru_heavy_machine_gun ) ;
1235: LD_INT 22
1237: PUSH
1238: LD_INT 3
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 30
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: EMPTY
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 35
1257: PUSH
1258: LD_INT 0
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: EMPTY
1271: LIST
1272: PPUSH
1273: CALL_OW 69
1277: PUSH
1278: LD_INT 1
1280: ARRAY
1281: PPUSH
1282: LD_INT 42
1284: PPUSH
1285: CALL_OW 148
// if engs then
1289: LD_VAR 0 2
1293: IFFALSE 1586
// begin if dmg_b then
1295: LD_VAR 0 4
1299: IFFALSE 1401
// begin for i = 1 to engs do
1301: LD_ADDR_VAR 0 1
1305: PUSH
1306: DOUBLE
1307: LD_INT 1
1309: DEC
1310: ST_TO_ADDR
1311: LD_VAR 0 2
1315: PUSH
1316: FOR_TO
1317: IFFALSE 1397
// if IsInUnit ( engs [ i ] ) then
1319: LD_VAR 0 2
1323: PUSH
1324: LD_VAR 0 1
1328: ARRAY
1329: PPUSH
1330: CALL_OW 310
1334: IFFALSE 1353
// ComExitBuilding ( engs [ i ] ) else
1336: LD_VAR 0 2
1340: PUSH
1341: LD_VAR 0 1
1345: ARRAY
1346: PPUSH
1347: CALL_OW 122
1351: GO 1395
// if not HasTask ( engs [ i ] ) then
1353: LD_VAR 0 2
1357: PUSH
1358: LD_VAR 0 1
1362: ARRAY
1363: PPUSH
1364: CALL_OW 314
1368: NOT
1369: IFFALSE 1395
// ComRepairBuilding ( engs [ i ] , dmg_b [ 1 ] ) ;
1371: LD_VAR 0 2
1375: PUSH
1376: LD_VAR 0 1
1380: ARRAY
1381: PPUSH
1382: LD_VAR 0 4
1386: PUSH
1387: LD_INT 1
1389: ARRAY
1390: PPUSH
1391: CALL_OW 130
1395: GO 1316
1397: POP
1398: POP
// end else
1399: GO 1586
// if ru_blist = 0 then
1401: LD_EXP 7
1405: PUSH
1406: LD_INT 0
1408: EQUAL
1409: IFFALSE 1489
// begin for i = 1 to engs do
1411: LD_ADDR_VAR 0 1
1415: PUSH
1416: DOUBLE
1417: LD_INT 1
1419: DEC
1420: ST_TO_ADDR
1421: LD_VAR 0 2
1425: PUSH
1426: FOR_TO
1427: IFFALSE 1485
// if not HasTask ( engs [ i ] ) and not IsInUnit ( engs [ i ] ) then
1429: LD_VAR 0 2
1433: PUSH
1434: LD_VAR 0 1
1438: ARRAY
1439: PPUSH
1440: CALL_OW 314
1444: NOT
1445: PUSH
1446: LD_VAR 0 2
1450: PUSH
1451: LD_VAR 0 1
1455: ARRAY
1456: PPUSH
1457: CALL_OW 310
1461: NOT
1462: AND
1463: IFFALSE 1483
// ComEnterUnit ( engs [ i ] , ru_dep ) ;
1465: LD_VAR 0 2
1469: PUSH
1470: LD_VAR 0 1
1474: ARRAY
1475: PPUSH
1476: LD_INT 2
1478: PPUSH
1479: CALL_OW 120
1483: GO 1426
1485: POP
1486: POP
// end else
1487: GO 1586
// if ru_blist then
1489: LD_EXP 7
1493: IFFALSE 1586
// for i = 1 to engs do
1495: LD_ADDR_VAR 0 1
1499: PUSH
1500: DOUBLE
1501: LD_INT 1
1503: DEC
1504: ST_TO_ADDR
1505: LD_VAR 0 2
1509: PUSH
1510: FOR_TO
1511: IFFALSE 1584
// if not HasTask ( engs [ i ] ) then
1513: LD_VAR 0 2
1517: PUSH
1518: LD_VAR 0 1
1522: ARRAY
1523: PPUSH
1524: CALL_OW 314
1528: NOT
1529: IFFALSE 1582
// ComBuild ( engs [ i ] , ru_blist [ 1 ] , ru_blist [ 2 ] , ru_blist [ 3 ] , ru_blist [ 4 ] ) ;
1531: LD_VAR 0 2
1535: PUSH
1536: LD_VAR 0 1
1540: ARRAY
1541: PPUSH
1542: LD_EXP 7
1546: PUSH
1547: LD_INT 1
1549: ARRAY
1550: PPUSH
1551: LD_EXP 7
1555: PUSH
1556: LD_INT 2
1558: ARRAY
1559: PPUSH
1560: LD_EXP 7
1564: PUSH
1565: LD_INT 3
1567: ARRAY
1568: PPUSH
1569: LD_EXP 7
1573: PUSH
1574: LD_INT 4
1576: ARRAY
1577: PPUSH
1578: CALL_OW 145
1582: GO 1510
1584: POP
1585: POP
// end ; end ; end_of_file
1586: PPOPN 9
1588: END
// export function RefreshTime ( time , bool ) ; begin
1589: LD_INT 0
1591: PPUSH
// if bool then
1592: LD_VAR 0 2
1596: IFFALSE 1614
// time := time + 0 0$01 else
1598: LD_ADDR_VAR 0 1
1602: PUSH
1603: LD_VAR 0 1
1607: PUSH
1608: LD_INT 35
1610: PLUS
1611: ST_TO_ADDR
1612: GO 1628
// time := time - 0 0$01 ;
1614: LD_ADDR_VAR 0 1
1618: PUSH
1619: LD_VAR 0 1
1623: PUSH
1624: LD_INT 35
1626: MINUS
1627: ST_TO_ADDR
// result := time ;
1628: LD_ADDR_VAR 0 3
1632: PUSH
1633: LD_VAR 0 1
1637: ST_TO_ADDR
// end ;
1638: LD_VAR 0 3
1642: RET
// export function MineExist ( side ) ; begin
1643: LD_INT 0
1645: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
1646: LD_INT 22
1648: PUSH
1649: LD_VAR 0 1
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: PUSH
1658: LD_INT 30
1660: PUSH
1661: LD_INT 30
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: PPUSH
1672: CALL_OW 69
1676: PUSH
1677: LD_INT 0
1679: GREATER
1680: IFFALSE 1692
// result := true else
1682: LD_ADDR_VAR 0 2
1686: PUSH
1687: LD_INT 1
1689: ST_TO_ADDR
1690: GO 1700
// result := false ;
1692: LD_ADDR_VAR 0 2
1696: PUSH
1697: LD_INT 0
1699: ST_TO_ADDR
// end ;
1700: LD_VAR 0 2
1704: RET
// export function FacExist ( side ) ; begin
1705: LD_INT 0
1707: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 then
1708: LD_INT 22
1710: PUSH
1711: LD_VAR 0 1
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: PUSH
1720: LD_INT 30
1722: PUSH
1723: LD_INT 3
1725: PUSH
1726: EMPTY
1727: LIST
1728: LIST
1729: PUSH
1730: EMPTY
1731: LIST
1732: LIST
1733: PPUSH
1734: CALL_OW 69
1738: PUSH
1739: LD_INT 0
1741: GREATER
1742: IFFALSE 1754
// result := true else
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: LD_INT 1
1751: ST_TO_ADDR
1752: GO 1762
// result := false ;
1754: LD_ADDR_VAR 0 2
1758: PUSH
1759: LD_INT 0
1761: ST_TO_ADDR
// end ;
1762: LD_VAR 0 2
1766: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
1767: LD_INT 0
1769: PPUSH
1770: PPUSH
1771: PPUSH
1772: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
1773: LD_ADDR_VAR 0 4
1777: PUSH
1778: LD_INT 22
1780: PUSH
1781: LD_VAR 0 1
1785: PUSH
1786: EMPTY
1787: LIST
1788: LIST
1789: PUSH
1790: LD_INT 33
1792: PUSH
1793: LD_INT 2
1795: PUSH
1796: EMPTY
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 50
1802: PUSH
1803: EMPTY
1804: LIST
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PPUSH
1811: CALL_OW 69
1815: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_INT 22
1823: PUSH
1824: LD_VAR 0 1
1828: PUSH
1829: EMPTY
1830: LIST
1831: LIST
1832: PUSH
1833: LD_INT 34
1835: PUSH
1836: LD_INT 31
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: PPUSH
1847: CALL_OW 69
1851: ST_TO_ADDR
// if tower > 0 and filter > 0 then
1852: LD_VAR 0 5
1856: PUSH
1857: LD_INT 0
1859: GREATER
1860: PUSH
1861: LD_VAR 0 4
1865: PUSH
1866: LD_INT 0
1868: GREATER
1869: AND
1870: IFFALSE 1946
// for i = 1 to filter do
1872: LD_ADDR_VAR 0 3
1876: PUSH
1877: DOUBLE
1878: LD_INT 1
1880: DEC
1881: ST_TO_ADDR
1882: LD_VAR 0 4
1886: PUSH
1887: FOR_TO
1888: IFFALSE 1944
// if not IsControledBy ( filter [ i ] ) then
1890: LD_VAR 0 4
1894: PUSH
1895: LD_VAR 0 3
1899: ARRAY
1900: PPUSH
1901: CALL_OW 312
1905: NOT
1906: IFFALSE 1942
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
1908: LD_VAR 0 4
1912: PUSH
1913: LD_VAR 0 3
1917: ARRAY
1918: PPUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_INT 1
1926: PPUSH
1927: LD_VAR 0 5
1931: PPUSH
1932: CALL_OW 12
1936: ARRAY
1937: PPUSH
1938: CALL_OW 135
1942: GO 1887
1944: POP
1945: POP
// end ;
1946: LD_VAR 0 2
1950: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
1951: LD_INT 0
1953: PPUSH
1954: PPUSH
1955: PPUSH
1956: PPUSH
1957: PPUSH
1958: PPUSH
// hc_class := clas ;
1959: LD_ADDR_OWVAR 28
1963: PUSH
1964: LD_VAR 0 1
1968: ST_TO_ADDR
// hc_importance := 0 ;
1969: LD_ADDR_OWVAR 32
1973: PUSH
1974: LD_INT 0
1976: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
1977: LD_ADDR_VAR 0 4
1981: PUSH
1982: LD_VAR 0 2
1986: PUSH
1987: LD_INT 1
1989: NEG
1990: PPUSH
1991: LD_INT 1
1993: PPUSH
1994: CALL_OW 12
1998: PLUS
1999: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
2000: LD_ADDR_VAR 0 5
2004: PUSH
2005: LD_VAR 0 2
2009: PUSH
2010: LD_INT 1
2012: NEG
2013: PPUSH
2014: LD_INT 1
2016: PPUSH
2017: CALL_OW 12
2021: PLUS
2022: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
2023: LD_ADDR_VAR 0 6
2027: PUSH
2028: LD_VAR 0 2
2032: PUSH
2033: LD_INT 1
2035: NEG
2036: PPUSH
2037: LD_INT 1
2039: PPUSH
2040: CALL_OW 12
2044: PLUS
2045: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
2046: LD_ADDR_VAR 0 7
2050: PUSH
2051: LD_VAR 0 2
2055: PUSH
2056: LD_INT 1
2058: NEG
2059: PPUSH
2060: LD_INT 1
2062: PPUSH
2063: CALL_OW 12
2067: PLUS
2068: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
2069: LD_VAR 0 1
2073: PUSH
2074: LD_INT 1
2076: EQUAL
2077: PUSH
2078: LD_VAR 0 1
2082: PUSH
2083: LD_INT 9
2085: EQUAL
2086: OR
2087: PUSH
2088: LD_VAR 0 1
2092: PUSH
2093: LD_INT 5
2095: EQUAL
2096: OR
2097: PUSH
2098: LD_VAR 0 1
2102: PUSH
2103: LD_INT 8
2105: EQUAL
2106: OR
2107: IFFALSE 2132
// bonus := [ 2 , 0 , 0 , 0 ] ;
2109: LD_ADDR_VAR 0 8
2113: PUSH
2114: LD_INT 2
2116: PUSH
2117: LD_INT 0
2119: PUSH
2120: LD_INT 0
2122: PUSH
2123: LD_INT 0
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: ST_TO_ADDR
// if clas = 2 then
2132: LD_VAR 0 1
2136: PUSH
2137: LD_INT 2
2139: EQUAL
2140: IFFALSE 2165
// bonus := [ 0 , 2 , 0 , 0 ] ;
2142: LD_ADDR_VAR 0 8
2146: PUSH
2147: LD_INT 0
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: LD_INT 0
2155: PUSH
2156: LD_INT 0
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: ST_TO_ADDR
// if clas = 3 then
2165: LD_VAR 0 1
2169: PUSH
2170: LD_INT 3
2172: EQUAL
2173: IFFALSE 2198
// bonus := [ 0 , 0 , 2 , 0 ] ;
2175: LD_ADDR_VAR 0 8
2179: PUSH
2180: LD_INT 0
2182: PUSH
2183: LD_INT 0
2185: PUSH
2186: LD_INT 2
2188: PUSH
2189: LD_INT 0
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: ST_TO_ADDR
// if clas = 4 then
2198: LD_VAR 0 1
2202: PUSH
2203: LD_INT 4
2205: EQUAL
2206: IFFALSE 2231
// bonus := [ 0 , 0 , 0 , 2 ] ;
2208: LD_ADDR_VAR 0 8
2212: PUSH
2213: LD_INT 0
2215: PUSH
2216: LD_INT 0
2218: PUSH
2219: LD_INT 0
2221: PUSH
2222: LD_INT 2
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: LIST
2230: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
2231: LD_VAR 0 1
2235: PUSH
2236: LD_INT 4
2238: GREATER
2239: PUSH
2240: LD_VAR 0 1
2244: PUSH
2245: LD_INT 9
2247: NONEQUAL
2248: AND
2249: PUSH
2250: LD_VAR 0 1
2254: PUSH
2255: LD_INT 5
2257: NONEQUAL
2258: AND
2259: PUSH
2260: LD_VAR 0 1
2264: PUSH
2265: LD_INT 8
2267: NONEQUAL
2268: AND
2269: IFFALSE 2294
// bonus := [ 0 , 0 , 0 , 0 ] ;
2271: LD_ADDR_VAR 0 8
2275: PUSH
2276: LD_INT 0
2278: PUSH
2279: LD_INT 0
2281: PUSH
2282: LD_INT 0
2284: PUSH
2285: LD_INT 0
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2294: LD_ADDR_OWVAR 30
2298: PUSH
2299: LD_INT 0
2301: PPUSH
2302: LD_INT 2
2304: PPUSH
2305: CALL_OW 12
2309: PUSH
2310: LD_INT 0
2312: PPUSH
2313: LD_INT 2
2315: PPUSH
2316: CALL_OW 12
2320: PUSH
2321: LD_INT 0
2323: PPUSH
2324: LD_INT 2
2326: PPUSH
2327: CALL_OW 12
2331: PUSH
2332: LD_INT 0
2334: PPUSH
2335: LD_INT 2
2337: PPUSH
2338: CALL_OW 12
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
2349: LD_ADDR_OWVAR 31
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_VAR 0 8
2363: PUSH
2364: LD_INT 1
2366: ARRAY
2367: PLUS
2368: PUSH
2369: LD_VAR 0 5
2373: PUSH
2374: LD_VAR 0 8
2378: PUSH
2379: LD_INT 2
2381: ARRAY
2382: PLUS
2383: PUSH
2384: LD_VAR 0 6
2388: PUSH
2389: LD_VAR 0 8
2393: PUSH
2394: LD_INT 3
2396: ARRAY
2397: PLUS
2398: PUSH
2399: LD_VAR 0 7
2403: PUSH
2404: LD_VAR 0 8
2408: PUSH
2409: LD_INT 4
2411: ARRAY
2412: PLUS
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: LIST
2418: LIST
2419: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
2420: LD_ADDR_OWVAR 27
2424: PUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 2
2430: PPUSH
2431: CALL_OW 12
2435: ST_TO_ADDR
// hc_gallery :=  ;
2436: LD_ADDR_OWVAR 33
2440: PUSH
2441: LD_STRING 
2443: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
2444: LD_ADDR_OWVAR 29
2448: PUSH
2449: LD_INT 8
2451: PPUSH
2452: LD_INT 12
2454: PPUSH
2455: CALL_OW 12
2459: PUSH
2460: LD_INT 9
2462: PPUSH
2463: LD_INT 11
2465: PPUSH
2466: CALL_OW 12
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: ST_TO_ADDR
// hc_name :=  ;
2475: LD_ADDR_OWVAR 26
2479: PUSH
2480: LD_STRING 
2482: ST_TO_ADDR
// result := CreateHuman ;
2483: LD_ADDR_VAR 0 3
2487: PUSH
2488: CALL_OW 44
2492: ST_TO_ADDR
// end ;
2493: LD_VAR 0 3
2497: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
2498: LD_INT 0
2500: PPUSH
2501: PPUSH
2502: PPUSH
2503: PPUSH
2504: PPUSH
2505: PPUSH
// uc_nation = nation_nature ;
2506: LD_ADDR_OWVAR 21
2510: PUSH
2511: LD_INT 0
2513: ST_TO_ADDR
// uc_side = 0 ;
2514: LD_ADDR_OWVAR 20
2518: PUSH
2519: LD_INT 0
2521: ST_TO_ADDR
// l = 0 ;
2522: LD_ADDR_VAR 0 7
2526: PUSH
2527: LD_INT 0
2529: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
2530: LD_ADDR_OWVAR 24
2534: PUSH
2535: LD_INT 0
2537: PPUSH
2538: LD_INT 5
2540: PPUSH
2541: CALL_OW 12
2545: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
2546: LD_ADDR_OWVAR 35
2550: PUSH
2551: LD_INT 5
2553: NEG
2554: PPUSH
2555: LD_INT 0
2557: PPUSH
2558: CALL_OW 12
2562: ST_TO_ADDR
// hc_gallery =  ;
2563: LD_ADDR_OWVAR 33
2567: PUSH
2568: LD_STRING 
2570: ST_TO_ADDR
// hc_class = class_apeman ;
2571: LD_ADDR_OWVAR 28
2575: PUSH
2576: LD_INT 12
2578: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
2579: LD_ADDR_OWVAR 29
2583: PUSH
2584: LD_INT 11
2586: PPUSH
2587: LD_INT 13
2589: PPUSH
2590: CALL_OW 12
2594: PUSH
2595: LD_INT 10
2597: PPUSH
2598: LD_INT 11
2600: PPUSH
2601: CALL_OW 12
2605: PUSH
2606: EMPTY
2607: LIST
2608: LIST
2609: ST_TO_ADDR
// hc_sex = sex_male ;
2610: LD_ADDR_OWVAR 27
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
2618: LD_ADDR_OWVAR 31
2622: PUSH
2623: LD_INT 0
2625: PPUSH
2626: LD_INT 2
2628: PPUSH
2629: CALL_OW 12
2633: PUSH
2634: LD_INT 0
2636: PUSH
2637: LD_INT 0
2639: PUSH
2640: LD_INT 0
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: ST_TO_ADDR
// apeman = CreateHuman ;
2649: LD_ADDR_VAR 0 8
2653: PUSH
2654: CALL_OW 44
2658: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
2659: LD_VAR 0 8
2663: PPUSH
2664: LD_VAR 0 1
2668: PPUSH
2669: LD_INT 0
2671: PPUSH
2672: CALL_OW 49
// l = l + 1 ;
2676: LD_ADDR_VAR 0 7
2680: PUSH
2681: LD_VAR 0 7
2685: PUSH
2686: LD_INT 1
2688: PLUS
2689: ST_TO_ADDR
// end until l = num1 ;
2690: LD_VAR 0 7
2694: PUSH
2695: LD_VAR 0 2
2699: EQUAL
2700: IFFALSE 2530
// l = 0 ;
2702: LD_ADDR_VAR 0 7
2706: PUSH
2707: LD_INT 0
2709: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
2710: LD_ADDR_OWVAR 35
2714: PUSH
2715: LD_INT 0
2717: PPUSH
2718: LD_INT 25
2720: PPUSH
2721: CALL_OW 12
2725: ST_TO_ADDR
// hc_class = class_tiger ;
2726: LD_ADDR_OWVAR 28
2730: PUSH
2731: LD_INT 14
2733: ST_TO_ADDR
// hc_sex = sex_male ;
2734: LD_ADDR_OWVAR 27
2738: PUSH
2739: LD_INT 1
2741: ST_TO_ADDR
// hc_gallery = sandnature ;
2742: LD_ADDR_OWVAR 33
2746: PUSH
2747: LD_STRING sandnature
2749: ST_TO_ADDR
// hc_face_number = 3 ;
2750: LD_ADDR_OWVAR 34
2754: PUSH
2755: LD_INT 3
2757: ST_TO_ADDR
// tiger = CreateHuman ;
2758: LD_ADDR_VAR 0 9
2762: PUSH
2763: CALL_OW 44
2767: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
2768: LD_VAR 0 9
2772: PPUSH
2773: LD_VAR 0 1
2777: PPUSH
2778: LD_INT 0
2780: PPUSH
2781: CALL_OW 49
// l = l + 1 ;
2785: LD_ADDR_VAR 0 7
2789: PUSH
2790: LD_VAR 0 7
2794: PUSH
2795: LD_INT 1
2797: PLUS
2798: ST_TO_ADDR
// end until l = num2 ;
2799: LD_VAR 0 7
2803: PUSH
2804: LD_VAR 0 3
2808: EQUAL
2809: IFFALSE 2710
// l = 0 ;
2811: LD_ADDR_VAR 0 7
2815: PUSH
2816: LD_INT 0
2818: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
2819: LD_ADDR_OWVAR 28
2823: PUSH
2824: LD_INT 18
2826: ST_TO_ADDR
// hc_gallery = sandnature ;
2827: LD_ADDR_OWVAR 33
2831: PUSH
2832: LD_STRING sandnature
2834: ST_TO_ADDR
// hc_face_number = 1 ;
2835: LD_ADDR_OWVAR 34
2839: PUSH
2840: LD_INT 1
2842: ST_TO_ADDR
// bird = CreateHuman ;
2843: LD_ADDR_VAR 0 10
2847: PUSH
2848: CALL_OW 44
2852: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
2853: LD_VAR 0 10
2857: PPUSH
2858: LD_INT 0
2860: PPUSH
2861: CALL_OW 51
// l = l + 1 ;
2865: LD_ADDR_VAR 0 7
2869: PUSH
2870: LD_VAR 0 7
2874: PUSH
2875: LD_INT 1
2877: PLUS
2878: ST_TO_ADDR
// end until l = num3 ;
2879: LD_VAR 0 7
2883: PUSH
2884: LD_VAR 0 4
2888: EQUAL
2889: IFFALSE 2819
// l = 0 ;
2891: LD_ADDR_VAR 0 7
2895: PUSH
2896: LD_INT 0
2898: ST_TO_ADDR
// repeat begin hc_class = 21 ;
2899: LD_ADDR_OWVAR 28
2903: PUSH
2904: LD_INT 21
2906: ST_TO_ADDR
// hc_gallery = sandnature ;
2907: LD_ADDR_OWVAR 33
2911: PUSH
2912: LD_STRING sandnature
2914: ST_TO_ADDR
// hc_face_number = 5 ;
2915: LD_ADDR_OWVAR 34
2919: PUSH
2920: LD_INT 5
2922: ST_TO_ADDR
// horse := CreateHuman ;
2923: LD_ADDR_VAR 0 11
2927: PUSH
2928: CALL_OW 44
2932: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
2933: LD_VAR 0 11
2937: PPUSH
2938: LD_VAR 0 1
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: CALL_OW 49
// l = l + 1 ;
2950: LD_ADDR_VAR 0 7
2954: PUSH
2955: LD_VAR 0 7
2959: PUSH
2960: LD_INT 1
2962: PLUS
2963: ST_TO_ADDR
// end until l = num4 ;
2964: LD_VAR 0 7
2968: PUSH
2969: LD_VAR 0 5
2973: EQUAL
2974: IFFALSE 2899
// end ; end_of_file
2976: LD_VAR 0 6
2980: RET
// export us_squad , brown ; export function PrepareAmerican ; var i , filter , p , us_sold , us_eng , us_sci , skill ; begin
2981: LD_INT 0
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
2987: PPUSH
2988: PPUSH
2989: PPUSH
2990: PPUSH
// uc_side := 1 ;
2991: LD_ADDR_OWVAR 20
2995: PUSH
2996: LD_INT 1
2998: ST_TO_ADDR
// uc_nation := 1 ;
2999: LD_ADDR_OWVAR 21
3003: PUSH
3004: LD_INT 1
3006: ST_TO_ADDR
// hc_gallery := us ;
3007: LD_ADDR_OWVAR 33
3011: PUSH
3012: LD_STRING us
3014: ST_TO_ADDR
// hc_face_number := 15 ;
3015: LD_ADDR_OWVAR 34
3019: PUSH
3020: LD_INT 15
3022: ST_TO_ADDR
// hc_sex := sex_male ;
3023: LD_ADDR_OWVAR 27
3027: PUSH
3028: LD_INT 1
3030: ST_TO_ADDR
// hc_name := Jeff Brown ;
3031: LD_ADDR_OWVAR 26
3035: PUSH
3036: LD_STRING Jeff Brown
3038: ST_TO_ADDR
// hc_basic_skills := [ 1 , 2 , 0 , 0 ] ;
3039: LD_ADDR_OWVAR 30
3043: PUSH
3044: LD_INT 1
3046: PUSH
3047: LD_INT 2
3049: PUSH
3050: LD_INT 0
3052: PUSH
3053: LD_INT 0
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: ST_TO_ADDR
// hc_skills := [ [ 4 , 3 , 2 ] [ game_difficulty ] , 3 , 1 , 0 ] ;
3062: LD_ADDR_OWVAR 31
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 3
3072: PUSH
3073: LD_INT 2
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: PUSH
3081: LD_EXP 1
3085: ARRAY
3086: PUSH
3087: LD_INT 3
3089: PUSH
3090: LD_INT 1
3092: PUSH
3093: LD_INT 0
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: ST_TO_ADDR
// hc_class := 1 ;
3102: LD_ADDR_OWVAR 28
3106: PUSH
3107: LD_INT 1
3109: ST_TO_ADDR
// hc_importance := 100 ;
3110: LD_ADDR_OWVAR 32
3114: PUSH
3115: LD_INT 100
3117: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 10
3125: PUSH
3126: LD_INT 10
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// brown := CreateHuman ;
3133: LD_ADDR_EXP 9
3137: PUSH
3138: CALL_OW 44
3142: ST_TO_ADDR
// PlaceUnitArea ( brown , us_start , false ) ;
3143: LD_EXP 9
3147: PPUSH
3148: LD_INT 13
3150: PPUSH
3151: LD_INT 0
3153: PPUSH
3154: CALL_OW 49
// skill := [ 3 , 2 , 1 ] [ game_difficulty ] ;
3158: LD_ADDR_VAR 0 8
3162: PUSH
3163: LD_INT 3
3165: PUSH
3166: LD_INT 2
3168: PUSH
3169: LD_INT 1
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_EXP 1
3181: ARRAY
3182: ST_TO_ADDR
// us_sold := [ 4 , 3 , 3 ] [ game_difficulty ] ;
3183: LD_ADDR_VAR 0 5
3187: PUSH
3188: LD_INT 4
3190: PUSH
3191: LD_INT 3
3193: PUSH
3194: LD_INT 3
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: LD_EXP 1
3206: ARRAY
3207: ST_TO_ADDR
// us_eng := [ 2 , 1 , 1 ] [ game_difficulty ] ;
3208: LD_ADDR_VAR 0 6
3212: PUSH
3213: LD_INT 2
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 1
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_EXP 1
3231: ARRAY
3232: ST_TO_ADDR
// us_sci := [ 2 , 2 , 1 ] [ game_difficulty ] ;
3233: LD_ADDR_VAR 0 7
3237: PUSH
3238: LD_INT 2
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: PUSH
3252: LD_EXP 1
3256: ARRAY
3257: ST_TO_ADDR
// for i = 1 to us_sold do
3258: LD_ADDR_VAR 0 2
3262: PUSH
3263: DOUBLE
3264: LD_INT 1
3266: DEC
3267: ST_TO_ADDR
3268: LD_VAR 0 5
3272: PUSH
3273: FOR_TO
3274: IFFALSE 3301
// PlaceUnitArea ( CreateHumanWithClass ( 1 , skill ) , us_start , false ) ;
3276: LD_INT 1
3278: PPUSH
3279: LD_VAR 0 8
3283: PPUSH
3284: CALL 1951 0 2
3288: PPUSH
3289: LD_INT 13
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: CALL_OW 49
3299: GO 3273
3301: POP
3302: POP
// for i = 1 to us_eng do
3303: LD_ADDR_VAR 0 2
3307: PUSH
3308: DOUBLE
3309: LD_INT 1
3311: DEC
3312: ST_TO_ADDR
3313: LD_VAR 0 6
3317: PUSH
3318: FOR_TO
3319: IFFALSE 3346
// PlaceUnitArea ( CreateHumanWithClass ( 2 , skill ) , us_start , false ) ;
3321: LD_INT 2
3323: PPUSH
3324: LD_VAR 0 8
3328: PPUSH
3329: CALL 1951 0 2
3333: PPUSH
3334: LD_INT 13
3336: PPUSH
3337: LD_INT 0
3339: PPUSH
3340: CALL_OW 49
3344: GO 3318
3346: POP
3347: POP
// for i = 1 to us_sci do
3348: LD_ADDR_VAR 0 2
3352: PUSH
3353: DOUBLE
3354: LD_INT 1
3356: DEC
3357: ST_TO_ADDR
3358: LD_VAR 0 7
3362: PUSH
3363: FOR_TO
3364: IFFALSE 3391
// PlaceUnitArea ( CreateHumanWithClass ( 4 , skill ) , us_start , false ) ;
3366: LD_INT 4
3368: PPUSH
3369: LD_VAR 0 8
3373: PPUSH
3374: CALL 1951 0 2
3378: PPUSH
3379: LD_INT 13
3381: PPUSH
3382: LD_INT 0
3384: PPUSH
3385: CALL_OW 49
3389: GO 3363
3391: POP
3392: POP
// end ; end_of_file
3393: LD_VAR 0 1
3397: RET
// on UnitDestroyed ( b ) do begin if b in FilterUnitsInArea ( ru_base , [ f_type , unit_building ] ) then
3398: LD_VAR 0 1
3402: PUSH
3403: LD_INT 14
3405: PPUSH
3406: LD_INT 21
3408: PUSH
3409: LD_INT 3
3411: PUSH
3412: EMPTY
3413: LIST
3414: LIST
3415: PPUSH
3416: CALL_OW 70
3420: IN
3421: IFFALSE 3553
// begin if GetBType ( b ) = b_lab or GetBType ( b ) = b_lab_half then
3423: LD_VAR 0 1
3427: PPUSH
3428: CALL_OW 266
3432: PUSH
3433: LD_INT 6
3435: EQUAL
3436: PUSH
3437: LD_VAR 0 1
3441: PPUSH
3442: CALL_OW 266
3446: PUSH
3447: LD_INT 7
3449: EQUAL
3450: OR
3451: IFFALSE 3469
// ru_blist := ru_blist ^ b_lab else
3453: LD_ADDR_EXP 7
3457: PUSH
3458: LD_EXP 7
3462: PUSH
3463: LD_INT 6
3465: ADD
3466: ST_TO_ADDR
3467: GO 3490
// ru_blist := ru_blist ^ GetBType ( b ) ;
3469: LD_ADDR_EXP 7
3473: PUSH
3474: LD_EXP 7
3478: PUSH
3479: LD_VAR 0 1
3483: PPUSH
3484: CALL_OW 266
3488: ADD
3489: ST_TO_ADDR
// ru_blist := ru_blist ^ GetX ( b ) ;
3490: LD_ADDR_EXP 7
3494: PUSH
3495: LD_EXP 7
3499: PUSH
3500: LD_VAR 0 1
3504: PPUSH
3505: CALL_OW 250
3509: ADD
3510: ST_TO_ADDR
// ru_blist := ru_blist ^ GetY ( b ) ;
3511: LD_ADDR_EXP 7
3515: PUSH
3516: LD_EXP 7
3520: PUSH
3521: LD_VAR 0 1
3525: PPUSH
3526: CALL_OW 251
3530: ADD
3531: ST_TO_ADDR
// ru_blist := ru_blist ^ GetDir ( b ) ;
3532: LD_ADDR_EXP 7
3536: PUSH
3537: LD_EXP 7
3541: PUSH
3542: LD_VAR 0 1
3546: PPUSH
3547: CALL_OW 254
3551: ADD
3552: ST_TO_ADDR
// end ; if b = ru_dep then
3553: LD_VAR 0 1
3557: PUSH
3558: LD_INT 2
3560: EQUAL
3561: IFFALSE 3570
// YouLost ( depot-dest ) ;
3563: LD_STRING depot-dest
3565: PPUSH
3566: CALL_OW 104
// if b = brown then
3570: LD_VAR 0 1
3574: PUSH
3575: LD_EXP 9
3579: EQUAL
3580: IFFALSE 3589
// YouLost ( brown-dead ) ;
3582: LD_STRING brown-dead
3584: PPUSH
3585: CALL_OW 104
// end ;
3589: PPOPN 1
3591: END
// every 0 0$01 trigger GetSide ( ru_dep ) = 1 do
3592: LD_INT 2
3594: PPUSH
3595: CALL_OW 255
3599: PUSH
3600: LD_INT 1
3602: EQUAL
3603: IFFALSE 3616
3605: GO 3607
3607: DISABLE
// ru_cont_base := false ;
3608: LD_ADDR_EXP 6
3612: PUSH
3613: LD_INT 0
3615: ST_TO_ADDR
3616: END
// on BuildingComplete ( b ) do var i ;
3617: LD_INT 0
3619: PPUSH
// begin if GetSide ( b ) = 3 then
3620: LD_VAR 0 1
3624: PPUSH
3625: CALL_OW 255
3629: PUSH
3630: LD_INT 3
3632: EQUAL
3633: IFFALSE 3673
// for i = 1 to 4 do
3635: LD_ADDR_VAR 0 2
3639: PUSH
3640: DOUBLE
3641: LD_INT 1
3643: DEC
3644: ST_TO_ADDR
3645: LD_INT 4
3647: PUSH
3648: FOR_TO
3649: IFFALSE 3671
// ru_blist := Delete ( ru_blist , 1 ) ;
3651: LD_ADDR_EXP 7
3655: PUSH
3656: LD_EXP 7
3660: PPUSH
3661: LD_INT 1
3663: PPUSH
3664: CALL_OW 3
3668: ST_TO_ADDR
3669: GO 3648
3671: POP
3672: POP
// end ; end_of_file
3673: PPOPN 2
3675: END
// every 0 0$01 trigger FilterUnitsInArea ( us_alfa , [ [ f_type , unit_human ] , [ f_side , 1 ] ] ) = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var i ;
3676: LD_INT 2
3678: PPUSH
3679: LD_INT 21
3681: PUSH
3682: LD_INT 1
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 22
3691: PUSH
3692: LD_INT 1
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PPUSH
3703: CALL_OW 70
3707: PUSH
3708: LD_INT 22
3710: PUSH
3711: LD_INT 1
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_INT 21
3720: PUSH
3721: LD_INT 1
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: PPUSH
3732: CALL_OW 69
3736: EQUAL
3737: IFFALSE 3786
3739: GO 3741
3741: DISABLE
3742: LD_INT 0
3744: PPUSH
// begin for i = 1 to 3 do
3745: LD_ADDR_VAR 0 1
3749: PUSH
3750: DOUBLE
3751: LD_INT 1
3753: DEC
3754: ST_TO_ADDR
3755: LD_INT 3
3757: PUSH
3758: FOR_TO
3759: IFFALSE 3773
// AddMedal (  , 1 ) ;
3761: LD_STRING 
3763: PPUSH
3764: LD_INT 1
3766: PPUSH
3767: CALL_OW 101
3771: GO 3758
3773: POP
3774: POP
// GiveMedals ( MAIN ) ;
3775: LD_STRING MAIN
3777: PPUSH
3778: CALL_OW 102
// YouWin ;
3782: CALL_OW 103
// end ;
3786: PPOPN 1
3788: END
