// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// if isEditor then
   8: LD_INT 1
  10: IFFALSE 19
// FogOff ( 6 ) ;
  12: LD_INT 6
  14: PPUSH
  15: CALL_OW 344
// PrepareAnimals ( 7 , 2 , 2 , cratesArea ) ;
  19: LD_INT 7
  21: PPUSH
  22: LD_INT 2
  24: PPUSH
  25: LD_INT 2
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: CALL 4525 0 4
// PrepareAlliance ;
  35: CALL 48 0 0
// PrepareLegion ;
  39: CALL 723 0 0
// Action ;
  43: CALL 3854 0 0
// end ; end_of_file
  47: END
// export function PrepareAlliance ; var i , un , skill ; begin
  48: LD_INT 0
  50: PPUSH
  51: PPUSH
  52: PPUSH
  53: PPUSH
// uc_side := 7 ;
  54: LD_ADDR_OWVAR 20
  58: PUSH
  59: LD_INT 7
  61: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
  62: LD_ADDR_VAR 0 4
  66: PUSH
  67: LD_INT 7
  69: PUSH
  70: LD_INT 8
  72: PUSH
  73: LD_INT 9
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: LIST
  80: PUSH
  81: LD_OWVAR 67
  85: ARRAY
  86: ST_TO_ADDR
// SetResourceType ( GetBase ( al_dep ) , mat_cans , 999999 ) ;
  87: LD_INT 1
  89: PPUSH
  90: CALL_OW 274
  94: PPUSH
  95: LD_INT 1
  97: PPUSH
  98: LD_INT 999999
 100: PPUSH
 101: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_oil , 10000 ) ;
 105: LD_INT 1
 107: PPUSH
 108: CALL_OW 274
 112: PPUSH
 113: LD_INT 2
 115: PPUSH
 116: LD_INT 10000
 118: PPUSH
 119: CALL_OW 277
// SetResourceType ( GetBase ( al_dep ) , mat_siberit , 10000 ) ;
 123: LD_INT 1
 125: PPUSH
 126: CALL_OW 274
 130: PPUSH
 131: LD_INT 3
 133: PPUSH
 134: LD_INT 10000
 136: PPUSH
 137: CALL_OW 277
// for i = 1 to 6 do
 141: LD_ADDR_VAR 0 2
 145: PUSH
 146: DOUBLE
 147: LD_INT 1
 149: DEC
 150: ST_TO_ADDR
 151: LD_INT 6
 153: PUSH
 154: FOR_TO
 155: IFFALSE 216
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 157: LD_ADDR_OWVAR 21
 161: PUSH
 162: LD_INT 1
 164: PUSH
 165: LD_INT 3
 167: PUSH
 168: EMPTY
 169: LIST
 170: LIST
 171: PUSH
 172: LD_INT 1
 174: PPUSH
 175: LD_INT 2
 177: PPUSH
 178: CALL_OW 12
 182: ARRAY
 183: ST_TO_ADDR
// PrepareHuman ( false , class_engineer , skill ) ;
 184: LD_INT 0
 186: PPUSH
 187: LD_INT 2
 189: PPUSH
 190: LD_VAR 0 4
 194: PPUSH
 195: CALL_OW 380
// PlaceUnitArea ( CreateHuman , al_base , false ) ;
 199: CALL_OW 44
 203: PPUSH
 204: LD_INT 1
 206: PPUSH
 207: LD_INT 0
 209: PPUSH
 210: CALL_OW 49
// end ;
 214: GO 154
 216: POP
 217: POP
// for i = 1 to 6 do
 218: LD_ADDR_VAR 0 2
 222: PUSH
 223: DOUBLE
 224: LD_INT 1
 226: DEC
 227: ST_TO_ADDR
 228: LD_INT 6
 230: PUSH
 231: FOR_TO
 232: IFFALSE 290
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 234: LD_ADDR_OWVAR 21
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 3
 244: PUSH
 245: EMPTY
 246: LIST
 247: LIST
 248: PUSH
 249: LD_INT 1
 251: PPUSH
 252: LD_INT 2
 254: PPUSH
 255: CALL_OW 12
 259: ARRAY
 260: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 261: LD_INT 0
 263: PPUSH
 264: LD_INT 3
 266: PPUSH
 267: LD_VAR 0 4
 271: PPUSH
 272: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_ru ) ;
 276: CALL_OW 44
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL_OW 52
// end ;
 288: GO 231
 290: POP
 291: POP
// for i = 1 to 6 do
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: DOUBLE
 298: LD_INT 1
 300: DEC
 301: ST_TO_ADDR
 302: LD_INT 6
 304: PUSH
 305: FOR_TO
 306: IFFALSE 364
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 308: LD_ADDR_OWVAR 21
 312: PUSH
 313: LD_INT 1
 315: PUSH
 316: LD_INT 3
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 2
 328: PPUSH
 329: CALL_OW 12
 333: ARRAY
 334: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
 335: LD_INT 0
 337: PPUSH
 338: LD_INT 3
 340: PPUSH
 341: LD_VAR 0 4
 345: PPUSH
 346: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_fac_us ) ;
 350: CALL_OW 44
 354: PPUSH
 355: LD_INT 11
 357: PPUSH
 358: CALL_OW 52
// end ;
 362: GO 305
 364: POP
 365: POP
// for i = 1 to 6 do
 366: LD_ADDR_VAR 0 2
 370: PUSH
 371: DOUBLE
 372: LD_INT 1
 374: DEC
 375: ST_TO_ADDR
 376: LD_INT 6
 378: PUSH
 379: FOR_TO
 380: IFFALSE 457
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 382: LD_ADDR_OWVAR 21
 386: PUSH
 387: LD_INT 1
 389: PUSH
 390: LD_INT 3
 392: PUSH
 393: EMPTY
 394: LIST
 395: LIST
 396: PUSH
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 2
 402: PPUSH
 403: CALL_OW 12
 407: ARRAY
 408: ST_TO_ADDR
// PrepareHuman ( false , class_scientistic , skill ) ;
 409: LD_INT 0
 411: PPUSH
 412: LD_INT 4
 414: PPUSH
 415: LD_VAR 0 4
 419: PPUSH
 420: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , [ al_lab_us , al_lab_ru ] [ Rand ( 1 , 2 ) ] ) ;
 424: CALL_OW 44
 428: PPUSH
 429: LD_INT 2
 431: PUSH
 432: LD_INT 5
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 1
 441: PPUSH
 442: LD_INT 2
 444: PPUSH
 445: CALL_OW 12
 449: ARRAY
 450: PPUSH
 451: CALL_OW 52
// end ;
 455: GO 379
 457: POP
 458: POP
// for i = 1 to 6 do
 459: LD_ADDR_VAR 0 2
 463: PUSH
 464: DOUBLE
 465: LD_INT 1
 467: DEC
 468: ST_TO_ADDR
 469: LD_INT 6
 471: PUSH
 472: FOR_TO
 473: IFFALSE 580
// begin uc_nation := [ 1 , 3 ] [ Rand ( 1 , 2 ) ] ;
 475: LD_ADDR_OWVAR 21
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 3
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 2
 495: PPUSH
 496: CALL_OW 12
 500: ARRAY
 501: ST_TO_ADDR
// PrepareHuman ( false , [ class_sniper , class_bazooker ] [ Rand ( 1 , 2 ) ] , skill ) ;
 502: LD_INT 0
 504: PPUSH
 505: LD_INT 5
 507: PUSH
 508: LD_INT 9
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 1
 517: PPUSH
 518: LD_INT 2
 520: PPUSH
 521: CALL_OW 12
 525: ARRAY
 526: PPUSH
 527: LD_VAR 0 4
 531: PPUSH
 532: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 536: CALL_OW 44
 540: PPUSH
 541: LD_INT 22
 543: PUSH
 544: LD_INT 7
 546: PUSH
 547: EMPTY
 548: LIST
 549: LIST
 550: PUSH
 551: LD_INT 30
 553: PUSH
 554: LD_INT 5
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: PUSH
 561: EMPTY
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL_OW 69
 569: PUSH
 570: LD_INT 1
 572: ARRAY
 573: PPUSH
 574: CALL_OW 52
// end ;
 578: GO 472
 580: POP
 581: POP
// uc_nation := 3 ;
 582: LD_ADDR_OWVAR 21
 586: PUSH
 587: LD_INT 3
 589: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , skill ) ;
 590: LD_INT 0
 592: PPUSH
 593: LD_INT 5
 595: PPUSH
 596: LD_VAR 0 4
 600: PPUSH
 601: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , al_bun ) ;
 605: CALL_OW 44
 609: PPUSH
 610: LD_INT 50
 612: PPUSH
 613: CALL_OW 52
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_turret ] ] ) do
 617: LD_ADDR_VAR 0 2
 621: PUSH
 622: LD_INT 22
 624: PUSH
 625: LD_INT 7
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: PUSH
 632: LD_INT 30
 634: PUSH
 635: LD_INT 33
 637: PUSH
 638: EMPTY
 639: LIST
 640: LIST
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: PPUSH
 646: CALL_OW 69
 650: PUSH
 651: FOR_IN
 652: IFFALSE 716
// if GetNation ( i ) = 1 then
 654: LD_VAR 0 2
 658: PPUSH
 659: CALL_OW 248
 663: PUSH
 664: LD_INT 1
 666: EQUAL
 667: IFFALSE 683
// AddComPlaceWeapon ( i , us_double_laser ) else
 669: LD_VAR 0 2
 673: PPUSH
 674: LD_INT 10
 676: PPUSH
 677: CALL_OW 208
 681: GO 714
// AddComPlaceWeapon ( i , [ ru_rocket , ru_rocket_launcher ] [ Rand ( 1 , 2 ) ] ) ;
 683: LD_VAR 0 2
 687: PPUSH
 688: LD_INT 47
 690: PUSH
 691: LD_INT 45
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: PUSH
 698: LD_INT 1
 700: PPUSH
 701: LD_INT 2
 703: PPUSH
 704: CALL_OW 12
 708: ARRAY
 709: PPUSH
 710: CALL_OW 208
 714: GO 651
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 1
 722: RET
// export function PrepareLegion ; var i , un , skill , dep , fac ; begin
 723: LD_INT 0
 725: PPUSH
 726: PPUSH
 727: PPUSH
 728: PPUSH
 729: PPUSH
 730: PPUSH
// uc_side := 8 ;
 731: LD_ADDR_OWVAR 20
 735: PUSH
 736: LD_INT 8
 738: ST_TO_ADDR
// uc_nation := 2 ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_INT 2
 746: ST_TO_ADDR
// skill := [ 7 , 8 , 9 ] [ Difficulty ] ;
 747: LD_ADDR_VAR 0 4
 751: PUSH
 752: LD_INT 7
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 9
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: ST_TO_ADDR
// dep := ar_base ;
 772: LD_ADDR_VAR 0 5
 776: PUSH
 777: LD_INT 57
 779: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
 780: LD_ADDR_VAR 0 6
 784: PUSH
 785: LD_INT 22
 787: PUSH
 788: LD_INT 8
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: PPUSH
 809: CALL_OW 69
 813: PUSH
 814: LD_INT 1
 816: ARRAY
 817: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 999999 ) ;
 818: LD_VAR 0 5
 822: PPUSH
 823: CALL_OW 274
 827: PPUSH
 828: LD_INT 1
 830: PPUSH
 831: LD_INT 999999
 833: PPUSH
 834: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 10000 ) ;
 838: LD_VAR 0 5
 842: PPUSH
 843: CALL_OW 274
 847: PPUSH
 848: LD_INT 2
 850: PPUSH
 851: LD_INT 10000
 853: PPUSH
 854: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 10000 ) ;
 858: LD_VAR 0 5
 862: PPUSH
 863: CALL_OW 274
 867: PPUSH
 868: LD_INT 3
 870: PPUSH
 871: LD_INT 10000
 873: PPUSH
 874: CALL_OW 277
// TeleportExit ( legion_telep , 224 , 5 ) ;
 878: LD_INT 68
 880: PPUSH
 881: LD_INT 224
 883: PPUSH
 884: LD_INT 5
 886: PPUSH
 887: CALL_OW 243
// for i = 1 to 4 do
 891: LD_ADDR_VAR 0 2
 895: PUSH
 896: DOUBLE
 897: LD_INT 1
 899: DEC
 900: ST_TO_ADDR
 901: LD_INT 4
 903: PUSH
 904: FOR_TO
 905: IFFALSE 966
// begin PrepareHuman ( false , class_bazooker , skill ) ;
 907: LD_INT 0
 909: PPUSH
 910: LD_INT 9
 912: PPUSH
 913: LD_VAR 0 4
 917: PPUSH
 918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
 922: CALL_OW 44
 926: PPUSH
 927: LD_INT 22
 929: PUSH
 930: LD_INT 8
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 30
 939: PUSH
 940: LD_INT 5
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PPUSH
 951: CALL_OW 69
 955: PUSH
 956: LD_INT 1
 958: ARRAY
 959: PPUSH
 960: CALL_OW 52
// end ;
 964: GO 904
 966: POP
 967: POP
// for i = 1 to 2 do
 968: LD_ADDR_VAR 0 2
 972: PUSH
 973: DOUBLE
 974: LD_INT 1
 976: DEC
 977: ST_TO_ADDR
 978: LD_INT 2
 980: PUSH
 981: FOR_TO
 982: IFFALSE 1043
// begin PrepareHuman ( false , 4 , skill ) ;
 984: LD_INT 0
 986: PPUSH
 987: LD_INT 4
 989: PPUSH
 990: LD_VAR 0 4
 994: PPUSH
 995: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
 999: CALL_OW 44
1003: PPUSH
1004: LD_INT 22
1006: PUSH
1007: LD_INT 8
1009: PUSH
1010: EMPTY
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 30
1016: PUSH
1017: LD_INT 8
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL_OW 69
1032: PUSH
1033: LD_INT 1
1035: ARRAY
1036: PPUSH
1037: CALL_OW 52
// end ;
1041: GO 981
1043: POP
1044: POP
// for i = 1 to 6 do
1045: LD_ADDR_VAR 0 2
1049: PUSH
1050: DOUBLE
1051: LD_INT 1
1053: DEC
1054: ST_TO_ADDR
1055: LD_INT 6
1057: PUSH
1058: FOR_TO
1059: IFFALSE 1096
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
1061: LD_INT 0
1063: PPUSH
1064: LD_INT 3
1066: PPUSH
1067: LD_VAR 0 4
1071: PUSH
1072: LD_INT 1
1074: PLUS
1075: PPUSH
1076: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac ) ;
1080: CALL_OW 44
1084: PPUSH
1085: LD_VAR 0 6
1089: PPUSH
1090: CALL_OW 52
// end ;
1094: GO 1058
1096: POP
1097: POP
// uc_nation := 0 ;
1098: LD_ADDR_OWVAR 21
1102: PUSH
1103: LD_INT 0
1105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_bunker ] ] ) do
1106: LD_ADDR_VAR 0 2
1110: PUSH
1111: LD_INT 22
1113: PUSH
1114: LD_INT 8
1116: PUSH
1117: EMPTY
1118: LIST
1119: LIST
1120: PUSH
1121: LD_INT 30
1123: PUSH
1124: LD_INT 32
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: PPUSH
1135: CALL_OW 69
1139: PUSH
1140: FOR_IN
1141: IFFALSE 1178
// begin PrepareHuman ( false , class_apeman_soldier , skill + 1 ) ;
1143: LD_INT 0
1145: PPUSH
1146: LD_INT 15
1148: PPUSH
1149: LD_VAR 0 4
1153: PUSH
1154: LD_INT 1
1156: PLUS
1157: PPUSH
1158: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
1162: CALL_OW 44
1166: PPUSH
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 52
// end ;
1176: GO 1140
1178: POP
1179: POP
// for i = 1 to 2 do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: DOUBLE
1186: LD_INT 1
1188: DEC
1189: ST_TO_ADDR
1190: LD_INT 2
1192: PUSH
1193: FOR_TO
1194: IFFALSE 1219
// AddComConstruct ( fac , ar_half_tracked , engine_solar , control_manual , ar_control_tower ) ;
1196: LD_VAR 0 6
1200: PPUSH
1201: LD_INT 14
1203: PPUSH
1204: LD_INT 2
1206: PPUSH
1207: LD_INT 1
1209: PPUSH
1210: LD_INT 31
1212: PPUSH
1213: CALL_OW 185
1217: GO 1193
1219: POP
1220: POP
// end ;
1221: LD_VAR 0 1
1225: RET
// export function PrepareHovercraft ( num ) ; var i ; begin
1226: LD_INT 0
1228: PPUSH
1229: PPUSH
// for i = 1 to num do
1230: LD_ADDR_VAR 0 3
1234: PUSH
1235: DOUBLE
1236: LD_INT 1
1238: DEC
1239: ST_TO_ADDR
1240: LD_VAR 0 1
1244: PUSH
1245: FOR_TO
1246: IFFALSE 1318
// AddComConstruct ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] , ar_hovercraft , engine_combustion , control_remote , [ ar_light_gun , ar_double_machine_gun ] [ rand ( 1 , 2 ) ] ) ;
1248: LD_INT 22
1250: PUSH
1251: LD_INT 8
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 30
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: PPUSH
1272: CALL_OW 69
1276: PUSH
1277: LD_INT 1
1279: ARRAY
1280: PPUSH
1281: LD_INT 11
1283: PPUSH
1284: LD_INT 1
1286: PPUSH
1287: LD_INT 2
1289: PPUSH
1290: LD_INT 23
1292: PUSH
1293: LD_INT 24
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: LD_INT 1
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: CALL_OW 12
1310: ARRAY
1311: PPUSH
1312: CALL_OW 185
1316: GO 1245
1318: POP
1319: POP
// end ;
1320: LD_VAR 0 2
1324: RET
// export function AddKamikaze ( ) ; var i , un ; begin
1325: LD_INT 0
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side := 8 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 8
1337: ST_TO_ADDR
// uc_nation := 0 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 0
1345: ST_TO_ADDR
// hc_class := 17 ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 17
1353: ST_TO_ADDR
// hc_gallery :=  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_name :=  ;
1362: LD_ADDR_OWVAR 26
1366: PUSH
1367: LD_STRING 
1369: ST_TO_ADDR
// hc_importance := 0 ;
1370: LD_ADDR_OWVAR 32
1374: PUSH
1375: LD_INT 0
1377: ST_TO_ADDR
// hc_skills := [ 10 , 10 , 10 , 10 ] ;
1378: LD_ADDR_OWVAR 31
1382: PUSH
1383: LD_INT 10
1385: PUSH
1386: LD_INT 10
1388: PUSH
1389: LD_INT 10
1391: PUSH
1392: LD_INT 10
1394: PUSH
1395: EMPTY
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: ST_TO_ADDR
// if ar_base then
1401: LD_INT 57
1403: IFFALSE 1448
// begin un := CreateHuman ;
1405: LD_ADDR_VAR 0 3
1409: PUSH
1410: CALL_OW 44
1414: ST_TO_ADDR
// PlaceHumanInUnit ( un , ar_base ) ;
1415: LD_VAR 0 3
1419: PPUSH
1420: LD_INT 57
1422: PPUSH
1423: CALL_OW 52
// ComExitBuilding ( un ) ;
1427: LD_VAR 0 3
1431: PPUSH
1432: CALL_OW 122
// AddComEnterUnit ( un , legion_telep ) ;
1436: LD_VAR 0 3
1440: PPUSH
1441: LD_INT 68
1443: PPUSH
1444: CALL_OW 180
// end ; end ;
1448: LD_VAR 0 1
1452: RET
// export legion_force ; export function PrepareAttack ( n1 , n2 ) ; var i ; begin
1453: LD_INT 0
1455: PPUSH
1456: PPUSH
// legion_force := [ ] ;
1457: LD_ADDR_EXP 1
1461: PUSH
1462: EMPTY
1463: ST_TO_ADDR
// PrepareHovercraft ( n1 ) ;
1464: LD_VAR 0 1
1468: PPUSH
1469: CALL 1226 0 1
// for i = 1 to n2 do
1473: LD_ADDR_VAR 0 4
1477: PUSH
1478: DOUBLE
1479: LD_INT 1
1481: DEC
1482: ST_TO_ADDR
1483: LD_VAR 0 2
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1497
// begin AddKamikaze ( ) ;
1491: CALL 1325 0 0
// end ;
1495: GO 1488
1497: POP
1498: POP
// end ;
1499: LD_VAR 0 3
1503: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) > 1 do
1504: LD_INT 22
1506: PUSH
1507: LD_INT 6
1509: PUSH
1510: EMPTY
1511: LIST
1512: LIST
1513: PUSH
1514: LD_INT 21
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: PPUSH
1528: CALL_OW 69
1532: PUSH
1533: LD_INT 1
1535: GREATER
1536: IFFALSE 1558
1538: GO 1540
1540: DISABLE
// begin wait ( 3 3$00 ) ;
1541: LD_INT 6300
1543: PPUSH
1544: CALL_OW 67
// PrepareAttack ( 4 , 2 ) ;
1548: LD_INT 4
1550: PPUSH
1551: LD_INT 2
1553: PPUSH
1554: CALL 1453 0 2
// end ;
1558: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] ] ) do var i , j , cts , vehs , best , best_mechanic , p ;
1559: LD_INT 22
1561: PUSH
1562: LD_INT 8
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 33
1571: PUSH
1572: LD_INT 2
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: PUSH
1579: EMPTY
1580: LIST
1581: LIST
1582: PPUSH
1583: CALL_OW 69
1587: IFFALSE 1799
1589: GO 1591
1591: DISABLE
1592: LD_INT 0
1594: PPUSH
1595: PPUSH
1596: PPUSH
1597: PPUSH
1598: PPUSH
1599: PPUSH
1600: PPUSH
// begin enable ;
1601: ENABLE
// vehs := FilterAllUnits ( [ [ f_side , 8 ] , [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
1602: LD_ADDR_VAR 0 4
1606: PUSH
1607: LD_INT 22
1609: PUSH
1610: LD_INT 8
1612: PUSH
1613: EMPTY
1614: LIST
1615: LIST
1616: PUSH
1617: LD_INT 33
1619: PUSH
1620: LD_INT 2
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 3
1629: PUSH
1630: LD_INT 61
1632: PUSH
1633: EMPTY
1634: LIST
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: PUSH
1640: EMPTY
1641: LIST
1642: LIST
1643: LIST
1644: PPUSH
1645: CALL_OW 69
1649: ST_TO_ADDR
// cts := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_control_tower ] ] ) ;
1650: LD_ADDR_VAR 0 3
1654: PUSH
1655: LD_INT 22
1657: PUSH
1658: LD_INT 8
1660: PUSH
1661: EMPTY
1662: LIST
1663: LIST
1664: PUSH
1665: LD_INT 34
1667: PUSH
1668: LD_INT 31
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: PUSH
1675: EMPTY
1676: LIST
1677: LIST
1678: PPUSH
1679: CALL_OW 69
1683: ST_TO_ADDR
// best := 10 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10
1691: ST_TO_ADDR
// best_mechanic := - 1 ;
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: LD_INT 1
1699: NEG
1700: ST_TO_ADDR
// if vehs then
1701: LD_VAR 0 4
1705: IFFALSE 1799
// begin for j in cts do
1707: LD_ADDR_VAR 0 2
1711: PUSH
1712: LD_VAR 0 3
1716: PUSH
1717: FOR_IN
1718: IFFALSE 1779
// begin p := UnitsLinked ( GetDriver ( j ) ) ;
1720: LD_ADDR_VAR 0 7
1724: PUSH
1725: LD_VAR 0 2
1729: PPUSH
1730: CALL 3204 0 1
1734: PPUSH
1735: CALL_OW 432
1739: ST_TO_ADDR
// if p < best then
1740: LD_VAR 0 7
1744: PUSH
1745: LD_VAR 0 5
1749: LESS
1750: IFFALSE 1777
// begin best := p ;
1752: LD_ADDR_VAR 0 5
1756: PUSH
1757: LD_VAR 0 7
1761: ST_TO_ADDR
// best_mechanic := GetDriver ( j ) ;
1762: LD_ADDR_VAR 0 6
1766: PUSH
1767: LD_VAR 0 2
1771: PPUSH
1772: CALL 3204 0 1
1776: ST_TO_ADDR
// end ; end ;
1777: GO 1717
1779: POP
1780: POP
// ComLinkTo ( vehs [ 1 ] , best_mechanic ) ;
1781: LD_VAR 0 4
1785: PUSH
1786: LD_INT 1
1788: ARRAY
1789: PPUSH
1790: LD_VAR 0 6
1794: PPUSH
1795: CALL_OW 135
// end ; end ; end_of_file
1799: PPOPN 7
1801: END
// export Davidov ; export function PrepareRussian ; var i , skill , un , tmp , amount , k ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
1808: PPUSH
1809: PPUSH
1810: PPUSH
// uc_side := 6 ;
1811: LD_ADDR_OWVAR 20
1815: PUSH
1816: LD_INT 6
1818: ST_TO_ADDR
// uc_nation := nation_russian ;
1819: LD_ADDR_OWVAR 21
1823: PUSH
1824: LD_INT 3
1826: ST_TO_ADDR
// amount := [ [ 8 , 4 ] , [ 7 , 3 ] , [ 6 , 2 ] ] [ Difficulty ] ;
1827: LD_ADDR_VAR 0 6
1831: PUSH
1832: LD_INT 8
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 7
1844: PUSH
1845: LD_INT 3
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: PUSH
1852: LD_INT 6
1854: PUSH
1855: LD_INT 2
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: PUSH
1862: EMPTY
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_OWVAR 67
1871: ARRAY
1872: ST_TO_ADDR
// skill := [ 9 , 7 , 6 ] [ Difficulty ] ;
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: LD_INT 9
1880: PUSH
1881: LD_INT 7
1883: PUSH
1884: LD_INT 6
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_OWVAR 67
1896: ARRAY
1897: ST_TO_ADDR
// tmp := [ ] ;
1898: LD_ADDR_VAR 0 5
1902: PUSH
1903: EMPTY
1904: ST_TO_ADDR
// Davidov := NewCharacter ( Davidov ) ;
1905: LD_ADDR_EXP 2
1909: PUSH
1910: LD_STRING Davidov
1912: PPUSH
1913: CALL_OW 25
1917: ST_TO_ADDR
// SetSkill ( Davidov , 1 , 7 ) ;
1918: LD_EXP 2
1922: PPUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_INT 7
1928: PPUSH
1929: CALL_OW 237
// SetSkill ( Davidov , 2 , 8 ) ;
1933: LD_EXP 2
1937: PPUSH
1938: LD_INT 2
1940: PPUSH
1941: LD_INT 8
1943: PPUSH
1944: CALL_OW 237
// SetSkill ( Davidov , 3 , 6 ) ;
1948: LD_EXP 2
1952: PPUSH
1953: LD_INT 3
1955: PPUSH
1956: LD_INT 6
1958: PPUSH
1959: CALL_OW 237
// SetSkill ( Davidov , 4 , 10 ) ;
1963: LD_EXP 2
1967: PPUSH
1968: LD_INT 4
1970: PPUSH
1971: LD_INT 10
1973: PPUSH
1974: CALL_OW 237
// SetClass ( Davidov , 4 ) ;
1978: LD_EXP 2
1982: PPUSH
1983: LD_INT 4
1985: PPUSH
1986: CALL_OW 336
// hc_importance := 0 ;
1990: LD_ADDR_OWVAR 32
1994: PUSH
1995: LD_INT 0
1997: ST_TO_ADDR
// while amount [ 1 ] do
1998: LD_VAR 0 6
2002: PUSH
2003: LD_INT 1
2005: ARRAY
2006: IFFALSE 2339
// begin Wait ( 1 ) ;
2008: LD_INT 1
2010: PPUSH
2011: CALL_OW 67
// k := rand ( 2 , 4 ) ;
2015: LD_ADDR_VAR 0 7
2019: PUSH
2020: LD_INT 2
2022: PPUSH
2023: LD_INT 4
2025: PPUSH
2026: CALL_OW 12
2030: ST_TO_ADDR
// if amount [ 2 ] and tmp then
2031: LD_VAR 0 6
2035: PUSH
2036: LD_INT 2
2038: ARRAY
2039: PUSH
2040: LD_VAR 0 5
2044: AND
2045: IFFALSE 2200
// begin if k in [ 1 , 2 ] then
2047: LD_VAR 0 7
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 2
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: IN
2062: IFFALSE 2072
// k := 3 ;
2064: LD_ADDR_VAR 0 7
2068: PUSH
2069: LD_INT 3
2071: ST_TO_ADDR
// vc_chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
2072: LD_ADDR_OWVAR 37
2076: PUSH
2077: LD_INT 22
2079: PUSH
2080: LD_INT 24
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: PUSH
2087: LD_INT 1
2089: PPUSH
2090: LD_INT 2
2092: PPUSH
2093: CALL_OW 12
2097: ARRAY
2098: ST_TO_ADDR
// vc_engine := engine_siberite ;
2099: LD_ADDR_OWVAR 39
2103: PUSH
2104: LD_INT 3
2106: ST_TO_ADDR
// vc_control := control_manual ;
2107: LD_ADDR_OWVAR 38
2111: PUSH
2112: LD_INT 1
2114: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_rocket_launcher , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ;
2115: LD_ADDR_OWVAR 40
2119: PUSH
2120: LD_INT 44
2122: PUSH
2123: LD_INT 45
2125: PUSH
2126: LD_INT 43
2128: PUSH
2129: EMPTY
2130: LIST
2131: LIST
2132: LIST
2133: PUSH
2134: LD_INT 1
2136: PPUSH
2137: LD_INT 3
2139: PPUSH
2140: CALL_OW 12
2144: ARRAY
2145: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , CreateVehicle ) ;
2146: LD_ADDR_VAR 0 5
2150: PUSH
2151: LD_VAR 0 5
2155: PPUSH
2156: LD_INT 1
2158: PPUSH
2159: CALL_OW 45
2163: PPUSH
2164: CALL_OW 2
2168: ST_TO_ADDR
// amount := Replace ( amount , 2 , amount [ 2 ] - 1 ) ;
2169: LD_ADDR_VAR 0 6
2173: PUSH
2174: LD_VAR 0 6
2178: PPUSH
2179: LD_INT 2
2181: PPUSH
2182: LD_VAR 0 6
2186: PUSH
2187: LD_INT 2
2189: ARRAY
2190: PUSH
2191: LD_INT 1
2193: MINUS
2194: PPUSH
2195: CALL_OW 1
2199: ST_TO_ADDR
// end ; if not tmp then
2200: LD_VAR 0 5
2204: NOT
2205: IFFALSE 2215
// k := 2 ;
2207: LD_ADDR_VAR 0 7
2211: PUSH
2212: LD_INT 2
2214: ST_TO_ADDR
// if amount [ 2 ] = 0 and k = 3 then
2215: LD_VAR 0 6
2219: PUSH
2220: LD_INT 2
2222: ARRAY
2223: PUSH
2224: LD_INT 0
2226: EQUAL
2227: PUSH
2228: LD_VAR 0 7
2232: PUSH
2233: LD_INT 3
2235: EQUAL
2236: AND
2237: IFFALSE 2266
// k := [ class_bazooker , class_scientistic ] [ rand ( 1 , 2 ) ] ;
2239: LD_ADDR_VAR 0 7
2243: PUSH
2244: LD_INT 9
2246: PUSH
2247: LD_INT 4
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: PUSH
2254: LD_INT 1
2256: PPUSH
2257: LD_INT 2
2259: PPUSH
2260: CALL_OW 12
2264: ARRAY
2265: ST_TO_ADDR
// PrepareHuman ( false , k , skill ) ;
2266: LD_INT 0
2268: PPUSH
2269: LD_VAR 0 7
2273: PPUSH
2274: LD_VAR 0 3
2278: PPUSH
2279: CALL_OW 380
// tmp := Insert ( tmp , 1 , CreateHuman ) ;
2283: LD_ADDR_VAR 0 5
2287: PUSH
2288: LD_VAR 0 5
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: CALL_OW 44
2300: PPUSH
2301: CALL_OW 2
2305: ST_TO_ADDR
// amount := Replace ( amount , 1 , amount [ 1 ] - 1 ) ;
2306: LD_ADDR_VAR 0 6
2310: PUSH
2311: LD_VAR 0 6
2315: PPUSH
2316: LD_INT 1
2318: PPUSH
2319: LD_VAR 0 6
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PUSH
2328: LD_INT 1
2330: MINUS
2331: PPUSH
2332: CALL_OW 1
2336: ST_TO_ADDR
// end ;
2337: GO 1998
// tmp := Insert ( tmp , tmp + 1 , Davidov ) ;
2339: LD_ADDR_VAR 0 5
2343: PUSH
2344: LD_VAR 0 5
2348: PPUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_INT 1
2356: PLUS
2357: PPUSH
2358: LD_EXP 2
2362: PPUSH
2363: CALL_OW 2
2367: ST_TO_ADDR
// for i = tmp downto 1 do
2368: LD_ADDR_VAR 0 2
2372: PUSH
2373: DOUBLE
2374: LD_VAR 0 5
2378: INC
2379: ST_TO_ADDR
2380: LD_INT 1
2382: PUSH
2383: FOR_DOWNTO
2384: IFFALSE 2546
// begin if GetType ( tmp [ i ] ) = unit_vehicle then
2386: LD_VAR 0 5
2390: PUSH
2391: LD_VAR 0 2
2395: ARRAY
2396: PPUSH
2397: CALL_OW 247
2401: PUSH
2402: LD_INT 2
2404: EQUAL
2405: IFFALSE 2495
// begin SetDir ( tmp [ i ] , 3 ) ;
2407: LD_VAR 0 5
2411: PUSH
2412: LD_VAR 0 2
2416: ARRAY
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitXY ( tmp [ i ] , 193 , 3 , false ) ;
2425: LD_VAR 0 5
2429: PUSH
2430: LD_VAR 0 2
2434: ARRAY
2435: PPUSH
2436: LD_INT 193
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: LD_INT 0
2444: PPUSH
2445: CALL_OW 48
// PlaceHumanInUnit ( tmp [ i - 1 ] , tmp [ i ] ) ;
2449: LD_VAR 0 5
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: LD_INT 1
2461: MINUS
2462: ARRAY
2463: PPUSH
2464: LD_VAR 0 5
2468: PUSH
2469: LD_VAR 0 2
2473: ARRAY
2474: PPUSH
2475: CALL_OW 52
// i := i - 1 ;
2479: LD_ADDR_VAR 0 2
2483: PUSH
2484: LD_VAR 0 2
2488: PUSH
2489: LD_INT 1
2491: MINUS
2492: ST_TO_ADDR
// end else
2493: GO 2516
// PlaceUnitArea ( tmp [ i ] , start_area , false ) ;
2495: LD_VAR 0 5
2499: PUSH
2500: LD_VAR 0 2
2504: ARRAY
2505: PPUSH
2506: LD_INT 2
2508: PPUSH
2509: LD_INT 0
2511: PPUSH
2512: CALL_OW 49
// ComMoveXY ( tmp [ i ] , 197 , 22 ) ;
2516: LD_VAR 0 5
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PPUSH
2527: LD_INT 197
2529: PPUSH
2530: LD_INT 22
2532: PPUSH
2533: CALL_OW 111
// Wait ( 0 0$02 ) ;
2537: LD_INT 70
2539: PPUSH
2540: CALL_OW 67
// end ;
2544: GO 2383
2546: POP
2547: POP
// end ; end_of_file
2548: LD_VAR 0 1
2552: RET
// on VehicleConstructed ( veh , fac ) do var side ;
2553: LD_INT 0
2555: PPUSH
// begin side := GetSide ( fac ) ;
2556: LD_ADDR_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: PPUSH
2566: CALL_OW 255
2570: ST_TO_ADDR
// case side of 8 :
2571: LD_VAR 0 3
2575: PUSH
2576: LD_INT 8
2578: DOUBLE
2579: EQUAL
2580: IFTRUE 2584
2582: GO 2655
2584: POP
// begin if GetWeapon ( veh ) = ar_control_tower then
2585: LD_VAR 0 1
2589: PPUSH
2590: CALL_OW 264
2594: PUSH
2595: LD_INT 31
2597: EQUAL
2598: IFFALSE 2615
// ComMoveXY ( veh , 145 , 66 ) ;
2600: LD_VAR 0 1
2604: PPUSH
2605: LD_INT 145
2607: PPUSH
2608: LD_INT 66
2610: PPUSH
2611: CALL_OW 111
// if GetChassis ( veh ) = ar_hovercraft then
2615: LD_VAR 0 1
2619: PPUSH
2620: CALL_OW 265
2624: PUSH
2625: LD_INT 11
2627: EQUAL
2628: IFFALSE 2653
// legion_force := Insert ( legion_force , 1 , veh ) ;
2630: LD_ADDR_EXP 1
2634: PUSH
2635: LD_EXP 1
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 2
2652: ST_TO_ADDR
// end ; end ;
2653: GO 2656
2655: POP
// end ;
2656: PPOPN 3
2658: END
// on UnitTeleported ( b , un ) do begin if b = legion_telep and GetClass ( un ) = 17 then
2659: LD_VAR 0 1
2663: PUSH
2664: LD_INT 68
2666: EQUAL
2667: PUSH
2668: LD_VAR 0 2
2672: PPUSH
2673: CALL_OW 257
2677: PUSH
2678: LD_INT 17
2680: EQUAL
2681: AND
2682: IFFALSE 2725
// begin Wait ( 0 0$03 ) ;
2684: LD_INT 105
2686: PPUSH
2687: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 6 ] ) , un ) ) ;
2691: LD_VAR 0 2
2695: PPUSH
2696: LD_INT 22
2698: PUSH
2699: LD_INT 6
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: PPUSH
2706: CALL_OW 69
2710: PPUSH
2711: LD_VAR 0 2
2715: PPUSH
2716: CALL_OW 74
2720: PPUSH
2721: CALL_OW 115
// end ; end ;
2725: PPOPN 2
2727: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
2728: LD_VAR 0 1
2732: PUSH
2733: LD_EXP 3
2737: IN
2738: NOT
2739: IFFALSE 2770
// unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
2741: LD_ADDR_EXP 3
2745: PUSH
2746: LD_EXP 3
2750: PPUSH
2751: LD_EXP 3
2755: PUSH
2756: LD_INT 1
2758: PLUS
2759: PPUSH
2760: LD_VAR 0 1
2764: PPUSH
2765: CALL_OW 2
2769: ST_TO_ADDR
// end ;
2770: PPOPN 1
2772: END
// on CrateSpawn ( id , x , y , amount , mode ) do var i , apes , n ;
2773: LD_INT 0
2775: PPUSH
2776: PPUSH
2777: PPUSH
// begin if InArea ( x , y , cratesArea ) then
2778: LD_VAR 0 2
2782: PPUSH
2783: LD_VAR 0 3
2787: PPUSH
2788: LD_INT 3
2790: PPUSH
2791: CALL_OW 309
2795: IFFALSE 3004
// begin apes := FilterAllUnits ( [ [ f_side , 6 ] , [ f_class , 16 ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_hastask ] ] ] ) ;
2797: LD_ADDR_VAR 0 7
2801: PUSH
2802: LD_INT 22
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: PUSH
2812: LD_INT 25
2814: PUSH
2815: LD_INT 16
2817: PUSH
2818: EMPTY
2819: LIST
2820: LIST
2821: PUSH
2822: LD_INT 3
2824: PUSH
2825: LD_INT 54
2827: PUSH
2828: EMPTY
2829: LIST
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: LD_INT 3
2837: PUSH
2838: LD_INT 60
2840: PUSH
2841: EMPTY
2842: LIST
2843: PUSH
2844: EMPTY
2845: LIST
2846: LIST
2847: PUSH
2848: EMPTY
2849: LIST
2850: LIST
2851: LIST
2852: LIST
2853: PPUSH
2854: CALL_OW 69
2858: ST_TO_ADDR
// if apes = 0 or FilterAllUnits ( [ [ f_side , 6 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 then
2859: LD_VAR 0 7
2863: PUSH
2864: LD_INT 0
2866: EQUAL
2867: PUSH
2868: LD_INT 22
2870: PUSH
2871: LD_INT 6
2873: PUSH
2874: EMPTY
2875: LIST
2876: LIST
2877: PUSH
2878: LD_INT 2
2880: PUSH
2881: LD_INT 30
2883: PUSH
2884: LD_INT 0
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PUSH
2891: LD_INT 30
2893: PUSH
2894: LD_INT 1
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: EMPTY
2907: LIST
2908: LIST
2909: PPUSH
2910: CALL_OW 69
2914: PUSH
2915: LD_INT 0
2917: EQUAL
2918: OR
2919: IFFALSE 2923
// exit ;
2921: GO 3004
// if apes < amount then
2923: LD_VAR 0 7
2927: PUSH
2928: LD_VAR 0 4
2932: LESS
2933: IFFALSE 2947
// n := apes else
2935: LD_ADDR_VAR 0 8
2939: PUSH
2940: LD_VAR 0 7
2944: ST_TO_ADDR
2945: GO 2957
// n := amount ;
2947: LD_ADDR_VAR 0 8
2951: PUSH
2952: LD_VAR 0 4
2956: ST_TO_ADDR
// for i = 1 to n do
2957: LD_ADDR_VAR 0 6
2961: PUSH
2962: DOUBLE
2963: LD_INT 1
2965: DEC
2966: ST_TO_ADDR
2967: LD_VAR 0 8
2971: PUSH
2972: FOR_TO
2973: IFFALSE 3002
// AddComCollect ( apes [ i ] , x , y ) ;
2975: LD_VAR 0 7
2979: PUSH
2980: LD_VAR 0 6
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PPUSH
2991: LD_VAR 0 3
2995: PPUSH
2996: CALL_OW 177
3000: GO 2972
3002: POP
3003: POP
// end ; end ;
3004: PPOPN 8
3006: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 8 and un in FilterAllUnits ( [ [ f_control , control_remote ] , [ f_type , unit_vehicle ] ] ) then
3007: LD_VAR 0 1
3011: PPUSH
3012: CALL_OW 255
3016: PUSH
3017: LD_INT 8
3019: EQUAL
3020: PUSH
3021: LD_VAR 0 1
3025: PUSH
3026: LD_INT 33
3028: PUSH
3029: LD_INT 2
3031: PUSH
3032: EMPTY
3033: LIST
3034: LIST
3035: PUSH
3036: LD_INT 21
3038: PUSH
3039: LD_INT 2
3041: PUSH
3042: EMPTY
3043: LIST
3044: LIST
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: PPUSH
3050: CALL_OW 69
3054: IN
3055: AND
3056: IFFALSE 3177
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 8 then
3058: LD_OWVAR 3
3062: PUSH
3063: LD_VAR 0 1
3067: DIFF
3068: PPUSH
3069: LD_VAR 0 1
3073: PPUSH
3074: CALL_OW 74
3078: PPUSH
3079: CALL_OW 255
3083: PUSH
3084: LD_INT 8
3086: NONEQUAL
3087: IFFALSE 3177
// begin Wait ( 0 0$1.3 ) ;
3089: LD_INT 46
3091: PPUSH
3092: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
3096: LD_VAR 0 1
3100: PPUSH
3101: CALL_OW 250
3105: PPUSH
3106: LD_VAR 0 1
3110: PPUSH
3111: CALL_OW 251
3115: PPUSH
3116: LD_INT 1
3118: PPUSH
3119: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
3123: LD_VAR 0 1
3127: PPUSH
3128: CALL_OW 250
3132: PPUSH
3133: LD_VAR 0 1
3137: PPUSH
3138: CALL_OW 251
3142: PPUSH
3143: LD_INT 1
3145: PPUSH
3146: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 250
3159: PPUSH
3160: LD_VAR 0 1
3164: PPUSH
3165: CALL_OW 251
3169: PPUSH
3170: LD_INT 1
3172: PPUSH
3173: CALL_OW 453
// end ; if GetControl ( un ) = control_remote then
3177: LD_VAR 0 1
3181: PPUSH
3182: CALL_OW 263
3186: PUSH
3187: LD_INT 2
3189: EQUAL
3190: IFFALSE 3201
// ComUnlink ( un ) ;
3192: LD_VAR 0 1
3196: PPUSH
3197: CALL_OW 136
// end ; end_of_file
3201: PPOPN 1
3203: END
// export function GetDriver ( veh ) ; var i , filter ; begin
3204: LD_INT 0
3206: PPUSH
3207: PPUSH
3208: PPUSH
// if not GetControl ( veh ) = control_manual then
3209: LD_VAR 0 1
3213: PPUSH
3214: CALL_OW 263
3218: PUSH
3219: LD_INT 1
3221: EQUAL
3222: NOT
3223: IFFALSE 3235
// result := false else
3225: LD_ADDR_VAR 0 2
3229: PUSH
3230: LD_INT 0
3232: ST_TO_ADDR
3233: GO 3380
// if veh in FilterAllUnits ( [ f_empty ] ) then
3235: LD_VAR 0 1
3239: PUSH
3240: LD_INT 58
3242: PUSH
3243: EMPTY
3244: LIST
3245: PPUSH
3246: CALL_OW 69
3250: IN
3251: IFFALSE 3263
// result := false else
3253: LD_ADDR_VAR 0 2
3257: PUSH
3258: LD_INT 0
3260: ST_TO_ADDR
3261: GO 3380
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: LD_INT 22
3270: PUSH
3271: LD_VAR 0 1
3275: PPUSH
3276: CALL_OW 255
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: PUSH
3285: LD_INT 55
3287: PUSH
3288: EMPTY
3289: LIST
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: PPUSH
3295: CALL_OW 69
3299: ST_TO_ADDR
// if not filter then
3300: LD_VAR 0 4
3304: NOT
3305: IFFALSE 3317
// result := false else
3307: LD_ADDR_VAR 0 2
3311: PUSH
3312: LD_INT 0
3314: ST_TO_ADDR
3315: GO 3380
// for i = 1 to filter do
3317: LD_ADDR_VAR 0 3
3321: PUSH
3322: DOUBLE
3323: LD_INT 1
3325: DEC
3326: ST_TO_ADDR
3327: LD_VAR 0 4
3331: PUSH
3332: FOR_TO
3333: IFFALSE 3378
// if IsDriver ( filter [ i ] ) = veh then
3335: LD_VAR 0 4
3339: PUSH
3340: LD_VAR 0 3
3344: ARRAY
3345: PPUSH
3346: CALL 3385 0 1
3350: PUSH
3351: LD_VAR 0 1
3355: EQUAL
3356: IFFALSE 3376
// begin result := filter [ i ] ;
3358: LD_ADDR_VAR 0 2
3362: PUSH
3363: LD_VAR 0 4
3367: PUSH
3368: LD_VAR 0 3
3372: ARRAY
3373: ST_TO_ADDR
// break ;
3374: GO 3378
// end ;
3376: GO 3332
3378: POP
3379: POP
// end ; end ;
3380: LD_VAR 0 2
3384: RET
// export function IsDriver ( unit ) ; begin
3385: LD_INT 0
3387: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
3388: LD_VAR 0 1
3392: PUSH
3393: LD_INT 55
3395: PUSH
3396: EMPTY
3397: LIST
3398: PPUSH
3399: CALL_OW 69
3403: IN
3404: IFFALSE 3423
// result := IsInUnit ( unit ) else
3406: LD_ADDR_VAR 0 2
3410: PUSH
3411: LD_VAR 0 1
3415: PPUSH
3416: CALL_OW 310
3420: ST_TO_ADDR
3421: GO 3431
// result := false ;
3423: LD_ADDR_VAR 0 2
3427: PUSH
3428: LD_INT 0
3430: ST_TO_ADDR
// end ;
3431: LD_VAR 0 2
3435: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
3436: LD_INT 0
3438: PPUSH
3439: PPUSH
3440: PPUSH
3441: PPUSH
// if pos < 1 then
3442: LD_VAR 0 2
3446: PUSH
3447: LD_INT 1
3449: LESS
3450: IFFALSE 3454
// exit ;
3452: GO 3757
// if pos = 1 then
3454: LD_VAR 0 2
3458: PUSH
3459: LD_INT 1
3461: EQUAL
3462: IFFALSE 3495
// result := Replace ( arr , pos [ 1 ] , value ) else
3464: LD_ADDR_VAR 0 4
3468: PUSH
3469: LD_VAR 0 1
3473: PPUSH
3474: LD_VAR 0 2
3478: PUSH
3479: LD_INT 1
3481: ARRAY
3482: PPUSH
3483: LD_VAR 0 3
3487: PPUSH
3488: CALL_OW 1
3492: ST_TO_ADDR
3493: GO 3757
// begin tmp := arr ;
3495: LD_ADDR_VAR 0 6
3499: PUSH
3500: LD_VAR 0 1
3504: ST_TO_ADDR
// s_arr := [ tmp ] ;
3505: LD_ADDR_VAR 0 7
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: EMPTY
3516: LIST
3517: ST_TO_ADDR
// for i = 1 to pos - 1 do
3518: LD_ADDR_VAR 0 5
3522: PUSH
3523: DOUBLE
3524: LD_INT 1
3526: DEC
3527: ST_TO_ADDR
3528: LD_VAR 0 2
3532: PUSH
3533: LD_INT 1
3535: MINUS
3536: PUSH
3537: FOR_TO
3538: IFFALSE 3583
// begin tmp := tmp [ pos [ i ] ] ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_VAR 0 2
3554: PUSH
3555: LD_VAR 0 5
3559: ARRAY
3560: ARRAY
3561: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
3562: LD_ADDR_VAR 0 7
3566: PUSH
3567: LD_VAR 0 7
3571: PUSH
3572: LD_VAR 0 6
3576: PUSH
3577: EMPTY
3578: LIST
3579: ADD
3580: ST_TO_ADDR
// end ;
3581: GO 3537
3583: POP
3584: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PPUSH
3595: LD_VAR 0 2
3599: PUSH
3600: LD_VAR 0 2
3604: ARRAY
3605: PPUSH
3606: LD_VAR 0 3
3610: PPUSH
3611: CALL_OW 1
3615: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
3616: LD_ADDR_VAR 0 7
3620: PUSH
3621: LD_VAR 0 7
3625: PPUSH
3626: LD_VAR 0 7
3630: PPUSH
3631: LD_VAR 0 6
3635: PPUSH
3636: CALL_OW 1
3640: ST_TO_ADDR
// for i = s_arr downto 2 do
3641: LD_ADDR_VAR 0 5
3645: PUSH
3646: DOUBLE
3647: LD_VAR 0 7
3651: INC
3652: ST_TO_ADDR
3653: LD_INT 2
3655: PUSH
3656: FOR_DOWNTO
3657: IFFALSE 3741
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
3659: LD_ADDR_VAR 0 6
3663: PUSH
3664: LD_VAR 0 7
3668: PUSH
3669: LD_VAR 0 5
3673: PUSH
3674: LD_INT 1
3676: MINUS
3677: ARRAY
3678: PPUSH
3679: LD_VAR 0 2
3683: PUSH
3684: LD_VAR 0 5
3688: PUSH
3689: LD_INT 1
3691: MINUS
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 7
3698: PUSH
3699: LD_VAR 0 5
3703: ARRAY
3704: PPUSH
3705: CALL_OW 1
3709: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
3710: LD_ADDR_VAR 0 7
3714: PUSH
3715: LD_VAR 0 7
3719: PPUSH
3720: LD_VAR 0 5
3724: PUSH
3725: LD_INT 1
3727: MINUS
3728: PPUSH
3729: LD_VAR 0 6
3733: PPUSH
3734: CALL_OW 1
3738: ST_TO_ADDR
// end ;
3739: GO 3656
3741: POP
3742: POP
// result := s_arr [ 1 ] ;
3743: LD_ADDR_VAR 0 4
3747: PUSH
3748: LD_VAR 0 7
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// end ; end ;
3757: LD_VAR 0 4
3761: RET
// export function DestinationReachable ( unit , x , y ) ; begin
3762: LD_INT 0
3764: PPUSH
// if unit in unreachableList then
3765: LD_VAR 0 1
3769: PUSH
3770: LD_EXP 3
3774: IN
3775: IFFALSE 3793
// unreachableList := unreachableList diff unit ;
3777: LD_ADDR_EXP 3
3781: PUSH
3782: LD_EXP 3
3786: PUSH
3787: LD_VAR 0 1
3791: DIFF
3792: ST_TO_ADDR
// ComMoveXY ( unit , x , y ) ;
3793: LD_VAR 0 1
3797: PPUSH
3798: LD_VAR 0 2
3802: PPUSH
3803: LD_VAR 0 3
3807: PPUSH
3808: CALL_OW 111
// Wait ( 1 ) ;
3812: LD_INT 1
3814: PPUSH
3815: CALL_OW 67
// if unit in unreachableList then
3819: LD_VAR 0 1
3823: PUSH
3824: LD_EXP 3
3828: IN
3829: IFFALSE 3841
// result := false else
3831: LD_ADDR_VAR 0 4
3835: PUSH
3836: LD_INT 0
3838: ST_TO_ADDR
3839: GO 3849
// result := true ;
3841: LD_ADDR_VAR 0 4
3845: PUSH
3846: LD_INT 1
3848: ST_TO_ADDR
// end ; end_of_file
3849: LD_VAR 0 4
3853: RET
// export function Action ; var dial ; begin
3854: LD_INT 0
3856: PPUSH
3857: PPUSH
// CenterNowOnXY ( 192 , 1 ) ;
3858: LD_INT 192
3860: PPUSH
3861: LD_INT 1
3863: PPUSH
3864: CALL_OW 86
// InGameOn ;
3868: CALL_OW 8
// case query ( textdiff ) of 1 :
3872: LD_STRING textdiff
3874: PPUSH
3875: CALL_OW 97
3879: PUSH
3880: LD_INT 1
3882: DOUBLE
3883: EQUAL
3884: IFTRUE 3888
3886: GO 3899
3888: POP
// Difficulty := 1 ; 2 :
3889: LD_ADDR_OWVAR 67
3893: PUSH
3894: LD_INT 1
3896: ST_TO_ADDR
3897: GO 3938
3899: LD_INT 2
3901: DOUBLE
3902: EQUAL
3903: IFTRUE 3907
3905: GO 3918
3907: POP
// Difficulty := 2 ; 3 :
3908: LD_ADDR_OWVAR 67
3912: PUSH
3913: LD_INT 2
3915: ST_TO_ADDR
3916: GO 3938
3918: LD_INT 3
3920: DOUBLE
3921: EQUAL
3922: IFTRUE 3926
3924: GO 3937
3926: POP
// Difficulty := 3 ; end ;
3927: LD_ADDR_OWVAR 67
3931: PUSH
3932: LD_INT 3
3934: ST_TO_ADDR
3935: GO 3938
3937: POP
// case query ( info ) of 1 :
3938: LD_STRING info
3940: PPUSH
3941: CALL_OW 97
3945: PUSH
3946: LD_INT 1
3948: DOUBLE
3949: EQUAL
3950: IFTRUE 3954
3952: GO 3957
3954: POP
// ; end ;
3955: GO 3958
3957: POP
// PrepareRussian ;
3958: CALL 1802 0 0
// dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Davidov ;
3962: LD_ADDR_VAR 0 2
3966: PUSH
3967: LD_INT 22
3969: PUSH
3970: LD_INT 6
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: PUSH
3977: LD_INT 21
3979: PUSH
3980: LD_INT 1
3982: PUSH
3983: EMPTY
3984: LIST
3985: LIST
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: PPUSH
3991: CALL_OW 69
3995: PUSH
3996: LD_EXP 2
4000: DIFF
4001: ST_TO_ADDR
// ComMoveXY ( dial [ 1 ] , 202 , 40 ) ;
4002: LD_VAR 0 2
4006: PUSH
4007: LD_INT 1
4009: ARRAY
4010: PPUSH
4011: LD_INT 202
4013: PPUSH
4014: LD_INT 40
4016: PPUSH
4017: CALL_OW 111
// Wait ( 0 0$03 ) ;
4021: LD_INT 105
4023: PPUSH
4024: CALL_OW 67
// Say ( Davidov , DD1 ) ;
4028: LD_EXP 2
4032: PPUSH
4033: LD_STRING DD1
4035: PPUSH
4036: CALL_OW 88
// ComTurnUnit ( dial [ 1 ] , Davidov ) ;
4040: LD_VAR 0 2
4044: PUSH
4045: LD_INT 1
4047: ARRAY
4048: PPUSH
4049: LD_EXP 2
4053: PPUSH
4054: CALL_OW 119
// ComTurnUnit ( Davidov , dial [ 1 ] ) ;
4058: LD_EXP 2
4062: PPUSH
4063: LD_VAR 0 2
4067: PUSH
4068: LD_INT 1
4070: ARRAY
4071: PPUSH
4072: CALL_OW 119
// CenterOnXY ( 202 , 40 ) ;
4076: LD_INT 202
4078: PPUSH
4079: LD_INT 40
4081: PPUSH
4082: CALL_OW 84
// Say ( dial [ 1 ] , DV1 ) ;
4086: LD_VAR 0 2
4090: PUSH
4091: LD_INT 1
4093: ARRAY
4094: PPUSH
4095: LD_STRING DV1
4097: PPUSH
4098: CALL_OW 88
// Say ( Davidov , DD2 ) ;
4102: LD_EXP 2
4106: PPUSH
4107: LD_STRING DD2
4109: PPUSH
4110: CALL_OW 88
// Say ( dial [ 1 ] , DV2 ) ;
4114: LD_VAR 0 2
4118: PUSH
4119: LD_INT 1
4121: ARRAY
4122: PPUSH
4123: LD_STRING DV2
4125: PPUSH
4126: CALL_OW 88
// Say ( Davidov , DD3 ) ;
4130: LD_EXP 2
4134: PPUSH
4135: LD_STRING DD3
4137: PPUSH
4138: CALL_OW 88
// InGameOff ;
4142: CALL_OW 9
// Wait ( 0 0$0.3 ) ;
4146: LD_INT 10
4148: PPUSH
4149: CALL_OW 67
// ChangeMissionObjectives ( C1 ) ;
4153: LD_STRING C1
4155: PPUSH
4156: CALL_OW 337
// end ;
4160: LD_VAR 0 1
4164: RET
// every 0 0$30 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab ] ] ) do
4165: LD_INT 22
4167: PUSH
4168: LD_INT 6
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: PUSH
4175: LD_INT 30
4177: PUSH
4178: LD_INT 6
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PPUSH
4189: CALL_OW 69
4193: IFFALSE 4210
4195: GO 4197
4197: DISABLE
// begin Say ( Davidov , DD4 ) ;
4198: LD_EXP 2
4202: PPUSH
4203: LD_STRING DD4
4205: PPUSH
4206: CALL_OW 88
// end ;
4210: END
// every 0 0$02 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_btype , b_lab_siberium ] ] ) do var dial ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 6
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 11
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: IFFALSE 4322
4241: GO 4243
4243: DISABLE
4244: LD_INT 0
4246: PPUSH
// begin dial := FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Davidov ;
4247: LD_ADDR_VAR 0 1
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_INT 6
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 21
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: PPUSH
4276: CALL_OW 69
4280: PUSH
4281: LD_EXP 2
4285: DIFF
4286: ST_TO_ADDR
// Say ( dial [ 1 ] , DV3 ) ;
4287: LD_VAR 0 1
4291: PUSH
4292: LD_INT 1
4294: ARRAY
4295: PPUSH
4296: LD_STRING DV3
4298: PPUSH
4299: CALL_OW 88
// Say ( Davidov , DD5 ) ;
4303: LD_EXP 2
4307: PPUSH
4308: LD_STRING DD5
4310: PPUSH
4311: CALL_OW 88
// ChangeMissionObjectives ( C2 ) ;
4315: LD_STRING C2
4317: PPUSH
4318: CALL_OW 337
// end ; end_of_file
4322: PPOPN 1
4324: END
// every 0 0$22 + 0 0$2 do
4325: GO 4327
4327: DISABLE
// begin enable ;
4328: ENABLE
// CreateCratesArea ( Rand ( 4 , 5 ) , cratesArea , true ) ;
4329: LD_INT 4
4331: PPUSH
4332: LD_INT 5
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: LD_INT 3
4342: PPUSH
4343: LD_INT 1
4345: PPUSH
4346: CALL_OW 55
// if tick >= 4 4$00 then
4350: LD_OWVAR 1
4354: PUSH
4355: LD_INT 8400
4357: GREATEREQUAL
4358: IFFALSE 4365
// begin disable ;
4360: DISABLE
// CratesSpawn ( ) ;
4361: CALL 4366 0 0
// end ; end ;
4365: END
// function CratesSpawn ( ) ; var i , amount , cr ; begin
4366: LD_INT 0
4368: PPUSH
4369: PPUSH
4370: PPUSH
4371: PPUSH
// amount := [ 30000 , 20000 , 10000 ] [ Difficulty ] ;
4372: LD_ADDR_VAR 0 3
4376: PUSH
4377: LD_INT 30000
4379: PUSH
4380: LD_INT 20000
4382: PUSH
4383: LD_INT 10000
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: LIST
4390: PUSH
4391: LD_OWVAR 67
4395: ARRAY
4396: ST_TO_ADDR
// while amount > 0 do
4397: LD_VAR 0 3
4401: PUSH
4402: LD_INT 0
4404: GREATER
4405: IFFALSE 4475
// begin Wait ( rand ( 0 0$30 , 1 1$30 ) ) ;
4407: LD_INT 1050
4409: PPUSH
4410: LD_INT 3150
4412: PPUSH
4413: CALL_OW 12
4417: PPUSH
4418: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
4422: LD_ADDR_VAR 0 4
4426: PUSH
4427: LD_INT 1
4429: PPUSH
4430: LD_INT 5
4432: PPUSH
4433: CALL_OW 12
4437: ST_TO_ADDR
// amount := amount - ( cr * 10 ) ;
4438: LD_ADDR_VAR 0 3
4442: PUSH
4443: LD_VAR 0 3
4447: PUSH
4448: LD_VAR 0 4
4452: PUSH
4453: LD_INT 10
4455: MUL
4456: MINUS
4457: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
4458: LD_VAR 0 4
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 1
4468: PPUSH
4469: CALL_OW 55
// end ;
4473: GO 4397
// end ; end_of_file
4475: LD_VAR 0 1
4479: RET
// every 2 2$10 do
4480: GO 4482
4482: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
4483: LD_INT 1
4485: PPUSH
4486: LD_INT 210
4488: PPUSH
4489: LD_INT 110
4491: PPUSH
4492: CALL_OW 550
// Wait ( Rand ( 7 7$00 , 10 10$00 ) ) ;
4496: LD_INT 14700
4498: PPUSH
4499: LD_INT 21000
4501: PPUSH
4502: CALL_OW 12
4506: PPUSH
4507: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
4511: LD_INT 0
4513: PPUSH
4514: LD_INT 210
4516: PPUSH
4517: LD_INT 110
4519: PPUSH
4520: CALL_OW 550
// end ;
4524: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
4525: LD_INT 0
4527: PPUSH
4528: PPUSH
4529: PPUSH
4530: PPUSH
4531: PPUSH
// uc_nation = nation_nature ;
4532: LD_ADDR_OWVAR 21
4536: PUSH
4537: LD_INT 0
4539: ST_TO_ADDR
// uc_side = 0 ;
4540: LD_ADDR_OWVAR 20
4544: PUSH
4545: LD_INT 0
4547: ST_TO_ADDR
// l = 0 ;
4548: LD_ADDR_VAR 0 6
4552: PUSH
4553: LD_INT 0
4555: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
4556: LD_ADDR_OWVAR 24
4560: PUSH
4561: LD_INT 0
4563: PPUSH
4564: LD_INT 5
4566: PPUSH
4567: CALL_OW 12
4571: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
4572: LD_ADDR_OWVAR 35
4576: PUSH
4577: LD_INT 5
4579: NEG
4580: PPUSH
4581: LD_INT 5
4583: PPUSH
4584: CALL_OW 12
4588: ST_TO_ADDR
// hc_gallery =  ;
4589: LD_ADDR_OWVAR 33
4593: PUSH
4594: LD_STRING 
4596: ST_TO_ADDR
// hc_class = class_apeman ;
4597: LD_ADDR_OWVAR 28
4601: PUSH
4602: LD_INT 12
4604: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
4605: LD_ADDR_OWVAR 29
4609: PUSH
4610: LD_INT 11
4612: PPUSH
4613: LD_INT 13
4615: PPUSH
4616: CALL_OW 12
4620: PUSH
4621: LD_INT 10
4623: PPUSH
4624: LD_INT 11
4626: PPUSH
4627: CALL_OW 12
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: ST_TO_ADDR
// hc_sex = sex_male ;
4636: LD_ADDR_OWVAR 27
4640: PUSH
4641: LD_INT 1
4643: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
4644: LD_ADDR_OWVAR 31
4648: PUSH
4649: LD_INT 0
4651: PPUSH
4652: LD_INT 2
4654: PPUSH
4655: CALL_OW 12
4659: PUSH
4660: LD_INT 0
4662: PUSH
4663: LD_INT 0
4665: PUSH
4666: LD_INT 0
4668: PUSH
4669: EMPTY
4670: LIST
4671: LIST
4672: LIST
4673: LIST
4674: ST_TO_ADDR
// apeman = CreateHuman ;
4675: LD_ADDR_VAR 0 7
4679: PUSH
4680: CALL_OW 44
4684: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
4685: LD_VAR 0 7
4689: PPUSH
4690: LD_VAR 0 4
4694: PPUSH
4695: LD_INT 0
4697: PPUSH
4698: CALL_OW 49
// l = l + 1 ;
4702: LD_ADDR_VAR 0 6
4706: PUSH
4707: LD_VAR 0 6
4711: PUSH
4712: LD_INT 1
4714: PLUS
4715: ST_TO_ADDR
// end until l = num1 ;
4716: LD_VAR 0 6
4720: PUSH
4721: LD_VAR 0 1
4725: EQUAL
4726: IFFALSE 4556
// l = 0 ;
4728: LD_ADDR_VAR 0 6
4732: PUSH
4733: LD_INT 0
4735: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
4736: LD_ADDR_OWVAR 35
4740: PUSH
4741: LD_INT 0
4743: PPUSH
4744: LD_INT 25
4746: PPUSH
4747: CALL_OW 12
4751: ST_TO_ADDR
// hc_class = class_tiger ;
4752: LD_ADDR_OWVAR 28
4756: PUSH
4757: LD_INT 14
4759: ST_TO_ADDR
// hc_sex = sex_male ;
4760: LD_ADDR_OWVAR 27
4764: PUSH
4765: LD_INT 1
4767: ST_TO_ADDR
// hc_gallery = sandnature ;
4768: LD_ADDR_OWVAR 33
4772: PUSH
4773: LD_STRING sandnature
4775: ST_TO_ADDR
// hc_face_number = 3 ;
4776: LD_ADDR_OWVAR 34
4780: PUSH
4781: LD_INT 3
4783: ST_TO_ADDR
// tiger = CreateHuman ;
4784: LD_ADDR_VAR 0 8
4788: PUSH
4789: CALL_OW 44
4793: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
4794: LD_VAR 0 8
4798: PPUSH
4799: LD_VAR 0 4
4803: PPUSH
4804: LD_INT 0
4806: PPUSH
4807: CALL_OW 49
// l = l + 1 ;
4811: LD_ADDR_VAR 0 6
4815: PUSH
4816: LD_VAR 0 6
4820: PUSH
4821: LD_INT 1
4823: PLUS
4824: ST_TO_ADDR
// end until l = num2 ;
4825: LD_VAR 0 6
4829: PUSH
4830: LD_VAR 0 2
4834: EQUAL
4835: IFFALSE 4736
// l = 0 ;
4837: LD_ADDR_VAR 0 6
4841: PUSH
4842: LD_INT 0
4844: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
4845: LD_ADDR_OWVAR 28
4849: PUSH
4850: LD_INT 18
4852: ST_TO_ADDR
// hc_gallery = sandnature ;
4853: LD_ADDR_OWVAR 33
4857: PUSH
4858: LD_STRING sandnature
4860: ST_TO_ADDR
// hc_face_number = 1 ;
4861: LD_ADDR_OWVAR 34
4865: PUSH
4866: LD_INT 1
4868: ST_TO_ADDR
// bird = CreateHuman ;
4869: LD_ADDR_VAR 0 9
4873: PUSH
4874: CALL_OW 44
4878: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
4879: LD_VAR 0 9
4883: PPUSH
4884: LD_INT 0
4886: PPUSH
4887: CALL_OW 51
// l = l + 1 ;
4891: LD_ADDR_VAR 0 6
4895: PUSH
4896: LD_VAR 0 6
4900: PUSH
4901: LD_INT 1
4903: PLUS
4904: ST_TO_ADDR
// end until l = num3 ;
4905: LD_VAR 0 6
4909: PUSH
4910: LD_VAR 0 3
4914: EQUAL
4915: IFFALSE 4845
// hc_gallery :=  ;
4917: LD_ADDR_OWVAR 33
4921: PUSH
4922: LD_STRING 
4924: ST_TO_ADDR
// hc_name :=  ;
4925: LD_ADDR_OWVAR 26
4929: PUSH
4930: LD_STRING 
4932: ST_TO_ADDR
// end ; end_of_file
4933: LD_VAR 0 5
4937: RET
// every 0 0$01 do var timer ;
4938: GO 4940
4940: DISABLE
4941: LD_INT 0
4943: PPUSH
// begin timer := 0 0$00 ;
4944: LD_ADDR_VAR 0 1
4948: PUSH
4949: LD_INT 0
4951: ST_TO_ADDR
// while ( true ) do
4952: LD_INT 1
4954: IFFALSE 4996
// begin timer := timer + 0 0$01 ;
4956: LD_ADDR_VAR 0 1
4960: PUSH
4961: LD_VAR 0 1
4965: PUSH
4966: LD_INT 35
4968: PLUS
4969: ST_TO_ADDR
// Display_Strings := [ #tick , timer ] ;
4970: LD_ADDR_OWVAR 47
4974: PUSH
4975: LD_STRING #tick
4977: PUSH
4978: LD_VAR 0 1
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4987: LD_INT 35
4989: PPUSH
4990: CALL_OW 67
// end ;
4994: GO 4952
// end ;
4996: PPOPN 1
4998: END
