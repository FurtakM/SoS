// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 136 , 106 ) ;
   4: LD_INT 136
   6: PPUSH
   7: LD_INT 106
   9: PPUSH
  10: CALL_OW 86
// Init ;
  14: CALL 75 0 0
// PrepareNature ( nat_area , wat_area , [ 10 , 2 * Difficulty , 6 , 6 , 3 * Difficulty , 6 , 4 ] ) ;
  18: LD_INT 2
  20: PPUSH
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 10
  26: PUSH
  27: LD_INT 2
  29: PUSH
  30: LD_OWVAR 67
  34: MUL
  35: PUSH
  36: LD_INT 6
  38: PUSH
  39: LD_INT 6
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: LD_OWVAR 67
  49: MUL
  50: PUSH
  51: LD_INT 6
  53: PUSH
  54: LD_INT 4
  56: PUSH
  57: EMPTY
  58: LIST
  59: LIST
  60: LIST
  61: LIST
  62: LIST
  63: LIST
  64: LIST
  65: PPUSH
  66: CALL 395 0 3
// PrepareHunters ( ) ;
  70: CALL 241 0 0
// end ;
  74: END
// export debug , hunterClass , huntersAmount , animalAmount ; export class_horse ; export points , hunters ; function Init ; begin
  75: LD_INT 0
  77: PPUSH
// debug := 0 ;
  78: LD_ADDR_EXP 1
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// class_horse := 21 ;
  86: LD_ADDR_EXP 5
  90: PUSH
  91: LD_INT 21
  93: ST_TO_ADDR
// if debug then
  94: LD_EXP 1
  98: IFFALSE 133
// begin FogOff ( 1 ) ;
 100: LD_INT 1
 102: PPUSH
 103: CALL_OW 344
// Difficulty := 2 ;
 107: LD_ADDR_OWVAR 67
 111: PUSH
 112: LD_INT 2
 114: ST_TO_ADDR
// hunterClass := 3 ;
 115: LD_ADDR_EXP 2
 119: PUSH
 120: LD_INT 3
 122: ST_TO_ADDR
// animalAmount := 2 ;
 123: LD_ADDR_EXP 4
 127: PUSH
 128: LD_INT 2
 130: ST_TO_ADDR
// end else
 131: GO 172
// begin Difficulty := GetMultiplayerSetting ( 0 ) ;
 133: LD_ADDR_OWVAR 67
 137: PUSH
 138: LD_INT 0
 140: PPUSH
 141: CALL_OW 426
 145: ST_TO_ADDR
// hunterClass := GetMultiplayerSetting ( 2 ) ;
 146: LD_ADDR_EXP 2
 150: PUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL_OW 426
 158: ST_TO_ADDR
// animalAmount := GetMultiplayerSetting ( 1 ) ;
 159: LD_ADDR_EXP 4
 163: PUSH
 164: LD_INT 1
 166: PPUSH
 167: CALL_OW 426
 171: ST_TO_ADDR
// end ; huntersAmount := [ 4 , 6 , 8 ] [ Difficulty ] ;
 172: LD_ADDR_EXP 3
 176: PUSH
 177: LD_INT 4
 179: PUSH
 180: LD_INT 6
 182: PUSH
 183: LD_INT 8
 185: PUSH
 186: EMPTY
 187: LIST
 188: LIST
 189: LIST
 190: PUSH
 191: LD_OWVAR 67
 195: ARRAY
 196: ST_TO_ADDR
// points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 197: LD_ADDR_EXP 6
 201: PUSH
 202: LD_INT 0
 204: PUSH
 205: LD_INT 0
 207: PUSH
 208: LD_INT 0
 210: PUSH
 211: LD_INT 0
 213: PUSH
 214: LD_INT 0
 216: PUSH
 217: LD_INT 0
 219: PUSH
 220: LD_INT 0
 222: PUSH
 223: LD_INT 0
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// end ;
 236: LD_VAR 0 1
 240: RET
// export function PrepareHunters ; var i , un ; begin
 241: LD_INT 0
 243: PPUSH
 244: PPUSH
 245: PPUSH
// for i := 1 to huntersAmount do
 246: LD_ADDR_VAR 0 2
 250: PUSH
 251: DOUBLE
 252: LD_INT 1
 254: DEC
 255: ST_TO_ADDR
 256: LD_EXP 3
 260: PUSH
 261: FOR_TO
 262: IFFALSE 388
// begin uc_side := i ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// uc_nation := i mod 3 + 1 ;
 274: LD_ADDR_OWVAR 21
 278: PUSH
 279: LD_VAR 0 2
 283: PUSH
 284: LD_INT 3
 286: MOD
 287: PUSH
 288: LD_INT 1
 290: PLUS
 291: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_sniper , class_desert_warior ] [ hunterClass ] , 10 - Difficulty * 2 ) ;
 292: LD_INT 0
 294: PPUSH
 295: LD_INT 1
 297: PUSH
 298: LD_INT 5
 300: PUSH
 301: LD_INT 11
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: LIST
 308: PUSH
 309: LD_EXP 2
 313: ARRAY
 314: PPUSH
 315: LD_INT 10
 317: PUSH
 318: LD_OWVAR 67
 322: PUSH
 323: LD_INT 2
 325: MUL
 326: MINUS
 327: PPUSH
 328: CALL_OW 380
// un := CreateHuman ;
 332: LD_ADDR_VAR 0 3
 336: PUSH
 337: CALL_OW 44
 341: ST_TO_ADDR
// hunters := Replace ( hunters , hunters + 1 , un ) ;
 342: LD_ADDR_EXP 7
 346: PUSH
 347: LD_EXP 7
 351: PPUSH
 352: LD_EXP 7
 356: PUSH
 357: LD_INT 1
 359: PLUS
 360: PPUSH
 361: LD_VAR 0 3
 365: PPUSH
 366: CALL_OW 1
 370: ST_TO_ADDR
// PlaceUnitArea ( un , startArea , false ) ;
 371: LD_VAR 0 3
 375: PPUSH
 376: LD_INT 4
 378: PPUSH
 379: LD_INT 0
 381: PPUSH
 382: CALL_OW 49
// end ;
 386: GO 261
 388: POP
 389: POP
// end ; end_of_file
 390: LD_VAR 0 1
 394: RET
// export function PrepareNature ( area , waterArea , numbers ) ; var i , j , classes , waterClass ; begin
 395: LD_INT 0
 397: PPUSH
 398: PPUSH
 399: PPUSH
 400: PPUSH
 401: PPUSH
// uc_side = 0 ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// uc_nation = 0 ;
 410: LD_ADDR_OWVAR 21
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// classes := [ class_apeman , class_apeman_soldier , class_baggie , class_phororhacos , class_tiger , class_horse ] ;
 418: LD_ADDR_VAR 0 7
 422: PUSH
 423: LD_INT 12
 425: PUSH
 426: LD_INT 15
 428: PUSH
 429: LD_INT 13
 431: PUSH
 432: LD_INT 18
 434: PUSH
 435: LD_INT 14
 437: PUSH
 438: LD_EXP 5
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: ST_TO_ADDR
// waterClass := [ class_fish ] ;
 451: LD_ADDR_VAR 0 8
 455: PUSH
 456: LD_INT 20
 458: PUSH
 459: EMPTY
 460: LIST
 461: ST_TO_ADDR
// InitHc_All ( ) ;
 462: CALL_OW 584
// for i := 1 to numbers - 2 do
 466: LD_ADDR_VAR 0 5
 470: PUSH
 471: DOUBLE
 472: LD_INT 1
 474: DEC
 475: ST_TO_ADDR
 476: LD_VAR 0 3
 480: PUSH
 481: LD_INT 2
 483: MINUS
 484: PUSH
 485: FOR_TO
 486: IFFALSE 627
// begin if numbers [ i ] = 0 then
 488: LD_VAR 0 3
 492: PUSH
 493: LD_VAR 0 5
 497: ARRAY
 498: PUSH
 499: LD_INT 0
 501: EQUAL
 502: IFFALSE 506
// continue ;
 504: GO 485
// hc_class := classes [ i ] ;
 506: LD_ADDR_OWVAR 28
 510: PUSH
 511: LD_VAR 0 7
 515: PUSH
 516: LD_VAR 0 5
 520: ARRAY
 521: ST_TO_ADDR
// hc_attr := [ rand ( 8 , 12 ) , rand ( 8 , 12 ) ] ;
 522: LD_ADDR_OWVAR 29
 526: PUSH
 527: LD_INT 8
 529: PPUSH
 530: LD_INT 12
 532: PPUSH
 533: CALL_OW 12
 537: PUSH
 538: LD_INT 8
 540: PPUSH
 541: LD_INT 12
 543: PPUSH
 544: CALL_OW 12
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) + Difficulty * 5 ;
 553: LD_ADDR_OWVAR 35
 557: PUSH
 558: LD_INT 5
 560: NEG
 561: PPUSH
 562: LD_INT 5
 564: PPUSH
 565: CALL_OW 12
 569: PUSH
 570: LD_OWVAR 67
 574: PUSH
 575: LD_INT 5
 577: MUL
 578: PLUS
 579: ST_TO_ADDR
// for j := 1 to numbers [ i ] do
 580: LD_ADDR_VAR 0 6
 584: PUSH
 585: DOUBLE
 586: LD_INT 1
 588: DEC
 589: ST_TO_ADDR
 590: LD_VAR 0 3
 594: PUSH
 595: LD_VAR 0 5
 599: ARRAY
 600: PUSH
 601: FOR_TO
 602: IFFALSE 623
// PlaceUnitArea ( CreateHuman , area , false ) ;
 604: CALL_OW 44
 608: PPUSH
 609: LD_VAR 0 1
 613: PPUSH
 614: LD_INT 0
 616: PPUSH
 617: CALL_OW 49
 621: GO 601
 623: POP
 624: POP
// end ;
 625: GO 485
 627: POP
 628: POP
// if not waterArea then
 629: LD_VAR 0 2
 633: NOT
 634: IFFALSE 638
// exit ;
 636: GO 718
// hc_class := waterClass [ 1 ] ;
 638: LD_ADDR_OWVAR 28
 642: PUSH
 643: LD_VAR 0 8
 647: PUSH
 648: LD_INT 1
 650: ARRAY
 651: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 652: LD_ADDR_OWVAR 29
 656: PUSH
 657: LD_INT 10
 659: PUSH
 660: LD_INT 10
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: ST_TO_ADDR
// hc_agressivity := 0 ;
 667: LD_ADDR_OWVAR 35
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// for j := 1 to numbers [ 7 ] do
 675: LD_ADDR_VAR 0 6
 679: PUSH
 680: DOUBLE
 681: LD_INT 1
 683: DEC
 684: ST_TO_ADDR
 685: LD_VAR 0 3
 689: PUSH
 690: LD_INT 7
 692: ARRAY
 693: PUSH
 694: FOR_TO
 695: IFFALSE 716
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 697: CALL_OW 44
 701: PPUSH
 702: LD_VAR 0 2
 706: PPUSH
 707: LD_INT 0
 709: PPUSH
 710: CALL_OW 49
 714: GO 694
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 4
 722: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do var i ;
 723: LD_INT 22
 725: PUSH
 726: LD_INT 0
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: PUSH
 733: LD_INT 25
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: PPUSH
 747: CALL_OW 69
 751: IFFALSE 857
 753: GO 755
 755: DISABLE
 756: LD_INT 0
 758: PPUSH
// begin enable ;
 759: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do
 760: LD_ADDR_VAR 0 1
 764: PUSH
 765: LD_INT 22
 767: PUSH
 768: LD_INT 0
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: PUSH
 775: LD_INT 25
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PPUSH
 789: CALL_OW 69
 793: PUSH
 794: FOR_IN
 795: IFFALSE 855
// if GetLives ( i ) < 1000 then
 797: LD_VAR 0 1
 801: PPUSH
 802: CALL_OW 256
 806: PUSH
 807: LD_INT 1000
 809: LESS
 810: IFFALSE 853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , i ) ) ;
 812: LD_VAR 0 1
 816: PPUSH
 817: LD_INT 3
 819: PUSH
 820: LD_INT 22
 822: PUSH
 823: LD_INT 0
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: LD_VAR 0 1
 843: PPUSH
 844: CALL_OW 74
 848: PPUSH
 849: CALL_OW 115
 853: GO 794
 855: POP
 856: POP
// end ;
 857: PPOPN 1
 859: END
// every 3 do var i , enemy , x , y , d ;
 860: GO 862
 862: DISABLE
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
 867: PPUSH
 868: PPUSH
 869: PPUSH
// begin enable ;
 870: ENABLE
// for i := 2 to huntersAmount do
 871: LD_ADDR_VAR 0 1
 875: PUSH
 876: DOUBLE
 877: LD_INT 2
 879: DEC
 880: ST_TO_ADDR
 881: LD_EXP 3
 885: PUSH
 886: FOR_TO
 887: IFFALSE 1226
// begin if not HasTask ( hunters [ i ] ) then
 889: LD_EXP 7
 893: PUSH
 894: LD_VAR 0 1
 898: ARRAY
 899: PPUSH
 900: CALL_OW 314
 904: NOT
 905: IFFALSE 1224
// begin enemy := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 0 ] ) , hunters [ i ] ) ;
 907: LD_ADDR_VAR 0 2
 911: PUSH
 912: LD_INT 22
 914: PUSH
 915: LD_INT 0
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: PPUSH
 922: CALL_OW 69
 926: PPUSH
 927: LD_EXP 7
 931: PUSH
 932: LD_VAR 0 1
 936: ARRAY
 937: PPUSH
 938: CALL_OW 74
 942: ST_TO_ADDR
// if not enemy then
 943: LD_VAR 0 2
 947: NOT
 948: IFFALSE 952
// continue ;
 950: GO 886
// if GetDistUnits ( hunters [ i ] , enemy ) < 17 then
 952: LD_EXP 7
 956: PUSH
 957: LD_VAR 0 1
 961: ARRAY
 962: PPUSH
 963: LD_VAR 0 2
 967: PPUSH
 968: CALL_OW 296
 972: PUSH
 973: LD_INT 17
 975: LESS
 976: IFFALSE 1079
// begin if GetClass ( hunters [ i ] ) = class_desert_warior then
 978: LD_EXP 7
 982: PUSH
 983: LD_VAR 0 1
 987: ARRAY
 988: PPUSH
 989: CALL_OW 257
 993: PUSH
 994: LD_INT 11
 996: EQUAL
 997: IFFALSE 1057
// if GetClass ( enemy ) in [ class_frog , class_fish , class_baggie ] then
 999: LD_VAR 0 2
1003: PPUSH
1004: CALL_OW 257
1008: PUSH
1009: LD_INT 19
1011: PUSH
1012: LD_INT 20
1014: PUSH
1015: LD_INT 13
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: IN
1023: IFFALSE 1042
// ComCarabine ( hunters [ i ] ) else
1025: LD_EXP 7
1029: PUSH
1030: LD_VAR 0 1
1034: ARRAY
1035: PPUSH
1036: CALL_OW 162
1040: GO 1057
// ComSabre ( hunters [ i ] ) ;
1042: LD_EXP 7
1046: PUSH
1047: LD_VAR 0 1
1051: ARRAY
1052: PPUSH
1053: CALL_OW 163
// ComAttackUnit ( hunters [ i ] , enemy ) ;
1057: LD_EXP 7
1061: PUSH
1062: LD_VAR 0 1
1066: ARRAY
1067: PPUSH
1068: LD_VAR 0 2
1072: PPUSH
1073: CALL_OW 115
// end else
1077: GO 1224
// begin d := rand ( 0 , 5 ) ;
1079: LD_ADDR_VAR 0 5
1083: PUSH
1084: LD_INT 0
1086: PPUSH
1087: LD_INT 5
1089: PPUSH
1090: CALL_OW 12
1094: ST_TO_ADDR
// x := ShiftX ( GetX ( hunters [ i ] ) , d , 8 ) ;
1095: LD_ADDR_VAR 0 3
1099: PUSH
1100: LD_EXP 7
1104: PUSH
1105: LD_VAR 0 1
1109: ARRAY
1110: PPUSH
1111: CALL_OW 250
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: LD_INT 8
1123: PPUSH
1124: CALL_OW 272
1128: ST_TO_ADDR
// y := ShiftY ( GetY ( hunters [ i ] ) , d , 8 ) ;
1129: LD_ADDR_VAR 0 4
1133: PUSH
1134: LD_EXP 7
1138: PUSH
1139: LD_VAR 0 1
1143: ARRAY
1144: PPUSH
1145: CALL_OW 251
1149: PPUSH
1150: LD_VAR 0 5
1154: PPUSH
1155: LD_INT 8
1157: PPUSH
1158: CALL_OW 273
1162: ST_TO_ADDR
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
1163: LD_VAR 0 3
1167: PPUSH
1168: LD_VAR 0 4
1172: PPUSH
1173: CALL_OW 488
1177: PUSH
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_VAR 0 4
1187: PPUSH
1188: CALL_OW 428
1192: PUSH
1193: LD_INT 0
1195: EQUAL
1196: AND
1197: IFFALSE 1224
// ComMoveXY ( hunters [ i ] , x , y ) ;
1199: LD_EXP 7
1203: PUSH
1204: LD_VAR 0 1
1208: ARRAY
1209: PPUSH
1210: LD_VAR 0 3
1214: PPUSH
1215: LD_VAR 0 4
1219: PPUSH
1220: CALL_OW 111
// end ; end ; end ;
1224: GO 886
1226: POP
1227: POP
// end ; end_of_file
1228: PPOPN 5
1230: END
// on UnitGoesToRed ( un ) do var i ;
1231: LD_INT 0
1233: PPUSH
// begin if GetSide ( un ) = 1 then
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 255
1243: PUSH
1244: LD_INT 1
1246: EQUAL
1247: IFFALSE 1256
// YouLost ( hunt2 ) ;
1249: LD_STRING hunt2
1251: PPUSH
1252: CALL_OW 104
// if GetSide ( un ) > 1 then
1256: LD_VAR 0 1
1260: PPUSH
1261: CALL_OW 255
1265: PUSH
1266: LD_INT 1
1268: GREATER
1269: IFFALSE 1322
// begin for i := 1 to 6 do
1271: LD_ADDR_VAR 0 2
1275: PUSH
1276: DOUBLE
1277: LD_INT 1
1279: DEC
1280: ST_TO_ADDR
1281: LD_INT 6
1283: PUSH
1284: FOR_TO
1285: IFFALSE 1308
// begin wait ( 0 0$1 ) ;
1287: LD_INT 35
1289: PPUSH
1290: CALL_OW 67
// SetLives ( un , 249 ) ;
1294: LD_VAR 0 1
1298: PPUSH
1299: LD_INT 249
1301: PPUSH
1302: CALL_OW 234
// end ;
1306: GO 1284
1308: POP
1309: POP
// SetLives ( un , 1000 ) ;
1310: LD_VAR 0 1
1314: PPUSH
1315: LD_INT 1000
1317: PPUSH
1318: CALL_OW 234
// end ; end ;
1322: PPOPN 2
1324: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 > 1 then
1325: LD_VAR 0 1
1329: PUSH
1330: LD_INT 1
1332: EQUAL
1333: PUSH
1334: LD_VAR 0 2
1338: PUSH
1339: LD_INT 1
1341: GREATER
1342: AND
1343: IFFALSE 1352
// YouLost ( hunt1 ) ;
1345: LD_STRING hunt1
1347: PPUSH
1348: CALL_OW 104
// end ;
1352: PPOPN 2
1354: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do var point ;
1355: LD_INT 0
1357: PPUSH
// begin point := 0 ;
1358: LD_ADDR_VAR 0 4
1362: PUSH
1363: LD_INT 0
1365: ST_TO_ADDR
// case GetClass ( un ) of class_fish :
1366: LD_VAR 0 1
1370: PPUSH
1371: CALL_OW 257
1375: PUSH
1376: LD_INT 20
1378: DOUBLE
1379: EQUAL
1380: IFTRUE 1384
1382: GO 1395
1384: POP
// point := 10 ; class_horse :
1385: LD_ADDR_VAR 0 4
1389: PUSH
1390: LD_INT 10
1392: ST_TO_ADDR
1393: GO 1531
1395: LD_EXP 5
1399: DOUBLE
1400: EQUAL
1401: IFTRUE 1405
1403: GO 1416
1405: POP
// point := 10 ; class_baggie :
1406: LD_ADDR_VAR 0 4
1410: PUSH
1411: LD_INT 10
1413: ST_TO_ADDR
1414: GO 1531
1416: LD_INT 13
1418: DOUBLE
1419: EQUAL
1420: IFTRUE 1424
1422: GO 1435
1424: POP
// point := 5 ; class_phororhacos :
1425: LD_ADDR_VAR 0 4
1429: PUSH
1430: LD_INT 5
1432: ST_TO_ADDR
1433: GO 1531
1435: LD_INT 18
1437: DOUBLE
1438: EQUAL
1439: IFTRUE 1443
1441: GO 1454
1443: POP
// point := 10 ; class_tiger :
1444: LD_ADDR_VAR 0 4
1448: PUSH
1449: LD_INT 10
1451: ST_TO_ADDR
1452: GO 1531
1454: LD_INT 14
1456: DOUBLE
1457: EQUAL
1458: IFTRUE 1462
1460: GO 1473
1462: POP
// point := 20 ; class_apeman :
1463: LD_ADDR_VAR 0 4
1467: PUSH
1468: LD_INT 20
1470: ST_TO_ADDR
1471: GO 1531
1473: LD_INT 12
1475: DOUBLE
1476: EQUAL
1477: IFTRUE 1481
1479: GO 1492
1481: POP
// point := 30 ; class_apeman_soldier :
1482: LD_ADDR_VAR 0 4
1486: PUSH
1487: LD_INT 30
1489: ST_TO_ADDR
1490: GO 1531
1492: LD_INT 15
1494: DOUBLE
1495: EQUAL
1496: IFTRUE 1500
1498: GO 1511
1500: POP
// point := 50 ; class_frog :
1501: LD_ADDR_VAR 0 4
1505: PUSH
1506: LD_INT 50
1508: ST_TO_ADDR
1509: GO 1531
1511: LD_INT 19
1513: DOUBLE
1514: EQUAL
1515: IFTRUE 1519
1517: GO 1530
1519: POP
// point := 10 ; end ;
1520: LD_ADDR_VAR 0 4
1524: PUSH
1525: LD_INT 10
1527: ST_TO_ADDR
1528: GO 1531
1530: POP
// if point then
1531: LD_VAR 0 4
1535: IFFALSE 1574
// points := Replace ( points , killer_side , points [ killer_side ] + point ) ;
1537: LD_ADDR_EXP 6
1541: PUSH
1542: LD_EXP 6
1546: PPUSH
1547: LD_VAR 0 2
1551: PPUSH
1552: LD_EXP 6
1556: PUSH
1557: LD_VAR 0 2
1561: ARRAY
1562: PUSH
1563: LD_VAR 0 4
1567: PLUS
1568: PPUSH
1569: CALL_OW 1
1573: ST_TO_ADDR
// end ;
1574: PPOPN 4
1576: END
// every 0 0$20 trigger FilterAllUnits ( [ f_side , 0 ] ) < 10 do
1577: LD_INT 22
1579: PUSH
1580: LD_INT 0
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: PUSH
1592: LD_INT 10
1594: LESS
1595: IFFALSE 1697
1597: GO 1599
1599: DISABLE
// begin enable ;
1600: ENABLE
// PrepareNature ( nat_area , wat_area , [ rand ( 0 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 2 , 4 ) , rand ( 2 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) ] ) ;
1601: LD_INT 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: LD_INT 0
1609: PPUSH
1610: LD_INT 4
1612: PPUSH
1613: CALL_OW 12
1617: PUSH
1618: LD_INT 0
1620: PPUSH
1621: LD_INT 2
1623: PPUSH
1624: CALL_OW 12
1628: PUSH
1629: LD_INT 0
1631: PPUSH
1632: LD_INT 4
1634: PPUSH
1635: CALL_OW 12
1639: PUSH
1640: LD_INT 2
1642: PPUSH
1643: LD_INT 4
1645: PPUSH
1646: CALL_OW 12
1650: PUSH
1651: LD_INT 2
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: CALL_OW 12
1661: PUSH
1662: LD_INT 0
1664: PPUSH
1665: LD_INT 2
1667: PPUSH
1668: CALL_OW 12
1672: PUSH
1673: LD_INT 0
1675: PPUSH
1676: LD_INT 4
1678: PPUSH
1679: CALL_OW 12
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: PPUSH
1693: CALL 395 0 3
// end ;
1697: END
// every 0 0$1 do var i ;
1698: GO 1700
1700: DISABLE
1701: LD_INT 0
1703: PPUSH
// begin enable ;
1704: ENABLE
// display_strings := [ ] ;
1705: LD_ADDR_OWVAR 47
1709: PUSH
1710: EMPTY
1711: ST_TO_ADDR
// for i := 1 to huntersAmount do
1712: LD_ADDR_VAR 0 1
1716: PUSH
1717: DOUBLE
1718: LD_INT 1
1720: DEC
1721: ST_TO_ADDR
1722: LD_EXP 3
1726: PUSH
1727: FOR_TO
1728: IFFALSE 1862
// begin display_strings := display_strings ^ [ #player & i , i , points [ i ] ] ;
1730: LD_ADDR_OWVAR 47
1734: PUSH
1735: LD_OWVAR 47
1739: PUSH
1740: LD_STRING #player
1742: PUSH
1743: LD_VAR 0 1
1747: STR
1748: PUSH
1749: LD_VAR 0 1
1753: PUSH
1754: LD_EXP 6
1758: PUSH
1759: LD_VAR 0 1
1763: ARRAY
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: ADD
1770: ST_TO_ADDR
// if points [ i ] >= [ 750 , 1250 , 2000 ] [ Difficulty ] then
1771: LD_EXP 6
1775: PUSH
1776: LD_VAR 0 1
1780: ARRAY
1781: PUSH
1782: LD_INT 750
1784: PUSH
1785: LD_INT 1250
1787: PUSH
1788: LD_INT 2000
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: PUSH
1796: LD_OWVAR 67
1800: ARRAY
1801: GREATEREQUAL
1802: IFFALSE 1860
// begin if i = 1 then
1804: LD_VAR 0 1
1808: PUSH
1809: LD_INT 1
1811: EQUAL
1812: IFFALSE 1853
// begin DialogueOn ;
1814: CALL_OW 6
// SetAchievement ( ACH_HUNT ) ;
1818: LD_STRING ACH_HUNT
1820: PPUSH
1821: CALL_OW 543
// display_strings := [ #hunting-win ] ;
1825: LD_ADDR_OWVAR 47
1829: PUSH
1830: LD_STRING #hunting-win
1832: PUSH
1833: EMPTY
1834: LIST
1835: ST_TO_ADDR
// dwait ( 0 0$5 ) ;
1836: LD_INT 175
1838: PPUSH
1839: CALL_OW 68
// YouWin ;
1843: CALL_OW 103
// DialogueOff ;
1847: CALL_OW 7
// end else
1851: GO 1860
// YouLost ( hunt3 ) ;
1853: LD_STRING hunt3
1855: PPUSH
1856: CALL_OW 104
// end ; end ;
1860: GO 1727
1862: POP
1863: POP
// end ; end_of_file end_of_file
1864: PPOPN 1
1866: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
1867: LD_VAR 0 2
1871: PUSH
1872: LD_INT 100
1874: EQUAL
1875: IFFALSE 2824
// begin if not StreamModeActive then
1877: LD_EXP 8
1881: NOT
1882: IFFALSE 1892
// StreamModeActive := true ;
1884: LD_ADDR_EXP 8
1888: PUSH
1889: LD_INT 1
1891: ST_TO_ADDR
// if p3 = 0 then
1892: LD_VAR 0 3
1896: PUSH
1897: LD_INT 0
1899: EQUAL
1900: IFFALSE 1906
// InitStreamMode ;
1902: CALL 2982 0 0
// if p3 = 1 then
1906: LD_VAR 0 3
1910: PUSH
1911: LD_INT 1
1913: EQUAL
1914: IFFALSE 1924
// sRocket := true ;
1916: LD_ADDR_EXP 13
1920: PUSH
1921: LD_INT 1
1923: ST_TO_ADDR
// if p3 = 2 then
1924: LD_VAR 0 3
1928: PUSH
1929: LD_INT 2
1931: EQUAL
1932: IFFALSE 1942
// sSpeed := true ;
1934: LD_ADDR_EXP 12
1938: PUSH
1939: LD_INT 1
1941: ST_TO_ADDR
// if p3 = 3 then
1942: LD_VAR 0 3
1946: PUSH
1947: LD_INT 3
1949: EQUAL
1950: IFFALSE 1960
// sEngine := true ;
1952: LD_ADDR_EXP 14
1956: PUSH
1957: LD_INT 1
1959: ST_TO_ADDR
// if p3 = 4 then
1960: LD_VAR 0 3
1964: PUSH
1965: LD_INT 4
1967: EQUAL
1968: IFFALSE 1978
// sSpec := true ;
1970: LD_ADDR_EXP 11
1974: PUSH
1975: LD_INT 1
1977: ST_TO_ADDR
// if p3 = 5 then
1978: LD_VAR 0 3
1982: PUSH
1983: LD_INT 5
1985: EQUAL
1986: IFFALSE 1996
// sLevel := true ;
1988: LD_ADDR_EXP 15
1992: PUSH
1993: LD_INT 1
1995: ST_TO_ADDR
// if p3 = 6 then
1996: LD_VAR 0 3
2000: PUSH
2001: LD_INT 6
2003: EQUAL
2004: IFFALSE 2014
// sArmoury := true ;
2006: LD_ADDR_EXP 16
2010: PUSH
2011: LD_INT 1
2013: ST_TO_ADDR
// if p3 = 7 then
2014: LD_VAR 0 3
2018: PUSH
2019: LD_INT 7
2021: EQUAL
2022: IFFALSE 2032
// sRadar := true ;
2024: LD_ADDR_EXP 17
2028: PUSH
2029: LD_INT 1
2031: ST_TO_ADDR
// if p3 = 8 then
2032: LD_VAR 0 3
2036: PUSH
2037: LD_INT 8
2039: EQUAL
2040: IFFALSE 2050
// sBunker := true ;
2042: LD_ADDR_EXP 18
2046: PUSH
2047: LD_INT 1
2049: ST_TO_ADDR
// if p3 = 9 then
2050: LD_VAR 0 3
2054: PUSH
2055: LD_INT 9
2057: EQUAL
2058: IFFALSE 2068
// sHack := true ;
2060: LD_ADDR_EXP 19
2064: PUSH
2065: LD_INT 1
2067: ST_TO_ADDR
// if p3 = 10 then
2068: LD_VAR 0 3
2072: PUSH
2073: LD_INT 10
2075: EQUAL
2076: IFFALSE 2086
// sFire := true ;
2078: LD_ADDR_EXP 20
2082: PUSH
2083: LD_INT 1
2085: ST_TO_ADDR
// if p3 = 11 then
2086: LD_VAR 0 3
2090: PUSH
2091: LD_INT 11
2093: EQUAL
2094: IFFALSE 2104
// sRefresh := true ;
2096: LD_ADDR_EXP 21
2100: PUSH
2101: LD_INT 1
2103: ST_TO_ADDR
// if p3 = 12 then
2104: LD_VAR 0 3
2108: PUSH
2109: LD_INT 12
2111: EQUAL
2112: IFFALSE 2122
// sExp := true ;
2114: LD_ADDR_EXP 22
2118: PUSH
2119: LD_INT 1
2121: ST_TO_ADDR
// if p3 = 13 then
2122: LD_VAR 0 3
2126: PUSH
2127: LD_INT 13
2129: EQUAL
2130: IFFALSE 2140
// sDepot := true ;
2132: LD_ADDR_EXP 23
2136: PUSH
2137: LD_INT 1
2139: ST_TO_ADDR
// if p3 = 14 then
2140: LD_VAR 0 3
2144: PUSH
2145: LD_INT 14
2147: EQUAL
2148: IFFALSE 2158
// sFlag := true ;
2150: LD_ADDR_EXP 24
2154: PUSH
2155: LD_INT 1
2157: ST_TO_ADDR
// if p3 = 15 then
2158: LD_VAR 0 3
2162: PUSH
2163: LD_INT 15
2165: EQUAL
2166: IFFALSE 2176
// sKamikadze := true ;
2168: LD_ADDR_EXP 32
2172: PUSH
2173: LD_INT 1
2175: ST_TO_ADDR
// if p3 = 16 then
2176: LD_VAR 0 3
2180: PUSH
2181: LD_INT 16
2183: EQUAL
2184: IFFALSE 2194
// sTroll := true ;
2186: LD_ADDR_EXP 33
2190: PUSH
2191: LD_INT 1
2193: ST_TO_ADDR
// if p3 = 17 then
2194: LD_VAR 0 3
2198: PUSH
2199: LD_INT 17
2201: EQUAL
2202: IFFALSE 2212
// sSlow := true ;
2204: LD_ADDR_EXP 34
2208: PUSH
2209: LD_INT 1
2211: ST_TO_ADDR
// if p3 = 18 then
2212: LD_VAR 0 3
2216: PUSH
2217: LD_INT 18
2219: EQUAL
2220: IFFALSE 2230
// sLack := true ;
2222: LD_ADDR_EXP 35
2226: PUSH
2227: LD_INT 1
2229: ST_TO_ADDR
// if p3 = 19 then
2230: LD_VAR 0 3
2234: PUSH
2235: LD_INT 19
2237: EQUAL
2238: IFFALSE 2248
// sTank := true ;
2240: LD_ADDR_EXP 37
2244: PUSH
2245: LD_INT 1
2247: ST_TO_ADDR
// if p3 = 20 then
2248: LD_VAR 0 3
2252: PUSH
2253: LD_INT 20
2255: EQUAL
2256: IFFALSE 2266
// sRemote := true ;
2258: LD_ADDR_EXP 38
2262: PUSH
2263: LD_INT 1
2265: ST_TO_ADDR
// if p3 = 21 then
2266: LD_VAR 0 3
2270: PUSH
2271: LD_INT 21
2273: EQUAL
2274: IFFALSE 2284
// sPowell := true ;
2276: LD_ADDR_EXP 39
2280: PUSH
2281: LD_INT 1
2283: ST_TO_ADDR
// if p3 = 22 then
2284: LD_VAR 0 3
2288: PUSH
2289: LD_INT 22
2291: EQUAL
2292: IFFALSE 2302
// sTeleport := true ;
2294: LD_ADDR_EXP 42
2298: PUSH
2299: LD_INT 1
2301: ST_TO_ADDR
// if p3 = 23 then
2302: LD_VAR 0 3
2306: PUSH
2307: LD_INT 23
2309: EQUAL
2310: IFFALSE 2320
// sOilTower := true ;
2312: LD_ADDR_EXP 44
2316: PUSH
2317: LD_INT 1
2319: ST_TO_ADDR
// if p3 = 24 then
2320: LD_VAR 0 3
2324: PUSH
2325: LD_INT 24
2327: EQUAL
2328: IFFALSE 2338
// sShovel := true ;
2330: LD_ADDR_EXP 45
2334: PUSH
2335: LD_INT 1
2337: ST_TO_ADDR
// if p3 = 25 then
2338: LD_VAR 0 3
2342: PUSH
2343: LD_INT 25
2345: EQUAL
2346: IFFALSE 2356
// sSheik := true ;
2348: LD_ADDR_EXP 46
2352: PUSH
2353: LD_INT 1
2355: ST_TO_ADDR
// if p3 = 26 then
2356: LD_VAR 0 3
2360: PUSH
2361: LD_INT 26
2363: EQUAL
2364: IFFALSE 2374
// sEarthquake := true ;
2366: LD_ADDR_EXP 48
2370: PUSH
2371: LD_INT 1
2373: ST_TO_ADDR
// if p3 = 27 then
2374: LD_VAR 0 3
2378: PUSH
2379: LD_INT 27
2381: EQUAL
2382: IFFALSE 2392
// sAI := true ;
2384: LD_ADDR_EXP 49
2388: PUSH
2389: LD_INT 1
2391: ST_TO_ADDR
// if p3 = 28 then
2392: LD_VAR 0 3
2396: PUSH
2397: LD_INT 28
2399: EQUAL
2400: IFFALSE 2410
// sCargo := true ;
2402: LD_ADDR_EXP 52
2406: PUSH
2407: LD_INT 1
2409: ST_TO_ADDR
// if p3 = 29 then
2410: LD_VAR 0 3
2414: PUSH
2415: LD_INT 29
2417: EQUAL
2418: IFFALSE 2428
// sDLaser := true ;
2420: LD_ADDR_EXP 53
2424: PUSH
2425: LD_INT 1
2427: ST_TO_ADDR
// if p3 = 30 then
2428: LD_VAR 0 3
2432: PUSH
2433: LD_INT 30
2435: EQUAL
2436: IFFALSE 2446
// sExchange := true ;
2438: LD_ADDR_EXP 54
2442: PUSH
2443: LD_INT 1
2445: ST_TO_ADDR
// if p3 = 31 then
2446: LD_VAR 0 3
2450: PUSH
2451: LD_INT 31
2453: EQUAL
2454: IFFALSE 2464
// sFac := true ;
2456: LD_ADDR_EXP 55
2460: PUSH
2461: LD_INT 1
2463: ST_TO_ADDR
// if p3 = 32 then
2464: LD_VAR 0 3
2468: PUSH
2469: LD_INT 32
2471: EQUAL
2472: IFFALSE 2482
// sPower := true ;
2474: LD_ADDR_EXP 56
2478: PUSH
2479: LD_INT 1
2481: ST_TO_ADDR
// if p3 = 33 then
2482: LD_VAR 0 3
2486: PUSH
2487: LD_INT 33
2489: EQUAL
2490: IFFALSE 2500
// sRandom := true ;
2492: LD_ADDR_EXP 57
2496: PUSH
2497: LD_INT 1
2499: ST_TO_ADDR
// if p3 = 34 then
2500: LD_VAR 0 3
2504: PUSH
2505: LD_INT 34
2507: EQUAL
2508: IFFALSE 2518
// sShield := true ;
2510: LD_ADDR_EXP 58
2514: PUSH
2515: LD_INT 1
2517: ST_TO_ADDR
// if p3 = 35 then
2518: LD_VAR 0 3
2522: PUSH
2523: LD_INT 35
2525: EQUAL
2526: IFFALSE 2536
// sTime := true ;
2528: LD_ADDR_EXP 59
2532: PUSH
2533: LD_INT 1
2535: ST_TO_ADDR
// if p3 = 36 then
2536: LD_VAR 0 3
2540: PUSH
2541: LD_INT 36
2543: EQUAL
2544: IFFALSE 2554
// sTools := true ;
2546: LD_ADDR_EXP 60
2550: PUSH
2551: LD_INT 1
2553: ST_TO_ADDR
// if p3 = 101 then
2554: LD_VAR 0 3
2558: PUSH
2559: LD_INT 101
2561: EQUAL
2562: IFFALSE 2572
// sSold := true ;
2564: LD_ADDR_EXP 25
2568: PUSH
2569: LD_INT 1
2571: ST_TO_ADDR
// if p3 = 102 then
2572: LD_VAR 0 3
2576: PUSH
2577: LD_INT 102
2579: EQUAL
2580: IFFALSE 2590
// sDiff := true ;
2582: LD_ADDR_EXP 26
2586: PUSH
2587: LD_INT 1
2589: ST_TO_ADDR
// if p3 = 103 then
2590: LD_VAR 0 3
2594: PUSH
2595: LD_INT 103
2597: EQUAL
2598: IFFALSE 2608
// sFog := true ;
2600: LD_ADDR_EXP 29
2604: PUSH
2605: LD_INT 1
2607: ST_TO_ADDR
// if p3 = 104 then
2608: LD_VAR 0 3
2612: PUSH
2613: LD_INT 104
2615: EQUAL
2616: IFFALSE 2626
// sReset := true ;
2618: LD_ADDR_EXP 30
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// if p3 = 105 then
2626: LD_VAR 0 3
2630: PUSH
2631: LD_INT 105
2633: EQUAL
2634: IFFALSE 2644
// sSun := true ;
2636: LD_ADDR_EXP 31
2640: PUSH
2641: LD_INT 1
2643: ST_TO_ADDR
// if p3 = 106 then
2644: LD_VAR 0 3
2648: PUSH
2649: LD_INT 106
2651: EQUAL
2652: IFFALSE 2662
// sTiger := true ;
2654: LD_ADDR_EXP 27
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// if p3 = 107 then
2662: LD_VAR 0 3
2666: PUSH
2667: LD_INT 107
2669: EQUAL
2670: IFFALSE 2680
// sBomb := true ;
2672: LD_ADDR_EXP 28
2676: PUSH
2677: LD_INT 1
2679: ST_TO_ADDR
// if p3 = 108 then
2680: LD_VAR 0 3
2684: PUSH
2685: LD_INT 108
2687: EQUAL
2688: IFFALSE 2698
// sWound := true ;
2690: LD_ADDR_EXP 36
2694: PUSH
2695: LD_INT 1
2697: ST_TO_ADDR
// if p3 = 109 then
2698: LD_VAR 0 3
2702: PUSH
2703: LD_INT 109
2705: EQUAL
2706: IFFALSE 2716
// sBetray := true ;
2708: LD_ADDR_EXP 40
2712: PUSH
2713: LD_INT 1
2715: ST_TO_ADDR
// if p3 = 110 then
2716: LD_VAR 0 3
2720: PUSH
2721: LD_INT 110
2723: EQUAL
2724: IFFALSE 2734
// sContamin := true ;
2726: LD_ADDR_EXP 41
2730: PUSH
2731: LD_INT 1
2733: ST_TO_ADDR
// if p3 = 111 then
2734: LD_VAR 0 3
2738: PUSH
2739: LD_INT 111
2741: EQUAL
2742: IFFALSE 2752
// sOil := true ;
2744: LD_ADDR_EXP 43
2748: PUSH
2749: LD_INT 1
2751: ST_TO_ADDR
// if p3 = 112 then
2752: LD_VAR 0 3
2756: PUSH
2757: LD_INT 112
2759: EQUAL
2760: IFFALSE 2770
// sStu := true ;
2762: LD_ADDR_EXP 47
2766: PUSH
2767: LD_INT 1
2769: ST_TO_ADDR
// if p3 = 113 then
2770: LD_VAR 0 3
2774: PUSH
2775: LD_INT 113
2777: EQUAL
2778: IFFALSE 2788
// sBazooka := true ;
2780: LD_ADDR_EXP 50
2784: PUSH
2785: LD_INT 1
2787: ST_TO_ADDR
// if p3 = 114 then
2788: LD_VAR 0 3
2792: PUSH
2793: LD_INT 114
2795: EQUAL
2796: IFFALSE 2806
// sMortar := true ;
2798: LD_ADDR_EXP 51
2802: PUSH
2803: LD_INT 1
2805: ST_TO_ADDR
// if p3 = 115 then
2806: LD_VAR 0 3
2810: PUSH
2811: LD_INT 115
2813: EQUAL
2814: IFFALSE 2824
// sRanger := true ;
2816: LD_ADDR_EXP 61
2820: PUSH
2821: LD_INT 1
2823: ST_TO_ADDR
// end ; if p2 = 101 then
2824: LD_VAR 0 2
2828: PUSH
2829: LD_INT 101
2831: EQUAL
2832: IFFALSE 2960
// begin case p3 of 1 :
2834: LD_VAR 0 3
2838: PUSH
2839: LD_INT 1
2841: DOUBLE
2842: EQUAL
2843: IFTRUE 2847
2845: GO 2854
2847: POP
// hHackUnlimitedResources ; 2 :
2848: CALL 13995 0 0
2852: GO 2960
2854: LD_INT 2
2856: DOUBLE
2857: EQUAL
2858: IFTRUE 2862
2860: GO 2869
2862: POP
// hHackSetLevel10 ; 3 :
2863: CALL 14128 0 0
2867: GO 2960
2869: LD_INT 3
2871: DOUBLE
2872: EQUAL
2873: IFTRUE 2877
2875: GO 2884
2877: POP
// hHackSetLevel10YourUnits ; 4 :
2878: CALL 14213 0 0
2882: GO 2960
2884: LD_INT 4
2886: DOUBLE
2887: EQUAL
2888: IFTRUE 2892
2890: GO 2899
2892: POP
// hHackInvincible ; 5 :
2893: CALL 14661 0 0
2897: GO 2960
2899: LD_INT 5
2901: DOUBLE
2902: EQUAL
2903: IFTRUE 2907
2905: GO 2914
2907: POP
// hHackInvisible ; 6 :
2908: CALL 14772 0 0
2912: GO 2960
2914: LD_INT 6
2916: DOUBLE
2917: EQUAL
2918: IFTRUE 2922
2920: GO 2929
2922: POP
// hHackChangeYourSide ; 7 :
2923: CALL 14829 0 0
2927: GO 2960
2929: LD_INT 7
2931: DOUBLE
2932: EQUAL
2933: IFTRUE 2937
2935: GO 2944
2937: POP
// hHackChangeUnitSide ; 8 :
2938: CALL 14871 0 0
2942: GO 2960
2944: LD_INT 8
2946: DOUBLE
2947: EQUAL
2948: IFTRUE 2952
2950: GO 2959
2952: POP
// hHackFog ; end ;
2953: CALL 14972 0 0
2957: GO 2960
2959: POP
// end ; end ;
2960: PPOPN 6
2962: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
2963: GO 2965
2965: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
2966: LD_STRING initStreamRollete();
2968: PPUSH
2969: CALL_OW 559
// InitStreamMode ;
2973: CALL 2982 0 0
// DefineStreamItems ( ) ;
2977: CALL 3422 0 0
// end ;
2981: END
// function InitStreamMode ; begin
2982: LD_INT 0
2984: PPUSH
// streamModeActive := false ;
2985: LD_ADDR_EXP 8
2989: PUSH
2990: LD_INT 0
2992: ST_TO_ADDR
// normalCounter := 36 ;
2993: LD_ADDR_EXP 9
2997: PUSH
2998: LD_INT 36
3000: ST_TO_ADDR
// hardcoreCounter := 16 ;
3001: LD_ADDR_EXP 10
3005: PUSH
3006: LD_INT 16
3008: ST_TO_ADDR
// sRocket := false ;
3009: LD_ADDR_EXP 13
3013: PUSH
3014: LD_INT 0
3016: ST_TO_ADDR
// sSpeed := false ;
3017: LD_ADDR_EXP 12
3021: PUSH
3022: LD_INT 0
3024: ST_TO_ADDR
// sEngine := false ;
3025: LD_ADDR_EXP 14
3029: PUSH
3030: LD_INT 0
3032: ST_TO_ADDR
// sSpec := false ;
3033: LD_ADDR_EXP 11
3037: PUSH
3038: LD_INT 0
3040: ST_TO_ADDR
// sLevel := false ;
3041: LD_ADDR_EXP 15
3045: PUSH
3046: LD_INT 0
3048: ST_TO_ADDR
// sArmoury := false ;
3049: LD_ADDR_EXP 16
3053: PUSH
3054: LD_INT 0
3056: ST_TO_ADDR
// sRadar := false ;
3057: LD_ADDR_EXP 17
3061: PUSH
3062: LD_INT 0
3064: ST_TO_ADDR
// sBunker := false ;
3065: LD_ADDR_EXP 18
3069: PUSH
3070: LD_INT 0
3072: ST_TO_ADDR
// sHack := false ;
3073: LD_ADDR_EXP 19
3077: PUSH
3078: LD_INT 0
3080: ST_TO_ADDR
// sFire := false ;
3081: LD_ADDR_EXP 20
3085: PUSH
3086: LD_INT 0
3088: ST_TO_ADDR
// sRefresh := false ;
3089: LD_ADDR_EXP 21
3093: PUSH
3094: LD_INT 0
3096: ST_TO_ADDR
// sExp := false ;
3097: LD_ADDR_EXP 22
3101: PUSH
3102: LD_INT 0
3104: ST_TO_ADDR
// sDepot := false ;
3105: LD_ADDR_EXP 23
3109: PUSH
3110: LD_INT 0
3112: ST_TO_ADDR
// sFlag := false ;
3113: LD_ADDR_EXP 24
3117: PUSH
3118: LD_INT 0
3120: ST_TO_ADDR
// sKamikadze := false ;
3121: LD_ADDR_EXP 32
3125: PUSH
3126: LD_INT 0
3128: ST_TO_ADDR
// sTroll := false ;
3129: LD_ADDR_EXP 33
3133: PUSH
3134: LD_INT 0
3136: ST_TO_ADDR
// sSlow := false ;
3137: LD_ADDR_EXP 34
3141: PUSH
3142: LD_INT 0
3144: ST_TO_ADDR
// sLack := false ;
3145: LD_ADDR_EXP 35
3149: PUSH
3150: LD_INT 0
3152: ST_TO_ADDR
// sTank := false ;
3153: LD_ADDR_EXP 37
3157: PUSH
3158: LD_INT 0
3160: ST_TO_ADDR
// sRemote := false ;
3161: LD_ADDR_EXP 38
3165: PUSH
3166: LD_INT 0
3168: ST_TO_ADDR
// sPowell := false ;
3169: LD_ADDR_EXP 39
3173: PUSH
3174: LD_INT 0
3176: ST_TO_ADDR
// sTeleport := false ;
3177: LD_ADDR_EXP 42
3181: PUSH
3182: LD_INT 0
3184: ST_TO_ADDR
// sOilTower := false ;
3185: LD_ADDR_EXP 44
3189: PUSH
3190: LD_INT 0
3192: ST_TO_ADDR
// sShovel := false ;
3193: LD_ADDR_EXP 45
3197: PUSH
3198: LD_INT 0
3200: ST_TO_ADDR
// sSheik := false ;
3201: LD_ADDR_EXP 46
3205: PUSH
3206: LD_INT 0
3208: ST_TO_ADDR
// sEarthquake := false ;
3209: LD_ADDR_EXP 48
3213: PUSH
3214: LD_INT 0
3216: ST_TO_ADDR
// sAI := false ;
3217: LD_ADDR_EXP 49
3221: PUSH
3222: LD_INT 0
3224: ST_TO_ADDR
// sCargo := false ;
3225: LD_ADDR_EXP 52
3229: PUSH
3230: LD_INT 0
3232: ST_TO_ADDR
// sDLaser := false ;
3233: LD_ADDR_EXP 53
3237: PUSH
3238: LD_INT 0
3240: ST_TO_ADDR
// sExchange := false ;
3241: LD_ADDR_EXP 54
3245: PUSH
3246: LD_INT 0
3248: ST_TO_ADDR
// sFac := false ;
3249: LD_ADDR_EXP 55
3253: PUSH
3254: LD_INT 0
3256: ST_TO_ADDR
// sPower := false ;
3257: LD_ADDR_EXP 56
3261: PUSH
3262: LD_INT 0
3264: ST_TO_ADDR
// sRandom := false ;
3265: LD_ADDR_EXP 57
3269: PUSH
3270: LD_INT 0
3272: ST_TO_ADDR
// sShield := false ;
3273: LD_ADDR_EXP 58
3277: PUSH
3278: LD_INT 0
3280: ST_TO_ADDR
// sTime := false ;
3281: LD_ADDR_EXP 59
3285: PUSH
3286: LD_INT 0
3288: ST_TO_ADDR
// sTools := false ;
3289: LD_ADDR_EXP 60
3293: PUSH
3294: LD_INT 0
3296: ST_TO_ADDR
// sSold := false ;
3297: LD_ADDR_EXP 25
3301: PUSH
3302: LD_INT 0
3304: ST_TO_ADDR
// sDiff := false ;
3305: LD_ADDR_EXP 26
3309: PUSH
3310: LD_INT 0
3312: ST_TO_ADDR
// sFog := false ;
3313: LD_ADDR_EXP 29
3317: PUSH
3318: LD_INT 0
3320: ST_TO_ADDR
// sReset := false ;
3321: LD_ADDR_EXP 30
3325: PUSH
3326: LD_INT 0
3328: ST_TO_ADDR
// sSun := false ;
3329: LD_ADDR_EXP 31
3333: PUSH
3334: LD_INT 0
3336: ST_TO_ADDR
// sTiger := false ;
3337: LD_ADDR_EXP 27
3341: PUSH
3342: LD_INT 0
3344: ST_TO_ADDR
// sBomb := false ;
3345: LD_ADDR_EXP 28
3349: PUSH
3350: LD_INT 0
3352: ST_TO_ADDR
// sWound := false ;
3353: LD_ADDR_EXP 36
3357: PUSH
3358: LD_INT 0
3360: ST_TO_ADDR
// sBetray := false ;
3361: LD_ADDR_EXP 40
3365: PUSH
3366: LD_INT 0
3368: ST_TO_ADDR
// sContamin := false ;
3369: LD_ADDR_EXP 41
3373: PUSH
3374: LD_INT 0
3376: ST_TO_ADDR
// sOil := false ;
3377: LD_ADDR_EXP 43
3381: PUSH
3382: LD_INT 0
3384: ST_TO_ADDR
// sStu := false ;
3385: LD_ADDR_EXP 47
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// sBazooka := false ;
3393: LD_ADDR_EXP 50
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// sMortar := false ;
3401: LD_ADDR_EXP 51
3405: PUSH
3406: LD_INT 0
3408: ST_TO_ADDR
// sRanger := false ;
3409: LD_ADDR_EXP 61
3413: PUSH
3414: LD_INT 0
3416: ST_TO_ADDR
// end ;
3417: LD_VAR 0 1
3421: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
3422: LD_INT 0
3424: PPUSH
3425: PPUSH
3426: PPUSH
3427: PPUSH
3428: PPUSH
// result := [ ] ;
3429: LD_ADDR_VAR 0 1
3433: PUSH
3434: EMPTY
3435: ST_TO_ADDR
// if campaign_id = 1 then
3436: LD_OWVAR 69
3440: PUSH
3441: LD_INT 1
3443: EQUAL
3444: IFFALSE 6382
// begin case mission_number of 1 :
3446: LD_OWVAR 70
3450: PUSH
3451: LD_INT 1
3453: DOUBLE
3454: EQUAL
3455: IFTRUE 3459
3457: GO 3523
3459: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
3460: LD_ADDR_VAR 0 1
3464: PUSH
3465: LD_INT 2
3467: PUSH
3468: LD_INT 4
3470: PUSH
3471: LD_INT 11
3473: PUSH
3474: LD_INT 12
3476: PUSH
3477: LD_INT 15
3479: PUSH
3480: LD_INT 16
3482: PUSH
3483: LD_INT 22
3485: PUSH
3486: LD_INT 23
3488: PUSH
3489: LD_INT 26
3491: PUSH
3492: EMPTY
3493: LIST
3494: LIST
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: LIST
3501: LIST
3502: PUSH
3503: LD_INT 101
3505: PUSH
3506: LD_INT 102
3508: PUSH
3509: LD_INT 106
3511: PUSH
3512: EMPTY
3513: LIST
3514: LIST
3515: LIST
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: ST_TO_ADDR
3521: GO 6380
3523: LD_INT 2
3525: DOUBLE
3526: EQUAL
3527: IFTRUE 3531
3529: GO 3603
3531: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
3532: LD_ADDR_VAR 0 1
3536: PUSH
3537: LD_INT 2
3539: PUSH
3540: LD_INT 4
3542: PUSH
3543: LD_INT 11
3545: PUSH
3546: LD_INT 12
3548: PUSH
3549: LD_INT 15
3551: PUSH
3552: LD_INT 16
3554: PUSH
3555: LD_INT 22
3557: PUSH
3558: LD_INT 23
3560: PUSH
3561: LD_INT 26
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: PUSH
3575: LD_INT 101
3577: PUSH
3578: LD_INT 102
3580: PUSH
3581: LD_INT 105
3583: PUSH
3584: LD_INT 106
3586: PUSH
3587: LD_INT 108
3589: PUSH
3590: EMPTY
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: LIST
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: ST_TO_ADDR
3601: GO 6380
3603: LD_INT 3
3605: DOUBLE
3606: EQUAL
3607: IFTRUE 3611
3609: GO 3687
3611: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
3612: LD_ADDR_VAR 0 1
3616: PUSH
3617: LD_INT 2
3619: PUSH
3620: LD_INT 4
3622: PUSH
3623: LD_INT 5
3625: PUSH
3626: LD_INT 11
3628: PUSH
3629: LD_INT 12
3631: PUSH
3632: LD_INT 15
3634: PUSH
3635: LD_INT 16
3637: PUSH
3638: LD_INT 22
3640: PUSH
3641: LD_INT 26
3643: PUSH
3644: LD_INT 36
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: LIST
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: PUSH
3659: LD_INT 101
3661: PUSH
3662: LD_INT 102
3664: PUSH
3665: LD_INT 105
3667: PUSH
3668: LD_INT 106
3670: PUSH
3671: LD_INT 108
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: LIST
3679: LIST
3680: PUSH
3681: EMPTY
3682: LIST
3683: LIST
3684: ST_TO_ADDR
3685: GO 6380
3687: LD_INT 4
3689: DOUBLE
3690: EQUAL
3691: IFTRUE 3695
3693: GO 3779
3695: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
3696: LD_ADDR_VAR 0 1
3700: PUSH
3701: LD_INT 2
3703: PUSH
3704: LD_INT 4
3706: PUSH
3707: LD_INT 5
3709: PUSH
3710: LD_INT 8
3712: PUSH
3713: LD_INT 11
3715: PUSH
3716: LD_INT 12
3718: PUSH
3719: LD_INT 15
3721: PUSH
3722: LD_INT 16
3724: PUSH
3725: LD_INT 22
3727: PUSH
3728: LD_INT 23
3730: PUSH
3731: LD_INT 26
3733: PUSH
3734: LD_INT 36
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: LIST
3747: LIST
3748: LIST
3749: LIST
3750: PUSH
3751: LD_INT 101
3753: PUSH
3754: LD_INT 102
3756: PUSH
3757: LD_INT 105
3759: PUSH
3760: LD_INT 106
3762: PUSH
3763: LD_INT 108
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: ST_TO_ADDR
3777: GO 6380
3779: LD_INT 5
3781: DOUBLE
3782: EQUAL
3783: IFTRUE 3787
3785: GO 3887
3787: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
3788: LD_ADDR_VAR 0 1
3792: PUSH
3793: LD_INT 2
3795: PUSH
3796: LD_INT 4
3798: PUSH
3799: LD_INT 5
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 8
3807: PUSH
3808: LD_INT 11
3810: PUSH
3811: LD_INT 12
3813: PUSH
3814: LD_INT 15
3816: PUSH
3817: LD_INT 16
3819: PUSH
3820: LD_INT 22
3822: PUSH
3823: LD_INT 23
3825: PUSH
3826: LD_INT 25
3828: PUSH
3829: LD_INT 26
3831: PUSH
3832: LD_INT 36
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 101
3853: PUSH
3854: LD_INT 102
3856: PUSH
3857: LD_INT 105
3859: PUSH
3860: LD_INT 106
3862: PUSH
3863: LD_INT 108
3865: PUSH
3866: LD_INT 109
3868: PUSH
3869: LD_INT 112
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: LIST
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: ST_TO_ADDR
3885: GO 6380
3887: LD_INT 6
3889: DOUBLE
3890: EQUAL
3891: IFTRUE 3895
3893: GO 4015
3895: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
3896: LD_ADDR_VAR 0 1
3900: PUSH
3901: LD_INT 2
3903: PUSH
3904: LD_INT 4
3906: PUSH
3907: LD_INT 5
3909: PUSH
3910: LD_INT 6
3912: PUSH
3913: LD_INT 8
3915: PUSH
3916: LD_INT 11
3918: PUSH
3919: LD_INT 12
3921: PUSH
3922: LD_INT 15
3924: PUSH
3925: LD_INT 16
3927: PUSH
3928: LD_INT 20
3930: PUSH
3931: LD_INT 21
3933: PUSH
3934: LD_INT 22
3936: PUSH
3937: LD_INT 23
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 26
3945: PUSH
3946: LD_INT 30
3948: PUSH
3949: LD_INT 31
3951: PUSH
3952: LD_INT 32
3954: PUSH
3955: LD_INT 36
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: LIST
3962: LIST
3963: LIST
3964: LIST
3965: LIST
3966: LIST
3967: LIST
3968: LIST
3969: LIST
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: PUSH
3979: LD_INT 101
3981: PUSH
3982: LD_INT 102
3984: PUSH
3985: LD_INT 105
3987: PUSH
3988: LD_INT 106
3990: PUSH
3991: LD_INT 108
3993: PUSH
3994: LD_INT 109
3996: PUSH
3997: LD_INT 112
3999: PUSH
4000: EMPTY
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: LIST
4007: LIST
4008: PUSH
4009: EMPTY
4010: LIST
4011: LIST
4012: ST_TO_ADDR
4013: GO 6380
4015: LD_INT 7
4017: DOUBLE
4018: EQUAL
4019: IFTRUE 4023
4021: GO 4123
4023: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
4024: LD_ADDR_VAR 0 1
4028: PUSH
4029: LD_INT 2
4031: PUSH
4032: LD_INT 4
4034: PUSH
4035: LD_INT 5
4037: PUSH
4038: LD_INT 7
4040: PUSH
4041: LD_INT 11
4043: PUSH
4044: LD_INT 12
4046: PUSH
4047: LD_INT 15
4049: PUSH
4050: LD_INT 16
4052: PUSH
4053: LD_INT 20
4055: PUSH
4056: LD_INT 21
4058: PUSH
4059: LD_INT 22
4061: PUSH
4062: LD_INT 23
4064: PUSH
4065: LD_INT 25
4067: PUSH
4068: LD_INT 26
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: LIST
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 101
4089: PUSH
4090: LD_INT 102
4092: PUSH
4093: LD_INT 103
4095: PUSH
4096: LD_INT 105
4098: PUSH
4099: LD_INT 106
4101: PUSH
4102: LD_INT 108
4104: PUSH
4105: LD_INT 112
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: LIST
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: ST_TO_ADDR
4121: GO 6380
4123: LD_INT 8
4125: DOUBLE
4126: EQUAL
4127: IFTRUE 4131
4129: GO 4259
4131: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
4132: LD_ADDR_VAR 0 1
4136: PUSH
4137: LD_INT 2
4139: PUSH
4140: LD_INT 4
4142: PUSH
4143: LD_INT 5
4145: PUSH
4146: LD_INT 6
4148: PUSH
4149: LD_INT 7
4151: PUSH
4152: LD_INT 8
4154: PUSH
4155: LD_INT 11
4157: PUSH
4158: LD_INT 12
4160: PUSH
4161: LD_INT 15
4163: PUSH
4164: LD_INT 16
4166: PUSH
4167: LD_INT 20
4169: PUSH
4170: LD_INT 21
4172: PUSH
4173: LD_INT 22
4175: PUSH
4176: LD_INT 23
4178: PUSH
4179: LD_INT 25
4181: PUSH
4182: LD_INT 26
4184: PUSH
4185: LD_INT 30
4187: PUSH
4188: LD_INT 31
4190: PUSH
4191: LD_INT 32
4193: PUSH
4194: LD_INT 36
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: LIST
4201: LIST
4202: LIST
4203: LIST
4204: LIST
4205: LIST
4206: LIST
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: LIST
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 101
4221: PUSH
4222: LD_INT 102
4224: PUSH
4225: LD_INT 103
4227: PUSH
4228: LD_INT 105
4230: PUSH
4231: LD_INT 106
4233: PUSH
4234: LD_INT 108
4236: PUSH
4237: LD_INT 109
4239: PUSH
4240: LD_INT 112
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: LIST
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: ST_TO_ADDR
4257: GO 6380
4259: LD_INT 9
4261: DOUBLE
4262: EQUAL
4263: IFTRUE 4267
4265: GO 4403
4267: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
4268: LD_ADDR_VAR 0 1
4272: PUSH
4273: LD_INT 2
4275: PUSH
4276: LD_INT 4
4278: PUSH
4279: LD_INT 5
4281: PUSH
4282: LD_INT 6
4284: PUSH
4285: LD_INT 7
4287: PUSH
4288: LD_INT 8
4290: PUSH
4291: LD_INT 11
4293: PUSH
4294: LD_INT 12
4296: PUSH
4297: LD_INT 15
4299: PUSH
4300: LD_INT 16
4302: PUSH
4303: LD_INT 20
4305: PUSH
4306: LD_INT 21
4308: PUSH
4309: LD_INT 22
4311: PUSH
4312: LD_INT 23
4314: PUSH
4315: LD_INT 25
4317: PUSH
4318: LD_INT 26
4320: PUSH
4321: LD_INT 28
4323: PUSH
4324: LD_INT 30
4326: PUSH
4327: LD_INT 31
4329: PUSH
4330: LD_INT 32
4332: PUSH
4333: LD_INT 36
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: LIST
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: LIST
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 101
4361: PUSH
4362: LD_INT 102
4364: PUSH
4365: LD_INT 103
4367: PUSH
4368: LD_INT 105
4370: PUSH
4371: LD_INT 106
4373: PUSH
4374: LD_INT 108
4376: PUSH
4377: LD_INT 109
4379: PUSH
4380: LD_INT 112
4382: PUSH
4383: LD_INT 114
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: EMPTY
4398: LIST
4399: LIST
4400: ST_TO_ADDR
4401: GO 6380
4403: LD_INT 10
4405: DOUBLE
4406: EQUAL
4407: IFTRUE 4411
4409: GO 4595
4411: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
4412: LD_ADDR_VAR 0 1
4416: PUSH
4417: LD_INT 2
4419: PUSH
4420: LD_INT 4
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 6
4428: PUSH
4429: LD_INT 7
4431: PUSH
4432: LD_INT 8
4434: PUSH
4435: LD_INT 9
4437: PUSH
4438: LD_INT 10
4440: PUSH
4441: LD_INT 11
4443: PUSH
4444: LD_INT 12
4446: PUSH
4447: LD_INT 13
4449: PUSH
4450: LD_INT 14
4452: PUSH
4453: LD_INT 15
4455: PUSH
4456: LD_INT 16
4458: PUSH
4459: LD_INT 17
4461: PUSH
4462: LD_INT 18
4464: PUSH
4465: LD_INT 19
4467: PUSH
4468: LD_INT 20
4470: PUSH
4471: LD_INT 21
4473: PUSH
4474: LD_INT 22
4476: PUSH
4477: LD_INT 23
4479: PUSH
4480: LD_INT 24
4482: PUSH
4483: LD_INT 25
4485: PUSH
4486: LD_INT 26
4488: PUSH
4489: LD_INT 28
4491: PUSH
4492: LD_INT 30
4494: PUSH
4495: LD_INT 31
4497: PUSH
4498: LD_INT 32
4500: PUSH
4501: LD_INT 36
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: PUSH
4535: LD_INT 101
4537: PUSH
4538: LD_INT 102
4540: PUSH
4541: LD_INT 103
4543: PUSH
4544: LD_INT 104
4546: PUSH
4547: LD_INT 105
4549: PUSH
4550: LD_INT 106
4552: PUSH
4553: LD_INT 107
4555: PUSH
4556: LD_INT 108
4558: PUSH
4559: LD_INT 109
4561: PUSH
4562: LD_INT 110
4564: PUSH
4565: LD_INT 111
4567: PUSH
4568: LD_INT 112
4570: PUSH
4571: LD_INT 114
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: LIST
4586: LIST
4587: LIST
4588: PUSH
4589: EMPTY
4590: LIST
4591: LIST
4592: ST_TO_ADDR
4593: GO 6380
4595: LD_INT 11
4597: DOUBLE
4598: EQUAL
4599: IFTRUE 4603
4601: GO 4795
4603: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 2
4611: PUSH
4612: LD_INT 3
4614: PUSH
4615: LD_INT 4
4617: PUSH
4618: LD_INT 5
4620: PUSH
4621: LD_INT 6
4623: PUSH
4624: LD_INT 7
4626: PUSH
4627: LD_INT 8
4629: PUSH
4630: LD_INT 9
4632: PUSH
4633: LD_INT 10
4635: PUSH
4636: LD_INT 11
4638: PUSH
4639: LD_INT 12
4641: PUSH
4642: LD_INT 13
4644: PUSH
4645: LD_INT 14
4647: PUSH
4648: LD_INT 15
4650: PUSH
4651: LD_INT 16
4653: PUSH
4654: LD_INT 17
4656: PUSH
4657: LD_INT 18
4659: PUSH
4660: LD_INT 19
4662: PUSH
4663: LD_INT 20
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 22
4671: PUSH
4672: LD_INT 23
4674: PUSH
4675: LD_INT 24
4677: PUSH
4678: LD_INT 25
4680: PUSH
4681: LD_INT 26
4683: PUSH
4684: LD_INT 28
4686: PUSH
4687: LD_INT 30
4689: PUSH
4690: LD_INT 31
4692: PUSH
4693: LD_INT 32
4695: PUSH
4696: LD_INT 34
4698: PUSH
4699: LD_INT 36
4701: PUSH
4702: EMPTY
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: LIST
4711: LIST
4712: LIST
4713: LIST
4714: LIST
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 101
4737: PUSH
4738: LD_INT 102
4740: PUSH
4741: LD_INT 103
4743: PUSH
4744: LD_INT 104
4746: PUSH
4747: LD_INT 105
4749: PUSH
4750: LD_INT 106
4752: PUSH
4753: LD_INT 107
4755: PUSH
4756: LD_INT 108
4758: PUSH
4759: LD_INT 109
4761: PUSH
4762: LD_INT 110
4764: PUSH
4765: LD_INT 111
4767: PUSH
4768: LD_INT 112
4770: PUSH
4771: LD_INT 114
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: ST_TO_ADDR
4793: GO 6380
4795: LD_INT 12
4797: DOUBLE
4798: EQUAL
4799: IFTRUE 4803
4801: GO 5011
4803: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
4804: LD_ADDR_VAR 0 1
4808: PUSH
4809: LD_INT 1
4811: PUSH
4812: LD_INT 2
4814: PUSH
4815: LD_INT 3
4817: PUSH
4818: LD_INT 4
4820: PUSH
4821: LD_INT 5
4823: PUSH
4824: LD_INT 6
4826: PUSH
4827: LD_INT 7
4829: PUSH
4830: LD_INT 8
4832: PUSH
4833: LD_INT 9
4835: PUSH
4836: LD_INT 10
4838: PUSH
4839: LD_INT 11
4841: PUSH
4842: LD_INT 12
4844: PUSH
4845: LD_INT 13
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 15
4853: PUSH
4854: LD_INT 16
4856: PUSH
4857: LD_INT 17
4859: PUSH
4860: LD_INT 18
4862: PUSH
4863: LD_INT 19
4865: PUSH
4866: LD_INT 20
4868: PUSH
4869: LD_INT 21
4871: PUSH
4872: LD_INT 22
4874: PUSH
4875: LD_INT 23
4877: PUSH
4878: LD_INT 24
4880: PUSH
4881: LD_INT 25
4883: PUSH
4884: LD_INT 26
4886: PUSH
4887: LD_INT 27
4889: PUSH
4890: LD_INT 28
4892: PUSH
4893: LD_INT 30
4895: PUSH
4896: LD_INT 31
4898: PUSH
4899: LD_INT 32
4901: PUSH
4902: LD_INT 33
4904: PUSH
4905: LD_INT 34
4907: PUSH
4908: LD_INT 36
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: LIST
4915: LIST
4916: LIST
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: LIST
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: LIST
4934: LIST
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 101
4949: PUSH
4950: LD_INT 102
4952: PUSH
4953: LD_INT 103
4955: PUSH
4956: LD_INT 104
4958: PUSH
4959: LD_INT 105
4961: PUSH
4962: LD_INT 106
4964: PUSH
4965: LD_INT 107
4967: PUSH
4968: LD_INT 108
4970: PUSH
4971: LD_INT 109
4973: PUSH
4974: LD_INT 110
4976: PUSH
4977: LD_INT 111
4979: PUSH
4980: LD_INT 112
4982: PUSH
4983: LD_INT 113
4985: PUSH
4986: LD_INT 114
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: PUSH
5005: EMPTY
5006: LIST
5007: LIST
5008: ST_TO_ADDR
5009: GO 6380
5011: LD_INT 13
5013: DOUBLE
5014: EQUAL
5015: IFTRUE 5019
5017: GO 5215
5019: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
5020: LD_ADDR_VAR 0 1
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 3
5033: PUSH
5034: LD_INT 4
5036: PUSH
5037: LD_INT 5
5039: PUSH
5040: LD_INT 8
5042: PUSH
5043: LD_INT 9
5045: PUSH
5046: LD_INT 10
5048: PUSH
5049: LD_INT 11
5051: PUSH
5052: LD_INT 12
5054: PUSH
5055: LD_INT 14
5057: PUSH
5058: LD_INT 15
5060: PUSH
5061: LD_INT 16
5063: PUSH
5064: LD_INT 17
5066: PUSH
5067: LD_INT 18
5069: PUSH
5070: LD_INT 19
5072: PUSH
5073: LD_INT 20
5075: PUSH
5076: LD_INT 21
5078: PUSH
5079: LD_INT 22
5081: PUSH
5082: LD_INT 23
5084: PUSH
5085: LD_INT 24
5087: PUSH
5088: LD_INT 25
5090: PUSH
5091: LD_INT 26
5093: PUSH
5094: LD_INT 27
5096: PUSH
5097: LD_INT 28
5099: PUSH
5100: LD_INT 30
5102: PUSH
5103: LD_INT 31
5105: PUSH
5106: LD_INT 32
5108: PUSH
5109: LD_INT 33
5111: PUSH
5112: LD_INT 34
5114: PUSH
5115: LD_INT 36
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: LIST
5124: LIST
5125: LIST
5126: LIST
5127: LIST
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: LIST
5137: LIST
5138: LIST
5139: LIST
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: PUSH
5151: LD_INT 101
5153: PUSH
5154: LD_INT 102
5156: PUSH
5157: LD_INT 103
5159: PUSH
5160: LD_INT 104
5162: PUSH
5163: LD_INT 105
5165: PUSH
5166: LD_INT 106
5168: PUSH
5169: LD_INT 107
5171: PUSH
5172: LD_INT 108
5174: PUSH
5175: LD_INT 109
5177: PUSH
5178: LD_INT 110
5180: PUSH
5181: LD_INT 111
5183: PUSH
5184: LD_INT 112
5186: PUSH
5187: LD_INT 113
5189: PUSH
5190: LD_INT 114
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: ST_TO_ADDR
5213: GO 6380
5215: LD_INT 14
5217: DOUBLE
5218: EQUAL
5219: IFTRUE 5223
5221: GO 5435
5223: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
5224: LD_ADDR_VAR 0 1
5228: PUSH
5229: LD_INT 1
5231: PUSH
5232: LD_INT 2
5234: PUSH
5235: LD_INT 3
5237: PUSH
5238: LD_INT 4
5240: PUSH
5241: LD_INT 5
5243: PUSH
5244: LD_INT 6
5246: PUSH
5247: LD_INT 7
5249: PUSH
5250: LD_INT 8
5252: PUSH
5253: LD_INT 9
5255: PUSH
5256: LD_INT 10
5258: PUSH
5259: LD_INT 11
5261: PUSH
5262: LD_INT 12
5264: PUSH
5265: LD_INT 13
5267: PUSH
5268: LD_INT 14
5270: PUSH
5271: LD_INT 15
5273: PUSH
5274: LD_INT 16
5276: PUSH
5277: LD_INT 17
5279: PUSH
5280: LD_INT 18
5282: PUSH
5283: LD_INT 19
5285: PUSH
5286: LD_INT 20
5288: PUSH
5289: LD_INT 21
5291: PUSH
5292: LD_INT 22
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 24
5300: PUSH
5301: LD_INT 25
5303: PUSH
5304: LD_INT 26
5306: PUSH
5307: LD_INT 27
5309: PUSH
5310: LD_INT 28
5312: PUSH
5313: LD_INT 29
5315: PUSH
5316: LD_INT 30
5318: PUSH
5319: LD_INT 31
5321: PUSH
5322: LD_INT 32
5324: PUSH
5325: LD_INT 33
5327: PUSH
5328: LD_INT 34
5330: PUSH
5331: LD_INT 36
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: LIST
5355: LIST
5356: LIST
5357: LIST
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: LIST
5368: LIST
5369: LIST
5370: PUSH
5371: LD_INT 101
5373: PUSH
5374: LD_INT 102
5376: PUSH
5377: LD_INT 103
5379: PUSH
5380: LD_INT 104
5382: PUSH
5383: LD_INT 105
5385: PUSH
5386: LD_INT 106
5388: PUSH
5389: LD_INT 107
5391: PUSH
5392: LD_INT 108
5394: PUSH
5395: LD_INT 109
5397: PUSH
5398: LD_INT 110
5400: PUSH
5401: LD_INT 111
5403: PUSH
5404: LD_INT 112
5406: PUSH
5407: LD_INT 113
5409: PUSH
5410: LD_INT 114
5412: PUSH
5413: EMPTY
5414: LIST
5415: LIST
5416: LIST
5417: LIST
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: ST_TO_ADDR
5433: GO 6380
5435: LD_INT 15
5437: DOUBLE
5438: EQUAL
5439: IFTRUE 5443
5441: GO 5655
5443: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
5444: LD_ADDR_VAR 0 1
5448: PUSH
5449: LD_INT 1
5451: PUSH
5452: LD_INT 2
5454: PUSH
5455: LD_INT 3
5457: PUSH
5458: LD_INT 4
5460: PUSH
5461: LD_INT 5
5463: PUSH
5464: LD_INT 6
5466: PUSH
5467: LD_INT 7
5469: PUSH
5470: LD_INT 8
5472: PUSH
5473: LD_INT 9
5475: PUSH
5476: LD_INT 10
5478: PUSH
5479: LD_INT 11
5481: PUSH
5482: LD_INT 12
5484: PUSH
5485: LD_INT 13
5487: PUSH
5488: LD_INT 14
5490: PUSH
5491: LD_INT 15
5493: PUSH
5494: LD_INT 16
5496: PUSH
5497: LD_INT 17
5499: PUSH
5500: LD_INT 18
5502: PUSH
5503: LD_INT 19
5505: PUSH
5506: LD_INT 20
5508: PUSH
5509: LD_INT 21
5511: PUSH
5512: LD_INT 22
5514: PUSH
5515: LD_INT 23
5517: PUSH
5518: LD_INT 24
5520: PUSH
5521: LD_INT 25
5523: PUSH
5524: LD_INT 26
5526: PUSH
5527: LD_INT 27
5529: PUSH
5530: LD_INT 28
5532: PUSH
5533: LD_INT 29
5535: PUSH
5536: LD_INT 30
5538: PUSH
5539: LD_INT 31
5541: PUSH
5542: LD_INT 32
5544: PUSH
5545: LD_INT 33
5547: PUSH
5548: LD_INT 34
5550: PUSH
5551: LD_INT 36
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: LIST
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: LIST
5580: LIST
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_INT 101
5593: PUSH
5594: LD_INT 102
5596: PUSH
5597: LD_INT 103
5599: PUSH
5600: LD_INT 104
5602: PUSH
5603: LD_INT 105
5605: PUSH
5606: LD_INT 106
5608: PUSH
5609: LD_INT 107
5611: PUSH
5612: LD_INT 108
5614: PUSH
5615: LD_INT 109
5617: PUSH
5618: LD_INT 110
5620: PUSH
5621: LD_INT 111
5623: PUSH
5624: LD_INT 112
5626: PUSH
5627: LD_INT 113
5629: PUSH
5630: LD_INT 114
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: LIST
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: ST_TO_ADDR
5653: GO 6380
5655: LD_INT 16
5657: DOUBLE
5658: EQUAL
5659: IFTRUE 5663
5661: GO 5787
5663: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
5664: LD_ADDR_VAR 0 1
5668: PUSH
5669: LD_INT 2
5671: PUSH
5672: LD_INT 4
5674: PUSH
5675: LD_INT 5
5677: PUSH
5678: LD_INT 7
5680: PUSH
5681: LD_INT 11
5683: PUSH
5684: LD_INT 12
5686: PUSH
5687: LD_INT 15
5689: PUSH
5690: LD_INT 16
5692: PUSH
5693: LD_INT 20
5695: PUSH
5696: LD_INT 21
5698: PUSH
5699: LD_INT 22
5701: PUSH
5702: LD_INT 23
5704: PUSH
5705: LD_INT 25
5707: PUSH
5708: LD_INT 26
5710: PUSH
5711: LD_INT 30
5713: PUSH
5714: LD_INT 31
5716: PUSH
5717: LD_INT 32
5719: PUSH
5720: LD_INT 33
5722: PUSH
5723: LD_INT 34
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 101
5749: PUSH
5750: LD_INT 102
5752: PUSH
5753: LD_INT 103
5755: PUSH
5756: LD_INT 106
5758: PUSH
5759: LD_INT 108
5761: PUSH
5762: LD_INT 112
5764: PUSH
5765: LD_INT 113
5767: PUSH
5768: LD_INT 114
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: LIST
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: ST_TO_ADDR
5785: GO 6380
5787: LD_INT 17
5789: DOUBLE
5790: EQUAL
5791: IFTRUE 5795
5793: GO 6007
5795: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
5796: LD_ADDR_VAR 0 1
5800: PUSH
5801: LD_INT 1
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 3
5809: PUSH
5810: LD_INT 4
5812: PUSH
5813: LD_INT 5
5815: PUSH
5816: LD_INT 6
5818: PUSH
5819: LD_INT 7
5821: PUSH
5822: LD_INT 8
5824: PUSH
5825: LD_INT 9
5827: PUSH
5828: LD_INT 10
5830: PUSH
5831: LD_INT 11
5833: PUSH
5834: LD_INT 12
5836: PUSH
5837: LD_INT 13
5839: PUSH
5840: LD_INT 14
5842: PUSH
5843: LD_INT 15
5845: PUSH
5846: LD_INT 16
5848: PUSH
5849: LD_INT 17
5851: PUSH
5852: LD_INT 18
5854: PUSH
5855: LD_INT 19
5857: PUSH
5858: LD_INT 20
5860: PUSH
5861: LD_INT 21
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 23
5869: PUSH
5870: LD_INT 24
5872: PUSH
5873: LD_INT 25
5875: PUSH
5876: LD_INT 26
5878: PUSH
5879: LD_INT 27
5881: PUSH
5882: LD_INT 28
5884: PUSH
5885: LD_INT 29
5887: PUSH
5888: LD_INT 30
5890: PUSH
5891: LD_INT 31
5893: PUSH
5894: LD_INT 32
5896: PUSH
5897: LD_INT 33
5899: PUSH
5900: LD_INT 34
5902: PUSH
5903: LD_INT 36
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 101
5945: PUSH
5946: LD_INT 102
5948: PUSH
5949: LD_INT 103
5951: PUSH
5952: LD_INT 104
5954: PUSH
5955: LD_INT 105
5957: PUSH
5958: LD_INT 106
5960: PUSH
5961: LD_INT 107
5963: PUSH
5964: LD_INT 108
5966: PUSH
5967: LD_INT 109
5969: PUSH
5970: LD_INT 110
5972: PUSH
5973: LD_INT 111
5975: PUSH
5976: LD_INT 112
5978: PUSH
5979: LD_INT 113
5981: PUSH
5982: LD_INT 114
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: ST_TO_ADDR
6005: GO 6380
6007: LD_INT 18
6009: DOUBLE
6010: EQUAL
6011: IFTRUE 6015
6013: GO 6151
6015: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
6016: LD_ADDR_VAR 0 1
6020: PUSH
6021: LD_INT 2
6023: PUSH
6024: LD_INT 4
6026: PUSH
6027: LD_INT 5
6029: PUSH
6030: LD_INT 7
6032: PUSH
6033: LD_INT 11
6035: PUSH
6036: LD_INT 12
6038: PUSH
6039: LD_INT 15
6041: PUSH
6042: LD_INT 16
6044: PUSH
6045: LD_INT 20
6047: PUSH
6048: LD_INT 21
6050: PUSH
6051: LD_INT 22
6053: PUSH
6054: LD_INT 23
6056: PUSH
6057: LD_INT 25
6059: PUSH
6060: LD_INT 26
6062: PUSH
6063: LD_INT 30
6065: PUSH
6066: LD_INT 31
6068: PUSH
6069: LD_INT 32
6071: PUSH
6072: LD_INT 33
6074: PUSH
6075: LD_INT 34
6077: PUSH
6078: LD_INT 35
6080: PUSH
6081: LD_INT 36
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: LIST
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 101
6109: PUSH
6110: LD_INT 102
6112: PUSH
6113: LD_INT 103
6115: PUSH
6116: LD_INT 106
6118: PUSH
6119: LD_INT 108
6121: PUSH
6122: LD_INT 112
6124: PUSH
6125: LD_INT 113
6127: PUSH
6128: LD_INT 114
6130: PUSH
6131: LD_INT 115
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: LIST
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: ST_TO_ADDR
6149: GO 6380
6151: LD_INT 19
6153: DOUBLE
6154: EQUAL
6155: IFTRUE 6159
6157: GO 6379
6159: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
6160: LD_ADDR_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: PUSH
6168: LD_INT 2
6170: PUSH
6171: LD_INT 3
6173: PUSH
6174: LD_INT 4
6176: PUSH
6177: LD_INT 5
6179: PUSH
6180: LD_INT 6
6182: PUSH
6183: LD_INT 7
6185: PUSH
6186: LD_INT 8
6188: PUSH
6189: LD_INT 9
6191: PUSH
6192: LD_INT 10
6194: PUSH
6195: LD_INT 11
6197: PUSH
6198: LD_INT 12
6200: PUSH
6201: LD_INT 13
6203: PUSH
6204: LD_INT 14
6206: PUSH
6207: LD_INT 15
6209: PUSH
6210: LD_INT 16
6212: PUSH
6213: LD_INT 17
6215: PUSH
6216: LD_INT 18
6218: PUSH
6219: LD_INT 19
6221: PUSH
6222: LD_INT 20
6224: PUSH
6225: LD_INT 21
6227: PUSH
6228: LD_INT 22
6230: PUSH
6231: LD_INT 23
6233: PUSH
6234: LD_INT 24
6236: PUSH
6237: LD_INT 25
6239: PUSH
6240: LD_INT 26
6242: PUSH
6243: LD_INT 27
6245: PUSH
6246: LD_INT 28
6248: PUSH
6249: LD_INT 29
6251: PUSH
6252: LD_INT 30
6254: PUSH
6255: LD_INT 31
6257: PUSH
6258: LD_INT 32
6260: PUSH
6261: LD_INT 33
6263: PUSH
6264: LD_INT 34
6266: PUSH
6267: LD_INT 35
6269: PUSH
6270: LD_INT 36
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: LIST
6308: LIST
6309: LIST
6310: PUSH
6311: LD_INT 101
6313: PUSH
6314: LD_INT 102
6316: PUSH
6317: LD_INT 103
6319: PUSH
6320: LD_INT 104
6322: PUSH
6323: LD_INT 105
6325: PUSH
6326: LD_INT 106
6328: PUSH
6329: LD_INT 107
6331: PUSH
6332: LD_INT 108
6334: PUSH
6335: LD_INT 109
6337: PUSH
6338: LD_INT 110
6340: PUSH
6341: LD_INT 111
6343: PUSH
6344: LD_INT 112
6346: PUSH
6347: LD_INT 113
6349: PUSH
6350: LD_INT 114
6352: PUSH
6353: LD_INT 115
6355: PUSH
6356: EMPTY
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: ST_TO_ADDR
6377: GO 6380
6379: POP
// end else
6380: GO 6599
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
6382: LD_ADDR_VAR 0 1
6386: PUSH
6387: LD_INT 1
6389: PUSH
6390: LD_INT 2
6392: PUSH
6393: LD_INT 3
6395: PUSH
6396: LD_INT 4
6398: PUSH
6399: LD_INT 5
6401: PUSH
6402: LD_INT 6
6404: PUSH
6405: LD_INT 7
6407: PUSH
6408: LD_INT 8
6410: PUSH
6411: LD_INT 9
6413: PUSH
6414: LD_INT 10
6416: PUSH
6417: LD_INT 11
6419: PUSH
6420: LD_INT 12
6422: PUSH
6423: LD_INT 13
6425: PUSH
6426: LD_INT 14
6428: PUSH
6429: LD_INT 15
6431: PUSH
6432: LD_INT 16
6434: PUSH
6435: LD_INT 17
6437: PUSH
6438: LD_INT 18
6440: PUSH
6441: LD_INT 19
6443: PUSH
6444: LD_INT 20
6446: PUSH
6447: LD_INT 21
6449: PUSH
6450: LD_INT 22
6452: PUSH
6453: LD_INT 23
6455: PUSH
6456: LD_INT 24
6458: PUSH
6459: LD_INT 25
6461: PUSH
6462: LD_INT 26
6464: PUSH
6465: LD_INT 27
6467: PUSH
6468: LD_INT 28
6470: PUSH
6471: LD_INT 29
6473: PUSH
6474: LD_INT 30
6476: PUSH
6477: LD_INT 31
6479: PUSH
6480: LD_INT 32
6482: PUSH
6483: LD_INT 33
6485: PUSH
6486: LD_INT 34
6488: PUSH
6489: LD_INT 35
6491: PUSH
6492: LD_INT 36
6494: PUSH
6495: EMPTY
6496: LIST
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: LIST
6514: LIST
6515: LIST
6516: LIST
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: LIST
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: LIST
6532: PUSH
6533: LD_INT 101
6535: PUSH
6536: LD_INT 102
6538: PUSH
6539: LD_INT 103
6541: PUSH
6542: LD_INT 104
6544: PUSH
6545: LD_INT 105
6547: PUSH
6548: LD_INT 106
6550: PUSH
6551: LD_INT 107
6553: PUSH
6554: LD_INT 108
6556: PUSH
6557: LD_INT 109
6559: PUSH
6560: LD_INT 110
6562: PUSH
6563: LD_INT 111
6565: PUSH
6566: LD_INT 112
6568: PUSH
6569: LD_INT 113
6571: PUSH
6572: LD_INT 114
6574: PUSH
6575: LD_INT 115
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: LIST
6592: LIST
6593: LIST
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: ST_TO_ADDR
// if result then
6599: LD_VAR 0 1
6603: IFFALSE 6892
// begin normal :=  ;
6605: LD_ADDR_VAR 0 3
6609: PUSH
6610: LD_STRING 
6612: ST_TO_ADDR
// hardcore :=  ;
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: LD_STRING 
6620: ST_TO_ADDR
// for i = 1 to normalCounter do
6621: LD_ADDR_VAR 0 5
6625: PUSH
6626: DOUBLE
6627: LD_INT 1
6629: DEC
6630: ST_TO_ADDR
6631: LD_EXP 9
6635: PUSH
6636: FOR_TO
6637: IFFALSE 6738
// begin tmp := 0 ;
6639: LD_ADDR_VAR 0 2
6643: PUSH
6644: LD_STRING 0
6646: ST_TO_ADDR
// if result [ 1 ] then
6647: LD_VAR 0 1
6651: PUSH
6652: LD_INT 1
6654: ARRAY
6655: IFFALSE 6720
// if result [ 1 ] [ 1 ] = i then
6657: LD_VAR 0 1
6661: PUSH
6662: LD_INT 1
6664: ARRAY
6665: PUSH
6666: LD_INT 1
6668: ARRAY
6669: PUSH
6670: LD_VAR 0 5
6674: EQUAL
6675: IFFALSE 6720
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
6677: LD_ADDR_VAR 0 1
6681: PUSH
6682: LD_VAR 0 1
6686: PPUSH
6687: LD_INT 1
6689: PPUSH
6690: LD_VAR 0 1
6694: PUSH
6695: LD_INT 1
6697: ARRAY
6698: PPUSH
6699: LD_INT 1
6701: PPUSH
6702: CALL_OW 3
6706: PPUSH
6707: CALL_OW 1
6711: ST_TO_ADDR
// tmp := 1 ;
6712: LD_ADDR_VAR 0 2
6716: PUSH
6717: LD_STRING 1
6719: ST_TO_ADDR
// end ; normal := normal & tmp ;
6720: LD_ADDR_VAR 0 3
6724: PUSH
6725: LD_VAR 0 3
6729: PUSH
6730: LD_VAR 0 2
6734: STR
6735: ST_TO_ADDR
// end ;
6736: GO 6636
6738: POP
6739: POP
// for i = 1 to hardcoreCounter do
6740: LD_ADDR_VAR 0 5
6744: PUSH
6745: DOUBLE
6746: LD_INT 1
6748: DEC
6749: ST_TO_ADDR
6750: LD_EXP 10
6754: PUSH
6755: FOR_TO
6756: IFFALSE 6861
// begin tmp := 0 ;
6758: LD_ADDR_VAR 0 2
6762: PUSH
6763: LD_STRING 0
6765: ST_TO_ADDR
// if result [ 2 ] then
6766: LD_VAR 0 1
6770: PUSH
6771: LD_INT 2
6773: ARRAY
6774: IFFALSE 6843
// if result [ 2 ] [ 1 ] = 100 + i then
6776: LD_VAR 0 1
6780: PUSH
6781: LD_INT 2
6783: ARRAY
6784: PUSH
6785: LD_INT 1
6787: ARRAY
6788: PUSH
6789: LD_INT 100
6791: PUSH
6792: LD_VAR 0 5
6796: PLUS
6797: EQUAL
6798: IFFALSE 6843
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
6800: LD_ADDR_VAR 0 1
6804: PUSH
6805: LD_VAR 0 1
6809: PPUSH
6810: LD_INT 2
6812: PPUSH
6813: LD_VAR 0 1
6817: PUSH
6818: LD_INT 2
6820: ARRAY
6821: PPUSH
6822: LD_INT 1
6824: PPUSH
6825: CALL_OW 3
6829: PPUSH
6830: CALL_OW 1
6834: ST_TO_ADDR
// tmp := 1 ;
6835: LD_ADDR_VAR 0 2
6839: PUSH
6840: LD_STRING 1
6842: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
6843: LD_ADDR_VAR 0 4
6847: PUSH
6848: LD_VAR 0 4
6852: PUSH
6853: LD_VAR 0 2
6857: STR
6858: ST_TO_ADDR
// end ;
6859: GO 6755
6861: POP
6862: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
6863: LD_STRING getStreamItemsFromMission("
6865: PUSH
6866: LD_VAR 0 3
6870: STR
6871: PUSH
6872: LD_STRING ","
6874: STR
6875: PUSH
6876: LD_VAR 0 4
6880: STR
6881: PUSH
6882: LD_STRING ")
6884: STR
6885: PPUSH
6886: CALL_OW 559
// end else
6890: GO 6899
// ToLua ( getStreamItemsFromMission("","") ) ;
6892: LD_STRING getStreamItemsFromMission("","")
6894: PPUSH
6895: CALL_OW 559
// end ;
6899: LD_VAR 0 1
6903: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
6904: LD_EXP 8
6908: PUSH
6909: LD_EXP 13
6913: AND
6914: IFFALSE 7038
6916: GO 6918
6918: DISABLE
6919: LD_INT 0
6921: PPUSH
6922: PPUSH
// begin enable ;
6923: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
6924: LD_ADDR_VAR 0 2
6928: PUSH
6929: LD_INT 22
6931: PUSH
6932: LD_OWVAR 2
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 2
6943: PUSH
6944: LD_INT 34
6946: PUSH
6947: LD_INT 7
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 34
6956: PUSH
6957: LD_INT 45
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 34
6966: PUSH
6967: LD_INT 28
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 34
6976: PUSH
6977: LD_INT 47
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PPUSH
6995: CALL_OW 69
6999: ST_TO_ADDR
// if not tmp then
7000: LD_VAR 0 2
7004: NOT
7005: IFFALSE 7009
// exit ;
7007: GO 7038
// for i in tmp do
7009: LD_ADDR_VAR 0 1
7013: PUSH
7014: LD_VAR 0 2
7018: PUSH
7019: FOR_IN
7020: IFFALSE 7036
// begin SetLives ( i , 0 ) ;
7022: LD_VAR 0 1
7026: PPUSH
7027: LD_INT 0
7029: PPUSH
7030: CALL_OW 234
// end ;
7034: GO 7019
7036: POP
7037: POP
// end ;
7038: PPOPN 2
7040: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
7041: LD_EXP 8
7045: PUSH
7046: LD_EXP 14
7050: AND
7051: IFFALSE 7135
7053: GO 7055
7055: DISABLE
7056: LD_INT 0
7058: PPUSH
7059: PPUSH
// begin enable ;
7060: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
7061: LD_ADDR_VAR 0 2
7065: PUSH
7066: LD_INT 22
7068: PUSH
7069: LD_OWVAR 2
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PUSH
7078: LD_INT 32
7080: PUSH
7081: LD_INT 3
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PPUSH
7092: CALL_OW 69
7096: ST_TO_ADDR
// if not tmp then
7097: LD_VAR 0 2
7101: NOT
7102: IFFALSE 7106
// exit ;
7104: GO 7135
// for i in tmp do
7106: LD_ADDR_VAR 0 1
7110: PUSH
7111: LD_VAR 0 2
7115: PUSH
7116: FOR_IN
7117: IFFALSE 7133
// begin SetLives ( i , 0 ) ;
7119: LD_VAR 0 1
7123: PPUSH
7124: LD_INT 0
7126: PPUSH
7127: CALL_OW 234
// end ;
7131: GO 7116
7133: POP
7134: POP
// end ;
7135: PPOPN 2
7137: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7138: LD_EXP 8
7142: PUSH
7143: LD_EXP 11
7147: AND
7148: IFFALSE 7241
7150: GO 7152
7152: DISABLE
7153: LD_INT 0
7155: PPUSH
// begin enable ;
7156: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7157: LD_ADDR_VAR 0 1
7161: PUSH
7162: LD_INT 22
7164: PUSH
7165: LD_OWVAR 2
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 2
7176: PUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 5
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: LD_INT 25
7189: PUSH
7190: LD_INT 9
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: PUSH
7197: LD_INT 25
7199: PUSH
7200: LD_INT 8
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: LIST
7211: LIST
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PPUSH
7217: CALL_OW 69
7221: PUSH
7222: FOR_IN
7223: IFFALSE 7239
// begin SetClass ( i , 1 ) ;
7225: LD_VAR 0 1
7229: PPUSH
7230: LD_INT 1
7232: PPUSH
7233: CALL_OW 336
// end ;
7237: GO 7222
7239: POP
7240: POP
// end ;
7241: PPOPN 1
7243: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7244: LD_EXP 8
7248: PUSH
7249: LD_EXP 12
7253: AND
7254: PUSH
7255: LD_OWVAR 65
7259: PUSH
7260: LD_INT 7
7262: LESS
7263: AND
7264: IFFALSE 7278
7266: GO 7268
7268: DISABLE
// begin enable ;
7269: ENABLE
// game_speed := 7 ;
7270: LD_ADDR_OWVAR 65
7274: PUSH
7275: LD_INT 7
7277: ST_TO_ADDR
// end ;
7278: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7279: LD_EXP 8
7283: PUSH
7284: LD_EXP 15
7288: AND
7289: IFFALSE 7491
7291: GO 7293
7293: DISABLE
7294: LD_INT 0
7296: PPUSH
7297: PPUSH
7298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7299: LD_ADDR_VAR 0 3
7303: PUSH
7304: LD_INT 81
7306: PUSH
7307: LD_OWVAR 2
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 21
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PPUSH
7330: CALL_OW 69
7334: ST_TO_ADDR
// if not tmp then
7335: LD_VAR 0 3
7339: NOT
7340: IFFALSE 7344
// exit ;
7342: GO 7491
// if tmp > 5 then
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 5
7351: GREATER
7352: IFFALSE 7364
// k := 5 else
7354: LD_ADDR_VAR 0 2
7358: PUSH
7359: LD_INT 5
7361: ST_TO_ADDR
7362: GO 7374
// k := tmp ;
7364: LD_ADDR_VAR 0 2
7368: PUSH
7369: LD_VAR 0 3
7373: ST_TO_ADDR
// for i := 1 to k do
7374: LD_ADDR_VAR 0 1
7378: PUSH
7379: DOUBLE
7380: LD_INT 1
7382: DEC
7383: ST_TO_ADDR
7384: LD_VAR 0 2
7388: PUSH
7389: FOR_TO
7390: IFFALSE 7489
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7392: LD_VAR 0 3
7396: PUSH
7397: LD_VAR 0 1
7401: ARRAY
7402: PPUSH
7403: LD_VAR 0 1
7407: PUSH
7408: LD_INT 4
7410: MOD
7411: PUSH
7412: LD_INT 1
7414: PLUS
7415: PPUSH
7416: CALL_OW 259
7420: PUSH
7421: LD_INT 10
7423: LESS
7424: IFFALSE 7487
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7426: LD_VAR 0 3
7430: PUSH
7431: LD_VAR 0 1
7435: ARRAY
7436: PPUSH
7437: LD_VAR 0 1
7441: PUSH
7442: LD_INT 4
7444: MOD
7445: PUSH
7446: LD_INT 1
7448: PLUS
7449: PPUSH
7450: LD_VAR 0 3
7454: PUSH
7455: LD_VAR 0 1
7459: ARRAY
7460: PPUSH
7461: LD_VAR 0 1
7465: PUSH
7466: LD_INT 4
7468: MOD
7469: PUSH
7470: LD_INT 1
7472: PLUS
7473: PPUSH
7474: CALL_OW 259
7478: PUSH
7479: LD_INT 1
7481: PLUS
7482: PPUSH
7483: CALL_OW 237
7487: GO 7389
7489: POP
7490: POP
// end ;
7491: PPOPN 3
7493: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7494: LD_EXP 8
7498: PUSH
7499: LD_EXP 16
7503: AND
7504: IFFALSE 7524
7506: GO 7508
7508: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7509: LD_INT 4
7511: PPUSH
7512: LD_OWVAR 2
7516: PPUSH
7517: LD_INT 0
7519: PPUSH
7520: CALL_OW 324
7524: END
// every 0 0$1 trigger StreamModeActive and sShovel do
7525: LD_EXP 8
7529: PUSH
7530: LD_EXP 45
7534: AND
7535: IFFALSE 7555
7537: GO 7539
7539: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
7540: LD_INT 19
7542: PPUSH
7543: LD_OWVAR 2
7547: PPUSH
7548: LD_INT 0
7550: PPUSH
7551: CALL_OW 324
7555: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7556: LD_EXP 8
7560: PUSH
7561: LD_EXP 17
7565: AND
7566: IFFALSE 7668
7568: GO 7570
7570: DISABLE
7571: LD_INT 0
7573: PPUSH
7574: PPUSH
// begin enable ;
7575: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7576: LD_ADDR_VAR 0 2
7580: PUSH
7581: LD_INT 22
7583: PUSH
7584: LD_OWVAR 2
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: PUSH
7593: LD_INT 2
7595: PUSH
7596: LD_INT 34
7598: PUSH
7599: LD_INT 11
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: LD_INT 34
7608: PUSH
7609: LD_INT 30
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: PPUSH
7625: CALL_OW 69
7629: ST_TO_ADDR
// if not tmp then
7630: LD_VAR 0 2
7634: NOT
7635: IFFALSE 7639
// exit ;
7637: GO 7668
// for i in tmp do
7639: LD_ADDR_VAR 0 1
7643: PUSH
7644: LD_VAR 0 2
7648: PUSH
7649: FOR_IN
7650: IFFALSE 7666
// begin SetLives ( i , 0 ) ;
7652: LD_VAR 0 1
7656: PPUSH
7657: LD_INT 0
7659: PPUSH
7660: CALL_OW 234
// end ;
7664: GO 7649
7666: POP
7667: POP
// end ;
7668: PPOPN 2
7670: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7671: LD_EXP 8
7675: PUSH
7676: LD_EXP 18
7680: AND
7681: IFFALSE 7701
7683: GO 7685
7685: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7686: LD_INT 32
7688: PPUSH
7689: LD_OWVAR 2
7693: PPUSH
7694: LD_INT 0
7696: PPUSH
7697: CALL_OW 324
7701: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
7702: LD_EXP 8
7706: PUSH
7707: LD_EXP 19
7711: AND
7712: IFFALSE 7893
7714: GO 7716
7716: DISABLE
7717: LD_INT 0
7719: PPUSH
7720: PPUSH
7721: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
7722: LD_ADDR_VAR 0 2
7726: PUSH
7727: LD_INT 22
7729: PUSH
7730: LD_OWVAR 2
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: LD_INT 33
7741: PUSH
7742: LD_INT 3
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PPUSH
7753: CALL_OW 69
7757: ST_TO_ADDR
// if not tmp then
7758: LD_VAR 0 2
7762: NOT
7763: IFFALSE 7767
// exit ;
7765: GO 7893
// side := 0 ;
7767: LD_ADDR_VAR 0 3
7771: PUSH
7772: LD_INT 0
7774: ST_TO_ADDR
// for i := 1 to 8 do
7775: LD_ADDR_VAR 0 1
7779: PUSH
7780: DOUBLE
7781: LD_INT 1
7783: DEC
7784: ST_TO_ADDR
7785: LD_INT 8
7787: PUSH
7788: FOR_TO
7789: IFFALSE 7837
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
7791: LD_OWVAR 2
7795: PUSH
7796: LD_VAR 0 1
7800: NONEQUAL
7801: PUSH
7802: LD_OWVAR 2
7806: PPUSH
7807: LD_VAR 0 1
7811: PPUSH
7812: CALL_OW 81
7816: PUSH
7817: LD_INT 2
7819: EQUAL
7820: AND
7821: IFFALSE 7835
// begin side := i ;
7823: LD_ADDR_VAR 0 3
7827: PUSH
7828: LD_VAR 0 1
7832: ST_TO_ADDR
// break ;
7833: GO 7837
// end ;
7835: GO 7788
7837: POP
7838: POP
// if not side then
7839: LD_VAR 0 3
7843: NOT
7844: IFFALSE 7848
// exit ;
7846: GO 7893
// for i := 1 to tmp do
7848: LD_ADDR_VAR 0 1
7852: PUSH
7853: DOUBLE
7854: LD_INT 1
7856: DEC
7857: ST_TO_ADDR
7858: LD_VAR 0 2
7862: PUSH
7863: FOR_TO
7864: IFFALSE 7891
// if Prob ( 60 ) then
7866: LD_INT 60
7868: PPUSH
7869: CALL_OW 13
7873: IFFALSE 7889
// SetSide ( i , side ) ;
7875: LD_VAR 0 1
7879: PPUSH
7880: LD_VAR 0 3
7884: PPUSH
7885: CALL_OW 235
7889: GO 7863
7891: POP
7892: POP
// end ;
7893: PPOPN 3
7895: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
7896: LD_EXP 8
7900: PUSH
7901: LD_EXP 21
7905: AND
7906: IFFALSE 8025
7908: GO 7910
7910: DISABLE
7911: LD_INT 0
7913: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
7914: LD_ADDR_VAR 0 1
7918: PUSH
7919: LD_INT 22
7921: PUSH
7922: LD_OWVAR 2
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PUSH
7931: LD_INT 21
7933: PUSH
7934: LD_INT 1
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 3
7943: PUSH
7944: LD_INT 23
7946: PUSH
7947: LD_INT 0
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: LIST
7962: PPUSH
7963: CALL_OW 69
7967: PUSH
7968: FOR_IN
7969: IFFALSE 8023
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
7971: LD_VAR 0 1
7975: PPUSH
7976: CALL_OW 257
7980: PUSH
7981: LD_INT 1
7983: PUSH
7984: LD_INT 2
7986: PUSH
7987: LD_INT 3
7989: PUSH
7990: LD_INT 4
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: IN
7999: IFFALSE 8021
// SetClass ( un , rand ( 1 , 4 ) ) ;
8001: LD_VAR 0 1
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: LD_INT 4
8011: PPUSH
8012: CALL_OW 12
8016: PPUSH
8017: CALL_OW 336
8021: GO 7968
8023: POP
8024: POP
// end ;
8025: PPOPN 1
8027: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
8028: LD_EXP 8
8032: PUSH
8033: LD_EXP 20
8037: AND
8038: IFFALSE 8117
8040: GO 8042
8042: DISABLE
8043: LD_INT 0
8045: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8046: LD_ADDR_VAR 0 1
8050: PUSH
8051: LD_INT 22
8053: PUSH
8054: LD_OWVAR 2
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PUSH
8063: LD_INT 21
8065: PUSH
8066: LD_INT 3
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: PPUSH
8077: CALL_OW 69
8081: ST_TO_ADDR
// if not tmp then
8082: LD_VAR 0 1
8086: NOT
8087: IFFALSE 8091
// exit ;
8089: GO 8117
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
8091: LD_VAR 0 1
8095: PUSH
8096: LD_INT 1
8098: PPUSH
8099: LD_VAR 0 1
8103: PPUSH
8104: CALL_OW 12
8108: ARRAY
8109: PPUSH
8110: LD_INT 100
8112: PPUSH
8113: CALL_OW 234
// end ;
8117: PPOPN 1
8119: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
8120: LD_EXP 8
8124: PUSH
8125: LD_EXP 22
8129: AND
8130: IFFALSE 8228
8132: GO 8134
8134: DISABLE
8135: LD_INT 0
8137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: LD_INT 22
8145: PUSH
8146: LD_OWVAR 2
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 21
8157: PUSH
8158: LD_INT 1
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: ST_TO_ADDR
// if not tmp then
8174: LD_VAR 0 1
8178: NOT
8179: IFFALSE 8183
// exit ;
8181: GO 8228
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8183: LD_VAR 0 1
8187: PUSH
8188: LD_INT 1
8190: PPUSH
8191: LD_VAR 0 1
8195: PPUSH
8196: CALL_OW 12
8200: ARRAY
8201: PPUSH
8202: LD_INT 1
8204: PPUSH
8205: LD_INT 4
8207: PPUSH
8208: CALL_OW 12
8212: PPUSH
8213: LD_INT 3000
8215: PPUSH
8216: LD_INT 9000
8218: PPUSH
8219: CALL_OW 12
8223: PPUSH
8224: CALL_OW 492
// end ;
8228: PPOPN 1
8230: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8231: LD_EXP 8
8235: PUSH
8236: LD_EXP 23
8240: AND
8241: IFFALSE 8261
8243: GO 8245
8245: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8246: LD_INT 1
8248: PPUSH
8249: LD_OWVAR 2
8253: PPUSH
8254: LD_INT 0
8256: PPUSH
8257: CALL_OW 324
8261: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8262: LD_EXP 8
8266: PUSH
8267: LD_EXP 24
8271: AND
8272: IFFALSE 8355
8274: GO 8276
8276: DISABLE
8277: LD_INT 0
8279: PPUSH
8280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_OWVAR 2
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 21
8300: PUSH
8301: LD_INT 3
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: ST_TO_ADDR
// if not tmp then
8317: LD_VAR 0 2
8321: NOT
8322: IFFALSE 8326
// exit ;
8324: GO 8355
// for i in tmp do
8326: LD_ADDR_VAR 0 1
8330: PUSH
8331: LD_VAR 0 2
8335: PUSH
8336: FOR_IN
8337: IFFALSE 8353
// SetBLevel ( i , 10 ) ;
8339: LD_VAR 0 1
8343: PPUSH
8344: LD_INT 10
8346: PPUSH
8347: CALL_OW 241
8351: GO 8336
8353: POP
8354: POP
// end ;
8355: PPOPN 2
8357: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
8358: LD_EXP 8
8362: PUSH
8363: LD_EXP 25
8367: AND
8368: IFFALSE 8479
8370: GO 8372
8372: DISABLE
8373: LD_INT 0
8375: PPUSH
8376: PPUSH
8377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8378: LD_ADDR_VAR 0 3
8382: PUSH
8383: LD_INT 22
8385: PUSH
8386: LD_OWVAR 2
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PUSH
8395: LD_INT 25
8397: PUSH
8398: LD_INT 1
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: PPUSH
8409: CALL_OW 69
8413: ST_TO_ADDR
// if not tmp then
8414: LD_VAR 0 3
8418: NOT
8419: IFFALSE 8423
// exit ;
8421: GO 8479
// un := tmp [ rand ( 1 , tmp ) ] ;
8423: LD_ADDR_VAR 0 2
8427: PUSH
8428: LD_VAR 0 3
8432: PUSH
8433: LD_INT 1
8435: PPUSH
8436: LD_VAR 0 3
8440: PPUSH
8441: CALL_OW 12
8445: ARRAY
8446: ST_TO_ADDR
// if Crawls ( un ) then
8447: LD_VAR 0 2
8451: PPUSH
8452: CALL_OW 318
8456: IFFALSE 8467
// ComWalk ( un ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: CALL_OW 138
// SetClass ( un , class_sniper ) ;
8467: LD_VAR 0 2
8471: PPUSH
8472: LD_INT 5
8474: PPUSH
8475: CALL_OW 336
// end ;
8479: PPOPN 3
8481: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8482: LD_EXP 8
8486: PUSH
8487: LD_EXP 26
8491: AND
8492: PUSH
8493: LD_OWVAR 67
8497: PUSH
8498: LD_INT 3
8500: LESS
8501: AND
8502: IFFALSE 8521
8504: GO 8506
8506: DISABLE
// Difficulty := Difficulty + 1 ;
8507: LD_ADDR_OWVAR 67
8511: PUSH
8512: LD_OWVAR 67
8516: PUSH
8517: LD_INT 1
8519: PLUS
8520: ST_TO_ADDR
8521: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8522: LD_EXP 8
8526: PUSH
8527: LD_EXP 27
8531: AND
8532: IFFALSE 8635
8534: GO 8536
8536: DISABLE
8537: LD_INT 0
8539: PPUSH
// begin for i := 1 to 5 do
8540: LD_ADDR_VAR 0 1
8544: PUSH
8545: DOUBLE
8546: LD_INT 1
8548: DEC
8549: ST_TO_ADDR
8550: LD_INT 5
8552: PUSH
8553: FOR_TO
8554: IFFALSE 8633
// begin uc_nation := nation_nature ;
8556: LD_ADDR_OWVAR 21
8560: PUSH
8561: LD_INT 0
8563: ST_TO_ADDR
// uc_side := 0 ;
8564: LD_ADDR_OWVAR 20
8568: PUSH
8569: LD_INT 0
8571: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8572: LD_ADDR_OWVAR 29
8576: PUSH
8577: LD_INT 12
8579: PUSH
8580: LD_INT 12
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: ST_TO_ADDR
// hc_agressivity := 20 ;
8587: LD_ADDR_OWVAR 35
8591: PUSH
8592: LD_INT 20
8594: ST_TO_ADDR
// hc_class := class_tiger ;
8595: LD_ADDR_OWVAR 28
8599: PUSH
8600: LD_INT 14
8602: ST_TO_ADDR
// hc_gallery :=  ;
8603: LD_ADDR_OWVAR 33
8607: PUSH
8608: LD_STRING 
8610: ST_TO_ADDR
// hc_name :=  ;
8611: LD_ADDR_OWVAR 26
8615: PUSH
8616: LD_STRING 
8618: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8619: CALL_OW 44
8623: PPUSH
8624: LD_INT 0
8626: PPUSH
8627: CALL_OW 51
// end ;
8631: GO 8553
8633: POP
8634: POP
// end ;
8635: PPOPN 1
8637: END
// every 0 0$1 trigger StreamModeActive and sBomb do
8638: LD_EXP 8
8642: PUSH
8643: LD_EXP 28
8647: AND
8648: IFFALSE 8657
8650: GO 8652
8652: DISABLE
// StreamSibBomb ;
8653: CALL 8658 0 0
8657: END
// export function StreamSibBomb ; var i , x , y ; begin
8658: LD_INT 0
8660: PPUSH
8661: PPUSH
8662: PPUSH
8663: PPUSH
// result := false ;
8664: LD_ADDR_VAR 0 1
8668: PUSH
8669: LD_INT 0
8671: ST_TO_ADDR
// for i := 1 to 16 do
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: DOUBLE
8678: LD_INT 1
8680: DEC
8681: ST_TO_ADDR
8682: LD_INT 16
8684: PUSH
8685: FOR_TO
8686: IFFALSE 8885
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8688: LD_ADDR_VAR 0 3
8692: PUSH
8693: LD_INT 10
8695: PUSH
8696: LD_INT 20
8698: PUSH
8699: LD_INT 30
8701: PUSH
8702: LD_INT 40
8704: PUSH
8705: LD_INT 50
8707: PUSH
8708: LD_INT 60
8710: PUSH
8711: LD_INT 70
8713: PUSH
8714: LD_INT 80
8716: PUSH
8717: LD_INT 90
8719: PUSH
8720: LD_INT 100
8722: PUSH
8723: LD_INT 110
8725: PUSH
8726: LD_INT 120
8728: PUSH
8729: LD_INT 130
8731: PUSH
8732: LD_INT 140
8734: PUSH
8735: LD_INT 150
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: LIST
8744: LIST
8745: LIST
8746: LIST
8747: LIST
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: LIST
8754: PUSH
8755: LD_INT 1
8757: PPUSH
8758: LD_INT 15
8760: PPUSH
8761: CALL_OW 12
8765: ARRAY
8766: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8767: LD_ADDR_VAR 0 4
8771: PUSH
8772: LD_INT 10
8774: PUSH
8775: LD_INT 20
8777: PUSH
8778: LD_INT 30
8780: PUSH
8781: LD_INT 40
8783: PUSH
8784: LD_INT 50
8786: PUSH
8787: LD_INT 60
8789: PUSH
8790: LD_INT 70
8792: PUSH
8793: LD_INT 80
8795: PUSH
8796: LD_INT 90
8798: PUSH
8799: LD_INT 100
8801: PUSH
8802: LD_INT 110
8804: PUSH
8805: LD_INT 120
8807: PUSH
8808: LD_INT 130
8810: PUSH
8811: LD_INT 140
8813: PUSH
8814: LD_INT 150
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: LIST
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: LIST
8832: LIST
8833: PUSH
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 15
8839: PPUSH
8840: CALL_OW 12
8844: ARRAY
8845: ST_TO_ADDR
// if ValidHex ( x , y ) then
8846: LD_VAR 0 3
8850: PPUSH
8851: LD_VAR 0 4
8855: PPUSH
8856: CALL_OW 488
8860: IFFALSE 8883
// begin result := [ x , y ] ;
8862: LD_ADDR_VAR 0 1
8866: PUSH
8867: LD_VAR 0 3
8871: PUSH
8872: LD_VAR 0 4
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: ST_TO_ADDR
// break ;
8881: GO 8885
// end ; end ;
8883: GO 8685
8885: POP
8886: POP
// if result then
8887: LD_VAR 0 1
8891: IFFALSE 8951
// begin ToLua ( playSibBomb() ) ;
8893: LD_STRING playSibBomb()
8895: PPUSH
8896: CALL_OW 559
// wait ( 0 0$14 ) ;
8900: LD_INT 490
8902: PPUSH
8903: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
8907: LD_VAR 0 1
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PPUSH
8916: LD_VAR 0 1
8920: PUSH
8921: LD_INT 2
8923: ARRAY
8924: PPUSH
8925: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
8929: LD_VAR 0 1
8933: PUSH
8934: LD_INT 1
8936: ARRAY
8937: PPUSH
8938: LD_VAR 0 1
8942: PUSH
8943: LD_INT 2
8945: ARRAY
8946: PPUSH
8947: CALL_OW 429
// end ; end ;
8951: LD_VAR 0 1
8955: RET
// every 0 0$1 trigger StreamModeActive and sReset do
8956: LD_EXP 8
8960: PUSH
8961: LD_EXP 30
8965: AND
8966: IFFALSE 8978
8968: GO 8970
8970: DISABLE
// YouLost (  ) ;
8971: LD_STRING 
8973: PPUSH
8974: CALL_OW 104
8978: END
// every 0 0$1 trigger StreamModeActive and sFog do
8979: LD_EXP 8
8983: PUSH
8984: LD_EXP 29
8988: AND
8989: IFFALSE 9003
8991: GO 8993
8993: DISABLE
// FogOff ( your_side ) ;
8994: LD_OWVAR 2
8998: PPUSH
8999: CALL_OW 344
9003: END
// every 0 0$1 trigger StreamModeActive and sSun do
9004: LD_EXP 8
9008: PUSH
9009: LD_EXP 31
9013: AND
9014: IFFALSE 9042
9016: GO 9018
9018: DISABLE
// begin solar_recharge_percent := 0 ;
9019: LD_ADDR_OWVAR 79
9023: PUSH
9024: LD_INT 0
9026: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9027: LD_INT 10500
9029: PPUSH
9030: CALL_OW 67
// solar_recharge_percent := 100 ;
9034: LD_ADDR_OWVAR 79
9038: PUSH
9039: LD_INT 100
9041: ST_TO_ADDR
// end ;
9042: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
9043: LD_EXP 8
9047: PUSH
9048: LD_EXP 32
9052: AND
9053: IFFALSE 9292
9055: GO 9057
9057: DISABLE
9058: LD_INT 0
9060: PPUSH
9061: PPUSH
9062: PPUSH
// begin tmp := [ ] ;
9063: LD_ADDR_VAR 0 3
9067: PUSH
9068: EMPTY
9069: ST_TO_ADDR
// for i := 1 to 6 do
9070: LD_ADDR_VAR 0 1
9074: PUSH
9075: DOUBLE
9076: LD_INT 1
9078: DEC
9079: ST_TO_ADDR
9080: LD_INT 6
9082: PUSH
9083: FOR_TO
9084: IFFALSE 9189
// begin uc_nation := nation_nature ;
9086: LD_ADDR_OWVAR 21
9090: PUSH
9091: LD_INT 0
9093: ST_TO_ADDR
// uc_side := 0 ;
9094: LD_ADDR_OWVAR 20
9098: PUSH
9099: LD_INT 0
9101: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9102: LD_ADDR_OWVAR 29
9106: PUSH
9107: LD_INT 12
9109: PUSH
9110: LD_INT 12
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: ST_TO_ADDR
// hc_agressivity := 20 ;
9117: LD_ADDR_OWVAR 35
9121: PUSH
9122: LD_INT 20
9124: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
9125: LD_ADDR_OWVAR 28
9129: PUSH
9130: LD_INT 17
9132: ST_TO_ADDR
// hc_gallery :=  ;
9133: LD_ADDR_OWVAR 33
9137: PUSH
9138: LD_STRING 
9140: ST_TO_ADDR
// hc_name :=  ;
9141: LD_ADDR_OWVAR 26
9145: PUSH
9146: LD_STRING 
9148: ST_TO_ADDR
// un := CreateHuman ;
9149: LD_ADDR_VAR 0 2
9153: PUSH
9154: CALL_OW 44
9158: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9159: LD_VAR 0 2
9163: PPUSH
9164: LD_INT 1
9166: PPUSH
9167: CALL_OW 51
// tmp := tmp ^ un ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_VAR 0 3
9180: PUSH
9181: LD_VAR 0 2
9185: ADD
9186: ST_TO_ADDR
// end ;
9187: GO 9083
9189: POP
9190: POP
// repeat wait ( 0 0$1 ) ;
9191: LD_INT 35
9193: PPUSH
9194: CALL_OW 67
// for un in tmp do
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 3
9207: PUSH
9208: FOR_IN
9209: IFFALSE 9283
// begin if IsDead ( un ) then
9211: LD_VAR 0 2
9215: PPUSH
9216: CALL_OW 301
9220: IFFALSE 9240
// begin tmp := tmp diff un ;
9222: LD_ADDR_VAR 0 3
9226: PUSH
9227: LD_VAR 0 3
9231: PUSH
9232: LD_VAR 0 2
9236: DIFF
9237: ST_TO_ADDR
// continue ;
9238: GO 9208
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9240: LD_VAR 0 2
9244: PPUSH
9245: LD_INT 3
9247: PUSH
9248: LD_INT 22
9250: PUSH
9251: LD_INT 0
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: PPUSH
9262: CALL_OW 69
9266: PPUSH
9267: LD_VAR 0 2
9271: PPUSH
9272: CALL_OW 74
9276: PPUSH
9277: CALL_OW 115
// end ;
9281: GO 9208
9283: POP
9284: POP
// until not tmp ;
9285: LD_VAR 0 3
9289: NOT
9290: IFFALSE 9191
// end ;
9292: PPOPN 3
9294: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9295: LD_EXP 8
9299: PUSH
9300: LD_EXP 33
9304: AND
9305: IFFALSE 9359
9307: GO 9309
9309: DISABLE
// begin ToLua ( displayTroll(); ) ;
9310: LD_STRING displayTroll();
9312: PPUSH
9313: CALL_OW 559
// wait ( 3 3$00 ) ;
9317: LD_INT 6300
9319: PPUSH
9320: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9324: LD_STRING hideTroll();
9326: PPUSH
9327: CALL_OW 559
// wait ( 1 1$00 ) ;
9331: LD_INT 2100
9333: PPUSH
9334: CALL_OW 67
// ToLua ( displayTroll(); ) ;
9338: LD_STRING displayTroll();
9340: PPUSH
9341: CALL_OW 559
// wait ( 1 1$00 ) ;
9345: LD_INT 2100
9347: PPUSH
9348: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9352: LD_STRING hideTroll();
9354: PPUSH
9355: CALL_OW 559
// end ;
9359: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9360: LD_EXP 8
9364: PUSH
9365: LD_EXP 34
9369: AND
9370: IFFALSE 9433
9372: GO 9374
9374: DISABLE
9375: LD_INT 0
9377: PPUSH
// begin p := 0 ;
9378: LD_ADDR_VAR 0 1
9382: PUSH
9383: LD_INT 0
9385: ST_TO_ADDR
// repeat game_speed := 1 ;
9386: LD_ADDR_OWVAR 65
9390: PUSH
9391: LD_INT 1
9393: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9394: LD_INT 35
9396: PPUSH
9397: CALL_OW 67
// p := p + 1 ;
9401: LD_ADDR_VAR 0 1
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 1
9413: PLUS
9414: ST_TO_ADDR
// until p >= 60 ;
9415: LD_VAR 0 1
9419: PUSH
9420: LD_INT 60
9422: GREATEREQUAL
9423: IFFALSE 9386
// game_speed := 4 ;
9425: LD_ADDR_OWVAR 65
9429: PUSH
9430: LD_INT 4
9432: ST_TO_ADDR
// end ;
9433: PPOPN 1
9435: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9436: LD_EXP 8
9440: PUSH
9441: LD_EXP 35
9445: AND
9446: IFFALSE 9592
9448: GO 9450
9450: DISABLE
9451: LD_INT 0
9453: PPUSH
9454: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9455: LD_ADDR_VAR 0 1
9459: PUSH
9460: LD_INT 22
9462: PUSH
9463: LD_OWVAR 2
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: LD_INT 30
9477: PUSH
9478: LD_INT 0
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: PUSH
9485: LD_INT 30
9487: PUSH
9488: LD_INT 1
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PUSH
9495: EMPTY
9496: LIST
9497: LIST
9498: LIST
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: PPUSH
9504: CALL_OW 69
9508: ST_TO_ADDR
// if not depot then
9509: LD_VAR 0 1
9513: NOT
9514: IFFALSE 9518
// exit ;
9516: GO 9592
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9518: LD_ADDR_VAR 0 2
9522: PUSH
9523: LD_VAR 0 1
9527: PUSH
9528: LD_INT 1
9530: PPUSH
9531: LD_VAR 0 1
9535: PPUSH
9536: CALL_OW 12
9540: ARRAY
9541: PPUSH
9542: CALL_OW 274
9546: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9547: LD_VAR 0 2
9551: PPUSH
9552: LD_INT 1
9554: PPUSH
9555: LD_INT 0
9557: PPUSH
9558: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9562: LD_VAR 0 2
9566: PPUSH
9567: LD_INT 2
9569: PPUSH
9570: LD_INT 0
9572: PPUSH
9573: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9577: LD_VAR 0 2
9581: PPUSH
9582: LD_INT 3
9584: PPUSH
9585: LD_INT 0
9587: PPUSH
9588: CALL_OW 277
// end ;
9592: PPOPN 2
9594: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
9595: LD_EXP 8
9599: PUSH
9600: LD_EXP 36
9604: AND
9605: IFFALSE 9702
9607: GO 9609
9609: DISABLE
9610: LD_INT 0
9612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9613: LD_ADDR_VAR 0 1
9617: PUSH
9618: LD_INT 22
9620: PUSH
9621: LD_OWVAR 2
9625: PUSH
9626: EMPTY
9627: LIST
9628: LIST
9629: PUSH
9630: LD_INT 21
9632: PUSH
9633: LD_INT 1
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: LD_INT 23
9645: PUSH
9646: LD_INT 0
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: PUSH
9657: EMPTY
9658: LIST
9659: LIST
9660: LIST
9661: PPUSH
9662: CALL_OW 69
9666: ST_TO_ADDR
// if not tmp then
9667: LD_VAR 0 1
9671: NOT
9672: IFFALSE 9676
// exit ;
9674: GO 9702
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
9676: LD_VAR 0 1
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_VAR 0 1
9688: PPUSH
9689: CALL_OW 12
9693: ARRAY
9694: PPUSH
9695: LD_INT 200
9697: PPUSH
9698: CALL_OW 234
// end ;
9702: PPOPN 1
9704: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
9705: LD_EXP 8
9709: PUSH
9710: LD_EXP 37
9714: AND
9715: IFFALSE 9794
9717: GO 9719
9719: DISABLE
9720: LD_INT 0
9722: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
9723: LD_ADDR_VAR 0 1
9727: PUSH
9728: LD_INT 22
9730: PUSH
9731: LD_OWVAR 2
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 21
9742: PUSH
9743: LD_INT 2
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: EMPTY
9751: LIST
9752: LIST
9753: PPUSH
9754: CALL_OW 69
9758: ST_TO_ADDR
// if not tmp then
9759: LD_VAR 0 1
9763: NOT
9764: IFFALSE 9768
// exit ;
9766: GO 9794
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
9768: LD_VAR 0 1
9772: PUSH
9773: LD_INT 1
9775: PPUSH
9776: LD_VAR 0 1
9780: PPUSH
9781: CALL_OW 12
9785: ARRAY
9786: PPUSH
9787: LD_INT 60
9789: PPUSH
9790: CALL_OW 234
// end ;
9794: PPOPN 1
9796: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9797: LD_EXP 8
9801: PUSH
9802: LD_EXP 38
9806: AND
9807: IFFALSE 9906
9809: GO 9811
9811: DISABLE
9812: LD_INT 0
9814: PPUSH
9815: PPUSH
// begin enable ;
9816: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9817: LD_ADDR_VAR 0 1
9821: PUSH
9822: LD_INT 22
9824: PUSH
9825: LD_OWVAR 2
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PUSH
9834: LD_INT 61
9836: PUSH
9837: EMPTY
9838: LIST
9839: PUSH
9840: LD_INT 33
9842: PUSH
9843: LD_INT 2
9845: PUSH
9846: EMPTY
9847: LIST
9848: LIST
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: LIST
9854: PPUSH
9855: CALL_OW 69
9859: ST_TO_ADDR
// if not tmp then
9860: LD_VAR 0 1
9864: NOT
9865: IFFALSE 9869
// exit ;
9867: GO 9906
// for i in tmp do
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 1
9878: PUSH
9879: FOR_IN
9880: IFFALSE 9904
// if IsControledBy ( i ) then
9882: LD_VAR 0 2
9886: PPUSH
9887: CALL_OW 312
9891: IFFALSE 9902
// ComUnlink ( i ) ;
9893: LD_VAR 0 2
9897: PPUSH
9898: CALL_OW 136
9902: GO 9879
9904: POP
9905: POP
// end ;
9906: PPOPN 2
9908: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
9909: LD_EXP 8
9913: PUSH
9914: LD_EXP 39
9918: AND
9919: IFFALSE 10059
9921: GO 9923
9923: DISABLE
9924: LD_INT 0
9926: PPUSH
9927: PPUSH
// begin ToLua ( displayPowell(); ) ;
9928: LD_STRING displayPowell();
9930: PPUSH
9931: CALL_OW 559
// uc_side := 0 ;
9935: LD_ADDR_OWVAR 20
9939: PUSH
9940: LD_INT 0
9942: ST_TO_ADDR
// uc_nation := 2 ;
9943: LD_ADDR_OWVAR 21
9947: PUSH
9948: LD_INT 2
9950: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
9951: LD_ADDR_OWVAR 37
9955: PUSH
9956: LD_INT 14
9958: ST_TO_ADDR
// vc_engine := engine_siberite ;
9959: LD_ADDR_OWVAR 39
9963: PUSH
9964: LD_INT 3
9966: ST_TO_ADDR
// vc_control := control_apeman ;
9967: LD_ADDR_OWVAR 38
9971: PUSH
9972: LD_INT 5
9974: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
9975: LD_ADDR_OWVAR 40
9979: PUSH
9980: LD_INT 29
9982: ST_TO_ADDR
// un := CreateVehicle ;
9983: LD_ADDR_VAR 0 2
9987: PUSH
9988: CALL_OW 45
9992: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9993: LD_VAR 0 2
9997: PPUSH
9998: LD_INT 1
10000: PPUSH
10001: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10005: LD_INT 35
10007: PPUSH
10008: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10012: LD_VAR 0 2
10016: PPUSH
10017: LD_INT 22
10019: PUSH
10020: LD_OWVAR 2
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PPUSH
10029: CALL_OW 69
10033: PPUSH
10034: LD_VAR 0 2
10038: PPUSH
10039: CALL_OW 74
10043: PPUSH
10044: CALL_OW 115
// until IsDead ( un ) ;
10048: LD_VAR 0 2
10052: PPUSH
10053: CALL_OW 301
10057: IFFALSE 10005
// end ;
10059: PPOPN 2
10061: END
// every 0 0$1 trigger StreamModeActive and sStu do
10062: LD_EXP 8
10066: PUSH
10067: LD_EXP 47
10071: AND
10072: IFFALSE 10088
10074: GO 10076
10076: DISABLE
// begin ToLua ( displayStucuk(); ) ;
10077: LD_STRING displayStucuk();
10079: PPUSH
10080: CALL_OW 559
// ResetFog ;
10084: CALL_OW 335
// end ;
10088: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
10089: LD_EXP 8
10093: PUSH
10094: LD_EXP 40
10098: AND
10099: IFFALSE 10240
10101: GO 10103
10103: DISABLE
10104: LD_INT 0
10106: PPUSH
10107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10108: LD_ADDR_VAR 0 2
10112: PUSH
10113: LD_INT 22
10115: PUSH
10116: LD_OWVAR 2
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: PUSH
10125: LD_INT 21
10127: PUSH
10128: LD_INT 1
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: EMPTY
10136: LIST
10137: LIST
10138: PPUSH
10139: CALL_OW 69
10143: ST_TO_ADDR
// if not tmp then
10144: LD_VAR 0 2
10148: NOT
10149: IFFALSE 10153
// exit ;
10151: GO 10240
// un := tmp [ rand ( 1 , tmp ) ] ;
10153: LD_ADDR_VAR 0 1
10157: PUSH
10158: LD_VAR 0 2
10162: PUSH
10163: LD_INT 1
10165: PPUSH
10166: LD_VAR 0 2
10170: PPUSH
10171: CALL_OW 12
10175: ARRAY
10176: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10177: LD_VAR 0 1
10181: PPUSH
10182: LD_INT 0
10184: PPUSH
10185: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10189: LD_VAR 0 1
10193: PPUSH
10194: LD_OWVAR 3
10198: PUSH
10199: LD_VAR 0 1
10203: DIFF
10204: PPUSH
10205: LD_VAR 0 1
10209: PPUSH
10210: CALL_OW 74
10214: PPUSH
10215: CALL_OW 115
// wait ( 0 0$20 ) ;
10219: LD_INT 700
10221: PPUSH
10222: CALL_OW 67
// SetSide ( un , your_side ) ;
10226: LD_VAR 0 1
10230: PPUSH
10231: LD_OWVAR 2
10235: PPUSH
10236: CALL_OW 235
// end ;
10240: PPOPN 2
10242: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10243: LD_EXP 8
10247: PUSH
10248: LD_EXP 41
10252: AND
10253: IFFALSE 10359
10255: GO 10257
10257: DISABLE
10258: LD_INT 0
10260: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10261: LD_ADDR_VAR 0 1
10265: PUSH
10266: LD_INT 22
10268: PUSH
10269: LD_OWVAR 2
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: PUSH
10278: LD_INT 2
10280: PUSH
10281: LD_INT 30
10283: PUSH
10284: LD_INT 0
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: PUSH
10291: LD_INT 30
10293: PUSH
10294: LD_INT 1
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PPUSH
10310: CALL_OW 69
10314: ST_TO_ADDR
// if not depot then
10315: LD_VAR 0 1
10319: NOT
10320: IFFALSE 10324
// exit ;
10322: GO 10359
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
10324: LD_VAR 0 1
10328: PUSH
10329: LD_INT 1
10331: ARRAY
10332: PPUSH
10333: CALL_OW 250
10337: PPUSH
10338: LD_VAR 0 1
10342: PUSH
10343: LD_INT 1
10345: ARRAY
10346: PPUSH
10347: CALL_OW 251
10351: PPUSH
10352: LD_INT 70
10354: PPUSH
10355: CALL_OW 495
// end ;
10359: PPOPN 1
10361: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
10362: LD_EXP 8
10366: PUSH
10367: LD_EXP 42
10371: AND
10372: IFFALSE 10583
10374: GO 10376
10376: DISABLE
10377: LD_INT 0
10379: PPUSH
10380: PPUSH
10381: PPUSH
10382: PPUSH
10383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10384: LD_ADDR_VAR 0 5
10388: PUSH
10389: LD_INT 22
10391: PUSH
10392: LD_OWVAR 2
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 21
10403: PUSH
10404: LD_INT 1
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: PPUSH
10415: CALL_OW 69
10419: ST_TO_ADDR
// if not tmp then
10420: LD_VAR 0 5
10424: NOT
10425: IFFALSE 10429
// exit ;
10427: GO 10583
// for i in tmp do
10429: LD_ADDR_VAR 0 1
10433: PUSH
10434: LD_VAR 0 5
10438: PUSH
10439: FOR_IN
10440: IFFALSE 10581
// begin d := rand ( 0 , 5 ) ;
10442: LD_ADDR_VAR 0 4
10446: PUSH
10447: LD_INT 0
10449: PPUSH
10450: LD_INT 5
10452: PPUSH
10453: CALL_OW 12
10457: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
10458: LD_ADDR_VAR 0 2
10462: PUSH
10463: LD_VAR 0 1
10467: PPUSH
10468: CALL_OW 250
10472: PPUSH
10473: LD_VAR 0 4
10477: PPUSH
10478: LD_INT 3
10480: PPUSH
10481: LD_INT 12
10483: PPUSH
10484: CALL_OW 12
10488: PPUSH
10489: CALL_OW 272
10493: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
10494: LD_ADDR_VAR 0 3
10498: PUSH
10499: LD_VAR 0 1
10503: PPUSH
10504: CALL_OW 251
10508: PPUSH
10509: LD_VAR 0 4
10513: PPUSH
10514: LD_INT 3
10516: PPUSH
10517: LD_INT 12
10519: PPUSH
10520: CALL_OW 12
10524: PPUSH
10525: CALL_OW 273
10529: ST_TO_ADDR
// if ValidHex ( x , y ) then
10530: LD_VAR 0 2
10534: PPUSH
10535: LD_VAR 0 3
10539: PPUSH
10540: CALL_OW 488
10544: IFFALSE 10579
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
10546: LD_VAR 0 1
10550: PPUSH
10551: LD_VAR 0 2
10555: PPUSH
10556: LD_VAR 0 3
10560: PPUSH
10561: LD_INT 3
10563: PPUSH
10564: LD_INT 6
10566: PPUSH
10567: CALL_OW 12
10571: PPUSH
10572: LD_INT 1
10574: PPUSH
10575: CALL_OW 483
// end ;
10579: GO 10439
10581: POP
10582: POP
// end ;
10583: PPOPN 5
10585: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
10586: LD_EXP 8
10590: PUSH
10591: LD_EXP 43
10595: AND
10596: IFFALSE 10690
10598: GO 10600
10600: DISABLE
10601: LD_INT 0
10603: PPUSH
10604: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: LD_INT 22
10612: PUSH
10613: LD_OWVAR 2
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PUSH
10622: LD_INT 32
10624: PUSH
10625: LD_INT 1
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PUSH
10632: LD_INT 21
10634: PUSH
10635: LD_INT 2
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: LIST
10646: PPUSH
10647: CALL_OW 69
10651: ST_TO_ADDR
// if not tmp then
10652: LD_VAR 0 2
10656: NOT
10657: IFFALSE 10661
// exit ;
10659: GO 10690
// for i in tmp do
10661: LD_ADDR_VAR 0 1
10665: PUSH
10666: LD_VAR 0 2
10670: PUSH
10671: FOR_IN
10672: IFFALSE 10688
// SetFuel ( i , 0 ) ;
10674: LD_VAR 0 1
10678: PPUSH
10679: LD_INT 0
10681: PPUSH
10682: CALL_OW 240
10686: GO 10671
10688: POP
10689: POP
// end ;
10690: PPOPN 2
10692: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
10693: LD_EXP 8
10697: PUSH
10698: LD_EXP 44
10702: AND
10703: IFFALSE 10769
10705: GO 10707
10707: DISABLE
10708: LD_INT 0
10710: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10711: LD_ADDR_VAR 0 1
10715: PUSH
10716: LD_INT 22
10718: PUSH
10719: LD_OWVAR 2
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PUSH
10728: LD_INT 30
10730: PUSH
10731: LD_INT 29
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PPUSH
10742: CALL_OW 69
10746: ST_TO_ADDR
// if not tmp then
10747: LD_VAR 0 1
10751: NOT
10752: IFFALSE 10756
// exit ;
10754: GO 10769
// DestroyUnit ( tmp [ 1 ] ) ;
10756: LD_VAR 0 1
10760: PUSH
10761: LD_INT 1
10763: ARRAY
10764: PPUSH
10765: CALL_OW 65
// end ;
10769: PPOPN 1
10771: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
10772: LD_EXP 8
10776: PUSH
10777: LD_EXP 46
10781: AND
10782: IFFALSE 10911
10784: GO 10786
10786: DISABLE
10787: LD_INT 0
10789: PPUSH
// begin uc_side := 0 ;
10790: LD_ADDR_OWVAR 20
10794: PUSH
10795: LD_INT 0
10797: ST_TO_ADDR
// uc_nation := nation_arabian ;
10798: LD_ADDR_OWVAR 21
10802: PUSH
10803: LD_INT 2
10805: ST_TO_ADDR
// hc_gallery :=  ;
10806: LD_ADDR_OWVAR 33
10810: PUSH
10811: LD_STRING 
10813: ST_TO_ADDR
// hc_name :=  ;
10814: LD_ADDR_OWVAR 26
10818: PUSH
10819: LD_STRING 
10821: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
10822: LD_INT 1
10824: PPUSH
10825: LD_INT 11
10827: PPUSH
10828: LD_INT 10
10830: PPUSH
10831: CALL_OW 380
// un := CreateHuman ;
10835: LD_ADDR_VAR 0 1
10839: PUSH
10840: CALL_OW 44
10844: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10845: LD_VAR 0 1
10849: PPUSH
10850: LD_INT 1
10852: PPUSH
10853: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10857: LD_INT 35
10859: PPUSH
10860: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10864: LD_VAR 0 1
10868: PPUSH
10869: LD_INT 22
10871: PUSH
10872: LD_OWVAR 2
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PPUSH
10881: CALL_OW 69
10885: PPUSH
10886: LD_VAR 0 1
10890: PPUSH
10891: CALL_OW 74
10895: PPUSH
10896: CALL_OW 115
// until IsDead ( un ) ;
10900: LD_VAR 0 1
10904: PPUSH
10905: CALL_OW 301
10909: IFFALSE 10857
// end ;
10911: PPOPN 1
10913: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
10914: LD_EXP 8
10918: PUSH
10919: LD_EXP 48
10923: AND
10924: IFFALSE 10936
10926: GO 10928
10928: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
10929: LD_STRING earthquake(getX(game), 0, 32)
10931: PPUSH
10932: CALL_OW 559
10936: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
10937: LD_EXP 8
10941: PUSH
10942: LD_EXP 49
10946: AND
10947: IFFALSE 11038
10949: GO 10951
10951: DISABLE
10952: LD_INT 0
10954: PPUSH
// begin enable ;
10955: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
10956: LD_ADDR_VAR 0 1
10960: PUSH
10961: LD_INT 22
10963: PUSH
10964: LD_OWVAR 2
10968: PUSH
10969: EMPTY
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 21
10975: PUSH
10976: LD_INT 2
10978: PUSH
10979: EMPTY
10980: LIST
10981: LIST
10982: PUSH
10983: LD_INT 33
10985: PUSH
10986: LD_INT 3
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: PPUSH
10998: CALL_OW 69
11002: ST_TO_ADDR
// if not tmp then
11003: LD_VAR 0 1
11007: NOT
11008: IFFALSE 11012
// exit ;
11010: GO 11038
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11012: LD_VAR 0 1
11016: PUSH
11017: LD_INT 1
11019: PPUSH
11020: LD_VAR 0 1
11024: PPUSH
11025: CALL_OW 12
11029: ARRAY
11030: PPUSH
11031: LD_INT 1
11033: PPUSH
11034: CALL_OW 234
// end ;
11038: PPOPN 1
11040: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
11041: LD_EXP 8
11045: PUSH
11046: LD_EXP 50
11050: AND
11051: IFFALSE 11192
11053: GO 11055
11055: DISABLE
11056: LD_INT 0
11058: PPUSH
11059: PPUSH
11060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11061: LD_ADDR_VAR 0 3
11065: PUSH
11066: LD_INT 22
11068: PUSH
11069: LD_OWVAR 2
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: PUSH
11078: LD_INT 25
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: ST_TO_ADDR
// if not tmp then
11097: LD_VAR 0 3
11101: NOT
11102: IFFALSE 11106
// exit ;
11104: GO 11192
// un := tmp [ rand ( 1 , tmp ) ] ;
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_VAR 0 3
11115: PUSH
11116: LD_INT 1
11118: PPUSH
11119: LD_VAR 0 3
11123: PPUSH
11124: CALL_OW 12
11128: ARRAY
11129: ST_TO_ADDR
// if Crawls ( un ) then
11130: LD_VAR 0 2
11134: PPUSH
11135: CALL_OW 318
11139: IFFALSE 11150
// ComWalk ( un ) ;
11141: LD_VAR 0 2
11145: PPUSH
11146: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
11150: LD_VAR 0 2
11154: PPUSH
11155: LD_INT 9
11157: PPUSH
11158: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
11162: LD_INT 28
11164: PPUSH
11165: LD_OWVAR 2
11169: PPUSH
11170: LD_INT 2
11172: PPUSH
11173: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
11177: LD_INT 29
11179: PPUSH
11180: LD_OWVAR 2
11184: PPUSH
11185: LD_INT 2
11187: PPUSH
11188: CALL_OW 322
// end ;
11192: PPOPN 3
11194: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
11195: LD_EXP 8
11199: PUSH
11200: LD_EXP 51
11204: AND
11205: IFFALSE 11316
11207: GO 11209
11209: DISABLE
11210: LD_INT 0
11212: PPUSH
11213: PPUSH
11214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: LD_INT 22
11222: PUSH
11223: LD_OWVAR 2
11227: PUSH
11228: EMPTY
11229: LIST
11230: LIST
11231: PUSH
11232: LD_INT 25
11234: PUSH
11235: LD_INT 1
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: EMPTY
11243: LIST
11244: LIST
11245: PPUSH
11246: CALL_OW 69
11250: ST_TO_ADDR
// if not tmp then
11251: LD_VAR 0 3
11255: NOT
11256: IFFALSE 11260
// exit ;
11258: GO 11316
// un := tmp [ rand ( 1 , tmp ) ] ;
11260: LD_ADDR_VAR 0 2
11264: PUSH
11265: LD_VAR 0 3
11269: PUSH
11270: LD_INT 1
11272: PPUSH
11273: LD_VAR 0 3
11277: PPUSH
11278: CALL_OW 12
11282: ARRAY
11283: ST_TO_ADDR
// if Crawls ( un ) then
11284: LD_VAR 0 2
11288: PPUSH
11289: CALL_OW 318
11293: IFFALSE 11304
// ComWalk ( un ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: CALL_OW 138
// SetClass ( un , class_mortar ) ;
11304: LD_VAR 0 2
11308: PPUSH
11309: LD_INT 8
11311: PPUSH
11312: CALL_OW 336
// end ;
11316: PPOPN 3
11318: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
11319: LD_EXP 8
11323: PUSH
11324: LD_EXP 52
11328: AND
11329: IFFALSE 11473
11331: GO 11333
11333: DISABLE
11334: LD_INT 0
11336: PPUSH
11337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
11338: LD_ADDR_VAR 0 2
11342: PUSH
11343: LD_INT 22
11345: PUSH
11346: LD_OWVAR 2
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: PUSH
11355: LD_INT 21
11357: PUSH
11358: LD_INT 2
11360: PUSH
11361: EMPTY
11362: LIST
11363: LIST
11364: PUSH
11365: LD_INT 2
11367: PUSH
11368: LD_INT 34
11370: PUSH
11371: LD_INT 12
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: LD_INT 34
11380: PUSH
11381: LD_INT 51
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: PUSH
11388: LD_INT 34
11390: PUSH
11391: LD_INT 32
11393: PUSH
11394: EMPTY
11395: LIST
11396: LIST
11397: PUSH
11398: EMPTY
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: LIST
11408: PPUSH
11409: CALL_OW 69
11413: ST_TO_ADDR
// if not tmp then
11414: LD_VAR 0 2
11418: NOT
11419: IFFALSE 11423
// exit ;
11421: GO 11473
// for i in tmp do
11423: LD_ADDR_VAR 0 1
11427: PUSH
11428: LD_VAR 0 2
11432: PUSH
11433: FOR_IN
11434: IFFALSE 11471
// if GetCargo ( i , mat_artifact ) = 0 then
11436: LD_VAR 0 1
11440: PPUSH
11441: LD_INT 4
11443: PPUSH
11444: CALL_OW 289
11448: PUSH
11449: LD_INT 0
11451: EQUAL
11452: IFFALSE 11469
// SetCargo ( i , mat_siberit , 100 ) ;
11454: LD_VAR 0 1
11458: PPUSH
11459: LD_INT 3
11461: PPUSH
11462: LD_INT 100
11464: PPUSH
11465: CALL_OW 290
11469: GO 11433
11471: POP
11472: POP
// end ;
11473: PPOPN 2
11475: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
11476: LD_EXP 8
11480: PUSH
11481: LD_EXP 53
11485: AND
11486: IFFALSE 11669
11488: GO 11490
11490: DISABLE
11491: LD_INT 0
11493: PPUSH
11494: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
11495: LD_ADDR_VAR 0 2
11499: PUSH
11500: LD_INT 22
11502: PUSH
11503: LD_OWVAR 2
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PPUSH
11512: CALL_OW 69
11516: ST_TO_ADDR
// if not tmp then
11517: LD_VAR 0 2
11521: NOT
11522: IFFALSE 11526
// exit ;
11524: GO 11669
// for i := 1 to 2 do
11526: LD_ADDR_VAR 0 1
11530: PUSH
11531: DOUBLE
11532: LD_INT 1
11534: DEC
11535: ST_TO_ADDR
11536: LD_INT 2
11538: PUSH
11539: FOR_TO
11540: IFFALSE 11667
// begin uc_side := your_side ;
11542: LD_ADDR_OWVAR 20
11546: PUSH
11547: LD_OWVAR 2
11551: ST_TO_ADDR
// uc_nation := nation_american ;
11552: LD_ADDR_OWVAR 21
11556: PUSH
11557: LD_INT 1
11559: ST_TO_ADDR
// vc_chassis := us_morphling ;
11560: LD_ADDR_OWVAR 37
11564: PUSH
11565: LD_INT 5
11567: ST_TO_ADDR
// vc_engine := engine_siberite ;
11568: LD_ADDR_OWVAR 39
11572: PUSH
11573: LD_INT 3
11575: ST_TO_ADDR
// vc_control := control_computer ;
11576: LD_ADDR_OWVAR 38
11580: PUSH
11581: LD_INT 3
11583: ST_TO_ADDR
// vc_weapon := us_double_laser ;
11584: LD_ADDR_OWVAR 40
11588: PUSH
11589: LD_INT 10
11591: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
11592: LD_VAR 0 2
11596: PUSH
11597: LD_INT 1
11599: ARRAY
11600: PPUSH
11601: CALL_OW 310
11605: NOT
11606: IFFALSE 11653
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
11608: CALL_OW 45
11612: PPUSH
11613: LD_VAR 0 2
11617: PUSH
11618: LD_INT 1
11620: ARRAY
11621: PPUSH
11622: CALL_OW 250
11626: PPUSH
11627: LD_VAR 0 2
11631: PUSH
11632: LD_INT 1
11634: ARRAY
11635: PPUSH
11636: CALL_OW 251
11640: PPUSH
11641: LD_INT 12
11643: PPUSH
11644: LD_INT 1
11646: PPUSH
11647: CALL_OW 50
11651: GO 11665
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
11653: CALL_OW 45
11657: PPUSH
11658: LD_INT 1
11660: PPUSH
11661: CALL_OW 51
// end ;
11665: GO 11539
11667: POP
11668: POP
// end ;
11669: PPOPN 2
11671: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
11672: LD_EXP 8
11676: PUSH
11677: LD_EXP 54
11681: AND
11682: IFFALSE 11904
11684: GO 11686
11686: DISABLE
11687: LD_INT 0
11689: PPUSH
11690: PPUSH
11691: PPUSH
11692: PPUSH
11693: PPUSH
11694: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11695: LD_ADDR_VAR 0 6
11699: PUSH
11700: LD_INT 22
11702: PUSH
11703: LD_OWVAR 2
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: PUSH
11712: LD_INT 21
11714: PUSH
11715: LD_INT 1
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: PUSH
11722: LD_INT 3
11724: PUSH
11725: LD_INT 23
11727: PUSH
11728: LD_INT 0
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 69
11748: ST_TO_ADDR
// if not tmp then
11749: LD_VAR 0 6
11753: NOT
11754: IFFALSE 11758
// exit ;
11756: GO 11904
// s1 := rand ( 1 , 4 ) ;
11758: LD_ADDR_VAR 0 2
11762: PUSH
11763: LD_INT 1
11765: PPUSH
11766: LD_INT 4
11768: PPUSH
11769: CALL_OW 12
11773: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
11774: LD_ADDR_VAR 0 4
11778: PUSH
11779: LD_VAR 0 6
11783: PUSH
11784: LD_INT 1
11786: ARRAY
11787: PPUSH
11788: LD_VAR 0 2
11792: PPUSH
11793: CALL_OW 259
11797: ST_TO_ADDR
// if s1 = 1 then
11798: LD_VAR 0 2
11802: PUSH
11803: LD_INT 1
11805: EQUAL
11806: IFFALSE 11826
// s2 := rand ( 2 , 4 ) else
11808: LD_ADDR_VAR 0 3
11812: PUSH
11813: LD_INT 2
11815: PPUSH
11816: LD_INT 4
11818: PPUSH
11819: CALL_OW 12
11823: ST_TO_ADDR
11824: GO 11834
// s2 := 1 ;
11826: LD_ADDR_VAR 0 3
11830: PUSH
11831: LD_INT 1
11833: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
11834: LD_ADDR_VAR 0 5
11838: PUSH
11839: LD_VAR 0 6
11843: PUSH
11844: LD_INT 1
11846: ARRAY
11847: PPUSH
11848: LD_VAR 0 3
11852: PPUSH
11853: CALL_OW 259
11857: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
11858: LD_VAR 0 6
11862: PUSH
11863: LD_INT 1
11865: ARRAY
11866: PPUSH
11867: LD_VAR 0 2
11871: PPUSH
11872: LD_VAR 0 5
11876: PPUSH
11877: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
11881: LD_VAR 0 6
11885: PUSH
11886: LD_INT 1
11888: ARRAY
11889: PPUSH
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 4
11899: PPUSH
11900: CALL_OW 237
// end ;
11904: PPOPN 6
11906: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
11907: LD_EXP 8
11911: PUSH
11912: LD_EXP 55
11916: AND
11917: IFFALSE 11996
11919: GO 11921
11921: DISABLE
11922: LD_INT 0
11924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
11925: LD_ADDR_VAR 0 1
11929: PUSH
11930: LD_INT 22
11932: PUSH
11933: LD_OWVAR 2
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PUSH
11942: LD_INT 30
11944: PUSH
11945: LD_INT 3
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PPUSH
11956: CALL_OW 69
11960: ST_TO_ADDR
// if not tmp then
11961: LD_VAR 0 1
11965: NOT
11966: IFFALSE 11970
// exit ;
11968: GO 11996
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11970: LD_VAR 0 1
11974: PUSH
11975: LD_INT 1
11977: PPUSH
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 12
11987: ARRAY
11988: PPUSH
11989: LD_INT 1
11991: PPUSH
11992: CALL_OW 234
// end ;
11996: PPOPN 1
11998: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
11999: LD_EXP 8
12003: PUSH
12004: LD_EXP 56
12008: AND
12009: IFFALSE 12121
12011: GO 12013
12013: DISABLE
12014: LD_INT 0
12016: PPUSH
12017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
12018: LD_ADDR_VAR 0 2
12022: PUSH
12023: LD_INT 22
12025: PUSH
12026: LD_OWVAR 2
12030: PUSH
12031: EMPTY
12032: LIST
12033: LIST
12034: PUSH
12035: LD_INT 2
12037: PUSH
12038: LD_INT 30
12040: PUSH
12041: LD_INT 27
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 30
12050: PUSH
12051: LD_INT 26
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: LD_INT 30
12060: PUSH
12061: LD_INT 28
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: LIST
12072: LIST
12073: PUSH
12074: EMPTY
12075: LIST
12076: LIST
12077: PPUSH
12078: CALL_OW 69
12082: ST_TO_ADDR
// if not tmp then
12083: LD_VAR 0 2
12087: NOT
12088: IFFALSE 12092
// exit ;
12090: GO 12121
// for i in tmp do
12092: LD_ADDR_VAR 0 1
12096: PUSH
12097: LD_VAR 0 2
12101: PUSH
12102: FOR_IN
12103: IFFALSE 12119
// SetLives ( i , 1 ) ;
12105: LD_VAR 0 1
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: CALL_OW 234
12117: GO 12102
12119: POP
12120: POP
// end ;
12121: PPOPN 2
12123: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
12124: LD_EXP 8
12128: PUSH
12129: LD_EXP 57
12133: AND
12134: IFFALSE 12408
12136: GO 12138
12138: DISABLE
12139: LD_INT 0
12141: PPUSH
12142: PPUSH
12143: PPUSH
// begin i := rand ( 1 , 7 ) ;
12144: LD_ADDR_VAR 0 1
12148: PUSH
12149: LD_INT 1
12151: PPUSH
12152: LD_INT 7
12154: PPUSH
12155: CALL_OW 12
12159: ST_TO_ADDR
// case i of 1 :
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: DOUBLE
12168: EQUAL
12169: IFTRUE 12173
12171: GO 12183
12173: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
12174: LD_STRING earthquake(getX(game), 0, 32)
12176: PPUSH
12177: CALL_OW 559
12181: GO 12408
12183: LD_INT 2
12185: DOUBLE
12186: EQUAL
12187: IFTRUE 12191
12189: GO 12205
12191: POP
// begin ToLua ( displayStucuk(); ) ;
12192: LD_STRING displayStucuk();
12194: PPUSH
12195: CALL_OW 559
// ResetFog ;
12199: CALL_OW 335
// end ; 3 :
12203: GO 12408
12205: LD_INT 3
12207: DOUBLE
12208: EQUAL
12209: IFTRUE 12213
12211: GO 12317
12213: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12214: LD_ADDR_VAR 0 2
12218: PUSH
12219: LD_INT 22
12221: PUSH
12222: LD_OWVAR 2
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 25
12233: PUSH
12234: LD_INT 1
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PPUSH
12245: CALL_OW 69
12249: ST_TO_ADDR
// if not tmp then
12250: LD_VAR 0 2
12254: NOT
12255: IFFALSE 12259
// exit ;
12257: GO 12408
// un := tmp [ rand ( 1 , tmp ) ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 2
12268: PUSH
12269: LD_INT 1
12271: PPUSH
12272: LD_VAR 0 2
12276: PPUSH
12277: CALL_OW 12
12281: ARRAY
12282: ST_TO_ADDR
// if Crawls ( un ) then
12283: LD_VAR 0 3
12287: PPUSH
12288: CALL_OW 318
12292: IFFALSE 12303
// ComWalk ( un ) ;
12294: LD_VAR 0 3
12298: PPUSH
12299: CALL_OW 138
// SetClass ( un , class_mortar ) ;
12303: LD_VAR 0 3
12307: PPUSH
12308: LD_INT 8
12310: PPUSH
12311: CALL_OW 336
// end ; 4 :
12315: GO 12408
12317: LD_INT 4
12319: DOUBLE
12320: EQUAL
12321: IFTRUE 12325
12323: GO 12386
12325: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12326: LD_ADDR_VAR 0 2
12330: PUSH
12331: LD_INT 22
12333: PUSH
12334: LD_OWVAR 2
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PUSH
12343: LD_INT 30
12345: PUSH
12346: LD_INT 29
12348: PUSH
12349: EMPTY
12350: LIST
12351: LIST
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PPUSH
12357: CALL_OW 69
12361: ST_TO_ADDR
// if not tmp then
12362: LD_VAR 0 2
12366: NOT
12367: IFFALSE 12371
// exit ;
12369: GO 12408
// DestroyUnit ( tmp [ 1 ] ) ;
12371: LD_VAR 0 2
12375: PUSH
12376: LD_INT 1
12378: ARRAY
12379: PPUSH
12380: CALL_OW 65
// end ; 5 .. 7 :
12384: GO 12408
12386: LD_INT 5
12388: DOUBLE
12389: GREATEREQUAL
12390: IFFALSE 12398
12392: LD_INT 7
12394: DOUBLE
12395: LESSEQUAL
12396: IFTRUE 12400
12398: GO 12407
12400: POP
// StreamSibBomb ; end ;
12401: CALL 8658 0 0
12405: GO 12408
12407: POP
// end ;
12408: PPOPN 3
12410: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
12411: LD_EXP 8
12415: PUSH
12416: LD_EXP 58
12420: AND
12421: IFFALSE 12577
12423: GO 12425
12425: DISABLE
12426: LD_INT 0
12428: PPUSH
12429: PPUSH
12430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
12431: LD_ADDR_VAR 0 2
12435: PUSH
12436: LD_INT 81
12438: PUSH
12439: LD_OWVAR 2
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 2
12450: PUSH
12451: LD_INT 21
12453: PUSH
12454: LD_INT 1
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: PUSH
12461: LD_INT 21
12463: PUSH
12464: LD_INT 2
12466: PUSH
12467: EMPTY
12468: LIST
12469: LIST
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: LIST
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PPUSH
12480: CALL_OW 69
12484: ST_TO_ADDR
// if not tmp then
12485: LD_VAR 0 2
12489: NOT
12490: IFFALSE 12494
// exit ;
12492: GO 12577
// p := 0 ;
12494: LD_ADDR_VAR 0 3
12498: PUSH
12499: LD_INT 0
12501: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12502: LD_INT 35
12504: PPUSH
12505: CALL_OW 67
// p := p + 1 ;
12509: LD_ADDR_VAR 0 3
12513: PUSH
12514: LD_VAR 0 3
12518: PUSH
12519: LD_INT 1
12521: PLUS
12522: ST_TO_ADDR
// for i in tmp do
12523: LD_ADDR_VAR 0 1
12527: PUSH
12528: LD_VAR 0 2
12532: PUSH
12533: FOR_IN
12534: IFFALSE 12565
// if GetLives ( i ) < 1000 then
12536: LD_VAR 0 1
12540: PPUSH
12541: CALL_OW 256
12545: PUSH
12546: LD_INT 1000
12548: LESS
12549: IFFALSE 12563
// SetLives ( i , 1000 ) ;
12551: LD_VAR 0 1
12555: PPUSH
12556: LD_INT 1000
12558: PPUSH
12559: CALL_OW 234
12563: GO 12533
12565: POP
12566: POP
// until p > 20 ;
12567: LD_VAR 0 3
12571: PUSH
12572: LD_INT 20
12574: GREATER
12575: IFFALSE 12502
// end ;
12577: PPOPN 3
12579: END
// every 0 0$1 trigger StreamModeActive and sTime do
12580: LD_EXP 8
12584: PUSH
12585: LD_EXP 59
12589: AND
12590: IFFALSE 12625
12592: GO 12594
12594: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
12595: LD_INT 28
12597: PPUSH
12598: LD_OWVAR 2
12602: PPUSH
12603: LD_INT 2
12605: PPUSH
12606: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
12610: LD_INT 30
12612: PPUSH
12613: LD_OWVAR 2
12617: PPUSH
12618: LD_INT 2
12620: PPUSH
12621: CALL_OW 322
// end ;
12625: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
12626: LD_EXP 8
12630: PUSH
12631: LD_EXP 60
12635: AND
12636: IFFALSE 12757
12638: GO 12640
12640: DISABLE
12641: LD_INT 0
12643: PPUSH
12644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12645: LD_ADDR_VAR 0 2
12649: PUSH
12650: LD_INT 22
12652: PUSH
12653: LD_OWVAR 2
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: LD_INT 21
12664: PUSH
12665: LD_INT 1
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: LD_INT 3
12674: PUSH
12675: LD_INT 23
12677: PUSH
12678: LD_INT 0
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: LIST
12693: PPUSH
12694: CALL_OW 69
12698: ST_TO_ADDR
// if not tmp then
12699: LD_VAR 0 2
12703: NOT
12704: IFFALSE 12708
// exit ;
12706: GO 12757
// for i in tmp do
12708: LD_ADDR_VAR 0 1
12712: PUSH
12713: LD_VAR 0 2
12717: PUSH
12718: FOR_IN
12719: IFFALSE 12755
// begin if Crawls ( i ) then
12721: LD_VAR 0 1
12725: PPUSH
12726: CALL_OW 318
12730: IFFALSE 12741
// ComWalk ( i ) ;
12732: LD_VAR 0 1
12736: PPUSH
12737: CALL_OW 138
// SetClass ( i , 2 ) ;
12741: LD_VAR 0 1
12745: PPUSH
12746: LD_INT 2
12748: PPUSH
12749: CALL_OW 336
// end ;
12753: GO 12718
12755: POP
12756: POP
// end ;
12757: PPOPN 2
12759: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
12760: LD_EXP 8
12764: PUSH
12765: LD_EXP 61
12769: AND
12770: IFFALSE 13051
12772: GO 12774
12774: DISABLE
12775: LD_INT 0
12777: PPUSH
12778: PPUSH
12779: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
12780: LD_OWVAR 2
12784: PPUSH
12785: LD_INT 9
12787: PPUSH
12788: LD_INT 1
12790: PPUSH
12791: LD_INT 1
12793: PPUSH
12794: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
12798: LD_INT 9
12800: PPUSH
12801: LD_OWVAR 2
12805: PPUSH
12806: CALL_OW 343
// uc_side := 9 ;
12810: LD_ADDR_OWVAR 20
12814: PUSH
12815: LD_INT 9
12817: ST_TO_ADDR
// uc_nation := 2 ;
12818: LD_ADDR_OWVAR 21
12822: PUSH
12823: LD_INT 2
12825: ST_TO_ADDR
// hc_name := Dark Warrior ;
12826: LD_ADDR_OWVAR 26
12830: PUSH
12831: LD_STRING Dark Warrior
12833: ST_TO_ADDR
// hc_gallery :=  ;
12834: LD_ADDR_OWVAR 33
12838: PUSH
12839: LD_STRING 
12841: ST_TO_ADDR
// hc_noskilllimit := true ;
12842: LD_ADDR_OWVAR 76
12846: PUSH
12847: LD_INT 1
12849: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
12850: LD_ADDR_OWVAR 31
12854: PUSH
12855: LD_INT 30
12857: PUSH
12858: LD_INT 30
12860: PUSH
12861: LD_INT 30
12863: PUSH
12864: LD_INT 30
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: ST_TO_ADDR
// un := CreateHuman ;
12873: LD_ADDR_VAR 0 3
12877: PUSH
12878: CALL_OW 44
12882: ST_TO_ADDR
// hc_noskilllimit := false ;
12883: LD_ADDR_OWVAR 76
12887: PUSH
12888: LD_INT 0
12890: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12891: LD_VAR 0 3
12895: PPUSH
12896: LD_INT 1
12898: PPUSH
12899: CALL_OW 51
// p := 0 ;
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: LD_INT 0
12910: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12911: LD_INT 35
12913: PPUSH
12914: CALL_OW 67
// p := p + 1 ;
12918: LD_ADDR_VAR 0 2
12922: PUSH
12923: LD_VAR 0 2
12927: PUSH
12928: LD_INT 1
12930: PLUS
12931: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
12932: LD_VAR 0 3
12936: PPUSH
12937: CALL_OW 256
12941: PUSH
12942: LD_INT 1000
12944: LESS
12945: IFFALSE 12959
// SetLives ( un , 1000 ) ;
12947: LD_VAR 0 3
12951: PPUSH
12952: LD_INT 1000
12954: PPUSH
12955: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
12959: LD_VAR 0 3
12963: PPUSH
12964: LD_INT 81
12966: PUSH
12967: LD_OWVAR 2
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 91
12978: PUSH
12979: LD_VAR 0 3
12983: PUSH
12984: LD_INT 30
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: LIST
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PPUSH
12996: CALL_OW 69
13000: PPUSH
13001: LD_VAR 0 3
13005: PPUSH
13006: CALL_OW 74
13010: PPUSH
13011: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
13015: LD_VAR 0 2
13019: PUSH
13020: LD_INT 60
13022: GREATER
13023: PUSH
13024: LD_VAR 0 3
13028: PPUSH
13029: CALL_OW 301
13033: OR
13034: IFFALSE 12911
// if un then
13036: LD_VAR 0 3
13040: IFFALSE 13051
// RemoveUnit ( un ) ;
13042: LD_VAR 0 3
13046: PPUSH
13047: CALL_OW 64
// end ;
13051: PPOPN 3
13053: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
13054: LD_INT 0
13056: PPUSH
// case cmd of 301 :
13057: LD_VAR 0 1
13061: PUSH
13062: LD_INT 301
13064: DOUBLE
13065: EQUAL
13066: IFTRUE 13070
13068: GO 13102
13070: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
13071: LD_VAR 0 6
13075: PPUSH
13076: LD_VAR 0 7
13080: PPUSH
13081: LD_VAR 0 8
13085: PPUSH
13086: LD_VAR 0 4
13090: PPUSH
13091: LD_VAR 0 5
13095: PPUSH
13096: CALL 14303 0 5
13100: GO 13223
13102: LD_INT 302
13104: DOUBLE
13105: EQUAL
13106: IFTRUE 13110
13108: GO 13147
13110: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
13111: LD_VAR 0 6
13115: PPUSH
13116: LD_VAR 0 7
13120: PPUSH
13121: LD_VAR 0 8
13125: PPUSH
13126: LD_VAR 0 9
13130: PPUSH
13131: LD_VAR 0 4
13135: PPUSH
13136: LD_VAR 0 5
13140: PPUSH
13141: CALL 14394 0 6
13145: GO 13223
13147: LD_INT 303
13149: DOUBLE
13150: EQUAL
13151: IFTRUE 13155
13153: GO 13192
13155: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
13156: LD_VAR 0 6
13160: PPUSH
13161: LD_VAR 0 7
13165: PPUSH
13166: LD_VAR 0 8
13170: PPUSH
13171: LD_VAR 0 9
13175: PPUSH
13176: LD_VAR 0 4
13180: PPUSH
13181: LD_VAR 0 5
13185: PPUSH
13186: CALL 13228 0 6
13190: GO 13223
13192: LD_INT 304
13194: DOUBLE
13195: EQUAL
13196: IFTRUE 13200
13198: GO 13222
13200: POP
// hHackTeleport ( unit , x , y ) ; end ;
13201: LD_VAR 0 2
13205: PPUSH
13206: LD_VAR 0 4
13210: PPUSH
13211: LD_VAR 0 5
13215: PPUSH
13216: CALL 14987 0 3
13220: GO 13223
13222: POP
// end ;
13223: LD_VAR 0 12
13227: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
13228: LD_INT 0
13230: PPUSH
13231: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
13232: LD_VAR 0 1
13236: PUSH
13237: LD_INT 1
13239: LESS
13240: PUSH
13241: LD_VAR 0 1
13245: PUSH
13246: LD_INT 3
13248: GREATER
13249: OR
13250: PUSH
13251: LD_VAR 0 5
13255: PPUSH
13256: LD_VAR 0 6
13260: PPUSH
13261: CALL_OW 428
13265: OR
13266: IFFALSE 13270
// exit ;
13268: GO 13990
// uc_side := your_side ;
13270: LD_ADDR_OWVAR 20
13274: PUSH
13275: LD_OWVAR 2
13279: ST_TO_ADDR
// uc_nation := nation ;
13280: LD_ADDR_OWVAR 21
13284: PUSH
13285: LD_VAR 0 1
13289: ST_TO_ADDR
// bc_level = 1 ;
13290: LD_ADDR_OWVAR 43
13294: PUSH
13295: LD_INT 1
13297: ST_TO_ADDR
// case btype of 1 :
13298: LD_VAR 0 2
13302: PUSH
13303: LD_INT 1
13305: DOUBLE
13306: EQUAL
13307: IFTRUE 13311
13309: GO 13322
13311: POP
// bc_type := b_depot ; 2 :
13312: LD_ADDR_OWVAR 42
13316: PUSH
13317: LD_INT 0
13319: ST_TO_ADDR
13320: GO 13934
13322: LD_INT 2
13324: DOUBLE
13325: EQUAL
13326: IFTRUE 13330
13328: GO 13341
13330: POP
// bc_type := b_warehouse ; 3 :
13331: LD_ADDR_OWVAR 42
13335: PUSH
13336: LD_INT 1
13338: ST_TO_ADDR
13339: GO 13934
13341: LD_INT 3
13343: DOUBLE
13344: EQUAL
13345: IFTRUE 13349
13347: GO 13360
13349: POP
// bc_type := b_lab ; 4 .. 9 :
13350: LD_ADDR_OWVAR 42
13354: PUSH
13355: LD_INT 6
13357: ST_TO_ADDR
13358: GO 13934
13360: LD_INT 4
13362: DOUBLE
13363: GREATEREQUAL
13364: IFFALSE 13372
13366: LD_INT 9
13368: DOUBLE
13369: LESSEQUAL
13370: IFTRUE 13374
13372: GO 13426
13374: POP
// begin bc_type := b_lab_half ;
13375: LD_ADDR_OWVAR 42
13379: PUSH
13380: LD_INT 7
13382: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
13383: LD_ADDR_OWVAR 44
13387: PUSH
13388: LD_INT 10
13390: PUSH
13391: LD_INT 11
13393: PUSH
13394: LD_INT 12
13396: PUSH
13397: LD_INT 15
13399: PUSH
13400: LD_INT 14
13402: PUSH
13403: LD_INT 13
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: PUSH
13414: LD_VAR 0 2
13418: PUSH
13419: LD_INT 3
13421: MINUS
13422: ARRAY
13423: ST_TO_ADDR
// end ; 10 .. 13 :
13424: GO 13934
13426: LD_INT 10
13428: DOUBLE
13429: GREATEREQUAL
13430: IFFALSE 13438
13432: LD_INT 13
13434: DOUBLE
13435: LESSEQUAL
13436: IFTRUE 13440
13438: GO 13517
13440: POP
// begin bc_type := b_lab_full ;
13441: LD_ADDR_OWVAR 42
13445: PUSH
13446: LD_INT 8
13448: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
13449: LD_ADDR_OWVAR 44
13453: PUSH
13454: LD_INT 10
13456: PUSH
13457: LD_INT 12
13459: PUSH
13460: LD_INT 14
13462: PUSH
13463: LD_INT 13
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: PUSH
13472: LD_VAR 0 2
13476: PUSH
13477: LD_INT 9
13479: MINUS
13480: ARRAY
13481: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
13482: LD_ADDR_OWVAR 45
13486: PUSH
13487: LD_INT 11
13489: PUSH
13490: LD_INT 15
13492: PUSH
13493: LD_INT 12
13495: PUSH
13496: LD_INT 15
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: LIST
13504: PUSH
13505: LD_VAR 0 2
13509: PUSH
13510: LD_INT 9
13512: MINUS
13513: ARRAY
13514: ST_TO_ADDR
// end ; 14 :
13515: GO 13934
13517: LD_INT 14
13519: DOUBLE
13520: EQUAL
13521: IFTRUE 13525
13523: GO 13536
13525: POP
// bc_type := b_workshop ; 15 :
13526: LD_ADDR_OWVAR 42
13530: PUSH
13531: LD_INT 2
13533: ST_TO_ADDR
13534: GO 13934
13536: LD_INT 15
13538: DOUBLE
13539: EQUAL
13540: IFTRUE 13544
13542: GO 13555
13544: POP
// bc_type := b_factory ; 16 :
13545: LD_ADDR_OWVAR 42
13549: PUSH
13550: LD_INT 3
13552: ST_TO_ADDR
13553: GO 13934
13555: LD_INT 16
13557: DOUBLE
13558: EQUAL
13559: IFTRUE 13563
13561: GO 13574
13563: POP
// bc_type := b_ext_gun ; 17 :
13564: LD_ADDR_OWVAR 42
13568: PUSH
13569: LD_INT 17
13571: ST_TO_ADDR
13572: GO 13934
13574: LD_INT 17
13576: DOUBLE
13577: EQUAL
13578: IFTRUE 13582
13580: GO 13610
13582: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
13583: LD_ADDR_OWVAR 42
13587: PUSH
13588: LD_INT 19
13590: PUSH
13591: LD_INT 23
13593: PUSH
13594: LD_INT 19
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: LIST
13601: PUSH
13602: LD_VAR 0 1
13606: ARRAY
13607: ST_TO_ADDR
13608: GO 13934
13610: LD_INT 18
13612: DOUBLE
13613: EQUAL
13614: IFTRUE 13618
13616: GO 13629
13618: POP
// bc_type := b_ext_radar ; 19 :
13619: LD_ADDR_OWVAR 42
13623: PUSH
13624: LD_INT 20
13626: ST_TO_ADDR
13627: GO 13934
13629: LD_INT 19
13631: DOUBLE
13632: EQUAL
13633: IFTRUE 13637
13635: GO 13648
13637: POP
// bc_type := b_ext_radio ; 20 :
13638: LD_ADDR_OWVAR 42
13642: PUSH
13643: LD_INT 22
13645: ST_TO_ADDR
13646: GO 13934
13648: LD_INT 20
13650: DOUBLE
13651: EQUAL
13652: IFTRUE 13656
13654: GO 13667
13656: POP
// bc_type := b_ext_siberium ; 21 :
13657: LD_ADDR_OWVAR 42
13661: PUSH
13662: LD_INT 21
13664: ST_TO_ADDR
13665: GO 13934
13667: LD_INT 21
13669: DOUBLE
13670: EQUAL
13671: IFTRUE 13675
13673: GO 13686
13675: POP
// bc_type := b_ext_computer ; 22 :
13676: LD_ADDR_OWVAR 42
13680: PUSH
13681: LD_INT 24
13683: ST_TO_ADDR
13684: GO 13934
13686: LD_INT 22
13688: DOUBLE
13689: EQUAL
13690: IFTRUE 13694
13692: GO 13705
13694: POP
// bc_type := b_ext_track ; 23 :
13695: LD_ADDR_OWVAR 42
13699: PUSH
13700: LD_INT 16
13702: ST_TO_ADDR
13703: GO 13934
13705: LD_INT 23
13707: DOUBLE
13708: EQUAL
13709: IFTRUE 13713
13711: GO 13724
13713: POP
// bc_type := b_ext_laser ; 24 :
13714: LD_ADDR_OWVAR 42
13718: PUSH
13719: LD_INT 25
13721: ST_TO_ADDR
13722: GO 13934
13724: LD_INT 24
13726: DOUBLE
13727: EQUAL
13728: IFTRUE 13732
13730: GO 13743
13732: POP
// bc_type := b_control_tower ; 25 :
13733: LD_ADDR_OWVAR 42
13737: PUSH
13738: LD_INT 36
13740: ST_TO_ADDR
13741: GO 13934
13743: LD_INT 25
13745: DOUBLE
13746: EQUAL
13747: IFTRUE 13751
13749: GO 13762
13751: POP
// bc_type := b_breastwork ; 26 :
13752: LD_ADDR_OWVAR 42
13756: PUSH
13757: LD_INT 31
13759: ST_TO_ADDR
13760: GO 13934
13762: LD_INT 26
13764: DOUBLE
13765: EQUAL
13766: IFTRUE 13770
13768: GO 13781
13770: POP
// bc_type := b_bunker ; 27 :
13771: LD_ADDR_OWVAR 42
13775: PUSH
13776: LD_INT 32
13778: ST_TO_ADDR
13779: GO 13934
13781: LD_INT 27
13783: DOUBLE
13784: EQUAL
13785: IFTRUE 13789
13787: GO 13800
13789: POP
// bc_type := b_turret ; 28 :
13790: LD_ADDR_OWVAR 42
13794: PUSH
13795: LD_INT 33
13797: ST_TO_ADDR
13798: GO 13934
13800: LD_INT 28
13802: DOUBLE
13803: EQUAL
13804: IFTRUE 13808
13806: GO 13819
13808: POP
// bc_type := b_armoury ; 29 :
13809: LD_ADDR_OWVAR 42
13813: PUSH
13814: LD_INT 4
13816: ST_TO_ADDR
13817: GO 13934
13819: LD_INT 29
13821: DOUBLE
13822: EQUAL
13823: IFTRUE 13827
13825: GO 13838
13827: POP
// bc_type := b_barracks ; 30 :
13828: LD_ADDR_OWVAR 42
13832: PUSH
13833: LD_INT 5
13835: ST_TO_ADDR
13836: GO 13934
13838: LD_INT 30
13840: DOUBLE
13841: EQUAL
13842: IFTRUE 13846
13844: GO 13857
13846: POP
// bc_type := b_solar_power ; 31 :
13847: LD_ADDR_OWVAR 42
13851: PUSH
13852: LD_INT 27
13854: ST_TO_ADDR
13855: GO 13934
13857: LD_INT 31
13859: DOUBLE
13860: EQUAL
13861: IFTRUE 13865
13863: GO 13876
13865: POP
// bc_type := b_oil_power ; 32 :
13866: LD_ADDR_OWVAR 42
13870: PUSH
13871: LD_INT 26
13873: ST_TO_ADDR
13874: GO 13934
13876: LD_INT 32
13878: DOUBLE
13879: EQUAL
13880: IFTRUE 13884
13882: GO 13895
13884: POP
// bc_type := b_siberite_power ; 33 :
13885: LD_ADDR_OWVAR 42
13889: PUSH
13890: LD_INT 28
13892: ST_TO_ADDR
13893: GO 13934
13895: LD_INT 33
13897: DOUBLE
13898: EQUAL
13899: IFTRUE 13903
13901: GO 13914
13903: POP
// bc_type := b_oil_mine ; 34 :
13904: LD_ADDR_OWVAR 42
13908: PUSH
13909: LD_INT 29
13911: ST_TO_ADDR
13912: GO 13934
13914: LD_INT 34
13916: DOUBLE
13917: EQUAL
13918: IFTRUE 13922
13920: GO 13933
13922: POP
// bc_type := b_siberite_mine ; end ;
13923: LD_ADDR_OWVAR 42
13927: PUSH
13928: LD_INT 30
13930: ST_TO_ADDR
13931: GO 13934
13933: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
13934: LD_ADDR_VAR 0 8
13938: PUSH
13939: LD_VAR 0 5
13943: PPUSH
13944: LD_VAR 0 6
13948: PPUSH
13949: LD_VAR 0 3
13953: PPUSH
13954: CALL_OW 47
13958: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
13959: LD_OWVAR 42
13963: PUSH
13964: LD_INT 32
13966: PUSH
13967: LD_INT 33
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: IN
13974: IFFALSE 13990
// PlaceWeaponTurret ( b , weapon ) ;
13976: LD_VAR 0 8
13980: PPUSH
13981: LD_VAR 0 4
13985: PPUSH
13986: CALL_OW 431
// end ;
13990: LD_VAR 0 7
13994: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
13995: LD_INT 0
13997: PPUSH
13998: PPUSH
13999: PPUSH
14000: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14001: LD_ADDR_VAR 0 4
14005: PUSH
14006: LD_INT 22
14008: PUSH
14009: LD_OWVAR 2
14013: PUSH
14014: EMPTY
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 2
14020: PUSH
14021: LD_INT 30
14023: PUSH
14024: LD_INT 0
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PUSH
14031: LD_INT 30
14033: PUSH
14034: LD_INT 1
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: EMPTY
14042: LIST
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: CALL_OW 69
14054: ST_TO_ADDR
// if not tmp then
14055: LD_VAR 0 4
14059: NOT
14060: IFFALSE 14064
// exit ;
14062: GO 14123
// for i in tmp do
14064: LD_ADDR_VAR 0 2
14068: PUSH
14069: LD_VAR 0 4
14073: PUSH
14074: FOR_IN
14075: IFFALSE 14121
// for j = 1 to 3 do
14077: LD_ADDR_VAR 0 3
14081: PUSH
14082: DOUBLE
14083: LD_INT 1
14085: DEC
14086: ST_TO_ADDR
14087: LD_INT 3
14089: PUSH
14090: FOR_TO
14091: IFFALSE 14117
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
14093: LD_VAR 0 2
14097: PPUSH
14098: CALL_OW 274
14102: PPUSH
14103: LD_VAR 0 3
14107: PPUSH
14108: LD_INT 99999
14110: PPUSH
14111: CALL_OW 277
14115: GO 14090
14117: POP
14118: POP
14119: GO 14074
14121: POP
14122: POP
// end ;
14123: LD_VAR 0 1
14127: RET
// export function hHackSetLevel10 ; var i , j ; begin
14128: LD_INT 0
14130: PPUSH
14131: PPUSH
14132: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
14133: LD_ADDR_VAR 0 2
14137: PUSH
14138: LD_INT 21
14140: PUSH
14141: LD_INT 1
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PPUSH
14148: CALL_OW 69
14152: PUSH
14153: FOR_IN
14154: IFFALSE 14206
// if IsSelected ( i ) then
14156: LD_VAR 0 2
14160: PPUSH
14161: CALL_OW 306
14165: IFFALSE 14204
// begin for j := 1 to 4 do
14167: LD_ADDR_VAR 0 3
14171: PUSH
14172: DOUBLE
14173: LD_INT 1
14175: DEC
14176: ST_TO_ADDR
14177: LD_INT 4
14179: PUSH
14180: FOR_TO
14181: IFFALSE 14202
// SetSkill ( i , j , 10 ) ;
14183: LD_VAR 0 2
14187: PPUSH
14188: LD_VAR 0 3
14192: PPUSH
14193: LD_INT 10
14195: PPUSH
14196: CALL_OW 237
14200: GO 14180
14202: POP
14203: POP
// end ;
14204: GO 14153
14206: POP
14207: POP
// end ;
14208: LD_VAR 0 1
14212: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
14213: LD_INT 0
14215: PPUSH
14216: PPUSH
14217: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
14218: LD_ADDR_VAR 0 2
14222: PUSH
14223: LD_INT 22
14225: PUSH
14226: LD_OWVAR 2
14230: PUSH
14231: EMPTY
14232: LIST
14233: LIST
14234: PUSH
14235: LD_INT 21
14237: PUSH
14238: LD_INT 1
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PUSH
14245: EMPTY
14246: LIST
14247: LIST
14248: PPUSH
14249: CALL_OW 69
14253: PUSH
14254: FOR_IN
14255: IFFALSE 14296
// begin for j := 1 to 4 do
14257: LD_ADDR_VAR 0 3
14261: PUSH
14262: DOUBLE
14263: LD_INT 1
14265: DEC
14266: ST_TO_ADDR
14267: LD_INT 4
14269: PUSH
14270: FOR_TO
14271: IFFALSE 14292
// SetSkill ( i , j , 10 ) ;
14273: LD_VAR 0 2
14277: PPUSH
14278: LD_VAR 0 3
14282: PPUSH
14283: LD_INT 10
14285: PPUSH
14286: CALL_OW 237
14290: GO 14270
14292: POP
14293: POP
// end ;
14294: GO 14254
14296: POP
14297: POP
// end ;
14298: LD_VAR 0 1
14302: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
14303: LD_INT 0
14305: PPUSH
// uc_side := your_side ;
14306: LD_ADDR_OWVAR 20
14310: PUSH
14311: LD_OWVAR 2
14315: ST_TO_ADDR
// uc_nation := nation ;
14316: LD_ADDR_OWVAR 21
14320: PUSH
14321: LD_VAR 0 1
14325: ST_TO_ADDR
// InitHc ;
14326: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
14330: LD_INT 0
14332: PPUSH
14333: LD_VAR 0 2
14337: PPUSH
14338: LD_VAR 0 3
14342: PPUSH
14343: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
14347: LD_VAR 0 4
14351: PPUSH
14352: LD_VAR 0 5
14356: PPUSH
14357: CALL_OW 428
14361: PUSH
14362: LD_INT 0
14364: EQUAL
14365: IFFALSE 14389
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
14367: CALL_OW 44
14371: PPUSH
14372: LD_VAR 0 4
14376: PPUSH
14377: LD_VAR 0 5
14381: PPUSH
14382: LD_INT 1
14384: PPUSH
14385: CALL_OW 48
// end ;
14389: LD_VAR 0 6
14393: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
14394: LD_INT 0
14396: PPUSH
14397: PPUSH
// uc_side := your_side ;
14398: LD_ADDR_OWVAR 20
14402: PUSH
14403: LD_OWVAR 2
14407: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
14408: LD_VAR 0 1
14412: PUSH
14413: LD_INT 1
14415: PUSH
14416: LD_INT 2
14418: PUSH
14419: LD_INT 3
14421: PUSH
14422: LD_INT 4
14424: PUSH
14425: LD_INT 5
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: IN
14435: IFFALSE 14447
// uc_nation := nation_american else
14437: LD_ADDR_OWVAR 21
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
14445: GO 14490
// if chassis in [ 11 , 12 , 13 , 14 ] then
14447: LD_VAR 0 1
14451: PUSH
14452: LD_INT 11
14454: PUSH
14455: LD_INT 12
14457: PUSH
14458: LD_INT 13
14460: PUSH
14461: LD_INT 14
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: IN
14470: IFFALSE 14482
// uc_nation := nation_arabian else
14472: LD_ADDR_OWVAR 21
14476: PUSH
14477: LD_INT 2
14479: ST_TO_ADDR
14480: GO 14490
// uc_nation := nation_russian ;
14482: LD_ADDR_OWVAR 21
14486: PUSH
14487: LD_INT 3
14489: ST_TO_ADDR
// vc_chassis := chassis ;
14490: LD_ADDR_OWVAR 37
14494: PUSH
14495: LD_VAR 0 1
14499: ST_TO_ADDR
// vc_engine := engine ;
14500: LD_ADDR_OWVAR 39
14504: PUSH
14505: LD_VAR 0 2
14509: ST_TO_ADDR
// vc_control := control ;
14510: LD_ADDR_OWVAR 38
14514: PUSH
14515: LD_VAR 0 3
14519: ST_TO_ADDR
// vc_weapon := weapon ;
14520: LD_ADDR_OWVAR 40
14524: PUSH
14525: LD_VAR 0 4
14529: ST_TO_ADDR
// un := CreateVehicle ;
14530: LD_ADDR_VAR 0 8
14534: PUSH
14535: CALL_OW 45
14539: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
14540: LD_VAR 0 8
14544: PPUSH
14545: LD_INT 0
14547: PPUSH
14548: LD_INT 5
14550: PPUSH
14551: CALL_OW 12
14555: PPUSH
14556: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
14560: LD_VAR 0 8
14564: PPUSH
14565: LD_VAR 0 5
14569: PPUSH
14570: LD_VAR 0 6
14574: PPUSH
14575: LD_INT 1
14577: PPUSH
14578: CALL_OW 48
// end ;
14582: LD_VAR 0 7
14586: RET
// export hInvincible ; every 1 do
14587: GO 14589
14589: DISABLE
// hInvincible := [ ] ;
14590: LD_ADDR_EXP 62
14594: PUSH
14595: EMPTY
14596: ST_TO_ADDR
14597: END
// every 10 do var i ;
14598: GO 14600
14600: DISABLE
14601: LD_INT 0
14603: PPUSH
// begin enable ;
14604: ENABLE
// if not hInvincible then
14605: LD_EXP 62
14609: NOT
14610: IFFALSE 14614
// exit ;
14612: GO 14658
// for i in hInvincible do
14614: LD_ADDR_VAR 0 1
14618: PUSH
14619: LD_EXP 62
14623: PUSH
14624: FOR_IN
14625: IFFALSE 14656
// if GetLives ( i ) < 1000 then
14627: LD_VAR 0 1
14631: PPUSH
14632: CALL_OW 256
14636: PUSH
14637: LD_INT 1000
14639: LESS
14640: IFFALSE 14654
// SetLives ( i , 1000 ) ;
14642: LD_VAR 0 1
14646: PPUSH
14647: LD_INT 1000
14649: PPUSH
14650: CALL_OW 234
14654: GO 14624
14656: POP
14657: POP
// end ;
14658: PPOPN 1
14660: END
// export function hHackInvincible ; var i ; begin
14661: LD_INT 0
14663: PPUSH
14664: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
14665: LD_ADDR_VAR 0 2
14669: PUSH
14670: LD_INT 2
14672: PUSH
14673: LD_INT 21
14675: PUSH
14676: LD_INT 1
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: LD_INT 21
14685: PUSH
14686: LD_INT 2
14688: PUSH
14689: EMPTY
14690: LIST
14691: LIST
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 69
14702: PUSH
14703: FOR_IN
14704: IFFALSE 14765
// if IsSelected ( i ) then
14706: LD_VAR 0 2
14710: PPUSH
14711: CALL_OW 306
14715: IFFALSE 14763
// begin if i in hInvincible then
14717: LD_VAR 0 2
14721: PUSH
14722: LD_EXP 62
14726: IN
14727: IFFALSE 14747
// hInvincible := hInvincible diff i else
14729: LD_ADDR_EXP 62
14733: PUSH
14734: LD_EXP 62
14738: PUSH
14739: LD_VAR 0 2
14743: DIFF
14744: ST_TO_ADDR
14745: GO 14763
// hInvincible := hInvincible union i ;
14747: LD_ADDR_EXP 62
14751: PUSH
14752: LD_EXP 62
14756: PUSH
14757: LD_VAR 0 2
14761: UNION
14762: ST_TO_ADDR
// end ;
14763: GO 14703
14765: POP
14766: POP
// end ;
14767: LD_VAR 0 1
14771: RET
// export function hHackInvisible ; var i , j ; begin
14772: LD_INT 0
14774: PPUSH
14775: PPUSH
14776: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
14777: LD_ADDR_VAR 0 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PPUSH
14792: CALL_OW 69
14796: PUSH
14797: FOR_IN
14798: IFFALSE 14822
// if IsSelected ( i ) then
14800: LD_VAR 0 2
14804: PPUSH
14805: CALL_OW 306
14809: IFFALSE 14820
// ComForceInvisible ( i ) ;
14811: LD_VAR 0 2
14815: PPUSH
14816: CALL_OW 496
14820: GO 14797
14822: POP
14823: POP
// end ;
14824: LD_VAR 0 1
14828: RET
// export function hHackChangeYourSide ; begin
14829: LD_INT 0
14831: PPUSH
// if your_side = 8 then
14832: LD_OWVAR 2
14836: PUSH
14837: LD_INT 8
14839: EQUAL
14840: IFFALSE 14852
// your_side := 0 else
14842: LD_ADDR_OWVAR 2
14846: PUSH
14847: LD_INT 0
14849: ST_TO_ADDR
14850: GO 14866
// your_side := your_side + 1 ;
14852: LD_ADDR_OWVAR 2
14856: PUSH
14857: LD_OWVAR 2
14861: PUSH
14862: LD_INT 1
14864: PLUS
14865: ST_TO_ADDR
// end ;
14866: LD_VAR 0 1
14870: RET
// export function hHackChangeUnitSide ; var i , j ; begin
14871: LD_INT 0
14873: PPUSH
14874: PPUSH
14875: PPUSH
// for i in all_units do
14876: LD_ADDR_VAR 0 2
14880: PUSH
14881: LD_OWVAR 3
14885: PUSH
14886: FOR_IN
14887: IFFALSE 14965
// if IsSelected ( i ) then
14889: LD_VAR 0 2
14893: PPUSH
14894: CALL_OW 306
14898: IFFALSE 14963
// begin j := GetSide ( i ) ;
14900: LD_ADDR_VAR 0 3
14904: PUSH
14905: LD_VAR 0 2
14909: PPUSH
14910: CALL_OW 255
14914: ST_TO_ADDR
// if j = 8 then
14915: LD_VAR 0 3
14919: PUSH
14920: LD_INT 8
14922: EQUAL
14923: IFFALSE 14935
// j := 0 else
14925: LD_ADDR_VAR 0 3
14929: PUSH
14930: LD_INT 0
14932: ST_TO_ADDR
14933: GO 14949
// j := j + 1 ;
14935: LD_ADDR_VAR 0 3
14939: PUSH
14940: LD_VAR 0 3
14944: PUSH
14945: LD_INT 1
14947: PLUS
14948: ST_TO_ADDR
// SetSide ( i , j ) ;
14949: LD_VAR 0 2
14953: PPUSH
14954: LD_VAR 0 3
14958: PPUSH
14959: CALL_OW 235
// end ;
14963: GO 14886
14965: POP
14966: POP
// end ;
14967: LD_VAR 0 1
14971: RET
// export function hHackFog ; begin
14972: LD_INT 0
14974: PPUSH
// FogOff ( true ) ;
14975: LD_INT 1
14977: PPUSH
14978: CALL_OW 344
// end ;
14982: LD_VAR 0 1
14986: RET
// export function hHackTeleport ( unit , x , y ) ; begin
14987: LD_INT 0
14989: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_VAR 0 2
14999: PPUSH
15000: LD_VAR 0 3
15004: PPUSH
15005: LD_INT 1
15007: PPUSH
15008: LD_INT 1
15010: PPUSH
15011: CALL_OW 483
// CenterOnXY ( x , y ) ;
15015: LD_VAR 0 2
15019: PPUSH
15020: LD_VAR 0 3
15024: PPUSH
15025: CALL_OW 84
// end ;
15029: LD_VAR 0 4
15033: RET
