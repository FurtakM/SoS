// starting begin ResetFog ;
   0: CALL_OW 335
// CenterNowOnXY ( 136 , 106 ) ;
   4: LD_INT 136
   6: PPUSH
   7: LD_INT 106
   9: PPUSH
  10: CALL_OW 86
// Init ;
  14: CALL 75 0 0
// PrepareNature ( nat_area , wat_area , [ 10 , 2 * Difficulty , 6 , 6 , 3 * Difficulty , 6 , 4 ] ) ;
  18: LD_INT 2
  20: PPUSH
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 10
  26: PUSH
  27: LD_INT 2
  29: PUSH
  30: LD_OWVAR 67
  34: MUL
  35: PUSH
  36: LD_INT 6
  38: PUSH
  39: LD_INT 6
  41: PUSH
  42: LD_INT 3
  44: PUSH
  45: LD_OWVAR 67
  49: MUL
  50: PUSH
  51: LD_INT 6
  53: PUSH
  54: LD_INT 4
  56: PUSH
  57: EMPTY
  58: LIST
  59: LIST
  60: LIST
  61: LIST
  62: LIST
  63: LIST
  64: LIST
  65: PPUSH
  66: CALL 395 0 3
// PrepareHunters ( ) ;
  70: CALL 241 0 0
// end ;
  74: END
// export debug , hunterClass , huntersAmount , animalAmount ; export class_horse ; export points , hunters ; function Init ; begin
  75: LD_INT 0
  77: PPUSH
// debug := 0 ;
  78: LD_ADDR_EXP 1
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// class_horse := 21 ;
  86: LD_ADDR_EXP 5
  90: PUSH
  91: LD_INT 21
  93: ST_TO_ADDR
// if debug then
  94: LD_EXP 1
  98: IFFALSE 133
// begin FogOff ( 1 ) ;
 100: LD_INT 1
 102: PPUSH
 103: CALL_OW 344
// Difficulty := 2 ;
 107: LD_ADDR_OWVAR 67
 111: PUSH
 112: LD_INT 2
 114: ST_TO_ADDR
// hunterClass := 3 ;
 115: LD_ADDR_EXP 2
 119: PUSH
 120: LD_INT 3
 122: ST_TO_ADDR
// animalAmount := 2 ;
 123: LD_ADDR_EXP 4
 127: PUSH
 128: LD_INT 2
 130: ST_TO_ADDR
// end else
 131: GO 172
// begin Difficulty := GetMultiplayerSetting ( 0 ) ;
 133: LD_ADDR_OWVAR 67
 137: PUSH
 138: LD_INT 0
 140: PPUSH
 141: CALL_OW 426
 145: ST_TO_ADDR
// hunterClass := GetMultiplayerSetting ( 2 ) ;
 146: LD_ADDR_EXP 2
 150: PUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL_OW 426
 158: ST_TO_ADDR
// animalAmount := GetMultiplayerSetting ( 1 ) ;
 159: LD_ADDR_EXP 4
 163: PUSH
 164: LD_INT 1
 166: PPUSH
 167: CALL_OW 426
 171: ST_TO_ADDR
// end ; huntersAmount := [ 4 , 6 , 8 ] [ Difficulty ] ;
 172: LD_ADDR_EXP 3
 176: PUSH
 177: LD_INT 4
 179: PUSH
 180: LD_INT 6
 182: PUSH
 183: LD_INT 8
 185: PUSH
 186: EMPTY
 187: LIST
 188: LIST
 189: LIST
 190: PUSH
 191: LD_OWVAR 67
 195: ARRAY
 196: ST_TO_ADDR
// points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 197: LD_ADDR_EXP 6
 201: PUSH
 202: LD_INT 0
 204: PUSH
 205: LD_INT 0
 207: PUSH
 208: LD_INT 0
 210: PUSH
 211: LD_INT 0
 213: PUSH
 214: LD_INT 0
 216: PUSH
 217: LD_INT 0
 219: PUSH
 220: LD_INT 0
 222: PUSH
 223: LD_INT 0
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// end ;
 236: LD_VAR 0 1
 240: RET
// export function PrepareHunters ; var i , un ; begin
 241: LD_INT 0
 243: PPUSH
 244: PPUSH
 245: PPUSH
// for i := 1 to huntersAmount do
 246: LD_ADDR_VAR 0 2
 250: PUSH
 251: DOUBLE
 252: LD_INT 1
 254: DEC
 255: ST_TO_ADDR
 256: LD_EXP 3
 260: PUSH
 261: FOR_TO
 262: IFFALSE 388
// begin uc_side := i ;
 264: LD_ADDR_OWVAR 20
 268: PUSH
 269: LD_VAR 0 2
 273: ST_TO_ADDR
// uc_nation := i mod 3 + 1 ;
 274: LD_ADDR_OWVAR 21
 278: PUSH
 279: LD_VAR 0 2
 283: PUSH
 284: LD_INT 3
 286: MOD
 287: PUSH
 288: LD_INT 1
 290: PLUS
 291: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_sniper , class_desert_warior ] [ hunterClass ] , 10 - Difficulty * 2 ) ;
 292: LD_INT 0
 294: PPUSH
 295: LD_INT 1
 297: PUSH
 298: LD_INT 5
 300: PUSH
 301: LD_INT 11
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: LIST
 308: PUSH
 309: LD_EXP 2
 313: ARRAY
 314: PPUSH
 315: LD_INT 10
 317: PUSH
 318: LD_OWVAR 67
 322: PUSH
 323: LD_INT 2
 325: MUL
 326: MINUS
 327: PPUSH
 328: CALL_OW 380
// un := CreateHuman ;
 332: LD_ADDR_VAR 0 3
 336: PUSH
 337: CALL_OW 44
 341: ST_TO_ADDR
// hunters := Replace ( hunters , hunters + 1 , un ) ;
 342: LD_ADDR_EXP 7
 346: PUSH
 347: LD_EXP 7
 351: PPUSH
 352: LD_EXP 7
 356: PUSH
 357: LD_INT 1
 359: PLUS
 360: PPUSH
 361: LD_VAR 0 3
 365: PPUSH
 366: CALL_OW 1
 370: ST_TO_ADDR
// PlaceUnitArea ( un , startArea , false ) ;
 371: LD_VAR 0 3
 375: PPUSH
 376: LD_INT 4
 378: PPUSH
 379: LD_INT 0
 381: PPUSH
 382: CALL_OW 49
// end ;
 386: GO 261
 388: POP
 389: POP
// end ; end_of_file
 390: LD_VAR 0 1
 394: RET
// export function PrepareNature ( area , waterArea , numbers ) ; var i , j , classes , waterClass ; begin
 395: LD_INT 0
 397: PPUSH
 398: PPUSH
 399: PPUSH
 400: PPUSH
 401: PPUSH
// uc_side = 0 ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// uc_nation = 0 ;
 410: LD_ADDR_OWVAR 21
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// classes := [ class_apeman , class_apeman_soldier , class_baggie , class_phororhacos , class_tiger , class_horse ] ;
 418: LD_ADDR_VAR 0 7
 422: PUSH
 423: LD_INT 12
 425: PUSH
 426: LD_INT 15
 428: PUSH
 429: LD_INT 13
 431: PUSH
 432: LD_INT 18
 434: PUSH
 435: LD_INT 14
 437: PUSH
 438: LD_EXP 5
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: ST_TO_ADDR
// waterClass := [ class_fish ] ;
 451: LD_ADDR_VAR 0 8
 455: PUSH
 456: LD_INT 20
 458: PUSH
 459: EMPTY
 460: LIST
 461: ST_TO_ADDR
// InitHc_All ( ) ;
 462: CALL_OW 584
// for i := 1 to numbers - 2 do
 466: LD_ADDR_VAR 0 5
 470: PUSH
 471: DOUBLE
 472: LD_INT 1
 474: DEC
 475: ST_TO_ADDR
 476: LD_VAR 0 3
 480: PUSH
 481: LD_INT 2
 483: MINUS
 484: PUSH
 485: FOR_TO
 486: IFFALSE 627
// begin if numbers [ i ] = 0 then
 488: LD_VAR 0 3
 492: PUSH
 493: LD_VAR 0 5
 497: ARRAY
 498: PUSH
 499: LD_INT 0
 501: EQUAL
 502: IFFALSE 506
// continue ;
 504: GO 485
// hc_class := classes [ i ] ;
 506: LD_ADDR_OWVAR 28
 510: PUSH
 511: LD_VAR 0 7
 515: PUSH
 516: LD_VAR 0 5
 520: ARRAY
 521: ST_TO_ADDR
// hc_attr := [ rand ( 8 , 12 ) , rand ( 8 , 12 ) ] ;
 522: LD_ADDR_OWVAR 29
 526: PUSH
 527: LD_INT 8
 529: PPUSH
 530: LD_INT 12
 532: PPUSH
 533: CALL_OW 12
 537: PUSH
 538: LD_INT 8
 540: PPUSH
 541: LD_INT 12
 543: PPUSH
 544: CALL_OW 12
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) + Difficulty * 5 ;
 553: LD_ADDR_OWVAR 35
 557: PUSH
 558: LD_INT 5
 560: NEG
 561: PPUSH
 562: LD_INT 5
 564: PPUSH
 565: CALL_OW 12
 569: PUSH
 570: LD_OWVAR 67
 574: PUSH
 575: LD_INT 5
 577: MUL
 578: PLUS
 579: ST_TO_ADDR
// for j := 1 to numbers [ i ] do
 580: LD_ADDR_VAR 0 6
 584: PUSH
 585: DOUBLE
 586: LD_INT 1
 588: DEC
 589: ST_TO_ADDR
 590: LD_VAR 0 3
 594: PUSH
 595: LD_VAR 0 5
 599: ARRAY
 600: PUSH
 601: FOR_TO
 602: IFFALSE 623
// PlaceUnitArea ( CreateHuman , area , false ) ;
 604: CALL_OW 44
 608: PPUSH
 609: LD_VAR 0 1
 613: PPUSH
 614: LD_INT 0
 616: PPUSH
 617: CALL_OW 49
 621: GO 601
 623: POP
 624: POP
// end ;
 625: GO 485
 627: POP
 628: POP
// if not waterArea then
 629: LD_VAR 0 2
 633: NOT
 634: IFFALSE 638
// exit ;
 636: GO 718
// hc_class := waterClass [ 1 ] ;
 638: LD_ADDR_OWVAR 28
 642: PUSH
 643: LD_VAR 0 8
 647: PUSH
 648: LD_INT 1
 650: ARRAY
 651: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
 652: LD_ADDR_OWVAR 29
 656: PUSH
 657: LD_INT 10
 659: PUSH
 660: LD_INT 10
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: ST_TO_ADDR
// hc_agressivity := 0 ;
 667: LD_ADDR_OWVAR 35
 671: PUSH
 672: LD_INT 0
 674: ST_TO_ADDR
// for j := 1 to numbers [ 7 ] do
 675: LD_ADDR_VAR 0 6
 679: PUSH
 680: DOUBLE
 681: LD_INT 1
 683: DEC
 684: ST_TO_ADDR
 685: LD_VAR 0 3
 689: PUSH
 690: LD_INT 7
 692: ARRAY
 693: PUSH
 694: FOR_TO
 695: IFFALSE 716
// PlaceUnitArea ( CreateHuman , waterArea , false ) ;
 697: CALL_OW 44
 701: PPUSH
 702: LD_VAR 0 2
 706: PPUSH
 707: LD_INT 0
 709: PPUSH
 710: CALL_OW 49
 714: GO 694
 716: POP
 717: POP
// end ; end_of_file
 718: LD_VAR 0 4
 722: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do var i ;
 723: LD_INT 22
 725: PUSH
 726: LD_INT 0
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: PUSH
 733: LD_INT 25
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: PPUSH
 747: CALL_OW 69
 751: IFFALSE 857
 753: GO 755
 755: DISABLE
 756: LD_INT 0
 758: PPUSH
// begin enable ;
 759: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman_soldier ] ] ) do
 760: LD_ADDR_VAR 0 1
 764: PUSH
 765: LD_INT 22
 767: PUSH
 768: LD_INT 0
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: PUSH
 775: LD_INT 25
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PPUSH
 789: CALL_OW 69
 793: PUSH
 794: FOR_IN
 795: IFFALSE 855
// if GetLives ( i ) < 1000 then
 797: LD_VAR 0 1
 801: PPUSH
 802: CALL_OW 256
 806: PUSH
 807: LD_INT 1000
 809: LESS
 810: IFFALSE 853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , i ) ) ;
 812: LD_VAR 0 1
 816: PPUSH
 817: LD_INT 3
 819: PUSH
 820: LD_INT 22
 822: PUSH
 823: LD_INT 0
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: LD_VAR 0 1
 843: PPUSH
 844: CALL_OW 74
 848: PPUSH
 849: CALL_OW 115
 853: GO 794
 855: POP
 856: POP
// end ;
 857: PPOPN 1
 859: END
// every 3 do var i , enemy , x , y , d ;
 860: GO 862
 862: DISABLE
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
 867: PPUSH
 868: PPUSH
 869: PPUSH
// begin enable ;
 870: ENABLE
// for i := 2 to huntersAmount do
 871: LD_ADDR_VAR 0 1
 875: PUSH
 876: DOUBLE
 877: LD_INT 2
 879: DEC
 880: ST_TO_ADDR
 881: LD_EXP 3
 885: PUSH
 886: FOR_TO
 887: IFFALSE 1226
// begin if not HasTask ( hunters [ i ] ) then
 889: LD_EXP 7
 893: PUSH
 894: LD_VAR 0 1
 898: ARRAY
 899: PPUSH
 900: CALL_OW 314
 904: NOT
 905: IFFALSE 1224
// begin enemy := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 0 ] ) , hunters [ i ] ) ;
 907: LD_ADDR_VAR 0 2
 911: PUSH
 912: LD_INT 22
 914: PUSH
 915: LD_INT 0
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: PPUSH
 922: CALL_OW 69
 926: PPUSH
 927: LD_EXP 7
 931: PUSH
 932: LD_VAR 0 1
 936: ARRAY
 937: PPUSH
 938: CALL_OW 74
 942: ST_TO_ADDR
// if not enemy then
 943: LD_VAR 0 2
 947: NOT
 948: IFFALSE 952
// continue ;
 950: GO 886
// if GetDistUnits ( hunters [ i ] , enemy ) < 17 then
 952: LD_EXP 7
 956: PUSH
 957: LD_VAR 0 1
 961: ARRAY
 962: PPUSH
 963: LD_VAR 0 2
 967: PPUSH
 968: CALL_OW 296
 972: PUSH
 973: LD_INT 17
 975: LESS
 976: IFFALSE 1079
// begin if GetClass ( hunters [ i ] ) = class_desert_warior then
 978: LD_EXP 7
 982: PUSH
 983: LD_VAR 0 1
 987: ARRAY
 988: PPUSH
 989: CALL_OW 257
 993: PUSH
 994: LD_INT 11
 996: EQUAL
 997: IFFALSE 1057
// if GetClass ( enemy ) in [ class_frog , class_fish , class_baggie ] then
 999: LD_VAR 0 2
1003: PPUSH
1004: CALL_OW 257
1008: PUSH
1009: LD_INT 19
1011: PUSH
1012: LD_INT 20
1014: PUSH
1015: LD_INT 13
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: IN
1023: IFFALSE 1042
// ComCarabine ( hunters [ i ] ) else
1025: LD_EXP 7
1029: PUSH
1030: LD_VAR 0 1
1034: ARRAY
1035: PPUSH
1036: CALL_OW 162
1040: GO 1057
// ComSabre ( hunters [ i ] ) ;
1042: LD_EXP 7
1046: PUSH
1047: LD_VAR 0 1
1051: ARRAY
1052: PPUSH
1053: CALL_OW 163
// ComAttackUnit ( hunters [ i ] , enemy ) ;
1057: LD_EXP 7
1061: PUSH
1062: LD_VAR 0 1
1066: ARRAY
1067: PPUSH
1068: LD_VAR 0 2
1072: PPUSH
1073: CALL_OW 115
// end else
1077: GO 1224
// begin d := rand ( 0 , 5 ) ;
1079: LD_ADDR_VAR 0 5
1083: PUSH
1084: LD_INT 0
1086: PPUSH
1087: LD_INT 5
1089: PPUSH
1090: CALL_OW 12
1094: ST_TO_ADDR
// x := ShiftX ( GetX ( hunters [ i ] ) , d , 8 ) ;
1095: LD_ADDR_VAR 0 3
1099: PUSH
1100: LD_EXP 7
1104: PUSH
1105: LD_VAR 0 1
1109: ARRAY
1110: PPUSH
1111: CALL_OW 250
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: LD_INT 8
1123: PPUSH
1124: CALL_OW 272
1128: ST_TO_ADDR
// y := ShiftY ( GetY ( hunters [ i ] ) , d , 8 ) ;
1129: LD_ADDR_VAR 0 4
1133: PUSH
1134: LD_EXP 7
1138: PUSH
1139: LD_VAR 0 1
1143: ARRAY
1144: PPUSH
1145: CALL_OW 251
1149: PPUSH
1150: LD_VAR 0 5
1154: PPUSH
1155: LD_INT 8
1157: PPUSH
1158: CALL_OW 273
1162: ST_TO_ADDR
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
1163: LD_VAR 0 3
1167: PPUSH
1168: LD_VAR 0 4
1172: PPUSH
1173: CALL_OW 488
1177: PUSH
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_VAR 0 4
1187: PPUSH
1188: CALL_OW 428
1192: PUSH
1193: LD_INT 0
1195: EQUAL
1196: AND
1197: IFFALSE 1224
// ComMoveXY ( hunters [ i ] , x , y ) ;
1199: LD_EXP 7
1203: PUSH
1204: LD_VAR 0 1
1208: ARRAY
1209: PPUSH
1210: LD_VAR 0 3
1214: PPUSH
1215: LD_VAR 0 4
1219: PPUSH
1220: CALL_OW 111
// end ; end ; end ;
1224: GO 886
1226: POP
1227: POP
// end ; end_of_file
1228: PPOPN 5
1230: END
// on UnitGoesToRed ( un ) do var i ;
1231: LD_INT 0
1233: PPUSH
// begin if GetSide ( un ) = 1 then
1234: LD_VAR 0 1
1238: PPUSH
1239: CALL_OW 255
1243: PUSH
1244: LD_INT 1
1246: EQUAL
1247: IFFALSE 1256
// YouLost ( hunt2 ) ;
1249: LD_STRING hunt2
1251: PPUSH
1252: CALL_OW 104
// if GetSide ( un ) > 1 then
1256: LD_VAR 0 1
1260: PPUSH
1261: CALL_OW 255
1265: PUSH
1266: LD_INT 1
1268: GREATER
1269: IFFALSE 1322
// begin for i := 1 to 6 do
1271: LD_ADDR_VAR 0 2
1275: PUSH
1276: DOUBLE
1277: LD_INT 1
1279: DEC
1280: ST_TO_ADDR
1281: LD_INT 6
1283: PUSH
1284: FOR_TO
1285: IFFALSE 1308
// begin wait ( 0 0$1 ) ;
1287: LD_INT 35
1289: PPUSH
1290: CALL_OW 67
// SetLives ( un , 249 ) ;
1294: LD_VAR 0 1
1298: PPUSH
1299: LD_INT 249
1301: PPUSH
1302: CALL_OW 234
// end ;
1306: GO 1284
1308: POP
1309: POP
// SetLives ( un , 1000 ) ;
1310: LD_VAR 0 1
1314: PPUSH
1315: LD_INT 1000
1317: PPUSH
1318: CALL_OW 234
// end ; end ;
1322: PPOPN 2
1324: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 > 1 then
1325: LD_VAR 0 1
1329: PUSH
1330: LD_INT 1
1332: EQUAL
1333: PUSH
1334: LD_VAR 0 2
1338: PUSH
1339: LD_INT 1
1341: GREATER
1342: AND
1343: IFFALSE 1352
// YouLost ( hunt1 ) ;
1345: LD_STRING hunt1
1347: PPUSH
1348: CALL_OW 104
// end ;
1352: PPOPN 2
1354: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do var point ;
1355: LD_INT 0
1357: PPUSH
// begin point := 0 ;
1358: LD_ADDR_VAR 0 4
1362: PUSH
1363: LD_INT 0
1365: ST_TO_ADDR
// case GetClass ( un ) of class_fish :
1366: LD_VAR 0 1
1370: PPUSH
1371: CALL_OW 257
1375: PUSH
1376: LD_INT 20
1378: DOUBLE
1379: EQUAL
1380: IFTRUE 1384
1382: GO 1395
1384: POP
// point := 10 ; class_horse :
1385: LD_ADDR_VAR 0 4
1389: PUSH
1390: LD_INT 10
1392: ST_TO_ADDR
1393: GO 1531
1395: LD_EXP 5
1399: DOUBLE
1400: EQUAL
1401: IFTRUE 1405
1403: GO 1416
1405: POP
// point := 10 ; class_baggie :
1406: LD_ADDR_VAR 0 4
1410: PUSH
1411: LD_INT 10
1413: ST_TO_ADDR
1414: GO 1531
1416: LD_INT 13
1418: DOUBLE
1419: EQUAL
1420: IFTRUE 1424
1422: GO 1435
1424: POP
// point := 5 ; class_phororhacos :
1425: LD_ADDR_VAR 0 4
1429: PUSH
1430: LD_INT 5
1432: ST_TO_ADDR
1433: GO 1531
1435: LD_INT 18
1437: DOUBLE
1438: EQUAL
1439: IFTRUE 1443
1441: GO 1454
1443: POP
// point := 10 ; class_tiger :
1444: LD_ADDR_VAR 0 4
1448: PUSH
1449: LD_INT 10
1451: ST_TO_ADDR
1452: GO 1531
1454: LD_INT 14
1456: DOUBLE
1457: EQUAL
1458: IFTRUE 1462
1460: GO 1473
1462: POP
// point := 20 ; class_apeman :
1463: LD_ADDR_VAR 0 4
1467: PUSH
1468: LD_INT 20
1470: ST_TO_ADDR
1471: GO 1531
1473: LD_INT 12
1475: DOUBLE
1476: EQUAL
1477: IFTRUE 1481
1479: GO 1492
1481: POP
// point := 30 ; class_apeman_soldier :
1482: LD_ADDR_VAR 0 4
1486: PUSH
1487: LD_INT 30
1489: ST_TO_ADDR
1490: GO 1531
1492: LD_INT 15
1494: DOUBLE
1495: EQUAL
1496: IFTRUE 1500
1498: GO 1511
1500: POP
// point := 50 ; class_frog :
1501: LD_ADDR_VAR 0 4
1505: PUSH
1506: LD_INT 50
1508: ST_TO_ADDR
1509: GO 1531
1511: LD_INT 19
1513: DOUBLE
1514: EQUAL
1515: IFTRUE 1519
1517: GO 1530
1519: POP
// point := 10 ; end ;
1520: LD_ADDR_VAR 0 4
1524: PUSH
1525: LD_INT 10
1527: ST_TO_ADDR
1528: GO 1531
1530: POP
// if point then
1531: LD_VAR 0 4
1535: IFFALSE 1574
// points := Replace ( points , killer_side , points [ killer_side ] + point ) ;
1537: LD_ADDR_EXP 6
1541: PUSH
1542: LD_EXP 6
1546: PPUSH
1547: LD_VAR 0 2
1551: PPUSH
1552: LD_EXP 6
1556: PUSH
1557: LD_VAR 0 2
1561: ARRAY
1562: PUSH
1563: LD_VAR 0 4
1567: PLUS
1568: PPUSH
1569: CALL_OW 1
1573: ST_TO_ADDR
// end ;
1574: PPOPN 4
1576: END
// every 0 0$20 trigger FilterAllUnits ( [ f_side , 0 ] ) < 10 do
1577: LD_INT 22
1579: PUSH
1580: LD_INT 0
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PPUSH
1587: CALL_OW 69
1591: PUSH
1592: LD_INT 10
1594: LESS
1595: IFFALSE 1697
1597: GO 1599
1599: DISABLE
// begin enable ;
1600: ENABLE
// PrepareNature ( nat_area , wat_area , [ rand ( 0 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) , rand ( 2 , 4 ) , rand ( 2 , 4 ) , rand ( 0 , 2 ) , rand ( 0 , 4 ) ] ) ;
1601: LD_INT 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: LD_INT 0
1609: PPUSH
1610: LD_INT 4
1612: PPUSH
1613: CALL_OW 12
1617: PUSH
1618: LD_INT 0
1620: PPUSH
1621: LD_INT 2
1623: PPUSH
1624: CALL_OW 12
1628: PUSH
1629: LD_INT 0
1631: PPUSH
1632: LD_INT 4
1634: PPUSH
1635: CALL_OW 12
1639: PUSH
1640: LD_INT 2
1642: PPUSH
1643: LD_INT 4
1645: PPUSH
1646: CALL_OW 12
1650: PUSH
1651: LD_INT 2
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: CALL_OW 12
1661: PUSH
1662: LD_INT 0
1664: PPUSH
1665: LD_INT 2
1667: PPUSH
1668: CALL_OW 12
1672: PUSH
1673: LD_INT 0
1675: PPUSH
1676: LD_INT 4
1678: PPUSH
1679: CALL_OW 12
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: PPUSH
1693: CALL 395 0 3
// end ;
1697: END
// every 0 0$1 do var i ;
1698: GO 1700
1700: DISABLE
1701: LD_INT 0
1703: PPUSH
// begin enable ;
1704: ENABLE
// display_strings := [ ] ;
1705: LD_ADDR_OWVAR 47
1709: PUSH
1710: EMPTY
1711: ST_TO_ADDR
// for i := 1 to huntersAmount do
1712: LD_ADDR_VAR 0 1
1716: PUSH
1717: DOUBLE
1718: LD_INT 1
1720: DEC
1721: ST_TO_ADDR
1722: LD_EXP 3
1726: PUSH
1727: FOR_TO
1728: IFFALSE 1855
// begin display_strings := display_strings ^ [ #player & i , i , points [ i ] ] ;
1730: LD_ADDR_OWVAR 47
1734: PUSH
1735: LD_OWVAR 47
1739: PUSH
1740: LD_STRING #player
1742: PUSH
1743: LD_VAR 0 1
1747: STR
1748: PUSH
1749: LD_VAR 0 1
1753: PUSH
1754: LD_EXP 6
1758: PUSH
1759: LD_VAR 0 1
1763: ARRAY
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: ADD
1770: ST_TO_ADDR
// if points [ i ] >= [ 750 , 1250 , 2000 ] [ Difficulty ] then
1771: LD_EXP 6
1775: PUSH
1776: LD_VAR 0 1
1780: ARRAY
1781: PUSH
1782: LD_INT 750
1784: PUSH
1785: LD_INT 1250
1787: PUSH
1788: LD_INT 2000
1790: PUSH
1791: EMPTY
1792: LIST
1793: LIST
1794: LIST
1795: PUSH
1796: LD_OWVAR 67
1800: ARRAY
1801: GREATEREQUAL
1802: IFFALSE 1853
// begin if i = 1 then
1804: LD_VAR 0 1
1808: PUSH
1809: LD_INT 1
1811: EQUAL
1812: IFFALSE 1846
// begin DialogueOn ;
1814: CALL_OW 6
// display_strings := [ #hunting-win ] ;
1818: LD_ADDR_OWVAR 47
1822: PUSH
1823: LD_STRING #hunting-win
1825: PUSH
1826: EMPTY
1827: LIST
1828: ST_TO_ADDR
// dwait ( 0 0$5 ) ;
1829: LD_INT 175
1831: PPUSH
1832: CALL_OW 68
// YouWin ;
1836: CALL_OW 103
// DialogueOff ;
1840: CALL_OW 7
// end else
1844: GO 1853
// YouLost ( hunt3 ) ;
1846: LD_STRING hunt3
1848: PPUSH
1849: CALL_OW 104
// end ; end ;
1853: GO 1727
1855: POP
1856: POP
// end ; end_of_file end_of_file
1857: PPOPN 1
1859: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
1860: GO 1862
1862: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
1863: LD_STRING initStreamRollete();
1865: PPUSH
1866: CALL_OW 559
// InitStreamMode ;
1870: CALL 1879 0 0
// DefineStreamItems ( ) ;
1874: CALL 2319 0 0
// end ;
1878: END
// function InitStreamMode ; begin
1879: LD_INT 0
1881: PPUSH
// streamModeActive := false ;
1882: LD_ADDR_EXP 8
1886: PUSH
1887: LD_INT 0
1889: ST_TO_ADDR
// normalCounter := 36 ;
1890: LD_ADDR_EXP 9
1894: PUSH
1895: LD_INT 36
1897: ST_TO_ADDR
// hardcoreCounter := 16 ;
1898: LD_ADDR_EXP 10
1902: PUSH
1903: LD_INT 16
1905: ST_TO_ADDR
// sRocket := false ;
1906: LD_ADDR_EXP 13
1910: PUSH
1911: LD_INT 0
1913: ST_TO_ADDR
// sSpeed := false ;
1914: LD_ADDR_EXP 12
1918: PUSH
1919: LD_INT 0
1921: ST_TO_ADDR
// sEngine := false ;
1922: LD_ADDR_EXP 14
1926: PUSH
1927: LD_INT 0
1929: ST_TO_ADDR
// sSpec := false ;
1930: LD_ADDR_EXP 11
1934: PUSH
1935: LD_INT 0
1937: ST_TO_ADDR
// sLevel := false ;
1938: LD_ADDR_EXP 15
1942: PUSH
1943: LD_INT 0
1945: ST_TO_ADDR
// sArmoury := false ;
1946: LD_ADDR_EXP 16
1950: PUSH
1951: LD_INT 0
1953: ST_TO_ADDR
// sRadar := false ;
1954: LD_ADDR_EXP 17
1958: PUSH
1959: LD_INT 0
1961: ST_TO_ADDR
// sBunker := false ;
1962: LD_ADDR_EXP 18
1966: PUSH
1967: LD_INT 0
1969: ST_TO_ADDR
// sHack := false ;
1970: LD_ADDR_EXP 19
1974: PUSH
1975: LD_INT 0
1977: ST_TO_ADDR
// sFire := false ;
1978: LD_ADDR_EXP 20
1982: PUSH
1983: LD_INT 0
1985: ST_TO_ADDR
// sRefresh := false ;
1986: LD_ADDR_EXP 21
1990: PUSH
1991: LD_INT 0
1993: ST_TO_ADDR
// sExp := false ;
1994: LD_ADDR_EXP 22
1998: PUSH
1999: LD_INT 0
2001: ST_TO_ADDR
// sDepot := false ;
2002: LD_ADDR_EXP 23
2006: PUSH
2007: LD_INT 0
2009: ST_TO_ADDR
// sFlag := false ;
2010: LD_ADDR_EXP 24
2014: PUSH
2015: LD_INT 0
2017: ST_TO_ADDR
// sKamikadze := false ;
2018: LD_ADDR_EXP 32
2022: PUSH
2023: LD_INT 0
2025: ST_TO_ADDR
// sTroll := false ;
2026: LD_ADDR_EXP 33
2030: PUSH
2031: LD_INT 0
2033: ST_TO_ADDR
// sSlow := false ;
2034: LD_ADDR_EXP 34
2038: PUSH
2039: LD_INT 0
2041: ST_TO_ADDR
// sLack := false ;
2042: LD_ADDR_EXP 35
2046: PUSH
2047: LD_INT 0
2049: ST_TO_ADDR
// sTank := false ;
2050: LD_ADDR_EXP 37
2054: PUSH
2055: LD_INT 0
2057: ST_TO_ADDR
// sRemote := false ;
2058: LD_ADDR_EXP 38
2062: PUSH
2063: LD_INT 0
2065: ST_TO_ADDR
// sPowell := false ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_INT 0
2073: ST_TO_ADDR
// sTeleport := false ;
2074: LD_ADDR_EXP 42
2078: PUSH
2079: LD_INT 0
2081: ST_TO_ADDR
// sOilTower := false ;
2082: LD_ADDR_EXP 44
2086: PUSH
2087: LD_INT 0
2089: ST_TO_ADDR
// sShovel := false ;
2090: LD_ADDR_EXP 45
2094: PUSH
2095: LD_INT 0
2097: ST_TO_ADDR
// sSheik := false ;
2098: LD_ADDR_EXP 46
2102: PUSH
2103: LD_INT 0
2105: ST_TO_ADDR
// sEarthquake := false ;
2106: LD_ADDR_EXP 48
2110: PUSH
2111: LD_INT 0
2113: ST_TO_ADDR
// sAI := false ;
2114: LD_ADDR_EXP 49
2118: PUSH
2119: LD_INT 0
2121: ST_TO_ADDR
// sCargo := false ;
2122: LD_ADDR_EXP 52
2126: PUSH
2127: LD_INT 0
2129: ST_TO_ADDR
// sDLaser := false ;
2130: LD_ADDR_EXP 53
2134: PUSH
2135: LD_INT 0
2137: ST_TO_ADDR
// sExchange := false ;
2138: LD_ADDR_EXP 54
2142: PUSH
2143: LD_INT 0
2145: ST_TO_ADDR
// sFac := false ;
2146: LD_ADDR_EXP 55
2150: PUSH
2151: LD_INT 0
2153: ST_TO_ADDR
// sPower := false ;
2154: LD_ADDR_EXP 56
2158: PUSH
2159: LD_INT 0
2161: ST_TO_ADDR
// sRandom := false ;
2162: LD_ADDR_EXP 57
2166: PUSH
2167: LD_INT 0
2169: ST_TO_ADDR
// sShield := false ;
2170: LD_ADDR_EXP 58
2174: PUSH
2175: LD_INT 0
2177: ST_TO_ADDR
// sTime := false ;
2178: LD_ADDR_EXP 59
2182: PUSH
2183: LD_INT 0
2185: ST_TO_ADDR
// sTools := false ;
2186: LD_ADDR_EXP 60
2190: PUSH
2191: LD_INT 0
2193: ST_TO_ADDR
// sSold := false ;
2194: LD_ADDR_EXP 25
2198: PUSH
2199: LD_INT 0
2201: ST_TO_ADDR
// sDiff := false ;
2202: LD_ADDR_EXP 26
2206: PUSH
2207: LD_INT 0
2209: ST_TO_ADDR
// sFog := false ;
2210: LD_ADDR_EXP 29
2214: PUSH
2215: LD_INT 0
2217: ST_TO_ADDR
// sReset := false ;
2218: LD_ADDR_EXP 30
2222: PUSH
2223: LD_INT 0
2225: ST_TO_ADDR
// sSun := false ;
2226: LD_ADDR_EXP 31
2230: PUSH
2231: LD_INT 0
2233: ST_TO_ADDR
// sTiger := false ;
2234: LD_ADDR_EXP 27
2238: PUSH
2239: LD_INT 0
2241: ST_TO_ADDR
// sBomb := false ;
2242: LD_ADDR_EXP 28
2246: PUSH
2247: LD_INT 0
2249: ST_TO_ADDR
// sWound := false ;
2250: LD_ADDR_EXP 36
2254: PUSH
2255: LD_INT 0
2257: ST_TO_ADDR
// sBetray := false ;
2258: LD_ADDR_EXP 40
2262: PUSH
2263: LD_INT 0
2265: ST_TO_ADDR
// sContamin := false ;
2266: LD_ADDR_EXP 41
2270: PUSH
2271: LD_INT 0
2273: ST_TO_ADDR
// sOil := false ;
2274: LD_ADDR_EXP 43
2278: PUSH
2279: LD_INT 0
2281: ST_TO_ADDR
// sStu := false ;
2282: LD_ADDR_EXP 47
2286: PUSH
2287: LD_INT 0
2289: ST_TO_ADDR
// sBazooka := false ;
2290: LD_ADDR_EXP 50
2294: PUSH
2295: LD_INT 0
2297: ST_TO_ADDR
// sMortar := false ;
2298: LD_ADDR_EXP 51
2302: PUSH
2303: LD_INT 0
2305: ST_TO_ADDR
// sRanger := false ;
2306: LD_ADDR_EXP 61
2310: PUSH
2311: LD_INT 0
2313: ST_TO_ADDR
// end ;
2314: LD_VAR 0 1
2318: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
2325: PPUSH
// result := [ ] ;
2326: LD_ADDR_VAR 0 1
2330: PUSH
2331: EMPTY
2332: ST_TO_ADDR
// if campaign_id = 1 then
2333: LD_OWVAR 69
2337: PUSH
2338: LD_INT 1
2340: EQUAL
2341: IFFALSE 5279
// begin case mission_number of 1 :
2343: LD_OWVAR 70
2347: PUSH
2348: LD_INT 1
2350: DOUBLE
2351: EQUAL
2352: IFTRUE 2356
2354: GO 2420
2356: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
2357: LD_ADDR_VAR 0 1
2361: PUSH
2362: LD_INT 2
2364: PUSH
2365: LD_INT 4
2367: PUSH
2368: LD_INT 11
2370: PUSH
2371: LD_INT 12
2373: PUSH
2374: LD_INT 15
2376: PUSH
2377: LD_INT 16
2379: PUSH
2380: LD_INT 22
2382: PUSH
2383: LD_INT 23
2385: PUSH
2386: LD_INT 26
2388: PUSH
2389: EMPTY
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 101
2402: PUSH
2403: LD_INT 102
2405: PUSH
2406: LD_INT 106
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: LIST
2413: PUSH
2414: EMPTY
2415: LIST
2416: LIST
2417: ST_TO_ADDR
2418: GO 5277
2420: LD_INT 2
2422: DOUBLE
2423: EQUAL
2424: IFTRUE 2428
2426: GO 2500
2428: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
2429: LD_ADDR_VAR 0 1
2433: PUSH
2434: LD_INT 2
2436: PUSH
2437: LD_INT 4
2439: PUSH
2440: LD_INT 11
2442: PUSH
2443: LD_INT 12
2445: PUSH
2446: LD_INT 15
2448: PUSH
2449: LD_INT 16
2451: PUSH
2452: LD_INT 22
2454: PUSH
2455: LD_INT 23
2457: PUSH
2458: LD_INT 26
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: LIST
2471: PUSH
2472: LD_INT 101
2474: PUSH
2475: LD_INT 102
2477: PUSH
2478: LD_INT 105
2480: PUSH
2481: LD_INT 106
2483: PUSH
2484: LD_INT 108
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: LIST
2491: LIST
2492: LIST
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: ST_TO_ADDR
2498: GO 5277
2500: LD_INT 3
2502: DOUBLE
2503: EQUAL
2504: IFTRUE 2508
2506: GO 2584
2508: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
2509: LD_ADDR_VAR 0 1
2513: PUSH
2514: LD_INT 2
2516: PUSH
2517: LD_INT 4
2519: PUSH
2520: LD_INT 5
2522: PUSH
2523: LD_INT 11
2525: PUSH
2526: LD_INT 12
2528: PUSH
2529: LD_INT 15
2531: PUSH
2532: LD_INT 16
2534: PUSH
2535: LD_INT 22
2537: PUSH
2538: LD_INT 26
2540: PUSH
2541: LD_INT 36
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: LIST
2555: PUSH
2556: LD_INT 101
2558: PUSH
2559: LD_INT 102
2561: PUSH
2562: LD_INT 105
2564: PUSH
2565: LD_INT 106
2567: PUSH
2568: LD_INT 108
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: LIST
2576: LIST
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: ST_TO_ADDR
2582: GO 5277
2584: LD_INT 4
2586: DOUBLE
2587: EQUAL
2588: IFTRUE 2592
2590: GO 2676
2592: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
2593: LD_ADDR_VAR 0 1
2597: PUSH
2598: LD_INT 2
2600: PUSH
2601: LD_INT 4
2603: PUSH
2604: LD_INT 5
2606: PUSH
2607: LD_INT 8
2609: PUSH
2610: LD_INT 11
2612: PUSH
2613: LD_INT 12
2615: PUSH
2616: LD_INT 15
2618: PUSH
2619: LD_INT 16
2621: PUSH
2622: LD_INT 22
2624: PUSH
2625: LD_INT 23
2627: PUSH
2628: LD_INT 26
2630: PUSH
2631: LD_INT 36
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 101
2650: PUSH
2651: LD_INT 102
2653: PUSH
2654: LD_INT 105
2656: PUSH
2657: LD_INT 106
2659: PUSH
2660: LD_INT 108
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: ST_TO_ADDR
2674: GO 5277
2676: LD_INT 5
2678: DOUBLE
2679: EQUAL
2680: IFTRUE 2684
2682: GO 2784
2684: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
2685: LD_ADDR_VAR 0 1
2689: PUSH
2690: LD_INT 2
2692: PUSH
2693: LD_INT 4
2695: PUSH
2696: LD_INT 5
2698: PUSH
2699: LD_INT 6
2701: PUSH
2702: LD_INT 8
2704: PUSH
2705: LD_INT 11
2707: PUSH
2708: LD_INT 12
2710: PUSH
2711: LD_INT 15
2713: PUSH
2714: LD_INT 16
2716: PUSH
2717: LD_INT 22
2719: PUSH
2720: LD_INT 23
2722: PUSH
2723: LD_INT 25
2725: PUSH
2726: LD_INT 26
2728: PUSH
2729: LD_INT 36
2731: PUSH
2732: EMPTY
2733: LIST
2734: LIST
2735: LIST
2736: LIST
2737: LIST
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: PUSH
2748: LD_INT 101
2750: PUSH
2751: LD_INT 102
2753: PUSH
2754: LD_INT 105
2756: PUSH
2757: LD_INT 106
2759: PUSH
2760: LD_INT 108
2762: PUSH
2763: LD_INT 109
2765: PUSH
2766: LD_INT 112
2768: PUSH
2769: EMPTY
2770: LIST
2771: LIST
2772: LIST
2773: LIST
2774: LIST
2775: LIST
2776: LIST
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: ST_TO_ADDR
2782: GO 5277
2784: LD_INT 6
2786: DOUBLE
2787: EQUAL
2788: IFTRUE 2792
2790: GO 2912
2792: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
2793: LD_ADDR_VAR 0 1
2797: PUSH
2798: LD_INT 2
2800: PUSH
2801: LD_INT 4
2803: PUSH
2804: LD_INT 5
2806: PUSH
2807: LD_INT 6
2809: PUSH
2810: LD_INT 8
2812: PUSH
2813: LD_INT 11
2815: PUSH
2816: LD_INT 12
2818: PUSH
2819: LD_INT 15
2821: PUSH
2822: LD_INT 16
2824: PUSH
2825: LD_INT 20
2827: PUSH
2828: LD_INT 21
2830: PUSH
2831: LD_INT 22
2833: PUSH
2834: LD_INT 23
2836: PUSH
2837: LD_INT 25
2839: PUSH
2840: LD_INT 26
2842: PUSH
2843: LD_INT 30
2845: PUSH
2846: LD_INT 31
2848: PUSH
2849: LD_INT 32
2851: PUSH
2852: LD_INT 36
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: PUSH
2876: LD_INT 101
2878: PUSH
2879: LD_INT 102
2881: PUSH
2882: LD_INT 105
2884: PUSH
2885: LD_INT 106
2887: PUSH
2888: LD_INT 108
2890: PUSH
2891: LD_INT 109
2893: PUSH
2894: LD_INT 112
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: LIST
2901: LIST
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: EMPTY
2907: LIST
2908: LIST
2909: ST_TO_ADDR
2910: GO 5277
2912: LD_INT 7
2914: DOUBLE
2915: EQUAL
2916: IFTRUE 2920
2918: GO 3020
2920: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
2921: LD_ADDR_VAR 0 1
2925: PUSH
2926: LD_INT 2
2928: PUSH
2929: LD_INT 4
2931: PUSH
2932: LD_INT 5
2934: PUSH
2935: LD_INT 7
2937: PUSH
2938: LD_INT 11
2940: PUSH
2941: LD_INT 12
2943: PUSH
2944: LD_INT 15
2946: PUSH
2947: LD_INT 16
2949: PUSH
2950: LD_INT 20
2952: PUSH
2953: LD_INT 21
2955: PUSH
2956: LD_INT 22
2958: PUSH
2959: LD_INT 23
2961: PUSH
2962: LD_INT 25
2964: PUSH
2965: LD_INT 26
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: LIST
2973: LIST
2974: LIST
2975: LIST
2976: LIST
2977: LIST
2978: LIST
2979: LIST
2980: LIST
2981: LIST
2982: LIST
2983: PUSH
2984: LD_INT 101
2986: PUSH
2987: LD_INT 102
2989: PUSH
2990: LD_INT 103
2992: PUSH
2993: LD_INT 105
2995: PUSH
2996: LD_INT 106
2998: PUSH
2999: LD_INT 108
3001: PUSH
3002: LD_INT 112
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: LIST
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: ST_TO_ADDR
3018: GO 5277
3020: LD_INT 8
3022: DOUBLE
3023: EQUAL
3024: IFTRUE 3028
3026: GO 3156
3028: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
3029: LD_ADDR_VAR 0 1
3033: PUSH
3034: LD_INT 2
3036: PUSH
3037: LD_INT 4
3039: PUSH
3040: LD_INT 5
3042: PUSH
3043: LD_INT 6
3045: PUSH
3046: LD_INT 7
3048: PUSH
3049: LD_INT 8
3051: PUSH
3052: LD_INT 11
3054: PUSH
3055: LD_INT 12
3057: PUSH
3058: LD_INT 15
3060: PUSH
3061: LD_INT 16
3063: PUSH
3064: LD_INT 20
3066: PUSH
3067: LD_INT 21
3069: PUSH
3070: LD_INT 22
3072: PUSH
3073: LD_INT 23
3075: PUSH
3076: LD_INT 25
3078: PUSH
3079: LD_INT 26
3081: PUSH
3082: LD_INT 30
3084: PUSH
3085: LD_INT 31
3087: PUSH
3088: LD_INT 32
3090: PUSH
3091: LD_INT 36
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: LIST
3102: LIST
3103: LIST
3104: LIST
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: LIST
3113: LIST
3114: LIST
3115: PUSH
3116: LD_INT 101
3118: PUSH
3119: LD_INT 102
3121: PUSH
3122: LD_INT 103
3124: PUSH
3125: LD_INT 105
3127: PUSH
3128: LD_INT 106
3130: PUSH
3131: LD_INT 108
3133: PUSH
3134: LD_INT 109
3136: PUSH
3137: LD_INT 112
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: ST_TO_ADDR
3154: GO 5277
3156: LD_INT 9
3158: DOUBLE
3159: EQUAL
3160: IFTRUE 3164
3162: GO 3300
3164: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
3165: LD_ADDR_VAR 0 1
3169: PUSH
3170: LD_INT 2
3172: PUSH
3173: LD_INT 4
3175: PUSH
3176: LD_INT 5
3178: PUSH
3179: LD_INT 6
3181: PUSH
3182: LD_INT 7
3184: PUSH
3185: LD_INT 8
3187: PUSH
3188: LD_INT 11
3190: PUSH
3191: LD_INT 12
3193: PUSH
3194: LD_INT 15
3196: PUSH
3197: LD_INT 16
3199: PUSH
3200: LD_INT 20
3202: PUSH
3203: LD_INT 21
3205: PUSH
3206: LD_INT 22
3208: PUSH
3209: LD_INT 23
3211: PUSH
3212: LD_INT 25
3214: PUSH
3215: LD_INT 26
3217: PUSH
3218: LD_INT 28
3220: PUSH
3221: LD_INT 30
3223: PUSH
3224: LD_INT 31
3226: PUSH
3227: LD_INT 32
3229: PUSH
3230: LD_INT 36
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 101
3258: PUSH
3259: LD_INT 102
3261: PUSH
3262: LD_INT 103
3264: PUSH
3265: LD_INT 105
3267: PUSH
3268: LD_INT 106
3270: PUSH
3271: LD_INT 108
3273: PUSH
3274: LD_INT 109
3276: PUSH
3277: LD_INT 112
3279: PUSH
3280: LD_INT 114
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: ST_TO_ADDR
3298: GO 5277
3300: LD_INT 10
3302: DOUBLE
3303: EQUAL
3304: IFTRUE 3308
3306: GO 3492
3308: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
3309: LD_ADDR_VAR 0 1
3313: PUSH
3314: LD_INT 2
3316: PUSH
3317: LD_INT 4
3319: PUSH
3320: LD_INT 5
3322: PUSH
3323: LD_INT 6
3325: PUSH
3326: LD_INT 7
3328: PUSH
3329: LD_INT 8
3331: PUSH
3332: LD_INT 9
3334: PUSH
3335: LD_INT 10
3337: PUSH
3338: LD_INT 11
3340: PUSH
3341: LD_INT 12
3343: PUSH
3344: LD_INT 13
3346: PUSH
3347: LD_INT 14
3349: PUSH
3350: LD_INT 15
3352: PUSH
3353: LD_INT 16
3355: PUSH
3356: LD_INT 17
3358: PUSH
3359: LD_INT 18
3361: PUSH
3362: LD_INT 19
3364: PUSH
3365: LD_INT 20
3367: PUSH
3368: LD_INT 21
3370: PUSH
3371: LD_INT 22
3373: PUSH
3374: LD_INT 23
3376: PUSH
3377: LD_INT 24
3379: PUSH
3380: LD_INT 25
3382: PUSH
3383: LD_INT 26
3385: PUSH
3386: LD_INT 28
3388: PUSH
3389: LD_INT 30
3391: PUSH
3392: LD_INT 31
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 36
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: LIST
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 101
3434: PUSH
3435: LD_INT 102
3437: PUSH
3438: LD_INT 103
3440: PUSH
3441: LD_INT 104
3443: PUSH
3444: LD_INT 105
3446: PUSH
3447: LD_INT 106
3449: PUSH
3450: LD_INT 107
3452: PUSH
3453: LD_INT 108
3455: PUSH
3456: LD_INT 109
3458: PUSH
3459: LD_INT 110
3461: PUSH
3462: LD_INT 111
3464: PUSH
3465: LD_INT 112
3467: PUSH
3468: LD_INT 114
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: LIST
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: ST_TO_ADDR
3490: GO 5277
3492: LD_INT 11
3494: DOUBLE
3495: EQUAL
3496: IFTRUE 3500
3498: GO 3692
3500: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
3501: LD_ADDR_VAR 0 1
3505: PUSH
3506: LD_INT 2
3508: PUSH
3509: LD_INT 3
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: LD_INT 5
3517: PUSH
3518: LD_INT 6
3520: PUSH
3521: LD_INT 7
3523: PUSH
3524: LD_INT 8
3526: PUSH
3527: LD_INT 9
3529: PUSH
3530: LD_INT 10
3532: PUSH
3533: LD_INT 11
3535: PUSH
3536: LD_INT 12
3538: PUSH
3539: LD_INT 13
3541: PUSH
3542: LD_INT 14
3544: PUSH
3545: LD_INT 15
3547: PUSH
3548: LD_INT 16
3550: PUSH
3551: LD_INT 17
3553: PUSH
3554: LD_INT 18
3556: PUSH
3557: LD_INT 19
3559: PUSH
3560: LD_INT 20
3562: PUSH
3563: LD_INT 21
3565: PUSH
3566: LD_INT 22
3568: PUSH
3569: LD_INT 23
3571: PUSH
3572: LD_INT 24
3574: PUSH
3575: LD_INT 25
3577: PUSH
3578: LD_INT 26
3580: PUSH
3581: LD_INT 28
3583: PUSH
3584: LD_INT 30
3586: PUSH
3587: LD_INT 31
3589: PUSH
3590: LD_INT 32
3592: PUSH
3593: LD_INT 34
3595: PUSH
3596: LD_INT 36
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: LIST
3623: LIST
3624: LIST
3625: LIST
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PUSH
3632: LD_INT 101
3634: PUSH
3635: LD_INT 102
3637: PUSH
3638: LD_INT 103
3640: PUSH
3641: LD_INT 104
3643: PUSH
3644: LD_INT 105
3646: PUSH
3647: LD_INT 106
3649: PUSH
3650: LD_INT 107
3652: PUSH
3653: LD_INT 108
3655: PUSH
3656: LD_INT 109
3658: PUSH
3659: LD_INT 110
3661: PUSH
3662: LD_INT 111
3664: PUSH
3665: LD_INT 112
3667: PUSH
3668: LD_INT 114
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: LIST
3675: LIST
3676: LIST
3677: LIST
3678: LIST
3679: LIST
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PUSH
3686: EMPTY
3687: LIST
3688: LIST
3689: ST_TO_ADDR
3690: GO 5277
3692: LD_INT 12
3694: DOUBLE
3695: EQUAL
3696: IFTRUE 3700
3698: GO 3908
3700: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
3701: LD_ADDR_VAR 0 1
3705: PUSH
3706: LD_INT 1
3708: PUSH
3709: LD_INT 2
3711: PUSH
3712: LD_INT 3
3714: PUSH
3715: LD_INT 4
3717: PUSH
3718: LD_INT 5
3720: PUSH
3721: LD_INT 6
3723: PUSH
3724: LD_INT 7
3726: PUSH
3727: LD_INT 8
3729: PUSH
3730: LD_INT 9
3732: PUSH
3733: LD_INT 10
3735: PUSH
3736: LD_INT 11
3738: PUSH
3739: LD_INT 12
3741: PUSH
3742: LD_INT 13
3744: PUSH
3745: LD_INT 14
3747: PUSH
3748: LD_INT 15
3750: PUSH
3751: LD_INT 16
3753: PUSH
3754: LD_INT 17
3756: PUSH
3757: LD_INT 18
3759: PUSH
3760: LD_INT 19
3762: PUSH
3763: LD_INT 20
3765: PUSH
3766: LD_INT 21
3768: PUSH
3769: LD_INT 22
3771: PUSH
3772: LD_INT 23
3774: PUSH
3775: LD_INT 24
3777: PUSH
3778: LD_INT 25
3780: PUSH
3781: LD_INT 26
3783: PUSH
3784: LD_INT 27
3786: PUSH
3787: LD_INT 28
3789: PUSH
3790: LD_INT 30
3792: PUSH
3793: LD_INT 31
3795: PUSH
3796: LD_INT 32
3798: PUSH
3799: LD_INT 33
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 36
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: LIST
3835: LIST
3836: LIST
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: PUSH
3844: LD_INT 101
3846: PUSH
3847: LD_INT 102
3849: PUSH
3850: LD_INT 103
3852: PUSH
3853: LD_INT 104
3855: PUSH
3856: LD_INT 105
3858: PUSH
3859: LD_INT 106
3861: PUSH
3862: LD_INT 107
3864: PUSH
3865: LD_INT 108
3867: PUSH
3868: LD_INT 109
3870: PUSH
3871: LD_INT 110
3873: PUSH
3874: LD_INT 111
3876: PUSH
3877: LD_INT 112
3879: PUSH
3880: LD_INT 113
3882: PUSH
3883: LD_INT 114
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: LIST
3890: LIST
3891: LIST
3892: LIST
3893: LIST
3894: LIST
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: PUSH
3902: EMPTY
3903: LIST
3904: LIST
3905: ST_TO_ADDR
3906: GO 5277
3908: LD_INT 13
3910: DOUBLE
3911: EQUAL
3912: IFTRUE 3916
3914: GO 4112
3916: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
3917: LD_ADDR_VAR 0 1
3921: PUSH
3922: LD_INT 1
3924: PUSH
3925: LD_INT 2
3927: PUSH
3928: LD_INT 3
3930: PUSH
3931: LD_INT 4
3933: PUSH
3934: LD_INT 5
3936: PUSH
3937: LD_INT 8
3939: PUSH
3940: LD_INT 9
3942: PUSH
3943: LD_INT 10
3945: PUSH
3946: LD_INT 11
3948: PUSH
3949: LD_INT 12
3951: PUSH
3952: LD_INT 14
3954: PUSH
3955: LD_INT 15
3957: PUSH
3958: LD_INT 16
3960: PUSH
3961: LD_INT 17
3963: PUSH
3964: LD_INT 18
3966: PUSH
3967: LD_INT 19
3969: PUSH
3970: LD_INT 20
3972: PUSH
3973: LD_INT 21
3975: PUSH
3976: LD_INT 22
3978: PUSH
3979: LD_INT 23
3981: PUSH
3982: LD_INT 24
3984: PUSH
3985: LD_INT 25
3987: PUSH
3988: LD_INT 26
3990: PUSH
3991: LD_INT 27
3993: PUSH
3994: LD_INT 28
3996: PUSH
3997: LD_INT 30
3999: PUSH
4000: LD_INT 31
4002: PUSH
4003: LD_INT 32
4005: PUSH
4006: LD_INT 33
4008: PUSH
4009: LD_INT 34
4011: PUSH
4012: LD_INT 36
4014: PUSH
4015: EMPTY
4016: LIST
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: LIST
4039: LIST
4040: LIST
4041: LIST
4042: LIST
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: PUSH
4048: LD_INT 101
4050: PUSH
4051: LD_INT 102
4053: PUSH
4054: LD_INT 103
4056: PUSH
4057: LD_INT 104
4059: PUSH
4060: LD_INT 105
4062: PUSH
4063: LD_INT 106
4065: PUSH
4066: LD_INT 107
4068: PUSH
4069: LD_INT 108
4071: PUSH
4072: LD_INT 109
4074: PUSH
4075: LD_INT 110
4077: PUSH
4078: LD_INT 111
4080: PUSH
4081: LD_INT 112
4083: PUSH
4084: LD_INT 113
4086: PUSH
4087: LD_INT 114
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: ST_TO_ADDR
4110: GO 5277
4112: LD_INT 14
4114: DOUBLE
4115: EQUAL
4116: IFTRUE 4120
4118: GO 4332
4120: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
4121: LD_ADDR_VAR 0 1
4125: PUSH
4126: LD_INT 1
4128: PUSH
4129: LD_INT 2
4131: PUSH
4132: LD_INT 3
4134: PUSH
4135: LD_INT 4
4137: PUSH
4138: LD_INT 5
4140: PUSH
4141: LD_INT 6
4143: PUSH
4144: LD_INT 7
4146: PUSH
4147: LD_INT 8
4149: PUSH
4150: LD_INT 9
4152: PUSH
4153: LD_INT 10
4155: PUSH
4156: LD_INT 11
4158: PUSH
4159: LD_INT 12
4161: PUSH
4162: LD_INT 13
4164: PUSH
4165: LD_INT 14
4167: PUSH
4168: LD_INT 15
4170: PUSH
4171: LD_INT 16
4173: PUSH
4174: LD_INT 17
4176: PUSH
4177: LD_INT 18
4179: PUSH
4180: LD_INT 19
4182: PUSH
4183: LD_INT 20
4185: PUSH
4186: LD_INT 21
4188: PUSH
4189: LD_INT 22
4191: PUSH
4192: LD_INT 23
4194: PUSH
4195: LD_INT 24
4197: PUSH
4198: LD_INT 25
4200: PUSH
4201: LD_INT 26
4203: PUSH
4204: LD_INT 27
4206: PUSH
4207: LD_INT 28
4209: PUSH
4210: LD_INT 29
4212: PUSH
4213: LD_INT 30
4215: PUSH
4216: LD_INT 31
4218: PUSH
4219: LD_INT 32
4221: PUSH
4222: LD_INT 33
4224: PUSH
4225: LD_INT 34
4227: PUSH
4228: LD_INT 36
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: LIST
4241: LIST
4242: LIST
4243: LIST
4244: LIST
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: LIST
4250: LIST
4251: LIST
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_INT 101
4270: PUSH
4271: LD_INT 102
4273: PUSH
4274: LD_INT 103
4276: PUSH
4277: LD_INT 104
4279: PUSH
4280: LD_INT 105
4282: PUSH
4283: LD_INT 106
4285: PUSH
4286: LD_INT 107
4288: PUSH
4289: LD_INT 108
4291: PUSH
4292: LD_INT 109
4294: PUSH
4295: LD_INT 110
4297: PUSH
4298: LD_INT 111
4300: PUSH
4301: LD_INT 112
4303: PUSH
4304: LD_INT 113
4306: PUSH
4307: LD_INT 114
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: LIST
4319: LIST
4320: LIST
4321: LIST
4322: LIST
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: ST_TO_ADDR
4330: GO 5277
4332: LD_INT 15
4334: DOUBLE
4335: EQUAL
4336: IFTRUE 4340
4338: GO 4552
4340: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
4341: LD_ADDR_VAR 0 1
4345: PUSH
4346: LD_INT 1
4348: PUSH
4349: LD_INT 2
4351: PUSH
4352: LD_INT 3
4354: PUSH
4355: LD_INT 4
4357: PUSH
4358: LD_INT 5
4360: PUSH
4361: LD_INT 6
4363: PUSH
4364: LD_INT 7
4366: PUSH
4367: LD_INT 8
4369: PUSH
4370: LD_INT 9
4372: PUSH
4373: LD_INT 10
4375: PUSH
4376: LD_INT 11
4378: PUSH
4379: LD_INT 12
4381: PUSH
4382: LD_INT 13
4384: PUSH
4385: LD_INT 14
4387: PUSH
4388: LD_INT 15
4390: PUSH
4391: LD_INT 16
4393: PUSH
4394: LD_INT 17
4396: PUSH
4397: LD_INT 18
4399: PUSH
4400: LD_INT 19
4402: PUSH
4403: LD_INT 20
4405: PUSH
4406: LD_INT 21
4408: PUSH
4409: LD_INT 22
4411: PUSH
4412: LD_INT 23
4414: PUSH
4415: LD_INT 24
4417: PUSH
4418: LD_INT 25
4420: PUSH
4421: LD_INT 26
4423: PUSH
4424: LD_INT 27
4426: PUSH
4427: LD_INT 28
4429: PUSH
4430: LD_INT 29
4432: PUSH
4433: LD_INT 30
4435: PUSH
4436: LD_INT 31
4438: PUSH
4439: LD_INT 32
4441: PUSH
4442: LD_INT 33
4444: PUSH
4445: LD_INT 34
4447: PUSH
4448: LD_INT 36
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 101
4490: PUSH
4491: LD_INT 102
4493: PUSH
4494: LD_INT 103
4496: PUSH
4497: LD_INT 104
4499: PUSH
4500: LD_INT 105
4502: PUSH
4503: LD_INT 106
4505: PUSH
4506: LD_INT 107
4508: PUSH
4509: LD_INT 108
4511: PUSH
4512: LD_INT 109
4514: PUSH
4515: LD_INT 110
4517: PUSH
4518: LD_INT 111
4520: PUSH
4521: LD_INT 112
4523: PUSH
4524: LD_INT 113
4526: PUSH
4527: LD_INT 114
4529: PUSH
4530: EMPTY
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: ST_TO_ADDR
4550: GO 5277
4552: LD_INT 16
4554: DOUBLE
4555: EQUAL
4556: IFTRUE 4560
4558: GO 4684
4560: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
4561: LD_ADDR_VAR 0 1
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: LD_INT 4
4571: PUSH
4572: LD_INT 5
4574: PUSH
4575: LD_INT 7
4577: PUSH
4578: LD_INT 11
4580: PUSH
4581: LD_INT 12
4583: PUSH
4584: LD_INT 15
4586: PUSH
4587: LD_INT 16
4589: PUSH
4590: LD_INT 20
4592: PUSH
4593: LD_INT 21
4595: PUSH
4596: LD_INT 22
4598: PUSH
4599: LD_INT 23
4601: PUSH
4602: LD_INT 25
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 30
4610: PUSH
4611: LD_INT 31
4613: PUSH
4614: LD_INT 32
4616: PUSH
4617: LD_INT 33
4619: PUSH
4620: LD_INT 34
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: LIST
4643: PUSH
4644: LD_INT 101
4646: PUSH
4647: LD_INT 102
4649: PUSH
4650: LD_INT 103
4652: PUSH
4653: LD_INT 106
4655: PUSH
4656: LD_INT 108
4658: PUSH
4659: LD_INT 112
4661: PUSH
4662: LD_INT 113
4664: PUSH
4665: LD_INT 114
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: LIST
4673: LIST
4674: LIST
4675: LIST
4676: LIST
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: ST_TO_ADDR
4682: GO 5277
4684: LD_INT 17
4686: DOUBLE
4687: EQUAL
4688: IFTRUE 4692
4690: GO 4904
4692: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
4693: LD_ADDR_VAR 0 1
4697: PUSH
4698: LD_INT 1
4700: PUSH
4701: LD_INT 2
4703: PUSH
4704: LD_INT 3
4706: PUSH
4707: LD_INT 4
4709: PUSH
4710: LD_INT 5
4712: PUSH
4713: LD_INT 6
4715: PUSH
4716: LD_INT 7
4718: PUSH
4719: LD_INT 8
4721: PUSH
4722: LD_INT 9
4724: PUSH
4725: LD_INT 10
4727: PUSH
4728: LD_INT 11
4730: PUSH
4731: LD_INT 12
4733: PUSH
4734: LD_INT 13
4736: PUSH
4737: LD_INT 14
4739: PUSH
4740: LD_INT 15
4742: PUSH
4743: LD_INT 16
4745: PUSH
4746: LD_INT 17
4748: PUSH
4749: LD_INT 18
4751: PUSH
4752: LD_INT 19
4754: PUSH
4755: LD_INT 20
4757: PUSH
4758: LD_INT 21
4760: PUSH
4761: LD_INT 22
4763: PUSH
4764: LD_INT 23
4766: PUSH
4767: LD_INT 24
4769: PUSH
4770: LD_INT 25
4772: PUSH
4773: LD_INT 26
4775: PUSH
4776: LD_INT 27
4778: PUSH
4779: LD_INT 28
4781: PUSH
4782: LD_INT 29
4784: PUSH
4785: LD_INT 30
4787: PUSH
4788: LD_INT 31
4790: PUSH
4791: LD_INT 32
4793: PUSH
4794: LD_INT 33
4796: PUSH
4797: LD_INT 34
4799: PUSH
4800: LD_INT 36
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: PUSH
4840: LD_INT 101
4842: PUSH
4843: LD_INT 102
4845: PUSH
4846: LD_INT 103
4848: PUSH
4849: LD_INT 104
4851: PUSH
4852: LD_INT 105
4854: PUSH
4855: LD_INT 106
4857: PUSH
4858: LD_INT 107
4860: PUSH
4861: LD_INT 108
4863: PUSH
4864: LD_INT 109
4866: PUSH
4867: LD_INT 110
4869: PUSH
4870: LD_INT 111
4872: PUSH
4873: LD_INT 112
4875: PUSH
4876: LD_INT 113
4878: PUSH
4879: LD_INT 114
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: ST_TO_ADDR
4902: GO 5277
4904: LD_INT 18
4906: DOUBLE
4907: EQUAL
4908: IFTRUE 4912
4910: GO 5048
4912: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
4913: LD_ADDR_VAR 0 1
4917: PUSH
4918: LD_INT 2
4920: PUSH
4921: LD_INT 4
4923: PUSH
4924: LD_INT 5
4926: PUSH
4927: LD_INT 7
4929: PUSH
4930: LD_INT 11
4932: PUSH
4933: LD_INT 12
4935: PUSH
4936: LD_INT 15
4938: PUSH
4939: LD_INT 16
4941: PUSH
4942: LD_INT 20
4944: PUSH
4945: LD_INT 21
4947: PUSH
4948: LD_INT 22
4950: PUSH
4951: LD_INT 23
4953: PUSH
4954: LD_INT 25
4956: PUSH
4957: LD_INT 26
4959: PUSH
4960: LD_INT 30
4962: PUSH
4963: LD_INT 31
4965: PUSH
4966: LD_INT 32
4968: PUSH
4969: LD_INT 33
4971: PUSH
4972: LD_INT 34
4974: PUSH
4975: LD_INT 35
4977: PUSH
4978: LD_INT 36
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 101
5006: PUSH
5007: LD_INT 102
5009: PUSH
5010: LD_INT 103
5012: PUSH
5013: LD_INT 106
5015: PUSH
5016: LD_INT 108
5018: PUSH
5019: LD_INT 112
5021: PUSH
5022: LD_INT 113
5024: PUSH
5025: LD_INT 114
5027: PUSH
5028: LD_INT 115
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: ST_TO_ADDR
5046: GO 5277
5048: LD_INT 19
5050: DOUBLE
5051: EQUAL
5052: IFTRUE 5056
5054: GO 5276
5056: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
5057: LD_ADDR_VAR 0 1
5061: PUSH
5062: LD_INT 1
5064: PUSH
5065: LD_INT 2
5067: PUSH
5068: LD_INT 3
5070: PUSH
5071: LD_INT 4
5073: PUSH
5074: LD_INT 5
5076: PUSH
5077: LD_INT 6
5079: PUSH
5080: LD_INT 7
5082: PUSH
5083: LD_INT 8
5085: PUSH
5086: LD_INT 9
5088: PUSH
5089: LD_INT 10
5091: PUSH
5092: LD_INT 11
5094: PUSH
5095: LD_INT 12
5097: PUSH
5098: LD_INT 13
5100: PUSH
5101: LD_INT 14
5103: PUSH
5104: LD_INT 15
5106: PUSH
5107: LD_INT 16
5109: PUSH
5110: LD_INT 17
5112: PUSH
5113: LD_INT 18
5115: PUSH
5116: LD_INT 19
5118: PUSH
5119: LD_INT 20
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 22
5127: PUSH
5128: LD_INT 23
5130: PUSH
5131: LD_INT 24
5133: PUSH
5134: LD_INT 25
5136: PUSH
5137: LD_INT 26
5139: PUSH
5140: LD_INT 27
5142: PUSH
5143: LD_INT 28
5145: PUSH
5146: LD_INT 29
5148: PUSH
5149: LD_INT 30
5151: PUSH
5152: LD_INT 31
5154: PUSH
5155: LD_INT 32
5157: PUSH
5158: LD_INT 33
5160: PUSH
5161: LD_INT 34
5163: PUSH
5164: LD_INT 35
5166: PUSH
5167: LD_INT 36
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: LIST
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_INT 101
5210: PUSH
5211: LD_INT 102
5213: PUSH
5214: LD_INT 103
5216: PUSH
5217: LD_INT 104
5219: PUSH
5220: LD_INT 105
5222: PUSH
5223: LD_INT 106
5225: PUSH
5226: LD_INT 107
5228: PUSH
5229: LD_INT 108
5231: PUSH
5232: LD_INT 109
5234: PUSH
5235: LD_INT 110
5237: PUSH
5238: LD_INT 111
5240: PUSH
5241: LD_INT 112
5243: PUSH
5244: LD_INT 113
5246: PUSH
5247: LD_INT 114
5249: PUSH
5250: LD_INT 115
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: LIST
5257: LIST
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: LIST
5267: LIST
5268: LIST
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: ST_TO_ADDR
5274: GO 5277
5276: POP
// end else
5277: GO 5496
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
5279: LD_ADDR_VAR 0 1
5283: PUSH
5284: LD_INT 1
5286: PUSH
5287: LD_INT 2
5289: PUSH
5290: LD_INT 3
5292: PUSH
5293: LD_INT 4
5295: PUSH
5296: LD_INT 5
5298: PUSH
5299: LD_INT 6
5301: PUSH
5302: LD_INT 7
5304: PUSH
5305: LD_INT 8
5307: PUSH
5308: LD_INT 9
5310: PUSH
5311: LD_INT 10
5313: PUSH
5314: LD_INT 11
5316: PUSH
5317: LD_INT 12
5319: PUSH
5320: LD_INT 13
5322: PUSH
5323: LD_INT 14
5325: PUSH
5326: LD_INT 15
5328: PUSH
5329: LD_INT 16
5331: PUSH
5332: LD_INT 17
5334: PUSH
5335: LD_INT 18
5337: PUSH
5338: LD_INT 19
5340: PUSH
5341: LD_INT 20
5343: PUSH
5344: LD_INT 21
5346: PUSH
5347: LD_INT 22
5349: PUSH
5350: LD_INT 23
5352: PUSH
5353: LD_INT 24
5355: PUSH
5356: LD_INT 25
5358: PUSH
5359: LD_INT 26
5361: PUSH
5362: LD_INT 27
5364: PUSH
5365: LD_INT 28
5367: PUSH
5368: LD_INT 29
5370: PUSH
5371: LD_INT 30
5373: PUSH
5374: LD_INT 31
5376: PUSH
5377: LD_INT 32
5379: PUSH
5380: LD_INT 33
5382: PUSH
5383: LD_INT 34
5385: PUSH
5386: LD_INT 35
5388: PUSH
5389: LD_INT 36
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: LIST
5400: LIST
5401: LIST
5402: LIST
5403: LIST
5404: LIST
5405: LIST
5406: LIST
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: LIST
5417: LIST
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 101
5432: PUSH
5433: LD_INT 102
5435: PUSH
5436: LD_INT 103
5438: PUSH
5439: LD_INT 104
5441: PUSH
5442: LD_INT 105
5444: PUSH
5445: LD_INT 106
5447: PUSH
5448: LD_INT 107
5450: PUSH
5451: LD_INT 108
5453: PUSH
5454: LD_INT 109
5456: PUSH
5457: LD_INT 110
5459: PUSH
5460: LD_INT 111
5462: PUSH
5463: LD_INT 112
5465: PUSH
5466: LD_INT 113
5468: PUSH
5469: LD_INT 114
5471: PUSH
5472: LD_INT 115
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: LIST
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: LIST
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: ST_TO_ADDR
// if result then
5496: LD_VAR 0 1
5500: IFFALSE 5789
// begin normal :=  ;
5502: LD_ADDR_VAR 0 3
5506: PUSH
5507: LD_STRING 
5509: ST_TO_ADDR
// hardcore :=  ;
5510: LD_ADDR_VAR 0 4
5514: PUSH
5515: LD_STRING 
5517: ST_TO_ADDR
// for i = 1 to normalCounter do
5518: LD_ADDR_VAR 0 5
5522: PUSH
5523: DOUBLE
5524: LD_INT 1
5526: DEC
5527: ST_TO_ADDR
5528: LD_EXP 9
5532: PUSH
5533: FOR_TO
5534: IFFALSE 5635
// begin tmp := 0 ;
5536: LD_ADDR_VAR 0 2
5540: PUSH
5541: LD_STRING 0
5543: ST_TO_ADDR
// if result [ 1 ] then
5544: LD_VAR 0 1
5548: PUSH
5549: LD_INT 1
5551: ARRAY
5552: IFFALSE 5617
// if result [ 1 ] [ 1 ] = i then
5554: LD_VAR 0 1
5558: PUSH
5559: LD_INT 1
5561: ARRAY
5562: PUSH
5563: LD_INT 1
5565: ARRAY
5566: PUSH
5567: LD_VAR 0 5
5571: EQUAL
5572: IFFALSE 5617
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
5574: LD_ADDR_VAR 0 1
5578: PUSH
5579: LD_VAR 0 1
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: LD_VAR 0 1
5591: PUSH
5592: LD_INT 1
5594: ARRAY
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL_OW 3
5603: PPUSH
5604: CALL_OW 1
5608: ST_TO_ADDR
// tmp := 1 ;
5609: LD_ADDR_VAR 0 2
5613: PUSH
5614: LD_STRING 1
5616: ST_TO_ADDR
// end ; normal := normal & tmp ;
5617: LD_ADDR_VAR 0 3
5621: PUSH
5622: LD_VAR 0 3
5626: PUSH
5627: LD_VAR 0 2
5631: STR
5632: ST_TO_ADDR
// end ;
5633: GO 5533
5635: POP
5636: POP
// for i = 1 to hardcoreCounter do
5637: LD_ADDR_VAR 0 5
5641: PUSH
5642: DOUBLE
5643: LD_INT 1
5645: DEC
5646: ST_TO_ADDR
5647: LD_EXP 10
5651: PUSH
5652: FOR_TO
5653: IFFALSE 5758
// begin tmp := 0 ;
5655: LD_ADDR_VAR 0 2
5659: PUSH
5660: LD_STRING 0
5662: ST_TO_ADDR
// if result [ 2 ] then
5663: LD_VAR 0 1
5667: PUSH
5668: LD_INT 2
5670: ARRAY
5671: IFFALSE 5740
// if result [ 2 ] [ 1 ] = 100 + i then
5673: LD_VAR 0 1
5677: PUSH
5678: LD_INT 2
5680: ARRAY
5681: PUSH
5682: LD_INT 1
5684: ARRAY
5685: PUSH
5686: LD_INT 100
5688: PUSH
5689: LD_VAR 0 5
5693: PLUS
5694: EQUAL
5695: IFFALSE 5740
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
5697: LD_ADDR_VAR 0 1
5701: PUSH
5702: LD_VAR 0 1
5706: PPUSH
5707: LD_INT 2
5709: PPUSH
5710: LD_VAR 0 1
5714: PUSH
5715: LD_INT 2
5717: ARRAY
5718: PPUSH
5719: LD_INT 1
5721: PPUSH
5722: CALL_OW 3
5726: PPUSH
5727: CALL_OW 1
5731: ST_TO_ADDR
// tmp := 1 ;
5732: LD_ADDR_VAR 0 2
5736: PUSH
5737: LD_STRING 1
5739: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
5740: LD_ADDR_VAR 0 4
5744: PUSH
5745: LD_VAR 0 4
5749: PUSH
5750: LD_VAR 0 2
5754: STR
5755: ST_TO_ADDR
// end ;
5756: GO 5652
5758: POP
5759: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
5760: LD_STRING getStreamItemsFromMission("
5762: PUSH
5763: LD_VAR 0 3
5767: STR
5768: PUSH
5769: LD_STRING ","
5771: STR
5772: PUSH
5773: LD_VAR 0 4
5777: STR
5778: PUSH
5779: LD_STRING ")
5781: STR
5782: PPUSH
5783: CALL_OW 559
// end else
5787: GO 5796
// ToLua ( getStreamItemsFromMission("","") ) ;
5789: LD_STRING getStreamItemsFromMission("","")
5791: PPUSH
5792: CALL_OW 559
// end ;
5796: LD_VAR 0 1
5800: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
5801: LD_VAR 0 2
5805: PUSH
5806: LD_INT 100
5808: EQUAL
5809: IFFALSE 6758
// begin if not StreamModeActive then
5811: LD_EXP 8
5815: NOT
5816: IFFALSE 5826
// StreamModeActive := true ;
5818: LD_ADDR_EXP 8
5822: PUSH
5823: LD_INT 1
5825: ST_TO_ADDR
// if p3 = 0 then
5826: LD_VAR 0 3
5830: PUSH
5831: LD_INT 0
5833: EQUAL
5834: IFFALSE 5840
// InitStreamMode ;
5836: CALL 1879 0 0
// if p3 = 1 then
5840: LD_VAR 0 3
5844: PUSH
5845: LD_INT 1
5847: EQUAL
5848: IFFALSE 5858
// sRocket := true ;
5850: LD_ADDR_EXP 13
5854: PUSH
5855: LD_INT 1
5857: ST_TO_ADDR
// if p3 = 2 then
5858: LD_VAR 0 3
5862: PUSH
5863: LD_INT 2
5865: EQUAL
5866: IFFALSE 5876
// sSpeed := true ;
5868: LD_ADDR_EXP 12
5872: PUSH
5873: LD_INT 1
5875: ST_TO_ADDR
// if p3 = 3 then
5876: LD_VAR 0 3
5880: PUSH
5881: LD_INT 3
5883: EQUAL
5884: IFFALSE 5894
// sEngine := true ;
5886: LD_ADDR_EXP 14
5890: PUSH
5891: LD_INT 1
5893: ST_TO_ADDR
// if p3 = 4 then
5894: LD_VAR 0 3
5898: PUSH
5899: LD_INT 4
5901: EQUAL
5902: IFFALSE 5912
// sSpec := true ;
5904: LD_ADDR_EXP 11
5908: PUSH
5909: LD_INT 1
5911: ST_TO_ADDR
// if p3 = 5 then
5912: LD_VAR 0 3
5916: PUSH
5917: LD_INT 5
5919: EQUAL
5920: IFFALSE 5930
// sLevel := true ;
5922: LD_ADDR_EXP 15
5926: PUSH
5927: LD_INT 1
5929: ST_TO_ADDR
// if p3 = 6 then
5930: LD_VAR 0 3
5934: PUSH
5935: LD_INT 6
5937: EQUAL
5938: IFFALSE 5948
// sArmoury := true ;
5940: LD_ADDR_EXP 16
5944: PUSH
5945: LD_INT 1
5947: ST_TO_ADDR
// if p3 = 7 then
5948: LD_VAR 0 3
5952: PUSH
5953: LD_INT 7
5955: EQUAL
5956: IFFALSE 5966
// sRadar := true ;
5958: LD_ADDR_EXP 17
5962: PUSH
5963: LD_INT 1
5965: ST_TO_ADDR
// if p3 = 8 then
5966: LD_VAR 0 3
5970: PUSH
5971: LD_INT 8
5973: EQUAL
5974: IFFALSE 5984
// sBunker := true ;
5976: LD_ADDR_EXP 18
5980: PUSH
5981: LD_INT 1
5983: ST_TO_ADDR
// if p3 = 9 then
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 9
5991: EQUAL
5992: IFFALSE 6002
// sHack := true ;
5994: LD_ADDR_EXP 19
5998: PUSH
5999: LD_INT 1
6001: ST_TO_ADDR
// if p3 = 10 then
6002: LD_VAR 0 3
6006: PUSH
6007: LD_INT 10
6009: EQUAL
6010: IFFALSE 6020
// sFire := true ;
6012: LD_ADDR_EXP 20
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// if p3 = 11 then
6020: LD_VAR 0 3
6024: PUSH
6025: LD_INT 11
6027: EQUAL
6028: IFFALSE 6038
// sRefresh := true ;
6030: LD_ADDR_EXP 21
6034: PUSH
6035: LD_INT 1
6037: ST_TO_ADDR
// if p3 = 12 then
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 12
6045: EQUAL
6046: IFFALSE 6056
// sExp := true ;
6048: LD_ADDR_EXP 22
6052: PUSH
6053: LD_INT 1
6055: ST_TO_ADDR
// if p3 = 13 then
6056: LD_VAR 0 3
6060: PUSH
6061: LD_INT 13
6063: EQUAL
6064: IFFALSE 6074
// sDepot := true ;
6066: LD_ADDR_EXP 23
6070: PUSH
6071: LD_INT 1
6073: ST_TO_ADDR
// if p3 = 14 then
6074: LD_VAR 0 3
6078: PUSH
6079: LD_INT 14
6081: EQUAL
6082: IFFALSE 6092
// sFlag := true ;
6084: LD_ADDR_EXP 24
6088: PUSH
6089: LD_INT 1
6091: ST_TO_ADDR
// if p3 = 15 then
6092: LD_VAR 0 3
6096: PUSH
6097: LD_INT 15
6099: EQUAL
6100: IFFALSE 6110
// sKamikadze := true ;
6102: LD_ADDR_EXP 32
6106: PUSH
6107: LD_INT 1
6109: ST_TO_ADDR
// if p3 = 16 then
6110: LD_VAR 0 3
6114: PUSH
6115: LD_INT 16
6117: EQUAL
6118: IFFALSE 6128
// sTroll := true ;
6120: LD_ADDR_EXP 33
6124: PUSH
6125: LD_INT 1
6127: ST_TO_ADDR
// if p3 = 17 then
6128: LD_VAR 0 3
6132: PUSH
6133: LD_INT 17
6135: EQUAL
6136: IFFALSE 6146
// sSlow := true ;
6138: LD_ADDR_EXP 34
6142: PUSH
6143: LD_INT 1
6145: ST_TO_ADDR
// if p3 = 18 then
6146: LD_VAR 0 3
6150: PUSH
6151: LD_INT 18
6153: EQUAL
6154: IFFALSE 6164
// sLack := true ;
6156: LD_ADDR_EXP 35
6160: PUSH
6161: LD_INT 1
6163: ST_TO_ADDR
// if p3 = 19 then
6164: LD_VAR 0 3
6168: PUSH
6169: LD_INT 19
6171: EQUAL
6172: IFFALSE 6182
// sTank := true ;
6174: LD_ADDR_EXP 37
6178: PUSH
6179: LD_INT 1
6181: ST_TO_ADDR
// if p3 = 20 then
6182: LD_VAR 0 3
6186: PUSH
6187: LD_INT 20
6189: EQUAL
6190: IFFALSE 6200
// sRemote := true ;
6192: LD_ADDR_EXP 38
6196: PUSH
6197: LD_INT 1
6199: ST_TO_ADDR
// if p3 = 21 then
6200: LD_VAR 0 3
6204: PUSH
6205: LD_INT 21
6207: EQUAL
6208: IFFALSE 6218
// sPowell := true ;
6210: LD_ADDR_EXP 39
6214: PUSH
6215: LD_INT 1
6217: ST_TO_ADDR
// if p3 = 22 then
6218: LD_VAR 0 3
6222: PUSH
6223: LD_INT 22
6225: EQUAL
6226: IFFALSE 6236
// sTeleport := true ;
6228: LD_ADDR_EXP 42
6232: PUSH
6233: LD_INT 1
6235: ST_TO_ADDR
// if p3 = 23 then
6236: LD_VAR 0 3
6240: PUSH
6241: LD_INT 23
6243: EQUAL
6244: IFFALSE 6254
// sOilTower := true ;
6246: LD_ADDR_EXP 44
6250: PUSH
6251: LD_INT 1
6253: ST_TO_ADDR
// if p3 = 24 then
6254: LD_VAR 0 3
6258: PUSH
6259: LD_INT 24
6261: EQUAL
6262: IFFALSE 6272
// sShovel := true ;
6264: LD_ADDR_EXP 45
6268: PUSH
6269: LD_INT 1
6271: ST_TO_ADDR
// if p3 = 25 then
6272: LD_VAR 0 3
6276: PUSH
6277: LD_INT 25
6279: EQUAL
6280: IFFALSE 6290
// sSheik := true ;
6282: LD_ADDR_EXP 46
6286: PUSH
6287: LD_INT 1
6289: ST_TO_ADDR
// if p3 = 26 then
6290: LD_VAR 0 3
6294: PUSH
6295: LD_INT 26
6297: EQUAL
6298: IFFALSE 6308
// sEarthquake := true ;
6300: LD_ADDR_EXP 48
6304: PUSH
6305: LD_INT 1
6307: ST_TO_ADDR
// if p3 = 27 then
6308: LD_VAR 0 3
6312: PUSH
6313: LD_INT 27
6315: EQUAL
6316: IFFALSE 6326
// sAI := true ;
6318: LD_ADDR_EXP 49
6322: PUSH
6323: LD_INT 1
6325: ST_TO_ADDR
// if p3 = 28 then
6326: LD_VAR 0 3
6330: PUSH
6331: LD_INT 28
6333: EQUAL
6334: IFFALSE 6344
// sCargo := true ;
6336: LD_ADDR_EXP 52
6340: PUSH
6341: LD_INT 1
6343: ST_TO_ADDR
// if p3 = 29 then
6344: LD_VAR 0 3
6348: PUSH
6349: LD_INT 29
6351: EQUAL
6352: IFFALSE 6362
// sDLaser := true ;
6354: LD_ADDR_EXP 53
6358: PUSH
6359: LD_INT 1
6361: ST_TO_ADDR
// if p3 = 30 then
6362: LD_VAR 0 3
6366: PUSH
6367: LD_INT 30
6369: EQUAL
6370: IFFALSE 6380
// sExchange := true ;
6372: LD_ADDR_EXP 54
6376: PUSH
6377: LD_INT 1
6379: ST_TO_ADDR
// if p3 = 31 then
6380: LD_VAR 0 3
6384: PUSH
6385: LD_INT 31
6387: EQUAL
6388: IFFALSE 6398
// sFac := true ;
6390: LD_ADDR_EXP 55
6394: PUSH
6395: LD_INT 1
6397: ST_TO_ADDR
// if p3 = 32 then
6398: LD_VAR 0 3
6402: PUSH
6403: LD_INT 32
6405: EQUAL
6406: IFFALSE 6416
// sPower := true ;
6408: LD_ADDR_EXP 56
6412: PUSH
6413: LD_INT 1
6415: ST_TO_ADDR
// if p3 = 33 then
6416: LD_VAR 0 3
6420: PUSH
6421: LD_INT 33
6423: EQUAL
6424: IFFALSE 6434
// sRandom := true ;
6426: LD_ADDR_EXP 57
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// if p3 = 34 then
6434: LD_VAR 0 3
6438: PUSH
6439: LD_INT 34
6441: EQUAL
6442: IFFALSE 6452
// sShield := true ;
6444: LD_ADDR_EXP 58
6448: PUSH
6449: LD_INT 1
6451: ST_TO_ADDR
// if p3 = 35 then
6452: LD_VAR 0 3
6456: PUSH
6457: LD_INT 35
6459: EQUAL
6460: IFFALSE 6470
// sTime := true ;
6462: LD_ADDR_EXP 59
6466: PUSH
6467: LD_INT 1
6469: ST_TO_ADDR
// if p3 = 36 then
6470: LD_VAR 0 3
6474: PUSH
6475: LD_INT 36
6477: EQUAL
6478: IFFALSE 6488
// sTools := true ;
6480: LD_ADDR_EXP 60
6484: PUSH
6485: LD_INT 1
6487: ST_TO_ADDR
// if p3 = 101 then
6488: LD_VAR 0 3
6492: PUSH
6493: LD_INT 101
6495: EQUAL
6496: IFFALSE 6506
// sSold := true ;
6498: LD_ADDR_EXP 25
6502: PUSH
6503: LD_INT 1
6505: ST_TO_ADDR
// if p3 = 102 then
6506: LD_VAR 0 3
6510: PUSH
6511: LD_INT 102
6513: EQUAL
6514: IFFALSE 6524
// sDiff := true ;
6516: LD_ADDR_EXP 26
6520: PUSH
6521: LD_INT 1
6523: ST_TO_ADDR
// if p3 = 103 then
6524: LD_VAR 0 3
6528: PUSH
6529: LD_INT 103
6531: EQUAL
6532: IFFALSE 6542
// sFog := true ;
6534: LD_ADDR_EXP 29
6538: PUSH
6539: LD_INT 1
6541: ST_TO_ADDR
// if p3 = 104 then
6542: LD_VAR 0 3
6546: PUSH
6547: LD_INT 104
6549: EQUAL
6550: IFFALSE 6560
// sReset := true ;
6552: LD_ADDR_EXP 30
6556: PUSH
6557: LD_INT 1
6559: ST_TO_ADDR
// if p3 = 105 then
6560: LD_VAR 0 3
6564: PUSH
6565: LD_INT 105
6567: EQUAL
6568: IFFALSE 6578
// sSun := true ;
6570: LD_ADDR_EXP 31
6574: PUSH
6575: LD_INT 1
6577: ST_TO_ADDR
// if p3 = 106 then
6578: LD_VAR 0 3
6582: PUSH
6583: LD_INT 106
6585: EQUAL
6586: IFFALSE 6596
// sTiger := true ;
6588: LD_ADDR_EXP 27
6592: PUSH
6593: LD_INT 1
6595: ST_TO_ADDR
// if p3 = 107 then
6596: LD_VAR 0 3
6600: PUSH
6601: LD_INT 107
6603: EQUAL
6604: IFFALSE 6614
// sBomb := true ;
6606: LD_ADDR_EXP 28
6610: PUSH
6611: LD_INT 1
6613: ST_TO_ADDR
// if p3 = 108 then
6614: LD_VAR 0 3
6618: PUSH
6619: LD_INT 108
6621: EQUAL
6622: IFFALSE 6632
// sWound := true ;
6624: LD_ADDR_EXP 36
6628: PUSH
6629: LD_INT 1
6631: ST_TO_ADDR
// if p3 = 109 then
6632: LD_VAR 0 3
6636: PUSH
6637: LD_INT 109
6639: EQUAL
6640: IFFALSE 6650
// sBetray := true ;
6642: LD_ADDR_EXP 40
6646: PUSH
6647: LD_INT 1
6649: ST_TO_ADDR
// if p3 = 110 then
6650: LD_VAR 0 3
6654: PUSH
6655: LD_INT 110
6657: EQUAL
6658: IFFALSE 6668
// sContamin := true ;
6660: LD_ADDR_EXP 41
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// if p3 = 111 then
6668: LD_VAR 0 3
6672: PUSH
6673: LD_INT 111
6675: EQUAL
6676: IFFALSE 6686
// sOil := true ;
6678: LD_ADDR_EXP 43
6682: PUSH
6683: LD_INT 1
6685: ST_TO_ADDR
// if p3 = 112 then
6686: LD_VAR 0 3
6690: PUSH
6691: LD_INT 112
6693: EQUAL
6694: IFFALSE 6704
// sStu := true ;
6696: LD_ADDR_EXP 47
6700: PUSH
6701: LD_INT 1
6703: ST_TO_ADDR
// if p3 = 113 then
6704: LD_VAR 0 3
6708: PUSH
6709: LD_INT 113
6711: EQUAL
6712: IFFALSE 6722
// sBazooka := true ;
6714: LD_ADDR_EXP 50
6718: PUSH
6719: LD_INT 1
6721: ST_TO_ADDR
// if p3 = 114 then
6722: LD_VAR 0 3
6726: PUSH
6727: LD_INT 114
6729: EQUAL
6730: IFFALSE 6740
// sMortar := true ;
6732: LD_ADDR_EXP 51
6736: PUSH
6737: LD_INT 1
6739: ST_TO_ADDR
// if p3 = 115 then
6740: LD_VAR 0 3
6744: PUSH
6745: LD_INT 115
6747: EQUAL
6748: IFFALSE 6758
// sRanger := true ;
6750: LD_ADDR_EXP 61
6754: PUSH
6755: LD_INT 1
6757: ST_TO_ADDR
// end ; end ;
6758: PPOPN 6
6760: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
6761: LD_EXP 8
6765: PUSH
6766: LD_EXP 13
6770: AND
6771: IFFALSE 6895
6773: GO 6775
6775: DISABLE
6776: LD_INT 0
6778: PPUSH
6779: PPUSH
// begin enable ;
6780: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
6781: LD_ADDR_VAR 0 2
6785: PUSH
6786: LD_INT 22
6788: PUSH
6789: LD_OWVAR 2
6793: PUSH
6794: EMPTY
6795: LIST
6796: LIST
6797: PUSH
6798: LD_INT 2
6800: PUSH
6801: LD_INT 34
6803: PUSH
6804: LD_INT 7
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: LD_INT 34
6813: PUSH
6814: LD_INT 45
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: PUSH
6821: LD_INT 34
6823: PUSH
6824: LD_INT 28
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: PUSH
6831: LD_INT 34
6833: PUSH
6834: LD_INT 47
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: LIST
6845: LIST
6846: LIST
6847: PUSH
6848: EMPTY
6849: LIST
6850: LIST
6851: PPUSH
6852: CALL_OW 69
6856: ST_TO_ADDR
// if not tmp then
6857: LD_VAR 0 2
6861: NOT
6862: IFFALSE 6866
// exit ;
6864: GO 6895
// for i in tmp do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: LD_VAR 0 2
6875: PUSH
6876: FOR_IN
6877: IFFALSE 6893
// begin SetLives ( i , 0 ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_INT 0
6886: PPUSH
6887: CALL_OW 234
// end ;
6891: GO 6876
6893: POP
6894: POP
// end ;
6895: PPOPN 2
6897: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
6898: LD_EXP 8
6902: PUSH
6903: LD_EXP 14
6907: AND
6908: IFFALSE 6992
6910: GO 6912
6912: DISABLE
6913: LD_INT 0
6915: PPUSH
6916: PPUSH
// begin enable ;
6917: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
6918: LD_ADDR_VAR 0 2
6922: PUSH
6923: LD_INT 22
6925: PUSH
6926: LD_OWVAR 2
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: PUSH
6935: LD_INT 32
6937: PUSH
6938: LD_INT 3
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PPUSH
6949: CALL_OW 69
6953: ST_TO_ADDR
// if not tmp then
6954: LD_VAR 0 2
6958: NOT
6959: IFFALSE 6963
// exit ;
6961: GO 6992
// for i in tmp do
6963: LD_ADDR_VAR 0 1
6967: PUSH
6968: LD_VAR 0 2
6972: PUSH
6973: FOR_IN
6974: IFFALSE 6990
// begin SetLives ( i , 0 ) ;
6976: LD_VAR 0 1
6980: PPUSH
6981: LD_INT 0
6983: PPUSH
6984: CALL_OW 234
// end ;
6988: GO 6973
6990: POP
6991: POP
// end ;
6992: PPOPN 2
6994: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
6995: LD_EXP 8
6999: PUSH
7000: LD_EXP 11
7004: AND
7005: IFFALSE 7098
7007: GO 7009
7009: DISABLE
7010: LD_INT 0
7012: PPUSH
// begin enable ;
7013: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7014: LD_ADDR_VAR 0 1
7018: PUSH
7019: LD_INT 22
7021: PUSH
7022: LD_OWVAR 2
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: LD_INT 25
7036: PUSH
7037: LD_INT 5
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PUSH
7044: LD_INT 25
7046: PUSH
7047: LD_INT 9
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PUSH
7054: LD_INT 25
7056: PUSH
7057: LD_INT 8
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: CALL_OW 69
7078: PUSH
7079: FOR_IN
7080: IFFALSE 7096
// begin SetClass ( i , 1 ) ;
7082: LD_VAR 0 1
7086: PPUSH
7087: LD_INT 1
7089: PPUSH
7090: CALL_OW 336
// end ;
7094: GO 7079
7096: POP
7097: POP
// end ;
7098: PPOPN 1
7100: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7101: LD_EXP 8
7105: PUSH
7106: LD_EXP 12
7110: AND
7111: PUSH
7112: LD_OWVAR 65
7116: PUSH
7117: LD_INT 7
7119: LESS
7120: AND
7121: IFFALSE 7135
7123: GO 7125
7125: DISABLE
// begin enable ;
7126: ENABLE
// game_speed := 7 ;
7127: LD_ADDR_OWVAR 65
7131: PUSH
7132: LD_INT 7
7134: ST_TO_ADDR
// end ;
7135: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7136: LD_EXP 8
7140: PUSH
7141: LD_EXP 15
7145: AND
7146: IFFALSE 7348
7148: GO 7150
7150: DISABLE
7151: LD_INT 0
7153: PPUSH
7154: PPUSH
7155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7156: LD_ADDR_VAR 0 3
7160: PUSH
7161: LD_INT 81
7163: PUSH
7164: LD_OWVAR 2
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 21
7175: PUSH
7176: LD_INT 1
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 69
7191: ST_TO_ADDR
// if not tmp then
7192: LD_VAR 0 3
7196: NOT
7197: IFFALSE 7201
// exit ;
7199: GO 7348
// if tmp > 5 then
7201: LD_VAR 0 3
7205: PUSH
7206: LD_INT 5
7208: GREATER
7209: IFFALSE 7221
// k := 5 else
7211: LD_ADDR_VAR 0 2
7215: PUSH
7216: LD_INT 5
7218: ST_TO_ADDR
7219: GO 7231
// k := tmp ;
7221: LD_ADDR_VAR 0 2
7225: PUSH
7226: LD_VAR 0 3
7230: ST_TO_ADDR
// for i := 1 to k do
7231: LD_ADDR_VAR 0 1
7235: PUSH
7236: DOUBLE
7237: LD_INT 1
7239: DEC
7240: ST_TO_ADDR
7241: LD_VAR 0 2
7245: PUSH
7246: FOR_TO
7247: IFFALSE 7346
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7249: LD_VAR 0 3
7253: PUSH
7254: LD_VAR 0 1
7258: ARRAY
7259: PPUSH
7260: LD_VAR 0 1
7264: PUSH
7265: LD_INT 4
7267: MOD
7268: PUSH
7269: LD_INT 1
7271: PLUS
7272: PPUSH
7273: CALL_OW 259
7277: PUSH
7278: LD_INT 10
7280: LESS
7281: IFFALSE 7344
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7283: LD_VAR 0 3
7287: PUSH
7288: LD_VAR 0 1
7292: ARRAY
7293: PPUSH
7294: LD_VAR 0 1
7298: PUSH
7299: LD_INT 4
7301: MOD
7302: PUSH
7303: LD_INT 1
7305: PLUS
7306: PPUSH
7307: LD_VAR 0 3
7311: PUSH
7312: LD_VAR 0 1
7316: ARRAY
7317: PPUSH
7318: LD_VAR 0 1
7322: PUSH
7323: LD_INT 4
7325: MOD
7326: PUSH
7327: LD_INT 1
7329: PLUS
7330: PPUSH
7331: CALL_OW 259
7335: PUSH
7336: LD_INT 1
7338: PLUS
7339: PPUSH
7340: CALL_OW 237
7344: GO 7246
7346: POP
7347: POP
// end ;
7348: PPOPN 3
7350: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7351: LD_EXP 8
7355: PUSH
7356: LD_EXP 16
7360: AND
7361: IFFALSE 7381
7363: GO 7365
7365: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7366: LD_INT 4
7368: PPUSH
7369: LD_OWVAR 2
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 324
7381: END
// every 0 0$1 trigger StreamModeActive and sShovel do
7382: LD_EXP 8
7386: PUSH
7387: LD_EXP 45
7391: AND
7392: IFFALSE 7412
7394: GO 7396
7396: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
7397: LD_INT 19
7399: PPUSH
7400: LD_OWVAR 2
7404: PPUSH
7405: LD_INT 0
7407: PPUSH
7408: CALL_OW 324
7412: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7413: LD_EXP 8
7417: PUSH
7418: LD_EXP 17
7422: AND
7423: IFFALSE 7525
7425: GO 7427
7427: DISABLE
7428: LD_INT 0
7430: PPUSH
7431: PPUSH
// begin enable ;
7432: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7433: LD_ADDR_VAR 0 2
7437: PUSH
7438: LD_INT 22
7440: PUSH
7441: LD_OWVAR 2
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: LD_INT 34
7455: PUSH
7456: LD_INT 11
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 34
7465: PUSH
7466: LD_INT 30
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PPUSH
7482: CALL_OW 69
7486: ST_TO_ADDR
// if not tmp then
7487: LD_VAR 0 2
7491: NOT
7492: IFFALSE 7496
// exit ;
7494: GO 7525
// for i in tmp do
7496: LD_ADDR_VAR 0 1
7500: PUSH
7501: LD_VAR 0 2
7505: PUSH
7506: FOR_IN
7507: IFFALSE 7523
// begin SetLives ( i , 0 ) ;
7509: LD_VAR 0 1
7513: PPUSH
7514: LD_INT 0
7516: PPUSH
7517: CALL_OW 234
// end ;
7521: GO 7506
7523: POP
7524: POP
// end ;
7525: PPOPN 2
7527: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7528: LD_EXP 8
7532: PUSH
7533: LD_EXP 18
7537: AND
7538: IFFALSE 7558
7540: GO 7542
7542: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7543: LD_INT 32
7545: PPUSH
7546: LD_OWVAR 2
7550: PPUSH
7551: LD_INT 0
7553: PPUSH
7554: CALL_OW 324
7558: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
7559: LD_EXP 8
7563: PUSH
7564: LD_EXP 19
7568: AND
7569: IFFALSE 7750
7571: GO 7573
7573: DISABLE
7574: LD_INT 0
7576: PPUSH
7577: PPUSH
7578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
7579: LD_ADDR_VAR 0 2
7583: PUSH
7584: LD_INT 22
7586: PUSH
7587: LD_OWVAR 2
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: LD_INT 33
7598: PUSH
7599: LD_INT 3
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PPUSH
7610: CALL_OW 69
7614: ST_TO_ADDR
// if not tmp then
7615: LD_VAR 0 2
7619: NOT
7620: IFFALSE 7624
// exit ;
7622: GO 7750
// side := 0 ;
7624: LD_ADDR_VAR 0 3
7628: PUSH
7629: LD_INT 0
7631: ST_TO_ADDR
// for i := 1 to 8 do
7632: LD_ADDR_VAR 0 1
7636: PUSH
7637: DOUBLE
7638: LD_INT 1
7640: DEC
7641: ST_TO_ADDR
7642: LD_INT 8
7644: PUSH
7645: FOR_TO
7646: IFFALSE 7694
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
7648: LD_OWVAR 2
7652: PUSH
7653: LD_VAR 0 1
7657: NONEQUAL
7658: PUSH
7659: LD_OWVAR 2
7663: PPUSH
7664: LD_VAR 0 1
7668: PPUSH
7669: CALL_OW 81
7673: PUSH
7674: LD_INT 2
7676: EQUAL
7677: AND
7678: IFFALSE 7692
// begin side := i ;
7680: LD_ADDR_VAR 0 3
7684: PUSH
7685: LD_VAR 0 1
7689: ST_TO_ADDR
// break ;
7690: GO 7694
// end ;
7692: GO 7645
7694: POP
7695: POP
// if not side then
7696: LD_VAR 0 3
7700: NOT
7701: IFFALSE 7705
// exit ;
7703: GO 7750
// for i := 1 to tmp do
7705: LD_ADDR_VAR 0 1
7709: PUSH
7710: DOUBLE
7711: LD_INT 1
7713: DEC
7714: ST_TO_ADDR
7715: LD_VAR 0 2
7719: PUSH
7720: FOR_TO
7721: IFFALSE 7748
// if Prob ( 60 ) then
7723: LD_INT 60
7725: PPUSH
7726: CALL_OW 13
7730: IFFALSE 7746
// SetSide ( i , side ) ;
7732: LD_VAR 0 1
7736: PPUSH
7737: LD_VAR 0 3
7741: PPUSH
7742: CALL_OW 235
7746: GO 7720
7748: POP
7749: POP
// end ;
7750: PPOPN 3
7752: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
7753: LD_EXP 8
7757: PUSH
7758: LD_EXP 21
7762: AND
7763: IFFALSE 7882
7765: GO 7767
7767: DISABLE
7768: LD_INT 0
7770: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
7771: LD_ADDR_VAR 0 1
7775: PUSH
7776: LD_INT 22
7778: PUSH
7779: LD_OWVAR 2
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 21
7790: PUSH
7791: LD_INT 1
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: PUSH
7798: LD_INT 3
7800: PUSH
7801: LD_INT 23
7803: PUSH
7804: LD_INT 0
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 69
7824: PUSH
7825: FOR_IN
7826: IFFALSE 7880
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
7828: LD_VAR 0 1
7832: PPUSH
7833: CALL_OW 257
7837: PUSH
7838: LD_INT 1
7840: PUSH
7841: LD_INT 2
7843: PUSH
7844: LD_INT 3
7846: PUSH
7847: LD_INT 4
7849: PUSH
7850: EMPTY
7851: LIST
7852: LIST
7853: LIST
7854: LIST
7855: IN
7856: IFFALSE 7878
// SetClass ( un , rand ( 1 , 4 ) ) ;
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 1
7865: PPUSH
7866: LD_INT 4
7868: PPUSH
7869: CALL_OW 12
7873: PPUSH
7874: CALL_OW 336
7878: GO 7825
7880: POP
7881: POP
// end ;
7882: PPOPN 1
7884: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
7885: LD_EXP 8
7889: PUSH
7890: LD_EXP 20
7894: AND
7895: IFFALSE 7974
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
7903: LD_ADDR_VAR 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_OWVAR 2
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 21
7922: PUSH
7923: LD_INT 3
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: PPUSH
7934: CALL_OW 69
7938: ST_TO_ADDR
// if not tmp then
7939: LD_VAR 0 1
7943: NOT
7944: IFFALSE 7948
// exit ;
7946: GO 7974
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
7948: LD_VAR 0 1
7952: PUSH
7953: LD_INT 1
7955: PPUSH
7956: LD_VAR 0 1
7960: PPUSH
7961: CALL_OW 12
7965: ARRAY
7966: PPUSH
7967: LD_INT 100
7969: PPUSH
7970: CALL_OW 234
// end ;
7974: PPOPN 1
7976: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
7977: LD_EXP 8
7981: PUSH
7982: LD_EXP 22
7986: AND
7987: IFFALSE 8085
7989: GO 7991
7991: DISABLE
7992: LD_INT 0
7994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: LD_INT 22
8002: PUSH
8003: LD_OWVAR 2
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PUSH
8012: LD_INT 21
8014: PUSH
8015: LD_INT 1
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PPUSH
8026: CALL_OW 69
8030: ST_TO_ADDR
// if not tmp then
8031: LD_VAR 0 1
8035: NOT
8036: IFFALSE 8040
// exit ;
8038: GO 8085
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8040: LD_VAR 0 1
8044: PUSH
8045: LD_INT 1
8047: PPUSH
8048: LD_VAR 0 1
8052: PPUSH
8053: CALL_OW 12
8057: ARRAY
8058: PPUSH
8059: LD_INT 1
8061: PPUSH
8062: LD_INT 4
8064: PPUSH
8065: CALL_OW 12
8069: PPUSH
8070: LD_INT 3000
8072: PPUSH
8073: LD_INT 9000
8075: PPUSH
8076: CALL_OW 12
8080: PPUSH
8081: CALL_OW 492
// end ;
8085: PPOPN 1
8087: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8088: LD_EXP 8
8092: PUSH
8093: LD_EXP 23
8097: AND
8098: IFFALSE 8118
8100: GO 8102
8102: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8103: LD_INT 1
8105: PPUSH
8106: LD_OWVAR 2
8110: PPUSH
8111: LD_INT 0
8113: PPUSH
8114: CALL_OW 324
8118: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8119: LD_EXP 8
8123: PUSH
8124: LD_EXP 24
8128: AND
8129: IFFALSE 8212
8131: GO 8133
8133: DISABLE
8134: LD_INT 0
8136: PPUSH
8137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8138: LD_ADDR_VAR 0 2
8142: PUSH
8143: LD_INT 22
8145: PUSH
8146: LD_OWVAR 2
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 21
8157: PUSH
8158: LD_INT 3
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: ST_TO_ADDR
// if not tmp then
8174: LD_VAR 0 2
8178: NOT
8179: IFFALSE 8183
// exit ;
8181: GO 8212
// for i in tmp do
8183: LD_ADDR_VAR 0 1
8187: PUSH
8188: LD_VAR 0 2
8192: PUSH
8193: FOR_IN
8194: IFFALSE 8210
// SetBLevel ( i , 10 ) ;
8196: LD_VAR 0 1
8200: PPUSH
8201: LD_INT 10
8203: PPUSH
8204: CALL_OW 241
8208: GO 8193
8210: POP
8211: POP
// end ;
8212: PPOPN 2
8214: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
8215: LD_EXP 8
8219: PUSH
8220: LD_EXP 25
8224: AND
8225: IFFALSE 8336
8227: GO 8229
8229: DISABLE
8230: LD_INT 0
8232: PPUSH
8233: PPUSH
8234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8235: LD_ADDR_VAR 0 3
8239: PUSH
8240: LD_INT 22
8242: PUSH
8243: LD_OWVAR 2
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 25
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: PPUSH
8266: CALL_OW 69
8270: ST_TO_ADDR
// if not tmp then
8271: LD_VAR 0 3
8275: NOT
8276: IFFALSE 8280
// exit ;
8278: GO 8336
// un := tmp [ rand ( 1 , tmp ) ] ;
8280: LD_ADDR_VAR 0 2
8284: PUSH
8285: LD_VAR 0 3
8289: PUSH
8290: LD_INT 1
8292: PPUSH
8293: LD_VAR 0 3
8297: PPUSH
8298: CALL_OW 12
8302: ARRAY
8303: ST_TO_ADDR
// if Crawls ( un ) then
8304: LD_VAR 0 2
8308: PPUSH
8309: CALL_OW 318
8313: IFFALSE 8324
// ComWalk ( un ) ;
8315: LD_VAR 0 2
8319: PPUSH
8320: CALL_OW 138
// SetClass ( un , class_sniper ) ;
8324: LD_VAR 0 2
8328: PPUSH
8329: LD_INT 5
8331: PPUSH
8332: CALL_OW 336
// end ;
8336: PPOPN 3
8338: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8339: LD_EXP 8
8343: PUSH
8344: LD_EXP 26
8348: AND
8349: PUSH
8350: LD_OWVAR 67
8354: PUSH
8355: LD_INT 3
8357: LESS
8358: AND
8359: IFFALSE 8378
8361: GO 8363
8363: DISABLE
// Difficulty := Difficulty + 1 ;
8364: LD_ADDR_OWVAR 67
8368: PUSH
8369: LD_OWVAR 67
8373: PUSH
8374: LD_INT 1
8376: PLUS
8377: ST_TO_ADDR
8378: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8379: LD_EXP 8
8383: PUSH
8384: LD_EXP 27
8388: AND
8389: IFFALSE 8492
8391: GO 8393
8393: DISABLE
8394: LD_INT 0
8396: PPUSH
// begin for i := 1 to 5 do
8397: LD_ADDR_VAR 0 1
8401: PUSH
8402: DOUBLE
8403: LD_INT 1
8405: DEC
8406: ST_TO_ADDR
8407: LD_INT 5
8409: PUSH
8410: FOR_TO
8411: IFFALSE 8490
// begin uc_nation := nation_nature ;
8413: LD_ADDR_OWVAR 21
8417: PUSH
8418: LD_INT 0
8420: ST_TO_ADDR
// uc_side := 0 ;
8421: LD_ADDR_OWVAR 20
8425: PUSH
8426: LD_INT 0
8428: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8429: LD_ADDR_OWVAR 29
8433: PUSH
8434: LD_INT 12
8436: PUSH
8437: LD_INT 12
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: ST_TO_ADDR
// hc_agressivity := 20 ;
8444: LD_ADDR_OWVAR 35
8448: PUSH
8449: LD_INT 20
8451: ST_TO_ADDR
// hc_class := class_tiger ;
8452: LD_ADDR_OWVAR 28
8456: PUSH
8457: LD_INT 14
8459: ST_TO_ADDR
// hc_gallery :=  ;
8460: LD_ADDR_OWVAR 33
8464: PUSH
8465: LD_STRING 
8467: ST_TO_ADDR
// hc_name :=  ;
8468: LD_ADDR_OWVAR 26
8472: PUSH
8473: LD_STRING 
8475: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8476: CALL_OW 44
8480: PPUSH
8481: LD_INT 0
8483: PPUSH
8484: CALL_OW 51
// end ;
8488: GO 8410
8490: POP
8491: POP
// end ;
8492: PPOPN 1
8494: END
// every 0 0$1 trigger StreamModeActive and sBomb do
8495: LD_EXP 8
8499: PUSH
8500: LD_EXP 28
8504: AND
8505: IFFALSE 8514
8507: GO 8509
8509: DISABLE
// StreamSibBomb ;
8510: CALL 8515 0 0
8514: END
// export function StreamSibBomb ; var i , x , y ; begin
8515: LD_INT 0
8517: PPUSH
8518: PPUSH
8519: PPUSH
8520: PPUSH
// result := false ;
8521: LD_ADDR_VAR 0 1
8525: PUSH
8526: LD_INT 0
8528: ST_TO_ADDR
// for i := 1 to 16 do
8529: LD_ADDR_VAR 0 2
8533: PUSH
8534: DOUBLE
8535: LD_INT 1
8537: DEC
8538: ST_TO_ADDR
8539: LD_INT 16
8541: PUSH
8542: FOR_TO
8543: IFFALSE 8742
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8545: LD_ADDR_VAR 0 3
8549: PUSH
8550: LD_INT 10
8552: PUSH
8553: LD_INT 20
8555: PUSH
8556: LD_INT 30
8558: PUSH
8559: LD_INT 40
8561: PUSH
8562: LD_INT 50
8564: PUSH
8565: LD_INT 60
8567: PUSH
8568: LD_INT 70
8570: PUSH
8571: LD_INT 80
8573: PUSH
8574: LD_INT 90
8576: PUSH
8577: LD_INT 100
8579: PUSH
8580: LD_INT 110
8582: PUSH
8583: LD_INT 120
8585: PUSH
8586: LD_INT 130
8588: PUSH
8589: LD_INT 140
8591: PUSH
8592: LD_INT 150
8594: PUSH
8595: EMPTY
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: LIST
8611: PUSH
8612: LD_INT 1
8614: PPUSH
8615: LD_INT 15
8617: PPUSH
8618: CALL_OW 12
8622: ARRAY
8623: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8624: LD_ADDR_VAR 0 4
8628: PUSH
8629: LD_INT 10
8631: PUSH
8632: LD_INT 20
8634: PUSH
8635: LD_INT 30
8637: PUSH
8638: LD_INT 40
8640: PUSH
8641: LD_INT 50
8643: PUSH
8644: LD_INT 60
8646: PUSH
8647: LD_INT 70
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 90
8655: PUSH
8656: LD_INT 100
8658: PUSH
8659: LD_INT 110
8661: PUSH
8662: LD_INT 120
8664: PUSH
8665: LD_INT 130
8667: PUSH
8668: LD_INT 140
8670: PUSH
8671: LD_INT 150
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: LIST
8680: LIST
8681: LIST
8682: LIST
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 1
8693: PPUSH
8694: LD_INT 15
8696: PPUSH
8697: CALL_OW 12
8701: ARRAY
8702: ST_TO_ADDR
// if ValidHex ( x , y ) then
8703: LD_VAR 0 3
8707: PPUSH
8708: LD_VAR 0 4
8712: PPUSH
8713: CALL_OW 488
8717: IFFALSE 8740
// begin result := [ x , y ] ;
8719: LD_ADDR_VAR 0 1
8723: PUSH
8724: LD_VAR 0 3
8728: PUSH
8729: LD_VAR 0 4
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: ST_TO_ADDR
// break ;
8738: GO 8742
// end ; end ;
8740: GO 8542
8742: POP
8743: POP
// if result then
8744: LD_VAR 0 1
8748: IFFALSE 8808
// begin ToLua ( playSibBomb() ) ;
8750: LD_STRING playSibBomb()
8752: PPUSH
8753: CALL_OW 559
// wait ( 0 0$14 ) ;
8757: LD_INT 490
8759: PPUSH
8760: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
8764: LD_VAR 0 1
8768: PUSH
8769: LD_INT 1
8771: ARRAY
8772: PPUSH
8773: LD_VAR 0 1
8777: PUSH
8778: LD_INT 2
8780: ARRAY
8781: PPUSH
8782: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
8786: LD_VAR 0 1
8790: PUSH
8791: LD_INT 1
8793: ARRAY
8794: PPUSH
8795: LD_VAR 0 1
8799: PUSH
8800: LD_INT 2
8802: ARRAY
8803: PPUSH
8804: CALL_OW 429
// end ; end ;
8808: LD_VAR 0 1
8812: RET
// every 0 0$1 trigger StreamModeActive and sReset do
8813: LD_EXP 8
8817: PUSH
8818: LD_EXP 30
8822: AND
8823: IFFALSE 8835
8825: GO 8827
8827: DISABLE
// YouLost (  ) ;
8828: LD_STRING 
8830: PPUSH
8831: CALL_OW 104
8835: END
// every 0 0$1 trigger StreamModeActive and sFog do
8836: LD_EXP 8
8840: PUSH
8841: LD_EXP 29
8845: AND
8846: IFFALSE 8860
8848: GO 8850
8850: DISABLE
// FogOff ( your_side ) ;
8851: LD_OWVAR 2
8855: PPUSH
8856: CALL_OW 344
8860: END
// every 0 0$1 trigger StreamModeActive and sSun do
8861: LD_EXP 8
8865: PUSH
8866: LD_EXP 31
8870: AND
8871: IFFALSE 8899
8873: GO 8875
8875: DISABLE
// begin solar_recharge_percent := 0 ;
8876: LD_ADDR_OWVAR 79
8880: PUSH
8881: LD_INT 0
8883: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8884: LD_INT 10500
8886: PPUSH
8887: CALL_OW 67
// solar_recharge_percent := 100 ;
8891: LD_ADDR_OWVAR 79
8895: PUSH
8896: LD_INT 100
8898: ST_TO_ADDR
// end ;
8899: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
8900: LD_EXP 8
8904: PUSH
8905: LD_EXP 32
8909: AND
8910: IFFALSE 9149
8912: GO 8914
8914: DISABLE
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
// begin tmp := [ ] ;
8920: LD_ADDR_VAR 0 3
8924: PUSH
8925: EMPTY
8926: ST_TO_ADDR
// for i := 1 to 6 do
8927: LD_ADDR_VAR 0 1
8931: PUSH
8932: DOUBLE
8933: LD_INT 1
8935: DEC
8936: ST_TO_ADDR
8937: LD_INT 6
8939: PUSH
8940: FOR_TO
8941: IFFALSE 9046
// begin uc_nation := nation_nature ;
8943: LD_ADDR_OWVAR 21
8947: PUSH
8948: LD_INT 0
8950: ST_TO_ADDR
// uc_side := 0 ;
8951: LD_ADDR_OWVAR 20
8955: PUSH
8956: LD_INT 0
8958: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8959: LD_ADDR_OWVAR 29
8963: PUSH
8964: LD_INT 12
8966: PUSH
8967: LD_INT 12
8969: PUSH
8970: EMPTY
8971: LIST
8972: LIST
8973: ST_TO_ADDR
// hc_agressivity := 20 ;
8974: LD_ADDR_OWVAR 35
8978: PUSH
8979: LD_INT 20
8981: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
8982: LD_ADDR_OWVAR 28
8986: PUSH
8987: LD_INT 17
8989: ST_TO_ADDR
// hc_gallery :=  ;
8990: LD_ADDR_OWVAR 33
8994: PUSH
8995: LD_STRING 
8997: ST_TO_ADDR
// hc_name :=  ;
8998: LD_ADDR_OWVAR 26
9002: PUSH
9003: LD_STRING 
9005: ST_TO_ADDR
// un := CreateHuman ;
9006: LD_ADDR_VAR 0 2
9010: PUSH
9011: CALL_OW 44
9015: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9016: LD_VAR 0 2
9020: PPUSH
9021: LD_INT 1
9023: PPUSH
9024: CALL_OW 51
// tmp := tmp ^ un ;
9028: LD_ADDR_VAR 0 3
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_VAR 0 2
9042: ADD
9043: ST_TO_ADDR
// end ;
9044: GO 8940
9046: POP
9047: POP
// repeat wait ( 0 0$1 ) ;
9048: LD_INT 35
9050: PPUSH
9051: CALL_OW 67
// for un in tmp do
9055: LD_ADDR_VAR 0 2
9059: PUSH
9060: LD_VAR 0 3
9064: PUSH
9065: FOR_IN
9066: IFFALSE 9140
// begin if IsDead ( un ) then
9068: LD_VAR 0 2
9072: PPUSH
9073: CALL_OW 301
9077: IFFALSE 9097
// begin tmp := tmp diff un ;
9079: LD_ADDR_VAR 0 3
9083: PUSH
9084: LD_VAR 0 3
9088: PUSH
9089: LD_VAR 0 2
9093: DIFF
9094: ST_TO_ADDR
// continue ;
9095: GO 9065
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9097: LD_VAR 0 2
9101: PPUSH
9102: LD_INT 3
9104: PUSH
9105: LD_INT 22
9107: PUSH
9108: LD_INT 0
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: PPUSH
9119: CALL_OW 69
9123: PPUSH
9124: LD_VAR 0 2
9128: PPUSH
9129: CALL_OW 74
9133: PPUSH
9134: CALL_OW 115
// end ;
9138: GO 9065
9140: POP
9141: POP
// until not tmp ;
9142: LD_VAR 0 3
9146: NOT
9147: IFFALSE 9048
// end ;
9149: PPOPN 3
9151: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9152: LD_EXP 8
9156: PUSH
9157: LD_EXP 33
9161: AND
9162: IFFALSE 9216
9164: GO 9166
9166: DISABLE
// begin ToLua ( displayTroll(); ) ;
9167: LD_STRING displayTroll();
9169: PPUSH
9170: CALL_OW 559
// wait ( 3 3$00 ) ;
9174: LD_INT 6300
9176: PPUSH
9177: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9181: LD_STRING hideTroll();
9183: PPUSH
9184: CALL_OW 559
// wait ( 1 1$00 ) ;
9188: LD_INT 2100
9190: PPUSH
9191: CALL_OW 67
// ToLua ( displayTroll(); ) ;
9195: LD_STRING displayTroll();
9197: PPUSH
9198: CALL_OW 559
// wait ( 1 1$00 ) ;
9202: LD_INT 2100
9204: PPUSH
9205: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9209: LD_STRING hideTroll();
9211: PPUSH
9212: CALL_OW 559
// end ;
9216: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9217: LD_EXP 8
9221: PUSH
9222: LD_EXP 34
9226: AND
9227: IFFALSE 9290
9229: GO 9231
9231: DISABLE
9232: LD_INT 0
9234: PPUSH
// begin p := 0 ;
9235: LD_ADDR_VAR 0 1
9239: PUSH
9240: LD_INT 0
9242: ST_TO_ADDR
// repeat game_speed := 1 ;
9243: LD_ADDR_OWVAR 65
9247: PUSH
9248: LD_INT 1
9250: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// p := p + 1 ;
9258: LD_ADDR_VAR 0 1
9262: PUSH
9263: LD_VAR 0 1
9267: PUSH
9268: LD_INT 1
9270: PLUS
9271: ST_TO_ADDR
// until p >= 60 ;
9272: LD_VAR 0 1
9276: PUSH
9277: LD_INT 60
9279: GREATEREQUAL
9280: IFFALSE 9243
// game_speed := 4 ;
9282: LD_ADDR_OWVAR 65
9286: PUSH
9287: LD_INT 4
9289: ST_TO_ADDR
// end ;
9290: PPOPN 1
9292: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9293: LD_EXP 8
9297: PUSH
9298: LD_EXP 35
9302: AND
9303: IFFALSE 9449
9305: GO 9307
9307: DISABLE
9308: LD_INT 0
9310: PPUSH
9311: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9312: LD_ADDR_VAR 0 1
9316: PUSH
9317: LD_INT 22
9319: PUSH
9320: LD_OWVAR 2
9324: PUSH
9325: EMPTY
9326: LIST
9327: LIST
9328: PUSH
9329: LD_INT 2
9331: PUSH
9332: LD_INT 30
9334: PUSH
9335: LD_INT 0
9337: PUSH
9338: EMPTY
9339: LIST
9340: LIST
9341: PUSH
9342: LD_INT 30
9344: PUSH
9345: LD_INT 1
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: LIST
9356: PUSH
9357: EMPTY
9358: LIST
9359: LIST
9360: PPUSH
9361: CALL_OW 69
9365: ST_TO_ADDR
// if not depot then
9366: LD_VAR 0 1
9370: NOT
9371: IFFALSE 9375
// exit ;
9373: GO 9449
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9375: LD_ADDR_VAR 0 2
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 1
9387: PPUSH
9388: LD_VAR 0 1
9392: PPUSH
9393: CALL_OW 12
9397: ARRAY
9398: PPUSH
9399: CALL_OW 274
9403: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9404: LD_VAR 0 2
9408: PPUSH
9409: LD_INT 1
9411: PPUSH
9412: LD_INT 0
9414: PPUSH
9415: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9419: LD_VAR 0 2
9423: PPUSH
9424: LD_INT 2
9426: PPUSH
9427: LD_INT 0
9429: PPUSH
9430: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9434: LD_VAR 0 2
9438: PPUSH
9439: LD_INT 3
9441: PPUSH
9442: LD_INT 0
9444: PPUSH
9445: CALL_OW 277
// end ;
9449: PPOPN 2
9451: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
9452: LD_EXP 8
9456: PUSH
9457: LD_EXP 36
9461: AND
9462: IFFALSE 9559
9464: GO 9466
9466: DISABLE
9467: LD_INT 0
9469: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9470: LD_ADDR_VAR 0 1
9474: PUSH
9475: LD_INT 22
9477: PUSH
9478: LD_OWVAR 2
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: PUSH
9487: LD_INT 21
9489: PUSH
9490: LD_INT 1
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PUSH
9497: LD_INT 3
9499: PUSH
9500: LD_INT 23
9502: PUSH
9503: LD_INT 0
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: PPUSH
9519: CALL_OW 69
9523: ST_TO_ADDR
// if not tmp then
9524: LD_VAR 0 1
9528: NOT
9529: IFFALSE 9533
// exit ;
9531: GO 9559
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
9533: LD_VAR 0 1
9537: PUSH
9538: LD_INT 1
9540: PPUSH
9541: LD_VAR 0 1
9545: PPUSH
9546: CALL_OW 12
9550: ARRAY
9551: PPUSH
9552: LD_INT 200
9554: PPUSH
9555: CALL_OW 234
// end ;
9559: PPOPN 1
9561: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
9562: LD_EXP 8
9566: PUSH
9567: LD_EXP 37
9571: AND
9572: IFFALSE 9651
9574: GO 9576
9576: DISABLE
9577: LD_INT 0
9579: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
9580: LD_ADDR_VAR 0 1
9584: PUSH
9585: LD_INT 22
9587: PUSH
9588: LD_OWVAR 2
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 21
9599: PUSH
9600: LD_INT 2
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: PPUSH
9611: CALL_OW 69
9615: ST_TO_ADDR
// if not tmp then
9616: LD_VAR 0 1
9620: NOT
9621: IFFALSE 9625
// exit ;
9623: GO 9651
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
9625: LD_VAR 0 1
9629: PUSH
9630: LD_INT 1
9632: PPUSH
9633: LD_VAR 0 1
9637: PPUSH
9638: CALL_OW 12
9642: ARRAY
9643: PPUSH
9644: LD_INT 60
9646: PPUSH
9647: CALL_OW 234
// end ;
9651: PPOPN 1
9653: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9654: LD_EXP 8
9658: PUSH
9659: LD_EXP 38
9663: AND
9664: IFFALSE 9763
9666: GO 9668
9668: DISABLE
9669: LD_INT 0
9671: PPUSH
9672: PPUSH
// begin enable ;
9673: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9674: LD_ADDR_VAR 0 1
9678: PUSH
9679: LD_INT 22
9681: PUSH
9682: LD_OWVAR 2
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: LD_INT 61
9693: PUSH
9694: EMPTY
9695: LIST
9696: PUSH
9697: LD_INT 33
9699: PUSH
9700: LD_INT 2
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PPUSH
9712: CALL_OW 69
9716: ST_TO_ADDR
// if not tmp then
9717: LD_VAR 0 1
9721: NOT
9722: IFFALSE 9726
// exit ;
9724: GO 9763
// for i in tmp do
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_VAR 0 1
9735: PUSH
9736: FOR_IN
9737: IFFALSE 9761
// if IsControledBy ( i ) then
9739: LD_VAR 0 2
9743: PPUSH
9744: CALL_OW 312
9748: IFFALSE 9759
// ComUnlink ( i ) ;
9750: LD_VAR 0 2
9754: PPUSH
9755: CALL_OW 136
9759: GO 9736
9761: POP
9762: POP
// end ;
9763: PPOPN 2
9765: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
9766: LD_EXP 8
9770: PUSH
9771: LD_EXP 39
9775: AND
9776: IFFALSE 9916
9778: GO 9780
9780: DISABLE
9781: LD_INT 0
9783: PPUSH
9784: PPUSH
// begin ToLua ( displayPowell(); ) ;
9785: LD_STRING displayPowell();
9787: PPUSH
9788: CALL_OW 559
// uc_side := 0 ;
9792: LD_ADDR_OWVAR 20
9796: PUSH
9797: LD_INT 0
9799: ST_TO_ADDR
// uc_nation := 2 ;
9800: LD_ADDR_OWVAR 21
9804: PUSH
9805: LD_INT 2
9807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
9808: LD_ADDR_OWVAR 37
9812: PUSH
9813: LD_INT 14
9815: ST_TO_ADDR
// vc_engine := engine_siberite ;
9816: LD_ADDR_OWVAR 39
9820: PUSH
9821: LD_INT 3
9823: ST_TO_ADDR
// vc_control := control_apeman ;
9824: LD_ADDR_OWVAR 38
9828: PUSH
9829: LD_INT 5
9831: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
9832: LD_ADDR_OWVAR 40
9836: PUSH
9837: LD_INT 29
9839: ST_TO_ADDR
// un := CreateVehicle ;
9840: LD_ADDR_VAR 0 2
9844: PUSH
9845: CALL_OW 45
9849: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9850: LD_VAR 0 2
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9862: LD_INT 35
9864: PPUSH
9865: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9869: LD_VAR 0 2
9873: PPUSH
9874: LD_INT 22
9876: PUSH
9877: LD_OWVAR 2
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: PPUSH
9886: CALL_OW 69
9890: PPUSH
9891: LD_VAR 0 2
9895: PPUSH
9896: CALL_OW 74
9900: PPUSH
9901: CALL_OW 115
// until IsDead ( un ) ;
9905: LD_VAR 0 2
9909: PPUSH
9910: CALL_OW 301
9914: IFFALSE 9862
// end ;
9916: PPOPN 2
9918: END
// every 0 0$1 trigger StreamModeActive and sStu do
9919: LD_EXP 8
9923: PUSH
9924: LD_EXP 47
9928: AND
9929: IFFALSE 9945
9931: GO 9933
9933: DISABLE
// begin ToLua ( displayStucuk(); ) ;
9934: LD_STRING displayStucuk();
9936: PPUSH
9937: CALL_OW 559
// ResetFog ;
9941: CALL_OW 335
// end ;
9945: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
9946: LD_EXP 8
9950: PUSH
9951: LD_EXP 40
9955: AND
9956: IFFALSE 10097
9958: GO 9960
9960: DISABLE
9961: LD_INT 0
9963: PPUSH
9964: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9965: LD_ADDR_VAR 0 2
9969: PUSH
9970: LD_INT 22
9972: PUSH
9973: LD_OWVAR 2
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: LD_INT 21
9984: PUSH
9985: LD_INT 1
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: ST_TO_ADDR
// if not tmp then
10001: LD_VAR 0 2
10005: NOT
10006: IFFALSE 10010
// exit ;
10008: GO 10097
// un := tmp [ rand ( 1 , tmp ) ] ;
10010: LD_ADDR_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 1
10022: PPUSH
10023: LD_VAR 0 2
10027: PPUSH
10028: CALL_OW 12
10032: ARRAY
10033: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10034: LD_VAR 0 1
10038: PPUSH
10039: LD_INT 0
10041: PPUSH
10042: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_OWVAR 3
10055: PUSH
10056: LD_VAR 0 1
10060: DIFF
10061: PPUSH
10062: LD_VAR 0 1
10066: PPUSH
10067: CALL_OW 74
10071: PPUSH
10072: CALL_OW 115
// wait ( 0 0$20 ) ;
10076: LD_INT 700
10078: PPUSH
10079: CALL_OW 67
// SetSide ( un , your_side ) ;
10083: LD_VAR 0 1
10087: PPUSH
10088: LD_OWVAR 2
10092: PPUSH
10093: CALL_OW 235
// end ;
10097: PPOPN 2
10099: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10100: LD_EXP 8
10104: PUSH
10105: LD_EXP 41
10109: AND
10110: IFFALSE 10216
10112: GO 10114
10114: DISABLE
10115: LD_INT 0
10117: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10118: LD_ADDR_VAR 0 1
10122: PUSH
10123: LD_INT 22
10125: PUSH
10126: LD_OWVAR 2
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 2
10137: PUSH
10138: LD_INT 30
10140: PUSH
10141: LD_INT 0
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PUSH
10148: LD_INT 30
10150: PUSH
10151: LD_INT 1
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: LIST
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 69
10171: ST_TO_ADDR
// if not depot then
10172: LD_VAR 0 1
10176: NOT
10177: IFFALSE 10181
// exit ;
10179: GO 10216
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
10181: LD_VAR 0 1
10185: PUSH
10186: LD_INT 1
10188: ARRAY
10189: PPUSH
10190: CALL_OW 250
10194: PPUSH
10195: LD_VAR 0 1
10199: PUSH
10200: LD_INT 1
10202: ARRAY
10203: PPUSH
10204: CALL_OW 251
10208: PPUSH
10209: LD_INT 70
10211: PPUSH
10212: CALL_OW 495
// end ;
10216: PPOPN 1
10218: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
10219: LD_EXP 8
10223: PUSH
10224: LD_EXP 42
10228: AND
10229: IFFALSE 10440
10231: GO 10233
10233: DISABLE
10234: LD_INT 0
10236: PPUSH
10237: PPUSH
10238: PPUSH
10239: PPUSH
10240: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10241: LD_ADDR_VAR 0 5
10245: PUSH
10246: LD_INT 22
10248: PUSH
10249: LD_OWVAR 2
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 21
10260: PUSH
10261: LD_INT 1
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PPUSH
10272: CALL_OW 69
10276: ST_TO_ADDR
// if not tmp then
10277: LD_VAR 0 5
10281: NOT
10282: IFFALSE 10286
// exit ;
10284: GO 10440
// for i in tmp do
10286: LD_ADDR_VAR 0 1
10290: PUSH
10291: LD_VAR 0 5
10295: PUSH
10296: FOR_IN
10297: IFFALSE 10438
// begin d := rand ( 0 , 5 ) ;
10299: LD_ADDR_VAR 0 4
10303: PUSH
10304: LD_INT 0
10306: PPUSH
10307: LD_INT 5
10309: PPUSH
10310: CALL_OW 12
10314: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
10315: LD_ADDR_VAR 0 2
10319: PUSH
10320: LD_VAR 0 1
10324: PPUSH
10325: CALL_OW 250
10329: PPUSH
10330: LD_VAR 0 4
10334: PPUSH
10335: LD_INT 3
10337: PPUSH
10338: LD_INT 12
10340: PPUSH
10341: CALL_OW 12
10345: PPUSH
10346: CALL_OW 272
10350: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
10351: LD_ADDR_VAR 0 3
10355: PUSH
10356: LD_VAR 0 1
10360: PPUSH
10361: CALL_OW 251
10365: PPUSH
10366: LD_VAR 0 4
10370: PPUSH
10371: LD_INT 3
10373: PPUSH
10374: LD_INT 12
10376: PPUSH
10377: CALL_OW 12
10381: PPUSH
10382: CALL_OW 273
10386: ST_TO_ADDR
// if ValidHex ( x , y ) then
10387: LD_VAR 0 2
10391: PPUSH
10392: LD_VAR 0 3
10396: PPUSH
10397: CALL_OW 488
10401: IFFALSE 10436
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
10403: LD_VAR 0 1
10407: PPUSH
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 3
10420: PPUSH
10421: LD_INT 6
10423: PPUSH
10424: CALL_OW 12
10428: PPUSH
10429: LD_INT 1
10431: PPUSH
10432: CALL_OW 483
// end ;
10436: GO 10296
10438: POP
10439: POP
// end ;
10440: PPOPN 5
10442: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
10443: LD_EXP 8
10447: PUSH
10448: LD_EXP 43
10452: AND
10453: IFFALSE 10547
10455: GO 10457
10457: DISABLE
10458: LD_INT 0
10460: PPUSH
10461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
10462: LD_ADDR_VAR 0 2
10466: PUSH
10467: LD_INT 22
10469: PUSH
10470: LD_OWVAR 2
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: LD_INT 32
10481: PUSH
10482: LD_INT 1
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 21
10491: PUSH
10492: LD_INT 2
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: PPUSH
10504: CALL_OW 69
10508: ST_TO_ADDR
// if not tmp then
10509: LD_VAR 0 2
10513: NOT
10514: IFFALSE 10518
// exit ;
10516: GO 10547
// for i in tmp do
10518: LD_ADDR_VAR 0 1
10522: PUSH
10523: LD_VAR 0 2
10527: PUSH
10528: FOR_IN
10529: IFFALSE 10545
// SetFuel ( i , 0 ) ;
10531: LD_VAR 0 1
10535: PPUSH
10536: LD_INT 0
10538: PPUSH
10539: CALL_OW 240
10543: GO 10528
10545: POP
10546: POP
// end ;
10547: PPOPN 2
10549: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
10550: LD_EXP 8
10554: PUSH
10555: LD_EXP 44
10559: AND
10560: IFFALSE 10626
10562: GO 10564
10564: DISABLE
10565: LD_INT 0
10567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10568: LD_ADDR_VAR 0 1
10572: PUSH
10573: LD_INT 22
10575: PUSH
10576: LD_OWVAR 2
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: LD_INT 30
10587: PUSH
10588: LD_INT 29
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: PPUSH
10599: CALL_OW 69
10603: ST_TO_ADDR
// if not tmp then
10604: LD_VAR 0 1
10608: NOT
10609: IFFALSE 10613
// exit ;
10611: GO 10626
// DestroyUnit ( tmp [ 1 ] ) ;
10613: LD_VAR 0 1
10617: PUSH
10618: LD_INT 1
10620: ARRAY
10621: PPUSH
10622: CALL_OW 65
// end ;
10626: PPOPN 1
10628: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
10629: LD_EXP 8
10633: PUSH
10634: LD_EXP 46
10638: AND
10639: IFFALSE 10768
10641: GO 10643
10643: DISABLE
10644: LD_INT 0
10646: PPUSH
// begin uc_side := 0 ;
10647: LD_ADDR_OWVAR 20
10651: PUSH
10652: LD_INT 0
10654: ST_TO_ADDR
// uc_nation := nation_arabian ;
10655: LD_ADDR_OWVAR 21
10659: PUSH
10660: LD_INT 2
10662: ST_TO_ADDR
// hc_gallery :=  ;
10663: LD_ADDR_OWVAR 33
10667: PUSH
10668: LD_STRING 
10670: ST_TO_ADDR
// hc_name :=  ;
10671: LD_ADDR_OWVAR 26
10675: PUSH
10676: LD_STRING 
10678: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
10679: LD_INT 1
10681: PPUSH
10682: LD_INT 11
10684: PPUSH
10685: LD_INT 10
10687: PPUSH
10688: CALL_OW 380
// un := CreateHuman ;
10692: LD_ADDR_VAR 0 1
10696: PUSH
10697: CALL_OW 44
10701: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10702: LD_VAR 0 1
10706: PPUSH
10707: LD_INT 1
10709: PPUSH
10710: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10714: LD_INT 35
10716: PPUSH
10717: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10721: LD_VAR 0 1
10725: PPUSH
10726: LD_INT 22
10728: PUSH
10729: LD_OWVAR 2
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 69
10742: PPUSH
10743: LD_VAR 0 1
10747: PPUSH
10748: CALL_OW 74
10752: PPUSH
10753: CALL_OW 115
// until IsDead ( un ) ;
10757: LD_VAR 0 1
10761: PPUSH
10762: CALL_OW 301
10766: IFFALSE 10714
// end ;
10768: PPOPN 1
10770: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
10771: LD_EXP 8
10775: PUSH
10776: LD_EXP 48
10780: AND
10781: IFFALSE 10793
10783: GO 10785
10785: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
10786: LD_STRING earthquake(getX(game), 0, 32)
10788: PPUSH
10789: CALL_OW 559
10793: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
10794: LD_EXP 8
10798: PUSH
10799: LD_EXP 49
10803: AND
10804: IFFALSE 10895
10806: GO 10808
10808: DISABLE
10809: LD_INT 0
10811: PPUSH
// begin enable ;
10812: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
10813: LD_ADDR_VAR 0 1
10817: PUSH
10818: LD_INT 22
10820: PUSH
10821: LD_OWVAR 2
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: PUSH
10830: LD_INT 21
10832: PUSH
10833: LD_INT 2
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PUSH
10840: LD_INT 33
10842: PUSH
10843: LD_INT 3
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: LIST
10854: PPUSH
10855: CALL_OW 69
10859: ST_TO_ADDR
// if not tmp then
10860: LD_VAR 0 1
10864: NOT
10865: IFFALSE 10869
// exit ;
10867: GO 10895
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10869: LD_VAR 0 1
10873: PUSH
10874: LD_INT 1
10876: PPUSH
10877: LD_VAR 0 1
10881: PPUSH
10882: CALL_OW 12
10886: ARRAY
10887: PPUSH
10888: LD_INT 1
10890: PPUSH
10891: CALL_OW 234
// end ;
10895: PPOPN 1
10897: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
10898: LD_EXP 8
10902: PUSH
10903: LD_EXP 50
10907: AND
10908: IFFALSE 11049
10910: GO 10912
10912: DISABLE
10913: LD_INT 0
10915: PPUSH
10916: PPUSH
10917: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_OWVAR 2
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: PUSH
10935: LD_INT 25
10937: PUSH
10938: LD_INT 1
10940: PUSH
10941: EMPTY
10942: LIST
10943: LIST
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: PPUSH
10949: CALL_OW 69
10953: ST_TO_ADDR
// if not tmp then
10954: LD_VAR 0 3
10958: NOT
10959: IFFALSE 10963
// exit ;
10961: GO 11049
// un := tmp [ rand ( 1 , tmp ) ] ;
10963: LD_ADDR_VAR 0 2
10967: PUSH
10968: LD_VAR 0 3
10972: PUSH
10973: LD_INT 1
10975: PPUSH
10976: LD_VAR 0 3
10980: PPUSH
10981: CALL_OW 12
10985: ARRAY
10986: ST_TO_ADDR
// if Crawls ( un ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 318
10996: IFFALSE 11007
// ComWalk ( un ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
11007: LD_VAR 0 2
11011: PPUSH
11012: LD_INT 9
11014: PPUSH
11015: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
11019: LD_INT 28
11021: PPUSH
11022: LD_OWVAR 2
11026: PPUSH
11027: LD_INT 2
11029: PPUSH
11030: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
11034: LD_INT 29
11036: PPUSH
11037: LD_OWVAR 2
11041: PPUSH
11042: LD_INT 2
11044: PPUSH
11045: CALL_OW 322
// end ;
11049: PPOPN 3
11051: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
11052: LD_EXP 8
11056: PUSH
11057: LD_EXP 51
11061: AND
11062: IFFALSE 11173
11064: GO 11066
11066: DISABLE
11067: LD_INT 0
11069: PPUSH
11070: PPUSH
11071: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11072: LD_ADDR_VAR 0 3
11076: PUSH
11077: LD_INT 22
11079: PUSH
11080: LD_OWVAR 2
11084: PUSH
11085: EMPTY
11086: LIST
11087: LIST
11088: PUSH
11089: LD_INT 25
11091: PUSH
11092: LD_INT 1
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: PPUSH
11103: CALL_OW 69
11107: ST_TO_ADDR
// if not tmp then
11108: LD_VAR 0 3
11112: NOT
11113: IFFALSE 11117
// exit ;
11115: GO 11173
// un := tmp [ rand ( 1 , tmp ) ] ;
11117: LD_ADDR_VAR 0 2
11121: PUSH
11122: LD_VAR 0 3
11126: PUSH
11127: LD_INT 1
11129: PPUSH
11130: LD_VAR 0 3
11134: PPUSH
11135: CALL_OW 12
11139: ARRAY
11140: ST_TO_ADDR
// if Crawls ( un ) then
11141: LD_VAR 0 2
11145: PPUSH
11146: CALL_OW 318
11150: IFFALSE 11161
// ComWalk ( un ) ;
11152: LD_VAR 0 2
11156: PPUSH
11157: CALL_OW 138
// SetClass ( un , class_mortar ) ;
11161: LD_VAR 0 2
11165: PPUSH
11166: LD_INT 8
11168: PPUSH
11169: CALL_OW 336
// end ;
11173: PPOPN 3
11175: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
11176: LD_EXP 8
11180: PUSH
11181: LD_EXP 52
11185: AND
11186: IFFALSE 11330
11188: GO 11190
11190: DISABLE
11191: LD_INT 0
11193: PPUSH
11194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
11195: LD_ADDR_VAR 0 2
11199: PUSH
11200: LD_INT 22
11202: PUSH
11203: LD_OWVAR 2
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: LD_INT 21
11214: PUSH
11215: LD_INT 2
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PUSH
11222: LD_INT 2
11224: PUSH
11225: LD_INT 34
11227: PUSH
11228: LD_INT 12
11230: PUSH
11231: EMPTY
11232: LIST
11233: LIST
11234: PUSH
11235: LD_INT 34
11237: PUSH
11238: LD_INT 51
11240: PUSH
11241: EMPTY
11242: LIST
11243: LIST
11244: PUSH
11245: LD_INT 34
11247: PUSH
11248: LD_INT 32
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: PUSH
11261: EMPTY
11262: LIST
11263: LIST
11264: LIST
11265: PPUSH
11266: CALL_OW 69
11270: ST_TO_ADDR
// if not tmp then
11271: LD_VAR 0 2
11275: NOT
11276: IFFALSE 11280
// exit ;
11278: GO 11330
// for i in tmp do
11280: LD_ADDR_VAR 0 1
11284: PUSH
11285: LD_VAR 0 2
11289: PUSH
11290: FOR_IN
11291: IFFALSE 11328
// if GetCargo ( i , mat_artifact ) = 0 then
11293: LD_VAR 0 1
11297: PPUSH
11298: LD_INT 4
11300: PPUSH
11301: CALL_OW 289
11305: PUSH
11306: LD_INT 0
11308: EQUAL
11309: IFFALSE 11326
// SetCargo ( i , mat_siberit , 100 ) ;
11311: LD_VAR 0 1
11315: PPUSH
11316: LD_INT 3
11318: PPUSH
11319: LD_INT 100
11321: PPUSH
11322: CALL_OW 290
11326: GO 11290
11328: POP
11329: POP
// end ;
11330: PPOPN 2
11332: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
11333: LD_EXP 8
11337: PUSH
11338: LD_EXP 53
11342: AND
11343: IFFALSE 11526
11345: GO 11347
11347: DISABLE
11348: LD_INT 0
11350: PPUSH
11351: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
11352: LD_ADDR_VAR 0 2
11356: PUSH
11357: LD_INT 22
11359: PUSH
11360: LD_OWVAR 2
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PPUSH
11369: CALL_OW 69
11373: ST_TO_ADDR
// if not tmp then
11374: LD_VAR 0 2
11378: NOT
11379: IFFALSE 11383
// exit ;
11381: GO 11526
// for i := 1 to 2 do
11383: LD_ADDR_VAR 0 1
11387: PUSH
11388: DOUBLE
11389: LD_INT 1
11391: DEC
11392: ST_TO_ADDR
11393: LD_INT 2
11395: PUSH
11396: FOR_TO
11397: IFFALSE 11524
// begin uc_side := your_side ;
11399: LD_ADDR_OWVAR 20
11403: PUSH
11404: LD_OWVAR 2
11408: ST_TO_ADDR
// uc_nation := nation_american ;
11409: LD_ADDR_OWVAR 21
11413: PUSH
11414: LD_INT 1
11416: ST_TO_ADDR
// vc_chassis := us_morphling ;
11417: LD_ADDR_OWVAR 37
11421: PUSH
11422: LD_INT 5
11424: ST_TO_ADDR
// vc_engine := engine_siberite ;
11425: LD_ADDR_OWVAR 39
11429: PUSH
11430: LD_INT 3
11432: ST_TO_ADDR
// vc_control := control_computer ;
11433: LD_ADDR_OWVAR 38
11437: PUSH
11438: LD_INT 3
11440: ST_TO_ADDR
// vc_weapon := us_double_laser ;
11441: LD_ADDR_OWVAR 40
11445: PUSH
11446: LD_INT 10
11448: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
11449: LD_VAR 0 2
11453: PUSH
11454: LD_INT 1
11456: ARRAY
11457: PPUSH
11458: CALL_OW 310
11462: NOT
11463: IFFALSE 11510
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
11465: CALL_OW 45
11469: PPUSH
11470: LD_VAR 0 2
11474: PUSH
11475: LD_INT 1
11477: ARRAY
11478: PPUSH
11479: CALL_OW 250
11483: PPUSH
11484: LD_VAR 0 2
11488: PUSH
11489: LD_INT 1
11491: ARRAY
11492: PPUSH
11493: CALL_OW 251
11497: PPUSH
11498: LD_INT 12
11500: PPUSH
11501: LD_INT 1
11503: PPUSH
11504: CALL_OW 50
11508: GO 11522
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
11510: CALL_OW 45
11514: PPUSH
11515: LD_INT 1
11517: PPUSH
11518: CALL_OW 51
// end ;
11522: GO 11396
11524: POP
11525: POP
// end ;
11526: PPOPN 2
11528: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
11529: LD_EXP 8
11533: PUSH
11534: LD_EXP 54
11538: AND
11539: IFFALSE 11761
11541: GO 11543
11543: DISABLE
11544: LD_INT 0
11546: PPUSH
11547: PPUSH
11548: PPUSH
11549: PPUSH
11550: PPUSH
11551: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11552: LD_ADDR_VAR 0 6
11556: PUSH
11557: LD_INT 22
11559: PUSH
11560: LD_OWVAR 2
11564: PUSH
11565: EMPTY
11566: LIST
11567: LIST
11568: PUSH
11569: LD_INT 21
11571: PUSH
11572: LD_INT 1
11574: PUSH
11575: EMPTY
11576: LIST
11577: LIST
11578: PUSH
11579: LD_INT 3
11581: PUSH
11582: LD_INT 23
11584: PUSH
11585: LD_INT 0
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: LIST
11600: PPUSH
11601: CALL_OW 69
11605: ST_TO_ADDR
// if not tmp then
11606: LD_VAR 0 6
11610: NOT
11611: IFFALSE 11615
// exit ;
11613: GO 11761
// s1 := rand ( 1 , 4 ) ;
11615: LD_ADDR_VAR 0 2
11619: PUSH
11620: LD_INT 1
11622: PPUSH
11623: LD_INT 4
11625: PPUSH
11626: CALL_OW 12
11630: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
11631: LD_ADDR_VAR 0 4
11635: PUSH
11636: LD_VAR 0 6
11640: PUSH
11641: LD_INT 1
11643: ARRAY
11644: PPUSH
11645: LD_VAR 0 2
11649: PPUSH
11650: CALL_OW 259
11654: ST_TO_ADDR
// if s1 = 1 then
11655: LD_VAR 0 2
11659: PUSH
11660: LD_INT 1
11662: EQUAL
11663: IFFALSE 11683
// s2 := rand ( 2 , 4 ) else
11665: LD_ADDR_VAR 0 3
11669: PUSH
11670: LD_INT 2
11672: PPUSH
11673: LD_INT 4
11675: PPUSH
11676: CALL_OW 12
11680: ST_TO_ADDR
11681: GO 11691
// s2 := 1 ;
11683: LD_ADDR_VAR 0 3
11687: PUSH
11688: LD_INT 1
11690: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
11691: LD_ADDR_VAR 0 5
11695: PUSH
11696: LD_VAR 0 6
11700: PUSH
11701: LD_INT 1
11703: ARRAY
11704: PPUSH
11705: LD_VAR 0 3
11709: PPUSH
11710: CALL_OW 259
11714: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
11715: LD_VAR 0 6
11719: PUSH
11720: LD_INT 1
11722: ARRAY
11723: PPUSH
11724: LD_VAR 0 2
11728: PPUSH
11729: LD_VAR 0 5
11733: PPUSH
11734: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
11738: LD_VAR 0 6
11742: PUSH
11743: LD_INT 1
11745: ARRAY
11746: PPUSH
11747: LD_VAR 0 3
11751: PPUSH
11752: LD_VAR 0 4
11756: PPUSH
11757: CALL_OW 237
// end ;
11761: PPOPN 6
11763: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
11764: LD_EXP 8
11768: PUSH
11769: LD_EXP 55
11773: AND
11774: IFFALSE 11853
11776: GO 11778
11778: DISABLE
11779: LD_INT 0
11781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
11782: LD_ADDR_VAR 0 1
11786: PUSH
11787: LD_INT 22
11789: PUSH
11790: LD_OWVAR 2
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PUSH
11799: LD_INT 30
11801: PUSH
11802: LD_INT 3
11804: PUSH
11805: EMPTY
11806: LIST
11807: LIST
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: PPUSH
11813: CALL_OW 69
11817: ST_TO_ADDR
// if not tmp then
11818: LD_VAR 0 1
11822: NOT
11823: IFFALSE 11827
// exit ;
11825: GO 11853
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11827: LD_VAR 0 1
11831: PUSH
11832: LD_INT 1
11834: PPUSH
11835: LD_VAR 0 1
11839: PPUSH
11840: CALL_OW 12
11844: ARRAY
11845: PPUSH
11846: LD_INT 1
11848: PPUSH
11849: CALL_OW 234
// end ;
11853: PPOPN 1
11855: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
11856: LD_EXP 8
11860: PUSH
11861: LD_EXP 56
11865: AND
11866: IFFALSE 11978
11868: GO 11870
11870: DISABLE
11871: LD_INT 0
11873: PPUSH
11874: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
11875: LD_ADDR_VAR 0 2
11879: PUSH
11880: LD_INT 22
11882: PUSH
11883: LD_OWVAR 2
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: LD_INT 2
11894: PUSH
11895: LD_INT 30
11897: PUSH
11898: LD_INT 27
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: PUSH
11905: LD_INT 30
11907: PUSH
11908: LD_INT 26
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 30
11917: PUSH
11918: LD_INT 28
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: LIST
11929: LIST
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: PPUSH
11935: CALL_OW 69
11939: ST_TO_ADDR
// if not tmp then
11940: LD_VAR 0 2
11944: NOT
11945: IFFALSE 11949
// exit ;
11947: GO 11978
// for i in tmp do
11949: LD_ADDR_VAR 0 1
11953: PUSH
11954: LD_VAR 0 2
11958: PUSH
11959: FOR_IN
11960: IFFALSE 11976
// SetLives ( i , 1 ) ;
11962: LD_VAR 0 1
11966: PPUSH
11967: LD_INT 1
11969: PPUSH
11970: CALL_OW 234
11974: GO 11959
11976: POP
11977: POP
// end ;
11978: PPOPN 2
11980: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
11981: LD_EXP 8
11985: PUSH
11986: LD_EXP 57
11990: AND
11991: IFFALSE 12265
11993: GO 11995
11995: DISABLE
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
12000: PPUSH
// begin i := rand ( 1 , 7 ) ;
12001: LD_ADDR_VAR 0 1
12005: PUSH
12006: LD_INT 1
12008: PPUSH
12009: LD_INT 7
12011: PPUSH
12012: CALL_OW 12
12016: ST_TO_ADDR
// case i of 1 :
12017: LD_VAR 0 1
12021: PUSH
12022: LD_INT 1
12024: DOUBLE
12025: EQUAL
12026: IFTRUE 12030
12028: GO 12040
12030: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
12031: LD_STRING earthquake(getX(game), 0, 32)
12033: PPUSH
12034: CALL_OW 559
12038: GO 12265
12040: LD_INT 2
12042: DOUBLE
12043: EQUAL
12044: IFTRUE 12048
12046: GO 12062
12048: POP
// begin ToLua ( displayStucuk(); ) ;
12049: LD_STRING displayStucuk();
12051: PPUSH
12052: CALL_OW 559
// ResetFog ;
12056: CALL_OW 335
// end ; 3 :
12060: GO 12265
12062: LD_INT 3
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12174
12070: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12071: LD_ADDR_VAR 0 2
12075: PUSH
12076: LD_INT 22
12078: PUSH
12079: LD_OWVAR 2
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: PUSH
12088: LD_INT 25
12090: PUSH
12091: LD_INT 1
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PPUSH
12102: CALL_OW 69
12106: ST_TO_ADDR
// if not tmp then
12107: LD_VAR 0 2
12111: NOT
12112: IFFALSE 12116
// exit ;
12114: GO 12265
// un := tmp [ rand ( 1 , tmp ) ] ;
12116: LD_ADDR_VAR 0 3
12120: PUSH
12121: LD_VAR 0 2
12125: PUSH
12126: LD_INT 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL_OW 12
12138: ARRAY
12139: ST_TO_ADDR
// if Crawls ( un ) then
12140: LD_VAR 0 3
12144: PPUSH
12145: CALL_OW 318
12149: IFFALSE 12160
// ComWalk ( un ) ;
12151: LD_VAR 0 3
12155: PPUSH
12156: CALL_OW 138
// SetClass ( un , class_mortar ) ;
12160: LD_VAR 0 3
12164: PPUSH
12165: LD_INT 8
12167: PPUSH
12168: CALL_OW 336
// end ; 4 :
12172: GO 12265
12174: LD_INT 4
12176: DOUBLE
12177: EQUAL
12178: IFTRUE 12182
12180: GO 12243
12182: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
12183: LD_ADDR_VAR 0 2
12187: PUSH
12188: LD_INT 22
12190: PUSH
12191: LD_OWVAR 2
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: LD_INT 30
12202: PUSH
12203: LD_INT 29
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: PPUSH
12214: CALL_OW 69
12218: ST_TO_ADDR
// if not tmp then
12219: LD_VAR 0 2
12223: NOT
12224: IFFALSE 12228
// exit ;
12226: GO 12265
// DestroyUnit ( tmp [ 1 ] ) ;
12228: LD_VAR 0 2
12232: PUSH
12233: LD_INT 1
12235: ARRAY
12236: PPUSH
12237: CALL_OW 65
// end ; 5 .. 7 :
12241: GO 12265
12243: LD_INT 5
12245: DOUBLE
12246: GREATEREQUAL
12247: IFFALSE 12255
12249: LD_INT 7
12251: DOUBLE
12252: LESSEQUAL
12253: IFTRUE 12257
12255: GO 12264
12257: POP
// StreamSibBomb ; end ;
12258: CALL 8515 0 0
12262: GO 12265
12264: POP
// end ;
12265: PPOPN 3
12267: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
12268: LD_EXP 8
12272: PUSH
12273: LD_EXP 58
12277: AND
12278: IFFALSE 12434
12280: GO 12282
12282: DISABLE
12283: LD_INT 0
12285: PPUSH
12286: PPUSH
12287: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
12288: LD_ADDR_VAR 0 2
12292: PUSH
12293: LD_INT 81
12295: PUSH
12296: LD_OWVAR 2
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 2
12307: PUSH
12308: LD_INT 21
12310: PUSH
12311: LD_INT 1
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 21
12320: PUSH
12321: LD_INT 2
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: LIST
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PPUSH
12337: CALL_OW 69
12341: ST_TO_ADDR
// if not tmp then
12342: LD_VAR 0 2
12346: NOT
12347: IFFALSE 12351
// exit ;
12349: GO 12434
// p := 0 ;
12351: LD_ADDR_VAR 0 3
12355: PUSH
12356: LD_INT 0
12358: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12359: LD_INT 35
12361: PPUSH
12362: CALL_OW 67
// p := p + 1 ;
12366: LD_ADDR_VAR 0 3
12370: PUSH
12371: LD_VAR 0 3
12375: PUSH
12376: LD_INT 1
12378: PLUS
12379: ST_TO_ADDR
// for i in tmp do
12380: LD_ADDR_VAR 0 1
12384: PUSH
12385: LD_VAR 0 2
12389: PUSH
12390: FOR_IN
12391: IFFALSE 12422
// if GetLives ( i ) < 1000 then
12393: LD_VAR 0 1
12397: PPUSH
12398: CALL_OW 256
12402: PUSH
12403: LD_INT 1000
12405: LESS
12406: IFFALSE 12420
// SetLives ( i , 1000 ) ;
12408: LD_VAR 0 1
12412: PPUSH
12413: LD_INT 1000
12415: PPUSH
12416: CALL_OW 234
12420: GO 12390
12422: POP
12423: POP
// until p > 20 ;
12424: LD_VAR 0 3
12428: PUSH
12429: LD_INT 20
12431: GREATER
12432: IFFALSE 12359
// end ;
12434: PPOPN 3
12436: END
// every 0 0$1 trigger StreamModeActive and sTime do
12437: LD_EXP 8
12441: PUSH
12442: LD_EXP 59
12446: AND
12447: IFFALSE 12482
12449: GO 12451
12451: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
12452: LD_INT 28
12454: PPUSH
12455: LD_OWVAR 2
12459: PPUSH
12460: LD_INT 2
12462: PPUSH
12463: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
12467: LD_INT 30
12469: PPUSH
12470: LD_OWVAR 2
12474: PPUSH
12475: LD_INT 2
12477: PPUSH
12478: CALL_OW 322
// end ;
12482: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
12483: LD_EXP 8
12487: PUSH
12488: LD_EXP 60
12492: AND
12493: IFFALSE 12614
12495: GO 12497
12497: DISABLE
12498: LD_INT 0
12500: PPUSH
12501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12502: LD_ADDR_VAR 0 2
12506: PUSH
12507: LD_INT 22
12509: PUSH
12510: LD_OWVAR 2
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: PUSH
12519: LD_INT 21
12521: PUSH
12522: LD_INT 1
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PUSH
12529: LD_INT 3
12531: PUSH
12532: LD_INT 23
12534: PUSH
12535: LD_INT 0
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: LIST
12550: PPUSH
12551: CALL_OW 69
12555: ST_TO_ADDR
// if not tmp then
12556: LD_VAR 0 2
12560: NOT
12561: IFFALSE 12565
// exit ;
12563: GO 12614
// for i in tmp do
12565: LD_ADDR_VAR 0 1
12569: PUSH
12570: LD_VAR 0 2
12574: PUSH
12575: FOR_IN
12576: IFFALSE 12612
// begin if Crawls ( i ) then
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 318
12587: IFFALSE 12598
// ComWalk ( i ) ;
12589: LD_VAR 0 1
12593: PPUSH
12594: CALL_OW 138
// SetClass ( i , 2 ) ;
12598: LD_VAR 0 1
12602: PPUSH
12603: LD_INT 2
12605: PPUSH
12606: CALL_OW 336
// end ;
12610: GO 12575
12612: POP
12613: POP
// end ;
12614: PPOPN 2
12616: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
12617: LD_EXP 8
12621: PUSH
12622: LD_EXP 61
12626: AND
12627: IFFALSE 12908
12629: GO 12631
12631: DISABLE
12632: LD_INT 0
12634: PPUSH
12635: PPUSH
12636: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
12637: LD_OWVAR 2
12641: PPUSH
12642: LD_INT 9
12644: PPUSH
12645: LD_INT 1
12647: PPUSH
12648: LD_INT 1
12650: PPUSH
12651: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
12655: LD_INT 9
12657: PPUSH
12658: LD_OWVAR 2
12662: PPUSH
12663: CALL_OW 343
// uc_side := 9 ;
12667: LD_ADDR_OWVAR 20
12671: PUSH
12672: LD_INT 9
12674: ST_TO_ADDR
// uc_nation := 2 ;
12675: LD_ADDR_OWVAR 21
12679: PUSH
12680: LD_INT 2
12682: ST_TO_ADDR
// hc_name := Dark Warrior ;
12683: LD_ADDR_OWVAR 26
12687: PUSH
12688: LD_STRING Dark Warrior
12690: ST_TO_ADDR
// hc_gallery :=  ;
12691: LD_ADDR_OWVAR 33
12695: PUSH
12696: LD_STRING 
12698: ST_TO_ADDR
// hc_noskilllimit := true ;
12699: LD_ADDR_OWVAR 76
12703: PUSH
12704: LD_INT 1
12706: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
12707: LD_ADDR_OWVAR 31
12711: PUSH
12712: LD_INT 30
12714: PUSH
12715: LD_INT 30
12717: PUSH
12718: LD_INT 30
12720: PUSH
12721: LD_INT 30
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: ST_TO_ADDR
// un := CreateHuman ;
12730: LD_ADDR_VAR 0 3
12734: PUSH
12735: CALL_OW 44
12739: ST_TO_ADDR
// hc_noskilllimit := false ;
12740: LD_ADDR_OWVAR 76
12744: PUSH
12745: LD_INT 0
12747: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12748: LD_VAR 0 3
12752: PPUSH
12753: LD_INT 1
12755: PPUSH
12756: CALL_OW 51
// p := 0 ;
12760: LD_ADDR_VAR 0 2
12764: PUSH
12765: LD_INT 0
12767: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12768: LD_INT 35
12770: PPUSH
12771: CALL_OW 67
// p := p + 1 ;
12775: LD_ADDR_VAR 0 2
12779: PUSH
12780: LD_VAR 0 2
12784: PUSH
12785: LD_INT 1
12787: PLUS
12788: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
12789: LD_VAR 0 3
12793: PPUSH
12794: CALL_OW 256
12798: PUSH
12799: LD_INT 1000
12801: LESS
12802: IFFALSE 12816
// SetLives ( un , 1000 ) ;
12804: LD_VAR 0 3
12808: PPUSH
12809: LD_INT 1000
12811: PPUSH
12812: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
12816: LD_VAR 0 3
12820: PPUSH
12821: LD_INT 81
12823: PUSH
12824: LD_OWVAR 2
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: PUSH
12833: LD_INT 91
12835: PUSH
12836: LD_VAR 0 3
12840: PUSH
12841: LD_INT 30
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: LIST
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PPUSH
12853: CALL_OW 69
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 74
12867: PPUSH
12868: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
12872: LD_VAR 0 2
12876: PUSH
12877: LD_INT 60
12879: GREATER
12880: PUSH
12881: LD_VAR 0 3
12885: PPUSH
12886: CALL_OW 301
12890: OR
12891: IFFALSE 12768
// if un then
12893: LD_VAR 0 3
12897: IFFALSE 12908
// RemoveUnit ( un ) ;
12899: LD_VAR 0 3
12903: PPUSH
12904: CALL_OW 64
// end ;
12908: PPOPN 3
12910: END
