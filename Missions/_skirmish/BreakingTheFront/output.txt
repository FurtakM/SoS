// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 557 0 0
// SetDiplomacy ;
  42: CALL 769 0 0
// PrepareGame ;
  46: CALL 851 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := false ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 1 trigger cratesSpawns and game and GameType = 1 do
 229: LD_EXP 19
 233: PUSH
 234: LD_EXP 3
 238: AND
 239: PUSH
 240: LD_EXP 2
 244: PUSH
 245: LD_INT 1
 247: EQUAL
 248: AND
 249: IFFALSE 310
 251: GO 253
 253: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 254: LD_EXP 19
 258: PUSH
 259: LD_INT 1
 261: ARRAY
 262: PUSH
 263: LD_INT 1
 265: ARRAY
 266: PPUSH
 267: LD_EXP 19
 271: PUSH
 272: LD_INT 1
 274: ARRAY
 275: PUSH
 276: LD_INT 2
 278: ARRAY
 279: PPUSH
 280: LD_EXP 19
 284: PUSH
 285: LD_INT 1
 287: ARRAY
 288: PUSH
 289: LD_INT 3
 291: ARRAY
 292: PPUSH
 293: LD_EXP 19
 297: PUSH
 298: LD_INT 1
 300: ARRAY
 301: PUSH
 302: LD_INT 4
 304: ARRAY
 305: PPUSH
 306: CALL 56854 0 4
 310: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 311: LD_EXP 19
 315: PUSH
 316: LD_EXP 3
 320: AND
 321: PUSH
 322: LD_EXP 2
 326: PUSH
 327: LD_INT 1
 329: EQUAL
 330: AND
 331: IFFALSE 392
 333: GO 335
 335: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 336: LD_EXP 19
 340: PUSH
 341: LD_INT 2
 343: ARRAY
 344: PUSH
 345: LD_INT 1
 347: ARRAY
 348: PPUSH
 349: LD_EXP 19
 353: PUSH
 354: LD_INT 2
 356: ARRAY
 357: PUSH
 358: LD_INT 2
 360: ARRAY
 361: PPUSH
 362: LD_EXP 19
 366: PUSH
 367: LD_INT 2
 369: ARRAY
 370: PUSH
 371: LD_INT 3
 373: ARRAY
 374: PPUSH
 375: LD_EXP 19
 379: PUSH
 380: LD_INT 2
 382: ARRAY
 383: PUSH
 384: LD_INT 4
 386: ARRAY
 387: PPUSH
 388: CALL 56854 0 4
 392: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 393: LD_EXP 19
 397: PUSH
 398: LD_EXP 3
 402: AND
 403: PUSH
 404: LD_EXP 2
 408: PUSH
 409: LD_INT 1
 411: EQUAL
 412: AND
 413: IFFALSE 474
 415: GO 417
 417: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 418: LD_EXP 19
 422: PUSH
 423: LD_INT 3
 425: ARRAY
 426: PUSH
 427: LD_INT 1
 429: ARRAY
 430: PPUSH
 431: LD_EXP 19
 435: PUSH
 436: LD_INT 3
 438: ARRAY
 439: PUSH
 440: LD_INT 2
 442: ARRAY
 443: PPUSH
 444: LD_EXP 19
 448: PUSH
 449: LD_INT 3
 451: ARRAY
 452: PUSH
 453: LD_INT 3
 455: ARRAY
 456: PPUSH
 457: LD_EXP 19
 461: PUSH
 462: LD_INT 3
 464: ARRAY
 465: PUSH
 466: LD_INT 4
 468: ARRAY
 469: PPUSH
 470: CALL 56854 0 4
 474: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 475: LD_EXP 19
 479: PUSH
 480: LD_EXP 3
 484: AND
 485: PUSH
 486: LD_EXP 2
 490: PUSH
 491: LD_INT 1
 493: EQUAL
 494: AND
 495: IFFALSE 556
 497: GO 499
 499: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 500: LD_EXP 19
 504: PUSH
 505: LD_INT 4
 507: ARRAY
 508: PUSH
 509: LD_INT 1
 511: ARRAY
 512: PPUSH
 513: LD_EXP 19
 517: PUSH
 518: LD_INT 4
 520: ARRAY
 521: PUSH
 522: LD_INT 2
 524: ARRAY
 525: PPUSH
 526: LD_EXP 19
 530: PUSH
 531: LD_INT 4
 533: ARRAY
 534: PUSH
 535: LD_INT 3
 537: ARRAY
 538: PPUSH
 539: LD_EXP 19
 543: PUSH
 544: LD_INT 4
 546: ARRAY
 547: PUSH
 548: LD_INT 4
 550: ARRAY
 551: PPUSH
 552: CALL 56854 0 4
 556: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 557: LD_INT 0
 559: PPUSH
 560: PPUSH
 561: PPUSH
 562: PPUSH
 563: PPUSH
// if GameType = 1 then
 564: LD_EXP 2
 568: PUSH
 569: LD_INT 1
 571: EQUAL
 572: IFFALSE 641
// begin ban_techs := [ ] ;
 574: LD_ADDR_VAR 0 4
 578: PUSH
 579: EMPTY
 580: ST_TO_ADDR
// if sibBombAllowed < 2 then
 581: LD_EXP 23
 585: PUSH
 586: LD_INT 2
 588: LESS
 589: IFFALSE 602
// ban_techs := [ tech_sibFiss ] ;
 591: LD_ADDR_VAR 0 4
 595: PUSH
 596: LD_INT 25
 598: PUSH
 599: EMPTY
 600: LIST
 601: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 602: LD_ADDR_VAR 0 5
 606: PUSH
 607: LD_INT 46
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: LD_INT 48
 615: PUSH
 616: LD_INT 49
 618: PUSH
 619: LD_INT 50
 621: PUSH
 622: LD_INT 39
 624: PUSH
 625: LD_INT 69
 627: PUSH
 628: LD_INT 40
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: ST_TO_ADDR
// end ; for i = 1 to 8 do
 641: LD_ADDR_VAR 0 2
 645: PUSH
 646: DOUBLE
 647: LD_INT 1
 649: DEC
 650: ST_TO_ADDR
 651: LD_INT 8
 653: PUSH
 654: FOR_TO
 655: IFFALSE 739
// begin if res_techs then
 657: LD_VAR 0 5
 661: IFFALSE 697
// for j in res_techs do
 663: LD_ADDR_VAR 0 3
 667: PUSH
 668: LD_VAR 0 5
 672: PUSH
 673: FOR_IN
 674: IFFALSE 695
// SetTech ( j , i , state_researched ) ;
 676: LD_VAR 0 3
 680: PPUSH
 681: LD_VAR 0 2
 685: PPUSH
 686: LD_INT 2
 688: PPUSH
 689: CALL_OW 322
 693: GO 673
 695: POP
 696: POP
// if ban_techs then
 697: LD_VAR 0 4
 701: IFFALSE 737
// for j in ban_techs do
 703: LD_ADDR_VAR 0 3
 707: PUSH
 708: LD_VAR 0 4
 712: PUSH
 713: FOR_IN
 714: IFFALSE 735
// SetTech ( j , i , state_disabled ) ;
 716: LD_VAR 0 3
 720: PPUSH
 721: LD_VAR 0 2
 725: PPUSH
 726: LD_INT 0
 728: PPUSH
 729: CALL_OW 322
 733: GO 713
 735: POP
 736: POP
// end ;
 737: GO 654
 739: POP
 740: POP
// if sibBombAllowed = 1 then
 741: LD_EXP 23
 745: PUSH
 746: LD_INT 1
 748: EQUAL
 749: IFFALSE 764
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 751: LD_INT 25
 753: PPUSH
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 1
 759: PPUSH
 760: CALL_OW 322
// end ;
 764: LD_VAR 0 1
 768: RET
// export function SetDiplomacy ; begin
 769: LD_INT 0
 771: PPUSH
// if GameType = 1 then
 772: LD_EXP 2
 776: PUSH
 777: LD_INT 1
 779: EQUAL
 780: IFFALSE 846
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 782: LD_INT 1
 784: PPUSH
 785: LD_INT 4
 787: PPUSH
 788: LD_INT 1
 790: PPUSH
 791: LD_INT 1
 793: PPUSH
 794: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 798: LD_INT 3
 800: PPUSH
 801: LD_INT 6
 803: PPUSH
 804: LD_INT 1
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 814: LD_INT 3
 816: PPUSH
 817: LD_INT 8
 819: PPUSH
 820: LD_INT 1
 822: PPUSH
 823: LD_INT 1
 825: PPUSH
 826: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 830: LD_INT 6
 832: PPUSH
 833: LD_INT 8
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 80
// end ; end ;
 846: LD_VAR 0 1
 850: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 851: LD_INT 0
 853: PPUSH
 854: PPUSH
 855: PPUSH
 856: PPUSH
// if GameType = 1 then
 857: LD_EXP 2
 861: PUSH
 862: LD_INT 1
 864: EQUAL
 865: IFFALSE 1361
// begin game := false ;
 867: LD_ADDR_EXP 3
 871: PUSH
 872: LD_INT 0
 874: ST_TO_ADDR
// your_side := 1 ;
 875: LD_ADDR_OWVAR 2
 879: PUSH
 880: LD_INT 1
 882: ST_TO_ADDR
// mc_amer := 1 ;
 883: LD_ADDR_EXP 5
 887: PUSH
 888: LD_INT 1
 890: ST_TO_ADDR
// mc_leg := 2 ;
 891: LD_ADDR_EXP 6
 895: PUSH
 896: LD_INT 2
 898: ST_TO_ADDR
// mc_rus_1 := 3 ;
 899: LD_ADDR_EXP 7
 903: PUSH
 904: LD_INT 3
 906: ST_TO_ADDR
// mc_rus_2 := 4 ;
 907: LD_ADDR_EXP 8
 911: PUSH
 912: LD_INT 4
 914: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 915: LD_ADDR_EXP 19
 919: PUSH
 920: LD_INT 5
 922: PUSH
 923: LD_INT 1
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 200
 931: PUSH
 932: LD_INT 250
 934: PUSH
 935: LD_INT 300
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_EXP 26
 947: ARRAY
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 13
 957: PUSH
 958: LD_INT 8
 960: PUSH
 961: LD_INT 50
 963: PUSH
 964: LD_INT 500
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: LD_INT 17
 975: PUSH
 976: LD_INT 5
 978: PUSH
 979: LD_INT 50
 981: PUSH
 982: LD_INT 300
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: LIST
 989: LIST
 990: PUSH
 991: LD_INT 18
 993: PUSH
 994: LD_INT 4
 996: PUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: PUSH
1008: LD_EXP 26
1012: ARRAY
1013: PUSH
1014: LD_INT 30
1016: PUSH
1017: LD_INT 300
1019: PUSH
1020: LD_INT 450
1022: PUSH
1023: LD_INT 500
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: PUSH
1031: LD_EXP 26
1035: ARRAY
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1049: LD_ADDR_VAR 0 4
1053: PUSH
1054: LD_INT 190
1056: PUSH
1057: LD_INT 193
1059: PUSH
1060: LD_INT 3
1062: PUSH
1063: EMPTY
1064: LIST
1065: LIST
1066: LIST
1067: PUSH
1068: LD_INT 182
1070: PUSH
1071: LD_INT 117
1073: PUSH
1074: LD_INT 3
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 43
1084: PUSH
1085: LD_INT 2
1087: PUSH
1088: LD_INT 3
1090: PUSH
1091: EMPTY
1092: LIST
1093: LIST
1094: LIST
1095: PUSH
1096: LD_INT 114
1098: PUSH
1099: LD_INT 152
1101: PUSH
1102: LD_INT 2
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 85
1112: PUSH
1113: LD_INT 38
1115: PUSH
1116: LD_INT 2
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: EMPTY
1125: LIST
1126: LIST
1127: LIST
1128: LIST
1129: LIST
1130: ST_TO_ADDR
// for i in sources do
1131: LD_ADDR_VAR 0 2
1135: PUSH
1136: LD_VAR 0 4
1140: PUSH
1141: FOR_IN
1142: IFFALSE 1177
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1144: LD_VAR 0 2
1148: PUSH
1149: LD_INT 1
1151: ARRAY
1152: PPUSH
1153: LD_VAR 0 2
1157: PUSH
1158: LD_INT 2
1160: ARRAY
1161: PPUSH
1162: LD_VAR 0 2
1166: PUSH
1167: LD_INT 3
1169: ARRAY
1170: PPUSH
1171: CALL_OW 62
1175: GO 1141
1177: POP
1178: POP
// disableGlobalTimer := false ;
1179: LD_ADDR_EXP 4
1183: PUSH
1184: LD_INT 0
1186: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1187: LD_ADDR_EXP 15
1191: PUSH
1192: LD_INT 0
1194: PUSH
1195: LD_INT 5
1197: PUSH
1198: LD_INT 6
1200: PUSH
1201: LD_INT 7
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_OWVAR 67
1213: ARRAY
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: ST_TO_ADDR
// ruOutpost := [ ] ;
1219: LD_ADDR_EXP 14
1223: PUSH
1224: EMPTY
1225: ST_TO_ADDR
// staticMines := [ ] ;
1226: LD_ADDR_EXP 16
1230: PUSH
1231: EMPTY
1232: ST_TO_ADDR
// baseCaptured := false ;
1233: LD_ADDR_EXP 17
1237: PUSH
1238: LD_INT 0
1240: ST_TO_ADDR
// legDestCounter := 0 ;
1241: LD_ADDR_EXP 18
1245: PUSH
1246: LD_INT 0
1248: ST_TO_ADDR
// legOfferAccepted := false ;
1249: LD_ADDR_EXP 20
1253: PUSH
1254: LD_INT 0
1256: ST_TO_ADDR
// legChangeSide := false ;
1257: LD_ADDR_EXP 21
1261: PUSH
1262: LD_INT 0
1264: ST_TO_ADDR
// allyDestCounter := 0 ;
1265: LD_ADDR_EXP 22
1269: PUSH
1270: LD_INT 0
1272: ST_TO_ADDR
// outpostEscape := false ;
1273: LD_ADDR_EXP 27
1277: PUSH
1278: LD_INT 0
1280: ST_TO_ADDR
// dialogueMineDetected := false ;
1281: LD_ADDR_EXP 28
1285: PUSH
1286: LD_INT 0
1288: ST_TO_ADDR
// PrepareAmericans ;
1289: CALL 7559 0 0
// PrepareLegion ;
1293: CALL 5493 0 0
// PrepareRussians ;
1297: CALL 2459 0 0
// playerForces := PreparePlayer ;
1301: LD_ADDR_EXP 10
1305: PUSH
1306: CALL 8802 0 0
1310: ST_TO_ADDR
// AnimateTrees ( true ) ;
1311: LD_INT 1
1313: PPUSH
1314: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1318: LD_INT 4
1320: PPUSH
1321: LD_INT 3
1323: PPUSH
1324: LD_INT 8
1326: PPUSH
1327: LD_INT 5
1329: PPUSH
1330: LD_INT 3
1332: PPUSH
1333: LD_INT 1
1335: PPUSH
1336: LD_INT 8
1338: PPUSH
1339: LD_INT 2
1341: PPUSH
1342: LD_INT 1
1344: PPUSH
1345: CALL 54207 0 9
// MC_Start ;
1349: CALL 64790 0 0
// SetAdditionalRussianForces ;
1353: CALL 7228 0 0
// Action ;
1357: CALL 11159 0 0
// end ; end ;
1361: LD_VAR 0 1
1365: RET
// export function CustomInitMacro ; begin
1366: LD_INT 0
1368: PPUSH
// if GameType <> 1 then
1369: LD_EXP 2
1373: PUSH
1374: LD_INT 1
1376: NONEQUAL
1377: IFFALSE 1381
// exit ;
1379: GO 2454
// MC_SetScanArea ( mc_amer , amerBase ) ;
1381: LD_EXP 5
1385: PPUSH
1386: LD_INT 3
1388: PPUSH
1389: CALL 88165 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1393: LD_EXP 5
1397: PPUSH
1398: LD_INT 4
1400: PPUSH
1401: CALL 88109 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1405: LD_EXP 5
1409: PPUSH
1410: LD_INT 11
1412: PUSH
1413: LD_INT 6
1415: PUSH
1416: LD_INT 7
1418: PUSH
1419: LD_INT 9
1421: PUSH
1422: LD_INT 10
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: PPUSH
1432: CALL 87997 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1436: LD_EXP 5
1440: PPUSH
1441: LD_INT 5
1443: PPUSH
1444: CALL 87679 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1448: LD_EXP 5
1452: PPUSH
1453: LD_INT 3
1455: PPUSH
1456: CALL 87410 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1460: LD_EXP 5
1464: PPUSH
1465: LD_INT 4
1467: PPUSH
1468: CALL 87029 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1472: LD_EXP 5
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 2
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 3
1497: PUSH
1498: LD_INT 2
1500: PUSH
1501: LD_INT 2
1503: PUSH
1504: LD_INT 9
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 2
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 2
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 86844 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1559: LD_EXP 5
1563: PPUSH
1564: LD_INT 33
1566: PUSH
1567: LD_INT 114
1569: PUSH
1570: LD_INT 16
1572: PUSH
1573: LD_INT 0
1575: PUSH
1576: EMPTY
1577: LIST
1578: LIST
1579: LIST
1580: LIST
1581: PUSH
1582: LD_INT 32
1584: PUSH
1585: LD_INT 110
1587: PUSH
1588: LD_INT 12
1590: PUSH
1591: LD_INT 0
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PPUSH
1604: CALL 86736 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1608: LD_EXP 5
1612: PPUSH
1613: LD_INT 10
1615: PUSH
1616: LD_INT 15
1618: PUSH
1619: LD_INT 12
1621: PUSH
1622: LD_INT 11
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 87586 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1635: LD_EXP 6
1639: PPUSH
1640: LD_INT 6
1642: PPUSH
1643: CALL 88165 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1647: LD_EXP 6
1651: PPUSH
1652: LD_INT 7
1654: PPUSH
1655: CALL 88109 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1659: LD_EXP 6
1663: PPUSH
1664: LD_INT 30
1666: PUSH
1667: LD_INT 27
1669: PUSH
1670: LD_INT 28
1672: PUSH
1673: LD_INT 25
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: PPUSH
1682: CALL 87997 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1686: LD_EXP 6
1690: PPUSH
1691: LD_INT 17
1693: PPUSH
1694: CALL 87679 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1698: LD_EXP 6
1702: PPUSH
1703: LD_INT 6
1705: PPUSH
1706: CALL 87410 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1710: LD_EXP 6
1714: PPUSH
1715: LD_INT 5
1717: PPUSH
1718: CALL 87029 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1722: LD_EXP 6
1726: PPUSH
1727: LD_INT 10
1729: PPUSH
1730: LD_INT 9
1732: PPUSH
1733: CALL 86507 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1737: LD_EXP 6
1741: PPUSH
1742: LD_INT 4
1744: PUSH
1745: LD_INT 157
1747: PUSH
1748: LD_INT 144
1750: PUSH
1751: LD_INT 0
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: PUSH
1760: LD_INT 32
1762: PUSH
1763: LD_INT 151
1765: PUSH
1766: LD_INT 142
1768: PUSH
1769: LD_INT 0
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 32
1780: PUSH
1781: LD_INT 161
1783: PUSH
1784: LD_INT 144
1786: PUSH
1787: LD_INT 0
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PUSH
1796: LD_INT 32
1798: PUSH
1799: LD_INT 140
1801: PUSH
1802: LD_INT 133
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL 86736 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1824: LD_EXP 6
1828: PPUSH
1829: LD_INT 13
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 1
1837: PUSH
1838: LD_INT 31
1840: PUSH
1841: EMPTY
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: PUSH
1847: LD_INT 13
1849: PUSH
1850: LD_INT 2
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 31
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 13
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 1
1873: PUSH
1874: LD_INT 27
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 13
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 27
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 13
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 27
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: LD_INT 13
1921: PUSH
1922: LD_INT 1
1924: PUSH
1925: LD_INT 2
1927: PUSH
1928: LD_INT 28
1930: PUSH
1931: EMPTY
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: PUSH
1937: LD_INT 13
1939: PUSH
1940: LD_INT 1
1942: PUSH
1943: LD_INT 2
1945: PUSH
1946: LD_INT 28
1948: PUSH
1949: EMPTY
1950: LIST
1951: LIST
1952: LIST
1953: LIST
1954: PUSH
1955: LD_INT 13
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 2
1963: PUSH
1964: LD_INT 32
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 13
1975: PUSH
1976: LD_INT 1
1978: PUSH
1979: LD_INT 2
1981: PUSH
1982: LD_INT 88
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: EMPTY
1992: LIST
1993: LIST
1994: LIST
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: PPUSH
2002: CALL 86844 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2006: LD_INT 165
2008: PPUSH
2009: LD_INT 156
2011: PPUSH
2012: LD_INT 8
2014: PPUSH
2015: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2019: LD_EXP 7
2023: PPUSH
2024: LD_INT 15
2026: PPUSH
2027: CALL 88165 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2031: LD_EXP 7
2035: PPUSH
2036: LD_INT 16
2038: PPUSH
2039: CALL 88109 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2043: LD_EXP 7
2047: PPUSH
2048: LD_INT 43
2050: PUSH
2051: LD_INT 47
2053: PUSH
2054: LD_INT 45
2056: PUSH
2057: LD_INT 49
2059: PUSH
2060: LD_INT 46
2062: PUSH
2063: EMPTY
2064: LIST
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL 87997 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2074: LD_EXP 7
2078: PPUSH
2079: LD_INT 13
2081: PPUSH
2082: CALL 87679 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2086: LD_EXP 7
2090: PPUSH
2091: LD_INT 15
2093: PPUSH
2094: CALL 87410 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2098: LD_EXP 7
2102: PPUSH
2103: LD_INT 5
2105: PPUSH
2106: CALL 87029 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2110: LD_EXP 7
2114: PPUSH
2115: LD_INT 23
2117: PUSH
2118: LD_INT 1
2120: PUSH
2121: LD_INT 3
2123: PUSH
2124: LD_INT 46
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: LIST
2131: LIST
2132: PUSH
2133: LD_INT 23
2135: PUSH
2136: LD_INT 1
2138: PUSH
2139: LD_INT 1
2141: PUSH
2142: LD_INT 46
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PUSH
2151: LD_INT 23
2153: PUSH
2154: LD_INT 1
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: LD_INT 45
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: LIST
2167: LIST
2168: PUSH
2169: LD_INT 23
2171: PUSH
2172: LD_INT 1
2174: PUSH
2175: LD_INT 1
2177: PUSH
2178: LD_INT 47
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 23
2189: PUSH
2190: LD_INT 1
2192: PUSH
2193: LD_INT 3
2195: PUSH
2196: LD_INT 46
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: LIST
2203: LIST
2204: PUSH
2205: LD_INT 21
2207: PUSH
2208: LD_INT 1
2210: PUSH
2211: LD_INT 3
2213: PUSH
2214: LD_INT 51
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: LIST
2222: PUSH
2223: LD_INT 21
2225: PUSH
2226: LD_INT 1
2228: PUSH
2229: LD_INT 3
2231: PUSH
2232: LD_INT 52
2234: PUSH
2235: EMPTY
2236: LIST
2237: LIST
2238: LIST
2239: LIST
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: LIST
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PPUSH
2250: CALL 86844 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2254: LD_EXP 8
2258: PPUSH
2259: LD_INT 11
2261: PPUSH
2262: CALL 88165 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2266: LD_EXP 8
2270: PPUSH
2271: LD_INT 12
2273: PPUSH
2274: CALL 88109 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2278: LD_EXP 8
2282: PPUSH
2283: LD_INT 43
2285: PUSH
2286: LD_INT 47
2288: PUSH
2289: LD_INT 45
2291: PUSH
2292: LD_INT 49
2294: PUSH
2295: LD_INT 46
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: LIST
2302: LIST
2303: LIST
2304: PPUSH
2305: CALL 87997 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2309: LD_EXP 8
2313: PPUSH
2314: LD_INT 13
2316: PPUSH
2317: CALL 87679 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2321: LD_EXP 8
2325: PPUSH
2326: LD_INT 11
2328: PPUSH
2329: CALL 87410 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2333: LD_EXP 8
2337: PPUSH
2338: LD_INT 4
2340: PPUSH
2341: CALL 87029 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2345: LD_EXP 8
2349: PPUSH
2350: LD_INT 115
2352: PUSH
2353: LD_INT 201
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PUSH
2360: EMPTY
2361: LIST
2362: PPUSH
2363: CALL 87735 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2367: LD_EXP 8
2371: PPUSH
2372: LD_INT 24
2374: PUSH
2375: LD_INT 3
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 46
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 24
2392: PUSH
2393: LD_INT 3
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 46
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 24
2410: PUSH
2411: LD_INT 3
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 46
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 24
2428: PUSH
2429: LD_INT 3
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 46
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: LIST
2448: LIST
2449: PPUSH
2450: CALL 86844 0 2
// end ;
2454: LD_VAR 0 1
2458: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
2464: PPUSH
2465: PPUSH
2466: PPUSH
2467: PPUSH
2468: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2469: LD_INT 0
2471: PPUSH
2472: LD_INT 0
2474: PPUSH
2475: LD_INT 3
2477: PPUSH
2478: LD_INT 0
2480: PPUSH
2481: LD_INT 0
2483: PPUSH
2484: LD_INT 0
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: LD_INT 14
2492: PPUSH
2493: LD_INT 0
2495: PPUSH
2496: CALL 54207 0 9
// side := 3 ;
2500: LD_ADDR_VAR 0 5
2504: PUSH
2505: LD_INT 3
2507: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2508: LD_INT 38
2510: PPUSH
2511: LD_VAR 0 5
2515: PPUSH
2516: LD_INT 2
2518: PPUSH
2519: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2523: LD_INT 39
2525: PPUSH
2526: LD_VAR 0 5
2530: PPUSH
2531: LD_INT 2
2533: PPUSH
2534: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2538: LD_INT 34
2540: PPUSH
2541: LD_VAR 0 5
2545: PPUSH
2546: LD_INT 2
2548: PPUSH
2549: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2553: LD_ADDR_VAR 0 4
2557: PUSH
2558: LD_INT 0
2560: PUSH
2561: LD_INT 208
2563: PUSH
2564: LD_INT 163
2566: PUSH
2567: LD_INT 4
2569: PUSH
2570: LD_INT 0
2572: PUSH
2573: LD_INT 0
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: LIST
2580: LIST
2581: LIST
2582: LIST
2583: PUSH
2584: LD_INT 3
2586: PUSH
2587: LD_INT 194
2589: PUSH
2590: LD_INT 161
2592: PUSH
2593: LD_INT 1
2595: PUSH
2596: LD_INT 0
2598: PUSH
2599: LD_INT 0
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: LIST
2606: LIST
2607: LIST
2608: LIST
2609: PUSH
2610: LD_INT 17
2612: PUSH
2613: LD_INT 190
2615: PUSH
2616: LD_INT 161
2618: PUSH
2619: LD_INT 1
2621: PUSH
2622: LD_INT 0
2624: PUSH
2625: LD_INT 0
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: LIST
2632: LIST
2633: LIST
2634: LIST
2635: PUSH
2636: LD_INT 5
2638: PUSH
2639: LD_INT 200
2641: PUSH
2642: LD_INT 145
2644: PUSH
2645: LD_INT 3
2647: PUSH
2648: LD_INT 0
2650: PUSH
2651: LD_INT 0
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: LIST
2658: LIST
2659: LIST
2660: LIST
2661: PUSH
2662: LD_INT 32
2664: PUSH
2665: LD_INT 192
2667: PUSH
2668: LD_INT 144
2670: PUSH
2671: LD_INT 3
2673: PUSH
2674: LD_INT 0
2676: PUSH
2677: LD_INT 0
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: LIST
2684: LIST
2685: LIST
2686: LIST
2687: PUSH
2688: LD_INT 26
2690: PUSH
2691: LD_INT 216
2693: PUSH
2694: LD_INT 172
2696: PUSH
2697: LD_INT 3
2699: PUSH
2700: LD_INT 0
2702: PUSH
2703: LD_INT 0
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: LIST
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: LD_INT 26
2716: PUSH
2717: LD_INT 218
2719: PUSH
2720: LD_INT 176
2722: PUSH
2723: LD_INT 3
2725: PUSH
2726: LD_INT 0
2728: PUSH
2729: LD_INT 0
2731: PUSH
2732: EMPTY
2733: LIST
2734: LIST
2735: LIST
2736: LIST
2737: LIST
2738: LIST
2739: PUSH
2740: LD_INT 29
2742: PUSH
2743: LD_INT 182
2745: PUSH
2746: LD_INT 149
2748: PUSH
2749: LD_INT 3
2751: PUSH
2752: LD_INT 0
2754: PUSH
2755: LD_INT 0
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: LIST
2764: LIST
2765: PUSH
2766: LD_INT 8
2768: PUSH
2769: LD_INT 201
2771: PUSH
2772: LD_INT 171
2774: PUSH
2775: LD_INT 0
2777: PUSH
2778: LD_INT 10
2780: PUSH
2781: LD_INT 11
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: PUSH
2792: LD_INT 32
2794: PUSH
2795: LD_INT 188
2797: PUSH
2798: LD_INT 167
2800: PUSH
2801: LD_INT 0
2803: PUSH
2804: LD_INT 0
2806: PUSH
2807: LD_INT 0
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 32
2820: PUSH
2821: LD_INT 202
2823: PUSH
2824: LD_INT 179
2826: PUSH
2827: LD_INT 0
2829: PUSH
2830: LD_INT 0
2832: PUSH
2833: LD_INT 0
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: LIST
2841: LIST
2842: LIST
2843: PUSH
2844: LD_INT 32
2846: PUSH
2847: LD_INT 209
2849: PUSH
2850: LD_INT 182
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 0
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: PUSH
2870: LD_INT 32
2872: PUSH
2873: LD_INT 220
2875: PUSH
2876: LD_INT 183
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 0
2884: PUSH
2885: LD_INT 0
2887: PUSH
2888: EMPTY
2889: LIST
2890: LIST
2891: LIST
2892: LIST
2893: LIST
2894: LIST
2895: PUSH
2896: LD_INT 32
2898: PUSH
2899: LD_INT 225
2901: PUSH
2902: LD_INT 181
2904: PUSH
2905: LD_INT 5
2907: PUSH
2908: LD_INT 0
2910: PUSH
2911: LD_INT 0
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: LIST
2919: LIST
2920: LIST
2921: PUSH
2922: LD_INT 26
2924: PUSH
2925: LD_INT 220
2927: PUSH
2928: LD_INT 174
2930: PUSH
2931: LD_INT 5
2933: PUSH
2934: LD_INT 0
2936: PUSH
2937: LD_INT 0
2939: PUSH
2940: EMPTY
2941: LIST
2942: LIST
2943: LIST
2944: LIST
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 1
2950: PUSH
2951: LD_INT 84
2953: PUSH
2954: LD_INT 128
2956: PUSH
2957: LD_INT 4
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 3
2976: PUSH
2977: LD_INT 68
2979: PUSH
2980: LD_INT 121
2982: PUSH
2983: LD_INT 1
2985: PUSH
2986: LD_INT 0
2988: PUSH
2989: LD_INT 0
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: PUSH
3000: LD_INT 19
3002: PUSH
3003: LD_INT 72
3005: PUSH
3006: LD_INT 125
3008: PUSH
3009: LD_INT 5
3011: PUSH
3012: LD_INT 0
3014: PUSH
3015: LD_INT 0
3017: PUSH
3018: EMPTY
3019: LIST
3020: LIST
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: PUSH
3026: LD_INT 18
3028: PUSH
3029: LD_INT 68
3031: PUSH
3032: LD_INT 124
3034: PUSH
3035: LD_INT 0
3037: PUSH
3038: LD_INT 0
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 24
3054: PUSH
3055: LD_INT 64
3057: PUSH
3058: LD_INT 121
3060: PUSH
3061: LD_INT 1
3063: PUSH
3064: LD_INT 0
3066: PUSH
3067: LD_INT 0
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_INT 17
3080: PUSH
3081: LD_INT 65
3083: PUSH
3084: LD_INT 118
3086: PUSH
3087: LD_INT 2
3089: PUSH
3090: LD_INT 0
3092: PUSH
3093: LD_INT 0
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 21
3106: PUSH
3107: LD_INT 68
3109: PUSH
3110: LD_INT 117
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: LD_INT 0
3118: PUSH
3119: LD_INT 0
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: LIST
3129: PUSH
3130: LD_INT 8
3132: PUSH
3133: LD_INT 68
3135: PUSH
3136: LD_INT 130
3138: PUSH
3139: LD_INT 1
3141: PUSH
3142: LD_INT 14
3144: PUSH
3145: LD_INT 10
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: PUSH
3156: LD_INT 8
3158: PUSH
3159: LD_INT 67
3161: PUSH
3162: LD_INT 110
3164: PUSH
3165: LD_INT 2
3167: PUSH
3168: LD_INT 11
3170: PUSH
3171: LD_INT 12
3173: PUSH
3174: EMPTY
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: PUSH
3182: LD_INT 28
3184: PUSH
3185: LD_INT 85
3187: PUSH
3188: LD_INT 108
3190: PUSH
3191: LD_INT 2
3193: PUSH
3194: LD_INT 0
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: LIST
3207: PUSH
3208: LD_INT 28
3210: PUSH
3211: LD_INT 85
3213: PUSH
3214: LD_INT 124
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 0
3222: PUSH
3223: LD_INT 0
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PUSH
3234: LD_INT 30
3236: PUSH
3237: LD_INT 97
3239: PUSH
3240: LD_INT 119
3242: PUSH
3243: LD_INT 2
3245: PUSH
3246: LD_INT 0
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: LD_INT 5
3262: PUSH
3263: LD_INT 111
3265: PUSH
3266: LD_INT 138
3268: PUSH
3269: LD_INT 4
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: LD_INT 0
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: LIST
3285: PUSH
3286: LD_INT 33
3288: PUSH
3289: LD_INT 104
3291: PUSH
3292: LD_INT 130
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: LD_INT 0
3300: PUSH
3301: LD_INT 0
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: LIST
3311: PUSH
3312: LD_INT 33
3314: PUSH
3315: LD_INT 110
3317: PUSH
3318: LD_INT 142
3320: PUSH
3321: LD_INT 5
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: LD_INT 0
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: LIST
3337: PUSH
3338: LD_INT 33
3340: PUSH
3341: LD_INT 91
3343: PUSH
3344: LD_INT 131
3346: PUSH
3347: LD_INT 5
3349: PUSH
3350: LD_INT 0
3352: PUSH
3353: LD_INT 0
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: LIST
3360: LIST
3361: LIST
3362: LIST
3363: PUSH
3364: LD_INT 33
3366: PUSH
3367: LD_INT 107
3369: PUSH
3370: LD_INT 157
3372: PUSH
3373: LD_INT 5
3375: PUSH
3376: LD_INT 0
3378: PUSH
3379: LD_INT 0
3381: PUSH
3382: EMPTY
3383: LIST
3384: LIST
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: PUSH
3390: LD_INT 33
3392: PUSH
3393: LD_INT 104
3395: PUSH
3396: LD_INT 160
3398: PUSH
3399: LD_INT 5
3401: PUSH
3402: LD_INT 0
3404: PUSH
3405: LD_INT 0
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 33
3418: PUSH
3419: LD_INT 101
3421: PUSH
3422: LD_INT 162
3424: PUSH
3425: LD_INT 5
3427: PUSH
3428: LD_INT 0
3430: PUSH
3431: LD_INT 0
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: LIST
3441: PUSH
3442: LD_INT 32
3444: PUSH
3445: LD_INT 87
3447: PUSH
3448: LD_INT 157
3450: PUSH
3451: LD_INT 5
3453: PUSH
3454: LD_INT 0
3456: PUSH
3457: LD_INT 0
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: LIST
3467: PUSH
3468: LD_INT 32
3470: PUSH
3471: LD_INT 105
3473: PUSH
3474: LD_INT 158
3476: PUSH
3477: LD_INT 5
3479: PUSH
3480: LD_INT 0
3482: PUSH
3483: LD_INT 0
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: LIST
3493: PUSH
3494: LD_INT 33
3496: PUSH
3497: LD_INT 91
3499: PUSH
3500: LD_INT 118
3502: PUSH
3503: LD_INT 4
3505: PUSH
3506: LD_INT 0
3508: PUSH
3509: LD_INT 0
3511: PUSH
3512: EMPTY
3513: LIST
3514: LIST
3515: LIST
3516: LIST
3517: LIST
3518: LIST
3519: PUSH
3520: LD_INT 33
3522: PUSH
3523: LD_INT 89
3525: PUSH
3526: LD_INT 107
3528: PUSH
3529: LD_INT 4
3531: PUSH
3532: LD_INT 0
3534: PUSH
3535: LD_INT 0
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 5
3548: PUSH
3549: LD_INT 86
3551: PUSH
3552: LD_INT 96
3554: PUSH
3555: LD_INT 3
3557: PUSH
3558: LD_INT 0
3560: PUSH
3561: LD_INT 0
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: LIST
3571: PUSH
3572: LD_INT 33
3574: PUSH
3575: LD_INT 91
3577: PUSH
3578: LD_INT 102
3580: PUSH
3581: LD_INT 4
3583: PUSH
3584: LD_INT 0
3586: PUSH
3587: LD_INT 0
3589: PUSH
3590: EMPTY
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 32
3600: PUSH
3601: LD_INT 80
3603: PUSH
3604: LD_INT 95
3606: PUSH
3607: LD_INT 3
3609: PUSH
3610: LD_INT 0
3612: PUSH
3613: LD_INT 0
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 28
3626: PUSH
3627: LD_INT 77
3629: PUSH
3630: LD_INT 105
3632: PUSH
3633: LD_INT 3
3635: PUSH
3636: LD_INT 0
3638: PUSH
3639: LD_INT 0
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: PUSH
3650: LD_INT 28
3652: PUSH
3653: LD_INT 85
3655: PUSH
3656: LD_INT 113
3658: PUSH
3659: LD_INT 3
3661: PUSH
3662: LD_INT 0
3664: PUSH
3665: LD_INT 0
3667: PUSH
3668: EMPTY
3669: LIST
3670: LIST
3671: LIST
3672: LIST
3673: LIST
3674: LIST
3675: PUSH
3676: LD_INT 28
3678: PUSH
3679: LD_INT 55
3681: PUSH
3682: LD_INT 97
3684: PUSH
3685: LD_INT 3
3687: PUSH
3688: LD_INT 0
3690: PUSH
3691: LD_INT 0
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: LIST
3701: PUSH
3702: LD_INT 28
3704: PUSH
3705: LD_INT 88
3707: PUSH
3708: LD_INT 128
3710: PUSH
3711: LD_INT 3
3713: PUSH
3714: LD_INT 0
3716: PUSH
3717: LD_INT 0
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: LIST
3724: LIST
3725: LIST
3726: LIST
3727: PUSH
3728: LD_INT 32
3730: PUSH
3731: LD_INT 69
3733: PUSH
3734: LD_INT 101
3736: PUSH
3737: LD_INT 2
3739: PUSH
3740: LD_INT 0
3742: PUSH
3743: LD_INT 0
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: LIST
3750: LIST
3751: LIST
3752: LIST
3753: PUSH
3754: LD_INT 1
3756: PUSH
3757: LD_INT 34
3759: PUSH
3760: LD_INT 23
3762: PUSH
3763: LD_INT 4
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: LD_INT 0
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: LIST
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 8
3782: PUSH
3783: LD_INT 25
3785: PUSH
3786: LD_INT 4
3788: PUSH
3789: LD_INT 3
3791: PUSH
3792: LD_INT 11
3794: PUSH
3795: LD_INT 10
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: PUSH
3806: LD_INT 8
3808: PUSH
3809: LD_INT 15
3811: PUSH
3812: LD_INT 4
3814: PUSH
3815: LD_INT 2
3817: PUSH
3818: LD_INT 14
3820: PUSH
3821: LD_INT 12
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: PUSH
3832: LD_INT 29
3834: PUSH
3835: LD_INT 55
3837: PUSH
3838: LD_INT 35
3840: PUSH
3841: LD_INT 2
3843: PUSH
3844: LD_INT 0
3846: PUSH
3847: LD_INT 0
3849: PUSH
3850: EMPTY
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: LIST
3856: LIST
3857: PUSH
3858: LD_INT 29
3860: PUSH
3861: LD_INT 24
3863: PUSH
3864: LD_INT 44
3866: PUSH
3867: LD_INT 2
3869: PUSH
3870: LD_INT 0
3872: PUSH
3873: LD_INT 0
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: PUSH
3884: LD_INT 34
3886: PUSH
3887: LD_INT 34
3889: PUSH
3890: LD_INT 32
3892: PUSH
3893: LD_INT 4
3895: PUSH
3896: LD_INT 0
3898: PUSH
3899: LD_INT 0
3901: PUSH
3902: EMPTY
3903: LIST
3904: LIST
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 3
3912: PUSH
3913: LD_INT 14
3915: PUSH
3916: LD_INT 16
3918: PUSH
3919: LD_INT 1
3921: PUSH
3922: LD_INT 0
3924: PUSH
3925: LD_INT 0
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: LIST
3932: LIST
3933: LIST
3934: LIST
3935: PUSH
3936: LD_INT 24
3938: PUSH
3939: LD_INT 10
3941: PUSH
3942: LD_INT 16
3944: PUSH
3945: LD_INT 1
3947: PUSH
3948: LD_INT 0
3950: PUSH
3951: LD_INT 0
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: LIST
3958: LIST
3959: LIST
3960: LIST
3961: PUSH
3962: LD_INT 21
3964: PUSH
3965: LD_INT 11
3967: PUSH
3968: LD_INT 13
3970: PUSH
3971: LD_INT 2
3973: PUSH
3974: LD_INT 0
3976: PUSH
3977: LD_INT 0
3979: PUSH
3980: EMPTY
3981: LIST
3982: LIST
3983: LIST
3984: LIST
3985: LIST
3986: LIST
3987: PUSH
3988: LD_INT 18
3990: PUSH
3991: LD_INT 14
3993: PUSH
3994: LD_INT 12
3996: PUSH
3997: LD_INT 3
3999: PUSH
4000: LD_INT 0
4002: PUSH
4003: LD_INT 0
4005: PUSH
4006: EMPTY
4007: LIST
4008: LIST
4009: LIST
4010: LIST
4011: LIST
4012: LIST
4013: PUSH
4014: LD_INT 16
4016: PUSH
4017: LD_INT 14
4019: PUSH
4020: LD_INT 19
4022: PUSH
4023: LD_INT 0
4025: PUSH
4026: LD_INT 0
4028: PUSH
4029: LD_INT 0
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 17
4042: PUSH
4043: LD_INT 18
4045: PUSH
4046: LD_INT 20
4048: PUSH
4049: LD_INT 5
4051: PUSH
4052: LD_INT 0
4054: PUSH
4055: LD_INT 0
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: LIST
4062: LIST
4063: LIST
4064: LIST
4065: PUSH
4066: LD_INT 28
4068: PUSH
4069: LD_INT 10
4071: PUSH
4072: LD_INT 5
4074: PUSH
4075: LD_INT 1
4077: PUSH
4078: LD_INT 0
4080: PUSH
4081: LD_INT 0
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: LIST
4089: LIST
4090: LIST
4091: PUSH
4092: LD_INT 28
4094: PUSH
4095: LD_INT 8
4097: PUSH
4098: LD_INT 8
4100: PUSH
4101: LD_INT 1
4103: PUSH
4104: LD_INT 0
4106: PUSH
4107: LD_INT 0
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: LIST
4114: LIST
4115: LIST
4116: LIST
4117: PUSH
4118: LD_INT 26
4120: PUSH
4121: LD_INT 19
4123: PUSH
4124: LD_INT 2
4126: PUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 0
4132: PUSH
4133: LD_INT 0
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 26
4146: PUSH
4147: LD_INT 30
4149: PUSH
4150: LD_INT 2
4152: PUSH
4153: LD_INT 1
4155: PUSH
4156: LD_INT 0
4158: PUSH
4159: LD_INT 0
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: LIST
4166: LIST
4167: LIST
4168: LIST
4169: PUSH
4170: LD_INT 5
4172: PUSH
4173: LD_INT 59
4175: PUSH
4176: LD_INT 20
4178: PUSH
4179: LD_INT 4
4181: PUSH
4182: LD_INT 0
4184: PUSH
4185: LD_INT 0
4187: PUSH
4188: EMPTY
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: LD_INT 32
4198: PUSH
4199: LD_INT 60
4201: PUSH
4202: LD_INT 24
4204: PUSH
4205: LD_INT 4
4207: PUSH
4208: LD_INT 0
4210: PUSH
4211: LD_INT 0
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 32
4224: PUSH
4225: LD_INT 61
4227: PUSH
4228: LD_INT 45
4230: PUSH
4231: LD_INT 5
4233: PUSH
4234: LD_INT 0
4236: PUSH
4237: LD_INT 0
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: LIST
4245: LIST
4246: LIST
4247: PUSH
4248: LD_INT 32
4250: PUSH
4251: LD_INT 52
4253: PUSH
4254: LD_INT 51
4256: PUSH
4257: LD_INT 5
4259: PUSH
4260: LD_INT 0
4262: PUSH
4263: LD_INT 0
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: LIST
4272: LIST
4273: PUSH
4274: LD_INT 33
4276: PUSH
4277: LD_INT 56
4279: PUSH
4280: LD_INT 51
4282: PUSH
4283: LD_INT 5
4285: PUSH
4286: LD_INT 0
4288: PUSH
4289: LD_INT 0
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: LIST
4296: LIST
4297: LIST
4298: LIST
4299: PUSH
4300: LD_INT 33
4302: PUSH
4303: LD_INT 62
4305: PUSH
4306: LD_INT 49
4308: PUSH
4309: LD_INT 5
4311: PUSH
4312: LD_INT 0
4314: PUSH
4315: LD_INT 0
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: LIST
4322: LIST
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 33
4328: PUSH
4329: LD_INT 41
4331: PUSH
4332: LD_INT 47
4334: PUSH
4335: LD_INT 5
4337: PUSH
4338: LD_INT 0
4340: PUSH
4341: LD_INT 0
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: LIST
4348: LIST
4349: LIST
4350: LIST
4351: PUSH
4352: LD_INT 33
4354: PUSH
4355: LD_INT 33
4357: PUSH
4358: LD_INT 52
4360: PUSH
4361: LD_INT 5
4363: PUSH
4364: LD_INT 0
4366: PUSH
4367: LD_INT 0
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: LIST
4375: LIST
4376: LIST
4377: PUSH
4378: LD_INT 5
4380: PUSH
4381: LD_INT 31
4383: PUSH
4384: LD_INT 40
4386: PUSH
4387: LD_INT 0
4389: PUSH
4390: LD_INT 0
4392: PUSH
4393: LD_INT 0
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: LIST
4401: LIST
4402: LIST
4403: PUSH
4404: LD_INT 33
4406: PUSH
4407: LD_INT 65
4409: PUSH
4410: LD_INT 37
4412: PUSH
4413: LD_INT 5
4415: PUSH
4416: LD_INT 0
4418: PUSH
4419: LD_INT 0
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 33
4432: PUSH
4433: LD_INT 63
4435: PUSH
4436: LD_INT 29
4438: PUSH
4439: LD_INT 4
4441: PUSH
4442: LD_INT 0
4444: PUSH
4445: LD_INT 0
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 33
4458: PUSH
4459: LD_INT 54
4461: PUSH
4462: LD_INT 11
4464: PUSH
4465: LD_INT 4
4467: PUSH
4468: LD_INT 0
4470: PUSH
4471: LD_INT 0
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 33
4484: PUSH
4485: LD_INT 56
4487: PUSH
4488: LD_INT 15
4490: PUSH
4491: LD_INT 4
4493: PUSH
4494: LD_INT 0
4496: PUSH
4497: LD_INT 0
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 33
4510: PUSH
4511: LD_INT 51
4513: PUSH
4514: LD_INT 6
4516: PUSH
4517: LD_INT 4
4519: PUSH
4520: LD_INT 0
4522: PUSH
4523: LD_INT 0
4525: PUSH
4526: EMPTY
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: PUSH
4534: LD_INT 26
4536: PUSH
4537: LD_INT 39
4539: PUSH
4540: LD_INT 25
4542: PUSH
4543: LD_INT 0
4545: PUSH
4546: LD_INT 0
4548: PUSH
4549: LD_INT 0
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 26
4562: PUSH
4563: LD_INT 37
4565: PUSH
4566: LD_INT 21
4568: PUSH
4569: LD_INT 0
4571: PUSH
4572: LD_INT 0
4574: PUSH
4575: LD_INT 0
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 32
4588: PUSH
4589: LD_INT 35
4591: PUSH
4592: LD_INT 17
4594: PUSH
4595: LD_INT 4
4597: PUSH
4598: LD_INT 0
4600: PUSH
4601: LD_INT 0
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: PUSH
4612: LD_INT 33
4614: PUSH
4615: LD_INT 35
4617: PUSH
4618: LD_INT 28
4620: PUSH
4621: LD_INT 4
4623: PUSH
4624: LD_INT 0
4626: PUSH
4627: LD_INT 0
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: LIST
4636: LIST
4637: PUSH
4638: LD_INT 33
4640: PUSH
4641: LD_INT 28
4643: PUSH
4644: LD_INT 46
4646: PUSH
4647: LD_INT 5
4649: PUSH
4650: LD_INT 0
4652: PUSH
4653: LD_INT 0
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: PUSH
4664: LD_INT 33
4666: PUSH
4667: LD_INT 31
4669: PUSH
4670: LD_INT 6
4672: PUSH
4673: LD_INT 4
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: LD_INT 0
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: LIST
4689: PUSH
4690: LD_INT 26
4692: PUSH
4693: LD_INT 54
4695: PUSH
4696: LD_INT 38
4698: PUSH
4699: LD_INT 4
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: LIST
4713: LIST
4714: LIST
4715: PUSH
4716: LD_INT 33
4718: PUSH
4719: LD_INT 207
4721: PUSH
4722: LD_INT 167
4724: PUSH
4725: LD_INT 3
4727: PUSH
4728: LD_INT 0
4730: PUSH
4731: LD_INT 0
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: LIST
4738: LIST
4739: LIST
4740: LIST
4741: PUSH
4742: LD_INT 30
4744: PUSH
4745: LD_INT 43
4747: PUSH
4748: LD_INT 2
4750: PUSH
4751: LD_INT 4
4753: PUSH
4754: LD_INT 0
4756: PUSH
4757: LD_INT 0
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: ST_TO_ADDR
// for i in tmp do
4855: LD_ADDR_VAR 0 2
4859: PUSH
4860: LD_VAR 0 4
4864: PUSH
4865: FOR_IN
4866: IFFALSE 5097
// begin uc_side := side ;
4868: LD_ADDR_OWVAR 20
4872: PUSH
4873: LD_VAR 0 5
4877: ST_TO_ADDR
// uc_nation := nation_russian ;
4878: LD_ADDR_OWVAR 21
4882: PUSH
4883: LD_INT 3
4885: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4886: LD_ADDR_OWVAR 42
4890: PUSH
4891: LD_VAR 0 2
4895: PUSH
4896: LD_INT 1
4898: ARRAY
4899: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4900: LD_ADDR_OWVAR 43
4904: PUSH
4905: LD_INT 5
4907: PPUSH
4908: LD_INT 6
4910: PPUSH
4911: CALL_OW 12
4915: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4916: LD_ADDR_OWVAR 44
4920: PUSH
4921: LD_VAR 0 2
4925: PUSH
4926: LD_INT 5
4928: ARRAY
4929: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4930: LD_ADDR_OWVAR 45
4934: PUSH
4935: LD_VAR 0 2
4939: PUSH
4940: LD_INT 6
4942: ARRAY
4943: ST_TO_ADDR
// sr := 0 ;
4944: LD_ADDR_VAR 0 6
4948: PUSH
4949: LD_INT 0
4951: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4952: LD_VAR 0 2
4956: PUSH
4957: LD_INT 1
4959: ARRAY
4960: PUSH
4961: LD_INT 29
4963: EQUAL
4964: IFFALSE 4976
// sr := mat_oil else
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_INT 2
4973: ST_TO_ADDR
4974: GO 4998
// if i [ 1 ] = b_siberite_mine then
4976: LD_VAR 0 2
4980: PUSH
4981: LD_INT 1
4983: ARRAY
4984: PUSH
4985: LD_INT 30
4987: EQUAL
4988: IFFALSE 4998
// sr := mat_siberit ;
4990: LD_ADDR_VAR 0 6
4994: PUSH
4995: LD_INT 3
4997: ST_TO_ADDR
// if sr then
4998: LD_VAR 0 6
5002: IFFALSE 5058
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5004: LD_VAR 0 2
5008: PUSH
5009: LD_INT 2
5011: ARRAY
5012: PPUSH
5013: LD_VAR 0 2
5017: PUSH
5018: LD_INT 3
5020: ARRAY
5021: PPUSH
5022: LD_VAR 0 6
5026: PPUSH
5027: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5031: LD_VAR 0 2
5035: PUSH
5036: LD_INT 2
5038: ARRAY
5039: PPUSH
5040: LD_VAR 0 2
5044: PUSH
5045: LD_INT 3
5047: ARRAY
5048: PPUSH
5049: LD_VAR 0 5
5053: PPUSH
5054: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5058: LD_ADDR_VAR 0 3
5062: PUSH
5063: LD_VAR 0 2
5067: PUSH
5068: LD_INT 2
5070: ARRAY
5071: PPUSH
5072: LD_VAR 0 2
5076: PUSH
5077: LD_INT 3
5079: ARRAY
5080: PPUSH
5081: LD_VAR 0 2
5085: PUSH
5086: LD_INT 4
5088: ARRAY
5089: PPUSH
5090: CALL_OW 47
5094: ST_TO_ADDR
// end ;
5095: GO 4865
5097: POP
5098: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5099: LD_ADDR_VAR 0 7
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_VAR 0 5
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 1
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PPUSH
5130: CALL_OW 69
5134: ST_TO_ADDR
// if not depot then
5135: LD_VAR 0 7
5139: NOT
5140: IFFALSE 5144
// exit ;
5142: GO 5488
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5144: LD_ADDR_VAR 0 8
5148: PUSH
5149: LD_INT 84
5151: PPUSH
5152: LD_INT 128
5154: PPUSH
5155: CALL_OW 428
5159: PPUSH
5160: LD_INT 15
5162: PPUSH
5163: LD_INT 0
5165: PPUSH
5166: LD_INT 6
5168: PUSH
5169: LD_INT 7
5171: PUSH
5172: LD_INT 8
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PPUSH
5186: LD_INT 3000
5188: PUSH
5189: LD_INT 300
5191: PUSH
5192: LD_INT 100
5194: PUSH
5195: EMPTY
5196: LIST
5197: LIST
5198: LIST
5199: PPUSH
5200: LD_INT 12
5202: PUSH
5203: LD_INT 6
5205: PUSH
5206: LD_INT 6
5208: PUSH
5209: LD_INT 4
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: PPUSH
5218: CALL 28500 0 6
5222: ST_TO_ADDR
// if not base then
5223: LD_VAR 0 8
5227: NOT
5228: IFFALSE 5232
// exit ;
5230: GO 5488
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5232: LD_ADDR_EXP 31
5236: PUSH
5237: LD_EXP 31
5241: PPUSH
5242: LD_EXP 7
5246: PPUSH
5247: LD_VAR 0 8
5251: PPUSH
5252: CALL_OW 1
5256: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5257: LD_ADDR_VAR 0 8
5261: PUSH
5262: LD_INT 34
5264: PPUSH
5265: LD_INT 23
5267: PPUSH
5268: CALL_OW 428
5272: PPUSH
5273: LD_INT 11
5275: PPUSH
5276: LD_INT 0
5278: PPUSH
5279: LD_INT 6
5281: PUSH
5282: LD_INT 7
5284: PUSH
5285: LD_INT 8
5287: PUSH
5288: EMPTY
5289: LIST
5290: LIST
5291: LIST
5292: PUSH
5293: LD_OWVAR 67
5297: ARRAY
5298: PPUSH
5299: LD_INT 20000
5301: PUSH
5302: LD_INT 3000
5304: PUSH
5305: LD_INT 1000
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: LIST
5312: PPUSH
5313: LD_INT 12
5315: PUSH
5316: LD_INT 6
5318: PUSH
5319: LD_INT 6
5321: PUSH
5322: LD_INT 4
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: PPUSH
5331: CALL 28500 0 6
5335: ST_TO_ADDR
// if not base then
5336: LD_VAR 0 8
5340: NOT
5341: IFFALSE 5345
// exit ;
5343: GO 5488
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5345: LD_ADDR_EXP 31
5349: PUSH
5350: LD_EXP 31
5354: PPUSH
5355: LD_EXP 8
5359: PPUSH
5360: LD_VAR 0 8
5364: PPUSH
5365: CALL_OW 1
5369: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5370: LD_ADDR_EXP 14
5374: PUSH
5375: LD_INT 22
5377: PUSH
5378: LD_INT 3
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PUSH
5385: LD_INT 30
5387: PUSH
5388: LD_INT 0
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_INT 1
5406: ARRAY
5407: PPUSH
5408: LD_INT 25
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: LD_INT 6
5416: PUSH
5417: LD_INT 7
5419: PUSH
5420: LD_INT 8
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: LIST
5427: PUSH
5428: LD_OWVAR 67
5432: ARRAY
5433: PPUSH
5434: LD_INT 500
5436: PUSH
5437: LD_INT 100
5439: PUSH
5440: LD_INT 10
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: PPUSH
5448: LD_INT 6
5450: PUSH
5451: LD_INT 7
5453: PUSH
5454: LD_INT 8
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: LIST
5461: PUSH
5462: LD_OWVAR 67
5466: ARRAY
5467: PUSH
5468: LD_INT 2
5470: PUSH
5471: LD_INT 0
5473: PUSH
5474: LD_INT 1
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: PPUSH
5483: CALL 28500 0 6
5487: ST_TO_ADDR
// end ;
5488: LD_VAR 0 1
5492: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5493: LD_INT 0
5495: PPUSH
5496: PPUSH
5497: PPUSH
5498: PPUSH
5499: PPUSH
5500: PPUSH
5501: PPUSH
5502: PPUSH
5503: PPUSH
5504: PPUSH
5505: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5506: LD_INT 0
5508: PPUSH
5509: LD_INT 0
5511: PPUSH
5512: LD_INT 6
5514: PPUSH
5515: LD_INT 0
5517: PPUSH
5518: LD_INT 0
5520: PPUSH
5521: LD_INT 0
5523: PPUSH
5524: LD_INT 0
5526: PPUSH
5527: LD_INT 8
5529: PPUSH
5530: LD_INT 0
5532: PPUSH
5533: CALL 54207 0 9
// side := 8 ;
5537: LD_ADDR_VAR 0 8
5541: PUSH
5542: LD_INT 8
5544: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5545: LD_ADDR_VAR 0 5
5549: PUSH
5550: LD_INT 20
5552: PPUSH
5553: LD_INT 0
5555: PPUSH
5556: CALL_OW 517
5560: ST_TO_ADDR
// if Difficulty > 2 then
5561: LD_OWVAR 67
5565: PUSH
5566: LD_INT 2
5568: GREATER
5569: IFFALSE 5713
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5571: LD_ADDR_VAR 0 6
5575: PUSH
5576: LD_INT 27
5578: PPUSH
5579: LD_INT 0
5581: PPUSH
5582: CALL_OW 517
5586: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5587: LD_ADDR_VAR 0 2
5591: PUSH
5592: DOUBLE
5593: LD_INT 1
5595: DEC
5596: ST_TO_ADDR
5597: LD_VAR 0 6
5601: PUSH
5602: LD_INT 1
5604: ARRAY
5605: PUSH
5606: FOR_TO
5607: IFFALSE 5711
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5609: LD_ADDR_VAR 0 5
5613: PUSH
5614: LD_VAR 0 5
5618: PPUSH
5619: LD_INT 1
5621: PUSH
5622: LD_VAR 0 5
5626: PUSH
5627: LD_INT 1
5629: ARRAY
5630: PUSH
5631: LD_INT 1
5633: PLUS
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PPUSH
5639: LD_VAR 0 6
5643: PUSH
5644: LD_INT 1
5646: ARRAY
5647: PUSH
5648: LD_VAR 0 2
5652: ARRAY
5653: PPUSH
5654: CALL 24801 0 3
5658: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5659: LD_ADDR_VAR 0 5
5663: PUSH
5664: LD_VAR 0 5
5668: PPUSH
5669: LD_INT 2
5671: PUSH
5672: LD_VAR 0 5
5676: PUSH
5677: LD_INT 2
5679: ARRAY
5680: PUSH
5681: LD_INT 1
5683: PLUS
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: LD_VAR 0 6
5693: PUSH
5694: LD_INT 2
5696: ARRAY
5697: PUSH
5698: LD_VAR 0 2
5702: ARRAY
5703: PPUSH
5704: CALL 24801 0 3
5708: ST_TO_ADDR
// end ;
5709: GO 5606
5711: POP
5712: POP
// end ; if tmp then
5713: LD_VAR 0 5
5717: IFFALSE 5845
// begin for i = 1 to tmp [ 1 ] do
5719: LD_ADDR_VAR 0 2
5723: PUSH
5724: DOUBLE
5725: LD_INT 1
5727: DEC
5728: ST_TO_ADDR
5729: LD_VAR 0 5
5733: PUSH
5734: LD_INT 1
5736: ARRAY
5737: PUSH
5738: FOR_TO
5739: IFFALSE 5843
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5741: LD_VAR 0 5
5745: PUSH
5746: LD_INT 1
5748: ARRAY
5749: PUSH
5750: LD_VAR 0 2
5754: ARRAY
5755: PPUSH
5756: LD_VAR 0 5
5760: PUSH
5761: LD_INT 2
5763: ARRAY
5764: PUSH
5765: LD_VAR 0 2
5769: ARRAY
5770: PPUSH
5771: LD_VAR 0 8
5775: PPUSH
5776: LD_INT 0
5778: PPUSH
5779: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5783: LD_ADDR_EXP 16
5787: PUSH
5788: LD_EXP 16
5792: PPUSH
5793: LD_EXP 16
5797: PUSH
5798: LD_INT 1
5800: PLUS
5801: PPUSH
5802: LD_VAR 0 5
5806: PUSH
5807: LD_INT 1
5809: ARRAY
5810: PUSH
5811: LD_VAR 0 2
5815: ARRAY
5816: PUSH
5817: LD_VAR 0 5
5821: PUSH
5822: LD_INT 2
5824: ARRAY
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PPUSH
5836: CALL_OW 2
5840: ST_TO_ADDR
// end ;
5841: GO 5738
5843: POP
5844: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5845: LD_ADDR_VAR 0 7
5849: PUSH
5850: LD_INT 165
5852: PUSH
5853: LD_INT 156
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 143
5862: PUSH
5863: LD_INT 145
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 152
5872: PUSH
5873: LD_INT 165
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: LD_INT 123
5882: PUSH
5883: LD_INT 153
5885: PUSH
5886: EMPTY
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 161
5892: PUSH
5893: LD_INT 215
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 172
5902: PUSH
5903: LD_INT 100
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PUSH
5910: LD_INT 148
5912: PUSH
5913: LD_INT 83
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: PUSH
5920: LD_INT 122
5922: PUSH
5923: LD_INT 68
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: PUSH
5930: LD_INT 105
5932: PUSH
5933: LD_INT 74
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: PUSH
5940: LD_INT 113
5942: PUSH
5943: LD_INT 97
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: ST_TO_ADDR
// for i in cameras do
5962: LD_ADDR_VAR 0 2
5966: PUSH
5967: LD_VAR 0 7
5971: PUSH
5972: FOR_IN
5973: IFFALSE 6004
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
5975: LD_VAR 0 2
5979: PUSH
5980: LD_INT 1
5982: ARRAY
5983: PPUSH
5984: LD_VAR 0 2
5988: PUSH
5989: LD_INT 2
5991: ARRAY
5992: PPUSH
5993: LD_VAR 0 8
5997: PPUSH
5998: CALL_OW 244
6002: GO 5972
6004: POP
6005: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6006: LD_ADDR_VAR 0 5
6010: PUSH
6011: LD_INT 1
6013: PUSH
6014: LD_INT 144
6016: PUSH
6017: LD_INT 110
6019: PUSH
6020: LD_INT 1
6022: PUSH
6023: LD_INT 0
6025: PUSH
6026: LD_INT 0
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: LD_INT 3
6039: PUSH
6040: LD_INT 151
6042: PUSH
6043: LD_INT 118
6045: PUSH
6046: LD_INT 0
6048: PUSH
6049: LD_INT 0
6051: PUSH
6052: LD_INT 0
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: PUSH
6063: LD_INT 8
6065: PUSH
6066: LD_INT 158
6068: PUSH
6069: LD_INT 110
6071: PUSH
6072: LD_INT 4
6074: PUSH
6075: LD_INT 10
6077: PUSH
6078: LD_INT 15
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: LIST
6085: LIST
6086: LIST
6087: LIST
6088: PUSH
6089: LD_INT 23
6091: PUSH
6092: LD_INT 154
6094: PUSH
6095: LD_INT 121
6097: PUSH
6098: LD_INT 5
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 22
6117: PUSH
6118: LD_INT 155
6120: PUSH
6121: LD_INT 118
6123: PUSH
6124: LD_INT 4
6126: PUSH
6127: LD_INT 0
6129: PUSH
6130: LD_INT 0
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 21
6143: PUSH
6144: LD_INT 151
6146: PUSH
6147: LD_INT 122
6149: PUSH
6150: LD_INT 0
6152: PUSH
6153: LD_INT 0
6155: PUSH
6156: LD_INT 0
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: LD_INT 18
6169: PUSH
6170: LD_INT 148
6172: PUSH
6173: LD_INT 118
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 0
6181: PUSH
6182: LD_INT 0
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: LD_INT 17
6195: PUSH
6196: LD_INT 147
6198: PUSH
6199: LD_INT 114
6201: PUSH
6202: LD_INT 2
6204: PUSH
6205: LD_INT 0
6207: PUSH
6208: LD_INT 0
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: LIST
6218: PUSH
6219: LD_INT 29
6221: PUSH
6222: LD_INT 163
6224: PUSH
6225: LD_INT 120
6227: PUSH
6228: LD_INT 5
6230: PUSH
6231: LD_INT 0
6233: PUSH
6234: LD_INT 0
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 27
6247: PUSH
6248: LD_INT 137
6250: PUSH
6251: LD_INT 116
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 0
6259: PUSH
6260: LD_INT 0
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 27
6273: PUSH
6274: LD_INT 133
6276: PUSH
6277: LD_INT 111
6279: PUSH
6280: LD_INT 1
6282: PUSH
6283: LD_INT 0
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 27
6299: PUSH
6300: LD_INT 132
6302: PUSH
6303: LD_INT 106
6305: PUSH
6306: LD_INT 4
6308: PUSH
6309: LD_INT 0
6311: PUSH
6312: LD_INT 0
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: LIST
6322: PUSH
6323: LD_INT 26
6325: PUSH
6326: LD_INT 137
6328: PUSH
6329: LD_INT 111
6331: PUSH
6332: LD_INT 0
6334: PUSH
6335: LD_INT 0
6337: PUSH
6338: LD_INT 0
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: LIST
6346: LIST
6347: LIST
6348: PUSH
6349: LD_INT 8
6351: PUSH
6352: LD_INT 141
6354: PUSH
6355: LD_INT 117
6357: PUSH
6358: LD_INT 1
6360: PUSH
6361: LD_INT 13
6363: PUSH
6364: LD_INT 11
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_INT 30
6377: PUSH
6378: LD_INT 140
6380: PUSH
6381: LD_INT 128
6383: PUSH
6384: LD_INT 1
6386: PUSH
6387: LD_INT 0
6389: PUSH
6390: LD_INT 0
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: PUSH
6401: LD_INT 5
6403: PUSH
6404: LD_INT 146
6406: PUSH
6407: LD_INT 96
6409: PUSH
6410: LD_INT 3
6412: PUSH
6413: LD_INT 0
6415: PUSH
6416: LD_INT 0
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 32
6429: PUSH
6430: LD_INT 150
6432: PUSH
6433: LD_INT 98
6435: PUSH
6436: LD_INT 3
6438: PUSH
6439: LD_INT 0
6441: PUSH
6442: LD_INT 0
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: LIST
6449: LIST
6450: LIST
6451: LIST
6452: PUSH
6453: LD_INT 32
6455: PUSH
6456: LD_INT 142
6458: PUSH
6459: LD_INT 95
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: LD_INT 0
6467: PUSH
6468: LD_INT 0
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: PUSH
6479: LD_INT 32
6481: PUSH
6482: LD_INT 159
6484: PUSH
6485: LD_INT 104
6487: PUSH
6488: LD_INT 3
6490: PUSH
6491: LD_INT 0
6493: PUSH
6494: LD_INT 0
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: PUSH
6505: LD_INT 32
6507: PUSH
6508: LD_INT 133
6510: PUSH
6511: LD_INT 95
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: LD_INT 0
6522: PUSH
6523: EMPTY
6524: LIST
6525: LIST
6526: LIST
6527: LIST
6528: LIST
6529: LIST
6530: PUSH
6531: LD_INT 32
6533: PUSH
6534: LD_INT 131
6536: PUSH
6537: LD_INT 102
6539: PUSH
6540: LD_INT 2
6542: PUSH
6543: LD_INT 0
6545: PUSH
6546: LD_INT 0
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: PUSH
6557: LD_INT 32
6559: PUSH
6560: LD_INT 164
6562: PUSH
6563: LD_INT 144
6565: PUSH
6566: LD_INT 0
6568: PUSH
6569: LD_INT 0
6571: PUSH
6572: LD_INT 0
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: LIST
6581: LIST
6582: PUSH
6583: LD_INT 32
6585: PUSH
6586: LD_INT 146
6588: PUSH
6589: LD_INT 139
6591: PUSH
6592: LD_INT 0
6594: PUSH
6595: LD_INT 0
6597: PUSH
6598: LD_INT 0
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: PUSH
6609: LD_INT 26
6611: PUSH
6612: LD_INT 143
6614: PUSH
6615: LD_INT 122
6617: PUSH
6618: LD_INT 4
6620: PUSH
6621: LD_INT 0
6623: PUSH
6624: LD_INT 0
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 26
6637: PUSH
6638: LD_INT 164
6640: PUSH
6641: LD_INT 116
6643: PUSH
6644: LD_INT 2
6646: PUSH
6647: LD_INT 0
6649: PUSH
6650: LD_INT 0
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: ST_TO_ADDR
// for i in tmp do
6688: LD_ADDR_VAR 0 2
6692: PUSH
6693: LD_VAR 0 5
6697: PUSH
6698: FOR_IN
6699: IFFALSE 6930
// begin uc_side := side ;
6701: LD_ADDR_OWVAR 20
6705: PUSH
6706: LD_VAR 0 8
6710: ST_TO_ADDR
// uc_nation := nation_arabian ;
6711: LD_ADDR_OWVAR 21
6715: PUSH
6716: LD_INT 2
6718: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6719: LD_ADDR_OWVAR 42
6723: PUSH
6724: LD_VAR 0 2
6728: PUSH
6729: LD_INT 1
6731: ARRAY
6732: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6733: LD_ADDR_OWVAR 43
6737: PUSH
6738: LD_INT 5
6740: PPUSH
6741: LD_INT 6
6743: PPUSH
6744: CALL_OW 12
6748: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6749: LD_ADDR_OWVAR 44
6753: PUSH
6754: LD_VAR 0 2
6758: PUSH
6759: LD_INT 5
6761: ARRAY
6762: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6763: LD_ADDR_OWVAR 45
6767: PUSH
6768: LD_VAR 0 2
6772: PUSH
6773: LD_INT 6
6775: ARRAY
6776: ST_TO_ADDR
// sr := 0 ;
6777: LD_ADDR_VAR 0 9
6781: PUSH
6782: LD_INT 0
6784: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6785: LD_VAR 0 2
6789: PUSH
6790: LD_INT 1
6792: ARRAY
6793: PUSH
6794: LD_INT 29
6796: EQUAL
6797: IFFALSE 6809
// sr := mat_oil else
6799: LD_ADDR_VAR 0 9
6803: PUSH
6804: LD_INT 2
6806: ST_TO_ADDR
6807: GO 6831
// if i [ 1 ] = b_siberite_mine then
6809: LD_VAR 0 2
6813: PUSH
6814: LD_INT 1
6816: ARRAY
6817: PUSH
6818: LD_INT 30
6820: EQUAL
6821: IFFALSE 6831
// sr := mat_siberit ;
6823: LD_ADDR_VAR 0 9
6827: PUSH
6828: LD_INT 3
6830: ST_TO_ADDR
// if sr then
6831: LD_VAR 0 9
6835: IFFALSE 6891
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6837: LD_VAR 0 2
6841: PUSH
6842: LD_INT 2
6844: ARRAY
6845: PPUSH
6846: LD_VAR 0 2
6850: PUSH
6851: LD_INT 3
6853: ARRAY
6854: PPUSH
6855: LD_VAR 0 9
6859: PPUSH
6860: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6864: LD_VAR 0 2
6868: PUSH
6869: LD_INT 2
6871: ARRAY
6872: PPUSH
6873: LD_VAR 0 2
6877: PUSH
6878: LD_INT 3
6880: ARRAY
6881: PPUSH
6882: LD_VAR 0 8
6886: PPUSH
6887: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6891: LD_ADDR_VAR 0 3
6895: PUSH
6896: LD_VAR 0 2
6900: PUSH
6901: LD_INT 2
6903: ARRAY
6904: PPUSH
6905: LD_VAR 0 2
6909: PUSH
6910: LD_INT 3
6912: ARRAY
6913: PPUSH
6914: LD_VAR 0 2
6918: PUSH
6919: LD_INT 4
6921: ARRAY
6922: PPUSH
6923: CALL_OW 47
6927: ST_TO_ADDR
// end ;
6928: GO 6698
6930: POP
6931: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6932: LD_ADDR_VAR 0 10
6936: PUSH
6937: LD_INT 22
6939: PUSH
6940: LD_VAR 0 8
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PUSH
6949: LD_INT 30
6951: PUSH
6952: LD_INT 1
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PPUSH
6963: CALL_OW 69
6967: ST_TO_ADDR
// if not depot then
6968: LD_VAR 0 10
6972: NOT
6973: IFFALSE 6977
// exit ;
6975: GO 7223
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
6977: LD_ADDR_VAR 0 11
6981: PUSH
6982: LD_VAR 0 10
6986: PUSH
6987: LD_INT 1
6989: ARRAY
6990: PPUSH
6991: LD_INT 6
6993: PPUSH
6994: LD_INT 0
6996: PPUSH
6997: LD_INT 7
6999: PUSH
7000: LD_INT 8
7002: PUSH
7003: LD_INT 10
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: LIST
7010: PUSH
7011: LD_OWVAR 67
7015: ARRAY
7016: PPUSH
7017: LD_INT 3000
7019: PUSH
7020: LD_INT 300
7022: PUSH
7023: LD_INT 100
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: LIST
7030: PPUSH
7031: LD_INT 14
7033: PUSH
7034: LD_INT 6
7036: PUSH
7037: LD_INT 6
7039: PUSH
7040: LD_INT 5
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL 28500 0 6
7053: ST_TO_ADDR
// if not base then
7054: LD_VAR 0 11
7058: NOT
7059: IFFALSE 7063
// exit ;
7061: GO 7223
// if Difficulty > 1 then
7063: LD_OWVAR 67
7067: PUSH
7068: LD_INT 1
7070: GREATER
7071: IFFALSE 7144
// begin InitHc ;
7073: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7077: LD_INT 1
7079: PPUSH
7080: LD_INT 5
7082: PPUSH
7083: LD_INT 5
7085: PUSH
7086: LD_INT 8
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PUSH
7093: LD_OWVAR 67
7097: PUSH
7098: LD_INT 1
7100: MINUS
7101: ARRAY
7102: PPUSH
7103: CALL_OW 380
// for i = 1 to Difficulty do
7107: LD_ADDR_VAR 0 2
7111: PUSH
7112: DOUBLE
7113: LD_INT 1
7115: DEC
7116: ST_TO_ADDR
7117: LD_OWVAR 67
7121: PUSH
7122: FOR_TO
7123: IFFALSE 7142
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7125: CALL_OW 44
7129: PPUSH
7130: LD_INT 24
7132: PPUSH
7133: LD_INT 0
7135: PPUSH
7136: CALL_OW 49
7140: GO 7122
7142: POP
7143: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7144: LD_ADDR_EXP 31
7148: PUSH
7149: LD_EXP 31
7153: PPUSH
7154: LD_EXP 6
7158: PPUSH
7159: LD_VAR 0 11
7163: PPUSH
7164: CALL_OW 1
7168: ST_TO_ADDR
// hc_gallery := ru ;
7169: LD_ADDR_OWVAR 33
7173: PUSH
7174: LD_STRING ru
7176: ST_TO_ADDR
// hc_face_number := 44 ;
7177: LD_ADDR_OWVAR 34
7181: PUSH
7182: LD_INT 44
7184: ST_TO_ADDR
// hc_name := Robert Farmer ;
7185: LD_ADDR_OWVAR 26
7189: PUSH
7190: LD_STRING Robert Farmer
7192: ST_TO_ADDR
// hc_sex := sex_male ;
7193: LD_ADDR_OWVAR 27
7197: PUSH
7198: LD_INT 1
7200: ST_TO_ADDR
// hc_class := 1 ;
7201: LD_ADDR_OWVAR 28
7205: PUSH
7206: LD_INT 1
7208: ST_TO_ADDR
// Farmer := CreateHuman ;
7209: LD_ADDR_EXP 13
7213: PUSH
7214: CALL_OW 44
7218: ST_TO_ADDR
// InitHc ;
7219: CALL_OW 19
// end ;
7223: LD_VAR 0 1
7227: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7228: LD_INT 0
7230: PPUSH
7231: PPUSH
7232: PPUSH
7233: PPUSH
// tmp := [ ] ;
7234: LD_ADDR_VAR 0 3
7238: PUSH
7239: EMPTY
7240: ST_TO_ADDR
// for i := 1 to 3 do
7241: LD_ADDR_VAR 0 2
7245: PUSH
7246: DOUBLE
7247: LD_INT 1
7249: DEC
7250: ST_TO_ADDR
7251: LD_INT 3
7253: PUSH
7254: FOR_TO
7255: IFFALSE 7367
// begin uc_side := 3 ;
7257: LD_ADDR_OWVAR 20
7261: PUSH
7262: LD_INT 3
7264: ST_TO_ADDR
// uc_nation := 3 ;
7265: LD_ADDR_OWVAR 21
7269: PUSH
7270: LD_INT 3
7272: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7273: LD_ADDR_OWVAR 37
7277: PUSH
7278: LD_INT 22
7280: ST_TO_ADDR
// vc_engine := engine_siberite ;
7281: LD_ADDR_OWVAR 39
7285: PUSH
7286: LD_INT 3
7288: ST_TO_ADDR
// vc_control := control_computer ;
7289: LD_ADDR_OWVAR 38
7293: PUSH
7294: LD_INT 3
7296: ST_TO_ADDR
// vc_weapon := ru_crane ;
7297: LD_ADDR_OWVAR 40
7301: PUSH
7302: LD_INT 52
7304: ST_TO_ADDR
// veh := CreateVehicle ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: CALL_OW 45
7314: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7315: LD_VAR 0 4
7319: PPUSH
7320: LD_INT 73
7322: PPUSH
7323: LD_INT 122
7325: PPUSH
7326: LD_INT 3
7328: PPUSH
7329: LD_INT 0
7331: PPUSH
7332: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7336: LD_ADDR_VAR 0 3
7340: PUSH
7341: LD_VAR 0 3
7345: PPUSH
7346: LD_VAR 0 3
7350: PUSH
7351: LD_INT 1
7353: PLUS
7354: PPUSH
7355: LD_VAR 0 4
7359: PPUSH
7360: CALL_OW 1
7364: ST_TO_ADDR
// end ;
7365: GO 7254
7367: POP
7368: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7369: LD_ADDR_EXP 50
7373: PUSH
7374: LD_EXP 50
7378: PPUSH
7379: LD_EXP 7
7383: PPUSH
7384: LD_VAR 0 3
7388: PPUSH
7389: CALL_OW 1
7393: ST_TO_ADDR
// tmp := [ ] ;
7394: LD_ADDR_VAR 0 3
7398: PUSH
7399: EMPTY
7400: ST_TO_ADDR
// for i := 1 to 3 do
7401: LD_ADDR_VAR 0 2
7405: PUSH
7406: DOUBLE
7407: LD_INT 1
7409: DEC
7410: ST_TO_ADDR
7411: LD_INT 3
7413: PUSH
7414: FOR_TO
7415: IFFALSE 7527
// begin uc_side := 3 ;
7417: LD_ADDR_OWVAR 20
7421: PUSH
7422: LD_INT 3
7424: ST_TO_ADDR
// uc_nation := 3 ;
7425: LD_ADDR_OWVAR 21
7429: PUSH
7430: LD_INT 3
7432: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7433: LD_ADDR_OWVAR 37
7437: PUSH
7438: LD_INT 22
7440: ST_TO_ADDR
// vc_engine := engine_siberite ;
7441: LD_ADDR_OWVAR 39
7445: PUSH
7446: LD_INT 3
7448: ST_TO_ADDR
// vc_control := control_computer ;
7449: LD_ADDR_OWVAR 38
7453: PUSH
7454: LD_INT 3
7456: ST_TO_ADDR
// vc_weapon := ru_crane ;
7457: LD_ADDR_OWVAR 40
7461: PUSH
7462: LD_INT 52
7464: ST_TO_ADDR
// veh := CreateVehicle ;
7465: LD_ADDR_VAR 0 4
7469: PUSH
7470: CALL_OW 45
7474: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7475: LD_VAR 0 4
7479: PPUSH
7480: LD_INT 22
7482: PPUSH
7483: LD_INT 28
7485: PPUSH
7486: LD_INT 3
7488: PPUSH
7489: LD_INT 0
7491: PPUSH
7492: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7496: LD_ADDR_VAR 0 3
7500: PUSH
7501: LD_VAR 0 3
7505: PPUSH
7506: LD_VAR 0 3
7510: PUSH
7511: LD_INT 1
7513: PLUS
7514: PPUSH
7515: LD_VAR 0 4
7519: PPUSH
7520: CALL_OW 1
7524: ST_TO_ADDR
// end ;
7525: GO 7414
7527: POP
7528: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7529: LD_ADDR_EXP 50
7533: PUSH
7534: LD_EXP 50
7538: PPUSH
7539: LD_EXP 8
7543: PPUSH
7544: LD_VAR 0 3
7548: PPUSH
7549: CALL_OW 1
7553: ST_TO_ADDR
// end ;
7554: LD_VAR 0 1
7558: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7559: LD_INT 0
7561: PPUSH
7562: PPUSH
7563: PPUSH
7564: PPUSH
7565: PPUSH
7566: PPUSH
7567: PPUSH
7568: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7569: LD_INT 0
7571: PPUSH
7572: LD_INT 0
7574: PPUSH
7575: LD_INT 4
7577: PPUSH
7578: LD_INT 0
7580: PPUSH
7581: LD_INT 0
7583: PPUSH
7584: LD_INT 0
7586: PPUSH
7587: LD_INT 0
7589: PPUSH
7590: LD_INT 10
7592: PPUSH
7593: LD_INT 0
7595: PPUSH
7596: CALL 54207 0 9
// side := 4 ;
7600: LD_ADDR_VAR 0 5
7604: PUSH
7605: LD_INT 4
7607: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7608: LD_ADDR_VAR 0 4
7612: PUSH
7613: LD_INT 1
7615: PUSH
7616: LD_INT 144
7618: PUSH
7619: LD_INT 18
7621: PUSH
7622: LD_INT 4
7624: PUSH
7625: LD_INT 0
7627: PUSH
7628: LD_INT 0
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: LIST
7638: PUSH
7639: LD_INT 3
7641: PUSH
7642: LD_INT 137
7644: PUSH
7645: LD_INT 8
7647: PUSH
7648: LD_INT 4
7650: PUSH
7651: LD_INT 0
7653: PUSH
7654: LD_INT 0
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: LIST
7661: LIST
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 22
7667: PUSH
7668: LD_INT 141
7670: PUSH
7671: LD_INT 8
7673: PUSH
7674: LD_INT 4
7676: PUSH
7677: LD_INT 0
7679: PUSH
7680: LD_INT 0
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 25
7693: PUSH
7694: LD_INT 137
7696: PUSH
7697: LD_INT 5
7699: PUSH
7700: LD_INT 3
7702: PUSH
7703: LD_INT 0
7705: PUSH
7706: LD_INT 0
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_INT 18
7719: PUSH
7720: LD_INT 137
7722: PUSH
7723: LD_INT 12
7725: PUSH
7726: LD_INT 0
7728: PUSH
7729: LD_INT 0
7731: PUSH
7732: LD_INT 0
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: LD_INT 17
7745: PUSH
7746: LD_INT 133
7748: PUSH
7749: LD_INT 4
7751: PUSH
7752: LD_INT 2
7754: PUSH
7755: LD_INT 0
7757: PUSH
7758: LD_INT 0
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 16
7771: PUSH
7772: LD_INT 140
7774: PUSH
7775: LD_INT 11
7777: PUSH
7778: LD_INT 5
7780: PUSH
7781: LD_INT 0
7783: PUSH
7784: LD_INT 0
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: LIST
7792: LIST
7793: LIST
7794: PUSH
7795: LD_INT 8
7797: PUSH
7798: LD_INT 149
7800: PUSH
7801: LD_INT 26
7803: PUSH
7804: LD_INT 4
7806: PUSH
7807: LD_INT 10
7809: PUSH
7810: LD_INT 15
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: LIST
7817: LIST
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 8
7823: PUSH
7824: LD_INT 142
7826: PUSH
7827: LD_INT 26
7829: PUSH
7830: LD_INT 1
7832: PUSH
7833: LD_INT 11
7835: PUSH
7836: LD_INT 12
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: LIST
7846: PUSH
7847: LD_INT 27
7849: PUSH
7850: LD_INT 153
7852: PUSH
7853: LD_INT 32
7855: PUSH
7856: LD_INT 5
7858: PUSH
7859: LD_INT 0
7861: PUSH
7862: LD_INT 0
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: LIST
7869: LIST
7870: LIST
7871: LIST
7872: PUSH
7873: LD_INT 27
7875: PUSH
7876: LD_INT 145
7878: PUSH
7879: LD_INT 32
7881: PUSH
7882: LD_INT 3
7884: PUSH
7885: LD_INT 0
7887: PUSH
7888: LD_INT 0
7890: PUSH
7891: EMPTY
7892: LIST
7893: LIST
7894: LIST
7895: LIST
7896: LIST
7897: LIST
7898: PUSH
7899: LD_INT 27
7901: PUSH
7902: LD_INT 138
7904: PUSH
7905: LD_INT 2
7907: PUSH
7908: LD_INT 4
7910: PUSH
7911: LD_INT 0
7913: PUSH
7914: LD_INT 0
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: LIST
7921: LIST
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 27
7927: PUSH
7928: LD_INT 144
7930: PUSH
7931: LD_INT 13
7933: PUSH
7934: LD_INT 0
7936: PUSH
7937: LD_INT 0
7939: PUSH
7940: LD_INT 0
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: LIST
7947: LIST
7948: LIST
7949: LIST
7950: PUSH
7951: LD_INT 26
7953: PUSH
7954: LD_INT 124
7956: PUSH
7957: LD_INT 2
7959: PUSH
7960: LD_INT 4
7962: PUSH
7963: LD_INT 0
7965: PUSH
7966: LD_INT 0
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: LIST
7975: LIST
7976: PUSH
7977: LD_INT 26
7979: PUSH
7980: LD_INT 121
7982: PUSH
7983: LD_INT 2
7985: PUSH
7986: LD_INT 2
7988: PUSH
7989: LD_INT 0
7991: PUSH
7992: LD_INT 0
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: LIST
7999: LIST
8000: LIST
8001: LIST
8002: PUSH
8003: LD_INT 26
8005: PUSH
8006: LD_INT 118
8008: PUSH
8009: LD_INT 2
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: LD_INT 0
8017: PUSH
8018: LD_INT 0
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: PUSH
8029: LD_INT 29
8031: PUSH
8032: LD_INT 159
8034: PUSH
8035: LD_INT 47
8037: PUSH
8038: LD_INT 2
8040: PUSH
8041: LD_INT 0
8043: PUSH
8044: LD_INT 0
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: LIST
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 32
8057: PUSH
8058: LD_INT 146
8060: PUSH
8061: LD_INT 41
8063: PUSH
8064: LD_INT 0
8066: PUSH
8067: LD_INT 0
8069: PUSH
8070: LD_INT 0
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: LD_INT 33
8083: PUSH
8084: LD_INT 136
8086: PUSH
8087: LD_INT 37
8089: PUSH
8090: LD_INT 0
8092: PUSH
8093: LD_INT 0
8095: PUSH
8096: LD_INT 0
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: LIST
8105: LIST
8106: PUSH
8107: LD_INT 33
8109: PUSH
8110: LD_INT 132
8112: PUSH
8113: LD_INT 34
8115: PUSH
8116: LD_INT 0
8118: PUSH
8119: LD_INT 0
8121: PUSH
8122: LD_INT 0
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_INT 36
8135: PUSH
8136: LD_INT 124
8138: PUSH
8139: LD_INT 7
8141: PUSH
8142: LD_INT 1
8144: PUSH
8145: LD_INT 0
8147: PUSH
8148: LD_INT 0
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: LIST
8155: LIST
8156: LIST
8157: LIST
8158: PUSH
8159: LD_INT 5
8161: PUSH
8162: LD_INT 124
8164: PUSH
8165: LD_INT 19
8167: PUSH
8168: LD_INT 0
8170: PUSH
8171: LD_INT 0
8173: PUSH
8174: LD_INT 0
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: LIST
8183: LIST
8184: PUSH
8185: LD_INT 32
8187: PUSH
8188: LD_INT 127
8190: PUSH
8191: LD_INT 23
8193: PUSH
8194: LD_INT 0
8196: PUSH
8197: LD_INT 0
8199: PUSH
8200: LD_INT 0
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: ST_TO_ADDR
// for i in tmp do
8236: LD_ADDR_VAR 0 2
8240: PUSH
8241: LD_VAR 0 4
8245: PUSH
8246: FOR_IN
8247: IFFALSE 8478
// begin uc_side := side ;
8249: LD_ADDR_OWVAR 20
8253: PUSH
8254: LD_VAR 0 5
8258: ST_TO_ADDR
// uc_nation := nation_american ;
8259: LD_ADDR_OWVAR 21
8263: PUSH
8264: LD_INT 1
8266: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8267: LD_ADDR_OWVAR 42
8271: PUSH
8272: LD_VAR 0 2
8276: PUSH
8277: LD_INT 1
8279: ARRAY
8280: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8281: LD_ADDR_OWVAR 43
8285: PUSH
8286: LD_INT 5
8288: PPUSH
8289: LD_INT 6
8291: PPUSH
8292: CALL_OW 12
8296: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8297: LD_ADDR_OWVAR 44
8301: PUSH
8302: LD_VAR 0 2
8306: PUSH
8307: LD_INT 5
8309: ARRAY
8310: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8311: LD_ADDR_OWVAR 45
8315: PUSH
8316: LD_VAR 0 2
8320: PUSH
8321: LD_INT 6
8323: ARRAY
8324: ST_TO_ADDR
// sr := 0 ;
8325: LD_ADDR_VAR 0 6
8329: PUSH
8330: LD_INT 0
8332: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8333: LD_VAR 0 2
8337: PUSH
8338: LD_INT 1
8340: ARRAY
8341: PUSH
8342: LD_INT 29
8344: EQUAL
8345: IFFALSE 8357
// sr := mat_oil else
8347: LD_ADDR_VAR 0 6
8351: PUSH
8352: LD_INT 2
8354: ST_TO_ADDR
8355: GO 8379
// if i [ 1 ] = b_siberite_mine then
8357: LD_VAR 0 2
8361: PUSH
8362: LD_INT 1
8364: ARRAY
8365: PUSH
8366: LD_INT 30
8368: EQUAL
8369: IFFALSE 8379
// sr := mat_siberit ;
8371: LD_ADDR_VAR 0 6
8375: PUSH
8376: LD_INT 3
8378: ST_TO_ADDR
// if sr then
8379: LD_VAR 0 6
8383: IFFALSE 8439
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8385: LD_VAR 0 2
8389: PUSH
8390: LD_INT 2
8392: ARRAY
8393: PPUSH
8394: LD_VAR 0 2
8398: PUSH
8399: LD_INT 3
8401: ARRAY
8402: PPUSH
8403: LD_VAR 0 6
8407: PPUSH
8408: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8412: LD_VAR 0 2
8416: PUSH
8417: LD_INT 2
8419: ARRAY
8420: PPUSH
8421: LD_VAR 0 2
8425: PUSH
8426: LD_INT 3
8428: ARRAY
8429: PPUSH
8430: LD_VAR 0 5
8434: PPUSH
8435: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: LD_VAR 0 2
8448: PUSH
8449: LD_INT 2
8451: ARRAY
8452: PPUSH
8453: LD_VAR 0 2
8457: PUSH
8458: LD_INT 3
8460: ARRAY
8461: PPUSH
8462: LD_VAR 0 2
8466: PUSH
8467: LD_INT 4
8469: ARRAY
8470: PPUSH
8471: CALL_OW 47
8475: ST_TO_ADDR
// end ;
8476: GO 8246
8478: POP
8479: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8480: LD_ADDR_VAR 0 8
8484: PUSH
8485: LD_INT 22
8487: PUSH
8488: LD_VAR 0 5
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PUSH
8497: LD_INT 30
8499: PUSH
8500: LD_INT 1
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: PPUSH
8511: CALL_OW 69
8515: ST_TO_ADDR
// if not depot then
8516: LD_VAR 0 8
8520: NOT
8521: IFFALSE 8525
// exit ;
8523: GO 8797
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8525: LD_ADDR_VAR 0 7
8529: PUSH
8530: LD_VAR 0 8
8534: PUSH
8535: LD_INT 1
8537: ARRAY
8538: PPUSH
8539: LD_INT 3
8541: PPUSH
8542: LD_STRING theta3
8544: PPUSH
8545: LD_INT 8
8547: PUSH
8548: LD_INT 7
8550: PUSH
8551: LD_INT 6
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PPUSH
8565: LD_INT 2500
8567: PUSH
8568: LD_INT 2000
8570: PUSH
8571: LD_INT 1750
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: LIST
8578: PUSH
8579: LD_OWVAR 67
8583: ARRAY
8584: PUSH
8585: LD_INT 300
8587: PUSH
8588: LD_INT 250
8590: PUSH
8591: LD_INT 200
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: PUSH
8599: LD_OWVAR 67
8603: ARRAY
8604: PUSH
8605: LD_INT 80
8607: PUSH
8608: LD_INT 60
8610: PUSH
8611: LD_INT 50
8613: PUSH
8614: EMPTY
8615: LIST
8616: LIST
8617: LIST
8618: PUSH
8619: LD_OWVAR 67
8623: ARRAY
8624: PUSH
8625: EMPTY
8626: LIST
8627: LIST
8628: LIST
8629: PPUSH
8630: LD_INT 7
8632: PUSH
8633: LD_INT 6
8635: PUSH
8636: LD_INT 5
8638: PUSH
8639: LD_INT 5
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: PPUSH
8648: CALL 28500 0 6
8652: ST_TO_ADDR
// if not base then
8653: LD_VAR 0 7
8657: NOT
8658: IFFALSE 8662
// exit ;
8660: GO 8797
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8662: LD_ADDR_EXP 31
8666: PUSH
8667: LD_EXP 31
8671: PPUSH
8672: LD_EXP 5
8676: PPUSH
8677: LD_VAR 0 7
8681: PPUSH
8682: CALL_OW 1
8686: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8687: LD_INT 1
8689: PPUSH
8690: LD_INT 1
8692: PPUSH
8693: LD_INT 7
8695: PPUSH
8696: CALL_OW 380
// allyCommander := CreateHuman ;
8700: LD_ADDR_EXP 11
8704: PUSH
8705: CALL_OW 44
8709: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8710: LD_EXP 11
8714: PPUSH
8715: LD_INT 139
8717: PPUSH
8718: LD_INT 15
8720: PPUSH
8721: LD_INT 0
8723: PPUSH
8724: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8728: LD_EXP 11
8732: PPUSH
8733: LD_INT 137
8735: PPUSH
8736: LD_INT 15
8738: PPUSH
8739: CALL_OW 118
// hc_gallery := us ;
8743: LD_ADDR_OWVAR 33
8747: PUSH
8748: LD_STRING us
8750: ST_TO_ADDR
// hc_face_number := 7 ;
8751: LD_ADDR_OWVAR 34
8755: PUSH
8756: LD_INT 7
8758: ST_TO_ADDR
// hc_name := Arthur Powell ;
8759: LD_ADDR_OWVAR 26
8763: PUSH
8764: LD_STRING Arthur Powell
8766: ST_TO_ADDR
// hc_sex := sex_male ;
8767: LD_ADDR_OWVAR 27
8771: PUSH
8772: LD_INT 1
8774: ST_TO_ADDR
// hc_class := 1 ;
8775: LD_ADDR_OWVAR 28
8779: PUSH
8780: LD_INT 1
8782: ST_TO_ADDR
// Powell := CreateHuman ;
8783: LD_ADDR_EXP 12
8787: PUSH
8788: CALL_OW 44
8792: ST_TO_ADDR
// InitHc ;
8793: CALL_OW 19
// end ;
8797: LD_VAR 0 1
8801: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8802: LD_INT 0
8804: PPUSH
8805: PPUSH
8806: PPUSH
8807: PPUSH
8808: PPUSH
8809: PPUSH
8810: PPUSH
8811: PPUSH
8812: PPUSH
// side := 1 ;
8813: LD_ADDR_VAR 0 3
8817: PUSH
8818: LD_INT 1
8820: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8821: LD_ADDR_VAR 0 1
8825: PUSH
8826: EMPTY
8827: PUSH
8828: EMPTY
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: ST_TO_ADDR
// uc_side := side ;
8834: LD_ADDR_OWVAR 20
8838: PUSH
8839: LD_VAR 0 3
8843: ST_TO_ADDR
// uc_nation := nation_american ;
8844: LD_ADDR_OWVAR 21
8848: PUSH
8849: LD_INT 1
8851: ST_TO_ADDR
// InitHc ;
8852: CALL_OW 19
// InitVc ;
8856: CALL_OW 20
// hc_importance := 0 ;
8860: LD_ADDR_OWVAR 32
8864: PUSH
8865: LD_INT 0
8867: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8868: LD_ADDR_VAR 0 7
8872: PUSH
8873: LD_INT 2
8875: PUSH
8876: LD_INT 3
8878: PUSH
8879: LD_INT 3
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: LIST
8886: ST_TO_ADDR
// if commander = 2 then
8887: LD_EXP 25
8891: PUSH
8892: LD_INT 2
8894: EQUAL
8895: IFFALSE 8916
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8897: LD_ADDR_VAR 0 7
8901: PUSH
8902: LD_INT 3
8904: PUSH
8905: LD_INT 4
8907: PUSH
8908: LD_INT 4
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: LIST
8915: ST_TO_ADDR
// if commander = 3 then
8916: LD_EXP 25
8920: PUSH
8921: LD_INT 3
8923: EQUAL
8924: IFFALSE 8945
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8926: LD_ADDR_VAR 0 7
8930: PUSH
8931: LD_INT 2
8933: PUSH
8934: LD_INT 5
8936: PUSH
8937: LD_INT 5
8939: PUSH
8940: EMPTY
8941: LIST
8942: LIST
8943: LIST
8944: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8945: LD_ADDR_VAR 0 8
8949: PUSH
8950: LD_INT 2
8952: PUSH
8953: LD_INT 2
8955: PUSH
8956: LD_INT 1
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: LIST
8963: ST_TO_ADDR
// if commander = 2 then
8964: LD_EXP 25
8968: PUSH
8969: LD_INT 2
8971: EQUAL
8972: IFFALSE 8993
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
8974: LD_ADDR_VAR 0 8
8978: PUSH
8979: LD_INT 1
8981: PUSH
8982: LD_INT 1
8984: PUSH
8985: LD_INT 3
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: LIST
8992: ST_TO_ADDR
// if commander = 3 then
8993: LD_EXP 25
8997: PUSH
8998: LD_INT 3
9000: EQUAL
9001: IFFALSE 9022
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9003: LD_ADDR_VAR 0 8
9007: PUSH
9008: LD_INT 3
9010: PUSH
9011: LD_INT 3
9013: PUSH
9014: LD_INT 1
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: LIST
9021: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9022: LD_ADDR_VAR 0 9
9026: PUSH
9027: LD_INT 5
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: LD_INT 4
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: LIST
9040: ST_TO_ADDR
// if commander = 2 then
9041: LD_EXP 25
9045: PUSH
9046: LD_INT 2
9048: EQUAL
9049: IFFALSE 9070
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9051: LD_ADDR_VAR 0 9
9055: PUSH
9056: LD_INT 7
9058: PUSH
9059: LD_INT 5
9061: PUSH
9062: LD_INT 6
9064: PUSH
9065: EMPTY
9066: LIST
9067: LIST
9068: LIST
9069: ST_TO_ADDR
// if commander = 3 then
9070: LD_EXP 25
9074: PUSH
9075: LD_INT 3
9077: EQUAL
9078: IFFALSE 9099
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9080: LD_ADDR_VAR 0 9
9084: PUSH
9085: LD_INT 9
9087: PUSH
9088: LD_INT 10
9090: PUSH
9091: LD_INT 7
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: LIST
9098: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9099: LD_ADDR_VAR 0 5
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 5
9109: PUSH
9110: LD_INT 4
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: LIST
9117: PUSH
9118: LD_OWVAR 67
9122: ARRAY
9123: ST_TO_ADDR
// if commander = 2 then
9124: LD_EXP 25
9128: PUSH
9129: LD_INT 2
9131: EQUAL
9132: IFFALSE 9148
// tanks := tanks + 3 ;
9134: LD_ADDR_VAR 0 5
9138: PUSH
9139: LD_VAR 0 5
9143: PUSH
9144: LD_INT 3
9146: PLUS
9147: ST_TO_ADDR
// for i = 1 to tanks do
9148: LD_ADDR_VAR 0 2
9152: PUSH
9153: DOUBLE
9154: LD_INT 1
9156: DEC
9157: ST_TO_ADDR
9158: LD_VAR 0 5
9162: PUSH
9163: FOR_TO
9164: IFFALSE 9274
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9166: LD_VAR 0 7
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: LD_INT 3
9178: MOD
9179: PUSH
9180: LD_INT 1
9182: PLUS
9183: ARRAY
9184: PPUSH
9185: LD_VAR 0 8
9189: PUSH
9190: LD_INT 1
9192: PPUSH
9193: LD_INT 3
9195: PPUSH
9196: CALL_OW 12
9200: ARRAY
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_VAR 0 9
9209: PUSH
9210: LD_VAR 0 2
9214: PUSH
9215: LD_INT 3
9217: MOD
9218: PUSH
9219: LD_INT 1
9221: PLUS
9222: ARRAY
9223: PPUSH
9224: LD_INT 60
9226: PPUSH
9227: LD_INT 70
9229: PPUSH
9230: CALL_OW 12
9234: PPUSH
9235: CALL 24679 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 1
9248: PPUSH
9249: LD_INT 1
9251: PPUSH
9252: LD_VAR 0 1
9256: PUSH
9257: LD_INT 1
9259: ARRAY
9260: PUSH
9261: CALL_OW 45
9265: ADD
9266: PPUSH
9267: CALL_OW 1
9271: ST_TO_ADDR
// end ;
9272: GO 9163
9274: POP
9275: POP
// cl := 1 ;
9276: LD_ADDR_VAR 0 6
9280: PUSH
9281: LD_INT 1
9283: ST_TO_ADDR
// for i = 1 to 10 do
9284: LD_ADDR_VAR 0 2
9288: PUSH
9289: DOUBLE
9290: LD_INT 1
9292: DEC
9293: ST_TO_ADDR
9294: LD_INT 10
9296: PUSH
9297: FOR_TO
9298: IFFALSE 9413
// begin if i mod 4 = 0 then
9300: LD_VAR 0 2
9304: PUSH
9305: LD_INT 4
9307: MOD
9308: PUSH
9309: LD_INT 0
9311: EQUAL
9312: IFFALSE 9328
// cl := cl + 1 ;
9314: LD_ADDR_VAR 0 6
9318: PUSH
9319: LD_VAR 0 6
9323: PUSH
9324: LD_INT 1
9326: PLUS
9327: ST_TO_ADDR
// if cl = 2 then
9328: LD_VAR 0 6
9332: PUSH
9333: LD_INT 2
9335: EQUAL
9336: IFFALSE 9346
// cl := 3 ;
9338: LD_ADDR_VAR 0 6
9342: PUSH
9343: LD_INT 3
9345: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9346: LD_INT 0
9348: PPUSH
9349: LD_VAR 0 6
9353: PPUSH
9354: LD_INT 6
9356: PUSH
9357: LD_INT 6
9359: PUSH
9360: LD_INT 5
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: LIST
9367: PUSH
9368: LD_OWVAR 67
9372: ARRAY
9373: PPUSH
9374: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9378: LD_ADDR_VAR 0 1
9382: PUSH
9383: LD_VAR 0 1
9387: PPUSH
9388: LD_INT 2
9390: PPUSH
9391: LD_VAR 0 1
9395: PUSH
9396: LD_INT 2
9398: ARRAY
9399: PUSH
9400: CALL_OW 44
9404: ADD
9405: PPUSH
9406: CALL_OW 1
9410: ST_TO_ADDR
// end ;
9411: GO 9297
9413: POP
9414: POP
// if commander = 1 then
9415: LD_EXP 25
9419: PUSH
9420: LD_INT 1
9422: EQUAL
9423: IFFALSE 9491
// for i = 1 to 4 do
9425: LD_ADDR_VAR 0 2
9429: PUSH
9430: DOUBLE
9431: LD_INT 1
9433: DEC
9434: ST_TO_ADDR
9435: LD_INT 4
9437: PUSH
9438: FOR_TO
9439: IFFALSE 9489
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9441: LD_INT 0
9443: PPUSH
9444: LD_INT 1
9446: PPUSH
9447: LD_INT 8
9449: PPUSH
9450: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: LD_VAR 0 1
9463: PPUSH
9464: LD_INT 2
9466: PPUSH
9467: LD_VAR 0 1
9471: PUSH
9472: LD_INT 2
9474: ARRAY
9475: PUSH
9476: CALL_OW 44
9480: ADD
9481: PPUSH
9482: CALL_OW 1
9486: ST_TO_ADDR
// end ;
9487: GO 9438
9489: POP
9490: POP
// techs := [ ] ;
9491: LD_ADDR_VAR 0 4
9495: PUSH
9496: EMPTY
9497: ST_TO_ADDR
// if commander = 1 then
9498: LD_EXP 25
9502: PUSH
9503: LD_INT 1
9505: EQUAL
9506: IFFALSE 9531
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9508: LD_ADDR_VAR 0 4
9512: PUSH
9513: LD_INT 51
9515: PUSH
9516: LD_INT 52
9518: PUSH
9519: LD_INT 53
9521: PUSH
9522: LD_INT 12
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: ST_TO_ADDR
// if commander = 2 then
9531: LD_EXP 25
9535: PUSH
9536: LD_INT 2
9538: EQUAL
9539: IFFALSE 9576
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9541: LD_ADDR_VAR 0 4
9545: PUSH
9546: LD_INT 48
9548: PUSH
9549: LD_INT 47
9551: PUSH
9552: LD_INT 46
9554: PUSH
9555: LD_INT 45
9557: PUSH
9558: LD_INT 35
9560: PUSH
9561: LD_INT 60
9563: PUSH
9564: LD_INT 6
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 3 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 3
9583: EQUAL
9584: IFFALSE 9633
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 27
9593: PUSH
9594: LD_INT 36
9596: PUSH
9597: LD_INT 32
9599: PUSH
9600: LD_INT 57
9602: PUSH
9603: LD_INT 58
9605: PUSH
9606: LD_INT 47
9608: PUSH
9609: LD_INT 46
9611: PUSH
9612: LD_INT 51
9614: PUSH
9615: LD_INT 69
9617: PUSH
9618: LD_INT 39
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: LIST
9630: LIST
9631: LIST
9632: ST_TO_ADDR
// if techs then
9633: LD_VAR 0 4
9637: IFFALSE 9671
// for i in techs do
9639: LD_ADDR_VAR 0 2
9643: PUSH
9644: LD_VAR 0 4
9648: PUSH
9649: FOR_IN
9650: IFFALSE 9669
// SetTech ( i , 1 , state_researched ) ;
9652: LD_VAR 0 2
9656: PPUSH
9657: LD_INT 1
9659: PPUSH
9660: LD_INT 2
9662: PPUSH
9663: CALL_OW 322
9667: GO 9649
9669: POP
9670: POP
// hc_gallery := skirmish ;
9671: LD_ADDR_OWVAR 33
9675: PUSH
9676: LD_STRING skirmish
9678: ST_TO_ADDR
// hc_face_number := commander ;
9679: LD_ADDR_OWVAR 34
9683: PUSH
9684: LD_EXP 25
9688: ST_TO_ADDR
// hc_importance := 100 ;
9689: LD_ADDR_OWVAR 32
9693: PUSH
9694: LD_INT 100
9696: ST_TO_ADDR
// case commander of 1 :
9697: LD_EXP 25
9701: PUSH
9702: LD_INT 1
9704: DOUBLE
9705: EQUAL
9706: IFTRUE 9710
9708: GO 9734
9710: POP
// begin hc_name := Jeff Ironside ;
9711: LD_ADDR_OWVAR 26
9715: PUSH
9716: LD_STRING Jeff Ironside
9718: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9719: LD_INT 1
9721: PPUSH
9722: LD_INT 1
9724: PPUSH
9725: LD_INT 7
9727: PPUSH
9728: CALL_OW 380
// end ; 2 :
9732: GO 9799
9734: LD_INT 2
9736: DOUBLE
9737: EQUAL
9738: IFTRUE 9742
9740: GO 9766
9742: POP
// begin hc_name := Paul Johnson ;
9743: LD_ADDR_OWVAR 26
9747: PUSH
9748: LD_STRING Paul Johnson
9750: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9751: LD_INT 1
9753: PPUSH
9754: LD_INT 3
9756: PPUSH
9757: LD_INT 7
9759: PPUSH
9760: CALL_OW 380
// end ; 3 :
9764: GO 9799
9766: LD_INT 3
9768: DOUBLE
9769: EQUAL
9770: IFTRUE 9774
9772: GO 9798
9774: POP
// begin hc_name := Lisa Stuart ;
9775: LD_ADDR_OWVAR 26
9779: PUSH
9780: LD_STRING Lisa Stuart
9782: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9783: LD_INT 2
9785: PPUSH
9786: LD_INT 4
9788: PPUSH
9789: LD_INT 7
9791: PPUSH
9792: CALL_OW 380
// end ; end ;
9796: GO 9799
9798: POP
// playerCommander := CreateHuman ;
9799: LD_ADDR_EXP 9
9803: PUSH
9804: CALL_OW 44
9808: ST_TO_ADDR
// hc_importance := 0 ;
9809: LD_ADDR_OWVAR 32
9813: PUSH
9814: LD_INT 0
9816: ST_TO_ADDR
// hc_gallery :=  ;
9817: LD_ADDR_OWVAR 33
9821: PUSH
9822: LD_STRING 
9824: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9825: LD_ADDR_VAR 0 1
9829: PUSH
9830: LD_VAR 0 1
9834: PPUSH
9835: LD_INT 2
9837: PPUSH
9838: LD_VAR 0 1
9842: PUSH
9843: LD_INT 2
9845: ARRAY
9846: PUSH
9847: LD_EXP 9
9851: ADD
9852: PPUSH
9853: CALL_OW 1
9857: ST_TO_ADDR
// end ;
9858: LD_VAR 0 1
9862: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9863: LD_INT 0
9865: PPUSH
9866: PPUSH
9867: PPUSH
9868: PPUSH
9869: PPUSH
9870: PPUSH
// uc_side := 1 ;
9871: LD_ADDR_OWVAR 20
9875: PUSH
9876: LD_INT 1
9878: ST_TO_ADDR
// uc_nation := 1 ;
9879: LD_ADDR_OWVAR 21
9883: PUSH
9884: LD_INT 1
9886: ST_TO_ADDR
// InitHc ;
9887: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9891: LD_ADDR_VAR 0 3
9895: PUSH
9896: LD_INT 3
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: LD_INT 2
9904: PUSH
9905: EMPTY
9906: LIST
9907: LIST
9908: LIST
9909: PUSH
9910: LD_OWVAR 67
9914: ARRAY
9915: ST_TO_ADDR
// for i = 1 to peopleAmount do
9916: LD_ADDR_VAR 0 2
9920: PUSH
9921: DOUBLE
9922: LD_INT 1
9924: DEC
9925: ST_TO_ADDR
9926: LD_VAR 0 3
9930: PUSH
9931: FOR_TO
9932: IFFALSE 9981
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9934: LD_INT 0
9936: PPUSH
9937: LD_INT 2
9939: PPUSH
9940: LD_INT 7
9942: PUSH
9943: LD_INT 6
9945: PUSH
9946: LD_INT 5
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: LIST
9953: PUSH
9954: LD_OWVAR 67
9958: ARRAY
9959: PPUSH
9960: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
9964: CALL_OW 44
9968: PPUSH
9969: LD_INT 19
9971: PPUSH
9972: LD_INT 0
9974: PPUSH
9975: CALL 56435 0 3
// end ;
9979: GO 9931
9981: POP
9982: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
9983: LD_INT 2
9985: PPUSH
9986: LD_INT 1
9988: PPUSH
9989: LD_INT 3
9991: PPUSH
9992: LD_INT 13
9994: PPUSH
9995: LD_INT 58
9997: PPUSH
9998: CALL 24679 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10002: CALL_OW 45
10006: PPUSH
10007: LD_INT 19
10009: PPUSH
10010: LD_INT 0
10012: PPUSH
10013: CALL 56435 0 3
// if commander = 1 then
10017: LD_EXP 25
10021: PUSH
10022: LD_INT 1
10024: EQUAL
10025: IFFALSE 10036
// wait ( 6 6$00 ) else
10027: LD_INT 12600
10029: PPUSH
10030: CALL_OW 67
10034: GO 10043
// wait ( 8 8$00 ) ;
10036: LD_INT 16800
10038: PPUSH
10039: CALL_OW 67
// uc_side := 1 ;
10043: LD_ADDR_OWVAR 20
10047: PUSH
10048: LD_INT 1
10050: ST_TO_ADDR
// uc_nation := 1 ;
10051: LD_ADDR_OWVAR 21
10055: PUSH
10056: LD_INT 1
10058: ST_TO_ADDR
// InitVc ;
10059: CALL_OW 20
// InitHc ;
10063: CALL_OW 19
// for i = 1 to 5 do
10067: LD_ADDR_VAR 0 2
10071: PUSH
10072: DOUBLE
10073: LD_INT 1
10075: DEC
10076: ST_TO_ADDR
10077: LD_INT 5
10079: PUSH
10080: FOR_TO
10081: IFFALSE 10325
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10083: LD_INT 4
10085: PUSH
10086: LD_INT 3
10088: PUSH
10089: LD_INT 1
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: LIST
10096: PUSH
10097: LD_VAR 0 2
10101: PUSH
10102: LD_INT 3
10104: MOD
10105: PUSH
10106: LD_INT 1
10108: PLUS
10109: ARRAY
10110: PPUSH
10111: LD_INT 1
10113: PPUSH
10114: LD_INT 1
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: EMPTY
10124: LIST
10125: LIST
10126: LIST
10127: PUSH
10128: LD_VAR 0 2
10132: PUSH
10133: LD_INT 3
10135: MOD
10136: PUSH
10137: LD_INT 1
10139: PLUS
10140: ARRAY
10141: PPUSH
10142: LD_INT 6
10144: PUSH
10145: LD_INT 12
10147: PUSH
10148: LD_INT 11
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_VAR 0 2
10160: PUSH
10161: LD_INT 3
10163: MOD
10164: PUSH
10165: LD_INT 1
10167: PLUS
10168: ARRAY
10169: PPUSH
10170: LD_INT 40
10172: PPUSH
10173: LD_INT 55
10175: PPUSH
10176: CALL_OW 12
10180: PPUSH
10181: CALL 24679 0 5
// veh := CreateVehicle ;
10185: LD_ADDR_VAR 0 6
10189: PUSH
10190: CALL_OW 45
10194: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10195: LD_VAR 0 6
10199: PPUSH
10200: LD_INT 19
10202: PPUSH
10203: LD_INT 0
10205: PPUSH
10206: CALL 56435 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10210: LD_VAR 0 6
10214: PPUSH
10215: CALL_OW 264
10219: PUSH
10220: LD_INT 12
10222: EQUAL
10223: IFFALSE 10255
// begin AddCargo ( veh , mat_cans , 70 ) ;
10225: LD_VAR 0 6
10229: PPUSH
10230: LD_INT 1
10232: PPUSH
10233: LD_INT 70
10235: PPUSH
10236: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 3
10247: PPUSH
10248: LD_INT 30
10250: PPUSH
10251: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 263
10264: PUSH
10265: LD_INT 1
10267: EQUAL
10268: IFFALSE 10323
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10270: LD_INT 1
10272: PPUSH
10273: LD_INT 3
10275: PPUSH
10276: LD_INT 6
10278: PPUSH
10279: CALL_OW 380
// un := CreateHuman ;
10283: LD_ADDR_VAR 0 5
10287: PUSH
10288: CALL_OW 44
10292: ST_TO_ADDR
// tmp := tmp ^ un ;
10293: LD_ADDR_VAR 0 4
10297: PUSH
10298: LD_VAR 0 4
10302: PUSH
10303: LD_VAR 0 5
10307: ADD
10308: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10309: LD_VAR 0 5
10313: PPUSH
10314: LD_VAR 0 6
10318: PPUSH
10319: CALL_OW 52
// end ; end ;
10323: GO 10080
10325: POP
10326: POP
// if tmp then
10327: LD_VAR 0 4
10331: IFFALSE 10395
// begin CenterNowOnUnits ( tmp ) ;
10333: LD_VAR 0 4
10337: PPUSH
10338: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10342: LD_VAR 0 4
10346: PUSH
10347: LD_INT 1
10349: ARRAY
10350: PPUSH
10351: LD_STRING DAR-1
10353: PPUSH
10354: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10358: LD_EXP 9
10362: PPUSH
10363: LD_STRING D
10365: PUSH
10366: LD_STRING I
10368: PUSH
10369: LD_STRING J
10371: PUSH
10372: LD_STRING S
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: PUSH
10380: LD_EXP 25
10384: ARRAY
10385: STR
10386: PUSH
10387: LD_STRING -1-DAR
10389: STR
10390: PPUSH
10391: CALL_OW 88
// end ; if not reinforceAllowed then
10395: LD_EXP 24
10399: NOT
10400: IFFALSE 10404
// exit ;
10402: GO 10558
// wait ( 25 25$00 ) ;
10404: LD_INT 52500
10406: PPUSH
10407: CALL_OW 67
// uc_side := 1 ;
10411: LD_ADDR_OWVAR 20
10415: PUSH
10416: LD_INT 1
10418: ST_TO_ADDR
// uc_nation := 1 ;
10419: LD_ADDR_OWVAR 21
10423: PUSH
10424: LD_INT 1
10426: ST_TO_ADDR
// InitVc ;
10427: CALL_OW 20
// InitHc ;
10431: CALL_OW 19
// for i = 1 to 4 do
10435: LD_ADDR_VAR 0 2
10439: PUSH
10440: DOUBLE
10441: LD_INT 1
10443: DEC
10444: ST_TO_ADDR
10445: LD_INT 4
10447: PUSH
10448: FOR_TO
10449: IFFALSE 10556
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10451: LD_INT 5
10453: PPUSH
10454: LD_INT 3
10456: PPUSH
10457: LD_INT 1
10459: PPUSH
10460: LD_INT 6
10462: PPUSH
10463: LD_INT 1
10465: PPUSH
10466: CALL 24679 0 5
// veh := CreateVehicle ;
10470: LD_ADDR_VAR 0 6
10474: PUSH
10475: CALL_OW 45
10479: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10480: LD_VAR 0 6
10484: PPUSH
10485: LD_INT 19
10487: PPUSH
10488: LD_INT 0
10490: PPUSH
10491: CALL 56435 0 3
// if GetControl ( veh ) = control_manual then
10495: LD_VAR 0 6
10499: PPUSH
10500: CALL_OW 263
10504: PUSH
10505: LD_INT 1
10507: EQUAL
10508: IFFALSE 10554
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10510: LD_INT 0
10512: PPUSH
10513: LD_INT 3
10515: PPUSH
10516: LD_INT 7
10518: PUSH
10519: LD_INT 6
10521: PUSH
10522: LD_INT 5
10524: PUSH
10525: EMPTY
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: LD_OWVAR 67
10534: ARRAY
10535: PPUSH
10536: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10540: CALL_OW 44
10544: PPUSH
10545: LD_VAR 0 6
10549: PPUSH
10550: CALL_OW 52
// end ; end ;
10554: GO 10448
10556: POP
10557: POP
// end ;
10558: LD_VAR 0 1
10562: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10563: LD_INT 0
10565: PPUSH
10566: PPUSH
10567: PPUSH
10568: PPUSH
10569: PPUSH
// uc_side := 8 ;
10570: LD_ADDR_OWVAR 20
10574: PUSH
10575: LD_INT 8
10577: ST_TO_ADDR
// uc_nation := nation_arabian ;
10578: LD_ADDR_OWVAR 21
10582: PUSH
10583: LD_INT 2
10585: ST_TO_ADDR
// for i = 1 to 2 do
10586: LD_ADDR_VAR 0 2
10590: PUSH
10591: DOUBLE
10592: LD_INT 1
10594: DEC
10595: ST_TO_ADDR
10596: LD_INT 2
10598: PUSH
10599: FOR_TO
10600: IFFALSE 10680
// for j = 1 to 4 do
10602: LD_ADDR_VAR 0 4
10606: PUSH
10607: DOUBLE
10608: LD_INT 1
10610: DEC
10611: ST_TO_ADDR
10612: LD_INT 4
10614: PUSH
10615: FOR_TO
10616: IFFALSE 10676
// begin PrepareHuman ( false , j , 8 ) ;
10618: LD_INT 0
10620: PPUSH
10621: LD_VAR 0 4
10625: PPUSH
10626: LD_INT 8
10628: PPUSH
10629: CALL_OW 380
// un := CreateHuman ;
10633: LD_ADDR_VAR 0 3
10637: PUSH
10638: CALL_OW 44
10642: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10643: LD_VAR 0 3
10647: PPUSH
10648: LD_INT 23
10650: PPUSH
10651: LD_INT 0
10653: PPUSH
10654: CALL_OW 49
// tmp := tmp union un ;
10658: LD_ADDR_VAR 0 5
10662: PUSH
10663: LD_VAR 0 5
10667: PUSH
10668: LD_VAR 0 3
10672: UNION
10673: ST_TO_ADDR
// end ;
10674: GO 10615
10676: POP
10677: POP
10678: GO 10599
10680: POP
10681: POP
// for i in tmp do
10682: LD_ADDR_VAR 0 2
10686: PUSH
10687: LD_VAR 0 5
10691: PUSH
10692: FOR_IN
10693: IFFALSE 10712
// ComMoveXY ( i , 150 , 136 ) ;
10695: LD_VAR 0 2
10699: PPUSH
10700: LD_INT 150
10702: PPUSH
10703: LD_INT 136
10705: PPUSH
10706: CALL_OW 111
10710: GO 10692
10712: POP
10713: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10714: LD_ADDR_EXP 31
10718: PUSH
10719: LD_EXP 31
10723: PPUSH
10724: LD_EXP 6
10728: PPUSH
10729: LD_EXP 31
10733: PUSH
10734: LD_EXP 6
10738: ARRAY
10739: PUSH
10740: LD_VAR 0 5
10744: UNION
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// end ;
10751: LD_VAR 0 1
10755: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10756: LD_OWVAR 67
10760: PUSH
10761: LD_INT 1
10763: GREATER
10764: PUSH
10765: LD_INT 31
10767: PPUSH
10768: LD_INT 3
10770: PPUSH
10771: CALL_OW 321
10775: PUSH
10776: LD_INT 2
10778: EQUAL
10779: AND
10780: IFFALSE 10997
10782: GO 10784
10784: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10785: LD_EXP 7
10789: PPUSH
10790: LD_INT 33
10792: PUSH
10793: LD_INT 101
10795: PUSH
10796: LD_INT 159
10798: PUSH
10799: LD_INT 5
10801: PUSH
10802: EMPTY
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: PUSH
10808: LD_INT 33
10810: PUSH
10811: LD_INT 105
10813: PUSH
10814: LD_INT 158
10816: PUSH
10817: LD_INT 5
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 33
10828: PUSH
10829: LD_INT 96
10831: PUSH
10832: LD_INT 136
10834: PUSH
10835: LD_INT 5
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: PUSH
10844: LD_INT 33
10846: PUSH
10847: LD_INT 94
10849: PUSH
10850: LD_INT 133
10852: PUSH
10853: LD_INT 4
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: PUSH
10862: LD_INT 33
10864: PUSH
10865: LD_INT 84
10867: PUSH
10868: LD_INT 102
10870: PUSH
10871: LD_INT 4
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: PPUSH
10887: CALL 86784 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10891: LD_EXP 8
10895: PPUSH
10896: LD_INT 33
10898: PUSH
10899: LD_INT 50
10901: PUSH
10902: LD_INT 17
10904: PUSH
10905: LD_INT 4
10907: PUSH
10908: EMPTY
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: PUSH
10914: LD_INT 33
10916: PUSH
10917: LD_INT 52
10919: PUSH
10920: LD_INT 20
10922: PUSH
10923: LD_INT 4
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 33
10934: PUSH
10935: LD_INT 53
10937: PUSH
10938: LD_INT 23
10940: PUSH
10941: LD_INT 4
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: PUSH
10950: LD_INT 33
10952: PUSH
10953: LD_INT 45
10955: PUSH
10956: LD_INT 32
10958: PUSH
10959: LD_INT 4
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: PUSH
10968: LD_INT 33
10970: PUSH
10971: LD_INT 45
10973: PUSH
10974: LD_INT 39
10976: PUSH
10977: LD_INT 4
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: LIST
10984: LIST
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: LIST
10990: LIST
10991: LIST
10992: PPUSH
10993: CALL 86784 0 2
// end ;
10997: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
10998: LD_INT 3
11000: PUSH
11001: LD_INT 22
11003: PUSH
11004: LD_OWVAR 2
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: PUSH
11017: LD_INT 33
11019: PUSH
11020: LD_INT 2
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: PUSH
11027: LD_INT 50
11029: PUSH
11030: EMPTY
11031: LIST
11032: PUSH
11033: LD_INT 3
11035: PUSH
11036: LD_INT 61
11038: PUSH
11039: EMPTY
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: LIST
11045: PUSH
11046: EMPTY
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: PPUSH
11052: CALL_OW 69
11056: IFFALSE 11156
11058: GO 11060
11060: DISABLE
11061: LD_INT 0
11063: PPUSH
11064: PPUSH
// begin enable ;
11065: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11066: LD_ADDR_VAR 0 2
11070: PUSH
11071: LD_INT 3
11073: PUSH
11074: LD_INT 22
11076: PUSH
11077: LD_OWVAR 2
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: PUSH
11086: EMPTY
11087: LIST
11088: LIST
11089: PUSH
11090: LD_INT 33
11092: PUSH
11093: LD_INT 2
11095: PUSH
11096: EMPTY
11097: LIST
11098: LIST
11099: PUSH
11100: LD_INT 50
11102: PUSH
11103: EMPTY
11104: LIST
11105: PUSH
11106: LD_INT 3
11108: PUSH
11109: LD_INT 61
11111: PUSH
11112: EMPTY
11113: LIST
11114: PUSH
11115: EMPTY
11116: LIST
11117: LIST
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: LIST
11123: LIST
11124: PPUSH
11125: CALL_OW 69
11129: ST_TO_ADDR
// for i in tmp do
11130: LD_ADDR_VAR 0 1
11134: PUSH
11135: LD_VAR 0 2
11139: PUSH
11140: FOR_IN
11141: IFFALSE 11154
// Connect ( i ) ;
11143: LD_VAR 0 1
11147: PPUSH
11148: CALL 28147 0 1
11152: GO 11140
11154: POP
11155: POP
// end ; end_of_file
11156: PPOPN 2
11158: END
// export function Action ; var i , tmp ; begin
11159: LD_INT 0
11161: PPUSH
11162: PPUSH
11163: PPUSH
// InGameOn ;
11164: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11168: LD_INT 225
11170: PPUSH
11171: LD_INT 217
11173: PPUSH
11174: CALL_OW 86
// for i in playerForces [ 2 ] do
11178: LD_ADDR_VAR 0 2
11182: PUSH
11183: LD_EXP 10
11187: PUSH
11188: LD_INT 2
11190: ARRAY
11191: PUSH
11192: FOR_IN
11193: IFFALSE 11326
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11195: LD_EXP 10
11199: PUSH
11200: LD_INT 1
11202: ARRAY
11203: PUSH
11204: LD_VAR 0 2
11208: PPUSH
11209: CALL_OW 257
11213: PUSH
11214: LD_INT 3
11216: PUSH
11217: LD_INT 4
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: IN
11224: AND
11225: IFFALSE 11309
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11227: LD_EXP 10
11231: PUSH
11232: LD_INT 1
11234: ARRAY
11235: PUSH
11236: LD_INT 1
11238: ARRAY
11239: PPUSH
11240: LD_INT 19
11242: PPUSH
11243: LD_INT 0
11245: PPUSH
11246: CALL 56435 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11250: LD_VAR 0 2
11254: PPUSH
11255: LD_EXP 10
11259: PUSH
11260: LD_INT 1
11262: ARRAY
11263: PUSH
11264: LD_INT 1
11266: ARRAY
11267: PPUSH
11268: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11272: LD_ADDR_EXP 10
11276: PUSH
11277: LD_EXP 10
11281: PPUSH
11282: LD_INT 1
11284: PPUSH
11285: LD_EXP 10
11289: PUSH
11290: LD_INT 1
11292: ARRAY
11293: PPUSH
11294: LD_INT 1
11296: PPUSH
11297: CALL_OW 3
11301: PPUSH
11302: CALL_OW 1
11306: ST_TO_ADDR
// end else
11307: GO 11324
// PlaceUnitInArea ( i , startArea , false ) ;
11309: LD_VAR 0 2
11313: PPUSH
11314: LD_INT 19
11316: PPUSH
11317: LD_INT 0
11319: PPUSH
11320: CALL 56435 0 3
// end ;
11324: GO 11192
11326: POP
11327: POP
// wait ( 0 0$2 ) ;
11328: LD_INT 70
11330: PPUSH
11331: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11335: LD_EXP 9
11339: PPUSH
11340: LD_STRING D
11342: PUSH
11343: LD_STRING I
11345: PUSH
11346: LD_STRING J
11348: PUSH
11349: LD_STRING S
11351: PUSH
11352: EMPTY
11353: LIST
11354: LIST
11355: LIST
11356: PUSH
11357: LD_EXP 25
11361: ARRAY
11362: STR
11363: PUSH
11364: LD_STRING -1
11366: STR
11367: PPUSH
11368: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11372: LD_EXP 12
11376: PPUSH
11377: LD_STRING DP-1
11379: PPUSH
11380: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11384: LD_EXP 12
11388: PPUSH
11389: LD_STRING DP-2
11391: PPUSH
11392: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11396: LD_EXP 9
11400: PPUSH
11401: LD_STRING D
11403: PUSH
11404: LD_STRING I
11406: PUSH
11407: LD_STRING J
11409: PUSH
11410: LD_STRING S
11412: PUSH
11413: EMPTY
11414: LIST
11415: LIST
11416: LIST
11417: PUSH
11418: LD_EXP 25
11422: ARRAY
11423: STR
11424: PUSH
11425: LD_STRING -2
11427: STR
11428: PPUSH
11429: CALL_OW 88
// InGameOff ;
11433: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11437: LD_STRING O1
11439: PPUSH
11440: CALL_OW 337
// game := true ;
11444: LD_ADDR_EXP 3
11448: PUSH
11449: LD_INT 1
11451: ST_TO_ADDR
// SaveForQuickRestart ;
11452: CALL_OW 22
// wait ( 0 0$5 ) ;
11456: LD_INT 175
11458: PPUSH
11459: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11463: LD_EXP 9
11467: PPUSH
11468: LD_STRING D
11470: PUSH
11471: LD_STRING I
11473: PUSH
11474: LD_STRING J
11476: PUSH
11477: LD_STRING S
11479: PUSH
11480: EMPTY
11481: LIST
11482: LIST
11483: LIST
11484: PUSH
11485: LD_EXP 25
11489: ARRAY
11490: STR
11491: PUSH
11492: LD_STRING -3
11494: STR
11495: PPUSH
11496: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11500: LD_INT 35
11502: PPUSH
11503: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11507: LD_EXP 15
11511: PUSH
11512: LD_INT 1
11514: ARRAY
11515: PUSH
11516: LD_EXP 15
11520: PUSH
11521: LD_INT 2
11523: ARRAY
11524: GREATEREQUAL
11525: IFFALSE 11500
// outpostEscape := true ;
11527: LD_ADDR_EXP 27
11531: PUSH
11532: LD_INT 1
11534: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11535: LD_ADDR_VAR 0 3
11539: PUSH
11540: LD_EXP 14
11544: PPUSH
11545: LD_INT 26
11547: PUSH
11548: LD_INT 1
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: PPUSH
11555: CALL_OW 72
11559: ST_TO_ADDR
// if tmp then
11560: LD_VAR 0 3
11564: IFFALSE 11582
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11566: LD_VAR 0 3
11570: PUSH
11571: LD_INT 1
11573: ARRAY
11574: PPUSH
11575: LD_STRING DR-1-Escape
11577: PPUSH
11578: CALL_OW 88
// wait ( 0 0$1 ) ;
11582: LD_INT 35
11584: PPUSH
11585: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11589: LD_EXP 9
11593: PPUSH
11594: LD_STRING D
11596: PUSH
11597: LD_STRING I
11599: PUSH
11600: LD_STRING J
11602: PUSH
11603: LD_STRING S
11605: PUSH
11606: EMPTY
11607: LIST
11608: LIST
11609: LIST
11610: PUSH
11611: LD_EXP 25
11615: ARRAY
11616: STR
11617: PUSH
11618: LD_STRING -1-Escape
11620: STR
11621: PPUSH
11622: CALL_OW 88
// for i in ruOutpost do
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_EXP 14
11635: PUSH
11636: FOR_IN
11637: IFFALSE 11691
// begin if IsInUnit ( i ) then
11639: LD_VAR 0 2
11643: PPUSH
11644: CALL_OW 310
11648: IFFALSE 11659
// ComExitBuilding ( i ) ;
11650: LD_VAR 0 2
11654: PPUSH
11655: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11659: LD_VAR 0 2
11663: PPUSH
11664: LD_INT 179
11666: PPUSH
11667: LD_INT 102
11669: PPUSH
11670: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11674: LD_VAR 0 2
11678: PPUSH
11679: LD_INT 28
11681: PPUSH
11682: LD_INT 20
11684: PPUSH
11685: CALL_OW 171
// end ;
11689: GO 11636
11691: POP
11692: POP
// tmp := [ ] ;
11693: LD_ADDR_VAR 0 3
11697: PUSH
11698: EMPTY
11699: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11700: LD_INT 35
11702: PPUSH
11703: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11707: LD_ADDR_VAR 0 3
11711: PUSH
11712: LD_EXP 14
11716: PPUSH
11717: LD_INT 95
11719: PUSH
11720: LD_INT 11
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PPUSH
11727: CALL_OW 72
11731: ST_TO_ADDR
// if tmp then
11732: LD_VAR 0 3
11736: IFFALSE 11815
// for i in tmp do
11738: LD_ADDR_VAR 0 2
11742: PUSH
11743: LD_VAR 0 3
11747: PUSH
11748: FOR_IN
11749: IFFALSE 11813
// begin ruOutpost := ruOutpost diff i ;
11751: LD_ADDR_EXP 14
11755: PUSH
11756: LD_EXP 14
11760: PUSH
11761: LD_VAR 0 2
11765: DIFF
11766: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11767: LD_ADDR_EXP 31
11771: PUSH
11772: LD_EXP 31
11776: PPUSH
11777: LD_EXP 8
11781: PUSH
11782: LD_EXP 31
11786: PUSH
11787: LD_EXP 8
11791: ARRAY
11792: PUSH
11793: LD_INT 1
11795: PLUS
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PPUSH
11801: LD_VAR 0 2
11805: PPUSH
11806: CALL 24801 0 3
11810: ST_TO_ADDR
// end ;
11811: GO 11748
11813: POP
11814: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11815: LD_EXP 14
11819: PPUSH
11820: LD_INT 21
11822: PUSH
11823: LD_INT 1
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PPUSH
11830: CALL_OW 72
11834: NOT
11835: IFFALSE 11700
// ruOutpost := [ ] ;
11837: LD_ADDR_EXP 14
11841: PUSH
11842: EMPTY
11843: ST_TO_ADDR
// end ;
11844: LD_VAR 0 1
11848: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11849: LD_EXP 27
11853: IFFALSE 12042
11855: GO 11857
11857: DISABLE
11858: LD_INT 0
11860: PPUSH
11861: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11862: LD_INT 875
11864: PPUSH
11865: LD_INT 1225
11867: PPUSH
11868: CALL_OW 12
11872: PPUSH
11873: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11877: LD_ADDR_VAR 0 2
11881: PUSH
11882: LD_INT 208
11884: PUSH
11885: LD_INT 166
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: LD_INT 218
11894: PUSH
11895: LD_INT 174
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: PUSH
11902: LD_INT 201
11904: PUSH
11905: LD_INT 173
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 189
11914: PUSH
11915: LD_INT 167
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PUSH
11922: LD_INT 191
11924: PUSH
11925: LD_INT 160
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PUSH
11932: LD_INT 209
11934: PUSH
11935: LD_INT 181
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PUSH
11942: LD_INT 192
11944: PUSH
11945: LD_INT 162
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: PUSH
11952: LD_INT 197
11954: PUSH
11955: LD_INT 166
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
11972: LD_ADDR_VAR 0 1
11976: PUSH
11977: DOUBLE
11978: LD_INT 1
11980: DEC
11981: ST_TO_ADDR
11982: LD_INT 5
11984: PUSH
11985: LD_OWVAR 67
11989: PLUS
11990: PUSH
11991: FOR_TO
11992: IFFALSE 12040
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
11994: LD_VAR 0 2
11998: PUSH
11999: LD_VAR 0 1
12003: ARRAY
12004: PUSH
12005: LD_INT 1
12007: ARRAY
12008: PPUSH
12009: LD_VAR 0 2
12013: PUSH
12014: LD_VAR 0 1
12018: ARRAY
12019: PUSH
12020: LD_INT 2
12022: ARRAY
12023: PPUSH
12024: LD_INT 1
12026: PPUSH
12027: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12031: LD_INT 28
12033: PPUSH
12034: CALL_OW 67
// end ;
12038: GO 11991
12040: POP
12041: POP
// end ;
12042: PPOPN 2
12044: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12045: LD_EXP 27
12049: NOT
12050: IFFALSE 12704
12052: GO 12054
12054: DISABLE
12055: LD_INT 0
12057: PPUSH
12058: PPUSH
12059: PPUSH
12060: PPUSH
12061: PPUSH
12062: PPUSH
12063: PPUSH
// begin enable ;
12064: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12065: LD_ADDR_VAR 0 1
12069: PUSH
12070: LD_EXP 14
12074: PPUSH
12075: LD_INT 22
12077: PUSH
12078: LD_INT 3
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PUSH
12085: LD_INT 25
12087: PUSH
12088: LD_INT 1
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: EMPTY
12096: LIST
12097: LIST
12098: PPUSH
12099: CALL_OW 72
12103: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12104: LD_ADDR_VAR 0 2
12108: PUSH
12109: LD_EXP 14
12113: PPUSH
12114: LD_INT 22
12116: PUSH
12117: LD_INT 3
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PUSH
12124: LD_INT 25
12126: PUSH
12127: LD_INT 2
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 72
12142: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12143: LD_ADDR_VAR 0 3
12147: PUSH
12148: LD_EXP 14
12152: PPUSH
12153: LD_INT 22
12155: PUSH
12156: LD_INT 3
12158: PUSH
12159: EMPTY
12160: LIST
12161: LIST
12162: PUSH
12163: LD_INT 21
12165: PUSH
12166: LD_INT 3
12168: PUSH
12169: EMPTY
12170: LIST
12171: LIST
12172: PUSH
12173: LD_INT 3
12175: PUSH
12176: LD_INT 24
12178: PUSH
12179: LD_INT 1000
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: PPUSH
12195: CALL_OW 72
12199: ST_TO_ADDR
// if engs and buildings then
12200: LD_VAR 0 2
12204: PUSH
12205: LD_VAR 0 3
12209: AND
12210: IFFALSE 12283
// begin for i in engs do
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_VAR 0 2
12221: PUSH
12222: FOR_IN
12223: IFFALSE 12279
// if IsInUnit ( i ) then
12225: LD_VAR 0 5
12229: PPUSH
12230: CALL_OW 310
12234: IFFALSE 12247
// ComExitBuilding ( i ) else
12236: LD_VAR 0 5
12240: PPUSH
12241: CALL_OW 122
12245: GO 12277
// if not HasTask ( i ) then
12247: LD_VAR 0 5
12251: PPUSH
12252: CALL_OW 314
12256: NOT
12257: IFFALSE 12277
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12259: LD_VAR 0 5
12263: PPUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_INT 1
12271: ARRAY
12272: PPUSH
12273: CALL_OW 130
12277: GO 12222
12279: POP
12280: POP
// end else
12281: GO 12386
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12283: LD_VAR 0 3
12287: NOT
12288: PUSH
12289: LD_EXP 14
12293: PPUSH
12294: LD_INT 30
12296: PUSH
12297: LD_INT 0
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: PPUSH
12304: CALL_OW 72
12308: AND
12309: PUSH
12310: LD_VAR 0 2
12314: PPUSH
12315: LD_INT 3
12317: PUSH
12318: LD_INT 54
12320: PUSH
12321: EMPTY
12322: LIST
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PPUSH
12328: CALL_OW 72
12332: AND
12333: IFFALSE 12386
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12335: LD_VAR 0 2
12339: PPUSH
12340: LD_INT 3
12342: PUSH
12343: LD_INT 54
12345: PUSH
12346: EMPTY
12347: LIST
12348: PUSH
12349: EMPTY
12350: LIST
12351: LIST
12352: PPUSH
12353: CALL_OW 72
12357: PPUSH
12358: LD_EXP 14
12362: PPUSH
12363: LD_INT 30
12365: PUSH
12366: LD_INT 0
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: PUSH
12378: LD_INT 1
12380: ARRAY
12381: PPUSH
12382: CALL_OW 120
// if not tmp then
12386: LD_VAR 0 1
12390: NOT
12391: IFFALSE 12395
// exit ;
12393: GO 12704
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12395: LD_INT 26
12397: PPUSH
12398: LD_INT 81
12400: PUSH
12401: LD_INT 3
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PPUSH
12408: CALL_OW 70
12412: PUSH
12413: LD_INT 1
12415: GREATER
12416: IFFALSE 12472
// begin for i in tmp do
12418: LD_ADDR_VAR 0 5
12422: PUSH
12423: LD_VAR 0 1
12427: PUSH
12428: FOR_IN
12429: IFFALSE 12468
// begin if IsInUnit ( i ) then
12431: LD_VAR 0 5
12435: PPUSH
12436: CALL_OW 310
12440: IFFALSE 12451
// ComExitBuilding ( i ) ;
12442: LD_VAR 0 5
12446: PPUSH
12447: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12451: LD_VAR 0 5
12455: PPUSH
12456: LD_INT 204
12458: PPUSH
12459: LD_INT 164
12461: PPUSH
12462: CALL_OW 174
// end ;
12466: GO 12428
12468: POP
12469: POP
// end else
12470: GO 12704
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12472: LD_VAR 0 1
12476: PPUSH
12477: LD_INT 3
12479: PUSH
12480: LD_INT 54
12482: PUSH
12483: EMPTY
12484: LIST
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PPUSH
12490: CALL_OW 72
12494: IFFALSE 12704
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12496: LD_ADDR_VAR 0 4
12500: PUSH
12501: LD_EXP 14
12505: PPUSH
12506: LD_INT 30
12508: PUSH
12509: LD_INT 32
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 58
12518: PUSH
12519: EMPTY
12520: LIST
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PPUSH
12526: CALL_OW 72
12530: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12531: LD_VAR 0 4
12535: NOT
12536: PUSH
12537: LD_EXP 14
12541: PPUSH
12542: LD_INT 30
12544: PUSH
12545: LD_INT 5
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PPUSH
12552: CALL_OW 72
12556: AND
12557: IFFALSE 12594
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12559: LD_VAR 0 1
12563: PPUSH
12564: LD_EXP 14
12568: PPUSH
12569: LD_INT 30
12571: PUSH
12572: LD_INT 5
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PPUSH
12579: CALL_OW 72
12583: PUSH
12584: LD_INT 1
12586: ARRAY
12587: PPUSH
12588: CALL_OW 120
// exit ;
12592: GO 12704
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12594: LD_ADDR_VAR 0 6
12598: PUSH
12599: LD_VAR 0 1
12603: PPUSH
12604: LD_INT 3
12606: PUSH
12607: LD_INT 54
12609: PUSH
12610: EMPTY
12611: LIST
12612: PUSH
12613: EMPTY
12614: LIST
12615: LIST
12616: PPUSH
12617: CALL_OW 72
12621: ST_TO_ADDR
// if j < empty then
12622: LD_VAR 0 6
12626: PUSH
12627: LD_VAR 0 4
12631: LESS
12632: IFFALSE 12646
// k := j else
12634: LD_ADDR_VAR 0 7
12638: PUSH
12639: LD_VAR 0 6
12643: ST_TO_ADDR
12644: GO 12656
// k := empty ;
12646: LD_ADDR_VAR 0 7
12650: PUSH
12651: LD_VAR 0 4
12655: ST_TO_ADDR
// for i = 1 to k do
12656: LD_ADDR_VAR 0 5
12660: PUSH
12661: DOUBLE
12662: LD_INT 1
12664: DEC
12665: ST_TO_ADDR
12666: LD_VAR 0 7
12670: PUSH
12671: FOR_TO
12672: IFFALSE 12702
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12674: LD_VAR 0 6
12678: PUSH
12679: LD_VAR 0 5
12683: ARRAY
12684: PPUSH
12685: LD_VAR 0 4
12689: PUSH
12690: LD_VAR 0 5
12694: ARRAY
12695: PPUSH
12696: CALL_OW 120
12700: GO 12671
12702: POP
12703: POP
// end ; end ;
12704: PPOPN 7
12706: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12707: LD_EXP 2
12711: PUSH
12712: LD_INT 1
12714: EQUAL
12715: PUSH
12716: LD_EXP 27
12720: AND
12721: PUSH
12722: LD_INT 22
12724: PUSH
12725: LD_INT 1
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PUSH
12732: LD_INT 92
12734: PUSH
12735: LD_INT 208
12737: PUSH
12738: LD_INT 163
12740: PUSH
12741: LD_INT 8
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PPUSH
12754: CALL_OW 69
12758: AND
12759: PUSH
12760: LD_INT 22
12762: PUSH
12763: LD_INT 3
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 21
12772: PUSH
12773: LD_INT 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 92
12782: PUSH
12783: LD_INT 208
12785: PUSH
12786: LD_INT 163
12788: PUSH
12789: LD_INT 14
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: PPUSH
12803: CALL_OW 69
12807: NOT
12808: AND
12809: IFFALSE 13114
12811: GO 12813
12813: DISABLE
12814: LD_INT 0
12816: PPUSH
// begin InGameOn ;
12817: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12821: LD_EXP 9
12825: PPUSH
12826: CALL_OW 87
// wait ( 0 0$1 ) ;
12830: LD_INT 35
12832: PPUSH
12833: CALL_OW 67
// DialogueOn ;
12837: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12841: LD_EXP 9
12845: PPUSH
12846: LD_STRING D
12848: PUSH
12849: LD_STRING I
12851: PUSH
12852: LD_STRING J
12854: PUSH
12855: LD_STRING S
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: PUSH
12863: LD_EXP 25
12867: ARRAY
12868: STR
12869: PUSH
12870: LD_STRING -1-BaseCaptured
12872: STR
12873: PPUSH
12874: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12878: LD_EXP 12
12882: PPUSH
12883: LD_STRING DP-1-BaseCaptured
12885: PPUSH
12886: CALL_OW 94
// if sibBombAllowed then
12890: LD_EXP 23
12894: IFFALSE 13036
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12896: LD_EXP 9
12900: PPUSH
12901: LD_STRING D
12903: PUSH
12904: LD_STRING I
12906: PUSH
12907: LD_STRING J
12909: PUSH
12910: LD_STRING S
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: LIST
12917: PUSH
12918: LD_EXP 25
12922: ARRAY
12923: STR
12924: PUSH
12925: LD_STRING -2-BaseCaptured
12927: STR
12928: PPUSH
12929: CALL_OW 88
// if commander = 1 then
12933: LD_EXP 25
12937: PUSH
12938: LD_INT 1
12940: EQUAL
12941: IFFALSE 12955
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12943: LD_EXP 12
12947: PPUSH
12948: LD_STRING DP-2b-BaseCaptured
12950: PPUSH
12951: CALL_OW 94
// if commander = 2 then
12955: LD_EXP 25
12959: PUSH
12960: LD_INT 2
12962: EQUAL
12963: IFFALSE 12977
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
12965: LD_EXP 12
12969: PPUSH
12970: LD_STRING DP-2-BaseCaptured
12972: PPUSH
12973: CALL_OW 94
// if commander = 3 then
12977: LD_EXP 25
12981: PUSH
12982: LD_INT 3
12984: EQUAL
12985: IFFALSE 12999
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
12987: LD_EXP 12
12991: PPUSH
12992: LD_STRING DP-2a-BaseCaptured
12994: PPUSH
12995: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
12999: LD_EXP 9
13003: PPUSH
13004: LD_STRING D
13006: PUSH
13007: LD_STRING I
13009: PUSH
13010: LD_STRING J
13012: PUSH
13013: LD_STRING S
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: PUSH
13021: LD_EXP 25
13025: ARRAY
13026: STR
13027: PUSH
13028: LD_STRING -3-BaseCaptured
13030: STR
13031: PPUSH
13032: CALL_OW 88
// end ; DialogueOff ;
13036: CALL_OW 7
// InGameOff ;
13040: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13044: LD_STRING O2
13046: PPUSH
13047: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13051: LD_ADDR_VAR 0 1
13055: PUSH
13056: LD_EXP 14
13060: PPUSH
13061: LD_INT 21
13063: PUSH
13064: LD_INT 3
13066: PUSH
13067: EMPTY
13068: LIST
13069: LIST
13070: PPUSH
13071: CALL_OW 72
13075: PUSH
13076: FOR_IN
13077: IFFALSE 13093
// SetSide ( i , 1 ) ;
13079: LD_VAR 0 1
13083: PPUSH
13084: LD_INT 1
13086: PPUSH
13087: CALL_OW 235
13091: GO 13076
13093: POP
13094: POP
// baseCaptured := true ;
13095: LD_ADDR_EXP 17
13099: PUSH
13100: LD_INT 1
13102: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13103: LD_INT 1225
13105: PPUSH
13106: CALL_OW 67
// PrepareReinforcements ;
13110: CALL 9863 0 0
// end ;
13114: PPOPN 1
13116: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13117: LD_INT 22
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 92
13129: PUSH
13130: LD_INT 167
13132: PUSH
13133: LD_INT 197
13135: PUSH
13136: LD_INT 20
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: PPUSH
13149: CALL_OW 69
13153: PUSH
13154: LD_INT 3
13156: GREATER
13157: IFFALSE 13174
13159: GO 13161
13161: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13162: LD_EXP 12
13166: PPUSH
13167: LD_STRING DP-RuAttack
13169: PPUSH
13170: CALL_OW 94
13174: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13175: LD_EXP 1
13179: NOT
13180: PUSH
13181: LD_INT 1
13183: PPUSH
13184: LD_INT 168
13186: PPUSH
13187: LD_INT 74
13189: PPUSH
13190: CALL_OW 293
13194: AND
13195: PUSH
13196: LD_INT 168
13198: PPUSH
13199: LD_INT 72
13201: PPUSH
13202: CALL_OW 553
13206: AND
13207: IFFALSE 13259
13209: GO 13211
13211: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13212: LD_INT 168
13214: PPUSH
13215: LD_INT 72
13217: PPUSH
13218: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13222: LD_EXP 9
13226: PPUSH
13227: LD_STRING D
13229: PUSH
13230: LD_STRING I
13232: PUSH
13233: LD_STRING J
13235: PUSH
13236: LD_STRING S
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: LIST
13243: PUSH
13244: LD_EXP 25
13248: ARRAY
13249: STR
13250: PUSH
13251: LD_STRING -1-Blockade
13253: STR
13254: PPUSH
13255: CALL_OW 88
// end ;
13259: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13260: LD_EXP 2
13264: PUSH
13265: LD_INT 1
13267: EQUAL
13268: PUSH
13269: LD_INT 22
13271: PUSH
13272: LD_INT 1
13274: PUSH
13275: EMPTY
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 101
13281: PUSH
13282: LD_INT 4
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: PPUSH
13293: CALL_OW 69
13297: AND
13298: IFFALSE 13830
13300: GO 13302
13302: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13303: LD_INT 4
13305: PPUSH
13306: LD_INT 1
13308: PPUSH
13309: CALL_OW 343
// DialogueOn ;
13313: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13317: LD_EXP 11
13321: PPUSH
13322: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13326: LD_EXP 11
13330: PPUSH
13331: LD_STRING DM-1-Contact
13333: PPUSH
13334: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13338: LD_EXP 9
13342: PPUSH
13343: LD_STRING D
13345: PUSH
13346: LD_STRING I
13348: PUSH
13349: LD_STRING J
13351: PUSH
13352: LD_STRING S
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: LIST
13359: PUSH
13360: LD_EXP 25
13364: ARRAY
13365: STR
13366: PUSH
13367: LD_STRING -1-Contact
13369: STR
13370: PPUSH
13371: CALL_OW 88
// if commander = 1 then
13375: LD_EXP 25
13379: PUSH
13380: LD_INT 1
13382: EQUAL
13383: IFFALSE 13515
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13385: LD_EXP 11
13389: PPUSH
13390: LD_STRING DM-2-Contact
13392: PPUSH
13393: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13397: LD_EXP 9
13401: PPUSH
13402: LD_STRING DI-2-Contact
13404: PPUSH
13405: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13409: LD_INT 22
13411: PUSH
13412: LD_INT 8
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 21
13421: PUSH
13422: LD_INT 1
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PPUSH
13433: CALL_OW 69
13437: PUSH
13438: LD_INT 8
13440: PPUSH
13441: LD_INT 1
13443: PPUSH
13444: CALL_OW 81
13448: PUSH
13449: LD_INT 2
13451: EQUAL
13452: AND
13453: IFFALSE 13479
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13455: LD_EXP 11
13459: PPUSH
13460: LD_STRING DM-3-Contact
13462: PPUSH
13463: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13467: LD_EXP 9
13471: PPUSH
13472: LD_STRING DI-3-Contact
13474: PPUSH
13475: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13479: LD_EXP 11
13483: PPUSH
13484: LD_STRING DM-4-Contact
13486: PPUSH
13487: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13491: LD_EXP 9
13495: PPUSH
13496: LD_STRING DI-4-Contact
13498: PPUSH
13499: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13503: LD_EXP 11
13507: PPUSH
13508: LD_STRING DM-5-Contact
13510: PPUSH
13511: CALL_OW 94
// end ; if commander = 2 then
13515: LD_EXP 25
13519: PUSH
13520: LD_INT 2
13522: EQUAL
13523: IFFALSE 13655
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13525: LD_EXP 11
13529: PPUSH
13530: LD_STRING DM-2c-Contact
13532: PPUSH
13533: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13537: LD_EXP 9
13541: PPUSH
13542: LD_STRING DJ-2-Contact
13544: PPUSH
13545: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13549: LD_INT 22
13551: PUSH
13552: LD_INT 8
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 21
13561: PUSH
13562: LD_INT 1
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 69
13577: PUSH
13578: LD_INT 8
13580: PPUSH
13581: LD_INT 1
13583: PPUSH
13584: CALL_OW 81
13588: PUSH
13589: LD_INT 2
13591: EQUAL
13592: AND
13593: IFFALSE 13619
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13595: LD_EXP 11
13599: PPUSH
13600: LD_STRING DM-3-Contact
13602: PPUSH
13603: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13607: LD_EXP 9
13611: PPUSH
13612: LD_STRING DJ-3-Contact
13614: PPUSH
13615: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13619: LD_EXP 11
13623: PPUSH
13624: LD_STRING DM-4-Contact
13626: PPUSH
13627: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13631: LD_EXP 9
13635: PPUSH
13636: LD_STRING DJ-4-Contact
13638: PPUSH
13639: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13643: LD_EXP 11
13647: PPUSH
13648: LD_STRING DM-5a-Contact
13650: PPUSH
13651: CALL_OW 94
// end ; if commander = 3 then
13655: LD_EXP 25
13659: PUSH
13660: LD_INT 3
13662: EQUAL
13663: IFFALSE 13819
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13665: LD_EXP 11
13669: PPUSH
13670: LD_STRING DM-2a-Contact
13672: PPUSH
13673: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13677: LD_EXP 9
13681: PPUSH
13682: LD_STRING DS-2a-Contact
13684: PPUSH
13685: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13689: LD_EXP 11
13693: PPUSH
13694: LD_STRING DM-2b-Contact
13696: PPUSH
13697: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13701: LD_EXP 9
13705: PPUSH
13706: LD_STRING DS-2b-Contact
13708: PPUSH
13709: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13713: LD_INT 22
13715: PUSH
13716: LD_INT 8
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PUSH
13723: LD_INT 21
13725: PUSH
13726: LD_INT 1
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PPUSH
13737: CALL_OW 69
13741: PUSH
13742: LD_INT 8
13744: PPUSH
13745: LD_INT 1
13747: PPUSH
13748: CALL_OW 81
13752: PUSH
13753: LD_INT 2
13755: EQUAL
13756: AND
13757: IFFALSE 13783
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13759: LD_EXP 11
13763: PPUSH
13764: LD_STRING DM-3-Contact
13766: PPUSH
13767: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13771: LD_EXP 9
13775: PPUSH
13776: LD_STRING DS-3-Contact
13778: PPUSH
13779: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13783: LD_EXP 11
13787: PPUSH
13788: LD_STRING DM-4-Contact
13790: PPUSH
13791: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13795: LD_EXP 9
13799: PPUSH
13800: LD_STRING DS-4-Contact
13802: PPUSH
13803: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13807: LD_EXP 11
13811: PPUSH
13812: LD_STRING DM-5-Contact
13814: PPUSH
13815: CALL_OW 94
// end ; DialogueOff ;
13819: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13823: LD_STRING O3
13825: PPUSH
13826: CALL_OW 337
// end ;
13830: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13831: LD_EXP 2
13835: PUSH
13836: LD_INT 1
13838: EQUAL
13839: PUSH
13840: LD_EXP 18
13844: PUSH
13845: LD_INT 15
13847: PUSH
13848: LD_INT 20
13850: PUSH
13851: LD_INT 25
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: LIST
13858: PUSH
13859: LD_OWVAR 67
13863: ARRAY
13864: GREATEREQUAL
13865: AND
13866: PUSH
13867: LD_INT 22
13869: PUSH
13870: LD_INT 8
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: PUSH
13877: LD_INT 30
13879: PUSH
13880: LD_INT 1
13882: PUSH
13883: EMPTY
13884: LIST
13885: LIST
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: PPUSH
13891: CALL_OW 69
13895: AND
13896: PUSH
13897: LD_INT 22
13899: PUSH
13900: LD_INT 8
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: LD_INT 21
13909: PUSH
13910: LD_INT 3
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PUSH
13917: EMPTY
13918: LIST
13919: LIST
13920: PPUSH
13921: CALL_OW 69
13925: PUSH
13926: LD_INT 5
13928: GREATEREQUAL
13929: AND
13930: IFFALSE 14453
13932: GO 13934
13934: DISABLE
13935: LD_INT 0
13937: PPUSH
13938: PPUSH
13939: PPUSH
13940: PPUSH
// begin DialogueOn ;
13941: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13945: LD_EXP 13
13949: PPUSH
13950: LD_STRING DF-1-Leg
13952: PPUSH
13953: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
13957: LD_EXP 9
13961: PPUSH
13962: LD_STRING D
13964: PUSH
13965: LD_STRING I
13967: PUSH
13968: LD_STRING J
13970: PUSH
13971: LD_STRING S
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: PUSH
13979: LD_EXP 25
13983: ARRAY
13984: STR
13985: PUSH
13986: LD_STRING -1-Leg
13988: STR
13989: PPUSH
13990: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
13994: LD_EXP 13
13998: PPUSH
13999: LD_STRING DF-2-Leg
14001: PPUSH
14002: CALL_OW 94
// DialogueOff ;
14006: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14010: LD_STRING QLegionOffer
14012: PPUSH
14013: CALL_OW 97
14017: PUSH
14018: LD_INT 1
14020: DOUBLE
14021: EQUAL
14022: IFTRUE 14026
14024: GO 14029
14026: POP
// ; 2 :
14027: GO 14043
14029: LD_INT 2
14031: DOUBLE
14032: EQUAL
14033: IFTRUE 14037
14035: GO 14042
14037: POP
// exit ; end ;
14038: GO 14453
14040: GO 14043
14042: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14043: LD_EXP 9
14047: PPUSH
14048: LD_STRING D
14050: PUSH
14051: LD_STRING I
14053: PUSH
14054: LD_STRING J
14056: PUSH
14057: LD_STRING S
14059: PUSH
14060: EMPTY
14061: LIST
14062: LIST
14063: LIST
14064: PUSH
14065: LD_EXP 25
14069: ARRAY
14070: STR
14071: PUSH
14072: LD_STRING -2-Leg
14074: STR
14075: PPUSH
14076: CALL_OW 88
// legOfferAccepted := true ;
14080: LD_ADDR_EXP 20
14084: PUSH
14085: LD_INT 1
14087: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14088: LD_INT 21
14090: PPUSH
14091: LD_INT 1
14093: PPUSH
14094: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14098: LD_INT 190
14100: PPUSH
14101: LD_INT 227
14103: PPUSH
14104: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14108: LD_ADDR_VAR 0 1
14112: PUSH
14113: LD_INT 16800
14115: PUSH
14116: LD_INT 14700
14118: PUSH
14119: LD_INT 12600
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: LIST
14126: PUSH
14127: LD_OWVAR 67
14131: ARRAY
14132: ST_TO_ADDR
// sib := 100 ;
14133: LD_ADDR_VAR 0 2
14137: PUSH
14138: LD_INT 100
14140: ST_TO_ADDR
// disableGlobalTimer := true ;
14141: LD_ADDR_EXP 4
14145: PUSH
14146: LD_INT 1
14148: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14149: LD_INT 35
14151: PPUSH
14152: CALL_OW 67
// time := time - 0 0$1 ;
14156: LD_ADDR_VAR 0 1
14160: PUSH
14161: LD_VAR 0 1
14165: PUSH
14166: LD_INT 35
14168: MINUS
14169: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: LD_INT 21
14177: PPUSH
14178: LD_INT 3
14180: PPUSH
14181: CALL_OW 287
14185: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14186: LD_ADDR_OWVAR 47
14190: PUSH
14191: LD_STRING #SkrTime
14193: PUSH
14194: LD_OWVAR 1
14198: PUSH
14199: LD_STRING #Skr-LegOffer
14201: PUSH
14202: LD_VAR 0 2
14206: PUSH
14207: LD_VAR 0 1
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: ST_TO_ADDR
// if sources then
14219: LD_VAR 0 3
14223: IFFALSE 14255
// begin sib := sib - sources * 10 ;
14225: LD_ADDR_VAR 0 2
14229: PUSH
14230: LD_VAR 0 2
14234: PUSH
14235: LD_VAR 0 3
14239: PUSH
14240: LD_INT 10
14242: MUL
14243: MINUS
14244: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14245: LD_INT 21
14247: PPUSH
14248: LD_INT 3
14250: PPUSH
14251: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14255: LD_VAR 0 1
14259: PUSH
14260: LD_INT 0
14262: EQUAL
14263: PUSH
14264: LD_VAR 0 2
14268: PUSH
14269: LD_INT 0
14271: LESSEQUAL
14272: OR
14273: PUSH
14274: LD_INT 22
14276: PUSH
14277: LD_INT 8
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PPUSH
14284: CALL_OW 69
14288: NOT
14289: OR
14290: IFFALSE 14149
// SetAreaMapShow ( legOfferArea , 0 ) ;
14292: LD_INT 21
14294: PPUSH
14295: LD_INT 0
14297: PPUSH
14298: CALL_OW 424
// disableGlobalTimer := false ;
14302: LD_ADDR_EXP 4
14306: PUSH
14307: LD_INT 0
14309: ST_TO_ADDR
// if sib <= 0 then
14310: LD_VAR 0 2
14314: PUSH
14315: LD_INT 0
14317: LESSEQUAL
14318: IFFALSE 14434
// begin legChangeSide := true ;
14320: LD_ADDR_EXP 21
14324: PUSH
14325: LD_INT 1
14327: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14328: LD_EXP 13
14332: PPUSH
14333: LD_STRING DF-4y-Leg
14335: PPUSH
14336: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14340: LD_STRING O3a
14342: PPUSH
14343: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14347: LD_INT 8
14349: PPUSH
14350: LD_INT 1
14352: PPUSH
14353: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14357: LD_INT 8
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 1
14365: PPUSH
14366: LD_INT 1
14368: PPUSH
14369: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14373: LD_INT 8
14375: PPUSH
14376: LD_INT 4
14378: PPUSH
14379: LD_INT 1
14381: PPUSH
14382: LD_INT 1
14384: PPUSH
14385: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14389: LD_INT 8
14391: PPUSH
14392: LD_INT 6
14394: PPUSH
14395: LD_INT 2
14397: PPUSH
14398: LD_INT 1
14400: PPUSH
14401: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14405: LD_INT 8
14407: PPUSH
14408: LD_INT 3
14410: PPUSH
14411: LD_INT 2
14413: PPUSH
14414: LD_INT 1
14416: PPUSH
14417: CALL_OW 80
// wait ( 0 0$30 ) ;
14421: LD_INT 1050
14423: PPUSH
14424: CALL_OW 67
// PrepareLegionReinforcements ;
14428: CALL 10563 0 0
// end else
14432: GO 14453
// begin ChangeMissionObjectives ( O3a ) ;
14434: LD_STRING O3a
14436: PPUSH
14437: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14441: LD_EXP 13
14445: PPUSH
14446: LD_STRING DF-4n-Leg
14448: PPUSH
14449: CALL_OW 94
// end ; end ;
14453: PPOPN 4
14455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14456: LD_INT 22
14458: PUSH
14459: LD_INT 8
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: LD_INT 21
14468: PUSH
14469: LD_INT 1
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PPUSH
14480: CALL_OW 69
14484: PUSH
14485: LD_INT 0
14487: EQUAL
14488: PUSH
14489: LD_INT 8
14491: PPUSH
14492: LD_INT 1
14494: PPUSH
14495: CALL_OW 81
14499: PUSH
14500: LD_INT 2
14502: EQUAL
14503: AND
14504: IFFALSE 14516
14506: GO 14508
14508: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14509: LD_STRING O3a
14511: PPUSH
14512: CALL_OW 337
14516: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14517: LD_EXP 2
14521: PUSH
14522: LD_INT 1
14524: EQUAL
14525: PUSH
14526: LD_EXP 3
14530: AND
14531: PUSH
14532: LD_INT 22
14534: PUSH
14535: LD_INT 3
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 21
14544: PUSH
14545: LD_INT 1
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: PPUSH
14556: CALL_OW 69
14560: PUSH
14561: LD_INT 0
14563: EQUAL
14564: AND
14565: PUSH
14566: LD_INT 22
14568: PUSH
14569: LD_INT 3
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: PUSH
14576: LD_INT 30
14578: PUSH
14579: LD_INT 1
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: PUSH
14586: EMPTY
14587: LIST
14588: LIST
14589: PPUSH
14590: CALL_OW 69
14594: PUSH
14595: LD_INT 0
14597: EQUAL
14598: AND
14599: IFFALSE 14837
14601: GO 14603
14603: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14604: LD_EXP 9
14608: PPUSH
14609: LD_STRING D
14611: PUSH
14612: LD_STRING I
14614: PUSH
14615: LD_STRING J
14617: PUSH
14618: LD_STRING S
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: LIST
14625: PUSH
14626: LD_EXP 25
14630: ARRAY
14631: STR
14632: PUSH
14633: LD_STRING -1-Win
14635: STR
14636: PPUSH
14637: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14641: LD_OWVAR 1
14645: PUSH
14646: LD_INT 315000
14648: PUSH
14649: LD_INT 273000
14651: PUSH
14652: LD_INT 231000
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: LIST
14659: PUSH
14660: LD_OWVAR 67
14664: ARRAY
14665: GREATEREQUAL
14666: IFFALSE 14681
// AddMedal ( med1 , - 1 ) else
14668: LD_STRING med1
14670: PPUSH
14671: LD_INT 1
14673: NEG
14674: PPUSH
14675: CALL_OW 101
14679: GO 14691
// AddMedal ( med1 , 1 ) ;
14681: LD_STRING med1
14683: PPUSH
14684: LD_INT 1
14686: PPUSH
14687: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14691: LD_EXP 22
14695: PUSH
14696: LD_INT 20
14698: PUSH
14699: LD_INT 15
14701: PUSH
14702: LD_INT 10
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: LIST
14709: PUSH
14710: LD_OWVAR 67
14714: ARRAY
14715: GREATEREQUAL
14716: IFFALSE 14731
// AddMedal ( med2 , - 1 ) else
14718: LD_STRING med2
14720: PPUSH
14721: LD_INT 1
14723: NEG
14724: PPUSH
14725: CALL_OW 101
14729: GO 14741
// AddMedal ( med2 , 1 ) ;
14731: LD_STRING med2
14733: PPUSH
14734: LD_INT 1
14736: PPUSH
14737: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14741: LD_INT 8
14743: PPUSH
14744: LD_INT 1
14746: PPUSH
14747: CALL_OW 81
14751: PUSH
14752: LD_INT 1
14754: EQUAL
14755: IFFALSE 14769
// AddMedal ( med3 , 1 ) else
14757: LD_STRING med3
14759: PPUSH
14760: LD_INT 1
14762: PPUSH
14763: CALL_OW 101
14767: GO 14826
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14769: LD_INT 22
14771: PUSH
14772: LD_INT 8
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 21
14781: PUSH
14782: LD_INT 1
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PPUSH
14793: CALL_OW 69
14797: PUSH
14798: LD_INT 0
14800: EQUAL
14801: IFFALSE 14815
// AddMedal ( med3 , 2 ) else
14803: LD_STRING med3
14805: PPUSH
14806: LD_INT 2
14808: PPUSH
14809: CALL_OW 101
14813: GO 14826
// AddMedal ( med3 , - 1 ) ;
14815: LD_STRING med3
14817: PPUSH
14818: LD_INT 1
14820: NEG
14821: PPUSH
14822: CALL_OW 101
// GiveMedals ( MAIN ) ;
14826: LD_STRING MAIN
14828: PPUSH
14829: CALL_OW 102
// YouWin ;
14833: CALL_OW 103
// end ;
14837: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14838: LD_EXP 2
14842: PUSH
14843: LD_INT 1
14845: EQUAL
14846: PUSH
14847: LD_EXP 16
14851: AND
14852: PUSH
14853: LD_INT 20
14855: PPUSH
14856: LD_INT 81
14858: PUSH
14859: LD_INT 8
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL_OW 70
14870: AND
14871: IFFALSE 15150
14873: GO 14875
14875: DISABLE
14876: LD_INT 0
14878: PPUSH
14879: PPUSH
14880: PPUSH
14881: PPUSH
14882: PPUSH
// begin enable ;
14883: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14884: LD_ADDR_VAR 0 3
14888: PUSH
14889: LD_INT 20
14891: PPUSH
14892: LD_INT 81
14894: PUSH
14895: LD_INT 8
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: PPUSH
14902: CALL_OW 70
14906: ST_TO_ADDR
// if not tmp then
14907: LD_VAR 0 3
14911: NOT
14912: IFFALSE 14916
// exit ;
14914: GO 15150
// for i in tmp do
14916: LD_ADDR_VAR 0 1
14920: PUSH
14921: LD_VAR 0 3
14925: PUSH
14926: FOR_IN
14927: IFFALSE 15148
// begin x := GetX ( i ) ;
14929: LD_ADDR_VAR 0 4
14933: PUSH
14934: LD_VAR 0 1
14938: PPUSH
14939: CALL_OW 250
14943: ST_TO_ADDR
// y := GetY ( i ) ;
14944: LD_ADDR_VAR 0 5
14948: PUSH
14949: LD_VAR 0 1
14953: PPUSH
14954: CALL_OW 251
14958: ST_TO_ADDR
// if MineAtPos ( x , y ) then
14959: LD_VAR 0 4
14963: PPUSH
14964: LD_VAR 0 5
14968: PPUSH
14969: CALL_OW 458
14973: IFFALSE 15146
// begin LaunchMineAtPos ( x , y , 8 ) ;
14975: LD_VAR 0 4
14979: PPUSH
14980: LD_VAR 0 5
14984: PPUSH
14985: LD_INT 8
14987: PPUSH
14988: CALL_OW 456
// if not dialogueMineDetected then
14992: LD_EXP 28
14996: NOT
14997: IFFALSE 15058
// begin dialogueMineDetected := true ;
14999: LD_ADDR_EXP 28
15003: PUSH
15004: LD_INT 1
15006: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15007: LD_VAR 0 4
15011: PPUSH
15012: LD_VAR 0 5
15016: PPUSH
15017: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15021: LD_EXP 9
15025: PPUSH
15026: LD_STRING D
15028: PUSH
15029: LD_STRING I
15031: PUSH
15032: LD_STRING J
15034: PUSH
15035: LD_STRING S
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: LIST
15042: PUSH
15043: LD_EXP 25
15047: ARRAY
15048: STR
15049: PUSH
15050: LD_STRING -1-Mine
15052: STR
15053: PPUSH
15054: CALL_OW 88
// end ; for j = 1 to staticMines do
15058: LD_ADDR_VAR 0 2
15062: PUSH
15063: DOUBLE
15064: LD_INT 1
15066: DEC
15067: ST_TO_ADDR
15068: LD_EXP 16
15072: PUSH
15073: FOR_TO
15074: IFFALSE 15144
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15076: LD_EXP 16
15080: PUSH
15081: LD_VAR 0 2
15085: ARRAY
15086: PUSH
15087: LD_INT 1
15089: ARRAY
15090: PUSH
15091: LD_VAR 0 4
15095: EQUAL
15096: PUSH
15097: LD_EXP 16
15101: PUSH
15102: LD_VAR 0 2
15106: ARRAY
15107: PUSH
15108: LD_INT 2
15110: ARRAY
15111: PUSH
15112: LD_VAR 0 5
15116: EQUAL
15117: AND
15118: IFFALSE 15142
// begin staticMines := Delete ( staticMines , j ) ;
15120: LD_ADDR_EXP 16
15124: PUSH
15125: LD_EXP 16
15129: PPUSH
15130: LD_VAR 0 2
15134: PPUSH
15135: CALL_OW 3
15139: ST_TO_ADDR
// break ;
15140: GO 15144
// end ;
15142: GO 15073
15144: POP
15145: POP
// end ; end ;
15146: GO 14926
15148: POP
15149: POP
// end ;
15150: PPOPN 5
15152: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15153: LD_EXP 2
15157: PUSH
15158: LD_INT 1
15160: EQUAL
15161: PUSH
15162: LD_EXP 3
15166: AND
15167: PUSH
15168: LD_EXP 23
15172: AND
15173: PUSH
15174: LD_EXP 31
15178: PUSH
15179: LD_EXP 7
15183: ARRAY
15184: PPUSH
15185: LD_INT 30
15187: PUSH
15188: LD_INT 3
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: CALL_OW 72
15199: AND
15200: IFFALSE 15404
15202: GO 15204
15204: DISABLE
15205: LD_INT 0
15207: PPUSH
15208: PPUSH
// begin enable ;
15209: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15210: LD_EXP 7
15214: PPUSH
15215: LD_INT 23
15217: PUSH
15218: LD_INT 3
15220: PUSH
15221: LD_INT 3
15223: PUSH
15224: LD_INT 48
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: PUSH
15233: EMPTY
15234: LIST
15235: PPUSH
15236: CALL 86892 0 2
// repeat wait ( 0 0$1 ) ;
15240: LD_INT 35
15242: PPUSH
15243: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15247: LD_INT 22
15249: PUSH
15250: LD_INT 3
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 34
15259: PUSH
15260: LD_INT 48
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: IFFALSE 15240
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15277: LD_ADDR_VAR 0 1
15281: PUSH
15282: LD_INT 22
15284: PUSH
15285: LD_INT 3
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 34
15294: PUSH
15295: LD_INT 48
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PPUSH
15306: CALL_OW 69
15310: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15311: LD_ADDR_VAR 0 2
15315: PUSH
15316: LD_INT 81
15318: PUSH
15319: LD_INT 3
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 21
15328: PUSH
15329: LD_INT 3
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: PPUSH
15340: CALL_OW 69
15344: ST_TO_ADDR
// if e then
15345: LD_VAR 0 2
15349: IFFALSE 15375
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15351: LD_ADDR_VAR 0 2
15355: PUSH
15356: LD_VAR 0 2
15360: PPUSH
15361: LD_VAR 0 1
15365: PUSH
15366: LD_INT 1
15368: ARRAY
15369: PPUSH
15370: CALL_OW 74
15374: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15375: LD_VAR 0 1
15379: PPUSH
15380: LD_VAR 0 2
15384: PPUSH
15385: CALL_OW 250
15389: PPUSH
15390: LD_VAR 0 2
15394: PPUSH
15395: CALL_OW 251
15399: PPUSH
15400: CALL_OW 116
// end ;
15404: PPOPN 2
15406: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15407: LD_OWVAR 67
15411: PUSH
15412: LD_INT 1
15414: GREATER
15415: PUSH
15416: LD_EXP 31
15420: PUSH
15421: LD_EXP 7
15425: ARRAY
15426: PPUSH
15427: LD_INT 25
15429: PUSH
15430: LD_INT 3
15432: PUSH
15433: EMPTY
15434: LIST
15435: LIST
15436: PPUSH
15437: CALL_OW 72
15441: AND
15442: PUSH
15443: LD_EXP 2
15447: PUSH
15448: LD_INT 1
15450: EQUAL
15451: AND
15452: PUSH
15453: LD_EXP 3
15457: AND
15458: PUSH
15459: LD_INT 23
15461: PPUSH
15462: LD_INT 3
15464: PPUSH
15465: CALL_OW 321
15469: PUSH
15470: LD_INT 2
15472: EQUAL
15473: AND
15474: IFFALSE 15601
15476: GO 15478
15478: DISABLE
15479: LD_INT 0
15481: PPUSH
15482: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15483: LD_ADDR_VAR 0 1
15487: PUSH
15488: LD_EXP 31
15492: PUSH
15493: LD_EXP 7
15497: ARRAY
15498: PPUSH
15499: LD_INT 25
15501: PUSH
15502: LD_INT 3
15504: PUSH
15505: EMPTY
15506: LIST
15507: LIST
15508: PPUSH
15509: CALL_OW 72
15513: ST_TO_ADDR
// if not tmp then
15514: LD_VAR 0 1
15518: NOT
15519: IFFALSE 15523
// exit ;
15521: GO 15601
// for i in tmp do
15523: LD_ADDR_VAR 0 2
15527: PUSH
15528: LD_VAR 0 1
15532: PUSH
15533: FOR_IN
15534: IFFALSE 15580
// begin SetTag ( i , 29 ) ;
15536: LD_VAR 0 2
15540: PPUSH
15541: LD_INT 29
15543: PPUSH
15544: CALL_OW 109
// ComExitBuilding ( i ) ;
15548: LD_VAR 0 2
15552: PPUSH
15553: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15557: LD_VAR 0 2
15561: PPUSH
15562: LD_INT 37
15564: PPUSH
15565: LD_INT 97
15567: PPUSH
15568: LD_INT 133
15570: PPUSH
15571: LD_INT 0
15573: PPUSH
15574: CALL_OW 230
// end ;
15578: GO 15533
15580: POP
15581: POP
// wait ( 1 1$00 ) ;
15582: LD_INT 2100
15584: PPUSH
15585: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15589: LD_EXP 7
15593: PPUSH
15594: LD_INT 29
15596: PPUSH
15597: CALL 66779 0 2
// end ;
15601: PPOPN 2
15603: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15604: LD_EXP 2
15608: PUSH
15609: LD_INT 1
15611: EQUAL
15612: PUSH
15613: LD_INT 84
15615: PPUSH
15616: LD_INT 128
15618: PPUSH
15619: CALL_OW 428
15623: PPUSH
15624: CALL_OW 266
15628: PUSH
15629: LD_INT 1
15631: EQUAL
15632: AND
15633: PUSH
15634: LD_INT 84
15636: PPUSH
15637: LD_INT 128
15639: PPUSH
15640: CALL_OW 428
15644: PPUSH
15645: CALL_OW 255
15649: PUSH
15650: LD_INT 3
15652: EQUAL
15653: AND
15654: IFFALSE 15827
15656: GO 15658
15658: DISABLE
15659: LD_INT 0
15661: PPUSH
15662: PPUSH
// begin enable ;
15663: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15664: LD_ADDR_VAR 0 2
15668: PUSH
15669: LD_INT 84
15671: PPUSH
15672: LD_INT 128
15674: PPUSH
15675: CALL_OW 428
15679: ST_TO_ADDR
// uc_side := 3 ;
15680: LD_ADDR_OWVAR 20
15684: PUSH
15685: LD_INT 3
15687: ST_TO_ADDR
// uc_nation := 3 ;
15688: LD_ADDR_OWVAR 21
15692: PUSH
15693: LD_INT 3
15695: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15696: LD_INT 21
15698: PPUSH
15699: LD_INT 3
15701: PPUSH
15702: LD_INT 3
15704: PPUSH
15705: LD_INT 51
15707: PPUSH
15708: LD_INT 0
15710: PPUSH
15711: CALL 24679 0 5
// veh := CreateVehicle ;
15715: LD_ADDR_VAR 0 1
15719: PUSH
15720: CALL_OW 45
15724: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15725: LD_VAR 0 1
15729: PPUSH
15730: LD_INT 126
15732: PPUSH
15733: LD_INT 227
15735: PPUSH
15736: LD_INT 0
15738: PPUSH
15739: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15743: LD_VAR 0 1
15747: PPUSH
15748: LD_INT 2
15750: PPUSH
15751: LD_INT 100
15753: PPUSH
15754: CALL_OW 290
// ComGive ( veh , depot ) ;
15758: LD_VAR 0 1
15762: PPUSH
15763: LD_VAR 0 2
15767: PPUSH
15768: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15772: LD_VAR 0 1
15776: PPUSH
15777: LD_INT 126
15779: PPUSH
15780: LD_INT 227
15782: PPUSH
15783: CALL_OW 171
// wait ( 0 0$10 ) ;
15787: LD_INT 350
15789: PPUSH
15790: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15794: LD_INT 35
15796: PPUSH
15797: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15801: LD_VAR 0 1
15805: PPUSH
15806: LD_INT 126
15808: PPUSH
15809: LD_INT 227
15811: PPUSH
15812: CALL_OW 307
15816: IFFALSE 15794
// RemoveUnit ( veh ) ;
15818: LD_VAR 0 1
15822: PPUSH
15823: CALL_OW 64
// end ;
15827: PPOPN 2
15829: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15830: LD_EXP 2
15834: PUSH
15835: LD_INT 1
15837: EQUAL
15838: PUSH
15839: LD_EXP 27
15843: AND
15844: PUSH
15845: LD_EXP 25
15849: PUSH
15850: LD_INT 2
15852: EQUAL
15853: AND
15854: IFFALSE 16046
15856: GO 15858
15858: DISABLE
15859: LD_INT 0
15861: PPUSH
15862: PPUSH
// begin enable ;
15863: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15864: LD_OWVAR 1
15868: PUSH
15869: LD_INT 105000
15871: PUSH
15872: LD_INT 84000
15874: PUSH
15875: LD_INT 63000
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: LIST
15882: PUSH
15883: LD_OWVAR 67
15887: ARRAY
15888: GREATEREQUAL
15889: IFFALSE 15892
// disable ;
15891: DISABLE
// uc_side := 4 ;
15892: LD_ADDR_OWVAR 20
15896: PUSH
15897: LD_INT 4
15899: ST_TO_ADDR
// uc_nation := 1 ;
15900: LD_ADDR_OWVAR 21
15904: PUSH
15905: LD_INT 1
15907: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15908: LD_INT 2
15910: PPUSH
15911: LD_INT 3
15913: PPUSH
15914: LD_INT 3
15916: PPUSH
15917: LD_INT 12
15919: PPUSH
15920: LD_INT 0
15922: PPUSH
15923: CALL 24679 0 5
// veh := CreateVehicle ;
15927: LD_ADDR_VAR 0 1
15931: PUSH
15932: CALL_OW 45
15936: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15937: LD_VAR 0 1
15941: PPUSH
15942: LD_INT 229
15944: PPUSH
15945: LD_INT 226
15947: PPUSH
15948: LD_INT 0
15950: PPUSH
15951: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
15955: LD_VAR 0 1
15959: PPUSH
15960: LD_INT 1
15962: PPUSH
15963: LD_INT 100
15965: PPUSH
15966: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
15970: LD_VAR 0 1
15974: PPUSH
15975: LD_INT 25
15977: PPUSH
15978: CALL_OW 173
// AddComUnload ( veh ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 229
15998: PPUSH
15999: LD_INT 226
16001: PPUSH
16002: CALL_OW 171
// wait ( 0 0$10 ) ;
16006: LD_INT 350
16008: PPUSH
16009: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16013: LD_INT 35
16015: PPUSH
16016: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16020: LD_VAR 0 1
16024: PPUSH
16025: LD_INT 229
16027: PPUSH
16028: LD_INT 226
16030: PPUSH
16031: CALL_OW 307
16035: IFFALSE 16013
// RemoveUnit ( veh ) ;
16037: LD_VAR 0 1
16041: PPUSH
16042: CALL_OW 64
// end ;
16046: PPOPN 2
16048: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16049: LD_EXP 2
16053: PUSH
16054: LD_INT 1
16056: EQUAL
16057: PUSH
16058: LD_EXP 3
16062: AND
16063: PUSH
16064: LD_EXP 24
16068: AND
16069: IFFALSE 16402
16071: GO 16073
16073: DISABLE
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
16080: PPUSH
// begin enable ;
16081: ENABLE
// tmp := [ ] ;
16082: LD_ADDR_VAR 0 4
16086: PUSH
16087: EMPTY
16088: ST_TO_ADDR
// if commander = 1 then
16089: LD_EXP 25
16093: PUSH
16094: LD_INT 1
16096: EQUAL
16097: IFFALSE 16109
// amount := 3 else
16099: LD_ADDR_VAR 0 5
16103: PUSH
16104: LD_INT 3
16106: ST_TO_ADDR
16107: GO 16117
// amount := 2 ;
16109: LD_ADDR_VAR 0 5
16113: PUSH
16114: LD_INT 2
16116: ST_TO_ADDR
// for i = 1 to amount do
16117: LD_ADDR_VAR 0 1
16121: PUSH
16122: DOUBLE
16123: LD_INT 1
16125: DEC
16126: ST_TO_ADDR
16127: LD_VAR 0 5
16131: PUSH
16132: FOR_TO
16133: IFFALSE 16297
// begin wait ( 0 0$5 ) ;
16135: LD_INT 175
16137: PPUSH
16138: CALL_OW 67
// for j = 1 to 3 do
16142: LD_ADDR_VAR 0 2
16146: PUSH
16147: DOUBLE
16148: LD_INT 1
16150: DEC
16151: ST_TO_ADDR
16152: LD_INT 3
16154: PUSH
16155: FOR_TO
16156: IFFALSE 16293
// begin uc_side := 4 ;
16158: LD_ADDR_OWVAR 20
16162: PUSH
16163: LD_INT 4
16165: ST_TO_ADDR
// uc_nation := 1 ;
16166: LD_ADDR_OWVAR 21
16170: PUSH
16171: LD_INT 1
16173: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16174: LD_INT 3
16176: PUSH
16177: LD_INT 5
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: PUSH
16184: LD_INT 1
16186: PPUSH
16187: LD_INT 2
16189: PPUSH
16190: CALL_OW 12
16194: ARRAY
16195: PPUSH
16196: LD_INT 3
16198: PPUSH
16199: LD_INT 3
16201: PPUSH
16202: LD_INT 9
16204: PUSH
16205: LD_INT 5
16207: PUSH
16208: LD_INT 7
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: LIST
16215: PUSH
16216: LD_INT 1
16218: PPUSH
16219: LD_INT 3
16221: PPUSH
16222: CALL_OW 12
16226: ARRAY
16227: PPUSH
16228: LD_INT 100
16230: PPUSH
16231: CALL 24679 0 5
// veh := CreateVehicle ;
16235: LD_ADDR_VAR 0 3
16239: PUSH
16240: CALL_OW 45
16244: ST_TO_ADDR
// tmp := tmp ^ veh ;
16245: LD_ADDR_VAR 0 4
16249: PUSH
16250: LD_VAR 0 4
16254: PUSH
16255: LD_VAR 0 3
16259: ADD
16260: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16261: LD_VAR 0 3
16265: PPUSH
16266: LD_INT 22
16268: PPUSH
16269: LD_INT 0
16271: PPUSH
16272: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16276: LD_VAR 0 3
16280: PPUSH
16281: LD_INT 119
16283: PPUSH
16284: LD_INT 215
16286: PPUSH
16287: CALL_OW 111
// end ;
16291: GO 16155
16293: POP
16294: POP
// end ;
16295: GO 16132
16297: POP
16298: POP
// wait ( 0 0$3 ) ;
16299: LD_INT 105
16301: PPUSH
16302: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16306: LD_INT 35
16308: PPUSH
16309: CALL_OW 67
// for i in tmp do
16313: LD_ADDR_VAR 0 1
16317: PUSH
16318: LD_VAR 0 4
16322: PUSH
16323: FOR_IN
16324: IFFALSE 16391
// if IsDead ( i ) then
16326: LD_VAR 0 1
16330: PPUSH
16331: CALL_OW 301
16335: IFFALSE 16355
// tmp := tmp diff i else
16337: LD_ADDR_VAR 0 4
16341: PUSH
16342: LD_VAR 0 4
16346: PUSH
16347: LD_VAR 0 1
16351: DIFF
16352: ST_TO_ADDR
16353: GO 16389
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16355: LD_VAR 0 1
16359: PPUSH
16360: LD_INT 81
16362: PUSH
16363: LD_INT 4
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: PPUSH
16375: LD_VAR 0 1
16379: PPUSH
16380: CALL_OW 74
16384: PPUSH
16385: CALL_OW 115
16389: GO 16323
16391: POP
16392: POP
// until tmp = [ ] ;
16393: LD_VAR 0 4
16397: PUSH
16398: EMPTY
16399: EQUAL
16400: IFFALSE 16306
// end ;
16402: PPOPN 5
16404: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16405: LD_EXP 2
16409: PUSH
16410: LD_INT 1
16412: EQUAL
16413: PUSH
16414: LD_EXP 3
16418: AND
16419: IFFALSE 16520
16421: GO 16423
16423: DISABLE
16424: LD_INT 0
16426: PPUSH
16427: PPUSH
// begin enable ;
16428: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16429: LD_ADDR_VAR 0 2
16433: PUSH
16434: LD_INT 3
16436: PUSH
16437: LD_INT 22
16439: PUSH
16440: LD_INT 1
16442: PUSH
16443: EMPTY
16444: LIST
16445: LIST
16446: PUSH
16447: EMPTY
16448: LIST
16449: LIST
16450: PUSH
16451: LD_INT 32
16453: PUSH
16454: LD_INT 1
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: PUSH
16461: EMPTY
16462: LIST
16463: LIST
16464: PPUSH
16465: CALL_OW 69
16469: ST_TO_ADDR
// if tmp then
16470: LD_VAR 0 2
16474: IFFALSE 16520
// for i in tmp do
16476: LD_ADDR_VAR 0 1
16480: PUSH
16481: LD_VAR 0 2
16485: PUSH
16486: FOR_IN
16487: IFFALSE 16518
// if GetFuel ( i ) < 3 then
16489: LD_VAR 0 1
16493: PPUSH
16494: CALL_OW 261
16498: PUSH
16499: LD_INT 3
16501: LESS
16502: IFFALSE 16516
// SetFuel ( i , 3 ) ;
16504: LD_VAR 0 1
16508: PPUSH
16509: LD_INT 3
16511: PPUSH
16512: CALL_OW 240
16516: GO 16486
16518: POP
16519: POP
// end ;
16520: PPOPN 2
16522: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16523: LD_EXP 3
16527: PUSH
16528: LD_INT 8
16530: PPUSH
16531: LD_INT 4
16533: PPUSH
16534: CALL_OW 81
16538: PUSH
16539: LD_INT 2
16541: EQUAL
16542: AND
16543: IFFALSE 16753
16545: GO 16547
16547: DISABLE
16548: LD_INT 0
16550: PPUSH
16551: PPUSH
16552: PPUSH
// begin enable ;
16553: ENABLE
// tmp := [ ] ;
16554: LD_ADDR_VAR 0 3
16558: PUSH
16559: EMPTY
16560: ST_TO_ADDR
// for i = 1 to 4 do
16561: LD_ADDR_VAR 0 1
16565: PUSH
16566: DOUBLE
16567: LD_INT 1
16569: DEC
16570: ST_TO_ADDR
16571: LD_INT 4
16573: PUSH
16574: FOR_TO
16575: IFFALSE 16719
// begin uc_side := 8 ;
16577: LD_ADDR_OWVAR 20
16581: PUSH
16582: LD_INT 8
16584: ST_TO_ADDR
// uc_nation := nation_arabian ;
16585: LD_ADDR_OWVAR 21
16589: PUSH
16590: LD_INT 2
16592: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16593: LD_INT 11
16595: PPUSH
16596: LD_INT 1
16598: PPUSH
16599: LD_INT 5
16601: PPUSH
16602: LD_INT 24
16604: PUSH
16605: LD_INT 23
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: LD_INT 1
16614: PPUSH
16615: LD_INT 2
16617: PPUSH
16618: CALL_OW 12
16622: ARRAY
16623: PPUSH
16624: LD_INT 60
16626: PPUSH
16627: LD_INT 80
16629: PPUSH
16630: CALL_OW 12
16634: PPUSH
16635: CALL 24679 0 5
// un := CreateVehicle ;
16639: LD_ADDR_VAR 0 2
16643: PUSH
16644: CALL_OW 45
16648: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16649: LD_VAR 0 2
16653: PPUSH
16654: LD_INT 2
16656: PPUSH
16657: CALL_OW 233
// tmp := tmp ^ un ;
16661: LD_ADDR_VAR 0 3
16665: PUSH
16666: LD_VAR 0 3
16670: PUSH
16671: LD_VAR 0 2
16675: ADD
16676: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16677: LD_VAR 0 2
16681: PPUSH
16682: LD_INT 88
16684: PPUSH
16685: LD_INT 2
16687: PPUSH
16688: LD_INT 0
16690: PPUSH
16691: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16695: LD_VAR 0 2
16699: PPUSH
16700: LD_INT 93
16702: PPUSH
16703: LD_INT 13
16705: PPUSH
16706: CALL_OW 111
// wait ( 0 0$2 ) ;
16710: LD_INT 70
16712: PPUSH
16713: CALL_OW 67
// end ;
16717: GO 16574
16719: POP
16720: POP
// for i in tmp do
16721: LD_ADDR_VAR 0 1
16725: PUSH
16726: LD_VAR 0 3
16730: PUSH
16731: FOR_IN
16732: IFFALSE 16751
// AddComMoveXY ( i , 136 , 19 ) ;
16734: LD_VAR 0 1
16738: PPUSH
16739: LD_INT 136
16741: PPUSH
16742: LD_INT 19
16744: PPUSH
16745: CALL_OW 171
16749: GO 16731
16751: POP
16752: POP
// end ;
16753: PPOPN 3
16755: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16756: LD_EXP 3
16760: IFFALSE 17679
16762: GO 16764
16764: DISABLE
16765: LD_INT 0
16767: PPUSH
16768: PPUSH
16769: PPUSH
16770: PPUSH
// begin enable ;
16771: ENABLE
// base := mc_leg ;
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_EXP 6
16781: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16782: LD_INT 22
16784: PUSH
16785: LD_INT 8
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PUSH
16792: LD_INT 23
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PUSH
16802: LD_INT 30
16804: PUSH
16805: LD_INT 3
16807: PUSH
16808: EMPTY
16809: LIST
16810: LIST
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: LIST
16816: PPUSH
16817: CALL_OW 69
16821: NOT
16822: IFFALSE 16826
// exit ;
16824: GO 17679
// if Prob ( 40 ) then
16826: LD_INT 40
16828: PPUSH
16829: CALL_OW 13
16833: IFFALSE 16962
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16835: LD_VAR 0 2
16839: PPUSH
16840: LD_INT 13
16842: PUSH
16843: LD_INT 1
16845: PUSH
16846: LD_INT 2
16848: PUSH
16849: LD_INT 28
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: LIST
16856: LIST
16857: PUSH
16858: LD_INT 13
16860: PUSH
16861: LD_INT 1
16863: PUSH
16864: LD_INT 2
16866: PUSH
16867: LD_INT 28
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: LIST
16874: LIST
16875: PUSH
16876: LD_INT 13
16878: PUSH
16879: LD_INT 1
16881: PUSH
16882: LD_INT 2
16884: PUSH
16885: LD_INT 28
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 13
16896: PUSH
16897: LD_INT 1
16899: PUSH
16900: LD_INT 2
16902: PUSH
16903: LD_INT 28
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: PUSH
16912: LD_INT 13
16914: PUSH
16915: LD_INT 1
16917: PUSH
16918: LD_INT 2
16920: PUSH
16921: LD_INT 28
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: PUSH
16930: LD_INT 13
16932: PUSH
16933: LD_INT 1
16935: PUSH
16936: LD_INT 2
16938: PUSH
16939: LD_INT 26
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: PPUSH
16956: CALL 86892 0 2
// end else
16960: GO 17179
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16962: LD_VAR 0 2
16966: PPUSH
16967: LD_INT 13
16969: PUSH
16970: LD_INT 1
16972: PUSH
16973: LD_INT 2
16975: PUSH
16976: LD_INT 27
16978: PUSH
16979: LD_INT 26
16981: PUSH
16982: LD_INT 26
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 1
16992: PPUSH
16993: LD_INT 3
16995: PPUSH
16996: CALL_OW 12
17000: ARRAY
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 13
17010: PUSH
17011: LD_INT 1
17013: PUSH
17014: LD_INT 2
17016: PUSH
17017: LD_INT 27
17019: PUSH
17020: LD_INT 26
17022: PUSH
17023: LD_INT 26
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: LIST
17030: PUSH
17031: LD_INT 1
17033: PPUSH
17034: LD_INT 3
17036: PPUSH
17037: CALL_OW 12
17041: ARRAY
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 13
17051: PUSH
17052: LD_INT 1
17054: PUSH
17055: LD_INT 2
17057: PUSH
17058: LD_INT 26
17060: PUSH
17061: LD_INT 26
17063: PUSH
17064: LD_INT 29
17066: PUSH
17067: EMPTY
17068: LIST
17069: LIST
17070: LIST
17071: PUSH
17072: LD_INT 1
17074: PPUSH
17075: LD_INT 3
17077: PPUSH
17078: CALL_OW 12
17082: ARRAY
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 13
17092: PUSH
17093: LD_INT 1
17095: PUSH
17096: LD_INT 2
17098: PUSH
17099: LD_INT 26
17101: PUSH
17102: LD_INT 29
17104: PUSH
17105: LD_INT 29
17107: PUSH
17108: EMPTY
17109: LIST
17110: LIST
17111: LIST
17112: PUSH
17113: LD_INT 1
17115: PPUSH
17116: LD_INT 3
17118: PPUSH
17119: CALL_OW 12
17123: ARRAY
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: LIST
17129: LIST
17130: PUSH
17131: LD_INT 13
17133: PUSH
17134: LD_INT 1
17136: PUSH
17137: LD_INT 2
17139: PUSH
17140: LD_INT 29
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 13
17151: PUSH
17152: LD_INT 1
17154: PUSH
17155: LD_INT 2
17157: PUSH
17158: LD_INT 26
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: LIST
17165: LIST
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL 86892 0 2
// end ; repeat wait ( 0 0$1 ) ;
17179: LD_INT 35
17181: PPUSH
17182: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17186: LD_VAR 0 2
17190: PPUSH
17191: LD_INT 1
17193: PPUSH
17194: CALL 88310 0 2
17198: PUSH
17199: LD_INT 6
17201: GREATEREQUAL
17202: PUSH
17203: LD_OWVAR 1
17207: PUSH
17208: LD_INT 21000
17210: MOD
17211: PUSH
17212: LD_INT 0
17214: EQUAL
17215: OR
17216: IFFALSE 17179
// wait ( 0 0$30 ) ;
17218: LD_INT 1050
17220: PPUSH
17221: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17225: LD_ADDR_VAR 0 3
17229: PUSH
17230: LD_VAR 0 2
17234: PPUSH
17235: LD_INT 1
17237: PPUSH
17238: CALL 88310 0 2
17242: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17243: LD_ADDR_EXP 50
17247: PUSH
17248: LD_EXP 50
17252: PPUSH
17253: LD_VAR 0 2
17257: PPUSH
17258: LD_EXP 50
17262: PUSH
17263: LD_VAR 0 2
17267: ARRAY
17268: PUSH
17269: LD_VAR 0 3
17273: DIFF
17274: PPUSH
17275: CALL_OW 1
17279: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17280: LD_ADDR_VAR 0 4
17284: PUSH
17285: LD_INT 0
17287: PPUSH
17288: LD_INT 2
17290: PPUSH
17291: CALL_OW 12
17295: ST_TO_ADDR
// if legChangeSide then
17296: LD_EXP 21
17300: IFFALSE 17310
// target := 2 ;
17302: LD_ADDR_VAR 0 4
17306: PUSH
17307: LD_INT 2
17309: ST_TO_ADDR
// if target = 2 then
17310: LD_VAR 0 4
17314: PUSH
17315: LD_INT 2
17317: EQUAL
17318: IFFALSE 17446
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17320: LD_ADDR_VAR 0 3
17324: PUSH
17325: LD_VAR 0 3
17329: PPUSH
17330: LD_INT 24
17332: PUSH
17333: LD_INT 250
17335: PUSH
17336: EMPTY
17337: LIST
17338: LIST
17339: PPUSH
17340: CALL_OW 72
17344: ST_TO_ADDR
// for i in tmp do
17345: LD_ADDR_VAR 0 1
17349: PUSH
17350: LD_VAR 0 3
17354: PUSH
17355: FOR_IN
17356: IFFALSE 17396
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17358: LD_VAR 0 1
17362: PPUSH
17363: LD_INT 112
17365: PPUSH
17366: LD_INT 64
17368: PPUSH
17369: CALL_OW 297
17373: PUSH
17374: LD_INT 9
17376: GREATER
17377: IFFALSE 17394
// ComMoveXY ( i , 112 , 64 ) ;
17379: LD_VAR 0 1
17383: PPUSH
17384: LD_INT 112
17386: PPUSH
17387: LD_INT 64
17389: PPUSH
17390: CALL_OW 111
17394: GO 17355
17396: POP
17397: POP
// wait ( 0 0$1 ) ;
17398: LD_INT 35
17400: PPUSH
17401: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17405: LD_VAR 0 3
17409: PPUSH
17410: LD_INT 92
17412: PUSH
17413: LD_INT 112
17415: PUSH
17416: LD_INT 64
17418: PUSH
17419: LD_INT 9
17421: PUSH
17422: EMPTY
17423: LIST
17424: LIST
17425: LIST
17426: LIST
17427: PPUSH
17428: CALL_OW 72
17432: PUSH
17433: LD_VAR 0 3
17437: PUSH
17438: LD_INT 1
17440: MINUS
17441: GREATEREQUAL
17442: IFFALSE 17320
// end else
17444: GO 17570
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17446: LD_ADDR_VAR 0 3
17450: PUSH
17451: LD_VAR 0 3
17455: PPUSH
17456: LD_INT 24
17458: PUSH
17459: LD_INT 250
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: PPUSH
17466: CALL_OW 72
17470: ST_TO_ADDR
// for i in tmp do
17471: LD_ADDR_VAR 0 1
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: FOR_IN
17482: IFFALSE 17522
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17484: LD_VAR 0 1
17488: PPUSH
17489: LD_INT 174
17491: PPUSH
17492: LD_INT 94
17494: PPUSH
17495: CALL_OW 297
17499: PUSH
17500: LD_INT 9
17502: GREATER
17503: IFFALSE 17520
// ComMoveXY ( i , 174 , 94 ) ;
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 174
17512: PPUSH
17513: LD_INT 94
17515: PPUSH
17516: CALL_OW 111
17520: GO 17481
17522: POP
17523: POP
// wait ( 0 0$1 ) ;
17524: LD_INT 35
17526: PPUSH
17527: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17531: LD_VAR 0 3
17535: PPUSH
17536: LD_INT 92
17538: PUSH
17539: LD_INT 174
17541: PUSH
17542: LD_INT 94
17544: PUSH
17545: LD_INT 9
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: LIST
17552: LIST
17553: PPUSH
17554: CALL_OW 72
17558: PUSH
17559: LD_VAR 0 3
17563: PUSH
17564: LD_INT 1
17566: MINUS
17567: GREATEREQUAL
17568: IFFALSE 17446
// end ; repeat wait ( 0 0$1 ) ;
17570: LD_INT 35
17572: PPUSH
17573: CALL_OW 67
// for i in tmp do
17577: LD_ADDR_VAR 0 1
17581: PUSH
17582: LD_VAR 0 3
17586: PUSH
17587: FOR_IN
17588: IFFALSE 17670
// begin if GetLives ( i ) > 251 then
17590: LD_VAR 0 1
17594: PPUSH
17595: CALL_OW 256
17599: PUSH
17600: LD_INT 251
17602: GREATER
17603: IFFALSE 17641
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17605: LD_VAR 0 1
17609: PPUSH
17610: LD_INT 81
17612: PUSH
17613: LD_INT 8
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: PPUSH
17620: CALL_OW 69
17624: PPUSH
17625: LD_VAR 0 1
17629: PPUSH
17630: CALL_OW 74
17634: PPUSH
17635: CALL_OW 115
17639: GO 17668
// if IsDead ( i ) then
17641: LD_VAR 0 1
17645: PPUSH
17646: CALL_OW 301
17650: IFFALSE 17668
// tmp := tmp diff i ;
17652: LD_ADDR_VAR 0 3
17656: PUSH
17657: LD_VAR 0 3
17661: PUSH
17662: LD_VAR 0 1
17666: DIFF
17667: ST_TO_ADDR
// end ;
17668: GO 17587
17670: POP
17671: POP
// until not tmp ;
17672: LD_VAR 0 3
17676: NOT
17677: IFFALSE 17570
// end ;
17679: PPOPN 4
17681: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17682: LD_EXP 3
17686: IFFALSE 18674
17688: GO 17690
17690: DISABLE
17691: LD_INT 0
17693: PPUSH
17694: PPUSH
17695: PPUSH
17696: PPUSH
17697: PPUSH
// begin enable ;
17698: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17699: LD_EXP 31
17703: PUSH
17704: LD_EXP 8
17708: ARRAY
17709: PPUSH
17710: LD_INT 22
17712: PUSH
17713: LD_INT 3
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: PUSH
17720: LD_INT 30
17722: PUSH
17723: LD_INT 3
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: PUSH
17730: EMPTY
17731: LIST
17732: LIST
17733: PPUSH
17734: CALL_OW 72
17738: NOT
17739: IFFALSE 17743
// exit ;
17741: GO 18674
// base := mc_rus_2 ;
17743: LD_ADDR_VAR 0 2
17747: PUSH
17748: LD_EXP 8
17752: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17753: LD_ADDR_VAR 0 5
17757: PUSH
17758: LD_INT 22
17760: PUSH
17761: LD_INT 3
17763: PUSH
17764: EMPTY
17765: LIST
17766: LIST
17767: PUSH
17768: LD_INT 30
17770: PUSH
17771: LD_INT 34
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: PUSH
17778: EMPTY
17779: LIST
17780: LIST
17781: PPUSH
17782: CALL_OW 69
17786: ST_TO_ADDR
// if Prob ( 40 ) then
17787: LD_INT 40
17789: PPUSH
17790: CALL_OW 13
17794: IFFALSE 17923
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17796: LD_VAR 0 2
17800: PPUSH
17801: LD_INT 22
17803: PUSH
17804: LD_INT 3
17806: PUSH
17807: LD_INT 3
17809: PUSH
17810: LD_INT 49
17812: PUSH
17813: EMPTY
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 22
17821: PUSH
17822: LD_INT 3
17824: PUSH
17825: LD_INT 3
17827: PUSH
17828: LD_INT 49
17830: PUSH
17831: EMPTY
17832: LIST
17833: LIST
17834: LIST
17835: LIST
17836: PUSH
17837: LD_INT 22
17839: PUSH
17840: LD_INT 3
17842: PUSH
17843: LD_INT 3
17845: PUSH
17846: LD_INT 49
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: LIST
17853: LIST
17854: PUSH
17855: LD_INT 24
17857: PUSH
17858: LD_INT 3
17860: PUSH
17861: LD_INT 3
17863: PUSH
17864: LD_INT 46
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: LIST
17871: LIST
17872: PUSH
17873: LD_INT 24
17875: PUSH
17876: LD_INT 3
17878: PUSH
17879: LD_INT 3
17881: PUSH
17882: LD_INT 46
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: LIST
17890: PUSH
17891: LD_INT 24
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: LD_INT 3
17899: PUSH
17900: LD_INT 46
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: LIST
17907: LIST
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: LIST
17916: PPUSH
17917: CALL 86892 0 2
// end else
17921: GO 18048
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17923: LD_VAR 0 2
17927: PPUSH
17928: LD_INT 24
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 3
17936: PUSH
17937: LD_INT 47
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: PUSH
17946: LD_INT 24
17948: PUSH
17949: LD_INT 3
17951: PUSH
17952: LD_INT 3
17954: PUSH
17955: LD_INT 47
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: PUSH
17964: LD_INT 24
17966: PUSH
17967: LD_INT 3
17969: PUSH
17970: LD_INT 3
17972: PUSH
17973: LD_INT 47
17975: PUSH
17976: EMPTY
17977: LIST
17978: LIST
17979: LIST
17980: LIST
17981: PUSH
17982: LD_INT 24
17984: PUSH
17985: LD_INT 3
17987: PUSH
17988: LD_INT 3
17990: PUSH
17991: LD_INT 46
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: PUSH
18000: LD_INT 24
18002: PUSH
18003: LD_INT 3
18005: PUSH
18006: LD_INT 3
18008: PUSH
18009: LD_INT 46
18011: PUSH
18012: EMPTY
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: PUSH
18018: LD_INT 24
18020: PUSH
18021: LD_INT 3
18023: PUSH
18024: LD_INT 3
18026: PUSH
18027: LD_INT 46
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: PPUSH
18044: CALL 86892 0 2
// end ; if Difficulty > 1 then
18048: LD_OWVAR 67
18052: PUSH
18053: LD_INT 1
18055: GREATER
18056: IFFALSE 18088
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18058: LD_VAR 0 2
18062: PPUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 47
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: PPUSH
18084: CALL 86892 0 2
// repeat wait ( 0 0$1 ) ;
18088: LD_INT 35
18090: PPUSH
18091: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18095: LD_VAR 0 2
18099: PPUSH
18100: LD_INT 1
18102: PPUSH
18103: CALL 88310 0 2
18107: PUSH
18108: LD_INT 6
18110: PUSH
18111: LD_INT 7
18113: PUSH
18114: LD_INT 7
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: LIST
18121: PUSH
18122: LD_OWVAR 67
18126: ARRAY
18127: GREATEREQUAL
18128: PUSH
18129: LD_OWVAR 1
18133: PUSH
18134: LD_INT 21000
18136: MOD
18137: PUSH
18138: LD_INT 0
18140: EQUAL
18141: OR
18142: IFFALSE 18088
// wait ( 0 0$45 ) ;
18144: LD_INT 1575
18146: PPUSH
18147: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18151: LD_ADDR_VAR 0 3
18155: PUSH
18156: LD_VAR 0 2
18160: PPUSH
18161: LD_INT 1
18163: PPUSH
18164: CALL 88310 0 2
18168: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18169: LD_ADDR_EXP 50
18173: PUSH
18174: LD_EXP 50
18178: PPUSH
18179: LD_VAR 0 2
18183: PPUSH
18184: LD_EXP 50
18188: PUSH
18189: LD_VAR 0 2
18193: ARRAY
18194: PUSH
18195: LD_VAR 0 3
18199: DIFF
18200: PPUSH
18201: CALL_OW 1
18205: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18206: LD_ADDR_VAR 0 4
18210: PUSH
18211: LD_INT 0
18213: PPUSH
18214: LD_INT 1
18216: PPUSH
18217: CALL_OW 12
18221: ST_TO_ADDR
// if target then
18222: LD_VAR 0 4
18226: IFFALSE 18354
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18228: LD_ADDR_VAR 0 3
18232: PUSH
18233: LD_VAR 0 3
18237: PPUSH
18238: LD_INT 24
18240: PUSH
18241: LD_INT 250
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PPUSH
18248: CALL_OW 72
18252: ST_TO_ADDR
// for i in tmp do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: LD_VAR 0 3
18262: PUSH
18263: FOR_IN
18264: IFFALSE 18304
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18266: LD_VAR 0 1
18270: PPUSH
18271: LD_INT 84
18273: PPUSH
18274: LD_INT 32
18276: PPUSH
18277: CALL_OW 297
18281: PUSH
18282: LD_INT 9
18284: GREATER
18285: IFFALSE 18302
// ComMoveXY ( i , 84 , 32 ) ;
18287: LD_VAR 0 1
18291: PPUSH
18292: LD_INT 84
18294: PPUSH
18295: LD_INT 32
18297: PPUSH
18298: CALL_OW 111
18302: GO 18263
18304: POP
18305: POP
// wait ( 0 0$1 ) ;
18306: LD_INT 35
18308: PPUSH
18309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18313: LD_VAR 0 3
18317: PPUSH
18318: LD_INT 92
18320: PUSH
18321: LD_INT 84
18323: PUSH
18324: LD_INT 32
18326: PUSH
18327: LD_INT 9
18329: PUSH
18330: EMPTY
18331: LIST
18332: LIST
18333: LIST
18334: LIST
18335: PPUSH
18336: CALL_OW 72
18340: PUSH
18341: LD_VAR 0 3
18345: PUSH
18346: LD_INT 1
18348: MINUS
18349: GREATEREQUAL
18350: IFFALSE 18228
// end else
18352: GO 18514
// begin if teleport then
18354: LD_VAR 0 5
18358: IFFALSE 18378
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18360: LD_VAR 0 3
18364: PPUSH
18365: LD_VAR 0 5
18369: PUSH
18370: LD_INT 1
18372: ARRAY
18373: PPUSH
18374: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18378: LD_ADDR_VAR 0 3
18382: PUSH
18383: LD_VAR 0 3
18387: PPUSH
18388: LD_INT 24
18390: PUSH
18391: LD_INT 250
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PPUSH
18398: CALL_OW 72
18402: ST_TO_ADDR
// for i in tmp do
18403: LD_ADDR_VAR 0 1
18407: PUSH
18408: LD_VAR 0 3
18412: PUSH
18413: FOR_IN
18414: IFFALSE 18466
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18416: LD_VAR 0 1
18420: PPUSH
18421: LD_INT 140
18423: PPUSH
18424: LD_INT 219
18426: PPUSH
18427: CALL_OW 297
18431: PUSH
18432: LD_INT 9
18434: GREATER
18435: PUSH
18436: LD_VAR 0 1
18440: PPUSH
18441: CALL_OW 314
18445: NOT
18446: AND
18447: IFFALSE 18464
// AddComMoveXY ( i , 140 , 219 ) ;
18449: LD_VAR 0 1
18453: PPUSH
18454: LD_INT 140
18456: PPUSH
18457: LD_INT 219
18459: PPUSH
18460: CALL_OW 171
18464: GO 18413
18466: POP
18467: POP
// wait ( 0 0$1 ) ;
18468: LD_INT 35
18470: PPUSH
18471: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18475: LD_VAR 0 3
18479: PPUSH
18480: LD_INT 92
18482: PUSH
18483: LD_INT 140
18485: PUSH
18486: LD_INT 219
18488: PUSH
18489: LD_INT 9
18491: PUSH
18492: EMPTY
18493: LIST
18494: LIST
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 72
18502: PUSH
18503: LD_VAR 0 3
18507: PUSH
18508: LD_INT 1
18510: MINUS
18511: GREATEREQUAL
18512: IFFALSE 18378
// end ; repeat wait ( 0 0$1 ) ;
18514: LD_INT 35
18516: PPUSH
18517: CALL_OW 67
// for i in tmp do
18521: LD_ADDR_VAR 0 1
18525: PUSH
18526: LD_VAR 0 3
18530: PUSH
18531: FOR_IN
18532: IFFALSE 18665
// begin if GetLives ( i ) > 251 then
18534: LD_VAR 0 1
18538: PPUSH
18539: CALL_OW 256
18543: PUSH
18544: LD_INT 251
18546: GREATER
18547: IFFALSE 18636
// begin if GetWeapon ( i ) = ru_time_lapser then
18549: LD_VAR 0 1
18553: PPUSH
18554: CALL_OW 264
18558: PUSH
18559: LD_INT 49
18561: EQUAL
18562: IFFALSE 18600
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18564: LD_VAR 0 1
18568: PPUSH
18569: LD_INT 81
18571: PUSH
18572: LD_INT 3
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PPUSH
18579: CALL_OW 69
18583: PPUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 74
18593: PPUSH
18594: CALL_OW 112
18598: GO 18634
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 81
18607: PUSH
18608: LD_INT 3
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL_OW 69
18619: PPUSH
18620: LD_VAR 0 1
18624: PPUSH
18625: CALL_OW 74
18629: PPUSH
18630: CALL_OW 115
// end else
18634: GO 18663
// if IsDead ( i ) then
18636: LD_VAR 0 1
18640: PPUSH
18641: CALL_OW 301
18645: IFFALSE 18663
// tmp := tmp diff i ;
18647: LD_ADDR_VAR 0 3
18651: PUSH
18652: LD_VAR 0 3
18656: PUSH
18657: LD_VAR 0 1
18661: DIFF
18662: ST_TO_ADDR
// end ;
18663: GO 18531
18665: POP
18666: POP
// until not tmp ;
18667: LD_VAR 0 3
18671: NOT
18672: IFFALSE 18514
// end ;
18674: PPOPN 5
18676: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18677: LD_EXP 3
18681: IFFALSE 19063
18683: GO 18685
18685: DISABLE
18686: LD_INT 0
18688: PPUSH
18689: PPUSH
18690: PPUSH
18691: PPUSH
// begin enable ;
18692: ENABLE
// base := mc_amer ;
18693: LD_ADDR_VAR 0 2
18697: PUSH
18698: LD_EXP 5
18702: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18703: LD_INT 22
18705: PUSH
18706: LD_INT 4
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: PUSH
18713: LD_INT 23
18715: PUSH
18716: LD_INT 1
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 30
18725: PUSH
18726: LD_INT 3
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: PPUSH
18738: CALL_OW 69
18742: NOT
18743: IFFALSE 18747
// exit ;
18745: GO 19063
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18747: LD_VAR 0 2
18751: PPUSH
18752: LD_INT 3
18754: PUSH
18755: LD_INT 1
18757: PUSH
18758: LD_INT 2
18760: PUSH
18761: LD_INT 5
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: LD_INT 1
18775: PUSH
18776: LD_INT 2
18778: PUSH
18779: LD_INT 9
18781: PUSH
18782: EMPTY
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: PUSH
18788: LD_INT 3
18790: PUSH
18791: LD_INT 1
18793: PUSH
18794: LD_INT 2
18796: PUSH
18797: LD_INT 7
18799: PUSH
18800: EMPTY
18801: LIST
18802: LIST
18803: LIST
18804: LIST
18805: PUSH
18806: LD_INT 3
18808: PUSH
18809: LD_INT 1
18811: PUSH
18812: LD_INT 2
18814: PUSH
18815: LD_INT 7
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: PUSH
18824: LD_INT 3
18826: PUSH
18827: LD_INT 1
18829: PUSH
18830: LD_INT 2
18832: PUSH
18833: LD_INT 7
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL 86892 0 2
// repeat wait ( 0 0$1 ) ;
18853: LD_INT 35
18855: PPUSH
18856: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18860: LD_VAR 0 2
18864: PPUSH
18865: LD_INT 1
18867: PPUSH
18868: CALL 88310 0 2
18872: PUSH
18873: LD_INT 5
18875: GREATEREQUAL
18876: PUSH
18877: LD_OWVAR 1
18881: PUSH
18882: LD_INT 21000
18884: MOD
18885: PUSH
18886: LD_INT 0
18888: EQUAL
18889: OR
18890: IFFALSE 18853
// wait ( 0 0$30 ) ;
18892: LD_INT 1050
18894: PPUSH
18895: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18899: LD_ADDR_VAR 0 3
18903: PUSH
18904: LD_VAR 0 2
18908: PPUSH
18909: LD_INT 1
18911: PPUSH
18912: CALL 88310 0 2
18916: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18917: LD_ADDR_EXP 50
18921: PUSH
18922: LD_EXP 50
18926: PPUSH
18927: LD_VAR 0 2
18931: PPUSH
18932: LD_EXP 50
18936: PUSH
18937: LD_VAR 0 2
18941: ARRAY
18942: PUSH
18943: LD_VAR 0 3
18947: DIFF
18948: PPUSH
18949: CALL_OW 1
18953: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18954: LD_INT 35
18956: PPUSH
18957: CALL_OW 67
// for i in tmp do
18961: LD_ADDR_VAR 0 1
18965: PUSH
18966: LD_VAR 0 3
18970: PUSH
18971: FOR_IN
18972: IFFALSE 19054
// begin if GetLives ( i ) > 251 then
18974: LD_VAR 0 1
18978: PPUSH
18979: CALL_OW 256
18983: PUSH
18984: LD_INT 251
18986: GREATER
18987: IFFALSE 19025
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
18989: LD_VAR 0 1
18993: PPUSH
18994: LD_INT 81
18996: PUSH
18997: LD_INT 4
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: PPUSH
19004: CALL_OW 69
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 74
19018: PPUSH
19019: CALL_OW 115
19023: GO 19052
// if IsDead ( i ) then
19025: LD_VAR 0 1
19029: PPUSH
19030: CALL_OW 301
19034: IFFALSE 19052
// tmp := tmp diff i ;
19036: LD_ADDR_VAR 0 3
19040: PUSH
19041: LD_VAR 0 3
19045: PUSH
19046: LD_VAR 0 1
19050: DIFF
19051: ST_TO_ADDR
// end ;
19052: GO 18971
19054: POP
19055: POP
// until not tmp ;
19056: LD_VAR 0 3
19060: NOT
19061: IFFALSE 18954
// end ; end_of_file
19063: PPOPN 4
19065: END
// export function CustomEvent ( event ) ; begin
19066: LD_INT 0
19068: PPUSH
// end ;
19069: LD_VAR 0 2
19073: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19074: LD_VAR 0 1
19078: PUSH
19079: LD_INT 1
19081: EQUAL
19082: PUSH
19083: LD_VAR 0 2
19087: PUSH
19088: LD_INT 4
19090: EQUAL
19091: AND
19092: IFFALSE 19120
// begin SayRadio ( Powell , DP-Lost ) ;
19094: LD_EXP 12
19098: PPUSH
19099: LD_STRING DP-Lost
19101: PPUSH
19102: CALL_OW 94
// wait ( 0 0$2 ) ;
19106: LD_INT 70
19108: PPUSH
19109: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19113: LD_STRING FriendlyFire
19115: PPUSH
19116: CALL_OW 104
// end ; end ;
19120: PPOPN 2
19122: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19123: LD_VAR 0 1
19127: PPUSH
19128: CALL 109137 0 1
// if GameType = 1 then
19132: LD_EXP 2
19136: PUSH
19137: LD_INT 1
19139: EQUAL
19140: IFFALSE 19375
// begin if un = playerCommander then
19142: LD_VAR 0 1
19146: PUSH
19147: LD_EXP 9
19151: EQUAL
19152: IFFALSE 19161
// YouLost ( commanderDied ) ;
19154: LD_STRING commanderDied
19156: PPUSH
19157: CALL_OW 104
// if un = allyCommander then
19161: LD_VAR 0 1
19165: PUSH
19166: LD_EXP 11
19170: EQUAL
19171: IFFALSE 19180
// YouLost ( Theta ) ;
19173: LD_STRING Theta
19175: PPUSH
19176: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19180: LD_VAR 0 1
19184: PUSH
19185: LD_INT 22
19187: PUSH
19188: LD_INT 8
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: PUSH
19195: LD_INT 2
19197: PUSH
19198: LD_INT 21
19200: PUSH
19201: LD_INT 1
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 21
19210: PUSH
19211: LD_INT 3
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: LIST
19222: PUSH
19223: EMPTY
19224: LIST
19225: LIST
19226: PPUSH
19227: CALL_OW 69
19231: IN
19232: IFFALSE 19248
// legDestCounter := legDestCounter + 1 ;
19234: LD_ADDR_EXP 18
19238: PUSH
19239: LD_EXP 18
19243: PUSH
19244: LD_INT 1
19246: PLUS
19247: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19248: LD_VAR 0 1
19252: PUSH
19253: LD_INT 22
19255: PUSH
19256: LD_INT 4
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 2
19265: PUSH
19266: LD_INT 21
19268: PUSH
19269: LD_INT 1
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 21
19278: PUSH
19279: LD_INT 3
19281: PUSH
19282: EMPTY
19283: LIST
19284: LIST
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: LIST
19290: PUSH
19291: EMPTY
19292: LIST
19293: LIST
19294: PPUSH
19295: CALL_OW 69
19299: IN
19300: IFFALSE 19316
// allyDestCounter := allyDestCounter + 1 ;
19302: LD_ADDR_EXP 22
19306: PUSH
19307: LD_EXP 22
19311: PUSH
19312: LD_INT 1
19314: PLUS
19315: ST_TO_ADDR
// if un in ruOutpost then
19316: LD_VAR 0 1
19320: PUSH
19321: LD_EXP 14
19325: IN
19326: IFFALSE 19375
// begin ruOutpost := ruOutpost diff un ;
19328: LD_ADDR_EXP 14
19332: PUSH
19333: LD_EXP 14
19337: PUSH
19338: LD_VAR 0 1
19342: DIFF
19343: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19344: LD_ADDR_EXP 15
19348: PUSH
19349: LD_EXP 15
19353: PPUSH
19354: LD_INT 1
19356: PPUSH
19357: LD_EXP 15
19361: PUSH
19362: LD_INT 1
19364: ARRAY
19365: PUSH
19366: LD_INT 1
19368: PLUS
19369: PPUSH
19370: CALL_OW 1
19374: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: CALL 90334 0 1
// end ;
19384: PPOPN 1
19386: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_VAR 0 2
19396: PPUSH
19397: CALL 92666 0 2
// end ;
19401: PPOPN 2
19403: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19404: LD_VAR 0 1
19408: PPUSH
19409: CALL 91734 0 1
// end ;
19413: PPOPN 1
19415: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19416: LD_VAR 0 1
19420: PPUSH
19421: CALL 91975 0 1
// end ;
19425: PPOPN 1
19427: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19428: LD_VAR 0 1
19432: PUSH
19433: LD_INT 14
19435: EQUAL
19436: PUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL_OW 255
19446: PUSH
19447: LD_INT 1
19449: EQUAL
19450: AND
19451: IFFALSE 19492
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19453: LD_EXP 9
19457: PPUSH
19458: LD_STRING D
19460: PUSH
19461: LD_STRING I
19463: PUSH
19464: LD_STRING J
19466: PUSH
19467: LD_STRING S
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: LIST
19474: PUSH
19475: LD_EXP 25
19479: ARRAY
19480: STR
19481: PUSH
19482: LD_STRING -1-Laser
19484: STR
19485: PPUSH
19486: CALL_OW 88
// exit ;
19490: GO 19634
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19492: LD_VAR 0 1
19496: PUSH
19497: LD_INT 7
19499: EQUAL
19500: PUSH
19501: LD_VAR 0 2
19505: PPUSH
19506: CALL_OW 255
19510: PUSH
19511: LD_INT 1
19513: EQUAL
19514: AND
19515: IFFALSE 19556
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19517: LD_EXP 9
19521: PPUSH
19522: LD_STRING D
19524: PUSH
19525: LD_STRING I
19527: PUSH
19528: LD_STRING J
19530: PUSH
19531: LD_STRING S
19533: PUSH
19534: EMPTY
19535: LIST
19536: LIST
19537: LIST
19538: PUSH
19539: LD_EXP 25
19543: ARRAY
19544: STR
19545: PUSH
19546: LD_STRING -1-Materialization
19548: STR
19549: PPUSH
19550: CALL_OW 88
// exit ;
19554: GO 19634
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19556: LD_VAR 0 1
19560: PUSH
19561: LD_INT 25
19563: EQUAL
19564: PUSH
19565: LD_VAR 0 2
19569: PPUSH
19570: CALL_OW 255
19574: PUSH
19575: LD_INT 1
19577: EQUAL
19578: AND
19579: IFFALSE 19620
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19581: LD_EXP 9
19585: PPUSH
19586: LD_STRING D
19588: PUSH
19589: LD_STRING I
19591: PUSH
19592: LD_STRING J
19594: PUSH
19595: LD_STRING S
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: LIST
19602: PUSH
19603: LD_EXP 25
19607: ARRAY
19608: STR
19609: PUSH
19610: LD_STRING -1-Rocket
19612: STR
19613: PPUSH
19614: CALL_OW 88
// exit ;
19618: GO 19634
// end ; MCE_ResearchComplete ( tech , lab ) ;
19620: LD_VAR 0 1
19624: PPUSH
19625: LD_VAR 0 2
19629: PPUSH
19630: CALL 90030 0 2
// end ;
19634: PPOPN 2
19636: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19637: LD_VAR 0 1
19641: PPUSH
19642: LD_VAR 0 2
19646: PPUSH
19647: LD_VAR 0 3
19651: PPUSH
19652: LD_VAR 0 4
19656: PPUSH
19657: LD_VAR 0 5
19661: PPUSH
19662: CALL 89650 0 5
// end ;
19666: PPOPN 5
19668: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19669: LD_VAR 0 1
19673: PPUSH
19674: LD_VAR 0 2
19678: PPUSH
19679: CALL 109257 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19683: LD_VAR 0 1
19687: PPUSH
19688: LD_VAR 0 2
19692: PPUSH
19693: CALL 89203 0 2
// end ;
19697: PPOPN 2
19699: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19700: LD_VAR 0 1
19704: PPUSH
19705: LD_VAR 0 2
19709: PPUSH
19710: LD_VAR 0 3
19714: PPUSH
19715: LD_VAR 0 4
19719: PPUSH
19720: CALL 89041 0 4
// end ;
19724: PPOPN 4
19726: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19727: LD_VAR 0 1
19731: PPUSH
19732: LD_VAR 0 2
19736: PPUSH
19737: LD_VAR 0 3
19741: PPUSH
19742: CALL 88816 0 3
// end ;
19746: PPOPN 3
19748: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19749: LD_VAR 0 1
19753: PPUSH
19754: LD_VAR 0 2
19758: PPUSH
19759: CALL 88701 0 2
// end ;
19763: PPOPN 2
19765: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19766: LD_VAR 0 1
19770: PPUSH
19771: LD_VAR 0 2
19775: PPUSH
19776: CALL 92961 0 2
// end ;
19780: PPOPN 2
19782: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19783: LD_VAR 0 1
19787: PPUSH
19788: LD_VAR 0 2
19792: PPUSH
19793: LD_VAR 0 3
19797: PPUSH
19798: LD_VAR 0 4
19802: PPUSH
19803: CALL 93177 0 4
// end ;
19807: PPOPN 4
19809: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19810: LD_VAR 0 1
19814: PPUSH
19815: LD_VAR 0 2
19819: PPUSH
19820: CALL 88510 0 2
// end ;
19824: PPOPN 2
19826: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19827: LD_VAR 0 1
19831: PPUSH
19832: CALL 109241 0 1
// end ; end_of_file
19836: PPOPN 1
19838: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19839: LD_INT 0
19841: PPUSH
19842: PPUSH
// if exist_mode then
19843: LD_VAR 0 2
19847: IFFALSE 19872
// unit := CreateCharacter ( prefix & ident ) else
19849: LD_ADDR_VAR 0 5
19853: PUSH
19854: LD_VAR 0 3
19858: PUSH
19859: LD_VAR 0 1
19863: STR
19864: PPUSH
19865: CALL_OW 34
19869: ST_TO_ADDR
19870: GO 19887
// unit := NewCharacter ( ident ) ;
19872: LD_ADDR_VAR 0 5
19876: PUSH
19877: LD_VAR 0 1
19881: PPUSH
19882: CALL_OW 25
19886: ST_TO_ADDR
// result := unit ;
19887: LD_ADDR_VAR 0 4
19891: PUSH
19892: LD_VAR 0 5
19896: ST_TO_ADDR
// end ;
19897: LD_VAR 0 4
19901: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19902: LD_INT 0
19904: PPUSH
19905: PPUSH
// if not side or not nation then
19906: LD_VAR 0 1
19910: NOT
19911: PUSH
19912: LD_VAR 0 2
19916: NOT
19917: OR
19918: IFFALSE 19922
// exit ;
19920: GO 20690
// case nation of nation_american :
19922: LD_VAR 0 2
19926: PUSH
19927: LD_INT 1
19929: DOUBLE
19930: EQUAL
19931: IFTRUE 19935
19933: GO 20149
19935: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19936: LD_ADDR_VAR 0 4
19940: PUSH
19941: LD_INT 35
19943: PUSH
19944: LD_INT 45
19946: PUSH
19947: LD_INT 46
19949: PUSH
19950: LD_INT 47
19952: PUSH
19953: LD_INT 82
19955: PUSH
19956: LD_INT 83
19958: PUSH
19959: LD_INT 84
19961: PUSH
19962: LD_INT 85
19964: PUSH
19965: LD_INT 86
19967: PUSH
19968: LD_INT 1
19970: PUSH
19971: LD_INT 2
19973: PUSH
19974: LD_INT 6
19976: PUSH
19977: LD_INT 15
19979: PUSH
19980: LD_INT 16
19982: PUSH
19983: LD_INT 7
19985: PUSH
19986: LD_INT 12
19988: PUSH
19989: LD_INT 13
19991: PUSH
19992: LD_INT 10
19994: PUSH
19995: LD_INT 14
19997: PUSH
19998: LD_INT 20
20000: PUSH
20001: LD_INT 21
20003: PUSH
20004: LD_INT 22
20006: PUSH
20007: LD_INT 25
20009: PUSH
20010: LD_INT 32
20012: PUSH
20013: LD_INT 27
20015: PUSH
20016: LD_INT 36
20018: PUSH
20019: LD_INT 69
20021: PUSH
20022: LD_INT 39
20024: PUSH
20025: LD_INT 34
20027: PUSH
20028: LD_INT 40
20030: PUSH
20031: LD_INT 48
20033: PUSH
20034: LD_INT 49
20036: PUSH
20037: LD_INT 50
20039: PUSH
20040: LD_INT 51
20042: PUSH
20043: LD_INT 52
20045: PUSH
20046: LD_INT 53
20048: PUSH
20049: LD_INT 54
20051: PUSH
20052: LD_INT 55
20054: PUSH
20055: LD_INT 56
20057: PUSH
20058: LD_INT 57
20060: PUSH
20061: LD_INT 58
20063: PUSH
20064: LD_INT 59
20066: PUSH
20067: LD_INT 60
20069: PUSH
20070: LD_INT 61
20072: PUSH
20073: LD_INT 62
20075: PUSH
20076: LD_INT 80
20078: PUSH
20079: LD_INT 82
20081: PUSH
20082: LD_INT 83
20084: PUSH
20085: LD_INT 84
20087: PUSH
20088: LD_INT 85
20090: PUSH
20091: LD_INT 86
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: LIST
20102: LIST
20103: LIST
20104: LIST
20105: LIST
20106: LIST
20107: LIST
20108: LIST
20109: LIST
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: LIST
20115: LIST
20116: LIST
20117: LIST
20118: LIST
20119: LIST
20120: LIST
20121: LIST
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: LIST
20130: LIST
20131: LIST
20132: LIST
20133: LIST
20134: LIST
20135: LIST
20136: LIST
20137: LIST
20138: LIST
20139: LIST
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: ST_TO_ADDR
20147: GO 20614
20149: LD_INT 2
20151: DOUBLE
20152: EQUAL
20153: IFTRUE 20157
20155: GO 20383
20157: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20158: LD_ADDR_VAR 0 4
20162: PUSH
20163: LD_INT 35
20165: PUSH
20166: LD_INT 45
20168: PUSH
20169: LD_INT 46
20171: PUSH
20172: LD_INT 47
20174: PUSH
20175: LD_INT 82
20177: PUSH
20178: LD_INT 83
20180: PUSH
20181: LD_INT 84
20183: PUSH
20184: LD_INT 85
20186: PUSH
20187: LD_INT 87
20189: PUSH
20190: LD_INT 70
20192: PUSH
20193: LD_INT 1
20195: PUSH
20196: LD_INT 11
20198: PUSH
20199: LD_INT 3
20201: PUSH
20202: LD_INT 4
20204: PUSH
20205: LD_INT 5
20207: PUSH
20208: LD_INT 6
20210: PUSH
20211: LD_INT 15
20213: PUSH
20214: LD_INT 18
20216: PUSH
20217: LD_INT 7
20219: PUSH
20220: LD_INT 17
20222: PUSH
20223: LD_INT 8
20225: PUSH
20226: LD_INT 20
20228: PUSH
20229: LD_INT 21
20231: PUSH
20232: LD_INT 22
20234: PUSH
20235: LD_INT 72
20237: PUSH
20238: LD_INT 26
20240: PUSH
20241: LD_INT 69
20243: PUSH
20244: LD_INT 39
20246: PUSH
20247: LD_INT 40
20249: PUSH
20250: LD_INT 41
20252: PUSH
20253: LD_INT 42
20255: PUSH
20256: LD_INT 43
20258: PUSH
20259: LD_INT 48
20261: PUSH
20262: LD_INT 49
20264: PUSH
20265: LD_INT 50
20267: PUSH
20268: LD_INT 51
20270: PUSH
20271: LD_INT 52
20273: PUSH
20274: LD_INT 53
20276: PUSH
20277: LD_INT 54
20279: PUSH
20280: LD_INT 55
20282: PUSH
20283: LD_INT 56
20285: PUSH
20286: LD_INT 60
20288: PUSH
20289: LD_INT 61
20291: PUSH
20292: LD_INT 62
20294: PUSH
20295: LD_INT 66
20297: PUSH
20298: LD_INT 67
20300: PUSH
20301: LD_INT 68
20303: PUSH
20304: LD_INT 81
20306: PUSH
20307: LD_INT 82
20309: PUSH
20310: LD_INT 83
20312: PUSH
20313: LD_INT 84
20315: PUSH
20316: LD_INT 85
20318: PUSH
20319: LD_INT 87
20321: PUSH
20322: LD_INT 88
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: LIST
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: LIST
20349: LIST
20350: LIST
20351: LIST
20352: LIST
20353: LIST
20354: LIST
20355: LIST
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: LIST
20361: LIST
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: ST_TO_ADDR
20381: GO 20614
20383: LD_INT 3
20385: DOUBLE
20386: EQUAL
20387: IFTRUE 20391
20389: GO 20613
20391: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20392: LD_ADDR_VAR 0 4
20396: PUSH
20397: LD_INT 46
20399: PUSH
20400: LD_INT 47
20402: PUSH
20403: LD_INT 1
20405: PUSH
20406: LD_INT 2
20408: PUSH
20409: LD_INT 82
20411: PUSH
20412: LD_INT 83
20414: PUSH
20415: LD_INT 84
20417: PUSH
20418: LD_INT 85
20420: PUSH
20421: LD_INT 86
20423: PUSH
20424: LD_INT 11
20426: PUSH
20427: LD_INT 9
20429: PUSH
20430: LD_INT 20
20432: PUSH
20433: LD_INT 19
20435: PUSH
20436: LD_INT 21
20438: PUSH
20439: LD_INT 24
20441: PUSH
20442: LD_INT 22
20444: PUSH
20445: LD_INT 25
20447: PUSH
20448: LD_INT 28
20450: PUSH
20451: LD_INT 29
20453: PUSH
20454: LD_INT 30
20456: PUSH
20457: LD_INT 31
20459: PUSH
20460: LD_INT 37
20462: PUSH
20463: LD_INT 38
20465: PUSH
20466: LD_INT 32
20468: PUSH
20469: LD_INT 27
20471: PUSH
20472: LD_INT 33
20474: PUSH
20475: LD_INT 69
20477: PUSH
20478: LD_INT 39
20480: PUSH
20481: LD_INT 34
20483: PUSH
20484: LD_INT 40
20486: PUSH
20487: LD_INT 71
20489: PUSH
20490: LD_INT 23
20492: PUSH
20493: LD_INT 44
20495: PUSH
20496: LD_INT 48
20498: PUSH
20499: LD_INT 49
20501: PUSH
20502: LD_INT 50
20504: PUSH
20505: LD_INT 51
20507: PUSH
20508: LD_INT 52
20510: PUSH
20511: LD_INT 53
20513: PUSH
20514: LD_INT 54
20516: PUSH
20517: LD_INT 55
20519: PUSH
20520: LD_INT 56
20522: PUSH
20523: LD_INT 57
20525: PUSH
20526: LD_INT 58
20528: PUSH
20529: LD_INT 59
20531: PUSH
20532: LD_INT 63
20534: PUSH
20535: LD_INT 64
20537: PUSH
20538: LD_INT 65
20540: PUSH
20541: LD_INT 82
20543: PUSH
20544: LD_INT 83
20546: PUSH
20547: LD_INT 84
20549: PUSH
20550: LD_INT 85
20552: PUSH
20553: LD_INT 86
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: ST_TO_ADDR
20611: GO 20614
20613: POP
// if state > - 1 and state < 3 then
20614: LD_VAR 0 3
20618: PUSH
20619: LD_INT 1
20621: NEG
20622: GREATER
20623: PUSH
20624: LD_VAR 0 3
20628: PUSH
20629: LD_INT 3
20631: LESS
20632: AND
20633: IFFALSE 20690
// for i in result do
20635: LD_ADDR_VAR 0 5
20639: PUSH
20640: LD_VAR 0 4
20644: PUSH
20645: FOR_IN
20646: IFFALSE 20688
// if GetTech ( i , side ) <> state then
20648: LD_VAR 0 5
20652: PPUSH
20653: LD_VAR 0 1
20657: PPUSH
20658: CALL_OW 321
20662: PUSH
20663: LD_VAR 0 3
20667: NONEQUAL
20668: IFFALSE 20686
// result := result diff i ;
20670: LD_ADDR_VAR 0 4
20674: PUSH
20675: LD_VAR 0 4
20679: PUSH
20680: LD_VAR 0 5
20684: DIFF
20685: ST_TO_ADDR
20686: GO 20645
20688: POP
20689: POP
// end ;
20690: LD_VAR 0 4
20694: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20695: LD_INT 0
20697: PPUSH
20698: PPUSH
20699: PPUSH
// result := true ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 1
20707: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: LD_VAR 0 2
20717: PPUSH
20718: CALL_OW 480
20722: ST_TO_ADDR
// if not tmp then
20723: LD_VAR 0 5
20727: NOT
20728: IFFALSE 20732
// exit ;
20730: GO 20781
// for i in tmp do
20732: LD_ADDR_VAR 0 4
20736: PUSH
20737: LD_VAR 0 5
20741: PUSH
20742: FOR_IN
20743: IFFALSE 20779
// if GetTech ( i , side ) <> state_researched then
20745: LD_VAR 0 4
20749: PPUSH
20750: LD_VAR 0 1
20754: PPUSH
20755: CALL_OW 321
20759: PUSH
20760: LD_INT 2
20762: NONEQUAL
20763: IFFALSE 20777
// begin result := false ;
20765: LD_ADDR_VAR 0 3
20769: PUSH
20770: LD_INT 0
20772: ST_TO_ADDR
// exit ;
20773: POP
20774: POP
20775: GO 20781
// end ;
20777: GO 20742
20779: POP
20780: POP
// end ;
20781: LD_VAR 0 3
20785: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20786: LD_INT 0
20788: PPUSH
20789: PPUSH
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
20796: PPUSH
20797: PPUSH
20798: PPUSH
20799: PPUSH
20800: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20801: LD_VAR 0 1
20805: NOT
20806: PUSH
20807: LD_VAR 0 1
20811: PPUSH
20812: CALL_OW 257
20816: PUSH
20817: LD_INT 9
20819: NONEQUAL
20820: OR
20821: IFFALSE 20825
// exit ;
20823: GO 21398
// side := GetSide ( unit ) ;
20825: LD_ADDR_VAR 0 9
20829: PUSH
20830: LD_VAR 0 1
20834: PPUSH
20835: CALL_OW 255
20839: ST_TO_ADDR
// tech_space := tech_spacanom ;
20840: LD_ADDR_VAR 0 12
20844: PUSH
20845: LD_INT 29
20847: ST_TO_ADDR
// tech_time := tech_taurad ;
20848: LD_ADDR_VAR 0 13
20852: PUSH
20853: LD_INT 28
20855: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20856: LD_ADDR_VAR 0 11
20860: PUSH
20861: LD_VAR 0 1
20865: PPUSH
20866: CALL_OW 310
20870: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20871: LD_VAR 0 11
20875: PPUSH
20876: CALL_OW 247
20880: PUSH
20881: LD_INT 2
20883: EQUAL
20884: IFFALSE 20888
// exit ;
20886: GO 21398
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20888: LD_ADDR_VAR 0 8
20892: PUSH
20893: LD_INT 81
20895: PUSH
20896: LD_VAR 0 9
20900: PUSH
20901: EMPTY
20902: LIST
20903: LIST
20904: PUSH
20905: LD_INT 3
20907: PUSH
20908: LD_INT 21
20910: PUSH
20911: LD_INT 3
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: PUSH
20922: EMPTY
20923: LIST
20924: LIST
20925: PPUSH
20926: CALL_OW 69
20930: ST_TO_ADDR
// if not tmp then
20931: LD_VAR 0 8
20935: NOT
20936: IFFALSE 20940
// exit ;
20938: GO 21398
// if in_unit then
20940: LD_VAR 0 11
20944: IFFALSE 20968
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20946: LD_ADDR_VAR 0 10
20950: PUSH
20951: LD_VAR 0 8
20955: PPUSH
20956: LD_VAR 0 11
20960: PPUSH
20961: CALL_OW 74
20965: ST_TO_ADDR
20966: GO 20988
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20968: LD_ADDR_VAR 0 10
20972: PUSH
20973: LD_VAR 0 8
20977: PPUSH
20978: LD_VAR 0 1
20982: PPUSH
20983: CALL_OW 74
20987: ST_TO_ADDR
// if not enemy then
20988: LD_VAR 0 10
20992: NOT
20993: IFFALSE 20997
// exit ;
20995: GO 21398
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20997: LD_VAR 0 11
21001: PUSH
21002: LD_VAR 0 11
21006: PPUSH
21007: LD_VAR 0 10
21011: PPUSH
21012: CALL_OW 296
21016: PUSH
21017: LD_INT 13
21019: GREATER
21020: AND
21021: PUSH
21022: LD_VAR 0 1
21026: PPUSH
21027: LD_VAR 0 10
21031: PPUSH
21032: CALL_OW 296
21036: PUSH
21037: LD_INT 12
21039: GREATER
21040: OR
21041: IFFALSE 21045
// exit ;
21043: GO 21398
// missile := [ 1 ] ;
21045: LD_ADDR_VAR 0 14
21049: PUSH
21050: LD_INT 1
21052: PUSH
21053: EMPTY
21054: LIST
21055: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21056: LD_VAR 0 9
21060: PPUSH
21061: LD_VAR 0 12
21065: PPUSH
21066: CALL_OW 325
21070: IFFALSE 21099
// missile := Replace ( missile , missile + 1 , 2 ) ;
21072: LD_ADDR_VAR 0 14
21076: PUSH
21077: LD_VAR 0 14
21081: PPUSH
21082: LD_VAR 0 14
21086: PUSH
21087: LD_INT 1
21089: PLUS
21090: PPUSH
21091: LD_INT 2
21093: PPUSH
21094: CALL_OW 1
21098: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21099: LD_VAR 0 9
21103: PPUSH
21104: LD_VAR 0 13
21108: PPUSH
21109: CALL_OW 325
21113: PUSH
21114: LD_VAR 0 10
21118: PPUSH
21119: CALL_OW 255
21123: PPUSH
21124: LD_VAR 0 13
21128: PPUSH
21129: CALL_OW 325
21133: NOT
21134: AND
21135: IFFALSE 21164
// missile := Replace ( missile , missile + 1 , 3 ) ;
21137: LD_ADDR_VAR 0 14
21141: PUSH
21142: LD_VAR 0 14
21146: PPUSH
21147: LD_VAR 0 14
21151: PUSH
21152: LD_INT 1
21154: PLUS
21155: PPUSH
21156: LD_INT 3
21158: PPUSH
21159: CALL_OW 1
21163: ST_TO_ADDR
// if missile < 2 then
21164: LD_VAR 0 14
21168: PUSH
21169: LD_INT 2
21171: LESS
21172: IFFALSE 21176
// exit ;
21174: GO 21398
// x := GetX ( enemy ) ;
21176: LD_ADDR_VAR 0 4
21180: PUSH
21181: LD_VAR 0 10
21185: PPUSH
21186: CALL_OW 250
21190: ST_TO_ADDR
// y := GetY ( enemy ) ;
21191: LD_ADDR_VAR 0 5
21195: PUSH
21196: LD_VAR 0 10
21200: PPUSH
21201: CALL_OW 251
21205: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21206: LD_ADDR_VAR 0 6
21210: PUSH
21211: LD_VAR 0 4
21215: PUSH
21216: LD_INT 1
21218: NEG
21219: PPUSH
21220: LD_INT 1
21222: PPUSH
21223: CALL_OW 12
21227: PLUS
21228: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21229: LD_ADDR_VAR 0 7
21233: PUSH
21234: LD_VAR 0 5
21238: PUSH
21239: LD_INT 1
21241: NEG
21242: PPUSH
21243: LD_INT 1
21245: PPUSH
21246: CALL_OW 12
21250: PLUS
21251: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21252: LD_VAR 0 6
21256: PPUSH
21257: LD_VAR 0 7
21261: PPUSH
21262: CALL_OW 488
21266: NOT
21267: IFFALSE 21289
// begin _x := x ;
21269: LD_ADDR_VAR 0 6
21273: PUSH
21274: LD_VAR 0 4
21278: ST_TO_ADDR
// _y := y ;
21279: LD_ADDR_VAR 0 7
21283: PUSH
21284: LD_VAR 0 5
21288: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21289: LD_ADDR_VAR 0 3
21293: PUSH
21294: LD_INT 1
21296: PPUSH
21297: LD_VAR 0 14
21301: PPUSH
21302: CALL_OW 12
21306: ST_TO_ADDR
// case i of 1 :
21307: LD_VAR 0 3
21311: PUSH
21312: LD_INT 1
21314: DOUBLE
21315: EQUAL
21316: IFTRUE 21320
21318: GO 21337
21320: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21321: LD_VAR 0 1
21325: PPUSH
21326: LD_VAR 0 10
21330: PPUSH
21331: CALL_OW 115
21335: GO 21398
21337: LD_INT 2
21339: DOUBLE
21340: EQUAL
21341: IFTRUE 21345
21343: GO 21367
21345: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21346: LD_VAR 0 1
21350: PPUSH
21351: LD_VAR 0 6
21355: PPUSH
21356: LD_VAR 0 7
21360: PPUSH
21361: CALL_OW 153
21365: GO 21398
21367: LD_INT 3
21369: DOUBLE
21370: EQUAL
21371: IFTRUE 21375
21373: GO 21397
21375: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21376: LD_VAR 0 1
21380: PPUSH
21381: LD_VAR 0 6
21385: PPUSH
21386: LD_VAR 0 7
21390: PPUSH
21391: CALL_OW 154
21395: GO 21398
21397: POP
// end ;
21398: LD_VAR 0 2
21402: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21403: LD_INT 0
21405: PPUSH
21406: PPUSH
21407: PPUSH
21408: PPUSH
21409: PPUSH
21410: PPUSH
// if not unit or not building then
21411: LD_VAR 0 1
21415: NOT
21416: PUSH
21417: LD_VAR 0 2
21421: NOT
21422: OR
21423: IFFALSE 21427
// exit ;
21425: GO 21585
// x := GetX ( building ) ;
21427: LD_ADDR_VAR 0 5
21431: PUSH
21432: LD_VAR 0 2
21436: PPUSH
21437: CALL_OW 250
21441: ST_TO_ADDR
// y := GetY ( building ) ;
21442: LD_ADDR_VAR 0 6
21446: PUSH
21447: LD_VAR 0 2
21451: PPUSH
21452: CALL_OW 251
21456: ST_TO_ADDR
// for i = 0 to 5 do
21457: LD_ADDR_VAR 0 4
21461: PUSH
21462: DOUBLE
21463: LD_INT 0
21465: DEC
21466: ST_TO_ADDR
21467: LD_INT 5
21469: PUSH
21470: FOR_TO
21471: IFFALSE 21583
// begin _x := ShiftX ( x , i , 3 ) ;
21473: LD_ADDR_VAR 0 7
21477: PUSH
21478: LD_VAR 0 5
21482: PPUSH
21483: LD_VAR 0 4
21487: PPUSH
21488: LD_INT 3
21490: PPUSH
21491: CALL_OW 272
21495: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21496: LD_ADDR_VAR 0 8
21500: PUSH
21501: LD_VAR 0 6
21505: PPUSH
21506: LD_VAR 0 4
21510: PPUSH
21511: LD_INT 3
21513: PPUSH
21514: CALL_OW 273
21518: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21519: LD_VAR 0 7
21523: PPUSH
21524: LD_VAR 0 8
21528: PPUSH
21529: CALL_OW 488
21533: NOT
21534: IFFALSE 21538
// continue ;
21536: GO 21470
// if HexInfo ( _x , _y ) = 0 then
21538: LD_VAR 0 7
21542: PPUSH
21543: LD_VAR 0 8
21547: PPUSH
21548: CALL_OW 428
21552: PUSH
21553: LD_INT 0
21555: EQUAL
21556: IFFALSE 21581
// begin ComMoveXY ( unit , _x , _y ) ;
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 7
21567: PPUSH
21568: LD_VAR 0 8
21572: PPUSH
21573: CALL_OW 111
// exit ;
21577: POP
21578: POP
21579: GO 21585
// end ; end ;
21581: GO 21470
21583: POP
21584: POP
// end ;
21585: LD_VAR 0 3
21589: RET
// export function ScanBase ( side , base_area ) ; begin
21590: LD_INT 0
21592: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21593: LD_ADDR_VAR 0 3
21597: PUSH
21598: LD_VAR 0 2
21602: PPUSH
21603: LD_INT 81
21605: PUSH
21606: LD_VAR 0 1
21610: PUSH
21611: EMPTY
21612: LIST
21613: LIST
21614: PPUSH
21615: CALL_OW 70
21619: ST_TO_ADDR
// end ;
21620: LD_VAR 0 3
21624: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21625: LD_INT 0
21627: PPUSH
21628: PPUSH
21629: PPUSH
21630: PPUSH
// result := false ;
21631: LD_ADDR_VAR 0 2
21635: PUSH
21636: LD_INT 0
21638: ST_TO_ADDR
// side := GetSide ( unit ) ;
21639: LD_ADDR_VAR 0 3
21643: PUSH
21644: LD_VAR 0 1
21648: PPUSH
21649: CALL_OW 255
21653: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21654: LD_ADDR_VAR 0 4
21658: PUSH
21659: LD_VAR 0 1
21663: PPUSH
21664: CALL_OW 248
21668: ST_TO_ADDR
// case nat of 1 :
21669: LD_VAR 0 4
21673: PUSH
21674: LD_INT 1
21676: DOUBLE
21677: EQUAL
21678: IFTRUE 21682
21680: GO 21693
21682: POP
// tech := tech_lassight ; 2 :
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_INT 12
21690: ST_TO_ADDR
21691: GO 21732
21693: LD_INT 2
21695: DOUBLE
21696: EQUAL
21697: IFTRUE 21701
21699: GO 21712
21701: POP
// tech := tech_mortar ; 3 :
21702: LD_ADDR_VAR 0 5
21706: PUSH
21707: LD_INT 41
21709: ST_TO_ADDR
21710: GO 21732
21712: LD_INT 3
21714: DOUBLE
21715: EQUAL
21716: IFTRUE 21720
21718: GO 21731
21720: POP
// tech := tech_bazooka ; end ;
21721: LD_ADDR_VAR 0 5
21725: PUSH
21726: LD_INT 44
21728: ST_TO_ADDR
21729: GO 21732
21731: POP
// if Researched ( side , tech ) then
21732: LD_VAR 0 3
21736: PPUSH
21737: LD_VAR 0 5
21741: PPUSH
21742: CALL_OW 325
21746: IFFALSE 21773
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21748: LD_ADDR_VAR 0 2
21752: PUSH
21753: LD_INT 5
21755: PUSH
21756: LD_INT 8
21758: PUSH
21759: LD_INT 9
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: LIST
21766: PUSH
21767: LD_VAR 0 4
21771: ARRAY
21772: ST_TO_ADDR
// end ;
21773: LD_VAR 0 2
21777: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21778: LD_INT 0
21780: PPUSH
21781: PPUSH
21782: PPUSH
// if not mines then
21783: LD_VAR 0 2
21787: NOT
21788: IFFALSE 21792
// exit ;
21790: GO 21936
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21792: LD_ADDR_VAR 0 5
21796: PUSH
21797: LD_INT 81
21799: PUSH
21800: LD_VAR 0 1
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 3
21811: PUSH
21812: LD_INT 21
21814: PUSH
21815: LD_INT 3
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: PUSH
21822: EMPTY
21823: LIST
21824: LIST
21825: PUSH
21826: EMPTY
21827: LIST
21828: LIST
21829: PPUSH
21830: CALL_OW 69
21834: ST_TO_ADDR
// for i in mines do
21835: LD_ADDR_VAR 0 4
21839: PUSH
21840: LD_VAR 0 2
21844: PUSH
21845: FOR_IN
21846: IFFALSE 21934
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21848: LD_VAR 0 4
21852: PUSH
21853: LD_INT 1
21855: ARRAY
21856: PPUSH
21857: LD_VAR 0 4
21861: PUSH
21862: LD_INT 2
21864: ARRAY
21865: PPUSH
21866: CALL_OW 458
21870: NOT
21871: IFFALSE 21875
// continue ;
21873: GO 21845
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21875: LD_VAR 0 4
21879: PUSH
21880: LD_INT 1
21882: ARRAY
21883: PPUSH
21884: LD_VAR 0 4
21888: PUSH
21889: LD_INT 2
21891: ARRAY
21892: PPUSH
21893: CALL_OW 428
21897: PUSH
21898: LD_VAR 0 5
21902: IN
21903: IFFALSE 21932
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21905: LD_VAR 0 4
21909: PUSH
21910: LD_INT 1
21912: ARRAY
21913: PPUSH
21914: LD_VAR 0 4
21918: PUSH
21919: LD_INT 2
21921: ARRAY
21922: PPUSH
21923: LD_VAR 0 1
21927: PPUSH
21928: CALL_OW 456
// end ;
21932: GO 21845
21934: POP
21935: POP
// end ;
21936: LD_VAR 0 3
21940: RET
// export function Count ( array ) ; begin
21941: LD_INT 0
21943: PPUSH
// result := array + 0 ;
21944: LD_ADDR_VAR 0 2
21948: PUSH
21949: LD_VAR 0 1
21953: PUSH
21954: LD_INT 0
21956: PLUS
21957: ST_TO_ADDR
// end ;
21958: LD_VAR 0 2
21962: RET
// export function IsEmpty ( building ) ; begin
21963: LD_INT 0
21965: PPUSH
// if not building then
21966: LD_VAR 0 1
21970: NOT
21971: IFFALSE 21975
// exit ;
21973: GO 22018
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21975: LD_ADDR_VAR 0 2
21979: PUSH
21980: LD_VAR 0 1
21984: PUSH
21985: LD_INT 22
21987: PUSH
21988: LD_VAR 0 1
21992: PPUSH
21993: CALL_OW 255
21997: PUSH
21998: EMPTY
21999: LIST
22000: LIST
22001: PUSH
22002: LD_INT 58
22004: PUSH
22005: EMPTY
22006: LIST
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PPUSH
22012: CALL_OW 69
22016: IN
22017: ST_TO_ADDR
// end ;
22018: LD_VAR 0 2
22022: RET
// export function IsNotFull ( building ) ; var places ; begin
22023: LD_INT 0
22025: PPUSH
22026: PPUSH
// if not building then
22027: LD_VAR 0 1
22031: NOT
22032: IFFALSE 22036
// exit ;
22034: GO 22064
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
22036: LD_ADDR_VAR 0 2
22040: PUSH
22041: LD_VAR 0 1
22045: PPUSH
22046: LD_INT 3
22048: PUSH
22049: LD_INT 62
22051: PUSH
22052: EMPTY
22053: LIST
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: PPUSH
22059: CALL_OW 72
22063: ST_TO_ADDR
// end ;
22064: LD_VAR 0 2
22068: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22069: LD_INT 0
22071: PPUSH
22072: PPUSH
22073: PPUSH
22074: PPUSH
// tmp := [ ] ;
22075: LD_ADDR_VAR 0 3
22079: PUSH
22080: EMPTY
22081: ST_TO_ADDR
// list := [ ] ;
22082: LD_ADDR_VAR 0 5
22086: PUSH
22087: EMPTY
22088: ST_TO_ADDR
// for i = 16 to 25 do
22089: LD_ADDR_VAR 0 4
22093: PUSH
22094: DOUBLE
22095: LD_INT 16
22097: DEC
22098: ST_TO_ADDR
22099: LD_INT 25
22101: PUSH
22102: FOR_TO
22103: IFFALSE 22176
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22105: LD_ADDR_VAR 0 3
22109: PUSH
22110: LD_VAR 0 3
22114: PUSH
22115: LD_INT 22
22117: PUSH
22118: LD_VAR 0 1
22122: PPUSH
22123: CALL_OW 255
22127: PUSH
22128: EMPTY
22129: LIST
22130: LIST
22131: PUSH
22132: LD_INT 91
22134: PUSH
22135: LD_VAR 0 1
22139: PUSH
22140: LD_INT 6
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: LIST
22147: PUSH
22148: LD_INT 30
22150: PUSH
22151: LD_VAR 0 4
22155: PUSH
22156: EMPTY
22157: LIST
22158: LIST
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: LIST
22164: PUSH
22165: EMPTY
22166: LIST
22167: PPUSH
22168: CALL_OW 69
22172: ADD
22173: ST_TO_ADDR
22174: GO 22102
22176: POP
22177: POP
// for i = 1 to tmp do
22178: LD_ADDR_VAR 0 4
22182: PUSH
22183: DOUBLE
22184: LD_INT 1
22186: DEC
22187: ST_TO_ADDR
22188: LD_VAR 0 3
22192: PUSH
22193: FOR_TO
22194: IFFALSE 22282
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22196: LD_ADDR_VAR 0 5
22200: PUSH
22201: LD_VAR 0 5
22205: PUSH
22206: LD_VAR 0 3
22210: PUSH
22211: LD_VAR 0 4
22215: ARRAY
22216: PPUSH
22217: CALL_OW 266
22221: PUSH
22222: LD_VAR 0 3
22226: PUSH
22227: LD_VAR 0 4
22231: ARRAY
22232: PPUSH
22233: CALL_OW 250
22237: PUSH
22238: LD_VAR 0 3
22242: PUSH
22243: LD_VAR 0 4
22247: ARRAY
22248: PPUSH
22249: CALL_OW 251
22253: PUSH
22254: LD_VAR 0 3
22258: PUSH
22259: LD_VAR 0 4
22263: ARRAY
22264: PPUSH
22265: CALL_OW 254
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: LIST
22274: LIST
22275: PUSH
22276: EMPTY
22277: LIST
22278: ADD
22279: ST_TO_ADDR
22280: GO 22193
22282: POP
22283: POP
// result := list ;
22284: LD_ADDR_VAR 0 2
22288: PUSH
22289: LD_VAR 0 5
22293: ST_TO_ADDR
// end ;
22294: LD_VAR 0 2
22298: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22299: LD_INT 0
22301: PPUSH
22302: PPUSH
22303: PPUSH
22304: PPUSH
22305: PPUSH
22306: PPUSH
22307: PPUSH
// if not factory then
22308: LD_VAR 0 1
22312: NOT
22313: IFFALSE 22317
// exit ;
22315: GO 22910
// if control = control_apeman then
22317: LD_VAR 0 4
22321: PUSH
22322: LD_INT 5
22324: EQUAL
22325: IFFALSE 22434
// begin tmp := UnitsInside ( factory ) ;
22327: LD_ADDR_VAR 0 8
22331: PUSH
22332: LD_VAR 0 1
22336: PPUSH
22337: CALL_OW 313
22341: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22342: LD_VAR 0 8
22346: PPUSH
22347: LD_INT 25
22349: PUSH
22350: LD_INT 12
22352: PUSH
22353: EMPTY
22354: LIST
22355: LIST
22356: PPUSH
22357: CALL_OW 72
22361: NOT
22362: IFFALSE 22372
// control := control_manual ;
22364: LD_ADDR_VAR 0 4
22368: PUSH
22369: LD_INT 1
22371: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22372: LD_ADDR_VAR 0 8
22376: PUSH
22377: LD_VAR 0 1
22381: PPUSH
22382: CALL 22069 0 1
22386: ST_TO_ADDR
// if tmp then
22387: LD_VAR 0 8
22391: IFFALSE 22434
// begin for i in tmp do
22393: LD_ADDR_VAR 0 7
22397: PUSH
22398: LD_VAR 0 8
22402: PUSH
22403: FOR_IN
22404: IFFALSE 22432
// if i [ 1 ] = b_ext_radio then
22406: LD_VAR 0 7
22410: PUSH
22411: LD_INT 1
22413: ARRAY
22414: PUSH
22415: LD_INT 22
22417: EQUAL
22418: IFFALSE 22430
// begin control := control_remote ;
22420: LD_ADDR_VAR 0 4
22424: PUSH
22425: LD_INT 2
22427: ST_TO_ADDR
// break ;
22428: GO 22432
// end ;
22430: GO 22403
22432: POP
22433: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22434: LD_VAR 0 1
22438: PPUSH
22439: LD_VAR 0 2
22443: PPUSH
22444: LD_VAR 0 3
22448: PPUSH
22449: LD_VAR 0 4
22453: PPUSH
22454: LD_VAR 0 5
22458: PPUSH
22459: CALL_OW 448
22463: IFFALSE 22498
// begin result := [ chassis , engine , control , weapon ] ;
22465: LD_ADDR_VAR 0 6
22469: PUSH
22470: LD_VAR 0 2
22474: PUSH
22475: LD_VAR 0 3
22479: PUSH
22480: LD_VAR 0 4
22484: PUSH
22485: LD_VAR 0 5
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: ST_TO_ADDR
// exit ;
22496: GO 22910
// end ; _chassis := AvailableChassisList ( factory ) ;
22498: LD_ADDR_VAR 0 9
22502: PUSH
22503: LD_VAR 0 1
22507: PPUSH
22508: CALL_OW 475
22512: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22513: LD_ADDR_VAR 0 11
22517: PUSH
22518: LD_VAR 0 1
22522: PPUSH
22523: CALL_OW 476
22527: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22528: LD_ADDR_VAR 0 12
22532: PUSH
22533: LD_VAR 0 1
22537: PPUSH
22538: CALL_OW 477
22542: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22543: LD_ADDR_VAR 0 10
22547: PUSH
22548: LD_VAR 0 1
22552: PPUSH
22553: CALL_OW 478
22557: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22558: LD_VAR 0 9
22562: NOT
22563: PUSH
22564: LD_VAR 0 11
22568: NOT
22569: OR
22570: PUSH
22571: LD_VAR 0 12
22575: NOT
22576: OR
22577: PUSH
22578: LD_VAR 0 10
22582: NOT
22583: OR
22584: IFFALSE 22619
// begin result := [ chassis , engine , control , weapon ] ;
22586: LD_ADDR_VAR 0 6
22590: PUSH
22591: LD_VAR 0 2
22595: PUSH
22596: LD_VAR 0 3
22600: PUSH
22601: LD_VAR 0 4
22605: PUSH
22606: LD_VAR 0 5
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: ST_TO_ADDR
// exit ;
22617: GO 22910
// end ; if not chassis in _chassis then
22619: LD_VAR 0 2
22623: PUSH
22624: LD_VAR 0 9
22628: IN
22629: NOT
22630: IFFALSE 22656
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22632: LD_ADDR_VAR 0 2
22636: PUSH
22637: LD_VAR 0 9
22641: PUSH
22642: LD_INT 1
22644: PPUSH
22645: LD_VAR 0 9
22649: PPUSH
22650: CALL_OW 12
22654: ARRAY
22655: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22656: LD_VAR 0 2
22660: PPUSH
22661: LD_VAR 0 3
22665: PPUSH
22666: CALL 22915 0 2
22670: NOT
22671: IFFALSE 22730
// repeat engine := _engine [ 1 ] ;
22673: LD_ADDR_VAR 0 3
22677: PUSH
22678: LD_VAR 0 11
22682: PUSH
22683: LD_INT 1
22685: ARRAY
22686: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22687: LD_ADDR_VAR 0 11
22691: PUSH
22692: LD_VAR 0 11
22696: PPUSH
22697: LD_INT 1
22699: PPUSH
22700: CALL_OW 3
22704: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22705: LD_VAR 0 2
22709: PPUSH
22710: LD_VAR 0 3
22714: PPUSH
22715: CALL 22915 0 2
22719: PUSH
22720: LD_VAR 0 11
22724: PUSH
22725: EMPTY
22726: EQUAL
22727: OR
22728: IFFALSE 22673
// if not control in _control then
22730: LD_VAR 0 4
22734: PUSH
22735: LD_VAR 0 12
22739: IN
22740: NOT
22741: IFFALSE 22767
// control := _control [ rand ( 1 , _control ) ] ;
22743: LD_ADDR_VAR 0 4
22747: PUSH
22748: LD_VAR 0 12
22752: PUSH
22753: LD_INT 1
22755: PPUSH
22756: LD_VAR 0 12
22760: PPUSH
22761: CALL_OW 12
22765: ARRAY
22766: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22767: LD_VAR 0 2
22771: PPUSH
22772: LD_VAR 0 5
22776: PPUSH
22777: CALL 23135 0 2
22781: NOT
22782: IFFALSE 22841
// repeat weapon := _weapon [ 1 ] ;
22784: LD_ADDR_VAR 0 5
22788: PUSH
22789: LD_VAR 0 10
22793: PUSH
22794: LD_INT 1
22796: ARRAY
22797: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22798: LD_ADDR_VAR 0 10
22802: PUSH
22803: LD_VAR 0 10
22807: PPUSH
22808: LD_INT 1
22810: PPUSH
22811: CALL_OW 3
22815: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22816: LD_VAR 0 2
22820: PPUSH
22821: LD_VAR 0 5
22825: PPUSH
22826: CALL 23135 0 2
22830: PUSH
22831: LD_VAR 0 10
22835: PUSH
22836: EMPTY
22837: EQUAL
22838: OR
22839: IFFALSE 22784
// result := [ ] ;
22841: LD_ADDR_VAR 0 6
22845: PUSH
22846: EMPTY
22847: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22848: LD_VAR 0 1
22852: PPUSH
22853: LD_VAR 0 2
22857: PPUSH
22858: LD_VAR 0 3
22862: PPUSH
22863: LD_VAR 0 4
22867: PPUSH
22868: LD_VAR 0 5
22872: PPUSH
22873: CALL_OW 448
22877: IFFALSE 22910
// result := [ chassis , engine , control , weapon ] ;
22879: LD_ADDR_VAR 0 6
22883: PUSH
22884: LD_VAR 0 2
22888: PUSH
22889: LD_VAR 0 3
22893: PUSH
22894: LD_VAR 0 4
22898: PUSH
22899: LD_VAR 0 5
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: ST_TO_ADDR
// end ;
22910: LD_VAR 0 6
22914: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22915: LD_INT 0
22917: PPUSH
// if not chassis or not engine then
22918: LD_VAR 0 1
22922: NOT
22923: PUSH
22924: LD_VAR 0 2
22928: NOT
22929: OR
22930: IFFALSE 22934
// exit ;
22932: GO 23130
// case engine of engine_solar :
22934: LD_VAR 0 2
22938: PUSH
22939: LD_INT 2
22941: DOUBLE
22942: EQUAL
22943: IFTRUE 22947
22945: GO 22985
22947: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22948: LD_ADDR_VAR 0 3
22952: PUSH
22953: LD_INT 11
22955: PUSH
22956: LD_INT 12
22958: PUSH
22959: LD_INT 13
22961: PUSH
22962: LD_INT 14
22964: PUSH
22965: LD_INT 1
22967: PUSH
22968: LD_INT 2
22970: PUSH
22971: LD_INT 3
22973: PUSH
22974: EMPTY
22975: LIST
22976: LIST
22977: LIST
22978: LIST
22979: LIST
22980: LIST
22981: LIST
22982: ST_TO_ADDR
22983: GO 23114
22985: LD_INT 1
22987: DOUBLE
22988: EQUAL
22989: IFTRUE 22993
22991: GO 23055
22993: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22994: LD_ADDR_VAR 0 3
22998: PUSH
22999: LD_INT 11
23001: PUSH
23002: LD_INT 12
23004: PUSH
23005: LD_INT 13
23007: PUSH
23008: LD_INT 14
23010: PUSH
23011: LD_INT 1
23013: PUSH
23014: LD_INT 2
23016: PUSH
23017: LD_INT 3
23019: PUSH
23020: LD_INT 4
23022: PUSH
23023: LD_INT 5
23025: PUSH
23026: LD_INT 21
23028: PUSH
23029: LD_INT 23
23031: PUSH
23032: LD_INT 22
23034: PUSH
23035: LD_INT 24
23037: PUSH
23038: EMPTY
23039: LIST
23040: LIST
23041: LIST
23042: LIST
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: LIST
23048: LIST
23049: LIST
23050: LIST
23051: LIST
23052: ST_TO_ADDR
23053: GO 23114
23055: LD_INT 3
23057: DOUBLE
23058: EQUAL
23059: IFTRUE 23063
23061: GO 23113
23063: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23064: LD_ADDR_VAR 0 3
23068: PUSH
23069: LD_INT 13
23071: PUSH
23072: LD_INT 14
23074: PUSH
23075: LD_INT 2
23077: PUSH
23078: LD_INT 3
23080: PUSH
23081: LD_INT 4
23083: PUSH
23084: LD_INT 5
23086: PUSH
23087: LD_INT 21
23089: PUSH
23090: LD_INT 22
23092: PUSH
23093: LD_INT 23
23095: PUSH
23096: LD_INT 24
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: LIST
23110: ST_TO_ADDR
23111: GO 23114
23113: POP
// result := ( chassis in result ) ;
23114: LD_ADDR_VAR 0 3
23118: PUSH
23119: LD_VAR 0 1
23123: PUSH
23124: LD_VAR 0 3
23128: IN
23129: ST_TO_ADDR
// end ;
23130: LD_VAR 0 3
23134: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23135: LD_INT 0
23137: PPUSH
// if not chassis or not weapon then
23138: LD_VAR 0 1
23142: NOT
23143: PUSH
23144: LD_VAR 0 2
23148: NOT
23149: OR
23150: IFFALSE 23154
// exit ;
23152: GO 24214
// case weapon of us_machine_gun :
23154: LD_VAR 0 2
23158: PUSH
23159: LD_INT 2
23161: DOUBLE
23162: EQUAL
23163: IFTRUE 23167
23165: GO 23197
23167: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23168: LD_ADDR_VAR 0 3
23172: PUSH
23173: LD_INT 1
23175: PUSH
23176: LD_INT 2
23178: PUSH
23179: LD_INT 3
23181: PUSH
23182: LD_INT 4
23184: PUSH
23185: LD_INT 5
23187: PUSH
23188: EMPTY
23189: LIST
23190: LIST
23191: LIST
23192: LIST
23193: LIST
23194: ST_TO_ADDR
23195: GO 24198
23197: LD_INT 3
23199: DOUBLE
23200: EQUAL
23201: IFTRUE 23205
23203: GO 23235
23205: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23206: LD_ADDR_VAR 0 3
23210: PUSH
23211: LD_INT 1
23213: PUSH
23214: LD_INT 2
23216: PUSH
23217: LD_INT 3
23219: PUSH
23220: LD_INT 4
23222: PUSH
23223: LD_INT 5
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: ST_TO_ADDR
23233: GO 24198
23235: LD_INT 11
23237: DOUBLE
23238: EQUAL
23239: IFTRUE 23243
23241: GO 23273
23243: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23244: LD_ADDR_VAR 0 3
23248: PUSH
23249: LD_INT 1
23251: PUSH
23252: LD_INT 2
23254: PUSH
23255: LD_INT 3
23257: PUSH
23258: LD_INT 4
23260: PUSH
23261: LD_INT 5
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: ST_TO_ADDR
23271: GO 24198
23273: LD_INT 4
23275: DOUBLE
23276: EQUAL
23277: IFTRUE 23281
23279: GO 23307
23281: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23282: LD_ADDR_VAR 0 3
23286: PUSH
23287: LD_INT 2
23289: PUSH
23290: LD_INT 3
23292: PUSH
23293: LD_INT 4
23295: PUSH
23296: LD_INT 5
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: LIST
23303: LIST
23304: ST_TO_ADDR
23305: GO 24198
23307: LD_INT 5
23309: DOUBLE
23310: EQUAL
23311: IFTRUE 23315
23313: GO 23341
23315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23316: LD_ADDR_VAR 0 3
23320: PUSH
23321: LD_INT 2
23323: PUSH
23324: LD_INT 3
23326: PUSH
23327: LD_INT 4
23329: PUSH
23330: LD_INT 5
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: LIST
23337: LIST
23338: ST_TO_ADDR
23339: GO 24198
23341: LD_INT 9
23343: DOUBLE
23344: EQUAL
23345: IFTRUE 23349
23347: GO 23375
23349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23350: LD_ADDR_VAR 0 3
23354: PUSH
23355: LD_INT 2
23357: PUSH
23358: LD_INT 3
23360: PUSH
23361: LD_INT 4
23363: PUSH
23364: LD_INT 5
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: LIST
23371: LIST
23372: ST_TO_ADDR
23373: GO 24198
23375: LD_INT 7
23377: DOUBLE
23378: EQUAL
23379: IFTRUE 23383
23381: GO 23409
23383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23384: LD_ADDR_VAR 0 3
23388: PUSH
23389: LD_INT 2
23391: PUSH
23392: LD_INT 3
23394: PUSH
23395: LD_INT 4
23397: PUSH
23398: LD_INT 5
23400: PUSH
23401: EMPTY
23402: LIST
23403: LIST
23404: LIST
23405: LIST
23406: ST_TO_ADDR
23407: GO 24198
23409: LD_INT 12
23411: DOUBLE
23412: EQUAL
23413: IFTRUE 23417
23415: GO 23443
23417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23418: LD_ADDR_VAR 0 3
23422: PUSH
23423: LD_INT 2
23425: PUSH
23426: LD_INT 3
23428: PUSH
23429: LD_INT 4
23431: PUSH
23432: LD_INT 5
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: LIST
23439: LIST
23440: ST_TO_ADDR
23441: GO 24198
23443: LD_INT 13
23445: DOUBLE
23446: EQUAL
23447: IFTRUE 23451
23449: GO 23477
23451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23452: LD_ADDR_VAR 0 3
23456: PUSH
23457: LD_INT 2
23459: PUSH
23460: LD_INT 3
23462: PUSH
23463: LD_INT 4
23465: PUSH
23466: LD_INT 5
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: ST_TO_ADDR
23475: GO 24198
23477: LD_INT 14
23479: DOUBLE
23480: EQUAL
23481: IFTRUE 23485
23483: GO 23503
23485: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23486: LD_ADDR_VAR 0 3
23490: PUSH
23491: LD_INT 4
23493: PUSH
23494: LD_INT 5
23496: PUSH
23497: EMPTY
23498: LIST
23499: LIST
23500: ST_TO_ADDR
23501: GO 24198
23503: LD_INT 6
23505: DOUBLE
23506: EQUAL
23507: IFTRUE 23511
23509: GO 23529
23511: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23512: LD_ADDR_VAR 0 3
23516: PUSH
23517: LD_INT 4
23519: PUSH
23520: LD_INT 5
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: ST_TO_ADDR
23527: GO 24198
23529: LD_INT 10
23531: DOUBLE
23532: EQUAL
23533: IFTRUE 23537
23535: GO 23555
23537: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23538: LD_ADDR_VAR 0 3
23542: PUSH
23543: LD_INT 4
23545: PUSH
23546: LD_INT 5
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: ST_TO_ADDR
23553: GO 24198
23555: LD_INT 22
23557: DOUBLE
23558: EQUAL
23559: IFTRUE 23563
23561: GO 23589
23563: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23564: LD_ADDR_VAR 0 3
23568: PUSH
23569: LD_INT 11
23571: PUSH
23572: LD_INT 12
23574: PUSH
23575: LD_INT 13
23577: PUSH
23578: LD_INT 14
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: LIST
23585: LIST
23586: ST_TO_ADDR
23587: GO 24198
23589: LD_INT 23
23591: DOUBLE
23592: EQUAL
23593: IFTRUE 23597
23595: GO 23623
23597: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23598: LD_ADDR_VAR 0 3
23602: PUSH
23603: LD_INT 11
23605: PUSH
23606: LD_INT 12
23608: PUSH
23609: LD_INT 13
23611: PUSH
23612: LD_INT 14
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: ST_TO_ADDR
23621: GO 24198
23623: LD_INT 24
23625: DOUBLE
23626: EQUAL
23627: IFTRUE 23631
23629: GO 23657
23631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23632: LD_ADDR_VAR 0 3
23636: PUSH
23637: LD_INT 11
23639: PUSH
23640: LD_INT 12
23642: PUSH
23643: LD_INT 13
23645: PUSH
23646: LD_INT 14
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: ST_TO_ADDR
23655: GO 24198
23657: LD_INT 30
23659: DOUBLE
23660: EQUAL
23661: IFTRUE 23665
23663: GO 23691
23665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23666: LD_ADDR_VAR 0 3
23670: PUSH
23671: LD_INT 11
23673: PUSH
23674: LD_INT 12
23676: PUSH
23677: LD_INT 13
23679: PUSH
23680: LD_INT 14
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: ST_TO_ADDR
23689: GO 24198
23691: LD_INT 25
23693: DOUBLE
23694: EQUAL
23695: IFTRUE 23699
23697: GO 23717
23699: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23700: LD_ADDR_VAR 0 3
23704: PUSH
23705: LD_INT 13
23707: PUSH
23708: LD_INT 14
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: ST_TO_ADDR
23715: GO 24198
23717: LD_INT 27
23719: DOUBLE
23720: EQUAL
23721: IFTRUE 23725
23723: GO 23743
23725: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23726: LD_ADDR_VAR 0 3
23730: PUSH
23731: LD_INT 13
23733: PUSH
23734: LD_INT 14
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: ST_TO_ADDR
23741: GO 24198
23743: LD_INT 92
23745: DOUBLE
23746: EQUAL
23747: IFTRUE 23751
23749: GO 23777
23751: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23752: LD_ADDR_VAR 0 3
23756: PUSH
23757: LD_INT 11
23759: PUSH
23760: LD_INT 12
23762: PUSH
23763: LD_INT 13
23765: PUSH
23766: LD_INT 14
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: ST_TO_ADDR
23775: GO 24198
23777: LD_INT 28
23779: DOUBLE
23780: EQUAL
23781: IFTRUE 23785
23783: GO 23803
23785: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23786: LD_ADDR_VAR 0 3
23790: PUSH
23791: LD_INT 13
23793: PUSH
23794: LD_INT 14
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: ST_TO_ADDR
23801: GO 24198
23803: LD_INT 29
23805: DOUBLE
23806: EQUAL
23807: IFTRUE 23811
23809: GO 23829
23811: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23812: LD_ADDR_VAR 0 3
23816: PUSH
23817: LD_INT 13
23819: PUSH
23820: LD_INT 14
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: ST_TO_ADDR
23827: GO 24198
23829: LD_INT 31
23831: DOUBLE
23832: EQUAL
23833: IFTRUE 23837
23835: GO 23855
23837: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23838: LD_ADDR_VAR 0 3
23842: PUSH
23843: LD_INT 13
23845: PUSH
23846: LD_INT 14
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: ST_TO_ADDR
23853: GO 24198
23855: LD_INT 26
23857: DOUBLE
23858: EQUAL
23859: IFTRUE 23863
23861: GO 23881
23863: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23864: LD_ADDR_VAR 0 3
23868: PUSH
23869: LD_INT 13
23871: PUSH
23872: LD_INT 14
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: ST_TO_ADDR
23879: GO 24198
23881: LD_INT 42
23883: DOUBLE
23884: EQUAL
23885: IFTRUE 23889
23887: GO 23915
23889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23890: LD_ADDR_VAR 0 3
23894: PUSH
23895: LD_INT 21
23897: PUSH
23898: LD_INT 22
23900: PUSH
23901: LD_INT 23
23903: PUSH
23904: LD_INT 24
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: ST_TO_ADDR
23913: GO 24198
23915: LD_INT 43
23917: DOUBLE
23918: EQUAL
23919: IFTRUE 23923
23921: GO 23949
23923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23924: LD_ADDR_VAR 0 3
23928: PUSH
23929: LD_INT 21
23931: PUSH
23932: LD_INT 22
23934: PUSH
23935: LD_INT 23
23937: PUSH
23938: LD_INT 24
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: LIST
23945: LIST
23946: ST_TO_ADDR
23947: GO 24198
23949: LD_INT 44
23951: DOUBLE
23952: EQUAL
23953: IFTRUE 23957
23955: GO 23983
23957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23958: LD_ADDR_VAR 0 3
23962: PUSH
23963: LD_INT 21
23965: PUSH
23966: LD_INT 22
23968: PUSH
23969: LD_INT 23
23971: PUSH
23972: LD_INT 24
23974: PUSH
23975: EMPTY
23976: LIST
23977: LIST
23978: LIST
23979: LIST
23980: ST_TO_ADDR
23981: GO 24198
23983: LD_INT 45
23985: DOUBLE
23986: EQUAL
23987: IFTRUE 23991
23989: GO 24017
23991: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23992: LD_ADDR_VAR 0 3
23996: PUSH
23997: LD_INT 21
23999: PUSH
24000: LD_INT 22
24002: PUSH
24003: LD_INT 23
24005: PUSH
24006: LD_INT 24
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: LIST
24013: LIST
24014: ST_TO_ADDR
24015: GO 24198
24017: LD_INT 49
24019: DOUBLE
24020: EQUAL
24021: IFTRUE 24025
24023: GO 24051
24025: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24026: LD_ADDR_VAR 0 3
24030: PUSH
24031: LD_INT 21
24033: PUSH
24034: LD_INT 22
24036: PUSH
24037: LD_INT 23
24039: PUSH
24040: LD_INT 24
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: LIST
24047: LIST
24048: ST_TO_ADDR
24049: GO 24198
24051: LD_INT 51
24053: DOUBLE
24054: EQUAL
24055: IFTRUE 24059
24057: GO 24085
24059: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24060: LD_ADDR_VAR 0 3
24064: PUSH
24065: LD_INT 21
24067: PUSH
24068: LD_INT 22
24070: PUSH
24071: LD_INT 23
24073: PUSH
24074: LD_INT 24
24076: PUSH
24077: EMPTY
24078: LIST
24079: LIST
24080: LIST
24081: LIST
24082: ST_TO_ADDR
24083: GO 24198
24085: LD_INT 52
24087: DOUBLE
24088: EQUAL
24089: IFTRUE 24093
24091: GO 24119
24093: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24094: LD_ADDR_VAR 0 3
24098: PUSH
24099: LD_INT 21
24101: PUSH
24102: LD_INT 22
24104: PUSH
24105: LD_INT 23
24107: PUSH
24108: LD_INT 24
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: LIST
24115: LIST
24116: ST_TO_ADDR
24117: GO 24198
24119: LD_INT 53
24121: DOUBLE
24122: EQUAL
24123: IFTRUE 24127
24125: GO 24145
24127: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24128: LD_ADDR_VAR 0 3
24132: PUSH
24133: LD_INT 23
24135: PUSH
24136: LD_INT 24
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: ST_TO_ADDR
24143: GO 24198
24145: LD_INT 46
24147: DOUBLE
24148: EQUAL
24149: IFTRUE 24153
24151: GO 24171
24153: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24154: LD_ADDR_VAR 0 3
24158: PUSH
24159: LD_INT 23
24161: PUSH
24162: LD_INT 24
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: ST_TO_ADDR
24169: GO 24198
24171: LD_INT 47
24173: DOUBLE
24174: EQUAL
24175: IFTRUE 24179
24177: GO 24197
24179: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24180: LD_ADDR_VAR 0 3
24184: PUSH
24185: LD_INT 23
24187: PUSH
24188: LD_INT 24
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: ST_TO_ADDR
24195: GO 24198
24197: POP
// result := ( chassis in result ) ;
24198: LD_ADDR_VAR 0 3
24202: PUSH
24203: LD_VAR 0 1
24207: PUSH
24208: LD_VAR 0 3
24212: IN
24213: ST_TO_ADDR
// end ;
24214: LD_VAR 0 3
24218: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24219: LD_INT 0
24221: PPUSH
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
24226: PPUSH
24227: PPUSH
// result := array ;
24228: LD_ADDR_VAR 0 5
24232: PUSH
24233: LD_VAR 0 1
24237: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24238: LD_VAR 0 1
24242: NOT
24243: PUSH
24244: LD_VAR 0 2
24248: NOT
24249: OR
24250: PUSH
24251: LD_VAR 0 3
24255: NOT
24256: OR
24257: PUSH
24258: LD_VAR 0 2
24262: PUSH
24263: LD_VAR 0 1
24267: GREATER
24268: OR
24269: PUSH
24270: LD_VAR 0 3
24274: PUSH
24275: LD_VAR 0 1
24279: GREATER
24280: OR
24281: IFFALSE 24285
// exit ;
24283: GO 24581
// if direction then
24285: LD_VAR 0 4
24289: IFFALSE 24353
// begin d := 1 ;
24291: LD_ADDR_VAR 0 9
24295: PUSH
24296: LD_INT 1
24298: ST_TO_ADDR
// if i_from > i_to then
24299: LD_VAR 0 2
24303: PUSH
24304: LD_VAR 0 3
24308: GREATER
24309: IFFALSE 24335
// length := ( array - i_from ) + i_to else
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: LD_VAR 0 1
24320: PUSH
24321: LD_VAR 0 2
24325: MINUS
24326: PUSH
24327: LD_VAR 0 3
24331: PLUS
24332: ST_TO_ADDR
24333: GO 24351
// length := i_to - i_from ;
24335: LD_ADDR_VAR 0 11
24339: PUSH
24340: LD_VAR 0 3
24344: PUSH
24345: LD_VAR 0 2
24349: MINUS
24350: ST_TO_ADDR
// end else
24351: GO 24414
// begin d := - 1 ;
24353: LD_ADDR_VAR 0 9
24357: PUSH
24358: LD_INT 1
24360: NEG
24361: ST_TO_ADDR
// if i_from > i_to then
24362: LD_VAR 0 2
24366: PUSH
24367: LD_VAR 0 3
24371: GREATER
24372: IFFALSE 24392
// length := i_from - i_to else
24374: LD_ADDR_VAR 0 11
24378: PUSH
24379: LD_VAR 0 2
24383: PUSH
24384: LD_VAR 0 3
24388: MINUS
24389: ST_TO_ADDR
24390: GO 24414
// length := ( array - i_to ) + i_from ;
24392: LD_ADDR_VAR 0 11
24396: PUSH
24397: LD_VAR 0 1
24401: PUSH
24402: LD_VAR 0 3
24406: MINUS
24407: PUSH
24408: LD_VAR 0 2
24412: PLUS
24413: ST_TO_ADDR
// end ; if not length then
24414: LD_VAR 0 11
24418: NOT
24419: IFFALSE 24423
// exit ;
24421: GO 24581
// tmp := array ;
24423: LD_ADDR_VAR 0 10
24427: PUSH
24428: LD_VAR 0 1
24432: ST_TO_ADDR
// for i = 1 to length do
24433: LD_ADDR_VAR 0 6
24437: PUSH
24438: DOUBLE
24439: LD_INT 1
24441: DEC
24442: ST_TO_ADDR
24443: LD_VAR 0 11
24447: PUSH
24448: FOR_TO
24449: IFFALSE 24569
// begin for j = 1 to array do
24451: LD_ADDR_VAR 0 7
24455: PUSH
24456: DOUBLE
24457: LD_INT 1
24459: DEC
24460: ST_TO_ADDR
24461: LD_VAR 0 1
24465: PUSH
24466: FOR_TO
24467: IFFALSE 24555
// begin k := j + d ;
24469: LD_ADDR_VAR 0 8
24473: PUSH
24474: LD_VAR 0 7
24478: PUSH
24479: LD_VAR 0 9
24483: PLUS
24484: ST_TO_ADDR
// if k > array then
24485: LD_VAR 0 8
24489: PUSH
24490: LD_VAR 0 1
24494: GREATER
24495: IFFALSE 24505
// k := 1 ;
24497: LD_ADDR_VAR 0 8
24501: PUSH
24502: LD_INT 1
24504: ST_TO_ADDR
// if not k then
24505: LD_VAR 0 8
24509: NOT
24510: IFFALSE 24522
// k := array ;
24512: LD_ADDR_VAR 0 8
24516: PUSH
24517: LD_VAR 0 1
24521: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24522: LD_ADDR_VAR 0 10
24526: PUSH
24527: LD_VAR 0 10
24531: PPUSH
24532: LD_VAR 0 8
24536: PPUSH
24537: LD_VAR 0 1
24541: PUSH
24542: LD_VAR 0 7
24546: ARRAY
24547: PPUSH
24548: CALL_OW 1
24552: ST_TO_ADDR
// end ;
24553: GO 24466
24555: POP
24556: POP
// array := tmp ;
24557: LD_ADDR_VAR 0 1
24561: PUSH
24562: LD_VAR 0 10
24566: ST_TO_ADDR
// end ;
24567: GO 24448
24569: POP
24570: POP
// result := array ;
24571: LD_ADDR_VAR 0 5
24575: PUSH
24576: LD_VAR 0 1
24580: ST_TO_ADDR
// end ;
24581: LD_VAR 0 5
24585: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24586: LD_INT 0
24588: PPUSH
24589: PPUSH
// result := 0 ;
24590: LD_ADDR_VAR 0 3
24594: PUSH
24595: LD_INT 0
24597: ST_TO_ADDR
// if not array or not value in array then
24598: LD_VAR 0 1
24602: NOT
24603: PUSH
24604: LD_VAR 0 2
24608: PUSH
24609: LD_VAR 0 1
24613: IN
24614: NOT
24615: OR
24616: IFFALSE 24620
// exit ;
24618: GO 24674
// for i = 1 to array do
24620: LD_ADDR_VAR 0 4
24624: PUSH
24625: DOUBLE
24626: LD_INT 1
24628: DEC
24629: ST_TO_ADDR
24630: LD_VAR 0 1
24634: PUSH
24635: FOR_TO
24636: IFFALSE 24672
// if value = array [ i ] then
24638: LD_VAR 0 2
24642: PUSH
24643: LD_VAR 0 1
24647: PUSH
24648: LD_VAR 0 4
24652: ARRAY
24653: EQUAL
24654: IFFALSE 24670
// begin result := i ;
24656: LD_ADDR_VAR 0 3
24660: PUSH
24661: LD_VAR 0 4
24665: ST_TO_ADDR
// exit ;
24666: POP
24667: POP
24668: GO 24674
// end ;
24670: GO 24635
24672: POP
24673: POP
// end ;
24674: LD_VAR 0 3
24678: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24679: LD_INT 0
24681: PPUSH
// vc_chassis := chassis ;
24682: LD_ADDR_OWVAR 37
24686: PUSH
24687: LD_VAR 0 1
24691: ST_TO_ADDR
// vc_engine := engine ;
24692: LD_ADDR_OWVAR 39
24696: PUSH
24697: LD_VAR 0 2
24701: ST_TO_ADDR
// vc_control := control ;
24702: LD_ADDR_OWVAR 38
24706: PUSH
24707: LD_VAR 0 3
24711: ST_TO_ADDR
// vc_weapon := weapon ;
24712: LD_ADDR_OWVAR 40
24716: PUSH
24717: LD_VAR 0 4
24721: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24722: LD_ADDR_OWVAR 41
24726: PUSH
24727: LD_VAR 0 5
24731: ST_TO_ADDR
// end ;
24732: LD_VAR 0 6
24736: RET
// export function WantPlant ( unit ) ; var task ; begin
24737: LD_INT 0
24739: PPUSH
24740: PPUSH
// result := false ;
24741: LD_ADDR_VAR 0 2
24745: PUSH
24746: LD_INT 0
24748: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24749: LD_ADDR_VAR 0 3
24753: PUSH
24754: LD_VAR 0 1
24758: PPUSH
24759: CALL_OW 437
24763: ST_TO_ADDR
// if task then
24764: LD_VAR 0 3
24768: IFFALSE 24796
// if task [ 1 ] [ 1 ] = p then
24770: LD_VAR 0 3
24774: PUSH
24775: LD_INT 1
24777: ARRAY
24778: PUSH
24779: LD_INT 1
24781: ARRAY
24782: PUSH
24783: LD_STRING p
24785: EQUAL
24786: IFFALSE 24796
// result := true ;
24788: LD_ADDR_VAR 0 2
24792: PUSH
24793: LD_INT 1
24795: ST_TO_ADDR
// end ;
24796: LD_VAR 0 2
24800: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24801: LD_INT 0
24803: PPUSH
24804: PPUSH
24805: PPUSH
24806: PPUSH
// if pos < 1 then
24807: LD_VAR 0 2
24811: PUSH
24812: LD_INT 1
24814: LESS
24815: IFFALSE 24819
// exit ;
24817: GO 25122
// if pos = 1 then
24819: LD_VAR 0 2
24823: PUSH
24824: LD_INT 1
24826: EQUAL
24827: IFFALSE 24860
// result := Replace ( arr , pos [ 1 ] , value ) else
24829: LD_ADDR_VAR 0 4
24833: PUSH
24834: LD_VAR 0 1
24838: PPUSH
24839: LD_VAR 0 2
24843: PUSH
24844: LD_INT 1
24846: ARRAY
24847: PPUSH
24848: LD_VAR 0 3
24852: PPUSH
24853: CALL_OW 1
24857: ST_TO_ADDR
24858: GO 25122
// begin tmp := arr ;
24860: LD_ADDR_VAR 0 6
24864: PUSH
24865: LD_VAR 0 1
24869: ST_TO_ADDR
// s_arr := [ tmp ] ;
24870: LD_ADDR_VAR 0 7
24874: PUSH
24875: LD_VAR 0 6
24879: PUSH
24880: EMPTY
24881: LIST
24882: ST_TO_ADDR
// for i = 1 to pos - 1 do
24883: LD_ADDR_VAR 0 5
24887: PUSH
24888: DOUBLE
24889: LD_INT 1
24891: DEC
24892: ST_TO_ADDR
24893: LD_VAR 0 2
24897: PUSH
24898: LD_INT 1
24900: MINUS
24901: PUSH
24902: FOR_TO
24903: IFFALSE 24948
// begin tmp := tmp [ pos [ i ] ] ;
24905: LD_ADDR_VAR 0 6
24909: PUSH
24910: LD_VAR 0 6
24914: PUSH
24915: LD_VAR 0 2
24919: PUSH
24920: LD_VAR 0 5
24924: ARRAY
24925: ARRAY
24926: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24927: LD_ADDR_VAR 0 7
24931: PUSH
24932: LD_VAR 0 7
24936: PUSH
24937: LD_VAR 0 6
24941: PUSH
24942: EMPTY
24943: LIST
24944: ADD
24945: ST_TO_ADDR
// end ;
24946: GO 24902
24948: POP
24949: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24950: LD_ADDR_VAR 0 6
24954: PUSH
24955: LD_VAR 0 6
24959: PPUSH
24960: LD_VAR 0 2
24964: PUSH
24965: LD_VAR 0 2
24969: ARRAY
24970: PPUSH
24971: LD_VAR 0 3
24975: PPUSH
24976: CALL_OW 1
24980: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24981: LD_ADDR_VAR 0 7
24985: PUSH
24986: LD_VAR 0 7
24990: PPUSH
24991: LD_VAR 0 7
24995: PPUSH
24996: LD_VAR 0 6
25000: PPUSH
25001: CALL_OW 1
25005: ST_TO_ADDR
// for i = s_arr downto 2 do
25006: LD_ADDR_VAR 0 5
25010: PUSH
25011: DOUBLE
25012: LD_VAR 0 7
25016: INC
25017: ST_TO_ADDR
25018: LD_INT 2
25020: PUSH
25021: FOR_DOWNTO
25022: IFFALSE 25106
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25024: LD_ADDR_VAR 0 6
25028: PUSH
25029: LD_VAR 0 7
25033: PUSH
25034: LD_VAR 0 5
25038: PUSH
25039: LD_INT 1
25041: MINUS
25042: ARRAY
25043: PPUSH
25044: LD_VAR 0 2
25048: PUSH
25049: LD_VAR 0 5
25053: PUSH
25054: LD_INT 1
25056: MINUS
25057: ARRAY
25058: PPUSH
25059: LD_VAR 0 7
25063: PUSH
25064: LD_VAR 0 5
25068: ARRAY
25069: PPUSH
25070: CALL_OW 1
25074: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25075: LD_ADDR_VAR 0 7
25079: PUSH
25080: LD_VAR 0 7
25084: PPUSH
25085: LD_VAR 0 5
25089: PUSH
25090: LD_INT 1
25092: MINUS
25093: PPUSH
25094: LD_VAR 0 6
25098: PPUSH
25099: CALL_OW 1
25103: ST_TO_ADDR
// end ;
25104: GO 25021
25106: POP
25107: POP
// result := s_arr [ 1 ] ;
25108: LD_ADDR_VAR 0 4
25112: PUSH
25113: LD_VAR 0 7
25117: PUSH
25118: LD_INT 1
25120: ARRAY
25121: ST_TO_ADDR
// end ; end ;
25122: LD_VAR 0 4
25126: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25127: LD_INT 0
25129: PPUSH
25130: PPUSH
// if not list then
25131: LD_VAR 0 1
25135: NOT
25136: IFFALSE 25140
// exit ;
25138: GO 25231
// i := list [ pos1 ] ;
25140: LD_ADDR_VAR 0 5
25144: PUSH
25145: LD_VAR 0 1
25149: PUSH
25150: LD_VAR 0 2
25154: ARRAY
25155: ST_TO_ADDR
// if not i then
25156: LD_VAR 0 5
25160: NOT
25161: IFFALSE 25165
// exit ;
25163: GO 25231
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25165: LD_ADDR_VAR 0 1
25169: PUSH
25170: LD_VAR 0 1
25174: PPUSH
25175: LD_VAR 0 2
25179: PPUSH
25180: LD_VAR 0 1
25184: PUSH
25185: LD_VAR 0 3
25189: ARRAY
25190: PPUSH
25191: CALL_OW 1
25195: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25196: LD_ADDR_VAR 0 1
25200: PUSH
25201: LD_VAR 0 1
25205: PPUSH
25206: LD_VAR 0 3
25210: PPUSH
25211: LD_VAR 0 5
25215: PPUSH
25216: CALL_OW 1
25220: ST_TO_ADDR
// result := list ;
25221: LD_ADDR_VAR 0 4
25225: PUSH
25226: LD_VAR 0 1
25230: ST_TO_ADDR
// end ;
25231: LD_VAR 0 4
25235: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25236: LD_INT 0
25238: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25239: LD_ADDR_VAR 0 5
25243: PUSH
25244: LD_VAR 0 1
25248: PPUSH
25249: CALL_OW 250
25253: PPUSH
25254: LD_VAR 0 1
25258: PPUSH
25259: CALL_OW 251
25263: PPUSH
25264: LD_VAR 0 2
25268: PPUSH
25269: LD_VAR 0 3
25273: PPUSH
25274: LD_VAR 0 4
25278: PPUSH
25279: CALL 25657 0 5
25283: ST_TO_ADDR
// end ;
25284: LD_VAR 0 5
25288: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
25289: LD_INT 0
25291: PPUSH
25292: PPUSH
25293: PPUSH
25294: PPUSH
// if not list or not unit then
25295: LD_VAR 0 2
25299: NOT
25300: PUSH
25301: LD_VAR 0 1
25305: NOT
25306: OR
25307: IFFALSE 25311
// exit ;
25309: GO 25652
// result := [ ] ;
25311: LD_ADDR_VAR 0 5
25315: PUSH
25316: EMPTY
25317: ST_TO_ADDR
// for i in list do
25318: LD_ADDR_VAR 0 6
25322: PUSH
25323: LD_VAR 0 2
25327: PUSH
25328: FOR_IN
25329: IFFALSE 25547
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
25331: LD_ADDR_VAR 0 8
25335: PUSH
25336: LD_VAR 0 1
25340: PPUSH
25341: LD_VAR 0 6
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: PPUSH
25350: LD_VAR 0 6
25354: PUSH
25355: LD_INT 2
25357: ARRAY
25358: PPUSH
25359: CALL_OW 297
25363: ST_TO_ADDR
// if not Count ( result ) then
25364: LD_VAR 0 5
25368: PPUSH
25369: CALL 21941 0 1
25373: NOT
25374: IFFALSE 25407
// begin result := Join ( result , [ i , tmp ] ) ;
25376: LD_ADDR_VAR 0 5
25380: PUSH
25381: LD_VAR 0 5
25385: PPUSH
25386: LD_VAR 0 6
25390: PUSH
25391: LD_VAR 0 8
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: PPUSH
25400: CALL 57530 0 2
25404: ST_TO_ADDR
// continue ;
25405: GO 25328
// end ; if result [ result ] [ 2 ] <= tmp then
25407: LD_VAR 0 5
25411: PUSH
25412: LD_VAR 0 5
25416: ARRAY
25417: PUSH
25418: LD_INT 2
25420: ARRAY
25421: PUSH
25422: LD_VAR 0 8
25426: LESSEQUAL
25427: IFFALSE 25460
// result := Join ( result , [ i , tmp ] ) else
25429: LD_ADDR_VAR 0 5
25433: PUSH
25434: LD_VAR 0 5
25438: PPUSH
25439: LD_VAR 0 6
25443: PUSH
25444: LD_VAR 0 8
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PPUSH
25453: CALL 57530 0 2
25457: ST_TO_ADDR
25458: GO 25545
// begin for j := 1 to Count ( result ) do
25460: LD_ADDR_VAR 0 7
25464: PUSH
25465: DOUBLE
25466: LD_INT 1
25468: DEC
25469: ST_TO_ADDR
25470: LD_VAR 0 5
25474: PPUSH
25475: CALL 21941 0 1
25479: PUSH
25480: FOR_TO
25481: IFFALSE 25543
// begin if tmp < result [ j ] [ 2 ] then
25483: LD_VAR 0 8
25487: PUSH
25488: LD_VAR 0 5
25492: PUSH
25493: LD_VAR 0 7
25497: ARRAY
25498: PUSH
25499: LD_INT 2
25501: ARRAY
25502: LESS
25503: IFFALSE 25541
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25505: LD_ADDR_VAR 0 5
25509: PUSH
25510: LD_VAR 0 5
25514: PPUSH
25515: LD_VAR 0 7
25519: PPUSH
25520: LD_VAR 0 6
25524: PUSH
25525: LD_VAR 0 8
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: PPUSH
25534: CALL_OW 2
25538: ST_TO_ADDR
// break ;
25539: GO 25543
// end ; end ;
25541: GO 25480
25543: POP
25544: POP
// end ; end ;
25545: GO 25328
25547: POP
25548: POP
// if result and not asc then
25549: LD_VAR 0 5
25553: PUSH
25554: LD_VAR 0 3
25558: NOT
25559: AND
25560: IFFALSE 25577
// result := ReverseArray ( result ) ;
25562: LD_ADDR_VAR 0 5
25566: PUSH
25567: LD_VAR 0 5
25571: PPUSH
25572: CALL 52817 0 1
25576: ST_TO_ADDR
// tmp := [ ] ;
25577: LD_ADDR_VAR 0 8
25581: PUSH
25582: EMPTY
25583: ST_TO_ADDR
// if mode then
25584: LD_VAR 0 4
25588: IFFALSE 25652
// begin for i := 1 to result do
25590: LD_ADDR_VAR 0 6
25594: PUSH
25595: DOUBLE
25596: LD_INT 1
25598: DEC
25599: ST_TO_ADDR
25600: LD_VAR 0 5
25604: PUSH
25605: FOR_TO
25606: IFFALSE 25640
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
25608: LD_ADDR_VAR 0 8
25612: PUSH
25613: LD_VAR 0 8
25617: PPUSH
25618: LD_VAR 0 5
25622: PUSH
25623: LD_VAR 0 6
25627: ARRAY
25628: PUSH
25629: LD_INT 1
25631: ARRAY
25632: PPUSH
25633: CALL 57530 0 2
25637: ST_TO_ADDR
25638: GO 25605
25640: POP
25641: POP
// result := tmp ;
25642: LD_ADDR_VAR 0 5
25646: PUSH
25647: LD_VAR 0 8
25651: ST_TO_ADDR
// end ; end ;
25652: LD_VAR 0 5
25656: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25657: LD_INT 0
25659: PPUSH
25660: PPUSH
25661: PPUSH
25662: PPUSH
// if not list then
25663: LD_VAR 0 3
25667: NOT
25668: IFFALSE 25672
// exit ;
25670: GO 26060
// result := [ ] ;
25672: LD_ADDR_VAR 0 6
25676: PUSH
25677: EMPTY
25678: ST_TO_ADDR
// for i in list do
25679: LD_ADDR_VAR 0 7
25683: PUSH
25684: LD_VAR 0 3
25688: PUSH
25689: FOR_IN
25690: IFFALSE 25892
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25692: LD_ADDR_VAR 0 9
25696: PUSH
25697: LD_VAR 0 7
25701: PPUSH
25702: LD_VAR 0 1
25706: PPUSH
25707: LD_VAR 0 2
25711: PPUSH
25712: CALL_OW 297
25716: ST_TO_ADDR
// if not result then
25717: LD_VAR 0 6
25721: NOT
25722: IFFALSE 25748
// result := [ [ i , tmp ] ] else
25724: LD_ADDR_VAR 0 6
25728: PUSH
25729: LD_VAR 0 7
25733: PUSH
25734: LD_VAR 0 9
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: PUSH
25743: EMPTY
25744: LIST
25745: ST_TO_ADDR
25746: GO 25890
// begin if result [ result ] [ 2 ] < tmp then
25748: LD_VAR 0 6
25752: PUSH
25753: LD_VAR 0 6
25757: ARRAY
25758: PUSH
25759: LD_INT 2
25761: ARRAY
25762: PUSH
25763: LD_VAR 0 9
25767: LESS
25768: IFFALSE 25810
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25770: LD_ADDR_VAR 0 6
25774: PUSH
25775: LD_VAR 0 6
25779: PPUSH
25780: LD_VAR 0 6
25784: PUSH
25785: LD_INT 1
25787: PLUS
25788: PPUSH
25789: LD_VAR 0 7
25793: PUSH
25794: LD_VAR 0 9
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: PPUSH
25803: CALL_OW 2
25807: ST_TO_ADDR
25808: GO 25890
// for j = 1 to result do
25810: LD_ADDR_VAR 0 8
25814: PUSH
25815: DOUBLE
25816: LD_INT 1
25818: DEC
25819: ST_TO_ADDR
25820: LD_VAR 0 6
25824: PUSH
25825: FOR_TO
25826: IFFALSE 25888
// begin if tmp < result [ j ] [ 2 ] then
25828: LD_VAR 0 9
25832: PUSH
25833: LD_VAR 0 6
25837: PUSH
25838: LD_VAR 0 8
25842: ARRAY
25843: PUSH
25844: LD_INT 2
25846: ARRAY
25847: LESS
25848: IFFALSE 25886
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25850: LD_ADDR_VAR 0 6
25854: PUSH
25855: LD_VAR 0 6
25859: PPUSH
25860: LD_VAR 0 8
25864: PPUSH
25865: LD_VAR 0 7
25869: PUSH
25870: LD_VAR 0 9
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: PPUSH
25879: CALL_OW 2
25883: ST_TO_ADDR
// break ;
25884: GO 25888
// end ; end ;
25886: GO 25825
25888: POP
25889: POP
// end ; end ;
25890: GO 25689
25892: POP
25893: POP
// if result and not asc then
25894: LD_VAR 0 6
25898: PUSH
25899: LD_VAR 0 4
25903: NOT
25904: AND
25905: IFFALSE 25980
// begin tmp := result ;
25907: LD_ADDR_VAR 0 9
25911: PUSH
25912: LD_VAR 0 6
25916: ST_TO_ADDR
// for i = tmp downto 1 do
25917: LD_ADDR_VAR 0 7
25921: PUSH
25922: DOUBLE
25923: LD_VAR 0 9
25927: INC
25928: ST_TO_ADDR
25929: LD_INT 1
25931: PUSH
25932: FOR_DOWNTO
25933: IFFALSE 25978
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25935: LD_ADDR_VAR 0 6
25939: PUSH
25940: LD_VAR 0 6
25944: PPUSH
25945: LD_VAR 0 9
25949: PUSH
25950: LD_VAR 0 7
25954: MINUS
25955: PUSH
25956: LD_INT 1
25958: PLUS
25959: PPUSH
25960: LD_VAR 0 9
25964: PUSH
25965: LD_VAR 0 7
25969: ARRAY
25970: PPUSH
25971: CALL_OW 1
25975: ST_TO_ADDR
25976: GO 25932
25978: POP
25979: POP
// end ; tmp := [ ] ;
25980: LD_ADDR_VAR 0 9
25984: PUSH
25985: EMPTY
25986: ST_TO_ADDR
// if mode then
25987: LD_VAR 0 5
25991: IFFALSE 26060
// begin for i = 1 to result do
25993: LD_ADDR_VAR 0 7
25997: PUSH
25998: DOUBLE
25999: LD_INT 1
26001: DEC
26002: ST_TO_ADDR
26003: LD_VAR 0 6
26007: PUSH
26008: FOR_TO
26009: IFFALSE 26048
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
26011: LD_ADDR_VAR 0 9
26015: PUSH
26016: LD_VAR 0 9
26020: PPUSH
26021: LD_VAR 0 7
26025: PPUSH
26026: LD_VAR 0 6
26030: PUSH
26031: LD_VAR 0 7
26035: ARRAY
26036: PUSH
26037: LD_INT 1
26039: ARRAY
26040: PPUSH
26041: CALL_OW 1
26045: ST_TO_ADDR
26046: GO 26008
26048: POP
26049: POP
// result := tmp ;
26050: LD_ADDR_VAR 0 6
26054: PUSH
26055: LD_VAR 0 9
26059: ST_TO_ADDR
// end ; end ;
26060: LD_VAR 0 6
26064: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
26065: LD_INT 0
26067: PPUSH
26068: PPUSH
26069: PPUSH
26070: PPUSH
26071: PPUSH
26072: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
26073: LD_ADDR_VAR 0 5
26077: PUSH
26078: LD_INT 0
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 0
26086: PUSH
26087: EMPTY
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: LIST
26093: LIST
26094: ST_TO_ADDR
// if not x or not y then
26095: LD_VAR 0 2
26099: NOT
26100: PUSH
26101: LD_VAR 0 3
26105: NOT
26106: OR
26107: IFFALSE 26111
// exit ;
26109: GO 27761
// if not range then
26111: LD_VAR 0 4
26115: NOT
26116: IFFALSE 26126
// range := 10 ;
26118: LD_ADDR_VAR 0 4
26122: PUSH
26123: LD_INT 10
26125: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
26126: LD_ADDR_VAR 0 8
26130: PUSH
26131: LD_INT 81
26133: PUSH
26134: LD_VAR 0 1
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 92
26145: PUSH
26146: LD_VAR 0 2
26150: PUSH
26151: LD_VAR 0 3
26155: PUSH
26156: LD_VAR 0 4
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: LIST
26165: LIST
26166: PUSH
26167: LD_INT 3
26169: PUSH
26170: LD_INT 21
26172: PUSH
26173: LD_INT 3
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: LIST
26188: PPUSH
26189: CALL_OW 69
26193: ST_TO_ADDR
// if not tmp then
26194: LD_VAR 0 8
26198: NOT
26199: IFFALSE 26203
// exit ;
26201: GO 27761
// for i in tmp do
26203: LD_ADDR_VAR 0 6
26207: PUSH
26208: LD_VAR 0 8
26212: PUSH
26213: FOR_IN
26214: IFFALSE 27736
// begin points := [ 0 , 0 , 0 ] ;
26216: LD_ADDR_VAR 0 9
26220: PUSH
26221: LD_INT 0
26223: PUSH
26224: LD_INT 0
26226: PUSH
26227: LD_INT 0
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: LIST
26234: ST_TO_ADDR
// bpoints := 1 ;
26235: LD_ADDR_VAR 0 10
26239: PUSH
26240: LD_INT 1
26242: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26243: LD_VAR 0 6
26247: PPUSH
26248: CALL_OW 247
26252: PUSH
26253: LD_INT 1
26255: DOUBLE
26256: EQUAL
26257: IFTRUE 26261
26259: GO 26839
26261: POP
// begin if GetClass ( i ) = 1 then
26262: LD_VAR 0 6
26266: PPUSH
26267: CALL_OW 257
26271: PUSH
26272: LD_INT 1
26274: EQUAL
26275: IFFALSE 26296
// points := [ 10 , 5 , 3 ] ;
26277: LD_ADDR_VAR 0 9
26281: PUSH
26282: LD_INT 10
26284: PUSH
26285: LD_INT 5
26287: PUSH
26288: LD_INT 3
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: LIST
26295: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26296: LD_VAR 0 6
26300: PPUSH
26301: CALL_OW 257
26305: PUSH
26306: LD_INT 2
26308: PUSH
26309: LD_INT 3
26311: PUSH
26312: LD_INT 4
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: LIST
26319: IN
26320: IFFALSE 26341
// points := [ 3 , 2 , 1 ] ;
26322: LD_ADDR_VAR 0 9
26326: PUSH
26327: LD_INT 3
26329: PUSH
26330: LD_INT 2
26332: PUSH
26333: LD_INT 1
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: LIST
26340: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26341: LD_VAR 0 6
26345: PPUSH
26346: CALL_OW 257
26350: PUSH
26351: LD_INT 5
26353: EQUAL
26354: IFFALSE 26375
// points := [ 130 , 5 , 2 ] ;
26356: LD_ADDR_VAR 0 9
26360: PUSH
26361: LD_INT 130
26363: PUSH
26364: LD_INT 5
26366: PUSH
26367: LD_INT 2
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: LIST
26374: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26375: LD_VAR 0 6
26379: PPUSH
26380: CALL_OW 257
26384: PUSH
26385: LD_INT 8
26387: EQUAL
26388: IFFALSE 26409
// points := [ 35 , 35 , 30 ] ;
26390: LD_ADDR_VAR 0 9
26394: PUSH
26395: LD_INT 35
26397: PUSH
26398: LD_INT 35
26400: PUSH
26401: LD_INT 30
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: LIST
26408: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26409: LD_VAR 0 6
26413: PPUSH
26414: CALL_OW 257
26418: PUSH
26419: LD_INT 9
26421: EQUAL
26422: IFFALSE 26443
// points := [ 20 , 55 , 40 ] ;
26424: LD_ADDR_VAR 0 9
26428: PUSH
26429: LD_INT 20
26431: PUSH
26432: LD_INT 55
26434: PUSH
26435: LD_INT 40
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: LIST
26442: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26443: LD_VAR 0 6
26447: PPUSH
26448: CALL_OW 257
26452: PUSH
26453: LD_INT 12
26455: PUSH
26456: LD_INT 16
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: IN
26463: IFFALSE 26484
// points := [ 5 , 3 , 2 ] ;
26465: LD_ADDR_VAR 0 9
26469: PUSH
26470: LD_INT 5
26472: PUSH
26473: LD_INT 3
26475: PUSH
26476: LD_INT 2
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: LIST
26483: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26484: LD_VAR 0 6
26488: PPUSH
26489: CALL_OW 257
26493: PUSH
26494: LD_INT 17
26496: EQUAL
26497: IFFALSE 26518
// points := [ 100 , 50 , 75 ] ;
26499: LD_ADDR_VAR 0 9
26503: PUSH
26504: LD_INT 100
26506: PUSH
26507: LD_INT 50
26509: PUSH
26510: LD_INT 75
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: LIST
26517: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26518: LD_VAR 0 6
26522: PPUSH
26523: CALL_OW 257
26527: PUSH
26528: LD_INT 15
26530: EQUAL
26531: IFFALSE 26552
// points := [ 10 , 5 , 3 ] ;
26533: LD_ADDR_VAR 0 9
26537: PUSH
26538: LD_INT 10
26540: PUSH
26541: LD_INT 5
26543: PUSH
26544: LD_INT 3
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: LIST
26551: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26552: LD_VAR 0 6
26556: PPUSH
26557: CALL_OW 257
26561: PUSH
26562: LD_INT 14
26564: EQUAL
26565: IFFALSE 26586
// points := [ 10 , 0 , 0 ] ;
26567: LD_ADDR_VAR 0 9
26571: PUSH
26572: LD_INT 10
26574: PUSH
26575: LD_INT 0
26577: PUSH
26578: LD_INT 0
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: LIST
26585: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26586: LD_VAR 0 6
26590: PPUSH
26591: CALL_OW 257
26595: PUSH
26596: LD_INT 11
26598: EQUAL
26599: IFFALSE 26620
// points := [ 30 , 10 , 5 ] ;
26601: LD_ADDR_VAR 0 9
26605: PUSH
26606: LD_INT 30
26608: PUSH
26609: LD_INT 10
26611: PUSH
26612: LD_INT 5
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: LIST
26619: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26620: LD_VAR 0 1
26624: PPUSH
26625: LD_INT 5
26627: PPUSH
26628: CALL_OW 321
26632: PUSH
26633: LD_INT 2
26635: EQUAL
26636: IFFALSE 26653
// bpoints := bpoints * 1.8 ;
26638: LD_ADDR_VAR 0 10
26642: PUSH
26643: LD_VAR 0 10
26647: PUSH
26648: LD_REAL  1.80000000000000E+0000
26651: MUL
26652: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26653: LD_VAR 0 6
26657: PPUSH
26658: CALL_OW 257
26662: PUSH
26663: LD_INT 1
26665: PUSH
26666: LD_INT 2
26668: PUSH
26669: LD_INT 3
26671: PUSH
26672: LD_INT 4
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: IN
26681: PUSH
26682: LD_VAR 0 1
26686: PPUSH
26687: LD_INT 51
26689: PPUSH
26690: CALL_OW 321
26694: PUSH
26695: LD_INT 2
26697: EQUAL
26698: AND
26699: IFFALSE 26716
// bpoints := bpoints * 1.2 ;
26701: LD_ADDR_VAR 0 10
26705: PUSH
26706: LD_VAR 0 10
26710: PUSH
26711: LD_REAL  1.20000000000000E+0000
26714: MUL
26715: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26716: LD_VAR 0 6
26720: PPUSH
26721: CALL_OW 257
26725: PUSH
26726: LD_INT 5
26728: PUSH
26729: LD_INT 7
26731: PUSH
26732: LD_INT 9
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: LIST
26739: IN
26740: PUSH
26741: LD_VAR 0 1
26745: PPUSH
26746: LD_INT 52
26748: PPUSH
26749: CALL_OW 321
26753: PUSH
26754: LD_INT 2
26756: EQUAL
26757: AND
26758: IFFALSE 26775
// bpoints := bpoints * 1.5 ;
26760: LD_ADDR_VAR 0 10
26764: PUSH
26765: LD_VAR 0 10
26769: PUSH
26770: LD_REAL  1.50000000000000E+0000
26773: MUL
26774: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26775: LD_VAR 0 1
26779: PPUSH
26780: LD_INT 66
26782: PPUSH
26783: CALL_OW 321
26787: PUSH
26788: LD_INT 2
26790: EQUAL
26791: IFFALSE 26808
// bpoints := bpoints * 1.1 ;
26793: LD_ADDR_VAR 0 10
26797: PUSH
26798: LD_VAR 0 10
26802: PUSH
26803: LD_REAL  1.10000000000000E+0000
26806: MUL
26807: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26808: LD_ADDR_VAR 0 10
26812: PUSH
26813: LD_VAR 0 10
26817: PUSH
26818: LD_VAR 0 6
26822: PPUSH
26823: LD_INT 1
26825: PPUSH
26826: CALL_OW 259
26830: PUSH
26831: LD_REAL  1.15000000000000E+0000
26834: MUL
26835: MUL
26836: ST_TO_ADDR
// end ; unit_vehicle :
26837: GO 27665
26839: LD_INT 2
26841: DOUBLE
26842: EQUAL
26843: IFTRUE 26847
26845: GO 27653
26847: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26848: LD_VAR 0 6
26852: PPUSH
26853: CALL_OW 264
26857: PUSH
26858: LD_INT 2
26860: PUSH
26861: LD_INT 42
26863: PUSH
26864: LD_INT 24
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: LIST
26871: IN
26872: IFFALSE 26893
// points := [ 25 , 5 , 3 ] ;
26874: LD_ADDR_VAR 0 9
26878: PUSH
26879: LD_INT 25
26881: PUSH
26882: LD_INT 5
26884: PUSH
26885: LD_INT 3
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: LIST
26892: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26893: LD_VAR 0 6
26897: PPUSH
26898: CALL_OW 264
26902: PUSH
26903: LD_INT 4
26905: PUSH
26906: LD_INT 43
26908: PUSH
26909: LD_INT 25
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: IN
26917: IFFALSE 26938
// points := [ 40 , 15 , 5 ] ;
26919: LD_ADDR_VAR 0 9
26923: PUSH
26924: LD_INT 40
26926: PUSH
26927: LD_INT 15
26929: PUSH
26930: LD_INT 5
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: LIST
26937: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26938: LD_VAR 0 6
26942: PPUSH
26943: CALL_OW 264
26947: PUSH
26948: LD_INT 3
26950: PUSH
26951: LD_INT 23
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: IN
26958: IFFALSE 26979
// points := [ 7 , 25 , 8 ] ;
26960: LD_ADDR_VAR 0 9
26964: PUSH
26965: LD_INT 7
26967: PUSH
26968: LD_INT 25
26970: PUSH
26971: LD_INT 8
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: LIST
26978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26979: LD_VAR 0 6
26983: PPUSH
26984: CALL_OW 264
26988: PUSH
26989: LD_INT 5
26991: PUSH
26992: LD_INT 27
26994: PUSH
26995: LD_INT 44
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: IN
27003: IFFALSE 27024
// points := [ 14 , 50 , 16 ] ;
27005: LD_ADDR_VAR 0 9
27009: PUSH
27010: LD_INT 14
27012: PUSH
27013: LD_INT 50
27015: PUSH
27016: LD_INT 16
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: LIST
27023: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
27024: LD_VAR 0 6
27028: PPUSH
27029: CALL_OW 264
27033: PUSH
27034: LD_INT 6
27036: PUSH
27037: LD_INT 46
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: IN
27044: IFFALSE 27065
// points := [ 32 , 120 , 70 ] ;
27046: LD_ADDR_VAR 0 9
27050: PUSH
27051: LD_INT 32
27053: PUSH
27054: LD_INT 120
27056: PUSH
27057: LD_INT 70
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: LIST
27064: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
27065: LD_VAR 0 6
27069: PPUSH
27070: CALL_OW 264
27074: PUSH
27075: LD_INT 7
27077: PUSH
27078: LD_INT 28
27080: PUSH
27081: LD_INT 45
27083: PUSH
27084: LD_INT 92
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: IN
27093: IFFALSE 27114
// points := [ 35 , 20 , 45 ] ;
27095: LD_ADDR_VAR 0 9
27099: PUSH
27100: LD_INT 35
27102: PUSH
27103: LD_INT 20
27105: PUSH
27106: LD_INT 45
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
27114: LD_VAR 0 6
27118: PPUSH
27119: CALL_OW 264
27123: PUSH
27124: LD_INT 47
27126: PUSH
27127: EMPTY
27128: LIST
27129: IN
27130: IFFALSE 27151
// points := [ 67 , 45 , 75 ] ;
27132: LD_ADDR_VAR 0 9
27136: PUSH
27137: LD_INT 67
27139: PUSH
27140: LD_INT 45
27142: PUSH
27143: LD_INT 75
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: LIST
27150: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27151: LD_VAR 0 6
27155: PPUSH
27156: CALL_OW 264
27160: PUSH
27161: LD_INT 26
27163: PUSH
27164: EMPTY
27165: LIST
27166: IN
27167: IFFALSE 27188
// points := [ 120 , 30 , 80 ] ;
27169: LD_ADDR_VAR 0 9
27173: PUSH
27174: LD_INT 120
27176: PUSH
27177: LD_INT 30
27179: PUSH
27180: LD_INT 80
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: LIST
27187: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27188: LD_VAR 0 6
27192: PPUSH
27193: CALL_OW 264
27197: PUSH
27198: LD_INT 22
27200: PUSH
27201: EMPTY
27202: LIST
27203: IN
27204: IFFALSE 27225
// points := [ 40 , 1 , 1 ] ;
27206: LD_ADDR_VAR 0 9
27210: PUSH
27211: LD_INT 40
27213: PUSH
27214: LD_INT 1
27216: PUSH
27217: LD_INT 1
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: LIST
27224: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27225: LD_VAR 0 6
27229: PPUSH
27230: CALL_OW 264
27234: PUSH
27235: LD_INT 29
27237: PUSH
27238: EMPTY
27239: LIST
27240: IN
27241: IFFALSE 27262
// points := [ 70 , 200 , 400 ] ;
27243: LD_ADDR_VAR 0 9
27247: PUSH
27248: LD_INT 70
27250: PUSH
27251: LD_INT 200
27253: PUSH
27254: LD_INT 400
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: LIST
27261: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27262: LD_VAR 0 6
27266: PPUSH
27267: CALL_OW 264
27271: PUSH
27272: LD_INT 14
27274: PUSH
27275: LD_INT 53
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: IN
27282: IFFALSE 27303
// points := [ 40 , 10 , 20 ] ;
27284: LD_ADDR_VAR 0 9
27288: PUSH
27289: LD_INT 40
27291: PUSH
27292: LD_INT 10
27294: PUSH
27295: LD_INT 20
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: LIST
27302: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27303: LD_VAR 0 6
27307: PPUSH
27308: CALL_OW 264
27312: PUSH
27313: LD_INT 9
27315: PUSH
27316: EMPTY
27317: LIST
27318: IN
27319: IFFALSE 27340
// points := [ 5 , 70 , 20 ] ;
27321: LD_ADDR_VAR 0 9
27325: PUSH
27326: LD_INT 5
27328: PUSH
27329: LD_INT 70
27331: PUSH
27332: LD_INT 20
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: LIST
27339: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27340: LD_VAR 0 6
27344: PPUSH
27345: CALL_OW 264
27349: PUSH
27350: LD_INT 10
27352: PUSH
27353: EMPTY
27354: LIST
27355: IN
27356: IFFALSE 27377
// points := [ 35 , 110 , 70 ] ;
27358: LD_ADDR_VAR 0 9
27362: PUSH
27363: LD_INT 35
27365: PUSH
27366: LD_INT 110
27368: PUSH
27369: LD_INT 70
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: LIST
27376: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27377: LD_VAR 0 6
27381: PPUSH
27382: CALL_OW 265
27386: PUSH
27387: LD_INT 25
27389: EQUAL
27390: IFFALSE 27411
// points := [ 80 , 65 , 100 ] ;
27392: LD_ADDR_VAR 0 9
27396: PUSH
27397: LD_INT 80
27399: PUSH
27400: LD_INT 65
27402: PUSH
27403: LD_INT 100
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: LIST
27410: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27411: LD_VAR 0 6
27415: PPUSH
27416: CALL_OW 263
27420: PUSH
27421: LD_INT 1
27423: EQUAL
27424: IFFALSE 27459
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27426: LD_ADDR_VAR 0 10
27430: PUSH
27431: LD_VAR 0 10
27435: PUSH
27436: LD_VAR 0 6
27440: PPUSH
27441: CALL_OW 311
27445: PPUSH
27446: LD_INT 3
27448: PPUSH
27449: CALL_OW 259
27453: PUSH
27454: LD_INT 4
27456: MUL
27457: MUL
27458: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27459: LD_VAR 0 6
27463: PPUSH
27464: CALL_OW 263
27468: PUSH
27469: LD_INT 2
27471: EQUAL
27472: IFFALSE 27523
// begin j := IsControledBy ( i ) ;
27474: LD_ADDR_VAR 0 7
27478: PUSH
27479: LD_VAR 0 6
27483: PPUSH
27484: CALL_OW 312
27488: ST_TO_ADDR
// if j then
27489: LD_VAR 0 7
27493: IFFALSE 27523
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27495: LD_ADDR_VAR 0 10
27499: PUSH
27500: LD_VAR 0 10
27504: PUSH
27505: LD_VAR 0 7
27509: PPUSH
27510: LD_INT 3
27512: PPUSH
27513: CALL_OW 259
27517: PUSH
27518: LD_INT 3
27520: MUL
27521: MUL
27522: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27523: LD_VAR 0 6
27527: PPUSH
27528: CALL_OW 264
27532: PUSH
27533: LD_INT 5
27535: PUSH
27536: LD_INT 6
27538: PUSH
27539: LD_INT 46
27541: PUSH
27542: LD_INT 44
27544: PUSH
27545: LD_INT 47
27547: PUSH
27548: LD_INT 45
27550: PUSH
27551: LD_INT 28
27553: PUSH
27554: LD_INT 7
27556: PUSH
27557: LD_INT 27
27559: PUSH
27560: LD_INT 29
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: IN
27575: PUSH
27576: LD_VAR 0 1
27580: PPUSH
27581: LD_INT 52
27583: PPUSH
27584: CALL_OW 321
27588: PUSH
27589: LD_INT 2
27591: EQUAL
27592: AND
27593: IFFALSE 27610
// bpoints := bpoints * 1.2 ;
27595: LD_ADDR_VAR 0 10
27599: PUSH
27600: LD_VAR 0 10
27604: PUSH
27605: LD_REAL  1.20000000000000E+0000
27608: MUL
27609: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27610: LD_VAR 0 6
27614: PPUSH
27615: CALL_OW 264
27619: PUSH
27620: LD_INT 6
27622: PUSH
27623: LD_INT 46
27625: PUSH
27626: LD_INT 47
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: LIST
27633: IN
27634: IFFALSE 27651
// bpoints := bpoints * 1.2 ;
27636: LD_ADDR_VAR 0 10
27640: PUSH
27641: LD_VAR 0 10
27645: PUSH
27646: LD_REAL  1.20000000000000E+0000
27649: MUL
27650: ST_TO_ADDR
// end ; unit_building :
27651: GO 27665
27653: LD_INT 3
27655: DOUBLE
27656: EQUAL
27657: IFTRUE 27661
27659: GO 27664
27661: POP
// ; end ;
27662: GO 27665
27664: POP
// for j = 1 to 3 do
27665: LD_ADDR_VAR 0 7
27669: PUSH
27670: DOUBLE
27671: LD_INT 1
27673: DEC
27674: ST_TO_ADDR
27675: LD_INT 3
27677: PUSH
27678: FOR_TO
27679: IFFALSE 27732
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27681: LD_ADDR_VAR 0 5
27685: PUSH
27686: LD_VAR 0 5
27690: PPUSH
27691: LD_VAR 0 7
27695: PPUSH
27696: LD_VAR 0 5
27700: PUSH
27701: LD_VAR 0 7
27705: ARRAY
27706: PUSH
27707: LD_VAR 0 9
27711: PUSH
27712: LD_VAR 0 7
27716: ARRAY
27717: PUSH
27718: LD_VAR 0 10
27722: MUL
27723: PLUS
27724: PPUSH
27725: CALL_OW 1
27729: ST_TO_ADDR
27730: GO 27678
27732: POP
27733: POP
// end ;
27734: GO 26213
27736: POP
27737: POP
// result := Replace ( result , 4 , tmp ) ;
27738: LD_ADDR_VAR 0 5
27742: PUSH
27743: LD_VAR 0 5
27747: PPUSH
27748: LD_INT 4
27750: PPUSH
27751: LD_VAR 0 8
27755: PPUSH
27756: CALL_OW 1
27760: ST_TO_ADDR
// end ;
27761: LD_VAR 0 5
27765: RET
// export function DangerAtRange ( unit , range ) ; begin
27766: LD_INT 0
27768: PPUSH
// if not unit then
27769: LD_VAR 0 1
27773: NOT
27774: IFFALSE 27778
// exit ;
27776: GO 27823
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27778: LD_ADDR_VAR 0 3
27782: PUSH
27783: LD_VAR 0 1
27787: PPUSH
27788: CALL_OW 255
27792: PPUSH
27793: LD_VAR 0 1
27797: PPUSH
27798: CALL_OW 250
27802: PPUSH
27803: LD_VAR 0 1
27807: PPUSH
27808: CALL_OW 251
27812: PPUSH
27813: LD_VAR 0 2
27817: PPUSH
27818: CALL 26065 0 4
27822: ST_TO_ADDR
// end ;
27823: LD_VAR 0 3
27827: RET
// export function DangerInArea ( side , area ) ; begin
27828: LD_INT 0
27830: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27831: LD_ADDR_VAR 0 3
27835: PUSH
27836: LD_VAR 0 2
27840: PPUSH
27841: LD_INT 81
27843: PUSH
27844: LD_VAR 0 1
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PPUSH
27853: CALL_OW 70
27857: ST_TO_ADDR
// end ;
27858: LD_VAR 0 3
27862: RET
// export function IsExtension ( b ) ; begin
27863: LD_INT 0
27865: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27866: LD_ADDR_VAR 0 2
27870: PUSH
27871: LD_VAR 0 1
27875: PUSH
27876: LD_INT 23
27878: PUSH
27879: LD_INT 20
27881: PUSH
27882: LD_INT 22
27884: PUSH
27885: LD_INT 17
27887: PUSH
27888: LD_INT 24
27890: PUSH
27891: LD_INT 21
27893: PUSH
27894: LD_INT 19
27896: PUSH
27897: LD_INT 16
27899: PUSH
27900: LD_INT 25
27902: PUSH
27903: LD_INT 18
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: IN
27918: ST_TO_ADDR
// end ;
27919: LD_VAR 0 2
27923: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27924: LD_INT 0
27926: PPUSH
27927: PPUSH
27928: PPUSH
// result := [ ] ;
27929: LD_ADDR_VAR 0 4
27933: PUSH
27934: EMPTY
27935: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27936: LD_ADDR_VAR 0 5
27940: PUSH
27941: LD_VAR 0 2
27945: PPUSH
27946: LD_INT 21
27948: PUSH
27949: LD_INT 3
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PPUSH
27956: CALL_OW 70
27960: ST_TO_ADDR
// if not tmp then
27961: LD_VAR 0 5
27965: NOT
27966: IFFALSE 27970
// exit ;
27968: GO 28034
// if checkLink then
27970: LD_VAR 0 3
27974: IFFALSE 28024
// begin for i in tmp do
27976: LD_ADDR_VAR 0 6
27980: PUSH
27981: LD_VAR 0 5
27985: PUSH
27986: FOR_IN
27987: IFFALSE 28022
// if GetBase ( i ) <> base then
27989: LD_VAR 0 6
27993: PPUSH
27994: CALL_OW 274
27998: PUSH
27999: LD_VAR 0 1
28003: NONEQUAL
28004: IFFALSE 28020
// ComLinkToBase ( base , i ) ;
28006: LD_VAR 0 1
28010: PPUSH
28011: LD_VAR 0 6
28015: PPUSH
28016: CALL_OW 169
28020: GO 27986
28022: POP
28023: POP
// end ; result := tmp ;
28024: LD_ADDR_VAR 0 4
28028: PUSH
28029: LD_VAR 0 5
28033: ST_TO_ADDR
// end ;
28034: LD_VAR 0 4
28038: RET
// export function ComComplete ( units , b ) ; var i ; begin
28039: LD_INT 0
28041: PPUSH
28042: PPUSH
// if not units then
28043: LD_VAR 0 1
28047: NOT
28048: IFFALSE 28052
// exit ;
28050: GO 28142
// for i in units do
28052: LD_ADDR_VAR 0 4
28056: PUSH
28057: LD_VAR 0 1
28061: PUSH
28062: FOR_IN
28063: IFFALSE 28140
// if BuildingStatus ( b ) = bs_build then
28065: LD_VAR 0 2
28069: PPUSH
28070: CALL_OW 461
28074: PUSH
28075: LD_INT 1
28077: EQUAL
28078: IFFALSE 28138
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
28080: LD_VAR 0 4
28084: PPUSH
28085: LD_STRING h
28087: PUSH
28088: LD_VAR 0 2
28092: PPUSH
28093: CALL_OW 250
28097: PUSH
28098: LD_VAR 0 2
28102: PPUSH
28103: CALL_OW 251
28107: PUSH
28108: LD_VAR 0 2
28112: PUSH
28113: LD_INT 0
28115: PUSH
28116: LD_INT 0
28118: PUSH
28119: LD_INT 0
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: LIST
28130: PUSH
28131: EMPTY
28132: LIST
28133: PPUSH
28134: CALL_OW 446
28138: GO 28062
28140: POP
28141: POP
// end ;
28142: LD_VAR 0 3
28146: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
28147: LD_INT 0
28149: PPUSH
28150: PPUSH
28151: PPUSH
28152: PPUSH
28153: PPUSH
28154: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
28155: LD_VAR 0 1
28159: NOT
28160: PUSH
28161: LD_VAR 0 1
28165: PPUSH
28166: CALL_OW 263
28170: PUSH
28171: LD_INT 2
28173: NONEQUAL
28174: OR
28175: IFFALSE 28179
// exit ;
28177: GO 28495
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28179: LD_ADDR_VAR 0 6
28183: PUSH
28184: LD_INT 22
28186: PUSH
28187: LD_VAR 0 1
28191: PPUSH
28192: CALL_OW 255
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PUSH
28201: LD_INT 2
28203: PUSH
28204: LD_INT 30
28206: PUSH
28207: LD_INT 36
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: PUSH
28214: LD_INT 34
28216: PUSH
28217: LD_INT 31
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: LIST
28228: PUSH
28229: EMPTY
28230: LIST
28231: LIST
28232: PPUSH
28233: CALL_OW 69
28237: ST_TO_ADDR
// if not tmp then
28238: LD_VAR 0 6
28242: NOT
28243: IFFALSE 28247
// exit ;
28245: GO 28495
// result := [ ] ;
28247: LD_ADDR_VAR 0 2
28251: PUSH
28252: EMPTY
28253: ST_TO_ADDR
// for i in tmp do
28254: LD_ADDR_VAR 0 3
28258: PUSH
28259: LD_VAR 0 6
28263: PUSH
28264: FOR_IN
28265: IFFALSE 28336
// begin t := UnitsInside ( i ) ;
28267: LD_ADDR_VAR 0 4
28271: PUSH
28272: LD_VAR 0 3
28276: PPUSH
28277: CALL_OW 313
28281: ST_TO_ADDR
// if t then
28282: LD_VAR 0 4
28286: IFFALSE 28334
// for j in t do
28288: LD_ADDR_VAR 0 7
28292: PUSH
28293: LD_VAR 0 4
28297: PUSH
28298: FOR_IN
28299: IFFALSE 28332
// result := Replace ( result , result + 1 , j ) ;
28301: LD_ADDR_VAR 0 2
28305: PUSH
28306: LD_VAR 0 2
28310: PPUSH
28311: LD_VAR 0 2
28315: PUSH
28316: LD_INT 1
28318: PLUS
28319: PPUSH
28320: LD_VAR 0 7
28324: PPUSH
28325: CALL_OW 1
28329: ST_TO_ADDR
28330: GO 28298
28332: POP
28333: POP
// end ;
28334: GO 28264
28336: POP
28337: POP
// if not result then
28338: LD_VAR 0 2
28342: NOT
28343: IFFALSE 28347
// exit ;
28345: GO 28495
// mech := result [ 1 ] ;
28347: LD_ADDR_VAR 0 5
28351: PUSH
28352: LD_VAR 0 2
28356: PUSH
28357: LD_INT 1
28359: ARRAY
28360: ST_TO_ADDR
// if result > 1 then
28361: LD_VAR 0 2
28365: PUSH
28366: LD_INT 1
28368: GREATER
28369: IFFALSE 28481
// begin for i = 2 to result do
28371: LD_ADDR_VAR 0 3
28375: PUSH
28376: DOUBLE
28377: LD_INT 2
28379: DEC
28380: ST_TO_ADDR
28381: LD_VAR 0 2
28385: PUSH
28386: FOR_TO
28387: IFFALSE 28479
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28389: LD_ADDR_VAR 0 4
28393: PUSH
28394: LD_VAR 0 2
28398: PUSH
28399: LD_VAR 0 3
28403: ARRAY
28404: PPUSH
28405: LD_INT 3
28407: PPUSH
28408: CALL_OW 259
28412: PUSH
28413: LD_VAR 0 2
28417: PUSH
28418: LD_VAR 0 3
28422: ARRAY
28423: PPUSH
28424: CALL_OW 432
28428: MINUS
28429: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28430: LD_VAR 0 4
28434: PUSH
28435: LD_VAR 0 5
28439: PPUSH
28440: LD_INT 3
28442: PPUSH
28443: CALL_OW 259
28447: PUSH
28448: LD_VAR 0 5
28452: PPUSH
28453: CALL_OW 432
28457: MINUS
28458: GREATEREQUAL
28459: IFFALSE 28477
// mech := result [ i ] ;
28461: LD_ADDR_VAR 0 5
28465: PUSH
28466: LD_VAR 0 2
28470: PUSH
28471: LD_VAR 0 3
28475: ARRAY
28476: ST_TO_ADDR
// end ;
28477: GO 28386
28479: POP
28480: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28481: LD_VAR 0 1
28485: PPUSH
28486: LD_VAR 0 5
28490: PPUSH
28491: CALL_OW 135
// end ;
28495: LD_VAR 0 2
28499: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28500: LD_INT 0
28502: PPUSH
28503: PPUSH
28504: PPUSH
28505: PPUSH
28506: PPUSH
28507: PPUSH
28508: PPUSH
28509: PPUSH
28510: PPUSH
28511: PPUSH
28512: PPUSH
28513: PPUSH
28514: PPUSH
// result := [ ] ;
28515: LD_ADDR_VAR 0 7
28519: PUSH
28520: EMPTY
28521: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28522: LD_VAR 0 1
28526: PPUSH
28527: CALL_OW 266
28531: PUSH
28532: LD_INT 0
28534: PUSH
28535: LD_INT 1
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: IN
28542: NOT
28543: IFFALSE 28547
// exit ;
28545: GO 30181
// if name then
28547: LD_VAR 0 3
28551: IFFALSE 28567
// SetBName ( base_dep , name ) ;
28553: LD_VAR 0 1
28557: PPUSH
28558: LD_VAR 0 3
28562: PPUSH
28563: CALL_OW 500
// base := GetBase ( base_dep ) ;
28567: LD_ADDR_VAR 0 15
28571: PUSH
28572: LD_VAR 0 1
28576: PPUSH
28577: CALL_OW 274
28581: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28582: LD_ADDR_VAR 0 16
28586: PUSH
28587: LD_VAR 0 1
28591: PPUSH
28592: CALL_OW 255
28596: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28597: LD_ADDR_VAR 0 17
28601: PUSH
28602: LD_VAR 0 1
28606: PPUSH
28607: CALL_OW 248
28611: ST_TO_ADDR
// if sources then
28612: LD_VAR 0 5
28616: IFFALSE 28663
// for i = 1 to 3 do
28618: LD_ADDR_VAR 0 8
28622: PUSH
28623: DOUBLE
28624: LD_INT 1
28626: DEC
28627: ST_TO_ADDR
28628: LD_INT 3
28630: PUSH
28631: FOR_TO
28632: IFFALSE 28661
// AddResourceType ( base , i , sources [ i ] ) ;
28634: LD_VAR 0 15
28638: PPUSH
28639: LD_VAR 0 8
28643: PPUSH
28644: LD_VAR 0 5
28648: PUSH
28649: LD_VAR 0 8
28653: ARRAY
28654: PPUSH
28655: CALL_OW 276
28659: GO 28631
28661: POP
28662: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28663: LD_ADDR_VAR 0 18
28667: PUSH
28668: LD_VAR 0 15
28672: PPUSH
28673: LD_VAR 0 2
28677: PPUSH
28678: LD_INT 1
28680: PPUSH
28681: CALL 27924 0 3
28685: ST_TO_ADDR
// InitHc ;
28686: CALL_OW 19
// InitUc ;
28690: CALL_OW 18
// uc_side := side ;
28694: LD_ADDR_OWVAR 20
28698: PUSH
28699: LD_VAR 0 16
28703: ST_TO_ADDR
// uc_nation := nation ;
28704: LD_ADDR_OWVAR 21
28708: PUSH
28709: LD_VAR 0 17
28713: ST_TO_ADDR
// if buildings then
28714: LD_VAR 0 18
28718: IFFALSE 30040
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28720: LD_ADDR_VAR 0 19
28724: PUSH
28725: LD_VAR 0 18
28729: PPUSH
28730: LD_INT 2
28732: PUSH
28733: LD_INT 30
28735: PUSH
28736: LD_INT 29
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: LD_INT 30
28745: PUSH
28746: LD_INT 30
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: LIST
28757: PPUSH
28758: CALL_OW 72
28762: ST_TO_ADDR
// if tmp then
28763: LD_VAR 0 19
28767: IFFALSE 28815
// for i in tmp do
28769: LD_ADDR_VAR 0 8
28773: PUSH
28774: LD_VAR 0 19
28778: PUSH
28779: FOR_IN
28780: IFFALSE 28813
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28782: LD_VAR 0 8
28786: PPUSH
28787: CALL_OW 250
28791: PPUSH
28792: LD_VAR 0 8
28796: PPUSH
28797: CALL_OW 251
28801: PPUSH
28802: LD_VAR 0 16
28806: PPUSH
28807: CALL_OW 441
28811: GO 28779
28813: POP
28814: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28815: LD_VAR 0 18
28819: PPUSH
28820: LD_INT 2
28822: PUSH
28823: LD_INT 30
28825: PUSH
28826: LD_INT 32
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 30
28835: PUSH
28836: LD_INT 33
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: LIST
28847: PPUSH
28848: CALL_OW 72
28852: IFFALSE 28940
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28854: LD_ADDR_VAR 0 8
28858: PUSH
28859: LD_VAR 0 18
28863: PPUSH
28864: LD_INT 2
28866: PUSH
28867: LD_INT 30
28869: PUSH
28870: LD_INT 32
28872: PUSH
28873: EMPTY
28874: LIST
28875: LIST
28876: PUSH
28877: LD_INT 30
28879: PUSH
28880: LD_INT 33
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: LIST
28891: PPUSH
28892: CALL_OW 72
28896: PUSH
28897: FOR_IN
28898: IFFALSE 28938
// begin if not GetBWeapon ( i ) then
28900: LD_VAR 0 8
28904: PPUSH
28905: CALL_OW 269
28909: NOT
28910: IFFALSE 28936
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28912: LD_VAR 0 8
28916: PPUSH
28917: LD_VAR 0 8
28921: PPUSH
28922: LD_VAR 0 2
28926: PPUSH
28927: CALL 30186 0 2
28931: PPUSH
28932: CALL_OW 431
// end ;
28936: GO 28897
28938: POP
28939: POP
// end ; for i = 1 to personel do
28940: LD_ADDR_VAR 0 8
28944: PUSH
28945: DOUBLE
28946: LD_INT 1
28948: DEC
28949: ST_TO_ADDR
28950: LD_VAR 0 6
28954: PUSH
28955: FOR_TO
28956: IFFALSE 30020
// begin if i > 4 then
28958: LD_VAR 0 8
28962: PUSH
28963: LD_INT 4
28965: GREATER
28966: IFFALSE 28970
// break ;
28968: GO 30020
// case i of 1 :
28970: LD_VAR 0 8
28974: PUSH
28975: LD_INT 1
28977: DOUBLE
28978: EQUAL
28979: IFTRUE 28983
28981: GO 29063
28983: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28984: LD_ADDR_VAR 0 12
28988: PUSH
28989: LD_VAR 0 18
28993: PPUSH
28994: LD_INT 22
28996: PUSH
28997: LD_VAR 0 16
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 58
29008: PUSH
29009: EMPTY
29010: LIST
29011: PUSH
29012: LD_INT 2
29014: PUSH
29015: LD_INT 30
29017: PUSH
29018: LD_INT 32
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: LD_INT 30
29027: PUSH
29028: LD_INT 4
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 30
29037: PUSH
29038: LD_INT 5
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: LIST
29055: PPUSH
29056: CALL_OW 72
29060: ST_TO_ADDR
29061: GO 29285
29063: LD_INT 2
29065: DOUBLE
29066: EQUAL
29067: IFTRUE 29071
29069: GO 29133
29071: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
29072: LD_ADDR_VAR 0 12
29076: PUSH
29077: LD_VAR 0 18
29081: PPUSH
29082: LD_INT 22
29084: PUSH
29085: LD_VAR 0 16
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: LD_INT 2
29096: PUSH
29097: LD_INT 30
29099: PUSH
29100: LD_INT 0
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 30
29109: PUSH
29110: LD_INT 1
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: LIST
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PPUSH
29126: CALL_OW 72
29130: ST_TO_ADDR
29131: GO 29285
29133: LD_INT 3
29135: DOUBLE
29136: EQUAL
29137: IFTRUE 29141
29139: GO 29203
29141: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
29142: LD_ADDR_VAR 0 12
29146: PUSH
29147: LD_VAR 0 18
29151: PPUSH
29152: LD_INT 22
29154: PUSH
29155: LD_VAR 0 16
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: LD_INT 30
29169: PUSH
29170: LD_INT 2
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 30
29179: PUSH
29180: LD_INT 3
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: LIST
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PPUSH
29196: CALL_OW 72
29200: ST_TO_ADDR
29201: GO 29285
29203: LD_INT 4
29205: DOUBLE
29206: EQUAL
29207: IFTRUE 29211
29209: GO 29284
29211: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29212: LD_ADDR_VAR 0 12
29216: PUSH
29217: LD_VAR 0 18
29221: PPUSH
29222: LD_INT 22
29224: PUSH
29225: LD_VAR 0 16
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: PUSH
29237: LD_INT 30
29239: PUSH
29240: LD_INT 6
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 30
29249: PUSH
29250: LD_INT 7
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 30
29259: PUSH
29260: LD_INT 8
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PPUSH
29277: CALL_OW 72
29281: ST_TO_ADDR
29282: GO 29285
29284: POP
// if i = 1 then
29285: LD_VAR 0 8
29289: PUSH
29290: LD_INT 1
29292: EQUAL
29293: IFFALSE 29404
// begin tmp := [ ] ;
29295: LD_ADDR_VAR 0 19
29299: PUSH
29300: EMPTY
29301: ST_TO_ADDR
// for j in f do
29302: LD_ADDR_VAR 0 9
29306: PUSH
29307: LD_VAR 0 12
29311: PUSH
29312: FOR_IN
29313: IFFALSE 29386
// if GetBType ( j ) = b_bunker then
29315: LD_VAR 0 9
29319: PPUSH
29320: CALL_OW 266
29324: PUSH
29325: LD_INT 32
29327: EQUAL
29328: IFFALSE 29355
// tmp := Insert ( tmp , 1 , j ) else
29330: LD_ADDR_VAR 0 19
29334: PUSH
29335: LD_VAR 0 19
29339: PPUSH
29340: LD_INT 1
29342: PPUSH
29343: LD_VAR 0 9
29347: PPUSH
29348: CALL_OW 2
29352: ST_TO_ADDR
29353: GO 29384
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29355: LD_ADDR_VAR 0 19
29359: PUSH
29360: LD_VAR 0 19
29364: PPUSH
29365: LD_VAR 0 19
29369: PUSH
29370: LD_INT 1
29372: PLUS
29373: PPUSH
29374: LD_VAR 0 9
29378: PPUSH
29379: CALL_OW 2
29383: ST_TO_ADDR
29384: GO 29312
29386: POP
29387: POP
// if tmp then
29388: LD_VAR 0 19
29392: IFFALSE 29404
// f := tmp ;
29394: LD_ADDR_VAR 0 12
29398: PUSH
29399: LD_VAR 0 19
29403: ST_TO_ADDR
// end ; x := personel [ i ] ;
29404: LD_ADDR_VAR 0 13
29408: PUSH
29409: LD_VAR 0 6
29413: PUSH
29414: LD_VAR 0 8
29418: ARRAY
29419: ST_TO_ADDR
// if x = - 1 then
29420: LD_VAR 0 13
29424: PUSH
29425: LD_INT 1
29427: NEG
29428: EQUAL
29429: IFFALSE 29638
// begin for j in f do
29431: LD_ADDR_VAR 0 9
29435: PUSH
29436: LD_VAR 0 12
29440: PUSH
29441: FOR_IN
29442: IFFALSE 29634
// repeat InitHc ;
29444: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29448: LD_VAR 0 9
29452: PPUSH
29453: CALL_OW 266
29457: PUSH
29458: LD_INT 5
29460: EQUAL
29461: IFFALSE 29531
// begin if UnitsInside ( j ) < 3 then
29463: LD_VAR 0 9
29467: PPUSH
29468: CALL_OW 313
29472: PUSH
29473: LD_INT 3
29475: LESS
29476: IFFALSE 29512
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29478: LD_INT 0
29480: PPUSH
29481: LD_INT 5
29483: PUSH
29484: LD_INT 8
29486: PUSH
29487: LD_INT 9
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: LIST
29494: PUSH
29495: LD_VAR 0 17
29499: ARRAY
29500: PPUSH
29501: LD_VAR 0 4
29505: PPUSH
29506: CALL_OW 380
29510: GO 29529
// PrepareHuman ( false , i , skill ) ;
29512: LD_INT 0
29514: PPUSH
29515: LD_VAR 0 8
29519: PPUSH
29520: LD_VAR 0 4
29524: PPUSH
29525: CALL_OW 380
// end else
29529: GO 29548
// PrepareHuman ( false , i , skill ) ;
29531: LD_INT 0
29533: PPUSH
29534: LD_VAR 0 8
29538: PPUSH
29539: LD_VAR 0 4
29543: PPUSH
29544: CALL_OW 380
// un := CreateHuman ;
29548: LD_ADDR_VAR 0 14
29552: PUSH
29553: CALL_OW 44
29557: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29558: LD_ADDR_VAR 0 7
29562: PUSH
29563: LD_VAR 0 7
29567: PPUSH
29568: LD_INT 1
29570: PPUSH
29571: LD_VAR 0 14
29575: PPUSH
29576: CALL_OW 2
29580: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29581: LD_VAR 0 14
29585: PPUSH
29586: LD_VAR 0 9
29590: PPUSH
29591: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29595: LD_VAR 0 9
29599: PPUSH
29600: CALL_OW 313
29604: PUSH
29605: LD_INT 6
29607: EQUAL
29608: PUSH
29609: LD_VAR 0 9
29613: PPUSH
29614: CALL_OW 266
29618: PUSH
29619: LD_INT 32
29621: PUSH
29622: LD_INT 31
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: IN
29629: OR
29630: IFFALSE 29444
29632: GO 29441
29634: POP
29635: POP
// end else
29636: GO 30018
// for j = 1 to x do
29638: LD_ADDR_VAR 0 9
29642: PUSH
29643: DOUBLE
29644: LD_INT 1
29646: DEC
29647: ST_TO_ADDR
29648: LD_VAR 0 13
29652: PUSH
29653: FOR_TO
29654: IFFALSE 30016
// begin InitHc ;
29656: CALL_OW 19
// if not f then
29660: LD_VAR 0 12
29664: NOT
29665: IFFALSE 29754
// begin PrepareHuman ( false , i , skill ) ;
29667: LD_INT 0
29669: PPUSH
29670: LD_VAR 0 8
29674: PPUSH
29675: LD_VAR 0 4
29679: PPUSH
29680: CALL_OW 380
// un := CreateHuman ;
29684: LD_ADDR_VAR 0 14
29688: PUSH
29689: CALL_OW 44
29693: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29694: LD_ADDR_VAR 0 7
29698: PUSH
29699: LD_VAR 0 7
29703: PPUSH
29704: LD_INT 1
29706: PPUSH
29707: LD_VAR 0 14
29711: PPUSH
29712: CALL_OW 2
29716: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29717: LD_VAR 0 14
29721: PPUSH
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 250
29731: PPUSH
29732: LD_VAR 0 1
29736: PPUSH
29737: CALL_OW 251
29741: PPUSH
29742: LD_INT 10
29744: PPUSH
29745: LD_INT 0
29747: PPUSH
29748: CALL_OW 50
// continue ;
29752: GO 29653
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29754: LD_VAR 0 12
29758: PUSH
29759: LD_INT 1
29761: ARRAY
29762: PPUSH
29763: CALL_OW 313
29767: PUSH
29768: LD_VAR 0 12
29772: PUSH
29773: LD_INT 1
29775: ARRAY
29776: PPUSH
29777: CALL_OW 266
29781: PUSH
29782: LD_INT 32
29784: PUSH
29785: LD_INT 31
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: IN
29792: AND
29793: PUSH
29794: LD_VAR 0 12
29798: PUSH
29799: LD_INT 1
29801: ARRAY
29802: PPUSH
29803: CALL_OW 313
29807: PUSH
29808: LD_INT 6
29810: EQUAL
29811: OR
29812: IFFALSE 29832
// f := Delete ( f , 1 ) ;
29814: LD_ADDR_VAR 0 12
29818: PUSH
29819: LD_VAR 0 12
29823: PPUSH
29824: LD_INT 1
29826: PPUSH
29827: CALL_OW 3
29831: ST_TO_ADDR
// if not f then
29832: LD_VAR 0 12
29836: NOT
29837: IFFALSE 29855
// begin x := x + 2 ;
29839: LD_ADDR_VAR 0 13
29843: PUSH
29844: LD_VAR 0 13
29848: PUSH
29849: LD_INT 2
29851: PLUS
29852: ST_TO_ADDR
// continue ;
29853: GO 29653
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29855: LD_VAR 0 12
29859: PUSH
29860: LD_INT 1
29862: ARRAY
29863: PPUSH
29864: CALL_OW 266
29868: PUSH
29869: LD_INT 5
29871: EQUAL
29872: IFFALSE 29946
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29874: LD_VAR 0 12
29878: PUSH
29879: LD_INT 1
29881: ARRAY
29882: PPUSH
29883: CALL_OW 313
29887: PUSH
29888: LD_INT 3
29890: LESS
29891: IFFALSE 29927
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29893: LD_INT 0
29895: PPUSH
29896: LD_INT 5
29898: PUSH
29899: LD_INT 8
29901: PUSH
29902: LD_INT 9
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: LIST
29909: PUSH
29910: LD_VAR 0 17
29914: ARRAY
29915: PPUSH
29916: LD_VAR 0 4
29920: PPUSH
29921: CALL_OW 380
29925: GO 29944
// PrepareHuman ( false , i , skill ) ;
29927: LD_INT 0
29929: PPUSH
29930: LD_VAR 0 8
29934: PPUSH
29935: LD_VAR 0 4
29939: PPUSH
29940: CALL_OW 380
// end else
29944: GO 29963
// PrepareHuman ( false , i , skill ) ;
29946: LD_INT 0
29948: PPUSH
29949: LD_VAR 0 8
29953: PPUSH
29954: LD_VAR 0 4
29958: PPUSH
29959: CALL_OW 380
// un := CreateHuman ;
29963: LD_ADDR_VAR 0 14
29967: PUSH
29968: CALL_OW 44
29972: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29973: LD_ADDR_VAR 0 7
29977: PUSH
29978: LD_VAR 0 7
29982: PPUSH
29983: LD_INT 1
29985: PPUSH
29986: LD_VAR 0 14
29990: PPUSH
29991: CALL_OW 2
29995: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29996: LD_VAR 0 14
30000: PPUSH
30001: LD_VAR 0 12
30005: PUSH
30006: LD_INT 1
30008: ARRAY
30009: PPUSH
30010: CALL_OW 52
// end ;
30014: GO 29653
30016: POP
30017: POP
// end ;
30018: GO 28955
30020: POP
30021: POP
// result := result ^ buildings ;
30022: LD_ADDR_VAR 0 7
30026: PUSH
30027: LD_VAR 0 7
30031: PUSH
30032: LD_VAR 0 18
30036: ADD
30037: ST_TO_ADDR
// end else
30038: GO 30181
// begin for i = 1 to personel do
30040: LD_ADDR_VAR 0 8
30044: PUSH
30045: DOUBLE
30046: LD_INT 1
30048: DEC
30049: ST_TO_ADDR
30050: LD_VAR 0 6
30054: PUSH
30055: FOR_TO
30056: IFFALSE 30179
// begin if i > 4 then
30058: LD_VAR 0 8
30062: PUSH
30063: LD_INT 4
30065: GREATER
30066: IFFALSE 30070
// break ;
30068: GO 30179
// x := personel [ i ] ;
30070: LD_ADDR_VAR 0 13
30074: PUSH
30075: LD_VAR 0 6
30079: PUSH
30080: LD_VAR 0 8
30084: ARRAY
30085: ST_TO_ADDR
// if x = - 1 then
30086: LD_VAR 0 13
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: EQUAL
30095: IFFALSE 30099
// continue ;
30097: GO 30055
// PrepareHuman ( false , i , skill ) ;
30099: LD_INT 0
30101: PPUSH
30102: LD_VAR 0 8
30106: PPUSH
30107: LD_VAR 0 4
30111: PPUSH
30112: CALL_OW 380
// un := CreateHuman ;
30116: LD_ADDR_VAR 0 14
30120: PUSH
30121: CALL_OW 44
30125: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
30126: LD_VAR 0 14
30130: PPUSH
30131: LD_VAR 0 1
30135: PPUSH
30136: CALL_OW 250
30140: PPUSH
30141: LD_VAR 0 1
30145: PPUSH
30146: CALL_OW 251
30150: PPUSH
30151: LD_INT 10
30153: PPUSH
30154: LD_INT 0
30156: PPUSH
30157: CALL_OW 50
// result := result ^ un ;
30161: LD_ADDR_VAR 0 7
30165: PUSH
30166: LD_VAR 0 7
30170: PUSH
30171: LD_VAR 0 14
30175: ADD
30176: ST_TO_ADDR
// end ;
30177: GO 30055
30179: POP
30180: POP
// end ; end ;
30181: LD_VAR 0 7
30185: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30186: LD_INT 0
30188: PPUSH
30189: PPUSH
30190: PPUSH
30191: PPUSH
30192: PPUSH
30193: PPUSH
30194: PPUSH
30195: PPUSH
30196: PPUSH
30197: PPUSH
30198: PPUSH
30199: PPUSH
30200: PPUSH
30201: PPUSH
30202: PPUSH
30203: PPUSH
// result := false ;
30204: LD_ADDR_VAR 0 3
30208: PUSH
30209: LD_INT 0
30211: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30212: LD_VAR 0 1
30216: NOT
30217: PUSH
30218: LD_VAR 0 1
30222: PPUSH
30223: CALL_OW 266
30227: PUSH
30228: LD_INT 32
30230: PUSH
30231: LD_INT 33
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: IN
30238: NOT
30239: OR
30240: IFFALSE 30244
// exit ;
30242: GO 31353
// nat := GetNation ( tower ) ;
30244: LD_ADDR_VAR 0 12
30248: PUSH
30249: LD_VAR 0 1
30253: PPUSH
30254: CALL_OW 248
30258: ST_TO_ADDR
// side := GetSide ( tower ) ;
30259: LD_ADDR_VAR 0 16
30263: PUSH
30264: LD_VAR 0 1
30268: PPUSH
30269: CALL_OW 255
30273: ST_TO_ADDR
// x := GetX ( tower ) ;
30274: LD_ADDR_VAR 0 10
30278: PUSH
30279: LD_VAR 0 1
30283: PPUSH
30284: CALL_OW 250
30288: ST_TO_ADDR
// y := GetY ( tower ) ;
30289: LD_ADDR_VAR 0 11
30293: PUSH
30294: LD_VAR 0 1
30298: PPUSH
30299: CALL_OW 251
30303: ST_TO_ADDR
// if not x or not y then
30304: LD_VAR 0 10
30308: NOT
30309: PUSH
30310: LD_VAR 0 11
30314: NOT
30315: OR
30316: IFFALSE 30320
// exit ;
30318: GO 31353
// weapon := 0 ;
30320: LD_ADDR_VAR 0 18
30324: PUSH
30325: LD_INT 0
30327: ST_TO_ADDR
// fac_list := [ ] ;
30328: LD_ADDR_VAR 0 17
30332: PUSH
30333: EMPTY
30334: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30335: LD_ADDR_VAR 0 6
30339: PUSH
30340: LD_VAR 0 1
30344: PPUSH
30345: CALL_OW 274
30349: PPUSH
30350: LD_VAR 0 2
30354: PPUSH
30355: LD_INT 0
30357: PPUSH
30358: CALL 27924 0 3
30362: PPUSH
30363: LD_INT 30
30365: PUSH
30366: LD_INT 3
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PPUSH
30373: CALL_OW 72
30377: ST_TO_ADDR
// if not factories then
30378: LD_VAR 0 6
30382: NOT
30383: IFFALSE 30387
// exit ;
30385: GO 31353
// for i in factories do
30387: LD_ADDR_VAR 0 8
30391: PUSH
30392: LD_VAR 0 6
30396: PUSH
30397: FOR_IN
30398: IFFALSE 30423
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30400: LD_ADDR_VAR 0 17
30404: PUSH
30405: LD_VAR 0 17
30409: PUSH
30410: LD_VAR 0 8
30414: PPUSH
30415: CALL_OW 478
30419: UNION
30420: ST_TO_ADDR
30421: GO 30397
30423: POP
30424: POP
// if not fac_list then
30425: LD_VAR 0 17
30429: NOT
30430: IFFALSE 30434
// exit ;
30432: GO 31353
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30434: LD_ADDR_VAR 0 5
30438: PUSH
30439: LD_INT 4
30441: PUSH
30442: LD_INT 5
30444: PUSH
30445: LD_INT 9
30447: PUSH
30448: LD_INT 10
30450: PUSH
30451: LD_INT 6
30453: PUSH
30454: LD_INT 7
30456: PUSH
30457: LD_INT 11
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 27
30471: PUSH
30472: LD_INT 28
30474: PUSH
30475: LD_INT 26
30477: PUSH
30478: LD_INT 30
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 43
30489: PUSH
30490: LD_INT 44
30492: PUSH
30493: LD_INT 46
30495: PUSH
30496: LD_INT 45
30498: PUSH
30499: LD_INT 47
30501: PUSH
30502: LD_INT 49
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: LIST
30517: PUSH
30518: LD_VAR 0 12
30522: ARRAY
30523: ST_TO_ADDR
// list := list isect fac_list ;
30524: LD_ADDR_VAR 0 5
30528: PUSH
30529: LD_VAR 0 5
30533: PUSH
30534: LD_VAR 0 17
30538: ISECT
30539: ST_TO_ADDR
// if not list then
30540: LD_VAR 0 5
30544: NOT
30545: IFFALSE 30549
// exit ;
30547: GO 31353
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30549: LD_VAR 0 12
30553: PUSH
30554: LD_INT 3
30556: EQUAL
30557: PUSH
30558: LD_INT 49
30560: PUSH
30561: LD_VAR 0 5
30565: IN
30566: AND
30567: PUSH
30568: LD_INT 31
30570: PPUSH
30571: LD_VAR 0 16
30575: PPUSH
30576: CALL_OW 321
30580: PUSH
30581: LD_INT 2
30583: EQUAL
30584: AND
30585: IFFALSE 30645
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30587: LD_INT 22
30589: PUSH
30590: LD_VAR 0 16
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 35
30601: PUSH
30602: LD_INT 49
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 91
30611: PUSH
30612: LD_VAR 0 1
30616: PUSH
30617: LD_INT 10
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: LIST
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: LIST
30629: PPUSH
30630: CALL_OW 69
30634: NOT
30635: IFFALSE 30645
// weapon := ru_time_lapser ;
30637: LD_ADDR_VAR 0 18
30641: PUSH
30642: LD_INT 49
30644: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30645: LD_VAR 0 12
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: LD_INT 2
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: IN
30660: PUSH
30661: LD_INT 11
30663: PUSH
30664: LD_VAR 0 5
30668: IN
30669: PUSH
30670: LD_INT 30
30672: PUSH
30673: LD_VAR 0 5
30677: IN
30678: OR
30679: AND
30680: PUSH
30681: LD_INT 6
30683: PPUSH
30684: LD_VAR 0 16
30688: PPUSH
30689: CALL_OW 321
30693: PUSH
30694: LD_INT 2
30696: EQUAL
30697: AND
30698: IFFALSE 30863
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30700: LD_INT 22
30702: PUSH
30703: LD_VAR 0 16
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: PUSH
30715: LD_INT 35
30717: PUSH
30718: LD_INT 11
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 35
30727: PUSH
30728: LD_INT 30
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 91
30742: PUSH
30743: LD_VAR 0 1
30747: PUSH
30748: LD_INT 18
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: LIST
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: LIST
30760: PPUSH
30761: CALL_OW 69
30765: NOT
30766: PUSH
30767: LD_INT 22
30769: PUSH
30770: LD_VAR 0 16
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 2
30781: PUSH
30782: LD_INT 30
30784: PUSH
30785: LD_INT 32
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 30
30794: PUSH
30795: LD_INT 33
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 91
30809: PUSH
30810: LD_VAR 0 1
30814: PUSH
30815: LD_INT 12
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: LIST
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: LIST
30827: PUSH
30828: EMPTY
30829: LIST
30830: PPUSH
30831: CALL_OW 69
30835: PUSH
30836: LD_INT 2
30838: GREATER
30839: AND
30840: IFFALSE 30863
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30842: LD_ADDR_VAR 0 18
30846: PUSH
30847: LD_INT 11
30849: PUSH
30850: LD_INT 30
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_VAR 0 12
30861: ARRAY
30862: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30863: LD_VAR 0 18
30867: NOT
30868: PUSH
30869: LD_INT 40
30871: PPUSH
30872: LD_VAR 0 16
30876: PPUSH
30877: CALL_OW 321
30881: PUSH
30882: LD_INT 2
30884: EQUAL
30885: AND
30886: PUSH
30887: LD_INT 7
30889: PUSH
30890: LD_VAR 0 5
30894: IN
30895: PUSH
30896: LD_INT 28
30898: PUSH
30899: LD_VAR 0 5
30903: IN
30904: OR
30905: PUSH
30906: LD_INT 45
30908: PUSH
30909: LD_VAR 0 5
30913: IN
30914: OR
30915: AND
30916: IFFALSE 31170
// begin hex := GetHexInfo ( x , y ) ;
30918: LD_ADDR_VAR 0 4
30922: PUSH
30923: LD_VAR 0 10
30927: PPUSH
30928: LD_VAR 0 11
30932: PPUSH
30933: CALL_OW 546
30937: ST_TO_ADDR
// if hex [ 1 ] then
30938: LD_VAR 0 4
30942: PUSH
30943: LD_INT 1
30945: ARRAY
30946: IFFALSE 30950
// exit ;
30948: GO 31353
// height := hex [ 2 ] ;
30950: LD_ADDR_VAR 0 15
30954: PUSH
30955: LD_VAR 0 4
30959: PUSH
30960: LD_INT 2
30962: ARRAY
30963: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30964: LD_ADDR_VAR 0 14
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: LD_INT 2
30974: PUSH
30975: LD_INT 3
30977: PUSH
30978: LD_INT 5
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: ST_TO_ADDR
// for i in tmp do
30987: LD_ADDR_VAR 0 8
30991: PUSH
30992: LD_VAR 0 14
30996: PUSH
30997: FOR_IN
30998: IFFALSE 31168
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
31000: LD_ADDR_VAR 0 9
31004: PUSH
31005: LD_VAR 0 10
31009: PPUSH
31010: LD_VAR 0 8
31014: PPUSH
31015: LD_INT 5
31017: PPUSH
31018: CALL_OW 272
31022: PUSH
31023: LD_VAR 0 11
31027: PPUSH
31028: LD_VAR 0 8
31032: PPUSH
31033: LD_INT 5
31035: PPUSH
31036: CALL_OW 273
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
31045: LD_VAR 0 9
31049: PUSH
31050: LD_INT 1
31052: ARRAY
31053: PPUSH
31054: LD_VAR 0 9
31058: PUSH
31059: LD_INT 2
31061: ARRAY
31062: PPUSH
31063: CALL_OW 488
31067: IFFALSE 31166
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
31069: LD_ADDR_VAR 0 4
31073: PUSH
31074: LD_VAR 0 9
31078: PUSH
31079: LD_INT 1
31081: ARRAY
31082: PPUSH
31083: LD_VAR 0 9
31087: PUSH
31088: LD_INT 2
31090: ARRAY
31091: PPUSH
31092: CALL_OW 546
31096: ST_TO_ADDR
// if hex [ 1 ] then
31097: LD_VAR 0 4
31101: PUSH
31102: LD_INT 1
31104: ARRAY
31105: IFFALSE 31109
// continue ;
31107: GO 30997
// h := hex [ 2 ] ;
31109: LD_ADDR_VAR 0 13
31113: PUSH
31114: LD_VAR 0 4
31118: PUSH
31119: LD_INT 2
31121: ARRAY
31122: ST_TO_ADDR
// if h + 7 < height then
31123: LD_VAR 0 13
31127: PUSH
31128: LD_INT 7
31130: PLUS
31131: PUSH
31132: LD_VAR 0 15
31136: LESS
31137: IFFALSE 31166
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
31139: LD_ADDR_VAR 0 18
31143: PUSH
31144: LD_INT 7
31146: PUSH
31147: LD_INT 28
31149: PUSH
31150: LD_INT 45
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: LIST
31157: PUSH
31158: LD_VAR 0 12
31162: ARRAY
31163: ST_TO_ADDR
// break ;
31164: GO 31168
// end ; end ; end ;
31166: GO 30997
31168: POP
31169: POP
// end ; if not weapon then
31170: LD_VAR 0 18
31174: NOT
31175: IFFALSE 31235
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31177: LD_ADDR_VAR 0 5
31181: PUSH
31182: LD_VAR 0 5
31186: PUSH
31187: LD_INT 11
31189: PUSH
31190: LD_INT 30
31192: PUSH
31193: LD_INT 49
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: LIST
31200: DIFF
31201: ST_TO_ADDR
// if not list then
31202: LD_VAR 0 5
31206: NOT
31207: IFFALSE 31211
// exit ;
31209: GO 31353
// weapon := list [ rand ( 1 , list ) ] ;
31211: LD_ADDR_VAR 0 18
31215: PUSH
31216: LD_VAR 0 5
31220: PUSH
31221: LD_INT 1
31223: PPUSH
31224: LD_VAR 0 5
31228: PPUSH
31229: CALL_OW 12
31233: ARRAY
31234: ST_TO_ADDR
// end ; if weapon then
31235: LD_VAR 0 18
31239: IFFALSE 31353
// begin tmp := CostOfWeapon ( weapon ) ;
31241: LD_ADDR_VAR 0 14
31245: PUSH
31246: LD_VAR 0 18
31250: PPUSH
31251: CALL_OW 451
31255: ST_TO_ADDR
// j := GetBase ( tower ) ;
31256: LD_ADDR_VAR 0 9
31260: PUSH
31261: LD_VAR 0 1
31265: PPUSH
31266: CALL_OW 274
31270: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31271: LD_VAR 0 9
31275: PPUSH
31276: LD_INT 1
31278: PPUSH
31279: CALL_OW 275
31283: PUSH
31284: LD_VAR 0 14
31288: PUSH
31289: LD_INT 1
31291: ARRAY
31292: GREATEREQUAL
31293: PUSH
31294: LD_VAR 0 9
31298: PPUSH
31299: LD_INT 2
31301: PPUSH
31302: CALL_OW 275
31306: PUSH
31307: LD_VAR 0 14
31311: PUSH
31312: LD_INT 2
31314: ARRAY
31315: GREATEREQUAL
31316: AND
31317: PUSH
31318: LD_VAR 0 9
31322: PPUSH
31323: LD_INT 3
31325: PPUSH
31326: CALL_OW 275
31330: PUSH
31331: LD_VAR 0 14
31335: PUSH
31336: LD_INT 3
31338: ARRAY
31339: GREATEREQUAL
31340: AND
31341: IFFALSE 31353
// result := weapon ;
31343: LD_ADDR_VAR 0 3
31347: PUSH
31348: LD_VAR 0 18
31352: ST_TO_ADDR
// end ; end ;
31353: LD_VAR 0 3
31357: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31358: LD_INT 0
31360: PPUSH
31361: PPUSH
// result := true ;
31362: LD_ADDR_VAR 0 3
31366: PUSH
31367: LD_INT 1
31369: ST_TO_ADDR
// if array1 = array2 then
31370: LD_VAR 0 1
31374: PUSH
31375: LD_VAR 0 2
31379: EQUAL
31380: IFFALSE 31440
// begin for i = 1 to array1 do
31382: LD_ADDR_VAR 0 4
31386: PUSH
31387: DOUBLE
31388: LD_INT 1
31390: DEC
31391: ST_TO_ADDR
31392: LD_VAR 0 1
31396: PUSH
31397: FOR_TO
31398: IFFALSE 31436
// if array1 [ i ] <> array2 [ i ] then
31400: LD_VAR 0 1
31404: PUSH
31405: LD_VAR 0 4
31409: ARRAY
31410: PUSH
31411: LD_VAR 0 2
31415: PUSH
31416: LD_VAR 0 4
31420: ARRAY
31421: NONEQUAL
31422: IFFALSE 31434
// begin result := false ;
31424: LD_ADDR_VAR 0 3
31428: PUSH
31429: LD_INT 0
31431: ST_TO_ADDR
// break ;
31432: GO 31436
// end ;
31434: GO 31397
31436: POP
31437: POP
// end else
31438: GO 31448
// result := false ;
31440: LD_ADDR_VAR 0 3
31444: PUSH
31445: LD_INT 0
31447: ST_TO_ADDR
// end ;
31448: LD_VAR 0 3
31452: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31453: LD_INT 0
31455: PPUSH
31456: PPUSH
// if not array1 or not array2 then
31457: LD_VAR 0 1
31461: NOT
31462: PUSH
31463: LD_VAR 0 2
31467: NOT
31468: OR
31469: IFFALSE 31473
// exit ;
31471: GO 31537
// result := true ;
31473: LD_ADDR_VAR 0 3
31477: PUSH
31478: LD_INT 1
31480: ST_TO_ADDR
// for i = 1 to array1 do
31481: LD_ADDR_VAR 0 4
31485: PUSH
31486: DOUBLE
31487: LD_INT 1
31489: DEC
31490: ST_TO_ADDR
31491: LD_VAR 0 1
31495: PUSH
31496: FOR_TO
31497: IFFALSE 31535
// if array1 [ i ] <> array2 [ i ] then
31499: LD_VAR 0 1
31503: PUSH
31504: LD_VAR 0 4
31508: ARRAY
31509: PUSH
31510: LD_VAR 0 2
31514: PUSH
31515: LD_VAR 0 4
31519: ARRAY
31520: NONEQUAL
31521: IFFALSE 31533
// begin result := false ;
31523: LD_ADDR_VAR 0 3
31527: PUSH
31528: LD_INT 0
31530: ST_TO_ADDR
// break ;
31531: GO 31535
// end ;
31533: GO 31496
31535: POP
31536: POP
// end ;
31537: LD_VAR 0 3
31541: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31542: LD_INT 0
31544: PPUSH
31545: PPUSH
31546: PPUSH
// pom := GetBase ( fac ) ;
31547: LD_ADDR_VAR 0 5
31551: PUSH
31552: LD_VAR 0 1
31556: PPUSH
31557: CALL_OW 274
31561: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31562: LD_ADDR_VAR 0 4
31566: PUSH
31567: LD_VAR 0 2
31571: PUSH
31572: LD_INT 1
31574: ARRAY
31575: PPUSH
31576: LD_VAR 0 2
31580: PUSH
31581: LD_INT 2
31583: ARRAY
31584: PPUSH
31585: LD_VAR 0 2
31589: PUSH
31590: LD_INT 3
31592: ARRAY
31593: PPUSH
31594: LD_VAR 0 2
31598: PUSH
31599: LD_INT 4
31601: ARRAY
31602: PPUSH
31603: CALL_OW 449
31607: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31608: LD_ADDR_VAR 0 3
31612: PUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: LD_INT 1
31620: PPUSH
31621: CALL_OW 275
31625: PUSH
31626: LD_VAR 0 4
31630: PUSH
31631: LD_INT 1
31633: ARRAY
31634: GREATEREQUAL
31635: PUSH
31636: LD_VAR 0 5
31640: PPUSH
31641: LD_INT 2
31643: PPUSH
31644: CALL_OW 275
31648: PUSH
31649: LD_VAR 0 4
31653: PUSH
31654: LD_INT 2
31656: ARRAY
31657: GREATEREQUAL
31658: AND
31659: PUSH
31660: LD_VAR 0 5
31664: PPUSH
31665: LD_INT 3
31667: PPUSH
31668: CALL_OW 275
31672: PUSH
31673: LD_VAR 0 4
31677: PUSH
31678: LD_INT 3
31680: ARRAY
31681: GREATEREQUAL
31682: AND
31683: ST_TO_ADDR
// end ;
31684: LD_VAR 0 3
31688: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31689: LD_INT 0
31691: PPUSH
31692: PPUSH
31693: PPUSH
31694: PPUSH
// pom := GetBase ( building ) ;
31695: LD_ADDR_VAR 0 3
31699: PUSH
31700: LD_VAR 0 1
31704: PPUSH
31705: CALL_OW 274
31709: ST_TO_ADDR
// if not pom then
31710: LD_VAR 0 3
31714: NOT
31715: IFFALSE 31719
// exit ;
31717: GO 31889
// btype := GetBType ( building ) ;
31719: LD_ADDR_VAR 0 5
31723: PUSH
31724: LD_VAR 0 1
31728: PPUSH
31729: CALL_OW 266
31733: ST_TO_ADDR
// if btype = b_armoury then
31734: LD_VAR 0 5
31738: PUSH
31739: LD_INT 4
31741: EQUAL
31742: IFFALSE 31752
// btype := b_barracks ;
31744: LD_ADDR_VAR 0 5
31748: PUSH
31749: LD_INT 5
31751: ST_TO_ADDR
// if btype = b_depot then
31752: LD_VAR 0 5
31756: PUSH
31757: LD_INT 0
31759: EQUAL
31760: IFFALSE 31770
// btype := b_warehouse ;
31762: LD_ADDR_VAR 0 5
31766: PUSH
31767: LD_INT 1
31769: ST_TO_ADDR
// if btype = b_workshop then
31770: LD_VAR 0 5
31774: PUSH
31775: LD_INT 2
31777: EQUAL
31778: IFFALSE 31788
// btype := b_factory ;
31780: LD_ADDR_VAR 0 5
31784: PUSH
31785: LD_INT 3
31787: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31788: LD_ADDR_VAR 0 4
31792: PUSH
31793: LD_VAR 0 5
31797: PPUSH
31798: LD_VAR 0 1
31802: PPUSH
31803: CALL_OW 248
31807: PPUSH
31808: CALL_OW 450
31812: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31813: LD_ADDR_VAR 0 2
31817: PUSH
31818: LD_VAR 0 3
31822: PPUSH
31823: LD_INT 1
31825: PPUSH
31826: CALL_OW 275
31830: PUSH
31831: LD_VAR 0 4
31835: PUSH
31836: LD_INT 1
31838: ARRAY
31839: GREATEREQUAL
31840: PUSH
31841: LD_VAR 0 3
31845: PPUSH
31846: LD_INT 2
31848: PPUSH
31849: CALL_OW 275
31853: PUSH
31854: LD_VAR 0 4
31858: PUSH
31859: LD_INT 2
31861: ARRAY
31862: GREATEREQUAL
31863: AND
31864: PUSH
31865: LD_VAR 0 3
31869: PPUSH
31870: LD_INT 3
31872: PPUSH
31873: CALL_OW 275
31877: PUSH
31878: LD_VAR 0 4
31882: PUSH
31883: LD_INT 3
31885: ARRAY
31886: GREATEREQUAL
31887: AND
31888: ST_TO_ADDR
// end ;
31889: LD_VAR 0 2
31893: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31894: LD_INT 0
31896: PPUSH
31897: PPUSH
31898: PPUSH
// pom := GetBase ( building ) ;
31899: LD_ADDR_VAR 0 4
31903: PUSH
31904: LD_VAR 0 1
31908: PPUSH
31909: CALL_OW 274
31913: ST_TO_ADDR
// if not pom then
31914: LD_VAR 0 4
31918: NOT
31919: IFFALSE 31923
// exit ;
31921: GO 32024
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31923: LD_ADDR_VAR 0 5
31927: PUSH
31928: LD_VAR 0 2
31932: PPUSH
31933: LD_VAR 0 1
31937: PPUSH
31938: CALL_OW 248
31942: PPUSH
31943: CALL_OW 450
31947: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31948: LD_ADDR_VAR 0 3
31952: PUSH
31953: LD_VAR 0 4
31957: PPUSH
31958: LD_INT 1
31960: PPUSH
31961: CALL_OW 275
31965: PUSH
31966: LD_VAR 0 5
31970: PUSH
31971: LD_INT 1
31973: ARRAY
31974: GREATEREQUAL
31975: PUSH
31976: LD_VAR 0 4
31980: PPUSH
31981: LD_INT 2
31983: PPUSH
31984: CALL_OW 275
31988: PUSH
31989: LD_VAR 0 5
31993: PUSH
31994: LD_INT 2
31996: ARRAY
31997: GREATEREQUAL
31998: AND
31999: PUSH
32000: LD_VAR 0 4
32004: PPUSH
32005: LD_INT 3
32007: PPUSH
32008: CALL_OW 275
32012: PUSH
32013: LD_VAR 0 5
32017: PUSH
32018: LD_INT 3
32020: ARRAY
32021: GREATEREQUAL
32022: AND
32023: ST_TO_ADDR
// end ;
32024: LD_VAR 0 3
32028: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
32029: LD_INT 0
32031: PPUSH
32032: PPUSH
32033: PPUSH
32034: PPUSH
32035: PPUSH
32036: PPUSH
32037: PPUSH
32038: PPUSH
32039: PPUSH
32040: PPUSH
32041: PPUSH
// result := false ;
32042: LD_ADDR_VAR 0 8
32046: PUSH
32047: LD_INT 0
32049: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
32050: LD_VAR 0 5
32054: NOT
32055: PUSH
32056: LD_VAR 0 1
32060: NOT
32061: OR
32062: PUSH
32063: LD_VAR 0 2
32067: NOT
32068: OR
32069: PUSH
32070: LD_VAR 0 3
32074: NOT
32075: OR
32076: IFFALSE 32080
// exit ;
32078: GO 32894
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
32080: LD_ADDR_VAR 0 14
32084: PUSH
32085: LD_VAR 0 1
32089: PPUSH
32090: LD_VAR 0 2
32094: PPUSH
32095: LD_VAR 0 3
32099: PPUSH
32100: LD_VAR 0 4
32104: PPUSH
32105: LD_VAR 0 5
32109: PUSH
32110: LD_INT 1
32112: ARRAY
32113: PPUSH
32114: CALL_OW 248
32118: PPUSH
32119: LD_INT 0
32121: PPUSH
32122: CALL 34147 0 6
32126: ST_TO_ADDR
// if not hexes then
32127: LD_VAR 0 14
32131: NOT
32132: IFFALSE 32136
// exit ;
32134: GO 32894
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
32136: LD_ADDR_VAR 0 17
32140: PUSH
32141: LD_VAR 0 5
32145: PPUSH
32146: LD_INT 22
32148: PUSH
32149: LD_VAR 0 13
32153: PPUSH
32154: CALL_OW 255
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 2
32165: PUSH
32166: LD_INT 30
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 30
32178: PUSH
32179: LD_INT 1
32181: PUSH
32182: EMPTY
32183: LIST
32184: LIST
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: LIST
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PPUSH
32195: CALL_OW 72
32199: ST_TO_ADDR
// for i = 1 to hexes do
32200: LD_ADDR_VAR 0 9
32204: PUSH
32205: DOUBLE
32206: LD_INT 1
32208: DEC
32209: ST_TO_ADDR
32210: LD_VAR 0 14
32214: PUSH
32215: FOR_TO
32216: IFFALSE 32892
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32218: LD_ADDR_VAR 0 13
32222: PUSH
32223: LD_VAR 0 14
32227: PUSH
32228: LD_VAR 0 9
32232: ARRAY
32233: PUSH
32234: LD_INT 1
32236: ARRAY
32237: PPUSH
32238: LD_VAR 0 14
32242: PUSH
32243: LD_VAR 0 9
32247: ARRAY
32248: PUSH
32249: LD_INT 2
32251: ARRAY
32252: PPUSH
32253: CALL_OW 428
32257: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32258: LD_VAR 0 14
32262: PUSH
32263: LD_VAR 0 9
32267: ARRAY
32268: PUSH
32269: LD_INT 1
32271: ARRAY
32272: PPUSH
32273: LD_VAR 0 14
32277: PUSH
32278: LD_VAR 0 9
32282: ARRAY
32283: PUSH
32284: LD_INT 2
32286: ARRAY
32287: PPUSH
32288: CALL_OW 351
32292: PUSH
32293: LD_VAR 0 14
32297: PUSH
32298: LD_VAR 0 9
32302: ARRAY
32303: PUSH
32304: LD_INT 1
32306: ARRAY
32307: PPUSH
32308: LD_VAR 0 14
32312: PUSH
32313: LD_VAR 0 9
32317: ARRAY
32318: PUSH
32319: LD_INT 2
32321: ARRAY
32322: PPUSH
32323: CALL_OW 488
32327: NOT
32328: OR
32329: PUSH
32330: LD_VAR 0 13
32334: PPUSH
32335: CALL_OW 247
32339: PUSH
32340: LD_INT 3
32342: EQUAL
32343: OR
32344: IFFALSE 32350
// exit ;
32346: POP
32347: POP
32348: GO 32894
// if not tmp then
32350: LD_VAR 0 13
32354: NOT
32355: IFFALSE 32359
// continue ;
32357: GO 32215
// result := true ;
32359: LD_ADDR_VAR 0 8
32363: PUSH
32364: LD_INT 1
32366: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32367: LD_VAR 0 6
32371: PUSH
32372: LD_VAR 0 13
32376: PPUSH
32377: CALL_OW 247
32381: PUSH
32382: LD_INT 2
32384: EQUAL
32385: AND
32386: PUSH
32387: LD_VAR 0 13
32391: PPUSH
32392: CALL_OW 263
32396: PUSH
32397: LD_INT 1
32399: EQUAL
32400: AND
32401: IFFALSE 32565
// begin if IsDrivenBy ( tmp ) then
32403: LD_VAR 0 13
32407: PPUSH
32408: CALL_OW 311
32412: IFFALSE 32416
// continue ;
32414: GO 32215
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32416: LD_VAR 0 6
32420: PPUSH
32421: LD_INT 3
32423: PUSH
32424: LD_INT 60
32426: PUSH
32427: EMPTY
32428: LIST
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 3
32436: PUSH
32437: LD_INT 55
32439: PUSH
32440: EMPTY
32441: LIST
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PPUSH
32451: CALL_OW 72
32455: IFFALSE 32563
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32457: LD_ADDR_VAR 0 18
32461: PUSH
32462: LD_VAR 0 6
32466: PPUSH
32467: LD_INT 3
32469: PUSH
32470: LD_INT 60
32472: PUSH
32473: EMPTY
32474: LIST
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 3
32482: PUSH
32483: LD_INT 55
32485: PUSH
32486: EMPTY
32487: LIST
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PPUSH
32497: CALL_OW 72
32501: PUSH
32502: LD_INT 1
32504: ARRAY
32505: ST_TO_ADDR
// if IsInUnit ( driver ) then
32506: LD_VAR 0 18
32510: PPUSH
32511: CALL_OW 310
32515: IFFALSE 32526
// ComExit ( driver ) ;
32517: LD_VAR 0 18
32521: PPUSH
32522: CALL 57928 0 1
// AddComEnterUnit ( driver , tmp ) ;
32526: LD_VAR 0 18
32530: PPUSH
32531: LD_VAR 0 13
32535: PPUSH
32536: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32540: LD_VAR 0 18
32544: PPUSH
32545: LD_VAR 0 7
32549: PPUSH
32550: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32554: LD_VAR 0 18
32558: PPUSH
32559: CALL_OW 181
// end ; continue ;
32563: GO 32215
// end ; if not cleaners or not tmp in cleaners then
32565: LD_VAR 0 6
32569: NOT
32570: PUSH
32571: LD_VAR 0 13
32575: PUSH
32576: LD_VAR 0 6
32580: IN
32581: NOT
32582: OR
32583: IFFALSE 32890
// begin if dep then
32585: LD_VAR 0 17
32589: IFFALSE 32725
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32591: LD_ADDR_VAR 0 16
32595: PUSH
32596: LD_VAR 0 17
32600: PUSH
32601: LD_INT 1
32603: ARRAY
32604: PPUSH
32605: CALL_OW 250
32609: PPUSH
32610: LD_VAR 0 17
32614: PUSH
32615: LD_INT 1
32617: ARRAY
32618: PPUSH
32619: CALL_OW 254
32623: PPUSH
32624: LD_INT 5
32626: PPUSH
32627: CALL_OW 272
32631: PUSH
32632: LD_VAR 0 17
32636: PUSH
32637: LD_INT 1
32639: ARRAY
32640: PPUSH
32641: CALL_OW 251
32645: PPUSH
32646: LD_VAR 0 17
32650: PUSH
32651: LD_INT 1
32653: ARRAY
32654: PPUSH
32655: CALL_OW 254
32659: PPUSH
32660: LD_INT 5
32662: PPUSH
32663: CALL_OW 273
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32672: LD_VAR 0 16
32676: PUSH
32677: LD_INT 1
32679: ARRAY
32680: PPUSH
32681: LD_VAR 0 16
32685: PUSH
32686: LD_INT 2
32688: ARRAY
32689: PPUSH
32690: CALL_OW 488
32694: IFFALSE 32725
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32696: LD_VAR 0 13
32700: PPUSH
32701: LD_VAR 0 16
32705: PUSH
32706: LD_INT 1
32708: ARRAY
32709: PPUSH
32710: LD_VAR 0 16
32714: PUSH
32715: LD_INT 2
32717: ARRAY
32718: PPUSH
32719: CALL_OW 111
// continue ;
32723: GO 32215
// end ; end ; r := GetDir ( tmp ) ;
32725: LD_ADDR_VAR 0 15
32729: PUSH
32730: LD_VAR 0 13
32734: PPUSH
32735: CALL_OW 254
32739: ST_TO_ADDR
// if r = 5 then
32740: LD_VAR 0 15
32744: PUSH
32745: LD_INT 5
32747: EQUAL
32748: IFFALSE 32758
// r := 0 ;
32750: LD_ADDR_VAR 0 15
32754: PUSH
32755: LD_INT 0
32757: ST_TO_ADDR
// for j = r to 5 do
32758: LD_ADDR_VAR 0 10
32762: PUSH
32763: DOUBLE
32764: LD_VAR 0 15
32768: DEC
32769: ST_TO_ADDR
32770: LD_INT 5
32772: PUSH
32773: FOR_TO
32774: IFFALSE 32888
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32776: LD_ADDR_VAR 0 11
32780: PUSH
32781: LD_VAR 0 13
32785: PPUSH
32786: CALL_OW 250
32790: PPUSH
32791: LD_VAR 0 10
32795: PPUSH
32796: LD_INT 2
32798: PPUSH
32799: CALL_OW 272
32803: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32804: LD_ADDR_VAR 0 12
32808: PUSH
32809: LD_VAR 0 13
32813: PPUSH
32814: CALL_OW 251
32818: PPUSH
32819: LD_VAR 0 10
32823: PPUSH
32824: LD_INT 2
32826: PPUSH
32827: CALL_OW 273
32831: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32832: LD_VAR 0 11
32836: PPUSH
32837: LD_VAR 0 12
32841: PPUSH
32842: CALL_OW 488
32846: PUSH
32847: LD_VAR 0 11
32851: PPUSH
32852: LD_VAR 0 12
32856: PPUSH
32857: CALL_OW 428
32861: NOT
32862: AND
32863: IFFALSE 32886
// begin ComMoveXY ( tmp , _x , _y ) ;
32865: LD_VAR 0 13
32869: PPUSH
32870: LD_VAR 0 11
32874: PPUSH
32875: LD_VAR 0 12
32879: PPUSH
32880: CALL_OW 111
// break ;
32884: GO 32888
// end ; end ;
32886: GO 32773
32888: POP
32889: POP
// end ; end ;
32890: GO 32215
32892: POP
32893: POP
// end ;
32894: LD_VAR 0 8
32898: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32899: LD_INT 0
32901: PPUSH
// result := true ;
32902: LD_ADDR_VAR 0 3
32906: PUSH
32907: LD_INT 1
32909: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32910: LD_VAR 0 2
32914: PUSH
32915: LD_INT 24
32917: DOUBLE
32918: EQUAL
32919: IFTRUE 32929
32921: LD_INT 33
32923: DOUBLE
32924: EQUAL
32925: IFTRUE 32929
32927: GO 32954
32929: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32930: LD_ADDR_VAR 0 3
32934: PUSH
32935: LD_INT 32
32937: PPUSH
32938: LD_VAR 0 1
32942: PPUSH
32943: CALL_OW 321
32947: PUSH
32948: LD_INT 2
32950: EQUAL
32951: ST_TO_ADDR
32952: GO 33270
32954: LD_INT 20
32956: DOUBLE
32957: EQUAL
32958: IFTRUE 32962
32960: GO 32987
32962: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32963: LD_ADDR_VAR 0 3
32967: PUSH
32968: LD_INT 6
32970: PPUSH
32971: LD_VAR 0 1
32975: PPUSH
32976: CALL_OW 321
32980: PUSH
32981: LD_INT 2
32983: EQUAL
32984: ST_TO_ADDR
32985: GO 33270
32987: LD_INT 22
32989: DOUBLE
32990: EQUAL
32991: IFTRUE 33001
32993: LD_INT 36
32995: DOUBLE
32996: EQUAL
32997: IFTRUE 33001
32999: GO 33026
33001: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
33002: LD_ADDR_VAR 0 3
33006: PUSH
33007: LD_INT 15
33009: PPUSH
33010: LD_VAR 0 1
33014: PPUSH
33015: CALL_OW 321
33019: PUSH
33020: LD_INT 2
33022: EQUAL
33023: ST_TO_ADDR
33024: GO 33270
33026: LD_INT 30
33028: DOUBLE
33029: EQUAL
33030: IFTRUE 33034
33032: GO 33059
33034: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
33035: LD_ADDR_VAR 0 3
33039: PUSH
33040: LD_INT 20
33042: PPUSH
33043: LD_VAR 0 1
33047: PPUSH
33048: CALL_OW 321
33052: PUSH
33053: LD_INT 2
33055: EQUAL
33056: ST_TO_ADDR
33057: GO 33270
33059: LD_INT 28
33061: DOUBLE
33062: EQUAL
33063: IFTRUE 33073
33065: LD_INT 21
33067: DOUBLE
33068: EQUAL
33069: IFTRUE 33073
33071: GO 33098
33073: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
33074: LD_ADDR_VAR 0 3
33078: PUSH
33079: LD_INT 21
33081: PPUSH
33082: LD_VAR 0 1
33086: PPUSH
33087: CALL_OW 321
33091: PUSH
33092: LD_INT 2
33094: EQUAL
33095: ST_TO_ADDR
33096: GO 33270
33098: LD_INT 16
33100: DOUBLE
33101: EQUAL
33102: IFTRUE 33106
33104: GO 33131
33106: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
33107: LD_ADDR_VAR 0 3
33111: PUSH
33112: LD_INT 84
33114: PPUSH
33115: LD_VAR 0 1
33119: PPUSH
33120: CALL_OW 321
33124: PUSH
33125: LD_INT 2
33127: EQUAL
33128: ST_TO_ADDR
33129: GO 33270
33131: LD_INT 19
33133: DOUBLE
33134: EQUAL
33135: IFTRUE 33145
33137: LD_INT 23
33139: DOUBLE
33140: EQUAL
33141: IFTRUE 33145
33143: GO 33170
33145: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
33146: LD_ADDR_VAR 0 3
33150: PUSH
33151: LD_INT 83
33153: PPUSH
33154: LD_VAR 0 1
33158: PPUSH
33159: CALL_OW 321
33163: PUSH
33164: LD_INT 2
33166: EQUAL
33167: ST_TO_ADDR
33168: GO 33270
33170: LD_INT 17
33172: DOUBLE
33173: EQUAL
33174: IFTRUE 33178
33176: GO 33203
33178: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33179: LD_ADDR_VAR 0 3
33183: PUSH
33184: LD_INT 39
33186: PPUSH
33187: LD_VAR 0 1
33191: PPUSH
33192: CALL_OW 321
33196: PUSH
33197: LD_INT 2
33199: EQUAL
33200: ST_TO_ADDR
33201: GO 33270
33203: LD_INT 18
33205: DOUBLE
33206: EQUAL
33207: IFTRUE 33211
33209: GO 33236
33211: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33212: LD_ADDR_VAR 0 3
33216: PUSH
33217: LD_INT 40
33219: PPUSH
33220: LD_VAR 0 1
33224: PPUSH
33225: CALL_OW 321
33229: PUSH
33230: LD_INT 2
33232: EQUAL
33233: ST_TO_ADDR
33234: GO 33270
33236: LD_INT 27
33238: DOUBLE
33239: EQUAL
33240: IFTRUE 33244
33242: GO 33269
33244: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33245: LD_ADDR_VAR 0 3
33249: PUSH
33250: LD_INT 35
33252: PPUSH
33253: LD_VAR 0 1
33257: PPUSH
33258: CALL_OW 321
33262: PUSH
33263: LD_INT 2
33265: EQUAL
33266: ST_TO_ADDR
33267: GO 33270
33269: POP
// end ;
33270: LD_VAR 0 3
33274: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33275: LD_INT 0
33277: PPUSH
33278: PPUSH
33279: PPUSH
33280: PPUSH
33281: PPUSH
33282: PPUSH
33283: PPUSH
33284: PPUSH
33285: PPUSH
33286: PPUSH
33287: PPUSH
// result := false ;
33288: LD_ADDR_VAR 0 6
33292: PUSH
33293: LD_INT 0
33295: ST_TO_ADDR
// if btype = b_depot then
33296: LD_VAR 0 2
33300: PUSH
33301: LD_INT 0
33303: EQUAL
33304: IFFALSE 33316
// begin result := true ;
33306: LD_ADDR_VAR 0 6
33310: PUSH
33311: LD_INT 1
33313: ST_TO_ADDR
// exit ;
33314: GO 34142
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33316: LD_VAR 0 1
33320: NOT
33321: PUSH
33322: LD_VAR 0 1
33326: PPUSH
33327: CALL_OW 266
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: IN
33342: NOT
33343: OR
33344: PUSH
33345: LD_VAR 0 2
33349: NOT
33350: OR
33351: PUSH
33352: LD_VAR 0 5
33356: PUSH
33357: LD_INT 0
33359: PUSH
33360: LD_INT 1
33362: PUSH
33363: LD_INT 2
33365: PUSH
33366: LD_INT 3
33368: PUSH
33369: LD_INT 4
33371: PUSH
33372: LD_INT 5
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: IN
33383: NOT
33384: OR
33385: PUSH
33386: LD_VAR 0 3
33390: PPUSH
33391: LD_VAR 0 4
33395: PPUSH
33396: CALL_OW 488
33400: NOT
33401: OR
33402: IFFALSE 33406
// exit ;
33404: GO 34142
// side := GetSide ( depot ) ;
33406: LD_ADDR_VAR 0 9
33410: PUSH
33411: LD_VAR 0 1
33415: PPUSH
33416: CALL_OW 255
33420: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33421: LD_VAR 0 9
33425: PPUSH
33426: LD_VAR 0 2
33430: PPUSH
33431: CALL 32899 0 2
33435: NOT
33436: IFFALSE 33440
// exit ;
33438: GO 34142
// pom := GetBase ( depot ) ;
33440: LD_ADDR_VAR 0 10
33444: PUSH
33445: LD_VAR 0 1
33449: PPUSH
33450: CALL_OW 274
33454: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33455: LD_ADDR_VAR 0 11
33459: PUSH
33460: LD_VAR 0 2
33464: PPUSH
33465: LD_VAR 0 1
33469: PPUSH
33470: CALL_OW 248
33474: PPUSH
33475: CALL_OW 450
33479: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33480: LD_VAR 0 10
33484: PPUSH
33485: LD_INT 1
33487: PPUSH
33488: CALL_OW 275
33492: PUSH
33493: LD_VAR 0 11
33497: PUSH
33498: LD_INT 1
33500: ARRAY
33501: GREATEREQUAL
33502: PUSH
33503: LD_VAR 0 10
33507: PPUSH
33508: LD_INT 2
33510: PPUSH
33511: CALL_OW 275
33515: PUSH
33516: LD_VAR 0 11
33520: PUSH
33521: LD_INT 2
33523: ARRAY
33524: GREATEREQUAL
33525: AND
33526: PUSH
33527: LD_VAR 0 10
33531: PPUSH
33532: LD_INT 3
33534: PPUSH
33535: CALL_OW 275
33539: PUSH
33540: LD_VAR 0 11
33544: PUSH
33545: LD_INT 3
33547: ARRAY
33548: GREATEREQUAL
33549: AND
33550: NOT
33551: IFFALSE 33555
// exit ;
33553: GO 34142
// if GetBType ( depot ) = b_depot then
33555: LD_VAR 0 1
33559: PPUSH
33560: CALL_OW 266
33564: PUSH
33565: LD_INT 0
33567: EQUAL
33568: IFFALSE 33580
// dist := 28 else
33570: LD_ADDR_VAR 0 14
33574: PUSH
33575: LD_INT 28
33577: ST_TO_ADDR
33578: GO 33588
// dist := 36 ;
33580: LD_ADDR_VAR 0 14
33584: PUSH
33585: LD_INT 36
33587: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33588: LD_VAR 0 1
33592: PPUSH
33593: LD_VAR 0 3
33597: PPUSH
33598: LD_VAR 0 4
33602: PPUSH
33603: CALL_OW 297
33607: PUSH
33608: LD_VAR 0 14
33612: GREATER
33613: IFFALSE 33617
// exit ;
33615: GO 34142
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33617: LD_ADDR_VAR 0 12
33621: PUSH
33622: LD_VAR 0 2
33626: PPUSH
33627: LD_VAR 0 3
33631: PPUSH
33632: LD_VAR 0 4
33636: PPUSH
33637: LD_VAR 0 5
33641: PPUSH
33642: LD_VAR 0 1
33646: PPUSH
33647: CALL_OW 248
33651: PPUSH
33652: LD_INT 0
33654: PPUSH
33655: CALL 34147 0 6
33659: ST_TO_ADDR
// if not hexes then
33660: LD_VAR 0 12
33664: NOT
33665: IFFALSE 33669
// exit ;
33667: GO 34142
// hex := GetHexInfo ( x , y ) ;
33669: LD_ADDR_VAR 0 15
33673: PUSH
33674: LD_VAR 0 3
33678: PPUSH
33679: LD_VAR 0 4
33683: PPUSH
33684: CALL_OW 546
33688: ST_TO_ADDR
// if hex [ 1 ] then
33689: LD_VAR 0 15
33693: PUSH
33694: LD_INT 1
33696: ARRAY
33697: IFFALSE 33701
// exit ;
33699: GO 34142
// height := hex [ 2 ] ;
33701: LD_ADDR_VAR 0 13
33705: PUSH
33706: LD_VAR 0 15
33710: PUSH
33711: LD_INT 2
33713: ARRAY
33714: ST_TO_ADDR
// for i = 1 to hexes do
33715: LD_ADDR_VAR 0 7
33719: PUSH
33720: DOUBLE
33721: LD_INT 1
33723: DEC
33724: ST_TO_ADDR
33725: LD_VAR 0 12
33729: PUSH
33730: FOR_TO
33731: IFFALSE 34061
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33733: LD_VAR 0 12
33737: PUSH
33738: LD_VAR 0 7
33742: ARRAY
33743: PUSH
33744: LD_INT 1
33746: ARRAY
33747: PPUSH
33748: LD_VAR 0 12
33752: PUSH
33753: LD_VAR 0 7
33757: ARRAY
33758: PUSH
33759: LD_INT 2
33761: ARRAY
33762: PPUSH
33763: CALL_OW 488
33767: NOT
33768: PUSH
33769: LD_VAR 0 12
33773: PUSH
33774: LD_VAR 0 7
33778: ARRAY
33779: PUSH
33780: LD_INT 1
33782: ARRAY
33783: PPUSH
33784: LD_VAR 0 12
33788: PUSH
33789: LD_VAR 0 7
33793: ARRAY
33794: PUSH
33795: LD_INT 2
33797: ARRAY
33798: PPUSH
33799: CALL_OW 428
33803: PUSH
33804: LD_INT 0
33806: GREATER
33807: OR
33808: PUSH
33809: LD_VAR 0 12
33813: PUSH
33814: LD_VAR 0 7
33818: ARRAY
33819: PUSH
33820: LD_INT 1
33822: ARRAY
33823: PPUSH
33824: LD_VAR 0 12
33828: PUSH
33829: LD_VAR 0 7
33833: ARRAY
33834: PUSH
33835: LD_INT 2
33837: ARRAY
33838: PPUSH
33839: CALL_OW 351
33843: OR
33844: IFFALSE 33850
// exit ;
33846: POP
33847: POP
33848: GO 34142
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33850: LD_ADDR_VAR 0 8
33854: PUSH
33855: LD_VAR 0 12
33859: PUSH
33860: LD_VAR 0 7
33864: ARRAY
33865: PUSH
33866: LD_INT 1
33868: ARRAY
33869: PPUSH
33870: LD_VAR 0 12
33874: PUSH
33875: LD_VAR 0 7
33879: ARRAY
33880: PUSH
33881: LD_INT 2
33883: ARRAY
33884: PPUSH
33885: CALL_OW 546
33889: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33890: LD_VAR 0 8
33894: PUSH
33895: LD_INT 1
33897: ARRAY
33898: PUSH
33899: LD_VAR 0 8
33903: PUSH
33904: LD_INT 2
33906: ARRAY
33907: PUSH
33908: LD_VAR 0 13
33912: PUSH
33913: LD_INT 2
33915: PLUS
33916: GREATER
33917: OR
33918: PUSH
33919: LD_VAR 0 8
33923: PUSH
33924: LD_INT 2
33926: ARRAY
33927: PUSH
33928: LD_VAR 0 13
33932: PUSH
33933: LD_INT 2
33935: MINUS
33936: LESS
33937: OR
33938: PUSH
33939: LD_VAR 0 8
33943: PUSH
33944: LD_INT 3
33946: ARRAY
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 8
33953: PUSH
33954: LD_INT 9
33956: PUSH
33957: LD_INT 10
33959: PUSH
33960: LD_INT 11
33962: PUSH
33963: LD_INT 12
33965: PUSH
33966: LD_INT 13
33968: PUSH
33969: LD_INT 16
33971: PUSH
33972: LD_INT 17
33974: PUSH
33975: LD_INT 18
33977: PUSH
33978: LD_INT 19
33980: PUSH
33981: LD_INT 20
33983: PUSH
33984: LD_INT 21
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: IN
34002: NOT
34003: OR
34004: PUSH
34005: LD_VAR 0 8
34009: PUSH
34010: LD_INT 5
34012: ARRAY
34013: NOT
34014: OR
34015: PUSH
34016: LD_VAR 0 8
34020: PUSH
34021: LD_INT 6
34023: ARRAY
34024: PUSH
34025: LD_INT 1
34027: PUSH
34028: LD_INT 2
34030: PUSH
34031: LD_INT 7
34033: PUSH
34034: LD_INT 9
34036: PUSH
34037: LD_INT 10
34039: PUSH
34040: LD_INT 11
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: IN
34051: NOT
34052: OR
34053: IFFALSE 34059
// exit ;
34055: POP
34056: POP
34057: GO 34142
// end ;
34059: GO 33730
34061: POP
34062: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
34063: LD_VAR 0 9
34067: PPUSH
34068: LD_VAR 0 3
34072: PPUSH
34073: LD_VAR 0 4
34077: PPUSH
34078: LD_INT 20
34080: PPUSH
34081: CALL 26065 0 4
34085: PUSH
34086: LD_INT 4
34088: ARRAY
34089: IFFALSE 34093
// exit ;
34091: GO 34142
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
34093: LD_VAR 0 2
34097: PUSH
34098: LD_INT 29
34100: PUSH
34101: LD_INT 30
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: IN
34108: PUSH
34109: LD_VAR 0 3
34113: PPUSH
34114: LD_VAR 0 4
34118: PPUSH
34119: LD_VAR 0 9
34123: PPUSH
34124: CALL_OW 440
34128: NOT
34129: AND
34130: IFFALSE 34134
// exit ;
34132: GO 34142
// result := true ;
34134: LD_ADDR_VAR 0 6
34138: PUSH
34139: LD_INT 1
34141: ST_TO_ADDR
// end ;
34142: LD_VAR 0 6
34146: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
34147: LD_INT 0
34149: PPUSH
34150: PPUSH
34151: PPUSH
34152: PPUSH
34153: PPUSH
34154: PPUSH
34155: PPUSH
34156: PPUSH
34157: PPUSH
34158: PPUSH
34159: PPUSH
34160: PPUSH
34161: PPUSH
34162: PPUSH
34163: PPUSH
34164: PPUSH
34165: PPUSH
34166: PPUSH
34167: PPUSH
34168: PPUSH
34169: PPUSH
34170: PPUSH
34171: PPUSH
34172: PPUSH
34173: PPUSH
34174: PPUSH
34175: PPUSH
34176: PPUSH
34177: PPUSH
34178: PPUSH
34179: PPUSH
34180: PPUSH
34181: PPUSH
34182: PPUSH
34183: PPUSH
34184: PPUSH
34185: PPUSH
34186: PPUSH
34187: PPUSH
34188: PPUSH
34189: PPUSH
34190: PPUSH
34191: PPUSH
34192: PPUSH
34193: PPUSH
34194: PPUSH
34195: PPUSH
34196: PPUSH
34197: PPUSH
34198: PPUSH
34199: PPUSH
34200: PPUSH
34201: PPUSH
34202: PPUSH
34203: PPUSH
34204: PPUSH
34205: PPUSH
34206: PPUSH
// result = [ ] ;
34207: LD_ADDR_VAR 0 7
34211: PUSH
34212: EMPTY
34213: ST_TO_ADDR
// temp_list = [ ] ;
34214: LD_ADDR_VAR 0 9
34218: PUSH
34219: EMPTY
34220: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34221: LD_VAR 0 4
34225: PUSH
34226: LD_INT 0
34228: PUSH
34229: LD_INT 1
34231: PUSH
34232: LD_INT 2
34234: PUSH
34235: LD_INT 3
34237: PUSH
34238: LD_INT 4
34240: PUSH
34241: LD_INT 5
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: IN
34252: NOT
34253: PUSH
34254: LD_VAR 0 1
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: LD_INT 1
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: IN
34269: PUSH
34270: LD_VAR 0 5
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 2
34280: PUSH
34281: LD_INT 3
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: LIST
34288: IN
34289: NOT
34290: AND
34291: OR
34292: IFFALSE 34296
// exit ;
34294: GO 52687
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34296: LD_VAR 0 1
34300: PUSH
34301: LD_INT 6
34303: PUSH
34304: LD_INT 7
34306: PUSH
34307: LD_INT 8
34309: PUSH
34310: LD_INT 13
34312: PUSH
34313: LD_INT 12
34315: PUSH
34316: LD_INT 15
34318: PUSH
34319: LD_INT 11
34321: PUSH
34322: LD_INT 14
34324: PUSH
34325: LD_INT 10
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: IN
34339: IFFALSE 34349
// btype = b_lab ;
34341: LD_ADDR_VAR 0 1
34345: PUSH
34346: LD_INT 6
34348: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34349: LD_VAR 0 6
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 2
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: LIST
34367: IN
34368: NOT
34369: PUSH
34370: LD_VAR 0 1
34374: PUSH
34375: LD_INT 0
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: LD_INT 2
34383: PUSH
34384: LD_INT 3
34386: PUSH
34387: LD_INT 6
34389: PUSH
34390: LD_INT 36
34392: PUSH
34393: LD_INT 4
34395: PUSH
34396: LD_INT 5
34398: PUSH
34399: LD_INT 31
34401: PUSH
34402: LD_INT 32
34404: PUSH
34405: LD_INT 33
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: IN
34421: NOT
34422: PUSH
34423: LD_VAR 0 6
34427: PUSH
34428: LD_INT 1
34430: EQUAL
34431: AND
34432: OR
34433: PUSH
34434: LD_VAR 0 1
34438: PUSH
34439: LD_INT 2
34441: PUSH
34442: LD_INT 3
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: IN
34449: NOT
34450: PUSH
34451: LD_VAR 0 6
34455: PUSH
34456: LD_INT 2
34458: EQUAL
34459: AND
34460: OR
34461: IFFALSE 34471
// mode = 0 ;
34463: LD_ADDR_VAR 0 6
34467: PUSH
34468: LD_INT 0
34470: ST_TO_ADDR
// case mode of 0 :
34471: LD_VAR 0 6
34475: PUSH
34476: LD_INT 0
34478: DOUBLE
34479: EQUAL
34480: IFTRUE 34484
34482: GO 45937
34484: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34485: LD_ADDR_VAR 0 11
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: LD_INT 1
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 0
34533: PUSH
34534: LD_INT 1
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 1
34543: NEG
34544: PUSH
34545: LD_INT 0
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: LD_INT 1
34558: NEG
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: LD_INT 2
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 0
34578: PUSH
34579: LD_INT 2
34581: NEG
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 1
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: PUSH
34608: LD_INT 0
34610: PUSH
34611: LD_INT 2
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: NEG
34621: PUSH
34622: LD_INT 1
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PUSH
34629: LD_INT 1
34631: PUSH
34632: LD_INT 3
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 0
34641: PUSH
34642: LD_INT 3
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: LD_INT 2
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34678: LD_ADDR_VAR 0 12
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: LD_INT 1
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: PUSH
34707: LD_INT 0
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 1
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 1
34736: NEG
34737: PUSH
34738: LD_INT 0
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: LD_INT 1
34751: NEG
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 1
34759: PUSH
34760: LD_INT 1
34762: NEG
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: PUSH
34768: LD_INT 2
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 2
34780: PUSH
34781: LD_INT 1
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 1
34790: NEG
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 2
34812: NEG
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: LD_INT 1
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 3
34835: NEG
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 3
34846: NEG
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34874: LD_ADDR_VAR 0 13
34878: PUSH
34879: LD_INT 0
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 0
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 1
34912: PUSH
34913: LD_INT 1
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 0
34922: PUSH
34923: LD_INT 1
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: LD_INT 1
34947: NEG
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 1
34955: NEG
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 2
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 2
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: LD_INT 2
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 2
34997: NEG
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 3
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 3
35033: NEG
35034: PUSH
35035: LD_INT 2
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 3
35045: NEG
35046: PUSH
35047: LD_INT 3
35049: NEG
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35073: LD_ADDR_VAR 0 14
35077: PUSH
35078: LD_INT 0
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: LD_INT 1
35093: NEG
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 1
35101: PUSH
35102: LD_INT 0
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 1
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: LD_INT 1
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 1
35131: NEG
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 1
35142: NEG
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 2
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: LD_INT 2
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: PUSH
35178: LD_INT 1
35180: NEG
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 1
35188: PUSH
35189: LD_INT 2
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 0
35198: PUSH
35199: LD_INT 2
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: LD_INT 3
35223: NEG
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: LD_INT 3
35234: NEG
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 1
35242: PUSH
35243: LD_INT 2
35245: NEG
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: LIST
35255: LIST
35256: LIST
35257: LIST
35258: LIST
35259: LIST
35260: LIST
35261: LIST
35262: LIST
35263: LIST
35264: LIST
35265: LIST
35266: LIST
35267: LIST
35268: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35269: LD_ADDR_VAR 0 15
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: LD_INT 0
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: LD_INT 0
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 1
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 0
35317: PUSH
35318: LD_INT 1
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: NEG
35328: PUSH
35329: LD_INT 0
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 1
35338: NEG
35339: PUSH
35340: LD_INT 1
35342: NEG
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: LD_INT 1
35353: NEG
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 2
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 2
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 1
35381: NEG
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 2
35392: NEG
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 2
35403: NEG
35404: PUSH
35405: LD_INT 1
35407: NEG
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 2
35415: PUSH
35416: LD_INT 1
35418: NEG
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 3
35426: PUSH
35427: LD_INT 0
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 3
35436: PUSH
35437: LD_INT 1
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35462: LD_ADDR_VAR 0 16
35466: PUSH
35467: LD_INT 0
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: LD_INT 1
35482: NEG
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PUSH
35498: LD_INT 1
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 0
35510: PUSH
35511: LD_INT 1
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 1
35520: NEG
35521: PUSH
35522: LD_INT 0
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: LD_INT 1
35535: NEG
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: NEG
35544: PUSH
35545: LD_INT 2
35547: NEG
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 2
35555: PUSH
35556: LD_INT 1
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 2
35565: PUSH
35566: LD_INT 2
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: LD_INT 1
35575: PUSH
35576: LD_INT 2
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 2
35585: NEG
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 2
35597: NEG
35598: PUSH
35599: LD_INT 2
35601: NEG
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 3
35609: PUSH
35610: LD_INT 2
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 3
35619: PUSH
35620: LD_INT 3
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 2
35629: PUSH
35630: LD_INT 3
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35655: LD_ADDR_VAR 0 17
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 0
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 0
35672: PUSH
35673: LD_INT 1
35675: NEG
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 1
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 0
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 1
35713: NEG
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 1
35724: NEG
35725: PUSH
35726: LD_INT 1
35728: NEG
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 1
35736: NEG
35737: PUSH
35738: LD_INT 2
35740: NEG
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: LD_INT 2
35751: NEG
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: LD_INT 1
35762: NEG
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 2
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: PUSH
35781: LD_INT 1
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 2
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 1
35800: PUSH
35801: LD_INT 2
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 0
35810: PUSH
35811: LD_INT 2
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 2
35831: NEG
35832: PUSH
35833: LD_INT 0
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 2
35842: NEG
35843: PUSH
35844: LD_INT 1
35846: NEG
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 2
35854: NEG
35855: PUSH
35856: LD_INT 2
35858: NEG
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: LIST
35877: LIST
35878: LIST
35879: LIST
35880: LIST
35881: LIST
35882: LIST
35883: LIST
35884: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35885: LD_ADDR_VAR 0 18
35889: PUSH
35890: LD_INT 0
35892: PUSH
35893: LD_INT 0
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 0
35902: PUSH
35903: LD_INT 1
35905: NEG
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 1
35913: PUSH
35914: LD_INT 0
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 0
35933: PUSH
35934: LD_INT 1
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 1
35943: NEG
35944: PUSH
35945: LD_INT 0
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 1
35954: NEG
35955: PUSH
35956: LD_INT 1
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: LD_INT 2
35970: NEG
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: LD_INT 2
35981: NEG
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: LD_INT 1
35992: NEG
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 2
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 2
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 2
36020: PUSH
36021: LD_INT 2
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 1
36030: PUSH
36031: LD_INT 2
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: PUSH
36038: LD_INT 0
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: LD_INT 1
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 2
36072: NEG
36073: PUSH
36074: LD_INT 1
36076: NEG
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: LD_INT 2
36084: NEG
36085: PUSH
36086: LD_INT 2
36088: NEG
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36115: LD_ADDR_VAR 0 19
36119: PUSH
36120: LD_INT 0
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 0
36132: PUSH
36133: LD_INT 1
36135: NEG
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 1
36153: PUSH
36154: LD_INT 1
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: LD_INT 0
36163: PUSH
36164: LD_INT 1
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: LD_INT 0
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: LD_INT 1
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: LD_INT 2
36200: NEG
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 2
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: LD_INT 1
36222: NEG
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 2
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 2
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 2
36250: PUSH
36251: LD_INT 2
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 1
36260: PUSH
36261: LD_INT 2
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 0
36270: PUSH
36271: LD_INT 2
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: LD_INT 1
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: LD_INT 0
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 2
36302: NEG
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 2
36314: NEG
36315: PUSH
36316: LD_INT 2
36318: NEG
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36345: LD_ADDR_VAR 0 20
36349: PUSH
36350: LD_INT 0
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 0
36362: PUSH
36363: LD_INT 1
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: LD_INT 0
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 0
36393: PUSH
36394: LD_INT 1
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: NEG
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: NEG
36427: PUSH
36428: LD_INT 2
36430: NEG
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: LD_INT 2
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: LD_INT 1
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 2
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 2
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 2
36480: PUSH
36481: LD_INT 2
36483: PUSH
36484: EMPTY
36485: LIST
36486: LIST
36487: PUSH
36488: LD_INT 1
36490: PUSH
36491: LD_INT 2
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: LD_INT 2
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: LD_INT 1
36510: NEG
36511: PUSH
36512: LD_INT 1
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: LD_INT 2
36521: NEG
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: LD_INT 1
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 2
36544: NEG
36545: PUSH
36546: LD_INT 2
36548: NEG
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: LIST
36560: LIST
36561: LIST
36562: LIST
36563: LIST
36564: LIST
36565: LIST
36566: LIST
36567: LIST
36568: LIST
36569: LIST
36570: LIST
36571: LIST
36572: LIST
36573: LIST
36574: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36575: LD_ADDR_VAR 0 21
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: LD_INT 0
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 0
36592: PUSH
36593: LD_INT 1
36595: NEG
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 1
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 1
36613: PUSH
36614: LD_INT 1
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 0
36623: PUSH
36624: LD_INT 1
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 1
36633: NEG
36634: PUSH
36635: LD_INT 0
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 0
36668: PUSH
36669: LD_INT 2
36671: NEG
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 1
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 2
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: PUSH
36701: LD_INT 1
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: PUSH
36711: LD_INT 2
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 1
36720: PUSH
36721: LD_INT 2
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: LD_INT 2
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 2
36751: NEG
36752: PUSH
36753: LD_INT 0
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 2
36762: NEG
36763: PUSH
36764: LD_INT 1
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 2
36774: NEG
36775: PUSH
36776: LD_INT 2
36778: NEG
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: LIST
36804: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36805: LD_ADDR_VAR 0 22
36809: PUSH
36810: LD_INT 0
36812: PUSH
36813: LD_INT 0
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 0
36822: PUSH
36823: LD_INT 1
36825: NEG
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 1
36833: PUSH
36834: LD_INT 0
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: PUSH
36844: LD_INT 1
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 0
36853: PUSH
36854: LD_INT 1
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 1
36886: NEG
36887: PUSH
36888: LD_INT 2
36890: NEG
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 0
36898: PUSH
36899: LD_INT 2
36901: NEG
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: LD_INT 1
36912: NEG
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 2
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 2
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 2
36940: PUSH
36941: LD_INT 2
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: LD_INT 2
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 0
36960: PUSH
36961: LD_INT 2
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 2
36981: NEG
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 2
36992: NEG
36993: PUSH
36994: LD_INT 1
36996: NEG
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: NEG
37005: PUSH
37006: LD_INT 2
37008: NEG
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37035: LD_ADDR_VAR 0 23
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: LD_INT 0
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: LD_INT 1
37055: NEG
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: LD_INT 1
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 0
37083: PUSH
37084: LD_INT 1
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: NEG
37094: PUSH
37095: LD_INT 0
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: NEG
37105: PUSH
37106: LD_INT 1
37108: NEG
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: LD_INT 1
37116: NEG
37117: PUSH
37118: LD_INT 2
37120: NEG
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 0
37128: PUSH
37129: LD_INT 2
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 1
37139: PUSH
37140: LD_INT 1
37142: NEG
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 2
37150: PUSH
37151: LD_INT 0
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: LD_INT 2
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: LD_INT 2
37170: PUSH
37171: LD_INT 2
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 1
37180: PUSH
37181: LD_INT 2
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: LD_INT 2
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: PUSH
37198: LD_INT 1
37200: NEG
37201: PUSH
37202: LD_INT 1
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: LD_INT 2
37211: NEG
37212: PUSH
37213: LD_INT 0
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 2
37222: NEG
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 2
37234: NEG
37235: PUSH
37236: LD_INT 2
37238: NEG
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: LD_INT 3
37250: NEG
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 1
37258: NEG
37259: PUSH
37260: LD_INT 3
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: PUSH
37271: LD_INT 2
37273: NEG
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 1
37284: NEG
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37315: LD_ADDR_VAR 0 24
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: LD_INT 0
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 0
37332: PUSH
37333: LD_INT 1
37335: NEG
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 1
37343: PUSH
37344: LD_INT 0
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 1
37353: PUSH
37354: LD_INT 1
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 0
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: LD_INT 1
37384: NEG
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: LD_INT 2
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 0
37408: PUSH
37409: LD_INT 2
37411: NEG
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 1
37419: PUSH
37420: LD_INT 1
37422: NEG
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 2
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 2
37440: PUSH
37441: LD_INT 1
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 2
37450: PUSH
37451: LD_INT 2
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: LD_INT 2
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: LD_INT 2
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: NEG
37481: PUSH
37482: LD_INT 1
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: NEG
37492: PUSH
37493: LD_INT 0
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 2
37502: NEG
37503: PUSH
37504: LD_INT 1
37506: NEG
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 2
37514: NEG
37515: PUSH
37516: LD_INT 2
37518: NEG
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 1
37526: PUSH
37527: LD_INT 2
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 2
37537: PUSH
37538: LD_INT 1
37540: NEG
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 3
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 3
37558: PUSH
37559: LD_INT 2
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37591: LD_ADDR_VAR 0 25
37595: PUSH
37596: LD_INT 0
37598: PUSH
37599: LD_INT 0
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 0
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: LD_INT 1
37619: PUSH
37620: LD_INT 0
37622: PUSH
37623: EMPTY
37624: LIST
37625: LIST
37626: PUSH
37627: LD_INT 1
37629: PUSH
37630: LD_INT 1
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: LD_INT 1
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 1
37660: NEG
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 1
37672: NEG
37673: PUSH
37674: LD_INT 2
37676: NEG
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: LD_INT 2
37687: NEG
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 1
37695: PUSH
37696: LD_INT 1
37698: NEG
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: LD_INT 2
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 2
37716: PUSH
37717: LD_INT 1
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 2
37726: PUSH
37727: LD_INT 2
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 2
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 2
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 1
37756: NEG
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 2
37767: NEG
37768: PUSH
37769: LD_INT 0
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 2
37778: NEG
37779: PUSH
37780: LD_INT 1
37782: NEG
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 2
37790: NEG
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 3
37802: PUSH
37803: LD_INT 1
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 3
37812: PUSH
37813: LD_INT 2
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 2
37822: PUSH
37823: LD_INT 3
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 1
37832: PUSH
37833: LD_INT 3
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37865: LD_ADDR_VAR 0 26
37869: PUSH
37870: LD_INT 0
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 0
37882: PUSH
37883: LD_INT 1
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 1
37893: PUSH
37894: LD_INT 0
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 1
37903: PUSH
37904: LD_INT 1
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 0
37913: PUSH
37914: LD_INT 1
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: LD_INT 0
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 1
37934: NEG
37935: PUSH
37936: LD_INT 1
37938: NEG
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 1
37946: NEG
37947: PUSH
37948: LD_INT 2
37950: NEG
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 0
37958: PUSH
37959: LD_INT 2
37961: NEG
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 1
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 2
37990: PUSH
37991: LD_INT 1
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 2
38000: PUSH
38001: LD_INT 2
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 1
38010: PUSH
38011: LD_INT 2
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: LD_INT 2
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PUSH
38028: LD_INT 1
38030: NEG
38031: PUSH
38032: LD_INT 1
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 2
38041: NEG
38042: PUSH
38043: LD_INT 0
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 2
38052: NEG
38053: PUSH
38054: LD_INT 1
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 2
38064: NEG
38065: PUSH
38066: LD_INT 2
38068: NEG
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 2
38076: PUSH
38077: LD_INT 3
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: LD_INT 3
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 1
38096: NEG
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 2
38107: NEG
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: LIST
38120: LIST
38121: LIST
38122: LIST
38123: LIST
38124: LIST
38125: LIST
38126: LIST
38127: LIST
38128: LIST
38129: LIST
38130: LIST
38131: LIST
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38141: LD_ADDR_VAR 0 27
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: LD_INT 0
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PUSH
38156: LD_INT 0
38158: PUSH
38159: LD_INT 1
38161: NEG
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 1
38169: PUSH
38170: LD_INT 0
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 1
38179: PUSH
38180: LD_INT 1
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 0
38189: PUSH
38190: LD_INT 1
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 1
38199: NEG
38200: PUSH
38201: LD_INT 0
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 1
38210: NEG
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: NEG
38223: PUSH
38224: LD_INT 2
38226: NEG
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: LD_INT 2
38237: NEG
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 2
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 2
38276: PUSH
38277: LD_INT 2
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: PUSH
38287: LD_INT 2
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: LD_INT 2
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 1
38306: NEG
38307: PUSH
38308: LD_INT 1
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PUSH
38315: LD_INT 2
38317: NEG
38318: PUSH
38319: LD_INT 0
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 2
38328: NEG
38329: PUSH
38330: LD_INT 1
38332: NEG
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: LD_INT 2
38344: NEG
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: LD_INT 2
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: LD_INT 1
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 3
38374: NEG
38375: PUSH
38376: LD_INT 1
38378: NEG
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 3
38386: NEG
38387: PUSH
38388: LD_INT 2
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38421: LD_ADDR_VAR 0 28
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: LD_INT 0
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: LD_INT 1
38441: NEG
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 1
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 1
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: LD_INT 1
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: NEG
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 1
38490: NEG
38491: PUSH
38492: LD_INT 1
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 1
38502: NEG
38503: PUSH
38504: LD_INT 2
38506: NEG
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 0
38514: PUSH
38515: LD_INT 2
38517: NEG
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: LD_INT 1
38528: NEG
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 2
38536: PUSH
38537: LD_INT 0
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 2
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 2
38556: PUSH
38557: LD_INT 2
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: LD_INT 2
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 0
38576: PUSH
38577: LD_INT 2
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 1
38586: NEG
38587: PUSH
38588: LD_INT 1
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 2
38597: NEG
38598: PUSH
38599: LD_INT 0
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 2
38608: NEG
38609: PUSH
38610: LD_INT 1
38612: NEG
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: NEG
38621: PUSH
38622: LD_INT 2
38624: NEG
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 2
38632: NEG
38633: PUSH
38634: LD_INT 3
38636: NEG
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 1
38644: NEG
38645: PUSH
38646: LD_INT 3
38648: NEG
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 3
38656: NEG
38657: PUSH
38658: LD_INT 1
38660: NEG
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 3
38668: NEG
38669: PUSH
38670: LD_INT 2
38672: NEG
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: LIST
38701: LIST
38702: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38703: LD_ADDR_VAR 0 29
38707: PUSH
38708: LD_INT 0
38710: PUSH
38711: LD_INT 0
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 0
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 1
38731: PUSH
38732: LD_INT 0
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 1
38741: PUSH
38742: LD_INT 1
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 0
38751: PUSH
38752: LD_INT 1
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 1
38761: NEG
38762: PUSH
38763: LD_INT 0
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 1
38772: NEG
38773: PUSH
38774: LD_INT 1
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 1
38784: NEG
38785: PUSH
38786: LD_INT 2
38788: NEG
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: LD_INT 2
38799: NEG
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 1
38807: PUSH
38808: LD_INT 1
38810: NEG
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 2
38818: PUSH
38819: LD_INT 0
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 2
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 1
38838: PUSH
38839: LD_INT 2
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 0
38848: PUSH
38849: LD_INT 2
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 1
38858: NEG
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: LD_INT 1
38873: NEG
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 2
38881: NEG
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 2
38893: NEG
38894: PUSH
38895: LD_INT 3
38897: NEG
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 2
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 3
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 1
38926: PUSH
38927: LD_INT 3
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 3
38947: NEG
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: LIST
38979: LIST
38980: LIST
38981: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38982: LD_ADDR_VAR 0 30
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 0
38999: PUSH
39000: LD_INT 1
39002: NEG
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 1
39010: PUSH
39011: LD_INT 0
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: LD_INT 1
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 0
39030: PUSH
39031: LD_INT 1
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: NEG
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 1
39051: NEG
39052: PUSH
39053: LD_INT 1
39055: NEG
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: LD_INT 2
39067: NEG
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: LD_INT 0
39075: PUSH
39076: LD_INT 2
39078: NEG
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 1
39086: PUSH
39087: LD_INT 1
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 2
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: LD_INT 2
39107: PUSH
39108: LD_INT 1
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 2
39117: PUSH
39118: LD_INT 2
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: LD_INT 2
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 1
39137: NEG
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 2
39148: NEG
39149: PUSH
39150: LD_INT 0
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 2
39159: NEG
39160: PUSH
39161: LD_INT 1
39163: NEG
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 1
39171: NEG
39172: PUSH
39173: LD_INT 3
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: LD_INT 2
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 3
39194: PUSH
39195: LD_INT 2
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 2
39204: PUSH
39205: LD_INT 3
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 2
39214: NEG
39215: PUSH
39216: LD_INT 1
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 3
39225: NEG
39226: PUSH
39227: LD_INT 1
39229: NEG
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39260: LD_ADDR_VAR 0 31
39264: PUSH
39265: LD_INT 0
39267: PUSH
39268: LD_INT 0
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 1
39280: NEG
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: LD_INT 1
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 0
39308: PUSH
39309: LD_INT 1
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 1
39318: NEG
39319: PUSH
39320: LD_INT 0
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 1
39329: NEG
39330: PUSH
39331: LD_INT 1
39333: NEG
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: LD_INT 2
39345: NEG
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 1
39353: PUSH
39354: LD_INT 1
39356: NEG
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 2
39364: PUSH
39365: LD_INT 0
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 2
39374: PUSH
39375: LD_INT 1
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 2
39384: PUSH
39385: LD_INT 2
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 1
39394: PUSH
39395: LD_INT 2
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 0
39404: PUSH
39405: LD_INT 2
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 1
39414: NEG
39415: PUSH
39416: LD_INT 1
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 2
39425: NEG
39426: PUSH
39427: LD_INT 1
39429: NEG
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: LD_INT 2
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 2
39449: NEG
39450: PUSH
39451: LD_INT 3
39453: NEG
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 2
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 3
39472: PUSH
39473: LD_INT 1
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 1
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: NEG
39493: PUSH
39494: LD_INT 2
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 3
39503: NEG
39504: PUSH
39505: LD_INT 2
39507: NEG
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39538: LD_ADDR_VAR 0 32
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 1
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 1
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 1
39596: NEG
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: LD_INT 1
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: LD_INT 2
39623: NEG
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: LD_INT 2
39634: NEG
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 1
39642: PUSH
39643: LD_INT 1
39645: NEG
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 2
39653: PUSH
39654: LD_INT 1
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: LD_INT 2
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: LD_INT 2
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 1
39693: NEG
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: NEG
39705: PUSH
39706: LD_INT 0
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 2
39715: NEG
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 1
39727: NEG
39728: PUSH
39729: LD_INT 3
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: LD_INT 2
39742: NEG
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 3
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 2
39760: PUSH
39761: LD_INT 3
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 2
39770: NEG
39771: PUSH
39772: LD_INT 1
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 3
39781: NEG
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: LIST
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: LIST
39809: LIST
39810: LIST
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39816: LD_ADDR_VAR 0 33
39820: PUSH
39821: LD_INT 0
39823: PUSH
39824: LD_INT 0
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 0
39833: PUSH
39834: LD_INT 1
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 1
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 1
39854: PUSH
39855: LD_INT 1
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 0
39864: PUSH
39865: LD_INT 1
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 1
39874: NEG
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: LD_INT 1
39889: NEG
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 1
39897: NEG
39898: PUSH
39899: LD_INT 2
39901: NEG
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: LD_INT 1
39912: NEG
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 2
39920: PUSH
39921: LD_INT 0
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 2
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: PUSH
39941: LD_INT 2
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 0
39950: PUSH
39951: LD_INT 2
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 1
39960: NEG
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 2
39971: NEG
39972: PUSH
39973: LD_INT 0
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 2
39982: NEG
39983: PUSH
39984: LD_INT 1
39986: NEG
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 2
39994: NEG
39995: PUSH
39996: LD_INT 2
39998: NEG
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: LD_INT 3
40010: NEG
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 2
40018: PUSH
40019: LD_INT 1
40021: NEG
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 3
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: LD_INT 3
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 1
40049: NEG
40050: PUSH
40051: LD_INT 2
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 3
40060: NEG
40061: PUSH
40062: LD_INT 2
40064: NEG
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: LIST
40074: LIST
40075: LIST
40076: LIST
40077: LIST
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: LIST
40083: LIST
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40095: LD_ADDR_VAR 0 34
40099: PUSH
40100: LD_INT 0
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 0
40112: PUSH
40113: LD_INT 1
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 1
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 1
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 0
40143: PUSH
40144: LD_INT 1
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 1
40153: NEG
40154: PUSH
40155: LD_INT 0
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 1
40164: NEG
40165: PUSH
40166: LD_INT 1
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 1
40176: NEG
40177: PUSH
40178: LD_INT 2
40180: NEG
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: LD_INT 2
40191: NEG
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 1
40202: NEG
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 2
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 2
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: LD_INT 1
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 2
40251: NEG
40252: PUSH
40253: LD_INT 0
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 2
40262: NEG
40263: PUSH
40264: LD_INT 1
40266: NEG
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 2
40274: NEG
40275: PUSH
40276: LD_INT 2
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 1
40286: NEG
40287: PUSH
40288: LD_INT 3
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 1
40298: PUSH
40299: LD_INT 2
40301: NEG
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 3
40309: PUSH
40310: LD_INT 2
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 2
40319: PUSH
40320: LD_INT 3
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 2
40329: NEG
40330: PUSH
40331: LD_INT 1
40333: PUSH
40334: EMPTY
40335: LIST
40336: LIST
40337: PUSH
40338: LD_INT 3
40340: NEG
40341: PUSH
40342: LD_INT 1
40344: NEG
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: EMPTY
40351: LIST
40352: LIST
40353: LIST
40354: LIST
40355: LIST
40356: LIST
40357: LIST
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40375: LD_ADDR_VAR 0 35
40379: PUSH
40380: LD_INT 0
40382: PUSH
40383: LD_INT 0
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: LD_INT 1
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: LD_INT 0
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 1
40413: PUSH
40414: LD_INT 1
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: LD_INT 1
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 1
40433: NEG
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 1
40444: NEG
40445: PUSH
40446: LD_INT 1
40448: NEG
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 2
40456: PUSH
40457: LD_INT 1
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 2
40466: NEG
40467: PUSH
40468: LD_INT 1
40470: NEG
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40487: LD_ADDR_VAR 0 36
40491: PUSH
40492: LD_INT 0
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 0
40504: PUSH
40505: LD_INT 1
40507: NEG
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 1
40515: PUSH
40516: LD_INT 0
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 1
40525: PUSH
40526: LD_INT 1
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: LD_INT 0
40535: PUSH
40536: LD_INT 1
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 1
40545: NEG
40546: PUSH
40547: LD_INT 0
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 1
40556: NEG
40557: PUSH
40558: LD_INT 1
40560: NEG
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 1
40568: NEG
40569: PUSH
40570: LD_INT 2
40572: NEG
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 1
40580: PUSH
40581: LD_INT 2
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40599: LD_ADDR_VAR 0 37
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: LD_INT 0
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 1
40619: NEG
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 1
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 1
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 0
40647: PUSH
40648: LD_INT 1
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PUSH
40666: LD_INT 1
40668: NEG
40669: PUSH
40670: LD_INT 1
40672: NEG
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 1
40680: PUSH
40681: LD_INT 1
40683: NEG
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 1
40691: NEG
40692: PUSH
40693: LD_INT 1
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40711: LD_ADDR_VAR 0 38
40715: PUSH
40716: LD_INT 0
40718: PUSH
40719: LD_INT 0
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 0
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 1
40749: PUSH
40750: LD_INT 1
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 0
40759: PUSH
40760: LD_INT 1
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 1
40769: NEG
40770: PUSH
40771: LD_INT 0
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: LD_INT 1
40780: NEG
40781: PUSH
40782: LD_INT 1
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 2
40792: PUSH
40793: LD_INT 1
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 2
40802: NEG
40803: PUSH
40804: LD_INT 1
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: LIST
40816: LIST
40817: LIST
40818: LIST
40819: LIST
40820: LIST
40821: LIST
40822: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40823: LD_ADDR_VAR 0 39
40827: PUSH
40828: LD_INT 0
40830: PUSH
40831: LD_INT 0
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 0
40840: PUSH
40841: LD_INT 1
40843: NEG
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 1
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: LD_INT 1
40861: PUSH
40862: LD_INT 1
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 0
40871: PUSH
40872: LD_INT 1
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 1
40881: NEG
40882: PUSH
40883: LD_INT 0
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: LD_INT 1
40896: NEG
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 1
40904: NEG
40905: PUSH
40906: LD_INT 2
40908: NEG
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: LD_INT 2
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40935: LD_ADDR_VAR 0 40
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 0
40952: PUSH
40953: LD_INT 1
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: LD_INT 1
40973: PUSH
40974: LD_INT 1
40976: PUSH
40977: EMPTY
40978: LIST
40979: LIST
40980: PUSH
40981: LD_INT 0
40983: PUSH
40984: LD_INT 1
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 1
40993: NEG
40994: PUSH
40995: LD_INT 0
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: LD_INT 1
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 1
41016: PUSH
41017: LD_INT 1
41019: NEG
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 1
41027: NEG
41028: PUSH
41029: LD_INT 1
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41047: LD_ADDR_VAR 0 41
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: LD_INT 0
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 0
41064: PUSH
41065: LD_INT 1
41067: NEG
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 1
41075: PUSH
41076: LD_INT 0
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 1
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 0
41095: PUSH
41096: LD_INT 1
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 1
41105: NEG
41106: PUSH
41107: LD_INT 0
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 1
41116: NEG
41117: PUSH
41118: LD_INT 1
41120: NEG
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 1
41128: NEG
41129: PUSH
41130: LD_INT 2
41132: NEG
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 1
41140: PUSH
41141: LD_INT 1
41143: NEG
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 2
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 2
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 2
41171: PUSH
41172: LD_INT 2
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 1
41181: PUSH
41182: LD_INT 2
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 1
41191: NEG
41192: PUSH
41193: LD_INT 1
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 2
41202: NEG
41203: PUSH
41204: LD_INT 0
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: PUSH
41211: LD_INT 2
41213: NEG
41214: PUSH
41215: LD_INT 1
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 2
41225: NEG
41226: PUSH
41227: LD_INT 2
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: NEG
41238: PUSH
41239: LD_INT 3
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 2
41249: PUSH
41250: LD_INT 1
41252: NEG
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 3
41260: PUSH
41261: LD_INT 0
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 3
41270: PUSH
41271: LD_INT 1
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 3
41280: PUSH
41281: LD_INT 2
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 3
41290: PUSH
41291: LD_INT 3
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: LD_INT 2
41300: PUSH
41301: LD_INT 3
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 2
41310: NEG
41311: PUSH
41312: LD_INT 1
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 3
41321: NEG
41322: PUSH
41323: LD_INT 0
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 3
41332: NEG
41333: PUSH
41334: LD_INT 1
41336: NEG
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: LD_INT 3
41344: NEG
41345: PUSH
41346: LD_INT 2
41348: NEG
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: NEG
41357: PUSH
41358: LD_INT 3
41360: NEG
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: LIST
41370: LIST
41371: LIST
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: LIST
41388: LIST
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41397: LD_ADDR_VAR 0 42
41401: PUSH
41402: LD_INT 0
41404: PUSH
41405: LD_INT 0
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: LD_INT 0
41414: PUSH
41415: LD_INT 1
41417: NEG
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 1
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 1
41435: PUSH
41436: LD_INT 1
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 0
41445: PUSH
41446: LD_INT 1
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 1
41455: NEG
41456: PUSH
41457: LD_INT 0
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 1
41466: NEG
41467: PUSH
41468: LD_INT 1
41470: NEG
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: LD_INT 2
41482: NEG
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 0
41490: PUSH
41491: LD_INT 2
41493: NEG
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 1
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 2
41512: PUSH
41513: LD_INT 1
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 2
41522: PUSH
41523: LD_INT 2
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: PUSH
41533: LD_INT 2
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 0
41542: PUSH
41543: LD_INT 2
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 1
41552: NEG
41553: PUSH
41554: LD_INT 1
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 2
41563: NEG
41564: PUSH
41565: LD_INT 1
41567: NEG
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 2
41575: NEG
41576: PUSH
41577: LD_INT 2
41579: NEG
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 2
41587: NEG
41588: PUSH
41589: LD_INT 3
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 1
41599: NEG
41600: PUSH
41601: LD_INT 3
41603: NEG
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: LD_INT 0
41611: PUSH
41612: LD_INT 3
41614: NEG
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 1
41622: PUSH
41623: LD_INT 2
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 3
41633: PUSH
41634: LD_INT 2
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: LD_INT 3
41643: PUSH
41644: LD_INT 3
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 2
41653: PUSH
41654: LD_INT 3
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 1
41663: PUSH
41664: LD_INT 3
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 0
41673: PUSH
41674: LD_INT 3
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 1
41683: NEG
41684: PUSH
41685: LD_INT 2
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 3
41694: NEG
41695: PUSH
41696: LD_INT 2
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 3
41706: NEG
41707: PUSH
41708: LD_INT 3
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41747: LD_ADDR_VAR 0 43
41751: PUSH
41752: LD_INT 0
41754: PUSH
41755: LD_INT 0
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 0
41764: PUSH
41765: LD_INT 1
41767: NEG
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 1
41775: PUSH
41776: LD_INT 0
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: LD_INT 1
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 0
41795: PUSH
41796: LD_INT 1
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PUSH
41803: LD_INT 1
41805: NEG
41806: PUSH
41807: LD_INT 0
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 1
41816: NEG
41817: PUSH
41818: LD_INT 1
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 1
41828: NEG
41829: PUSH
41830: LD_INT 2
41832: NEG
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 0
41840: PUSH
41841: LD_INT 2
41843: NEG
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 2
41862: PUSH
41863: LD_INT 0
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 2
41872: PUSH
41873: LD_INT 1
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: LD_INT 2
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: LD_INT 2
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 1
41902: NEG
41903: PUSH
41904: LD_INT 1
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 2
41913: NEG
41914: PUSH
41915: LD_INT 0
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: PUSH
41922: LD_INT 2
41924: NEG
41925: PUSH
41926: LD_INT 1
41928: NEG
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 1
41936: NEG
41937: PUSH
41938: LD_INT 3
41940: NEG
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 0
41948: PUSH
41949: LD_INT 3
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: LD_INT 2
41962: NEG
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 2
41970: PUSH
41971: LD_INT 1
41973: NEG
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 1
42001: PUSH
42002: LD_INT 3
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 0
42011: PUSH
42012: LD_INT 3
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 1
42021: NEG
42022: PUSH
42023: LD_INT 2
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 2
42032: NEG
42033: PUSH
42034: LD_INT 1
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 3
42043: NEG
42044: PUSH
42045: LD_INT 0
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: LD_INT 3
42054: NEG
42055: PUSH
42056: LD_INT 1
42058: NEG
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42095: LD_ADDR_VAR 0 44
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 0
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 0
42112: PUSH
42113: LD_INT 1
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: LD_INT 0
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 1
42133: PUSH
42134: LD_INT 1
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 0
42143: PUSH
42144: LD_INT 1
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 1
42153: NEG
42154: PUSH
42155: LD_INT 0
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PUSH
42162: LD_INT 1
42164: NEG
42165: PUSH
42166: LD_INT 1
42168: NEG
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: PUSH
42174: LD_INT 1
42176: NEG
42177: PUSH
42178: LD_INT 2
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 1
42188: PUSH
42189: LD_INT 1
42191: NEG
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 2
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 2
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 2
42219: PUSH
42220: LD_INT 2
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: LD_INT 2
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 1
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PUSH
42248: LD_INT 2
42250: NEG
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 2
42261: NEG
42262: PUSH
42263: LD_INT 1
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 2
42273: NEG
42274: PUSH
42275: LD_INT 2
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 2
42285: NEG
42286: PUSH
42287: LD_INT 3
42289: NEG
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 2
42297: PUSH
42298: LD_INT 1
42300: NEG
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 3
42308: PUSH
42309: LD_INT 0
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 3
42318: PUSH
42319: LD_INT 1
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 3
42328: PUSH
42329: LD_INT 2
42331: PUSH
42332: EMPTY
42333: LIST
42334: LIST
42335: PUSH
42336: LD_INT 3
42338: PUSH
42339: LD_INT 3
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 2
42348: PUSH
42349: LD_INT 3
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 2
42358: NEG
42359: PUSH
42360: LD_INT 1
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 3
42369: NEG
42370: PUSH
42371: LD_INT 0
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: LD_INT 2
42396: NEG
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: LD_INT 3
42404: NEG
42405: PUSH
42406: LD_INT 3
42408: NEG
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: LIST
42427: LIST
42428: LIST
42429: LIST
42430: LIST
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42445: LD_ADDR_VAR 0 45
42449: PUSH
42450: LD_INT 0
42452: PUSH
42453: LD_INT 0
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 0
42462: PUSH
42463: LD_INT 1
42465: NEG
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 1
42473: PUSH
42474: LD_INT 0
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 1
42483: PUSH
42484: LD_INT 1
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 0
42493: PUSH
42494: LD_INT 1
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 1
42503: NEG
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 1
42514: NEG
42515: PUSH
42516: LD_INT 1
42518: NEG
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 1
42526: NEG
42527: PUSH
42528: LD_INT 2
42530: NEG
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: LD_INT 2
42541: NEG
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 1
42549: PUSH
42550: LD_INT 1
42552: NEG
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 2
42560: PUSH
42561: LD_INT 1
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 2
42570: PUSH
42571: LD_INT 2
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 1
42580: PUSH
42581: LD_INT 2
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 1
42600: NEG
42601: PUSH
42602: LD_INT 1
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 2
42611: NEG
42612: PUSH
42613: LD_INT 1
42615: NEG
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: LD_INT 2
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 2
42635: NEG
42636: PUSH
42637: LD_INT 3
42639: NEG
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 1
42647: NEG
42648: PUSH
42649: LD_INT 3
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: LD_INT 0
42659: PUSH
42660: LD_INT 3
42662: NEG
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 1
42670: PUSH
42671: LD_INT 2
42673: NEG
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 3
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: PUSH
42692: LD_INT 3
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 2
42701: PUSH
42702: LD_INT 3
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 1
42711: PUSH
42712: LD_INT 3
42714: PUSH
42715: EMPTY
42716: LIST
42717: LIST
42718: PUSH
42719: LD_INT 0
42721: PUSH
42722: LD_INT 3
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 1
42731: NEG
42732: PUSH
42733: LD_INT 2
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 3
42742: NEG
42743: PUSH
42744: LD_INT 2
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: LD_INT 3
42758: NEG
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42795: LD_ADDR_VAR 0 46
42799: PUSH
42800: LD_INT 0
42802: PUSH
42803: LD_INT 0
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PUSH
42821: LD_INT 1
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PUSH
42831: LD_INT 1
42833: PUSH
42834: LD_INT 1
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: PUSH
42841: LD_INT 0
42843: PUSH
42844: LD_INT 1
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: PUSH
42851: LD_INT 1
42853: NEG
42854: PUSH
42855: LD_INT 0
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 1
42864: NEG
42865: PUSH
42866: LD_INT 1
42868: NEG
42869: PUSH
42870: EMPTY
42871: LIST
42872: LIST
42873: PUSH
42874: LD_INT 1
42876: NEG
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 0
42888: PUSH
42889: LD_INT 2
42891: NEG
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 1
42899: PUSH
42900: LD_INT 1
42902: NEG
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 2
42910: PUSH
42911: LD_INT 0
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 2
42920: PUSH
42921: LD_INT 1
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 2
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 2
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 1
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 2
42961: NEG
42962: PUSH
42963: LD_INT 0
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_INT 2
42972: NEG
42973: PUSH
42974: LD_INT 1
42976: NEG
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: PUSH
42982: LD_INT 1
42984: NEG
42985: PUSH
42986: LD_INT 3
42988: NEG
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: LD_INT 3
42999: NEG
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: LD_INT 2
43010: NEG
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 2
43018: PUSH
43019: LD_INT 1
43021: NEG
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 3
43029: PUSH
43030: LD_INT 0
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: PUSH
43040: LD_INT 1
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 1
43049: PUSH
43050: LD_INT 3
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 0
43059: PUSH
43060: LD_INT 3
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 1
43069: NEG
43070: PUSH
43071: LD_INT 2
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 2
43080: NEG
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: PUSH
43089: LD_INT 3
43091: NEG
43092: PUSH
43093: LD_INT 0
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: PUSH
43100: LD_INT 3
43102: NEG
43103: PUSH
43104: LD_INT 1
43106: NEG
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: LIST
43116: LIST
43117: LIST
43118: LIST
43119: LIST
43120: LIST
43121: LIST
43122: LIST
43123: LIST
43124: LIST
43125: LIST
43126: LIST
43127: LIST
43128: LIST
43129: LIST
43130: LIST
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: LIST
43138: LIST
43139: LIST
43140: LIST
43141: LIST
43142: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43143: LD_ADDR_VAR 0 47
43147: PUSH
43148: LD_INT 0
43150: PUSH
43151: LD_INT 0
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: LD_INT 1
43163: NEG
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 1
43171: PUSH
43172: LD_INT 0
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 1
43181: PUSH
43182: LD_INT 1
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 0
43191: PUSH
43192: LD_INT 1
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 1
43201: NEG
43202: PUSH
43203: LD_INT 0
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 1
43212: NEG
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 1
43224: NEG
43225: PUSH
43226: LD_INT 2
43228: NEG
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 0
43236: PUSH
43237: LD_INT 2
43239: NEG
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 1
43247: PUSH
43248: LD_INT 1
43250: NEG
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 2
43258: NEG
43259: PUSH
43260: LD_INT 1
43262: NEG
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: LD_INT 2
43270: NEG
43271: PUSH
43272: LD_INT 2
43274: NEG
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: LIST
43284: LIST
43285: LIST
43286: LIST
43287: LIST
43288: LIST
43289: LIST
43290: LIST
43291: LIST
43292: LIST
43293: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43294: LD_ADDR_VAR 0 48
43298: PUSH
43299: LD_INT 0
43301: PUSH
43302: LD_INT 0
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 0
43311: PUSH
43312: LD_INT 1
43314: NEG
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: PUSH
43323: LD_INT 0
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 0
43342: PUSH
43343: LD_INT 1
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 1
43352: NEG
43353: PUSH
43354: LD_INT 0
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 1
43363: NEG
43364: PUSH
43365: LD_INT 1
43367: NEG
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: LD_INT 1
43375: NEG
43376: PUSH
43377: LD_INT 2
43379: NEG
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 0
43387: PUSH
43388: LD_INT 2
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 1
43398: PUSH
43399: LD_INT 1
43401: NEG
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 2
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 2
43419: PUSH
43420: LD_INT 1
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: LIST
43431: LIST
43432: LIST
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: LIST
43440: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43441: LD_ADDR_VAR 0 49
43445: PUSH
43446: LD_INT 0
43448: PUSH
43449: LD_INT 0
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 0
43458: PUSH
43459: LD_INT 1
43461: NEG
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 1
43469: PUSH
43470: LD_INT 0
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: PUSH
43477: LD_INT 1
43479: PUSH
43480: LD_INT 1
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 0
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 1
43499: NEG
43500: PUSH
43501: LD_INT 0
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 1
43510: NEG
43511: PUSH
43512: LD_INT 1
43514: NEG
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 1
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 2
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 2
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 2
43553: PUSH
43554: LD_INT 2
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: PUSH
43564: LD_INT 2
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: LIST
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43585: LD_ADDR_VAR 0 50
43589: PUSH
43590: LD_INT 0
43592: PUSH
43593: LD_INT 0
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 0
43602: PUSH
43603: LD_INT 1
43605: NEG
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 1
43613: PUSH
43614: LD_INT 0
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PUSH
43621: LD_INT 1
43623: PUSH
43624: LD_INT 1
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 0
43633: PUSH
43634: LD_INT 1
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 1
43643: NEG
43644: PUSH
43645: LD_INT 0
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 1
43654: NEG
43655: PUSH
43656: LD_INT 1
43658: NEG
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 2
43666: PUSH
43667: LD_INT 1
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 2
43676: PUSH
43677: LD_INT 2
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 1
43686: PUSH
43687: LD_INT 2
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 0
43696: PUSH
43697: LD_INT 2
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 1
43706: NEG
43707: PUSH
43708: LD_INT 1
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43729: LD_ADDR_VAR 0 51
43733: PUSH
43734: LD_INT 0
43736: PUSH
43737: LD_INT 0
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 0
43746: PUSH
43747: LD_INT 1
43749: NEG
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 1
43757: PUSH
43758: LD_INT 0
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 1
43767: PUSH
43768: LD_INT 1
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 0
43777: PUSH
43778: LD_INT 1
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 1
43787: NEG
43788: PUSH
43789: LD_INT 0
43791: PUSH
43792: EMPTY
43793: LIST
43794: LIST
43795: PUSH
43796: LD_INT 1
43798: NEG
43799: PUSH
43800: LD_INT 1
43802: NEG
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 1
43810: PUSH
43811: LD_INT 2
43813: PUSH
43814: EMPTY
43815: LIST
43816: LIST
43817: PUSH
43818: LD_INT 0
43820: PUSH
43821: LD_INT 2
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PUSH
43828: LD_INT 1
43830: NEG
43831: PUSH
43832: LD_INT 1
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 2
43841: NEG
43842: PUSH
43843: LD_INT 0
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: PUSH
43850: LD_INT 2
43852: NEG
43853: PUSH
43854: LD_INT 1
43856: NEG
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43876: LD_ADDR_VAR 0 52
43880: PUSH
43881: LD_INT 0
43883: PUSH
43884: LD_INT 0
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: LD_INT 0
43893: PUSH
43894: LD_INT 1
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 1
43904: PUSH
43905: LD_INT 0
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: LD_INT 1
43914: PUSH
43915: LD_INT 1
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PUSH
43922: LD_INT 0
43924: PUSH
43925: LD_INT 1
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 1
43934: NEG
43935: PUSH
43936: LD_INT 0
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 1
43945: NEG
43946: PUSH
43947: LD_INT 1
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: LD_INT 2
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 1
43969: NEG
43970: PUSH
43971: LD_INT 1
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: LD_INT 2
43980: NEG
43981: PUSH
43982: LD_INT 0
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 2
43991: NEG
43992: PUSH
43993: LD_INT 1
43995: NEG
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: NEG
44004: PUSH
44005: LD_INT 2
44007: NEG
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: LIST
44024: LIST
44025: LIST
44026: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44027: LD_ADDR_VAR 0 53
44031: PUSH
44032: LD_INT 0
44034: PUSH
44035: LD_INT 0
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 0
44044: PUSH
44045: LD_INT 1
44047: NEG
44048: PUSH
44049: EMPTY
44050: LIST
44051: LIST
44052: PUSH
44053: LD_INT 1
44055: PUSH
44056: LD_INT 0
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: PUSH
44063: LD_INT 1
44065: PUSH
44066: LD_INT 1
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 0
44075: PUSH
44076: LD_INT 1
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 1
44085: NEG
44086: PUSH
44087: LD_INT 0
44089: PUSH
44090: EMPTY
44091: LIST
44092: LIST
44093: PUSH
44094: LD_INT 1
44096: NEG
44097: PUSH
44098: LD_INT 1
44100: NEG
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 1
44108: NEG
44109: PUSH
44110: LD_INT 2
44112: NEG
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 2
44123: NEG
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: LD_INT 1
44134: NEG
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: LD_INT 2
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 2
44152: PUSH
44153: LD_INT 1
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 2
44162: PUSH
44163: LD_INT 2
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 1
44172: PUSH
44173: LD_INT 2
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 0
44182: PUSH
44183: LD_INT 2
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 1
44192: NEG
44193: PUSH
44194: LD_INT 1
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 2
44203: NEG
44204: PUSH
44205: LD_INT 0
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 2
44214: NEG
44215: PUSH
44216: LD_INT 1
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 2
44226: NEG
44227: PUSH
44228: LD_INT 2
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44257: LD_ADDR_VAR 0 54
44261: PUSH
44262: LD_INT 0
44264: PUSH
44265: LD_INT 0
44267: PUSH
44268: EMPTY
44269: LIST
44270: LIST
44271: PUSH
44272: LD_INT 0
44274: PUSH
44275: LD_INT 1
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 1
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 1
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 0
44305: PUSH
44306: LD_INT 1
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 1
44315: NEG
44316: PUSH
44317: LD_INT 0
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 1
44326: NEG
44327: PUSH
44328: LD_INT 1
44330: NEG
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 1
44338: NEG
44339: PUSH
44340: LD_INT 2
44342: NEG
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 2
44353: NEG
44354: PUSH
44355: EMPTY
44356: LIST
44357: LIST
44358: PUSH
44359: LD_INT 1
44361: PUSH
44362: LD_INT 1
44364: NEG
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 2
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: PUSH
44383: LD_INT 1
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 2
44392: PUSH
44393: LD_INT 2
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: PUSH
44400: LD_INT 1
44402: PUSH
44403: LD_INT 2
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PUSH
44410: LD_INT 0
44412: PUSH
44413: LD_INT 2
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 1
44422: NEG
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 2
44433: NEG
44434: PUSH
44435: LD_INT 0
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 2
44444: NEG
44445: PUSH
44446: LD_INT 1
44448: NEG
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 2
44456: NEG
44457: PUSH
44458: LD_INT 2
44460: NEG
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: LIST
44478: LIST
44479: LIST
44480: LIST
44481: LIST
44482: LIST
44483: LIST
44484: LIST
44485: LIST
44486: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44487: LD_ADDR_VAR 0 55
44491: PUSH
44492: LD_INT 0
44494: PUSH
44495: LD_INT 0
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 0
44504: PUSH
44505: LD_INT 1
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 1
44515: PUSH
44516: LD_INT 0
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: PUSH
44523: LD_INT 1
44525: PUSH
44526: LD_INT 1
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 0
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 1
44545: NEG
44546: PUSH
44547: LD_INT 0
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 1
44556: NEG
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 1
44568: NEG
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: LD_INT 2
44583: NEG
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 1
44591: PUSH
44592: LD_INT 1
44594: NEG
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 2
44602: PUSH
44603: LD_INT 0
44605: PUSH
44606: EMPTY
44607: LIST
44608: LIST
44609: PUSH
44610: LD_INT 2
44612: PUSH
44613: LD_INT 1
44615: PUSH
44616: EMPTY
44617: LIST
44618: LIST
44619: PUSH
44620: LD_INT 2
44622: PUSH
44623: LD_INT 2
44625: PUSH
44626: EMPTY
44627: LIST
44628: LIST
44629: PUSH
44630: LD_INT 1
44632: PUSH
44633: LD_INT 2
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 2
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 1
44652: NEG
44653: PUSH
44654: LD_INT 1
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 2
44663: NEG
44664: PUSH
44665: LD_INT 0
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 2
44674: NEG
44675: PUSH
44676: LD_INT 1
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 2
44686: NEG
44687: PUSH
44688: LD_INT 2
44690: NEG
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44717: LD_ADDR_VAR 0 56
44721: PUSH
44722: LD_INT 0
44724: PUSH
44725: LD_INT 0
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 0
44734: PUSH
44735: LD_INT 1
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 1
44745: PUSH
44746: LD_INT 0
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 1
44755: PUSH
44756: LD_INT 1
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 0
44765: PUSH
44766: LD_INT 1
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 1
44775: NEG
44776: PUSH
44777: LD_INT 0
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: LD_INT 1
44786: NEG
44787: PUSH
44788: LD_INT 1
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 1
44798: NEG
44799: PUSH
44800: LD_INT 2
44802: NEG
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 0
44810: PUSH
44811: LD_INT 2
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 1
44821: PUSH
44822: LD_INT 1
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 2
44832: PUSH
44833: LD_INT 0
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 2
44842: PUSH
44843: LD_INT 1
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 2
44852: PUSH
44853: LD_INT 2
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 1
44862: PUSH
44863: LD_INT 2
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 0
44872: PUSH
44873: LD_INT 2
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 1
44882: NEG
44883: PUSH
44884: LD_INT 1
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 2
44893: NEG
44894: PUSH
44895: LD_INT 0
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 2
44904: NEG
44905: PUSH
44906: LD_INT 1
44908: NEG
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 2
44916: NEG
44917: PUSH
44918: LD_INT 2
44920: NEG
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44947: LD_ADDR_VAR 0 57
44951: PUSH
44952: LD_INT 0
44954: PUSH
44955: LD_INT 0
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 0
44964: PUSH
44965: LD_INT 1
44967: NEG
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 1
44975: PUSH
44976: LD_INT 0
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 1
44985: PUSH
44986: LD_INT 1
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 0
44995: PUSH
44996: LD_INT 1
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 1
45005: NEG
45006: PUSH
45007: LD_INT 0
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 1
45016: NEG
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 1
45028: NEG
45029: PUSH
45030: LD_INT 2
45032: NEG
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 0
45040: PUSH
45041: LD_INT 2
45043: NEG
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: LD_INT 1
45054: NEG
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PUSH
45060: LD_INT 2
45062: PUSH
45063: LD_INT 0
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: LD_INT 2
45072: PUSH
45073: LD_INT 1
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PUSH
45080: LD_INT 2
45082: PUSH
45083: LD_INT 2
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 1
45092: PUSH
45093: LD_INT 2
45095: PUSH
45096: EMPTY
45097: LIST
45098: LIST
45099: PUSH
45100: LD_INT 0
45102: PUSH
45103: LD_INT 2
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 1
45112: NEG
45113: PUSH
45114: LD_INT 1
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 2
45123: NEG
45124: PUSH
45125: LD_INT 0
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: LD_INT 2
45134: NEG
45135: PUSH
45136: LD_INT 1
45138: NEG
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: LD_INT 2
45146: NEG
45147: PUSH
45148: LD_INT 2
45150: NEG
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45177: LD_ADDR_VAR 0 58
45181: PUSH
45182: LD_INT 0
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 0
45194: PUSH
45195: LD_INT 1
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 1
45205: PUSH
45206: LD_INT 0
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 1
45215: PUSH
45216: LD_INT 1
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: PUSH
45223: LD_INT 0
45225: PUSH
45226: LD_INT 1
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: LD_INT 1
45235: NEG
45236: PUSH
45237: LD_INT 0
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 1
45246: NEG
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 1
45258: NEG
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: LD_INT 2
45273: NEG
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: LD_INT 1
45284: NEG
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 2
45292: PUSH
45293: LD_INT 0
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: LD_INT 2
45302: PUSH
45303: LD_INT 1
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 2
45312: PUSH
45313: LD_INT 2
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 1
45322: PUSH
45323: LD_INT 2
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 0
45332: PUSH
45333: LD_INT 2
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: LD_INT 1
45342: NEG
45343: PUSH
45344: LD_INT 1
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: PUSH
45351: LD_INT 2
45353: NEG
45354: PUSH
45355: LD_INT 0
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PUSH
45362: LD_INT 2
45364: NEG
45365: PUSH
45366: LD_INT 1
45368: NEG
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 2
45376: NEG
45377: PUSH
45378: LD_INT 2
45380: NEG
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45407: LD_ADDR_VAR 0 59
45411: PUSH
45412: LD_INT 0
45414: PUSH
45415: LD_INT 0
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 0
45424: PUSH
45425: LD_INT 1
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 1
45435: PUSH
45436: LD_INT 0
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 1
45445: PUSH
45446: LD_INT 1
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: LD_INT 0
45455: PUSH
45456: LD_INT 1
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 1
45465: NEG
45466: PUSH
45467: LD_INT 0
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 1
45476: NEG
45477: PUSH
45478: LD_INT 1
45480: NEG
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45495: LD_ADDR_VAR 0 60
45499: PUSH
45500: LD_INT 0
45502: PUSH
45503: LD_INT 0
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 0
45512: PUSH
45513: LD_INT 1
45515: NEG
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 1
45523: PUSH
45524: LD_INT 0
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 1
45533: PUSH
45534: LD_INT 1
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: LD_INT 0
45543: PUSH
45544: LD_INT 1
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 1
45553: NEG
45554: PUSH
45555: LD_INT 0
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: LD_INT 1
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45583: LD_ADDR_VAR 0 61
45587: PUSH
45588: LD_INT 0
45590: PUSH
45591: LD_INT 0
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: PUSH
45598: LD_INT 0
45600: PUSH
45601: LD_INT 1
45603: NEG
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: LD_INT 1
45611: PUSH
45612: LD_INT 0
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 1
45621: PUSH
45622: LD_INT 1
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 0
45631: PUSH
45632: LD_INT 1
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 1
45641: NEG
45642: PUSH
45643: LD_INT 0
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: LD_INT 1
45652: NEG
45653: PUSH
45654: LD_INT 1
45656: NEG
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45671: LD_ADDR_VAR 0 62
45675: PUSH
45676: LD_INT 0
45678: PUSH
45679: LD_INT 0
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: LD_INT 1
45691: NEG
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 1
45699: PUSH
45700: LD_INT 0
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 1
45709: PUSH
45710: LD_INT 1
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 0
45719: PUSH
45720: LD_INT 1
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 1
45729: NEG
45730: PUSH
45731: LD_INT 0
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 1
45740: NEG
45741: PUSH
45742: LD_INT 1
45744: NEG
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45759: LD_ADDR_VAR 0 63
45763: PUSH
45764: LD_INT 0
45766: PUSH
45767: LD_INT 0
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: LD_INT 0
45776: PUSH
45777: LD_INT 1
45779: NEG
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 1
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: LD_INT 1
45797: PUSH
45798: LD_INT 1
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 0
45807: PUSH
45808: LD_INT 1
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 1
45817: NEG
45818: PUSH
45819: LD_INT 0
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 1
45828: NEG
45829: PUSH
45830: LD_INT 1
45832: NEG
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: EMPTY
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45847: LD_ADDR_VAR 0 64
45851: PUSH
45852: LD_INT 0
45854: PUSH
45855: LD_INT 0
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 0
45864: PUSH
45865: LD_INT 1
45867: NEG
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: LD_INT 1
45875: PUSH
45876: LD_INT 0
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 1
45885: PUSH
45886: LD_INT 1
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PUSH
45893: LD_INT 0
45895: PUSH
45896: LD_INT 1
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 1
45905: NEG
45906: PUSH
45907: LD_INT 0
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 1
45916: NEG
45917: PUSH
45918: LD_INT 1
45920: NEG
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: LIST
45930: LIST
45931: LIST
45932: LIST
45933: LIST
45934: ST_TO_ADDR
// end ; 1 :
45935: GO 51832
45937: LD_INT 1
45939: DOUBLE
45940: EQUAL
45941: IFTRUE 45945
45943: GO 48568
45945: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45946: LD_ADDR_VAR 0 11
45950: PUSH
45951: LD_INT 1
45953: NEG
45954: PUSH
45955: LD_INT 3
45957: NEG
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: PUSH
45963: LD_INT 0
45965: PUSH
45966: LD_INT 3
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: LD_INT 1
45976: PUSH
45977: LD_INT 2
45979: NEG
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: LIST
45989: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45990: LD_ADDR_VAR 0 12
45994: PUSH
45995: LD_INT 2
45997: PUSH
45998: LD_INT 1
46000: NEG
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 3
46008: PUSH
46009: LD_INT 0
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 3
46018: PUSH
46019: LD_INT 1
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: LIST
46030: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46031: LD_ADDR_VAR 0 13
46035: PUSH
46036: LD_INT 3
46038: PUSH
46039: LD_INT 2
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: LD_INT 3
46048: PUSH
46049: LD_INT 3
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 2
46058: PUSH
46059: LD_INT 3
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: LIST
46070: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46071: LD_ADDR_VAR 0 14
46075: PUSH
46076: LD_INT 1
46078: PUSH
46079: LD_INT 3
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: PUSH
46086: LD_INT 0
46088: PUSH
46089: LD_INT 3
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 1
46098: NEG
46099: PUSH
46100: LD_INT 2
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: LIST
46111: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46112: LD_ADDR_VAR 0 15
46116: PUSH
46117: LD_INT 2
46119: NEG
46120: PUSH
46121: LD_INT 1
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 3
46130: NEG
46131: PUSH
46132: LD_INT 0
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 3
46141: NEG
46142: PUSH
46143: LD_INT 1
46145: NEG
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: LIST
46155: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46156: LD_ADDR_VAR 0 16
46160: PUSH
46161: LD_INT 2
46163: NEG
46164: PUSH
46165: LD_INT 3
46167: NEG
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: PUSH
46173: LD_INT 3
46175: NEG
46176: PUSH
46177: LD_INT 2
46179: NEG
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 3
46187: NEG
46188: PUSH
46189: LD_INT 3
46191: NEG
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: LIST
46201: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46202: LD_ADDR_VAR 0 17
46206: PUSH
46207: LD_INT 1
46209: NEG
46210: PUSH
46211: LD_INT 3
46213: NEG
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 0
46221: PUSH
46222: LD_INT 3
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 1
46232: PUSH
46233: LD_INT 2
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: LIST
46245: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46246: LD_ADDR_VAR 0 18
46250: PUSH
46251: LD_INT 2
46253: PUSH
46254: LD_INT 1
46256: NEG
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 3
46264: PUSH
46265: LD_INT 0
46267: PUSH
46268: EMPTY
46269: LIST
46270: LIST
46271: PUSH
46272: LD_INT 3
46274: PUSH
46275: LD_INT 1
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: LIST
46286: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46287: LD_ADDR_VAR 0 19
46291: PUSH
46292: LD_INT 3
46294: PUSH
46295: LD_INT 2
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: PUSH
46302: LD_INT 3
46304: PUSH
46305: LD_INT 3
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PUSH
46312: LD_INT 2
46314: PUSH
46315: LD_INT 3
46317: PUSH
46318: EMPTY
46319: LIST
46320: LIST
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: LIST
46326: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46327: LD_ADDR_VAR 0 20
46331: PUSH
46332: LD_INT 1
46334: PUSH
46335: LD_INT 3
46337: PUSH
46338: EMPTY
46339: LIST
46340: LIST
46341: PUSH
46342: LD_INT 0
46344: PUSH
46345: LD_INT 3
46347: PUSH
46348: EMPTY
46349: LIST
46350: LIST
46351: PUSH
46352: LD_INT 1
46354: NEG
46355: PUSH
46356: LD_INT 2
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: LIST
46367: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46368: LD_ADDR_VAR 0 21
46372: PUSH
46373: LD_INT 2
46375: NEG
46376: PUSH
46377: LD_INT 1
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 3
46386: NEG
46387: PUSH
46388: LD_INT 0
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 3
46397: NEG
46398: PUSH
46399: LD_INT 1
46401: NEG
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: LIST
46411: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46412: LD_ADDR_VAR 0 22
46416: PUSH
46417: LD_INT 2
46419: NEG
46420: PUSH
46421: LD_INT 3
46423: NEG
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 3
46431: NEG
46432: PUSH
46433: LD_INT 2
46435: NEG
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 3
46443: NEG
46444: PUSH
46445: LD_INT 3
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: LIST
46457: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46458: LD_ADDR_VAR 0 23
46462: PUSH
46463: LD_INT 0
46465: PUSH
46466: LD_INT 3
46468: NEG
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 1
46476: NEG
46477: PUSH
46478: LD_INT 4
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 1
46488: PUSH
46489: LD_INT 3
46491: NEG
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: LIST
46501: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46502: LD_ADDR_VAR 0 24
46506: PUSH
46507: LD_INT 3
46509: PUSH
46510: LD_INT 0
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: PUSH
46517: LD_INT 3
46519: PUSH
46520: LD_INT 1
46522: NEG
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: PUSH
46528: LD_INT 4
46530: PUSH
46531: LD_INT 1
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: LIST
46542: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46543: LD_ADDR_VAR 0 25
46547: PUSH
46548: LD_INT 3
46550: PUSH
46551: LD_INT 3
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 4
46560: PUSH
46561: LD_INT 3
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 3
46570: PUSH
46571: LD_INT 4
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: LIST
46582: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46583: LD_ADDR_VAR 0 26
46587: PUSH
46588: LD_INT 0
46590: PUSH
46591: LD_INT 3
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 1
46600: PUSH
46601: LD_INT 4
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 1
46610: NEG
46611: PUSH
46612: LD_INT 3
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: LIST
46623: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46624: LD_ADDR_VAR 0 27
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: LD_INT 0
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 3
46642: NEG
46643: PUSH
46644: LD_INT 1
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 4
46653: NEG
46654: PUSH
46655: LD_INT 1
46657: NEG
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: LIST
46667: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46668: LD_ADDR_VAR 0 28
46672: PUSH
46673: LD_INT 3
46675: NEG
46676: PUSH
46677: LD_INT 3
46679: NEG
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: PUSH
46685: LD_INT 3
46687: NEG
46688: PUSH
46689: LD_INT 4
46691: NEG
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: LD_INT 4
46699: NEG
46700: PUSH
46701: LD_INT 3
46703: NEG
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: LIST
46713: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46714: LD_ADDR_VAR 0 29
46718: PUSH
46719: LD_INT 1
46721: NEG
46722: PUSH
46723: LD_INT 3
46725: NEG
46726: PUSH
46727: EMPTY
46728: LIST
46729: LIST
46730: PUSH
46731: LD_INT 0
46733: PUSH
46734: LD_INT 3
46736: NEG
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: LD_INT 1
46744: PUSH
46745: LD_INT 2
46747: NEG
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: LD_INT 1
46755: NEG
46756: PUSH
46757: LD_INT 4
46759: NEG
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: PUSH
46765: LD_INT 0
46767: PUSH
46768: LD_INT 4
46770: NEG
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 1
46778: PUSH
46779: LD_INT 3
46781: NEG
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PUSH
46787: LD_INT 1
46789: NEG
46790: PUSH
46791: LD_INT 5
46793: NEG
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 0
46801: PUSH
46802: LD_INT 5
46804: NEG
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: PUSH
46810: LD_INT 1
46812: PUSH
46813: LD_INT 4
46815: NEG
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: LD_INT 1
46823: NEG
46824: PUSH
46825: LD_INT 6
46827: NEG
46828: PUSH
46829: EMPTY
46830: LIST
46831: LIST
46832: PUSH
46833: LD_INT 0
46835: PUSH
46836: LD_INT 6
46838: NEG
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: PUSH
46844: LD_INT 1
46846: PUSH
46847: LD_INT 5
46849: NEG
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: LIST
46864: LIST
46865: LIST
46866: LIST
46867: LIST
46868: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46869: LD_ADDR_VAR 0 30
46873: PUSH
46874: LD_INT 2
46876: PUSH
46877: LD_INT 1
46879: NEG
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: PUSH
46885: LD_INT 3
46887: PUSH
46888: LD_INT 0
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: LD_INT 3
46897: PUSH
46898: LD_INT 1
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: PUSH
46905: LD_INT 3
46907: PUSH
46908: LD_INT 1
46910: NEG
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: PUSH
46916: LD_INT 4
46918: PUSH
46919: LD_INT 0
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_INT 4
46928: PUSH
46929: LD_INT 1
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: LD_INT 4
46938: PUSH
46939: LD_INT 1
46941: NEG
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: PUSH
46947: LD_INT 5
46949: PUSH
46950: LD_INT 0
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 5
46959: PUSH
46960: LD_INT 1
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 5
46969: PUSH
46970: LD_INT 1
46972: NEG
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: PUSH
46978: LD_INT 6
46980: PUSH
46981: LD_INT 0
46983: PUSH
46984: EMPTY
46985: LIST
46986: LIST
46987: PUSH
46988: LD_INT 6
46990: PUSH
46991: LD_INT 1
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
47012: LD_ADDR_VAR 0 31
47016: PUSH
47017: LD_INT 3
47019: PUSH
47020: LD_INT 2
47022: PUSH
47023: EMPTY
47024: LIST
47025: LIST
47026: PUSH
47027: LD_INT 3
47029: PUSH
47030: LD_INT 3
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PUSH
47037: LD_INT 2
47039: PUSH
47040: LD_INT 3
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: PUSH
47047: LD_INT 4
47049: PUSH
47050: LD_INT 3
47052: PUSH
47053: EMPTY
47054: LIST
47055: LIST
47056: PUSH
47057: LD_INT 4
47059: PUSH
47060: LD_INT 4
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 3
47069: PUSH
47070: LD_INT 4
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: PUSH
47077: LD_INT 5
47079: PUSH
47080: LD_INT 4
47082: PUSH
47083: EMPTY
47084: LIST
47085: LIST
47086: PUSH
47087: LD_INT 5
47089: PUSH
47090: LD_INT 5
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: LD_INT 4
47099: PUSH
47100: LD_INT 5
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PUSH
47107: LD_INT 6
47109: PUSH
47110: LD_INT 5
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 6
47119: PUSH
47120: LD_INT 6
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: LD_INT 5
47129: PUSH
47130: LD_INT 6
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
47151: LD_ADDR_VAR 0 32
47155: PUSH
47156: LD_INT 1
47158: PUSH
47159: LD_INT 3
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 0
47168: PUSH
47169: LD_INT 3
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 1
47178: NEG
47179: PUSH
47180: LD_INT 2
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: PUSH
47187: LD_INT 1
47189: PUSH
47190: LD_INT 4
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 0
47199: PUSH
47200: LD_INT 4
47202: PUSH
47203: EMPTY
47204: LIST
47205: LIST
47206: PUSH
47207: LD_INT 1
47209: NEG
47210: PUSH
47211: LD_INT 3
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 1
47220: PUSH
47221: LD_INT 5
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 0
47230: PUSH
47231: LD_INT 5
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 1
47240: NEG
47241: PUSH
47242: LD_INT 4
47244: PUSH
47245: EMPTY
47246: LIST
47247: LIST
47248: PUSH
47249: LD_INT 1
47251: PUSH
47252: LD_INT 6
47254: PUSH
47255: EMPTY
47256: LIST
47257: LIST
47258: PUSH
47259: LD_INT 0
47261: PUSH
47262: LD_INT 6
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: LD_INT 5
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47294: LD_ADDR_VAR 0 33
47298: PUSH
47299: LD_INT 2
47301: NEG
47302: PUSH
47303: LD_INT 1
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: PUSH
47310: LD_INT 3
47312: NEG
47313: PUSH
47314: LD_INT 0
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: PUSH
47321: LD_INT 3
47323: NEG
47324: PUSH
47325: LD_INT 1
47327: NEG
47328: PUSH
47329: EMPTY
47330: LIST
47331: LIST
47332: PUSH
47333: LD_INT 3
47335: NEG
47336: PUSH
47337: LD_INT 1
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PUSH
47344: LD_INT 4
47346: NEG
47347: PUSH
47348: LD_INT 0
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 4
47357: NEG
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 4
47369: NEG
47370: PUSH
47371: LD_INT 1
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: LD_INT 5
47380: NEG
47381: PUSH
47382: LD_INT 0
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 5
47391: NEG
47392: PUSH
47393: LD_INT 1
47395: NEG
47396: PUSH
47397: EMPTY
47398: LIST
47399: LIST
47400: PUSH
47401: LD_INT 5
47403: NEG
47404: PUSH
47405: LD_INT 1
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: PUSH
47412: LD_INT 6
47414: NEG
47415: PUSH
47416: LD_INT 0
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: PUSH
47423: LD_INT 6
47425: NEG
47426: PUSH
47427: LD_INT 1
47429: NEG
47430: PUSH
47431: EMPTY
47432: LIST
47433: LIST
47434: PUSH
47435: EMPTY
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47449: LD_ADDR_VAR 0 34
47453: PUSH
47454: LD_INT 2
47456: NEG
47457: PUSH
47458: LD_INT 3
47460: NEG
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: PUSH
47466: LD_INT 3
47468: NEG
47469: PUSH
47470: LD_INT 2
47472: NEG
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 3
47480: NEG
47481: PUSH
47482: LD_INT 3
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 3
47492: NEG
47493: PUSH
47494: LD_INT 4
47496: NEG
47497: PUSH
47498: EMPTY
47499: LIST
47500: LIST
47501: PUSH
47502: LD_INT 4
47504: NEG
47505: PUSH
47506: LD_INT 3
47508: NEG
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: PUSH
47514: LD_INT 4
47516: NEG
47517: PUSH
47518: LD_INT 4
47520: NEG
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: PUSH
47526: LD_INT 4
47528: NEG
47529: PUSH
47530: LD_INT 5
47532: NEG
47533: PUSH
47534: EMPTY
47535: LIST
47536: LIST
47537: PUSH
47538: LD_INT 5
47540: NEG
47541: PUSH
47542: LD_INT 4
47544: NEG
47545: PUSH
47546: EMPTY
47547: LIST
47548: LIST
47549: PUSH
47550: LD_INT 5
47552: NEG
47553: PUSH
47554: LD_INT 5
47556: NEG
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PUSH
47562: LD_INT 5
47564: NEG
47565: PUSH
47566: LD_INT 6
47568: NEG
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: PUSH
47574: LD_INT 6
47576: NEG
47577: PUSH
47578: LD_INT 5
47580: NEG
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: PUSH
47586: LD_INT 6
47588: NEG
47589: PUSH
47590: LD_INT 6
47592: NEG
47593: PUSH
47594: EMPTY
47595: LIST
47596: LIST
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47612: LD_ADDR_VAR 0 41
47616: PUSH
47617: LD_INT 0
47619: PUSH
47620: LD_INT 2
47622: NEG
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: PUSH
47628: LD_INT 1
47630: NEG
47631: PUSH
47632: LD_INT 3
47634: NEG
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: LD_INT 1
47642: PUSH
47643: LD_INT 2
47645: NEG
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: EMPTY
47652: LIST
47653: LIST
47654: LIST
47655: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47656: LD_ADDR_VAR 0 42
47660: PUSH
47661: LD_INT 2
47663: PUSH
47664: LD_INT 0
47666: PUSH
47667: EMPTY
47668: LIST
47669: LIST
47670: PUSH
47671: LD_INT 2
47673: PUSH
47674: LD_INT 1
47676: NEG
47677: PUSH
47678: EMPTY
47679: LIST
47680: LIST
47681: PUSH
47682: LD_INT 3
47684: PUSH
47685: LD_INT 1
47687: PUSH
47688: EMPTY
47689: LIST
47690: LIST
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: LIST
47696: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47697: LD_ADDR_VAR 0 43
47701: PUSH
47702: LD_INT 2
47704: PUSH
47705: LD_INT 2
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PUSH
47712: LD_INT 3
47714: PUSH
47715: LD_INT 2
47717: PUSH
47718: EMPTY
47719: LIST
47720: LIST
47721: PUSH
47722: LD_INT 2
47724: PUSH
47725: LD_INT 3
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: EMPTY
47733: LIST
47734: LIST
47735: LIST
47736: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47737: LD_ADDR_VAR 0 44
47741: PUSH
47742: LD_INT 0
47744: PUSH
47745: LD_INT 2
47747: PUSH
47748: EMPTY
47749: LIST
47750: LIST
47751: PUSH
47752: LD_INT 1
47754: PUSH
47755: LD_INT 3
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 1
47764: NEG
47765: PUSH
47766: LD_INT 2
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: LIST
47777: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47778: LD_ADDR_VAR 0 45
47782: PUSH
47783: LD_INT 2
47785: NEG
47786: PUSH
47787: LD_INT 0
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: PUSH
47794: LD_INT 2
47796: NEG
47797: PUSH
47798: LD_INT 1
47800: PUSH
47801: EMPTY
47802: LIST
47803: LIST
47804: PUSH
47805: LD_INT 3
47807: NEG
47808: PUSH
47809: LD_INT 1
47811: NEG
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: EMPTY
47818: LIST
47819: LIST
47820: LIST
47821: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47822: LD_ADDR_VAR 0 46
47826: PUSH
47827: LD_INT 2
47829: NEG
47830: PUSH
47831: LD_INT 2
47833: NEG
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PUSH
47839: LD_INT 2
47841: NEG
47842: PUSH
47843: LD_INT 3
47845: NEG
47846: PUSH
47847: EMPTY
47848: LIST
47849: LIST
47850: PUSH
47851: LD_INT 3
47853: NEG
47854: PUSH
47855: LD_INT 2
47857: NEG
47858: PUSH
47859: EMPTY
47860: LIST
47861: LIST
47862: PUSH
47863: EMPTY
47864: LIST
47865: LIST
47866: LIST
47867: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47868: LD_ADDR_VAR 0 47
47872: PUSH
47873: LD_INT 2
47875: NEG
47876: PUSH
47877: LD_INT 3
47879: NEG
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 1
47887: NEG
47888: PUSH
47889: LD_INT 3
47891: NEG
47892: PUSH
47893: EMPTY
47894: LIST
47895: LIST
47896: PUSH
47897: EMPTY
47898: LIST
47899: LIST
47900: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47901: LD_ADDR_VAR 0 48
47905: PUSH
47906: LD_INT 1
47908: PUSH
47909: LD_INT 2
47911: NEG
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: PUSH
47917: LD_INT 2
47919: PUSH
47920: LD_INT 1
47922: NEG
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47932: LD_ADDR_VAR 0 49
47936: PUSH
47937: LD_INT 3
47939: PUSH
47940: LD_INT 1
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 2
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47961: LD_ADDR_VAR 0 50
47965: PUSH
47966: LD_INT 2
47968: PUSH
47969: LD_INT 3
47971: PUSH
47972: EMPTY
47973: LIST
47974: LIST
47975: PUSH
47976: LD_INT 1
47978: PUSH
47979: LD_INT 3
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47990: LD_ADDR_VAR 0 51
47994: PUSH
47995: LD_INT 1
47997: NEG
47998: PUSH
47999: LD_INT 2
48001: PUSH
48002: EMPTY
48003: LIST
48004: LIST
48005: PUSH
48006: LD_INT 2
48008: NEG
48009: PUSH
48010: LD_INT 1
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
48021: LD_ADDR_VAR 0 52
48025: PUSH
48026: LD_INT 3
48028: NEG
48029: PUSH
48030: LD_INT 1
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 3
48040: NEG
48041: PUSH
48042: LD_INT 2
48044: NEG
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
48054: LD_ADDR_VAR 0 53
48058: PUSH
48059: LD_INT 1
48061: NEG
48062: PUSH
48063: LD_INT 3
48065: NEG
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: PUSH
48071: LD_INT 0
48073: PUSH
48074: LD_INT 3
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: LD_INT 1
48084: PUSH
48085: LD_INT 2
48087: NEG
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: EMPTY
48094: LIST
48095: LIST
48096: LIST
48097: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
48098: LD_ADDR_VAR 0 54
48102: PUSH
48103: LD_INT 2
48105: PUSH
48106: LD_INT 1
48108: NEG
48109: PUSH
48110: EMPTY
48111: LIST
48112: LIST
48113: PUSH
48114: LD_INT 3
48116: PUSH
48117: LD_INT 0
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: PUSH
48124: LD_INT 3
48126: PUSH
48127: LD_INT 1
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: LIST
48138: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
48139: LD_ADDR_VAR 0 55
48143: PUSH
48144: LD_INT 3
48146: PUSH
48147: LD_INT 2
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_INT 3
48156: PUSH
48157: LD_INT 3
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: PUSH
48164: LD_INT 2
48166: PUSH
48167: LD_INT 3
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: LIST
48178: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48179: LD_ADDR_VAR 0 56
48183: PUSH
48184: LD_INT 1
48186: PUSH
48187: LD_INT 3
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 0
48196: PUSH
48197: LD_INT 3
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: PUSH
48204: LD_INT 1
48206: NEG
48207: PUSH
48208: LD_INT 2
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: LIST
48219: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48220: LD_ADDR_VAR 0 57
48224: PUSH
48225: LD_INT 2
48227: NEG
48228: PUSH
48229: LD_INT 1
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_INT 3
48238: NEG
48239: PUSH
48240: LD_INT 0
48242: PUSH
48243: EMPTY
48244: LIST
48245: LIST
48246: PUSH
48247: LD_INT 3
48249: NEG
48250: PUSH
48251: LD_INT 1
48253: NEG
48254: PUSH
48255: EMPTY
48256: LIST
48257: LIST
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: LIST
48263: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48264: LD_ADDR_VAR 0 58
48268: PUSH
48269: LD_INT 2
48271: NEG
48272: PUSH
48273: LD_INT 3
48275: NEG
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PUSH
48281: LD_INT 3
48283: NEG
48284: PUSH
48285: LD_INT 2
48287: NEG
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PUSH
48293: LD_INT 3
48295: NEG
48296: PUSH
48297: LD_INT 3
48299: NEG
48300: PUSH
48301: EMPTY
48302: LIST
48303: LIST
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: LIST
48309: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48310: LD_ADDR_VAR 0 59
48314: PUSH
48315: LD_INT 1
48317: NEG
48318: PUSH
48319: LD_INT 2
48321: NEG
48322: PUSH
48323: EMPTY
48324: LIST
48325: LIST
48326: PUSH
48327: LD_INT 0
48329: PUSH
48330: LD_INT 2
48332: NEG
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PUSH
48338: LD_INT 1
48340: PUSH
48341: LD_INT 1
48343: NEG
48344: PUSH
48345: EMPTY
48346: LIST
48347: LIST
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: LIST
48353: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48354: LD_ADDR_VAR 0 60
48358: PUSH
48359: LD_INT 1
48361: PUSH
48362: LD_INT 1
48364: NEG
48365: PUSH
48366: EMPTY
48367: LIST
48368: LIST
48369: PUSH
48370: LD_INT 2
48372: PUSH
48373: LD_INT 0
48375: PUSH
48376: EMPTY
48377: LIST
48378: LIST
48379: PUSH
48380: LD_INT 2
48382: PUSH
48383: LD_INT 1
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: LIST
48394: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48395: LD_ADDR_VAR 0 61
48399: PUSH
48400: LD_INT 2
48402: PUSH
48403: LD_INT 1
48405: PUSH
48406: EMPTY
48407: LIST
48408: LIST
48409: PUSH
48410: LD_INT 2
48412: PUSH
48413: LD_INT 2
48415: PUSH
48416: EMPTY
48417: LIST
48418: LIST
48419: PUSH
48420: LD_INT 1
48422: PUSH
48423: LD_INT 2
48425: PUSH
48426: EMPTY
48427: LIST
48428: LIST
48429: PUSH
48430: EMPTY
48431: LIST
48432: LIST
48433: LIST
48434: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48435: LD_ADDR_VAR 0 62
48439: PUSH
48440: LD_INT 1
48442: PUSH
48443: LD_INT 2
48445: PUSH
48446: EMPTY
48447: LIST
48448: LIST
48449: PUSH
48450: LD_INT 0
48452: PUSH
48453: LD_INT 2
48455: PUSH
48456: EMPTY
48457: LIST
48458: LIST
48459: PUSH
48460: LD_INT 1
48462: NEG
48463: PUSH
48464: LD_INT 1
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: LIST
48475: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48476: LD_ADDR_VAR 0 63
48480: PUSH
48481: LD_INT 1
48483: NEG
48484: PUSH
48485: LD_INT 1
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: LD_INT 2
48494: NEG
48495: PUSH
48496: LD_INT 0
48498: PUSH
48499: EMPTY
48500: LIST
48501: LIST
48502: PUSH
48503: LD_INT 2
48505: NEG
48506: PUSH
48507: LD_INT 1
48509: NEG
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: LIST
48519: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48520: LD_ADDR_VAR 0 64
48524: PUSH
48525: LD_INT 1
48527: NEG
48528: PUSH
48529: LD_INT 2
48531: NEG
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: LD_INT 2
48539: NEG
48540: PUSH
48541: LD_INT 1
48543: NEG
48544: PUSH
48545: EMPTY
48546: LIST
48547: LIST
48548: PUSH
48549: LD_INT 2
48551: NEG
48552: PUSH
48553: LD_INT 2
48555: NEG
48556: PUSH
48557: EMPTY
48558: LIST
48559: LIST
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: LIST
48565: ST_TO_ADDR
// end ; 2 :
48566: GO 51832
48568: LD_INT 2
48570: DOUBLE
48571: EQUAL
48572: IFTRUE 48576
48574: GO 51831
48576: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48577: LD_ADDR_VAR 0 29
48581: PUSH
48582: LD_INT 4
48584: PUSH
48585: LD_INT 0
48587: PUSH
48588: EMPTY
48589: LIST
48590: LIST
48591: PUSH
48592: LD_INT 4
48594: PUSH
48595: LD_INT 1
48597: NEG
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: LD_INT 5
48605: PUSH
48606: LD_INT 0
48608: PUSH
48609: EMPTY
48610: LIST
48611: LIST
48612: PUSH
48613: LD_INT 5
48615: PUSH
48616: LD_INT 1
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: LD_INT 4
48625: PUSH
48626: LD_INT 1
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: LD_INT 3
48635: PUSH
48636: LD_INT 0
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: LD_INT 3
48645: PUSH
48646: LD_INT 1
48648: NEG
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PUSH
48654: LD_INT 3
48656: PUSH
48657: LD_INT 2
48659: NEG
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PUSH
48665: LD_INT 5
48667: PUSH
48668: LD_INT 2
48670: PUSH
48671: EMPTY
48672: LIST
48673: LIST
48674: PUSH
48675: LD_INT 3
48677: PUSH
48678: LD_INT 3
48680: PUSH
48681: EMPTY
48682: LIST
48683: LIST
48684: PUSH
48685: LD_INT 3
48687: PUSH
48688: LD_INT 2
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 4
48697: PUSH
48698: LD_INT 3
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PUSH
48705: LD_INT 4
48707: PUSH
48708: LD_INT 4
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 3
48717: PUSH
48718: LD_INT 4
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 2
48727: PUSH
48728: LD_INT 3
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 2
48737: PUSH
48738: LD_INT 2
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PUSH
48745: LD_INT 4
48747: PUSH
48748: LD_INT 2
48750: PUSH
48751: EMPTY
48752: LIST
48753: LIST
48754: PUSH
48755: LD_INT 2
48757: PUSH
48758: LD_INT 4
48760: PUSH
48761: EMPTY
48762: LIST
48763: LIST
48764: PUSH
48765: LD_INT 0
48767: PUSH
48768: LD_INT 4
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: PUSH
48775: LD_INT 0
48777: PUSH
48778: LD_INT 3
48780: PUSH
48781: EMPTY
48782: LIST
48783: LIST
48784: PUSH
48785: LD_INT 1
48787: PUSH
48788: LD_INT 4
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 1
48797: PUSH
48798: LD_INT 5
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PUSH
48805: LD_INT 0
48807: PUSH
48808: LD_INT 5
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: PUSH
48815: LD_INT 1
48817: NEG
48818: PUSH
48819: LD_INT 4
48821: PUSH
48822: EMPTY
48823: LIST
48824: LIST
48825: PUSH
48826: LD_INT 1
48828: NEG
48829: PUSH
48830: LD_INT 3
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: PUSH
48837: LD_INT 2
48839: PUSH
48840: LD_INT 5
48842: PUSH
48843: EMPTY
48844: LIST
48845: LIST
48846: PUSH
48847: LD_INT 2
48849: NEG
48850: PUSH
48851: LD_INT 3
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PUSH
48858: LD_INT 3
48860: NEG
48861: PUSH
48862: LD_INT 0
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: PUSH
48869: LD_INT 3
48871: NEG
48872: PUSH
48873: LD_INT 1
48875: NEG
48876: PUSH
48877: EMPTY
48878: LIST
48879: LIST
48880: PUSH
48881: LD_INT 2
48883: NEG
48884: PUSH
48885: LD_INT 0
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 2
48894: NEG
48895: PUSH
48896: LD_INT 1
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: PUSH
48903: LD_INT 3
48905: NEG
48906: PUSH
48907: LD_INT 1
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: PUSH
48914: LD_INT 4
48916: NEG
48917: PUSH
48918: LD_INT 0
48920: PUSH
48921: EMPTY
48922: LIST
48923: LIST
48924: PUSH
48925: LD_INT 4
48927: NEG
48928: PUSH
48929: LD_INT 1
48931: NEG
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PUSH
48937: LD_INT 4
48939: NEG
48940: PUSH
48941: LD_INT 2
48943: NEG
48944: PUSH
48945: EMPTY
48946: LIST
48947: LIST
48948: PUSH
48949: LD_INT 2
48951: NEG
48952: PUSH
48953: LD_INT 2
48955: PUSH
48956: EMPTY
48957: LIST
48958: LIST
48959: PUSH
48960: LD_INT 4
48962: NEG
48963: PUSH
48964: LD_INT 4
48966: NEG
48967: PUSH
48968: EMPTY
48969: LIST
48970: LIST
48971: PUSH
48972: LD_INT 4
48974: NEG
48975: PUSH
48976: LD_INT 5
48978: NEG
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: PUSH
48984: LD_INT 3
48986: NEG
48987: PUSH
48988: LD_INT 4
48990: NEG
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: PUSH
48996: LD_INT 3
48998: NEG
48999: PUSH
49000: LD_INT 3
49002: NEG
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PUSH
49008: LD_INT 4
49010: NEG
49011: PUSH
49012: LD_INT 3
49014: NEG
49015: PUSH
49016: EMPTY
49017: LIST
49018: LIST
49019: PUSH
49020: LD_INT 5
49022: NEG
49023: PUSH
49024: LD_INT 4
49026: NEG
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 5
49034: NEG
49035: PUSH
49036: LD_INT 5
49038: NEG
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 3
49046: NEG
49047: PUSH
49048: LD_INT 5
49050: NEG
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 5
49058: NEG
49059: PUSH
49060: LD_INT 3
49062: NEG
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: PUSH
49068: EMPTY
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
49115: LD_ADDR_VAR 0 30
49119: PUSH
49120: LD_INT 4
49122: PUSH
49123: LD_INT 4
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PUSH
49130: LD_INT 4
49132: PUSH
49133: LD_INT 3
49135: PUSH
49136: EMPTY
49137: LIST
49138: LIST
49139: PUSH
49140: LD_INT 5
49142: PUSH
49143: LD_INT 4
49145: PUSH
49146: EMPTY
49147: LIST
49148: LIST
49149: PUSH
49150: LD_INT 5
49152: PUSH
49153: LD_INT 5
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PUSH
49160: LD_INT 4
49162: PUSH
49163: LD_INT 5
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PUSH
49170: LD_INT 3
49172: PUSH
49173: LD_INT 4
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: PUSH
49180: LD_INT 3
49182: PUSH
49183: LD_INT 3
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 5
49192: PUSH
49193: LD_INT 3
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PUSH
49200: LD_INT 3
49202: PUSH
49203: LD_INT 5
49205: PUSH
49206: EMPTY
49207: LIST
49208: LIST
49209: PUSH
49210: LD_INT 0
49212: PUSH
49213: LD_INT 3
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: PUSH
49220: LD_INT 0
49222: PUSH
49223: LD_INT 2
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: PUSH
49230: LD_INT 1
49232: PUSH
49233: LD_INT 3
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 1
49242: PUSH
49243: LD_INT 4
49245: PUSH
49246: EMPTY
49247: LIST
49248: LIST
49249: PUSH
49250: LD_INT 0
49252: PUSH
49253: LD_INT 4
49255: PUSH
49256: EMPTY
49257: LIST
49258: LIST
49259: PUSH
49260: LD_INT 1
49262: NEG
49263: PUSH
49264: LD_INT 3
49266: PUSH
49267: EMPTY
49268: LIST
49269: LIST
49270: PUSH
49271: LD_INT 1
49273: NEG
49274: PUSH
49275: LD_INT 2
49277: PUSH
49278: EMPTY
49279: LIST
49280: LIST
49281: PUSH
49282: LD_INT 2
49284: PUSH
49285: LD_INT 4
49287: PUSH
49288: EMPTY
49289: LIST
49290: LIST
49291: PUSH
49292: LD_INT 2
49294: NEG
49295: PUSH
49296: LD_INT 2
49298: PUSH
49299: EMPTY
49300: LIST
49301: LIST
49302: PUSH
49303: LD_INT 4
49305: NEG
49306: PUSH
49307: LD_INT 0
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 4
49316: NEG
49317: PUSH
49318: LD_INT 1
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 3
49328: NEG
49329: PUSH
49330: LD_INT 0
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 3
49339: NEG
49340: PUSH
49341: LD_INT 1
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PUSH
49348: LD_INT 4
49350: NEG
49351: PUSH
49352: LD_INT 1
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PUSH
49359: LD_INT 5
49361: NEG
49362: PUSH
49363: LD_INT 0
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: PUSH
49370: LD_INT 5
49372: NEG
49373: PUSH
49374: LD_INT 1
49376: NEG
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 5
49384: NEG
49385: PUSH
49386: LD_INT 2
49388: NEG
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 3
49396: NEG
49397: PUSH
49398: LD_INT 2
49400: PUSH
49401: EMPTY
49402: LIST
49403: LIST
49404: PUSH
49405: LD_INT 3
49407: NEG
49408: PUSH
49409: LD_INT 3
49411: NEG
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: PUSH
49417: LD_INT 3
49419: NEG
49420: PUSH
49421: LD_INT 4
49423: NEG
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: PUSH
49429: LD_INT 2
49431: NEG
49432: PUSH
49433: LD_INT 3
49435: NEG
49436: PUSH
49437: EMPTY
49438: LIST
49439: LIST
49440: PUSH
49441: LD_INT 2
49443: NEG
49444: PUSH
49445: LD_INT 2
49447: NEG
49448: PUSH
49449: EMPTY
49450: LIST
49451: LIST
49452: PUSH
49453: LD_INT 3
49455: NEG
49456: PUSH
49457: LD_INT 2
49459: NEG
49460: PUSH
49461: EMPTY
49462: LIST
49463: LIST
49464: PUSH
49465: LD_INT 4
49467: NEG
49468: PUSH
49469: LD_INT 3
49471: NEG
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: PUSH
49477: LD_INT 4
49479: NEG
49480: PUSH
49481: LD_INT 4
49483: NEG
49484: PUSH
49485: EMPTY
49486: LIST
49487: LIST
49488: PUSH
49489: LD_INT 2
49491: NEG
49492: PUSH
49493: LD_INT 4
49495: NEG
49496: PUSH
49497: EMPTY
49498: LIST
49499: LIST
49500: PUSH
49501: LD_INT 4
49503: NEG
49504: PUSH
49505: LD_INT 2
49507: NEG
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: LD_INT 0
49515: PUSH
49516: LD_INT 4
49518: NEG
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 0
49526: PUSH
49527: LD_INT 5
49529: NEG
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PUSH
49535: LD_INT 1
49537: PUSH
49538: LD_INT 4
49540: NEG
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: LD_INT 1
49548: PUSH
49549: LD_INT 3
49551: NEG
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PUSH
49557: LD_INT 0
49559: PUSH
49560: LD_INT 3
49562: NEG
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 1
49570: NEG
49571: PUSH
49572: LD_INT 4
49574: NEG
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: PUSH
49580: LD_INT 1
49582: NEG
49583: PUSH
49584: LD_INT 5
49586: NEG
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: PUSH
49592: LD_INT 2
49594: PUSH
49595: LD_INT 3
49597: NEG
49598: PUSH
49599: EMPTY
49600: LIST
49601: LIST
49602: PUSH
49603: LD_INT 2
49605: NEG
49606: PUSH
49607: LD_INT 5
49609: NEG
49610: PUSH
49611: EMPTY
49612: LIST
49613: LIST
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: LIST
49647: LIST
49648: LIST
49649: LIST
49650: LIST
49651: LIST
49652: LIST
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: LIST
49659: LIST
49660: LIST
49661: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49662: LD_ADDR_VAR 0 31
49666: PUSH
49667: LD_INT 0
49669: PUSH
49670: LD_INT 4
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PUSH
49677: LD_INT 0
49679: PUSH
49680: LD_INT 3
49682: PUSH
49683: EMPTY
49684: LIST
49685: LIST
49686: PUSH
49687: LD_INT 1
49689: PUSH
49690: LD_INT 4
49692: PUSH
49693: EMPTY
49694: LIST
49695: LIST
49696: PUSH
49697: LD_INT 1
49699: PUSH
49700: LD_INT 5
49702: PUSH
49703: EMPTY
49704: LIST
49705: LIST
49706: PUSH
49707: LD_INT 0
49709: PUSH
49710: LD_INT 5
49712: PUSH
49713: EMPTY
49714: LIST
49715: LIST
49716: PUSH
49717: LD_INT 1
49719: NEG
49720: PUSH
49721: LD_INT 4
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: PUSH
49728: LD_INT 1
49730: NEG
49731: PUSH
49732: LD_INT 3
49734: PUSH
49735: EMPTY
49736: LIST
49737: LIST
49738: PUSH
49739: LD_INT 2
49741: PUSH
49742: LD_INT 5
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: LD_INT 2
49751: NEG
49752: PUSH
49753: LD_INT 3
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PUSH
49760: LD_INT 3
49762: NEG
49763: PUSH
49764: LD_INT 0
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: LD_INT 3
49773: NEG
49774: PUSH
49775: LD_INT 1
49777: NEG
49778: PUSH
49779: EMPTY
49780: LIST
49781: LIST
49782: PUSH
49783: LD_INT 2
49785: NEG
49786: PUSH
49787: LD_INT 0
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 2
49796: NEG
49797: PUSH
49798: LD_INT 1
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 3
49807: NEG
49808: PUSH
49809: LD_INT 1
49811: PUSH
49812: EMPTY
49813: LIST
49814: LIST
49815: PUSH
49816: LD_INT 4
49818: NEG
49819: PUSH
49820: LD_INT 0
49822: PUSH
49823: EMPTY
49824: LIST
49825: LIST
49826: PUSH
49827: LD_INT 4
49829: NEG
49830: PUSH
49831: LD_INT 1
49833: NEG
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: LD_INT 4
49841: NEG
49842: PUSH
49843: LD_INT 2
49845: NEG
49846: PUSH
49847: EMPTY
49848: LIST
49849: LIST
49850: PUSH
49851: LD_INT 2
49853: NEG
49854: PUSH
49855: LD_INT 2
49857: PUSH
49858: EMPTY
49859: LIST
49860: LIST
49861: PUSH
49862: LD_INT 4
49864: NEG
49865: PUSH
49866: LD_INT 4
49868: NEG
49869: PUSH
49870: EMPTY
49871: LIST
49872: LIST
49873: PUSH
49874: LD_INT 4
49876: NEG
49877: PUSH
49878: LD_INT 5
49880: NEG
49881: PUSH
49882: EMPTY
49883: LIST
49884: LIST
49885: PUSH
49886: LD_INT 3
49888: NEG
49889: PUSH
49890: LD_INT 4
49892: NEG
49893: PUSH
49894: EMPTY
49895: LIST
49896: LIST
49897: PUSH
49898: LD_INT 3
49900: NEG
49901: PUSH
49902: LD_INT 3
49904: NEG
49905: PUSH
49906: EMPTY
49907: LIST
49908: LIST
49909: PUSH
49910: LD_INT 4
49912: NEG
49913: PUSH
49914: LD_INT 3
49916: NEG
49917: PUSH
49918: EMPTY
49919: LIST
49920: LIST
49921: PUSH
49922: LD_INT 5
49924: NEG
49925: PUSH
49926: LD_INT 4
49928: NEG
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PUSH
49934: LD_INT 5
49936: NEG
49937: PUSH
49938: LD_INT 5
49940: NEG
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: PUSH
49946: LD_INT 3
49948: NEG
49949: PUSH
49950: LD_INT 5
49952: NEG
49953: PUSH
49954: EMPTY
49955: LIST
49956: LIST
49957: PUSH
49958: LD_INT 5
49960: NEG
49961: PUSH
49962: LD_INT 3
49964: NEG
49965: PUSH
49966: EMPTY
49967: LIST
49968: LIST
49969: PUSH
49970: LD_INT 0
49972: PUSH
49973: LD_INT 3
49975: NEG
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: PUSH
49981: LD_INT 0
49983: PUSH
49984: LD_INT 4
49986: NEG
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PUSH
49992: LD_INT 1
49994: PUSH
49995: LD_INT 3
49997: NEG
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: PUSH
50003: LD_INT 1
50005: PUSH
50006: LD_INT 2
50008: NEG
50009: PUSH
50010: EMPTY
50011: LIST
50012: LIST
50013: PUSH
50014: LD_INT 0
50016: PUSH
50017: LD_INT 2
50019: NEG
50020: PUSH
50021: EMPTY
50022: LIST
50023: LIST
50024: PUSH
50025: LD_INT 1
50027: NEG
50028: PUSH
50029: LD_INT 3
50031: NEG
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: PUSH
50037: LD_INT 1
50039: NEG
50040: PUSH
50041: LD_INT 4
50043: NEG
50044: PUSH
50045: EMPTY
50046: LIST
50047: LIST
50048: PUSH
50049: LD_INT 2
50051: PUSH
50052: LD_INT 2
50054: NEG
50055: PUSH
50056: EMPTY
50057: LIST
50058: LIST
50059: PUSH
50060: LD_INT 2
50062: NEG
50063: PUSH
50064: LD_INT 4
50066: NEG
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: PUSH
50072: LD_INT 4
50074: PUSH
50075: LD_INT 0
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 4
50084: PUSH
50085: LD_INT 1
50087: NEG
50088: PUSH
50089: EMPTY
50090: LIST
50091: LIST
50092: PUSH
50093: LD_INT 5
50095: PUSH
50096: LD_INT 0
50098: PUSH
50099: EMPTY
50100: LIST
50101: LIST
50102: PUSH
50103: LD_INT 5
50105: PUSH
50106: LD_INT 1
50108: PUSH
50109: EMPTY
50110: LIST
50111: LIST
50112: PUSH
50113: LD_INT 4
50115: PUSH
50116: LD_INT 1
50118: PUSH
50119: EMPTY
50120: LIST
50121: LIST
50122: PUSH
50123: LD_INT 3
50125: PUSH
50126: LD_INT 0
50128: PUSH
50129: EMPTY
50130: LIST
50131: LIST
50132: PUSH
50133: LD_INT 3
50135: PUSH
50136: LD_INT 1
50138: NEG
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 3
50146: PUSH
50147: LD_INT 2
50149: NEG
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 5
50157: PUSH
50158: LD_INT 2
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: EMPTY
50166: LIST
50167: LIST
50168: LIST
50169: LIST
50170: LIST
50171: LIST
50172: LIST
50173: LIST
50174: LIST
50175: LIST
50176: LIST
50177: LIST
50178: LIST
50179: LIST
50180: LIST
50181: LIST
50182: LIST
50183: LIST
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: LIST
50189: LIST
50190: LIST
50191: LIST
50192: LIST
50193: LIST
50194: LIST
50195: LIST
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: LIST
50202: LIST
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: LIST
50211: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50212: LD_ADDR_VAR 0 32
50216: PUSH
50217: LD_INT 4
50219: NEG
50220: PUSH
50221: LD_INT 0
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PUSH
50228: LD_INT 4
50230: NEG
50231: PUSH
50232: LD_INT 1
50234: NEG
50235: PUSH
50236: EMPTY
50237: LIST
50238: LIST
50239: PUSH
50240: LD_INT 3
50242: NEG
50243: PUSH
50244: LD_INT 0
50246: PUSH
50247: EMPTY
50248: LIST
50249: LIST
50250: PUSH
50251: LD_INT 3
50253: NEG
50254: PUSH
50255: LD_INT 1
50257: PUSH
50258: EMPTY
50259: LIST
50260: LIST
50261: PUSH
50262: LD_INT 4
50264: NEG
50265: PUSH
50266: LD_INT 1
50268: PUSH
50269: EMPTY
50270: LIST
50271: LIST
50272: PUSH
50273: LD_INT 5
50275: NEG
50276: PUSH
50277: LD_INT 0
50279: PUSH
50280: EMPTY
50281: LIST
50282: LIST
50283: PUSH
50284: LD_INT 5
50286: NEG
50287: PUSH
50288: LD_INT 1
50290: NEG
50291: PUSH
50292: EMPTY
50293: LIST
50294: LIST
50295: PUSH
50296: LD_INT 5
50298: NEG
50299: PUSH
50300: LD_INT 2
50302: NEG
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: PUSH
50308: LD_INT 3
50310: NEG
50311: PUSH
50312: LD_INT 2
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: PUSH
50319: LD_INT 3
50321: NEG
50322: PUSH
50323: LD_INT 3
50325: NEG
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 3
50333: NEG
50334: PUSH
50335: LD_INT 4
50337: NEG
50338: PUSH
50339: EMPTY
50340: LIST
50341: LIST
50342: PUSH
50343: LD_INT 2
50345: NEG
50346: PUSH
50347: LD_INT 3
50349: NEG
50350: PUSH
50351: EMPTY
50352: LIST
50353: LIST
50354: PUSH
50355: LD_INT 2
50357: NEG
50358: PUSH
50359: LD_INT 2
50361: NEG
50362: PUSH
50363: EMPTY
50364: LIST
50365: LIST
50366: PUSH
50367: LD_INT 3
50369: NEG
50370: PUSH
50371: LD_INT 2
50373: NEG
50374: PUSH
50375: EMPTY
50376: LIST
50377: LIST
50378: PUSH
50379: LD_INT 4
50381: NEG
50382: PUSH
50383: LD_INT 3
50385: NEG
50386: PUSH
50387: EMPTY
50388: LIST
50389: LIST
50390: PUSH
50391: LD_INT 4
50393: NEG
50394: PUSH
50395: LD_INT 4
50397: NEG
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 2
50405: NEG
50406: PUSH
50407: LD_INT 4
50409: NEG
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: PUSH
50415: LD_INT 4
50417: NEG
50418: PUSH
50419: LD_INT 2
50421: NEG
50422: PUSH
50423: EMPTY
50424: LIST
50425: LIST
50426: PUSH
50427: LD_INT 0
50429: PUSH
50430: LD_INT 4
50432: NEG
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PUSH
50438: LD_INT 0
50440: PUSH
50441: LD_INT 5
50443: NEG
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: PUSH
50449: LD_INT 1
50451: PUSH
50452: LD_INT 4
50454: NEG
50455: PUSH
50456: EMPTY
50457: LIST
50458: LIST
50459: PUSH
50460: LD_INT 1
50462: PUSH
50463: LD_INT 3
50465: NEG
50466: PUSH
50467: EMPTY
50468: LIST
50469: LIST
50470: PUSH
50471: LD_INT 0
50473: PUSH
50474: LD_INT 3
50476: NEG
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: PUSH
50482: LD_INT 1
50484: NEG
50485: PUSH
50486: LD_INT 4
50488: NEG
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 1
50496: NEG
50497: PUSH
50498: LD_INT 5
50500: NEG
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: PUSH
50506: LD_INT 2
50508: PUSH
50509: LD_INT 3
50511: NEG
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: LD_INT 2
50519: NEG
50520: PUSH
50521: LD_INT 5
50523: NEG
50524: PUSH
50525: EMPTY
50526: LIST
50527: LIST
50528: PUSH
50529: LD_INT 3
50531: PUSH
50532: LD_INT 0
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: PUSH
50539: LD_INT 3
50541: PUSH
50542: LD_INT 1
50544: NEG
50545: PUSH
50546: EMPTY
50547: LIST
50548: LIST
50549: PUSH
50550: LD_INT 4
50552: PUSH
50553: LD_INT 0
50555: PUSH
50556: EMPTY
50557: LIST
50558: LIST
50559: PUSH
50560: LD_INT 4
50562: PUSH
50563: LD_INT 1
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: PUSH
50570: LD_INT 3
50572: PUSH
50573: LD_INT 1
50575: PUSH
50576: EMPTY
50577: LIST
50578: LIST
50579: PUSH
50580: LD_INT 2
50582: PUSH
50583: LD_INT 0
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: PUSH
50590: LD_INT 2
50592: PUSH
50593: LD_INT 1
50595: NEG
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: PUSH
50601: LD_INT 2
50603: PUSH
50604: LD_INT 2
50606: NEG
50607: PUSH
50608: EMPTY
50609: LIST
50610: LIST
50611: PUSH
50612: LD_INT 4
50614: PUSH
50615: LD_INT 2
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PUSH
50622: LD_INT 4
50624: PUSH
50625: LD_INT 4
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: PUSH
50632: LD_INT 4
50634: PUSH
50635: LD_INT 3
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PUSH
50642: LD_INT 5
50644: PUSH
50645: LD_INT 4
50647: PUSH
50648: EMPTY
50649: LIST
50650: LIST
50651: PUSH
50652: LD_INT 5
50654: PUSH
50655: LD_INT 5
50657: PUSH
50658: EMPTY
50659: LIST
50660: LIST
50661: PUSH
50662: LD_INT 4
50664: PUSH
50665: LD_INT 5
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: PUSH
50672: LD_INT 3
50674: PUSH
50675: LD_INT 4
50677: PUSH
50678: EMPTY
50679: LIST
50680: LIST
50681: PUSH
50682: LD_INT 3
50684: PUSH
50685: LD_INT 3
50687: PUSH
50688: EMPTY
50689: LIST
50690: LIST
50691: PUSH
50692: LD_INT 5
50694: PUSH
50695: LD_INT 3
50697: PUSH
50698: EMPTY
50699: LIST
50700: LIST
50701: PUSH
50702: LD_INT 3
50704: PUSH
50705: LD_INT 5
50707: PUSH
50708: EMPTY
50709: LIST
50710: LIST
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: LIST
50716: LIST
50717: LIST
50718: LIST
50719: LIST
50720: LIST
50721: LIST
50722: LIST
50723: LIST
50724: LIST
50725: LIST
50726: LIST
50727: LIST
50728: LIST
50729: LIST
50730: LIST
50731: LIST
50732: LIST
50733: LIST
50734: LIST
50735: LIST
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: LIST
50745: LIST
50746: LIST
50747: LIST
50748: LIST
50749: LIST
50750: LIST
50751: LIST
50752: LIST
50753: LIST
50754: LIST
50755: LIST
50756: LIST
50757: LIST
50758: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50759: LD_ADDR_VAR 0 33
50763: PUSH
50764: LD_INT 4
50766: NEG
50767: PUSH
50768: LD_INT 4
50770: NEG
50771: PUSH
50772: EMPTY
50773: LIST
50774: LIST
50775: PUSH
50776: LD_INT 4
50778: NEG
50779: PUSH
50780: LD_INT 5
50782: NEG
50783: PUSH
50784: EMPTY
50785: LIST
50786: LIST
50787: PUSH
50788: LD_INT 3
50790: NEG
50791: PUSH
50792: LD_INT 4
50794: NEG
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: LD_INT 3
50802: NEG
50803: PUSH
50804: LD_INT 3
50806: NEG
50807: PUSH
50808: EMPTY
50809: LIST
50810: LIST
50811: PUSH
50812: LD_INT 4
50814: NEG
50815: PUSH
50816: LD_INT 3
50818: NEG
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: PUSH
50824: LD_INT 5
50826: NEG
50827: PUSH
50828: LD_INT 4
50830: NEG
50831: PUSH
50832: EMPTY
50833: LIST
50834: LIST
50835: PUSH
50836: LD_INT 5
50838: NEG
50839: PUSH
50840: LD_INT 5
50842: NEG
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 3
50850: NEG
50851: PUSH
50852: LD_INT 5
50854: NEG
50855: PUSH
50856: EMPTY
50857: LIST
50858: LIST
50859: PUSH
50860: LD_INT 5
50862: NEG
50863: PUSH
50864: LD_INT 3
50866: NEG
50867: PUSH
50868: EMPTY
50869: LIST
50870: LIST
50871: PUSH
50872: LD_INT 0
50874: PUSH
50875: LD_INT 3
50877: NEG
50878: PUSH
50879: EMPTY
50880: LIST
50881: LIST
50882: PUSH
50883: LD_INT 0
50885: PUSH
50886: LD_INT 4
50888: NEG
50889: PUSH
50890: EMPTY
50891: LIST
50892: LIST
50893: PUSH
50894: LD_INT 1
50896: PUSH
50897: LD_INT 3
50899: NEG
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: PUSH
50905: LD_INT 1
50907: PUSH
50908: LD_INT 2
50910: NEG
50911: PUSH
50912: EMPTY
50913: LIST
50914: LIST
50915: PUSH
50916: LD_INT 0
50918: PUSH
50919: LD_INT 2
50921: NEG
50922: PUSH
50923: EMPTY
50924: LIST
50925: LIST
50926: PUSH
50927: LD_INT 1
50929: NEG
50930: PUSH
50931: LD_INT 3
50933: NEG
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 1
50941: NEG
50942: PUSH
50943: LD_INT 4
50945: NEG
50946: PUSH
50947: EMPTY
50948: LIST
50949: LIST
50950: PUSH
50951: LD_INT 2
50953: PUSH
50954: LD_INT 2
50956: NEG
50957: PUSH
50958: EMPTY
50959: LIST
50960: LIST
50961: PUSH
50962: LD_INT 2
50964: NEG
50965: PUSH
50966: LD_INT 4
50968: NEG
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: PUSH
50974: LD_INT 4
50976: PUSH
50977: LD_INT 0
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: PUSH
50984: LD_INT 4
50986: PUSH
50987: LD_INT 1
50989: NEG
50990: PUSH
50991: EMPTY
50992: LIST
50993: LIST
50994: PUSH
50995: LD_INT 5
50997: PUSH
50998: LD_INT 0
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: PUSH
51005: LD_INT 5
51007: PUSH
51008: LD_INT 1
51010: PUSH
51011: EMPTY
51012: LIST
51013: LIST
51014: PUSH
51015: LD_INT 4
51017: PUSH
51018: LD_INT 1
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: PUSH
51025: LD_INT 3
51027: PUSH
51028: LD_INT 0
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: PUSH
51035: LD_INT 3
51037: PUSH
51038: LD_INT 1
51040: NEG
51041: PUSH
51042: EMPTY
51043: LIST
51044: LIST
51045: PUSH
51046: LD_INT 3
51048: PUSH
51049: LD_INT 2
51051: NEG
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: PUSH
51057: LD_INT 5
51059: PUSH
51060: LD_INT 2
51062: PUSH
51063: EMPTY
51064: LIST
51065: LIST
51066: PUSH
51067: LD_INT 3
51069: PUSH
51070: LD_INT 3
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: PUSH
51077: LD_INT 3
51079: PUSH
51080: LD_INT 2
51082: PUSH
51083: EMPTY
51084: LIST
51085: LIST
51086: PUSH
51087: LD_INT 4
51089: PUSH
51090: LD_INT 3
51092: PUSH
51093: EMPTY
51094: LIST
51095: LIST
51096: PUSH
51097: LD_INT 4
51099: PUSH
51100: LD_INT 4
51102: PUSH
51103: EMPTY
51104: LIST
51105: LIST
51106: PUSH
51107: LD_INT 3
51109: PUSH
51110: LD_INT 4
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: PUSH
51117: LD_INT 2
51119: PUSH
51120: LD_INT 3
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: PUSH
51127: LD_INT 2
51129: PUSH
51130: LD_INT 2
51132: PUSH
51133: EMPTY
51134: LIST
51135: LIST
51136: PUSH
51137: LD_INT 4
51139: PUSH
51140: LD_INT 2
51142: PUSH
51143: EMPTY
51144: LIST
51145: LIST
51146: PUSH
51147: LD_INT 2
51149: PUSH
51150: LD_INT 4
51152: PUSH
51153: EMPTY
51154: LIST
51155: LIST
51156: PUSH
51157: LD_INT 0
51159: PUSH
51160: LD_INT 4
51162: PUSH
51163: EMPTY
51164: LIST
51165: LIST
51166: PUSH
51167: LD_INT 0
51169: PUSH
51170: LD_INT 3
51172: PUSH
51173: EMPTY
51174: LIST
51175: LIST
51176: PUSH
51177: LD_INT 1
51179: PUSH
51180: LD_INT 4
51182: PUSH
51183: EMPTY
51184: LIST
51185: LIST
51186: PUSH
51187: LD_INT 1
51189: PUSH
51190: LD_INT 5
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: PUSH
51197: LD_INT 0
51199: PUSH
51200: LD_INT 5
51202: PUSH
51203: EMPTY
51204: LIST
51205: LIST
51206: PUSH
51207: LD_INT 1
51209: NEG
51210: PUSH
51211: LD_INT 4
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: PUSH
51218: LD_INT 1
51220: NEG
51221: PUSH
51222: LD_INT 3
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: PUSH
51229: LD_INT 2
51231: PUSH
51232: LD_INT 5
51234: PUSH
51235: EMPTY
51236: LIST
51237: LIST
51238: PUSH
51239: LD_INT 2
51241: NEG
51242: PUSH
51243: LD_INT 3
51245: PUSH
51246: EMPTY
51247: LIST
51248: LIST
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: LIST
51273: LIST
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: LIST
51281: LIST
51282: LIST
51283: LIST
51284: LIST
51285: LIST
51286: LIST
51287: LIST
51288: LIST
51289: LIST
51290: LIST
51291: LIST
51292: LIST
51293: LIST
51294: LIST
51295: LIST
51296: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51297: LD_ADDR_VAR 0 34
51301: PUSH
51302: LD_INT 0
51304: PUSH
51305: LD_INT 4
51307: NEG
51308: PUSH
51309: EMPTY
51310: LIST
51311: LIST
51312: PUSH
51313: LD_INT 0
51315: PUSH
51316: LD_INT 5
51318: NEG
51319: PUSH
51320: EMPTY
51321: LIST
51322: LIST
51323: PUSH
51324: LD_INT 1
51326: PUSH
51327: LD_INT 4
51329: NEG
51330: PUSH
51331: EMPTY
51332: LIST
51333: LIST
51334: PUSH
51335: LD_INT 1
51337: PUSH
51338: LD_INT 3
51340: NEG
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 0
51348: PUSH
51349: LD_INT 3
51351: NEG
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: PUSH
51357: LD_INT 1
51359: NEG
51360: PUSH
51361: LD_INT 4
51363: NEG
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 1
51371: NEG
51372: PUSH
51373: LD_INT 5
51375: NEG
51376: PUSH
51377: EMPTY
51378: LIST
51379: LIST
51380: PUSH
51381: LD_INT 2
51383: PUSH
51384: LD_INT 3
51386: NEG
51387: PUSH
51388: EMPTY
51389: LIST
51390: LIST
51391: PUSH
51392: LD_INT 2
51394: NEG
51395: PUSH
51396: LD_INT 5
51398: NEG
51399: PUSH
51400: EMPTY
51401: LIST
51402: LIST
51403: PUSH
51404: LD_INT 3
51406: PUSH
51407: LD_INT 0
51409: PUSH
51410: EMPTY
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 3
51416: PUSH
51417: LD_INT 1
51419: NEG
51420: PUSH
51421: EMPTY
51422: LIST
51423: LIST
51424: PUSH
51425: LD_INT 4
51427: PUSH
51428: LD_INT 0
51430: PUSH
51431: EMPTY
51432: LIST
51433: LIST
51434: PUSH
51435: LD_INT 4
51437: PUSH
51438: LD_INT 1
51440: PUSH
51441: EMPTY
51442: LIST
51443: LIST
51444: PUSH
51445: LD_INT 3
51447: PUSH
51448: LD_INT 1
51450: PUSH
51451: EMPTY
51452: LIST
51453: LIST
51454: PUSH
51455: LD_INT 2
51457: PUSH
51458: LD_INT 0
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PUSH
51465: LD_INT 2
51467: PUSH
51468: LD_INT 1
51470: NEG
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: PUSH
51476: LD_INT 2
51478: PUSH
51479: LD_INT 2
51481: NEG
51482: PUSH
51483: EMPTY
51484: LIST
51485: LIST
51486: PUSH
51487: LD_INT 4
51489: PUSH
51490: LD_INT 2
51492: PUSH
51493: EMPTY
51494: LIST
51495: LIST
51496: PUSH
51497: LD_INT 4
51499: PUSH
51500: LD_INT 4
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: PUSH
51507: LD_INT 4
51509: PUSH
51510: LD_INT 3
51512: PUSH
51513: EMPTY
51514: LIST
51515: LIST
51516: PUSH
51517: LD_INT 5
51519: PUSH
51520: LD_INT 4
51522: PUSH
51523: EMPTY
51524: LIST
51525: LIST
51526: PUSH
51527: LD_INT 5
51529: PUSH
51530: LD_INT 5
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: PUSH
51537: LD_INT 4
51539: PUSH
51540: LD_INT 5
51542: PUSH
51543: EMPTY
51544: LIST
51545: LIST
51546: PUSH
51547: LD_INT 3
51549: PUSH
51550: LD_INT 4
51552: PUSH
51553: EMPTY
51554: LIST
51555: LIST
51556: PUSH
51557: LD_INT 3
51559: PUSH
51560: LD_INT 3
51562: PUSH
51563: EMPTY
51564: LIST
51565: LIST
51566: PUSH
51567: LD_INT 5
51569: PUSH
51570: LD_INT 3
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: PUSH
51577: LD_INT 3
51579: PUSH
51580: LD_INT 5
51582: PUSH
51583: EMPTY
51584: LIST
51585: LIST
51586: PUSH
51587: LD_INT 0
51589: PUSH
51590: LD_INT 3
51592: PUSH
51593: EMPTY
51594: LIST
51595: LIST
51596: PUSH
51597: LD_INT 0
51599: PUSH
51600: LD_INT 2
51602: PUSH
51603: EMPTY
51604: LIST
51605: LIST
51606: PUSH
51607: LD_INT 1
51609: PUSH
51610: LD_INT 3
51612: PUSH
51613: EMPTY
51614: LIST
51615: LIST
51616: PUSH
51617: LD_INT 1
51619: PUSH
51620: LD_INT 4
51622: PUSH
51623: EMPTY
51624: LIST
51625: LIST
51626: PUSH
51627: LD_INT 0
51629: PUSH
51630: LD_INT 4
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: PUSH
51637: LD_INT 1
51639: NEG
51640: PUSH
51641: LD_INT 3
51643: PUSH
51644: EMPTY
51645: LIST
51646: LIST
51647: PUSH
51648: LD_INT 1
51650: NEG
51651: PUSH
51652: LD_INT 2
51654: PUSH
51655: EMPTY
51656: LIST
51657: LIST
51658: PUSH
51659: LD_INT 2
51661: PUSH
51662: LD_INT 4
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: PUSH
51669: LD_INT 2
51671: NEG
51672: PUSH
51673: LD_INT 2
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PUSH
51680: LD_INT 4
51682: NEG
51683: PUSH
51684: LD_INT 0
51686: PUSH
51687: EMPTY
51688: LIST
51689: LIST
51690: PUSH
51691: LD_INT 4
51693: NEG
51694: PUSH
51695: LD_INT 1
51697: NEG
51698: PUSH
51699: EMPTY
51700: LIST
51701: LIST
51702: PUSH
51703: LD_INT 3
51705: NEG
51706: PUSH
51707: LD_INT 0
51709: PUSH
51710: EMPTY
51711: LIST
51712: LIST
51713: PUSH
51714: LD_INT 3
51716: NEG
51717: PUSH
51718: LD_INT 1
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: PUSH
51725: LD_INT 4
51727: NEG
51728: PUSH
51729: LD_INT 1
51731: PUSH
51732: EMPTY
51733: LIST
51734: LIST
51735: PUSH
51736: LD_INT 5
51738: NEG
51739: PUSH
51740: LD_INT 0
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: PUSH
51747: LD_INT 5
51749: NEG
51750: PUSH
51751: LD_INT 1
51753: NEG
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: PUSH
51759: LD_INT 5
51761: NEG
51762: PUSH
51763: LD_INT 2
51765: NEG
51766: PUSH
51767: EMPTY
51768: LIST
51769: LIST
51770: PUSH
51771: LD_INT 3
51773: NEG
51774: PUSH
51775: LD_INT 2
51777: PUSH
51778: EMPTY
51779: LIST
51780: LIST
51781: PUSH
51782: EMPTY
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: LIST
51796: LIST
51797: LIST
51798: LIST
51799: LIST
51800: LIST
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: LIST
51806: LIST
51807: LIST
51808: LIST
51809: LIST
51810: LIST
51811: LIST
51812: LIST
51813: LIST
51814: LIST
51815: LIST
51816: LIST
51817: LIST
51818: LIST
51819: LIST
51820: LIST
51821: LIST
51822: LIST
51823: LIST
51824: LIST
51825: LIST
51826: LIST
51827: LIST
51828: ST_TO_ADDR
// end ; end ;
51829: GO 51832
51831: POP
// case btype of b_depot , b_warehouse :
51832: LD_VAR 0 1
51836: PUSH
51837: LD_INT 0
51839: DOUBLE
51840: EQUAL
51841: IFTRUE 51851
51843: LD_INT 1
51845: DOUBLE
51846: EQUAL
51847: IFTRUE 51851
51849: GO 52052
51851: POP
// case nation of nation_american :
51852: LD_VAR 0 5
51856: PUSH
51857: LD_INT 1
51859: DOUBLE
51860: EQUAL
51861: IFTRUE 51865
51863: GO 51921
51865: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51866: LD_ADDR_VAR 0 9
51870: PUSH
51871: LD_VAR 0 11
51875: PUSH
51876: LD_VAR 0 12
51880: PUSH
51881: LD_VAR 0 13
51885: PUSH
51886: LD_VAR 0 14
51890: PUSH
51891: LD_VAR 0 15
51895: PUSH
51896: LD_VAR 0 16
51900: PUSH
51901: EMPTY
51902: LIST
51903: LIST
51904: LIST
51905: LIST
51906: LIST
51907: LIST
51908: PUSH
51909: LD_VAR 0 4
51913: PUSH
51914: LD_INT 1
51916: PLUS
51917: ARRAY
51918: ST_TO_ADDR
51919: GO 52050
51921: LD_INT 2
51923: DOUBLE
51924: EQUAL
51925: IFTRUE 51929
51927: GO 51985
51929: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51930: LD_ADDR_VAR 0 9
51934: PUSH
51935: LD_VAR 0 17
51939: PUSH
51940: LD_VAR 0 18
51944: PUSH
51945: LD_VAR 0 19
51949: PUSH
51950: LD_VAR 0 20
51954: PUSH
51955: LD_VAR 0 21
51959: PUSH
51960: LD_VAR 0 22
51964: PUSH
51965: EMPTY
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: LIST
51971: LIST
51972: PUSH
51973: LD_VAR 0 4
51977: PUSH
51978: LD_INT 1
51980: PLUS
51981: ARRAY
51982: ST_TO_ADDR
51983: GO 52050
51985: LD_INT 3
51987: DOUBLE
51988: EQUAL
51989: IFTRUE 51993
51991: GO 52049
51993: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51994: LD_ADDR_VAR 0 9
51998: PUSH
51999: LD_VAR 0 23
52003: PUSH
52004: LD_VAR 0 24
52008: PUSH
52009: LD_VAR 0 25
52013: PUSH
52014: LD_VAR 0 26
52018: PUSH
52019: LD_VAR 0 27
52023: PUSH
52024: LD_VAR 0 28
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: PUSH
52037: LD_VAR 0 4
52041: PUSH
52042: LD_INT 1
52044: PLUS
52045: ARRAY
52046: ST_TO_ADDR
52047: GO 52050
52049: POP
52050: GO 52605
52052: LD_INT 2
52054: DOUBLE
52055: EQUAL
52056: IFTRUE 52066
52058: LD_INT 3
52060: DOUBLE
52061: EQUAL
52062: IFTRUE 52066
52064: GO 52122
52066: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
52067: LD_ADDR_VAR 0 9
52071: PUSH
52072: LD_VAR 0 29
52076: PUSH
52077: LD_VAR 0 30
52081: PUSH
52082: LD_VAR 0 31
52086: PUSH
52087: LD_VAR 0 32
52091: PUSH
52092: LD_VAR 0 33
52096: PUSH
52097: LD_VAR 0 34
52101: PUSH
52102: EMPTY
52103: LIST
52104: LIST
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: PUSH
52110: LD_VAR 0 4
52114: PUSH
52115: LD_INT 1
52117: PLUS
52118: ARRAY
52119: ST_TO_ADDR
52120: GO 52605
52122: LD_INT 16
52124: DOUBLE
52125: EQUAL
52126: IFTRUE 52184
52128: LD_INT 17
52130: DOUBLE
52131: EQUAL
52132: IFTRUE 52184
52134: LD_INT 18
52136: DOUBLE
52137: EQUAL
52138: IFTRUE 52184
52140: LD_INT 19
52142: DOUBLE
52143: EQUAL
52144: IFTRUE 52184
52146: LD_INT 22
52148: DOUBLE
52149: EQUAL
52150: IFTRUE 52184
52152: LD_INT 20
52154: DOUBLE
52155: EQUAL
52156: IFTRUE 52184
52158: LD_INT 21
52160: DOUBLE
52161: EQUAL
52162: IFTRUE 52184
52164: LD_INT 23
52166: DOUBLE
52167: EQUAL
52168: IFTRUE 52184
52170: LD_INT 24
52172: DOUBLE
52173: EQUAL
52174: IFTRUE 52184
52176: LD_INT 25
52178: DOUBLE
52179: EQUAL
52180: IFTRUE 52184
52182: GO 52240
52184: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52185: LD_ADDR_VAR 0 9
52189: PUSH
52190: LD_VAR 0 35
52194: PUSH
52195: LD_VAR 0 36
52199: PUSH
52200: LD_VAR 0 37
52204: PUSH
52205: LD_VAR 0 38
52209: PUSH
52210: LD_VAR 0 39
52214: PUSH
52215: LD_VAR 0 40
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: LIST
52227: PUSH
52228: LD_VAR 0 4
52232: PUSH
52233: LD_INT 1
52235: PLUS
52236: ARRAY
52237: ST_TO_ADDR
52238: GO 52605
52240: LD_INT 6
52242: DOUBLE
52243: EQUAL
52244: IFTRUE 52296
52246: LD_INT 7
52248: DOUBLE
52249: EQUAL
52250: IFTRUE 52296
52252: LD_INT 8
52254: DOUBLE
52255: EQUAL
52256: IFTRUE 52296
52258: LD_INT 13
52260: DOUBLE
52261: EQUAL
52262: IFTRUE 52296
52264: LD_INT 12
52266: DOUBLE
52267: EQUAL
52268: IFTRUE 52296
52270: LD_INT 15
52272: DOUBLE
52273: EQUAL
52274: IFTRUE 52296
52276: LD_INT 11
52278: DOUBLE
52279: EQUAL
52280: IFTRUE 52296
52282: LD_INT 14
52284: DOUBLE
52285: EQUAL
52286: IFTRUE 52296
52288: LD_INT 10
52290: DOUBLE
52291: EQUAL
52292: IFTRUE 52296
52294: GO 52352
52296: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52297: LD_ADDR_VAR 0 9
52301: PUSH
52302: LD_VAR 0 41
52306: PUSH
52307: LD_VAR 0 42
52311: PUSH
52312: LD_VAR 0 43
52316: PUSH
52317: LD_VAR 0 44
52321: PUSH
52322: LD_VAR 0 45
52326: PUSH
52327: LD_VAR 0 46
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: PUSH
52340: LD_VAR 0 4
52344: PUSH
52345: LD_INT 1
52347: PLUS
52348: ARRAY
52349: ST_TO_ADDR
52350: GO 52605
52352: LD_INT 36
52354: DOUBLE
52355: EQUAL
52356: IFTRUE 52360
52358: GO 52416
52360: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52361: LD_ADDR_VAR 0 9
52365: PUSH
52366: LD_VAR 0 47
52370: PUSH
52371: LD_VAR 0 48
52375: PUSH
52376: LD_VAR 0 49
52380: PUSH
52381: LD_VAR 0 50
52385: PUSH
52386: LD_VAR 0 51
52390: PUSH
52391: LD_VAR 0 52
52395: PUSH
52396: EMPTY
52397: LIST
52398: LIST
52399: LIST
52400: LIST
52401: LIST
52402: LIST
52403: PUSH
52404: LD_VAR 0 4
52408: PUSH
52409: LD_INT 1
52411: PLUS
52412: ARRAY
52413: ST_TO_ADDR
52414: GO 52605
52416: LD_INT 4
52418: DOUBLE
52419: EQUAL
52420: IFTRUE 52442
52422: LD_INT 5
52424: DOUBLE
52425: EQUAL
52426: IFTRUE 52442
52428: LD_INT 34
52430: DOUBLE
52431: EQUAL
52432: IFTRUE 52442
52434: LD_INT 37
52436: DOUBLE
52437: EQUAL
52438: IFTRUE 52442
52440: GO 52498
52442: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52443: LD_ADDR_VAR 0 9
52447: PUSH
52448: LD_VAR 0 53
52452: PUSH
52453: LD_VAR 0 54
52457: PUSH
52458: LD_VAR 0 55
52462: PUSH
52463: LD_VAR 0 56
52467: PUSH
52468: LD_VAR 0 57
52472: PUSH
52473: LD_VAR 0 58
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: LIST
52482: LIST
52483: LIST
52484: LIST
52485: PUSH
52486: LD_VAR 0 4
52490: PUSH
52491: LD_INT 1
52493: PLUS
52494: ARRAY
52495: ST_TO_ADDR
52496: GO 52605
52498: LD_INT 31
52500: DOUBLE
52501: EQUAL
52502: IFTRUE 52548
52504: LD_INT 32
52506: DOUBLE
52507: EQUAL
52508: IFTRUE 52548
52510: LD_INT 33
52512: DOUBLE
52513: EQUAL
52514: IFTRUE 52548
52516: LD_INT 27
52518: DOUBLE
52519: EQUAL
52520: IFTRUE 52548
52522: LD_INT 26
52524: DOUBLE
52525: EQUAL
52526: IFTRUE 52548
52528: LD_INT 28
52530: DOUBLE
52531: EQUAL
52532: IFTRUE 52548
52534: LD_INT 29
52536: DOUBLE
52537: EQUAL
52538: IFTRUE 52548
52540: LD_INT 30
52542: DOUBLE
52543: EQUAL
52544: IFTRUE 52548
52546: GO 52604
52548: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52549: LD_ADDR_VAR 0 9
52553: PUSH
52554: LD_VAR 0 59
52558: PUSH
52559: LD_VAR 0 60
52563: PUSH
52564: LD_VAR 0 61
52568: PUSH
52569: LD_VAR 0 62
52573: PUSH
52574: LD_VAR 0 63
52578: PUSH
52579: LD_VAR 0 64
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: LIST
52588: LIST
52589: LIST
52590: LIST
52591: PUSH
52592: LD_VAR 0 4
52596: PUSH
52597: LD_INT 1
52599: PLUS
52600: ARRAY
52601: ST_TO_ADDR
52602: GO 52605
52604: POP
// temp_list2 = [ ] ;
52605: LD_ADDR_VAR 0 10
52609: PUSH
52610: EMPTY
52611: ST_TO_ADDR
// for i in temp_list do
52612: LD_ADDR_VAR 0 8
52616: PUSH
52617: LD_VAR 0 9
52621: PUSH
52622: FOR_IN
52623: IFFALSE 52675
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52625: LD_ADDR_VAR 0 10
52629: PUSH
52630: LD_VAR 0 10
52634: PUSH
52635: LD_VAR 0 8
52639: PUSH
52640: LD_INT 1
52642: ARRAY
52643: PUSH
52644: LD_VAR 0 2
52648: PLUS
52649: PUSH
52650: LD_VAR 0 8
52654: PUSH
52655: LD_INT 2
52657: ARRAY
52658: PUSH
52659: LD_VAR 0 3
52663: PLUS
52664: PUSH
52665: EMPTY
52666: LIST
52667: LIST
52668: PUSH
52669: EMPTY
52670: LIST
52671: ADD
52672: ST_TO_ADDR
52673: GO 52622
52675: POP
52676: POP
// result = temp_list2 ;
52677: LD_ADDR_VAR 0 7
52681: PUSH
52682: LD_VAR 0 10
52686: ST_TO_ADDR
// end ;
52687: LD_VAR 0 7
52691: RET
// export function EnemyInRange ( unit , dist ) ; begin
52692: LD_INT 0
52694: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52695: LD_ADDR_VAR 0 3
52699: PUSH
52700: LD_VAR 0 1
52704: PPUSH
52705: CALL_OW 255
52709: PPUSH
52710: LD_VAR 0 1
52714: PPUSH
52715: CALL_OW 250
52719: PPUSH
52720: LD_VAR 0 1
52724: PPUSH
52725: CALL_OW 251
52729: PPUSH
52730: LD_VAR 0 2
52734: PPUSH
52735: CALL 26065 0 4
52739: PUSH
52740: LD_INT 4
52742: ARRAY
52743: ST_TO_ADDR
// end ;
52744: LD_VAR 0 3
52748: RET
// export function PlayerSeeMe ( unit ) ; begin
52749: LD_INT 0
52751: PPUSH
// result := See ( your_side , unit ) ;
52752: LD_ADDR_VAR 0 2
52756: PUSH
52757: LD_OWVAR 2
52761: PPUSH
52762: LD_VAR 0 1
52766: PPUSH
52767: CALL_OW 292
52771: ST_TO_ADDR
// end ;
52772: LD_VAR 0 2
52776: RET
// export function ReverseDir ( unit ) ; begin
52777: LD_INT 0
52779: PPUSH
// if not unit then
52780: LD_VAR 0 1
52784: NOT
52785: IFFALSE 52789
// exit ;
52787: GO 52812
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52789: LD_ADDR_VAR 0 2
52793: PUSH
52794: LD_VAR 0 1
52798: PPUSH
52799: CALL_OW 254
52803: PUSH
52804: LD_INT 3
52806: PLUS
52807: PUSH
52808: LD_INT 6
52810: MOD
52811: ST_TO_ADDR
// end ;
52812: LD_VAR 0 2
52816: RET
// export function ReverseArray ( array ) ; var i ; begin
52817: LD_INT 0
52819: PPUSH
52820: PPUSH
// if not array then
52821: LD_VAR 0 1
52825: NOT
52826: IFFALSE 52830
// exit ;
52828: GO 52885
// result := [ ] ;
52830: LD_ADDR_VAR 0 2
52834: PUSH
52835: EMPTY
52836: ST_TO_ADDR
// for i := array downto 1 do
52837: LD_ADDR_VAR 0 3
52841: PUSH
52842: DOUBLE
52843: LD_VAR 0 1
52847: INC
52848: ST_TO_ADDR
52849: LD_INT 1
52851: PUSH
52852: FOR_DOWNTO
52853: IFFALSE 52883
// result := Join ( result , array [ i ] ) ;
52855: LD_ADDR_VAR 0 2
52859: PUSH
52860: LD_VAR 0 2
52864: PPUSH
52865: LD_VAR 0 1
52869: PUSH
52870: LD_VAR 0 3
52874: ARRAY
52875: PPUSH
52876: CALL 57530 0 2
52880: ST_TO_ADDR
52881: GO 52852
52883: POP
52884: POP
// end ;
52885: LD_VAR 0 2
52889: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52890: LD_INT 0
52892: PPUSH
52893: PPUSH
52894: PPUSH
52895: PPUSH
52896: PPUSH
52897: PPUSH
// if not unit or not hexes then
52898: LD_VAR 0 1
52902: NOT
52903: PUSH
52904: LD_VAR 0 2
52908: NOT
52909: OR
52910: IFFALSE 52914
// exit ;
52912: GO 53037
// dist := 9999 ;
52914: LD_ADDR_VAR 0 5
52918: PUSH
52919: LD_INT 9999
52921: ST_TO_ADDR
// for i = 1 to hexes do
52922: LD_ADDR_VAR 0 4
52926: PUSH
52927: DOUBLE
52928: LD_INT 1
52930: DEC
52931: ST_TO_ADDR
52932: LD_VAR 0 2
52936: PUSH
52937: FOR_TO
52938: IFFALSE 53025
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52940: LD_ADDR_VAR 0 6
52944: PUSH
52945: LD_VAR 0 1
52949: PPUSH
52950: LD_VAR 0 2
52954: PUSH
52955: LD_VAR 0 4
52959: ARRAY
52960: PUSH
52961: LD_INT 1
52963: ARRAY
52964: PPUSH
52965: LD_VAR 0 2
52969: PUSH
52970: LD_VAR 0 4
52974: ARRAY
52975: PUSH
52976: LD_INT 2
52978: ARRAY
52979: PPUSH
52980: CALL_OW 297
52984: ST_TO_ADDR
// if tdist < dist then
52985: LD_VAR 0 6
52989: PUSH
52990: LD_VAR 0 5
52994: LESS
52995: IFFALSE 53023
// begin hex := hexes [ i ] ;
52997: LD_ADDR_VAR 0 8
53001: PUSH
53002: LD_VAR 0 2
53006: PUSH
53007: LD_VAR 0 4
53011: ARRAY
53012: ST_TO_ADDR
// dist := tdist ;
53013: LD_ADDR_VAR 0 5
53017: PUSH
53018: LD_VAR 0 6
53022: ST_TO_ADDR
// end ; end ;
53023: GO 52937
53025: POP
53026: POP
// result := hex ;
53027: LD_ADDR_VAR 0 3
53031: PUSH
53032: LD_VAR 0 8
53036: ST_TO_ADDR
// end ;
53037: LD_VAR 0 3
53041: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
53042: LD_INT 0
53044: PPUSH
53045: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53046: LD_VAR 0 1
53050: NOT
53051: PUSH
53052: LD_VAR 0 1
53056: PUSH
53057: LD_INT 21
53059: PUSH
53060: LD_INT 2
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: PUSH
53067: LD_INT 23
53069: PUSH
53070: LD_INT 2
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: PPUSH
53081: CALL_OW 69
53085: IN
53086: NOT
53087: OR
53088: IFFALSE 53092
// exit ;
53090: GO 53139
// for i = 1 to 3 do
53092: LD_ADDR_VAR 0 3
53096: PUSH
53097: DOUBLE
53098: LD_INT 1
53100: DEC
53101: ST_TO_ADDR
53102: LD_INT 3
53104: PUSH
53105: FOR_TO
53106: IFFALSE 53137
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
53108: LD_VAR 0 1
53112: PPUSH
53113: CALL_OW 250
53117: PPUSH
53118: LD_VAR 0 1
53122: PPUSH
53123: CALL_OW 251
53127: PPUSH
53128: LD_INT 1
53130: PPUSH
53131: CALL_OW 453
53135: GO 53105
53137: POP
53138: POP
// end ;
53139: LD_VAR 0 2
53143: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
53144: LD_INT 0
53146: PPUSH
53147: PPUSH
53148: PPUSH
53149: PPUSH
53150: PPUSH
53151: PPUSH
// if not unit or not enemy_unit then
53152: LD_VAR 0 1
53156: NOT
53157: PUSH
53158: LD_VAR 0 2
53162: NOT
53163: OR
53164: IFFALSE 53168
// exit ;
53166: GO 53635
// if GetLives ( i ) < 250 then
53168: LD_VAR 0 4
53172: PPUSH
53173: CALL_OW 256
53177: PUSH
53178: LD_INT 250
53180: LESS
53181: IFFALSE 53194
// begin ComAutodestruct ( i ) ;
53183: LD_VAR 0 4
53187: PPUSH
53188: CALL 53042 0 1
// exit ;
53192: GO 53635
// end ; x := GetX ( enemy_unit ) ;
53194: LD_ADDR_VAR 0 7
53198: PUSH
53199: LD_VAR 0 2
53203: PPUSH
53204: CALL_OW 250
53208: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53209: LD_ADDR_VAR 0 8
53213: PUSH
53214: LD_VAR 0 2
53218: PPUSH
53219: CALL_OW 251
53223: ST_TO_ADDR
// if not x or not y then
53224: LD_VAR 0 7
53228: NOT
53229: PUSH
53230: LD_VAR 0 8
53234: NOT
53235: OR
53236: IFFALSE 53240
// exit ;
53238: GO 53635
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53240: LD_ADDR_VAR 0 6
53244: PUSH
53245: LD_VAR 0 7
53249: PPUSH
53250: LD_INT 0
53252: PPUSH
53253: LD_INT 4
53255: PPUSH
53256: CALL_OW 272
53260: PUSH
53261: LD_VAR 0 8
53265: PPUSH
53266: LD_INT 0
53268: PPUSH
53269: LD_INT 4
53271: PPUSH
53272: CALL_OW 273
53276: PUSH
53277: EMPTY
53278: LIST
53279: LIST
53280: PUSH
53281: LD_VAR 0 7
53285: PPUSH
53286: LD_INT 1
53288: PPUSH
53289: LD_INT 4
53291: PPUSH
53292: CALL_OW 272
53296: PUSH
53297: LD_VAR 0 8
53301: PPUSH
53302: LD_INT 1
53304: PPUSH
53305: LD_INT 4
53307: PPUSH
53308: CALL_OW 273
53312: PUSH
53313: EMPTY
53314: LIST
53315: LIST
53316: PUSH
53317: LD_VAR 0 7
53321: PPUSH
53322: LD_INT 2
53324: PPUSH
53325: LD_INT 4
53327: PPUSH
53328: CALL_OW 272
53332: PUSH
53333: LD_VAR 0 8
53337: PPUSH
53338: LD_INT 2
53340: PPUSH
53341: LD_INT 4
53343: PPUSH
53344: CALL_OW 273
53348: PUSH
53349: EMPTY
53350: LIST
53351: LIST
53352: PUSH
53353: LD_VAR 0 7
53357: PPUSH
53358: LD_INT 3
53360: PPUSH
53361: LD_INT 4
53363: PPUSH
53364: CALL_OW 272
53368: PUSH
53369: LD_VAR 0 8
53373: PPUSH
53374: LD_INT 3
53376: PPUSH
53377: LD_INT 4
53379: PPUSH
53380: CALL_OW 273
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: PUSH
53389: LD_VAR 0 7
53393: PPUSH
53394: LD_INT 4
53396: PPUSH
53397: LD_INT 4
53399: PPUSH
53400: CALL_OW 272
53404: PUSH
53405: LD_VAR 0 8
53409: PPUSH
53410: LD_INT 4
53412: PPUSH
53413: LD_INT 4
53415: PPUSH
53416: CALL_OW 273
53420: PUSH
53421: EMPTY
53422: LIST
53423: LIST
53424: PUSH
53425: LD_VAR 0 7
53429: PPUSH
53430: LD_INT 5
53432: PPUSH
53433: LD_INT 4
53435: PPUSH
53436: CALL_OW 272
53440: PUSH
53441: LD_VAR 0 8
53445: PPUSH
53446: LD_INT 5
53448: PPUSH
53449: LD_INT 4
53451: PPUSH
53452: CALL_OW 273
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: LIST
53465: LIST
53466: LIST
53467: LIST
53468: ST_TO_ADDR
// for i = tmp downto 1 do
53469: LD_ADDR_VAR 0 4
53473: PUSH
53474: DOUBLE
53475: LD_VAR 0 6
53479: INC
53480: ST_TO_ADDR
53481: LD_INT 1
53483: PUSH
53484: FOR_DOWNTO
53485: IFFALSE 53586
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53487: LD_VAR 0 6
53491: PUSH
53492: LD_VAR 0 4
53496: ARRAY
53497: PUSH
53498: LD_INT 1
53500: ARRAY
53501: PPUSH
53502: LD_VAR 0 6
53506: PUSH
53507: LD_VAR 0 4
53511: ARRAY
53512: PUSH
53513: LD_INT 2
53515: ARRAY
53516: PPUSH
53517: CALL_OW 488
53521: NOT
53522: PUSH
53523: LD_VAR 0 6
53527: PUSH
53528: LD_VAR 0 4
53532: ARRAY
53533: PUSH
53534: LD_INT 1
53536: ARRAY
53537: PPUSH
53538: LD_VAR 0 6
53542: PUSH
53543: LD_VAR 0 4
53547: ARRAY
53548: PUSH
53549: LD_INT 2
53551: ARRAY
53552: PPUSH
53553: CALL_OW 428
53557: PUSH
53558: LD_INT 0
53560: NONEQUAL
53561: OR
53562: IFFALSE 53584
// tmp := Delete ( tmp , i ) ;
53564: LD_ADDR_VAR 0 6
53568: PUSH
53569: LD_VAR 0 6
53573: PPUSH
53574: LD_VAR 0 4
53578: PPUSH
53579: CALL_OW 3
53583: ST_TO_ADDR
53584: GO 53484
53586: POP
53587: POP
// j := GetClosestHex ( unit , tmp ) ;
53588: LD_ADDR_VAR 0 5
53592: PUSH
53593: LD_VAR 0 1
53597: PPUSH
53598: LD_VAR 0 6
53602: PPUSH
53603: CALL 52890 0 2
53607: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53608: LD_VAR 0 1
53612: PPUSH
53613: LD_VAR 0 5
53617: PUSH
53618: LD_INT 1
53620: ARRAY
53621: PPUSH
53622: LD_VAR 0 5
53626: PUSH
53627: LD_INT 2
53629: ARRAY
53630: PPUSH
53631: CALL_OW 111
// end ;
53635: LD_VAR 0 3
53639: RET
// export function PrepareApemanSoldier ( ) ; begin
53640: LD_INT 0
53642: PPUSH
// uc_nation := 0 ;
53643: LD_ADDR_OWVAR 21
53647: PUSH
53648: LD_INT 0
53650: ST_TO_ADDR
// hc_sex := sex_male ;
53651: LD_ADDR_OWVAR 27
53655: PUSH
53656: LD_INT 1
53658: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53659: LD_ADDR_OWVAR 28
53663: PUSH
53664: LD_INT 15
53666: ST_TO_ADDR
// hc_gallery :=  ;
53667: LD_ADDR_OWVAR 33
53671: PUSH
53672: LD_STRING 
53674: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53675: LD_ADDR_OWVAR 31
53679: PUSH
53680: LD_INT 0
53682: PPUSH
53683: LD_INT 3
53685: PPUSH
53686: CALL_OW 12
53690: PUSH
53691: LD_INT 0
53693: PPUSH
53694: LD_INT 3
53696: PPUSH
53697: CALL_OW 12
53701: PUSH
53702: LD_INT 0
53704: PUSH
53705: LD_INT 0
53707: PUSH
53708: EMPTY
53709: LIST
53710: LIST
53711: LIST
53712: LIST
53713: ST_TO_ADDR
// end ;
53714: LD_VAR 0 1
53718: RET
// export function PrepareApemanEngineer ( ) ; begin
53719: LD_INT 0
53721: PPUSH
// uc_nation := 0 ;
53722: LD_ADDR_OWVAR 21
53726: PUSH
53727: LD_INT 0
53729: ST_TO_ADDR
// hc_sex := sex_male ;
53730: LD_ADDR_OWVAR 27
53734: PUSH
53735: LD_INT 1
53737: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53738: LD_ADDR_OWVAR 28
53742: PUSH
53743: LD_INT 16
53745: ST_TO_ADDR
// hc_gallery :=  ;
53746: LD_ADDR_OWVAR 33
53750: PUSH
53751: LD_STRING 
53753: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53754: LD_ADDR_OWVAR 31
53758: PUSH
53759: LD_INT 0
53761: PPUSH
53762: LD_INT 3
53764: PPUSH
53765: CALL_OW 12
53769: PUSH
53770: LD_INT 0
53772: PPUSH
53773: LD_INT 3
53775: PPUSH
53776: CALL_OW 12
53780: PUSH
53781: LD_INT 0
53783: PUSH
53784: LD_INT 0
53786: PUSH
53787: EMPTY
53788: LIST
53789: LIST
53790: LIST
53791: LIST
53792: ST_TO_ADDR
// end ;
53793: LD_VAR 0 1
53797: RET
// export function PrepareApeman ( agressivity ) ; begin
53798: LD_INT 0
53800: PPUSH
// uc_side := 0 ;
53801: LD_ADDR_OWVAR 20
53805: PUSH
53806: LD_INT 0
53808: ST_TO_ADDR
// uc_nation := 0 ;
53809: LD_ADDR_OWVAR 21
53813: PUSH
53814: LD_INT 0
53816: ST_TO_ADDR
// hc_sex := sex_male ;
53817: LD_ADDR_OWVAR 27
53821: PUSH
53822: LD_INT 1
53824: ST_TO_ADDR
// hc_class := class_apeman ;
53825: LD_ADDR_OWVAR 28
53829: PUSH
53830: LD_INT 12
53832: ST_TO_ADDR
// hc_gallery :=  ;
53833: LD_ADDR_OWVAR 33
53837: PUSH
53838: LD_STRING 
53840: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53841: LD_ADDR_OWVAR 35
53845: PUSH
53846: LD_VAR 0 1
53850: NEG
53851: PPUSH
53852: LD_VAR 0 1
53856: PPUSH
53857: CALL_OW 12
53861: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53862: LD_ADDR_OWVAR 31
53866: PUSH
53867: LD_INT 0
53869: PPUSH
53870: LD_INT 3
53872: PPUSH
53873: CALL_OW 12
53877: PUSH
53878: LD_INT 0
53880: PPUSH
53881: LD_INT 3
53883: PPUSH
53884: CALL_OW 12
53888: PUSH
53889: LD_INT 0
53891: PUSH
53892: LD_INT 0
53894: PUSH
53895: EMPTY
53896: LIST
53897: LIST
53898: LIST
53899: LIST
53900: ST_TO_ADDR
// end ;
53901: LD_VAR 0 2
53905: RET
// export function PrepareTiger ( agressivity ) ; begin
53906: LD_INT 0
53908: PPUSH
// uc_side := 0 ;
53909: LD_ADDR_OWVAR 20
53913: PUSH
53914: LD_INT 0
53916: ST_TO_ADDR
// uc_nation := 0 ;
53917: LD_ADDR_OWVAR 21
53921: PUSH
53922: LD_INT 0
53924: ST_TO_ADDR
// hc_class := class_tiger ;
53925: LD_ADDR_OWVAR 28
53929: PUSH
53930: LD_INT 14
53932: ST_TO_ADDR
// hc_gallery :=  ;
53933: LD_ADDR_OWVAR 33
53937: PUSH
53938: LD_STRING 
53940: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53941: LD_ADDR_OWVAR 35
53945: PUSH
53946: LD_VAR 0 1
53950: NEG
53951: PPUSH
53952: LD_VAR 0 1
53956: PPUSH
53957: CALL_OW 12
53961: ST_TO_ADDR
// end ;
53962: LD_VAR 0 2
53966: RET
// export function PrepareEnchidna ( ) ; begin
53967: LD_INT 0
53969: PPUSH
// uc_side := 0 ;
53970: LD_ADDR_OWVAR 20
53974: PUSH
53975: LD_INT 0
53977: ST_TO_ADDR
// uc_nation := 0 ;
53978: LD_ADDR_OWVAR 21
53982: PUSH
53983: LD_INT 0
53985: ST_TO_ADDR
// hc_class := class_baggie ;
53986: LD_ADDR_OWVAR 28
53990: PUSH
53991: LD_INT 13
53993: ST_TO_ADDR
// hc_gallery :=  ;
53994: LD_ADDR_OWVAR 33
53998: PUSH
53999: LD_STRING 
54001: ST_TO_ADDR
// end ;
54002: LD_VAR 0 1
54006: RET
// export function PrepareFrog ( ) ; begin
54007: LD_INT 0
54009: PPUSH
// uc_side := 0 ;
54010: LD_ADDR_OWVAR 20
54014: PUSH
54015: LD_INT 0
54017: ST_TO_ADDR
// uc_nation := 0 ;
54018: LD_ADDR_OWVAR 21
54022: PUSH
54023: LD_INT 0
54025: ST_TO_ADDR
// hc_class := class_frog ;
54026: LD_ADDR_OWVAR 28
54030: PUSH
54031: LD_INT 19
54033: ST_TO_ADDR
// hc_gallery :=  ;
54034: LD_ADDR_OWVAR 33
54038: PUSH
54039: LD_STRING 
54041: ST_TO_ADDR
// end ;
54042: LD_VAR 0 1
54046: RET
// export function PrepareFish ( ) ; begin
54047: LD_INT 0
54049: PPUSH
// uc_side := 0 ;
54050: LD_ADDR_OWVAR 20
54054: PUSH
54055: LD_INT 0
54057: ST_TO_ADDR
// uc_nation := 0 ;
54058: LD_ADDR_OWVAR 21
54062: PUSH
54063: LD_INT 0
54065: ST_TO_ADDR
// hc_class := class_fish ;
54066: LD_ADDR_OWVAR 28
54070: PUSH
54071: LD_INT 20
54073: ST_TO_ADDR
// hc_gallery :=  ;
54074: LD_ADDR_OWVAR 33
54078: PUSH
54079: LD_STRING 
54081: ST_TO_ADDR
// end ;
54082: LD_VAR 0 1
54086: RET
// export function PrepareBird ( ) ; begin
54087: LD_INT 0
54089: PPUSH
// uc_side := 0 ;
54090: LD_ADDR_OWVAR 20
54094: PUSH
54095: LD_INT 0
54097: ST_TO_ADDR
// uc_nation := 0 ;
54098: LD_ADDR_OWVAR 21
54102: PUSH
54103: LD_INT 0
54105: ST_TO_ADDR
// hc_class := class_phororhacos ;
54106: LD_ADDR_OWVAR 28
54110: PUSH
54111: LD_INT 18
54113: ST_TO_ADDR
// hc_gallery :=  ;
54114: LD_ADDR_OWVAR 33
54118: PUSH
54119: LD_STRING 
54121: ST_TO_ADDR
// end ;
54122: LD_VAR 0 1
54126: RET
// export function PrepareHorse ( ) ; begin
54127: LD_INT 0
54129: PPUSH
// uc_side := 0 ;
54130: LD_ADDR_OWVAR 20
54134: PUSH
54135: LD_INT 0
54137: ST_TO_ADDR
// uc_nation := 0 ;
54138: LD_ADDR_OWVAR 21
54142: PUSH
54143: LD_INT 0
54145: ST_TO_ADDR
// hc_class := class_horse ;
54146: LD_ADDR_OWVAR 28
54150: PUSH
54151: LD_INT 21
54153: ST_TO_ADDR
// hc_gallery :=  ;
54154: LD_ADDR_OWVAR 33
54158: PUSH
54159: LD_STRING 
54161: ST_TO_ADDR
// end ;
54162: LD_VAR 0 1
54166: RET
// export function PrepareMastodont ( ) ; begin
54167: LD_INT 0
54169: PPUSH
// uc_side := 0 ;
54170: LD_ADDR_OWVAR 20
54174: PUSH
54175: LD_INT 0
54177: ST_TO_ADDR
// uc_nation := 0 ;
54178: LD_ADDR_OWVAR 21
54182: PUSH
54183: LD_INT 0
54185: ST_TO_ADDR
// vc_chassis := class_mastodont ;
54186: LD_ADDR_OWVAR 37
54190: PUSH
54191: LD_INT 31
54193: ST_TO_ADDR
// vc_control := control_rider ;
54194: LD_ADDR_OWVAR 38
54198: PUSH
54199: LD_INT 4
54201: ST_TO_ADDR
// end ;
54202: LD_VAR 0 1
54206: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54207: LD_INT 0
54209: PPUSH
54210: PPUSH
54211: PPUSH
// uc_side = 0 ;
54212: LD_ADDR_OWVAR 20
54216: PUSH
54217: LD_INT 0
54219: ST_TO_ADDR
// uc_nation = 0 ;
54220: LD_ADDR_OWVAR 21
54224: PUSH
54225: LD_INT 0
54227: ST_TO_ADDR
// InitHc_All ( ) ;
54228: CALL_OW 584
// InitVc ;
54232: CALL_OW 20
// if mastodonts then
54236: LD_VAR 0 6
54240: IFFALSE 54307
// for i = 1 to mastodonts do
54242: LD_ADDR_VAR 0 11
54246: PUSH
54247: DOUBLE
54248: LD_INT 1
54250: DEC
54251: ST_TO_ADDR
54252: LD_VAR 0 6
54256: PUSH
54257: FOR_TO
54258: IFFALSE 54305
// begin vc_chassis := 31 ;
54260: LD_ADDR_OWVAR 37
54264: PUSH
54265: LD_INT 31
54267: ST_TO_ADDR
// vc_control := control_rider ;
54268: LD_ADDR_OWVAR 38
54272: PUSH
54273: LD_INT 4
54275: ST_TO_ADDR
// animal := CreateVehicle ;
54276: LD_ADDR_VAR 0 12
54280: PUSH
54281: CALL_OW 45
54285: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54286: LD_VAR 0 12
54290: PPUSH
54291: LD_VAR 0 8
54295: PPUSH
54296: LD_INT 0
54298: PPUSH
54299: CALL 56435 0 3
// end ;
54303: GO 54257
54305: POP
54306: POP
// if horses then
54307: LD_VAR 0 5
54311: IFFALSE 54378
// for i = 1 to horses do
54313: LD_ADDR_VAR 0 11
54317: PUSH
54318: DOUBLE
54319: LD_INT 1
54321: DEC
54322: ST_TO_ADDR
54323: LD_VAR 0 5
54327: PUSH
54328: FOR_TO
54329: IFFALSE 54376
// begin hc_class := 21 ;
54331: LD_ADDR_OWVAR 28
54335: PUSH
54336: LD_INT 21
54338: ST_TO_ADDR
// hc_gallery :=  ;
54339: LD_ADDR_OWVAR 33
54343: PUSH
54344: LD_STRING 
54346: ST_TO_ADDR
// animal := CreateHuman ;
54347: LD_ADDR_VAR 0 12
54351: PUSH
54352: CALL_OW 44
54356: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54357: LD_VAR 0 12
54361: PPUSH
54362: LD_VAR 0 8
54366: PPUSH
54367: LD_INT 0
54369: PPUSH
54370: CALL 56435 0 3
// end ;
54374: GO 54328
54376: POP
54377: POP
// if birds then
54378: LD_VAR 0 1
54382: IFFALSE 54449
// for i = 1 to birds do
54384: LD_ADDR_VAR 0 11
54388: PUSH
54389: DOUBLE
54390: LD_INT 1
54392: DEC
54393: ST_TO_ADDR
54394: LD_VAR 0 1
54398: PUSH
54399: FOR_TO
54400: IFFALSE 54447
// begin hc_class := 18 ;
54402: LD_ADDR_OWVAR 28
54406: PUSH
54407: LD_INT 18
54409: ST_TO_ADDR
// hc_gallery =  ;
54410: LD_ADDR_OWVAR 33
54414: PUSH
54415: LD_STRING 
54417: ST_TO_ADDR
// animal := CreateHuman ;
54418: LD_ADDR_VAR 0 12
54422: PUSH
54423: CALL_OW 44
54427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54428: LD_VAR 0 12
54432: PPUSH
54433: LD_VAR 0 8
54437: PPUSH
54438: LD_INT 0
54440: PPUSH
54441: CALL 56435 0 3
// end ;
54445: GO 54399
54447: POP
54448: POP
// if tigers then
54449: LD_VAR 0 2
54453: IFFALSE 54537
// for i = 1 to tigers do
54455: LD_ADDR_VAR 0 11
54459: PUSH
54460: DOUBLE
54461: LD_INT 1
54463: DEC
54464: ST_TO_ADDR
54465: LD_VAR 0 2
54469: PUSH
54470: FOR_TO
54471: IFFALSE 54535
// begin hc_class = class_tiger ;
54473: LD_ADDR_OWVAR 28
54477: PUSH
54478: LD_INT 14
54480: ST_TO_ADDR
// hc_gallery =  ;
54481: LD_ADDR_OWVAR 33
54485: PUSH
54486: LD_STRING 
54488: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54489: LD_ADDR_OWVAR 35
54493: PUSH
54494: LD_INT 7
54496: NEG
54497: PPUSH
54498: LD_INT 7
54500: PPUSH
54501: CALL_OW 12
54505: ST_TO_ADDR
// animal := CreateHuman ;
54506: LD_ADDR_VAR 0 12
54510: PUSH
54511: CALL_OW 44
54515: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54516: LD_VAR 0 12
54520: PPUSH
54521: LD_VAR 0 8
54525: PPUSH
54526: LD_INT 0
54528: PPUSH
54529: CALL 56435 0 3
// end ;
54533: GO 54470
54535: POP
54536: POP
// if apemans then
54537: LD_VAR 0 3
54541: IFFALSE 54664
// for i = 1 to apemans do
54543: LD_ADDR_VAR 0 11
54547: PUSH
54548: DOUBLE
54549: LD_INT 1
54551: DEC
54552: ST_TO_ADDR
54553: LD_VAR 0 3
54557: PUSH
54558: FOR_TO
54559: IFFALSE 54662
// begin hc_class = class_apeman ;
54561: LD_ADDR_OWVAR 28
54565: PUSH
54566: LD_INT 12
54568: ST_TO_ADDR
// hc_gallery =  ;
54569: LD_ADDR_OWVAR 33
54573: PUSH
54574: LD_STRING 
54576: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54577: LD_ADDR_OWVAR 35
54581: PUSH
54582: LD_INT 2
54584: NEG
54585: PPUSH
54586: LD_INT 2
54588: PPUSH
54589: CALL_OW 12
54593: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54594: LD_ADDR_OWVAR 31
54598: PUSH
54599: LD_INT 1
54601: PPUSH
54602: LD_INT 3
54604: PPUSH
54605: CALL_OW 12
54609: PUSH
54610: LD_INT 1
54612: PPUSH
54613: LD_INT 3
54615: PPUSH
54616: CALL_OW 12
54620: PUSH
54621: LD_INT 0
54623: PUSH
54624: LD_INT 0
54626: PUSH
54627: EMPTY
54628: LIST
54629: LIST
54630: LIST
54631: LIST
54632: ST_TO_ADDR
// animal := CreateHuman ;
54633: LD_ADDR_VAR 0 12
54637: PUSH
54638: CALL_OW 44
54642: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54643: LD_VAR 0 12
54647: PPUSH
54648: LD_VAR 0 8
54652: PPUSH
54653: LD_INT 0
54655: PPUSH
54656: CALL 56435 0 3
// end ;
54660: GO 54558
54662: POP
54663: POP
// if enchidnas then
54664: LD_VAR 0 4
54668: IFFALSE 54735
// for i = 1 to enchidnas do
54670: LD_ADDR_VAR 0 11
54674: PUSH
54675: DOUBLE
54676: LD_INT 1
54678: DEC
54679: ST_TO_ADDR
54680: LD_VAR 0 4
54684: PUSH
54685: FOR_TO
54686: IFFALSE 54733
// begin hc_class = 13 ;
54688: LD_ADDR_OWVAR 28
54692: PUSH
54693: LD_INT 13
54695: ST_TO_ADDR
// hc_gallery =  ;
54696: LD_ADDR_OWVAR 33
54700: PUSH
54701: LD_STRING 
54703: ST_TO_ADDR
// animal := CreateHuman ;
54704: LD_ADDR_VAR 0 12
54708: PUSH
54709: CALL_OW 44
54713: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54714: LD_VAR 0 12
54718: PPUSH
54719: LD_VAR 0 8
54723: PPUSH
54724: LD_INT 0
54726: PPUSH
54727: CALL 56435 0 3
// end ;
54731: GO 54685
54733: POP
54734: POP
// if fishes then
54735: LD_VAR 0 7
54739: IFFALSE 54806
// for i = 1 to fishes do
54741: LD_ADDR_VAR 0 11
54745: PUSH
54746: DOUBLE
54747: LD_INT 1
54749: DEC
54750: ST_TO_ADDR
54751: LD_VAR 0 7
54755: PUSH
54756: FOR_TO
54757: IFFALSE 54804
// begin hc_class = 20 ;
54759: LD_ADDR_OWVAR 28
54763: PUSH
54764: LD_INT 20
54766: ST_TO_ADDR
// hc_gallery =  ;
54767: LD_ADDR_OWVAR 33
54771: PUSH
54772: LD_STRING 
54774: ST_TO_ADDR
// animal := CreateHuman ;
54775: LD_ADDR_VAR 0 12
54779: PUSH
54780: CALL_OW 44
54784: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54785: LD_VAR 0 12
54789: PPUSH
54790: LD_VAR 0 9
54794: PPUSH
54795: LD_INT 0
54797: PPUSH
54798: CALL 56435 0 3
// end ;
54802: GO 54756
54804: POP
54805: POP
// end ;
54806: LD_VAR 0 10
54810: RET
// export function WantHeal ( sci , unit ) ; begin
54811: LD_INT 0
54813: PPUSH
// if GetTaskList ( sci ) > 0 then
54814: LD_VAR 0 1
54818: PPUSH
54819: CALL_OW 437
54823: PUSH
54824: LD_INT 0
54826: GREATER
54827: IFFALSE 54897
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54829: LD_VAR 0 1
54833: PPUSH
54834: CALL_OW 437
54838: PUSH
54839: LD_INT 1
54841: ARRAY
54842: PUSH
54843: LD_INT 1
54845: ARRAY
54846: PUSH
54847: LD_STRING l
54849: EQUAL
54850: PUSH
54851: LD_VAR 0 1
54855: PPUSH
54856: CALL_OW 437
54860: PUSH
54861: LD_INT 1
54863: ARRAY
54864: PUSH
54865: LD_INT 4
54867: ARRAY
54868: PUSH
54869: LD_VAR 0 2
54873: EQUAL
54874: AND
54875: IFFALSE 54887
// result := true else
54877: LD_ADDR_VAR 0 3
54881: PUSH
54882: LD_INT 1
54884: ST_TO_ADDR
54885: GO 54895
// result := false ;
54887: LD_ADDR_VAR 0 3
54891: PUSH
54892: LD_INT 0
54894: ST_TO_ADDR
// end else
54895: GO 54905
// result := false ;
54897: LD_ADDR_VAR 0 3
54901: PUSH
54902: LD_INT 0
54904: ST_TO_ADDR
// end ;
54905: LD_VAR 0 3
54909: RET
// export function HealTarget ( sci ) ; begin
54910: LD_INT 0
54912: PPUSH
// if not sci then
54913: LD_VAR 0 1
54917: NOT
54918: IFFALSE 54922
// exit ;
54920: GO 54987
// result := 0 ;
54922: LD_ADDR_VAR 0 2
54926: PUSH
54927: LD_INT 0
54929: ST_TO_ADDR
// if GetTaskList ( sci ) then
54930: LD_VAR 0 1
54934: PPUSH
54935: CALL_OW 437
54939: IFFALSE 54987
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54941: LD_VAR 0 1
54945: PPUSH
54946: CALL_OW 437
54950: PUSH
54951: LD_INT 1
54953: ARRAY
54954: PUSH
54955: LD_INT 1
54957: ARRAY
54958: PUSH
54959: LD_STRING l
54961: EQUAL
54962: IFFALSE 54987
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54964: LD_ADDR_VAR 0 2
54968: PUSH
54969: LD_VAR 0 1
54973: PPUSH
54974: CALL_OW 437
54978: PUSH
54979: LD_INT 1
54981: ARRAY
54982: PUSH
54983: LD_INT 4
54985: ARRAY
54986: ST_TO_ADDR
// end ;
54987: LD_VAR 0 2
54991: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54992: LD_INT 0
54994: PPUSH
54995: PPUSH
54996: PPUSH
54997: PPUSH
// if not base_units then
54998: LD_VAR 0 1
55002: NOT
55003: IFFALSE 55007
// exit ;
55005: GO 55094
// result := false ;
55007: LD_ADDR_VAR 0 2
55011: PUSH
55012: LD_INT 0
55014: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
55015: LD_ADDR_VAR 0 5
55019: PUSH
55020: LD_VAR 0 1
55024: PPUSH
55025: LD_INT 21
55027: PUSH
55028: LD_INT 3
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: PPUSH
55035: CALL_OW 72
55039: ST_TO_ADDR
// if not tmp then
55040: LD_VAR 0 5
55044: NOT
55045: IFFALSE 55049
// exit ;
55047: GO 55094
// for i in tmp do
55049: LD_ADDR_VAR 0 3
55053: PUSH
55054: LD_VAR 0 5
55058: PUSH
55059: FOR_IN
55060: IFFALSE 55092
// begin result := EnemyInRange ( i , 22 ) ;
55062: LD_ADDR_VAR 0 2
55066: PUSH
55067: LD_VAR 0 3
55071: PPUSH
55072: LD_INT 22
55074: PPUSH
55075: CALL 52692 0 2
55079: ST_TO_ADDR
// if result then
55080: LD_VAR 0 2
55084: IFFALSE 55090
// exit ;
55086: POP
55087: POP
55088: GO 55094
// end ;
55090: GO 55059
55092: POP
55093: POP
// end ;
55094: LD_VAR 0 2
55098: RET
// export function FilterByTag ( units , tag ) ; begin
55099: LD_INT 0
55101: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
55102: LD_ADDR_VAR 0 3
55106: PUSH
55107: LD_VAR 0 1
55111: PPUSH
55112: LD_INT 120
55114: PUSH
55115: LD_VAR 0 2
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: PPUSH
55124: CALL_OW 72
55128: ST_TO_ADDR
// end ;
55129: LD_VAR 0 3
55133: RET
// export function IsDriver ( un ) ; begin
55134: LD_INT 0
55136: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
55137: LD_ADDR_VAR 0 2
55141: PUSH
55142: LD_VAR 0 1
55146: PUSH
55147: LD_INT 55
55149: PUSH
55150: EMPTY
55151: LIST
55152: PPUSH
55153: CALL_OW 69
55157: IN
55158: ST_TO_ADDR
// end ;
55159: LD_VAR 0 2
55163: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
55164: LD_INT 0
55166: PPUSH
55167: PPUSH
// list := [ ] ;
55168: LD_ADDR_VAR 0 5
55172: PUSH
55173: EMPTY
55174: ST_TO_ADDR
// case d of 0 :
55175: LD_VAR 0 3
55179: PUSH
55180: LD_INT 0
55182: DOUBLE
55183: EQUAL
55184: IFTRUE 55188
55186: GO 55321
55188: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55189: LD_ADDR_VAR 0 5
55193: PUSH
55194: LD_VAR 0 1
55198: PUSH
55199: LD_INT 4
55201: MINUS
55202: PUSH
55203: LD_VAR 0 2
55207: PUSH
55208: LD_INT 4
55210: MINUS
55211: PUSH
55212: LD_INT 2
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: LIST
55219: PUSH
55220: LD_VAR 0 1
55224: PUSH
55225: LD_INT 3
55227: MINUS
55228: PUSH
55229: LD_VAR 0 2
55233: PUSH
55234: LD_INT 1
55236: PUSH
55237: EMPTY
55238: LIST
55239: LIST
55240: LIST
55241: PUSH
55242: LD_VAR 0 1
55246: PUSH
55247: LD_INT 4
55249: PLUS
55250: PUSH
55251: LD_VAR 0 2
55255: PUSH
55256: LD_INT 4
55258: PUSH
55259: EMPTY
55260: LIST
55261: LIST
55262: LIST
55263: PUSH
55264: LD_VAR 0 1
55268: PUSH
55269: LD_INT 3
55271: PLUS
55272: PUSH
55273: LD_VAR 0 2
55277: PUSH
55278: LD_INT 3
55280: PLUS
55281: PUSH
55282: LD_INT 5
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: LIST
55289: PUSH
55290: LD_VAR 0 1
55294: PUSH
55295: LD_VAR 0 2
55299: PUSH
55300: LD_INT 4
55302: PLUS
55303: PUSH
55304: LD_INT 0
55306: PUSH
55307: EMPTY
55308: LIST
55309: LIST
55310: LIST
55311: PUSH
55312: EMPTY
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: LIST
55318: ST_TO_ADDR
// end ; 1 :
55319: GO 56019
55321: LD_INT 1
55323: DOUBLE
55324: EQUAL
55325: IFTRUE 55329
55327: GO 55462
55329: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55330: LD_ADDR_VAR 0 5
55334: PUSH
55335: LD_VAR 0 1
55339: PUSH
55340: LD_VAR 0 2
55344: PUSH
55345: LD_INT 4
55347: MINUS
55348: PUSH
55349: LD_INT 3
55351: PUSH
55352: EMPTY
55353: LIST
55354: LIST
55355: LIST
55356: PUSH
55357: LD_VAR 0 1
55361: PUSH
55362: LD_INT 3
55364: MINUS
55365: PUSH
55366: LD_VAR 0 2
55370: PUSH
55371: LD_INT 3
55373: MINUS
55374: PUSH
55375: LD_INT 2
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: LIST
55382: PUSH
55383: LD_VAR 0 1
55387: PUSH
55388: LD_INT 4
55390: MINUS
55391: PUSH
55392: LD_VAR 0 2
55396: PUSH
55397: LD_INT 1
55399: PUSH
55400: EMPTY
55401: LIST
55402: LIST
55403: LIST
55404: PUSH
55405: LD_VAR 0 1
55409: PUSH
55410: LD_VAR 0 2
55414: PUSH
55415: LD_INT 3
55417: PLUS
55418: PUSH
55419: LD_INT 0
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: LIST
55426: PUSH
55427: LD_VAR 0 1
55431: PUSH
55432: LD_INT 4
55434: PLUS
55435: PUSH
55436: LD_VAR 0 2
55440: PUSH
55441: LD_INT 4
55443: PLUS
55444: PUSH
55445: LD_INT 5
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: LIST
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: LIST
55457: LIST
55458: LIST
55459: ST_TO_ADDR
// end ; 2 :
55460: GO 56019
55462: LD_INT 2
55464: DOUBLE
55465: EQUAL
55466: IFTRUE 55470
55468: GO 55599
55470: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55471: LD_ADDR_VAR 0 5
55475: PUSH
55476: LD_VAR 0 1
55480: PUSH
55481: LD_VAR 0 2
55485: PUSH
55486: LD_INT 3
55488: MINUS
55489: PUSH
55490: LD_INT 3
55492: PUSH
55493: EMPTY
55494: LIST
55495: LIST
55496: LIST
55497: PUSH
55498: LD_VAR 0 1
55502: PUSH
55503: LD_INT 4
55505: PLUS
55506: PUSH
55507: LD_VAR 0 2
55511: PUSH
55512: LD_INT 4
55514: PUSH
55515: EMPTY
55516: LIST
55517: LIST
55518: LIST
55519: PUSH
55520: LD_VAR 0 1
55524: PUSH
55525: LD_VAR 0 2
55529: PUSH
55530: LD_INT 4
55532: PLUS
55533: PUSH
55534: LD_INT 0
55536: PUSH
55537: EMPTY
55538: LIST
55539: LIST
55540: LIST
55541: PUSH
55542: LD_VAR 0 1
55546: PUSH
55547: LD_INT 3
55549: MINUS
55550: PUSH
55551: LD_VAR 0 2
55555: PUSH
55556: LD_INT 1
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: LIST
55563: PUSH
55564: LD_VAR 0 1
55568: PUSH
55569: LD_INT 4
55571: MINUS
55572: PUSH
55573: LD_VAR 0 2
55577: PUSH
55578: LD_INT 4
55580: MINUS
55581: PUSH
55582: LD_INT 2
55584: PUSH
55585: EMPTY
55586: LIST
55587: LIST
55588: LIST
55589: PUSH
55590: EMPTY
55591: LIST
55592: LIST
55593: LIST
55594: LIST
55595: LIST
55596: ST_TO_ADDR
// end ; 3 :
55597: GO 56019
55599: LD_INT 3
55601: DOUBLE
55602: EQUAL
55603: IFTRUE 55607
55605: GO 55740
55607: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55608: LD_ADDR_VAR 0 5
55612: PUSH
55613: LD_VAR 0 1
55617: PUSH
55618: LD_INT 3
55620: PLUS
55621: PUSH
55622: LD_VAR 0 2
55626: PUSH
55627: LD_INT 4
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: LIST
55634: PUSH
55635: LD_VAR 0 1
55639: PUSH
55640: LD_INT 4
55642: PLUS
55643: PUSH
55644: LD_VAR 0 2
55648: PUSH
55649: LD_INT 4
55651: PLUS
55652: PUSH
55653: LD_INT 5
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: LIST
55660: PUSH
55661: LD_VAR 0 1
55665: PUSH
55666: LD_INT 4
55668: MINUS
55669: PUSH
55670: LD_VAR 0 2
55674: PUSH
55675: LD_INT 1
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: LIST
55682: PUSH
55683: LD_VAR 0 1
55687: PUSH
55688: LD_VAR 0 2
55692: PUSH
55693: LD_INT 4
55695: MINUS
55696: PUSH
55697: LD_INT 3
55699: PUSH
55700: EMPTY
55701: LIST
55702: LIST
55703: LIST
55704: PUSH
55705: LD_VAR 0 1
55709: PUSH
55710: LD_INT 3
55712: MINUS
55713: PUSH
55714: LD_VAR 0 2
55718: PUSH
55719: LD_INT 3
55721: MINUS
55722: PUSH
55723: LD_INT 2
55725: PUSH
55726: EMPTY
55727: LIST
55728: LIST
55729: LIST
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: LIST
55735: LIST
55736: LIST
55737: ST_TO_ADDR
// end ; 4 :
55738: GO 56019
55740: LD_INT 4
55742: DOUBLE
55743: EQUAL
55744: IFTRUE 55748
55746: GO 55881
55748: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55749: LD_ADDR_VAR 0 5
55753: PUSH
55754: LD_VAR 0 1
55758: PUSH
55759: LD_VAR 0 2
55763: PUSH
55764: LD_INT 4
55766: PLUS
55767: PUSH
55768: LD_INT 0
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: LIST
55775: PUSH
55776: LD_VAR 0 1
55780: PUSH
55781: LD_INT 3
55783: PLUS
55784: PUSH
55785: LD_VAR 0 2
55789: PUSH
55790: LD_INT 3
55792: PLUS
55793: PUSH
55794: LD_INT 5
55796: PUSH
55797: EMPTY
55798: LIST
55799: LIST
55800: LIST
55801: PUSH
55802: LD_VAR 0 1
55806: PUSH
55807: LD_INT 4
55809: PLUS
55810: PUSH
55811: LD_VAR 0 2
55815: PUSH
55816: LD_INT 4
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: PUSH
55824: LD_VAR 0 1
55828: PUSH
55829: LD_VAR 0 2
55833: PUSH
55834: LD_INT 3
55836: MINUS
55837: PUSH
55838: LD_INT 3
55840: PUSH
55841: EMPTY
55842: LIST
55843: LIST
55844: LIST
55845: PUSH
55846: LD_VAR 0 1
55850: PUSH
55851: LD_INT 4
55853: MINUS
55854: PUSH
55855: LD_VAR 0 2
55859: PUSH
55860: LD_INT 4
55862: MINUS
55863: PUSH
55864: LD_INT 2
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: LIST
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: LIST
55876: LIST
55877: LIST
55878: ST_TO_ADDR
// end ; 5 :
55879: GO 56019
55881: LD_INT 5
55883: DOUBLE
55884: EQUAL
55885: IFTRUE 55889
55887: GO 56018
55889: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55890: LD_ADDR_VAR 0 5
55894: PUSH
55895: LD_VAR 0 1
55899: PUSH
55900: LD_INT 4
55902: MINUS
55903: PUSH
55904: LD_VAR 0 2
55908: PUSH
55909: LD_INT 1
55911: PUSH
55912: EMPTY
55913: LIST
55914: LIST
55915: LIST
55916: PUSH
55917: LD_VAR 0 1
55921: PUSH
55922: LD_VAR 0 2
55926: PUSH
55927: LD_INT 4
55929: MINUS
55930: PUSH
55931: LD_INT 3
55933: PUSH
55934: EMPTY
55935: LIST
55936: LIST
55937: LIST
55938: PUSH
55939: LD_VAR 0 1
55943: PUSH
55944: LD_INT 4
55946: PLUS
55947: PUSH
55948: LD_VAR 0 2
55952: PUSH
55953: LD_INT 4
55955: PLUS
55956: PUSH
55957: LD_INT 5
55959: PUSH
55960: EMPTY
55961: LIST
55962: LIST
55963: LIST
55964: PUSH
55965: LD_VAR 0 1
55969: PUSH
55970: LD_INT 3
55972: PLUS
55973: PUSH
55974: LD_VAR 0 2
55978: PUSH
55979: LD_INT 4
55981: PUSH
55982: EMPTY
55983: LIST
55984: LIST
55985: LIST
55986: PUSH
55987: LD_VAR 0 1
55991: PUSH
55992: LD_VAR 0 2
55996: PUSH
55997: LD_INT 3
55999: PLUS
56000: PUSH
56001: LD_INT 0
56003: PUSH
56004: EMPTY
56005: LIST
56006: LIST
56007: LIST
56008: PUSH
56009: EMPTY
56010: LIST
56011: LIST
56012: LIST
56013: LIST
56014: LIST
56015: ST_TO_ADDR
// end ; end ;
56016: GO 56019
56018: POP
// result := list ;
56019: LD_ADDR_VAR 0 4
56023: PUSH
56024: LD_VAR 0 5
56028: ST_TO_ADDR
// end ;
56029: LD_VAR 0 4
56033: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
56034: LD_INT 0
56036: PPUSH
56037: PPUSH
56038: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
56039: LD_VAR 0 1
56043: NOT
56044: PUSH
56045: LD_VAR 0 2
56049: PUSH
56050: LD_INT 1
56052: PUSH
56053: LD_INT 2
56055: PUSH
56056: LD_INT 3
56058: PUSH
56059: LD_INT 4
56061: PUSH
56062: EMPTY
56063: LIST
56064: LIST
56065: LIST
56066: LIST
56067: IN
56068: NOT
56069: OR
56070: IFFALSE 56074
// exit ;
56072: GO 56157
// tmp := [ ] ;
56074: LD_ADDR_VAR 0 5
56078: PUSH
56079: EMPTY
56080: ST_TO_ADDR
// for i in units do
56081: LD_ADDR_VAR 0 4
56085: PUSH
56086: LD_VAR 0 1
56090: PUSH
56091: FOR_IN
56092: IFFALSE 56126
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
56094: LD_ADDR_VAR 0 5
56098: PUSH
56099: LD_VAR 0 5
56103: PPUSH
56104: LD_VAR 0 4
56108: PPUSH
56109: LD_VAR 0 2
56113: PPUSH
56114: CALL_OW 259
56118: PPUSH
56119: CALL 57530 0 2
56123: ST_TO_ADDR
56124: GO 56091
56126: POP
56127: POP
// if not tmp then
56128: LD_VAR 0 5
56132: NOT
56133: IFFALSE 56137
// exit ;
56135: GO 56157
// result := SortListByListDesc ( units , tmp ) ;
56137: LD_ADDR_VAR 0 3
56141: PUSH
56142: LD_VAR 0 1
56146: PPUSH
56147: LD_VAR 0 5
56151: PPUSH
56152: CALL_OW 77
56156: ST_TO_ADDR
// end ;
56157: LD_VAR 0 3
56161: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
56162: LD_INT 0
56164: PPUSH
56165: PPUSH
56166: PPUSH
// result := false ;
56167: LD_ADDR_VAR 0 3
56171: PUSH
56172: LD_INT 0
56174: ST_TO_ADDR
// if not building then
56175: LD_VAR 0 2
56179: NOT
56180: IFFALSE 56184
// exit ;
56182: GO 56322
// x := GetX ( building ) ;
56184: LD_ADDR_VAR 0 4
56188: PUSH
56189: LD_VAR 0 2
56193: PPUSH
56194: CALL_OW 250
56198: ST_TO_ADDR
// y := GetY ( building ) ;
56199: LD_ADDR_VAR 0 5
56203: PUSH
56204: LD_VAR 0 2
56208: PPUSH
56209: CALL_OW 251
56213: ST_TO_ADDR
// if not x or not y then
56214: LD_VAR 0 4
56218: NOT
56219: PUSH
56220: LD_VAR 0 5
56224: NOT
56225: OR
56226: IFFALSE 56230
// exit ;
56228: GO 56322
// if GetTaskList ( unit ) then
56230: LD_VAR 0 1
56234: PPUSH
56235: CALL_OW 437
56239: IFFALSE 56322
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56241: LD_STRING e
56243: PUSH
56244: LD_VAR 0 1
56248: PPUSH
56249: CALL_OW 437
56253: PUSH
56254: LD_INT 1
56256: ARRAY
56257: PUSH
56258: LD_INT 1
56260: ARRAY
56261: EQUAL
56262: PUSH
56263: LD_VAR 0 4
56267: PUSH
56268: LD_VAR 0 1
56272: PPUSH
56273: CALL_OW 437
56277: PUSH
56278: LD_INT 1
56280: ARRAY
56281: PUSH
56282: LD_INT 2
56284: ARRAY
56285: EQUAL
56286: AND
56287: PUSH
56288: LD_VAR 0 5
56292: PUSH
56293: LD_VAR 0 1
56297: PPUSH
56298: CALL_OW 437
56302: PUSH
56303: LD_INT 1
56305: ARRAY
56306: PUSH
56307: LD_INT 3
56309: ARRAY
56310: EQUAL
56311: AND
56312: IFFALSE 56322
// result := true end ;
56314: LD_ADDR_VAR 0 3
56318: PUSH
56319: LD_INT 1
56321: ST_TO_ADDR
// end ;
56322: LD_VAR 0 3
56326: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56327: LD_INT 0
56329: PPUSH
// result := false ;
56330: LD_ADDR_VAR 0 4
56334: PUSH
56335: LD_INT 0
56337: ST_TO_ADDR
// if GetTaskList ( unit ) then
56338: LD_VAR 0 1
56342: PPUSH
56343: CALL_OW 437
56347: IFFALSE 56430
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56349: LD_STRING M
56351: PUSH
56352: LD_VAR 0 1
56356: PPUSH
56357: CALL_OW 437
56361: PUSH
56362: LD_INT 1
56364: ARRAY
56365: PUSH
56366: LD_INT 1
56368: ARRAY
56369: EQUAL
56370: PUSH
56371: LD_VAR 0 2
56375: PUSH
56376: LD_VAR 0 1
56380: PPUSH
56381: CALL_OW 437
56385: PUSH
56386: LD_INT 1
56388: ARRAY
56389: PUSH
56390: LD_INT 2
56392: ARRAY
56393: EQUAL
56394: AND
56395: PUSH
56396: LD_VAR 0 3
56400: PUSH
56401: LD_VAR 0 1
56405: PPUSH
56406: CALL_OW 437
56410: PUSH
56411: LD_INT 1
56413: ARRAY
56414: PUSH
56415: LD_INT 3
56417: ARRAY
56418: EQUAL
56419: AND
56420: IFFALSE 56430
// result := true ;
56422: LD_ADDR_VAR 0 4
56426: PUSH
56427: LD_INT 1
56429: ST_TO_ADDR
// end ; end ;
56430: LD_VAR 0 4
56434: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56435: LD_INT 0
56437: PPUSH
56438: PPUSH
56439: PPUSH
56440: PPUSH
// if not unit or not area then
56441: LD_VAR 0 1
56445: NOT
56446: PUSH
56447: LD_VAR 0 2
56451: NOT
56452: OR
56453: IFFALSE 56457
// exit ;
56455: GO 56633
// tmp := AreaToList ( area , i ) ;
56457: LD_ADDR_VAR 0 6
56461: PUSH
56462: LD_VAR 0 2
56466: PPUSH
56467: LD_VAR 0 5
56471: PPUSH
56472: CALL_OW 517
56476: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56477: LD_ADDR_VAR 0 5
56481: PUSH
56482: DOUBLE
56483: LD_INT 1
56485: DEC
56486: ST_TO_ADDR
56487: LD_VAR 0 6
56491: PUSH
56492: LD_INT 1
56494: ARRAY
56495: PUSH
56496: FOR_TO
56497: IFFALSE 56631
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56499: LD_ADDR_VAR 0 7
56503: PUSH
56504: LD_VAR 0 6
56508: PUSH
56509: LD_INT 1
56511: ARRAY
56512: PUSH
56513: LD_VAR 0 5
56517: ARRAY
56518: PUSH
56519: LD_VAR 0 6
56523: PUSH
56524: LD_INT 2
56526: ARRAY
56527: PUSH
56528: LD_VAR 0 5
56532: ARRAY
56533: PUSH
56534: EMPTY
56535: LIST
56536: LIST
56537: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
56538: LD_INT 92
56540: PUSH
56541: LD_VAR 0 7
56545: PUSH
56546: LD_INT 1
56548: ARRAY
56549: PUSH
56550: LD_VAR 0 7
56554: PUSH
56555: LD_INT 2
56557: ARRAY
56558: PUSH
56559: LD_INT 2
56561: PUSH
56562: EMPTY
56563: LIST
56564: LIST
56565: LIST
56566: LIST
56567: PPUSH
56568: CALL_OW 69
56572: PUSH
56573: LD_INT 0
56575: EQUAL
56576: IFFALSE 56629
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56578: LD_VAR 0 1
56582: PPUSH
56583: LD_VAR 0 7
56587: PUSH
56588: LD_INT 1
56590: ARRAY
56591: PPUSH
56592: LD_VAR 0 7
56596: PUSH
56597: LD_INT 2
56599: ARRAY
56600: PPUSH
56601: LD_VAR 0 3
56605: PPUSH
56606: CALL_OW 48
// result := IsPlaced ( unit ) ;
56610: LD_ADDR_VAR 0 4
56614: PUSH
56615: LD_VAR 0 1
56619: PPUSH
56620: CALL_OW 305
56624: ST_TO_ADDR
// exit ;
56625: POP
56626: POP
56627: GO 56633
// end ; end ;
56629: GO 56496
56631: POP
56632: POP
// end ;
56633: LD_VAR 0 4
56637: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56638: LD_INT 0
56640: PPUSH
56641: PPUSH
56642: PPUSH
// if not side or side > 8 then
56643: LD_VAR 0 1
56647: NOT
56648: PUSH
56649: LD_VAR 0 1
56653: PUSH
56654: LD_INT 8
56656: GREATER
56657: OR
56658: IFFALSE 56662
// exit ;
56660: GO 56849
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56662: LD_ADDR_VAR 0 4
56666: PUSH
56667: LD_INT 22
56669: PUSH
56670: LD_VAR 0 1
56674: PUSH
56675: EMPTY
56676: LIST
56677: LIST
56678: PUSH
56679: LD_INT 21
56681: PUSH
56682: LD_INT 3
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: PUSH
56689: EMPTY
56690: LIST
56691: LIST
56692: PPUSH
56693: CALL_OW 69
56697: ST_TO_ADDR
// if not tmp then
56698: LD_VAR 0 4
56702: NOT
56703: IFFALSE 56707
// exit ;
56705: GO 56849
// enable_addtolog := true ;
56707: LD_ADDR_OWVAR 81
56711: PUSH
56712: LD_INT 1
56714: ST_TO_ADDR
// AddToLog ( [ ) ;
56715: LD_STRING [
56717: PPUSH
56718: CALL_OW 561
// for i in tmp do
56722: LD_ADDR_VAR 0 3
56726: PUSH
56727: LD_VAR 0 4
56731: PUSH
56732: FOR_IN
56733: IFFALSE 56840
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56735: LD_STRING [
56737: PUSH
56738: LD_VAR 0 3
56742: PPUSH
56743: CALL_OW 266
56747: STR
56748: PUSH
56749: LD_STRING , 
56751: STR
56752: PUSH
56753: LD_VAR 0 3
56757: PPUSH
56758: CALL_OW 250
56762: STR
56763: PUSH
56764: LD_STRING , 
56766: STR
56767: PUSH
56768: LD_VAR 0 3
56772: PPUSH
56773: CALL_OW 251
56777: STR
56778: PUSH
56779: LD_STRING , 
56781: STR
56782: PUSH
56783: LD_VAR 0 3
56787: PPUSH
56788: CALL_OW 254
56792: STR
56793: PUSH
56794: LD_STRING , 
56796: STR
56797: PUSH
56798: LD_VAR 0 3
56802: PPUSH
56803: LD_INT 1
56805: PPUSH
56806: CALL_OW 268
56810: STR
56811: PUSH
56812: LD_STRING , 
56814: STR
56815: PUSH
56816: LD_VAR 0 3
56820: PPUSH
56821: LD_INT 2
56823: PPUSH
56824: CALL_OW 268
56828: STR
56829: PUSH
56830: LD_STRING ],
56832: STR
56833: PPUSH
56834: CALL_OW 561
// end ;
56838: GO 56732
56840: POP
56841: POP
// AddToLog ( ]; ) ;
56842: LD_STRING ];
56844: PPUSH
56845: CALL_OW 561
// end ;
56849: LD_VAR 0 2
56853: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56854: LD_INT 0
56856: PPUSH
56857: PPUSH
56858: PPUSH
56859: PPUSH
56860: PPUSH
// if not area or not rate or not max then
56861: LD_VAR 0 1
56865: NOT
56866: PUSH
56867: LD_VAR 0 2
56871: NOT
56872: OR
56873: PUSH
56874: LD_VAR 0 4
56878: NOT
56879: OR
56880: IFFALSE 56884
// exit ;
56882: GO 57073
// while 1 do
56884: LD_INT 1
56886: IFFALSE 57073
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56888: LD_ADDR_VAR 0 9
56892: PUSH
56893: LD_VAR 0 1
56897: PPUSH
56898: LD_INT 1
56900: PPUSH
56901: CALL_OW 287
56905: PUSH
56906: LD_INT 10
56908: MUL
56909: ST_TO_ADDR
// r := rate / 10 ;
56910: LD_ADDR_VAR 0 7
56914: PUSH
56915: LD_VAR 0 2
56919: PUSH
56920: LD_INT 10
56922: DIVREAL
56923: ST_TO_ADDR
// time := 1 1$00 ;
56924: LD_ADDR_VAR 0 8
56928: PUSH
56929: LD_INT 2100
56931: ST_TO_ADDR
// if amount < min then
56932: LD_VAR 0 9
56936: PUSH
56937: LD_VAR 0 3
56941: LESS
56942: IFFALSE 56960
// r := r * 2 else
56944: LD_ADDR_VAR 0 7
56948: PUSH
56949: LD_VAR 0 7
56953: PUSH
56954: LD_INT 2
56956: MUL
56957: ST_TO_ADDR
56958: GO 56986
// if amount > max then
56960: LD_VAR 0 9
56964: PUSH
56965: LD_VAR 0 4
56969: GREATER
56970: IFFALSE 56986
// r := r / 2 ;
56972: LD_ADDR_VAR 0 7
56976: PUSH
56977: LD_VAR 0 7
56981: PUSH
56982: LD_INT 2
56984: DIVREAL
56985: ST_TO_ADDR
// time := time / r ;
56986: LD_ADDR_VAR 0 8
56990: PUSH
56991: LD_VAR 0 8
56995: PUSH
56996: LD_VAR 0 7
57000: DIVREAL
57001: ST_TO_ADDR
// if time < 0 then
57002: LD_VAR 0 8
57006: PUSH
57007: LD_INT 0
57009: LESS
57010: IFFALSE 57027
// time := time * - 1 ;
57012: LD_ADDR_VAR 0 8
57016: PUSH
57017: LD_VAR 0 8
57021: PUSH
57022: LD_INT 1
57024: NEG
57025: MUL
57026: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
57027: LD_VAR 0 8
57031: PUSH
57032: LD_INT 35
57034: PPUSH
57035: LD_INT 875
57037: PPUSH
57038: CALL_OW 12
57042: PLUS
57043: PPUSH
57044: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
57048: LD_INT 1
57050: PPUSH
57051: LD_INT 5
57053: PPUSH
57054: CALL_OW 12
57058: PPUSH
57059: LD_VAR 0 1
57063: PPUSH
57064: LD_INT 1
57066: PPUSH
57067: CALL_OW 55
// end ;
57071: GO 56884
// end ;
57073: LD_VAR 0 5
57077: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
57078: LD_INT 0
57080: PPUSH
57081: PPUSH
57082: PPUSH
57083: PPUSH
57084: PPUSH
57085: PPUSH
57086: PPUSH
57087: PPUSH
// if not turrets or not factories then
57088: LD_VAR 0 1
57092: NOT
57093: PUSH
57094: LD_VAR 0 2
57098: NOT
57099: OR
57100: IFFALSE 57104
// exit ;
57102: GO 57411
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
57104: LD_ADDR_VAR 0 10
57108: PUSH
57109: LD_INT 5
57111: PUSH
57112: LD_INT 6
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PUSH
57119: LD_INT 2
57121: PUSH
57122: LD_INT 4
57124: PUSH
57125: EMPTY
57126: LIST
57127: LIST
57128: PUSH
57129: LD_INT 3
57131: PUSH
57132: LD_INT 5
57134: PUSH
57135: EMPTY
57136: LIST
57137: LIST
57138: PUSH
57139: EMPTY
57140: LIST
57141: LIST
57142: LIST
57143: PUSH
57144: LD_INT 24
57146: PUSH
57147: LD_INT 25
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: PUSH
57154: LD_INT 23
57156: PUSH
57157: LD_INT 27
57159: PUSH
57160: EMPTY
57161: LIST
57162: LIST
57163: PUSH
57164: EMPTY
57165: LIST
57166: LIST
57167: PUSH
57168: LD_INT 42
57170: PUSH
57171: LD_INT 43
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: PUSH
57178: LD_INT 44
57180: PUSH
57181: LD_INT 46
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: LD_INT 45
57190: PUSH
57191: LD_INT 47
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: EMPTY
57199: LIST
57200: LIST
57201: LIST
57202: PUSH
57203: EMPTY
57204: LIST
57205: LIST
57206: LIST
57207: ST_TO_ADDR
// result := [ ] ;
57208: LD_ADDR_VAR 0 3
57212: PUSH
57213: EMPTY
57214: ST_TO_ADDR
// for i in turrets do
57215: LD_ADDR_VAR 0 4
57219: PUSH
57220: LD_VAR 0 1
57224: PUSH
57225: FOR_IN
57226: IFFALSE 57409
// begin nat := GetNation ( i ) ;
57228: LD_ADDR_VAR 0 7
57232: PUSH
57233: LD_VAR 0 4
57237: PPUSH
57238: CALL_OW 248
57242: ST_TO_ADDR
// weapon := 0 ;
57243: LD_ADDR_VAR 0 8
57247: PUSH
57248: LD_INT 0
57250: ST_TO_ADDR
// if not nat then
57251: LD_VAR 0 7
57255: NOT
57256: IFFALSE 57260
// continue ;
57258: GO 57225
// for j in list [ nat ] do
57260: LD_ADDR_VAR 0 5
57264: PUSH
57265: LD_VAR 0 10
57269: PUSH
57270: LD_VAR 0 7
57274: ARRAY
57275: PUSH
57276: FOR_IN
57277: IFFALSE 57318
// if GetBWeapon ( i ) = j [ 1 ] then
57279: LD_VAR 0 4
57283: PPUSH
57284: CALL_OW 269
57288: PUSH
57289: LD_VAR 0 5
57293: PUSH
57294: LD_INT 1
57296: ARRAY
57297: EQUAL
57298: IFFALSE 57316
// begin weapon := j [ 2 ] ;
57300: LD_ADDR_VAR 0 8
57304: PUSH
57305: LD_VAR 0 5
57309: PUSH
57310: LD_INT 2
57312: ARRAY
57313: ST_TO_ADDR
// break ;
57314: GO 57318
// end ;
57316: GO 57276
57318: POP
57319: POP
// if not weapon then
57320: LD_VAR 0 8
57324: NOT
57325: IFFALSE 57329
// continue ;
57327: GO 57225
// for k in factories do
57329: LD_ADDR_VAR 0 6
57333: PUSH
57334: LD_VAR 0 2
57338: PUSH
57339: FOR_IN
57340: IFFALSE 57405
// begin weapons := AvailableWeaponList ( k ) ;
57342: LD_ADDR_VAR 0 9
57346: PUSH
57347: LD_VAR 0 6
57351: PPUSH
57352: CALL_OW 478
57356: ST_TO_ADDR
// if not weapons then
57357: LD_VAR 0 9
57361: NOT
57362: IFFALSE 57366
// continue ;
57364: GO 57339
// if weapon in weapons then
57366: LD_VAR 0 8
57370: PUSH
57371: LD_VAR 0 9
57375: IN
57376: IFFALSE 57403
// begin result := [ i , weapon ] ;
57378: LD_ADDR_VAR 0 3
57382: PUSH
57383: LD_VAR 0 4
57387: PUSH
57388: LD_VAR 0 8
57392: PUSH
57393: EMPTY
57394: LIST
57395: LIST
57396: ST_TO_ADDR
// exit ;
57397: POP
57398: POP
57399: POP
57400: POP
57401: GO 57411
// end ; end ;
57403: GO 57339
57405: POP
57406: POP
// end ;
57407: GO 57225
57409: POP
57410: POP
// end ;
57411: LD_VAR 0 3
57415: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57416: LD_INT 0
57418: PPUSH
// if not side or side > 8 then
57419: LD_VAR 0 3
57423: NOT
57424: PUSH
57425: LD_VAR 0 3
57429: PUSH
57430: LD_INT 8
57432: GREATER
57433: OR
57434: IFFALSE 57438
// exit ;
57436: GO 57497
// if not range then
57438: LD_VAR 0 4
57442: NOT
57443: IFFALSE 57454
// range := - 12 ;
57445: LD_ADDR_VAR 0 4
57449: PUSH
57450: LD_INT 12
57452: NEG
57453: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57454: LD_VAR 0 1
57458: PPUSH
57459: LD_VAR 0 2
57463: PPUSH
57464: LD_VAR 0 3
57468: PPUSH
57469: LD_VAR 0 4
57473: PPUSH
57474: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57478: LD_VAR 0 1
57482: PPUSH
57483: LD_VAR 0 2
57487: PPUSH
57488: LD_VAR 0 3
57492: PPUSH
57493: CALL_OW 331
// end ;
57497: LD_VAR 0 5
57501: RET
// export function Video ( mode ) ; begin
57502: LD_INT 0
57504: PPUSH
// ingame_video = mode ;
57505: LD_ADDR_OWVAR 52
57509: PUSH
57510: LD_VAR 0 1
57514: ST_TO_ADDR
// interface_hidden = mode ;
57515: LD_ADDR_OWVAR 54
57519: PUSH
57520: LD_VAR 0 1
57524: ST_TO_ADDR
// end ;
57525: LD_VAR 0 2
57529: RET
// export function Join ( array , element ) ; begin
57530: LD_INT 0
57532: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57533: LD_ADDR_VAR 0 3
57537: PUSH
57538: LD_VAR 0 1
57542: PPUSH
57543: LD_VAR 0 1
57547: PUSH
57548: LD_INT 1
57550: PLUS
57551: PPUSH
57552: LD_VAR 0 2
57556: PPUSH
57557: CALL_OW 1
57561: ST_TO_ADDR
// end ;
57562: LD_VAR 0 3
57566: RET
// export function JoinUnion ( array , element ) ; begin
57567: LD_INT 0
57569: PPUSH
// result := array union element ;
57570: LD_ADDR_VAR 0 3
57574: PUSH
57575: LD_VAR 0 1
57579: PUSH
57580: LD_VAR 0 2
57584: UNION
57585: ST_TO_ADDR
// end ;
57586: LD_VAR 0 3
57590: RET
// export function GetBehemoths ( side ) ; begin
57591: LD_INT 0
57593: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57594: LD_ADDR_VAR 0 2
57598: PUSH
57599: LD_INT 22
57601: PUSH
57602: LD_VAR 0 1
57606: PUSH
57607: EMPTY
57608: LIST
57609: LIST
57610: PUSH
57611: LD_INT 31
57613: PUSH
57614: LD_INT 25
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: PUSH
57621: EMPTY
57622: LIST
57623: LIST
57624: PPUSH
57625: CALL_OW 69
57629: ST_TO_ADDR
// end ;
57630: LD_VAR 0 2
57634: RET
// export function Shuffle ( array ) ; var i , index ; begin
57635: LD_INT 0
57637: PPUSH
57638: PPUSH
57639: PPUSH
// result := [ ] ;
57640: LD_ADDR_VAR 0 2
57644: PUSH
57645: EMPTY
57646: ST_TO_ADDR
// if not array then
57647: LD_VAR 0 1
57651: NOT
57652: IFFALSE 57656
// exit ;
57654: GO 57755
// Randomize ;
57656: CALL_OW 10
// for i = array downto 1 do
57660: LD_ADDR_VAR 0 3
57664: PUSH
57665: DOUBLE
57666: LD_VAR 0 1
57670: INC
57671: ST_TO_ADDR
57672: LD_INT 1
57674: PUSH
57675: FOR_DOWNTO
57676: IFFALSE 57753
// begin index := rand ( 1 , array ) ;
57678: LD_ADDR_VAR 0 4
57682: PUSH
57683: LD_INT 1
57685: PPUSH
57686: LD_VAR 0 1
57690: PPUSH
57691: CALL_OW 12
57695: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57696: LD_ADDR_VAR 0 2
57700: PUSH
57701: LD_VAR 0 2
57705: PPUSH
57706: LD_VAR 0 2
57710: PUSH
57711: LD_INT 1
57713: PLUS
57714: PPUSH
57715: LD_VAR 0 1
57719: PUSH
57720: LD_VAR 0 4
57724: ARRAY
57725: PPUSH
57726: CALL_OW 2
57730: ST_TO_ADDR
// array := Delete ( array , index ) ;
57731: LD_ADDR_VAR 0 1
57735: PUSH
57736: LD_VAR 0 1
57740: PPUSH
57741: LD_VAR 0 4
57745: PPUSH
57746: CALL_OW 3
57750: ST_TO_ADDR
// end ;
57751: GO 57675
57753: POP
57754: POP
// end ;
57755: LD_VAR 0 2
57759: RET
// export function GetBaseMaterials ( base ) ; begin
57760: LD_INT 0
57762: PPUSH
// result := [ 0 , 0 , 0 ] ;
57763: LD_ADDR_VAR 0 2
57767: PUSH
57768: LD_INT 0
57770: PUSH
57771: LD_INT 0
57773: PUSH
57774: LD_INT 0
57776: PUSH
57777: EMPTY
57778: LIST
57779: LIST
57780: LIST
57781: ST_TO_ADDR
// if not base then
57782: LD_VAR 0 1
57786: NOT
57787: IFFALSE 57791
// exit ;
57789: GO 57840
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57791: LD_ADDR_VAR 0 2
57795: PUSH
57796: LD_VAR 0 1
57800: PPUSH
57801: LD_INT 1
57803: PPUSH
57804: CALL_OW 275
57808: PUSH
57809: LD_VAR 0 1
57813: PPUSH
57814: LD_INT 2
57816: PPUSH
57817: CALL_OW 275
57821: PUSH
57822: LD_VAR 0 1
57826: PPUSH
57827: LD_INT 3
57829: PPUSH
57830: CALL_OW 275
57834: PUSH
57835: EMPTY
57836: LIST
57837: LIST
57838: LIST
57839: ST_TO_ADDR
// end ;
57840: LD_VAR 0 2
57844: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57845: LD_INT 0
57847: PPUSH
57848: PPUSH
// result := array ;
57849: LD_ADDR_VAR 0 3
57853: PUSH
57854: LD_VAR 0 1
57858: ST_TO_ADDR
// if size >= result then
57859: LD_VAR 0 2
57863: PUSH
57864: LD_VAR 0 3
57868: GREATEREQUAL
57869: IFFALSE 57873
// exit ;
57871: GO 57923
// if size then
57873: LD_VAR 0 2
57877: IFFALSE 57923
// for i := array downto size do
57879: LD_ADDR_VAR 0 4
57883: PUSH
57884: DOUBLE
57885: LD_VAR 0 1
57889: INC
57890: ST_TO_ADDR
57891: LD_VAR 0 2
57895: PUSH
57896: FOR_DOWNTO
57897: IFFALSE 57921
// result := Delete ( result , result ) ;
57899: LD_ADDR_VAR 0 3
57903: PUSH
57904: LD_VAR 0 3
57908: PPUSH
57909: LD_VAR 0 3
57913: PPUSH
57914: CALL_OW 3
57918: ST_TO_ADDR
57919: GO 57896
57921: POP
57922: POP
// end ;
57923: LD_VAR 0 3
57927: RET
// export function ComExit ( unit ) ; var tmp ; begin
57928: LD_INT 0
57930: PPUSH
57931: PPUSH
// if not IsInUnit ( unit ) then
57932: LD_VAR 0 1
57936: PPUSH
57937: CALL_OW 310
57941: NOT
57942: IFFALSE 57946
// exit ;
57944: GO 58006
// tmp := IsInUnit ( unit ) ;
57946: LD_ADDR_VAR 0 3
57950: PUSH
57951: LD_VAR 0 1
57955: PPUSH
57956: CALL_OW 310
57960: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57961: LD_VAR 0 3
57965: PPUSH
57966: CALL_OW 247
57970: PUSH
57971: LD_INT 2
57973: EQUAL
57974: IFFALSE 57987
// ComExitVehicle ( unit ) else
57976: LD_VAR 0 1
57980: PPUSH
57981: CALL_OW 121
57985: GO 57996
// ComExitBuilding ( unit ) ;
57987: LD_VAR 0 1
57991: PPUSH
57992: CALL_OW 122
// result := tmp ;
57996: LD_ADDR_VAR 0 2
58000: PUSH
58001: LD_VAR 0 3
58005: ST_TO_ADDR
// end ;
58006: LD_VAR 0 2
58010: RET
// export function ComExitAll ( units ) ; var i ; begin
58011: LD_INT 0
58013: PPUSH
58014: PPUSH
// if not units then
58015: LD_VAR 0 1
58019: NOT
58020: IFFALSE 58024
// exit ;
58022: GO 58050
// for i in units do
58024: LD_ADDR_VAR 0 3
58028: PUSH
58029: LD_VAR 0 1
58033: PUSH
58034: FOR_IN
58035: IFFALSE 58048
// ComExit ( i ) ;
58037: LD_VAR 0 3
58041: PPUSH
58042: CALL 57928 0 1
58046: GO 58034
58048: POP
58049: POP
// end ;
58050: LD_VAR 0 2
58054: RET
// export function ResetHc ; begin
58055: LD_INT 0
58057: PPUSH
// InitHc ;
58058: CALL_OW 19
// hc_importance := 0 ;
58062: LD_ADDR_OWVAR 32
58066: PUSH
58067: LD_INT 0
58069: ST_TO_ADDR
// end ;
58070: LD_VAR 0 1
58074: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
58075: LD_INT 0
58077: PPUSH
58078: PPUSH
58079: PPUSH
// _x := ( x1 + x2 ) div 2 ;
58080: LD_ADDR_VAR 0 6
58084: PUSH
58085: LD_VAR 0 1
58089: PUSH
58090: LD_VAR 0 3
58094: PLUS
58095: PUSH
58096: LD_INT 2
58098: DIV
58099: ST_TO_ADDR
// if _x < 0 then
58100: LD_VAR 0 6
58104: PUSH
58105: LD_INT 0
58107: LESS
58108: IFFALSE 58125
// _x := _x * - 1 ;
58110: LD_ADDR_VAR 0 6
58114: PUSH
58115: LD_VAR 0 6
58119: PUSH
58120: LD_INT 1
58122: NEG
58123: MUL
58124: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
58125: LD_ADDR_VAR 0 7
58129: PUSH
58130: LD_VAR 0 2
58134: PUSH
58135: LD_VAR 0 4
58139: PLUS
58140: PUSH
58141: LD_INT 2
58143: DIV
58144: ST_TO_ADDR
// if _y < 0 then
58145: LD_VAR 0 7
58149: PUSH
58150: LD_INT 0
58152: LESS
58153: IFFALSE 58170
// _y := _y * - 1 ;
58155: LD_ADDR_VAR 0 7
58159: PUSH
58160: LD_VAR 0 7
58164: PUSH
58165: LD_INT 1
58167: NEG
58168: MUL
58169: ST_TO_ADDR
// result := [ _x , _y ] ;
58170: LD_ADDR_VAR 0 5
58174: PUSH
58175: LD_VAR 0 6
58179: PUSH
58180: LD_VAR 0 7
58184: PUSH
58185: EMPTY
58186: LIST
58187: LIST
58188: ST_TO_ADDR
// end ;
58189: LD_VAR 0 5
58193: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
58194: LD_INT 0
58196: PPUSH
58197: PPUSH
58198: PPUSH
58199: PPUSH
// task := GetTaskList ( unit ) ;
58200: LD_ADDR_VAR 0 7
58204: PUSH
58205: LD_VAR 0 1
58209: PPUSH
58210: CALL_OW 437
58214: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58215: LD_VAR 0 7
58219: NOT
58220: PUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: LD_VAR 0 2
58230: PPUSH
58231: CALL_OW 308
58235: NOT
58236: AND
58237: IFFALSE 58241
// exit ;
58239: GO 58359
// if IsInArea ( unit , area ) then
58241: LD_VAR 0 1
58245: PPUSH
58246: LD_VAR 0 2
58250: PPUSH
58251: CALL_OW 308
58255: IFFALSE 58273
// begin ComMoveToArea ( unit , goAway ) ;
58257: LD_VAR 0 1
58261: PPUSH
58262: LD_VAR 0 3
58266: PPUSH
58267: CALL_OW 113
// exit ;
58271: GO 58359
// end ; if task [ 1 ] [ 1 ] <> M then
58273: LD_VAR 0 7
58277: PUSH
58278: LD_INT 1
58280: ARRAY
58281: PUSH
58282: LD_INT 1
58284: ARRAY
58285: PUSH
58286: LD_STRING M
58288: NONEQUAL
58289: IFFALSE 58293
// exit ;
58291: GO 58359
// x := task [ 1 ] [ 2 ] ;
58293: LD_ADDR_VAR 0 5
58297: PUSH
58298: LD_VAR 0 7
58302: PUSH
58303: LD_INT 1
58305: ARRAY
58306: PUSH
58307: LD_INT 2
58309: ARRAY
58310: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58311: LD_ADDR_VAR 0 6
58315: PUSH
58316: LD_VAR 0 7
58320: PUSH
58321: LD_INT 1
58323: ARRAY
58324: PUSH
58325: LD_INT 3
58327: ARRAY
58328: ST_TO_ADDR
// if InArea ( x , y , area ) then
58329: LD_VAR 0 5
58333: PPUSH
58334: LD_VAR 0 6
58338: PPUSH
58339: LD_VAR 0 2
58343: PPUSH
58344: CALL_OW 309
58348: IFFALSE 58359
// ComStop ( unit ) ;
58350: LD_VAR 0 1
58354: PPUSH
58355: CALL_OW 141
// end ;
58359: LD_VAR 0 4
58363: RET
// export function Abs ( value ) ; begin
58364: LD_INT 0
58366: PPUSH
// result := value ;
58367: LD_ADDR_VAR 0 2
58371: PUSH
58372: LD_VAR 0 1
58376: ST_TO_ADDR
// if value < 0 then
58377: LD_VAR 0 1
58381: PUSH
58382: LD_INT 0
58384: LESS
58385: IFFALSE 58402
// result := value * - 1 ;
58387: LD_ADDR_VAR 0 2
58391: PUSH
58392: LD_VAR 0 1
58396: PUSH
58397: LD_INT 1
58399: NEG
58400: MUL
58401: ST_TO_ADDR
// end ;
58402: LD_VAR 0 2
58406: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58407: LD_INT 0
58409: PPUSH
58410: PPUSH
58411: PPUSH
58412: PPUSH
58413: PPUSH
58414: PPUSH
58415: PPUSH
58416: PPUSH
// if not unit or not building then
58417: LD_VAR 0 1
58421: NOT
58422: PUSH
58423: LD_VAR 0 2
58427: NOT
58428: OR
58429: IFFALSE 58433
// exit ;
58431: GO 58659
// x := GetX ( building ) ;
58433: LD_ADDR_VAR 0 4
58437: PUSH
58438: LD_VAR 0 2
58442: PPUSH
58443: CALL_OW 250
58447: ST_TO_ADDR
// y := GetY ( building ) ;
58448: LD_ADDR_VAR 0 6
58452: PUSH
58453: LD_VAR 0 2
58457: PPUSH
58458: CALL_OW 251
58462: ST_TO_ADDR
// d := GetDir ( building ) ;
58463: LD_ADDR_VAR 0 8
58467: PUSH
58468: LD_VAR 0 2
58472: PPUSH
58473: CALL_OW 254
58477: ST_TO_ADDR
// r := 4 ;
58478: LD_ADDR_VAR 0 9
58482: PUSH
58483: LD_INT 4
58485: ST_TO_ADDR
// for i := 1 to 5 do
58486: LD_ADDR_VAR 0 10
58490: PUSH
58491: DOUBLE
58492: LD_INT 1
58494: DEC
58495: ST_TO_ADDR
58496: LD_INT 5
58498: PUSH
58499: FOR_TO
58500: IFFALSE 58657
// begin _x := ShiftX ( x , d , r + i ) ;
58502: LD_ADDR_VAR 0 5
58506: PUSH
58507: LD_VAR 0 4
58511: PPUSH
58512: LD_VAR 0 8
58516: PPUSH
58517: LD_VAR 0 9
58521: PUSH
58522: LD_VAR 0 10
58526: PLUS
58527: PPUSH
58528: CALL_OW 272
58532: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58533: LD_ADDR_VAR 0 7
58537: PUSH
58538: LD_VAR 0 6
58542: PPUSH
58543: LD_VAR 0 8
58547: PPUSH
58548: LD_VAR 0 9
58552: PUSH
58553: LD_VAR 0 10
58557: PLUS
58558: PPUSH
58559: CALL_OW 273
58563: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58564: LD_VAR 0 5
58568: PPUSH
58569: LD_VAR 0 7
58573: PPUSH
58574: CALL_OW 488
58578: PUSH
58579: LD_VAR 0 5
58583: PPUSH
58584: LD_VAR 0 7
58588: PPUSH
58589: CALL_OW 428
58593: PPUSH
58594: CALL_OW 247
58598: PUSH
58599: LD_INT 3
58601: PUSH
58602: LD_INT 2
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: IN
58609: NOT
58610: AND
58611: IFFALSE 58655
// begin ComMoveXY ( unit , _x , _y ) ;
58613: LD_VAR 0 1
58617: PPUSH
58618: LD_VAR 0 5
58622: PPUSH
58623: LD_VAR 0 7
58627: PPUSH
58628: CALL_OW 111
// result := [ _x , _y ] ;
58632: LD_ADDR_VAR 0 3
58636: PUSH
58637: LD_VAR 0 5
58641: PUSH
58642: LD_VAR 0 7
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: ST_TO_ADDR
// exit ;
58651: POP
58652: POP
58653: GO 58659
// end ; end ;
58655: GO 58499
58657: POP
58658: POP
// end ;
58659: LD_VAR 0 3
58663: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58664: LD_INT 0
58666: PPUSH
58667: PPUSH
58668: PPUSH
// result := 0 ;
58669: LD_ADDR_VAR 0 3
58673: PUSH
58674: LD_INT 0
58676: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58677: LD_VAR 0 1
58681: PUSH
58682: LD_INT 0
58684: LESS
58685: PUSH
58686: LD_VAR 0 1
58690: PUSH
58691: LD_INT 8
58693: GREATER
58694: OR
58695: PUSH
58696: LD_VAR 0 2
58700: PUSH
58701: LD_INT 0
58703: LESS
58704: OR
58705: PUSH
58706: LD_VAR 0 2
58710: PUSH
58711: LD_INT 8
58713: GREATER
58714: OR
58715: IFFALSE 58719
// exit ;
58717: GO 58794
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58719: LD_ADDR_VAR 0 4
58723: PUSH
58724: LD_INT 22
58726: PUSH
58727: LD_VAR 0 2
58731: PUSH
58732: EMPTY
58733: LIST
58734: LIST
58735: PPUSH
58736: CALL_OW 69
58740: PUSH
58741: FOR_IN
58742: IFFALSE 58792
// begin un := UnitShoot ( i ) ;
58744: LD_ADDR_VAR 0 5
58748: PUSH
58749: LD_VAR 0 4
58753: PPUSH
58754: CALL_OW 504
58758: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58759: LD_VAR 0 5
58763: PPUSH
58764: CALL_OW 255
58768: PUSH
58769: LD_VAR 0 1
58773: EQUAL
58774: IFFALSE 58790
// begin result := un ;
58776: LD_ADDR_VAR 0 3
58780: PUSH
58781: LD_VAR 0 5
58785: ST_TO_ADDR
// exit ;
58786: POP
58787: POP
58788: GO 58794
// end ; end ;
58790: GO 58741
58792: POP
58793: POP
// end ;
58794: LD_VAR 0 3
58798: RET
// export function GetCargoBay ( units ) ; begin
58799: LD_INT 0
58801: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58802: LD_ADDR_VAR 0 2
58806: PUSH
58807: LD_VAR 0 1
58811: PPUSH
58812: LD_INT 2
58814: PUSH
58815: LD_INT 34
58817: PUSH
58818: LD_INT 12
58820: PUSH
58821: EMPTY
58822: LIST
58823: LIST
58824: PUSH
58825: LD_INT 34
58827: PUSH
58828: LD_INT 51
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: PUSH
58835: LD_INT 34
58837: PUSH
58838: LD_INT 32
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: PUSH
58845: LD_INT 34
58847: PUSH
58848: LD_INT 89
58850: PUSH
58851: EMPTY
58852: LIST
58853: LIST
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: LIST
58859: LIST
58860: LIST
58861: PPUSH
58862: CALL_OW 72
58866: ST_TO_ADDR
// end ;
58867: LD_VAR 0 2
58871: RET
// export function Negate ( value ) ; begin
58872: LD_INT 0
58874: PPUSH
// result := not value ;
58875: LD_ADDR_VAR 0 2
58879: PUSH
58880: LD_VAR 0 1
58884: NOT
58885: ST_TO_ADDR
// end ;
58886: LD_VAR 0 2
58890: RET
// export function Inc ( value ) ; begin
58891: LD_INT 0
58893: PPUSH
// result := value + 1 ;
58894: LD_ADDR_VAR 0 2
58898: PUSH
58899: LD_VAR 0 1
58903: PUSH
58904: LD_INT 1
58906: PLUS
58907: ST_TO_ADDR
// end ;
58908: LD_VAR 0 2
58912: RET
// export function Dec ( value ) ; begin
58913: LD_INT 0
58915: PPUSH
// result := value - 1 ;
58916: LD_ADDR_VAR 0 2
58920: PUSH
58921: LD_VAR 0 1
58925: PUSH
58926: LD_INT 1
58928: MINUS
58929: ST_TO_ADDR
// end ;
58930: LD_VAR 0 2
58934: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58935: LD_INT 0
58937: PPUSH
58938: PPUSH
58939: PPUSH
58940: PPUSH
58941: PPUSH
58942: PPUSH
58943: PPUSH
58944: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58945: LD_VAR 0 1
58949: PPUSH
58950: LD_VAR 0 2
58954: PPUSH
58955: CALL_OW 488
58959: NOT
58960: PUSH
58961: LD_VAR 0 3
58965: PPUSH
58966: LD_VAR 0 4
58970: PPUSH
58971: CALL_OW 488
58975: NOT
58976: OR
58977: IFFALSE 58990
// begin result := - 1 ;
58979: LD_ADDR_VAR 0 5
58983: PUSH
58984: LD_INT 1
58986: NEG
58987: ST_TO_ADDR
// exit ;
58988: GO 59225
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58990: LD_ADDR_VAR 0 12
58994: PUSH
58995: LD_VAR 0 1
58999: PPUSH
59000: LD_VAR 0 2
59004: PPUSH
59005: LD_VAR 0 3
59009: PPUSH
59010: LD_VAR 0 4
59014: PPUSH
59015: CALL 58075 0 4
59019: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
59020: LD_ADDR_VAR 0 11
59024: PUSH
59025: LD_VAR 0 1
59029: PPUSH
59030: LD_VAR 0 2
59034: PPUSH
59035: LD_VAR 0 12
59039: PUSH
59040: LD_INT 1
59042: ARRAY
59043: PPUSH
59044: LD_VAR 0 12
59048: PUSH
59049: LD_INT 2
59051: ARRAY
59052: PPUSH
59053: CALL_OW 298
59057: ST_TO_ADDR
// distance := 9999 ;
59058: LD_ADDR_VAR 0 10
59062: PUSH
59063: LD_INT 9999
59065: ST_TO_ADDR
// for i := 0 to 5 do
59066: LD_ADDR_VAR 0 6
59070: PUSH
59071: DOUBLE
59072: LD_INT 0
59074: DEC
59075: ST_TO_ADDR
59076: LD_INT 5
59078: PUSH
59079: FOR_TO
59080: IFFALSE 59223
// begin _x := ShiftX ( x1 , i , centerDist ) ;
59082: LD_ADDR_VAR 0 7
59086: PUSH
59087: LD_VAR 0 1
59091: PPUSH
59092: LD_VAR 0 6
59096: PPUSH
59097: LD_VAR 0 11
59101: PPUSH
59102: CALL_OW 272
59106: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
59107: LD_ADDR_VAR 0 8
59111: PUSH
59112: LD_VAR 0 2
59116: PPUSH
59117: LD_VAR 0 6
59121: PPUSH
59122: LD_VAR 0 11
59126: PPUSH
59127: CALL_OW 273
59131: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59132: LD_VAR 0 7
59136: PPUSH
59137: LD_VAR 0 8
59141: PPUSH
59142: CALL_OW 488
59146: NOT
59147: IFFALSE 59151
// continue ;
59149: GO 59079
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
59151: LD_ADDR_VAR 0 9
59155: PUSH
59156: LD_VAR 0 12
59160: PUSH
59161: LD_INT 1
59163: ARRAY
59164: PPUSH
59165: LD_VAR 0 12
59169: PUSH
59170: LD_INT 2
59172: ARRAY
59173: PPUSH
59174: LD_VAR 0 7
59178: PPUSH
59179: LD_VAR 0 8
59183: PPUSH
59184: CALL_OW 298
59188: ST_TO_ADDR
// if tmp < distance then
59189: LD_VAR 0 9
59193: PUSH
59194: LD_VAR 0 10
59198: LESS
59199: IFFALSE 59221
// begin result := i ;
59201: LD_ADDR_VAR 0 5
59205: PUSH
59206: LD_VAR 0 6
59210: ST_TO_ADDR
// distance := tmp ;
59211: LD_ADDR_VAR 0 10
59215: PUSH
59216: LD_VAR 0 9
59220: ST_TO_ADDR
// end ; end ;
59221: GO 59079
59223: POP
59224: POP
// end ;
59225: LD_VAR 0 5
59229: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59230: LD_INT 0
59232: PPUSH
59233: PPUSH
// if not driver or not IsInUnit ( driver ) then
59234: LD_VAR 0 1
59238: NOT
59239: PUSH
59240: LD_VAR 0 1
59244: PPUSH
59245: CALL_OW 310
59249: NOT
59250: OR
59251: IFFALSE 59255
// exit ;
59253: GO 59345
// vehicle := IsInUnit ( driver ) ;
59255: LD_ADDR_VAR 0 3
59259: PUSH
59260: LD_VAR 0 1
59264: PPUSH
59265: CALL_OW 310
59269: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59270: LD_VAR 0 1
59274: PPUSH
59275: LD_STRING \
59277: PUSH
59278: LD_INT 0
59280: PUSH
59281: LD_INT 0
59283: PUSH
59284: LD_INT 0
59286: PUSH
59287: LD_INT 0
59289: PUSH
59290: LD_INT 0
59292: PUSH
59293: LD_INT 0
59295: PUSH
59296: EMPTY
59297: LIST
59298: LIST
59299: LIST
59300: LIST
59301: LIST
59302: LIST
59303: LIST
59304: PUSH
59305: LD_STRING E
59307: PUSH
59308: LD_INT 0
59310: PUSH
59311: LD_INT 0
59313: PUSH
59314: LD_VAR 0 3
59318: PUSH
59319: LD_INT 0
59321: PUSH
59322: LD_INT 0
59324: PUSH
59325: LD_INT 0
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: LIST
59332: LIST
59333: LIST
59334: LIST
59335: LIST
59336: PUSH
59337: EMPTY
59338: LIST
59339: LIST
59340: PPUSH
59341: CALL_OW 446
// end ;
59345: LD_VAR 0 2
59349: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59350: LD_INT 0
59352: PPUSH
59353: PPUSH
// if not driver or not IsInUnit ( driver ) then
59354: LD_VAR 0 1
59358: NOT
59359: PUSH
59360: LD_VAR 0 1
59364: PPUSH
59365: CALL_OW 310
59369: NOT
59370: OR
59371: IFFALSE 59375
// exit ;
59373: GO 59465
// vehicle := IsInUnit ( driver ) ;
59375: LD_ADDR_VAR 0 3
59379: PUSH
59380: LD_VAR 0 1
59384: PPUSH
59385: CALL_OW 310
59389: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59390: LD_VAR 0 1
59394: PPUSH
59395: LD_STRING \
59397: PUSH
59398: LD_INT 0
59400: PUSH
59401: LD_INT 0
59403: PUSH
59404: LD_INT 0
59406: PUSH
59407: LD_INT 0
59409: PUSH
59410: LD_INT 0
59412: PUSH
59413: LD_INT 0
59415: PUSH
59416: EMPTY
59417: LIST
59418: LIST
59419: LIST
59420: LIST
59421: LIST
59422: LIST
59423: LIST
59424: PUSH
59425: LD_STRING E
59427: PUSH
59428: LD_INT 0
59430: PUSH
59431: LD_INT 0
59433: PUSH
59434: LD_VAR 0 3
59438: PUSH
59439: LD_INT 0
59441: PUSH
59442: LD_INT 0
59444: PUSH
59445: LD_INT 0
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: LIST
59452: LIST
59453: LIST
59454: LIST
59455: LIST
59456: PUSH
59457: EMPTY
59458: LIST
59459: LIST
59460: PPUSH
59461: CALL_OW 447
// end ;
59465: LD_VAR 0 2
59469: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59470: LD_INT 0
59472: PPUSH
59473: PPUSH
59474: PPUSH
// tmp := [ ] ;
59475: LD_ADDR_VAR 0 5
59479: PUSH
59480: EMPTY
59481: ST_TO_ADDR
// for i in units do
59482: LD_ADDR_VAR 0 4
59486: PUSH
59487: LD_VAR 0 1
59491: PUSH
59492: FOR_IN
59493: IFFALSE 59531
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59495: LD_ADDR_VAR 0 5
59499: PUSH
59500: LD_VAR 0 5
59504: PPUSH
59505: LD_VAR 0 5
59509: PUSH
59510: LD_INT 1
59512: PLUS
59513: PPUSH
59514: LD_VAR 0 4
59518: PPUSH
59519: CALL_OW 256
59523: PPUSH
59524: CALL_OW 2
59528: ST_TO_ADDR
59529: GO 59492
59531: POP
59532: POP
// if not tmp then
59533: LD_VAR 0 5
59537: NOT
59538: IFFALSE 59542
// exit ;
59540: GO 59590
// if asc then
59542: LD_VAR 0 2
59546: IFFALSE 59570
// result := SortListByListAsc ( units , tmp ) else
59548: LD_ADDR_VAR 0 3
59552: PUSH
59553: LD_VAR 0 1
59557: PPUSH
59558: LD_VAR 0 5
59562: PPUSH
59563: CALL_OW 76
59567: ST_TO_ADDR
59568: GO 59590
// result := SortListByListDesc ( units , tmp ) ;
59570: LD_ADDR_VAR 0 3
59574: PUSH
59575: LD_VAR 0 1
59579: PPUSH
59580: LD_VAR 0 5
59584: PPUSH
59585: CALL_OW 77
59589: ST_TO_ADDR
// end ;
59590: LD_VAR 0 3
59594: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59595: LD_INT 0
59597: PPUSH
59598: PPUSH
// task := GetTaskList ( mech ) ;
59599: LD_ADDR_VAR 0 4
59603: PUSH
59604: LD_VAR 0 1
59608: PPUSH
59609: CALL_OW 437
59613: ST_TO_ADDR
// if not task then
59614: LD_VAR 0 4
59618: NOT
59619: IFFALSE 59623
// exit ;
59621: GO 59665
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59623: LD_ADDR_VAR 0 3
59627: PUSH
59628: LD_VAR 0 4
59632: PUSH
59633: LD_INT 1
59635: ARRAY
59636: PUSH
59637: LD_INT 1
59639: ARRAY
59640: PUSH
59641: LD_STRING r
59643: EQUAL
59644: PUSH
59645: LD_VAR 0 4
59649: PUSH
59650: LD_INT 1
59652: ARRAY
59653: PUSH
59654: LD_INT 4
59656: ARRAY
59657: PUSH
59658: LD_VAR 0 2
59662: EQUAL
59663: AND
59664: ST_TO_ADDR
// end ;
59665: LD_VAR 0 3
59669: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59670: LD_INT 0
59672: PPUSH
// SetDir ( unit , d ) ;
59673: LD_VAR 0 1
59677: PPUSH
59678: LD_VAR 0 4
59682: PPUSH
59683: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59687: LD_VAR 0 1
59691: PPUSH
59692: LD_VAR 0 2
59696: PPUSH
59697: LD_VAR 0 3
59701: PPUSH
59702: LD_VAR 0 5
59706: PPUSH
59707: CALL_OW 48
// end ;
59711: LD_VAR 0 6
59715: RET
// export function ToNaturalNumber ( number ) ; begin
59716: LD_INT 0
59718: PPUSH
// result := number div 1 ;
59719: LD_ADDR_VAR 0 2
59723: PUSH
59724: LD_VAR 0 1
59728: PUSH
59729: LD_INT 1
59731: DIV
59732: ST_TO_ADDR
// if number < 0 then
59733: LD_VAR 0 1
59737: PUSH
59738: LD_INT 0
59740: LESS
59741: IFFALSE 59751
// result := 0 ;
59743: LD_ADDR_VAR 0 2
59747: PUSH
59748: LD_INT 0
59750: ST_TO_ADDR
// end ;
59751: LD_VAR 0 2
59755: RET
// export function SortByClass ( units , class ) ; var un ; begin
59756: LD_INT 0
59758: PPUSH
59759: PPUSH
// if not units or not class then
59760: LD_VAR 0 1
59764: NOT
59765: PUSH
59766: LD_VAR 0 2
59770: NOT
59771: OR
59772: IFFALSE 59776
// exit ;
59774: GO 59871
// result := [ ] ;
59776: LD_ADDR_VAR 0 3
59780: PUSH
59781: EMPTY
59782: ST_TO_ADDR
// for un in units do
59783: LD_ADDR_VAR 0 4
59787: PUSH
59788: LD_VAR 0 1
59792: PUSH
59793: FOR_IN
59794: IFFALSE 59869
// if GetClass ( un ) = class then
59796: LD_VAR 0 4
59800: PPUSH
59801: CALL_OW 257
59805: PUSH
59806: LD_VAR 0 2
59810: EQUAL
59811: IFFALSE 59838
// result := Insert ( result , 1 , un ) else
59813: LD_ADDR_VAR 0 3
59817: PUSH
59818: LD_VAR 0 3
59822: PPUSH
59823: LD_INT 1
59825: PPUSH
59826: LD_VAR 0 4
59830: PPUSH
59831: CALL_OW 2
59835: ST_TO_ADDR
59836: GO 59867
// result := Replace ( result , result + 1 , un ) ;
59838: LD_ADDR_VAR 0 3
59842: PUSH
59843: LD_VAR 0 3
59847: PPUSH
59848: LD_VAR 0 3
59852: PUSH
59853: LD_INT 1
59855: PLUS
59856: PPUSH
59857: LD_VAR 0 4
59861: PPUSH
59862: CALL_OW 1
59866: ST_TO_ADDR
59867: GO 59793
59869: POP
59870: POP
// end ;
59871: LD_VAR 0 3
59875: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59876: LD_INT 0
59878: PPUSH
59879: PPUSH
59880: PPUSH
59881: PPUSH
59882: PPUSH
59883: PPUSH
59884: PPUSH
// result := [ ] ;
59885: LD_ADDR_VAR 0 4
59889: PUSH
59890: EMPTY
59891: ST_TO_ADDR
// if x - r < 0 then
59892: LD_VAR 0 1
59896: PUSH
59897: LD_VAR 0 3
59901: MINUS
59902: PUSH
59903: LD_INT 0
59905: LESS
59906: IFFALSE 59918
// min_x := 0 else
59908: LD_ADDR_VAR 0 8
59912: PUSH
59913: LD_INT 0
59915: ST_TO_ADDR
59916: GO 59934
// min_x := x - r ;
59918: LD_ADDR_VAR 0 8
59922: PUSH
59923: LD_VAR 0 1
59927: PUSH
59928: LD_VAR 0 3
59932: MINUS
59933: ST_TO_ADDR
// if y - r < 0 then
59934: LD_VAR 0 2
59938: PUSH
59939: LD_VAR 0 3
59943: MINUS
59944: PUSH
59945: LD_INT 0
59947: LESS
59948: IFFALSE 59960
// min_y := 0 else
59950: LD_ADDR_VAR 0 7
59954: PUSH
59955: LD_INT 0
59957: ST_TO_ADDR
59958: GO 59976
// min_y := y - r ;
59960: LD_ADDR_VAR 0 7
59964: PUSH
59965: LD_VAR 0 2
59969: PUSH
59970: LD_VAR 0 3
59974: MINUS
59975: ST_TO_ADDR
// max_x := x + r ;
59976: LD_ADDR_VAR 0 9
59980: PUSH
59981: LD_VAR 0 1
59985: PUSH
59986: LD_VAR 0 3
59990: PLUS
59991: ST_TO_ADDR
// max_y := y + r ;
59992: LD_ADDR_VAR 0 10
59996: PUSH
59997: LD_VAR 0 2
60001: PUSH
60002: LD_VAR 0 3
60006: PLUS
60007: ST_TO_ADDR
// for _x = min_x to max_x do
60008: LD_ADDR_VAR 0 5
60012: PUSH
60013: DOUBLE
60014: LD_VAR 0 8
60018: DEC
60019: ST_TO_ADDR
60020: LD_VAR 0 9
60024: PUSH
60025: FOR_TO
60026: IFFALSE 60127
// for _y = min_y to max_y do
60028: LD_ADDR_VAR 0 6
60032: PUSH
60033: DOUBLE
60034: LD_VAR 0 7
60038: DEC
60039: ST_TO_ADDR
60040: LD_VAR 0 10
60044: PUSH
60045: FOR_TO
60046: IFFALSE 60123
// begin if not ValidHex ( _x , _y ) then
60048: LD_VAR 0 5
60052: PPUSH
60053: LD_VAR 0 6
60057: PPUSH
60058: CALL_OW 488
60062: NOT
60063: IFFALSE 60067
// continue ;
60065: GO 60045
// if GetResourceTypeXY ( _x , _y ) then
60067: LD_VAR 0 5
60071: PPUSH
60072: LD_VAR 0 6
60076: PPUSH
60077: CALL_OW 283
60081: IFFALSE 60121
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
60083: LD_ADDR_VAR 0 4
60087: PUSH
60088: LD_VAR 0 4
60092: PPUSH
60093: LD_VAR 0 4
60097: PUSH
60098: LD_INT 1
60100: PLUS
60101: PPUSH
60102: LD_VAR 0 5
60106: PUSH
60107: LD_VAR 0 6
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PPUSH
60116: CALL_OW 1
60120: ST_TO_ADDR
// end ;
60121: GO 60045
60123: POP
60124: POP
60125: GO 60025
60127: POP
60128: POP
// end ;
60129: LD_VAR 0 4
60133: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
60134: LD_INT 0
60136: PPUSH
60137: PPUSH
60138: PPUSH
60139: PPUSH
60140: PPUSH
60141: PPUSH
60142: PPUSH
60143: PPUSH
// if not units then
60144: LD_VAR 0 1
60148: NOT
60149: IFFALSE 60153
// exit ;
60151: GO 60677
// result := UnitFilter ( units , [ f_ok ] ) ;
60153: LD_ADDR_VAR 0 3
60157: PUSH
60158: LD_VAR 0 1
60162: PPUSH
60163: LD_INT 50
60165: PUSH
60166: EMPTY
60167: LIST
60168: PPUSH
60169: CALL_OW 72
60173: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
60174: LD_ADDR_VAR 0 8
60178: PUSH
60179: LD_VAR 0 1
60183: PUSH
60184: LD_INT 1
60186: ARRAY
60187: PPUSH
60188: CALL_OW 255
60192: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
60193: LD_ADDR_VAR 0 10
60197: PUSH
60198: LD_INT 29
60200: PUSH
60201: LD_INT 91
60203: PUSH
60204: LD_INT 49
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: LIST
60211: ST_TO_ADDR
// if not result then
60212: LD_VAR 0 3
60216: NOT
60217: IFFALSE 60221
// exit ;
60219: GO 60677
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
60221: LD_ADDR_VAR 0 5
60225: PUSH
60226: LD_INT 81
60228: PUSH
60229: LD_VAR 0 8
60233: PUSH
60234: EMPTY
60235: LIST
60236: LIST
60237: PPUSH
60238: CALL_OW 69
60242: ST_TO_ADDR
// for i in result do
60243: LD_ADDR_VAR 0 4
60247: PUSH
60248: LD_VAR 0 3
60252: PUSH
60253: FOR_IN
60254: IFFALSE 60675
// begin tag := GetTag ( i ) + 1 ;
60256: LD_ADDR_VAR 0 9
60260: PUSH
60261: LD_VAR 0 4
60265: PPUSH
60266: CALL_OW 110
60270: PUSH
60271: LD_INT 1
60273: PLUS
60274: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60275: LD_ADDR_VAR 0 7
60279: PUSH
60280: LD_VAR 0 4
60284: PPUSH
60285: CALL_OW 250
60289: PPUSH
60290: LD_VAR 0 4
60294: PPUSH
60295: CALL_OW 251
60299: PPUSH
60300: LD_INT 6
60302: PPUSH
60303: CALL 59876 0 3
60307: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60308: LD_VAR 0 4
60312: PPUSH
60313: CALL_OW 247
60317: PUSH
60318: LD_INT 2
60320: EQUAL
60321: PUSH
60322: LD_VAR 0 7
60326: AND
60327: PUSH
60328: LD_VAR 0 4
60332: PPUSH
60333: CALL_OW 264
60337: PUSH
60338: LD_VAR 0 10
60342: IN
60343: NOT
60344: AND
60345: IFFALSE 60384
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60347: LD_VAR 0 4
60351: PPUSH
60352: LD_VAR 0 7
60356: PUSH
60357: LD_INT 1
60359: ARRAY
60360: PUSH
60361: LD_INT 1
60363: ARRAY
60364: PPUSH
60365: LD_VAR 0 7
60369: PUSH
60370: LD_INT 1
60372: ARRAY
60373: PUSH
60374: LD_INT 2
60376: ARRAY
60377: PPUSH
60378: CALL_OW 116
60382: GO 60673
// if path > tag then
60384: LD_VAR 0 2
60388: PUSH
60389: LD_VAR 0 9
60393: GREATER
60394: IFFALSE 60602
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60396: LD_ADDR_VAR 0 6
60400: PUSH
60401: LD_VAR 0 5
60405: PPUSH
60406: LD_INT 91
60408: PUSH
60409: LD_VAR 0 4
60413: PUSH
60414: LD_INT 8
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: LIST
60421: PPUSH
60422: CALL_OW 72
60426: ST_TO_ADDR
// if nearEnemy then
60427: LD_VAR 0 6
60431: IFFALSE 60500
// begin if GetWeapon ( i ) = ru_time_lapser then
60433: LD_VAR 0 4
60437: PPUSH
60438: CALL_OW 264
60442: PUSH
60443: LD_INT 49
60445: EQUAL
60446: IFFALSE 60474
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60448: LD_VAR 0 4
60452: PPUSH
60453: LD_VAR 0 6
60457: PPUSH
60458: LD_VAR 0 4
60462: PPUSH
60463: CALL_OW 74
60467: PPUSH
60468: CALL_OW 112
60472: GO 60498
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60474: LD_VAR 0 4
60478: PPUSH
60479: LD_VAR 0 6
60483: PPUSH
60484: LD_VAR 0 4
60488: PPUSH
60489: CALL_OW 74
60493: PPUSH
60494: CALL 61602 0 2
// end else
60498: GO 60600
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60500: LD_VAR 0 4
60504: PPUSH
60505: LD_VAR 0 2
60509: PUSH
60510: LD_VAR 0 9
60514: ARRAY
60515: PUSH
60516: LD_INT 1
60518: ARRAY
60519: PPUSH
60520: LD_VAR 0 2
60524: PUSH
60525: LD_VAR 0 9
60529: ARRAY
60530: PUSH
60531: LD_INT 2
60533: ARRAY
60534: PPUSH
60535: CALL_OW 297
60539: PUSH
60540: LD_INT 6
60542: GREATER
60543: IFFALSE 60586
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60545: LD_VAR 0 4
60549: PPUSH
60550: LD_VAR 0 2
60554: PUSH
60555: LD_VAR 0 9
60559: ARRAY
60560: PUSH
60561: LD_INT 1
60563: ARRAY
60564: PPUSH
60565: LD_VAR 0 2
60569: PUSH
60570: LD_VAR 0 9
60574: ARRAY
60575: PUSH
60576: LD_INT 2
60578: ARRAY
60579: PPUSH
60580: CALL_OW 114
60584: GO 60600
// SetTag ( i , tag ) ;
60586: LD_VAR 0 4
60590: PPUSH
60591: LD_VAR 0 9
60595: PPUSH
60596: CALL_OW 109
// end else
60600: GO 60673
// if enemy then
60602: LD_VAR 0 5
60606: IFFALSE 60673
// begin if GetWeapon ( i ) = ru_time_lapser then
60608: LD_VAR 0 4
60612: PPUSH
60613: CALL_OW 264
60617: PUSH
60618: LD_INT 49
60620: EQUAL
60621: IFFALSE 60649
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60623: LD_VAR 0 4
60627: PPUSH
60628: LD_VAR 0 5
60632: PPUSH
60633: LD_VAR 0 4
60637: PPUSH
60638: CALL_OW 74
60642: PPUSH
60643: CALL_OW 112
60647: GO 60673
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60649: LD_VAR 0 4
60653: PPUSH
60654: LD_VAR 0 5
60658: PPUSH
60659: LD_VAR 0 4
60663: PPUSH
60664: CALL_OW 74
60668: PPUSH
60669: CALL 61602 0 2
// end ; end ;
60673: GO 60253
60675: POP
60676: POP
// end ;
60677: LD_VAR 0 3
60681: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60682: LD_INT 0
60684: PPUSH
60685: PPUSH
60686: PPUSH
// if not unit or IsInUnit ( unit ) then
60687: LD_VAR 0 1
60691: NOT
60692: PUSH
60693: LD_VAR 0 1
60697: PPUSH
60698: CALL_OW 310
60702: OR
60703: IFFALSE 60707
// exit ;
60705: GO 60798
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60707: LD_ADDR_VAR 0 4
60711: PUSH
60712: LD_VAR 0 1
60716: PPUSH
60717: CALL_OW 250
60721: PPUSH
60722: LD_VAR 0 2
60726: PPUSH
60727: LD_INT 1
60729: PPUSH
60730: CALL_OW 272
60734: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60735: LD_ADDR_VAR 0 5
60739: PUSH
60740: LD_VAR 0 1
60744: PPUSH
60745: CALL_OW 251
60749: PPUSH
60750: LD_VAR 0 2
60754: PPUSH
60755: LD_INT 1
60757: PPUSH
60758: CALL_OW 273
60762: ST_TO_ADDR
// if ValidHex ( x , y ) then
60763: LD_VAR 0 4
60767: PPUSH
60768: LD_VAR 0 5
60772: PPUSH
60773: CALL_OW 488
60777: IFFALSE 60798
// ComTurnXY ( unit , x , y ) ;
60779: LD_VAR 0 1
60783: PPUSH
60784: LD_VAR 0 4
60788: PPUSH
60789: LD_VAR 0 5
60793: PPUSH
60794: CALL_OW 118
// end ;
60798: LD_VAR 0 3
60802: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60803: LD_INT 0
60805: PPUSH
60806: PPUSH
// result := false ;
60807: LD_ADDR_VAR 0 3
60811: PUSH
60812: LD_INT 0
60814: ST_TO_ADDR
// if not units then
60815: LD_VAR 0 2
60819: NOT
60820: IFFALSE 60824
// exit ;
60822: GO 60869
// for i in units do
60824: LD_ADDR_VAR 0 4
60828: PUSH
60829: LD_VAR 0 2
60833: PUSH
60834: FOR_IN
60835: IFFALSE 60867
// if See ( side , i ) then
60837: LD_VAR 0 1
60841: PPUSH
60842: LD_VAR 0 4
60846: PPUSH
60847: CALL_OW 292
60851: IFFALSE 60865
// begin result := true ;
60853: LD_ADDR_VAR 0 3
60857: PUSH
60858: LD_INT 1
60860: ST_TO_ADDR
// exit ;
60861: POP
60862: POP
60863: GO 60869
// end ;
60865: GO 60834
60867: POP
60868: POP
// end ;
60869: LD_VAR 0 3
60873: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60874: LD_INT 0
60876: PPUSH
60877: PPUSH
60878: PPUSH
60879: PPUSH
// if not unit or not points then
60880: LD_VAR 0 1
60884: NOT
60885: PUSH
60886: LD_VAR 0 2
60890: NOT
60891: OR
60892: IFFALSE 60896
// exit ;
60894: GO 60986
// dist := 99999 ;
60896: LD_ADDR_VAR 0 5
60900: PUSH
60901: LD_INT 99999
60903: ST_TO_ADDR
// for i in points do
60904: LD_ADDR_VAR 0 4
60908: PUSH
60909: LD_VAR 0 2
60913: PUSH
60914: FOR_IN
60915: IFFALSE 60984
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60917: LD_ADDR_VAR 0 6
60921: PUSH
60922: LD_VAR 0 1
60926: PPUSH
60927: LD_VAR 0 4
60931: PUSH
60932: LD_INT 1
60934: ARRAY
60935: PPUSH
60936: LD_VAR 0 4
60940: PUSH
60941: LD_INT 2
60943: ARRAY
60944: PPUSH
60945: CALL_OW 297
60949: ST_TO_ADDR
// if tmpDist < dist then
60950: LD_VAR 0 6
60954: PUSH
60955: LD_VAR 0 5
60959: LESS
60960: IFFALSE 60982
// begin result := i ;
60962: LD_ADDR_VAR 0 3
60966: PUSH
60967: LD_VAR 0 4
60971: ST_TO_ADDR
// dist := tmpDist ;
60972: LD_ADDR_VAR 0 5
60976: PUSH
60977: LD_VAR 0 6
60981: ST_TO_ADDR
// end ; end ;
60982: GO 60914
60984: POP
60985: POP
// end ;
60986: LD_VAR 0 3
60990: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60991: LD_INT 0
60993: PPUSH
// uc_side := side ;
60994: LD_ADDR_OWVAR 20
60998: PUSH
60999: LD_VAR 0 1
61003: ST_TO_ADDR
// uc_nation := 3 ;
61004: LD_ADDR_OWVAR 21
61008: PUSH
61009: LD_INT 3
61011: ST_TO_ADDR
// vc_chassis := 25 ;
61012: LD_ADDR_OWVAR 37
61016: PUSH
61017: LD_INT 25
61019: ST_TO_ADDR
// vc_engine := engine_siberite ;
61020: LD_ADDR_OWVAR 39
61024: PUSH
61025: LD_INT 3
61027: ST_TO_ADDR
// vc_control := control_computer ;
61028: LD_ADDR_OWVAR 38
61032: PUSH
61033: LD_INT 3
61035: ST_TO_ADDR
// vc_weapon := 59 ;
61036: LD_ADDR_OWVAR 40
61040: PUSH
61041: LD_INT 59
61043: ST_TO_ADDR
// result := CreateVehicle ;
61044: LD_ADDR_VAR 0 5
61048: PUSH
61049: CALL_OW 45
61053: ST_TO_ADDR
// SetDir ( result , d ) ;
61054: LD_VAR 0 5
61058: PPUSH
61059: LD_VAR 0 4
61063: PPUSH
61064: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
61068: LD_VAR 0 5
61072: PPUSH
61073: LD_VAR 0 2
61077: PPUSH
61078: LD_VAR 0 3
61082: PPUSH
61083: LD_INT 0
61085: PPUSH
61086: CALL_OW 48
// end ;
61090: LD_VAR 0 5
61094: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
61095: LD_INT 0
61097: PPUSH
61098: PPUSH
61099: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
61100: LD_ADDR_VAR 0 2
61104: PUSH
61105: LD_INT 0
61107: PUSH
61108: LD_INT 0
61110: PUSH
61111: LD_INT 0
61113: PUSH
61114: LD_INT 0
61116: PUSH
61117: EMPTY
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
61123: LD_VAR 0 1
61127: NOT
61128: PUSH
61129: LD_VAR 0 1
61133: PPUSH
61134: CALL_OW 264
61138: PUSH
61139: LD_INT 12
61141: PUSH
61142: LD_INT 51
61144: PUSH
61145: LD_INT 32
61147: PUSH
61148: LD_INT 89
61150: PUSH
61151: EMPTY
61152: LIST
61153: LIST
61154: LIST
61155: LIST
61156: IN
61157: NOT
61158: OR
61159: IFFALSE 61163
// exit ;
61161: GO 61261
// for i := 1 to 3 do
61163: LD_ADDR_VAR 0 3
61167: PUSH
61168: DOUBLE
61169: LD_INT 1
61171: DEC
61172: ST_TO_ADDR
61173: LD_INT 3
61175: PUSH
61176: FOR_TO
61177: IFFALSE 61259
// begin tmp := GetCargo ( cargo , i ) ;
61179: LD_ADDR_VAR 0 4
61183: PUSH
61184: LD_VAR 0 1
61188: PPUSH
61189: LD_VAR 0 3
61193: PPUSH
61194: CALL_OW 289
61198: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
61199: LD_ADDR_VAR 0 2
61203: PUSH
61204: LD_VAR 0 2
61208: PPUSH
61209: LD_VAR 0 3
61213: PPUSH
61214: LD_VAR 0 4
61218: PPUSH
61219: CALL_OW 1
61223: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
61224: LD_ADDR_VAR 0 2
61228: PUSH
61229: LD_VAR 0 2
61233: PPUSH
61234: LD_INT 4
61236: PPUSH
61237: LD_VAR 0 2
61241: PUSH
61242: LD_INT 4
61244: ARRAY
61245: PUSH
61246: LD_VAR 0 4
61250: PLUS
61251: PPUSH
61252: CALL_OW 1
61256: ST_TO_ADDR
// end ;
61257: GO 61176
61259: POP
61260: POP
// end ;
61261: LD_VAR 0 2
61265: RET
// export function Length ( array ) ; begin
61266: LD_INT 0
61268: PPUSH
// result := array + 0 ;
61269: LD_ADDR_VAR 0 2
61273: PUSH
61274: LD_VAR 0 1
61278: PUSH
61279: LD_INT 0
61281: PLUS
61282: ST_TO_ADDR
// end ;
61283: LD_VAR 0 2
61287: RET
// export function PrepareArray ( array ) ; begin
61288: LD_INT 0
61290: PPUSH
// result := array diff 0 ;
61291: LD_ADDR_VAR 0 2
61295: PUSH
61296: LD_VAR 0 1
61300: PUSH
61301: LD_INT 0
61303: DIFF
61304: ST_TO_ADDR
// if not result [ 1 ] then
61305: LD_VAR 0 2
61309: PUSH
61310: LD_INT 1
61312: ARRAY
61313: NOT
61314: IFFALSE 61334
// result := Delete ( result , 1 ) ;
61316: LD_ADDR_VAR 0 2
61320: PUSH
61321: LD_VAR 0 2
61325: PPUSH
61326: LD_INT 1
61328: PPUSH
61329: CALL_OW 3
61333: ST_TO_ADDR
// end ;
61334: LD_VAR 0 2
61338: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
61339: LD_INT 0
61341: PPUSH
61342: PPUSH
61343: PPUSH
61344: PPUSH
// sibRocketRange := 25 ;
61345: LD_ADDR_VAR 0 6
61349: PUSH
61350: LD_INT 25
61352: ST_TO_ADDR
// result := false ;
61353: LD_ADDR_VAR 0 4
61357: PUSH
61358: LD_INT 0
61360: ST_TO_ADDR
// for i := 0 to 5 do
61361: LD_ADDR_VAR 0 5
61365: PUSH
61366: DOUBLE
61367: LD_INT 0
61369: DEC
61370: ST_TO_ADDR
61371: LD_INT 5
61373: PUSH
61374: FOR_TO
61375: IFFALSE 61442
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61377: LD_VAR 0 1
61381: PPUSH
61382: LD_VAR 0 5
61386: PPUSH
61387: LD_VAR 0 6
61391: PPUSH
61392: CALL_OW 272
61396: PPUSH
61397: LD_VAR 0 2
61401: PPUSH
61402: LD_VAR 0 5
61406: PPUSH
61407: LD_VAR 0 6
61411: PPUSH
61412: CALL_OW 273
61416: PPUSH
61417: LD_VAR 0 3
61421: PPUSH
61422: CALL_OW 309
61426: IFFALSE 61440
// begin result := true ;
61428: LD_ADDR_VAR 0 4
61432: PUSH
61433: LD_INT 1
61435: ST_TO_ADDR
// exit ;
61436: POP
61437: POP
61438: GO 61444
// end ;
61440: GO 61374
61442: POP
61443: POP
// end ;
61444: LD_VAR 0 4
61448: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
61449: LD_INT 0
61451: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
61452: LD_VAR 0 1
61456: PPUSH
61457: LD_VAR 0 2
61461: PPUSH
61462: LD_INT 0
61464: PPUSH
61465: LD_INT 0
61467: PPUSH
61468: LD_INT 1
61470: PPUSH
61471: LD_INT 0
61473: PPUSH
61474: CALL_OW 587
// end ;
61478: LD_VAR 0 3
61482: RET
// export function CenterOnNow ( unit ) ; begin
61483: LD_INT 0
61485: PPUSH
// result := IsInUnit ( unit ) ;
61486: LD_ADDR_VAR 0 2
61490: PUSH
61491: LD_VAR 0 1
61495: PPUSH
61496: CALL_OW 310
61500: ST_TO_ADDR
// if not result then
61501: LD_VAR 0 2
61505: NOT
61506: IFFALSE 61518
// result := unit ;
61508: LD_ADDR_VAR 0 2
61512: PUSH
61513: LD_VAR 0 1
61517: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
61518: LD_VAR 0 1
61522: PPUSH
61523: CALL_OW 87
// end ;
61527: LD_VAR 0 2
61531: RET
// export function ComMoveHex ( unit , hex ) ; begin
61532: LD_INT 0
61534: PPUSH
// if not hex then
61535: LD_VAR 0 2
61539: NOT
61540: IFFALSE 61544
// exit ;
61542: GO 61597
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
61544: LD_VAR 0 2
61548: PUSH
61549: LD_INT 1
61551: ARRAY
61552: PPUSH
61553: LD_VAR 0 2
61557: PUSH
61558: LD_INT 2
61560: ARRAY
61561: PPUSH
61562: CALL_OW 428
61566: IFFALSE 61570
// exit ;
61568: GO 61597
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
61570: LD_VAR 0 1
61574: PPUSH
61575: LD_VAR 0 2
61579: PUSH
61580: LD_INT 1
61582: ARRAY
61583: PPUSH
61584: LD_VAR 0 2
61588: PUSH
61589: LD_INT 2
61591: ARRAY
61592: PPUSH
61593: CALL_OW 111
// end ;
61597: LD_VAR 0 3
61601: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
61602: LD_INT 0
61604: PPUSH
61605: PPUSH
61606: PPUSH
// if not unit or not enemy then
61607: LD_VAR 0 1
61611: NOT
61612: PUSH
61613: LD_VAR 0 2
61617: NOT
61618: OR
61619: IFFALSE 61623
// exit ;
61621: GO 61747
// x := GetX ( enemy ) ;
61623: LD_ADDR_VAR 0 4
61627: PUSH
61628: LD_VAR 0 2
61632: PPUSH
61633: CALL_OW 250
61637: ST_TO_ADDR
// y := GetY ( enemy ) ;
61638: LD_ADDR_VAR 0 5
61642: PUSH
61643: LD_VAR 0 2
61647: PPUSH
61648: CALL_OW 251
61652: ST_TO_ADDR
// if ValidHex ( x , y ) then
61653: LD_VAR 0 4
61657: PPUSH
61658: LD_VAR 0 5
61662: PPUSH
61663: CALL_OW 488
61667: IFFALSE 61747
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
61669: LD_VAR 0 2
61673: PPUSH
61674: CALL_OW 247
61678: PUSH
61679: LD_INT 3
61681: PUSH
61682: LD_INT 2
61684: PUSH
61685: EMPTY
61686: LIST
61687: LIST
61688: IN
61689: PUSH
61690: LD_VAR 0 1
61694: PPUSH
61695: CALL_OW 255
61699: PPUSH
61700: LD_VAR 0 2
61704: PPUSH
61705: CALL_OW 292
61709: OR
61710: IFFALSE 61728
// ComAttackUnit ( unit , enemy ) else
61712: LD_VAR 0 1
61716: PPUSH
61717: LD_VAR 0 2
61721: PPUSH
61722: CALL_OW 115
61726: GO 61747
// ComAgressiveMove ( unit , x , y ) ;
61728: LD_VAR 0 1
61732: PPUSH
61733: LD_VAR 0 4
61737: PPUSH
61738: LD_VAR 0 5
61742: PPUSH
61743: CALL_OW 114
// end ;
61747: LD_VAR 0 3
61751: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
61752: LD_INT 0
61754: PPUSH
61755: PPUSH
61756: PPUSH
// list := AreaToList ( area , 0 ) ;
61757: LD_ADDR_VAR 0 5
61761: PUSH
61762: LD_VAR 0 1
61766: PPUSH
61767: LD_INT 0
61769: PPUSH
61770: CALL_OW 517
61774: ST_TO_ADDR
// if not list then
61775: LD_VAR 0 5
61779: NOT
61780: IFFALSE 61784
// exit ;
61782: GO 61914
// if all then
61784: LD_VAR 0 2
61788: IFFALSE 61876
// begin for i := 1 to list [ 1 ] do
61790: LD_ADDR_VAR 0 4
61794: PUSH
61795: DOUBLE
61796: LD_INT 1
61798: DEC
61799: ST_TO_ADDR
61800: LD_VAR 0 5
61804: PUSH
61805: LD_INT 1
61807: ARRAY
61808: PUSH
61809: FOR_TO
61810: IFFALSE 61872
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
61812: LD_ADDR_VAR 0 3
61816: PUSH
61817: LD_VAR 0 3
61821: PPUSH
61822: LD_VAR 0 3
61826: PUSH
61827: LD_INT 1
61829: PLUS
61830: PPUSH
61831: LD_VAR 0 5
61835: PUSH
61836: LD_INT 1
61838: ARRAY
61839: PUSH
61840: LD_VAR 0 4
61844: ARRAY
61845: PUSH
61846: LD_VAR 0 5
61850: PUSH
61851: LD_INT 2
61853: ARRAY
61854: PUSH
61855: LD_VAR 0 4
61859: ARRAY
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: PPUSH
61865: CALL_OW 1
61869: ST_TO_ADDR
61870: GO 61809
61872: POP
61873: POP
// exit ;
61874: GO 61914
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
61876: LD_ADDR_VAR 0 3
61880: PUSH
61881: LD_VAR 0 5
61885: PUSH
61886: LD_INT 1
61888: ARRAY
61889: PUSH
61890: LD_INT 1
61892: ARRAY
61893: PUSH
61894: LD_VAR 0 5
61898: PUSH
61899: LD_INT 2
61901: ARRAY
61902: PUSH
61903: LD_INT 1
61905: ARRAY
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: PUSH
61911: EMPTY
61912: LIST
61913: ST_TO_ADDR
// end ;
61914: LD_VAR 0 3
61918: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
61919: LD_INT 0
61921: PPUSH
61922: PPUSH
// list := AreaToList ( area , 0 ) ;
61923: LD_ADDR_VAR 0 4
61927: PUSH
61928: LD_VAR 0 1
61932: PPUSH
61933: LD_INT 0
61935: PPUSH
61936: CALL_OW 517
61940: ST_TO_ADDR
// if not list then
61941: LD_VAR 0 4
61945: NOT
61946: IFFALSE 61950
// exit ;
61948: GO 61991
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
61950: LD_ADDR_VAR 0 3
61954: PUSH
61955: LD_VAR 0 4
61959: PUSH
61960: LD_INT 1
61962: ARRAY
61963: PUSH
61964: LD_INT 1
61966: ARRAY
61967: PUSH
61968: LD_VAR 0 4
61972: PUSH
61973: LD_INT 2
61975: ARRAY
61976: PUSH
61977: LD_INT 1
61979: ARRAY
61980: PUSH
61981: LD_VAR 0 2
61985: PUSH
61986: EMPTY
61987: LIST
61988: LIST
61989: LIST
61990: ST_TO_ADDR
// end ;
61991: LD_VAR 0 3
61995: RET
// export function First ( array ) ; begin
61996: LD_INT 0
61998: PPUSH
// if not array then
61999: LD_VAR 0 1
62003: NOT
62004: IFFALSE 62008
// exit ;
62006: GO 62022
// result := array [ 1 ] ;
62008: LD_ADDR_VAR 0 2
62012: PUSH
62013: LD_VAR 0 1
62017: PUSH
62018: LD_INT 1
62020: ARRAY
62021: ST_TO_ADDR
// end ;
62022: LD_VAR 0 2
62026: RET
// export function Last ( array ) ; begin
62027: LD_INT 0
62029: PPUSH
// if not array then
62030: LD_VAR 0 1
62034: NOT
62035: IFFALSE 62039
// exit ;
62037: GO 62055
// result := array [ array ] ;
62039: LD_ADDR_VAR 0 2
62043: PUSH
62044: LD_VAR 0 1
62048: PUSH
62049: LD_VAR 0 1
62053: ARRAY
62054: ST_TO_ADDR
// end ;
62055: LD_VAR 0 2
62059: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
62060: LD_INT 0
62062: PPUSH
62063: PPUSH
// result := [ ] ;
62064: LD_ADDR_VAR 0 5
62068: PUSH
62069: EMPTY
62070: ST_TO_ADDR
// if not array then
62071: LD_VAR 0 1
62075: NOT
62076: IFFALSE 62080
// exit ;
62078: GO 62192
// for i := 1 to array do
62080: LD_ADDR_VAR 0 6
62084: PUSH
62085: DOUBLE
62086: LD_INT 1
62088: DEC
62089: ST_TO_ADDR
62090: LD_VAR 0 1
62094: PUSH
62095: FOR_TO
62096: IFFALSE 62190
// if array [ i ] [ index ] = value then
62098: LD_VAR 0 1
62102: PUSH
62103: LD_VAR 0 6
62107: ARRAY
62108: PUSH
62109: LD_VAR 0 2
62113: ARRAY
62114: PUSH
62115: LD_VAR 0 3
62119: EQUAL
62120: IFFALSE 62188
// begin if indexColumn then
62122: LD_VAR 0 4
62126: IFFALSE 62162
// result := Join ( result , array [ i ] [ indexColumn ] ) else
62128: LD_ADDR_VAR 0 5
62132: PUSH
62133: LD_VAR 0 5
62137: PPUSH
62138: LD_VAR 0 1
62142: PUSH
62143: LD_VAR 0 6
62147: ARRAY
62148: PUSH
62149: LD_VAR 0 4
62153: ARRAY
62154: PPUSH
62155: CALL 57530 0 2
62159: ST_TO_ADDR
62160: GO 62188
// result := Join ( result , array [ i ] ) ;
62162: LD_ADDR_VAR 0 5
62166: PUSH
62167: LD_VAR 0 5
62171: PPUSH
62172: LD_VAR 0 1
62176: PUSH
62177: LD_VAR 0 6
62181: ARRAY
62182: PPUSH
62183: CALL 57530 0 2
62187: ST_TO_ADDR
// end ;
62188: GO 62095
62190: POP
62191: POP
// end ;
62192: LD_VAR 0 5
62196: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
62197: LD_INT 0
62199: PPUSH
62200: PPUSH
62201: PPUSH
// if btype = b_depot then
62202: LD_VAR 0 2
62206: PUSH
62207: LD_INT 0
62209: EQUAL
62210: IFFALSE 62222
// begin result := true ;
62212: LD_ADDR_VAR 0 3
62216: PUSH
62217: LD_INT 1
62219: ST_TO_ADDR
// exit ;
62220: GO 62338
// end ; pom := GetBase ( depot ) ;
62222: LD_ADDR_VAR 0 4
62226: PUSH
62227: LD_VAR 0 1
62231: PPUSH
62232: CALL_OW 274
62236: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62237: LD_ADDR_VAR 0 5
62241: PUSH
62242: LD_VAR 0 2
62246: PPUSH
62247: LD_VAR 0 1
62251: PPUSH
62252: CALL_OW 248
62256: PPUSH
62257: CALL_OW 450
62261: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
62262: LD_ADDR_VAR 0 3
62266: PUSH
62267: LD_VAR 0 4
62271: PPUSH
62272: LD_INT 1
62274: PPUSH
62275: CALL_OW 275
62279: PUSH
62280: LD_VAR 0 5
62284: PUSH
62285: LD_INT 1
62287: ARRAY
62288: GREATEREQUAL
62289: PUSH
62290: LD_VAR 0 4
62294: PPUSH
62295: LD_INT 2
62297: PPUSH
62298: CALL_OW 275
62302: PUSH
62303: LD_VAR 0 5
62307: PUSH
62308: LD_INT 2
62310: ARRAY
62311: GREATEREQUAL
62312: AND
62313: PUSH
62314: LD_VAR 0 4
62318: PPUSH
62319: LD_INT 3
62321: PPUSH
62322: CALL_OW 275
62326: PUSH
62327: LD_VAR 0 5
62331: PUSH
62332: LD_INT 3
62334: ARRAY
62335: GREATEREQUAL
62336: AND
62337: ST_TO_ADDR
// end ;
62338: LD_VAR 0 3
62342: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
62343: LD_INT 0
62345: PPUSH
// if not vehicles or not parkingPoint then
62346: LD_VAR 0 1
62350: NOT
62351: PUSH
62352: LD_VAR 0 2
62356: NOT
62357: OR
62358: IFFALSE 62362
// exit ;
62360: GO 62460
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
62362: LD_ADDR_VAR 0 1
62366: PUSH
62367: LD_VAR 0 1
62371: PPUSH
62372: LD_INT 50
62374: PUSH
62375: EMPTY
62376: LIST
62377: PUSH
62378: LD_INT 3
62380: PUSH
62381: LD_INT 92
62383: PUSH
62384: LD_VAR 0 2
62388: PUSH
62389: LD_INT 1
62391: ARRAY
62392: PUSH
62393: LD_VAR 0 2
62397: PUSH
62398: LD_INT 2
62400: ARRAY
62401: PUSH
62402: LD_INT 8
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: LIST
62409: LIST
62410: PUSH
62411: EMPTY
62412: LIST
62413: LIST
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: PPUSH
62419: CALL_OW 72
62423: ST_TO_ADDR
// if not vehicles then
62424: LD_VAR 0 1
62428: NOT
62429: IFFALSE 62433
// exit ;
62431: GO 62460
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
62433: LD_VAR 0 1
62437: PPUSH
62438: LD_VAR 0 2
62442: PUSH
62443: LD_INT 1
62445: ARRAY
62446: PPUSH
62447: LD_VAR 0 2
62451: PUSH
62452: LD_INT 2
62454: ARRAY
62455: PPUSH
62456: CALL_OW 111
// end ;
62460: LD_VAR 0 3
62464: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
62465: LD_INT 0
62467: PPUSH
62468: PPUSH
62469: PPUSH
// if not side or not area then
62470: LD_VAR 0 1
62474: NOT
62475: PUSH
62476: LD_VAR 0 2
62480: NOT
62481: OR
62482: IFFALSE 62486
// exit ;
62484: GO 62605
// tmp := AreaToList ( area , 0 ) ;
62486: LD_ADDR_VAR 0 5
62490: PUSH
62491: LD_VAR 0 2
62495: PPUSH
62496: LD_INT 0
62498: PPUSH
62499: CALL_OW 517
62503: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
62504: LD_ADDR_VAR 0 4
62508: PUSH
62509: DOUBLE
62510: LD_INT 1
62512: DEC
62513: ST_TO_ADDR
62514: LD_VAR 0 5
62518: PUSH
62519: LD_INT 1
62521: ARRAY
62522: PUSH
62523: FOR_TO
62524: IFFALSE 62603
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
62526: LD_VAR 0 5
62530: PUSH
62531: LD_INT 1
62533: ARRAY
62534: PUSH
62535: LD_VAR 0 4
62539: ARRAY
62540: PPUSH
62541: LD_VAR 0 5
62545: PUSH
62546: LD_INT 2
62548: ARRAY
62549: PUSH
62550: LD_VAR 0 4
62554: ARRAY
62555: PPUSH
62556: CALL_OW 351
62560: IFFALSE 62601
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
62562: LD_VAR 0 5
62566: PUSH
62567: LD_INT 1
62569: ARRAY
62570: PUSH
62571: LD_VAR 0 4
62575: ARRAY
62576: PPUSH
62577: LD_VAR 0 5
62581: PUSH
62582: LD_INT 2
62584: ARRAY
62585: PUSH
62586: LD_VAR 0 4
62590: ARRAY
62591: PPUSH
62592: LD_VAR 0 1
62596: PPUSH
62597: CALL_OW 244
// end ;
62601: GO 62523
62603: POP
62604: POP
// end ; end_of_file
62605: LD_VAR 0 3
62609: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
62610: LD_INT 0
62612: PPUSH
62613: PPUSH
// skirmish := false ;
62614: LD_ADDR_EXP 29
62618: PUSH
62619: LD_INT 0
62621: ST_TO_ADDR
// debug_mc := false ;
62622: LD_ADDR_EXP 30
62626: PUSH
62627: LD_INT 0
62629: ST_TO_ADDR
// mc_bases := [ ] ;
62630: LD_ADDR_EXP 31
62634: PUSH
62635: EMPTY
62636: ST_TO_ADDR
// mc_sides := [ ] ;
62637: LD_ADDR_EXP 57
62641: PUSH
62642: EMPTY
62643: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
62644: LD_ADDR_EXP 32
62648: PUSH
62649: EMPTY
62650: ST_TO_ADDR
// mc_building_repairs := [ ] ;
62651: LD_ADDR_EXP 33
62655: PUSH
62656: EMPTY
62657: ST_TO_ADDR
// mc_need_heal := [ ] ;
62658: LD_ADDR_EXP 34
62662: PUSH
62663: EMPTY
62664: ST_TO_ADDR
// mc_healers := [ ] ;
62665: LD_ADDR_EXP 35
62669: PUSH
62670: EMPTY
62671: ST_TO_ADDR
// mc_build_list := [ ] ;
62672: LD_ADDR_EXP 36
62676: PUSH
62677: EMPTY
62678: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
62679: LD_ADDR_EXP 63
62683: PUSH
62684: EMPTY
62685: ST_TO_ADDR
// mc_builders := [ ] ;
62686: LD_ADDR_EXP 37
62690: PUSH
62691: EMPTY
62692: ST_TO_ADDR
// mc_construct_list := [ ] ;
62693: LD_ADDR_EXP 38
62697: PUSH
62698: EMPTY
62699: ST_TO_ADDR
// mc_turret_list := [ ] ;
62700: LD_ADDR_EXP 39
62704: PUSH
62705: EMPTY
62706: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
62707: LD_ADDR_EXP 40
62711: PUSH
62712: EMPTY
62713: ST_TO_ADDR
// mc_miners := [ ] ;
62714: LD_ADDR_EXP 45
62718: PUSH
62719: EMPTY
62720: ST_TO_ADDR
// mc_mines := [ ] ;
62721: LD_ADDR_EXP 44
62725: PUSH
62726: EMPTY
62727: ST_TO_ADDR
// mc_minefields := [ ] ;
62728: LD_ADDR_EXP 46
62732: PUSH
62733: EMPTY
62734: ST_TO_ADDR
// mc_crates := [ ] ;
62735: LD_ADDR_EXP 47
62739: PUSH
62740: EMPTY
62741: ST_TO_ADDR
// mc_crates_collector := [ ] ;
62742: LD_ADDR_EXP 48
62746: PUSH
62747: EMPTY
62748: ST_TO_ADDR
// mc_crates_area := [ ] ;
62749: LD_ADDR_EXP 49
62753: PUSH
62754: EMPTY
62755: ST_TO_ADDR
// mc_vehicles := [ ] ;
62756: LD_ADDR_EXP 50
62760: PUSH
62761: EMPTY
62762: ST_TO_ADDR
// mc_attack := [ ] ;
62763: LD_ADDR_EXP 51
62767: PUSH
62768: EMPTY
62769: ST_TO_ADDR
// mc_produce := [ ] ;
62770: LD_ADDR_EXP 52
62774: PUSH
62775: EMPTY
62776: ST_TO_ADDR
// mc_defender := [ ] ;
62777: LD_ADDR_EXP 53
62781: PUSH
62782: EMPTY
62783: ST_TO_ADDR
// mc_parking := [ ] ;
62784: LD_ADDR_EXP 55
62788: PUSH
62789: EMPTY
62790: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
62791: LD_ADDR_EXP 41
62795: PUSH
62796: EMPTY
62797: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
62798: LD_ADDR_EXP 43
62802: PUSH
62803: EMPTY
62804: ST_TO_ADDR
// mc_scan := [ ] ;
62805: LD_ADDR_EXP 54
62809: PUSH
62810: EMPTY
62811: ST_TO_ADDR
// mc_scan_area := [ ] ;
62812: LD_ADDR_EXP 56
62816: PUSH
62817: EMPTY
62818: ST_TO_ADDR
// mc_tech := [ ] ;
62819: LD_ADDR_EXP 58
62823: PUSH
62824: EMPTY
62825: ST_TO_ADDR
// mc_class := [ ] ;
62826: LD_ADDR_EXP 72
62830: PUSH
62831: EMPTY
62832: ST_TO_ADDR
// mc_class_case_use := [ ] ;
62833: LD_ADDR_EXP 73
62837: PUSH
62838: EMPTY
62839: ST_TO_ADDR
// mc_is_defending := [ ] ;
62840: LD_ADDR_EXP 74
62844: PUSH
62845: EMPTY
62846: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
62847: LD_ADDR_EXP 65
62851: PUSH
62852: EMPTY
62853: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
62854: LD_ADDR_EXP 75
62858: PUSH
62859: LD_INT 0
62861: ST_TO_ADDR
// end ;
62862: LD_VAR 0 1
62866: RET
// export function MC_Kill ( base ) ; begin
62867: LD_INT 0
62869: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
62870: LD_ADDR_EXP 31
62874: PUSH
62875: LD_EXP 31
62879: PPUSH
62880: LD_VAR 0 1
62884: PPUSH
62885: EMPTY
62886: PPUSH
62887: CALL_OW 1
62891: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62892: LD_ADDR_EXP 32
62896: PUSH
62897: LD_EXP 32
62901: PPUSH
62902: LD_VAR 0 1
62906: PPUSH
62907: EMPTY
62908: PPUSH
62909: CALL_OW 1
62913: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62914: LD_ADDR_EXP 33
62918: PUSH
62919: LD_EXP 33
62923: PPUSH
62924: LD_VAR 0 1
62928: PPUSH
62929: EMPTY
62930: PPUSH
62931: CALL_OW 1
62935: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62936: LD_ADDR_EXP 34
62940: PUSH
62941: LD_EXP 34
62945: PPUSH
62946: LD_VAR 0 1
62950: PPUSH
62951: EMPTY
62952: PPUSH
62953: CALL_OW 1
62957: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62958: LD_ADDR_EXP 35
62962: PUSH
62963: LD_EXP 35
62967: PPUSH
62968: LD_VAR 0 1
62972: PPUSH
62973: EMPTY
62974: PPUSH
62975: CALL_OW 1
62979: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62980: LD_ADDR_EXP 36
62984: PUSH
62985: LD_EXP 36
62989: PPUSH
62990: LD_VAR 0 1
62994: PPUSH
62995: EMPTY
62996: PPUSH
62997: CALL_OW 1
63001: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63002: LD_ADDR_EXP 37
63006: PUSH
63007: LD_EXP 37
63011: PPUSH
63012: LD_VAR 0 1
63016: PPUSH
63017: EMPTY
63018: PPUSH
63019: CALL_OW 1
63023: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63024: LD_ADDR_EXP 38
63028: PUSH
63029: LD_EXP 38
63033: PPUSH
63034: LD_VAR 0 1
63038: PPUSH
63039: EMPTY
63040: PPUSH
63041: CALL_OW 1
63045: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63046: LD_ADDR_EXP 39
63050: PUSH
63051: LD_EXP 39
63055: PPUSH
63056: LD_VAR 0 1
63060: PPUSH
63061: EMPTY
63062: PPUSH
63063: CALL_OW 1
63067: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63068: LD_ADDR_EXP 40
63072: PUSH
63073: LD_EXP 40
63077: PPUSH
63078: LD_VAR 0 1
63082: PPUSH
63083: EMPTY
63084: PPUSH
63085: CALL_OW 1
63089: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63090: LD_ADDR_EXP 41
63094: PUSH
63095: LD_EXP 41
63099: PPUSH
63100: LD_VAR 0 1
63104: PPUSH
63105: EMPTY
63106: PPUSH
63107: CALL_OW 1
63111: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
63112: LD_ADDR_EXP 42
63116: PUSH
63117: LD_EXP 42
63121: PPUSH
63122: LD_VAR 0 1
63126: PPUSH
63127: LD_INT 0
63129: PPUSH
63130: CALL_OW 1
63134: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
63135: LD_ADDR_EXP 43
63139: PUSH
63140: LD_EXP 43
63144: PPUSH
63145: LD_VAR 0 1
63149: PPUSH
63150: EMPTY
63151: PPUSH
63152: CALL_OW 1
63156: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
63157: LD_ADDR_EXP 44
63161: PUSH
63162: LD_EXP 44
63166: PPUSH
63167: LD_VAR 0 1
63171: PPUSH
63172: EMPTY
63173: PPUSH
63174: CALL_OW 1
63178: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
63179: LD_ADDR_EXP 45
63183: PUSH
63184: LD_EXP 45
63188: PPUSH
63189: LD_VAR 0 1
63193: PPUSH
63194: EMPTY
63195: PPUSH
63196: CALL_OW 1
63200: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
63201: LD_ADDR_EXP 46
63205: PUSH
63206: LD_EXP 46
63210: PPUSH
63211: LD_VAR 0 1
63215: PPUSH
63216: EMPTY
63217: PPUSH
63218: CALL_OW 1
63222: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
63223: LD_ADDR_EXP 47
63227: PUSH
63228: LD_EXP 47
63232: PPUSH
63233: LD_VAR 0 1
63237: PPUSH
63238: EMPTY
63239: PPUSH
63240: CALL_OW 1
63244: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
63245: LD_ADDR_EXP 48
63249: PUSH
63250: LD_EXP 48
63254: PPUSH
63255: LD_VAR 0 1
63259: PPUSH
63260: EMPTY
63261: PPUSH
63262: CALL_OW 1
63266: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
63267: LD_ADDR_EXP 49
63271: PUSH
63272: LD_EXP 49
63276: PPUSH
63277: LD_VAR 0 1
63281: PPUSH
63282: EMPTY
63283: PPUSH
63284: CALL_OW 1
63288: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63289: LD_ADDR_EXP 50
63293: PUSH
63294: LD_EXP 50
63298: PPUSH
63299: LD_VAR 0 1
63303: PPUSH
63304: EMPTY
63305: PPUSH
63306: CALL_OW 1
63310: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
63311: LD_ADDR_EXP 51
63315: PUSH
63316: LD_EXP 51
63320: PPUSH
63321: LD_VAR 0 1
63325: PPUSH
63326: EMPTY
63327: PPUSH
63328: CALL_OW 1
63332: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63333: LD_ADDR_EXP 52
63337: PUSH
63338: LD_EXP 52
63342: PPUSH
63343: LD_VAR 0 1
63347: PPUSH
63348: EMPTY
63349: PPUSH
63350: CALL_OW 1
63354: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63355: LD_ADDR_EXP 53
63359: PUSH
63360: LD_EXP 53
63364: PPUSH
63365: LD_VAR 0 1
63369: PPUSH
63370: EMPTY
63371: PPUSH
63372: CALL_OW 1
63376: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63377: LD_ADDR_EXP 54
63381: PUSH
63382: LD_EXP 54
63386: PPUSH
63387: LD_VAR 0 1
63391: PPUSH
63392: EMPTY
63393: PPUSH
63394: CALL_OW 1
63398: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63399: LD_ADDR_EXP 55
63403: PUSH
63404: LD_EXP 55
63408: PPUSH
63409: LD_VAR 0 1
63413: PPUSH
63414: EMPTY
63415: PPUSH
63416: CALL_OW 1
63420: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63421: LD_ADDR_EXP 56
63425: PUSH
63426: LD_EXP 56
63430: PPUSH
63431: LD_VAR 0 1
63435: PPUSH
63436: EMPTY
63437: PPUSH
63438: CALL_OW 1
63442: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63443: LD_ADDR_EXP 58
63447: PUSH
63448: LD_EXP 58
63452: PPUSH
63453: LD_VAR 0 1
63457: PPUSH
63458: EMPTY
63459: PPUSH
63460: CALL_OW 1
63464: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63465: LD_ADDR_EXP 60
63469: PUSH
63470: LD_EXP 60
63474: PPUSH
63475: LD_VAR 0 1
63479: PPUSH
63480: EMPTY
63481: PPUSH
63482: CALL_OW 1
63486: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63487: LD_ADDR_EXP 61
63491: PUSH
63492: LD_EXP 61
63496: PPUSH
63497: LD_VAR 0 1
63501: PPUSH
63502: EMPTY
63503: PPUSH
63504: CALL_OW 1
63508: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63509: LD_ADDR_EXP 62
63513: PUSH
63514: LD_EXP 62
63518: PPUSH
63519: LD_VAR 0 1
63523: PPUSH
63524: EMPTY
63525: PPUSH
63526: CALL_OW 1
63530: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63531: LD_ADDR_EXP 63
63535: PUSH
63536: LD_EXP 63
63540: PPUSH
63541: LD_VAR 0 1
63545: PPUSH
63546: EMPTY
63547: PPUSH
63548: CALL_OW 1
63552: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63553: LD_ADDR_EXP 64
63557: PUSH
63558: LD_EXP 64
63562: PPUSH
63563: LD_VAR 0 1
63567: PPUSH
63568: EMPTY
63569: PPUSH
63570: CALL_OW 1
63574: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63575: LD_ADDR_EXP 65
63579: PUSH
63580: LD_EXP 65
63584: PPUSH
63585: LD_VAR 0 1
63589: PPUSH
63590: EMPTY
63591: PPUSH
63592: CALL_OW 1
63596: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63597: LD_ADDR_EXP 66
63601: PUSH
63602: LD_EXP 66
63606: PPUSH
63607: LD_VAR 0 1
63611: PPUSH
63612: EMPTY
63613: PPUSH
63614: CALL_OW 1
63618: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63619: LD_ADDR_EXP 67
63623: PUSH
63624: LD_EXP 67
63628: PPUSH
63629: LD_VAR 0 1
63633: PPUSH
63634: EMPTY
63635: PPUSH
63636: CALL_OW 1
63640: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63641: LD_ADDR_EXP 68
63645: PUSH
63646: LD_EXP 68
63650: PPUSH
63651: LD_VAR 0 1
63655: PPUSH
63656: EMPTY
63657: PPUSH
63658: CALL_OW 1
63662: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63663: LD_ADDR_EXP 69
63667: PUSH
63668: LD_EXP 69
63672: PPUSH
63673: LD_VAR 0 1
63677: PPUSH
63678: EMPTY
63679: PPUSH
63680: CALL_OW 1
63684: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63685: LD_ADDR_EXP 70
63689: PUSH
63690: LD_EXP 70
63694: PPUSH
63695: LD_VAR 0 1
63699: PPUSH
63700: EMPTY
63701: PPUSH
63702: CALL_OW 1
63706: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63707: LD_ADDR_EXP 71
63711: PUSH
63712: LD_EXP 71
63716: PPUSH
63717: LD_VAR 0 1
63721: PPUSH
63722: EMPTY
63723: PPUSH
63724: CALL_OW 1
63728: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63729: LD_ADDR_EXP 72
63733: PUSH
63734: LD_EXP 72
63738: PPUSH
63739: LD_VAR 0 1
63743: PPUSH
63744: EMPTY
63745: PPUSH
63746: CALL_OW 1
63750: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63751: LD_ADDR_EXP 73
63755: PUSH
63756: LD_EXP 73
63760: PPUSH
63761: LD_VAR 0 1
63765: PPUSH
63766: LD_INT 0
63768: PPUSH
63769: CALL_OW 1
63773: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63774: LD_ADDR_EXP 74
63778: PUSH
63779: LD_EXP 74
63783: PPUSH
63784: LD_VAR 0 1
63788: PPUSH
63789: LD_INT 0
63791: PPUSH
63792: CALL_OW 1
63796: ST_TO_ADDR
// end ;
63797: LD_VAR 0 2
63801: RET
// export function MC_Add ( side , units ) ; var base ; begin
63802: LD_INT 0
63804: PPUSH
63805: PPUSH
// base := mc_bases + 1 ;
63806: LD_ADDR_VAR 0 4
63810: PUSH
63811: LD_EXP 31
63815: PUSH
63816: LD_INT 1
63818: PLUS
63819: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
63820: LD_ADDR_EXP 57
63824: PUSH
63825: LD_EXP 57
63829: PPUSH
63830: LD_VAR 0 4
63834: PPUSH
63835: LD_VAR 0 1
63839: PPUSH
63840: CALL_OW 1
63844: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
63845: LD_ADDR_EXP 31
63849: PUSH
63850: LD_EXP 31
63854: PPUSH
63855: LD_VAR 0 4
63859: PPUSH
63860: LD_VAR 0 2
63864: PPUSH
63865: CALL_OW 1
63869: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
63870: LD_ADDR_EXP 32
63874: PUSH
63875: LD_EXP 32
63879: PPUSH
63880: LD_VAR 0 4
63884: PPUSH
63885: EMPTY
63886: PPUSH
63887: CALL_OW 1
63891: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63892: LD_ADDR_EXP 33
63896: PUSH
63897: LD_EXP 33
63901: PPUSH
63902: LD_VAR 0 4
63906: PPUSH
63907: EMPTY
63908: PPUSH
63909: CALL_OW 1
63913: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63914: LD_ADDR_EXP 34
63918: PUSH
63919: LD_EXP 34
63923: PPUSH
63924: LD_VAR 0 4
63928: PPUSH
63929: EMPTY
63930: PPUSH
63931: CALL_OW 1
63935: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63936: LD_ADDR_EXP 35
63940: PUSH
63941: LD_EXP 35
63945: PPUSH
63946: LD_VAR 0 4
63950: PPUSH
63951: EMPTY
63952: PPUSH
63953: CALL_OW 1
63957: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63958: LD_ADDR_EXP 36
63962: PUSH
63963: LD_EXP 36
63967: PPUSH
63968: LD_VAR 0 4
63972: PPUSH
63973: EMPTY
63974: PPUSH
63975: CALL_OW 1
63979: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63980: LD_ADDR_EXP 37
63984: PUSH
63985: LD_EXP 37
63989: PPUSH
63990: LD_VAR 0 4
63994: PPUSH
63995: EMPTY
63996: PPUSH
63997: CALL_OW 1
64001: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
64002: LD_ADDR_EXP 38
64006: PUSH
64007: LD_EXP 38
64011: PPUSH
64012: LD_VAR 0 4
64016: PPUSH
64017: EMPTY
64018: PPUSH
64019: CALL_OW 1
64023: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
64024: LD_ADDR_EXP 39
64028: PUSH
64029: LD_EXP 39
64033: PPUSH
64034: LD_VAR 0 4
64038: PPUSH
64039: EMPTY
64040: PPUSH
64041: CALL_OW 1
64045: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
64046: LD_ADDR_EXP 40
64050: PUSH
64051: LD_EXP 40
64055: PPUSH
64056: LD_VAR 0 4
64060: PPUSH
64061: EMPTY
64062: PPUSH
64063: CALL_OW 1
64067: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
64068: LD_ADDR_EXP 41
64072: PUSH
64073: LD_EXP 41
64077: PPUSH
64078: LD_VAR 0 4
64082: PPUSH
64083: EMPTY
64084: PPUSH
64085: CALL_OW 1
64089: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
64090: LD_ADDR_EXP 42
64094: PUSH
64095: LD_EXP 42
64099: PPUSH
64100: LD_VAR 0 4
64104: PPUSH
64105: LD_INT 0
64107: PPUSH
64108: CALL_OW 1
64112: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
64113: LD_ADDR_EXP 43
64117: PUSH
64118: LD_EXP 43
64122: PPUSH
64123: LD_VAR 0 4
64127: PPUSH
64128: EMPTY
64129: PPUSH
64130: CALL_OW 1
64134: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
64135: LD_ADDR_EXP 44
64139: PUSH
64140: LD_EXP 44
64144: PPUSH
64145: LD_VAR 0 4
64149: PPUSH
64150: EMPTY
64151: PPUSH
64152: CALL_OW 1
64156: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
64157: LD_ADDR_EXP 45
64161: PUSH
64162: LD_EXP 45
64166: PPUSH
64167: LD_VAR 0 4
64171: PPUSH
64172: EMPTY
64173: PPUSH
64174: CALL_OW 1
64178: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
64179: LD_ADDR_EXP 46
64183: PUSH
64184: LD_EXP 46
64188: PPUSH
64189: LD_VAR 0 4
64193: PPUSH
64194: EMPTY
64195: PPUSH
64196: CALL_OW 1
64200: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
64201: LD_ADDR_EXP 47
64205: PUSH
64206: LD_EXP 47
64210: PPUSH
64211: LD_VAR 0 4
64215: PPUSH
64216: EMPTY
64217: PPUSH
64218: CALL_OW 1
64222: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
64223: LD_ADDR_EXP 48
64227: PUSH
64228: LD_EXP 48
64232: PPUSH
64233: LD_VAR 0 4
64237: PPUSH
64238: EMPTY
64239: PPUSH
64240: CALL_OW 1
64244: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
64245: LD_ADDR_EXP 49
64249: PUSH
64250: LD_EXP 49
64254: PPUSH
64255: LD_VAR 0 4
64259: PPUSH
64260: EMPTY
64261: PPUSH
64262: CALL_OW 1
64266: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
64267: LD_ADDR_EXP 50
64271: PUSH
64272: LD_EXP 50
64276: PPUSH
64277: LD_VAR 0 4
64281: PPUSH
64282: EMPTY
64283: PPUSH
64284: CALL_OW 1
64288: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
64289: LD_ADDR_EXP 51
64293: PUSH
64294: LD_EXP 51
64298: PPUSH
64299: LD_VAR 0 4
64303: PPUSH
64304: EMPTY
64305: PPUSH
64306: CALL_OW 1
64310: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
64311: LD_ADDR_EXP 52
64315: PUSH
64316: LD_EXP 52
64320: PPUSH
64321: LD_VAR 0 4
64325: PPUSH
64326: EMPTY
64327: PPUSH
64328: CALL_OW 1
64332: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
64333: LD_ADDR_EXP 53
64337: PUSH
64338: LD_EXP 53
64342: PPUSH
64343: LD_VAR 0 4
64347: PPUSH
64348: EMPTY
64349: PPUSH
64350: CALL_OW 1
64354: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
64355: LD_ADDR_EXP 54
64359: PUSH
64360: LD_EXP 54
64364: PPUSH
64365: LD_VAR 0 4
64369: PPUSH
64370: EMPTY
64371: PPUSH
64372: CALL_OW 1
64376: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
64377: LD_ADDR_EXP 55
64381: PUSH
64382: LD_EXP 55
64386: PPUSH
64387: LD_VAR 0 4
64391: PPUSH
64392: EMPTY
64393: PPUSH
64394: CALL_OW 1
64398: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
64399: LD_ADDR_EXP 56
64403: PUSH
64404: LD_EXP 56
64408: PPUSH
64409: LD_VAR 0 4
64413: PPUSH
64414: EMPTY
64415: PPUSH
64416: CALL_OW 1
64420: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
64421: LD_ADDR_EXP 58
64425: PUSH
64426: LD_EXP 58
64430: PPUSH
64431: LD_VAR 0 4
64435: PPUSH
64436: EMPTY
64437: PPUSH
64438: CALL_OW 1
64442: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
64443: LD_ADDR_EXP 60
64447: PUSH
64448: LD_EXP 60
64452: PPUSH
64453: LD_VAR 0 4
64457: PPUSH
64458: EMPTY
64459: PPUSH
64460: CALL_OW 1
64464: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
64465: LD_ADDR_EXP 61
64469: PUSH
64470: LD_EXP 61
64474: PPUSH
64475: LD_VAR 0 4
64479: PPUSH
64480: EMPTY
64481: PPUSH
64482: CALL_OW 1
64486: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
64487: LD_ADDR_EXP 62
64491: PUSH
64492: LD_EXP 62
64496: PPUSH
64497: LD_VAR 0 4
64501: PPUSH
64502: EMPTY
64503: PPUSH
64504: CALL_OW 1
64508: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
64509: LD_ADDR_EXP 63
64513: PUSH
64514: LD_EXP 63
64518: PPUSH
64519: LD_VAR 0 4
64523: PPUSH
64524: EMPTY
64525: PPUSH
64526: CALL_OW 1
64530: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
64531: LD_ADDR_EXP 64
64535: PUSH
64536: LD_EXP 64
64540: PPUSH
64541: LD_VAR 0 4
64545: PPUSH
64546: EMPTY
64547: PPUSH
64548: CALL_OW 1
64552: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
64553: LD_ADDR_EXP 65
64557: PUSH
64558: LD_EXP 65
64562: PPUSH
64563: LD_VAR 0 4
64567: PPUSH
64568: EMPTY
64569: PPUSH
64570: CALL_OW 1
64574: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
64575: LD_ADDR_EXP 66
64579: PUSH
64580: LD_EXP 66
64584: PPUSH
64585: LD_VAR 0 4
64589: PPUSH
64590: EMPTY
64591: PPUSH
64592: CALL_OW 1
64596: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
64597: LD_ADDR_EXP 67
64601: PUSH
64602: LD_EXP 67
64606: PPUSH
64607: LD_VAR 0 4
64611: PPUSH
64612: EMPTY
64613: PPUSH
64614: CALL_OW 1
64618: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
64619: LD_ADDR_EXP 68
64623: PUSH
64624: LD_EXP 68
64628: PPUSH
64629: LD_VAR 0 4
64633: PPUSH
64634: EMPTY
64635: PPUSH
64636: CALL_OW 1
64640: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
64641: LD_ADDR_EXP 69
64645: PUSH
64646: LD_EXP 69
64650: PPUSH
64651: LD_VAR 0 4
64655: PPUSH
64656: EMPTY
64657: PPUSH
64658: CALL_OW 1
64662: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
64663: LD_ADDR_EXP 70
64667: PUSH
64668: LD_EXP 70
64672: PPUSH
64673: LD_VAR 0 4
64677: PPUSH
64678: EMPTY
64679: PPUSH
64680: CALL_OW 1
64684: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
64685: LD_ADDR_EXP 71
64689: PUSH
64690: LD_EXP 71
64694: PPUSH
64695: LD_VAR 0 4
64699: PPUSH
64700: EMPTY
64701: PPUSH
64702: CALL_OW 1
64706: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
64707: LD_ADDR_EXP 72
64711: PUSH
64712: LD_EXP 72
64716: PPUSH
64717: LD_VAR 0 4
64721: PPUSH
64722: EMPTY
64723: PPUSH
64724: CALL_OW 1
64728: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
64729: LD_ADDR_EXP 73
64733: PUSH
64734: LD_EXP 73
64738: PPUSH
64739: LD_VAR 0 4
64743: PPUSH
64744: LD_INT 0
64746: PPUSH
64747: CALL_OW 1
64751: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
64752: LD_ADDR_EXP 74
64756: PUSH
64757: LD_EXP 74
64761: PPUSH
64762: LD_VAR 0 4
64766: PPUSH
64767: LD_INT 0
64769: PPUSH
64770: CALL_OW 1
64774: ST_TO_ADDR
// result := base ;
64775: LD_ADDR_VAR 0 3
64779: PUSH
64780: LD_VAR 0 4
64784: ST_TO_ADDR
// end ;
64785: LD_VAR 0 3
64789: RET
// export function MC_Start ( ) ; var i ; begin
64790: LD_INT 0
64792: PPUSH
64793: PPUSH
// for i = 1 to mc_bases do
64794: LD_ADDR_VAR 0 2
64798: PUSH
64799: DOUBLE
64800: LD_INT 1
64802: DEC
64803: ST_TO_ADDR
64804: LD_EXP 31
64808: PUSH
64809: FOR_TO
64810: IFFALSE 65910
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
64812: LD_ADDR_EXP 31
64816: PUSH
64817: LD_EXP 31
64821: PPUSH
64822: LD_VAR 0 2
64826: PPUSH
64827: LD_EXP 31
64831: PUSH
64832: LD_VAR 0 2
64836: ARRAY
64837: PUSH
64838: LD_INT 0
64840: DIFF
64841: PPUSH
64842: CALL_OW 1
64846: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
64847: LD_ADDR_EXP 32
64851: PUSH
64852: LD_EXP 32
64856: PPUSH
64857: LD_VAR 0 2
64861: PPUSH
64862: EMPTY
64863: PPUSH
64864: CALL_OW 1
64868: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64869: LD_ADDR_EXP 33
64873: PUSH
64874: LD_EXP 33
64878: PPUSH
64879: LD_VAR 0 2
64883: PPUSH
64884: EMPTY
64885: PPUSH
64886: CALL_OW 1
64890: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
64891: LD_ADDR_EXP 34
64895: PUSH
64896: LD_EXP 34
64900: PPUSH
64901: LD_VAR 0 2
64905: PPUSH
64906: EMPTY
64907: PPUSH
64908: CALL_OW 1
64912: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
64913: LD_ADDR_EXP 35
64917: PUSH
64918: LD_EXP 35
64922: PPUSH
64923: LD_VAR 0 2
64927: PPUSH
64928: EMPTY
64929: PUSH
64930: EMPTY
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PPUSH
64936: CALL_OW 1
64940: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
64941: LD_ADDR_EXP 36
64945: PUSH
64946: LD_EXP 36
64950: PPUSH
64951: LD_VAR 0 2
64955: PPUSH
64956: EMPTY
64957: PPUSH
64958: CALL_OW 1
64962: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
64963: LD_ADDR_EXP 63
64967: PUSH
64968: LD_EXP 63
64972: PPUSH
64973: LD_VAR 0 2
64977: PPUSH
64978: EMPTY
64979: PPUSH
64980: CALL_OW 1
64984: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
64985: LD_ADDR_EXP 37
64989: PUSH
64990: LD_EXP 37
64994: PPUSH
64995: LD_VAR 0 2
64999: PPUSH
65000: EMPTY
65001: PPUSH
65002: CALL_OW 1
65006: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
65007: LD_ADDR_EXP 38
65011: PUSH
65012: LD_EXP 38
65016: PPUSH
65017: LD_VAR 0 2
65021: PPUSH
65022: EMPTY
65023: PPUSH
65024: CALL_OW 1
65028: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
65029: LD_ADDR_EXP 39
65033: PUSH
65034: LD_EXP 39
65038: PPUSH
65039: LD_VAR 0 2
65043: PPUSH
65044: LD_EXP 31
65048: PUSH
65049: LD_VAR 0 2
65053: ARRAY
65054: PPUSH
65055: LD_INT 2
65057: PUSH
65058: LD_INT 30
65060: PUSH
65061: LD_INT 32
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: PUSH
65068: LD_INT 30
65070: PUSH
65071: LD_INT 33
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: LIST
65082: PPUSH
65083: CALL_OW 72
65087: PPUSH
65088: CALL_OW 1
65092: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
65093: LD_ADDR_EXP 40
65097: PUSH
65098: LD_EXP 40
65102: PPUSH
65103: LD_VAR 0 2
65107: PPUSH
65108: LD_EXP 31
65112: PUSH
65113: LD_VAR 0 2
65117: ARRAY
65118: PPUSH
65119: LD_INT 2
65121: PUSH
65122: LD_INT 30
65124: PUSH
65125: LD_INT 32
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: LD_INT 30
65134: PUSH
65135: LD_INT 31
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: LIST
65146: PUSH
65147: LD_INT 58
65149: PUSH
65150: EMPTY
65151: LIST
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PPUSH
65157: CALL_OW 72
65161: PPUSH
65162: CALL_OW 1
65166: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
65167: LD_ADDR_EXP 41
65171: PUSH
65172: LD_EXP 41
65176: PPUSH
65177: LD_VAR 0 2
65181: PPUSH
65182: EMPTY
65183: PPUSH
65184: CALL_OW 1
65188: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
65189: LD_ADDR_EXP 45
65193: PUSH
65194: LD_EXP 45
65198: PPUSH
65199: LD_VAR 0 2
65203: PPUSH
65204: EMPTY
65205: PPUSH
65206: CALL_OW 1
65210: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
65211: LD_ADDR_EXP 44
65215: PUSH
65216: LD_EXP 44
65220: PPUSH
65221: LD_VAR 0 2
65225: PPUSH
65226: EMPTY
65227: PPUSH
65228: CALL_OW 1
65232: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
65233: LD_ADDR_EXP 46
65237: PUSH
65238: LD_EXP 46
65242: PPUSH
65243: LD_VAR 0 2
65247: PPUSH
65248: EMPTY
65249: PPUSH
65250: CALL_OW 1
65254: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
65255: LD_ADDR_EXP 47
65259: PUSH
65260: LD_EXP 47
65264: PPUSH
65265: LD_VAR 0 2
65269: PPUSH
65270: EMPTY
65271: PPUSH
65272: CALL_OW 1
65276: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65277: LD_ADDR_EXP 48
65281: PUSH
65282: LD_EXP 48
65286: PPUSH
65287: LD_VAR 0 2
65291: PPUSH
65292: EMPTY
65293: PPUSH
65294: CALL_OW 1
65298: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
65299: LD_ADDR_EXP 49
65303: PUSH
65304: LD_EXP 49
65308: PPUSH
65309: LD_VAR 0 2
65313: PPUSH
65314: EMPTY
65315: PPUSH
65316: CALL_OW 1
65320: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
65321: LD_ADDR_EXP 50
65325: PUSH
65326: LD_EXP 50
65330: PPUSH
65331: LD_VAR 0 2
65335: PPUSH
65336: EMPTY
65337: PPUSH
65338: CALL_OW 1
65342: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65343: LD_ADDR_EXP 51
65347: PUSH
65348: LD_EXP 51
65352: PPUSH
65353: LD_VAR 0 2
65357: PPUSH
65358: EMPTY
65359: PPUSH
65360: CALL_OW 1
65364: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
65365: LD_ADDR_EXP 52
65369: PUSH
65370: LD_EXP 52
65374: PPUSH
65375: LD_VAR 0 2
65379: PPUSH
65380: EMPTY
65381: PPUSH
65382: CALL_OW 1
65386: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
65387: LD_ADDR_EXP 53
65391: PUSH
65392: LD_EXP 53
65396: PPUSH
65397: LD_VAR 0 2
65401: PPUSH
65402: EMPTY
65403: PPUSH
65404: CALL_OW 1
65408: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
65409: LD_ADDR_EXP 42
65413: PUSH
65414: LD_EXP 42
65418: PPUSH
65419: LD_VAR 0 2
65423: PPUSH
65424: LD_INT 0
65426: PPUSH
65427: CALL_OW 1
65431: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
65432: LD_ADDR_EXP 55
65436: PUSH
65437: LD_EXP 55
65441: PPUSH
65442: LD_VAR 0 2
65446: PPUSH
65447: LD_INT 0
65449: PPUSH
65450: CALL_OW 1
65454: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
65455: LD_ADDR_EXP 43
65459: PUSH
65460: LD_EXP 43
65464: PPUSH
65465: LD_VAR 0 2
65469: PPUSH
65470: EMPTY
65471: PPUSH
65472: CALL_OW 1
65476: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
65477: LD_ADDR_EXP 54
65481: PUSH
65482: LD_EXP 54
65486: PPUSH
65487: LD_VAR 0 2
65491: PPUSH
65492: LD_INT 0
65494: PPUSH
65495: CALL_OW 1
65499: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
65500: LD_ADDR_EXP 56
65504: PUSH
65505: LD_EXP 56
65509: PPUSH
65510: LD_VAR 0 2
65514: PPUSH
65515: EMPTY
65516: PPUSH
65517: CALL_OW 1
65521: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
65522: LD_ADDR_EXP 59
65526: PUSH
65527: LD_EXP 59
65531: PPUSH
65532: LD_VAR 0 2
65536: PPUSH
65537: LD_INT 0
65539: PPUSH
65540: CALL_OW 1
65544: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
65545: LD_ADDR_EXP 60
65549: PUSH
65550: LD_EXP 60
65554: PPUSH
65555: LD_VAR 0 2
65559: PPUSH
65560: EMPTY
65561: PPUSH
65562: CALL_OW 1
65566: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65567: LD_ADDR_EXP 61
65571: PUSH
65572: LD_EXP 61
65576: PPUSH
65577: LD_VAR 0 2
65581: PPUSH
65582: EMPTY
65583: PPUSH
65584: CALL_OW 1
65588: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65589: LD_ADDR_EXP 62
65593: PUSH
65594: LD_EXP 62
65598: PPUSH
65599: LD_VAR 0 2
65603: PPUSH
65604: EMPTY
65605: PPUSH
65606: CALL_OW 1
65610: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
65611: LD_ADDR_EXP 64
65615: PUSH
65616: LD_EXP 64
65620: PPUSH
65621: LD_VAR 0 2
65625: PPUSH
65626: LD_EXP 31
65630: PUSH
65631: LD_VAR 0 2
65635: ARRAY
65636: PPUSH
65637: LD_INT 2
65639: PUSH
65640: LD_INT 30
65642: PUSH
65643: LD_INT 6
65645: PUSH
65646: EMPTY
65647: LIST
65648: LIST
65649: PUSH
65650: LD_INT 30
65652: PUSH
65653: LD_INT 7
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 30
65662: PUSH
65663: LD_INT 8
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: PPUSH
65676: CALL_OW 72
65680: PPUSH
65681: CALL_OW 1
65685: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
65686: LD_ADDR_EXP 65
65690: PUSH
65691: LD_EXP 65
65695: PPUSH
65696: LD_VAR 0 2
65700: PPUSH
65701: EMPTY
65702: PPUSH
65703: CALL_OW 1
65707: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
65708: LD_ADDR_EXP 66
65712: PUSH
65713: LD_EXP 66
65717: PPUSH
65718: LD_VAR 0 2
65722: PPUSH
65723: EMPTY
65724: PPUSH
65725: CALL_OW 1
65729: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
65730: LD_ADDR_EXP 67
65734: PUSH
65735: LD_EXP 67
65739: PPUSH
65740: LD_VAR 0 2
65744: PPUSH
65745: EMPTY
65746: PPUSH
65747: CALL_OW 1
65751: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
65752: LD_ADDR_EXP 68
65756: PUSH
65757: LD_EXP 68
65761: PPUSH
65762: LD_VAR 0 2
65766: PPUSH
65767: EMPTY
65768: PPUSH
65769: CALL_OW 1
65773: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
65774: LD_ADDR_EXP 69
65778: PUSH
65779: LD_EXP 69
65783: PPUSH
65784: LD_VAR 0 2
65788: PPUSH
65789: EMPTY
65790: PPUSH
65791: CALL_OW 1
65795: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
65796: LD_ADDR_EXP 70
65800: PUSH
65801: LD_EXP 70
65805: PPUSH
65806: LD_VAR 0 2
65810: PPUSH
65811: EMPTY
65812: PPUSH
65813: CALL_OW 1
65817: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
65818: LD_ADDR_EXP 71
65822: PUSH
65823: LD_EXP 71
65827: PPUSH
65828: LD_VAR 0 2
65832: PPUSH
65833: EMPTY
65834: PPUSH
65835: CALL_OW 1
65839: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
65840: LD_ADDR_EXP 72
65844: PUSH
65845: LD_EXP 72
65849: PPUSH
65850: LD_VAR 0 2
65854: PPUSH
65855: EMPTY
65856: PPUSH
65857: CALL_OW 1
65861: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
65862: LD_ADDR_EXP 73
65866: PUSH
65867: LD_EXP 73
65871: PPUSH
65872: LD_VAR 0 2
65876: PPUSH
65877: LD_INT 0
65879: PPUSH
65880: CALL_OW 1
65884: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65885: LD_ADDR_EXP 74
65889: PUSH
65890: LD_EXP 74
65894: PPUSH
65895: LD_VAR 0 2
65899: PPUSH
65900: LD_INT 0
65902: PPUSH
65903: CALL_OW 1
65907: ST_TO_ADDR
// end ;
65908: GO 64809
65910: POP
65911: POP
// MC_InitSides ( ) ;
65912: CALL 66198 0 0
// MC_InitResearch ( ) ;
65916: CALL 65937 0 0
// CustomInitMacro ( ) ;
65920: CALL 1366 0 0
// skirmish := true ;
65924: LD_ADDR_EXP 29
65928: PUSH
65929: LD_INT 1
65931: ST_TO_ADDR
// end ;
65932: LD_VAR 0 1
65936: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
65937: LD_INT 0
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
65943: PPUSH
65944: PPUSH
// if not mc_bases then
65945: LD_EXP 31
65949: NOT
65950: IFFALSE 65954
// exit ;
65952: GO 66193
// for i = 1 to 8 do
65954: LD_ADDR_VAR 0 2
65958: PUSH
65959: DOUBLE
65960: LD_INT 1
65962: DEC
65963: ST_TO_ADDR
65964: LD_INT 8
65966: PUSH
65967: FOR_TO
65968: IFFALSE 65994
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
65970: LD_ADDR_EXP 58
65974: PUSH
65975: LD_EXP 58
65979: PPUSH
65980: LD_VAR 0 2
65984: PPUSH
65985: EMPTY
65986: PPUSH
65987: CALL_OW 1
65991: ST_TO_ADDR
65992: GO 65967
65994: POP
65995: POP
// tmp := [ ] ;
65996: LD_ADDR_VAR 0 5
66000: PUSH
66001: EMPTY
66002: ST_TO_ADDR
// for i = 1 to mc_sides do
66003: LD_ADDR_VAR 0 2
66007: PUSH
66008: DOUBLE
66009: LD_INT 1
66011: DEC
66012: ST_TO_ADDR
66013: LD_EXP 57
66017: PUSH
66018: FOR_TO
66019: IFFALSE 66077
// if not mc_sides [ i ] in tmp then
66021: LD_EXP 57
66025: PUSH
66026: LD_VAR 0 2
66030: ARRAY
66031: PUSH
66032: LD_VAR 0 5
66036: IN
66037: NOT
66038: IFFALSE 66075
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
66040: LD_ADDR_VAR 0 5
66044: PUSH
66045: LD_VAR 0 5
66049: PPUSH
66050: LD_VAR 0 5
66054: PUSH
66055: LD_INT 1
66057: PLUS
66058: PPUSH
66059: LD_EXP 57
66063: PUSH
66064: LD_VAR 0 2
66068: ARRAY
66069: PPUSH
66070: CALL_OW 2
66074: ST_TO_ADDR
66075: GO 66018
66077: POP
66078: POP
// if not tmp then
66079: LD_VAR 0 5
66083: NOT
66084: IFFALSE 66088
// exit ;
66086: GO 66193
// for j in tmp do
66088: LD_ADDR_VAR 0 3
66092: PUSH
66093: LD_VAR 0 5
66097: PUSH
66098: FOR_IN
66099: IFFALSE 66191
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
66101: LD_ADDR_VAR 0 6
66105: PUSH
66106: LD_INT 22
66108: PUSH
66109: LD_VAR 0 3
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PPUSH
66118: CALL_OW 69
66122: ST_TO_ADDR
// if not un then
66123: LD_VAR 0 6
66127: NOT
66128: IFFALSE 66132
// continue ;
66130: GO 66098
// nation := GetNation ( un [ 1 ] ) ;
66132: LD_ADDR_VAR 0 4
66136: PUSH
66137: LD_VAR 0 6
66141: PUSH
66142: LD_INT 1
66144: ARRAY
66145: PPUSH
66146: CALL_OW 248
66150: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
66151: LD_ADDR_EXP 58
66155: PUSH
66156: LD_EXP 58
66160: PPUSH
66161: LD_VAR 0 3
66165: PPUSH
66166: LD_VAR 0 3
66170: PPUSH
66171: LD_VAR 0 4
66175: PPUSH
66176: LD_INT 1
66178: PPUSH
66179: CALL 19902 0 3
66183: PPUSH
66184: CALL_OW 1
66188: ST_TO_ADDR
// end ;
66189: GO 66098
66191: POP
66192: POP
// end ;
66193: LD_VAR 0 1
66197: RET
// export function MC_InitSides ( ) ; var i ; begin
66198: LD_INT 0
66200: PPUSH
66201: PPUSH
// if not mc_bases then
66202: LD_EXP 31
66206: NOT
66207: IFFALSE 66211
// exit ;
66209: GO 66285
// for i = 1 to mc_bases do
66211: LD_ADDR_VAR 0 2
66215: PUSH
66216: DOUBLE
66217: LD_INT 1
66219: DEC
66220: ST_TO_ADDR
66221: LD_EXP 31
66225: PUSH
66226: FOR_TO
66227: IFFALSE 66283
// if mc_bases [ i ] then
66229: LD_EXP 31
66233: PUSH
66234: LD_VAR 0 2
66238: ARRAY
66239: IFFALSE 66281
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
66241: LD_ADDR_EXP 57
66245: PUSH
66246: LD_EXP 57
66250: PPUSH
66251: LD_VAR 0 2
66255: PPUSH
66256: LD_EXP 31
66260: PUSH
66261: LD_VAR 0 2
66265: ARRAY
66266: PUSH
66267: LD_INT 1
66269: ARRAY
66270: PPUSH
66271: CALL_OW 255
66275: PPUSH
66276: CALL_OW 1
66280: ST_TO_ADDR
66281: GO 66226
66283: POP
66284: POP
// end ;
66285: LD_VAR 0 1
66289: RET
// every 0 0$03 trigger skirmish do
66290: LD_EXP 29
66294: IFFALSE 66448
66296: GO 66298
66298: DISABLE
// begin enable ;
66299: ENABLE
// MC_CheckBuildings ( ) ;
66300: CALL 70960 0 0
// MC_CheckPeopleLife ( ) ;
66304: CALL 71121 0 0
// RaiseSailEvent ( 100 ) ;
66308: LD_INT 100
66310: PPUSH
66311: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
66315: LD_INT 103
66317: PPUSH
66318: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
66322: LD_INT 104
66324: PPUSH
66325: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
66329: LD_INT 105
66331: PPUSH
66332: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
66336: LD_INT 106
66338: PPUSH
66339: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
66343: LD_INT 107
66345: PPUSH
66346: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
66350: LD_INT 108
66352: PPUSH
66353: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
66357: LD_INT 109
66359: PPUSH
66360: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
66364: LD_INT 110
66366: PPUSH
66367: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
66371: LD_INT 111
66373: PPUSH
66374: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
66378: LD_INT 112
66380: PPUSH
66381: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
66385: LD_INT 113
66387: PPUSH
66388: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
66392: LD_INT 120
66394: PPUSH
66395: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
66399: LD_INT 121
66401: PPUSH
66402: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
66406: LD_INT 122
66408: PPUSH
66409: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
66413: LD_INT 123
66415: PPUSH
66416: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
66420: LD_INT 124
66422: PPUSH
66423: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
66427: LD_INT 125
66429: PPUSH
66430: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
66434: LD_INT 126
66436: PPUSH
66437: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
66441: LD_INT 200
66443: PPUSH
66444: CALL_OW 427
// end ;
66448: END
// on SailEvent ( event ) do begin if event < 100 then
66449: LD_VAR 0 1
66453: PUSH
66454: LD_INT 100
66456: LESS
66457: IFFALSE 66468
// CustomEvent ( event ) ;
66459: LD_VAR 0 1
66463: PPUSH
66464: CALL 19066 0 1
// if event = 100 then
66468: LD_VAR 0 1
66472: PUSH
66473: LD_INT 100
66475: EQUAL
66476: IFFALSE 66482
// MC_ClassManager ( ) ;
66478: CALL 66874 0 0
// if event = 101 then
66482: LD_VAR 0 1
66486: PUSH
66487: LD_INT 101
66489: EQUAL
66490: IFFALSE 66496
// MC_RepairBuildings ( ) ;
66492: CALL 71706 0 0
// if event = 102 then
66496: LD_VAR 0 1
66500: PUSH
66501: LD_INT 102
66503: EQUAL
66504: IFFALSE 66510
// MC_Heal ( ) ;
66506: CALL 72641 0 0
// if event = 103 then
66510: LD_VAR 0 1
66514: PUSH
66515: LD_INT 103
66517: EQUAL
66518: IFFALSE 66524
// MC_Build ( ) ;
66520: CALL 73063 0 0
// if event = 104 then
66524: LD_VAR 0 1
66528: PUSH
66529: LD_INT 104
66531: EQUAL
66532: IFFALSE 66538
// MC_TurretWeapon ( ) ;
66534: CALL 74697 0 0
// if event = 105 then
66538: LD_VAR 0 1
66542: PUSH
66543: LD_INT 105
66545: EQUAL
66546: IFFALSE 66552
// MC_BuildUpgrade ( ) ;
66548: CALL 74248 0 0
// if event = 106 then
66552: LD_VAR 0 1
66556: PUSH
66557: LD_INT 106
66559: EQUAL
66560: IFFALSE 66566
// MC_PlantMines ( ) ;
66562: CALL 75127 0 0
// if event = 107 then
66566: LD_VAR 0 1
66570: PUSH
66571: LD_INT 107
66573: EQUAL
66574: IFFALSE 66580
// MC_CollectCrates ( ) ;
66576: CALL 75925 0 0
// if event = 108 then
66580: LD_VAR 0 1
66584: PUSH
66585: LD_INT 108
66587: EQUAL
66588: IFFALSE 66594
// MC_LinkRemoteControl ( ) ;
66590: CALL 77775 0 0
// if event = 109 then
66594: LD_VAR 0 1
66598: PUSH
66599: LD_INT 109
66601: EQUAL
66602: IFFALSE 66608
// MC_ProduceVehicle ( ) ;
66604: CALL 77956 0 0
// if event = 110 then
66608: LD_VAR 0 1
66612: PUSH
66613: LD_INT 110
66615: EQUAL
66616: IFFALSE 66622
// MC_SendAttack ( ) ;
66618: CALL 78422 0 0
// if event = 111 then
66622: LD_VAR 0 1
66626: PUSH
66627: LD_INT 111
66629: EQUAL
66630: IFFALSE 66636
// MC_Defend ( ) ;
66632: CALL 78530 0 0
// if event = 112 then
66636: LD_VAR 0 1
66640: PUSH
66641: LD_INT 112
66643: EQUAL
66644: IFFALSE 66650
// MC_Research ( ) ;
66646: CALL 79410 0 0
// if event = 113 then
66650: LD_VAR 0 1
66654: PUSH
66655: LD_INT 113
66657: EQUAL
66658: IFFALSE 66664
// MC_MinesTrigger ( ) ;
66660: CALL 80524 0 0
// if event = 120 then
66664: LD_VAR 0 1
66668: PUSH
66669: LD_INT 120
66671: EQUAL
66672: IFFALSE 66678
// MC_RepairVehicle ( ) ;
66674: CALL 80623 0 0
// if event = 121 then
66678: LD_VAR 0 1
66682: PUSH
66683: LD_INT 121
66685: EQUAL
66686: IFFALSE 66692
// MC_TameApe ( ) ;
66688: CALL 81392 0 0
// if event = 122 then
66692: LD_VAR 0 1
66696: PUSH
66697: LD_INT 122
66699: EQUAL
66700: IFFALSE 66706
// MC_ChangeApeClass ( ) ;
66702: CALL 82221 0 0
// if event = 123 then
66706: LD_VAR 0 1
66710: PUSH
66711: LD_INT 123
66713: EQUAL
66714: IFFALSE 66720
// MC_Bazooka ( ) ;
66716: CALL 82871 0 0
// if event = 124 then
66720: LD_VAR 0 1
66724: PUSH
66725: LD_INT 124
66727: EQUAL
66728: IFFALSE 66734
// MC_TeleportExit ( ) ;
66730: CALL 83069 0 0
// if event = 125 then
66734: LD_VAR 0 1
66738: PUSH
66739: LD_INT 125
66741: EQUAL
66742: IFFALSE 66748
// MC_Deposits ( ) ;
66744: CALL 83716 0 0
// if event = 126 then
66748: LD_VAR 0 1
66752: PUSH
66753: LD_INT 126
66755: EQUAL
66756: IFFALSE 66762
// MC_RemoteDriver ( ) ;
66758: CALL 84341 0 0
// if event = 200 then
66762: LD_VAR 0 1
66766: PUSH
66767: LD_INT 200
66769: EQUAL
66770: IFFALSE 66776
// MC_Idle ( ) ;
66772: CALL 86248 0 0
// end ;
66776: PPOPN 1
66778: END
// export function MC_Reset ( base , tag ) ; var i ; begin
66779: LD_INT 0
66781: PPUSH
66782: PPUSH
// if not mc_bases [ base ] or not tag then
66783: LD_EXP 31
66787: PUSH
66788: LD_VAR 0 1
66792: ARRAY
66793: NOT
66794: PUSH
66795: LD_VAR 0 2
66799: NOT
66800: OR
66801: IFFALSE 66805
// exit ;
66803: GO 66869
// for i in mc_bases [ base ] union mc_ape [ base ] do
66805: LD_ADDR_VAR 0 4
66809: PUSH
66810: LD_EXP 31
66814: PUSH
66815: LD_VAR 0 1
66819: ARRAY
66820: PUSH
66821: LD_EXP 60
66825: PUSH
66826: LD_VAR 0 1
66830: ARRAY
66831: UNION
66832: PUSH
66833: FOR_IN
66834: IFFALSE 66867
// if GetTag ( i ) = tag then
66836: LD_VAR 0 4
66840: PPUSH
66841: CALL_OW 110
66845: PUSH
66846: LD_VAR 0 2
66850: EQUAL
66851: IFFALSE 66865
// SetTag ( i , 0 ) ;
66853: LD_VAR 0 4
66857: PPUSH
66858: LD_INT 0
66860: PPUSH
66861: CALL_OW 109
66865: GO 66833
66867: POP
66868: POP
// end ;
66869: LD_VAR 0 3
66873: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
66874: LD_INT 0
66876: PPUSH
66877: PPUSH
66878: PPUSH
66879: PPUSH
66880: PPUSH
66881: PPUSH
66882: PPUSH
66883: PPUSH
// if not mc_bases then
66884: LD_EXP 31
66888: NOT
66889: IFFALSE 66893
// exit ;
66891: GO 67342
// for i = 1 to mc_bases do
66893: LD_ADDR_VAR 0 2
66897: PUSH
66898: DOUBLE
66899: LD_INT 1
66901: DEC
66902: ST_TO_ADDR
66903: LD_EXP 31
66907: PUSH
66908: FOR_TO
66909: IFFALSE 67340
// begin tmp := MC_ClassCheckReq ( i ) ;
66911: LD_ADDR_VAR 0 4
66915: PUSH
66916: LD_VAR 0 2
66920: PPUSH
66921: CALL 67347 0 1
66925: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
66926: LD_ADDR_EXP 72
66930: PUSH
66931: LD_EXP 72
66935: PPUSH
66936: LD_VAR 0 2
66940: PPUSH
66941: LD_VAR 0 4
66945: PPUSH
66946: CALL_OW 1
66950: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
66951: LD_ADDR_VAR 0 6
66955: PUSH
66956: LD_EXP 31
66960: PUSH
66961: LD_VAR 0 2
66965: ARRAY
66966: PPUSH
66967: LD_INT 2
66969: PUSH
66970: LD_INT 30
66972: PUSH
66973: LD_INT 4
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 30
66982: PUSH
66983: LD_INT 5
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: LIST
66994: PPUSH
66995: CALL_OW 72
66999: PUSH
67000: LD_EXP 31
67004: PUSH
67005: LD_VAR 0 2
67009: ARRAY
67010: PPUSH
67011: LD_INT 2
67013: PUSH
67014: LD_INT 30
67016: PUSH
67017: LD_INT 0
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 30
67026: PUSH
67027: LD_INT 1
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: LIST
67038: PPUSH
67039: CALL_OW 72
67043: PUSH
67044: LD_EXP 31
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: PPUSH
67055: LD_INT 30
67057: PUSH
67058: LD_INT 3
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PPUSH
67065: CALL_OW 72
67069: PUSH
67070: LD_EXP 31
67074: PUSH
67075: LD_VAR 0 2
67079: ARRAY
67080: PPUSH
67081: LD_INT 2
67083: PUSH
67084: LD_INT 30
67086: PUSH
67087: LD_INT 6
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: LD_INT 30
67096: PUSH
67097: LD_INT 7
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 30
67106: PUSH
67107: LD_INT 8
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: PPUSH
67120: CALL_OW 72
67124: PUSH
67125: EMPTY
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: ST_TO_ADDR
// for j := 1 to 4 do
67131: LD_ADDR_VAR 0 3
67135: PUSH
67136: DOUBLE
67137: LD_INT 1
67139: DEC
67140: ST_TO_ADDR
67141: LD_INT 4
67143: PUSH
67144: FOR_TO
67145: IFFALSE 67336
// begin if not tmp [ j ] then
67147: LD_VAR 0 4
67151: PUSH
67152: LD_VAR 0 3
67156: ARRAY
67157: NOT
67158: IFFALSE 67162
// continue ;
67160: GO 67144
// for p in tmp [ j ] do
67162: LD_ADDR_VAR 0 5
67166: PUSH
67167: LD_VAR 0 4
67171: PUSH
67172: LD_VAR 0 3
67176: ARRAY
67177: PUSH
67178: FOR_IN
67179: IFFALSE 67332
// begin if not b [ j ] then
67181: LD_VAR 0 6
67185: PUSH
67186: LD_VAR 0 3
67190: ARRAY
67191: NOT
67192: IFFALSE 67196
// break ;
67194: GO 67332
// e := 0 ;
67196: LD_ADDR_VAR 0 7
67200: PUSH
67201: LD_INT 0
67203: ST_TO_ADDR
// for k in b [ j ] do
67204: LD_ADDR_VAR 0 8
67208: PUSH
67209: LD_VAR 0 6
67213: PUSH
67214: LD_VAR 0 3
67218: ARRAY
67219: PUSH
67220: FOR_IN
67221: IFFALSE 67248
// if IsNotFull ( k ) then
67223: LD_VAR 0 8
67227: PPUSH
67228: CALL 22023 0 1
67232: IFFALSE 67246
// begin e := k ;
67234: LD_ADDR_VAR 0 7
67238: PUSH
67239: LD_VAR 0 8
67243: ST_TO_ADDR
// break ;
67244: GO 67248
// end ;
67246: GO 67220
67248: POP
67249: POP
// if e and not UnitGoingToBuilding ( p , e ) then
67250: LD_VAR 0 7
67254: PUSH
67255: LD_VAR 0 5
67259: PPUSH
67260: LD_VAR 0 7
67264: PPUSH
67265: CALL 56162 0 2
67269: NOT
67270: AND
67271: IFFALSE 67330
// begin if IsInUnit ( p ) then
67273: LD_VAR 0 5
67277: PPUSH
67278: CALL_OW 310
67282: IFFALSE 67293
// ComExitBuilding ( p ) ;
67284: LD_VAR 0 5
67288: PPUSH
67289: CALL_OW 122
// ComEnterUnit ( p , e ) ;
67293: LD_VAR 0 5
67297: PPUSH
67298: LD_VAR 0 7
67302: PPUSH
67303: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
67307: LD_VAR 0 5
67311: PPUSH
67312: LD_VAR 0 3
67316: PPUSH
67317: CALL_OW 183
// AddComExitBuilding ( p ) ;
67321: LD_VAR 0 5
67325: PPUSH
67326: CALL_OW 182
// end ; end ;
67330: GO 67178
67332: POP
67333: POP
// end ;
67334: GO 67144
67336: POP
67337: POP
// end ;
67338: GO 66908
67340: POP
67341: POP
// end ;
67342: LD_VAR 0 1
67346: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
67347: LD_INT 0
67349: PPUSH
67350: PPUSH
67351: PPUSH
67352: PPUSH
67353: PPUSH
67354: PPUSH
67355: PPUSH
67356: PPUSH
67357: PPUSH
67358: PPUSH
67359: PPUSH
67360: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
67361: LD_ADDR_VAR 0 2
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: LD_INT 0
67371: PUSH
67372: LD_INT 0
67374: PUSH
67375: LD_INT 0
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67384: LD_VAR 0 1
67388: NOT
67389: PUSH
67390: LD_EXP 31
67394: PUSH
67395: LD_VAR 0 1
67399: ARRAY
67400: NOT
67401: OR
67402: PUSH
67403: LD_EXP 31
67407: PUSH
67408: LD_VAR 0 1
67412: ARRAY
67413: PPUSH
67414: LD_INT 2
67416: PUSH
67417: LD_INT 30
67419: PUSH
67420: LD_INT 0
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 30
67429: PUSH
67430: LD_INT 1
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: LIST
67441: PPUSH
67442: CALL_OW 72
67446: NOT
67447: OR
67448: IFFALSE 67452
// exit ;
67450: GO 70955
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67452: LD_ADDR_VAR 0 4
67456: PUSH
67457: LD_EXP 31
67461: PUSH
67462: LD_VAR 0 1
67466: ARRAY
67467: PPUSH
67468: LD_INT 2
67470: PUSH
67471: LD_INT 25
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: LD_INT 25
67483: PUSH
67484: LD_INT 2
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 25
67493: PUSH
67494: LD_INT 3
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 25
67503: PUSH
67504: LD_INT 4
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 25
67513: PUSH
67514: LD_INT 5
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 25
67523: PUSH
67524: LD_INT 8
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 25
67533: PUSH
67534: LD_INT 9
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: EMPTY
67542: LIST
67543: LIST
67544: LIST
67545: LIST
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: PPUSH
67551: CALL_OW 72
67555: ST_TO_ADDR
// if not tmp then
67556: LD_VAR 0 4
67560: NOT
67561: IFFALSE 67565
// exit ;
67563: GO 70955
// for i in tmp do
67565: LD_ADDR_VAR 0 3
67569: PUSH
67570: LD_VAR 0 4
67574: PUSH
67575: FOR_IN
67576: IFFALSE 67607
// if GetTag ( i ) then
67578: LD_VAR 0 3
67582: PPUSH
67583: CALL_OW 110
67587: IFFALSE 67605
// tmp := tmp diff i ;
67589: LD_ADDR_VAR 0 4
67593: PUSH
67594: LD_VAR 0 4
67598: PUSH
67599: LD_VAR 0 3
67603: DIFF
67604: ST_TO_ADDR
67605: GO 67575
67607: POP
67608: POP
// if not tmp then
67609: LD_VAR 0 4
67613: NOT
67614: IFFALSE 67618
// exit ;
67616: GO 70955
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67618: LD_ADDR_VAR 0 5
67622: PUSH
67623: LD_EXP 31
67627: PUSH
67628: LD_VAR 0 1
67632: ARRAY
67633: PPUSH
67634: LD_INT 2
67636: PUSH
67637: LD_INT 25
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 25
67649: PUSH
67650: LD_INT 5
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 25
67659: PUSH
67660: LD_INT 8
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 25
67669: PUSH
67670: LD_INT 9
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: LIST
67681: LIST
67682: LIST
67683: PPUSH
67684: CALL_OW 72
67688: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
67689: LD_ADDR_VAR 0 6
67693: PUSH
67694: LD_EXP 31
67698: PUSH
67699: LD_VAR 0 1
67703: ARRAY
67704: PPUSH
67705: LD_INT 25
67707: PUSH
67708: LD_INT 2
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PPUSH
67715: CALL_OW 72
67719: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67720: LD_ADDR_VAR 0 7
67724: PUSH
67725: LD_EXP 31
67729: PUSH
67730: LD_VAR 0 1
67734: ARRAY
67735: PPUSH
67736: LD_INT 25
67738: PUSH
67739: LD_INT 3
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PPUSH
67746: CALL_OW 72
67750: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
67751: LD_ADDR_VAR 0 8
67755: PUSH
67756: LD_EXP 31
67760: PUSH
67761: LD_VAR 0 1
67765: ARRAY
67766: PPUSH
67767: LD_INT 25
67769: PUSH
67770: LD_INT 4
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 24
67779: PUSH
67780: LD_INT 251
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PPUSH
67791: CALL_OW 72
67795: ST_TO_ADDR
// if mc_is_defending [ base ] then
67796: LD_EXP 74
67800: PUSH
67801: LD_VAR 0 1
67805: ARRAY
67806: IFFALSE 68267
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
67808: LD_ADDR_EXP 73
67812: PUSH
67813: LD_EXP 73
67817: PPUSH
67818: LD_VAR 0 1
67822: PPUSH
67823: LD_INT 4
67825: PPUSH
67826: CALL_OW 1
67830: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67831: LD_ADDR_VAR 0 12
67835: PUSH
67836: LD_EXP 31
67840: PUSH
67841: LD_VAR 0 1
67845: ARRAY
67846: PPUSH
67847: LD_INT 2
67849: PUSH
67850: LD_INT 30
67852: PUSH
67853: LD_INT 4
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 30
67862: PUSH
67863: LD_INT 5
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: LIST
67874: PPUSH
67875: CALL_OW 72
67879: ST_TO_ADDR
// if not b then
67880: LD_VAR 0 12
67884: NOT
67885: IFFALSE 67889
// exit ;
67887: GO 70955
// p := [ ] ;
67889: LD_ADDR_VAR 0 11
67893: PUSH
67894: EMPTY
67895: ST_TO_ADDR
// if sci >= 2 then
67896: LD_VAR 0 8
67900: PUSH
67901: LD_INT 2
67903: GREATEREQUAL
67904: IFFALSE 67935
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
67906: LD_ADDR_VAR 0 8
67910: PUSH
67911: LD_VAR 0 8
67915: PUSH
67916: LD_INT 1
67918: ARRAY
67919: PUSH
67920: LD_VAR 0 8
67924: PUSH
67925: LD_INT 2
67927: ARRAY
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: ST_TO_ADDR
67933: GO 67996
// if sci = 1 then
67935: LD_VAR 0 8
67939: PUSH
67940: LD_INT 1
67942: EQUAL
67943: IFFALSE 67964
// sci := [ sci [ 1 ] ] else
67945: LD_ADDR_VAR 0 8
67949: PUSH
67950: LD_VAR 0 8
67954: PUSH
67955: LD_INT 1
67957: ARRAY
67958: PUSH
67959: EMPTY
67960: LIST
67961: ST_TO_ADDR
67962: GO 67996
// if sci = 0 then
67964: LD_VAR 0 8
67968: PUSH
67969: LD_INT 0
67971: EQUAL
67972: IFFALSE 67996
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
67974: LD_ADDR_VAR 0 11
67978: PUSH
67979: LD_VAR 0 4
67983: PPUSH
67984: LD_INT 4
67986: PPUSH
67987: CALL 56034 0 2
67991: PUSH
67992: LD_INT 1
67994: ARRAY
67995: ST_TO_ADDR
// if eng > 4 then
67996: LD_VAR 0 6
68000: PUSH
68001: LD_INT 4
68003: GREATER
68004: IFFALSE 68050
// for i = eng downto 4 do
68006: LD_ADDR_VAR 0 3
68010: PUSH
68011: DOUBLE
68012: LD_VAR 0 6
68016: INC
68017: ST_TO_ADDR
68018: LD_INT 4
68020: PUSH
68021: FOR_DOWNTO
68022: IFFALSE 68048
// eng := eng diff eng [ i ] ;
68024: LD_ADDR_VAR 0 6
68028: PUSH
68029: LD_VAR 0 6
68033: PUSH
68034: LD_VAR 0 6
68038: PUSH
68039: LD_VAR 0 3
68043: ARRAY
68044: DIFF
68045: ST_TO_ADDR
68046: GO 68021
68048: POP
68049: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
68050: LD_ADDR_VAR 0 4
68054: PUSH
68055: LD_VAR 0 4
68059: PUSH
68060: LD_VAR 0 5
68064: PUSH
68065: LD_VAR 0 6
68069: UNION
68070: PUSH
68071: LD_VAR 0 7
68075: UNION
68076: PUSH
68077: LD_VAR 0 8
68081: UNION
68082: DIFF
68083: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
68084: LD_ADDR_VAR 0 13
68088: PUSH
68089: LD_EXP 31
68093: PUSH
68094: LD_VAR 0 1
68098: ARRAY
68099: PPUSH
68100: LD_INT 2
68102: PUSH
68103: LD_INT 30
68105: PUSH
68106: LD_INT 32
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: LD_INT 30
68115: PUSH
68116: LD_INT 31
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: LIST
68127: PPUSH
68128: CALL_OW 72
68132: PUSH
68133: LD_EXP 31
68137: PUSH
68138: LD_VAR 0 1
68142: ARRAY
68143: PPUSH
68144: LD_INT 2
68146: PUSH
68147: LD_INT 30
68149: PUSH
68150: LD_INT 4
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 30
68159: PUSH
68160: LD_INT 5
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: PPUSH
68172: CALL_OW 72
68176: PUSH
68177: LD_INT 6
68179: MUL
68180: PLUS
68181: ST_TO_ADDR
// if bcount < tmp then
68182: LD_VAR 0 13
68186: PUSH
68187: LD_VAR 0 4
68191: LESS
68192: IFFALSE 68238
// for i = tmp downto bcount do
68194: LD_ADDR_VAR 0 3
68198: PUSH
68199: DOUBLE
68200: LD_VAR 0 4
68204: INC
68205: ST_TO_ADDR
68206: LD_VAR 0 13
68210: PUSH
68211: FOR_DOWNTO
68212: IFFALSE 68236
// tmp := Delete ( tmp , tmp ) ;
68214: LD_ADDR_VAR 0 4
68218: PUSH
68219: LD_VAR 0 4
68223: PPUSH
68224: LD_VAR 0 4
68228: PPUSH
68229: CALL_OW 3
68233: ST_TO_ADDR
68234: GO 68211
68236: POP
68237: POP
// result := [ tmp , 0 , 0 , p ] ;
68238: LD_ADDR_VAR 0 2
68242: PUSH
68243: LD_VAR 0 4
68247: PUSH
68248: LD_INT 0
68250: PUSH
68251: LD_INT 0
68253: PUSH
68254: LD_VAR 0 11
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: ST_TO_ADDR
// exit ;
68265: GO 70955
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
68267: LD_EXP 31
68271: PUSH
68272: LD_VAR 0 1
68276: ARRAY
68277: PPUSH
68278: LD_INT 2
68280: PUSH
68281: LD_INT 30
68283: PUSH
68284: LD_INT 6
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 30
68293: PUSH
68294: LD_INT 7
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 30
68303: PUSH
68304: LD_INT 8
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: PPUSH
68317: CALL_OW 72
68321: NOT
68322: PUSH
68323: LD_EXP 31
68327: PUSH
68328: LD_VAR 0 1
68332: ARRAY
68333: PPUSH
68334: LD_INT 30
68336: PUSH
68337: LD_INT 3
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PPUSH
68344: CALL_OW 72
68348: NOT
68349: AND
68350: IFFALSE 68422
// begin if eng = tmp then
68352: LD_VAR 0 6
68356: PUSH
68357: LD_VAR 0 4
68361: EQUAL
68362: IFFALSE 68366
// exit ;
68364: GO 70955
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
68366: LD_ADDR_EXP 73
68370: PUSH
68371: LD_EXP 73
68375: PPUSH
68376: LD_VAR 0 1
68380: PPUSH
68381: LD_INT 1
68383: PPUSH
68384: CALL_OW 1
68388: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
68389: LD_ADDR_VAR 0 2
68393: PUSH
68394: LD_INT 0
68396: PUSH
68397: LD_VAR 0 4
68401: PUSH
68402: LD_VAR 0 6
68406: DIFF
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: LD_INT 0
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: ST_TO_ADDR
// exit ;
68420: GO 70955
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
68422: LD_EXP 58
68426: PUSH
68427: LD_EXP 57
68431: PUSH
68432: LD_VAR 0 1
68436: ARRAY
68437: ARRAY
68438: PUSH
68439: LD_EXP 31
68443: PUSH
68444: LD_VAR 0 1
68448: ARRAY
68449: PPUSH
68450: LD_INT 2
68452: PUSH
68453: LD_INT 30
68455: PUSH
68456: LD_INT 6
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 30
68465: PUSH
68466: LD_INT 7
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 30
68475: PUSH
68476: LD_INT 8
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: PPUSH
68489: CALL_OW 72
68493: AND
68494: PUSH
68495: LD_EXP 31
68499: PUSH
68500: LD_VAR 0 1
68504: ARRAY
68505: PPUSH
68506: LD_INT 30
68508: PUSH
68509: LD_INT 3
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PPUSH
68516: CALL_OW 72
68520: NOT
68521: AND
68522: IFFALSE 68736
// begin if sci >= 6 then
68524: LD_VAR 0 8
68528: PUSH
68529: LD_INT 6
68531: GREATEREQUAL
68532: IFFALSE 68536
// exit ;
68534: GO 70955
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
68536: LD_ADDR_EXP 73
68540: PUSH
68541: LD_EXP 73
68545: PPUSH
68546: LD_VAR 0 1
68550: PPUSH
68551: LD_INT 2
68553: PPUSH
68554: CALL_OW 1
68558: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
68559: LD_ADDR_VAR 0 9
68563: PUSH
68564: LD_VAR 0 4
68568: PUSH
68569: LD_VAR 0 8
68573: DIFF
68574: PPUSH
68575: LD_INT 4
68577: PPUSH
68578: CALL 56034 0 2
68582: ST_TO_ADDR
// p := [ ] ;
68583: LD_ADDR_VAR 0 11
68587: PUSH
68588: EMPTY
68589: ST_TO_ADDR
// if sci < 6 and sort > 6 then
68590: LD_VAR 0 8
68594: PUSH
68595: LD_INT 6
68597: LESS
68598: PUSH
68599: LD_VAR 0 9
68603: PUSH
68604: LD_INT 6
68606: GREATER
68607: AND
68608: IFFALSE 68689
// begin for i = 1 to 6 - sci do
68610: LD_ADDR_VAR 0 3
68614: PUSH
68615: DOUBLE
68616: LD_INT 1
68618: DEC
68619: ST_TO_ADDR
68620: LD_INT 6
68622: PUSH
68623: LD_VAR 0 8
68627: MINUS
68628: PUSH
68629: FOR_TO
68630: IFFALSE 68685
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
68632: LD_ADDR_VAR 0 11
68636: PUSH
68637: LD_VAR 0 11
68641: PPUSH
68642: LD_VAR 0 11
68646: PUSH
68647: LD_INT 1
68649: PLUS
68650: PPUSH
68651: LD_VAR 0 9
68655: PUSH
68656: LD_INT 1
68658: ARRAY
68659: PPUSH
68660: CALL_OW 2
68664: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
68665: LD_ADDR_VAR 0 9
68669: PUSH
68670: LD_VAR 0 9
68674: PPUSH
68675: LD_INT 1
68677: PPUSH
68678: CALL_OW 3
68682: ST_TO_ADDR
// end ;
68683: GO 68629
68685: POP
68686: POP
// end else
68687: GO 68709
// if sort then
68689: LD_VAR 0 9
68693: IFFALSE 68709
// p := sort [ 1 ] ;
68695: LD_ADDR_VAR 0 11
68699: PUSH
68700: LD_VAR 0 9
68704: PUSH
68705: LD_INT 1
68707: ARRAY
68708: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
68709: LD_ADDR_VAR 0 2
68713: PUSH
68714: LD_INT 0
68716: PUSH
68717: LD_INT 0
68719: PUSH
68720: LD_INT 0
68722: PUSH
68723: LD_VAR 0 11
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: ST_TO_ADDR
// exit ;
68734: GO 70955
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
68736: LD_EXP 58
68740: PUSH
68741: LD_EXP 57
68745: PUSH
68746: LD_VAR 0 1
68750: ARRAY
68751: ARRAY
68752: PUSH
68753: LD_EXP 31
68757: PUSH
68758: LD_VAR 0 1
68762: ARRAY
68763: PPUSH
68764: LD_INT 2
68766: PUSH
68767: LD_INT 30
68769: PUSH
68770: LD_INT 6
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 30
68779: PUSH
68780: LD_INT 7
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 30
68789: PUSH
68790: LD_INT 8
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: PPUSH
68803: CALL_OW 72
68807: AND
68808: PUSH
68809: LD_EXP 31
68813: PUSH
68814: LD_VAR 0 1
68818: ARRAY
68819: PPUSH
68820: LD_INT 30
68822: PUSH
68823: LD_INT 3
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PPUSH
68830: CALL_OW 72
68834: AND
68835: IFFALSE 69569
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
68837: LD_ADDR_EXP 73
68841: PUSH
68842: LD_EXP 73
68846: PPUSH
68847: LD_VAR 0 1
68851: PPUSH
68852: LD_INT 3
68854: PPUSH
68855: CALL_OW 1
68859: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68860: LD_ADDR_VAR 0 2
68864: PUSH
68865: LD_INT 0
68867: PUSH
68868: LD_INT 0
68870: PUSH
68871: LD_INT 0
68873: PUSH
68874: LD_INT 0
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: ST_TO_ADDR
// if not eng then
68883: LD_VAR 0 6
68887: NOT
68888: IFFALSE 68951
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
68890: LD_ADDR_VAR 0 11
68894: PUSH
68895: LD_VAR 0 4
68899: PPUSH
68900: LD_INT 2
68902: PPUSH
68903: CALL 56034 0 2
68907: PUSH
68908: LD_INT 1
68910: ARRAY
68911: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
68912: LD_ADDR_VAR 0 2
68916: PUSH
68917: LD_VAR 0 2
68921: PPUSH
68922: LD_INT 2
68924: PPUSH
68925: LD_VAR 0 11
68929: PPUSH
68930: CALL_OW 1
68934: ST_TO_ADDR
// tmp := tmp diff p ;
68935: LD_ADDR_VAR 0 4
68939: PUSH
68940: LD_VAR 0 4
68944: PUSH
68945: LD_VAR 0 11
68949: DIFF
68950: ST_TO_ADDR
// end ; if tmp and sci < 6 then
68951: LD_VAR 0 4
68955: PUSH
68956: LD_VAR 0 8
68960: PUSH
68961: LD_INT 6
68963: LESS
68964: AND
68965: IFFALSE 69153
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
68967: LD_ADDR_VAR 0 9
68971: PUSH
68972: LD_VAR 0 4
68976: PUSH
68977: LD_VAR 0 8
68981: PUSH
68982: LD_VAR 0 7
68986: UNION
68987: DIFF
68988: PPUSH
68989: LD_INT 4
68991: PPUSH
68992: CALL 56034 0 2
68996: ST_TO_ADDR
// p := [ ] ;
68997: LD_ADDR_VAR 0 11
69001: PUSH
69002: EMPTY
69003: ST_TO_ADDR
// if sort then
69004: LD_VAR 0 9
69008: IFFALSE 69124
// for i = 1 to 6 - sci do
69010: LD_ADDR_VAR 0 3
69014: PUSH
69015: DOUBLE
69016: LD_INT 1
69018: DEC
69019: ST_TO_ADDR
69020: LD_INT 6
69022: PUSH
69023: LD_VAR 0 8
69027: MINUS
69028: PUSH
69029: FOR_TO
69030: IFFALSE 69122
// begin if i = sort then
69032: LD_VAR 0 3
69036: PUSH
69037: LD_VAR 0 9
69041: EQUAL
69042: IFFALSE 69046
// break ;
69044: GO 69122
// if GetClass ( i ) = 4 then
69046: LD_VAR 0 3
69050: PPUSH
69051: CALL_OW 257
69055: PUSH
69056: LD_INT 4
69058: EQUAL
69059: IFFALSE 69063
// continue ;
69061: GO 69029
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69063: LD_ADDR_VAR 0 11
69067: PUSH
69068: LD_VAR 0 11
69072: PPUSH
69073: LD_VAR 0 11
69077: PUSH
69078: LD_INT 1
69080: PLUS
69081: PPUSH
69082: LD_VAR 0 9
69086: PUSH
69087: LD_VAR 0 3
69091: ARRAY
69092: PPUSH
69093: CALL_OW 2
69097: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69098: LD_ADDR_VAR 0 4
69102: PUSH
69103: LD_VAR 0 4
69107: PUSH
69108: LD_VAR 0 9
69112: PUSH
69113: LD_VAR 0 3
69117: ARRAY
69118: DIFF
69119: ST_TO_ADDR
// end ;
69120: GO 69029
69122: POP
69123: POP
// if p then
69124: LD_VAR 0 11
69128: IFFALSE 69153
// result := Replace ( result , 4 , p ) ;
69130: LD_ADDR_VAR 0 2
69134: PUSH
69135: LD_VAR 0 2
69139: PPUSH
69140: LD_INT 4
69142: PPUSH
69143: LD_VAR 0 11
69147: PPUSH
69148: CALL_OW 1
69152: ST_TO_ADDR
// end ; if tmp and mech < 6 then
69153: LD_VAR 0 4
69157: PUSH
69158: LD_VAR 0 7
69162: PUSH
69163: LD_INT 6
69165: LESS
69166: AND
69167: IFFALSE 69355
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
69169: LD_ADDR_VAR 0 9
69173: PUSH
69174: LD_VAR 0 4
69178: PUSH
69179: LD_VAR 0 8
69183: PUSH
69184: LD_VAR 0 7
69188: UNION
69189: DIFF
69190: PPUSH
69191: LD_INT 3
69193: PPUSH
69194: CALL 56034 0 2
69198: ST_TO_ADDR
// p := [ ] ;
69199: LD_ADDR_VAR 0 11
69203: PUSH
69204: EMPTY
69205: ST_TO_ADDR
// if sort then
69206: LD_VAR 0 9
69210: IFFALSE 69326
// for i = 1 to 6 - mech do
69212: LD_ADDR_VAR 0 3
69216: PUSH
69217: DOUBLE
69218: LD_INT 1
69220: DEC
69221: ST_TO_ADDR
69222: LD_INT 6
69224: PUSH
69225: LD_VAR 0 7
69229: MINUS
69230: PUSH
69231: FOR_TO
69232: IFFALSE 69324
// begin if i = sort then
69234: LD_VAR 0 3
69238: PUSH
69239: LD_VAR 0 9
69243: EQUAL
69244: IFFALSE 69248
// break ;
69246: GO 69324
// if GetClass ( i ) = 3 then
69248: LD_VAR 0 3
69252: PPUSH
69253: CALL_OW 257
69257: PUSH
69258: LD_INT 3
69260: EQUAL
69261: IFFALSE 69265
// continue ;
69263: GO 69231
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69265: LD_ADDR_VAR 0 11
69269: PUSH
69270: LD_VAR 0 11
69274: PPUSH
69275: LD_VAR 0 11
69279: PUSH
69280: LD_INT 1
69282: PLUS
69283: PPUSH
69284: LD_VAR 0 9
69288: PUSH
69289: LD_VAR 0 3
69293: ARRAY
69294: PPUSH
69295: CALL_OW 2
69299: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69300: LD_ADDR_VAR 0 4
69304: PUSH
69305: LD_VAR 0 4
69309: PUSH
69310: LD_VAR 0 9
69314: PUSH
69315: LD_VAR 0 3
69319: ARRAY
69320: DIFF
69321: ST_TO_ADDR
// end ;
69322: GO 69231
69324: POP
69325: POP
// if p then
69326: LD_VAR 0 11
69330: IFFALSE 69355
// result := Replace ( result , 3 , p ) ;
69332: LD_ADDR_VAR 0 2
69336: PUSH
69337: LD_VAR 0 2
69341: PPUSH
69342: LD_INT 3
69344: PPUSH
69345: LD_VAR 0 11
69349: PPUSH
69350: CALL_OW 1
69354: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
69355: LD_VAR 0 4
69359: PUSH
69360: LD_INT 6
69362: GREATER
69363: PUSH
69364: LD_VAR 0 6
69368: PUSH
69369: LD_INT 6
69371: LESS
69372: AND
69373: IFFALSE 69567
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
69375: LD_ADDR_VAR 0 9
69379: PUSH
69380: LD_VAR 0 4
69384: PUSH
69385: LD_VAR 0 8
69389: PUSH
69390: LD_VAR 0 7
69394: UNION
69395: PUSH
69396: LD_VAR 0 6
69400: UNION
69401: DIFF
69402: PPUSH
69403: LD_INT 2
69405: PPUSH
69406: CALL 56034 0 2
69410: ST_TO_ADDR
// p := [ ] ;
69411: LD_ADDR_VAR 0 11
69415: PUSH
69416: EMPTY
69417: ST_TO_ADDR
// if sort then
69418: LD_VAR 0 9
69422: IFFALSE 69538
// for i = 1 to 6 - eng do
69424: LD_ADDR_VAR 0 3
69428: PUSH
69429: DOUBLE
69430: LD_INT 1
69432: DEC
69433: ST_TO_ADDR
69434: LD_INT 6
69436: PUSH
69437: LD_VAR 0 6
69441: MINUS
69442: PUSH
69443: FOR_TO
69444: IFFALSE 69536
// begin if i = sort then
69446: LD_VAR 0 3
69450: PUSH
69451: LD_VAR 0 9
69455: EQUAL
69456: IFFALSE 69460
// break ;
69458: GO 69536
// if GetClass ( i ) = 2 then
69460: LD_VAR 0 3
69464: PPUSH
69465: CALL_OW 257
69469: PUSH
69470: LD_INT 2
69472: EQUAL
69473: IFFALSE 69477
// continue ;
69475: GO 69443
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69477: LD_ADDR_VAR 0 11
69481: PUSH
69482: LD_VAR 0 11
69486: PPUSH
69487: LD_VAR 0 11
69491: PUSH
69492: LD_INT 1
69494: PLUS
69495: PPUSH
69496: LD_VAR 0 9
69500: PUSH
69501: LD_VAR 0 3
69505: ARRAY
69506: PPUSH
69507: CALL_OW 2
69511: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69512: LD_ADDR_VAR 0 4
69516: PUSH
69517: LD_VAR 0 4
69521: PUSH
69522: LD_VAR 0 9
69526: PUSH
69527: LD_VAR 0 3
69531: ARRAY
69532: DIFF
69533: ST_TO_ADDR
// end ;
69534: GO 69443
69536: POP
69537: POP
// if p then
69538: LD_VAR 0 11
69542: IFFALSE 69567
// result := Replace ( result , 2 , p ) ;
69544: LD_ADDR_VAR 0 2
69548: PUSH
69549: LD_VAR 0 2
69553: PPUSH
69554: LD_INT 2
69556: PPUSH
69557: LD_VAR 0 11
69561: PPUSH
69562: CALL_OW 1
69566: ST_TO_ADDR
// end ; exit ;
69567: GO 70955
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
69569: LD_EXP 58
69573: PUSH
69574: LD_EXP 57
69578: PUSH
69579: LD_VAR 0 1
69583: ARRAY
69584: ARRAY
69585: NOT
69586: PUSH
69587: LD_EXP 31
69591: PUSH
69592: LD_VAR 0 1
69596: ARRAY
69597: PPUSH
69598: LD_INT 30
69600: PUSH
69601: LD_INT 3
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PPUSH
69608: CALL_OW 72
69612: AND
69613: PUSH
69614: LD_EXP 36
69618: PUSH
69619: LD_VAR 0 1
69623: ARRAY
69624: AND
69625: IFFALSE 70233
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
69627: LD_ADDR_EXP 73
69631: PUSH
69632: LD_EXP 73
69636: PPUSH
69637: LD_VAR 0 1
69641: PPUSH
69642: LD_INT 5
69644: PPUSH
69645: CALL_OW 1
69649: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69650: LD_ADDR_VAR 0 2
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: LD_INT 0
69660: PUSH
69661: LD_INT 0
69663: PUSH
69664: LD_INT 0
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: ST_TO_ADDR
// if sci > 1 then
69673: LD_VAR 0 8
69677: PUSH
69678: LD_INT 1
69680: GREATER
69681: IFFALSE 69709
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
69683: LD_ADDR_VAR 0 4
69687: PUSH
69688: LD_VAR 0 4
69692: PUSH
69693: LD_VAR 0 8
69697: PUSH
69698: LD_VAR 0 8
69702: PUSH
69703: LD_INT 1
69705: ARRAY
69706: DIFF
69707: DIFF
69708: ST_TO_ADDR
// if tmp and not sci then
69709: LD_VAR 0 4
69713: PUSH
69714: LD_VAR 0 8
69718: NOT
69719: AND
69720: IFFALSE 69789
// begin sort := SortBySkill ( tmp , 4 ) ;
69722: LD_ADDR_VAR 0 9
69726: PUSH
69727: LD_VAR 0 4
69731: PPUSH
69732: LD_INT 4
69734: PPUSH
69735: CALL 56034 0 2
69739: ST_TO_ADDR
// if sort then
69740: LD_VAR 0 9
69744: IFFALSE 69760
// p := sort [ 1 ] ;
69746: LD_ADDR_VAR 0 11
69750: PUSH
69751: LD_VAR 0 9
69755: PUSH
69756: LD_INT 1
69758: ARRAY
69759: ST_TO_ADDR
// if p then
69760: LD_VAR 0 11
69764: IFFALSE 69789
// result := Replace ( result , 4 , p ) ;
69766: LD_ADDR_VAR 0 2
69770: PUSH
69771: LD_VAR 0 2
69775: PPUSH
69776: LD_INT 4
69778: PPUSH
69779: LD_VAR 0 11
69783: PPUSH
69784: CALL_OW 1
69788: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69789: LD_ADDR_VAR 0 4
69793: PUSH
69794: LD_VAR 0 4
69798: PUSH
69799: LD_VAR 0 7
69803: DIFF
69804: ST_TO_ADDR
// if tmp and mech < 6 then
69805: LD_VAR 0 4
69809: PUSH
69810: LD_VAR 0 7
69814: PUSH
69815: LD_INT 6
69817: LESS
69818: AND
69819: IFFALSE 70007
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
69821: LD_ADDR_VAR 0 9
69825: PUSH
69826: LD_VAR 0 4
69830: PUSH
69831: LD_VAR 0 8
69835: PUSH
69836: LD_VAR 0 7
69840: UNION
69841: DIFF
69842: PPUSH
69843: LD_INT 3
69845: PPUSH
69846: CALL 56034 0 2
69850: ST_TO_ADDR
// p := [ ] ;
69851: LD_ADDR_VAR 0 11
69855: PUSH
69856: EMPTY
69857: ST_TO_ADDR
// if sort then
69858: LD_VAR 0 9
69862: IFFALSE 69978
// for i = 1 to 6 - mech do
69864: LD_ADDR_VAR 0 3
69868: PUSH
69869: DOUBLE
69870: LD_INT 1
69872: DEC
69873: ST_TO_ADDR
69874: LD_INT 6
69876: PUSH
69877: LD_VAR 0 7
69881: MINUS
69882: PUSH
69883: FOR_TO
69884: IFFALSE 69976
// begin if i = sort then
69886: LD_VAR 0 3
69890: PUSH
69891: LD_VAR 0 9
69895: EQUAL
69896: IFFALSE 69900
// break ;
69898: GO 69976
// if GetClass ( i ) = 3 then
69900: LD_VAR 0 3
69904: PPUSH
69905: CALL_OW 257
69909: PUSH
69910: LD_INT 3
69912: EQUAL
69913: IFFALSE 69917
// continue ;
69915: GO 69883
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69917: LD_ADDR_VAR 0 11
69921: PUSH
69922: LD_VAR 0 11
69926: PPUSH
69927: LD_VAR 0 11
69931: PUSH
69932: LD_INT 1
69934: PLUS
69935: PPUSH
69936: LD_VAR 0 9
69940: PUSH
69941: LD_VAR 0 3
69945: ARRAY
69946: PPUSH
69947: CALL_OW 2
69951: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69952: LD_ADDR_VAR 0 4
69956: PUSH
69957: LD_VAR 0 4
69961: PUSH
69962: LD_VAR 0 9
69966: PUSH
69967: LD_VAR 0 3
69971: ARRAY
69972: DIFF
69973: ST_TO_ADDR
// end ;
69974: GO 69883
69976: POP
69977: POP
// if p then
69978: LD_VAR 0 11
69982: IFFALSE 70007
// result := Replace ( result , 3 , p ) ;
69984: LD_ADDR_VAR 0 2
69988: PUSH
69989: LD_VAR 0 2
69993: PPUSH
69994: LD_INT 3
69996: PPUSH
69997: LD_VAR 0 11
70001: PPUSH
70002: CALL_OW 1
70006: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
70007: LD_ADDR_VAR 0 4
70011: PUSH
70012: LD_VAR 0 4
70016: PUSH
70017: LD_VAR 0 6
70021: DIFF
70022: ST_TO_ADDR
// if tmp and eng < 6 then
70023: LD_VAR 0 4
70027: PUSH
70028: LD_VAR 0 6
70032: PUSH
70033: LD_INT 6
70035: LESS
70036: AND
70037: IFFALSE 70231
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
70039: LD_ADDR_VAR 0 9
70043: PUSH
70044: LD_VAR 0 4
70048: PUSH
70049: LD_VAR 0 8
70053: PUSH
70054: LD_VAR 0 7
70058: UNION
70059: PUSH
70060: LD_VAR 0 6
70064: UNION
70065: DIFF
70066: PPUSH
70067: LD_INT 2
70069: PPUSH
70070: CALL 56034 0 2
70074: ST_TO_ADDR
// p := [ ] ;
70075: LD_ADDR_VAR 0 11
70079: PUSH
70080: EMPTY
70081: ST_TO_ADDR
// if sort then
70082: LD_VAR 0 9
70086: IFFALSE 70202
// for i = 1 to 6 - eng do
70088: LD_ADDR_VAR 0 3
70092: PUSH
70093: DOUBLE
70094: LD_INT 1
70096: DEC
70097: ST_TO_ADDR
70098: LD_INT 6
70100: PUSH
70101: LD_VAR 0 6
70105: MINUS
70106: PUSH
70107: FOR_TO
70108: IFFALSE 70200
// begin if i = sort then
70110: LD_VAR 0 3
70114: PUSH
70115: LD_VAR 0 9
70119: EQUAL
70120: IFFALSE 70124
// break ;
70122: GO 70200
// if GetClass ( i ) = 2 then
70124: LD_VAR 0 3
70128: PPUSH
70129: CALL_OW 257
70133: PUSH
70134: LD_INT 2
70136: EQUAL
70137: IFFALSE 70141
// continue ;
70139: GO 70107
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70141: LD_ADDR_VAR 0 11
70145: PUSH
70146: LD_VAR 0 11
70150: PPUSH
70151: LD_VAR 0 11
70155: PUSH
70156: LD_INT 1
70158: PLUS
70159: PPUSH
70160: LD_VAR 0 9
70164: PUSH
70165: LD_VAR 0 3
70169: ARRAY
70170: PPUSH
70171: CALL_OW 2
70175: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70176: LD_ADDR_VAR 0 4
70180: PUSH
70181: LD_VAR 0 4
70185: PUSH
70186: LD_VAR 0 9
70190: PUSH
70191: LD_VAR 0 3
70195: ARRAY
70196: DIFF
70197: ST_TO_ADDR
// end ;
70198: GO 70107
70200: POP
70201: POP
// if p then
70202: LD_VAR 0 11
70206: IFFALSE 70231
// result := Replace ( result , 2 , p ) ;
70208: LD_ADDR_VAR 0 2
70212: PUSH
70213: LD_VAR 0 2
70217: PPUSH
70218: LD_INT 2
70220: PPUSH
70221: LD_VAR 0 11
70225: PPUSH
70226: CALL_OW 1
70230: ST_TO_ADDR
// end ; exit ;
70231: GO 70955
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
70233: LD_EXP 58
70237: PUSH
70238: LD_EXP 57
70242: PUSH
70243: LD_VAR 0 1
70247: ARRAY
70248: ARRAY
70249: NOT
70250: PUSH
70251: LD_EXP 31
70255: PUSH
70256: LD_VAR 0 1
70260: ARRAY
70261: PPUSH
70262: LD_INT 30
70264: PUSH
70265: LD_INT 3
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PPUSH
70272: CALL_OW 72
70276: AND
70277: PUSH
70278: LD_EXP 36
70282: PUSH
70283: LD_VAR 0 1
70287: ARRAY
70288: NOT
70289: AND
70290: IFFALSE 70955
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
70292: LD_ADDR_EXP 73
70296: PUSH
70297: LD_EXP 73
70301: PPUSH
70302: LD_VAR 0 1
70306: PPUSH
70307: LD_INT 6
70309: PPUSH
70310: CALL_OW 1
70314: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
70315: LD_ADDR_VAR 0 2
70319: PUSH
70320: LD_INT 0
70322: PUSH
70323: LD_INT 0
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: LD_INT 0
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: ST_TO_ADDR
// if sci >= 1 then
70338: LD_VAR 0 8
70342: PUSH
70343: LD_INT 1
70345: GREATEREQUAL
70346: IFFALSE 70368
// tmp := tmp diff sci [ 1 ] ;
70348: LD_ADDR_VAR 0 4
70352: PUSH
70353: LD_VAR 0 4
70357: PUSH
70358: LD_VAR 0 8
70362: PUSH
70363: LD_INT 1
70365: ARRAY
70366: DIFF
70367: ST_TO_ADDR
// if tmp and not sci then
70368: LD_VAR 0 4
70372: PUSH
70373: LD_VAR 0 8
70377: NOT
70378: AND
70379: IFFALSE 70448
// begin sort := SortBySkill ( tmp , 4 ) ;
70381: LD_ADDR_VAR 0 9
70385: PUSH
70386: LD_VAR 0 4
70390: PPUSH
70391: LD_INT 4
70393: PPUSH
70394: CALL 56034 0 2
70398: ST_TO_ADDR
// if sort then
70399: LD_VAR 0 9
70403: IFFALSE 70419
// p := sort [ 1 ] ;
70405: LD_ADDR_VAR 0 11
70409: PUSH
70410: LD_VAR 0 9
70414: PUSH
70415: LD_INT 1
70417: ARRAY
70418: ST_TO_ADDR
// if p then
70419: LD_VAR 0 11
70423: IFFALSE 70448
// result := Replace ( result , 4 , p ) ;
70425: LD_ADDR_VAR 0 2
70429: PUSH
70430: LD_VAR 0 2
70434: PPUSH
70435: LD_INT 4
70437: PPUSH
70438: LD_VAR 0 11
70442: PPUSH
70443: CALL_OW 1
70447: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
70448: LD_ADDR_VAR 0 4
70452: PUSH
70453: LD_VAR 0 4
70457: PUSH
70458: LD_VAR 0 7
70462: DIFF
70463: ST_TO_ADDR
// if tmp and mech < 6 then
70464: LD_VAR 0 4
70468: PUSH
70469: LD_VAR 0 7
70473: PUSH
70474: LD_INT 6
70476: LESS
70477: AND
70478: IFFALSE 70660
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
70480: LD_ADDR_VAR 0 9
70484: PUSH
70485: LD_VAR 0 4
70489: PUSH
70490: LD_VAR 0 7
70494: DIFF
70495: PPUSH
70496: LD_INT 3
70498: PPUSH
70499: CALL 56034 0 2
70503: ST_TO_ADDR
// p := [ ] ;
70504: LD_ADDR_VAR 0 11
70508: PUSH
70509: EMPTY
70510: ST_TO_ADDR
// if sort then
70511: LD_VAR 0 9
70515: IFFALSE 70631
// for i = 1 to 6 - mech do
70517: LD_ADDR_VAR 0 3
70521: PUSH
70522: DOUBLE
70523: LD_INT 1
70525: DEC
70526: ST_TO_ADDR
70527: LD_INT 6
70529: PUSH
70530: LD_VAR 0 7
70534: MINUS
70535: PUSH
70536: FOR_TO
70537: IFFALSE 70629
// begin if i = sort then
70539: LD_VAR 0 3
70543: PUSH
70544: LD_VAR 0 9
70548: EQUAL
70549: IFFALSE 70553
// break ;
70551: GO 70629
// if GetClass ( i ) = 3 then
70553: LD_VAR 0 3
70557: PPUSH
70558: CALL_OW 257
70562: PUSH
70563: LD_INT 3
70565: EQUAL
70566: IFFALSE 70570
// continue ;
70568: GO 70536
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70570: LD_ADDR_VAR 0 11
70574: PUSH
70575: LD_VAR 0 11
70579: PPUSH
70580: LD_VAR 0 11
70584: PUSH
70585: LD_INT 1
70587: PLUS
70588: PPUSH
70589: LD_VAR 0 9
70593: PUSH
70594: LD_VAR 0 3
70598: ARRAY
70599: PPUSH
70600: CALL_OW 2
70604: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70605: LD_ADDR_VAR 0 4
70609: PUSH
70610: LD_VAR 0 4
70614: PUSH
70615: LD_VAR 0 9
70619: PUSH
70620: LD_VAR 0 3
70624: ARRAY
70625: DIFF
70626: ST_TO_ADDR
// end ;
70627: GO 70536
70629: POP
70630: POP
// if p then
70631: LD_VAR 0 11
70635: IFFALSE 70660
// result := Replace ( result , 3 , p ) ;
70637: LD_ADDR_VAR 0 2
70641: PUSH
70642: LD_VAR 0 2
70646: PPUSH
70647: LD_INT 3
70649: PPUSH
70650: LD_VAR 0 11
70654: PPUSH
70655: CALL_OW 1
70659: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
70660: LD_ADDR_VAR 0 4
70664: PUSH
70665: LD_VAR 0 4
70669: PUSH
70670: LD_VAR 0 6
70674: DIFF
70675: ST_TO_ADDR
// if tmp and eng < 4 then
70676: LD_VAR 0 4
70680: PUSH
70681: LD_VAR 0 6
70685: PUSH
70686: LD_INT 4
70688: LESS
70689: AND
70690: IFFALSE 70880
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
70692: LD_ADDR_VAR 0 9
70696: PUSH
70697: LD_VAR 0 4
70701: PUSH
70702: LD_VAR 0 7
70706: PUSH
70707: LD_VAR 0 6
70711: UNION
70712: DIFF
70713: PPUSH
70714: LD_INT 2
70716: PPUSH
70717: CALL 56034 0 2
70721: ST_TO_ADDR
// p := [ ] ;
70722: LD_ADDR_VAR 0 11
70726: PUSH
70727: EMPTY
70728: ST_TO_ADDR
// if sort then
70729: LD_VAR 0 9
70733: IFFALSE 70849
// for i = 1 to 4 - eng do
70735: LD_ADDR_VAR 0 3
70739: PUSH
70740: DOUBLE
70741: LD_INT 1
70743: DEC
70744: ST_TO_ADDR
70745: LD_INT 4
70747: PUSH
70748: LD_VAR 0 6
70752: MINUS
70753: PUSH
70754: FOR_TO
70755: IFFALSE 70847
// begin if i = sort then
70757: LD_VAR 0 3
70761: PUSH
70762: LD_VAR 0 9
70766: EQUAL
70767: IFFALSE 70771
// break ;
70769: GO 70847
// if GetClass ( i ) = 2 then
70771: LD_VAR 0 3
70775: PPUSH
70776: CALL_OW 257
70780: PUSH
70781: LD_INT 2
70783: EQUAL
70784: IFFALSE 70788
// continue ;
70786: GO 70754
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70788: LD_ADDR_VAR 0 11
70792: PUSH
70793: LD_VAR 0 11
70797: PPUSH
70798: LD_VAR 0 11
70802: PUSH
70803: LD_INT 1
70805: PLUS
70806: PPUSH
70807: LD_VAR 0 9
70811: PUSH
70812: LD_VAR 0 3
70816: ARRAY
70817: PPUSH
70818: CALL_OW 2
70822: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70823: LD_ADDR_VAR 0 4
70827: PUSH
70828: LD_VAR 0 4
70832: PUSH
70833: LD_VAR 0 9
70837: PUSH
70838: LD_VAR 0 3
70842: ARRAY
70843: DIFF
70844: ST_TO_ADDR
// end ;
70845: GO 70754
70847: POP
70848: POP
// if p then
70849: LD_VAR 0 11
70853: IFFALSE 70878
// result := Replace ( result , 2 , p ) ;
70855: LD_ADDR_VAR 0 2
70859: PUSH
70860: LD_VAR 0 2
70864: PPUSH
70865: LD_INT 2
70867: PPUSH
70868: LD_VAR 0 11
70872: PPUSH
70873: CALL_OW 1
70877: ST_TO_ADDR
// end else
70878: GO 70924
// for i = eng downto 5 do
70880: LD_ADDR_VAR 0 3
70884: PUSH
70885: DOUBLE
70886: LD_VAR 0 6
70890: INC
70891: ST_TO_ADDR
70892: LD_INT 5
70894: PUSH
70895: FOR_DOWNTO
70896: IFFALSE 70922
// tmp := tmp union eng [ i ] ;
70898: LD_ADDR_VAR 0 4
70902: PUSH
70903: LD_VAR 0 4
70907: PUSH
70908: LD_VAR 0 6
70912: PUSH
70913: LD_VAR 0 3
70917: ARRAY
70918: UNION
70919: ST_TO_ADDR
70920: GO 70895
70922: POP
70923: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
70924: LD_ADDR_VAR 0 2
70928: PUSH
70929: LD_VAR 0 2
70933: PPUSH
70934: LD_INT 1
70936: PPUSH
70937: LD_VAR 0 4
70941: PUSH
70942: LD_VAR 0 5
70946: DIFF
70947: PPUSH
70948: CALL_OW 1
70952: ST_TO_ADDR
// exit ;
70953: GO 70955
// end ; end ;
70955: LD_VAR 0 2
70959: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
70960: LD_INT 0
70962: PPUSH
70963: PPUSH
70964: PPUSH
// if not mc_bases then
70965: LD_EXP 31
70969: NOT
70970: IFFALSE 70974
// exit ;
70972: GO 71116
// for i = 1 to mc_bases do
70974: LD_ADDR_VAR 0 2
70978: PUSH
70979: DOUBLE
70980: LD_INT 1
70982: DEC
70983: ST_TO_ADDR
70984: LD_EXP 31
70988: PUSH
70989: FOR_TO
70990: IFFALSE 71107
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70992: LD_ADDR_VAR 0 3
70996: PUSH
70997: LD_EXP 31
71001: PUSH
71002: LD_VAR 0 2
71006: ARRAY
71007: PPUSH
71008: LD_INT 21
71010: PUSH
71011: LD_INT 3
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 3
71020: PUSH
71021: LD_INT 2
71023: PUSH
71024: LD_INT 30
71026: PUSH
71027: LD_INT 29
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 30
71036: PUSH
71037: LD_INT 30
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: LIST
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 3
71055: PUSH
71056: LD_INT 24
71058: PUSH
71059: LD_INT 1000
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: LIST
71074: PPUSH
71075: CALL_OW 72
71079: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
71080: LD_ADDR_EXP 32
71084: PUSH
71085: LD_EXP 32
71089: PPUSH
71090: LD_VAR 0 2
71094: PPUSH
71095: LD_VAR 0 3
71099: PPUSH
71100: CALL_OW 1
71104: ST_TO_ADDR
// end ;
71105: GO 70989
71107: POP
71108: POP
// RaiseSailEvent ( 101 ) ;
71109: LD_INT 101
71111: PPUSH
71112: CALL_OW 427
// end ;
71116: LD_VAR 0 1
71120: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
71121: LD_INT 0
71123: PPUSH
71124: PPUSH
71125: PPUSH
71126: PPUSH
71127: PPUSH
71128: PPUSH
71129: PPUSH
// if not mc_bases then
71130: LD_EXP 31
71134: NOT
71135: IFFALSE 71139
// exit ;
71137: GO 71701
// for i = 1 to mc_bases do
71139: LD_ADDR_VAR 0 2
71143: PUSH
71144: DOUBLE
71145: LD_INT 1
71147: DEC
71148: ST_TO_ADDR
71149: LD_EXP 31
71153: PUSH
71154: FOR_TO
71155: IFFALSE 71692
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
71157: LD_ADDR_VAR 0 5
71161: PUSH
71162: LD_EXP 31
71166: PUSH
71167: LD_VAR 0 2
71171: ARRAY
71172: PUSH
71173: LD_EXP 60
71177: PUSH
71178: LD_VAR 0 2
71182: ARRAY
71183: UNION
71184: PPUSH
71185: LD_INT 21
71187: PUSH
71188: LD_INT 1
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: LD_INT 1
71197: PUSH
71198: LD_INT 3
71200: PUSH
71201: LD_INT 54
71203: PUSH
71204: EMPTY
71205: LIST
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 3
71213: PUSH
71214: LD_INT 24
71216: PUSH
71217: LD_INT 1000
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: LIST
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PPUSH
71237: CALL_OW 72
71241: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
71242: LD_ADDR_VAR 0 6
71246: PUSH
71247: LD_EXP 31
71251: PUSH
71252: LD_VAR 0 2
71256: ARRAY
71257: PPUSH
71258: LD_INT 21
71260: PUSH
71261: LD_INT 1
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PUSH
71268: LD_INT 1
71270: PUSH
71271: LD_INT 3
71273: PUSH
71274: LD_INT 54
71276: PUSH
71277: EMPTY
71278: LIST
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: LD_INT 3
71286: PUSH
71287: LD_INT 24
71289: PUSH
71290: LD_INT 250
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: LIST
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PPUSH
71310: CALL_OW 72
71314: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
71315: LD_ADDR_VAR 0 7
71319: PUSH
71320: LD_VAR 0 5
71324: PUSH
71325: LD_VAR 0 6
71329: DIFF
71330: ST_TO_ADDR
// if not need_heal_1 then
71331: LD_VAR 0 6
71335: NOT
71336: IFFALSE 71369
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
71338: LD_ADDR_EXP 34
71342: PUSH
71343: LD_EXP 34
71347: PPUSH
71348: LD_VAR 0 2
71352: PUSH
71353: LD_INT 1
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PPUSH
71360: EMPTY
71361: PPUSH
71362: CALL 24801 0 3
71366: ST_TO_ADDR
71367: GO 71439
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
71369: LD_ADDR_EXP 34
71373: PUSH
71374: LD_EXP 34
71378: PPUSH
71379: LD_VAR 0 2
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PPUSH
71391: LD_EXP 34
71395: PUSH
71396: LD_VAR 0 2
71400: ARRAY
71401: PUSH
71402: LD_INT 1
71404: ARRAY
71405: PPUSH
71406: LD_INT 3
71408: PUSH
71409: LD_INT 24
71411: PUSH
71412: LD_INT 1000
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PPUSH
71423: CALL_OW 72
71427: PUSH
71428: LD_VAR 0 6
71432: UNION
71433: PPUSH
71434: CALL 24801 0 3
71438: ST_TO_ADDR
// if not need_heal_2 then
71439: LD_VAR 0 7
71443: NOT
71444: IFFALSE 71477
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
71446: LD_ADDR_EXP 34
71450: PUSH
71451: LD_EXP 34
71455: PPUSH
71456: LD_VAR 0 2
71460: PUSH
71461: LD_INT 2
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PPUSH
71468: EMPTY
71469: PPUSH
71470: CALL 24801 0 3
71474: ST_TO_ADDR
71475: GO 71509
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
71477: LD_ADDR_EXP 34
71481: PUSH
71482: LD_EXP 34
71486: PPUSH
71487: LD_VAR 0 2
71491: PUSH
71492: LD_INT 2
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PPUSH
71499: LD_VAR 0 7
71503: PPUSH
71504: CALL 24801 0 3
71508: ST_TO_ADDR
// if need_heal_2 then
71509: LD_VAR 0 7
71513: IFFALSE 71674
// for j in need_heal_2 do
71515: LD_ADDR_VAR 0 3
71519: PUSH
71520: LD_VAR 0 7
71524: PUSH
71525: FOR_IN
71526: IFFALSE 71672
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71528: LD_ADDR_VAR 0 5
71532: PUSH
71533: LD_EXP 31
71537: PUSH
71538: LD_VAR 0 2
71542: ARRAY
71543: PPUSH
71544: LD_INT 2
71546: PUSH
71547: LD_INT 30
71549: PUSH
71550: LD_INT 6
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 30
71559: PUSH
71560: LD_INT 7
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 30
71569: PUSH
71570: LD_INT 8
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 30
71579: PUSH
71580: LD_INT 0
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 30
71589: PUSH
71590: LD_INT 1
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: PPUSH
71605: CALL_OW 72
71609: ST_TO_ADDR
// if tmp then
71610: LD_VAR 0 5
71614: IFFALSE 71670
// begin k := NearestUnitToUnit ( tmp , j ) ;
71616: LD_ADDR_VAR 0 4
71620: PUSH
71621: LD_VAR 0 5
71625: PPUSH
71626: LD_VAR 0 3
71630: PPUSH
71631: CALL_OW 74
71635: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
71636: LD_VAR 0 3
71640: PPUSH
71641: LD_VAR 0 4
71645: PPUSH
71646: CALL_OW 296
71650: PUSH
71651: LD_INT 5
71653: GREATER
71654: IFFALSE 71670
// ComMoveToNearbyEntrance ( j , k ) ;
71656: LD_VAR 0 3
71660: PPUSH
71661: LD_VAR 0 4
71665: PPUSH
71666: CALL 58407 0 2
// end ; end ;
71670: GO 71525
71672: POP
71673: POP
// if not need_heal_1 and not need_heal_2 then
71674: LD_VAR 0 6
71678: NOT
71679: PUSH
71680: LD_VAR 0 7
71684: NOT
71685: AND
71686: IFFALSE 71690
// continue ;
71688: GO 71154
// end ;
71690: GO 71154
71692: POP
71693: POP
// RaiseSailEvent ( 102 ) ;
71694: LD_INT 102
71696: PPUSH
71697: CALL_OW 427
// end ;
71701: LD_VAR 0 1
71705: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
71706: LD_INT 0
71708: PPUSH
71709: PPUSH
71710: PPUSH
71711: PPUSH
71712: PPUSH
71713: PPUSH
71714: PPUSH
71715: PPUSH
// if not mc_bases then
71716: LD_EXP 31
71720: NOT
71721: IFFALSE 71725
// exit ;
71723: GO 72636
// for i = 1 to mc_bases do
71725: LD_ADDR_VAR 0 2
71729: PUSH
71730: DOUBLE
71731: LD_INT 1
71733: DEC
71734: ST_TO_ADDR
71735: LD_EXP 31
71739: PUSH
71740: FOR_TO
71741: IFFALSE 72634
// begin if not mc_building_need_repair [ i ] then
71743: LD_EXP 32
71747: PUSH
71748: LD_VAR 0 2
71752: ARRAY
71753: NOT
71754: IFFALSE 71939
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
71756: LD_ADDR_VAR 0 6
71760: PUSH
71761: LD_EXP 50
71765: PUSH
71766: LD_VAR 0 2
71770: ARRAY
71771: PPUSH
71772: LD_INT 3
71774: PUSH
71775: LD_INT 24
71777: PUSH
71778: LD_INT 1000
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 2
71791: PUSH
71792: LD_INT 34
71794: PUSH
71795: LD_INT 13
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 34
71804: PUSH
71805: LD_INT 52
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 34
71814: PUSH
71815: LD_INT 88
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PPUSH
71832: CALL_OW 72
71836: ST_TO_ADDR
// if cranes then
71837: LD_VAR 0 6
71841: IFFALSE 71903
// for j in cranes do
71843: LD_ADDR_VAR 0 3
71847: PUSH
71848: LD_VAR 0 6
71852: PUSH
71853: FOR_IN
71854: IFFALSE 71901
// if not IsInArea ( j , mc_parking [ i ] ) then
71856: LD_VAR 0 3
71860: PPUSH
71861: LD_EXP 55
71865: PUSH
71866: LD_VAR 0 2
71870: ARRAY
71871: PPUSH
71872: CALL_OW 308
71876: NOT
71877: IFFALSE 71899
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71879: LD_VAR 0 3
71883: PPUSH
71884: LD_EXP 55
71888: PUSH
71889: LD_VAR 0 2
71893: ARRAY
71894: PPUSH
71895: CALL_OW 113
71899: GO 71853
71901: POP
71902: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
71903: LD_ADDR_EXP 33
71907: PUSH
71908: LD_EXP 33
71912: PPUSH
71913: LD_VAR 0 2
71917: PPUSH
71918: EMPTY
71919: PPUSH
71920: CALL_OW 1
71924: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
71925: LD_VAR 0 2
71929: PPUSH
71930: LD_INT 101
71932: PPUSH
71933: CALL 66779 0 2
// continue ;
71937: GO 71740
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
71939: LD_ADDR_EXP 37
71943: PUSH
71944: LD_EXP 37
71948: PPUSH
71949: LD_VAR 0 2
71953: PPUSH
71954: EMPTY
71955: PPUSH
71956: CALL_OW 1
71960: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71961: LD_VAR 0 2
71965: PPUSH
71966: LD_INT 103
71968: PPUSH
71969: CALL 66779 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
71973: LD_ADDR_VAR 0 5
71977: PUSH
71978: LD_EXP 31
71982: PUSH
71983: LD_VAR 0 2
71987: ARRAY
71988: PUSH
71989: LD_EXP 60
71993: PUSH
71994: LD_VAR 0 2
71998: ARRAY
71999: UNION
72000: PPUSH
72001: LD_INT 2
72003: PUSH
72004: LD_INT 25
72006: PUSH
72007: LD_INT 2
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 25
72016: PUSH
72017: LD_INT 16
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: LIST
72028: PUSH
72029: EMPTY
72030: LIST
72031: PPUSH
72032: CALL_OW 72
72036: ST_TO_ADDR
// if mc_need_heal [ i ] then
72037: LD_EXP 34
72041: PUSH
72042: LD_VAR 0 2
72046: ARRAY
72047: IFFALSE 72091
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
72049: LD_ADDR_VAR 0 5
72053: PUSH
72054: LD_VAR 0 5
72058: PUSH
72059: LD_EXP 34
72063: PUSH
72064: LD_VAR 0 2
72068: ARRAY
72069: PUSH
72070: LD_INT 1
72072: ARRAY
72073: PUSH
72074: LD_EXP 34
72078: PUSH
72079: LD_VAR 0 2
72083: ARRAY
72084: PUSH
72085: LD_INT 2
72087: ARRAY
72088: UNION
72089: DIFF
72090: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
72091: LD_ADDR_VAR 0 6
72095: PUSH
72096: LD_EXP 50
72100: PUSH
72101: LD_VAR 0 2
72105: ARRAY
72106: PPUSH
72107: LD_INT 2
72109: PUSH
72110: LD_INT 34
72112: PUSH
72113: LD_INT 13
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 34
72122: PUSH
72123: LD_INT 52
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 34
72132: PUSH
72133: LD_INT 88
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: PPUSH
72146: CALL_OW 72
72150: ST_TO_ADDR
// if cranes then
72151: LD_VAR 0 6
72155: IFFALSE 72323
// begin for j in cranes do
72157: LD_ADDR_VAR 0 3
72161: PUSH
72162: LD_VAR 0 6
72166: PUSH
72167: FOR_IN
72168: IFFALSE 72321
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
72170: LD_VAR 0 3
72174: PPUSH
72175: CALL_OW 256
72179: PUSH
72180: LD_INT 1000
72182: EQUAL
72183: PUSH
72184: LD_VAR 0 3
72188: PPUSH
72189: CALL_OW 314
72193: NOT
72194: AND
72195: IFFALSE 72261
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
72197: LD_ADDR_VAR 0 8
72201: PUSH
72202: LD_EXP 32
72206: PUSH
72207: LD_VAR 0 2
72211: ARRAY
72212: PPUSH
72213: LD_VAR 0 3
72217: PPUSH
72218: CALL_OW 74
72222: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
72223: LD_VAR 0 8
72227: PPUSH
72228: LD_INT 16
72230: PPUSH
72231: CALL 27766 0 2
72235: PUSH
72236: LD_INT 4
72238: ARRAY
72239: PUSH
72240: LD_INT 10
72242: LESS
72243: IFFALSE 72259
// ComRepairBuilding ( j , to_repair ) ;
72245: LD_VAR 0 3
72249: PPUSH
72250: LD_VAR 0 8
72254: PPUSH
72255: CALL_OW 130
// end else
72259: GO 72319
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
72261: LD_VAR 0 3
72265: PPUSH
72266: CALL_OW 256
72270: PUSH
72271: LD_INT 500
72273: LESS
72274: PUSH
72275: LD_VAR 0 3
72279: PPUSH
72280: LD_EXP 55
72284: PUSH
72285: LD_VAR 0 2
72289: ARRAY
72290: PPUSH
72291: CALL_OW 308
72295: NOT
72296: AND
72297: IFFALSE 72319
// ComMoveToArea ( j , mc_parking [ i ] ) ;
72299: LD_VAR 0 3
72303: PPUSH
72304: LD_EXP 55
72308: PUSH
72309: LD_VAR 0 2
72313: ARRAY
72314: PPUSH
72315: CALL_OW 113
// end ;
72319: GO 72167
72321: POP
72322: POP
// end ; if tmp > 3 then
72323: LD_VAR 0 5
72327: PUSH
72328: LD_INT 3
72330: GREATER
72331: IFFALSE 72351
// tmp := ShrinkArray ( tmp , 4 ) ;
72333: LD_ADDR_VAR 0 5
72337: PUSH
72338: LD_VAR 0 5
72342: PPUSH
72343: LD_INT 4
72345: PPUSH
72346: CALL 57845 0 2
72350: ST_TO_ADDR
// if not tmp then
72351: LD_VAR 0 5
72355: NOT
72356: IFFALSE 72360
// continue ;
72358: GO 71740
// for j in tmp do
72360: LD_ADDR_VAR 0 3
72364: PUSH
72365: LD_VAR 0 5
72369: PUSH
72370: FOR_IN
72371: IFFALSE 72630
// begin if IsInUnit ( j ) then
72373: LD_VAR 0 3
72377: PPUSH
72378: CALL_OW 310
72382: IFFALSE 72393
// ComExitBuilding ( j ) ;
72384: LD_VAR 0 3
72388: PPUSH
72389: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
72393: LD_VAR 0 3
72397: PUSH
72398: LD_EXP 33
72402: PUSH
72403: LD_VAR 0 2
72407: ARRAY
72408: IN
72409: NOT
72410: IFFALSE 72468
// begin SetTag ( j , 101 ) ;
72412: LD_VAR 0 3
72416: PPUSH
72417: LD_INT 101
72419: PPUSH
72420: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
72424: LD_ADDR_EXP 33
72428: PUSH
72429: LD_EXP 33
72433: PPUSH
72434: LD_VAR 0 2
72438: PUSH
72439: LD_EXP 33
72443: PUSH
72444: LD_VAR 0 2
72448: ARRAY
72449: PUSH
72450: LD_INT 1
72452: PLUS
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PPUSH
72458: LD_VAR 0 3
72462: PPUSH
72463: CALL 24801 0 3
72467: ST_TO_ADDR
// end ; wait ( 1 ) ;
72468: LD_INT 1
72470: PPUSH
72471: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
72475: LD_ADDR_VAR 0 7
72479: PUSH
72480: LD_EXP 32
72484: PUSH
72485: LD_VAR 0 2
72489: ARRAY
72490: ST_TO_ADDR
// if mc_scan [ i ] then
72491: LD_EXP 54
72495: PUSH
72496: LD_VAR 0 2
72500: ARRAY
72501: IFFALSE 72563
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
72503: LD_ADDR_VAR 0 7
72507: PUSH
72508: LD_EXP 32
72512: PUSH
72513: LD_VAR 0 2
72517: ARRAY
72518: PPUSH
72519: LD_INT 3
72521: PUSH
72522: LD_INT 30
72524: PUSH
72525: LD_INT 32
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 30
72534: PUSH
72535: LD_INT 33
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 30
72544: PUSH
72545: LD_INT 31
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: PPUSH
72558: CALL_OW 72
72562: ST_TO_ADDR
// if not to_repair_tmp then
72563: LD_VAR 0 7
72567: NOT
72568: IFFALSE 72572
// continue ;
72570: GO 72370
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
72572: LD_ADDR_VAR 0 8
72576: PUSH
72577: LD_VAR 0 7
72581: PPUSH
72582: LD_VAR 0 3
72586: PPUSH
72587: CALL_OW 74
72591: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
72592: LD_VAR 0 8
72596: PPUSH
72597: LD_INT 16
72599: PPUSH
72600: CALL 27766 0 2
72604: PUSH
72605: LD_INT 4
72607: ARRAY
72608: PUSH
72609: LD_INT 14
72611: LESS
72612: IFFALSE 72628
// ComRepairBuilding ( j , to_repair ) ;
72614: LD_VAR 0 3
72618: PPUSH
72619: LD_VAR 0 8
72623: PPUSH
72624: CALL_OW 130
// end ;
72628: GO 72370
72630: POP
72631: POP
// end ;
72632: GO 71740
72634: POP
72635: POP
// end ;
72636: LD_VAR 0 1
72640: RET
// export function MC_Heal ; var i , j , tmp ; begin
72641: LD_INT 0
72643: PPUSH
72644: PPUSH
72645: PPUSH
72646: PPUSH
// if not mc_bases then
72647: LD_EXP 31
72651: NOT
72652: IFFALSE 72656
// exit ;
72654: GO 73058
// for i = 1 to mc_bases do
72656: LD_ADDR_VAR 0 2
72660: PUSH
72661: DOUBLE
72662: LD_INT 1
72664: DEC
72665: ST_TO_ADDR
72666: LD_EXP 31
72670: PUSH
72671: FOR_TO
72672: IFFALSE 73056
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
72674: LD_EXP 34
72678: PUSH
72679: LD_VAR 0 2
72683: ARRAY
72684: PUSH
72685: LD_INT 1
72687: ARRAY
72688: NOT
72689: PUSH
72690: LD_EXP 34
72694: PUSH
72695: LD_VAR 0 2
72699: ARRAY
72700: PUSH
72701: LD_INT 2
72703: ARRAY
72704: NOT
72705: AND
72706: IFFALSE 72744
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
72708: LD_ADDR_EXP 35
72712: PUSH
72713: LD_EXP 35
72717: PPUSH
72718: LD_VAR 0 2
72722: PPUSH
72723: EMPTY
72724: PPUSH
72725: CALL_OW 1
72729: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
72730: LD_VAR 0 2
72734: PPUSH
72735: LD_INT 102
72737: PPUSH
72738: CALL 66779 0 2
// continue ;
72742: GO 72671
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72744: LD_ADDR_VAR 0 4
72748: PUSH
72749: LD_EXP 31
72753: PUSH
72754: LD_VAR 0 2
72758: ARRAY
72759: PPUSH
72760: LD_INT 25
72762: PUSH
72763: LD_INT 4
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PPUSH
72770: CALL_OW 72
72774: ST_TO_ADDR
// if not tmp then
72775: LD_VAR 0 4
72779: NOT
72780: IFFALSE 72784
// continue ;
72782: GO 72671
// if mc_taming [ i ] then
72784: LD_EXP 62
72788: PUSH
72789: LD_VAR 0 2
72793: ARRAY
72794: IFFALSE 72818
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72796: LD_ADDR_EXP 62
72800: PUSH
72801: LD_EXP 62
72805: PPUSH
72806: LD_VAR 0 2
72810: PPUSH
72811: EMPTY
72812: PPUSH
72813: CALL_OW 1
72817: ST_TO_ADDR
// for j in tmp do
72818: LD_ADDR_VAR 0 3
72822: PUSH
72823: LD_VAR 0 4
72827: PUSH
72828: FOR_IN
72829: IFFALSE 73052
// begin if IsInUnit ( j ) then
72831: LD_VAR 0 3
72835: PPUSH
72836: CALL_OW 310
72840: IFFALSE 72851
// ComExitBuilding ( j ) ;
72842: LD_VAR 0 3
72846: PPUSH
72847: CALL_OW 122
// if not j in mc_healers [ i ] then
72851: LD_VAR 0 3
72855: PUSH
72856: LD_EXP 35
72860: PUSH
72861: LD_VAR 0 2
72865: ARRAY
72866: IN
72867: NOT
72868: IFFALSE 72914
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
72870: LD_ADDR_EXP 35
72874: PUSH
72875: LD_EXP 35
72879: PPUSH
72880: LD_VAR 0 2
72884: PUSH
72885: LD_EXP 35
72889: PUSH
72890: LD_VAR 0 2
72894: ARRAY
72895: PUSH
72896: LD_INT 1
72898: PLUS
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PPUSH
72904: LD_VAR 0 3
72908: PPUSH
72909: CALL 24801 0 3
72913: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
72914: LD_VAR 0 3
72918: PPUSH
72919: CALL_OW 110
72923: PUSH
72924: LD_INT 102
72926: NONEQUAL
72927: IFFALSE 72941
// SetTag ( j , 102 ) ;
72929: LD_VAR 0 3
72933: PPUSH
72934: LD_INT 102
72936: PPUSH
72937: CALL_OW 109
// Wait ( 3 ) ;
72941: LD_INT 3
72943: PPUSH
72944: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
72948: LD_EXP 34
72952: PUSH
72953: LD_VAR 0 2
72957: ARRAY
72958: PUSH
72959: LD_INT 1
72961: ARRAY
72962: IFFALSE 72994
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
72964: LD_VAR 0 3
72968: PPUSH
72969: LD_EXP 34
72973: PUSH
72974: LD_VAR 0 2
72978: ARRAY
72979: PUSH
72980: LD_INT 1
72982: ARRAY
72983: PUSH
72984: LD_INT 1
72986: ARRAY
72987: PPUSH
72988: CALL_OW 128
72992: GO 73050
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
72994: LD_VAR 0 3
72998: PPUSH
72999: CALL_OW 314
73003: NOT
73004: PUSH
73005: LD_EXP 34
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: PUSH
73016: LD_INT 2
73018: ARRAY
73019: AND
73020: IFFALSE 73050
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
73022: LD_VAR 0 3
73026: PPUSH
73027: LD_EXP 34
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: PUSH
73038: LD_INT 2
73040: ARRAY
73041: PUSH
73042: LD_INT 1
73044: ARRAY
73045: PPUSH
73046: CALL_OW 128
// end ;
73050: GO 72828
73052: POP
73053: POP
// end ;
73054: GO 72671
73056: POP
73057: POP
// end ;
73058: LD_VAR 0 1
73062: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
73063: LD_INT 0
73065: PPUSH
73066: PPUSH
73067: PPUSH
73068: PPUSH
73069: PPUSH
73070: PPUSH
// if not mc_bases then
73071: LD_EXP 31
73075: NOT
73076: IFFALSE 73080
// exit ;
73078: GO 74243
// for i = 1 to mc_bases do
73080: LD_ADDR_VAR 0 2
73084: PUSH
73085: DOUBLE
73086: LD_INT 1
73088: DEC
73089: ST_TO_ADDR
73090: LD_EXP 31
73094: PUSH
73095: FOR_TO
73096: IFFALSE 74241
// begin if mc_scan [ i ] then
73098: LD_EXP 54
73102: PUSH
73103: LD_VAR 0 2
73107: ARRAY
73108: IFFALSE 73112
// continue ;
73110: GO 73095
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
73112: LD_EXP 36
73116: PUSH
73117: LD_VAR 0 2
73121: ARRAY
73122: NOT
73123: PUSH
73124: LD_EXP 38
73128: PUSH
73129: LD_VAR 0 2
73133: ARRAY
73134: NOT
73135: AND
73136: PUSH
73137: LD_EXP 37
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: AND
73148: IFFALSE 73186
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
73150: LD_ADDR_EXP 37
73154: PUSH
73155: LD_EXP 37
73159: PPUSH
73160: LD_VAR 0 2
73164: PPUSH
73165: EMPTY
73166: PPUSH
73167: CALL_OW 1
73171: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
73172: LD_VAR 0 2
73176: PPUSH
73177: LD_INT 103
73179: PPUSH
73180: CALL 66779 0 2
// continue ;
73184: GO 73095
// end ; if mc_construct_list [ i ] then
73186: LD_EXP 38
73190: PUSH
73191: LD_VAR 0 2
73195: ARRAY
73196: IFFALSE 73416
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
73198: LD_ADDR_VAR 0 5
73202: PUSH
73203: LD_EXP 31
73207: PUSH
73208: LD_VAR 0 2
73212: ARRAY
73213: PPUSH
73214: LD_INT 25
73216: PUSH
73217: LD_INT 2
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PPUSH
73224: CALL_OW 72
73228: PUSH
73229: LD_EXP 33
73233: PUSH
73234: LD_VAR 0 2
73238: ARRAY
73239: DIFF
73240: ST_TO_ADDR
// if not tmp then
73241: LD_VAR 0 5
73245: NOT
73246: IFFALSE 73250
// continue ;
73248: GO 73095
// for j in tmp do
73250: LD_ADDR_VAR 0 3
73254: PUSH
73255: LD_VAR 0 5
73259: PUSH
73260: FOR_IN
73261: IFFALSE 73412
// begin if not mc_builders [ i ] then
73263: LD_EXP 37
73267: PUSH
73268: LD_VAR 0 2
73272: ARRAY
73273: NOT
73274: IFFALSE 73332
// begin SetTag ( j , 103 ) ;
73276: LD_VAR 0 3
73280: PPUSH
73281: LD_INT 103
73283: PPUSH
73284: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
73288: LD_ADDR_EXP 37
73292: PUSH
73293: LD_EXP 37
73297: PPUSH
73298: LD_VAR 0 2
73302: PUSH
73303: LD_EXP 37
73307: PUSH
73308: LD_VAR 0 2
73312: ARRAY
73313: PUSH
73314: LD_INT 1
73316: PLUS
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PPUSH
73322: LD_VAR 0 3
73326: PPUSH
73327: CALL 24801 0 3
73331: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
73332: LD_VAR 0 3
73336: PPUSH
73337: CALL_OW 310
73341: IFFALSE 73352
// ComExitBuilding ( j ) ;
73343: LD_VAR 0 3
73347: PPUSH
73348: CALL_OW 122
// wait ( 3 ) ;
73352: LD_INT 3
73354: PPUSH
73355: CALL_OW 67
// if not mc_construct_list [ i ] then
73359: LD_EXP 38
73363: PUSH
73364: LD_VAR 0 2
73368: ARRAY
73369: NOT
73370: IFFALSE 73374
// break ;
73372: GO 73412
// if not HasTask ( j ) then
73374: LD_VAR 0 3
73378: PPUSH
73379: CALL_OW 314
73383: NOT
73384: IFFALSE 73410
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
73386: LD_VAR 0 3
73390: PPUSH
73391: LD_EXP 38
73395: PUSH
73396: LD_VAR 0 2
73400: ARRAY
73401: PUSH
73402: LD_INT 1
73404: ARRAY
73405: PPUSH
73406: CALL 28039 0 2
// end ;
73410: GO 73260
73412: POP
73413: POP
// end else
73414: GO 74239
// if mc_build_list [ i ] then
73416: LD_EXP 36
73420: PUSH
73421: LD_VAR 0 2
73425: ARRAY
73426: IFFALSE 74239
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
73428: LD_EXP 36
73432: PUSH
73433: LD_VAR 0 2
73437: ARRAY
73438: PUSH
73439: LD_INT 1
73441: ARRAY
73442: PUSH
73443: LD_INT 1
73445: ARRAY
73446: PPUSH
73447: CALL 27863 0 1
73451: PUSH
73452: LD_EXP 31
73456: PUSH
73457: LD_VAR 0 2
73461: ARRAY
73462: PPUSH
73463: LD_INT 2
73465: PUSH
73466: LD_INT 30
73468: PUSH
73469: LD_INT 2
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 30
73478: PUSH
73479: LD_INT 3
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: LIST
73490: PPUSH
73491: CALL_OW 72
73495: NOT
73496: AND
73497: IFFALSE 73602
// begin for j = 1 to mc_build_list [ i ] do
73499: LD_ADDR_VAR 0 3
73503: PUSH
73504: DOUBLE
73505: LD_INT 1
73507: DEC
73508: ST_TO_ADDR
73509: LD_EXP 36
73513: PUSH
73514: LD_VAR 0 2
73518: ARRAY
73519: PUSH
73520: FOR_TO
73521: IFFALSE 73600
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
73523: LD_EXP 36
73527: PUSH
73528: LD_VAR 0 2
73532: ARRAY
73533: PUSH
73534: LD_VAR 0 3
73538: ARRAY
73539: PUSH
73540: LD_INT 1
73542: ARRAY
73543: PUSH
73544: LD_INT 2
73546: EQUAL
73547: IFFALSE 73598
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
73549: LD_ADDR_EXP 36
73553: PUSH
73554: LD_EXP 36
73558: PPUSH
73559: LD_VAR 0 2
73563: PPUSH
73564: LD_EXP 36
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: PPUSH
73575: LD_VAR 0 3
73579: PPUSH
73580: LD_INT 1
73582: PPUSH
73583: LD_INT 0
73585: PPUSH
73586: CALL 24219 0 4
73590: PPUSH
73591: CALL_OW 1
73595: ST_TO_ADDR
// break ;
73596: GO 73600
// end ;
73598: GO 73520
73600: POP
73601: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73602: LD_ADDR_VAR 0 6
73606: PUSH
73607: LD_EXP 31
73611: PUSH
73612: LD_VAR 0 2
73616: ARRAY
73617: PPUSH
73618: LD_INT 2
73620: PUSH
73621: LD_INT 30
73623: PUSH
73624: LD_INT 0
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 30
73633: PUSH
73634: LD_INT 1
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: LIST
73645: PPUSH
73646: CALL_OW 72
73650: ST_TO_ADDR
// for k := 1 to depot do
73651: LD_ADDR_VAR 0 4
73655: PUSH
73656: DOUBLE
73657: LD_INT 1
73659: DEC
73660: ST_TO_ADDR
73661: LD_VAR 0 6
73665: PUSH
73666: FOR_TO
73667: IFFALSE 74237
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
73669: LD_EXP 36
73673: PUSH
73674: LD_VAR 0 2
73678: ARRAY
73679: PUSH
73680: LD_INT 1
73682: ARRAY
73683: PUSH
73684: LD_INT 1
73686: ARRAY
73687: PUSH
73688: LD_INT 0
73690: EQUAL
73691: PUSH
73692: LD_VAR 0 6
73696: PUSH
73697: LD_VAR 0 4
73701: ARRAY
73702: PPUSH
73703: LD_EXP 36
73707: PUSH
73708: LD_VAR 0 2
73712: ARRAY
73713: PUSH
73714: LD_INT 1
73716: ARRAY
73717: PUSH
73718: LD_INT 1
73720: ARRAY
73721: PPUSH
73722: LD_EXP 36
73726: PUSH
73727: LD_VAR 0 2
73731: ARRAY
73732: PUSH
73733: LD_INT 1
73735: ARRAY
73736: PUSH
73737: LD_INT 2
73739: ARRAY
73740: PPUSH
73741: LD_EXP 36
73745: PUSH
73746: LD_VAR 0 2
73750: ARRAY
73751: PUSH
73752: LD_INT 1
73754: ARRAY
73755: PUSH
73756: LD_INT 3
73758: ARRAY
73759: PPUSH
73760: LD_EXP 36
73764: PUSH
73765: LD_VAR 0 2
73769: ARRAY
73770: PUSH
73771: LD_INT 1
73773: ARRAY
73774: PUSH
73775: LD_INT 4
73777: ARRAY
73778: PPUSH
73779: CALL 33275 0 5
73783: OR
73784: IFFALSE 74065
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
73786: LD_ADDR_VAR 0 5
73790: PUSH
73791: LD_EXP 31
73795: PUSH
73796: LD_VAR 0 2
73800: ARRAY
73801: PPUSH
73802: LD_INT 25
73804: PUSH
73805: LD_INT 2
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PPUSH
73812: CALL_OW 72
73816: PUSH
73817: LD_EXP 33
73821: PUSH
73822: LD_VAR 0 2
73826: ARRAY
73827: DIFF
73828: ST_TO_ADDR
// if not tmp then
73829: LD_VAR 0 5
73833: NOT
73834: IFFALSE 73838
// continue ;
73836: GO 73666
// for j in tmp do
73838: LD_ADDR_VAR 0 3
73842: PUSH
73843: LD_VAR 0 5
73847: PUSH
73848: FOR_IN
73849: IFFALSE 74061
// begin if not mc_builders [ i ] then
73851: LD_EXP 37
73855: PUSH
73856: LD_VAR 0 2
73860: ARRAY
73861: NOT
73862: IFFALSE 73920
// begin SetTag ( j , 103 ) ;
73864: LD_VAR 0 3
73868: PPUSH
73869: LD_INT 103
73871: PPUSH
73872: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
73876: LD_ADDR_EXP 37
73880: PUSH
73881: LD_EXP 37
73885: PPUSH
73886: LD_VAR 0 2
73890: PUSH
73891: LD_EXP 37
73895: PUSH
73896: LD_VAR 0 2
73900: ARRAY
73901: PUSH
73902: LD_INT 1
73904: PLUS
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PPUSH
73910: LD_VAR 0 3
73914: PPUSH
73915: CALL 24801 0 3
73919: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
73920: LD_VAR 0 3
73924: PPUSH
73925: CALL_OW 310
73929: IFFALSE 73940
// ComExitBuilding ( j ) ;
73931: LD_VAR 0 3
73935: PPUSH
73936: CALL_OW 122
// wait ( 3 ) ;
73940: LD_INT 3
73942: PPUSH
73943: CALL_OW 67
// if not mc_build_list [ i ] then
73947: LD_EXP 36
73951: PUSH
73952: LD_VAR 0 2
73956: ARRAY
73957: NOT
73958: IFFALSE 73962
// break ;
73960: GO 74061
// if not HasTask ( j ) then
73962: LD_VAR 0 3
73966: PPUSH
73967: CALL_OW 314
73971: NOT
73972: IFFALSE 74059
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
73974: LD_VAR 0 3
73978: PPUSH
73979: LD_EXP 36
73983: PUSH
73984: LD_VAR 0 2
73988: ARRAY
73989: PUSH
73990: LD_INT 1
73992: ARRAY
73993: PUSH
73994: LD_INT 1
73996: ARRAY
73997: PPUSH
73998: LD_EXP 36
74002: PUSH
74003: LD_VAR 0 2
74007: ARRAY
74008: PUSH
74009: LD_INT 1
74011: ARRAY
74012: PUSH
74013: LD_INT 2
74015: ARRAY
74016: PPUSH
74017: LD_EXP 36
74021: PUSH
74022: LD_VAR 0 2
74026: ARRAY
74027: PUSH
74028: LD_INT 1
74030: ARRAY
74031: PUSH
74032: LD_INT 3
74034: ARRAY
74035: PPUSH
74036: LD_EXP 36
74040: PUSH
74041: LD_VAR 0 2
74045: ARRAY
74046: PUSH
74047: LD_INT 1
74049: ARRAY
74050: PUSH
74051: LD_INT 4
74053: ARRAY
74054: PPUSH
74055: CALL_OW 145
// end ;
74059: GO 73848
74061: POP
74062: POP
// end else
74063: GO 74235
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
74065: LD_EXP 31
74069: PUSH
74070: LD_VAR 0 2
74074: ARRAY
74075: PPUSH
74076: LD_EXP 36
74080: PUSH
74081: LD_VAR 0 2
74085: ARRAY
74086: PUSH
74087: LD_INT 1
74089: ARRAY
74090: PUSH
74091: LD_INT 1
74093: ARRAY
74094: PPUSH
74095: LD_EXP 36
74099: PUSH
74100: LD_VAR 0 2
74104: ARRAY
74105: PUSH
74106: LD_INT 1
74108: ARRAY
74109: PUSH
74110: LD_INT 2
74112: ARRAY
74113: PPUSH
74114: LD_EXP 36
74118: PUSH
74119: LD_VAR 0 2
74123: ARRAY
74124: PUSH
74125: LD_INT 1
74127: ARRAY
74128: PUSH
74129: LD_INT 3
74131: ARRAY
74132: PPUSH
74133: LD_EXP 36
74137: PUSH
74138: LD_VAR 0 2
74142: ARRAY
74143: PUSH
74144: LD_INT 1
74146: ARRAY
74147: PUSH
74148: LD_INT 4
74150: ARRAY
74151: PPUSH
74152: LD_EXP 31
74156: PUSH
74157: LD_VAR 0 2
74161: ARRAY
74162: PPUSH
74163: LD_INT 21
74165: PUSH
74166: LD_INT 3
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PPUSH
74173: CALL_OW 72
74177: PPUSH
74178: EMPTY
74179: PPUSH
74180: CALL 32029 0 7
74184: NOT
74185: IFFALSE 74235
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
74187: LD_ADDR_EXP 36
74191: PUSH
74192: LD_EXP 36
74196: PPUSH
74197: LD_VAR 0 2
74201: PPUSH
74202: LD_EXP 36
74206: PUSH
74207: LD_VAR 0 2
74211: ARRAY
74212: PPUSH
74213: LD_INT 1
74215: PPUSH
74216: LD_INT 1
74218: NEG
74219: PPUSH
74220: LD_INT 0
74222: PPUSH
74223: CALL 24219 0 4
74227: PPUSH
74228: CALL_OW 1
74232: ST_TO_ADDR
// continue ;
74233: GO 73666
// end ; end ;
74235: GO 73666
74237: POP
74238: POP
// end ; end ;
74239: GO 73095
74241: POP
74242: POP
// end ;
74243: LD_VAR 0 1
74247: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
74248: LD_INT 0
74250: PPUSH
74251: PPUSH
74252: PPUSH
74253: PPUSH
74254: PPUSH
74255: PPUSH
// if not mc_bases then
74256: LD_EXP 31
74260: NOT
74261: IFFALSE 74265
// exit ;
74263: GO 74692
// for i = 1 to mc_bases do
74265: LD_ADDR_VAR 0 2
74269: PUSH
74270: DOUBLE
74271: LD_INT 1
74273: DEC
74274: ST_TO_ADDR
74275: LD_EXP 31
74279: PUSH
74280: FOR_TO
74281: IFFALSE 74690
// begin tmp := mc_build_upgrade [ i ] ;
74283: LD_ADDR_VAR 0 4
74287: PUSH
74288: LD_EXP 63
74292: PUSH
74293: LD_VAR 0 2
74297: ARRAY
74298: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
74299: LD_ADDR_VAR 0 6
74303: PUSH
74304: LD_EXP 64
74308: PUSH
74309: LD_VAR 0 2
74313: ARRAY
74314: PPUSH
74315: LD_INT 2
74317: PUSH
74318: LD_INT 30
74320: PUSH
74321: LD_INT 6
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: LD_INT 30
74330: PUSH
74331: LD_INT 7
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: LIST
74342: PPUSH
74343: CALL_OW 72
74347: ST_TO_ADDR
// if not tmp and not lab then
74348: LD_VAR 0 4
74352: NOT
74353: PUSH
74354: LD_VAR 0 6
74358: NOT
74359: AND
74360: IFFALSE 74364
// continue ;
74362: GO 74280
// if tmp then
74364: LD_VAR 0 4
74368: IFFALSE 74488
// for j in tmp do
74370: LD_ADDR_VAR 0 3
74374: PUSH
74375: LD_VAR 0 4
74379: PUSH
74380: FOR_IN
74381: IFFALSE 74486
// begin if UpgradeCost ( j ) then
74383: LD_VAR 0 3
74387: PPUSH
74388: CALL 31689 0 1
74392: IFFALSE 74484
// begin ComUpgrade ( j ) ;
74394: LD_VAR 0 3
74398: PPUSH
74399: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
74403: LD_ADDR_EXP 63
74407: PUSH
74408: LD_EXP 63
74412: PPUSH
74413: LD_VAR 0 2
74417: PPUSH
74418: LD_EXP 63
74422: PUSH
74423: LD_VAR 0 2
74427: ARRAY
74428: PUSH
74429: LD_VAR 0 3
74433: DIFF
74434: PPUSH
74435: CALL_OW 1
74439: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
74440: LD_ADDR_EXP 38
74444: PUSH
74445: LD_EXP 38
74449: PPUSH
74450: LD_VAR 0 2
74454: PUSH
74455: LD_EXP 38
74459: PUSH
74460: LD_VAR 0 2
74464: ARRAY
74465: PUSH
74466: LD_INT 1
74468: PLUS
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PPUSH
74474: LD_VAR 0 3
74478: PPUSH
74479: CALL 24801 0 3
74483: ST_TO_ADDR
// end ; end ;
74484: GO 74380
74486: POP
74487: POP
// if not lab or not mc_lab_upgrade [ i ] then
74488: LD_VAR 0 6
74492: NOT
74493: PUSH
74494: LD_EXP 65
74498: PUSH
74499: LD_VAR 0 2
74503: ARRAY
74504: NOT
74505: OR
74506: IFFALSE 74510
// continue ;
74508: GO 74280
// for j in lab do
74510: LD_ADDR_VAR 0 3
74514: PUSH
74515: LD_VAR 0 6
74519: PUSH
74520: FOR_IN
74521: IFFALSE 74686
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
74523: LD_VAR 0 3
74527: PPUSH
74528: CALL_OW 266
74532: PUSH
74533: LD_INT 6
74535: PUSH
74536: LD_INT 7
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: IN
74543: PUSH
74544: LD_VAR 0 3
74548: PPUSH
74549: CALL_OW 461
74553: PUSH
74554: LD_INT 1
74556: NONEQUAL
74557: AND
74558: IFFALSE 74684
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
74560: LD_VAR 0 3
74564: PPUSH
74565: LD_EXP 65
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: PUSH
74576: LD_INT 1
74578: ARRAY
74579: PPUSH
74580: CALL 31894 0 2
74584: IFFALSE 74684
// begin ComCancel ( j ) ;
74586: LD_VAR 0 3
74590: PPUSH
74591: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
74595: LD_VAR 0 3
74599: PPUSH
74600: LD_EXP 65
74604: PUSH
74605: LD_VAR 0 2
74609: ARRAY
74610: PUSH
74611: LD_INT 1
74613: ARRAY
74614: PPUSH
74615: CALL_OW 207
// if not j in mc_construct_list [ i ] then
74619: LD_VAR 0 3
74623: PUSH
74624: LD_EXP 38
74628: PUSH
74629: LD_VAR 0 2
74633: ARRAY
74634: IN
74635: NOT
74636: IFFALSE 74682
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
74638: LD_ADDR_EXP 38
74642: PUSH
74643: LD_EXP 38
74647: PPUSH
74648: LD_VAR 0 2
74652: PUSH
74653: LD_EXP 38
74657: PUSH
74658: LD_VAR 0 2
74662: ARRAY
74663: PUSH
74664: LD_INT 1
74666: PLUS
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PPUSH
74672: LD_VAR 0 3
74676: PPUSH
74677: CALL 24801 0 3
74681: ST_TO_ADDR
// break ;
74682: GO 74686
// end ; end ; end ;
74684: GO 74520
74686: POP
74687: POP
// end ;
74688: GO 74280
74690: POP
74691: POP
// end ;
74692: LD_VAR 0 1
74696: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
74697: LD_INT 0
74699: PPUSH
74700: PPUSH
74701: PPUSH
74702: PPUSH
74703: PPUSH
74704: PPUSH
74705: PPUSH
74706: PPUSH
74707: PPUSH
// if not mc_bases then
74708: LD_EXP 31
74712: NOT
74713: IFFALSE 74717
// exit ;
74715: GO 75122
// for i = 1 to mc_bases do
74717: LD_ADDR_VAR 0 2
74721: PUSH
74722: DOUBLE
74723: LD_INT 1
74725: DEC
74726: ST_TO_ADDR
74727: LD_EXP 31
74731: PUSH
74732: FOR_TO
74733: IFFALSE 75120
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
74735: LD_EXP 39
74739: PUSH
74740: LD_VAR 0 2
74744: ARRAY
74745: NOT
74746: PUSH
74747: LD_EXP 31
74751: PUSH
74752: LD_VAR 0 2
74756: ARRAY
74757: PPUSH
74758: LD_INT 30
74760: PUSH
74761: LD_INT 3
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PPUSH
74768: CALL_OW 72
74772: NOT
74773: OR
74774: IFFALSE 74778
// continue ;
74776: GO 74732
// busy := false ;
74778: LD_ADDR_VAR 0 8
74782: PUSH
74783: LD_INT 0
74785: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74786: LD_ADDR_VAR 0 4
74790: PUSH
74791: LD_EXP 31
74795: PUSH
74796: LD_VAR 0 2
74800: ARRAY
74801: PPUSH
74802: LD_INT 30
74804: PUSH
74805: LD_INT 3
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PPUSH
74812: CALL_OW 72
74816: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
74817: LD_ADDR_VAR 0 6
74821: PUSH
74822: LD_EXP 39
74826: PUSH
74827: LD_VAR 0 2
74831: ARRAY
74832: PPUSH
74833: LD_INT 2
74835: PUSH
74836: LD_INT 30
74838: PUSH
74839: LD_INT 32
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: LD_INT 30
74848: PUSH
74849: LD_INT 33
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: LIST
74860: PPUSH
74861: CALL_OW 72
74865: ST_TO_ADDR
// if not t then
74866: LD_VAR 0 6
74870: NOT
74871: IFFALSE 74875
// continue ;
74873: GO 74732
// for j in tmp do
74875: LD_ADDR_VAR 0 3
74879: PUSH
74880: LD_VAR 0 4
74884: PUSH
74885: FOR_IN
74886: IFFALSE 74916
// if not BuildingStatus ( j ) = bs_idle then
74888: LD_VAR 0 3
74892: PPUSH
74893: CALL_OW 461
74897: PUSH
74898: LD_INT 2
74900: EQUAL
74901: NOT
74902: IFFALSE 74914
// begin busy := true ;
74904: LD_ADDR_VAR 0 8
74908: PUSH
74909: LD_INT 1
74911: ST_TO_ADDR
// break ;
74912: GO 74916
// end ;
74914: GO 74885
74916: POP
74917: POP
// if busy then
74918: LD_VAR 0 8
74922: IFFALSE 74926
// continue ;
74924: GO 74732
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
74926: LD_ADDR_VAR 0 7
74930: PUSH
74931: LD_VAR 0 6
74935: PPUSH
74936: LD_INT 35
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PPUSH
74946: CALL_OW 72
74950: ST_TO_ADDR
// if tw then
74951: LD_VAR 0 7
74955: IFFALSE 75032
// begin tw := tw [ 1 ] ;
74957: LD_ADDR_VAR 0 7
74961: PUSH
74962: LD_VAR 0 7
74966: PUSH
74967: LD_INT 1
74969: ARRAY
74970: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
74971: LD_ADDR_VAR 0 9
74975: PUSH
74976: LD_VAR 0 7
74980: PPUSH
74981: LD_EXP 56
74985: PUSH
74986: LD_VAR 0 2
74990: ARRAY
74991: PPUSH
74992: CALL 30186 0 2
74996: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
74997: LD_EXP 70
75001: PUSH
75002: LD_VAR 0 2
75006: ARRAY
75007: IFFALSE 75030
// if not weapon in mc_allowed_tower_weapons [ i ] then
75009: LD_VAR 0 9
75013: PUSH
75014: LD_EXP 70
75018: PUSH
75019: LD_VAR 0 2
75023: ARRAY
75024: IN
75025: NOT
75026: IFFALSE 75030
// continue ;
75028: GO 74732
// end else
75030: GO 75095
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
75032: LD_ADDR_VAR 0 5
75036: PUSH
75037: LD_EXP 39
75041: PUSH
75042: LD_VAR 0 2
75046: ARRAY
75047: PPUSH
75048: LD_VAR 0 4
75052: PPUSH
75053: CALL 57078 0 2
75057: ST_TO_ADDR
// if not tmp2 then
75058: LD_VAR 0 5
75062: NOT
75063: IFFALSE 75067
// continue ;
75065: GO 74732
// tw := tmp2 [ 1 ] ;
75067: LD_ADDR_VAR 0 7
75071: PUSH
75072: LD_VAR 0 5
75076: PUSH
75077: LD_INT 1
75079: ARRAY
75080: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
75081: LD_ADDR_VAR 0 9
75085: PUSH
75086: LD_VAR 0 5
75090: PUSH
75091: LD_INT 2
75093: ARRAY
75094: ST_TO_ADDR
// end ; if not weapon then
75095: LD_VAR 0 9
75099: NOT
75100: IFFALSE 75104
// continue ;
75102: GO 74732
// ComPlaceWeapon ( tw , weapon ) ;
75104: LD_VAR 0 7
75108: PPUSH
75109: LD_VAR 0 9
75113: PPUSH
75114: CALL_OW 148
// end ;
75118: GO 74732
75120: POP
75121: POP
// end ;
75122: LD_VAR 0 1
75126: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
75127: LD_INT 0
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
// if not mc_bases then
75136: LD_EXP 31
75140: NOT
75141: IFFALSE 75145
// exit ;
75143: GO 75920
// for i = 1 to mc_bases do
75145: LD_ADDR_VAR 0 2
75149: PUSH
75150: DOUBLE
75151: LD_INT 1
75153: DEC
75154: ST_TO_ADDR
75155: LD_EXP 31
75159: PUSH
75160: FOR_TO
75161: IFFALSE 75918
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
75163: LD_EXP 44
75167: PUSH
75168: LD_VAR 0 2
75172: ARRAY
75173: NOT
75174: PUSH
75175: LD_EXP 44
75179: PUSH
75180: LD_VAR 0 2
75184: ARRAY
75185: PUSH
75186: LD_EXP 45
75190: PUSH
75191: LD_VAR 0 2
75195: ARRAY
75196: EQUAL
75197: OR
75198: PUSH
75199: LD_EXP 54
75203: PUSH
75204: LD_VAR 0 2
75208: ARRAY
75209: OR
75210: IFFALSE 75214
// continue ;
75212: GO 75160
// if mc_miners [ i ] then
75214: LD_EXP 45
75218: PUSH
75219: LD_VAR 0 2
75223: ARRAY
75224: IFFALSE 75605
// begin for j = mc_miners [ i ] downto 1 do
75226: LD_ADDR_VAR 0 3
75230: PUSH
75231: DOUBLE
75232: LD_EXP 45
75236: PUSH
75237: LD_VAR 0 2
75241: ARRAY
75242: INC
75243: ST_TO_ADDR
75244: LD_INT 1
75246: PUSH
75247: FOR_DOWNTO
75248: IFFALSE 75603
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
75250: LD_EXP 45
75254: PUSH
75255: LD_VAR 0 2
75259: ARRAY
75260: PUSH
75261: LD_VAR 0 3
75265: ARRAY
75266: PPUSH
75267: CALL_OW 301
75271: PUSH
75272: LD_EXP 45
75276: PUSH
75277: LD_VAR 0 2
75281: ARRAY
75282: PUSH
75283: LD_VAR 0 3
75287: ARRAY
75288: PPUSH
75289: CALL_OW 257
75293: PUSH
75294: LD_INT 1
75296: NONEQUAL
75297: OR
75298: IFFALSE 75361
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
75300: LD_ADDR_VAR 0 5
75304: PUSH
75305: LD_EXP 45
75309: PUSH
75310: LD_VAR 0 2
75314: ARRAY
75315: PUSH
75316: LD_EXP 45
75320: PUSH
75321: LD_VAR 0 2
75325: ARRAY
75326: PUSH
75327: LD_VAR 0 3
75331: ARRAY
75332: DIFF
75333: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
75334: LD_ADDR_EXP 45
75338: PUSH
75339: LD_EXP 45
75343: PPUSH
75344: LD_VAR 0 2
75348: PPUSH
75349: LD_VAR 0 5
75353: PPUSH
75354: CALL_OW 1
75358: ST_TO_ADDR
// continue ;
75359: GO 75247
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
75361: LD_EXP 45
75365: PUSH
75366: LD_VAR 0 2
75370: ARRAY
75371: PUSH
75372: LD_VAR 0 3
75376: ARRAY
75377: PPUSH
75378: CALL_OW 257
75382: PUSH
75383: LD_INT 1
75385: EQUAL
75386: PUSH
75387: LD_EXP 45
75391: PUSH
75392: LD_VAR 0 2
75396: ARRAY
75397: PUSH
75398: LD_VAR 0 3
75402: ARRAY
75403: PPUSH
75404: CALL_OW 459
75408: NOT
75409: AND
75410: PUSH
75411: LD_EXP 45
75415: PUSH
75416: LD_VAR 0 2
75420: ARRAY
75421: PUSH
75422: LD_VAR 0 3
75426: ARRAY
75427: PPUSH
75428: CALL_OW 314
75432: NOT
75433: AND
75434: IFFALSE 75601
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
75436: LD_EXP 45
75440: PUSH
75441: LD_VAR 0 2
75445: ARRAY
75446: PUSH
75447: LD_VAR 0 3
75451: ARRAY
75452: PPUSH
75453: CALL_OW 310
75457: IFFALSE 75480
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
75459: LD_EXP 45
75463: PUSH
75464: LD_VAR 0 2
75468: ARRAY
75469: PUSH
75470: LD_VAR 0 3
75474: ARRAY
75475: PPUSH
75476: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
75480: LD_EXP 45
75484: PUSH
75485: LD_VAR 0 2
75489: ARRAY
75490: PUSH
75491: LD_VAR 0 3
75495: ARRAY
75496: PPUSH
75497: CALL_OW 314
75501: NOT
75502: IFFALSE 75601
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
75504: LD_ADDR_VAR 0 7
75508: PUSH
75509: LD_VAR 0 3
75513: PUSH
75514: LD_EXP 44
75518: PUSH
75519: LD_VAR 0 2
75523: ARRAY
75524: PPUSH
75525: CALL 21941 0 1
75529: MOD
75530: PUSH
75531: LD_INT 1
75533: PLUS
75534: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
75535: LD_EXP 45
75539: PUSH
75540: LD_VAR 0 2
75544: ARRAY
75545: PUSH
75546: LD_VAR 0 3
75550: ARRAY
75551: PPUSH
75552: LD_EXP 44
75556: PUSH
75557: LD_VAR 0 2
75561: ARRAY
75562: PUSH
75563: LD_VAR 0 7
75567: ARRAY
75568: PUSH
75569: LD_INT 1
75571: ARRAY
75572: PPUSH
75573: LD_EXP 44
75577: PUSH
75578: LD_VAR 0 2
75582: ARRAY
75583: PUSH
75584: LD_VAR 0 7
75588: ARRAY
75589: PUSH
75590: LD_INT 2
75592: ARRAY
75593: PPUSH
75594: LD_INT 0
75596: PPUSH
75597: CALL_OW 193
// end ; end ; end ;
75601: GO 75247
75603: POP
75604: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
75605: LD_ADDR_VAR 0 5
75609: PUSH
75610: LD_EXP 31
75614: PUSH
75615: LD_VAR 0 2
75619: ARRAY
75620: PPUSH
75621: LD_INT 2
75623: PUSH
75624: LD_INT 30
75626: PUSH
75627: LD_INT 4
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PUSH
75634: LD_INT 30
75636: PUSH
75637: LD_INT 5
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: LD_INT 30
75646: PUSH
75647: LD_INT 32
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: PPUSH
75660: CALL_OW 72
75664: ST_TO_ADDR
// if not tmp then
75665: LD_VAR 0 5
75669: NOT
75670: IFFALSE 75674
// continue ;
75672: GO 75160
// list := [ ] ;
75674: LD_ADDR_VAR 0 6
75678: PUSH
75679: EMPTY
75680: ST_TO_ADDR
// for j in tmp do
75681: LD_ADDR_VAR 0 3
75685: PUSH
75686: LD_VAR 0 5
75690: PUSH
75691: FOR_IN
75692: IFFALSE 75761
// begin for k in UnitsInside ( j ) do
75694: LD_ADDR_VAR 0 4
75698: PUSH
75699: LD_VAR 0 3
75703: PPUSH
75704: CALL_OW 313
75708: PUSH
75709: FOR_IN
75710: IFFALSE 75757
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
75712: LD_VAR 0 4
75716: PPUSH
75717: CALL_OW 257
75721: PUSH
75722: LD_INT 1
75724: EQUAL
75725: PUSH
75726: LD_VAR 0 4
75730: PPUSH
75731: CALL_OW 459
75735: NOT
75736: AND
75737: IFFALSE 75755
// list := list ^ k ;
75739: LD_ADDR_VAR 0 6
75743: PUSH
75744: LD_VAR 0 6
75748: PUSH
75749: LD_VAR 0 4
75753: ADD
75754: ST_TO_ADDR
75755: GO 75709
75757: POP
75758: POP
// end ;
75759: GO 75691
75761: POP
75762: POP
// list := list diff mc_miners [ i ] ;
75763: LD_ADDR_VAR 0 6
75767: PUSH
75768: LD_VAR 0 6
75772: PUSH
75773: LD_EXP 45
75777: PUSH
75778: LD_VAR 0 2
75782: ARRAY
75783: DIFF
75784: ST_TO_ADDR
// if not list then
75785: LD_VAR 0 6
75789: NOT
75790: IFFALSE 75794
// continue ;
75792: GO 75160
// k := mc_mines [ i ] - mc_miners [ i ] ;
75794: LD_ADDR_VAR 0 4
75798: PUSH
75799: LD_EXP 44
75803: PUSH
75804: LD_VAR 0 2
75808: ARRAY
75809: PUSH
75810: LD_EXP 45
75814: PUSH
75815: LD_VAR 0 2
75819: ARRAY
75820: MINUS
75821: ST_TO_ADDR
// if k > list then
75822: LD_VAR 0 4
75826: PUSH
75827: LD_VAR 0 6
75831: GREATER
75832: IFFALSE 75844
// k := list ;
75834: LD_ADDR_VAR 0 4
75838: PUSH
75839: LD_VAR 0 6
75843: ST_TO_ADDR
// for j = 1 to k do
75844: LD_ADDR_VAR 0 3
75848: PUSH
75849: DOUBLE
75850: LD_INT 1
75852: DEC
75853: ST_TO_ADDR
75854: LD_VAR 0 4
75858: PUSH
75859: FOR_TO
75860: IFFALSE 75914
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
75862: LD_ADDR_EXP 45
75866: PUSH
75867: LD_EXP 45
75871: PPUSH
75872: LD_VAR 0 2
75876: PUSH
75877: LD_EXP 45
75881: PUSH
75882: LD_VAR 0 2
75886: ARRAY
75887: PUSH
75888: LD_INT 1
75890: PLUS
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PPUSH
75896: LD_VAR 0 6
75900: PUSH
75901: LD_VAR 0 3
75905: ARRAY
75906: PPUSH
75907: CALL 24801 0 3
75911: ST_TO_ADDR
75912: GO 75859
75914: POP
75915: POP
// end ;
75916: GO 75160
75918: POP
75919: POP
// end ;
75920: LD_VAR 0 1
75924: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
75925: LD_INT 0
75927: PPUSH
75928: PPUSH
75929: PPUSH
75930: PPUSH
75931: PPUSH
75932: PPUSH
75933: PPUSH
75934: PPUSH
75935: PPUSH
75936: PPUSH
75937: PPUSH
// if not mc_bases then
75938: LD_EXP 31
75942: NOT
75943: IFFALSE 75947
// exit ;
75945: GO 77770
// for i = 1 to mc_bases do
75947: LD_ADDR_VAR 0 2
75951: PUSH
75952: DOUBLE
75953: LD_INT 1
75955: DEC
75956: ST_TO_ADDR
75957: LD_EXP 31
75961: PUSH
75962: FOR_TO
75963: IFFALSE 77768
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
75965: LD_EXP 31
75969: PUSH
75970: LD_VAR 0 2
75974: ARRAY
75975: NOT
75976: PUSH
75977: LD_EXP 38
75981: PUSH
75982: LD_VAR 0 2
75986: ARRAY
75987: OR
75988: IFFALSE 75992
// continue ;
75990: GO 75962
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
75992: LD_EXP 47
75996: PUSH
75997: LD_VAR 0 2
76001: ARRAY
76002: NOT
76003: PUSH
76004: LD_EXP 48
76008: PUSH
76009: LD_VAR 0 2
76013: ARRAY
76014: AND
76015: IFFALSE 76053
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
76017: LD_ADDR_EXP 48
76021: PUSH
76022: LD_EXP 48
76026: PPUSH
76027: LD_VAR 0 2
76031: PPUSH
76032: EMPTY
76033: PPUSH
76034: CALL_OW 1
76038: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
76039: LD_VAR 0 2
76043: PPUSH
76044: LD_INT 107
76046: PPUSH
76047: CALL 66779 0 2
// continue ;
76051: GO 75962
// end ; target := [ ] ;
76053: LD_ADDR_VAR 0 7
76057: PUSH
76058: EMPTY
76059: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
76060: LD_ADDR_VAR 0 6
76064: PUSH
76065: LD_EXP 31
76069: PUSH
76070: LD_VAR 0 2
76074: ARRAY
76075: PUSH
76076: LD_INT 1
76078: ARRAY
76079: PPUSH
76080: CALL_OW 255
76084: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76085: LD_ADDR_VAR 0 9
76089: PUSH
76090: LD_EXP 31
76094: PUSH
76095: LD_VAR 0 2
76099: ARRAY
76100: PPUSH
76101: LD_INT 2
76103: PUSH
76104: LD_INT 30
76106: PUSH
76107: LD_INT 0
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 30
76116: PUSH
76117: LD_INT 1
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: LIST
76128: PPUSH
76129: CALL_OW 72
76133: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
76134: LD_ADDR_VAR 0 3
76138: PUSH
76139: DOUBLE
76140: LD_EXP 47
76144: PUSH
76145: LD_VAR 0 2
76149: ARRAY
76150: INC
76151: ST_TO_ADDR
76152: LD_INT 1
76154: PUSH
76155: FOR_DOWNTO
76156: IFFALSE 76401
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
76158: LD_EXP 47
76162: PUSH
76163: LD_VAR 0 2
76167: ARRAY
76168: PUSH
76169: LD_VAR 0 3
76173: ARRAY
76174: PUSH
76175: LD_INT 2
76177: ARRAY
76178: PPUSH
76179: LD_EXP 47
76183: PUSH
76184: LD_VAR 0 2
76188: ARRAY
76189: PUSH
76190: LD_VAR 0 3
76194: ARRAY
76195: PUSH
76196: LD_INT 3
76198: ARRAY
76199: PPUSH
76200: CALL_OW 488
76204: PUSH
76205: LD_EXP 47
76209: PUSH
76210: LD_VAR 0 2
76214: ARRAY
76215: PUSH
76216: LD_VAR 0 3
76220: ARRAY
76221: PUSH
76222: LD_INT 2
76224: ARRAY
76225: PPUSH
76226: LD_EXP 47
76230: PUSH
76231: LD_VAR 0 2
76235: ARRAY
76236: PUSH
76237: LD_VAR 0 3
76241: ARRAY
76242: PUSH
76243: LD_INT 3
76245: ARRAY
76246: PPUSH
76247: CALL_OW 284
76251: PUSH
76252: LD_INT 0
76254: EQUAL
76255: AND
76256: IFFALSE 76311
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
76258: LD_ADDR_VAR 0 5
76262: PUSH
76263: LD_EXP 47
76267: PUSH
76268: LD_VAR 0 2
76272: ARRAY
76273: PPUSH
76274: LD_VAR 0 3
76278: PPUSH
76279: CALL_OW 3
76283: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
76284: LD_ADDR_EXP 47
76288: PUSH
76289: LD_EXP 47
76293: PPUSH
76294: LD_VAR 0 2
76298: PPUSH
76299: LD_VAR 0 5
76303: PPUSH
76304: CALL_OW 1
76308: ST_TO_ADDR
// continue ;
76309: GO 76155
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
76311: LD_VAR 0 6
76315: PPUSH
76316: LD_EXP 47
76320: PUSH
76321: LD_VAR 0 2
76325: ARRAY
76326: PUSH
76327: LD_VAR 0 3
76331: ARRAY
76332: PUSH
76333: LD_INT 2
76335: ARRAY
76336: PPUSH
76337: LD_EXP 47
76341: PUSH
76342: LD_VAR 0 2
76346: ARRAY
76347: PUSH
76348: LD_VAR 0 3
76352: ARRAY
76353: PUSH
76354: LD_INT 3
76356: ARRAY
76357: PPUSH
76358: LD_INT 30
76360: PPUSH
76361: CALL 26065 0 4
76365: PUSH
76366: LD_INT 4
76368: ARRAY
76369: PUSH
76370: LD_INT 0
76372: EQUAL
76373: IFFALSE 76399
// begin target := mc_crates [ i ] [ j ] ;
76375: LD_ADDR_VAR 0 7
76379: PUSH
76380: LD_EXP 47
76384: PUSH
76385: LD_VAR 0 2
76389: ARRAY
76390: PUSH
76391: LD_VAR 0 3
76395: ARRAY
76396: ST_TO_ADDR
// break ;
76397: GO 76401
// end ; end ;
76399: GO 76155
76401: POP
76402: POP
// if not target then
76403: LD_VAR 0 7
76407: NOT
76408: IFFALSE 76412
// continue ;
76410: GO 75962
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
76412: LD_ADDR_VAR 0 8
76416: PUSH
76417: LD_EXP 50
76421: PUSH
76422: LD_VAR 0 2
76426: ARRAY
76427: PPUSH
76428: LD_INT 2
76430: PUSH
76431: LD_INT 3
76433: PUSH
76434: LD_INT 58
76436: PUSH
76437: EMPTY
76438: LIST
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 61
76446: PUSH
76447: EMPTY
76448: LIST
76449: PUSH
76450: LD_INT 33
76452: PUSH
76453: LD_INT 5
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 33
76462: PUSH
76463: LD_INT 3
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 2
76479: PUSH
76480: LD_INT 34
76482: PUSH
76483: LD_INT 32
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 34
76492: PUSH
76493: LD_INT 51
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: LD_INT 34
76502: PUSH
76503: LD_INT 12
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: LIST
76514: LIST
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PPUSH
76520: CALL_OW 72
76524: ST_TO_ADDR
// if not cargo then
76525: LD_VAR 0 8
76529: NOT
76530: IFFALSE 77236
// begin if mc_crates_collector [ i ] < 5 then
76532: LD_EXP 48
76536: PUSH
76537: LD_VAR 0 2
76541: ARRAY
76542: PUSH
76543: LD_INT 5
76545: LESS
76546: IFFALSE 76912
// begin if mc_ape [ i ] then
76548: LD_EXP 60
76552: PUSH
76553: LD_VAR 0 2
76557: ARRAY
76558: IFFALSE 76605
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
76560: LD_ADDR_VAR 0 5
76564: PUSH
76565: LD_EXP 60
76569: PUSH
76570: LD_VAR 0 2
76574: ARRAY
76575: PPUSH
76576: LD_INT 25
76578: PUSH
76579: LD_INT 16
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 24
76588: PUSH
76589: LD_INT 750
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PPUSH
76600: CALL_OW 72
76604: ST_TO_ADDR
// if not tmp then
76605: LD_VAR 0 5
76609: NOT
76610: IFFALSE 76657
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
76612: LD_ADDR_VAR 0 5
76616: PUSH
76617: LD_EXP 31
76621: PUSH
76622: LD_VAR 0 2
76626: ARRAY
76627: PPUSH
76628: LD_INT 25
76630: PUSH
76631: LD_INT 2
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: PUSH
76638: LD_INT 24
76640: PUSH
76641: LD_INT 750
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PPUSH
76652: CALL_OW 72
76656: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
76657: LD_EXP 60
76661: PUSH
76662: LD_VAR 0 2
76666: ARRAY
76667: PUSH
76668: LD_EXP 31
76672: PUSH
76673: LD_VAR 0 2
76677: ARRAY
76678: PPUSH
76679: LD_INT 25
76681: PUSH
76682: LD_INT 2
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PUSH
76689: LD_INT 24
76691: PUSH
76692: LD_INT 750
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PPUSH
76703: CALL_OW 72
76707: AND
76708: PUSH
76709: LD_VAR 0 5
76713: PUSH
76714: LD_INT 5
76716: LESS
76717: AND
76718: IFFALSE 76800
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
76720: LD_ADDR_VAR 0 3
76724: PUSH
76725: LD_EXP 31
76729: PUSH
76730: LD_VAR 0 2
76734: ARRAY
76735: PPUSH
76736: LD_INT 25
76738: PUSH
76739: LD_INT 2
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: LD_INT 24
76748: PUSH
76749: LD_INT 750
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PPUSH
76760: CALL_OW 72
76764: PUSH
76765: FOR_IN
76766: IFFALSE 76798
// begin tmp := tmp union j ;
76768: LD_ADDR_VAR 0 5
76772: PUSH
76773: LD_VAR 0 5
76777: PUSH
76778: LD_VAR 0 3
76782: UNION
76783: ST_TO_ADDR
// if tmp >= 5 then
76784: LD_VAR 0 5
76788: PUSH
76789: LD_INT 5
76791: GREATEREQUAL
76792: IFFALSE 76796
// break ;
76794: GO 76798
// end ;
76796: GO 76765
76798: POP
76799: POP
// end ; if not tmp then
76800: LD_VAR 0 5
76804: NOT
76805: IFFALSE 76809
// continue ;
76807: GO 75962
// for j in tmp do
76809: LD_ADDR_VAR 0 3
76813: PUSH
76814: LD_VAR 0 5
76818: PUSH
76819: FOR_IN
76820: IFFALSE 76910
// if not GetTag ( j ) then
76822: LD_VAR 0 3
76826: PPUSH
76827: CALL_OW 110
76831: NOT
76832: IFFALSE 76908
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
76834: LD_ADDR_EXP 48
76838: PUSH
76839: LD_EXP 48
76843: PPUSH
76844: LD_VAR 0 2
76848: PUSH
76849: LD_EXP 48
76853: PUSH
76854: LD_VAR 0 2
76858: ARRAY
76859: PUSH
76860: LD_INT 1
76862: PLUS
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PPUSH
76868: LD_VAR 0 3
76872: PPUSH
76873: CALL 24801 0 3
76877: ST_TO_ADDR
// SetTag ( j , 107 ) ;
76878: LD_VAR 0 3
76882: PPUSH
76883: LD_INT 107
76885: PPUSH
76886: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
76890: LD_EXP 48
76894: PUSH
76895: LD_VAR 0 2
76899: ARRAY
76900: PUSH
76901: LD_INT 5
76903: GREATEREQUAL
76904: IFFALSE 76908
// break ;
76906: GO 76910
// end ;
76908: GO 76819
76910: POP
76911: POP
// end ; if mc_crates_collector [ i ] and target then
76912: LD_EXP 48
76916: PUSH
76917: LD_VAR 0 2
76921: ARRAY
76922: PUSH
76923: LD_VAR 0 7
76927: AND
76928: IFFALSE 77234
// begin if mc_crates_collector [ i ] < target [ 1 ] then
76930: LD_EXP 48
76934: PUSH
76935: LD_VAR 0 2
76939: ARRAY
76940: PUSH
76941: LD_VAR 0 7
76945: PUSH
76946: LD_INT 1
76948: ARRAY
76949: LESS
76950: IFFALSE 76970
// tmp := mc_crates_collector [ i ] else
76952: LD_ADDR_VAR 0 5
76956: PUSH
76957: LD_EXP 48
76961: PUSH
76962: LD_VAR 0 2
76966: ARRAY
76967: ST_TO_ADDR
76968: GO 76984
// tmp := target [ 1 ] ;
76970: LD_ADDR_VAR 0 5
76974: PUSH
76975: LD_VAR 0 7
76979: PUSH
76980: LD_INT 1
76982: ARRAY
76983: ST_TO_ADDR
// k := 0 ;
76984: LD_ADDR_VAR 0 4
76988: PUSH
76989: LD_INT 0
76991: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
76992: LD_ADDR_VAR 0 3
76996: PUSH
76997: LD_EXP 48
77001: PUSH
77002: LD_VAR 0 2
77006: ARRAY
77007: PUSH
77008: FOR_IN
77009: IFFALSE 77232
// begin k := k + 1 ;
77011: LD_ADDR_VAR 0 4
77015: PUSH
77016: LD_VAR 0 4
77020: PUSH
77021: LD_INT 1
77023: PLUS
77024: ST_TO_ADDR
// if k > tmp then
77025: LD_VAR 0 4
77029: PUSH
77030: LD_VAR 0 5
77034: GREATER
77035: IFFALSE 77039
// break ;
77037: GO 77232
// if not GetClass ( j ) in [ 2 , 16 ] then
77039: LD_VAR 0 3
77043: PPUSH
77044: CALL_OW 257
77048: PUSH
77049: LD_INT 2
77051: PUSH
77052: LD_INT 16
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: IN
77059: NOT
77060: IFFALSE 77113
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
77062: LD_ADDR_EXP 48
77066: PUSH
77067: LD_EXP 48
77071: PPUSH
77072: LD_VAR 0 2
77076: PPUSH
77077: LD_EXP 48
77081: PUSH
77082: LD_VAR 0 2
77086: ARRAY
77087: PUSH
77088: LD_VAR 0 3
77092: DIFF
77093: PPUSH
77094: CALL_OW 1
77098: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77099: LD_VAR 0 3
77103: PPUSH
77104: LD_INT 0
77106: PPUSH
77107: CALL_OW 109
// continue ;
77111: GO 77008
// end ; if IsInUnit ( j ) then
77113: LD_VAR 0 3
77117: PPUSH
77118: CALL_OW 310
77122: IFFALSE 77133
// ComExitBuilding ( j ) ;
77124: LD_VAR 0 3
77128: PPUSH
77129: CALL_OW 122
// wait ( 3 ) ;
77133: LD_INT 3
77135: PPUSH
77136: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
77140: LD_VAR 0 3
77144: PPUSH
77145: CALL_OW 314
77149: PUSH
77150: LD_VAR 0 6
77154: PPUSH
77155: LD_VAR 0 7
77159: PUSH
77160: LD_INT 2
77162: ARRAY
77163: PPUSH
77164: LD_VAR 0 7
77168: PUSH
77169: LD_INT 3
77171: ARRAY
77172: PPUSH
77173: LD_INT 30
77175: PPUSH
77176: CALL 26065 0 4
77180: PUSH
77181: LD_INT 4
77183: ARRAY
77184: AND
77185: IFFALSE 77203
// ComStandNearbyBuilding ( j , depot ) else
77187: LD_VAR 0 3
77191: PPUSH
77192: LD_VAR 0 9
77196: PPUSH
77197: CALL 21403 0 2
77201: GO 77230
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
77203: LD_VAR 0 3
77207: PPUSH
77208: LD_VAR 0 7
77212: PUSH
77213: LD_INT 2
77215: ARRAY
77216: PPUSH
77217: LD_VAR 0 7
77221: PUSH
77222: LD_INT 3
77224: ARRAY
77225: PPUSH
77226: CALL_OW 117
// end ;
77230: GO 77008
77232: POP
77233: POP
// end ; end else
77234: GO 77766
// begin for j in cargo do
77236: LD_ADDR_VAR 0 3
77240: PUSH
77241: LD_VAR 0 8
77245: PUSH
77246: FOR_IN
77247: IFFALSE 77764
// begin if GetTag ( j ) <> 0 then
77249: LD_VAR 0 3
77253: PPUSH
77254: CALL_OW 110
77258: PUSH
77259: LD_INT 0
77261: NONEQUAL
77262: IFFALSE 77266
// continue ;
77264: GO 77246
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
77266: LD_VAR 0 3
77270: PPUSH
77271: CALL_OW 256
77275: PUSH
77276: LD_INT 1000
77278: LESS
77279: PUSH
77280: LD_VAR 0 3
77284: PPUSH
77285: LD_EXP 55
77289: PUSH
77290: LD_VAR 0 2
77294: ARRAY
77295: PPUSH
77296: CALL_OW 308
77300: NOT
77301: AND
77302: IFFALSE 77324
// ComMoveToArea ( j , mc_parking [ i ] ) ;
77304: LD_VAR 0 3
77308: PPUSH
77309: LD_EXP 55
77313: PUSH
77314: LD_VAR 0 2
77318: ARRAY
77319: PPUSH
77320: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
77324: LD_VAR 0 3
77328: PPUSH
77329: CALL_OW 256
77333: PUSH
77334: LD_INT 1000
77336: LESS
77337: PUSH
77338: LD_VAR 0 3
77342: PPUSH
77343: LD_EXP 55
77347: PUSH
77348: LD_VAR 0 2
77352: ARRAY
77353: PPUSH
77354: CALL_OW 308
77358: AND
77359: IFFALSE 77363
// continue ;
77361: GO 77246
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
77363: LD_VAR 0 3
77367: PPUSH
77368: CALL_OW 262
77372: PUSH
77373: LD_INT 2
77375: EQUAL
77376: PUSH
77377: LD_VAR 0 3
77381: PPUSH
77382: CALL_OW 261
77386: PUSH
77387: LD_INT 15
77389: LESS
77390: AND
77391: IFFALSE 77395
// continue ;
77393: GO 77246
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
77395: LD_VAR 0 3
77399: PPUSH
77400: CALL_OW 262
77404: PUSH
77405: LD_INT 1
77407: EQUAL
77408: PUSH
77409: LD_VAR 0 3
77413: PPUSH
77414: CALL_OW 261
77418: PUSH
77419: LD_INT 10
77421: LESS
77422: AND
77423: IFFALSE 77703
// begin if not depot then
77425: LD_VAR 0 9
77429: NOT
77430: IFFALSE 77434
// continue ;
77432: GO 77246
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
77434: LD_VAR 0 3
77438: PPUSH
77439: LD_VAR 0 9
77443: PPUSH
77444: LD_VAR 0 3
77448: PPUSH
77449: CALL_OW 74
77453: PPUSH
77454: CALL_OW 296
77458: PUSH
77459: LD_INT 6
77461: LESS
77462: IFFALSE 77478
// SetFuel ( j , 100 ) else
77464: LD_VAR 0 3
77468: PPUSH
77469: LD_INT 100
77471: PPUSH
77472: CALL_OW 240
77476: GO 77703
// if GetFuel ( j ) = 0 then
77478: LD_VAR 0 3
77482: PPUSH
77483: CALL_OW 261
77487: PUSH
77488: LD_INT 0
77490: EQUAL
77491: IFFALSE 77703
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
77493: LD_ADDR_EXP 50
77497: PUSH
77498: LD_EXP 50
77502: PPUSH
77503: LD_VAR 0 2
77507: PPUSH
77508: LD_EXP 50
77512: PUSH
77513: LD_VAR 0 2
77517: ARRAY
77518: PUSH
77519: LD_VAR 0 3
77523: DIFF
77524: PPUSH
77525: CALL_OW 1
77529: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
77530: LD_VAR 0 3
77534: PPUSH
77535: CALL_OW 263
77539: PUSH
77540: LD_INT 1
77542: EQUAL
77543: IFFALSE 77559
// ComExitVehicle ( IsInUnit ( j ) ) ;
77545: LD_VAR 0 3
77549: PPUSH
77550: CALL_OW 310
77554: PPUSH
77555: CALL_OW 121
// if GetControl ( j ) = control_remote then
77559: LD_VAR 0 3
77563: PPUSH
77564: CALL_OW 263
77568: PUSH
77569: LD_INT 2
77571: EQUAL
77572: IFFALSE 77583
// ComUnlink ( j ) ;
77574: LD_VAR 0 3
77578: PPUSH
77579: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
77583: LD_ADDR_VAR 0 10
77587: PUSH
77588: LD_VAR 0 2
77592: PPUSH
77593: LD_INT 3
77595: PPUSH
77596: CALL 87347 0 2
77600: ST_TO_ADDR
// if fac then
77601: LD_VAR 0 10
77605: IFFALSE 77701
// begin for k in fac do
77607: LD_ADDR_VAR 0 4
77611: PUSH
77612: LD_VAR 0 10
77616: PUSH
77617: FOR_IN
77618: IFFALSE 77699
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
77620: LD_ADDR_VAR 0 11
77624: PUSH
77625: LD_VAR 0 10
77629: PPUSH
77630: LD_VAR 0 3
77634: PPUSH
77635: CALL_OW 265
77639: PPUSH
77640: LD_VAR 0 3
77644: PPUSH
77645: CALL_OW 262
77649: PPUSH
77650: LD_VAR 0 3
77654: PPUSH
77655: CALL_OW 263
77659: PPUSH
77660: LD_VAR 0 3
77664: PPUSH
77665: CALL_OW 264
77669: PPUSH
77670: CALL 22299 0 5
77674: ST_TO_ADDR
// if components then
77675: LD_VAR 0 11
77679: IFFALSE 77697
// begin MC_InsertProduceList ( i , components ) ;
77681: LD_VAR 0 2
77685: PPUSH
77686: LD_VAR 0 11
77690: PPUSH
77691: CALL 86892 0 2
// break ;
77695: GO 77699
// end ; end ;
77697: GO 77617
77699: POP
77700: POP
// end ; continue ;
77701: GO 77246
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
77703: LD_VAR 0 3
77707: PPUSH
77708: LD_INT 1
77710: PPUSH
77711: CALL_OW 289
77715: PUSH
77716: LD_INT 100
77718: LESS
77719: PUSH
77720: LD_VAR 0 3
77724: PPUSH
77725: CALL_OW 314
77729: NOT
77730: AND
77731: IFFALSE 77760
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
77733: LD_VAR 0 3
77737: PPUSH
77738: LD_VAR 0 7
77742: PUSH
77743: LD_INT 2
77745: ARRAY
77746: PPUSH
77747: LD_VAR 0 7
77751: PUSH
77752: LD_INT 3
77754: ARRAY
77755: PPUSH
77756: CALL_OW 117
// break ;
77760: GO 77764
// end ;
77762: GO 77246
77764: POP
77765: POP
// end ; end ;
77766: GO 75962
77768: POP
77769: POP
// end ;
77770: LD_VAR 0 1
77774: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
77775: LD_INT 0
77777: PPUSH
77778: PPUSH
77779: PPUSH
77780: PPUSH
// if not mc_bases then
77781: LD_EXP 31
77785: NOT
77786: IFFALSE 77790
// exit ;
77788: GO 77951
// for i = 1 to mc_bases do
77790: LD_ADDR_VAR 0 2
77794: PUSH
77795: DOUBLE
77796: LD_INT 1
77798: DEC
77799: ST_TO_ADDR
77800: LD_EXP 31
77804: PUSH
77805: FOR_TO
77806: IFFALSE 77949
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
77808: LD_ADDR_VAR 0 4
77812: PUSH
77813: LD_EXP 50
77817: PUSH
77818: LD_VAR 0 2
77822: ARRAY
77823: PUSH
77824: LD_EXP 53
77828: PUSH
77829: LD_VAR 0 2
77833: ARRAY
77834: UNION
77835: PPUSH
77836: LD_INT 33
77838: PUSH
77839: LD_INT 2
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PPUSH
77846: CALL_OW 72
77850: ST_TO_ADDR
// if tmp then
77851: LD_VAR 0 4
77855: IFFALSE 77947
// for j in tmp do
77857: LD_ADDR_VAR 0 3
77861: PUSH
77862: LD_VAR 0 4
77866: PUSH
77867: FOR_IN
77868: IFFALSE 77945
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
77870: LD_VAR 0 3
77874: PPUSH
77875: CALL_OW 312
77879: NOT
77880: PUSH
77881: LD_VAR 0 3
77885: PPUSH
77886: CALL_OW 256
77890: PUSH
77891: LD_INT 250
77893: GREATEREQUAL
77894: AND
77895: IFFALSE 77908
// Connect ( j ) else
77897: LD_VAR 0 3
77901: PPUSH
77902: CALL 28147 0 1
77906: GO 77943
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
77908: LD_VAR 0 3
77912: PPUSH
77913: CALL_OW 256
77917: PUSH
77918: LD_INT 250
77920: LESS
77921: PUSH
77922: LD_VAR 0 3
77926: PPUSH
77927: CALL_OW 312
77931: AND
77932: IFFALSE 77943
// ComUnlink ( j ) ;
77934: LD_VAR 0 3
77938: PPUSH
77939: CALL_OW 136
77943: GO 77867
77945: POP
77946: POP
// end ;
77947: GO 77805
77949: POP
77950: POP
// end ;
77951: LD_VAR 0 1
77955: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
77956: LD_INT 0
77958: PPUSH
77959: PPUSH
77960: PPUSH
77961: PPUSH
77962: PPUSH
// if not mc_bases then
77963: LD_EXP 31
77967: NOT
77968: IFFALSE 77972
// exit ;
77970: GO 78417
// for i = 1 to mc_bases do
77972: LD_ADDR_VAR 0 2
77976: PUSH
77977: DOUBLE
77978: LD_INT 1
77980: DEC
77981: ST_TO_ADDR
77982: LD_EXP 31
77986: PUSH
77987: FOR_TO
77988: IFFALSE 78415
// begin if not mc_produce [ i ] then
77990: LD_EXP 52
77994: PUSH
77995: LD_VAR 0 2
77999: ARRAY
78000: NOT
78001: IFFALSE 78005
// continue ;
78003: GO 77987
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78005: LD_ADDR_VAR 0 5
78009: PUSH
78010: LD_EXP 31
78014: PUSH
78015: LD_VAR 0 2
78019: ARRAY
78020: PPUSH
78021: LD_INT 30
78023: PUSH
78024: LD_INT 3
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PPUSH
78031: CALL_OW 72
78035: ST_TO_ADDR
// if not fac then
78036: LD_VAR 0 5
78040: NOT
78041: IFFALSE 78045
// continue ;
78043: GO 77987
// for j in fac do
78045: LD_ADDR_VAR 0 3
78049: PUSH
78050: LD_VAR 0 5
78054: PUSH
78055: FOR_IN
78056: IFFALSE 78411
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
78058: LD_VAR 0 3
78062: PPUSH
78063: CALL_OW 461
78067: PUSH
78068: LD_INT 2
78070: NONEQUAL
78071: PUSH
78072: LD_VAR 0 3
78076: PPUSH
78077: LD_INT 15
78079: PPUSH
78080: CALL 27766 0 2
78084: PUSH
78085: LD_INT 4
78087: ARRAY
78088: OR
78089: IFFALSE 78093
// continue ;
78091: GO 78055
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
78093: LD_VAR 0 3
78097: PPUSH
78098: LD_EXP 52
78102: PUSH
78103: LD_VAR 0 2
78107: ARRAY
78108: PUSH
78109: LD_INT 1
78111: ARRAY
78112: PUSH
78113: LD_INT 1
78115: ARRAY
78116: PPUSH
78117: LD_EXP 52
78121: PUSH
78122: LD_VAR 0 2
78126: ARRAY
78127: PUSH
78128: LD_INT 1
78130: ARRAY
78131: PUSH
78132: LD_INT 2
78134: ARRAY
78135: PPUSH
78136: LD_EXP 52
78140: PUSH
78141: LD_VAR 0 2
78145: ARRAY
78146: PUSH
78147: LD_INT 1
78149: ARRAY
78150: PUSH
78151: LD_INT 3
78153: ARRAY
78154: PPUSH
78155: LD_EXP 52
78159: PUSH
78160: LD_VAR 0 2
78164: ARRAY
78165: PUSH
78166: LD_INT 1
78168: ARRAY
78169: PUSH
78170: LD_INT 4
78172: ARRAY
78173: PPUSH
78174: CALL_OW 448
78178: PUSH
78179: LD_VAR 0 3
78183: PPUSH
78184: LD_EXP 52
78188: PUSH
78189: LD_VAR 0 2
78193: ARRAY
78194: PUSH
78195: LD_INT 1
78197: ARRAY
78198: PUSH
78199: LD_INT 1
78201: ARRAY
78202: PUSH
78203: LD_EXP 52
78207: PUSH
78208: LD_VAR 0 2
78212: ARRAY
78213: PUSH
78214: LD_INT 1
78216: ARRAY
78217: PUSH
78218: LD_INT 2
78220: ARRAY
78221: PUSH
78222: LD_EXP 52
78226: PUSH
78227: LD_VAR 0 2
78231: ARRAY
78232: PUSH
78233: LD_INT 1
78235: ARRAY
78236: PUSH
78237: LD_INT 3
78239: ARRAY
78240: PUSH
78241: LD_EXP 52
78245: PUSH
78246: LD_VAR 0 2
78250: ARRAY
78251: PUSH
78252: LD_INT 1
78254: ARRAY
78255: PUSH
78256: LD_INT 4
78258: ARRAY
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: LIST
78264: LIST
78265: PPUSH
78266: CALL 31542 0 2
78270: AND
78271: IFFALSE 78409
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
78273: LD_VAR 0 3
78277: PPUSH
78278: LD_EXP 52
78282: PUSH
78283: LD_VAR 0 2
78287: ARRAY
78288: PUSH
78289: LD_INT 1
78291: ARRAY
78292: PUSH
78293: LD_INT 1
78295: ARRAY
78296: PPUSH
78297: LD_EXP 52
78301: PUSH
78302: LD_VAR 0 2
78306: ARRAY
78307: PUSH
78308: LD_INT 1
78310: ARRAY
78311: PUSH
78312: LD_INT 2
78314: ARRAY
78315: PPUSH
78316: LD_EXP 52
78320: PUSH
78321: LD_VAR 0 2
78325: ARRAY
78326: PUSH
78327: LD_INT 1
78329: ARRAY
78330: PUSH
78331: LD_INT 3
78333: ARRAY
78334: PPUSH
78335: LD_EXP 52
78339: PUSH
78340: LD_VAR 0 2
78344: ARRAY
78345: PUSH
78346: LD_INT 1
78348: ARRAY
78349: PUSH
78350: LD_INT 4
78352: ARRAY
78353: PPUSH
78354: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
78358: LD_ADDR_VAR 0 4
78362: PUSH
78363: LD_EXP 52
78367: PUSH
78368: LD_VAR 0 2
78372: ARRAY
78373: PPUSH
78374: LD_INT 1
78376: PPUSH
78377: CALL_OW 3
78381: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78382: LD_ADDR_EXP 52
78386: PUSH
78387: LD_EXP 52
78391: PPUSH
78392: LD_VAR 0 2
78396: PPUSH
78397: LD_VAR 0 4
78401: PPUSH
78402: CALL_OW 1
78406: ST_TO_ADDR
// break ;
78407: GO 78411
// end ; end ;
78409: GO 78055
78411: POP
78412: POP
// end ;
78413: GO 77987
78415: POP
78416: POP
// end ;
78417: LD_VAR 0 1
78421: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
78422: LD_INT 0
78424: PPUSH
78425: PPUSH
78426: PPUSH
// if not mc_bases then
78427: LD_EXP 31
78431: NOT
78432: IFFALSE 78436
// exit ;
78434: GO 78525
// for i = 1 to mc_bases do
78436: LD_ADDR_VAR 0 2
78440: PUSH
78441: DOUBLE
78442: LD_INT 1
78444: DEC
78445: ST_TO_ADDR
78446: LD_EXP 31
78450: PUSH
78451: FOR_TO
78452: IFFALSE 78523
// begin if mc_attack [ i ] then
78454: LD_EXP 51
78458: PUSH
78459: LD_VAR 0 2
78463: ARRAY
78464: IFFALSE 78521
// begin tmp := mc_attack [ i ] [ 1 ] ;
78466: LD_ADDR_VAR 0 3
78470: PUSH
78471: LD_EXP 51
78475: PUSH
78476: LD_VAR 0 2
78480: ARRAY
78481: PUSH
78482: LD_INT 1
78484: ARRAY
78485: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
78486: LD_ADDR_EXP 51
78490: PUSH
78491: LD_EXP 51
78495: PPUSH
78496: LD_VAR 0 2
78500: PPUSH
78501: EMPTY
78502: PPUSH
78503: CALL_OW 1
78507: ST_TO_ADDR
// Attack ( tmp ) ;
78508: LD_VAR 0 3
78512: PPUSH
78513: CALL 114031 0 1
// exit ;
78517: POP
78518: POP
78519: GO 78525
// end ; end ;
78521: GO 78451
78523: POP
78524: POP
// end ;
78525: LD_VAR 0 1
78529: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
78530: LD_INT 0
78532: PPUSH
78533: PPUSH
78534: PPUSH
78535: PPUSH
78536: PPUSH
78537: PPUSH
78538: PPUSH
// if not mc_bases then
78539: LD_EXP 31
78543: NOT
78544: IFFALSE 78548
// exit ;
78546: GO 79405
// for i = 1 to mc_bases do
78548: LD_ADDR_VAR 0 2
78552: PUSH
78553: DOUBLE
78554: LD_INT 1
78556: DEC
78557: ST_TO_ADDR
78558: LD_EXP 31
78562: PUSH
78563: FOR_TO
78564: IFFALSE 79403
// begin if not mc_bases [ i ] then
78566: LD_EXP 31
78570: PUSH
78571: LD_VAR 0 2
78575: ARRAY
78576: NOT
78577: IFFALSE 78581
// continue ;
78579: GO 78563
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
78581: LD_ADDR_VAR 0 7
78585: PUSH
78586: LD_EXP 31
78590: PUSH
78591: LD_VAR 0 2
78595: ARRAY
78596: PUSH
78597: LD_INT 1
78599: ARRAY
78600: PPUSH
78601: CALL 21625 0 1
78605: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
78606: LD_ADDR_EXP 54
78610: PUSH
78611: LD_EXP 54
78615: PPUSH
78616: LD_VAR 0 2
78620: PPUSH
78621: LD_EXP 31
78625: PUSH
78626: LD_VAR 0 2
78630: ARRAY
78631: PUSH
78632: LD_INT 1
78634: ARRAY
78635: PPUSH
78636: CALL_OW 255
78640: PPUSH
78641: LD_EXP 56
78645: PUSH
78646: LD_VAR 0 2
78650: ARRAY
78651: PPUSH
78652: CALL 21590 0 2
78656: PPUSH
78657: CALL_OW 1
78661: ST_TO_ADDR
// if not mc_scan [ i ] then
78662: LD_EXP 54
78666: PUSH
78667: LD_VAR 0 2
78671: ARRAY
78672: NOT
78673: IFFALSE 78851
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
78675: LD_ADDR_EXP 74
78679: PUSH
78680: LD_EXP 74
78684: PPUSH
78685: LD_VAR 0 2
78689: PPUSH
78690: LD_INT 0
78692: PPUSH
78693: CALL_OW 1
78697: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78698: LD_ADDR_VAR 0 4
78702: PUSH
78703: LD_EXP 31
78707: PUSH
78708: LD_VAR 0 2
78712: ARRAY
78713: PPUSH
78714: LD_INT 2
78716: PUSH
78717: LD_INT 25
78719: PUSH
78720: LD_INT 5
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 25
78729: PUSH
78730: LD_INT 8
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 25
78739: PUSH
78740: LD_INT 9
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: PPUSH
78753: CALL_OW 72
78757: ST_TO_ADDR
// if not tmp then
78758: LD_VAR 0 4
78762: NOT
78763: IFFALSE 78767
// continue ;
78765: GO 78563
// for j in tmp do
78767: LD_ADDR_VAR 0 3
78771: PUSH
78772: LD_VAR 0 4
78776: PUSH
78777: FOR_IN
78778: IFFALSE 78849
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
78780: LD_VAR 0 3
78784: PPUSH
78785: CALL_OW 310
78789: PPUSH
78790: CALL_OW 266
78794: PUSH
78795: LD_INT 5
78797: EQUAL
78798: PUSH
78799: LD_VAR 0 3
78803: PPUSH
78804: CALL_OW 257
78808: PUSH
78809: LD_INT 1
78811: EQUAL
78812: AND
78813: PUSH
78814: LD_VAR 0 3
78818: PPUSH
78819: CALL_OW 459
78823: NOT
78824: AND
78825: PUSH
78826: LD_VAR 0 7
78830: AND
78831: IFFALSE 78847
// ComChangeProfession ( j , class ) ;
78833: LD_VAR 0 3
78837: PPUSH
78838: LD_VAR 0 7
78842: PPUSH
78843: CALL_OW 123
78847: GO 78777
78849: POP
78850: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
78851: LD_EXP 54
78855: PUSH
78856: LD_VAR 0 2
78860: ARRAY
78861: PUSH
78862: LD_EXP 74
78866: PUSH
78867: LD_VAR 0 2
78871: ARRAY
78872: NOT
78873: AND
78874: PUSH
78875: LD_EXP 53
78879: PUSH
78880: LD_VAR 0 2
78884: ARRAY
78885: NOT
78886: AND
78887: PUSH
78888: LD_EXP 31
78892: PUSH
78893: LD_VAR 0 2
78897: ARRAY
78898: PPUSH
78899: LD_INT 50
78901: PUSH
78902: EMPTY
78903: LIST
78904: PUSH
78905: LD_INT 2
78907: PUSH
78908: LD_INT 30
78910: PUSH
78911: LD_INT 32
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 30
78920: PUSH
78921: LD_INT 33
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 30
78930: PUSH
78931: LD_INT 4
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 30
78940: PUSH
78941: LD_INT 5
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: LIST
78952: LIST
78953: LIST
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PPUSH
78959: CALL_OW 72
78963: PUSH
78964: LD_INT 4
78966: LESS
78967: PUSH
78968: LD_EXP 31
78972: PUSH
78973: LD_VAR 0 2
78977: ARRAY
78978: PPUSH
78979: LD_INT 3
78981: PUSH
78982: LD_INT 24
78984: PUSH
78985: LD_INT 1000
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 2
78998: PUSH
78999: LD_INT 30
79001: PUSH
79002: LD_INT 0
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 30
79011: PUSH
79012: LD_INT 1
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: LIST
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PPUSH
79028: CALL_OW 72
79032: OR
79033: AND
79034: IFFALSE 79285
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
79036: LD_ADDR_EXP 74
79040: PUSH
79041: LD_EXP 74
79045: PPUSH
79046: LD_VAR 0 2
79050: PPUSH
79051: LD_INT 1
79053: PPUSH
79054: CALL_OW 1
79058: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79059: LD_ADDR_VAR 0 4
79063: PUSH
79064: LD_EXP 31
79068: PUSH
79069: LD_VAR 0 2
79073: ARRAY
79074: PPUSH
79075: LD_INT 2
79077: PUSH
79078: LD_INT 25
79080: PUSH
79081: LD_INT 1
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 25
79090: PUSH
79091: LD_INT 5
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 25
79100: PUSH
79101: LD_INT 8
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 25
79110: PUSH
79111: LD_INT 9
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: PPUSH
79125: CALL_OW 72
79129: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
79130: LD_ADDR_VAR 0 4
79134: PUSH
79135: LD_VAR 0 4
79139: PUSH
79140: LD_VAR 0 4
79144: PPUSH
79145: LD_INT 18
79147: PPUSH
79148: CALL 55099 0 2
79152: DIFF
79153: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
79154: LD_VAR 0 4
79158: NOT
79159: PUSH
79160: LD_EXP 31
79164: PUSH
79165: LD_VAR 0 2
79169: ARRAY
79170: PPUSH
79171: LD_INT 2
79173: PUSH
79174: LD_INT 30
79176: PUSH
79177: LD_INT 4
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 30
79186: PUSH
79187: LD_INT 5
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: LIST
79198: PPUSH
79199: CALL_OW 72
79203: NOT
79204: AND
79205: IFFALSE 79267
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
79207: LD_ADDR_VAR 0 4
79211: PUSH
79212: LD_EXP 31
79216: PUSH
79217: LD_VAR 0 2
79221: ARRAY
79222: PPUSH
79223: LD_INT 2
79225: PUSH
79226: LD_INT 25
79228: PUSH
79229: LD_INT 2
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 25
79238: PUSH
79239: LD_INT 3
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 25
79248: PUSH
79249: LD_INT 4
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: PPUSH
79262: CALL_OW 72
79266: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
79267: LD_VAR 0 2
79271: PPUSH
79272: LD_VAR 0 4
79276: PPUSH
79277: CALL 118740 0 2
// exit ;
79281: POP
79282: POP
79283: GO 79405
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
79285: LD_EXP 54
79289: PUSH
79290: LD_VAR 0 2
79294: ARRAY
79295: PUSH
79296: LD_EXP 74
79300: PUSH
79301: LD_VAR 0 2
79305: ARRAY
79306: NOT
79307: AND
79308: PUSH
79309: LD_EXP 53
79313: PUSH
79314: LD_VAR 0 2
79318: ARRAY
79319: AND
79320: IFFALSE 79401
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
79322: LD_ADDR_EXP 74
79326: PUSH
79327: LD_EXP 74
79331: PPUSH
79332: LD_VAR 0 2
79336: PPUSH
79337: LD_INT 1
79339: PPUSH
79340: CALL_OW 1
79344: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
79345: LD_ADDR_VAR 0 4
79349: PUSH
79350: LD_EXP 53
79354: PUSH
79355: LD_VAR 0 2
79359: ARRAY
79360: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
79361: LD_ADDR_EXP 53
79365: PUSH
79366: LD_EXP 53
79370: PPUSH
79371: LD_VAR 0 2
79375: PPUSH
79376: EMPTY
79377: PPUSH
79378: CALL_OW 1
79382: ST_TO_ADDR
// Defend ( i , tmp ) ;
79383: LD_VAR 0 2
79387: PPUSH
79388: LD_VAR 0 4
79392: PPUSH
79393: CALL 119336 0 2
// exit ;
79397: POP
79398: POP
79399: GO 79405
// end ; end ;
79401: GO 78563
79403: POP
79404: POP
// end ;
79405: LD_VAR 0 1
79409: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
79410: LD_INT 0
79412: PPUSH
79413: PPUSH
79414: PPUSH
79415: PPUSH
79416: PPUSH
79417: PPUSH
79418: PPUSH
79419: PPUSH
79420: PPUSH
79421: PPUSH
79422: PPUSH
// if not mc_bases then
79423: LD_EXP 31
79427: NOT
79428: IFFALSE 79432
// exit ;
79430: GO 80519
// for i = 1 to mc_bases do
79432: LD_ADDR_VAR 0 2
79436: PUSH
79437: DOUBLE
79438: LD_INT 1
79440: DEC
79441: ST_TO_ADDR
79442: LD_EXP 31
79446: PUSH
79447: FOR_TO
79448: IFFALSE 80517
// begin tmp := mc_lab [ i ] ;
79450: LD_ADDR_VAR 0 6
79454: PUSH
79455: LD_EXP 64
79459: PUSH
79460: LD_VAR 0 2
79464: ARRAY
79465: ST_TO_ADDR
// if not tmp then
79466: LD_VAR 0 6
79470: NOT
79471: IFFALSE 79475
// continue ;
79473: GO 79447
// idle_lab := 0 ;
79475: LD_ADDR_VAR 0 11
79479: PUSH
79480: LD_INT 0
79482: ST_TO_ADDR
// for j in tmp do
79483: LD_ADDR_VAR 0 3
79487: PUSH
79488: LD_VAR 0 6
79492: PUSH
79493: FOR_IN
79494: IFFALSE 80513
// begin researching := false ;
79496: LD_ADDR_VAR 0 10
79500: PUSH
79501: LD_INT 0
79503: ST_TO_ADDR
// side := GetSide ( j ) ;
79504: LD_ADDR_VAR 0 4
79508: PUSH
79509: LD_VAR 0 3
79513: PPUSH
79514: CALL_OW 255
79518: ST_TO_ADDR
// if not mc_tech [ side ] then
79519: LD_EXP 58
79523: PUSH
79524: LD_VAR 0 4
79528: ARRAY
79529: NOT
79530: IFFALSE 79534
// continue ;
79532: GO 79493
// if BuildingStatus ( j ) = bs_idle then
79534: LD_VAR 0 3
79538: PPUSH
79539: CALL_OW 461
79543: PUSH
79544: LD_INT 2
79546: EQUAL
79547: IFFALSE 79735
// begin if idle_lab and UnitsInside ( j ) < 6 then
79549: LD_VAR 0 11
79553: PUSH
79554: LD_VAR 0 3
79558: PPUSH
79559: CALL_OW 313
79563: PUSH
79564: LD_INT 6
79566: LESS
79567: AND
79568: IFFALSE 79639
// begin tmp2 := UnitsInside ( idle_lab ) ;
79570: LD_ADDR_VAR 0 9
79574: PUSH
79575: LD_VAR 0 11
79579: PPUSH
79580: CALL_OW 313
79584: ST_TO_ADDR
// if tmp2 then
79585: LD_VAR 0 9
79589: IFFALSE 79631
// for x in tmp2 do
79591: LD_ADDR_VAR 0 7
79595: PUSH
79596: LD_VAR 0 9
79600: PUSH
79601: FOR_IN
79602: IFFALSE 79629
// begin ComExitBuilding ( x ) ;
79604: LD_VAR 0 7
79608: PPUSH
79609: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79613: LD_VAR 0 7
79617: PPUSH
79618: LD_VAR 0 3
79622: PPUSH
79623: CALL_OW 180
// end ;
79627: GO 79601
79629: POP
79630: POP
// idle_lab := 0 ;
79631: LD_ADDR_VAR 0 11
79635: PUSH
79636: LD_INT 0
79638: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
79639: LD_ADDR_VAR 0 5
79643: PUSH
79644: LD_EXP 58
79648: PUSH
79649: LD_VAR 0 4
79653: ARRAY
79654: PUSH
79655: FOR_IN
79656: IFFALSE 79716
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
79658: LD_VAR 0 3
79662: PPUSH
79663: LD_VAR 0 5
79667: PPUSH
79668: CALL_OW 430
79672: PUSH
79673: LD_VAR 0 4
79677: PPUSH
79678: LD_VAR 0 5
79682: PPUSH
79683: CALL 20695 0 2
79687: AND
79688: IFFALSE 79714
// begin researching := true ;
79690: LD_ADDR_VAR 0 10
79694: PUSH
79695: LD_INT 1
79697: ST_TO_ADDR
// ComResearch ( j , t ) ;
79698: LD_VAR 0 3
79702: PPUSH
79703: LD_VAR 0 5
79707: PPUSH
79708: CALL_OW 124
// break ;
79712: GO 79716
// end ;
79714: GO 79655
79716: POP
79717: POP
// if not researching then
79718: LD_VAR 0 10
79722: NOT
79723: IFFALSE 79735
// idle_lab := j ;
79725: LD_ADDR_VAR 0 11
79729: PUSH
79730: LD_VAR 0 3
79734: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
79735: LD_VAR 0 3
79739: PPUSH
79740: CALL_OW 461
79744: PUSH
79745: LD_INT 10
79747: EQUAL
79748: IFFALSE 80336
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
79750: LD_EXP 60
79754: PUSH
79755: LD_VAR 0 2
79759: ARRAY
79760: NOT
79761: PUSH
79762: LD_EXP 61
79766: PUSH
79767: LD_VAR 0 2
79771: ARRAY
79772: NOT
79773: AND
79774: PUSH
79775: LD_EXP 58
79779: PUSH
79780: LD_VAR 0 4
79784: ARRAY
79785: PUSH
79786: LD_INT 1
79788: GREATER
79789: AND
79790: IFFALSE 79921
// begin ComCancel ( j ) ;
79792: LD_VAR 0 3
79796: PPUSH
79797: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
79801: LD_ADDR_EXP 58
79805: PUSH
79806: LD_EXP 58
79810: PPUSH
79811: LD_VAR 0 4
79815: PPUSH
79816: LD_EXP 58
79820: PUSH
79821: LD_VAR 0 4
79825: ARRAY
79826: PPUSH
79827: LD_EXP 58
79831: PUSH
79832: LD_VAR 0 4
79836: ARRAY
79837: PUSH
79838: LD_INT 1
79840: MINUS
79841: PPUSH
79842: LD_EXP 58
79846: PUSH
79847: LD_VAR 0 4
79851: ARRAY
79852: PPUSH
79853: LD_INT 0
79855: PPUSH
79856: CALL 24219 0 4
79860: PPUSH
79861: CALL_OW 1
79865: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
79866: LD_ADDR_EXP 58
79870: PUSH
79871: LD_EXP 58
79875: PPUSH
79876: LD_VAR 0 4
79880: PPUSH
79881: LD_EXP 58
79885: PUSH
79886: LD_VAR 0 4
79890: ARRAY
79891: PPUSH
79892: LD_EXP 58
79896: PUSH
79897: LD_VAR 0 4
79901: ARRAY
79902: PPUSH
79903: LD_INT 1
79905: PPUSH
79906: LD_INT 0
79908: PPUSH
79909: CALL 24219 0 4
79913: PPUSH
79914: CALL_OW 1
79918: ST_TO_ADDR
// continue ;
79919: GO 79493
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
79921: LD_EXP 60
79925: PUSH
79926: LD_VAR 0 2
79930: ARRAY
79931: PUSH
79932: LD_EXP 61
79936: PUSH
79937: LD_VAR 0 2
79941: ARRAY
79942: NOT
79943: AND
79944: IFFALSE 80071
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
79946: LD_ADDR_EXP 61
79950: PUSH
79951: LD_EXP 61
79955: PPUSH
79956: LD_VAR 0 2
79960: PUSH
79961: LD_EXP 61
79965: PUSH
79966: LD_VAR 0 2
79970: ARRAY
79971: PUSH
79972: LD_INT 1
79974: PLUS
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PPUSH
79980: LD_EXP 60
79984: PUSH
79985: LD_VAR 0 2
79989: ARRAY
79990: PUSH
79991: LD_INT 1
79993: ARRAY
79994: PPUSH
79995: CALL 24801 0 3
79999: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
80000: LD_EXP 60
80004: PUSH
80005: LD_VAR 0 2
80009: ARRAY
80010: PUSH
80011: LD_INT 1
80013: ARRAY
80014: PPUSH
80015: LD_INT 112
80017: PPUSH
80018: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
80022: LD_ADDR_VAR 0 9
80026: PUSH
80027: LD_EXP 60
80031: PUSH
80032: LD_VAR 0 2
80036: ARRAY
80037: PPUSH
80038: LD_INT 1
80040: PPUSH
80041: CALL_OW 3
80045: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
80046: LD_ADDR_EXP 60
80050: PUSH
80051: LD_EXP 60
80055: PPUSH
80056: LD_VAR 0 2
80060: PPUSH
80061: LD_VAR 0 9
80065: PPUSH
80066: CALL_OW 1
80070: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
80071: LD_EXP 60
80075: PUSH
80076: LD_VAR 0 2
80080: ARRAY
80081: PUSH
80082: LD_EXP 61
80086: PUSH
80087: LD_VAR 0 2
80091: ARRAY
80092: AND
80093: PUSH
80094: LD_EXP 61
80098: PUSH
80099: LD_VAR 0 2
80103: ARRAY
80104: PUSH
80105: LD_INT 1
80107: ARRAY
80108: PPUSH
80109: CALL_OW 310
80113: NOT
80114: AND
80115: PUSH
80116: LD_VAR 0 3
80120: PPUSH
80121: CALL_OW 313
80125: PUSH
80126: LD_INT 6
80128: EQUAL
80129: AND
80130: IFFALSE 80186
// begin tmp2 := UnitsInside ( j ) ;
80132: LD_ADDR_VAR 0 9
80136: PUSH
80137: LD_VAR 0 3
80141: PPUSH
80142: CALL_OW 313
80146: ST_TO_ADDR
// if tmp2 = 6 then
80147: LD_VAR 0 9
80151: PUSH
80152: LD_INT 6
80154: EQUAL
80155: IFFALSE 80186
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
80157: LD_VAR 0 9
80161: PUSH
80162: LD_INT 1
80164: ARRAY
80165: PPUSH
80166: LD_INT 112
80168: PPUSH
80169: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
80173: LD_VAR 0 9
80177: PUSH
80178: LD_INT 1
80180: ARRAY
80181: PPUSH
80182: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
80186: LD_EXP 61
80190: PUSH
80191: LD_VAR 0 2
80195: ARRAY
80196: PUSH
80197: LD_EXP 61
80201: PUSH
80202: LD_VAR 0 2
80206: ARRAY
80207: PUSH
80208: LD_INT 1
80210: ARRAY
80211: PPUSH
80212: CALL_OW 314
80216: NOT
80217: AND
80218: PUSH
80219: LD_EXP 61
80223: PUSH
80224: LD_VAR 0 2
80228: ARRAY
80229: PUSH
80230: LD_INT 1
80232: ARRAY
80233: PPUSH
80234: CALL_OW 310
80238: NOT
80239: AND
80240: IFFALSE 80266
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
80242: LD_EXP 61
80246: PUSH
80247: LD_VAR 0 2
80251: ARRAY
80252: PUSH
80253: LD_INT 1
80255: ARRAY
80256: PPUSH
80257: LD_VAR 0 3
80261: PPUSH
80262: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
80266: LD_EXP 61
80270: PUSH
80271: LD_VAR 0 2
80275: ARRAY
80276: PUSH
80277: LD_INT 1
80279: ARRAY
80280: PPUSH
80281: CALL_OW 310
80285: PUSH
80286: LD_EXP 61
80290: PUSH
80291: LD_VAR 0 2
80295: ARRAY
80296: PUSH
80297: LD_INT 1
80299: ARRAY
80300: PPUSH
80301: CALL_OW 310
80305: PPUSH
80306: CALL_OW 461
80310: PUSH
80311: LD_INT 3
80313: NONEQUAL
80314: AND
80315: IFFALSE 80336
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
80317: LD_EXP 61
80321: PUSH
80322: LD_VAR 0 2
80326: ARRAY
80327: PUSH
80328: LD_INT 1
80330: ARRAY
80331: PPUSH
80332: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
80336: LD_VAR 0 3
80340: PPUSH
80341: CALL_OW 461
80345: PUSH
80346: LD_INT 6
80348: EQUAL
80349: PUSH
80350: LD_VAR 0 6
80354: PUSH
80355: LD_INT 1
80357: GREATER
80358: AND
80359: IFFALSE 80511
// begin sci := [ ] ;
80361: LD_ADDR_VAR 0 8
80365: PUSH
80366: EMPTY
80367: ST_TO_ADDR
// for x in ( tmp diff j ) do
80368: LD_ADDR_VAR 0 7
80372: PUSH
80373: LD_VAR 0 6
80377: PUSH
80378: LD_VAR 0 3
80382: DIFF
80383: PUSH
80384: FOR_IN
80385: IFFALSE 80437
// begin if sci = 6 then
80387: LD_VAR 0 8
80391: PUSH
80392: LD_INT 6
80394: EQUAL
80395: IFFALSE 80399
// break ;
80397: GO 80437
// if BuildingStatus ( x ) = bs_idle then
80399: LD_VAR 0 7
80403: PPUSH
80404: CALL_OW 461
80408: PUSH
80409: LD_INT 2
80411: EQUAL
80412: IFFALSE 80435
// sci := sci ^ UnitsInside ( x ) ;
80414: LD_ADDR_VAR 0 8
80418: PUSH
80419: LD_VAR 0 8
80423: PUSH
80424: LD_VAR 0 7
80428: PPUSH
80429: CALL_OW 313
80433: ADD
80434: ST_TO_ADDR
// end ;
80435: GO 80384
80437: POP
80438: POP
// if not sci then
80439: LD_VAR 0 8
80443: NOT
80444: IFFALSE 80448
// continue ;
80446: GO 79493
// for x in sci do
80448: LD_ADDR_VAR 0 7
80452: PUSH
80453: LD_VAR 0 8
80457: PUSH
80458: FOR_IN
80459: IFFALSE 80509
// if IsInUnit ( x ) and not HasTask ( x ) then
80461: LD_VAR 0 7
80465: PPUSH
80466: CALL_OW 310
80470: PUSH
80471: LD_VAR 0 7
80475: PPUSH
80476: CALL_OW 314
80480: NOT
80481: AND
80482: IFFALSE 80507
// begin ComExitBuilding ( x ) ;
80484: LD_VAR 0 7
80488: PPUSH
80489: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
80493: LD_VAR 0 7
80497: PPUSH
80498: LD_VAR 0 3
80502: PPUSH
80503: CALL_OW 180
// end ;
80507: GO 80458
80509: POP
80510: POP
// end ; end ;
80511: GO 79493
80513: POP
80514: POP
// end ;
80515: GO 79447
80517: POP
80518: POP
// end ;
80519: LD_VAR 0 1
80523: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
80524: LD_INT 0
80526: PPUSH
80527: PPUSH
// if not mc_bases then
80528: LD_EXP 31
80532: NOT
80533: IFFALSE 80537
// exit ;
80535: GO 80618
// for i = 1 to mc_bases do
80537: LD_ADDR_VAR 0 2
80541: PUSH
80542: DOUBLE
80543: LD_INT 1
80545: DEC
80546: ST_TO_ADDR
80547: LD_EXP 31
80551: PUSH
80552: FOR_TO
80553: IFFALSE 80616
// if mc_mines [ i ] and mc_miners [ i ] then
80555: LD_EXP 44
80559: PUSH
80560: LD_VAR 0 2
80564: ARRAY
80565: PUSH
80566: LD_EXP 45
80570: PUSH
80571: LD_VAR 0 2
80575: ARRAY
80576: AND
80577: IFFALSE 80614
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
80579: LD_EXP 45
80583: PUSH
80584: LD_VAR 0 2
80588: ARRAY
80589: PUSH
80590: LD_INT 1
80592: ARRAY
80593: PPUSH
80594: CALL_OW 255
80598: PPUSH
80599: LD_EXP 44
80603: PUSH
80604: LD_VAR 0 2
80608: ARRAY
80609: PPUSH
80610: CALL 21778 0 2
80614: GO 80552
80616: POP
80617: POP
// end ;
80618: LD_VAR 0 1
80622: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
80623: LD_INT 0
80625: PPUSH
80626: PPUSH
80627: PPUSH
80628: PPUSH
80629: PPUSH
80630: PPUSH
80631: PPUSH
80632: PPUSH
// if not mc_bases or not mc_parking then
80633: LD_EXP 31
80637: NOT
80638: PUSH
80639: LD_EXP 55
80643: NOT
80644: OR
80645: IFFALSE 80649
// exit ;
80647: GO 81387
// for i = 1 to mc_bases do
80649: LD_ADDR_VAR 0 2
80653: PUSH
80654: DOUBLE
80655: LD_INT 1
80657: DEC
80658: ST_TO_ADDR
80659: LD_EXP 31
80663: PUSH
80664: FOR_TO
80665: IFFALSE 81385
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
80667: LD_EXP 31
80671: PUSH
80672: LD_VAR 0 2
80676: ARRAY
80677: NOT
80678: PUSH
80679: LD_EXP 55
80683: PUSH
80684: LD_VAR 0 2
80688: ARRAY
80689: NOT
80690: OR
80691: IFFALSE 80695
// continue ;
80693: GO 80664
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
80695: LD_ADDR_VAR 0 5
80699: PUSH
80700: LD_EXP 31
80704: PUSH
80705: LD_VAR 0 2
80709: ARRAY
80710: PUSH
80711: LD_INT 1
80713: ARRAY
80714: PPUSH
80715: CALL_OW 255
80719: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
80720: LD_ADDR_VAR 0 6
80724: PUSH
80725: LD_EXP 31
80729: PUSH
80730: LD_VAR 0 2
80734: ARRAY
80735: PPUSH
80736: LD_INT 30
80738: PUSH
80739: LD_INT 3
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PPUSH
80746: CALL_OW 72
80750: ST_TO_ADDR
// if not fac then
80751: LD_VAR 0 6
80755: NOT
80756: IFFALSE 80807
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80758: LD_ADDR_VAR 0 6
80762: PUSH
80763: LD_EXP 31
80767: PUSH
80768: LD_VAR 0 2
80772: ARRAY
80773: PPUSH
80774: LD_INT 2
80776: PUSH
80777: LD_INT 30
80779: PUSH
80780: LD_INT 0
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 30
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: LIST
80801: PPUSH
80802: CALL_OW 72
80806: ST_TO_ADDR
// if not fac then
80807: LD_VAR 0 6
80811: NOT
80812: IFFALSE 80816
// continue ;
80814: GO 80664
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
80816: LD_ADDR_VAR 0 7
80820: PUSH
80821: LD_EXP 55
80825: PUSH
80826: LD_VAR 0 2
80830: ARRAY
80831: PPUSH
80832: LD_INT 22
80834: PUSH
80835: LD_VAR 0 5
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: PUSH
80844: LD_INT 21
80846: PUSH
80847: LD_INT 2
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 3
80856: PUSH
80857: LD_INT 60
80859: PUSH
80860: EMPTY
80861: LIST
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 3
80869: PUSH
80870: LD_INT 24
80872: PUSH
80873: LD_INT 1000
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: PPUSH
80890: CALL_OW 70
80894: ST_TO_ADDR
// for j in fac do
80895: LD_ADDR_VAR 0 3
80899: PUSH
80900: LD_VAR 0 6
80904: PUSH
80905: FOR_IN
80906: IFFALSE 81001
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
80908: LD_ADDR_VAR 0 7
80912: PUSH
80913: LD_VAR 0 7
80917: PUSH
80918: LD_INT 22
80920: PUSH
80921: LD_VAR 0 5
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 91
80932: PUSH
80933: LD_VAR 0 3
80937: PUSH
80938: LD_INT 15
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 21
80948: PUSH
80949: LD_INT 2
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 3
80958: PUSH
80959: LD_INT 60
80961: PUSH
80962: EMPTY
80963: LIST
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 3
80971: PUSH
80972: LD_INT 24
80974: PUSH
80975: LD_INT 1000
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: PPUSH
80993: CALL_OW 69
80997: UNION
80998: ST_TO_ADDR
80999: GO 80905
81001: POP
81002: POP
// if not vehs then
81003: LD_VAR 0 7
81007: NOT
81008: IFFALSE 81034
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
81010: LD_ADDR_EXP 43
81014: PUSH
81015: LD_EXP 43
81019: PPUSH
81020: LD_VAR 0 2
81024: PPUSH
81025: EMPTY
81026: PPUSH
81027: CALL_OW 1
81031: ST_TO_ADDR
// continue ;
81032: GO 80664
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
81034: LD_ADDR_VAR 0 8
81038: PUSH
81039: LD_EXP 31
81043: PUSH
81044: LD_VAR 0 2
81048: ARRAY
81049: PPUSH
81050: LD_INT 30
81052: PUSH
81053: LD_INT 3
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PPUSH
81060: CALL_OW 72
81064: ST_TO_ADDR
// if tmp then
81065: LD_VAR 0 8
81069: IFFALSE 81172
// begin for j in tmp do
81071: LD_ADDR_VAR 0 3
81075: PUSH
81076: LD_VAR 0 8
81080: PUSH
81081: FOR_IN
81082: IFFALSE 81170
// for k in UnitsInside ( j ) do
81084: LD_ADDR_VAR 0 4
81088: PUSH
81089: LD_VAR 0 3
81093: PPUSH
81094: CALL_OW 313
81098: PUSH
81099: FOR_IN
81100: IFFALSE 81166
// if k then
81102: LD_VAR 0 4
81106: IFFALSE 81164
// if not k in mc_repair_vehicle [ i ] then
81108: LD_VAR 0 4
81112: PUSH
81113: LD_EXP 43
81117: PUSH
81118: LD_VAR 0 2
81122: ARRAY
81123: IN
81124: NOT
81125: IFFALSE 81164
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
81127: LD_ADDR_EXP 43
81131: PUSH
81132: LD_EXP 43
81136: PPUSH
81137: LD_VAR 0 2
81141: PPUSH
81142: LD_EXP 43
81146: PUSH
81147: LD_VAR 0 2
81151: ARRAY
81152: PUSH
81153: LD_VAR 0 4
81157: UNION
81158: PPUSH
81159: CALL_OW 1
81163: ST_TO_ADDR
81164: GO 81099
81166: POP
81167: POP
81168: GO 81081
81170: POP
81171: POP
// end ; if not mc_repair_vehicle [ i ] then
81172: LD_EXP 43
81176: PUSH
81177: LD_VAR 0 2
81181: ARRAY
81182: NOT
81183: IFFALSE 81187
// continue ;
81185: GO 80664
// for j in mc_repair_vehicle [ i ] do
81187: LD_ADDR_VAR 0 3
81191: PUSH
81192: LD_EXP 43
81196: PUSH
81197: LD_VAR 0 2
81201: ARRAY
81202: PUSH
81203: FOR_IN
81204: IFFALSE 81381
// begin if GetClass ( j ) <> 3 then
81206: LD_VAR 0 3
81210: PPUSH
81211: CALL_OW 257
81215: PUSH
81216: LD_INT 3
81218: NONEQUAL
81219: IFFALSE 81260
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
81221: LD_ADDR_EXP 43
81225: PUSH
81226: LD_EXP 43
81230: PPUSH
81231: LD_VAR 0 2
81235: PPUSH
81236: LD_EXP 43
81240: PUSH
81241: LD_VAR 0 2
81245: ARRAY
81246: PUSH
81247: LD_VAR 0 3
81251: DIFF
81252: PPUSH
81253: CALL_OW 1
81257: ST_TO_ADDR
// continue ;
81258: GO 81203
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81260: LD_VAR 0 3
81264: PPUSH
81265: CALL_OW 311
81269: NOT
81270: PUSH
81271: LD_VAR 0 3
81275: PUSH
81276: LD_EXP 34
81280: PUSH
81281: LD_VAR 0 2
81285: ARRAY
81286: PUSH
81287: LD_INT 1
81289: ARRAY
81290: IN
81291: NOT
81292: AND
81293: PUSH
81294: LD_VAR 0 3
81298: PUSH
81299: LD_EXP 34
81303: PUSH
81304: LD_VAR 0 2
81308: ARRAY
81309: PUSH
81310: LD_INT 2
81312: ARRAY
81313: IN
81314: NOT
81315: AND
81316: IFFALSE 81379
// begin if IsInUnit ( j ) then
81318: LD_VAR 0 3
81322: PPUSH
81323: CALL_OW 310
81327: IFFALSE 81340
// ComExitBuilding ( j ) else
81329: LD_VAR 0 3
81333: PPUSH
81334: CALL_OW 122
81338: GO 81379
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
81340: LD_VAR 0 3
81344: PPUSH
81345: LD_VAR 0 7
81349: PUSH
81350: LD_INT 1
81352: ARRAY
81353: PPUSH
81354: CALL 59595 0 2
81358: NOT
81359: IFFALSE 81379
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
81361: LD_VAR 0 3
81365: PPUSH
81366: LD_VAR 0 7
81370: PUSH
81371: LD_INT 1
81373: ARRAY
81374: PPUSH
81375: CALL_OW 129
// end ; end ;
81379: GO 81203
81381: POP
81382: POP
// end ;
81383: GO 80664
81385: POP
81386: POP
// end ;
81387: LD_VAR 0 1
81391: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
81392: LD_INT 0
81394: PPUSH
81395: PPUSH
81396: PPUSH
81397: PPUSH
81398: PPUSH
81399: PPUSH
81400: PPUSH
81401: PPUSH
81402: PPUSH
81403: PPUSH
81404: PPUSH
// if not mc_bases then
81405: LD_EXP 31
81409: NOT
81410: IFFALSE 81414
// exit ;
81412: GO 82216
// for i = 1 to mc_bases do
81414: LD_ADDR_VAR 0 2
81418: PUSH
81419: DOUBLE
81420: LD_INT 1
81422: DEC
81423: ST_TO_ADDR
81424: LD_EXP 31
81428: PUSH
81429: FOR_TO
81430: IFFALSE 82214
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
81432: LD_EXP 59
81436: PUSH
81437: LD_VAR 0 2
81441: ARRAY
81442: NOT
81443: PUSH
81444: LD_EXP 34
81448: PUSH
81449: LD_VAR 0 2
81453: ARRAY
81454: PUSH
81455: LD_INT 1
81457: ARRAY
81458: OR
81459: PUSH
81460: LD_EXP 34
81464: PUSH
81465: LD_VAR 0 2
81469: ARRAY
81470: PUSH
81471: LD_INT 2
81473: ARRAY
81474: OR
81475: PUSH
81476: LD_EXP 57
81480: PUSH
81481: LD_VAR 0 2
81485: ARRAY
81486: PPUSH
81487: LD_INT 1
81489: PPUSH
81490: CALL_OW 325
81494: NOT
81495: OR
81496: PUSH
81497: LD_EXP 54
81501: PUSH
81502: LD_VAR 0 2
81506: ARRAY
81507: OR
81508: IFFALSE 81512
// continue ;
81510: GO 81429
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
81512: LD_ADDR_VAR 0 8
81516: PUSH
81517: LD_EXP 31
81521: PUSH
81522: LD_VAR 0 2
81526: ARRAY
81527: PPUSH
81528: LD_INT 25
81530: PUSH
81531: LD_INT 4
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 50
81540: PUSH
81541: EMPTY
81542: LIST
81543: PUSH
81544: LD_INT 3
81546: PUSH
81547: LD_INT 60
81549: PUSH
81550: EMPTY
81551: LIST
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: LIST
81561: PPUSH
81562: CALL_OW 72
81566: PUSH
81567: LD_EXP 35
81571: PUSH
81572: LD_VAR 0 2
81576: ARRAY
81577: DIFF
81578: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81579: LD_ADDR_VAR 0 9
81583: PUSH
81584: LD_EXP 31
81588: PUSH
81589: LD_VAR 0 2
81593: ARRAY
81594: PPUSH
81595: LD_INT 2
81597: PUSH
81598: LD_INT 30
81600: PUSH
81601: LD_INT 0
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 30
81610: PUSH
81611: LD_INT 1
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: LIST
81622: PPUSH
81623: CALL_OW 72
81627: ST_TO_ADDR
// if not tmp or not dep then
81628: LD_VAR 0 8
81632: NOT
81633: PUSH
81634: LD_VAR 0 9
81638: NOT
81639: OR
81640: IFFALSE 81644
// continue ;
81642: GO 81429
// side := GetSide ( tmp [ 1 ] ) ;
81644: LD_ADDR_VAR 0 11
81648: PUSH
81649: LD_VAR 0 8
81653: PUSH
81654: LD_INT 1
81656: ARRAY
81657: PPUSH
81658: CALL_OW 255
81662: ST_TO_ADDR
// dep := dep [ 1 ] ;
81663: LD_ADDR_VAR 0 9
81667: PUSH
81668: LD_VAR 0 9
81672: PUSH
81673: LD_INT 1
81675: ARRAY
81676: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
81677: LD_ADDR_VAR 0 7
81681: PUSH
81682: LD_EXP 59
81686: PUSH
81687: LD_VAR 0 2
81691: ARRAY
81692: PPUSH
81693: LD_INT 22
81695: PUSH
81696: LD_INT 0
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_INT 25
81705: PUSH
81706: LD_INT 12
81708: PUSH
81709: EMPTY
81710: LIST
81711: LIST
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PPUSH
81717: CALL_OW 70
81721: PUSH
81722: LD_INT 22
81724: PUSH
81725: LD_INT 0
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 25
81734: PUSH
81735: LD_INT 12
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 91
81744: PUSH
81745: LD_VAR 0 9
81749: PUSH
81750: LD_INT 20
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: LIST
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: LIST
81762: PPUSH
81763: CALL_OW 69
81767: UNION
81768: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
81769: LD_ADDR_VAR 0 10
81773: PUSH
81774: LD_EXP 59
81778: PUSH
81779: LD_VAR 0 2
81783: ARRAY
81784: PPUSH
81785: LD_INT 81
81787: PUSH
81788: LD_VAR 0 11
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PPUSH
81797: CALL_OW 70
81801: ST_TO_ADDR
// if not apes or danger_at_area then
81802: LD_VAR 0 7
81806: NOT
81807: PUSH
81808: LD_VAR 0 10
81812: OR
81813: IFFALSE 81863
// begin if mc_taming [ i ] then
81815: LD_EXP 62
81819: PUSH
81820: LD_VAR 0 2
81824: ARRAY
81825: IFFALSE 81861
// begin MC_Reset ( i , 121 ) ;
81827: LD_VAR 0 2
81831: PPUSH
81832: LD_INT 121
81834: PPUSH
81835: CALL 66779 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
81839: LD_ADDR_EXP 62
81843: PUSH
81844: LD_EXP 62
81848: PPUSH
81849: LD_VAR 0 2
81853: PPUSH
81854: EMPTY
81855: PPUSH
81856: CALL_OW 1
81860: ST_TO_ADDR
// end ; continue ;
81861: GO 81429
// end ; for j in tmp do
81863: LD_ADDR_VAR 0 3
81867: PUSH
81868: LD_VAR 0 8
81872: PUSH
81873: FOR_IN
81874: IFFALSE 82210
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
81876: LD_VAR 0 3
81880: PUSH
81881: LD_EXP 62
81885: PUSH
81886: LD_VAR 0 2
81890: ARRAY
81891: IN
81892: NOT
81893: PUSH
81894: LD_EXP 62
81898: PUSH
81899: LD_VAR 0 2
81903: ARRAY
81904: PUSH
81905: LD_INT 3
81907: LESS
81908: AND
81909: IFFALSE 81967
// begin SetTag ( j , 121 ) ;
81911: LD_VAR 0 3
81915: PPUSH
81916: LD_INT 121
81918: PPUSH
81919: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
81923: LD_ADDR_EXP 62
81927: PUSH
81928: LD_EXP 62
81932: PPUSH
81933: LD_VAR 0 2
81937: PUSH
81938: LD_EXP 62
81942: PUSH
81943: LD_VAR 0 2
81947: ARRAY
81948: PUSH
81949: LD_INT 1
81951: PLUS
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PPUSH
81957: LD_VAR 0 3
81961: PPUSH
81962: CALL 24801 0 3
81966: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
81967: LD_VAR 0 3
81971: PUSH
81972: LD_EXP 62
81976: PUSH
81977: LD_VAR 0 2
81981: ARRAY
81982: IN
81983: IFFALSE 82208
// begin if GetClass ( j ) <> 4 then
81985: LD_VAR 0 3
81989: PPUSH
81990: CALL_OW 257
81994: PUSH
81995: LD_INT 4
81997: NONEQUAL
81998: IFFALSE 82051
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
82000: LD_ADDR_EXP 62
82004: PUSH
82005: LD_EXP 62
82009: PPUSH
82010: LD_VAR 0 2
82014: PPUSH
82015: LD_EXP 62
82019: PUSH
82020: LD_VAR 0 2
82024: ARRAY
82025: PUSH
82026: LD_VAR 0 3
82030: DIFF
82031: PPUSH
82032: CALL_OW 1
82036: ST_TO_ADDR
// SetTag ( j , 0 ) ;
82037: LD_VAR 0 3
82041: PPUSH
82042: LD_INT 0
82044: PPUSH
82045: CALL_OW 109
// continue ;
82049: GO 81873
// end ; if IsInUnit ( j ) then
82051: LD_VAR 0 3
82055: PPUSH
82056: CALL_OW 310
82060: IFFALSE 82071
// ComExitBuilding ( j ) ;
82062: LD_VAR 0 3
82066: PPUSH
82067: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
82071: LD_ADDR_VAR 0 6
82075: PUSH
82076: LD_VAR 0 7
82080: PPUSH
82081: LD_VAR 0 3
82085: PPUSH
82086: CALL_OW 74
82090: ST_TO_ADDR
// if not ape then
82091: LD_VAR 0 6
82095: NOT
82096: IFFALSE 82100
// break ;
82098: GO 82210
// x := GetX ( ape ) ;
82100: LD_ADDR_VAR 0 4
82104: PUSH
82105: LD_VAR 0 6
82109: PPUSH
82110: CALL_OW 250
82114: ST_TO_ADDR
// y := GetY ( ape ) ;
82115: LD_ADDR_VAR 0 5
82119: PUSH
82120: LD_VAR 0 6
82124: PPUSH
82125: CALL_OW 251
82129: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
82130: LD_VAR 0 4
82134: PPUSH
82135: LD_VAR 0 5
82139: PPUSH
82140: CALL_OW 488
82144: NOT
82145: PUSH
82146: LD_VAR 0 11
82150: PPUSH
82151: LD_VAR 0 4
82155: PPUSH
82156: LD_VAR 0 5
82160: PPUSH
82161: LD_INT 20
82163: PPUSH
82164: CALL 26065 0 4
82168: PUSH
82169: LD_INT 4
82171: ARRAY
82172: OR
82173: IFFALSE 82177
// break ;
82175: GO 82210
// if not HasTask ( j ) then
82177: LD_VAR 0 3
82181: PPUSH
82182: CALL_OW 314
82186: NOT
82187: IFFALSE 82208
// ComTameXY ( j , x , y ) ;
82189: LD_VAR 0 3
82193: PPUSH
82194: LD_VAR 0 4
82198: PPUSH
82199: LD_VAR 0 5
82203: PPUSH
82204: CALL_OW 131
// end ; end ;
82208: GO 81873
82210: POP
82211: POP
// end ;
82212: GO 81429
82214: POP
82215: POP
// end ;
82216: LD_VAR 0 1
82220: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
82221: LD_INT 0
82223: PPUSH
82224: PPUSH
82225: PPUSH
82226: PPUSH
82227: PPUSH
82228: PPUSH
82229: PPUSH
82230: PPUSH
// if not mc_bases then
82231: LD_EXP 31
82235: NOT
82236: IFFALSE 82240
// exit ;
82238: GO 82866
// for i = 1 to mc_bases do
82240: LD_ADDR_VAR 0 2
82244: PUSH
82245: DOUBLE
82246: LD_INT 1
82248: DEC
82249: ST_TO_ADDR
82250: LD_EXP 31
82254: PUSH
82255: FOR_TO
82256: IFFALSE 82864
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
82258: LD_EXP 60
82262: PUSH
82263: LD_VAR 0 2
82267: ARRAY
82268: NOT
82269: PUSH
82270: LD_EXP 60
82274: PUSH
82275: LD_VAR 0 2
82279: ARRAY
82280: PPUSH
82281: LD_INT 25
82283: PUSH
82284: LD_INT 12
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PPUSH
82291: CALL_OW 72
82295: NOT
82296: OR
82297: IFFALSE 82301
// continue ;
82299: GO 82255
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
82301: LD_ADDR_VAR 0 5
82305: PUSH
82306: LD_EXP 60
82310: PUSH
82311: LD_VAR 0 2
82315: ARRAY
82316: PUSH
82317: LD_INT 1
82319: ARRAY
82320: PPUSH
82321: CALL_OW 255
82325: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
82326: LD_VAR 0 5
82330: PPUSH
82331: LD_INT 2
82333: PPUSH
82334: CALL_OW 325
82338: IFFALSE 82591
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
82340: LD_ADDR_VAR 0 4
82344: PUSH
82345: LD_EXP 60
82349: PUSH
82350: LD_VAR 0 2
82354: ARRAY
82355: PPUSH
82356: LD_INT 25
82358: PUSH
82359: LD_INT 16
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PPUSH
82366: CALL_OW 72
82370: ST_TO_ADDR
// if tmp < 6 then
82371: LD_VAR 0 4
82375: PUSH
82376: LD_INT 6
82378: LESS
82379: IFFALSE 82591
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82381: LD_ADDR_VAR 0 6
82385: PUSH
82386: LD_EXP 31
82390: PUSH
82391: LD_VAR 0 2
82395: ARRAY
82396: PPUSH
82397: LD_INT 2
82399: PUSH
82400: LD_INT 30
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 30
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: LIST
82424: PPUSH
82425: CALL_OW 72
82429: ST_TO_ADDR
// if depot then
82430: LD_VAR 0 6
82434: IFFALSE 82591
// begin selected := 0 ;
82436: LD_ADDR_VAR 0 7
82440: PUSH
82441: LD_INT 0
82443: ST_TO_ADDR
// for j in depot do
82444: LD_ADDR_VAR 0 3
82448: PUSH
82449: LD_VAR 0 6
82453: PUSH
82454: FOR_IN
82455: IFFALSE 82486
// begin if UnitsInside ( j ) < 6 then
82457: LD_VAR 0 3
82461: PPUSH
82462: CALL_OW 313
82466: PUSH
82467: LD_INT 6
82469: LESS
82470: IFFALSE 82484
// begin selected := j ;
82472: LD_ADDR_VAR 0 7
82476: PUSH
82477: LD_VAR 0 3
82481: ST_TO_ADDR
// break ;
82482: GO 82486
// end ; end ;
82484: GO 82454
82486: POP
82487: POP
// if selected then
82488: LD_VAR 0 7
82492: IFFALSE 82591
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
82494: LD_ADDR_VAR 0 3
82498: PUSH
82499: LD_EXP 60
82503: PUSH
82504: LD_VAR 0 2
82508: ARRAY
82509: PPUSH
82510: LD_INT 25
82512: PUSH
82513: LD_INT 12
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PPUSH
82520: CALL_OW 72
82524: PUSH
82525: FOR_IN
82526: IFFALSE 82589
// if not HasTask ( j ) then
82528: LD_VAR 0 3
82532: PPUSH
82533: CALL_OW 314
82537: NOT
82538: IFFALSE 82587
// begin if not IsInUnit ( j ) then
82540: LD_VAR 0 3
82544: PPUSH
82545: CALL_OW 310
82549: NOT
82550: IFFALSE 82566
// ComEnterUnit ( j , selected ) ;
82552: LD_VAR 0 3
82556: PPUSH
82557: LD_VAR 0 7
82561: PPUSH
82562: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
82566: LD_VAR 0 3
82570: PPUSH
82571: LD_INT 16
82573: PPUSH
82574: CALL_OW 183
// AddComExitBuilding ( j ) ;
82578: LD_VAR 0 3
82582: PPUSH
82583: CALL_OW 182
// end ;
82587: GO 82525
82589: POP
82590: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
82591: LD_VAR 0 5
82595: PPUSH
82596: LD_INT 11
82598: PPUSH
82599: CALL_OW 325
82603: IFFALSE 82862
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
82605: LD_ADDR_VAR 0 4
82609: PUSH
82610: LD_EXP 60
82614: PUSH
82615: LD_VAR 0 2
82619: ARRAY
82620: PPUSH
82621: LD_INT 25
82623: PUSH
82624: LD_INT 16
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PPUSH
82631: CALL_OW 72
82635: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
82636: LD_VAR 0 4
82640: PUSH
82641: LD_INT 6
82643: GREATEREQUAL
82644: PUSH
82645: LD_VAR 0 5
82649: PPUSH
82650: LD_INT 2
82652: PPUSH
82653: CALL_OW 325
82657: NOT
82658: OR
82659: IFFALSE 82862
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82661: LD_ADDR_VAR 0 8
82665: PUSH
82666: LD_EXP 31
82670: PUSH
82671: LD_VAR 0 2
82675: ARRAY
82676: PPUSH
82677: LD_INT 2
82679: PUSH
82680: LD_INT 30
82682: PUSH
82683: LD_INT 4
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 30
82692: PUSH
82693: LD_INT 5
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: LIST
82704: PPUSH
82705: CALL_OW 72
82709: ST_TO_ADDR
// if barracks then
82710: LD_VAR 0 8
82714: IFFALSE 82862
// begin selected := 0 ;
82716: LD_ADDR_VAR 0 7
82720: PUSH
82721: LD_INT 0
82723: ST_TO_ADDR
// for j in barracks do
82724: LD_ADDR_VAR 0 3
82728: PUSH
82729: LD_VAR 0 8
82733: PUSH
82734: FOR_IN
82735: IFFALSE 82766
// begin if UnitsInside ( j ) < 6 then
82737: LD_VAR 0 3
82741: PPUSH
82742: CALL_OW 313
82746: PUSH
82747: LD_INT 6
82749: LESS
82750: IFFALSE 82764
// begin selected := j ;
82752: LD_ADDR_VAR 0 7
82756: PUSH
82757: LD_VAR 0 3
82761: ST_TO_ADDR
// break ;
82762: GO 82766
// end ; end ;
82764: GO 82734
82766: POP
82767: POP
// if selected then
82768: LD_VAR 0 7
82772: IFFALSE 82862
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
82774: LD_ADDR_VAR 0 3
82778: PUSH
82779: LD_EXP 60
82783: PUSH
82784: LD_VAR 0 2
82788: ARRAY
82789: PPUSH
82790: LD_INT 25
82792: PUSH
82793: LD_INT 12
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PPUSH
82800: CALL_OW 72
82804: PUSH
82805: FOR_IN
82806: IFFALSE 82860
// if not IsInUnit ( j ) and not HasTask ( j ) then
82808: LD_VAR 0 3
82812: PPUSH
82813: CALL_OW 310
82817: NOT
82818: PUSH
82819: LD_VAR 0 3
82823: PPUSH
82824: CALL_OW 314
82828: NOT
82829: AND
82830: IFFALSE 82858
// begin ComEnterUnit ( j , selected ) ;
82832: LD_VAR 0 3
82836: PPUSH
82837: LD_VAR 0 7
82841: PPUSH
82842: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
82846: LD_VAR 0 3
82850: PPUSH
82851: LD_INT 15
82853: PPUSH
82854: CALL_OW 183
// end ;
82858: GO 82805
82860: POP
82861: POP
// end ; end ; end ; end ; end ;
82862: GO 82255
82864: POP
82865: POP
// end ;
82866: LD_VAR 0 1
82870: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
82871: LD_INT 0
82873: PPUSH
82874: PPUSH
82875: PPUSH
82876: PPUSH
// if not mc_bases then
82877: LD_EXP 31
82881: NOT
82882: IFFALSE 82886
// exit ;
82884: GO 83064
// for i = 1 to mc_bases do
82886: LD_ADDR_VAR 0 2
82890: PUSH
82891: DOUBLE
82892: LD_INT 1
82894: DEC
82895: ST_TO_ADDR
82896: LD_EXP 31
82900: PUSH
82901: FOR_TO
82902: IFFALSE 83062
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
82904: LD_ADDR_VAR 0 4
82908: PUSH
82909: LD_EXP 31
82913: PUSH
82914: LD_VAR 0 2
82918: ARRAY
82919: PPUSH
82920: LD_INT 25
82922: PUSH
82923: LD_INT 9
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PPUSH
82930: CALL_OW 72
82934: ST_TO_ADDR
// if not tmp then
82935: LD_VAR 0 4
82939: NOT
82940: IFFALSE 82944
// continue ;
82942: GO 82901
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
82944: LD_EXP 57
82948: PUSH
82949: LD_VAR 0 2
82953: ARRAY
82954: PPUSH
82955: LD_INT 29
82957: PPUSH
82958: CALL_OW 325
82962: NOT
82963: PUSH
82964: LD_EXP 57
82968: PUSH
82969: LD_VAR 0 2
82973: ARRAY
82974: PPUSH
82975: LD_INT 28
82977: PPUSH
82978: CALL_OW 325
82982: NOT
82983: AND
82984: IFFALSE 82988
// continue ;
82986: GO 82901
// for j in tmp do
82988: LD_ADDR_VAR 0 3
82992: PUSH
82993: LD_VAR 0 4
82997: PUSH
82998: FOR_IN
82999: IFFALSE 83058
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
83001: LD_VAR 0 3
83005: PUSH
83006: LD_EXP 34
83010: PUSH
83011: LD_VAR 0 2
83015: ARRAY
83016: PUSH
83017: LD_INT 1
83019: ARRAY
83020: IN
83021: NOT
83022: PUSH
83023: LD_VAR 0 3
83027: PUSH
83028: LD_EXP 34
83032: PUSH
83033: LD_VAR 0 2
83037: ARRAY
83038: PUSH
83039: LD_INT 2
83041: ARRAY
83042: IN
83043: NOT
83044: AND
83045: IFFALSE 83056
// ComSpaceTimeShoot ( j ) ;
83047: LD_VAR 0 3
83051: PPUSH
83052: CALL 20786 0 1
83056: GO 82998
83058: POP
83059: POP
// end ;
83060: GO 82901
83062: POP
83063: POP
// end ;
83064: LD_VAR 0 1
83068: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
83069: LD_INT 0
83071: PPUSH
83072: PPUSH
83073: PPUSH
83074: PPUSH
83075: PPUSH
83076: PPUSH
83077: PPUSH
83078: PPUSH
83079: PPUSH
// if not mc_bases then
83080: LD_EXP 31
83084: NOT
83085: IFFALSE 83089
// exit ;
83087: GO 83711
// for i = 1 to mc_bases do
83089: LD_ADDR_VAR 0 2
83093: PUSH
83094: DOUBLE
83095: LD_INT 1
83097: DEC
83098: ST_TO_ADDR
83099: LD_EXP 31
83103: PUSH
83104: FOR_TO
83105: IFFALSE 83709
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
83107: LD_EXP 66
83111: PUSH
83112: LD_VAR 0 2
83116: ARRAY
83117: NOT
83118: PUSH
83119: LD_INT 38
83121: PPUSH
83122: LD_EXP 57
83126: PUSH
83127: LD_VAR 0 2
83131: ARRAY
83132: PPUSH
83133: CALL_OW 321
83137: PUSH
83138: LD_INT 2
83140: NONEQUAL
83141: OR
83142: IFFALSE 83146
// continue ;
83144: GO 83104
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
83146: LD_ADDR_VAR 0 8
83150: PUSH
83151: LD_EXP 31
83155: PUSH
83156: LD_VAR 0 2
83160: ARRAY
83161: PPUSH
83162: LD_INT 30
83164: PUSH
83165: LD_INT 34
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PPUSH
83172: CALL_OW 72
83176: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
83177: LD_ADDR_VAR 0 9
83181: PUSH
83182: LD_EXP 31
83186: PUSH
83187: LD_VAR 0 2
83191: ARRAY
83192: PPUSH
83193: LD_INT 25
83195: PUSH
83196: LD_INT 4
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PPUSH
83203: CALL_OW 72
83207: PPUSH
83208: LD_INT 0
83210: PPUSH
83211: CALL 55099 0 2
83215: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
83216: LD_VAR 0 9
83220: NOT
83221: PUSH
83222: LD_VAR 0 8
83226: NOT
83227: OR
83228: PUSH
83229: LD_EXP 31
83233: PUSH
83234: LD_VAR 0 2
83238: ARRAY
83239: PPUSH
83240: LD_INT 124
83242: PPUSH
83243: CALL 55099 0 2
83247: OR
83248: IFFALSE 83252
// continue ;
83250: GO 83104
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
83252: LD_EXP 67
83256: PUSH
83257: LD_VAR 0 2
83261: ARRAY
83262: PUSH
83263: LD_EXP 66
83267: PUSH
83268: LD_VAR 0 2
83272: ARRAY
83273: LESS
83274: PUSH
83275: LD_EXP 67
83279: PUSH
83280: LD_VAR 0 2
83284: ARRAY
83285: PUSH
83286: LD_VAR 0 8
83290: LESS
83291: AND
83292: IFFALSE 83707
// begin tmp := sci [ 1 ] ;
83294: LD_ADDR_VAR 0 7
83298: PUSH
83299: LD_VAR 0 9
83303: PUSH
83304: LD_INT 1
83306: ARRAY
83307: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
83308: LD_VAR 0 7
83312: PPUSH
83313: LD_INT 124
83315: PPUSH
83316: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
83320: LD_ADDR_VAR 0 3
83324: PUSH
83325: DOUBLE
83326: LD_EXP 66
83330: PUSH
83331: LD_VAR 0 2
83335: ARRAY
83336: INC
83337: ST_TO_ADDR
83338: LD_EXP 66
83342: PUSH
83343: LD_VAR 0 2
83347: ARRAY
83348: PUSH
83349: FOR_DOWNTO
83350: IFFALSE 83693
// begin if IsInUnit ( tmp ) then
83352: LD_VAR 0 7
83356: PPUSH
83357: CALL_OW 310
83361: IFFALSE 83372
// ComExitBuilding ( tmp ) ;
83363: LD_VAR 0 7
83367: PPUSH
83368: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
83372: LD_INT 35
83374: PPUSH
83375: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
83379: LD_VAR 0 7
83383: PPUSH
83384: CALL_OW 310
83388: NOT
83389: PUSH
83390: LD_VAR 0 7
83394: PPUSH
83395: CALL_OW 314
83399: NOT
83400: AND
83401: IFFALSE 83372
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
83403: LD_ADDR_VAR 0 6
83407: PUSH
83408: LD_VAR 0 7
83412: PPUSH
83413: CALL_OW 250
83417: PUSH
83418: LD_VAR 0 7
83422: PPUSH
83423: CALL_OW 251
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
83432: LD_INT 35
83434: PPUSH
83435: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
83439: LD_ADDR_VAR 0 4
83443: PUSH
83444: LD_EXP 66
83448: PUSH
83449: LD_VAR 0 2
83453: ARRAY
83454: PUSH
83455: LD_VAR 0 3
83459: ARRAY
83460: PUSH
83461: LD_INT 1
83463: ARRAY
83464: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
83465: LD_ADDR_VAR 0 5
83469: PUSH
83470: LD_EXP 66
83474: PUSH
83475: LD_VAR 0 2
83479: ARRAY
83480: PUSH
83481: LD_VAR 0 3
83485: ARRAY
83486: PUSH
83487: LD_INT 2
83489: ARRAY
83490: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
83491: LD_VAR 0 7
83495: PPUSH
83496: LD_INT 10
83498: PPUSH
83499: CALL 27766 0 2
83503: PUSH
83504: LD_INT 4
83506: ARRAY
83507: IFFALSE 83545
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
83509: LD_VAR 0 7
83513: PPUSH
83514: LD_VAR 0 6
83518: PUSH
83519: LD_INT 1
83521: ARRAY
83522: PPUSH
83523: LD_VAR 0 6
83527: PUSH
83528: LD_INT 2
83530: ARRAY
83531: PPUSH
83532: CALL_OW 111
// wait ( 0 0$10 ) ;
83536: LD_INT 350
83538: PPUSH
83539: CALL_OW 67
// end else
83543: GO 83571
// begin ComMoveXY ( tmp , x , y ) ;
83545: LD_VAR 0 7
83549: PPUSH
83550: LD_VAR 0 4
83554: PPUSH
83555: LD_VAR 0 5
83559: PPUSH
83560: CALL_OW 111
// wait ( 0 0$3 ) ;
83564: LD_INT 105
83566: PPUSH
83567: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
83571: LD_VAR 0 7
83575: PPUSH
83576: LD_VAR 0 4
83580: PPUSH
83581: LD_VAR 0 5
83585: PPUSH
83586: CALL_OW 307
83590: IFFALSE 83432
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
83592: LD_VAR 0 7
83596: PPUSH
83597: LD_VAR 0 4
83601: PPUSH
83602: LD_VAR 0 5
83606: PPUSH
83607: LD_VAR 0 8
83611: PUSH
83612: LD_VAR 0 3
83616: ARRAY
83617: PPUSH
83618: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
83622: LD_INT 35
83624: PPUSH
83625: CALL_OW 67
// until not HasTask ( tmp ) ;
83629: LD_VAR 0 7
83633: PPUSH
83634: CALL_OW 314
83638: NOT
83639: IFFALSE 83622
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
83641: LD_ADDR_EXP 67
83645: PUSH
83646: LD_EXP 67
83650: PPUSH
83651: LD_VAR 0 2
83655: PUSH
83656: LD_EXP 67
83660: PUSH
83661: LD_VAR 0 2
83665: ARRAY
83666: PUSH
83667: LD_INT 1
83669: PLUS
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PPUSH
83675: LD_VAR 0 8
83679: PUSH
83680: LD_VAR 0 3
83684: ARRAY
83685: PPUSH
83686: CALL 24801 0 3
83690: ST_TO_ADDR
// end ;
83691: GO 83349
83693: POP
83694: POP
// MC_Reset ( i , 124 ) ;
83695: LD_VAR 0 2
83699: PPUSH
83700: LD_INT 124
83702: PPUSH
83703: CALL 66779 0 2
// end ; end ;
83707: GO 83104
83709: POP
83710: POP
// end ;
83711: LD_VAR 0 1
83715: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
83716: LD_INT 0
83718: PPUSH
83719: PPUSH
83720: PPUSH
// if not mc_bases then
83721: LD_EXP 31
83725: NOT
83726: IFFALSE 83730
// exit ;
83728: GO 84336
// for i = 1 to mc_bases do
83730: LD_ADDR_VAR 0 2
83734: PUSH
83735: DOUBLE
83736: LD_INT 1
83738: DEC
83739: ST_TO_ADDR
83740: LD_EXP 31
83744: PUSH
83745: FOR_TO
83746: IFFALSE 84334
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
83748: LD_ADDR_VAR 0 3
83752: PUSH
83753: LD_EXP 31
83757: PUSH
83758: LD_VAR 0 2
83762: ARRAY
83763: PPUSH
83764: LD_INT 25
83766: PUSH
83767: LD_INT 4
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PPUSH
83774: CALL_OW 72
83778: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83779: LD_VAR 0 3
83783: NOT
83784: PUSH
83785: LD_EXP 68
83789: PUSH
83790: LD_VAR 0 2
83794: ARRAY
83795: NOT
83796: OR
83797: PUSH
83798: LD_EXP 31
83802: PUSH
83803: LD_VAR 0 2
83807: ARRAY
83808: PPUSH
83809: LD_INT 2
83811: PUSH
83812: LD_INT 30
83814: PUSH
83815: LD_INT 0
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 30
83824: PUSH
83825: LD_INT 1
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: LIST
83836: PPUSH
83837: CALL_OW 72
83841: NOT
83842: OR
83843: IFFALSE 83893
// begin if mc_deposits_finder [ i ] then
83845: LD_EXP 69
83849: PUSH
83850: LD_VAR 0 2
83854: ARRAY
83855: IFFALSE 83891
// begin MC_Reset ( i , 125 ) ;
83857: LD_VAR 0 2
83861: PPUSH
83862: LD_INT 125
83864: PPUSH
83865: CALL 66779 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
83869: LD_ADDR_EXP 69
83873: PUSH
83874: LD_EXP 69
83878: PPUSH
83879: LD_VAR 0 2
83883: PPUSH
83884: EMPTY
83885: PPUSH
83886: CALL_OW 1
83890: ST_TO_ADDR
// end ; continue ;
83891: GO 83745
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
83893: LD_EXP 68
83897: PUSH
83898: LD_VAR 0 2
83902: ARRAY
83903: PUSH
83904: LD_INT 1
83906: ARRAY
83907: PUSH
83908: LD_INT 3
83910: ARRAY
83911: PUSH
83912: LD_INT 1
83914: EQUAL
83915: PUSH
83916: LD_INT 20
83918: PPUSH
83919: LD_EXP 57
83923: PUSH
83924: LD_VAR 0 2
83928: ARRAY
83929: PPUSH
83930: CALL_OW 321
83934: PUSH
83935: LD_INT 2
83937: NONEQUAL
83938: AND
83939: IFFALSE 83989
// begin if mc_deposits_finder [ i ] then
83941: LD_EXP 69
83945: PUSH
83946: LD_VAR 0 2
83950: ARRAY
83951: IFFALSE 83987
// begin MC_Reset ( i , 125 ) ;
83953: LD_VAR 0 2
83957: PPUSH
83958: LD_INT 125
83960: PPUSH
83961: CALL 66779 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
83965: LD_ADDR_EXP 69
83969: PUSH
83970: LD_EXP 69
83974: PPUSH
83975: LD_VAR 0 2
83979: PPUSH
83980: EMPTY
83981: PPUSH
83982: CALL_OW 1
83986: ST_TO_ADDR
// end ; continue ;
83987: GO 83745
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
83989: LD_EXP 68
83993: PUSH
83994: LD_VAR 0 2
83998: ARRAY
83999: PUSH
84000: LD_INT 1
84002: ARRAY
84003: PUSH
84004: LD_INT 1
84006: ARRAY
84007: PPUSH
84008: LD_EXP 68
84012: PUSH
84013: LD_VAR 0 2
84017: ARRAY
84018: PUSH
84019: LD_INT 1
84021: ARRAY
84022: PUSH
84023: LD_INT 2
84025: ARRAY
84026: PPUSH
84027: LD_EXP 57
84031: PUSH
84032: LD_VAR 0 2
84036: ARRAY
84037: PPUSH
84038: CALL_OW 440
84042: IFFALSE 84085
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
84044: LD_ADDR_EXP 68
84048: PUSH
84049: LD_EXP 68
84053: PPUSH
84054: LD_VAR 0 2
84058: PPUSH
84059: LD_EXP 68
84063: PUSH
84064: LD_VAR 0 2
84068: ARRAY
84069: PPUSH
84070: LD_INT 1
84072: PPUSH
84073: CALL_OW 3
84077: PPUSH
84078: CALL_OW 1
84082: ST_TO_ADDR
84083: GO 84332
// begin if not mc_deposits_finder [ i ] then
84085: LD_EXP 69
84089: PUSH
84090: LD_VAR 0 2
84094: ARRAY
84095: NOT
84096: IFFALSE 84148
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
84098: LD_ADDR_EXP 69
84102: PUSH
84103: LD_EXP 69
84107: PPUSH
84108: LD_VAR 0 2
84112: PPUSH
84113: LD_VAR 0 3
84117: PUSH
84118: LD_INT 1
84120: ARRAY
84121: PUSH
84122: EMPTY
84123: LIST
84124: PPUSH
84125: CALL_OW 1
84129: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
84130: LD_VAR 0 3
84134: PUSH
84135: LD_INT 1
84137: ARRAY
84138: PPUSH
84139: LD_INT 125
84141: PPUSH
84142: CALL_OW 109
// end else
84146: GO 84332
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
84148: LD_EXP 69
84152: PUSH
84153: LD_VAR 0 2
84157: ARRAY
84158: PUSH
84159: LD_INT 1
84161: ARRAY
84162: PPUSH
84163: CALL_OW 310
84167: IFFALSE 84190
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
84169: LD_EXP 69
84173: PUSH
84174: LD_VAR 0 2
84178: ARRAY
84179: PUSH
84180: LD_INT 1
84182: ARRAY
84183: PPUSH
84184: CALL_OW 122
84188: GO 84332
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
84190: LD_EXP 69
84194: PUSH
84195: LD_VAR 0 2
84199: ARRAY
84200: PUSH
84201: LD_INT 1
84203: ARRAY
84204: PPUSH
84205: CALL_OW 314
84209: NOT
84210: PUSH
84211: LD_EXP 69
84215: PUSH
84216: LD_VAR 0 2
84220: ARRAY
84221: PUSH
84222: LD_INT 1
84224: ARRAY
84225: PPUSH
84226: LD_EXP 68
84230: PUSH
84231: LD_VAR 0 2
84235: ARRAY
84236: PUSH
84237: LD_INT 1
84239: ARRAY
84240: PUSH
84241: LD_INT 1
84243: ARRAY
84244: PPUSH
84245: LD_EXP 68
84249: PUSH
84250: LD_VAR 0 2
84254: ARRAY
84255: PUSH
84256: LD_INT 1
84258: ARRAY
84259: PUSH
84260: LD_INT 2
84262: ARRAY
84263: PPUSH
84264: CALL_OW 297
84268: PUSH
84269: LD_INT 6
84271: GREATER
84272: AND
84273: IFFALSE 84332
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
84275: LD_EXP 69
84279: PUSH
84280: LD_VAR 0 2
84284: ARRAY
84285: PUSH
84286: LD_INT 1
84288: ARRAY
84289: PPUSH
84290: LD_EXP 68
84294: PUSH
84295: LD_VAR 0 2
84299: ARRAY
84300: PUSH
84301: LD_INT 1
84303: ARRAY
84304: PUSH
84305: LD_INT 1
84307: ARRAY
84308: PPUSH
84309: LD_EXP 68
84313: PUSH
84314: LD_VAR 0 2
84318: ARRAY
84319: PUSH
84320: LD_INT 1
84322: ARRAY
84323: PUSH
84324: LD_INT 2
84326: ARRAY
84327: PPUSH
84328: CALL_OW 111
// end ; end ; end ;
84332: GO 83745
84334: POP
84335: POP
// end ;
84336: LD_VAR 0 1
84340: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
84341: LD_INT 0
84343: PPUSH
84344: PPUSH
84345: PPUSH
84346: PPUSH
84347: PPUSH
84348: PPUSH
84349: PPUSH
84350: PPUSH
84351: PPUSH
84352: PPUSH
84353: PPUSH
// if not mc_bases then
84354: LD_EXP 31
84358: NOT
84359: IFFALSE 84363
// exit ;
84361: GO 85303
// for i = 1 to mc_bases do
84363: LD_ADDR_VAR 0 2
84367: PUSH
84368: DOUBLE
84369: LD_INT 1
84371: DEC
84372: ST_TO_ADDR
84373: LD_EXP 31
84377: PUSH
84378: FOR_TO
84379: IFFALSE 85301
// begin if not mc_bases [ i ] or mc_scan [ i ] then
84381: LD_EXP 31
84385: PUSH
84386: LD_VAR 0 2
84390: ARRAY
84391: NOT
84392: PUSH
84393: LD_EXP 54
84397: PUSH
84398: LD_VAR 0 2
84402: ARRAY
84403: OR
84404: IFFALSE 84408
// continue ;
84406: GO 84378
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
84408: LD_ADDR_VAR 0 7
84412: PUSH
84413: LD_EXP 31
84417: PUSH
84418: LD_VAR 0 2
84422: ARRAY
84423: PUSH
84424: LD_INT 1
84426: ARRAY
84427: PPUSH
84428: CALL_OW 248
84432: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
84433: LD_VAR 0 7
84437: PUSH
84438: LD_INT 3
84440: EQUAL
84441: PUSH
84442: LD_EXP 50
84446: PUSH
84447: LD_VAR 0 2
84451: ARRAY
84452: PUSH
84453: LD_EXP 53
84457: PUSH
84458: LD_VAR 0 2
84462: ARRAY
84463: UNION
84464: PPUSH
84465: LD_INT 33
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PPUSH
84475: CALL_OW 72
84479: NOT
84480: OR
84481: IFFALSE 84485
// continue ;
84483: GO 84378
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
84485: LD_ADDR_VAR 0 9
84489: PUSH
84490: LD_EXP 31
84494: PUSH
84495: LD_VAR 0 2
84499: ARRAY
84500: PPUSH
84501: LD_INT 30
84503: PUSH
84504: LD_INT 36
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PPUSH
84511: CALL_OW 72
84515: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
84516: LD_ADDR_VAR 0 10
84520: PUSH
84521: LD_EXP 50
84525: PUSH
84526: LD_VAR 0 2
84530: ARRAY
84531: PPUSH
84532: LD_INT 34
84534: PUSH
84535: LD_INT 31
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PPUSH
84542: CALL_OW 72
84546: ST_TO_ADDR
// if not cts and not mcts then
84547: LD_VAR 0 9
84551: NOT
84552: PUSH
84553: LD_VAR 0 10
84557: NOT
84558: AND
84559: IFFALSE 84563
// continue ;
84561: GO 84378
// x := cts ;
84563: LD_ADDR_VAR 0 11
84567: PUSH
84568: LD_VAR 0 9
84572: ST_TO_ADDR
// if not x then
84573: LD_VAR 0 11
84577: NOT
84578: IFFALSE 84590
// x := mcts ;
84580: LD_ADDR_VAR 0 11
84584: PUSH
84585: LD_VAR 0 10
84589: ST_TO_ADDR
// if not x then
84590: LD_VAR 0 11
84594: NOT
84595: IFFALSE 84599
// continue ;
84597: GO 84378
// if mc_remote_driver [ i ] then
84599: LD_EXP 71
84603: PUSH
84604: LD_VAR 0 2
84608: ARRAY
84609: IFFALSE 84996
// for j in mc_remote_driver [ i ] do
84611: LD_ADDR_VAR 0 3
84615: PUSH
84616: LD_EXP 71
84620: PUSH
84621: LD_VAR 0 2
84625: ARRAY
84626: PUSH
84627: FOR_IN
84628: IFFALSE 84994
// begin if GetClass ( j ) <> 3 then
84630: LD_VAR 0 3
84634: PPUSH
84635: CALL_OW 257
84639: PUSH
84640: LD_INT 3
84642: NONEQUAL
84643: IFFALSE 84696
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
84645: LD_ADDR_EXP 71
84649: PUSH
84650: LD_EXP 71
84654: PPUSH
84655: LD_VAR 0 2
84659: PPUSH
84660: LD_EXP 71
84664: PUSH
84665: LD_VAR 0 2
84669: ARRAY
84670: PUSH
84671: LD_VAR 0 3
84675: DIFF
84676: PPUSH
84677: CALL_OW 1
84681: ST_TO_ADDR
// SetTag ( j , 0 ) ;
84682: LD_VAR 0 3
84686: PPUSH
84687: LD_INT 0
84689: PPUSH
84690: CALL_OW 109
// continue ;
84694: GO 84627
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
84696: LD_EXP 50
84700: PUSH
84701: LD_VAR 0 2
84705: ARRAY
84706: PPUSH
84707: LD_INT 34
84709: PUSH
84710: LD_INT 31
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 58
84719: PUSH
84720: EMPTY
84721: LIST
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: PPUSH
84727: CALL_OW 72
84731: PUSH
84732: LD_VAR 0 3
84736: PPUSH
84737: CALL 55134 0 1
84741: NOT
84742: AND
84743: IFFALSE 84814
// begin if IsInUnit ( j ) then
84745: LD_VAR 0 3
84749: PPUSH
84750: CALL_OW 310
84754: IFFALSE 84765
// ComExitBuilding ( j ) ;
84756: LD_VAR 0 3
84760: PPUSH
84761: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
84765: LD_VAR 0 3
84769: PPUSH
84770: LD_EXP 50
84774: PUSH
84775: LD_VAR 0 2
84779: ARRAY
84780: PPUSH
84781: LD_INT 34
84783: PUSH
84784: LD_INT 31
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 58
84793: PUSH
84794: EMPTY
84795: LIST
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PPUSH
84801: CALL_OW 72
84805: PUSH
84806: LD_INT 1
84808: ARRAY
84809: PPUSH
84810: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
84814: LD_VAR 0 3
84818: PPUSH
84819: CALL_OW 310
84823: NOT
84824: PUSH
84825: LD_VAR 0 3
84829: PPUSH
84830: CALL_OW 310
84834: PPUSH
84835: CALL_OW 266
84839: PUSH
84840: LD_INT 36
84842: NONEQUAL
84843: PUSH
84844: LD_VAR 0 3
84848: PPUSH
84849: CALL 55134 0 1
84853: NOT
84854: AND
84855: OR
84856: IFFALSE 84992
// begin if IsInUnit ( j ) then
84858: LD_VAR 0 3
84862: PPUSH
84863: CALL_OW 310
84867: IFFALSE 84878
// ComExitBuilding ( j ) ;
84869: LD_VAR 0 3
84873: PPUSH
84874: CALL_OW 122
// ct := 0 ;
84878: LD_ADDR_VAR 0 8
84882: PUSH
84883: LD_INT 0
84885: ST_TO_ADDR
// for k in x do
84886: LD_ADDR_VAR 0 4
84890: PUSH
84891: LD_VAR 0 11
84895: PUSH
84896: FOR_IN
84897: IFFALSE 84970
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
84899: LD_VAR 0 4
84903: PPUSH
84904: CALL_OW 264
84908: PUSH
84909: LD_INT 31
84911: EQUAL
84912: PUSH
84913: LD_VAR 0 4
84917: PPUSH
84918: CALL_OW 311
84922: NOT
84923: AND
84924: PUSH
84925: LD_VAR 0 4
84929: PPUSH
84930: CALL_OW 266
84934: PUSH
84935: LD_INT 36
84937: EQUAL
84938: PUSH
84939: LD_VAR 0 4
84943: PPUSH
84944: CALL_OW 313
84948: PUSH
84949: LD_INT 3
84951: LESS
84952: AND
84953: OR
84954: IFFALSE 84968
// begin ct := k ;
84956: LD_ADDR_VAR 0 8
84960: PUSH
84961: LD_VAR 0 4
84965: ST_TO_ADDR
// break ;
84966: GO 84970
// end ;
84968: GO 84896
84970: POP
84971: POP
// if ct then
84972: LD_VAR 0 8
84976: IFFALSE 84992
// ComEnterUnit ( j , ct ) ;
84978: LD_VAR 0 3
84982: PPUSH
84983: LD_VAR 0 8
84987: PPUSH
84988: CALL_OW 120
// end ; end ;
84992: GO 84627
84994: POP
84995: POP
// places := 0 ;
84996: LD_ADDR_VAR 0 5
85000: PUSH
85001: LD_INT 0
85003: ST_TO_ADDR
// for j = 1 to x do
85004: LD_ADDR_VAR 0 3
85008: PUSH
85009: DOUBLE
85010: LD_INT 1
85012: DEC
85013: ST_TO_ADDR
85014: LD_VAR 0 11
85018: PUSH
85019: FOR_TO
85020: IFFALSE 85096
// if GetWeapon ( x [ j ] ) = ar_control_tower then
85022: LD_VAR 0 11
85026: PUSH
85027: LD_VAR 0 3
85031: ARRAY
85032: PPUSH
85033: CALL_OW 264
85037: PUSH
85038: LD_INT 31
85040: EQUAL
85041: IFFALSE 85059
// places := places + 1 else
85043: LD_ADDR_VAR 0 5
85047: PUSH
85048: LD_VAR 0 5
85052: PUSH
85053: LD_INT 1
85055: PLUS
85056: ST_TO_ADDR
85057: GO 85094
// if GetBType ( x [ j ] ) = b_control_tower then
85059: LD_VAR 0 11
85063: PUSH
85064: LD_VAR 0 3
85068: ARRAY
85069: PPUSH
85070: CALL_OW 266
85074: PUSH
85075: LD_INT 36
85077: EQUAL
85078: IFFALSE 85094
// places := places + 3 ;
85080: LD_ADDR_VAR 0 5
85084: PUSH
85085: LD_VAR 0 5
85089: PUSH
85090: LD_INT 3
85092: PLUS
85093: ST_TO_ADDR
85094: GO 85019
85096: POP
85097: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
85098: LD_VAR 0 5
85102: PUSH
85103: LD_INT 0
85105: EQUAL
85106: PUSH
85107: LD_VAR 0 5
85111: PUSH
85112: LD_EXP 71
85116: PUSH
85117: LD_VAR 0 2
85121: ARRAY
85122: LESSEQUAL
85123: OR
85124: IFFALSE 85128
// continue ;
85126: GO 84378
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
85128: LD_ADDR_VAR 0 6
85132: PUSH
85133: LD_EXP 31
85137: PUSH
85138: LD_VAR 0 2
85142: ARRAY
85143: PPUSH
85144: LD_INT 25
85146: PUSH
85147: LD_INT 3
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: PPUSH
85154: CALL_OW 72
85158: PUSH
85159: LD_EXP 71
85163: PUSH
85164: LD_VAR 0 2
85168: ARRAY
85169: DIFF
85170: PPUSH
85171: LD_INT 3
85173: PPUSH
85174: CALL 56034 0 2
85178: ST_TO_ADDR
// for j in tmp do
85179: LD_ADDR_VAR 0 3
85183: PUSH
85184: LD_VAR 0 6
85188: PUSH
85189: FOR_IN
85190: IFFALSE 85225
// if GetTag ( j ) > 0 then
85192: LD_VAR 0 3
85196: PPUSH
85197: CALL_OW 110
85201: PUSH
85202: LD_INT 0
85204: GREATER
85205: IFFALSE 85223
// tmp := tmp diff j ;
85207: LD_ADDR_VAR 0 6
85211: PUSH
85212: LD_VAR 0 6
85216: PUSH
85217: LD_VAR 0 3
85221: DIFF
85222: ST_TO_ADDR
85223: GO 85189
85225: POP
85226: POP
// if not tmp then
85227: LD_VAR 0 6
85231: NOT
85232: IFFALSE 85236
// continue ;
85234: GO 84378
// if places then
85236: LD_VAR 0 5
85240: IFFALSE 85299
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
85242: LD_ADDR_EXP 71
85246: PUSH
85247: LD_EXP 71
85251: PPUSH
85252: LD_VAR 0 2
85256: PPUSH
85257: LD_EXP 71
85261: PUSH
85262: LD_VAR 0 2
85266: ARRAY
85267: PUSH
85268: LD_VAR 0 6
85272: PUSH
85273: LD_INT 1
85275: ARRAY
85276: UNION
85277: PPUSH
85278: CALL_OW 1
85282: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
85283: LD_VAR 0 6
85287: PUSH
85288: LD_INT 1
85290: ARRAY
85291: PPUSH
85292: LD_INT 126
85294: PPUSH
85295: CALL_OW 109
// end ; end ;
85299: GO 84378
85301: POP
85302: POP
// end ;
85303: LD_VAR 0 1
85307: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
85308: LD_INT 0
85310: PPUSH
85311: PPUSH
85312: PPUSH
85313: PPUSH
85314: PPUSH
85315: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
85316: LD_VAR 0 1
85320: NOT
85321: PUSH
85322: LD_VAR 0 2
85326: NOT
85327: OR
85328: PUSH
85329: LD_VAR 0 3
85333: NOT
85334: OR
85335: PUSH
85336: LD_VAR 0 4
85340: PUSH
85341: LD_INT 1
85343: PUSH
85344: LD_INT 2
85346: PUSH
85347: LD_INT 3
85349: PUSH
85350: LD_INT 4
85352: PUSH
85353: LD_INT 5
85355: PUSH
85356: LD_INT 8
85358: PUSH
85359: LD_INT 9
85361: PUSH
85362: LD_INT 15
85364: PUSH
85365: LD_INT 16
85367: PUSH
85368: EMPTY
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: IN
85379: NOT
85380: OR
85381: IFFALSE 85385
// exit ;
85383: GO 86243
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
85385: LD_ADDR_VAR 0 2
85389: PUSH
85390: LD_VAR 0 2
85394: PPUSH
85395: LD_INT 21
85397: PUSH
85398: LD_INT 3
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 24
85407: PUSH
85408: LD_INT 250
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PPUSH
85419: CALL_OW 72
85423: ST_TO_ADDR
// case class of 1 , 15 :
85424: LD_VAR 0 4
85428: PUSH
85429: LD_INT 1
85431: DOUBLE
85432: EQUAL
85433: IFTRUE 85443
85435: LD_INT 15
85437: DOUBLE
85438: EQUAL
85439: IFTRUE 85443
85441: GO 85528
85443: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
85444: LD_ADDR_VAR 0 8
85448: PUSH
85449: LD_VAR 0 2
85453: PPUSH
85454: LD_INT 2
85456: PUSH
85457: LD_INT 30
85459: PUSH
85460: LD_INT 32
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 30
85469: PUSH
85470: LD_INT 31
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: LIST
85481: PPUSH
85482: CALL_OW 72
85486: PUSH
85487: LD_VAR 0 2
85491: PPUSH
85492: LD_INT 2
85494: PUSH
85495: LD_INT 30
85497: PUSH
85498: LD_INT 4
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 30
85507: PUSH
85508: LD_INT 5
85510: PUSH
85511: EMPTY
85512: LIST
85513: LIST
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: LIST
85519: PPUSH
85520: CALL_OW 72
85524: ADD
85525: ST_TO_ADDR
85526: GO 85774
85528: LD_INT 2
85530: DOUBLE
85531: EQUAL
85532: IFTRUE 85542
85534: LD_INT 16
85536: DOUBLE
85537: EQUAL
85538: IFTRUE 85542
85540: GO 85588
85542: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
85543: LD_ADDR_VAR 0 8
85547: PUSH
85548: LD_VAR 0 2
85552: PPUSH
85553: LD_INT 2
85555: PUSH
85556: LD_INT 30
85558: PUSH
85559: LD_INT 0
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 30
85568: PUSH
85569: LD_INT 1
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: LIST
85580: PPUSH
85581: CALL_OW 72
85585: ST_TO_ADDR
85586: GO 85774
85588: LD_INT 3
85590: DOUBLE
85591: EQUAL
85592: IFTRUE 85596
85594: GO 85642
85596: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
85597: LD_ADDR_VAR 0 8
85601: PUSH
85602: LD_VAR 0 2
85606: PPUSH
85607: LD_INT 2
85609: PUSH
85610: LD_INT 30
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 30
85622: PUSH
85623: LD_INT 3
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: EMPTY
85631: LIST
85632: LIST
85633: LIST
85634: PPUSH
85635: CALL_OW 72
85639: ST_TO_ADDR
85640: GO 85774
85642: LD_INT 4
85644: DOUBLE
85645: EQUAL
85646: IFTRUE 85650
85648: GO 85707
85650: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
85651: LD_ADDR_VAR 0 8
85655: PUSH
85656: LD_VAR 0 2
85660: PPUSH
85661: LD_INT 2
85663: PUSH
85664: LD_INT 30
85666: PUSH
85667: LD_INT 6
85669: PUSH
85670: EMPTY
85671: LIST
85672: LIST
85673: PUSH
85674: LD_INT 30
85676: PUSH
85677: LD_INT 7
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: LD_INT 30
85686: PUSH
85687: LD_INT 8
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: PPUSH
85700: CALL_OW 72
85704: ST_TO_ADDR
85705: GO 85774
85707: LD_INT 5
85709: DOUBLE
85710: EQUAL
85711: IFTRUE 85727
85713: LD_INT 8
85715: DOUBLE
85716: EQUAL
85717: IFTRUE 85727
85719: LD_INT 9
85721: DOUBLE
85722: EQUAL
85723: IFTRUE 85727
85725: GO 85773
85727: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
85728: LD_ADDR_VAR 0 8
85732: PUSH
85733: LD_VAR 0 2
85737: PPUSH
85738: LD_INT 2
85740: PUSH
85741: LD_INT 30
85743: PUSH
85744: LD_INT 4
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 30
85753: PUSH
85754: LD_INT 5
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: EMPTY
85762: LIST
85763: LIST
85764: LIST
85765: PPUSH
85766: CALL_OW 72
85770: ST_TO_ADDR
85771: GO 85774
85773: POP
// if not tmp then
85774: LD_VAR 0 8
85778: NOT
85779: IFFALSE 85783
// exit ;
85781: GO 86243
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
85783: LD_VAR 0 4
85787: PUSH
85788: LD_INT 1
85790: PUSH
85791: LD_INT 15
85793: PUSH
85794: EMPTY
85795: LIST
85796: LIST
85797: IN
85798: PUSH
85799: LD_EXP 40
85803: PUSH
85804: LD_VAR 0 1
85808: ARRAY
85809: AND
85810: IFFALSE 85966
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
85812: LD_ADDR_VAR 0 9
85816: PUSH
85817: LD_EXP 40
85821: PUSH
85822: LD_VAR 0 1
85826: ARRAY
85827: PUSH
85828: LD_INT 1
85830: ARRAY
85831: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
85832: LD_VAR 0 9
85836: PUSH
85837: LD_EXP 41
85841: PUSH
85842: LD_VAR 0 1
85846: ARRAY
85847: IN
85848: NOT
85849: IFFALSE 85964
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
85851: LD_ADDR_EXP 41
85855: PUSH
85856: LD_EXP 41
85860: PPUSH
85861: LD_VAR 0 1
85865: PUSH
85866: LD_EXP 41
85870: PUSH
85871: LD_VAR 0 1
85875: ARRAY
85876: PUSH
85877: LD_INT 1
85879: PLUS
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PPUSH
85885: LD_VAR 0 9
85889: PPUSH
85890: CALL 24801 0 3
85894: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
85895: LD_ADDR_EXP 40
85899: PUSH
85900: LD_EXP 40
85904: PPUSH
85905: LD_VAR 0 1
85909: PPUSH
85910: LD_EXP 40
85914: PUSH
85915: LD_VAR 0 1
85919: ARRAY
85920: PUSH
85921: LD_VAR 0 9
85925: DIFF
85926: PPUSH
85927: CALL_OW 1
85931: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
85932: LD_VAR 0 3
85936: PPUSH
85937: LD_EXP 41
85941: PUSH
85942: LD_VAR 0 1
85946: ARRAY
85947: PUSH
85948: LD_EXP 41
85952: PUSH
85953: LD_VAR 0 1
85957: ARRAY
85958: ARRAY
85959: PPUSH
85960: CALL_OW 120
// end ; exit ;
85964: GO 86243
// end ; if tmp > 1 then
85966: LD_VAR 0 8
85970: PUSH
85971: LD_INT 1
85973: GREATER
85974: IFFALSE 86078
// for i = 2 to tmp do
85976: LD_ADDR_VAR 0 6
85980: PUSH
85981: DOUBLE
85982: LD_INT 2
85984: DEC
85985: ST_TO_ADDR
85986: LD_VAR 0 8
85990: PUSH
85991: FOR_TO
85992: IFFALSE 86076
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
85994: LD_VAR 0 8
85998: PUSH
85999: LD_VAR 0 6
86003: ARRAY
86004: PPUSH
86005: CALL_OW 461
86009: PUSH
86010: LD_INT 6
86012: EQUAL
86013: IFFALSE 86074
// begin x := tmp [ i ] ;
86015: LD_ADDR_VAR 0 9
86019: PUSH
86020: LD_VAR 0 8
86024: PUSH
86025: LD_VAR 0 6
86029: ARRAY
86030: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
86031: LD_ADDR_VAR 0 8
86035: PUSH
86036: LD_VAR 0 8
86040: PPUSH
86041: LD_VAR 0 6
86045: PPUSH
86046: CALL_OW 3
86050: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
86051: LD_ADDR_VAR 0 8
86055: PUSH
86056: LD_VAR 0 8
86060: PPUSH
86061: LD_INT 1
86063: PPUSH
86064: LD_VAR 0 9
86068: PPUSH
86069: CALL_OW 2
86073: ST_TO_ADDR
// end ;
86074: GO 85991
86076: POP
86077: POP
// for i in tmp do
86078: LD_ADDR_VAR 0 6
86082: PUSH
86083: LD_VAR 0 8
86087: PUSH
86088: FOR_IN
86089: IFFALSE 86116
// begin if IsNotFull ( i ) then
86091: LD_VAR 0 6
86095: PPUSH
86096: CALL 22023 0 1
86100: IFFALSE 86114
// begin j := i ;
86102: LD_ADDR_VAR 0 7
86106: PUSH
86107: LD_VAR 0 6
86111: ST_TO_ADDR
// break ;
86112: GO 86116
// end ; end ;
86114: GO 86088
86116: POP
86117: POP
// if j then
86118: LD_VAR 0 7
86122: IFFALSE 86140
// ComEnterUnit ( unit , j ) else
86124: LD_VAR 0 3
86128: PPUSH
86129: LD_VAR 0 7
86133: PPUSH
86134: CALL_OW 120
86138: GO 86243
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86140: LD_ADDR_VAR 0 10
86144: PUSH
86145: LD_VAR 0 2
86149: PPUSH
86150: LD_INT 2
86152: PUSH
86153: LD_INT 30
86155: PUSH
86156: LD_INT 0
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 30
86165: PUSH
86166: LD_INT 1
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: LIST
86177: PPUSH
86178: CALL_OW 72
86182: ST_TO_ADDR
// if depot then
86183: LD_VAR 0 10
86187: IFFALSE 86243
// begin depot := NearestUnitToUnit ( depot , unit ) ;
86189: LD_ADDR_VAR 0 10
86193: PUSH
86194: LD_VAR 0 10
86198: PPUSH
86199: LD_VAR 0 3
86203: PPUSH
86204: CALL_OW 74
86208: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
86209: LD_VAR 0 3
86213: PPUSH
86214: LD_VAR 0 10
86218: PPUSH
86219: CALL_OW 296
86223: PUSH
86224: LD_INT 10
86226: GREATER
86227: IFFALSE 86243
// ComStandNearbyBuilding ( unit , depot ) ;
86229: LD_VAR 0 3
86233: PPUSH
86234: LD_VAR 0 10
86238: PPUSH
86239: CALL 21403 0 2
// end ; end ; end ;
86243: LD_VAR 0 5
86247: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
86248: LD_INT 0
86250: PPUSH
86251: PPUSH
86252: PPUSH
86253: PPUSH
// if not mc_bases then
86254: LD_EXP 31
86258: NOT
86259: IFFALSE 86263
// exit ;
86261: GO 86502
// for i = 1 to mc_bases do
86263: LD_ADDR_VAR 0 2
86267: PUSH
86268: DOUBLE
86269: LD_INT 1
86271: DEC
86272: ST_TO_ADDR
86273: LD_EXP 31
86277: PUSH
86278: FOR_TO
86279: IFFALSE 86500
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
86281: LD_ADDR_VAR 0 4
86285: PUSH
86286: LD_EXP 31
86290: PUSH
86291: LD_VAR 0 2
86295: ARRAY
86296: PPUSH
86297: LD_INT 21
86299: PUSH
86300: LD_INT 1
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PPUSH
86307: CALL_OW 72
86311: PUSH
86312: LD_EXP 60
86316: PUSH
86317: LD_VAR 0 2
86321: ARRAY
86322: UNION
86323: ST_TO_ADDR
// if not tmp then
86324: LD_VAR 0 4
86328: NOT
86329: IFFALSE 86333
// continue ;
86331: GO 86278
// for j in tmp do
86333: LD_ADDR_VAR 0 3
86337: PUSH
86338: LD_VAR 0 4
86342: PUSH
86343: FOR_IN
86344: IFFALSE 86496
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
86346: LD_VAR 0 3
86350: PPUSH
86351: CALL_OW 110
86355: NOT
86356: PUSH
86357: LD_VAR 0 3
86361: PPUSH
86362: CALL_OW 314
86366: NOT
86367: AND
86368: PUSH
86369: LD_VAR 0 3
86373: PPUSH
86374: CALL_OW 311
86378: NOT
86379: AND
86380: PUSH
86381: LD_VAR 0 3
86385: PPUSH
86386: CALL_OW 310
86390: NOT
86391: AND
86392: PUSH
86393: LD_VAR 0 3
86397: PUSH
86398: LD_EXP 34
86402: PUSH
86403: LD_VAR 0 2
86407: ARRAY
86408: PUSH
86409: LD_INT 1
86411: ARRAY
86412: IN
86413: NOT
86414: AND
86415: PUSH
86416: LD_VAR 0 3
86420: PUSH
86421: LD_EXP 34
86425: PUSH
86426: LD_VAR 0 2
86430: ARRAY
86431: PUSH
86432: LD_INT 2
86434: ARRAY
86435: IN
86436: NOT
86437: AND
86438: PUSH
86439: LD_VAR 0 3
86443: PUSH
86444: LD_EXP 43
86448: PUSH
86449: LD_VAR 0 2
86453: ARRAY
86454: IN
86455: NOT
86456: AND
86457: IFFALSE 86494
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
86459: LD_VAR 0 2
86463: PPUSH
86464: LD_EXP 31
86468: PUSH
86469: LD_VAR 0 2
86473: ARRAY
86474: PPUSH
86475: LD_VAR 0 3
86479: PPUSH
86480: LD_VAR 0 3
86484: PPUSH
86485: CALL_OW 257
86489: PPUSH
86490: CALL 85308 0 4
// end ;
86494: GO 86343
86496: POP
86497: POP
// end ;
86498: GO 86278
86500: POP
86501: POP
// end ;
86502: LD_VAR 0 1
86506: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
86507: LD_INT 0
86509: PPUSH
86510: PPUSH
86511: PPUSH
86512: PPUSH
86513: PPUSH
86514: PPUSH
// if not mc_bases [ base ] then
86515: LD_EXP 31
86519: PUSH
86520: LD_VAR 0 1
86524: ARRAY
86525: NOT
86526: IFFALSE 86530
// exit ;
86528: GO 86731
// tmp := [ ] ;
86530: LD_ADDR_VAR 0 6
86534: PUSH
86535: EMPTY
86536: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
86537: LD_ADDR_VAR 0 7
86541: PUSH
86542: LD_VAR 0 3
86546: PPUSH
86547: LD_INT 0
86549: PPUSH
86550: CALL_OW 517
86554: ST_TO_ADDR
// if not list then
86555: LD_VAR 0 7
86559: NOT
86560: IFFALSE 86564
// exit ;
86562: GO 86731
// c := Count ( list [ 1 ] ) ;
86564: LD_ADDR_VAR 0 9
86568: PUSH
86569: LD_VAR 0 7
86573: PUSH
86574: LD_INT 1
86576: ARRAY
86577: PPUSH
86578: CALL 21941 0 1
86582: ST_TO_ADDR
// if amount > c then
86583: LD_VAR 0 2
86587: PUSH
86588: LD_VAR 0 9
86592: GREATER
86593: IFFALSE 86605
// amount := c ;
86595: LD_ADDR_VAR 0 2
86599: PUSH
86600: LD_VAR 0 9
86604: ST_TO_ADDR
// for i := 1 to amount do
86605: LD_ADDR_VAR 0 5
86609: PUSH
86610: DOUBLE
86611: LD_INT 1
86613: DEC
86614: ST_TO_ADDR
86615: LD_VAR 0 2
86619: PUSH
86620: FOR_TO
86621: IFFALSE 86679
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
86623: LD_ADDR_VAR 0 6
86627: PUSH
86628: LD_VAR 0 6
86632: PPUSH
86633: LD_VAR 0 5
86637: PPUSH
86638: LD_VAR 0 7
86642: PUSH
86643: LD_INT 1
86645: ARRAY
86646: PUSH
86647: LD_VAR 0 5
86651: ARRAY
86652: PUSH
86653: LD_VAR 0 7
86657: PUSH
86658: LD_INT 2
86660: ARRAY
86661: PUSH
86662: LD_VAR 0 5
86666: ARRAY
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PPUSH
86672: CALL_OW 1
86676: ST_TO_ADDR
86677: GO 86620
86679: POP
86680: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
86681: LD_ADDR_EXP 44
86685: PUSH
86686: LD_EXP 44
86690: PPUSH
86691: LD_VAR 0 1
86695: PPUSH
86696: LD_VAR 0 6
86700: PPUSH
86701: CALL_OW 1
86705: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
86706: LD_ADDR_EXP 46
86710: PUSH
86711: LD_EXP 46
86715: PPUSH
86716: LD_VAR 0 1
86720: PPUSH
86721: LD_VAR 0 3
86725: PPUSH
86726: CALL_OW 1
86730: ST_TO_ADDR
// end ;
86731: LD_VAR 0 4
86735: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
86736: LD_INT 0
86738: PPUSH
// if not mc_bases [ base ] then
86739: LD_EXP 31
86743: PUSH
86744: LD_VAR 0 1
86748: ARRAY
86749: NOT
86750: IFFALSE 86754
// exit ;
86752: GO 86779
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
86754: LD_ADDR_EXP 36
86758: PUSH
86759: LD_EXP 36
86763: PPUSH
86764: LD_VAR 0 1
86768: PPUSH
86769: LD_VAR 0 2
86773: PPUSH
86774: CALL_OW 1
86778: ST_TO_ADDR
// end ;
86779: LD_VAR 0 3
86783: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
86784: LD_INT 0
86786: PPUSH
// if not mc_bases [ base ] then
86787: LD_EXP 31
86791: PUSH
86792: LD_VAR 0 1
86796: ARRAY
86797: NOT
86798: IFFALSE 86802
// exit ;
86800: GO 86839
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
86802: LD_ADDR_EXP 36
86806: PUSH
86807: LD_EXP 36
86811: PPUSH
86812: LD_VAR 0 1
86816: PPUSH
86817: LD_EXP 36
86821: PUSH
86822: LD_VAR 0 1
86826: ARRAY
86827: PUSH
86828: LD_VAR 0 2
86832: UNION
86833: PPUSH
86834: CALL_OW 1
86838: ST_TO_ADDR
// end ;
86839: LD_VAR 0 3
86843: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
86844: LD_INT 0
86846: PPUSH
// if not mc_bases [ base ] then
86847: LD_EXP 31
86851: PUSH
86852: LD_VAR 0 1
86856: ARRAY
86857: NOT
86858: IFFALSE 86862
// exit ;
86860: GO 86887
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
86862: LD_ADDR_EXP 52
86866: PUSH
86867: LD_EXP 52
86871: PPUSH
86872: LD_VAR 0 1
86876: PPUSH
86877: LD_VAR 0 2
86881: PPUSH
86882: CALL_OW 1
86886: ST_TO_ADDR
// end ;
86887: LD_VAR 0 3
86891: RET
// export function MC_InsertProduceList ( base , components ) ; begin
86892: LD_INT 0
86894: PPUSH
// if not mc_bases [ base ] then
86895: LD_EXP 31
86899: PUSH
86900: LD_VAR 0 1
86904: ARRAY
86905: NOT
86906: IFFALSE 86910
// exit ;
86908: GO 86947
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
86910: LD_ADDR_EXP 52
86914: PUSH
86915: LD_EXP 52
86919: PPUSH
86920: LD_VAR 0 1
86924: PPUSH
86925: LD_EXP 52
86929: PUSH
86930: LD_VAR 0 1
86934: ARRAY
86935: PUSH
86936: LD_VAR 0 2
86940: ADD
86941: PPUSH
86942: CALL_OW 1
86946: ST_TO_ADDR
// end ;
86947: LD_VAR 0 3
86951: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
86952: LD_INT 0
86954: PPUSH
// if not mc_bases [ base ] then
86955: LD_EXP 31
86959: PUSH
86960: LD_VAR 0 1
86964: ARRAY
86965: NOT
86966: IFFALSE 86970
// exit ;
86968: GO 87024
// mc_defender := Replace ( mc_defender , base , deflist ) ;
86970: LD_ADDR_EXP 53
86974: PUSH
86975: LD_EXP 53
86979: PPUSH
86980: LD_VAR 0 1
86984: PPUSH
86985: LD_VAR 0 2
86989: PPUSH
86990: CALL_OW 1
86994: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
86995: LD_ADDR_EXP 42
86999: PUSH
87000: LD_EXP 42
87004: PPUSH
87005: LD_VAR 0 1
87009: PPUSH
87010: LD_VAR 0 2
87014: PUSH
87015: LD_INT 0
87017: PLUS
87018: PPUSH
87019: CALL_OW 1
87023: ST_TO_ADDR
// end ;
87024: LD_VAR 0 3
87028: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
87029: LD_INT 0
87031: PPUSH
// if not mc_bases [ base ] then
87032: LD_EXP 31
87036: PUSH
87037: LD_VAR 0 1
87041: ARRAY
87042: NOT
87043: IFFALSE 87047
// exit ;
87045: GO 87072
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
87047: LD_ADDR_EXP 42
87051: PUSH
87052: LD_EXP 42
87056: PPUSH
87057: LD_VAR 0 1
87061: PPUSH
87062: LD_VAR 0 2
87066: PPUSH
87067: CALL_OW 1
87071: ST_TO_ADDR
// end ;
87072: LD_VAR 0 3
87076: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
87077: LD_INT 0
87079: PPUSH
87080: PPUSH
87081: PPUSH
87082: PPUSH
// if not mc_bases [ base ] then
87083: LD_EXP 31
87087: PUSH
87088: LD_VAR 0 1
87092: ARRAY
87093: NOT
87094: IFFALSE 87098
// exit ;
87096: GO 87163
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
87098: LD_ADDR_EXP 51
87102: PUSH
87103: LD_EXP 51
87107: PPUSH
87108: LD_VAR 0 1
87112: PUSH
87113: LD_EXP 51
87117: PUSH
87118: LD_VAR 0 1
87122: ARRAY
87123: PUSH
87124: LD_INT 1
87126: PLUS
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PPUSH
87132: LD_VAR 0 1
87136: PUSH
87137: LD_VAR 0 2
87141: PUSH
87142: LD_VAR 0 3
87146: PUSH
87147: LD_VAR 0 4
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: PPUSH
87158: CALL 24801 0 3
87162: ST_TO_ADDR
// end ;
87163: LD_VAR 0 5
87167: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
87168: LD_INT 0
87170: PPUSH
// if not mc_bases [ base ] then
87171: LD_EXP 31
87175: PUSH
87176: LD_VAR 0 1
87180: ARRAY
87181: NOT
87182: IFFALSE 87186
// exit ;
87184: GO 87211
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
87186: LD_ADDR_EXP 68
87190: PUSH
87191: LD_EXP 68
87195: PPUSH
87196: LD_VAR 0 1
87200: PPUSH
87201: LD_VAR 0 2
87205: PPUSH
87206: CALL_OW 1
87210: ST_TO_ADDR
// end ;
87211: LD_VAR 0 3
87215: RET
// export function MC_GetMinesField ( base ) ; begin
87216: LD_INT 0
87218: PPUSH
// result := mc_mines [ base ] ;
87219: LD_ADDR_VAR 0 2
87223: PUSH
87224: LD_EXP 44
87228: PUSH
87229: LD_VAR 0 1
87233: ARRAY
87234: ST_TO_ADDR
// end ;
87235: LD_VAR 0 2
87239: RET
// export function MC_GetProduceList ( base ) ; begin
87240: LD_INT 0
87242: PPUSH
// result := mc_produce [ base ] ;
87243: LD_ADDR_VAR 0 2
87247: PUSH
87248: LD_EXP 52
87252: PUSH
87253: LD_VAR 0 1
87257: ARRAY
87258: ST_TO_ADDR
// end ;
87259: LD_VAR 0 2
87263: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
87264: LD_INT 0
87266: PPUSH
87267: PPUSH
// if not mc_bases then
87268: LD_EXP 31
87272: NOT
87273: IFFALSE 87277
// exit ;
87275: GO 87342
// if mc_bases [ base ] then
87277: LD_EXP 31
87281: PUSH
87282: LD_VAR 0 1
87286: ARRAY
87287: IFFALSE 87342
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
87289: LD_ADDR_VAR 0 3
87293: PUSH
87294: LD_EXP 31
87298: PUSH
87299: LD_VAR 0 1
87303: ARRAY
87304: PPUSH
87305: LD_INT 30
87307: PUSH
87308: LD_VAR 0 2
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PPUSH
87317: CALL_OW 72
87321: ST_TO_ADDR
// if result then
87322: LD_VAR 0 3
87326: IFFALSE 87342
// result := result [ 1 ] ;
87328: LD_ADDR_VAR 0 3
87332: PUSH
87333: LD_VAR 0 3
87337: PUSH
87338: LD_INT 1
87340: ARRAY
87341: ST_TO_ADDR
// end ; end ;
87342: LD_VAR 0 3
87346: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
87347: LD_INT 0
87349: PPUSH
87350: PPUSH
// if not mc_bases then
87351: LD_EXP 31
87355: NOT
87356: IFFALSE 87360
// exit ;
87358: GO 87405
// if mc_bases [ base ] then
87360: LD_EXP 31
87364: PUSH
87365: LD_VAR 0 1
87369: ARRAY
87370: IFFALSE 87405
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
87372: LD_ADDR_VAR 0 3
87376: PUSH
87377: LD_EXP 31
87381: PUSH
87382: LD_VAR 0 1
87386: ARRAY
87387: PPUSH
87388: LD_INT 30
87390: PUSH
87391: LD_VAR 0 2
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PPUSH
87400: CALL_OW 72
87404: ST_TO_ADDR
// end ;
87405: LD_VAR 0 3
87409: RET
// export function MC_SetTame ( base , area ) ; begin
87410: LD_INT 0
87412: PPUSH
// if not mc_bases or not base then
87413: LD_EXP 31
87417: NOT
87418: PUSH
87419: LD_VAR 0 1
87423: NOT
87424: OR
87425: IFFALSE 87429
// exit ;
87427: GO 87454
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
87429: LD_ADDR_EXP 59
87433: PUSH
87434: LD_EXP 59
87438: PPUSH
87439: LD_VAR 0 1
87443: PPUSH
87444: LD_VAR 0 2
87448: PPUSH
87449: CALL_OW 1
87453: ST_TO_ADDR
// end ;
87454: LD_VAR 0 3
87458: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
87459: LD_INT 0
87461: PPUSH
87462: PPUSH
// if not mc_bases or not base then
87463: LD_EXP 31
87467: NOT
87468: PUSH
87469: LD_VAR 0 1
87473: NOT
87474: OR
87475: IFFALSE 87479
// exit ;
87477: GO 87581
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
87479: LD_ADDR_VAR 0 4
87483: PUSH
87484: LD_EXP 31
87488: PUSH
87489: LD_VAR 0 1
87493: ARRAY
87494: PPUSH
87495: LD_INT 30
87497: PUSH
87498: LD_VAR 0 2
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PPUSH
87507: CALL_OW 72
87511: ST_TO_ADDR
// if not tmp then
87512: LD_VAR 0 4
87516: NOT
87517: IFFALSE 87521
// exit ;
87519: GO 87581
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
87521: LD_ADDR_EXP 63
87525: PUSH
87526: LD_EXP 63
87530: PPUSH
87531: LD_VAR 0 1
87535: PPUSH
87536: LD_EXP 63
87540: PUSH
87541: LD_VAR 0 1
87545: ARRAY
87546: PPUSH
87547: LD_EXP 63
87551: PUSH
87552: LD_VAR 0 1
87556: ARRAY
87557: PUSH
87558: LD_INT 1
87560: PLUS
87561: PPUSH
87562: LD_VAR 0 4
87566: PUSH
87567: LD_INT 1
87569: ARRAY
87570: PPUSH
87571: CALL_OW 2
87575: PPUSH
87576: CALL_OW 1
87580: ST_TO_ADDR
// end ;
87581: LD_VAR 0 3
87585: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
87586: LD_INT 0
87588: PPUSH
87589: PPUSH
// if not mc_bases or not base or not kinds then
87590: LD_EXP 31
87594: NOT
87595: PUSH
87596: LD_VAR 0 1
87600: NOT
87601: OR
87602: PUSH
87603: LD_VAR 0 2
87607: NOT
87608: OR
87609: IFFALSE 87613
// exit ;
87611: GO 87674
// for i in kinds do
87613: LD_ADDR_VAR 0 4
87617: PUSH
87618: LD_VAR 0 2
87622: PUSH
87623: FOR_IN
87624: IFFALSE 87672
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
87626: LD_ADDR_EXP 65
87630: PUSH
87631: LD_EXP 65
87635: PPUSH
87636: LD_VAR 0 1
87640: PUSH
87641: LD_EXP 65
87645: PUSH
87646: LD_VAR 0 1
87650: ARRAY
87651: PUSH
87652: LD_INT 1
87654: PLUS
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PPUSH
87660: LD_VAR 0 4
87664: PPUSH
87665: CALL 24801 0 3
87669: ST_TO_ADDR
87670: GO 87623
87672: POP
87673: POP
// end ;
87674: LD_VAR 0 3
87678: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
87679: LD_INT 0
87681: PPUSH
// if not mc_bases or not base or not areas then
87682: LD_EXP 31
87686: NOT
87687: PUSH
87688: LD_VAR 0 1
87692: NOT
87693: OR
87694: PUSH
87695: LD_VAR 0 2
87699: NOT
87700: OR
87701: IFFALSE 87705
// exit ;
87703: GO 87730
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
87705: LD_ADDR_EXP 49
87709: PUSH
87710: LD_EXP 49
87714: PPUSH
87715: LD_VAR 0 1
87719: PPUSH
87720: LD_VAR 0 2
87724: PPUSH
87725: CALL_OW 1
87729: ST_TO_ADDR
// end ;
87730: LD_VAR 0 3
87734: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
87735: LD_INT 0
87737: PPUSH
// if not mc_bases or not base or not teleports_exit then
87738: LD_EXP 31
87742: NOT
87743: PUSH
87744: LD_VAR 0 1
87748: NOT
87749: OR
87750: PUSH
87751: LD_VAR 0 2
87755: NOT
87756: OR
87757: IFFALSE 87761
// exit ;
87759: GO 87786
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
87761: LD_ADDR_EXP 66
87765: PUSH
87766: LD_EXP 66
87770: PPUSH
87771: LD_VAR 0 1
87775: PPUSH
87776: LD_VAR 0 2
87780: PPUSH
87781: CALL_OW 1
87785: ST_TO_ADDR
// end ;
87786: LD_VAR 0 3
87790: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
87791: LD_INT 0
87793: PPUSH
87794: PPUSH
87795: PPUSH
// if not mc_bases or not base or not ext_list then
87796: LD_EXP 31
87800: NOT
87801: PUSH
87802: LD_VAR 0 1
87806: NOT
87807: OR
87808: PUSH
87809: LD_VAR 0 5
87813: NOT
87814: OR
87815: IFFALSE 87819
// exit ;
87817: GO 87992
// tmp := GetFacExtXYD ( x , y , d ) ;
87819: LD_ADDR_VAR 0 8
87823: PUSH
87824: LD_VAR 0 2
87828: PPUSH
87829: LD_VAR 0 3
87833: PPUSH
87834: LD_VAR 0 4
87838: PPUSH
87839: CALL 55164 0 3
87843: ST_TO_ADDR
// if not tmp then
87844: LD_VAR 0 8
87848: NOT
87849: IFFALSE 87853
// exit ;
87851: GO 87992
// for i in tmp do
87853: LD_ADDR_VAR 0 7
87857: PUSH
87858: LD_VAR 0 8
87862: PUSH
87863: FOR_IN
87864: IFFALSE 87990
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
87866: LD_ADDR_EXP 36
87870: PUSH
87871: LD_EXP 36
87875: PPUSH
87876: LD_VAR 0 1
87880: PPUSH
87881: LD_EXP 36
87885: PUSH
87886: LD_VAR 0 1
87890: ARRAY
87891: PPUSH
87892: LD_EXP 36
87896: PUSH
87897: LD_VAR 0 1
87901: ARRAY
87902: PUSH
87903: LD_INT 1
87905: PLUS
87906: PPUSH
87907: LD_VAR 0 5
87911: PUSH
87912: LD_INT 1
87914: ARRAY
87915: PUSH
87916: LD_VAR 0 7
87920: PUSH
87921: LD_INT 1
87923: ARRAY
87924: PUSH
87925: LD_VAR 0 7
87929: PUSH
87930: LD_INT 2
87932: ARRAY
87933: PUSH
87934: LD_VAR 0 7
87938: PUSH
87939: LD_INT 3
87941: ARRAY
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: PPUSH
87949: CALL_OW 2
87953: PPUSH
87954: CALL_OW 1
87958: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
87959: LD_ADDR_VAR 0 5
87963: PUSH
87964: LD_VAR 0 5
87968: PPUSH
87969: LD_INT 1
87971: PPUSH
87972: CALL_OW 3
87976: ST_TO_ADDR
// if not ext_list then
87977: LD_VAR 0 5
87981: NOT
87982: IFFALSE 87988
// exit ;
87984: POP
87985: POP
87986: GO 87992
// end ;
87988: GO 87863
87990: POP
87991: POP
// end ;
87992: LD_VAR 0 6
87996: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
87997: LD_INT 0
87999: PPUSH
// if not mc_bases or not base or not weapon_list then
88000: LD_EXP 31
88004: NOT
88005: PUSH
88006: LD_VAR 0 1
88010: NOT
88011: OR
88012: PUSH
88013: LD_VAR 0 2
88017: NOT
88018: OR
88019: IFFALSE 88023
// exit ;
88021: GO 88048
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
88023: LD_ADDR_EXP 70
88027: PUSH
88028: LD_EXP 70
88032: PPUSH
88033: LD_VAR 0 1
88037: PPUSH
88038: LD_VAR 0 2
88042: PPUSH
88043: CALL_OW 1
88047: ST_TO_ADDR
// end ;
88048: LD_VAR 0 3
88052: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
88053: LD_INT 0
88055: PPUSH
// if not mc_bases or not base or not tech_list then
88056: LD_EXP 31
88060: NOT
88061: PUSH
88062: LD_VAR 0 1
88066: NOT
88067: OR
88068: PUSH
88069: LD_VAR 0 2
88073: NOT
88074: OR
88075: IFFALSE 88079
// exit ;
88077: GO 88104
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
88079: LD_ADDR_EXP 58
88083: PUSH
88084: LD_EXP 58
88088: PPUSH
88089: LD_VAR 0 1
88093: PPUSH
88094: LD_VAR 0 2
88098: PPUSH
88099: CALL_OW 1
88103: ST_TO_ADDR
// end ;
88104: LD_VAR 0 3
88108: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
88109: LD_INT 0
88111: PPUSH
// if not mc_bases or not parking_area or not base then
88112: LD_EXP 31
88116: NOT
88117: PUSH
88118: LD_VAR 0 2
88122: NOT
88123: OR
88124: PUSH
88125: LD_VAR 0 1
88129: NOT
88130: OR
88131: IFFALSE 88135
// exit ;
88133: GO 88160
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
88135: LD_ADDR_EXP 55
88139: PUSH
88140: LD_EXP 55
88144: PPUSH
88145: LD_VAR 0 1
88149: PPUSH
88150: LD_VAR 0 2
88154: PPUSH
88155: CALL_OW 1
88159: ST_TO_ADDR
// end ;
88160: LD_VAR 0 3
88164: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
88165: LD_INT 0
88167: PPUSH
// if not mc_bases or not base or not scan_area then
88168: LD_EXP 31
88172: NOT
88173: PUSH
88174: LD_VAR 0 1
88178: NOT
88179: OR
88180: PUSH
88181: LD_VAR 0 2
88185: NOT
88186: OR
88187: IFFALSE 88191
// exit ;
88189: GO 88216
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
88191: LD_ADDR_EXP 56
88195: PUSH
88196: LD_EXP 56
88200: PPUSH
88201: LD_VAR 0 1
88205: PPUSH
88206: LD_VAR 0 2
88210: PPUSH
88211: CALL_OW 1
88215: ST_TO_ADDR
// end ;
88216: LD_VAR 0 3
88220: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
88221: LD_INT 0
88223: PPUSH
88224: PPUSH
// if not mc_bases or not base then
88225: LD_EXP 31
88229: NOT
88230: PUSH
88231: LD_VAR 0 1
88235: NOT
88236: OR
88237: IFFALSE 88241
// exit ;
88239: GO 88305
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
88241: LD_ADDR_VAR 0 3
88245: PUSH
88246: LD_INT 1
88248: PUSH
88249: LD_INT 2
88251: PUSH
88252: LD_INT 3
88254: PUSH
88255: LD_INT 4
88257: PUSH
88258: LD_INT 11
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
88268: LD_ADDR_EXP 58
88272: PUSH
88273: LD_EXP 58
88277: PPUSH
88278: LD_VAR 0 1
88282: PPUSH
88283: LD_EXP 58
88287: PUSH
88288: LD_VAR 0 1
88292: ARRAY
88293: PUSH
88294: LD_VAR 0 3
88298: DIFF
88299: PPUSH
88300: CALL_OW 1
88304: ST_TO_ADDR
// end ;
88305: LD_VAR 0 2
88309: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
88310: LD_INT 0
88312: PPUSH
// result := mc_vehicles [ base ] ;
88313: LD_ADDR_VAR 0 3
88317: PUSH
88318: LD_EXP 50
88322: PUSH
88323: LD_VAR 0 1
88327: ARRAY
88328: ST_TO_ADDR
// if onlyCombat then
88329: LD_VAR 0 2
88333: IFFALSE 88505
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
88335: LD_ADDR_VAR 0 3
88339: PUSH
88340: LD_VAR 0 3
88344: PUSH
88345: LD_VAR 0 3
88349: PPUSH
88350: LD_INT 2
88352: PUSH
88353: LD_INT 34
88355: PUSH
88356: LD_INT 12
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 34
88365: PUSH
88366: LD_INT 51
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 34
88375: PUSH
88376: LD_INT 89
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 34
88385: PUSH
88386: LD_INT 32
88388: PUSH
88389: EMPTY
88390: LIST
88391: LIST
88392: PUSH
88393: LD_INT 34
88395: PUSH
88396: LD_INT 13
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: PUSH
88403: LD_INT 34
88405: PUSH
88406: LD_INT 52
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: PUSH
88413: LD_INT 34
88415: PUSH
88416: LD_INT 88
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 34
88425: PUSH
88426: LD_INT 14
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 34
88435: PUSH
88436: LD_INT 53
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 34
88445: PUSH
88446: LD_INT 98
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 34
88455: PUSH
88456: LD_INT 31
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 34
88465: PUSH
88466: LD_INT 48
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 34
88475: PUSH
88476: LD_INT 8
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: PPUSH
88499: CALL_OW 72
88503: DIFF
88504: ST_TO_ADDR
// end ; end_of_file
88505: LD_VAR 0 3
88509: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
88510: LD_INT 0
88512: PPUSH
88513: PPUSH
88514: PPUSH
// if not mc_bases or not skirmish then
88515: LD_EXP 31
88519: NOT
88520: PUSH
88521: LD_EXP 29
88525: NOT
88526: OR
88527: IFFALSE 88531
// exit ;
88529: GO 88696
// for i = 1 to mc_bases do
88531: LD_ADDR_VAR 0 4
88535: PUSH
88536: DOUBLE
88537: LD_INT 1
88539: DEC
88540: ST_TO_ADDR
88541: LD_EXP 31
88545: PUSH
88546: FOR_TO
88547: IFFALSE 88694
// begin if sci in mc_bases [ i ] then
88549: LD_VAR 0 2
88553: PUSH
88554: LD_EXP 31
88558: PUSH
88559: LD_VAR 0 4
88563: ARRAY
88564: IN
88565: IFFALSE 88692
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
88567: LD_ADDR_EXP 60
88571: PUSH
88572: LD_EXP 60
88576: PPUSH
88577: LD_VAR 0 4
88581: PUSH
88582: LD_EXP 60
88586: PUSH
88587: LD_VAR 0 4
88591: ARRAY
88592: PUSH
88593: LD_INT 1
88595: PLUS
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PPUSH
88601: LD_VAR 0 1
88605: PPUSH
88606: CALL 24801 0 3
88610: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
88611: LD_ADDR_VAR 0 5
88615: PUSH
88616: LD_EXP 31
88620: PUSH
88621: LD_VAR 0 4
88625: ARRAY
88626: PPUSH
88627: LD_INT 2
88629: PUSH
88630: LD_INT 30
88632: PUSH
88633: LD_INT 0
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 30
88642: PUSH
88643: LD_INT 1
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: LIST
88654: PPUSH
88655: CALL_OW 72
88659: PPUSH
88660: LD_VAR 0 1
88664: PPUSH
88665: CALL_OW 74
88669: ST_TO_ADDR
// if tmp then
88670: LD_VAR 0 5
88674: IFFALSE 88690
// ComStandNearbyBuilding ( ape , tmp ) ;
88676: LD_VAR 0 1
88680: PPUSH
88681: LD_VAR 0 5
88685: PPUSH
88686: CALL 21403 0 2
// break ;
88690: GO 88694
// end ; end ;
88692: GO 88546
88694: POP
88695: POP
// end ;
88696: LD_VAR 0 3
88700: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
88701: LD_INT 0
88703: PPUSH
88704: PPUSH
88705: PPUSH
// if not mc_bases or not skirmish then
88706: LD_EXP 31
88710: NOT
88711: PUSH
88712: LD_EXP 29
88716: NOT
88717: OR
88718: IFFALSE 88722
// exit ;
88720: GO 88811
// for i = 1 to mc_bases do
88722: LD_ADDR_VAR 0 4
88726: PUSH
88727: DOUBLE
88728: LD_INT 1
88730: DEC
88731: ST_TO_ADDR
88732: LD_EXP 31
88736: PUSH
88737: FOR_TO
88738: IFFALSE 88809
// begin if building in mc_busy_turret_list [ i ] then
88740: LD_VAR 0 1
88744: PUSH
88745: LD_EXP 41
88749: PUSH
88750: LD_VAR 0 4
88754: ARRAY
88755: IN
88756: IFFALSE 88807
// begin tmp := mc_busy_turret_list [ i ] diff building ;
88758: LD_ADDR_VAR 0 5
88762: PUSH
88763: LD_EXP 41
88767: PUSH
88768: LD_VAR 0 4
88772: ARRAY
88773: PUSH
88774: LD_VAR 0 1
88778: DIFF
88779: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
88780: LD_ADDR_EXP 41
88784: PUSH
88785: LD_EXP 41
88789: PPUSH
88790: LD_VAR 0 4
88794: PPUSH
88795: LD_VAR 0 5
88799: PPUSH
88800: CALL_OW 1
88804: ST_TO_ADDR
// break ;
88805: GO 88809
// end ; end ;
88807: GO 88737
88809: POP
88810: POP
// end ;
88811: LD_VAR 0 3
88815: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
88816: LD_INT 0
88818: PPUSH
88819: PPUSH
88820: PPUSH
// if not mc_bases or not skirmish then
88821: LD_EXP 31
88825: NOT
88826: PUSH
88827: LD_EXP 29
88831: NOT
88832: OR
88833: IFFALSE 88837
// exit ;
88835: GO 89036
// for i = 1 to mc_bases do
88837: LD_ADDR_VAR 0 5
88841: PUSH
88842: DOUBLE
88843: LD_INT 1
88845: DEC
88846: ST_TO_ADDR
88847: LD_EXP 31
88851: PUSH
88852: FOR_TO
88853: IFFALSE 89034
// if building in mc_bases [ i ] then
88855: LD_VAR 0 1
88859: PUSH
88860: LD_EXP 31
88864: PUSH
88865: LD_VAR 0 5
88869: ARRAY
88870: IN
88871: IFFALSE 89032
// begin tmp := mc_bases [ i ] diff building ;
88873: LD_ADDR_VAR 0 6
88877: PUSH
88878: LD_EXP 31
88882: PUSH
88883: LD_VAR 0 5
88887: ARRAY
88888: PUSH
88889: LD_VAR 0 1
88893: DIFF
88894: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
88895: LD_ADDR_EXP 31
88899: PUSH
88900: LD_EXP 31
88904: PPUSH
88905: LD_VAR 0 5
88909: PPUSH
88910: LD_VAR 0 6
88914: PPUSH
88915: CALL_OW 1
88919: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
88920: LD_VAR 0 1
88924: PUSH
88925: LD_EXP 39
88929: PUSH
88930: LD_VAR 0 5
88934: ARRAY
88935: IN
88936: IFFALSE 88975
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
88938: LD_ADDR_EXP 39
88942: PUSH
88943: LD_EXP 39
88947: PPUSH
88948: LD_VAR 0 5
88952: PPUSH
88953: LD_EXP 39
88957: PUSH
88958: LD_VAR 0 5
88962: ARRAY
88963: PUSH
88964: LD_VAR 0 1
88968: DIFF
88969: PPUSH
88970: CALL_OW 1
88974: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
88975: LD_VAR 0 1
88979: PUSH
88980: LD_EXP 40
88984: PUSH
88985: LD_VAR 0 5
88989: ARRAY
88990: IN
88991: IFFALSE 89030
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
88993: LD_ADDR_EXP 40
88997: PUSH
88998: LD_EXP 40
89002: PPUSH
89003: LD_VAR 0 5
89007: PPUSH
89008: LD_EXP 40
89012: PUSH
89013: LD_VAR 0 5
89017: ARRAY
89018: PUSH
89019: LD_VAR 0 1
89023: DIFF
89024: PPUSH
89025: CALL_OW 1
89029: ST_TO_ADDR
// break ;
89030: GO 89034
// end ;
89032: GO 88852
89034: POP
89035: POP
// end ;
89036: LD_VAR 0 4
89040: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
89041: LD_INT 0
89043: PPUSH
89044: PPUSH
89045: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
89046: LD_EXP 31
89050: NOT
89051: PUSH
89052: LD_EXP 29
89056: NOT
89057: OR
89058: PUSH
89059: LD_VAR 0 3
89063: PUSH
89064: LD_EXP 57
89068: IN
89069: NOT
89070: OR
89071: IFFALSE 89075
// exit ;
89073: GO 89198
// for i = 1 to mc_vehicles do
89075: LD_ADDR_VAR 0 6
89079: PUSH
89080: DOUBLE
89081: LD_INT 1
89083: DEC
89084: ST_TO_ADDR
89085: LD_EXP 50
89089: PUSH
89090: FOR_TO
89091: IFFALSE 89196
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
89093: LD_VAR 0 2
89097: PUSH
89098: LD_EXP 50
89102: PUSH
89103: LD_VAR 0 6
89107: ARRAY
89108: IN
89109: PUSH
89110: LD_VAR 0 1
89114: PUSH
89115: LD_EXP 50
89119: PUSH
89120: LD_VAR 0 6
89124: ARRAY
89125: IN
89126: OR
89127: IFFALSE 89194
// begin tmp := mc_vehicles [ i ] diff old ;
89129: LD_ADDR_VAR 0 7
89133: PUSH
89134: LD_EXP 50
89138: PUSH
89139: LD_VAR 0 6
89143: ARRAY
89144: PUSH
89145: LD_VAR 0 2
89149: DIFF
89150: ST_TO_ADDR
// tmp := tmp diff new ;
89151: LD_ADDR_VAR 0 7
89155: PUSH
89156: LD_VAR 0 7
89160: PUSH
89161: LD_VAR 0 1
89165: DIFF
89166: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
89167: LD_ADDR_EXP 50
89171: PUSH
89172: LD_EXP 50
89176: PPUSH
89177: LD_VAR 0 6
89181: PPUSH
89182: LD_VAR 0 7
89186: PPUSH
89187: CALL_OW 1
89191: ST_TO_ADDR
// break ;
89192: GO 89196
// end ;
89194: GO 89090
89196: POP
89197: POP
// end ;
89198: LD_VAR 0 5
89202: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
89203: LD_INT 0
89205: PPUSH
89206: PPUSH
89207: PPUSH
89208: PPUSH
// if not mc_bases or not skirmish then
89209: LD_EXP 31
89213: NOT
89214: PUSH
89215: LD_EXP 29
89219: NOT
89220: OR
89221: IFFALSE 89225
// exit ;
89223: GO 89645
// repeat wait ( 0 0$1 ) ;
89225: LD_INT 35
89227: PPUSH
89228: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
89232: LD_EXP 75
89236: NOT
89237: IFFALSE 89225
// mc_block_vehicle_constructed_thread := true ;
89239: LD_ADDR_EXP 75
89243: PUSH
89244: LD_INT 1
89246: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
89247: LD_ADDR_VAR 0 5
89251: PUSH
89252: LD_VAR 0 1
89256: PPUSH
89257: CALL_OW 255
89261: ST_TO_ADDR
// for i = 1 to mc_bases do
89262: LD_ADDR_VAR 0 4
89266: PUSH
89267: DOUBLE
89268: LD_INT 1
89270: DEC
89271: ST_TO_ADDR
89272: LD_EXP 31
89276: PUSH
89277: FOR_TO
89278: IFFALSE 89635
// begin if factory in mc_bases [ i ] then
89280: LD_VAR 0 2
89284: PUSH
89285: LD_EXP 31
89289: PUSH
89290: LD_VAR 0 4
89294: ARRAY
89295: IN
89296: IFFALSE 89633
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
89298: LD_EXP 53
89302: PUSH
89303: LD_VAR 0 4
89307: ARRAY
89308: PUSH
89309: LD_EXP 42
89313: PUSH
89314: LD_VAR 0 4
89318: ARRAY
89319: LESS
89320: PUSH
89321: LD_VAR 0 1
89325: PPUSH
89326: CALL_OW 264
89330: PUSH
89331: LD_INT 31
89333: PUSH
89334: LD_INT 32
89336: PUSH
89337: LD_INT 51
89339: PUSH
89340: LD_INT 89
89342: PUSH
89343: LD_INT 12
89345: PUSH
89346: LD_INT 30
89348: PUSH
89349: LD_INT 98
89351: PUSH
89352: LD_INT 11
89354: PUSH
89355: LD_INT 53
89357: PUSH
89358: LD_INT 14
89360: PUSH
89361: LD_INT 91
89363: PUSH
89364: LD_INT 29
89366: PUSH
89367: LD_INT 99
89369: PUSH
89370: LD_INT 13
89372: PUSH
89373: LD_INT 52
89375: PUSH
89376: LD_INT 88
89378: PUSH
89379: LD_INT 48
89381: PUSH
89382: LD_INT 8
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: IN
89405: NOT
89406: AND
89407: IFFALSE 89455
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
89409: LD_ADDR_EXP 53
89413: PUSH
89414: LD_EXP 53
89418: PPUSH
89419: LD_VAR 0 4
89423: PUSH
89424: LD_EXP 53
89428: PUSH
89429: LD_VAR 0 4
89433: ARRAY
89434: PUSH
89435: LD_INT 1
89437: PLUS
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PPUSH
89443: LD_VAR 0 1
89447: PPUSH
89448: CALL 24801 0 3
89452: ST_TO_ADDR
89453: GO 89499
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
89455: LD_ADDR_EXP 50
89459: PUSH
89460: LD_EXP 50
89464: PPUSH
89465: LD_VAR 0 4
89469: PUSH
89470: LD_EXP 50
89474: PUSH
89475: LD_VAR 0 4
89479: ARRAY
89480: PUSH
89481: LD_INT 1
89483: PLUS
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PPUSH
89489: LD_VAR 0 1
89493: PPUSH
89494: CALL 24801 0 3
89498: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
89499: LD_ADDR_EXP 75
89503: PUSH
89504: LD_INT 0
89506: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
89507: LD_VAR 0 1
89511: PPUSH
89512: CALL_OW 263
89516: PUSH
89517: LD_INT 2
89519: EQUAL
89520: IFFALSE 89549
// begin repeat wait ( 0 0$3 ) ;
89522: LD_INT 105
89524: PPUSH
89525: CALL_OW 67
// Connect ( vehicle ) ;
89529: LD_VAR 0 1
89533: PPUSH
89534: CALL 28147 0 1
// until IsControledBy ( vehicle ) ;
89538: LD_VAR 0 1
89542: PPUSH
89543: CALL_OW 312
89547: IFFALSE 89522
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
89549: LD_VAR 0 1
89553: PPUSH
89554: LD_EXP 55
89558: PUSH
89559: LD_VAR 0 4
89563: ARRAY
89564: PPUSH
89565: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
89569: LD_VAR 0 1
89573: PPUSH
89574: CALL_OW 263
89578: PUSH
89579: LD_INT 1
89581: NONEQUAL
89582: IFFALSE 89586
// break ;
89584: GO 89635
// repeat wait ( 0 0$1 ) ;
89586: LD_INT 35
89588: PPUSH
89589: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
89593: LD_VAR 0 1
89597: PPUSH
89598: LD_EXP 55
89602: PUSH
89603: LD_VAR 0 4
89607: ARRAY
89608: PPUSH
89609: CALL_OW 308
89613: IFFALSE 89586
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
89615: LD_VAR 0 1
89619: PPUSH
89620: CALL_OW 311
89624: PPUSH
89625: CALL_OW 121
// exit ;
89629: POP
89630: POP
89631: GO 89645
// end ; end ;
89633: GO 89277
89635: POP
89636: POP
// mc_block_vehicle_constructed_thread := false ;
89637: LD_ADDR_EXP 75
89641: PUSH
89642: LD_INT 0
89644: ST_TO_ADDR
// end ;
89645: LD_VAR 0 3
89649: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
89650: LD_INT 0
89652: PPUSH
89653: PPUSH
89654: PPUSH
89655: PPUSH
// if not mc_bases or not skirmish then
89656: LD_EXP 31
89660: NOT
89661: PUSH
89662: LD_EXP 29
89666: NOT
89667: OR
89668: IFFALSE 89672
// exit ;
89670: GO 90025
// repeat wait ( 0 0$1 ) ;
89672: LD_INT 35
89674: PPUSH
89675: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
89679: LD_VAR 0 2
89683: PPUSH
89684: LD_VAR 0 3
89688: PPUSH
89689: CALL_OW 284
89693: IFFALSE 89672
// if GetResourceTypeXY ( x , y ) = mat_artefact then
89695: LD_VAR 0 2
89699: PPUSH
89700: LD_VAR 0 3
89704: PPUSH
89705: CALL_OW 283
89709: PUSH
89710: LD_INT 4
89712: EQUAL
89713: IFFALSE 89717
// exit ;
89715: GO 90025
// for i = 1 to mc_bases do
89717: LD_ADDR_VAR 0 7
89721: PUSH
89722: DOUBLE
89723: LD_INT 1
89725: DEC
89726: ST_TO_ADDR
89727: LD_EXP 31
89731: PUSH
89732: FOR_TO
89733: IFFALSE 90023
// begin if mc_crates_area [ i ] then
89735: LD_EXP 49
89739: PUSH
89740: LD_VAR 0 7
89744: ARRAY
89745: IFFALSE 89856
// for j in mc_crates_area [ i ] do
89747: LD_ADDR_VAR 0 8
89751: PUSH
89752: LD_EXP 49
89756: PUSH
89757: LD_VAR 0 7
89761: ARRAY
89762: PUSH
89763: FOR_IN
89764: IFFALSE 89854
// if InArea ( x , y , j ) then
89766: LD_VAR 0 2
89770: PPUSH
89771: LD_VAR 0 3
89775: PPUSH
89776: LD_VAR 0 8
89780: PPUSH
89781: CALL_OW 309
89785: IFFALSE 89852
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
89787: LD_ADDR_EXP 47
89791: PUSH
89792: LD_EXP 47
89796: PPUSH
89797: LD_VAR 0 7
89801: PUSH
89802: LD_EXP 47
89806: PUSH
89807: LD_VAR 0 7
89811: ARRAY
89812: PUSH
89813: LD_INT 1
89815: PLUS
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PPUSH
89821: LD_VAR 0 4
89825: PUSH
89826: LD_VAR 0 2
89830: PUSH
89831: LD_VAR 0 3
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: LIST
89840: PPUSH
89841: CALL 24801 0 3
89845: ST_TO_ADDR
// exit ;
89846: POP
89847: POP
89848: POP
89849: POP
89850: GO 90025
// end ;
89852: GO 89763
89854: POP
89855: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89856: LD_ADDR_VAR 0 9
89860: PUSH
89861: LD_EXP 31
89865: PUSH
89866: LD_VAR 0 7
89870: ARRAY
89871: PPUSH
89872: LD_INT 2
89874: PUSH
89875: LD_INT 30
89877: PUSH
89878: LD_INT 0
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: LD_INT 30
89887: PUSH
89888: LD_INT 1
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: LIST
89899: PPUSH
89900: CALL_OW 72
89904: ST_TO_ADDR
// if not depot then
89905: LD_VAR 0 9
89909: NOT
89910: IFFALSE 89914
// continue ;
89912: GO 89732
// for j in depot do
89914: LD_ADDR_VAR 0 8
89918: PUSH
89919: LD_VAR 0 9
89923: PUSH
89924: FOR_IN
89925: IFFALSE 90019
// if GetDistUnitXY ( j , x , y ) < 30 then
89927: LD_VAR 0 8
89931: PPUSH
89932: LD_VAR 0 2
89936: PPUSH
89937: LD_VAR 0 3
89941: PPUSH
89942: CALL_OW 297
89946: PUSH
89947: LD_INT 30
89949: LESS
89950: IFFALSE 90017
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
89952: LD_ADDR_EXP 47
89956: PUSH
89957: LD_EXP 47
89961: PPUSH
89962: LD_VAR 0 7
89966: PUSH
89967: LD_EXP 47
89971: PUSH
89972: LD_VAR 0 7
89976: ARRAY
89977: PUSH
89978: LD_INT 1
89980: PLUS
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PPUSH
89986: LD_VAR 0 4
89990: PUSH
89991: LD_VAR 0 2
89995: PUSH
89996: LD_VAR 0 3
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: LIST
90005: PPUSH
90006: CALL 24801 0 3
90010: ST_TO_ADDR
// exit ;
90011: POP
90012: POP
90013: POP
90014: POP
90015: GO 90025
// end ;
90017: GO 89924
90019: POP
90020: POP
// end ;
90021: GO 89732
90023: POP
90024: POP
// end ;
90025: LD_VAR 0 6
90029: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
90030: LD_INT 0
90032: PPUSH
90033: PPUSH
90034: PPUSH
90035: PPUSH
// if not mc_bases or not skirmish then
90036: LD_EXP 31
90040: NOT
90041: PUSH
90042: LD_EXP 29
90046: NOT
90047: OR
90048: IFFALSE 90052
// exit ;
90050: GO 90329
// side := GetSide ( lab ) ;
90052: LD_ADDR_VAR 0 4
90056: PUSH
90057: LD_VAR 0 2
90061: PPUSH
90062: CALL_OW 255
90066: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
90067: LD_VAR 0 4
90071: PUSH
90072: LD_EXP 57
90076: IN
90077: NOT
90078: PUSH
90079: LD_EXP 58
90083: NOT
90084: OR
90085: PUSH
90086: LD_EXP 31
90090: NOT
90091: OR
90092: IFFALSE 90096
// exit ;
90094: GO 90329
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
90096: LD_ADDR_EXP 58
90100: PUSH
90101: LD_EXP 58
90105: PPUSH
90106: LD_VAR 0 4
90110: PPUSH
90111: LD_EXP 58
90115: PUSH
90116: LD_VAR 0 4
90120: ARRAY
90121: PUSH
90122: LD_VAR 0 1
90126: DIFF
90127: PPUSH
90128: CALL_OW 1
90132: ST_TO_ADDR
// for i = 1 to mc_bases do
90133: LD_ADDR_VAR 0 5
90137: PUSH
90138: DOUBLE
90139: LD_INT 1
90141: DEC
90142: ST_TO_ADDR
90143: LD_EXP 31
90147: PUSH
90148: FOR_TO
90149: IFFALSE 90327
// begin if lab in mc_bases [ i ] then
90151: LD_VAR 0 2
90155: PUSH
90156: LD_EXP 31
90160: PUSH
90161: LD_VAR 0 5
90165: ARRAY
90166: IN
90167: IFFALSE 90325
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
90169: LD_VAR 0 1
90173: PUSH
90174: LD_INT 11
90176: PUSH
90177: LD_INT 4
90179: PUSH
90180: LD_INT 3
90182: PUSH
90183: LD_INT 2
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: IN
90192: PUSH
90193: LD_EXP 61
90197: PUSH
90198: LD_VAR 0 5
90202: ARRAY
90203: AND
90204: IFFALSE 90325
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
90206: LD_ADDR_VAR 0 6
90210: PUSH
90211: LD_EXP 61
90215: PUSH
90216: LD_VAR 0 5
90220: ARRAY
90221: PUSH
90222: LD_INT 1
90224: ARRAY
90225: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
90226: LD_ADDR_EXP 61
90230: PUSH
90231: LD_EXP 61
90235: PPUSH
90236: LD_VAR 0 5
90240: PPUSH
90241: EMPTY
90242: PPUSH
90243: CALL_OW 1
90247: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
90248: LD_VAR 0 6
90252: PPUSH
90253: LD_INT 0
90255: PPUSH
90256: CALL_OW 109
// ComExitBuilding ( tmp ) ;
90260: LD_VAR 0 6
90264: PPUSH
90265: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
90269: LD_ADDR_EXP 60
90273: PUSH
90274: LD_EXP 60
90278: PPUSH
90279: LD_VAR 0 5
90283: PPUSH
90284: LD_EXP 60
90288: PUSH
90289: LD_VAR 0 5
90293: ARRAY
90294: PPUSH
90295: LD_INT 1
90297: PPUSH
90298: LD_VAR 0 6
90302: PPUSH
90303: CALL_OW 2
90307: PPUSH
90308: CALL_OW 1
90312: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
90313: LD_VAR 0 5
90317: PPUSH
90318: LD_INT 112
90320: PPUSH
90321: CALL 66779 0 2
// end ; end ; end ;
90325: GO 90148
90327: POP
90328: POP
// end ;
90329: LD_VAR 0 3
90333: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
90334: LD_INT 0
90336: PPUSH
90337: PPUSH
90338: PPUSH
90339: PPUSH
90340: PPUSH
90341: PPUSH
90342: PPUSH
90343: PPUSH
// if not mc_bases or not skirmish then
90344: LD_EXP 31
90348: NOT
90349: PUSH
90350: LD_EXP 29
90354: NOT
90355: OR
90356: IFFALSE 90360
// exit ;
90358: GO 91729
// for i = 1 to mc_bases do
90360: LD_ADDR_VAR 0 3
90364: PUSH
90365: DOUBLE
90366: LD_INT 1
90368: DEC
90369: ST_TO_ADDR
90370: LD_EXP 31
90374: PUSH
90375: FOR_TO
90376: IFFALSE 91727
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
90378: LD_VAR 0 1
90382: PUSH
90383: LD_EXP 31
90387: PUSH
90388: LD_VAR 0 3
90392: ARRAY
90393: IN
90394: PUSH
90395: LD_VAR 0 1
90399: PUSH
90400: LD_EXP 38
90404: PUSH
90405: LD_VAR 0 3
90409: ARRAY
90410: IN
90411: OR
90412: PUSH
90413: LD_VAR 0 1
90417: PUSH
90418: LD_EXP 53
90422: PUSH
90423: LD_VAR 0 3
90427: ARRAY
90428: IN
90429: OR
90430: PUSH
90431: LD_VAR 0 1
90435: PUSH
90436: LD_EXP 50
90440: PUSH
90441: LD_VAR 0 3
90445: ARRAY
90446: IN
90447: OR
90448: PUSH
90449: LD_VAR 0 1
90453: PUSH
90454: LD_EXP 60
90458: PUSH
90459: LD_VAR 0 3
90463: ARRAY
90464: IN
90465: OR
90466: PUSH
90467: LD_VAR 0 1
90471: PUSH
90472: LD_EXP 61
90476: PUSH
90477: LD_VAR 0 3
90481: ARRAY
90482: IN
90483: OR
90484: IFFALSE 91725
// begin if un in mc_ape [ i ] then
90486: LD_VAR 0 1
90490: PUSH
90491: LD_EXP 60
90495: PUSH
90496: LD_VAR 0 3
90500: ARRAY
90501: IN
90502: IFFALSE 90541
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
90504: LD_ADDR_EXP 60
90508: PUSH
90509: LD_EXP 60
90513: PPUSH
90514: LD_VAR 0 3
90518: PPUSH
90519: LD_EXP 60
90523: PUSH
90524: LD_VAR 0 3
90528: ARRAY
90529: PUSH
90530: LD_VAR 0 1
90534: DIFF
90535: PPUSH
90536: CALL_OW 1
90540: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
90541: LD_VAR 0 1
90545: PUSH
90546: LD_EXP 61
90550: PUSH
90551: LD_VAR 0 3
90555: ARRAY
90556: IN
90557: IFFALSE 90581
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
90559: LD_ADDR_EXP 61
90563: PUSH
90564: LD_EXP 61
90568: PPUSH
90569: LD_VAR 0 3
90573: PPUSH
90574: EMPTY
90575: PPUSH
90576: CALL_OW 1
90580: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
90581: LD_VAR 0 1
90585: PPUSH
90586: CALL_OW 247
90590: PUSH
90591: LD_INT 2
90593: EQUAL
90594: PUSH
90595: LD_VAR 0 1
90599: PPUSH
90600: CALL_OW 110
90604: PUSH
90605: LD_INT 20
90607: EQUAL
90608: PUSH
90609: LD_VAR 0 1
90613: PUSH
90614: LD_EXP 53
90618: PUSH
90619: LD_VAR 0 3
90623: ARRAY
90624: IN
90625: OR
90626: PUSH
90627: LD_VAR 0 1
90631: PPUSH
90632: CALL_OW 264
90636: PUSH
90637: LD_INT 12
90639: PUSH
90640: LD_INT 51
90642: PUSH
90643: LD_INT 89
90645: PUSH
90646: LD_INT 32
90648: PUSH
90649: LD_INT 13
90651: PUSH
90652: LD_INT 52
90654: PUSH
90655: LD_INT 31
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: IN
90667: OR
90668: AND
90669: IFFALSE 90977
// begin if un in mc_defender [ i ] then
90671: LD_VAR 0 1
90675: PUSH
90676: LD_EXP 53
90680: PUSH
90681: LD_VAR 0 3
90685: ARRAY
90686: IN
90687: IFFALSE 90726
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90689: LD_ADDR_EXP 53
90693: PUSH
90694: LD_EXP 53
90698: PPUSH
90699: LD_VAR 0 3
90703: PPUSH
90704: LD_EXP 53
90708: PUSH
90709: LD_VAR 0 3
90713: ARRAY
90714: PUSH
90715: LD_VAR 0 1
90719: DIFF
90720: PPUSH
90721: CALL_OW 1
90725: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
90726: LD_ADDR_VAR 0 8
90730: PUSH
90731: LD_VAR 0 3
90735: PPUSH
90736: LD_INT 3
90738: PPUSH
90739: CALL 87347 0 2
90743: ST_TO_ADDR
// if fac then
90744: LD_VAR 0 8
90748: IFFALSE 90977
// begin for j in fac do
90750: LD_ADDR_VAR 0 4
90754: PUSH
90755: LD_VAR 0 8
90759: PUSH
90760: FOR_IN
90761: IFFALSE 90975
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
90763: LD_ADDR_VAR 0 9
90767: PUSH
90768: LD_VAR 0 8
90772: PPUSH
90773: LD_VAR 0 1
90777: PPUSH
90778: CALL_OW 265
90782: PPUSH
90783: LD_VAR 0 1
90787: PPUSH
90788: CALL_OW 262
90792: PPUSH
90793: LD_VAR 0 1
90797: PPUSH
90798: CALL_OW 263
90802: PPUSH
90803: LD_VAR 0 1
90807: PPUSH
90808: CALL_OW 264
90812: PPUSH
90813: CALL 22299 0 5
90817: ST_TO_ADDR
// if components then
90818: LD_VAR 0 9
90822: IFFALSE 90973
// begin if GetWeapon ( un ) = ar_control_tower then
90824: LD_VAR 0 1
90828: PPUSH
90829: CALL_OW 264
90833: PUSH
90834: LD_INT 31
90836: EQUAL
90837: IFFALSE 90954
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
90839: LD_VAR 0 1
90843: PPUSH
90844: CALL_OW 311
90848: PPUSH
90849: LD_INT 0
90851: PPUSH
90852: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
90856: LD_ADDR_EXP 71
90860: PUSH
90861: LD_EXP 71
90865: PPUSH
90866: LD_VAR 0 3
90870: PPUSH
90871: LD_EXP 71
90875: PUSH
90876: LD_VAR 0 3
90880: ARRAY
90881: PUSH
90882: LD_VAR 0 1
90886: PPUSH
90887: CALL_OW 311
90891: DIFF
90892: PPUSH
90893: CALL_OW 1
90897: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
90898: LD_ADDR_VAR 0 7
90902: PUSH
90903: LD_EXP 52
90907: PUSH
90908: LD_VAR 0 3
90912: ARRAY
90913: PPUSH
90914: LD_INT 1
90916: PPUSH
90917: LD_VAR 0 9
90921: PPUSH
90922: CALL_OW 2
90926: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
90927: LD_ADDR_EXP 52
90931: PUSH
90932: LD_EXP 52
90936: PPUSH
90937: LD_VAR 0 3
90941: PPUSH
90942: LD_VAR 0 7
90946: PPUSH
90947: CALL_OW 1
90951: ST_TO_ADDR
// end else
90952: GO 90971
// MC_InsertProduceList ( i , [ components ] ) ;
90954: LD_VAR 0 3
90958: PPUSH
90959: LD_VAR 0 9
90963: PUSH
90964: EMPTY
90965: LIST
90966: PPUSH
90967: CALL 86892 0 2
// break ;
90971: GO 90975
// end ; end ;
90973: GO 90760
90975: POP
90976: POP
// end ; end ; if GetType ( un ) = unit_building then
90977: LD_VAR 0 1
90981: PPUSH
90982: CALL_OW 247
90986: PUSH
90987: LD_INT 3
90989: EQUAL
90990: IFFALSE 91393
// begin btype := GetBType ( un ) ;
90992: LD_ADDR_VAR 0 5
90996: PUSH
90997: LD_VAR 0 1
91001: PPUSH
91002: CALL_OW 266
91006: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
91007: LD_VAR 0 5
91011: PUSH
91012: LD_INT 29
91014: PUSH
91015: LD_INT 30
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: IN
91022: IFFALSE 91095
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
91024: LD_VAR 0 1
91028: PPUSH
91029: CALL_OW 250
91033: PPUSH
91034: LD_VAR 0 1
91038: PPUSH
91039: CALL_OW 251
91043: PPUSH
91044: LD_VAR 0 1
91048: PPUSH
91049: CALL_OW 255
91053: PPUSH
91054: CALL_OW 440
91058: NOT
91059: IFFALSE 91095
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
91061: LD_VAR 0 1
91065: PPUSH
91066: CALL_OW 250
91070: PPUSH
91071: LD_VAR 0 1
91075: PPUSH
91076: CALL_OW 251
91080: PPUSH
91081: LD_VAR 0 1
91085: PPUSH
91086: CALL_OW 255
91090: PPUSH
91091: CALL_OW 441
// end ; if btype = b_warehouse then
91095: LD_VAR 0 5
91099: PUSH
91100: LD_INT 1
91102: EQUAL
91103: IFFALSE 91121
// begin btype := b_depot ;
91105: LD_ADDR_VAR 0 5
91109: PUSH
91110: LD_INT 0
91112: ST_TO_ADDR
// pos := 1 ;
91113: LD_ADDR_VAR 0 6
91117: PUSH
91118: LD_INT 1
91120: ST_TO_ADDR
// end ; if btype = b_factory then
91121: LD_VAR 0 5
91125: PUSH
91126: LD_INT 3
91128: EQUAL
91129: IFFALSE 91147
// begin btype := b_workshop ;
91131: LD_ADDR_VAR 0 5
91135: PUSH
91136: LD_INT 2
91138: ST_TO_ADDR
// pos := 1 ;
91139: LD_ADDR_VAR 0 6
91143: PUSH
91144: LD_INT 1
91146: ST_TO_ADDR
// end ; if btype = b_barracks then
91147: LD_VAR 0 5
91151: PUSH
91152: LD_INT 5
91154: EQUAL
91155: IFFALSE 91165
// btype := b_armoury ;
91157: LD_ADDR_VAR 0 5
91161: PUSH
91162: LD_INT 4
91164: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
91165: LD_VAR 0 5
91169: PUSH
91170: LD_INT 7
91172: PUSH
91173: LD_INT 8
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: IN
91180: IFFALSE 91190
// btype := b_lab ;
91182: LD_ADDR_VAR 0 5
91186: PUSH
91187: LD_INT 6
91189: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
91190: LD_ADDR_EXP 36
91194: PUSH
91195: LD_EXP 36
91199: PPUSH
91200: LD_VAR 0 3
91204: PUSH
91205: LD_EXP 36
91209: PUSH
91210: LD_VAR 0 3
91214: ARRAY
91215: PUSH
91216: LD_INT 1
91218: PLUS
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PPUSH
91224: LD_VAR 0 5
91228: PUSH
91229: LD_VAR 0 1
91233: PPUSH
91234: CALL_OW 250
91238: PUSH
91239: LD_VAR 0 1
91243: PPUSH
91244: CALL_OW 251
91248: PUSH
91249: LD_VAR 0 1
91253: PPUSH
91254: CALL_OW 254
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: PPUSH
91265: CALL 24801 0 3
91269: ST_TO_ADDR
// if pos = 1 then
91270: LD_VAR 0 6
91274: PUSH
91275: LD_INT 1
91277: EQUAL
91278: IFFALSE 91393
// begin tmp := mc_build_list [ i ] ;
91280: LD_ADDR_VAR 0 7
91284: PUSH
91285: LD_EXP 36
91289: PUSH
91290: LD_VAR 0 3
91294: ARRAY
91295: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
91296: LD_VAR 0 7
91300: PPUSH
91301: LD_INT 2
91303: PUSH
91304: LD_INT 30
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 30
91316: PUSH
91317: LD_INT 1
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: LIST
91328: PPUSH
91329: CALL_OW 72
91333: IFFALSE 91343
// pos := 2 ;
91335: LD_ADDR_VAR 0 6
91339: PUSH
91340: LD_INT 2
91342: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
91343: LD_ADDR_VAR 0 7
91347: PUSH
91348: LD_VAR 0 7
91352: PPUSH
91353: LD_VAR 0 6
91357: PPUSH
91358: LD_VAR 0 7
91362: PPUSH
91363: CALL 25127 0 3
91367: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
91368: LD_ADDR_EXP 36
91372: PUSH
91373: LD_EXP 36
91377: PPUSH
91378: LD_VAR 0 3
91382: PPUSH
91383: LD_VAR 0 7
91387: PPUSH
91388: CALL_OW 1
91392: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
91393: LD_VAR 0 1
91397: PUSH
91398: LD_EXP 31
91402: PUSH
91403: LD_VAR 0 3
91407: ARRAY
91408: IN
91409: IFFALSE 91448
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
91411: LD_ADDR_EXP 31
91415: PUSH
91416: LD_EXP 31
91420: PPUSH
91421: LD_VAR 0 3
91425: PPUSH
91426: LD_EXP 31
91430: PUSH
91431: LD_VAR 0 3
91435: ARRAY
91436: PUSH
91437: LD_VAR 0 1
91441: DIFF
91442: PPUSH
91443: CALL_OW 1
91447: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
91448: LD_VAR 0 1
91452: PUSH
91453: LD_EXP 38
91457: PUSH
91458: LD_VAR 0 3
91462: ARRAY
91463: IN
91464: IFFALSE 91503
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
91466: LD_ADDR_EXP 38
91470: PUSH
91471: LD_EXP 38
91475: PPUSH
91476: LD_VAR 0 3
91480: PPUSH
91481: LD_EXP 38
91485: PUSH
91486: LD_VAR 0 3
91490: ARRAY
91491: PUSH
91492: LD_VAR 0 1
91496: DIFF
91497: PPUSH
91498: CALL_OW 1
91502: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
91503: LD_VAR 0 1
91507: PUSH
91508: LD_EXP 50
91512: PUSH
91513: LD_VAR 0 3
91517: ARRAY
91518: IN
91519: IFFALSE 91558
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
91521: LD_ADDR_EXP 50
91525: PUSH
91526: LD_EXP 50
91530: PPUSH
91531: LD_VAR 0 3
91535: PPUSH
91536: LD_EXP 50
91540: PUSH
91541: LD_VAR 0 3
91545: ARRAY
91546: PUSH
91547: LD_VAR 0 1
91551: DIFF
91552: PPUSH
91553: CALL_OW 1
91557: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
91558: LD_VAR 0 1
91562: PUSH
91563: LD_EXP 53
91567: PUSH
91568: LD_VAR 0 3
91572: ARRAY
91573: IN
91574: IFFALSE 91613
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
91576: LD_ADDR_EXP 53
91580: PUSH
91581: LD_EXP 53
91585: PPUSH
91586: LD_VAR 0 3
91590: PPUSH
91591: LD_EXP 53
91595: PUSH
91596: LD_VAR 0 3
91600: ARRAY
91601: PUSH
91602: LD_VAR 0 1
91606: DIFF
91607: PPUSH
91608: CALL_OW 1
91612: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
91613: LD_VAR 0 1
91617: PUSH
91618: LD_EXP 40
91622: PUSH
91623: LD_VAR 0 3
91627: ARRAY
91628: IN
91629: IFFALSE 91668
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
91631: LD_ADDR_EXP 40
91635: PUSH
91636: LD_EXP 40
91640: PPUSH
91641: LD_VAR 0 3
91645: PPUSH
91646: LD_EXP 40
91650: PUSH
91651: LD_VAR 0 3
91655: ARRAY
91656: PUSH
91657: LD_VAR 0 1
91661: DIFF
91662: PPUSH
91663: CALL_OW 1
91667: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
91668: LD_VAR 0 1
91672: PUSH
91673: LD_EXP 39
91677: PUSH
91678: LD_VAR 0 3
91682: ARRAY
91683: IN
91684: IFFALSE 91723
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
91686: LD_ADDR_EXP 39
91690: PUSH
91691: LD_EXP 39
91695: PPUSH
91696: LD_VAR 0 3
91700: PPUSH
91701: LD_EXP 39
91705: PUSH
91706: LD_VAR 0 3
91710: ARRAY
91711: PUSH
91712: LD_VAR 0 1
91716: DIFF
91717: PPUSH
91718: CALL_OW 1
91722: ST_TO_ADDR
// end ; break ;
91723: GO 91727
// end ;
91725: GO 90375
91727: POP
91728: POP
// end ;
91729: LD_VAR 0 2
91733: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
91734: LD_INT 0
91736: PPUSH
91737: PPUSH
91738: PPUSH
// if not mc_bases or not skirmish then
91739: LD_EXP 31
91743: NOT
91744: PUSH
91745: LD_EXP 29
91749: NOT
91750: OR
91751: IFFALSE 91755
// exit ;
91753: GO 91970
// for i = 1 to mc_bases do
91755: LD_ADDR_VAR 0 3
91759: PUSH
91760: DOUBLE
91761: LD_INT 1
91763: DEC
91764: ST_TO_ADDR
91765: LD_EXP 31
91769: PUSH
91770: FOR_TO
91771: IFFALSE 91968
// begin if building in mc_construct_list [ i ] then
91773: LD_VAR 0 1
91777: PUSH
91778: LD_EXP 38
91782: PUSH
91783: LD_VAR 0 3
91787: ARRAY
91788: IN
91789: IFFALSE 91966
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
91791: LD_ADDR_EXP 38
91795: PUSH
91796: LD_EXP 38
91800: PPUSH
91801: LD_VAR 0 3
91805: PPUSH
91806: LD_EXP 38
91810: PUSH
91811: LD_VAR 0 3
91815: ARRAY
91816: PUSH
91817: LD_VAR 0 1
91821: DIFF
91822: PPUSH
91823: CALL_OW 1
91827: ST_TO_ADDR
// if building in mc_lab [ i ] then
91828: LD_VAR 0 1
91832: PUSH
91833: LD_EXP 64
91837: PUSH
91838: LD_VAR 0 3
91842: ARRAY
91843: IN
91844: IFFALSE 91899
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
91846: LD_ADDR_EXP 65
91850: PUSH
91851: LD_EXP 65
91855: PPUSH
91856: LD_VAR 0 3
91860: PPUSH
91861: LD_EXP 65
91865: PUSH
91866: LD_VAR 0 3
91870: ARRAY
91871: PPUSH
91872: LD_INT 1
91874: PPUSH
91875: LD_EXP 65
91879: PUSH
91880: LD_VAR 0 3
91884: ARRAY
91885: PPUSH
91886: LD_INT 0
91888: PPUSH
91889: CALL 24219 0 4
91893: PPUSH
91894: CALL_OW 1
91898: ST_TO_ADDR
// if not building in mc_bases [ i ] then
91899: LD_VAR 0 1
91903: PUSH
91904: LD_EXP 31
91908: PUSH
91909: LD_VAR 0 3
91913: ARRAY
91914: IN
91915: NOT
91916: IFFALSE 91962
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
91918: LD_ADDR_EXP 31
91922: PUSH
91923: LD_EXP 31
91927: PPUSH
91928: LD_VAR 0 3
91932: PUSH
91933: LD_EXP 31
91937: PUSH
91938: LD_VAR 0 3
91942: ARRAY
91943: PUSH
91944: LD_INT 1
91946: PLUS
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PPUSH
91952: LD_VAR 0 1
91956: PPUSH
91957: CALL 24801 0 3
91961: ST_TO_ADDR
// exit ;
91962: POP
91963: POP
91964: GO 91970
// end ; end ;
91966: GO 91770
91968: POP
91969: POP
// end ;
91970: LD_VAR 0 2
91974: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
91975: LD_INT 0
91977: PPUSH
91978: PPUSH
91979: PPUSH
91980: PPUSH
91981: PPUSH
91982: PPUSH
91983: PPUSH
// if not mc_bases or not skirmish then
91984: LD_EXP 31
91988: NOT
91989: PUSH
91990: LD_EXP 29
91994: NOT
91995: OR
91996: IFFALSE 92000
// exit ;
91998: GO 92661
// for i = 1 to mc_bases do
92000: LD_ADDR_VAR 0 3
92004: PUSH
92005: DOUBLE
92006: LD_INT 1
92008: DEC
92009: ST_TO_ADDR
92010: LD_EXP 31
92014: PUSH
92015: FOR_TO
92016: IFFALSE 92659
// begin if building in mc_construct_list [ i ] then
92018: LD_VAR 0 1
92022: PUSH
92023: LD_EXP 38
92027: PUSH
92028: LD_VAR 0 3
92032: ARRAY
92033: IN
92034: IFFALSE 92657
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
92036: LD_ADDR_EXP 38
92040: PUSH
92041: LD_EXP 38
92045: PPUSH
92046: LD_VAR 0 3
92050: PPUSH
92051: LD_EXP 38
92055: PUSH
92056: LD_VAR 0 3
92060: ARRAY
92061: PUSH
92062: LD_VAR 0 1
92066: DIFF
92067: PPUSH
92068: CALL_OW 1
92072: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
92073: LD_ADDR_EXP 31
92077: PUSH
92078: LD_EXP 31
92082: PPUSH
92083: LD_VAR 0 3
92087: PUSH
92088: LD_EXP 31
92092: PUSH
92093: LD_VAR 0 3
92097: ARRAY
92098: PUSH
92099: LD_INT 1
92101: PLUS
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PPUSH
92107: LD_VAR 0 1
92111: PPUSH
92112: CALL 24801 0 3
92116: ST_TO_ADDR
// btype := GetBType ( building ) ;
92117: LD_ADDR_VAR 0 5
92121: PUSH
92122: LD_VAR 0 1
92126: PPUSH
92127: CALL_OW 266
92131: ST_TO_ADDR
// side := GetSide ( building ) ;
92132: LD_ADDR_VAR 0 8
92136: PUSH
92137: LD_VAR 0 1
92141: PPUSH
92142: CALL_OW 255
92146: ST_TO_ADDR
// if btype = b_lab then
92147: LD_VAR 0 5
92151: PUSH
92152: LD_INT 6
92154: EQUAL
92155: IFFALSE 92205
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
92157: LD_ADDR_EXP 64
92161: PUSH
92162: LD_EXP 64
92166: PPUSH
92167: LD_VAR 0 3
92171: PUSH
92172: LD_EXP 64
92176: PUSH
92177: LD_VAR 0 3
92181: ARRAY
92182: PUSH
92183: LD_INT 1
92185: PLUS
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PPUSH
92191: LD_VAR 0 1
92195: PPUSH
92196: CALL 24801 0 3
92200: ST_TO_ADDR
// exit ;
92201: POP
92202: POP
92203: GO 92661
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
92205: LD_VAR 0 5
92209: PUSH
92210: LD_INT 0
92212: PUSH
92213: LD_INT 2
92215: PUSH
92216: LD_INT 4
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: LIST
92223: IN
92224: IFFALSE 92348
// begin if btype = b_armoury then
92226: LD_VAR 0 5
92230: PUSH
92231: LD_INT 4
92233: EQUAL
92234: IFFALSE 92244
// btype := b_barracks ;
92236: LD_ADDR_VAR 0 5
92240: PUSH
92241: LD_INT 5
92243: ST_TO_ADDR
// if btype = b_depot then
92244: LD_VAR 0 5
92248: PUSH
92249: LD_INT 0
92251: EQUAL
92252: IFFALSE 92262
// btype := b_warehouse ;
92254: LD_ADDR_VAR 0 5
92258: PUSH
92259: LD_INT 1
92261: ST_TO_ADDR
// if btype = b_workshop then
92262: LD_VAR 0 5
92266: PUSH
92267: LD_INT 2
92269: EQUAL
92270: IFFALSE 92280
// btype := b_factory ;
92272: LD_ADDR_VAR 0 5
92276: PUSH
92277: LD_INT 3
92279: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
92280: LD_VAR 0 5
92284: PPUSH
92285: LD_VAR 0 8
92289: PPUSH
92290: CALL_OW 323
92294: PUSH
92295: LD_INT 1
92297: EQUAL
92298: IFFALSE 92344
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
92300: LD_ADDR_EXP 63
92304: PUSH
92305: LD_EXP 63
92309: PPUSH
92310: LD_VAR 0 3
92314: PUSH
92315: LD_EXP 63
92319: PUSH
92320: LD_VAR 0 3
92324: ARRAY
92325: PUSH
92326: LD_INT 1
92328: PLUS
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PPUSH
92334: LD_VAR 0 1
92338: PPUSH
92339: CALL 24801 0 3
92343: ST_TO_ADDR
// exit ;
92344: POP
92345: POP
92346: GO 92661
// end ; if btype in [ b_bunker , b_turret ] then
92348: LD_VAR 0 5
92352: PUSH
92353: LD_INT 32
92355: PUSH
92356: LD_INT 33
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: IN
92363: IFFALSE 92653
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
92365: LD_ADDR_EXP 39
92369: PUSH
92370: LD_EXP 39
92374: PPUSH
92375: LD_VAR 0 3
92379: PUSH
92380: LD_EXP 39
92384: PUSH
92385: LD_VAR 0 3
92389: ARRAY
92390: PUSH
92391: LD_INT 1
92393: PLUS
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PPUSH
92399: LD_VAR 0 1
92403: PPUSH
92404: CALL 24801 0 3
92408: ST_TO_ADDR
// if btype = b_bunker then
92409: LD_VAR 0 5
92413: PUSH
92414: LD_INT 32
92416: EQUAL
92417: IFFALSE 92653
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
92419: LD_ADDR_EXP 40
92423: PUSH
92424: LD_EXP 40
92428: PPUSH
92429: LD_VAR 0 3
92433: PUSH
92434: LD_EXP 40
92438: PUSH
92439: LD_VAR 0 3
92443: ARRAY
92444: PUSH
92445: LD_INT 1
92447: PLUS
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PPUSH
92453: LD_VAR 0 1
92457: PPUSH
92458: CALL 24801 0 3
92462: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
92463: LD_ADDR_VAR 0 6
92467: PUSH
92468: LD_EXP 31
92472: PUSH
92473: LD_VAR 0 3
92477: ARRAY
92478: PPUSH
92479: LD_INT 25
92481: PUSH
92482: LD_INT 1
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 3
92491: PUSH
92492: LD_INT 54
92494: PUSH
92495: EMPTY
92496: LIST
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PPUSH
92506: CALL_OW 72
92510: ST_TO_ADDR
// if tmp then
92511: LD_VAR 0 6
92515: IFFALSE 92521
// exit ;
92517: POP
92518: POP
92519: GO 92661
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
92521: LD_ADDR_VAR 0 6
92525: PUSH
92526: LD_EXP 31
92530: PUSH
92531: LD_VAR 0 3
92535: ARRAY
92536: PPUSH
92537: LD_INT 2
92539: PUSH
92540: LD_INT 30
92542: PUSH
92543: LD_INT 4
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: PUSH
92550: LD_INT 30
92552: PUSH
92553: LD_INT 5
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: LIST
92564: PPUSH
92565: CALL_OW 72
92569: ST_TO_ADDR
// if not tmp then
92570: LD_VAR 0 6
92574: NOT
92575: IFFALSE 92581
// exit ;
92577: POP
92578: POP
92579: GO 92661
// for j in tmp do
92581: LD_ADDR_VAR 0 4
92585: PUSH
92586: LD_VAR 0 6
92590: PUSH
92591: FOR_IN
92592: IFFALSE 92651
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
92594: LD_ADDR_VAR 0 7
92598: PUSH
92599: LD_VAR 0 4
92603: PPUSH
92604: CALL_OW 313
92608: PPUSH
92609: LD_INT 25
92611: PUSH
92612: LD_INT 1
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PPUSH
92619: CALL_OW 72
92623: ST_TO_ADDR
// if units then
92624: LD_VAR 0 7
92628: IFFALSE 92649
// begin ComExitBuilding ( units [ 1 ] ) ;
92630: LD_VAR 0 7
92634: PUSH
92635: LD_INT 1
92637: ARRAY
92638: PPUSH
92639: CALL_OW 122
// exit ;
92643: POP
92644: POP
92645: POP
92646: POP
92647: GO 92661
// end ; end ;
92649: GO 92591
92651: POP
92652: POP
// end ; end ; exit ;
92653: POP
92654: POP
92655: GO 92661
// end ; end ;
92657: GO 92015
92659: POP
92660: POP
// end ;
92661: LD_VAR 0 2
92665: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
92666: LD_INT 0
92668: PPUSH
92669: PPUSH
92670: PPUSH
92671: PPUSH
92672: PPUSH
92673: PPUSH
92674: PPUSH
// if not mc_bases or not skirmish then
92675: LD_EXP 31
92679: NOT
92680: PUSH
92681: LD_EXP 29
92685: NOT
92686: OR
92687: IFFALSE 92691
// exit ;
92689: GO 92956
// btype := GetBType ( building ) ;
92691: LD_ADDR_VAR 0 6
92695: PUSH
92696: LD_VAR 0 1
92700: PPUSH
92701: CALL_OW 266
92705: ST_TO_ADDR
// x := GetX ( building ) ;
92706: LD_ADDR_VAR 0 7
92710: PUSH
92711: LD_VAR 0 1
92715: PPUSH
92716: CALL_OW 250
92720: ST_TO_ADDR
// y := GetY ( building ) ;
92721: LD_ADDR_VAR 0 8
92725: PUSH
92726: LD_VAR 0 1
92730: PPUSH
92731: CALL_OW 251
92735: ST_TO_ADDR
// d := GetDir ( building ) ;
92736: LD_ADDR_VAR 0 9
92740: PUSH
92741: LD_VAR 0 1
92745: PPUSH
92746: CALL_OW 254
92750: ST_TO_ADDR
// for i = 1 to mc_bases do
92751: LD_ADDR_VAR 0 4
92755: PUSH
92756: DOUBLE
92757: LD_INT 1
92759: DEC
92760: ST_TO_ADDR
92761: LD_EXP 31
92765: PUSH
92766: FOR_TO
92767: IFFALSE 92954
// begin if not mc_build_list [ i ] then
92769: LD_EXP 36
92773: PUSH
92774: LD_VAR 0 4
92778: ARRAY
92779: NOT
92780: IFFALSE 92784
// continue ;
92782: GO 92766
// for j := 1 to mc_build_list [ i ] do
92784: LD_ADDR_VAR 0 5
92788: PUSH
92789: DOUBLE
92790: LD_INT 1
92792: DEC
92793: ST_TO_ADDR
92794: LD_EXP 36
92798: PUSH
92799: LD_VAR 0 4
92803: ARRAY
92804: PUSH
92805: FOR_TO
92806: IFFALSE 92950
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
92808: LD_VAR 0 6
92812: PUSH
92813: LD_VAR 0 7
92817: PUSH
92818: LD_VAR 0 8
92822: PUSH
92823: LD_VAR 0 9
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: PPUSH
92834: LD_EXP 36
92838: PUSH
92839: LD_VAR 0 4
92843: ARRAY
92844: PUSH
92845: LD_VAR 0 5
92849: ARRAY
92850: PPUSH
92851: CALL 31358 0 2
92855: IFFALSE 92948
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
92857: LD_ADDR_EXP 36
92861: PUSH
92862: LD_EXP 36
92866: PPUSH
92867: LD_VAR 0 4
92871: PPUSH
92872: LD_EXP 36
92876: PUSH
92877: LD_VAR 0 4
92881: ARRAY
92882: PPUSH
92883: LD_VAR 0 5
92887: PPUSH
92888: CALL_OW 3
92892: PPUSH
92893: CALL_OW 1
92897: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
92898: LD_ADDR_EXP 38
92902: PUSH
92903: LD_EXP 38
92907: PPUSH
92908: LD_VAR 0 4
92912: PUSH
92913: LD_EXP 38
92917: PUSH
92918: LD_VAR 0 4
92922: ARRAY
92923: PUSH
92924: LD_INT 1
92926: PLUS
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PPUSH
92932: LD_VAR 0 1
92936: PPUSH
92937: CALL 24801 0 3
92941: ST_TO_ADDR
// exit ;
92942: POP
92943: POP
92944: POP
92945: POP
92946: GO 92956
// end ;
92948: GO 92805
92950: POP
92951: POP
// end ;
92952: GO 92766
92954: POP
92955: POP
// end ;
92956: LD_VAR 0 3
92960: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
92961: LD_INT 0
92963: PPUSH
92964: PPUSH
92965: PPUSH
// if not mc_bases or not skirmish then
92966: LD_EXP 31
92970: NOT
92971: PUSH
92972: LD_EXP 29
92976: NOT
92977: OR
92978: IFFALSE 92982
// exit ;
92980: GO 93172
// for i = 1 to mc_bases do
92982: LD_ADDR_VAR 0 4
92986: PUSH
92987: DOUBLE
92988: LD_INT 1
92990: DEC
92991: ST_TO_ADDR
92992: LD_EXP 31
92996: PUSH
92997: FOR_TO
92998: IFFALSE 93085
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
93000: LD_VAR 0 1
93004: PUSH
93005: LD_EXP 39
93009: PUSH
93010: LD_VAR 0 4
93014: ARRAY
93015: IN
93016: PUSH
93017: LD_VAR 0 1
93021: PUSH
93022: LD_EXP 40
93026: PUSH
93027: LD_VAR 0 4
93031: ARRAY
93032: IN
93033: NOT
93034: AND
93035: IFFALSE 93083
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
93037: LD_ADDR_EXP 40
93041: PUSH
93042: LD_EXP 40
93046: PPUSH
93047: LD_VAR 0 4
93051: PUSH
93052: LD_EXP 40
93056: PUSH
93057: LD_VAR 0 4
93061: ARRAY
93062: PUSH
93063: LD_INT 1
93065: PLUS
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PPUSH
93071: LD_VAR 0 1
93075: PPUSH
93076: CALL 24801 0 3
93080: ST_TO_ADDR
// break ;
93081: GO 93085
// end ; end ;
93083: GO 92997
93085: POP
93086: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
93087: LD_VAR 0 1
93091: PPUSH
93092: CALL_OW 257
93096: PUSH
93097: LD_EXP 57
93101: IN
93102: PUSH
93103: LD_VAR 0 1
93107: PPUSH
93108: CALL_OW 266
93112: PUSH
93113: LD_INT 5
93115: EQUAL
93116: AND
93117: PUSH
93118: LD_VAR 0 2
93122: PPUSH
93123: CALL_OW 110
93127: PUSH
93128: LD_INT 18
93130: NONEQUAL
93131: AND
93132: IFFALSE 93172
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
93134: LD_VAR 0 2
93138: PPUSH
93139: CALL_OW 257
93143: PUSH
93144: LD_INT 5
93146: PUSH
93147: LD_INT 8
93149: PUSH
93150: LD_INT 9
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: LIST
93157: IN
93158: IFFALSE 93172
// SetClass ( unit , 1 ) ;
93160: LD_VAR 0 2
93164: PPUSH
93165: LD_INT 1
93167: PPUSH
93168: CALL_OW 336
// end ;
93172: LD_VAR 0 3
93176: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
93177: LD_INT 0
93179: PPUSH
93180: PPUSH
// if not mc_bases or not skirmish then
93181: LD_EXP 31
93185: NOT
93186: PUSH
93187: LD_EXP 29
93191: NOT
93192: OR
93193: IFFALSE 93197
// exit ;
93195: GO 93313
// if GetLives ( abandoned_vehicle ) > 250 then
93197: LD_VAR 0 2
93201: PPUSH
93202: CALL_OW 256
93206: PUSH
93207: LD_INT 250
93209: GREATER
93210: IFFALSE 93214
// exit ;
93212: GO 93313
// for i = 1 to mc_bases do
93214: LD_ADDR_VAR 0 6
93218: PUSH
93219: DOUBLE
93220: LD_INT 1
93222: DEC
93223: ST_TO_ADDR
93224: LD_EXP 31
93228: PUSH
93229: FOR_TO
93230: IFFALSE 93311
// begin if driver in mc_bases [ i ] then
93232: LD_VAR 0 1
93236: PUSH
93237: LD_EXP 31
93241: PUSH
93242: LD_VAR 0 6
93246: ARRAY
93247: IN
93248: IFFALSE 93309
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
93250: LD_VAR 0 1
93254: PPUSH
93255: LD_EXP 31
93259: PUSH
93260: LD_VAR 0 6
93264: ARRAY
93265: PPUSH
93266: LD_INT 2
93268: PUSH
93269: LD_INT 30
93271: PUSH
93272: LD_INT 0
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 30
93281: PUSH
93282: LD_INT 1
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: LIST
93293: PPUSH
93294: CALL_OW 72
93298: PUSH
93299: LD_INT 1
93301: ARRAY
93302: PPUSH
93303: CALL 58407 0 2
// break ;
93307: GO 93311
// end ; end ;
93309: GO 93229
93311: POP
93312: POP
// end ; end_of_file end_of_file
93313: LD_VAR 0 5
93317: RET
// export globalGameSaveCounter ; every 0 0$1 do
93318: GO 93320
93320: DISABLE
// begin enable ;
93321: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93322: LD_STRING updateTimer(
93324: PUSH
93325: LD_OWVAR 1
93329: STR
93330: PUSH
93331: LD_STRING );
93333: STR
93334: PPUSH
93335: CALL_OW 559
// end ;
93339: END
// every 0 0$1 do
93340: GO 93342
93342: DISABLE
// begin globalGameSaveCounter := 0 ;
93343: LD_ADDR_EXP 76
93347: PUSH
93348: LD_INT 0
93350: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93351: LD_STRING setGameSaveCounter(0)
93353: PPUSH
93354: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93358: LD_STRING initStreamRollete();
93360: PPUSH
93361: CALL_OW 559
// InitStreamMode ;
93365: CALL 94708 0 0
// DefineStreamItems ( false ) ;
93369: LD_INT 0
93371: PPUSH
93372: CALL 95172 0 1
// end ;
93376: END
// export function SOS_MapStart ( ) ; begin
93377: LD_INT 0
93379: PPUSH
// if streamModeActive then
93380: LD_EXP 77
93384: IFFALSE 93393
// DefineStreamItems ( true ) ;
93386: LD_INT 1
93388: PPUSH
93389: CALL 95172 0 1
// UpdateLuaVariables ( ) ;
93393: CALL 93410 0 0
// UpdateFactoryWaypoints ( ) ;
93397: CALL 108041 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93401: CALL 108298 0 0
// end ;
93405: LD_VAR 0 1
93409: RET
// function UpdateLuaVariables ( ) ; begin
93410: LD_INT 0
93412: PPUSH
// if globalGameSaveCounter then
93413: LD_EXP 76
93417: IFFALSE 93451
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93419: LD_ADDR_EXP 76
93423: PUSH
93424: LD_EXP 76
93428: PPUSH
93429: CALL 58891 0 1
93433: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93434: LD_STRING setGameSaveCounter(
93436: PUSH
93437: LD_EXP 76
93441: STR
93442: PUSH
93443: LD_STRING )
93445: STR
93446: PPUSH
93447: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93451: LD_STRING setGameDifficulty(
93453: PUSH
93454: LD_OWVAR 67
93458: STR
93459: PUSH
93460: LD_STRING )
93462: STR
93463: PPUSH
93464: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
93468: LD_STRING displayDifficulty(
93470: PUSH
93471: LD_OWVAR 67
93475: STR
93476: PUSH
93477: LD_STRING )
93479: STR
93480: PPUSH
93481: CALL_OW 559
// end ;
93485: LD_VAR 0 1
93489: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93490: LD_INT 0
93492: PPUSH
// if p2 = stream_mode then
93493: LD_VAR 0 2
93497: PUSH
93498: LD_INT 100
93500: EQUAL
93501: IFFALSE 94504
// begin if not StreamModeActive then
93503: LD_EXP 77
93507: NOT
93508: IFFALSE 93518
// StreamModeActive := true ;
93510: LD_ADDR_EXP 77
93514: PUSH
93515: LD_INT 1
93517: ST_TO_ADDR
// if p3 = 0 then
93518: LD_VAR 0 3
93522: PUSH
93523: LD_INT 0
93525: EQUAL
93526: IFFALSE 93532
// InitStreamMode ;
93528: CALL 94708 0 0
// if p3 = 1 then
93532: LD_VAR 0 3
93536: PUSH
93537: LD_INT 1
93539: EQUAL
93540: IFFALSE 93550
// sRocket := true ;
93542: LD_ADDR_EXP 82
93546: PUSH
93547: LD_INT 1
93549: ST_TO_ADDR
// if p3 = 2 then
93550: LD_VAR 0 3
93554: PUSH
93555: LD_INT 2
93557: EQUAL
93558: IFFALSE 93568
// sSpeed := true ;
93560: LD_ADDR_EXP 81
93564: PUSH
93565: LD_INT 1
93567: ST_TO_ADDR
// if p3 = 3 then
93568: LD_VAR 0 3
93572: PUSH
93573: LD_INT 3
93575: EQUAL
93576: IFFALSE 93586
// sEngine := true ;
93578: LD_ADDR_EXP 83
93582: PUSH
93583: LD_INT 1
93585: ST_TO_ADDR
// if p3 = 4 then
93586: LD_VAR 0 3
93590: PUSH
93591: LD_INT 4
93593: EQUAL
93594: IFFALSE 93604
// sSpec := true ;
93596: LD_ADDR_EXP 80
93600: PUSH
93601: LD_INT 1
93603: ST_TO_ADDR
// if p3 = 5 then
93604: LD_VAR 0 3
93608: PUSH
93609: LD_INT 5
93611: EQUAL
93612: IFFALSE 93622
// sLevel := true ;
93614: LD_ADDR_EXP 84
93618: PUSH
93619: LD_INT 1
93621: ST_TO_ADDR
// if p3 = 6 then
93622: LD_VAR 0 3
93626: PUSH
93627: LD_INT 6
93629: EQUAL
93630: IFFALSE 93640
// sArmoury := true ;
93632: LD_ADDR_EXP 85
93636: PUSH
93637: LD_INT 1
93639: ST_TO_ADDR
// if p3 = 7 then
93640: LD_VAR 0 3
93644: PUSH
93645: LD_INT 7
93647: EQUAL
93648: IFFALSE 93658
// sRadar := true ;
93650: LD_ADDR_EXP 86
93654: PUSH
93655: LD_INT 1
93657: ST_TO_ADDR
// if p3 = 8 then
93658: LD_VAR 0 3
93662: PUSH
93663: LD_INT 8
93665: EQUAL
93666: IFFALSE 93676
// sBunker := true ;
93668: LD_ADDR_EXP 87
93672: PUSH
93673: LD_INT 1
93675: ST_TO_ADDR
// if p3 = 9 then
93676: LD_VAR 0 3
93680: PUSH
93681: LD_INT 9
93683: EQUAL
93684: IFFALSE 93694
// sHack := true ;
93686: LD_ADDR_EXP 88
93690: PUSH
93691: LD_INT 1
93693: ST_TO_ADDR
// if p3 = 10 then
93694: LD_VAR 0 3
93698: PUSH
93699: LD_INT 10
93701: EQUAL
93702: IFFALSE 93712
// sFire := true ;
93704: LD_ADDR_EXP 89
93708: PUSH
93709: LD_INT 1
93711: ST_TO_ADDR
// if p3 = 11 then
93712: LD_VAR 0 3
93716: PUSH
93717: LD_INT 11
93719: EQUAL
93720: IFFALSE 93730
// sRefresh := true ;
93722: LD_ADDR_EXP 90
93726: PUSH
93727: LD_INT 1
93729: ST_TO_ADDR
// if p3 = 12 then
93730: LD_VAR 0 3
93734: PUSH
93735: LD_INT 12
93737: EQUAL
93738: IFFALSE 93748
// sExp := true ;
93740: LD_ADDR_EXP 91
93744: PUSH
93745: LD_INT 1
93747: ST_TO_ADDR
// if p3 = 13 then
93748: LD_VAR 0 3
93752: PUSH
93753: LD_INT 13
93755: EQUAL
93756: IFFALSE 93766
// sDepot := true ;
93758: LD_ADDR_EXP 92
93762: PUSH
93763: LD_INT 1
93765: ST_TO_ADDR
// if p3 = 14 then
93766: LD_VAR 0 3
93770: PUSH
93771: LD_INT 14
93773: EQUAL
93774: IFFALSE 93784
// sFlag := true ;
93776: LD_ADDR_EXP 93
93780: PUSH
93781: LD_INT 1
93783: ST_TO_ADDR
// if p3 = 15 then
93784: LD_VAR 0 3
93788: PUSH
93789: LD_INT 15
93791: EQUAL
93792: IFFALSE 93802
// sKamikadze := true ;
93794: LD_ADDR_EXP 101
93798: PUSH
93799: LD_INT 1
93801: ST_TO_ADDR
// if p3 = 16 then
93802: LD_VAR 0 3
93806: PUSH
93807: LD_INT 16
93809: EQUAL
93810: IFFALSE 93820
// sTroll := true ;
93812: LD_ADDR_EXP 102
93816: PUSH
93817: LD_INT 1
93819: ST_TO_ADDR
// if p3 = 17 then
93820: LD_VAR 0 3
93824: PUSH
93825: LD_INT 17
93827: EQUAL
93828: IFFALSE 93838
// sSlow := true ;
93830: LD_ADDR_EXP 103
93834: PUSH
93835: LD_INT 1
93837: ST_TO_ADDR
// if p3 = 18 then
93838: LD_VAR 0 3
93842: PUSH
93843: LD_INT 18
93845: EQUAL
93846: IFFALSE 93856
// sLack := true ;
93848: LD_ADDR_EXP 104
93852: PUSH
93853: LD_INT 1
93855: ST_TO_ADDR
// if p3 = 19 then
93856: LD_VAR 0 3
93860: PUSH
93861: LD_INT 19
93863: EQUAL
93864: IFFALSE 93874
// sTank := true ;
93866: LD_ADDR_EXP 106
93870: PUSH
93871: LD_INT 1
93873: ST_TO_ADDR
// if p3 = 20 then
93874: LD_VAR 0 3
93878: PUSH
93879: LD_INT 20
93881: EQUAL
93882: IFFALSE 93892
// sRemote := true ;
93884: LD_ADDR_EXP 107
93888: PUSH
93889: LD_INT 1
93891: ST_TO_ADDR
// if p3 = 21 then
93892: LD_VAR 0 3
93896: PUSH
93897: LD_INT 21
93899: EQUAL
93900: IFFALSE 93910
// sPowell := true ;
93902: LD_ADDR_EXP 108
93906: PUSH
93907: LD_INT 1
93909: ST_TO_ADDR
// if p3 = 22 then
93910: LD_VAR 0 3
93914: PUSH
93915: LD_INT 22
93917: EQUAL
93918: IFFALSE 93928
// sTeleport := true ;
93920: LD_ADDR_EXP 111
93924: PUSH
93925: LD_INT 1
93927: ST_TO_ADDR
// if p3 = 23 then
93928: LD_VAR 0 3
93932: PUSH
93933: LD_INT 23
93935: EQUAL
93936: IFFALSE 93946
// sOilTower := true ;
93938: LD_ADDR_EXP 113
93942: PUSH
93943: LD_INT 1
93945: ST_TO_ADDR
// if p3 = 24 then
93946: LD_VAR 0 3
93950: PUSH
93951: LD_INT 24
93953: EQUAL
93954: IFFALSE 93964
// sShovel := true ;
93956: LD_ADDR_EXP 114
93960: PUSH
93961: LD_INT 1
93963: ST_TO_ADDR
// if p3 = 25 then
93964: LD_VAR 0 3
93968: PUSH
93969: LD_INT 25
93971: EQUAL
93972: IFFALSE 93982
// sSheik := true ;
93974: LD_ADDR_EXP 115
93978: PUSH
93979: LD_INT 1
93981: ST_TO_ADDR
// if p3 = 26 then
93982: LD_VAR 0 3
93986: PUSH
93987: LD_INT 26
93989: EQUAL
93990: IFFALSE 94000
// sEarthquake := true ;
93992: LD_ADDR_EXP 117
93996: PUSH
93997: LD_INT 1
93999: ST_TO_ADDR
// if p3 = 27 then
94000: LD_VAR 0 3
94004: PUSH
94005: LD_INT 27
94007: EQUAL
94008: IFFALSE 94018
// sAI := true ;
94010: LD_ADDR_EXP 118
94014: PUSH
94015: LD_INT 1
94017: ST_TO_ADDR
// if p3 = 28 then
94018: LD_VAR 0 3
94022: PUSH
94023: LD_INT 28
94025: EQUAL
94026: IFFALSE 94036
// sCargo := true ;
94028: LD_ADDR_EXP 121
94032: PUSH
94033: LD_INT 1
94035: ST_TO_ADDR
// if p3 = 29 then
94036: LD_VAR 0 3
94040: PUSH
94041: LD_INT 29
94043: EQUAL
94044: IFFALSE 94054
// sDLaser := true ;
94046: LD_ADDR_EXP 122
94050: PUSH
94051: LD_INT 1
94053: ST_TO_ADDR
// if p3 = 30 then
94054: LD_VAR 0 3
94058: PUSH
94059: LD_INT 30
94061: EQUAL
94062: IFFALSE 94072
// sExchange := true ;
94064: LD_ADDR_EXP 123
94068: PUSH
94069: LD_INT 1
94071: ST_TO_ADDR
// if p3 = 31 then
94072: LD_VAR 0 3
94076: PUSH
94077: LD_INT 31
94079: EQUAL
94080: IFFALSE 94090
// sFac := true ;
94082: LD_ADDR_EXP 124
94086: PUSH
94087: LD_INT 1
94089: ST_TO_ADDR
// if p3 = 32 then
94090: LD_VAR 0 3
94094: PUSH
94095: LD_INT 32
94097: EQUAL
94098: IFFALSE 94108
// sPower := true ;
94100: LD_ADDR_EXP 125
94104: PUSH
94105: LD_INT 1
94107: ST_TO_ADDR
// if p3 = 33 then
94108: LD_VAR 0 3
94112: PUSH
94113: LD_INT 33
94115: EQUAL
94116: IFFALSE 94126
// sRandom := true ;
94118: LD_ADDR_EXP 126
94122: PUSH
94123: LD_INT 1
94125: ST_TO_ADDR
// if p3 = 34 then
94126: LD_VAR 0 3
94130: PUSH
94131: LD_INT 34
94133: EQUAL
94134: IFFALSE 94144
// sShield := true ;
94136: LD_ADDR_EXP 127
94140: PUSH
94141: LD_INT 1
94143: ST_TO_ADDR
// if p3 = 35 then
94144: LD_VAR 0 3
94148: PUSH
94149: LD_INT 35
94151: EQUAL
94152: IFFALSE 94162
// sTime := true ;
94154: LD_ADDR_EXP 128
94158: PUSH
94159: LD_INT 1
94161: ST_TO_ADDR
// if p3 = 36 then
94162: LD_VAR 0 3
94166: PUSH
94167: LD_INT 36
94169: EQUAL
94170: IFFALSE 94180
// sTools := true ;
94172: LD_ADDR_EXP 129
94176: PUSH
94177: LD_INT 1
94179: ST_TO_ADDR
// if p3 = 101 then
94180: LD_VAR 0 3
94184: PUSH
94185: LD_INT 101
94187: EQUAL
94188: IFFALSE 94198
// sSold := true ;
94190: LD_ADDR_EXP 94
94194: PUSH
94195: LD_INT 1
94197: ST_TO_ADDR
// if p3 = 102 then
94198: LD_VAR 0 3
94202: PUSH
94203: LD_INT 102
94205: EQUAL
94206: IFFALSE 94216
// sDiff := true ;
94208: LD_ADDR_EXP 95
94212: PUSH
94213: LD_INT 1
94215: ST_TO_ADDR
// if p3 = 103 then
94216: LD_VAR 0 3
94220: PUSH
94221: LD_INT 103
94223: EQUAL
94224: IFFALSE 94234
// sFog := true ;
94226: LD_ADDR_EXP 98
94230: PUSH
94231: LD_INT 1
94233: ST_TO_ADDR
// if p3 = 104 then
94234: LD_VAR 0 3
94238: PUSH
94239: LD_INT 104
94241: EQUAL
94242: IFFALSE 94252
// sReset := true ;
94244: LD_ADDR_EXP 99
94248: PUSH
94249: LD_INT 1
94251: ST_TO_ADDR
// if p3 = 105 then
94252: LD_VAR 0 3
94256: PUSH
94257: LD_INT 105
94259: EQUAL
94260: IFFALSE 94270
// sSun := true ;
94262: LD_ADDR_EXP 100
94266: PUSH
94267: LD_INT 1
94269: ST_TO_ADDR
// if p3 = 106 then
94270: LD_VAR 0 3
94274: PUSH
94275: LD_INT 106
94277: EQUAL
94278: IFFALSE 94288
// sTiger := true ;
94280: LD_ADDR_EXP 96
94284: PUSH
94285: LD_INT 1
94287: ST_TO_ADDR
// if p3 = 107 then
94288: LD_VAR 0 3
94292: PUSH
94293: LD_INT 107
94295: EQUAL
94296: IFFALSE 94306
// sBomb := true ;
94298: LD_ADDR_EXP 97
94302: PUSH
94303: LD_INT 1
94305: ST_TO_ADDR
// if p3 = 108 then
94306: LD_VAR 0 3
94310: PUSH
94311: LD_INT 108
94313: EQUAL
94314: IFFALSE 94324
// sWound := true ;
94316: LD_ADDR_EXP 105
94320: PUSH
94321: LD_INT 1
94323: ST_TO_ADDR
// if p3 = 109 then
94324: LD_VAR 0 3
94328: PUSH
94329: LD_INT 109
94331: EQUAL
94332: IFFALSE 94342
// sBetray := true ;
94334: LD_ADDR_EXP 109
94338: PUSH
94339: LD_INT 1
94341: ST_TO_ADDR
// if p3 = 110 then
94342: LD_VAR 0 3
94346: PUSH
94347: LD_INT 110
94349: EQUAL
94350: IFFALSE 94360
// sContamin := true ;
94352: LD_ADDR_EXP 110
94356: PUSH
94357: LD_INT 1
94359: ST_TO_ADDR
// if p3 = 111 then
94360: LD_VAR 0 3
94364: PUSH
94365: LD_INT 111
94367: EQUAL
94368: IFFALSE 94378
// sOil := true ;
94370: LD_ADDR_EXP 112
94374: PUSH
94375: LD_INT 1
94377: ST_TO_ADDR
// if p3 = 112 then
94378: LD_VAR 0 3
94382: PUSH
94383: LD_INT 112
94385: EQUAL
94386: IFFALSE 94396
// sStu := true ;
94388: LD_ADDR_EXP 116
94392: PUSH
94393: LD_INT 1
94395: ST_TO_ADDR
// if p3 = 113 then
94396: LD_VAR 0 3
94400: PUSH
94401: LD_INT 113
94403: EQUAL
94404: IFFALSE 94414
// sBazooka := true ;
94406: LD_ADDR_EXP 119
94410: PUSH
94411: LD_INT 1
94413: ST_TO_ADDR
// if p3 = 114 then
94414: LD_VAR 0 3
94418: PUSH
94419: LD_INT 114
94421: EQUAL
94422: IFFALSE 94432
// sMortar := true ;
94424: LD_ADDR_EXP 120
94428: PUSH
94429: LD_INT 1
94431: ST_TO_ADDR
// if p3 = 115 then
94432: LD_VAR 0 3
94436: PUSH
94437: LD_INT 115
94439: EQUAL
94440: IFFALSE 94450
// sRanger := true ;
94442: LD_ADDR_EXP 130
94446: PUSH
94447: LD_INT 1
94449: ST_TO_ADDR
// if p3 = 116 then
94450: LD_VAR 0 3
94454: PUSH
94455: LD_INT 116
94457: EQUAL
94458: IFFALSE 94468
// sComputer := true ;
94460: LD_ADDR_EXP 131
94464: PUSH
94465: LD_INT 1
94467: ST_TO_ADDR
// if p3 = 117 then
94468: LD_VAR 0 3
94472: PUSH
94473: LD_INT 117
94475: EQUAL
94476: IFFALSE 94486
// s30 := true ;
94478: LD_ADDR_EXP 132
94482: PUSH
94483: LD_INT 1
94485: ST_TO_ADDR
// if p3 = 118 then
94486: LD_VAR 0 3
94490: PUSH
94491: LD_INT 118
94493: EQUAL
94494: IFFALSE 94504
// s60 := true ;
94496: LD_ADDR_EXP 133
94500: PUSH
94501: LD_INT 1
94503: ST_TO_ADDR
// end ; if p2 = hack_mode then
94504: LD_VAR 0 2
94508: PUSH
94509: LD_INT 101
94511: EQUAL
94512: IFFALSE 94640
// begin case p3 of 1 :
94514: LD_VAR 0 3
94518: PUSH
94519: LD_INT 1
94521: DOUBLE
94522: EQUAL
94523: IFTRUE 94527
94525: GO 94534
94527: POP
// hHackUnlimitedResources ; 2 :
94528: CALL 106787 0 0
94532: GO 94640
94534: LD_INT 2
94536: DOUBLE
94537: EQUAL
94538: IFTRUE 94542
94540: GO 94549
94542: POP
// hHackSetLevel10 ; 3 :
94543: CALL 106920 0 0
94547: GO 94640
94549: LD_INT 3
94551: DOUBLE
94552: EQUAL
94553: IFTRUE 94557
94555: GO 94564
94557: POP
// hHackSetLevel10YourUnits ; 4 :
94558: CALL 107005 0 0
94562: GO 94640
94564: LD_INT 4
94566: DOUBLE
94567: EQUAL
94568: IFTRUE 94572
94570: GO 94579
94572: POP
// hHackInvincible ; 5 :
94573: CALL 107453 0 0
94577: GO 94640
94579: LD_INT 5
94581: DOUBLE
94582: EQUAL
94583: IFTRUE 94587
94585: GO 94594
94587: POP
// hHackInvisible ; 6 :
94588: CALL 107564 0 0
94592: GO 94640
94594: LD_INT 6
94596: DOUBLE
94597: EQUAL
94598: IFTRUE 94602
94600: GO 94609
94602: POP
// hHackChangeYourSide ; 7 :
94603: CALL 107621 0 0
94607: GO 94640
94609: LD_INT 7
94611: DOUBLE
94612: EQUAL
94613: IFTRUE 94617
94615: GO 94624
94617: POP
// hHackChangeUnitSide ; 8 :
94618: CALL 107663 0 0
94622: GO 94640
94624: LD_INT 8
94626: DOUBLE
94627: EQUAL
94628: IFTRUE 94632
94630: GO 94639
94632: POP
// hHackFog ; end ;
94633: CALL 107764 0 0
94637: GO 94640
94639: POP
// end ; if p2 = game_save_mode then
94640: LD_VAR 0 2
94644: PUSH
94645: LD_INT 102
94647: EQUAL
94648: IFFALSE 94703
// begin if p3 = 1 then
94650: LD_VAR 0 3
94654: PUSH
94655: LD_INT 1
94657: EQUAL
94658: IFFALSE 94670
// globalGameSaveCounter := p4 ;
94660: LD_ADDR_EXP 76
94664: PUSH
94665: LD_VAR 0 4
94669: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
94670: LD_VAR 0 3
94674: PUSH
94675: LD_INT 2
94677: EQUAL
94678: PUSH
94679: LD_EXP 76
94683: AND
94684: IFFALSE 94703
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94686: LD_STRING setGameSaveCounter(
94688: PUSH
94689: LD_EXP 76
94693: STR
94694: PUSH
94695: LD_STRING )
94697: STR
94698: PPUSH
94699: CALL_OW 559
// end ; end ;
94703: LD_VAR 0 7
94707: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
94708: LD_INT 0
94710: PPUSH
// streamModeActive := false ;
94711: LD_ADDR_EXP 77
94715: PUSH
94716: LD_INT 0
94718: ST_TO_ADDR
// normalCounter := 36 ;
94719: LD_ADDR_EXP 78
94723: PUSH
94724: LD_INT 36
94726: ST_TO_ADDR
// hardcoreCounter := 18 ;
94727: LD_ADDR_EXP 79
94731: PUSH
94732: LD_INT 18
94734: ST_TO_ADDR
// sRocket := false ;
94735: LD_ADDR_EXP 82
94739: PUSH
94740: LD_INT 0
94742: ST_TO_ADDR
// sSpeed := false ;
94743: LD_ADDR_EXP 81
94747: PUSH
94748: LD_INT 0
94750: ST_TO_ADDR
// sEngine := false ;
94751: LD_ADDR_EXP 83
94755: PUSH
94756: LD_INT 0
94758: ST_TO_ADDR
// sSpec := false ;
94759: LD_ADDR_EXP 80
94763: PUSH
94764: LD_INT 0
94766: ST_TO_ADDR
// sLevel := false ;
94767: LD_ADDR_EXP 84
94771: PUSH
94772: LD_INT 0
94774: ST_TO_ADDR
// sArmoury := false ;
94775: LD_ADDR_EXP 85
94779: PUSH
94780: LD_INT 0
94782: ST_TO_ADDR
// sRadar := false ;
94783: LD_ADDR_EXP 86
94787: PUSH
94788: LD_INT 0
94790: ST_TO_ADDR
// sBunker := false ;
94791: LD_ADDR_EXP 87
94795: PUSH
94796: LD_INT 0
94798: ST_TO_ADDR
// sHack := false ;
94799: LD_ADDR_EXP 88
94803: PUSH
94804: LD_INT 0
94806: ST_TO_ADDR
// sFire := false ;
94807: LD_ADDR_EXP 89
94811: PUSH
94812: LD_INT 0
94814: ST_TO_ADDR
// sRefresh := false ;
94815: LD_ADDR_EXP 90
94819: PUSH
94820: LD_INT 0
94822: ST_TO_ADDR
// sExp := false ;
94823: LD_ADDR_EXP 91
94827: PUSH
94828: LD_INT 0
94830: ST_TO_ADDR
// sDepot := false ;
94831: LD_ADDR_EXP 92
94835: PUSH
94836: LD_INT 0
94838: ST_TO_ADDR
// sFlag := false ;
94839: LD_ADDR_EXP 93
94843: PUSH
94844: LD_INT 0
94846: ST_TO_ADDR
// sKamikadze := false ;
94847: LD_ADDR_EXP 101
94851: PUSH
94852: LD_INT 0
94854: ST_TO_ADDR
// sTroll := false ;
94855: LD_ADDR_EXP 102
94859: PUSH
94860: LD_INT 0
94862: ST_TO_ADDR
// sSlow := false ;
94863: LD_ADDR_EXP 103
94867: PUSH
94868: LD_INT 0
94870: ST_TO_ADDR
// sLack := false ;
94871: LD_ADDR_EXP 104
94875: PUSH
94876: LD_INT 0
94878: ST_TO_ADDR
// sTank := false ;
94879: LD_ADDR_EXP 106
94883: PUSH
94884: LD_INT 0
94886: ST_TO_ADDR
// sRemote := false ;
94887: LD_ADDR_EXP 107
94891: PUSH
94892: LD_INT 0
94894: ST_TO_ADDR
// sPowell := false ;
94895: LD_ADDR_EXP 108
94899: PUSH
94900: LD_INT 0
94902: ST_TO_ADDR
// sTeleport := false ;
94903: LD_ADDR_EXP 111
94907: PUSH
94908: LD_INT 0
94910: ST_TO_ADDR
// sOilTower := false ;
94911: LD_ADDR_EXP 113
94915: PUSH
94916: LD_INT 0
94918: ST_TO_ADDR
// sShovel := false ;
94919: LD_ADDR_EXP 114
94923: PUSH
94924: LD_INT 0
94926: ST_TO_ADDR
// sSheik := false ;
94927: LD_ADDR_EXP 115
94931: PUSH
94932: LD_INT 0
94934: ST_TO_ADDR
// sEarthquake := false ;
94935: LD_ADDR_EXP 117
94939: PUSH
94940: LD_INT 0
94942: ST_TO_ADDR
// sAI := false ;
94943: LD_ADDR_EXP 118
94947: PUSH
94948: LD_INT 0
94950: ST_TO_ADDR
// sCargo := false ;
94951: LD_ADDR_EXP 121
94955: PUSH
94956: LD_INT 0
94958: ST_TO_ADDR
// sDLaser := false ;
94959: LD_ADDR_EXP 122
94963: PUSH
94964: LD_INT 0
94966: ST_TO_ADDR
// sExchange := false ;
94967: LD_ADDR_EXP 123
94971: PUSH
94972: LD_INT 0
94974: ST_TO_ADDR
// sFac := false ;
94975: LD_ADDR_EXP 124
94979: PUSH
94980: LD_INT 0
94982: ST_TO_ADDR
// sPower := false ;
94983: LD_ADDR_EXP 125
94987: PUSH
94988: LD_INT 0
94990: ST_TO_ADDR
// sRandom := false ;
94991: LD_ADDR_EXP 126
94995: PUSH
94996: LD_INT 0
94998: ST_TO_ADDR
// sShield := false ;
94999: LD_ADDR_EXP 127
95003: PUSH
95004: LD_INT 0
95006: ST_TO_ADDR
// sTime := false ;
95007: LD_ADDR_EXP 128
95011: PUSH
95012: LD_INT 0
95014: ST_TO_ADDR
// sTools := false ;
95015: LD_ADDR_EXP 129
95019: PUSH
95020: LD_INT 0
95022: ST_TO_ADDR
// sSold := false ;
95023: LD_ADDR_EXP 94
95027: PUSH
95028: LD_INT 0
95030: ST_TO_ADDR
// sDiff := false ;
95031: LD_ADDR_EXP 95
95035: PUSH
95036: LD_INT 0
95038: ST_TO_ADDR
// sFog := false ;
95039: LD_ADDR_EXP 98
95043: PUSH
95044: LD_INT 0
95046: ST_TO_ADDR
// sReset := false ;
95047: LD_ADDR_EXP 99
95051: PUSH
95052: LD_INT 0
95054: ST_TO_ADDR
// sSun := false ;
95055: LD_ADDR_EXP 100
95059: PUSH
95060: LD_INT 0
95062: ST_TO_ADDR
// sTiger := false ;
95063: LD_ADDR_EXP 96
95067: PUSH
95068: LD_INT 0
95070: ST_TO_ADDR
// sBomb := false ;
95071: LD_ADDR_EXP 97
95075: PUSH
95076: LD_INT 0
95078: ST_TO_ADDR
// sWound := false ;
95079: LD_ADDR_EXP 105
95083: PUSH
95084: LD_INT 0
95086: ST_TO_ADDR
// sBetray := false ;
95087: LD_ADDR_EXP 109
95091: PUSH
95092: LD_INT 0
95094: ST_TO_ADDR
// sContamin := false ;
95095: LD_ADDR_EXP 110
95099: PUSH
95100: LD_INT 0
95102: ST_TO_ADDR
// sOil := false ;
95103: LD_ADDR_EXP 112
95107: PUSH
95108: LD_INT 0
95110: ST_TO_ADDR
// sStu := false ;
95111: LD_ADDR_EXP 116
95115: PUSH
95116: LD_INT 0
95118: ST_TO_ADDR
// sBazooka := false ;
95119: LD_ADDR_EXP 119
95123: PUSH
95124: LD_INT 0
95126: ST_TO_ADDR
// sMortar := false ;
95127: LD_ADDR_EXP 120
95131: PUSH
95132: LD_INT 0
95134: ST_TO_ADDR
// sRanger := false ;
95135: LD_ADDR_EXP 130
95139: PUSH
95140: LD_INT 0
95142: ST_TO_ADDR
// sComputer := false ;
95143: LD_ADDR_EXP 131
95147: PUSH
95148: LD_INT 0
95150: ST_TO_ADDR
// s30 := false ;
95151: LD_ADDR_EXP 132
95155: PUSH
95156: LD_INT 0
95158: ST_TO_ADDR
// s60 := false ;
95159: LD_ADDR_EXP 133
95163: PUSH
95164: LD_INT 0
95166: ST_TO_ADDR
// end ;
95167: LD_VAR 0 1
95171: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95172: LD_INT 0
95174: PPUSH
95175: PPUSH
95176: PPUSH
95177: PPUSH
95178: PPUSH
95179: PPUSH
95180: PPUSH
// result := [ ] ;
95181: LD_ADDR_VAR 0 2
95185: PUSH
95186: EMPTY
95187: ST_TO_ADDR
// if campaign_id = 1 then
95188: LD_OWVAR 69
95192: PUSH
95193: LD_INT 1
95195: EQUAL
95196: IFFALSE 98362
// begin case mission_number of 1 :
95198: LD_OWVAR 70
95202: PUSH
95203: LD_INT 1
95205: DOUBLE
95206: EQUAL
95207: IFTRUE 95211
95209: GO 95287
95211: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95212: LD_ADDR_VAR 0 2
95216: PUSH
95217: LD_INT 2
95219: PUSH
95220: LD_INT 4
95222: PUSH
95223: LD_INT 11
95225: PUSH
95226: LD_INT 12
95228: PUSH
95229: LD_INT 15
95231: PUSH
95232: LD_INT 16
95234: PUSH
95235: LD_INT 22
95237: PUSH
95238: LD_INT 23
95240: PUSH
95241: LD_INT 26
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 101
95257: PUSH
95258: LD_INT 102
95260: PUSH
95261: LD_INT 106
95263: PUSH
95264: LD_INT 116
95266: PUSH
95267: LD_INT 117
95269: PUSH
95270: LD_INT 118
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: ST_TO_ADDR
95285: GO 98360
95287: LD_INT 2
95289: DOUBLE
95290: EQUAL
95291: IFTRUE 95295
95293: GO 95379
95295: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95296: LD_ADDR_VAR 0 2
95300: PUSH
95301: LD_INT 2
95303: PUSH
95304: LD_INT 4
95306: PUSH
95307: LD_INT 11
95309: PUSH
95310: LD_INT 12
95312: PUSH
95313: LD_INT 15
95315: PUSH
95316: LD_INT 16
95318: PUSH
95319: LD_INT 22
95321: PUSH
95322: LD_INT 23
95324: PUSH
95325: LD_INT 26
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: PUSH
95339: LD_INT 101
95341: PUSH
95342: LD_INT 102
95344: PUSH
95345: LD_INT 105
95347: PUSH
95348: LD_INT 106
95350: PUSH
95351: LD_INT 108
95353: PUSH
95354: LD_INT 116
95356: PUSH
95357: LD_INT 117
95359: PUSH
95360: LD_INT 118
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: ST_TO_ADDR
95377: GO 98360
95379: LD_INT 3
95381: DOUBLE
95382: EQUAL
95383: IFTRUE 95387
95385: GO 95475
95387: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95388: LD_ADDR_VAR 0 2
95392: PUSH
95393: LD_INT 2
95395: PUSH
95396: LD_INT 4
95398: PUSH
95399: LD_INT 5
95401: PUSH
95402: LD_INT 11
95404: PUSH
95405: LD_INT 12
95407: PUSH
95408: LD_INT 15
95410: PUSH
95411: LD_INT 16
95413: PUSH
95414: LD_INT 22
95416: PUSH
95417: LD_INT 26
95419: PUSH
95420: LD_INT 36
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 101
95437: PUSH
95438: LD_INT 102
95440: PUSH
95441: LD_INT 105
95443: PUSH
95444: LD_INT 106
95446: PUSH
95447: LD_INT 108
95449: PUSH
95450: LD_INT 116
95452: PUSH
95453: LD_INT 117
95455: PUSH
95456: LD_INT 118
95458: PUSH
95459: EMPTY
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: ST_TO_ADDR
95473: GO 98360
95475: LD_INT 4
95477: DOUBLE
95478: EQUAL
95479: IFTRUE 95483
95481: GO 95579
95483: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95484: LD_ADDR_VAR 0 2
95488: PUSH
95489: LD_INT 2
95491: PUSH
95492: LD_INT 4
95494: PUSH
95495: LD_INT 5
95497: PUSH
95498: LD_INT 8
95500: PUSH
95501: LD_INT 11
95503: PUSH
95504: LD_INT 12
95506: PUSH
95507: LD_INT 15
95509: PUSH
95510: LD_INT 16
95512: PUSH
95513: LD_INT 22
95515: PUSH
95516: LD_INT 23
95518: PUSH
95519: LD_INT 26
95521: PUSH
95522: LD_INT 36
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: PUSH
95539: LD_INT 101
95541: PUSH
95542: LD_INT 102
95544: PUSH
95545: LD_INT 105
95547: PUSH
95548: LD_INT 106
95550: PUSH
95551: LD_INT 108
95553: PUSH
95554: LD_INT 116
95556: PUSH
95557: LD_INT 117
95559: PUSH
95560: LD_INT 118
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: ST_TO_ADDR
95577: GO 98360
95579: LD_INT 5
95581: DOUBLE
95582: EQUAL
95583: IFTRUE 95587
95585: GO 95699
95587: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95588: LD_ADDR_VAR 0 2
95592: PUSH
95593: LD_INT 2
95595: PUSH
95596: LD_INT 4
95598: PUSH
95599: LD_INT 5
95601: PUSH
95602: LD_INT 6
95604: PUSH
95605: LD_INT 8
95607: PUSH
95608: LD_INT 11
95610: PUSH
95611: LD_INT 12
95613: PUSH
95614: LD_INT 15
95616: PUSH
95617: LD_INT 16
95619: PUSH
95620: LD_INT 22
95622: PUSH
95623: LD_INT 23
95625: PUSH
95626: LD_INT 25
95628: PUSH
95629: LD_INT 26
95631: PUSH
95632: LD_INT 36
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: PUSH
95651: LD_INT 101
95653: PUSH
95654: LD_INT 102
95656: PUSH
95657: LD_INT 105
95659: PUSH
95660: LD_INT 106
95662: PUSH
95663: LD_INT 108
95665: PUSH
95666: LD_INT 109
95668: PUSH
95669: LD_INT 112
95671: PUSH
95672: LD_INT 116
95674: PUSH
95675: LD_INT 117
95677: PUSH
95678: LD_INT 118
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: ST_TO_ADDR
95697: GO 98360
95699: LD_INT 6
95701: DOUBLE
95702: EQUAL
95703: IFTRUE 95707
95705: GO 95839
95707: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95708: LD_ADDR_VAR 0 2
95712: PUSH
95713: LD_INT 2
95715: PUSH
95716: LD_INT 4
95718: PUSH
95719: LD_INT 5
95721: PUSH
95722: LD_INT 6
95724: PUSH
95725: LD_INT 8
95727: PUSH
95728: LD_INT 11
95730: PUSH
95731: LD_INT 12
95733: PUSH
95734: LD_INT 15
95736: PUSH
95737: LD_INT 16
95739: PUSH
95740: LD_INT 20
95742: PUSH
95743: LD_INT 21
95745: PUSH
95746: LD_INT 22
95748: PUSH
95749: LD_INT 23
95751: PUSH
95752: LD_INT 25
95754: PUSH
95755: LD_INT 26
95757: PUSH
95758: LD_INT 30
95760: PUSH
95761: LD_INT 31
95763: PUSH
95764: LD_INT 32
95766: PUSH
95767: LD_INT 36
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 101
95793: PUSH
95794: LD_INT 102
95796: PUSH
95797: LD_INT 105
95799: PUSH
95800: LD_INT 106
95802: PUSH
95803: LD_INT 108
95805: PUSH
95806: LD_INT 109
95808: PUSH
95809: LD_INT 112
95811: PUSH
95812: LD_INT 116
95814: PUSH
95815: LD_INT 117
95817: PUSH
95818: LD_INT 118
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: ST_TO_ADDR
95837: GO 98360
95839: LD_INT 7
95841: DOUBLE
95842: EQUAL
95843: IFTRUE 95847
95845: GO 95959
95847: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95848: LD_ADDR_VAR 0 2
95852: PUSH
95853: LD_INT 2
95855: PUSH
95856: LD_INT 4
95858: PUSH
95859: LD_INT 5
95861: PUSH
95862: LD_INT 7
95864: PUSH
95865: LD_INT 11
95867: PUSH
95868: LD_INT 12
95870: PUSH
95871: LD_INT 15
95873: PUSH
95874: LD_INT 16
95876: PUSH
95877: LD_INT 20
95879: PUSH
95880: LD_INT 21
95882: PUSH
95883: LD_INT 22
95885: PUSH
95886: LD_INT 23
95888: PUSH
95889: LD_INT 25
95891: PUSH
95892: LD_INT 26
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 101
95913: PUSH
95914: LD_INT 102
95916: PUSH
95917: LD_INT 103
95919: PUSH
95920: LD_INT 105
95922: PUSH
95923: LD_INT 106
95925: PUSH
95926: LD_INT 108
95928: PUSH
95929: LD_INT 112
95931: PUSH
95932: LD_INT 116
95934: PUSH
95935: LD_INT 117
95937: PUSH
95938: LD_INT 118
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: ST_TO_ADDR
95957: GO 98360
95959: LD_INT 8
95961: DOUBLE
95962: EQUAL
95963: IFTRUE 95967
95965: GO 96107
95967: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95968: LD_ADDR_VAR 0 2
95972: PUSH
95973: LD_INT 2
95975: PUSH
95976: LD_INT 4
95978: PUSH
95979: LD_INT 5
95981: PUSH
95982: LD_INT 6
95984: PUSH
95985: LD_INT 7
95987: PUSH
95988: LD_INT 8
95990: PUSH
95991: LD_INT 11
95993: PUSH
95994: LD_INT 12
95996: PUSH
95997: LD_INT 15
95999: PUSH
96000: LD_INT 16
96002: PUSH
96003: LD_INT 20
96005: PUSH
96006: LD_INT 21
96008: PUSH
96009: LD_INT 22
96011: PUSH
96012: LD_INT 23
96014: PUSH
96015: LD_INT 25
96017: PUSH
96018: LD_INT 26
96020: PUSH
96021: LD_INT 30
96023: PUSH
96024: LD_INT 31
96026: PUSH
96027: LD_INT 32
96029: PUSH
96030: LD_INT 36
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: PUSH
96055: LD_INT 101
96057: PUSH
96058: LD_INT 102
96060: PUSH
96061: LD_INT 103
96063: PUSH
96064: LD_INT 105
96066: PUSH
96067: LD_INT 106
96069: PUSH
96070: LD_INT 108
96072: PUSH
96073: LD_INT 109
96075: PUSH
96076: LD_INT 112
96078: PUSH
96079: LD_INT 116
96081: PUSH
96082: LD_INT 117
96084: PUSH
96085: LD_INT 118
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: ST_TO_ADDR
96105: GO 98360
96107: LD_INT 9
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96115
96113: GO 96263
96115: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96116: LD_ADDR_VAR 0 2
96120: PUSH
96121: LD_INT 2
96123: PUSH
96124: LD_INT 4
96126: PUSH
96127: LD_INT 5
96129: PUSH
96130: LD_INT 6
96132: PUSH
96133: LD_INT 7
96135: PUSH
96136: LD_INT 8
96138: PUSH
96139: LD_INT 11
96141: PUSH
96142: LD_INT 12
96144: PUSH
96145: LD_INT 15
96147: PUSH
96148: LD_INT 16
96150: PUSH
96151: LD_INT 20
96153: PUSH
96154: LD_INT 21
96156: PUSH
96157: LD_INT 22
96159: PUSH
96160: LD_INT 23
96162: PUSH
96163: LD_INT 25
96165: PUSH
96166: LD_INT 26
96168: PUSH
96169: LD_INT 28
96171: PUSH
96172: LD_INT 30
96174: PUSH
96175: LD_INT 31
96177: PUSH
96178: LD_INT 32
96180: PUSH
96181: LD_INT 36
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: PUSH
96207: LD_INT 101
96209: PUSH
96210: LD_INT 102
96212: PUSH
96213: LD_INT 103
96215: PUSH
96216: LD_INT 105
96218: PUSH
96219: LD_INT 106
96221: PUSH
96222: LD_INT 108
96224: PUSH
96225: LD_INT 109
96227: PUSH
96228: LD_INT 112
96230: PUSH
96231: LD_INT 114
96233: PUSH
96234: LD_INT 116
96236: PUSH
96237: LD_INT 117
96239: PUSH
96240: LD_INT 118
96242: PUSH
96243: EMPTY
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: ST_TO_ADDR
96261: GO 98360
96263: LD_INT 10
96265: DOUBLE
96266: EQUAL
96267: IFTRUE 96271
96269: GO 96467
96271: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96272: LD_ADDR_VAR 0 2
96276: PUSH
96277: LD_INT 2
96279: PUSH
96280: LD_INT 4
96282: PUSH
96283: LD_INT 5
96285: PUSH
96286: LD_INT 6
96288: PUSH
96289: LD_INT 7
96291: PUSH
96292: LD_INT 8
96294: PUSH
96295: LD_INT 9
96297: PUSH
96298: LD_INT 10
96300: PUSH
96301: LD_INT 11
96303: PUSH
96304: LD_INT 12
96306: PUSH
96307: LD_INT 13
96309: PUSH
96310: LD_INT 14
96312: PUSH
96313: LD_INT 15
96315: PUSH
96316: LD_INT 16
96318: PUSH
96319: LD_INT 17
96321: PUSH
96322: LD_INT 18
96324: PUSH
96325: LD_INT 19
96327: PUSH
96328: LD_INT 20
96330: PUSH
96331: LD_INT 21
96333: PUSH
96334: LD_INT 22
96336: PUSH
96337: LD_INT 23
96339: PUSH
96340: LD_INT 24
96342: PUSH
96343: LD_INT 25
96345: PUSH
96346: LD_INT 26
96348: PUSH
96349: LD_INT 28
96351: PUSH
96352: LD_INT 30
96354: PUSH
96355: LD_INT 31
96357: PUSH
96358: LD_INT 32
96360: PUSH
96361: LD_INT 36
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: PUSH
96395: LD_INT 101
96397: PUSH
96398: LD_INT 102
96400: PUSH
96401: LD_INT 103
96403: PUSH
96404: LD_INT 104
96406: PUSH
96407: LD_INT 105
96409: PUSH
96410: LD_INT 106
96412: PUSH
96413: LD_INT 107
96415: PUSH
96416: LD_INT 108
96418: PUSH
96419: LD_INT 109
96421: PUSH
96422: LD_INT 110
96424: PUSH
96425: LD_INT 111
96427: PUSH
96428: LD_INT 112
96430: PUSH
96431: LD_INT 114
96433: PUSH
96434: LD_INT 116
96436: PUSH
96437: LD_INT 117
96439: PUSH
96440: LD_INT 118
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: PUSH
96461: EMPTY
96462: LIST
96463: LIST
96464: ST_TO_ADDR
96465: GO 98360
96467: LD_INT 11
96469: DOUBLE
96470: EQUAL
96471: IFTRUE 96475
96473: GO 96679
96475: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96476: LD_ADDR_VAR 0 2
96480: PUSH
96481: LD_INT 2
96483: PUSH
96484: LD_INT 3
96486: PUSH
96487: LD_INT 4
96489: PUSH
96490: LD_INT 5
96492: PUSH
96493: LD_INT 6
96495: PUSH
96496: LD_INT 7
96498: PUSH
96499: LD_INT 8
96501: PUSH
96502: LD_INT 9
96504: PUSH
96505: LD_INT 10
96507: PUSH
96508: LD_INT 11
96510: PUSH
96511: LD_INT 12
96513: PUSH
96514: LD_INT 13
96516: PUSH
96517: LD_INT 14
96519: PUSH
96520: LD_INT 15
96522: PUSH
96523: LD_INT 16
96525: PUSH
96526: LD_INT 17
96528: PUSH
96529: LD_INT 18
96531: PUSH
96532: LD_INT 19
96534: PUSH
96535: LD_INT 20
96537: PUSH
96538: LD_INT 21
96540: PUSH
96541: LD_INT 22
96543: PUSH
96544: LD_INT 23
96546: PUSH
96547: LD_INT 24
96549: PUSH
96550: LD_INT 25
96552: PUSH
96553: LD_INT 26
96555: PUSH
96556: LD_INT 28
96558: PUSH
96559: LD_INT 30
96561: PUSH
96562: LD_INT 31
96564: PUSH
96565: LD_INT 32
96567: PUSH
96568: LD_INT 34
96570: PUSH
96571: LD_INT 36
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 101
96609: PUSH
96610: LD_INT 102
96612: PUSH
96613: LD_INT 103
96615: PUSH
96616: LD_INT 104
96618: PUSH
96619: LD_INT 105
96621: PUSH
96622: LD_INT 106
96624: PUSH
96625: LD_INT 107
96627: PUSH
96628: LD_INT 108
96630: PUSH
96631: LD_INT 109
96633: PUSH
96634: LD_INT 110
96636: PUSH
96637: LD_INT 111
96639: PUSH
96640: LD_INT 112
96642: PUSH
96643: LD_INT 114
96645: PUSH
96646: LD_INT 116
96648: PUSH
96649: LD_INT 117
96651: PUSH
96652: LD_INT 118
96654: PUSH
96655: EMPTY
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: PUSH
96673: EMPTY
96674: LIST
96675: LIST
96676: ST_TO_ADDR
96677: GO 98360
96679: LD_INT 12
96681: DOUBLE
96682: EQUAL
96683: IFTRUE 96687
96685: GO 96907
96687: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96688: LD_ADDR_VAR 0 2
96692: PUSH
96693: LD_INT 1
96695: PUSH
96696: LD_INT 2
96698: PUSH
96699: LD_INT 3
96701: PUSH
96702: LD_INT 4
96704: PUSH
96705: LD_INT 5
96707: PUSH
96708: LD_INT 6
96710: PUSH
96711: LD_INT 7
96713: PUSH
96714: LD_INT 8
96716: PUSH
96717: LD_INT 9
96719: PUSH
96720: LD_INT 10
96722: PUSH
96723: LD_INT 11
96725: PUSH
96726: LD_INT 12
96728: PUSH
96729: LD_INT 13
96731: PUSH
96732: LD_INT 14
96734: PUSH
96735: LD_INT 15
96737: PUSH
96738: LD_INT 16
96740: PUSH
96741: LD_INT 17
96743: PUSH
96744: LD_INT 18
96746: PUSH
96747: LD_INT 19
96749: PUSH
96750: LD_INT 20
96752: PUSH
96753: LD_INT 21
96755: PUSH
96756: LD_INT 22
96758: PUSH
96759: LD_INT 23
96761: PUSH
96762: LD_INT 24
96764: PUSH
96765: LD_INT 25
96767: PUSH
96768: LD_INT 26
96770: PUSH
96771: LD_INT 27
96773: PUSH
96774: LD_INT 28
96776: PUSH
96777: LD_INT 30
96779: PUSH
96780: LD_INT 31
96782: PUSH
96783: LD_INT 32
96785: PUSH
96786: LD_INT 33
96788: PUSH
96789: LD_INT 34
96791: PUSH
96792: LD_INT 36
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 101
96833: PUSH
96834: LD_INT 102
96836: PUSH
96837: LD_INT 103
96839: PUSH
96840: LD_INT 104
96842: PUSH
96843: LD_INT 105
96845: PUSH
96846: LD_INT 106
96848: PUSH
96849: LD_INT 107
96851: PUSH
96852: LD_INT 108
96854: PUSH
96855: LD_INT 109
96857: PUSH
96858: LD_INT 110
96860: PUSH
96861: LD_INT 111
96863: PUSH
96864: LD_INT 112
96866: PUSH
96867: LD_INT 113
96869: PUSH
96870: LD_INT 114
96872: PUSH
96873: LD_INT 116
96875: PUSH
96876: LD_INT 117
96878: PUSH
96879: LD_INT 118
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: PUSH
96901: EMPTY
96902: LIST
96903: LIST
96904: ST_TO_ADDR
96905: GO 98360
96907: LD_INT 13
96909: DOUBLE
96910: EQUAL
96911: IFTRUE 96915
96913: GO 97123
96915: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96916: LD_ADDR_VAR 0 2
96920: PUSH
96921: LD_INT 1
96923: PUSH
96924: LD_INT 2
96926: PUSH
96927: LD_INT 3
96929: PUSH
96930: LD_INT 4
96932: PUSH
96933: LD_INT 5
96935: PUSH
96936: LD_INT 8
96938: PUSH
96939: LD_INT 9
96941: PUSH
96942: LD_INT 10
96944: PUSH
96945: LD_INT 11
96947: PUSH
96948: LD_INT 12
96950: PUSH
96951: LD_INT 14
96953: PUSH
96954: LD_INT 15
96956: PUSH
96957: LD_INT 16
96959: PUSH
96960: LD_INT 17
96962: PUSH
96963: LD_INT 18
96965: PUSH
96966: LD_INT 19
96968: PUSH
96969: LD_INT 20
96971: PUSH
96972: LD_INT 21
96974: PUSH
96975: LD_INT 22
96977: PUSH
96978: LD_INT 23
96980: PUSH
96981: LD_INT 24
96983: PUSH
96984: LD_INT 25
96986: PUSH
96987: LD_INT 26
96989: PUSH
96990: LD_INT 27
96992: PUSH
96993: LD_INT 28
96995: PUSH
96996: LD_INT 30
96998: PUSH
96999: LD_INT 31
97001: PUSH
97002: LD_INT 32
97004: PUSH
97005: LD_INT 33
97007: PUSH
97008: LD_INT 34
97010: PUSH
97011: LD_INT 36
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: PUSH
97047: LD_INT 101
97049: PUSH
97050: LD_INT 102
97052: PUSH
97053: LD_INT 103
97055: PUSH
97056: LD_INT 104
97058: PUSH
97059: LD_INT 105
97061: PUSH
97062: LD_INT 106
97064: PUSH
97065: LD_INT 107
97067: PUSH
97068: LD_INT 108
97070: PUSH
97071: LD_INT 109
97073: PUSH
97074: LD_INT 110
97076: PUSH
97077: LD_INT 111
97079: PUSH
97080: LD_INT 112
97082: PUSH
97083: LD_INT 113
97085: PUSH
97086: LD_INT 114
97088: PUSH
97089: LD_INT 116
97091: PUSH
97092: LD_INT 117
97094: PUSH
97095: LD_INT 118
97097: PUSH
97098: EMPTY
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: ST_TO_ADDR
97121: GO 98360
97123: LD_INT 14
97125: DOUBLE
97126: EQUAL
97127: IFTRUE 97131
97129: GO 97355
97131: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97132: LD_ADDR_VAR 0 2
97136: PUSH
97137: LD_INT 1
97139: PUSH
97140: LD_INT 2
97142: PUSH
97143: LD_INT 3
97145: PUSH
97146: LD_INT 4
97148: PUSH
97149: LD_INT 5
97151: PUSH
97152: LD_INT 6
97154: PUSH
97155: LD_INT 7
97157: PUSH
97158: LD_INT 8
97160: PUSH
97161: LD_INT 9
97163: PUSH
97164: LD_INT 10
97166: PUSH
97167: LD_INT 11
97169: PUSH
97170: LD_INT 12
97172: PUSH
97173: LD_INT 13
97175: PUSH
97176: LD_INT 14
97178: PUSH
97179: LD_INT 15
97181: PUSH
97182: LD_INT 16
97184: PUSH
97185: LD_INT 17
97187: PUSH
97188: LD_INT 18
97190: PUSH
97191: LD_INT 19
97193: PUSH
97194: LD_INT 20
97196: PUSH
97197: LD_INT 21
97199: PUSH
97200: LD_INT 22
97202: PUSH
97203: LD_INT 23
97205: PUSH
97206: LD_INT 24
97208: PUSH
97209: LD_INT 25
97211: PUSH
97212: LD_INT 26
97214: PUSH
97215: LD_INT 27
97217: PUSH
97218: LD_INT 28
97220: PUSH
97221: LD_INT 29
97223: PUSH
97224: LD_INT 30
97226: PUSH
97227: LD_INT 31
97229: PUSH
97230: LD_INT 32
97232: PUSH
97233: LD_INT 33
97235: PUSH
97236: LD_INT 34
97238: PUSH
97239: LD_INT 36
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: PUSH
97279: LD_INT 101
97281: PUSH
97282: LD_INT 102
97284: PUSH
97285: LD_INT 103
97287: PUSH
97288: LD_INT 104
97290: PUSH
97291: LD_INT 105
97293: PUSH
97294: LD_INT 106
97296: PUSH
97297: LD_INT 107
97299: PUSH
97300: LD_INT 108
97302: PUSH
97303: LD_INT 109
97305: PUSH
97306: LD_INT 110
97308: PUSH
97309: LD_INT 111
97311: PUSH
97312: LD_INT 112
97314: PUSH
97315: LD_INT 113
97317: PUSH
97318: LD_INT 114
97320: PUSH
97321: LD_INT 116
97323: PUSH
97324: LD_INT 117
97326: PUSH
97327: LD_INT 118
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: ST_TO_ADDR
97353: GO 98360
97355: LD_INT 15
97357: DOUBLE
97358: EQUAL
97359: IFTRUE 97363
97361: GO 97587
97363: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97364: LD_ADDR_VAR 0 2
97368: PUSH
97369: LD_INT 1
97371: PUSH
97372: LD_INT 2
97374: PUSH
97375: LD_INT 3
97377: PUSH
97378: LD_INT 4
97380: PUSH
97381: LD_INT 5
97383: PUSH
97384: LD_INT 6
97386: PUSH
97387: LD_INT 7
97389: PUSH
97390: LD_INT 8
97392: PUSH
97393: LD_INT 9
97395: PUSH
97396: LD_INT 10
97398: PUSH
97399: LD_INT 11
97401: PUSH
97402: LD_INT 12
97404: PUSH
97405: LD_INT 13
97407: PUSH
97408: LD_INT 14
97410: PUSH
97411: LD_INT 15
97413: PUSH
97414: LD_INT 16
97416: PUSH
97417: LD_INT 17
97419: PUSH
97420: LD_INT 18
97422: PUSH
97423: LD_INT 19
97425: PUSH
97426: LD_INT 20
97428: PUSH
97429: LD_INT 21
97431: PUSH
97432: LD_INT 22
97434: PUSH
97435: LD_INT 23
97437: PUSH
97438: LD_INT 24
97440: PUSH
97441: LD_INT 25
97443: PUSH
97444: LD_INT 26
97446: PUSH
97447: LD_INT 27
97449: PUSH
97450: LD_INT 28
97452: PUSH
97453: LD_INT 29
97455: PUSH
97456: LD_INT 30
97458: PUSH
97459: LD_INT 31
97461: PUSH
97462: LD_INT 32
97464: PUSH
97465: LD_INT 33
97467: PUSH
97468: LD_INT 34
97470: PUSH
97471: LD_INT 36
97473: PUSH
97474: EMPTY
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 101
97513: PUSH
97514: LD_INT 102
97516: PUSH
97517: LD_INT 103
97519: PUSH
97520: LD_INT 104
97522: PUSH
97523: LD_INT 105
97525: PUSH
97526: LD_INT 106
97528: PUSH
97529: LD_INT 107
97531: PUSH
97532: LD_INT 108
97534: PUSH
97535: LD_INT 109
97537: PUSH
97538: LD_INT 110
97540: PUSH
97541: LD_INT 111
97543: PUSH
97544: LD_INT 112
97546: PUSH
97547: LD_INT 113
97549: PUSH
97550: LD_INT 114
97552: PUSH
97553: LD_INT 116
97555: PUSH
97556: LD_INT 117
97558: PUSH
97559: LD_INT 118
97561: PUSH
97562: EMPTY
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: ST_TO_ADDR
97585: GO 98360
97587: LD_INT 16
97589: DOUBLE
97590: EQUAL
97591: IFTRUE 97595
97593: GO 97731
97595: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97596: LD_ADDR_VAR 0 2
97600: PUSH
97601: LD_INT 2
97603: PUSH
97604: LD_INT 4
97606: PUSH
97607: LD_INT 5
97609: PUSH
97610: LD_INT 7
97612: PUSH
97613: LD_INT 11
97615: PUSH
97616: LD_INT 12
97618: PUSH
97619: LD_INT 15
97621: PUSH
97622: LD_INT 16
97624: PUSH
97625: LD_INT 20
97627: PUSH
97628: LD_INT 21
97630: PUSH
97631: LD_INT 22
97633: PUSH
97634: LD_INT 23
97636: PUSH
97637: LD_INT 25
97639: PUSH
97640: LD_INT 26
97642: PUSH
97643: LD_INT 30
97645: PUSH
97646: LD_INT 31
97648: PUSH
97649: LD_INT 32
97651: PUSH
97652: LD_INT 33
97654: PUSH
97655: LD_INT 34
97657: PUSH
97658: EMPTY
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: PUSH
97679: LD_INT 101
97681: PUSH
97682: LD_INT 102
97684: PUSH
97685: LD_INT 103
97687: PUSH
97688: LD_INT 106
97690: PUSH
97691: LD_INT 108
97693: PUSH
97694: LD_INT 112
97696: PUSH
97697: LD_INT 113
97699: PUSH
97700: LD_INT 114
97702: PUSH
97703: LD_INT 116
97705: PUSH
97706: LD_INT 117
97708: PUSH
97709: LD_INT 118
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: ST_TO_ADDR
97729: GO 98360
97731: LD_INT 17
97733: DOUBLE
97734: EQUAL
97735: IFTRUE 97739
97737: GO 97963
97739: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97740: LD_ADDR_VAR 0 2
97744: PUSH
97745: LD_INT 1
97747: PUSH
97748: LD_INT 2
97750: PUSH
97751: LD_INT 3
97753: PUSH
97754: LD_INT 4
97756: PUSH
97757: LD_INT 5
97759: PUSH
97760: LD_INT 6
97762: PUSH
97763: LD_INT 7
97765: PUSH
97766: LD_INT 8
97768: PUSH
97769: LD_INT 9
97771: PUSH
97772: LD_INT 10
97774: PUSH
97775: LD_INT 11
97777: PUSH
97778: LD_INT 12
97780: PUSH
97781: LD_INT 13
97783: PUSH
97784: LD_INT 14
97786: PUSH
97787: LD_INT 15
97789: PUSH
97790: LD_INT 16
97792: PUSH
97793: LD_INT 17
97795: PUSH
97796: LD_INT 18
97798: PUSH
97799: LD_INT 19
97801: PUSH
97802: LD_INT 20
97804: PUSH
97805: LD_INT 21
97807: PUSH
97808: LD_INT 22
97810: PUSH
97811: LD_INT 23
97813: PUSH
97814: LD_INT 24
97816: PUSH
97817: LD_INT 25
97819: PUSH
97820: LD_INT 26
97822: PUSH
97823: LD_INT 27
97825: PUSH
97826: LD_INT 28
97828: PUSH
97829: LD_INT 29
97831: PUSH
97832: LD_INT 30
97834: PUSH
97835: LD_INT 31
97837: PUSH
97838: LD_INT 32
97840: PUSH
97841: LD_INT 33
97843: PUSH
97844: LD_INT 34
97846: PUSH
97847: LD_INT 36
97849: PUSH
97850: EMPTY
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: PUSH
97887: LD_INT 101
97889: PUSH
97890: LD_INT 102
97892: PUSH
97893: LD_INT 103
97895: PUSH
97896: LD_INT 104
97898: PUSH
97899: LD_INT 105
97901: PUSH
97902: LD_INT 106
97904: PUSH
97905: LD_INT 107
97907: PUSH
97908: LD_INT 108
97910: PUSH
97911: LD_INT 109
97913: PUSH
97914: LD_INT 110
97916: PUSH
97917: LD_INT 111
97919: PUSH
97920: LD_INT 112
97922: PUSH
97923: LD_INT 113
97925: PUSH
97926: LD_INT 114
97928: PUSH
97929: LD_INT 116
97931: PUSH
97932: LD_INT 117
97934: PUSH
97935: LD_INT 118
97937: PUSH
97938: EMPTY
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: ST_TO_ADDR
97961: GO 98360
97963: LD_INT 18
97965: DOUBLE
97966: EQUAL
97967: IFTRUE 97971
97969: GO 98119
97971: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97972: LD_ADDR_VAR 0 2
97976: PUSH
97977: LD_INT 2
97979: PUSH
97980: LD_INT 4
97982: PUSH
97983: LD_INT 5
97985: PUSH
97986: LD_INT 7
97988: PUSH
97989: LD_INT 11
97991: PUSH
97992: LD_INT 12
97994: PUSH
97995: LD_INT 15
97997: PUSH
97998: LD_INT 16
98000: PUSH
98001: LD_INT 20
98003: PUSH
98004: LD_INT 21
98006: PUSH
98007: LD_INT 22
98009: PUSH
98010: LD_INT 23
98012: PUSH
98013: LD_INT 25
98015: PUSH
98016: LD_INT 26
98018: PUSH
98019: LD_INT 30
98021: PUSH
98022: LD_INT 31
98024: PUSH
98025: LD_INT 32
98027: PUSH
98028: LD_INT 33
98030: PUSH
98031: LD_INT 34
98033: PUSH
98034: LD_INT 35
98036: PUSH
98037: LD_INT 36
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: LIST
98062: PUSH
98063: LD_INT 101
98065: PUSH
98066: LD_INT 102
98068: PUSH
98069: LD_INT 103
98071: PUSH
98072: LD_INT 106
98074: PUSH
98075: LD_INT 108
98077: PUSH
98078: LD_INT 112
98080: PUSH
98081: LD_INT 113
98083: PUSH
98084: LD_INT 114
98086: PUSH
98087: LD_INT 115
98089: PUSH
98090: LD_INT 116
98092: PUSH
98093: LD_INT 117
98095: PUSH
98096: LD_INT 118
98098: PUSH
98099: EMPTY
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: ST_TO_ADDR
98117: GO 98360
98119: LD_INT 19
98121: DOUBLE
98122: EQUAL
98123: IFTRUE 98127
98125: GO 98359
98127: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98128: LD_ADDR_VAR 0 2
98132: PUSH
98133: LD_INT 1
98135: PUSH
98136: LD_INT 2
98138: PUSH
98139: LD_INT 3
98141: PUSH
98142: LD_INT 4
98144: PUSH
98145: LD_INT 5
98147: PUSH
98148: LD_INT 6
98150: PUSH
98151: LD_INT 7
98153: PUSH
98154: LD_INT 8
98156: PUSH
98157: LD_INT 9
98159: PUSH
98160: LD_INT 10
98162: PUSH
98163: LD_INT 11
98165: PUSH
98166: LD_INT 12
98168: PUSH
98169: LD_INT 13
98171: PUSH
98172: LD_INT 14
98174: PUSH
98175: LD_INT 15
98177: PUSH
98178: LD_INT 16
98180: PUSH
98181: LD_INT 17
98183: PUSH
98184: LD_INT 18
98186: PUSH
98187: LD_INT 19
98189: PUSH
98190: LD_INT 20
98192: PUSH
98193: LD_INT 21
98195: PUSH
98196: LD_INT 22
98198: PUSH
98199: LD_INT 23
98201: PUSH
98202: LD_INT 24
98204: PUSH
98205: LD_INT 25
98207: PUSH
98208: LD_INT 26
98210: PUSH
98211: LD_INT 27
98213: PUSH
98214: LD_INT 28
98216: PUSH
98217: LD_INT 29
98219: PUSH
98220: LD_INT 30
98222: PUSH
98223: LD_INT 31
98225: PUSH
98226: LD_INT 32
98228: PUSH
98229: LD_INT 33
98231: PUSH
98232: LD_INT 34
98234: PUSH
98235: LD_INT 35
98237: PUSH
98238: LD_INT 36
98240: PUSH
98241: EMPTY
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: LIST
98272: LIST
98273: LIST
98274: LIST
98275: LIST
98276: LIST
98277: LIST
98278: PUSH
98279: LD_INT 101
98281: PUSH
98282: LD_INT 102
98284: PUSH
98285: LD_INT 103
98287: PUSH
98288: LD_INT 104
98290: PUSH
98291: LD_INT 105
98293: PUSH
98294: LD_INT 106
98296: PUSH
98297: LD_INT 107
98299: PUSH
98300: LD_INT 108
98302: PUSH
98303: LD_INT 109
98305: PUSH
98306: LD_INT 110
98308: PUSH
98309: LD_INT 111
98311: PUSH
98312: LD_INT 112
98314: PUSH
98315: LD_INT 113
98317: PUSH
98318: LD_INT 114
98320: PUSH
98321: LD_INT 115
98323: PUSH
98324: LD_INT 116
98326: PUSH
98327: LD_INT 117
98329: PUSH
98330: LD_INT 118
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: PUSH
98353: EMPTY
98354: LIST
98355: LIST
98356: ST_TO_ADDR
98357: GO 98360
98359: POP
// end else
98360: GO 98591
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98362: LD_ADDR_VAR 0 2
98366: PUSH
98367: LD_INT 1
98369: PUSH
98370: LD_INT 2
98372: PUSH
98373: LD_INT 3
98375: PUSH
98376: LD_INT 4
98378: PUSH
98379: LD_INT 5
98381: PUSH
98382: LD_INT 6
98384: PUSH
98385: LD_INT 7
98387: PUSH
98388: LD_INT 8
98390: PUSH
98391: LD_INT 9
98393: PUSH
98394: LD_INT 10
98396: PUSH
98397: LD_INT 11
98399: PUSH
98400: LD_INT 12
98402: PUSH
98403: LD_INT 13
98405: PUSH
98406: LD_INT 14
98408: PUSH
98409: LD_INT 15
98411: PUSH
98412: LD_INT 16
98414: PUSH
98415: LD_INT 17
98417: PUSH
98418: LD_INT 18
98420: PUSH
98421: LD_INT 19
98423: PUSH
98424: LD_INT 20
98426: PUSH
98427: LD_INT 21
98429: PUSH
98430: LD_INT 22
98432: PUSH
98433: LD_INT 23
98435: PUSH
98436: LD_INT 24
98438: PUSH
98439: LD_INT 25
98441: PUSH
98442: LD_INT 26
98444: PUSH
98445: LD_INT 27
98447: PUSH
98448: LD_INT 28
98450: PUSH
98451: LD_INT 29
98453: PUSH
98454: LD_INT 30
98456: PUSH
98457: LD_INT 31
98459: PUSH
98460: LD_INT 32
98462: PUSH
98463: LD_INT 33
98465: PUSH
98466: LD_INT 34
98468: PUSH
98469: LD_INT 35
98471: PUSH
98472: LD_INT 36
98474: PUSH
98475: EMPTY
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: PUSH
98513: LD_INT 101
98515: PUSH
98516: LD_INT 102
98518: PUSH
98519: LD_INT 103
98521: PUSH
98522: LD_INT 104
98524: PUSH
98525: LD_INT 105
98527: PUSH
98528: LD_INT 106
98530: PUSH
98531: LD_INT 107
98533: PUSH
98534: LD_INT 108
98536: PUSH
98537: LD_INT 109
98539: PUSH
98540: LD_INT 110
98542: PUSH
98543: LD_INT 111
98545: PUSH
98546: LD_INT 112
98548: PUSH
98549: LD_INT 113
98551: PUSH
98552: LD_INT 114
98554: PUSH
98555: LD_INT 115
98557: PUSH
98558: LD_INT 116
98560: PUSH
98561: LD_INT 117
98563: PUSH
98564: LD_INT 118
98566: PUSH
98567: EMPTY
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: PUSH
98587: EMPTY
98588: LIST
98589: LIST
98590: ST_TO_ADDR
// if result then
98591: LD_VAR 0 2
98595: IFFALSE 99381
// begin normal :=  ;
98597: LD_ADDR_VAR 0 5
98601: PUSH
98602: LD_STRING 
98604: ST_TO_ADDR
// hardcore :=  ;
98605: LD_ADDR_VAR 0 6
98609: PUSH
98610: LD_STRING 
98612: ST_TO_ADDR
// active :=  ;
98613: LD_ADDR_VAR 0 7
98617: PUSH
98618: LD_STRING 
98620: ST_TO_ADDR
// for i = 1 to normalCounter do
98621: LD_ADDR_VAR 0 8
98625: PUSH
98626: DOUBLE
98627: LD_INT 1
98629: DEC
98630: ST_TO_ADDR
98631: LD_EXP 78
98635: PUSH
98636: FOR_TO
98637: IFFALSE 98738
// begin tmp := 0 ;
98639: LD_ADDR_VAR 0 3
98643: PUSH
98644: LD_STRING 0
98646: ST_TO_ADDR
// if result [ 1 ] then
98647: LD_VAR 0 2
98651: PUSH
98652: LD_INT 1
98654: ARRAY
98655: IFFALSE 98720
// if result [ 1 ] [ 1 ] = i then
98657: LD_VAR 0 2
98661: PUSH
98662: LD_INT 1
98664: ARRAY
98665: PUSH
98666: LD_INT 1
98668: ARRAY
98669: PUSH
98670: LD_VAR 0 8
98674: EQUAL
98675: IFFALSE 98720
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98677: LD_ADDR_VAR 0 2
98681: PUSH
98682: LD_VAR 0 2
98686: PPUSH
98687: LD_INT 1
98689: PPUSH
98690: LD_VAR 0 2
98694: PUSH
98695: LD_INT 1
98697: ARRAY
98698: PPUSH
98699: LD_INT 1
98701: PPUSH
98702: CALL_OW 3
98706: PPUSH
98707: CALL_OW 1
98711: ST_TO_ADDR
// tmp := 1 ;
98712: LD_ADDR_VAR 0 3
98716: PUSH
98717: LD_STRING 1
98719: ST_TO_ADDR
// end ; normal := normal & tmp ;
98720: LD_ADDR_VAR 0 5
98724: PUSH
98725: LD_VAR 0 5
98729: PUSH
98730: LD_VAR 0 3
98734: STR
98735: ST_TO_ADDR
// end ;
98736: GO 98636
98738: POP
98739: POP
// for i = 1 to hardcoreCounter do
98740: LD_ADDR_VAR 0 8
98744: PUSH
98745: DOUBLE
98746: LD_INT 1
98748: DEC
98749: ST_TO_ADDR
98750: LD_EXP 79
98754: PUSH
98755: FOR_TO
98756: IFFALSE 98861
// begin tmp := 0 ;
98758: LD_ADDR_VAR 0 3
98762: PUSH
98763: LD_STRING 0
98765: ST_TO_ADDR
// if result [ 2 ] then
98766: LD_VAR 0 2
98770: PUSH
98771: LD_INT 2
98773: ARRAY
98774: IFFALSE 98843
// if result [ 2 ] [ 1 ] = 100 + i then
98776: LD_VAR 0 2
98780: PUSH
98781: LD_INT 2
98783: ARRAY
98784: PUSH
98785: LD_INT 1
98787: ARRAY
98788: PUSH
98789: LD_INT 100
98791: PUSH
98792: LD_VAR 0 8
98796: PLUS
98797: EQUAL
98798: IFFALSE 98843
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98800: LD_ADDR_VAR 0 2
98804: PUSH
98805: LD_VAR 0 2
98809: PPUSH
98810: LD_INT 2
98812: PPUSH
98813: LD_VAR 0 2
98817: PUSH
98818: LD_INT 2
98820: ARRAY
98821: PPUSH
98822: LD_INT 1
98824: PPUSH
98825: CALL_OW 3
98829: PPUSH
98830: CALL_OW 1
98834: ST_TO_ADDR
// tmp := 1 ;
98835: LD_ADDR_VAR 0 3
98839: PUSH
98840: LD_STRING 1
98842: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98843: LD_ADDR_VAR 0 6
98847: PUSH
98848: LD_VAR 0 6
98852: PUSH
98853: LD_VAR 0 3
98857: STR
98858: ST_TO_ADDR
// end ;
98859: GO 98755
98861: POP
98862: POP
// if isGameLoad then
98863: LD_VAR 0 1
98867: IFFALSE 99342
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98869: LD_ADDR_VAR 0 4
98873: PUSH
98874: LD_EXP 82
98878: PUSH
98879: LD_EXP 81
98883: PUSH
98884: LD_EXP 83
98888: PUSH
98889: LD_EXP 80
98893: PUSH
98894: LD_EXP 84
98898: PUSH
98899: LD_EXP 85
98903: PUSH
98904: LD_EXP 86
98908: PUSH
98909: LD_EXP 87
98913: PUSH
98914: LD_EXP 88
98918: PUSH
98919: LD_EXP 89
98923: PUSH
98924: LD_EXP 90
98928: PUSH
98929: LD_EXP 91
98933: PUSH
98934: LD_EXP 92
98938: PUSH
98939: LD_EXP 93
98943: PUSH
98944: LD_EXP 101
98948: PUSH
98949: LD_EXP 102
98953: PUSH
98954: LD_EXP 103
98958: PUSH
98959: LD_EXP 104
98963: PUSH
98964: LD_EXP 106
98968: PUSH
98969: LD_EXP 107
98973: PUSH
98974: LD_EXP 108
98978: PUSH
98979: LD_EXP 111
98983: PUSH
98984: LD_EXP 113
98988: PUSH
98989: LD_EXP 114
98993: PUSH
98994: LD_EXP 115
98998: PUSH
98999: LD_EXP 117
99003: PUSH
99004: LD_EXP 118
99008: PUSH
99009: LD_EXP 121
99013: PUSH
99014: LD_EXP 122
99018: PUSH
99019: LD_EXP 123
99023: PUSH
99024: LD_EXP 124
99028: PUSH
99029: LD_EXP 125
99033: PUSH
99034: LD_EXP 126
99038: PUSH
99039: LD_EXP 127
99043: PUSH
99044: LD_EXP 128
99048: PUSH
99049: LD_EXP 129
99053: PUSH
99054: LD_EXP 94
99058: PUSH
99059: LD_EXP 95
99063: PUSH
99064: LD_EXP 98
99068: PUSH
99069: LD_EXP 99
99073: PUSH
99074: LD_EXP 100
99078: PUSH
99079: LD_EXP 96
99083: PUSH
99084: LD_EXP 97
99088: PUSH
99089: LD_EXP 105
99093: PUSH
99094: LD_EXP 109
99098: PUSH
99099: LD_EXP 110
99103: PUSH
99104: LD_EXP 112
99108: PUSH
99109: LD_EXP 116
99113: PUSH
99114: LD_EXP 119
99118: PUSH
99119: LD_EXP 120
99123: PUSH
99124: LD_EXP 130
99128: PUSH
99129: LD_EXP 131
99133: PUSH
99134: LD_EXP 132
99138: PUSH
99139: LD_EXP 133
99143: PUSH
99144: EMPTY
99145: LIST
99146: LIST
99147: LIST
99148: LIST
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: LIST
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: ST_TO_ADDR
// tmp :=  ;
99200: LD_ADDR_VAR 0 3
99204: PUSH
99205: LD_STRING 
99207: ST_TO_ADDR
// for i = 1 to normalCounter do
99208: LD_ADDR_VAR 0 8
99212: PUSH
99213: DOUBLE
99214: LD_INT 1
99216: DEC
99217: ST_TO_ADDR
99218: LD_EXP 78
99222: PUSH
99223: FOR_TO
99224: IFFALSE 99260
// begin if flags [ i ] then
99226: LD_VAR 0 4
99230: PUSH
99231: LD_VAR 0 8
99235: ARRAY
99236: IFFALSE 99258
// tmp := tmp & i & ; ;
99238: LD_ADDR_VAR 0 3
99242: PUSH
99243: LD_VAR 0 3
99247: PUSH
99248: LD_VAR 0 8
99252: STR
99253: PUSH
99254: LD_STRING ;
99256: STR
99257: ST_TO_ADDR
// end ;
99258: GO 99223
99260: POP
99261: POP
// for i = 1 to hardcoreCounter do
99262: LD_ADDR_VAR 0 8
99266: PUSH
99267: DOUBLE
99268: LD_INT 1
99270: DEC
99271: ST_TO_ADDR
99272: LD_EXP 79
99276: PUSH
99277: FOR_TO
99278: IFFALSE 99324
// begin if flags [ normalCounter + i ] then
99280: LD_VAR 0 4
99284: PUSH
99285: LD_EXP 78
99289: PUSH
99290: LD_VAR 0 8
99294: PLUS
99295: ARRAY
99296: IFFALSE 99322
// tmp := tmp & ( 100 + i ) & ; ;
99298: LD_ADDR_VAR 0 3
99302: PUSH
99303: LD_VAR 0 3
99307: PUSH
99308: LD_INT 100
99310: PUSH
99311: LD_VAR 0 8
99315: PLUS
99316: STR
99317: PUSH
99318: LD_STRING ;
99320: STR
99321: ST_TO_ADDR
// end ;
99322: GO 99277
99324: POP
99325: POP
// if tmp then
99326: LD_VAR 0 3
99330: IFFALSE 99342
// active := tmp ;
99332: LD_ADDR_VAR 0 7
99336: PUSH
99337: LD_VAR 0 3
99341: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99342: LD_STRING getStreamItemsFromMission("
99344: PUSH
99345: LD_VAR 0 5
99349: STR
99350: PUSH
99351: LD_STRING ","
99353: STR
99354: PUSH
99355: LD_VAR 0 6
99359: STR
99360: PUSH
99361: LD_STRING ","
99363: STR
99364: PUSH
99365: LD_VAR 0 7
99369: STR
99370: PUSH
99371: LD_STRING ")
99373: STR
99374: PPUSH
99375: CALL_OW 559
// end else
99379: GO 99388
// ToLua ( getStreamItemsFromMission("","","") ) ;
99381: LD_STRING getStreamItemsFromMission("","","")
99383: PPUSH
99384: CALL_OW 559
// end ;
99388: LD_VAR 0 2
99392: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99393: LD_EXP 77
99397: PUSH
99398: LD_EXP 82
99402: AND
99403: IFFALSE 99527
99405: GO 99407
99407: DISABLE
99408: LD_INT 0
99410: PPUSH
99411: PPUSH
// begin enable ;
99412: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99413: LD_ADDR_VAR 0 2
99417: PUSH
99418: LD_INT 22
99420: PUSH
99421: LD_OWVAR 2
99425: PUSH
99426: EMPTY
99427: LIST
99428: LIST
99429: PUSH
99430: LD_INT 2
99432: PUSH
99433: LD_INT 34
99435: PUSH
99436: LD_INT 7
99438: PUSH
99439: EMPTY
99440: LIST
99441: LIST
99442: PUSH
99443: LD_INT 34
99445: PUSH
99446: LD_INT 45
99448: PUSH
99449: EMPTY
99450: LIST
99451: LIST
99452: PUSH
99453: LD_INT 34
99455: PUSH
99456: LD_INT 28
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: PUSH
99463: LD_INT 34
99465: PUSH
99466: LD_INT 47
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: LIST
99477: LIST
99478: LIST
99479: PUSH
99480: EMPTY
99481: LIST
99482: LIST
99483: PPUSH
99484: CALL_OW 69
99488: ST_TO_ADDR
// if not tmp then
99489: LD_VAR 0 2
99493: NOT
99494: IFFALSE 99498
// exit ;
99496: GO 99527
// for i in tmp do
99498: LD_ADDR_VAR 0 1
99502: PUSH
99503: LD_VAR 0 2
99507: PUSH
99508: FOR_IN
99509: IFFALSE 99525
// begin SetLives ( i , 0 ) ;
99511: LD_VAR 0 1
99515: PPUSH
99516: LD_INT 0
99518: PPUSH
99519: CALL_OW 234
// end ;
99523: GO 99508
99525: POP
99526: POP
// end ;
99527: PPOPN 2
99529: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99530: LD_EXP 77
99534: PUSH
99535: LD_EXP 83
99539: AND
99540: IFFALSE 99624
99542: GO 99544
99544: DISABLE
99545: LD_INT 0
99547: PPUSH
99548: PPUSH
// begin enable ;
99549: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99550: LD_ADDR_VAR 0 2
99554: PUSH
99555: LD_INT 22
99557: PUSH
99558: LD_OWVAR 2
99562: PUSH
99563: EMPTY
99564: LIST
99565: LIST
99566: PUSH
99567: LD_INT 32
99569: PUSH
99570: LD_INT 3
99572: PUSH
99573: EMPTY
99574: LIST
99575: LIST
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: PPUSH
99581: CALL_OW 69
99585: ST_TO_ADDR
// if not tmp then
99586: LD_VAR 0 2
99590: NOT
99591: IFFALSE 99595
// exit ;
99593: GO 99624
// for i in tmp do
99595: LD_ADDR_VAR 0 1
99599: PUSH
99600: LD_VAR 0 2
99604: PUSH
99605: FOR_IN
99606: IFFALSE 99622
// begin SetLives ( i , 0 ) ;
99608: LD_VAR 0 1
99612: PPUSH
99613: LD_INT 0
99615: PPUSH
99616: CALL_OW 234
// end ;
99620: GO 99605
99622: POP
99623: POP
// end ;
99624: PPOPN 2
99626: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99627: LD_EXP 77
99631: PUSH
99632: LD_EXP 80
99636: AND
99637: IFFALSE 99730
99639: GO 99641
99641: DISABLE
99642: LD_INT 0
99644: PPUSH
// begin enable ;
99645: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99646: LD_ADDR_VAR 0 1
99650: PUSH
99651: LD_INT 22
99653: PUSH
99654: LD_OWVAR 2
99658: PUSH
99659: EMPTY
99660: LIST
99661: LIST
99662: PUSH
99663: LD_INT 2
99665: PUSH
99666: LD_INT 25
99668: PUSH
99669: LD_INT 5
99671: PUSH
99672: EMPTY
99673: LIST
99674: LIST
99675: PUSH
99676: LD_INT 25
99678: PUSH
99679: LD_INT 9
99681: PUSH
99682: EMPTY
99683: LIST
99684: LIST
99685: PUSH
99686: LD_INT 25
99688: PUSH
99689: LD_INT 8
99691: PUSH
99692: EMPTY
99693: LIST
99694: LIST
99695: PUSH
99696: EMPTY
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: PPUSH
99706: CALL_OW 69
99710: PUSH
99711: FOR_IN
99712: IFFALSE 99728
// begin SetClass ( i , 1 ) ;
99714: LD_VAR 0 1
99718: PPUSH
99719: LD_INT 1
99721: PPUSH
99722: CALL_OW 336
// end ;
99726: GO 99711
99728: POP
99729: POP
// end ;
99730: PPOPN 1
99732: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99733: LD_EXP 77
99737: PUSH
99738: LD_EXP 81
99742: AND
99743: PUSH
99744: LD_OWVAR 65
99748: PUSH
99749: LD_INT 7
99751: LESS
99752: AND
99753: IFFALSE 99767
99755: GO 99757
99757: DISABLE
// begin enable ;
99758: ENABLE
// game_speed := 7 ;
99759: LD_ADDR_OWVAR 65
99763: PUSH
99764: LD_INT 7
99766: ST_TO_ADDR
// end ;
99767: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99768: LD_EXP 77
99772: PUSH
99773: LD_EXP 84
99777: AND
99778: IFFALSE 99980
99780: GO 99782
99782: DISABLE
99783: LD_INT 0
99785: PPUSH
99786: PPUSH
99787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99788: LD_ADDR_VAR 0 3
99792: PUSH
99793: LD_INT 81
99795: PUSH
99796: LD_OWVAR 2
99800: PUSH
99801: EMPTY
99802: LIST
99803: LIST
99804: PUSH
99805: LD_INT 21
99807: PUSH
99808: LD_INT 1
99810: PUSH
99811: EMPTY
99812: LIST
99813: LIST
99814: PUSH
99815: EMPTY
99816: LIST
99817: LIST
99818: PPUSH
99819: CALL_OW 69
99823: ST_TO_ADDR
// if not tmp then
99824: LD_VAR 0 3
99828: NOT
99829: IFFALSE 99833
// exit ;
99831: GO 99980
// if tmp > 5 then
99833: LD_VAR 0 3
99837: PUSH
99838: LD_INT 5
99840: GREATER
99841: IFFALSE 99853
// k := 5 else
99843: LD_ADDR_VAR 0 2
99847: PUSH
99848: LD_INT 5
99850: ST_TO_ADDR
99851: GO 99863
// k := tmp ;
99853: LD_ADDR_VAR 0 2
99857: PUSH
99858: LD_VAR 0 3
99862: ST_TO_ADDR
// for i := 1 to k do
99863: LD_ADDR_VAR 0 1
99867: PUSH
99868: DOUBLE
99869: LD_INT 1
99871: DEC
99872: ST_TO_ADDR
99873: LD_VAR 0 2
99877: PUSH
99878: FOR_TO
99879: IFFALSE 99978
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99881: LD_VAR 0 3
99885: PUSH
99886: LD_VAR 0 1
99890: ARRAY
99891: PPUSH
99892: LD_VAR 0 1
99896: PUSH
99897: LD_INT 4
99899: MOD
99900: PUSH
99901: LD_INT 1
99903: PLUS
99904: PPUSH
99905: CALL_OW 259
99909: PUSH
99910: LD_INT 10
99912: LESS
99913: IFFALSE 99976
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99915: LD_VAR 0 3
99919: PUSH
99920: LD_VAR 0 1
99924: ARRAY
99925: PPUSH
99926: LD_VAR 0 1
99930: PUSH
99931: LD_INT 4
99933: MOD
99934: PUSH
99935: LD_INT 1
99937: PLUS
99938: PPUSH
99939: LD_VAR 0 3
99943: PUSH
99944: LD_VAR 0 1
99948: ARRAY
99949: PPUSH
99950: LD_VAR 0 1
99954: PUSH
99955: LD_INT 4
99957: MOD
99958: PUSH
99959: LD_INT 1
99961: PLUS
99962: PPUSH
99963: CALL_OW 259
99967: PUSH
99968: LD_INT 1
99970: PLUS
99971: PPUSH
99972: CALL_OW 237
99976: GO 99878
99978: POP
99979: POP
// end ;
99980: PPOPN 3
99982: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99983: LD_EXP 77
99987: PUSH
99988: LD_EXP 85
99992: AND
99993: IFFALSE 100013
99995: GO 99997
99997: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99998: LD_INT 4
100000: PPUSH
100001: LD_OWVAR 2
100005: PPUSH
100006: LD_INT 0
100008: PPUSH
100009: CALL_OW 324
100013: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100014: LD_EXP 77
100018: PUSH
100019: LD_EXP 114
100023: AND
100024: IFFALSE 100044
100026: GO 100028
100028: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100029: LD_INT 19
100031: PPUSH
100032: LD_OWVAR 2
100036: PPUSH
100037: LD_INT 0
100039: PPUSH
100040: CALL_OW 324
100044: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100045: LD_EXP 77
100049: PUSH
100050: LD_EXP 86
100054: AND
100055: IFFALSE 100157
100057: GO 100059
100059: DISABLE
100060: LD_INT 0
100062: PPUSH
100063: PPUSH
// begin enable ;
100064: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100065: LD_ADDR_VAR 0 2
100069: PUSH
100070: LD_INT 22
100072: PUSH
100073: LD_OWVAR 2
100077: PUSH
100078: EMPTY
100079: LIST
100080: LIST
100081: PUSH
100082: LD_INT 2
100084: PUSH
100085: LD_INT 34
100087: PUSH
100088: LD_INT 11
100090: PUSH
100091: EMPTY
100092: LIST
100093: LIST
100094: PUSH
100095: LD_INT 34
100097: PUSH
100098: LD_INT 30
100100: PUSH
100101: EMPTY
100102: LIST
100103: LIST
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: LIST
100109: PUSH
100110: EMPTY
100111: LIST
100112: LIST
100113: PPUSH
100114: CALL_OW 69
100118: ST_TO_ADDR
// if not tmp then
100119: LD_VAR 0 2
100123: NOT
100124: IFFALSE 100128
// exit ;
100126: GO 100157
// for i in tmp do
100128: LD_ADDR_VAR 0 1
100132: PUSH
100133: LD_VAR 0 2
100137: PUSH
100138: FOR_IN
100139: IFFALSE 100155
// begin SetLives ( i , 0 ) ;
100141: LD_VAR 0 1
100145: PPUSH
100146: LD_INT 0
100148: PPUSH
100149: CALL_OW 234
// end ;
100153: GO 100138
100155: POP
100156: POP
// end ;
100157: PPOPN 2
100159: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100160: LD_EXP 77
100164: PUSH
100165: LD_EXP 87
100169: AND
100170: IFFALSE 100190
100172: GO 100174
100174: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100175: LD_INT 32
100177: PPUSH
100178: LD_OWVAR 2
100182: PPUSH
100183: LD_INT 0
100185: PPUSH
100186: CALL_OW 324
100190: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100191: LD_EXP 77
100195: PUSH
100196: LD_EXP 88
100200: AND
100201: IFFALSE 100382
100203: GO 100205
100205: DISABLE
100206: LD_INT 0
100208: PPUSH
100209: PPUSH
100210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100211: LD_ADDR_VAR 0 2
100215: PUSH
100216: LD_INT 22
100218: PUSH
100219: LD_OWVAR 2
100223: PUSH
100224: EMPTY
100225: LIST
100226: LIST
100227: PUSH
100228: LD_INT 33
100230: PUSH
100231: LD_INT 3
100233: PUSH
100234: EMPTY
100235: LIST
100236: LIST
100237: PUSH
100238: EMPTY
100239: LIST
100240: LIST
100241: PPUSH
100242: CALL_OW 69
100246: ST_TO_ADDR
// if not tmp then
100247: LD_VAR 0 2
100251: NOT
100252: IFFALSE 100256
// exit ;
100254: GO 100382
// side := 0 ;
100256: LD_ADDR_VAR 0 3
100260: PUSH
100261: LD_INT 0
100263: ST_TO_ADDR
// for i := 1 to 8 do
100264: LD_ADDR_VAR 0 1
100268: PUSH
100269: DOUBLE
100270: LD_INT 1
100272: DEC
100273: ST_TO_ADDR
100274: LD_INT 8
100276: PUSH
100277: FOR_TO
100278: IFFALSE 100326
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100280: LD_OWVAR 2
100284: PUSH
100285: LD_VAR 0 1
100289: NONEQUAL
100290: PUSH
100291: LD_OWVAR 2
100295: PPUSH
100296: LD_VAR 0 1
100300: PPUSH
100301: CALL_OW 81
100305: PUSH
100306: LD_INT 2
100308: EQUAL
100309: AND
100310: IFFALSE 100324
// begin side := i ;
100312: LD_ADDR_VAR 0 3
100316: PUSH
100317: LD_VAR 0 1
100321: ST_TO_ADDR
// break ;
100322: GO 100326
// end ;
100324: GO 100277
100326: POP
100327: POP
// if not side then
100328: LD_VAR 0 3
100332: NOT
100333: IFFALSE 100337
// exit ;
100335: GO 100382
// for i := 1 to tmp do
100337: LD_ADDR_VAR 0 1
100341: PUSH
100342: DOUBLE
100343: LD_INT 1
100345: DEC
100346: ST_TO_ADDR
100347: LD_VAR 0 2
100351: PUSH
100352: FOR_TO
100353: IFFALSE 100380
// if Prob ( 60 ) then
100355: LD_INT 60
100357: PPUSH
100358: CALL_OW 13
100362: IFFALSE 100378
// SetSide ( i , side ) ;
100364: LD_VAR 0 1
100368: PPUSH
100369: LD_VAR 0 3
100373: PPUSH
100374: CALL_OW 235
100378: GO 100352
100380: POP
100381: POP
// end ;
100382: PPOPN 3
100384: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100385: LD_EXP 77
100389: PUSH
100390: LD_EXP 90
100394: AND
100395: IFFALSE 100514
100397: GO 100399
100399: DISABLE
100400: LD_INT 0
100402: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100403: LD_ADDR_VAR 0 1
100407: PUSH
100408: LD_INT 22
100410: PUSH
100411: LD_OWVAR 2
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: PUSH
100420: LD_INT 21
100422: PUSH
100423: LD_INT 1
100425: PUSH
100426: EMPTY
100427: LIST
100428: LIST
100429: PUSH
100430: LD_INT 3
100432: PUSH
100433: LD_INT 23
100435: PUSH
100436: LD_INT 0
100438: PUSH
100439: EMPTY
100440: LIST
100441: LIST
100442: PUSH
100443: EMPTY
100444: LIST
100445: LIST
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: LIST
100451: PPUSH
100452: CALL_OW 69
100456: PUSH
100457: FOR_IN
100458: IFFALSE 100512
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100460: LD_VAR 0 1
100464: PPUSH
100465: CALL_OW 257
100469: PUSH
100470: LD_INT 1
100472: PUSH
100473: LD_INT 2
100475: PUSH
100476: LD_INT 3
100478: PUSH
100479: LD_INT 4
100481: PUSH
100482: EMPTY
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: IN
100488: IFFALSE 100510
// SetClass ( un , rand ( 1 , 4 ) ) ;
100490: LD_VAR 0 1
100494: PPUSH
100495: LD_INT 1
100497: PPUSH
100498: LD_INT 4
100500: PPUSH
100501: CALL_OW 12
100505: PPUSH
100506: CALL_OW 336
100510: GO 100457
100512: POP
100513: POP
// end ;
100514: PPOPN 1
100516: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100517: LD_EXP 77
100521: PUSH
100522: LD_EXP 89
100526: AND
100527: IFFALSE 100606
100529: GO 100531
100531: DISABLE
100532: LD_INT 0
100534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100535: LD_ADDR_VAR 0 1
100539: PUSH
100540: LD_INT 22
100542: PUSH
100543: LD_OWVAR 2
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: LD_INT 21
100554: PUSH
100555: LD_INT 3
100557: PUSH
100558: EMPTY
100559: LIST
100560: LIST
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: PPUSH
100566: CALL_OW 69
100570: ST_TO_ADDR
// if not tmp then
100571: LD_VAR 0 1
100575: NOT
100576: IFFALSE 100580
// exit ;
100578: GO 100606
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100580: LD_VAR 0 1
100584: PUSH
100585: LD_INT 1
100587: PPUSH
100588: LD_VAR 0 1
100592: PPUSH
100593: CALL_OW 12
100597: ARRAY
100598: PPUSH
100599: LD_INT 100
100601: PPUSH
100602: CALL_OW 234
// end ;
100606: PPOPN 1
100608: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100609: LD_EXP 77
100613: PUSH
100614: LD_EXP 91
100618: AND
100619: IFFALSE 100717
100621: GO 100623
100623: DISABLE
100624: LD_INT 0
100626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100627: LD_ADDR_VAR 0 1
100631: PUSH
100632: LD_INT 22
100634: PUSH
100635: LD_OWVAR 2
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: PUSH
100644: LD_INT 21
100646: PUSH
100647: LD_INT 1
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PPUSH
100658: CALL_OW 69
100662: ST_TO_ADDR
// if not tmp then
100663: LD_VAR 0 1
100667: NOT
100668: IFFALSE 100672
// exit ;
100670: GO 100717
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100672: LD_VAR 0 1
100676: PUSH
100677: LD_INT 1
100679: PPUSH
100680: LD_VAR 0 1
100684: PPUSH
100685: CALL_OW 12
100689: ARRAY
100690: PPUSH
100691: LD_INT 1
100693: PPUSH
100694: LD_INT 4
100696: PPUSH
100697: CALL_OW 12
100701: PPUSH
100702: LD_INT 3000
100704: PPUSH
100705: LD_INT 9000
100707: PPUSH
100708: CALL_OW 12
100712: PPUSH
100713: CALL_OW 492
// end ;
100717: PPOPN 1
100719: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100720: LD_EXP 77
100724: PUSH
100725: LD_EXP 92
100729: AND
100730: IFFALSE 100750
100732: GO 100734
100734: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100735: LD_INT 1
100737: PPUSH
100738: LD_OWVAR 2
100742: PPUSH
100743: LD_INT 0
100745: PPUSH
100746: CALL_OW 324
100750: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100751: LD_EXP 77
100755: PUSH
100756: LD_EXP 93
100760: AND
100761: IFFALSE 100844
100763: GO 100765
100765: DISABLE
100766: LD_INT 0
100768: PPUSH
100769: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100770: LD_ADDR_VAR 0 2
100774: PUSH
100775: LD_INT 22
100777: PUSH
100778: LD_OWVAR 2
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PUSH
100787: LD_INT 21
100789: PUSH
100790: LD_INT 3
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: EMPTY
100798: LIST
100799: LIST
100800: PPUSH
100801: CALL_OW 69
100805: ST_TO_ADDR
// if not tmp then
100806: LD_VAR 0 2
100810: NOT
100811: IFFALSE 100815
// exit ;
100813: GO 100844
// for i in tmp do
100815: LD_ADDR_VAR 0 1
100819: PUSH
100820: LD_VAR 0 2
100824: PUSH
100825: FOR_IN
100826: IFFALSE 100842
// SetBLevel ( i , 10 ) ;
100828: LD_VAR 0 1
100832: PPUSH
100833: LD_INT 10
100835: PPUSH
100836: CALL_OW 241
100840: GO 100825
100842: POP
100843: POP
// end ;
100844: PPOPN 2
100846: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100847: LD_EXP 77
100851: PUSH
100852: LD_EXP 94
100856: AND
100857: IFFALSE 100968
100859: GO 100861
100861: DISABLE
100862: LD_INT 0
100864: PPUSH
100865: PPUSH
100866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100867: LD_ADDR_VAR 0 3
100871: PUSH
100872: LD_INT 22
100874: PUSH
100875: LD_OWVAR 2
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PUSH
100884: LD_INT 25
100886: PUSH
100887: LD_INT 1
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PUSH
100894: EMPTY
100895: LIST
100896: LIST
100897: PPUSH
100898: CALL_OW 69
100902: ST_TO_ADDR
// if not tmp then
100903: LD_VAR 0 3
100907: NOT
100908: IFFALSE 100912
// exit ;
100910: GO 100968
// un := tmp [ rand ( 1 , tmp ) ] ;
100912: LD_ADDR_VAR 0 2
100916: PUSH
100917: LD_VAR 0 3
100921: PUSH
100922: LD_INT 1
100924: PPUSH
100925: LD_VAR 0 3
100929: PPUSH
100930: CALL_OW 12
100934: ARRAY
100935: ST_TO_ADDR
// if Crawls ( un ) then
100936: LD_VAR 0 2
100940: PPUSH
100941: CALL_OW 318
100945: IFFALSE 100956
// ComWalk ( un ) ;
100947: LD_VAR 0 2
100951: PPUSH
100952: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100956: LD_VAR 0 2
100960: PPUSH
100961: LD_INT 5
100963: PPUSH
100964: CALL_OW 336
// end ;
100968: PPOPN 3
100970: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100971: LD_EXP 77
100975: PUSH
100976: LD_EXP 95
100980: AND
100981: PUSH
100982: LD_OWVAR 67
100986: PUSH
100987: LD_INT 4
100989: LESS
100990: AND
100991: IFFALSE 101010
100993: GO 100995
100995: DISABLE
// begin Difficulty := Difficulty + 1 ;
100996: LD_ADDR_OWVAR 67
101000: PUSH
101001: LD_OWVAR 67
101005: PUSH
101006: LD_INT 1
101008: PLUS
101009: ST_TO_ADDR
// end ;
101010: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101011: LD_EXP 77
101015: PUSH
101016: LD_EXP 96
101020: AND
101021: IFFALSE 101124
101023: GO 101025
101025: DISABLE
101026: LD_INT 0
101028: PPUSH
// begin for i := 1 to 5 do
101029: LD_ADDR_VAR 0 1
101033: PUSH
101034: DOUBLE
101035: LD_INT 1
101037: DEC
101038: ST_TO_ADDR
101039: LD_INT 5
101041: PUSH
101042: FOR_TO
101043: IFFALSE 101122
// begin uc_nation := nation_nature ;
101045: LD_ADDR_OWVAR 21
101049: PUSH
101050: LD_INT 0
101052: ST_TO_ADDR
// uc_side := 0 ;
101053: LD_ADDR_OWVAR 20
101057: PUSH
101058: LD_INT 0
101060: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101061: LD_ADDR_OWVAR 29
101065: PUSH
101066: LD_INT 12
101068: PUSH
101069: LD_INT 12
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: ST_TO_ADDR
// hc_agressivity := 20 ;
101076: LD_ADDR_OWVAR 35
101080: PUSH
101081: LD_INT 20
101083: ST_TO_ADDR
// hc_class := class_tiger ;
101084: LD_ADDR_OWVAR 28
101088: PUSH
101089: LD_INT 14
101091: ST_TO_ADDR
// hc_gallery :=  ;
101092: LD_ADDR_OWVAR 33
101096: PUSH
101097: LD_STRING 
101099: ST_TO_ADDR
// hc_name :=  ;
101100: LD_ADDR_OWVAR 26
101104: PUSH
101105: LD_STRING 
101107: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101108: CALL_OW 44
101112: PPUSH
101113: LD_INT 0
101115: PPUSH
101116: CALL_OW 51
// end ;
101120: GO 101042
101122: POP
101123: POP
// end ;
101124: PPOPN 1
101126: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101127: LD_EXP 77
101131: PUSH
101132: LD_EXP 97
101136: AND
101137: IFFALSE 101146
101139: GO 101141
101141: DISABLE
// StreamSibBomb ;
101142: CALL 101147 0 0
101146: END
// export function StreamSibBomb ; var i , x , y ; begin
101147: LD_INT 0
101149: PPUSH
101150: PPUSH
101151: PPUSH
101152: PPUSH
// result := false ;
101153: LD_ADDR_VAR 0 1
101157: PUSH
101158: LD_INT 0
101160: ST_TO_ADDR
// for i := 1 to 16 do
101161: LD_ADDR_VAR 0 2
101165: PUSH
101166: DOUBLE
101167: LD_INT 1
101169: DEC
101170: ST_TO_ADDR
101171: LD_INT 16
101173: PUSH
101174: FOR_TO
101175: IFFALSE 101374
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101177: LD_ADDR_VAR 0 3
101181: PUSH
101182: LD_INT 10
101184: PUSH
101185: LD_INT 20
101187: PUSH
101188: LD_INT 30
101190: PUSH
101191: LD_INT 40
101193: PUSH
101194: LD_INT 50
101196: PUSH
101197: LD_INT 60
101199: PUSH
101200: LD_INT 70
101202: PUSH
101203: LD_INT 80
101205: PUSH
101206: LD_INT 90
101208: PUSH
101209: LD_INT 100
101211: PUSH
101212: LD_INT 110
101214: PUSH
101215: LD_INT 120
101217: PUSH
101218: LD_INT 130
101220: PUSH
101221: LD_INT 140
101223: PUSH
101224: LD_INT 150
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: LIST
101231: LIST
101232: LIST
101233: LIST
101234: LIST
101235: LIST
101236: LIST
101237: LIST
101238: LIST
101239: LIST
101240: LIST
101241: LIST
101242: LIST
101243: PUSH
101244: LD_INT 1
101246: PPUSH
101247: LD_INT 15
101249: PPUSH
101250: CALL_OW 12
101254: ARRAY
101255: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101256: LD_ADDR_VAR 0 4
101260: PUSH
101261: LD_INT 10
101263: PUSH
101264: LD_INT 20
101266: PUSH
101267: LD_INT 30
101269: PUSH
101270: LD_INT 40
101272: PUSH
101273: LD_INT 50
101275: PUSH
101276: LD_INT 60
101278: PUSH
101279: LD_INT 70
101281: PUSH
101282: LD_INT 80
101284: PUSH
101285: LD_INT 90
101287: PUSH
101288: LD_INT 100
101290: PUSH
101291: LD_INT 110
101293: PUSH
101294: LD_INT 120
101296: PUSH
101297: LD_INT 130
101299: PUSH
101300: LD_INT 140
101302: PUSH
101303: LD_INT 150
101305: PUSH
101306: EMPTY
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: LIST
101312: LIST
101313: LIST
101314: LIST
101315: LIST
101316: LIST
101317: LIST
101318: LIST
101319: LIST
101320: LIST
101321: LIST
101322: PUSH
101323: LD_INT 1
101325: PPUSH
101326: LD_INT 15
101328: PPUSH
101329: CALL_OW 12
101333: ARRAY
101334: ST_TO_ADDR
// if ValidHex ( x , y ) then
101335: LD_VAR 0 3
101339: PPUSH
101340: LD_VAR 0 4
101344: PPUSH
101345: CALL_OW 488
101349: IFFALSE 101372
// begin result := [ x , y ] ;
101351: LD_ADDR_VAR 0 1
101355: PUSH
101356: LD_VAR 0 3
101360: PUSH
101361: LD_VAR 0 4
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: ST_TO_ADDR
// break ;
101370: GO 101374
// end ; end ;
101372: GO 101174
101374: POP
101375: POP
// if result then
101376: LD_VAR 0 1
101380: IFFALSE 101440
// begin ToLua ( playSibBomb() ) ;
101382: LD_STRING playSibBomb()
101384: PPUSH
101385: CALL_OW 559
// wait ( 0 0$14 ) ;
101389: LD_INT 490
101391: PPUSH
101392: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101396: LD_VAR 0 1
101400: PUSH
101401: LD_INT 1
101403: ARRAY
101404: PPUSH
101405: LD_VAR 0 1
101409: PUSH
101410: LD_INT 2
101412: ARRAY
101413: PPUSH
101414: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101418: LD_VAR 0 1
101422: PUSH
101423: LD_INT 1
101425: ARRAY
101426: PPUSH
101427: LD_VAR 0 1
101431: PUSH
101432: LD_INT 2
101434: ARRAY
101435: PPUSH
101436: CALL_OW 429
// end ; end ;
101440: LD_VAR 0 1
101444: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101445: LD_EXP 77
101449: PUSH
101450: LD_EXP 99
101454: AND
101455: IFFALSE 101467
101457: GO 101459
101459: DISABLE
// YouLost (  ) ;
101460: LD_STRING 
101462: PPUSH
101463: CALL_OW 104
101467: END
// every 0 0$1 trigger StreamModeActive and sFog do
101468: LD_EXP 77
101472: PUSH
101473: LD_EXP 98
101477: AND
101478: IFFALSE 101492
101480: GO 101482
101482: DISABLE
// FogOff ( your_side ) ;
101483: LD_OWVAR 2
101487: PPUSH
101488: CALL_OW 344
101492: END
// every 0 0$1 trigger StreamModeActive and sSun do
101493: LD_EXP 77
101497: PUSH
101498: LD_EXP 100
101502: AND
101503: IFFALSE 101531
101505: GO 101507
101507: DISABLE
// begin solar_recharge_percent := 0 ;
101508: LD_ADDR_OWVAR 79
101512: PUSH
101513: LD_INT 0
101515: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101516: LD_INT 10500
101518: PPUSH
101519: CALL_OW 67
// solar_recharge_percent := 100 ;
101523: LD_ADDR_OWVAR 79
101527: PUSH
101528: LD_INT 100
101530: ST_TO_ADDR
// end ;
101531: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101532: LD_EXP 77
101536: PUSH
101537: LD_EXP 101
101541: AND
101542: IFFALSE 101781
101544: GO 101546
101546: DISABLE
101547: LD_INT 0
101549: PPUSH
101550: PPUSH
101551: PPUSH
// begin tmp := [ ] ;
101552: LD_ADDR_VAR 0 3
101556: PUSH
101557: EMPTY
101558: ST_TO_ADDR
// for i := 1 to 6 do
101559: LD_ADDR_VAR 0 1
101563: PUSH
101564: DOUBLE
101565: LD_INT 1
101567: DEC
101568: ST_TO_ADDR
101569: LD_INT 6
101571: PUSH
101572: FOR_TO
101573: IFFALSE 101678
// begin uc_nation := nation_nature ;
101575: LD_ADDR_OWVAR 21
101579: PUSH
101580: LD_INT 0
101582: ST_TO_ADDR
// uc_side := 0 ;
101583: LD_ADDR_OWVAR 20
101587: PUSH
101588: LD_INT 0
101590: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101591: LD_ADDR_OWVAR 29
101595: PUSH
101596: LD_INT 12
101598: PUSH
101599: LD_INT 12
101601: PUSH
101602: EMPTY
101603: LIST
101604: LIST
101605: ST_TO_ADDR
// hc_agressivity := 20 ;
101606: LD_ADDR_OWVAR 35
101610: PUSH
101611: LD_INT 20
101613: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101614: LD_ADDR_OWVAR 28
101618: PUSH
101619: LD_INT 17
101621: ST_TO_ADDR
// hc_gallery :=  ;
101622: LD_ADDR_OWVAR 33
101626: PUSH
101627: LD_STRING 
101629: ST_TO_ADDR
// hc_name :=  ;
101630: LD_ADDR_OWVAR 26
101634: PUSH
101635: LD_STRING 
101637: ST_TO_ADDR
// un := CreateHuman ;
101638: LD_ADDR_VAR 0 2
101642: PUSH
101643: CALL_OW 44
101647: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101648: LD_VAR 0 2
101652: PPUSH
101653: LD_INT 1
101655: PPUSH
101656: CALL_OW 51
// tmp := tmp ^ un ;
101660: LD_ADDR_VAR 0 3
101664: PUSH
101665: LD_VAR 0 3
101669: PUSH
101670: LD_VAR 0 2
101674: ADD
101675: ST_TO_ADDR
// end ;
101676: GO 101572
101678: POP
101679: POP
// repeat wait ( 0 0$1 ) ;
101680: LD_INT 35
101682: PPUSH
101683: CALL_OW 67
// for un in tmp do
101687: LD_ADDR_VAR 0 2
101691: PUSH
101692: LD_VAR 0 3
101696: PUSH
101697: FOR_IN
101698: IFFALSE 101772
// begin if IsDead ( un ) then
101700: LD_VAR 0 2
101704: PPUSH
101705: CALL_OW 301
101709: IFFALSE 101729
// begin tmp := tmp diff un ;
101711: LD_ADDR_VAR 0 3
101715: PUSH
101716: LD_VAR 0 3
101720: PUSH
101721: LD_VAR 0 2
101725: DIFF
101726: ST_TO_ADDR
// continue ;
101727: GO 101697
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101729: LD_VAR 0 2
101733: PPUSH
101734: LD_INT 3
101736: PUSH
101737: LD_INT 22
101739: PUSH
101740: LD_INT 0
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: PPUSH
101751: CALL_OW 69
101755: PPUSH
101756: LD_VAR 0 2
101760: PPUSH
101761: CALL_OW 74
101765: PPUSH
101766: CALL_OW 115
// end ;
101770: GO 101697
101772: POP
101773: POP
// until not tmp ;
101774: LD_VAR 0 3
101778: NOT
101779: IFFALSE 101680
// end ;
101781: PPOPN 3
101783: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101784: LD_EXP 77
101788: PUSH
101789: LD_EXP 102
101793: AND
101794: IFFALSE 101848
101796: GO 101798
101798: DISABLE
// begin ToLua ( displayTroll(); ) ;
101799: LD_STRING displayTroll();
101801: PPUSH
101802: CALL_OW 559
// wait ( 3 3$00 ) ;
101806: LD_INT 6300
101808: PPUSH
101809: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101813: LD_STRING hideTroll();
101815: PPUSH
101816: CALL_OW 559
// wait ( 1 1$00 ) ;
101820: LD_INT 2100
101822: PPUSH
101823: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101827: LD_STRING displayTroll();
101829: PPUSH
101830: CALL_OW 559
// wait ( 1 1$00 ) ;
101834: LD_INT 2100
101836: PPUSH
101837: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101841: LD_STRING hideTroll();
101843: PPUSH
101844: CALL_OW 559
// end ;
101848: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101849: LD_EXP 77
101853: PUSH
101854: LD_EXP 103
101858: AND
101859: IFFALSE 101922
101861: GO 101863
101863: DISABLE
101864: LD_INT 0
101866: PPUSH
// begin p := 0 ;
101867: LD_ADDR_VAR 0 1
101871: PUSH
101872: LD_INT 0
101874: ST_TO_ADDR
// repeat game_speed := 1 ;
101875: LD_ADDR_OWVAR 65
101879: PUSH
101880: LD_INT 1
101882: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101883: LD_INT 35
101885: PPUSH
101886: CALL_OW 67
// p := p + 1 ;
101890: LD_ADDR_VAR 0 1
101894: PUSH
101895: LD_VAR 0 1
101899: PUSH
101900: LD_INT 1
101902: PLUS
101903: ST_TO_ADDR
// until p >= 60 ;
101904: LD_VAR 0 1
101908: PUSH
101909: LD_INT 60
101911: GREATEREQUAL
101912: IFFALSE 101875
// game_speed := 4 ;
101914: LD_ADDR_OWVAR 65
101918: PUSH
101919: LD_INT 4
101921: ST_TO_ADDR
// end ;
101922: PPOPN 1
101924: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101925: LD_EXP 77
101929: PUSH
101930: LD_EXP 104
101934: AND
101935: IFFALSE 102081
101937: GO 101939
101939: DISABLE
101940: LD_INT 0
101942: PPUSH
101943: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101944: LD_ADDR_VAR 0 1
101948: PUSH
101949: LD_INT 22
101951: PUSH
101952: LD_OWVAR 2
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: PUSH
101961: LD_INT 2
101963: PUSH
101964: LD_INT 30
101966: PUSH
101967: LD_INT 0
101969: PUSH
101970: EMPTY
101971: LIST
101972: LIST
101973: PUSH
101974: LD_INT 30
101976: PUSH
101977: LD_INT 1
101979: PUSH
101980: EMPTY
101981: LIST
101982: LIST
101983: PUSH
101984: EMPTY
101985: LIST
101986: LIST
101987: LIST
101988: PUSH
101989: EMPTY
101990: LIST
101991: LIST
101992: PPUSH
101993: CALL_OW 69
101997: ST_TO_ADDR
// if not depot then
101998: LD_VAR 0 1
102002: NOT
102003: IFFALSE 102007
// exit ;
102005: GO 102081
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102007: LD_ADDR_VAR 0 2
102011: PUSH
102012: LD_VAR 0 1
102016: PUSH
102017: LD_INT 1
102019: PPUSH
102020: LD_VAR 0 1
102024: PPUSH
102025: CALL_OW 12
102029: ARRAY
102030: PPUSH
102031: CALL_OW 274
102035: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102036: LD_VAR 0 2
102040: PPUSH
102041: LD_INT 1
102043: PPUSH
102044: LD_INT 0
102046: PPUSH
102047: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102051: LD_VAR 0 2
102055: PPUSH
102056: LD_INT 2
102058: PPUSH
102059: LD_INT 0
102061: PPUSH
102062: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102066: LD_VAR 0 2
102070: PPUSH
102071: LD_INT 3
102073: PPUSH
102074: LD_INT 0
102076: PPUSH
102077: CALL_OW 277
// end ;
102081: PPOPN 2
102083: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102084: LD_EXP 77
102088: PUSH
102089: LD_EXP 105
102093: AND
102094: IFFALSE 102191
102096: GO 102098
102098: DISABLE
102099: LD_INT 0
102101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102102: LD_ADDR_VAR 0 1
102106: PUSH
102107: LD_INT 22
102109: PUSH
102110: LD_OWVAR 2
102114: PUSH
102115: EMPTY
102116: LIST
102117: LIST
102118: PUSH
102119: LD_INT 21
102121: PUSH
102122: LD_INT 1
102124: PUSH
102125: EMPTY
102126: LIST
102127: LIST
102128: PUSH
102129: LD_INT 3
102131: PUSH
102132: LD_INT 23
102134: PUSH
102135: LD_INT 0
102137: PUSH
102138: EMPTY
102139: LIST
102140: LIST
102141: PUSH
102142: EMPTY
102143: LIST
102144: LIST
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: LIST
102150: PPUSH
102151: CALL_OW 69
102155: ST_TO_ADDR
// if not tmp then
102156: LD_VAR 0 1
102160: NOT
102161: IFFALSE 102165
// exit ;
102163: GO 102191
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102165: LD_VAR 0 1
102169: PUSH
102170: LD_INT 1
102172: PPUSH
102173: LD_VAR 0 1
102177: PPUSH
102178: CALL_OW 12
102182: ARRAY
102183: PPUSH
102184: LD_INT 200
102186: PPUSH
102187: CALL_OW 234
// end ;
102191: PPOPN 1
102193: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102194: LD_EXP 77
102198: PUSH
102199: LD_EXP 106
102203: AND
102204: IFFALSE 102283
102206: GO 102208
102208: DISABLE
102209: LD_INT 0
102211: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102212: LD_ADDR_VAR 0 1
102216: PUSH
102217: LD_INT 22
102219: PUSH
102220: LD_OWVAR 2
102224: PUSH
102225: EMPTY
102226: LIST
102227: LIST
102228: PUSH
102229: LD_INT 21
102231: PUSH
102232: LD_INT 2
102234: PUSH
102235: EMPTY
102236: LIST
102237: LIST
102238: PUSH
102239: EMPTY
102240: LIST
102241: LIST
102242: PPUSH
102243: CALL_OW 69
102247: ST_TO_ADDR
// if not tmp then
102248: LD_VAR 0 1
102252: NOT
102253: IFFALSE 102257
// exit ;
102255: GO 102283
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102257: LD_VAR 0 1
102261: PUSH
102262: LD_INT 1
102264: PPUSH
102265: LD_VAR 0 1
102269: PPUSH
102270: CALL_OW 12
102274: ARRAY
102275: PPUSH
102276: LD_INT 60
102278: PPUSH
102279: CALL_OW 234
// end ;
102283: PPOPN 1
102285: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102286: LD_EXP 77
102290: PUSH
102291: LD_EXP 107
102295: AND
102296: IFFALSE 102395
102298: GO 102300
102300: DISABLE
102301: LD_INT 0
102303: PPUSH
102304: PPUSH
// begin enable ;
102305: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102306: LD_ADDR_VAR 0 1
102310: PUSH
102311: LD_INT 22
102313: PUSH
102314: LD_OWVAR 2
102318: PUSH
102319: EMPTY
102320: LIST
102321: LIST
102322: PUSH
102323: LD_INT 61
102325: PUSH
102326: EMPTY
102327: LIST
102328: PUSH
102329: LD_INT 33
102331: PUSH
102332: LD_INT 2
102334: PUSH
102335: EMPTY
102336: LIST
102337: LIST
102338: PUSH
102339: EMPTY
102340: LIST
102341: LIST
102342: LIST
102343: PPUSH
102344: CALL_OW 69
102348: ST_TO_ADDR
// if not tmp then
102349: LD_VAR 0 1
102353: NOT
102354: IFFALSE 102358
// exit ;
102356: GO 102395
// for i in tmp do
102358: LD_ADDR_VAR 0 2
102362: PUSH
102363: LD_VAR 0 1
102367: PUSH
102368: FOR_IN
102369: IFFALSE 102393
// if IsControledBy ( i ) then
102371: LD_VAR 0 2
102375: PPUSH
102376: CALL_OW 312
102380: IFFALSE 102391
// ComUnlink ( i ) ;
102382: LD_VAR 0 2
102386: PPUSH
102387: CALL_OW 136
102391: GO 102368
102393: POP
102394: POP
// end ;
102395: PPOPN 2
102397: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102398: LD_EXP 77
102402: PUSH
102403: LD_EXP 108
102407: AND
102408: IFFALSE 102548
102410: GO 102412
102412: DISABLE
102413: LD_INT 0
102415: PPUSH
102416: PPUSH
// begin ToLua ( displayPowell(); ) ;
102417: LD_STRING displayPowell();
102419: PPUSH
102420: CALL_OW 559
// uc_side := 0 ;
102424: LD_ADDR_OWVAR 20
102428: PUSH
102429: LD_INT 0
102431: ST_TO_ADDR
// uc_nation := 2 ;
102432: LD_ADDR_OWVAR 21
102436: PUSH
102437: LD_INT 2
102439: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102440: LD_ADDR_OWVAR 37
102444: PUSH
102445: LD_INT 14
102447: ST_TO_ADDR
// vc_engine := engine_siberite ;
102448: LD_ADDR_OWVAR 39
102452: PUSH
102453: LD_INT 3
102455: ST_TO_ADDR
// vc_control := control_apeman ;
102456: LD_ADDR_OWVAR 38
102460: PUSH
102461: LD_INT 5
102463: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102464: LD_ADDR_OWVAR 40
102468: PUSH
102469: LD_INT 29
102471: ST_TO_ADDR
// un := CreateVehicle ;
102472: LD_ADDR_VAR 0 2
102476: PUSH
102477: CALL_OW 45
102481: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102482: LD_VAR 0 2
102486: PPUSH
102487: LD_INT 1
102489: PPUSH
102490: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102494: LD_INT 35
102496: PPUSH
102497: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102501: LD_VAR 0 2
102505: PPUSH
102506: LD_INT 22
102508: PUSH
102509: LD_OWVAR 2
102513: PUSH
102514: EMPTY
102515: LIST
102516: LIST
102517: PPUSH
102518: CALL_OW 69
102522: PPUSH
102523: LD_VAR 0 2
102527: PPUSH
102528: CALL_OW 74
102532: PPUSH
102533: CALL_OW 115
// until IsDead ( un ) ;
102537: LD_VAR 0 2
102541: PPUSH
102542: CALL_OW 301
102546: IFFALSE 102494
// end ;
102548: PPOPN 2
102550: END
// every 0 0$1 trigger StreamModeActive and sStu do
102551: LD_EXP 77
102555: PUSH
102556: LD_EXP 116
102560: AND
102561: IFFALSE 102577
102563: GO 102565
102565: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102566: LD_STRING displayStucuk();
102568: PPUSH
102569: CALL_OW 559
// ResetFog ;
102573: CALL_OW 335
// end ;
102577: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102578: LD_EXP 77
102582: PUSH
102583: LD_EXP 109
102587: AND
102588: IFFALSE 102729
102590: GO 102592
102592: DISABLE
102593: LD_INT 0
102595: PPUSH
102596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102597: LD_ADDR_VAR 0 2
102601: PUSH
102602: LD_INT 22
102604: PUSH
102605: LD_OWVAR 2
102609: PUSH
102610: EMPTY
102611: LIST
102612: LIST
102613: PUSH
102614: LD_INT 21
102616: PUSH
102617: LD_INT 1
102619: PUSH
102620: EMPTY
102621: LIST
102622: LIST
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PPUSH
102628: CALL_OW 69
102632: ST_TO_ADDR
// if not tmp then
102633: LD_VAR 0 2
102637: NOT
102638: IFFALSE 102642
// exit ;
102640: GO 102729
// un := tmp [ rand ( 1 , tmp ) ] ;
102642: LD_ADDR_VAR 0 1
102646: PUSH
102647: LD_VAR 0 2
102651: PUSH
102652: LD_INT 1
102654: PPUSH
102655: LD_VAR 0 2
102659: PPUSH
102660: CALL_OW 12
102664: ARRAY
102665: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102666: LD_VAR 0 1
102670: PPUSH
102671: LD_INT 0
102673: PPUSH
102674: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102678: LD_VAR 0 1
102682: PPUSH
102683: LD_OWVAR 3
102687: PUSH
102688: LD_VAR 0 1
102692: DIFF
102693: PPUSH
102694: LD_VAR 0 1
102698: PPUSH
102699: CALL_OW 74
102703: PPUSH
102704: CALL_OW 115
// wait ( 0 0$20 ) ;
102708: LD_INT 700
102710: PPUSH
102711: CALL_OW 67
// SetSide ( un , your_side ) ;
102715: LD_VAR 0 1
102719: PPUSH
102720: LD_OWVAR 2
102724: PPUSH
102725: CALL_OW 235
// end ;
102729: PPOPN 2
102731: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102732: LD_EXP 77
102736: PUSH
102737: LD_EXP 110
102741: AND
102742: IFFALSE 102848
102744: GO 102746
102746: DISABLE
102747: LD_INT 0
102749: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102750: LD_ADDR_VAR 0 1
102754: PUSH
102755: LD_INT 22
102757: PUSH
102758: LD_OWVAR 2
102762: PUSH
102763: EMPTY
102764: LIST
102765: LIST
102766: PUSH
102767: LD_INT 2
102769: PUSH
102770: LD_INT 30
102772: PUSH
102773: LD_INT 0
102775: PUSH
102776: EMPTY
102777: LIST
102778: LIST
102779: PUSH
102780: LD_INT 30
102782: PUSH
102783: LD_INT 1
102785: PUSH
102786: EMPTY
102787: LIST
102788: LIST
102789: PUSH
102790: EMPTY
102791: LIST
102792: LIST
102793: LIST
102794: PUSH
102795: EMPTY
102796: LIST
102797: LIST
102798: PPUSH
102799: CALL_OW 69
102803: ST_TO_ADDR
// if not depot then
102804: LD_VAR 0 1
102808: NOT
102809: IFFALSE 102813
// exit ;
102811: GO 102848
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102813: LD_VAR 0 1
102817: PUSH
102818: LD_INT 1
102820: ARRAY
102821: PPUSH
102822: CALL_OW 250
102826: PPUSH
102827: LD_VAR 0 1
102831: PUSH
102832: LD_INT 1
102834: ARRAY
102835: PPUSH
102836: CALL_OW 251
102840: PPUSH
102841: LD_INT 70
102843: PPUSH
102844: CALL_OW 495
// end ;
102848: PPOPN 1
102850: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102851: LD_EXP 77
102855: PUSH
102856: LD_EXP 111
102860: AND
102861: IFFALSE 103072
102863: GO 102865
102865: DISABLE
102866: LD_INT 0
102868: PPUSH
102869: PPUSH
102870: PPUSH
102871: PPUSH
102872: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102873: LD_ADDR_VAR 0 5
102877: PUSH
102878: LD_INT 22
102880: PUSH
102881: LD_OWVAR 2
102885: PUSH
102886: EMPTY
102887: LIST
102888: LIST
102889: PUSH
102890: LD_INT 21
102892: PUSH
102893: LD_INT 1
102895: PUSH
102896: EMPTY
102897: LIST
102898: LIST
102899: PUSH
102900: EMPTY
102901: LIST
102902: LIST
102903: PPUSH
102904: CALL_OW 69
102908: ST_TO_ADDR
// if not tmp then
102909: LD_VAR 0 5
102913: NOT
102914: IFFALSE 102918
// exit ;
102916: GO 103072
// for i in tmp do
102918: LD_ADDR_VAR 0 1
102922: PUSH
102923: LD_VAR 0 5
102927: PUSH
102928: FOR_IN
102929: IFFALSE 103070
// begin d := rand ( 0 , 5 ) ;
102931: LD_ADDR_VAR 0 4
102935: PUSH
102936: LD_INT 0
102938: PPUSH
102939: LD_INT 5
102941: PPUSH
102942: CALL_OW 12
102946: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102947: LD_ADDR_VAR 0 2
102951: PUSH
102952: LD_VAR 0 1
102956: PPUSH
102957: CALL_OW 250
102961: PPUSH
102962: LD_VAR 0 4
102966: PPUSH
102967: LD_INT 3
102969: PPUSH
102970: LD_INT 12
102972: PPUSH
102973: CALL_OW 12
102977: PPUSH
102978: CALL_OW 272
102982: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102983: LD_ADDR_VAR 0 3
102987: PUSH
102988: LD_VAR 0 1
102992: PPUSH
102993: CALL_OW 251
102997: PPUSH
102998: LD_VAR 0 4
103002: PPUSH
103003: LD_INT 3
103005: PPUSH
103006: LD_INT 12
103008: PPUSH
103009: CALL_OW 12
103013: PPUSH
103014: CALL_OW 273
103018: ST_TO_ADDR
// if ValidHex ( x , y ) then
103019: LD_VAR 0 2
103023: PPUSH
103024: LD_VAR 0 3
103028: PPUSH
103029: CALL_OW 488
103033: IFFALSE 103068
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103035: LD_VAR 0 1
103039: PPUSH
103040: LD_VAR 0 2
103044: PPUSH
103045: LD_VAR 0 3
103049: PPUSH
103050: LD_INT 3
103052: PPUSH
103053: LD_INT 6
103055: PPUSH
103056: CALL_OW 12
103060: PPUSH
103061: LD_INT 1
103063: PPUSH
103064: CALL_OW 483
// end ;
103068: GO 102928
103070: POP
103071: POP
// end ;
103072: PPOPN 5
103074: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103075: LD_EXP 77
103079: PUSH
103080: LD_EXP 112
103084: AND
103085: IFFALSE 103179
103087: GO 103089
103089: DISABLE
103090: LD_INT 0
103092: PPUSH
103093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103094: LD_ADDR_VAR 0 2
103098: PUSH
103099: LD_INT 22
103101: PUSH
103102: LD_OWVAR 2
103106: PUSH
103107: EMPTY
103108: LIST
103109: LIST
103110: PUSH
103111: LD_INT 32
103113: PUSH
103114: LD_INT 1
103116: PUSH
103117: EMPTY
103118: LIST
103119: LIST
103120: PUSH
103121: LD_INT 21
103123: PUSH
103124: LD_INT 2
103126: PUSH
103127: EMPTY
103128: LIST
103129: LIST
103130: PUSH
103131: EMPTY
103132: LIST
103133: LIST
103134: LIST
103135: PPUSH
103136: CALL_OW 69
103140: ST_TO_ADDR
// if not tmp then
103141: LD_VAR 0 2
103145: NOT
103146: IFFALSE 103150
// exit ;
103148: GO 103179
// for i in tmp do
103150: LD_ADDR_VAR 0 1
103154: PUSH
103155: LD_VAR 0 2
103159: PUSH
103160: FOR_IN
103161: IFFALSE 103177
// SetFuel ( i , 0 ) ;
103163: LD_VAR 0 1
103167: PPUSH
103168: LD_INT 0
103170: PPUSH
103171: CALL_OW 240
103175: GO 103160
103177: POP
103178: POP
// end ;
103179: PPOPN 2
103181: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103182: LD_EXP 77
103186: PUSH
103187: LD_EXP 113
103191: AND
103192: IFFALSE 103258
103194: GO 103196
103196: DISABLE
103197: LD_INT 0
103199: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103200: LD_ADDR_VAR 0 1
103204: PUSH
103205: LD_INT 22
103207: PUSH
103208: LD_OWVAR 2
103212: PUSH
103213: EMPTY
103214: LIST
103215: LIST
103216: PUSH
103217: LD_INT 30
103219: PUSH
103220: LD_INT 29
103222: PUSH
103223: EMPTY
103224: LIST
103225: LIST
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: PPUSH
103231: CALL_OW 69
103235: ST_TO_ADDR
// if not tmp then
103236: LD_VAR 0 1
103240: NOT
103241: IFFALSE 103245
// exit ;
103243: GO 103258
// DestroyUnit ( tmp [ 1 ] ) ;
103245: LD_VAR 0 1
103249: PUSH
103250: LD_INT 1
103252: ARRAY
103253: PPUSH
103254: CALL_OW 65
// end ;
103258: PPOPN 1
103260: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103261: LD_EXP 77
103265: PUSH
103266: LD_EXP 115
103270: AND
103271: IFFALSE 103400
103273: GO 103275
103275: DISABLE
103276: LD_INT 0
103278: PPUSH
// begin uc_side := 0 ;
103279: LD_ADDR_OWVAR 20
103283: PUSH
103284: LD_INT 0
103286: ST_TO_ADDR
// uc_nation := nation_arabian ;
103287: LD_ADDR_OWVAR 21
103291: PUSH
103292: LD_INT 2
103294: ST_TO_ADDR
// hc_gallery :=  ;
103295: LD_ADDR_OWVAR 33
103299: PUSH
103300: LD_STRING 
103302: ST_TO_ADDR
// hc_name :=  ;
103303: LD_ADDR_OWVAR 26
103307: PUSH
103308: LD_STRING 
103310: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103311: LD_INT 1
103313: PPUSH
103314: LD_INT 11
103316: PPUSH
103317: LD_INT 10
103319: PPUSH
103320: CALL_OW 380
// un := CreateHuman ;
103324: LD_ADDR_VAR 0 1
103328: PUSH
103329: CALL_OW 44
103333: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103334: LD_VAR 0 1
103338: PPUSH
103339: LD_INT 1
103341: PPUSH
103342: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103346: LD_INT 35
103348: PPUSH
103349: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103353: LD_VAR 0 1
103357: PPUSH
103358: LD_INT 22
103360: PUSH
103361: LD_OWVAR 2
103365: PUSH
103366: EMPTY
103367: LIST
103368: LIST
103369: PPUSH
103370: CALL_OW 69
103374: PPUSH
103375: LD_VAR 0 1
103379: PPUSH
103380: CALL_OW 74
103384: PPUSH
103385: CALL_OW 115
// until IsDead ( un ) ;
103389: LD_VAR 0 1
103393: PPUSH
103394: CALL_OW 301
103398: IFFALSE 103346
// end ;
103400: PPOPN 1
103402: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103403: LD_EXP 77
103407: PUSH
103408: LD_EXP 117
103412: AND
103413: IFFALSE 103425
103415: GO 103417
103417: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103418: LD_STRING earthquake(getX(game), 0, 32)
103420: PPUSH
103421: CALL_OW 559
103425: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103426: LD_EXP 77
103430: PUSH
103431: LD_EXP 118
103435: AND
103436: IFFALSE 103527
103438: GO 103440
103440: DISABLE
103441: LD_INT 0
103443: PPUSH
// begin enable ;
103444: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103445: LD_ADDR_VAR 0 1
103449: PUSH
103450: LD_INT 22
103452: PUSH
103453: LD_OWVAR 2
103457: PUSH
103458: EMPTY
103459: LIST
103460: LIST
103461: PUSH
103462: LD_INT 21
103464: PUSH
103465: LD_INT 2
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: PUSH
103472: LD_INT 33
103474: PUSH
103475: LD_INT 3
103477: PUSH
103478: EMPTY
103479: LIST
103480: LIST
103481: PUSH
103482: EMPTY
103483: LIST
103484: LIST
103485: LIST
103486: PPUSH
103487: CALL_OW 69
103491: ST_TO_ADDR
// if not tmp then
103492: LD_VAR 0 1
103496: NOT
103497: IFFALSE 103501
// exit ;
103499: GO 103527
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103501: LD_VAR 0 1
103505: PUSH
103506: LD_INT 1
103508: PPUSH
103509: LD_VAR 0 1
103513: PPUSH
103514: CALL_OW 12
103518: ARRAY
103519: PPUSH
103520: LD_INT 1
103522: PPUSH
103523: CALL_OW 234
// end ;
103527: PPOPN 1
103529: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103530: LD_EXP 77
103534: PUSH
103535: LD_EXP 119
103539: AND
103540: IFFALSE 103681
103542: GO 103544
103544: DISABLE
103545: LD_INT 0
103547: PPUSH
103548: PPUSH
103549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103550: LD_ADDR_VAR 0 3
103554: PUSH
103555: LD_INT 22
103557: PUSH
103558: LD_OWVAR 2
103562: PUSH
103563: EMPTY
103564: LIST
103565: LIST
103566: PUSH
103567: LD_INT 25
103569: PUSH
103570: LD_INT 1
103572: PUSH
103573: EMPTY
103574: LIST
103575: LIST
103576: PUSH
103577: EMPTY
103578: LIST
103579: LIST
103580: PPUSH
103581: CALL_OW 69
103585: ST_TO_ADDR
// if not tmp then
103586: LD_VAR 0 3
103590: NOT
103591: IFFALSE 103595
// exit ;
103593: GO 103681
// un := tmp [ rand ( 1 , tmp ) ] ;
103595: LD_ADDR_VAR 0 2
103599: PUSH
103600: LD_VAR 0 3
103604: PUSH
103605: LD_INT 1
103607: PPUSH
103608: LD_VAR 0 3
103612: PPUSH
103613: CALL_OW 12
103617: ARRAY
103618: ST_TO_ADDR
// if Crawls ( un ) then
103619: LD_VAR 0 2
103623: PPUSH
103624: CALL_OW 318
103628: IFFALSE 103639
// ComWalk ( un ) ;
103630: LD_VAR 0 2
103634: PPUSH
103635: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103639: LD_VAR 0 2
103643: PPUSH
103644: LD_INT 9
103646: PPUSH
103647: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103651: LD_INT 28
103653: PPUSH
103654: LD_OWVAR 2
103658: PPUSH
103659: LD_INT 2
103661: PPUSH
103662: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103666: LD_INT 29
103668: PPUSH
103669: LD_OWVAR 2
103673: PPUSH
103674: LD_INT 2
103676: PPUSH
103677: CALL_OW 322
// end ;
103681: PPOPN 3
103683: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103684: LD_EXP 77
103688: PUSH
103689: LD_EXP 120
103693: AND
103694: IFFALSE 103805
103696: GO 103698
103698: DISABLE
103699: LD_INT 0
103701: PPUSH
103702: PPUSH
103703: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103704: LD_ADDR_VAR 0 3
103708: PUSH
103709: LD_INT 22
103711: PUSH
103712: LD_OWVAR 2
103716: PUSH
103717: EMPTY
103718: LIST
103719: LIST
103720: PUSH
103721: LD_INT 25
103723: PUSH
103724: LD_INT 1
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: PPUSH
103735: CALL_OW 69
103739: ST_TO_ADDR
// if not tmp then
103740: LD_VAR 0 3
103744: NOT
103745: IFFALSE 103749
// exit ;
103747: GO 103805
// un := tmp [ rand ( 1 , tmp ) ] ;
103749: LD_ADDR_VAR 0 2
103753: PUSH
103754: LD_VAR 0 3
103758: PUSH
103759: LD_INT 1
103761: PPUSH
103762: LD_VAR 0 3
103766: PPUSH
103767: CALL_OW 12
103771: ARRAY
103772: ST_TO_ADDR
// if Crawls ( un ) then
103773: LD_VAR 0 2
103777: PPUSH
103778: CALL_OW 318
103782: IFFALSE 103793
// ComWalk ( un ) ;
103784: LD_VAR 0 2
103788: PPUSH
103789: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103793: LD_VAR 0 2
103797: PPUSH
103798: LD_INT 8
103800: PPUSH
103801: CALL_OW 336
// end ;
103805: PPOPN 3
103807: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103808: LD_EXP 77
103812: PUSH
103813: LD_EXP 121
103817: AND
103818: IFFALSE 103962
103820: GO 103822
103822: DISABLE
103823: LD_INT 0
103825: PPUSH
103826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103827: LD_ADDR_VAR 0 2
103831: PUSH
103832: LD_INT 22
103834: PUSH
103835: LD_OWVAR 2
103839: PUSH
103840: EMPTY
103841: LIST
103842: LIST
103843: PUSH
103844: LD_INT 21
103846: PUSH
103847: LD_INT 2
103849: PUSH
103850: EMPTY
103851: LIST
103852: LIST
103853: PUSH
103854: LD_INT 2
103856: PUSH
103857: LD_INT 34
103859: PUSH
103860: LD_INT 12
103862: PUSH
103863: EMPTY
103864: LIST
103865: LIST
103866: PUSH
103867: LD_INT 34
103869: PUSH
103870: LD_INT 51
103872: PUSH
103873: EMPTY
103874: LIST
103875: LIST
103876: PUSH
103877: LD_INT 34
103879: PUSH
103880: LD_INT 32
103882: PUSH
103883: EMPTY
103884: LIST
103885: LIST
103886: PUSH
103887: EMPTY
103888: LIST
103889: LIST
103890: LIST
103891: LIST
103892: PUSH
103893: EMPTY
103894: LIST
103895: LIST
103896: LIST
103897: PPUSH
103898: CALL_OW 69
103902: ST_TO_ADDR
// if not tmp then
103903: LD_VAR 0 2
103907: NOT
103908: IFFALSE 103912
// exit ;
103910: GO 103962
// for i in tmp do
103912: LD_ADDR_VAR 0 1
103916: PUSH
103917: LD_VAR 0 2
103921: PUSH
103922: FOR_IN
103923: IFFALSE 103960
// if GetCargo ( i , mat_artifact ) = 0 then
103925: LD_VAR 0 1
103929: PPUSH
103930: LD_INT 4
103932: PPUSH
103933: CALL_OW 289
103937: PUSH
103938: LD_INT 0
103940: EQUAL
103941: IFFALSE 103958
// SetCargo ( i , mat_siberit , 100 ) ;
103943: LD_VAR 0 1
103947: PPUSH
103948: LD_INT 3
103950: PPUSH
103951: LD_INT 100
103953: PPUSH
103954: CALL_OW 290
103958: GO 103922
103960: POP
103961: POP
// end ;
103962: PPOPN 2
103964: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103965: LD_EXP 77
103969: PUSH
103970: LD_EXP 122
103974: AND
103975: IFFALSE 104158
103977: GO 103979
103979: DISABLE
103980: LD_INT 0
103982: PPUSH
103983: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103984: LD_ADDR_VAR 0 2
103988: PUSH
103989: LD_INT 22
103991: PUSH
103992: LD_OWVAR 2
103996: PUSH
103997: EMPTY
103998: LIST
103999: LIST
104000: PPUSH
104001: CALL_OW 69
104005: ST_TO_ADDR
// if not tmp then
104006: LD_VAR 0 2
104010: NOT
104011: IFFALSE 104015
// exit ;
104013: GO 104158
// for i := 1 to 2 do
104015: LD_ADDR_VAR 0 1
104019: PUSH
104020: DOUBLE
104021: LD_INT 1
104023: DEC
104024: ST_TO_ADDR
104025: LD_INT 2
104027: PUSH
104028: FOR_TO
104029: IFFALSE 104156
// begin uc_side := your_side ;
104031: LD_ADDR_OWVAR 20
104035: PUSH
104036: LD_OWVAR 2
104040: ST_TO_ADDR
// uc_nation := nation_american ;
104041: LD_ADDR_OWVAR 21
104045: PUSH
104046: LD_INT 1
104048: ST_TO_ADDR
// vc_chassis := us_morphling ;
104049: LD_ADDR_OWVAR 37
104053: PUSH
104054: LD_INT 5
104056: ST_TO_ADDR
// vc_engine := engine_siberite ;
104057: LD_ADDR_OWVAR 39
104061: PUSH
104062: LD_INT 3
104064: ST_TO_ADDR
// vc_control := control_computer ;
104065: LD_ADDR_OWVAR 38
104069: PUSH
104070: LD_INT 3
104072: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104073: LD_ADDR_OWVAR 40
104077: PUSH
104078: LD_INT 10
104080: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104081: LD_VAR 0 2
104085: PUSH
104086: LD_INT 1
104088: ARRAY
104089: PPUSH
104090: CALL_OW 310
104094: NOT
104095: IFFALSE 104142
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104097: CALL_OW 45
104101: PPUSH
104102: LD_VAR 0 2
104106: PUSH
104107: LD_INT 1
104109: ARRAY
104110: PPUSH
104111: CALL_OW 250
104115: PPUSH
104116: LD_VAR 0 2
104120: PUSH
104121: LD_INT 1
104123: ARRAY
104124: PPUSH
104125: CALL_OW 251
104129: PPUSH
104130: LD_INT 12
104132: PPUSH
104133: LD_INT 1
104135: PPUSH
104136: CALL_OW 50
104140: GO 104154
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104142: CALL_OW 45
104146: PPUSH
104147: LD_INT 1
104149: PPUSH
104150: CALL_OW 51
// end ;
104154: GO 104028
104156: POP
104157: POP
// end ;
104158: PPOPN 2
104160: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104161: LD_EXP 77
104165: PUSH
104166: LD_EXP 123
104170: AND
104171: IFFALSE 104393
104173: GO 104175
104175: DISABLE
104176: LD_INT 0
104178: PPUSH
104179: PPUSH
104180: PPUSH
104181: PPUSH
104182: PPUSH
104183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104184: LD_ADDR_VAR 0 6
104188: PUSH
104189: LD_INT 22
104191: PUSH
104192: LD_OWVAR 2
104196: PUSH
104197: EMPTY
104198: LIST
104199: LIST
104200: PUSH
104201: LD_INT 21
104203: PUSH
104204: LD_INT 1
104206: PUSH
104207: EMPTY
104208: LIST
104209: LIST
104210: PUSH
104211: LD_INT 3
104213: PUSH
104214: LD_INT 23
104216: PUSH
104217: LD_INT 0
104219: PUSH
104220: EMPTY
104221: LIST
104222: LIST
104223: PUSH
104224: EMPTY
104225: LIST
104226: LIST
104227: PUSH
104228: EMPTY
104229: LIST
104230: LIST
104231: LIST
104232: PPUSH
104233: CALL_OW 69
104237: ST_TO_ADDR
// if not tmp then
104238: LD_VAR 0 6
104242: NOT
104243: IFFALSE 104247
// exit ;
104245: GO 104393
// s1 := rand ( 1 , 4 ) ;
104247: LD_ADDR_VAR 0 2
104251: PUSH
104252: LD_INT 1
104254: PPUSH
104255: LD_INT 4
104257: PPUSH
104258: CALL_OW 12
104262: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104263: LD_ADDR_VAR 0 4
104267: PUSH
104268: LD_VAR 0 6
104272: PUSH
104273: LD_INT 1
104275: ARRAY
104276: PPUSH
104277: LD_VAR 0 2
104281: PPUSH
104282: CALL_OW 259
104286: ST_TO_ADDR
// if s1 = 1 then
104287: LD_VAR 0 2
104291: PUSH
104292: LD_INT 1
104294: EQUAL
104295: IFFALSE 104315
// s2 := rand ( 2 , 4 ) else
104297: LD_ADDR_VAR 0 3
104301: PUSH
104302: LD_INT 2
104304: PPUSH
104305: LD_INT 4
104307: PPUSH
104308: CALL_OW 12
104312: ST_TO_ADDR
104313: GO 104323
// s2 := 1 ;
104315: LD_ADDR_VAR 0 3
104319: PUSH
104320: LD_INT 1
104322: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104323: LD_ADDR_VAR 0 5
104327: PUSH
104328: LD_VAR 0 6
104332: PUSH
104333: LD_INT 1
104335: ARRAY
104336: PPUSH
104337: LD_VAR 0 3
104341: PPUSH
104342: CALL_OW 259
104346: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104347: LD_VAR 0 6
104351: PUSH
104352: LD_INT 1
104354: ARRAY
104355: PPUSH
104356: LD_VAR 0 2
104360: PPUSH
104361: LD_VAR 0 5
104365: PPUSH
104366: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104370: LD_VAR 0 6
104374: PUSH
104375: LD_INT 1
104377: ARRAY
104378: PPUSH
104379: LD_VAR 0 3
104383: PPUSH
104384: LD_VAR 0 4
104388: PPUSH
104389: CALL_OW 237
// end ;
104393: PPOPN 6
104395: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104396: LD_EXP 77
104400: PUSH
104401: LD_EXP 124
104405: AND
104406: IFFALSE 104485
104408: GO 104410
104410: DISABLE
104411: LD_INT 0
104413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104414: LD_ADDR_VAR 0 1
104418: PUSH
104419: LD_INT 22
104421: PUSH
104422: LD_OWVAR 2
104426: PUSH
104427: EMPTY
104428: LIST
104429: LIST
104430: PUSH
104431: LD_INT 30
104433: PUSH
104434: LD_INT 3
104436: PUSH
104437: EMPTY
104438: LIST
104439: LIST
104440: PUSH
104441: EMPTY
104442: LIST
104443: LIST
104444: PPUSH
104445: CALL_OW 69
104449: ST_TO_ADDR
// if not tmp then
104450: LD_VAR 0 1
104454: NOT
104455: IFFALSE 104459
// exit ;
104457: GO 104485
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104459: LD_VAR 0 1
104463: PUSH
104464: LD_INT 1
104466: PPUSH
104467: LD_VAR 0 1
104471: PPUSH
104472: CALL_OW 12
104476: ARRAY
104477: PPUSH
104478: LD_INT 1
104480: PPUSH
104481: CALL_OW 234
// end ;
104485: PPOPN 1
104487: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104488: LD_EXP 77
104492: PUSH
104493: LD_EXP 125
104497: AND
104498: IFFALSE 104610
104500: GO 104502
104502: DISABLE
104503: LD_INT 0
104505: PPUSH
104506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104507: LD_ADDR_VAR 0 2
104511: PUSH
104512: LD_INT 22
104514: PUSH
104515: LD_OWVAR 2
104519: PUSH
104520: EMPTY
104521: LIST
104522: LIST
104523: PUSH
104524: LD_INT 2
104526: PUSH
104527: LD_INT 30
104529: PUSH
104530: LD_INT 27
104532: PUSH
104533: EMPTY
104534: LIST
104535: LIST
104536: PUSH
104537: LD_INT 30
104539: PUSH
104540: LD_INT 26
104542: PUSH
104543: EMPTY
104544: LIST
104545: LIST
104546: PUSH
104547: LD_INT 30
104549: PUSH
104550: LD_INT 28
104552: PUSH
104553: EMPTY
104554: LIST
104555: LIST
104556: PUSH
104557: EMPTY
104558: LIST
104559: LIST
104560: LIST
104561: LIST
104562: PUSH
104563: EMPTY
104564: LIST
104565: LIST
104566: PPUSH
104567: CALL_OW 69
104571: ST_TO_ADDR
// if not tmp then
104572: LD_VAR 0 2
104576: NOT
104577: IFFALSE 104581
// exit ;
104579: GO 104610
// for i in tmp do
104581: LD_ADDR_VAR 0 1
104585: PUSH
104586: LD_VAR 0 2
104590: PUSH
104591: FOR_IN
104592: IFFALSE 104608
// SetLives ( i , 1 ) ;
104594: LD_VAR 0 1
104598: PPUSH
104599: LD_INT 1
104601: PPUSH
104602: CALL_OW 234
104606: GO 104591
104608: POP
104609: POP
// end ;
104610: PPOPN 2
104612: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104613: LD_EXP 77
104617: PUSH
104618: LD_EXP 126
104622: AND
104623: IFFALSE 104910
104625: GO 104627
104627: DISABLE
104628: LD_INT 0
104630: PPUSH
104631: PPUSH
104632: PPUSH
// begin i := rand ( 1 , 7 ) ;
104633: LD_ADDR_VAR 0 1
104637: PUSH
104638: LD_INT 1
104640: PPUSH
104641: LD_INT 7
104643: PPUSH
104644: CALL_OW 12
104648: ST_TO_ADDR
// case i of 1 :
104649: LD_VAR 0 1
104653: PUSH
104654: LD_INT 1
104656: DOUBLE
104657: EQUAL
104658: IFTRUE 104662
104660: GO 104672
104662: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104663: LD_STRING earthquake(getX(game), 0, 32)
104665: PPUSH
104666: CALL_OW 559
104670: GO 104910
104672: LD_INT 2
104674: DOUBLE
104675: EQUAL
104676: IFTRUE 104680
104678: GO 104694
104680: POP
// begin ToLua ( displayStucuk(); ) ;
104681: LD_STRING displayStucuk();
104683: PPUSH
104684: CALL_OW 559
// ResetFog ;
104688: CALL_OW 335
// end ; 3 :
104692: GO 104910
104694: LD_INT 3
104696: DOUBLE
104697: EQUAL
104698: IFTRUE 104702
104700: GO 104806
104702: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104703: LD_ADDR_VAR 0 2
104707: PUSH
104708: LD_INT 22
104710: PUSH
104711: LD_OWVAR 2
104715: PUSH
104716: EMPTY
104717: LIST
104718: LIST
104719: PUSH
104720: LD_INT 25
104722: PUSH
104723: LD_INT 1
104725: PUSH
104726: EMPTY
104727: LIST
104728: LIST
104729: PUSH
104730: EMPTY
104731: LIST
104732: LIST
104733: PPUSH
104734: CALL_OW 69
104738: ST_TO_ADDR
// if not tmp then
104739: LD_VAR 0 2
104743: NOT
104744: IFFALSE 104748
// exit ;
104746: GO 104910
// un := tmp [ rand ( 1 , tmp ) ] ;
104748: LD_ADDR_VAR 0 3
104752: PUSH
104753: LD_VAR 0 2
104757: PUSH
104758: LD_INT 1
104760: PPUSH
104761: LD_VAR 0 2
104765: PPUSH
104766: CALL_OW 12
104770: ARRAY
104771: ST_TO_ADDR
// if Crawls ( un ) then
104772: LD_VAR 0 3
104776: PPUSH
104777: CALL_OW 318
104781: IFFALSE 104792
// ComWalk ( un ) ;
104783: LD_VAR 0 3
104787: PPUSH
104788: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104792: LD_VAR 0 3
104796: PPUSH
104797: LD_INT 8
104799: PPUSH
104800: CALL_OW 336
// end ; 4 :
104804: GO 104910
104806: LD_INT 4
104808: DOUBLE
104809: EQUAL
104810: IFTRUE 104814
104812: GO 104888
104814: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104815: LD_ADDR_VAR 0 2
104819: PUSH
104820: LD_INT 22
104822: PUSH
104823: LD_OWVAR 2
104827: PUSH
104828: EMPTY
104829: LIST
104830: LIST
104831: PUSH
104832: LD_INT 30
104834: PUSH
104835: LD_INT 29
104837: PUSH
104838: EMPTY
104839: LIST
104840: LIST
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: PPUSH
104846: CALL_OW 69
104850: ST_TO_ADDR
// if not tmp then
104851: LD_VAR 0 2
104855: NOT
104856: IFFALSE 104860
// exit ;
104858: GO 104910
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104860: LD_VAR 0 2
104864: PUSH
104865: LD_INT 1
104867: ARRAY
104868: PPUSH
104869: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104873: LD_VAR 0 2
104877: PUSH
104878: LD_INT 1
104880: ARRAY
104881: PPUSH
104882: CALL_OW 65
// end ; 5 .. 7 :
104886: GO 104910
104888: LD_INT 5
104890: DOUBLE
104891: GREATEREQUAL
104892: IFFALSE 104900
104894: LD_INT 7
104896: DOUBLE
104897: LESSEQUAL
104898: IFTRUE 104902
104900: GO 104909
104902: POP
// StreamSibBomb ; end ;
104903: CALL 101147 0 0
104907: GO 104910
104909: POP
// end ;
104910: PPOPN 3
104912: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104913: LD_EXP 77
104917: PUSH
104918: LD_EXP 127
104922: AND
104923: IFFALSE 105079
104925: GO 104927
104927: DISABLE
104928: LD_INT 0
104930: PPUSH
104931: PPUSH
104932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104933: LD_ADDR_VAR 0 2
104937: PUSH
104938: LD_INT 81
104940: PUSH
104941: LD_OWVAR 2
104945: PUSH
104946: EMPTY
104947: LIST
104948: LIST
104949: PUSH
104950: LD_INT 2
104952: PUSH
104953: LD_INT 21
104955: PUSH
104956: LD_INT 1
104958: PUSH
104959: EMPTY
104960: LIST
104961: LIST
104962: PUSH
104963: LD_INT 21
104965: PUSH
104966: LD_INT 2
104968: PUSH
104969: EMPTY
104970: LIST
104971: LIST
104972: PUSH
104973: EMPTY
104974: LIST
104975: LIST
104976: LIST
104977: PUSH
104978: EMPTY
104979: LIST
104980: LIST
104981: PPUSH
104982: CALL_OW 69
104986: ST_TO_ADDR
// if not tmp then
104987: LD_VAR 0 2
104991: NOT
104992: IFFALSE 104996
// exit ;
104994: GO 105079
// p := 0 ;
104996: LD_ADDR_VAR 0 3
105000: PUSH
105001: LD_INT 0
105003: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105004: LD_INT 35
105006: PPUSH
105007: CALL_OW 67
// p := p + 1 ;
105011: LD_ADDR_VAR 0 3
105015: PUSH
105016: LD_VAR 0 3
105020: PUSH
105021: LD_INT 1
105023: PLUS
105024: ST_TO_ADDR
// for i in tmp do
105025: LD_ADDR_VAR 0 1
105029: PUSH
105030: LD_VAR 0 2
105034: PUSH
105035: FOR_IN
105036: IFFALSE 105067
// if GetLives ( i ) < 1000 then
105038: LD_VAR 0 1
105042: PPUSH
105043: CALL_OW 256
105047: PUSH
105048: LD_INT 1000
105050: LESS
105051: IFFALSE 105065
// SetLives ( i , 1000 ) ;
105053: LD_VAR 0 1
105057: PPUSH
105058: LD_INT 1000
105060: PPUSH
105061: CALL_OW 234
105065: GO 105035
105067: POP
105068: POP
// until p > 20 ;
105069: LD_VAR 0 3
105073: PUSH
105074: LD_INT 20
105076: GREATER
105077: IFFALSE 105004
// end ;
105079: PPOPN 3
105081: END
// every 0 0$1 trigger StreamModeActive and sTime do
105082: LD_EXP 77
105086: PUSH
105087: LD_EXP 128
105091: AND
105092: IFFALSE 105127
105094: GO 105096
105096: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105097: LD_INT 28
105099: PPUSH
105100: LD_OWVAR 2
105104: PPUSH
105105: LD_INT 2
105107: PPUSH
105108: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105112: LD_INT 30
105114: PPUSH
105115: LD_OWVAR 2
105119: PPUSH
105120: LD_INT 2
105122: PPUSH
105123: CALL_OW 322
// end ;
105127: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105128: LD_EXP 77
105132: PUSH
105133: LD_EXP 129
105137: AND
105138: IFFALSE 105259
105140: GO 105142
105142: DISABLE
105143: LD_INT 0
105145: PPUSH
105146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105147: LD_ADDR_VAR 0 2
105151: PUSH
105152: LD_INT 22
105154: PUSH
105155: LD_OWVAR 2
105159: PUSH
105160: EMPTY
105161: LIST
105162: LIST
105163: PUSH
105164: LD_INT 21
105166: PUSH
105167: LD_INT 1
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: PUSH
105174: LD_INT 3
105176: PUSH
105177: LD_INT 23
105179: PUSH
105180: LD_INT 0
105182: PUSH
105183: EMPTY
105184: LIST
105185: LIST
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: LIST
105195: PPUSH
105196: CALL_OW 69
105200: ST_TO_ADDR
// if not tmp then
105201: LD_VAR 0 2
105205: NOT
105206: IFFALSE 105210
// exit ;
105208: GO 105259
// for i in tmp do
105210: LD_ADDR_VAR 0 1
105214: PUSH
105215: LD_VAR 0 2
105219: PUSH
105220: FOR_IN
105221: IFFALSE 105257
// begin if Crawls ( i ) then
105223: LD_VAR 0 1
105227: PPUSH
105228: CALL_OW 318
105232: IFFALSE 105243
// ComWalk ( i ) ;
105234: LD_VAR 0 1
105238: PPUSH
105239: CALL_OW 138
// SetClass ( i , 2 ) ;
105243: LD_VAR 0 1
105247: PPUSH
105248: LD_INT 2
105250: PPUSH
105251: CALL_OW 336
// end ;
105255: GO 105220
105257: POP
105258: POP
// end ;
105259: PPOPN 2
105261: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105262: LD_EXP 77
105266: PUSH
105267: LD_EXP 130
105271: AND
105272: IFFALSE 105560
105274: GO 105276
105276: DISABLE
105277: LD_INT 0
105279: PPUSH
105280: PPUSH
105281: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105282: LD_OWVAR 2
105286: PPUSH
105287: LD_INT 9
105289: PPUSH
105290: LD_INT 1
105292: PPUSH
105293: LD_INT 1
105295: PPUSH
105296: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105300: LD_INT 9
105302: PPUSH
105303: LD_OWVAR 2
105307: PPUSH
105308: CALL_OW 343
// uc_side := 9 ;
105312: LD_ADDR_OWVAR 20
105316: PUSH
105317: LD_INT 9
105319: ST_TO_ADDR
// uc_nation := 2 ;
105320: LD_ADDR_OWVAR 21
105324: PUSH
105325: LD_INT 2
105327: ST_TO_ADDR
// hc_name := Dark Warrior ;
105328: LD_ADDR_OWVAR 26
105332: PUSH
105333: LD_STRING Dark Warrior
105335: ST_TO_ADDR
// hc_gallery :=  ;
105336: LD_ADDR_OWVAR 33
105340: PUSH
105341: LD_STRING 
105343: ST_TO_ADDR
// hc_noskilllimit := true ;
105344: LD_ADDR_OWVAR 76
105348: PUSH
105349: LD_INT 1
105351: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105352: LD_ADDR_OWVAR 31
105356: PUSH
105357: LD_INT 30
105359: PUSH
105360: LD_INT 30
105362: PUSH
105363: LD_INT 30
105365: PUSH
105366: LD_INT 30
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: LIST
105373: LIST
105374: ST_TO_ADDR
// un := CreateHuman ;
105375: LD_ADDR_VAR 0 3
105379: PUSH
105380: CALL_OW 44
105384: ST_TO_ADDR
// hc_noskilllimit := false ;
105385: LD_ADDR_OWVAR 76
105389: PUSH
105390: LD_INT 0
105392: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105393: LD_VAR 0 3
105397: PPUSH
105398: LD_INT 1
105400: PPUSH
105401: CALL_OW 51
// ToLua ( playRanger() ) ;
105405: LD_STRING playRanger()
105407: PPUSH
105408: CALL_OW 559
// p := 0 ;
105412: LD_ADDR_VAR 0 2
105416: PUSH
105417: LD_INT 0
105419: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105420: LD_INT 35
105422: PPUSH
105423: CALL_OW 67
// p := p + 1 ;
105427: LD_ADDR_VAR 0 2
105431: PUSH
105432: LD_VAR 0 2
105436: PUSH
105437: LD_INT 1
105439: PLUS
105440: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105441: LD_VAR 0 3
105445: PPUSH
105446: CALL_OW 256
105450: PUSH
105451: LD_INT 1000
105453: LESS
105454: IFFALSE 105468
// SetLives ( un , 1000 ) ;
105456: LD_VAR 0 3
105460: PPUSH
105461: LD_INT 1000
105463: PPUSH
105464: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105468: LD_VAR 0 3
105472: PPUSH
105473: LD_INT 81
105475: PUSH
105476: LD_OWVAR 2
105480: PUSH
105481: EMPTY
105482: LIST
105483: LIST
105484: PUSH
105485: LD_INT 91
105487: PUSH
105488: LD_VAR 0 3
105492: PUSH
105493: LD_INT 30
105495: PUSH
105496: EMPTY
105497: LIST
105498: LIST
105499: LIST
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: PPUSH
105505: CALL_OW 69
105509: PPUSH
105510: LD_VAR 0 3
105514: PPUSH
105515: CALL_OW 74
105519: PPUSH
105520: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105524: LD_VAR 0 2
105528: PUSH
105529: LD_INT 80
105531: GREATER
105532: PUSH
105533: LD_VAR 0 3
105537: PPUSH
105538: CALL_OW 301
105542: OR
105543: IFFALSE 105420
// if un then
105545: LD_VAR 0 3
105549: IFFALSE 105560
// RemoveUnit ( un ) ;
105551: LD_VAR 0 3
105555: PPUSH
105556: CALL_OW 64
// end ;
105560: PPOPN 3
105562: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105563: LD_EXP 131
105567: IFFALSE 105683
105569: GO 105571
105571: DISABLE
105572: LD_INT 0
105574: PPUSH
105575: PPUSH
105576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105577: LD_ADDR_VAR 0 2
105581: PUSH
105582: LD_INT 81
105584: PUSH
105585: LD_OWVAR 2
105589: PUSH
105590: EMPTY
105591: LIST
105592: LIST
105593: PUSH
105594: LD_INT 21
105596: PUSH
105597: LD_INT 1
105599: PUSH
105600: EMPTY
105601: LIST
105602: LIST
105603: PUSH
105604: EMPTY
105605: LIST
105606: LIST
105607: PPUSH
105608: CALL_OW 69
105612: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105613: LD_STRING playComputer()
105615: PPUSH
105616: CALL_OW 559
// if not tmp then
105620: LD_VAR 0 2
105624: NOT
105625: IFFALSE 105629
// exit ;
105627: GO 105683
// for i in tmp do
105629: LD_ADDR_VAR 0 1
105633: PUSH
105634: LD_VAR 0 2
105638: PUSH
105639: FOR_IN
105640: IFFALSE 105681
// for j := 1 to 4 do
105642: LD_ADDR_VAR 0 3
105646: PUSH
105647: DOUBLE
105648: LD_INT 1
105650: DEC
105651: ST_TO_ADDR
105652: LD_INT 4
105654: PUSH
105655: FOR_TO
105656: IFFALSE 105677
// SetSkill ( i , j , 10 ) ;
105658: LD_VAR 0 1
105662: PPUSH
105663: LD_VAR 0 3
105667: PPUSH
105668: LD_INT 10
105670: PPUSH
105671: CALL_OW 237
105675: GO 105655
105677: POP
105678: POP
105679: GO 105639
105681: POP
105682: POP
// end ;
105683: PPOPN 3
105685: END
// every 0 0$1 trigger s30 do var i , tmp ;
105686: LD_EXP 132
105690: IFFALSE 105759
105692: GO 105694
105694: DISABLE
105695: LD_INT 0
105697: PPUSH
105698: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105699: LD_ADDR_VAR 0 2
105703: PUSH
105704: LD_INT 22
105706: PUSH
105707: LD_OWVAR 2
105711: PUSH
105712: EMPTY
105713: LIST
105714: LIST
105715: PPUSH
105716: CALL_OW 69
105720: ST_TO_ADDR
// if not tmp then
105721: LD_VAR 0 2
105725: NOT
105726: IFFALSE 105730
// exit ;
105728: GO 105759
// for i in tmp do
105730: LD_ADDR_VAR 0 1
105734: PUSH
105735: LD_VAR 0 2
105739: PUSH
105740: FOR_IN
105741: IFFALSE 105757
// SetLives ( i , 300 ) ;
105743: LD_VAR 0 1
105747: PPUSH
105748: LD_INT 300
105750: PPUSH
105751: CALL_OW 234
105755: GO 105740
105757: POP
105758: POP
// end ;
105759: PPOPN 2
105761: END
// every 0 0$1 trigger s60 do var i , tmp ;
105762: LD_EXP 133
105766: IFFALSE 105835
105768: GO 105770
105770: DISABLE
105771: LD_INT 0
105773: PPUSH
105774: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105775: LD_ADDR_VAR 0 2
105779: PUSH
105780: LD_INT 22
105782: PUSH
105783: LD_OWVAR 2
105787: PUSH
105788: EMPTY
105789: LIST
105790: LIST
105791: PPUSH
105792: CALL_OW 69
105796: ST_TO_ADDR
// if not tmp then
105797: LD_VAR 0 2
105801: NOT
105802: IFFALSE 105806
// exit ;
105804: GO 105835
// for i in tmp do
105806: LD_ADDR_VAR 0 1
105810: PUSH
105811: LD_VAR 0 2
105815: PUSH
105816: FOR_IN
105817: IFFALSE 105833
// SetLives ( i , 600 ) ;
105819: LD_VAR 0 1
105823: PPUSH
105824: LD_INT 600
105826: PPUSH
105827: CALL_OW 234
105831: GO 105816
105833: POP
105834: POP
// end ;
105835: PPOPN 2
105837: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105838: LD_INT 0
105840: PPUSH
// case cmd of 301 :
105841: LD_VAR 0 1
105845: PUSH
105846: LD_INT 301
105848: DOUBLE
105849: EQUAL
105850: IFTRUE 105854
105852: GO 105886
105854: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105855: LD_VAR 0 6
105859: PPUSH
105860: LD_VAR 0 7
105864: PPUSH
105865: LD_VAR 0 8
105869: PPUSH
105870: LD_VAR 0 4
105874: PPUSH
105875: LD_VAR 0 5
105879: PPUSH
105880: CALL 107095 0 5
105884: GO 106007
105886: LD_INT 302
105888: DOUBLE
105889: EQUAL
105890: IFTRUE 105894
105892: GO 105931
105894: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105895: LD_VAR 0 6
105899: PPUSH
105900: LD_VAR 0 7
105904: PPUSH
105905: LD_VAR 0 8
105909: PPUSH
105910: LD_VAR 0 9
105914: PPUSH
105915: LD_VAR 0 4
105919: PPUSH
105920: LD_VAR 0 5
105924: PPUSH
105925: CALL 107186 0 6
105929: GO 106007
105931: LD_INT 303
105933: DOUBLE
105934: EQUAL
105935: IFTRUE 105939
105937: GO 105976
105939: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105940: LD_VAR 0 6
105944: PPUSH
105945: LD_VAR 0 7
105949: PPUSH
105950: LD_VAR 0 8
105954: PPUSH
105955: LD_VAR 0 9
105959: PPUSH
105960: LD_VAR 0 4
105964: PPUSH
105965: LD_VAR 0 5
105969: PPUSH
105970: CALL 106012 0 6
105974: GO 106007
105976: LD_INT 304
105978: DOUBLE
105979: EQUAL
105980: IFTRUE 105984
105982: GO 106006
105984: POP
// hHackTeleport ( unit , x , y ) ; end ;
105985: LD_VAR 0 2
105989: PPUSH
105990: LD_VAR 0 4
105994: PPUSH
105995: LD_VAR 0 5
105999: PPUSH
106000: CALL 107779 0 3
106004: GO 106007
106006: POP
// end ;
106007: LD_VAR 0 12
106011: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106012: LD_INT 0
106014: PPUSH
106015: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106016: LD_VAR 0 1
106020: PUSH
106021: LD_INT 1
106023: LESS
106024: PUSH
106025: LD_VAR 0 1
106029: PUSH
106030: LD_INT 3
106032: GREATER
106033: OR
106034: PUSH
106035: LD_VAR 0 5
106039: PPUSH
106040: LD_VAR 0 6
106044: PPUSH
106045: CALL_OW 428
106049: OR
106050: IFFALSE 106054
// exit ;
106052: GO 106782
// uc_side := your_side ;
106054: LD_ADDR_OWVAR 20
106058: PUSH
106059: LD_OWVAR 2
106063: ST_TO_ADDR
// uc_nation := nation ;
106064: LD_ADDR_OWVAR 21
106068: PUSH
106069: LD_VAR 0 1
106073: ST_TO_ADDR
// bc_level = 1 ;
106074: LD_ADDR_OWVAR 43
106078: PUSH
106079: LD_INT 1
106081: ST_TO_ADDR
// case btype of 1 :
106082: LD_VAR 0 2
106086: PUSH
106087: LD_INT 1
106089: DOUBLE
106090: EQUAL
106091: IFTRUE 106095
106093: GO 106106
106095: POP
// bc_type := b_depot ; 2 :
106096: LD_ADDR_OWVAR 42
106100: PUSH
106101: LD_INT 0
106103: ST_TO_ADDR
106104: GO 106726
106106: LD_INT 2
106108: DOUBLE
106109: EQUAL
106110: IFTRUE 106114
106112: GO 106125
106114: POP
// bc_type := b_warehouse ; 3 :
106115: LD_ADDR_OWVAR 42
106119: PUSH
106120: LD_INT 1
106122: ST_TO_ADDR
106123: GO 106726
106125: LD_INT 3
106127: DOUBLE
106128: EQUAL
106129: IFTRUE 106133
106131: GO 106144
106133: POP
// bc_type := b_lab ; 4 .. 9 :
106134: LD_ADDR_OWVAR 42
106138: PUSH
106139: LD_INT 6
106141: ST_TO_ADDR
106142: GO 106726
106144: LD_INT 4
106146: DOUBLE
106147: GREATEREQUAL
106148: IFFALSE 106156
106150: LD_INT 9
106152: DOUBLE
106153: LESSEQUAL
106154: IFTRUE 106158
106156: GO 106218
106158: POP
// begin bc_type := b_lab_half ;
106159: LD_ADDR_OWVAR 42
106163: PUSH
106164: LD_INT 7
106166: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106167: LD_ADDR_OWVAR 44
106171: PUSH
106172: LD_INT 10
106174: PUSH
106175: LD_INT 11
106177: PUSH
106178: LD_INT 12
106180: PUSH
106181: LD_INT 15
106183: PUSH
106184: LD_INT 14
106186: PUSH
106187: LD_INT 13
106189: PUSH
106190: EMPTY
106191: LIST
106192: LIST
106193: LIST
106194: LIST
106195: LIST
106196: LIST
106197: PUSH
106198: LD_VAR 0 2
106202: PUSH
106203: LD_INT 3
106205: MINUS
106206: ARRAY
106207: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
106208: LD_ADDR_OWVAR 45
106212: PUSH
106213: LD_INT 9
106215: ST_TO_ADDR
// end ; 10 .. 13 :
106216: GO 106726
106218: LD_INT 10
106220: DOUBLE
106221: GREATEREQUAL
106222: IFFALSE 106230
106224: LD_INT 13
106226: DOUBLE
106227: LESSEQUAL
106228: IFTRUE 106232
106230: GO 106309
106232: POP
// begin bc_type := b_lab_full ;
106233: LD_ADDR_OWVAR 42
106237: PUSH
106238: LD_INT 8
106240: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106241: LD_ADDR_OWVAR 44
106245: PUSH
106246: LD_INT 10
106248: PUSH
106249: LD_INT 12
106251: PUSH
106252: LD_INT 14
106254: PUSH
106255: LD_INT 13
106257: PUSH
106258: EMPTY
106259: LIST
106260: LIST
106261: LIST
106262: LIST
106263: PUSH
106264: LD_VAR 0 2
106268: PUSH
106269: LD_INT 9
106271: MINUS
106272: ARRAY
106273: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106274: LD_ADDR_OWVAR 45
106278: PUSH
106279: LD_INT 11
106281: PUSH
106282: LD_INT 15
106284: PUSH
106285: LD_INT 12
106287: PUSH
106288: LD_INT 15
106290: PUSH
106291: EMPTY
106292: LIST
106293: LIST
106294: LIST
106295: LIST
106296: PUSH
106297: LD_VAR 0 2
106301: PUSH
106302: LD_INT 9
106304: MINUS
106305: ARRAY
106306: ST_TO_ADDR
// end ; 14 :
106307: GO 106726
106309: LD_INT 14
106311: DOUBLE
106312: EQUAL
106313: IFTRUE 106317
106315: GO 106328
106317: POP
// bc_type := b_workshop ; 15 :
106318: LD_ADDR_OWVAR 42
106322: PUSH
106323: LD_INT 2
106325: ST_TO_ADDR
106326: GO 106726
106328: LD_INT 15
106330: DOUBLE
106331: EQUAL
106332: IFTRUE 106336
106334: GO 106347
106336: POP
// bc_type := b_factory ; 16 :
106337: LD_ADDR_OWVAR 42
106341: PUSH
106342: LD_INT 3
106344: ST_TO_ADDR
106345: GO 106726
106347: LD_INT 16
106349: DOUBLE
106350: EQUAL
106351: IFTRUE 106355
106353: GO 106366
106355: POP
// bc_type := b_ext_gun ; 17 :
106356: LD_ADDR_OWVAR 42
106360: PUSH
106361: LD_INT 17
106363: ST_TO_ADDR
106364: GO 106726
106366: LD_INT 17
106368: DOUBLE
106369: EQUAL
106370: IFTRUE 106374
106372: GO 106402
106374: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106375: LD_ADDR_OWVAR 42
106379: PUSH
106380: LD_INT 19
106382: PUSH
106383: LD_INT 23
106385: PUSH
106386: LD_INT 19
106388: PUSH
106389: EMPTY
106390: LIST
106391: LIST
106392: LIST
106393: PUSH
106394: LD_VAR 0 1
106398: ARRAY
106399: ST_TO_ADDR
106400: GO 106726
106402: LD_INT 18
106404: DOUBLE
106405: EQUAL
106406: IFTRUE 106410
106408: GO 106421
106410: POP
// bc_type := b_ext_radar ; 19 :
106411: LD_ADDR_OWVAR 42
106415: PUSH
106416: LD_INT 20
106418: ST_TO_ADDR
106419: GO 106726
106421: LD_INT 19
106423: DOUBLE
106424: EQUAL
106425: IFTRUE 106429
106427: GO 106440
106429: POP
// bc_type := b_ext_radio ; 20 :
106430: LD_ADDR_OWVAR 42
106434: PUSH
106435: LD_INT 22
106437: ST_TO_ADDR
106438: GO 106726
106440: LD_INT 20
106442: DOUBLE
106443: EQUAL
106444: IFTRUE 106448
106446: GO 106459
106448: POP
// bc_type := b_ext_siberium ; 21 :
106449: LD_ADDR_OWVAR 42
106453: PUSH
106454: LD_INT 21
106456: ST_TO_ADDR
106457: GO 106726
106459: LD_INT 21
106461: DOUBLE
106462: EQUAL
106463: IFTRUE 106467
106465: GO 106478
106467: POP
// bc_type := b_ext_computer ; 22 :
106468: LD_ADDR_OWVAR 42
106472: PUSH
106473: LD_INT 24
106475: ST_TO_ADDR
106476: GO 106726
106478: LD_INT 22
106480: DOUBLE
106481: EQUAL
106482: IFTRUE 106486
106484: GO 106497
106486: POP
// bc_type := b_ext_track ; 23 :
106487: LD_ADDR_OWVAR 42
106491: PUSH
106492: LD_INT 16
106494: ST_TO_ADDR
106495: GO 106726
106497: LD_INT 23
106499: DOUBLE
106500: EQUAL
106501: IFTRUE 106505
106503: GO 106516
106505: POP
// bc_type := b_ext_laser ; 24 :
106506: LD_ADDR_OWVAR 42
106510: PUSH
106511: LD_INT 25
106513: ST_TO_ADDR
106514: GO 106726
106516: LD_INT 24
106518: DOUBLE
106519: EQUAL
106520: IFTRUE 106524
106522: GO 106535
106524: POP
// bc_type := b_control_tower ; 25 :
106525: LD_ADDR_OWVAR 42
106529: PUSH
106530: LD_INT 36
106532: ST_TO_ADDR
106533: GO 106726
106535: LD_INT 25
106537: DOUBLE
106538: EQUAL
106539: IFTRUE 106543
106541: GO 106554
106543: POP
// bc_type := b_breastwork ; 26 :
106544: LD_ADDR_OWVAR 42
106548: PUSH
106549: LD_INT 31
106551: ST_TO_ADDR
106552: GO 106726
106554: LD_INT 26
106556: DOUBLE
106557: EQUAL
106558: IFTRUE 106562
106560: GO 106573
106562: POP
// bc_type := b_bunker ; 27 :
106563: LD_ADDR_OWVAR 42
106567: PUSH
106568: LD_INT 32
106570: ST_TO_ADDR
106571: GO 106726
106573: LD_INT 27
106575: DOUBLE
106576: EQUAL
106577: IFTRUE 106581
106579: GO 106592
106581: POP
// bc_type := b_turret ; 28 :
106582: LD_ADDR_OWVAR 42
106586: PUSH
106587: LD_INT 33
106589: ST_TO_ADDR
106590: GO 106726
106592: LD_INT 28
106594: DOUBLE
106595: EQUAL
106596: IFTRUE 106600
106598: GO 106611
106600: POP
// bc_type := b_armoury ; 29 :
106601: LD_ADDR_OWVAR 42
106605: PUSH
106606: LD_INT 4
106608: ST_TO_ADDR
106609: GO 106726
106611: LD_INT 29
106613: DOUBLE
106614: EQUAL
106615: IFTRUE 106619
106617: GO 106630
106619: POP
// bc_type := b_barracks ; 30 :
106620: LD_ADDR_OWVAR 42
106624: PUSH
106625: LD_INT 5
106627: ST_TO_ADDR
106628: GO 106726
106630: LD_INT 30
106632: DOUBLE
106633: EQUAL
106634: IFTRUE 106638
106636: GO 106649
106638: POP
// bc_type := b_solar_power ; 31 :
106639: LD_ADDR_OWVAR 42
106643: PUSH
106644: LD_INT 27
106646: ST_TO_ADDR
106647: GO 106726
106649: LD_INT 31
106651: DOUBLE
106652: EQUAL
106653: IFTRUE 106657
106655: GO 106668
106657: POP
// bc_type := b_oil_power ; 32 :
106658: LD_ADDR_OWVAR 42
106662: PUSH
106663: LD_INT 26
106665: ST_TO_ADDR
106666: GO 106726
106668: LD_INT 32
106670: DOUBLE
106671: EQUAL
106672: IFTRUE 106676
106674: GO 106687
106676: POP
// bc_type := b_siberite_power ; 33 :
106677: LD_ADDR_OWVAR 42
106681: PUSH
106682: LD_INT 28
106684: ST_TO_ADDR
106685: GO 106726
106687: LD_INT 33
106689: DOUBLE
106690: EQUAL
106691: IFTRUE 106695
106693: GO 106706
106695: POP
// bc_type := b_oil_mine ; 34 :
106696: LD_ADDR_OWVAR 42
106700: PUSH
106701: LD_INT 29
106703: ST_TO_ADDR
106704: GO 106726
106706: LD_INT 34
106708: DOUBLE
106709: EQUAL
106710: IFTRUE 106714
106712: GO 106725
106714: POP
// bc_type := b_siberite_mine ; end ;
106715: LD_ADDR_OWVAR 42
106719: PUSH
106720: LD_INT 30
106722: ST_TO_ADDR
106723: GO 106726
106725: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106726: LD_ADDR_VAR 0 8
106730: PUSH
106731: LD_VAR 0 5
106735: PPUSH
106736: LD_VAR 0 6
106740: PPUSH
106741: LD_VAR 0 3
106745: PPUSH
106746: CALL_OW 47
106750: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106751: LD_OWVAR 42
106755: PUSH
106756: LD_INT 32
106758: PUSH
106759: LD_INT 33
106761: PUSH
106762: EMPTY
106763: LIST
106764: LIST
106765: IN
106766: IFFALSE 106782
// PlaceWeaponTurret ( b , weapon ) ;
106768: LD_VAR 0 8
106772: PPUSH
106773: LD_VAR 0 4
106777: PPUSH
106778: CALL_OW 431
// end ;
106782: LD_VAR 0 7
106786: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106787: LD_INT 0
106789: PPUSH
106790: PPUSH
106791: PPUSH
106792: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106793: LD_ADDR_VAR 0 4
106797: PUSH
106798: LD_INT 22
106800: PUSH
106801: LD_OWVAR 2
106805: PUSH
106806: EMPTY
106807: LIST
106808: LIST
106809: PUSH
106810: LD_INT 2
106812: PUSH
106813: LD_INT 30
106815: PUSH
106816: LD_INT 0
106818: PUSH
106819: EMPTY
106820: LIST
106821: LIST
106822: PUSH
106823: LD_INT 30
106825: PUSH
106826: LD_INT 1
106828: PUSH
106829: EMPTY
106830: LIST
106831: LIST
106832: PUSH
106833: EMPTY
106834: LIST
106835: LIST
106836: LIST
106837: PUSH
106838: EMPTY
106839: LIST
106840: LIST
106841: PPUSH
106842: CALL_OW 69
106846: ST_TO_ADDR
// if not tmp then
106847: LD_VAR 0 4
106851: NOT
106852: IFFALSE 106856
// exit ;
106854: GO 106915
// for i in tmp do
106856: LD_ADDR_VAR 0 2
106860: PUSH
106861: LD_VAR 0 4
106865: PUSH
106866: FOR_IN
106867: IFFALSE 106913
// for j = 1 to 3 do
106869: LD_ADDR_VAR 0 3
106873: PUSH
106874: DOUBLE
106875: LD_INT 1
106877: DEC
106878: ST_TO_ADDR
106879: LD_INT 3
106881: PUSH
106882: FOR_TO
106883: IFFALSE 106909
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106885: LD_VAR 0 2
106889: PPUSH
106890: CALL_OW 274
106894: PPUSH
106895: LD_VAR 0 3
106899: PPUSH
106900: LD_INT 99999
106902: PPUSH
106903: CALL_OW 277
106907: GO 106882
106909: POP
106910: POP
106911: GO 106866
106913: POP
106914: POP
// end ;
106915: LD_VAR 0 1
106919: RET
// export function hHackSetLevel10 ; var i , j ; begin
106920: LD_INT 0
106922: PPUSH
106923: PPUSH
106924: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106925: LD_ADDR_VAR 0 2
106929: PUSH
106930: LD_INT 21
106932: PUSH
106933: LD_INT 1
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: PPUSH
106940: CALL_OW 69
106944: PUSH
106945: FOR_IN
106946: IFFALSE 106998
// if IsSelected ( i ) then
106948: LD_VAR 0 2
106952: PPUSH
106953: CALL_OW 306
106957: IFFALSE 106996
// begin for j := 1 to 4 do
106959: LD_ADDR_VAR 0 3
106963: PUSH
106964: DOUBLE
106965: LD_INT 1
106967: DEC
106968: ST_TO_ADDR
106969: LD_INT 4
106971: PUSH
106972: FOR_TO
106973: IFFALSE 106994
// SetSkill ( i , j , 10 ) ;
106975: LD_VAR 0 2
106979: PPUSH
106980: LD_VAR 0 3
106984: PPUSH
106985: LD_INT 10
106987: PPUSH
106988: CALL_OW 237
106992: GO 106972
106994: POP
106995: POP
// end ;
106996: GO 106945
106998: POP
106999: POP
// end ;
107000: LD_VAR 0 1
107004: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107005: LD_INT 0
107007: PPUSH
107008: PPUSH
107009: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107010: LD_ADDR_VAR 0 2
107014: PUSH
107015: LD_INT 22
107017: PUSH
107018: LD_OWVAR 2
107022: PUSH
107023: EMPTY
107024: LIST
107025: LIST
107026: PUSH
107027: LD_INT 21
107029: PUSH
107030: LD_INT 1
107032: PUSH
107033: EMPTY
107034: LIST
107035: LIST
107036: PUSH
107037: EMPTY
107038: LIST
107039: LIST
107040: PPUSH
107041: CALL_OW 69
107045: PUSH
107046: FOR_IN
107047: IFFALSE 107088
// begin for j := 1 to 4 do
107049: LD_ADDR_VAR 0 3
107053: PUSH
107054: DOUBLE
107055: LD_INT 1
107057: DEC
107058: ST_TO_ADDR
107059: LD_INT 4
107061: PUSH
107062: FOR_TO
107063: IFFALSE 107084
// SetSkill ( i , j , 10 ) ;
107065: LD_VAR 0 2
107069: PPUSH
107070: LD_VAR 0 3
107074: PPUSH
107075: LD_INT 10
107077: PPUSH
107078: CALL_OW 237
107082: GO 107062
107084: POP
107085: POP
// end ;
107086: GO 107046
107088: POP
107089: POP
// end ;
107090: LD_VAR 0 1
107094: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107095: LD_INT 0
107097: PPUSH
// uc_side := your_side ;
107098: LD_ADDR_OWVAR 20
107102: PUSH
107103: LD_OWVAR 2
107107: ST_TO_ADDR
// uc_nation := nation ;
107108: LD_ADDR_OWVAR 21
107112: PUSH
107113: LD_VAR 0 1
107117: ST_TO_ADDR
// InitHc ;
107118: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107122: LD_INT 0
107124: PPUSH
107125: LD_VAR 0 2
107129: PPUSH
107130: LD_VAR 0 3
107134: PPUSH
107135: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107139: LD_VAR 0 4
107143: PPUSH
107144: LD_VAR 0 5
107148: PPUSH
107149: CALL_OW 428
107153: PUSH
107154: LD_INT 0
107156: EQUAL
107157: IFFALSE 107181
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107159: CALL_OW 44
107163: PPUSH
107164: LD_VAR 0 4
107168: PPUSH
107169: LD_VAR 0 5
107173: PPUSH
107174: LD_INT 1
107176: PPUSH
107177: CALL_OW 48
// end ;
107181: LD_VAR 0 6
107185: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107186: LD_INT 0
107188: PPUSH
107189: PPUSH
// uc_side := your_side ;
107190: LD_ADDR_OWVAR 20
107194: PUSH
107195: LD_OWVAR 2
107199: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107200: LD_VAR 0 1
107204: PUSH
107205: LD_INT 1
107207: PUSH
107208: LD_INT 2
107210: PUSH
107211: LD_INT 3
107213: PUSH
107214: LD_INT 4
107216: PUSH
107217: LD_INT 5
107219: PUSH
107220: EMPTY
107221: LIST
107222: LIST
107223: LIST
107224: LIST
107225: LIST
107226: IN
107227: IFFALSE 107239
// uc_nation := nation_american else
107229: LD_ADDR_OWVAR 21
107233: PUSH
107234: LD_INT 1
107236: ST_TO_ADDR
107237: GO 107282
// if chassis in [ 11 , 12 , 13 , 14 ] then
107239: LD_VAR 0 1
107243: PUSH
107244: LD_INT 11
107246: PUSH
107247: LD_INT 12
107249: PUSH
107250: LD_INT 13
107252: PUSH
107253: LD_INT 14
107255: PUSH
107256: EMPTY
107257: LIST
107258: LIST
107259: LIST
107260: LIST
107261: IN
107262: IFFALSE 107274
// uc_nation := nation_arabian else
107264: LD_ADDR_OWVAR 21
107268: PUSH
107269: LD_INT 2
107271: ST_TO_ADDR
107272: GO 107282
// uc_nation := nation_russian ;
107274: LD_ADDR_OWVAR 21
107278: PUSH
107279: LD_INT 3
107281: ST_TO_ADDR
// vc_chassis := chassis ;
107282: LD_ADDR_OWVAR 37
107286: PUSH
107287: LD_VAR 0 1
107291: ST_TO_ADDR
// vc_engine := engine ;
107292: LD_ADDR_OWVAR 39
107296: PUSH
107297: LD_VAR 0 2
107301: ST_TO_ADDR
// vc_control := control ;
107302: LD_ADDR_OWVAR 38
107306: PUSH
107307: LD_VAR 0 3
107311: ST_TO_ADDR
// vc_weapon := weapon ;
107312: LD_ADDR_OWVAR 40
107316: PUSH
107317: LD_VAR 0 4
107321: ST_TO_ADDR
// un := CreateVehicle ;
107322: LD_ADDR_VAR 0 8
107326: PUSH
107327: CALL_OW 45
107331: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107332: LD_VAR 0 8
107336: PPUSH
107337: LD_INT 0
107339: PPUSH
107340: LD_INT 5
107342: PPUSH
107343: CALL_OW 12
107347: PPUSH
107348: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107352: LD_VAR 0 8
107356: PPUSH
107357: LD_VAR 0 5
107361: PPUSH
107362: LD_VAR 0 6
107366: PPUSH
107367: LD_INT 1
107369: PPUSH
107370: CALL_OW 48
// end ;
107374: LD_VAR 0 7
107378: RET
// export hInvincible ; every 1 do
107379: GO 107381
107381: DISABLE
// hInvincible := [ ] ;
107382: LD_ADDR_EXP 134
107386: PUSH
107387: EMPTY
107388: ST_TO_ADDR
107389: END
// every 10 do var i ;
107390: GO 107392
107392: DISABLE
107393: LD_INT 0
107395: PPUSH
// begin enable ;
107396: ENABLE
// if not hInvincible then
107397: LD_EXP 134
107401: NOT
107402: IFFALSE 107406
// exit ;
107404: GO 107450
// for i in hInvincible do
107406: LD_ADDR_VAR 0 1
107410: PUSH
107411: LD_EXP 134
107415: PUSH
107416: FOR_IN
107417: IFFALSE 107448
// if GetLives ( i ) < 1000 then
107419: LD_VAR 0 1
107423: PPUSH
107424: CALL_OW 256
107428: PUSH
107429: LD_INT 1000
107431: LESS
107432: IFFALSE 107446
// SetLives ( i , 1000 ) ;
107434: LD_VAR 0 1
107438: PPUSH
107439: LD_INT 1000
107441: PPUSH
107442: CALL_OW 234
107446: GO 107416
107448: POP
107449: POP
// end ;
107450: PPOPN 1
107452: END
// export function hHackInvincible ; var i ; begin
107453: LD_INT 0
107455: PPUSH
107456: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107457: LD_ADDR_VAR 0 2
107461: PUSH
107462: LD_INT 2
107464: PUSH
107465: LD_INT 21
107467: PUSH
107468: LD_INT 1
107470: PUSH
107471: EMPTY
107472: LIST
107473: LIST
107474: PUSH
107475: LD_INT 21
107477: PUSH
107478: LD_INT 2
107480: PUSH
107481: EMPTY
107482: LIST
107483: LIST
107484: PUSH
107485: EMPTY
107486: LIST
107487: LIST
107488: LIST
107489: PPUSH
107490: CALL_OW 69
107494: PUSH
107495: FOR_IN
107496: IFFALSE 107557
// if IsSelected ( i ) then
107498: LD_VAR 0 2
107502: PPUSH
107503: CALL_OW 306
107507: IFFALSE 107555
// begin if i in hInvincible then
107509: LD_VAR 0 2
107513: PUSH
107514: LD_EXP 134
107518: IN
107519: IFFALSE 107539
// hInvincible := hInvincible diff i else
107521: LD_ADDR_EXP 134
107525: PUSH
107526: LD_EXP 134
107530: PUSH
107531: LD_VAR 0 2
107535: DIFF
107536: ST_TO_ADDR
107537: GO 107555
// hInvincible := hInvincible union i ;
107539: LD_ADDR_EXP 134
107543: PUSH
107544: LD_EXP 134
107548: PUSH
107549: LD_VAR 0 2
107553: UNION
107554: ST_TO_ADDR
// end ;
107555: GO 107495
107557: POP
107558: POP
// end ;
107559: LD_VAR 0 1
107563: RET
// export function hHackInvisible ; var i , j ; begin
107564: LD_INT 0
107566: PPUSH
107567: PPUSH
107568: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107569: LD_ADDR_VAR 0 2
107573: PUSH
107574: LD_INT 21
107576: PUSH
107577: LD_INT 1
107579: PUSH
107580: EMPTY
107581: LIST
107582: LIST
107583: PPUSH
107584: CALL_OW 69
107588: PUSH
107589: FOR_IN
107590: IFFALSE 107614
// if IsSelected ( i ) then
107592: LD_VAR 0 2
107596: PPUSH
107597: CALL_OW 306
107601: IFFALSE 107612
// ComForceInvisible ( i ) ;
107603: LD_VAR 0 2
107607: PPUSH
107608: CALL_OW 496
107612: GO 107589
107614: POP
107615: POP
// end ;
107616: LD_VAR 0 1
107620: RET
// export function hHackChangeYourSide ; begin
107621: LD_INT 0
107623: PPUSH
// if your_side = 8 then
107624: LD_OWVAR 2
107628: PUSH
107629: LD_INT 8
107631: EQUAL
107632: IFFALSE 107644
// your_side := 0 else
107634: LD_ADDR_OWVAR 2
107638: PUSH
107639: LD_INT 0
107641: ST_TO_ADDR
107642: GO 107658
// your_side := your_side + 1 ;
107644: LD_ADDR_OWVAR 2
107648: PUSH
107649: LD_OWVAR 2
107653: PUSH
107654: LD_INT 1
107656: PLUS
107657: ST_TO_ADDR
// end ;
107658: LD_VAR 0 1
107662: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107663: LD_INT 0
107665: PPUSH
107666: PPUSH
107667: PPUSH
// for i in all_units do
107668: LD_ADDR_VAR 0 2
107672: PUSH
107673: LD_OWVAR 3
107677: PUSH
107678: FOR_IN
107679: IFFALSE 107757
// if IsSelected ( i ) then
107681: LD_VAR 0 2
107685: PPUSH
107686: CALL_OW 306
107690: IFFALSE 107755
// begin j := GetSide ( i ) ;
107692: LD_ADDR_VAR 0 3
107696: PUSH
107697: LD_VAR 0 2
107701: PPUSH
107702: CALL_OW 255
107706: ST_TO_ADDR
// if j = 8 then
107707: LD_VAR 0 3
107711: PUSH
107712: LD_INT 8
107714: EQUAL
107715: IFFALSE 107727
// j := 0 else
107717: LD_ADDR_VAR 0 3
107721: PUSH
107722: LD_INT 0
107724: ST_TO_ADDR
107725: GO 107741
// j := j + 1 ;
107727: LD_ADDR_VAR 0 3
107731: PUSH
107732: LD_VAR 0 3
107736: PUSH
107737: LD_INT 1
107739: PLUS
107740: ST_TO_ADDR
// SetSide ( i , j ) ;
107741: LD_VAR 0 2
107745: PPUSH
107746: LD_VAR 0 3
107750: PPUSH
107751: CALL_OW 235
// end ;
107755: GO 107678
107757: POP
107758: POP
// end ;
107759: LD_VAR 0 1
107763: RET
// export function hHackFog ; begin
107764: LD_INT 0
107766: PPUSH
// FogOff ( true ) ;
107767: LD_INT 1
107769: PPUSH
107770: CALL_OW 344
// end ;
107774: LD_VAR 0 1
107778: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107779: LD_INT 0
107781: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107782: LD_VAR 0 1
107786: PPUSH
107787: LD_VAR 0 2
107791: PPUSH
107792: LD_VAR 0 3
107796: PPUSH
107797: LD_INT 1
107799: PPUSH
107800: LD_INT 1
107802: PPUSH
107803: CALL_OW 483
// CenterOnXY ( x , y ) ;
107807: LD_VAR 0 2
107811: PPUSH
107812: LD_VAR 0 3
107816: PPUSH
107817: CALL_OW 84
// end ;
107821: LD_VAR 0 4
107825: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107826: LD_INT 0
107828: PPUSH
107829: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107830: LD_VAR 0 1
107834: NOT
107835: PUSH
107836: LD_VAR 0 2
107840: PPUSH
107841: LD_VAR 0 3
107845: PPUSH
107846: CALL_OW 488
107850: NOT
107851: OR
107852: PUSH
107853: LD_VAR 0 1
107857: PPUSH
107858: CALL_OW 266
107862: PUSH
107863: LD_INT 3
107865: NONEQUAL
107866: PUSH
107867: LD_VAR 0 1
107871: PPUSH
107872: CALL_OW 247
107876: PUSH
107877: LD_INT 1
107879: EQUAL
107880: NOT
107881: AND
107882: OR
107883: IFFALSE 107887
// exit ;
107885: GO 108036
// if GetType ( factory ) = unit_human then
107887: LD_VAR 0 1
107891: PPUSH
107892: CALL_OW 247
107896: PUSH
107897: LD_INT 1
107899: EQUAL
107900: IFFALSE 107917
// factory := IsInUnit ( factory ) ;
107902: LD_ADDR_VAR 0 1
107906: PUSH
107907: LD_VAR 0 1
107911: PPUSH
107912: CALL_OW 310
107916: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107917: LD_VAR 0 1
107921: PPUSH
107922: CALL_OW 266
107926: PUSH
107927: LD_INT 3
107929: NONEQUAL
107930: IFFALSE 107934
// exit ;
107932: GO 108036
// if HexInfo ( x , y ) = factory then
107934: LD_VAR 0 2
107938: PPUSH
107939: LD_VAR 0 3
107943: PPUSH
107944: CALL_OW 428
107948: PUSH
107949: LD_VAR 0 1
107953: EQUAL
107954: IFFALSE 107981
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107956: LD_ADDR_EXP 135
107960: PUSH
107961: LD_EXP 135
107965: PPUSH
107966: LD_VAR 0 1
107970: PPUSH
107971: LD_INT 0
107973: PPUSH
107974: CALL_OW 1
107978: ST_TO_ADDR
107979: GO 108032
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107981: LD_ADDR_EXP 135
107985: PUSH
107986: LD_EXP 135
107990: PPUSH
107991: LD_VAR 0 1
107995: PPUSH
107996: LD_VAR 0 1
108000: PPUSH
108001: CALL_OW 255
108005: PUSH
108006: LD_VAR 0 1
108010: PUSH
108011: LD_VAR 0 2
108015: PUSH
108016: LD_VAR 0 3
108020: PUSH
108021: EMPTY
108022: LIST
108023: LIST
108024: LIST
108025: LIST
108026: PPUSH
108027: CALL_OW 1
108031: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108032: CALL 108041 0 0
// end ;
108036: LD_VAR 0 4
108040: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108041: LD_INT 0
108043: PPUSH
108044: PPUSH
108045: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108046: LD_STRING resetFactoryWaypoint();
108048: PPUSH
108049: CALL_OW 559
// if factoryWaypoints then
108053: LD_EXP 135
108057: IFFALSE 108183
// begin list := PrepareArray ( factoryWaypoints ) ;
108059: LD_ADDR_VAR 0 3
108063: PUSH
108064: LD_EXP 135
108068: PPUSH
108069: CALL 61288 0 1
108073: ST_TO_ADDR
// for i := 1 to list do
108074: LD_ADDR_VAR 0 2
108078: PUSH
108079: DOUBLE
108080: LD_INT 1
108082: DEC
108083: ST_TO_ADDR
108084: LD_VAR 0 3
108088: PUSH
108089: FOR_TO
108090: IFFALSE 108181
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108092: LD_STRING setFactoryWaypointXY(
108094: PUSH
108095: LD_VAR 0 3
108099: PUSH
108100: LD_VAR 0 2
108104: ARRAY
108105: PUSH
108106: LD_INT 1
108108: ARRAY
108109: STR
108110: PUSH
108111: LD_STRING ,
108113: STR
108114: PUSH
108115: LD_VAR 0 3
108119: PUSH
108120: LD_VAR 0 2
108124: ARRAY
108125: PUSH
108126: LD_INT 2
108128: ARRAY
108129: STR
108130: PUSH
108131: LD_STRING ,
108133: STR
108134: PUSH
108135: LD_VAR 0 3
108139: PUSH
108140: LD_VAR 0 2
108144: ARRAY
108145: PUSH
108146: LD_INT 3
108148: ARRAY
108149: STR
108150: PUSH
108151: LD_STRING ,
108153: STR
108154: PUSH
108155: LD_VAR 0 3
108159: PUSH
108160: LD_VAR 0 2
108164: ARRAY
108165: PUSH
108166: LD_INT 4
108168: ARRAY
108169: STR
108170: PUSH
108171: LD_STRING )
108173: STR
108174: PPUSH
108175: CALL_OW 559
108179: GO 108089
108181: POP
108182: POP
// end ; end ;
108183: LD_VAR 0 1
108187: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108188: LD_INT 0
108190: PPUSH
// if HexInfo ( x , y ) = warehouse then
108191: LD_VAR 0 2
108195: PPUSH
108196: LD_VAR 0 3
108200: PPUSH
108201: CALL_OW 428
108205: PUSH
108206: LD_VAR 0 1
108210: EQUAL
108211: IFFALSE 108238
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108213: LD_ADDR_EXP 136
108217: PUSH
108218: LD_EXP 136
108222: PPUSH
108223: LD_VAR 0 1
108227: PPUSH
108228: LD_INT 0
108230: PPUSH
108231: CALL_OW 1
108235: ST_TO_ADDR
108236: GO 108289
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108238: LD_ADDR_EXP 136
108242: PUSH
108243: LD_EXP 136
108247: PPUSH
108248: LD_VAR 0 1
108252: PPUSH
108253: LD_VAR 0 1
108257: PPUSH
108258: CALL_OW 255
108262: PUSH
108263: LD_VAR 0 1
108267: PUSH
108268: LD_VAR 0 2
108272: PUSH
108273: LD_VAR 0 3
108277: PUSH
108278: EMPTY
108279: LIST
108280: LIST
108281: LIST
108282: LIST
108283: PPUSH
108284: CALL_OW 1
108288: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108289: CALL 108298 0 0
// end ;
108293: LD_VAR 0 4
108297: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108298: LD_INT 0
108300: PPUSH
108301: PPUSH
108302: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108303: LD_STRING resetWarehouseGatheringPoints();
108305: PPUSH
108306: CALL_OW 559
// if warehouseGatheringPoints then
108310: LD_EXP 136
108314: IFFALSE 108440
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108316: LD_ADDR_VAR 0 3
108320: PUSH
108321: LD_EXP 136
108325: PPUSH
108326: CALL 61288 0 1
108330: ST_TO_ADDR
// for i := 1 to list do
108331: LD_ADDR_VAR 0 2
108335: PUSH
108336: DOUBLE
108337: LD_INT 1
108339: DEC
108340: ST_TO_ADDR
108341: LD_VAR 0 3
108345: PUSH
108346: FOR_TO
108347: IFFALSE 108438
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108349: LD_STRING setWarehouseGatheringPointXY(
108351: PUSH
108352: LD_VAR 0 3
108356: PUSH
108357: LD_VAR 0 2
108361: ARRAY
108362: PUSH
108363: LD_INT 1
108365: ARRAY
108366: STR
108367: PUSH
108368: LD_STRING ,
108370: STR
108371: PUSH
108372: LD_VAR 0 3
108376: PUSH
108377: LD_VAR 0 2
108381: ARRAY
108382: PUSH
108383: LD_INT 2
108385: ARRAY
108386: STR
108387: PUSH
108388: LD_STRING ,
108390: STR
108391: PUSH
108392: LD_VAR 0 3
108396: PUSH
108397: LD_VAR 0 2
108401: ARRAY
108402: PUSH
108403: LD_INT 3
108405: ARRAY
108406: STR
108407: PUSH
108408: LD_STRING ,
108410: STR
108411: PUSH
108412: LD_VAR 0 3
108416: PUSH
108417: LD_VAR 0 2
108421: ARRAY
108422: PUSH
108423: LD_INT 4
108425: ARRAY
108426: STR
108427: PUSH
108428: LD_STRING )
108430: STR
108431: PPUSH
108432: CALL_OW 559
108436: GO 108346
108438: POP
108439: POP
// end ; end ;
108440: LD_VAR 0 1
108444: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108445: LD_EXP 136
108449: IFFALSE 109134
108451: GO 108453
108453: DISABLE
108454: LD_INT 0
108456: PPUSH
108457: PPUSH
108458: PPUSH
108459: PPUSH
108460: PPUSH
108461: PPUSH
108462: PPUSH
108463: PPUSH
108464: PPUSH
// begin enable ;
108465: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108466: LD_ADDR_VAR 0 3
108470: PUSH
108471: LD_EXP 136
108475: PPUSH
108476: CALL 61288 0 1
108480: ST_TO_ADDR
// if not list then
108481: LD_VAR 0 3
108485: NOT
108486: IFFALSE 108490
// exit ;
108488: GO 109134
// for i := 1 to list do
108490: LD_ADDR_VAR 0 1
108494: PUSH
108495: DOUBLE
108496: LD_INT 1
108498: DEC
108499: ST_TO_ADDR
108500: LD_VAR 0 3
108504: PUSH
108505: FOR_TO
108506: IFFALSE 109132
// begin depot := list [ i ] [ 2 ] ;
108508: LD_ADDR_VAR 0 8
108512: PUSH
108513: LD_VAR 0 3
108517: PUSH
108518: LD_VAR 0 1
108522: ARRAY
108523: PUSH
108524: LD_INT 2
108526: ARRAY
108527: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108528: LD_ADDR_VAR 0 5
108532: PUSH
108533: LD_VAR 0 3
108537: PUSH
108538: LD_VAR 0 1
108542: ARRAY
108543: PUSH
108544: LD_INT 1
108546: ARRAY
108547: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108548: LD_VAR 0 8
108552: PPUSH
108553: CALL_OW 301
108557: PUSH
108558: LD_VAR 0 5
108562: PUSH
108563: LD_VAR 0 8
108567: PPUSH
108568: CALL_OW 255
108572: NONEQUAL
108573: OR
108574: IFFALSE 108603
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108576: LD_ADDR_EXP 136
108580: PUSH
108581: LD_EXP 136
108585: PPUSH
108586: LD_VAR 0 8
108590: PPUSH
108591: LD_INT 0
108593: PPUSH
108594: CALL_OW 1
108598: ST_TO_ADDR
// exit ;
108599: POP
108600: POP
108601: GO 109134
// end ; x := list [ i ] [ 3 ] ;
108603: LD_ADDR_VAR 0 6
108607: PUSH
108608: LD_VAR 0 3
108612: PUSH
108613: LD_VAR 0 1
108617: ARRAY
108618: PUSH
108619: LD_INT 3
108621: ARRAY
108622: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108623: LD_ADDR_VAR 0 7
108627: PUSH
108628: LD_VAR 0 3
108632: PUSH
108633: LD_VAR 0 1
108637: ARRAY
108638: PUSH
108639: LD_INT 4
108641: ARRAY
108642: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108643: LD_ADDR_VAR 0 9
108647: PUSH
108648: LD_VAR 0 6
108652: PPUSH
108653: LD_VAR 0 7
108657: PPUSH
108658: LD_INT 16
108660: PPUSH
108661: CALL 59876 0 3
108665: ST_TO_ADDR
// if not cratesNearbyPoint then
108666: LD_VAR 0 9
108670: NOT
108671: IFFALSE 108677
// exit ;
108673: POP
108674: POP
108675: GO 109134
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108677: LD_ADDR_VAR 0 4
108681: PUSH
108682: LD_INT 22
108684: PUSH
108685: LD_VAR 0 5
108689: PUSH
108690: EMPTY
108691: LIST
108692: LIST
108693: PUSH
108694: LD_INT 3
108696: PUSH
108697: LD_INT 60
108699: PUSH
108700: EMPTY
108701: LIST
108702: PUSH
108703: EMPTY
108704: LIST
108705: LIST
108706: PUSH
108707: LD_INT 91
108709: PUSH
108710: LD_VAR 0 8
108714: PUSH
108715: LD_INT 6
108717: PUSH
108718: EMPTY
108719: LIST
108720: LIST
108721: LIST
108722: PUSH
108723: LD_INT 2
108725: PUSH
108726: LD_INT 25
108728: PUSH
108729: LD_INT 2
108731: PUSH
108732: EMPTY
108733: LIST
108734: LIST
108735: PUSH
108736: LD_INT 25
108738: PUSH
108739: LD_INT 16
108741: PUSH
108742: EMPTY
108743: LIST
108744: LIST
108745: PUSH
108746: EMPTY
108747: LIST
108748: LIST
108749: LIST
108750: PUSH
108751: EMPTY
108752: LIST
108753: LIST
108754: LIST
108755: LIST
108756: PPUSH
108757: CALL_OW 69
108761: PUSH
108762: LD_VAR 0 8
108766: PPUSH
108767: CALL_OW 313
108771: PPUSH
108772: LD_INT 3
108774: PUSH
108775: LD_INT 60
108777: PUSH
108778: EMPTY
108779: LIST
108780: PUSH
108781: EMPTY
108782: LIST
108783: LIST
108784: PUSH
108785: LD_INT 2
108787: PUSH
108788: LD_INT 25
108790: PUSH
108791: LD_INT 2
108793: PUSH
108794: EMPTY
108795: LIST
108796: LIST
108797: PUSH
108798: LD_INT 25
108800: PUSH
108801: LD_INT 16
108803: PUSH
108804: EMPTY
108805: LIST
108806: LIST
108807: PUSH
108808: EMPTY
108809: LIST
108810: LIST
108811: LIST
108812: PUSH
108813: EMPTY
108814: LIST
108815: LIST
108816: PPUSH
108817: CALL_OW 72
108821: UNION
108822: ST_TO_ADDR
// if tmp then
108823: LD_VAR 0 4
108827: IFFALSE 108907
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108829: LD_ADDR_VAR 0 4
108833: PUSH
108834: LD_VAR 0 4
108838: PPUSH
108839: LD_INT 3
108841: PPUSH
108842: CALL 57845 0 2
108846: ST_TO_ADDR
// for j in tmp do
108847: LD_ADDR_VAR 0 2
108851: PUSH
108852: LD_VAR 0 4
108856: PUSH
108857: FOR_IN
108858: IFFALSE 108901
// begin if IsInUnit ( j ) then
108860: LD_VAR 0 2
108864: PPUSH
108865: CALL_OW 310
108869: IFFALSE 108880
// ComExit ( j ) ;
108871: LD_VAR 0 2
108875: PPUSH
108876: CALL 57928 0 1
// AddComCollect ( j , x , y ) ;
108880: LD_VAR 0 2
108884: PPUSH
108885: LD_VAR 0 6
108889: PPUSH
108890: LD_VAR 0 7
108894: PPUSH
108895: CALL_OW 177
// end ;
108899: GO 108857
108901: POP
108902: POP
// exit ;
108903: POP
108904: POP
108905: GO 109134
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
108907: LD_ADDR_VAR 0 4
108911: PUSH
108912: LD_INT 22
108914: PUSH
108915: LD_VAR 0 5
108919: PUSH
108920: EMPTY
108921: LIST
108922: LIST
108923: PUSH
108924: LD_INT 91
108926: PUSH
108927: LD_VAR 0 8
108931: PUSH
108932: LD_INT 8
108934: PUSH
108935: EMPTY
108936: LIST
108937: LIST
108938: LIST
108939: PUSH
108940: LD_INT 2
108942: PUSH
108943: LD_INT 34
108945: PUSH
108946: LD_INT 12
108948: PUSH
108949: EMPTY
108950: LIST
108951: LIST
108952: PUSH
108953: LD_INT 34
108955: PUSH
108956: LD_INT 51
108958: PUSH
108959: EMPTY
108960: LIST
108961: LIST
108962: PUSH
108963: LD_INT 34
108965: PUSH
108966: LD_INT 32
108968: PUSH
108969: EMPTY
108970: LIST
108971: LIST
108972: PUSH
108973: LD_INT 34
108975: PUSH
108976: LD_INT 89
108978: PUSH
108979: EMPTY
108980: LIST
108981: LIST
108982: PUSH
108983: EMPTY
108984: LIST
108985: LIST
108986: LIST
108987: LIST
108988: LIST
108989: PUSH
108990: EMPTY
108991: LIST
108992: LIST
108993: LIST
108994: PPUSH
108995: CALL_OW 69
108999: ST_TO_ADDR
// if tmp then
109000: LD_VAR 0 4
109004: IFFALSE 109130
// begin for j in tmp do
109006: LD_ADDR_VAR 0 2
109010: PUSH
109011: LD_VAR 0 4
109015: PUSH
109016: FOR_IN
109017: IFFALSE 109128
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109019: LD_VAR 0 2
109023: PPUSH
109024: CALL_OW 262
109028: PUSH
109029: LD_INT 3
109031: EQUAL
109032: PUSH
109033: LD_VAR 0 2
109037: PPUSH
109038: CALL_OW 261
109042: PUSH
109043: LD_INT 20
109045: GREATER
109046: OR
109047: PUSH
109048: LD_VAR 0 2
109052: PPUSH
109053: CALL_OW 314
109057: NOT
109058: AND
109059: PUSH
109060: LD_VAR 0 2
109064: PPUSH
109065: CALL_OW 263
109069: PUSH
109070: LD_INT 1
109072: NONEQUAL
109073: PUSH
109074: LD_VAR 0 2
109078: PPUSH
109079: CALL_OW 311
109083: OR
109084: AND
109085: IFFALSE 109126
// begin ComCollect ( j , x , y ) ;
109087: LD_VAR 0 2
109091: PPUSH
109092: LD_VAR 0 6
109096: PPUSH
109097: LD_VAR 0 7
109101: PPUSH
109102: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109106: LD_VAR 0 2
109110: PPUSH
109111: LD_VAR 0 8
109115: PPUSH
109116: CALL_OW 172
// exit ;
109120: POP
109121: POP
109122: POP
109123: POP
109124: GO 109134
// end ;
109126: GO 109016
109128: POP
109129: POP
// end ; end ;
109130: GO 108505
109132: POP
109133: POP
// end ; end_of_file
109134: PPOPN 9
109136: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
109137: LD_INT 0
109139: PPUSH
109140: PPUSH
109141: PPUSH
109142: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
109143: LD_VAR 0 1
109147: PPUSH
109148: CALL_OW 264
109152: PUSH
109153: LD_INT 91
109155: EQUAL
109156: IFFALSE 109228
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109158: LD_INT 68
109160: PPUSH
109161: LD_VAR 0 1
109165: PPUSH
109166: CALL_OW 255
109170: PPUSH
109171: CALL_OW 321
109175: PUSH
109176: LD_INT 2
109178: EQUAL
109179: IFFALSE 109191
// eff := 70 else
109181: LD_ADDR_VAR 0 4
109185: PUSH
109186: LD_INT 70
109188: ST_TO_ADDR
109189: GO 109199
// eff := 30 ;
109191: LD_ADDR_VAR 0 4
109195: PUSH
109196: LD_INT 30
109198: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109199: LD_VAR 0 1
109203: PPUSH
109204: CALL_OW 250
109208: PPUSH
109209: LD_VAR 0 1
109213: PPUSH
109214: CALL_OW 251
109218: PPUSH
109219: LD_VAR 0 4
109223: PPUSH
109224: CALL_OW 495
// end ; end ;
109228: LD_VAR 0 2
109232: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
109233: LD_INT 0
109235: PPUSH
// end ;
109236: LD_VAR 0 4
109240: RET
// export function SOS_Command ( cmd ) ; begin
109241: LD_INT 0
109243: PPUSH
// end ;
109244: LD_VAR 0 2
109248: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
109249: LD_INT 0
109251: PPUSH
// end ;
109252: LD_VAR 0 6
109256: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
109257: LD_INT 0
109259: PPUSH
109260: PPUSH
// if not vehicle or not factory then
109261: LD_VAR 0 1
109265: NOT
109266: PUSH
109267: LD_VAR 0 2
109271: NOT
109272: OR
109273: IFFALSE 109277
// exit ;
109275: GO 109508
// if factoryWaypoints >= factory then
109277: LD_EXP 135
109281: PUSH
109282: LD_VAR 0 2
109286: GREATEREQUAL
109287: IFFALSE 109508
// if factoryWaypoints [ factory ] then
109289: LD_EXP 135
109293: PUSH
109294: LD_VAR 0 2
109298: ARRAY
109299: IFFALSE 109508
// begin if GetControl ( vehicle ) = control_manual then
109301: LD_VAR 0 1
109305: PPUSH
109306: CALL_OW 263
109310: PUSH
109311: LD_INT 1
109313: EQUAL
109314: IFFALSE 109395
// begin driver := IsDrivenBy ( vehicle ) ;
109316: LD_ADDR_VAR 0 4
109320: PUSH
109321: LD_VAR 0 1
109325: PPUSH
109326: CALL_OW 311
109330: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109331: LD_VAR 0 4
109335: PPUSH
109336: LD_EXP 135
109340: PUSH
109341: LD_VAR 0 2
109345: ARRAY
109346: PUSH
109347: LD_INT 3
109349: ARRAY
109350: PPUSH
109351: LD_EXP 135
109355: PUSH
109356: LD_VAR 0 2
109360: ARRAY
109361: PUSH
109362: LD_INT 4
109364: ARRAY
109365: PPUSH
109366: CALL_OW 171
// AddComExitVehicle ( driver ) ;
109370: LD_VAR 0 4
109374: PPUSH
109375: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
109379: LD_VAR 0 4
109383: PPUSH
109384: LD_VAR 0 2
109388: PPUSH
109389: CALL_OW 180
// end else
109393: GO 109508
// if GetControl ( vehicle ) = control_remote then
109395: LD_VAR 0 1
109399: PPUSH
109400: CALL_OW 263
109404: PUSH
109405: LD_INT 2
109407: EQUAL
109408: IFFALSE 109469
// begin wait ( 0 0$2 ) ;
109410: LD_INT 70
109412: PPUSH
109413: CALL_OW 67
// if Connect ( vehicle ) then
109417: LD_VAR 0 1
109421: PPUSH
109422: CALL 28147 0 1
109426: IFFALSE 109467
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109428: LD_VAR 0 1
109432: PPUSH
109433: LD_EXP 135
109437: PUSH
109438: LD_VAR 0 2
109442: ARRAY
109443: PUSH
109444: LD_INT 3
109446: ARRAY
109447: PPUSH
109448: LD_EXP 135
109452: PUSH
109453: LD_VAR 0 2
109457: ARRAY
109458: PUSH
109459: LD_INT 4
109461: ARRAY
109462: PPUSH
109463: CALL_OW 171
// end else
109467: GO 109508
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109469: LD_VAR 0 1
109473: PPUSH
109474: LD_EXP 135
109478: PUSH
109479: LD_VAR 0 2
109483: ARRAY
109484: PUSH
109485: LD_INT 3
109487: ARRAY
109488: PPUSH
109489: LD_EXP 135
109493: PUSH
109494: LD_VAR 0 2
109498: ARRAY
109499: PUSH
109500: LD_INT 4
109502: ARRAY
109503: PPUSH
109504: CALL_OW 171
// end ; end ;
109508: LD_VAR 0 3
109512: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109513: LD_INT 0
109515: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109516: LD_VAR 0 1
109520: PUSH
109521: LD_INT 250
109523: EQUAL
109524: PUSH
109525: LD_VAR 0 2
109529: PPUSH
109530: CALL_OW 264
109534: PUSH
109535: LD_INT 81
109537: EQUAL
109538: AND
109539: IFFALSE 109560
// MinerPlaceMine ( unit , x , y ) ;
109541: LD_VAR 0 2
109545: PPUSH
109546: LD_VAR 0 4
109550: PPUSH
109551: LD_VAR 0 5
109555: PPUSH
109556: CALL 112550 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109560: LD_VAR 0 1
109564: PUSH
109565: LD_INT 251
109567: EQUAL
109568: PUSH
109569: LD_VAR 0 2
109573: PPUSH
109574: CALL_OW 264
109578: PUSH
109579: LD_INT 81
109581: EQUAL
109582: AND
109583: IFFALSE 109604
// MinerDetonateMine ( unit , x , y ) ;
109585: LD_VAR 0 2
109589: PPUSH
109590: LD_VAR 0 4
109594: PPUSH
109595: LD_VAR 0 5
109599: PPUSH
109600: CALL 112825 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109604: LD_VAR 0 1
109608: PUSH
109609: LD_INT 252
109611: EQUAL
109612: PUSH
109613: LD_VAR 0 2
109617: PPUSH
109618: CALL_OW 264
109622: PUSH
109623: LD_INT 81
109625: EQUAL
109626: AND
109627: IFFALSE 109648
// MinerCreateMinefield ( unit , x , y ) ;
109629: LD_VAR 0 2
109633: PPUSH
109634: LD_VAR 0 4
109638: PPUSH
109639: LD_VAR 0 5
109643: PPUSH
109644: CALL 113242 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109648: LD_VAR 0 1
109652: PUSH
109653: LD_INT 253
109655: EQUAL
109656: PUSH
109657: LD_VAR 0 2
109661: PPUSH
109662: CALL_OW 257
109666: PUSH
109667: LD_INT 5
109669: EQUAL
109670: AND
109671: IFFALSE 109692
// ComBinocular ( unit , x , y ) ;
109673: LD_VAR 0 2
109677: PPUSH
109678: LD_VAR 0 4
109682: PPUSH
109683: LD_VAR 0 5
109687: PPUSH
109688: CALL 113611 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109692: LD_VAR 0 1
109696: PUSH
109697: LD_INT 254
109699: EQUAL
109700: PUSH
109701: LD_VAR 0 2
109705: PPUSH
109706: CALL_OW 264
109710: PUSH
109711: LD_INT 99
109713: EQUAL
109714: AND
109715: PUSH
109716: LD_VAR 0 3
109720: PPUSH
109721: CALL_OW 263
109725: PUSH
109726: LD_INT 3
109728: EQUAL
109729: AND
109730: IFFALSE 109746
// HackDestroyVehicle ( unit , selectedUnit ) ;
109732: LD_VAR 0 2
109736: PPUSH
109737: LD_VAR 0 3
109741: PPUSH
109742: CALL 111914 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109746: LD_VAR 0 1
109750: PUSH
109751: LD_INT 255
109753: EQUAL
109754: PUSH
109755: LD_VAR 0 2
109759: PPUSH
109760: CALL_OW 264
109764: PUSH
109765: LD_INT 14
109767: PUSH
109768: LD_INT 53
109770: PUSH
109771: EMPTY
109772: LIST
109773: LIST
109774: IN
109775: AND
109776: PUSH
109777: LD_VAR 0 4
109781: PPUSH
109782: LD_VAR 0 5
109786: PPUSH
109787: CALL_OW 488
109791: AND
109792: IFFALSE 109816
// CutTreeXYR ( unit , x , y , 12 ) ;
109794: LD_VAR 0 2
109798: PPUSH
109799: LD_VAR 0 4
109803: PPUSH
109804: LD_VAR 0 5
109808: PPUSH
109809: LD_INT 12
109811: PPUSH
109812: CALL 109911 0 4
// if cmd = 256 then
109816: LD_VAR 0 1
109820: PUSH
109821: LD_INT 256
109823: EQUAL
109824: IFFALSE 109845
// SetFactoryWaypoint ( unit , x , y ) ;
109826: LD_VAR 0 2
109830: PPUSH
109831: LD_VAR 0 4
109835: PPUSH
109836: LD_VAR 0 5
109840: PPUSH
109841: CALL 107826 0 3
// if cmd = 257 then
109845: LD_VAR 0 1
109849: PUSH
109850: LD_INT 257
109852: EQUAL
109853: IFFALSE 109874
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109855: LD_VAR 0 2
109859: PPUSH
109860: LD_VAR 0 4
109864: PPUSH
109865: LD_VAR 0 5
109869: PPUSH
109870: CALL 108188 0 3
// if cmd = 258 then
109874: LD_VAR 0 1
109878: PUSH
109879: LD_INT 258
109881: EQUAL
109882: IFFALSE 109906
// BurnTreeXYR ( unit , x , y , 8 ) ;
109884: LD_VAR 0 2
109888: PPUSH
109889: LD_VAR 0 4
109893: PPUSH
109894: LD_VAR 0 5
109898: PPUSH
109899: LD_INT 8
109901: PPUSH
109902: CALL 110305 0 4
// end ;
109906: LD_VAR 0 6
109910: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109911: LD_INT 0
109913: PPUSH
109914: PPUSH
109915: PPUSH
109916: PPUSH
109917: PPUSH
109918: PPUSH
109919: PPUSH
109920: PPUSH
109921: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
109922: LD_VAR 0 1
109926: PPUSH
109927: CALL_OW 302
109931: NOT
109932: PUSH
109933: LD_VAR 0 2
109937: PPUSH
109938: LD_VAR 0 3
109942: PPUSH
109943: CALL_OW 488
109947: NOT
109948: OR
109949: PUSH
109950: LD_VAR 0 4
109954: NOT
109955: OR
109956: IFFALSE 109960
// exit ;
109958: GO 110300
// list := [ ] ;
109960: LD_ADDR_VAR 0 13
109964: PUSH
109965: EMPTY
109966: ST_TO_ADDR
// if x - r < 0 then
109967: LD_VAR 0 2
109971: PUSH
109972: LD_VAR 0 4
109976: MINUS
109977: PUSH
109978: LD_INT 0
109980: LESS
109981: IFFALSE 109993
// min_x := 0 else
109983: LD_ADDR_VAR 0 7
109987: PUSH
109988: LD_INT 0
109990: ST_TO_ADDR
109991: GO 110009
// min_x := x - r ;
109993: LD_ADDR_VAR 0 7
109997: PUSH
109998: LD_VAR 0 2
110002: PUSH
110003: LD_VAR 0 4
110007: MINUS
110008: ST_TO_ADDR
// if y - r < 0 then
110009: LD_VAR 0 3
110013: PUSH
110014: LD_VAR 0 4
110018: MINUS
110019: PUSH
110020: LD_INT 0
110022: LESS
110023: IFFALSE 110035
// min_y := 0 else
110025: LD_ADDR_VAR 0 8
110029: PUSH
110030: LD_INT 0
110032: ST_TO_ADDR
110033: GO 110051
// min_y := y - r ;
110035: LD_ADDR_VAR 0 8
110039: PUSH
110040: LD_VAR 0 3
110044: PUSH
110045: LD_VAR 0 4
110049: MINUS
110050: ST_TO_ADDR
// max_x := x + r ;
110051: LD_ADDR_VAR 0 9
110055: PUSH
110056: LD_VAR 0 2
110060: PUSH
110061: LD_VAR 0 4
110065: PLUS
110066: ST_TO_ADDR
// max_y := y + r ;
110067: LD_ADDR_VAR 0 10
110071: PUSH
110072: LD_VAR 0 3
110076: PUSH
110077: LD_VAR 0 4
110081: PLUS
110082: ST_TO_ADDR
// for _x = min_x to max_x do
110083: LD_ADDR_VAR 0 11
110087: PUSH
110088: DOUBLE
110089: LD_VAR 0 7
110093: DEC
110094: ST_TO_ADDR
110095: LD_VAR 0 9
110099: PUSH
110100: FOR_TO
110101: IFFALSE 110218
// for _y = min_y to max_y do
110103: LD_ADDR_VAR 0 12
110107: PUSH
110108: DOUBLE
110109: LD_VAR 0 8
110113: DEC
110114: ST_TO_ADDR
110115: LD_VAR 0 10
110119: PUSH
110120: FOR_TO
110121: IFFALSE 110214
// begin if not ValidHex ( _x , _y ) then
110123: LD_VAR 0 11
110127: PPUSH
110128: LD_VAR 0 12
110132: PPUSH
110133: CALL_OW 488
110137: NOT
110138: IFFALSE 110142
// continue ;
110140: GO 110120
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110142: LD_VAR 0 11
110146: PPUSH
110147: LD_VAR 0 12
110151: PPUSH
110152: CALL_OW 351
110156: PUSH
110157: LD_VAR 0 11
110161: PPUSH
110162: LD_VAR 0 12
110166: PPUSH
110167: CALL_OW 554
110171: AND
110172: IFFALSE 110212
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110174: LD_ADDR_VAR 0 13
110178: PUSH
110179: LD_VAR 0 13
110183: PPUSH
110184: LD_VAR 0 13
110188: PUSH
110189: LD_INT 1
110191: PLUS
110192: PPUSH
110193: LD_VAR 0 11
110197: PUSH
110198: LD_VAR 0 12
110202: PUSH
110203: EMPTY
110204: LIST
110205: LIST
110206: PPUSH
110207: CALL_OW 2
110211: ST_TO_ADDR
// end ;
110212: GO 110120
110214: POP
110215: POP
110216: GO 110100
110218: POP
110219: POP
// if not list then
110220: LD_VAR 0 13
110224: NOT
110225: IFFALSE 110229
// exit ;
110227: GO 110300
// for i in list do
110229: LD_ADDR_VAR 0 6
110233: PUSH
110234: LD_VAR 0 13
110238: PUSH
110239: FOR_IN
110240: IFFALSE 110298
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
110242: LD_VAR 0 1
110246: PPUSH
110247: LD_STRING M
110249: PUSH
110250: LD_VAR 0 6
110254: PUSH
110255: LD_INT 1
110257: ARRAY
110258: PUSH
110259: LD_VAR 0 6
110263: PUSH
110264: LD_INT 2
110266: ARRAY
110267: PUSH
110268: LD_INT 0
110270: PUSH
110271: LD_INT 0
110273: PUSH
110274: LD_INT 0
110276: PUSH
110277: LD_INT 0
110279: PUSH
110280: EMPTY
110281: LIST
110282: LIST
110283: LIST
110284: LIST
110285: LIST
110286: LIST
110287: LIST
110288: PUSH
110289: EMPTY
110290: LIST
110291: PPUSH
110292: CALL_OW 447
110296: GO 110239
110298: POP
110299: POP
// end ;
110300: LD_VAR 0 5
110304: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
110305: LD_INT 0
110307: PPUSH
110308: PPUSH
110309: PPUSH
110310: PPUSH
110311: PPUSH
110312: PPUSH
110313: PPUSH
110314: PPUSH
110315: PPUSH
110316: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
110317: LD_VAR 0 1
110321: PPUSH
110322: CALL_OW 302
110326: NOT
110327: PUSH
110328: LD_VAR 0 2
110332: PPUSH
110333: LD_VAR 0 3
110337: PPUSH
110338: CALL_OW 488
110342: NOT
110343: OR
110344: PUSH
110345: LD_VAR 0 4
110349: NOT
110350: OR
110351: IFFALSE 110355
// exit ;
110353: GO 110868
// list := [ ] ;
110355: LD_ADDR_VAR 0 13
110359: PUSH
110360: EMPTY
110361: ST_TO_ADDR
// if x - r < 0 then
110362: LD_VAR 0 2
110366: PUSH
110367: LD_VAR 0 4
110371: MINUS
110372: PUSH
110373: LD_INT 0
110375: LESS
110376: IFFALSE 110388
// min_x := 0 else
110378: LD_ADDR_VAR 0 7
110382: PUSH
110383: LD_INT 0
110385: ST_TO_ADDR
110386: GO 110404
// min_x := x - r ;
110388: LD_ADDR_VAR 0 7
110392: PUSH
110393: LD_VAR 0 2
110397: PUSH
110398: LD_VAR 0 4
110402: MINUS
110403: ST_TO_ADDR
// if y - r < 0 then
110404: LD_VAR 0 3
110408: PUSH
110409: LD_VAR 0 4
110413: MINUS
110414: PUSH
110415: LD_INT 0
110417: LESS
110418: IFFALSE 110430
// min_y := 0 else
110420: LD_ADDR_VAR 0 8
110424: PUSH
110425: LD_INT 0
110427: ST_TO_ADDR
110428: GO 110446
// min_y := y - r ;
110430: LD_ADDR_VAR 0 8
110434: PUSH
110435: LD_VAR 0 3
110439: PUSH
110440: LD_VAR 0 4
110444: MINUS
110445: ST_TO_ADDR
// max_x := x + r ;
110446: LD_ADDR_VAR 0 9
110450: PUSH
110451: LD_VAR 0 2
110455: PUSH
110456: LD_VAR 0 4
110460: PLUS
110461: ST_TO_ADDR
// max_y := y + r ;
110462: LD_ADDR_VAR 0 10
110466: PUSH
110467: LD_VAR 0 3
110471: PUSH
110472: LD_VAR 0 4
110476: PLUS
110477: ST_TO_ADDR
// for _x = min_x to max_x do
110478: LD_ADDR_VAR 0 11
110482: PUSH
110483: DOUBLE
110484: LD_VAR 0 7
110488: DEC
110489: ST_TO_ADDR
110490: LD_VAR 0 9
110494: PUSH
110495: FOR_TO
110496: IFFALSE 110613
// for _y = min_y to max_y do
110498: LD_ADDR_VAR 0 12
110502: PUSH
110503: DOUBLE
110504: LD_VAR 0 8
110508: DEC
110509: ST_TO_ADDR
110510: LD_VAR 0 10
110514: PUSH
110515: FOR_TO
110516: IFFALSE 110609
// begin if not ValidHex ( _x , _y ) then
110518: LD_VAR 0 11
110522: PPUSH
110523: LD_VAR 0 12
110527: PPUSH
110528: CALL_OW 488
110532: NOT
110533: IFFALSE 110537
// continue ;
110535: GO 110515
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110537: LD_VAR 0 11
110541: PPUSH
110542: LD_VAR 0 12
110546: PPUSH
110547: CALL_OW 351
110551: PUSH
110552: LD_VAR 0 11
110556: PPUSH
110557: LD_VAR 0 12
110561: PPUSH
110562: CALL_OW 554
110566: AND
110567: IFFALSE 110607
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110569: LD_ADDR_VAR 0 13
110573: PUSH
110574: LD_VAR 0 13
110578: PPUSH
110579: LD_VAR 0 13
110583: PUSH
110584: LD_INT 1
110586: PLUS
110587: PPUSH
110588: LD_VAR 0 11
110592: PUSH
110593: LD_VAR 0 12
110597: PUSH
110598: EMPTY
110599: LIST
110600: LIST
110601: PPUSH
110602: CALL_OW 2
110606: ST_TO_ADDR
// end ;
110607: GO 110515
110609: POP
110610: POP
110611: GO 110495
110613: POP
110614: POP
// if not list then
110615: LD_VAR 0 13
110619: NOT
110620: IFFALSE 110624
// exit ;
110622: GO 110868
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
110624: LD_ADDR_VAR 0 13
110628: PUSH
110629: LD_VAR 0 1
110633: PPUSH
110634: LD_VAR 0 13
110638: PPUSH
110639: LD_INT 1
110641: PPUSH
110642: LD_INT 1
110644: PPUSH
110645: CALL 25289 0 4
110649: ST_TO_ADDR
// ComStop ( flame ) ;
110650: LD_VAR 0 1
110654: PPUSH
110655: CALL_OW 141
// for i in list do
110659: LD_ADDR_VAR 0 6
110663: PUSH
110664: LD_VAR 0 13
110668: PUSH
110669: FOR_IN
110670: IFFALSE 110701
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
110672: LD_VAR 0 1
110676: PPUSH
110677: LD_VAR 0 6
110681: PUSH
110682: LD_INT 1
110684: ARRAY
110685: PPUSH
110686: LD_VAR 0 6
110690: PUSH
110691: LD_INT 2
110693: ARRAY
110694: PPUSH
110695: CALL_OW 176
110699: GO 110669
110701: POP
110702: POP
// repeat wait ( 0 0$1 ) ;
110703: LD_INT 35
110705: PPUSH
110706: CALL_OW 67
// task := GetTaskList ( flame ) ;
110710: LD_ADDR_VAR 0 14
110714: PUSH
110715: LD_VAR 0 1
110719: PPUSH
110720: CALL_OW 437
110724: ST_TO_ADDR
// if not task then
110725: LD_VAR 0 14
110729: NOT
110730: IFFALSE 110734
// exit ;
110732: GO 110868
// if task [ 1 ] [ 1 ] <> | then
110734: LD_VAR 0 14
110738: PUSH
110739: LD_INT 1
110741: ARRAY
110742: PUSH
110743: LD_INT 1
110745: ARRAY
110746: PUSH
110747: LD_STRING |
110749: NONEQUAL
110750: IFFALSE 110754
// exit ;
110752: GO 110868
// _x := task [ 1 ] [ 2 ] ;
110754: LD_ADDR_VAR 0 11
110758: PUSH
110759: LD_VAR 0 14
110763: PUSH
110764: LD_INT 1
110766: ARRAY
110767: PUSH
110768: LD_INT 2
110770: ARRAY
110771: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
110772: LD_ADDR_VAR 0 12
110776: PUSH
110777: LD_VAR 0 14
110781: PUSH
110782: LD_INT 1
110784: ARRAY
110785: PUSH
110786: LD_INT 3
110788: ARRAY
110789: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
110790: LD_VAR 0 11
110794: PPUSH
110795: LD_VAR 0 12
110799: PPUSH
110800: CALL_OW 351
110804: NOT
110805: PUSH
110806: LD_VAR 0 11
110810: PPUSH
110811: LD_VAR 0 12
110815: PPUSH
110816: CALL_OW 554
110820: NOT
110821: OR
110822: IFFALSE 110856
// begin task := Delete ( task , 1 ) ;
110824: LD_ADDR_VAR 0 14
110828: PUSH
110829: LD_VAR 0 14
110833: PPUSH
110834: LD_INT 1
110836: PPUSH
110837: CALL_OW 3
110841: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
110842: LD_VAR 0 1
110846: PPUSH
110847: LD_VAR 0 14
110851: PPUSH
110852: CALL_OW 446
// end ; until not HasTask ( flame ) ;
110856: LD_VAR 0 1
110860: PPUSH
110861: CALL_OW 314
110865: NOT
110866: IFFALSE 110703
// end ;
110868: LD_VAR 0 5
110872: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110873: LD_EXP 138
110877: NOT
110878: IFFALSE 110928
110880: GO 110882
110882: DISABLE
// begin initHack := true ;
110883: LD_ADDR_EXP 138
110887: PUSH
110888: LD_INT 1
110890: ST_TO_ADDR
// hackTanks := [ ] ;
110891: LD_ADDR_EXP 139
110895: PUSH
110896: EMPTY
110897: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110898: LD_ADDR_EXP 140
110902: PUSH
110903: EMPTY
110904: ST_TO_ADDR
// hackLimit := 3 ;
110905: LD_ADDR_EXP 141
110909: PUSH
110910: LD_INT 3
110912: ST_TO_ADDR
// hackDist := 12 ;
110913: LD_ADDR_EXP 142
110917: PUSH
110918: LD_INT 12
110920: ST_TO_ADDR
// hackCounter := [ ] ;
110921: LD_ADDR_EXP 143
110925: PUSH
110926: EMPTY
110927: ST_TO_ADDR
// end ;
110928: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110929: LD_EXP 138
110933: PUSH
110934: LD_INT 34
110936: PUSH
110937: LD_INT 99
110939: PUSH
110940: EMPTY
110941: LIST
110942: LIST
110943: PPUSH
110944: CALL_OW 69
110948: AND
110949: IFFALSE 111202
110951: GO 110953
110953: DISABLE
110954: LD_INT 0
110956: PPUSH
110957: PPUSH
// begin enable ;
110958: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110959: LD_ADDR_VAR 0 1
110963: PUSH
110964: LD_INT 34
110966: PUSH
110967: LD_INT 99
110969: PUSH
110970: EMPTY
110971: LIST
110972: LIST
110973: PPUSH
110974: CALL_OW 69
110978: PUSH
110979: FOR_IN
110980: IFFALSE 111200
// begin if not i in hackTanks then
110982: LD_VAR 0 1
110986: PUSH
110987: LD_EXP 139
110991: IN
110992: NOT
110993: IFFALSE 111076
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110995: LD_ADDR_EXP 139
110999: PUSH
111000: LD_EXP 139
111004: PPUSH
111005: LD_EXP 139
111009: PUSH
111010: LD_INT 1
111012: PLUS
111013: PPUSH
111014: LD_VAR 0 1
111018: PPUSH
111019: CALL_OW 1
111023: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
111024: LD_ADDR_EXP 140
111028: PUSH
111029: LD_EXP 140
111033: PPUSH
111034: LD_EXP 140
111038: PUSH
111039: LD_INT 1
111041: PLUS
111042: PPUSH
111043: EMPTY
111044: PPUSH
111045: CALL_OW 1
111049: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
111050: LD_ADDR_EXP 143
111054: PUSH
111055: LD_EXP 143
111059: PPUSH
111060: LD_EXP 143
111064: PUSH
111065: LD_INT 1
111067: PLUS
111068: PPUSH
111069: EMPTY
111070: PPUSH
111071: CALL_OW 1
111075: ST_TO_ADDR
// end ; if not IsOk ( i ) then
111076: LD_VAR 0 1
111080: PPUSH
111081: CALL_OW 302
111085: NOT
111086: IFFALSE 111099
// begin HackUnlinkAll ( i ) ;
111088: LD_VAR 0 1
111092: PPUSH
111093: CALL 111205 0 1
// continue ;
111097: GO 110979
// end ; HackCheckCapturedStatus ( i ) ;
111099: LD_VAR 0 1
111103: PPUSH
111104: CALL 111648 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
111108: LD_ADDR_VAR 0 2
111112: PUSH
111113: LD_INT 81
111115: PUSH
111116: LD_VAR 0 1
111120: PPUSH
111121: CALL_OW 255
111125: PUSH
111126: EMPTY
111127: LIST
111128: LIST
111129: PUSH
111130: LD_INT 33
111132: PUSH
111133: LD_INT 3
111135: PUSH
111136: EMPTY
111137: LIST
111138: LIST
111139: PUSH
111140: LD_INT 91
111142: PUSH
111143: LD_VAR 0 1
111147: PUSH
111148: LD_EXP 142
111152: PUSH
111153: EMPTY
111154: LIST
111155: LIST
111156: LIST
111157: PUSH
111158: LD_INT 50
111160: PUSH
111161: EMPTY
111162: LIST
111163: PUSH
111164: EMPTY
111165: LIST
111166: LIST
111167: LIST
111168: LIST
111169: PPUSH
111170: CALL_OW 69
111174: ST_TO_ADDR
// if not tmp then
111175: LD_VAR 0 2
111179: NOT
111180: IFFALSE 111184
// continue ;
111182: GO 110979
// HackLink ( i , tmp ) ;
111184: LD_VAR 0 1
111188: PPUSH
111189: LD_VAR 0 2
111193: PPUSH
111194: CALL 111341 0 2
// end ;
111198: GO 110979
111200: POP
111201: POP
// end ;
111202: PPOPN 2
111204: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
111205: LD_INT 0
111207: PPUSH
111208: PPUSH
111209: PPUSH
// if not hack in hackTanks then
111210: LD_VAR 0 1
111214: PUSH
111215: LD_EXP 139
111219: IN
111220: NOT
111221: IFFALSE 111225
// exit ;
111223: GO 111336
// index := GetElementIndex ( hackTanks , hack ) ;
111225: LD_ADDR_VAR 0 4
111229: PUSH
111230: LD_EXP 139
111234: PPUSH
111235: LD_VAR 0 1
111239: PPUSH
111240: CALL 24586 0 2
111244: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
111245: LD_EXP 140
111249: PUSH
111250: LD_VAR 0 4
111254: ARRAY
111255: IFFALSE 111336
// begin for i in hackTanksCaptured [ index ] do
111257: LD_ADDR_VAR 0 3
111261: PUSH
111262: LD_EXP 140
111266: PUSH
111267: LD_VAR 0 4
111271: ARRAY
111272: PUSH
111273: FOR_IN
111274: IFFALSE 111300
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
111276: LD_VAR 0 3
111280: PUSH
111281: LD_INT 1
111283: ARRAY
111284: PPUSH
111285: LD_VAR 0 3
111289: PUSH
111290: LD_INT 2
111292: ARRAY
111293: PPUSH
111294: CALL_OW 235
111298: GO 111273
111300: POP
111301: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
111302: LD_ADDR_EXP 140
111306: PUSH
111307: LD_EXP 140
111311: PPUSH
111312: LD_VAR 0 4
111316: PPUSH
111317: EMPTY
111318: PPUSH
111319: CALL_OW 1
111323: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
111324: LD_VAR 0 1
111328: PPUSH
111329: LD_INT 0
111331: PPUSH
111332: CALL_OW 505
// end ; end ;
111336: LD_VAR 0 2
111340: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
111341: LD_INT 0
111343: PPUSH
111344: PPUSH
111345: PPUSH
// if not hack in hackTanks or not vehicles then
111346: LD_VAR 0 1
111350: PUSH
111351: LD_EXP 139
111355: IN
111356: NOT
111357: PUSH
111358: LD_VAR 0 2
111362: NOT
111363: OR
111364: IFFALSE 111368
// exit ;
111366: GO 111643
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
111368: LD_ADDR_VAR 0 2
111372: PUSH
111373: LD_VAR 0 1
111377: PPUSH
111378: LD_VAR 0 2
111382: PPUSH
111383: LD_INT 1
111385: PPUSH
111386: LD_INT 1
111388: PPUSH
111389: CALL 25236 0 4
111393: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
111394: LD_ADDR_VAR 0 5
111398: PUSH
111399: LD_EXP 139
111403: PPUSH
111404: LD_VAR 0 1
111408: PPUSH
111409: CALL 24586 0 2
111413: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
111414: LD_EXP 140
111418: PUSH
111419: LD_VAR 0 5
111423: ARRAY
111424: PUSH
111425: LD_EXP 141
111429: LESS
111430: IFFALSE 111619
// begin for i := 1 to vehicles do
111432: LD_ADDR_VAR 0 4
111436: PUSH
111437: DOUBLE
111438: LD_INT 1
111440: DEC
111441: ST_TO_ADDR
111442: LD_VAR 0 2
111446: PUSH
111447: FOR_TO
111448: IFFALSE 111617
// begin if hackTanksCaptured [ index ] = hackLimit then
111450: LD_EXP 140
111454: PUSH
111455: LD_VAR 0 5
111459: ARRAY
111460: PUSH
111461: LD_EXP 141
111465: EQUAL
111466: IFFALSE 111470
// break ;
111468: GO 111617
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111470: LD_ADDR_EXP 143
111474: PUSH
111475: LD_EXP 143
111479: PPUSH
111480: LD_VAR 0 5
111484: PPUSH
111485: LD_EXP 143
111489: PUSH
111490: LD_VAR 0 5
111494: ARRAY
111495: PUSH
111496: LD_INT 1
111498: PLUS
111499: PPUSH
111500: CALL_OW 1
111504: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111505: LD_ADDR_EXP 140
111509: PUSH
111510: LD_EXP 140
111514: PPUSH
111515: LD_VAR 0 5
111519: PUSH
111520: LD_EXP 140
111524: PUSH
111525: LD_VAR 0 5
111529: ARRAY
111530: PUSH
111531: LD_INT 1
111533: PLUS
111534: PUSH
111535: EMPTY
111536: LIST
111537: LIST
111538: PPUSH
111539: LD_VAR 0 2
111543: PUSH
111544: LD_VAR 0 4
111548: ARRAY
111549: PUSH
111550: LD_VAR 0 2
111554: PUSH
111555: LD_VAR 0 4
111559: ARRAY
111560: PPUSH
111561: CALL_OW 255
111565: PUSH
111566: EMPTY
111567: LIST
111568: LIST
111569: PPUSH
111570: CALL 24801 0 3
111574: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
111575: LD_VAR 0 2
111579: PUSH
111580: LD_VAR 0 4
111584: ARRAY
111585: PPUSH
111586: LD_VAR 0 1
111590: PPUSH
111591: CALL_OW 255
111595: PPUSH
111596: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
111600: LD_VAR 0 2
111604: PUSH
111605: LD_VAR 0 4
111609: ARRAY
111610: PPUSH
111611: CALL_OW 141
// end ;
111615: GO 111447
111617: POP
111618: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111619: LD_VAR 0 1
111623: PPUSH
111624: LD_EXP 140
111628: PUSH
111629: LD_VAR 0 5
111633: ARRAY
111634: PUSH
111635: LD_INT 0
111637: PLUS
111638: PPUSH
111639: CALL_OW 505
// end ;
111643: LD_VAR 0 3
111647: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
111648: LD_INT 0
111650: PPUSH
111651: PPUSH
111652: PPUSH
111653: PPUSH
// if not hack in hackTanks then
111654: LD_VAR 0 1
111658: PUSH
111659: LD_EXP 139
111663: IN
111664: NOT
111665: IFFALSE 111669
// exit ;
111667: GO 111909
// index := GetElementIndex ( hackTanks , hack ) ;
111669: LD_ADDR_VAR 0 4
111673: PUSH
111674: LD_EXP 139
111678: PPUSH
111679: LD_VAR 0 1
111683: PPUSH
111684: CALL 24586 0 2
111688: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111689: LD_ADDR_VAR 0 3
111693: PUSH
111694: DOUBLE
111695: LD_EXP 140
111699: PUSH
111700: LD_VAR 0 4
111704: ARRAY
111705: INC
111706: ST_TO_ADDR
111707: LD_INT 1
111709: PUSH
111710: FOR_DOWNTO
111711: IFFALSE 111883
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111713: LD_ADDR_VAR 0 5
111717: PUSH
111718: LD_EXP 140
111722: PUSH
111723: LD_VAR 0 4
111727: ARRAY
111728: PUSH
111729: LD_VAR 0 3
111733: ARRAY
111734: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111735: LD_VAR 0 5
111739: PUSH
111740: LD_INT 1
111742: ARRAY
111743: PPUSH
111744: CALL_OW 302
111748: NOT
111749: PUSH
111750: LD_VAR 0 5
111754: PUSH
111755: LD_INT 1
111757: ARRAY
111758: PPUSH
111759: CALL_OW 255
111763: PUSH
111764: LD_VAR 0 1
111768: PPUSH
111769: CALL_OW 255
111773: NONEQUAL
111774: OR
111775: IFFALSE 111881
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111777: LD_VAR 0 5
111781: PUSH
111782: LD_INT 1
111784: ARRAY
111785: PPUSH
111786: CALL_OW 305
111790: PUSH
111791: LD_VAR 0 5
111795: PUSH
111796: LD_INT 1
111798: ARRAY
111799: PPUSH
111800: CALL_OW 255
111804: PUSH
111805: LD_VAR 0 1
111809: PPUSH
111810: CALL_OW 255
111814: EQUAL
111815: AND
111816: IFFALSE 111840
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111818: LD_VAR 0 5
111822: PUSH
111823: LD_INT 1
111825: ARRAY
111826: PPUSH
111827: LD_VAR 0 5
111831: PUSH
111832: LD_INT 2
111834: ARRAY
111835: PPUSH
111836: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111840: LD_ADDR_EXP 140
111844: PUSH
111845: LD_EXP 140
111849: PPUSH
111850: LD_VAR 0 4
111854: PPUSH
111855: LD_EXP 140
111859: PUSH
111860: LD_VAR 0 4
111864: ARRAY
111865: PPUSH
111866: LD_VAR 0 3
111870: PPUSH
111871: CALL_OW 3
111875: PPUSH
111876: CALL_OW 1
111880: ST_TO_ADDR
// end ; end ;
111881: GO 111710
111883: POP
111884: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111885: LD_VAR 0 1
111889: PPUSH
111890: LD_EXP 140
111894: PUSH
111895: LD_VAR 0 4
111899: ARRAY
111900: PUSH
111901: LD_INT 0
111903: PLUS
111904: PPUSH
111905: CALL_OW 505
// end ;
111909: LD_VAR 0 2
111913: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111914: LD_INT 0
111916: PPUSH
111917: PPUSH
111918: PPUSH
111919: PPUSH
// if not hack in hackTanks then
111920: LD_VAR 0 1
111924: PUSH
111925: LD_EXP 139
111929: IN
111930: NOT
111931: IFFALSE 111935
// exit ;
111933: GO 112020
// index := GetElementIndex ( hackTanks , hack ) ;
111935: LD_ADDR_VAR 0 5
111939: PUSH
111940: LD_EXP 139
111944: PPUSH
111945: LD_VAR 0 1
111949: PPUSH
111950: CALL 24586 0 2
111954: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111955: LD_ADDR_VAR 0 4
111959: PUSH
111960: DOUBLE
111961: LD_INT 1
111963: DEC
111964: ST_TO_ADDR
111965: LD_EXP 140
111969: PUSH
111970: LD_VAR 0 5
111974: ARRAY
111975: PUSH
111976: FOR_TO
111977: IFFALSE 112018
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111979: LD_EXP 140
111983: PUSH
111984: LD_VAR 0 5
111988: ARRAY
111989: PUSH
111990: LD_VAR 0 4
111994: ARRAY
111995: PUSH
111996: LD_INT 1
111998: ARRAY
111999: PUSH
112000: LD_VAR 0 2
112004: EQUAL
112005: IFFALSE 112016
// KillUnit ( vehicle ) ;
112007: LD_VAR 0 2
112011: PPUSH
112012: CALL_OW 66
112016: GO 111976
112018: POP
112019: POP
// end ;
112020: LD_VAR 0 3
112024: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
112025: LD_EXP 144
112029: NOT
112030: IFFALSE 112065
112032: GO 112034
112034: DISABLE
// begin initMiner := true ;
112035: LD_ADDR_EXP 144
112039: PUSH
112040: LD_INT 1
112042: ST_TO_ADDR
// minersList := [ ] ;
112043: LD_ADDR_EXP 145
112047: PUSH
112048: EMPTY
112049: ST_TO_ADDR
// minerMinesList := [ ] ;
112050: LD_ADDR_EXP 146
112054: PUSH
112055: EMPTY
112056: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
112057: LD_ADDR_EXP 147
112061: PUSH
112062: LD_INT 5
112064: ST_TO_ADDR
// end ;
112065: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
112066: LD_EXP 144
112070: PUSH
112071: LD_INT 34
112073: PUSH
112074: LD_INT 81
112076: PUSH
112077: EMPTY
112078: LIST
112079: LIST
112080: PPUSH
112081: CALL_OW 69
112085: AND
112086: IFFALSE 112547
112088: GO 112090
112090: DISABLE
112091: LD_INT 0
112093: PPUSH
112094: PPUSH
112095: PPUSH
112096: PPUSH
// begin enable ;
112097: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
112098: LD_ADDR_VAR 0 1
112102: PUSH
112103: LD_INT 34
112105: PUSH
112106: LD_INT 81
112108: PUSH
112109: EMPTY
112110: LIST
112111: LIST
112112: PPUSH
112113: CALL_OW 69
112117: PUSH
112118: FOR_IN
112119: IFFALSE 112191
// begin if not i in minersList then
112121: LD_VAR 0 1
112125: PUSH
112126: LD_EXP 145
112130: IN
112131: NOT
112132: IFFALSE 112189
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
112134: LD_ADDR_EXP 145
112138: PUSH
112139: LD_EXP 145
112143: PPUSH
112144: LD_EXP 145
112148: PUSH
112149: LD_INT 1
112151: PLUS
112152: PPUSH
112153: LD_VAR 0 1
112157: PPUSH
112158: CALL_OW 1
112162: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
112163: LD_ADDR_EXP 146
112167: PUSH
112168: LD_EXP 146
112172: PPUSH
112173: LD_EXP 146
112177: PUSH
112178: LD_INT 1
112180: PLUS
112181: PPUSH
112182: EMPTY
112183: PPUSH
112184: CALL_OW 1
112188: ST_TO_ADDR
// end end ;
112189: GO 112118
112191: POP
112192: POP
// for i := minerMinesList downto 1 do
112193: LD_ADDR_VAR 0 1
112197: PUSH
112198: DOUBLE
112199: LD_EXP 146
112203: INC
112204: ST_TO_ADDR
112205: LD_INT 1
112207: PUSH
112208: FOR_DOWNTO
112209: IFFALSE 112545
// begin if IsLive ( minersList [ i ] ) then
112211: LD_EXP 145
112215: PUSH
112216: LD_VAR 0 1
112220: ARRAY
112221: PPUSH
112222: CALL_OW 300
112226: IFFALSE 112254
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
112228: LD_EXP 145
112232: PUSH
112233: LD_VAR 0 1
112237: ARRAY
112238: PPUSH
112239: LD_EXP 146
112243: PUSH
112244: LD_VAR 0 1
112248: ARRAY
112249: PPUSH
112250: CALL_OW 505
// if not minerMinesList [ i ] then
112254: LD_EXP 146
112258: PUSH
112259: LD_VAR 0 1
112263: ARRAY
112264: NOT
112265: IFFALSE 112269
// continue ;
112267: GO 112208
// for j := minerMinesList [ i ] downto 1 do
112269: LD_ADDR_VAR 0 2
112273: PUSH
112274: DOUBLE
112275: LD_EXP 146
112279: PUSH
112280: LD_VAR 0 1
112284: ARRAY
112285: INC
112286: ST_TO_ADDR
112287: LD_INT 1
112289: PUSH
112290: FOR_DOWNTO
112291: IFFALSE 112541
// begin side := GetSide ( minersList [ i ] ) ;
112293: LD_ADDR_VAR 0 3
112297: PUSH
112298: LD_EXP 145
112302: PUSH
112303: LD_VAR 0 1
112307: ARRAY
112308: PPUSH
112309: CALL_OW 255
112313: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
112314: LD_ADDR_VAR 0 4
112318: PUSH
112319: LD_EXP 146
112323: PUSH
112324: LD_VAR 0 1
112328: ARRAY
112329: PUSH
112330: LD_VAR 0 2
112334: ARRAY
112335: PUSH
112336: LD_INT 1
112338: ARRAY
112339: PPUSH
112340: LD_EXP 146
112344: PUSH
112345: LD_VAR 0 1
112349: ARRAY
112350: PUSH
112351: LD_VAR 0 2
112355: ARRAY
112356: PUSH
112357: LD_INT 2
112359: ARRAY
112360: PPUSH
112361: CALL_OW 428
112365: ST_TO_ADDR
// if not tmp then
112366: LD_VAR 0 4
112370: NOT
112371: IFFALSE 112375
// continue ;
112373: GO 112290
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
112375: LD_VAR 0 4
112379: PUSH
112380: LD_INT 81
112382: PUSH
112383: LD_VAR 0 3
112387: PUSH
112388: EMPTY
112389: LIST
112390: LIST
112391: PPUSH
112392: CALL_OW 69
112396: IN
112397: PUSH
112398: LD_EXP 146
112402: PUSH
112403: LD_VAR 0 1
112407: ARRAY
112408: PUSH
112409: LD_VAR 0 2
112413: ARRAY
112414: PUSH
112415: LD_INT 1
112417: ARRAY
112418: PPUSH
112419: LD_EXP 146
112423: PUSH
112424: LD_VAR 0 1
112428: ARRAY
112429: PUSH
112430: LD_VAR 0 2
112434: ARRAY
112435: PUSH
112436: LD_INT 2
112438: ARRAY
112439: PPUSH
112440: CALL_OW 458
112444: AND
112445: IFFALSE 112539
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
112447: LD_EXP 146
112451: PUSH
112452: LD_VAR 0 1
112456: ARRAY
112457: PUSH
112458: LD_VAR 0 2
112462: ARRAY
112463: PUSH
112464: LD_INT 1
112466: ARRAY
112467: PPUSH
112468: LD_EXP 146
112472: PUSH
112473: LD_VAR 0 1
112477: ARRAY
112478: PUSH
112479: LD_VAR 0 2
112483: ARRAY
112484: PUSH
112485: LD_INT 2
112487: ARRAY
112488: PPUSH
112489: LD_VAR 0 3
112493: PPUSH
112494: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112498: LD_ADDR_EXP 146
112502: PUSH
112503: LD_EXP 146
112507: PPUSH
112508: LD_VAR 0 1
112512: PPUSH
112513: LD_EXP 146
112517: PUSH
112518: LD_VAR 0 1
112522: ARRAY
112523: PPUSH
112524: LD_VAR 0 2
112528: PPUSH
112529: CALL_OW 3
112533: PPUSH
112534: CALL_OW 1
112538: ST_TO_ADDR
// end ; end ;
112539: GO 112290
112541: POP
112542: POP
// end ;
112543: GO 112208
112545: POP
112546: POP
// end ;
112547: PPOPN 4
112549: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
112550: LD_INT 0
112552: PPUSH
112553: PPUSH
// result := false ;
112554: LD_ADDR_VAR 0 4
112558: PUSH
112559: LD_INT 0
112561: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
112562: LD_VAR 0 1
112566: PPUSH
112567: CALL_OW 264
112571: PUSH
112572: LD_INT 81
112574: EQUAL
112575: NOT
112576: IFFALSE 112580
// exit ;
112578: GO 112820
// index := GetElementIndex ( minersList , unit ) ;
112580: LD_ADDR_VAR 0 5
112584: PUSH
112585: LD_EXP 145
112589: PPUSH
112590: LD_VAR 0 1
112594: PPUSH
112595: CALL 24586 0 2
112599: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
112600: LD_EXP 146
112604: PUSH
112605: LD_VAR 0 5
112609: ARRAY
112610: PUSH
112611: LD_EXP 147
112615: GREATEREQUAL
112616: IFFALSE 112620
// exit ;
112618: GO 112820
// ComMoveXY ( unit , x , y ) ;
112620: LD_VAR 0 1
112624: PPUSH
112625: LD_VAR 0 2
112629: PPUSH
112630: LD_VAR 0 3
112634: PPUSH
112635: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112639: LD_INT 35
112641: PPUSH
112642: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
112646: LD_VAR 0 1
112650: PPUSH
112651: LD_VAR 0 2
112655: PPUSH
112656: LD_VAR 0 3
112660: PPUSH
112661: CALL 56327 0 3
112665: NOT
112666: PUSH
112667: LD_VAR 0 1
112671: PPUSH
112672: CALL_OW 314
112676: AND
112677: IFFALSE 112681
// exit ;
112679: GO 112820
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112681: LD_VAR 0 2
112685: PPUSH
112686: LD_VAR 0 3
112690: PPUSH
112691: CALL_OW 428
112695: PUSH
112696: LD_VAR 0 1
112700: EQUAL
112701: PUSH
112702: LD_VAR 0 1
112706: PPUSH
112707: CALL_OW 314
112711: NOT
112712: AND
112713: IFFALSE 112639
// PlaySoundXY ( x , y , PlantMine ) ;
112715: LD_VAR 0 2
112719: PPUSH
112720: LD_VAR 0 3
112724: PPUSH
112725: LD_STRING PlantMine
112727: PPUSH
112728: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
112732: LD_VAR 0 2
112736: PPUSH
112737: LD_VAR 0 3
112741: PPUSH
112742: LD_VAR 0 1
112746: PPUSH
112747: CALL_OW 255
112751: PPUSH
112752: LD_INT 0
112754: PPUSH
112755: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112759: LD_ADDR_EXP 146
112763: PUSH
112764: LD_EXP 146
112768: PPUSH
112769: LD_VAR 0 5
112773: PUSH
112774: LD_EXP 146
112778: PUSH
112779: LD_VAR 0 5
112783: ARRAY
112784: PUSH
112785: LD_INT 1
112787: PLUS
112788: PUSH
112789: EMPTY
112790: LIST
112791: LIST
112792: PPUSH
112793: LD_VAR 0 2
112797: PUSH
112798: LD_VAR 0 3
112802: PUSH
112803: EMPTY
112804: LIST
112805: LIST
112806: PPUSH
112807: CALL 24801 0 3
112811: ST_TO_ADDR
// result := true ;
112812: LD_ADDR_VAR 0 4
112816: PUSH
112817: LD_INT 1
112819: ST_TO_ADDR
// end ;
112820: LD_VAR 0 4
112824: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112825: LD_INT 0
112827: PPUSH
112828: PPUSH
112829: PPUSH
// if not unit in minersList then
112830: LD_VAR 0 1
112834: PUSH
112835: LD_EXP 145
112839: IN
112840: NOT
112841: IFFALSE 112845
// exit ;
112843: GO 113237
// index := GetElementIndex ( minersList , unit ) ;
112845: LD_ADDR_VAR 0 6
112849: PUSH
112850: LD_EXP 145
112854: PPUSH
112855: LD_VAR 0 1
112859: PPUSH
112860: CALL 24586 0 2
112864: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112865: LD_ADDR_VAR 0 5
112869: PUSH
112870: DOUBLE
112871: LD_EXP 146
112875: PUSH
112876: LD_VAR 0 6
112880: ARRAY
112881: INC
112882: ST_TO_ADDR
112883: LD_INT 1
112885: PUSH
112886: FOR_DOWNTO
112887: IFFALSE 113048
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112889: LD_EXP 146
112893: PUSH
112894: LD_VAR 0 6
112898: ARRAY
112899: PUSH
112900: LD_VAR 0 5
112904: ARRAY
112905: PUSH
112906: LD_INT 1
112908: ARRAY
112909: PUSH
112910: LD_VAR 0 2
112914: EQUAL
112915: PUSH
112916: LD_EXP 146
112920: PUSH
112921: LD_VAR 0 6
112925: ARRAY
112926: PUSH
112927: LD_VAR 0 5
112931: ARRAY
112932: PUSH
112933: LD_INT 2
112935: ARRAY
112936: PUSH
112937: LD_VAR 0 3
112941: EQUAL
112942: AND
112943: IFFALSE 113046
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112945: LD_EXP 146
112949: PUSH
112950: LD_VAR 0 6
112954: ARRAY
112955: PUSH
112956: LD_VAR 0 5
112960: ARRAY
112961: PUSH
112962: LD_INT 1
112964: ARRAY
112965: PPUSH
112966: LD_EXP 146
112970: PUSH
112971: LD_VAR 0 6
112975: ARRAY
112976: PUSH
112977: LD_VAR 0 5
112981: ARRAY
112982: PUSH
112983: LD_INT 2
112985: ARRAY
112986: PPUSH
112987: LD_VAR 0 1
112991: PPUSH
112992: CALL_OW 255
112996: PPUSH
112997: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113001: LD_ADDR_EXP 146
113005: PUSH
113006: LD_EXP 146
113010: PPUSH
113011: LD_VAR 0 6
113015: PPUSH
113016: LD_EXP 146
113020: PUSH
113021: LD_VAR 0 6
113025: ARRAY
113026: PPUSH
113027: LD_VAR 0 5
113031: PPUSH
113032: CALL_OW 3
113036: PPUSH
113037: CALL_OW 1
113041: ST_TO_ADDR
// exit ;
113042: POP
113043: POP
113044: GO 113237
// end ; end ;
113046: GO 112886
113048: POP
113049: POP
// for i := minerMinesList [ index ] downto 1 do
113050: LD_ADDR_VAR 0 5
113054: PUSH
113055: DOUBLE
113056: LD_EXP 146
113060: PUSH
113061: LD_VAR 0 6
113065: ARRAY
113066: INC
113067: ST_TO_ADDR
113068: LD_INT 1
113070: PUSH
113071: FOR_DOWNTO
113072: IFFALSE 113235
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
113074: LD_EXP 146
113078: PUSH
113079: LD_VAR 0 6
113083: ARRAY
113084: PUSH
113085: LD_VAR 0 5
113089: ARRAY
113090: PUSH
113091: LD_INT 1
113093: ARRAY
113094: PPUSH
113095: LD_EXP 146
113099: PUSH
113100: LD_VAR 0 6
113104: ARRAY
113105: PUSH
113106: LD_VAR 0 5
113110: ARRAY
113111: PUSH
113112: LD_INT 2
113114: ARRAY
113115: PPUSH
113116: LD_VAR 0 2
113120: PPUSH
113121: LD_VAR 0 3
113125: PPUSH
113126: CALL_OW 298
113130: PUSH
113131: LD_INT 6
113133: LESS
113134: IFFALSE 113233
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113136: LD_EXP 146
113140: PUSH
113141: LD_VAR 0 6
113145: ARRAY
113146: PUSH
113147: LD_VAR 0 5
113151: ARRAY
113152: PUSH
113153: LD_INT 1
113155: ARRAY
113156: PPUSH
113157: LD_EXP 146
113161: PUSH
113162: LD_VAR 0 6
113166: ARRAY
113167: PUSH
113168: LD_VAR 0 5
113172: ARRAY
113173: PUSH
113174: LD_INT 2
113176: ARRAY
113177: PPUSH
113178: LD_VAR 0 1
113182: PPUSH
113183: CALL_OW 255
113187: PPUSH
113188: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113192: LD_ADDR_EXP 146
113196: PUSH
113197: LD_EXP 146
113201: PPUSH
113202: LD_VAR 0 6
113206: PPUSH
113207: LD_EXP 146
113211: PUSH
113212: LD_VAR 0 6
113216: ARRAY
113217: PPUSH
113218: LD_VAR 0 5
113222: PPUSH
113223: CALL_OW 3
113227: PPUSH
113228: CALL_OW 1
113232: ST_TO_ADDR
// end ; end ;
113233: GO 113071
113235: POP
113236: POP
// end ;
113237: LD_VAR 0 4
113241: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
113242: LD_INT 0
113244: PPUSH
113245: PPUSH
113246: PPUSH
113247: PPUSH
113248: PPUSH
113249: PPUSH
113250: PPUSH
113251: PPUSH
113252: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
113253: LD_VAR 0 1
113257: PPUSH
113258: CALL_OW 264
113262: PUSH
113263: LD_INT 81
113265: EQUAL
113266: NOT
113267: PUSH
113268: LD_VAR 0 1
113272: PUSH
113273: LD_EXP 145
113277: IN
113278: NOT
113279: OR
113280: IFFALSE 113284
// exit ;
113282: GO 113606
// index := GetElementIndex ( minersList , unit ) ;
113284: LD_ADDR_VAR 0 6
113288: PUSH
113289: LD_EXP 145
113293: PPUSH
113294: LD_VAR 0 1
113298: PPUSH
113299: CALL 24586 0 2
113303: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
113304: LD_ADDR_VAR 0 8
113308: PUSH
113309: LD_EXP 147
113313: PUSH
113314: LD_EXP 146
113318: PUSH
113319: LD_VAR 0 6
113323: ARRAY
113324: MINUS
113325: ST_TO_ADDR
// if not minesFreeAmount then
113326: LD_VAR 0 8
113330: NOT
113331: IFFALSE 113335
// exit ;
113333: GO 113606
// tmp := [ ] ;
113335: LD_ADDR_VAR 0 7
113339: PUSH
113340: EMPTY
113341: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
113342: LD_ADDR_VAR 0 5
113346: PUSH
113347: DOUBLE
113348: LD_INT 1
113350: DEC
113351: ST_TO_ADDR
113352: LD_VAR 0 8
113356: PUSH
113357: FOR_TO
113358: IFFALSE 113553
// begin _d := rand ( 0 , 5 ) ;
113360: LD_ADDR_VAR 0 11
113364: PUSH
113365: LD_INT 0
113367: PPUSH
113368: LD_INT 5
113370: PPUSH
113371: CALL_OW 12
113375: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
113376: LD_ADDR_VAR 0 12
113380: PUSH
113381: LD_INT 2
113383: PPUSH
113384: LD_INT 6
113386: PPUSH
113387: CALL_OW 12
113391: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
113392: LD_ADDR_VAR 0 9
113396: PUSH
113397: LD_VAR 0 2
113401: PPUSH
113402: LD_VAR 0 11
113406: PPUSH
113407: LD_VAR 0 12
113411: PPUSH
113412: CALL_OW 272
113416: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
113417: LD_ADDR_VAR 0 10
113421: PUSH
113422: LD_VAR 0 3
113426: PPUSH
113427: LD_VAR 0 11
113431: PPUSH
113432: LD_VAR 0 12
113436: PPUSH
113437: CALL_OW 273
113441: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
113442: LD_VAR 0 9
113446: PPUSH
113447: LD_VAR 0 10
113451: PPUSH
113452: CALL_OW 488
113456: PUSH
113457: LD_VAR 0 9
113461: PUSH
113462: LD_VAR 0 10
113466: PUSH
113467: EMPTY
113468: LIST
113469: LIST
113470: PUSH
113471: LD_VAR 0 7
113475: IN
113476: NOT
113477: AND
113478: PUSH
113479: LD_VAR 0 9
113483: PPUSH
113484: LD_VAR 0 10
113488: PPUSH
113489: CALL_OW 458
113493: NOT
113494: AND
113495: IFFALSE 113537
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113497: LD_ADDR_VAR 0 7
113501: PUSH
113502: LD_VAR 0 7
113506: PPUSH
113507: LD_VAR 0 7
113511: PUSH
113512: LD_INT 1
113514: PLUS
113515: PPUSH
113516: LD_VAR 0 9
113520: PUSH
113521: LD_VAR 0 10
113525: PUSH
113526: EMPTY
113527: LIST
113528: LIST
113529: PPUSH
113530: CALL_OW 1
113534: ST_TO_ADDR
113535: GO 113551
// i := i - 1 ;
113537: LD_ADDR_VAR 0 5
113541: PUSH
113542: LD_VAR 0 5
113546: PUSH
113547: LD_INT 1
113549: MINUS
113550: ST_TO_ADDR
// end ;
113551: GO 113357
113553: POP
113554: POP
// for i in tmp do
113555: LD_ADDR_VAR 0 5
113559: PUSH
113560: LD_VAR 0 7
113564: PUSH
113565: FOR_IN
113566: IFFALSE 113604
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
113568: LD_VAR 0 1
113572: PPUSH
113573: LD_VAR 0 5
113577: PUSH
113578: LD_INT 1
113580: ARRAY
113581: PPUSH
113582: LD_VAR 0 5
113586: PUSH
113587: LD_INT 2
113589: ARRAY
113590: PPUSH
113591: CALL 112550 0 3
113595: NOT
113596: IFFALSE 113602
// exit ;
113598: POP
113599: POP
113600: GO 113606
113602: GO 113565
113604: POP
113605: POP
// end ;
113606: LD_VAR 0 4
113610: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
113611: LD_INT 0
113613: PPUSH
113614: PPUSH
113615: PPUSH
113616: PPUSH
113617: PPUSH
113618: PPUSH
113619: PPUSH
// if not GetClass ( unit ) = class_sniper then
113620: LD_VAR 0 1
113624: PPUSH
113625: CALL_OW 257
113629: PUSH
113630: LD_INT 5
113632: EQUAL
113633: NOT
113634: IFFALSE 113638
// exit ;
113636: GO 114026
// dist := 8 ;
113638: LD_ADDR_VAR 0 5
113642: PUSH
113643: LD_INT 8
113645: ST_TO_ADDR
// viewRange := 12 ;
113646: LD_ADDR_VAR 0 7
113650: PUSH
113651: LD_INT 12
113653: ST_TO_ADDR
// side := GetSide ( unit ) ;
113654: LD_ADDR_VAR 0 6
113658: PUSH
113659: LD_VAR 0 1
113663: PPUSH
113664: CALL_OW 255
113668: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113669: LD_INT 61
113671: PPUSH
113672: LD_VAR 0 6
113676: PPUSH
113677: CALL_OW 321
113681: PUSH
113682: LD_INT 2
113684: EQUAL
113685: IFFALSE 113695
// viewRange := 16 ;
113687: LD_ADDR_VAR 0 7
113691: PUSH
113692: LD_INT 16
113694: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113695: LD_VAR 0 1
113699: PPUSH
113700: LD_VAR 0 2
113704: PPUSH
113705: LD_VAR 0 3
113709: PPUSH
113710: CALL_OW 297
113714: PUSH
113715: LD_VAR 0 5
113719: GREATER
113720: IFFALSE 113799
// begin ComMoveXY ( unit , x , y ) ;
113722: LD_VAR 0 1
113726: PPUSH
113727: LD_VAR 0 2
113731: PPUSH
113732: LD_VAR 0 3
113736: PPUSH
113737: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113741: LD_INT 35
113743: PPUSH
113744: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113748: LD_VAR 0 1
113752: PPUSH
113753: LD_VAR 0 2
113757: PPUSH
113758: LD_VAR 0 3
113762: PPUSH
113763: CALL 56327 0 3
113767: NOT
113768: IFFALSE 113772
// exit ;
113770: GO 114026
// until GetDistUnitXY ( unit , x , y ) < dist ;
113772: LD_VAR 0 1
113776: PPUSH
113777: LD_VAR 0 2
113781: PPUSH
113782: LD_VAR 0 3
113786: PPUSH
113787: CALL_OW 297
113791: PUSH
113792: LD_VAR 0 5
113796: LESS
113797: IFFALSE 113741
// end ; ComTurnXY ( unit , x , y ) ;
113799: LD_VAR 0 1
113803: PPUSH
113804: LD_VAR 0 2
113808: PPUSH
113809: LD_VAR 0 3
113813: PPUSH
113814: CALL_OW 118
// wait ( 5 ) ;
113818: LD_INT 5
113820: PPUSH
113821: CALL_OW 67
// _d := GetDir ( unit ) ;
113825: LD_ADDR_VAR 0 10
113829: PUSH
113830: LD_VAR 0 1
113834: PPUSH
113835: CALL_OW 254
113839: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
113840: LD_ADDR_VAR 0 8
113844: PUSH
113845: LD_VAR 0 1
113849: PPUSH
113850: CALL_OW 250
113854: PPUSH
113855: LD_VAR 0 10
113859: PPUSH
113860: LD_VAR 0 5
113864: PPUSH
113865: CALL_OW 272
113869: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
113870: LD_ADDR_VAR 0 9
113874: PUSH
113875: LD_VAR 0 1
113879: PPUSH
113880: CALL_OW 251
113884: PPUSH
113885: LD_VAR 0 10
113889: PPUSH
113890: LD_VAR 0 5
113894: PPUSH
113895: CALL_OW 273
113899: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113900: LD_VAR 0 8
113904: PPUSH
113905: LD_VAR 0 9
113909: PPUSH
113910: CALL_OW 488
113914: NOT
113915: IFFALSE 113919
// exit ;
113917: GO 114026
// ComAnimCustom ( unit , 1 ) ;
113919: LD_VAR 0 1
113923: PPUSH
113924: LD_INT 1
113926: PPUSH
113927: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113931: LD_VAR 0 8
113935: PPUSH
113936: LD_VAR 0 9
113940: PPUSH
113941: LD_VAR 0 6
113945: PPUSH
113946: LD_VAR 0 7
113950: PPUSH
113951: CALL_OW 330
// repeat wait ( 1 ) ;
113955: LD_INT 1
113957: PPUSH
113958: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
113962: LD_VAR 0 1
113966: PPUSH
113967: CALL_OW 316
113971: PUSH
113972: LD_VAR 0 1
113976: PPUSH
113977: CALL_OW 314
113981: OR
113982: PUSH
113983: LD_VAR 0 1
113987: PPUSH
113988: CALL_OW 302
113992: NOT
113993: OR
113994: PUSH
113995: LD_VAR 0 1
113999: PPUSH
114000: CALL_OW 301
114004: OR
114005: IFFALSE 113955
// RemoveSeeing ( _x , _y , side ) ;
114007: LD_VAR 0 8
114011: PPUSH
114012: LD_VAR 0 9
114016: PPUSH
114017: LD_VAR 0 6
114021: PPUSH
114022: CALL_OW 331
// end ; end_of_file
114026: LD_VAR 0 4
114030: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
114031: LD_INT 0
114033: PPUSH
114034: PPUSH
114035: PPUSH
114036: PPUSH
114037: PPUSH
114038: PPUSH
114039: PPUSH
114040: PPUSH
114041: PPUSH
114042: PPUSH
114043: PPUSH
114044: PPUSH
114045: PPUSH
114046: PPUSH
114047: PPUSH
114048: PPUSH
114049: PPUSH
114050: PPUSH
114051: PPUSH
114052: PPUSH
114053: PPUSH
114054: PPUSH
114055: PPUSH
114056: PPUSH
114057: PPUSH
114058: PPUSH
114059: PPUSH
114060: PPUSH
114061: PPUSH
114062: PPUSH
114063: PPUSH
114064: PPUSH
114065: PPUSH
114066: PPUSH
// if not list then
114067: LD_VAR 0 1
114071: NOT
114072: IFFALSE 114076
// exit ;
114074: GO 118735
// base := list [ 1 ] ;
114076: LD_ADDR_VAR 0 3
114080: PUSH
114081: LD_VAR 0 1
114085: PUSH
114086: LD_INT 1
114088: ARRAY
114089: ST_TO_ADDR
// group := list [ 2 ] ;
114090: LD_ADDR_VAR 0 4
114094: PUSH
114095: LD_VAR 0 1
114099: PUSH
114100: LD_INT 2
114102: ARRAY
114103: ST_TO_ADDR
// path := list [ 3 ] ;
114104: LD_ADDR_VAR 0 5
114108: PUSH
114109: LD_VAR 0 1
114113: PUSH
114114: LD_INT 3
114116: ARRAY
114117: ST_TO_ADDR
// flags := list [ 4 ] ;
114118: LD_ADDR_VAR 0 6
114122: PUSH
114123: LD_VAR 0 1
114127: PUSH
114128: LD_INT 4
114130: ARRAY
114131: ST_TO_ADDR
// mined := [ ] ;
114132: LD_ADDR_VAR 0 27
114136: PUSH
114137: EMPTY
114138: ST_TO_ADDR
// bombed := [ ] ;
114139: LD_ADDR_VAR 0 28
114143: PUSH
114144: EMPTY
114145: ST_TO_ADDR
// healers := [ ] ;
114146: LD_ADDR_VAR 0 31
114150: PUSH
114151: EMPTY
114152: ST_TO_ADDR
// to_heal := [ ] ;
114153: LD_ADDR_VAR 0 30
114157: PUSH
114158: EMPTY
114159: ST_TO_ADDR
// repairs := [ ] ;
114160: LD_ADDR_VAR 0 33
114164: PUSH
114165: EMPTY
114166: ST_TO_ADDR
// to_repair := [ ] ;
114167: LD_ADDR_VAR 0 32
114171: PUSH
114172: EMPTY
114173: ST_TO_ADDR
// if not group or not path then
114174: LD_VAR 0 4
114178: NOT
114179: PUSH
114180: LD_VAR 0 5
114184: NOT
114185: OR
114186: IFFALSE 114190
// exit ;
114188: GO 118735
// side := GetSide ( group [ 1 ] ) ;
114190: LD_ADDR_VAR 0 35
114194: PUSH
114195: LD_VAR 0 4
114199: PUSH
114200: LD_INT 1
114202: ARRAY
114203: PPUSH
114204: CALL_OW 255
114208: ST_TO_ADDR
// if flags then
114209: LD_VAR 0 6
114213: IFFALSE 114357
// begin f_ignore_area := flags [ 1 ] ;
114215: LD_ADDR_VAR 0 17
114219: PUSH
114220: LD_VAR 0 6
114224: PUSH
114225: LD_INT 1
114227: ARRAY
114228: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
114229: LD_ADDR_VAR 0 18
114233: PUSH
114234: LD_VAR 0 6
114238: PUSH
114239: LD_INT 2
114241: ARRAY
114242: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
114243: LD_ADDR_VAR 0 19
114247: PUSH
114248: LD_VAR 0 6
114252: PUSH
114253: LD_INT 3
114255: ARRAY
114256: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
114257: LD_ADDR_VAR 0 20
114261: PUSH
114262: LD_VAR 0 6
114266: PUSH
114267: LD_INT 4
114269: ARRAY
114270: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
114271: LD_ADDR_VAR 0 21
114275: PUSH
114276: LD_VAR 0 6
114280: PUSH
114281: LD_INT 5
114283: ARRAY
114284: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
114285: LD_ADDR_VAR 0 22
114289: PUSH
114290: LD_VAR 0 6
114294: PUSH
114295: LD_INT 6
114297: ARRAY
114298: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
114299: LD_ADDR_VAR 0 23
114303: PUSH
114304: LD_VAR 0 6
114308: PUSH
114309: LD_INT 7
114311: ARRAY
114312: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
114313: LD_ADDR_VAR 0 24
114317: PUSH
114318: LD_VAR 0 6
114322: PUSH
114323: LD_INT 8
114325: ARRAY
114326: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
114327: LD_ADDR_VAR 0 25
114331: PUSH
114332: LD_VAR 0 6
114336: PUSH
114337: LD_INT 9
114339: ARRAY
114340: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
114341: LD_ADDR_VAR 0 26
114345: PUSH
114346: LD_VAR 0 6
114350: PUSH
114351: LD_INT 10
114353: ARRAY
114354: ST_TO_ADDR
// end else
114355: GO 114437
// begin f_ignore_area := false ;
114357: LD_ADDR_VAR 0 17
114361: PUSH
114362: LD_INT 0
114364: ST_TO_ADDR
// f_capture := false ;
114365: LD_ADDR_VAR 0 18
114369: PUSH
114370: LD_INT 0
114372: ST_TO_ADDR
// f_ignore_civ := false ;
114373: LD_ADDR_VAR 0 19
114377: PUSH
114378: LD_INT 0
114380: ST_TO_ADDR
// f_murder := false ;
114381: LD_ADDR_VAR 0 20
114385: PUSH
114386: LD_INT 0
114388: ST_TO_ADDR
// f_mines := false ;
114389: LD_ADDR_VAR 0 21
114393: PUSH
114394: LD_INT 0
114396: ST_TO_ADDR
// f_repair := false ;
114397: LD_ADDR_VAR 0 22
114401: PUSH
114402: LD_INT 0
114404: ST_TO_ADDR
// f_heal := false ;
114405: LD_ADDR_VAR 0 23
114409: PUSH
114410: LD_INT 0
114412: ST_TO_ADDR
// f_spacetime := false ;
114413: LD_ADDR_VAR 0 24
114417: PUSH
114418: LD_INT 0
114420: ST_TO_ADDR
// f_attack_depot := false ;
114421: LD_ADDR_VAR 0 25
114425: PUSH
114426: LD_INT 0
114428: ST_TO_ADDR
// f_crawl := false ;
114429: LD_ADDR_VAR 0 26
114433: PUSH
114434: LD_INT 0
114436: ST_TO_ADDR
// end ; if f_heal then
114437: LD_VAR 0 23
114441: IFFALSE 114468
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
114443: LD_ADDR_VAR 0 31
114447: PUSH
114448: LD_VAR 0 4
114452: PPUSH
114453: LD_INT 25
114455: PUSH
114456: LD_INT 4
114458: PUSH
114459: EMPTY
114460: LIST
114461: LIST
114462: PPUSH
114463: CALL_OW 72
114467: ST_TO_ADDR
// if f_repair then
114468: LD_VAR 0 22
114472: IFFALSE 114499
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114474: LD_ADDR_VAR 0 33
114478: PUSH
114479: LD_VAR 0 4
114483: PPUSH
114484: LD_INT 25
114486: PUSH
114487: LD_INT 3
114489: PUSH
114490: EMPTY
114491: LIST
114492: LIST
114493: PPUSH
114494: CALL_OW 72
114498: ST_TO_ADDR
// units_path := [ ] ;
114499: LD_ADDR_VAR 0 16
114503: PUSH
114504: EMPTY
114505: ST_TO_ADDR
// for i = 1 to group do
114506: LD_ADDR_VAR 0 7
114510: PUSH
114511: DOUBLE
114512: LD_INT 1
114514: DEC
114515: ST_TO_ADDR
114516: LD_VAR 0 4
114520: PUSH
114521: FOR_TO
114522: IFFALSE 114551
// units_path := Replace ( units_path , i , path ) ;
114524: LD_ADDR_VAR 0 16
114528: PUSH
114529: LD_VAR 0 16
114533: PPUSH
114534: LD_VAR 0 7
114538: PPUSH
114539: LD_VAR 0 5
114543: PPUSH
114544: CALL_OW 1
114548: ST_TO_ADDR
114549: GO 114521
114551: POP
114552: POP
// repeat for i = group downto 1 do
114553: LD_ADDR_VAR 0 7
114557: PUSH
114558: DOUBLE
114559: LD_VAR 0 4
114563: INC
114564: ST_TO_ADDR
114565: LD_INT 1
114567: PUSH
114568: FOR_DOWNTO
114569: IFFALSE 118691
// begin wait ( 5 ) ;
114571: LD_INT 5
114573: PPUSH
114574: CALL_OW 67
// tmp := [ ] ;
114578: LD_ADDR_VAR 0 14
114582: PUSH
114583: EMPTY
114584: ST_TO_ADDR
// attacking := false ;
114585: LD_ADDR_VAR 0 29
114589: PUSH
114590: LD_INT 0
114592: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114593: LD_VAR 0 4
114597: PUSH
114598: LD_VAR 0 7
114602: ARRAY
114603: PPUSH
114604: CALL_OW 301
114608: PUSH
114609: LD_VAR 0 4
114613: PUSH
114614: LD_VAR 0 7
114618: ARRAY
114619: NOT
114620: OR
114621: IFFALSE 114730
// begin if GetType ( group [ i ] ) = unit_human then
114623: LD_VAR 0 4
114627: PUSH
114628: LD_VAR 0 7
114632: ARRAY
114633: PPUSH
114634: CALL_OW 247
114638: PUSH
114639: LD_INT 1
114641: EQUAL
114642: IFFALSE 114688
// begin to_heal := to_heal diff group [ i ] ;
114644: LD_ADDR_VAR 0 30
114648: PUSH
114649: LD_VAR 0 30
114653: PUSH
114654: LD_VAR 0 4
114658: PUSH
114659: LD_VAR 0 7
114663: ARRAY
114664: DIFF
114665: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114666: LD_ADDR_VAR 0 31
114670: PUSH
114671: LD_VAR 0 31
114675: PUSH
114676: LD_VAR 0 4
114680: PUSH
114681: LD_VAR 0 7
114685: ARRAY
114686: DIFF
114687: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114688: LD_ADDR_VAR 0 4
114692: PUSH
114693: LD_VAR 0 4
114697: PPUSH
114698: LD_VAR 0 7
114702: PPUSH
114703: CALL_OW 3
114707: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114708: LD_ADDR_VAR 0 16
114712: PUSH
114713: LD_VAR 0 16
114717: PPUSH
114718: LD_VAR 0 7
114722: PPUSH
114723: CALL_OW 3
114727: ST_TO_ADDR
// continue ;
114728: GO 114568
// end ; if f_repair then
114730: LD_VAR 0 22
114734: IFFALSE 115223
// begin if GetType ( group [ i ] ) = unit_vehicle then
114736: LD_VAR 0 4
114740: PUSH
114741: LD_VAR 0 7
114745: ARRAY
114746: PPUSH
114747: CALL_OW 247
114751: PUSH
114752: LD_INT 2
114754: EQUAL
114755: IFFALSE 114945
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114757: LD_VAR 0 4
114761: PUSH
114762: LD_VAR 0 7
114766: ARRAY
114767: PPUSH
114768: CALL_OW 256
114772: PUSH
114773: LD_INT 700
114775: LESS
114776: PUSH
114777: LD_VAR 0 4
114781: PUSH
114782: LD_VAR 0 7
114786: ARRAY
114787: PUSH
114788: LD_VAR 0 32
114792: IN
114793: NOT
114794: AND
114795: IFFALSE 114819
// to_repair := to_repair union group [ i ] ;
114797: LD_ADDR_VAR 0 32
114801: PUSH
114802: LD_VAR 0 32
114806: PUSH
114807: LD_VAR 0 4
114811: PUSH
114812: LD_VAR 0 7
114816: ARRAY
114817: UNION
114818: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114819: LD_VAR 0 4
114823: PUSH
114824: LD_VAR 0 7
114828: ARRAY
114829: PPUSH
114830: CALL_OW 256
114834: PUSH
114835: LD_INT 1000
114837: EQUAL
114838: PUSH
114839: LD_VAR 0 4
114843: PUSH
114844: LD_VAR 0 7
114848: ARRAY
114849: PUSH
114850: LD_VAR 0 32
114854: IN
114855: AND
114856: IFFALSE 114880
// to_repair := to_repair diff group [ i ] ;
114858: LD_ADDR_VAR 0 32
114862: PUSH
114863: LD_VAR 0 32
114867: PUSH
114868: LD_VAR 0 4
114872: PUSH
114873: LD_VAR 0 7
114877: ARRAY
114878: DIFF
114879: ST_TO_ADDR
// if group [ i ] in to_repair then
114880: LD_VAR 0 4
114884: PUSH
114885: LD_VAR 0 7
114889: ARRAY
114890: PUSH
114891: LD_VAR 0 32
114895: IN
114896: IFFALSE 114943
// begin if not IsInArea ( group [ i ] , f_repair ) then
114898: LD_VAR 0 4
114902: PUSH
114903: LD_VAR 0 7
114907: ARRAY
114908: PPUSH
114909: LD_VAR 0 22
114913: PPUSH
114914: CALL_OW 308
114918: NOT
114919: IFFALSE 114941
// ComMoveToArea ( group [ i ] , f_repair ) ;
114921: LD_VAR 0 4
114925: PUSH
114926: LD_VAR 0 7
114930: ARRAY
114931: PPUSH
114932: LD_VAR 0 22
114936: PPUSH
114937: CALL_OW 113
// continue ;
114941: GO 114568
// end ; end else
114943: GO 115223
// if group [ i ] in repairs then
114945: LD_VAR 0 4
114949: PUSH
114950: LD_VAR 0 7
114954: ARRAY
114955: PUSH
114956: LD_VAR 0 33
114960: IN
114961: IFFALSE 115223
// begin if IsInUnit ( group [ i ] ) then
114963: LD_VAR 0 4
114967: PUSH
114968: LD_VAR 0 7
114972: ARRAY
114973: PPUSH
114974: CALL_OW 310
114978: IFFALSE 115046
// begin z := IsInUnit ( group [ i ] ) ;
114980: LD_ADDR_VAR 0 13
114984: PUSH
114985: LD_VAR 0 4
114989: PUSH
114990: LD_VAR 0 7
114994: ARRAY
114995: PPUSH
114996: CALL_OW 310
115000: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
115001: LD_VAR 0 13
115005: PUSH
115006: LD_VAR 0 32
115010: IN
115011: PUSH
115012: LD_VAR 0 13
115016: PPUSH
115017: LD_VAR 0 22
115021: PPUSH
115022: CALL_OW 308
115026: AND
115027: IFFALSE 115044
// ComExitVehicle ( group [ i ] ) ;
115029: LD_VAR 0 4
115033: PUSH
115034: LD_VAR 0 7
115038: ARRAY
115039: PPUSH
115040: CALL_OW 121
// end else
115044: GO 115223
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
115046: LD_ADDR_VAR 0 13
115050: PUSH
115051: LD_VAR 0 4
115055: PPUSH
115056: LD_INT 95
115058: PUSH
115059: LD_VAR 0 22
115063: PUSH
115064: EMPTY
115065: LIST
115066: LIST
115067: PUSH
115068: LD_INT 58
115070: PUSH
115071: EMPTY
115072: LIST
115073: PUSH
115074: EMPTY
115075: LIST
115076: LIST
115077: PPUSH
115078: CALL_OW 72
115082: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
115083: LD_VAR 0 4
115087: PUSH
115088: LD_VAR 0 7
115092: ARRAY
115093: PPUSH
115094: CALL_OW 314
115098: NOT
115099: IFFALSE 115221
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
115101: LD_ADDR_VAR 0 10
115105: PUSH
115106: LD_VAR 0 13
115110: PPUSH
115111: LD_VAR 0 4
115115: PUSH
115116: LD_VAR 0 7
115120: ARRAY
115121: PPUSH
115122: CALL_OW 74
115126: ST_TO_ADDR
// if not x then
115127: LD_VAR 0 10
115131: NOT
115132: IFFALSE 115136
// continue ;
115134: GO 114568
// if GetLives ( x ) < 1000 then
115136: LD_VAR 0 10
115140: PPUSH
115141: CALL_OW 256
115145: PUSH
115146: LD_INT 1000
115148: LESS
115149: IFFALSE 115173
// ComRepairVehicle ( group [ i ] , x ) else
115151: LD_VAR 0 4
115155: PUSH
115156: LD_VAR 0 7
115160: ARRAY
115161: PPUSH
115162: LD_VAR 0 10
115166: PPUSH
115167: CALL_OW 129
115171: GO 115221
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
115173: LD_VAR 0 23
115177: PUSH
115178: LD_VAR 0 4
115182: PUSH
115183: LD_VAR 0 7
115187: ARRAY
115188: PPUSH
115189: CALL_OW 256
115193: PUSH
115194: LD_INT 1000
115196: LESS
115197: AND
115198: NOT
115199: IFFALSE 115221
// ComEnterUnit ( group [ i ] , x ) ;
115201: LD_VAR 0 4
115205: PUSH
115206: LD_VAR 0 7
115210: ARRAY
115211: PPUSH
115212: LD_VAR 0 10
115216: PPUSH
115217: CALL_OW 120
// end ; continue ;
115221: GO 114568
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
115223: LD_VAR 0 23
115227: PUSH
115228: LD_VAR 0 4
115232: PUSH
115233: LD_VAR 0 7
115237: ARRAY
115238: PPUSH
115239: CALL_OW 247
115243: PUSH
115244: LD_INT 1
115246: EQUAL
115247: AND
115248: IFFALSE 115726
// begin if group [ i ] in healers then
115250: LD_VAR 0 4
115254: PUSH
115255: LD_VAR 0 7
115259: ARRAY
115260: PUSH
115261: LD_VAR 0 31
115265: IN
115266: IFFALSE 115539
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
115268: LD_VAR 0 4
115272: PUSH
115273: LD_VAR 0 7
115277: ARRAY
115278: PPUSH
115279: LD_VAR 0 23
115283: PPUSH
115284: CALL_OW 308
115288: NOT
115289: PUSH
115290: LD_VAR 0 4
115294: PUSH
115295: LD_VAR 0 7
115299: ARRAY
115300: PPUSH
115301: CALL_OW 314
115305: NOT
115306: AND
115307: IFFALSE 115331
// ComMoveToArea ( group [ i ] , f_heal ) else
115309: LD_VAR 0 4
115313: PUSH
115314: LD_VAR 0 7
115318: ARRAY
115319: PPUSH
115320: LD_VAR 0 23
115324: PPUSH
115325: CALL_OW 113
115329: GO 115537
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
115331: LD_VAR 0 4
115335: PUSH
115336: LD_VAR 0 7
115340: ARRAY
115341: PPUSH
115342: CALL 54910 0 1
115346: PPUSH
115347: CALL_OW 256
115351: PUSH
115352: LD_INT 1000
115354: EQUAL
115355: IFFALSE 115374
// ComStop ( group [ i ] ) else
115357: LD_VAR 0 4
115361: PUSH
115362: LD_VAR 0 7
115366: ARRAY
115367: PPUSH
115368: CALL_OW 141
115372: GO 115537
// if not HasTask ( group [ i ] ) and to_heal then
115374: LD_VAR 0 4
115378: PUSH
115379: LD_VAR 0 7
115383: ARRAY
115384: PPUSH
115385: CALL_OW 314
115389: NOT
115390: PUSH
115391: LD_VAR 0 30
115395: AND
115396: IFFALSE 115537
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115398: LD_ADDR_VAR 0 13
115402: PUSH
115403: LD_VAR 0 30
115407: PPUSH
115408: LD_INT 3
115410: PUSH
115411: LD_INT 54
115413: PUSH
115414: EMPTY
115415: LIST
115416: PUSH
115417: EMPTY
115418: LIST
115419: LIST
115420: PPUSH
115421: CALL_OW 72
115425: PPUSH
115426: LD_VAR 0 4
115430: PUSH
115431: LD_VAR 0 7
115435: ARRAY
115436: PPUSH
115437: CALL_OW 74
115441: ST_TO_ADDR
// if z then
115442: LD_VAR 0 13
115446: IFFALSE 115537
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
115448: LD_INT 91
115450: PUSH
115451: LD_VAR 0 13
115455: PUSH
115456: LD_INT 10
115458: PUSH
115459: EMPTY
115460: LIST
115461: LIST
115462: LIST
115463: PUSH
115464: LD_INT 81
115466: PUSH
115467: LD_VAR 0 13
115471: PPUSH
115472: CALL_OW 255
115476: PUSH
115477: EMPTY
115478: LIST
115479: LIST
115480: PUSH
115481: EMPTY
115482: LIST
115483: LIST
115484: PPUSH
115485: CALL_OW 69
115489: PUSH
115490: LD_INT 0
115492: EQUAL
115493: IFFALSE 115517
// ComHeal ( group [ i ] , z ) else
115495: LD_VAR 0 4
115499: PUSH
115500: LD_VAR 0 7
115504: ARRAY
115505: PPUSH
115506: LD_VAR 0 13
115510: PPUSH
115511: CALL_OW 128
115515: GO 115537
// ComMoveToArea ( group [ i ] , f_heal ) ;
115517: LD_VAR 0 4
115521: PUSH
115522: LD_VAR 0 7
115526: ARRAY
115527: PPUSH
115528: LD_VAR 0 23
115532: PPUSH
115533: CALL_OW 113
// end ; continue ;
115537: GO 114568
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
115539: LD_VAR 0 4
115543: PUSH
115544: LD_VAR 0 7
115548: ARRAY
115549: PPUSH
115550: CALL_OW 256
115554: PUSH
115555: LD_INT 700
115557: LESS
115558: PUSH
115559: LD_VAR 0 4
115563: PUSH
115564: LD_VAR 0 7
115568: ARRAY
115569: PUSH
115570: LD_VAR 0 30
115574: IN
115575: NOT
115576: AND
115577: IFFALSE 115601
// to_heal := to_heal union group [ i ] ;
115579: LD_ADDR_VAR 0 30
115583: PUSH
115584: LD_VAR 0 30
115588: PUSH
115589: LD_VAR 0 4
115593: PUSH
115594: LD_VAR 0 7
115598: ARRAY
115599: UNION
115600: ST_TO_ADDR
// if group [ i ] in to_heal then
115601: LD_VAR 0 4
115605: PUSH
115606: LD_VAR 0 7
115610: ARRAY
115611: PUSH
115612: LD_VAR 0 30
115616: IN
115617: IFFALSE 115726
// begin if GetLives ( group [ i ] ) = 1000 then
115619: LD_VAR 0 4
115623: PUSH
115624: LD_VAR 0 7
115628: ARRAY
115629: PPUSH
115630: CALL_OW 256
115634: PUSH
115635: LD_INT 1000
115637: EQUAL
115638: IFFALSE 115664
// to_heal := to_heal diff group [ i ] else
115640: LD_ADDR_VAR 0 30
115644: PUSH
115645: LD_VAR 0 30
115649: PUSH
115650: LD_VAR 0 4
115654: PUSH
115655: LD_VAR 0 7
115659: ARRAY
115660: DIFF
115661: ST_TO_ADDR
115662: GO 115726
// begin if not IsInArea ( group [ i ] , to_heal ) then
115664: LD_VAR 0 4
115668: PUSH
115669: LD_VAR 0 7
115673: ARRAY
115674: PPUSH
115675: LD_VAR 0 30
115679: PPUSH
115680: CALL_OW 308
115684: NOT
115685: IFFALSE 115709
// ComMoveToArea ( group [ i ] , f_heal ) else
115687: LD_VAR 0 4
115691: PUSH
115692: LD_VAR 0 7
115696: ARRAY
115697: PPUSH
115698: LD_VAR 0 23
115702: PPUSH
115703: CALL_OW 113
115707: GO 115724
// ComHold ( group [ i ] ) ;
115709: LD_VAR 0 4
115713: PUSH
115714: LD_VAR 0 7
115718: ARRAY
115719: PPUSH
115720: CALL_OW 140
// continue ;
115724: GO 114568
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115726: LD_VAR 0 4
115730: PUSH
115731: LD_VAR 0 7
115735: ARRAY
115736: PPUSH
115737: LD_INT 10
115739: PPUSH
115740: CALL 52692 0 2
115744: NOT
115745: PUSH
115746: LD_VAR 0 16
115750: PUSH
115751: LD_VAR 0 7
115755: ARRAY
115756: PUSH
115757: EMPTY
115758: EQUAL
115759: NOT
115760: AND
115761: IFFALSE 116027
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
115763: LD_VAR 0 4
115767: PUSH
115768: LD_VAR 0 7
115772: ARRAY
115773: PPUSH
115774: CALL_OW 262
115778: PUSH
115779: LD_INT 1
115781: PUSH
115782: LD_INT 2
115784: PUSH
115785: EMPTY
115786: LIST
115787: LIST
115788: IN
115789: IFFALSE 115830
// if GetFuel ( group [ i ] ) < 10 then
115791: LD_VAR 0 4
115795: PUSH
115796: LD_VAR 0 7
115800: ARRAY
115801: PPUSH
115802: CALL_OW 261
115806: PUSH
115807: LD_INT 10
115809: LESS
115810: IFFALSE 115830
// SetFuel ( group [ i ] , 12 ) ;
115812: LD_VAR 0 4
115816: PUSH
115817: LD_VAR 0 7
115821: ARRAY
115822: PPUSH
115823: LD_INT 12
115825: PPUSH
115826: CALL_OW 240
// if units_path [ i ] then
115830: LD_VAR 0 16
115834: PUSH
115835: LD_VAR 0 7
115839: ARRAY
115840: IFFALSE 116025
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115842: LD_VAR 0 4
115846: PUSH
115847: LD_VAR 0 7
115851: ARRAY
115852: PPUSH
115853: LD_VAR 0 16
115857: PUSH
115858: LD_VAR 0 7
115862: ARRAY
115863: PUSH
115864: LD_INT 1
115866: ARRAY
115867: PUSH
115868: LD_INT 1
115870: ARRAY
115871: PPUSH
115872: LD_VAR 0 16
115876: PUSH
115877: LD_VAR 0 7
115881: ARRAY
115882: PUSH
115883: LD_INT 1
115885: ARRAY
115886: PUSH
115887: LD_INT 2
115889: ARRAY
115890: PPUSH
115891: CALL_OW 297
115895: PUSH
115896: LD_INT 6
115898: GREATER
115899: IFFALSE 115974
// begin if not HasTask ( group [ i ] ) then
115901: LD_VAR 0 4
115905: PUSH
115906: LD_VAR 0 7
115910: ARRAY
115911: PPUSH
115912: CALL_OW 314
115916: NOT
115917: IFFALSE 115972
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115919: LD_VAR 0 4
115923: PUSH
115924: LD_VAR 0 7
115928: ARRAY
115929: PPUSH
115930: LD_VAR 0 16
115934: PUSH
115935: LD_VAR 0 7
115939: ARRAY
115940: PUSH
115941: LD_INT 1
115943: ARRAY
115944: PUSH
115945: LD_INT 1
115947: ARRAY
115948: PPUSH
115949: LD_VAR 0 16
115953: PUSH
115954: LD_VAR 0 7
115958: ARRAY
115959: PUSH
115960: LD_INT 1
115962: ARRAY
115963: PUSH
115964: LD_INT 2
115966: ARRAY
115967: PPUSH
115968: CALL_OW 114
// end else
115972: GO 116025
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115974: LD_ADDR_VAR 0 15
115978: PUSH
115979: LD_VAR 0 16
115983: PUSH
115984: LD_VAR 0 7
115988: ARRAY
115989: PPUSH
115990: LD_INT 1
115992: PPUSH
115993: CALL_OW 3
115997: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115998: LD_ADDR_VAR 0 16
116002: PUSH
116003: LD_VAR 0 16
116007: PPUSH
116008: LD_VAR 0 7
116012: PPUSH
116013: LD_VAR 0 15
116017: PPUSH
116018: CALL_OW 1
116022: ST_TO_ADDR
// continue ;
116023: GO 114568
// end ; end ; end else
116025: GO 118689
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
116027: LD_ADDR_VAR 0 14
116031: PUSH
116032: LD_INT 81
116034: PUSH
116035: LD_VAR 0 4
116039: PUSH
116040: LD_VAR 0 7
116044: ARRAY
116045: PPUSH
116046: CALL_OW 255
116050: PUSH
116051: EMPTY
116052: LIST
116053: LIST
116054: PPUSH
116055: CALL_OW 69
116059: ST_TO_ADDR
// if not tmp then
116060: LD_VAR 0 14
116064: NOT
116065: IFFALSE 116069
// continue ;
116067: GO 114568
// if f_ignore_area then
116069: LD_VAR 0 17
116073: IFFALSE 116161
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
116075: LD_ADDR_VAR 0 15
116079: PUSH
116080: LD_VAR 0 14
116084: PPUSH
116085: LD_INT 3
116087: PUSH
116088: LD_INT 92
116090: PUSH
116091: LD_VAR 0 17
116095: PUSH
116096: LD_INT 1
116098: ARRAY
116099: PUSH
116100: LD_VAR 0 17
116104: PUSH
116105: LD_INT 2
116107: ARRAY
116108: PUSH
116109: LD_VAR 0 17
116113: PUSH
116114: LD_INT 3
116116: ARRAY
116117: PUSH
116118: EMPTY
116119: LIST
116120: LIST
116121: LIST
116122: LIST
116123: PUSH
116124: EMPTY
116125: LIST
116126: LIST
116127: PPUSH
116128: CALL_OW 72
116132: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116133: LD_VAR 0 14
116137: PUSH
116138: LD_VAR 0 15
116142: DIFF
116143: IFFALSE 116161
// tmp := tmp diff tmp2 ;
116145: LD_ADDR_VAR 0 14
116149: PUSH
116150: LD_VAR 0 14
116154: PUSH
116155: LD_VAR 0 15
116159: DIFF
116160: ST_TO_ADDR
// end ; if not f_murder then
116161: LD_VAR 0 20
116165: NOT
116166: IFFALSE 116224
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
116168: LD_ADDR_VAR 0 15
116172: PUSH
116173: LD_VAR 0 14
116177: PPUSH
116178: LD_INT 3
116180: PUSH
116181: LD_INT 50
116183: PUSH
116184: EMPTY
116185: LIST
116186: PUSH
116187: EMPTY
116188: LIST
116189: LIST
116190: PPUSH
116191: CALL_OW 72
116195: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116196: LD_VAR 0 14
116200: PUSH
116201: LD_VAR 0 15
116205: DIFF
116206: IFFALSE 116224
// tmp := tmp diff tmp2 ;
116208: LD_ADDR_VAR 0 14
116212: PUSH
116213: LD_VAR 0 14
116217: PUSH
116218: LD_VAR 0 15
116222: DIFF
116223: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
116224: LD_ADDR_VAR 0 14
116228: PUSH
116229: LD_VAR 0 4
116233: PUSH
116234: LD_VAR 0 7
116238: ARRAY
116239: PPUSH
116240: LD_VAR 0 14
116244: PPUSH
116245: LD_INT 1
116247: PPUSH
116248: LD_INT 1
116250: PPUSH
116251: CALL 25236 0 4
116255: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
116256: LD_VAR 0 4
116260: PUSH
116261: LD_VAR 0 7
116265: ARRAY
116266: PPUSH
116267: CALL_OW 257
116271: PUSH
116272: LD_INT 1
116274: EQUAL
116275: IFFALSE 116723
// begin if WantPlant ( group [ i ] ) then
116277: LD_VAR 0 4
116281: PUSH
116282: LD_VAR 0 7
116286: ARRAY
116287: PPUSH
116288: CALL 24737 0 1
116292: IFFALSE 116296
// continue ;
116294: GO 114568
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
116296: LD_VAR 0 18
116300: PUSH
116301: LD_VAR 0 4
116305: PUSH
116306: LD_VAR 0 7
116310: ARRAY
116311: PPUSH
116312: CALL_OW 310
116316: NOT
116317: AND
116318: PUSH
116319: LD_VAR 0 14
116323: PUSH
116324: LD_INT 1
116326: ARRAY
116327: PUSH
116328: LD_VAR 0 14
116332: PPUSH
116333: LD_INT 21
116335: PUSH
116336: LD_INT 2
116338: PUSH
116339: EMPTY
116340: LIST
116341: LIST
116342: PUSH
116343: LD_INT 58
116345: PUSH
116346: EMPTY
116347: LIST
116348: PUSH
116349: EMPTY
116350: LIST
116351: LIST
116352: PPUSH
116353: CALL_OW 72
116357: IN
116358: AND
116359: IFFALSE 116395
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
116361: LD_VAR 0 4
116365: PUSH
116366: LD_VAR 0 7
116370: ARRAY
116371: PPUSH
116372: LD_VAR 0 14
116376: PUSH
116377: LD_INT 1
116379: ARRAY
116380: PPUSH
116381: CALL_OW 120
// attacking := true ;
116385: LD_ADDR_VAR 0 29
116389: PUSH
116390: LD_INT 1
116392: ST_TO_ADDR
// continue ;
116393: GO 114568
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116395: LD_VAR 0 26
116399: PUSH
116400: LD_VAR 0 4
116404: PUSH
116405: LD_VAR 0 7
116409: ARRAY
116410: PPUSH
116411: CALL_OW 257
116415: PUSH
116416: LD_INT 1
116418: EQUAL
116419: AND
116420: PUSH
116421: LD_VAR 0 4
116425: PUSH
116426: LD_VAR 0 7
116430: ARRAY
116431: PPUSH
116432: CALL_OW 256
116436: PUSH
116437: LD_INT 800
116439: LESS
116440: AND
116441: PUSH
116442: LD_VAR 0 4
116446: PUSH
116447: LD_VAR 0 7
116451: ARRAY
116452: PPUSH
116453: CALL_OW 318
116457: NOT
116458: AND
116459: IFFALSE 116476
// ComCrawl ( group [ i ] ) ;
116461: LD_VAR 0 4
116465: PUSH
116466: LD_VAR 0 7
116470: ARRAY
116471: PPUSH
116472: CALL_OW 137
// if f_mines then
116476: LD_VAR 0 21
116480: IFFALSE 116723
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116482: LD_VAR 0 14
116486: PUSH
116487: LD_INT 1
116489: ARRAY
116490: PPUSH
116491: CALL_OW 247
116495: PUSH
116496: LD_INT 3
116498: EQUAL
116499: PUSH
116500: LD_VAR 0 14
116504: PUSH
116505: LD_INT 1
116507: ARRAY
116508: PUSH
116509: LD_VAR 0 27
116513: IN
116514: NOT
116515: AND
116516: IFFALSE 116723
// begin x := GetX ( tmp [ 1 ] ) ;
116518: LD_ADDR_VAR 0 10
116522: PUSH
116523: LD_VAR 0 14
116527: PUSH
116528: LD_INT 1
116530: ARRAY
116531: PPUSH
116532: CALL_OW 250
116536: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
116537: LD_ADDR_VAR 0 11
116541: PUSH
116542: LD_VAR 0 14
116546: PUSH
116547: LD_INT 1
116549: ARRAY
116550: PPUSH
116551: CALL_OW 251
116555: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116556: LD_ADDR_VAR 0 12
116560: PUSH
116561: LD_VAR 0 4
116565: PUSH
116566: LD_VAR 0 7
116570: ARRAY
116571: PPUSH
116572: CALL 52777 0 1
116576: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116577: LD_VAR 0 4
116581: PUSH
116582: LD_VAR 0 7
116586: ARRAY
116587: PPUSH
116588: LD_VAR 0 10
116592: PPUSH
116593: LD_VAR 0 11
116597: PPUSH
116598: LD_VAR 0 14
116602: PUSH
116603: LD_INT 1
116605: ARRAY
116606: PPUSH
116607: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116611: LD_VAR 0 4
116615: PUSH
116616: LD_VAR 0 7
116620: ARRAY
116621: PPUSH
116622: LD_VAR 0 10
116626: PPUSH
116627: LD_VAR 0 12
116631: PPUSH
116632: LD_INT 7
116634: PPUSH
116635: CALL_OW 272
116639: PPUSH
116640: LD_VAR 0 11
116644: PPUSH
116645: LD_VAR 0 12
116649: PPUSH
116650: LD_INT 7
116652: PPUSH
116653: CALL_OW 273
116657: PPUSH
116658: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116662: LD_VAR 0 4
116666: PUSH
116667: LD_VAR 0 7
116671: ARRAY
116672: PPUSH
116673: LD_INT 71
116675: PPUSH
116676: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116680: LD_ADDR_VAR 0 27
116684: PUSH
116685: LD_VAR 0 27
116689: PPUSH
116690: LD_VAR 0 27
116694: PUSH
116695: LD_INT 1
116697: PLUS
116698: PPUSH
116699: LD_VAR 0 14
116703: PUSH
116704: LD_INT 1
116706: ARRAY
116707: PPUSH
116708: CALL_OW 1
116712: ST_TO_ADDR
// attacking := true ;
116713: LD_ADDR_VAR 0 29
116717: PUSH
116718: LD_INT 1
116720: ST_TO_ADDR
// continue ;
116721: GO 114568
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116723: LD_VAR 0 4
116727: PUSH
116728: LD_VAR 0 7
116732: ARRAY
116733: PPUSH
116734: CALL_OW 257
116738: PUSH
116739: LD_INT 17
116741: EQUAL
116742: PUSH
116743: LD_VAR 0 4
116747: PUSH
116748: LD_VAR 0 7
116752: ARRAY
116753: PPUSH
116754: CALL_OW 110
116758: PUSH
116759: LD_INT 71
116761: EQUAL
116762: NOT
116763: AND
116764: IFFALSE 116910
// begin attacking := false ;
116766: LD_ADDR_VAR 0 29
116770: PUSH
116771: LD_INT 0
116773: ST_TO_ADDR
// k := 5 ;
116774: LD_ADDR_VAR 0 9
116778: PUSH
116779: LD_INT 5
116781: ST_TO_ADDR
// if tmp < k then
116782: LD_VAR 0 14
116786: PUSH
116787: LD_VAR 0 9
116791: LESS
116792: IFFALSE 116804
// k := tmp ;
116794: LD_ADDR_VAR 0 9
116798: PUSH
116799: LD_VAR 0 14
116803: ST_TO_ADDR
// for j = 1 to k do
116804: LD_ADDR_VAR 0 8
116808: PUSH
116809: DOUBLE
116810: LD_INT 1
116812: DEC
116813: ST_TO_ADDR
116814: LD_VAR 0 9
116818: PUSH
116819: FOR_TO
116820: IFFALSE 116908
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116822: LD_VAR 0 14
116826: PUSH
116827: LD_VAR 0 8
116831: ARRAY
116832: PUSH
116833: LD_VAR 0 14
116837: PPUSH
116838: LD_INT 58
116840: PUSH
116841: EMPTY
116842: LIST
116843: PPUSH
116844: CALL_OW 72
116848: IN
116849: NOT
116850: IFFALSE 116906
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116852: LD_VAR 0 4
116856: PUSH
116857: LD_VAR 0 7
116861: ARRAY
116862: PPUSH
116863: LD_VAR 0 14
116867: PUSH
116868: LD_VAR 0 8
116872: ARRAY
116873: PPUSH
116874: CALL_OW 115
// attacking := true ;
116878: LD_ADDR_VAR 0 29
116882: PUSH
116883: LD_INT 1
116885: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116886: LD_VAR 0 4
116890: PUSH
116891: LD_VAR 0 7
116895: ARRAY
116896: PPUSH
116897: LD_INT 71
116899: PPUSH
116900: CALL_OW 109
// continue ;
116904: GO 116819
// end ; end ;
116906: GO 116819
116908: POP
116909: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116910: LD_VAR 0 4
116914: PUSH
116915: LD_VAR 0 7
116919: ARRAY
116920: PPUSH
116921: CALL_OW 257
116925: PUSH
116926: LD_INT 8
116928: EQUAL
116929: PUSH
116930: LD_VAR 0 4
116934: PUSH
116935: LD_VAR 0 7
116939: ARRAY
116940: PPUSH
116941: CALL_OW 264
116945: PUSH
116946: LD_INT 28
116948: PUSH
116949: LD_INT 45
116951: PUSH
116952: LD_INT 7
116954: PUSH
116955: LD_INT 47
116957: PUSH
116958: EMPTY
116959: LIST
116960: LIST
116961: LIST
116962: LIST
116963: IN
116964: OR
116965: IFFALSE 117221
// begin attacking := false ;
116967: LD_ADDR_VAR 0 29
116971: PUSH
116972: LD_INT 0
116974: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116975: LD_VAR 0 14
116979: PUSH
116980: LD_INT 1
116982: ARRAY
116983: PPUSH
116984: CALL_OW 266
116988: PUSH
116989: LD_INT 32
116991: PUSH
116992: LD_INT 31
116994: PUSH
116995: LD_INT 33
116997: PUSH
116998: LD_INT 4
117000: PUSH
117001: LD_INT 5
117003: PUSH
117004: EMPTY
117005: LIST
117006: LIST
117007: LIST
117008: LIST
117009: LIST
117010: IN
117011: IFFALSE 117197
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
117013: LD_ADDR_VAR 0 9
117017: PUSH
117018: LD_VAR 0 14
117022: PUSH
117023: LD_INT 1
117025: ARRAY
117026: PPUSH
117027: CALL_OW 266
117031: PPUSH
117032: LD_VAR 0 14
117036: PUSH
117037: LD_INT 1
117039: ARRAY
117040: PPUSH
117041: CALL_OW 250
117045: PPUSH
117046: LD_VAR 0 14
117050: PUSH
117051: LD_INT 1
117053: ARRAY
117054: PPUSH
117055: CALL_OW 251
117059: PPUSH
117060: LD_VAR 0 14
117064: PUSH
117065: LD_INT 1
117067: ARRAY
117068: PPUSH
117069: CALL_OW 254
117073: PPUSH
117074: LD_VAR 0 14
117078: PUSH
117079: LD_INT 1
117081: ARRAY
117082: PPUSH
117083: CALL_OW 248
117087: PPUSH
117088: LD_INT 0
117090: PPUSH
117091: CALL 34147 0 6
117095: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
117096: LD_ADDR_VAR 0 8
117100: PUSH
117101: LD_VAR 0 4
117105: PUSH
117106: LD_VAR 0 7
117110: ARRAY
117111: PPUSH
117112: LD_VAR 0 9
117116: PPUSH
117117: CALL 52890 0 2
117121: ST_TO_ADDR
// if j then
117122: LD_VAR 0 8
117126: IFFALSE 117195
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
117128: LD_VAR 0 8
117132: PUSH
117133: LD_INT 1
117135: ARRAY
117136: PPUSH
117137: LD_VAR 0 8
117141: PUSH
117142: LD_INT 2
117144: ARRAY
117145: PPUSH
117146: CALL_OW 488
117150: IFFALSE 117195
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
117152: LD_VAR 0 4
117156: PUSH
117157: LD_VAR 0 7
117161: ARRAY
117162: PPUSH
117163: LD_VAR 0 8
117167: PUSH
117168: LD_INT 1
117170: ARRAY
117171: PPUSH
117172: LD_VAR 0 8
117176: PUSH
117177: LD_INT 2
117179: ARRAY
117180: PPUSH
117181: CALL_OW 116
// attacking := true ;
117185: LD_ADDR_VAR 0 29
117189: PUSH
117190: LD_INT 1
117192: ST_TO_ADDR
// continue ;
117193: GO 114568
// end ; end else
117195: GO 117221
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117197: LD_VAR 0 4
117201: PUSH
117202: LD_VAR 0 7
117206: ARRAY
117207: PPUSH
117208: LD_VAR 0 14
117212: PUSH
117213: LD_INT 1
117215: ARRAY
117216: PPUSH
117217: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
117221: LD_VAR 0 4
117225: PUSH
117226: LD_VAR 0 7
117230: ARRAY
117231: PPUSH
117232: CALL_OW 265
117236: PUSH
117237: LD_INT 11
117239: EQUAL
117240: IFFALSE 117518
// begin k := 10 ;
117242: LD_ADDR_VAR 0 9
117246: PUSH
117247: LD_INT 10
117249: ST_TO_ADDR
// x := 0 ;
117250: LD_ADDR_VAR 0 10
117254: PUSH
117255: LD_INT 0
117257: ST_TO_ADDR
// if tmp < k then
117258: LD_VAR 0 14
117262: PUSH
117263: LD_VAR 0 9
117267: LESS
117268: IFFALSE 117280
// k := tmp ;
117270: LD_ADDR_VAR 0 9
117274: PUSH
117275: LD_VAR 0 14
117279: ST_TO_ADDR
// for j = k downto 1 do
117280: LD_ADDR_VAR 0 8
117284: PUSH
117285: DOUBLE
117286: LD_VAR 0 9
117290: INC
117291: ST_TO_ADDR
117292: LD_INT 1
117294: PUSH
117295: FOR_DOWNTO
117296: IFFALSE 117371
// begin if GetType ( tmp [ j ] ) = unit_human then
117298: LD_VAR 0 14
117302: PUSH
117303: LD_VAR 0 8
117307: ARRAY
117308: PPUSH
117309: CALL_OW 247
117313: PUSH
117314: LD_INT 1
117316: EQUAL
117317: IFFALSE 117369
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
117319: LD_VAR 0 4
117323: PUSH
117324: LD_VAR 0 7
117328: ARRAY
117329: PPUSH
117330: LD_VAR 0 14
117334: PUSH
117335: LD_VAR 0 8
117339: ARRAY
117340: PPUSH
117341: CALL 53144 0 2
// x := tmp [ j ] ;
117345: LD_ADDR_VAR 0 10
117349: PUSH
117350: LD_VAR 0 14
117354: PUSH
117355: LD_VAR 0 8
117359: ARRAY
117360: ST_TO_ADDR
// attacking := true ;
117361: LD_ADDR_VAR 0 29
117365: PUSH
117366: LD_INT 1
117368: ST_TO_ADDR
// end ; end ;
117369: GO 117295
117371: POP
117372: POP
// if not x then
117373: LD_VAR 0 10
117377: NOT
117378: IFFALSE 117518
// begin attacking := true ;
117380: LD_ADDR_VAR 0 29
117384: PUSH
117385: LD_INT 1
117387: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117388: LD_VAR 0 4
117392: PUSH
117393: LD_VAR 0 7
117397: ARRAY
117398: PPUSH
117399: CALL_OW 250
117403: PPUSH
117404: LD_VAR 0 4
117408: PUSH
117409: LD_VAR 0 7
117413: ARRAY
117414: PPUSH
117415: CALL_OW 251
117419: PPUSH
117420: CALL_OW 546
117424: PUSH
117425: LD_INT 2
117427: ARRAY
117428: PUSH
117429: LD_VAR 0 14
117433: PUSH
117434: LD_INT 1
117436: ARRAY
117437: PPUSH
117438: CALL_OW 250
117442: PPUSH
117443: LD_VAR 0 14
117447: PUSH
117448: LD_INT 1
117450: ARRAY
117451: PPUSH
117452: CALL_OW 251
117456: PPUSH
117457: CALL_OW 546
117461: PUSH
117462: LD_INT 2
117464: ARRAY
117465: EQUAL
117466: IFFALSE 117494
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117468: LD_VAR 0 4
117472: PUSH
117473: LD_VAR 0 7
117477: ARRAY
117478: PPUSH
117479: LD_VAR 0 14
117483: PUSH
117484: LD_INT 1
117486: ARRAY
117487: PPUSH
117488: CALL 53144 0 2
117492: GO 117518
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117494: LD_VAR 0 4
117498: PUSH
117499: LD_VAR 0 7
117503: ARRAY
117504: PPUSH
117505: LD_VAR 0 14
117509: PUSH
117510: LD_INT 1
117512: ARRAY
117513: PPUSH
117514: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117518: LD_VAR 0 4
117522: PUSH
117523: LD_VAR 0 7
117527: ARRAY
117528: PPUSH
117529: CALL_OW 264
117533: PUSH
117534: LD_INT 29
117536: EQUAL
117537: IFFALSE 117903
// begin if WantsToAttack ( group [ i ] ) in bombed then
117539: LD_VAR 0 4
117543: PUSH
117544: LD_VAR 0 7
117548: ARRAY
117549: PPUSH
117550: CALL_OW 319
117554: PUSH
117555: LD_VAR 0 28
117559: IN
117560: IFFALSE 117564
// continue ;
117562: GO 114568
// k := 8 ;
117564: LD_ADDR_VAR 0 9
117568: PUSH
117569: LD_INT 8
117571: ST_TO_ADDR
// x := 0 ;
117572: LD_ADDR_VAR 0 10
117576: PUSH
117577: LD_INT 0
117579: ST_TO_ADDR
// if tmp < k then
117580: LD_VAR 0 14
117584: PUSH
117585: LD_VAR 0 9
117589: LESS
117590: IFFALSE 117602
// k := tmp ;
117592: LD_ADDR_VAR 0 9
117596: PUSH
117597: LD_VAR 0 14
117601: ST_TO_ADDR
// for j = 1 to k do
117602: LD_ADDR_VAR 0 8
117606: PUSH
117607: DOUBLE
117608: LD_INT 1
117610: DEC
117611: ST_TO_ADDR
117612: LD_VAR 0 9
117616: PUSH
117617: FOR_TO
117618: IFFALSE 117750
// begin if GetType ( tmp [ j ] ) = unit_building then
117620: LD_VAR 0 14
117624: PUSH
117625: LD_VAR 0 8
117629: ARRAY
117630: PPUSH
117631: CALL_OW 247
117635: PUSH
117636: LD_INT 3
117638: EQUAL
117639: IFFALSE 117748
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117641: LD_VAR 0 14
117645: PUSH
117646: LD_VAR 0 8
117650: ARRAY
117651: PUSH
117652: LD_VAR 0 28
117656: IN
117657: NOT
117658: PUSH
117659: LD_VAR 0 14
117663: PUSH
117664: LD_VAR 0 8
117668: ARRAY
117669: PPUSH
117670: CALL_OW 313
117674: AND
117675: IFFALSE 117748
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117677: LD_VAR 0 4
117681: PUSH
117682: LD_VAR 0 7
117686: ARRAY
117687: PPUSH
117688: LD_VAR 0 14
117692: PUSH
117693: LD_VAR 0 8
117697: ARRAY
117698: PPUSH
117699: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117703: LD_ADDR_VAR 0 28
117707: PUSH
117708: LD_VAR 0 28
117712: PPUSH
117713: LD_VAR 0 28
117717: PUSH
117718: LD_INT 1
117720: PLUS
117721: PPUSH
117722: LD_VAR 0 14
117726: PUSH
117727: LD_VAR 0 8
117731: ARRAY
117732: PPUSH
117733: CALL_OW 1
117737: ST_TO_ADDR
// attacking := true ;
117738: LD_ADDR_VAR 0 29
117742: PUSH
117743: LD_INT 1
117745: ST_TO_ADDR
// break ;
117746: GO 117750
// end ; end ;
117748: GO 117617
117750: POP
117751: POP
// if not attacking and f_attack_depot then
117752: LD_VAR 0 29
117756: NOT
117757: PUSH
117758: LD_VAR 0 25
117762: AND
117763: IFFALSE 117858
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117765: LD_ADDR_VAR 0 13
117769: PUSH
117770: LD_VAR 0 14
117774: PPUSH
117775: LD_INT 2
117777: PUSH
117778: LD_INT 30
117780: PUSH
117781: LD_INT 0
117783: PUSH
117784: EMPTY
117785: LIST
117786: LIST
117787: PUSH
117788: LD_INT 30
117790: PUSH
117791: LD_INT 1
117793: PUSH
117794: EMPTY
117795: LIST
117796: LIST
117797: PUSH
117798: EMPTY
117799: LIST
117800: LIST
117801: LIST
117802: PPUSH
117803: CALL_OW 72
117807: ST_TO_ADDR
// if z then
117808: LD_VAR 0 13
117812: IFFALSE 117858
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
117814: LD_VAR 0 4
117818: PUSH
117819: LD_VAR 0 7
117823: ARRAY
117824: PPUSH
117825: LD_VAR 0 13
117829: PPUSH
117830: LD_VAR 0 4
117834: PUSH
117835: LD_VAR 0 7
117839: ARRAY
117840: PPUSH
117841: CALL_OW 74
117845: PPUSH
117846: CALL_OW 115
// attacking := true ;
117850: LD_ADDR_VAR 0 29
117854: PUSH
117855: LD_INT 1
117857: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117858: LD_VAR 0 4
117862: PUSH
117863: LD_VAR 0 7
117867: ARRAY
117868: PPUSH
117869: CALL_OW 256
117873: PUSH
117874: LD_INT 500
117876: LESS
117877: IFFALSE 117903
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117879: LD_VAR 0 4
117883: PUSH
117884: LD_VAR 0 7
117888: ARRAY
117889: PPUSH
117890: LD_VAR 0 14
117894: PUSH
117895: LD_INT 1
117897: ARRAY
117898: PPUSH
117899: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117903: LD_VAR 0 4
117907: PUSH
117908: LD_VAR 0 7
117912: ARRAY
117913: PPUSH
117914: CALL_OW 264
117918: PUSH
117919: LD_INT 49
117921: EQUAL
117922: IFFALSE 118043
// begin if not HasTask ( group [ i ] ) then
117924: LD_VAR 0 4
117928: PUSH
117929: LD_VAR 0 7
117933: ARRAY
117934: PPUSH
117935: CALL_OW 314
117939: NOT
117940: IFFALSE 118043
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117942: LD_ADDR_VAR 0 9
117946: PUSH
117947: LD_INT 81
117949: PUSH
117950: LD_VAR 0 4
117954: PUSH
117955: LD_VAR 0 7
117959: ARRAY
117960: PPUSH
117961: CALL_OW 255
117965: PUSH
117966: EMPTY
117967: LIST
117968: LIST
117969: PPUSH
117970: CALL_OW 69
117974: PPUSH
117975: LD_VAR 0 4
117979: PUSH
117980: LD_VAR 0 7
117984: ARRAY
117985: PPUSH
117986: CALL_OW 74
117990: ST_TO_ADDR
// if k then
117991: LD_VAR 0 9
117995: IFFALSE 118043
// if GetDistUnits ( group [ i ] , k ) > 10 then
117997: LD_VAR 0 4
118001: PUSH
118002: LD_VAR 0 7
118006: ARRAY
118007: PPUSH
118008: LD_VAR 0 9
118012: PPUSH
118013: CALL_OW 296
118017: PUSH
118018: LD_INT 10
118020: GREATER
118021: IFFALSE 118043
// ComMoveUnit ( group [ i ] , k ) ;
118023: LD_VAR 0 4
118027: PUSH
118028: LD_VAR 0 7
118032: ARRAY
118033: PPUSH
118034: LD_VAR 0 9
118038: PPUSH
118039: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
118043: LD_VAR 0 4
118047: PUSH
118048: LD_VAR 0 7
118052: ARRAY
118053: PPUSH
118054: CALL_OW 256
118058: PUSH
118059: LD_INT 250
118061: LESS
118062: PUSH
118063: LD_VAR 0 4
118067: PUSH
118068: LD_VAR 0 7
118072: ARRAY
118073: PUSH
118074: LD_INT 21
118076: PUSH
118077: LD_INT 2
118079: PUSH
118080: EMPTY
118081: LIST
118082: LIST
118083: PUSH
118084: LD_INT 23
118086: PUSH
118087: LD_INT 2
118089: PUSH
118090: EMPTY
118091: LIST
118092: LIST
118093: PUSH
118094: EMPTY
118095: LIST
118096: LIST
118097: PPUSH
118098: CALL_OW 69
118102: IN
118103: AND
118104: IFFALSE 118229
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
118106: LD_ADDR_VAR 0 9
118110: PUSH
118111: LD_OWVAR 3
118115: PUSH
118116: LD_VAR 0 4
118120: PUSH
118121: LD_VAR 0 7
118125: ARRAY
118126: DIFF
118127: PPUSH
118128: LD_VAR 0 4
118132: PUSH
118133: LD_VAR 0 7
118137: ARRAY
118138: PPUSH
118139: CALL_OW 74
118143: ST_TO_ADDR
// if not k then
118144: LD_VAR 0 9
118148: NOT
118149: IFFALSE 118153
// continue ;
118151: GO 114568
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
118153: LD_VAR 0 9
118157: PUSH
118158: LD_INT 81
118160: PUSH
118161: LD_VAR 0 4
118165: PUSH
118166: LD_VAR 0 7
118170: ARRAY
118171: PPUSH
118172: CALL_OW 255
118176: PUSH
118177: EMPTY
118178: LIST
118179: LIST
118180: PPUSH
118181: CALL_OW 69
118185: IN
118186: PUSH
118187: LD_VAR 0 9
118191: PPUSH
118192: LD_VAR 0 4
118196: PUSH
118197: LD_VAR 0 7
118201: ARRAY
118202: PPUSH
118203: CALL_OW 296
118207: PUSH
118208: LD_INT 5
118210: LESS
118211: AND
118212: IFFALSE 118229
// ComAutodestruct ( group [ i ] ) ;
118214: LD_VAR 0 4
118218: PUSH
118219: LD_VAR 0 7
118223: ARRAY
118224: PPUSH
118225: CALL 53042 0 1
// end ; if f_attack_depot then
118229: LD_VAR 0 25
118233: IFFALSE 118345
// begin k := 6 ;
118235: LD_ADDR_VAR 0 9
118239: PUSH
118240: LD_INT 6
118242: ST_TO_ADDR
// if tmp < k then
118243: LD_VAR 0 14
118247: PUSH
118248: LD_VAR 0 9
118252: LESS
118253: IFFALSE 118265
// k := tmp ;
118255: LD_ADDR_VAR 0 9
118259: PUSH
118260: LD_VAR 0 14
118264: ST_TO_ADDR
// for j = 1 to k do
118265: LD_ADDR_VAR 0 8
118269: PUSH
118270: DOUBLE
118271: LD_INT 1
118273: DEC
118274: ST_TO_ADDR
118275: LD_VAR 0 9
118279: PUSH
118280: FOR_TO
118281: IFFALSE 118343
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
118283: LD_VAR 0 8
118287: PPUSH
118288: CALL_OW 266
118292: PUSH
118293: LD_INT 0
118295: PUSH
118296: LD_INT 1
118298: PUSH
118299: EMPTY
118300: LIST
118301: LIST
118302: IN
118303: IFFALSE 118341
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118305: LD_VAR 0 4
118309: PUSH
118310: LD_VAR 0 7
118314: ARRAY
118315: PPUSH
118316: LD_VAR 0 14
118320: PUSH
118321: LD_VAR 0 8
118325: ARRAY
118326: PPUSH
118327: CALL_OW 115
// attacking := true ;
118331: LD_ADDR_VAR 0 29
118335: PUSH
118336: LD_INT 1
118338: ST_TO_ADDR
// break ;
118339: GO 118343
// end ;
118341: GO 118280
118343: POP
118344: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
118345: LD_VAR 0 4
118349: PUSH
118350: LD_VAR 0 7
118354: ARRAY
118355: PPUSH
118356: CALL_OW 302
118360: PUSH
118361: LD_VAR 0 29
118365: NOT
118366: AND
118367: IFFALSE 118689
// begin if GetTag ( group [ i ] ) = 71 then
118369: LD_VAR 0 4
118373: PUSH
118374: LD_VAR 0 7
118378: ARRAY
118379: PPUSH
118380: CALL_OW 110
118384: PUSH
118385: LD_INT 71
118387: EQUAL
118388: IFFALSE 118429
// begin if HasTask ( group [ i ] ) then
118390: LD_VAR 0 4
118394: PUSH
118395: LD_VAR 0 7
118399: ARRAY
118400: PPUSH
118401: CALL_OW 314
118405: IFFALSE 118411
// continue else
118407: GO 114568
118409: GO 118429
// SetTag ( group [ i ] , 0 ) ;
118411: LD_VAR 0 4
118415: PUSH
118416: LD_VAR 0 7
118420: ARRAY
118421: PPUSH
118422: LD_INT 0
118424: PPUSH
118425: CALL_OW 109
// end ; k := 8 ;
118429: LD_ADDR_VAR 0 9
118433: PUSH
118434: LD_INT 8
118436: ST_TO_ADDR
// x := 0 ;
118437: LD_ADDR_VAR 0 10
118441: PUSH
118442: LD_INT 0
118444: ST_TO_ADDR
// if tmp < k then
118445: LD_VAR 0 14
118449: PUSH
118450: LD_VAR 0 9
118454: LESS
118455: IFFALSE 118467
// k := tmp ;
118457: LD_ADDR_VAR 0 9
118461: PUSH
118462: LD_VAR 0 14
118466: ST_TO_ADDR
// for j = 1 to k do
118467: LD_ADDR_VAR 0 8
118471: PUSH
118472: DOUBLE
118473: LD_INT 1
118475: DEC
118476: ST_TO_ADDR
118477: LD_VAR 0 9
118481: PUSH
118482: FOR_TO
118483: IFFALSE 118581
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118485: LD_VAR 0 14
118489: PUSH
118490: LD_VAR 0 8
118494: ARRAY
118495: PPUSH
118496: CALL_OW 247
118500: PUSH
118501: LD_INT 1
118503: EQUAL
118504: PUSH
118505: LD_VAR 0 14
118509: PUSH
118510: LD_VAR 0 8
118514: ARRAY
118515: PPUSH
118516: CALL_OW 256
118520: PUSH
118521: LD_INT 250
118523: LESS
118524: PUSH
118525: LD_VAR 0 20
118529: AND
118530: PUSH
118531: LD_VAR 0 20
118535: NOT
118536: PUSH
118537: LD_VAR 0 14
118541: PUSH
118542: LD_VAR 0 8
118546: ARRAY
118547: PPUSH
118548: CALL_OW 256
118552: PUSH
118553: LD_INT 250
118555: GREATEREQUAL
118556: AND
118557: OR
118558: AND
118559: IFFALSE 118579
// begin x := tmp [ j ] ;
118561: LD_ADDR_VAR 0 10
118565: PUSH
118566: LD_VAR 0 14
118570: PUSH
118571: LD_VAR 0 8
118575: ARRAY
118576: ST_TO_ADDR
// break ;
118577: GO 118581
// end ;
118579: GO 118482
118581: POP
118582: POP
// if x then
118583: LD_VAR 0 10
118587: IFFALSE 118611
// ComAttackUnit ( group [ i ] , x ) else
118589: LD_VAR 0 4
118593: PUSH
118594: LD_VAR 0 7
118598: ARRAY
118599: PPUSH
118600: LD_VAR 0 10
118604: PPUSH
118605: CALL_OW 115
118609: GO 118635
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118611: LD_VAR 0 4
118615: PUSH
118616: LD_VAR 0 7
118620: ARRAY
118621: PPUSH
118622: LD_VAR 0 14
118626: PUSH
118627: LD_INT 1
118629: ARRAY
118630: PPUSH
118631: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118635: LD_VAR 0 4
118639: PUSH
118640: LD_VAR 0 7
118644: ARRAY
118645: PPUSH
118646: CALL_OW 314
118650: NOT
118651: IFFALSE 118689
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118653: LD_VAR 0 4
118657: PUSH
118658: LD_VAR 0 7
118662: ARRAY
118663: PPUSH
118664: LD_VAR 0 14
118668: PPUSH
118669: LD_VAR 0 4
118673: PUSH
118674: LD_VAR 0 7
118678: ARRAY
118679: PPUSH
118680: CALL_OW 74
118684: PPUSH
118685: CALL_OW 115
// end ; end ; end ;
118689: GO 114568
118691: POP
118692: POP
// wait ( 0 0$2 ) ;
118693: LD_INT 70
118695: PPUSH
118696: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118700: LD_VAR 0 4
118704: NOT
118705: PUSH
118706: LD_VAR 0 4
118710: PUSH
118711: EMPTY
118712: EQUAL
118713: OR
118714: PUSH
118715: LD_INT 81
118717: PUSH
118718: LD_VAR 0 35
118722: PUSH
118723: EMPTY
118724: LIST
118725: LIST
118726: PPUSH
118727: CALL_OW 69
118731: NOT
118732: OR
118733: IFFALSE 114553
// end ;
118735: LD_VAR 0 2
118739: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
118740: LD_INT 0
118742: PPUSH
118743: PPUSH
118744: PPUSH
118745: PPUSH
118746: PPUSH
118747: PPUSH
// if not base or not mc_bases [ base ] or not solds then
118748: LD_VAR 0 1
118752: NOT
118753: PUSH
118754: LD_EXP 31
118758: PUSH
118759: LD_VAR 0 1
118763: ARRAY
118764: NOT
118765: OR
118766: PUSH
118767: LD_VAR 0 2
118771: NOT
118772: OR
118773: IFFALSE 118777
// exit ;
118775: GO 119331
// side := mc_sides [ base ] ;
118777: LD_ADDR_VAR 0 6
118781: PUSH
118782: LD_EXP 57
118786: PUSH
118787: LD_VAR 0 1
118791: ARRAY
118792: ST_TO_ADDR
// if not side then
118793: LD_VAR 0 6
118797: NOT
118798: IFFALSE 118802
// exit ;
118800: GO 119331
// for i in solds do
118802: LD_ADDR_VAR 0 7
118806: PUSH
118807: LD_VAR 0 2
118811: PUSH
118812: FOR_IN
118813: IFFALSE 118874
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118815: LD_VAR 0 7
118819: PPUSH
118820: CALL_OW 310
118824: PPUSH
118825: CALL_OW 266
118829: PUSH
118830: LD_INT 32
118832: PUSH
118833: LD_INT 31
118835: PUSH
118836: EMPTY
118837: LIST
118838: LIST
118839: IN
118840: IFFALSE 118860
// solds := solds diff i else
118842: LD_ADDR_VAR 0 2
118846: PUSH
118847: LD_VAR 0 2
118851: PUSH
118852: LD_VAR 0 7
118856: DIFF
118857: ST_TO_ADDR
118858: GO 118872
// SetTag ( i , 18 ) ;
118860: LD_VAR 0 7
118864: PPUSH
118865: LD_INT 18
118867: PPUSH
118868: CALL_OW 109
118872: GO 118812
118874: POP
118875: POP
// if not solds then
118876: LD_VAR 0 2
118880: NOT
118881: IFFALSE 118885
// exit ;
118883: GO 119331
// repeat wait ( 0 0$2 ) ;
118885: LD_INT 70
118887: PPUSH
118888: CALL_OW 67
// enemy := mc_scan [ base ] ;
118892: LD_ADDR_VAR 0 4
118896: PUSH
118897: LD_EXP 54
118901: PUSH
118902: LD_VAR 0 1
118906: ARRAY
118907: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118908: LD_EXP 31
118912: PUSH
118913: LD_VAR 0 1
118917: ARRAY
118918: NOT
118919: PUSH
118920: LD_EXP 31
118924: PUSH
118925: LD_VAR 0 1
118929: ARRAY
118930: PUSH
118931: EMPTY
118932: EQUAL
118933: OR
118934: IFFALSE 118971
// begin for i in solds do
118936: LD_ADDR_VAR 0 7
118940: PUSH
118941: LD_VAR 0 2
118945: PUSH
118946: FOR_IN
118947: IFFALSE 118960
// ComStop ( i ) ;
118949: LD_VAR 0 7
118953: PPUSH
118954: CALL_OW 141
118958: GO 118946
118960: POP
118961: POP
// solds := [ ] ;
118962: LD_ADDR_VAR 0 2
118966: PUSH
118967: EMPTY
118968: ST_TO_ADDR
// exit ;
118969: GO 119331
// end ; for i in solds do
118971: LD_ADDR_VAR 0 7
118975: PUSH
118976: LD_VAR 0 2
118980: PUSH
118981: FOR_IN
118982: IFFALSE 119303
// begin if IsInUnit ( i ) then
118984: LD_VAR 0 7
118988: PPUSH
118989: CALL_OW 310
118993: IFFALSE 119004
// ComExitBuilding ( i ) ;
118995: LD_VAR 0 7
118999: PPUSH
119000: CALL_OW 122
// if GetLives ( i ) > 500 then
119004: LD_VAR 0 7
119008: PPUSH
119009: CALL_OW 256
119013: PUSH
119014: LD_INT 500
119016: GREATER
119017: IFFALSE 119070
// begin e := NearestUnitToUnit ( enemy , i ) ;
119019: LD_ADDR_VAR 0 5
119023: PUSH
119024: LD_VAR 0 4
119028: PPUSH
119029: LD_VAR 0 7
119033: PPUSH
119034: CALL_OW 74
119038: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
119039: LD_VAR 0 7
119043: PPUSH
119044: LD_VAR 0 5
119048: PPUSH
119049: CALL_OW 250
119053: PPUSH
119054: LD_VAR 0 5
119058: PPUSH
119059: CALL_OW 251
119063: PPUSH
119064: CALL_OW 114
// end else
119068: GO 119301
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
119070: LD_VAR 0 7
119074: PPUSH
119075: LD_EXP 31
119079: PUSH
119080: LD_VAR 0 1
119084: ARRAY
119085: PPUSH
119086: LD_INT 2
119088: PUSH
119089: LD_INT 30
119091: PUSH
119092: LD_INT 0
119094: PUSH
119095: EMPTY
119096: LIST
119097: LIST
119098: PUSH
119099: LD_INT 30
119101: PUSH
119102: LD_INT 1
119104: PUSH
119105: EMPTY
119106: LIST
119107: LIST
119108: PUSH
119109: LD_INT 30
119111: PUSH
119112: LD_INT 6
119114: PUSH
119115: EMPTY
119116: LIST
119117: LIST
119118: PUSH
119119: EMPTY
119120: LIST
119121: LIST
119122: LIST
119123: LIST
119124: PPUSH
119125: CALL_OW 72
119129: PPUSH
119130: LD_VAR 0 7
119134: PPUSH
119135: CALL_OW 74
119139: PPUSH
119140: CALL_OW 296
119144: PUSH
119145: LD_INT 10
119147: GREATER
119148: IFFALSE 119301
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
119150: LD_ADDR_VAR 0 8
119154: PUSH
119155: LD_EXP 31
119159: PUSH
119160: LD_VAR 0 1
119164: ARRAY
119165: PPUSH
119166: LD_INT 2
119168: PUSH
119169: LD_INT 30
119171: PUSH
119172: LD_INT 0
119174: PUSH
119175: EMPTY
119176: LIST
119177: LIST
119178: PUSH
119179: LD_INT 30
119181: PUSH
119182: LD_INT 1
119184: PUSH
119185: EMPTY
119186: LIST
119187: LIST
119188: PUSH
119189: LD_INT 30
119191: PUSH
119192: LD_INT 6
119194: PUSH
119195: EMPTY
119196: LIST
119197: LIST
119198: PUSH
119199: EMPTY
119200: LIST
119201: LIST
119202: LIST
119203: LIST
119204: PPUSH
119205: CALL_OW 72
119209: PPUSH
119210: LD_VAR 0 7
119214: PPUSH
119215: CALL_OW 74
119219: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
119220: LD_VAR 0 7
119224: PPUSH
119225: LD_VAR 0 8
119229: PPUSH
119230: CALL_OW 250
119234: PPUSH
119235: LD_INT 3
119237: PPUSH
119238: LD_INT 5
119240: PPUSH
119241: CALL_OW 272
119245: PPUSH
119246: LD_VAR 0 8
119250: PPUSH
119251: CALL_OW 251
119255: PPUSH
119256: LD_INT 3
119258: PPUSH
119259: LD_INT 5
119261: PPUSH
119262: CALL_OW 273
119266: PPUSH
119267: CALL_OW 111
// SetTag ( i , 0 ) ;
119271: LD_VAR 0 7
119275: PPUSH
119276: LD_INT 0
119278: PPUSH
119279: CALL_OW 109
// solds := solds diff i ;
119283: LD_ADDR_VAR 0 2
119287: PUSH
119288: LD_VAR 0 2
119292: PUSH
119293: LD_VAR 0 7
119297: DIFF
119298: ST_TO_ADDR
// continue ;
119299: GO 118981
// end ; end ;
119301: GO 118981
119303: POP
119304: POP
// until not solds or not enemy ;
119305: LD_VAR 0 2
119309: NOT
119310: PUSH
119311: LD_VAR 0 4
119315: NOT
119316: OR
119317: IFFALSE 118885
// MC_Reset ( base , 18 ) ;
119319: LD_VAR 0 1
119323: PPUSH
119324: LD_INT 18
119326: PPUSH
119327: CALL 66779 0 2
// end ;
119331: LD_VAR 0 3
119335: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
119336: LD_INT 0
119338: PPUSH
119339: PPUSH
119340: PPUSH
119341: PPUSH
119342: PPUSH
119343: PPUSH
119344: PPUSH
119345: PPUSH
119346: PPUSH
119347: PPUSH
119348: PPUSH
119349: PPUSH
119350: PPUSH
119351: PPUSH
119352: PPUSH
119353: PPUSH
119354: PPUSH
119355: PPUSH
119356: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
119357: LD_ADDR_VAR 0 12
119361: PUSH
119362: LD_EXP 31
119366: PUSH
119367: LD_VAR 0 1
119371: ARRAY
119372: PPUSH
119373: LD_INT 25
119375: PUSH
119376: LD_INT 3
119378: PUSH
119379: EMPTY
119380: LIST
119381: LIST
119382: PPUSH
119383: CALL_OW 72
119387: ST_TO_ADDR
// if mc_remote_driver [ base ] then
119388: LD_EXP 71
119392: PUSH
119393: LD_VAR 0 1
119397: ARRAY
119398: IFFALSE 119422
// mechs := mechs diff mc_remote_driver [ base ] ;
119400: LD_ADDR_VAR 0 12
119404: PUSH
119405: LD_VAR 0 12
119409: PUSH
119410: LD_EXP 71
119414: PUSH
119415: LD_VAR 0 1
119419: ARRAY
119420: DIFF
119421: ST_TO_ADDR
// for i in mechs do
119422: LD_ADDR_VAR 0 4
119426: PUSH
119427: LD_VAR 0 12
119431: PUSH
119432: FOR_IN
119433: IFFALSE 119468
// if GetTag ( i ) > 0 then
119435: LD_VAR 0 4
119439: PPUSH
119440: CALL_OW 110
119444: PUSH
119445: LD_INT 0
119447: GREATER
119448: IFFALSE 119466
// mechs := mechs diff i ;
119450: LD_ADDR_VAR 0 12
119454: PUSH
119455: LD_VAR 0 12
119459: PUSH
119460: LD_VAR 0 4
119464: DIFF
119465: ST_TO_ADDR
119466: GO 119432
119468: POP
119469: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119470: LD_ADDR_VAR 0 8
119474: PUSH
119475: LD_EXP 31
119479: PUSH
119480: LD_VAR 0 1
119484: ARRAY
119485: PPUSH
119486: LD_INT 2
119488: PUSH
119489: LD_INT 25
119491: PUSH
119492: LD_INT 1
119494: PUSH
119495: EMPTY
119496: LIST
119497: LIST
119498: PUSH
119499: LD_INT 25
119501: PUSH
119502: LD_INT 5
119504: PUSH
119505: EMPTY
119506: LIST
119507: LIST
119508: PUSH
119509: LD_INT 25
119511: PUSH
119512: LD_INT 8
119514: PUSH
119515: EMPTY
119516: LIST
119517: LIST
119518: PUSH
119519: LD_INT 25
119521: PUSH
119522: LD_INT 9
119524: PUSH
119525: EMPTY
119526: LIST
119527: LIST
119528: PUSH
119529: EMPTY
119530: LIST
119531: LIST
119532: LIST
119533: LIST
119534: LIST
119535: PPUSH
119536: CALL_OW 72
119540: ST_TO_ADDR
// if not defenders and not solds then
119541: LD_VAR 0 2
119545: NOT
119546: PUSH
119547: LD_VAR 0 8
119551: NOT
119552: AND
119553: IFFALSE 119557
// exit ;
119555: GO 121327
// depot_under_attack := false ;
119557: LD_ADDR_VAR 0 16
119561: PUSH
119562: LD_INT 0
119564: ST_TO_ADDR
// sold_defenders := [ ] ;
119565: LD_ADDR_VAR 0 17
119569: PUSH
119570: EMPTY
119571: ST_TO_ADDR
// if mechs then
119572: LD_VAR 0 12
119576: IFFALSE 119729
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119578: LD_ADDR_VAR 0 4
119582: PUSH
119583: LD_VAR 0 2
119587: PPUSH
119588: LD_INT 21
119590: PUSH
119591: LD_INT 2
119593: PUSH
119594: EMPTY
119595: LIST
119596: LIST
119597: PPUSH
119598: CALL_OW 72
119602: PUSH
119603: FOR_IN
119604: IFFALSE 119727
// begin if GetTag ( i ) <> 20 then
119606: LD_VAR 0 4
119610: PPUSH
119611: CALL_OW 110
119615: PUSH
119616: LD_INT 20
119618: NONEQUAL
119619: IFFALSE 119633
// SetTag ( i , 20 ) ;
119621: LD_VAR 0 4
119625: PPUSH
119626: LD_INT 20
119628: PPUSH
119629: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119633: LD_VAR 0 4
119637: PPUSH
119638: CALL_OW 263
119642: PUSH
119643: LD_INT 1
119645: EQUAL
119646: PUSH
119647: LD_VAR 0 4
119651: PPUSH
119652: CALL_OW 311
119656: NOT
119657: AND
119658: IFFALSE 119725
// begin un := mechs [ 1 ] ;
119660: LD_ADDR_VAR 0 10
119664: PUSH
119665: LD_VAR 0 12
119669: PUSH
119670: LD_INT 1
119672: ARRAY
119673: ST_TO_ADDR
// ComExit ( un ) ;
119674: LD_VAR 0 10
119678: PPUSH
119679: CALL 57928 0 1
// AddComEnterUnit ( un , i ) ;
119683: LD_VAR 0 10
119687: PPUSH
119688: LD_VAR 0 4
119692: PPUSH
119693: CALL_OW 180
// SetTag ( un , 19 ) ;
119697: LD_VAR 0 10
119701: PPUSH
119702: LD_INT 19
119704: PPUSH
119705: CALL_OW 109
// mechs := mechs diff un ;
119709: LD_ADDR_VAR 0 12
119713: PUSH
119714: LD_VAR 0 12
119718: PUSH
119719: LD_VAR 0 10
119723: DIFF
119724: ST_TO_ADDR
// end ; end ;
119725: GO 119603
119727: POP
119728: POP
// if solds then
119729: LD_VAR 0 8
119733: IFFALSE 119792
// for i in solds do
119735: LD_ADDR_VAR 0 4
119739: PUSH
119740: LD_VAR 0 8
119744: PUSH
119745: FOR_IN
119746: IFFALSE 119790
// if not GetTag ( i ) then
119748: LD_VAR 0 4
119752: PPUSH
119753: CALL_OW 110
119757: NOT
119758: IFFALSE 119788
// begin defenders := defenders union i ;
119760: LD_ADDR_VAR 0 2
119764: PUSH
119765: LD_VAR 0 2
119769: PUSH
119770: LD_VAR 0 4
119774: UNION
119775: ST_TO_ADDR
// SetTag ( i , 18 ) ;
119776: LD_VAR 0 4
119780: PPUSH
119781: LD_INT 18
119783: PPUSH
119784: CALL_OW 109
// end ;
119788: GO 119745
119790: POP
119791: POP
// repeat wait ( 0 0$2 ) ;
119792: LD_INT 70
119794: PPUSH
119795: CALL_OW 67
// enemy := mc_scan [ base ] ;
119799: LD_ADDR_VAR 0 21
119803: PUSH
119804: LD_EXP 54
119808: PUSH
119809: LD_VAR 0 1
119813: ARRAY
119814: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119815: LD_EXP 31
119819: PUSH
119820: LD_VAR 0 1
119824: ARRAY
119825: NOT
119826: PUSH
119827: LD_EXP 31
119831: PUSH
119832: LD_VAR 0 1
119836: ARRAY
119837: PUSH
119838: EMPTY
119839: EQUAL
119840: OR
119841: IFFALSE 119878
// begin for i in defenders do
119843: LD_ADDR_VAR 0 4
119847: PUSH
119848: LD_VAR 0 2
119852: PUSH
119853: FOR_IN
119854: IFFALSE 119867
// ComStop ( i ) ;
119856: LD_VAR 0 4
119860: PPUSH
119861: CALL_OW 141
119865: GO 119853
119867: POP
119868: POP
// defenders := [ ] ;
119869: LD_ADDR_VAR 0 2
119873: PUSH
119874: EMPTY
119875: ST_TO_ADDR
// exit ;
119876: GO 121327
// end ; for i in defenders do
119878: LD_ADDR_VAR 0 4
119882: PUSH
119883: LD_VAR 0 2
119887: PUSH
119888: FOR_IN
119889: IFFALSE 120787
// begin e := NearestUnitToUnit ( enemy , i ) ;
119891: LD_ADDR_VAR 0 13
119895: PUSH
119896: LD_VAR 0 21
119900: PPUSH
119901: LD_VAR 0 4
119905: PPUSH
119906: CALL_OW 74
119910: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119911: LD_ADDR_VAR 0 7
119915: PUSH
119916: LD_EXP 31
119920: PUSH
119921: LD_VAR 0 1
119925: ARRAY
119926: PPUSH
119927: LD_INT 2
119929: PUSH
119930: LD_INT 30
119932: PUSH
119933: LD_INT 0
119935: PUSH
119936: EMPTY
119937: LIST
119938: LIST
119939: PUSH
119940: LD_INT 30
119942: PUSH
119943: LD_INT 1
119945: PUSH
119946: EMPTY
119947: LIST
119948: LIST
119949: PUSH
119950: EMPTY
119951: LIST
119952: LIST
119953: LIST
119954: PPUSH
119955: CALL_OW 72
119959: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119960: LD_ADDR_VAR 0 16
119964: PUSH
119965: LD_VAR 0 7
119969: NOT
119970: PUSH
119971: LD_VAR 0 7
119975: PPUSH
119976: LD_INT 3
119978: PUSH
119979: LD_INT 24
119981: PUSH
119982: LD_INT 600
119984: PUSH
119985: EMPTY
119986: LIST
119987: LIST
119988: PUSH
119989: EMPTY
119990: LIST
119991: LIST
119992: PPUSH
119993: CALL_OW 72
119997: OR
119998: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119999: LD_VAR 0 4
120003: PPUSH
120004: CALL_OW 247
120008: PUSH
120009: LD_INT 2
120011: DOUBLE
120012: EQUAL
120013: IFTRUE 120017
120015: GO 120413
120017: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
120018: LD_VAR 0 4
120022: PPUSH
120023: CALL_OW 256
120027: PUSH
120028: LD_INT 1000
120030: EQUAL
120031: PUSH
120032: LD_VAR 0 4
120036: PPUSH
120037: LD_VAR 0 13
120041: PPUSH
120042: CALL_OW 296
120046: PUSH
120047: LD_INT 40
120049: LESS
120050: PUSH
120051: LD_VAR 0 13
120055: PPUSH
120056: LD_EXP 56
120060: PUSH
120061: LD_VAR 0 1
120065: ARRAY
120066: PPUSH
120067: CALL_OW 308
120071: OR
120072: AND
120073: IFFALSE 120195
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
120075: LD_VAR 0 4
120079: PPUSH
120080: CALL_OW 262
120084: PUSH
120085: LD_INT 1
120087: EQUAL
120088: PUSH
120089: LD_VAR 0 4
120093: PPUSH
120094: CALL_OW 261
120098: PUSH
120099: LD_INT 30
120101: LESS
120102: AND
120103: PUSH
120104: LD_VAR 0 7
120108: AND
120109: IFFALSE 120179
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
120111: LD_VAR 0 4
120115: PPUSH
120116: LD_VAR 0 7
120120: PPUSH
120121: LD_VAR 0 4
120125: PPUSH
120126: CALL_OW 74
120130: PPUSH
120131: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
120135: LD_VAR 0 4
120139: PPUSH
120140: LD_VAR 0 7
120144: PPUSH
120145: LD_VAR 0 4
120149: PPUSH
120150: CALL_OW 74
120154: PPUSH
120155: CALL_OW 296
120159: PUSH
120160: LD_INT 6
120162: LESS
120163: IFFALSE 120177
// SetFuel ( i , 100 ) ;
120165: LD_VAR 0 4
120169: PPUSH
120170: LD_INT 100
120172: PPUSH
120173: CALL_OW 240
// end else
120177: GO 120193
// ComAttackUnit ( i , e ) ;
120179: LD_VAR 0 4
120183: PPUSH
120184: LD_VAR 0 13
120188: PPUSH
120189: CALL_OW 115
// end else
120193: GO 120296
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
120195: LD_VAR 0 13
120199: PPUSH
120200: LD_EXP 56
120204: PUSH
120205: LD_VAR 0 1
120209: ARRAY
120210: PPUSH
120211: CALL_OW 308
120215: NOT
120216: PUSH
120217: LD_VAR 0 4
120221: PPUSH
120222: LD_VAR 0 13
120226: PPUSH
120227: CALL_OW 296
120231: PUSH
120232: LD_INT 40
120234: GREATEREQUAL
120235: AND
120236: PUSH
120237: LD_VAR 0 4
120241: PPUSH
120242: CALL_OW 256
120246: PUSH
120247: LD_INT 650
120249: LESSEQUAL
120250: OR
120251: PUSH
120252: LD_VAR 0 4
120256: PPUSH
120257: LD_EXP 55
120261: PUSH
120262: LD_VAR 0 1
120266: ARRAY
120267: PPUSH
120268: CALL_OW 308
120272: NOT
120273: AND
120274: IFFALSE 120296
// ComMoveToArea ( i , mc_parking [ base ] ) ;
120276: LD_VAR 0 4
120280: PPUSH
120281: LD_EXP 55
120285: PUSH
120286: LD_VAR 0 1
120290: ARRAY
120291: PPUSH
120292: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
120296: LD_VAR 0 4
120300: PPUSH
120301: CALL_OW 256
120305: PUSH
120306: LD_INT 1000
120308: LESS
120309: PUSH
120310: LD_VAR 0 4
120314: PPUSH
120315: CALL_OW 263
120319: PUSH
120320: LD_INT 1
120322: EQUAL
120323: AND
120324: PUSH
120325: LD_VAR 0 4
120329: PPUSH
120330: CALL_OW 311
120334: AND
120335: PUSH
120336: LD_VAR 0 4
120340: PPUSH
120341: LD_EXP 55
120345: PUSH
120346: LD_VAR 0 1
120350: ARRAY
120351: PPUSH
120352: CALL_OW 308
120356: AND
120357: IFFALSE 120411
// begin mech := IsDrivenBy ( i ) ;
120359: LD_ADDR_VAR 0 9
120363: PUSH
120364: LD_VAR 0 4
120368: PPUSH
120369: CALL_OW 311
120373: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
120374: LD_VAR 0 9
120378: PPUSH
120379: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
120383: LD_VAR 0 9
120387: PPUSH
120388: LD_VAR 0 4
120392: PPUSH
120393: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
120397: LD_VAR 0 9
120401: PPUSH
120402: LD_VAR 0 4
120406: PPUSH
120407: CALL_OW 180
// end ; end ; unit_human :
120411: GO 120758
120413: LD_INT 1
120415: DOUBLE
120416: EQUAL
120417: IFTRUE 120421
120419: GO 120757
120421: POP
// begin b := IsInUnit ( i ) ;
120422: LD_ADDR_VAR 0 18
120426: PUSH
120427: LD_VAR 0 4
120431: PPUSH
120432: CALL_OW 310
120436: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
120437: LD_ADDR_VAR 0 19
120441: PUSH
120442: LD_VAR 0 18
120446: NOT
120447: PUSH
120448: LD_VAR 0 18
120452: PPUSH
120453: CALL_OW 266
120457: PUSH
120458: LD_INT 32
120460: PUSH
120461: LD_INT 31
120463: PUSH
120464: EMPTY
120465: LIST
120466: LIST
120467: IN
120468: OR
120469: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120470: LD_VAR 0 18
120474: PPUSH
120475: CALL_OW 266
120479: PUSH
120480: LD_INT 5
120482: EQUAL
120483: PUSH
120484: LD_VAR 0 4
120488: PPUSH
120489: CALL_OW 257
120493: PUSH
120494: LD_INT 1
120496: PUSH
120497: LD_INT 2
120499: PUSH
120500: LD_INT 3
120502: PUSH
120503: LD_INT 4
120505: PUSH
120506: EMPTY
120507: LIST
120508: LIST
120509: LIST
120510: LIST
120511: IN
120512: AND
120513: IFFALSE 120550
// begin class := AllowSpecClass ( i ) ;
120515: LD_ADDR_VAR 0 20
120519: PUSH
120520: LD_VAR 0 4
120524: PPUSH
120525: CALL 21625 0 1
120529: ST_TO_ADDR
// if class then
120530: LD_VAR 0 20
120534: IFFALSE 120550
// ComChangeProfession ( i , class ) ;
120536: LD_VAR 0 4
120540: PPUSH
120541: LD_VAR 0 20
120545: PPUSH
120546: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120550: LD_VAR 0 16
120554: PUSH
120555: LD_VAR 0 2
120559: PPUSH
120560: LD_INT 21
120562: PUSH
120563: LD_INT 2
120565: PUSH
120566: EMPTY
120567: LIST
120568: LIST
120569: PPUSH
120570: CALL_OW 72
120574: PUSH
120575: LD_INT 1
120577: LESSEQUAL
120578: OR
120579: PUSH
120580: LD_VAR 0 19
120584: AND
120585: PUSH
120586: LD_VAR 0 4
120590: PUSH
120591: LD_VAR 0 17
120595: IN
120596: NOT
120597: AND
120598: IFFALSE 120691
// begin if b then
120600: LD_VAR 0 18
120604: IFFALSE 120653
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120606: LD_VAR 0 18
120610: PPUSH
120611: LD_VAR 0 21
120615: PPUSH
120616: LD_VAR 0 18
120620: PPUSH
120621: CALL_OW 74
120625: PPUSH
120626: CALL_OW 296
120630: PUSH
120631: LD_INT 10
120633: LESS
120634: PUSH
120635: LD_VAR 0 18
120639: PPUSH
120640: CALL_OW 461
120644: PUSH
120645: LD_INT 7
120647: NONEQUAL
120648: AND
120649: IFFALSE 120653
// continue ;
120651: GO 119888
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120653: LD_ADDR_VAR 0 17
120657: PUSH
120658: LD_VAR 0 17
120662: PPUSH
120663: LD_VAR 0 17
120667: PUSH
120668: LD_INT 1
120670: PLUS
120671: PPUSH
120672: LD_VAR 0 4
120676: PPUSH
120677: CALL_OW 1
120681: ST_TO_ADDR
// ComExitBuilding ( i ) ;
120682: LD_VAR 0 4
120686: PPUSH
120687: CALL_OW 122
// end ; if sold_defenders then
120691: LD_VAR 0 17
120695: IFFALSE 120755
// if i in sold_defenders then
120697: LD_VAR 0 4
120701: PUSH
120702: LD_VAR 0 17
120706: IN
120707: IFFALSE 120755
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
120709: LD_VAR 0 4
120713: PPUSH
120714: CALL_OW 314
120718: NOT
120719: PUSH
120720: LD_VAR 0 4
120724: PPUSH
120725: LD_VAR 0 13
120729: PPUSH
120730: CALL_OW 296
120734: PUSH
120735: LD_INT 30
120737: LESS
120738: AND
120739: IFFALSE 120755
// ComAttackUnit ( i , e ) ;
120741: LD_VAR 0 4
120745: PPUSH
120746: LD_VAR 0 13
120750: PPUSH
120751: CALL_OW 115
// end ; end ; end ;
120755: GO 120758
120757: POP
// if IsDead ( i ) then
120758: LD_VAR 0 4
120762: PPUSH
120763: CALL_OW 301
120767: IFFALSE 120785
// defenders := defenders diff i ;
120769: LD_ADDR_VAR 0 2
120773: PUSH
120774: LD_VAR 0 2
120778: PUSH
120779: LD_VAR 0 4
120783: DIFF
120784: ST_TO_ADDR
// end ;
120785: GO 119888
120787: POP
120788: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
120789: LD_VAR 0 21
120793: NOT
120794: PUSH
120795: LD_VAR 0 2
120799: NOT
120800: OR
120801: PUSH
120802: LD_EXP 31
120806: PUSH
120807: LD_VAR 0 1
120811: ARRAY
120812: NOT
120813: OR
120814: IFFALSE 119792
// MC_Reset ( base , 18 ) ;
120816: LD_VAR 0 1
120820: PPUSH
120821: LD_INT 18
120823: PPUSH
120824: CALL 66779 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120828: LD_ADDR_VAR 0 2
120832: PUSH
120833: LD_VAR 0 2
120837: PUSH
120838: LD_VAR 0 2
120842: PPUSH
120843: LD_INT 2
120845: PUSH
120846: LD_INT 25
120848: PUSH
120849: LD_INT 1
120851: PUSH
120852: EMPTY
120853: LIST
120854: LIST
120855: PUSH
120856: LD_INT 25
120858: PUSH
120859: LD_INT 5
120861: PUSH
120862: EMPTY
120863: LIST
120864: LIST
120865: PUSH
120866: LD_INT 25
120868: PUSH
120869: LD_INT 8
120871: PUSH
120872: EMPTY
120873: LIST
120874: LIST
120875: PUSH
120876: LD_INT 25
120878: PUSH
120879: LD_INT 9
120881: PUSH
120882: EMPTY
120883: LIST
120884: LIST
120885: PUSH
120886: EMPTY
120887: LIST
120888: LIST
120889: LIST
120890: LIST
120891: LIST
120892: PPUSH
120893: CALL_OW 72
120897: DIFF
120898: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120899: LD_VAR 0 21
120903: NOT
120904: PUSH
120905: LD_VAR 0 2
120909: PPUSH
120910: LD_INT 21
120912: PUSH
120913: LD_INT 2
120915: PUSH
120916: EMPTY
120917: LIST
120918: LIST
120919: PPUSH
120920: CALL_OW 72
120924: AND
120925: IFFALSE 121263
// begin tmp := FilterByTag ( defenders , 19 ) ;
120927: LD_ADDR_VAR 0 11
120931: PUSH
120932: LD_VAR 0 2
120936: PPUSH
120937: LD_INT 19
120939: PPUSH
120940: CALL 55099 0 2
120944: ST_TO_ADDR
// if tmp then
120945: LD_VAR 0 11
120949: IFFALSE 121019
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120951: LD_ADDR_VAR 0 11
120955: PUSH
120956: LD_VAR 0 11
120960: PPUSH
120961: LD_INT 25
120963: PUSH
120964: LD_INT 3
120966: PUSH
120967: EMPTY
120968: LIST
120969: LIST
120970: PPUSH
120971: CALL_OW 72
120975: ST_TO_ADDR
// if tmp then
120976: LD_VAR 0 11
120980: IFFALSE 121019
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120982: LD_ADDR_EXP 43
120986: PUSH
120987: LD_EXP 43
120991: PPUSH
120992: LD_VAR 0 1
120996: PPUSH
120997: LD_EXP 43
121001: PUSH
121002: LD_VAR 0 1
121006: ARRAY
121007: PUSH
121008: LD_VAR 0 11
121012: UNION
121013: PPUSH
121014: CALL_OW 1
121018: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
121019: LD_VAR 0 1
121023: PPUSH
121024: LD_INT 19
121026: PPUSH
121027: CALL 66779 0 2
// repeat wait ( 0 0$1 ) ;
121031: LD_INT 35
121033: PPUSH
121034: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121038: LD_EXP 31
121042: PUSH
121043: LD_VAR 0 1
121047: ARRAY
121048: NOT
121049: PUSH
121050: LD_EXP 31
121054: PUSH
121055: LD_VAR 0 1
121059: ARRAY
121060: PUSH
121061: EMPTY
121062: EQUAL
121063: OR
121064: IFFALSE 121101
// begin for i in defenders do
121066: LD_ADDR_VAR 0 4
121070: PUSH
121071: LD_VAR 0 2
121075: PUSH
121076: FOR_IN
121077: IFFALSE 121090
// ComStop ( i ) ;
121079: LD_VAR 0 4
121083: PPUSH
121084: CALL_OW 141
121088: GO 121076
121090: POP
121091: POP
// defenders := [ ] ;
121092: LD_ADDR_VAR 0 2
121096: PUSH
121097: EMPTY
121098: ST_TO_ADDR
// exit ;
121099: GO 121327
// end ; for i in defenders do
121101: LD_ADDR_VAR 0 4
121105: PUSH
121106: LD_VAR 0 2
121110: PUSH
121111: FOR_IN
121112: IFFALSE 121201
// begin if not IsInArea ( i , mc_parking [ base ] ) then
121114: LD_VAR 0 4
121118: PPUSH
121119: LD_EXP 55
121123: PUSH
121124: LD_VAR 0 1
121128: ARRAY
121129: PPUSH
121130: CALL_OW 308
121134: NOT
121135: IFFALSE 121159
// ComMoveToArea ( i , mc_parking [ base ] ) else
121137: LD_VAR 0 4
121141: PPUSH
121142: LD_EXP 55
121146: PUSH
121147: LD_VAR 0 1
121151: ARRAY
121152: PPUSH
121153: CALL_OW 113
121157: GO 121199
// if GetControl ( i ) = control_manual then
121159: LD_VAR 0 4
121163: PPUSH
121164: CALL_OW 263
121168: PUSH
121169: LD_INT 1
121171: EQUAL
121172: IFFALSE 121199
// if IsDrivenBy ( i ) then
121174: LD_VAR 0 4
121178: PPUSH
121179: CALL_OW 311
121183: IFFALSE 121199
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
121185: LD_VAR 0 4
121189: PPUSH
121190: CALL_OW 311
121194: PPUSH
121195: CALL_OW 121
// end ;
121199: GO 121111
121201: POP
121202: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
121203: LD_VAR 0 2
121207: PPUSH
121208: LD_INT 95
121210: PUSH
121211: LD_EXP 55
121215: PUSH
121216: LD_VAR 0 1
121220: ARRAY
121221: PUSH
121222: EMPTY
121223: LIST
121224: LIST
121225: PPUSH
121226: CALL_OW 72
121230: PUSH
121231: LD_VAR 0 2
121235: EQUAL
121236: PUSH
121237: LD_EXP 54
121241: PUSH
121242: LD_VAR 0 1
121246: ARRAY
121247: OR
121248: PUSH
121249: LD_EXP 31
121253: PUSH
121254: LD_VAR 0 1
121258: ARRAY
121259: NOT
121260: OR
121261: IFFALSE 121031
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
121263: LD_ADDR_EXP 53
121267: PUSH
121268: LD_EXP 53
121272: PPUSH
121273: LD_VAR 0 1
121277: PPUSH
121278: LD_VAR 0 2
121282: PPUSH
121283: LD_INT 21
121285: PUSH
121286: LD_INT 2
121288: PUSH
121289: EMPTY
121290: LIST
121291: LIST
121292: PPUSH
121293: CALL_OW 72
121297: PPUSH
121298: CALL_OW 1
121302: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
121303: LD_VAR 0 1
121307: PPUSH
121308: LD_INT 19
121310: PPUSH
121311: CALL 66779 0 2
// MC_Reset ( base , 20 ) ;
121315: LD_VAR 0 1
121319: PPUSH
121320: LD_INT 20
121322: PPUSH
121323: CALL 66779 0 2
// end ; end_of_file
121327: LD_VAR 0 3
121331: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
121332: LD_VAR 0 1
121336: PUSH
121337: LD_INT 200
121339: DOUBLE
121340: GREATEREQUAL
121341: IFFALSE 121349
121343: LD_INT 299
121345: DOUBLE
121346: LESSEQUAL
121347: IFTRUE 121351
121349: GO 121383
121351: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
121352: LD_VAR 0 1
121356: PPUSH
121357: LD_VAR 0 2
121361: PPUSH
121362: LD_VAR 0 3
121366: PPUSH
121367: LD_VAR 0 4
121371: PPUSH
121372: LD_VAR 0 5
121376: PPUSH
121377: CALL 109513 0 5
121381: GO 121460
121383: LD_INT 300
121385: DOUBLE
121386: GREATEREQUAL
121387: IFFALSE 121395
121389: LD_INT 399
121391: DOUBLE
121392: LESSEQUAL
121393: IFTRUE 121397
121395: GO 121459
121397: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
121398: LD_VAR 0 1
121402: PPUSH
121403: LD_VAR 0 2
121407: PPUSH
121408: LD_VAR 0 3
121412: PPUSH
121413: LD_VAR 0 4
121417: PPUSH
121418: LD_VAR 0 5
121422: PPUSH
121423: LD_VAR 0 6
121427: PPUSH
121428: LD_VAR 0 7
121432: PPUSH
121433: LD_VAR 0 8
121437: PPUSH
121438: LD_VAR 0 9
121442: PPUSH
121443: LD_VAR 0 10
121447: PPUSH
121448: LD_VAR 0 11
121452: PPUSH
121453: CALL 105838 0 11
121457: GO 121460
121459: POP
// end ;
121460: PPOPN 11
121462: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121463: LD_VAR 0 1
121467: PPUSH
121468: LD_VAR 0 2
121472: PPUSH
121473: LD_VAR 0 3
121477: PPUSH
121478: LD_VAR 0 4
121482: PPUSH
121483: LD_VAR 0 5
121487: PPUSH
121488: CALL 109249 0 5
// end ; end_of_file
121492: PPOPN 5
121494: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121495: LD_VAR 0 1
121499: PPUSH
121500: LD_VAR 0 2
121504: PPUSH
121505: LD_VAR 0 3
121509: PPUSH
121510: LD_VAR 0 4
121514: PPUSH
121515: LD_VAR 0 5
121519: PPUSH
121520: LD_VAR 0 6
121524: PPUSH
121525: CALL 93490 0 6
// end ;
121529: PPOPN 6
121531: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121532: LD_INT 0
121534: PPUSH
// begin if not units then
121535: LD_VAR 0 1
121539: NOT
121540: IFFALSE 121544
// exit ;
121542: GO 121544
// end ;
121544: PPOPN 7
121546: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121547: CALL 93377 0 0
// end ;
121551: PPOPN 1
121553: END
