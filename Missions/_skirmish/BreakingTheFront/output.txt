// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56584 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56584 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56584 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56584 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 53942 0 9
// MC_Start ;
1394: CALL 63234 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86558 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86502 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86390 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86072 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 85803 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85422 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85237 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85129 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 85979 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86558 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86502 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86390 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86072 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 85803 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85422 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 84919 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85129 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 85237 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 86558 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 86502 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 86390 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86072 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 85803 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 85422 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 85237 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 86558 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 86502 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 86390 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86072 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 85803 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 85422 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86128 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 85237 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 53942 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28343 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28343 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28343 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 53942 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 25021 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 25021 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28343 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 53942 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28343 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24899 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56177 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24899 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56177 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24899 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56177 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24899 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56177 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85177 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85177 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 27990 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56177 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56177 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 25021 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin CenterNowOnXY ( x , y ) ;
15044: LD_VAR 0 4
15048: PPUSH
15049: LD_VAR 0 5
15053: PPUSH
15054: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15058: LD_EXP 9
15062: PPUSH
15063: LD_STRING D
15065: PUSH
15066: LD_STRING I
15068: PUSH
15069: LD_STRING J
15071: PUSH
15072: LD_STRING S
15074: PUSH
15075: EMPTY
15076: LIST
15077: LIST
15078: LIST
15079: PUSH
15080: LD_EXP 25
15084: ARRAY
15085: STR
15086: PUSH
15087: LD_STRING -1-Mine
15089: STR
15090: PPUSH
15091: CALL_OW 88
// dialogueMineDetected := true ;
15095: LD_ADDR_EXP 28
15099: PUSH
15100: LD_INT 1
15102: ST_TO_ADDR
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 85285 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65223 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24899 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24899 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24899 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24899 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 85285 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 85285 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 86703 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 86703 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 85285 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 85285 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 85285 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 86703 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 86703 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 85285 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 86703 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 86703 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 107322 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 88689 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91021 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90089 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 90330 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 88385 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88005 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 107442 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 87596 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 87434 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 87209 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87094 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 91316 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 91532 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 86903 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 107426 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; var i ; begin
21986: LD_INT 0
21988: PPUSH
21989: PPUSH
// result := 0 ;
21990: LD_ADDR_VAR 0 2
21994: PUSH
21995: LD_INT 0
21997: ST_TO_ADDR
// for i in array do
21998: LD_ADDR_VAR 0 3
22002: PUSH
22003: LD_VAR 0 1
22007: PUSH
22008: FOR_IN
22009: IFFALSE 22033
// if i then
22011: LD_VAR 0 3
22015: IFFALSE 22031
// result := result + 1 ;
22017: LD_ADDR_VAR 0 2
22021: PUSH
22022: LD_VAR 0 2
22026: PUSH
22027: LD_INT 1
22029: PLUS
22030: ST_TO_ADDR
22031: GO 22008
22033: POP
22034: POP
// end ;
22035: LD_VAR 0 2
22039: RET
// export function IsEmpty ( building ) ; begin
22040: LD_INT 0
22042: PPUSH
// if not building then
22043: LD_VAR 0 1
22047: NOT
22048: IFFALSE 22052
// exit ;
22050: GO 22095
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22052: LD_ADDR_VAR 0 2
22056: PUSH
22057: LD_VAR 0 1
22061: PUSH
22062: LD_INT 22
22064: PUSH
22065: LD_VAR 0 1
22069: PPUSH
22070: CALL_OW 255
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 58
22081: PUSH
22082: EMPTY
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PPUSH
22089: CALL_OW 69
22093: IN
22094: ST_TO_ADDR
// end ;
22095: LD_VAR 0 2
22099: RET
// export function IsNotFull ( building ) ; var places ; begin
22100: LD_INT 0
22102: PPUSH
22103: PPUSH
// if not building then
22104: LD_VAR 0 1
22108: NOT
22109: IFFALSE 22113
// exit ;
22111: GO 22284
// result := false ;
22113: LD_ADDR_VAR 0 2
22117: PUSH
22118: LD_INT 0
22120: ST_TO_ADDR
// places := 0 ;
22121: LD_ADDR_VAR 0 3
22125: PUSH
22126: LD_INT 0
22128: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
22129: LD_VAR 0 1
22133: PPUSH
22134: CALL_OW 266
22138: PUSH
22139: LD_INT 0
22141: DOUBLE
22142: EQUAL
22143: IFTRUE 22201
22145: LD_INT 1
22147: DOUBLE
22148: EQUAL
22149: IFTRUE 22201
22151: LD_INT 6
22153: DOUBLE
22154: EQUAL
22155: IFTRUE 22201
22157: LD_INT 7
22159: DOUBLE
22160: EQUAL
22161: IFTRUE 22201
22163: LD_INT 8
22165: DOUBLE
22166: EQUAL
22167: IFTRUE 22201
22169: LD_INT 4
22171: DOUBLE
22172: EQUAL
22173: IFTRUE 22201
22175: LD_INT 5
22177: DOUBLE
22178: EQUAL
22179: IFTRUE 22201
22181: LD_INT 2
22183: DOUBLE
22184: EQUAL
22185: IFTRUE 22201
22187: LD_INT 3
22189: DOUBLE
22190: EQUAL
22191: IFTRUE 22201
22193: LD_INT 35
22195: DOUBLE
22196: EQUAL
22197: IFTRUE 22201
22199: GO 22212
22201: POP
// places := 6 ; b_bunker , b_breastwork :
22202: LD_ADDR_VAR 0 3
22206: PUSH
22207: LD_INT 6
22209: ST_TO_ADDR
22210: GO 22257
22212: LD_INT 32
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22226
22218: LD_INT 31
22220: DOUBLE
22221: EQUAL
22222: IFTRUE 22226
22224: GO 22237
22226: POP
// places := 1 ; b_control_tower :
22227: LD_ADDR_VAR 0 3
22231: PUSH
22232: LD_INT 1
22234: ST_TO_ADDR
22235: GO 22257
22237: LD_INT 36
22239: DOUBLE
22240: EQUAL
22241: IFTRUE 22245
22243: GO 22256
22245: POP
// places := 3 ; end ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_INT 3
22253: ST_TO_ADDR
22254: GO 22257
22256: POP
// if places then
22257: LD_VAR 0 3
22261: IFFALSE 22284
// result := UnitsInside ( building ) < places ;
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: LD_VAR 0 1
22272: PPUSH
22273: CALL_OW 313
22277: PUSH
22278: LD_VAR 0 3
22282: LESS
22283: ST_TO_ADDR
// end ;
22284: LD_VAR 0 2
22288: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22289: LD_INT 0
22291: PPUSH
22292: PPUSH
22293: PPUSH
22294: PPUSH
// tmp := [ ] ;
22295: LD_ADDR_VAR 0 3
22299: PUSH
22300: EMPTY
22301: ST_TO_ADDR
// list := [ ] ;
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: EMPTY
22308: ST_TO_ADDR
// for i = 16 to 25 do
22309: LD_ADDR_VAR 0 4
22313: PUSH
22314: DOUBLE
22315: LD_INT 16
22317: DEC
22318: ST_TO_ADDR
22319: LD_INT 25
22321: PUSH
22322: FOR_TO
22323: IFFALSE 22396
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22325: LD_ADDR_VAR 0 3
22329: PUSH
22330: LD_VAR 0 3
22334: PUSH
22335: LD_INT 22
22337: PUSH
22338: LD_VAR 0 1
22342: PPUSH
22343: CALL_OW 255
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: PUSH
22352: LD_INT 91
22354: PUSH
22355: LD_VAR 0 1
22359: PUSH
22360: LD_INT 6
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: PUSH
22368: LD_INT 30
22370: PUSH
22371: LD_VAR 0 4
22375: PUSH
22376: EMPTY
22377: LIST
22378: LIST
22379: PUSH
22380: EMPTY
22381: LIST
22382: LIST
22383: LIST
22384: PUSH
22385: EMPTY
22386: LIST
22387: PPUSH
22388: CALL_OW 69
22392: ADD
22393: ST_TO_ADDR
22394: GO 22322
22396: POP
22397: POP
// for i = 1 to tmp do
22398: LD_ADDR_VAR 0 4
22402: PUSH
22403: DOUBLE
22404: LD_INT 1
22406: DEC
22407: ST_TO_ADDR
22408: LD_VAR 0 3
22412: PUSH
22413: FOR_TO
22414: IFFALSE 22502
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_VAR 0 5
22425: PUSH
22426: LD_VAR 0 3
22430: PUSH
22431: LD_VAR 0 4
22435: ARRAY
22436: PPUSH
22437: CALL_OW 266
22441: PUSH
22442: LD_VAR 0 3
22446: PUSH
22447: LD_VAR 0 4
22451: ARRAY
22452: PPUSH
22453: CALL_OW 250
22457: PUSH
22458: LD_VAR 0 3
22462: PUSH
22463: LD_VAR 0 4
22467: ARRAY
22468: PPUSH
22469: CALL_OW 251
22473: PUSH
22474: LD_VAR 0 3
22478: PUSH
22479: LD_VAR 0 4
22483: ARRAY
22484: PPUSH
22485: CALL_OW 254
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: PUSH
22496: EMPTY
22497: LIST
22498: ADD
22499: ST_TO_ADDR
22500: GO 22413
22502: POP
22503: POP
// result := list ;
22504: LD_ADDR_VAR 0 2
22508: PUSH
22509: LD_VAR 0 5
22513: ST_TO_ADDR
// end ;
22514: LD_VAR 0 2
22518: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22519: LD_INT 0
22521: PPUSH
22522: PPUSH
22523: PPUSH
22524: PPUSH
22525: PPUSH
22526: PPUSH
22527: PPUSH
// if not factory then
22528: LD_VAR 0 1
22532: NOT
22533: IFFALSE 22537
// exit ;
22535: GO 23130
// if control = control_apeman then
22537: LD_VAR 0 4
22541: PUSH
22542: LD_INT 5
22544: EQUAL
22545: IFFALSE 22654
// begin tmp := UnitsInside ( factory ) ;
22547: LD_ADDR_VAR 0 8
22551: PUSH
22552: LD_VAR 0 1
22556: PPUSH
22557: CALL_OW 313
22561: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22562: LD_VAR 0 8
22566: PPUSH
22567: LD_INT 25
22569: PUSH
22570: LD_INT 12
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: PPUSH
22577: CALL_OW 72
22581: NOT
22582: IFFALSE 22592
// control := control_manual ;
22584: LD_ADDR_VAR 0 4
22588: PUSH
22589: LD_INT 1
22591: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22592: LD_ADDR_VAR 0 8
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL 22289 0 1
22606: ST_TO_ADDR
// if tmp then
22607: LD_VAR 0 8
22611: IFFALSE 22654
// begin for i in tmp do
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: LD_VAR 0 8
22622: PUSH
22623: FOR_IN
22624: IFFALSE 22652
// if i [ 1 ] = b_ext_radio then
22626: LD_VAR 0 7
22630: PUSH
22631: LD_INT 1
22633: ARRAY
22634: PUSH
22635: LD_INT 22
22637: EQUAL
22638: IFFALSE 22650
// begin control := control_remote ;
22640: LD_ADDR_VAR 0 4
22644: PUSH
22645: LD_INT 2
22647: ST_TO_ADDR
// break ;
22648: GO 22652
// end ;
22650: GO 22623
22652: POP
22653: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: LD_VAR 0 3
22668: PPUSH
22669: LD_VAR 0 4
22673: PPUSH
22674: LD_VAR 0 5
22678: PPUSH
22679: CALL_OW 448
22683: IFFALSE 22718
// begin result := [ chassis , engine , control , weapon ] ;
22685: LD_ADDR_VAR 0 6
22689: PUSH
22690: LD_VAR 0 2
22694: PUSH
22695: LD_VAR 0 3
22699: PUSH
22700: LD_VAR 0 4
22704: PUSH
22705: LD_VAR 0 5
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: ST_TO_ADDR
// exit ;
22716: GO 23130
// end ; _chassis := AvailableChassisList ( factory ) ;
22718: LD_ADDR_VAR 0 9
22722: PUSH
22723: LD_VAR 0 1
22727: PPUSH
22728: CALL_OW 475
22732: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22733: LD_ADDR_VAR 0 11
22737: PUSH
22738: LD_VAR 0 1
22742: PPUSH
22743: CALL_OW 476
22747: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22748: LD_ADDR_VAR 0 12
22752: PUSH
22753: LD_VAR 0 1
22757: PPUSH
22758: CALL_OW 477
22762: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22763: LD_ADDR_VAR 0 10
22767: PUSH
22768: LD_VAR 0 1
22772: PPUSH
22773: CALL_OW 478
22777: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22778: LD_VAR 0 9
22782: NOT
22783: PUSH
22784: LD_VAR 0 11
22788: NOT
22789: OR
22790: PUSH
22791: LD_VAR 0 12
22795: NOT
22796: OR
22797: PUSH
22798: LD_VAR 0 10
22802: NOT
22803: OR
22804: IFFALSE 22839
// begin result := [ chassis , engine , control , weapon ] ;
22806: LD_ADDR_VAR 0 6
22810: PUSH
22811: LD_VAR 0 2
22815: PUSH
22816: LD_VAR 0 3
22820: PUSH
22821: LD_VAR 0 4
22825: PUSH
22826: LD_VAR 0 5
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: ST_TO_ADDR
// exit ;
22837: GO 23130
// end ; if not chassis in _chassis then
22839: LD_VAR 0 2
22843: PUSH
22844: LD_VAR 0 9
22848: IN
22849: NOT
22850: IFFALSE 22876
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22852: LD_ADDR_VAR 0 2
22856: PUSH
22857: LD_VAR 0 9
22861: PUSH
22862: LD_INT 1
22864: PPUSH
22865: LD_VAR 0 9
22869: PPUSH
22870: CALL_OW 12
22874: ARRAY
22875: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_VAR 0 3
22885: PPUSH
22886: CALL 23135 0 2
22890: NOT
22891: IFFALSE 22950
// repeat engine := _engine [ 1 ] ;
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_VAR 0 11
22902: PUSH
22903: LD_INT 1
22905: ARRAY
22906: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22907: LD_ADDR_VAR 0 11
22911: PUSH
22912: LD_VAR 0 11
22916: PPUSH
22917: LD_INT 1
22919: PPUSH
22920: CALL_OW 3
22924: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22925: LD_VAR 0 2
22929: PPUSH
22930: LD_VAR 0 3
22934: PPUSH
22935: CALL 23135 0 2
22939: PUSH
22940: LD_VAR 0 11
22944: PUSH
22945: EMPTY
22946: EQUAL
22947: OR
22948: IFFALSE 22893
// if not control in _control then
22950: LD_VAR 0 4
22954: PUSH
22955: LD_VAR 0 12
22959: IN
22960: NOT
22961: IFFALSE 22987
// control := _control [ rand ( 1 , _control ) ] ;
22963: LD_ADDR_VAR 0 4
22967: PUSH
22968: LD_VAR 0 12
22972: PUSH
22973: LD_INT 1
22975: PPUSH
22976: LD_VAR 0 12
22980: PPUSH
22981: CALL_OW 12
22985: ARRAY
22986: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22987: LD_VAR 0 2
22991: PPUSH
22992: LD_VAR 0 5
22996: PPUSH
22997: CALL 23355 0 2
23001: NOT
23002: IFFALSE 23061
// repeat weapon := _weapon [ 1 ] ;
23004: LD_ADDR_VAR 0 5
23008: PUSH
23009: LD_VAR 0 10
23013: PUSH
23014: LD_INT 1
23016: ARRAY
23017: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23018: LD_ADDR_VAR 0 10
23022: PUSH
23023: LD_VAR 0 10
23027: PPUSH
23028: LD_INT 1
23030: PPUSH
23031: CALL_OW 3
23035: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23036: LD_VAR 0 2
23040: PPUSH
23041: LD_VAR 0 5
23045: PPUSH
23046: CALL 23355 0 2
23050: PUSH
23051: LD_VAR 0 10
23055: PUSH
23056: EMPTY
23057: EQUAL
23058: OR
23059: IFFALSE 23004
// result := [ ] ;
23061: LD_ADDR_VAR 0 6
23065: PUSH
23066: EMPTY
23067: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: LD_VAR 0 3
23082: PPUSH
23083: LD_VAR 0 4
23087: PPUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: CALL_OW 448
23097: IFFALSE 23130
// result := [ chassis , engine , control , weapon ] ;
23099: LD_ADDR_VAR 0 6
23103: PUSH
23104: LD_VAR 0 2
23108: PUSH
23109: LD_VAR 0 3
23113: PUSH
23114: LD_VAR 0 4
23118: PUSH
23119: LD_VAR 0 5
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: LIST
23128: LIST
23129: ST_TO_ADDR
// end ;
23130: LD_VAR 0 6
23134: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23135: LD_INT 0
23137: PPUSH
// if not chassis or not engine then
23138: LD_VAR 0 1
23142: NOT
23143: PUSH
23144: LD_VAR 0 2
23148: NOT
23149: OR
23150: IFFALSE 23154
// exit ;
23152: GO 23350
// case engine of engine_solar :
23154: LD_VAR 0 2
23158: PUSH
23159: LD_INT 2
23161: DOUBLE
23162: EQUAL
23163: IFTRUE 23167
23165: GO 23205
23167: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23168: LD_ADDR_VAR 0 3
23172: PUSH
23173: LD_INT 11
23175: PUSH
23176: LD_INT 12
23178: PUSH
23179: LD_INT 13
23181: PUSH
23182: LD_INT 14
23184: PUSH
23185: LD_INT 1
23187: PUSH
23188: LD_INT 2
23190: PUSH
23191: LD_INT 3
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: ST_TO_ADDR
23203: GO 23334
23205: LD_INT 1
23207: DOUBLE
23208: EQUAL
23209: IFTRUE 23213
23211: GO 23275
23213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23214: LD_ADDR_VAR 0 3
23218: PUSH
23219: LD_INT 11
23221: PUSH
23222: LD_INT 12
23224: PUSH
23225: LD_INT 13
23227: PUSH
23228: LD_INT 14
23230: PUSH
23231: LD_INT 1
23233: PUSH
23234: LD_INT 2
23236: PUSH
23237: LD_INT 3
23239: PUSH
23240: LD_INT 4
23242: PUSH
23243: LD_INT 5
23245: PUSH
23246: LD_INT 21
23248: PUSH
23249: LD_INT 23
23251: PUSH
23252: LD_INT 22
23254: PUSH
23255: LD_INT 24
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: LIST
23271: LIST
23272: ST_TO_ADDR
23273: GO 23334
23275: LD_INT 3
23277: DOUBLE
23278: EQUAL
23279: IFTRUE 23283
23281: GO 23333
23283: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23284: LD_ADDR_VAR 0 3
23288: PUSH
23289: LD_INT 13
23291: PUSH
23292: LD_INT 14
23294: PUSH
23295: LD_INT 2
23297: PUSH
23298: LD_INT 3
23300: PUSH
23301: LD_INT 4
23303: PUSH
23304: LD_INT 5
23306: PUSH
23307: LD_INT 21
23309: PUSH
23310: LD_INT 22
23312: PUSH
23313: LD_INT 23
23315: PUSH
23316: LD_INT 24
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
23331: GO 23334
23333: POP
// result := ( chassis in result ) ;
23334: LD_ADDR_VAR 0 3
23338: PUSH
23339: LD_VAR 0 1
23343: PUSH
23344: LD_VAR 0 3
23348: IN
23349: ST_TO_ADDR
// end ;
23350: LD_VAR 0 3
23354: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23355: LD_INT 0
23357: PPUSH
// if not chassis or not weapon then
23358: LD_VAR 0 1
23362: NOT
23363: PUSH
23364: LD_VAR 0 2
23368: NOT
23369: OR
23370: IFFALSE 23374
// exit ;
23372: GO 24434
// case weapon of us_machine_gun :
23374: LD_VAR 0 2
23378: PUSH
23379: LD_INT 2
23381: DOUBLE
23382: EQUAL
23383: IFTRUE 23387
23385: GO 23417
23387: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23388: LD_ADDR_VAR 0 3
23392: PUSH
23393: LD_INT 1
23395: PUSH
23396: LD_INT 2
23398: PUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 4
23404: PUSH
23405: LD_INT 5
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: ST_TO_ADDR
23415: GO 24418
23417: LD_INT 3
23419: DOUBLE
23420: EQUAL
23421: IFTRUE 23425
23423: GO 23455
23425: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23426: LD_ADDR_VAR 0 3
23430: PUSH
23431: LD_INT 1
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: ST_TO_ADDR
23453: GO 24418
23455: LD_INT 11
23457: DOUBLE
23458: EQUAL
23459: IFTRUE 23463
23461: GO 23493
23463: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23464: LD_ADDR_VAR 0 3
23468: PUSH
23469: LD_INT 1
23471: PUSH
23472: LD_INT 2
23474: PUSH
23475: LD_INT 3
23477: PUSH
23478: LD_INT 4
23480: PUSH
23481: LD_INT 5
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: ST_TO_ADDR
23491: GO 24418
23493: LD_INT 4
23495: DOUBLE
23496: EQUAL
23497: IFTRUE 23501
23499: GO 23527
23501: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23502: LD_ADDR_VAR 0 3
23506: PUSH
23507: LD_INT 2
23509: PUSH
23510: LD_INT 3
23512: PUSH
23513: LD_INT 4
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: LIST
23523: LIST
23524: ST_TO_ADDR
23525: GO 24418
23527: LD_INT 5
23529: DOUBLE
23530: EQUAL
23531: IFTRUE 23535
23533: GO 23561
23535: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23536: LD_ADDR_VAR 0 3
23540: PUSH
23541: LD_INT 2
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 4
23549: PUSH
23550: LD_INT 5
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: LIST
23557: LIST
23558: ST_TO_ADDR
23559: GO 24418
23561: LD_INT 9
23563: DOUBLE
23564: EQUAL
23565: IFTRUE 23569
23567: GO 23595
23569: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: LD_INT 3
23580: PUSH
23581: LD_INT 4
23583: PUSH
23584: LD_INT 5
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: ST_TO_ADDR
23593: GO 24418
23595: LD_INT 7
23597: DOUBLE
23598: EQUAL
23599: IFTRUE 23603
23601: GO 23629
23603: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23604: LD_ADDR_VAR 0 3
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 3
23614: PUSH
23615: LD_INT 4
23617: PUSH
23618: LD_INT 5
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: LIST
23625: LIST
23626: ST_TO_ADDR
23627: GO 24418
23629: LD_INT 12
23631: DOUBLE
23632: EQUAL
23633: IFTRUE 23637
23635: GO 23663
23637: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23638: LD_ADDR_VAR 0 3
23642: PUSH
23643: LD_INT 2
23645: PUSH
23646: LD_INT 3
23648: PUSH
23649: LD_INT 4
23651: PUSH
23652: LD_INT 5
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
23661: GO 24418
23663: LD_INT 13
23665: DOUBLE
23666: EQUAL
23667: IFTRUE 23671
23669: GO 23697
23671: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23672: LD_ADDR_VAR 0 3
23676: PUSH
23677: LD_INT 2
23679: PUSH
23680: LD_INT 3
23682: PUSH
23683: LD_INT 4
23685: PUSH
23686: LD_INT 5
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: ST_TO_ADDR
23695: GO 24418
23697: LD_INT 14
23699: DOUBLE
23700: EQUAL
23701: IFTRUE 23705
23703: GO 23723
23705: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_INT 4
23713: PUSH
23714: LD_INT 5
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: ST_TO_ADDR
23721: GO 24418
23723: LD_INT 6
23725: DOUBLE
23726: EQUAL
23727: IFTRUE 23731
23729: GO 23749
23731: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23732: LD_ADDR_VAR 0 3
23736: PUSH
23737: LD_INT 4
23739: PUSH
23740: LD_INT 5
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: ST_TO_ADDR
23747: GO 24418
23749: LD_INT 10
23751: DOUBLE
23752: EQUAL
23753: IFTRUE 23757
23755: GO 23775
23757: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23758: LD_ADDR_VAR 0 3
23762: PUSH
23763: LD_INT 4
23765: PUSH
23766: LD_INT 5
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: ST_TO_ADDR
23773: GO 24418
23775: LD_INT 22
23777: DOUBLE
23778: EQUAL
23779: IFTRUE 23783
23781: GO 23809
23783: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23784: LD_ADDR_VAR 0 3
23788: PUSH
23789: LD_INT 11
23791: PUSH
23792: LD_INT 12
23794: PUSH
23795: LD_INT 13
23797: PUSH
23798: LD_INT 14
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: LIST
23805: LIST
23806: ST_TO_ADDR
23807: GO 24418
23809: LD_INT 23
23811: DOUBLE
23812: EQUAL
23813: IFTRUE 23817
23815: GO 23843
23817: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23818: LD_ADDR_VAR 0 3
23822: PUSH
23823: LD_INT 11
23825: PUSH
23826: LD_INT 12
23828: PUSH
23829: LD_INT 13
23831: PUSH
23832: LD_INT 14
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: ST_TO_ADDR
23841: GO 24418
23843: LD_INT 24
23845: DOUBLE
23846: EQUAL
23847: IFTRUE 23851
23849: GO 23877
23851: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23852: LD_ADDR_VAR 0 3
23856: PUSH
23857: LD_INT 11
23859: PUSH
23860: LD_INT 12
23862: PUSH
23863: LD_INT 13
23865: PUSH
23866: LD_INT 14
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 24418
23877: LD_INT 30
23879: DOUBLE
23880: EQUAL
23881: IFTRUE 23885
23883: GO 23911
23885: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23886: LD_ADDR_VAR 0 3
23890: PUSH
23891: LD_INT 11
23893: PUSH
23894: LD_INT 12
23896: PUSH
23897: LD_INT 13
23899: PUSH
23900: LD_INT 14
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: LIST
23907: LIST
23908: ST_TO_ADDR
23909: GO 24418
23911: LD_INT 25
23913: DOUBLE
23914: EQUAL
23915: IFTRUE 23919
23917: GO 23937
23919: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23920: LD_ADDR_VAR 0 3
23924: PUSH
23925: LD_INT 13
23927: PUSH
23928: LD_INT 14
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: ST_TO_ADDR
23935: GO 24418
23937: LD_INT 27
23939: DOUBLE
23940: EQUAL
23941: IFTRUE 23945
23943: GO 23963
23945: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23946: LD_ADDR_VAR 0 3
23950: PUSH
23951: LD_INT 13
23953: PUSH
23954: LD_INT 14
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: ST_TO_ADDR
23961: GO 24418
23963: LD_INT 92
23965: DOUBLE
23966: EQUAL
23967: IFTRUE 23971
23969: GO 23997
23971: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23972: LD_ADDR_VAR 0 3
23976: PUSH
23977: LD_INT 11
23979: PUSH
23980: LD_INT 12
23982: PUSH
23983: LD_INT 13
23985: PUSH
23986: LD_INT 14
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: ST_TO_ADDR
23995: GO 24418
23997: LD_INT 28
23999: DOUBLE
24000: EQUAL
24001: IFTRUE 24005
24003: GO 24023
24005: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24006: LD_ADDR_VAR 0 3
24010: PUSH
24011: LD_INT 13
24013: PUSH
24014: LD_INT 14
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: ST_TO_ADDR
24021: GO 24418
24023: LD_INT 29
24025: DOUBLE
24026: EQUAL
24027: IFTRUE 24031
24029: GO 24049
24031: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24032: LD_ADDR_VAR 0 3
24036: PUSH
24037: LD_INT 13
24039: PUSH
24040: LD_INT 14
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: ST_TO_ADDR
24047: GO 24418
24049: LD_INT 31
24051: DOUBLE
24052: EQUAL
24053: IFTRUE 24057
24055: GO 24075
24057: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24058: LD_ADDR_VAR 0 3
24062: PUSH
24063: LD_INT 13
24065: PUSH
24066: LD_INT 14
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: ST_TO_ADDR
24073: GO 24418
24075: LD_INT 26
24077: DOUBLE
24078: EQUAL
24079: IFTRUE 24083
24081: GO 24101
24083: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24084: LD_ADDR_VAR 0 3
24088: PUSH
24089: LD_INT 13
24091: PUSH
24092: LD_INT 14
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: ST_TO_ADDR
24099: GO 24418
24101: LD_INT 42
24103: DOUBLE
24104: EQUAL
24105: IFTRUE 24109
24107: GO 24135
24109: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24110: LD_ADDR_VAR 0 3
24114: PUSH
24115: LD_INT 21
24117: PUSH
24118: LD_INT 22
24120: PUSH
24121: LD_INT 23
24123: PUSH
24124: LD_INT 24
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: ST_TO_ADDR
24133: GO 24418
24135: LD_INT 43
24137: DOUBLE
24138: EQUAL
24139: IFTRUE 24143
24141: GO 24169
24143: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_INT 21
24151: PUSH
24152: LD_INT 22
24154: PUSH
24155: LD_INT 23
24157: PUSH
24158: LD_INT 24
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: ST_TO_ADDR
24167: GO 24418
24169: LD_INT 44
24171: DOUBLE
24172: EQUAL
24173: IFTRUE 24177
24175: GO 24203
24177: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 21
24185: PUSH
24186: LD_INT 22
24188: PUSH
24189: LD_INT 23
24191: PUSH
24192: LD_INT 24
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: LIST
24199: LIST
24200: ST_TO_ADDR
24201: GO 24418
24203: LD_INT 45
24205: DOUBLE
24206: EQUAL
24207: IFTRUE 24211
24209: GO 24237
24211: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: LD_INT 21
24219: PUSH
24220: LD_INT 22
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 24
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
24235: GO 24418
24237: LD_INT 49
24239: DOUBLE
24240: EQUAL
24241: IFTRUE 24245
24243: GO 24271
24245: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24246: LD_ADDR_VAR 0 3
24250: PUSH
24251: LD_INT 21
24253: PUSH
24254: LD_INT 22
24256: PUSH
24257: LD_INT 23
24259: PUSH
24260: LD_INT 24
24262: PUSH
24263: EMPTY
24264: LIST
24265: LIST
24266: LIST
24267: LIST
24268: ST_TO_ADDR
24269: GO 24418
24271: LD_INT 51
24273: DOUBLE
24274: EQUAL
24275: IFTRUE 24279
24277: GO 24305
24279: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24280: LD_ADDR_VAR 0 3
24284: PUSH
24285: LD_INT 21
24287: PUSH
24288: LD_INT 22
24290: PUSH
24291: LD_INT 23
24293: PUSH
24294: LD_INT 24
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
24303: GO 24418
24305: LD_INT 52
24307: DOUBLE
24308: EQUAL
24309: IFTRUE 24313
24311: GO 24339
24313: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24314: LD_ADDR_VAR 0 3
24318: PUSH
24319: LD_INT 21
24321: PUSH
24322: LD_INT 22
24324: PUSH
24325: LD_INT 23
24327: PUSH
24328: LD_INT 24
24330: PUSH
24331: EMPTY
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: ST_TO_ADDR
24337: GO 24418
24339: LD_INT 53
24341: DOUBLE
24342: EQUAL
24343: IFTRUE 24347
24345: GO 24365
24347: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24348: LD_ADDR_VAR 0 3
24352: PUSH
24353: LD_INT 23
24355: PUSH
24356: LD_INT 24
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: ST_TO_ADDR
24363: GO 24418
24365: LD_INT 46
24367: DOUBLE
24368: EQUAL
24369: IFTRUE 24373
24371: GO 24391
24373: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_INT 23
24381: PUSH
24382: LD_INT 24
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: ST_TO_ADDR
24389: GO 24418
24391: LD_INT 47
24393: DOUBLE
24394: EQUAL
24395: IFTRUE 24399
24397: GO 24417
24399: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24400: LD_ADDR_VAR 0 3
24404: PUSH
24405: LD_INT 23
24407: PUSH
24408: LD_INT 24
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: ST_TO_ADDR
24415: GO 24418
24417: POP
// result := ( chassis in result ) ;
24418: LD_ADDR_VAR 0 3
24422: PUSH
24423: LD_VAR 0 1
24427: PUSH
24428: LD_VAR 0 3
24432: IN
24433: ST_TO_ADDR
// end ;
24434: LD_VAR 0 3
24438: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24439: LD_INT 0
24441: PPUSH
24442: PPUSH
24443: PPUSH
24444: PPUSH
24445: PPUSH
24446: PPUSH
24447: PPUSH
// result := array ;
24448: LD_ADDR_VAR 0 5
24452: PUSH
24453: LD_VAR 0 1
24457: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24458: LD_VAR 0 1
24462: NOT
24463: PUSH
24464: LD_VAR 0 2
24468: NOT
24469: OR
24470: PUSH
24471: LD_VAR 0 3
24475: NOT
24476: OR
24477: PUSH
24478: LD_VAR 0 2
24482: PUSH
24483: LD_VAR 0 1
24487: GREATER
24488: OR
24489: PUSH
24490: LD_VAR 0 3
24494: PUSH
24495: LD_VAR 0 1
24499: GREATER
24500: OR
24501: IFFALSE 24505
// exit ;
24503: GO 24801
// if direction then
24505: LD_VAR 0 4
24509: IFFALSE 24573
// begin d := 1 ;
24511: LD_ADDR_VAR 0 9
24515: PUSH
24516: LD_INT 1
24518: ST_TO_ADDR
// if i_from > i_to then
24519: LD_VAR 0 2
24523: PUSH
24524: LD_VAR 0 3
24528: GREATER
24529: IFFALSE 24555
// length := ( array - i_from ) + i_to else
24531: LD_ADDR_VAR 0 11
24535: PUSH
24536: LD_VAR 0 1
24540: PUSH
24541: LD_VAR 0 2
24545: MINUS
24546: PUSH
24547: LD_VAR 0 3
24551: PLUS
24552: ST_TO_ADDR
24553: GO 24571
// length := i_to - i_from ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 3
24564: PUSH
24565: LD_VAR 0 2
24569: MINUS
24570: ST_TO_ADDR
// end else
24571: GO 24634
// begin d := - 1 ;
24573: LD_ADDR_VAR 0 9
24577: PUSH
24578: LD_INT 1
24580: NEG
24581: ST_TO_ADDR
// if i_from > i_to then
24582: LD_VAR 0 2
24586: PUSH
24587: LD_VAR 0 3
24591: GREATER
24592: IFFALSE 24612
// length := i_from - i_to else
24594: LD_ADDR_VAR 0 11
24598: PUSH
24599: LD_VAR 0 2
24603: PUSH
24604: LD_VAR 0 3
24608: MINUS
24609: ST_TO_ADDR
24610: GO 24634
// length := ( array - i_to ) + i_from ;
24612: LD_ADDR_VAR 0 11
24616: PUSH
24617: LD_VAR 0 1
24621: PUSH
24622: LD_VAR 0 3
24626: MINUS
24627: PUSH
24628: LD_VAR 0 2
24632: PLUS
24633: ST_TO_ADDR
// end ; if not length then
24634: LD_VAR 0 11
24638: NOT
24639: IFFALSE 24643
// exit ;
24641: GO 24801
// tmp := array ;
24643: LD_ADDR_VAR 0 10
24647: PUSH
24648: LD_VAR 0 1
24652: ST_TO_ADDR
// for i = 1 to length do
24653: LD_ADDR_VAR 0 6
24657: PUSH
24658: DOUBLE
24659: LD_INT 1
24661: DEC
24662: ST_TO_ADDR
24663: LD_VAR 0 11
24667: PUSH
24668: FOR_TO
24669: IFFALSE 24789
// begin for j = 1 to array do
24671: LD_ADDR_VAR 0 7
24675: PUSH
24676: DOUBLE
24677: LD_INT 1
24679: DEC
24680: ST_TO_ADDR
24681: LD_VAR 0 1
24685: PUSH
24686: FOR_TO
24687: IFFALSE 24775
// begin k := j + d ;
24689: LD_ADDR_VAR 0 8
24693: PUSH
24694: LD_VAR 0 7
24698: PUSH
24699: LD_VAR 0 9
24703: PLUS
24704: ST_TO_ADDR
// if k > array then
24705: LD_VAR 0 8
24709: PUSH
24710: LD_VAR 0 1
24714: GREATER
24715: IFFALSE 24725
// k := 1 ;
24717: LD_ADDR_VAR 0 8
24721: PUSH
24722: LD_INT 1
24724: ST_TO_ADDR
// if not k then
24725: LD_VAR 0 8
24729: NOT
24730: IFFALSE 24742
// k := array ;
24732: LD_ADDR_VAR 0 8
24736: PUSH
24737: LD_VAR 0 1
24741: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24742: LD_ADDR_VAR 0 10
24746: PUSH
24747: LD_VAR 0 10
24751: PPUSH
24752: LD_VAR 0 8
24756: PPUSH
24757: LD_VAR 0 1
24761: PUSH
24762: LD_VAR 0 7
24766: ARRAY
24767: PPUSH
24768: CALL_OW 1
24772: ST_TO_ADDR
// end ;
24773: GO 24686
24775: POP
24776: POP
// array := tmp ;
24777: LD_ADDR_VAR 0 1
24781: PUSH
24782: LD_VAR 0 10
24786: ST_TO_ADDR
// end ;
24787: GO 24668
24789: POP
24790: POP
// result := array ;
24791: LD_ADDR_VAR 0 5
24795: PUSH
24796: LD_VAR 0 1
24800: ST_TO_ADDR
// end ;
24801: LD_VAR 0 5
24805: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24806: LD_INT 0
24808: PPUSH
24809: PPUSH
// result := 0 ;
24810: LD_ADDR_VAR 0 3
24814: PUSH
24815: LD_INT 0
24817: ST_TO_ADDR
// if not array or not value in array then
24818: LD_VAR 0 1
24822: NOT
24823: PUSH
24824: LD_VAR 0 2
24828: PUSH
24829: LD_VAR 0 1
24833: IN
24834: NOT
24835: OR
24836: IFFALSE 24840
// exit ;
24838: GO 24894
// for i = 1 to array do
24840: LD_ADDR_VAR 0 4
24844: PUSH
24845: DOUBLE
24846: LD_INT 1
24848: DEC
24849: ST_TO_ADDR
24850: LD_VAR 0 1
24854: PUSH
24855: FOR_TO
24856: IFFALSE 24892
// if value = array [ i ] then
24858: LD_VAR 0 2
24862: PUSH
24863: LD_VAR 0 1
24867: PUSH
24868: LD_VAR 0 4
24872: ARRAY
24873: EQUAL
24874: IFFALSE 24890
// begin result := i ;
24876: LD_ADDR_VAR 0 3
24880: PUSH
24881: LD_VAR 0 4
24885: ST_TO_ADDR
// exit ;
24886: POP
24887: POP
24888: GO 24894
// end ;
24890: GO 24855
24892: POP
24893: POP
// end ;
24894: LD_VAR 0 3
24898: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24899: LD_INT 0
24901: PPUSH
// vc_chassis := chassis ;
24902: LD_ADDR_OWVAR 37
24906: PUSH
24907: LD_VAR 0 1
24911: ST_TO_ADDR
// vc_engine := engine ;
24912: LD_ADDR_OWVAR 39
24916: PUSH
24917: LD_VAR 0 2
24921: ST_TO_ADDR
// vc_control := control ;
24922: LD_ADDR_OWVAR 38
24926: PUSH
24927: LD_VAR 0 3
24931: ST_TO_ADDR
// vc_weapon := weapon ;
24932: LD_ADDR_OWVAR 40
24936: PUSH
24937: LD_VAR 0 4
24941: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24942: LD_ADDR_OWVAR 41
24946: PUSH
24947: LD_VAR 0 5
24951: ST_TO_ADDR
// end ;
24952: LD_VAR 0 6
24956: RET
// export function WantPlant ( unit ) ; var task ; begin
24957: LD_INT 0
24959: PPUSH
24960: PPUSH
// result := false ;
24961: LD_ADDR_VAR 0 2
24965: PUSH
24966: LD_INT 0
24968: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24969: LD_ADDR_VAR 0 3
24973: PUSH
24974: LD_VAR 0 1
24978: PPUSH
24979: CALL_OW 437
24983: ST_TO_ADDR
// if task then
24984: LD_VAR 0 3
24988: IFFALSE 25016
// if task [ 1 ] [ 1 ] = p then
24990: LD_VAR 0 3
24994: PUSH
24995: LD_INT 1
24997: ARRAY
24998: PUSH
24999: LD_INT 1
25001: ARRAY
25002: PUSH
25003: LD_STRING p
25005: EQUAL
25006: IFFALSE 25016
// result := true ;
25008: LD_ADDR_VAR 0 2
25012: PUSH
25013: LD_INT 1
25015: ST_TO_ADDR
// end ;
25016: LD_VAR 0 2
25020: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25021: LD_INT 0
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
// if pos < 1 then
25027: LD_VAR 0 2
25031: PUSH
25032: LD_INT 1
25034: LESS
25035: IFFALSE 25039
// exit ;
25037: GO 25342
// if pos = 1 then
25039: LD_VAR 0 2
25043: PUSH
25044: LD_INT 1
25046: EQUAL
25047: IFFALSE 25080
// result := Replace ( arr , pos [ 1 ] , value ) else
25049: LD_ADDR_VAR 0 4
25053: PUSH
25054: LD_VAR 0 1
25058: PPUSH
25059: LD_VAR 0 2
25063: PUSH
25064: LD_INT 1
25066: ARRAY
25067: PPUSH
25068: LD_VAR 0 3
25072: PPUSH
25073: CALL_OW 1
25077: ST_TO_ADDR
25078: GO 25342
// begin tmp := arr ;
25080: LD_ADDR_VAR 0 6
25084: PUSH
25085: LD_VAR 0 1
25089: ST_TO_ADDR
// s_arr := [ tmp ] ;
25090: LD_ADDR_VAR 0 7
25094: PUSH
25095: LD_VAR 0 6
25099: PUSH
25100: EMPTY
25101: LIST
25102: ST_TO_ADDR
// for i = 1 to pos - 1 do
25103: LD_ADDR_VAR 0 5
25107: PUSH
25108: DOUBLE
25109: LD_INT 1
25111: DEC
25112: ST_TO_ADDR
25113: LD_VAR 0 2
25117: PUSH
25118: LD_INT 1
25120: MINUS
25121: PUSH
25122: FOR_TO
25123: IFFALSE 25168
// begin tmp := tmp [ pos [ i ] ] ;
25125: LD_ADDR_VAR 0 6
25129: PUSH
25130: LD_VAR 0 6
25134: PUSH
25135: LD_VAR 0 2
25139: PUSH
25140: LD_VAR 0 5
25144: ARRAY
25145: ARRAY
25146: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25147: LD_ADDR_VAR 0 7
25151: PUSH
25152: LD_VAR 0 7
25156: PUSH
25157: LD_VAR 0 6
25161: PUSH
25162: EMPTY
25163: LIST
25164: ADD
25165: ST_TO_ADDR
// end ;
25166: GO 25122
25168: POP
25169: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25170: LD_ADDR_VAR 0 6
25174: PUSH
25175: LD_VAR 0 6
25179: PPUSH
25180: LD_VAR 0 2
25184: PUSH
25185: LD_VAR 0 2
25189: ARRAY
25190: PPUSH
25191: LD_VAR 0 3
25195: PPUSH
25196: CALL_OW 1
25200: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25201: LD_ADDR_VAR 0 7
25205: PUSH
25206: LD_VAR 0 7
25210: PPUSH
25211: LD_VAR 0 7
25215: PPUSH
25216: LD_VAR 0 6
25220: PPUSH
25221: CALL_OW 1
25225: ST_TO_ADDR
// for i = s_arr downto 2 do
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: DOUBLE
25232: LD_VAR 0 7
25236: INC
25237: ST_TO_ADDR
25238: LD_INT 2
25240: PUSH
25241: FOR_DOWNTO
25242: IFFALSE 25326
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 7
25253: PUSH
25254: LD_VAR 0 5
25258: PUSH
25259: LD_INT 1
25261: MINUS
25262: ARRAY
25263: PPUSH
25264: LD_VAR 0 2
25268: PUSH
25269: LD_VAR 0 5
25273: PUSH
25274: LD_INT 1
25276: MINUS
25277: ARRAY
25278: PPUSH
25279: LD_VAR 0 7
25283: PUSH
25284: LD_VAR 0 5
25288: ARRAY
25289: PPUSH
25290: CALL_OW 1
25294: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25295: LD_ADDR_VAR 0 7
25299: PUSH
25300: LD_VAR 0 7
25304: PPUSH
25305: LD_VAR 0 5
25309: PUSH
25310: LD_INT 1
25312: MINUS
25313: PPUSH
25314: LD_VAR 0 6
25318: PPUSH
25319: CALL_OW 1
25323: ST_TO_ADDR
// end ;
25324: GO 25241
25326: POP
25327: POP
// result := s_arr [ 1 ] ;
25328: LD_ADDR_VAR 0 4
25332: PUSH
25333: LD_VAR 0 7
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: ST_TO_ADDR
// end ; end ;
25342: LD_VAR 0 4
25346: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25347: LD_INT 0
25349: PPUSH
25350: PPUSH
// if not list then
25351: LD_VAR 0 1
25355: NOT
25356: IFFALSE 25360
// exit ;
25358: GO 25451
// i := list [ pos1 ] ;
25360: LD_ADDR_VAR 0 5
25364: PUSH
25365: LD_VAR 0 1
25369: PUSH
25370: LD_VAR 0 2
25374: ARRAY
25375: ST_TO_ADDR
// if not i then
25376: LD_VAR 0 5
25380: NOT
25381: IFFALSE 25385
// exit ;
25383: GO 25451
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25385: LD_ADDR_VAR 0 1
25389: PUSH
25390: LD_VAR 0 1
25394: PPUSH
25395: LD_VAR 0 2
25399: PPUSH
25400: LD_VAR 0 1
25404: PUSH
25405: LD_VAR 0 3
25409: ARRAY
25410: PPUSH
25411: CALL_OW 1
25415: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25416: LD_ADDR_VAR 0 1
25420: PUSH
25421: LD_VAR 0 1
25425: PPUSH
25426: LD_VAR 0 3
25430: PPUSH
25431: LD_VAR 0 5
25435: PPUSH
25436: CALL_OW 1
25440: ST_TO_ADDR
// result := list ;
25441: LD_ADDR_VAR 0 4
25445: PUSH
25446: LD_VAR 0 1
25450: ST_TO_ADDR
// end ;
25451: LD_VAR 0 4
25455: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25456: LD_INT 0
25458: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25459: LD_ADDR_VAR 0 5
25463: PUSH
25464: LD_VAR 0 1
25468: PPUSH
25469: CALL_OW 250
25473: PPUSH
25474: LD_VAR 0 1
25478: PPUSH
25479: CALL_OW 251
25483: PPUSH
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_VAR 0 3
25493: PPUSH
25494: LD_VAR 0 4
25498: PPUSH
25499: CALL 25509 0 5
25503: ST_TO_ADDR
// end ;
25504: LD_VAR 0 5
25508: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25509: LD_INT 0
25511: PPUSH
25512: PPUSH
25513: PPUSH
25514: PPUSH
// if not list then
25515: LD_VAR 0 3
25519: NOT
25520: IFFALSE 25524
// exit ;
25522: GO 25912
// result := [ ] ;
25524: LD_ADDR_VAR 0 6
25528: PUSH
25529: EMPTY
25530: ST_TO_ADDR
// for i in list do
25531: LD_ADDR_VAR 0 7
25535: PUSH
25536: LD_VAR 0 3
25540: PUSH
25541: FOR_IN
25542: IFFALSE 25744
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25544: LD_ADDR_VAR 0 9
25548: PUSH
25549: LD_VAR 0 7
25553: PPUSH
25554: LD_VAR 0 1
25558: PPUSH
25559: LD_VAR 0 2
25563: PPUSH
25564: CALL_OW 297
25568: ST_TO_ADDR
// if not result then
25569: LD_VAR 0 6
25573: NOT
25574: IFFALSE 25600
// result := [ [ i , tmp ] ] else
25576: LD_ADDR_VAR 0 6
25580: PUSH
25581: LD_VAR 0 7
25585: PUSH
25586: LD_VAR 0 9
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: EMPTY
25596: LIST
25597: ST_TO_ADDR
25598: GO 25742
// begin if result [ result ] [ 2 ] < tmp then
25600: LD_VAR 0 6
25604: PUSH
25605: LD_VAR 0 6
25609: ARRAY
25610: PUSH
25611: LD_INT 2
25613: ARRAY
25614: PUSH
25615: LD_VAR 0 9
25619: LESS
25620: IFFALSE 25662
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25622: LD_ADDR_VAR 0 6
25626: PUSH
25627: LD_VAR 0 6
25631: PPUSH
25632: LD_VAR 0 6
25636: PUSH
25637: LD_INT 1
25639: PLUS
25640: PPUSH
25641: LD_VAR 0 7
25645: PUSH
25646: LD_VAR 0 9
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PPUSH
25655: CALL_OW 2
25659: ST_TO_ADDR
25660: GO 25742
// for j = 1 to result do
25662: LD_ADDR_VAR 0 8
25666: PUSH
25667: DOUBLE
25668: LD_INT 1
25670: DEC
25671: ST_TO_ADDR
25672: LD_VAR 0 6
25676: PUSH
25677: FOR_TO
25678: IFFALSE 25740
// begin if tmp < result [ j ] [ 2 ] then
25680: LD_VAR 0 9
25684: PUSH
25685: LD_VAR 0 6
25689: PUSH
25690: LD_VAR 0 8
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: LESS
25700: IFFALSE 25738
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25702: LD_ADDR_VAR 0 6
25706: PUSH
25707: LD_VAR 0 6
25711: PPUSH
25712: LD_VAR 0 8
25716: PPUSH
25717: LD_VAR 0 7
25721: PUSH
25722: LD_VAR 0 9
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 2
25735: ST_TO_ADDR
// break ;
25736: GO 25740
// end ; end ;
25738: GO 25677
25740: POP
25741: POP
// end ; end ;
25742: GO 25541
25744: POP
25745: POP
// if result and not asc then
25746: LD_VAR 0 6
25750: PUSH
25751: LD_VAR 0 4
25755: NOT
25756: AND
25757: IFFALSE 25832
// begin tmp := result ;
25759: LD_ADDR_VAR 0 9
25763: PUSH
25764: LD_VAR 0 6
25768: ST_TO_ADDR
// for i = tmp downto 1 do
25769: LD_ADDR_VAR 0 7
25773: PUSH
25774: DOUBLE
25775: LD_VAR 0 9
25779: INC
25780: ST_TO_ADDR
25781: LD_INT 1
25783: PUSH
25784: FOR_DOWNTO
25785: IFFALSE 25830
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25787: LD_ADDR_VAR 0 6
25791: PUSH
25792: LD_VAR 0 6
25796: PPUSH
25797: LD_VAR 0 9
25801: PUSH
25802: LD_VAR 0 7
25806: MINUS
25807: PUSH
25808: LD_INT 1
25810: PLUS
25811: PPUSH
25812: LD_VAR 0 9
25816: PUSH
25817: LD_VAR 0 7
25821: ARRAY
25822: PPUSH
25823: CALL_OW 1
25827: ST_TO_ADDR
25828: GO 25784
25830: POP
25831: POP
// end ; tmp := [ ] ;
25832: LD_ADDR_VAR 0 9
25836: PUSH
25837: EMPTY
25838: ST_TO_ADDR
// if mode then
25839: LD_VAR 0 5
25843: IFFALSE 25912
// begin for i = 1 to result do
25845: LD_ADDR_VAR 0 7
25849: PUSH
25850: DOUBLE
25851: LD_INT 1
25853: DEC
25854: ST_TO_ADDR
25855: LD_VAR 0 6
25859: PUSH
25860: FOR_TO
25861: IFFALSE 25900
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25863: LD_ADDR_VAR 0 9
25867: PUSH
25868: LD_VAR 0 9
25872: PPUSH
25873: LD_VAR 0 7
25877: PPUSH
25878: LD_VAR 0 6
25882: PUSH
25883: LD_VAR 0 7
25887: ARRAY
25888: PUSH
25889: LD_INT 1
25891: ARRAY
25892: PPUSH
25893: CALL_OW 1
25897: ST_TO_ADDR
25898: GO 25860
25900: POP
25901: POP
// result := tmp ;
25902: LD_ADDR_VAR 0 6
25906: PUSH
25907: LD_VAR 0 9
25911: ST_TO_ADDR
// end ; end ;
25912: LD_VAR 0 6
25916: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25917: LD_INT 0
25919: PPUSH
25920: PPUSH
25921: PPUSH
25922: PPUSH
25923: PPUSH
25924: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25925: LD_ADDR_VAR 0 5
25929: PUSH
25930: LD_INT 0
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: LD_INT 0
25938: PUSH
25939: EMPTY
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: ST_TO_ADDR
// if not x or not y then
25947: LD_VAR 0 2
25951: NOT
25952: PUSH
25953: LD_VAR 0 3
25957: NOT
25958: OR
25959: IFFALSE 25963
// exit ;
25961: GO 27613
// if not range then
25963: LD_VAR 0 4
25967: NOT
25968: IFFALSE 25978
// range := 10 ;
25970: LD_ADDR_VAR 0 4
25974: PUSH
25975: LD_INT 10
25977: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25978: LD_ADDR_VAR 0 8
25982: PUSH
25983: LD_INT 81
25985: PUSH
25986: LD_VAR 0 1
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 92
25997: PUSH
25998: LD_VAR 0 2
26002: PUSH
26003: LD_VAR 0 3
26007: PUSH
26008: LD_VAR 0 4
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 3
26021: PUSH
26022: LD_INT 21
26024: PUSH
26025: LD_INT 3
26027: PUSH
26028: EMPTY
26029: LIST
26030: LIST
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: LIST
26040: PPUSH
26041: CALL_OW 69
26045: ST_TO_ADDR
// if not tmp then
26046: LD_VAR 0 8
26050: NOT
26051: IFFALSE 26055
// exit ;
26053: GO 27613
// for i in tmp do
26055: LD_ADDR_VAR 0 6
26059: PUSH
26060: LD_VAR 0 8
26064: PUSH
26065: FOR_IN
26066: IFFALSE 27588
// begin points := [ 0 , 0 , 0 ] ;
26068: LD_ADDR_VAR 0 9
26072: PUSH
26073: LD_INT 0
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: LIST
26086: ST_TO_ADDR
// bpoints := 1 ;
26087: LD_ADDR_VAR 0 10
26091: PUSH
26092: LD_INT 1
26094: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26095: LD_VAR 0 6
26099: PPUSH
26100: CALL_OW 247
26104: PUSH
26105: LD_INT 1
26107: DOUBLE
26108: EQUAL
26109: IFTRUE 26113
26111: GO 26691
26113: POP
// begin if GetClass ( i ) = 1 then
26114: LD_VAR 0 6
26118: PPUSH
26119: CALL_OW 257
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26148
// points := [ 10 , 5 , 3 ] ;
26129: LD_ADDR_VAR 0 9
26133: PUSH
26134: LD_INT 10
26136: PUSH
26137: LD_INT 5
26139: PUSH
26140: LD_INT 3
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26148: LD_VAR 0 6
26152: PPUSH
26153: CALL_OW 257
26157: PUSH
26158: LD_INT 2
26160: PUSH
26161: LD_INT 3
26163: PUSH
26164: LD_INT 4
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: IN
26172: IFFALSE 26193
// points := [ 3 , 2 , 1 ] ;
26174: LD_ADDR_VAR 0 9
26178: PUSH
26179: LD_INT 3
26181: PUSH
26182: LD_INT 2
26184: PUSH
26185: LD_INT 1
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: LIST
26192: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26193: LD_VAR 0 6
26197: PPUSH
26198: CALL_OW 257
26202: PUSH
26203: LD_INT 5
26205: EQUAL
26206: IFFALSE 26227
// points := [ 130 , 5 , 2 ] ;
26208: LD_ADDR_VAR 0 9
26212: PUSH
26213: LD_INT 130
26215: PUSH
26216: LD_INT 5
26218: PUSH
26219: LD_INT 2
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: LIST
26226: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26227: LD_VAR 0 6
26231: PPUSH
26232: CALL_OW 257
26236: PUSH
26237: LD_INT 8
26239: EQUAL
26240: IFFALSE 26261
// points := [ 35 , 35 , 30 ] ;
26242: LD_ADDR_VAR 0 9
26246: PUSH
26247: LD_INT 35
26249: PUSH
26250: LD_INT 35
26252: PUSH
26253: LD_INT 30
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: LIST
26260: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26261: LD_VAR 0 6
26265: PPUSH
26266: CALL_OW 257
26270: PUSH
26271: LD_INT 9
26273: EQUAL
26274: IFFALSE 26295
// points := [ 20 , 55 , 40 ] ;
26276: LD_ADDR_VAR 0 9
26280: PUSH
26281: LD_INT 20
26283: PUSH
26284: LD_INT 55
26286: PUSH
26287: LD_INT 40
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: LIST
26294: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26295: LD_VAR 0 6
26299: PPUSH
26300: CALL_OW 257
26304: PUSH
26305: LD_INT 12
26307: PUSH
26308: LD_INT 16
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: IN
26315: IFFALSE 26336
// points := [ 5 , 3 , 2 ] ;
26317: LD_ADDR_VAR 0 9
26321: PUSH
26322: LD_INT 5
26324: PUSH
26325: LD_INT 3
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26336: LD_VAR 0 6
26340: PPUSH
26341: CALL_OW 257
26345: PUSH
26346: LD_INT 17
26348: EQUAL
26349: IFFALSE 26370
// points := [ 100 , 50 , 75 ] ;
26351: LD_ADDR_VAR 0 9
26355: PUSH
26356: LD_INT 100
26358: PUSH
26359: LD_INT 50
26361: PUSH
26362: LD_INT 75
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: LIST
26369: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26370: LD_VAR 0 6
26374: PPUSH
26375: CALL_OW 257
26379: PUSH
26380: LD_INT 15
26382: EQUAL
26383: IFFALSE 26404
// points := [ 10 , 5 , 3 ] ;
26385: LD_ADDR_VAR 0 9
26389: PUSH
26390: LD_INT 10
26392: PUSH
26393: LD_INT 5
26395: PUSH
26396: LD_INT 3
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: LIST
26403: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26404: LD_VAR 0 6
26408: PPUSH
26409: CALL_OW 257
26413: PUSH
26414: LD_INT 14
26416: EQUAL
26417: IFFALSE 26438
// points := [ 10 , 0 , 0 ] ;
26419: LD_ADDR_VAR 0 9
26423: PUSH
26424: LD_INT 10
26426: PUSH
26427: LD_INT 0
26429: PUSH
26430: LD_INT 0
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: LIST
26437: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 257
26447: PUSH
26448: LD_INT 11
26450: EQUAL
26451: IFFALSE 26472
// points := [ 30 , 10 , 5 ] ;
26453: LD_ADDR_VAR 0 9
26457: PUSH
26458: LD_INT 30
26460: PUSH
26461: LD_INT 10
26463: PUSH
26464: LD_INT 5
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: LIST
26471: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26472: LD_VAR 0 1
26476: PPUSH
26477: LD_INT 5
26479: PPUSH
26480: CALL_OW 321
26484: PUSH
26485: LD_INT 2
26487: EQUAL
26488: IFFALSE 26505
// bpoints := bpoints * 1.8 ;
26490: LD_ADDR_VAR 0 10
26494: PUSH
26495: LD_VAR 0 10
26499: PUSH
26500: LD_REAL  1.80000000000000E+0000
26503: MUL
26504: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26505: LD_VAR 0 6
26509: PPUSH
26510: CALL_OW 257
26514: PUSH
26515: LD_INT 1
26517: PUSH
26518: LD_INT 2
26520: PUSH
26521: LD_INT 3
26523: PUSH
26524: LD_INT 4
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: IN
26533: PUSH
26534: LD_VAR 0 1
26538: PPUSH
26539: LD_INT 51
26541: PPUSH
26542: CALL_OW 321
26546: PUSH
26547: LD_INT 2
26549: EQUAL
26550: AND
26551: IFFALSE 26568
// bpoints := bpoints * 1.2 ;
26553: LD_ADDR_VAR 0 10
26557: PUSH
26558: LD_VAR 0 10
26562: PUSH
26563: LD_REAL  1.20000000000000E+0000
26566: MUL
26567: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26568: LD_VAR 0 6
26572: PPUSH
26573: CALL_OW 257
26577: PUSH
26578: LD_INT 5
26580: PUSH
26581: LD_INT 7
26583: PUSH
26584: LD_INT 9
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: IN
26592: PUSH
26593: LD_VAR 0 1
26597: PPUSH
26598: LD_INT 52
26600: PPUSH
26601: CALL_OW 321
26605: PUSH
26606: LD_INT 2
26608: EQUAL
26609: AND
26610: IFFALSE 26627
// bpoints := bpoints * 1.5 ;
26612: LD_ADDR_VAR 0 10
26616: PUSH
26617: LD_VAR 0 10
26621: PUSH
26622: LD_REAL  1.50000000000000E+0000
26625: MUL
26626: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26627: LD_VAR 0 1
26631: PPUSH
26632: LD_INT 66
26634: PPUSH
26635: CALL_OW 321
26639: PUSH
26640: LD_INT 2
26642: EQUAL
26643: IFFALSE 26660
// bpoints := bpoints * 1.1 ;
26645: LD_ADDR_VAR 0 10
26649: PUSH
26650: LD_VAR 0 10
26654: PUSH
26655: LD_REAL  1.10000000000000E+0000
26658: MUL
26659: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26660: LD_ADDR_VAR 0 10
26664: PUSH
26665: LD_VAR 0 10
26669: PUSH
26670: LD_VAR 0 6
26674: PPUSH
26675: LD_INT 1
26677: PPUSH
26678: CALL_OW 259
26682: PUSH
26683: LD_REAL  1.15000000000000E+0000
26686: MUL
26687: MUL
26688: ST_TO_ADDR
// end ; unit_vehicle :
26689: GO 27517
26691: LD_INT 2
26693: DOUBLE
26694: EQUAL
26695: IFTRUE 26699
26697: GO 27505
26699: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26700: LD_VAR 0 6
26704: PPUSH
26705: CALL_OW 264
26709: PUSH
26710: LD_INT 2
26712: PUSH
26713: LD_INT 42
26715: PUSH
26716: LD_INT 24
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: LIST
26723: IN
26724: IFFALSE 26745
// points := [ 25 , 5 , 3 ] ;
26726: LD_ADDR_VAR 0 9
26730: PUSH
26731: LD_INT 25
26733: PUSH
26734: LD_INT 5
26736: PUSH
26737: LD_INT 3
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: LIST
26744: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26745: LD_VAR 0 6
26749: PPUSH
26750: CALL_OW 264
26754: PUSH
26755: LD_INT 4
26757: PUSH
26758: LD_INT 43
26760: PUSH
26761: LD_INT 25
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: IN
26769: IFFALSE 26790
// points := [ 40 , 15 , 5 ] ;
26771: LD_ADDR_VAR 0 9
26775: PUSH
26776: LD_INT 40
26778: PUSH
26779: LD_INT 15
26781: PUSH
26782: LD_INT 5
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26790: LD_VAR 0 6
26794: PPUSH
26795: CALL_OW 264
26799: PUSH
26800: LD_INT 3
26802: PUSH
26803: LD_INT 23
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: IN
26810: IFFALSE 26831
// points := [ 7 , 25 , 8 ] ;
26812: LD_ADDR_VAR 0 9
26816: PUSH
26817: LD_INT 7
26819: PUSH
26820: LD_INT 25
26822: PUSH
26823: LD_INT 8
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: LIST
26830: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26831: LD_VAR 0 6
26835: PPUSH
26836: CALL_OW 264
26840: PUSH
26841: LD_INT 5
26843: PUSH
26844: LD_INT 27
26846: PUSH
26847: LD_INT 44
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: LIST
26854: IN
26855: IFFALSE 26876
// points := [ 14 , 50 , 16 ] ;
26857: LD_ADDR_VAR 0 9
26861: PUSH
26862: LD_INT 14
26864: PUSH
26865: LD_INT 50
26867: PUSH
26868: LD_INT 16
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26876: LD_VAR 0 6
26880: PPUSH
26881: CALL_OW 264
26885: PUSH
26886: LD_INT 6
26888: PUSH
26889: LD_INT 46
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: IN
26896: IFFALSE 26917
// points := [ 32 , 120 , 70 ] ;
26898: LD_ADDR_VAR 0 9
26902: PUSH
26903: LD_INT 32
26905: PUSH
26906: LD_INT 120
26908: PUSH
26909: LD_INT 70
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26917: LD_VAR 0 6
26921: PPUSH
26922: CALL_OW 264
26926: PUSH
26927: LD_INT 7
26929: PUSH
26930: LD_INT 28
26932: PUSH
26933: LD_INT 45
26935: PUSH
26936: LD_INT 92
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: IN
26945: IFFALSE 26966
// points := [ 35 , 20 , 45 ] ;
26947: LD_ADDR_VAR 0 9
26951: PUSH
26952: LD_INT 35
26954: PUSH
26955: LD_INT 20
26957: PUSH
26958: LD_INT 45
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: LIST
26965: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26966: LD_VAR 0 6
26970: PPUSH
26971: CALL_OW 264
26975: PUSH
26976: LD_INT 47
26978: PUSH
26979: EMPTY
26980: LIST
26981: IN
26982: IFFALSE 27003
// points := [ 67 , 45 , 75 ] ;
26984: LD_ADDR_VAR 0 9
26988: PUSH
26989: LD_INT 67
26991: PUSH
26992: LD_INT 45
26994: PUSH
26995: LD_INT 75
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27003: LD_VAR 0 6
27007: PPUSH
27008: CALL_OW 264
27012: PUSH
27013: LD_INT 26
27015: PUSH
27016: EMPTY
27017: LIST
27018: IN
27019: IFFALSE 27040
// points := [ 120 , 30 , 80 ] ;
27021: LD_ADDR_VAR 0 9
27025: PUSH
27026: LD_INT 120
27028: PUSH
27029: LD_INT 30
27031: PUSH
27032: LD_INT 80
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: LIST
27039: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27040: LD_VAR 0 6
27044: PPUSH
27045: CALL_OW 264
27049: PUSH
27050: LD_INT 22
27052: PUSH
27053: EMPTY
27054: LIST
27055: IN
27056: IFFALSE 27077
// points := [ 40 , 1 , 1 ] ;
27058: LD_ADDR_VAR 0 9
27062: PUSH
27063: LD_INT 40
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: LD_INT 1
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27077: LD_VAR 0 6
27081: PPUSH
27082: CALL_OW 264
27086: PUSH
27087: LD_INT 29
27089: PUSH
27090: EMPTY
27091: LIST
27092: IN
27093: IFFALSE 27114
// points := [ 70 , 200 , 400 ] ;
27095: LD_ADDR_VAR 0 9
27099: PUSH
27100: LD_INT 70
27102: PUSH
27103: LD_INT 200
27105: PUSH
27106: LD_INT 400
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27114: LD_VAR 0 6
27118: PPUSH
27119: CALL_OW 264
27123: PUSH
27124: LD_INT 14
27126: PUSH
27127: LD_INT 53
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: IN
27134: IFFALSE 27155
// points := [ 40 , 10 , 20 ] ;
27136: LD_ADDR_VAR 0 9
27140: PUSH
27141: LD_INT 40
27143: PUSH
27144: LD_INT 10
27146: PUSH
27147: LD_INT 20
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27155: LD_VAR 0 6
27159: PPUSH
27160: CALL_OW 264
27164: PUSH
27165: LD_INT 9
27167: PUSH
27168: EMPTY
27169: LIST
27170: IN
27171: IFFALSE 27192
// points := [ 5 , 70 , 20 ] ;
27173: LD_ADDR_VAR 0 9
27177: PUSH
27178: LD_INT 5
27180: PUSH
27181: LD_INT 70
27183: PUSH
27184: LD_INT 20
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27192: LD_VAR 0 6
27196: PPUSH
27197: CALL_OW 264
27201: PUSH
27202: LD_INT 10
27204: PUSH
27205: EMPTY
27206: LIST
27207: IN
27208: IFFALSE 27229
// points := [ 35 , 110 , 70 ] ;
27210: LD_ADDR_VAR 0 9
27214: PUSH
27215: LD_INT 35
27217: PUSH
27218: LD_INT 110
27220: PUSH
27221: LD_INT 70
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: LIST
27228: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27229: LD_VAR 0 6
27233: PPUSH
27234: CALL_OW 265
27238: PUSH
27239: LD_INT 25
27241: EQUAL
27242: IFFALSE 27263
// points := [ 80 , 65 , 100 ] ;
27244: LD_ADDR_VAR 0 9
27248: PUSH
27249: LD_INT 80
27251: PUSH
27252: LD_INT 65
27254: PUSH
27255: LD_INT 100
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27263: LD_VAR 0 6
27267: PPUSH
27268: CALL_OW 263
27272: PUSH
27273: LD_INT 1
27275: EQUAL
27276: IFFALSE 27311
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27278: LD_ADDR_VAR 0 10
27282: PUSH
27283: LD_VAR 0 10
27287: PUSH
27288: LD_VAR 0 6
27292: PPUSH
27293: CALL_OW 311
27297: PPUSH
27298: LD_INT 3
27300: PPUSH
27301: CALL_OW 259
27305: PUSH
27306: LD_INT 4
27308: MUL
27309: MUL
27310: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27311: LD_VAR 0 6
27315: PPUSH
27316: CALL_OW 263
27320: PUSH
27321: LD_INT 2
27323: EQUAL
27324: IFFALSE 27375
// begin j := IsControledBy ( i ) ;
27326: LD_ADDR_VAR 0 7
27330: PUSH
27331: LD_VAR 0 6
27335: PPUSH
27336: CALL_OW 312
27340: ST_TO_ADDR
// if j then
27341: LD_VAR 0 7
27345: IFFALSE 27375
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27347: LD_ADDR_VAR 0 10
27351: PUSH
27352: LD_VAR 0 10
27356: PUSH
27357: LD_VAR 0 7
27361: PPUSH
27362: LD_INT 3
27364: PPUSH
27365: CALL_OW 259
27369: PUSH
27370: LD_INT 3
27372: MUL
27373: MUL
27374: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27375: LD_VAR 0 6
27379: PPUSH
27380: CALL_OW 264
27384: PUSH
27385: LD_INT 5
27387: PUSH
27388: LD_INT 6
27390: PUSH
27391: LD_INT 46
27393: PUSH
27394: LD_INT 44
27396: PUSH
27397: LD_INT 47
27399: PUSH
27400: LD_INT 45
27402: PUSH
27403: LD_INT 28
27405: PUSH
27406: LD_INT 7
27408: PUSH
27409: LD_INT 27
27411: PUSH
27412: LD_INT 29
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: LIST
27422: LIST
27423: LIST
27424: LIST
27425: LIST
27426: IN
27427: PUSH
27428: LD_VAR 0 1
27432: PPUSH
27433: LD_INT 52
27435: PPUSH
27436: CALL_OW 321
27440: PUSH
27441: LD_INT 2
27443: EQUAL
27444: AND
27445: IFFALSE 27462
// bpoints := bpoints * 1.2 ;
27447: LD_ADDR_VAR 0 10
27451: PUSH
27452: LD_VAR 0 10
27456: PUSH
27457: LD_REAL  1.20000000000000E+0000
27460: MUL
27461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27462: LD_VAR 0 6
27466: PPUSH
27467: CALL_OW 264
27471: PUSH
27472: LD_INT 6
27474: PUSH
27475: LD_INT 46
27477: PUSH
27478: LD_INT 47
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: LIST
27485: IN
27486: IFFALSE 27503
// bpoints := bpoints * 1.2 ;
27488: LD_ADDR_VAR 0 10
27492: PUSH
27493: LD_VAR 0 10
27497: PUSH
27498: LD_REAL  1.20000000000000E+0000
27501: MUL
27502: ST_TO_ADDR
// end ; unit_building :
27503: GO 27517
27505: LD_INT 3
27507: DOUBLE
27508: EQUAL
27509: IFTRUE 27513
27511: GO 27516
27513: POP
// ; end ;
27514: GO 27517
27516: POP
// for j = 1 to 3 do
27517: LD_ADDR_VAR 0 7
27521: PUSH
27522: DOUBLE
27523: LD_INT 1
27525: DEC
27526: ST_TO_ADDR
27527: LD_INT 3
27529: PUSH
27530: FOR_TO
27531: IFFALSE 27584
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27533: LD_ADDR_VAR 0 5
27537: PUSH
27538: LD_VAR 0 5
27542: PPUSH
27543: LD_VAR 0 7
27547: PPUSH
27548: LD_VAR 0 5
27552: PUSH
27553: LD_VAR 0 7
27557: ARRAY
27558: PUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 7
27568: ARRAY
27569: PUSH
27570: LD_VAR 0 10
27574: MUL
27575: PLUS
27576: PPUSH
27577: CALL_OW 1
27581: ST_TO_ADDR
27582: GO 27530
27584: POP
27585: POP
// end ;
27586: GO 26065
27588: POP
27589: POP
// result := Replace ( result , 4 , tmp ) ;
27590: LD_ADDR_VAR 0 5
27594: PUSH
27595: LD_VAR 0 5
27599: PPUSH
27600: LD_INT 4
27602: PPUSH
27603: LD_VAR 0 8
27607: PPUSH
27608: CALL_OW 1
27612: ST_TO_ADDR
// end ;
27613: LD_VAR 0 5
27617: RET
// export function DangerAtRange ( unit , range ) ; begin
27618: LD_INT 0
27620: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27621: LD_ADDR_VAR 0 3
27625: PUSH
27626: LD_VAR 0 1
27630: PPUSH
27631: CALL_OW 255
27635: PPUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 250
27645: PPUSH
27646: LD_VAR 0 1
27650: PPUSH
27651: CALL_OW 251
27655: PPUSH
27656: LD_VAR 0 2
27660: PPUSH
27661: CALL 25917 0 4
27665: ST_TO_ADDR
// end ;
27666: LD_VAR 0 3
27670: RET
// export function DangerInArea ( side , area ) ; begin
27671: LD_INT 0
27673: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27674: LD_ADDR_VAR 0 3
27678: PUSH
27679: LD_VAR 0 2
27683: PPUSH
27684: LD_INT 81
27686: PUSH
27687: LD_VAR 0 1
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PPUSH
27696: CALL_OW 70
27700: ST_TO_ADDR
// end ;
27701: LD_VAR 0 3
27705: RET
// export function IsExtension ( b ) ; begin
27706: LD_INT 0
27708: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27709: LD_ADDR_VAR 0 2
27713: PUSH
27714: LD_VAR 0 1
27718: PUSH
27719: LD_INT 23
27721: PUSH
27722: LD_INT 20
27724: PUSH
27725: LD_INT 22
27727: PUSH
27728: LD_INT 17
27730: PUSH
27731: LD_INT 24
27733: PUSH
27734: LD_INT 21
27736: PUSH
27737: LD_INT 19
27739: PUSH
27740: LD_INT 16
27742: PUSH
27743: LD_INT 25
27745: PUSH
27746: LD_INT 18
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: IN
27761: ST_TO_ADDR
// end ;
27762: LD_VAR 0 2
27766: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27767: LD_INT 0
27769: PPUSH
27770: PPUSH
27771: PPUSH
// result := [ ] ;
27772: LD_ADDR_VAR 0 4
27776: PUSH
27777: EMPTY
27778: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27779: LD_ADDR_VAR 0 5
27783: PUSH
27784: LD_VAR 0 2
27788: PPUSH
27789: LD_INT 21
27791: PUSH
27792: LD_INT 3
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PPUSH
27799: CALL_OW 70
27803: ST_TO_ADDR
// if not tmp then
27804: LD_VAR 0 5
27808: NOT
27809: IFFALSE 27813
// exit ;
27811: GO 27877
// if checkLink then
27813: LD_VAR 0 3
27817: IFFALSE 27867
// begin for i in tmp do
27819: LD_ADDR_VAR 0 6
27823: PUSH
27824: LD_VAR 0 5
27828: PUSH
27829: FOR_IN
27830: IFFALSE 27865
// if GetBase ( i ) <> base then
27832: LD_VAR 0 6
27836: PPUSH
27837: CALL_OW 274
27841: PUSH
27842: LD_VAR 0 1
27846: NONEQUAL
27847: IFFALSE 27863
// ComLinkToBase ( base , i ) ;
27849: LD_VAR 0 1
27853: PPUSH
27854: LD_VAR 0 6
27858: PPUSH
27859: CALL_OW 169
27863: GO 27829
27865: POP
27866: POP
// end ; result := tmp ;
27867: LD_ADDR_VAR 0 4
27871: PUSH
27872: LD_VAR 0 5
27876: ST_TO_ADDR
// end ;
27877: LD_VAR 0 4
27881: RET
// export function ComComplete ( units , b ) ; var i ; begin
27882: LD_INT 0
27884: PPUSH
27885: PPUSH
// if not units then
27886: LD_VAR 0 1
27890: NOT
27891: IFFALSE 27895
// exit ;
27893: GO 27985
// for i in units do
27895: LD_ADDR_VAR 0 4
27899: PUSH
27900: LD_VAR 0 1
27904: PUSH
27905: FOR_IN
27906: IFFALSE 27983
// if BuildingStatus ( b ) = bs_build then
27908: LD_VAR 0 2
27912: PPUSH
27913: CALL_OW 461
27917: PUSH
27918: LD_INT 1
27920: EQUAL
27921: IFFALSE 27981
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27923: LD_VAR 0 4
27927: PPUSH
27928: LD_STRING h
27930: PUSH
27931: LD_VAR 0 2
27935: PPUSH
27936: CALL_OW 250
27940: PUSH
27941: LD_VAR 0 2
27945: PPUSH
27946: CALL_OW 251
27950: PUSH
27951: LD_VAR 0 2
27955: PUSH
27956: LD_INT 0
27958: PUSH
27959: LD_INT 0
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: PUSH
27974: EMPTY
27975: LIST
27976: PPUSH
27977: CALL_OW 446
27981: GO 27905
27983: POP
27984: POP
// end ;
27985: LD_VAR 0 3
27989: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27990: LD_INT 0
27992: PPUSH
27993: PPUSH
27994: PPUSH
27995: PPUSH
27996: PPUSH
27997: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27998: LD_VAR 0 1
28002: NOT
28003: PUSH
28004: LD_VAR 0 1
28008: PPUSH
28009: CALL_OW 263
28013: PUSH
28014: LD_INT 2
28016: NONEQUAL
28017: OR
28018: IFFALSE 28022
// exit ;
28020: GO 28338
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28022: LD_ADDR_VAR 0 6
28026: PUSH
28027: LD_INT 22
28029: PUSH
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 255
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 30
28049: PUSH
28050: LD_INT 36
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 34
28059: PUSH
28060: LD_INT 31
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: LIST
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PPUSH
28076: CALL_OW 69
28080: ST_TO_ADDR
// if not tmp then
28081: LD_VAR 0 6
28085: NOT
28086: IFFALSE 28090
// exit ;
28088: GO 28338
// result := [ ] ;
28090: LD_ADDR_VAR 0 2
28094: PUSH
28095: EMPTY
28096: ST_TO_ADDR
// for i in tmp do
28097: LD_ADDR_VAR 0 3
28101: PUSH
28102: LD_VAR 0 6
28106: PUSH
28107: FOR_IN
28108: IFFALSE 28179
// begin t := UnitsInside ( i ) ;
28110: LD_ADDR_VAR 0 4
28114: PUSH
28115: LD_VAR 0 3
28119: PPUSH
28120: CALL_OW 313
28124: ST_TO_ADDR
// if t then
28125: LD_VAR 0 4
28129: IFFALSE 28177
// for j in t do
28131: LD_ADDR_VAR 0 7
28135: PUSH
28136: LD_VAR 0 4
28140: PUSH
28141: FOR_IN
28142: IFFALSE 28175
// result := Replace ( result , result + 1 , j ) ;
28144: LD_ADDR_VAR 0 2
28148: PUSH
28149: LD_VAR 0 2
28153: PPUSH
28154: LD_VAR 0 2
28158: PUSH
28159: LD_INT 1
28161: PLUS
28162: PPUSH
28163: LD_VAR 0 7
28167: PPUSH
28168: CALL_OW 1
28172: ST_TO_ADDR
28173: GO 28141
28175: POP
28176: POP
// end ;
28177: GO 28107
28179: POP
28180: POP
// if not result then
28181: LD_VAR 0 2
28185: NOT
28186: IFFALSE 28190
// exit ;
28188: GO 28338
// mech := result [ 1 ] ;
28190: LD_ADDR_VAR 0 5
28194: PUSH
28195: LD_VAR 0 2
28199: PUSH
28200: LD_INT 1
28202: ARRAY
28203: ST_TO_ADDR
// if result > 1 then
28204: LD_VAR 0 2
28208: PUSH
28209: LD_INT 1
28211: GREATER
28212: IFFALSE 28324
// begin for i = 2 to result do
28214: LD_ADDR_VAR 0 3
28218: PUSH
28219: DOUBLE
28220: LD_INT 2
28222: DEC
28223: ST_TO_ADDR
28224: LD_VAR 0 2
28228: PUSH
28229: FOR_TO
28230: IFFALSE 28322
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28232: LD_ADDR_VAR 0 4
28236: PUSH
28237: LD_VAR 0 2
28241: PUSH
28242: LD_VAR 0 3
28246: ARRAY
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL_OW 259
28255: PUSH
28256: LD_VAR 0 2
28260: PUSH
28261: LD_VAR 0 3
28265: ARRAY
28266: PPUSH
28267: CALL_OW 432
28271: MINUS
28272: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28273: LD_VAR 0 4
28277: PUSH
28278: LD_VAR 0 5
28282: PPUSH
28283: LD_INT 3
28285: PPUSH
28286: CALL_OW 259
28290: PUSH
28291: LD_VAR 0 5
28295: PPUSH
28296: CALL_OW 432
28300: MINUS
28301: GREATEREQUAL
28302: IFFALSE 28320
// mech := result [ i ] ;
28304: LD_ADDR_VAR 0 5
28308: PUSH
28309: LD_VAR 0 2
28313: PUSH
28314: LD_VAR 0 3
28318: ARRAY
28319: ST_TO_ADDR
// end ;
28320: GO 28229
28322: POP
28323: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28324: LD_VAR 0 1
28328: PPUSH
28329: LD_VAR 0 5
28333: PPUSH
28334: CALL_OW 135
// end ;
28338: LD_VAR 0 2
28342: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28343: LD_INT 0
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
// result := [ ] ;
28358: LD_ADDR_VAR 0 7
28362: PUSH
28363: EMPTY
28364: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28365: LD_VAR 0 1
28369: PPUSH
28370: CALL_OW 266
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: LD_INT 1
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: IN
28385: NOT
28386: IFFALSE 28390
// exit ;
28388: GO 30024
// if name then
28390: LD_VAR 0 3
28394: IFFALSE 28410
// SetBName ( base_dep , name ) ;
28396: LD_VAR 0 1
28400: PPUSH
28401: LD_VAR 0 3
28405: PPUSH
28406: CALL_OW 500
// base := GetBase ( base_dep ) ;
28410: LD_ADDR_VAR 0 15
28414: PUSH
28415: LD_VAR 0 1
28419: PPUSH
28420: CALL_OW 274
28424: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28425: LD_ADDR_VAR 0 16
28429: PUSH
28430: LD_VAR 0 1
28434: PPUSH
28435: CALL_OW 255
28439: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28440: LD_ADDR_VAR 0 17
28444: PUSH
28445: LD_VAR 0 1
28449: PPUSH
28450: CALL_OW 248
28454: ST_TO_ADDR
// if sources then
28455: LD_VAR 0 5
28459: IFFALSE 28506
// for i = 1 to 3 do
28461: LD_ADDR_VAR 0 8
28465: PUSH
28466: DOUBLE
28467: LD_INT 1
28469: DEC
28470: ST_TO_ADDR
28471: LD_INT 3
28473: PUSH
28474: FOR_TO
28475: IFFALSE 28504
// AddResourceType ( base , i , sources [ i ] ) ;
28477: LD_VAR 0 15
28481: PPUSH
28482: LD_VAR 0 8
28486: PPUSH
28487: LD_VAR 0 5
28491: PUSH
28492: LD_VAR 0 8
28496: ARRAY
28497: PPUSH
28498: CALL_OW 276
28502: GO 28474
28504: POP
28505: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28506: LD_ADDR_VAR 0 18
28510: PUSH
28511: LD_VAR 0 15
28515: PPUSH
28516: LD_VAR 0 2
28520: PPUSH
28521: LD_INT 1
28523: PPUSH
28524: CALL 27767 0 3
28528: ST_TO_ADDR
// InitHc ;
28529: CALL_OW 19
// InitUc ;
28533: CALL_OW 18
// uc_side := side ;
28537: LD_ADDR_OWVAR 20
28541: PUSH
28542: LD_VAR 0 16
28546: ST_TO_ADDR
// uc_nation := nation ;
28547: LD_ADDR_OWVAR 21
28551: PUSH
28552: LD_VAR 0 17
28556: ST_TO_ADDR
// if buildings then
28557: LD_VAR 0 18
28561: IFFALSE 29883
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28563: LD_ADDR_VAR 0 19
28567: PUSH
28568: LD_VAR 0 18
28572: PPUSH
28573: LD_INT 2
28575: PUSH
28576: LD_INT 30
28578: PUSH
28579: LD_INT 29
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 30
28588: PUSH
28589: LD_INT 30
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: PPUSH
28601: CALL_OW 72
28605: ST_TO_ADDR
// if tmp then
28606: LD_VAR 0 19
28610: IFFALSE 28658
// for i in tmp do
28612: LD_ADDR_VAR 0 8
28616: PUSH
28617: LD_VAR 0 19
28621: PUSH
28622: FOR_IN
28623: IFFALSE 28656
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28625: LD_VAR 0 8
28629: PPUSH
28630: CALL_OW 250
28634: PPUSH
28635: LD_VAR 0 8
28639: PPUSH
28640: CALL_OW 251
28644: PPUSH
28645: LD_VAR 0 16
28649: PPUSH
28650: CALL_OW 441
28654: GO 28622
28656: POP
28657: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28658: LD_VAR 0 18
28662: PPUSH
28663: LD_INT 2
28665: PUSH
28666: LD_INT 30
28668: PUSH
28669: LD_INT 32
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 30
28678: PUSH
28679: LD_INT 33
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: LIST
28690: PPUSH
28691: CALL_OW 72
28695: IFFALSE 28783
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28697: LD_ADDR_VAR 0 8
28701: PUSH
28702: LD_VAR 0 18
28706: PPUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: LD_INT 32
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 30
28722: PUSH
28723: LD_INT 33
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: LIST
28734: PPUSH
28735: CALL_OW 72
28739: PUSH
28740: FOR_IN
28741: IFFALSE 28781
// begin if not GetBWeapon ( i ) then
28743: LD_VAR 0 8
28747: PPUSH
28748: CALL_OW 269
28752: NOT
28753: IFFALSE 28779
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28755: LD_VAR 0 8
28759: PPUSH
28760: LD_VAR 0 8
28764: PPUSH
28765: LD_VAR 0 2
28769: PPUSH
28770: CALL 30029 0 2
28774: PPUSH
28775: CALL_OW 431
// end ;
28779: GO 28740
28781: POP
28782: POP
// end ; for i = 1 to personel do
28783: LD_ADDR_VAR 0 8
28787: PUSH
28788: DOUBLE
28789: LD_INT 1
28791: DEC
28792: ST_TO_ADDR
28793: LD_VAR 0 6
28797: PUSH
28798: FOR_TO
28799: IFFALSE 29863
// begin if i > 4 then
28801: LD_VAR 0 8
28805: PUSH
28806: LD_INT 4
28808: GREATER
28809: IFFALSE 28813
// break ;
28811: GO 29863
// case i of 1 :
28813: LD_VAR 0 8
28817: PUSH
28818: LD_INT 1
28820: DOUBLE
28821: EQUAL
28822: IFTRUE 28826
28824: GO 28906
28826: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28827: LD_ADDR_VAR 0 12
28831: PUSH
28832: LD_VAR 0 18
28836: PPUSH
28837: LD_INT 22
28839: PUSH
28840: LD_VAR 0 16
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 58
28851: PUSH
28852: EMPTY
28853: LIST
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: LD_INT 30
28860: PUSH
28861: LD_INT 32
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 4
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 5
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: LIST
28898: PPUSH
28899: CALL_OW 72
28903: ST_TO_ADDR
28904: GO 29128
28906: LD_INT 2
28908: DOUBLE
28909: EQUAL
28910: IFTRUE 28914
28912: GO 28976
28914: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28915: LD_ADDR_VAR 0 12
28919: PUSH
28920: LD_VAR 0 18
28924: PPUSH
28925: LD_INT 22
28927: PUSH
28928: LD_VAR 0 16
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 2
28939: PUSH
28940: LD_INT 30
28942: PUSH
28943: LD_INT 0
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 30
28952: PUSH
28953: LD_INT 1
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: LIST
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PPUSH
28969: CALL_OW 72
28973: ST_TO_ADDR
28974: GO 29128
28976: LD_INT 3
28978: DOUBLE
28979: EQUAL
28980: IFTRUE 28984
28982: GO 29046
28984: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28985: LD_ADDR_VAR 0 12
28989: PUSH
28990: LD_VAR 0 18
28994: PPUSH
28995: LD_INT 22
28997: PUSH
28998: LD_VAR 0 16
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 30
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 30
29022: PUSH
29023: LD_INT 3
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: LIST
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PPUSH
29039: CALL_OW 72
29043: ST_TO_ADDR
29044: GO 29128
29046: LD_INT 4
29048: DOUBLE
29049: EQUAL
29050: IFTRUE 29054
29052: GO 29127
29054: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29055: LD_ADDR_VAR 0 12
29059: PUSH
29060: LD_VAR 0 18
29064: PPUSH
29065: LD_INT 22
29067: PUSH
29068: LD_VAR 0 16
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 2
29079: PUSH
29080: LD_INT 30
29082: PUSH
29083: LD_INT 6
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 30
29092: PUSH
29093: LD_INT 7
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 30
29102: PUSH
29103: LD_INT 8
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PPUSH
29120: CALL_OW 72
29124: ST_TO_ADDR
29125: GO 29128
29127: POP
// if i = 1 then
29128: LD_VAR 0 8
29132: PUSH
29133: LD_INT 1
29135: EQUAL
29136: IFFALSE 29247
// begin tmp := [ ] ;
29138: LD_ADDR_VAR 0 19
29142: PUSH
29143: EMPTY
29144: ST_TO_ADDR
// for j in f do
29145: LD_ADDR_VAR 0 9
29149: PUSH
29150: LD_VAR 0 12
29154: PUSH
29155: FOR_IN
29156: IFFALSE 29229
// if GetBType ( j ) = b_bunker then
29158: LD_VAR 0 9
29162: PPUSH
29163: CALL_OW 266
29167: PUSH
29168: LD_INT 32
29170: EQUAL
29171: IFFALSE 29198
// tmp := Insert ( tmp , 1 , j ) else
29173: LD_ADDR_VAR 0 19
29177: PUSH
29178: LD_VAR 0 19
29182: PPUSH
29183: LD_INT 1
29185: PPUSH
29186: LD_VAR 0 9
29190: PPUSH
29191: CALL_OW 2
29195: ST_TO_ADDR
29196: GO 29227
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29198: LD_ADDR_VAR 0 19
29202: PUSH
29203: LD_VAR 0 19
29207: PPUSH
29208: LD_VAR 0 19
29212: PUSH
29213: LD_INT 1
29215: PLUS
29216: PPUSH
29217: LD_VAR 0 9
29221: PPUSH
29222: CALL_OW 2
29226: ST_TO_ADDR
29227: GO 29155
29229: POP
29230: POP
// if tmp then
29231: LD_VAR 0 19
29235: IFFALSE 29247
// f := tmp ;
29237: LD_ADDR_VAR 0 12
29241: PUSH
29242: LD_VAR 0 19
29246: ST_TO_ADDR
// end ; x := personel [ i ] ;
29247: LD_ADDR_VAR 0 13
29251: PUSH
29252: LD_VAR 0 6
29256: PUSH
29257: LD_VAR 0 8
29261: ARRAY
29262: ST_TO_ADDR
// if x = - 1 then
29263: LD_VAR 0 13
29267: PUSH
29268: LD_INT 1
29270: NEG
29271: EQUAL
29272: IFFALSE 29481
// begin for j in f do
29274: LD_ADDR_VAR 0 9
29278: PUSH
29279: LD_VAR 0 12
29283: PUSH
29284: FOR_IN
29285: IFFALSE 29477
// repeat InitHc ;
29287: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29291: LD_VAR 0 9
29295: PPUSH
29296: CALL_OW 266
29300: PUSH
29301: LD_INT 5
29303: EQUAL
29304: IFFALSE 29374
// begin if UnitsInside ( j ) < 3 then
29306: LD_VAR 0 9
29310: PPUSH
29311: CALL_OW 313
29315: PUSH
29316: LD_INT 3
29318: LESS
29319: IFFALSE 29355
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29321: LD_INT 0
29323: PPUSH
29324: LD_INT 5
29326: PUSH
29327: LD_INT 8
29329: PUSH
29330: LD_INT 9
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: LIST
29337: PUSH
29338: LD_VAR 0 17
29342: ARRAY
29343: PPUSH
29344: LD_VAR 0 4
29348: PPUSH
29349: CALL_OW 380
29353: GO 29372
// PrepareHuman ( false , i , skill ) ;
29355: LD_INT 0
29357: PPUSH
29358: LD_VAR 0 8
29362: PPUSH
29363: LD_VAR 0 4
29367: PPUSH
29368: CALL_OW 380
// end else
29372: GO 29391
// PrepareHuman ( false , i , skill ) ;
29374: LD_INT 0
29376: PPUSH
29377: LD_VAR 0 8
29381: PPUSH
29382: LD_VAR 0 4
29386: PPUSH
29387: CALL_OW 380
// un := CreateHuman ;
29391: LD_ADDR_VAR 0 14
29395: PUSH
29396: CALL_OW 44
29400: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29401: LD_ADDR_VAR 0 7
29405: PUSH
29406: LD_VAR 0 7
29410: PPUSH
29411: LD_INT 1
29413: PPUSH
29414: LD_VAR 0 14
29418: PPUSH
29419: CALL_OW 2
29423: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29424: LD_VAR 0 14
29428: PPUSH
29429: LD_VAR 0 9
29433: PPUSH
29434: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29438: LD_VAR 0 9
29442: PPUSH
29443: CALL_OW 313
29447: PUSH
29448: LD_INT 6
29450: EQUAL
29451: PUSH
29452: LD_VAR 0 9
29456: PPUSH
29457: CALL_OW 266
29461: PUSH
29462: LD_INT 32
29464: PUSH
29465: LD_INT 31
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: IN
29472: OR
29473: IFFALSE 29287
29475: GO 29284
29477: POP
29478: POP
// end else
29479: GO 29861
// for j = 1 to x do
29481: LD_ADDR_VAR 0 9
29485: PUSH
29486: DOUBLE
29487: LD_INT 1
29489: DEC
29490: ST_TO_ADDR
29491: LD_VAR 0 13
29495: PUSH
29496: FOR_TO
29497: IFFALSE 29859
// begin InitHc ;
29499: CALL_OW 19
// if not f then
29503: LD_VAR 0 12
29507: NOT
29508: IFFALSE 29597
// begin PrepareHuman ( false , i , skill ) ;
29510: LD_INT 0
29512: PPUSH
29513: LD_VAR 0 8
29517: PPUSH
29518: LD_VAR 0 4
29522: PPUSH
29523: CALL_OW 380
// un := CreateHuman ;
29527: LD_ADDR_VAR 0 14
29531: PUSH
29532: CALL_OW 44
29536: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29537: LD_ADDR_VAR 0 7
29541: PUSH
29542: LD_VAR 0 7
29546: PPUSH
29547: LD_INT 1
29549: PPUSH
29550: LD_VAR 0 14
29554: PPUSH
29555: CALL_OW 2
29559: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29560: LD_VAR 0 14
29564: PPUSH
29565: LD_VAR 0 1
29569: PPUSH
29570: CALL_OW 250
29574: PPUSH
29575: LD_VAR 0 1
29579: PPUSH
29580: CALL_OW 251
29584: PPUSH
29585: LD_INT 10
29587: PPUSH
29588: LD_INT 0
29590: PPUSH
29591: CALL_OW 50
// continue ;
29595: GO 29496
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29597: LD_VAR 0 12
29601: PUSH
29602: LD_INT 1
29604: ARRAY
29605: PPUSH
29606: CALL_OW 313
29610: PUSH
29611: LD_VAR 0 12
29615: PUSH
29616: LD_INT 1
29618: ARRAY
29619: PPUSH
29620: CALL_OW 266
29624: PUSH
29625: LD_INT 32
29627: PUSH
29628: LD_INT 31
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: IN
29635: AND
29636: PUSH
29637: LD_VAR 0 12
29641: PUSH
29642: LD_INT 1
29644: ARRAY
29645: PPUSH
29646: CALL_OW 313
29650: PUSH
29651: LD_INT 6
29653: EQUAL
29654: OR
29655: IFFALSE 29675
// f := Delete ( f , 1 ) ;
29657: LD_ADDR_VAR 0 12
29661: PUSH
29662: LD_VAR 0 12
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 3
29674: ST_TO_ADDR
// if not f then
29675: LD_VAR 0 12
29679: NOT
29680: IFFALSE 29698
// begin x := x + 2 ;
29682: LD_ADDR_VAR 0 13
29686: PUSH
29687: LD_VAR 0 13
29691: PUSH
29692: LD_INT 2
29694: PLUS
29695: ST_TO_ADDR
// continue ;
29696: GO 29496
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29698: LD_VAR 0 12
29702: PUSH
29703: LD_INT 1
29705: ARRAY
29706: PPUSH
29707: CALL_OW 266
29711: PUSH
29712: LD_INT 5
29714: EQUAL
29715: IFFALSE 29789
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29717: LD_VAR 0 12
29721: PUSH
29722: LD_INT 1
29724: ARRAY
29725: PPUSH
29726: CALL_OW 313
29730: PUSH
29731: LD_INT 3
29733: LESS
29734: IFFALSE 29770
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29736: LD_INT 0
29738: PPUSH
29739: LD_INT 5
29741: PUSH
29742: LD_INT 8
29744: PUSH
29745: LD_INT 9
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: LIST
29752: PUSH
29753: LD_VAR 0 17
29757: ARRAY
29758: PPUSH
29759: LD_VAR 0 4
29763: PPUSH
29764: CALL_OW 380
29768: GO 29787
// PrepareHuman ( false , i , skill ) ;
29770: LD_INT 0
29772: PPUSH
29773: LD_VAR 0 8
29777: PPUSH
29778: LD_VAR 0 4
29782: PPUSH
29783: CALL_OW 380
// end else
29787: GO 29806
// PrepareHuman ( false , i , skill ) ;
29789: LD_INT 0
29791: PPUSH
29792: LD_VAR 0 8
29796: PPUSH
29797: LD_VAR 0 4
29801: PPUSH
29802: CALL_OW 380
// un := CreateHuman ;
29806: LD_ADDR_VAR 0 14
29810: PUSH
29811: CALL_OW 44
29815: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29816: LD_ADDR_VAR 0 7
29820: PUSH
29821: LD_VAR 0 7
29825: PPUSH
29826: LD_INT 1
29828: PPUSH
29829: LD_VAR 0 14
29833: PPUSH
29834: CALL_OW 2
29838: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29839: LD_VAR 0 14
29843: PPUSH
29844: LD_VAR 0 12
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: PPUSH
29853: CALL_OW 52
// end ;
29857: GO 29496
29859: POP
29860: POP
// end ;
29861: GO 28798
29863: POP
29864: POP
// result := result ^ buildings ;
29865: LD_ADDR_VAR 0 7
29869: PUSH
29870: LD_VAR 0 7
29874: PUSH
29875: LD_VAR 0 18
29879: ADD
29880: ST_TO_ADDR
// end else
29881: GO 30024
// begin for i = 1 to personel do
29883: LD_ADDR_VAR 0 8
29887: PUSH
29888: DOUBLE
29889: LD_INT 1
29891: DEC
29892: ST_TO_ADDR
29893: LD_VAR 0 6
29897: PUSH
29898: FOR_TO
29899: IFFALSE 30022
// begin if i > 4 then
29901: LD_VAR 0 8
29905: PUSH
29906: LD_INT 4
29908: GREATER
29909: IFFALSE 29913
// break ;
29911: GO 30022
// x := personel [ i ] ;
29913: LD_ADDR_VAR 0 13
29917: PUSH
29918: LD_VAR 0 6
29922: PUSH
29923: LD_VAR 0 8
29927: ARRAY
29928: ST_TO_ADDR
// if x = - 1 then
29929: LD_VAR 0 13
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: EQUAL
29938: IFFALSE 29942
// continue ;
29940: GO 29898
// PrepareHuman ( false , i , skill ) ;
29942: LD_INT 0
29944: PPUSH
29945: LD_VAR 0 8
29949: PPUSH
29950: LD_VAR 0 4
29954: PPUSH
29955: CALL_OW 380
// un := CreateHuman ;
29959: LD_ADDR_VAR 0 14
29963: PUSH
29964: CALL_OW 44
29968: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29969: LD_VAR 0 14
29973: PPUSH
29974: LD_VAR 0 1
29978: PPUSH
29979: CALL_OW 250
29983: PPUSH
29984: LD_VAR 0 1
29988: PPUSH
29989: CALL_OW 251
29993: PPUSH
29994: LD_INT 10
29996: PPUSH
29997: LD_INT 0
29999: PPUSH
30000: CALL_OW 50
// result := result ^ un ;
30004: LD_ADDR_VAR 0 7
30008: PUSH
30009: LD_VAR 0 7
30013: PUSH
30014: LD_VAR 0 14
30018: ADD
30019: ST_TO_ADDR
// end ;
30020: GO 29898
30022: POP
30023: POP
// end ; end ;
30024: LD_VAR 0 7
30028: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30029: LD_INT 0
30031: PPUSH
30032: PPUSH
30033: PPUSH
30034: PPUSH
30035: PPUSH
30036: PPUSH
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
30043: PPUSH
30044: PPUSH
30045: PPUSH
30046: PPUSH
// result := false ;
30047: LD_ADDR_VAR 0 3
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30055: LD_VAR 0 1
30059: NOT
30060: PUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 266
30070: PUSH
30071: LD_INT 32
30073: PUSH
30074: LD_INT 33
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: IN
30081: NOT
30082: OR
30083: IFFALSE 30087
// exit ;
30085: GO 31196
// nat := GetNation ( tower ) ;
30087: LD_ADDR_VAR 0 12
30091: PUSH
30092: LD_VAR 0 1
30096: PPUSH
30097: CALL_OW 248
30101: ST_TO_ADDR
// side := GetSide ( tower ) ;
30102: LD_ADDR_VAR 0 16
30106: PUSH
30107: LD_VAR 0 1
30111: PPUSH
30112: CALL_OW 255
30116: ST_TO_ADDR
// x := GetX ( tower ) ;
30117: LD_ADDR_VAR 0 10
30121: PUSH
30122: LD_VAR 0 1
30126: PPUSH
30127: CALL_OW 250
30131: ST_TO_ADDR
// y := GetY ( tower ) ;
30132: LD_ADDR_VAR 0 11
30136: PUSH
30137: LD_VAR 0 1
30141: PPUSH
30142: CALL_OW 251
30146: ST_TO_ADDR
// if not x or not y then
30147: LD_VAR 0 10
30151: NOT
30152: PUSH
30153: LD_VAR 0 11
30157: NOT
30158: OR
30159: IFFALSE 30163
// exit ;
30161: GO 31196
// weapon := 0 ;
30163: LD_ADDR_VAR 0 18
30167: PUSH
30168: LD_INT 0
30170: ST_TO_ADDR
// fac_list := [ ] ;
30171: LD_ADDR_VAR 0 17
30175: PUSH
30176: EMPTY
30177: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30178: LD_ADDR_VAR 0 6
30182: PUSH
30183: LD_VAR 0 1
30187: PPUSH
30188: CALL_OW 274
30192: PPUSH
30193: LD_VAR 0 2
30197: PPUSH
30198: LD_INT 0
30200: PPUSH
30201: CALL 27767 0 3
30205: PPUSH
30206: LD_INT 30
30208: PUSH
30209: LD_INT 3
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PPUSH
30216: CALL_OW 72
30220: ST_TO_ADDR
// if not factories then
30221: LD_VAR 0 6
30225: NOT
30226: IFFALSE 30230
// exit ;
30228: GO 31196
// for i in factories do
30230: LD_ADDR_VAR 0 8
30234: PUSH
30235: LD_VAR 0 6
30239: PUSH
30240: FOR_IN
30241: IFFALSE 30266
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30243: LD_ADDR_VAR 0 17
30247: PUSH
30248: LD_VAR 0 17
30252: PUSH
30253: LD_VAR 0 8
30257: PPUSH
30258: CALL_OW 478
30262: UNION
30263: ST_TO_ADDR
30264: GO 30240
30266: POP
30267: POP
// if not fac_list then
30268: LD_VAR 0 17
30272: NOT
30273: IFFALSE 30277
// exit ;
30275: GO 31196
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30277: LD_ADDR_VAR 0 5
30281: PUSH
30282: LD_INT 4
30284: PUSH
30285: LD_INT 5
30287: PUSH
30288: LD_INT 9
30290: PUSH
30291: LD_INT 10
30293: PUSH
30294: LD_INT 6
30296: PUSH
30297: LD_INT 7
30299: PUSH
30300: LD_INT 11
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 27
30314: PUSH
30315: LD_INT 28
30317: PUSH
30318: LD_INT 26
30320: PUSH
30321: LD_INT 30
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 43
30332: PUSH
30333: LD_INT 44
30335: PUSH
30336: LD_INT 46
30338: PUSH
30339: LD_INT 45
30341: PUSH
30342: LD_INT 47
30344: PUSH
30345: LD_INT 49
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: LIST
30360: PUSH
30361: LD_VAR 0 12
30365: ARRAY
30366: ST_TO_ADDR
// list := list isect fac_list ;
30367: LD_ADDR_VAR 0 5
30371: PUSH
30372: LD_VAR 0 5
30376: PUSH
30377: LD_VAR 0 17
30381: ISECT
30382: ST_TO_ADDR
// if not list then
30383: LD_VAR 0 5
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 31196
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30392: LD_VAR 0 12
30396: PUSH
30397: LD_INT 3
30399: EQUAL
30400: PUSH
30401: LD_INT 49
30403: PUSH
30404: LD_VAR 0 5
30408: IN
30409: AND
30410: PUSH
30411: LD_INT 31
30413: PPUSH
30414: LD_VAR 0 16
30418: PPUSH
30419: CALL_OW 321
30423: PUSH
30424: LD_INT 2
30426: EQUAL
30427: AND
30428: IFFALSE 30488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30430: LD_INT 22
30432: PUSH
30433: LD_VAR 0 16
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 35
30444: PUSH
30445: LD_INT 49
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 91
30454: PUSH
30455: LD_VAR 0 1
30459: PUSH
30460: LD_INT 10
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: LIST
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: LIST
30472: PPUSH
30473: CALL_OW 69
30477: NOT
30478: IFFALSE 30488
// weapon := ru_time_lapser ;
30480: LD_ADDR_VAR 0 18
30484: PUSH
30485: LD_INT 49
30487: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30488: LD_VAR 0 12
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: IN
30503: PUSH
30504: LD_INT 11
30506: PUSH
30507: LD_VAR 0 5
30511: IN
30512: PUSH
30513: LD_INT 30
30515: PUSH
30516: LD_VAR 0 5
30520: IN
30521: OR
30522: AND
30523: PUSH
30524: LD_INT 6
30526: PPUSH
30527: LD_VAR 0 16
30531: PPUSH
30532: CALL_OW 321
30536: PUSH
30537: LD_INT 2
30539: EQUAL
30540: AND
30541: IFFALSE 30706
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30543: LD_INT 22
30545: PUSH
30546: LD_VAR 0 16
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: LD_INT 35
30560: PUSH
30561: LD_INT 11
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 35
30570: PUSH
30571: LD_INT 30
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 91
30585: PUSH
30586: LD_VAR 0 1
30590: PUSH
30591: LD_INT 18
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: LIST
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: PPUSH
30604: CALL_OW 69
30608: NOT
30609: PUSH
30610: LD_INT 22
30612: PUSH
30613: LD_VAR 0 16
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 32
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 30
30637: PUSH
30638: LD_INT 33
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 91
30652: PUSH
30653: LD_VAR 0 1
30657: PUSH
30658: LD_INT 12
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: LIST
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: PPUSH
30674: CALL_OW 69
30678: PUSH
30679: LD_INT 2
30681: GREATER
30682: AND
30683: IFFALSE 30706
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30685: LD_ADDR_VAR 0 18
30689: PUSH
30690: LD_INT 11
30692: PUSH
30693: LD_INT 30
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_VAR 0 12
30704: ARRAY
30705: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30706: LD_VAR 0 18
30710: NOT
30711: PUSH
30712: LD_INT 40
30714: PPUSH
30715: LD_VAR 0 16
30719: PPUSH
30720: CALL_OW 321
30724: PUSH
30725: LD_INT 2
30727: EQUAL
30728: AND
30729: PUSH
30730: LD_INT 7
30732: PUSH
30733: LD_VAR 0 5
30737: IN
30738: PUSH
30739: LD_INT 28
30741: PUSH
30742: LD_VAR 0 5
30746: IN
30747: OR
30748: PUSH
30749: LD_INT 45
30751: PUSH
30752: LD_VAR 0 5
30756: IN
30757: OR
30758: AND
30759: IFFALSE 31013
// begin hex := GetHexInfo ( x , y ) ;
30761: LD_ADDR_VAR 0 4
30765: PUSH
30766: LD_VAR 0 10
30770: PPUSH
30771: LD_VAR 0 11
30775: PPUSH
30776: CALL_OW 546
30780: ST_TO_ADDR
// if hex [ 1 ] then
30781: LD_VAR 0 4
30785: PUSH
30786: LD_INT 1
30788: ARRAY
30789: IFFALSE 30793
// exit ;
30791: GO 31196
// height := hex [ 2 ] ;
30793: LD_ADDR_VAR 0 15
30797: PUSH
30798: LD_VAR 0 4
30802: PUSH
30803: LD_INT 2
30805: ARRAY
30806: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30807: LD_ADDR_VAR 0 14
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: LD_INT 2
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 5
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: ST_TO_ADDR
// for i in tmp do
30830: LD_ADDR_VAR 0 8
30834: PUSH
30835: LD_VAR 0 14
30839: PUSH
30840: FOR_IN
30841: IFFALSE 31011
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30843: LD_ADDR_VAR 0 9
30847: PUSH
30848: LD_VAR 0 10
30852: PPUSH
30853: LD_VAR 0 8
30857: PPUSH
30858: LD_INT 5
30860: PPUSH
30861: CALL_OW 272
30865: PUSH
30866: LD_VAR 0 11
30870: PPUSH
30871: LD_VAR 0 8
30875: PPUSH
30876: LD_INT 5
30878: PPUSH
30879: CALL_OW 273
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30888: LD_VAR 0 9
30892: PUSH
30893: LD_INT 1
30895: ARRAY
30896: PPUSH
30897: LD_VAR 0 9
30901: PUSH
30902: LD_INT 2
30904: ARRAY
30905: PPUSH
30906: CALL_OW 488
30910: IFFALSE 31009
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30912: LD_ADDR_VAR 0 4
30916: PUSH
30917: LD_VAR 0 9
30921: PUSH
30922: LD_INT 1
30924: ARRAY
30925: PPUSH
30926: LD_VAR 0 9
30930: PUSH
30931: LD_INT 2
30933: ARRAY
30934: PPUSH
30935: CALL_OW 546
30939: ST_TO_ADDR
// if hex [ 1 ] then
30940: LD_VAR 0 4
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: IFFALSE 30952
// continue ;
30950: GO 30840
// h := hex [ 2 ] ;
30952: LD_ADDR_VAR 0 13
30956: PUSH
30957: LD_VAR 0 4
30961: PUSH
30962: LD_INT 2
30964: ARRAY
30965: ST_TO_ADDR
// if h + 7 < height then
30966: LD_VAR 0 13
30970: PUSH
30971: LD_INT 7
30973: PLUS
30974: PUSH
30975: LD_VAR 0 15
30979: LESS
30980: IFFALSE 31009
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30982: LD_ADDR_VAR 0 18
30986: PUSH
30987: LD_INT 7
30989: PUSH
30990: LD_INT 28
30992: PUSH
30993: LD_INT 45
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: LIST
31000: PUSH
31001: LD_VAR 0 12
31005: ARRAY
31006: ST_TO_ADDR
// break ;
31007: GO 31011
// end ; end ; end ;
31009: GO 30840
31011: POP
31012: POP
// end ; if not weapon then
31013: LD_VAR 0 18
31017: NOT
31018: IFFALSE 31078
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31020: LD_ADDR_VAR 0 5
31024: PUSH
31025: LD_VAR 0 5
31029: PUSH
31030: LD_INT 11
31032: PUSH
31033: LD_INT 30
31035: PUSH
31036: LD_INT 49
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: LIST
31043: DIFF
31044: ST_TO_ADDR
// if not list then
31045: LD_VAR 0 5
31049: NOT
31050: IFFALSE 31054
// exit ;
31052: GO 31196
// weapon := list [ rand ( 1 , list ) ] ;
31054: LD_ADDR_VAR 0 18
31058: PUSH
31059: LD_VAR 0 5
31063: PUSH
31064: LD_INT 1
31066: PPUSH
31067: LD_VAR 0 5
31071: PPUSH
31072: CALL_OW 12
31076: ARRAY
31077: ST_TO_ADDR
// end ; if weapon then
31078: LD_VAR 0 18
31082: IFFALSE 31196
// begin tmp := CostOfWeapon ( weapon ) ;
31084: LD_ADDR_VAR 0 14
31088: PUSH
31089: LD_VAR 0 18
31093: PPUSH
31094: CALL_OW 451
31098: ST_TO_ADDR
// j := GetBase ( tower ) ;
31099: LD_ADDR_VAR 0 9
31103: PUSH
31104: LD_VAR 0 1
31108: PPUSH
31109: CALL_OW 274
31113: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31114: LD_VAR 0 9
31118: PPUSH
31119: LD_INT 1
31121: PPUSH
31122: CALL_OW 275
31126: PUSH
31127: LD_VAR 0 14
31131: PUSH
31132: LD_INT 1
31134: ARRAY
31135: GREATEREQUAL
31136: PUSH
31137: LD_VAR 0 9
31141: PPUSH
31142: LD_INT 2
31144: PPUSH
31145: CALL_OW 275
31149: PUSH
31150: LD_VAR 0 14
31154: PUSH
31155: LD_INT 2
31157: ARRAY
31158: GREATEREQUAL
31159: AND
31160: PUSH
31161: LD_VAR 0 9
31165: PPUSH
31166: LD_INT 3
31168: PPUSH
31169: CALL_OW 275
31173: PUSH
31174: LD_VAR 0 14
31178: PUSH
31179: LD_INT 3
31181: ARRAY
31182: GREATEREQUAL
31183: AND
31184: IFFALSE 31196
// result := weapon ;
31186: LD_ADDR_VAR 0 3
31190: PUSH
31191: LD_VAR 0 18
31195: ST_TO_ADDR
// end ; end ;
31196: LD_VAR 0 3
31200: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31201: LD_INT 0
31203: PPUSH
31204: PPUSH
// result := true ;
31205: LD_ADDR_VAR 0 3
31209: PUSH
31210: LD_INT 1
31212: ST_TO_ADDR
// if array1 = array2 then
31213: LD_VAR 0 1
31217: PUSH
31218: LD_VAR 0 2
31222: EQUAL
31223: IFFALSE 31283
// begin for i = 1 to array1 do
31225: LD_ADDR_VAR 0 4
31229: PUSH
31230: DOUBLE
31231: LD_INT 1
31233: DEC
31234: ST_TO_ADDR
31235: LD_VAR 0 1
31239: PUSH
31240: FOR_TO
31241: IFFALSE 31279
// if array1 [ i ] <> array2 [ i ] then
31243: LD_VAR 0 1
31247: PUSH
31248: LD_VAR 0 4
31252: ARRAY
31253: PUSH
31254: LD_VAR 0 2
31258: PUSH
31259: LD_VAR 0 4
31263: ARRAY
31264: NONEQUAL
31265: IFFALSE 31277
// begin result := false ;
31267: LD_ADDR_VAR 0 3
31271: PUSH
31272: LD_INT 0
31274: ST_TO_ADDR
// break ;
31275: GO 31279
// end ;
31277: GO 31240
31279: POP
31280: POP
// end else
31281: GO 31291
// result := false ;
31283: LD_ADDR_VAR 0 3
31287: PUSH
31288: LD_INT 0
31290: ST_TO_ADDR
// end ;
31291: LD_VAR 0 3
31295: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31296: LD_INT 0
31298: PPUSH
31299: PPUSH
// if not array1 or not array2 then
31300: LD_VAR 0 1
31304: NOT
31305: PUSH
31306: LD_VAR 0 2
31310: NOT
31311: OR
31312: IFFALSE 31316
// exit ;
31314: GO 31380
// result := true ;
31316: LD_ADDR_VAR 0 3
31320: PUSH
31321: LD_INT 1
31323: ST_TO_ADDR
// for i = 1 to array1 do
31324: LD_ADDR_VAR 0 4
31328: PUSH
31329: DOUBLE
31330: LD_INT 1
31332: DEC
31333: ST_TO_ADDR
31334: LD_VAR 0 1
31338: PUSH
31339: FOR_TO
31340: IFFALSE 31378
// if array1 [ i ] <> array2 [ i ] then
31342: LD_VAR 0 1
31346: PUSH
31347: LD_VAR 0 4
31351: ARRAY
31352: PUSH
31353: LD_VAR 0 2
31357: PUSH
31358: LD_VAR 0 4
31362: ARRAY
31363: NONEQUAL
31364: IFFALSE 31376
// begin result := false ;
31366: LD_ADDR_VAR 0 3
31370: PUSH
31371: LD_INT 0
31373: ST_TO_ADDR
// break ;
31374: GO 31378
// end ;
31376: GO 31339
31378: POP
31379: POP
// end ;
31380: LD_VAR 0 3
31384: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31385: LD_INT 0
31387: PPUSH
31388: PPUSH
31389: PPUSH
// pom := GetBase ( fac ) ;
31390: LD_ADDR_VAR 0 5
31394: PUSH
31395: LD_VAR 0 1
31399: PPUSH
31400: CALL_OW 274
31404: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31405: LD_ADDR_VAR 0 4
31409: PUSH
31410: LD_VAR 0 2
31414: PUSH
31415: LD_INT 1
31417: ARRAY
31418: PPUSH
31419: LD_VAR 0 2
31423: PUSH
31424: LD_INT 2
31426: ARRAY
31427: PPUSH
31428: LD_VAR 0 2
31432: PUSH
31433: LD_INT 3
31435: ARRAY
31436: PPUSH
31437: LD_VAR 0 2
31441: PUSH
31442: LD_INT 4
31444: ARRAY
31445: PPUSH
31446: CALL_OW 449
31450: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31451: LD_ADDR_VAR 0 3
31455: PUSH
31456: LD_VAR 0 5
31460: PPUSH
31461: LD_INT 1
31463: PPUSH
31464: CALL_OW 275
31468: PUSH
31469: LD_VAR 0 4
31473: PUSH
31474: LD_INT 1
31476: ARRAY
31477: GREATEREQUAL
31478: PUSH
31479: LD_VAR 0 5
31483: PPUSH
31484: LD_INT 2
31486: PPUSH
31487: CALL_OW 275
31491: PUSH
31492: LD_VAR 0 4
31496: PUSH
31497: LD_INT 2
31499: ARRAY
31500: GREATEREQUAL
31501: AND
31502: PUSH
31503: LD_VAR 0 5
31507: PPUSH
31508: LD_INT 3
31510: PPUSH
31511: CALL_OW 275
31515: PUSH
31516: LD_VAR 0 4
31520: PUSH
31521: LD_INT 3
31523: ARRAY
31524: GREATEREQUAL
31525: AND
31526: ST_TO_ADDR
// end ;
31527: LD_VAR 0 3
31531: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31532: LD_INT 0
31534: PPUSH
31535: PPUSH
31536: PPUSH
31537: PPUSH
// pom := GetBase ( building ) ;
31538: LD_ADDR_VAR 0 3
31542: PUSH
31543: LD_VAR 0 1
31547: PPUSH
31548: CALL_OW 274
31552: ST_TO_ADDR
// if not pom then
31553: LD_VAR 0 3
31557: NOT
31558: IFFALSE 31562
// exit ;
31560: GO 31732
// btype := GetBType ( building ) ;
31562: LD_ADDR_VAR 0 5
31566: PUSH
31567: LD_VAR 0 1
31571: PPUSH
31572: CALL_OW 266
31576: ST_TO_ADDR
// if btype = b_armoury then
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 4
31584: EQUAL
31585: IFFALSE 31595
// btype := b_barracks ;
31587: LD_ADDR_VAR 0 5
31591: PUSH
31592: LD_INT 5
31594: ST_TO_ADDR
// if btype = b_depot then
31595: LD_VAR 0 5
31599: PUSH
31600: LD_INT 0
31602: EQUAL
31603: IFFALSE 31613
// btype := b_warehouse ;
31605: LD_ADDR_VAR 0 5
31609: PUSH
31610: LD_INT 1
31612: ST_TO_ADDR
// if btype = b_workshop then
31613: LD_VAR 0 5
31617: PUSH
31618: LD_INT 2
31620: EQUAL
31621: IFFALSE 31631
// btype := b_factory ;
31623: LD_ADDR_VAR 0 5
31627: PUSH
31628: LD_INT 3
31630: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31631: LD_ADDR_VAR 0 4
31635: PUSH
31636: LD_VAR 0 5
31640: PPUSH
31641: LD_VAR 0 1
31645: PPUSH
31646: CALL_OW 248
31650: PPUSH
31651: CALL_OW 450
31655: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31656: LD_ADDR_VAR 0 2
31660: PUSH
31661: LD_VAR 0 3
31665: PPUSH
31666: LD_INT 1
31668: PPUSH
31669: CALL_OW 275
31673: PUSH
31674: LD_VAR 0 4
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: GREATEREQUAL
31683: PUSH
31684: LD_VAR 0 3
31688: PPUSH
31689: LD_INT 2
31691: PPUSH
31692: CALL_OW 275
31696: PUSH
31697: LD_VAR 0 4
31701: PUSH
31702: LD_INT 2
31704: ARRAY
31705: GREATEREQUAL
31706: AND
31707: PUSH
31708: LD_VAR 0 3
31712: PPUSH
31713: LD_INT 3
31715: PPUSH
31716: CALL_OW 275
31720: PUSH
31721: LD_VAR 0 4
31725: PUSH
31726: LD_INT 3
31728: ARRAY
31729: GREATEREQUAL
31730: AND
31731: ST_TO_ADDR
// end ;
31732: LD_VAR 0 2
31736: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31737: LD_INT 0
31739: PPUSH
31740: PPUSH
31741: PPUSH
// pom := GetBase ( building ) ;
31742: LD_ADDR_VAR 0 4
31746: PUSH
31747: LD_VAR 0 1
31751: PPUSH
31752: CALL_OW 274
31756: ST_TO_ADDR
// if not pom then
31757: LD_VAR 0 4
31761: NOT
31762: IFFALSE 31766
// exit ;
31764: GO 31867
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31766: LD_ADDR_VAR 0 5
31770: PUSH
31771: LD_VAR 0 2
31775: PPUSH
31776: LD_VAR 0 1
31780: PPUSH
31781: CALL_OW 248
31785: PPUSH
31786: CALL_OW 450
31790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31791: LD_ADDR_VAR 0 3
31795: PUSH
31796: LD_VAR 0 4
31800: PPUSH
31801: LD_INT 1
31803: PPUSH
31804: CALL_OW 275
31808: PUSH
31809: LD_VAR 0 5
31813: PUSH
31814: LD_INT 1
31816: ARRAY
31817: GREATEREQUAL
31818: PUSH
31819: LD_VAR 0 4
31823: PPUSH
31824: LD_INT 2
31826: PPUSH
31827: CALL_OW 275
31831: PUSH
31832: LD_VAR 0 5
31836: PUSH
31837: LD_INT 2
31839: ARRAY
31840: GREATEREQUAL
31841: AND
31842: PUSH
31843: LD_VAR 0 4
31847: PPUSH
31848: LD_INT 3
31850: PPUSH
31851: CALL_OW 275
31855: PUSH
31856: LD_VAR 0 5
31860: PUSH
31861: LD_INT 3
31863: ARRAY
31864: GREATEREQUAL
31865: AND
31866: ST_TO_ADDR
// end ;
31867: LD_VAR 0 3
31871: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31872: LD_INT 0
31874: PPUSH
31875: PPUSH
31876: PPUSH
31877: PPUSH
31878: PPUSH
31879: PPUSH
31880: PPUSH
31881: PPUSH
31882: PPUSH
31883: PPUSH
31884: PPUSH
// result := false ;
31885: LD_ADDR_VAR 0 8
31889: PUSH
31890: LD_INT 0
31892: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31893: LD_VAR 0 5
31897: NOT
31898: PUSH
31899: LD_VAR 0 1
31903: NOT
31904: OR
31905: PUSH
31906: LD_VAR 0 2
31910: NOT
31911: OR
31912: PUSH
31913: LD_VAR 0 3
31917: NOT
31918: OR
31919: IFFALSE 31923
// exit ;
31921: GO 32737
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31923: LD_ADDR_VAR 0 14
31927: PUSH
31928: LD_VAR 0 1
31932: PPUSH
31933: LD_VAR 0 2
31937: PPUSH
31938: LD_VAR 0 3
31942: PPUSH
31943: LD_VAR 0 4
31947: PPUSH
31948: LD_VAR 0 5
31952: PUSH
31953: LD_INT 1
31955: ARRAY
31956: PPUSH
31957: CALL_OW 248
31961: PPUSH
31962: LD_INT 0
31964: PPUSH
31965: CALL 33970 0 6
31969: ST_TO_ADDR
// if not hexes then
31970: LD_VAR 0 14
31974: NOT
31975: IFFALSE 31979
// exit ;
31977: GO 32737
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31979: LD_ADDR_VAR 0 17
31983: PUSH
31984: LD_VAR 0 5
31988: PPUSH
31989: LD_INT 22
31991: PUSH
31992: LD_VAR 0 13
31996: PPUSH
31997: CALL_OW 255
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 2
32008: PUSH
32009: LD_INT 30
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 30
32021: PUSH
32022: LD_INT 1
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PPUSH
32038: CALL_OW 72
32042: ST_TO_ADDR
// for i = 1 to hexes do
32043: LD_ADDR_VAR 0 9
32047: PUSH
32048: DOUBLE
32049: LD_INT 1
32051: DEC
32052: ST_TO_ADDR
32053: LD_VAR 0 14
32057: PUSH
32058: FOR_TO
32059: IFFALSE 32735
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32061: LD_ADDR_VAR 0 13
32065: PUSH
32066: LD_VAR 0 14
32070: PUSH
32071: LD_VAR 0 9
32075: ARRAY
32076: PUSH
32077: LD_INT 1
32079: ARRAY
32080: PPUSH
32081: LD_VAR 0 14
32085: PUSH
32086: LD_VAR 0 9
32090: ARRAY
32091: PUSH
32092: LD_INT 2
32094: ARRAY
32095: PPUSH
32096: CALL_OW 428
32100: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32101: LD_VAR 0 14
32105: PUSH
32106: LD_VAR 0 9
32110: ARRAY
32111: PUSH
32112: LD_INT 1
32114: ARRAY
32115: PPUSH
32116: LD_VAR 0 14
32120: PUSH
32121: LD_VAR 0 9
32125: ARRAY
32126: PUSH
32127: LD_INT 2
32129: ARRAY
32130: PPUSH
32131: CALL_OW 351
32135: PUSH
32136: LD_VAR 0 14
32140: PUSH
32141: LD_VAR 0 9
32145: ARRAY
32146: PUSH
32147: LD_INT 1
32149: ARRAY
32150: PPUSH
32151: LD_VAR 0 14
32155: PUSH
32156: LD_VAR 0 9
32160: ARRAY
32161: PUSH
32162: LD_INT 2
32164: ARRAY
32165: PPUSH
32166: CALL_OW 488
32170: NOT
32171: OR
32172: PUSH
32173: LD_VAR 0 13
32177: PPUSH
32178: CALL_OW 247
32182: PUSH
32183: LD_INT 3
32185: EQUAL
32186: OR
32187: IFFALSE 32193
// exit ;
32189: POP
32190: POP
32191: GO 32737
// if not tmp then
32193: LD_VAR 0 13
32197: NOT
32198: IFFALSE 32202
// continue ;
32200: GO 32058
// result := true ;
32202: LD_ADDR_VAR 0 8
32206: PUSH
32207: LD_INT 1
32209: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32210: LD_VAR 0 6
32214: PUSH
32215: LD_VAR 0 13
32219: PPUSH
32220: CALL_OW 247
32224: PUSH
32225: LD_INT 2
32227: EQUAL
32228: AND
32229: PUSH
32230: LD_VAR 0 13
32234: PPUSH
32235: CALL_OW 263
32239: PUSH
32240: LD_INT 1
32242: EQUAL
32243: AND
32244: IFFALSE 32408
// begin if IsDrivenBy ( tmp ) then
32246: LD_VAR 0 13
32250: PPUSH
32251: CALL_OW 311
32255: IFFALSE 32259
// continue ;
32257: GO 32058
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32259: LD_VAR 0 6
32263: PPUSH
32264: LD_INT 3
32266: PUSH
32267: LD_INT 60
32269: PUSH
32270: EMPTY
32271: LIST
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: LD_INT 55
32282: PUSH
32283: EMPTY
32284: LIST
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PPUSH
32294: CALL_OW 72
32298: IFFALSE 32406
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32300: LD_ADDR_VAR 0 18
32304: PUSH
32305: LD_VAR 0 6
32309: PPUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 60
32315: PUSH
32316: EMPTY
32317: LIST
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: LD_INT 55
32328: PUSH
32329: EMPTY
32330: LIST
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PPUSH
32340: CALL_OW 72
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: ST_TO_ADDR
// if IsInUnit ( driver ) then
32349: LD_VAR 0 18
32353: PPUSH
32354: CALL_OW 310
32358: IFFALSE 32369
// ComExit ( driver ) ;
32360: LD_VAR 0 18
32364: PPUSH
32365: CALL 57658 0 1
// AddComEnterUnit ( driver , tmp ) ;
32369: LD_VAR 0 18
32373: PPUSH
32374: LD_VAR 0 13
32378: PPUSH
32379: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32383: LD_VAR 0 18
32387: PPUSH
32388: LD_VAR 0 7
32392: PPUSH
32393: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32397: LD_VAR 0 18
32401: PPUSH
32402: CALL_OW 181
// end ; continue ;
32406: GO 32058
// end ; if not cleaners or not tmp in cleaners then
32408: LD_VAR 0 6
32412: NOT
32413: PUSH
32414: LD_VAR 0 13
32418: PUSH
32419: LD_VAR 0 6
32423: IN
32424: NOT
32425: OR
32426: IFFALSE 32733
// begin if dep then
32428: LD_VAR 0 17
32432: IFFALSE 32568
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32434: LD_ADDR_VAR 0 16
32438: PUSH
32439: LD_VAR 0 17
32443: PUSH
32444: LD_INT 1
32446: ARRAY
32447: PPUSH
32448: CALL_OW 250
32452: PPUSH
32453: LD_VAR 0 17
32457: PUSH
32458: LD_INT 1
32460: ARRAY
32461: PPUSH
32462: CALL_OW 254
32466: PPUSH
32467: LD_INT 5
32469: PPUSH
32470: CALL_OW 272
32474: PUSH
32475: LD_VAR 0 17
32479: PUSH
32480: LD_INT 1
32482: ARRAY
32483: PPUSH
32484: CALL_OW 251
32488: PPUSH
32489: LD_VAR 0 17
32493: PUSH
32494: LD_INT 1
32496: ARRAY
32497: PPUSH
32498: CALL_OW 254
32502: PPUSH
32503: LD_INT 5
32505: PPUSH
32506: CALL_OW 273
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32515: LD_VAR 0 16
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PPUSH
32524: LD_VAR 0 16
32528: PUSH
32529: LD_INT 2
32531: ARRAY
32532: PPUSH
32533: CALL_OW 488
32537: IFFALSE 32568
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32539: LD_VAR 0 13
32543: PPUSH
32544: LD_VAR 0 16
32548: PUSH
32549: LD_INT 1
32551: ARRAY
32552: PPUSH
32553: LD_VAR 0 16
32557: PUSH
32558: LD_INT 2
32560: ARRAY
32561: PPUSH
32562: CALL_OW 111
// continue ;
32566: GO 32058
// end ; end ; r := GetDir ( tmp ) ;
32568: LD_ADDR_VAR 0 15
32572: PUSH
32573: LD_VAR 0 13
32577: PPUSH
32578: CALL_OW 254
32582: ST_TO_ADDR
// if r = 5 then
32583: LD_VAR 0 15
32587: PUSH
32588: LD_INT 5
32590: EQUAL
32591: IFFALSE 32601
// r := 0 ;
32593: LD_ADDR_VAR 0 15
32597: PUSH
32598: LD_INT 0
32600: ST_TO_ADDR
// for j = r to 5 do
32601: LD_ADDR_VAR 0 10
32605: PUSH
32606: DOUBLE
32607: LD_VAR 0 15
32611: DEC
32612: ST_TO_ADDR
32613: LD_INT 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32731
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32619: LD_ADDR_VAR 0 11
32623: PUSH
32624: LD_VAR 0 13
32628: PPUSH
32629: CALL_OW 250
32633: PPUSH
32634: LD_VAR 0 10
32638: PPUSH
32639: LD_INT 2
32641: PPUSH
32642: CALL_OW 272
32646: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32647: LD_ADDR_VAR 0 12
32651: PUSH
32652: LD_VAR 0 13
32656: PPUSH
32657: CALL_OW 251
32661: PPUSH
32662: LD_VAR 0 10
32666: PPUSH
32667: LD_INT 2
32669: PPUSH
32670: CALL_OW 273
32674: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32675: LD_VAR 0 11
32679: PPUSH
32680: LD_VAR 0 12
32684: PPUSH
32685: CALL_OW 488
32689: PUSH
32690: LD_VAR 0 11
32694: PPUSH
32695: LD_VAR 0 12
32699: PPUSH
32700: CALL_OW 428
32704: NOT
32705: AND
32706: IFFALSE 32729
// begin ComMoveXY ( tmp , _x , _y ) ;
32708: LD_VAR 0 13
32712: PPUSH
32713: LD_VAR 0 11
32717: PPUSH
32718: LD_VAR 0 12
32722: PPUSH
32723: CALL_OW 111
// break ;
32727: GO 32731
// end ; end ;
32729: GO 32616
32731: POP
32732: POP
// end ; end ;
32733: GO 32058
32735: POP
32736: POP
// end ;
32737: LD_VAR 0 8
32741: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32742: LD_INT 0
32744: PPUSH
// result := true ;
32745: LD_ADDR_VAR 0 3
32749: PUSH
32750: LD_INT 1
32752: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32753: LD_VAR 0 2
32757: PUSH
32758: LD_INT 24
32760: DOUBLE
32761: EQUAL
32762: IFTRUE 32772
32764: LD_INT 33
32766: DOUBLE
32767: EQUAL
32768: IFTRUE 32772
32770: GO 32797
32772: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32773: LD_ADDR_VAR 0 3
32777: PUSH
32778: LD_INT 32
32780: PPUSH
32781: LD_VAR 0 1
32785: PPUSH
32786: CALL_OW 321
32790: PUSH
32791: LD_INT 2
32793: EQUAL
32794: ST_TO_ADDR
32795: GO 33113
32797: LD_INT 20
32799: DOUBLE
32800: EQUAL
32801: IFTRUE 32805
32803: GO 32830
32805: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32806: LD_ADDR_VAR 0 3
32810: PUSH
32811: LD_INT 6
32813: PPUSH
32814: LD_VAR 0 1
32818: PPUSH
32819: CALL_OW 321
32823: PUSH
32824: LD_INT 2
32826: EQUAL
32827: ST_TO_ADDR
32828: GO 33113
32830: LD_INT 22
32832: DOUBLE
32833: EQUAL
32834: IFTRUE 32844
32836: LD_INT 36
32838: DOUBLE
32839: EQUAL
32840: IFTRUE 32844
32842: GO 32869
32844: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32845: LD_ADDR_VAR 0 3
32849: PUSH
32850: LD_INT 15
32852: PPUSH
32853: LD_VAR 0 1
32857: PPUSH
32858: CALL_OW 321
32862: PUSH
32863: LD_INT 2
32865: EQUAL
32866: ST_TO_ADDR
32867: GO 33113
32869: LD_INT 30
32871: DOUBLE
32872: EQUAL
32873: IFTRUE 32877
32875: GO 32902
32877: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32878: LD_ADDR_VAR 0 3
32882: PUSH
32883: LD_INT 20
32885: PPUSH
32886: LD_VAR 0 1
32890: PPUSH
32891: CALL_OW 321
32895: PUSH
32896: LD_INT 2
32898: EQUAL
32899: ST_TO_ADDR
32900: GO 33113
32902: LD_INT 28
32904: DOUBLE
32905: EQUAL
32906: IFTRUE 32916
32908: LD_INT 21
32910: DOUBLE
32911: EQUAL
32912: IFTRUE 32916
32914: GO 32941
32916: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32917: LD_ADDR_VAR 0 3
32921: PUSH
32922: LD_INT 21
32924: PPUSH
32925: LD_VAR 0 1
32929: PPUSH
32930: CALL_OW 321
32934: PUSH
32935: LD_INT 2
32937: EQUAL
32938: ST_TO_ADDR
32939: GO 33113
32941: LD_INT 16
32943: DOUBLE
32944: EQUAL
32945: IFTRUE 32949
32947: GO 32974
32949: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32950: LD_ADDR_VAR 0 3
32954: PUSH
32955: LD_INT 84
32957: PPUSH
32958: LD_VAR 0 1
32962: PPUSH
32963: CALL_OW 321
32967: PUSH
32968: LD_INT 2
32970: EQUAL
32971: ST_TO_ADDR
32972: GO 33113
32974: LD_INT 19
32976: DOUBLE
32977: EQUAL
32978: IFTRUE 32988
32980: LD_INT 23
32982: DOUBLE
32983: EQUAL
32984: IFTRUE 32988
32986: GO 33013
32988: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32989: LD_ADDR_VAR 0 3
32993: PUSH
32994: LD_INT 83
32996: PPUSH
32997: LD_VAR 0 1
33001: PPUSH
33002: CALL_OW 321
33006: PUSH
33007: LD_INT 2
33009: EQUAL
33010: ST_TO_ADDR
33011: GO 33113
33013: LD_INT 17
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33046
33021: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33022: LD_ADDR_VAR 0 3
33026: PUSH
33027: LD_INT 39
33029: PPUSH
33030: LD_VAR 0 1
33034: PPUSH
33035: CALL_OW 321
33039: PUSH
33040: LD_INT 2
33042: EQUAL
33043: ST_TO_ADDR
33044: GO 33113
33046: LD_INT 18
33048: DOUBLE
33049: EQUAL
33050: IFTRUE 33054
33052: GO 33079
33054: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33055: LD_ADDR_VAR 0 3
33059: PUSH
33060: LD_INT 40
33062: PPUSH
33063: LD_VAR 0 1
33067: PPUSH
33068: CALL_OW 321
33072: PUSH
33073: LD_INT 2
33075: EQUAL
33076: ST_TO_ADDR
33077: GO 33113
33079: LD_INT 27
33081: DOUBLE
33082: EQUAL
33083: IFTRUE 33087
33085: GO 33112
33087: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33088: LD_ADDR_VAR 0 3
33092: PUSH
33093: LD_INT 35
33095: PPUSH
33096: LD_VAR 0 1
33100: PPUSH
33101: CALL_OW 321
33105: PUSH
33106: LD_INT 2
33108: EQUAL
33109: ST_TO_ADDR
33110: GO 33113
33112: POP
// end ;
33113: LD_VAR 0 3
33117: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33118: LD_INT 0
33120: PPUSH
33121: PPUSH
33122: PPUSH
33123: PPUSH
33124: PPUSH
33125: PPUSH
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
33130: PPUSH
// result := false ;
33131: LD_ADDR_VAR 0 6
33135: PUSH
33136: LD_INT 0
33138: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33139: LD_VAR 0 1
33143: NOT
33144: PUSH
33145: LD_VAR 0 1
33149: PPUSH
33150: CALL_OW 266
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: IN
33165: NOT
33166: OR
33167: PUSH
33168: LD_VAR 0 2
33172: NOT
33173: OR
33174: PUSH
33175: LD_VAR 0 5
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 1
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: LD_INT 4
33194: PUSH
33195: LD_INT 5
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: IN
33206: NOT
33207: OR
33208: PUSH
33209: LD_VAR 0 3
33213: PPUSH
33214: LD_VAR 0 4
33218: PPUSH
33219: CALL_OW 488
33223: NOT
33224: OR
33225: IFFALSE 33229
// exit ;
33227: GO 33965
// side := GetSide ( depot ) ;
33229: LD_ADDR_VAR 0 9
33233: PUSH
33234: LD_VAR 0 1
33238: PPUSH
33239: CALL_OW 255
33243: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33244: LD_VAR 0 9
33248: PPUSH
33249: LD_VAR 0 2
33253: PPUSH
33254: CALL 32742 0 2
33258: NOT
33259: IFFALSE 33263
// exit ;
33261: GO 33965
// pom := GetBase ( depot ) ;
33263: LD_ADDR_VAR 0 10
33267: PUSH
33268: LD_VAR 0 1
33272: PPUSH
33273: CALL_OW 274
33277: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33278: LD_ADDR_VAR 0 11
33282: PUSH
33283: LD_VAR 0 2
33287: PPUSH
33288: LD_VAR 0 1
33292: PPUSH
33293: CALL_OW 248
33297: PPUSH
33298: CALL_OW 450
33302: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33303: LD_VAR 0 10
33307: PPUSH
33308: LD_INT 1
33310: PPUSH
33311: CALL_OW 275
33315: PUSH
33316: LD_VAR 0 11
33320: PUSH
33321: LD_INT 1
33323: ARRAY
33324: GREATEREQUAL
33325: PUSH
33326: LD_VAR 0 10
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: CALL_OW 275
33338: PUSH
33339: LD_VAR 0 11
33343: PUSH
33344: LD_INT 2
33346: ARRAY
33347: GREATEREQUAL
33348: AND
33349: PUSH
33350: LD_VAR 0 10
33354: PPUSH
33355: LD_INT 3
33357: PPUSH
33358: CALL_OW 275
33362: PUSH
33363: LD_VAR 0 11
33367: PUSH
33368: LD_INT 3
33370: ARRAY
33371: GREATEREQUAL
33372: AND
33373: NOT
33374: IFFALSE 33378
// exit ;
33376: GO 33965
// if GetBType ( depot ) = b_depot then
33378: LD_VAR 0 1
33382: PPUSH
33383: CALL_OW 266
33387: PUSH
33388: LD_INT 0
33390: EQUAL
33391: IFFALSE 33403
// dist := 28 else
33393: LD_ADDR_VAR 0 14
33397: PUSH
33398: LD_INT 28
33400: ST_TO_ADDR
33401: GO 33411
// dist := 36 ;
33403: LD_ADDR_VAR 0 14
33407: PUSH
33408: LD_INT 36
33410: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33411: LD_VAR 0 1
33415: PPUSH
33416: LD_VAR 0 3
33420: PPUSH
33421: LD_VAR 0 4
33425: PPUSH
33426: CALL_OW 297
33430: PUSH
33431: LD_VAR 0 14
33435: GREATER
33436: IFFALSE 33440
// exit ;
33438: GO 33965
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33440: LD_ADDR_VAR 0 12
33444: PUSH
33445: LD_VAR 0 2
33449: PPUSH
33450: LD_VAR 0 3
33454: PPUSH
33455: LD_VAR 0 4
33459: PPUSH
33460: LD_VAR 0 5
33464: PPUSH
33465: LD_VAR 0 1
33469: PPUSH
33470: CALL_OW 248
33474: PPUSH
33475: LD_INT 0
33477: PPUSH
33478: CALL 33970 0 6
33482: ST_TO_ADDR
// if not hexes then
33483: LD_VAR 0 12
33487: NOT
33488: IFFALSE 33492
// exit ;
33490: GO 33965
// hex := GetHexInfo ( x , y ) ;
33492: LD_ADDR_VAR 0 15
33496: PUSH
33497: LD_VAR 0 3
33501: PPUSH
33502: LD_VAR 0 4
33506: PPUSH
33507: CALL_OW 546
33511: ST_TO_ADDR
// if hex [ 1 ] then
33512: LD_VAR 0 15
33516: PUSH
33517: LD_INT 1
33519: ARRAY
33520: IFFALSE 33524
// exit ;
33522: GO 33965
// height := hex [ 2 ] ;
33524: LD_ADDR_VAR 0 13
33528: PUSH
33529: LD_VAR 0 15
33533: PUSH
33534: LD_INT 2
33536: ARRAY
33537: ST_TO_ADDR
// for i = 1 to hexes do
33538: LD_ADDR_VAR 0 7
33542: PUSH
33543: DOUBLE
33544: LD_INT 1
33546: DEC
33547: ST_TO_ADDR
33548: LD_VAR 0 12
33552: PUSH
33553: FOR_TO
33554: IFFALSE 33884
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33556: LD_VAR 0 12
33560: PUSH
33561: LD_VAR 0 7
33565: ARRAY
33566: PUSH
33567: LD_INT 1
33569: ARRAY
33570: PPUSH
33571: LD_VAR 0 12
33575: PUSH
33576: LD_VAR 0 7
33580: ARRAY
33581: PUSH
33582: LD_INT 2
33584: ARRAY
33585: PPUSH
33586: CALL_OW 488
33590: NOT
33591: PUSH
33592: LD_VAR 0 12
33596: PUSH
33597: LD_VAR 0 7
33601: ARRAY
33602: PUSH
33603: LD_INT 1
33605: ARRAY
33606: PPUSH
33607: LD_VAR 0 12
33611: PUSH
33612: LD_VAR 0 7
33616: ARRAY
33617: PUSH
33618: LD_INT 2
33620: ARRAY
33621: PPUSH
33622: CALL_OW 428
33626: PUSH
33627: LD_INT 0
33629: GREATER
33630: OR
33631: PUSH
33632: LD_VAR 0 12
33636: PUSH
33637: LD_VAR 0 7
33641: ARRAY
33642: PUSH
33643: LD_INT 1
33645: ARRAY
33646: PPUSH
33647: LD_VAR 0 12
33651: PUSH
33652: LD_VAR 0 7
33656: ARRAY
33657: PUSH
33658: LD_INT 2
33660: ARRAY
33661: PPUSH
33662: CALL_OW 351
33666: OR
33667: IFFALSE 33673
// exit ;
33669: POP
33670: POP
33671: GO 33965
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33673: LD_ADDR_VAR 0 8
33677: PUSH
33678: LD_VAR 0 12
33682: PUSH
33683: LD_VAR 0 7
33687: ARRAY
33688: PUSH
33689: LD_INT 1
33691: ARRAY
33692: PPUSH
33693: LD_VAR 0 12
33697: PUSH
33698: LD_VAR 0 7
33702: ARRAY
33703: PUSH
33704: LD_INT 2
33706: ARRAY
33707: PPUSH
33708: CALL_OW 546
33712: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33713: LD_VAR 0 8
33717: PUSH
33718: LD_INT 1
33720: ARRAY
33721: PUSH
33722: LD_VAR 0 8
33726: PUSH
33727: LD_INT 2
33729: ARRAY
33730: PUSH
33731: LD_VAR 0 13
33735: PUSH
33736: LD_INT 2
33738: PLUS
33739: GREATER
33740: OR
33741: PUSH
33742: LD_VAR 0 8
33746: PUSH
33747: LD_INT 2
33749: ARRAY
33750: PUSH
33751: LD_VAR 0 13
33755: PUSH
33756: LD_INT 2
33758: MINUS
33759: LESS
33760: OR
33761: PUSH
33762: LD_VAR 0 8
33766: PUSH
33767: LD_INT 3
33769: ARRAY
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 8
33776: PUSH
33777: LD_INT 9
33779: PUSH
33780: LD_INT 10
33782: PUSH
33783: LD_INT 11
33785: PUSH
33786: LD_INT 12
33788: PUSH
33789: LD_INT 13
33791: PUSH
33792: LD_INT 16
33794: PUSH
33795: LD_INT 17
33797: PUSH
33798: LD_INT 18
33800: PUSH
33801: LD_INT 19
33803: PUSH
33804: LD_INT 20
33806: PUSH
33807: LD_INT 21
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: IN
33825: NOT
33826: OR
33827: PUSH
33828: LD_VAR 0 8
33832: PUSH
33833: LD_INT 5
33835: ARRAY
33836: NOT
33837: OR
33838: PUSH
33839: LD_VAR 0 8
33843: PUSH
33844: LD_INT 6
33846: ARRAY
33847: PUSH
33848: LD_INT 1
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: LD_INT 7
33856: PUSH
33857: LD_INT 9
33859: PUSH
33860: LD_INT 10
33862: PUSH
33863: LD_INT 11
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: IN
33874: NOT
33875: OR
33876: IFFALSE 33882
// exit ;
33878: POP
33879: POP
33880: GO 33965
// end ;
33882: GO 33553
33884: POP
33885: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33886: LD_VAR 0 9
33890: PPUSH
33891: LD_VAR 0 3
33895: PPUSH
33896: LD_VAR 0 4
33900: PPUSH
33901: LD_INT 20
33903: PPUSH
33904: CALL 25917 0 4
33908: PUSH
33909: LD_INT 4
33911: ARRAY
33912: IFFALSE 33916
// exit ;
33914: GO 33965
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33916: LD_VAR 0 2
33920: PUSH
33921: LD_INT 29
33923: PUSH
33924: LD_INT 30
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: IN
33931: PUSH
33932: LD_VAR 0 3
33936: PPUSH
33937: LD_VAR 0 4
33941: PPUSH
33942: LD_VAR 0 9
33946: PPUSH
33947: CALL_OW 440
33951: NOT
33952: AND
33953: IFFALSE 33957
// exit ;
33955: GO 33965
// result := true ;
33957: LD_ADDR_VAR 0 6
33961: PUSH
33962: LD_INT 1
33964: ST_TO_ADDR
// end ;
33965: LD_VAR 0 6
33969: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33970: LD_INT 0
33972: PPUSH
33973: PPUSH
33974: PPUSH
33975: PPUSH
33976: PPUSH
33977: PPUSH
33978: PPUSH
33979: PPUSH
33980: PPUSH
33981: PPUSH
33982: PPUSH
33983: PPUSH
33984: PPUSH
33985: PPUSH
33986: PPUSH
33987: PPUSH
33988: PPUSH
33989: PPUSH
33990: PPUSH
33991: PPUSH
33992: PPUSH
33993: PPUSH
33994: PPUSH
33995: PPUSH
33996: PPUSH
33997: PPUSH
33998: PPUSH
33999: PPUSH
34000: PPUSH
34001: PPUSH
34002: PPUSH
34003: PPUSH
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
34015: PPUSH
34016: PPUSH
34017: PPUSH
34018: PPUSH
34019: PPUSH
34020: PPUSH
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
34025: PPUSH
34026: PPUSH
34027: PPUSH
34028: PPUSH
34029: PPUSH
// result = [ ] ;
34030: LD_ADDR_VAR 0 7
34034: PUSH
34035: EMPTY
34036: ST_TO_ADDR
// temp_list = [ ] ;
34037: LD_ADDR_VAR 0 9
34041: PUSH
34042: EMPTY
34043: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34044: LD_VAR 0 4
34048: PUSH
34049: LD_INT 0
34051: PUSH
34052: LD_INT 1
34054: PUSH
34055: LD_INT 2
34057: PUSH
34058: LD_INT 3
34060: PUSH
34061: LD_INT 4
34063: PUSH
34064: LD_INT 5
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: IN
34075: NOT
34076: PUSH
34077: LD_VAR 0 1
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: IN
34092: PUSH
34093: LD_VAR 0 5
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 2
34103: PUSH
34104: LD_INT 3
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: LIST
34111: IN
34112: NOT
34113: AND
34114: OR
34115: IFFALSE 34119
// exit ;
34117: GO 52510
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34119: LD_VAR 0 1
34123: PUSH
34124: LD_INT 6
34126: PUSH
34127: LD_INT 7
34129: PUSH
34130: LD_INT 8
34132: PUSH
34133: LD_INT 13
34135: PUSH
34136: LD_INT 12
34138: PUSH
34139: LD_INT 15
34141: PUSH
34142: LD_INT 11
34144: PUSH
34145: LD_INT 14
34147: PUSH
34148: LD_INT 10
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: IN
34162: IFFALSE 34172
// btype = b_lab ;
34164: LD_ADDR_VAR 0 1
34168: PUSH
34169: LD_INT 6
34171: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34172: LD_VAR 0 6
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 1
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: LIST
34190: IN
34191: NOT
34192: PUSH
34193: LD_VAR 0 1
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: LD_INT 1
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: LD_INT 3
34209: PUSH
34210: LD_INT 6
34212: PUSH
34213: LD_INT 36
34215: PUSH
34216: LD_INT 4
34218: PUSH
34219: LD_INT 5
34221: PUSH
34222: LD_INT 31
34224: PUSH
34225: LD_INT 32
34227: PUSH
34228: LD_INT 33
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: IN
34244: NOT
34245: PUSH
34246: LD_VAR 0 6
34250: PUSH
34251: LD_INT 1
34253: EQUAL
34254: AND
34255: OR
34256: PUSH
34257: LD_VAR 0 1
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: LD_INT 3
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: IN
34272: NOT
34273: PUSH
34274: LD_VAR 0 6
34278: PUSH
34279: LD_INT 2
34281: EQUAL
34282: AND
34283: OR
34284: IFFALSE 34294
// mode = 0 ;
34286: LD_ADDR_VAR 0 6
34290: PUSH
34291: LD_INT 0
34293: ST_TO_ADDR
// case mode of 0 :
34294: LD_VAR 0 6
34298: PUSH
34299: LD_INT 0
34301: DOUBLE
34302: EQUAL
34303: IFTRUE 34307
34305: GO 45760
34307: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34308: LD_ADDR_VAR 0 11
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: NEG
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 2
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 2
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 2
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: LD_INT 3
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 3
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34501: LD_ADDR_VAR 0 12
34505: PUSH
34506: LD_INT 0
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: LD_INT 1
34574: NEG
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 2
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 2
34624: NEG
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: NEG
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: NEG
34648: PUSH
34649: LD_INT 1
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34697: LD_ADDR_VAR 0 13
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 2
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 2
34832: NEG
34833: PUSH
34834: LD_INT 2
34836: NEG
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 2
34844: NEG
34845: PUSH
34846: LD_INT 3
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 3
34856: NEG
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 3
34868: NEG
34869: PUSH
34870: LD_INT 3
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34896: LD_ADDR_VAR 0 14
34900: PUSH
34901: LD_INT 0
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 1
34965: NEG
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 0
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: LD_INT 2
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 2
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 1
35031: NEG
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 3
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 0
35054: PUSH
35055: LD_INT 3
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: LD_INT 2
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35092: LD_ADDR_VAR 0 15
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 1
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 0
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: LD_INT 1
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: LD_INT 0
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: NEG
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: LD_INT 0
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 2
35215: NEG
35216: PUSH
35217: LD_INT 0
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: NEG
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 2
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 3
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 3
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35285: LD_ADDR_VAR 0 16
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 2
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: LD_INT 2
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 2
35408: NEG
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: NEG
35421: PUSH
35422: LD_INT 2
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: LD_INT 2
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 3
35442: PUSH
35443: LD_INT 3
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 2
35452: PUSH
35453: LD_INT 3
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35478: LD_ADDR_VAR 0 17
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 2
35563: NEG
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: NEG
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 2
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 1
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: LD_INT 1
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 2
35677: NEG
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35708: LD_ADDR_VAR 0 18
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 1
35728: NEG
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 1
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 1
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: NEG
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 2
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 2
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 2
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 2
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 0
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: LD_INT 2
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35938: LD_ADDR_VAR 0 19
35942: PUSH
35943: LD_INT 0
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 0
35955: PUSH
35956: LD_INT 1
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: LD_INT 2
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 2
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: LD_INT 2
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: LD_INT 2
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: NEG
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 2
36125: NEG
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 2
36137: NEG
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36168: LD_ADDR_VAR 0 20
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: LD_INT 1
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: NEG
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 2
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 0
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 2
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 1
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 2
36344: NEG
36345: PUSH
36346: LD_INT 0
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 2
36355: NEG
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36398: LD_ADDR_VAR 0 21
36402: PUSH
36403: LD_INT 0
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 1
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 1
36456: NEG
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 1
36479: NEG
36480: PUSH
36481: LD_INT 2
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 2
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 2
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 1
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: LD_INT 2
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: LD_INT 2
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: LD_INT 2
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: LD_INT 0
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 2
36585: NEG
36586: PUSH
36587: LD_INT 1
36589: NEG
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: LD_INT 2
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36628: LD_ADDR_VAR 0 22
36632: PUSH
36633: LD_INT 0
36635: PUSH
36636: LD_INT 0
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: LD_INT 1
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: NEG
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 1
36697: NEG
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: NEG
36710: PUSH
36711: LD_INT 2
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: LD_INT 1
36735: NEG
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 2
36753: PUSH
36754: LD_INT 1
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: NEG
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: NEG
36816: PUSH
36817: LD_INT 1
36819: NEG
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 2
36827: NEG
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36858: LD_ADDR_VAR 0 23
36862: PUSH
36863: LD_INT 0
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 1
36886: PUSH
36887: LD_INT 0
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 0
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 1
36931: NEG
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: NEG
36940: PUSH
36941: LD_INT 2
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 0
36951: PUSH
36952: LD_INT 2
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 2
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 2
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 1
37023: NEG
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 2
37034: NEG
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 2
37045: NEG
37046: PUSH
37047: LD_INT 1
37049: NEG
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 2
37057: NEG
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 2
37069: NEG
37070: PUSH
37071: LD_INT 3
37073: NEG
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 1
37081: NEG
37082: PUSH
37083: LD_INT 3
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37138: LD_ADDR_VAR 0 24
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: EMPTY
37161: LIST
37162: LIST
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 1
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: LD_INT 0
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: LD_INT 1
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 2
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 2
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 2
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 0
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: NEG
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: NEG
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 2
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 2
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: PUSH
37350: LD_INT 2
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 2
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 3
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37414: LD_ADDR_VAR 0 25
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 0
37507: PUSH
37508: LD_INT 2
37510: NEG
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 1
37518: PUSH
37519: LD_INT 1
37521: NEG
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 2
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 0
37569: PUSH
37570: LD_INT 2
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 1
37579: NEG
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: NEG
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 2
37601: NEG
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 2
37613: NEG
37614: PUSH
37615: LD_INT 2
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37688: LD_ADDR_VAR 0 26
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: NEG
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 2
37864: NEG
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 1
37879: NEG
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: PUSH
37900: LD_INT 3
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 1
37909: PUSH
37910: LD_INT 3
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: NEG
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37964: LD_ADDR_VAR 0 27
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 0
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 1
38022: NEG
38023: PUSH
38024: LD_INT 0
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: LD_INT 1
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: LD_INT 2
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 2
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 1
38068: PUSH
38069: LD_INT 1
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: PUSH
38100: LD_INT 2
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: LD_INT 2
38167: NEG
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: LD_INT 2
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 2
38186: NEG
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 3
38197: NEG
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 3
38209: NEG
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38244: LD_ADDR_VAR 0 28
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 0
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 0
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 1
38302: NEG
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: NEG
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 2
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 2
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 2
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 3
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 3
38491: NEG
38492: PUSH
38493: LD_INT 2
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38526: LD_ADDR_VAR 0 29
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: LD_INT 2
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 1
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 2
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 2
38651: PUSH
38652: LD_INT 1
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 2
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: LD_INT 3
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 2
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 3
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: PUSH
38750: LD_INT 3
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: NEG
38771: PUSH
38772: LD_INT 2
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38805: LD_ADDR_VAR 0 30
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 0
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: NEG
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: LD_INT 3
38998: NEG
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 1
39006: PUSH
39007: LD_INT 2
39009: NEG
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 3
39017: PUSH
39018: LD_INT 2
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 2
39027: PUSH
39028: LD_INT 3
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 3
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39083: LD_ADDR_VAR 0 31
39087: PUSH
39088: LD_INT 0
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 1
39152: NEG
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 2
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 2
39187: PUSH
39188: LD_INT 0
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 2
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 2
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 2
39248: NEG
39249: PUSH
39250: LD_INT 1
39252: NEG
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 2
39260: NEG
39261: PUSH
39262: LD_INT 2
39264: NEG
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 3
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 3
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: PUSH
39306: LD_INT 3
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 3
39326: NEG
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39361: LD_ADDR_VAR 0 32
39365: PUSH
39366: LD_INT 0
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 1
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: LD_INT 1
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 0
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: LD_INT 2
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 1
39465: PUSH
39466: LD_INT 1
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 2
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: LD_INT 2
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: LD_INT 2
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: LD_INT 2
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 2
39527: NEG
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 2
39538: NEG
39539: PUSH
39540: LD_INT 1
39542: NEG
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: PUSH
39563: LD_INT 2
39565: NEG
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 3
39573: PUSH
39574: LD_INT 2
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 2
39583: PUSH
39584: LD_INT 3
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 2
39593: NEG
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 3
39604: NEG
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39639: LD_ADDR_VAR 0 33
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: LD_INT 1
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 1
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 1
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: LD_INT 2
39724: NEG
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: LD_INT 2
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: LD_INT 0
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: LD_INT 1
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: NEG
39830: PUSH
39831: LD_INT 3
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: LD_INT 2
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39918: LD_ADDR_VAR 0 34
39922: PUSH
39923: LD_INT 0
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: LD_INT 1
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 1
39946: PUSH
39947: LD_INT 0
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 1
39956: PUSH
39957: LD_INT 1
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 1
39976: NEG
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 1
39987: NEG
39988: PUSH
39989: LD_INT 1
39991: NEG
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: LD_INT 2
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: LD_INT 2
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 1
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 2
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 1
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 2
40074: NEG
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 2
40097: NEG
40098: PUSH
40099: LD_INT 2
40101: NEG
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 1
40109: NEG
40110: PUSH
40111: LD_INT 3
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 3
40132: PUSH
40133: LD_INT 2
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 2
40142: PUSH
40143: LD_INT 3
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40198: LD_ADDR_VAR 0 35
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: LD_INT 1
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 2
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 1
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40310: LD_ADDR_VAR 0 36
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: LD_INT 1
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 0
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 0
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 1
40391: NEG
40392: PUSH
40393: LD_INT 2
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: LD_INT 2
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40422: LD_ADDR_VAR 0 37
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: LD_INT 0
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 1
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 0
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 1
40480: NEG
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40534: LD_ADDR_VAR 0 38
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: LD_INT 1
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 1
40562: PUSH
40563: LD_INT 0
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 0
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 1
40592: NEG
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: LD_INT 1
40607: NEG
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 2
40615: PUSH
40616: LD_INT 1
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 2
40625: NEG
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40646: LD_ADDR_VAR 0 39
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 1
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 2
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 2
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40758: LD_ADDR_VAR 0 40
40762: PUSH
40763: LD_INT 0
40765: PUSH
40766: LD_INT 0
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: LD_INT 1
40778: NEG
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 1
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: LD_INT 1
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 0
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 1
40816: NEG
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: LD_INT 1
40831: NEG
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 1
40850: NEG
40851: PUSH
40852: LD_INT 1
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40870: LD_ADDR_VAR 0 41
40874: PUSH
40875: LD_INT 0
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: LD_INT 1
40890: NEG
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: LD_INT 1
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 0
40918: PUSH
40919: LD_INT 1
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 1
40928: NEG
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 1
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 2
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 1
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 2
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 2
40994: PUSH
40995: LD_INT 2
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: LD_INT 1
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: NEG
41037: PUSH
41038: LD_INT 1
41040: NEG
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 2
41048: NEG
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 2
41060: NEG
41061: PUSH
41062: LD_INT 3
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 3
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 3
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 3
41113: PUSH
41114: LD_INT 3
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 3
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: LD_INT 1
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 3
41155: NEG
41156: PUSH
41157: LD_INT 1
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: LIST
41193: LIST
41194: LIST
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41220: LD_ADDR_VAR 0 42
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 0
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 0
41237: PUSH
41238: LD_INT 1
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 1
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: NEG
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 1
41289: NEG
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 1
41301: NEG
41302: PUSH
41303: LD_INT 2
41305: NEG
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 2
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 1
41355: PUSH
41356: LD_INT 2
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: LD_INT 2
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 1
41375: NEG
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 2
41386: NEG
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: LD_INT 2
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: LD_INT 3
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 3
41456: PUSH
41457: LD_INT 2
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 3
41466: PUSH
41467: LD_INT 3
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 2
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: NEG
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 3
41517: NEG
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: LD_INT 3
41533: NEG
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41570: LD_ADDR_VAR 0 43
41574: PUSH
41575: LD_INT 0
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 0
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 1
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: LD_INT 1
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 1
41639: NEG
41640: PUSH
41641: LD_INT 1
41643: NEG
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 1
41651: NEG
41652: PUSH
41653: LD_INT 2
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 0
41663: PUSH
41664: LD_INT 2
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 1
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 2
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 2
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 0
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 1
41725: NEG
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 2
41736: NEG
41737: PUSH
41738: LD_INT 0
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 2
41747: NEG
41748: PUSH
41749: LD_INT 1
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 1
41759: NEG
41760: PUSH
41761: LD_INT 3
41763: NEG
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 1
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: PUSH
41805: LD_INT 0
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: LD_INT 1
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: LD_INT 3
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 0
41834: PUSH
41835: LD_INT 3
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: LD_INT 2
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 2
41855: NEG
41856: PUSH
41857: LD_INT 1
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 3
41866: NEG
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41918: LD_ADDR_VAR 0 44
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 1
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 0
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 1
41976: NEG
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 1
41991: NEG
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 1
41999: NEG
42000: PUSH
42001: LD_INT 2
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 1
42011: PUSH
42012: LD_INT 1
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 2
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 2
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: LD_INT 2
42042: PUSH
42043: LD_INT 2
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: LD_INT 2
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: NEG
42063: PUSH
42064: LD_INT 1
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: NEG
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: LD_INT 2
42084: NEG
42085: PUSH
42086: LD_INT 1
42088: NEG
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PUSH
42094: LD_INT 2
42096: NEG
42097: PUSH
42098: LD_INT 2
42100: NEG
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 2
42108: NEG
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: LD_INT 1
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 3
42131: PUSH
42132: LD_INT 0
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 1
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 3
42151: PUSH
42152: LD_INT 2
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: LD_INT 3
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 2
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: NEG
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 3
42203: NEG
42204: PUSH
42205: LD_INT 1
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42268: LD_ADDR_VAR 0 45
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: LD_INT 1
42288: NEG
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: LD_INT 0
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 1
42306: PUSH
42307: LD_INT 1
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 1
42326: NEG
42327: PUSH
42328: LD_INT 0
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: NEG
42338: PUSH
42339: LD_INT 1
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 0
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 2
42383: PUSH
42384: LD_INT 1
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 2
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: LD_INT 2
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: LD_INT 2
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: LD_INT 1
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: LD_INT 2
42434: NEG
42435: PUSH
42436: LD_INT 1
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: LD_INT 2
42446: NEG
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: EMPTY
42453: LIST
42454: LIST
42455: PUSH
42456: LD_INT 2
42458: NEG
42459: PUSH
42460: LD_INT 3
42462: NEG
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 1
42470: NEG
42471: PUSH
42472: LD_INT 3
42474: NEG
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 2
42496: NEG
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: LD_INT 2
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: PUSH
42515: LD_INT 3
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 2
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 0
42544: PUSH
42545: LD_INT 3
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 1
42554: NEG
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: NEG
42566: PUSH
42567: LD_INT 2
42569: NEG
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 3
42577: NEG
42578: PUSH
42579: LD_INT 3
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42618: LD_ADDR_VAR 0 46
42622: PUSH
42623: LD_INT 0
42625: PUSH
42626: LD_INT 0
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: LD_INT 1
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 1
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: LD_INT 1
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: LD_INT 1
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: LD_INT 0
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: LD_INT 1
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 1
42699: NEG
42700: PUSH
42701: LD_INT 2
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: LD_INT 2
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 1
42722: PUSH
42723: LD_INT 1
42725: NEG
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 2
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: LD_INT 2
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 2
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 1
42773: NEG
42774: PUSH
42775: LD_INT 1
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: LD_INT 0
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 2
42795: NEG
42796: PUSH
42797: LD_INT 1
42799: NEG
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: LD_INT 3
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 0
42819: PUSH
42820: LD_INT 3
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: PUSH
42831: LD_INT 2
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: LD_INT 1
42844: NEG
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 3
42852: PUSH
42853: LD_INT 0
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 3
42862: PUSH
42863: LD_INT 1
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 3
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 3
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 1
42892: NEG
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 1
42907: PUSH
42908: EMPTY
42909: LIST
42910: LIST
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: LD_INT 0
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: LD_INT 1
42929: NEG
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42966: LD_ADDR_VAR 0 47
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 1
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 0
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: LD_INT 0
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 1
43035: NEG
43036: PUSH
43037: LD_INT 1
43039: NEG
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 1
43047: NEG
43048: PUSH
43049: LD_INT 2
43051: NEG
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 0
43059: PUSH
43060: LD_INT 2
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: LD_INT 1
43073: NEG
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_INT 2
43081: NEG
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: LD_INT 2
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: LIST
43112: LIST
43113: LIST
43114: LIST
43115: LIST
43116: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43117: LD_ADDR_VAR 0 48
43121: PUSH
43122: LD_INT 0
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 0
43134: PUSH
43135: LD_INT 1
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: LD_INT 1
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 0
43165: PUSH
43166: LD_INT 1
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: LD_INT 0
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 1
43186: NEG
43187: PUSH
43188: LD_INT 1
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 1
43198: NEG
43199: PUSH
43200: LD_INT 2
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: LD_INT 2
43213: NEG
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: LD_INT 1
43224: NEG
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: PUSH
43233: LD_INT 0
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 1
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43264: LD_ADDR_VAR 0 49
43268: PUSH
43269: LD_INT 0
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 1
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 1
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 0
43312: PUSH
43313: LD_INT 1
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: NEG
43323: PUSH
43324: LD_INT 0
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 1
43337: NEG
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 1
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 0
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: LD_INT 2
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 1
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43408: LD_ADDR_VAR 0 50
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 1
43428: NEG
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 1
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: LD_INT 1
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 0
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: LD_INT 0
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: NEG
43478: PUSH
43479: LD_INT 1
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 2
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 1
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: LD_INT 2
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 1
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43552: LD_ADDR_VAR 0 51
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 1
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 1
43610: NEG
43611: PUSH
43612: LD_INT 0
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 1
43621: NEG
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 0
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: LD_INT 1
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 2
43664: NEG
43665: PUSH
43666: LD_INT 0
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 2
43675: NEG
43676: PUSH
43677: LD_INT 1
43679: NEG
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43699: LD_ADDR_VAR 0 52
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: PUSH
43728: LD_INT 0
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 1
43737: PUSH
43738: LD_INT 1
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 0
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: LD_INT 0
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 1
43768: NEG
43769: PUSH
43770: LD_INT 1
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 1
43780: NEG
43781: PUSH
43782: LD_INT 2
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: LD_INT 1
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 2
43803: NEG
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 2
43814: NEG
43815: PUSH
43816: LD_INT 1
43818: NEG
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: LD_INT 2
43830: NEG
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43850: LD_ADDR_VAR 0 53
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 1
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: LD_INT 0
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 1
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 1
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 1
43931: NEG
43932: PUSH
43933: LD_INT 2
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 0
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 1
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 2
43965: PUSH
43966: LD_INT 0
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 2
43975: PUSH
43976: LD_INT 1
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 2
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 1
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 0
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 1
44015: NEG
44016: PUSH
44017: LD_INT 1
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 2
44026: NEG
44027: PUSH
44028: LD_INT 0
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 2
44037: NEG
44038: PUSH
44039: LD_INT 1
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 2
44049: NEG
44050: PUSH
44051: LD_INT 2
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44080: LD_ADDR_VAR 0 54
44084: PUSH
44085: LD_INT 0
44087: PUSH
44088: LD_INT 0
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 0
44097: PUSH
44098: LD_INT 1
44100: NEG
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: LD_INT 0
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 1
44118: PUSH
44119: LD_INT 1
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 0
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: LD_INT 0
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 1
44161: NEG
44162: PUSH
44163: LD_INT 2
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 1
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 2
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: LD_INT 1
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 2
44215: PUSH
44216: LD_INT 2
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 1
44225: PUSH
44226: LD_INT 2
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 0
44235: PUSH
44236: LD_INT 2
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: NEG
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 2
44256: NEG
44257: PUSH
44258: LD_INT 0
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 2
44267: NEG
44268: PUSH
44269: LD_INT 1
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 2
44279: NEG
44280: PUSH
44281: LD_INT 2
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44310: LD_ADDR_VAR 0 55
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: LD_INT 0
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: LD_INT 1
44330: NEG
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 1
44338: PUSH
44339: LD_INT 0
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 1
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: LD_INT 1
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: LD_INT 0
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 1
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 2
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 0
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 1
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 2
44435: PUSH
44436: LD_INT 1
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 2
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 1
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: NEG
44476: PUSH
44477: LD_INT 1
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 2
44486: NEG
44487: PUSH
44488: LD_INT 0
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 2
44497: NEG
44498: PUSH
44499: LD_INT 1
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 2
44509: NEG
44510: PUSH
44511: LD_INT 2
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44540: LD_ADDR_VAR 0 56
44544: PUSH
44545: LD_INT 0
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 0
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 1
44568: PUSH
44569: LD_INT 0
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: LD_INT 1
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: LD_INT 1
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: LD_INT 0
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 1
44609: NEG
44610: PUSH
44611: LD_INT 1
44613: NEG
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: LD_INT 2
44625: NEG
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: LD_INT 2
44636: NEG
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 1
44644: PUSH
44645: LD_INT 1
44647: NEG
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 2
44655: PUSH
44656: LD_INT 0
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: LD_INT 2
44665: PUSH
44666: LD_INT 1
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: LD_INT 2
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 1
44685: PUSH
44686: LD_INT 2
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 0
44695: PUSH
44696: LD_INT 2
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 2
44716: NEG
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 2
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 2
44739: NEG
44740: PUSH
44741: LD_INT 2
44743: NEG
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44770: LD_ADDR_VAR 0 57
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: LD_INT 0
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: LD_INT 1
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 1
44798: PUSH
44799: LD_INT 0
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: LD_INT 1
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: LD_INT 0
44818: PUSH
44819: LD_INT 1
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 1
44828: NEG
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 1
44839: NEG
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 1
44851: NEG
44852: PUSH
44853: LD_INT 2
44855: NEG
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 0
44863: PUSH
44864: LD_INT 2
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 1
44874: PUSH
44875: LD_INT 1
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 2
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 1
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 2
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: LD_INT 2
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 1
44935: NEG
44936: PUSH
44937: LD_INT 1
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 2
44946: NEG
44947: PUSH
44948: LD_INT 0
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 2
44957: NEG
44958: PUSH
44959: LD_INT 1
44961: NEG
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 2
44969: NEG
44970: PUSH
44971: LD_INT 2
44973: NEG
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45000: LD_ADDR_VAR 0 58
45004: PUSH
45005: LD_INT 0
45007: PUSH
45008: LD_INT 0
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 1
45028: PUSH
45029: LD_INT 0
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 1
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 0
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 1
45069: NEG
45070: PUSH
45071: LD_INT 1
45073: NEG
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 1
45081: NEG
45082: PUSH
45083: LD_INT 2
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 0
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 1
45104: PUSH
45105: LD_INT 1
45107: NEG
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: LD_INT 1
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: PUSH
45136: LD_INT 2
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 1
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 0
45155: PUSH
45156: LD_INT 2
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 1
45165: NEG
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 2
45176: NEG
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 2
45187: NEG
45188: PUSH
45189: LD_INT 1
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 2
45199: NEG
45200: PUSH
45201: LD_INT 2
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45230: LD_ADDR_VAR 0 59
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 0
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 1
45258: PUSH
45259: LD_INT 0
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 1
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 0
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 1
45288: NEG
45289: PUSH
45290: LD_INT 0
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 1
45299: NEG
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45318: LD_ADDR_VAR 0 60
45322: PUSH
45323: LD_INT 0
45325: PUSH
45326: LD_INT 0
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 0
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 1
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 0
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 1
45376: NEG
45377: PUSH
45378: LD_INT 0
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 1
45387: NEG
45388: PUSH
45389: LD_INT 1
45391: NEG
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45406: LD_ADDR_VAR 0 61
45410: PUSH
45411: LD_INT 0
45413: PUSH
45414: LD_INT 0
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 0
45423: PUSH
45424: LD_INT 1
45426: NEG
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 1
45434: PUSH
45435: LD_INT 0
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 1
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: LD_INT 1
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 1
45464: NEG
45465: PUSH
45466: LD_INT 0
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 1
45475: NEG
45476: PUSH
45477: LD_INT 1
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45494: LD_ADDR_VAR 0 62
45498: PUSH
45499: LD_INT 0
45501: PUSH
45502: LD_INT 0
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 1
45514: NEG
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: LD_INT 1
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 1
45532: PUSH
45533: LD_INT 1
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 0
45542: PUSH
45543: LD_INT 1
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 1
45552: NEG
45553: PUSH
45554: LD_INT 0
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 1
45563: NEG
45564: PUSH
45565: LD_INT 1
45567: NEG
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: EMPTY
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45582: LD_ADDR_VAR 0 63
45586: PUSH
45587: LD_INT 0
45589: PUSH
45590: LD_INT 0
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 1
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 1
45610: PUSH
45611: LD_INT 0
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 1
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 0
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 1
45640: NEG
45641: PUSH
45642: LD_INT 0
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: NEG
45652: PUSH
45653: LD_INT 1
45655: NEG
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45670: LD_ADDR_VAR 0 64
45674: PUSH
45675: LD_INT 0
45677: PUSH
45678: LD_INT 0
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 1
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: LD_INT 0
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 1
45708: PUSH
45709: LD_INT 1
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 0
45718: PUSH
45719: LD_INT 1
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: NEG
45729: PUSH
45730: LD_INT 0
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: ST_TO_ADDR
// end ; 1 :
45758: GO 51655
45760: LD_INT 1
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45768
45766: GO 48391
45768: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45769: LD_ADDR_VAR 0 11
45773: PUSH
45774: LD_INT 1
45776: NEG
45777: PUSH
45778: LD_INT 3
45780: NEG
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 0
45788: PUSH
45789: LD_INT 3
45791: NEG
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: PUSH
45800: LD_INT 2
45802: NEG
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: LIST
45812: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45813: LD_ADDR_VAR 0 12
45817: PUSH
45818: LD_INT 2
45820: PUSH
45821: LD_INT 1
45823: NEG
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: LD_INT 0
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: LD_INT 1
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: LIST
45853: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45854: LD_ADDR_VAR 0 13
45858: PUSH
45859: LD_INT 3
45861: PUSH
45862: LD_INT 2
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 3
45871: PUSH
45872: LD_INT 3
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 2
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45894: LD_ADDR_VAR 0 14
45898: PUSH
45899: LD_INT 1
45901: PUSH
45902: LD_INT 3
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 1
45921: NEG
45922: PUSH
45923: LD_INT 2
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: LIST
45934: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45935: LD_ADDR_VAR 0 15
45939: PUSH
45940: LD_INT 2
45942: NEG
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: NEG
45954: PUSH
45955: LD_INT 0
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 3
45964: NEG
45965: PUSH
45966: LD_INT 1
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: LIST
45978: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45979: LD_ADDR_VAR 0 16
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: LD_INT 3
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: NEG
45999: PUSH
46000: LD_INT 2
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 3
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: LIST
46024: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46025: LD_ADDR_VAR 0 17
46029: PUSH
46030: LD_INT 1
46032: NEG
46033: PUSH
46034: LD_INT 3
46036: NEG
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 0
46044: PUSH
46045: LD_INT 3
46047: NEG
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 1
46055: PUSH
46056: LD_INT 2
46058: NEG
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: LIST
46068: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46069: LD_ADDR_VAR 0 18
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 3
46097: PUSH
46098: LD_INT 1
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: LIST
46109: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46110: LD_ADDR_VAR 0 19
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: LD_INT 2
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: LD_INT 3
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: LIST
46149: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46150: LD_ADDR_VAR 0 20
46154: PUSH
46155: LD_INT 1
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 0
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 1
46177: NEG
46178: PUSH
46179: LD_INT 2
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: LIST
46190: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46191: LD_ADDR_VAR 0 21
46195: PUSH
46196: LD_INT 2
46198: NEG
46199: PUSH
46200: LD_INT 1
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 3
46209: NEG
46210: PUSH
46211: LD_INT 0
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 3
46220: NEG
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: LIST
46234: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46235: LD_ADDR_VAR 0 22
46239: PUSH
46240: LD_INT 2
46242: NEG
46243: PUSH
46244: LD_INT 3
46246: NEG
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 3
46254: NEG
46255: PUSH
46256: LD_INT 2
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 3
46266: NEG
46267: PUSH
46268: LD_INT 3
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: LIST
46280: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46281: LD_ADDR_VAR 0 23
46285: PUSH
46286: LD_INT 0
46288: PUSH
46289: LD_INT 3
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 1
46299: NEG
46300: PUSH
46301: LD_INT 4
46303: NEG
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 1
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: LIST
46324: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46325: LD_ADDR_VAR 0 24
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: LD_INT 0
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46366: LD_ADDR_VAR 0 25
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 3
46393: PUSH
46394: LD_INT 4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: LIST
46405: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46406: LD_ADDR_VAR 0 26
46410: PUSH
46411: LD_INT 0
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 1
46423: PUSH
46424: LD_INT 4
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 1
46433: NEG
46434: PUSH
46435: LD_INT 3
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: LIST
46446: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46447: LD_ADDR_VAR 0 27
46451: PUSH
46452: LD_INT 3
46454: NEG
46455: PUSH
46456: LD_INT 0
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: PUSH
46463: LD_INT 3
46465: NEG
46466: PUSH
46467: LD_INT 1
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 4
46476: NEG
46477: PUSH
46478: LD_INT 1
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: LIST
46490: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46491: LD_ADDR_VAR 0 28
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46537: LD_ADDR_VAR 0 29
46541: PUSH
46542: LD_INT 1
46544: NEG
46545: PUSH
46546: LD_INT 3
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 0
46556: PUSH
46557: LD_INT 3
46559: NEG
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: PUSH
46565: LD_INT 1
46567: PUSH
46568: LD_INT 2
46570: NEG
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 1
46578: NEG
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 0
46590: PUSH
46591: LD_INT 4
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 3
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 1
46612: NEG
46613: PUSH
46614: LD_INT 5
46616: NEG
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: LD_INT 0
46624: PUSH
46625: LD_INT 5
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: PUSH
46636: LD_INT 4
46638: NEG
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 1
46646: NEG
46647: PUSH
46648: LD_INT 6
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 0
46658: PUSH
46659: LD_INT 6
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 1
46669: PUSH
46670: LD_INT 5
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46692: LD_ADDR_VAR 0 30
46696: PUSH
46697: LD_INT 2
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: LD_INT 0
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 3
46720: PUSH
46721: LD_INT 1
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 1
46733: NEG
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: LD_INT 0
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 4
46751: PUSH
46752: LD_INT 1
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 4
46761: PUSH
46762: LD_INT 1
46764: NEG
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 5
46772: PUSH
46773: LD_INT 0
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 5
46782: PUSH
46783: LD_INT 1
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 5
46792: PUSH
46793: LD_INT 1
46795: NEG
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 6
46803: PUSH
46804: LD_INT 0
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 6
46813: PUSH
46814: LD_INT 1
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46835: LD_ADDR_VAR 0 31
46839: PUSH
46840: LD_INT 3
46842: PUSH
46843: LD_INT 2
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 2
46862: PUSH
46863: LD_INT 3
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 4
46872: PUSH
46873: LD_INT 3
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 4
46882: PUSH
46883: LD_INT 4
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: LD_INT 4
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 5
46902: PUSH
46903: LD_INT 4
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 5
46912: PUSH
46913: LD_INT 5
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 4
46922: PUSH
46923: LD_INT 5
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 6
46932: PUSH
46933: LD_INT 5
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PUSH
46940: LD_INT 6
46942: PUSH
46943: LD_INT 6
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 5
46952: PUSH
46953: LD_INT 6
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46974: LD_ADDR_VAR 0 32
46978: PUSH
46979: LD_INT 1
46981: PUSH
46982: LD_INT 3
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: PUSH
46989: LD_INT 0
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 1
47001: NEG
47002: PUSH
47003: LD_INT 2
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 1
47012: PUSH
47013: LD_INT 4
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: PUSH
47020: LD_INT 0
47022: PUSH
47023: LD_INT 4
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: PUSH
47030: LD_INT 1
47032: NEG
47033: PUSH
47034: LD_INT 3
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 1
47043: PUSH
47044: LD_INT 5
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: LD_INT 5
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 1
47063: NEG
47064: PUSH
47065: LD_INT 4
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: PUSH
47072: LD_INT 1
47074: PUSH
47075: LD_INT 6
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 0
47084: PUSH
47085: LD_INT 6
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: LD_INT 1
47094: NEG
47095: PUSH
47096: LD_INT 5
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47117: LD_ADDR_VAR 0 33
47121: PUSH
47122: LD_INT 2
47124: NEG
47125: PUSH
47126: LD_INT 1
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 3
47135: NEG
47136: PUSH
47137: LD_INT 0
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 3
47146: NEG
47147: PUSH
47148: LD_INT 1
47150: NEG
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 3
47158: NEG
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 4
47169: NEG
47170: PUSH
47171: LD_INT 0
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 4
47180: NEG
47181: PUSH
47182: LD_INT 1
47184: NEG
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: LD_INT 4
47192: NEG
47193: PUSH
47194: LD_INT 1
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 5
47203: NEG
47204: PUSH
47205: LD_INT 0
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 5
47214: NEG
47215: PUSH
47216: LD_INT 1
47218: NEG
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 5
47226: NEG
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PUSH
47235: LD_INT 6
47237: NEG
47238: PUSH
47239: LD_INT 0
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 6
47248: NEG
47249: PUSH
47250: LD_INT 1
47252: NEG
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47272: LD_ADDR_VAR 0 34
47276: PUSH
47277: LD_INT 2
47279: NEG
47280: PUSH
47281: LD_INT 3
47283: NEG
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 3
47291: NEG
47292: PUSH
47293: LD_INT 2
47295: NEG
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: LD_INT 3
47303: NEG
47304: PUSH
47305: LD_INT 3
47307: NEG
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 3
47315: NEG
47316: PUSH
47317: LD_INT 4
47319: NEG
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: LD_INT 4
47327: NEG
47328: PUSH
47329: LD_INT 3
47331: NEG
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 4
47339: NEG
47340: PUSH
47341: LD_INT 4
47343: NEG
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: PUSH
47349: LD_INT 4
47351: NEG
47352: PUSH
47353: LD_INT 5
47355: NEG
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PUSH
47361: LD_INT 5
47363: NEG
47364: PUSH
47365: LD_INT 4
47367: NEG
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: LD_INT 5
47375: NEG
47376: PUSH
47377: LD_INT 5
47379: NEG
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: LD_INT 5
47387: NEG
47388: PUSH
47389: LD_INT 6
47391: NEG
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 6
47399: NEG
47400: PUSH
47401: LD_INT 5
47403: NEG
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 6
47411: NEG
47412: PUSH
47413: LD_INT 6
47415: NEG
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47435: LD_ADDR_VAR 0 41
47439: PUSH
47440: LD_INT 0
47442: PUSH
47443: LD_INT 2
47445: NEG
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 1
47453: NEG
47454: PUSH
47455: LD_INT 3
47457: NEG
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: PUSH
47463: LD_INT 1
47465: PUSH
47466: LD_INT 2
47468: NEG
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: LIST
47478: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47479: LD_ADDR_VAR 0 42
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: LD_INT 0
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: PUSH
47494: LD_INT 2
47496: PUSH
47497: LD_INT 1
47499: NEG
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 3
47507: PUSH
47508: LD_INT 1
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: LIST
47519: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47520: LD_ADDR_VAR 0 43
47524: PUSH
47525: LD_INT 2
47527: PUSH
47528: LD_INT 2
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 2
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 2
47547: PUSH
47548: LD_INT 3
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: LIST
47559: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47560: LD_ADDR_VAR 0 44
47564: PUSH
47565: LD_INT 0
47567: PUSH
47568: LD_INT 2
47570: PUSH
47571: EMPTY
47572: LIST
47573: LIST
47574: PUSH
47575: LD_INT 1
47577: PUSH
47578: LD_INT 3
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 1
47587: NEG
47588: PUSH
47589: LD_INT 2
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: LIST
47600: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47601: LD_ADDR_VAR 0 45
47605: PUSH
47606: LD_INT 2
47608: NEG
47609: PUSH
47610: LD_INT 0
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: LD_INT 2
47619: NEG
47620: PUSH
47621: LD_INT 1
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: PUSH
47628: LD_INT 3
47630: NEG
47631: PUSH
47632: LD_INT 1
47634: NEG
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47645: LD_ADDR_VAR 0 46
47649: PUSH
47650: LD_INT 2
47652: NEG
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PUSH
47662: LD_INT 2
47664: NEG
47665: PUSH
47666: LD_INT 3
47668: NEG
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 3
47676: NEG
47677: PUSH
47678: LD_INT 2
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47691: LD_ADDR_VAR 0 47
47695: PUSH
47696: LD_INT 2
47698: NEG
47699: PUSH
47700: LD_INT 3
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 1
47710: NEG
47711: PUSH
47712: LD_INT 3
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47724: LD_ADDR_VAR 0 48
47728: PUSH
47729: LD_INT 1
47731: PUSH
47732: LD_INT 2
47734: NEG
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: PUSH
47740: LD_INT 2
47742: PUSH
47743: LD_INT 1
47745: NEG
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47755: LD_ADDR_VAR 0 49
47759: PUSH
47760: LD_INT 3
47762: PUSH
47763: LD_INT 1
47765: PUSH
47766: EMPTY
47767: LIST
47768: LIST
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47784: LD_ADDR_VAR 0 50
47788: PUSH
47789: LD_INT 2
47791: PUSH
47792: LD_INT 3
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 1
47801: PUSH
47802: LD_INT 3
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47813: LD_ADDR_VAR 0 51
47817: PUSH
47818: LD_INT 1
47820: NEG
47821: PUSH
47822: LD_INT 2
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PUSH
47829: LD_INT 2
47831: NEG
47832: PUSH
47833: LD_INT 1
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47844: LD_ADDR_VAR 0 52
47848: PUSH
47849: LD_INT 3
47851: NEG
47852: PUSH
47853: LD_INT 1
47855: NEG
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PUSH
47861: LD_INT 3
47863: NEG
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47877: LD_ADDR_VAR 0 53
47881: PUSH
47882: LD_INT 1
47884: NEG
47885: PUSH
47886: LD_INT 3
47888: NEG
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 0
47896: PUSH
47897: LD_INT 3
47899: NEG
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: LD_INT 1
47907: PUSH
47908: LD_INT 2
47910: NEG
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: LIST
47920: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47921: LD_ADDR_VAR 0 54
47925: PUSH
47926: LD_INT 2
47928: PUSH
47929: LD_INT 1
47931: NEG
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 3
47939: PUSH
47940: LD_INT 0
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 1
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: LIST
47961: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47962: LD_ADDR_VAR 0 55
47966: PUSH
47967: LD_INT 3
47969: PUSH
47970: LD_INT 2
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 3
47979: PUSH
47980: LD_INT 3
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 2
47989: PUSH
47990: LD_INT 3
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48002: LD_ADDR_VAR 0 56
48006: PUSH
48007: LD_INT 1
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 0
48019: PUSH
48020: LD_INT 3
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 1
48029: NEG
48030: PUSH
48031: LD_INT 2
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48043: LD_ADDR_VAR 0 57
48047: PUSH
48048: LD_INT 2
48050: NEG
48051: PUSH
48052: LD_INT 1
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_INT 3
48061: NEG
48062: PUSH
48063: LD_INT 0
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 3
48072: NEG
48073: PUSH
48074: LD_INT 1
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: LIST
48086: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48087: LD_ADDR_VAR 0 58
48091: PUSH
48092: LD_INT 2
48094: NEG
48095: PUSH
48096: LD_INT 3
48098: NEG
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: LD_INT 3
48106: NEG
48107: PUSH
48108: LD_INT 2
48110: NEG
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 3
48118: NEG
48119: PUSH
48120: LD_INT 3
48122: NEG
48123: PUSH
48124: EMPTY
48125: LIST
48126: LIST
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48133: LD_ADDR_VAR 0 59
48137: PUSH
48138: LD_INT 1
48140: NEG
48141: PUSH
48142: LD_INT 2
48144: NEG
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: LD_INT 0
48152: PUSH
48153: LD_INT 2
48155: NEG
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: PUSH
48161: LD_INT 1
48163: PUSH
48164: LD_INT 1
48166: NEG
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: EMPTY
48173: LIST
48174: LIST
48175: LIST
48176: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48177: LD_ADDR_VAR 0 60
48181: PUSH
48182: LD_INT 1
48184: PUSH
48185: LD_INT 1
48187: NEG
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 2
48195: PUSH
48196: LD_INT 0
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 2
48205: PUSH
48206: LD_INT 1
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48218: LD_ADDR_VAR 0 61
48222: PUSH
48223: LD_INT 2
48225: PUSH
48226: LD_INT 1
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 2
48235: PUSH
48236: LD_INT 2
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 1
48245: PUSH
48246: LD_INT 2
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: LIST
48257: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48258: LD_ADDR_VAR 0 62
48262: PUSH
48263: LD_INT 1
48265: PUSH
48266: LD_INT 2
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: LD_INT 2
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: PUSH
48283: LD_INT 1
48285: NEG
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: LIST
48298: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48299: LD_ADDR_VAR 0 63
48303: PUSH
48304: LD_INT 1
48306: NEG
48307: PUSH
48308: LD_INT 1
48310: PUSH
48311: EMPTY
48312: LIST
48313: LIST
48314: PUSH
48315: LD_INT 2
48317: NEG
48318: PUSH
48319: LD_INT 0
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: PUSH
48326: LD_INT 2
48328: NEG
48329: PUSH
48330: LD_INT 1
48332: NEG
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48343: LD_ADDR_VAR 0 64
48347: PUSH
48348: LD_INT 1
48350: NEG
48351: PUSH
48352: LD_INT 2
48354: NEG
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: PUSH
48360: LD_INT 2
48362: NEG
48363: PUSH
48364: LD_INT 1
48366: NEG
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 2
48374: NEG
48375: PUSH
48376: LD_INT 2
48378: NEG
48379: PUSH
48380: EMPTY
48381: LIST
48382: LIST
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: LIST
48388: ST_TO_ADDR
// end ; 2 :
48389: GO 51655
48391: LD_INT 2
48393: DOUBLE
48394: EQUAL
48395: IFTRUE 48399
48397: GO 51654
48399: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48400: LD_ADDR_VAR 0 29
48404: PUSH
48405: LD_INT 4
48407: PUSH
48408: LD_INT 0
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 1
48420: NEG
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: LD_INT 5
48428: PUSH
48429: LD_INT 0
48431: PUSH
48432: EMPTY
48433: LIST
48434: LIST
48435: PUSH
48436: LD_INT 5
48438: PUSH
48439: LD_INT 1
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 4
48448: PUSH
48449: LD_INT 1
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: LD_INT 3
48458: PUSH
48459: LD_INT 0
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 3
48468: PUSH
48469: LD_INT 1
48471: NEG
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 3
48479: PUSH
48480: LD_INT 2
48482: NEG
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PUSH
48488: LD_INT 5
48490: PUSH
48491: LD_INT 2
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: LD_INT 3
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: LD_INT 2
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 4
48520: PUSH
48521: LD_INT 3
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: PUSH
48528: LD_INT 4
48530: PUSH
48531: LD_INT 4
48533: PUSH
48534: EMPTY
48535: LIST
48536: LIST
48537: PUSH
48538: LD_INT 3
48540: PUSH
48541: LD_INT 4
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 2
48550: PUSH
48551: LD_INT 3
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: PUSH
48561: LD_INT 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 4
48570: PUSH
48571: LD_INT 2
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 4
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 0
48590: PUSH
48591: LD_INT 4
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 0
48600: PUSH
48601: LD_INT 3
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 1
48610: PUSH
48611: LD_INT 4
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 1
48620: PUSH
48621: LD_INT 5
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 0
48630: PUSH
48631: LD_INT 5
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 1
48640: NEG
48641: PUSH
48642: LD_INT 4
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 1
48651: NEG
48652: PUSH
48653: LD_INT 3
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 5
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: LD_INT 2
48672: NEG
48673: PUSH
48674: LD_INT 3
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 3
48683: NEG
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 3
48694: NEG
48695: PUSH
48696: LD_INT 1
48698: NEG
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 2
48706: NEG
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 2
48717: NEG
48718: PUSH
48719: LD_INT 1
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: PUSH
48726: LD_INT 3
48728: NEG
48729: PUSH
48730: LD_INT 1
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 4
48739: NEG
48740: PUSH
48741: LD_INT 0
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: LD_INT 4
48750: NEG
48751: PUSH
48752: LD_INT 1
48754: NEG
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 4
48762: NEG
48763: PUSH
48764: LD_INT 2
48766: NEG
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 2
48774: NEG
48775: PUSH
48776: LD_INT 2
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 4
48785: NEG
48786: PUSH
48787: LD_INT 4
48789: NEG
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 4
48797: NEG
48798: PUSH
48799: LD_INT 5
48801: NEG
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PUSH
48807: LD_INT 3
48809: NEG
48810: PUSH
48811: LD_INT 4
48813: NEG
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PUSH
48819: LD_INT 3
48821: NEG
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_INT 4
48833: NEG
48834: PUSH
48835: LD_INT 3
48837: NEG
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_INT 5
48845: NEG
48846: PUSH
48847: LD_INT 4
48849: NEG
48850: PUSH
48851: EMPTY
48852: LIST
48853: LIST
48854: PUSH
48855: LD_INT 5
48857: NEG
48858: PUSH
48859: LD_INT 5
48861: NEG
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_INT 3
48869: NEG
48870: PUSH
48871: LD_INT 5
48873: NEG
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: LD_INT 5
48881: NEG
48882: PUSH
48883: LD_INT 3
48885: NEG
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: EMPTY
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48938: LD_ADDR_VAR 0 30
48942: PUSH
48943: LD_INT 4
48945: PUSH
48946: LD_INT 4
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 4
48955: PUSH
48956: LD_INT 3
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: LD_INT 5
48965: PUSH
48966: LD_INT 4
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PUSH
48973: LD_INT 5
48975: PUSH
48976: LD_INT 5
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_INT 4
48985: PUSH
48986: LD_INT 5
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 3
48995: PUSH
48996: LD_INT 4
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: PUSH
49006: LD_INT 3
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: LD_INT 5
49015: PUSH
49016: LD_INT 3
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: LD_INT 5
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 0
49035: PUSH
49036: LD_INT 3
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: LD_INT 2
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 1
49055: PUSH
49056: LD_INT 3
49058: PUSH
49059: EMPTY
49060: LIST
49061: LIST
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: LD_INT 4
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: LD_INT 4
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 1
49085: NEG
49086: PUSH
49087: LD_INT 3
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 1
49096: NEG
49097: PUSH
49098: LD_INT 2
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: LD_INT 2
49107: PUSH
49108: LD_INT 4
49110: PUSH
49111: EMPTY
49112: LIST
49113: LIST
49114: PUSH
49115: LD_INT 2
49117: NEG
49118: PUSH
49119: LD_INT 2
49121: PUSH
49122: EMPTY
49123: LIST
49124: LIST
49125: PUSH
49126: LD_INT 4
49128: NEG
49129: PUSH
49130: LD_INT 0
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: LD_INT 4
49139: NEG
49140: PUSH
49141: LD_INT 1
49143: NEG
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 3
49151: NEG
49152: PUSH
49153: LD_INT 0
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PUSH
49160: LD_INT 3
49162: NEG
49163: PUSH
49164: LD_INT 1
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: LD_INT 4
49173: NEG
49174: PUSH
49175: LD_INT 1
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: PUSH
49182: LD_INT 5
49184: NEG
49185: PUSH
49186: LD_INT 0
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PUSH
49193: LD_INT 5
49195: NEG
49196: PUSH
49197: LD_INT 1
49199: NEG
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 5
49207: NEG
49208: PUSH
49209: LD_INT 2
49211: NEG
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PUSH
49217: LD_INT 3
49219: NEG
49220: PUSH
49221: LD_INT 2
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 3
49230: NEG
49231: PUSH
49232: LD_INT 3
49234: NEG
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 3
49242: NEG
49243: PUSH
49244: LD_INT 4
49246: NEG
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 2
49254: NEG
49255: PUSH
49256: LD_INT 3
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 2
49266: NEG
49267: PUSH
49268: LD_INT 2
49270: NEG
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 3
49278: NEG
49279: PUSH
49280: LD_INT 2
49282: NEG
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: PUSH
49288: LD_INT 4
49290: NEG
49291: PUSH
49292: LD_INT 3
49294: NEG
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 4
49302: NEG
49303: PUSH
49304: LD_INT 4
49306: NEG
49307: PUSH
49308: EMPTY
49309: LIST
49310: LIST
49311: PUSH
49312: LD_INT 2
49314: NEG
49315: PUSH
49316: LD_INT 4
49318: NEG
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: PUSH
49324: LD_INT 4
49326: NEG
49327: PUSH
49328: LD_INT 2
49330: NEG
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 0
49338: PUSH
49339: LD_INT 4
49341: NEG
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PUSH
49347: LD_INT 0
49349: PUSH
49350: LD_INT 5
49352: NEG
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: LD_INT 1
49360: PUSH
49361: LD_INT 4
49363: NEG
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: PUSH
49369: LD_INT 1
49371: PUSH
49372: LD_INT 3
49374: NEG
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: PUSH
49380: LD_INT 0
49382: PUSH
49383: LD_INT 3
49385: NEG
49386: PUSH
49387: EMPTY
49388: LIST
49389: LIST
49390: PUSH
49391: LD_INT 1
49393: NEG
49394: PUSH
49395: LD_INT 4
49397: NEG
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: LD_INT 5
49409: NEG
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 2
49417: PUSH
49418: LD_INT 3
49420: NEG
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 2
49428: NEG
49429: PUSH
49430: LD_INT 5
49432: NEG
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49485: LD_ADDR_VAR 0 31
49489: PUSH
49490: LD_INT 0
49492: PUSH
49493: LD_INT 4
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 0
49502: PUSH
49503: LD_INT 3
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 1
49512: PUSH
49513: LD_INT 4
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 5
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 0
49532: PUSH
49533: LD_INT 5
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PUSH
49540: LD_INT 1
49542: NEG
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: EMPTY
49548: LIST
49549: LIST
49550: PUSH
49551: LD_INT 1
49553: NEG
49554: PUSH
49555: LD_INT 3
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 2
49564: PUSH
49565: LD_INT 5
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 2
49574: NEG
49575: PUSH
49576: LD_INT 3
49578: PUSH
49579: EMPTY
49580: LIST
49581: LIST
49582: PUSH
49583: LD_INT 3
49585: NEG
49586: PUSH
49587: LD_INT 0
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: LD_INT 3
49596: NEG
49597: PUSH
49598: LD_INT 1
49600: NEG
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 2
49608: NEG
49609: PUSH
49610: LD_INT 0
49612: PUSH
49613: EMPTY
49614: LIST
49615: LIST
49616: PUSH
49617: LD_INT 2
49619: NEG
49620: PUSH
49621: LD_INT 1
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: LD_INT 3
49630: NEG
49631: PUSH
49632: LD_INT 1
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: LD_INT 4
49641: NEG
49642: PUSH
49643: LD_INT 0
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: NEG
49653: PUSH
49654: LD_INT 1
49656: NEG
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 4
49664: NEG
49665: PUSH
49666: LD_INT 2
49668: NEG
49669: PUSH
49670: EMPTY
49671: LIST
49672: LIST
49673: PUSH
49674: LD_INT 2
49676: NEG
49677: PUSH
49678: LD_INT 2
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: LD_INT 4
49687: NEG
49688: PUSH
49689: LD_INT 4
49691: NEG
49692: PUSH
49693: EMPTY
49694: LIST
49695: LIST
49696: PUSH
49697: LD_INT 4
49699: NEG
49700: PUSH
49701: LD_INT 5
49703: NEG
49704: PUSH
49705: EMPTY
49706: LIST
49707: LIST
49708: PUSH
49709: LD_INT 3
49711: NEG
49712: PUSH
49713: LD_INT 4
49715: NEG
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 3
49723: NEG
49724: PUSH
49725: LD_INT 3
49727: NEG
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 4
49735: NEG
49736: PUSH
49737: LD_INT 3
49739: NEG
49740: PUSH
49741: EMPTY
49742: LIST
49743: LIST
49744: PUSH
49745: LD_INT 5
49747: NEG
49748: PUSH
49749: LD_INT 4
49751: NEG
49752: PUSH
49753: EMPTY
49754: LIST
49755: LIST
49756: PUSH
49757: LD_INT 5
49759: NEG
49760: PUSH
49761: LD_INT 5
49763: NEG
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 3
49771: NEG
49772: PUSH
49773: LD_INT 5
49775: NEG
49776: PUSH
49777: EMPTY
49778: LIST
49779: LIST
49780: PUSH
49781: LD_INT 5
49783: NEG
49784: PUSH
49785: LD_INT 3
49787: NEG
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 0
49795: PUSH
49796: LD_INT 3
49798: NEG
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: PUSH
49804: LD_INT 0
49806: PUSH
49807: LD_INT 4
49809: NEG
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 1
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 1
49828: PUSH
49829: LD_INT 2
49831: NEG
49832: PUSH
49833: EMPTY
49834: LIST
49835: LIST
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: LD_INT 2
49842: NEG
49843: PUSH
49844: EMPTY
49845: LIST
49846: LIST
49847: PUSH
49848: LD_INT 1
49850: NEG
49851: PUSH
49852: LD_INT 3
49854: NEG
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PUSH
49860: LD_INT 1
49862: NEG
49863: PUSH
49864: LD_INT 4
49866: NEG
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PUSH
49872: LD_INT 2
49874: PUSH
49875: LD_INT 2
49877: NEG
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: LD_INT 2
49885: NEG
49886: PUSH
49887: LD_INT 4
49889: NEG
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 4
49897: PUSH
49898: LD_INT 0
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 4
49907: PUSH
49908: LD_INT 1
49910: NEG
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: PUSH
49916: LD_INT 5
49918: PUSH
49919: LD_INT 0
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: LD_INT 5
49928: PUSH
49929: LD_INT 1
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PUSH
49936: LD_INT 4
49938: PUSH
49939: LD_INT 1
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: PUSH
49946: LD_INT 3
49948: PUSH
49949: LD_INT 0
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 3
49958: PUSH
49959: LD_INT 1
49961: NEG
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 3
49969: PUSH
49970: LD_INT 2
49972: NEG
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: LD_INT 5
49980: PUSH
49981: LD_INT 2
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: LIST
50032: LIST
50033: LIST
50034: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50035: LD_ADDR_VAR 0 32
50039: PUSH
50040: LD_INT 4
50042: NEG
50043: PUSH
50044: LD_INT 0
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: LD_INT 4
50053: NEG
50054: PUSH
50055: LD_INT 1
50057: NEG
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 3
50065: NEG
50066: PUSH
50067: LD_INT 0
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PUSH
50074: LD_INT 3
50076: NEG
50077: PUSH
50078: LD_INT 1
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 4
50087: NEG
50088: PUSH
50089: LD_INT 1
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: PUSH
50096: LD_INT 5
50098: NEG
50099: PUSH
50100: LD_INT 0
50102: PUSH
50103: EMPTY
50104: LIST
50105: LIST
50106: PUSH
50107: LD_INT 5
50109: NEG
50110: PUSH
50111: LD_INT 1
50113: NEG
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 5
50121: NEG
50122: PUSH
50123: LD_INT 2
50125: NEG
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: LD_INT 3
50133: NEG
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: LD_INT 3
50144: NEG
50145: PUSH
50146: LD_INT 3
50148: NEG
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 3
50156: NEG
50157: PUSH
50158: LD_INT 4
50160: NEG
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 2
50168: NEG
50169: PUSH
50170: LD_INT 3
50172: NEG
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 2
50180: NEG
50181: PUSH
50182: LD_INT 2
50184: NEG
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PUSH
50190: LD_INT 3
50192: NEG
50193: PUSH
50194: LD_INT 2
50196: NEG
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: LD_INT 4
50204: NEG
50205: PUSH
50206: LD_INT 3
50208: NEG
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 4
50216: NEG
50217: PUSH
50218: LD_INT 4
50220: NEG
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: LD_INT 2
50228: NEG
50229: PUSH
50230: LD_INT 4
50232: NEG
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 4
50240: NEG
50241: PUSH
50242: LD_INT 2
50244: NEG
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: PUSH
50250: LD_INT 0
50252: PUSH
50253: LD_INT 4
50255: NEG
50256: PUSH
50257: EMPTY
50258: LIST
50259: LIST
50260: PUSH
50261: LD_INT 0
50263: PUSH
50264: LD_INT 5
50266: NEG
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 1
50274: PUSH
50275: LD_INT 4
50277: NEG
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: PUSH
50283: LD_INT 1
50285: PUSH
50286: LD_INT 3
50288: NEG
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: PUSH
50294: LD_INT 0
50296: PUSH
50297: LD_INT 3
50299: NEG
50300: PUSH
50301: EMPTY
50302: LIST
50303: LIST
50304: PUSH
50305: LD_INT 1
50307: NEG
50308: PUSH
50309: LD_INT 4
50311: NEG
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: LD_INT 1
50319: NEG
50320: PUSH
50321: LD_INT 5
50323: NEG
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: LD_INT 2
50331: PUSH
50332: LD_INT 3
50334: NEG
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 2
50342: NEG
50343: PUSH
50344: LD_INT 5
50346: NEG
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 3
50354: PUSH
50355: LD_INT 0
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 1
50367: NEG
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: PUSH
50373: LD_INT 4
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 4
50385: PUSH
50386: LD_INT 1
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: LD_INT 1
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 2
50405: PUSH
50406: LD_INT 0
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: LD_INT 2
50415: PUSH
50416: LD_INT 1
50418: NEG
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 2
50426: PUSH
50427: LD_INT 2
50429: NEG
50430: PUSH
50431: EMPTY
50432: LIST
50433: LIST
50434: PUSH
50435: LD_INT 4
50437: PUSH
50438: LD_INT 2
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: PUSH
50445: LD_INT 4
50447: PUSH
50448: LD_INT 4
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: PUSH
50455: LD_INT 4
50457: PUSH
50458: LD_INT 3
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: LD_INT 5
50467: PUSH
50468: LD_INT 4
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: PUSH
50475: LD_INT 5
50477: PUSH
50478: LD_INT 5
50480: PUSH
50481: EMPTY
50482: LIST
50483: LIST
50484: PUSH
50485: LD_INT 4
50487: PUSH
50488: LD_INT 5
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 3
50497: PUSH
50498: LD_INT 4
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 3
50507: PUSH
50508: LD_INT 3
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 5
50517: PUSH
50518: LD_INT 3
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: PUSH
50528: LD_INT 5
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50582: LD_ADDR_VAR 0 33
50586: PUSH
50587: LD_INT 4
50589: NEG
50590: PUSH
50591: LD_INT 4
50593: NEG
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PUSH
50599: LD_INT 4
50601: NEG
50602: PUSH
50603: LD_INT 5
50605: NEG
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: LD_INT 3
50613: NEG
50614: PUSH
50615: LD_INT 4
50617: NEG
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: LD_INT 3
50625: NEG
50626: PUSH
50627: LD_INT 3
50629: NEG
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 4
50637: NEG
50638: PUSH
50639: LD_INT 3
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 5
50649: NEG
50650: PUSH
50651: LD_INT 4
50653: NEG
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 5
50661: NEG
50662: PUSH
50663: LD_INT 5
50665: NEG
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: PUSH
50671: LD_INT 3
50673: NEG
50674: PUSH
50675: LD_INT 5
50677: NEG
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: LD_INT 5
50685: NEG
50686: PUSH
50687: LD_INT 3
50689: NEG
50690: PUSH
50691: EMPTY
50692: LIST
50693: LIST
50694: PUSH
50695: LD_INT 0
50697: PUSH
50698: LD_INT 3
50700: NEG
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PUSH
50706: LD_INT 0
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 1
50719: PUSH
50720: LD_INT 3
50722: NEG
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 1
50730: PUSH
50731: LD_INT 2
50733: NEG
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 0
50741: PUSH
50742: LD_INT 2
50744: NEG
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 1
50752: NEG
50753: PUSH
50754: LD_INT 3
50756: NEG
50757: PUSH
50758: EMPTY
50759: LIST
50760: LIST
50761: PUSH
50762: LD_INT 1
50764: NEG
50765: PUSH
50766: LD_INT 4
50768: NEG
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 2
50776: PUSH
50777: LD_INT 2
50779: NEG
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: PUSH
50785: LD_INT 2
50787: NEG
50788: PUSH
50789: LD_INT 4
50791: NEG
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: LD_INT 4
50799: PUSH
50800: LD_INT 0
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 4
50809: PUSH
50810: LD_INT 1
50812: NEG
50813: PUSH
50814: EMPTY
50815: LIST
50816: LIST
50817: PUSH
50818: LD_INT 5
50820: PUSH
50821: LD_INT 0
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: LD_INT 5
50830: PUSH
50831: LD_INT 1
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_INT 4
50840: PUSH
50841: LD_INT 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 3
50850: PUSH
50851: LD_INT 0
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 3
50860: PUSH
50861: LD_INT 1
50863: NEG
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: PUSH
50869: LD_INT 3
50871: PUSH
50872: LD_INT 2
50874: NEG
50875: PUSH
50876: EMPTY
50877: LIST
50878: LIST
50879: PUSH
50880: LD_INT 5
50882: PUSH
50883: LD_INT 2
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PUSH
50890: LD_INT 3
50892: PUSH
50893: LD_INT 3
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PUSH
50900: LD_INT 3
50902: PUSH
50903: LD_INT 2
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 4
50912: PUSH
50913: LD_INT 3
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: PUSH
50920: LD_INT 4
50922: PUSH
50923: LD_INT 4
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 3
50932: PUSH
50933: LD_INT 4
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: LD_INT 2
50942: PUSH
50943: LD_INT 3
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: LD_INT 2
50952: PUSH
50953: LD_INT 2
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 4
50962: PUSH
50963: LD_INT 2
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: LD_INT 2
50972: PUSH
50973: LD_INT 4
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: LD_INT 0
50982: PUSH
50983: LD_INT 4
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 0
50992: PUSH
50993: LD_INT 3
50995: PUSH
50996: EMPTY
50997: LIST
50998: LIST
50999: PUSH
51000: LD_INT 1
51002: PUSH
51003: LD_INT 4
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PUSH
51010: LD_INT 1
51012: PUSH
51013: LD_INT 5
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 0
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 1
51032: NEG
51033: PUSH
51034: LD_INT 4
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PUSH
51041: LD_INT 1
51043: NEG
51044: PUSH
51045: LD_INT 3
51047: PUSH
51048: EMPTY
51049: LIST
51050: LIST
51051: PUSH
51052: LD_INT 2
51054: PUSH
51055: LD_INT 5
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 2
51064: NEG
51065: PUSH
51066: LD_INT 3
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: LIST
51080: LIST
51081: LIST
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51120: LD_ADDR_VAR 0 34
51124: PUSH
51125: LD_INT 0
51127: PUSH
51128: LD_INT 4
51130: NEG
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 0
51138: PUSH
51139: LD_INT 5
51141: NEG
51142: PUSH
51143: EMPTY
51144: LIST
51145: LIST
51146: PUSH
51147: LD_INT 1
51149: PUSH
51150: LD_INT 4
51152: NEG
51153: PUSH
51154: EMPTY
51155: LIST
51156: LIST
51157: PUSH
51158: LD_INT 1
51160: PUSH
51161: LD_INT 3
51163: NEG
51164: PUSH
51165: EMPTY
51166: LIST
51167: LIST
51168: PUSH
51169: LD_INT 0
51171: PUSH
51172: LD_INT 3
51174: NEG
51175: PUSH
51176: EMPTY
51177: LIST
51178: LIST
51179: PUSH
51180: LD_INT 1
51182: NEG
51183: PUSH
51184: LD_INT 4
51186: NEG
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 1
51194: NEG
51195: PUSH
51196: LD_INT 5
51198: NEG
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: LD_INT 2
51206: PUSH
51207: LD_INT 3
51209: NEG
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PUSH
51215: LD_INT 2
51217: NEG
51218: PUSH
51219: LD_INT 5
51221: NEG
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: PUSH
51227: LD_INT 3
51229: PUSH
51230: LD_INT 0
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 1
51242: NEG
51243: PUSH
51244: EMPTY
51245: LIST
51246: LIST
51247: PUSH
51248: LD_INT 4
51250: PUSH
51251: LD_INT 0
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 4
51260: PUSH
51261: LD_INT 1
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 3
51270: PUSH
51271: LD_INT 1
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 2
51280: PUSH
51281: LD_INT 0
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: PUSH
51288: LD_INT 2
51290: PUSH
51291: LD_INT 1
51293: NEG
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: PUSH
51299: LD_INT 2
51301: PUSH
51302: LD_INT 2
51304: NEG
51305: PUSH
51306: EMPTY
51307: LIST
51308: LIST
51309: PUSH
51310: LD_INT 4
51312: PUSH
51313: LD_INT 2
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: PUSH
51320: LD_INT 4
51322: PUSH
51323: LD_INT 4
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: LD_INT 4
51332: PUSH
51333: LD_INT 3
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 5
51342: PUSH
51343: LD_INT 4
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 5
51352: PUSH
51353: LD_INT 5
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: LD_INT 4
51362: PUSH
51363: LD_INT 5
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: LD_INT 3
51372: PUSH
51373: LD_INT 4
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: PUSH
51383: LD_INT 3
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 5
51392: PUSH
51393: LD_INT 3
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 3
51402: PUSH
51403: LD_INT 5
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 0
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 0
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 1
51432: PUSH
51433: LD_INT 3
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: LD_INT 1
51442: PUSH
51443: LD_INT 4
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: PUSH
51450: LD_INT 0
51452: PUSH
51453: LD_INT 4
51455: PUSH
51456: EMPTY
51457: LIST
51458: LIST
51459: PUSH
51460: LD_INT 1
51462: NEG
51463: PUSH
51464: LD_INT 3
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: PUSH
51471: LD_INT 1
51473: NEG
51474: PUSH
51475: LD_INT 2
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: PUSH
51482: LD_INT 2
51484: PUSH
51485: LD_INT 4
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PUSH
51492: LD_INT 2
51494: NEG
51495: PUSH
51496: LD_INT 2
51498: PUSH
51499: EMPTY
51500: LIST
51501: LIST
51502: PUSH
51503: LD_INT 4
51505: NEG
51506: PUSH
51507: LD_INT 0
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: PUSH
51514: LD_INT 4
51516: NEG
51517: PUSH
51518: LD_INT 1
51520: NEG
51521: PUSH
51522: EMPTY
51523: LIST
51524: LIST
51525: PUSH
51526: LD_INT 3
51528: NEG
51529: PUSH
51530: LD_INT 0
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: PUSH
51537: LD_INT 3
51539: NEG
51540: PUSH
51541: LD_INT 1
51543: PUSH
51544: EMPTY
51545: LIST
51546: LIST
51547: PUSH
51548: LD_INT 4
51550: NEG
51551: PUSH
51552: LD_INT 1
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: PUSH
51559: LD_INT 5
51561: NEG
51562: PUSH
51563: LD_INT 0
51565: PUSH
51566: EMPTY
51567: LIST
51568: LIST
51569: PUSH
51570: LD_INT 5
51572: NEG
51573: PUSH
51574: LD_INT 1
51576: NEG
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PUSH
51582: LD_INT 5
51584: NEG
51585: PUSH
51586: LD_INT 2
51588: NEG
51589: PUSH
51590: EMPTY
51591: LIST
51592: LIST
51593: PUSH
51594: LD_INT 3
51596: NEG
51597: PUSH
51598: LD_INT 2
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: ST_TO_ADDR
// end ; end ;
51652: GO 51655
51654: POP
// case btype of b_depot , b_warehouse :
51655: LD_VAR 0 1
51659: PUSH
51660: LD_INT 0
51662: DOUBLE
51663: EQUAL
51664: IFTRUE 51674
51666: LD_INT 1
51668: DOUBLE
51669: EQUAL
51670: IFTRUE 51674
51672: GO 51875
51674: POP
// case nation of nation_american :
51675: LD_VAR 0 5
51679: PUSH
51680: LD_INT 1
51682: DOUBLE
51683: EQUAL
51684: IFTRUE 51688
51686: GO 51744
51688: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51689: LD_ADDR_VAR 0 9
51693: PUSH
51694: LD_VAR 0 11
51698: PUSH
51699: LD_VAR 0 12
51703: PUSH
51704: LD_VAR 0 13
51708: PUSH
51709: LD_VAR 0 14
51713: PUSH
51714: LD_VAR 0 15
51718: PUSH
51719: LD_VAR 0 16
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: LIST
51729: LIST
51730: LIST
51731: PUSH
51732: LD_VAR 0 4
51736: PUSH
51737: LD_INT 1
51739: PLUS
51740: ARRAY
51741: ST_TO_ADDR
51742: GO 51873
51744: LD_INT 2
51746: DOUBLE
51747: EQUAL
51748: IFTRUE 51752
51750: GO 51808
51752: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51753: LD_ADDR_VAR 0 9
51757: PUSH
51758: LD_VAR 0 17
51762: PUSH
51763: LD_VAR 0 18
51767: PUSH
51768: LD_VAR 0 19
51772: PUSH
51773: LD_VAR 0 20
51777: PUSH
51778: LD_VAR 0 21
51782: PUSH
51783: LD_VAR 0 22
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: PUSH
51796: LD_VAR 0 4
51800: PUSH
51801: LD_INT 1
51803: PLUS
51804: ARRAY
51805: ST_TO_ADDR
51806: GO 51873
51808: LD_INT 3
51810: DOUBLE
51811: EQUAL
51812: IFTRUE 51816
51814: GO 51872
51816: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51817: LD_ADDR_VAR 0 9
51821: PUSH
51822: LD_VAR 0 23
51826: PUSH
51827: LD_VAR 0 24
51831: PUSH
51832: LD_VAR 0 25
51836: PUSH
51837: LD_VAR 0 26
51841: PUSH
51842: LD_VAR 0 27
51846: PUSH
51847: LD_VAR 0 28
51851: PUSH
51852: EMPTY
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: PUSH
51860: LD_VAR 0 4
51864: PUSH
51865: LD_INT 1
51867: PLUS
51868: ARRAY
51869: ST_TO_ADDR
51870: GO 51873
51872: POP
51873: GO 52428
51875: LD_INT 2
51877: DOUBLE
51878: EQUAL
51879: IFTRUE 51889
51881: LD_INT 3
51883: DOUBLE
51884: EQUAL
51885: IFTRUE 51889
51887: GO 51945
51889: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51890: LD_ADDR_VAR 0 9
51894: PUSH
51895: LD_VAR 0 29
51899: PUSH
51900: LD_VAR 0 30
51904: PUSH
51905: LD_VAR 0 31
51909: PUSH
51910: LD_VAR 0 32
51914: PUSH
51915: LD_VAR 0 33
51919: PUSH
51920: LD_VAR 0 34
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: PUSH
51933: LD_VAR 0 4
51937: PUSH
51938: LD_INT 1
51940: PLUS
51941: ARRAY
51942: ST_TO_ADDR
51943: GO 52428
51945: LD_INT 16
51947: DOUBLE
51948: EQUAL
51949: IFTRUE 52007
51951: LD_INT 17
51953: DOUBLE
51954: EQUAL
51955: IFTRUE 52007
51957: LD_INT 18
51959: DOUBLE
51960: EQUAL
51961: IFTRUE 52007
51963: LD_INT 19
51965: DOUBLE
51966: EQUAL
51967: IFTRUE 52007
51969: LD_INT 22
51971: DOUBLE
51972: EQUAL
51973: IFTRUE 52007
51975: LD_INT 20
51977: DOUBLE
51978: EQUAL
51979: IFTRUE 52007
51981: LD_INT 21
51983: DOUBLE
51984: EQUAL
51985: IFTRUE 52007
51987: LD_INT 23
51989: DOUBLE
51990: EQUAL
51991: IFTRUE 52007
51993: LD_INT 24
51995: DOUBLE
51996: EQUAL
51997: IFTRUE 52007
51999: LD_INT 25
52001: DOUBLE
52002: EQUAL
52003: IFTRUE 52007
52005: GO 52063
52007: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52008: LD_ADDR_VAR 0 9
52012: PUSH
52013: LD_VAR 0 35
52017: PUSH
52018: LD_VAR 0 36
52022: PUSH
52023: LD_VAR 0 37
52027: PUSH
52028: LD_VAR 0 38
52032: PUSH
52033: LD_VAR 0 39
52037: PUSH
52038: LD_VAR 0 40
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: PUSH
52051: LD_VAR 0 4
52055: PUSH
52056: LD_INT 1
52058: PLUS
52059: ARRAY
52060: ST_TO_ADDR
52061: GO 52428
52063: LD_INT 6
52065: DOUBLE
52066: EQUAL
52067: IFTRUE 52119
52069: LD_INT 7
52071: DOUBLE
52072: EQUAL
52073: IFTRUE 52119
52075: LD_INT 8
52077: DOUBLE
52078: EQUAL
52079: IFTRUE 52119
52081: LD_INT 13
52083: DOUBLE
52084: EQUAL
52085: IFTRUE 52119
52087: LD_INT 12
52089: DOUBLE
52090: EQUAL
52091: IFTRUE 52119
52093: LD_INT 15
52095: DOUBLE
52096: EQUAL
52097: IFTRUE 52119
52099: LD_INT 11
52101: DOUBLE
52102: EQUAL
52103: IFTRUE 52119
52105: LD_INT 14
52107: DOUBLE
52108: EQUAL
52109: IFTRUE 52119
52111: LD_INT 10
52113: DOUBLE
52114: EQUAL
52115: IFTRUE 52119
52117: GO 52175
52119: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52120: LD_ADDR_VAR 0 9
52124: PUSH
52125: LD_VAR 0 41
52129: PUSH
52130: LD_VAR 0 42
52134: PUSH
52135: LD_VAR 0 43
52139: PUSH
52140: LD_VAR 0 44
52144: PUSH
52145: LD_VAR 0 45
52149: PUSH
52150: LD_VAR 0 46
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: LIST
52160: LIST
52161: LIST
52162: PUSH
52163: LD_VAR 0 4
52167: PUSH
52168: LD_INT 1
52170: PLUS
52171: ARRAY
52172: ST_TO_ADDR
52173: GO 52428
52175: LD_INT 36
52177: DOUBLE
52178: EQUAL
52179: IFTRUE 52183
52181: GO 52239
52183: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52184: LD_ADDR_VAR 0 9
52188: PUSH
52189: LD_VAR 0 47
52193: PUSH
52194: LD_VAR 0 48
52198: PUSH
52199: LD_VAR 0 49
52203: PUSH
52204: LD_VAR 0 50
52208: PUSH
52209: LD_VAR 0 51
52213: PUSH
52214: LD_VAR 0 52
52218: PUSH
52219: EMPTY
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: PUSH
52227: LD_VAR 0 4
52231: PUSH
52232: LD_INT 1
52234: PLUS
52235: ARRAY
52236: ST_TO_ADDR
52237: GO 52428
52239: LD_INT 4
52241: DOUBLE
52242: EQUAL
52243: IFTRUE 52265
52245: LD_INT 5
52247: DOUBLE
52248: EQUAL
52249: IFTRUE 52265
52251: LD_INT 34
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52265
52257: LD_INT 37
52259: DOUBLE
52260: EQUAL
52261: IFTRUE 52265
52263: GO 52321
52265: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52266: LD_ADDR_VAR 0 9
52270: PUSH
52271: LD_VAR 0 53
52275: PUSH
52276: LD_VAR 0 54
52280: PUSH
52281: LD_VAR 0 55
52285: PUSH
52286: LD_VAR 0 56
52290: PUSH
52291: LD_VAR 0 57
52295: PUSH
52296: LD_VAR 0 58
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: PUSH
52309: LD_VAR 0 4
52313: PUSH
52314: LD_INT 1
52316: PLUS
52317: ARRAY
52318: ST_TO_ADDR
52319: GO 52428
52321: LD_INT 31
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52371
52327: LD_INT 32
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52371
52333: LD_INT 33
52335: DOUBLE
52336: EQUAL
52337: IFTRUE 52371
52339: LD_INT 27
52341: DOUBLE
52342: EQUAL
52343: IFTRUE 52371
52345: LD_INT 26
52347: DOUBLE
52348: EQUAL
52349: IFTRUE 52371
52351: LD_INT 28
52353: DOUBLE
52354: EQUAL
52355: IFTRUE 52371
52357: LD_INT 29
52359: DOUBLE
52360: EQUAL
52361: IFTRUE 52371
52363: LD_INT 30
52365: DOUBLE
52366: EQUAL
52367: IFTRUE 52371
52369: GO 52427
52371: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52372: LD_ADDR_VAR 0 9
52376: PUSH
52377: LD_VAR 0 59
52381: PUSH
52382: LD_VAR 0 60
52386: PUSH
52387: LD_VAR 0 61
52391: PUSH
52392: LD_VAR 0 62
52396: PUSH
52397: LD_VAR 0 63
52401: PUSH
52402: LD_VAR 0 64
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: PUSH
52415: LD_VAR 0 4
52419: PUSH
52420: LD_INT 1
52422: PLUS
52423: ARRAY
52424: ST_TO_ADDR
52425: GO 52428
52427: POP
// temp_list2 = [ ] ;
52428: LD_ADDR_VAR 0 10
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// for i in temp_list do
52435: LD_ADDR_VAR 0 8
52439: PUSH
52440: LD_VAR 0 9
52444: PUSH
52445: FOR_IN
52446: IFFALSE 52498
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52448: LD_ADDR_VAR 0 10
52452: PUSH
52453: LD_VAR 0 10
52457: PUSH
52458: LD_VAR 0 8
52462: PUSH
52463: LD_INT 1
52465: ARRAY
52466: PUSH
52467: LD_VAR 0 2
52471: PLUS
52472: PUSH
52473: LD_VAR 0 8
52477: PUSH
52478: LD_INT 2
52480: ARRAY
52481: PUSH
52482: LD_VAR 0 3
52486: PLUS
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: EMPTY
52493: LIST
52494: ADD
52495: ST_TO_ADDR
52496: GO 52445
52498: POP
52499: POP
// result = temp_list2 ;
52500: LD_ADDR_VAR 0 7
52504: PUSH
52505: LD_VAR 0 10
52509: ST_TO_ADDR
// end ;
52510: LD_VAR 0 7
52514: RET
// export function EnemyInRange ( unit , dist ) ; begin
52515: LD_INT 0
52517: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52518: LD_ADDR_VAR 0 3
52522: PUSH
52523: LD_VAR 0 1
52527: PPUSH
52528: CALL_OW 255
52532: PPUSH
52533: LD_VAR 0 1
52537: PPUSH
52538: CALL_OW 250
52542: PPUSH
52543: LD_VAR 0 1
52547: PPUSH
52548: CALL_OW 251
52552: PPUSH
52553: LD_VAR 0 2
52557: PPUSH
52558: CALL 25917 0 4
52562: PUSH
52563: LD_INT 4
52565: ARRAY
52566: ST_TO_ADDR
// end ;
52567: LD_VAR 0 3
52571: RET
// export function PlayerSeeMe ( unit ) ; begin
52572: LD_INT 0
52574: PPUSH
// result := See ( your_side , unit ) ;
52575: LD_ADDR_VAR 0 2
52579: PUSH
52580: LD_OWVAR 2
52584: PPUSH
52585: LD_VAR 0 1
52589: PPUSH
52590: CALL_OW 292
52594: ST_TO_ADDR
// end ;
52595: LD_VAR 0 2
52599: RET
// export function ReverseDir ( unit ) ; begin
52600: LD_INT 0
52602: PPUSH
// if not unit then
52603: LD_VAR 0 1
52607: NOT
52608: IFFALSE 52612
// exit ;
52610: GO 52635
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52612: LD_ADDR_VAR 0 2
52616: PUSH
52617: LD_VAR 0 1
52621: PPUSH
52622: CALL_OW 254
52626: PUSH
52627: LD_INT 3
52629: PLUS
52630: PUSH
52631: LD_INT 6
52633: MOD
52634: ST_TO_ADDR
// end ;
52635: LD_VAR 0 2
52639: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52640: LD_INT 0
52642: PPUSH
52643: PPUSH
52644: PPUSH
52645: PPUSH
52646: PPUSH
52647: PPUSH
// if not unit or not hexes then
52648: LD_VAR 0 1
52652: NOT
52653: PUSH
52654: LD_VAR 0 2
52658: NOT
52659: OR
52660: IFFALSE 52664
// exit ;
52662: GO 52787
// dist := 9999 ;
52664: LD_ADDR_VAR 0 5
52668: PUSH
52669: LD_INT 9999
52671: ST_TO_ADDR
// for i = 1 to hexes do
52672: LD_ADDR_VAR 0 4
52676: PUSH
52677: DOUBLE
52678: LD_INT 1
52680: DEC
52681: ST_TO_ADDR
52682: LD_VAR 0 2
52686: PUSH
52687: FOR_TO
52688: IFFALSE 52775
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52690: LD_ADDR_VAR 0 6
52694: PUSH
52695: LD_VAR 0 1
52699: PPUSH
52700: LD_VAR 0 2
52704: PUSH
52705: LD_VAR 0 4
52709: ARRAY
52710: PUSH
52711: LD_INT 1
52713: ARRAY
52714: PPUSH
52715: LD_VAR 0 2
52719: PUSH
52720: LD_VAR 0 4
52724: ARRAY
52725: PUSH
52726: LD_INT 2
52728: ARRAY
52729: PPUSH
52730: CALL_OW 297
52734: ST_TO_ADDR
// if tdist < dist then
52735: LD_VAR 0 6
52739: PUSH
52740: LD_VAR 0 5
52744: LESS
52745: IFFALSE 52773
// begin hex := hexes [ i ] ;
52747: LD_ADDR_VAR 0 8
52751: PUSH
52752: LD_VAR 0 2
52756: PUSH
52757: LD_VAR 0 4
52761: ARRAY
52762: ST_TO_ADDR
// dist := tdist ;
52763: LD_ADDR_VAR 0 5
52767: PUSH
52768: LD_VAR 0 6
52772: ST_TO_ADDR
// end ; end ;
52773: GO 52687
52775: POP
52776: POP
// result := hex ;
52777: LD_ADDR_VAR 0 3
52781: PUSH
52782: LD_VAR 0 8
52786: ST_TO_ADDR
// end ;
52787: LD_VAR 0 3
52791: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52792: LD_INT 0
52794: PPUSH
52795: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52796: LD_VAR 0 1
52800: NOT
52801: PUSH
52802: LD_VAR 0 1
52806: PUSH
52807: LD_INT 21
52809: PUSH
52810: LD_INT 2
52812: PUSH
52813: EMPTY
52814: LIST
52815: LIST
52816: PUSH
52817: LD_INT 23
52819: PUSH
52820: LD_INT 2
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PUSH
52827: EMPTY
52828: LIST
52829: LIST
52830: PPUSH
52831: CALL_OW 69
52835: IN
52836: NOT
52837: OR
52838: IFFALSE 52842
// exit ;
52840: GO 52889
// for i = 1 to 3 do
52842: LD_ADDR_VAR 0 3
52846: PUSH
52847: DOUBLE
52848: LD_INT 1
52850: DEC
52851: ST_TO_ADDR
52852: LD_INT 3
52854: PUSH
52855: FOR_TO
52856: IFFALSE 52887
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52858: LD_VAR 0 1
52862: PPUSH
52863: CALL_OW 250
52867: PPUSH
52868: LD_VAR 0 1
52872: PPUSH
52873: CALL_OW 251
52877: PPUSH
52878: LD_INT 1
52880: PPUSH
52881: CALL_OW 453
52885: GO 52855
52887: POP
52888: POP
// end ;
52889: LD_VAR 0 2
52893: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52894: LD_INT 0
52896: PPUSH
52897: PPUSH
52898: PPUSH
52899: PPUSH
52900: PPUSH
52901: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52902: LD_VAR 0 1
52906: NOT
52907: PUSH
52908: LD_VAR 0 2
52912: NOT
52913: OR
52914: PUSH
52915: LD_VAR 0 1
52919: PPUSH
52920: CALL_OW 314
52924: OR
52925: IFFALSE 52929
// exit ;
52927: GO 53370
// x := GetX ( enemy_unit ) ;
52929: LD_ADDR_VAR 0 7
52933: PUSH
52934: LD_VAR 0 2
52938: PPUSH
52939: CALL_OW 250
52943: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52944: LD_ADDR_VAR 0 8
52948: PUSH
52949: LD_VAR 0 2
52953: PPUSH
52954: CALL_OW 251
52958: ST_TO_ADDR
// if not x or not y then
52959: LD_VAR 0 7
52963: NOT
52964: PUSH
52965: LD_VAR 0 8
52969: NOT
52970: OR
52971: IFFALSE 52975
// exit ;
52973: GO 53370
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52975: LD_ADDR_VAR 0 6
52979: PUSH
52980: LD_VAR 0 7
52984: PPUSH
52985: LD_INT 0
52987: PPUSH
52988: LD_INT 4
52990: PPUSH
52991: CALL_OW 272
52995: PUSH
52996: LD_VAR 0 8
53000: PPUSH
53001: LD_INT 0
53003: PPUSH
53004: LD_INT 4
53006: PPUSH
53007: CALL_OW 273
53011: PUSH
53012: EMPTY
53013: LIST
53014: LIST
53015: PUSH
53016: LD_VAR 0 7
53020: PPUSH
53021: LD_INT 1
53023: PPUSH
53024: LD_INT 4
53026: PPUSH
53027: CALL_OW 272
53031: PUSH
53032: LD_VAR 0 8
53036: PPUSH
53037: LD_INT 1
53039: PPUSH
53040: LD_INT 4
53042: PPUSH
53043: CALL_OW 273
53047: PUSH
53048: EMPTY
53049: LIST
53050: LIST
53051: PUSH
53052: LD_VAR 0 7
53056: PPUSH
53057: LD_INT 2
53059: PPUSH
53060: LD_INT 4
53062: PPUSH
53063: CALL_OW 272
53067: PUSH
53068: LD_VAR 0 8
53072: PPUSH
53073: LD_INT 2
53075: PPUSH
53076: LD_INT 4
53078: PPUSH
53079: CALL_OW 273
53083: PUSH
53084: EMPTY
53085: LIST
53086: LIST
53087: PUSH
53088: LD_VAR 0 7
53092: PPUSH
53093: LD_INT 3
53095: PPUSH
53096: LD_INT 4
53098: PPUSH
53099: CALL_OW 272
53103: PUSH
53104: LD_VAR 0 8
53108: PPUSH
53109: LD_INT 3
53111: PPUSH
53112: LD_INT 4
53114: PPUSH
53115: CALL_OW 273
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: PUSH
53124: LD_VAR 0 7
53128: PPUSH
53129: LD_INT 4
53131: PPUSH
53132: LD_INT 4
53134: PPUSH
53135: CALL_OW 272
53139: PUSH
53140: LD_VAR 0 8
53144: PPUSH
53145: LD_INT 4
53147: PPUSH
53148: LD_INT 4
53150: PPUSH
53151: CALL_OW 273
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PUSH
53160: LD_VAR 0 7
53164: PPUSH
53165: LD_INT 5
53167: PPUSH
53168: LD_INT 4
53170: PPUSH
53171: CALL_OW 272
53175: PUSH
53176: LD_VAR 0 8
53180: PPUSH
53181: LD_INT 5
53183: PPUSH
53184: LD_INT 4
53186: PPUSH
53187: CALL_OW 273
53191: PUSH
53192: EMPTY
53193: LIST
53194: LIST
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: LIST
53200: LIST
53201: LIST
53202: LIST
53203: ST_TO_ADDR
// for i = tmp downto 1 do
53204: LD_ADDR_VAR 0 4
53208: PUSH
53209: DOUBLE
53210: LD_VAR 0 6
53214: INC
53215: ST_TO_ADDR
53216: LD_INT 1
53218: PUSH
53219: FOR_DOWNTO
53220: IFFALSE 53321
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53222: LD_VAR 0 6
53226: PUSH
53227: LD_VAR 0 4
53231: ARRAY
53232: PUSH
53233: LD_INT 1
53235: ARRAY
53236: PPUSH
53237: LD_VAR 0 6
53241: PUSH
53242: LD_VAR 0 4
53246: ARRAY
53247: PUSH
53248: LD_INT 2
53250: ARRAY
53251: PPUSH
53252: CALL_OW 488
53256: NOT
53257: PUSH
53258: LD_VAR 0 6
53262: PUSH
53263: LD_VAR 0 4
53267: ARRAY
53268: PUSH
53269: LD_INT 1
53271: ARRAY
53272: PPUSH
53273: LD_VAR 0 6
53277: PUSH
53278: LD_VAR 0 4
53282: ARRAY
53283: PUSH
53284: LD_INT 2
53286: ARRAY
53287: PPUSH
53288: CALL_OW 428
53292: PUSH
53293: LD_INT 0
53295: NONEQUAL
53296: OR
53297: IFFALSE 53319
// tmp := Delete ( tmp , i ) ;
53299: LD_ADDR_VAR 0 6
53303: PUSH
53304: LD_VAR 0 6
53308: PPUSH
53309: LD_VAR 0 4
53313: PPUSH
53314: CALL_OW 3
53318: ST_TO_ADDR
53319: GO 53219
53321: POP
53322: POP
// j := GetClosestHex ( unit , tmp ) ;
53323: LD_ADDR_VAR 0 5
53327: PUSH
53328: LD_VAR 0 1
53332: PPUSH
53333: LD_VAR 0 6
53337: PPUSH
53338: CALL 52640 0 2
53342: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53343: LD_VAR 0 1
53347: PPUSH
53348: LD_VAR 0 5
53352: PUSH
53353: LD_INT 1
53355: ARRAY
53356: PPUSH
53357: LD_VAR 0 5
53361: PUSH
53362: LD_INT 2
53364: ARRAY
53365: PPUSH
53366: CALL_OW 111
// end ;
53370: LD_VAR 0 3
53374: RET
// export function PrepareApemanSoldier ( ) ; begin
53375: LD_INT 0
53377: PPUSH
// uc_nation := 0 ;
53378: LD_ADDR_OWVAR 21
53382: PUSH
53383: LD_INT 0
53385: ST_TO_ADDR
// hc_sex := sex_male ;
53386: LD_ADDR_OWVAR 27
53390: PUSH
53391: LD_INT 1
53393: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53394: LD_ADDR_OWVAR 28
53398: PUSH
53399: LD_INT 15
53401: ST_TO_ADDR
// hc_gallery :=  ;
53402: LD_ADDR_OWVAR 33
53406: PUSH
53407: LD_STRING 
53409: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53410: LD_ADDR_OWVAR 31
53414: PUSH
53415: LD_INT 0
53417: PPUSH
53418: LD_INT 3
53420: PPUSH
53421: CALL_OW 12
53425: PUSH
53426: LD_INT 0
53428: PPUSH
53429: LD_INT 3
53431: PPUSH
53432: CALL_OW 12
53436: PUSH
53437: LD_INT 0
53439: PUSH
53440: LD_INT 0
53442: PUSH
53443: EMPTY
53444: LIST
53445: LIST
53446: LIST
53447: LIST
53448: ST_TO_ADDR
// end ;
53449: LD_VAR 0 1
53453: RET
// export function PrepareApemanEngineer ( ) ; begin
53454: LD_INT 0
53456: PPUSH
// uc_nation := 0 ;
53457: LD_ADDR_OWVAR 21
53461: PUSH
53462: LD_INT 0
53464: ST_TO_ADDR
// hc_sex := sex_male ;
53465: LD_ADDR_OWVAR 27
53469: PUSH
53470: LD_INT 1
53472: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53473: LD_ADDR_OWVAR 28
53477: PUSH
53478: LD_INT 16
53480: ST_TO_ADDR
// hc_gallery :=  ;
53481: LD_ADDR_OWVAR 33
53485: PUSH
53486: LD_STRING 
53488: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53489: LD_ADDR_OWVAR 31
53493: PUSH
53494: LD_INT 0
53496: PPUSH
53497: LD_INT 3
53499: PPUSH
53500: CALL_OW 12
53504: PUSH
53505: LD_INT 0
53507: PPUSH
53508: LD_INT 3
53510: PPUSH
53511: CALL_OW 12
53515: PUSH
53516: LD_INT 0
53518: PUSH
53519: LD_INT 0
53521: PUSH
53522: EMPTY
53523: LIST
53524: LIST
53525: LIST
53526: LIST
53527: ST_TO_ADDR
// end ;
53528: LD_VAR 0 1
53532: RET
// export function PrepareApeman ( agressivity ) ; begin
53533: LD_INT 0
53535: PPUSH
// uc_side := 0 ;
53536: LD_ADDR_OWVAR 20
53540: PUSH
53541: LD_INT 0
53543: ST_TO_ADDR
// uc_nation := 0 ;
53544: LD_ADDR_OWVAR 21
53548: PUSH
53549: LD_INT 0
53551: ST_TO_ADDR
// hc_sex := sex_male ;
53552: LD_ADDR_OWVAR 27
53556: PUSH
53557: LD_INT 1
53559: ST_TO_ADDR
// hc_class := class_apeman ;
53560: LD_ADDR_OWVAR 28
53564: PUSH
53565: LD_INT 12
53567: ST_TO_ADDR
// hc_gallery :=  ;
53568: LD_ADDR_OWVAR 33
53572: PUSH
53573: LD_STRING 
53575: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53576: LD_ADDR_OWVAR 35
53580: PUSH
53581: LD_VAR 0 1
53585: NEG
53586: PPUSH
53587: LD_VAR 0 1
53591: PPUSH
53592: CALL_OW 12
53596: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53597: LD_ADDR_OWVAR 31
53601: PUSH
53602: LD_INT 0
53604: PPUSH
53605: LD_INT 3
53607: PPUSH
53608: CALL_OW 12
53612: PUSH
53613: LD_INT 0
53615: PPUSH
53616: LD_INT 3
53618: PPUSH
53619: CALL_OW 12
53623: PUSH
53624: LD_INT 0
53626: PUSH
53627: LD_INT 0
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: LIST
53634: LIST
53635: ST_TO_ADDR
// end ;
53636: LD_VAR 0 2
53640: RET
// export function PrepareTiger ( agressivity ) ; begin
53641: LD_INT 0
53643: PPUSH
// uc_side := 0 ;
53644: LD_ADDR_OWVAR 20
53648: PUSH
53649: LD_INT 0
53651: ST_TO_ADDR
// uc_nation := 0 ;
53652: LD_ADDR_OWVAR 21
53656: PUSH
53657: LD_INT 0
53659: ST_TO_ADDR
// hc_class := class_tiger ;
53660: LD_ADDR_OWVAR 28
53664: PUSH
53665: LD_INT 14
53667: ST_TO_ADDR
// hc_gallery :=  ;
53668: LD_ADDR_OWVAR 33
53672: PUSH
53673: LD_STRING 
53675: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53676: LD_ADDR_OWVAR 35
53680: PUSH
53681: LD_VAR 0 1
53685: NEG
53686: PPUSH
53687: LD_VAR 0 1
53691: PPUSH
53692: CALL_OW 12
53696: ST_TO_ADDR
// end ;
53697: LD_VAR 0 2
53701: RET
// export function PrepareEnchidna ( ) ; begin
53702: LD_INT 0
53704: PPUSH
// uc_side := 0 ;
53705: LD_ADDR_OWVAR 20
53709: PUSH
53710: LD_INT 0
53712: ST_TO_ADDR
// uc_nation := 0 ;
53713: LD_ADDR_OWVAR 21
53717: PUSH
53718: LD_INT 0
53720: ST_TO_ADDR
// hc_class := class_baggie ;
53721: LD_ADDR_OWVAR 28
53725: PUSH
53726: LD_INT 13
53728: ST_TO_ADDR
// hc_gallery :=  ;
53729: LD_ADDR_OWVAR 33
53733: PUSH
53734: LD_STRING 
53736: ST_TO_ADDR
// end ;
53737: LD_VAR 0 1
53741: RET
// export function PrepareFrog ( ) ; begin
53742: LD_INT 0
53744: PPUSH
// uc_side := 0 ;
53745: LD_ADDR_OWVAR 20
53749: PUSH
53750: LD_INT 0
53752: ST_TO_ADDR
// uc_nation := 0 ;
53753: LD_ADDR_OWVAR 21
53757: PUSH
53758: LD_INT 0
53760: ST_TO_ADDR
// hc_class := class_frog ;
53761: LD_ADDR_OWVAR 28
53765: PUSH
53766: LD_INT 19
53768: ST_TO_ADDR
// hc_gallery :=  ;
53769: LD_ADDR_OWVAR 33
53773: PUSH
53774: LD_STRING 
53776: ST_TO_ADDR
// end ;
53777: LD_VAR 0 1
53781: RET
// export function PrepareFish ( ) ; begin
53782: LD_INT 0
53784: PPUSH
// uc_side := 0 ;
53785: LD_ADDR_OWVAR 20
53789: PUSH
53790: LD_INT 0
53792: ST_TO_ADDR
// uc_nation := 0 ;
53793: LD_ADDR_OWVAR 21
53797: PUSH
53798: LD_INT 0
53800: ST_TO_ADDR
// hc_class := class_fish ;
53801: LD_ADDR_OWVAR 28
53805: PUSH
53806: LD_INT 20
53808: ST_TO_ADDR
// hc_gallery :=  ;
53809: LD_ADDR_OWVAR 33
53813: PUSH
53814: LD_STRING 
53816: ST_TO_ADDR
// end ;
53817: LD_VAR 0 1
53821: RET
// export function PrepareBird ( ) ; begin
53822: LD_INT 0
53824: PPUSH
// uc_side := 0 ;
53825: LD_ADDR_OWVAR 20
53829: PUSH
53830: LD_INT 0
53832: ST_TO_ADDR
// uc_nation := 0 ;
53833: LD_ADDR_OWVAR 21
53837: PUSH
53838: LD_INT 0
53840: ST_TO_ADDR
// hc_class := class_phororhacos ;
53841: LD_ADDR_OWVAR 28
53845: PUSH
53846: LD_INT 18
53848: ST_TO_ADDR
// hc_gallery :=  ;
53849: LD_ADDR_OWVAR 33
53853: PUSH
53854: LD_STRING 
53856: ST_TO_ADDR
// end ;
53857: LD_VAR 0 1
53861: RET
// export function PrepareHorse ( ) ; begin
53862: LD_INT 0
53864: PPUSH
// uc_side := 0 ;
53865: LD_ADDR_OWVAR 20
53869: PUSH
53870: LD_INT 0
53872: ST_TO_ADDR
// uc_nation := 0 ;
53873: LD_ADDR_OWVAR 21
53877: PUSH
53878: LD_INT 0
53880: ST_TO_ADDR
// hc_class := class_horse ;
53881: LD_ADDR_OWVAR 28
53885: PUSH
53886: LD_INT 21
53888: ST_TO_ADDR
// hc_gallery :=  ;
53889: LD_ADDR_OWVAR 33
53893: PUSH
53894: LD_STRING 
53896: ST_TO_ADDR
// end ;
53897: LD_VAR 0 1
53901: RET
// export function PrepareMastodont ( ) ; begin
53902: LD_INT 0
53904: PPUSH
// uc_side := 0 ;
53905: LD_ADDR_OWVAR 20
53909: PUSH
53910: LD_INT 0
53912: ST_TO_ADDR
// uc_nation := 0 ;
53913: LD_ADDR_OWVAR 21
53917: PUSH
53918: LD_INT 0
53920: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53921: LD_ADDR_OWVAR 37
53925: PUSH
53926: LD_INT 31
53928: ST_TO_ADDR
// vc_control := control_rider ;
53929: LD_ADDR_OWVAR 38
53933: PUSH
53934: LD_INT 4
53936: ST_TO_ADDR
// end ;
53937: LD_VAR 0 1
53941: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53942: LD_INT 0
53944: PPUSH
53945: PPUSH
53946: PPUSH
// uc_side = 0 ;
53947: LD_ADDR_OWVAR 20
53951: PUSH
53952: LD_INT 0
53954: ST_TO_ADDR
// uc_nation = 0 ;
53955: LD_ADDR_OWVAR 21
53959: PUSH
53960: LD_INT 0
53962: ST_TO_ADDR
// InitHc_All ( ) ;
53963: CALL_OW 584
// InitVc ;
53967: CALL_OW 20
// if mastodonts then
53971: LD_VAR 0 6
53975: IFFALSE 54042
// for i = 1 to mastodonts do
53977: LD_ADDR_VAR 0 11
53981: PUSH
53982: DOUBLE
53983: LD_INT 1
53985: DEC
53986: ST_TO_ADDR
53987: LD_VAR 0 6
53991: PUSH
53992: FOR_TO
53993: IFFALSE 54040
// begin vc_chassis := 31 ;
53995: LD_ADDR_OWVAR 37
53999: PUSH
54000: LD_INT 31
54002: ST_TO_ADDR
// vc_control := control_rider ;
54003: LD_ADDR_OWVAR 38
54007: PUSH
54008: LD_INT 4
54010: ST_TO_ADDR
// animal := CreateVehicle ;
54011: LD_ADDR_VAR 0 12
54015: PUSH
54016: CALL_OW 45
54020: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54021: LD_VAR 0 12
54025: PPUSH
54026: LD_VAR 0 8
54030: PPUSH
54031: LD_INT 0
54033: PPUSH
54034: CALL 56177 0 3
// end ;
54038: GO 53992
54040: POP
54041: POP
// if horses then
54042: LD_VAR 0 5
54046: IFFALSE 54113
// for i = 1 to horses do
54048: LD_ADDR_VAR 0 11
54052: PUSH
54053: DOUBLE
54054: LD_INT 1
54056: DEC
54057: ST_TO_ADDR
54058: LD_VAR 0 5
54062: PUSH
54063: FOR_TO
54064: IFFALSE 54111
// begin hc_class := 21 ;
54066: LD_ADDR_OWVAR 28
54070: PUSH
54071: LD_INT 21
54073: ST_TO_ADDR
// hc_gallery :=  ;
54074: LD_ADDR_OWVAR 33
54078: PUSH
54079: LD_STRING 
54081: ST_TO_ADDR
// animal := CreateHuman ;
54082: LD_ADDR_VAR 0 12
54086: PUSH
54087: CALL_OW 44
54091: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54092: LD_VAR 0 12
54096: PPUSH
54097: LD_VAR 0 8
54101: PPUSH
54102: LD_INT 0
54104: PPUSH
54105: CALL 56177 0 3
// end ;
54109: GO 54063
54111: POP
54112: POP
// if birds then
54113: LD_VAR 0 1
54117: IFFALSE 54184
// for i = 1 to birds do
54119: LD_ADDR_VAR 0 11
54123: PUSH
54124: DOUBLE
54125: LD_INT 1
54127: DEC
54128: ST_TO_ADDR
54129: LD_VAR 0 1
54133: PUSH
54134: FOR_TO
54135: IFFALSE 54182
// begin hc_class = 18 ;
54137: LD_ADDR_OWVAR 28
54141: PUSH
54142: LD_INT 18
54144: ST_TO_ADDR
// hc_gallery =  ;
54145: LD_ADDR_OWVAR 33
54149: PUSH
54150: LD_STRING 
54152: ST_TO_ADDR
// animal := CreateHuman ;
54153: LD_ADDR_VAR 0 12
54157: PUSH
54158: CALL_OW 44
54162: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54163: LD_VAR 0 12
54167: PPUSH
54168: LD_VAR 0 8
54172: PPUSH
54173: LD_INT 0
54175: PPUSH
54176: CALL 56177 0 3
// end ;
54180: GO 54134
54182: POP
54183: POP
// if tigers then
54184: LD_VAR 0 2
54188: IFFALSE 54272
// for i = 1 to tigers do
54190: LD_ADDR_VAR 0 11
54194: PUSH
54195: DOUBLE
54196: LD_INT 1
54198: DEC
54199: ST_TO_ADDR
54200: LD_VAR 0 2
54204: PUSH
54205: FOR_TO
54206: IFFALSE 54270
// begin hc_class = class_tiger ;
54208: LD_ADDR_OWVAR 28
54212: PUSH
54213: LD_INT 14
54215: ST_TO_ADDR
// hc_gallery =  ;
54216: LD_ADDR_OWVAR 33
54220: PUSH
54221: LD_STRING 
54223: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54224: LD_ADDR_OWVAR 35
54228: PUSH
54229: LD_INT 7
54231: NEG
54232: PPUSH
54233: LD_INT 7
54235: PPUSH
54236: CALL_OW 12
54240: ST_TO_ADDR
// animal := CreateHuman ;
54241: LD_ADDR_VAR 0 12
54245: PUSH
54246: CALL_OW 44
54250: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54251: LD_VAR 0 12
54255: PPUSH
54256: LD_VAR 0 8
54260: PPUSH
54261: LD_INT 0
54263: PPUSH
54264: CALL 56177 0 3
// end ;
54268: GO 54205
54270: POP
54271: POP
// if apemans then
54272: LD_VAR 0 3
54276: IFFALSE 54399
// for i = 1 to apemans do
54278: LD_ADDR_VAR 0 11
54282: PUSH
54283: DOUBLE
54284: LD_INT 1
54286: DEC
54287: ST_TO_ADDR
54288: LD_VAR 0 3
54292: PUSH
54293: FOR_TO
54294: IFFALSE 54397
// begin hc_class = class_apeman ;
54296: LD_ADDR_OWVAR 28
54300: PUSH
54301: LD_INT 12
54303: ST_TO_ADDR
// hc_gallery =  ;
54304: LD_ADDR_OWVAR 33
54308: PUSH
54309: LD_STRING 
54311: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54312: LD_ADDR_OWVAR 35
54316: PUSH
54317: LD_INT 2
54319: NEG
54320: PPUSH
54321: LD_INT 2
54323: PPUSH
54324: CALL_OW 12
54328: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54329: LD_ADDR_OWVAR 31
54333: PUSH
54334: LD_INT 1
54336: PPUSH
54337: LD_INT 3
54339: PPUSH
54340: CALL_OW 12
54344: PUSH
54345: LD_INT 1
54347: PPUSH
54348: LD_INT 3
54350: PPUSH
54351: CALL_OW 12
54355: PUSH
54356: LD_INT 0
54358: PUSH
54359: LD_INT 0
54361: PUSH
54362: EMPTY
54363: LIST
54364: LIST
54365: LIST
54366: LIST
54367: ST_TO_ADDR
// animal := CreateHuman ;
54368: LD_ADDR_VAR 0 12
54372: PUSH
54373: CALL_OW 44
54377: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54378: LD_VAR 0 12
54382: PPUSH
54383: LD_VAR 0 8
54387: PPUSH
54388: LD_INT 0
54390: PPUSH
54391: CALL 56177 0 3
// end ;
54395: GO 54293
54397: POP
54398: POP
// if enchidnas then
54399: LD_VAR 0 4
54403: IFFALSE 54470
// for i = 1 to enchidnas do
54405: LD_ADDR_VAR 0 11
54409: PUSH
54410: DOUBLE
54411: LD_INT 1
54413: DEC
54414: ST_TO_ADDR
54415: LD_VAR 0 4
54419: PUSH
54420: FOR_TO
54421: IFFALSE 54468
// begin hc_class = 13 ;
54423: LD_ADDR_OWVAR 28
54427: PUSH
54428: LD_INT 13
54430: ST_TO_ADDR
// hc_gallery =  ;
54431: LD_ADDR_OWVAR 33
54435: PUSH
54436: LD_STRING 
54438: ST_TO_ADDR
// animal := CreateHuman ;
54439: LD_ADDR_VAR 0 12
54443: PUSH
54444: CALL_OW 44
54448: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54449: LD_VAR 0 12
54453: PPUSH
54454: LD_VAR 0 8
54458: PPUSH
54459: LD_INT 0
54461: PPUSH
54462: CALL 56177 0 3
// end ;
54466: GO 54420
54468: POP
54469: POP
// if fishes then
54470: LD_VAR 0 7
54474: IFFALSE 54541
// for i = 1 to fishes do
54476: LD_ADDR_VAR 0 11
54480: PUSH
54481: DOUBLE
54482: LD_INT 1
54484: DEC
54485: ST_TO_ADDR
54486: LD_VAR 0 7
54490: PUSH
54491: FOR_TO
54492: IFFALSE 54539
// begin hc_class = 20 ;
54494: LD_ADDR_OWVAR 28
54498: PUSH
54499: LD_INT 20
54501: ST_TO_ADDR
// hc_gallery =  ;
54502: LD_ADDR_OWVAR 33
54506: PUSH
54507: LD_STRING 
54509: ST_TO_ADDR
// animal := CreateHuman ;
54510: LD_ADDR_VAR 0 12
54514: PUSH
54515: CALL_OW 44
54519: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54520: LD_VAR 0 12
54524: PPUSH
54525: LD_VAR 0 9
54529: PPUSH
54530: LD_INT 0
54532: PPUSH
54533: CALL 56177 0 3
// end ;
54537: GO 54491
54539: POP
54540: POP
// end ;
54541: LD_VAR 0 10
54545: RET
// export function WantHeal ( sci , unit ) ; begin
54546: LD_INT 0
54548: PPUSH
// if GetTaskList ( sci ) > 0 then
54549: LD_VAR 0 1
54553: PPUSH
54554: CALL_OW 437
54558: PUSH
54559: LD_INT 0
54561: GREATER
54562: IFFALSE 54632
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54564: LD_VAR 0 1
54568: PPUSH
54569: CALL_OW 437
54573: PUSH
54574: LD_INT 1
54576: ARRAY
54577: PUSH
54578: LD_INT 1
54580: ARRAY
54581: PUSH
54582: LD_STRING l
54584: EQUAL
54585: PUSH
54586: LD_VAR 0 1
54590: PPUSH
54591: CALL_OW 437
54595: PUSH
54596: LD_INT 1
54598: ARRAY
54599: PUSH
54600: LD_INT 4
54602: ARRAY
54603: PUSH
54604: LD_VAR 0 2
54608: EQUAL
54609: AND
54610: IFFALSE 54622
// result := true else
54612: LD_ADDR_VAR 0 3
54616: PUSH
54617: LD_INT 1
54619: ST_TO_ADDR
54620: GO 54630
// result := false ;
54622: LD_ADDR_VAR 0 3
54626: PUSH
54627: LD_INT 0
54629: ST_TO_ADDR
// end else
54630: GO 54640
// result := false ;
54632: LD_ADDR_VAR 0 3
54636: PUSH
54637: LD_INT 0
54639: ST_TO_ADDR
// end ;
54640: LD_VAR 0 3
54644: RET
// export function HealTarget ( sci ) ; begin
54645: LD_INT 0
54647: PPUSH
// if not sci then
54648: LD_VAR 0 1
54652: NOT
54653: IFFALSE 54657
// exit ;
54655: GO 54722
// result := 0 ;
54657: LD_ADDR_VAR 0 2
54661: PUSH
54662: LD_INT 0
54664: ST_TO_ADDR
// if GetTaskList ( sci ) then
54665: LD_VAR 0 1
54669: PPUSH
54670: CALL_OW 437
54674: IFFALSE 54722
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54676: LD_VAR 0 1
54680: PPUSH
54681: CALL_OW 437
54685: PUSH
54686: LD_INT 1
54688: ARRAY
54689: PUSH
54690: LD_INT 1
54692: ARRAY
54693: PUSH
54694: LD_STRING l
54696: EQUAL
54697: IFFALSE 54722
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54699: LD_ADDR_VAR 0 2
54703: PUSH
54704: LD_VAR 0 1
54708: PPUSH
54709: CALL_OW 437
54713: PUSH
54714: LD_INT 1
54716: ARRAY
54717: PUSH
54718: LD_INT 4
54720: ARRAY
54721: ST_TO_ADDR
// end ;
54722: LD_VAR 0 2
54726: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54727: LD_INT 0
54729: PPUSH
54730: PPUSH
54731: PPUSH
54732: PPUSH
// if not base_units then
54733: LD_VAR 0 1
54737: NOT
54738: IFFALSE 54742
// exit ;
54740: GO 54829
// result := false ;
54742: LD_ADDR_VAR 0 2
54746: PUSH
54747: LD_INT 0
54749: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54750: LD_ADDR_VAR 0 5
54754: PUSH
54755: LD_VAR 0 1
54759: PPUSH
54760: LD_INT 21
54762: PUSH
54763: LD_INT 3
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: PPUSH
54770: CALL_OW 72
54774: ST_TO_ADDR
// if not tmp then
54775: LD_VAR 0 5
54779: NOT
54780: IFFALSE 54784
// exit ;
54782: GO 54829
// for i in tmp do
54784: LD_ADDR_VAR 0 3
54788: PUSH
54789: LD_VAR 0 5
54793: PUSH
54794: FOR_IN
54795: IFFALSE 54827
// begin result := EnemyInRange ( i , 22 ) ;
54797: LD_ADDR_VAR 0 2
54801: PUSH
54802: LD_VAR 0 3
54806: PPUSH
54807: LD_INT 22
54809: PPUSH
54810: CALL 52515 0 2
54814: ST_TO_ADDR
// if result then
54815: LD_VAR 0 2
54819: IFFALSE 54825
// exit ;
54821: POP
54822: POP
54823: GO 54829
// end ;
54825: GO 54794
54827: POP
54828: POP
// end ;
54829: LD_VAR 0 2
54833: RET
// export function FilterByTag ( units , tag ) ; begin
54834: LD_INT 0
54836: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54837: LD_ADDR_VAR 0 3
54841: PUSH
54842: LD_VAR 0 1
54846: PPUSH
54847: LD_INT 120
54849: PUSH
54850: LD_VAR 0 2
54854: PUSH
54855: EMPTY
54856: LIST
54857: LIST
54858: PPUSH
54859: CALL_OW 72
54863: ST_TO_ADDR
// end ;
54864: LD_VAR 0 3
54868: RET
// export function IsDriver ( un ) ; begin
54869: LD_INT 0
54871: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54872: LD_ADDR_VAR 0 2
54876: PUSH
54877: LD_VAR 0 1
54881: PUSH
54882: LD_INT 55
54884: PUSH
54885: EMPTY
54886: LIST
54887: PPUSH
54888: CALL_OW 69
54892: IN
54893: ST_TO_ADDR
// end ;
54894: LD_VAR 0 2
54898: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54899: LD_INT 0
54901: PPUSH
54902: PPUSH
// list := [ ] ;
54903: LD_ADDR_VAR 0 5
54907: PUSH
54908: EMPTY
54909: ST_TO_ADDR
// case d of 0 :
54910: LD_VAR 0 3
54914: PUSH
54915: LD_INT 0
54917: DOUBLE
54918: EQUAL
54919: IFTRUE 54923
54921: GO 55056
54923: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54924: LD_ADDR_VAR 0 5
54928: PUSH
54929: LD_VAR 0 1
54933: PUSH
54934: LD_INT 4
54936: MINUS
54937: PUSH
54938: LD_VAR 0 2
54942: PUSH
54943: LD_INT 4
54945: MINUS
54946: PUSH
54947: LD_INT 2
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: PUSH
54955: LD_VAR 0 1
54959: PUSH
54960: LD_INT 3
54962: MINUS
54963: PUSH
54964: LD_VAR 0 2
54968: PUSH
54969: LD_INT 1
54971: PUSH
54972: EMPTY
54973: LIST
54974: LIST
54975: LIST
54976: PUSH
54977: LD_VAR 0 1
54981: PUSH
54982: LD_INT 4
54984: PLUS
54985: PUSH
54986: LD_VAR 0 2
54990: PUSH
54991: LD_INT 4
54993: PUSH
54994: EMPTY
54995: LIST
54996: LIST
54997: LIST
54998: PUSH
54999: LD_VAR 0 1
55003: PUSH
55004: LD_INT 3
55006: PLUS
55007: PUSH
55008: LD_VAR 0 2
55012: PUSH
55013: LD_INT 3
55015: PLUS
55016: PUSH
55017: LD_INT 5
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: LIST
55024: PUSH
55025: LD_VAR 0 1
55029: PUSH
55030: LD_VAR 0 2
55034: PUSH
55035: LD_INT 4
55037: PLUS
55038: PUSH
55039: LD_INT 0
55041: PUSH
55042: EMPTY
55043: LIST
55044: LIST
55045: LIST
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: LIST
55053: ST_TO_ADDR
// end ; 1 :
55054: GO 55754
55056: LD_INT 1
55058: DOUBLE
55059: EQUAL
55060: IFTRUE 55064
55062: GO 55197
55064: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55065: LD_ADDR_VAR 0 5
55069: PUSH
55070: LD_VAR 0 1
55074: PUSH
55075: LD_VAR 0 2
55079: PUSH
55080: LD_INT 4
55082: MINUS
55083: PUSH
55084: LD_INT 3
55086: PUSH
55087: EMPTY
55088: LIST
55089: LIST
55090: LIST
55091: PUSH
55092: LD_VAR 0 1
55096: PUSH
55097: LD_INT 3
55099: MINUS
55100: PUSH
55101: LD_VAR 0 2
55105: PUSH
55106: LD_INT 3
55108: MINUS
55109: PUSH
55110: LD_INT 2
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: PUSH
55118: LD_VAR 0 1
55122: PUSH
55123: LD_INT 4
55125: MINUS
55126: PUSH
55127: LD_VAR 0 2
55131: PUSH
55132: LD_INT 1
55134: PUSH
55135: EMPTY
55136: LIST
55137: LIST
55138: LIST
55139: PUSH
55140: LD_VAR 0 1
55144: PUSH
55145: LD_VAR 0 2
55149: PUSH
55150: LD_INT 3
55152: PLUS
55153: PUSH
55154: LD_INT 0
55156: PUSH
55157: EMPTY
55158: LIST
55159: LIST
55160: LIST
55161: PUSH
55162: LD_VAR 0 1
55166: PUSH
55167: LD_INT 4
55169: PLUS
55170: PUSH
55171: LD_VAR 0 2
55175: PUSH
55176: LD_INT 4
55178: PLUS
55179: PUSH
55180: LD_INT 5
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: PUSH
55188: EMPTY
55189: LIST
55190: LIST
55191: LIST
55192: LIST
55193: LIST
55194: ST_TO_ADDR
// end ; 2 :
55195: GO 55754
55197: LD_INT 2
55199: DOUBLE
55200: EQUAL
55201: IFTRUE 55205
55203: GO 55334
55205: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55206: LD_ADDR_VAR 0 5
55210: PUSH
55211: LD_VAR 0 1
55215: PUSH
55216: LD_VAR 0 2
55220: PUSH
55221: LD_INT 3
55223: MINUS
55224: PUSH
55225: LD_INT 3
55227: PUSH
55228: EMPTY
55229: LIST
55230: LIST
55231: LIST
55232: PUSH
55233: LD_VAR 0 1
55237: PUSH
55238: LD_INT 4
55240: PLUS
55241: PUSH
55242: LD_VAR 0 2
55246: PUSH
55247: LD_INT 4
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: LIST
55254: PUSH
55255: LD_VAR 0 1
55259: PUSH
55260: LD_VAR 0 2
55264: PUSH
55265: LD_INT 4
55267: PLUS
55268: PUSH
55269: LD_INT 0
55271: PUSH
55272: EMPTY
55273: LIST
55274: LIST
55275: LIST
55276: PUSH
55277: LD_VAR 0 1
55281: PUSH
55282: LD_INT 3
55284: MINUS
55285: PUSH
55286: LD_VAR 0 2
55290: PUSH
55291: LD_INT 1
55293: PUSH
55294: EMPTY
55295: LIST
55296: LIST
55297: LIST
55298: PUSH
55299: LD_VAR 0 1
55303: PUSH
55304: LD_INT 4
55306: MINUS
55307: PUSH
55308: LD_VAR 0 2
55312: PUSH
55313: LD_INT 4
55315: MINUS
55316: PUSH
55317: LD_INT 2
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: LIST
55324: PUSH
55325: EMPTY
55326: LIST
55327: LIST
55328: LIST
55329: LIST
55330: LIST
55331: ST_TO_ADDR
// end ; 3 :
55332: GO 55754
55334: LD_INT 3
55336: DOUBLE
55337: EQUAL
55338: IFTRUE 55342
55340: GO 55475
55342: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55343: LD_ADDR_VAR 0 5
55347: PUSH
55348: LD_VAR 0 1
55352: PUSH
55353: LD_INT 3
55355: PLUS
55356: PUSH
55357: LD_VAR 0 2
55361: PUSH
55362: LD_INT 4
55364: PUSH
55365: EMPTY
55366: LIST
55367: LIST
55368: LIST
55369: PUSH
55370: LD_VAR 0 1
55374: PUSH
55375: LD_INT 4
55377: PLUS
55378: PUSH
55379: LD_VAR 0 2
55383: PUSH
55384: LD_INT 4
55386: PLUS
55387: PUSH
55388: LD_INT 5
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: LIST
55395: PUSH
55396: LD_VAR 0 1
55400: PUSH
55401: LD_INT 4
55403: MINUS
55404: PUSH
55405: LD_VAR 0 2
55409: PUSH
55410: LD_INT 1
55412: PUSH
55413: EMPTY
55414: LIST
55415: LIST
55416: LIST
55417: PUSH
55418: LD_VAR 0 1
55422: PUSH
55423: LD_VAR 0 2
55427: PUSH
55428: LD_INT 4
55430: MINUS
55431: PUSH
55432: LD_INT 3
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: LIST
55439: PUSH
55440: LD_VAR 0 1
55444: PUSH
55445: LD_INT 3
55447: MINUS
55448: PUSH
55449: LD_VAR 0 2
55453: PUSH
55454: LD_INT 3
55456: MINUS
55457: PUSH
55458: LD_INT 2
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: PUSH
55466: EMPTY
55467: LIST
55468: LIST
55469: LIST
55470: LIST
55471: LIST
55472: ST_TO_ADDR
// end ; 4 :
55473: GO 55754
55475: LD_INT 4
55477: DOUBLE
55478: EQUAL
55479: IFTRUE 55483
55481: GO 55616
55483: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55484: LD_ADDR_VAR 0 5
55488: PUSH
55489: LD_VAR 0 1
55493: PUSH
55494: LD_VAR 0 2
55498: PUSH
55499: LD_INT 4
55501: PLUS
55502: PUSH
55503: LD_INT 0
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: LIST
55510: PUSH
55511: LD_VAR 0 1
55515: PUSH
55516: LD_INT 3
55518: PLUS
55519: PUSH
55520: LD_VAR 0 2
55524: PUSH
55525: LD_INT 3
55527: PLUS
55528: PUSH
55529: LD_INT 5
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: LIST
55536: PUSH
55537: LD_VAR 0 1
55541: PUSH
55542: LD_INT 4
55544: PLUS
55545: PUSH
55546: LD_VAR 0 2
55550: PUSH
55551: LD_INT 4
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: LIST
55558: PUSH
55559: LD_VAR 0 1
55563: PUSH
55564: LD_VAR 0 2
55568: PUSH
55569: LD_INT 3
55571: MINUS
55572: PUSH
55573: LD_INT 3
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: LIST
55580: PUSH
55581: LD_VAR 0 1
55585: PUSH
55586: LD_INT 4
55588: MINUS
55589: PUSH
55590: LD_VAR 0 2
55594: PUSH
55595: LD_INT 4
55597: MINUS
55598: PUSH
55599: LD_INT 2
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: LIST
55606: PUSH
55607: EMPTY
55608: LIST
55609: LIST
55610: LIST
55611: LIST
55612: LIST
55613: ST_TO_ADDR
// end ; 5 :
55614: GO 55754
55616: LD_INT 5
55618: DOUBLE
55619: EQUAL
55620: IFTRUE 55624
55622: GO 55753
55624: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55625: LD_ADDR_VAR 0 5
55629: PUSH
55630: LD_VAR 0 1
55634: PUSH
55635: LD_INT 4
55637: MINUS
55638: PUSH
55639: LD_VAR 0 2
55643: PUSH
55644: LD_INT 1
55646: PUSH
55647: EMPTY
55648: LIST
55649: LIST
55650: LIST
55651: PUSH
55652: LD_VAR 0 1
55656: PUSH
55657: LD_VAR 0 2
55661: PUSH
55662: LD_INT 4
55664: MINUS
55665: PUSH
55666: LD_INT 3
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: LIST
55673: PUSH
55674: LD_VAR 0 1
55678: PUSH
55679: LD_INT 4
55681: PLUS
55682: PUSH
55683: LD_VAR 0 2
55687: PUSH
55688: LD_INT 4
55690: PLUS
55691: PUSH
55692: LD_INT 5
55694: PUSH
55695: EMPTY
55696: LIST
55697: LIST
55698: LIST
55699: PUSH
55700: LD_VAR 0 1
55704: PUSH
55705: LD_INT 3
55707: PLUS
55708: PUSH
55709: LD_VAR 0 2
55713: PUSH
55714: LD_INT 4
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: LIST
55721: PUSH
55722: LD_VAR 0 1
55726: PUSH
55727: LD_VAR 0 2
55731: PUSH
55732: LD_INT 3
55734: PLUS
55735: PUSH
55736: LD_INT 0
55738: PUSH
55739: EMPTY
55740: LIST
55741: LIST
55742: LIST
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: LIST
55748: LIST
55749: LIST
55750: ST_TO_ADDR
// end ; end ;
55751: GO 55754
55753: POP
// result := list ;
55754: LD_ADDR_VAR 0 4
55758: PUSH
55759: LD_VAR 0 5
55763: ST_TO_ADDR
// end ;
55764: LD_VAR 0 4
55768: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55769: LD_INT 0
55771: PPUSH
55772: PPUSH
55773: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55774: LD_VAR 0 1
55778: NOT
55779: PUSH
55780: LD_VAR 0 2
55784: PUSH
55785: LD_INT 1
55787: PUSH
55788: LD_INT 2
55790: PUSH
55791: LD_INT 3
55793: PUSH
55794: LD_INT 4
55796: PUSH
55797: EMPTY
55798: LIST
55799: LIST
55800: LIST
55801: LIST
55802: IN
55803: NOT
55804: OR
55805: IFFALSE 55809
// exit ;
55807: GO 55901
// tmp := [ ] ;
55809: LD_ADDR_VAR 0 5
55813: PUSH
55814: EMPTY
55815: ST_TO_ADDR
// for i in units do
55816: LD_ADDR_VAR 0 4
55820: PUSH
55821: LD_VAR 0 1
55825: PUSH
55826: FOR_IN
55827: IFFALSE 55870
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55829: LD_ADDR_VAR 0 5
55833: PUSH
55834: LD_VAR 0 5
55838: PPUSH
55839: LD_VAR 0 5
55843: PUSH
55844: LD_INT 1
55846: PLUS
55847: PPUSH
55848: LD_VAR 0 4
55852: PPUSH
55853: LD_VAR 0 2
55857: PPUSH
55858: CALL_OW 259
55862: PPUSH
55863: CALL_OW 2
55867: ST_TO_ADDR
55868: GO 55826
55870: POP
55871: POP
// if not tmp then
55872: LD_VAR 0 5
55876: NOT
55877: IFFALSE 55881
// exit ;
55879: GO 55901
// result := SortListByListDesc ( units , tmp ) ;
55881: LD_ADDR_VAR 0 3
55885: PUSH
55886: LD_VAR 0 1
55890: PPUSH
55891: LD_VAR 0 5
55895: PPUSH
55896: CALL_OW 77
55900: ST_TO_ADDR
// end ;
55901: LD_VAR 0 3
55905: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55906: LD_INT 0
55908: PPUSH
55909: PPUSH
55910: PPUSH
// result := false ;
55911: LD_ADDR_VAR 0 3
55915: PUSH
55916: LD_INT 0
55918: ST_TO_ADDR
// x := GetX ( building ) ;
55919: LD_ADDR_VAR 0 4
55923: PUSH
55924: LD_VAR 0 2
55928: PPUSH
55929: CALL_OW 250
55933: ST_TO_ADDR
// y := GetY ( building ) ;
55934: LD_ADDR_VAR 0 5
55938: PUSH
55939: LD_VAR 0 2
55943: PPUSH
55944: CALL_OW 251
55948: ST_TO_ADDR
// if not building or not x or not y then
55949: LD_VAR 0 2
55953: NOT
55954: PUSH
55955: LD_VAR 0 4
55959: NOT
55960: OR
55961: PUSH
55962: LD_VAR 0 5
55966: NOT
55967: OR
55968: IFFALSE 55972
// exit ;
55970: GO 56064
// if GetTaskList ( unit ) then
55972: LD_VAR 0 1
55976: PPUSH
55977: CALL_OW 437
55981: IFFALSE 56064
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55983: LD_STRING e
55985: PUSH
55986: LD_VAR 0 1
55990: PPUSH
55991: CALL_OW 437
55995: PUSH
55996: LD_INT 1
55998: ARRAY
55999: PUSH
56000: LD_INT 1
56002: ARRAY
56003: EQUAL
56004: PUSH
56005: LD_VAR 0 4
56009: PUSH
56010: LD_VAR 0 1
56014: PPUSH
56015: CALL_OW 437
56019: PUSH
56020: LD_INT 1
56022: ARRAY
56023: PUSH
56024: LD_INT 2
56026: ARRAY
56027: EQUAL
56028: AND
56029: PUSH
56030: LD_VAR 0 5
56034: PUSH
56035: LD_VAR 0 1
56039: PPUSH
56040: CALL_OW 437
56044: PUSH
56045: LD_INT 1
56047: ARRAY
56048: PUSH
56049: LD_INT 3
56051: ARRAY
56052: EQUAL
56053: AND
56054: IFFALSE 56064
// result := true end ;
56056: LD_ADDR_VAR 0 3
56060: PUSH
56061: LD_INT 1
56063: ST_TO_ADDR
// end ;
56064: LD_VAR 0 3
56068: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56069: LD_INT 0
56071: PPUSH
// result := false ;
56072: LD_ADDR_VAR 0 4
56076: PUSH
56077: LD_INT 0
56079: ST_TO_ADDR
// if GetTaskList ( unit ) then
56080: LD_VAR 0 1
56084: PPUSH
56085: CALL_OW 437
56089: IFFALSE 56172
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56091: LD_STRING M
56093: PUSH
56094: LD_VAR 0 1
56098: PPUSH
56099: CALL_OW 437
56103: PUSH
56104: LD_INT 1
56106: ARRAY
56107: PUSH
56108: LD_INT 1
56110: ARRAY
56111: EQUAL
56112: PUSH
56113: LD_VAR 0 2
56117: PUSH
56118: LD_VAR 0 1
56122: PPUSH
56123: CALL_OW 437
56127: PUSH
56128: LD_INT 1
56130: ARRAY
56131: PUSH
56132: LD_INT 2
56134: ARRAY
56135: EQUAL
56136: AND
56137: PUSH
56138: LD_VAR 0 3
56142: PUSH
56143: LD_VAR 0 1
56147: PPUSH
56148: CALL_OW 437
56152: PUSH
56153: LD_INT 1
56155: ARRAY
56156: PUSH
56157: LD_INT 3
56159: ARRAY
56160: EQUAL
56161: AND
56162: IFFALSE 56172
// result := true ;
56164: LD_ADDR_VAR 0 4
56168: PUSH
56169: LD_INT 1
56171: ST_TO_ADDR
// end ; end ;
56172: LD_VAR 0 4
56176: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56177: LD_INT 0
56179: PPUSH
56180: PPUSH
56181: PPUSH
56182: PPUSH
// if not unit or not area then
56183: LD_VAR 0 1
56187: NOT
56188: PUSH
56189: LD_VAR 0 2
56193: NOT
56194: OR
56195: IFFALSE 56199
// exit ;
56197: GO 56363
// tmp := AreaToList ( area , i ) ;
56199: LD_ADDR_VAR 0 6
56203: PUSH
56204: LD_VAR 0 2
56208: PPUSH
56209: LD_VAR 0 5
56213: PPUSH
56214: CALL_OW 517
56218: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56219: LD_ADDR_VAR 0 5
56223: PUSH
56224: DOUBLE
56225: LD_INT 1
56227: DEC
56228: ST_TO_ADDR
56229: LD_VAR 0 6
56233: PUSH
56234: LD_INT 1
56236: ARRAY
56237: PUSH
56238: FOR_TO
56239: IFFALSE 56361
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56241: LD_ADDR_VAR 0 7
56245: PUSH
56246: LD_VAR 0 6
56250: PUSH
56251: LD_INT 1
56253: ARRAY
56254: PUSH
56255: LD_VAR 0 5
56259: ARRAY
56260: PUSH
56261: LD_VAR 0 6
56265: PUSH
56266: LD_INT 2
56268: ARRAY
56269: PUSH
56270: LD_VAR 0 5
56274: ARRAY
56275: PUSH
56276: EMPTY
56277: LIST
56278: LIST
56279: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56280: LD_VAR 0 7
56284: PUSH
56285: LD_INT 1
56287: ARRAY
56288: PPUSH
56289: LD_VAR 0 7
56293: PUSH
56294: LD_INT 2
56296: ARRAY
56297: PPUSH
56298: CALL_OW 428
56302: PUSH
56303: LD_INT 0
56305: EQUAL
56306: IFFALSE 56359
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56308: LD_VAR 0 1
56312: PPUSH
56313: LD_VAR 0 7
56317: PUSH
56318: LD_INT 1
56320: ARRAY
56321: PPUSH
56322: LD_VAR 0 7
56326: PUSH
56327: LD_INT 2
56329: ARRAY
56330: PPUSH
56331: LD_VAR 0 3
56335: PPUSH
56336: CALL_OW 48
// result := IsPlaced ( unit ) ;
56340: LD_ADDR_VAR 0 4
56344: PUSH
56345: LD_VAR 0 1
56349: PPUSH
56350: CALL_OW 305
56354: ST_TO_ADDR
// exit ;
56355: POP
56356: POP
56357: GO 56363
// end ; end ;
56359: GO 56238
56361: POP
56362: POP
// end ;
56363: LD_VAR 0 4
56367: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56368: LD_INT 0
56370: PPUSH
56371: PPUSH
56372: PPUSH
// if not side or side > 8 then
56373: LD_VAR 0 1
56377: NOT
56378: PUSH
56379: LD_VAR 0 1
56383: PUSH
56384: LD_INT 8
56386: GREATER
56387: OR
56388: IFFALSE 56392
// exit ;
56390: GO 56579
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56392: LD_ADDR_VAR 0 4
56396: PUSH
56397: LD_INT 22
56399: PUSH
56400: LD_VAR 0 1
56404: PUSH
56405: EMPTY
56406: LIST
56407: LIST
56408: PUSH
56409: LD_INT 21
56411: PUSH
56412: LD_INT 3
56414: PUSH
56415: EMPTY
56416: LIST
56417: LIST
56418: PUSH
56419: EMPTY
56420: LIST
56421: LIST
56422: PPUSH
56423: CALL_OW 69
56427: ST_TO_ADDR
// if not tmp then
56428: LD_VAR 0 4
56432: NOT
56433: IFFALSE 56437
// exit ;
56435: GO 56579
// enable_addtolog := true ;
56437: LD_ADDR_OWVAR 81
56441: PUSH
56442: LD_INT 1
56444: ST_TO_ADDR
// AddToLog ( [ ) ;
56445: LD_STRING [
56447: PPUSH
56448: CALL_OW 561
// for i in tmp do
56452: LD_ADDR_VAR 0 3
56456: PUSH
56457: LD_VAR 0 4
56461: PUSH
56462: FOR_IN
56463: IFFALSE 56570
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56465: LD_STRING [
56467: PUSH
56468: LD_VAR 0 3
56472: PPUSH
56473: CALL_OW 266
56477: STR
56478: PUSH
56479: LD_STRING , 
56481: STR
56482: PUSH
56483: LD_VAR 0 3
56487: PPUSH
56488: CALL_OW 250
56492: STR
56493: PUSH
56494: LD_STRING , 
56496: STR
56497: PUSH
56498: LD_VAR 0 3
56502: PPUSH
56503: CALL_OW 251
56507: STR
56508: PUSH
56509: LD_STRING , 
56511: STR
56512: PUSH
56513: LD_VAR 0 3
56517: PPUSH
56518: CALL_OW 254
56522: STR
56523: PUSH
56524: LD_STRING , 
56526: STR
56527: PUSH
56528: LD_VAR 0 3
56532: PPUSH
56533: LD_INT 1
56535: PPUSH
56536: CALL_OW 268
56540: STR
56541: PUSH
56542: LD_STRING , 
56544: STR
56545: PUSH
56546: LD_VAR 0 3
56550: PPUSH
56551: LD_INT 2
56553: PPUSH
56554: CALL_OW 268
56558: STR
56559: PUSH
56560: LD_STRING ],
56562: STR
56563: PPUSH
56564: CALL_OW 561
// end ;
56568: GO 56462
56570: POP
56571: POP
// AddToLog ( ]; ) ;
56572: LD_STRING ];
56574: PPUSH
56575: CALL_OW 561
// end ;
56579: LD_VAR 0 2
56583: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56584: LD_INT 0
56586: PPUSH
56587: PPUSH
56588: PPUSH
56589: PPUSH
56590: PPUSH
// if not area or not rate or not max then
56591: LD_VAR 0 1
56595: NOT
56596: PUSH
56597: LD_VAR 0 2
56601: NOT
56602: OR
56603: PUSH
56604: LD_VAR 0 4
56608: NOT
56609: OR
56610: IFFALSE 56614
// exit ;
56612: GO 56803
// while 1 do
56614: LD_INT 1
56616: IFFALSE 56803
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56618: LD_ADDR_VAR 0 9
56622: PUSH
56623: LD_VAR 0 1
56627: PPUSH
56628: LD_INT 1
56630: PPUSH
56631: CALL_OW 287
56635: PUSH
56636: LD_INT 10
56638: MUL
56639: ST_TO_ADDR
// r := rate / 10 ;
56640: LD_ADDR_VAR 0 7
56644: PUSH
56645: LD_VAR 0 2
56649: PUSH
56650: LD_INT 10
56652: DIVREAL
56653: ST_TO_ADDR
// time := 1 1$00 ;
56654: LD_ADDR_VAR 0 8
56658: PUSH
56659: LD_INT 2100
56661: ST_TO_ADDR
// if amount < min then
56662: LD_VAR 0 9
56666: PUSH
56667: LD_VAR 0 3
56671: LESS
56672: IFFALSE 56690
// r := r * 2 else
56674: LD_ADDR_VAR 0 7
56678: PUSH
56679: LD_VAR 0 7
56683: PUSH
56684: LD_INT 2
56686: MUL
56687: ST_TO_ADDR
56688: GO 56716
// if amount > max then
56690: LD_VAR 0 9
56694: PUSH
56695: LD_VAR 0 4
56699: GREATER
56700: IFFALSE 56716
// r := r / 2 ;
56702: LD_ADDR_VAR 0 7
56706: PUSH
56707: LD_VAR 0 7
56711: PUSH
56712: LD_INT 2
56714: DIVREAL
56715: ST_TO_ADDR
// time := time / r ;
56716: LD_ADDR_VAR 0 8
56720: PUSH
56721: LD_VAR 0 8
56725: PUSH
56726: LD_VAR 0 7
56730: DIVREAL
56731: ST_TO_ADDR
// if time < 0 then
56732: LD_VAR 0 8
56736: PUSH
56737: LD_INT 0
56739: LESS
56740: IFFALSE 56757
// time := time * - 1 ;
56742: LD_ADDR_VAR 0 8
56746: PUSH
56747: LD_VAR 0 8
56751: PUSH
56752: LD_INT 1
56754: NEG
56755: MUL
56756: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56757: LD_VAR 0 8
56761: PUSH
56762: LD_INT 35
56764: PPUSH
56765: LD_INT 875
56767: PPUSH
56768: CALL_OW 12
56772: PLUS
56773: PPUSH
56774: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56778: LD_INT 1
56780: PPUSH
56781: LD_INT 5
56783: PPUSH
56784: CALL_OW 12
56788: PPUSH
56789: LD_VAR 0 1
56793: PPUSH
56794: LD_INT 1
56796: PPUSH
56797: CALL_OW 55
// end ;
56801: GO 56614
// end ;
56803: LD_VAR 0 5
56807: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56808: LD_INT 0
56810: PPUSH
56811: PPUSH
56812: PPUSH
56813: PPUSH
56814: PPUSH
56815: PPUSH
56816: PPUSH
56817: PPUSH
// if not turrets or not factories then
56818: LD_VAR 0 1
56822: NOT
56823: PUSH
56824: LD_VAR 0 2
56828: NOT
56829: OR
56830: IFFALSE 56834
// exit ;
56832: GO 57141
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56834: LD_ADDR_VAR 0 10
56838: PUSH
56839: LD_INT 5
56841: PUSH
56842: LD_INT 6
56844: PUSH
56845: EMPTY
56846: LIST
56847: LIST
56848: PUSH
56849: LD_INT 2
56851: PUSH
56852: LD_INT 4
56854: PUSH
56855: EMPTY
56856: LIST
56857: LIST
56858: PUSH
56859: LD_INT 3
56861: PUSH
56862: LD_INT 5
56864: PUSH
56865: EMPTY
56866: LIST
56867: LIST
56868: PUSH
56869: EMPTY
56870: LIST
56871: LIST
56872: LIST
56873: PUSH
56874: LD_INT 24
56876: PUSH
56877: LD_INT 25
56879: PUSH
56880: EMPTY
56881: LIST
56882: LIST
56883: PUSH
56884: LD_INT 23
56886: PUSH
56887: LD_INT 27
56889: PUSH
56890: EMPTY
56891: LIST
56892: LIST
56893: PUSH
56894: EMPTY
56895: LIST
56896: LIST
56897: PUSH
56898: LD_INT 42
56900: PUSH
56901: LD_INT 43
56903: PUSH
56904: EMPTY
56905: LIST
56906: LIST
56907: PUSH
56908: LD_INT 44
56910: PUSH
56911: LD_INT 46
56913: PUSH
56914: EMPTY
56915: LIST
56916: LIST
56917: PUSH
56918: LD_INT 45
56920: PUSH
56921: LD_INT 47
56923: PUSH
56924: EMPTY
56925: LIST
56926: LIST
56927: PUSH
56928: EMPTY
56929: LIST
56930: LIST
56931: LIST
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: LIST
56937: ST_TO_ADDR
// result := [ ] ;
56938: LD_ADDR_VAR 0 3
56942: PUSH
56943: EMPTY
56944: ST_TO_ADDR
// for i in turrets do
56945: LD_ADDR_VAR 0 4
56949: PUSH
56950: LD_VAR 0 1
56954: PUSH
56955: FOR_IN
56956: IFFALSE 57139
// begin nat := GetNation ( i ) ;
56958: LD_ADDR_VAR 0 7
56962: PUSH
56963: LD_VAR 0 4
56967: PPUSH
56968: CALL_OW 248
56972: ST_TO_ADDR
// weapon := 0 ;
56973: LD_ADDR_VAR 0 8
56977: PUSH
56978: LD_INT 0
56980: ST_TO_ADDR
// if not nat then
56981: LD_VAR 0 7
56985: NOT
56986: IFFALSE 56990
// continue ;
56988: GO 56955
// for j in list [ nat ] do
56990: LD_ADDR_VAR 0 5
56994: PUSH
56995: LD_VAR 0 10
56999: PUSH
57000: LD_VAR 0 7
57004: ARRAY
57005: PUSH
57006: FOR_IN
57007: IFFALSE 57048
// if GetBWeapon ( i ) = j [ 1 ] then
57009: LD_VAR 0 4
57013: PPUSH
57014: CALL_OW 269
57018: PUSH
57019: LD_VAR 0 5
57023: PUSH
57024: LD_INT 1
57026: ARRAY
57027: EQUAL
57028: IFFALSE 57046
// begin weapon := j [ 2 ] ;
57030: LD_ADDR_VAR 0 8
57034: PUSH
57035: LD_VAR 0 5
57039: PUSH
57040: LD_INT 2
57042: ARRAY
57043: ST_TO_ADDR
// break ;
57044: GO 57048
// end ;
57046: GO 57006
57048: POP
57049: POP
// if not weapon then
57050: LD_VAR 0 8
57054: NOT
57055: IFFALSE 57059
// continue ;
57057: GO 56955
// for k in factories do
57059: LD_ADDR_VAR 0 6
57063: PUSH
57064: LD_VAR 0 2
57068: PUSH
57069: FOR_IN
57070: IFFALSE 57135
// begin weapons := AvailableWeaponList ( k ) ;
57072: LD_ADDR_VAR 0 9
57076: PUSH
57077: LD_VAR 0 6
57081: PPUSH
57082: CALL_OW 478
57086: ST_TO_ADDR
// if not weapons then
57087: LD_VAR 0 9
57091: NOT
57092: IFFALSE 57096
// continue ;
57094: GO 57069
// if weapon in weapons then
57096: LD_VAR 0 8
57100: PUSH
57101: LD_VAR 0 9
57105: IN
57106: IFFALSE 57133
// begin result := [ i , weapon ] ;
57108: LD_ADDR_VAR 0 3
57112: PUSH
57113: LD_VAR 0 4
57117: PUSH
57118: LD_VAR 0 8
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: ST_TO_ADDR
// exit ;
57127: POP
57128: POP
57129: POP
57130: POP
57131: GO 57141
// end ; end ;
57133: GO 57069
57135: POP
57136: POP
// end ;
57137: GO 56955
57139: POP
57140: POP
// end ;
57141: LD_VAR 0 3
57145: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57146: LD_INT 0
57148: PPUSH
// if not side or side > 8 then
57149: LD_VAR 0 3
57153: NOT
57154: PUSH
57155: LD_VAR 0 3
57159: PUSH
57160: LD_INT 8
57162: GREATER
57163: OR
57164: IFFALSE 57168
// exit ;
57166: GO 57227
// if not range then
57168: LD_VAR 0 4
57172: NOT
57173: IFFALSE 57184
// range := - 12 ;
57175: LD_ADDR_VAR 0 4
57179: PUSH
57180: LD_INT 12
57182: NEG
57183: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57184: LD_VAR 0 1
57188: PPUSH
57189: LD_VAR 0 2
57193: PPUSH
57194: LD_VAR 0 3
57198: PPUSH
57199: LD_VAR 0 4
57203: PPUSH
57204: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57208: LD_VAR 0 1
57212: PPUSH
57213: LD_VAR 0 2
57217: PPUSH
57218: LD_VAR 0 3
57222: PPUSH
57223: CALL_OW 331
// end ;
57227: LD_VAR 0 5
57231: RET
// export function Video ( mode ) ; begin
57232: LD_INT 0
57234: PPUSH
// ingame_video = mode ;
57235: LD_ADDR_OWVAR 52
57239: PUSH
57240: LD_VAR 0 1
57244: ST_TO_ADDR
// interface_hidden = mode ;
57245: LD_ADDR_OWVAR 54
57249: PUSH
57250: LD_VAR 0 1
57254: ST_TO_ADDR
// end ;
57255: LD_VAR 0 2
57259: RET
// export function Join ( array , element ) ; begin
57260: LD_INT 0
57262: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57263: LD_ADDR_VAR 0 3
57267: PUSH
57268: LD_VAR 0 1
57272: PPUSH
57273: LD_VAR 0 1
57277: PUSH
57278: LD_INT 1
57280: PLUS
57281: PPUSH
57282: LD_VAR 0 2
57286: PPUSH
57287: CALL_OW 1
57291: ST_TO_ADDR
// end ;
57292: LD_VAR 0 3
57296: RET
// export function JoinUnion ( array , element ) ; begin
57297: LD_INT 0
57299: PPUSH
// result := array union element ;
57300: LD_ADDR_VAR 0 3
57304: PUSH
57305: LD_VAR 0 1
57309: PUSH
57310: LD_VAR 0 2
57314: UNION
57315: ST_TO_ADDR
// end ;
57316: LD_VAR 0 3
57320: RET
// export function GetBehemoths ( side ) ; begin
57321: LD_INT 0
57323: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57324: LD_ADDR_VAR 0 2
57328: PUSH
57329: LD_INT 22
57331: PUSH
57332: LD_VAR 0 1
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PUSH
57341: LD_INT 31
57343: PUSH
57344: LD_INT 25
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: PPUSH
57355: CALL_OW 69
57359: ST_TO_ADDR
// end ;
57360: LD_VAR 0 2
57364: RET
// export function Shuffle ( array ) ; var i , index ; begin
57365: LD_INT 0
57367: PPUSH
57368: PPUSH
57369: PPUSH
// result := [ ] ;
57370: LD_ADDR_VAR 0 2
57374: PUSH
57375: EMPTY
57376: ST_TO_ADDR
// if not array then
57377: LD_VAR 0 1
57381: NOT
57382: IFFALSE 57386
// exit ;
57384: GO 57485
// Randomize ;
57386: CALL_OW 10
// for i = array downto 1 do
57390: LD_ADDR_VAR 0 3
57394: PUSH
57395: DOUBLE
57396: LD_VAR 0 1
57400: INC
57401: ST_TO_ADDR
57402: LD_INT 1
57404: PUSH
57405: FOR_DOWNTO
57406: IFFALSE 57483
// begin index := rand ( 1 , array ) ;
57408: LD_ADDR_VAR 0 4
57412: PUSH
57413: LD_INT 1
57415: PPUSH
57416: LD_VAR 0 1
57420: PPUSH
57421: CALL_OW 12
57425: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57426: LD_ADDR_VAR 0 2
57430: PUSH
57431: LD_VAR 0 2
57435: PPUSH
57436: LD_VAR 0 2
57440: PUSH
57441: LD_INT 1
57443: PLUS
57444: PPUSH
57445: LD_VAR 0 1
57449: PUSH
57450: LD_VAR 0 4
57454: ARRAY
57455: PPUSH
57456: CALL_OW 2
57460: ST_TO_ADDR
// array := Delete ( array , index ) ;
57461: LD_ADDR_VAR 0 1
57465: PUSH
57466: LD_VAR 0 1
57470: PPUSH
57471: LD_VAR 0 4
57475: PPUSH
57476: CALL_OW 3
57480: ST_TO_ADDR
// end ;
57481: GO 57405
57483: POP
57484: POP
// end ;
57485: LD_VAR 0 2
57489: RET
// export function GetBaseMaterials ( base ) ; begin
57490: LD_INT 0
57492: PPUSH
// result := [ 0 , 0 , 0 ] ;
57493: LD_ADDR_VAR 0 2
57497: PUSH
57498: LD_INT 0
57500: PUSH
57501: LD_INT 0
57503: PUSH
57504: LD_INT 0
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: LIST
57511: ST_TO_ADDR
// if not base then
57512: LD_VAR 0 1
57516: NOT
57517: IFFALSE 57521
// exit ;
57519: GO 57570
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57521: LD_ADDR_VAR 0 2
57525: PUSH
57526: LD_VAR 0 1
57530: PPUSH
57531: LD_INT 1
57533: PPUSH
57534: CALL_OW 275
57538: PUSH
57539: LD_VAR 0 1
57543: PPUSH
57544: LD_INT 2
57546: PPUSH
57547: CALL_OW 275
57551: PUSH
57552: LD_VAR 0 1
57556: PPUSH
57557: LD_INT 3
57559: PPUSH
57560: CALL_OW 275
57564: PUSH
57565: EMPTY
57566: LIST
57567: LIST
57568: LIST
57569: ST_TO_ADDR
// end ;
57570: LD_VAR 0 2
57574: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57575: LD_INT 0
57577: PPUSH
57578: PPUSH
// result := array ;
57579: LD_ADDR_VAR 0 3
57583: PUSH
57584: LD_VAR 0 1
57588: ST_TO_ADDR
// if size >= result then
57589: LD_VAR 0 2
57593: PUSH
57594: LD_VAR 0 3
57598: GREATEREQUAL
57599: IFFALSE 57603
// exit ;
57601: GO 57653
// if size then
57603: LD_VAR 0 2
57607: IFFALSE 57653
// for i := array downto size do
57609: LD_ADDR_VAR 0 4
57613: PUSH
57614: DOUBLE
57615: LD_VAR 0 1
57619: INC
57620: ST_TO_ADDR
57621: LD_VAR 0 2
57625: PUSH
57626: FOR_DOWNTO
57627: IFFALSE 57651
// result := Delete ( result , result ) ;
57629: LD_ADDR_VAR 0 3
57633: PUSH
57634: LD_VAR 0 3
57638: PPUSH
57639: LD_VAR 0 3
57643: PPUSH
57644: CALL_OW 3
57648: ST_TO_ADDR
57649: GO 57626
57651: POP
57652: POP
// end ;
57653: LD_VAR 0 3
57657: RET
// export function ComExit ( unit ) ; var tmp ; begin
57658: LD_INT 0
57660: PPUSH
57661: PPUSH
// if not IsInUnit ( unit ) then
57662: LD_VAR 0 1
57666: PPUSH
57667: CALL_OW 310
57671: NOT
57672: IFFALSE 57676
// exit ;
57674: GO 57736
// tmp := IsInUnit ( unit ) ;
57676: LD_ADDR_VAR 0 3
57680: PUSH
57681: LD_VAR 0 1
57685: PPUSH
57686: CALL_OW 310
57690: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57691: LD_VAR 0 3
57695: PPUSH
57696: CALL_OW 247
57700: PUSH
57701: LD_INT 2
57703: EQUAL
57704: IFFALSE 57717
// ComExitVehicle ( unit ) else
57706: LD_VAR 0 1
57710: PPUSH
57711: CALL_OW 121
57715: GO 57726
// ComExitBuilding ( unit ) ;
57717: LD_VAR 0 1
57721: PPUSH
57722: CALL_OW 122
// result := tmp ;
57726: LD_ADDR_VAR 0 2
57730: PUSH
57731: LD_VAR 0 3
57735: ST_TO_ADDR
// end ;
57736: LD_VAR 0 2
57740: RET
// export function ComExitAll ( units ) ; var i ; begin
57741: LD_INT 0
57743: PPUSH
57744: PPUSH
// if not units then
57745: LD_VAR 0 1
57749: NOT
57750: IFFALSE 57754
// exit ;
57752: GO 57780
// for i in units do
57754: LD_ADDR_VAR 0 3
57758: PUSH
57759: LD_VAR 0 1
57763: PUSH
57764: FOR_IN
57765: IFFALSE 57778
// ComExit ( i ) ;
57767: LD_VAR 0 3
57771: PPUSH
57772: CALL 57658 0 1
57776: GO 57764
57778: POP
57779: POP
// end ;
57780: LD_VAR 0 2
57784: RET
// export function ResetHc ; begin
57785: LD_INT 0
57787: PPUSH
// InitHc ;
57788: CALL_OW 19
// hc_importance := 0 ;
57792: LD_ADDR_OWVAR 32
57796: PUSH
57797: LD_INT 0
57799: ST_TO_ADDR
// end ;
57800: LD_VAR 0 1
57804: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57805: LD_INT 0
57807: PPUSH
57808: PPUSH
57809: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57810: LD_ADDR_VAR 0 6
57814: PUSH
57815: LD_VAR 0 1
57819: PUSH
57820: LD_VAR 0 3
57824: PLUS
57825: PUSH
57826: LD_INT 2
57828: DIV
57829: ST_TO_ADDR
// if _x < 0 then
57830: LD_VAR 0 6
57834: PUSH
57835: LD_INT 0
57837: LESS
57838: IFFALSE 57855
// _x := _x * - 1 ;
57840: LD_ADDR_VAR 0 6
57844: PUSH
57845: LD_VAR 0 6
57849: PUSH
57850: LD_INT 1
57852: NEG
57853: MUL
57854: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57855: LD_ADDR_VAR 0 7
57859: PUSH
57860: LD_VAR 0 2
57864: PUSH
57865: LD_VAR 0 4
57869: PLUS
57870: PUSH
57871: LD_INT 2
57873: DIV
57874: ST_TO_ADDR
// if _y < 0 then
57875: LD_VAR 0 7
57879: PUSH
57880: LD_INT 0
57882: LESS
57883: IFFALSE 57900
// _y := _y * - 1 ;
57885: LD_ADDR_VAR 0 7
57889: PUSH
57890: LD_VAR 0 7
57894: PUSH
57895: LD_INT 1
57897: NEG
57898: MUL
57899: ST_TO_ADDR
// result := [ _x , _y ] ;
57900: LD_ADDR_VAR 0 5
57904: PUSH
57905: LD_VAR 0 6
57909: PUSH
57910: LD_VAR 0 7
57914: PUSH
57915: EMPTY
57916: LIST
57917: LIST
57918: ST_TO_ADDR
// end ;
57919: LD_VAR 0 5
57923: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57924: LD_INT 0
57926: PPUSH
57927: PPUSH
57928: PPUSH
57929: PPUSH
// task := GetTaskList ( unit ) ;
57930: LD_ADDR_VAR 0 7
57934: PUSH
57935: LD_VAR 0 1
57939: PPUSH
57940: CALL_OW 437
57944: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57945: LD_VAR 0 7
57949: NOT
57950: PUSH
57951: LD_VAR 0 1
57955: PPUSH
57956: LD_VAR 0 2
57960: PPUSH
57961: CALL_OW 308
57965: NOT
57966: AND
57967: IFFALSE 57971
// exit ;
57969: GO 58089
// if IsInArea ( unit , area ) then
57971: LD_VAR 0 1
57975: PPUSH
57976: LD_VAR 0 2
57980: PPUSH
57981: CALL_OW 308
57985: IFFALSE 58003
// begin ComMoveToArea ( unit , goAway ) ;
57987: LD_VAR 0 1
57991: PPUSH
57992: LD_VAR 0 3
57996: PPUSH
57997: CALL_OW 113
// exit ;
58001: GO 58089
// end ; if task [ 1 ] [ 1 ] <> M then
58003: LD_VAR 0 7
58007: PUSH
58008: LD_INT 1
58010: ARRAY
58011: PUSH
58012: LD_INT 1
58014: ARRAY
58015: PUSH
58016: LD_STRING M
58018: NONEQUAL
58019: IFFALSE 58023
// exit ;
58021: GO 58089
// x := task [ 1 ] [ 2 ] ;
58023: LD_ADDR_VAR 0 5
58027: PUSH
58028: LD_VAR 0 7
58032: PUSH
58033: LD_INT 1
58035: ARRAY
58036: PUSH
58037: LD_INT 2
58039: ARRAY
58040: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58041: LD_ADDR_VAR 0 6
58045: PUSH
58046: LD_VAR 0 7
58050: PUSH
58051: LD_INT 1
58053: ARRAY
58054: PUSH
58055: LD_INT 3
58057: ARRAY
58058: ST_TO_ADDR
// if InArea ( x , y , area ) then
58059: LD_VAR 0 5
58063: PPUSH
58064: LD_VAR 0 6
58068: PPUSH
58069: LD_VAR 0 2
58073: PPUSH
58074: CALL_OW 309
58078: IFFALSE 58089
// ComStop ( unit ) ;
58080: LD_VAR 0 1
58084: PPUSH
58085: CALL_OW 141
// end ;
58089: LD_VAR 0 4
58093: RET
// export function Abs ( value ) ; begin
58094: LD_INT 0
58096: PPUSH
// result := value ;
58097: LD_ADDR_VAR 0 2
58101: PUSH
58102: LD_VAR 0 1
58106: ST_TO_ADDR
// if value < 0 then
58107: LD_VAR 0 1
58111: PUSH
58112: LD_INT 0
58114: LESS
58115: IFFALSE 58132
// result := value * - 1 ;
58117: LD_ADDR_VAR 0 2
58121: PUSH
58122: LD_VAR 0 1
58126: PUSH
58127: LD_INT 1
58129: NEG
58130: MUL
58131: ST_TO_ADDR
// end ;
58132: LD_VAR 0 2
58136: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58137: LD_INT 0
58139: PPUSH
58140: PPUSH
58141: PPUSH
58142: PPUSH
58143: PPUSH
58144: PPUSH
58145: PPUSH
58146: PPUSH
// if not unit or not building then
58147: LD_VAR 0 1
58151: NOT
58152: PUSH
58153: LD_VAR 0 2
58157: NOT
58158: OR
58159: IFFALSE 58163
// exit ;
58161: GO 58389
// x := GetX ( building ) ;
58163: LD_ADDR_VAR 0 4
58167: PUSH
58168: LD_VAR 0 2
58172: PPUSH
58173: CALL_OW 250
58177: ST_TO_ADDR
// y := GetY ( building ) ;
58178: LD_ADDR_VAR 0 6
58182: PUSH
58183: LD_VAR 0 2
58187: PPUSH
58188: CALL_OW 251
58192: ST_TO_ADDR
// d := GetDir ( building ) ;
58193: LD_ADDR_VAR 0 8
58197: PUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: CALL_OW 254
58207: ST_TO_ADDR
// r := 4 ;
58208: LD_ADDR_VAR 0 9
58212: PUSH
58213: LD_INT 4
58215: ST_TO_ADDR
// for i := 1 to 5 do
58216: LD_ADDR_VAR 0 10
58220: PUSH
58221: DOUBLE
58222: LD_INT 1
58224: DEC
58225: ST_TO_ADDR
58226: LD_INT 5
58228: PUSH
58229: FOR_TO
58230: IFFALSE 58387
// begin _x := ShiftX ( x , d , r + i ) ;
58232: LD_ADDR_VAR 0 5
58236: PUSH
58237: LD_VAR 0 4
58241: PPUSH
58242: LD_VAR 0 8
58246: PPUSH
58247: LD_VAR 0 9
58251: PUSH
58252: LD_VAR 0 10
58256: PLUS
58257: PPUSH
58258: CALL_OW 272
58262: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58263: LD_ADDR_VAR 0 7
58267: PUSH
58268: LD_VAR 0 6
58272: PPUSH
58273: LD_VAR 0 8
58277: PPUSH
58278: LD_VAR 0 9
58282: PUSH
58283: LD_VAR 0 10
58287: PLUS
58288: PPUSH
58289: CALL_OW 273
58293: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58294: LD_VAR 0 5
58298: PPUSH
58299: LD_VAR 0 7
58303: PPUSH
58304: CALL_OW 488
58308: PUSH
58309: LD_VAR 0 5
58313: PPUSH
58314: LD_VAR 0 7
58318: PPUSH
58319: CALL_OW 428
58323: PPUSH
58324: CALL_OW 247
58328: PUSH
58329: LD_INT 3
58331: PUSH
58332: LD_INT 2
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: IN
58339: NOT
58340: AND
58341: IFFALSE 58385
// begin ComMoveXY ( unit , _x , _y ) ;
58343: LD_VAR 0 1
58347: PPUSH
58348: LD_VAR 0 5
58352: PPUSH
58353: LD_VAR 0 7
58357: PPUSH
58358: CALL_OW 111
// result := [ _x , _y ] ;
58362: LD_ADDR_VAR 0 3
58366: PUSH
58367: LD_VAR 0 5
58371: PUSH
58372: LD_VAR 0 7
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: ST_TO_ADDR
// exit ;
58381: POP
58382: POP
58383: GO 58389
// end ; end ;
58385: GO 58229
58387: POP
58388: POP
// end ;
58389: LD_VAR 0 3
58393: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58394: LD_INT 0
58396: PPUSH
58397: PPUSH
58398: PPUSH
// result := 0 ;
58399: LD_ADDR_VAR 0 3
58403: PUSH
58404: LD_INT 0
58406: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58407: LD_VAR 0 1
58411: PUSH
58412: LD_INT 0
58414: LESS
58415: PUSH
58416: LD_VAR 0 1
58420: PUSH
58421: LD_INT 8
58423: GREATER
58424: OR
58425: PUSH
58426: LD_VAR 0 2
58430: PUSH
58431: LD_INT 0
58433: LESS
58434: OR
58435: PUSH
58436: LD_VAR 0 2
58440: PUSH
58441: LD_INT 8
58443: GREATER
58444: OR
58445: IFFALSE 58449
// exit ;
58447: GO 58524
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58449: LD_ADDR_VAR 0 4
58453: PUSH
58454: LD_INT 22
58456: PUSH
58457: LD_VAR 0 2
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: PPUSH
58466: CALL_OW 69
58470: PUSH
58471: FOR_IN
58472: IFFALSE 58522
// begin un := UnitShoot ( i ) ;
58474: LD_ADDR_VAR 0 5
58478: PUSH
58479: LD_VAR 0 4
58483: PPUSH
58484: CALL_OW 504
58488: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58489: LD_VAR 0 5
58493: PPUSH
58494: CALL_OW 255
58498: PUSH
58499: LD_VAR 0 1
58503: EQUAL
58504: IFFALSE 58520
// begin result := un ;
58506: LD_ADDR_VAR 0 3
58510: PUSH
58511: LD_VAR 0 5
58515: ST_TO_ADDR
// exit ;
58516: POP
58517: POP
58518: GO 58524
// end ; end ;
58520: GO 58471
58522: POP
58523: POP
// end ;
58524: LD_VAR 0 3
58528: RET
// export function GetCargoBay ( units ) ; begin
58529: LD_INT 0
58531: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58532: LD_ADDR_VAR 0 2
58536: PUSH
58537: LD_VAR 0 1
58541: PPUSH
58542: LD_INT 2
58544: PUSH
58545: LD_INT 34
58547: PUSH
58548: LD_INT 12
58550: PUSH
58551: EMPTY
58552: LIST
58553: LIST
58554: PUSH
58555: LD_INT 34
58557: PUSH
58558: LD_INT 51
58560: PUSH
58561: EMPTY
58562: LIST
58563: LIST
58564: PUSH
58565: LD_INT 34
58567: PUSH
58568: LD_INT 32
58570: PUSH
58571: EMPTY
58572: LIST
58573: LIST
58574: PUSH
58575: LD_INT 34
58577: PUSH
58578: LD_INT 89
58580: PUSH
58581: EMPTY
58582: LIST
58583: LIST
58584: PUSH
58585: EMPTY
58586: LIST
58587: LIST
58588: LIST
58589: LIST
58590: LIST
58591: PPUSH
58592: CALL_OW 72
58596: ST_TO_ADDR
// end ;
58597: LD_VAR 0 2
58601: RET
// export function Negate ( value ) ; begin
58602: LD_INT 0
58604: PPUSH
// result := not value ;
58605: LD_ADDR_VAR 0 2
58609: PUSH
58610: LD_VAR 0 1
58614: NOT
58615: ST_TO_ADDR
// end ;
58616: LD_VAR 0 2
58620: RET
// export function Inc ( value ) ; begin
58621: LD_INT 0
58623: PPUSH
// result := value + 1 ;
58624: LD_ADDR_VAR 0 2
58628: PUSH
58629: LD_VAR 0 1
58633: PUSH
58634: LD_INT 1
58636: PLUS
58637: ST_TO_ADDR
// end ;
58638: LD_VAR 0 2
58642: RET
// export function Dec ( value ) ; begin
58643: LD_INT 0
58645: PPUSH
// result := value - 1 ;
58646: LD_ADDR_VAR 0 2
58650: PUSH
58651: LD_VAR 0 1
58655: PUSH
58656: LD_INT 1
58658: MINUS
58659: ST_TO_ADDR
// end ;
58660: LD_VAR 0 2
58664: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58665: LD_INT 0
58667: PPUSH
58668: PPUSH
58669: PPUSH
58670: PPUSH
58671: PPUSH
58672: PPUSH
58673: PPUSH
58674: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58675: LD_VAR 0 1
58679: PPUSH
58680: LD_VAR 0 2
58684: PPUSH
58685: CALL_OW 488
58689: NOT
58690: PUSH
58691: LD_VAR 0 3
58695: PPUSH
58696: LD_VAR 0 4
58700: PPUSH
58701: CALL_OW 488
58705: NOT
58706: OR
58707: IFFALSE 58720
// begin result := - 1 ;
58709: LD_ADDR_VAR 0 5
58713: PUSH
58714: LD_INT 1
58716: NEG
58717: ST_TO_ADDR
// exit ;
58718: GO 58955
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58720: LD_ADDR_VAR 0 12
58724: PUSH
58725: LD_VAR 0 1
58729: PPUSH
58730: LD_VAR 0 2
58734: PPUSH
58735: LD_VAR 0 3
58739: PPUSH
58740: LD_VAR 0 4
58744: PPUSH
58745: CALL 57805 0 4
58749: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58750: LD_ADDR_VAR 0 11
58754: PUSH
58755: LD_VAR 0 1
58759: PPUSH
58760: LD_VAR 0 2
58764: PPUSH
58765: LD_VAR 0 12
58769: PUSH
58770: LD_INT 1
58772: ARRAY
58773: PPUSH
58774: LD_VAR 0 12
58778: PUSH
58779: LD_INT 2
58781: ARRAY
58782: PPUSH
58783: CALL_OW 298
58787: ST_TO_ADDR
// distance := 9999 ;
58788: LD_ADDR_VAR 0 10
58792: PUSH
58793: LD_INT 9999
58795: ST_TO_ADDR
// for i := 0 to 5 do
58796: LD_ADDR_VAR 0 6
58800: PUSH
58801: DOUBLE
58802: LD_INT 0
58804: DEC
58805: ST_TO_ADDR
58806: LD_INT 5
58808: PUSH
58809: FOR_TO
58810: IFFALSE 58953
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58812: LD_ADDR_VAR 0 7
58816: PUSH
58817: LD_VAR 0 1
58821: PPUSH
58822: LD_VAR 0 6
58826: PPUSH
58827: LD_VAR 0 11
58831: PPUSH
58832: CALL_OW 272
58836: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58837: LD_ADDR_VAR 0 8
58841: PUSH
58842: LD_VAR 0 2
58846: PPUSH
58847: LD_VAR 0 6
58851: PPUSH
58852: LD_VAR 0 11
58856: PPUSH
58857: CALL_OW 273
58861: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58862: LD_VAR 0 7
58866: PPUSH
58867: LD_VAR 0 8
58871: PPUSH
58872: CALL_OW 488
58876: NOT
58877: IFFALSE 58881
// continue ;
58879: GO 58809
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58881: LD_ADDR_VAR 0 9
58885: PUSH
58886: LD_VAR 0 12
58890: PUSH
58891: LD_INT 1
58893: ARRAY
58894: PPUSH
58895: LD_VAR 0 12
58899: PUSH
58900: LD_INT 2
58902: ARRAY
58903: PPUSH
58904: LD_VAR 0 7
58908: PPUSH
58909: LD_VAR 0 8
58913: PPUSH
58914: CALL_OW 298
58918: ST_TO_ADDR
// if tmp < distance then
58919: LD_VAR 0 9
58923: PUSH
58924: LD_VAR 0 10
58928: LESS
58929: IFFALSE 58951
// begin result := i ;
58931: LD_ADDR_VAR 0 5
58935: PUSH
58936: LD_VAR 0 6
58940: ST_TO_ADDR
// distance := tmp ;
58941: LD_ADDR_VAR 0 10
58945: PUSH
58946: LD_VAR 0 9
58950: ST_TO_ADDR
// end ; end ;
58951: GO 58809
58953: POP
58954: POP
// end ;
58955: LD_VAR 0 5
58959: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58960: LD_INT 0
58962: PPUSH
58963: PPUSH
// if not driver or not IsInUnit ( driver ) then
58964: LD_VAR 0 1
58968: NOT
58969: PUSH
58970: LD_VAR 0 1
58974: PPUSH
58975: CALL_OW 310
58979: NOT
58980: OR
58981: IFFALSE 58985
// exit ;
58983: GO 59075
// vehicle := IsInUnit ( driver ) ;
58985: LD_ADDR_VAR 0 3
58989: PUSH
58990: LD_VAR 0 1
58994: PPUSH
58995: CALL_OW 310
58999: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59000: LD_VAR 0 1
59004: PPUSH
59005: LD_STRING \
59007: PUSH
59008: LD_INT 0
59010: PUSH
59011: LD_INT 0
59013: PUSH
59014: LD_INT 0
59016: PUSH
59017: LD_INT 0
59019: PUSH
59020: LD_INT 0
59022: PUSH
59023: LD_INT 0
59025: PUSH
59026: EMPTY
59027: LIST
59028: LIST
59029: LIST
59030: LIST
59031: LIST
59032: LIST
59033: LIST
59034: PUSH
59035: LD_STRING E
59037: PUSH
59038: LD_INT 0
59040: PUSH
59041: LD_INT 0
59043: PUSH
59044: LD_VAR 0 3
59048: PUSH
59049: LD_INT 0
59051: PUSH
59052: LD_INT 0
59054: PUSH
59055: LD_INT 0
59057: PUSH
59058: EMPTY
59059: LIST
59060: LIST
59061: LIST
59062: LIST
59063: LIST
59064: LIST
59065: LIST
59066: PUSH
59067: EMPTY
59068: LIST
59069: LIST
59070: PPUSH
59071: CALL_OW 446
// end ;
59075: LD_VAR 0 2
59079: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59080: LD_INT 0
59082: PPUSH
59083: PPUSH
// if not driver or not IsInUnit ( driver ) then
59084: LD_VAR 0 1
59088: NOT
59089: PUSH
59090: LD_VAR 0 1
59094: PPUSH
59095: CALL_OW 310
59099: NOT
59100: OR
59101: IFFALSE 59105
// exit ;
59103: GO 59195
// vehicle := IsInUnit ( driver ) ;
59105: LD_ADDR_VAR 0 3
59109: PUSH
59110: LD_VAR 0 1
59114: PPUSH
59115: CALL_OW 310
59119: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59120: LD_VAR 0 1
59124: PPUSH
59125: LD_STRING \
59127: PUSH
59128: LD_INT 0
59130: PUSH
59131: LD_INT 0
59133: PUSH
59134: LD_INT 0
59136: PUSH
59137: LD_INT 0
59139: PUSH
59140: LD_INT 0
59142: PUSH
59143: LD_INT 0
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: LIST
59150: LIST
59151: LIST
59152: LIST
59153: LIST
59154: PUSH
59155: LD_STRING E
59157: PUSH
59158: LD_INT 0
59160: PUSH
59161: LD_INT 0
59163: PUSH
59164: LD_VAR 0 3
59168: PUSH
59169: LD_INT 0
59171: PUSH
59172: LD_INT 0
59174: PUSH
59175: LD_INT 0
59177: PUSH
59178: EMPTY
59179: LIST
59180: LIST
59181: LIST
59182: LIST
59183: LIST
59184: LIST
59185: LIST
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PPUSH
59191: CALL_OW 447
// end ;
59195: LD_VAR 0 2
59199: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59200: LD_INT 0
59202: PPUSH
59203: PPUSH
59204: PPUSH
// tmp := [ ] ;
59205: LD_ADDR_VAR 0 5
59209: PUSH
59210: EMPTY
59211: ST_TO_ADDR
// for i in units do
59212: LD_ADDR_VAR 0 4
59216: PUSH
59217: LD_VAR 0 1
59221: PUSH
59222: FOR_IN
59223: IFFALSE 59261
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59225: LD_ADDR_VAR 0 5
59229: PUSH
59230: LD_VAR 0 5
59234: PPUSH
59235: LD_VAR 0 5
59239: PUSH
59240: LD_INT 1
59242: PLUS
59243: PPUSH
59244: LD_VAR 0 4
59248: PPUSH
59249: CALL_OW 256
59253: PPUSH
59254: CALL_OW 2
59258: ST_TO_ADDR
59259: GO 59222
59261: POP
59262: POP
// if not tmp then
59263: LD_VAR 0 5
59267: NOT
59268: IFFALSE 59272
// exit ;
59270: GO 59320
// if asc then
59272: LD_VAR 0 2
59276: IFFALSE 59300
// result := SortListByListAsc ( units , tmp ) else
59278: LD_ADDR_VAR 0 3
59282: PUSH
59283: LD_VAR 0 1
59287: PPUSH
59288: LD_VAR 0 5
59292: PPUSH
59293: CALL_OW 76
59297: ST_TO_ADDR
59298: GO 59320
// result := SortListByListDesc ( units , tmp ) ;
59300: LD_ADDR_VAR 0 3
59304: PUSH
59305: LD_VAR 0 1
59309: PPUSH
59310: LD_VAR 0 5
59314: PPUSH
59315: CALL_OW 77
59319: ST_TO_ADDR
// end ;
59320: LD_VAR 0 3
59324: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59325: LD_INT 0
59327: PPUSH
59328: PPUSH
// task := GetTaskList ( mech ) ;
59329: LD_ADDR_VAR 0 4
59333: PUSH
59334: LD_VAR 0 1
59338: PPUSH
59339: CALL_OW 437
59343: ST_TO_ADDR
// if not task then
59344: LD_VAR 0 4
59348: NOT
59349: IFFALSE 59353
// exit ;
59351: GO 59395
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59353: LD_ADDR_VAR 0 3
59357: PUSH
59358: LD_VAR 0 4
59362: PUSH
59363: LD_INT 1
59365: ARRAY
59366: PUSH
59367: LD_INT 1
59369: ARRAY
59370: PUSH
59371: LD_STRING r
59373: EQUAL
59374: PUSH
59375: LD_VAR 0 4
59379: PUSH
59380: LD_INT 1
59382: ARRAY
59383: PUSH
59384: LD_INT 4
59386: ARRAY
59387: PUSH
59388: LD_VAR 0 2
59392: EQUAL
59393: AND
59394: ST_TO_ADDR
// end ;
59395: LD_VAR 0 3
59399: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59400: LD_INT 0
59402: PPUSH
// SetDir ( unit , d ) ;
59403: LD_VAR 0 1
59407: PPUSH
59408: LD_VAR 0 4
59412: PPUSH
59413: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59417: LD_VAR 0 1
59421: PPUSH
59422: LD_VAR 0 2
59426: PPUSH
59427: LD_VAR 0 3
59431: PPUSH
59432: LD_VAR 0 5
59436: PPUSH
59437: CALL_OW 48
// end ;
59441: LD_VAR 0 6
59445: RET
// export function ToNaturalNumber ( number ) ; begin
59446: LD_INT 0
59448: PPUSH
// result := number div 1 ;
59449: LD_ADDR_VAR 0 2
59453: PUSH
59454: LD_VAR 0 1
59458: PUSH
59459: LD_INT 1
59461: DIV
59462: ST_TO_ADDR
// if number < 0 then
59463: LD_VAR 0 1
59467: PUSH
59468: LD_INT 0
59470: LESS
59471: IFFALSE 59481
// result := 0 ;
59473: LD_ADDR_VAR 0 2
59477: PUSH
59478: LD_INT 0
59480: ST_TO_ADDR
// end ;
59481: LD_VAR 0 2
59485: RET
// export function SortByClass ( units , class ) ; var un ; begin
59486: LD_INT 0
59488: PPUSH
59489: PPUSH
// if not units or not class then
59490: LD_VAR 0 1
59494: NOT
59495: PUSH
59496: LD_VAR 0 2
59500: NOT
59501: OR
59502: IFFALSE 59506
// exit ;
59504: GO 59601
// result := [ ] ;
59506: LD_ADDR_VAR 0 3
59510: PUSH
59511: EMPTY
59512: ST_TO_ADDR
// for un in units do
59513: LD_ADDR_VAR 0 4
59517: PUSH
59518: LD_VAR 0 1
59522: PUSH
59523: FOR_IN
59524: IFFALSE 59599
// if GetClass ( un ) = class then
59526: LD_VAR 0 4
59530: PPUSH
59531: CALL_OW 257
59535: PUSH
59536: LD_VAR 0 2
59540: EQUAL
59541: IFFALSE 59568
// result := Insert ( result , 1 , un ) else
59543: LD_ADDR_VAR 0 3
59547: PUSH
59548: LD_VAR 0 3
59552: PPUSH
59553: LD_INT 1
59555: PPUSH
59556: LD_VAR 0 4
59560: PPUSH
59561: CALL_OW 2
59565: ST_TO_ADDR
59566: GO 59597
// result := Replace ( result , result + 1 , un ) ;
59568: LD_ADDR_VAR 0 3
59572: PUSH
59573: LD_VAR 0 3
59577: PPUSH
59578: LD_VAR 0 3
59582: PUSH
59583: LD_INT 1
59585: PLUS
59586: PPUSH
59587: LD_VAR 0 4
59591: PPUSH
59592: CALL_OW 1
59596: ST_TO_ADDR
59597: GO 59523
59599: POP
59600: POP
// end ;
59601: LD_VAR 0 3
59605: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59606: LD_INT 0
59608: PPUSH
59609: PPUSH
59610: PPUSH
59611: PPUSH
59612: PPUSH
59613: PPUSH
59614: PPUSH
// result := [ ] ;
59615: LD_ADDR_VAR 0 4
59619: PUSH
59620: EMPTY
59621: ST_TO_ADDR
// if x - r < 0 then
59622: LD_VAR 0 1
59626: PUSH
59627: LD_VAR 0 3
59631: MINUS
59632: PUSH
59633: LD_INT 0
59635: LESS
59636: IFFALSE 59648
// min_x := 0 else
59638: LD_ADDR_VAR 0 8
59642: PUSH
59643: LD_INT 0
59645: ST_TO_ADDR
59646: GO 59664
// min_x := x - r ;
59648: LD_ADDR_VAR 0 8
59652: PUSH
59653: LD_VAR 0 1
59657: PUSH
59658: LD_VAR 0 3
59662: MINUS
59663: ST_TO_ADDR
// if y - r < 0 then
59664: LD_VAR 0 2
59668: PUSH
59669: LD_VAR 0 3
59673: MINUS
59674: PUSH
59675: LD_INT 0
59677: LESS
59678: IFFALSE 59690
// min_y := 0 else
59680: LD_ADDR_VAR 0 7
59684: PUSH
59685: LD_INT 0
59687: ST_TO_ADDR
59688: GO 59706
// min_y := y - r ;
59690: LD_ADDR_VAR 0 7
59694: PUSH
59695: LD_VAR 0 2
59699: PUSH
59700: LD_VAR 0 3
59704: MINUS
59705: ST_TO_ADDR
// max_x := x + r ;
59706: LD_ADDR_VAR 0 9
59710: PUSH
59711: LD_VAR 0 1
59715: PUSH
59716: LD_VAR 0 3
59720: PLUS
59721: ST_TO_ADDR
// max_y := y + r ;
59722: LD_ADDR_VAR 0 10
59726: PUSH
59727: LD_VAR 0 2
59731: PUSH
59732: LD_VAR 0 3
59736: PLUS
59737: ST_TO_ADDR
// for _x = min_x to max_x do
59738: LD_ADDR_VAR 0 5
59742: PUSH
59743: DOUBLE
59744: LD_VAR 0 8
59748: DEC
59749: ST_TO_ADDR
59750: LD_VAR 0 9
59754: PUSH
59755: FOR_TO
59756: IFFALSE 59857
// for _y = min_y to max_y do
59758: LD_ADDR_VAR 0 6
59762: PUSH
59763: DOUBLE
59764: LD_VAR 0 7
59768: DEC
59769: ST_TO_ADDR
59770: LD_VAR 0 10
59774: PUSH
59775: FOR_TO
59776: IFFALSE 59853
// begin if not ValidHex ( _x , _y ) then
59778: LD_VAR 0 5
59782: PPUSH
59783: LD_VAR 0 6
59787: PPUSH
59788: CALL_OW 488
59792: NOT
59793: IFFALSE 59797
// continue ;
59795: GO 59775
// if GetResourceTypeXY ( _x , _y ) then
59797: LD_VAR 0 5
59801: PPUSH
59802: LD_VAR 0 6
59806: PPUSH
59807: CALL_OW 283
59811: IFFALSE 59851
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59813: LD_ADDR_VAR 0 4
59817: PUSH
59818: LD_VAR 0 4
59822: PPUSH
59823: LD_VAR 0 4
59827: PUSH
59828: LD_INT 1
59830: PLUS
59831: PPUSH
59832: LD_VAR 0 5
59836: PUSH
59837: LD_VAR 0 6
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PPUSH
59846: CALL_OW 1
59850: ST_TO_ADDR
// end ;
59851: GO 59775
59853: POP
59854: POP
59855: GO 59755
59857: POP
59858: POP
// end ;
59859: LD_VAR 0 4
59863: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59864: LD_INT 0
59866: PPUSH
59867: PPUSH
59868: PPUSH
59869: PPUSH
59870: PPUSH
59871: PPUSH
59872: PPUSH
59873: PPUSH
// if not units then
59874: LD_VAR 0 1
59878: NOT
59879: IFFALSE 59883
// exit ;
59881: GO 60407
// result := UnitFilter ( units , [ f_ok ] ) ;
59883: LD_ADDR_VAR 0 3
59887: PUSH
59888: LD_VAR 0 1
59892: PPUSH
59893: LD_INT 50
59895: PUSH
59896: EMPTY
59897: LIST
59898: PPUSH
59899: CALL_OW 72
59903: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59904: LD_ADDR_VAR 0 8
59908: PUSH
59909: LD_VAR 0 1
59913: PUSH
59914: LD_INT 1
59916: ARRAY
59917: PPUSH
59918: CALL_OW 255
59922: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59923: LD_ADDR_VAR 0 10
59927: PUSH
59928: LD_INT 29
59930: PUSH
59931: LD_INT 91
59933: PUSH
59934: LD_INT 49
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: LIST
59941: ST_TO_ADDR
// if not result then
59942: LD_VAR 0 3
59946: NOT
59947: IFFALSE 59951
// exit ;
59949: GO 60407
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59951: LD_ADDR_VAR 0 5
59955: PUSH
59956: LD_INT 81
59958: PUSH
59959: LD_VAR 0 8
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: PPUSH
59968: CALL_OW 69
59972: ST_TO_ADDR
// for i in result do
59973: LD_ADDR_VAR 0 4
59977: PUSH
59978: LD_VAR 0 3
59982: PUSH
59983: FOR_IN
59984: IFFALSE 60405
// begin tag := GetTag ( i ) + 1 ;
59986: LD_ADDR_VAR 0 9
59990: PUSH
59991: LD_VAR 0 4
59995: PPUSH
59996: CALL_OW 110
60000: PUSH
60001: LD_INT 1
60003: PLUS
60004: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60005: LD_ADDR_VAR 0 7
60009: PUSH
60010: LD_VAR 0 4
60014: PPUSH
60015: CALL_OW 250
60019: PPUSH
60020: LD_VAR 0 4
60024: PPUSH
60025: CALL_OW 251
60029: PPUSH
60030: LD_INT 6
60032: PPUSH
60033: CALL 59606 0 3
60037: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60038: LD_VAR 0 4
60042: PPUSH
60043: CALL_OW 247
60047: PUSH
60048: LD_INT 2
60050: EQUAL
60051: PUSH
60052: LD_VAR 0 7
60056: AND
60057: PUSH
60058: LD_VAR 0 4
60062: PPUSH
60063: CALL_OW 264
60067: PUSH
60068: LD_VAR 0 10
60072: IN
60073: NOT
60074: AND
60075: IFFALSE 60114
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60077: LD_VAR 0 4
60081: PPUSH
60082: LD_VAR 0 7
60086: PUSH
60087: LD_INT 1
60089: ARRAY
60090: PUSH
60091: LD_INT 1
60093: ARRAY
60094: PPUSH
60095: LD_VAR 0 7
60099: PUSH
60100: LD_INT 1
60102: ARRAY
60103: PUSH
60104: LD_INT 2
60106: ARRAY
60107: PPUSH
60108: CALL_OW 116
60112: GO 60403
// if path > tag then
60114: LD_VAR 0 2
60118: PUSH
60119: LD_VAR 0 9
60123: GREATER
60124: IFFALSE 60332
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60126: LD_ADDR_VAR 0 6
60130: PUSH
60131: LD_VAR 0 5
60135: PPUSH
60136: LD_INT 91
60138: PUSH
60139: LD_VAR 0 4
60143: PUSH
60144: LD_INT 8
60146: PUSH
60147: EMPTY
60148: LIST
60149: LIST
60150: LIST
60151: PPUSH
60152: CALL_OW 72
60156: ST_TO_ADDR
// if nearEnemy then
60157: LD_VAR 0 6
60161: IFFALSE 60230
// begin if GetWeapon ( i ) = ru_time_lapser then
60163: LD_VAR 0 4
60167: PPUSH
60168: CALL_OW 264
60172: PUSH
60173: LD_INT 49
60175: EQUAL
60176: IFFALSE 60204
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60178: LD_VAR 0 4
60182: PPUSH
60183: LD_VAR 0 6
60187: PPUSH
60188: LD_VAR 0 4
60192: PPUSH
60193: CALL_OW 74
60197: PPUSH
60198: CALL_OW 112
60202: GO 60228
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60204: LD_VAR 0 4
60208: PPUSH
60209: LD_VAR 0 6
60213: PPUSH
60214: LD_VAR 0 4
60218: PPUSH
60219: CALL_OW 74
60223: PPUSH
60224: CALL_OW 115
// end else
60228: GO 60330
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60230: LD_VAR 0 4
60234: PPUSH
60235: LD_VAR 0 2
60239: PUSH
60240: LD_VAR 0 9
60244: ARRAY
60245: PUSH
60246: LD_INT 1
60248: ARRAY
60249: PPUSH
60250: LD_VAR 0 2
60254: PUSH
60255: LD_VAR 0 9
60259: ARRAY
60260: PUSH
60261: LD_INT 2
60263: ARRAY
60264: PPUSH
60265: CALL_OW 297
60269: PUSH
60270: LD_INT 6
60272: GREATER
60273: IFFALSE 60316
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60275: LD_VAR 0 4
60279: PPUSH
60280: LD_VAR 0 2
60284: PUSH
60285: LD_VAR 0 9
60289: ARRAY
60290: PUSH
60291: LD_INT 1
60293: ARRAY
60294: PPUSH
60295: LD_VAR 0 2
60299: PUSH
60300: LD_VAR 0 9
60304: ARRAY
60305: PUSH
60306: LD_INT 2
60308: ARRAY
60309: PPUSH
60310: CALL_OW 114
60314: GO 60330
// SetTag ( i , tag ) ;
60316: LD_VAR 0 4
60320: PPUSH
60321: LD_VAR 0 9
60325: PPUSH
60326: CALL_OW 109
// end else
60330: GO 60403
// if enemy then
60332: LD_VAR 0 5
60336: IFFALSE 60403
// begin if GetWeapon ( i ) = ru_time_lapser then
60338: LD_VAR 0 4
60342: PPUSH
60343: CALL_OW 264
60347: PUSH
60348: LD_INT 49
60350: EQUAL
60351: IFFALSE 60379
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60353: LD_VAR 0 4
60357: PPUSH
60358: LD_VAR 0 5
60362: PPUSH
60363: LD_VAR 0 4
60367: PPUSH
60368: CALL_OW 74
60372: PPUSH
60373: CALL_OW 112
60377: GO 60403
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60379: LD_VAR 0 4
60383: PPUSH
60384: LD_VAR 0 5
60388: PPUSH
60389: LD_VAR 0 4
60393: PPUSH
60394: CALL_OW 74
60398: PPUSH
60399: CALL_OW 115
// end ; end ;
60403: GO 59983
60405: POP
60406: POP
// end ;
60407: LD_VAR 0 3
60411: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60412: LD_INT 0
60414: PPUSH
60415: PPUSH
60416: PPUSH
// if not unit or IsInUnit ( unit ) then
60417: LD_VAR 0 1
60421: NOT
60422: PUSH
60423: LD_VAR 0 1
60427: PPUSH
60428: CALL_OW 310
60432: OR
60433: IFFALSE 60437
// exit ;
60435: GO 60528
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60437: LD_ADDR_VAR 0 4
60441: PUSH
60442: LD_VAR 0 1
60446: PPUSH
60447: CALL_OW 250
60451: PPUSH
60452: LD_VAR 0 2
60456: PPUSH
60457: LD_INT 1
60459: PPUSH
60460: CALL_OW 272
60464: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60465: LD_ADDR_VAR 0 5
60469: PUSH
60470: LD_VAR 0 1
60474: PPUSH
60475: CALL_OW 251
60479: PPUSH
60480: LD_VAR 0 2
60484: PPUSH
60485: LD_INT 1
60487: PPUSH
60488: CALL_OW 273
60492: ST_TO_ADDR
// if ValidHex ( x , y ) then
60493: LD_VAR 0 4
60497: PPUSH
60498: LD_VAR 0 5
60502: PPUSH
60503: CALL_OW 488
60507: IFFALSE 60528
// ComTurnXY ( unit , x , y ) ;
60509: LD_VAR 0 1
60513: PPUSH
60514: LD_VAR 0 4
60518: PPUSH
60519: LD_VAR 0 5
60523: PPUSH
60524: CALL_OW 118
// end ;
60528: LD_VAR 0 3
60532: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60533: LD_INT 0
60535: PPUSH
60536: PPUSH
// result := false ;
60537: LD_ADDR_VAR 0 3
60541: PUSH
60542: LD_INT 0
60544: ST_TO_ADDR
// if not units then
60545: LD_VAR 0 2
60549: NOT
60550: IFFALSE 60554
// exit ;
60552: GO 60599
// for i in units do
60554: LD_ADDR_VAR 0 4
60558: PUSH
60559: LD_VAR 0 2
60563: PUSH
60564: FOR_IN
60565: IFFALSE 60597
// if See ( side , i ) then
60567: LD_VAR 0 1
60571: PPUSH
60572: LD_VAR 0 4
60576: PPUSH
60577: CALL_OW 292
60581: IFFALSE 60595
// begin result := true ;
60583: LD_ADDR_VAR 0 3
60587: PUSH
60588: LD_INT 1
60590: ST_TO_ADDR
// exit ;
60591: POP
60592: POP
60593: GO 60599
// end ;
60595: GO 60564
60597: POP
60598: POP
// end ;
60599: LD_VAR 0 3
60603: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60604: LD_INT 0
60606: PPUSH
60607: PPUSH
60608: PPUSH
60609: PPUSH
// if not unit or not points then
60610: LD_VAR 0 1
60614: NOT
60615: PUSH
60616: LD_VAR 0 2
60620: NOT
60621: OR
60622: IFFALSE 60626
// exit ;
60624: GO 60716
// dist := 99999 ;
60626: LD_ADDR_VAR 0 5
60630: PUSH
60631: LD_INT 99999
60633: ST_TO_ADDR
// for i in points do
60634: LD_ADDR_VAR 0 4
60638: PUSH
60639: LD_VAR 0 2
60643: PUSH
60644: FOR_IN
60645: IFFALSE 60714
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60647: LD_ADDR_VAR 0 6
60651: PUSH
60652: LD_VAR 0 1
60656: PPUSH
60657: LD_VAR 0 4
60661: PUSH
60662: LD_INT 1
60664: ARRAY
60665: PPUSH
60666: LD_VAR 0 4
60670: PUSH
60671: LD_INT 2
60673: ARRAY
60674: PPUSH
60675: CALL_OW 297
60679: ST_TO_ADDR
// if tmpDist < dist then
60680: LD_VAR 0 6
60684: PUSH
60685: LD_VAR 0 5
60689: LESS
60690: IFFALSE 60712
// begin result := i ;
60692: LD_ADDR_VAR 0 3
60696: PUSH
60697: LD_VAR 0 4
60701: ST_TO_ADDR
// dist := tmpDist ;
60702: LD_ADDR_VAR 0 5
60706: PUSH
60707: LD_VAR 0 6
60711: ST_TO_ADDR
// end ; end ;
60712: GO 60644
60714: POP
60715: POP
// end ;
60716: LD_VAR 0 3
60720: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60721: LD_INT 0
60723: PPUSH
// uc_side := side ;
60724: LD_ADDR_OWVAR 20
60728: PUSH
60729: LD_VAR 0 1
60733: ST_TO_ADDR
// uc_nation := 3 ;
60734: LD_ADDR_OWVAR 21
60738: PUSH
60739: LD_INT 3
60741: ST_TO_ADDR
// vc_chassis := 25 ;
60742: LD_ADDR_OWVAR 37
60746: PUSH
60747: LD_INT 25
60749: ST_TO_ADDR
// vc_engine := engine_siberite ;
60750: LD_ADDR_OWVAR 39
60754: PUSH
60755: LD_INT 3
60757: ST_TO_ADDR
// vc_control := control_computer ;
60758: LD_ADDR_OWVAR 38
60762: PUSH
60763: LD_INT 3
60765: ST_TO_ADDR
// vc_weapon := 59 ;
60766: LD_ADDR_OWVAR 40
60770: PUSH
60771: LD_INT 59
60773: ST_TO_ADDR
// result := CreateVehicle ;
60774: LD_ADDR_VAR 0 5
60778: PUSH
60779: CALL_OW 45
60783: ST_TO_ADDR
// SetDir ( result , d ) ;
60784: LD_VAR 0 5
60788: PPUSH
60789: LD_VAR 0 4
60793: PPUSH
60794: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60798: LD_VAR 0 5
60802: PPUSH
60803: LD_VAR 0 2
60807: PPUSH
60808: LD_VAR 0 3
60812: PPUSH
60813: LD_INT 0
60815: PPUSH
60816: CALL_OW 48
// end ;
60820: LD_VAR 0 5
60824: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60825: LD_INT 0
60827: PPUSH
60828: PPUSH
60829: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60830: LD_ADDR_VAR 0 2
60834: PUSH
60835: LD_INT 0
60837: PUSH
60838: LD_INT 0
60840: PUSH
60841: LD_INT 0
60843: PUSH
60844: LD_INT 0
60846: PUSH
60847: EMPTY
60848: LIST
60849: LIST
60850: LIST
60851: LIST
60852: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60853: LD_VAR 0 1
60857: NOT
60858: PUSH
60859: LD_VAR 0 1
60863: PPUSH
60864: CALL_OW 264
60868: PUSH
60869: LD_INT 12
60871: PUSH
60872: LD_INT 51
60874: PUSH
60875: LD_INT 32
60877: PUSH
60878: LD_INT 89
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: IN
60887: NOT
60888: OR
60889: IFFALSE 60893
// exit ;
60891: GO 60991
// for i := 1 to 3 do
60893: LD_ADDR_VAR 0 3
60897: PUSH
60898: DOUBLE
60899: LD_INT 1
60901: DEC
60902: ST_TO_ADDR
60903: LD_INT 3
60905: PUSH
60906: FOR_TO
60907: IFFALSE 60989
// begin tmp := GetCargo ( cargo , i ) ;
60909: LD_ADDR_VAR 0 4
60913: PUSH
60914: LD_VAR 0 1
60918: PPUSH
60919: LD_VAR 0 3
60923: PPUSH
60924: CALL_OW 289
60928: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60929: LD_ADDR_VAR 0 2
60933: PUSH
60934: LD_VAR 0 2
60938: PPUSH
60939: LD_VAR 0 3
60943: PPUSH
60944: LD_VAR 0 4
60948: PPUSH
60949: CALL_OW 1
60953: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60954: LD_ADDR_VAR 0 2
60958: PUSH
60959: LD_VAR 0 2
60963: PPUSH
60964: LD_INT 4
60966: PPUSH
60967: LD_VAR 0 2
60971: PUSH
60972: LD_INT 4
60974: ARRAY
60975: PUSH
60976: LD_VAR 0 4
60980: PLUS
60981: PPUSH
60982: CALL_OW 1
60986: ST_TO_ADDR
// end ;
60987: GO 60906
60989: POP
60990: POP
// end ;
60991: LD_VAR 0 2
60995: RET
// export function Length ( array ) ; begin
60996: LD_INT 0
60998: PPUSH
// result := array + 0 ;
60999: LD_ADDR_VAR 0 2
61003: PUSH
61004: LD_VAR 0 1
61008: PUSH
61009: LD_INT 0
61011: PLUS
61012: ST_TO_ADDR
// end ;
61013: LD_VAR 0 2
61017: RET
// export function PrepareArray ( array ) ; begin
61018: LD_INT 0
61020: PPUSH
// result := array diff 0 ;
61021: LD_ADDR_VAR 0 2
61025: PUSH
61026: LD_VAR 0 1
61030: PUSH
61031: LD_INT 0
61033: DIFF
61034: ST_TO_ADDR
// if not result [ 1 ] then
61035: LD_VAR 0 2
61039: PUSH
61040: LD_INT 1
61042: ARRAY
61043: NOT
61044: IFFALSE 61064
// result := Delete ( result , 1 ) ;
61046: LD_ADDR_VAR 0 2
61050: PUSH
61051: LD_VAR 0 2
61055: PPUSH
61056: LD_INT 1
61058: PPUSH
61059: CALL_OW 3
61063: ST_TO_ADDR
// end ; end_of_file
61064: LD_VAR 0 2
61068: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
61069: LD_INT 0
61071: PPUSH
61072: PPUSH
// skirmish := false ;
61073: LD_ADDR_EXP 29
61077: PUSH
61078: LD_INT 0
61080: ST_TO_ADDR
// debug_mc := false ;
61081: LD_ADDR_EXP 30
61085: PUSH
61086: LD_INT 0
61088: ST_TO_ADDR
// mc_bases := [ ] ;
61089: LD_ADDR_EXP 31
61093: PUSH
61094: EMPTY
61095: ST_TO_ADDR
// mc_sides := [ ] ;
61096: LD_ADDR_EXP 57
61100: PUSH
61101: EMPTY
61102: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61103: LD_ADDR_EXP 32
61107: PUSH
61108: EMPTY
61109: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61110: LD_ADDR_EXP 33
61114: PUSH
61115: EMPTY
61116: ST_TO_ADDR
// mc_need_heal := [ ] ;
61117: LD_ADDR_EXP 34
61121: PUSH
61122: EMPTY
61123: ST_TO_ADDR
// mc_healers := [ ] ;
61124: LD_ADDR_EXP 35
61128: PUSH
61129: EMPTY
61130: ST_TO_ADDR
// mc_build_list := [ ] ;
61131: LD_ADDR_EXP 36
61135: PUSH
61136: EMPTY
61137: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61138: LD_ADDR_EXP 63
61142: PUSH
61143: EMPTY
61144: ST_TO_ADDR
// mc_builders := [ ] ;
61145: LD_ADDR_EXP 37
61149: PUSH
61150: EMPTY
61151: ST_TO_ADDR
// mc_construct_list := [ ] ;
61152: LD_ADDR_EXP 38
61156: PUSH
61157: EMPTY
61158: ST_TO_ADDR
// mc_turret_list := [ ] ;
61159: LD_ADDR_EXP 39
61163: PUSH
61164: EMPTY
61165: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61166: LD_ADDR_EXP 40
61170: PUSH
61171: EMPTY
61172: ST_TO_ADDR
// mc_miners := [ ] ;
61173: LD_ADDR_EXP 45
61177: PUSH
61178: EMPTY
61179: ST_TO_ADDR
// mc_mines := [ ] ;
61180: LD_ADDR_EXP 44
61184: PUSH
61185: EMPTY
61186: ST_TO_ADDR
// mc_minefields := [ ] ;
61187: LD_ADDR_EXP 46
61191: PUSH
61192: EMPTY
61193: ST_TO_ADDR
// mc_crates := [ ] ;
61194: LD_ADDR_EXP 47
61198: PUSH
61199: EMPTY
61200: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61201: LD_ADDR_EXP 48
61205: PUSH
61206: EMPTY
61207: ST_TO_ADDR
// mc_crates_area := [ ] ;
61208: LD_ADDR_EXP 49
61212: PUSH
61213: EMPTY
61214: ST_TO_ADDR
// mc_vehicles := [ ] ;
61215: LD_ADDR_EXP 50
61219: PUSH
61220: EMPTY
61221: ST_TO_ADDR
// mc_attack := [ ] ;
61222: LD_ADDR_EXP 51
61226: PUSH
61227: EMPTY
61228: ST_TO_ADDR
// mc_produce := [ ] ;
61229: LD_ADDR_EXP 52
61233: PUSH
61234: EMPTY
61235: ST_TO_ADDR
// mc_defender := [ ] ;
61236: LD_ADDR_EXP 53
61240: PUSH
61241: EMPTY
61242: ST_TO_ADDR
// mc_parking := [ ] ;
61243: LD_ADDR_EXP 55
61247: PUSH
61248: EMPTY
61249: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61250: LD_ADDR_EXP 41
61254: PUSH
61255: EMPTY
61256: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61257: LD_ADDR_EXP 43
61261: PUSH
61262: EMPTY
61263: ST_TO_ADDR
// mc_scan := [ ] ;
61264: LD_ADDR_EXP 54
61268: PUSH
61269: EMPTY
61270: ST_TO_ADDR
// mc_scan_area := [ ] ;
61271: LD_ADDR_EXP 56
61275: PUSH
61276: EMPTY
61277: ST_TO_ADDR
// mc_tech := [ ] ;
61278: LD_ADDR_EXP 58
61282: PUSH
61283: EMPTY
61284: ST_TO_ADDR
// mc_class := [ ] ;
61285: LD_ADDR_EXP 72
61289: PUSH
61290: EMPTY
61291: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61292: LD_ADDR_EXP 73
61296: PUSH
61297: EMPTY
61298: ST_TO_ADDR
// mc_is_defending := [ ] ;
61299: LD_ADDR_EXP 74
61303: PUSH
61304: EMPTY
61305: ST_TO_ADDR
// end ;
61306: LD_VAR 0 1
61310: RET
// export function MC_Kill ( base ) ; begin
61311: LD_INT 0
61313: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61314: LD_ADDR_EXP 31
61318: PUSH
61319: LD_EXP 31
61323: PPUSH
61324: LD_VAR 0 1
61328: PPUSH
61329: EMPTY
61330: PPUSH
61331: CALL_OW 1
61335: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61336: LD_ADDR_EXP 32
61340: PUSH
61341: LD_EXP 32
61345: PPUSH
61346: LD_VAR 0 1
61350: PPUSH
61351: EMPTY
61352: PPUSH
61353: CALL_OW 1
61357: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61358: LD_ADDR_EXP 33
61362: PUSH
61363: LD_EXP 33
61367: PPUSH
61368: LD_VAR 0 1
61372: PPUSH
61373: EMPTY
61374: PPUSH
61375: CALL_OW 1
61379: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61380: LD_ADDR_EXP 34
61384: PUSH
61385: LD_EXP 34
61389: PPUSH
61390: LD_VAR 0 1
61394: PPUSH
61395: EMPTY
61396: PPUSH
61397: CALL_OW 1
61401: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61402: LD_ADDR_EXP 35
61406: PUSH
61407: LD_EXP 35
61411: PPUSH
61412: LD_VAR 0 1
61416: PPUSH
61417: EMPTY
61418: PPUSH
61419: CALL_OW 1
61423: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61424: LD_ADDR_EXP 36
61428: PUSH
61429: LD_EXP 36
61433: PPUSH
61434: LD_VAR 0 1
61438: PPUSH
61439: EMPTY
61440: PPUSH
61441: CALL_OW 1
61445: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61446: LD_ADDR_EXP 37
61450: PUSH
61451: LD_EXP 37
61455: PPUSH
61456: LD_VAR 0 1
61460: PPUSH
61461: EMPTY
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61468: LD_ADDR_EXP 38
61472: PUSH
61473: LD_EXP 38
61477: PPUSH
61478: LD_VAR 0 1
61482: PPUSH
61483: EMPTY
61484: PPUSH
61485: CALL_OW 1
61489: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61490: LD_ADDR_EXP 39
61494: PUSH
61495: LD_EXP 39
61499: PPUSH
61500: LD_VAR 0 1
61504: PPUSH
61505: EMPTY
61506: PPUSH
61507: CALL_OW 1
61511: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61512: LD_ADDR_EXP 40
61516: PUSH
61517: LD_EXP 40
61521: PPUSH
61522: LD_VAR 0 1
61526: PPUSH
61527: EMPTY
61528: PPUSH
61529: CALL_OW 1
61533: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61534: LD_ADDR_EXP 41
61538: PUSH
61539: LD_EXP 41
61543: PPUSH
61544: LD_VAR 0 1
61548: PPUSH
61549: EMPTY
61550: PPUSH
61551: CALL_OW 1
61555: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61556: LD_ADDR_EXP 42
61560: PUSH
61561: LD_EXP 42
61565: PPUSH
61566: LD_VAR 0 1
61570: PPUSH
61571: LD_INT 0
61573: PPUSH
61574: CALL_OW 1
61578: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61579: LD_ADDR_EXP 43
61583: PUSH
61584: LD_EXP 43
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: EMPTY
61595: PPUSH
61596: CALL_OW 1
61600: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61601: LD_ADDR_EXP 44
61605: PUSH
61606: LD_EXP 44
61610: PPUSH
61611: LD_VAR 0 1
61615: PPUSH
61616: EMPTY
61617: PPUSH
61618: CALL_OW 1
61622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61623: LD_ADDR_EXP 45
61627: PUSH
61628: LD_EXP 45
61632: PPUSH
61633: LD_VAR 0 1
61637: PPUSH
61638: EMPTY
61639: PPUSH
61640: CALL_OW 1
61644: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61645: LD_ADDR_EXP 46
61649: PUSH
61650: LD_EXP 46
61654: PPUSH
61655: LD_VAR 0 1
61659: PPUSH
61660: EMPTY
61661: PPUSH
61662: CALL_OW 1
61666: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61667: LD_ADDR_EXP 47
61671: PUSH
61672: LD_EXP 47
61676: PPUSH
61677: LD_VAR 0 1
61681: PPUSH
61682: EMPTY
61683: PPUSH
61684: CALL_OW 1
61688: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61689: LD_ADDR_EXP 48
61693: PUSH
61694: LD_EXP 48
61698: PPUSH
61699: LD_VAR 0 1
61703: PPUSH
61704: EMPTY
61705: PPUSH
61706: CALL_OW 1
61710: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61711: LD_ADDR_EXP 49
61715: PUSH
61716: LD_EXP 49
61720: PPUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: EMPTY
61727: PPUSH
61728: CALL_OW 1
61732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61733: LD_ADDR_EXP 50
61737: PUSH
61738: LD_EXP 50
61742: PPUSH
61743: LD_VAR 0 1
61747: PPUSH
61748: EMPTY
61749: PPUSH
61750: CALL_OW 1
61754: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61755: LD_ADDR_EXP 51
61759: PUSH
61760: LD_EXP 51
61764: PPUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: EMPTY
61771: PPUSH
61772: CALL_OW 1
61776: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61777: LD_ADDR_EXP 52
61781: PUSH
61782: LD_EXP 52
61786: PPUSH
61787: LD_VAR 0 1
61791: PPUSH
61792: EMPTY
61793: PPUSH
61794: CALL_OW 1
61798: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61799: LD_ADDR_EXP 53
61803: PUSH
61804: LD_EXP 53
61808: PPUSH
61809: LD_VAR 0 1
61813: PPUSH
61814: EMPTY
61815: PPUSH
61816: CALL_OW 1
61820: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61821: LD_ADDR_EXP 54
61825: PUSH
61826: LD_EXP 54
61830: PPUSH
61831: LD_VAR 0 1
61835: PPUSH
61836: EMPTY
61837: PPUSH
61838: CALL_OW 1
61842: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61843: LD_ADDR_EXP 55
61847: PUSH
61848: LD_EXP 55
61852: PPUSH
61853: LD_VAR 0 1
61857: PPUSH
61858: EMPTY
61859: PPUSH
61860: CALL_OW 1
61864: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61865: LD_ADDR_EXP 56
61869: PUSH
61870: LD_EXP 56
61874: PPUSH
61875: LD_VAR 0 1
61879: PPUSH
61880: EMPTY
61881: PPUSH
61882: CALL_OW 1
61886: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61887: LD_ADDR_EXP 58
61891: PUSH
61892: LD_EXP 58
61896: PPUSH
61897: LD_VAR 0 1
61901: PPUSH
61902: EMPTY
61903: PPUSH
61904: CALL_OW 1
61908: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61909: LD_ADDR_EXP 60
61913: PUSH
61914: LD_EXP 60
61918: PPUSH
61919: LD_VAR 0 1
61923: PPUSH
61924: EMPTY
61925: PPUSH
61926: CALL_OW 1
61930: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61931: LD_ADDR_EXP 61
61935: PUSH
61936: LD_EXP 61
61940: PPUSH
61941: LD_VAR 0 1
61945: PPUSH
61946: EMPTY
61947: PPUSH
61948: CALL_OW 1
61952: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61953: LD_ADDR_EXP 62
61957: PUSH
61958: LD_EXP 62
61962: PPUSH
61963: LD_VAR 0 1
61967: PPUSH
61968: EMPTY
61969: PPUSH
61970: CALL_OW 1
61974: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61975: LD_ADDR_EXP 63
61979: PUSH
61980: LD_EXP 63
61984: PPUSH
61985: LD_VAR 0 1
61989: PPUSH
61990: EMPTY
61991: PPUSH
61992: CALL_OW 1
61996: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61997: LD_ADDR_EXP 64
62001: PUSH
62002: LD_EXP 64
62006: PPUSH
62007: LD_VAR 0 1
62011: PPUSH
62012: EMPTY
62013: PPUSH
62014: CALL_OW 1
62018: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62019: LD_ADDR_EXP 65
62023: PUSH
62024: LD_EXP 65
62028: PPUSH
62029: LD_VAR 0 1
62033: PPUSH
62034: EMPTY
62035: PPUSH
62036: CALL_OW 1
62040: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62041: LD_ADDR_EXP 66
62045: PUSH
62046: LD_EXP 66
62050: PPUSH
62051: LD_VAR 0 1
62055: PPUSH
62056: EMPTY
62057: PPUSH
62058: CALL_OW 1
62062: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62063: LD_ADDR_EXP 67
62067: PUSH
62068: LD_EXP 67
62072: PPUSH
62073: LD_VAR 0 1
62077: PPUSH
62078: EMPTY
62079: PPUSH
62080: CALL_OW 1
62084: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62085: LD_ADDR_EXP 68
62089: PUSH
62090: LD_EXP 68
62094: PPUSH
62095: LD_VAR 0 1
62099: PPUSH
62100: EMPTY
62101: PPUSH
62102: CALL_OW 1
62106: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62107: LD_ADDR_EXP 69
62111: PUSH
62112: LD_EXP 69
62116: PPUSH
62117: LD_VAR 0 1
62121: PPUSH
62122: EMPTY
62123: PPUSH
62124: CALL_OW 1
62128: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62129: LD_ADDR_EXP 70
62133: PUSH
62134: LD_EXP 70
62138: PPUSH
62139: LD_VAR 0 1
62143: PPUSH
62144: EMPTY
62145: PPUSH
62146: CALL_OW 1
62150: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62151: LD_ADDR_EXP 71
62155: PUSH
62156: LD_EXP 71
62160: PPUSH
62161: LD_VAR 0 1
62165: PPUSH
62166: EMPTY
62167: PPUSH
62168: CALL_OW 1
62172: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62173: LD_ADDR_EXP 72
62177: PUSH
62178: LD_EXP 72
62182: PPUSH
62183: LD_VAR 0 1
62187: PPUSH
62188: EMPTY
62189: PPUSH
62190: CALL_OW 1
62194: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62195: LD_ADDR_EXP 73
62199: PUSH
62200: LD_EXP 73
62204: PPUSH
62205: LD_VAR 0 1
62209: PPUSH
62210: LD_INT 0
62212: PPUSH
62213: CALL_OW 1
62217: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62218: LD_ADDR_EXP 74
62222: PUSH
62223: LD_EXP 74
62227: PPUSH
62228: LD_VAR 0 1
62232: PPUSH
62233: LD_INT 0
62235: PPUSH
62236: CALL_OW 1
62240: ST_TO_ADDR
// end ;
62241: LD_VAR 0 2
62245: RET
// export function MC_Add ( side , units ) ; var base ; begin
62246: LD_INT 0
62248: PPUSH
62249: PPUSH
// base := mc_bases + 1 ;
62250: LD_ADDR_VAR 0 4
62254: PUSH
62255: LD_EXP 31
62259: PUSH
62260: LD_INT 1
62262: PLUS
62263: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62264: LD_ADDR_EXP 57
62268: PUSH
62269: LD_EXP 57
62273: PPUSH
62274: LD_VAR 0 4
62278: PPUSH
62279: LD_VAR 0 1
62283: PPUSH
62284: CALL_OW 1
62288: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62289: LD_ADDR_EXP 31
62293: PUSH
62294: LD_EXP 31
62298: PPUSH
62299: LD_VAR 0 4
62303: PPUSH
62304: LD_VAR 0 2
62308: PPUSH
62309: CALL_OW 1
62313: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62314: LD_ADDR_EXP 32
62318: PUSH
62319: LD_EXP 32
62323: PPUSH
62324: LD_VAR 0 4
62328: PPUSH
62329: EMPTY
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62336: LD_ADDR_EXP 33
62340: PUSH
62341: LD_EXP 33
62345: PPUSH
62346: LD_VAR 0 4
62350: PPUSH
62351: EMPTY
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62358: LD_ADDR_EXP 34
62362: PUSH
62363: LD_EXP 34
62367: PPUSH
62368: LD_VAR 0 4
62372: PPUSH
62373: EMPTY
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62380: LD_ADDR_EXP 35
62384: PUSH
62385: LD_EXP 35
62389: PPUSH
62390: LD_VAR 0 4
62394: PPUSH
62395: EMPTY
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62402: LD_ADDR_EXP 36
62406: PUSH
62407: LD_EXP 36
62411: PPUSH
62412: LD_VAR 0 4
62416: PPUSH
62417: EMPTY
62418: PPUSH
62419: CALL_OW 1
62423: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62424: LD_ADDR_EXP 37
62428: PUSH
62429: LD_EXP 37
62433: PPUSH
62434: LD_VAR 0 4
62438: PPUSH
62439: EMPTY
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62446: LD_ADDR_EXP 38
62450: PUSH
62451: LD_EXP 38
62455: PPUSH
62456: LD_VAR 0 4
62460: PPUSH
62461: EMPTY
62462: PPUSH
62463: CALL_OW 1
62467: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62468: LD_ADDR_EXP 39
62472: PUSH
62473: LD_EXP 39
62477: PPUSH
62478: LD_VAR 0 4
62482: PPUSH
62483: EMPTY
62484: PPUSH
62485: CALL_OW 1
62489: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62490: LD_ADDR_EXP 40
62494: PUSH
62495: LD_EXP 40
62499: PPUSH
62500: LD_VAR 0 4
62504: PPUSH
62505: EMPTY
62506: PPUSH
62507: CALL_OW 1
62511: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62512: LD_ADDR_EXP 41
62516: PUSH
62517: LD_EXP 41
62521: PPUSH
62522: LD_VAR 0 4
62526: PPUSH
62527: EMPTY
62528: PPUSH
62529: CALL_OW 1
62533: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62534: LD_ADDR_EXP 42
62538: PUSH
62539: LD_EXP 42
62543: PPUSH
62544: LD_VAR 0 4
62548: PPUSH
62549: LD_INT 0
62551: PPUSH
62552: CALL_OW 1
62556: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62557: LD_ADDR_EXP 43
62561: PUSH
62562: LD_EXP 43
62566: PPUSH
62567: LD_VAR 0 4
62571: PPUSH
62572: EMPTY
62573: PPUSH
62574: CALL_OW 1
62578: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62579: LD_ADDR_EXP 44
62583: PUSH
62584: LD_EXP 44
62588: PPUSH
62589: LD_VAR 0 4
62593: PPUSH
62594: EMPTY
62595: PPUSH
62596: CALL_OW 1
62600: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62601: LD_ADDR_EXP 45
62605: PUSH
62606: LD_EXP 45
62610: PPUSH
62611: LD_VAR 0 4
62615: PPUSH
62616: EMPTY
62617: PPUSH
62618: CALL_OW 1
62622: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62623: LD_ADDR_EXP 46
62627: PUSH
62628: LD_EXP 46
62632: PPUSH
62633: LD_VAR 0 4
62637: PPUSH
62638: EMPTY
62639: PPUSH
62640: CALL_OW 1
62644: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62645: LD_ADDR_EXP 47
62649: PUSH
62650: LD_EXP 47
62654: PPUSH
62655: LD_VAR 0 4
62659: PPUSH
62660: EMPTY
62661: PPUSH
62662: CALL_OW 1
62666: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62667: LD_ADDR_EXP 48
62671: PUSH
62672: LD_EXP 48
62676: PPUSH
62677: LD_VAR 0 4
62681: PPUSH
62682: EMPTY
62683: PPUSH
62684: CALL_OW 1
62688: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62689: LD_ADDR_EXP 49
62693: PUSH
62694: LD_EXP 49
62698: PPUSH
62699: LD_VAR 0 4
62703: PPUSH
62704: EMPTY
62705: PPUSH
62706: CALL_OW 1
62710: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62711: LD_ADDR_EXP 50
62715: PUSH
62716: LD_EXP 50
62720: PPUSH
62721: LD_VAR 0 4
62725: PPUSH
62726: EMPTY
62727: PPUSH
62728: CALL_OW 1
62732: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62733: LD_ADDR_EXP 51
62737: PUSH
62738: LD_EXP 51
62742: PPUSH
62743: LD_VAR 0 4
62747: PPUSH
62748: EMPTY
62749: PPUSH
62750: CALL_OW 1
62754: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62755: LD_ADDR_EXP 52
62759: PUSH
62760: LD_EXP 52
62764: PPUSH
62765: LD_VAR 0 4
62769: PPUSH
62770: EMPTY
62771: PPUSH
62772: CALL_OW 1
62776: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62777: LD_ADDR_EXP 53
62781: PUSH
62782: LD_EXP 53
62786: PPUSH
62787: LD_VAR 0 4
62791: PPUSH
62792: EMPTY
62793: PPUSH
62794: CALL_OW 1
62798: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62799: LD_ADDR_EXP 54
62803: PUSH
62804: LD_EXP 54
62808: PPUSH
62809: LD_VAR 0 4
62813: PPUSH
62814: EMPTY
62815: PPUSH
62816: CALL_OW 1
62820: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62821: LD_ADDR_EXP 55
62825: PUSH
62826: LD_EXP 55
62830: PPUSH
62831: LD_VAR 0 4
62835: PPUSH
62836: EMPTY
62837: PPUSH
62838: CALL_OW 1
62842: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62843: LD_ADDR_EXP 56
62847: PUSH
62848: LD_EXP 56
62852: PPUSH
62853: LD_VAR 0 4
62857: PPUSH
62858: EMPTY
62859: PPUSH
62860: CALL_OW 1
62864: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62865: LD_ADDR_EXP 58
62869: PUSH
62870: LD_EXP 58
62874: PPUSH
62875: LD_VAR 0 4
62879: PPUSH
62880: EMPTY
62881: PPUSH
62882: CALL_OW 1
62886: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62887: LD_ADDR_EXP 60
62891: PUSH
62892: LD_EXP 60
62896: PPUSH
62897: LD_VAR 0 4
62901: PPUSH
62902: EMPTY
62903: PPUSH
62904: CALL_OW 1
62908: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62909: LD_ADDR_EXP 61
62913: PUSH
62914: LD_EXP 61
62918: PPUSH
62919: LD_VAR 0 4
62923: PPUSH
62924: EMPTY
62925: PPUSH
62926: CALL_OW 1
62930: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62931: LD_ADDR_EXP 62
62935: PUSH
62936: LD_EXP 62
62940: PPUSH
62941: LD_VAR 0 4
62945: PPUSH
62946: EMPTY
62947: PPUSH
62948: CALL_OW 1
62952: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62953: LD_ADDR_EXP 63
62957: PUSH
62958: LD_EXP 63
62962: PPUSH
62963: LD_VAR 0 4
62967: PPUSH
62968: EMPTY
62969: PPUSH
62970: CALL_OW 1
62974: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62975: LD_ADDR_EXP 64
62979: PUSH
62980: LD_EXP 64
62984: PPUSH
62985: LD_VAR 0 4
62989: PPUSH
62990: EMPTY
62991: PPUSH
62992: CALL_OW 1
62996: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62997: LD_ADDR_EXP 65
63001: PUSH
63002: LD_EXP 65
63006: PPUSH
63007: LD_VAR 0 4
63011: PPUSH
63012: EMPTY
63013: PPUSH
63014: CALL_OW 1
63018: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63019: LD_ADDR_EXP 66
63023: PUSH
63024: LD_EXP 66
63028: PPUSH
63029: LD_VAR 0 4
63033: PPUSH
63034: EMPTY
63035: PPUSH
63036: CALL_OW 1
63040: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63041: LD_ADDR_EXP 67
63045: PUSH
63046: LD_EXP 67
63050: PPUSH
63051: LD_VAR 0 4
63055: PPUSH
63056: EMPTY
63057: PPUSH
63058: CALL_OW 1
63062: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63063: LD_ADDR_EXP 68
63067: PUSH
63068: LD_EXP 68
63072: PPUSH
63073: LD_VAR 0 4
63077: PPUSH
63078: EMPTY
63079: PPUSH
63080: CALL_OW 1
63084: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63085: LD_ADDR_EXP 69
63089: PUSH
63090: LD_EXP 69
63094: PPUSH
63095: LD_VAR 0 4
63099: PPUSH
63100: EMPTY
63101: PPUSH
63102: CALL_OW 1
63106: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63107: LD_ADDR_EXP 70
63111: PUSH
63112: LD_EXP 70
63116: PPUSH
63117: LD_VAR 0 4
63121: PPUSH
63122: EMPTY
63123: PPUSH
63124: CALL_OW 1
63128: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63129: LD_ADDR_EXP 71
63133: PUSH
63134: LD_EXP 71
63138: PPUSH
63139: LD_VAR 0 4
63143: PPUSH
63144: EMPTY
63145: PPUSH
63146: CALL_OW 1
63150: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63151: LD_ADDR_EXP 72
63155: PUSH
63156: LD_EXP 72
63160: PPUSH
63161: LD_VAR 0 4
63165: PPUSH
63166: EMPTY
63167: PPUSH
63168: CALL_OW 1
63172: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63173: LD_ADDR_EXP 73
63177: PUSH
63178: LD_EXP 73
63182: PPUSH
63183: LD_VAR 0 4
63187: PPUSH
63188: LD_INT 0
63190: PPUSH
63191: CALL_OW 1
63195: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63196: LD_ADDR_EXP 74
63200: PUSH
63201: LD_EXP 74
63205: PPUSH
63206: LD_VAR 0 4
63210: PPUSH
63211: LD_INT 0
63213: PPUSH
63214: CALL_OW 1
63218: ST_TO_ADDR
// result := base ;
63219: LD_ADDR_VAR 0 3
63223: PUSH
63224: LD_VAR 0 4
63228: ST_TO_ADDR
// end ;
63229: LD_VAR 0 3
63233: RET
// export function MC_Start ( ) ; var i ; begin
63234: LD_INT 0
63236: PPUSH
63237: PPUSH
// for i = 1 to mc_bases do
63238: LD_ADDR_VAR 0 2
63242: PUSH
63243: DOUBLE
63244: LD_INT 1
63246: DEC
63247: ST_TO_ADDR
63248: LD_EXP 31
63252: PUSH
63253: FOR_TO
63254: IFFALSE 64354
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63256: LD_ADDR_EXP 31
63260: PUSH
63261: LD_EXP 31
63265: PPUSH
63266: LD_VAR 0 2
63270: PPUSH
63271: LD_EXP 31
63275: PUSH
63276: LD_VAR 0 2
63280: ARRAY
63281: PUSH
63282: LD_INT 0
63284: DIFF
63285: PPUSH
63286: CALL_OW 1
63290: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63291: LD_ADDR_EXP 32
63295: PUSH
63296: LD_EXP 32
63300: PPUSH
63301: LD_VAR 0 2
63305: PPUSH
63306: EMPTY
63307: PPUSH
63308: CALL_OW 1
63312: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63313: LD_ADDR_EXP 33
63317: PUSH
63318: LD_EXP 33
63322: PPUSH
63323: LD_VAR 0 2
63327: PPUSH
63328: EMPTY
63329: PPUSH
63330: CALL_OW 1
63334: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63335: LD_ADDR_EXP 34
63339: PUSH
63340: LD_EXP 34
63344: PPUSH
63345: LD_VAR 0 2
63349: PPUSH
63350: EMPTY
63351: PPUSH
63352: CALL_OW 1
63356: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63357: LD_ADDR_EXP 35
63361: PUSH
63362: LD_EXP 35
63366: PPUSH
63367: LD_VAR 0 2
63371: PPUSH
63372: EMPTY
63373: PUSH
63374: EMPTY
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PPUSH
63380: CALL_OW 1
63384: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63385: LD_ADDR_EXP 36
63389: PUSH
63390: LD_EXP 36
63394: PPUSH
63395: LD_VAR 0 2
63399: PPUSH
63400: EMPTY
63401: PPUSH
63402: CALL_OW 1
63406: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63407: LD_ADDR_EXP 63
63411: PUSH
63412: LD_EXP 63
63416: PPUSH
63417: LD_VAR 0 2
63421: PPUSH
63422: EMPTY
63423: PPUSH
63424: CALL_OW 1
63428: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63429: LD_ADDR_EXP 37
63433: PUSH
63434: LD_EXP 37
63438: PPUSH
63439: LD_VAR 0 2
63443: PPUSH
63444: EMPTY
63445: PPUSH
63446: CALL_OW 1
63450: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63451: LD_ADDR_EXP 38
63455: PUSH
63456: LD_EXP 38
63460: PPUSH
63461: LD_VAR 0 2
63465: PPUSH
63466: EMPTY
63467: PPUSH
63468: CALL_OW 1
63472: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63473: LD_ADDR_EXP 39
63477: PUSH
63478: LD_EXP 39
63482: PPUSH
63483: LD_VAR 0 2
63487: PPUSH
63488: LD_EXP 31
63492: PUSH
63493: LD_VAR 0 2
63497: ARRAY
63498: PPUSH
63499: LD_INT 2
63501: PUSH
63502: LD_INT 30
63504: PUSH
63505: LD_INT 32
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 30
63514: PUSH
63515: LD_INT 33
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: LIST
63526: PPUSH
63527: CALL_OW 72
63531: PPUSH
63532: CALL_OW 1
63536: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63537: LD_ADDR_EXP 40
63541: PUSH
63542: LD_EXP 40
63546: PPUSH
63547: LD_VAR 0 2
63551: PPUSH
63552: LD_EXP 31
63556: PUSH
63557: LD_VAR 0 2
63561: ARRAY
63562: PPUSH
63563: LD_INT 2
63565: PUSH
63566: LD_INT 30
63568: PUSH
63569: LD_INT 32
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: LD_INT 30
63578: PUSH
63579: LD_INT 31
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 58
63593: PUSH
63594: EMPTY
63595: LIST
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PPUSH
63601: CALL_OW 72
63605: PPUSH
63606: CALL_OW 1
63610: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63611: LD_ADDR_EXP 41
63615: PUSH
63616: LD_EXP 41
63620: PPUSH
63621: LD_VAR 0 2
63625: PPUSH
63626: EMPTY
63627: PPUSH
63628: CALL_OW 1
63632: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63633: LD_ADDR_EXP 45
63637: PUSH
63638: LD_EXP 45
63642: PPUSH
63643: LD_VAR 0 2
63647: PPUSH
63648: EMPTY
63649: PPUSH
63650: CALL_OW 1
63654: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63655: LD_ADDR_EXP 44
63659: PUSH
63660: LD_EXP 44
63664: PPUSH
63665: LD_VAR 0 2
63669: PPUSH
63670: EMPTY
63671: PPUSH
63672: CALL_OW 1
63676: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63677: LD_ADDR_EXP 46
63681: PUSH
63682: LD_EXP 46
63686: PPUSH
63687: LD_VAR 0 2
63691: PPUSH
63692: EMPTY
63693: PPUSH
63694: CALL_OW 1
63698: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63699: LD_ADDR_EXP 47
63703: PUSH
63704: LD_EXP 47
63708: PPUSH
63709: LD_VAR 0 2
63713: PPUSH
63714: EMPTY
63715: PPUSH
63716: CALL_OW 1
63720: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63721: LD_ADDR_EXP 48
63725: PUSH
63726: LD_EXP 48
63730: PPUSH
63731: LD_VAR 0 2
63735: PPUSH
63736: EMPTY
63737: PPUSH
63738: CALL_OW 1
63742: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63743: LD_ADDR_EXP 49
63747: PUSH
63748: LD_EXP 49
63752: PPUSH
63753: LD_VAR 0 2
63757: PPUSH
63758: EMPTY
63759: PPUSH
63760: CALL_OW 1
63764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63765: LD_ADDR_EXP 50
63769: PUSH
63770: LD_EXP 50
63774: PPUSH
63775: LD_VAR 0 2
63779: PPUSH
63780: EMPTY
63781: PPUSH
63782: CALL_OW 1
63786: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63787: LD_ADDR_EXP 51
63791: PUSH
63792: LD_EXP 51
63796: PPUSH
63797: LD_VAR 0 2
63801: PPUSH
63802: EMPTY
63803: PPUSH
63804: CALL_OW 1
63808: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
63809: LD_ADDR_EXP 52
63813: PUSH
63814: LD_EXP 52
63818: PPUSH
63819: LD_VAR 0 2
63823: PPUSH
63824: EMPTY
63825: PPUSH
63826: CALL_OW 1
63830: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63831: LD_ADDR_EXP 53
63835: PUSH
63836: LD_EXP 53
63840: PPUSH
63841: LD_VAR 0 2
63845: PPUSH
63846: EMPTY
63847: PPUSH
63848: CALL_OW 1
63852: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
63853: LD_ADDR_EXP 42
63857: PUSH
63858: LD_EXP 42
63862: PPUSH
63863: LD_VAR 0 2
63867: PPUSH
63868: LD_INT 0
63870: PPUSH
63871: CALL_OW 1
63875: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
63876: LD_ADDR_EXP 55
63880: PUSH
63881: LD_EXP 55
63885: PPUSH
63886: LD_VAR 0 2
63890: PPUSH
63891: LD_INT 0
63893: PPUSH
63894: CALL_OW 1
63898: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
63899: LD_ADDR_EXP 43
63903: PUSH
63904: LD_EXP 43
63908: PPUSH
63909: LD_VAR 0 2
63913: PPUSH
63914: EMPTY
63915: PPUSH
63916: CALL_OW 1
63920: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
63921: LD_ADDR_EXP 54
63925: PUSH
63926: LD_EXP 54
63930: PPUSH
63931: LD_VAR 0 2
63935: PPUSH
63936: LD_INT 0
63938: PPUSH
63939: CALL_OW 1
63943: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
63944: LD_ADDR_EXP 56
63948: PUSH
63949: LD_EXP 56
63953: PPUSH
63954: LD_VAR 0 2
63958: PPUSH
63959: EMPTY
63960: PPUSH
63961: CALL_OW 1
63965: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63966: LD_ADDR_EXP 59
63970: PUSH
63971: LD_EXP 59
63975: PPUSH
63976: LD_VAR 0 2
63980: PPUSH
63981: LD_INT 0
63983: PPUSH
63984: CALL_OW 1
63988: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63989: LD_ADDR_EXP 60
63993: PUSH
63994: LD_EXP 60
63998: PPUSH
63999: LD_VAR 0 2
64003: PPUSH
64004: EMPTY
64005: PPUSH
64006: CALL_OW 1
64010: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64011: LD_ADDR_EXP 61
64015: PUSH
64016: LD_EXP 61
64020: PPUSH
64021: LD_VAR 0 2
64025: PPUSH
64026: EMPTY
64027: PPUSH
64028: CALL_OW 1
64032: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64033: LD_ADDR_EXP 62
64037: PUSH
64038: LD_EXP 62
64042: PPUSH
64043: LD_VAR 0 2
64047: PPUSH
64048: EMPTY
64049: PPUSH
64050: CALL_OW 1
64054: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64055: LD_ADDR_EXP 64
64059: PUSH
64060: LD_EXP 64
64064: PPUSH
64065: LD_VAR 0 2
64069: PPUSH
64070: LD_EXP 31
64074: PUSH
64075: LD_VAR 0 2
64079: ARRAY
64080: PPUSH
64081: LD_INT 2
64083: PUSH
64084: LD_INT 30
64086: PUSH
64087: LD_INT 6
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 30
64096: PUSH
64097: LD_INT 7
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: LD_INT 30
64106: PUSH
64107: LD_INT 8
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: PPUSH
64120: CALL_OW 72
64124: PPUSH
64125: CALL_OW 1
64129: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64130: LD_ADDR_EXP 65
64134: PUSH
64135: LD_EXP 65
64139: PPUSH
64140: LD_VAR 0 2
64144: PPUSH
64145: EMPTY
64146: PPUSH
64147: CALL_OW 1
64151: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64152: LD_ADDR_EXP 66
64156: PUSH
64157: LD_EXP 66
64161: PPUSH
64162: LD_VAR 0 2
64166: PPUSH
64167: EMPTY
64168: PPUSH
64169: CALL_OW 1
64173: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64174: LD_ADDR_EXP 67
64178: PUSH
64179: LD_EXP 67
64183: PPUSH
64184: LD_VAR 0 2
64188: PPUSH
64189: EMPTY
64190: PPUSH
64191: CALL_OW 1
64195: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64196: LD_ADDR_EXP 68
64200: PUSH
64201: LD_EXP 68
64205: PPUSH
64206: LD_VAR 0 2
64210: PPUSH
64211: EMPTY
64212: PPUSH
64213: CALL_OW 1
64217: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64218: LD_ADDR_EXP 69
64222: PUSH
64223: LD_EXP 69
64227: PPUSH
64228: LD_VAR 0 2
64232: PPUSH
64233: EMPTY
64234: PPUSH
64235: CALL_OW 1
64239: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64240: LD_ADDR_EXP 70
64244: PUSH
64245: LD_EXP 70
64249: PPUSH
64250: LD_VAR 0 2
64254: PPUSH
64255: EMPTY
64256: PPUSH
64257: CALL_OW 1
64261: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64262: LD_ADDR_EXP 71
64266: PUSH
64267: LD_EXP 71
64271: PPUSH
64272: LD_VAR 0 2
64276: PPUSH
64277: EMPTY
64278: PPUSH
64279: CALL_OW 1
64283: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64284: LD_ADDR_EXP 72
64288: PUSH
64289: LD_EXP 72
64293: PPUSH
64294: LD_VAR 0 2
64298: PPUSH
64299: EMPTY
64300: PPUSH
64301: CALL_OW 1
64305: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64306: LD_ADDR_EXP 73
64310: PUSH
64311: LD_EXP 73
64315: PPUSH
64316: LD_VAR 0 2
64320: PPUSH
64321: LD_INT 0
64323: PPUSH
64324: CALL_OW 1
64328: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64329: LD_ADDR_EXP 74
64333: PUSH
64334: LD_EXP 74
64338: PPUSH
64339: LD_VAR 0 2
64343: PPUSH
64344: LD_INT 0
64346: PPUSH
64347: CALL_OW 1
64351: ST_TO_ADDR
// end ;
64352: GO 63253
64354: POP
64355: POP
// MC_InitSides ( ) ;
64356: CALL 64642 0 0
// MC_InitResearch ( ) ;
64360: CALL 64381 0 0
// CustomInitMacro ( ) ;
64364: CALL 1411 0 0
// skirmish := true ;
64368: LD_ADDR_EXP 29
64372: PUSH
64373: LD_INT 1
64375: ST_TO_ADDR
// end ;
64376: LD_VAR 0 1
64380: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64381: LD_INT 0
64383: PPUSH
64384: PPUSH
64385: PPUSH
64386: PPUSH
64387: PPUSH
64388: PPUSH
// if not mc_bases then
64389: LD_EXP 31
64393: NOT
64394: IFFALSE 64398
// exit ;
64396: GO 64637
// for i = 1 to 8 do
64398: LD_ADDR_VAR 0 2
64402: PUSH
64403: DOUBLE
64404: LD_INT 1
64406: DEC
64407: ST_TO_ADDR
64408: LD_INT 8
64410: PUSH
64411: FOR_TO
64412: IFFALSE 64438
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64414: LD_ADDR_EXP 58
64418: PUSH
64419: LD_EXP 58
64423: PPUSH
64424: LD_VAR 0 2
64428: PPUSH
64429: EMPTY
64430: PPUSH
64431: CALL_OW 1
64435: ST_TO_ADDR
64436: GO 64411
64438: POP
64439: POP
// tmp := [ ] ;
64440: LD_ADDR_VAR 0 5
64444: PUSH
64445: EMPTY
64446: ST_TO_ADDR
// for i = 1 to mc_sides do
64447: LD_ADDR_VAR 0 2
64451: PUSH
64452: DOUBLE
64453: LD_INT 1
64455: DEC
64456: ST_TO_ADDR
64457: LD_EXP 57
64461: PUSH
64462: FOR_TO
64463: IFFALSE 64521
// if not mc_sides [ i ] in tmp then
64465: LD_EXP 57
64469: PUSH
64470: LD_VAR 0 2
64474: ARRAY
64475: PUSH
64476: LD_VAR 0 5
64480: IN
64481: NOT
64482: IFFALSE 64519
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64484: LD_ADDR_VAR 0 5
64488: PUSH
64489: LD_VAR 0 5
64493: PPUSH
64494: LD_VAR 0 5
64498: PUSH
64499: LD_INT 1
64501: PLUS
64502: PPUSH
64503: LD_EXP 57
64507: PUSH
64508: LD_VAR 0 2
64512: ARRAY
64513: PPUSH
64514: CALL_OW 2
64518: ST_TO_ADDR
64519: GO 64462
64521: POP
64522: POP
// if not tmp then
64523: LD_VAR 0 5
64527: NOT
64528: IFFALSE 64532
// exit ;
64530: GO 64637
// for j in tmp do
64532: LD_ADDR_VAR 0 3
64536: PUSH
64537: LD_VAR 0 5
64541: PUSH
64542: FOR_IN
64543: IFFALSE 64635
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64545: LD_ADDR_VAR 0 6
64549: PUSH
64550: LD_INT 22
64552: PUSH
64553: LD_VAR 0 3
64557: PUSH
64558: EMPTY
64559: LIST
64560: LIST
64561: PPUSH
64562: CALL_OW 69
64566: ST_TO_ADDR
// if not un then
64567: LD_VAR 0 6
64571: NOT
64572: IFFALSE 64576
// continue ;
64574: GO 64542
// nation := GetNation ( un [ 1 ] ) ;
64576: LD_ADDR_VAR 0 4
64580: PUSH
64581: LD_VAR 0 6
64585: PUSH
64586: LD_INT 1
64588: ARRAY
64589: PPUSH
64590: CALL_OW 248
64594: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64595: LD_ADDR_EXP 58
64599: PUSH
64600: LD_EXP 58
64604: PPUSH
64605: LD_VAR 0 3
64609: PPUSH
64610: LD_VAR 0 3
64614: PPUSH
64615: LD_VAR 0 4
64619: PPUSH
64620: LD_INT 1
64622: PPUSH
64623: CALL 19947 0 3
64627: PPUSH
64628: CALL_OW 1
64632: ST_TO_ADDR
// end ;
64633: GO 64542
64635: POP
64636: POP
// end ;
64637: LD_VAR 0 1
64641: RET
// export function MC_InitSides ( ) ; var i ; begin
64642: LD_INT 0
64644: PPUSH
64645: PPUSH
// if not mc_bases then
64646: LD_EXP 31
64650: NOT
64651: IFFALSE 64655
// exit ;
64653: GO 64729
// for i = 1 to mc_bases do
64655: LD_ADDR_VAR 0 2
64659: PUSH
64660: DOUBLE
64661: LD_INT 1
64663: DEC
64664: ST_TO_ADDR
64665: LD_EXP 31
64669: PUSH
64670: FOR_TO
64671: IFFALSE 64727
// if mc_bases [ i ] then
64673: LD_EXP 31
64677: PUSH
64678: LD_VAR 0 2
64682: ARRAY
64683: IFFALSE 64725
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64685: LD_ADDR_EXP 57
64689: PUSH
64690: LD_EXP 57
64694: PPUSH
64695: LD_VAR 0 2
64699: PPUSH
64700: LD_EXP 31
64704: PUSH
64705: LD_VAR 0 2
64709: ARRAY
64710: PUSH
64711: LD_INT 1
64713: ARRAY
64714: PPUSH
64715: CALL_OW 255
64719: PPUSH
64720: CALL_OW 1
64724: ST_TO_ADDR
64725: GO 64670
64727: POP
64728: POP
// end ;
64729: LD_VAR 0 1
64733: RET
// every 0 0$03 trigger skirmish do
64734: LD_EXP 29
64738: IFFALSE 64892
64740: GO 64742
64742: DISABLE
// begin enable ;
64743: ENABLE
// MC_CheckBuildings ( ) ;
64744: CALL 69390 0 0
// MC_CheckPeopleLife ( ) ;
64748: CALL 69551 0 0
// RaiseSailEvent ( 100 ) ;
64752: LD_INT 100
64754: PPUSH
64755: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64759: LD_INT 103
64761: PPUSH
64762: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64766: LD_INT 104
64768: PPUSH
64769: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64773: LD_INT 105
64775: PPUSH
64776: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64780: LD_INT 106
64782: PPUSH
64783: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64787: LD_INT 107
64789: PPUSH
64790: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64794: LD_INT 108
64796: PPUSH
64797: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64801: LD_INT 109
64803: PPUSH
64804: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
64808: LD_INT 110
64810: PPUSH
64811: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
64815: LD_INT 111
64817: PPUSH
64818: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
64822: LD_INT 112
64824: PPUSH
64825: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
64829: LD_INT 113
64831: PPUSH
64832: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
64836: LD_INT 120
64838: PPUSH
64839: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
64843: LD_INT 121
64845: PPUSH
64846: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
64850: LD_INT 122
64852: PPUSH
64853: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
64857: LD_INT 123
64859: PPUSH
64860: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
64864: LD_INT 124
64866: PPUSH
64867: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
64871: LD_INT 125
64873: PPUSH
64874: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
64878: LD_INT 126
64880: PPUSH
64881: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
64885: LD_INT 200
64887: PPUSH
64888: CALL_OW 427
// end ;
64892: END
// on SailEvent ( event ) do begin if event < 100 then
64893: LD_VAR 0 1
64897: PUSH
64898: LD_INT 100
64900: LESS
64901: IFFALSE 64912
// CustomEvent ( event ) ;
64903: LD_VAR 0 1
64907: PPUSH
64908: CALL 19111 0 1
// if event = 100 then
64912: LD_VAR 0 1
64916: PUSH
64917: LD_INT 100
64919: EQUAL
64920: IFFALSE 64926
// MC_ClassManager ( ) ;
64922: CALL 65318 0 0
// if event = 101 then
64926: LD_VAR 0 1
64930: PUSH
64931: LD_INT 101
64933: EQUAL
64934: IFFALSE 64940
// MC_RepairBuildings ( ) ;
64936: CALL 70136 0 0
// if event = 102 then
64940: LD_VAR 0 1
64944: PUSH
64945: LD_INT 102
64947: EQUAL
64948: IFFALSE 64954
// MC_Heal ( ) ;
64950: CALL 71039 0 0
// if event = 103 then
64954: LD_VAR 0 1
64958: PUSH
64959: LD_INT 103
64961: EQUAL
64962: IFFALSE 64968
// MC_Build ( ) ;
64964: CALL 71461 0 0
// if event = 104 then
64968: LD_VAR 0 1
64972: PUSH
64973: LD_INT 104
64975: EQUAL
64976: IFFALSE 64982
// MC_TurretWeapon ( ) ;
64978: CALL 73102 0 0
// if event = 105 then
64982: LD_VAR 0 1
64986: PUSH
64987: LD_INT 105
64989: EQUAL
64990: IFFALSE 64996
// MC_BuildUpgrade ( ) ;
64992: CALL 72653 0 0
// if event = 106 then
64996: LD_VAR 0 1
65000: PUSH
65001: LD_INT 106
65003: EQUAL
65004: IFFALSE 65010
// MC_PlantMines ( ) ;
65006: CALL 73532 0 0
// if event = 107 then
65010: LD_VAR 0 1
65014: PUSH
65015: LD_INT 107
65017: EQUAL
65018: IFFALSE 65024
// MC_CollectCrates ( ) ;
65020: CALL 74323 0 0
// if event = 108 then
65024: LD_VAR 0 1
65028: PUSH
65029: LD_INT 108
65031: EQUAL
65032: IFFALSE 65038
// MC_LinkRemoteControl ( ) ;
65034: CALL 76173 0 0
// if event = 109 then
65038: LD_VAR 0 1
65042: PUSH
65043: LD_INT 109
65045: EQUAL
65046: IFFALSE 65052
// MC_ProduceVehicle ( ) ;
65048: CALL 76354 0 0
// if event = 110 then
65052: LD_VAR 0 1
65056: PUSH
65057: LD_INT 110
65059: EQUAL
65060: IFFALSE 65066
// MC_SendAttack ( ) ;
65062: CALL 76820 0 0
// if event = 111 then
65066: LD_VAR 0 1
65070: PUSH
65071: LD_INT 111
65073: EQUAL
65074: IFFALSE 65080
// MC_Defend ( ) ;
65076: CALL 76928 0 0
// if event = 112 then
65080: LD_VAR 0 1
65084: PUSH
65085: LD_INT 112
65087: EQUAL
65088: IFFALSE 65094
// MC_Research ( ) ;
65090: CALL 77808 0 0
// if event = 113 then
65094: LD_VAR 0 1
65098: PUSH
65099: LD_INT 113
65101: EQUAL
65102: IFFALSE 65108
// MC_MinesTrigger ( ) ;
65104: CALL 78922 0 0
// if event = 120 then
65108: LD_VAR 0 1
65112: PUSH
65113: LD_INT 120
65115: EQUAL
65116: IFFALSE 65122
// MC_RepairVehicle ( ) ;
65118: CALL 79021 0 0
// if event = 121 then
65122: LD_VAR 0 1
65126: PUSH
65127: LD_INT 121
65129: EQUAL
65130: IFFALSE 65136
// MC_TameApe ( ) ;
65132: CALL 79762 0 0
// if event = 122 then
65136: LD_VAR 0 1
65140: PUSH
65141: LD_INT 122
65143: EQUAL
65144: IFFALSE 65150
// MC_ChangeApeClass ( ) ;
65146: CALL 80591 0 0
// if event = 123 then
65150: LD_VAR 0 1
65154: PUSH
65155: LD_INT 123
65157: EQUAL
65158: IFFALSE 65164
// MC_Bazooka ( ) ;
65160: CALL 81241 0 0
// if event = 124 then
65164: LD_VAR 0 1
65168: PUSH
65169: LD_INT 124
65171: EQUAL
65172: IFFALSE 65178
// MC_TeleportExit ( ) ;
65174: CALL 81439 0 0
// if event = 125 then
65178: LD_VAR 0 1
65182: PUSH
65183: LD_INT 125
65185: EQUAL
65186: IFFALSE 65192
// MC_Deposits ( ) ;
65188: CALL 82086 0 0
// if event = 126 then
65192: LD_VAR 0 1
65196: PUSH
65197: LD_INT 126
65199: EQUAL
65200: IFFALSE 65206
// MC_RemoteDriver ( ) ;
65202: CALL 82711 0 0
// if event = 200 then
65206: LD_VAR 0 1
65210: PUSH
65211: LD_INT 200
65213: EQUAL
65214: IFFALSE 65220
// MC_Idle ( ) ;
65216: CALL 84660 0 0
// end ;
65220: PPOPN 1
65222: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65223: LD_INT 0
65225: PPUSH
65226: PPUSH
// if not mc_bases [ base ] or not tag then
65227: LD_EXP 31
65231: PUSH
65232: LD_VAR 0 1
65236: ARRAY
65237: NOT
65238: PUSH
65239: LD_VAR 0 2
65243: NOT
65244: OR
65245: IFFALSE 65249
// exit ;
65247: GO 65313
// for i in mc_bases [ base ] union mc_ape [ base ] do
65249: LD_ADDR_VAR 0 4
65253: PUSH
65254: LD_EXP 31
65258: PUSH
65259: LD_VAR 0 1
65263: ARRAY
65264: PUSH
65265: LD_EXP 60
65269: PUSH
65270: LD_VAR 0 1
65274: ARRAY
65275: UNION
65276: PUSH
65277: FOR_IN
65278: IFFALSE 65311
// if GetTag ( i ) = tag then
65280: LD_VAR 0 4
65284: PPUSH
65285: CALL_OW 110
65289: PUSH
65290: LD_VAR 0 2
65294: EQUAL
65295: IFFALSE 65309
// SetTag ( i , 0 ) ;
65297: LD_VAR 0 4
65301: PPUSH
65302: LD_INT 0
65304: PPUSH
65305: CALL_OW 109
65309: GO 65277
65311: POP
65312: POP
// end ;
65313: LD_VAR 0 3
65317: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65318: LD_INT 0
65320: PPUSH
65321: PPUSH
65322: PPUSH
65323: PPUSH
65324: PPUSH
65325: PPUSH
65326: PPUSH
65327: PPUSH
// if not mc_bases then
65328: LD_EXP 31
65332: NOT
65333: IFFALSE 65337
// exit ;
65335: GO 65795
// for i = 1 to mc_bases do
65337: LD_ADDR_VAR 0 2
65341: PUSH
65342: DOUBLE
65343: LD_INT 1
65345: DEC
65346: ST_TO_ADDR
65347: LD_EXP 31
65351: PUSH
65352: FOR_TO
65353: IFFALSE 65793
// begin tmp := MC_ClassCheckReq ( i ) ;
65355: LD_ADDR_VAR 0 4
65359: PUSH
65360: LD_VAR 0 2
65364: PPUSH
65365: CALL 65800 0 1
65369: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65370: LD_ADDR_EXP 72
65374: PUSH
65375: LD_EXP 72
65379: PPUSH
65380: LD_VAR 0 2
65384: PPUSH
65385: LD_VAR 0 4
65389: PPUSH
65390: CALL_OW 1
65394: ST_TO_ADDR
// if not tmp then
65395: LD_VAR 0 4
65399: NOT
65400: IFFALSE 65404
// continue ;
65402: GO 65352
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65404: LD_ADDR_VAR 0 6
65408: PUSH
65409: LD_EXP 31
65413: PUSH
65414: LD_VAR 0 2
65418: ARRAY
65419: PPUSH
65420: LD_INT 2
65422: PUSH
65423: LD_INT 30
65425: PUSH
65426: LD_INT 4
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 30
65435: PUSH
65436: LD_INT 5
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: LIST
65447: PPUSH
65448: CALL_OW 72
65452: PUSH
65453: LD_EXP 31
65457: PUSH
65458: LD_VAR 0 2
65462: ARRAY
65463: PPUSH
65464: LD_INT 2
65466: PUSH
65467: LD_INT 30
65469: PUSH
65470: LD_INT 0
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 30
65479: PUSH
65480: LD_INT 1
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: LIST
65491: PPUSH
65492: CALL_OW 72
65496: PUSH
65497: LD_EXP 31
65501: PUSH
65502: LD_VAR 0 2
65506: ARRAY
65507: PPUSH
65508: LD_INT 30
65510: PUSH
65511: LD_INT 3
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PPUSH
65518: CALL_OW 72
65522: PUSH
65523: LD_EXP 31
65527: PUSH
65528: LD_VAR 0 2
65532: ARRAY
65533: PPUSH
65534: LD_INT 2
65536: PUSH
65537: LD_INT 30
65539: PUSH
65540: LD_INT 6
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 30
65549: PUSH
65550: LD_INT 7
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 30
65559: PUSH
65560: LD_INT 8
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: PPUSH
65573: CALL_OW 72
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: ST_TO_ADDR
// for j = 1 to 4 do
65584: LD_ADDR_VAR 0 3
65588: PUSH
65589: DOUBLE
65590: LD_INT 1
65592: DEC
65593: ST_TO_ADDR
65594: LD_INT 4
65596: PUSH
65597: FOR_TO
65598: IFFALSE 65789
// begin if not tmp [ j ] then
65600: LD_VAR 0 4
65604: PUSH
65605: LD_VAR 0 3
65609: ARRAY
65610: NOT
65611: IFFALSE 65615
// continue ;
65613: GO 65597
// for p in tmp [ j ] do
65615: LD_ADDR_VAR 0 5
65619: PUSH
65620: LD_VAR 0 4
65624: PUSH
65625: LD_VAR 0 3
65629: ARRAY
65630: PUSH
65631: FOR_IN
65632: IFFALSE 65785
// begin if not b [ j ] then
65634: LD_VAR 0 6
65638: PUSH
65639: LD_VAR 0 3
65643: ARRAY
65644: NOT
65645: IFFALSE 65649
// break ;
65647: GO 65785
// e := 0 ;
65649: LD_ADDR_VAR 0 7
65653: PUSH
65654: LD_INT 0
65656: ST_TO_ADDR
// for k in b [ j ] do
65657: LD_ADDR_VAR 0 8
65661: PUSH
65662: LD_VAR 0 6
65666: PUSH
65667: LD_VAR 0 3
65671: ARRAY
65672: PUSH
65673: FOR_IN
65674: IFFALSE 65701
// if IsNotFull ( k ) then
65676: LD_VAR 0 8
65680: PPUSH
65681: CALL 22100 0 1
65685: IFFALSE 65699
// begin e := k ;
65687: LD_ADDR_VAR 0 7
65691: PUSH
65692: LD_VAR 0 8
65696: ST_TO_ADDR
// break ;
65697: GO 65701
// end ;
65699: GO 65673
65701: POP
65702: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65703: LD_VAR 0 7
65707: PUSH
65708: LD_VAR 0 5
65712: PPUSH
65713: LD_VAR 0 7
65717: PPUSH
65718: CALL 55906 0 2
65722: NOT
65723: AND
65724: IFFALSE 65783
// begin if IsInUnit ( p ) then
65726: LD_VAR 0 5
65730: PPUSH
65731: CALL_OW 310
65735: IFFALSE 65746
// ComExitBuilding ( p ) ;
65737: LD_VAR 0 5
65741: PPUSH
65742: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65746: LD_VAR 0 5
65750: PPUSH
65751: LD_VAR 0 7
65755: PPUSH
65756: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65760: LD_VAR 0 5
65764: PPUSH
65765: LD_VAR 0 3
65769: PPUSH
65770: CALL_OW 183
// AddComExitBuilding ( p ) ;
65774: LD_VAR 0 5
65778: PPUSH
65779: CALL_OW 182
// end ; end ;
65783: GO 65631
65785: POP
65786: POP
// end ;
65787: GO 65597
65789: POP
65790: POP
// end ;
65791: GO 65352
65793: POP
65794: POP
// end ;
65795: LD_VAR 0 1
65799: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65800: LD_INT 0
65802: PPUSH
65803: PPUSH
65804: PPUSH
65805: PPUSH
65806: PPUSH
65807: PPUSH
65808: PPUSH
65809: PPUSH
65810: PPUSH
65811: PPUSH
65812: PPUSH
65813: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65814: LD_VAR 0 1
65818: NOT
65819: PUSH
65820: LD_EXP 31
65824: PUSH
65825: LD_VAR 0 1
65829: ARRAY
65830: NOT
65831: OR
65832: PUSH
65833: LD_EXP 31
65837: PUSH
65838: LD_VAR 0 1
65842: ARRAY
65843: PPUSH
65844: LD_INT 2
65846: PUSH
65847: LD_INT 30
65849: PUSH
65850: LD_INT 0
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PUSH
65857: LD_INT 30
65859: PUSH
65860: LD_INT 1
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: LIST
65871: PPUSH
65872: CALL_OW 72
65876: NOT
65877: OR
65878: IFFALSE 65882
// exit ;
65880: GO 69385
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65882: LD_ADDR_VAR 0 4
65886: PUSH
65887: LD_EXP 31
65891: PUSH
65892: LD_VAR 0 1
65896: ARRAY
65897: PPUSH
65898: LD_INT 2
65900: PUSH
65901: LD_INT 25
65903: PUSH
65904: LD_INT 1
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 25
65913: PUSH
65914: LD_INT 2
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 25
65923: PUSH
65924: LD_INT 3
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 25
65933: PUSH
65934: LD_INT 4
65936: PUSH
65937: EMPTY
65938: LIST
65939: LIST
65940: PUSH
65941: LD_INT 25
65943: PUSH
65944: LD_INT 5
65946: PUSH
65947: EMPTY
65948: LIST
65949: LIST
65950: PUSH
65951: LD_INT 25
65953: PUSH
65954: LD_INT 8
65956: PUSH
65957: EMPTY
65958: LIST
65959: LIST
65960: PUSH
65961: LD_INT 25
65963: PUSH
65964: LD_INT 9
65966: PUSH
65967: EMPTY
65968: LIST
65969: LIST
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: PPUSH
65981: CALL_OW 72
65985: ST_TO_ADDR
// if not tmp then
65986: LD_VAR 0 4
65990: NOT
65991: IFFALSE 65995
// exit ;
65993: GO 69385
// for i in tmp do
65995: LD_ADDR_VAR 0 3
65999: PUSH
66000: LD_VAR 0 4
66004: PUSH
66005: FOR_IN
66006: IFFALSE 66037
// if GetTag ( i ) then
66008: LD_VAR 0 3
66012: PPUSH
66013: CALL_OW 110
66017: IFFALSE 66035
// tmp := tmp diff i ;
66019: LD_ADDR_VAR 0 4
66023: PUSH
66024: LD_VAR 0 4
66028: PUSH
66029: LD_VAR 0 3
66033: DIFF
66034: ST_TO_ADDR
66035: GO 66005
66037: POP
66038: POP
// if not tmp then
66039: LD_VAR 0 4
66043: NOT
66044: IFFALSE 66048
// exit ;
66046: GO 69385
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66048: LD_ADDR_VAR 0 5
66052: PUSH
66053: LD_EXP 31
66057: PUSH
66058: LD_VAR 0 1
66062: ARRAY
66063: PPUSH
66064: LD_INT 2
66066: PUSH
66067: LD_INT 25
66069: PUSH
66070: LD_INT 1
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PUSH
66077: LD_INT 25
66079: PUSH
66080: LD_INT 5
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: PUSH
66087: LD_INT 25
66089: PUSH
66090: LD_INT 8
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 25
66099: PUSH
66100: LD_INT 9
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: LIST
66111: LIST
66112: LIST
66113: PPUSH
66114: CALL_OW 72
66118: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66119: LD_ADDR_VAR 0 6
66123: PUSH
66124: LD_EXP 31
66128: PUSH
66129: LD_VAR 0 1
66133: ARRAY
66134: PPUSH
66135: LD_INT 25
66137: PUSH
66138: LD_INT 2
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PPUSH
66145: CALL_OW 72
66149: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66150: LD_ADDR_VAR 0 7
66154: PUSH
66155: LD_EXP 31
66159: PUSH
66160: LD_VAR 0 1
66164: ARRAY
66165: PPUSH
66166: LD_INT 25
66168: PUSH
66169: LD_INT 3
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: PPUSH
66176: CALL_OW 72
66180: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66181: LD_ADDR_VAR 0 8
66185: PUSH
66186: LD_EXP 31
66190: PUSH
66191: LD_VAR 0 1
66195: ARRAY
66196: PPUSH
66197: LD_INT 25
66199: PUSH
66200: LD_INT 4
66202: PUSH
66203: EMPTY
66204: LIST
66205: LIST
66206: PUSH
66207: LD_INT 24
66209: PUSH
66210: LD_INT 251
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PPUSH
66221: CALL_OW 72
66225: ST_TO_ADDR
// if mc_is_defending [ base ] then
66226: LD_EXP 74
66230: PUSH
66231: LD_VAR 0 1
66235: ARRAY
66236: IFFALSE 66697
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66238: LD_ADDR_EXP 73
66242: PUSH
66243: LD_EXP 73
66247: PPUSH
66248: LD_VAR 0 1
66252: PPUSH
66253: LD_INT 4
66255: PPUSH
66256: CALL_OW 1
66260: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66261: LD_ADDR_VAR 0 12
66265: PUSH
66266: LD_EXP 31
66270: PUSH
66271: LD_VAR 0 1
66275: ARRAY
66276: PPUSH
66277: LD_INT 2
66279: PUSH
66280: LD_INT 30
66282: PUSH
66283: LD_INT 4
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 30
66292: PUSH
66293: LD_INT 5
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: LIST
66304: PPUSH
66305: CALL_OW 72
66309: ST_TO_ADDR
// if not b then
66310: LD_VAR 0 12
66314: NOT
66315: IFFALSE 66319
// exit ;
66317: GO 69385
// p := [ ] ;
66319: LD_ADDR_VAR 0 11
66323: PUSH
66324: EMPTY
66325: ST_TO_ADDR
// if sci >= 2 then
66326: LD_VAR 0 8
66330: PUSH
66331: LD_INT 2
66333: GREATEREQUAL
66334: IFFALSE 66365
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66336: LD_ADDR_VAR 0 8
66340: PUSH
66341: LD_VAR 0 8
66345: PUSH
66346: LD_INT 1
66348: ARRAY
66349: PUSH
66350: LD_VAR 0 8
66354: PUSH
66355: LD_INT 2
66357: ARRAY
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: ST_TO_ADDR
66363: GO 66426
// if sci = 1 then
66365: LD_VAR 0 8
66369: PUSH
66370: LD_INT 1
66372: EQUAL
66373: IFFALSE 66394
// sci := [ sci [ 1 ] ] else
66375: LD_ADDR_VAR 0 8
66379: PUSH
66380: LD_VAR 0 8
66384: PUSH
66385: LD_INT 1
66387: ARRAY
66388: PUSH
66389: EMPTY
66390: LIST
66391: ST_TO_ADDR
66392: GO 66426
// if sci = 0 then
66394: LD_VAR 0 8
66398: PUSH
66399: LD_INT 0
66401: EQUAL
66402: IFFALSE 66426
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66404: LD_ADDR_VAR 0 11
66408: PUSH
66409: LD_VAR 0 4
66413: PPUSH
66414: LD_INT 4
66416: PPUSH
66417: CALL 55769 0 2
66421: PUSH
66422: LD_INT 1
66424: ARRAY
66425: ST_TO_ADDR
// if eng > 4 then
66426: LD_VAR 0 6
66430: PUSH
66431: LD_INT 4
66433: GREATER
66434: IFFALSE 66480
// for i = eng downto 4 do
66436: LD_ADDR_VAR 0 3
66440: PUSH
66441: DOUBLE
66442: LD_VAR 0 6
66446: INC
66447: ST_TO_ADDR
66448: LD_INT 4
66450: PUSH
66451: FOR_DOWNTO
66452: IFFALSE 66478
// eng := eng diff eng [ i ] ;
66454: LD_ADDR_VAR 0 6
66458: PUSH
66459: LD_VAR 0 6
66463: PUSH
66464: LD_VAR 0 6
66468: PUSH
66469: LD_VAR 0 3
66473: ARRAY
66474: DIFF
66475: ST_TO_ADDR
66476: GO 66451
66478: POP
66479: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66480: LD_ADDR_VAR 0 4
66484: PUSH
66485: LD_VAR 0 4
66489: PUSH
66490: LD_VAR 0 5
66494: PUSH
66495: LD_VAR 0 6
66499: UNION
66500: PUSH
66501: LD_VAR 0 7
66505: UNION
66506: PUSH
66507: LD_VAR 0 8
66511: UNION
66512: DIFF
66513: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66514: LD_ADDR_VAR 0 13
66518: PUSH
66519: LD_EXP 31
66523: PUSH
66524: LD_VAR 0 1
66528: ARRAY
66529: PPUSH
66530: LD_INT 2
66532: PUSH
66533: LD_INT 30
66535: PUSH
66536: LD_INT 32
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 30
66545: PUSH
66546: LD_INT 31
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: LIST
66557: PPUSH
66558: CALL_OW 72
66562: PUSH
66563: LD_EXP 31
66567: PUSH
66568: LD_VAR 0 1
66572: ARRAY
66573: PPUSH
66574: LD_INT 2
66576: PUSH
66577: LD_INT 30
66579: PUSH
66580: LD_INT 4
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 30
66589: PUSH
66590: LD_INT 5
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: LIST
66601: PPUSH
66602: CALL_OW 72
66606: PUSH
66607: LD_INT 6
66609: MUL
66610: PLUS
66611: ST_TO_ADDR
// if bcount < tmp then
66612: LD_VAR 0 13
66616: PUSH
66617: LD_VAR 0 4
66621: LESS
66622: IFFALSE 66668
// for i = tmp downto bcount do
66624: LD_ADDR_VAR 0 3
66628: PUSH
66629: DOUBLE
66630: LD_VAR 0 4
66634: INC
66635: ST_TO_ADDR
66636: LD_VAR 0 13
66640: PUSH
66641: FOR_DOWNTO
66642: IFFALSE 66666
// tmp := Delete ( tmp , tmp ) ;
66644: LD_ADDR_VAR 0 4
66648: PUSH
66649: LD_VAR 0 4
66653: PPUSH
66654: LD_VAR 0 4
66658: PPUSH
66659: CALL_OW 3
66663: ST_TO_ADDR
66664: GO 66641
66666: POP
66667: POP
// result := [ tmp , 0 , 0 , p ] ;
66668: LD_ADDR_VAR 0 2
66672: PUSH
66673: LD_VAR 0 4
66677: PUSH
66678: LD_INT 0
66680: PUSH
66681: LD_INT 0
66683: PUSH
66684: LD_VAR 0 11
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: LIST
66693: LIST
66694: ST_TO_ADDR
// exit ;
66695: GO 69385
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66697: LD_EXP 31
66701: PUSH
66702: LD_VAR 0 1
66706: ARRAY
66707: PPUSH
66708: LD_INT 2
66710: PUSH
66711: LD_INT 30
66713: PUSH
66714: LD_INT 6
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 30
66723: PUSH
66724: LD_INT 7
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 30
66733: PUSH
66734: LD_INT 8
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: PPUSH
66747: CALL_OW 72
66751: NOT
66752: PUSH
66753: LD_EXP 31
66757: PUSH
66758: LD_VAR 0 1
66762: ARRAY
66763: PPUSH
66764: LD_INT 30
66766: PUSH
66767: LD_INT 3
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PPUSH
66774: CALL_OW 72
66778: NOT
66779: AND
66780: IFFALSE 66852
// begin if eng = tmp then
66782: LD_VAR 0 6
66786: PUSH
66787: LD_VAR 0 4
66791: EQUAL
66792: IFFALSE 66796
// exit ;
66794: GO 69385
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66796: LD_ADDR_EXP 73
66800: PUSH
66801: LD_EXP 73
66805: PPUSH
66806: LD_VAR 0 1
66810: PPUSH
66811: LD_INT 1
66813: PPUSH
66814: CALL_OW 1
66818: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
66819: LD_ADDR_VAR 0 2
66823: PUSH
66824: LD_INT 0
66826: PUSH
66827: LD_VAR 0 4
66831: PUSH
66832: LD_VAR 0 6
66836: DIFF
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: LD_INT 0
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: ST_TO_ADDR
// exit ;
66850: GO 69385
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66852: LD_EXP 58
66856: PUSH
66857: LD_EXP 57
66861: PUSH
66862: LD_VAR 0 1
66866: ARRAY
66867: ARRAY
66868: PUSH
66869: LD_EXP 31
66873: PUSH
66874: LD_VAR 0 1
66878: ARRAY
66879: PPUSH
66880: LD_INT 2
66882: PUSH
66883: LD_INT 30
66885: PUSH
66886: LD_INT 6
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 30
66895: PUSH
66896: LD_INT 7
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 30
66905: PUSH
66906: LD_INT 8
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: PPUSH
66919: CALL_OW 72
66923: AND
66924: PUSH
66925: LD_EXP 31
66929: PUSH
66930: LD_VAR 0 1
66934: ARRAY
66935: PPUSH
66936: LD_INT 30
66938: PUSH
66939: LD_INT 3
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PPUSH
66946: CALL_OW 72
66950: NOT
66951: AND
66952: IFFALSE 67166
// begin if sci >= 6 then
66954: LD_VAR 0 8
66958: PUSH
66959: LD_INT 6
66961: GREATEREQUAL
66962: IFFALSE 66966
// exit ;
66964: GO 69385
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66966: LD_ADDR_EXP 73
66970: PUSH
66971: LD_EXP 73
66975: PPUSH
66976: LD_VAR 0 1
66980: PPUSH
66981: LD_INT 2
66983: PPUSH
66984: CALL_OW 1
66988: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66989: LD_ADDR_VAR 0 9
66993: PUSH
66994: LD_VAR 0 4
66998: PUSH
66999: LD_VAR 0 8
67003: DIFF
67004: PPUSH
67005: LD_INT 4
67007: PPUSH
67008: CALL 55769 0 2
67012: ST_TO_ADDR
// p := [ ] ;
67013: LD_ADDR_VAR 0 11
67017: PUSH
67018: EMPTY
67019: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67020: LD_VAR 0 8
67024: PUSH
67025: LD_INT 6
67027: LESS
67028: PUSH
67029: LD_VAR 0 9
67033: PUSH
67034: LD_INT 6
67036: GREATER
67037: AND
67038: IFFALSE 67119
// begin for i = 1 to 6 - sci do
67040: LD_ADDR_VAR 0 3
67044: PUSH
67045: DOUBLE
67046: LD_INT 1
67048: DEC
67049: ST_TO_ADDR
67050: LD_INT 6
67052: PUSH
67053: LD_VAR 0 8
67057: MINUS
67058: PUSH
67059: FOR_TO
67060: IFFALSE 67115
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67062: LD_ADDR_VAR 0 11
67066: PUSH
67067: LD_VAR 0 11
67071: PPUSH
67072: LD_VAR 0 11
67076: PUSH
67077: LD_INT 1
67079: PLUS
67080: PPUSH
67081: LD_VAR 0 9
67085: PUSH
67086: LD_INT 1
67088: ARRAY
67089: PPUSH
67090: CALL_OW 2
67094: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67095: LD_ADDR_VAR 0 9
67099: PUSH
67100: LD_VAR 0 9
67104: PPUSH
67105: LD_INT 1
67107: PPUSH
67108: CALL_OW 3
67112: ST_TO_ADDR
// end ;
67113: GO 67059
67115: POP
67116: POP
// end else
67117: GO 67139
// if sort then
67119: LD_VAR 0 9
67123: IFFALSE 67139
// p := sort [ 1 ] ;
67125: LD_ADDR_VAR 0 11
67129: PUSH
67130: LD_VAR 0 9
67134: PUSH
67135: LD_INT 1
67137: ARRAY
67138: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67139: LD_ADDR_VAR 0 2
67143: PUSH
67144: LD_INT 0
67146: PUSH
67147: LD_INT 0
67149: PUSH
67150: LD_INT 0
67152: PUSH
67153: LD_VAR 0 11
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: ST_TO_ADDR
// exit ;
67164: GO 69385
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67166: LD_EXP 58
67170: PUSH
67171: LD_EXP 57
67175: PUSH
67176: LD_VAR 0 1
67180: ARRAY
67181: ARRAY
67182: PUSH
67183: LD_EXP 31
67187: PUSH
67188: LD_VAR 0 1
67192: ARRAY
67193: PPUSH
67194: LD_INT 2
67196: PUSH
67197: LD_INT 30
67199: PUSH
67200: LD_INT 6
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 30
67209: PUSH
67210: LD_INT 7
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 30
67219: PUSH
67220: LD_INT 8
67222: PUSH
67223: EMPTY
67224: LIST
67225: LIST
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: PPUSH
67233: CALL_OW 72
67237: AND
67238: PUSH
67239: LD_EXP 31
67243: PUSH
67244: LD_VAR 0 1
67248: ARRAY
67249: PPUSH
67250: LD_INT 30
67252: PUSH
67253: LD_INT 3
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PPUSH
67260: CALL_OW 72
67264: AND
67265: IFFALSE 67999
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67267: LD_ADDR_EXP 73
67271: PUSH
67272: LD_EXP 73
67276: PPUSH
67277: LD_VAR 0 1
67281: PPUSH
67282: LD_INT 3
67284: PPUSH
67285: CALL_OW 1
67289: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67290: LD_ADDR_VAR 0 2
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: LD_INT 0
67303: PUSH
67304: LD_INT 0
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: ST_TO_ADDR
// if not eng then
67313: LD_VAR 0 6
67317: NOT
67318: IFFALSE 67381
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67320: LD_ADDR_VAR 0 11
67324: PUSH
67325: LD_VAR 0 4
67329: PPUSH
67330: LD_INT 2
67332: PPUSH
67333: CALL 55769 0 2
67337: PUSH
67338: LD_INT 1
67340: ARRAY
67341: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67342: LD_ADDR_VAR 0 2
67346: PUSH
67347: LD_VAR 0 2
67351: PPUSH
67352: LD_INT 2
67354: PPUSH
67355: LD_VAR 0 11
67359: PPUSH
67360: CALL_OW 1
67364: ST_TO_ADDR
// tmp := tmp diff p ;
67365: LD_ADDR_VAR 0 4
67369: PUSH
67370: LD_VAR 0 4
67374: PUSH
67375: LD_VAR 0 11
67379: DIFF
67380: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67381: LD_VAR 0 4
67385: PUSH
67386: LD_VAR 0 8
67390: PUSH
67391: LD_INT 6
67393: LESS
67394: AND
67395: IFFALSE 67583
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67397: LD_ADDR_VAR 0 9
67401: PUSH
67402: LD_VAR 0 4
67406: PUSH
67407: LD_VAR 0 8
67411: PUSH
67412: LD_VAR 0 7
67416: UNION
67417: DIFF
67418: PPUSH
67419: LD_INT 4
67421: PPUSH
67422: CALL 55769 0 2
67426: ST_TO_ADDR
// p := [ ] ;
67427: LD_ADDR_VAR 0 11
67431: PUSH
67432: EMPTY
67433: ST_TO_ADDR
// if sort then
67434: LD_VAR 0 9
67438: IFFALSE 67554
// for i = 1 to 6 - sci do
67440: LD_ADDR_VAR 0 3
67444: PUSH
67445: DOUBLE
67446: LD_INT 1
67448: DEC
67449: ST_TO_ADDR
67450: LD_INT 6
67452: PUSH
67453: LD_VAR 0 8
67457: MINUS
67458: PUSH
67459: FOR_TO
67460: IFFALSE 67552
// begin if i = sort then
67462: LD_VAR 0 3
67466: PUSH
67467: LD_VAR 0 9
67471: EQUAL
67472: IFFALSE 67476
// break ;
67474: GO 67552
// if GetClass ( i ) = 4 then
67476: LD_VAR 0 3
67480: PPUSH
67481: CALL_OW 257
67485: PUSH
67486: LD_INT 4
67488: EQUAL
67489: IFFALSE 67493
// continue ;
67491: GO 67459
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67493: LD_ADDR_VAR 0 11
67497: PUSH
67498: LD_VAR 0 11
67502: PPUSH
67503: LD_VAR 0 11
67507: PUSH
67508: LD_INT 1
67510: PLUS
67511: PPUSH
67512: LD_VAR 0 9
67516: PUSH
67517: LD_VAR 0 3
67521: ARRAY
67522: PPUSH
67523: CALL_OW 2
67527: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67528: LD_ADDR_VAR 0 4
67532: PUSH
67533: LD_VAR 0 4
67537: PUSH
67538: LD_VAR 0 9
67542: PUSH
67543: LD_VAR 0 3
67547: ARRAY
67548: DIFF
67549: ST_TO_ADDR
// end ;
67550: GO 67459
67552: POP
67553: POP
// if p then
67554: LD_VAR 0 11
67558: IFFALSE 67583
// result := Replace ( result , 4 , p ) ;
67560: LD_ADDR_VAR 0 2
67564: PUSH
67565: LD_VAR 0 2
67569: PPUSH
67570: LD_INT 4
67572: PPUSH
67573: LD_VAR 0 11
67577: PPUSH
67578: CALL_OW 1
67582: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67583: LD_VAR 0 4
67587: PUSH
67588: LD_VAR 0 7
67592: PUSH
67593: LD_INT 6
67595: LESS
67596: AND
67597: IFFALSE 67785
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67599: LD_ADDR_VAR 0 9
67603: PUSH
67604: LD_VAR 0 4
67608: PUSH
67609: LD_VAR 0 8
67613: PUSH
67614: LD_VAR 0 7
67618: UNION
67619: DIFF
67620: PPUSH
67621: LD_INT 3
67623: PPUSH
67624: CALL 55769 0 2
67628: ST_TO_ADDR
// p := [ ] ;
67629: LD_ADDR_VAR 0 11
67633: PUSH
67634: EMPTY
67635: ST_TO_ADDR
// if sort then
67636: LD_VAR 0 9
67640: IFFALSE 67756
// for i = 1 to 6 - mech do
67642: LD_ADDR_VAR 0 3
67646: PUSH
67647: DOUBLE
67648: LD_INT 1
67650: DEC
67651: ST_TO_ADDR
67652: LD_INT 6
67654: PUSH
67655: LD_VAR 0 7
67659: MINUS
67660: PUSH
67661: FOR_TO
67662: IFFALSE 67754
// begin if i = sort then
67664: LD_VAR 0 3
67668: PUSH
67669: LD_VAR 0 9
67673: EQUAL
67674: IFFALSE 67678
// break ;
67676: GO 67754
// if GetClass ( i ) = 3 then
67678: LD_VAR 0 3
67682: PPUSH
67683: CALL_OW 257
67687: PUSH
67688: LD_INT 3
67690: EQUAL
67691: IFFALSE 67695
// continue ;
67693: GO 67661
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67695: LD_ADDR_VAR 0 11
67699: PUSH
67700: LD_VAR 0 11
67704: PPUSH
67705: LD_VAR 0 11
67709: PUSH
67710: LD_INT 1
67712: PLUS
67713: PPUSH
67714: LD_VAR 0 9
67718: PUSH
67719: LD_VAR 0 3
67723: ARRAY
67724: PPUSH
67725: CALL_OW 2
67729: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67730: LD_ADDR_VAR 0 4
67734: PUSH
67735: LD_VAR 0 4
67739: PUSH
67740: LD_VAR 0 9
67744: PUSH
67745: LD_VAR 0 3
67749: ARRAY
67750: DIFF
67751: ST_TO_ADDR
// end ;
67752: GO 67661
67754: POP
67755: POP
// if p then
67756: LD_VAR 0 11
67760: IFFALSE 67785
// result := Replace ( result , 3 , p ) ;
67762: LD_ADDR_VAR 0 2
67766: PUSH
67767: LD_VAR 0 2
67771: PPUSH
67772: LD_INT 3
67774: PPUSH
67775: LD_VAR 0 11
67779: PPUSH
67780: CALL_OW 1
67784: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67785: LD_VAR 0 4
67789: PUSH
67790: LD_INT 6
67792: GREATER
67793: PUSH
67794: LD_VAR 0 6
67798: PUSH
67799: LD_INT 6
67801: LESS
67802: AND
67803: IFFALSE 67997
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67805: LD_ADDR_VAR 0 9
67809: PUSH
67810: LD_VAR 0 4
67814: PUSH
67815: LD_VAR 0 8
67819: PUSH
67820: LD_VAR 0 7
67824: UNION
67825: PUSH
67826: LD_VAR 0 6
67830: UNION
67831: DIFF
67832: PPUSH
67833: LD_INT 2
67835: PPUSH
67836: CALL 55769 0 2
67840: ST_TO_ADDR
// p := [ ] ;
67841: LD_ADDR_VAR 0 11
67845: PUSH
67846: EMPTY
67847: ST_TO_ADDR
// if sort then
67848: LD_VAR 0 9
67852: IFFALSE 67968
// for i = 1 to 6 - eng do
67854: LD_ADDR_VAR 0 3
67858: PUSH
67859: DOUBLE
67860: LD_INT 1
67862: DEC
67863: ST_TO_ADDR
67864: LD_INT 6
67866: PUSH
67867: LD_VAR 0 6
67871: MINUS
67872: PUSH
67873: FOR_TO
67874: IFFALSE 67966
// begin if i = sort then
67876: LD_VAR 0 3
67880: PUSH
67881: LD_VAR 0 9
67885: EQUAL
67886: IFFALSE 67890
// break ;
67888: GO 67966
// if GetClass ( i ) = 2 then
67890: LD_VAR 0 3
67894: PPUSH
67895: CALL_OW 257
67899: PUSH
67900: LD_INT 2
67902: EQUAL
67903: IFFALSE 67907
// continue ;
67905: GO 67873
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67907: LD_ADDR_VAR 0 11
67911: PUSH
67912: LD_VAR 0 11
67916: PPUSH
67917: LD_VAR 0 11
67921: PUSH
67922: LD_INT 1
67924: PLUS
67925: PPUSH
67926: LD_VAR 0 9
67930: PUSH
67931: LD_VAR 0 3
67935: ARRAY
67936: PPUSH
67937: CALL_OW 2
67941: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67942: LD_ADDR_VAR 0 4
67946: PUSH
67947: LD_VAR 0 4
67951: PUSH
67952: LD_VAR 0 9
67956: PUSH
67957: LD_VAR 0 3
67961: ARRAY
67962: DIFF
67963: ST_TO_ADDR
// end ;
67964: GO 67873
67966: POP
67967: POP
// if p then
67968: LD_VAR 0 11
67972: IFFALSE 67997
// result := Replace ( result , 2 , p ) ;
67974: LD_ADDR_VAR 0 2
67978: PUSH
67979: LD_VAR 0 2
67983: PPUSH
67984: LD_INT 2
67986: PPUSH
67987: LD_VAR 0 11
67991: PPUSH
67992: CALL_OW 1
67996: ST_TO_ADDR
// end ; exit ;
67997: GO 69385
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67999: LD_EXP 58
68003: PUSH
68004: LD_EXP 57
68008: PUSH
68009: LD_VAR 0 1
68013: ARRAY
68014: ARRAY
68015: NOT
68016: PUSH
68017: LD_EXP 31
68021: PUSH
68022: LD_VAR 0 1
68026: ARRAY
68027: PPUSH
68028: LD_INT 30
68030: PUSH
68031: LD_INT 3
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PPUSH
68038: CALL_OW 72
68042: AND
68043: PUSH
68044: LD_EXP 36
68048: PUSH
68049: LD_VAR 0 1
68053: ARRAY
68054: AND
68055: IFFALSE 68663
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68057: LD_ADDR_EXP 73
68061: PUSH
68062: LD_EXP 73
68066: PPUSH
68067: LD_VAR 0 1
68071: PPUSH
68072: LD_INT 5
68074: PPUSH
68075: CALL_OW 1
68079: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68080: LD_ADDR_VAR 0 2
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: LD_INT 0
68090: PUSH
68091: LD_INT 0
68093: PUSH
68094: LD_INT 0
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: ST_TO_ADDR
// if sci > 1 then
68103: LD_VAR 0 8
68107: PUSH
68108: LD_INT 1
68110: GREATER
68111: IFFALSE 68139
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68113: LD_ADDR_VAR 0 4
68117: PUSH
68118: LD_VAR 0 4
68122: PUSH
68123: LD_VAR 0 8
68127: PUSH
68128: LD_VAR 0 8
68132: PUSH
68133: LD_INT 1
68135: ARRAY
68136: DIFF
68137: DIFF
68138: ST_TO_ADDR
// if tmp and not sci then
68139: LD_VAR 0 4
68143: PUSH
68144: LD_VAR 0 8
68148: NOT
68149: AND
68150: IFFALSE 68219
// begin sort := SortBySkill ( tmp , 4 ) ;
68152: LD_ADDR_VAR 0 9
68156: PUSH
68157: LD_VAR 0 4
68161: PPUSH
68162: LD_INT 4
68164: PPUSH
68165: CALL 55769 0 2
68169: ST_TO_ADDR
// if sort then
68170: LD_VAR 0 9
68174: IFFALSE 68190
// p := sort [ 1 ] ;
68176: LD_ADDR_VAR 0 11
68180: PUSH
68181: LD_VAR 0 9
68185: PUSH
68186: LD_INT 1
68188: ARRAY
68189: ST_TO_ADDR
// if p then
68190: LD_VAR 0 11
68194: IFFALSE 68219
// result := Replace ( result , 4 , p ) ;
68196: LD_ADDR_VAR 0 2
68200: PUSH
68201: LD_VAR 0 2
68205: PPUSH
68206: LD_INT 4
68208: PPUSH
68209: LD_VAR 0 11
68213: PPUSH
68214: CALL_OW 1
68218: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68219: LD_ADDR_VAR 0 4
68223: PUSH
68224: LD_VAR 0 4
68228: PUSH
68229: LD_VAR 0 7
68233: DIFF
68234: ST_TO_ADDR
// if tmp and mech < 6 then
68235: LD_VAR 0 4
68239: PUSH
68240: LD_VAR 0 7
68244: PUSH
68245: LD_INT 6
68247: LESS
68248: AND
68249: IFFALSE 68437
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68251: LD_ADDR_VAR 0 9
68255: PUSH
68256: LD_VAR 0 4
68260: PUSH
68261: LD_VAR 0 8
68265: PUSH
68266: LD_VAR 0 7
68270: UNION
68271: DIFF
68272: PPUSH
68273: LD_INT 3
68275: PPUSH
68276: CALL 55769 0 2
68280: ST_TO_ADDR
// p := [ ] ;
68281: LD_ADDR_VAR 0 11
68285: PUSH
68286: EMPTY
68287: ST_TO_ADDR
// if sort then
68288: LD_VAR 0 9
68292: IFFALSE 68408
// for i = 1 to 6 - mech do
68294: LD_ADDR_VAR 0 3
68298: PUSH
68299: DOUBLE
68300: LD_INT 1
68302: DEC
68303: ST_TO_ADDR
68304: LD_INT 6
68306: PUSH
68307: LD_VAR 0 7
68311: MINUS
68312: PUSH
68313: FOR_TO
68314: IFFALSE 68406
// begin if i = sort then
68316: LD_VAR 0 3
68320: PUSH
68321: LD_VAR 0 9
68325: EQUAL
68326: IFFALSE 68330
// break ;
68328: GO 68406
// if GetClass ( i ) = 3 then
68330: LD_VAR 0 3
68334: PPUSH
68335: CALL_OW 257
68339: PUSH
68340: LD_INT 3
68342: EQUAL
68343: IFFALSE 68347
// continue ;
68345: GO 68313
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68347: LD_ADDR_VAR 0 11
68351: PUSH
68352: LD_VAR 0 11
68356: PPUSH
68357: LD_VAR 0 11
68361: PUSH
68362: LD_INT 1
68364: PLUS
68365: PPUSH
68366: LD_VAR 0 9
68370: PUSH
68371: LD_VAR 0 3
68375: ARRAY
68376: PPUSH
68377: CALL_OW 2
68381: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68382: LD_ADDR_VAR 0 4
68386: PUSH
68387: LD_VAR 0 4
68391: PUSH
68392: LD_VAR 0 9
68396: PUSH
68397: LD_VAR 0 3
68401: ARRAY
68402: DIFF
68403: ST_TO_ADDR
// end ;
68404: GO 68313
68406: POP
68407: POP
// if p then
68408: LD_VAR 0 11
68412: IFFALSE 68437
// result := Replace ( result , 3 , p ) ;
68414: LD_ADDR_VAR 0 2
68418: PUSH
68419: LD_VAR 0 2
68423: PPUSH
68424: LD_INT 3
68426: PPUSH
68427: LD_VAR 0 11
68431: PPUSH
68432: CALL_OW 1
68436: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68437: LD_ADDR_VAR 0 4
68441: PUSH
68442: LD_VAR 0 4
68446: PUSH
68447: LD_VAR 0 6
68451: DIFF
68452: ST_TO_ADDR
// if tmp and eng < 6 then
68453: LD_VAR 0 4
68457: PUSH
68458: LD_VAR 0 6
68462: PUSH
68463: LD_INT 6
68465: LESS
68466: AND
68467: IFFALSE 68661
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68469: LD_ADDR_VAR 0 9
68473: PUSH
68474: LD_VAR 0 4
68478: PUSH
68479: LD_VAR 0 8
68483: PUSH
68484: LD_VAR 0 7
68488: UNION
68489: PUSH
68490: LD_VAR 0 6
68494: UNION
68495: DIFF
68496: PPUSH
68497: LD_INT 2
68499: PPUSH
68500: CALL 55769 0 2
68504: ST_TO_ADDR
// p := [ ] ;
68505: LD_ADDR_VAR 0 11
68509: PUSH
68510: EMPTY
68511: ST_TO_ADDR
// if sort then
68512: LD_VAR 0 9
68516: IFFALSE 68632
// for i = 1 to 6 - eng do
68518: LD_ADDR_VAR 0 3
68522: PUSH
68523: DOUBLE
68524: LD_INT 1
68526: DEC
68527: ST_TO_ADDR
68528: LD_INT 6
68530: PUSH
68531: LD_VAR 0 6
68535: MINUS
68536: PUSH
68537: FOR_TO
68538: IFFALSE 68630
// begin if i = sort then
68540: LD_VAR 0 3
68544: PUSH
68545: LD_VAR 0 9
68549: EQUAL
68550: IFFALSE 68554
// break ;
68552: GO 68630
// if GetClass ( i ) = 2 then
68554: LD_VAR 0 3
68558: PPUSH
68559: CALL_OW 257
68563: PUSH
68564: LD_INT 2
68566: EQUAL
68567: IFFALSE 68571
// continue ;
68569: GO 68537
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68571: LD_ADDR_VAR 0 11
68575: PUSH
68576: LD_VAR 0 11
68580: PPUSH
68581: LD_VAR 0 11
68585: PUSH
68586: LD_INT 1
68588: PLUS
68589: PPUSH
68590: LD_VAR 0 9
68594: PUSH
68595: LD_VAR 0 3
68599: ARRAY
68600: PPUSH
68601: CALL_OW 2
68605: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68606: LD_ADDR_VAR 0 4
68610: PUSH
68611: LD_VAR 0 4
68615: PUSH
68616: LD_VAR 0 9
68620: PUSH
68621: LD_VAR 0 3
68625: ARRAY
68626: DIFF
68627: ST_TO_ADDR
// end ;
68628: GO 68537
68630: POP
68631: POP
// if p then
68632: LD_VAR 0 11
68636: IFFALSE 68661
// result := Replace ( result , 2 , p ) ;
68638: LD_ADDR_VAR 0 2
68642: PUSH
68643: LD_VAR 0 2
68647: PPUSH
68648: LD_INT 2
68650: PPUSH
68651: LD_VAR 0 11
68655: PPUSH
68656: CALL_OW 1
68660: ST_TO_ADDR
// end ; exit ;
68661: GO 69385
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68663: LD_EXP 58
68667: PUSH
68668: LD_EXP 57
68672: PUSH
68673: LD_VAR 0 1
68677: ARRAY
68678: ARRAY
68679: NOT
68680: PUSH
68681: LD_EXP 31
68685: PUSH
68686: LD_VAR 0 1
68690: ARRAY
68691: PPUSH
68692: LD_INT 30
68694: PUSH
68695: LD_INT 3
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PPUSH
68702: CALL_OW 72
68706: AND
68707: PUSH
68708: LD_EXP 36
68712: PUSH
68713: LD_VAR 0 1
68717: ARRAY
68718: NOT
68719: AND
68720: IFFALSE 69385
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68722: LD_ADDR_EXP 73
68726: PUSH
68727: LD_EXP 73
68731: PPUSH
68732: LD_VAR 0 1
68736: PPUSH
68737: LD_INT 6
68739: PPUSH
68740: CALL_OW 1
68744: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68745: LD_ADDR_VAR 0 2
68749: PUSH
68750: LD_INT 0
68752: PUSH
68753: LD_INT 0
68755: PUSH
68756: LD_INT 0
68758: PUSH
68759: LD_INT 0
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: ST_TO_ADDR
// if sci >= 1 then
68768: LD_VAR 0 8
68772: PUSH
68773: LD_INT 1
68775: GREATEREQUAL
68776: IFFALSE 68798
// tmp := tmp diff sci [ 1 ] ;
68778: LD_ADDR_VAR 0 4
68782: PUSH
68783: LD_VAR 0 4
68787: PUSH
68788: LD_VAR 0 8
68792: PUSH
68793: LD_INT 1
68795: ARRAY
68796: DIFF
68797: ST_TO_ADDR
// if tmp and not sci then
68798: LD_VAR 0 4
68802: PUSH
68803: LD_VAR 0 8
68807: NOT
68808: AND
68809: IFFALSE 68878
// begin sort := SortBySkill ( tmp , 4 ) ;
68811: LD_ADDR_VAR 0 9
68815: PUSH
68816: LD_VAR 0 4
68820: PPUSH
68821: LD_INT 4
68823: PPUSH
68824: CALL 55769 0 2
68828: ST_TO_ADDR
// if sort then
68829: LD_VAR 0 9
68833: IFFALSE 68849
// p := sort [ 1 ] ;
68835: LD_ADDR_VAR 0 11
68839: PUSH
68840: LD_VAR 0 9
68844: PUSH
68845: LD_INT 1
68847: ARRAY
68848: ST_TO_ADDR
// if p then
68849: LD_VAR 0 11
68853: IFFALSE 68878
// result := Replace ( result , 4 , p ) ;
68855: LD_ADDR_VAR 0 2
68859: PUSH
68860: LD_VAR 0 2
68864: PPUSH
68865: LD_INT 4
68867: PPUSH
68868: LD_VAR 0 11
68872: PPUSH
68873: CALL_OW 1
68877: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68878: LD_ADDR_VAR 0 4
68882: PUSH
68883: LD_VAR 0 4
68887: PUSH
68888: LD_VAR 0 7
68892: DIFF
68893: ST_TO_ADDR
// if tmp and mech < 6 then
68894: LD_VAR 0 4
68898: PUSH
68899: LD_VAR 0 7
68903: PUSH
68904: LD_INT 6
68906: LESS
68907: AND
68908: IFFALSE 69090
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
68910: LD_ADDR_VAR 0 9
68914: PUSH
68915: LD_VAR 0 4
68919: PUSH
68920: LD_VAR 0 7
68924: DIFF
68925: PPUSH
68926: LD_INT 3
68928: PPUSH
68929: CALL 55769 0 2
68933: ST_TO_ADDR
// p := [ ] ;
68934: LD_ADDR_VAR 0 11
68938: PUSH
68939: EMPTY
68940: ST_TO_ADDR
// if sort then
68941: LD_VAR 0 9
68945: IFFALSE 69061
// for i = 1 to 6 - mech do
68947: LD_ADDR_VAR 0 3
68951: PUSH
68952: DOUBLE
68953: LD_INT 1
68955: DEC
68956: ST_TO_ADDR
68957: LD_INT 6
68959: PUSH
68960: LD_VAR 0 7
68964: MINUS
68965: PUSH
68966: FOR_TO
68967: IFFALSE 69059
// begin if i = sort then
68969: LD_VAR 0 3
68973: PUSH
68974: LD_VAR 0 9
68978: EQUAL
68979: IFFALSE 68983
// break ;
68981: GO 69059
// if GetClass ( i ) = 3 then
68983: LD_VAR 0 3
68987: PPUSH
68988: CALL_OW 257
68992: PUSH
68993: LD_INT 3
68995: EQUAL
68996: IFFALSE 69000
// continue ;
68998: GO 68966
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69000: LD_ADDR_VAR 0 11
69004: PUSH
69005: LD_VAR 0 11
69009: PPUSH
69010: LD_VAR 0 11
69014: PUSH
69015: LD_INT 1
69017: PLUS
69018: PPUSH
69019: LD_VAR 0 9
69023: PUSH
69024: LD_VAR 0 3
69028: ARRAY
69029: PPUSH
69030: CALL_OW 2
69034: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69035: LD_ADDR_VAR 0 4
69039: PUSH
69040: LD_VAR 0 4
69044: PUSH
69045: LD_VAR 0 9
69049: PUSH
69050: LD_VAR 0 3
69054: ARRAY
69055: DIFF
69056: ST_TO_ADDR
// end ;
69057: GO 68966
69059: POP
69060: POP
// if p then
69061: LD_VAR 0 11
69065: IFFALSE 69090
// result := Replace ( result , 3 , p ) ;
69067: LD_ADDR_VAR 0 2
69071: PUSH
69072: LD_VAR 0 2
69076: PPUSH
69077: LD_INT 3
69079: PPUSH
69080: LD_VAR 0 11
69084: PPUSH
69085: CALL_OW 1
69089: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69090: LD_ADDR_VAR 0 4
69094: PUSH
69095: LD_VAR 0 4
69099: PUSH
69100: LD_VAR 0 6
69104: DIFF
69105: ST_TO_ADDR
// if tmp and eng < 4 then
69106: LD_VAR 0 4
69110: PUSH
69111: LD_VAR 0 6
69115: PUSH
69116: LD_INT 4
69118: LESS
69119: AND
69120: IFFALSE 69310
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69122: LD_ADDR_VAR 0 9
69126: PUSH
69127: LD_VAR 0 4
69131: PUSH
69132: LD_VAR 0 7
69136: PUSH
69137: LD_VAR 0 6
69141: UNION
69142: DIFF
69143: PPUSH
69144: LD_INT 2
69146: PPUSH
69147: CALL 55769 0 2
69151: ST_TO_ADDR
// p := [ ] ;
69152: LD_ADDR_VAR 0 11
69156: PUSH
69157: EMPTY
69158: ST_TO_ADDR
// if sort then
69159: LD_VAR 0 9
69163: IFFALSE 69279
// for i = 1 to 4 - eng do
69165: LD_ADDR_VAR 0 3
69169: PUSH
69170: DOUBLE
69171: LD_INT 1
69173: DEC
69174: ST_TO_ADDR
69175: LD_INT 4
69177: PUSH
69178: LD_VAR 0 6
69182: MINUS
69183: PUSH
69184: FOR_TO
69185: IFFALSE 69277
// begin if i = sort then
69187: LD_VAR 0 3
69191: PUSH
69192: LD_VAR 0 9
69196: EQUAL
69197: IFFALSE 69201
// break ;
69199: GO 69277
// if GetClass ( i ) = 2 then
69201: LD_VAR 0 3
69205: PPUSH
69206: CALL_OW 257
69210: PUSH
69211: LD_INT 2
69213: EQUAL
69214: IFFALSE 69218
// continue ;
69216: GO 69184
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69218: LD_ADDR_VAR 0 11
69222: PUSH
69223: LD_VAR 0 11
69227: PPUSH
69228: LD_VAR 0 11
69232: PUSH
69233: LD_INT 1
69235: PLUS
69236: PPUSH
69237: LD_VAR 0 9
69241: PUSH
69242: LD_VAR 0 3
69246: ARRAY
69247: PPUSH
69248: CALL_OW 2
69252: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69253: LD_ADDR_VAR 0 4
69257: PUSH
69258: LD_VAR 0 4
69262: PUSH
69263: LD_VAR 0 9
69267: PUSH
69268: LD_VAR 0 3
69272: ARRAY
69273: DIFF
69274: ST_TO_ADDR
// end ;
69275: GO 69184
69277: POP
69278: POP
// if p then
69279: LD_VAR 0 11
69283: IFFALSE 69308
// result := Replace ( result , 2 , p ) ;
69285: LD_ADDR_VAR 0 2
69289: PUSH
69290: LD_VAR 0 2
69294: PPUSH
69295: LD_INT 2
69297: PPUSH
69298: LD_VAR 0 11
69302: PPUSH
69303: CALL_OW 1
69307: ST_TO_ADDR
// end else
69308: GO 69354
// for i = eng downto 5 do
69310: LD_ADDR_VAR 0 3
69314: PUSH
69315: DOUBLE
69316: LD_VAR 0 6
69320: INC
69321: ST_TO_ADDR
69322: LD_INT 5
69324: PUSH
69325: FOR_DOWNTO
69326: IFFALSE 69352
// tmp := tmp union eng [ i ] ;
69328: LD_ADDR_VAR 0 4
69332: PUSH
69333: LD_VAR 0 4
69337: PUSH
69338: LD_VAR 0 6
69342: PUSH
69343: LD_VAR 0 3
69347: ARRAY
69348: UNION
69349: ST_TO_ADDR
69350: GO 69325
69352: POP
69353: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69354: LD_ADDR_VAR 0 2
69358: PUSH
69359: LD_VAR 0 2
69363: PPUSH
69364: LD_INT 1
69366: PPUSH
69367: LD_VAR 0 4
69371: PUSH
69372: LD_VAR 0 5
69376: DIFF
69377: PPUSH
69378: CALL_OW 1
69382: ST_TO_ADDR
// exit ;
69383: GO 69385
// end ; end ;
69385: LD_VAR 0 2
69389: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69390: LD_INT 0
69392: PPUSH
69393: PPUSH
69394: PPUSH
// if not mc_bases then
69395: LD_EXP 31
69399: NOT
69400: IFFALSE 69404
// exit ;
69402: GO 69546
// for i = 1 to mc_bases do
69404: LD_ADDR_VAR 0 2
69408: PUSH
69409: DOUBLE
69410: LD_INT 1
69412: DEC
69413: ST_TO_ADDR
69414: LD_EXP 31
69418: PUSH
69419: FOR_TO
69420: IFFALSE 69537
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69422: LD_ADDR_VAR 0 3
69426: PUSH
69427: LD_EXP 31
69431: PUSH
69432: LD_VAR 0 2
69436: ARRAY
69437: PPUSH
69438: LD_INT 21
69440: PUSH
69441: LD_INT 3
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 3
69450: PUSH
69451: LD_INT 2
69453: PUSH
69454: LD_INT 30
69456: PUSH
69457: LD_INT 29
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 30
69466: PUSH
69467: LD_INT 30
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: LIST
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 3
69485: PUSH
69486: LD_INT 24
69488: PUSH
69489: LD_INT 1000
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: LIST
69504: PPUSH
69505: CALL_OW 72
69509: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69510: LD_ADDR_EXP 32
69514: PUSH
69515: LD_EXP 32
69519: PPUSH
69520: LD_VAR 0 2
69524: PPUSH
69525: LD_VAR 0 3
69529: PPUSH
69530: CALL_OW 1
69534: ST_TO_ADDR
// end ;
69535: GO 69419
69537: POP
69538: POP
// RaiseSailEvent ( 101 ) ;
69539: LD_INT 101
69541: PPUSH
69542: CALL_OW 427
// end ;
69546: LD_VAR 0 1
69550: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69551: LD_INT 0
69553: PPUSH
69554: PPUSH
69555: PPUSH
69556: PPUSH
69557: PPUSH
69558: PPUSH
69559: PPUSH
// if not mc_bases then
69560: LD_EXP 31
69564: NOT
69565: IFFALSE 69569
// exit ;
69567: GO 70131
// for i = 1 to mc_bases do
69569: LD_ADDR_VAR 0 2
69573: PUSH
69574: DOUBLE
69575: LD_INT 1
69577: DEC
69578: ST_TO_ADDR
69579: LD_EXP 31
69583: PUSH
69584: FOR_TO
69585: IFFALSE 70122
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69587: LD_ADDR_VAR 0 5
69591: PUSH
69592: LD_EXP 31
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: LD_EXP 60
69607: PUSH
69608: LD_VAR 0 2
69612: ARRAY
69613: UNION
69614: PPUSH
69615: LD_INT 21
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 1
69627: PUSH
69628: LD_INT 3
69630: PUSH
69631: LD_INT 54
69633: PUSH
69634: EMPTY
69635: LIST
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 3
69643: PUSH
69644: LD_INT 24
69646: PUSH
69647: LD_INT 1000
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: LIST
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PPUSH
69667: CALL_OW 72
69671: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69672: LD_ADDR_VAR 0 6
69676: PUSH
69677: LD_EXP 31
69681: PUSH
69682: LD_VAR 0 2
69686: ARRAY
69687: PPUSH
69688: LD_INT 21
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 1
69700: PUSH
69701: LD_INT 3
69703: PUSH
69704: LD_INT 54
69706: PUSH
69707: EMPTY
69708: LIST
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 3
69716: PUSH
69717: LD_INT 24
69719: PUSH
69720: LD_INT 250
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: PPUSH
69740: CALL_OW 72
69744: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69745: LD_ADDR_VAR 0 7
69749: PUSH
69750: LD_VAR 0 5
69754: PUSH
69755: LD_VAR 0 6
69759: DIFF
69760: ST_TO_ADDR
// if not need_heal_1 then
69761: LD_VAR 0 6
69765: NOT
69766: IFFALSE 69799
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69768: LD_ADDR_EXP 34
69772: PUSH
69773: LD_EXP 34
69777: PPUSH
69778: LD_VAR 0 2
69782: PUSH
69783: LD_INT 1
69785: PUSH
69786: EMPTY
69787: LIST
69788: LIST
69789: PPUSH
69790: EMPTY
69791: PPUSH
69792: CALL 25021 0 3
69796: ST_TO_ADDR
69797: GO 69869
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69799: LD_ADDR_EXP 34
69803: PUSH
69804: LD_EXP 34
69808: PPUSH
69809: LD_VAR 0 2
69813: PUSH
69814: LD_INT 1
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PPUSH
69821: LD_EXP 34
69825: PUSH
69826: LD_VAR 0 2
69830: ARRAY
69831: PUSH
69832: LD_INT 1
69834: ARRAY
69835: PPUSH
69836: LD_INT 3
69838: PUSH
69839: LD_INT 24
69841: PUSH
69842: LD_INT 1000
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PPUSH
69853: CALL_OW 72
69857: PUSH
69858: LD_VAR 0 6
69862: UNION
69863: PPUSH
69864: CALL 25021 0 3
69868: ST_TO_ADDR
// if not need_heal_2 then
69869: LD_VAR 0 7
69873: NOT
69874: IFFALSE 69907
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
69876: LD_ADDR_EXP 34
69880: PUSH
69881: LD_EXP 34
69885: PPUSH
69886: LD_VAR 0 2
69890: PUSH
69891: LD_INT 2
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PPUSH
69898: EMPTY
69899: PPUSH
69900: CALL 25021 0 3
69904: ST_TO_ADDR
69905: GO 69939
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
69907: LD_ADDR_EXP 34
69911: PUSH
69912: LD_EXP 34
69916: PPUSH
69917: LD_VAR 0 2
69921: PUSH
69922: LD_INT 2
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PPUSH
69929: LD_VAR 0 7
69933: PPUSH
69934: CALL 25021 0 3
69938: ST_TO_ADDR
// if need_heal_2 then
69939: LD_VAR 0 7
69943: IFFALSE 70104
// for j in need_heal_2 do
69945: LD_ADDR_VAR 0 3
69949: PUSH
69950: LD_VAR 0 7
69954: PUSH
69955: FOR_IN
69956: IFFALSE 70102
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69958: LD_ADDR_VAR 0 5
69962: PUSH
69963: LD_EXP 31
69967: PUSH
69968: LD_VAR 0 2
69972: ARRAY
69973: PPUSH
69974: LD_INT 2
69976: PUSH
69977: LD_INT 30
69979: PUSH
69980: LD_INT 6
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 30
69989: PUSH
69990: LD_INT 7
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 30
69999: PUSH
70000: LD_INT 8
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 30
70009: PUSH
70010: LD_INT 0
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 30
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: PPUSH
70035: CALL_OW 72
70039: ST_TO_ADDR
// if tmp then
70040: LD_VAR 0 5
70044: IFFALSE 70100
// begin k := NearestUnitToUnit ( tmp , j ) ;
70046: LD_ADDR_VAR 0 4
70050: PUSH
70051: LD_VAR 0 5
70055: PPUSH
70056: LD_VAR 0 3
70060: PPUSH
70061: CALL_OW 74
70065: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70066: LD_VAR 0 3
70070: PPUSH
70071: LD_VAR 0 4
70075: PPUSH
70076: CALL_OW 296
70080: PUSH
70081: LD_INT 5
70083: GREATER
70084: IFFALSE 70100
// ComMoveToNearbyEntrance ( j , k ) ;
70086: LD_VAR 0 3
70090: PPUSH
70091: LD_VAR 0 4
70095: PPUSH
70096: CALL 58137 0 2
// end ; end ;
70100: GO 69955
70102: POP
70103: POP
// if not need_heal_1 and not need_heal_2 then
70104: LD_VAR 0 6
70108: NOT
70109: PUSH
70110: LD_VAR 0 7
70114: NOT
70115: AND
70116: IFFALSE 70120
// continue ;
70118: GO 69584
// end ;
70120: GO 69584
70122: POP
70123: POP
// RaiseSailEvent ( 102 ) ;
70124: LD_INT 102
70126: PPUSH
70127: CALL_OW 427
// end ;
70131: LD_VAR 0 1
70135: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70136: LD_INT 0
70138: PPUSH
70139: PPUSH
70140: PPUSH
70141: PPUSH
70142: PPUSH
70143: PPUSH
70144: PPUSH
70145: PPUSH
// if not mc_bases then
70146: LD_EXP 31
70150: NOT
70151: IFFALSE 70155
// exit ;
70153: GO 71034
// for i = 1 to mc_bases do
70155: LD_ADDR_VAR 0 2
70159: PUSH
70160: DOUBLE
70161: LD_INT 1
70163: DEC
70164: ST_TO_ADDR
70165: LD_EXP 31
70169: PUSH
70170: FOR_TO
70171: IFFALSE 71032
// begin if not mc_building_need_repair [ i ] then
70173: LD_EXP 32
70177: PUSH
70178: LD_VAR 0 2
70182: ARRAY
70183: NOT
70184: IFFALSE 70369
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70186: LD_ADDR_VAR 0 6
70190: PUSH
70191: LD_EXP 50
70195: PUSH
70196: LD_VAR 0 2
70200: ARRAY
70201: PPUSH
70202: LD_INT 3
70204: PUSH
70205: LD_INT 24
70207: PUSH
70208: LD_INT 1000
70210: PUSH
70211: EMPTY
70212: LIST
70213: LIST
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: PUSH
70222: LD_INT 34
70224: PUSH
70225: LD_INT 13
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 34
70234: PUSH
70235: LD_INT 52
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 34
70244: PUSH
70245: LD_INT 88
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: EMPTY
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PPUSH
70262: CALL_OW 72
70266: ST_TO_ADDR
// if cranes then
70267: LD_VAR 0 6
70271: IFFALSE 70333
// for j in cranes do
70273: LD_ADDR_VAR 0 3
70277: PUSH
70278: LD_VAR 0 6
70282: PUSH
70283: FOR_IN
70284: IFFALSE 70331
// if not IsInArea ( j , mc_parking [ i ] ) then
70286: LD_VAR 0 3
70290: PPUSH
70291: LD_EXP 55
70295: PUSH
70296: LD_VAR 0 2
70300: ARRAY
70301: PPUSH
70302: CALL_OW 308
70306: NOT
70307: IFFALSE 70329
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70309: LD_VAR 0 3
70313: PPUSH
70314: LD_EXP 55
70318: PUSH
70319: LD_VAR 0 2
70323: ARRAY
70324: PPUSH
70325: CALL_OW 113
70329: GO 70283
70331: POP
70332: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70333: LD_ADDR_EXP 33
70337: PUSH
70338: LD_EXP 33
70342: PPUSH
70343: LD_VAR 0 2
70347: PPUSH
70348: EMPTY
70349: PPUSH
70350: CALL_OW 1
70354: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70355: LD_VAR 0 2
70359: PPUSH
70360: LD_INT 101
70362: PPUSH
70363: CALL 65223 0 2
// continue ;
70367: GO 70170
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70369: LD_ADDR_EXP 37
70373: PUSH
70374: LD_EXP 37
70378: PPUSH
70379: LD_VAR 0 2
70383: PPUSH
70384: EMPTY
70385: PPUSH
70386: CALL_OW 1
70390: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70391: LD_VAR 0 2
70395: PPUSH
70396: LD_INT 103
70398: PPUSH
70399: CALL 65223 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70403: LD_ADDR_VAR 0 5
70407: PUSH
70408: LD_EXP 31
70412: PUSH
70413: LD_VAR 0 2
70417: ARRAY
70418: PUSH
70419: LD_EXP 60
70423: PUSH
70424: LD_VAR 0 2
70428: ARRAY
70429: UNION
70430: PPUSH
70431: LD_INT 2
70433: PUSH
70434: LD_INT 25
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 25
70446: PUSH
70447: LD_INT 16
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: LIST
70458: PUSH
70459: EMPTY
70460: LIST
70461: PPUSH
70462: CALL_OW 72
70466: ST_TO_ADDR
// if mc_need_heal [ i ] then
70467: LD_EXP 34
70471: PUSH
70472: LD_VAR 0 2
70476: ARRAY
70477: IFFALSE 70521
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70479: LD_ADDR_VAR 0 5
70483: PUSH
70484: LD_VAR 0 5
70488: PUSH
70489: LD_EXP 34
70493: PUSH
70494: LD_VAR 0 2
70498: ARRAY
70499: PUSH
70500: LD_INT 1
70502: ARRAY
70503: PUSH
70504: LD_EXP 34
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PUSH
70515: LD_INT 2
70517: ARRAY
70518: UNION
70519: DIFF
70520: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70521: LD_ADDR_VAR 0 6
70525: PUSH
70526: LD_EXP 50
70530: PUSH
70531: LD_VAR 0 2
70535: ARRAY
70536: PPUSH
70537: LD_INT 2
70539: PUSH
70540: LD_INT 34
70542: PUSH
70543: LD_INT 13
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: PUSH
70550: LD_INT 34
70552: PUSH
70553: LD_INT 52
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 34
70562: PUSH
70563: LD_INT 88
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: PPUSH
70576: CALL_OW 72
70580: ST_TO_ADDR
// if cranes then
70581: LD_VAR 0 6
70585: IFFALSE 70721
// begin for j in cranes do
70587: LD_ADDR_VAR 0 3
70591: PUSH
70592: LD_VAR 0 6
70596: PUSH
70597: FOR_IN
70598: IFFALSE 70719
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70600: LD_VAR 0 3
70604: PPUSH
70605: CALL_OW 256
70609: PUSH
70610: LD_INT 1000
70612: EQUAL
70613: PUSH
70614: LD_VAR 0 3
70618: PPUSH
70619: CALL_OW 314
70623: NOT
70624: AND
70625: IFFALSE 70659
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
70627: LD_VAR 0 3
70631: PPUSH
70632: LD_EXP 32
70636: PUSH
70637: LD_VAR 0 2
70641: ARRAY
70642: PPUSH
70643: LD_VAR 0 3
70647: PPUSH
70648: CALL_OW 74
70652: PPUSH
70653: CALL_OW 130
70657: GO 70717
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70659: LD_VAR 0 3
70663: PPUSH
70664: CALL_OW 256
70668: PUSH
70669: LD_INT 500
70671: LESS
70672: PUSH
70673: LD_VAR 0 3
70677: PPUSH
70678: LD_EXP 55
70682: PUSH
70683: LD_VAR 0 2
70687: ARRAY
70688: PPUSH
70689: CALL_OW 308
70693: NOT
70694: AND
70695: IFFALSE 70717
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70697: LD_VAR 0 3
70701: PPUSH
70702: LD_EXP 55
70706: PUSH
70707: LD_VAR 0 2
70711: ARRAY
70712: PPUSH
70713: CALL_OW 113
// end ;
70717: GO 70597
70719: POP
70720: POP
// end ; if tmp > 3 then
70721: LD_VAR 0 5
70725: PUSH
70726: LD_INT 3
70728: GREATER
70729: IFFALSE 70749
// tmp := ShrinkArray ( tmp , 4 ) ;
70731: LD_ADDR_VAR 0 5
70735: PUSH
70736: LD_VAR 0 5
70740: PPUSH
70741: LD_INT 4
70743: PPUSH
70744: CALL 57575 0 2
70748: ST_TO_ADDR
// if not tmp then
70749: LD_VAR 0 5
70753: NOT
70754: IFFALSE 70758
// continue ;
70756: GO 70170
// for j in tmp do
70758: LD_ADDR_VAR 0 3
70762: PUSH
70763: LD_VAR 0 5
70767: PUSH
70768: FOR_IN
70769: IFFALSE 71028
// begin if IsInUnit ( j ) then
70771: LD_VAR 0 3
70775: PPUSH
70776: CALL_OW 310
70780: IFFALSE 70791
// ComExitBuilding ( j ) ;
70782: LD_VAR 0 3
70786: PPUSH
70787: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
70791: LD_VAR 0 3
70795: PUSH
70796: LD_EXP 33
70800: PUSH
70801: LD_VAR 0 2
70805: ARRAY
70806: IN
70807: NOT
70808: IFFALSE 70866
// begin SetTag ( j , 101 ) ;
70810: LD_VAR 0 3
70814: PPUSH
70815: LD_INT 101
70817: PPUSH
70818: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
70822: LD_ADDR_EXP 33
70826: PUSH
70827: LD_EXP 33
70831: PPUSH
70832: LD_VAR 0 2
70836: PUSH
70837: LD_EXP 33
70841: PUSH
70842: LD_VAR 0 2
70846: ARRAY
70847: PUSH
70848: LD_INT 1
70850: PLUS
70851: PUSH
70852: EMPTY
70853: LIST
70854: LIST
70855: PPUSH
70856: LD_VAR 0 3
70860: PPUSH
70861: CALL 25021 0 3
70865: ST_TO_ADDR
// end ; wait ( 1 ) ;
70866: LD_INT 1
70868: PPUSH
70869: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
70873: LD_ADDR_VAR 0 7
70877: PUSH
70878: LD_EXP 32
70882: PUSH
70883: LD_VAR 0 2
70887: ARRAY
70888: ST_TO_ADDR
// if mc_scan [ i ] then
70889: LD_EXP 54
70893: PUSH
70894: LD_VAR 0 2
70898: ARRAY
70899: IFFALSE 70961
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
70901: LD_ADDR_VAR 0 7
70905: PUSH
70906: LD_EXP 32
70910: PUSH
70911: LD_VAR 0 2
70915: ARRAY
70916: PPUSH
70917: LD_INT 3
70919: PUSH
70920: LD_INT 30
70922: PUSH
70923: LD_INT 32
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 30
70932: PUSH
70933: LD_INT 33
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 30
70942: PUSH
70943: LD_INT 31
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: PPUSH
70956: CALL_OW 72
70960: ST_TO_ADDR
// if not to_repair_tmp then
70961: LD_VAR 0 7
70965: NOT
70966: IFFALSE 70970
// continue ;
70968: GO 70768
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70970: LD_ADDR_VAR 0 8
70974: PUSH
70975: LD_VAR 0 7
70979: PPUSH
70980: LD_VAR 0 3
70984: PPUSH
70985: CALL_OW 74
70989: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70990: LD_VAR 0 8
70994: PPUSH
70995: LD_INT 16
70997: PPUSH
70998: CALL 27618 0 2
71002: PUSH
71003: LD_INT 4
71005: ARRAY
71006: PUSH
71007: LD_INT 10
71009: LESS
71010: IFFALSE 71026
// ComRepairBuilding ( j , to_repair ) ;
71012: LD_VAR 0 3
71016: PPUSH
71017: LD_VAR 0 8
71021: PPUSH
71022: CALL_OW 130
// end ;
71026: GO 70768
71028: POP
71029: POP
// end ;
71030: GO 70170
71032: POP
71033: POP
// end ;
71034: LD_VAR 0 1
71038: RET
// export function MC_Heal ; var i , j , tmp ; begin
71039: LD_INT 0
71041: PPUSH
71042: PPUSH
71043: PPUSH
71044: PPUSH
// if not mc_bases then
71045: LD_EXP 31
71049: NOT
71050: IFFALSE 71054
// exit ;
71052: GO 71456
// for i = 1 to mc_bases do
71054: LD_ADDR_VAR 0 2
71058: PUSH
71059: DOUBLE
71060: LD_INT 1
71062: DEC
71063: ST_TO_ADDR
71064: LD_EXP 31
71068: PUSH
71069: FOR_TO
71070: IFFALSE 71454
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71072: LD_EXP 34
71076: PUSH
71077: LD_VAR 0 2
71081: ARRAY
71082: PUSH
71083: LD_INT 1
71085: ARRAY
71086: NOT
71087: PUSH
71088: LD_EXP 34
71092: PUSH
71093: LD_VAR 0 2
71097: ARRAY
71098: PUSH
71099: LD_INT 2
71101: ARRAY
71102: NOT
71103: AND
71104: IFFALSE 71142
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71106: LD_ADDR_EXP 35
71110: PUSH
71111: LD_EXP 35
71115: PPUSH
71116: LD_VAR 0 2
71120: PPUSH
71121: EMPTY
71122: PPUSH
71123: CALL_OW 1
71127: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71128: LD_VAR 0 2
71132: PPUSH
71133: LD_INT 102
71135: PPUSH
71136: CALL 65223 0 2
// continue ;
71140: GO 71069
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71142: LD_ADDR_VAR 0 4
71146: PUSH
71147: LD_EXP 31
71151: PUSH
71152: LD_VAR 0 2
71156: ARRAY
71157: PPUSH
71158: LD_INT 25
71160: PUSH
71161: LD_INT 4
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PPUSH
71168: CALL_OW 72
71172: ST_TO_ADDR
// if not tmp then
71173: LD_VAR 0 4
71177: NOT
71178: IFFALSE 71182
// continue ;
71180: GO 71069
// if mc_taming [ i ] then
71182: LD_EXP 62
71186: PUSH
71187: LD_VAR 0 2
71191: ARRAY
71192: IFFALSE 71216
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71194: LD_ADDR_EXP 62
71198: PUSH
71199: LD_EXP 62
71203: PPUSH
71204: LD_VAR 0 2
71208: PPUSH
71209: EMPTY
71210: PPUSH
71211: CALL_OW 1
71215: ST_TO_ADDR
// for j in tmp do
71216: LD_ADDR_VAR 0 3
71220: PUSH
71221: LD_VAR 0 4
71225: PUSH
71226: FOR_IN
71227: IFFALSE 71450
// begin if IsInUnit ( j ) then
71229: LD_VAR 0 3
71233: PPUSH
71234: CALL_OW 310
71238: IFFALSE 71249
// ComExitBuilding ( j ) ;
71240: LD_VAR 0 3
71244: PPUSH
71245: CALL_OW 122
// if not j in mc_healers [ i ] then
71249: LD_VAR 0 3
71253: PUSH
71254: LD_EXP 35
71258: PUSH
71259: LD_VAR 0 2
71263: ARRAY
71264: IN
71265: NOT
71266: IFFALSE 71312
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71268: LD_ADDR_EXP 35
71272: PUSH
71273: LD_EXP 35
71277: PPUSH
71278: LD_VAR 0 2
71282: PUSH
71283: LD_EXP 35
71287: PUSH
71288: LD_VAR 0 2
71292: ARRAY
71293: PUSH
71294: LD_INT 1
71296: PLUS
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: LD_VAR 0 3
71306: PPUSH
71307: CALL 25021 0 3
71311: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71312: LD_VAR 0 3
71316: PPUSH
71317: CALL_OW 110
71321: PUSH
71322: LD_INT 102
71324: NONEQUAL
71325: IFFALSE 71339
// SetTag ( j , 102 ) ;
71327: LD_VAR 0 3
71331: PPUSH
71332: LD_INT 102
71334: PPUSH
71335: CALL_OW 109
// Wait ( 3 ) ;
71339: LD_INT 3
71341: PPUSH
71342: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71346: LD_EXP 34
71350: PUSH
71351: LD_VAR 0 2
71355: ARRAY
71356: PUSH
71357: LD_INT 1
71359: ARRAY
71360: IFFALSE 71392
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71362: LD_VAR 0 3
71366: PPUSH
71367: LD_EXP 34
71371: PUSH
71372: LD_VAR 0 2
71376: ARRAY
71377: PUSH
71378: LD_INT 1
71380: ARRAY
71381: PUSH
71382: LD_INT 1
71384: ARRAY
71385: PPUSH
71386: CALL_OW 128
71390: GO 71448
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71392: LD_VAR 0 3
71396: PPUSH
71397: CALL_OW 314
71401: NOT
71402: PUSH
71403: LD_EXP 34
71407: PUSH
71408: LD_VAR 0 2
71412: ARRAY
71413: PUSH
71414: LD_INT 2
71416: ARRAY
71417: AND
71418: IFFALSE 71448
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71420: LD_VAR 0 3
71424: PPUSH
71425: LD_EXP 34
71429: PUSH
71430: LD_VAR 0 2
71434: ARRAY
71435: PUSH
71436: LD_INT 2
71438: ARRAY
71439: PUSH
71440: LD_INT 1
71442: ARRAY
71443: PPUSH
71444: CALL_OW 128
// end ;
71448: GO 71226
71450: POP
71451: POP
// end ;
71452: GO 71069
71454: POP
71455: POP
// end ;
71456: LD_VAR 0 1
71460: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
71461: LD_INT 0
71463: PPUSH
71464: PPUSH
71465: PPUSH
71466: PPUSH
71467: PPUSH
// if not mc_bases then
71468: LD_EXP 31
71472: NOT
71473: IFFALSE 71477
// exit ;
71475: GO 72648
// for i = 1 to mc_bases do
71477: LD_ADDR_VAR 0 2
71481: PUSH
71482: DOUBLE
71483: LD_INT 1
71485: DEC
71486: ST_TO_ADDR
71487: LD_EXP 31
71491: PUSH
71492: FOR_TO
71493: IFFALSE 72646
// begin if mc_scan [ i ] then
71495: LD_EXP 54
71499: PUSH
71500: LD_VAR 0 2
71504: ARRAY
71505: IFFALSE 71509
// continue ;
71507: GO 71492
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71509: LD_EXP 36
71513: PUSH
71514: LD_VAR 0 2
71518: ARRAY
71519: NOT
71520: PUSH
71521: LD_EXP 38
71525: PUSH
71526: LD_VAR 0 2
71530: ARRAY
71531: NOT
71532: AND
71533: PUSH
71534: LD_EXP 37
71538: PUSH
71539: LD_VAR 0 2
71543: ARRAY
71544: AND
71545: IFFALSE 71583
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71547: LD_ADDR_EXP 37
71551: PUSH
71552: LD_EXP 37
71556: PPUSH
71557: LD_VAR 0 2
71561: PPUSH
71562: EMPTY
71563: PPUSH
71564: CALL_OW 1
71568: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71569: LD_VAR 0 2
71573: PPUSH
71574: LD_INT 103
71576: PPUSH
71577: CALL 65223 0 2
// continue ;
71581: GO 71492
// end ; if mc_construct_list [ i ] then
71583: LD_EXP 38
71587: PUSH
71588: LD_VAR 0 2
71592: ARRAY
71593: IFFALSE 71813
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71595: LD_ADDR_VAR 0 4
71599: PUSH
71600: LD_EXP 31
71604: PUSH
71605: LD_VAR 0 2
71609: ARRAY
71610: PPUSH
71611: LD_INT 25
71613: PUSH
71614: LD_INT 2
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PPUSH
71621: CALL_OW 72
71625: PUSH
71626: LD_EXP 33
71630: PUSH
71631: LD_VAR 0 2
71635: ARRAY
71636: DIFF
71637: ST_TO_ADDR
// if not tmp then
71638: LD_VAR 0 4
71642: NOT
71643: IFFALSE 71647
// continue ;
71645: GO 71492
// for j in tmp do
71647: LD_ADDR_VAR 0 3
71651: PUSH
71652: LD_VAR 0 4
71656: PUSH
71657: FOR_IN
71658: IFFALSE 71809
// begin if not mc_builders [ i ] then
71660: LD_EXP 37
71664: PUSH
71665: LD_VAR 0 2
71669: ARRAY
71670: NOT
71671: IFFALSE 71729
// begin SetTag ( j , 103 ) ;
71673: LD_VAR 0 3
71677: PPUSH
71678: LD_INT 103
71680: PPUSH
71681: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71685: LD_ADDR_EXP 37
71689: PUSH
71690: LD_EXP 37
71694: PPUSH
71695: LD_VAR 0 2
71699: PUSH
71700: LD_EXP 37
71704: PUSH
71705: LD_VAR 0 2
71709: ARRAY
71710: PUSH
71711: LD_INT 1
71713: PLUS
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PPUSH
71719: LD_VAR 0 3
71723: PPUSH
71724: CALL 25021 0 3
71728: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71729: LD_VAR 0 3
71733: PPUSH
71734: CALL_OW 310
71738: IFFALSE 71749
// ComExitBuilding ( j ) ;
71740: LD_VAR 0 3
71744: PPUSH
71745: CALL_OW 122
// wait ( 3 ) ;
71749: LD_INT 3
71751: PPUSH
71752: CALL_OW 67
// if not mc_construct_list [ i ] then
71756: LD_EXP 38
71760: PUSH
71761: LD_VAR 0 2
71765: ARRAY
71766: NOT
71767: IFFALSE 71771
// break ;
71769: GO 71809
// if not HasTask ( j ) then
71771: LD_VAR 0 3
71775: PPUSH
71776: CALL_OW 314
71780: NOT
71781: IFFALSE 71807
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
71783: LD_VAR 0 3
71787: PPUSH
71788: LD_EXP 38
71792: PUSH
71793: LD_VAR 0 2
71797: ARRAY
71798: PUSH
71799: LD_INT 1
71801: ARRAY
71802: PPUSH
71803: CALL 27882 0 2
// end ;
71807: GO 71657
71809: POP
71810: POP
// end else
71811: GO 72644
// if mc_build_list [ i ] then
71813: LD_EXP 36
71817: PUSH
71818: LD_VAR 0 2
71822: ARRAY
71823: IFFALSE 72644
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71825: LD_ADDR_VAR 0 5
71829: PUSH
71830: LD_EXP 31
71834: PUSH
71835: LD_VAR 0 2
71839: ARRAY
71840: PPUSH
71841: LD_INT 2
71843: PUSH
71844: LD_INT 30
71846: PUSH
71847: LD_INT 0
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 30
71856: PUSH
71857: LD_INT 1
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: LIST
71868: PPUSH
71869: CALL_OW 72
71873: ST_TO_ADDR
// if depot then
71874: LD_VAR 0 5
71878: IFFALSE 71896
// depot := depot [ 1 ] else
71880: LD_ADDR_VAR 0 5
71884: PUSH
71885: LD_VAR 0 5
71889: PUSH
71890: LD_INT 1
71892: ARRAY
71893: ST_TO_ADDR
71894: GO 71904
// depot := 0 ;
71896: LD_ADDR_VAR 0 5
71900: PUSH
71901: LD_INT 0
71903: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
71904: LD_EXP 36
71908: PUSH
71909: LD_VAR 0 2
71913: ARRAY
71914: PUSH
71915: LD_INT 1
71917: ARRAY
71918: PUSH
71919: LD_INT 1
71921: ARRAY
71922: PPUSH
71923: CALL 27706 0 1
71927: PUSH
71928: LD_EXP 31
71932: PUSH
71933: LD_VAR 0 2
71937: ARRAY
71938: PPUSH
71939: LD_INT 2
71941: PUSH
71942: LD_INT 30
71944: PUSH
71945: LD_INT 2
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 30
71954: PUSH
71955: LD_INT 3
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: EMPTY
71963: LIST
71964: LIST
71965: LIST
71966: PPUSH
71967: CALL_OW 72
71971: NOT
71972: AND
71973: IFFALSE 72078
// begin for j = 1 to mc_build_list [ i ] do
71975: LD_ADDR_VAR 0 3
71979: PUSH
71980: DOUBLE
71981: LD_INT 1
71983: DEC
71984: ST_TO_ADDR
71985: LD_EXP 36
71989: PUSH
71990: LD_VAR 0 2
71994: ARRAY
71995: PUSH
71996: FOR_TO
71997: IFFALSE 72076
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71999: LD_EXP 36
72003: PUSH
72004: LD_VAR 0 2
72008: ARRAY
72009: PUSH
72010: LD_VAR 0 3
72014: ARRAY
72015: PUSH
72016: LD_INT 1
72018: ARRAY
72019: PUSH
72020: LD_INT 2
72022: EQUAL
72023: IFFALSE 72074
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72025: LD_ADDR_EXP 36
72029: PUSH
72030: LD_EXP 36
72034: PPUSH
72035: LD_VAR 0 2
72039: PPUSH
72040: LD_EXP 36
72044: PUSH
72045: LD_VAR 0 2
72049: ARRAY
72050: PPUSH
72051: LD_VAR 0 3
72055: PPUSH
72056: LD_INT 1
72058: PPUSH
72059: LD_INT 0
72061: PPUSH
72062: CALL 24439 0 4
72066: PPUSH
72067: CALL_OW 1
72071: ST_TO_ADDR
// break ;
72072: GO 72076
// end ;
72074: GO 71996
72076: POP
72077: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
72078: LD_EXP 36
72082: PUSH
72083: LD_VAR 0 2
72087: ARRAY
72088: PUSH
72089: LD_INT 1
72091: ARRAY
72092: PUSH
72093: LD_INT 1
72095: ARRAY
72096: PUSH
72097: LD_INT 0
72099: EQUAL
72100: PUSH
72101: LD_VAR 0 5
72105: PUSH
72106: LD_VAR 0 5
72110: PPUSH
72111: LD_EXP 36
72115: PUSH
72116: LD_VAR 0 2
72120: ARRAY
72121: PUSH
72122: LD_INT 1
72124: ARRAY
72125: PUSH
72126: LD_INT 1
72128: ARRAY
72129: PPUSH
72130: LD_EXP 36
72134: PUSH
72135: LD_VAR 0 2
72139: ARRAY
72140: PUSH
72141: LD_INT 1
72143: ARRAY
72144: PUSH
72145: LD_INT 2
72147: ARRAY
72148: PPUSH
72149: LD_EXP 36
72153: PUSH
72154: LD_VAR 0 2
72158: ARRAY
72159: PUSH
72160: LD_INT 1
72162: ARRAY
72163: PUSH
72164: LD_INT 3
72166: ARRAY
72167: PPUSH
72168: LD_EXP 36
72172: PUSH
72173: LD_VAR 0 2
72177: ARRAY
72178: PUSH
72179: LD_INT 1
72181: ARRAY
72182: PUSH
72183: LD_INT 4
72185: ARRAY
72186: PPUSH
72187: CALL 33118 0 5
72191: AND
72192: OR
72193: IFFALSE 72474
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72195: LD_ADDR_VAR 0 4
72199: PUSH
72200: LD_EXP 31
72204: PUSH
72205: LD_VAR 0 2
72209: ARRAY
72210: PPUSH
72211: LD_INT 25
72213: PUSH
72214: LD_INT 2
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PPUSH
72221: CALL_OW 72
72225: PUSH
72226: LD_EXP 33
72230: PUSH
72231: LD_VAR 0 2
72235: ARRAY
72236: DIFF
72237: ST_TO_ADDR
// if not tmp then
72238: LD_VAR 0 4
72242: NOT
72243: IFFALSE 72247
// continue ;
72245: GO 71492
// for j in tmp do
72247: LD_ADDR_VAR 0 3
72251: PUSH
72252: LD_VAR 0 4
72256: PUSH
72257: FOR_IN
72258: IFFALSE 72470
// begin if not mc_builders [ i ] then
72260: LD_EXP 37
72264: PUSH
72265: LD_VAR 0 2
72269: ARRAY
72270: NOT
72271: IFFALSE 72329
// begin SetTag ( j , 103 ) ;
72273: LD_VAR 0 3
72277: PPUSH
72278: LD_INT 103
72280: PPUSH
72281: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72285: LD_ADDR_EXP 37
72289: PUSH
72290: LD_EXP 37
72294: PPUSH
72295: LD_VAR 0 2
72299: PUSH
72300: LD_EXP 37
72304: PUSH
72305: LD_VAR 0 2
72309: ARRAY
72310: PUSH
72311: LD_INT 1
72313: PLUS
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PPUSH
72319: LD_VAR 0 3
72323: PPUSH
72324: CALL 25021 0 3
72328: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72329: LD_VAR 0 3
72333: PPUSH
72334: CALL_OW 310
72338: IFFALSE 72349
// ComExitBuilding ( j ) ;
72340: LD_VAR 0 3
72344: PPUSH
72345: CALL_OW 122
// wait ( 3 ) ;
72349: LD_INT 3
72351: PPUSH
72352: CALL_OW 67
// if not mc_build_list [ i ] then
72356: LD_EXP 36
72360: PUSH
72361: LD_VAR 0 2
72365: ARRAY
72366: NOT
72367: IFFALSE 72371
// break ;
72369: GO 72470
// if not HasTask ( j ) then
72371: LD_VAR 0 3
72375: PPUSH
72376: CALL_OW 314
72380: NOT
72381: IFFALSE 72468
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72383: LD_VAR 0 3
72387: PPUSH
72388: LD_EXP 36
72392: PUSH
72393: LD_VAR 0 2
72397: ARRAY
72398: PUSH
72399: LD_INT 1
72401: ARRAY
72402: PUSH
72403: LD_INT 1
72405: ARRAY
72406: PPUSH
72407: LD_EXP 36
72411: PUSH
72412: LD_VAR 0 2
72416: ARRAY
72417: PUSH
72418: LD_INT 1
72420: ARRAY
72421: PUSH
72422: LD_INT 2
72424: ARRAY
72425: PPUSH
72426: LD_EXP 36
72430: PUSH
72431: LD_VAR 0 2
72435: ARRAY
72436: PUSH
72437: LD_INT 1
72439: ARRAY
72440: PUSH
72441: LD_INT 3
72443: ARRAY
72444: PPUSH
72445: LD_EXP 36
72449: PUSH
72450: LD_VAR 0 2
72454: ARRAY
72455: PUSH
72456: LD_INT 1
72458: ARRAY
72459: PUSH
72460: LD_INT 4
72462: ARRAY
72463: PPUSH
72464: CALL_OW 145
// end ;
72468: GO 72257
72470: POP
72471: POP
// end else
72472: GO 72644
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72474: LD_EXP 31
72478: PUSH
72479: LD_VAR 0 2
72483: ARRAY
72484: PPUSH
72485: LD_EXP 36
72489: PUSH
72490: LD_VAR 0 2
72494: ARRAY
72495: PUSH
72496: LD_INT 1
72498: ARRAY
72499: PUSH
72500: LD_INT 1
72502: ARRAY
72503: PPUSH
72504: LD_EXP 36
72508: PUSH
72509: LD_VAR 0 2
72513: ARRAY
72514: PUSH
72515: LD_INT 1
72517: ARRAY
72518: PUSH
72519: LD_INT 2
72521: ARRAY
72522: PPUSH
72523: LD_EXP 36
72527: PUSH
72528: LD_VAR 0 2
72532: ARRAY
72533: PUSH
72534: LD_INT 1
72536: ARRAY
72537: PUSH
72538: LD_INT 3
72540: ARRAY
72541: PPUSH
72542: LD_EXP 36
72546: PUSH
72547: LD_VAR 0 2
72551: ARRAY
72552: PUSH
72553: LD_INT 1
72555: ARRAY
72556: PUSH
72557: LD_INT 4
72559: ARRAY
72560: PPUSH
72561: LD_EXP 31
72565: PUSH
72566: LD_VAR 0 2
72570: ARRAY
72571: PPUSH
72572: LD_INT 21
72574: PUSH
72575: LD_INT 3
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PPUSH
72582: CALL_OW 72
72586: PPUSH
72587: EMPTY
72588: PPUSH
72589: CALL 31872 0 7
72593: NOT
72594: IFFALSE 72644
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72596: LD_ADDR_EXP 36
72600: PUSH
72601: LD_EXP 36
72605: PPUSH
72606: LD_VAR 0 2
72610: PPUSH
72611: LD_EXP 36
72615: PUSH
72616: LD_VAR 0 2
72620: ARRAY
72621: PPUSH
72622: LD_INT 1
72624: PPUSH
72625: LD_INT 1
72627: NEG
72628: PPUSH
72629: LD_INT 0
72631: PPUSH
72632: CALL 24439 0 4
72636: PPUSH
72637: CALL_OW 1
72641: ST_TO_ADDR
// continue ;
72642: GO 71492
// end ; end ; end ;
72644: GO 71492
72646: POP
72647: POP
// end ;
72648: LD_VAR 0 1
72652: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72653: LD_INT 0
72655: PPUSH
72656: PPUSH
72657: PPUSH
72658: PPUSH
72659: PPUSH
72660: PPUSH
// if not mc_bases then
72661: LD_EXP 31
72665: NOT
72666: IFFALSE 72670
// exit ;
72668: GO 73097
// for i = 1 to mc_bases do
72670: LD_ADDR_VAR 0 2
72674: PUSH
72675: DOUBLE
72676: LD_INT 1
72678: DEC
72679: ST_TO_ADDR
72680: LD_EXP 31
72684: PUSH
72685: FOR_TO
72686: IFFALSE 73095
// begin tmp := mc_build_upgrade [ i ] ;
72688: LD_ADDR_VAR 0 4
72692: PUSH
72693: LD_EXP 63
72697: PUSH
72698: LD_VAR 0 2
72702: ARRAY
72703: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72704: LD_ADDR_VAR 0 6
72708: PUSH
72709: LD_EXP 64
72713: PUSH
72714: LD_VAR 0 2
72718: ARRAY
72719: PPUSH
72720: LD_INT 2
72722: PUSH
72723: LD_INT 30
72725: PUSH
72726: LD_INT 6
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 30
72735: PUSH
72736: LD_INT 7
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: LIST
72747: PPUSH
72748: CALL_OW 72
72752: ST_TO_ADDR
// if not tmp and not lab then
72753: LD_VAR 0 4
72757: NOT
72758: PUSH
72759: LD_VAR 0 6
72763: NOT
72764: AND
72765: IFFALSE 72769
// continue ;
72767: GO 72685
// if tmp then
72769: LD_VAR 0 4
72773: IFFALSE 72893
// for j in tmp do
72775: LD_ADDR_VAR 0 3
72779: PUSH
72780: LD_VAR 0 4
72784: PUSH
72785: FOR_IN
72786: IFFALSE 72891
// begin if UpgradeCost ( j ) then
72788: LD_VAR 0 3
72792: PPUSH
72793: CALL 31532 0 1
72797: IFFALSE 72889
// begin ComUpgrade ( j ) ;
72799: LD_VAR 0 3
72803: PPUSH
72804: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
72808: LD_ADDR_EXP 63
72812: PUSH
72813: LD_EXP 63
72817: PPUSH
72818: LD_VAR 0 2
72822: PPUSH
72823: LD_EXP 63
72827: PUSH
72828: LD_VAR 0 2
72832: ARRAY
72833: PUSH
72834: LD_VAR 0 3
72838: DIFF
72839: PPUSH
72840: CALL_OW 1
72844: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72845: LD_ADDR_EXP 38
72849: PUSH
72850: LD_EXP 38
72854: PPUSH
72855: LD_VAR 0 2
72859: PUSH
72860: LD_EXP 38
72864: PUSH
72865: LD_VAR 0 2
72869: ARRAY
72870: PUSH
72871: LD_INT 1
72873: PLUS
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PPUSH
72879: LD_VAR 0 3
72883: PPUSH
72884: CALL 25021 0 3
72888: ST_TO_ADDR
// end ; end ;
72889: GO 72785
72891: POP
72892: POP
// if not lab or not mc_lab_upgrade [ i ] then
72893: LD_VAR 0 6
72897: NOT
72898: PUSH
72899: LD_EXP 65
72903: PUSH
72904: LD_VAR 0 2
72908: ARRAY
72909: NOT
72910: OR
72911: IFFALSE 72915
// continue ;
72913: GO 72685
// for j in lab do
72915: LD_ADDR_VAR 0 3
72919: PUSH
72920: LD_VAR 0 6
72924: PUSH
72925: FOR_IN
72926: IFFALSE 73091
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
72928: LD_VAR 0 3
72932: PPUSH
72933: CALL_OW 266
72937: PUSH
72938: LD_INT 6
72940: PUSH
72941: LD_INT 7
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: IN
72948: PUSH
72949: LD_VAR 0 3
72953: PPUSH
72954: CALL_OW 461
72958: PUSH
72959: LD_INT 1
72961: NONEQUAL
72962: AND
72963: IFFALSE 73089
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72965: LD_VAR 0 3
72969: PPUSH
72970: LD_EXP 65
72974: PUSH
72975: LD_VAR 0 2
72979: ARRAY
72980: PUSH
72981: LD_INT 1
72983: ARRAY
72984: PPUSH
72985: CALL 31737 0 2
72989: IFFALSE 73089
// begin ComCancel ( j ) ;
72991: LD_VAR 0 3
72995: PPUSH
72996: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73000: LD_VAR 0 3
73004: PPUSH
73005: LD_EXP 65
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: PUSH
73016: LD_INT 1
73018: ARRAY
73019: PPUSH
73020: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73024: LD_VAR 0 3
73028: PUSH
73029: LD_EXP 38
73033: PUSH
73034: LD_VAR 0 2
73038: ARRAY
73039: IN
73040: NOT
73041: IFFALSE 73087
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73043: LD_ADDR_EXP 38
73047: PUSH
73048: LD_EXP 38
73052: PPUSH
73053: LD_VAR 0 2
73057: PUSH
73058: LD_EXP 38
73062: PUSH
73063: LD_VAR 0 2
73067: ARRAY
73068: PUSH
73069: LD_INT 1
73071: PLUS
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PPUSH
73077: LD_VAR 0 3
73081: PPUSH
73082: CALL 25021 0 3
73086: ST_TO_ADDR
// break ;
73087: GO 73091
// end ; end ; end ;
73089: GO 72925
73091: POP
73092: POP
// end ;
73093: GO 72685
73095: POP
73096: POP
// end ;
73097: LD_VAR 0 1
73101: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73102: LD_INT 0
73104: PPUSH
73105: PPUSH
73106: PPUSH
73107: PPUSH
73108: PPUSH
73109: PPUSH
73110: PPUSH
73111: PPUSH
73112: PPUSH
// if not mc_bases then
73113: LD_EXP 31
73117: NOT
73118: IFFALSE 73122
// exit ;
73120: GO 73527
// for i = 1 to mc_bases do
73122: LD_ADDR_VAR 0 2
73126: PUSH
73127: DOUBLE
73128: LD_INT 1
73130: DEC
73131: ST_TO_ADDR
73132: LD_EXP 31
73136: PUSH
73137: FOR_TO
73138: IFFALSE 73525
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73140: LD_EXP 39
73144: PUSH
73145: LD_VAR 0 2
73149: ARRAY
73150: NOT
73151: PUSH
73152: LD_EXP 31
73156: PUSH
73157: LD_VAR 0 2
73161: ARRAY
73162: PPUSH
73163: LD_INT 30
73165: PUSH
73166: LD_INT 3
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PPUSH
73173: CALL_OW 72
73177: NOT
73178: OR
73179: IFFALSE 73183
// continue ;
73181: GO 73137
// busy := false ;
73183: LD_ADDR_VAR 0 8
73187: PUSH
73188: LD_INT 0
73190: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73191: LD_ADDR_VAR 0 4
73195: PUSH
73196: LD_EXP 31
73200: PUSH
73201: LD_VAR 0 2
73205: ARRAY
73206: PPUSH
73207: LD_INT 30
73209: PUSH
73210: LD_INT 3
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: PPUSH
73217: CALL_OW 72
73221: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73222: LD_ADDR_VAR 0 6
73226: PUSH
73227: LD_EXP 39
73231: PUSH
73232: LD_VAR 0 2
73236: ARRAY
73237: PPUSH
73238: LD_INT 2
73240: PUSH
73241: LD_INT 30
73243: PUSH
73244: LD_INT 32
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 30
73253: PUSH
73254: LD_INT 33
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: LIST
73265: PPUSH
73266: CALL_OW 72
73270: ST_TO_ADDR
// if not t then
73271: LD_VAR 0 6
73275: NOT
73276: IFFALSE 73280
// continue ;
73278: GO 73137
// for j in tmp do
73280: LD_ADDR_VAR 0 3
73284: PUSH
73285: LD_VAR 0 4
73289: PUSH
73290: FOR_IN
73291: IFFALSE 73321
// if not BuildingStatus ( j ) = bs_idle then
73293: LD_VAR 0 3
73297: PPUSH
73298: CALL_OW 461
73302: PUSH
73303: LD_INT 2
73305: EQUAL
73306: NOT
73307: IFFALSE 73319
// begin busy := true ;
73309: LD_ADDR_VAR 0 8
73313: PUSH
73314: LD_INT 1
73316: ST_TO_ADDR
// break ;
73317: GO 73321
// end ;
73319: GO 73290
73321: POP
73322: POP
// if busy then
73323: LD_VAR 0 8
73327: IFFALSE 73331
// continue ;
73329: GO 73137
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73331: LD_ADDR_VAR 0 7
73335: PUSH
73336: LD_VAR 0 6
73340: PPUSH
73341: LD_INT 35
73343: PUSH
73344: LD_INT 0
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PPUSH
73351: CALL_OW 72
73355: ST_TO_ADDR
// if tw then
73356: LD_VAR 0 7
73360: IFFALSE 73437
// begin tw := tw [ 1 ] ;
73362: LD_ADDR_VAR 0 7
73366: PUSH
73367: LD_VAR 0 7
73371: PUSH
73372: LD_INT 1
73374: ARRAY
73375: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73376: LD_ADDR_VAR 0 9
73380: PUSH
73381: LD_VAR 0 7
73385: PPUSH
73386: LD_EXP 56
73390: PUSH
73391: LD_VAR 0 2
73395: ARRAY
73396: PPUSH
73397: CALL 30029 0 2
73401: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73402: LD_EXP 70
73406: PUSH
73407: LD_VAR 0 2
73411: ARRAY
73412: IFFALSE 73435
// if not weapon in mc_allowed_tower_weapons [ i ] then
73414: LD_VAR 0 9
73418: PUSH
73419: LD_EXP 70
73423: PUSH
73424: LD_VAR 0 2
73428: ARRAY
73429: IN
73430: NOT
73431: IFFALSE 73435
// continue ;
73433: GO 73137
// end else
73435: GO 73500
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73437: LD_ADDR_VAR 0 5
73441: PUSH
73442: LD_EXP 39
73446: PUSH
73447: LD_VAR 0 2
73451: ARRAY
73452: PPUSH
73453: LD_VAR 0 4
73457: PPUSH
73458: CALL 56808 0 2
73462: ST_TO_ADDR
// if not tmp2 then
73463: LD_VAR 0 5
73467: NOT
73468: IFFALSE 73472
// continue ;
73470: GO 73137
// tw := tmp2 [ 1 ] ;
73472: LD_ADDR_VAR 0 7
73476: PUSH
73477: LD_VAR 0 5
73481: PUSH
73482: LD_INT 1
73484: ARRAY
73485: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73486: LD_ADDR_VAR 0 9
73490: PUSH
73491: LD_VAR 0 5
73495: PUSH
73496: LD_INT 2
73498: ARRAY
73499: ST_TO_ADDR
// end ; if not weapon then
73500: LD_VAR 0 9
73504: NOT
73505: IFFALSE 73509
// continue ;
73507: GO 73137
// ComPlaceWeapon ( tw , weapon ) ;
73509: LD_VAR 0 7
73513: PPUSH
73514: LD_VAR 0 9
73518: PPUSH
73519: CALL_OW 148
// end ;
73523: GO 73137
73525: POP
73526: POP
// end ;
73527: LD_VAR 0 1
73531: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73532: LD_INT 0
73534: PPUSH
73535: PPUSH
73536: PPUSH
73537: PPUSH
73538: PPUSH
73539: PPUSH
73540: PPUSH
// if not mc_bases then
73541: LD_EXP 31
73545: NOT
73546: IFFALSE 73550
// exit ;
73548: GO 74318
// for i = 1 to mc_bases do
73550: LD_ADDR_VAR 0 2
73554: PUSH
73555: DOUBLE
73556: LD_INT 1
73558: DEC
73559: ST_TO_ADDR
73560: LD_EXP 31
73564: PUSH
73565: FOR_TO
73566: IFFALSE 74316
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73568: LD_EXP 44
73572: PUSH
73573: LD_VAR 0 2
73577: ARRAY
73578: NOT
73579: PUSH
73580: LD_EXP 44
73584: PUSH
73585: LD_VAR 0 2
73589: ARRAY
73590: PUSH
73591: LD_EXP 45
73595: PUSH
73596: LD_VAR 0 2
73600: ARRAY
73601: EQUAL
73602: OR
73603: PUSH
73604: LD_EXP 54
73608: PUSH
73609: LD_VAR 0 2
73613: ARRAY
73614: OR
73615: IFFALSE 73619
// continue ;
73617: GO 73565
// if mc_miners [ i ] then
73619: LD_EXP 45
73623: PUSH
73624: LD_VAR 0 2
73628: ARRAY
73629: IFFALSE 74003
// begin for j = mc_miners [ i ] downto 1 do
73631: LD_ADDR_VAR 0 3
73635: PUSH
73636: DOUBLE
73637: LD_EXP 45
73641: PUSH
73642: LD_VAR 0 2
73646: ARRAY
73647: INC
73648: ST_TO_ADDR
73649: LD_INT 1
73651: PUSH
73652: FOR_DOWNTO
73653: IFFALSE 74001
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73655: LD_EXP 45
73659: PUSH
73660: LD_VAR 0 2
73664: ARRAY
73665: PUSH
73666: LD_VAR 0 3
73670: ARRAY
73671: PPUSH
73672: CALL_OW 301
73676: PUSH
73677: LD_EXP 45
73681: PUSH
73682: LD_VAR 0 2
73686: ARRAY
73687: PUSH
73688: LD_VAR 0 3
73692: ARRAY
73693: PPUSH
73694: CALL_OW 257
73698: PUSH
73699: LD_INT 1
73701: NONEQUAL
73702: OR
73703: IFFALSE 73766
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73705: LD_ADDR_VAR 0 5
73709: PUSH
73710: LD_EXP 45
73714: PUSH
73715: LD_VAR 0 2
73719: ARRAY
73720: PUSH
73721: LD_EXP 45
73725: PUSH
73726: LD_VAR 0 2
73730: ARRAY
73731: PUSH
73732: LD_VAR 0 3
73736: ARRAY
73737: DIFF
73738: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73739: LD_ADDR_EXP 45
73743: PUSH
73744: LD_EXP 45
73748: PPUSH
73749: LD_VAR 0 2
73753: PPUSH
73754: LD_VAR 0 5
73758: PPUSH
73759: CALL_OW 1
73763: ST_TO_ADDR
// continue ;
73764: GO 73652
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73766: LD_EXP 45
73770: PUSH
73771: LD_VAR 0 2
73775: ARRAY
73776: PUSH
73777: LD_VAR 0 3
73781: ARRAY
73782: PPUSH
73783: CALL_OW 257
73787: PUSH
73788: LD_INT 1
73790: EQUAL
73791: PUSH
73792: LD_EXP 45
73796: PUSH
73797: LD_VAR 0 2
73801: ARRAY
73802: PUSH
73803: LD_VAR 0 3
73807: ARRAY
73808: PPUSH
73809: CALL_OW 459
73813: NOT
73814: AND
73815: PUSH
73816: LD_EXP 45
73820: PUSH
73821: LD_VAR 0 2
73825: ARRAY
73826: PUSH
73827: LD_VAR 0 3
73831: ARRAY
73832: PPUSH
73833: CALL_OW 314
73837: NOT
73838: AND
73839: IFFALSE 73999
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
73841: LD_EXP 45
73845: PUSH
73846: LD_VAR 0 2
73850: ARRAY
73851: PUSH
73852: LD_VAR 0 3
73856: ARRAY
73857: PPUSH
73858: CALL_OW 310
73862: IFFALSE 73885
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
73864: LD_EXP 45
73868: PUSH
73869: LD_VAR 0 2
73873: ARRAY
73874: PUSH
73875: LD_VAR 0 3
73879: ARRAY
73880: PPUSH
73881: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
73885: LD_EXP 45
73889: PUSH
73890: LD_VAR 0 2
73894: ARRAY
73895: PUSH
73896: LD_VAR 0 3
73900: ARRAY
73901: PPUSH
73902: CALL_OW 314
73906: NOT
73907: IFFALSE 73999
// begin r := rand ( 1 , mc_mines [ i ] ) ;
73909: LD_ADDR_VAR 0 7
73913: PUSH
73914: LD_INT 1
73916: PPUSH
73917: LD_EXP 44
73921: PUSH
73922: LD_VAR 0 2
73926: ARRAY
73927: PPUSH
73928: CALL_OW 12
73932: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
73933: LD_EXP 45
73937: PUSH
73938: LD_VAR 0 2
73942: ARRAY
73943: PUSH
73944: LD_VAR 0 3
73948: ARRAY
73949: PPUSH
73950: LD_EXP 44
73954: PUSH
73955: LD_VAR 0 2
73959: ARRAY
73960: PUSH
73961: LD_VAR 0 7
73965: ARRAY
73966: PUSH
73967: LD_INT 1
73969: ARRAY
73970: PPUSH
73971: LD_EXP 44
73975: PUSH
73976: LD_VAR 0 2
73980: ARRAY
73981: PUSH
73982: LD_VAR 0 7
73986: ARRAY
73987: PUSH
73988: LD_INT 2
73990: ARRAY
73991: PPUSH
73992: LD_INT 0
73994: PPUSH
73995: CALL_OW 193
// end ; end ; end ;
73999: GO 73652
74001: POP
74002: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74003: LD_ADDR_VAR 0 5
74007: PUSH
74008: LD_EXP 31
74012: PUSH
74013: LD_VAR 0 2
74017: ARRAY
74018: PPUSH
74019: LD_INT 2
74021: PUSH
74022: LD_INT 30
74024: PUSH
74025: LD_INT 4
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 30
74034: PUSH
74035: LD_INT 5
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 30
74044: PUSH
74045: LD_INT 32
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: PPUSH
74058: CALL_OW 72
74062: ST_TO_ADDR
// if not tmp then
74063: LD_VAR 0 5
74067: NOT
74068: IFFALSE 74072
// continue ;
74070: GO 73565
// list := [ ] ;
74072: LD_ADDR_VAR 0 6
74076: PUSH
74077: EMPTY
74078: ST_TO_ADDR
// for j in tmp do
74079: LD_ADDR_VAR 0 3
74083: PUSH
74084: LD_VAR 0 5
74088: PUSH
74089: FOR_IN
74090: IFFALSE 74159
// begin for k in UnitsInside ( j ) do
74092: LD_ADDR_VAR 0 4
74096: PUSH
74097: LD_VAR 0 3
74101: PPUSH
74102: CALL_OW 313
74106: PUSH
74107: FOR_IN
74108: IFFALSE 74155
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74110: LD_VAR 0 4
74114: PPUSH
74115: CALL_OW 257
74119: PUSH
74120: LD_INT 1
74122: EQUAL
74123: PUSH
74124: LD_VAR 0 4
74128: PPUSH
74129: CALL_OW 459
74133: NOT
74134: AND
74135: IFFALSE 74153
// list := list ^ k ;
74137: LD_ADDR_VAR 0 6
74141: PUSH
74142: LD_VAR 0 6
74146: PUSH
74147: LD_VAR 0 4
74151: ADD
74152: ST_TO_ADDR
74153: GO 74107
74155: POP
74156: POP
// end ;
74157: GO 74089
74159: POP
74160: POP
// list := list diff mc_miners [ i ] ;
74161: LD_ADDR_VAR 0 6
74165: PUSH
74166: LD_VAR 0 6
74170: PUSH
74171: LD_EXP 45
74175: PUSH
74176: LD_VAR 0 2
74180: ARRAY
74181: DIFF
74182: ST_TO_ADDR
// if not list then
74183: LD_VAR 0 6
74187: NOT
74188: IFFALSE 74192
// continue ;
74190: GO 73565
// k := mc_mines [ i ] - mc_miners [ i ] ;
74192: LD_ADDR_VAR 0 4
74196: PUSH
74197: LD_EXP 44
74201: PUSH
74202: LD_VAR 0 2
74206: ARRAY
74207: PUSH
74208: LD_EXP 45
74212: PUSH
74213: LD_VAR 0 2
74217: ARRAY
74218: MINUS
74219: ST_TO_ADDR
// if k > list then
74220: LD_VAR 0 4
74224: PUSH
74225: LD_VAR 0 6
74229: GREATER
74230: IFFALSE 74242
// k := list ;
74232: LD_ADDR_VAR 0 4
74236: PUSH
74237: LD_VAR 0 6
74241: ST_TO_ADDR
// for j = 1 to k do
74242: LD_ADDR_VAR 0 3
74246: PUSH
74247: DOUBLE
74248: LD_INT 1
74250: DEC
74251: ST_TO_ADDR
74252: LD_VAR 0 4
74256: PUSH
74257: FOR_TO
74258: IFFALSE 74312
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74260: LD_ADDR_EXP 45
74264: PUSH
74265: LD_EXP 45
74269: PPUSH
74270: LD_VAR 0 2
74274: PUSH
74275: LD_EXP 45
74279: PUSH
74280: LD_VAR 0 2
74284: ARRAY
74285: PUSH
74286: LD_INT 1
74288: PLUS
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PPUSH
74294: LD_VAR 0 6
74298: PUSH
74299: LD_VAR 0 3
74303: ARRAY
74304: PPUSH
74305: CALL 25021 0 3
74309: ST_TO_ADDR
74310: GO 74257
74312: POP
74313: POP
// end ;
74314: GO 73565
74316: POP
74317: POP
// end ;
74318: LD_VAR 0 1
74322: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74323: LD_INT 0
74325: PPUSH
74326: PPUSH
74327: PPUSH
74328: PPUSH
74329: PPUSH
74330: PPUSH
74331: PPUSH
74332: PPUSH
74333: PPUSH
74334: PPUSH
74335: PPUSH
// if not mc_bases then
74336: LD_EXP 31
74340: NOT
74341: IFFALSE 74345
// exit ;
74343: GO 76168
// for i = 1 to mc_bases do
74345: LD_ADDR_VAR 0 2
74349: PUSH
74350: DOUBLE
74351: LD_INT 1
74353: DEC
74354: ST_TO_ADDR
74355: LD_EXP 31
74359: PUSH
74360: FOR_TO
74361: IFFALSE 76166
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74363: LD_EXP 31
74367: PUSH
74368: LD_VAR 0 2
74372: ARRAY
74373: NOT
74374: PUSH
74375: LD_EXP 38
74379: PUSH
74380: LD_VAR 0 2
74384: ARRAY
74385: OR
74386: IFFALSE 74390
// continue ;
74388: GO 74360
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74390: LD_EXP 47
74394: PUSH
74395: LD_VAR 0 2
74399: ARRAY
74400: NOT
74401: PUSH
74402: LD_EXP 48
74406: PUSH
74407: LD_VAR 0 2
74411: ARRAY
74412: AND
74413: IFFALSE 74451
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74415: LD_ADDR_EXP 48
74419: PUSH
74420: LD_EXP 48
74424: PPUSH
74425: LD_VAR 0 2
74429: PPUSH
74430: EMPTY
74431: PPUSH
74432: CALL_OW 1
74436: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74437: LD_VAR 0 2
74441: PPUSH
74442: LD_INT 107
74444: PPUSH
74445: CALL 65223 0 2
// continue ;
74449: GO 74360
// end ; target := [ ] ;
74451: LD_ADDR_VAR 0 7
74455: PUSH
74456: EMPTY
74457: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74458: LD_ADDR_VAR 0 6
74462: PUSH
74463: LD_EXP 31
74467: PUSH
74468: LD_VAR 0 2
74472: ARRAY
74473: PUSH
74474: LD_INT 1
74476: ARRAY
74477: PPUSH
74478: CALL_OW 255
74482: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74483: LD_ADDR_VAR 0 9
74487: PUSH
74488: LD_EXP 31
74492: PUSH
74493: LD_VAR 0 2
74497: ARRAY
74498: PPUSH
74499: LD_INT 2
74501: PUSH
74502: LD_INT 30
74504: PUSH
74505: LD_INT 0
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 30
74514: PUSH
74515: LD_INT 1
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: LIST
74526: PPUSH
74527: CALL_OW 72
74531: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74532: LD_ADDR_VAR 0 3
74536: PUSH
74537: DOUBLE
74538: LD_EXP 47
74542: PUSH
74543: LD_VAR 0 2
74547: ARRAY
74548: INC
74549: ST_TO_ADDR
74550: LD_INT 1
74552: PUSH
74553: FOR_DOWNTO
74554: IFFALSE 74799
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74556: LD_EXP 47
74560: PUSH
74561: LD_VAR 0 2
74565: ARRAY
74566: PUSH
74567: LD_VAR 0 3
74571: ARRAY
74572: PUSH
74573: LD_INT 2
74575: ARRAY
74576: PPUSH
74577: LD_EXP 47
74581: PUSH
74582: LD_VAR 0 2
74586: ARRAY
74587: PUSH
74588: LD_VAR 0 3
74592: ARRAY
74593: PUSH
74594: LD_INT 3
74596: ARRAY
74597: PPUSH
74598: CALL_OW 488
74602: PUSH
74603: LD_EXP 47
74607: PUSH
74608: LD_VAR 0 2
74612: ARRAY
74613: PUSH
74614: LD_VAR 0 3
74618: ARRAY
74619: PUSH
74620: LD_INT 2
74622: ARRAY
74623: PPUSH
74624: LD_EXP 47
74628: PUSH
74629: LD_VAR 0 2
74633: ARRAY
74634: PUSH
74635: LD_VAR 0 3
74639: ARRAY
74640: PUSH
74641: LD_INT 3
74643: ARRAY
74644: PPUSH
74645: CALL_OW 284
74649: PUSH
74650: LD_INT 0
74652: EQUAL
74653: AND
74654: IFFALSE 74709
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74656: LD_ADDR_VAR 0 5
74660: PUSH
74661: LD_EXP 47
74665: PUSH
74666: LD_VAR 0 2
74670: ARRAY
74671: PPUSH
74672: LD_VAR 0 3
74676: PPUSH
74677: CALL_OW 3
74681: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74682: LD_ADDR_EXP 47
74686: PUSH
74687: LD_EXP 47
74691: PPUSH
74692: LD_VAR 0 2
74696: PPUSH
74697: LD_VAR 0 5
74701: PPUSH
74702: CALL_OW 1
74706: ST_TO_ADDR
// continue ;
74707: GO 74553
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74709: LD_VAR 0 6
74713: PPUSH
74714: LD_EXP 47
74718: PUSH
74719: LD_VAR 0 2
74723: ARRAY
74724: PUSH
74725: LD_VAR 0 3
74729: ARRAY
74730: PUSH
74731: LD_INT 2
74733: ARRAY
74734: PPUSH
74735: LD_EXP 47
74739: PUSH
74740: LD_VAR 0 2
74744: ARRAY
74745: PUSH
74746: LD_VAR 0 3
74750: ARRAY
74751: PUSH
74752: LD_INT 3
74754: ARRAY
74755: PPUSH
74756: LD_INT 30
74758: PPUSH
74759: CALL 25917 0 4
74763: PUSH
74764: LD_INT 4
74766: ARRAY
74767: PUSH
74768: LD_INT 0
74770: EQUAL
74771: IFFALSE 74797
// begin target := mc_crates [ i ] [ j ] ;
74773: LD_ADDR_VAR 0 7
74777: PUSH
74778: LD_EXP 47
74782: PUSH
74783: LD_VAR 0 2
74787: ARRAY
74788: PUSH
74789: LD_VAR 0 3
74793: ARRAY
74794: ST_TO_ADDR
// break ;
74795: GO 74799
// end ; end ;
74797: GO 74553
74799: POP
74800: POP
// if not target then
74801: LD_VAR 0 7
74805: NOT
74806: IFFALSE 74810
// continue ;
74808: GO 74360
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
74810: LD_ADDR_VAR 0 8
74814: PUSH
74815: LD_EXP 50
74819: PUSH
74820: LD_VAR 0 2
74824: ARRAY
74825: PPUSH
74826: LD_INT 2
74828: PUSH
74829: LD_INT 3
74831: PUSH
74832: LD_INT 58
74834: PUSH
74835: EMPTY
74836: LIST
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 61
74844: PUSH
74845: EMPTY
74846: LIST
74847: PUSH
74848: LD_INT 33
74850: PUSH
74851: LD_INT 5
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PUSH
74858: LD_INT 33
74860: PUSH
74861: LD_INT 3
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 2
74877: PUSH
74878: LD_INT 34
74880: PUSH
74881: LD_INT 32
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 34
74890: PUSH
74891: LD_INT 51
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 34
74900: PUSH
74901: LD_INT 12
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: LIST
74912: LIST
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PPUSH
74918: CALL_OW 72
74922: ST_TO_ADDR
// if not cargo then
74923: LD_VAR 0 8
74927: NOT
74928: IFFALSE 75634
// begin if mc_crates_collector [ i ] < 5 then
74930: LD_EXP 48
74934: PUSH
74935: LD_VAR 0 2
74939: ARRAY
74940: PUSH
74941: LD_INT 5
74943: LESS
74944: IFFALSE 75310
// begin if mc_ape [ i ] then
74946: LD_EXP 60
74950: PUSH
74951: LD_VAR 0 2
74955: ARRAY
74956: IFFALSE 75003
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74958: LD_ADDR_VAR 0 5
74962: PUSH
74963: LD_EXP 60
74967: PUSH
74968: LD_VAR 0 2
74972: ARRAY
74973: PPUSH
74974: LD_INT 25
74976: PUSH
74977: LD_INT 16
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 24
74986: PUSH
74987: LD_INT 750
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PPUSH
74998: CALL_OW 72
75002: ST_TO_ADDR
// if not tmp then
75003: LD_VAR 0 5
75007: NOT
75008: IFFALSE 75055
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75010: LD_ADDR_VAR 0 5
75014: PUSH
75015: LD_EXP 31
75019: PUSH
75020: LD_VAR 0 2
75024: ARRAY
75025: PPUSH
75026: LD_INT 25
75028: PUSH
75029: LD_INT 2
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 24
75038: PUSH
75039: LD_INT 750
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PPUSH
75050: CALL_OW 72
75054: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75055: LD_EXP 60
75059: PUSH
75060: LD_VAR 0 2
75064: ARRAY
75065: PUSH
75066: LD_EXP 31
75070: PUSH
75071: LD_VAR 0 2
75075: ARRAY
75076: PPUSH
75077: LD_INT 25
75079: PUSH
75080: LD_INT 2
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 24
75089: PUSH
75090: LD_INT 750
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PPUSH
75101: CALL_OW 72
75105: AND
75106: PUSH
75107: LD_VAR 0 5
75111: PUSH
75112: LD_INT 5
75114: LESS
75115: AND
75116: IFFALSE 75198
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75118: LD_ADDR_VAR 0 3
75122: PUSH
75123: LD_EXP 31
75127: PUSH
75128: LD_VAR 0 2
75132: ARRAY
75133: PPUSH
75134: LD_INT 25
75136: PUSH
75137: LD_INT 2
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 24
75146: PUSH
75147: LD_INT 750
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PPUSH
75158: CALL_OW 72
75162: PUSH
75163: FOR_IN
75164: IFFALSE 75196
// begin tmp := tmp union j ;
75166: LD_ADDR_VAR 0 5
75170: PUSH
75171: LD_VAR 0 5
75175: PUSH
75176: LD_VAR 0 3
75180: UNION
75181: ST_TO_ADDR
// if tmp >= 5 then
75182: LD_VAR 0 5
75186: PUSH
75187: LD_INT 5
75189: GREATEREQUAL
75190: IFFALSE 75194
// break ;
75192: GO 75196
// end ;
75194: GO 75163
75196: POP
75197: POP
// end ; if not tmp then
75198: LD_VAR 0 5
75202: NOT
75203: IFFALSE 75207
// continue ;
75205: GO 74360
// for j in tmp do
75207: LD_ADDR_VAR 0 3
75211: PUSH
75212: LD_VAR 0 5
75216: PUSH
75217: FOR_IN
75218: IFFALSE 75308
// if not GetTag ( j ) then
75220: LD_VAR 0 3
75224: PPUSH
75225: CALL_OW 110
75229: NOT
75230: IFFALSE 75306
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75232: LD_ADDR_EXP 48
75236: PUSH
75237: LD_EXP 48
75241: PPUSH
75242: LD_VAR 0 2
75246: PUSH
75247: LD_EXP 48
75251: PUSH
75252: LD_VAR 0 2
75256: ARRAY
75257: PUSH
75258: LD_INT 1
75260: PLUS
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PPUSH
75266: LD_VAR 0 3
75270: PPUSH
75271: CALL 25021 0 3
75275: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75276: LD_VAR 0 3
75280: PPUSH
75281: LD_INT 107
75283: PPUSH
75284: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75288: LD_EXP 48
75292: PUSH
75293: LD_VAR 0 2
75297: ARRAY
75298: PUSH
75299: LD_INT 5
75301: GREATEREQUAL
75302: IFFALSE 75306
// break ;
75304: GO 75308
// end ;
75306: GO 75217
75308: POP
75309: POP
// end ; if mc_crates_collector [ i ] and target then
75310: LD_EXP 48
75314: PUSH
75315: LD_VAR 0 2
75319: ARRAY
75320: PUSH
75321: LD_VAR 0 7
75325: AND
75326: IFFALSE 75632
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75328: LD_EXP 48
75332: PUSH
75333: LD_VAR 0 2
75337: ARRAY
75338: PUSH
75339: LD_VAR 0 7
75343: PUSH
75344: LD_INT 1
75346: ARRAY
75347: LESS
75348: IFFALSE 75368
// tmp := mc_crates_collector [ i ] else
75350: LD_ADDR_VAR 0 5
75354: PUSH
75355: LD_EXP 48
75359: PUSH
75360: LD_VAR 0 2
75364: ARRAY
75365: ST_TO_ADDR
75366: GO 75382
// tmp := target [ 1 ] ;
75368: LD_ADDR_VAR 0 5
75372: PUSH
75373: LD_VAR 0 7
75377: PUSH
75378: LD_INT 1
75380: ARRAY
75381: ST_TO_ADDR
// k := 0 ;
75382: LD_ADDR_VAR 0 4
75386: PUSH
75387: LD_INT 0
75389: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75390: LD_ADDR_VAR 0 3
75394: PUSH
75395: LD_EXP 48
75399: PUSH
75400: LD_VAR 0 2
75404: ARRAY
75405: PUSH
75406: FOR_IN
75407: IFFALSE 75630
// begin k := k + 1 ;
75409: LD_ADDR_VAR 0 4
75413: PUSH
75414: LD_VAR 0 4
75418: PUSH
75419: LD_INT 1
75421: PLUS
75422: ST_TO_ADDR
// if k > tmp then
75423: LD_VAR 0 4
75427: PUSH
75428: LD_VAR 0 5
75432: GREATER
75433: IFFALSE 75437
// break ;
75435: GO 75630
// if not GetClass ( j ) in [ 2 , 16 ] then
75437: LD_VAR 0 3
75441: PPUSH
75442: CALL_OW 257
75446: PUSH
75447: LD_INT 2
75449: PUSH
75450: LD_INT 16
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: IN
75457: NOT
75458: IFFALSE 75511
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75460: LD_ADDR_EXP 48
75464: PUSH
75465: LD_EXP 48
75469: PPUSH
75470: LD_VAR 0 2
75474: PPUSH
75475: LD_EXP 48
75479: PUSH
75480: LD_VAR 0 2
75484: ARRAY
75485: PUSH
75486: LD_VAR 0 3
75490: DIFF
75491: PPUSH
75492: CALL_OW 1
75496: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75497: LD_VAR 0 3
75501: PPUSH
75502: LD_INT 0
75504: PPUSH
75505: CALL_OW 109
// continue ;
75509: GO 75406
// end ; if IsInUnit ( j ) then
75511: LD_VAR 0 3
75515: PPUSH
75516: CALL_OW 310
75520: IFFALSE 75531
// ComExitBuilding ( j ) ;
75522: LD_VAR 0 3
75526: PPUSH
75527: CALL_OW 122
// wait ( 3 ) ;
75531: LD_INT 3
75533: PPUSH
75534: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75538: LD_VAR 0 3
75542: PPUSH
75543: CALL_OW 314
75547: PUSH
75548: LD_VAR 0 6
75552: PPUSH
75553: LD_VAR 0 7
75557: PUSH
75558: LD_INT 2
75560: ARRAY
75561: PPUSH
75562: LD_VAR 0 7
75566: PUSH
75567: LD_INT 3
75569: ARRAY
75570: PPUSH
75571: LD_INT 30
75573: PPUSH
75574: CALL 25917 0 4
75578: PUSH
75579: LD_INT 4
75581: ARRAY
75582: AND
75583: IFFALSE 75601
// ComStandNearbyBuilding ( j , depot ) else
75585: LD_VAR 0 3
75589: PPUSH
75590: LD_VAR 0 9
75594: PPUSH
75595: CALL 21448 0 2
75599: GO 75628
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75601: LD_VAR 0 3
75605: PPUSH
75606: LD_VAR 0 7
75610: PUSH
75611: LD_INT 2
75613: ARRAY
75614: PPUSH
75615: LD_VAR 0 7
75619: PUSH
75620: LD_INT 3
75622: ARRAY
75623: PPUSH
75624: CALL_OW 117
// end ;
75628: GO 75406
75630: POP
75631: POP
// end ; end else
75632: GO 76164
// begin for j in cargo do
75634: LD_ADDR_VAR 0 3
75638: PUSH
75639: LD_VAR 0 8
75643: PUSH
75644: FOR_IN
75645: IFFALSE 76162
// begin if GetTag ( j ) <> 0 then
75647: LD_VAR 0 3
75651: PPUSH
75652: CALL_OW 110
75656: PUSH
75657: LD_INT 0
75659: NONEQUAL
75660: IFFALSE 75664
// continue ;
75662: GO 75644
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75664: LD_VAR 0 3
75668: PPUSH
75669: CALL_OW 256
75673: PUSH
75674: LD_INT 1000
75676: LESS
75677: PUSH
75678: LD_VAR 0 3
75682: PPUSH
75683: LD_EXP 55
75687: PUSH
75688: LD_VAR 0 2
75692: ARRAY
75693: PPUSH
75694: CALL_OW 308
75698: NOT
75699: AND
75700: IFFALSE 75722
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75702: LD_VAR 0 3
75706: PPUSH
75707: LD_EXP 55
75711: PUSH
75712: LD_VAR 0 2
75716: ARRAY
75717: PPUSH
75718: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75722: LD_VAR 0 3
75726: PPUSH
75727: CALL_OW 256
75731: PUSH
75732: LD_INT 1000
75734: LESS
75735: PUSH
75736: LD_VAR 0 3
75740: PPUSH
75741: LD_EXP 55
75745: PUSH
75746: LD_VAR 0 2
75750: ARRAY
75751: PPUSH
75752: CALL_OW 308
75756: AND
75757: IFFALSE 75761
// continue ;
75759: GO 75644
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75761: LD_VAR 0 3
75765: PPUSH
75766: CALL_OW 262
75770: PUSH
75771: LD_INT 2
75773: EQUAL
75774: PUSH
75775: LD_VAR 0 3
75779: PPUSH
75780: CALL_OW 261
75784: PUSH
75785: LD_INT 15
75787: LESS
75788: AND
75789: IFFALSE 75793
// continue ;
75791: GO 75644
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
75793: LD_VAR 0 3
75797: PPUSH
75798: CALL_OW 262
75802: PUSH
75803: LD_INT 1
75805: EQUAL
75806: PUSH
75807: LD_VAR 0 3
75811: PPUSH
75812: CALL_OW 261
75816: PUSH
75817: LD_INT 10
75819: LESS
75820: AND
75821: IFFALSE 76101
// begin if not depot then
75823: LD_VAR 0 9
75827: NOT
75828: IFFALSE 75832
// continue ;
75830: GO 75644
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
75832: LD_VAR 0 3
75836: PPUSH
75837: LD_VAR 0 9
75841: PPUSH
75842: LD_VAR 0 3
75846: PPUSH
75847: CALL_OW 74
75851: PPUSH
75852: CALL_OW 296
75856: PUSH
75857: LD_INT 6
75859: LESS
75860: IFFALSE 75876
// SetFuel ( j , 100 ) else
75862: LD_VAR 0 3
75866: PPUSH
75867: LD_INT 100
75869: PPUSH
75870: CALL_OW 240
75874: GO 76101
// if GetFuel ( j ) = 0 then
75876: LD_VAR 0 3
75880: PPUSH
75881: CALL_OW 261
75885: PUSH
75886: LD_INT 0
75888: EQUAL
75889: IFFALSE 76101
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
75891: LD_ADDR_EXP 50
75895: PUSH
75896: LD_EXP 50
75900: PPUSH
75901: LD_VAR 0 2
75905: PPUSH
75906: LD_EXP 50
75910: PUSH
75911: LD_VAR 0 2
75915: ARRAY
75916: PUSH
75917: LD_VAR 0 3
75921: DIFF
75922: PPUSH
75923: CALL_OW 1
75927: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
75928: LD_VAR 0 3
75932: PPUSH
75933: CALL_OW 263
75937: PUSH
75938: LD_INT 1
75940: EQUAL
75941: IFFALSE 75957
// ComExitVehicle ( IsInUnit ( j ) ) ;
75943: LD_VAR 0 3
75947: PPUSH
75948: CALL_OW 310
75952: PPUSH
75953: CALL_OW 121
// if GetControl ( j ) = control_remote then
75957: LD_VAR 0 3
75961: PPUSH
75962: CALL_OW 263
75966: PUSH
75967: LD_INT 2
75969: EQUAL
75970: IFFALSE 75981
// ComUnlink ( j ) ;
75972: LD_VAR 0 3
75976: PPUSH
75977: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75981: LD_ADDR_VAR 0 10
75985: PUSH
75986: LD_VAR 0 2
75990: PPUSH
75991: LD_INT 3
75993: PPUSH
75994: CALL 85740 0 2
75998: ST_TO_ADDR
// if fac then
75999: LD_VAR 0 10
76003: IFFALSE 76099
// begin for k in fac do
76005: LD_ADDR_VAR 0 4
76009: PUSH
76010: LD_VAR 0 10
76014: PUSH
76015: FOR_IN
76016: IFFALSE 76097
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76018: LD_ADDR_VAR 0 11
76022: PUSH
76023: LD_VAR 0 10
76027: PPUSH
76028: LD_VAR 0 3
76032: PPUSH
76033: CALL_OW 265
76037: PPUSH
76038: LD_VAR 0 3
76042: PPUSH
76043: CALL_OW 262
76047: PPUSH
76048: LD_VAR 0 3
76052: PPUSH
76053: CALL_OW 263
76057: PPUSH
76058: LD_VAR 0 3
76062: PPUSH
76063: CALL_OW 264
76067: PPUSH
76068: CALL 22519 0 5
76072: ST_TO_ADDR
// if components then
76073: LD_VAR 0 11
76077: IFFALSE 76095
// begin MC_InsertProduceList ( i , components ) ;
76079: LD_VAR 0 2
76083: PPUSH
76084: LD_VAR 0 11
76088: PPUSH
76089: CALL 85285 0 2
// break ;
76093: GO 76097
// end ; end ;
76095: GO 76015
76097: POP
76098: POP
// end ; continue ;
76099: GO 75644
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76101: LD_VAR 0 3
76105: PPUSH
76106: LD_INT 1
76108: PPUSH
76109: CALL_OW 289
76113: PUSH
76114: LD_INT 100
76116: LESS
76117: PUSH
76118: LD_VAR 0 3
76122: PPUSH
76123: CALL_OW 314
76127: NOT
76128: AND
76129: IFFALSE 76158
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76131: LD_VAR 0 3
76135: PPUSH
76136: LD_VAR 0 7
76140: PUSH
76141: LD_INT 2
76143: ARRAY
76144: PPUSH
76145: LD_VAR 0 7
76149: PUSH
76150: LD_INT 3
76152: ARRAY
76153: PPUSH
76154: CALL_OW 117
// break ;
76158: GO 76162
// end ;
76160: GO 75644
76162: POP
76163: POP
// end ; end ;
76164: GO 74360
76166: POP
76167: POP
// end ;
76168: LD_VAR 0 1
76172: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76173: LD_INT 0
76175: PPUSH
76176: PPUSH
76177: PPUSH
76178: PPUSH
// if not mc_bases then
76179: LD_EXP 31
76183: NOT
76184: IFFALSE 76188
// exit ;
76186: GO 76349
// for i = 1 to mc_bases do
76188: LD_ADDR_VAR 0 2
76192: PUSH
76193: DOUBLE
76194: LD_INT 1
76196: DEC
76197: ST_TO_ADDR
76198: LD_EXP 31
76202: PUSH
76203: FOR_TO
76204: IFFALSE 76347
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76206: LD_ADDR_VAR 0 4
76210: PUSH
76211: LD_EXP 50
76215: PUSH
76216: LD_VAR 0 2
76220: ARRAY
76221: PUSH
76222: LD_EXP 53
76226: PUSH
76227: LD_VAR 0 2
76231: ARRAY
76232: UNION
76233: PPUSH
76234: LD_INT 33
76236: PUSH
76237: LD_INT 2
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PPUSH
76244: CALL_OW 72
76248: ST_TO_ADDR
// if tmp then
76249: LD_VAR 0 4
76253: IFFALSE 76345
// for j in tmp do
76255: LD_ADDR_VAR 0 3
76259: PUSH
76260: LD_VAR 0 4
76264: PUSH
76265: FOR_IN
76266: IFFALSE 76343
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76268: LD_VAR 0 3
76272: PPUSH
76273: CALL_OW 312
76277: NOT
76278: PUSH
76279: LD_VAR 0 3
76283: PPUSH
76284: CALL_OW 256
76288: PUSH
76289: LD_INT 250
76291: GREATEREQUAL
76292: AND
76293: IFFALSE 76306
// Connect ( j ) else
76295: LD_VAR 0 3
76299: PPUSH
76300: CALL 27990 0 1
76304: GO 76341
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76306: LD_VAR 0 3
76310: PPUSH
76311: CALL_OW 256
76315: PUSH
76316: LD_INT 250
76318: LESS
76319: PUSH
76320: LD_VAR 0 3
76324: PPUSH
76325: CALL_OW 312
76329: AND
76330: IFFALSE 76341
// ComUnlink ( j ) ;
76332: LD_VAR 0 3
76336: PPUSH
76337: CALL_OW 136
76341: GO 76265
76343: POP
76344: POP
// end ;
76345: GO 76203
76347: POP
76348: POP
// end ;
76349: LD_VAR 0 1
76353: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76354: LD_INT 0
76356: PPUSH
76357: PPUSH
76358: PPUSH
76359: PPUSH
76360: PPUSH
// if not mc_bases then
76361: LD_EXP 31
76365: NOT
76366: IFFALSE 76370
// exit ;
76368: GO 76815
// for i = 1 to mc_bases do
76370: LD_ADDR_VAR 0 2
76374: PUSH
76375: DOUBLE
76376: LD_INT 1
76378: DEC
76379: ST_TO_ADDR
76380: LD_EXP 31
76384: PUSH
76385: FOR_TO
76386: IFFALSE 76813
// begin if not mc_produce [ i ] then
76388: LD_EXP 52
76392: PUSH
76393: LD_VAR 0 2
76397: ARRAY
76398: NOT
76399: IFFALSE 76403
// continue ;
76401: GO 76385
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76403: LD_ADDR_VAR 0 5
76407: PUSH
76408: LD_EXP 31
76412: PUSH
76413: LD_VAR 0 2
76417: ARRAY
76418: PPUSH
76419: LD_INT 30
76421: PUSH
76422: LD_INT 3
76424: PUSH
76425: EMPTY
76426: LIST
76427: LIST
76428: PPUSH
76429: CALL_OW 72
76433: ST_TO_ADDR
// if not fac then
76434: LD_VAR 0 5
76438: NOT
76439: IFFALSE 76443
// continue ;
76441: GO 76385
// for j in fac do
76443: LD_ADDR_VAR 0 3
76447: PUSH
76448: LD_VAR 0 5
76452: PUSH
76453: FOR_IN
76454: IFFALSE 76809
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76456: LD_VAR 0 3
76460: PPUSH
76461: CALL_OW 461
76465: PUSH
76466: LD_INT 2
76468: NONEQUAL
76469: PUSH
76470: LD_VAR 0 3
76474: PPUSH
76475: LD_INT 15
76477: PPUSH
76478: CALL 27618 0 2
76482: PUSH
76483: LD_INT 4
76485: ARRAY
76486: OR
76487: IFFALSE 76491
// continue ;
76489: GO 76453
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76491: LD_VAR 0 3
76495: PPUSH
76496: LD_EXP 52
76500: PUSH
76501: LD_VAR 0 2
76505: ARRAY
76506: PUSH
76507: LD_INT 1
76509: ARRAY
76510: PUSH
76511: LD_INT 1
76513: ARRAY
76514: PPUSH
76515: LD_EXP 52
76519: PUSH
76520: LD_VAR 0 2
76524: ARRAY
76525: PUSH
76526: LD_INT 1
76528: ARRAY
76529: PUSH
76530: LD_INT 2
76532: ARRAY
76533: PPUSH
76534: LD_EXP 52
76538: PUSH
76539: LD_VAR 0 2
76543: ARRAY
76544: PUSH
76545: LD_INT 1
76547: ARRAY
76548: PUSH
76549: LD_INT 3
76551: ARRAY
76552: PPUSH
76553: LD_EXP 52
76557: PUSH
76558: LD_VAR 0 2
76562: ARRAY
76563: PUSH
76564: LD_INT 1
76566: ARRAY
76567: PUSH
76568: LD_INT 4
76570: ARRAY
76571: PPUSH
76572: CALL_OW 448
76576: PUSH
76577: LD_VAR 0 3
76581: PPUSH
76582: LD_EXP 52
76586: PUSH
76587: LD_VAR 0 2
76591: ARRAY
76592: PUSH
76593: LD_INT 1
76595: ARRAY
76596: PUSH
76597: LD_INT 1
76599: ARRAY
76600: PUSH
76601: LD_EXP 52
76605: PUSH
76606: LD_VAR 0 2
76610: ARRAY
76611: PUSH
76612: LD_INT 1
76614: ARRAY
76615: PUSH
76616: LD_INT 2
76618: ARRAY
76619: PUSH
76620: LD_EXP 52
76624: PUSH
76625: LD_VAR 0 2
76629: ARRAY
76630: PUSH
76631: LD_INT 1
76633: ARRAY
76634: PUSH
76635: LD_INT 3
76637: ARRAY
76638: PUSH
76639: LD_EXP 52
76643: PUSH
76644: LD_VAR 0 2
76648: ARRAY
76649: PUSH
76650: LD_INT 1
76652: ARRAY
76653: PUSH
76654: LD_INT 4
76656: ARRAY
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: PPUSH
76664: CALL 31385 0 2
76668: AND
76669: IFFALSE 76807
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76671: LD_VAR 0 3
76675: PPUSH
76676: LD_EXP 52
76680: PUSH
76681: LD_VAR 0 2
76685: ARRAY
76686: PUSH
76687: LD_INT 1
76689: ARRAY
76690: PUSH
76691: LD_INT 1
76693: ARRAY
76694: PPUSH
76695: LD_EXP 52
76699: PUSH
76700: LD_VAR 0 2
76704: ARRAY
76705: PUSH
76706: LD_INT 1
76708: ARRAY
76709: PUSH
76710: LD_INT 2
76712: ARRAY
76713: PPUSH
76714: LD_EXP 52
76718: PUSH
76719: LD_VAR 0 2
76723: ARRAY
76724: PUSH
76725: LD_INT 1
76727: ARRAY
76728: PUSH
76729: LD_INT 3
76731: ARRAY
76732: PPUSH
76733: LD_EXP 52
76737: PUSH
76738: LD_VAR 0 2
76742: ARRAY
76743: PUSH
76744: LD_INT 1
76746: ARRAY
76747: PUSH
76748: LD_INT 4
76750: ARRAY
76751: PPUSH
76752: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76756: LD_ADDR_VAR 0 4
76760: PUSH
76761: LD_EXP 52
76765: PUSH
76766: LD_VAR 0 2
76770: ARRAY
76771: PPUSH
76772: LD_INT 1
76774: PPUSH
76775: CALL_OW 3
76779: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76780: LD_ADDR_EXP 52
76784: PUSH
76785: LD_EXP 52
76789: PPUSH
76790: LD_VAR 0 2
76794: PPUSH
76795: LD_VAR 0 4
76799: PPUSH
76800: CALL_OW 1
76804: ST_TO_ADDR
// break ;
76805: GO 76809
// end ; end ;
76807: GO 76453
76809: POP
76810: POP
// end ;
76811: GO 76385
76813: POP
76814: POP
// end ;
76815: LD_VAR 0 1
76819: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
76820: LD_INT 0
76822: PPUSH
76823: PPUSH
76824: PPUSH
// if not mc_bases then
76825: LD_EXP 31
76829: NOT
76830: IFFALSE 76834
// exit ;
76832: GO 76923
// for i = 1 to mc_bases do
76834: LD_ADDR_VAR 0 2
76838: PUSH
76839: DOUBLE
76840: LD_INT 1
76842: DEC
76843: ST_TO_ADDR
76844: LD_EXP 31
76848: PUSH
76849: FOR_TO
76850: IFFALSE 76921
// begin if mc_attack [ i ] then
76852: LD_EXP 51
76856: PUSH
76857: LD_VAR 0 2
76861: ARRAY
76862: IFFALSE 76919
// begin tmp := mc_attack [ i ] [ 1 ] ;
76864: LD_ADDR_VAR 0 3
76868: PUSH
76869: LD_EXP 51
76873: PUSH
76874: LD_VAR 0 2
76878: ARRAY
76879: PUSH
76880: LD_INT 1
76882: ARRAY
76883: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
76884: LD_ADDR_EXP 51
76888: PUSH
76889: LD_EXP 51
76893: PPUSH
76894: LD_VAR 0 2
76898: PPUSH
76899: EMPTY
76900: PPUSH
76901: CALL_OW 1
76905: ST_TO_ADDR
// Attack ( tmp ) ;
76906: LD_VAR 0 3
76910: PPUSH
76911: CALL 111611 0 1
// exit ;
76915: POP
76916: POP
76917: GO 76923
// end ; end ;
76919: GO 76849
76921: POP
76922: POP
// end ;
76923: LD_VAR 0 1
76927: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
76928: LD_INT 0
76930: PPUSH
76931: PPUSH
76932: PPUSH
76933: PPUSH
76934: PPUSH
76935: PPUSH
76936: PPUSH
// if not mc_bases then
76937: LD_EXP 31
76941: NOT
76942: IFFALSE 76946
// exit ;
76944: GO 77803
// for i = 1 to mc_bases do
76946: LD_ADDR_VAR 0 2
76950: PUSH
76951: DOUBLE
76952: LD_INT 1
76954: DEC
76955: ST_TO_ADDR
76956: LD_EXP 31
76960: PUSH
76961: FOR_TO
76962: IFFALSE 77801
// begin if not mc_bases [ i ] then
76964: LD_EXP 31
76968: PUSH
76969: LD_VAR 0 2
76973: ARRAY
76974: NOT
76975: IFFALSE 76979
// continue ;
76977: GO 76961
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76979: LD_ADDR_VAR 0 7
76983: PUSH
76984: LD_EXP 31
76988: PUSH
76989: LD_VAR 0 2
76993: ARRAY
76994: PUSH
76995: LD_INT 1
76997: ARRAY
76998: PPUSH
76999: CALL 21670 0 1
77003: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77004: LD_ADDR_EXP 54
77008: PUSH
77009: LD_EXP 54
77013: PPUSH
77014: LD_VAR 0 2
77018: PPUSH
77019: LD_EXP 31
77023: PUSH
77024: LD_VAR 0 2
77028: ARRAY
77029: PUSH
77030: LD_INT 1
77032: ARRAY
77033: PPUSH
77034: CALL_OW 255
77038: PPUSH
77039: LD_EXP 56
77043: PUSH
77044: LD_VAR 0 2
77048: ARRAY
77049: PPUSH
77050: CALL 21635 0 2
77054: PPUSH
77055: CALL_OW 1
77059: ST_TO_ADDR
// if not mc_scan [ i ] then
77060: LD_EXP 54
77064: PUSH
77065: LD_VAR 0 2
77069: ARRAY
77070: NOT
77071: IFFALSE 77249
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77073: LD_ADDR_EXP 74
77077: PUSH
77078: LD_EXP 74
77082: PPUSH
77083: LD_VAR 0 2
77087: PPUSH
77088: LD_INT 0
77090: PPUSH
77091: CALL_OW 1
77095: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77096: LD_ADDR_VAR 0 4
77100: PUSH
77101: LD_EXP 31
77105: PUSH
77106: LD_VAR 0 2
77110: ARRAY
77111: PPUSH
77112: LD_INT 2
77114: PUSH
77115: LD_INT 25
77117: PUSH
77118: LD_INT 5
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 25
77127: PUSH
77128: LD_INT 8
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 25
77137: PUSH
77138: LD_INT 9
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: PPUSH
77151: CALL_OW 72
77155: ST_TO_ADDR
// if not tmp then
77156: LD_VAR 0 4
77160: NOT
77161: IFFALSE 77165
// continue ;
77163: GO 76961
// for j in tmp do
77165: LD_ADDR_VAR 0 3
77169: PUSH
77170: LD_VAR 0 4
77174: PUSH
77175: FOR_IN
77176: IFFALSE 77247
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77178: LD_VAR 0 3
77182: PPUSH
77183: CALL_OW 310
77187: PPUSH
77188: CALL_OW 266
77192: PUSH
77193: LD_INT 5
77195: EQUAL
77196: PUSH
77197: LD_VAR 0 3
77201: PPUSH
77202: CALL_OW 257
77206: PUSH
77207: LD_INT 1
77209: EQUAL
77210: AND
77211: PUSH
77212: LD_VAR 0 3
77216: PPUSH
77217: CALL_OW 459
77221: NOT
77222: AND
77223: PUSH
77224: LD_VAR 0 7
77228: AND
77229: IFFALSE 77245
// ComChangeProfession ( j , class ) ;
77231: LD_VAR 0 3
77235: PPUSH
77236: LD_VAR 0 7
77240: PPUSH
77241: CALL_OW 123
77245: GO 77175
77247: POP
77248: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77249: LD_EXP 54
77253: PUSH
77254: LD_VAR 0 2
77258: ARRAY
77259: PUSH
77260: LD_EXP 74
77264: PUSH
77265: LD_VAR 0 2
77269: ARRAY
77270: NOT
77271: AND
77272: PUSH
77273: LD_EXP 53
77277: PUSH
77278: LD_VAR 0 2
77282: ARRAY
77283: NOT
77284: AND
77285: PUSH
77286: LD_EXP 31
77290: PUSH
77291: LD_VAR 0 2
77295: ARRAY
77296: PPUSH
77297: LD_INT 50
77299: PUSH
77300: EMPTY
77301: LIST
77302: PUSH
77303: LD_INT 2
77305: PUSH
77306: LD_INT 30
77308: PUSH
77309: LD_INT 32
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 30
77318: PUSH
77319: LD_INT 33
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 30
77328: PUSH
77329: LD_INT 4
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 30
77338: PUSH
77339: LD_INT 5
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: LIST
77350: LIST
77351: LIST
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PPUSH
77357: CALL_OW 72
77361: PUSH
77362: LD_INT 4
77364: LESS
77365: PUSH
77366: LD_EXP 31
77370: PUSH
77371: LD_VAR 0 2
77375: ARRAY
77376: PPUSH
77377: LD_INT 3
77379: PUSH
77380: LD_INT 24
77382: PUSH
77383: LD_INT 1000
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 2
77396: PUSH
77397: LD_INT 30
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 30
77409: PUSH
77410: LD_INT 1
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PPUSH
77426: CALL_OW 72
77430: OR
77431: AND
77432: IFFALSE 77683
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77434: LD_ADDR_EXP 74
77438: PUSH
77439: LD_EXP 74
77443: PPUSH
77444: LD_VAR 0 2
77448: PPUSH
77449: LD_INT 1
77451: PPUSH
77452: CALL_OW 1
77456: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77457: LD_ADDR_VAR 0 4
77461: PUSH
77462: LD_EXP 31
77466: PUSH
77467: LD_VAR 0 2
77471: ARRAY
77472: PPUSH
77473: LD_INT 2
77475: PUSH
77476: LD_INT 25
77478: PUSH
77479: LD_INT 1
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 25
77488: PUSH
77489: LD_INT 5
77491: PUSH
77492: EMPTY
77493: LIST
77494: LIST
77495: PUSH
77496: LD_INT 25
77498: PUSH
77499: LD_INT 8
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 25
77508: PUSH
77509: LD_INT 9
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: PPUSH
77523: CALL_OW 72
77527: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77528: LD_ADDR_VAR 0 4
77532: PUSH
77533: LD_VAR 0 4
77537: PUSH
77538: LD_VAR 0 4
77542: PPUSH
77543: LD_INT 18
77545: PPUSH
77546: CALL 54834 0 2
77550: DIFF
77551: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77552: LD_VAR 0 4
77556: NOT
77557: PUSH
77558: LD_EXP 31
77562: PUSH
77563: LD_VAR 0 2
77567: ARRAY
77568: PPUSH
77569: LD_INT 2
77571: PUSH
77572: LD_INT 30
77574: PUSH
77575: LD_INT 4
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 30
77584: PUSH
77585: LD_INT 5
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: LIST
77596: PPUSH
77597: CALL_OW 72
77601: NOT
77602: AND
77603: IFFALSE 77665
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77605: LD_ADDR_VAR 0 4
77609: PUSH
77610: LD_EXP 31
77614: PUSH
77615: LD_VAR 0 2
77619: ARRAY
77620: PPUSH
77621: LD_INT 2
77623: PUSH
77624: LD_INT 25
77626: PUSH
77627: LD_INT 2
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: PUSH
77634: LD_INT 25
77636: PUSH
77637: LD_INT 3
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 25
77646: PUSH
77647: LD_INT 4
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: PPUSH
77660: CALL_OW 72
77664: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77665: LD_VAR 0 2
77669: PPUSH
77670: LD_VAR 0 4
77674: PPUSH
77675: CALL 116320 0 2
// exit ;
77679: POP
77680: POP
77681: GO 77803
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77683: LD_EXP 54
77687: PUSH
77688: LD_VAR 0 2
77692: ARRAY
77693: PUSH
77694: LD_EXP 74
77698: PUSH
77699: LD_VAR 0 2
77703: ARRAY
77704: NOT
77705: AND
77706: PUSH
77707: LD_EXP 53
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: AND
77718: IFFALSE 77799
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77720: LD_ADDR_EXP 74
77724: PUSH
77725: LD_EXP 74
77729: PPUSH
77730: LD_VAR 0 2
77734: PPUSH
77735: LD_INT 1
77737: PPUSH
77738: CALL_OW 1
77742: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77743: LD_ADDR_VAR 0 4
77747: PUSH
77748: LD_EXP 53
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77759: LD_ADDR_EXP 53
77763: PUSH
77764: LD_EXP 53
77768: PPUSH
77769: LD_VAR 0 2
77773: PPUSH
77774: EMPTY
77775: PPUSH
77776: CALL_OW 1
77780: ST_TO_ADDR
// Defend ( i , tmp ) ;
77781: LD_VAR 0 2
77785: PPUSH
77786: LD_VAR 0 4
77790: PPUSH
77791: CALL 116916 0 2
// exit ;
77795: POP
77796: POP
77797: GO 77803
// end ; end ;
77799: GO 76961
77801: POP
77802: POP
// end ;
77803: LD_VAR 0 1
77807: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
77808: LD_INT 0
77810: PPUSH
77811: PPUSH
77812: PPUSH
77813: PPUSH
77814: PPUSH
77815: PPUSH
77816: PPUSH
77817: PPUSH
77818: PPUSH
77819: PPUSH
77820: PPUSH
// if not mc_bases then
77821: LD_EXP 31
77825: NOT
77826: IFFALSE 77830
// exit ;
77828: GO 78917
// for i = 1 to mc_bases do
77830: LD_ADDR_VAR 0 2
77834: PUSH
77835: DOUBLE
77836: LD_INT 1
77838: DEC
77839: ST_TO_ADDR
77840: LD_EXP 31
77844: PUSH
77845: FOR_TO
77846: IFFALSE 78915
// begin tmp := mc_lab [ i ] ;
77848: LD_ADDR_VAR 0 6
77852: PUSH
77853: LD_EXP 64
77857: PUSH
77858: LD_VAR 0 2
77862: ARRAY
77863: ST_TO_ADDR
// if not tmp then
77864: LD_VAR 0 6
77868: NOT
77869: IFFALSE 77873
// continue ;
77871: GO 77845
// idle_lab := 0 ;
77873: LD_ADDR_VAR 0 11
77877: PUSH
77878: LD_INT 0
77880: ST_TO_ADDR
// for j in tmp do
77881: LD_ADDR_VAR 0 3
77885: PUSH
77886: LD_VAR 0 6
77890: PUSH
77891: FOR_IN
77892: IFFALSE 78911
// begin researching := false ;
77894: LD_ADDR_VAR 0 10
77898: PUSH
77899: LD_INT 0
77901: ST_TO_ADDR
// side := GetSide ( j ) ;
77902: LD_ADDR_VAR 0 4
77906: PUSH
77907: LD_VAR 0 3
77911: PPUSH
77912: CALL_OW 255
77916: ST_TO_ADDR
// if not mc_tech [ side ] then
77917: LD_EXP 58
77921: PUSH
77922: LD_VAR 0 4
77926: ARRAY
77927: NOT
77928: IFFALSE 77932
// continue ;
77930: GO 77891
// if BuildingStatus ( j ) = bs_idle then
77932: LD_VAR 0 3
77936: PPUSH
77937: CALL_OW 461
77941: PUSH
77942: LD_INT 2
77944: EQUAL
77945: IFFALSE 78133
// begin if idle_lab and UnitsInside ( j ) < 6 then
77947: LD_VAR 0 11
77951: PUSH
77952: LD_VAR 0 3
77956: PPUSH
77957: CALL_OW 313
77961: PUSH
77962: LD_INT 6
77964: LESS
77965: AND
77966: IFFALSE 78037
// begin tmp2 := UnitsInside ( idle_lab ) ;
77968: LD_ADDR_VAR 0 9
77972: PUSH
77973: LD_VAR 0 11
77977: PPUSH
77978: CALL_OW 313
77982: ST_TO_ADDR
// if tmp2 then
77983: LD_VAR 0 9
77987: IFFALSE 78029
// for x in tmp2 do
77989: LD_ADDR_VAR 0 7
77993: PUSH
77994: LD_VAR 0 9
77998: PUSH
77999: FOR_IN
78000: IFFALSE 78027
// begin ComExitBuilding ( x ) ;
78002: LD_VAR 0 7
78006: PPUSH
78007: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78011: LD_VAR 0 7
78015: PPUSH
78016: LD_VAR 0 3
78020: PPUSH
78021: CALL_OW 180
// end ;
78025: GO 77999
78027: POP
78028: POP
// idle_lab := 0 ;
78029: LD_ADDR_VAR 0 11
78033: PUSH
78034: LD_INT 0
78036: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78037: LD_ADDR_VAR 0 5
78041: PUSH
78042: LD_EXP 58
78046: PUSH
78047: LD_VAR 0 4
78051: ARRAY
78052: PUSH
78053: FOR_IN
78054: IFFALSE 78114
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78056: LD_VAR 0 3
78060: PPUSH
78061: LD_VAR 0 5
78065: PPUSH
78066: CALL_OW 430
78070: PUSH
78071: LD_VAR 0 4
78075: PPUSH
78076: LD_VAR 0 5
78080: PPUSH
78081: CALL 20740 0 2
78085: AND
78086: IFFALSE 78112
// begin researching := true ;
78088: LD_ADDR_VAR 0 10
78092: PUSH
78093: LD_INT 1
78095: ST_TO_ADDR
// ComResearch ( j , t ) ;
78096: LD_VAR 0 3
78100: PPUSH
78101: LD_VAR 0 5
78105: PPUSH
78106: CALL_OW 124
// break ;
78110: GO 78114
// end ;
78112: GO 78053
78114: POP
78115: POP
// if not researching then
78116: LD_VAR 0 10
78120: NOT
78121: IFFALSE 78133
// idle_lab := j ;
78123: LD_ADDR_VAR 0 11
78127: PUSH
78128: LD_VAR 0 3
78132: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78133: LD_VAR 0 3
78137: PPUSH
78138: CALL_OW 461
78142: PUSH
78143: LD_INT 10
78145: EQUAL
78146: IFFALSE 78734
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78148: LD_EXP 60
78152: PUSH
78153: LD_VAR 0 2
78157: ARRAY
78158: NOT
78159: PUSH
78160: LD_EXP 61
78164: PUSH
78165: LD_VAR 0 2
78169: ARRAY
78170: NOT
78171: AND
78172: PUSH
78173: LD_EXP 58
78177: PUSH
78178: LD_VAR 0 4
78182: ARRAY
78183: PUSH
78184: LD_INT 1
78186: GREATER
78187: AND
78188: IFFALSE 78319
// begin ComCancel ( j ) ;
78190: LD_VAR 0 3
78194: PPUSH
78195: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78199: LD_ADDR_EXP 58
78203: PUSH
78204: LD_EXP 58
78208: PPUSH
78209: LD_VAR 0 4
78213: PPUSH
78214: LD_EXP 58
78218: PUSH
78219: LD_VAR 0 4
78223: ARRAY
78224: PPUSH
78225: LD_EXP 58
78229: PUSH
78230: LD_VAR 0 4
78234: ARRAY
78235: PUSH
78236: LD_INT 1
78238: MINUS
78239: PPUSH
78240: LD_EXP 58
78244: PUSH
78245: LD_VAR 0 4
78249: ARRAY
78250: PPUSH
78251: LD_INT 0
78253: PPUSH
78254: CALL 24439 0 4
78258: PPUSH
78259: CALL_OW 1
78263: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78264: LD_ADDR_EXP 58
78268: PUSH
78269: LD_EXP 58
78273: PPUSH
78274: LD_VAR 0 4
78278: PPUSH
78279: LD_EXP 58
78283: PUSH
78284: LD_VAR 0 4
78288: ARRAY
78289: PPUSH
78290: LD_EXP 58
78294: PUSH
78295: LD_VAR 0 4
78299: ARRAY
78300: PPUSH
78301: LD_INT 1
78303: PPUSH
78304: LD_INT 0
78306: PPUSH
78307: CALL 24439 0 4
78311: PPUSH
78312: CALL_OW 1
78316: ST_TO_ADDR
// continue ;
78317: GO 77891
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78319: LD_EXP 60
78323: PUSH
78324: LD_VAR 0 2
78328: ARRAY
78329: PUSH
78330: LD_EXP 61
78334: PUSH
78335: LD_VAR 0 2
78339: ARRAY
78340: NOT
78341: AND
78342: IFFALSE 78469
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78344: LD_ADDR_EXP 61
78348: PUSH
78349: LD_EXP 61
78353: PPUSH
78354: LD_VAR 0 2
78358: PUSH
78359: LD_EXP 61
78363: PUSH
78364: LD_VAR 0 2
78368: ARRAY
78369: PUSH
78370: LD_INT 1
78372: PLUS
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PPUSH
78378: LD_EXP 60
78382: PUSH
78383: LD_VAR 0 2
78387: ARRAY
78388: PUSH
78389: LD_INT 1
78391: ARRAY
78392: PPUSH
78393: CALL 25021 0 3
78397: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78398: LD_EXP 60
78402: PUSH
78403: LD_VAR 0 2
78407: ARRAY
78408: PUSH
78409: LD_INT 1
78411: ARRAY
78412: PPUSH
78413: LD_INT 112
78415: PPUSH
78416: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78420: LD_ADDR_VAR 0 9
78424: PUSH
78425: LD_EXP 60
78429: PUSH
78430: LD_VAR 0 2
78434: ARRAY
78435: PPUSH
78436: LD_INT 1
78438: PPUSH
78439: CALL_OW 3
78443: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78444: LD_ADDR_EXP 60
78448: PUSH
78449: LD_EXP 60
78453: PPUSH
78454: LD_VAR 0 2
78458: PPUSH
78459: LD_VAR 0 9
78463: PPUSH
78464: CALL_OW 1
78468: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78469: LD_EXP 60
78473: PUSH
78474: LD_VAR 0 2
78478: ARRAY
78479: PUSH
78480: LD_EXP 61
78484: PUSH
78485: LD_VAR 0 2
78489: ARRAY
78490: AND
78491: PUSH
78492: LD_EXP 61
78496: PUSH
78497: LD_VAR 0 2
78501: ARRAY
78502: PUSH
78503: LD_INT 1
78505: ARRAY
78506: PPUSH
78507: CALL_OW 310
78511: NOT
78512: AND
78513: PUSH
78514: LD_VAR 0 3
78518: PPUSH
78519: CALL_OW 313
78523: PUSH
78524: LD_INT 6
78526: EQUAL
78527: AND
78528: IFFALSE 78584
// begin tmp2 := UnitsInside ( j ) ;
78530: LD_ADDR_VAR 0 9
78534: PUSH
78535: LD_VAR 0 3
78539: PPUSH
78540: CALL_OW 313
78544: ST_TO_ADDR
// if tmp2 = 6 then
78545: LD_VAR 0 9
78549: PUSH
78550: LD_INT 6
78552: EQUAL
78553: IFFALSE 78584
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78555: LD_VAR 0 9
78559: PUSH
78560: LD_INT 1
78562: ARRAY
78563: PPUSH
78564: LD_INT 112
78566: PPUSH
78567: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78571: LD_VAR 0 9
78575: PUSH
78576: LD_INT 1
78578: ARRAY
78579: PPUSH
78580: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78584: LD_EXP 61
78588: PUSH
78589: LD_VAR 0 2
78593: ARRAY
78594: PUSH
78595: LD_EXP 61
78599: PUSH
78600: LD_VAR 0 2
78604: ARRAY
78605: PUSH
78606: LD_INT 1
78608: ARRAY
78609: PPUSH
78610: CALL_OW 314
78614: NOT
78615: AND
78616: PUSH
78617: LD_EXP 61
78621: PUSH
78622: LD_VAR 0 2
78626: ARRAY
78627: PUSH
78628: LD_INT 1
78630: ARRAY
78631: PPUSH
78632: CALL_OW 310
78636: NOT
78637: AND
78638: IFFALSE 78664
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78640: LD_EXP 61
78644: PUSH
78645: LD_VAR 0 2
78649: ARRAY
78650: PUSH
78651: LD_INT 1
78653: ARRAY
78654: PPUSH
78655: LD_VAR 0 3
78659: PPUSH
78660: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78664: LD_EXP 61
78668: PUSH
78669: LD_VAR 0 2
78673: ARRAY
78674: PUSH
78675: LD_INT 1
78677: ARRAY
78678: PPUSH
78679: CALL_OW 310
78683: PUSH
78684: LD_EXP 61
78688: PUSH
78689: LD_VAR 0 2
78693: ARRAY
78694: PUSH
78695: LD_INT 1
78697: ARRAY
78698: PPUSH
78699: CALL_OW 310
78703: PPUSH
78704: CALL_OW 461
78708: PUSH
78709: LD_INT 3
78711: NONEQUAL
78712: AND
78713: IFFALSE 78734
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78715: LD_EXP 61
78719: PUSH
78720: LD_VAR 0 2
78724: ARRAY
78725: PUSH
78726: LD_INT 1
78728: ARRAY
78729: PPUSH
78730: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78734: LD_VAR 0 3
78738: PPUSH
78739: CALL_OW 461
78743: PUSH
78744: LD_INT 6
78746: EQUAL
78747: PUSH
78748: LD_VAR 0 6
78752: PUSH
78753: LD_INT 1
78755: GREATER
78756: AND
78757: IFFALSE 78909
// begin sci := [ ] ;
78759: LD_ADDR_VAR 0 8
78763: PUSH
78764: EMPTY
78765: ST_TO_ADDR
// for x in ( tmp diff j ) do
78766: LD_ADDR_VAR 0 7
78770: PUSH
78771: LD_VAR 0 6
78775: PUSH
78776: LD_VAR 0 3
78780: DIFF
78781: PUSH
78782: FOR_IN
78783: IFFALSE 78835
// begin if sci = 6 then
78785: LD_VAR 0 8
78789: PUSH
78790: LD_INT 6
78792: EQUAL
78793: IFFALSE 78797
// break ;
78795: GO 78835
// if BuildingStatus ( x ) = bs_idle then
78797: LD_VAR 0 7
78801: PPUSH
78802: CALL_OW 461
78806: PUSH
78807: LD_INT 2
78809: EQUAL
78810: IFFALSE 78833
// sci := sci ^ UnitsInside ( x ) ;
78812: LD_ADDR_VAR 0 8
78816: PUSH
78817: LD_VAR 0 8
78821: PUSH
78822: LD_VAR 0 7
78826: PPUSH
78827: CALL_OW 313
78831: ADD
78832: ST_TO_ADDR
// end ;
78833: GO 78782
78835: POP
78836: POP
// if not sci then
78837: LD_VAR 0 8
78841: NOT
78842: IFFALSE 78846
// continue ;
78844: GO 77891
// for x in sci do
78846: LD_ADDR_VAR 0 7
78850: PUSH
78851: LD_VAR 0 8
78855: PUSH
78856: FOR_IN
78857: IFFALSE 78907
// if IsInUnit ( x ) and not HasTask ( x ) then
78859: LD_VAR 0 7
78863: PPUSH
78864: CALL_OW 310
78868: PUSH
78869: LD_VAR 0 7
78873: PPUSH
78874: CALL_OW 314
78878: NOT
78879: AND
78880: IFFALSE 78905
// begin ComExitBuilding ( x ) ;
78882: LD_VAR 0 7
78886: PPUSH
78887: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78891: LD_VAR 0 7
78895: PPUSH
78896: LD_VAR 0 3
78900: PPUSH
78901: CALL_OW 180
// end ;
78905: GO 78856
78907: POP
78908: POP
// end ; end ;
78909: GO 77891
78911: POP
78912: POP
// end ;
78913: GO 77845
78915: POP
78916: POP
// end ;
78917: LD_VAR 0 1
78921: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
78922: LD_INT 0
78924: PPUSH
78925: PPUSH
// if not mc_bases then
78926: LD_EXP 31
78930: NOT
78931: IFFALSE 78935
// exit ;
78933: GO 79016
// for i = 1 to mc_bases do
78935: LD_ADDR_VAR 0 2
78939: PUSH
78940: DOUBLE
78941: LD_INT 1
78943: DEC
78944: ST_TO_ADDR
78945: LD_EXP 31
78949: PUSH
78950: FOR_TO
78951: IFFALSE 79014
// if mc_mines [ i ] and mc_miners [ i ] then
78953: LD_EXP 44
78957: PUSH
78958: LD_VAR 0 2
78962: ARRAY
78963: PUSH
78964: LD_EXP 45
78968: PUSH
78969: LD_VAR 0 2
78973: ARRAY
78974: AND
78975: IFFALSE 79012
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
78977: LD_EXP 45
78981: PUSH
78982: LD_VAR 0 2
78986: ARRAY
78987: PUSH
78988: LD_INT 1
78990: ARRAY
78991: PPUSH
78992: CALL_OW 255
78996: PPUSH
78997: LD_EXP 44
79001: PUSH
79002: LD_VAR 0 2
79006: ARRAY
79007: PPUSH
79008: CALL 21823 0 2
79012: GO 78950
79014: POP
79015: POP
// end ;
79016: LD_VAR 0 1
79020: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79021: LD_INT 0
79023: PPUSH
79024: PPUSH
79025: PPUSH
79026: PPUSH
79027: PPUSH
79028: PPUSH
79029: PPUSH
79030: PPUSH
// if not mc_bases or not mc_parking then
79031: LD_EXP 31
79035: NOT
79036: PUSH
79037: LD_EXP 55
79041: NOT
79042: OR
79043: IFFALSE 79047
// exit ;
79045: GO 79757
// for i = 1 to mc_bases do
79047: LD_ADDR_VAR 0 2
79051: PUSH
79052: DOUBLE
79053: LD_INT 1
79055: DEC
79056: ST_TO_ADDR
79057: LD_EXP 31
79061: PUSH
79062: FOR_TO
79063: IFFALSE 79755
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79065: LD_EXP 31
79069: PUSH
79070: LD_VAR 0 2
79074: ARRAY
79075: NOT
79076: PUSH
79077: LD_EXP 55
79081: PUSH
79082: LD_VAR 0 2
79086: ARRAY
79087: NOT
79088: OR
79089: IFFALSE 79093
// continue ;
79091: GO 79062
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79093: LD_ADDR_VAR 0 5
79097: PUSH
79098: LD_EXP 31
79102: PUSH
79103: LD_VAR 0 2
79107: ARRAY
79108: PUSH
79109: LD_INT 1
79111: ARRAY
79112: PPUSH
79113: CALL_OW 255
79117: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79118: LD_ADDR_VAR 0 6
79122: PUSH
79123: LD_EXP 31
79127: PUSH
79128: LD_VAR 0 2
79132: ARRAY
79133: PPUSH
79134: LD_INT 30
79136: PUSH
79137: LD_INT 3
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PPUSH
79144: CALL_OW 72
79148: ST_TO_ADDR
// if not fac then
79149: LD_VAR 0 6
79153: NOT
79154: IFFALSE 79205
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79156: LD_ADDR_VAR 0 6
79160: PUSH
79161: LD_EXP 31
79165: PUSH
79166: LD_VAR 0 2
79170: ARRAY
79171: PPUSH
79172: LD_INT 2
79174: PUSH
79175: LD_INT 30
79177: PUSH
79178: LD_INT 0
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 30
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: LIST
79199: PPUSH
79200: CALL_OW 72
79204: ST_TO_ADDR
// if not fac then
79205: LD_VAR 0 6
79209: NOT
79210: IFFALSE 79214
// continue ;
79212: GO 79062
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79214: LD_ADDR_VAR 0 7
79218: PUSH
79219: LD_EXP 55
79223: PUSH
79224: LD_VAR 0 2
79228: ARRAY
79229: PPUSH
79230: LD_INT 22
79232: PUSH
79233: LD_VAR 0 5
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 21
79244: PUSH
79245: LD_INT 2
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 3
79254: PUSH
79255: LD_INT 24
79257: PUSH
79258: LD_INT 1000
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: LIST
79273: PPUSH
79274: CALL_OW 70
79278: ST_TO_ADDR
// for j in fac do
79279: LD_ADDR_VAR 0 3
79283: PUSH
79284: LD_VAR 0 6
79288: PUSH
79289: FOR_IN
79290: IFFALSE 79371
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79292: LD_ADDR_VAR 0 7
79296: PUSH
79297: LD_VAR 0 7
79301: PUSH
79302: LD_INT 22
79304: PUSH
79305: LD_VAR 0 5
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 91
79316: PUSH
79317: LD_VAR 0 3
79321: PUSH
79322: LD_INT 15
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 21
79332: PUSH
79333: LD_INT 2
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 3
79342: PUSH
79343: LD_INT 24
79345: PUSH
79346: LD_INT 1000
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: LIST
79361: LIST
79362: PPUSH
79363: CALL_OW 69
79367: UNION
79368: ST_TO_ADDR
79369: GO 79289
79371: POP
79372: POP
// if not vehs then
79373: LD_VAR 0 7
79377: NOT
79378: IFFALSE 79404
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79380: LD_ADDR_EXP 43
79384: PUSH
79385: LD_EXP 43
79389: PPUSH
79390: LD_VAR 0 2
79394: PPUSH
79395: EMPTY
79396: PPUSH
79397: CALL_OW 1
79401: ST_TO_ADDR
// continue ;
79402: GO 79062
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79404: LD_ADDR_VAR 0 8
79408: PUSH
79409: LD_EXP 31
79413: PUSH
79414: LD_VAR 0 2
79418: ARRAY
79419: PPUSH
79420: LD_INT 30
79422: PUSH
79423: LD_INT 3
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PPUSH
79430: CALL_OW 72
79434: ST_TO_ADDR
// if tmp then
79435: LD_VAR 0 8
79439: IFFALSE 79542
// begin for j in tmp do
79441: LD_ADDR_VAR 0 3
79445: PUSH
79446: LD_VAR 0 8
79450: PUSH
79451: FOR_IN
79452: IFFALSE 79540
// for k in UnitsInside ( j ) do
79454: LD_ADDR_VAR 0 4
79458: PUSH
79459: LD_VAR 0 3
79463: PPUSH
79464: CALL_OW 313
79468: PUSH
79469: FOR_IN
79470: IFFALSE 79536
// if k then
79472: LD_VAR 0 4
79476: IFFALSE 79534
// if not k in mc_repair_vehicle [ i ] then
79478: LD_VAR 0 4
79482: PUSH
79483: LD_EXP 43
79487: PUSH
79488: LD_VAR 0 2
79492: ARRAY
79493: IN
79494: NOT
79495: IFFALSE 79534
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79497: LD_ADDR_EXP 43
79501: PUSH
79502: LD_EXP 43
79506: PPUSH
79507: LD_VAR 0 2
79511: PPUSH
79512: LD_EXP 43
79516: PUSH
79517: LD_VAR 0 2
79521: ARRAY
79522: PUSH
79523: LD_VAR 0 4
79527: UNION
79528: PPUSH
79529: CALL_OW 1
79533: ST_TO_ADDR
79534: GO 79469
79536: POP
79537: POP
79538: GO 79451
79540: POP
79541: POP
// end ; if not mc_repair_vehicle [ i ] then
79542: LD_EXP 43
79546: PUSH
79547: LD_VAR 0 2
79551: ARRAY
79552: NOT
79553: IFFALSE 79557
// continue ;
79555: GO 79062
// for j in mc_repair_vehicle [ i ] do
79557: LD_ADDR_VAR 0 3
79561: PUSH
79562: LD_EXP 43
79566: PUSH
79567: LD_VAR 0 2
79571: ARRAY
79572: PUSH
79573: FOR_IN
79574: IFFALSE 79751
// begin if GetClass ( j ) <> 3 then
79576: LD_VAR 0 3
79580: PPUSH
79581: CALL_OW 257
79585: PUSH
79586: LD_INT 3
79588: NONEQUAL
79589: IFFALSE 79630
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79591: LD_ADDR_EXP 43
79595: PUSH
79596: LD_EXP 43
79600: PPUSH
79601: LD_VAR 0 2
79605: PPUSH
79606: LD_EXP 43
79610: PUSH
79611: LD_VAR 0 2
79615: ARRAY
79616: PUSH
79617: LD_VAR 0 3
79621: DIFF
79622: PPUSH
79623: CALL_OW 1
79627: ST_TO_ADDR
// continue ;
79628: GO 79573
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79630: LD_VAR 0 3
79634: PPUSH
79635: CALL_OW 311
79639: NOT
79640: PUSH
79641: LD_VAR 0 3
79645: PUSH
79646: LD_EXP 34
79650: PUSH
79651: LD_VAR 0 2
79655: ARRAY
79656: PUSH
79657: LD_INT 1
79659: ARRAY
79660: IN
79661: NOT
79662: AND
79663: PUSH
79664: LD_VAR 0 3
79668: PUSH
79669: LD_EXP 34
79673: PUSH
79674: LD_VAR 0 2
79678: ARRAY
79679: PUSH
79680: LD_INT 2
79682: ARRAY
79683: IN
79684: NOT
79685: AND
79686: IFFALSE 79749
// begin if IsInUnit ( j ) then
79688: LD_VAR 0 3
79692: PPUSH
79693: CALL_OW 310
79697: IFFALSE 79710
// ComExitBuilding ( j ) else
79699: LD_VAR 0 3
79703: PPUSH
79704: CALL_OW 122
79708: GO 79749
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79710: LD_VAR 0 3
79714: PPUSH
79715: LD_VAR 0 7
79719: PUSH
79720: LD_INT 1
79722: ARRAY
79723: PPUSH
79724: CALL 59325 0 2
79728: NOT
79729: IFFALSE 79749
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79731: LD_VAR 0 3
79735: PPUSH
79736: LD_VAR 0 7
79740: PUSH
79741: LD_INT 1
79743: ARRAY
79744: PPUSH
79745: CALL_OW 129
// end ; end ;
79749: GO 79573
79751: POP
79752: POP
// end ;
79753: GO 79062
79755: POP
79756: POP
// end ;
79757: LD_VAR 0 1
79761: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79762: LD_INT 0
79764: PPUSH
79765: PPUSH
79766: PPUSH
79767: PPUSH
79768: PPUSH
79769: PPUSH
79770: PPUSH
79771: PPUSH
79772: PPUSH
79773: PPUSH
79774: PPUSH
// if not mc_bases then
79775: LD_EXP 31
79779: NOT
79780: IFFALSE 79784
// exit ;
79782: GO 80586
// for i = 1 to mc_bases do
79784: LD_ADDR_VAR 0 2
79788: PUSH
79789: DOUBLE
79790: LD_INT 1
79792: DEC
79793: ST_TO_ADDR
79794: LD_EXP 31
79798: PUSH
79799: FOR_TO
79800: IFFALSE 80584
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
79802: LD_EXP 59
79806: PUSH
79807: LD_VAR 0 2
79811: ARRAY
79812: NOT
79813: PUSH
79814: LD_EXP 34
79818: PUSH
79819: LD_VAR 0 2
79823: ARRAY
79824: PUSH
79825: LD_INT 1
79827: ARRAY
79828: OR
79829: PUSH
79830: LD_EXP 34
79834: PUSH
79835: LD_VAR 0 2
79839: ARRAY
79840: PUSH
79841: LD_INT 2
79843: ARRAY
79844: OR
79845: PUSH
79846: LD_EXP 57
79850: PUSH
79851: LD_VAR 0 2
79855: ARRAY
79856: PPUSH
79857: LD_INT 1
79859: PPUSH
79860: CALL_OW 325
79864: NOT
79865: OR
79866: PUSH
79867: LD_EXP 54
79871: PUSH
79872: LD_VAR 0 2
79876: ARRAY
79877: OR
79878: IFFALSE 79882
// continue ;
79880: GO 79799
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
79882: LD_ADDR_VAR 0 8
79886: PUSH
79887: LD_EXP 31
79891: PUSH
79892: LD_VAR 0 2
79896: ARRAY
79897: PPUSH
79898: LD_INT 25
79900: PUSH
79901: LD_INT 4
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 50
79910: PUSH
79911: EMPTY
79912: LIST
79913: PUSH
79914: LD_INT 3
79916: PUSH
79917: LD_INT 60
79919: PUSH
79920: EMPTY
79921: LIST
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: LIST
79931: PPUSH
79932: CALL_OW 72
79936: PUSH
79937: LD_EXP 35
79941: PUSH
79942: LD_VAR 0 2
79946: ARRAY
79947: DIFF
79948: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79949: LD_ADDR_VAR 0 9
79953: PUSH
79954: LD_EXP 31
79958: PUSH
79959: LD_VAR 0 2
79963: ARRAY
79964: PPUSH
79965: LD_INT 2
79967: PUSH
79968: LD_INT 30
79970: PUSH
79971: LD_INT 0
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 30
79980: PUSH
79981: LD_INT 1
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: LIST
79992: PPUSH
79993: CALL_OW 72
79997: ST_TO_ADDR
// if not tmp or not dep then
79998: LD_VAR 0 8
80002: NOT
80003: PUSH
80004: LD_VAR 0 9
80008: NOT
80009: OR
80010: IFFALSE 80014
// continue ;
80012: GO 79799
// side := GetSide ( tmp [ 1 ] ) ;
80014: LD_ADDR_VAR 0 11
80018: PUSH
80019: LD_VAR 0 8
80023: PUSH
80024: LD_INT 1
80026: ARRAY
80027: PPUSH
80028: CALL_OW 255
80032: ST_TO_ADDR
// dep := dep [ 1 ] ;
80033: LD_ADDR_VAR 0 9
80037: PUSH
80038: LD_VAR 0 9
80042: PUSH
80043: LD_INT 1
80045: ARRAY
80046: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80047: LD_ADDR_VAR 0 7
80051: PUSH
80052: LD_EXP 59
80056: PUSH
80057: LD_VAR 0 2
80061: ARRAY
80062: PPUSH
80063: LD_INT 22
80065: PUSH
80066: LD_INT 0
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 25
80075: PUSH
80076: LD_INT 12
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PPUSH
80087: CALL_OW 70
80091: PUSH
80092: LD_INT 22
80094: PUSH
80095: LD_INT 0
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 25
80104: PUSH
80105: LD_INT 12
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: PUSH
80112: LD_INT 91
80114: PUSH
80115: LD_VAR 0 9
80119: PUSH
80120: LD_INT 20
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: LIST
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: LIST
80132: PPUSH
80133: CALL_OW 69
80137: UNION
80138: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80139: LD_ADDR_VAR 0 10
80143: PUSH
80144: LD_EXP 59
80148: PUSH
80149: LD_VAR 0 2
80153: ARRAY
80154: PPUSH
80155: LD_INT 81
80157: PUSH
80158: LD_VAR 0 11
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PPUSH
80167: CALL_OW 70
80171: ST_TO_ADDR
// if not apes or danger_at_area then
80172: LD_VAR 0 7
80176: NOT
80177: PUSH
80178: LD_VAR 0 10
80182: OR
80183: IFFALSE 80233
// begin if mc_taming [ i ] then
80185: LD_EXP 62
80189: PUSH
80190: LD_VAR 0 2
80194: ARRAY
80195: IFFALSE 80231
// begin MC_Reset ( i , 121 ) ;
80197: LD_VAR 0 2
80201: PPUSH
80202: LD_INT 121
80204: PPUSH
80205: CALL 65223 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80209: LD_ADDR_EXP 62
80213: PUSH
80214: LD_EXP 62
80218: PPUSH
80219: LD_VAR 0 2
80223: PPUSH
80224: EMPTY
80225: PPUSH
80226: CALL_OW 1
80230: ST_TO_ADDR
// end ; continue ;
80231: GO 79799
// end ; for j in tmp do
80233: LD_ADDR_VAR 0 3
80237: PUSH
80238: LD_VAR 0 8
80242: PUSH
80243: FOR_IN
80244: IFFALSE 80580
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80246: LD_VAR 0 3
80250: PUSH
80251: LD_EXP 62
80255: PUSH
80256: LD_VAR 0 2
80260: ARRAY
80261: IN
80262: NOT
80263: PUSH
80264: LD_EXP 62
80268: PUSH
80269: LD_VAR 0 2
80273: ARRAY
80274: PUSH
80275: LD_INT 3
80277: LESS
80278: AND
80279: IFFALSE 80337
// begin SetTag ( j , 121 ) ;
80281: LD_VAR 0 3
80285: PPUSH
80286: LD_INT 121
80288: PPUSH
80289: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80293: LD_ADDR_EXP 62
80297: PUSH
80298: LD_EXP 62
80302: PPUSH
80303: LD_VAR 0 2
80307: PUSH
80308: LD_EXP 62
80312: PUSH
80313: LD_VAR 0 2
80317: ARRAY
80318: PUSH
80319: LD_INT 1
80321: PLUS
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PPUSH
80327: LD_VAR 0 3
80331: PPUSH
80332: CALL 25021 0 3
80336: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80337: LD_VAR 0 3
80341: PUSH
80342: LD_EXP 62
80346: PUSH
80347: LD_VAR 0 2
80351: ARRAY
80352: IN
80353: IFFALSE 80578
// begin if GetClass ( j ) <> 4 then
80355: LD_VAR 0 3
80359: PPUSH
80360: CALL_OW 257
80364: PUSH
80365: LD_INT 4
80367: NONEQUAL
80368: IFFALSE 80421
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80370: LD_ADDR_EXP 62
80374: PUSH
80375: LD_EXP 62
80379: PPUSH
80380: LD_VAR 0 2
80384: PPUSH
80385: LD_EXP 62
80389: PUSH
80390: LD_VAR 0 2
80394: ARRAY
80395: PUSH
80396: LD_VAR 0 3
80400: DIFF
80401: PPUSH
80402: CALL_OW 1
80406: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80407: LD_VAR 0 3
80411: PPUSH
80412: LD_INT 0
80414: PPUSH
80415: CALL_OW 109
// continue ;
80419: GO 80243
// end ; if IsInUnit ( j ) then
80421: LD_VAR 0 3
80425: PPUSH
80426: CALL_OW 310
80430: IFFALSE 80441
// ComExitBuilding ( j ) ;
80432: LD_VAR 0 3
80436: PPUSH
80437: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80441: LD_ADDR_VAR 0 6
80445: PUSH
80446: LD_VAR 0 7
80450: PPUSH
80451: LD_VAR 0 3
80455: PPUSH
80456: CALL_OW 74
80460: ST_TO_ADDR
// if not ape then
80461: LD_VAR 0 6
80465: NOT
80466: IFFALSE 80470
// break ;
80468: GO 80580
// x := GetX ( ape ) ;
80470: LD_ADDR_VAR 0 4
80474: PUSH
80475: LD_VAR 0 6
80479: PPUSH
80480: CALL_OW 250
80484: ST_TO_ADDR
// y := GetY ( ape ) ;
80485: LD_ADDR_VAR 0 5
80489: PUSH
80490: LD_VAR 0 6
80494: PPUSH
80495: CALL_OW 251
80499: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80500: LD_VAR 0 4
80504: PPUSH
80505: LD_VAR 0 5
80509: PPUSH
80510: CALL_OW 488
80514: NOT
80515: PUSH
80516: LD_VAR 0 11
80520: PPUSH
80521: LD_VAR 0 4
80525: PPUSH
80526: LD_VAR 0 5
80530: PPUSH
80531: LD_INT 20
80533: PPUSH
80534: CALL 25917 0 4
80538: PUSH
80539: LD_INT 4
80541: ARRAY
80542: OR
80543: IFFALSE 80547
// break ;
80545: GO 80580
// if not HasTask ( j ) then
80547: LD_VAR 0 3
80551: PPUSH
80552: CALL_OW 314
80556: NOT
80557: IFFALSE 80578
// ComTameXY ( j , x , y ) ;
80559: LD_VAR 0 3
80563: PPUSH
80564: LD_VAR 0 4
80568: PPUSH
80569: LD_VAR 0 5
80573: PPUSH
80574: CALL_OW 131
// end ; end ;
80578: GO 80243
80580: POP
80581: POP
// end ;
80582: GO 79799
80584: POP
80585: POP
// end ;
80586: LD_VAR 0 1
80590: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80591: LD_INT 0
80593: PPUSH
80594: PPUSH
80595: PPUSH
80596: PPUSH
80597: PPUSH
80598: PPUSH
80599: PPUSH
80600: PPUSH
// if not mc_bases then
80601: LD_EXP 31
80605: NOT
80606: IFFALSE 80610
// exit ;
80608: GO 81236
// for i = 1 to mc_bases do
80610: LD_ADDR_VAR 0 2
80614: PUSH
80615: DOUBLE
80616: LD_INT 1
80618: DEC
80619: ST_TO_ADDR
80620: LD_EXP 31
80624: PUSH
80625: FOR_TO
80626: IFFALSE 81234
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80628: LD_EXP 60
80632: PUSH
80633: LD_VAR 0 2
80637: ARRAY
80638: NOT
80639: PUSH
80640: LD_EXP 60
80644: PUSH
80645: LD_VAR 0 2
80649: ARRAY
80650: PPUSH
80651: LD_INT 25
80653: PUSH
80654: LD_INT 12
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PPUSH
80661: CALL_OW 72
80665: NOT
80666: OR
80667: IFFALSE 80671
// continue ;
80669: GO 80625
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80671: LD_ADDR_VAR 0 5
80675: PUSH
80676: LD_EXP 60
80680: PUSH
80681: LD_VAR 0 2
80685: ARRAY
80686: PUSH
80687: LD_INT 1
80689: ARRAY
80690: PPUSH
80691: CALL_OW 255
80695: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80696: LD_VAR 0 5
80700: PPUSH
80701: LD_INT 2
80703: PPUSH
80704: CALL_OW 325
80708: IFFALSE 80961
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80710: LD_ADDR_VAR 0 4
80714: PUSH
80715: LD_EXP 60
80719: PUSH
80720: LD_VAR 0 2
80724: ARRAY
80725: PPUSH
80726: LD_INT 25
80728: PUSH
80729: LD_INT 16
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PPUSH
80736: CALL_OW 72
80740: ST_TO_ADDR
// if tmp < 6 then
80741: LD_VAR 0 4
80745: PUSH
80746: LD_INT 6
80748: LESS
80749: IFFALSE 80961
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80751: LD_ADDR_VAR 0 6
80755: PUSH
80756: LD_EXP 31
80760: PUSH
80761: LD_VAR 0 2
80765: ARRAY
80766: PPUSH
80767: LD_INT 2
80769: PUSH
80770: LD_INT 30
80772: PUSH
80773: LD_INT 0
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 30
80782: PUSH
80783: LD_INT 1
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: LIST
80794: PPUSH
80795: CALL_OW 72
80799: ST_TO_ADDR
// if depot then
80800: LD_VAR 0 6
80804: IFFALSE 80961
// begin selected := 0 ;
80806: LD_ADDR_VAR 0 7
80810: PUSH
80811: LD_INT 0
80813: ST_TO_ADDR
// for j in depot do
80814: LD_ADDR_VAR 0 3
80818: PUSH
80819: LD_VAR 0 6
80823: PUSH
80824: FOR_IN
80825: IFFALSE 80856
// begin if UnitsInside ( j ) < 6 then
80827: LD_VAR 0 3
80831: PPUSH
80832: CALL_OW 313
80836: PUSH
80837: LD_INT 6
80839: LESS
80840: IFFALSE 80854
// begin selected := j ;
80842: LD_ADDR_VAR 0 7
80846: PUSH
80847: LD_VAR 0 3
80851: ST_TO_ADDR
// break ;
80852: GO 80856
// end ; end ;
80854: GO 80824
80856: POP
80857: POP
// if selected then
80858: LD_VAR 0 7
80862: IFFALSE 80961
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80864: LD_ADDR_VAR 0 3
80868: PUSH
80869: LD_EXP 60
80873: PUSH
80874: LD_VAR 0 2
80878: ARRAY
80879: PPUSH
80880: LD_INT 25
80882: PUSH
80883: LD_INT 12
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PPUSH
80890: CALL_OW 72
80894: PUSH
80895: FOR_IN
80896: IFFALSE 80959
// if not HasTask ( j ) then
80898: LD_VAR 0 3
80902: PPUSH
80903: CALL_OW 314
80907: NOT
80908: IFFALSE 80957
// begin if not IsInUnit ( j ) then
80910: LD_VAR 0 3
80914: PPUSH
80915: CALL_OW 310
80919: NOT
80920: IFFALSE 80936
// ComEnterUnit ( j , selected ) ;
80922: LD_VAR 0 3
80926: PPUSH
80927: LD_VAR 0 7
80931: PPUSH
80932: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
80936: LD_VAR 0 3
80940: PPUSH
80941: LD_INT 16
80943: PPUSH
80944: CALL_OW 183
// AddComExitBuilding ( j ) ;
80948: LD_VAR 0 3
80952: PPUSH
80953: CALL_OW 182
// end ;
80957: GO 80895
80959: POP
80960: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
80961: LD_VAR 0 5
80965: PPUSH
80966: LD_INT 11
80968: PPUSH
80969: CALL_OW 325
80973: IFFALSE 81232
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80975: LD_ADDR_VAR 0 4
80979: PUSH
80980: LD_EXP 60
80984: PUSH
80985: LD_VAR 0 2
80989: ARRAY
80990: PPUSH
80991: LD_INT 25
80993: PUSH
80994: LD_INT 16
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PPUSH
81001: CALL_OW 72
81005: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81006: LD_VAR 0 4
81010: PUSH
81011: LD_INT 6
81013: GREATEREQUAL
81014: PUSH
81015: LD_VAR 0 5
81019: PPUSH
81020: LD_INT 2
81022: PPUSH
81023: CALL_OW 325
81027: NOT
81028: OR
81029: IFFALSE 81232
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81031: LD_ADDR_VAR 0 8
81035: PUSH
81036: LD_EXP 31
81040: PUSH
81041: LD_VAR 0 2
81045: ARRAY
81046: PPUSH
81047: LD_INT 2
81049: PUSH
81050: LD_INT 30
81052: PUSH
81053: LD_INT 4
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 30
81062: PUSH
81063: LD_INT 5
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: LIST
81074: PPUSH
81075: CALL_OW 72
81079: ST_TO_ADDR
// if barracks then
81080: LD_VAR 0 8
81084: IFFALSE 81232
// begin selected := 0 ;
81086: LD_ADDR_VAR 0 7
81090: PUSH
81091: LD_INT 0
81093: ST_TO_ADDR
// for j in barracks do
81094: LD_ADDR_VAR 0 3
81098: PUSH
81099: LD_VAR 0 8
81103: PUSH
81104: FOR_IN
81105: IFFALSE 81136
// begin if UnitsInside ( j ) < 6 then
81107: LD_VAR 0 3
81111: PPUSH
81112: CALL_OW 313
81116: PUSH
81117: LD_INT 6
81119: LESS
81120: IFFALSE 81134
// begin selected := j ;
81122: LD_ADDR_VAR 0 7
81126: PUSH
81127: LD_VAR 0 3
81131: ST_TO_ADDR
// break ;
81132: GO 81136
// end ; end ;
81134: GO 81104
81136: POP
81137: POP
// if selected then
81138: LD_VAR 0 7
81142: IFFALSE 81232
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81144: LD_ADDR_VAR 0 3
81148: PUSH
81149: LD_EXP 60
81153: PUSH
81154: LD_VAR 0 2
81158: ARRAY
81159: PPUSH
81160: LD_INT 25
81162: PUSH
81163: LD_INT 12
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PPUSH
81170: CALL_OW 72
81174: PUSH
81175: FOR_IN
81176: IFFALSE 81230
// if not IsInUnit ( j ) and not HasTask ( j ) then
81178: LD_VAR 0 3
81182: PPUSH
81183: CALL_OW 310
81187: NOT
81188: PUSH
81189: LD_VAR 0 3
81193: PPUSH
81194: CALL_OW 314
81198: NOT
81199: AND
81200: IFFALSE 81228
// begin ComEnterUnit ( j , selected ) ;
81202: LD_VAR 0 3
81206: PPUSH
81207: LD_VAR 0 7
81211: PPUSH
81212: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81216: LD_VAR 0 3
81220: PPUSH
81221: LD_INT 15
81223: PPUSH
81224: CALL_OW 183
// end ;
81228: GO 81175
81230: POP
81231: POP
// end ; end ; end ; end ; end ;
81232: GO 80625
81234: POP
81235: POP
// end ;
81236: LD_VAR 0 1
81240: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81241: LD_INT 0
81243: PPUSH
81244: PPUSH
81245: PPUSH
81246: PPUSH
// if not mc_bases then
81247: LD_EXP 31
81251: NOT
81252: IFFALSE 81256
// exit ;
81254: GO 81434
// for i = 1 to mc_bases do
81256: LD_ADDR_VAR 0 2
81260: PUSH
81261: DOUBLE
81262: LD_INT 1
81264: DEC
81265: ST_TO_ADDR
81266: LD_EXP 31
81270: PUSH
81271: FOR_TO
81272: IFFALSE 81432
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81274: LD_ADDR_VAR 0 4
81278: PUSH
81279: LD_EXP 31
81283: PUSH
81284: LD_VAR 0 2
81288: ARRAY
81289: PPUSH
81290: LD_INT 25
81292: PUSH
81293: LD_INT 9
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PPUSH
81300: CALL_OW 72
81304: ST_TO_ADDR
// if not tmp then
81305: LD_VAR 0 4
81309: NOT
81310: IFFALSE 81314
// continue ;
81312: GO 81271
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81314: LD_EXP 57
81318: PUSH
81319: LD_VAR 0 2
81323: ARRAY
81324: PPUSH
81325: LD_INT 29
81327: PPUSH
81328: CALL_OW 325
81332: NOT
81333: PUSH
81334: LD_EXP 57
81338: PUSH
81339: LD_VAR 0 2
81343: ARRAY
81344: PPUSH
81345: LD_INT 28
81347: PPUSH
81348: CALL_OW 325
81352: NOT
81353: AND
81354: IFFALSE 81358
// continue ;
81356: GO 81271
// for j in tmp do
81358: LD_ADDR_VAR 0 3
81362: PUSH
81363: LD_VAR 0 4
81367: PUSH
81368: FOR_IN
81369: IFFALSE 81428
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81371: LD_VAR 0 3
81375: PUSH
81376: LD_EXP 34
81380: PUSH
81381: LD_VAR 0 2
81385: ARRAY
81386: PUSH
81387: LD_INT 1
81389: ARRAY
81390: IN
81391: NOT
81392: PUSH
81393: LD_VAR 0 3
81397: PUSH
81398: LD_EXP 34
81402: PUSH
81403: LD_VAR 0 2
81407: ARRAY
81408: PUSH
81409: LD_INT 2
81411: ARRAY
81412: IN
81413: NOT
81414: AND
81415: IFFALSE 81426
// ComSpaceTimeShoot ( j ) ;
81417: LD_VAR 0 3
81421: PPUSH
81422: CALL 20831 0 1
81426: GO 81368
81428: POP
81429: POP
// end ;
81430: GO 81271
81432: POP
81433: POP
// end ;
81434: LD_VAR 0 1
81438: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81439: LD_INT 0
81441: PPUSH
81442: PPUSH
81443: PPUSH
81444: PPUSH
81445: PPUSH
81446: PPUSH
81447: PPUSH
81448: PPUSH
81449: PPUSH
// if not mc_bases then
81450: LD_EXP 31
81454: NOT
81455: IFFALSE 81459
// exit ;
81457: GO 82081
// for i = 1 to mc_bases do
81459: LD_ADDR_VAR 0 2
81463: PUSH
81464: DOUBLE
81465: LD_INT 1
81467: DEC
81468: ST_TO_ADDR
81469: LD_EXP 31
81473: PUSH
81474: FOR_TO
81475: IFFALSE 82079
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81477: LD_EXP 66
81481: PUSH
81482: LD_VAR 0 2
81486: ARRAY
81487: NOT
81488: PUSH
81489: LD_INT 38
81491: PPUSH
81492: LD_EXP 57
81496: PUSH
81497: LD_VAR 0 2
81501: ARRAY
81502: PPUSH
81503: CALL_OW 321
81507: PUSH
81508: LD_INT 2
81510: NONEQUAL
81511: OR
81512: IFFALSE 81516
// continue ;
81514: GO 81474
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81516: LD_ADDR_VAR 0 8
81520: PUSH
81521: LD_EXP 31
81525: PUSH
81526: LD_VAR 0 2
81530: ARRAY
81531: PPUSH
81532: LD_INT 30
81534: PUSH
81535: LD_INT 34
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PPUSH
81542: CALL_OW 72
81546: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81547: LD_ADDR_VAR 0 9
81551: PUSH
81552: LD_EXP 31
81556: PUSH
81557: LD_VAR 0 2
81561: ARRAY
81562: PPUSH
81563: LD_INT 25
81565: PUSH
81566: LD_INT 4
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PPUSH
81573: CALL_OW 72
81577: PPUSH
81578: LD_INT 0
81580: PPUSH
81581: CALL 54834 0 2
81585: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81586: LD_VAR 0 9
81590: NOT
81591: PUSH
81592: LD_VAR 0 8
81596: NOT
81597: OR
81598: PUSH
81599: LD_EXP 31
81603: PUSH
81604: LD_VAR 0 2
81608: ARRAY
81609: PPUSH
81610: LD_INT 124
81612: PPUSH
81613: CALL 54834 0 2
81617: OR
81618: IFFALSE 81622
// continue ;
81620: GO 81474
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81622: LD_EXP 67
81626: PUSH
81627: LD_VAR 0 2
81631: ARRAY
81632: PUSH
81633: LD_EXP 66
81637: PUSH
81638: LD_VAR 0 2
81642: ARRAY
81643: LESS
81644: PUSH
81645: LD_EXP 67
81649: PUSH
81650: LD_VAR 0 2
81654: ARRAY
81655: PUSH
81656: LD_VAR 0 8
81660: LESS
81661: AND
81662: IFFALSE 82077
// begin tmp := sci [ 1 ] ;
81664: LD_ADDR_VAR 0 7
81668: PUSH
81669: LD_VAR 0 9
81673: PUSH
81674: LD_INT 1
81676: ARRAY
81677: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81678: LD_VAR 0 7
81682: PPUSH
81683: LD_INT 124
81685: PPUSH
81686: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81690: LD_ADDR_VAR 0 3
81694: PUSH
81695: DOUBLE
81696: LD_EXP 66
81700: PUSH
81701: LD_VAR 0 2
81705: ARRAY
81706: INC
81707: ST_TO_ADDR
81708: LD_EXP 66
81712: PUSH
81713: LD_VAR 0 2
81717: ARRAY
81718: PUSH
81719: FOR_DOWNTO
81720: IFFALSE 82063
// begin if IsInUnit ( tmp ) then
81722: LD_VAR 0 7
81726: PPUSH
81727: CALL_OW 310
81731: IFFALSE 81742
// ComExitBuilding ( tmp ) ;
81733: LD_VAR 0 7
81737: PPUSH
81738: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81742: LD_INT 35
81744: PPUSH
81745: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81749: LD_VAR 0 7
81753: PPUSH
81754: CALL_OW 310
81758: NOT
81759: PUSH
81760: LD_VAR 0 7
81764: PPUSH
81765: CALL_OW 314
81769: NOT
81770: AND
81771: IFFALSE 81742
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81773: LD_ADDR_VAR 0 6
81777: PUSH
81778: LD_VAR 0 7
81782: PPUSH
81783: CALL_OW 250
81787: PUSH
81788: LD_VAR 0 7
81792: PPUSH
81793: CALL_OW 251
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
81802: LD_INT 35
81804: PPUSH
81805: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
81809: LD_ADDR_VAR 0 4
81813: PUSH
81814: LD_EXP 66
81818: PUSH
81819: LD_VAR 0 2
81823: ARRAY
81824: PUSH
81825: LD_VAR 0 3
81829: ARRAY
81830: PUSH
81831: LD_INT 1
81833: ARRAY
81834: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
81835: LD_ADDR_VAR 0 5
81839: PUSH
81840: LD_EXP 66
81844: PUSH
81845: LD_VAR 0 2
81849: ARRAY
81850: PUSH
81851: LD_VAR 0 3
81855: ARRAY
81856: PUSH
81857: LD_INT 2
81859: ARRAY
81860: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
81861: LD_VAR 0 7
81865: PPUSH
81866: LD_INT 10
81868: PPUSH
81869: CALL 27618 0 2
81873: PUSH
81874: LD_INT 4
81876: ARRAY
81877: IFFALSE 81915
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
81879: LD_VAR 0 7
81883: PPUSH
81884: LD_VAR 0 6
81888: PUSH
81889: LD_INT 1
81891: ARRAY
81892: PPUSH
81893: LD_VAR 0 6
81897: PUSH
81898: LD_INT 2
81900: ARRAY
81901: PPUSH
81902: CALL_OW 111
// wait ( 0 0$10 ) ;
81906: LD_INT 350
81908: PPUSH
81909: CALL_OW 67
// end else
81913: GO 81941
// begin ComMoveXY ( tmp , x , y ) ;
81915: LD_VAR 0 7
81919: PPUSH
81920: LD_VAR 0 4
81924: PPUSH
81925: LD_VAR 0 5
81929: PPUSH
81930: CALL_OW 111
// wait ( 0 0$3 ) ;
81934: LD_INT 105
81936: PPUSH
81937: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
81941: LD_VAR 0 7
81945: PPUSH
81946: LD_VAR 0 4
81950: PPUSH
81951: LD_VAR 0 5
81955: PPUSH
81956: CALL_OW 307
81960: IFFALSE 81802
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
81962: LD_VAR 0 7
81966: PPUSH
81967: LD_VAR 0 4
81971: PPUSH
81972: LD_VAR 0 5
81976: PPUSH
81977: LD_VAR 0 8
81981: PUSH
81982: LD_VAR 0 3
81986: ARRAY
81987: PPUSH
81988: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
81992: LD_INT 35
81994: PPUSH
81995: CALL_OW 67
// until not HasTask ( tmp ) ;
81999: LD_VAR 0 7
82003: PPUSH
82004: CALL_OW 314
82008: NOT
82009: IFFALSE 81992
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82011: LD_ADDR_EXP 67
82015: PUSH
82016: LD_EXP 67
82020: PPUSH
82021: LD_VAR 0 2
82025: PUSH
82026: LD_EXP 67
82030: PUSH
82031: LD_VAR 0 2
82035: ARRAY
82036: PUSH
82037: LD_INT 1
82039: PLUS
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PPUSH
82045: LD_VAR 0 8
82049: PUSH
82050: LD_VAR 0 3
82054: ARRAY
82055: PPUSH
82056: CALL 25021 0 3
82060: ST_TO_ADDR
// end ;
82061: GO 81719
82063: POP
82064: POP
// MC_Reset ( i , 124 ) ;
82065: LD_VAR 0 2
82069: PPUSH
82070: LD_INT 124
82072: PPUSH
82073: CALL 65223 0 2
// end ; end ;
82077: GO 81474
82079: POP
82080: POP
// end ;
82081: LD_VAR 0 1
82085: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82086: LD_INT 0
82088: PPUSH
82089: PPUSH
82090: PPUSH
// if not mc_bases then
82091: LD_EXP 31
82095: NOT
82096: IFFALSE 82100
// exit ;
82098: GO 82706
// for i = 1 to mc_bases do
82100: LD_ADDR_VAR 0 2
82104: PUSH
82105: DOUBLE
82106: LD_INT 1
82108: DEC
82109: ST_TO_ADDR
82110: LD_EXP 31
82114: PUSH
82115: FOR_TO
82116: IFFALSE 82704
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82118: LD_ADDR_VAR 0 3
82122: PUSH
82123: LD_EXP 31
82127: PUSH
82128: LD_VAR 0 2
82132: ARRAY
82133: PPUSH
82134: LD_INT 25
82136: PUSH
82137: LD_INT 4
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PPUSH
82144: CALL_OW 72
82148: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82149: LD_VAR 0 3
82153: NOT
82154: PUSH
82155: LD_EXP 68
82159: PUSH
82160: LD_VAR 0 2
82164: ARRAY
82165: NOT
82166: OR
82167: PUSH
82168: LD_EXP 31
82172: PUSH
82173: LD_VAR 0 2
82177: ARRAY
82178: PPUSH
82179: LD_INT 2
82181: PUSH
82182: LD_INT 30
82184: PUSH
82185: LD_INT 0
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 30
82194: PUSH
82195: LD_INT 1
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: LIST
82206: PPUSH
82207: CALL_OW 72
82211: NOT
82212: OR
82213: IFFALSE 82263
// begin if mc_deposits_finder [ i ] then
82215: LD_EXP 69
82219: PUSH
82220: LD_VAR 0 2
82224: ARRAY
82225: IFFALSE 82261
// begin MC_Reset ( i , 125 ) ;
82227: LD_VAR 0 2
82231: PPUSH
82232: LD_INT 125
82234: PPUSH
82235: CALL 65223 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82239: LD_ADDR_EXP 69
82243: PUSH
82244: LD_EXP 69
82248: PPUSH
82249: LD_VAR 0 2
82253: PPUSH
82254: EMPTY
82255: PPUSH
82256: CALL_OW 1
82260: ST_TO_ADDR
// end ; continue ;
82261: GO 82115
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82263: LD_EXP 68
82267: PUSH
82268: LD_VAR 0 2
82272: ARRAY
82273: PUSH
82274: LD_INT 1
82276: ARRAY
82277: PUSH
82278: LD_INT 3
82280: ARRAY
82281: PUSH
82282: LD_INT 1
82284: EQUAL
82285: PUSH
82286: LD_INT 20
82288: PPUSH
82289: LD_EXP 57
82293: PUSH
82294: LD_VAR 0 2
82298: ARRAY
82299: PPUSH
82300: CALL_OW 321
82304: PUSH
82305: LD_INT 2
82307: NONEQUAL
82308: AND
82309: IFFALSE 82359
// begin if mc_deposits_finder [ i ] then
82311: LD_EXP 69
82315: PUSH
82316: LD_VAR 0 2
82320: ARRAY
82321: IFFALSE 82357
// begin MC_Reset ( i , 125 ) ;
82323: LD_VAR 0 2
82327: PPUSH
82328: LD_INT 125
82330: PPUSH
82331: CALL 65223 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82335: LD_ADDR_EXP 69
82339: PUSH
82340: LD_EXP 69
82344: PPUSH
82345: LD_VAR 0 2
82349: PPUSH
82350: EMPTY
82351: PPUSH
82352: CALL_OW 1
82356: ST_TO_ADDR
// end ; continue ;
82357: GO 82115
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82359: LD_EXP 68
82363: PUSH
82364: LD_VAR 0 2
82368: ARRAY
82369: PUSH
82370: LD_INT 1
82372: ARRAY
82373: PUSH
82374: LD_INT 1
82376: ARRAY
82377: PPUSH
82378: LD_EXP 68
82382: PUSH
82383: LD_VAR 0 2
82387: ARRAY
82388: PUSH
82389: LD_INT 1
82391: ARRAY
82392: PUSH
82393: LD_INT 2
82395: ARRAY
82396: PPUSH
82397: LD_EXP 57
82401: PUSH
82402: LD_VAR 0 2
82406: ARRAY
82407: PPUSH
82408: CALL_OW 440
82412: IFFALSE 82455
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82414: LD_ADDR_EXP 68
82418: PUSH
82419: LD_EXP 68
82423: PPUSH
82424: LD_VAR 0 2
82428: PPUSH
82429: LD_EXP 68
82433: PUSH
82434: LD_VAR 0 2
82438: ARRAY
82439: PPUSH
82440: LD_INT 1
82442: PPUSH
82443: CALL_OW 3
82447: PPUSH
82448: CALL_OW 1
82452: ST_TO_ADDR
82453: GO 82702
// begin if not mc_deposits_finder [ i ] then
82455: LD_EXP 69
82459: PUSH
82460: LD_VAR 0 2
82464: ARRAY
82465: NOT
82466: IFFALSE 82518
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82468: LD_ADDR_EXP 69
82472: PUSH
82473: LD_EXP 69
82477: PPUSH
82478: LD_VAR 0 2
82482: PPUSH
82483: LD_VAR 0 3
82487: PUSH
82488: LD_INT 1
82490: ARRAY
82491: PUSH
82492: EMPTY
82493: LIST
82494: PPUSH
82495: CALL_OW 1
82499: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82500: LD_VAR 0 3
82504: PUSH
82505: LD_INT 1
82507: ARRAY
82508: PPUSH
82509: LD_INT 125
82511: PPUSH
82512: CALL_OW 109
// end else
82516: GO 82702
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82518: LD_EXP 69
82522: PUSH
82523: LD_VAR 0 2
82527: ARRAY
82528: PUSH
82529: LD_INT 1
82531: ARRAY
82532: PPUSH
82533: CALL_OW 310
82537: IFFALSE 82560
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82539: LD_EXP 69
82543: PUSH
82544: LD_VAR 0 2
82548: ARRAY
82549: PUSH
82550: LD_INT 1
82552: ARRAY
82553: PPUSH
82554: CALL_OW 122
82558: GO 82702
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82560: LD_EXP 69
82564: PUSH
82565: LD_VAR 0 2
82569: ARRAY
82570: PUSH
82571: LD_INT 1
82573: ARRAY
82574: PPUSH
82575: CALL_OW 314
82579: NOT
82580: PUSH
82581: LD_EXP 69
82585: PUSH
82586: LD_VAR 0 2
82590: ARRAY
82591: PUSH
82592: LD_INT 1
82594: ARRAY
82595: PPUSH
82596: LD_EXP 68
82600: PUSH
82601: LD_VAR 0 2
82605: ARRAY
82606: PUSH
82607: LD_INT 1
82609: ARRAY
82610: PUSH
82611: LD_INT 1
82613: ARRAY
82614: PPUSH
82615: LD_EXP 68
82619: PUSH
82620: LD_VAR 0 2
82624: ARRAY
82625: PUSH
82626: LD_INT 1
82628: ARRAY
82629: PUSH
82630: LD_INT 2
82632: ARRAY
82633: PPUSH
82634: CALL_OW 297
82638: PUSH
82639: LD_INT 6
82641: GREATER
82642: AND
82643: IFFALSE 82702
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82645: LD_EXP 69
82649: PUSH
82650: LD_VAR 0 2
82654: ARRAY
82655: PUSH
82656: LD_INT 1
82658: ARRAY
82659: PPUSH
82660: LD_EXP 68
82664: PUSH
82665: LD_VAR 0 2
82669: ARRAY
82670: PUSH
82671: LD_INT 1
82673: ARRAY
82674: PUSH
82675: LD_INT 1
82677: ARRAY
82678: PPUSH
82679: LD_EXP 68
82683: PUSH
82684: LD_VAR 0 2
82688: ARRAY
82689: PUSH
82690: LD_INT 1
82692: ARRAY
82693: PUSH
82694: LD_INT 2
82696: ARRAY
82697: PPUSH
82698: CALL_OW 111
// end ; end ; end ;
82702: GO 82115
82704: POP
82705: POP
// end ;
82706: LD_VAR 0 1
82710: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82711: LD_INT 0
82713: PPUSH
82714: PPUSH
82715: PPUSH
82716: PPUSH
82717: PPUSH
82718: PPUSH
82719: PPUSH
82720: PPUSH
82721: PPUSH
82722: PPUSH
82723: PPUSH
// if not mc_bases then
82724: LD_EXP 31
82728: NOT
82729: IFFALSE 82733
// exit ;
82731: GO 83673
// for i = 1 to mc_bases do
82733: LD_ADDR_VAR 0 2
82737: PUSH
82738: DOUBLE
82739: LD_INT 1
82741: DEC
82742: ST_TO_ADDR
82743: LD_EXP 31
82747: PUSH
82748: FOR_TO
82749: IFFALSE 83671
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82751: LD_EXP 31
82755: PUSH
82756: LD_VAR 0 2
82760: ARRAY
82761: NOT
82762: PUSH
82763: LD_EXP 54
82767: PUSH
82768: LD_VAR 0 2
82772: ARRAY
82773: OR
82774: IFFALSE 82778
// continue ;
82776: GO 82748
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
82778: LD_ADDR_VAR 0 7
82782: PUSH
82783: LD_EXP 31
82787: PUSH
82788: LD_VAR 0 2
82792: ARRAY
82793: PUSH
82794: LD_INT 1
82796: ARRAY
82797: PPUSH
82798: CALL_OW 248
82802: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
82803: LD_VAR 0 7
82807: PUSH
82808: LD_INT 3
82810: EQUAL
82811: PUSH
82812: LD_EXP 50
82816: PUSH
82817: LD_VAR 0 2
82821: ARRAY
82822: PUSH
82823: LD_EXP 53
82827: PUSH
82828: LD_VAR 0 2
82832: ARRAY
82833: UNION
82834: PPUSH
82835: LD_INT 33
82837: PUSH
82838: LD_INT 2
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PPUSH
82845: CALL_OW 72
82849: NOT
82850: OR
82851: IFFALSE 82855
// continue ;
82853: GO 82748
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
82855: LD_ADDR_VAR 0 9
82859: PUSH
82860: LD_EXP 31
82864: PUSH
82865: LD_VAR 0 2
82869: ARRAY
82870: PPUSH
82871: LD_INT 30
82873: PUSH
82874: LD_INT 36
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PPUSH
82881: CALL_OW 72
82885: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
82886: LD_ADDR_VAR 0 10
82890: PUSH
82891: LD_EXP 50
82895: PUSH
82896: LD_VAR 0 2
82900: ARRAY
82901: PPUSH
82902: LD_INT 34
82904: PUSH
82905: LD_INT 31
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PPUSH
82912: CALL_OW 72
82916: ST_TO_ADDR
// if not cts and not mcts then
82917: LD_VAR 0 9
82921: NOT
82922: PUSH
82923: LD_VAR 0 10
82927: NOT
82928: AND
82929: IFFALSE 82933
// continue ;
82931: GO 82748
// x := cts ;
82933: LD_ADDR_VAR 0 11
82937: PUSH
82938: LD_VAR 0 9
82942: ST_TO_ADDR
// if not x then
82943: LD_VAR 0 11
82947: NOT
82948: IFFALSE 82960
// x := mcts ;
82950: LD_ADDR_VAR 0 11
82954: PUSH
82955: LD_VAR 0 10
82959: ST_TO_ADDR
// if not x then
82960: LD_VAR 0 11
82964: NOT
82965: IFFALSE 82969
// continue ;
82967: GO 82748
// if mc_remote_driver [ i ] then
82969: LD_EXP 71
82973: PUSH
82974: LD_VAR 0 2
82978: ARRAY
82979: IFFALSE 83366
// for j in mc_remote_driver [ i ] do
82981: LD_ADDR_VAR 0 3
82985: PUSH
82986: LD_EXP 71
82990: PUSH
82991: LD_VAR 0 2
82995: ARRAY
82996: PUSH
82997: FOR_IN
82998: IFFALSE 83364
// begin if GetClass ( j ) <> 3 then
83000: LD_VAR 0 3
83004: PPUSH
83005: CALL_OW 257
83009: PUSH
83010: LD_INT 3
83012: NONEQUAL
83013: IFFALSE 83066
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83015: LD_ADDR_EXP 71
83019: PUSH
83020: LD_EXP 71
83024: PPUSH
83025: LD_VAR 0 2
83029: PPUSH
83030: LD_EXP 71
83034: PUSH
83035: LD_VAR 0 2
83039: ARRAY
83040: PUSH
83041: LD_VAR 0 3
83045: DIFF
83046: PPUSH
83047: CALL_OW 1
83051: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83052: LD_VAR 0 3
83056: PPUSH
83057: LD_INT 0
83059: PPUSH
83060: CALL_OW 109
// continue ;
83064: GO 82997
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83066: LD_EXP 50
83070: PUSH
83071: LD_VAR 0 2
83075: ARRAY
83076: PPUSH
83077: LD_INT 34
83079: PUSH
83080: LD_INT 31
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 58
83089: PUSH
83090: EMPTY
83091: LIST
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PPUSH
83097: CALL_OW 72
83101: PUSH
83102: LD_VAR 0 3
83106: PPUSH
83107: CALL 54869 0 1
83111: NOT
83112: AND
83113: IFFALSE 83184
// begin if IsInUnit ( j ) then
83115: LD_VAR 0 3
83119: PPUSH
83120: CALL_OW 310
83124: IFFALSE 83135
// ComExitBuilding ( j ) ;
83126: LD_VAR 0 3
83130: PPUSH
83131: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83135: LD_VAR 0 3
83139: PPUSH
83140: LD_EXP 50
83144: PUSH
83145: LD_VAR 0 2
83149: ARRAY
83150: PPUSH
83151: LD_INT 34
83153: PUSH
83154: LD_INT 31
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 58
83163: PUSH
83164: EMPTY
83165: LIST
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PPUSH
83171: CALL_OW 72
83175: PUSH
83176: LD_INT 1
83178: ARRAY
83179: PPUSH
83180: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83184: LD_VAR 0 3
83188: PPUSH
83189: CALL_OW 310
83193: NOT
83194: PUSH
83195: LD_VAR 0 3
83199: PPUSH
83200: CALL_OW 310
83204: PPUSH
83205: CALL_OW 266
83209: PUSH
83210: LD_INT 36
83212: NONEQUAL
83213: PUSH
83214: LD_VAR 0 3
83218: PPUSH
83219: CALL 54869 0 1
83223: NOT
83224: AND
83225: OR
83226: IFFALSE 83362
// begin if IsInUnit ( j ) then
83228: LD_VAR 0 3
83232: PPUSH
83233: CALL_OW 310
83237: IFFALSE 83248
// ComExitBuilding ( j ) ;
83239: LD_VAR 0 3
83243: PPUSH
83244: CALL_OW 122
// ct := 0 ;
83248: LD_ADDR_VAR 0 8
83252: PUSH
83253: LD_INT 0
83255: ST_TO_ADDR
// for k in x do
83256: LD_ADDR_VAR 0 4
83260: PUSH
83261: LD_VAR 0 11
83265: PUSH
83266: FOR_IN
83267: IFFALSE 83340
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83269: LD_VAR 0 4
83273: PPUSH
83274: CALL_OW 264
83278: PUSH
83279: LD_INT 31
83281: EQUAL
83282: PUSH
83283: LD_VAR 0 4
83287: PPUSH
83288: CALL_OW 311
83292: NOT
83293: AND
83294: PUSH
83295: LD_VAR 0 4
83299: PPUSH
83300: CALL_OW 266
83304: PUSH
83305: LD_INT 36
83307: EQUAL
83308: PUSH
83309: LD_VAR 0 4
83313: PPUSH
83314: CALL_OW 313
83318: PUSH
83319: LD_INT 3
83321: LESS
83322: AND
83323: OR
83324: IFFALSE 83338
// begin ct := k ;
83326: LD_ADDR_VAR 0 8
83330: PUSH
83331: LD_VAR 0 4
83335: ST_TO_ADDR
// break ;
83336: GO 83340
// end ;
83338: GO 83266
83340: POP
83341: POP
// if ct then
83342: LD_VAR 0 8
83346: IFFALSE 83362
// ComEnterUnit ( j , ct ) ;
83348: LD_VAR 0 3
83352: PPUSH
83353: LD_VAR 0 8
83357: PPUSH
83358: CALL_OW 120
// end ; end ;
83362: GO 82997
83364: POP
83365: POP
// places := 0 ;
83366: LD_ADDR_VAR 0 5
83370: PUSH
83371: LD_INT 0
83373: ST_TO_ADDR
// for j = 1 to x do
83374: LD_ADDR_VAR 0 3
83378: PUSH
83379: DOUBLE
83380: LD_INT 1
83382: DEC
83383: ST_TO_ADDR
83384: LD_VAR 0 11
83388: PUSH
83389: FOR_TO
83390: IFFALSE 83466
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83392: LD_VAR 0 11
83396: PUSH
83397: LD_VAR 0 3
83401: ARRAY
83402: PPUSH
83403: CALL_OW 264
83407: PUSH
83408: LD_INT 31
83410: EQUAL
83411: IFFALSE 83429
// places := places + 1 else
83413: LD_ADDR_VAR 0 5
83417: PUSH
83418: LD_VAR 0 5
83422: PUSH
83423: LD_INT 1
83425: PLUS
83426: ST_TO_ADDR
83427: GO 83464
// if GetBType ( x [ j ] ) = b_control_tower then
83429: LD_VAR 0 11
83433: PUSH
83434: LD_VAR 0 3
83438: ARRAY
83439: PPUSH
83440: CALL_OW 266
83444: PUSH
83445: LD_INT 36
83447: EQUAL
83448: IFFALSE 83464
// places := places + 3 ;
83450: LD_ADDR_VAR 0 5
83454: PUSH
83455: LD_VAR 0 5
83459: PUSH
83460: LD_INT 3
83462: PLUS
83463: ST_TO_ADDR
83464: GO 83389
83466: POP
83467: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83468: LD_VAR 0 5
83472: PUSH
83473: LD_INT 0
83475: EQUAL
83476: PUSH
83477: LD_VAR 0 5
83481: PUSH
83482: LD_EXP 71
83486: PUSH
83487: LD_VAR 0 2
83491: ARRAY
83492: LESSEQUAL
83493: OR
83494: IFFALSE 83498
// continue ;
83496: GO 82748
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83498: LD_ADDR_VAR 0 6
83502: PUSH
83503: LD_EXP 31
83507: PUSH
83508: LD_VAR 0 2
83512: ARRAY
83513: PPUSH
83514: LD_INT 25
83516: PUSH
83517: LD_INT 3
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PPUSH
83524: CALL_OW 72
83528: PUSH
83529: LD_EXP 71
83533: PUSH
83534: LD_VAR 0 2
83538: ARRAY
83539: DIFF
83540: PPUSH
83541: LD_INT 3
83543: PPUSH
83544: CALL 55769 0 2
83548: ST_TO_ADDR
// for j in tmp do
83549: LD_ADDR_VAR 0 3
83553: PUSH
83554: LD_VAR 0 6
83558: PUSH
83559: FOR_IN
83560: IFFALSE 83595
// if GetTag ( j ) > 0 then
83562: LD_VAR 0 3
83566: PPUSH
83567: CALL_OW 110
83571: PUSH
83572: LD_INT 0
83574: GREATER
83575: IFFALSE 83593
// tmp := tmp diff j ;
83577: LD_ADDR_VAR 0 6
83581: PUSH
83582: LD_VAR 0 6
83586: PUSH
83587: LD_VAR 0 3
83591: DIFF
83592: ST_TO_ADDR
83593: GO 83559
83595: POP
83596: POP
// if not tmp then
83597: LD_VAR 0 6
83601: NOT
83602: IFFALSE 83606
// continue ;
83604: GO 82748
// if places then
83606: LD_VAR 0 5
83610: IFFALSE 83669
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83612: LD_ADDR_EXP 71
83616: PUSH
83617: LD_EXP 71
83621: PPUSH
83622: LD_VAR 0 2
83626: PPUSH
83627: LD_EXP 71
83631: PUSH
83632: LD_VAR 0 2
83636: ARRAY
83637: PUSH
83638: LD_VAR 0 6
83642: PUSH
83643: LD_INT 1
83645: ARRAY
83646: UNION
83647: PPUSH
83648: CALL_OW 1
83652: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83653: LD_VAR 0 6
83657: PUSH
83658: LD_INT 1
83660: ARRAY
83661: PPUSH
83662: LD_INT 126
83664: PPUSH
83665: CALL_OW 109
// end ; end ;
83669: GO 82748
83671: POP
83672: POP
// end ;
83673: LD_VAR 0 1
83677: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83678: LD_INT 0
83680: PPUSH
83681: PPUSH
83682: PPUSH
83683: PPUSH
83684: PPUSH
83685: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83686: LD_VAR 0 1
83690: NOT
83691: PUSH
83692: LD_VAR 0 2
83696: NOT
83697: OR
83698: PUSH
83699: LD_VAR 0 3
83703: NOT
83704: OR
83705: PUSH
83706: LD_VAR 0 4
83710: PUSH
83711: LD_INT 1
83713: PUSH
83714: LD_INT 2
83716: PUSH
83717: LD_INT 3
83719: PUSH
83720: LD_INT 4
83722: PUSH
83723: LD_INT 5
83725: PUSH
83726: LD_INT 8
83728: PUSH
83729: LD_INT 9
83731: PUSH
83732: LD_INT 15
83734: PUSH
83735: LD_INT 16
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: IN
83749: NOT
83750: OR
83751: IFFALSE 83755
// exit ;
83753: GO 84655
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83755: LD_ADDR_VAR 0 2
83759: PUSH
83760: LD_VAR 0 2
83764: PPUSH
83765: LD_INT 21
83767: PUSH
83768: LD_INT 3
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PUSH
83775: LD_INT 24
83777: PUSH
83778: LD_INT 250
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PPUSH
83789: CALL_OW 72
83793: ST_TO_ADDR
// case class of 1 , 15 :
83794: LD_VAR 0 4
83798: PUSH
83799: LD_INT 1
83801: DOUBLE
83802: EQUAL
83803: IFTRUE 83813
83805: LD_INT 15
83807: DOUBLE
83808: EQUAL
83809: IFTRUE 83813
83811: GO 83898
83813: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
83814: LD_ADDR_VAR 0 8
83818: PUSH
83819: LD_VAR 0 2
83823: PPUSH
83824: LD_INT 2
83826: PUSH
83827: LD_INT 30
83829: PUSH
83830: LD_INT 32
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 30
83839: PUSH
83840: LD_INT 31
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: LIST
83851: PPUSH
83852: CALL_OW 72
83856: PUSH
83857: LD_VAR 0 2
83861: PPUSH
83862: LD_INT 2
83864: PUSH
83865: LD_INT 30
83867: PUSH
83868: LD_INT 4
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 30
83877: PUSH
83878: LD_INT 5
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: LIST
83889: PPUSH
83890: CALL_OW 72
83894: ADD
83895: ST_TO_ADDR
83896: GO 84144
83898: LD_INT 2
83900: DOUBLE
83901: EQUAL
83902: IFTRUE 83912
83904: LD_INT 16
83906: DOUBLE
83907: EQUAL
83908: IFTRUE 83912
83910: GO 83958
83912: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
83913: LD_ADDR_VAR 0 8
83917: PUSH
83918: LD_VAR 0 2
83922: PPUSH
83923: LD_INT 2
83925: PUSH
83926: LD_INT 30
83928: PUSH
83929: LD_INT 0
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 30
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: LIST
83950: PPUSH
83951: CALL_OW 72
83955: ST_TO_ADDR
83956: GO 84144
83958: LD_INT 3
83960: DOUBLE
83961: EQUAL
83962: IFTRUE 83966
83964: GO 84012
83966: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
83967: LD_ADDR_VAR 0 8
83971: PUSH
83972: LD_VAR 0 2
83976: PPUSH
83977: LD_INT 2
83979: PUSH
83980: LD_INT 30
83982: PUSH
83983: LD_INT 2
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 30
83992: PUSH
83993: LD_INT 3
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: LIST
84004: PPUSH
84005: CALL_OW 72
84009: ST_TO_ADDR
84010: GO 84144
84012: LD_INT 4
84014: DOUBLE
84015: EQUAL
84016: IFTRUE 84020
84018: GO 84077
84020: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84021: LD_ADDR_VAR 0 8
84025: PUSH
84026: LD_VAR 0 2
84030: PPUSH
84031: LD_INT 2
84033: PUSH
84034: LD_INT 30
84036: PUSH
84037: LD_INT 6
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 30
84046: PUSH
84047: LD_INT 7
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 30
84056: PUSH
84057: LD_INT 8
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: PPUSH
84070: CALL_OW 72
84074: ST_TO_ADDR
84075: GO 84144
84077: LD_INT 5
84079: DOUBLE
84080: EQUAL
84081: IFTRUE 84097
84083: LD_INT 8
84085: DOUBLE
84086: EQUAL
84087: IFTRUE 84097
84089: LD_INT 9
84091: DOUBLE
84092: EQUAL
84093: IFTRUE 84097
84095: GO 84143
84097: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84098: LD_ADDR_VAR 0 8
84102: PUSH
84103: LD_VAR 0 2
84107: PPUSH
84108: LD_INT 2
84110: PUSH
84111: LD_INT 30
84113: PUSH
84114: LD_INT 4
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 30
84123: PUSH
84124: LD_INT 5
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: LIST
84135: PPUSH
84136: CALL_OW 72
84140: ST_TO_ADDR
84141: GO 84144
84143: POP
// if not tmp then
84144: LD_VAR 0 8
84148: NOT
84149: IFFALSE 84153
// exit ;
84151: GO 84655
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84153: LD_VAR 0 4
84157: PUSH
84158: LD_INT 1
84160: PUSH
84161: LD_INT 15
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: IN
84168: PUSH
84169: LD_EXP 40
84173: PUSH
84174: LD_VAR 0 1
84178: ARRAY
84179: AND
84180: IFFALSE 84336
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84182: LD_ADDR_VAR 0 9
84186: PUSH
84187: LD_EXP 40
84191: PUSH
84192: LD_VAR 0 1
84196: ARRAY
84197: PUSH
84198: LD_INT 1
84200: ARRAY
84201: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84202: LD_VAR 0 9
84206: PUSH
84207: LD_EXP 41
84211: PUSH
84212: LD_VAR 0 1
84216: ARRAY
84217: IN
84218: NOT
84219: IFFALSE 84334
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84221: LD_ADDR_EXP 41
84225: PUSH
84226: LD_EXP 41
84230: PPUSH
84231: LD_VAR 0 1
84235: PUSH
84236: LD_EXP 41
84240: PUSH
84241: LD_VAR 0 1
84245: ARRAY
84246: PUSH
84247: LD_INT 1
84249: PLUS
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PPUSH
84255: LD_VAR 0 9
84259: PPUSH
84260: CALL 25021 0 3
84264: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84265: LD_ADDR_EXP 40
84269: PUSH
84270: LD_EXP 40
84274: PPUSH
84275: LD_VAR 0 1
84279: PPUSH
84280: LD_EXP 40
84284: PUSH
84285: LD_VAR 0 1
84289: ARRAY
84290: PUSH
84291: LD_VAR 0 9
84295: DIFF
84296: PPUSH
84297: CALL_OW 1
84301: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84302: LD_VAR 0 3
84306: PPUSH
84307: LD_EXP 41
84311: PUSH
84312: LD_VAR 0 1
84316: ARRAY
84317: PUSH
84318: LD_EXP 41
84322: PUSH
84323: LD_VAR 0 1
84327: ARRAY
84328: ARRAY
84329: PPUSH
84330: CALL_OW 120
// end ; exit ;
84334: GO 84655
// end ; if tmp > 1 then
84336: LD_VAR 0 8
84340: PUSH
84341: LD_INT 1
84343: GREATER
84344: IFFALSE 84448
// for i = 2 to tmp do
84346: LD_ADDR_VAR 0 6
84350: PUSH
84351: DOUBLE
84352: LD_INT 2
84354: DEC
84355: ST_TO_ADDR
84356: LD_VAR 0 8
84360: PUSH
84361: FOR_TO
84362: IFFALSE 84446
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84364: LD_VAR 0 8
84368: PUSH
84369: LD_VAR 0 6
84373: ARRAY
84374: PPUSH
84375: CALL_OW 461
84379: PUSH
84380: LD_INT 6
84382: EQUAL
84383: IFFALSE 84444
// begin x := tmp [ i ] ;
84385: LD_ADDR_VAR 0 9
84389: PUSH
84390: LD_VAR 0 8
84394: PUSH
84395: LD_VAR 0 6
84399: ARRAY
84400: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84401: LD_ADDR_VAR 0 8
84405: PUSH
84406: LD_VAR 0 8
84410: PPUSH
84411: LD_VAR 0 6
84415: PPUSH
84416: CALL_OW 3
84420: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84421: LD_ADDR_VAR 0 8
84425: PUSH
84426: LD_VAR 0 8
84430: PPUSH
84431: LD_INT 1
84433: PPUSH
84434: LD_VAR 0 9
84438: PPUSH
84439: CALL_OW 2
84443: ST_TO_ADDR
// end ;
84444: GO 84361
84446: POP
84447: POP
// for i in tmp do
84448: LD_ADDR_VAR 0 6
84452: PUSH
84453: LD_VAR 0 8
84457: PUSH
84458: FOR_IN
84459: IFFALSE 84528
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84461: LD_VAR 0 6
84465: PPUSH
84466: CALL_OW 313
84470: PUSH
84471: LD_INT 6
84473: LESS
84474: PUSH
84475: LD_VAR 0 6
84479: PPUSH
84480: CALL_OW 266
84484: PUSH
84485: LD_INT 31
84487: PUSH
84488: LD_INT 32
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: IN
84495: NOT
84496: AND
84497: PUSH
84498: LD_VAR 0 6
84502: PPUSH
84503: CALL_OW 313
84507: PUSH
84508: LD_INT 0
84510: EQUAL
84511: OR
84512: IFFALSE 84526
// begin j := i ;
84514: LD_ADDR_VAR 0 7
84518: PUSH
84519: LD_VAR 0 6
84523: ST_TO_ADDR
// break ;
84524: GO 84528
// end ; end ;
84526: GO 84458
84528: POP
84529: POP
// if j then
84530: LD_VAR 0 7
84534: IFFALSE 84552
// ComEnterUnit ( unit , j ) else
84536: LD_VAR 0 3
84540: PPUSH
84541: LD_VAR 0 7
84545: PPUSH
84546: CALL_OW 120
84550: GO 84655
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84552: LD_ADDR_VAR 0 10
84556: PUSH
84557: LD_VAR 0 2
84561: PPUSH
84562: LD_INT 2
84564: PUSH
84565: LD_INT 30
84567: PUSH
84568: LD_INT 0
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 30
84577: PUSH
84578: LD_INT 1
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: LIST
84589: PPUSH
84590: CALL_OW 72
84594: ST_TO_ADDR
// if depot then
84595: LD_VAR 0 10
84599: IFFALSE 84655
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84601: LD_ADDR_VAR 0 10
84605: PUSH
84606: LD_VAR 0 10
84610: PPUSH
84611: LD_VAR 0 3
84615: PPUSH
84616: CALL_OW 74
84620: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84621: LD_VAR 0 3
84625: PPUSH
84626: LD_VAR 0 10
84630: PPUSH
84631: CALL_OW 296
84635: PUSH
84636: LD_INT 10
84638: GREATER
84639: IFFALSE 84655
// ComStandNearbyBuilding ( unit , depot ) ;
84641: LD_VAR 0 3
84645: PPUSH
84646: LD_VAR 0 10
84650: PPUSH
84651: CALL 21448 0 2
// end ; end ; end ;
84655: LD_VAR 0 5
84659: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84660: LD_INT 0
84662: PPUSH
84663: PPUSH
84664: PPUSH
84665: PPUSH
// if not mc_bases then
84666: LD_EXP 31
84670: NOT
84671: IFFALSE 84675
// exit ;
84673: GO 84914
// for i = 1 to mc_bases do
84675: LD_ADDR_VAR 0 2
84679: PUSH
84680: DOUBLE
84681: LD_INT 1
84683: DEC
84684: ST_TO_ADDR
84685: LD_EXP 31
84689: PUSH
84690: FOR_TO
84691: IFFALSE 84912
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84693: LD_ADDR_VAR 0 4
84697: PUSH
84698: LD_EXP 31
84702: PUSH
84703: LD_VAR 0 2
84707: ARRAY
84708: PPUSH
84709: LD_INT 21
84711: PUSH
84712: LD_INT 1
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PPUSH
84719: CALL_OW 72
84723: PUSH
84724: LD_EXP 60
84728: PUSH
84729: LD_VAR 0 2
84733: ARRAY
84734: UNION
84735: ST_TO_ADDR
// if not tmp then
84736: LD_VAR 0 4
84740: NOT
84741: IFFALSE 84745
// continue ;
84743: GO 84690
// for j in tmp do
84745: LD_ADDR_VAR 0 3
84749: PUSH
84750: LD_VAR 0 4
84754: PUSH
84755: FOR_IN
84756: IFFALSE 84908
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84758: LD_VAR 0 3
84762: PPUSH
84763: CALL_OW 110
84767: NOT
84768: PUSH
84769: LD_VAR 0 3
84773: PPUSH
84774: CALL_OW 314
84778: NOT
84779: AND
84780: PUSH
84781: LD_VAR 0 3
84785: PPUSH
84786: CALL_OW 311
84790: NOT
84791: AND
84792: PUSH
84793: LD_VAR 0 3
84797: PPUSH
84798: CALL_OW 310
84802: NOT
84803: AND
84804: PUSH
84805: LD_VAR 0 3
84809: PUSH
84810: LD_EXP 34
84814: PUSH
84815: LD_VAR 0 2
84819: ARRAY
84820: PUSH
84821: LD_INT 1
84823: ARRAY
84824: IN
84825: NOT
84826: AND
84827: PUSH
84828: LD_VAR 0 3
84832: PUSH
84833: LD_EXP 34
84837: PUSH
84838: LD_VAR 0 2
84842: ARRAY
84843: PUSH
84844: LD_INT 2
84846: ARRAY
84847: IN
84848: NOT
84849: AND
84850: PUSH
84851: LD_VAR 0 3
84855: PUSH
84856: LD_EXP 43
84860: PUSH
84861: LD_VAR 0 2
84865: ARRAY
84866: IN
84867: NOT
84868: AND
84869: IFFALSE 84906
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
84871: LD_VAR 0 2
84875: PPUSH
84876: LD_EXP 31
84880: PUSH
84881: LD_VAR 0 2
84885: ARRAY
84886: PPUSH
84887: LD_VAR 0 3
84891: PPUSH
84892: LD_VAR 0 3
84896: PPUSH
84897: CALL_OW 257
84901: PPUSH
84902: CALL 83678 0 4
// end ;
84906: GO 84755
84908: POP
84909: POP
// end ;
84910: GO 84690
84912: POP
84913: POP
// end ;
84914: LD_VAR 0 1
84918: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
84919: LD_INT 0
84921: PPUSH
84922: PPUSH
84923: PPUSH
84924: PPUSH
84925: PPUSH
84926: PPUSH
// if not mc_bases [ base ] then
84927: LD_EXP 31
84931: PUSH
84932: LD_VAR 0 1
84936: ARRAY
84937: NOT
84938: IFFALSE 84942
// exit ;
84940: GO 85124
// tmp := [ ] ;
84942: LD_ADDR_VAR 0 6
84946: PUSH
84947: EMPTY
84948: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
84949: LD_ADDR_VAR 0 7
84953: PUSH
84954: LD_VAR 0 3
84958: PPUSH
84959: LD_INT 0
84961: PPUSH
84962: CALL_OW 517
84966: ST_TO_ADDR
// if not list then
84967: LD_VAR 0 7
84971: NOT
84972: IFFALSE 84976
// exit ;
84974: GO 85124
// for i = 1 to amount do
84976: LD_ADDR_VAR 0 5
84980: PUSH
84981: DOUBLE
84982: LD_INT 1
84984: DEC
84985: ST_TO_ADDR
84986: LD_VAR 0 2
84990: PUSH
84991: FOR_TO
84992: IFFALSE 85072
// begin x := rand ( 1 , list [ 1 ] ) ;
84994: LD_ADDR_VAR 0 8
84998: PUSH
84999: LD_INT 1
85001: PPUSH
85002: LD_VAR 0 7
85006: PUSH
85007: LD_INT 1
85009: ARRAY
85010: PPUSH
85011: CALL_OW 12
85015: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85016: LD_ADDR_VAR 0 6
85020: PUSH
85021: LD_VAR 0 6
85025: PPUSH
85026: LD_VAR 0 5
85030: PPUSH
85031: LD_VAR 0 7
85035: PUSH
85036: LD_INT 1
85038: ARRAY
85039: PUSH
85040: LD_VAR 0 8
85044: ARRAY
85045: PUSH
85046: LD_VAR 0 7
85050: PUSH
85051: LD_INT 2
85053: ARRAY
85054: PUSH
85055: LD_VAR 0 8
85059: ARRAY
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PPUSH
85065: CALL_OW 1
85069: ST_TO_ADDR
// end ;
85070: GO 84991
85072: POP
85073: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85074: LD_ADDR_EXP 44
85078: PUSH
85079: LD_EXP 44
85083: PPUSH
85084: LD_VAR 0 1
85088: PPUSH
85089: LD_VAR 0 6
85093: PPUSH
85094: CALL_OW 1
85098: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85099: LD_ADDR_EXP 46
85103: PUSH
85104: LD_EXP 46
85108: PPUSH
85109: LD_VAR 0 1
85113: PPUSH
85114: LD_VAR 0 3
85118: PPUSH
85119: CALL_OW 1
85123: ST_TO_ADDR
// end ;
85124: LD_VAR 0 4
85128: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85129: LD_INT 0
85131: PPUSH
// if not mc_bases [ base ] then
85132: LD_EXP 31
85136: PUSH
85137: LD_VAR 0 1
85141: ARRAY
85142: NOT
85143: IFFALSE 85147
// exit ;
85145: GO 85172
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85147: LD_ADDR_EXP 36
85151: PUSH
85152: LD_EXP 36
85156: PPUSH
85157: LD_VAR 0 1
85161: PPUSH
85162: LD_VAR 0 2
85166: PPUSH
85167: CALL_OW 1
85171: ST_TO_ADDR
// end ;
85172: LD_VAR 0 3
85176: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85177: LD_INT 0
85179: PPUSH
// if not mc_bases [ base ] then
85180: LD_EXP 31
85184: PUSH
85185: LD_VAR 0 1
85189: ARRAY
85190: NOT
85191: IFFALSE 85195
// exit ;
85193: GO 85232
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85195: LD_ADDR_EXP 36
85199: PUSH
85200: LD_EXP 36
85204: PPUSH
85205: LD_VAR 0 1
85209: PPUSH
85210: LD_EXP 36
85214: PUSH
85215: LD_VAR 0 1
85219: ARRAY
85220: PUSH
85221: LD_VAR 0 2
85225: UNION
85226: PPUSH
85227: CALL_OW 1
85231: ST_TO_ADDR
// end ;
85232: LD_VAR 0 3
85236: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85237: LD_INT 0
85239: PPUSH
// if not mc_bases [ base ] then
85240: LD_EXP 31
85244: PUSH
85245: LD_VAR 0 1
85249: ARRAY
85250: NOT
85251: IFFALSE 85255
// exit ;
85253: GO 85280
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85255: LD_ADDR_EXP 52
85259: PUSH
85260: LD_EXP 52
85264: PPUSH
85265: LD_VAR 0 1
85269: PPUSH
85270: LD_VAR 0 2
85274: PPUSH
85275: CALL_OW 1
85279: ST_TO_ADDR
// end ;
85280: LD_VAR 0 3
85284: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85285: LD_INT 0
85287: PPUSH
// if not mc_bases [ base ] then
85288: LD_EXP 31
85292: PUSH
85293: LD_VAR 0 1
85297: ARRAY
85298: NOT
85299: IFFALSE 85303
// exit ;
85301: GO 85340
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85303: LD_ADDR_EXP 52
85307: PUSH
85308: LD_EXP 52
85312: PPUSH
85313: LD_VAR 0 1
85317: PPUSH
85318: LD_EXP 52
85322: PUSH
85323: LD_VAR 0 1
85327: ARRAY
85328: PUSH
85329: LD_VAR 0 2
85333: ADD
85334: PPUSH
85335: CALL_OW 1
85339: ST_TO_ADDR
// end ;
85340: LD_VAR 0 3
85344: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85345: LD_INT 0
85347: PPUSH
// if not mc_bases [ base ] then
85348: LD_EXP 31
85352: PUSH
85353: LD_VAR 0 1
85357: ARRAY
85358: NOT
85359: IFFALSE 85363
// exit ;
85361: GO 85417
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85363: LD_ADDR_EXP 53
85367: PUSH
85368: LD_EXP 53
85372: PPUSH
85373: LD_VAR 0 1
85377: PPUSH
85378: LD_VAR 0 2
85382: PPUSH
85383: CALL_OW 1
85387: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85388: LD_ADDR_EXP 42
85392: PUSH
85393: LD_EXP 42
85397: PPUSH
85398: LD_VAR 0 1
85402: PPUSH
85403: LD_VAR 0 2
85407: PUSH
85408: LD_INT 0
85410: PLUS
85411: PPUSH
85412: CALL_OW 1
85416: ST_TO_ADDR
// end ;
85417: LD_VAR 0 3
85421: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85422: LD_INT 0
85424: PPUSH
// if not mc_bases [ base ] then
85425: LD_EXP 31
85429: PUSH
85430: LD_VAR 0 1
85434: ARRAY
85435: NOT
85436: IFFALSE 85440
// exit ;
85438: GO 85465
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85440: LD_ADDR_EXP 42
85444: PUSH
85445: LD_EXP 42
85449: PPUSH
85450: LD_VAR 0 1
85454: PPUSH
85455: LD_VAR 0 2
85459: PPUSH
85460: CALL_OW 1
85464: ST_TO_ADDR
// end ;
85465: LD_VAR 0 3
85469: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85470: LD_INT 0
85472: PPUSH
85473: PPUSH
85474: PPUSH
85475: PPUSH
// if not mc_bases [ base ] then
85476: LD_EXP 31
85480: PUSH
85481: LD_VAR 0 1
85485: ARRAY
85486: NOT
85487: IFFALSE 85491
// exit ;
85489: GO 85556
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85491: LD_ADDR_EXP 51
85495: PUSH
85496: LD_EXP 51
85500: PPUSH
85501: LD_VAR 0 1
85505: PUSH
85506: LD_EXP 51
85510: PUSH
85511: LD_VAR 0 1
85515: ARRAY
85516: PUSH
85517: LD_INT 1
85519: PLUS
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PPUSH
85525: LD_VAR 0 1
85529: PUSH
85530: LD_VAR 0 2
85534: PUSH
85535: LD_VAR 0 3
85539: PUSH
85540: LD_VAR 0 4
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: PPUSH
85551: CALL 25021 0 3
85555: ST_TO_ADDR
// end ;
85556: LD_VAR 0 5
85560: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85561: LD_INT 0
85563: PPUSH
// if not mc_bases [ base ] then
85564: LD_EXP 31
85568: PUSH
85569: LD_VAR 0 1
85573: ARRAY
85574: NOT
85575: IFFALSE 85579
// exit ;
85577: GO 85604
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85579: LD_ADDR_EXP 68
85583: PUSH
85584: LD_EXP 68
85588: PPUSH
85589: LD_VAR 0 1
85593: PPUSH
85594: LD_VAR 0 2
85598: PPUSH
85599: CALL_OW 1
85603: ST_TO_ADDR
// end ;
85604: LD_VAR 0 3
85608: RET
// export function MC_GetMinesField ( base ) ; begin
85609: LD_INT 0
85611: PPUSH
// result := mc_mines [ base ] ;
85612: LD_ADDR_VAR 0 2
85616: PUSH
85617: LD_EXP 44
85621: PUSH
85622: LD_VAR 0 1
85626: ARRAY
85627: ST_TO_ADDR
// end ;
85628: LD_VAR 0 2
85632: RET
// export function MC_GetProduceList ( base ) ; begin
85633: LD_INT 0
85635: PPUSH
// result := mc_produce [ base ] ;
85636: LD_ADDR_VAR 0 2
85640: PUSH
85641: LD_EXP 52
85645: PUSH
85646: LD_VAR 0 1
85650: ARRAY
85651: ST_TO_ADDR
// end ;
85652: LD_VAR 0 2
85656: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85657: LD_INT 0
85659: PPUSH
85660: PPUSH
// if not mc_bases then
85661: LD_EXP 31
85665: NOT
85666: IFFALSE 85670
// exit ;
85668: GO 85735
// if mc_bases [ base ] then
85670: LD_EXP 31
85674: PUSH
85675: LD_VAR 0 1
85679: ARRAY
85680: IFFALSE 85735
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85682: LD_ADDR_VAR 0 3
85686: PUSH
85687: LD_EXP 31
85691: PUSH
85692: LD_VAR 0 1
85696: ARRAY
85697: PPUSH
85698: LD_INT 30
85700: PUSH
85701: LD_VAR 0 2
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PPUSH
85710: CALL_OW 72
85714: ST_TO_ADDR
// if result then
85715: LD_VAR 0 3
85719: IFFALSE 85735
// result := result [ 1 ] ;
85721: LD_ADDR_VAR 0 3
85725: PUSH
85726: LD_VAR 0 3
85730: PUSH
85731: LD_INT 1
85733: ARRAY
85734: ST_TO_ADDR
// end ; end ;
85735: LD_VAR 0 3
85739: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85740: LD_INT 0
85742: PPUSH
85743: PPUSH
// if not mc_bases then
85744: LD_EXP 31
85748: NOT
85749: IFFALSE 85753
// exit ;
85751: GO 85798
// if mc_bases [ base ] then
85753: LD_EXP 31
85757: PUSH
85758: LD_VAR 0 1
85762: ARRAY
85763: IFFALSE 85798
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85765: LD_ADDR_VAR 0 3
85769: PUSH
85770: LD_EXP 31
85774: PUSH
85775: LD_VAR 0 1
85779: ARRAY
85780: PPUSH
85781: LD_INT 30
85783: PUSH
85784: LD_VAR 0 2
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PPUSH
85793: CALL_OW 72
85797: ST_TO_ADDR
// end ;
85798: LD_VAR 0 3
85802: RET
// export function MC_SetTame ( base , area ) ; begin
85803: LD_INT 0
85805: PPUSH
// if not mc_bases or not base then
85806: LD_EXP 31
85810: NOT
85811: PUSH
85812: LD_VAR 0 1
85816: NOT
85817: OR
85818: IFFALSE 85822
// exit ;
85820: GO 85847
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
85822: LD_ADDR_EXP 59
85826: PUSH
85827: LD_EXP 59
85831: PPUSH
85832: LD_VAR 0 1
85836: PPUSH
85837: LD_VAR 0 2
85841: PPUSH
85842: CALL_OW 1
85846: ST_TO_ADDR
// end ;
85847: LD_VAR 0 3
85851: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
85852: LD_INT 0
85854: PPUSH
85855: PPUSH
// if not mc_bases or not base then
85856: LD_EXP 31
85860: NOT
85861: PUSH
85862: LD_VAR 0 1
85866: NOT
85867: OR
85868: IFFALSE 85872
// exit ;
85870: GO 85974
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85872: LD_ADDR_VAR 0 4
85876: PUSH
85877: LD_EXP 31
85881: PUSH
85882: LD_VAR 0 1
85886: ARRAY
85887: PPUSH
85888: LD_INT 30
85890: PUSH
85891: LD_VAR 0 2
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PPUSH
85900: CALL_OW 72
85904: ST_TO_ADDR
// if not tmp then
85905: LD_VAR 0 4
85909: NOT
85910: IFFALSE 85914
// exit ;
85912: GO 85974
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
85914: LD_ADDR_EXP 63
85918: PUSH
85919: LD_EXP 63
85923: PPUSH
85924: LD_VAR 0 1
85928: PPUSH
85929: LD_EXP 63
85933: PUSH
85934: LD_VAR 0 1
85938: ARRAY
85939: PPUSH
85940: LD_EXP 63
85944: PUSH
85945: LD_VAR 0 1
85949: ARRAY
85950: PUSH
85951: LD_INT 1
85953: PLUS
85954: PPUSH
85955: LD_VAR 0 4
85959: PUSH
85960: LD_INT 1
85962: ARRAY
85963: PPUSH
85964: CALL_OW 2
85968: PPUSH
85969: CALL_OW 1
85973: ST_TO_ADDR
// end ;
85974: LD_VAR 0 3
85978: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
85979: LD_INT 0
85981: PPUSH
85982: PPUSH
// if not mc_bases or not base or not kinds then
85983: LD_EXP 31
85987: NOT
85988: PUSH
85989: LD_VAR 0 1
85993: NOT
85994: OR
85995: PUSH
85996: LD_VAR 0 2
86000: NOT
86001: OR
86002: IFFALSE 86006
// exit ;
86004: GO 86067
// for i in kinds do
86006: LD_ADDR_VAR 0 4
86010: PUSH
86011: LD_VAR 0 2
86015: PUSH
86016: FOR_IN
86017: IFFALSE 86065
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86019: LD_ADDR_EXP 65
86023: PUSH
86024: LD_EXP 65
86028: PPUSH
86029: LD_VAR 0 1
86033: PUSH
86034: LD_EXP 65
86038: PUSH
86039: LD_VAR 0 1
86043: ARRAY
86044: PUSH
86045: LD_INT 1
86047: PLUS
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PPUSH
86053: LD_VAR 0 4
86057: PPUSH
86058: CALL 25021 0 3
86062: ST_TO_ADDR
86063: GO 86016
86065: POP
86066: POP
// end ;
86067: LD_VAR 0 3
86071: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86072: LD_INT 0
86074: PPUSH
// if not mc_bases or not base or not areas then
86075: LD_EXP 31
86079: NOT
86080: PUSH
86081: LD_VAR 0 1
86085: NOT
86086: OR
86087: PUSH
86088: LD_VAR 0 2
86092: NOT
86093: OR
86094: IFFALSE 86098
// exit ;
86096: GO 86123
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86098: LD_ADDR_EXP 49
86102: PUSH
86103: LD_EXP 49
86107: PPUSH
86108: LD_VAR 0 1
86112: PPUSH
86113: LD_VAR 0 2
86117: PPUSH
86118: CALL_OW 1
86122: ST_TO_ADDR
// end ;
86123: LD_VAR 0 3
86127: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86128: LD_INT 0
86130: PPUSH
// if not mc_bases or not base or not teleports_exit then
86131: LD_EXP 31
86135: NOT
86136: PUSH
86137: LD_VAR 0 1
86141: NOT
86142: OR
86143: PUSH
86144: LD_VAR 0 2
86148: NOT
86149: OR
86150: IFFALSE 86154
// exit ;
86152: GO 86179
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86154: LD_ADDR_EXP 66
86158: PUSH
86159: LD_EXP 66
86163: PPUSH
86164: LD_VAR 0 1
86168: PPUSH
86169: LD_VAR 0 2
86173: PPUSH
86174: CALL_OW 1
86178: ST_TO_ADDR
// end ;
86179: LD_VAR 0 3
86183: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86184: LD_INT 0
86186: PPUSH
86187: PPUSH
86188: PPUSH
// if not mc_bases or not base or not ext_list then
86189: LD_EXP 31
86193: NOT
86194: PUSH
86195: LD_VAR 0 1
86199: NOT
86200: OR
86201: PUSH
86202: LD_VAR 0 5
86206: NOT
86207: OR
86208: IFFALSE 86212
// exit ;
86210: GO 86385
// tmp := GetFacExtXYD ( x , y , d ) ;
86212: LD_ADDR_VAR 0 8
86216: PUSH
86217: LD_VAR 0 2
86221: PPUSH
86222: LD_VAR 0 3
86226: PPUSH
86227: LD_VAR 0 4
86231: PPUSH
86232: CALL 54899 0 3
86236: ST_TO_ADDR
// if not tmp then
86237: LD_VAR 0 8
86241: NOT
86242: IFFALSE 86246
// exit ;
86244: GO 86385
// for i in tmp do
86246: LD_ADDR_VAR 0 7
86250: PUSH
86251: LD_VAR 0 8
86255: PUSH
86256: FOR_IN
86257: IFFALSE 86383
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86259: LD_ADDR_EXP 36
86263: PUSH
86264: LD_EXP 36
86268: PPUSH
86269: LD_VAR 0 1
86273: PPUSH
86274: LD_EXP 36
86278: PUSH
86279: LD_VAR 0 1
86283: ARRAY
86284: PPUSH
86285: LD_EXP 36
86289: PUSH
86290: LD_VAR 0 1
86294: ARRAY
86295: PUSH
86296: LD_INT 1
86298: PLUS
86299: PPUSH
86300: LD_VAR 0 5
86304: PUSH
86305: LD_INT 1
86307: ARRAY
86308: PUSH
86309: LD_VAR 0 7
86313: PUSH
86314: LD_INT 1
86316: ARRAY
86317: PUSH
86318: LD_VAR 0 7
86322: PUSH
86323: LD_INT 2
86325: ARRAY
86326: PUSH
86327: LD_VAR 0 7
86331: PUSH
86332: LD_INT 3
86334: ARRAY
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: PPUSH
86342: CALL_OW 2
86346: PPUSH
86347: CALL_OW 1
86351: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86352: LD_ADDR_VAR 0 5
86356: PUSH
86357: LD_VAR 0 5
86361: PPUSH
86362: LD_INT 1
86364: PPUSH
86365: CALL_OW 3
86369: ST_TO_ADDR
// if not ext_list then
86370: LD_VAR 0 5
86374: NOT
86375: IFFALSE 86381
// exit ;
86377: POP
86378: POP
86379: GO 86385
// end ;
86381: GO 86256
86383: POP
86384: POP
// end ;
86385: LD_VAR 0 6
86389: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86390: LD_INT 0
86392: PPUSH
// if not mc_bases or not base or not weapon_list then
86393: LD_EXP 31
86397: NOT
86398: PUSH
86399: LD_VAR 0 1
86403: NOT
86404: OR
86405: PUSH
86406: LD_VAR 0 2
86410: NOT
86411: OR
86412: IFFALSE 86416
// exit ;
86414: GO 86441
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86416: LD_ADDR_EXP 70
86420: PUSH
86421: LD_EXP 70
86425: PPUSH
86426: LD_VAR 0 1
86430: PPUSH
86431: LD_VAR 0 2
86435: PPUSH
86436: CALL_OW 1
86440: ST_TO_ADDR
// end ;
86441: LD_VAR 0 3
86445: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86446: LD_INT 0
86448: PPUSH
// if not mc_bases or not base or not tech_list then
86449: LD_EXP 31
86453: NOT
86454: PUSH
86455: LD_VAR 0 1
86459: NOT
86460: OR
86461: PUSH
86462: LD_VAR 0 2
86466: NOT
86467: OR
86468: IFFALSE 86472
// exit ;
86470: GO 86497
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86472: LD_ADDR_EXP 58
86476: PUSH
86477: LD_EXP 58
86481: PPUSH
86482: LD_VAR 0 1
86486: PPUSH
86487: LD_VAR 0 2
86491: PPUSH
86492: CALL_OW 1
86496: ST_TO_ADDR
// end ;
86497: LD_VAR 0 3
86501: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86502: LD_INT 0
86504: PPUSH
// if not mc_bases or not parking_area or not base then
86505: LD_EXP 31
86509: NOT
86510: PUSH
86511: LD_VAR 0 2
86515: NOT
86516: OR
86517: PUSH
86518: LD_VAR 0 1
86522: NOT
86523: OR
86524: IFFALSE 86528
// exit ;
86526: GO 86553
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86528: LD_ADDR_EXP 55
86532: PUSH
86533: LD_EXP 55
86537: PPUSH
86538: LD_VAR 0 1
86542: PPUSH
86543: LD_VAR 0 2
86547: PPUSH
86548: CALL_OW 1
86552: ST_TO_ADDR
// end ;
86553: LD_VAR 0 3
86557: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86558: LD_INT 0
86560: PPUSH
// if not mc_bases or not base or not scan_area then
86561: LD_EXP 31
86565: NOT
86566: PUSH
86567: LD_VAR 0 1
86571: NOT
86572: OR
86573: PUSH
86574: LD_VAR 0 2
86578: NOT
86579: OR
86580: IFFALSE 86584
// exit ;
86582: GO 86609
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86584: LD_ADDR_EXP 56
86588: PUSH
86589: LD_EXP 56
86593: PPUSH
86594: LD_VAR 0 1
86598: PPUSH
86599: LD_VAR 0 2
86603: PPUSH
86604: CALL_OW 1
86608: ST_TO_ADDR
// end ;
86609: LD_VAR 0 3
86613: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86614: LD_INT 0
86616: PPUSH
86617: PPUSH
// if not mc_bases or not base then
86618: LD_EXP 31
86622: NOT
86623: PUSH
86624: LD_VAR 0 1
86628: NOT
86629: OR
86630: IFFALSE 86634
// exit ;
86632: GO 86698
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86634: LD_ADDR_VAR 0 3
86638: PUSH
86639: LD_INT 1
86641: PUSH
86642: LD_INT 2
86644: PUSH
86645: LD_INT 3
86647: PUSH
86648: LD_INT 4
86650: PUSH
86651: LD_INT 11
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86661: LD_ADDR_EXP 58
86665: PUSH
86666: LD_EXP 58
86670: PPUSH
86671: LD_VAR 0 1
86675: PPUSH
86676: LD_EXP 58
86680: PUSH
86681: LD_VAR 0 1
86685: ARRAY
86686: PUSH
86687: LD_VAR 0 3
86691: DIFF
86692: PPUSH
86693: CALL_OW 1
86697: ST_TO_ADDR
// end ;
86698: LD_VAR 0 2
86702: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86703: LD_INT 0
86705: PPUSH
// result := mc_vehicles [ base ] ;
86706: LD_ADDR_VAR 0 3
86710: PUSH
86711: LD_EXP 50
86715: PUSH
86716: LD_VAR 0 1
86720: ARRAY
86721: ST_TO_ADDR
// if onlyCombat then
86722: LD_VAR 0 2
86726: IFFALSE 86898
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86728: LD_ADDR_VAR 0 3
86732: PUSH
86733: LD_VAR 0 3
86737: PUSH
86738: LD_VAR 0 3
86742: PPUSH
86743: LD_INT 2
86745: PUSH
86746: LD_INT 34
86748: PUSH
86749: LD_INT 12
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 34
86758: PUSH
86759: LD_INT 51
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 34
86768: PUSH
86769: LD_INT 89
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 34
86778: PUSH
86779: LD_INT 32
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 34
86788: PUSH
86789: LD_INT 13
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 34
86798: PUSH
86799: LD_INT 52
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 34
86808: PUSH
86809: LD_INT 88
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 34
86818: PUSH
86819: LD_INT 14
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 34
86828: PUSH
86829: LD_INT 53
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 34
86838: PUSH
86839: LD_INT 98
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 34
86848: PUSH
86849: LD_INT 31
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 34
86858: PUSH
86859: LD_INT 48
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 34
86868: PUSH
86869: LD_INT 8
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: PPUSH
86892: CALL_OW 72
86896: DIFF
86897: ST_TO_ADDR
// end ; end_of_file
86898: LD_VAR 0 3
86902: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
86903: LD_INT 0
86905: PPUSH
86906: PPUSH
86907: PPUSH
// if not mc_bases or not skirmish then
86908: LD_EXP 31
86912: NOT
86913: PUSH
86914: LD_EXP 29
86918: NOT
86919: OR
86920: IFFALSE 86924
// exit ;
86922: GO 87089
// for i = 1 to mc_bases do
86924: LD_ADDR_VAR 0 4
86928: PUSH
86929: DOUBLE
86930: LD_INT 1
86932: DEC
86933: ST_TO_ADDR
86934: LD_EXP 31
86938: PUSH
86939: FOR_TO
86940: IFFALSE 87087
// begin if sci in mc_bases [ i ] then
86942: LD_VAR 0 2
86946: PUSH
86947: LD_EXP 31
86951: PUSH
86952: LD_VAR 0 4
86956: ARRAY
86957: IN
86958: IFFALSE 87085
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
86960: LD_ADDR_EXP 60
86964: PUSH
86965: LD_EXP 60
86969: PPUSH
86970: LD_VAR 0 4
86974: PUSH
86975: LD_EXP 60
86979: PUSH
86980: LD_VAR 0 4
86984: ARRAY
86985: PUSH
86986: LD_INT 1
86988: PLUS
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PPUSH
86994: LD_VAR 0 1
86998: PPUSH
86999: CALL 25021 0 3
87003: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87004: LD_ADDR_VAR 0 5
87008: PUSH
87009: LD_EXP 31
87013: PUSH
87014: LD_VAR 0 4
87018: ARRAY
87019: PPUSH
87020: LD_INT 2
87022: PUSH
87023: LD_INT 30
87025: PUSH
87026: LD_INT 0
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 30
87035: PUSH
87036: LD_INT 1
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: LIST
87047: PPUSH
87048: CALL_OW 72
87052: PPUSH
87053: LD_VAR 0 1
87057: PPUSH
87058: CALL_OW 74
87062: ST_TO_ADDR
// if tmp then
87063: LD_VAR 0 5
87067: IFFALSE 87083
// ComStandNearbyBuilding ( ape , tmp ) ;
87069: LD_VAR 0 1
87073: PPUSH
87074: LD_VAR 0 5
87078: PPUSH
87079: CALL 21448 0 2
// break ;
87083: GO 87087
// end ; end ;
87085: GO 86939
87087: POP
87088: POP
// end ;
87089: LD_VAR 0 3
87093: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87094: LD_INT 0
87096: PPUSH
87097: PPUSH
87098: PPUSH
// if not mc_bases or not skirmish then
87099: LD_EXP 31
87103: NOT
87104: PUSH
87105: LD_EXP 29
87109: NOT
87110: OR
87111: IFFALSE 87115
// exit ;
87113: GO 87204
// for i = 1 to mc_bases do
87115: LD_ADDR_VAR 0 4
87119: PUSH
87120: DOUBLE
87121: LD_INT 1
87123: DEC
87124: ST_TO_ADDR
87125: LD_EXP 31
87129: PUSH
87130: FOR_TO
87131: IFFALSE 87202
// begin if building in mc_busy_turret_list [ i ] then
87133: LD_VAR 0 1
87137: PUSH
87138: LD_EXP 41
87142: PUSH
87143: LD_VAR 0 4
87147: ARRAY
87148: IN
87149: IFFALSE 87200
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87151: LD_ADDR_VAR 0 5
87155: PUSH
87156: LD_EXP 41
87160: PUSH
87161: LD_VAR 0 4
87165: ARRAY
87166: PUSH
87167: LD_VAR 0 1
87171: DIFF
87172: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87173: LD_ADDR_EXP 41
87177: PUSH
87178: LD_EXP 41
87182: PPUSH
87183: LD_VAR 0 4
87187: PPUSH
87188: LD_VAR 0 5
87192: PPUSH
87193: CALL_OW 1
87197: ST_TO_ADDR
// break ;
87198: GO 87202
// end ; end ;
87200: GO 87130
87202: POP
87203: POP
// end ;
87204: LD_VAR 0 3
87208: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87209: LD_INT 0
87211: PPUSH
87212: PPUSH
87213: PPUSH
// if not mc_bases or not skirmish then
87214: LD_EXP 31
87218: NOT
87219: PUSH
87220: LD_EXP 29
87224: NOT
87225: OR
87226: IFFALSE 87230
// exit ;
87228: GO 87429
// for i = 1 to mc_bases do
87230: LD_ADDR_VAR 0 5
87234: PUSH
87235: DOUBLE
87236: LD_INT 1
87238: DEC
87239: ST_TO_ADDR
87240: LD_EXP 31
87244: PUSH
87245: FOR_TO
87246: IFFALSE 87427
// if building in mc_bases [ i ] then
87248: LD_VAR 0 1
87252: PUSH
87253: LD_EXP 31
87257: PUSH
87258: LD_VAR 0 5
87262: ARRAY
87263: IN
87264: IFFALSE 87425
// begin tmp := mc_bases [ i ] diff building ;
87266: LD_ADDR_VAR 0 6
87270: PUSH
87271: LD_EXP 31
87275: PUSH
87276: LD_VAR 0 5
87280: ARRAY
87281: PUSH
87282: LD_VAR 0 1
87286: DIFF
87287: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87288: LD_ADDR_EXP 31
87292: PUSH
87293: LD_EXP 31
87297: PPUSH
87298: LD_VAR 0 5
87302: PPUSH
87303: LD_VAR 0 6
87307: PPUSH
87308: CALL_OW 1
87312: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87313: LD_VAR 0 1
87317: PUSH
87318: LD_EXP 39
87322: PUSH
87323: LD_VAR 0 5
87327: ARRAY
87328: IN
87329: IFFALSE 87368
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87331: LD_ADDR_EXP 39
87335: PUSH
87336: LD_EXP 39
87340: PPUSH
87341: LD_VAR 0 5
87345: PPUSH
87346: LD_EXP 39
87350: PUSH
87351: LD_VAR 0 5
87355: ARRAY
87356: PUSH
87357: LD_VAR 0 1
87361: DIFF
87362: PPUSH
87363: CALL_OW 1
87367: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87368: LD_VAR 0 1
87372: PUSH
87373: LD_EXP 40
87377: PUSH
87378: LD_VAR 0 5
87382: ARRAY
87383: IN
87384: IFFALSE 87423
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87386: LD_ADDR_EXP 40
87390: PUSH
87391: LD_EXP 40
87395: PPUSH
87396: LD_VAR 0 5
87400: PPUSH
87401: LD_EXP 40
87405: PUSH
87406: LD_VAR 0 5
87410: ARRAY
87411: PUSH
87412: LD_VAR 0 1
87416: DIFF
87417: PPUSH
87418: CALL_OW 1
87422: ST_TO_ADDR
// break ;
87423: GO 87427
// end ;
87425: GO 87245
87427: POP
87428: POP
// end ;
87429: LD_VAR 0 4
87433: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87434: LD_INT 0
87436: PPUSH
87437: PPUSH
87438: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87439: LD_EXP 31
87443: NOT
87444: PUSH
87445: LD_EXP 29
87449: NOT
87450: OR
87451: PUSH
87452: LD_VAR 0 3
87456: PUSH
87457: LD_EXP 57
87461: IN
87462: NOT
87463: OR
87464: IFFALSE 87468
// exit ;
87466: GO 87591
// for i = 1 to mc_vehicles do
87468: LD_ADDR_VAR 0 6
87472: PUSH
87473: DOUBLE
87474: LD_INT 1
87476: DEC
87477: ST_TO_ADDR
87478: LD_EXP 50
87482: PUSH
87483: FOR_TO
87484: IFFALSE 87589
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87486: LD_VAR 0 2
87490: PUSH
87491: LD_EXP 50
87495: PUSH
87496: LD_VAR 0 6
87500: ARRAY
87501: IN
87502: PUSH
87503: LD_VAR 0 1
87507: PUSH
87508: LD_EXP 50
87512: PUSH
87513: LD_VAR 0 6
87517: ARRAY
87518: IN
87519: OR
87520: IFFALSE 87587
// begin tmp := mc_vehicles [ i ] diff old ;
87522: LD_ADDR_VAR 0 7
87526: PUSH
87527: LD_EXP 50
87531: PUSH
87532: LD_VAR 0 6
87536: ARRAY
87537: PUSH
87538: LD_VAR 0 2
87542: DIFF
87543: ST_TO_ADDR
// tmp := tmp diff new ;
87544: LD_ADDR_VAR 0 7
87548: PUSH
87549: LD_VAR 0 7
87553: PUSH
87554: LD_VAR 0 1
87558: DIFF
87559: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87560: LD_ADDR_EXP 50
87564: PUSH
87565: LD_EXP 50
87569: PPUSH
87570: LD_VAR 0 6
87574: PPUSH
87575: LD_VAR 0 7
87579: PPUSH
87580: CALL_OW 1
87584: ST_TO_ADDR
// break ;
87585: GO 87589
// end ;
87587: GO 87483
87589: POP
87590: POP
// end ;
87591: LD_VAR 0 5
87595: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87596: LD_INT 0
87598: PPUSH
87599: PPUSH
87600: PPUSH
87601: PPUSH
// if not mc_bases or not skirmish then
87602: LD_EXP 31
87606: NOT
87607: PUSH
87608: LD_EXP 29
87612: NOT
87613: OR
87614: IFFALSE 87618
// exit ;
87616: GO 88000
// side := GetSide ( vehicle ) ;
87618: LD_ADDR_VAR 0 5
87622: PUSH
87623: LD_VAR 0 1
87627: PPUSH
87628: CALL_OW 255
87632: ST_TO_ADDR
// for i = 1 to mc_bases do
87633: LD_ADDR_VAR 0 4
87637: PUSH
87638: DOUBLE
87639: LD_INT 1
87641: DEC
87642: ST_TO_ADDR
87643: LD_EXP 31
87647: PUSH
87648: FOR_TO
87649: IFFALSE 87998
// begin if factory in mc_bases [ i ] then
87651: LD_VAR 0 2
87655: PUSH
87656: LD_EXP 31
87660: PUSH
87661: LD_VAR 0 4
87665: ARRAY
87666: IN
87667: IFFALSE 87996
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87669: LD_EXP 53
87673: PUSH
87674: LD_VAR 0 4
87678: ARRAY
87679: PUSH
87680: LD_EXP 42
87684: PUSH
87685: LD_VAR 0 4
87689: ARRAY
87690: LESS
87691: PUSH
87692: LD_VAR 0 1
87696: PPUSH
87697: CALL_OW 264
87701: PUSH
87702: LD_INT 31
87704: PUSH
87705: LD_INT 32
87707: PUSH
87708: LD_INT 51
87710: PUSH
87711: LD_INT 89
87713: PUSH
87714: LD_INT 12
87716: PUSH
87717: LD_INT 30
87719: PUSH
87720: LD_INT 98
87722: PUSH
87723: LD_INT 11
87725: PUSH
87726: LD_INT 53
87728: PUSH
87729: LD_INT 14
87731: PUSH
87732: LD_INT 91
87734: PUSH
87735: LD_INT 29
87737: PUSH
87738: LD_INT 99
87740: PUSH
87741: LD_INT 13
87743: PUSH
87744: LD_INT 52
87746: PUSH
87747: LD_INT 88
87749: PUSH
87750: LD_INT 48
87752: PUSH
87753: LD_INT 8
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: IN
87776: NOT
87777: AND
87778: IFFALSE 87826
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
87780: LD_ADDR_EXP 53
87784: PUSH
87785: LD_EXP 53
87789: PPUSH
87790: LD_VAR 0 4
87794: PUSH
87795: LD_EXP 53
87799: PUSH
87800: LD_VAR 0 4
87804: ARRAY
87805: PUSH
87806: LD_INT 1
87808: PLUS
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PPUSH
87814: LD_VAR 0 1
87818: PPUSH
87819: CALL 25021 0 3
87823: ST_TO_ADDR
87824: GO 87870
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
87826: LD_ADDR_EXP 50
87830: PUSH
87831: LD_EXP 50
87835: PPUSH
87836: LD_VAR 0 4
87840: PUSH
87841: LD_EXP 50
87845: PUSH
87846: LD_VAR 0 4
87850: ARRAY
87851: PUSH
87852: LD_INT 1
87854: PLUS
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PPUSH
87860: LD_VAR 0 1
87864: PPUSH
87865: CALL 25021 0 3
87869: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
87870: LD_VAR 0 1
87874: PPUSH
87875: CALL_OW 263
87879: PUSH
87880: LD_INT 2
87882: EQUAL
87883: IFFALSE 87912
// begin repeat wait ( 0 0$3 ) ;
87885: LD_INT 105
87887: PPUSH
87888: CALL_OW 67
// Connect ( vehicle ) ;
87892: LD_VAR 0 1
87896: PPUSH
87897: CALL 27990 0 1
// until IsControledBy ( vehicle ) ;
87901: LD_VAR 0 1
87905: PPUSH
87906: CALL_OW 312
87910: IFFALSE 87885
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
87912: LD_VAR 0 1
87916: PPUSH
87917: LD_EXP 55
87921: PUSH
87922: LD_VAR 0 4
87926: ARRAY
87927: PPUSH
87928: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
87932: LD_VAR 0 1
87936: PPUSH
87937: CALL_OW 263
87941: PUSH
87942: LD_INT 1
87944: NONEQUAL
87945: IFFALSE 87949
// break ;
87947: GO 87998
// repeat wait ( 0 0$1 ) ;
87949: LD_INT 35
87951: PPUSH
87952: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
87956: LD_VAR 0 1
87960: PPUSH
87961: LD_EXP 55
87965: PUSH
87966: LD_VAR 0 4
87970: ARRAY
87971: PPUSH
87972: CALL_OW 308
87976: IFFALSE 87949
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
87978: LD_VAR 0 1
87982: PPUSH
87983: CALL_OW 311
87987: PPUSH
87988: CALL_OW 121
// exit ;
87992: POP
87993: POP
87994: GO 88000
// end ; end ;
87996: GO 87648
87998: POP
87999: POP
// end ;
88000: LD_VAR 0 3
88004: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88005: LD_INT 0
88007: PPUSH
88008: PPUSH
88009: PPUSH
88010: PPUSH
// if not mc_bases or not skirmish then
88011: LD_EXP 31
88015: NOT
88016: PUSH
88017: LD_EXP 29
88021: NOT
88022: OR
88023: IFFALSE 88027
// exit ;
88025: GO 88380
// repeat wait ( 0 0$1 ) ;
88027: LD_INT 35
88029: PPUSH
88030: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88034: LD_VAR 0 2
88038: PPUSH
88039: LD_VAR 0 3
88043: PPUSH
88044: CALL_OW 284
88048: IFFALSE 88027
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88050: LD_VAR 0 2
88054: PPUSH
88055: LD_VAR 0 3
88059: PPUSH
88060: CALL_OW 283
88064: PUSH
88065: LD_INT 4
88067: EQUAL
88068: IFFALSE 88072
// exit ;
88070: GO 88380
// for i = 1 to mc_bases do
88072: LD_ADDR_VAR 0 7
88076: PUSH
88077: DOUBLE
88078: LD_INT 1
88080: DEC
88081: ST_TO_ADDR
88082: LD_EXP 31
88086: PUSH
88087: FOR_TO
88088: IFFALSE 88378
// begin if mc_crates_area [ i ] then
88090: LD_EXP 49
88094: PUSH
88095: LD_VAR 0 7
88099: ARRAY
88100: IFFALSE 88211
// for j in mc_crates_area [ i ] do
88102: LD_ADDR_VAR 0 8
88106: PUSH
88107: LD_EXP 49
88111: PUSH
88112: LD_VAR 0 7
88116: ARRAY
88117: PUSH
88118: FOR_IN
88119: IFFALSE 88209
// if InArea ( x , y , j ) then
88121: LD_VAR 0 2
88125: PPUSH
88126: LD_VAR 0 3
88130: PPUSH
88131: LD_VAR 0 8
88135: PPUSH
88136: CALL_OW 309
88140: IFFALSE 88207
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88142: LD_ADDR_EXP 47
88146: PUSH
88147: LD_EXP 47
88151: PPUSH
88152: LD_VAR 0 7
88156: PUSH
88157: LD_EXP 47
88161: PUSH
88162: LD_VAR 0 7
88166: ARRAY
88167: PUSH
88168: LD_INT 1
88170: PLUS
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PPUSH
88176: LD_VAR 0 4
88180: PUSH
88181: LD_VAR 0 2
88185: PUSH
88186: LD_VAR 0 3
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: LIST
88195: PPUSH
88196: CALL 25021 0 3
88200: ST_TO_ADDR
// exit ;
88201: POP
88202: POP
88203: POP
88204: POP
88205: GO 88380
// end ;
88207: GO 88118
88209: POP
88210: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88211: LD_ADDR_VAR 0 9
88215: PUSH
88216: LD_EXP 31
88220: PUSH
88221: LD_VAR 0 7
88225: ARRAY
88226: PPUSH
88227: LD_INT 2
88229: PUSH
88230: LD_INT 30
88232: PUSH
88233: LD_INT 0
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 30
88242: PUSH
88243: LD_INT 1
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: EMPTY
88251: LIST
88252: LIST
88253: LIST
88254: PPUSH
88255: CALL_OW 72
88259: ST_TO_ADDR
// if not depot then
88260: LD_VAR 0 9
88264: NOT
88265: IFFALSE 88269
// continue ;
88267: GO 88087
// for j in depot do
88269: LD_ADDR_VAR 0 8
88273: PUSH
88274: LD_VAR 0 9
88278: PUSH
88279: FOR_IN
88280: IFFALSE 88374
// if GetDistUnitXY ( j , x , y ) < 30 then
88282: LD_VAR 0 8
88286: PPUSH
88287: LD_VAR 0 2
88291: PPUSH
88292: LD_VAR 0 3
88296: PPUSH
88297: CALL_OW 297
88301: PUSH
88302: LD_INT 30
88304: LESS
88305: IFFALSE 88372
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88307: LD_ADDR_EXP 47
88311: PUSH
88312: LD_EXP 47
88316: PPUSH
88317: LD_VAR 0 7
88321: PUSH
88322: LD_EXP 47
88326: PUSH
88327: LD_VAR 0 7
88331: ARRAY
88332: PUSH
88333: LD_INT 1
88335: PLUS
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: PPUSH
88341: LD_VAR 0 4
88345: PUSH
88346: LD_VAR 0 2
88350: PUSH
88351: LD_VAR 0 3
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: LIST
88360: PPUSH
88361: CALL 25021 0 3
88365: ST_TO_ADDR
// exit ;
88366: POP
88367: POP
88368: POP
88369: POP
88370: GO 88380
// end ;
88372: GO 88279
88374: POP
88375: POP
// end ;
88376: GO 88087
88378: POP
88379: POP
// end ;
88380: LD_VAR 0 6
88384: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88385: LD_INT 0
88387: PPUSH
88388: PPUSH
88389: PPUSH
88390: PPUSH
// if not mc_bases or not skirmish then
88391: LD_EXP 31
88395: NOT
88396: PUSH
88397: LD_EXP 29
88401: NOT
88402: OR
88403: IFFALSE 88407
// exit ;
88405: GO 88684
// side := GetSide ( lab ) ;
88407: LD_ADDR_VAR 0 4
88411: PUSH
88412: LD_VAR 0 2
88416: PPUSH
88417: CALL_OW 255
88421: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88422: LD_VAR 0 4
88426: PUSH
88427: LD_EXP 57
88431: IN
88432: NOT
88433: PUSH
88434: LD_EXP 58
88438: NOT
88439: OR
88440: PUSH
88441: LD_EXP 31
88445: NOT
88446: OR
88447: IFFALSE 88451
// exit ;
88449: GO 88684
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88451: LD_ADDR_EXP 58
88455: PUSH
88456: LD_EXP 58
88460: PPUSH
88461: LD_VAR 0 4
88465: PPUSH
88466: LD_EXP 58
88470: PUSH
88471: LD_VAR 0 4
88475: ARRAY
88476: PUSH
88477: LD_VAR 0 1
88481: DIFF
88482: PPUSH
88483: CALL_OW 1
88487: ST_TO_ADDR
// for i = 1 to mc_bases do
88488: LD_ADDR_VAR 0 5
88492: PUSH
88493: DOUBLE
88494: LD_INT 1
88496: DEC
88497: ST_TO_ADDR
88498: LD_EXP 31
88502: PUSH
88503: FOR_TO
88504: IFFALSE 88682
// begin if lab in mc_bases [ i ] then
88506: LD_VAR 0 2
88510: PUSH
88511: LD_EXP 31
88515: PUSH
88516: LD_VAR 0 5
88520: ARRAY
88521: IN
88522: IFFALSE 88680
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88524: LD_VAR 0 1
88528: PUSH
88529: LD_INT 11
88531: PUSH
88532: LD_INT 4
88534: PUSH
88535: LD_INT 3
88537: PUSH
88538: LD_INT 2
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: IN
88547: PUSH
88548: LD_EXP 61
88552: PUSH
88553: LD_VAR 0 5
88557: ARRAY
88558: AND
88559: IFFALSE 88680
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88561: LD_ADDR_VAR 0 6
88565: PUSH
88566: LD_EXP 61
88570: PUSH
88571: LD_VAR 0 5
88575: ARRAY
88576: PUSH
88577: LD_INT 1
88579: ARRAY
88580: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88581: LD_ADDR_EXP 61
88585: PUSH
88586: LD_EXP 61
88590: PPUSH
88591: LD_VAR 0 5
88595: PPUSH
88596: EMPTY
88597: PPUSH
88598: CALL_OW 1
88602: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88603: LD_VAR 0 6
88607: PPUSH
88608: LD_INT 0
88610: PPUSH
88611: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88615: LD_VAR 0 6
88619: PPUSH
88620: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88624: LD_ADDR_EXP 60
88628: PUSH
88629: LD_EXP 60
88633: PPUSH
88634: LD_VAR 0 5
88638: PPUSH
88639: LD_EXP 60
88643: PUSH
88644: LD_VAR 0 5
88648: ARRAY
88649: PPUSH
88650: LD_INT 1
88652: PPUSH
88653: LD_VAR 0 6
88657: PPUSH
88658: CALL_OW 2
88662: PPUSH
88663: CALL_OW 1
88667: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88668: LD_VAR 0 5
88672: PPUSH
88673: LD_INT 112
88675: PPUSH
88676: CALL 65223 0 2
// end ; end ; end ;
88680: GO 88503
88682: POP
88683: POP
// end ;
88684: LD_VAR 0 3
88688: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88689: LD_INT 0
88691: PPUSH
88692: PPUSH
88693: PPUSH
88694: PPUSH
88695: PPUSH
88696: PPUSH
88697: PPUSH
88698: PPUSH
// if not mc_bases or not skirmish then
88699: LD_EXP 31
88703: NOT
88704: PUSH
88705: LD_EXP 29
88709: NOT
88710: OR
88711: IFFALSE 88715
// exit ;
88713: GO 90084
// for i = 1 to mc_bases do
88715: LD_ADDR_VAR 0 3
88719: PUSH
88720: DOUBLE
88721: LD_INT 1
88723: DEC
88724: ST_TO_ADDR
88725: LD_EXP 31
88729: PUSH
88730: FOR_TO
88731: IFFALSE 90082
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88733: LD_VAR 0 1
88737: PUSH
88738: LD_EXP 31
88742: PUSH
88743: LD_VAR 0 3
88747: ARRAY
88748: IN
88749: PUSH
88750: LD_VAR 0 1
88754: PUSH
88755: LD_EXP 38
88759: PUSH
88760: LD_VAR 0 3
88764: ARRAY
88765: IN
88766: OR
88767: PUSH
88768: LD_VAR 0 1
88772: PUSH
88773: LD_EXP 53
88777: PUSH
88778: LD_VAR 0 3
88782: ARRAY
88783: IN
88784: OR
88785: PUSH
88786: LD_VAR 0 1
88790: PUSH
88791: LD_EXP 50
88795: PUSH
88796: LD_VAR 0 3
88800: ARRAY
88801: IN
88802: OR
88803: PUSH
88804: LD_VAR 0 1
88808: PUSH
88809: LD_EXP 60
88813: PUSH
88814: LD_VAR 0 3
88818: ARRAY
88819: IN
88820: OR
88821: PUSH
88822: LD_VAR 0 1
88826: PUSH
88827: LD_EXP 61
88831: PUSH
88832: LD_VAR 0 3
88836: ARRAY
88837: IN
88838: OR
88839: IFFALSE 90080
// begin if un in mc_ape [ i ] then
88841: LD_VAR 0 1
88845: PUSH
88846: LD_EXP 60
88850: PUSH
88851: LD_VAR 0 3
88855: ARRAY
88856: IN
88857: IFFALSE 88896
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
88859: LD_ADDR_EXP 60
88863: PUSH
88864: LD_EXP 60
88868: PPUSH
88869: LD_VAR 0 3
88873: PPUSH
88874: LD_EXP 60
88878: PUSH
88879: LD_VAR 0 3
88883: ARRAY
88884: PUSH
88885: LD_VAR 0 1
88889: DIFF
88890: PPUSH
88891: CALL_OW 1
88895: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
88896: LD_VAR 0 1
88900: PUSH
88901: LD_EXP 61
88905: PUSH
88906: LD_VAR 0 3
88910: ARRAY
88911: IN
88912: IFFALSE 88936
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88914: LD_ADDR_EXP 61
88918: PUSH
88919: LD_EXP 61
88923: PPUSH
88924: LD_VAR 0 3
88928: PPUSH
88929: EMPTY
88930: PPUSH
88931: CALL_OW 1
88935: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
88936: LD_VAR 0 1
88940: PPUSH
88941: CALL_OW 247
88945: PUSH
88946: LD_INT 2
88948: EQUAL
88949: PUSH
88950: LD_VAR 0 1
88954: PPUSH
88955: CALL_OW 110
88959: PUSH
88960: LD_INT 20
88962: EQUAL
88963: PUSH
88964: LD_VAR 0 1
88968: PUSH
88969: LD_EXP 53
88973: PUSH
88974: LD_VAR 0 3
88978: ARRAY
88979: IN
88980: OR
88981: PUSH
88982: LD_VAR 0 1
88986: PPUSH
88987: CALL_OW 264
88991: PUSH
88992: LD_INT 12
88994: PUSH
88995: LD_INT 51
88997: PUSH
88998: LD_INT 89
89000: PUSH
89001: LD_INT 32
89003: PUSH
89004: LD_INT 13
89006: PUSH
89007: LD_INT 52
89009: PUSH
89010: LD_INT 31
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: IN
89022: OR
89023: AND
89024: IFFALSE 89332
// begin if un in mc_defender [ i ] then
89026: LD_VAR 0 1
89030: PUSH
89031: LD_EXP 53
89035: PUSH
89036: LD_VAR 0 3
89040: ARRAY
89041: IN
89042: IFFALSE 89081
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89044: LD_ADDR_EXP 53
89048: PUSH
89049: LD_EXP 53
89053: PPUSH
89054: LD_VAR 0 3
89058: PPUSH
89059: LD_EXP 53
89063: PUSH
89064: LD_VAR 0 3
89068: ARRAY
89069: PUSH
89070: LD_VAR 0 1
89074: DIFF
89075: PPUSH
89076: CALL_OW 1
89080: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89081: LD_ADDR_VAR 0 8
89085: PUSH
89086: LD_VAR 0 3
89090: PPUSH
89091: LD_INT 3
89093: PPUSH
89094: CALL 85740 0 2
89098: ST_TO_ADDR
// if fac then
89099: LD_VAR 0 8
89103: IFFALSE 89332
// begin for j in fac do
89105: LD_ADDR_VAR 0 4
89109: PUSH
89110: LD_VAR 0 8
89114: PUSH
89115: FOR_IN
89116: IFFALSE 89330
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89118: LD_ADDR_VAR 0 9
89122: PUSH
89123: LD_VAR 0 8
89127: PPUSH
89128: LD_VAR 0 1
89132: PPUSH
89133: CALL_OW 265
89137: PPUSH
89138: LD_VAR 0 1
89142: PPUSH
89143: CALL_OW 262
89147: PPUSH
89148: LD_VAR 0 1
89152: PPUSH
89153: CALL_OW 263
89157: PPUSH
89158: LD_VAR 0 1
89162: PPUSH
89163: CALL_OW 264
89167: PPUSH
89168: CALL 22519 0 5
89172: ST_TO_ADDR
// if components then
89173: LD_VAR 0 9
89177: IFFALSE 89328
// begin if GetWeapon ( un ) = ar_control_tower then
89179: LD_VAR 0 1
89183: PPUSH
89184: CALL_OW 264
89188: PUSH
89189: LD_INT 31
89191: EQUAL
89192: IFFALSE 89309
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89194: LD_VAR 0 1
89198: PPUSH
89199: CALL_OW 311
89203: PPUSH
89204: LD_INT 0
89206: PPUSH
89207: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89211: LD_ADDR_EXP 71
89215: PUSH
89216: LD_EXP 71
89220: PPUSH
89221: LD_VAR 0 3
89225: PPUSH
89226: LD_EXP 71
89230: PUSH
89231: LD_VAR 0 3
89235: ARRAY
89236: PUSH
89237: LD_VAR 0 1
89241: PPUSH
89242: CALL_OW 311
89246: DIFF
89247: PPUSH
89248: CALL_OW 1
89252: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89253: LD_ADDR_VAR 0 7
89257: PUSH
89258: LD_EXP 52
89262: PUSH
89263: LD_VAR 0 3
89267: ARRAY
89268: PPUSH
89269: LD_INT 1
89271: PPUSH
89272: LD_VAR 0 9
89276: PPUSH
89277: CALL_OW 2
89281: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89282: LD_ADDR_EXP 52
89286: PUSH
89287: LD_EXP 52
89291: PPUSH
89292: LD_VAR 0 3
89296: PPUSH
89297: LD_VAR 0 7
89301: PPUSH
89302: CALL_OW 1
89306: ST_TO_ADDR
// end else
89307: GO 89326
// MC_InsertProduceList ( i , [ components ] ) ;
89309: LD_VAR 0 3
89313: PPUSH
89314: LD_VAR 0 9
89318: PUSH
89319: EMPTY
89320: LIST
89321: PPUSH
89322: CALL 85285 0 2
// break ;
89326: GO 89330
// end ; end ;
89328: GO 89115
89330: POP
89331: POP
// end ; end ; if GetType ( un ) = unit_building then
89332: LD_VAR 0 1
89336: PPUSH
89337: CALL_OW 247
89341: PUSH
89342: LD_INT 3
89344: EQUAL
89345: IFFALSE 89748
// begin btype := GetBType ( un ) ;
89347: LD_ADDR_VAR 0 5
89351: PUSH
89352: LD_VAR 0 1
89356: PPUSH
89357: CALL_OW 266
89361: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89362: LD_VAR 0 5
89366: PUSH
89367: LD_INT 29
89369: PUSH
89370: LD_INT 30
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: IN
89377: IFFALSE 89450
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89379: LD_VAR 0 1
89383: PPUSH
89384: CALL_OW 250
89388: PPUSH
89389: LD_VAR 0 1
89393: PPUSH
89394: CALL_OW 251
89398: PPUSH
89399: LD_VAR 0 1
89403: PPUSH
89404: CALL_OW 255
89408: PPUSH
89409: CALL_OW 440
89413: NOT
89414: IFFALSE 89450
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89416: LD_VAR 0 1
89420: PPUSH
89421: CALL_OW 250
89425: PPUSH
89426: LD_VAR 0 1
89430: PPUSH
89431: CALL_OW 251
89435: PPUSH
89436: LD_VAR 0 1
89440: PPUSH
89441: CALL_OW 255
89445: PPUSH
89446: CALL_OW 441
// end ; if btype = b_warehouse then
89450: LD_VAR 0 5
89454: PUSH
89455: LD_INT 1
89457: EQUAL
89458: IFFALSE 89476
// begin btype := b_depot ;
89460: LD_ADDR_VAR 0 5
89464: PUSH
89465: LD_INT 0
89467: ST_TO_ADDR
// pos := 1 ;
89468: LD_ADDR_VAR 0 6
89472: PUSH
89473: LD_INT 1
89475: ST_TO_ADDR
// end ; if btype = b_factory then
89476: LD_VAR 0 5
89480: PUSH
89481: LD_INT 3
89483: EQUAL
89484: IFFALSE 89502
// begin btype := b_workshop ;
89486: LD_ADDR_VAR 0 5
89490: PUSH
89491: LD_INT 2
89493: ST_TO_ADDR
// pos := 1 ;
89494: LD_ADDR_VAR 0 6
89498: PUSH
89499: LD_INT 1
89501: ST_TO_ADDR
// end ; if btype = b_barracks then
89502: LD_VAR 0 5
89506: PUSH
89507: LD_INT 5
89509: EQUAL
89510: IFFALSE 89520
// btype := b_armoury ;
89512: LD_ADDR_VAR 0 5
89516: PUSH
89517: LD_INT 4
89519: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89520: LD_VAR 0 5
89524: PUSH
89525: LD_INT 7
89527: PUSH
89528: LD_INT 8
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: IN
89535: IFFALSE 89545
// btype := b_lab ;
89537: LD_ADDR_VAR 0 5
89541: PUSH
89542: LD_INT 6
89544: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89545: LD_ADDR_EXP 36
89549: PUSH
89550: LD_EXP 36
89554: PPUSH
89555: LD_VAR 0 3
89559: PUSH
89560: LD_EXP 36
89564: PUSH
89565: LD_VAR 0 3
89569: ARRAY
89570: PUSH
89571: LD_INT 1
89573: PLUS
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PPUSH
89579: LD_VAR 0 5
89583: PUSH
89584: LD_VAR 0 1
89588: PPUSH
89589: CALL_OW 250
89593: PUSH
89594: LD_VAR 0 1
89598: PPUSH
89599: CALL_OW 251
89603: PUSH
89604: LD_VAR 0 1
89608: PPUSH
89609: CALL_OW 254
89613: PUSH
89614: EMPTY
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: PPUSH
89620: CALL 25021 0 3
89624: ST_TO_ADDR
// if pos = 1 then
89625: LD_VAR 0 6
89629: PUSH
89630: LD_INT 1
89632: EQUAL
89633: IFFALSE 89748
// begin tmp := mc_build_list [ i ] ;
89635: LD_ADDR_VAR 0 7
89639: PUSH
89640: LD_EXP 36
89644: PUSH
89645: LD_VAR 0 3
89649: ARRAY
89650: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89651: LD_VAR 0 7
89655: PPUSH
89656: LD_INT 2
89658: PUSH
89659: LD_INT 30
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 30
89671: PUSH
89672: LD_INT 1
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: LIST
89683: PPUSH
89684: CALL_OW 72
89688: IFFALSE 89698
// pos := 2 ;
89690: LD_ADDR_VAR 0 6
89694: PUSH
89695: LD_INT 2
89697: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89698: LD_ADDR_VAR 0 7
89702: PUSH
89703: LD_VAR 0 7
89707: PPUSH
89708: LD_VAR 0 6
89712: PPUSH
89713: LD_VAR 0 7
89717: PPUSH
89718: CALL 25347 0 3
89722: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89723: LD_ADDR_EXP 36
89727: PUSH
89728: LD_EXP 36
89732: PPUSH
89733: LD_VAR 0 3
89737: PPUSH
89738: LD_VAR 0 7
89742: PPUSH
89743: CALL_OW 1
89747: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
89748: LD_VAR 0 1
89752: PUSH
89753: LD_EXP 31
89757: PUSH
89758: LD_VAR 0 3
89762: ARRAY
89763: IN
89764: IFFALSE 89803
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
89766: LD_ADDR_EXP 31
89770: PUSH
89771: LD_EXP 31
89775: PPUSH
89776: LD_VAR 0 3
89780: PPUSH
89781: LD_EXP 31
89785: PUSH
89786: LD_VAR 0 3
89790: ARRAY
89791: PUSH
89792: LD_VAR 0 1
89796: DIFF
89797: PPUSH
89798: CALL_OW 1
89802: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
89803: LD_VAR 0 1
89807: PUSH
89808: LD_EXP 38
89812: PUSH
89813: LD_VAR 0 3
89817: ARRAY
89818: IN
89819: IFFALSE 89858
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
89821: LD_ADDR_EXP 38
89825: PUSH
89826: LD_EXP 38
89830: PPUSH
89831: LD_VAR 0 3
89835: PPUSH
89836: LD_EXP 38
89840: PUSH
89841: LD_VAR 0 3
89845: ARRAY
89846: PUSH
89847: LD_VAR 0 1
89851: DIFF
89852: PPUSH
89853: CALL_OW 1
89857: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
89858: LD_VAR 0 1
89862: PUSH
89863: LD_EXP 50
89867: PUSH
89868: LD_VAR 0 3
89872: ARRAY
89873: IN
89874: IFFALSE 89913
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
89876: LD_ADDR_EXP 50
89880: PUSH
89881: LD_EXP 50
89885: PPUSH
89886: LD_VAR 0 3
89890: PPUSH
89891: LD_EXP 50
89895: PUSH
89896: LD_VAR 0 3
89900: ARRAY
89901: PUSH
89902: LD_VAR 0 1
89906: DIFF
89907: PPUSH
89908: CALL_OW 1
89912: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
89913: LD_VAR 0 1
89917: PUSH
89918: LD_EXP 53
89922: PUSH
89923: LD_VAR 0 3
89927: ARRAY
89928: IN
89929: IFFALSE 89968
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89931: LD_ADDR_EXP 53
89935: PUSH
89936: LD_EXP 53
89940: PPUSH
89941: LD_VAR 0 3
89945: PPUSH
89946: LD_EXP 53
89950: PUSH
89951: LD_VAR 0 3
89955: ARRAY
89956: PUSH
89957: LD_VAR 0 1
89961: DIFF
89962: PPUSH
89963: CALL_OW 1
89967: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
89968: LD_VAR 0 1
89972: PUSH
89973: LD_EXP 40
89977: PUSH
89978: LD_VAR 0 3
89982: ARRAY
89983: IN
89984: IFFALSE 90023
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
89986: LD_ADDR_EXP 40
89990: PUSH
89991: LD_EXP 40
89995: PPUSH
89996: LD_VAR 0 3
90000: PPUSH
90001: LD_EXP 40
90005: PUSH
90006: LD_VAR 0 3
90010: ARRAY
90011: PUSH
90012: LD_VAR 0 1
90016: DIFF
90017: PPUSH
90018: CALL_OW 1
90022: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90023: LD_VAR 0 1
90027: PUSH
90028: LD_EXP 39
90032: PUSH
90033: LD_VAR 0 3
90037: ARRAY
90038: IN
90039: IFFALSE 90078
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90041: LD_ADDR_EXP 39
90045: PUSH
90046: LD_EXP 39
90050: PPUSH
90051: LD_VAR 0 3
90055: PPUSH
90056: LD_EXP 39
90060: PUSH
90061: LD_VAR 0 3
90065: ARRAY
90066: PUSH
90067: LD_VAR 0 1
90071: DIFF
90072: PPUSH
90073: CALL_OW 1
90077: ST_TO_ADDR
// end ; break ;
90078: GO 90082
// end ;
90080: GO 88730
90082: POP
90083: POP
// end ;
90084: LD_VAR 0 2
90088: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90089: LD_INT 0
90091: PPUSH
90092: PPUSH
90093: PPUSH
// if not mc_bases or not skirmish then
90094: LD_EXP 31
90098: NOT
90099: PUSH
90100: LD_EXP 29
90104: NOT
90105: OR
90106: IFFALSE 90110
// exit ;
90108: GO 90325
// for i = 1 to mc_bases do
90110: LD_ADDR_VAR 0 3
90114: PUSH
90115: DOUBLE
90116: LD_INT 1
90118: DEC
90119: ST_TO_ADDR
90120: LD_EXP 31
90124: PUSH
90125: FOR_TO
90126: IFFALSE 90323
// begin if building in mc_construct_list [ i ] then
90128: LD_VAR 0 1
90132: PUSH
90133: LD_EXP 38
90137: PUSH
90138: LD_VAR 0 3
90142: ARRAY
90143: IN
90144: IFFALSE 90321
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90146: LD_ADDR_EXP 38
90150: PUSH
90151: LD_EXP 38
90155: PPUSH
90156: LD_VAR 0 3
90160: PPUSH
90161: LD_EXP 38
90165: PUSH
90166: LD_VAR 0 3
90170: ARRAY
90171: PUSH
90172: LD_VAR 0 1
90176: DIFF
90177: PPUSH
90178: CALL_OW 1
90182: ST_TO_ADDR
// if building in mc_lab [ i ] then
90183: LD_VAR 0 1
90187: PUSH
90188: LD_EXP 64
90192: PUSH
90193: LD_VAR 0 3
90197: ARRAY
90198: IN
90199: IFFALSE 90254
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90201: LD_ADDR_EXP 65
90205: PUSH
90206: LD_EXP 65
90210: PPUSH
90211: LD_VAR 0 3
90215: PPUSH
90216: LD_EXP 65
90220: PUSH
90221: LD_VAR 0 3
90225: ARRAY
90226: PPUSH
90227: LD_INT 1
90229: PPUSH
90230: LD_EXP 65
90234: PUSH
90235: LD_VAR 0 3
90239: ARRAY
90240: PPUSH
90241: LD_INT 0
90243: PPUSH
90244: CALL 24439 0 4
90248: PPUSH
90249: CALL_OW 1
90253: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90254: LD_VAR 0 1
90258: PUSH
90259: LD_EXP 31
90263: PUSH
90264: LD_VAR 0 3
90268: ARRAY
90269: IN
90270: NOT
90271: IFFALSE 90317
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90273: LD_ADDR_EXP 31
90277: PUSH
90278: LD_EXP 31
90282: PPUSH
90283: LD_VAR 0 3
90287: PUSH
90288: LD_EXP 31
90292: PUSH
90293: LD_VAR 0 3
90297: ARRAY
90298: PUSH
90299: LD_INT 1
90301: PLUS
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PPUSH
90307: LD_VAR 0 1
90311: PPUSH
90312: CALL 25021 0 3
90316: ST_TO_ADDR
// exit ;
90317: POP
90318: POP
90319: GO 90325
// end ; end ;
90321: GO 90125
90323: POP
90324: POP
// end ;
90325: LD_VAR 0 2
90329: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90330: LD_INT 0
90332: PPUSH
90333: PPUSH
90334: PPUSH
90335: PPUSH
90336: PPUSH
90337: PPUSH
90338: PPUSH
// if not mc_bases or not skirmish then
90339: LD_EXP 31
90343: NOT
90344: PUSH
90345: LD_EXP 29
90349: NOT
90350: OR
90351: IFFALSE 90355
// exit ;
90353: GO 91016
// for i = 1 to mc_bases do
90355: LD_ADDR_VAR 0 3
90359: PUSH
90360: DOUBLE
90361: LD_INT 1
90363: DEC
90364: ST_TO_ADDR
90365: LD_EXP 31
90369: PUSH
90370: FOR_TO
90371: IFFALSE 91014
// begin if building in mc_construct_list [ i ] then
90373: LD_VAR 0 1
90377: PUSH
90378: LD_EXP 38
90382: PUSH
90383: LD_VAR 0 3
90387: ARRAY
90388: IN
90389: IFFALSE 91012
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90391: LD_ADDR_EXP 38
90395: PUSH
90396: LD_EXP 38
90400: PPUSH
90401: LD_VAR 0 3
90405: PPUSH
90406: LD_EXP 38
90410: PUSH
90411: LD_VAR 0 3
90415: ARRAY
90416: PUSH
90417: LD_VAR 0 1
90421: DIFF
90422: PPUSH
90423: CALL_OW 1
90427: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90428: LD_ADDR_EXP 31
90432: PUSH
90433: LD_EXP 31
90437: PPUSH
90438: LD_VAR 0 3
90442: PUSH
90443: LD_EXP 31
90447: PUSH
90448: LD_VAR 0 3
90452: ARRAY
90453: PUSH
90454: LD_INT 1
90456: PLUS
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PPUSH
90462: LD_VAR 0 1
90466: PPUSH
90467: CALL 25021 0 3
90471: ST_TO_ADDR
// btype := GetBType ( building ) ;
90472: LD_ADDR_VAR 0 5
90476: PUSH
90477: LD_VAR 0 1
90481: PPUSH
90482: CALL_OW 266
90486: ST_TO_ADDR
// side := GetSide ( building ) ;
90487: LD_ADDR_VAR 0 8
90491: PUSH
90492: LD_VAR 0 1
90496: PPUSH
90497: CALL_OW 255
90501: ST_TO_ADDR
// if btype = b_lab then
90502: LD_VAR 0 5
90506: PUSH
90507: LD_INT 6
90509: EQUAL
90510: IFFALSE 90560
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90512: LD_ADDR_EXP 64
90516: PUSH
90517: LD_EXP 64
90521: PPUSH
90522: LD_VAR 0 3
90526: PUSH
90527: LD_EXP 64
90531: PUSH
90532: LD_VAR 0 3
90536: ARRAY
90537: PUSH
90538: LD_INT 1
90540: PLUS
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PPUSH
90546: LD_VAR 0 1
90550: PPUSH
90551: CALL 25021 0 3
90555: ST_TO_ADDR
// exit ;
90556: POP
90557: POP
90558: GO 91016
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90560: LD_VAR 0 5
90564: PUSH
90565: LD_INT 0
90567: PUSH
90568: LD_INT 2
90570: PUSH
90571: LD_INT 4
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: IN
90579: IFFALSE 90703
// begin if btype = b_armoury then
90581: LD_VAR 0 5
90585: PUSH
90586: LD_INT 4
90588: EQUAL
90589: IFFALSE 90599
// btype := b_barracks ;
90591: LD_ADDR_VAR 0 5
90595: PUSH
90596: LD_INT 5
90598: ST_TO_ADDR
// if btype = b_depot then
90599: LD_VAR 0 5
90603: PUSH
90604: LD_INT 0
90606: EQUAL
90607: IFFALSE 90617
// btype := b_warehouse ;
90609: LD_ADDR_VAR 0 5
90613: PUSH
90614: LD_INT 1
90616: ST_TO_ADDR
// if btype = b_workshop then
90617: LD_VAR 0 5
90621: PUSH
90622: LD_INT 2
90624: EQUAL
90625: IFFALSE 90635
// btype := b_factory ;
90627: LD_ADDR_VAR 0 5
90631: PUSH
90632: LD_INT 3
90634: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90635: LD_VAR 0 5
90639: PPUSH
90640: LD_VAR 0 8
90644: PPUSH
90645: CALL_OW 323
90649: PUSH
90650: LD_INT 1
90652: EQUAL
90653: IFFALSE 90699
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90655: LD_ADDR_EXP 63
90659: PUSH
90660: LD_EXP 63
90664: PPUSH
90665: LD_VAR 0 3
90669: PUSH
90670: LD_EXP 63
90674: PUSH
90675: LD_VAR 0 3
90679: ARRAY
90680: PUSH
90681: LD_INT 1
90683: PLUS
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PPUSH
90689: LD_VAR 0 1
90693: PPUSH
90694: CALL 25021 0 3
90698: ST_TO_ADDR
// exit ;
90699: POP
90700: POP
90701: GO 91016
// end ; if btype in [ b_bunker , b_turret ] then
90703: LD_VAR 0 5
90707: PUSH
90708: LD_INT 32
90710: PUSH
90711: LD_INT 33
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: IN
90718: IFFALSE 91008
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90720: LD_ADDR_EXP 39
90724: PUSH
90725: LD_EXP 39
90729: PPUSH
90730: LD_VAR 0 3
90734: PUSH
90735: LD_EXP 39
90739: PUSH
90740: LD_VAR 0 3
90744: ARRAY
90745: PUSH
90746: LD_INT 1
90748: PLUS
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PPUSH
90754: LD_VAR 0 1
90758: PPUSH
90759: CALL 25021 0 3
90763: ST_TO_ADDR
// if btype = b_bunker then
90764: LD_VAR 0 5
90768: PUSH
90769: LD_INT 32
90771: EQUAL
90772: IFFALSE 91008
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90774: LD_ADDR_EXP 40
90778: PUSH
90779: LD_EXP 40
90783: PPUSH
90784: LD_VAR 0 3
90788: PUSH
90789: LD_EXP 40
90793: PUSH
90794: LD_VAR 0 3
90798: ARRAY
90799: PUSH
90800: LD_INT 1
90802: PLUS
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PPUSH
90808: LD_VAR 0 1
90812: PPUSH
90813: CALL 25021 0 3
90817: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
90818: LD_ADDR_VAR 0 6
90822: PUSH
90823: LD_EXP 31
90827: PUSH
90828: LD_VAR 0 3
90832: ARRAY
90833: PPUSH
90834: LD_INT 25
90836: PUSH
90837: LD_INT 1
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 3
90846: PUSH
90847: LD_INT 54
90849: PUSH
90850: EMPTY
90851: LIST
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PPUSH
90861: CALL_OW 72
90865: ST_TO_ADDR
// if tmp then
90866: LD_VAR 0 6
90870: IFFALSE 90876
// exit ;
90872: POP
90873: POP
90874: GO 91016
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
90876: LD_ADDR_VAR 0 6
90880: PUSH
90881: LD_EXP 31
90885: PUSH
90886: LD_VAR 0 3
90890: ARRAY
90891: PPUSH
90892: LD_INT 2
90894: PUSH
90895: LD_INT 30
90897: PUSH
90898: LD_INT 4
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 30
90907: PUSH
90908: LD_INT 5
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: LIST
90919: PPUSH
90920: CALL_OW 72
90924: ST_TO_ADDR
// if not tmp then
90925: LD_VAR 0 6
90929: NOT
90930: IFFALSE 90936
// exit ;
90932: POP
90933: POP
90934: GO 91016
// for j in tmp do
90936: LD_ADDR_VAR 0 4
90940: PUSH
90941: LD_VAR 0 6
90945: PUSH
90946: FOR_IN
90947: IFFALSE 91006
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
90949: LD_ADDR_VAR 0 7
90953: PUSH
90954: LD_VAR 0 4
90958: PPUSH
90959: CALL_OW 313
90963: PPUSH
90964: LD_INT 25
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PPUSH
90974: CALL_OW 72
90978: ST_TO_ADDR
// if units then
90979: LD_VAR 0 7
90983: IFFALSE 91004
// begin ComExitBuilding ( units [ 1 ] ) ;
90985: LD_VAR 0 7
90989: PUSH
90990: LD_INT 1
90992: ARRAY
90993: PPUSH
90994: CALL_OW 122
// exit ;
90998: POP
90999: POP
91000: POP
91001: POP
91002: GO 91016
// end ; end ;
91004: GO 90946
91006: POP
91007: POP
// end ; end ; exit ;
91008: POP
91009: POP
91010: GO 91016
// end ; end ;
91012: GO 90370
91014: POP
91015: POP
// end ;
91016: LD_VAR 0 2
91020: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91021: LD_INT 0
91023: PPUSH
91024: PPUSH
91025: PPUSH
91026: PPUSH
91027: PPUSH
91028: PPUSH
91029: PPUSH
// if not mc_bases or not skirmish then
91030: LD_EXP 31
91034: NOT
91035: PUSH
91036: LD_EXP 29
91040: NOT
91041: OR
91042: IFFALSE 91046
// exit ;
91044: GO 91311
// btype := GetBType ( building ) ;
91046: LD_ADDR_VAR 0 6
91050: PUSH
91051: LD_VAR 0 1
91055: PPUSH
91056: CALL_OW 266
91060: ST_TO_ADDR
// x := GetX ( building ) ;
91061: LD_ADDR_VAR 0 7
91065: PUSH
91066: LD_VAR 0 1
91070: PPUSH
91071: CALL_OW 250
91075: ST_TO_ADDR
// y := GetY ( building ) ;
91076: LD_ADDR_VAR 0 8
91080: PUSH
91081: LD_VAR 0 1
91085: PPUSH
91086: CALL_OW 251
91090: ST_TO_ADDR
// d := GetDir ( building ) ;
91091: LD_ADDR_VAR 0 9
91095: PUSH
91096: LD_VAR 0 1
91100: PPUSH
91101: CALL_OW 254
91105: ST_TO_ADDR
// for i = 1 to mc_bases do
91106: LD_ADDR_VAR 0 4
91110: PUSH
91111: DOUBLE
91112: LD_INT 1
91114: DEC
91115: ST_TO_ADDR
91116: LD_EXP 31
91120: PUSH
91121: FOR_TO
91122: IFFALSE 91309
// begin if not mc_build_list [ i ] then
91124: LD_EXP 36
91128: PUSH
91129: LD_VAR 0 4
91133: ARRAY
91134: NOT
91135: IFFALSE 91139
// continue ;
91137: GO 91121
// for j := 1 to mc_build_list [ i ] do
91139: LD_ADDR_VAR 0 5
91143: PUSH
91144: DOUBLE
91145: LD_INT 1
91147: DEC
91148: ST_TO_ADDR
91149: LD_EXP 36
91153: PUSH
91154: LD_VAR 0 4
91158: ARRAY
91159: PUSH
91160: FOR_TO
91161: IFFALSE 91305
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91163: LD_VAR 0 6
91167: PUSH
91168: LD_VAR 0 7
91172: PUSH
91173: LD_VAR 0 8
91177: PUSH
91178: LD_VAR 0 9
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: PPUSH
91189: LD_EXP 36
91193: PUSH
91194: LD_VAR 0 4
91198: ARRAY
91199: PUSH
91200: LD_VAR 0 5
91204: ARRAY
91205: PPUSH
91206: CALL 31201 0 2
91210: IFFALSE 91303
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91212: LD_ADDR_EXP 36
91216: PUSH
91217: LD_EXP 36
91221: PPUSH
91222: LD_VAR 0 4
91226: PPUSH
91227: LD_EXP 36
91231: PUSH
91232: LD_VAR 0 4
91236: ARRAY
91237: PPUSH
91238: LD_VAR 0 5
91242: PPUSH
91243: CALL_OW 3
91247: PPUSH
91248: CALL_OW 1
91252: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91253: LD_ADDR_EXP 38
91257: PUSH
91258: LD_EXP 38
91262: PPUSH
91263: LD_VAR 0 4
91267: PUSH
91268: LD_EXP 38
91272: PUSH
91273: LD_VAR 0 4
91277: ARRAY
91278: PUSH
91279: LD_INT 1
91281: PLUS
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PPUSH
91287: LD_VAR 0 1
91291: PPUSH
91292: CALL 25021 0 3
91296: ST_TO_ADDR
// exit ;
91297: POP
91298: POP
91299: POP
91300: POP
91301: GO 91311
// end ;
91303: GO 91160
91305: POP
91306: POP
// end ;
91307: GO 91121
91309: POP
91310: POP
// end ;
91311: LD_VAR 0 3
91315: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91316: LD_INT 0
91318: PPUSH
91319: PPUSH
91320: PPUSH
// if not mc_bases or not skirmish then
91321: LD_EXP 31
91325: NOT
91326: PUSH
91327: LD_EXP 29
91331: NOT
91332: OR
91333: IFFALSE 91337
// exit ;
91335: GO 91527
// for i = 1 to mc_bases do
91337: LD_ADDR_VAR 0 4
91341: PUSH
91342: DOUBLE
91343: LD_INT 1
91345: DEC
91346: ST_TO_ADDR
91347: LD_EXP 31
91351: PUSH
91352: FOR_TO
91353: IFFALSE 91440
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91355: LD_VAR 0 1
91359: PUSH
91360: LD_EXP 39
91364: PUSH
91365: LD_VAR 0 4
91369: ARRAY
91370: IN
91371: PUSH
91372: LD_VAR 0 1
91376: PUSH
91377: LD_EXP 40
91381: PUSH
91382: LD_VAR 0 4
91386: ARRAY
91387: IN
91388: NOT
91389: AND
91390: IFFALSE 91438
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91392: LD_ADDR_EXP 40
91396: PUSH
91397: LD_EXP 40
91401: PPUSH
91402: LD_VAR 0 4
91406: PUSH
91407: LD_EXP 40
91411: PUSH
91412: LD_VAR 0 4
91416: ARRAY
91417: PUSH
91418: LD_INT 1
91420: PLUS
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PPUSH
91426: LD_VAR 0 1
91430: PPUSH
91431: CALL 25021 0 3
91435: ST_TO_ADDR
// break ;
91436: GO 91440
// end ; end ;
91438: GO 91352
91440: POP
91441: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91442: LD_VAR 0 1
91446: PPUSH
91447: CALL_OW 257
91451: PUSH
91452: LD_EXP 57
91456: IN
91457: PUSH
91458: LD_VAR 0 1
91462: PPUSH
91463: CALL_OW 266
91467: PUSH
91468: LD_INT 5
91470: EQUAL
91471: AND
91472: PUSH
91473: LD_VAR 0 2
91477: PPUSH
91478: CALL_OW 110
91482: PUSH
91483: LD_INT 18
91485: NONEQUAL
91486: AND
91487: IFFALSE 91527
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91489: LD_VAR 0 2
91493: PPUSH
91494: CALL_OW 257
91498: PUSH
91499: LD_INT 5
91501: PUSH
91502: LD_INT 8
91504: PUSH
91505: LD_INT 9
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: LIST
91512: IN
91513: IFFALSE 91527
// SetClass ( unit , 1 ) ;
91515: LD_VAR 0 2
91519: PPUSH
91520: LD_INT 1
91522: PPUSH
91523: CALL_OW 336
// end ;
91527: LD_VAR 0 3
91531: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91532: LD_INT 0
91534: PPUSH
91535: PPUSH
// if not mc_bases or not skirmish then
91536: LD_EXP 31
91540: NOT
91541: PUSH
91542: LD_EXP 29
91546: NOT
91547: OR
91548: IFFALSE 91552
// exit ;
91550: GO 91668
// if GetLives ( abandoned_vehicle ) > 250 then
91552: LD_VAR 0 2
91556: PPUSH
91557: CALL_OW 256
91561: PUSH
91562: LD_INT 250
91564: GREATER
91565: IFFALSE 91569
// exit ;
91567: GO 91668
// for i = 1 to mc_bases do
91569: LD_ADDR_VAR 0 6
91573: PUSH
91574: DOUBLE
91575: LD_INT 1
91577: DEC
91578: ST_TO_ADDR
91579: LD_EXP 31
91583: PUSH
91584: FOR_TO
91585: IFFALSE 91666
// begin if driver in mc_bases [ i ] then
91587: LD_VAR 0 1
91591: PUSH
91592: LD_EXP 31
91596: PUSH
91597: LD_VAR 0 6
91601: ARRAY
91602: IN
91603: IFFALSE 91664
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91605: LD_VAR 0 1
91609: PPUSH
91610: LD_EXP 31
91614: PUSH
91615: LD_VAR 0 6
91619: ARRAY
91620: PPUSH
91621: LD_INT 2
91623: PUSH
91624: LD_INT 30
91626: PUSH
91627: LD_INT 0
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 30
91636: PUSH
91637: LD_INT 1
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: LIST
91648: PPUSH
91649: CALL_OW 72
91653: PUSH
91654: LD_INT 1
91656: ARRAY
91657: PPUSH
91658: CALL 58137 0 2
// break ;
91662: GO 91666
// end ; end ;
91664: GO 91584
91666: POP
91667: POP
// end ; end_of_file end_of_file
91668: LD_VAR 0 5
91672: RET
// every 0 0$1 do
91673: GO 91675
91675: DISABLE
// begin enable ;
91676: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91677: LD_STRING updateTimer(
91679: PUSH
91680: LD_OWVAR 1
91684: STR
91685: PUSH
91686: LD_STRING );
91688: STR
91689: PPUSH
91690: CALL_OW 559
// end ;
91694: END
// export function SOS_MapStart ( ) ; begin
91695: LD_INT 0
91697: PPUSH
// if streamModeActive then
91698: LD_EXP 75
91702: IFFALSE 91711
// DefineStreamItems ( true ) ;
91704: LD_INT 1
91706: PPUSH
91707: CALL 93365 0 1
// UpdateFactoryWaypoints ( ) ;
91711: CALL 106226 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91715: CALL 106483 0 0
// end ;
91719: LD_VAR 0 1
91723: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91724: LD_INT 0
91726: PPUSH
// if p2 = 100 then
91727: LD_VAR 0 2
91731: PUSH
91732: LD_INT 100
91734: EQUAL
91735: IFFALSE 92738
// begin if not StreamModeActive then
91737: LD_EXP 75
91741: NOT
91742: IFFALSE 91752
// StreamModeActive := true ;
91744: LD_ADDR_EXP 75
91748: PUSH
91749: LD_INT 1
91751: ST_TO_ADDR
// if p3 = 0 then
91752: LD_VAR 0 3
91756: PUSH
91757: LD_INT 0
91759: EQUAL
91760: IFFALSE 91766
// InitStreamMode ;
91762: CALL 92901 0 0
// if p3 = 1 then
91766: LD_VAR 0 3
91770: PUSH
91771: LD_INT 1
91773: EQUAL
91774: IFFALSE 91784
// sRocket := true ;
91776: LD_ADDR_EXP 80
91780: PUSH
91781: LD_INT 1
91783: ST_TO_ADDR
// if p3 = 2 then
91784: LD_VAR 0 3
91788: PUSH
91789: LD_INT 2
91791: EQUAL
91792: IFFALSE 91802
// sSpeed := true ;
91794: LD_ADDR_EXP 79
91798: PUSH
91799: LD_INT 1
91801: ST_TO_ADDR
// if p3 = 3 then
91802: LD_VAR 0 3
91806: PUSH
91807: LD_INT 3
91809: EQUAL
91810: IFFALSE 91820
// sEngine := true ;
91812: LD_ADDR_EXP 81
91816: PUSH
91817: LD_INT 1
91819: ST_TO_ADDR
// if p3 = 4 then
91820: LD_VAR 0 3
91824: PUSH
91825: LD_INT 4
91827: EQUAL
91828: IFFALSE 91838
// sSpec := true ;
91830: LD_ADDR_EXP 78
91834: PUSH
91835: LD_INT 1
91837: ST_TO_ADDR
// if p3 = 5 then
91838: LD_VAR 0 3
91842: PUSH
91843: LD_INT 5
91845: EQUAL
91846: IFFALSE 91856
// sLevel := true ;
91848: LD_ADDR_EXP 82
91852: PUSH
91853: LD_INT 1
91855: ST_TO_ADDR
// if p3 = 6 then
91856: LD_VAR 0 3
91860: PUSH
91861: LD_INT 6
91863: EQUAL
91864: IFFALSE 91874
// sArmoury := true ;
91866: LD_ADDR_EXP 83
91870: PUSH
91871: LD_INT 1
91873: ST_TO_ADDR
// if p3 = 7 then
91874: LD_VAR 0 3
91878: PUSH
91879: LD_INT 7
91881: EQUAL
91882: IFFALSE 91892
// sRadar := true ;
91884: LD_ADDR_EXP 84
91888: PUSH
91889: LD_INT 1
91891: ST_TO_ADDR
// if p3 = 8 then
91892: LD_VAR 0 3
91896: PUSH
91897: LD_INT 8
91899: EQUAL
91900: IFFALSE 91910
// sBunker := true ;
91902: LD_ADDR_EXP 85
91906: PUSH
91907: LD_INT 1
91909: ST_TO_ADDR
// if p3 = 9 then
91910: LD_VAR 0 3
91914: PUSH
91915: LD_INT 9
91917: EQUAL
91918: IFFALSE 91928
// sHack := true ;
91920: LD_ADDR_EXP 86
91924: PUSH
91925: LD_INT 1
91927: ST_TO_ADDR
// if p3 = 10 then
91928: LD_VAR 0 3
91932: PUSH
91933: LD_INT 10
91935: EQUAL
91936: IFFALSE 91946
// sFire := true ;
91938: LD_ADDR_EXP 87
91942: PUSH
91943: LD_INT 1
91945: ST_TO_ADDR
// if p3 = 11 then
91946: LD_VAR 0 3
91950: PUSH
91951: LD_INT 11
91953: EQUAL
91954: IFFALSE 91964
// sRefresh := true ;
91956: LD_ADDR_EXP 88
91960: PUSH
91961: LD_INT 1
91963: ST_TO_ADDR
// if p3 = 12 then
91964: LD_VAR 0 3
91968: PUSH
91969: LD_INT 12
91971: EQUAL
91972: IFFALSE 91982
// sExp := true ;
91974: LD_ADDR_EXP 89
91978: PUSH
91979: LD_INT 1
91981: ST_TO_ADDR
// if p3 = 13 then
91982: LD_VAR 0 3
91986: PUSH
91987: LD_INT 13
91989: EQUAL
91990: IFFALSE 92000
// sDepot := true ;
91992: LD_ADDR_EXP 90
91996: PUSH
91997: LD_INT 1
91999: ST_TO_ADDR
// if p3 = 14 then
92000: LD_VAR 0 3
92004: PUSH
92005: LD_INT 14
92007: EQUAL
92008: IFFALSE 92018
// sFlag := true ;
92010: LD_ADDR_EXP 91
92014: PUSH
92015: LD_INT 1
92017: ST_TO_ADDR
// if p3 = 15 then
92018: LD_VAR 0 3
92022: PUSH
92023: LD_INT 15
92025: EQUAL
92026: IFFALSE 92036
// sKamikadze := true ;
92028: LD_ADDR_EXP 99
92032: PUSH
92033: LD_INT 1
92035: ST_TO_ADDR
// if p3 = 16 then
92036: LD_VAR 0 3
92040: PUSH
92041: LD_INT 16
92043: EQUAL
92044: IFFALSE 92054
// sTroll := true ;
92046: LD_ADDR_EXP 100
92050: PUSH
92051: LD_INT 1
92053: ST_TO_ADDR
// if p3 = 17 then
92054: LD_VAR 0 3
92058: PUSH
92059: LD_INT 17
92061: EQUAL
92062: IFFALSE 92072
// sSlow := true ;
92064: LD_ADDR_EXP 101
92068: PUSH
92069: LD_INT 1
92071: ST_TO_ADDR
// if p3 = 18 then
92072: LD_VAR 0 3
92076: PUSH
92077: LD_INT 18
92079: EQUAL
92080: IFFALSE 92090
// sLack := true ;
92082: LD_ADDR_EXP 102
92086: PUSH
92087: LD_INT 1
92089: ST_TO_ADDR
// if p3 = 19 then
92090: LD_VAR 0 3
92094: PUSH
92095: LD_INT 19
92097: EQUAL
92098: IFFALSE 92108
// sTank := true ;
92100: LD_ADDR_EXP 104
92104: PUSH
92105: LD_INT 1
92107: ST_TO_ADDR
// if p3 = 20 then
92108: LD_VAR 0 3
92112: PUSH
92113: LD_INT 20
92115: EQUAL
92116: IFFALSE 92126
// sRemote := true ;
92118: LD_ADDR_EXP 105
92122: PUSH
92123: LD_INT 1
92125: ST_TO_ADDR
// if p3 = 21 then
92126: LD_VAR 0 3
92130: PUSH
92131: LD_INT 21
92133: EQUAL
92134: IFFALSE 92144
// sPowell := true ;
92136: LD_ADDR_EXP 106
92140: PUSH
92141: LD_INT 1
92143: ST_TO_ADDR
// if p3 = 22 then
92144: LD_VAR 0 3
92148: PUSH
92149: LD_INT 22
92151: EQUAL
92152: IFFALSE 92162
// sTeleport := true ;
92154: LD_ADDR_EXP 109
92158: PUSH
92159: LD_INT 1
92161: ST_TO_ADDR
// if p3 = 23 then
92162: LD_VAR 0 3
92166: PUSH
92167: LD_INT 23
92169: EQUAL
92170: IFFALSE 92180
// sOilTower := true ;
92172: LD_ADDR_EXP 111
92176: PUSH
92177: LD_INT 1
92179: ST_TO_ADDR
// if p3 = 24 then
92180: LD_VAR 0 3
92184: PUSH
92185: LD_INT 24
92187: EQUAL
92188: IFFALSE 92198
// sShovel := true ;
92190: LD_ADDR_EXP 112
92194: PUSH
92195: LD_INT 1
92197: ST_TO_ADDR
// if p3 = 25 then
92198: LD_VAR 0 3
92202: PUSH
92203: LD_INT 25
92205: EQUAL
92206: IFFALSE 92216
// sSheik := true ;
92208: LD_ADDR_EXP 113
92212: PUSH
92213: LD_INT 1
92215: ST_TO_ADDR
// if p3 = 26 then
92216: LD_VAR 0 3
92220: PUSH
92221: LD_INT 26
92223: EQUAL
92224: IFFALSE 92234
// sEarthquake := true ;
92226: LD_ADDR_EXP 115
92230: PUSH
92231: LD_INT 1
92233: ST_TO_ADDR
// if p3 = 27 then
92234: LD_VAR 0 3
92238: PUSH
92239: LD_INT 27
92241: EQUAL
92242: IFFALSE 92252
// sAI := true ;
92244: LD_ADDR_EXP 116
92248: PUSH
92249: LD_INT 1
92251: ST_TO_ADDR
// if p3 = 28 then
92252: LD_VAR 0 3
92256: PUSH
92257: LD_INT 28
92259: EQUAL
92260: IFFALSE 92270
// sCargo := true ;
92262: LD_ADDR_EXP 119
92266: PUSH
92267: LD_INT 1
92269: ST_TO_ADDR
// if p3 = 29 then
92270: LD_VAR 0 3
92274: PUSH
92275: LD_INT 29
92277: EQUAL
92278: IFFALSE 92288
// sDLaser := true ;
92280: LD_ADDR_EXP 120
92284: PUSH
92285: LD_INT 1
92287: ST_TO_ADDR
// if p3 = 30 then
92288: LD_VAR 0 3
92292: PUSH
92293: LD_INT 30
92295: EQUAL
92296: IFFALSE 92306
// sExchange := true ;
92298: LD_ADDR_EXP 121
92302: PUSH
92303: LD_INT 1
92305: ST_TO_ADDR
// if p3 = 31 then
92306: LD_VAR 0 3
92310: PUSH
92311: LD_INT 31
92313: EQUAL
92314: IFFALSE 92324
// sFac := true ;
92316: LD_ADDR_EXP 122
92320: PUSH
92321: LD_INT 1
92323: ST_TO_ADDR
// if p3 = 32 then
92324: LD_VAR 0 3
92328: PUSH
92329: LD_INT 32
92331: EQUAL
92332: IFFALSE 92342
// sPower := true ;
92334: LD_ADDR_EXP 123
92338: PUSH
92339: LD_INT 1
92341: ST_TO_ADDR
// if p3 = 33 then
92342: LD_VAR 0 3
92346: PUSH
92347: LD_INT 33
92349: EQUAL
92350: IFFALSE 92360
// sRandom := true ;
92352: LD_ADDR_EXP 124
92356: PUSH
92357: LD_INT 1
92359: ST_TO_ADDR
// if p3 = 34 then
92360: LD_VAR 0 3
92364: PUSH
92365: LD_INT 34
92367: EQUAL
92368: IFFALSE 92378
// sShield := true ;
92370: LD_ADDR_EXP 125
92374: PUSH
92375: LD_INT 1
92377: ST_TO_ADDR
// if p3 = 35 then
92378: LD_VAR 0 3
92382: PUSH
92383: LD_INT 35
92385: EQUAL
92386: IFFALSE 92396
// sTime := true ;
92388: LD_ADDR_EXP 126
92392: PUSH
92393: LD_INT 1
92395: ST_TO_ADDR
// if p3 = 36 then
92396: LD_VAR 0 3
92400: PUSH
92401: LD_INT 36
92403: EQUAL
92404: IFFALSE 92414
// sTools := true ;
92406: LD_ADDR_EXP 127
92410: PUSH
92411: LD_INT 1
92413: ST_TO_ADDR
// if p3 = 101 then
92414: LD_VAR 0 3
92418: PUSH
92419: LD_INT 101
92421: EQUAL
92422: IFFALSE 92432
// sSold := true ;
92424: LD_ADDR_EXP 92
92428: PUSH
92429: LD_INT 1
92431: ST_TO_ADDR
// if p3 = 102 then
92432: LD_VAR 0 3
92436: PUSH
92437: LD_INT 102
92439: EQUAL
92440: IFFALSE 92450
// sDiff := true ;
92442: LD_ADDR_EXP 93
92446: PUSH
92447: LD_INT 1
92449: ST_TO_ADDR
// if p3 = 103 then
92450: LD_VAR 0 3
92454: PUSH
92455: LD_INT 103
92457: EQUAL
92458: IFFALSE 92468
// sFog := true ;
92460: LD_ADDR_EXP 96
92464: PUSH
92465: LD_INT 1
92467: ST_TO_ADDR
// if p3 = 104 then
92468: LD_VAR 0 3
92472: PUSH
92473: LD_INT 104
92475: EQUAL
92476: IFFALSE 92486
// sReset := true ;
92478: LD_ADDR_EXP 97
92482: PUSH
92483: LD_INT 1
92485: ST_TO_ADDR
// if p3 = 105 then
92486: LD_VAR 0 3
92490: PUSH
92491: LD_INT 105
92493: EQUAL
92494: IFFALSE 92504
// sSun := true ;
92496: LD_ADDR_EXP 98
92500: PUSH
92501: LD_INT 1
92503: ST_TO_ADDR
// if p3 = 106 then
92504: LD_VAR 0 3
92508: PUSH
92509: LD_INT 106
92511: EQUAL
92512: IFFALSE 92522
// sTiger := true ;
92514: LD_ADDR_EXP 94
92518: PUSH
92519: LD_INT 1
92521: ST_TO_ADDR
// if p3 = 107 then
92522: LD_VAR 0 3
92526: PUSH
92527: LD_INT 107
92529: EQUAL
92530: IFFALSE 92540
// sBomb := true ;
92532: LD_ADDR_EXP 95
92536: PUSH
92537: LD_INT 1
92539: ST_TO_ADDR
// if p3 = 108 then
92540: LD_VAR 0 3
92544: PUSH
92545: LD_INT 108
92547: EQUAL
92548: IFFALSE 92558
// sWound := true ;
92550: LD_ADDR_EXP 103
92554: PUSH
92555: LD_INT 1
92557: ST_TO_ADDR
// if p3 = 109 then
92558: LD_VAR 0 3
92562: PUSH
92563: LD_INT 109
92565: EQUAL
92566: IFFALSE 92576
// sBetray := true ;
92568: LD_ADDR_EXP 107
92572: PUSH
92573: LD_INT 1
92575: ST_TO_ADDR
// if p3 = 110 then
92576: LD_VAR 0 3
92580: PUSH
92581: LD_INT 110
92583: EQUAL
92584: IFFALSE 92594
// sContamin := true ;
92586: LD_ADDR_EXP 108
92590: PUSH
92591: LD_INT 1
92593: ST_TO_ADDR
// if p3 = 111 then
92594: LD_VAR 0 3
92598: PUSH
92599: LD_INT 111
92601: EQUAL
92602: IFFALSE 92612
// sOil := true ;
92604: LD_ADDR_EXP 110
92608: PUSH
92609: LD_INT 1
92611: ST_TO_ADDR
// if p3 = 112 then
92612: LD_VAR 0 3
92616: PUSH
92617: LD_INT 112
92619: EQUAL
92620: IFFALSE 92630
// sStu := true ;
92622: LD_ADDR_EXP 114
92626: PUSH
92627: LD_INT 1
92629: ST_TO_ADDR
// if p3 = 113 then
92630: LD_VAR 0 3
92634: PUSH
92635: LD_INT 113
92637: EQUAL
92638: IFFALSE 92648
// sBazooka := true ;
92640: LD_ADDR_EXP 117
92644: PUSH
92645: LD_INT 1
92647: ST_TO_ADDR
// if p3 = 114 then
92648: LD_VAR 0 3
92652: PUSH
92653: LD_INT 114
92655: EQUAL
92656: IFFALSE 92666
// sMortar := true ;
92658: LD_ADDR_EXP 118
92662: PUSH
92663: LD_INT 1
92665: ST_TO_ADDR
// if p3 = 115 then
92666: LD_VAR 0 3
92670: PUSH
92671: LD_INT 115
92673: EQUAL
92674: IFFALSE 92684
// sRanger := true ;
92676: LD_ADDR_EXP 128
92680: PUSH
92681: LD_INT 1
92683: ST_TO_ADDR
// if p3 = 116 then
92684: LD_VAR 0 3
92688: PUSH
92689: LD_INT 116
92691: EQUAL
92692: IFFALSE 92702
// sComputer := true ;
92694: LD_ADDR_EXP 129
92698: PUSH
92699: LD_INT 1
92701: ST_TO_ADDR
// if p3 = 117 then
92702: LD_VAR 0 3
92706: PUSH
92707: LD_INT 117
92709: EQUAL
92710: IFFALSE 92720
// s30 := true ;
92712: LD_ADDR_EXP 130
92716: PUSH
92717: LD_INT 1
92719: ST_TO_ADDR
// if p3 = 118 then
92720: LD_VAR 0 3
92724: PUSH
92725: LD_INT 118
92727: EQUAL
92728: IFFALSE 92738
// s60 := true ;
92730: LD_ADDR_EXP 131
92734: PUSH
92735: LD_INT 1
92737: ST_TO_ADDR
// end ; if p2 = 101 then
92738: LD_VAR 0 2
92742: PUSH
92743: LD_INT 101
92745: EQUAL
92746: IFFALSE 92874
// begin case p3 of 1 :
92748: LD_VAR 0 3
92752: PUSH
92753: LD_INT 1
92755: DOUBLE
92756: EQUAL
92757: IFTRUE 92761
92759: GO 92768
92761: POP
// hHackUnlimitedResources ; 2 :
92762: CALL 104972 0 0
92766: GO 92874
92768: LD_INT 2
92770: DOUBLE
92771: EQUAL
92772: IFTRUE 92776
92774: GO 92783
92776: POP
// hHackSetLevel10 ; 3 :
92777: CALL 105105 0 0
92781: GO 92874
92783: LD_INT 3
92785: DOUBLE
92786: EQUAL
92787: IFTRUE 92791
92789: GO 92798
92791: POP
// hHackSetLevel10YourUnits ; 4 :
92792: CALL 105190 0 0
92796: GO 92874
92798: LD_INT 4
92800: DOUBLE
92801: EQUAL
92802: IFTRUE 92806
92804: GO 92813
92806: POP
// hHackInvincible ; 5 :
92807: CALL 105638 0 0
92811: GO 92874
92813: LD_INT 5
92815: DOUBLE
92816: EQUAL
92817: IFTRUE 92821
92819: GO 92828
92821: POP
// hHackInvisible ; 6 :
92822: CALL 105749 0 0
92826: GO 92874
92828: LD_INT 6
92830: DOUBLE
92831: EQUAL
92832: IFTRUE 92836
92834: GO 92843
92836: POP
// hHackChangeYourSide ; 7 :
92837: CALL 105806 0 0
92841: GO 92874
92843: LD_INT 7
92845: DOUBLE
92846: EQUAL
92847: IFTRUE 92851
92849: GO 92858
92851: POP
// hHackChangeUnitSide ; 8 :
92852: CALL 105848 0 0
92856: GO 92874
92858: LD_INT 8
92860: DOUBLE
92861: EQUAL
92862: IFTRUE 92866
92864: GO 92873
92866: POP
// hHackFog ; end ;
92867: CALL 105949 0 0
92871: GO 92874
92873: POP
// end ; end ;
92874: LD_VAR 0 7
92878: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
92879: GO 92881
92881: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92882: LD_STRING initStreamRollete();
92884: PPUSH
92885: CALL_OW 559
// InitStreamMode ;
92889: CALL 92901 0 0
// DefineStreamItems ( false ) ;
92893: LD_INT 0
92895: PPUSH
92896: CALL 93365 0 1
// end ;
92900: END
// function InitStreamMode ; begin
92901: LD_INT 0
92903: PPUSH
// streamModeActive := false ;
92904: LD_ADDR_EXP 75
92908: PUSH
92909: LD_INT 0
92911: ST_TO_ADDR
// normalCounter := 36 ;
92912: LD_ADDR_EXP 76
92916: PUSH
92917: LD_INT 36
92919: ST_TO_ADDR
// hardcoreCounter := 18 ;
92920: LD_ADDR_EXP 77
92924: PUSH
92925: LD_INT 18
92927: ST_TO_ADDR
// sRocket := false ;
92928: LD_ADDR_EXP 80
92932: PUSH
92933: LD_INT 0
92935: ST_TO_ADDR
// sSpeed := false ;
92936: LD_ADDR_EXP 79
92940: PUSH
92941: LD_INT 0
92943: ST_TO_ADDR
// sEngine := false ;
92944: LD_ADDR_EXP 81
92948: PUSH
92949: LD_INT 0
92951: ST_TO_ADDR
// sSpec := false ;
92952: LD_ADDR_EXP 78
92956: PUSH
92957: LD_INT 0
92959: ST_TO_ADDR
// sLevel := false ;
92960: LD_ADDR_EXP 82
92964: PUSH
92965: LD_INT 0
92967: ST_TO_ADDR
// sArmoury := false ;
92968: LD_ADDR_EXP 83
92972: PUSH
92973: LD_INT 0
92975: ST_TO_ADDR
// sRadar := false ;
92976: LD_ADDR_EXP 84
92980: PUSH
92981: LD_INT 0
92983: ST_TO_ADDR
// sBunker := false ;
92984: LD_ADDR_EXP 85
92988: PUSH
92989: LD_INT 0
92991: ST_TO_ADDR
// sHack := false ;
92992: LD_ADDR_EXP 86
92996: PUSH
92997: LD_INT 0
92999: ST_TO_ADDR
// sFire := false ;
93000: LD_ADDR_EXP 87
93004: PUSH
93005: LD_INT 0
93007: ST_TO_ADDR
// sRefresh := false ;
93008: LD_ADDR_EXP 88
93012: PUSH
93013: LD_INT 0
93015: ST_TO_ADDR
// sExp := false ;
93016: LD_ADDR_EXP 89
93020: PUSH
93021: LD_INT 0
93023: ST_TO_ADDR
// sDepot := false ;
93024: LD_ADDR_EXP 90
93028: PUSH
93029: LD_INT 0
93031: ST_TO_ADDR
// sFlag := false ;
93032: LD_ADDR_EXP 91
93036: PUSH
93037: LD_INT 0
93039: ST_TO_ADDR
// sKamikadze := false ;
93040: LD_ADDR_EXP 99
93044: PUSH
93045: LD_INT 0
93047: ST_TO_ADDR
// sTroll := false ;
93048: LD_ADDR_EXP 100
93052: PUSH
93053: LD_INT 0
93055: ST_TO_ADDR
// sSlow := false ;
93056: LD_ADDR_EXP 101
93060: PUSH
93061: LD_INT 0
93063: ST_TO_ADDR
// sLack := false ;
93064: LD_ADDR_EXP 102
93068: PUSH
93069: LD_INT 0
93071: ST_TO_ADDR
// sTank := false ;
93072: LD_ADDR_EXP 104
93076: PUSH
93077: LD_INT 0
93079: ST_TO_ADDR
// sRemote := false ;
93080: LD_ADDR_EXP 105
93084: PUSH
93085: LD_INT 0
93087: ST_TO_ADDR
// sPowell := false ;
93088: LD_ADDR_EXP 106
93092: PUSH
93093: LD_INT 0
93095: ST_TO_ADDR
// sTeleport := false ;
93096: LD_ADDR_EXP 109
93100: PUSH
93101: LD_INT 0
93103: ST_TO_ADDR
// sOilTower := false ;
93104: LD_ADDR_EXP 111
93108: PUSH
93109: LD_INT 0
93111: ST_TO_ADDR
// sShovel := false ;
93112: LD_ADDR_EXP 112
93116: PUSH
93117: LD_INT 0
93119: ST_TO_ADDR
// sSheik := false ;
93120: LD_ADDR_EXP 113
93124: PUSH
93125: LD_INT 0
93127: ST_TO_ADDR
// sEarthquake := false ;
93128: LD_ADDR_EXP 115
93132: PUSH
93133: LD_INT 0
93135: ST_TO_ADDR
// sAI := false ;
93136: LD_ADDR_EXP 116
93140: PUSH
93141: LD_INT 0
93143: ST_TO_ADDR
// sCargo := false ;
93144: LD_ADDR_EXP 119
93148: PUSH
93149: LD_INT 0
93151: ST_TO_ADDR
// sDLaser := false ;
93152: LD_ADDR_EXP 120
93156: PUSH
93157: LD_INT 0
93159: ST_TO_ADDR
// sExchange := false ;
93160: LD_ADDR_EXP 121
93164: PUSH
93165: LD_INT 0
93167: ST_TO_ADDR
// sFac := false ;
93168: LD_ADDR_EXP 122
93172: PUSH
93173: LD_INT 0
93175: ST_TO_ADDR
// sPower := false ;
93176: LD_ADDR_EXP 123
93180: PUSH
93181: LD_INT 0
93183: ST_TO_ADDR
// sRandom := false ;
93184: LD_ADDR_EXP 124
93188: PUSH
93189: LD_INT 0
93191: ST_TO_ADDR
// sShield := false ;
93192: LD_ADDR_EXP 125
93196: PUSH
93197: LD_INT 0
93199: ST_TO_ADDR
// sTime := false ;
93200: LD_ADDR_EXP 126
93204: PUSH
93205: LD_INT 0
93207: ST_TO_ADDR
// sTools := false ;
93208: LD_ADDR_EXP 127
93212: PUSH
93213: LD_INT 0
93215: ST_TO_ADDR
// sSold := false ;
93216: LD_ADDR_EXP 92
93220: PUSH
93221: LD_INT 0
93223: ST_TO_ADDR
// sDiff := false ;
93224: LD_ADDR_EXP 93
93228: PUSH
93229: LD_INT 0
93231: ST_TO_ADDR
// sFog := false ;
93232: LD_ADDR_EXP 96
93236: PUSH
93237: LD_INT 0
93239: ST_TO_ADDR
// sReset := false ;
93240: LD_ADDR_EXP 97
93244: PUSH
93245: LD_INT 0
93247: ST_TO_ADDR
// sSun := false ;
93248: LD_ADDR_EXP 98
93252: PUSH
93253: LD_INT 0
93255: ST_TO_ADDR
// sTiger := false ;
93256: LD_ADDR_EXP 94
93260: PUSH
93261: LD_INT 0
93263: ST_TO_ADDR
// sBomb := false ;
93264: LD_ADDR_EXP 95
93268: PUSH
93269: LD_INT 0
93271: ST_TO_ADDR
// sWound := false ;
93272: LD_ADDR_EXP 103
93276: PUSH
93277: LD_INT 0
93279: ST_TO_ADDR
// sBetray := false ;
93280: LD_ADDR_EXP 107
93284: PUSH
93285: LD_INT 0
93287: ST_TO_ADDR
// sContamin := false ;
93288: LD_ADDR_EXP 108
93292: PUSH
93293: LD_INT 0
93295: ST_TO_ADDR
// sOil := false ;
93296: LD_ADDR_EXP 110
93300: PUSH
93301: LD_INT 0
93303: ST_TO_ADDR
// sStu := false ;
93304: LD_ADDR_EXP 114
93308: PUSH
93309: LD_INT 0
93311: ST_TO_ADDR
// sBazooka := false ;
93312: LD_ADDR_EXP 117
93316: PUSH
93317: LD_INT 0
93319: ST_TO_ADDR
// sMortar := false ;
93320: LD_ADDR_EXP 118
93324: PUSH
93325: LD_INT 0
93327: ST_TO_ADDR
// sRanger := false ;
93328: LD_ADDR_EXP 128
93332: PUSH
93333: LD_INT 0
93335: ST_TO_ADDR
// sComputer := false ;
93336: LD_ADDR_EXP 129
93340: PUSH
93341: LD_INT 0
93343: ST_TO_ADDR
// s30 := false ;
93344: LD_ADDR_EXP 130
93348: PUSH
93349: LD_INT 0
93351: ST_TO_ADDR
// s60 := false ;
93352: LD_ADDR_EXP 131
93356: PUSH
93357: LD_INT 0
93359: ST_TO_ADDR
// end ;
93360: LD_VAR 0 1
93364: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93365: LD_INT 0
93367: PPUSH
93368: PPUSH
93369: PPUSH
93370: PPUSH
93371: PPUSH
93372: PPUSH
93373: PPUSH
// result := [ ] ;
93374: LD_ADDR_VAR 0 2
93378: PUSH
93379: EMPTY
93380: ST_TO_ADDR
// if campaign_id = 1 then
93381: LD_OWVAR 69
93385: PUSH
93386: LD_INT 1
93388: EQUAL
93389: IFFALSE 96555
// begin case mission_number of 1 :
93391: LD_OWVAR 70
93395: PUSH
93396: LD_INT 1
93398: DOUBLE
93399: EQUAL
93400: IFTRUE 93404
93402: GO 93480
93404: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93405: LD_ADDR_VAR 0 2
93409: PUSH
93410: LD_INT 2
93412: PUSH
93413: LD_INT 4
93415: PUSH
93416: LD_INT 11
93418: PUSH
93419: LD_INT 12
93421: PUSH
93422: LD_INT 15
93424: PUSH
93425: LD_INT 16
93427: PUSH
93428: LD_INT 22
93430: PUSH
93431: LD_INT 23
93433: PUSH
93434: LD_INT 26
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 101
93450: PUSH
93451: LD_INT 102
93453: PUSH
93454: LD_INT 106
93456: PUSH
93457: LD_INT 116
93459: PUSH
93460: LD_INT 117
93462: PUSH
93463: LD_INT 118
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: ST_TO_ADDR
93478: GO 96553
93480: LD_INT 2
93482: DOUBLE
93483: EQUAL
93484: IFTRUE 93488
93486: GO 93572
93488: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93489: LD_ADDR_VAR 0 2
93493: PUSH
93494: LD_INT 2
93496: PUSH
93497: LD_INT 4
93499: PUSH
93500: LD_INT 11
93502: PUSH
93503: LD_INT 12
93505: PUSH
93506: LD_INT 15
93508: PUSH
93509: LD_INT 16
93511: PUSH
93512: LD_INT 22
93514: PUSH
93515: LD_INT 23
93517: PUSH
93518: LD_INT 26
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 101
93534: PUSH
93535: LD_INT 102
93537: PUSH
93538: LD_INT 105
93540: PUSH
93541: LD_INT 106
93543: PUSH
93544: LD_INT 108
93546: PUSH
93547: LD_INT 116
93549: PUSH
93550: LD_INT 117
93552: PUSH
93553: LD_INT 118
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: ST_TO_ADDR
93570: GO 96553
93572: LD_INT 3
93574: DOUBLE
93575: EQUAL
93576: IFTRUE 93580
93578: GO 93668
93580: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93581: LD_ADDR_VAR 0 2
93585: PUSH
93586: LD_INT 2
93588: PUSH
93589: LD_INT 4
93591: PUSH
93592: LD_INT 5
93594: PUSH
93595: LD_INT 11
93597: PUSH
93598: LD_INT 12
93600: PUSH
93601: LD_INT 15
93603: PUSH
93604: LD_INT 16
93606: PUSH
93607: LD_INT 22
93609: PUSH
93610: LD_INT 26
93612: PUSH
93613: LD_INT 36
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: PUSH
93628: LD_INT 101
93630: PUSH
93631: LD_INT 102
93633: PUSH
93634: LD_INT 105
93636: PUSH
93637: LD_INT 106
93639: PUSH
93640: LD_INT 108
93642: PUSH
93643: LD_INT 116
93645: PUSH
93646: LD_INT 117
93648: PUSH
93649: LD_INT 118
93651: PUSH
93652: EMPTY
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: ST_TO_ADDR
93666: GO 96553
93668: LD_INT 4
93670: DOUBLE
93671: EQUAL
93672: IFTRUE 93676
93674: GO 93772
93676: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93677: LD_ADDR_VAR 0 2
93681: PUSH
93682: LD_INT 2
93684: PUSH
93685: LD_INT 4
93687: PUSH
93688: LD_INT 5
93690: PUSH
93691: LD_INT 8
93693: PUSH
93694: LD_INT 11
93696: PUSH
93697: LD_INT 12
93699: PUSH
93700: LD_INT 15
93702: PUSH
93703: LD_INT 16
93705: PUSH
93706: LD_INT 22
93708: PUSH
93709: LD_INT 23
93711: PUSH
93712: LD_INT 26
93714: PUSH
93715: LD_INT 36
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 101
93734: PUSH
93735: LD_INT 102
93737: PUSH
93738: LD_INT 105
93740: PUSH
93741: LD_INT 106
93743: PUSH
93744: LD_INT 108
93746: PUSH
93747: LD_INT 116
93749: PUSH
93750: LD_INT 117
93752: PUSH
93753: LD_INT 118
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: ST_TO_ADDR
93770: GO 96553
93772: LD_INT 5
93774: DOUBLE
93775: EQUAL
93776: IFTRUE 93780
93778: GO 93892
93780: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93781: LD_ADDR_VAR 0 2
93785: PUSH
93786: LD_INT 2
93788: PUSH
93789: LD_INT 4
93791: PUSH
93792: LD_INT 5
93794: PUSH
93795: LD_INT 6
93797: PUSH
93798: LD_INT 8
93800: PUSH
93801: LD_INT 11
93803: PUSH
93804: LD_INT 12
93806: PUSH
93807: LD_INT 15
93809: PUSH
93810: LD_INT 16
93812: PUSH
93813: LD_INT 22
93815: PUSH
93816: LD_INT 23
93818: PUSH
93819: LD_INT 25
93821: PUSH
93822: LD_INT 26
93824: PUSH
93825: LD_INT 36
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: PUSH
93844: LD_INT 101
93846: PUSH
93847: LD_INT 102
93849: PUSH
93850: LD_INT 105
93852: PUSH
93853: LD_INT 106
93855: PUSH
93856: LD_INT 108
93858: PUSH
93859: LD_INT 109
93861: PUSH
93862: LD_INT 112
93864: PUSH
93865: LD_INT 116
93867: PUSH
93868: LD_INT 117
93870: PUSH
93871: LD_INT 118
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: ST_TO_ADDR
93890: GO 96553
93892: LD_INT 6
93894: DOUBLE
93895: EQUAL
93896: IFTRUE 93900
93898: GO 94032
93900: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93901: LD_ADDR_VAR 0 2
93905: PUSH
93906: LD_INT 2
93908: PUSH
93909: LD_INT 4
93911: PUSH
93912: LD_INT 5
93914: PUSH
93915: LD_INT 6
93917: PUSH
93918: LD_INT 8
93920: PUSH
93921: LD_INT 11
93923: PUSH
93924: LD_INT 12
93926: PUSH
93927: LD_INT 15
93929: PUSH
93930: LD_INT 16
93932: PUSH
93933: LD_INT 20
93935: PUSH
93936: LD_INT 21
93938: PUSH
93939: LD_INT 22
93941: PUSH
93942: LD_INT 23
93944: PUSH
93945: LD_INT 25
93947: PUSH
93948: LD_INT 26
93950: PUSH
93951: LD_INT 30
93953: PUSH
93954: LD_INT 31
93956: PUSH
93957: LD_INT 32
93959: PUSH
93960: LD_INT 36
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 101
93986: PUSH
93987: LD_INT 102
93989: PUSH
93990: LD_INT 105
93992: PUSH
93993: LD_INT 106
93995: PUSH
93996: LD_INT 108
93998: PUSH
93999: LD_INT 109
94001: PUSH
94002: LD_INT 112
94004: PUSH
94005: LD_INT 116
94007: PUSH
94008: LD_INT 117
94010: PUSH
94011: LD_INT 118
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: PUSH
94026: EMPTY
94027: LIST
94028: LIST
94029: ST_TO_ADDR
94030: GO 96553
94032: LD_INT 7
94034: DOUBLE
94035: EQUAL
94036: IFTRUE 94040
94038: GO 94152
94040: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94041: LD_ADDR_VAR 0 2
94045: PUSH
94046: LD_INT 2
94048: PUSH
94049: LD_INT 4
94051: PUSH
94052: LD_INT 5
94054: PUSH
94055: LD_INT 7
94057: PUSH
94058: LD_INT 11
94060: PUSH
94061: LD_INT 12
94063: PUSH
94064: LD_INT 15
94066: PUSH
94067: LD_INT 16
94069: PUSH
94070: LD_INT 20
94072: PUSH
94073: LD_INT 21
94075: PUSH
94076: LD_INT 22
94078: PUSH
94079: LD_INT 23
94081: PUSH
94082: LD_INT 25
94084: PUSH
94085: LD_INT 26
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 101
94106: PUSH
94107: LD_INT 102
94109: PUSH
94110: LD_INT 103
94112: PUSH
94113: LD_INT 105
94115: PUSH
94116: LD_INT 106
94118: PUSH
94119: LD_INT 108
94121: PUSH
94122: LD_INT 112
94124: PUSH
94125: LD_INT 116
94127: PUSH
94128: LD_INT 117
94130: PUSH
94131: LD_INT 118
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: ST_TO_ADDR
94150: GO 96553
94152: LD_INT 8
94154: DOUBLE
94155: EQUAL
94156: IFTRUE 94160
94158: GO 94300
94160: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94161: LD_ADDR_VAR 0 2
94165: PUSH
94166: LD_INT 2
94168: PUSH
94169: LD_INT 4
94171: PUSH
94172: LD_INT 5
94174: PUSH
94175: LD_INT 6
94177: PUSH
94178: LD_INT 7
94180: PUSH
94181: LD_INT 8
94183: PUSH
94184: LD_INT 11
94186: PUSH
94187: LD_INT 12
94189: PUSH
94190: LD_INT 15
94192: PUSH
94193: LD_INT 16
94195: PUSH
94196: LD_INT 20
94198: PUSH
94199: LD_INT 21
94201: PUSH
94202: LD_INT 22
94204: PUSH
94205: LD_INT 23
94207: PUSH
94208: LD_INT 25
94210: PUSH
94211: LD_INT 26
94213: PUSH
94214: LD_INT 30
94216: PUSH
94217: LD_INT 31
94219: PUSH
94220: LD_INT 32
94222: PUSH
94223: LD_INT 36
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 101
94250: PUSH
94251: LD_INT 102
94253: PUSH
94254: LD_INT 103
94256: PUSH
94257: LD_INT 105
94259: PUSH
94260: LD_INT 106
94262: PUSH
94263: LD_INT 108
94265: PUSH
94266: LD_INT 109
94268: PUSH
94269: LD_INT 112
94271: PUSH
94272: LD_INT 116
94274: PUSH
94275: LD_INT 117
94277: PUSH
94278: LD_INT 118
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: ST_TO_ADDR
94298: GO 96553
94300: LD_INT 9
94302: DOUBLE
94303: EQUAL
94304: IFTRUE 94308
94306: GO 94456
94308: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94309: LD_ADDR_VAR 0 2
94313: PUSH
94314: LD_INT 2
94316: PUSH
94317: LD_INT 4
94319: PUSH
94320: LD_INT 5
94322: PUSH
94323: LD_INT 6
94325: PUSH
94326: LD_INT 7
94328: PUSH
94329: LD_INT 8
94331: PUSH
94332: LD_INT 11
94334: PUSH
94335: LD_INT 12
94337: PUSH
94338: LD_INT 15
94340: PUSH
94341: LD_INT 16
94343: PUSH
94344: LD_INT 20
94346: PUSH
94347: LD_INT 21
94349: PUSH
94350: LD_INT 22
94352: PUSH
94353: LD_INT 23
94355: PUSH
94356: LD_INT 25
94358: PUSH
94359: LD_INT 26
94361: PUSH
94362: LD_INT 28
94364: PUSH
94365: LD_INT 30
94367: PUSH
94368: LD_INT 31
94370: PUSH
94371: LD_INT 32
94373: PUSH
94374: LD_INT 36
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 101
94402: PUSH
94403: LD_INT 102
94405: PUSH
94406: LD_INT 103
94408: PUSH
94409: LD_INT 105
94411: PUSH
94412: LD_INT 106
94414: PUSH
94415: LD_INT 108
94417: PUSH
94418: LD_INT 109
94420: PUSH
94421: LD_INT 112
94423: PUSH
94424: LD_INT 114
94426: PUSH
94427: LD_INT 116
94429: PUSH
94430: LD_INT 117
94432: PUSH
94433: LD_INT 118
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: ST_TO_ADDR
94454: GO 96553
94456: LD_INT 10
94458: DOUBLE
94459: EQUAL
94460: IFTRUE 94464
94462: GO 94660
94464: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94465: LD_ADDR_VAR 0 2
94469: PUSH
94470: LD_INT 2
94472: PUSH
94473: LD_INT 4
94475: PUSH
94476: LD_INT 5
94478: PUSH
94479: LD_INT 6
94481: PUSH
94482: LD_INT 7
94484: PUSH
94485: LD_INT 8
94487: PUSH
94488: LD_INT 9
94490: PUSH
94491: LD_INT 10
94493: PUSH
94494: LD_INT 11
94496: PUSH
94497: LD_INT 12
94499: PUSH
94500: LD_INT 13
94502: PUSH
94503: LD_INT 14
94505: PUSH
94506: LD_INT 15
94508: PUSH
94509: LD_INT 16
94511: PUSH
94512: LD_INT 17
94514: PUSH
94515: LD_INT 18
94517: PUSH
94518: LD_INT 19
94520: PUSH
94521: LD_INT 20
94523: PUSH
94524: LD_INT 21
94526: PUSH
94527: LD_INT 22
94529: PUSH
94530: LD_INT 23
94532: PUSH
94533: LD_INT 24
94535: PUSH
94536: LD_INT 25
94538: PUSH
94539: LD_INT 26
94541: PUSH
94542: LD_INT 28
94544: PUSH
94545: LD_INT 30
94547: PUSH
94548: LD_INT 31
94550: PUSH
94551: LD_INT 32
94553: PUSH
94554: LD_INT 36
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 101
94590: PUSH
94591: LD_INT 102
94593: PUSH
94594: LD_INT 103
94596: PUSH
94597: LD_INT 104
94599: PUSH
94600: LD_INT 105
94602: PUSH
94603: LD_INT 106
94605: PUSH
94606: LD_INT 107
94608: PUSH
94609: LD_INT 108
94611: PUSH
94612: LD_INT 109
94614: PUSH
94615: LD_INT 110
94617: PUSH
94618: LD_INT 111
94620: PUSH
94621: LD_INT 112
94623: PUSH
94624: LD_INT 114
94626: PUSH
94627: LD_INT 116
94629: PUSH
94630: LD_INT 117
94632: PUSH
94633: LD_INT 118
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: ST_TO_ADDR
94658: GO 96553
94660: LD_INT 11
94662: DOUBLE
94663: EQUAL
94664: IFTRUE 94668
94666: GO 94872
94668: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94669: LD_ADDR_VAR 0 2
94673: PUSH
94674: LD_INT 2
94676: PUSH
94677: LD_INT 3
94679: PUSH
94680: LD_INT 4
94682: PUSH
94683: LD_INT 5
94685: PUSH
94686: LD_INT 6
94688: PUSH
94689: LD_INT 7
94691: PUSH
94692: LD_INT 8
94694: PUSH
94695: LD_INT 9
94697: PUSH
94698: LD_INT 10
94700: PUSH
94701: LD_INT 11
94703: PUSH
94704: LD_INT 12
94706: PUSH
94707: LD_INT 13
94709: PUSH
94710: LD_INT 14
94712: PUSH
94713: LD_INT 15
94715: PUSH
94716: LD_INT 16
94718: PUSH
94719: LD_INT 17
94721: PUSH
94722: LD_INT 18
94724: PUSH
94725: LD_INT 19
94727: PUSH
94728: LD_INT 20
94730: PUSH
94731: LD_INT 21
94733: PUSH
94734: LD_INT 22
94736: PUSH
94737: LD_INT 23
94739: PUSH
94740: LD_INT 24
94742: PUSH
94743: LD_INT 25
94745: PUSH
94746: LD_INT 26
94748: PUSH
94749: LD_INT 28
94751: PUSH
94752: LD_INT 30
94754: PUSH
94755: LD_INT 31
94757: PUSH
94758: LD_INT 32
94760: PUSH
94761: LD_INT 34
94763: PUSH
94764: LD_INT 36
94766: PUSH
94767: EMPTY
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 101
94802: PUSH
94803: LD_INT 102
94805: PUSH
94806: LD_INT 103
94808: PUSH
94809: LD_INT 104
94811: PUSH
94812: LD_INT 105
94814: PUSH
94815: LD_INT 106
94817: PUSH
94818: LD_INT 107
94820: PUSH
94821: LD_INT 108
94823: PUSH
94824: LD_INT 109
94826: PUSH
94827: LD_INT 110
94829: PUSH
94830: LD_INT 111
94832: PUSH
94833: LD_INT 112
94835: PUSH
94836: LD_INT 114
94838: PUSH
94839: LD_INT 116
94841: PUSH
94842: LD_INT 117
94844: PUSH
94845: LD_INT 118
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: ST_TO_ADDR
94870: GO 96553
94872: LD_INT 12
94874: DOUBLE
94875: EQUAL
94876: IFTRUE 94880
94878: GO 95100
94880: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94881: LD_ADDR_VAR 0 2
94885: PUSH
94886: LD_INT 1
94888: PUSH
94889: LD_INT 2
94891: PUSH
94892: LD_INT 3
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: LD_INT 5
94900: PUSH
94901: LD_INT 6
94903: PUSH
94904: LD_INT 7
94906: PUSH
94907: LD_INT 8
94909: PUSH
94910: LD_INT 9
94912: PUSH
94913: LD_INT 10
94915: PUSH
94916: LD_INT 11
94918: PUSH
94919: LD_INT 12
94921: PUSH
94922: LD_INT 13
94924: PUSH
94925: LD_INT 14
94927: PUSH
94928: LD_INT 15
94930: PUSH
94931: LD_INT 16
94933: PUSH
94934: LD_INT 17
94936: PUSH
94937: LD_INT 18
94939: PUSH
94940: LD_INT 19
94942: PUSH
94943: LD_INT 20
94945: PUSH
94946: LD_INT 21
94948: PUSH
94949: LD_INT 22
94951: PUSH
94952: LD_INT 23
94954: PUSH
94955: LD_INT 24
94957: PUSH
94958: LD_INT 25
94960: PUSH
94961: LD_INT 26
94963: PUSH
94964: LD_INT 27
94966: PUSH
94967: LD_INT 28
94969: PUSH
94970: LD_INT 30
94972: PUSH
94973: LD_INT 31
94975: PUSH
94976: LD_INT 32
94978: PUSH
94979: LD_INT 33
94981: PUSH
94982: LD_INT 34
94984: PUSH
94985: LD_INT 36
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: PUSH
95024: LD_INT 101
95026: PUSH
95027: LD_INT 102
95029: PUSH
95030: LD_INT 103
95032: PUSH
95033: LD_INT 104
95035: PUSH
95036: LD_INT 105
95038: PUSH
95039: LD_INT 106
95041: PUSH
95042: LD_INT 107
95044: PUSH
95045: LD_INT 108
95047: PUSH
95048: LD_INT 109
95050: PUSH
95051: LD_INT 110
95053: PUSH
95054: LD_INT 111
95056: PUSH
95057: LD_INT 112
95059: PUSH
95060: LD_INT 113
95062: PUSH
95063: LD_INT 114
95065: PUSH
95066: LD_INT 116
95068: PUSH
95069: LD_INT 117
95071: PUSH
95072: LD_INT 118
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: ST_TO_ADDR
95098: GO 96553
95100: LD_INT 13
95102: DOUBLE
95103: EQUAL
95104: IFTRUE 95108
95106: GO 95316
95108: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95109: LD_ADDR_VAR 0 2
95113: PUSH
95114: LD_INT 1
95116: PUSH
95117: LD_INT 2
95119: PUSH
95120: LD_INT 3
95122: PUSH
95123: LD_INT 4
95125: PUSH
95126: LD_INT 5
95128: PUSH
95129: LD_INT 8
95131: PUSH
95132: LD_INT 9
95134: PUSH
95135: LD_INT 10
95137: PUSH
95138: LD_INT 11
95140: PUSH
95141: LD_INT 12
95143: PUSH
95144: LD_INT 14
95146: PUSH
95147: LD_INT 15
95149: PUSH
95150: LD_INT 16
95152: PUSH
95153: LD_INT 17
95155: PUSH
95156: LD_INT 18
95158: PUSH
95159: LD_INT 19
95161: PUSH
95162: LD_INT 20
95164: PUSH
95165: LD_INT 21
95167: PUSH
95168: LD_INT 22
95170: PUSH
95171: LD_INT 23
95173: PUSH
95174: LD_INT 24
95176: PUSH
95177: LD_INT 25
95179: PUSH
95180: LD_INT 26
95182: PUSH
95183: LD_INT 27
95185: PUSH
95186: LD_INT 28
95188: PUSH
95189: LD_INT 30
95191: PUSH
95192: LD_INT 31
95194: PUSH
95195: LD_INT 32
95197: PUSH
95198: LD_INT 33
95200: PUSH
95201: LD_INT 34
95203: PUSH
95204: LD_INT 36
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: PUSH
95240: LD_INT 101
95242: PUSH
95243: LD_INT 102
95245: PUSH
95246: LD_INT 103
95248: PUSH
95249: LD_INT 104
95251: PUSH
95252: LD_INT 105
95254: PUSH
95255: LD_INT 106
95257: PUSH
95258: LD_INT 107
95260: PUSH
95261: LD_INT 108
95263: PUSH
95264: LD_INT 109
95266: PUSH
95267: LD_INT 110
95269: PUSH
95270: LD_INT 111
95272: PUSH
95273: LD_INT 112
95275: PUSH
95276: LD_INT 113
95278: PUSH
95279: LD_INT 114
95281: PUSH
95282: LD_INT 116
95284: PUSH
95285: LD_INT 117
95287: PUSH
95288: LD_INT 118
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: ST_TO_ADDR
95314: GO 96553
95316: LD_INT 14
95318: DOUBLE
95319: EQUAL
95320: IFTRUE 95324
95322: GO 95548
95324: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95325: LD_ADDR_VAR 0 2
95329: PUSH
95330: LD_INT 1
95332: PUSH
95333: LD_INT 2
95335: PUSH
95336: LD_INT 3
95338: PUSH
95339: LD_INT 4
95341: PUSH
95342: LD_INT 5
95344: PUSH
95345: LD_INT 6
95347: PUSH
95348: LD_INT 7
95350: PUSH
95351: LD_INT 8
95353: PUSH
95354: LD_INT 9
95356: PUSH
95357: LD_INT 10
95359: PUSH
95360: LD_INT 11
95362: PUSH
95363: LD_INT 12
95365: PUSH
95366: LD_INT 13
95368: PUSH
95369: LD_INT 14
95371: PUSH
95372: LD_INT 15
95374: PUSH
95375: LD_INT 16
95377: PUSH
95378: LD_INT 17
95380: PUSH
95381: LD_INT 18
95383: PUSH
95384: LD_INT 19
95386: PUSH
95387: LD_INT 20
95389: PUSH
95390: LD_INT 21
95392: PUSH
95393: LD_INT 22
95395: PUSH
95396: LD_INT 23
95398: PUSH
95399: LD_INT 24
95401: PUSH
95402: LD_INT 25
95404: PUSH
95405: LD_INT 26
95407: PUSH
95408: LD_INT 27
95410: PUSH
95411: LD_INT 28
95413: PUSH
95414: LD_INT 29
95416: PUSH
95417: LD_INT 30
95419: PUSH
95420: LD_INT 31
95422: PUSH
95423: LD_INT 32
95425: PUSH
95426: LD_INT 33
95428: PUSH
95429: LD_INT 34
95431: PUSH
95432: LD_INT 36
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 101
95474: PUSH
95475: LD_INT 102
95477: PUSH
95478: LD_INT 103
95480: PUSH
95481: LD_INT 104
95483: PUSH
95484: LD_INT 105
95486: PUSH
95487: LD_INT 106
95489: PUSH
95490: LD_INT 107
95492: PUSH
95493: LD_INT 108
95495: PUSH
95496: LD_INT 109
95498: PUSH
95499: LD_INT 110
95501: PUSH
95502: LD_INT 111
95504: PUSH
95505: LD_INT 112
95507: PUSH
95508: LD_INT 113
95510: PUSH
95511: LD_INT 114
95513: PUSH
95514: LD_INT 116
95516: PUSH
95517: LD_INT 117
95519: PUSH
95520: LD_INT 118
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: ST_TO_ADDR
95546: GO 96553
95548: LD_INT 15
95550: DOUBLE
95551: EQUAL
95552: IFTRUE 95556
95554: GO 95780
95556: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95557: LD_ADDR_VAR 0 2
95561: PUSH
95562: LD_INT 1
95564: PUSH
95565: LD_INT 2
95567: PUSH
95568: LD_INT 3
95570: PUSH
95571: LD_INT 4
95573: PUSH
95574: LD_INT 5
95576: PUSH
95577: LD_INT 6
95579: PUSH
95580: LD_INT 7
95582: PUSH
95583: LD_INT 8
95585: PUSH
95586: LD_INT 9
95588: PUSH
95589: LD_INT 10
95591: PUSH
95592: LD_INT 11
95594: PUSH
95595: LD_INT 12
95597: PUSH
95598: LD_INT 13
95600: PUSH
95601: LD_INT 14
95603: PUSH
95604: LD_INT 15
95606: PUSH
95607: LD_INT 16
95609: PUSH
95610: LD_INT 17
95612: PUSH
95613: LD_INT 18
95615: PUSH
95616: LD_INT 19
95618: PUSH
95619: LD_INT 20
95621: PUSH
95622: LD_INT 21
95624: PUSH
95625: LD_INT 22
95627: PUSH
95628: LD_INT 23
95630: PUSH
95631: LD_INT 24
95633: PUSH
95634: LD_INT 25
95636: PUSH
95637: LD_INT 26
95639: PUSH
95640: LD_INT 27
95642: PUSH
95643: LD_INT 28
95645: PUSH
95646: LD_INT 29
95648: PUSH
95649: LD_INT 30
95651: PUSH
95652: LD_INT 31
95654: PUSH
95655: LD_INT 32
95657: PUSH
95658: LD_INT 33
95660: PUSH
95661: LD_INT 34
95663: PUSH
95664: LD_INT 36
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 101
95706: PUSH
95707: LD_INT 102
95709: PUSH
95710: LD_INT 103
95712: PUSH
95713: LD_INT 104
95715: PUSH
95716: LD_INT 105
95718: PUSH
95719: LD_INT 106
95721: PUSH
95722: LD_INT 107
95724: PUSH
95725: LD_INT 108
95727: PUSH
95728: LD_INT 109
95730: PUSH
95731: LD_INT 110
95733: PUSH
95734: LD_INT 111
95736: PUSH
95737: LD_INT 112
95739: PUSH
95740: LD_INT 113
95742: PUSH
95743: LD_INT 114
95745: PUSH
95746: LD_INT 116
95748: PUSH
95749: LD_INT 117
95751: PUSH
95752: LD_INT 118
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: ST_TO_ADDR
95778: GO 96553
95780: LD_INT 16
95782: DOUBLE
95783: EQUAL
95784: IFTRUE 95788
95786: GO 95924
95788: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95789: LD_ADDR_VAR 0 2
95793: PUSH
95794: LD_INT 2
95796: PUSH
95797: LD_INT 4
95799: PUSH
95800: LD_INT 5
95802: PUSH
95803: LD_INT 7
95805: PUSH
95806: LD_INT 11
95808: PUSH
95809: LD_INT 12
95811: PUSH
95812: LD_INT 15
95814: PUSH
95815: LD_INT 16
95817: PUSH
95818: LD_INT 20
95820: PUSH
95821: LD_INT 21
95823: PUSH
95824: LD_INT 22
95826: PUSH
95827: LD_INT 23
95829: PUSH
95830: LD_INT 25
95832: PUSH
95833: LD_INT 26
95835: PUSH
95836: LD_INT 30
95838: PUSH
95839: LD_INT 31
95841: PUSH
95842: LD_INT 32
95844: PUSH
95845: LD_INT 33
95847: PUSH
95848: LD_INT 34
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: PUSH
95872: LD_INT 101
95874: PUSH
95875: LD_INT 102
95877: PUSH
95878: LD_INT 103
95880: PUSH
95881: LD_INT 106
95883: PUSH
95884: LD_INT 108
95886: PUSH
95887: LD_INT 112
95889: PUSH
95890: LD_INT 113
95892: PUSH
95893: LD_INT 114
95895: PUSH
95896: LD_INT 116
95898: PUSH
95899: LD_INT 117
95901: PUSH
95902: LD_INT 118
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: ST_TO_ADDR
95922: GO 96553
95924: LD_INT 17
95926: DOUBLE
95927: EQUAL
95928: IFTRUE 95932
95930: GO 96156
95932: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95933: LD_ADDR_VAR 0 2
95937: PUSH
95938: LD_INT 1
95940: PUSH
95941: LD_INT 2
95943: PUSH
95944: LD_INT 3
95946: PUSH
95947: LD_INT 4
95949: PUSH
95950: LD_INT 5
95952: PUSH
95953: LD_INT 6
95955: PUSH
95956: LD_INT 7
95958: PUSH
95959: LD_INT 8
95961: PUSH
95962: LD_INT 9
95964: PUSH
95965: LD_INT 10
95967: PUSH
95968: LD_INT 11
95970: PUSH
95971: LD_INT 12
95973: PUSH
95974: LD_INT 13
95976: PUSH
95977: LD_INT 14
95979: PUSH
95980: LD_INT 15
95982: PUSH
95983: LD_INT 16
95985: PUSH
95986: LD_INT 17
95988: PUSH
95989: LD_INT 18
95991: PUSH
95992: LD_INT 19
95994: PUSH
95995: LD_INT 20
95997: PUSH
95998: LD_INT 21
96000: PUSH
96001: LD_INT 22
96003: PUSH
96004: LD_INT 23
96006: PUSH
96007: LD_INT 24
96009: PUSH
96010: LD_INT 25
96012: PUSH
96013: LD_INT 26
96015: PUSH
96016: LD_INT 27
96018: PUSH
96019: LD_INT 28
96021: PUSH
96022: LD_INT 29
96024: PUSH
96025: LD_INT 30
96027: PUSH
96028: LD_INT 31
96030: PUSH
96031: LD_INT 32
96033: PUSH
96034: LD_INT 33
96036: PUSH
96037: LD_INT 34
96039: PUSH
96040: LD_INT 36
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: PUSH
96080: LD_INT 101
96082: PUSH
96083: LD_INT 102
96085: PUSH
96086: LD_INT 103
96088: PUSH
96089: LD_INT 104
96091: PUSH
96092: LD_INT 105
96094: PUSH
96095: LD_INT 106
96097: PUSH
96098: LD_INT 107
96100: PUSH
96101: LD_INT 108
96103: PUSH
96104: LD_INT 109
96106: PUSH
96107: LD_INT 110
96109: PUSH
96110: LD_INT 111
96112: PUSH
96113: LD_INT 112
96115: PUSH
96116: LD_INT 113
96118: PUSH
96119: LD_INT 114
96121: PUSH
96122: LD_INT 116
96124: PUSH
96125: LD_INT 117
96127: PUSH
96128: LD_INT 118
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: ST_TO_ADDR
96154: GO 96553
96156: LD_INT 18
96158: DOUBLE
96159: EQUAL
96160: IFTRUE 96164
96162: GO 96312
96164: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96165: LD_ADDR_VAR 0 2
96169: PUSH
96170: LD_INT 2
96172: PUSH
96173: LD_INT 4
96175: PUSH
96176: LD_INT 5
96178: PUSH
96179: LD_INT 7
96181: PUSH
96182: LD_INT 11
96184: PUSH
96185: LD_INT 12
96187: PUSH
96188: LD_INT 15
96190: PUSH
96191: LD_INT 16
96193: PUSH
96194: LD_INT 20
96196: PUSH
96197: LD_INT 21
96199: PUSH
96200: LD_INT 22
96202: PUSH
96203: LD_INT 23
96205: PUSH
96206: LD_INT 25
96208: PUSH
96209: LD_INT 26
96211: PUSH
96212: LD_INT 30
96214: PUSH
96215: LD_INT 31
96217: PUSH
96218: LD_INT 32
96220: PUSH
96221: LD_INT 33
96223: PUSH
96224: LD_INT 34
96226: PUSH
96227: LD_INT 35
96229: PUSH
96230: LD_INT 36
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: LIST
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: PUSH
96256: LD_INT 101
96258: PUSH
96259: LD_INT 102
96261: PUSH
96262: LD_INT 103
96264: PUSH
96265: LD_INT 106
96267: PUSH
96268: LD_INT 108
96270: PUSH
96271: LD_INT 112
96273: PUSH
96274: LD_INT 113
96276: PUSH
96277: LD_INT 114
96279: PUSH
96280: LD_INT 115
96282: PUSH
96283: LD_INT 116
96285: PUSH
96286: LD_INT 117
96288: PUSH
96289: LD_INT 118
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: ST_TO_ADDR
96310: GO 96553
96312: LD_INT 19
96314: DOUBLE
96315: EQUAL
96316: IFTRUE 96320
96318: GO 96552
96320: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96321: LD_ADDR_VAR 0 2
96325: PUSH
96326: LD_INT 1
96328: PUSH
96329: LD_INT 2
96331: PUSH
96332: LD_INT 3
96334: PUSH
96335: LD_INT 4
96337: PUSH
96338: LD_INT 5
96340: PUSH
96341: LD_INT 6
96343: PUSH
96344: LD_INT 7
96346: PUSH
96347: LD_INT 8
96349: PUSH
96350: LD_INT 9
96352: PUSH
96353: LD_INT 10
96355: PUSH
96356: LD_INT 11
96358: PUSH
96359: LD_INT 12
96361: PUSH
96362: LD_INT 13
96364: PUSH
96365: LD_INT 14
96367: PUSH
96368: LD_INT 15
96370: PUSH
96371: LD_INT 16
96373: PUSH
96374: LD_INT 17
96376: PUSH
96377: LD_INT 18
96379: PUSH
96380: LD_INT 19
96382: PUSH
96383: LD_INT 20
96385: PUSH
96386: LD_INT 21
96388: PUSH
96389: LD_INT 22
96391: PUSH
96392: LD_INT 23
96394: PUSH
96395: LD_INT 24
96397: PUSH
96398: LD_INT 25
96400: PUSH
96401: LD_INT 26
96403: PUSH
96404: LD_INT 27
96406: PUSH
96407: LD_INT 28
96409: PUSH
96410: LD_INT 29
96412: PUSH
96413: LD_INT 30
96415: PUSH
96416: LD_INT 31
96418: PUSH
96419: LD_INT 32
96421: PUSH
96422: LD_INT 33
96424: PUSH
96425: LD_INT 34
96427: PUSH
96428: LD_INT 35
96430: PUSH
96431: LD_INT 36
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: PUSH
96472: LD_INT 101
96474: PUSH
96475: LD_INT 102
96477: PUSH
96478: LD_INT 103
96480: PUSH
96481: LD_INT 104
96483: PUSH
96484: LD_INT 105
96486: PUSH
96487: LD_INT 106
96489: PUSH
96490: LD_INT 107
96492: PUSH
96493: LD_INT 108
96495: PUSH
96496: LD_INT 109
96498: PUSH
96499: LD_INT 110
96501: PUSH
96502: LD_INT 111
96504: PUSH
96505: LD_INT 112
96507: PUSH
96508: LD_INT 113
96510: PUSH
96511: LD_INT 114
96513: PUSH
96514: LD_INT 115
96516: PUSH
96517: LD_INT 116
96519: PUSH
96520: LD_INT 117
96522: PUSH
96523: LD_INT 118
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: ST_TO_ADDR
96550: GO 96553
96552: POP
// end else
96553: GO 96784
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96555: LD_ADDR_VAR 0 2
96559: PUSH
96560: LD_INT 1
96562: PUSH
96563: LD_INT 2
96565: PUSH
96566: LD_INT 3
96568: PUSH
96569: LD_INT 4
96571: PUSH
96572: LD_INT 5
96574: PUSH
96575: LD_INT 6
96577: PUSH
96578: LD_INT 7
96580: PUSH
96581: LD_INT 8
96583: PUSH
96584: LD_INT 9
96586: PUSH
96587: LD_INT 10
96589: PUSH
96590: LD_INT 11
96592: PUSH
96593: LD_INT 12
96595: PUSH
96596: LD_INT 13
96598: PUSH
96599: LD_INT 14
96601: PUSH
96602: LD_INT 15
96604: PUSH
96605: LD_INT 16
96607: PUSH
96608: LD_INT 17
96610: PUSH
96611: LD_INT 18
96613: PUSH
96614: LD_INT 19
96616: PUSH
96617: LD_INT 20
96619: PUSH
96620: LD_INT 21
96622: PUSH
96623: LD_INT 22
96625: PUSH
96626: LD_INT 23
96628: PUSH
96629: LD_INT 24
96631: PUSH
96632: LD_INT 25
96634: PUSH
96635: LD_INT 26
96637: PUSH
96638: LD_INT 27
96640: PUSH
96641: LD_INT 28
96643: PUSH
96644: LD_INT 29
96646: PUSH
96647: LD_INT 30
96649: PUSH
96650: LD_INT 31
96652: PUSH
96653: LD_INT 32
96655: PUSH
96656: LD_INT 33
96658: PUSH
96659: LD_INT 34
96661: PUSH
96662: LD_INT 35
96664: PUSH
96665: LD_INT 36
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: PUSH
96706: LD_INT 101
96708: PUSH
96709: LD_INT 102
96711: PUSH
96712: LD_INT 103
96714: PUSH
96715: LD_INT 104
96717: PUSH
96718: LD_INT 105
96720: PUSH
96721: LD_INT 106
96723: PUSH
96724: LD_INT 107
96726: PUSH
96727: LD_INT 108
96729: PUSH
96730: LD_INT 109
96732: PUSH
96733: LD_INT 110
96735: PUSH
96736: LD_INT 111
96738: PUSH
96739: LD_INT 112
96741: PUSH
96742: LD_INT 113
96744: PUSH
96745: LD_INT 114
96747: PUSH
96748: LD_INT 115
96750: PUSH
96751: LD_INT 116
96753: PUSH
96754: LD_INT 117
96756: PUSH
96757: LD_INT 118
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: ST_TO_ADDR
// if result then
96784: LD_VAR 0 2
96788: IFFALSE 97574
// begin normal :=  ;
96790: LD_ADDR_VAR 0 5
96794: PUSH
96795: LD_STRING 
96797: ST_TO_ADDR
// hardcore :=  ;
96798: LD_ADDR_VAR 0 6
96802: PUSH
96803: LD_STRING 
96805: ST_TO_ADDR
// active :=  ;
96806: LD_ADDR_VAR 0 7
96810: PUSH
96811: LD_STRING 
96813: ST_TO_ADDR
// for i = 1 to normalCounter do
96814: LD_ADDR_VAR 0 8
96818: PUSH
96819: DOUBLE
96820: LD_INT 1
96822: DEC
96823: ST_TO_ADDR
96824: LD_EXP 76
96828: PUSH
96829: FOR_TO
96830: IFFALSE 96931
// begin tmp := 0 ;
96832: LD_ADDR_VAR 0 3
96836: PUSH
96837: LD_STRING 0
96839: ST_TO_ADDR
// if result [ 1 ] then
96840: LD_VAR 0 2
96844: PUSH
96845: LD_INT 1
96847: ARRAY
96848: IFFALSE 96913
// if result [ 1 ] [ 1 ] = i then
96850: LD_VAR 0 2
96854: PUSH
96855: LD_INT 1
96857: ARRAY
96858: PUSH
96859: LD_INT 1
96861: ARRAY
96862: PUSH
96863: LD_VAR 0 8
96867: EQUAL
96868: IFFALSE 96913
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96870: LD_ADDR_VAR 0 2
96874: PUSH
96875: LD_VAR 0 2
96879: PPUSH
96880: LD_INT 1
96882: PPUSH
96883: LD_VAR 0 2
96887: PUSH
96888: LD_INT 1
96890: ARRAY
96891: PPUSH
96892: LD_INT 1
96894: PPUSH
96895: CALL_OW 3
96899: PPUSH
96900: CALL_OW 1
96904: ST_TO_ADDR
// tmp := 1 ;
96905: LD_ADDR_VAR 0 3
96909: PUSH
96910: LD_STRING 1
96912: ST_TO_ADDR
// end ; normal := normal & tmp ;
96913: LD_ADDR_VAR 0 5
96917: PUSH
96918: LD_VAR 0 5
96922: PUSH
96923: LD_VAR 0 3
96927: STR
96928: ST_TO_ADDR
// end ;
96929: GO 96829
96931: POP
96932: POP
// for i = 1 to hardcoreCounter do
96933: LD_ADDR_VAR 0 8
96937: PUSH
96938: DOUBLE
96939: LD_INT 1
96941: DEC
96942: ST_TO_ADDR
96943: LD_EXP 77
96947: PUSH
96948: FOR_TO
96949: IFFALSE 97054
// begin tmp := 0 ;
96951: LD_ADDR_VAR 0 3
96955: PUSH
96956: LD_STRING 0
96958: ST_TO_ADDR
// if result [ 2 ] then
96959: LD_VAR 0 2
96963: PUSH
96964: LD_INT 2
96966: ARRAY
96967: IFFALSE 97036
// if result [ 2 ] [ 1 ] = 100 + i then
96969: LD_VAR 0 2
96973: PUSH
96974: LD_INT 2
96976: ARRAY
96977: PUSH
96978: LD_INT 1
96980: ARRAY
96981: PUSH
96982: LD_INT 100
96984: PUSH
96985: LD_VAR 0 8
96989: PLUS
96990: EQUAL
96991: IFFALSE 97036
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96993: LD_ADDR_VAR 0 2
96997: PUSH
96998: LD_VAR 0 2
97002: PPUSH
97003: LD_INT 2
97005: PPUSH
97006: LD_VAR 0 2
97010: PUSH
97011: LD_INT 2
97013: ARRAY
97014: PPUSH
97015: LD_INT 1
97017: PPUSH
97018: CALL_OW 3
97022: PPUSH
97023: CALL_OW 1
97027: ST_TO_ADDR
// tmp := 1 ;
97028: LD_ADDR_VAR 0 3
97032: PUSH
97033: LD_STRING 1
97035: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97036: LD_ADDR_VAR 0 6
97040: PUSH
97041: LD_VAR 0 6
97045: PUSH
97046: LD_VAR 0 3
97050: STR
97051: ST_TO_ADDR
// end ;
97052: GO 96948
97054: POP
97055: POP
// if isGameLoad then
97056: LD_VAR 0 1
97060: IFFALSE 97535
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97062: LD_ADDR_VAR 0 4
97066: PUSH
97067: LD_EXP 80
97071: PUSH
97072: LD_EXP 79
97076: PUSH
97077: LD_EXP 81
97081: PUSH
97082: LD_EXP 78
97086: PUSH
97087: LD_EXP 82
97091: PUSH
97092: LD_EXP 83
97096: PUSH
97097: LD_EXP 84
97101: PUSH
97102: LD_EXP 85
97106: PUSH
97107: LD_EXP 86
97111: PUSH
97112: LD_EXP 87
97116: PUSH
97117: LD_EXP 88
97121: PUSH
97122: LD_EXP 89
97126: PUSH
97127: LD_EXP 90
97131: PUSH
97132: LD_EXP 91
97136: PUSH
97137: LD_EXP 99
97141: PUSH
97142: LD_EXP 100
97146: PUSH
97147: LD_EXP 101
97151: PUSH
97152: LD_EXP 102
97156: PUSH
97157: LD_EXP 104
97161: PUSH
97162: LD_EXP 105
97166: PUSH
97167: LD_EXP 106
97171: PUSH
97172: LD_EXP 109
97176: PUSH
97177: LD_EXP 111
97181: PUSH
97182: LD_EXP 112
97186: PUSH
97187: LD_EXP 113
97191: PUSH
97192: LD_EXP 115
97196: PUSH
97197: LD_EXP 116
97201: PUSH
97202: LD_EXP 119
97206: PUSH
97207: LD_EXP 120
97211: PUSH
97212: LD_EXP 121
97216: PUSH
97217: LD_EXP 122
97221: PUSH
97222: LD_EXP 123
97226: PUSH
97227: LD_EXP 124
97231: PUSH
97232: LD_EXP 125
97236: PUSH
97237: LD_EXP 126
97241: PUSH
97242: LD_EXP 127
97246: PUSH
97247: LD_EXP 92
97251: PUSH
97252: LD_EXP 93
97256: PUSH
97257: LD_EXP 96
97261: PUSH
97262: LD_EXP 97
97266: PUSH
97267: LD_EXP 98
97271: PUSH
97272: LD_EXP 94
97276: PUSH
97277: LD_EXP 95
97281: PUSH
97282: LD_EXP 103
97286: PUSH
97287: LD_EXP 107
97291: PUSH
97292: LD_EXP 108
97296: PUSH
97297: LD_EXP 110
97301: PUSH
97302: LD_EXP 114
97306: PUSH
97307: LD_EXP 117
97311: PUSH
97312: LD_EXP 118
97316: PUSH
97317: LD_EXP 128
97321: PUSH
97322: LD_EXP 129
97326: PUSH
97327: LD_EXP 130
97331: PUSH
97332: LD_EXP 131
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: ST_TO_ADDR
// tmp :=  ;
97393: LD_ADDR_VAR 0 3
97397: PUSH
97398: LD_STRING 
97400: ST_TO_ADDR
// for i = 1 to normalCounter do
97401: LD_ADDR_VAR 0 8
97405: PUSH
97406: DOUBLE
97407: LD_INT 1
97409: DEC
97410: ST_TO_ADDR
97411: LD_EXP 76
97415: PUSH
97416: FOR_TO
97417: IFFALSE 97453
// begin if flags [ i ] then
97419: LD_VAR 0 4
97423: PUSH
97424: LD_VAR 0 8
97428: ARRAY
97429: IFFALSE 97451
// tmp := tmp & i & ; ;
97431: LD_ADDR_VAR 0 3
97435: PUSH
97436: LD_VAR 0 3
97440: PUSH
97441: LD_VAR 0 8
97445: STR
97446: PUSH
97447: LD_STRING ;
97449: STR
97450: ST_TO_ADDR
// end ;
97451: GO 97416
97453: POP
97454: POP
// for i = 1 to hardcoreCounter do
97455: LD_ADDR_VAR 0 8
97459: PUSH
97460: DOUBLE
97461: LD_INT 1
97463: DEC
97464: ST_TO_ADDR
97465: LD_EXP 77
97469: PUSH
97470: FOR_TO
97471: IFFALSE 97517
// begin if flags [ normalCounter + i ] then
97473: LD_VAR 0 4
97477: PUSH
97478: LD_EXP 76
97482: PUSH
97483: LD_VAR 0 8
97487: PLUS
97488: ARRAY
97489: IFFALSE 97515
// tmp := tmp & ( 100 + i ) & ; ;
97491: LD_ADDR_VAR 0 3
97495: PUSH
97496: LD_VAR 0 3
97500: PUSH
97501: LD_INT 100
97503: PUSH
97504: LD_VAR 0 8
97508: PLUS
97509: STR
97510: PUSH
97511: LD_STRING ;
97513: STR
97514: ST_TO_ADDR
// end ;
97515: GO 97470
97517: POP
97518: POP
// if tmp then
97519: LD_VAR 0 3
97523: IFFALSE 97535
// active := tmp ;
97525: LD_ADDR_VAR 0 7
97529: PUSH
97530: LD_VAR 0 3
97534: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97535: LD_STRING getStreamItemsFromMission("
97537: PUSH
97538: LD_VAR 0 5
97542: STR
97543: PUSH
97544: LD_STRING ","
97546: STR
97547: PUSH
97548: LD_VAR 0 6
97552: STR
97553: PUSH
97554: LD_STRING ","
97556: STR
97557: PUSH
97558: LD_VAR 0 7
97562: STR
97563: PUSH
97564: LD_STRING ")
97566: STR
97567: PPUSH
97568: CALL_OW 559
// end else
97572: GO 97581
// ToLua ( getStreamItemsFromMission("","","") ) ;
97574: LD_STRING getStreamItemsFromMission("","","")
97576: PPUSH
97577: CALL_OW 559
// end ;
97581: LD_VAR 0 2
97585: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97586: LD_EXP 75
97590: PUSH
97591: LD_EXP 80
97595: AND
97596: IFFALSE 97720
97598: GO 97600
97600: DISABLE
97601: LD_INT 0
97603: PPUSH
97604: PPUSH
// begin enable ;
97605: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97606: LD_ADDR_VAR 0 2
97610: PUSH
97611: LD_INT 22
97613: PUSH
97614: LD_OWVAR 2
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 2
97625: PUSH
97626: LD_INT 34
97628: PUSH
97629: LD_INT 7
97631: PUSH
97632: EMPTY
97633: LIST
97634: LIST
97635: PUSH
97636: LD_INT 34
97638: PUSH
97639: LD_INT 45
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: PUSH
97646: LD_INT 34
97648: PUSH
97649: LD_INT 28
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: PUSH
97656: LD_INT 34
97658: PUSH
97659: LD_INT 47
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: PUSH
97673: EMPTY
97674: LIST
97675: LIST
97676: PPUSH
97677: CALL_OW 69
97681: ST_TO_ADDR
// if not tmp then
97682: LD_VAR 0 2
97686: NOT
97687: IFFALSE 97691
// exit ;
97689: GO 97720
// for i in tmp do
97691: LD_ADDR_VAR 0 1
97695: PUSH
97696: LD_VAR 0 2
97700: PUSH
97701: FOR_IN
97702: IFFALSE 97718
// begin SetLives ( i , 0 ) ;
97704: LD_VAR 0 1
97708: PPUSH
97709: LD_INT 0
97711: PPUSH
97712: CALL_OW 234
// end ;
97716: GO 97701
97718: POP
97719: POP
// end ;
97720: PPOPN 2
97722: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97723: LD_EXP 75
97727: PUSH
97728: LD_EXP 81
97732: AND
97733: IFFALSE 97817
97735: GO 97737
97737: DISABLE
97738: LD_INT 0
97740: PPUSH
97741: PPUSH
// begin enable ;
97742: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97743: LD_ADDR_VAR 0 2
97747: PUSH
97748: LD_INT 22
97750: PUSH
97751: LD_OWVAR 2
97755: PUSH
97756: EMPTY
97757: LIST
97758: LIST
97759: PUSH
97760: LD_INT 32
97762: PUSH
97763: LD_INT 3
97765: PUSH
97766: EMPTY
97767: LIST
97768: LIST
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: PPUSH
97774: CALL_OW 69
97778: ST_TO_ADDR
// if not tmp then
97779: LD_VAR 0 2
97783: NOT
97784: IFFALSE 97788
// exit ;
97786: GO 97817
// for i in tmp do
97788: LD_ADDR_VAR 0 1
97792: PUSH
97793: LD_VAR 0 2
97797: PUSH
97798: FOR_IN
97799: IFFALSE 97815
// begin SetLives ( i , 0 ) ;
97801: LD_VAR 0 1
97805: PPUSH
97806: LD_INT 0
97808: PPUSH
97809: CALL_OW 234
// end ;
97813: GO 97798
97815: POP
97816: POP
// end ;
97817: PPOPN 2
97819: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97820: LD_EXP 75
97824: PUSH
97825: LD_EXP 78
97829: AND
97830: IFFALSE 97923
97832: GO 97834
97834: DISABLE
97835: LD_INT 0
97837: PPUSH
// begin enable ;
97838: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97839: LD_ADDR_VAR 0 1
97843: PUSH
97844: LD_INT 22
97846: PUSH
97847: LD_OWVAR 2
97851: PUSH
97852: EMPTY
97853: LIST
97854: LIST
97855: PUSH
97856: LD_INT 2
97858: PUSH
97859: LD_INT 25
97861: PUSH
97862: LD_INT 5
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: PUSH
97869: LD_INT 25
97871: PUSH
97872: LD_INT 9
97874: PUSH
97875: EMPTY
97876: LIST
97877: LIST
97878: PUSH
97879: LD_INT 25
97881: PUSH
97882: LD_INT 8
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PPUSH
97899: CALL_OW 69
97903: PUSH
97904: FOR_IN
97905: IFFALSE 97921
// begin SetClass ( i , 1 ) ;
97907: LD_VAR 0 1
97911: PPUSH
97912: LD_INT 1
97914: PPUSH
97915: CALL_OW 336
// end ;
97919: GO 97904
97921: POP
97922: POP
// end ;
97923: PPOPN 1
97925: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97926: LD_EXP 75
97930: PUSH
97931: LD_EXP 79
97935: AND
97936: PUSH
97937: LD_OWVAR 65
97941: PUSH
97942: LD_INT 7
97944: LESS
97945: AND
97946: IFFALSE 97960
97948: GO 97950
97950: DISABLE
// begin enable ;
97951: ENABLE
// game_speed := 7 ;
97952: LD_ADDR_OWVAR 65
97956: PUSH
97957: LD_INT 7
97959: ST_TO_ADDR
// end ;
97960: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97961: LD_EXP 75
97965: PUSH
97966: LD_EXP 82
97970: AND
97971: IFFALSE 98173
97973: GO 97975
97975: DISABLE
97976: LD_INT 0
97978: PPUSH
97979: PPUSH
97980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97981: LD_ADDR_VAR 0 3
97985: PUSH
97986: LD_INT 81
97988: PUSH
97989: LD_OWVAR 2
97993: PUSH
97994: EMPTY
97995: LIST
97996: LIST
97997: PUSH
97998: LD_INT 21
98000: PUSH
98001: LD_INT 1
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: PPUSH
98012: CALL_OW 69
98016: ST_TO_ADDR
// if not tmp then
98017: LD_VAR 0 3
98021: NOT
98022: IFFALSE 98026
// exit ;
98024: GO 98173
// if tmp > 5 then
98026: LD_VAR 0 3
98030: PUSH
98031: LD_INT 5
98033: GREATER
98034: IFFALSE 98046
// k := 5 else
98036: LD_ADDR_VAR 0 2
98040: PUSH
98041: LD_INT 5
98043: ST_TO_ADDR
98044: GO 98056
// k := tmp ;
98046: LD_ADDR_VAR 0 2
98050: PUSH
98051: LD_VAR 0 3
98055: ST_TO_ADDR
// for i := 1 to k do
98056: LD_ADDR_VAR 0 1
98060: PUSH
98061: DOUBLE
98062: LD_INT 1
98064: DEC
98065: ST_TO_ADDR
98066: LD_VAR 0 2
98070: PUSH
98071: FOR_TO
98072: IFFALSE 98171
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98074: LD_VAR 0 3
98078: PUSH
98079: LD_VAR 0 1
98083: ARRAY
98084: PPUSH
98085: LD_VAR 0 1
98089: PUSH
98090: LD_INT 4
98092: MOD
98093: PUSH
98094: LD_INT 1
98096: PLUS
98097: PPUSH
98098: CALL_OW 259
98102: PUSH
98103: LD_INT 10
98105: LESS
98106: IFFALSE 98169
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98108: LD_VAR 0 3
98112: PUSH
98113: LD_VAR 0 1
98117: ARRAY
98118: PPUSH
98119: LD_VAR 0 1
98123: PUSH
98124: LD_INT 4
98126: MOD
98127: PUSH
98128: LD_INT 1
98130: PLUS
98131: PPUSH
98132: LD_VAR 0 3
98136: PUSH
98137: LD_VAR 0 1
98141: ARRAY
98142: PPUSH
98143: LD_VAR 0 1
98147: PUSH
98148: LD_INT 4
98150: MOD
98151: PUSH
98152: LD_INT 1
98154: PLUS
98155: PPUSH
98156: CALL_OW 259
98160: PUSH
98161: LD_INT 1
98163: PLUS
98164: PPUSH
98165: CALL_OW 237
98169: GO 98071
98171: POP
98172: POP
// end ;
98173: PPOPN 3
98175: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98176: LD_EXP 75
98180: PUSH
98181: LD_EXP 83
98185: AND
98186: IFFALSE 98206
98188: GO 98190
98190: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98191: LD_INT 4
98193: PPUSH
98194: LD_OWVAR 2
98198: PPUSH
98199: LD_INT 0
98201: PPUSH
98202: CALL_OW 324
98206: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98207: LD_EXP 75
98211: PUSH
98212: LD_EXP 112
98216: AND
98217: IFFALSE 98237
98219: GO 98221
98221: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98222: LD_INT 19
98224: PPUSH
98225: LD_OWVAR 2
98229: PPUSH
98230: LD_INT 0
98232: PPUSH
98233: CALL_OW 324
98237: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98238: LD_EXP 75
98242: PUSH
98243: LD_EXP 84
98247: AND
98248: IFFALSE 98350
98250: GO 98252
98252: DISABLE
98253: LD_INT 0
98255: PPUSH
98256: PPUSH
// begin enable ;
98257: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98258: LD_ADDR_VAR 0 2
98262: PUSH
98263: LD_INT 22
98265: PUSH
98266: LD_OWVAR 2
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: PUSH
98275: LD_INT 2
98277: PUSH
98278: LD_INT 34
98280: PUSH
98281: LD_INT 11
98283: PUSH
98284: EMPTY
98285: LIST
98286: LIST
98287: PUSH
98288: LD_INT 34
98290: PUSH
98291: LD_INT 30
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: PUSH
98298: EMPTY
98299: LIST
98300: LIST
98301: LIST
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: PPUSH
98307: CALL_OW 69
98311: ST_TO_ADDR
// if not tmp then
98312: LD_VAR 0 2
98316: NOT
98317: IFFALSE 98321
// exit ;
98319: GO 98350
// for i in tmp do
98321: LD_ADDR_VAR 0 1
98325: PUSH
98326: LD_VAR 0 2
98330: PUSH
98331: FOR_IN
98332: IFFALSE 98348
// begin SetLives ( i , 0 ) ;
98334: LD_VAR 0 1
98338: PPUSH
98339: LD_INT 0
98341: PPUSH
98342: CALL_OW 234
// end ;
98346: GO 98331
98348: POP
98349: POP
// end ;
98350: PPOPN 2
98352: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98353: LD_EXP 75
98357: PUSH
98358: LD_EXP 85
98362: AND
98363: IFFALSE 98383
98365: GO 98367
98367: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98368: LD_INT 32
98370: PPUSH
98371: LD_OWVAR 2
98375: PPUSH
98376: LD_INT 0
98378: PPUSH
98379: CALL_OW 324
98383: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98384: LD_EXP 75
98388: PUSH
98389: LD_EXP 86
98393: AND
98394: IFFALSE 98575
98396: GO 98398
98398: DISABLE
98399: LD_INT 0
98401: PPUSH
98402: PPUSH
98403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98404: LD_ADDR_VAR 0 2
98408: PUSH
98409: LD_INT 22
98411: PUSH
98412: LD_OWVAR 2
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PUSH
98421: LD_INT 33
98423: PUSH
98424: LD_INT 3
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: PUSH
98431: EMPTY
98432: LIST
98433: LIST
98434: PPUSH
98435: CALL_OW 69
98439: ST_TO_ADDR
// if not tmp then
98440: LD_VAR 0 2
98444: NOT
98445: IFFALSE 98449
// exit ;
98447: GO 98575
// side := 0 ;
98449: LD_ADDR_VAR 0 3
98453: PUSH
98454: LD_INT 0
98456: ST_TO_ADDR
// for i := 1 to 8 do
98457: LD_ADDR_VAR 0 1
98461: PUSH
98462: DOUBLE
98463: LD_INT 1
98465: DEC
98466: ST_TO_ADDR
98467: LD_INT 8
98469: PUSH
98470: FOR_TO
98471: IFFALSE 98519
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98473: LD_OWVAR 2
98477: PUSH
98478: LD_VAR 0 1
98482: NONEQUAL
98483: PUSH
98484: LD_OWVAR 2
98488: PPUSH
98489: LD_VAR 0 1
98493: PPUSH
98494: CALL_OW 81
98498: PUSH
98499: LD_INT 2
98501: EQUAL
98502: AND
98503: IFFALSE 98517
// begin side := i ;
98505: LD_ADDR_VAR 0 3
98509: PUSH
98510: LD_VAR 0 1
98514: ST_TO_ADDR
// break ;
98515: GO 98519
// end ;
98517: GO 98470
98519: POP
98520: POP
// if not side then
98521: LD_VAR 0 3
98525: NOT
98526: IFFALSE 98530
// exit ;
98528: GO 98575
// for i := 1 to tmp do
98530: LD_ADDR_VAR 0 1
98534: PUSH
98535: DOUBLE
98536: LD_INT 1
98538: DEC
98539: ST_TO_ADDR
98540: LD_VAR 0 2
98544: PUSH
98545: FOR_TO
98546: IFFALSE 98573
// if Prob ( 60 ) then
98548: LD_INT 60
98550: PPUSH
98551: CALL_OW 13
98555: IFFALSE 98571
// SetSide ( i , side ) ;
98557: LD_VAR 0 1
98561: PPUSH
98562: LD_VAR 0 3
98566: PPUSH
98567: CALL_OW 235
98571: GO 98545
98573: POP
98574: POP
// end ;
98575: PPOPN 3
98577: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98578: LD_EXP 75
98582: PUSH
98583: LD_EXP 88
98587: AND
98588: IFFALSE 98707
98590: GO 98592
98592: DISABLE
98593: LD_INT 0
98595: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98596: LD_ADDR_VAR 0 1
98600: PUSH
98601: LD_INT 22
98603: PUSH
98604: LD_OWVAR 2
98608: PUSH
98609: EMPTY
98610: LIST
98611: LIST
98612: PUSH
98613: LD_INT 21
98615: PUSH
98616: LD_INT 1
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: PUSH
98623: LD_INT 3
98625: PUSH
98626: LD_INT 23
98628: PUSH
98629: LD_INT 0
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: EMPTY
98637: LIST
98638: LIST
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: LIST
98644: PPUSH
98645: CALL_OW 69
98649: PUSH
98650: FOR_IN
98651: IFFALSE 98705
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98653: LD_VAR 0 1
98657: PPUSH
98658: CALL_OW 257
98662: PUSH
98663: LD_INT 1
98665: PUSH
98666: LD_INT 2
98668: PUSH
98669: LD_INT 3
98671: PUSH
98672: LD_INT 4
98674: PUSH
98675: EMPTY
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: IN
98681: IFFALSE 98703
// SetClass ( un , rand ( 1 , 4 ) ) ;
98683: LD_VAR 0 1
98687: PPUSH
98688: LD_INT 1
98690: PPUSH
98691: LD_INT 4
98693: PPUSH
98694: CALL_OW 12
98698: PPUSH
98699: CALL_OW 336
98703: GO 98650
98705: POP
98706: POP
// end ;
98707: PPOPN 1
98709: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98710: LD_EXP 75
98714: PUSH
98715: LD_EXP 87
98719: AND
98720: IFFALSE 98799
98722: GO 98724
98724: DISABLE
98725: LD_INT 0
98727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98728: LD_ADDR_VAR 0 1
98732: PUSH
98733: LD_INT 22
98735: PUSH
98736: LD_OWVAR 2
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_INT 21
98747: PUSH
98748: LD_INT 3
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: PPUSH
98759: CALL_OW 69
98763: ST_TO_ADDR
// if not tmp then
98764: LD_VAR 0 1
98768: NOT
98769: IFFALSE 98773
// exit ;
98771: GO 98799
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98773: LD_VAR 0 1
98777: PUSH
98778: LD_INT 1
98780: PPUSH
98781: LD_VAR 0 1
98785: PPUSH
98786: CALL_OW 12
98790: ARRAY
98791: PPUSH
98792: LD_INT 100
98794: PPUSH
98795: CALL_OW 234
// end ;
98799: PPOPN 1
98801: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98802: LD_EXP 75
98806: PUSH
98807: LD_EXP 89
98811: AND
98812: IFFALSE 98910
98814: GO 98816
98816: DISABLE
98817: LD_INT 0
98819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98820: LD_ADDR_VAR 0 1
98824: PUSH
98825: LD_INT 22
98827: PUSH
98828: LD_OWVAR 2
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: PUSH
98837: LD_INT 21
98839: PUSH
98840: LD_INT 1
98842: PUSH
98843: EMPTY
98844: LIST
98845: LIST
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: PPUSH
98851: CALL_OW 69
98855: ST_TO_ADDR
// if not tmp then
98856: LD_VAR 0 1
98860: NOT
98861: IFFALSE 98865
// exit ;
98863: GO 98910
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98865: LD_VAR 0 1
98869: PUSH
98870: LD_INT 1
98872: PPUSH
98873: LD_VAR 0 1
98877: PPUSH
98878: CALL_OW 12
98882: ARRAY
98883: PPUSH
98884: LD_INT 1
98886: PPUSH
98887: LD_INT 4
98889: PPUSH
98890: CALL_OW 12
98894: PPUSH
98895: LD_INT 3000
98897: PPUSH
98898: LD_INT 9000
98900: PPUSH
98901: CALL_OW 12
98905: PPUSH
98906: CALL_OW 492
// end ;
98910: PPOPN 1
98912: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98913: LD_EXP 75
98917: PUSH
98918: LD_EXP 90
98922: AND
98923: IFFALSE 98943
98925: GO 98927
98927: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98928: LD_INT 1
98930: PPUSH
98931: LD_OWVAR 2
98935: PPUSH
98936: LD_INT 0
98938: PPUSH
98939: CALL_OW 324
98943: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98944: LD_EXP 75
98948: PUSH
98949: LD_EXP 91
98953: AND
98954: IFFALSE 99037
98956: GO 98958
98958: DISABLE
98959: LD_INT 0
98961: PPUSH
98962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98963: LD_ADDR_VAR 0 2
98967: PUSH
98968: LD_INT 22
98970: PUSH
98971: LD_OWVAR 2
98975: PUSH
98976: EMPTY
98977: LIST
98978: LIST
98979: PUSH
98980: LD_INT 21
98982: PUSH
98983: LD_INT 3
98985: PUSH
98986: EMPTY
98987: LIST
98988: LIST
98989: PUSH
98990: EMPTY
98991: LIST
98992: LIST
98993: PPUSH
98994: CALL_OW 69
98998: ST_TO_ADDR
// if not tmp then
98999: LD_VAR 0 2
99003: NOT
99004: IFFALSE 99008
// exit ;
99006: GO 99037
// for i in tmp do
99008: LD_ADDR_VAR 0 1
99012: PUSH
99013: LD_VAR 0 2
99017: PUSH
99018: FOR_IN
99019: IFFALSE 99035
// SetBLevel ( i , 10 ) ;
99021: LD_VAR 0 1
99025: PPUSH
99026: LD_INT 10
99028: PPUSH
99029: CALL_OW 241
99033: GO 99018
99035: POP
99036: POP
// end ;
99037: PPOPN 2
99039: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99040: LD_EXP 75
99044: PUSH
99045: LD_EXP 92
99049: AND
99050: IFFALSE 99161
99052: GO 99054
99054: DISABLE
99055: LD_INT 0
99057: PPUSH
99058: PPUSH
99059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99060: LD_ADDR_VAR 0 3
99064: PUSH
99065: LD_INT 22
99067: PUSH
99068: LD_OWVAR 2
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: PUSH
99077: LD_INT 25
99079: PUSH
99080: LD_INT 1
99082: PUSH
99083: EMPTY
99084: LIST
99085: LIST
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: PPUSH
99091: CALL_OW 69
99095: ST_TO_ADDR
// if not tmp then
99096: LD_VAR 0 3
99100: NOT
99101: IFFALSE 99105
// exit ;
99103: GO 99161
// un := tmp [ rand ( 1 , tmp ) ] ;
99105: LD_ADDR_VAR 0 2
99109: PUSH
99110: LD_VAR 0 3
99114: PUSH
99115: LD_INT 1
99117: PPUSH
99118: LD_VAR 0 3
99122: PPUSH
99123: CALL_OW 12
99127: ARRAY
99128: ST_TO_ADDR
// if Crawls ( un ) then
99129: LD_VAR 0 2
99133: PPUSH
99134: CALL_OW 318
99138: IFFALSE 99149
// ComWalk ( un ) ;
99140: LD_VAR 0 2
99144: PPUSH
99145: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99149: LD_VAR 0 2
99153: PPUSH
99154: LD_INT 5
99156: PPUSH
99157: CALL_OW 336
// end ;
99161: PPOPN 3
99163: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99164: LD_EXP 75
99168: PUSH
99169: LD_EXP 93
99173: AND
99174: PUSH
99175: LD_OWVAR 67
99179: PUSH
99180: LD_INT 4
99182: LESS
99183: AND
99184: IFFALSE 99203
99186: GO 99188
99188: DISABLE
// begin Difficulty := Difficulty + 1 ;
99189: LD_ADDR_OWVAR 67
99193: PUSH
99194: LD_OWVAR 67
99198: PUSH
99199: LD_INT 1
99201: PLUS
99202: ST_TO_ADDR
// end ;
99203: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99204: LD_EXP 75
99208: PUSH
99209: LD_EXP 94
99213: AND
99214: IFFALSE 99317
99216: GO 99218
99218: DISABLE
99219: LD_INT 0
99221: PPUSH
// begin for i := 1 to 5 do
99222: LD_ADDR_VAR 0 1
99226: PUSH
99227: DOUBLE
99228: LD_INT 1
99230: DEC
99231: ST_TO_ADDR
99232: LD_INT 5
99234: PUSH
99235: FOR_TO
99236: IFFALSE 99315
// begin uc_nation := nation_nature ;
99238: LD_ADDR_OWVAR 21
99242: PUSH
99243: LD_INT 0
99245: ST_TO_ADDR
// uc_side := 0 ;
99246: LD_ADDR_OWVAR 20
99250: PUSH
99251: LD_INT 0
99253: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99254: LD_ADDR_OWVAR 29
99258: PUSH
99259: LD_INT 12
99261: PUSH
99262: LD_INT 12
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: ST_TO_ADDR
// hc_agressivity := 20 ;
99269: LD_ADDR_OWVAR 35
99273: PUSH
99274: LD_INT 20
99276: ST_TO_ADDR
// hc_class := class_tiger ;
99277: LD_ADDR_OWVAR 28
99281: PUSH
99282: LD_INT 14
99284: ST_TO_ADDR
// hc_gallery :=  ;
99285: LD_ADDR_OWVAR 33
99289: PUSH
99290: LD_STRING 
99292: ST_TO_ADDR
// hc_name :=  ;
99293: LD_ADDR_OWVAR 26
99297: PUSH
99298: LD_STRING 
99300: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99301: CALL_OW 44
99305: PPUSH
99306: LD_INT 0
99308: PPUSH
99309: CALL_OW 51
// end ;
99313: GO 99235
99315: POP
99316: POP
// end ;
99317: PPOPN 1
99319: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99320: LD_EXP 75
99324: PUSH
99325: LD_EXP 95
99329: AND
99330: IFFALSE 99339
99332: GO 99334
99334: DISABLE
// StreamSibBomb ;
99335: CALL 99340 0 0
99339: END
// export function StreamSibBomb ; var i , x , y ; begin
99340: LD_INT 0
99342: PPUSH
99343: PPUSH
99344: PPUSH
99345: PPUSH
// result := false ;
99346: LD_ADDR_VAR 0 1
99350: PUSH
99351: LD_INT 0
99353: ST_TO_ADDR
// for i := 1 to 16 do
99354: LD_ADDR_VAR 0 2
99358: PUSH
99359: DOUBLE
99360: LD_INT 1
99362: DEC
99363: ST_TO_ADDR
99364: LD_INT 16
99366: PUSH
99367: FOR_TO
99368: IFFALSE 99567
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99370: LD_ADDR_VAR 0 3
99374: PUSH
99375: LD_INT 10
99377: PUSH
99378: LD_INT 20
99380: PUSH
99381: LD_INT 30
99383: PUSH
99384: LD_INT 40
99386: PUSH
99387: LD_INT 50
99389: PUSH
99390: LD_INT 60
99392: PUSH
99393: LD_INT 70
99395: PUSH
99396: LD_INT 80
99398: PUSH
99399: LD_INT 90
99401: PUSH
99402: LD_INT 100
99404: PUSH
99405: LD_INT 110
99407: PUSH
99408: LD_INT 120
99410: PUSH
99411: LD_INT 130
99413: PUSH
99414: LD_INT 140
99416: PUSH
99417: LD_INT 150
99419: PUSH
99420: EMPTY
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: LIST
99434: LIST
99435: LIST
99436: PUSH
99437: LD_INT 1
99439: PPUSH
99440: LD_INT 15
99442: PPUSH
99443: CALL_OW 12
99447: ARRAY
99448: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99449: LD_ADDR_VAR 0 4
99453: PUSH
99454: LD_INT 10
99456: PUSH
99457: LD_INT 20
99459: PUSH
99460: LD_INT 30
99462: PUSH
99463: LD_INT 40
99465: PUSH
99466: LD_INT 50
99468: PUSH
99469: LD_INT 60
99471: PUSH
99472: LD_INT 70
99474: PUSH
99475: LD_INT 80
99477: PUSH
99478: LD_INT 90
99480: PUSH
99481: LD_INT 100
99483: PUSH
99484: LD_INT 110
99486: PUSH
99487: LD_INT 120
99489: PUSH
99490: LD_INT 130
99492: PUSH
99493: LD_INT 140
99495: PUSH
99496: LD_INT 150
99498: PUSH
99499: EMPTY
99500: LIST
99501: LIST
99502: LIST
99503: LIST
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: PUSH
99516: LD_INT 1
99518: PPUSH
99519: LD_INT 15
99521: PPUSH
99522: CALL_OW 12
99526: ARRAY
99527: ST_TO_ADDR
// if ValidHex ( x , y ) then
99528: LD_VAR 0 3
99532: PPUSH
99533: LD_VAR 0 4
99537: PPUSH
99538: CALL_OW 488
99542: IFFALSE 99565
// begin result := [ x , y ] ;
99544: LD_ADDR_VAR 0 1
99548: PUSH
99549: LD_VAR 0 3
99553: PUSH
99554: LD_VAR 0 4
99558: PUSH
99559: EMPTY
99560: LIST
99561: LIST
99562: ST_TO_ADDR
// break ;
99563: GO 99567
// end ; end ;
99565: GO 99367
99567: POP
99568: POP
// if result then
99569: LD_VAR 0 1
99573: IFFALSE 99633
// begin ToLua ( playSibBomb() ) ;
99575: LD_STRING playSibBomb()
99577: PPUSH
99578: CALL_OW 559
// wait ( 0 0$14 ) ;
99582: LD_INT 490
99584: PPUSH
99585: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99589: LD_VAR 0 1
99593: PUSH
99594: LD_INT 1
99596: ARRAY
99597: PPUSH
99598: LD_VAR 0 1
99602: PUSH
99603: LD_INT 2
99605: ARRAY
99606: PPUSH
99607: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99611: LD_VAR 0 1
99615: PUSH
99616: LD_INT 1
99618: ARRAY
99619: PPUSH
99620: LD_VAR 0 1
99624: PUSH
99625: LD_INT 2
99627: ARRAY
99628: PPUSH
99629: CALL_OW 429
// end ; end ;
99633: LD_VAR 0 1
99637: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99638: LD_EXP 75
99642: PUSH
99643: LD_EXP 97
99647: AND
99648: IFFALSE 99660
99650: GO 99652
99652: DISABLE
// YouLost (  ) ;
99653: LD_STRING 
99655: PPUSH
99656: CALL_OW 104
99660: END
// every 0 0$1 trigger StreamModeActive and sFog do
99661: LD_EXP 75
99665: PUSH
99666: LD_EXP 96
99670: AND
99671: IFFALSE 99685
99673: GO 99675
99675: DISABLE
// FogOff ( your_side ) ;
99676: LD_OWVAR 2
99680: PPUSH
99681: CALL_OW 344
99685: END
// every 0 0$1 trigger StreamModeActive and sSun do
99686: LD_EXP 75
99690: PUSH
99691: LD_EXP 98
99695: AND
99696: IFFALSE 99724
99698: GO 99700
99700: DISABLE
// begin solar_recharge_percent := 0 ;
99701: LD_ADDR_OWVAR 79
99705: PUSH
99706: LD_INT 0
99708: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99709: LD_INT 10500
99711: PPUSH
99712: CALL_OW 67
// solar_recharge_percent := 100 ;
99716: LD_ADDR_OWVAR 79
99720: PUSH
99721: LD_INT 100
99723: ST_TO_ADDR
// end ;
99724: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99725: LD_EXP 75
99729: PUSH
99730: LD_EXP 99
99734: AND
99735: IFFALSE 99974
99737: GO 99739
99739: DISABLE
99740: LD_INT 0
99742: PPUSH
99743: PPUSH
99744: PPUSH
// begin tmp := [ ] ;
99745: LD_ADDR_VAR 0 3
99749: PUSH
99750: EMPTY
99751: ST_TO_ADDR
// for i := 1 to 6 do
99752: LD_ADDR_VAR 0 1
99756: PUSH
99757: DOUBLE
99758: LD_INT 1
99760: DEC
99761: ST_TO_ADDR
99762: LD_INT 6
99764: PUSH
99765: FOR_TO
99766: IFFALSE 99871
// begin uc_nation := nation_nature ;
99768: LD_ADDR_OWVAR 21
99772: PUSH
99773: LD_INT 0
99775: ST_TO_ADDR
// uc_side := 0 ;
99776: LD_ADDR_OWVAR 20
99780: PUSH
99781: LD_INT 0
99783: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99784: LD_ADDR_OWVAR 29
99788: PUSH
99789: LD_INT 12
99791: PUSH
99792: LD_INT 12
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: ST_TO_ADDR
// hc_agressivity := 20 ;
99799: LD_ADDR_OWVAR 35
99803: PUSH
99804: LD_INT 20
99806: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99807: LD_ADDR_OWVAR 28
99811: PUSH
99812: LD_INT 17
99814: ST_TO_ADDR
// hc_gallery :=  ;
99815: LD_ADDR_OWVAR 33
99819: PUSH
99820: LD_STRING 
99822: ST_TO_ADDR
// hc_name :=  ;
99823: LD_ADDR_OWVAR 26
99827: PUSH
99828: LD_STRING 
99830: ST_TO_ADDR
// un := CreateHuman ;
99831: LD_ADDR_VAR 0 2
99835: PUSH
99836: CALL_OW 44
99840: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99841: LD_VAR 0 2
99845: PPUSH
99846: LD_INT 1
99848: PPUSH
99849: CALL_OW 51
// tmp := tmp ^ un ;
99853: LD_ADDR_VAR 0 3
99857: PUSH
99858: LD_VAR 0 3
99862: PUSH
99863: LD_VAR 0 2
99867: ADD
99868: ST_TO_ADDR
// end ;
99869: GO 99765
99871: POP
99872: POP
// repeat wait ( 0 0$1 ) ;
99873: LD_INT 35
99875: PPUSH
99876: CALL_OW 67
// for un in tmp do
99880: LD_ADDR_VAR 0 2
99884: PUSH
99885: LD_VAR 0 3
99889: PUSH
99890: FOR_IN
99891: IFFALSE 99965
// begin if IsDead ( un ) then
99893: LD_VAR 0 2
99897: PPUSH
99898: CALL_OW 301
99902: IFFALSE 99922
// begin tmp := tmp diff un ;
99904: LD_ADDR_VAR 0 3
99908: PUSH
99909: LD_VAR 0 3
99913: PUSH
99914: LD_VAR 0 2
99918: DIFF
99919: ST_TO_ADDR
// continue ;
99920: GO 99890
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99922: LD_VAR 0 2
99926: PPUSH
99927: LD_INT 3
99929: PUSH
99930: LD_INT 22
99932: PUSH
99933: LD_INT 0
99935: PUSH
99936: EMPTY
99937: LIST
99938: LIST
99939: PUSH
99940: EMPTY
99941: LIST
99942: LIST
99943: PPUSH
99944: CALL_OW 69
99948: PPUSH
99949: LD_VAR 0 2
99953: PPUSH
99954: CALL_OW 74
99958: PPUSH
99959: CALL_OW 115
// end ;
99963: GO 99890
99965: POP
99966: POP
// until not tmp ;
99967: LD_VAR 0 3
99971: NOT
99972: IFFALSE 99873
// end ;
99974: PPOPN 3
99976: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99977: LD_EXP 75
99981: PUSH
99982: LD_EXP 100
99986: AND
99987: IFFALSE 100041
99989: GO 99991
99991: DISABLE
// begin ToLua ( displayTroll(); ) ;
99992: LD_STRING displayTroll();
99994: PPUSH
99995: CALL_OW 559
// wait ( 3 3$00 ) ;
99999: LD_INT 6300
100001: PPUSH
100002: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100006: LD_STRING hideTroll();
100008: PPUSH
100009: CALL_OW 559
// wait ( 1 1$00 ) ;
100013: LD_INT 2100
100015: PPUSH
100016: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100020: LD_STRING displayTroll();
100022: PPUSH
100023: CALL_OW 559
// wait ( 1 1$00 ) ;
100027: LD_INT 2100
100029: PPUSH
100030: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100034: LD_STRING hideTroll();
100036: PPUSH
100037: CALL_OW 559
// end ;
100041: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100042: LD_EXP 75
100046: PUSH
100047: LD_EXP 101
100051: AND
100052: IFFALSE 100115
100054: GO 100056
100056: DISABLE
100057: LD_INT 0
100059: PPUSH
// begin p := 0 ;
100060: LD_ADDR_VAR 0 1
100064: PUSH
100065: LD_INT 0
100067: ST_TO_ADDR
// repeat game_speed := 1 ;
100068: LD_ADDR_OWVAR 65
100072: PUSH
100073: LD_INT 1
100075: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100076: LD_INT 35
100078: PPUSH
100079: CALL_OW 67
// p := p + 1 ;
100083: LD_ADDR_VAR 0 1
100087: PUSH
100088: LD_VAR 0 1
100092: PUSH
100093: LD_INT 1
100095: PLUS
100096: ST_TO_ADDR
// until p >= 60 ;
100097: LD_VAR 0 1
100101: PUSH
100102: LD_INT 60
100104: GREATEREQUAL
100105: IFFALSE 100068
// game_speed := 4 ;
100107: LD_ADDR_OWVAR 65
100111: PUSH
100112: LD_INT 4
100114: ST_TO_ADDR
// end ;
100115: PPOPN 1
100117: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100118: LD_EXP 75
100122: PUSH
100123: LD_EXP 102
100127: AND
100128: IFFALSE 100274
100130: GO 100132
100132: DISABLE
100133: LD_INT 0
100135: PPUSH
100136: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100137: LD_ADDR_VAR 0 1
100141: PUSH
100142: LD_INT 22
100144: PUSH
100145: LD_OWVAR 2
100149: PUSH
100150: EMPTY
100151: LIST
100152: LIST
100153: PUSH
100154: LD_INT 2
100156: PUSH
100157: LD_INT 30
100159: PUSH
100160: LD_INT 0
100162: PUSH
100163: EMPTY
100164: LIST
100165: LIST
100166: PUSH
100167: LD_INT 30
100169: PUSH
100170: LD_INT 1
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: LIST
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: PPUSH
100186: CALL_OW 69
100190: ST_TO_ADDR
// if not depot then
100191: LD_VAR 0 1
100195: NOT
100196: IFFALSE 100200
// exit ;
100198: GO 100274
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100200: LD_ADDR_VAR 0 2
100204: PUSH
100205: LD_VAR 0 1
100209: PUSH
100210: LD_INT 1
100212: PPUSH
100213: LD_VAR 0 1
100217: PPUSH
100218: CALL_OW 12
100222: ARRAY
100223: PPUSH
100224: CALL_OW 274
100228: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100229: LD_VAR 0 2
100233: PPUSH
100234: LD_INT 1
100236: PPUSH
100237: LD_INT 0
100239: PPUSH
100240: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100244: LD_VAR 0 2
100248: PPUSH
100249: LD_INT 2
100251: PPUSH
100252: LD_INT 0
100254: PPUSH
100255: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100259: LD_VAR 0 2
100263: PPUSH
100264: LD_INT 3
100266: PPUSH
100267: LD_INT 0
100269: PPUSH
100270: CALL_OW 277
// end ;
100274: PPOPN 2
100276: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100277: LD_EXP 75
100281: PUSH
100282: LD_EXP 103
100286: AND
100287: IFFALSE 100384
100289: GO 100291
100291: DISABLE
100292: LD_INT 0
100294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100295: LD_ADDR_VAR 0 1
100299: PUSH
100300: LD_INT 22
100302: PUSH
100303: LD_OWVAR 2
100307: PUSH
100308: EMPTY
100309: LIST
100310: LIST
100311: PUSH
100312: LD_INT 21
100314: PUSH
100315: LD_INT 1
100317: PUSH
100318: EMPTY
100319: LIST
100320: LIST
100321: PUSH
100322: LD_INT 3
100324: PUSH
100325: LD_INT 23
100327: PUSH
100328: LD_INT 0
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: PUSH
100335: EMPTY
100336: LIST
100337: LIST
100338: PUSH
100339: EMPTY
100340: LIST
100341: LIST
100342: LIST
100343: PPUSH
100344: CALL_OW 69
100348: ST_TO_ADDR
// if not tmp then
100349: LD_VAR 0 1
100353: NOT
100354: IFFALSE 100358
// exit ;
100356: GO 100384
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100358: LD_VAR 0 1
100362: PUSH
100363: LD_INT 1
100365: PPUSH
100366: LD_VAR 0 1
100370: PPUSH
100371: CALL_OW 12
100375: ARRAY
100376: PPUSH
100377: LD_INT 200
100379: PPUSH
100380: CALL_OW 234
// end ;
100384: PPOPN 1
100386: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100387: LD_EXP 75
100391: PUSH
100392: LD_EXP 104
100396: AND
100397: IFFALSE 100476
100399: GO 100401
100401: DISABLE
100402: LD_INT 0
100404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100405: LD_ADDR_VAR 0 1
100409: PUSH
100410: LD_INT 22
100412: PUSH
100413: LD_OWVAR 2
100417: PUSH
100418: EMPTY
100419: LIST
100420: LIST
100421: PUSH
100422: LD_INT 21
100424: PUSH
100425: LD_INT 2
100427: PUSH
100428: EMPTY
100429: LIST
100430: LIST
100431: PUSH
100432: EMPTY
100433: LIST
100434: LIST
100435: PPUSH
100436: CALL_OW 69
100440: ST_TO_ADDR
// if not tmp then
100441: LD_VAR 0 1
100445: NOT
100446: IFFALSE 100450
// exit ;
100448: GO 100476
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100450: LD_VAR 0 1
100454: PUSH
100455: LD_INT 1
100457: PPUSH
100458: LD_VAR 0 1
100462: PPUSH
100463: CALL_OW 12
100467: ARRAY
100468: PPUSH
100469: LD_INT 60
100471: PPUSH
100472: CALL_OW 234
// end ;
100476: PPOPN 1
100478: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100479: LD_EXP 75
100483: PUSH
100484: LD_EXP 105
100488: AND
100489: IFFALSE 100588
100491: GO 100493
100493: DISABLE
100494: LD_INT 0
100496: PPUSH
100497: PPUSH
// begin enable ;
100498: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100499: LD_ADDR_VAR 0 1
100503: PUSH
100504: LD_INT 22
100506: PUSH
100507: LD_OWVAR 2
100511: PUSH
100512: EMPTY
100513: LIST
100514: LIST
100515: PUSH
100516: LD_INT 61
100518: PUSH
100519: EMPTY
100520: LIST
100521: PUSH
100522: LD_INT 33
100524: PUSH
100525: LD_INT 2
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: PUSH
100532: EMPTY
100533: LIST
100534: LIST
100535: LIST
100536: PPUSH
100537: CALL_OW 69
100541: ST_TO_ADDR
// if not tmp then
100542: LD_VAR 0 1
100546: NOT
100547: IFFALSE 100551
// exit ;
100549: GO 100588
// for i in tmp do
100551: LD_ADDR_VAR 0 2
100555: PUSH
100556: LD_VAR 0 1
100560: PUSH
100561: FOR_IN
100562: IFFALSE 100586
// if IsControledBy ( i ) then
100564: LD_VAR 0 2
100568: PPUSH
100569: CALL_OW 312
100573: IFFALSE 100584
// ComUnlink ( i ) ;
100575: LD_VAR 0 2
100579: PPUSH
100580: CALL_OW 136
100584: GO 100561
100586: POP
100587: POP
// end ;
100588: PPOPN 2
100590: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100591: LD_EXP 75
100595: PUSH
100596: LD_EXP 106
100600: AND
100601: IFFALSE 100741
100603: GO 100605
100605: DISABLE
100606: LD_INT 0
100608: PPUSH
100609: PPUSH
// begin ToLua ( displayPowell(); ) ;
100610: LD_STRING displayPowell();
100612: PPUSH
100613: CALL_OW 559
// uc_side := 0 ;
100617: LD_ADDR_OWVAR 20
100621: PUSH
100622: LD_INT 0
100624: ST_TO_ADDR
// uc_nation := 2 ;
100625: LD_ADDR_OWVAR 21
100629: PUSH
100630: LD_INT 2
100632: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100633: LD_ADDR_OWVAR 37
100637: PUSH
100638: LD_INT 14
100640: ST_TO_ADDR
// vc_engine := engine_siberite ;
100641: LD_ADDR_OWVAR 39
100645: PUSH
100646: LD_INT 3
100648: ST_TO_ADDR
// vc_control := control_apeman ;
100649: LD_ADDR_OWVAR 38
100653: PUSH
100654: LD_INT 5
100656: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100657: LD_ADDR_OWVAR 40
100661: PUSH
100662: LD_INT 29
100664: ST_TO_ADDR
// un := CreateVehicle ;
100665: LD_ADDR_VAR 0 2
100669: PUSH
100670: CALL_OW 45
100674: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100675: LD_VAR 0 2
100679: PPUSH
100680: LD_INT 1
100682: PPUSH
100683: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100687: LD_INT 35
100689: PPUSH
100690: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100694: LD_VAR 0 2
100698: PPUSH
100699: LD_INT 22
100701: PUSH
100702: LD_OWVAR 2
100706: PUSH
100707: EMPTY
100708: LIST
100709: LIST
100710: PPUSH
100711: CALL_OW 69
100715: PPUSH
100716: LD_VAR 0 2
100720: PPUSH
100721: CALL_OW 74
100725: PPUSH
100726: CALL_OW 115
// until IsDead ( un ) ;
100730: LD_VAR 0 2
100734: PPUSH
100735: CALL_OW 301
100739: IFFALSE 100687
// end ;
100741: PPOPN 2
100743: END
// every 0 0$1 trigger StreamModeActive and sStu do
100744: LD_EXP 75
100748: PUSH
100749: LD_EXP 114
100753: AND
100754: IFFALSE 100770
100756: GO 100758
100758: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100759: LD_STRING displayStucuk();
100761: PPUSH
100762: CALL_OW 559
// ResetFog ;
100766: CALL_OW 335
// end ;
100770: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100771: LD_EXP 75
100775: PUSH
100776: LD_EXP 107
100780: AND
100781: IFFALSE 100922
100783: GO 100785
100785: DISABLE
100786: LD_INT 0
100788: PPUSH
100789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100790: LD_ADDR_VAR 0 2
100794: PUSH
100795: LD_INT 22
100797: PUSH
100798: LD_OWVAR 2
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 21
100809: PUSH
100810: LD_INT 1
100812: PUSH
100813: EMPTY
100814: LIST
100815: LIST
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: PPUSH
100821: CALL_OW 69
100825: ST_TO_ADDR
// if not tmp then
100826: LD_VAR 0 2
100830: NOT
100831: IFFALSE 100835
// exit ;
100833: GO 100922
// un := tmp [ rand ( 1 , tmp ) ] ;
100835: LD_ADDR_VAR 0 1
100839: PUSH
100840: LD_VAR 0 2
100844: PUSH
100845: LD_INT 1
100847: PPUSH
100848: LD_VAR 0 2
100852: PPUSH
100853: CALL_OW 12
100857: ARRAY
100858: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100859: LD_VAR 0 1
100863: PPUSH
100864: LD_INT 0
100866: PPUSH
100867: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100871: LD_VAR 0 1
100875: PPUSH
100876: LD_OWVAR 3
100880: PUSH
100881: LD_VAR 0 1
100885: DIFF
100886: PPUSH
100887: LD_VAR 0 1
100891: PPUSH
100892: CALL_OW 74
100896: PPUSH
100897: CALL_OW 115
// wait ( 0 0$20 ) ;
100901: LD_INT 700
100903: PPUSH
100904: CALL_OW 67
// SetSide ( un , your_side ) ;
100908: LD_VAR 0 1
100912: PPUSH
100913: LD_OWVAR 2
100917: PPUSH
100918: CALL_OW 235
// end ;
100922: PPOPN 2
100924: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100925: LD_EXP 75
100929: PUSH
100930: LD_EXP 108
100934: AND
100935: IFFALSE 101041
100937: GO 100939
100939: DISABLE
100940: LD_INT 0
100942: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100943: LD_ADDR_VAR 0 1
100947: PUSH
100948: LD_INT 22
100950: PUSH
100951: LD_OWVAR 2
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: PUSH
100960: LD_INT 2
100962: PUSH
100963: LD_INT 30
100965: PUSH
100966: LD_INT 0
100968: PUSH
100969: EMPTY
100970: LIST
100971: LIST
100972: PUSH
100973: LD_INT 30
100975: PUSH
100976: LD_INT 1
100978: PUSH
100979: EMPTY
100980: LIST
100981: LIST
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: LIST
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: PPUSH
100992: CALL_OW 69
100996: ST_TO_ADDR
// if not depot then
100997: LD_VAR 0 1
101001: NOT
101002: IFFALSE 101006
// exit ;
101004: GO 101041
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101006: LD_VAR 0 1
101010: PUSH
101011: LD_INT 1
101013: ARRAY
101014: PPUSH
101015: CALL_OW 250
101019: PPUSH
101020: LD_VAR 0 1
101024: PUSH
101025: LD_INT 1
101027: ARRAY
101028: PPUSH
101029: CALL_OW 251
101033: PPUSH
101034: LD_INT 70
101036: PPUSH
101037: CALL_OW 495
// end ;
101041: PPOPN 1
101043: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101044: LD_EXP 75
101048: PUSH
101049: LD_EXP 109
101053: AND
101054: IFFALSE 101265
101056: GO 101058
101058: DISABLE
101059: LD_INT 0
101061: PPUSH
101062: PPUSH
101063: PPUSH
101064: PPUSH
101065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101066: LD_ADDR_VAR 0 5
101070: PUSH
101071: LD_INT 22
101073: PUSH
101074: LD_OWVAR 2
101078: PUSH
101079: EMPTY
101080: LIST
101081: LIST
101082: PUSH
101083: LD_INT 21
101085: PUSH
101086: LD_INT 1
101088: PUSH
101089: EMPTY
101090: LIST
101091: LIST
101092: PUSH
101093: EMPTY
101094: LIST
101095: LIST
101096: PPUSH
101097: CALL_OW 69
101101: ST_TO_ADDR
// if not tmp then
101102: LD_VAR 0 5
101106: NOT
101107: IFFALSE 101111
// exit ;
101109: GO 101265
// for i in tmp do
101111: LD_ADDR_VAR 0 1
101115: PUSH
101116: LD_VAR 0 5
101120: PUSH
101121: FOR_IN
101122: IFFALSE 101263
// begin d := rand ( 0 , 5 ) ;
101124: LD_ADDR_VAR 0 4
101128: PUSH
101129: LD_INT 0
101131: PPUSH
101132: LD_INT 5
101134: PPUSH
101135: CALL_OW 12
101139: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101140: LD_ADDR_VAR 0 2
101144: PUSH
101145: LD_VAR 0 1
101149: PPUSH
101150: CALL_OW 250
101154: PPUSH
101155: LD_VAR 0 4
101159: PPUSH
101160: LD_INT 3
101162: PPUSH
101163: LD_INT 12
101165: PPUSH
101166: CALL_OW 12
101170: PPUSH
101171: CALL_OW 272
101175: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101176: LD_ADDR_VAR 0 3
101180: PUSH
101181: LD_VAR 0 1
101185: PPUSH
101186: CALL_OW 251
101190: PPUSH
101191: LD_VAR 0 4
101195: PPUSH
101196: LD_INT 3
101198: PPUSH
101199: LD_INT 12
101201: PPUSH
101202: CALL_OW 12
101206: PPUSH
101207: CALL_OW 273
101211: ST_TO_ADDR
// if ValidHex ( x , y ) then
101212: LD_VAR 0 2
101216: PPUSH
101217: LD_VAR 0 3
101221: PPUSH
101222: CALL_OW 488
101226: IFFALSE 101261
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101228: LD_VAR 0 1
101232: PPUSH
101233: LD_VAR 0 2
101237: PPUSH
101238: LD_VAR 0 3
101242: PPUSH
101243: LD_INT 3
101245: PPUSH
101246: LD_INT 6
101248: PPUSH
101249: CALL_OW 12
101253: PPUSH
101254: LD_INT 1
101256: PPUSH
101257: CALL_OW 483
// end ;
101261: GO 101121
101263: POP
101264: POP
// end ;
101265: PPOPN 5
101267: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101268: LD_EXP 75
101272: PUSH
101273: LD_EXP 110
101277: AND
101278: IFFALSE 101372
101280: GO 101282
101282: DISABLE
101283: LD_INT 0
101285: PPUSH
101286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101287: LD_ADDR_VAR 0 2
101291: PUSH
101292: LD_INT 22
101294: PUSH
101295: LD_OWVAR 2
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PUSH
101304: LD_INT 32
101306: PUSH
101307: LD_INT 1
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PUSH
101314: LD_INT 21
101316: PUSH
101317: LD_INT 2
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: LIST
101328: PPUSH
101329: CALL_OW 69
101333: ST_TO_ADDR
// if not tmp then
101334: LD_VAR 0 2
101338: NOT
101339: IFFALSE 101343
// exit ;
101341: GO 101372
// for i in tmp do
101343: LD_ADDR_VAR 0 1
101347: PUSH
101348: LD_VAR 0 2
101352: PUSH
101353: FOR_IN
101354: IFFALSE 101370
// SetFuel ( i , 0 ) ;
101356: LD_VAR 0 1
101360: PPUSH
101361: LD_INT 0
101363: PPUSH
101364: CALL_OW 240
101368: GO 101353
101370: POP
101371: POP
// end ;
101372: PPOPN 2
101374: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101375: LD_EXP 75
101379: PUSH
101380: LD_EXP 111
101384: AND
101385: IFFALSE 101451
101387: GO 101389
101389: DISABLE
101390: LD_INT 0
101392: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101393: LD_ADDR_VAR 0 1
101397: PUSH
101398: LD_INT 22
101400: PUSH
101401: LD_OWVAR 2
101405: PUSH
101406: EMPTY
101407: LIST
101408: LIST
101409: PUSH
101410: LD_INT 30
101412: PUSH
101413: LD_INT 29
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: PUSH
101420: EMPTY
101421: LIST
101422: LIST
101423: PPUSH
101424: CALL_OW 69
101428: ST_TO_ADDR
// if not tmp then
101429: LD_VAR 0 1
101433: NOT
101434: IFFALSE 101438
// exit ;
101436: GO 101451
// DestroyUnit ( tmp [ 1 ] ) ;
101438: LD_VAR 0 1
101442: PUSH
101443: LD_INT 1
101445: ARRAY
101446: PPUSH
101447: CALL_OW 65
// end ;
101451: PPOPN 1
101453: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101454: LD_EXP 75
101458: PUSH
101459: LD_EXP 113
101463: AND
101464: IFFALSE 101593
101466: GO 101468
101468: DISABLE
101469: LD_INT 0
101471: PPUSH
// begin uc_side := 0 ;
101472: LD_ADDR_OWVAR 20
101476: PUSH
101477: LD_INT 0
101479: ST_TO_ADDR
// uc_nation := nation_arabian ;
101480: LD_ADDR_OWVAR 21
101484: PUSH
101485: LD_INT 2
101487: ST_TO_ADDR
// hc_gallery :=  ;
101488: LD_ADDR_OWVAR 33
101492: PUSH
101493: LD_STRING 
101495: ST_TO_ADDR
// hc_name :=  ;
101496: LD_ADDR_OWVAR 26
101500: PUSH
101501: LD_STRING 
101503: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101504: LD_INT 1
101506: PPUSH
101507: LD_INT 11
101509: PPUSH
101510: LD_INT 10
101512: PPUSH
101513: CALL_OW 380
// un := CreateHuman ;
101517: LD_ADDR_VAR 0 1
101521: PUSH
101522: CALL_OW 44
101526: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101527: LD_VAR 0 1
101531: PPUSH
101532: LD_INT 1
101534: PPUSH
101535: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101539: LD_INT 35
101541: PPUSH
101542: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101546: LD_VAR 0 1
101550: PPUSH
101551: LD_INT 22
101553: PUSH
101554: LD_OWVAR 2
101558: PUSH
101559: EMPTY
101560: LIST
101561: LIST
101562: PPUSH
101563: CALL_OW 69
101567: PPUSH
101568: LD_VAR 0 1
101572: PPUSH
101573: CALL_OW 74
101577: PPUSH
101578: CALL_OW 115
// until IsDead ( un ) ;
101582: LD_VAR 0 1
101586: PPUSH
101587: CALL_OW 301
101591: IFFALSE 101539
// end ;
101593: PPOPN 1
101595: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101596: LD_EXP 75
101600: PUSH
101601: LD_EXP 115
101605: AND
101606: IFFALSE 101618
101608: GO 101610
101610: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101611: LD_STRING earthquake(getX(game), 0, 32)
101613: PPUSH
101614: CALL_OW 559
101618: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101619: LD_EXP 75
101623: PUSH
101624: LD_EXP 116
101628: AND
101629: IFFALSE 101720
101631: GO 101633
101633: DISABLE
101634: LD_INT 0
101636: PPUSH
// begin enable ;
101637: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101638: LD_ADDR_VAR 0 1
101642: PUSH
101643: LD_INT 22
101645: PUSH
101646: LD_OWVAR 2
101650: PUSH
101651: EMPTY
101652: LIST
101653: LIST
101654: PUSH
101655: LD_INT 21
101657: PUSH
101658: LD_INT 2
101660: PUSH
101661: EMPTY
101662: LIST
101663: LIST
101664: PUSH
101665: LD_INT 33
101667: PUSH
101668: LD_INT 3
101670: PUSH
101671: EMPTY
101672: LIST
101673: LIST
101674: PUSH
101675: EMPTY
101676: LIST
101677: LIST
101678: LIST
101679: PPUSH
101680: CALL_OW 69
101684: ST_TO_ADDR
// if not tmp then
101685: LD_VAR 0 1
101689: NOT
101690: IFFALSE 101694
// exit ;
101692: GO 101720
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101694: LD_VAR 0 1
101698: PUSH
101699: LD_INT 1
101701: PPUSH
101702: LD_VAR 0 1
101706: PPUSH
101707: CALL_OW 12
101711: ARRAY
101712: PPUSH
101713: LD_INT 1
101715: PPUSH
101716: CALL_OW 234
// end ;
101720: PPOPN 1
101722: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101723: LD_EXP 75
101727: PUSH
101728: LD_EXP 117
101732: AND
101733: IFFALSE 101874
101735: GO 101737
101737: DISABLE
101738: LD_INT 0
101740: PPUSH
101741: PPUSH
101742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101743: LD_ADDR_VAR 0 3
101747: PUSH
101748: LD_INT 22
101750: PUSH
101751: LD_OWVAR 2
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: PUSH
101760: LD_INT 25
101762: PUSH
101763: LD_INT 1
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: EMPTY
101771: LIST
101772: LIST
101773: PPUSH
101774: CALL_OW 69
101778: ST_TO_ADDR
// if not tmp then
101779: LD_VAR 0 3
101783: NOT
101784: IFFALSE 101788
// exit ;
101786: GO 101874
// un := tmp [ rand ( 1 , tmp ) ] ;
101788: LD_ADDR_VAR 0 2
101792: PUSH
101793: LD_VAR 0 3
101797: PUSH
101798: LD_INT 1
101800: PPUSH
101801: LD_VAR 0 3
101805: PPUSH
101806: CALL_OW 12
101810: ARRAY
101811: ST_TO_ADDR
// if Crawls ( un ) then
101812: LD_VAR 0 2
101816: PPUSH
101817: CALL_OW 318
101821: IFFALSE 101832
// ComWalk ( un ) ;
101823: LD_VAR 0 2
101827: PPUSH
101828: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101832: LD_VAR 0 2
101836: PPUSH
101837: LD_INT 9
101839: PPUSH
101840: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101844: LD_INT 28
101846: PPUSH
101847: LD_OWVAR 2
101851: PPUSH
101852: LD_INT 2
101854: PPUSH
101855: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101859: LD_INT 29
101861: PPUSH
101862: LD_OWVAR 2
101866: PPUSH
101867: LD_INT 2
101869: PPUSH
101870: CALL_OW 322
// end ;
101874: PPOPN 3
101876: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101877: LD_EXP 75
101881: PUSH
101882: LD_EXP 118
101886: AND
101887: IFFALSE 101998
101889: GO 101891
101891: DISABLE
101892: LD_INT 0
101894: PPUSH
101895: PPUSH
101896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101897: LD_ADDR_VAR 0 3
101901: PUSH
101902: LD_INT 22
101904: PUSH
101905: LD_OWVAR 2
101909: PUSH
101910: EMPTY
101911: LIST
101912: LIST
101913: PUSH
101914: LD_INT 25
101916: PUSH
101917: LD_INT 1
101919: PUSH
101920: EMPTY
101921: LIST
101922: LIST
101923: PUSH
101924: EMPTY
101925: LIST
101926: LIST
101927: PPUSH
101928: CALL_OW 69
101932: ST_TO_ADDR
// if not tmp then
101933: LD_VAR 0 3
101937: NOT
101938: IFFALSE 101942
// exit ;
101940: GO 101998
// un := tmp [ rand ( 1 , tmp ) ] ;
101942: LD_ADDR_VAR 0 2
101946: PUSH
101947: LD_VAR 0 3
101951: PUSH
101952: LD_INT 1
101954: PPUSH
101955: LD_VAR 0 3
101959: PPUSH
101960: CALL_OW 12
101964: ARRAY
101965: ST_TO_ADDR
// if Crawls ( un ) then
101966: LD_VAR 0 2
101970: PPUSH
101971: CALL_OW 318
101975: IFFALSE 101986
// ComWalk ( un ) ;
101977: LD_VAR 0 2
101981: PPUSH
101982: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101986: LD_VAR 0 2
101990: PPUSH
101991: LD_INT 8
101993: PPUSH
101994: CALL_OW 336
// end ;
101998: PPOPN 3
102000: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102001: LD_EXP 75
102005: PUSH
102006: LD_EXP 119
102010: AND
102011: IFFALSE 102155
102013: GO 102015
102015: DISABLE
102016: LD_INT 0
102018: PPUSH
102019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102020: LD_ADDR_VAR 0 2
102024: PUSH
102025: LD_INT 22
102027: PUSH
102028: LD_OWVAR 2
102032: PUSH
102033: EMPTY
102034: LIST
102035: LIST
102036: PUSH
102037: LD_INT 21
102039: PUSH
102040: LD_INT 2
102042: PUSH
102043: EMPTY
102044: LIST
102045: LIST
102046: PUSH
102047: LD_INT 2
102049: PUSH
102050: LD_INT 34
102052: PUSH
102053: LD_INT 12
102055: PUSH
102056: EMPTY
102057: LIST
102058: LIST
102059: PUSH
102060: LD_INT 34
102062: PUSH
102063: LD_INT 51
102065: PUSH
102066: EMPTY
102067: LIST
102068: LIST
102069: PUSH
102070: LD_INT 34
102072: PUSH
102073: LD_INT 32
102075: PUSH
102076: EMPTY
102077: LIST
102078: LIST
102079: PUSH
102080: EMPTY
102081: LIST
102082: LIST
102083: LIST
102084: LIST
102085: PUSH
102086: EMPTY
102087: LIST
102088: LIST
102089: LIST
102090: PPUSH
102091: CALL_OW 69
102095: ST_TO_ADDR
// if not tmp then
102096: LD_VAR 0 2
102100: NOT
102101: IFFALSE 102105
// exit ;
102103: GO 102155
// for i in tmp do
102105: LD_ADDR_VAR 0 1
102109: PUSH
102110: LD_VAR 0 2
102114: PUSH
102115: FOR_IN
102116: IFFALSE 102153
// if GetCargo ( i , mat_artifact ) = 0 then
102118: LD_VAR 0 1
102122: PPUSH
102123: LD_INT 4
102125: PPUSH
102126: CALL_OW 289
102130: PUSH
102131: LD_INT 0
102133: EQUAL
102134: IFFALSE 102151
// SetCargo ( i , mat_siberit , 100 ) ;
102136: LD_VAR 0 1
102140: PPUSH
102141: LD_INT 3
102143: PPUSH
102144: LD_INT 100
102146: PPUSH
102147: CALL_OW 290
102151: GO 102115
102153: POP
102154: POP
// end ;
102155: PPOPN 2
102157: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102158: LD_EXP 75
102162: PUSH
102163: LD_EXP 120
102167: AND
102168: IFFALSE 102351
102170: GO 102172
102172: DISABLE
102173: LD_INT 0
102175: PPUSH
102176: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102177: LD_ADDR_VAR 0 2
102181: PUSH
102182: LD_INT 22
102184: PUSH
102185: LD_OWVAR 2
102189: PUSH
102190: EMPTY
102191: LIST
102192: LIST
102193: PPUSH
102194: CALL_OW 69
102198: ST_TO_ADDR
// if not tmp then
102199: LD_VAR 0 2
102203: NOT
102204: IFFALSE 102208
// exit ;
102206: GO 102351
// for i := 1 to 2 do
102208: LD_ADDR_VAR 0 1
102212: PUSH
102213: DOUBLE
102214: LD_INT 1
102216: DEC
102217: ST_TO_ADDR
102218: LD_INT 2
102220: PUSH
102221: FOR_TO
102222: IFFALSE 102349
// begin uc_side := your_side ;
102224: LD_ADDR_OWVAR 20
102228: PUSH
102229: LD_OWVAR 2
102233: ST_TO_ADDR
// uc_nation := nation_american ;
102234: LD_ADDR_OWVAR 21
102238: PUSH
102239: LD_INT 1
102241: ST_TO_ADDR
// vc_chassis := us_morphling ;
102242: LD_ADDR_OWVAR 37
102246: PUSH
102247: LD_INT 5
102249: ST_TO_ADDR
// vc_engine := engine_siberite ;
102250: LD_ADDR_OWVAR 39
102254: PUSH
102255: LD_INT 3
102257: ST_TO_ADDR
// vc_control := control_computer ;
102258: LD_ADDR_OWVAR 38
102262: PUSH
102263: LD_INT 3
102265: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102266: LD_ADDR_OWVAR 40
102270: PUSH
102271: LD_INT 10
102273: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102274: LD_VAR 0 2
102278: PUSH
102279: LD_INT 1
102281: ARRAY
102282: PPUSH
102283: CALL_OW 310
102287: NOT
102288: IFFALSE 102335
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102290: CALL_OW 45
102294: PPUSH
102295: LD_VAR 0 2
102299: PUSH
102300: LD_INT 1
102302: ARRAY
102303: PPUSH
102304: CALL_OW 250
102308: PPUSH
102309: LD_VAR 0 2
102313: PUSH
102314: LD_INT 1
102316: ARRAY
102317: PPUSH
102318: CALL_OW 251
102322: PPUSH
102323: LD_INT 12
102325: PPUSH
102326: LD_INT 1
102328: PPUSH
102329: CALL_OW 50
102333: GO 102347
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102335: CALL_OW 45
102339: PPUSH
102340: LD_INT 1
102342: PPUSH
102343: CALL_OW 51
// end ;
102347: GO 102221
102349: POP
102350: POP
// end ;
102351: PPOPN 2
102353: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102354: LD_EXP 75
102358: PUSH
102359: LD_EXP 121
102363: AND
102364: IFFALSE 102586
102366: GO 102368
102368: DISABLE
102369: LD_INT 0
102371: PPUSH
102372: PPUSH
102373: PPUSH
102374: PPUSH
102375: PPUSH
102376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102377: LD_ADDR_VAR 0 6
102381: PUSH
102382: LD_INT 22
102384: PUSH
102385: LD_OWVAR 2
102389: PUSH
102390: EMPTY
102391: LIST
102392: LIST
102393: PUSH
102394: LD_INT 21
102396: PUSH
102397: LD_INT 1
102399: PUSH
102400: EMPTY
102401: LIST
102402: LIST
102403: PUSH
102404: LD_INT 3
102406: PUSH
102407: LD_INT 23
102409: PUSH
102410: LD_INT 0
102412: PUSH
102413: EMPTY
102414: LIST
102415: LIST
102416: PUSH
102417: EMPTY
102418: LIST
102419: LIST
102420: PUSH
102421: EMPTY
102422: LIST
102423: LIST
102424: LIST
102425: PPUSH
102426: CALL_OW 69
102430: ST_TO_ADDR
// if not tmp then
102431: LD_VAR 0 6
102435: NOT
102436: IFFALSE 102440
// exit ;
102438: GO 102586
// s1 := rand ( 1 , 4 ) ;
102440: LD_ADDR_VAR 0 2
102444: PUSH
102445: LD_INT 1
102447: PPUSH
102448: LD_INT 4
102450: PPUSH
102451: CALL_OW 12
102455: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102456: LD_ADDR_VAR 0 4
102460: PUSH
102461: LD_VAR 0 6
102465: PUSH
102466: LD_INT 1
102468: ARRAY
102469: PPUSH
102470: LD_VAR 0 2
102474: PPUSH
102475: CALL_OW 259
102479: ST_TO_ADDR
// if s1 = 1 then
102480: LD_VAR 0 2
102484: PUSH
102485: LD_INT 1
102487: EQUAL
102488: IFFALSE 102508
// s2 := rand ( 2 , 4 ) else
102490: LD_ADDR_VAR 0 3
102494: PUSH
102495: LD_INT 2
102497: PPUSH
102498: LD_INT 4
102500: PPUSH
102501: CALL_OW 12
102505: ST_TO_ADDR
102506: GO 102516
// s2 := 1 ;
102508: LD_ADDR_VAR 0 3
102512: PUSH
102513: LD_INT 1
102515: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102516: LD_ADDR_VAR 0 5
102520: PUSH
102521: LD_VAR 0 6
102525: PUSH
102526: LD_INT 1
102528: ARRAY
102529: PPUSH
102530: LD_VAR 0 3
102534: PPUSH
102535: CALL_OW 259
102539: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102540: LD_VAR 0 6
102544: PUSH
102545: LD_INT 1
102547: ARRAY
102548: PPUSH
102549: LD_VAR 0 2
102553: PPUSH
102554: LD_VAR 0 5
102558: PPUSH
102559: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102563: LD_VAR 0 6
102567: PUSH
102568: LD_INT 1
102570: ARRAY
102571: PPUSH
102572: LD_VAR 0 3
102576: PPUSH
102577: LD_VAR 0 4
102581: PPUSH
102582: CALL_OW 237
// end ;
102586: PPOPN 6
102588: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102589: LD_EXP 75
102593: PUSH
102594: LD_EXP 122
102598: AND
102599: IFFALSE 102678
102601: GO 102603
102603: DISABLE
102604: LD_INT 0
102606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102607: LD_ADDR_VAR 0 1
102611: PUSH
102612: LD_INT 22
102614: PUSH
102615: LD_OWVAR 2
102619: PUSH
102620: EMPTY
102621: LIST
102622: LIST
102623: PUSH
102624: LD_INT 30
102626: PUSH
102627: LD_INT 3
102629: PUSH
102630: EMPTY
102631: LIST
102632: LIST
102633: PUSH
102634: EMPTY
102635: LIST
102636: LIST
102637: PPUSH
102638: CALL_OW 69
102642: ST_TO_ADDR
// if not tmp then
102643: LD_VAR 0 1
102647: NOT
102648: IFFALSE 102652
// exit ;
102650: GO 102678
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102652: LD_VAR 0 1
102656: PUSH
102657: LD_INT 1
102659: PPUSH
102660: LD_VAR 0 1
102664: PPUSH
102665: CALL_OW 12
102669: ARRAY
102670: PPUSH
102671: LD_INT 1
102673: PPUSH
102674: CALL_OW 234
// end ;
102678: PPOPN 1
102680: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102681: LD_EXP 75
102685: PUSH
102686: LD_EXP 123
102690: AND
102691: IFFALSE 102803
102693: GO 102695
102695: DISABLE
102696: LD_INT 0
102698: PPUSH
102699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102700: LD_ADDR_VAR 0 2
102704: PUSH
102705: LD_INT 22
102707: PUSH
102708: LD_OWVAR 2
102712: PUSH
102713: EMPTY
102714: LIST
102715: LIST
102716: PUSH
102717: LD_INT 2
102719: PUSH
102720: LD_INT 30
102722: PUSH
102723: LD_INT 27
102725: PUSH
102726: EMPTY
102727: LIST
102728: LIST
102729: PUSH
102730: LD_INT 30
102732: PUSH
102733: LD_INT 26
102735: PUSH
102736: EMPTY
102737: LIST
102738: LIST
102739: PUSH
102740: LD_INT 30
102742: PUSH
102743: LD_INT 28
102745: PUSH
102746: EMPTY
102747: LIST
102748: LIST
102749: PUSH
102750: EMPTY
102751: LIST
102752: LIST
102753: LIST
102754: LIST
102755: PUSH
102756: EMPTY
102757: LIST
102758: LIST
102759: PPUSH
102760: CALL_OW 69
102764: ST_TO_ADDR
// if not tmp then
102765: LD_VAR 0 2
102769: NOT
102770: IFFALSE 102774
// exit ;
102772: GO 102803
// for i in tmp do
102774: LD_ADDR_VAR 0 1
102778: PUSH
102779: LD_VAR 0 2
102783: PUSH
102784: FOR_IN
102785: IFFALSE 102801
// SetLives ( i , 1 ) ;
102787: LD_VAR 0 1
102791: PPUSH
102792: LD_INT 1
102794: PPUSH
102795: CALL_OW 234
102799: GO 102784
102801: POP
102802: POP
// end ;
102803: PPOPN 2
102805: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102806: LD_EXP 75
102810: PUSH
102811: LD_EXP 124
102815: AND
102816: IFFALSE 103103
102818: GO 102820
102820: DISABLE
102821: LD_INT 0
102823: PPUSH
102824: PPUSH
102825: PPUSH
// begin i := rand ( 1 , 7 ) ;
102826: LD_ADDR_VAR 0 1
102830: PUSH
102831: LD_INT 1
102833: PPUSH
102834: LD_INT 7
102836: PPUSH
102837: CALL_OW 12
102841: ST_TO_ADDR
// case i of 1 :
102842: LD_VAR 0 1
102846: PUSH
102847: LD_INT 1
102849: DOUBLE
102850: EQUAL
102851: IFTRUE 102855
102853: GO 102865
102855: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102856: LD_STRING earthquake(getX(game), 0, 32)
102858: PPUSH
102859: CALL_OW 559
102863: GO 103103
102865: LD_INT 2
102867: DOUBLE
102868: EQUAL
102869: IFTRUE 102873
102871: GO 102887
102873: POP
// begin ToLua ( displayStucuk(); ) ;
102874: LD_STRING displayStucuk();
102876: PPUSH
102877: CALL_OW 559
// ResetFog ;
102881: CALL_OW 335
// end ; 3 :
102885: GO 103103
102887: LD_INT 3
102889: DOUBLE
102890: EQUAL
102891: IFTRUE 102895
102893: GO 102999
102895: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102896: LD_ADDR_VAR 0 2
102900: PUSH
102901: LD_INT 22
102903: PUSH
102904: LD_OWVAR 2
102908: PUSH
102909: EMPTY
102910: LIST
102911: LIST
102912: PUSH
102913: LD_INT 25
102915: PUSH
102916: LD_INT 1
102918: PUSH
102919: EMPTY
102920: LIST
102921: LIST
102922: PUSH
102923: EMPTY
102924: LIST
102925: LIST
102926: PPUSH
102927: CALL_OW 69
102931: ST_TO_ADDR
// if not tmp then
102932: LD_VAR 0 2
102936: NOT
102937: IFFALSE 102941
// exit ;
102939: GO 103103
// un := tmp [ rand ( 1 , tmp ) ] ;
102941: LD_ADDR_VAR 0 3
102945: PUSH
102946: LD_VAR 0 2
102950: PUSH
102951: LD_INT 1
102953: PPUSH
102954: LD_VAR 0 2
102958: PPUSH
102959: CALL_OW 12
102963: ARRAY
102964: ST_TO_ADDR
// if Crawls ( un ) then
102965: LD_VAR 0 3
102969: PPUSH
102970: CALL_OW 318
102974: IFFALSE 102985
// ComWalk ( un ) ;
102976: LD_VAR 0 3
102980: PPUSH
102981: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102985: LD_VAR 0 3
102989: PPUSH
102990: LD_INT 8
102992: PPUSH
102993: CALL_OW 336
// end ; 4 :
102997: GO 103103
102999: LD_INT 4
103001: DOUBLE
103002: EQUAL
103003: IFTRUE 103007
103005: GO 103081
103007: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103008: LD_ADDR_VAR 0 2
103012: PUSH
103013: LD_INT 22
103015: PUSH
103016: LD_OWVAR 2
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: PUSH
103025: LD_INT 30
103027: PUSH
103028: LD_INT 29
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: PUSH
103035: EMPTY
103036: LIST
103037: LIST
103038: PPUSH
103039: CALL_OW 69
103043: ST_TO_ADDR
// if not tmp then
103044: LD_VAR 0 2
103048: NOT
103049: IFFALSE 103053
// exit ;
103051: GO 103103
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103053: LD_VAR 0 2
103057: PUSH
103058: LD_INT 1
103060: ARRAY
103061: PPUSH
103062: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103066: LD_VAR 0 2
103070: PUSH
103071: LD_INT 1
103073: ARRAY
103074: PPUSH
103075: CALL_OW 65
// end ; 5 .. 7 :
103079: GO 103103
103081: LD_INT 5
103083: DOUBLE
103084: GREATEREQUAL
103085: IFFALSE 103093
103087: LD_INT 7
103089: DOUBLE
103090: LESSEQUAL
103091: IFTRUE 103095
103093: GO 103102
103095: POP
// StreamSibBomb ; end ;
103096: CALL 99340 0 0
103100: GO 103103
103102: POP
// end ;
103103: PPOPN 3
103105: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103106: LD_EXP 75
103110: PUSH
103111: LD_EXP 125
103115: AND
103116: IFFALSE 103272
103118: GO 103120
103120: DISABLE
103121: LD_INT 0
103123: PPUSH
103124: PPUSH
103125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103126: LD_ADDR_VAR 0 2
103130: PUSH
103131: LD_INT 81
103133: PUSH
103134: LD_OWVAR 2
103138: PUSH
103139: EMPTY
103140: LIST
103141: LIST
103142: PUSH
103143: LD_INT 2
103145: PUSH
103146: LD_INT 21
103148: PUSH
103149: LD_INT 1
103151: PUSH
103152: EMPTY
103153: LIST
103154: LIST
103155: PUSH
103156: LD_INT 21
103158: PUSH
103159: LD_INT 2
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: PUSH
103166: EMPTY
103167: LIST
103168: LIST
103169: LIST
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: PPUSH
103175: CALL_OW 69
103179: ST_TO_ADDR
// if not tmp then
103180: LD_VAR 0 2
103184: NOT
103185: IFFALSE 103189
// exit ;
103187: GO 103272
// p := 0 ;
103189: LD_ADDR_VAR 0 3
103193: PUSH
103194: LD_INT 0
103196: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103197: LD_INT 35
103199: PPUSH
103200: CALL_OW 67
// p := p + 1 ;
103204: LD_ADDR_VAR 0 3
103208: PUSH
103209: LD_VAR 0 3
103213: PUSH
103214: LD_INT 1
103216: PLUS
103217: ST_TO_ADDR
// for i in tmp do
103218: LD_ADDR_VAR 0 1
103222: PUSH
103223: LD_VAR 0 2
103227: PUSH
103228: FOR_IN
103229: IFFALSE 103260
// if GetLives ( i ) < 1000 then
103231: LD_VAR 0 1
103235: PPUSH
103236: CALL_OW 256
103240: PUSH
103241: LD_INT 1000
103243: LESS
103244: IFFALSE 103258
// SetLives ( i , 1000 ) ;
103246: LD_VAR 0 1
103250: PPUSH
103251: LD_INT 1000
103253: PPUSH
103254: CALL_OW 234
103258: GO 103228
103260: POP
103261: POP
// until p > 20 ;
103262: LD_VAR 0 3
103266: PUSH
103267: LD_INT 20
103269: GREATER
103270: IFFALSE 103197
// end ;
103272: PPOPN 3
103274: END
// every 0 0$1 trigger StreamModeActive and sTime do
103275: LD_EXP 75
103279: PUSH
103280: LD_EXP 126
103284: AND
103285: IFFALSE 103320
103287: GO 103289
103289: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103290: LD_INT 28
103292: PPUSH
103293: LD_OWVAR 2
103297: PPUSH
103298: LD_INT 2
103300: PPUSH
103301: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103305: LD_INT 30
103307: PPUSH
103308: LD_OWVAR 2
103312: PPUSH
103313: LD_INT 2
103315: PPUSH
103316: CALL_OW 322
// end ;
103320: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103321: LD_EXP 75
103325: PUSH
103326: LD_EXP 127
103330: AND
103331: IFFALSE 103452
103333: GO 103335
103335: DISABLE
103336: LD_INT 0
103338: PPUSH
103339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103340: LD_ADDR_VAR 0 2
103344: PUSH
103345: LD_INT 22
103347: PUSH
103348: LD_OWVAR 2
103352: PUSH
103353: EMPTY
103354: LIST
103355: LIST
103356: PUSH
103357: LD_INT 21
103359: PUSH
103360: LD_INT 1
103362: PUSH
103363: EMPTY
103364: LIST
103365: LIST
103366: PUSH
103367: LD_INT 3
103369: PUSH
103370: LD_INT 23
103372: PUSH
103373: LD_INT 0
103375: PUSH
103376: EMPTY
103377: LIST
103378: LIST
103379: PUSH
103380: EMPTY
103381: LIST
103382: LIST
103383: PUSH
103384: EMPTY
103385: LIST
103386: LIST
103387: LIST
103388: PPUSH
103389: CALL_OW 69
103393: ST_TO_ADDR
// if not tmp then
103394: LD_VAR 0 2
103398: NOT
103399: IFFALSE 103403
// exit ;
103401: GO 103452
// for i in tmp do
103403: LD_ADDR_VAR 0 1
103407: PUSH
103408: LD_VAR 0 2
103412: PUSH
103413: FOR_IN
103414: IFFALSE 103450
// begin if Crawls ( i ) then
103416: LD_VAR 0 1
103420: PPUSH
103421: CALL_OW 318
103425: IFFALSE 103436
// ComWalk ( i ) ;
103427: LD_VAR 0 1
103431: PPUSH
103432: CALL_OW 138
// SetClass ( i , 2 ) ;
103436: LD_VAR 0 1
103440: PPUSH
103441: LD_INT 2
103443: PPUSH
103444: CALL_OW 336
// end ;
103448: GO 103413
103450: POP
103451: POP
// end ;
103452: PPOPN 2
103454: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103455: LD_EXP 75
103459: PUSH
103460: LD_EXP 128
103464: AND
103465: IFFALSE 103753
103467: GO 103469
103469: DISABLE
103470: LD_INT 0
103472: PPUSH
103473: PPUSH
103474: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103475: LD_OWVAR 2
103479: PPUSH
103480: LD_INT 9
103482: PPUSH
103483: LD_INT 1
103485: PPUSH
103486: LD_INT 1
103488: PPUSH
103489: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103493: LD_INT 9
103495: PPUSH
103496: LD_OWVAR 2
103500: PPUSH
103501: CALL_OW 343
// uc_side := 9 ;
103505: LD_ADDR_OWVAR 20
103509: PUSH
103510: LD_INT 9
103512: ST_TO_ADDR
// uc_nation := 2 ;
103513: LD_ADDR_OWVAR 21
103517: PUSH
103518: LD_INT 2
103520: ST_TO_ADDR
// hc_name := Dark Warrior ;
103521: LD_ADDR_OWVAR 26
103525: PUSH
103526: LD_STRING Dark Warrior
103528: ST_TO_ADDR
// hc_gallery :=  ;
103529: LD_ADDR_OWVAR 33
103533: PUSH
103534: LD_STRING 
103536: ST_TO_ADDR
// hc_noskilllimit := true ;
103537: LD_ADDR_OWVAR 76
103541: PUSH
103542: LD_INT 1
103544: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103545: LD_ADDR_OWVAR 31
103549: PUSH
103550: LD_INT 30
103552: PUSH
103553: LD_INT 30
103555: PUSH
103556: LD_INT 30
103558: PUSH
103559: LD_INT 30
103561: PUSH
103562: EMPTY
103563: LIST
103564: LIST
103565: LIST
103566: LIST
103567: ST_TO_ADDR
// un := CreateHuman ;
103568: LD_ADDR_VAR 0 3
103572: PUSH
103573: CALL_OW 44
103577: ST_TO_ADDR
// hc_noskilllimit := false ;
103578: LD_ADDR_OWVAR 76
103582: PUSH
103583: LD_INT 0
103585: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103586: LD_VAR 0 3
103590: PPUSH
103591: LD_INT 1
103593: PPUSH
103594: CALL_OW 51
// ToLua ( playRanger() ) ;
103598: LD_STRING playRanger()
103600: PPUSH
103601: CALL_OW 559
// p := 0 ;
103605: LD_ADDR_VAR 0 2
103609: PUSH
103610: LD_INT 0
103612: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103613: LD_INT 35
103615: PPUSH
103616: CALL_OW 67
// p := p + 1 ;
103620: LD_ADDR_VAR 0 2
103624: PUSH
103625: LD_VAR 0 2
103629: PUSH
103630: LD_INT 1
103632: PLUS
103633: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103634: LD_VAR 0 3
103638: PPUSH
103639: CALL_OW 256
103643: PUSH
103644: LD_INT 1000
103646: LESS
103647: IFFALSE 103661
// SetLives ( un , 1000 ) ;
103649: LD_VAR 0 3
103653: PPUSH
103654: LD_INT 1000
103656: PPUSH
103657: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103661: LD_VAR 0 3
103665: PPUSH
103666: LD_INT 81
103668: PUSH
103669: LD_OWVAR 2
103673: PUSH
103674: EMPTY
103675: LIST
103676: LIST
103677: PUSH
103678: LD_INT 91
103680: PUSH
103681: LD_VAR 0 3
103685: PUSH
103686: LD_INT 30
103688: PUSH
103689: EMPTY
103690: LIST
103691: LIST
103692: LIST
103693: PUSH
103694: EMPTY
103695: LIST
103696: LIST
103697: PPUSH
103698: CALL_OW 69
103702: PPUSH
103703: LD_VAR 0 3
103707: PPUSH
103708: CALL_OW 74
103712: PPUSH
103713: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103717: LD_VAR 0 2
103721: PUSH
103722: LD_INT 80
103724: GREATER
103725: PUSH
103726: LD_VAR 0 3
103730: PPUSH
103731: CALL_OW 301
103735: OR
103736: IFFALSE 103613
// if un then
103738: LD_VAR 0 3
103742: IFFALSE 103753
// RemoveUnit ( un ) ;
103744: LD_VAR 0 3
103748: PPUSH
103749: CALL_OW 64
// end ;
103753: PPOPN 3
103755: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103756: LD_EXP 129
103760: IFFALSE 103876
103762: GO 103764
103764: DISABLE
103765: LD_INT 0
103767: PPUSH
103768: PPUSH
103769: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103770: LD_ADDR_VAR 0 2
103774: PUSH
103775: LD_INT 81
103777: PUSH
103778: LD_OWVAR 2
103782: PUSH
103783: EMPTY
103784: LIST
103785: LIST
103786: PUSH
103787: LD_INT 21
103789: PUSH
103790: LD_INT 1
103792: PUSH
103793: EMPTY
103794: LIST
103795: LIST
103796: PUSH
103797: EMPTY
103798: LIST
103799: LIST
103800: PPUSH
103801: CALL_OW 69
103805: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103806: LD_STRING playComputer()
103808: PPUSH
103809: CALL_OW 559
// if not tmp then
103813: LD_VAR 0 2
103817: NOT
103818: IFFALSE 103822
// exit ;
103820: GO 103876
// for i in tmp do
103822: LD_ADDR_VAR 0 1
103826: PUSH
103827: LD_VAR 0 2
103831: PUSH
103832: FOR_IN
103833: IFFALSE 103874
// for j := 1 to 4 do
103835: LD_ADDR_VAR 0 3
103839: PUSH
103840: DOUBLE
103841: LD_INT 1
103843: DEC
103844: ST_TO_ADDR
103845: LD_INT 4
103847: PUSH
103848: FOR_TO
103849: IFFALSE 103870
// SetSkill ( i , j , 10 ) ;
103851: LD_VAR 0 1
103855: PPUSH
103856: LD_VAR 0 3
103860: PPUSH
103861: LD_INT 10
103863: PPUSH
103864: CALL_OW 237
103868: GO 103848
103870: POP
103871: POP
103872: GO 103832
103874: POP
103875: POP
// end ;
103876: PPOPN 3
103878: END
// every 0 0$1 trigger s30 do var i , tmp ;
103879: LD_EXP 130
103883: IFFALSE 103952
103885: GO 103887
103887: DISABLE
103888: LD_INT 0
103890: PPUSH
103891: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103892: LD_ADDR_VAR 0 2
103896: PUSH
103897: LD_INT 22
103899: PUSH
103900: LD_OWVAR 2
103904: PUSH
103905: EMPTY
103906: LIST
103907: LIST
103908: PPUSH
103909: CALL_OW 69
103913: ST_TO_ADDR
// if not tmp then
103914: LD_VAR 0 2
103918: NOT
103919: IFFALSE 103923
// exit ;
103921: GO 103952
// for i in tmp do
103923: LD_ADDR_VAR 0 1
103927: PUSH
103928: LD_VAR 0 2
103932: PUSH
103933: FOR_IN
103934: IFFALSE 103950
// SetLives ( i , 300 ) ;
103936: LD_VAR 0 1
103940: PPUSH
103941: LD_INT 300
103943: PPUSH
103944: CALL_OW 234
103948: GO 103933
103950: POP
103951: POP
// end ;
103952: PPOPN 2
103954: END
// every 0 0$1 trigger s60 do var i , tmp ;
103955: LD_EXP 131
103959: IFFALSE 104028
103961: GO 103963
103963: DISABLE
103964: LD_INT 0
103966: PPUSH
103967: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103968: LD_ADDR_VAR 0 2
103972: PUSH
103973: LD_INT 22
103975: PUSH
103976: LD_OWVAR 2
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: PPUSH
103985: CALL_OW 69
103989: ST_TO_ADDR
// if not tmp then
103990: LD_VAR 0 2
103994: NOT
103995: IFFALSE 103999
// exit ;
103997: GO 104028
// for i in tmp do
103999: LD_ADDR_VAR 0 1
104003: PUSH
104004: LD_VAR 0 2
104008: PUSH
104009: FOR_IN
104010: IFFALSE 104026
// SetLives ( i , 600 ) ;
104012: LD_VAR 0 1
104016: PPUSH
104017: LD_INT 600
104019: PPUSH
104020: CALL_OW 234
104024: GO 104009
104026: POP
104027: POP
// end ;
104028: PPOPN 2
104030: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104031: LD_INT 0
104033: PPUSH
// case cmd of 301 :
104034: LD_VAR 0 1
104038: PUSH
104039: LD_INT 301
104041: DOUBLE
104042: EQUAL
104043: IFTRUE 104047
104045: GO 104079
104047: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104048: LD_VAR 0 6
104052: PPUSH
104053: LD_VAR 0 7
104057: PPUSH
104058: LD_VAR 0 8
104062: PPUSH
104063: LD_VAR 0 4
104067: PPUSH
104068: LD_VAR 0 5
104072: PPUSH
104073: CALL 105280 0 5
104077: GO 104200
104079: LD_INT 302
104081: DOUBLE
104082: EQUAL
104083: IFTRUE 104087
104085: GO 104124
104087: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104088: LD_VAR 0 6
104092: PPUSH
104093: LD_VAR 0 7
104097: PPUSH
104098: LD_VAR 0 8
104102: PPUSH
104103: LD_VAR 0 9
104107: PPUSH
104108: LD_VAR 0 4
104112: PPUSH
104113: LD_VAR 0 5
104117: PPUSH
104118: CALL 105371 0 6
104122: GO 104200
104124: LD_INT 303
104126: DOUBLE
104127: EQUAL
104128: IFTRUE 104132
104130: GO 104169
104132: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104133: LD_VAR 0 6
104137: PPUSH
104138: LD_VAR 0 7
104142: PPUSH
104143: LD_VAR 0 8
104147: PPUSH
104148: LD_VAR 0 9
104152: PPUSH
104153: LD_VAR 0 4
104157: PPUSH
104158: LD_VAR 0 5
104162: PPUSH
104163: CALL 104205 0 6
104167: GO 104200
104169: LD_INT 304
104171: DOUBLE
104172: EQUAL
104173: IFTRUE 104177
104175: GO 104199
104177: POP
// hHackTeleport ( unit , x , y ) ; end ;
104178: LD_VAR 0 2
104182: PPUSH
104183: LD_VAR 0 4
104187: PPUSH
104188: LD_VAR 0 5
104192: PPUSH
104193: CALL 105964 0 3
104197: GO 104200
104199: POP
// end ;
104200: LD_VAR 0 12
104204: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104205: LD_INT 0
104207: PPUSH
104208: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104209: LD_VAR 0 1
104213: PUSH
104214: LD_INT 1
104216: LESS
104217: PUSH
104218: LD_VAR 0 1
104222: PUSH
104223: LD_INT 3
104225: GREATER
104226: OR
104227: PUSH
104228: LD_VAR 0 5
104232: PPUSH
104233: LD_VAR 0 6
104237: PPUSH
104238: CALL_OW 428
104242: OR
104243: IFFALSE 104247
// exit ;
104245: GO 104967
// uc_side := your_side ;
104247: LD_ADDR_OWVAR 20
104251: PUSH
104252: LD_OWVAR 2
104256: ST_TO_ADDR
// uc_nation := nation ;
104257: LD_ADDR_OWVAR 21
104261: PUSH
104262: LD_VAR 0 1
104266: ST_TO_ADDR
// bc_level = 1 ;
104267: LD_ADDR_OWVAR 43
104271: PUSH
104272: LD_INT 1
104274: ST_TO_ADDR
// case btype of 1 :
104275: LD_VAR 0 2
104279: PUSH
104280: LD_INT 1
104282: DOUBLE
104283: EQUAL
104284: IFTRUE 104288
104286: GO 104299
104288: POP
// bc_type := b_depot ; 2 :
104289: LD_ADDR_OWVAR 42
104293: PUSH
104294: LD_INT 0
104296: ST_TO_ADDR
104297: GO 104911
104299: LD_INT 2
104301: DOUBLE
104302: EQUAL
104303: IFTRUE 104307
104305: GO 104318
104307: POP
// bc_type := b_warehouse ; 3 :
104308: LD_ADDR_OWVAR 42
104312: PUSH
104313: LD_INT 1
104315: ST_TO_ADDR
104316: GO 104911
104318: LD_INT 3
104320: DOUBLE
104321: EQUAL
104322: IFTRUE 104326
104324: GO 104337
104326: POP
// bc_type := b_lab ; 4 .. 9 :
104327: LD_ADDR_OWVAR 42
104331: PUSH
104332: LD_INT 6
104334: ST_TO_ADDR
104335: GO 104911
104337: LD_INT 4
104339: DOUBLE
104340: GREATEREQUAL
104341: IFFALSE 104349
104343: LD_INT 9
104345: DOUBLE
104346: LESSEQUAL
104347: IFTRUE 104351
104349: GO 104403
104351: POP
// begin bc_type := b_lab_half ;
104352: LD_ADDR_OWVAR 42
104356: PUSH
104357: LD_INT 7
104359: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104360: LD_ADDR_OWVAR 44
104364: PUSH
104365: LD_INT 10
104367: PUSH
104368: LD_INT 11
104370: PUSH
104371: LD_INT 12
104373: PUSH
104374: LD_INT 15
104376: PUSH
104377: LD_INT 14
104379: PUSH
104380: LD_INT 13
104382: PUSH
104383: EMPTY
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: PUSH
104391: LD_VAR 0 2
104395: PUSH
104396: LD_INT 3
104398: MINUS
104399: ARRAY
104400: ST_TO_ADDR
// end ; 10 .. 13 :
104401: GO 104911
104403: LD_INT 10
104405: DOUBLE
104406: GREATEREQUAL
104407: IFFALSE 104415
104409: LD_INT 13
104411: DOUBLE
104412: LESSEQUAL
104413: IFTRUE 104417
104415: GO 104494
104417: POP
// begin bc_type := b_lab_full ;
104418: LD_ADDR_OWVAR 42
104422: PUSH
104423: LD_INT 8
104425: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104426: LD_ADDR_OWVAR 44
104430: PUSH
104431: LD_INT 10
104433: PUSH
104434: LD_INT 12
104436: PUSH
104437: LD_INT 14
104439: PUSH
104440: LD_INT 13
104442: PUSH
104443: EMPTY
104444: LIST
104445: LIST
104446: LIST
104447: LIST
104448: PUSH
104449: LD_VAR 0 2
104453: PUSH
104454: LD_INT 9
104456: MINUS
104457: ARRAY
104458: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104459: LD_ADDR_OWVAR 45
104463: PUSH
104464: LD_INT 11
104466: PUSH
104467: LD_INT 15
104469: PUSH
104470: LD_INT 12
104472: PUSH
104473: LD_INT 15
104475: PUSH
104476: EMPTY
104477: LIST
104478: LIST
104479: LIST
104480: LIST
104481: PUSH
104482: LD_VAR 0 2
104486: PUSH
104487: LD_INT 9
104489: MINUS
104490: ARRAY
104491: ST_TO_ADDR
// end ; 14 :
104492: GO 104911
104494: LD_INT 14
104496: DOUBLE
104497: EQUAL
104498: IFTRUE 104502
104500: GO 104513
104502: POP
// bc_type := b_workshop ; 15 :
104503: LD_ADDR_OWVAR 42
104507: PUSH
104508: LD_INT 2
104510: ST_TO_ADDR
104511: GO 104911
104513: LD_INT 15
104515: DOUBLE
104516: EQUAL
104517: IFTRUE 104521
104519: GO 104532
104521: POP
// bc_type := b_factory ; 16 :
104522: LD_ADDR_OWVAR 42
104526: PUSH
104527: LD_INT 3
104529: ST_TO_ADDR
104530: GO 104911
104532: LD_INT 16
104534: DOUBLE
104535: EQUAL
104536: IFTRUE 104540
104538: GO 104551
104540: POP
// bc_type := b_ext_gun ; 17 :
104541: LD_ADDR_OWVAR 42
104545: PUSH
104546: LD_INT 17
104548: ST_TO_ADDR
104549: GO 104911
104551: LD_INT 17
104553: DOUBLE
104554: EQUAL
104555: IFTRUE 104559
104557: GO 104587
104559: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104560: LD_ADDR_OWVAR 42
104564: PUSH
104565: LD_INT 19
104567: PUSH
104568: LD_INT 23
104570: PUSH
104571: LD_INT 19
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: LIST
104578: PUSH
104579: LD_VAR 0 1
104583: ARRAY
104584: ST_TO_ADDR
104585: GO 104911
104587: LD_INT 18
104589: DOUBLE
104590: EQUAL
104591: IFTRUE 104595
104593: GO 104606
104595: POP
// bc_type := b_ext_radar ; 19 :
104596: LD_ADDR_OWVAR 42
104600: PUSH
104601: LD_INT 20
104603: ST_TO_ADDR
104604: GO 104911
104606: LD_INT 19
104608: DOUBLE
104609: EQUAL
104610: IFTRUE 104614
104612: GO 104625
104614: POP
// bc_type := b_ext_radio ; 20 :
104615: LD_ADDR_OWVAR 42
104619: PUSH
104620: LD_INT 22
104622: ST_TO_ADDR
104623: GO 104911
104625: LD_INT 20
104627: DOUBLE
104628: EQUAL
104629: IFTRUE 104633
104631: GO 104644
104633: POP
// bc_type := b_ext_siberium ; 21 :
104634: LD_ADDR_OWVAR 42
104638: PUSH
104639: LD_INT 21
104641: ST_TO_ADDR
104642: GO 104911
104644: LD_INT 21
104646: DOUBLE
104647: EQUAL
104648: IFTRUE 104652
104650: GO 104663
104652: POP
// bc_type := b_ext_computer ; 22 :
104653: LD_ADDR_OWVAR 42
104657: PUSH
104658: LD_INT 24
104660: ST_TO_ADDR
104661: GO 104911
104663: LD_INT 22
104665: DOUBLE
104666: EQUAL
104667: IFTRUE 104671
104669: GO 104682
104671: POP
// bc_type := b_ext_track ; 23 :
104672: LD_ADDR_OWVAR 42
104676: PUSH
104677: LD_INT 16
104679: ST_TO_ADDR
104680: GO 104911
104682: LD_INT 23
104684: DOUBLE
104685: EQUAL
104686: IFTRUE 104690
104688: GO 104701
104690: POP
// bc_type := b_ext_laser ; 24 :
104691: LD_ADDR_OWVAR 42
104695: PUSH
104696: LD_INT 25
104698: ST_TO_ADDR
104699: GO 104911
104701: LD_INT 24
104703: DOUBLE
104704: EQUAL
104705: IFTRUE 104709
104707: GO 104720
104709: POP
// bc_type := b_control_tower ; 25 :
104710: LD_ADDR_OWVAR 42
104714: PUSH
104715: LD_INT 36
104717: ST_TO_ADDR
104718: GO 104911
104720: LD_INT 25
104722: DOUBLE
104723: EQUAL
104724: IFTRUE 104728
104726: GO 104739
104728: POP
// bc_type := b_breastwork ; 26 :
104729: LD_ADDR_OWVAR 42
104733: PUSH
104734: LD_INT 31
104736: ST_TO_ADDR
104737: GO 104911
104739: LD_INT 26
104741: DOUBLE
104742: EQUAL
104743: IFTRUE 104747
104745: GO 104758
104747: POP
// bc_type := b_bunker ; 27 :
104748: LD_ADDR_OWVAR 42
104752: PUSH
104753: LD_INT 32
104755: ST_TO_ADDR
104756: GO 104911
104758: LD_INT 27
104760: DOUBLE
104761: EQUAL
104762: IFTRUE 104766
104764: GO 104777
104766: POP
// bc_type := b_turret ; 28 :
104767: LD_ADDR_OWVAR 42
104771: PUSH
104772: LD_INT 33
104774: ST_TO_ADDR
104775: GO 104911
104777: LD_INT 28
104779: DOUBLE
104780: EQUAL
104781: IFTRUE 104785
104783: GO 104796
104785: POP
// bc_type := b_armoury ; 29 :
104786: LD_ADDR_OWVAR 42
104790: PUSH
104791: LD_INT 4
104793: ST_TO_ADDR
104794: GO 104911
104796: LD_INT 29
104798: DOUBLE
104799: EQUAL
104800: IFTRUE 104804
104802: GO 104815
104804: POP
// bc_type := b_barracks ; 30 :
104805: LD_ADDR_OWVAR 42
104809: PUSH
104810: LD_INT 5
104812: ST_TO_ADDR
104813: GO 104911
104815: LD_INT 30
104817: DOUBLE
104818: EQUAL
104819: IFTRUE 104823
104821: GO 104834
104823: POP
// bc_type := b_solar_power ; 31 :
104824: LD_ADDR_OWVAR 42
104828: PUSH
104829: LD_INT 27
104831: ST_TO_ADDR
104832: GO 104911
104834: LD_INT 31
104836: DOUBLE
104837: EQUAL
104838: IFTRUE 104842
104840: GO 104853
104842: POP
// bc_type := b_oil_power ; 32 :
104843: LD_ADDR_OWVAR 42
104847: PUSH
104848: LD_INT 26
104850: ST_TO_ADDR
104851: GO 104911
104853: LD_INT 32
104855: DOUBLE
104856: EQUAL
104857: IFTRUE 104861
104859: GO 104872
104861: POP
// bc_type := b_siberite_power ; 33 :
104862: LD_ADDR_OWVAR 42
104866: PUSH
104867: LD_INT 28
104869: ST_TO_ADDR
104870: GO 104911
104872: LD_INT 33
104874: DOUBLE
104875: EQUAL
104876: IFTRUE 104880
104878: GO 104891
104880: POP
// bc_type := b_oil_mine ; 34 :
104881: LD_ADDR_OWVAR 42
104885: PUSH
104886: LD_INT 29
104888: ST_TO_ADDR
104889: GO 104911
104891: LD_INT 34
104893: DOUBLE
104894: EQUAL
104895: IFTRUE 104899
104897: GO 104910
104899: POP
// bc_type := b_siberite_mine ; end ;
104900: LD_ADDR_OWVAR 42
104904: PUSH
104905: LD_INT 30
104907: ST_TO_ADDR
104908: GO 104911
104910: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104911: LD_ADDR_VAR 0 8
104915: PUSH
104916: LD_VAR 0 5
104920: PPUSH
104921: LD_VAR 0 6
104925: PPUSH
104926: LD_VAR 0 3
104930: PPUSH
104931: CALL_OW 47
104935: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104936: LD_OWVAR 42
104940: PUSH
104941: LD_INT 32
104943: PUSH
104944: LD_INT 33
104946: PUSH
104947: EMPTY
104948: LIST
104949: LIST
104950: IN
104951: IFFALSE 104967
// PlaceWeaponTurret ( b , weapon ) ;
104953: LD_VAR 0 8
104957: PPUSH
104958: LD_VAR 0 4
104962: PPUSH
104963: CALL_OW 431
// end ;
104967: LD_VAR 0 7
104971: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104972: LD_INT 0
104974: PPUSH
104975: PPUSH
104976: PPUSH
104977: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104978: LD_ADDR_VAR 0 4
104982: PUSH
104983: LD_INT 22
104985: PUSH
104986: LD_OWVAR 2
104990: PUSH
104991: EMPTY
104992: LIST
104993: LIST
104994: PUSH
104995: LD_INT 2
104997: PUSH
104998: LD_INT 30
105000: PUSH
105001: LD_INT 0
105003: PUSH
105004: EMPTY
105005: LIST
105006: LIST
105007: PUSH
105008: LD_INT 30
105010: PUSH
105011: LD_INT 1
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: PUSH
105018: EMPTY
105019: LIST
105020: LIST
105021: LIST
105022: PUSH
105023: EMPTY
105024: LIST
105025: LIST
105026: PPUSH
105027: CALL_OW 69
105031: ST_TO_ADDR
// if not tmp then
105032: LD_VAR 0 4
105036: NOT
105037: IFFALSE 105041
// exit ;
105039: GO 105100
// for i in tmp do
105041: LD_ADDR_VAR 0 2
105045: PUSH
105046: LD_VAR 0 4
105050: PUSH
105051: FOR_IN
105052: IFFALSE 105098
// for j = 1 to 3 do
105054: LD_ADDR_VAR 0 3
105058: PUSH
105059: DOUBLE
105060: LD_INT 1
105062: DEC
105063: ST_TO_ADDR
105064: LD_INT 3
105066: PUSH
105067: FOR_TO
105068: IFFALSE 105094
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105070: LD_VAR 0 2
105074: PPUSH
105075: CALL_OW 274
105079: PPUSH
105080: LD_VAR 0 3
105084: PPUSH
105085: LD_INT 99999
105087: PPUSH
105088: CALL_OW 277
105092: GO 105067
105094: POP
105095: POP
105096: GO 105051
105098: POP
105099: POP
// end ;
105100: LD_VAR 0 1
105104: RET
// export function hHackSetLevel10 ; var i , j ; begin
105105: LD_INT 0
105107: PPUSH
105108: PPUSH
105109: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105110: LD_ADDR_VAR 0 2
105114: PUSH
105115: LD_INT 21
105117: PUSH
105118: LD_INT 1
105120: PUSH
105121: EMPTY
105122: LIST
105123: LIST
105124: PPUSH
105125: CALL_OW 69
105129: PUSH
105130: FOR_IN
105131: IFFALSE 105183
// if IsSelected ( i ) then
105133: LD_VAR 0 2
105137: PPUSH
105138: CALL_OW 306
105142: IFFALSE 105181
// begin for j := 1 to 4 do
105144: LD_ADDR_VAR 0 3
105148: PUSH
105149: DOUBLE
105150: LD_INT 1
105152: DEC
105153: ST_TO_ADDR
105154: LD_INT 4
105156: PUSH
105157: FOR_TO
105158: IFFALSE 105179
// SetSkill ( i , j , 10 ) ;
105160: LD_VAR 0 2
105164: PPUSH
105165: LD_VAR 0 3
105169: PPUSH
105170: LD_INT 10
105172: PPUSH
105173: CALL_OW 237
105177: GO 105157
105179: POP
105180: POP
// end ;
105181: GO 105130
105183: POP
105184: POP
// end ;
105185: LD_VAR 0 1
105189: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105190: LD_INT 0
105192: PPUSH
105193: PPUSH
105194: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105195: LD_ADDR_VAR 0 2
105199: PUSH
105200: LD_INT 22
105202: PUSH
105203: LD_OWVAR 2
105207: PUSH
105208: EMPTY
105209: LIST
105210: LIST
105211: PUSH
105212: LD_INT 21
105214: PUSH
105215: LD_INT 1
105217: PUSH
105218: EMPTY
105219: LIST
105220: LIST
105221: PUSH
105222: EMPTY
105223: LIST
105224: LIST
105225: PPUSH
105226: CALL_OW 69
105230: PUSH
105231: FOR_IN
105232: IFFALSE 105273
// begin for j := 1 to 4 do
105234: LD_ADDR_VAR 0 3
105238: PUSH
105239: DOUBLE
105240: LD_INT 1
105242: DEC
105243: ST_TO_ADDR
105244: LD_INT 4
105246: PUSH
105247: FOR_TO
105248: IFFALSE 105269
// SetSkill ( i , j , 10 ) ;
105250: LD_VAR 0 2
105254: PPUSH
105255: LD_VAR 0 3
105259: PPUSH
105260: LD_INT 10
105262: PPUSH
105263: CALL_OW 237
105267: GO 105247
105269: POP
105270: POP
// end ;
105271: GO 105231
105273: POP
105274: POP
// end ;
105275: LD_VAR 0 1
105279: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105280: LD_INT 0
105282: PPUSH
// uc_side := your_side ;
105283: LD_ADDR_OWVAR 20
105287: PUSH
105288: LD_OWVAR 2
105292: ST_TO_ADDR
// uc_nation := nation ;
105293: LD_ADDR_OWVAR 21
105297: PUSH
105298: LD_VAR 0 1
105302: ST_TO_ADDR
// InitHc ;
105303: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105307: LD_INT 0
105309: PPUSH
105310: LD_VAR 0 2
105314: PPUSH
105315: LD_VAR 0 3
105319: PPUSH
105320: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105324: LD_VAR 0 4
105328: PPUSH
105329: LD_VAR 0 5
105333: PPUSH
105334: CALL_OW 428
105338: PUSH
105339: LD_INT 0
105341: EQUAL
105342: IFFALSE 105366
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105344: CALL_OW 44
105348: PPUSH
105349: LD_VAR 0 4
105353: PPUSH
105354: LD_VAR 0 5
105358: PPUSH
105359: LD_INT 1
105361: PPUSH
105362: CALL_OW 48
// end ;
105366: LD_VAR 0 6
105370: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105371: LD_INT 0
105373: PPUSH
105374: PPUSH
// uc_side := your_side ;
105375: LD_ADDR_OWVAR 20
105379: PUSH
105380: LD_OWVAR 2
105384: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105385: LD_VAR 0 1
105389: PUSH
105390: LD_INT 1
105392: PUSH
105393: LD_INT 2
105395: PUSH
105396: LD_INT 3
105398: PUSH
105399: LD_INT 4
105401: PUSH
105402: LD_INT 5
105404: PUSH
105405: EMPTY
105406: LIST
105407: LIST
105408: LIST
105409: LIST
105410: LIST
105411: IN
105412: IFFALSE 105424
// uc_nation := nation_american else
105414: LD_ADDR_OWVAR 21
105418: PUSH
105419: LD_INT 1
105421: ST_TO_ADDR
105422: GO 105467
// if chassis in [ 11 , 12 , 13 , 14 ] then
105424: LD_VAR 0 1
105428: PUSH
105429: LD_INT 11
105431: PUSH
105432: LD_INT 12
105434: PUSH
105435: LD_INT 13
105437: PUSH
105438: LD_INT 14
105440: PUSH
105441: EMPTY
105442: LIST
105443: LIST
105444: LIST
105445: LIST
105446: IN
105447: IFFALSE 105459
// uc_nation := nation_arabian else
105449: LD_ADDR_OWVAR 21
105453: PUSH
105454: LD_INT 2
105456: ST_TO_ADDR
105457: GO 105467
// uc_nation := nation_russian ;
105459: LD_ADDR_OWVAR 21
105463: PUSH
105464: LD_INT 3
105466: ST_TO_ADDR
// vc_chassis := chassis ;
105467: LD_ADDR_OWVAR 37
105471: PUSH
105472: LD_VAR 0 1
105476: ST_TO_ADDR
// vc_engine := engine ;
105477: LD_ADDR_OWVAR 39
105481: PUSH
105482: LD_VAR 0 2
105486: ST_TO_ADDR
// vc_control := control ;
105487: LD_ADDR_OWVAR 38
105491: PUSH
105492: LD_VAR 0 3
105496: ST_TO_ADDR
// vc_weapon := weapon ;
105497: LD_ADDR_OWVAR 40
105501: PUSH
105502: LD_VAR 0 4
105506: ST_TO_ADDR
// un := CreateVehicle ;
105507: LD_ADDR_VAR 0 8
105511: PUSH
105512: CALL_OW 45
105516: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105517: LD_VAR 0 8
105521: PPUSH
105522: LD_INT 0
105524: PPUSH
105525: LD_INT 5
105527: PPUSH
105528: CALL_OW 12
105532: PPUSH
105533: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105537: LD_VAR 0 8
105541: PPUSH
105542: LD_VAR 0 5
105546: PPUSH
105547: LD_VAR 0 6
105551: PPUSH
105552: LD_INT 1
105554: PPUSH
105555: CALL_OW 48
// end ;
105559: LD_VAR 0 7
105563: RET
// export hInvincible ; every 1 do
105564: GO 105566
105566: DISABLE
// hInvincible := [ ] ;
105567: LD_ADDR_EXP 132
105571: PUSH
105572: EMPTY
105573: ST_TO_ADDR
105574: END
// every 10 do var i ;
105575: GO 105577
105577: DISABLE
105578: LD_INT 0
105580: PPUSH
// begin enable ;
105581: ENABLE
// if not hInvincible then
105582: LD_EXP 132
105586: NOT
105587: IFFALSE 105591
// exit ;
105589: GO 105635
// for i in hInvincible do
105591: LD_ADDR_VAR 0 1
105595: PUSH
105596: LD_EXP 132
105600: PUSH
105601: FOR_IN
105602: IFFALSE 105633
// if GetLives ( i ) < 1000 then
105604: LD_VAR 0 1
105608: PPUSH
105609: CALL_OW 256
105613: PUSH
105614: LD_INT 1000
105616: LESS
105617: IFFALSE 105631
// SetLives ( i , 1000 ) ;
105619: LD_VAR 0 1
105623: PPUSH
105624: LD_INT 1000
105626: PPUSH
105627: CALL_OW 234
105631: GO 105601
105633: POP
105634: POP
// end ;
105635: PPOPN 1
105637: END
// export function hHackInvincible ; var i ; begin
105638: LD_INT 0
105640: PPUSH
105641: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105642: LD_ADDR_VAR 0 2
105646: PUSH
105647: LD_INT 2
105649: PUSH
105650: LD_INT 21
105652: PUSH
105653: LD_INT 1
105655: PUSH
105656: EMPTY
105657: LIST
105658: LIST
105659: PUSH
105660: LD_INT 21
105662: PUSH
105663: LD_INT 2
105665: PUSH
105666: EMPTY
105667: LIST
105668: LIST
105669: PUSH
105670: EMPTY
105671: LIST
105672: LIST
105673: LIST
105674: PPUSH
105675: CALL_OW 69
105679: PUSH
105680: FOR_IN
105681: IFFALSE 105742
// if IsSelected ( i ) then
105683: LD_VAR 0 2
105687: PPUSH
105688: CALL_OW 306
105692: IFFALSE 105740
// begin if i in hInvincible then
105694: LD_VAR 0 2
105698: PUSH
105699: LD_EXP 132
105703: IN
105704: IFFALSE 105724
// hInvincible := hInvincible diff i else
105706: LD_ADDR_EXP 132
105710: PUSH
105711: LD_EXP 132
105715: PUSH
105716: LD_VAR 0 2
105720: DIFF
105721: ST_TO_ADDR
105722: GO 105740
// hInvincible := hInvincible union i ;
105724: LD_ADDR_EXP 132
105728: PUSH
105729: LD_EXP 132
105733: PUSH
105734: LD_VAR 0 2
105738: UNION
105739: ST_TO_ADDR
// end ;
105740: GO 105680
105742: POP
105743: POP
// end ;
105744: LD_VAR 0 1
105748: RET
// export function hHackInvisible ; var i , j ; begin
105749: LD_INT 0
105751: PPUSH
105752: PPUSH
105753: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105754: LD_ADDR_VAR 0 2
105758: PUSH
105759: LD_INT 21
105761: PUSH
105762: LD_INT 1
105764: PUSH
105765: EMPTY
105766: LIST
105767: LIST
105768: PPUSH
105769: CALL_OW 69
105773: PUSH
105774: FOR_IN
105775: IFFALSE 105799
// if IsSelected ( i ) then
105777: LD_VAR 0 2
105781: PPUSH
105782: CALL_OW 306
105786: IFFALSE 105797
// ComForceInvisible ( i ) ;
105788: LD_VAR 0 2
105792: PPUSH
105793: CALL_OW 496
105797: GO 105774
105799: POP
105800: POP
// end ;
105801: LD_VAR 0 1
105805: RET
// export function hHackChangeYourSide ; begin
105806: LD_INT 0
105808: PPUSH
// if your_side = 8 then
105809: LD_OWVAR 2
105813: PUSH
105814: LD_INT 8
105816: EQUAL
105817: IFFALSE 105829
// your_side := 0 else
105819: LD_ADDR_OWVAR 2
105823: PUSH
105824: LD_INT 0
105826: ST_TO_ADDR
105827: GO 105843
// your_side := your_side + 1 ;
105829: LD_ADDR_OWVAR 2
105833: PUSH
105834: LD_OWVAR 2
105838: PUSH
105839: LD_INT 1
105841: PLUS
105842: ST_TO_ADDR
// end ;
105843: LD_VAR 0 1
105847: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105848: LD_INT 0
105850: PPUSH
105851: PPUSH
105852: PPUSH
// for i in all_units do
105853: LD_ADDR_VAR 0 2
105857: PUSH
105858: LD_OWVAR 3
105862: PUSH
105863: FOR_IN
105864: IFFALSE 105942
// if IsSelected ( i ) then
105866: LD_VAR 0 2
105870: PPUSH
105871: CALL_OW 306
105875: IFFALSE 105940
// begin j := GetSide ( i ) ;
105877: LD_ADDR_VAR 0 3
105881: PUSH
105882: LD_VAR 0 2
105886: PPUSH
105887: CALL_OW 255
105891: ST_TO_ADDR
// if j = 8 then
105892: LD_VAR 0 3
105896: PUSH
105897: LD_INT 8
105899: EQUAL
105900: IFFALSE 105912
// j := 0 else
105902: LD_ADDR_VAR 0 3
105906: PUSH
105907: LD_INT 0
105909: ST_TO_ADDR
105910: GO 105926
// j := j + 1 ;
105912: LD_ADDR_VAR 0 3
105916: PUSH
105917: LD_VAR 0 3
105921: PUSH
105922: LD_INT 1
105924: PLUS
105925: ST_TO_ADDR
// SetSide ( i , j ) ;
105926: LD_VAR 0 2
105930: PPUSH
105931: LD_VAR 0 3
105935: PPUSH
105936: CALL_OW 235
// end ;
105940: GO 105863
105942: POP
105943: POP
// end ;
105944: LD_VAR 0 1
105948: RET
// export function hHackFog ; begin
105949: LD_INT 0
105951: PPUSH
// FogOff ( true ) ;
105952: LD_INT 1
105954: PPUSH
105955: CALL_OW 344
// end ;
105959: LD_VAR 0 1
105963: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105964: LD_INT 0
105966: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105967: LD_VAR 0 1
105971: PPUSH
105972: LD_VAR 0 2
105976: PPUSH
105977: LD_VAR 0 3
105981: PPUSH
105982: LD_INT 1
105984: PPUSH
105985: LD_INT 1
105987: PPUSH
105988: CALL_OW 483
// CenterOnXY ( x , y ) ;
105992: LD_VAR 0 2
105996: PPUSH
105997: LD_VAR 0 3
106001: PPUSH
106002: CALL_OW 84
// end ;
106006: LD_VAR 0 4
106010: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106011: LD_INT 0
106013: PPUSH
106014: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106015: LD_VAR 0 1
106019: NOT
106020: PUSH
106021: LD_VAR 0 2
106025: PPUSH
106026: LD_VAR 0 3
106030: PPUSH
106031: CALL_OW 488
106035: NOT
106036: OR
106037: PUSH
106038: LD_VAR 0 1
106042: PPUSH
106043: CALL_OW 266
106047: PUSH
106048: LD_INT 3
106050: NONEQUAL
106051: PUSH
106052: LD_VAR 0 1
106056: PPUSH
106057: CALL_OW 247
106061: PUSH
106062: LD_INT 1
106064: EQUAL
106065: NOT
106066: AND
106067: OR
106068: IFFALSE 106072
// exit ;
106070: GO 106221
// if GetType ( factory ) = unit_human then
106072: LD_VAR 0 1
106076: PPUSH
106077: CALL_OW 247
106081: PUSH
106082: LD_INT 1
106084: EQUAL
106085: IFFALSE 106102
// factory := IsInUnit ( factory ) ;
106087: LD_ADDR_VAR 0 1
106091: PUSH
106092: LD_VAR 0 1
106096: PPUSH
106097: CALL_OW 310
106101: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106102: LD_VAR 0 1
106106: PPUSH
106107: CALL_OW 266
106111: PUSH
106112: LD_INT 3
106114: NONEQUAL
106115: IFFALSE 106119
// exit ;
106117: GO 106221
// if HexInfo ( x , y ) = factory then
106119: LD_VAR 0 2
106123: PPUSH
106124: LD_VAR 0 3
106128: PPUSH
106129: CALL_OW 428
106133: PUSH
106134: LD_VAR 0 1
106138: EQUAL
106139: IFFALSE 106166
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106141: LD_ADDR_EXP 133
106145: PUSH
106146: LD_EXP 133
106150: PPUSH
106151: LD_VAR 0 1
106155: PPUSH
106156: LD_INT 0
106158: PPUSH
106159: CALL_OW 1
106163: ST_TO_ADDR
106164: GO 106217
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106166: LD_ADDR_EXP 133
106170: PUSH
106171: LD_EXP 133
106175: PPUSH
106176: LD_VAR 0 1
106180: PPUSH
106181: LD_VAR 0 1
106185: PPUSH
106186: CALL_OW 255
106190: PUSH
106191: LD_VAR 0 1
106195: PUSH
106196: LD_VAR 0 2
106200: PUSH
106201: LD_VAR 0 3
106205: PUSH
106206: EMPTY
106207: LIST
106208: LIST
106209: LIST
106210: LIST
106211: PPUSH
106212: CALL_OW 1
106216: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106217: CALL 106226 0 0
// end ;
106221: LD_VAR 0 4
106225: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106226: LD_INT 0
106228: PPUSH
106229: PPUSH
106230: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106231: LD_STRING resetFactoryWaypoint();
106233: PPUSH
106234: CALL_OW 559
// if factoryWaypoints then
106238: LD_EXP 133
106242: IFFALSE 106368
// begin list := PrepareArray ( factoryWaypoints ) ;
106244: LD_ADDR_VAR 0 3
106248: PUSH
106249: LD_EXP 133
106253: PPUSH
106254: CALL 61018 0 1
106258: ST_TO_ADDR
// for i := 1 to list do
106259: LD_ADDR_VAR 0 2
106263: PUSH
106264: DOUBLE
106265: LD_INT 1
106267: DEC
106268: ST_TO_ADDR
106269: LD_VAR 0 3
106273: PUSH
106274: FOR_TO
106275: IFFALSE 106366
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106277: LD_STRING setFactoryWaypointXY(
106279: PUSH
106280: LD_VAR 0 3
106284: PUSH
106285: LD_VAR 0 2
106289: ARRAY
106290: PUSH
106291: LD_INT 1
106293: ARRAY
106294: STR
106295: PUSH
106296: LD_STRING ,
106298: STR
106299: PUSH
106300: LD_VAR 0 3
106304: PUSH
106305: LD_VAR 0 2
106309: ARRAY
106310: PUSH
106311: LD_INT 2
106313: ARRAY
106314: STR
106315: PUSH
106316: LD_STRING ,
106318: STR
106319: PUSH
106320: LD_VAR 0 3
106324: PUSH
106325: LD_VAR 0 2
106329: ARRAY
106330: PUSH
106331: LD_INT 3
106333: ARRAY
106334: STR
106335: PUSH
106336: LD_STRING ,
106338: STR
106339: PUSH
106340: LD_VAR 0 3
106344: PUSH
106345: LD_VAR 0 2
106349: ARRAY
106350: PUSH
106351: LD_INT 4
106353: ARRAY
106354: STR
106355: PUSH
106356: LD_STRING )
106358: STR
106359: PPUSH
106360: CALL_OW 559
106364: GO 106274
106366: POP
106367: POP
// end ; end ;
106368: LD_VAR 0 1
106372: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106373: LD_INT 0
106375: PPUSH
// if HexInfo ( x , y ) = warehouse then
106376: LD_VAR 0 2
106380: PPUSH
106381: LD_VAR 0 3
106385: PPUSH
106386: CALL_OW 428
106390: PUSH
106391: LD_VAR 0 1
106395: EQUAL
106396: IFFALSE 106423
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106398: LD_ADDR_EXP 134
106402: PUSH
106403: LD_EXP 134
106407: PPUSH
106408: LD_VAR 0 1
106412: PPUSH
106413: LD_INT 0
106415: PPUSH
106416: CALL_OW 1
106420: ST_TO_ADDR
106421: GO 106474
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106423: LD_ADDR_EXP 134
106427: PUSH
106428: LD_EXP 134
106432: PPUSH
106433: LD_VAR 0 1
106437: PPUSH
106438: LD_VAR 0 1
106442: PPUSH
106443: CALL_OW 255
106447: PUSH
106448: LD_VAR 0 1
106452: PUSH
106453: LD_VAR 0 2
106457: PUSH
106458: LD_VAR 0 3
106462: PUSH
106463: EMPTY
106464: LIST
106465: LIST
106466: LIST
106467: LIST
106468: PPUSH
106469: CALL_OW 1
106473: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106474: CALL 106483 0 0
// end ;
106478: LD_VAR 0 4
106482: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106483: LD_INT 0
106485: PPUSH
106486: PPUSH
106487: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106488: LD_STRING resetWarehouseGatheringPoints();
106490: PPUSH
106491: CALL_OW 559
// if warehouseGatheringPoints then
106495: LD_EXP 134
106499: IFFALSE 106625
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106501: LD_ADDR_VAR 0 3
106505: PUSH
106506: LD_EXP 134
106510: PPUSH
106511: CALL 61018 0 1
106515: ST_TO_ADDR
// for i := 1 to list do
106516: LD_ADDR_VAR 0 2
106520: PUSH
106521: DOUBLE
106522: LD_INT 1
106524: DEC
106525: ST_TO_ADDR
106526: LD_VAR 0 3
106530: PUSH
106531: FOR_TO
106532: IFFALSE 106623
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106534: LD_STRING setWarehouseGatheringPointXY(
106536: PUSH
106537: LD_VAR 0 3
106541: PUSH
106542: LD_VAR 0 2
106546: ARRAY
106547: PUSH
106548: LD_INT 1
106550: ARRAY
106551: STR
106552: PUSH
106553: LD_STRING ,
106555: STR
106556: PUSH
106557: LD_VAR 0 3
106561: PUSH
106562: LD_VAR 0 2
106566: ARRAY
106567: PUSH
106568: LD_INT 2
106570: ARRAY
106571: STR
106572: PUSH
106573: LD_STRING ,
106575: STR
106576: PUSH
106577: LD_VAR 0 3
106581: PUSH
106582: LD_VAR 0 2
106586: ARRAY
106587: PUSH
106588: LD_INT 3
106590: ARRAY
106591: STR
106592: PUSH
106593: LD_STRING ,
106595: STR
106596: PUSH
106597: LD_VAR 0 3
106601: PUSH
106602: LD_VAR 0 2
106606: ARRAY
106607: PUSH
106608: LD_INT 4
106610: ARRAY
106611: STR
106612: PUSH
106613: LD_STRING )
106615: STR
106616: PPUSH
106617: CALL_OW 559
106621: GO 106531
106623: POP
106624: POP
// end ; end ;
106625: LD_VAR 0 1
106629: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106630: LD_EXP 134
106634: IFFALSE 107319
106636: GO 106638
106638: DISABLE
106639: LD_INT 0
106641: PPUSH
106642: PPUSH
106643: PPUSH
106644: PPUSH
106645: PPUSH
106646: PPUSH
106647: PPUSH
106648: PPUSH
106649: PPUSH
// begin enable ;
106650: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106651: LD_ADDR_VAR 0 3
106655: PUSH
106656: LD_EXP 134
106660: PPUSH
106661: CALL 61018 0 1
106665: ST_TO_ADDR
// if not list then
106666: LD_VAR 0 3
106670: NOT
106671: IFFALSE 106675
// exit ;
106673: GO 107319
// for i := 1 to list do
106675: LD_ADDR_VAR 0 1
106679: PUSH
106680: DOUBLE
106681: LD_INT 1
106683: DEC
106684: ST_TO_ADDR
106685: LD_VAR 0 3
106689: PUSH
106690: FOR_TO
106691: IFFALSE 107317
// begin depot := list [ i ] [ 2 ] ;
106693: LD_ADDR_VAR 0 8
106697: PUSH
106698: LD_VAR 0 3
106702: PUSH
106703: LD_VAR 0 1
106707: ARRAY
106708: PUSH
106709: LD_INT 2
106711: ARRAY
106712: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106713: LD_ADDR_VAR 0 5
106717: PUSH
106718: LD_VAR 0 3
106722: PUSH
106723: LD_VAR 0 1
106727: ARRAY
106728: PUSH
106729: LD_INT 1
106731: ARRAY
106732: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106733: LD_VAR 0 8
106737: PPUSH
106738: CALL_OW 301
106742: PUSH
106743: LD_VAR 0 5
106747: PUSH
106748: LD_VAR 0 8
106752: PPUSH
106753: CALL_OW 255
106757: NONEQUAL
106758: OR
106759: IFFALSE 106788
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106761: LD_ADDR_EXP 134
106765: PUSH
106766: LD_EXP 134
106770: PPUSH
106771: LD_VAR 0 8
106775: PPUSH
106776: LD_INT 0
106778: PPUSH
106779: CALL_OW 1
106783: ST_TO_ADDR
// exit ;
106784: POP
106785: POP
106786: GO 107319
// end ; x := list [ i ] [ 3 ] ;
106788: LD_ADDR_VAR 0 6
106792: PUSH
106793: LD_VAR 0 3
106797: PUSH
106798: LD_VAR 0 1
106802: ARRAY
106803: PUSH
106804: LD_INT 3
106806: ARRAY
106807: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106808: LD_ADDR_VAR 0 7
106812: PUSH
106813: LD_VAR 0 3
106817: PUSH
106818: LD_VAR 0 1
106822: ARRAY
106823: PUSH
106824: LD_INT 4
106826: ARRAY
106827: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106828: LD_ADDR_VAR 0 9
106832: PUSH
106833: LD_VAR 0 6
106837: PPUSH
106838: LD_VAR 0 7
106842: PPUSH
106843: LD_INT 16
106845: PPUSH
106846: CALL 59606 0 3
106850: ST_TO_ADDR
// if not cratesNearbyPoint then
106851: LD_VAR 0 9
106855: NOT
106856: IFFALSE 106862
// exit ;
106858: POP
106859: POP
106860: GO 107319
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106862: LD_ADDR_VAR 0 4
106866: PUSH
106867: LD_INT 22
106869: PUSH
106870: LD_VAR 0 5
106874: PUSH
106875: EMPTY
106876: LIST
106877: LIST
106878: PUSH
106879: LD_INT 3
106881: PUSH
106882: LD_INT 60
106884: PUSH
106885: EMPTY
106886: LIST
106887: PUSH
106888: EMPTY
106889: LIST
106890: LIST
106891: PUSH
106892: LD_INT 91
106894: PUSH
106895: LD_VAR 0 8
106899: PUSH
106900: LD_INT 6
106902: PUSH
106903: EMPTY
106904: LIST
106905: LIST
106906: LIST
106907: PUSH
106908: LD_INT 2
106910: PUSH
106911: LD_INT 25
106913: PUSH
106914: LD_INT 2
106916: PUSH
106917: EMPTY
106918: LIST
106919: LIST
106920: PUSH
106921: LD_INT 25
106923: PUSH
106924: LD_INT 16
106926: PUSH
106927: EMPTY
106928: LIST
106929: LIST
106930: PUSH
106931: EMPTY
106932: LIST
106933: LIST
106934: LIST
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: LIST
106940: LIST
106941: PPUSH
106942: CALL_OW 69
106946: PUSH
106947: LD_VAR 0 8
106951: PPUSH
106952: CALL_OW 313
106956: PPUSH
106957: LD_INT 3
106959: PUSH
106960: LD_INT 60
106962: PUSH
106963: EMPTY
106964: LIST
106965: PUSH
106966: EMPTY
106967: LIST
106968: LIST
106969: PUSH
106970: LD_INT 2
106972: PUSH
106973: LD_INT 25
106975: PUSH
106976: LD_INT 2
106978: PUSH
106979: EMPTY
106980: LIST
106981: LIST
106982: PUSH
106983: LD_INT 25
106985: PUSH
106986: LD_INT 16
106988: PUSH
106989: EMPTY
106990: LIST
106991: LIST
106992: PUSH
106993: EMPTY
106994: LIST
106995: LIST
106996: LIST
106997: PUSH
106998: EMPTY
106999: LIST
107000: LIST
107001: PPUSH
107002: CALL_OW 72
107006: UNION
107007: ST_TO_ADDR
// if tmp then
107008: LD_VAR 0 4
107012: IFFALSE 107092
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107014: LD_ADDR_VAR 0 4
107018: PUSH
107019: LD_VAR 0 4
107023: PPUSH
107024: LD_INT 3
107026: PPUSH
107027: CALL 57575 0 2
107031: ST_TO_ADDR
// for j in tmp do
107032: LD_ADDR_VAR 0 2
107036: PUSH
107037: LD_VAR 0 4
107041: PUSH
107042: FOR_IN
107043: IFFALSE 107086
// begin if IsInUnit ( j ) then
107045: LD_VAR 0 2
107049: PPUSH
107050: CALL_OW 310
107054: IFFALSE 107065
// ComExit ( j ) ;
107056: LD_VAR 0 2
107060: PPUSH
107061: CALL 57658 0 1
// AddComCollect ( j , x , y ) ;
107065: LD_VAR 0 2
107069: PPUSH
107070: LD_VAR 0 6
107074: PPUSH
107075: LD_VAR 0 7
107079: PPUSH
107080: CALL_OW 177
// end ;
107084: GO 107042
107086: POP
107087: POP
// exit ;
107088: POP
107089: POP
107090: GO 107319
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107092: LD_ADDR_VAR 0 4
107096: PUSH
107097: LD_INT 22
107099: PUSH
107100: LD_VAR 0 5
107104: PUSH
107105: EMPTY
107106: LIST
107107: LIST
107108: PUSH
107109: LD_INT 91
107111: PUSH
107112: LD_VAR 0 8
107116: PUSH
107117: LD_INT 8
107119: PUSH
107120: EMPTY
107121: LIST
107122: LIST
107123: LIST
107124: PUSH
107125: LD_INT 2
107127: PUSH
107128: LD_INT 34
107130: PUSH
107131: LD_INT 12
107133: PUSH
107134: EMPTY
107135: LIST
107136: LIST
107137: PUSH
107138: LD_INT 34
107140: PUSH
107141: LD_INT 51
107143: PUSH
107144: EMPTY
107145: LIST
107146: LIST
107147: PUSH
107148: LD_INT 34
107150: PUSH
107151: LD_INT 32
107153: PUSH
107154: EMPTY
107155: LIST
107156: LIST
107157: PUSH
107158: LD_INT 34
107160: PUSH
107161: LD_INT 89
107163: PUSH
107164: EMPTY
107165: LIST
107166: LIST
107167: PUSH
107168: EMPTY
107169: LIST
107170: LIST
107171: LIST
107172: LIST
107173: LIST
107174: PUSH
107175: EMPTY
107176: LIST
107177: LIST
107178: LIST
107179: PPUSH
107180: CALL_OW 69
107184: ST_TO_ADDR
// if tmp then
107185: LD_VAR 0 4
107189: IFFALSE 107315
// begin for j in tmp do
107191: LD_ADDR_VAR 0 2
107195: PUSH
107196: LD_VAR 0 4
107200: PUSH
107201: FOR_IN
107202: IFFALSE 107313
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107204: LD_VAR 0 2
107208: PPUSH
107209: CALL_OW 262
107213: PUSH
107214: LD_INT 3
107216: EQUAL
107217: PUSH
107218: LD_VAR 0 2
107222: PPUSH
107223: CALL_OW 261
107227: PUSH
107228: LD_INT 20
107230: GREATER
107231: OR
107232: PUSH
107233: LD_VAR 0 2
107237: PPUSH
107238: CALL_OW 314
107242: NOT
107243: AND
107244: PUSH
107245: LD_VAR 0 2
107249: PPUSH
107250: CALL_OW 263
107254: PUSH
107255: LD_INT 1
107257: NONEQUAL
107258: PUSH
107259: LD_VAR 0 2
107263: PPUSH
107264: CALL_OW 311
107268: OR
107269: AND
107270: IFFALSE 107311
// begin ComCollect ( j , x , y ) ;
107272: LD_VAR 0 2
107276: PPUSH
107277: LD_VAR 0 6
107281: PPUSH
107282: LD_VAR 0 7
107286: PPUSH
107287: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107291: LD_VAR 0 2
107295: PPUSH
107296: LD_VAR 0 8
107300: PPUSH
107301: CALL_OW 172
// exit ;
107305: POP
107306: POP
107307: POP
107308: POP
107309: GO 107319
// end ;
107311: GO 107201
107313: POP
107314: POP
// end ; end ;
107315: GO 106690
107317: POP
107318: POP
// end ; end_of_file
107319: PPOPN 9
107321: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107322: LD_INT 0
107324: PPUSH
107325: PPUSH
107326: PPUSH
107327: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107328: LD_VAR 0 1
107332: PPUSH
107333: CALL_OW 264
107337: PUSH
107338: LD_INT 91
107340: EQUAL
107341: IFFALSE 107413
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107343: LD_INT 68
107345: PPUSH
107346: LD_VAR 0 1
107350: PPUSH
107351: CALL_OW 255
107355: PPUSH
107356: CALL_OW 321
107360: PUSH
107361: LD_INT 2
107363: EQUAL
107364: IFFALSE 107376
// eff := 70 else
107366: LD_ADDR_VAR 0 4
107370: PUSH
107371: LD_INT 70
107373: ST_TO_ADDR
107374: GO 107384
// eff := 30 ;
107376: LD_ADDR_VAR 0 4
107380: PUSH
107381: LD_INT 30
107383: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107384: LD_VAR 0 1
107388: PPUSH
107389: CALL_OW 250
107393: PPUSH
107394: LD_VAR 0 1
107398: PPUSH
107399: CALL_OW 251
107403: PPUSH
107404: LD_VAR 0 4
107408: PPUSH
107409: CALL_OW 495
// end ; end ;
107413: LD_VAR 0 2
107417: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107418: LD_INT 0
107420: PPUSH
// end ;
107421: LD_VAR 0 4
107425: RET
// export function SOS_Command ( cmd ) ; begin
107426: LD_INT 0
107428: PPUSH
// end ;
107429: LD_VAR 0 2
107433: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107434: LD_INT 0
107436: PPUSH
// end ;
107437: LD_VAR 0 6
107441: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107442: LD_INT 0
107444: PPUSH
107445: PPUSH
// if not vehicle or not factory then
107446: LD_VAR 0 1
107450: NOT
107451: PUSH
107452: LD_VAR 0 2
107456: NOT
107457: OR
107458: IFFALSE 107462
// exit ;
107460: GO 107693
// if factoryWaypoints >= factory then
107462: LD_EXP 133
107466: PUSH
107467: LD_VAR 0 2
107471: GREATEREQUAL
107472: IFFALSE 107693
// if factoryWaypoints [ factory ] then
107474: LD_EXP 133
107478: PUSH
107479: LD_VAR 0 2
107483: ARRAY
107484: IFFALSE 107693
// begin if GetControl ( vehicle ) = control_manual then
107486: LD_VAR 0 1
107490: PPUSH
107491: CALL_OW 263
107495: PUSH
107496: LD_INT 1
107498: EQUAL
107499: IFFALSE 107580
// begin driver := IsDrivenBy ( vehicle ) ;
107501: LD_ADDR_VAR 0 4
107505: PUSH
107506: LD_VAR 0 1
107510: PPUSH
107511: CALL_OW 311
107515: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107516: LD_VAR 0 4
107520: PPUSH
107521: LD_EXP 133
107525: PUSH
107526: LD_VAR 0 2
107530: ARRAY
107531: PUSH
107532: LD_INT 3
107534: ARRAY
107535: PPUSH
107536: LD_EXP 133
107540: PUSH
107541: LD_VAR 0 2
107545: ARRAY
107546: PUSH
107547: LD_INT 4
107549: ARRAY
107550: PPUSH
107551: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107555: LD_VAR 0 4
107559: PPUSH
107560: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107564: LD_VAR 0 4
107568: PPUSH
107569: LD_VAR 0 2
107573: PPUSH
107574: CALL_OW 180
// end else
107578: GO 107693
// if GetControl ( vehicle ) = control_remote then
107580: LD_VAR 0 1
107584: PPUSH
107585: CALL_OW 263
107589: PUSH
107590: LD_INT 2
107592: EQUAL
107593: IFFALSE 107654
// begin wait ( 0 0$2 ) ;
107595: LD_INT 70
107597: PPUSH
107598: CALL_OW 67
// if Connect ( vehicle ) then
107602: LD_VAR 0 1
107606: PPUSH
107607: CALL 27990 0 1
107611: IFFALSE 107652
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107613: LD_VAR 0 1
107617: PPUSH
107618: LD_EXP 133
107622: PUSH
107623: LD_VAR 0 2
107627: ARRAY
107628: PUSH
107629: LD_INT 3
107631: ARRAY
107632: PPUSH
107633: LD_EXP 133
107637: PUSH
107638: LD_VAR 0 2
107642: ARRAY
107643: PUSH
107644: LD_INT 4
107646: ARRAY
107647: PPUSH
107648: CALL_OW 171
// end else
107652: GO 107693
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107654: LD_VAR 0 1
107658: PPUSH
107659: LD_EXP 133
107663: PUSH
107664: LD_VAR 0 2
107668: ARRAY
107669: PUSH
107670: LD_INT 3
107672: ARRAY
107673: PPUSH
107674: LD_EXP 133
107678: PUSH
107679: LD_VAR 0 2
107683: ARRAY
107684: PUSH
107685: LD_INT 4
107687: ARRAY
107688: PPUSH
107689: CALL_OW 171
// end ; end ;
107693: LD_VAR 0 3
107697: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107698: LD_INT 0
107700: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107701: LD_VAR 0 1
107705: PUSH
107706: LD_INT 250
107708: EQUAL
107709: PUSH
107710: LD_VAR 0 2
107714: PPUSH
107715: CALL_OW 264
107719: PUSH
107720: LD_INT 81
107722: EQUAL
107723: AND
107724: IFFALSE 107745
// MinerPlaceMine ( unit , x , y ) ;
107726: LD_VAR 0 2
107730: PPUSH
107731: LD_VAR 0 4
107735: PPUSH
107736: LD_VAR 0 5
107740: PPUSH
107741: CALL 110130 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107745: LD_VAR 0 1
107749: PUSH
107750: LD_INT 251
107752: EQUAL
107753: PUSH
107754: LD_VAR 0 2
107758: PPUSH
107759: CALL_OW 264
107763: PUSH
107764: LD_INT 81
107766: EQUAL
107767: AND
107768: IFFALSE 107789
// MinerDetonateMine ( unit , x , y ) ;
107770: LD_VAR 0 2
107774: PPUSH
107775: LD_VAR 0 4
107779: PPUSH
107780: LD_VAR 0 5
107784: PPUSH
107785: CALL 110405 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107789: LD_VAR 0 1
107793: PUSH
107794: LD_INT 252
107796: EQUAL
107797: PUSH
107798: LD_VAR 0 2
107802: PPUSH
107803: CALL_OW 264
107807: PUSH
107808: LD_INT 81
107810: EQUAL
107811: AND
107812: IFFALSE 107833
// MinerCreateMinefield ( unit , x , y ) ;
107814: LD_VAR 0 2
107818: PPUSH
107819: LD_VAR 0 4
107823: PPUSH
107824: LD_VAR 0 5
107828: PPUSH
107829: CALL 110822 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107833: LD_VAR 0 1
107837: PUSH
107838: LD_INT 253
107840: EQUAL
107841: PUSH
107842: LD_VAR 0 2
107846: PPUSH
107847: CALL_OW 257
107851: PUSH
107852: LD_INT 5
107854: EQUAL
107855: AND
107856: IFFALSE 107877
// ComBinocular ( unit , x , y ) ;
107858: LD_VAR 0 2
107862: PPUSH
107863: LD_VAR 0 4
107867: PPUSH
107868: LD_VAR 0 5
107872: PPUSH
107873: CALL 111191 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107877: LD_VAR 0 1
107881: PUSH
107882: LD_INT 254
107884: EQUAL
107885: PUSH
107886: LD_VAR 0 2
107890: PPUSH
107891: CALL_OW 264
107895: PUSH
107896: LD_INT 99
107898: EQUAL
107899: AND
107900: PUSH
107901: LD_VAR 0 3
107905: PPUSH
107906: CALL_OW 263
107910: PUSH
107911: LD_INT 3
107913: EQUAL
107914: AND
107915: IFFALSE 107931
// HackDestroyVehicle ( unit , selectedUnit ) ;
107917: LD_VAR 0 2
107921: PPUSH
107922: LD_VAR 0 3
107926: PPUSH
107927: CALL 109494 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107931: LD_VAR 0 1
107935: PUSH
107936: LD_INT 255
107938: EQUAL
107939: PUSH
107940: LD_VAR 0 2
107944: PPUSH
107945: CALL_OW 264
107949: PUSH
107950: LD_INT 14
107952: PUSH
107953: LD_INT 53
107955: PUSH
107956: EMPTY
107957: LIST
107958: LIST
107959: IN
107960: AND
107961: PUSH
107962: LD_VAR 0 4
107966: PPUSH
107967: LD_VAR 0 5
107971: PPUSH
107972: CALL_OW 488
107976: AND
107977: IFFALSE 108001
// CutTreeXYR ( unit , x , y , 12 ) ;
107979: LD_VAR 0 2
107983: PPUSH
107984: LD_VAR 0 4
107988: PPUSH
107989: LD_VAR 0 5
107993: PPUSH
107994: LD_INT 12
107996: PPUSH
107997: CALL 108064 0 4
// if cmd = 256 then
108001: LD_VAR 0 1
108005: PUSH
108006: LD_INT 256
108008: EQUAL
108009: IFFALSE 108030
// SetFactoryWaypoint ( unit , x , y ) ;
108011: LD_VAR 0 2
108015: PPUSH
108016: LD_VAR 0 4
108020: PPUSH
108021: LD_VAR 0 5
108025: PPUSH
108026: CALL 106011 0 3
// if cmd = 257 then
108030: LD_VAR 0 1
108034: PUSH
108035: LD_INT 257
108037: EQUAL
108038: IFFALSE 108059
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108040: LD_VAR 0 2
108044: PPUSH
108045: LD_VAR 0 4
108049: PPUSH
108050: LD_VAR 0 5
108054: PPUSH
108055: CALL 106373 0 3
// end ;
108059: LD_VAR 0 6
108063: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108064: LD_INT 0
108066: PPUSH
108067: PPUSH
108068: PPUSH
108069: PPUSH
108070: PPUSH
108071: PPUSH
108072: PPUSH
108073: PPUSH
108074: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108075: LD_VAR 0 1
108079: NOT
108080: PUSH
108081: LD_VAR 0 2
108085: PPUSH
108086: LD_VAR 0 3
108090: PPUSH
108091: CALL_OW 488
108095: NOT
108096: OR
108097: PUSH
108098: LD_VAR 0 4
108102: NOT
108103: OR
108104: IFFALSE 108108
// exit ;
108106: GO 108448
// list := [ ] ;
108108: LD_ADDR_VAR 0 13
108112: PUSH
108113: EMPTY
108114: ST_TO_ADDR
// if x - r < 0 then
108115: LD_VAR 0 2
108119: PUSH
108120: LD_VAR 0 4
108124: MINUS
108125: PUSH
108126: LD_INT 0
108128: LESS
108129: IFFALSE 108141
// min_x := 0 else
108131: LD_ADDR_VAR 0 7
108135: PUSH
108136: LD_INT 0
108138: ST_TO_ADDR
108139: GO 108157
// min_x := x - r ;
108141: LD_ADDR_VAR 0 7
108145: PUSH
108146: LD_VAR 0 2
108150: PUSH
108151: LD_VAR 0 4
108155: MINUS
108156: ST_TO_ADDR
// if y - r < 0 then
108157: LD_VAR 0 3
108161: PUSH
108162: LD_VAR 0 4
108166: MINUS
108167: PUSH
108168: LD_INT 0
108170: LESS
108171: IFFALSE 108183
// min_y := 0 else
108173: LD_ADDR_VAR 0 8
108177: PUSH
108178: LD_INT 0
108180: ST_TO_ADDR
108181: GO 108199
// min_y := y - r ;
108183: LD_ADDR_VAR 0 8
108187: PUSH
108188: LD_VAR 0 3
108192: PUSH
108193: LD_VAR 0 4
108197: MINUS
108198: ST_TO_ADDR
// max_x := x + r ;
108199: LD_ADDR_VAR 0 9
108203: PUSH
108204: LD_VAR 0 2
108208: PUSH
108209: LD_VAR 0 4
108213: PLUS
108214: ST_TO_ADDR
// max_y := y + r ;
108215: LD_ADDR_VAR 0 10
108219: PUSH
108220: LD_VAR 0 3
108224: PUSH
108225: LD_VAR 0 4
108229: PLUS
108230: ST_TO_ADDR
// for _x = min_x to max_x do
108231: LD_ADDR_VAR 0 11
108235: PUSH
108236: DOUBLE
108237: LD_VAR 0 7
108241: DEC
108242: ST_TO_ADDR
108243: LD_VAR 0 9
108247: PUSH
108248: FOR_TO
108249: IFFALSE 108366
// for _y = min_y to max_y do
108251: LD_ADDR_VAR 0 12
108255: PUSH
108256: DOUBLE
108257: LD_VAR 0 8
108261: DEC
108262: ST_TO_ADDR
108263: LD_VAR 0 10
108267: PUSH
108268: FOR_TO
108269: IFFALSE 108362
// begin if not ValidHex ( _x , _y ) then
108271: LD_VAR 0 11
108275: PPUSH
108276: LD_VAR 0 12
108280: PPUSH
108281: CALL_OW 488
108285: NOT
108286: IFFALSE 108290
// continue ;
108288: GO 108268
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108290: LD_VAR 0 11
108294: PPUSH
108295: LD_VAR 0 12
108299: PPUSH
108300: CALL_OW 351
108304: PUSH
108305: LD_VAR 0 11
108309: PPUSH
108310: LD_VAR 0 12
108314: PPUSH
108315: CALL_OW 554
108319: AND
108320: IFFALSE 108360
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108322: LD_ADDR_VAR 0 13
108326: PUSH
108327: LD_VAR 0 13
108331: PPUSH
108332: LD_VAR 0 13
108336: PUSH
108337: LD_INT 1
108339: PLUS
108340: PPUSH
108341: LD_VAR 0 11
108345: PUSH
108346: LD_VAR 0 12
108350: PUSH
108351: EMPTY
108352: LIST
108353: LIST
108354: PPUSH
108355: CALL_OW 2
108359: ST_TO_ADDR
// end ;
108360: GO 108268
108362: POP
108363: POP
108364: GO 108248
108366: POP
108367: POP
// if not list then
108368: LD_VAR 0 13
108372: NOT
108373: IFFALSE 108377
// exit ;
108375: GO 108448
// for i in list do
108377: LD_ADDR_VAR 0 6
108381: PUSH
108382: LD_VAR 0 13
108386: PUSH
108387: FOR_IN
108388: IFFALSE 108446
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108390: LD_VAR 0 1
108394: PPUSH
108395: LD_STRING M
108397: PUSH
108398: LD_VAR 0 6
108402: PUSH
108403: LD_INT 1
108405: ARRAY
108406: PUSH
108407: LD_VAR 0 6
108411: PUSH
108412: LD_INT 2
108414: ARRAY
108415: PUSH
108416: LD_INT 0
108418: PUSH
108419: LD_INT 0
108421: PUSH
108422: LD_INT 0
108424: PUSH
108425: LD_INT 0
108427: PUSH
108428: EMPTY
108429: LIST
108430: LIST
108431: LIST
108432: LIST
108433: LIST
108434: LIST
108435: LIST
108436: PUSH
108437: EMPTY
108438: LIST
108439: PPUSH
108440: CALL_OW 447
108444: GO 108387
108446: POP
108447: POP
// end ;
108448: LD_VAR 0 5
108452: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108453: LD_EXP 136
108457: NOT
108458: IFFALSE 108508
108460: GO 108462
108462: DISABLE
// begin initHack := true ;
108463: LD_ADDR_EXP 136
108467: PUSH
108468: LD_INT 1
108470: ST_TO_ADDR
// hackTanks := [ ] ;
108471: LD_ADDR_EXP 137
108475: PUSH
108476: EMPTY
108477: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108478: LD_ADDR_EXP 138
108482: PUSH
108483: EMPTY
108484: ST_TO_ADDR
// hackLimit := 3 ;
108485: LD_ADDR_EXP 139
108489: PUSH
108490: LD_INT 3
108492: ST_TO_ADDR
// hackDist := 12 ;
108493: LD_ADDR_EXP 140
108497: PUSH
108498: LD_INT 12
108500: ST_TO_ADDR
// hackCounter := [ ] ;
108501: LD_ADDR_EXP 141
108505: PUSH
108506: EMPTY
108507: ST_TO_ADDR
// end ;
108508: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108509: LD_EXP 136
108513: PUSH
108514: LD_INT 34
108516: PUSH
108517: LD_INT 99
108519: PUSH
108520: EMPTY
108521: LIST
108522: LIST
108523: PPUSH
108524: CALL_OW 69
108528: AND
108529: IFFALSE 108782
108531: GO 108533
108533: DISABLE
108534: LD_INT 0
108536: PPUSH
108537: PPUSH
// begin enable ;
108538: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108539: LD_ADDR_VAR 0 1
108543: PUSH
108544: LD_INT 34
108546: PUSH
108547: LD_INT 99
108549: PUSH
108550: EMPTY
108551: LIST
108552: LIST
108553: PPUSH
108554: CALL_OW 69
108558: PUSH
108559: FOR_IN
108560: IFFALSE 108780
// begin if not i in hackTanks then
108562: LD_VAR 0 1
108566: PUSH
108567: LD_EXP 137
108571: IN
108572: NOT
108573: IFFALSE 108656
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108575: LD_ADDR_EXP 137
108579: PUSH
108580: LD_EXP 137
108584: PPUSH
108585: LD_EXP 137
108589: PUSH
108590: LD_INT 1
108592: PLUS
108593: PPUSH
108594: LD_VAR 0 1
108598: PPUSH
108599: CALL_OW 1
108603: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108604: LD_ADDR_EXP 138
108608: PUSH
108609: LD_EXP 138
108613: PPUSH
108614: LD_EXP 138
108618: PUSH
108619: LD_INT 1
108621: PLUS
108622: PPUSH
108623: EMPTY
108624: PPUSH
108625: CALL_OW 1
108629: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108630: LD_ADDR_EXP 141
108634: PUSH
108635: LD_EXP 141
108639: PPUSH
108640: LD_EXP 141
108644: PUSH
108645: LD_INT 1
108647: PLUS
108648: PPUSH
108649: EMPTY
108650: PPUSH
108651: CALL_OW 1
108655: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108656: LD_VAR 0 1
108660: PPUSH
108661: CALL_OW 302
108665: NOT
108666: IFFALSE 108679
// begin HackUnlinkAll ( i ) ;
108668: LD_VAR 0 1
108672: PPUSH
108673: CALL 108785 0 1
// continue ;
108677: GO 108559
// end ; HackCheckCapturedStatus ( i ) ;
108679: LD_VAR 0 1
108683: PPUSH
108684: CALL 109228 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108688: LD_ADDR_VAR 0 2
108692: PUSH
108693: LD_INT 81
108695: PUSH
108696: LD_VAR 0 1
108700: PPUSH
108701: CALL_OW 255
108705: PUSH
108706: EMPTY
108707: LIST
108708: LIST
108709: PUSH
108710: LD_INT 33
108712: PUSH
108713: LD_INT 3
108715: PUSH
108716: EMPTY
108717: LIST
108718: LIST
108719: PUSH
108720: LD_INT 91
108722: PUSH
108723: LD_VAR 0 1
108727: PUSH
108728: LD_EXP 140
108732: PUSH
108733: EMPTY
108734: LIST
108735: LIST
108736: LIST
108737: PUSH
108738: LD_INT 50
108740: PUSH
108741: EMPTY
108742: LIST
108743: PUSH
108744: EMPTY
108745: LIST
108746: LIST
108747: LIST
108748: LIST
108749: PPUSH
108750: CALL_OW 69
108754: ST_TO_ADDR
// if not tmp then
108755: LD_VAR 0 2
108759: NOT
108760: IFFALSE 108764
// continue ;
108762: GO 108559
// HackLink ( i , tmp ) ;
108764: LD_VAR 0 1
108768: PPUSH
108769: LD_VAR 0 2
108773: PPUSH
108774: CALL 108921 0 2
// end ;
108778: GO 108559
108780: POP
108781: POP
// end ;
108782: PPOPN 2
108784: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108785: LD_INT 0
108787: PPUSH
108788: PPUSH
108789: PPUSH
// if not hack in hackTanks then
108790: LD_VAR 0 1
108794: PUSH
108795: LD_EXP 137
108799: IN
108800: NOT
108801: IFFALSE 108805
// exit ;
108803: GO 108916
// index := GetElementIndex ( hackTanks , hack ) ;
108805: LD_ADDR_VAR 0 4
108809: PUSH
108810: LD_EXP 137
108814: PPUSH
108815: LD_VAR 0 1
108819: PPUSH
108820: CALL 24806 0 2
108824: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
108825: LD_EXP 138
108829: PUSH
108830: LD_VAR 0 4
108834: ARRAY
108835: IFFALSE 108916
// begin for i in hackTanksCaptured [ index ] do
108837: LD_ADDR_VAR 0 3
108841: PUSH
108842: LD_EXP 138
108846: PUSH
108847: LD_VAR 0 4
108851: ARRAY
108852: PUSH
108853: FOR_IN
108854: IFFALSE 108880
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
108856: LD_VAR 0 3
108860: PUSH
108861: LD_INT 1
108863: ARRAY
108864: PPUSH
108865: LD_VAR 0 3
108869: PUSH
108870: LD_INT 2
108872: ARRAY
108873: PPUSH
108874: CALL_OW 235
108878: GO 108853
108880: POP
108881: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108882: LD_ADDR_EXP 138
108886: PUSH
108887: LD_EXP 138
108891: PPUSH
108892: LD_VAR 0 4
108896: PPUSH
108897: EMPTY
108898: PPUSH
108899: CALL_OW 1
108903: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108904: LD_VAR 0 1
108908: PPUSH
108909: LD_INT 0
108911: PPUSH
108912: CALL_OW 505
// end ; end ;
108916: LD_VAR 0 2
108920: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108921: LD_INT 0
108923: PPUSH
108924: PPUSH
108925: PPUSH
// if not hack in hackTanks or not vehicles then
108926: LD_VAR 0 1
108930: PUSH
108931: LD_EXP 137
108935: IN
108936: NOT
108937: PUSH
108938: LD_VAR 0 2
108942: NOT
108943: OR
108944: IFFALSE 108948
// exit ;
108946: GO 109223
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108948: LD_ADDR_VAR 0 2
108952: PUSH
108953: LD_VAR 0 1
108957: PPUSH
108958: LD_VAR 0 2
108962: PPUSH
108963: LD_INT 1
108965: PPUSH
108966: LD_INT 1
108968: PPUSH
108969: CALL 25456 0 4
108973: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108974: LD_ADDR_VAR 0 5
108978: PUSH
108979: LD_EXP 137
108983: PPUSH
108984: LD_VAR 0 1
108988: PPUSH
108989: CALL 24806 0 2
108993: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108994: LD_EXP 138
108998: PUSH
108999: LD_VAR 0 5
109003: ARRAY
109004: PUSH
109005: LD_EXP 139
109009: LESS
109010: IFFALSE 109199
// begin for i := 1 to vehicles do
109012: LD_ADDR_VAR 0 4
109016: PUSH
109017: DOUBLE
109018: LD_INT 1
109020: DEC
109021: ST_TO_ADDR
109022: LD_VAR 0 2
109026: PUSH
109027: FOR_TO
109028: IFFALSE 109197
// begin if hackTanksCaptured [ index ] = hackLimit then
109030: LD_EXP 138
109034: PUSH
109035: LD_VAR 0 5
109039: ARRAY
109040: PUSH
109041: LD_EXP 139
109045: EQUAL
109046: IFFALSE 109050
// break ;
109048: GO 109197
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109050: LD_ADDR_EXP 141
109054: PUSH
109055: LD_EXP 141
109059: PPUSH
109060: LD_VAR 0 5
109064: PPUSH
109065: LD_EXP 141
109069: PUSH
109070: LD_VAR 0 5
109074: ARRAY
109075: PUSH
109076: LD_INT 1
109078: PLUS
109079: PPUSH
109080: CALL_OW 1
109084: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109085: LD_ADDR_EXP 138
109089: PUSH
109090: LD_EXP 138
109094: PPUSH
109095: LD_VAR 0 5
109099: PUSH
109100: LD_EXP 138
109104: PUSH
109105: LD_VAR 0 5
109109: ARRAY
109110: PUSH
109111: LD_INT 1
109113: PLUS
109114: PUSH
109115: EMPTY
109116: LIST
109117: LIST
109118: PPUSH
109119: LD_VAR 0 2
109123: PUSH
109124: LD_VAR 0 4
109128: ARRAY
109129: PUSH
109130: LD_VAR 0 2
109134: PUSH
109135: LD_VAR 0 4
109139: ARRAY
109140: PPUSH
109141: CALL_OW 255
109145: PUSH
109146: EMPTY
109147: LIST
109148: LIST
109149: PPUSH
109150: CALL 25021 0 3
109154: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109155: LD_VAR 0 2
109159: PUSH
109160: LD_VAR 0 4
109164: ARRAY
109165: PPUSH
109166: LD_VAR 0 1
109170: PPUSH
109171: CALL_OW 255
109175: PPUSH
109176: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109180: LD_VAR 0 2
109184: PUSH
109185: LD_VAR 0 4
109189: ARRAY
109190: PPUSH
109191: CALL_OW 141
// end ;
109195: GO 109027
109197: POP
109198: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109199: LD_VAR 0 1
109203: PPUSH
109204: LD_EXP 138
109208: PUSH
109209: LD_VAR 0 5
109213: ARRAY
109214: PUSH
109215: LD_INT 0
109217: PLUS
109218: PPUSH
109219: CALL_OW 505
// end ;
109223: LD_VAR 0 3
109227: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109228: LD_INT 0
109230: PPUSH
109231: PPUSH
109232: PPUSH
109233: PPUSH
// if not hack in hackTanks then
109234: LD_VAR 0 1
109238: PUSH
109239: LD_EXP 137
109243: IN
109244: NOT
109245: IFFALSE 109249
// exit ;
109247: GO 109489
// index := GetElementIndex ( hackTanks , hack ) ;
109249: LD_ADDR_VAR 0 4
109253: PUSH
109254: LD_EXP 137
109258: PPUSH
109259: LD_VAR 0 1
109263: PPUSH
109264: CALL 24806 0 2
109268: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109269: LD_ADDR_VAR 0 3
109273: PUSH
109274: DOUBLE
109275: LD_EXP 138
109279: PUSH
109280: LD_VAR 0 4
109284: ARRAY
109285: INC
109286: ST_TO_ADDR
109287: LD_INT 1
109289: PUSH
109290: FOR_DOWNTO
109291: IFFALSE 109463
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109293: LD_ADDR_VAR 0 5
109297: PUSH
109298: LD_EXP 138
109302: PUSH
109303: LD_VAR 0 4
109307: ARRAY
109308: PUSH
109309: LD_VAR 0 3
109313: ARRAY
109314: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109315: LD_VAR 0 5
109319: PUSH
109320: LD_INT 1
109322: ARRAY
109323: PPUSH
109324: CALL_OW 302
109328: NOT
109329: PUSH
109330: LD_VAR 0 5
109334: PUSH
109335: LD_INT 1
109337: ARRAY
109338: PPUSH
109339: CALL_OW 255
109343: PUSH
109344: LD_VAR 0 1
109348: PPUSH
109349: CALL_OW 255
109353: NONEQUAL
109354: OR
109355: IFFALSE 109461
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109357: LD_VAR 0 5
109361: PUSH
109362: LD_INT 1
109364: ARRAY
109365: PPUSH
109366: CALL_OW 305
109370: PUSH
109371: LD_VAR 0 5
109375: PUSH
109376: LD_INT 1
109378: ARRAY
109379: PPUSH
109380: CALL_OW 255
109384: PUSH
109385: LD_VAR 0 1
109389: PPUSH
109390: CALL_OW 255
109394: EQUAL
109395: AND
109396: IFFALSE 109420
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109398: LD_VAR 0 5
109402: PUSH
109403: LD_INT 1
109405: ARRAY
109406: PPUSH
109407: LD_VAR 0 5
109411: PUSH
109412: LD_INT 2
109414: ARRAY
109415: PPUSH
109416: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109420: LD_ADDR_EXP 138
109424: PUSH
109425: LD_EXP 138
109429: PPUSH
109430: LD_VAR 0 4
109434: PPUSH
109435: LD_EXP 138
109439: PUSH
109440: LD_VAR 0 4
109444: ARRAY
109445: PPUSH
109446: LD_VAR 0 3
109450: PPUSH
109451: CALL_OW 3
109455: PPUSH
109456: CALL_OW 1
109460: ST_TO_ADDR
// end ; end ;
109461: GO 109290
109463: POP
109464: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109465: LD_VAR 0 1
109469: PPUSH
109470: LD_EXP 138
109474: PUSH
109475: LD_VAR 0 4
109479: ARRAY
109480: PUSH
109481: LD_INT 0
109483: PLUS
109484: PPUSH
109485: CALL_OW 505
// end ;
109489: LD_VAR 0 2
109493: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109494: LD_INT 0
109496: PPUSH
109497: PPUSH
109498: PPUSH
109499: PPUSH
// if not hack in hackTanks then
109500: LD_VAR 0 1
109504: PUSH
109505: LD_EXP 137
109509: IN
109510: NOT
109511: IFFALSE 109515
// exit ;
109513: GO 109600
// index := GetElementIndex ( hackTanks , hack ) ;
109515: LD_ADDR_VAR 0 5
109519: PUSH
109520: LD_EXP 137
109524: PPUSH
109525: LD_VAR 0 1
109529: PPUSH
109530: CALL 24806 0 2
109534: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109535: LD_ADDR_VAR 0 4
109539: PUSH
109540: DOUBLE
109541: LD_INT 1
109543: DEC
109544: ST_TO_ADDR
109545: LD_EXP 138
109549: PUSH
109550: LD_VAR 0 5
109554: ARRAY
109555: PUSH
109556: FOR_TO
109557: IFFALSE 109598
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109559: LD_EXP 138
109563: PUSH
109564: LD_VAR 0 5
109568: ARRAY
109569: PUSH
109570: LD_VAR 0 4
109574: ARRAY
109575: PUSH
109576: LD_INT 1
109578: ARRAY
109579: PUSH
109580: LD_VAR 0 2
109584: EQUAL
109585: IFFALSE 109596
// KillUnit ( vehicle ) ;
109587: LD_VAR 0 2
109591: PPUSH
109592: CALL_OW 66
109596: GO 109556
109598: POP
109599: POP
// end ;
109600: LD_VAR 0 3
109604: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109605: LD_EXP 142
109609: NOT
109610: IFFALSE 109645
109612: GO 109614
109614: DISABLE
// begin initMiner := true ;
109615: LD_ADDR_EXP 142
109619: PUSH
109620: LD_INT 1
109622: ST_TO_ADDR
// minersList := [ ] ;
109623: LD_ADDR_EXP 143
109627: PUSH
109628: EMPTY
109629: ST_TO_ADDR
// minerMinesList := [ ] ;
109630: LD_ADDR_EXP 144
109634: PUSH
109635: EMPTY
109636: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109637: LD_ADDR_EXP 145
109641: PUSH
109642: LD_INT 5
109644: ST_TO_ADDR
// end ;
109645: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109646: LD_EXP 142
109650: PUSH
109651: LD_INT 34
109653: PUSH
109654: LD_INT 81
109656: PUSH
109657: EMPTY
109658: LIST
109659: LIST
109660: PPUSH
109661: CALL_OW 69
109665: AND
109666: IFFALSE 110127
109668: GO 109670
109670: DISABLE
109671: LD_INT 0
109673: PPUSH
109674: PPUSH
109675: PPUSH
109676: PPUSH
// begin enable ;
109677: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109678: LD_ADDR_VAR 0 1
109682: PUSH
109683: LD_INT 34
109685: PUSH
109686: LD_INT 81
109688: PUSH
109689: EMPTY
109690: LIST
109691: LIST
109692: PPUSH
109693: CALL_OW 69
109697: PUSH
109698: FOR_IN
109699: IFFALSE 109771
// begin if not i in minersList then
109701: LD_VAR 0 1
109705: PUSH
109706: LD_EXP 143
109710: IN
109711: NOT
109712: IFFALSE 109769
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109714: LD_ADDR_EXP 143
109718: PUSH
109719: LD_EXP 143
109723: PPUSH
109724: LD_EXP 143
109728: PUSH
109729: LD_INT 1
109731: PLUS
109732: PPUSH
109733: LD_VAR 0 1
109737: PPUSH
109738: CALL_OW 1
109742: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109743: LD_ADDR_EXP 144
109747: PUSH
109748: LD_EXP 144
109752: PPUSH
109753: LD_EXP 144
109757: PUSH
109758: LD_INT 1
109760: PLUS
109761: PPUSH
109762: EMPTY
109763: PPUSH
109764: CALL_OW 1
109768: ST_TO_ADDR
// end end ;
109769: GO 109698
109771: POP
109772: POP
// for i := minerMinesList downto 1 do
109773: LD_ADDR_VAR 0 1
109777: PUSH
109778: DOUBLE
109779: LD_EXP 144
109783: INC
109784: ST_TO_ADDR
109785: LD_INT 1
109787: PUSH
109788: FOR_DOWNTO
109789: IFFALSE 110125
// begin if IsLive ( minersList [ i ] ) then
109791: LD_EXP 143
109795: PUSH
109796: LD_VAR 0 1
109800: ARRAY
109801: PPUSH
109802: CALL_OW 300
109806: IFFALSE 109834
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109808: LD_EXP 143
109812: PUSH
109813: LD_VAR 0 1
109817: ARRAY
109818: PPUSH
109819: LD_EXP 144
109823: PUSH
109824: LD_VAR 0 1
109828: ARRAY
109829: PPUSH
109830: CALL_OW 505
// if not minerMinesList [ i ] then
109834: LD_EXP 144
109838: PUSH
109839: LD_VAR 0 1
109843: ARRAY
109844: NOT
109845: IFFALSE 109849
// continue ;
109847: GO 109788
// for j := minerMinesList [ i ] downto 1 do
109849: LD_ADDR_VAR 0 2
109853: PUSH
109854: DOUBLE
109855: LD_EXP 144
109859: PUSH
109860: LD_VAR 0 1
109864: ARRAY
109865: INC
109866: ST_TO_ADDR
109867: LD_INT 1
109869: PUSH
109870: FOR_DOWNTO
109871: IFFALSE 110121
// begin side := GetSide ( minersList [ i ] ) ;
109873: LD_ADDR_VAR 0 3
109877: PUSH
109878: LD_EXP 143
109882: PUSH
109883: LD_VAR 0 1
109887: ARRAY
109888: PPUSH
109889: CALL_OW 255
109893: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109894: LD_ADDR_VAR 0 4
109898: PUSH
109899: LD_EXP 144
109903: PUSH
109904: LD_VAR 0 1
109908: ARRAY
109909: PUSH
109910: LD_VAR 0 2
109914: ARRAY
109915: PUSH
109916: LD_INT 1
109918: ARRAY
109919: PPUSH
109920: LD_EXP 144
109924: PUSH
109925: LD_VAR 0 1
109929: ARRAY
109930: PUSH
109931: LD_VAR 0 2
109935: ARRAY
109936: PUSH
109937: LD_INT 2
109939: ARRAY
109940: PPUSH
109941: CALL_OW 428
109945: ST_TO_ADDR
// if not tmp then
109946: LD_VAR 0 4
109950: NOT
109951: IFFALSE 109955
// continue ;
109953: GO 109870
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109955: LD_VAR 0 4
109959: PUSH
109960: LD_INT 81
109962: PUSH
109963: LD_VAR 0 3
109967: PUSH
109968: EMPTY
109969: LIST
109970: LIST
109971: PPUSH
109972: CALL_OW 69
109976: IN
109977: PUSH
109978: LD_EXP 144
109982: PUSH
109983: LD_VAR 0 1
109987: ARRAY
109988: PUSH
109989: LD_VAR 0 2
109993: ARRAY
109994: PUSH
109995: LD_INT 1
109997: ARRAY
109998: PPUSH
109999: LD_EXP 144
110003: PUSH
110004: LD_VAR 0 1
110008: ARRAY
110009: PUSH
110010: LD_VAR 0 2
110014: ARRAY
110015: PUSH
110016: LD_INT 2
110018: ARRAY
110019: PPUSH
110020: CALL_OW 458
110024: AND
110025: IFFALSE 110119
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110027: LD_EXP 144
110031: PUSH
110032: LD_VAR 0 1
110036: ARRAY
110037: PUSH
110038: LD_VAR 0 2
110042: ARRAY
110043: PUSH
110044: LD_INT 1
110046: ARRAY
110047: PPUSH
110048: LD_EXP 144
110052: PUSH
110053: LD_VAR 0 1
110057: ARRAY
110058: PUSH
110059: LD_VAR 0 2
110063: ARRAY
110064: PUSH
110065: LD_INT 2
110067: ARRAY
110068: PPUSH
110069: LD_VAR 0 3
110073: PPUSH
110074: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110078: LD_ADDR_EXP 144
110082: PUSH
110083: LD_EXP 144
110087: PPUSH
110088: LD_VAR 0 1
110092: PPUSH
110093: LD_EXP 144
110097: PUSH
110098: LD_VAR 0 1
110102: ARRAY
110103: PPUSH
110104: LD_VAR 0 2
110108: PPUSH
110109: CALL_OW 3
110113: PPUSH
110114: CALL_OW 1
110118: ST_TO_ADDR
// end ; end ;
110119: GO 109870
110121: POP
110122: POP
// end ;
110123: GO 109788
110125: POP
110126: POP
// end ;
110127: PPOPN 4
110129: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110130: LD_INT 0
110132: PPUSH
110133: PPUSH
// result := false ;
110134: LD_ADDR_VAR 0 4
110138: PUSH
110139: LD_INT 0
110141: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110142: LD_VAR 0 1
110146: PPUSH
110147: CALL_OW 264
110151: PUSH
110152: LD_INT 81
110154: EQUAL
110155: NOT
110156: IFFALSE 110160
// exit ;
110158: GO 110400
// index := GetElementIndex ( minersList , unit ) ;
110160: LD_ADDR_VAR 0 5
110164: PUSH
110165: LD_EXP 143
110169: PPUSH
110170: LD_VAR 0 1
110174: PPUSH
110175: CALL 24806 0 2
110179: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110180: LD_EXP 144
110184: PUSH
110185: LD_VAR 0 5
110189: ARRAY
110190: PUSH
110191: LD_EXP 145
110195: GREATEREQUAL
110196: IFFALSE 110200
// exit ;
110198: GO 110400
// ComMoveXY ( unit , x , y ) ;
110200: LD_VAR 0 1
110204: PPUSH
110205: LD_VAR 0 2
110209: PPUSH
110210: LD_VAR 0 3
110214: PPUSH
110215: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110219: LD_INT 35
110221: PPUSH
110222: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110226: LD_VAR 0 1
110230: PPUSH
110231: LD_VAR 0 2
110235: PPUSH
110236: LD_VAR 0 3
110240: PPUSH
110241: CALL 56069 0 3
110245: NOT
110246: PUSH
110247: LD_VAR 0 1
110251: PPUSH
110252: CALL_OW 314
110256: AND
110257: IFFALSE 110261
// exit ;
110259: GO 110400
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110261: LD_VAR 0 2
110265: PPUSH
110266: LD_VAR 0 3
110270: PPUSH
110271: CALL_OW 428
110275: PUSH
110276: LD_VAR 0 1
110280: EQUAL
110281: PUSH
110282: LD_VAR 0 1
110286: PPUSH
110287: CALL_OW 314
110291: NOT
110292: AND
110293: IFFALSE 110219
// PlaySoundXY ( x , y , PlantMine ) ;
110295: LD_VAR 0 2
110299: PPUSH
110300: LD_VAR 0 3
110304: PPUSH
110305: LD_STRING PlantMine
110307: PPUSH
110308: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110312: LD_VAR 0 2
110316: PPUSH
110317: LD_VAR 0 3
110321: PPUSH
110322: LD_VAR 0 1
110326: PPUSH
110327: CALL_OW 255
110331: PPUSH
110332: LD_INT 0
110334: PPUSH
110335: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110339: LD_ADDR_EXP 144
110343: PUSH
110344: LD_EXP 144
110348: PPUSH
110349: LD_VAR 0 5
110353: PUSH
110354: LD_EXP 144
110358: PUSH
110359: LD_VAR 0 5
110363: ARRAY
110364: PUSH
110365: LD_INT 1
110367: PLUS
110368: PUSH
110369: EMPTY
110370: LIST
110371: LIST
110372: PPUSH
110373: LD_VAR 0 2
110377: PUSH
110378: LD_VAR 0 3
110382: PUSH
110383: EMPTY
110384: LIST
110385: LIST
110386: PPUSH
110387: CALL 25021 0 3
110391: ST_TO_ADDR
// result := true ;
110392: LD_ADDR_VAR 0 4
110396: PUSH
110397: LD_INT 1
110399: ST_TO_ADDR
// end ;
110400: LD_VAR 0 4
110404: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110405: LD_INT 0
110407: PPUSH
110408: PPUSH
110409: PPUSH
// if not unit in minersList then
110410: LD_VAR 0 1
110414: PUSH
110415: LD_EXP 143
110419: IN
110420: NOT
110421: IFFALSE 110425
// exit ;
110423: GO 110817
// index := GetElementIndex ( minersList , unit ) ;
110425: LD_ADDR_VAR 0 6
110429: PUSH
110430: LD_EXP 143
110434: PPUSH
110435: LD_VAR 0 1
110439: PPUSH
110440: CALL 24806 0 2
110444: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110445: LD_ADDR_VAR 0 5
110449: PUSH
110450: DOUBLE
110451: LD_EXP 144
110455: PUSH
110456: LD_VAR 0 6
110460: ARRAY
110461: INC
110462: ST_TO_ADDR
110463: LD_INT 1
110465: PUSH
110466: FOR_DOWNTO
110467: IFFALSE 110628
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110469: LD_EXP 144
110473: PUSH
110474: LD_VAR 0 6
110478: ARRAY
110479: PUSH
110480: LD_VAR 0 5
110484: ARRAY
110485: PUSH
110486: LD_INT 1
110488: ARRAY
110489: PUSH
110490: LD_VAR 0 2
110494: EQUAL
110495: PUSH
110496: LD_EXP 144
110500: PUSH
110501: LD_VAR 0 6
110505: ARRAY
110506: PUSH
110507: LD_VAR 0 5
110511: ARRAY
110512: PUSH
110513: LD_INT 2
110515: ARRAY
110516: PUSH
110517: LD_VAR 0 3
110521: EQUAL
110522: AND
110523: IFFALSE 110626
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110525: LD_EXP 144
110529: PUSH
110530: LD_VAR 0 6
110534: ARRAY
110535: PUSH
110536: LD_VAR 0 5
110540: ARRAY
110541: PUSH
110542: LD_INT 1
110544: ARRAY
110545: PPUSH
110546: LD_EXP 144
110550: PUSH
110551: LD_VAR 0 6
110555: ARRAY
110556: PUSH
110557: LD_VAR 0 5
110561: ARRAY
110562: PUSH
110563: LD_INT 2
110565: ARRAY
110566: PPUSH
110567: LD_VAR 0 1
110571: PPUSH
110572: CALL_OW 255
110576: PPUSH
110577: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110581: LD_ADDR_EXP 144
110585: PUSH
110586: LD_EXP 144
110590: PPUSH
110591: LD_VAR 0 6
110595: PPUSH
110596: LD_EXP 144
110600: PUSH
110601: LD_VAR 0 6
110605: ARRAY
110606: PPUSH
110607: LD_VAR 0 5
110611: PPUSH
110612: CALL_OW 3
110616: PPUSH
110617: CALL_OW 1
110621: ST_TO_ADDR
// exit ;
110622: POP
110623: POP
110624: GO 110817
// end ; end ;
110626: GO 110466
110628: POP
110629: POP
// for i := minerMinesList [ index ] downto 1 do
110630: LD_ADDR_VAR 0 5
110634: PUSH
110635: DOUBLE
110636: LD_EXP 144
110640: PUSH
110641: LD_VAR 0 6
110645: ARRAY
110646: INC
110647: ST_TO_ADDR
110648: LD_INT 1
110650: PUSH
110651: FOR_DOWNTO
110652: IFFALSE 110815
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110654: LD_EXP 144
110658: PUSH
110659: LD_VAR 0 6
110663: ARRAY
110664: PUSH
110665: LD_VAR 0 5
110669: ARRAY
110670: PUSH
110671: LD_INT 1
110673: ARRAY
110674: PPUSH
110675: LD_EXP 144
110679: PUSH
110680: LD_VAR 0 6
110684: ARRAY
110685: PUSH
110686: LD_VAR 0 5
110690: ARRAY
110691: PUSH
110692: LD_INT 2
110694: ARRAY
110695: PPUSH
110696: LD_VAR 0 2
110700: PPUSH
110701: LD_VAR 0 3
110705: PPUSH
110706: CALL_OW 298
110710: PUSH
110711: LD_INT 6
110713: LESS
110714: IFFALSE 110813
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110716: LD_EXP 144
110720: PUSH
110721: LD_VAR 0 6
110725: ARRAY
110726: PUSH
110727: LD_VAR 0 5
110731: ARRAY
110732: PUSH
110733: LD_INT 1
110735: ARRAY
110736: PPUSH
110737: LD_EXP 144
110741: PUSH
110742: LD_VAR 0 6
110746: ARRAY
110747: PUSH
110748: LD_VAR 0 5
110752: ARRAY
110753: PUSH
110754: LD_INT 2
110756: ARRAY
110757: PPUSH
110758: LD_VAR 0 1
110762: PPUSH
110763: CALL_OW 255
110767: PPUSH
110768: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110772: LD_ADDR_EXP 144
110776: PUSH
110777: LD_EXP 144
110781: PPUSH
110782: LD_VAR 0 6
110786: PPUSH
110787: LD_EXP 144
110791: PUSH
110792: LD_VAR 0 6
110796: ARRAY
110797: PPUSH
110798: LD_VAR 0 5
110802: PPUSH
110803: CALL_OW 3
110807: PPUSH
110808: CALL_OW 1
110812: ST_TO_ADDR
// end ; end ;
110813: GO 110651
110815: POP
110816: POP
// end ;
110817: LD_VAR 0 4
110821: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
110822: LD_INT 0
110824: PPUSH
110825: PPUSH
110826: PPUSH
110827: PPUSH
110828: PPUSH
110829: PPUSH
110830: PPUSH
110831: PPUSH
110832: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
110833: LD_VAR 0 1
110837: PPUSH
110838: CALL_OW 264
110842: PUSH
110843: LD_INT 81
110845: EQUAL
110846: NOT
110847: PUSH
110848: LD_VAR 0 1
110852: PUSH
110853: LD_EXP 143
110857: IN
110858: NOT
110859: OR
110860: IFFALSE 110864
// exit ;
110862: GO 111186
// index := GetElementIndex ( minersList , unit ) ;
110864: LD_ADDR_VAR 0 6
110868: PUSH
110869: LD_EXP 143
110873: PPUSH
110874: LD_VAR 0 1
110878: PPUSH
110879: CALL 24806 0 2
110883: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110884: LD_ADDR_VAR 0 8
110888: PUSH
110889: LD_EXP 145
110893: PUSH
110894: LD_EXP 144
110898: PUSH
110899: LD_VAR 0 6
110903: ARRAY
110904: MINUS
110905: ST_TO_ADDR
// if not minesFreeAmount then
110906: LD_VAR 0 8
110910: NOT
110911: IFFALSE 110915
// exit ;
110913: GO 111186
// tmp := [ ] ;
110915: LD_ADDR_VAR 0 7
110919: PUSH
110920: EMPTY
110921: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110922: LD_ADDR_VAR 0 5
110926: PUSH
110927: DOUBLE
110928: LD_INT 1
110930: DEC
110931: ST_TO_ADDR
110932: LD_VAR 0 8
110936: PUSH
110937: FOR_TO
110938: IFFALSE 111133
// begin _d := rand ( 0 , 5 ) ;
110940: LD_ADDR_VAR 0 11
110944: PUSH
110945: LD_INT 0
110947: PPUSH
110948: LD_INT 5
110950: PPUSH
110951: CALL_OW 12
110955: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110956: LD_ADDR_VAR 0 12
110960: PUSH
110961: LD_INT 2
110963: PPUSH
110964: LD_INT 6
110966: PPUSH
110967: CALL_OW 12
110971: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110972: LD_ADDR_VAR 0 9
110976: PUSH
110977: LD_VAR 0 2
110981: PPUSH
110982: LD_VAR 0 11
110986: PPUSH
110987: LD_VAR 0 12
110991: PPUSH
110992: CALL_OW 272
110996: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110997: LD_ADDR_VAR 0 10
111001: PUSH
111002: LD_VAR 0 3
111006: PPUSH
111007: LD_VAR 0 11
111011: PPUSH
111012: LD_VAR 0 12
111016: PPUSH
111017: CALL_OW 273
111021: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111022: LD_VAR 0 9
111026: PPUSH
111027: LD_VAR 0 10
111031: PPUSH
111032: CALL_OW 488
111036: PUSH
111037: LD_VAR 0 9
111041: PUSH
111042: LD_VAR 0 10
111046: PUSH
111047: EMPTY
111048: LIST
111049: LIST
111050: PUSH
111051: LD_VAR 0 7
111055: IN
111056: NOT
111057: AND
111058: PUSH
111059: LD_VAR 0 9
111063: PPUSH
111064: LD_VAR 0 10
111068: PPUSH
111069: CALL_OW 458
111073: NOT
111074: AND
111075: IFFALSE 111117
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111077: LD_ADDR_VAR 0 7
111081: PUSH
111082: LD_VAR 0 7
111086: PPUSH
111087: LD_VAR 0 7
111091: PUSH
111092: LD_INT 1
111094: PLUS
111095: PPUSH
111096: LD_VAR 0 9
111100: PUSH
111101: LD_VAR 0 10
111105: PUSH
111106: EMPTY
111107: LIST
111108: LIST
111109: PPUSH
111110: CALL_OW 1
111114: ST_TO_ADDR
111115: GO 111131
// i := i - 1 ;
111117: LD_ADDR_VAR 0 5
111121: PUSH
111122: LD_VAR 0 5
111126: PUSH
111127: LD_INT 1
111129: MINUS
111130: ST_TO_ADDR
// end ;
111131: GO 110937
111133: POP
111134: POP
// for i in tmp do
111135: LD_ADDR_VAR 0 5
111139: PUSH
111140: LD_VAR 0 7
111144: PUSH
111145: FOR_IN
111146: IFFALSE 111184
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111148: LD_VAR 0 1
111152: PPUSH
111153: LD_VAR 0 5
111157: PUSH
111158: LD_INT 1
111160: ARRAY
111161: PPUSH
111162: LD_VAR 0 5
111166: PUSH
111167: LD_INT 2
111169: ARRAY
111170: PPUSH
111171: CALL 110130 0 3
111175: NOT
111176: IFFALSE 111182
// exit ;
111178: POP
111179: POP
111180: GO 111186
111182: GO 111145
111184: POP
111185: POP
// end ;
111186: LD_VAR 0 4
111190: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111191: LD_INT 0
111193: PPUSH
111194: PPUSH
111195: PPUSH
111196: PPUSH
111197: PPUSH
111198: PPUSH
111199: PPUSH
// if not GetClass ( unit ) = class_sniper then
111200: LD_VAR 0 1
111204: PPUSH
111205: CALL_OW 257
111209: PUSH
111210: LD_INT 5
111212: EQUAL
111213: NOT
111214: IFFALSE 111218
// exit ;
111216: GO 111606
// dist := 8 ;
111218: LD_ADDR_VAR 0 5
111222: PUSH
111223: LD_INT 8
111225: ST_TO_ADDR
// viewRange := 12 ;
111226: LD_ADDR_VAR 0 7
111230: PUSH
111231: LD_INT 12
111233: ST_TO_ADDR
// side := GetSide ( unit ) ;
111234: LD_ADDR_VAR 0 6
111238: PUSH
111239: LD_VAR 0 1
111243: PPUSH
111244: CALL_OW 255
111248: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111249: LD_INT 61
111251: PPUSH
111252: LD_VAR 0 6
111256: PPUSH
111257: CALL_OW 321
111261: PUSH
111262: LD_INT 2
111264: EQUAL
111265: IFFALSE 111275
// viewRange := 16 ;
111267: LD_ADDR_VAR 0 7
111271: PUSH
111272: LD_INT 16
111274: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111275: LD_VAR 0 1
111279: PPUSH
111280: LD_VAR 0 2
111284: PPUSH
111285: LD_VAR 0 3
111289: PPUSH
111290: CALL_OW 297
111294: PUSH
111295: LD_VAR 0 5
111299: GREATER
111300: IFFALSE 111379
// begin ComMoveXY ( unit , x , y ) ;
111302: LD_VAR 0 1
111306: PPUSH
111307: LD_VAR 0 2
111311: PPUSH
111312: LD_VAR 0 3
111316: PPUSH
111317: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111321: LD_INT 35
111323: PPUSH
111324: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111328: LD_VAR 0 1
111332: PPUSH
111333: LD_VAR 0 2
111337: PPUSH
111338: LD_VAR 0 3
111342: PPUSH
111343: CALL 56069 0 3
111347: NOT
111348: IFFALSE 111352
// exit ;
111350: GO 111606
// until GetDistUnitXY ( unit , x , y ) < dist ;
111352: LD_VAR 0 1
111356: PPUSH
111357: LD_VAR 0 2
111361: PPUSH
111362: LD_VAR 0 3
111366: PPUSH
111367: CALL_OW 297
111371: PUSH
111372: LD_VAR 0 5
111376: LESS
111377: IFFALSE 111321
// end ; ComTurnXY ( unit , x , y ) ;
111379: LD_VAR 0 1
111383: PPUSH
111384: LD_VAR 0 2
111388: PPUSH
111389: LD_VAR 0 3
111393: PPUSH
111394: CALL_OW 118
// wait ( 5 ) ;
111398: LD_INT 5
111400: PPUSH
111401: CALL_OW 67
// _d := GetDir ( unit ) ;
111405: LD_ADDR_VAR 0 10
111409: PUSH
111410: LD_VAR 0 1
111414: PPUSH
111415: CALL_OW 254
111419: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111420: LD_ADDR_VAR 0 8
111424: PUSH
111425: LD_VAR 0 1
111429: PPUSH
111430: CALL_OW 250
111434: PPUSH
111435: LD_VAR 0 10
111439: PPUSH
111440: LD_VAR 0 5
111444: PPUSH
111445: CALL_OW 272
111449: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111450: LD_ADDR_VAR 0 9
111454: PUSH
111455: LD_VAR 0 1
111459: PPUSH
111460: CALL_OW 251
111464: PPUSH
111465: LD_VAR 0 10
111469: PPUSH
111470: LD_VAR 0 5
111474: PPUSH
111475: CALL_OW 273
111479: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111480: LD_VAR 0 8
111484: PPUSH
111485: LD_VAR 0 9
111489: PPUSH
111490: CALL_OW 488
111494: NOT
111495: IFFALSE 111499
// exit ;
111497: GO 111606
// ComAnimCustom ( unit , 1 ) ;
111499: LD_VAR 0 1
111503: PPUSH
111504: LD_INT 1
111506: PPUSH
111507: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111511: LD_VAR 0 8
111515: PPUSH
111516: LD_VAR 0 9
111520: PPUSH
111521: LD_VAR 0 6
111525: PPUSH
111526: LD_VAR 0 7
111530: PPUSH
111531: CALL_OW 330
// repeat wait ( 1 ) ;
111535: LD_INT 1
111537: PPUSH
111538: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111542: LD_VAR 0 1
111546: PPUSH
111547: CALL_OW 316
111551: PUSH
111552: LD_VAR 0 1
111556: PPUSH
111557: CALL_OW 314
111561: OR
111562: PUSH
111563: LD_VAR 0 1
111567: PPUSH
111568: CALL_OW 302
111572: NOT
111573: OR
111574: PUSH
111575: LD_VAR 0 1
111579: PPUSH
111580: CALL_OW 301
111584: OR
111585: IFFALSE 111535
// RemoveSeeing ( _x , _y , side ) ;
111587: LD_VAR 0 8
111591: PPUSH
111592: LD_VAR 0 9
111596: PPUSH
111597: LD_VAR 0 6
111601: PPUSH
111602: CALL_OW 331
// end ; end_of_file
111606: LD_VAR 0 4
111610: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111611: LD_INT 0
111613: PPUSH
111614: PPUSH
111615: PPUSH
111616: PPUSH
111617: PPUSH
111618: PPUSH
111619: PPUSH
111620: PPUSH
111621: PPUSH
111622: PPUSH
111623: PPUSH
111624: PPUSH
111625: PPUSH
111626: PPUSH
111627: PPUSH
111628: PPUSH
111629: PPUSH
111630: PPUSH
111631: PPUSH
111632: PPUSH
111633: PPUSH
111634: PPUSH
111635: PPUSH
111636: PPUSH
111637: PPUSH
111638: PPUSH
111639: PPUSH
111640: PPUSH
111641: PPUSH
111642: PPUSH
111643: PPUSH
111644: PPUSH
111645: PPUSH
111646: PPUSH
// if not list then
111647: LD_VAR 0 1
111651: NOT
111652: IFFALSE 111656
// exit ;
111654: GO 116315
// base := list [ 1 ] ;
111656: LD_ADDR_VAR 0 3
111660: PUSH
111661: LD_VAR 0 1
111665: PUSH
111666: LD_INT 1
111668: ARRAY
111669: ST_TO_ADDR
// group := list [ 2 ] ;
111670: LD_ADDR_VAR 0 4
111674: PUSH
111675: LD_VAR 0 1
111679: PUSH
111680: LD_INT 2
111682: ARRAY
111683: ST_TO_ADDR
// path := list [ 3 ] ;
111684: LD_ADDR_VAR 0 5
111688: PUSH
111689: LD_VAR 0 1
111693: PUSH
111694: LD_INT 3
111696: ARRAY
111697: ST_TO_ADDR
// flags := list [ 4 ] ;
111698: LD_ADDR_VAR 0 6
111702: PUSH
111703: LD_VAR 0 1
111707: PUSH
111708: LD_INT 4
111710: ARRAY
111711: ST_TO_ADDR
// mined := [ ] ;
111712: LD_ADDR_VAR 0 27
111716: PUSH
111717: EMPTY
111718: ST_TO_ADDR
// bombed := [ ] ;
111719: LD_ADDR_VAR 0 28
111723: PUSH
111724: EMPTY
111725: ST_TO_ADDR
// healers := [ ] ;
111726: LD_ADDR_VAR 0 31
111730: PUSH
111731: EMPTY
111732: ST_TO_ADDR
// to_heal := [ ] ;
111733: LD_ADDR_VAR 0 30
111737: PUSH
111738: EMPTY
111739: ST_TO_ADDR
// repairs := [ ] ;
111740: LD_ADDR_VAR 0 33
111744: PUSH
111745: EMPTY
111746: ST_TO_ADDR
// to_repair := [ ] ;
111747: LD_ADDR_VAR 0 32
111751: PUSH
111752: EMPTY
111753: ST_TO_ADDR
// if not group or not path then
111754: LD_VAR 0 4
111758: NOT
111759: PUSH
111760: LD_VAR 0 5
111764: NOT
111765: OR
111766: IFFALSE 111770
// exit ;
111768: GO 116315
// side := GetSide ( group [ 1 ] ) ;
111770: LD_ADDR_VAR 0 35
111774: PUSH
111775: LD_VAR 0 4
111779: PUSH
111780: LD_INT 1
111782: ARRAY
111783: PPUSH
111784: CALL_OW 255
111788: ST_TO_ADDR
// if flags then
111789: LD_VAR 0 6
111793: IFFALSE 111937
// begin f_ignore_area := flags [ 1 ] ;
111795: LD_ADDR_VAR 0 17
111799: PUSH
111800: LD_VAR 0 6
111804: PUSH
111805: LD_INT 1
111807: ARRAY
111808: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111809: LD_ADDR_VAR 0 18
111813: PUSH
111814: LD_VAR 0 6
111818: PUSH
111819: LD_INT 2
111821: ARRAY
111822: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
111823: LD_ADDR_VAR 0 19
111827: PUSH
111828: LD_VAR 0 6
111832: PUSH
111833: LD_INT 3
111835: ARRAY
111836: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
111837: LD_ADDR_VAR 0 20
111841: PUSH
111842: LD_VAR 0 6
111846: PUSH
111847: LD_INT 4
111849: ARRAY
111850: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
111851: LD_ADDR_VAR 0 21
111855: PUSH
111856: LD_VAR 0 6
111860: PUSH
111861: LD_INT 5
111863: ARRAY
111864: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
111865: LD_ADDR_VAR 0 22
111869: PUSH
111870: LD_VAR 0 6
111874: PUSH
111875: LD_INT 6
111877: ARRAY
111878: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111879: LD_ADDR_VAR 0 23
111883: PUSH
111884: LD_VAR 0 6
111888: PUSH
111889: LD_INT 7
111891: ARRAY
111892: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111893: LD_ADDR_VAR 0 24
111897: PUSH
111898: LD_VAR 0 6
111902: PUSH
111903: LD_INT 8
111905: ARRAY
111906: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111907: LD_ADDR_VAR 0 25
111911: PUSH
111912: LD_VAR 0 6
111916: PUSH
111917: LD_INT 9
111919: ARRAY
111920: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111921: LD_ADDR_VAR 0 26
111925: PUSH
111926: LD_VAR 0 6
111930: PUSH
111931: LD_INT 10
111933: ARRAY
111934: ST_TO_ADDR
// end else
111935: GO 112017
// begin f_ignore_area := false ;
111937: LD_ADDR_VAR 0 17
111941: PUSH
111942: LD_INT 0
111944: ST_TO_ADDR
// f_capture := false ;
111945: LD_ADDR_VAR 0 18
111949: PUSH
111950: LD_INT 0
111952: ST_TO_ADDR
// f_ignore_civ := false ;
111953: LD_ADDR_VAR 0 19
111957: PUSH
111958: LD_INT 0
111960: ST_TO_ADDR
// f_murder := false ;
111961: LD_ADDR_VAR 0 20
111965: PUSH
111966: LD_INT 0
111968: ST_TO_ADDR
// f_mines := false ;
111969: LD_ADDR_VAR 0 21
111973: PUSH
111974: LD_INT 0
111976: ST_TO_ADDR
// f_repair := false ;
111977: LD_ADDR_VAR 0 22
111981: PUSH
111982: LD_INT 0
111984: ST_TO_ADDR
// f_heal := false ;
111985: LD_ADDR_VAR 0 23
111989: PUSH
111990: LD_INT 0
111992: ST_TO_ADDR
// f_spacetime := false ;
111993: LD_ADDR_VAR 0 24
111997: PUSH
111998: LD_INT 0
112000: ST_TO_ADDR
// f_attack_depot := false ;
112001: LD_ADDR_VAR 0 25
112005: PUSH
112006: LD_INT 0
112008: ST_TO_ADDR
// f_crawl := false ;
112009: LD_ADDR_VAR 0 26
112013: PUSH
112014: LD_INT 0
112016: ST_TO_ADDR
// end ; if f_heal then
112017: LD_VAR 0 23
112021: IFFALSE 112048
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112023: LD_ADDR_VAR 0 31
112027: PUSH
112028: LD_VAR 0 4
112032: PPUSH
112033: LD_INT 25
112035: PUSH
112036: LD_INT 4
112038: PUSH
112039: EMPTY
112040: LIST
112041: LIST
112042: PPUSH
112043: CALL_OW 72
112047: ST_TO_ADDR
// if f_repair then
112048: LD_VAR 0 22
112052: IFFALSE 112079
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112054: LD_ADDR_VAR 0 33
112058: PUSH
112059: LD_VAR 0 4
112063: PPUSH
112064: LD_INT 25
112066: PUSH
112067: LD_INT 3
112069: PUSH
112070: EMPTY
112071: LIST
112072: LIST
112073: PPUSH
112074: CALL_OW 72
112078: ST_TO_ADDR
// units_path := [ ] ;
112079: LD_ADDR_VAR 0 16
112083: PUSH
112084: EMPTY
112085: ST_TO_ADDR
// for i = 1 to group do
112086: LD_ADDR_VAR 0 7
112090: PUSH
112091: DOUBLE
112092: LD_INT 1
112094: DEC
112095: ST_TO_ADDR
112096: LD_VAR 0 4
112100: PUSH
112101: FOR_TO
112102: IFFALSE 112131
// units_path := Replace ( units_path , i , path ) ;
112104: LD_ADDR_VAR 0 16
112108: PUSH
112109: LD_VAR 0 16
112113: PPUSH
112114: LD_VAR 0 7
112118: PPUSH
112119: LD_VAR 0 5
112123: PPUSH
112124: CALL_OW 1
112128: ST_TO_ADDR
112129: GO 112101
112131: POP
112132: POP
// repeat for i = group downto 1 do
112133: LD_ADDR_VAR 0 7
112137: PUSH
112138: DOUBLE
112139: LD_VAR 0 4
112143: INC
112144: ST_TO_ADDR
112145: LD_INT 1
112147: PUSH
112148: FOR_DOWNTO
112149: IFFALSE 116271
// begin wait ( 5 ) ;
112151: LD_INT 5
112153: PPUSH
112154: CALL_OW 67
// tmp := [ ] ;
112158: LD_ADDR_VAR 0 14
112162: PUSH
112163: EMPTY
112164: ST_TO_ADDR
// attacking := false ;
112165: LD_ADDR_VAR 0 29
112169: PUSH
112170: LD_INT 0
112172: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112173: LD_VAR 0 4
112177: PUSH
112178: LD_VAR 0 7
112182: ARRAY
112183: PPUSH
112184: CALL_OW 301
112188: PUSH
112189: LD_VAR 0 4
112193: PUSH
112194: LD_VAR 0 7
112198: ARRAY
112199: NOT
112200: OR
112201: IFFALSE 112310
// begin if GetType ( group [ i ] ) = unit_human then
112203: LD_VAR 0 4
112207: PUSH
112208: LD_VAR 0 7
112212: ARRAY
112213: PPUSH
112214: CALL_OW 247
112218: PUSH
112219: LD_INT 1
112221: EQUAL
112222: IFFALSE 112268
// begin to_heal := to_heal diff group [ i ] ;
112224: LD_ADDR_VAR 0 30
112228: PUSH
112229: LD_VAR 0 30
112233: PUSH
112234: LD_VAR 0 4
112238: PUSH
112239: LD_VAR 0 7
112243: ARRAY
112244: DIFF
112245: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112246: LD_ADDR_VAR 0 31
112250: PUSH
112251: LD_VAR 0 31
112255: PUSH
112256: LD_VAR 0 4
112260: PUSH
112261: LD_VAR 0 7
112265: ARRAY
112266: DIFF
112267: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112268: LD_ADDR_VAR 0 4
112272: PUSH
112273: LD_VAR 0 4
112277: PPUSH
112278: LD_VAR 0 7
112282: PPUSH
112283: CALL_OW 3
112287: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112288: LD_ADDR_VAR 0 16
112292: PUSH
112293: LD_VAR 0 16
112297: PPUSH
112298: LD_VAR 0 7
112302: PPUSH
112303: CALL_OW 3
112307: ST_TO_ADDR
// continue ;
112308: GO 112148
// end ; if f_repair then
112310: LD_VAR 0 22
112314: IFFALSE 112803
// begin if GetType ( group [ i ] ) = unit_vehicle then
112316: LD_VAR 0 4
112320: PUSH
112321: LD_VAR 0 7
112325: ARRAY
112326: PPUSH
112327: CALL_OW 247
112331: PUSH
112332: LD_INT 2
112334: EQUAL
112335: IFFALSE 112525
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112337: LD_VAR 0 4
112341: PUSH
112342: LD_VAR 0 7
112346: ARRAY
112347: PPUSH
112348: CALL_OW 256
112352: PUSH
112353: LD_INT 700
112355: LESS
112356: PUSH
112357: LD_VAR 0 4
112361: PUSH
112362: LD_VAR 0 7
112366: ARRAY
112367: PUSH
112368: LD_VAR 0 32
112372: IN
112373: NOT
112374: AND
112375: IFFALSE 112399
// to_repair := to_repair union group [ i ] ;
112377: LD_ADDR_VAR 0 32
112381: PUSH
112382: LD_VAR 0 32
112386: PUSH
112387: LD_VAR 0 4
112391: PUSH
112392: LD_VAR 0 7
112396: ARRAY
112397: UNION
112398: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112399: LD_VAR 0 4
112403: PUSH
112404: LD_VAR 0 7
112408: ARRAY
112409: PPUSH
112410: CALL_OW 256
112414: PUSH
112415: LD_INT 1000
112417: EQUAL
112418: PUSH
112419: LD_VAR 0 4
112423: PUSH
112424: LD_VAR 0 7
112428: ARRAY
112429: PUSH
112430: LD_VAR 0 32
112434: IN
112435: AND
112436: IFFALSE 112460
// to_repair := to_repair diff group [ i ] ;
112438: LD_ADDR_VAR 0 32
112442: PUSH
112443: LD_VAR 0 32
112447: PUSH
112448: LD_VAR 0 4
112452: PUSH
112453: LD_VAR 0 7
112457: ARRAY
112458: DIFF
112459: ST_TO_ADDR
// if group [ i ] in to_repair then
112460: LD_VAR 0 4
112464: PUSH
112465: LD_VAR 0 7
112469: ARRAY
112470: PUSH
112471: LD_VAR 0 32
112475: IN
112476: IFFALSE 112523
// begin if not IsInArea ( group [ i ] , f_repair ) then
112478: LD_VAR 0 4
112482: PUSH
112483: LD_VAR 0 7
112487: ARRAY
112488: PPUSH
112489: LD_VAR 0 22
112493: PPUSH
112494: CALL_OW 308
112498: NOT
112499: IFFALSE 112521
// ComMoveToArea ( group [ i ] , f_repair ) ;
112501: LD_VAR 0 4
112505: PUSH
112506: LD_VAR 0 7
112510: ARRAY
112511: PPUSH
112512: LD_VAR 0 22
112516: PPUSH
112517: CALL_OW 113
// continue ;
112521: GO 112148
// end ; end else
112523: GO 112803
// if group [ i ] in repairs then
112525: LD_VAR 0 4
112529: PUSH
112530: LD_VAR 0 7
112534: ARRAY
112535: PUSH
112536: LD_VAR 0 33
112540: IN
112541: IFFALSE 112803
// begin if IsInUnit ( group [ i ] ) then
112543: LD_VAR 0 4
112547: PUSH
112548: LD_VAR 0 7
112552: ARRAY
112553: PPUSH
112554: CALL_OW 310
112558: IFFALSE 112626
// begin z := IsInUnit ( group [ i ] ) ;
112560: LD_ADDR_VAR 0 13
112564: PUSH
112565: LD_VAR 0 4
112569: PUSH
112570: LD_VAR 0 7
112574: ARRAY
112575: PPUSH
112576: CALL_OW 310
112580: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112581: LD_VAR 0 13
112585: PUSH
112586: LD_VAR 0 32
112590: IN
112591: PUSH
112592: LD_VAR 0 13
112596: PPUSH
112597: LD_VAR 0 22
112601: PPUSH
112602: CALL_OW 308
112606: AND
112607: IFFALSE 112624
// ComExitVehicle ( group [ i ] ) ;
112609: LD_VAR 0 4
112613: PUSH
112614: LD_VAR 0 7
112618: ARRAY
112619: PPUSH
112620: CALL_OW 121
// end else
112624: GO 112803
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112626: LD_ADDR_VAR 0 13
112630: PUSH
112631: LD_VAR 0 4
112635: PPUSH
112636: LD_INT 95
112638: PUSH
112639: LD_VAR 0 22
112643: PUSH
112644: EMPTY
112645: LIST
112646: LIST
112647: PUSH
112648: LD_INT 58
112650: PUSH
112651: EMPTY
112652: LIST
112653: PUSH
112654: EMPTY
112655: LIST
112656: LIST
112657: PPUSH
112658: CALL_OW 72
112662: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112663: LD_VAR 0 4
112667: PUSH
112668: LD_VAR 0 7
112672: ARRAY
112673: PPUSH
112674: CALL_OW 314
112678: NOT
112679: IFFALSE 112801
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112681: LD_ADDR_VAR 0 10
112685: PUSH
112686: LD_VAR 0 13
112690: PPUSH
112691: LD_VAR 0 4
112695: PUSH
112696: LD_VAR 0 7
112700: ARRAY
112701: PPUSH
112702: CALL_OW 74
112706: ST_TO_ADDR
// if not x then
112707: LD_VAR 0 10
112711: NOT
112712: IFFALSE 112716
// continue ;
112714: GO 112148
// if GetLives ( x ) < 1000 then
112716: LD_VAR 0 10
112720: PPUSH
112721: CALL_OW 256
112725: PUSH
112726: LD_INT 1000
112728: LESS
112729: IFFALSE 112753
// ComRepairVehicle ( group [ i ] , x ) else
112731: LD_VAR 0 4
112735: PUSH
112736: LD_VAR 0 7
112740: ARRAY
112741: PPUSH
112742: LD_VAR 0 10
112746: PPUSH
112747: CALL_OW 129
112751: GO 112801
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112753: LD_VAR 0 23
112757: PUSH
112758: LD_VAR 0 4
112762: PUSH
112763: LD_VAR 0 7
112767: ARRAY
112768: PPUSH
112769: CALL_OW 256
112773: PUSH
112774: LD_INT 1000
112776: LESS
112777: AND
112778: NOT
112779: IFFALSE 112801
// ComEnterUnit ( group [ i ] , x ) ;
112781: LD_VAR 0 4
112785: PUSH
112786: LD_VAR 0 7
112790: ARRAY
112791: PPUSH
112792: LD_VAR 0 10
112796: PPUSH
112797: CALL_OW 120
// end ; continue ;
112801: GO 112148
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112803: LD_VAR 0 23
112807: PUSH
112808: LD_VAR 0 4
112812: PUSH
112813: LD_VAR 0 7
112817: ARRAY
112818: PPUSH
112819: CALL_OW 247
112823: PUSH
112824: LD_INT 1
112826: EQUAL
112827: AND
112828: IFFALSE 113306
// begin if group [ i ] in healers then
112830: LD_VAR 0 4
112834: PUSH
112835: LD_VAR 0 7
112839: ARRAY
112840: PUSH
112841: LD_VAR 0 31
112845: IN
112846: IFFALSE 113119
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
112848: LD_VAR 0 4
112852: PUSH
112853: LD_VAR 0 7
112857: ARRAY
112858: PPUSH
112859: LD_VAR 0 23
112863: PPUSH
112864: CALL_OW 308
112868: NOT
112869: PUSH
112870: LD_VAR 0 4
112874: PUSH
112875: LD_VAR 0 7
112879: ARRAY
112880: PPUSH
112881: CALL_OW 314
112885: NOT
112886: AND
112887: IFFALSE 112911
// ComMoveToArea ( group [ i ] , f_heal ) else
112889: LD_VAR 0 4
112893: PUSH
112894: LD_VAR 0 7
112898: ARRAY
112899: PPUSH
112900: LD_VAR 0 23
112904: PPUSH
112905: CALL_OW 113
112909: GO 113117
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112911: LD_VAR 0 4
112915: PUSH
112916: LD_VAR 0 7
112920: ARRAY
112921: PPUSH
112922: CALL 54645 0 1
112926: PPUSH
112927: CALL_OW 256
112931: PUSH
112932: LD_INT 1000
112934: EQUAL
112935: IFFALSE 112954
// ComStop ( group [ i ] ) else
112937: LD_VAR 0 4
112941: PUSH
112942: LD_VAR 0 7
112946: ARRAY
112947: PPUSH
112948: CALL_OW 141
112952: GO 113117
// if not HasTask ( group [ i ] ) and to_heal then
112954: LD_VAR 0 4
112958: PUSH
112959: LD_VAR 0 7
112963: ARRAY
112964: PPUSH
112965: CALL_OW 314
112969: NOT
112970: PUSH
112971: LD_VAR 0 30
112975: AND
112976: IFFALSE 113117
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112978: LD_ADDR_VAR 0 13
112982: PUSH
112983: LD_VAR 0 30
112987: PPUSH
112988: LD_INT 3
112990: PUSH
112991: LD_INT 54
112993: PUSH
112994: EMPTY
112995: LIST
112996: PUSH
112997: EMPTY
112998: LIST
112999: LIST
113000: PPUSH
113001: CALL_OW 72
113005: PPUSH
113006: LD_VAR 0 4
113010: PUSH
113011: LD_VAR 0 7
113015: ARRAY
113016: PPUSH
113017: CALL_OW 74
113021: ST_TO_ADDR
// if z then
113022: LD_VAR 0 13
113026: IFFALSE 113117
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113028: LD_INT 91
113030: PUSH
113031: LD_VAR 0 13
113035: PUSH
113036: LD_INT 10
113038: PUSH
113039: EMPTY
113040: LIST
113041: LIST
113042: LIST
113043: PUSH
113044: LD_INT 81
113046: PUSH
113047: LD_VAR 0 13
113051: PPUSH
113052: CALL_OW 255
113056: PUSH
113057: EMPTY
113058: LIST
113059: LIST
113060: PUSH
113061: EMPTY
113062: LIST
113063: LIST
113064: PPUSH
113065: CALL_OW 69
113069: PUSH
113070: LD_INT 0
113072: EQUAL
113073: IFFALSE 113097
// ComHeal ( group [ i ] , z ) else
113075: LD_VAR 0 4
113079: PUSH
113080: LD_VAR 0 7
113084: ARRAY
113085: PPUSH
113086: LD_VAR 0 13
113090: PPUSH
113091: CALL_OW 128
113095: GO 113117
// ComMoveToArea ( group [ i ] , f_heal ) ;
113097: LD_VAR 0 4
113101: PUSH
113102: LD_VAR 0 7
113106: ARRAY
113107: PPUSH
113108: LD_VAR 0 23
113112: PPUSH
113113: CALL_OW 113
// end ; continue ;
113117: GO 112148
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113119: LD_VAR 0 4
113123: PUSH
113124: LD_VAR 0 7
113128: ARRAY
113129: PPUSH
113130: CALL_OW 256
113134: PUSH
113135: LD_INT 700
113137: LESS
113138: PUSH
113139: LD_VAR 0 4
113143: PUSH
113144: LD_VAR 0 7
113148: ARRAY
113149: PUSH
113150: LD_VAR 0 30
113154: IN
113155: NOT
113156: AND
113157: IFFALSE 113181
// to_heal := to_heal union group [ i ] ;
113159: LD_ADDR_VAR 0 30
113163: PUSH
113164: LD_VAR 0 30
113168: PUSH
113169: LD_VAR 0 4
113173: PUSH
113174: LD_VAR 0 7
113178: ARRAY
113179: UNION
113180: ST_TO_ADDR
// if group [ i ] in to_heal then
113181: LD_VAR 0 4
113185: PUSH
113186: LD_VAR 0 7
113190: ARRAY
113191: PUSH
113192: LD_VAR 0 30
113196: IN
113197: IFFALSE 113306
// begin if GetLives ( group [ i ] ) = 1000 then
113199: LD_VAR 0 4
113203: PUSH
113204: LD_VAR 0 7
113208: ARRAY
113209: PPUSH
113210: CALL_OW 256
113214: PUSH
113215: LD_INT 1000
113217: EQUAL
113218: IFFALSE 113244
// to_heal := to_heal diff group [ i ] else
113220: LD_ADDR_VAR 0 30
113224: PUSH
113225: LD_VAR 0 30
113229: PUSH
113230: LD_VAR 0 4
113234: PUSH
113235: LD_VAR 0 7
113239: ARRAY
113240: DIFF
113241: ST_TO_ADDR
113242: GO 113306
// begin if not IsInArea ( group [ i ] , to_heal ) then
113244: LD_VAR 0 4
113248: PUSH
113249: LD_VAR 0 7
113253: ARRAY
113254: PPUSH
113255: LD_VAR 0 30
113259: PPUSH
113260: CALL_OW 308
113264: NOT
113265: IFFALSE 113289
// ComMoveToArea ( group [ i ] , f_heal ) else
113267: LD_VAR 0 4
113271: PUSH
113272: LD_VAR 0 7
113276: ARRAY
113277: PPUSH
113278: LD_VAR 0 23
113282: PPUSH
113283: CALL_OW 113
113287: GO 113304
// ComHold ( group [ i ] ) ;
113289: LD_VAR 0 4
113293: PUSH
113294: LD_VAR 0 7
113298: ARRAY
113299: PPUSH
113300: CALL_OW 140
// continue ;
113304: GO 112148
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113306: LD_VAR 0 4
113310: PUSH
113311: LD_VAR 0 7
113315: ARRAY
113316: PPUSH
113317: LD_INT 10
113319: PPUSH
113320: CALL 52515 0 2
113324: NOT
113325: PUSH
113326: LD_VAR 0 16
113330: PUSH
113331: LD_VAR 0 7
113335: ARRAY
113336: PUSH
113337: EMPTY
113338: EQUAL
113339: NOT
113340: AND
113341: IFFALSE 113607
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113343: LD_VAR 0 4
113347: PUSH
113348: LD_VAR 0 7
113352: ARRAY
113353: PPUSH
113354: CALL_OW 262
113358: PUSH
113359: LD_INT 1
113361: PUSH
113362: LD_INT 2
113364: PUSH
113365: EMPTY
113366: LIST
113367: LIST
113368: IN
113369: IFFALSE 113410
// if GetFuel ( group [ i ] ) < 10 then
113371: LD_VAR 0 4
113375: PUSH
113376: LD_VAR 0 7
113380: ARRAY
113381: PPUSH
113382: CALL_OW 261
113386: PUSH
113387: LD_INT 10
113389: LESS
113390: IFFALSE 113410
// SetFuel ( group [ i ] , 12 ) ;
113392: LD_VAR 0 4
113396: PUSH
113397: LD_VAR 0 7
113401: ARRAY
113402: PPUSH
113403: LD_INT 12
113405: PPUSH
113406: CALL_OW 240
// if units_path [ i ] then
113410: LD_VAR 0 16
113414: PUSH
113415: LD_VAR 0 7
113419: ARRAY
113420: IFFALSE 113605
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113422: LD_VAR 0 4
113426: PUSH
113427: LD_VAR 0 7
113431: ARRAY
113432: PPUSH
113433: LD_VAR 0 16
113437: PUSH
113438: LD_VAR 0 7
113442: ARRAY
113443: PUSH
113444: LD_INT 1
113446: ARRAY
113447: PUSH
113448: LD_INT 1
113450: ARRAY
113451: PPUSH
113452: LD_VAR 0 16
113456: PUSH
113457: LD_VAR 0 7
113461: ARRAY
113462: PUSH
113463: LD_INT 1
113465: ARRAY
113466: PUSH
113467: LD_INT 2
113469: ARRAY
113470: PPUSH
113471: CALL_OW 297
113475: PUSH
113476: LD_INT 6
113478: GREATER
113479: IFFALSE 113554
// begin if not HasTask ( group [ i ] ) then
113481: LD_VAR 0 4
113485: PUSH
113486: LD_VAR 0 7
113490: ARRAY
113491: PPUSH
113492: CALL_OW 314
113496: NOT
113497: IFFALSE 113552
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113499: LD_VAR 0 4
113503: PUSH
113504: LD_VAR 0 7
113508: ARRAY
113509: PPUSH
113510: LD_VAR 0 16
113514: PUSH
113515: LD_VAR 0 7
113519: ARRAY
113520: PUSH
113521: LD_INT 1
113523: ARRAY
113524: PUSH
113525: LD_INT 1
113527: ARRAY
113528: PPUSH
113529: LD_VAR 0 16
113533: PUSH
113534: LD_VAR 0 7
113538: ARRAY
113539: PUSH
113540: LD_INT 1
113542: ARRAY
113543: PUSH
113544: LD_INT 2
113546: ARRAY
113547: PPUSH
113548: CALL_OW 114
// end else
113552: GO 113605
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113554: LD_ADDR_VAR 0 15
113558: PUSH
113559: LD_VAR 0 16
113563: PUSH
113564: LD_VAR 0 7
113568: ARRAY
113569: PPUSH
113570: LD_INT 1
113572: PPUSH
113573: CALL_OW 3
113577: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113578: LD_ADDR_VAR 0 16
113582: PUSH
113583: LD_VAR 0 16
113587: PPUSH
113588: LD_VAR 0 7
113592: PPUSH
113593: LD_VAR 0 15
113597: PPUSH
113598: CALL_OW 1
113602: ST_TO_ADDR
// continue ;
113603: GO 112148
// end ; end ; end else
113605: GO 116269
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113607: LD_ADDR_VAR 0 14
113611: PUSH
113612: LD_INT 81
113614: PUSH
113615: LD_VAR 0 4
113619: PUSH
113620: LD_VAR 0 7
113624: ARRAY
113625: PPUSH
113626: CALL_OW 255
113630: PUSH
113631: EMPTY
113632: LIST
113633: LIST
113634: PPUSH
113635: CALL_OW 69
113639: ST_TO_ADDR
// if not tmp then
113640: LD_VAR 0 14
113644: NOT
113645: IFFALSE 113649
// continue ;
113647: GO 112148
// if f_ignore_area then
113649: LD_VAR 0 17
113653: IFFALSE 113741
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113655: LD_ADDR_VAR 0 15
113659: PUSH
113660: LD_VAR 0 14
113664: PPUSH
113665: LD_INT 3
113667: PUSH
113668: LD_INT 92
113670: PUSH
113671: LD_VAR 0 17
113675: PUSH
113676: LD_INT 1
113678: ARRAY
113679: PUSH
113680: LD_VAR 0 17
113684: PUSH
113685: LD_INT 2
113687: ARRAY
113688: PUSH
113689: LD_VAR 0 17
113693: PUSH
113694: LD_INT 3
113696: ARRAY
113697: PUSH
113698: EMPTY
113699: LIST
113700: LIST
113701: LIST
113702: LIST
113703: PUSH
113704: EMPTY
113705: LIST
113706: LIST
113707: PPUSH
113708: CALL_OW 72
113712: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113713: LD_VAR 0 14
113717: PUSH
113718: LD_VAR 0 15
113722: DIFF
113723: IFFALSE 113741
// tmp := tmp diff tmp2 ;
113725: LD_ADDR_VAR 0 14
113729: PUSH
113730: LD_VAR 0 14
113734: PUSH
113735: LD_VAR 0 15
113739: DIFF
113740: ST_TO_ADDR
// end ; if not f_murder then
113741: LD_VAR 0 20
113745: NOT
113746: IFFALSE 113804
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113748: LD_ADDR_VAR 0 15
113752: PUSH
113753: LD_VAR 0 14
113757: PPUSH
113758: LD_INT 3
113760: PUSH
113761: LD_INT 50
113763: PUSH
113764: EMPTY
113765: LIST
113766: PUSH
113767: EMPTY
113768: LIST
113769: LIST
113770: PPUSH
113771: CALL_OW 72
113775: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113776: LD_VAR 0 14
113780: PUSH
113781: LD_VAR 0 15
113785: DIFF
113786: IFFALSE 113804
// tmp := tmp diff tmp2 ;
113788: LD_ADDR_VAR 0 14
113792: PUSH
113793: LD_VAR 0 14
113797: PUSH
113798: LD_VAR 0 15
113802: DIFF
113803: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113804: LD_ADDR_VAR 0 14
113808: PUSH
113809: LD_VAR 0 4
113813: PUSH
113814: LD_VAR 0 7
113818: ARRAY
113819: PPUSH
113820: LD_VAR 0 14
113824: PPUSH
113825: LD_INT 1
113827: PPUSH
113828: LD_INT 1
113830: PPUSH
113831: CALL 25456 0 4
113835: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
113836: LD_VAR 0 4
113840: PUSH
113841: LD_VAR 0 7
113845: ARRAY
113846: PPUSH
113847: CALL_OW 257
113851: PUSH
113852: LD_INT 1
113854: EQUAL
113855: IFFALSE 114303
// begin if WantPlant ( group [ i ] ) then
113857: LD_VAR 0 4
113861: PUSH
113862: LD_VAR 0 7
113866: ARRAY
113867: PPUSH
113868: CALL 24957 0 1
113872: IFFALSE 113876
// continue ;
113874: GO 112148
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113876: LD_VAR 0 18
113880: PUSH
113881: LD_VAR 0 4
113885: PUSH
113886: LD_VAR 0 7
113890: ARRAY
113891: PPUSH
113892: CALL_OW 310
113896: NOT
113897: AND
113898: PUSH
113899: LD_VAR 0 14
113903: PUSH
113904: LD_INT 1
113906: ARRAY
113907: PUSH
113908: LD_VAR 0 14
113912: PPUSH
113913: LD_INT 21
113915: PUSH
113916: LD_INT 2
113918: PUSH
113919: EMPTY
113920: LIST
113921: LIST
113922: PUSH
113923: LD_INT 58
113925: PUSH
113926: EMPTY
113927: LIST
113928: PUSH
113929: EMPTY
113930: LIST
113931: LIST
113932: PPUSH
113933: CALL_OW 72
113937: IN
113938: AND
113939: IFFALSE 113975
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113941: LD_VAR 0 4
113945: PUSH
113946: LD_VAR 0 7
113950: ARRAY
113951: PPUSH
113952: LD_VAR 0 14
113956: PUSH
113957: LD_INT 1
113959: ARRAY
113960: PPUSH
113961: CALL_OW 120
// attacking := true ;
113965: LD_ADDR_VAR 0 29
113969: PUSH
113970: LD_INT 1
113972: ST_TO_ADDR
// continue ;
113973: GO 112148
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113975: LD_VAR 0 26
113979: PUSH
113980: LD_VAR 0 4
113984: PUSH
113985: LD_VAR 0 7
113989: ARRAY
113990: PPUSH
113991: CALL_OW 257
113995: PUSH
113996: LD_INT 1
113998: EQUAL
113999: AND
114000: PUSH
114001: LD_VAR 0 4
114005: PUSH
114006: LD_VAR 0 7
114010: ARRAY
114011: PPUSH
114012: CALL_OW 256
114016: PUSH
114017: LD_INT 800
114019: LESS
114020: AND
114021: PUSH
114022: LD_VAR 0 4
114026: PUSH
114027: LD_VAR 0 7
114031: ARRAY
114032: PPUSH
114033: CALL_OW 318
114037: NOT
114038: AND
114039: IFFALSE 114056
// ComCrawl ( group [ i ] ) ;
114041: LD_VAR 0 4
114045: PUSH
114046: LD_VAR 0 7
114050: ARRAY
114051: PPUSH
114052: CALL_OW 137
// if f_mines then
114056: LD_VAR 0 21
114060: IFFALSE 114303
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114062: LD_VAR 0 14
114066: PUSH
114067: LD_INT 1
114069: ARRAY
114070: PPUSH
114071: CALL_OW 247
114075: PUSH
114076: LD_INT 3
114078: EQUAL
114079: PUSH
114080: LD_VAR 0 14
114084: PUSH
114085: LD_INT 1
114087: ARRAY
114088: PUSH
114089: LD_VAR 0 27
114093: IN
114094: NOT
114095: AND
114096: IFFALSE 114303
// begin x := GetX ( tmp [ 1 ] ) ;
114098: LD_ADDR_VAR 0 10
114102: PUSH
114103: LD_VAR 0 14
114107: PUSH
114108: LD_INT 1
114110: ARRAY
114111: PPUSH
114112: CALL_OW 250
114116: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114117: LD_ADDR_VAR 0 11
114121: PUSH
114122: LD_VAR 0 14
114126: PUSH
114127: LD_INT 1
114129: ARRAY
114130: PPUSH
114131: CALL_OW 251
114135: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114136: LD_ADDR_VAR 0 12
114140: PUSH
114141: LD_VAR 0 4
114145: PUSH
114146: LD_VAR 0 7
114150: ARRAY
114151: PPUSH
114152: CALL 52600 0 1
114156: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114157: LD_VAR 0 4
114161: PUSH
114162: LD_VAR 0 7
114166: ARRAY
114167: PPUSH
114168: LD_VAR 0 10
114172: PPUSH
114173: LD_VAR 0 11
114177: PPUSH
114178: LD_VAR 0 14
114182: PUSH
114183: LD_INT 1
114185: ARRAY
114186: PPUSH
114187: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114191: LD_VAR 0 4
114195: PUSH
114196: LD_VAR 0 7
114200: ARRAY
114201: PPUSH
114202: LD_VAR 0 10
114206: PPUSH
114207: LD_VAR 0 12
114211: PPUSH
114212: LD_INT 7
114214: PPUSH
114215: CALL_OW 272
114219: PPUSH
114220: LD_VAR 0 11
114224: PPUSH
114225: LD_VAR 0 12
114229: PPUSH
114230: LD_INT 7
114232: PPUSH
114233: CALL_OW 273
114237: PPUSH
114238: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114242: LD_VAR 0 4
114246: PUSH
114247: LD_VAR 0 7
114251: ARRAY
114252: PPUSH
114253: LD_INT 71
114255: PPUSH
114256: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114260: LD_ADDR_VAR 0 27
114264: PUSH
114265: LD_VAR 0 27
114269: PPUSH
114270: LD_VAR 0 27
114274: PUSH
114275: LD_INT 1
114277: PLUS
114278: PPUSH
114279: LD_VAR 0 14
114283: PUSH
114284: LD_INT 1
114286: ARRAY
114287: PPUSH
114288: CALL_OW 1
114292: ST_TO_ADDR
// attacking := true ;
114293: LD_ADDR_VAR 0 29
114297: PUSH
114298: LD_INT 1
114300: ST_TO_ADDR
// continue ;
114301: GO 112148
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114303: LD_VAR 0 4
114307: PUSH
114308: LD_VAR 0 7
114312: ARRAY
114313: PPUSH
114314: CALL_OW 257
114318: PUSH
114319: LD_INT 17
114321: EQUAL
114322: PUSH
114323: LD_VAR 0 4
114327: PUSH
114328: LD_VAR 0 7
114332: ARRAY
114333: PPUSH
114334: CALL_OW 110
114338: PUSH
114339: LD_INT 71
114341: EQUAL
114342: NOT
114343: AND
114344: IFFALSE 114490
// begin attacking := false ;
114346: LD_ADDR_VAR 0 29
114350: PUSH
114351: LD_INT 0
114353: ST_TO_ADDR
// k := 5 ;
114354: LD_ADDR_VAR 0 9
114358: PUSH
114359: LD_INT 5
114361: ST_TO_ADDR
// if tmp < k then
114362: LD_VAR 0 14
114366: PUSH
114367: LD_VAR 0 9
114371: LESS
114372: IFFALSE 114384
// k := tmp ;
114374: LD_ADDR_VAR 0 9
114378: PUSH
114379: LD_VAR 0 14
114383: ST_TO_ADDR
// for j = 1 to k do
114384: LD_ADDR_VAR 0 8
114388: PUSH
114389: DOUBLE
114390: LD_INT 1
114392: DEC
114393: ST_TO_ADDR
114394: LD_VAR 0 9
114398: PUSH
114399: FOR_TO
114400: IFFALSE 114488
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114402: LD_VAR 0 14
114406: PUSH
114407: LD_VAR 0 8
114411: ARRAY
114412: PUSH
114413: LD_VAR 0 14
114417: PPUSH
114418: LD_INT 58
114420: PUSH
114421: EMPTY
114422: LIST
114423: PPUSH
114424: CALL_OW 72
114428: IN
114429: NOT
114430: IFFALSE 114486
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114432: LD_VAR 0 4
114436: PUSH
114437: LD_VAR 0 7
114441: ARRAY
114442: PPUSH
114443: LD_VAR 0 14
114447: PUSH
114448: LD_VAR 0 8
114452: ARRAY
114453: PPUSH
114454: CALL_OW 115
// attacking := true ;
114458: LD_ADDR_VAR 0 29
114462: PUSH
114463: LD_INT 1
114465: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114466: LD_VAR 0 4
114470: PUSH
114471: LD_VAR 0 7
114475: ARRAY
114476: PPUSH
114477: LD_INT 71
114479: PPUSH
114480: CALL_OW 109
// continue ;
114484: GO 114399
// end ; end ;
114486: GO 114399
114488: POP
114489: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114490: LD_VAR 0 4
114494: PUSH
114495: LD_VAR 0 7
114499: ARRAY
114500: PPUSH
114501: CALL_OW 257
114505: PUSH
114506: LD_INT 8
114508: EQUAL
114509: PUSH
114510: LD_VAR 0 4
114514: PUSH
114515: LD_VAR 0 7
114519: ARRAY
114520: PPUSH
114521: CALL_OW 264
114525: PUSH
114526: LD_INT 28
114528: PUSH
114529: LD_INT 45
114531: PUSH
114532: LD_INT 7
114534: PUSH
114535: LD_INT 47
114537: PUSH
114538: EMPTY
114539: LIST
114540: LIST
114541: LIST
114542: LIST
114543: IN
114544: OR
114545: IFFALSE 114801
// begin attacking := false ;
114547: LD_ADDR_VAR 0 29
114551: PUSH
114552: LD_INT 0
114554: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114555: LD_VAR 0 14
114559: PUSH
114560: LD_INT 1
114562: ARRAY
114563: PPUSH
114564: CALL_OW 266
114568: PUSH
114569: LD_INT 32
114571: PUSH
114572: LD_INT 31
114574: PUSH
114575: LD_INT 33
114577: PUSH
114578: LD_INT 4
114580: PUSH
114581: LD_INT 5
114583: PUSH
114584: EMPTY
114585: LIST
114586: LIST
114587: LIST
114588: LIST
114589: LIST
114590: IN
114591: IFFALSE 114777
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114593: LD_ADDR_VAR 0 9
114597: PUSH
114598: LD_VAR 0 14
114602: PUSH
114603: LD_INT 1
114605: ARRAY
114606: PPUSH
114607: CALL_OW 266
114611: PPUSH
114612: LD_VAR 0 14
114616: PUSH
114617: LD_INT 1
114619: ARRAY
114620: PPUSH
114621: CALL_OW 250
114625: PPUSH
114626: LD_VAR 0 14
114630: PUSH
114631: LD_INT 1
114633: ARRAY
114634: PPUSH
114635: CALL_OW 251
114639: PPUSH
114640: LD_VAR 0 14
114644: PUSH
114645: LD_INT 1
114647: ARRAY
114648: PPUSH
114649: CALL_OW 254
114653: PPUSH
114654: LD_VAR 0 14
114658: PUSH
114659: LD_INT 1
114661: ARRAY
114662: PPUSH
114663: CALL_OW 248
114667: PPUSH
114668: LD_INT 0
114670: PPUSH
114671: CALL 33970 0 6
114675: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114676: LD_ADDR_VAR 0 8
114680: PUSH
114681: LD_VAR 0 4
114685: PUSH
114686: LD_VAR 0 7
114690: ARRAY
114691: PPUSH
114692: LD_VAR 0 9
114696: PPUSH
114697: CALL 52640 0 2
114701: ST_TO_ADDR
// if j then
114702: LD_VAR 0 8
114706: IFFALSE 114775
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114708: LD_VAR 0 8
114712: PUSH
114713: LD_INT 1
114715: ARRAY
114716: PPUSH
114717: LD_VAR 0 8
114721: PUSH
114722: LD_INT 2
114724: ARRAY
114725: PPUSH
114726: CALL_OW 488
114730: IFFALSE 114775
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114732: LD_VAR 0 4
114736: PUSH
114737: LD_VAR 0 7
114741: ARRAY
114742: PPUSH
114743: LD_VAR 0 8
114747: PUSH
114748: LD_INT 1
114750: ARRAY
114751: PPUSH
114752: LD_VAR 0 8
114756: PUSH
114757: LD_INT 2
114759: ARRAY
114760: PPUSH
114761: CALL_OW 116
// attacking := true ;
114765: LD_ADDR_VAR 0 29
114769: PUSH
114770: LD_INT 1
114772: ST_TO_ADDR
// continue ;
114773: GO 112148
// end ; end else
114775: GO 114801
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114777: LD_VAR 0 4
114781: PUSH
114782: LD_VAR 0 7
114786: ARRAY
114787: PPUSH
114788: LD_VAR 0 14
114792: PUSH
114793: LD_INT 1
114795: ARRAY
114796: PPUSH
114797: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114801: LD_VAR 0 4
114805: PUSH
114806: LD_VAR 0 7
114810: ARRAY
114811: PPUSH
114812: CALL_OW 265
114816: PUSH
114817: LD_INT 11
114819: EQUAL
114820: IFFALSE 115098
// begin k := 10 ;
114822: LD_ADDR_VAR 0 9
114826: PUSH
114827: LD_INT 10
114829: ST_TO_ADDR
// x := 0 ;
114830: LD_ADDR_VAR 0 10
114834: PUSH
114835: LD_INT 0
114837: ST_TO_ADDR
// if tmp < k then
114838: LD_VAR 0 14
114842: PUSH
114843: LD_VAR 0 9
114847: LESS
114848: IFFALSE 114860
// k := tmp ;
114850: LD_ADDR_VAR 0 9
114854: PUSH
114855: LD_VAR 0 14
114859: ST_TO_ADDR
// for j = k downto 1 do
114860: LD_ADDR_VAR 0 8
114864: PUSH
114865: DOUBLE
114866: LD_VAR 0 9
114870: INC
114871: ST_TO_ADDR
114872: LD_INT 1
114874: PUSH
114875: FOR_DOWNTO
114876: IFFALSE 114951
// begin if GetType ( tmp [ j ] ) = unit_human then
114878: LD_VAR 0 14
114882: PUSH
114883: LD_VAR 0 8
114887: ARRAY
114888: PPUSH
114889: CALL_OW 247
114893: PUSH
114894: LD_INT 1
114896: EQUAL
114897: IFFALSE 114949
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114899: LD_VAR 0 4
114903: PUSH
114904: LD_VAR 0 7
114908: ARRAY
114909: PPUSH
114910: LD_VAR 0 14
114914: PUSH
114915: LD_VAR 0 8
114919: ARRAY
114920: PPUSH
114921: CALL 52894 0 2
// x := tmp [ j ] ;
114925: LD_ADDR_VAR 0 10
114929: PUSH
114930: LD_VAR 0 14
114934: PUSH
114935: LD_VAR 0 8
114939: ARRAY
114940: ST_TO_ADDR
// attacking := true ;
114941: LD_ADDR_VAR 0 29
114945: PUSH
114946: LD_INT 1
114948: ST_TO_ADDR
// end ; end ;
114949: GO 114875
114951: POP
114952: POP
// if not x then
114953: LD_VAR 0 10
114957: NOT
114958: IFFALSE 115098
// begin attacking := true ;
114960: LD_ADDR_VAR 0 29
114964: PUSH
114965: LD_INT 1
114967: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114968: LD_VAR 0 4
114972: PUSH
114973: LD_VAR 0 7
114977: ARRAY
114978: PPUSH
114979: CALL_OW 250
114983: PPUSH
114984: LD_VAR 0 4
114988: PUSH
114989: LD_VAR 0 7
114993: ARRAY
114994: PPUSH
114995: CALL_OW 251
114999: PPUSH
115000: CALL_OW 546
115004: PUSH
115005: LD_INT 2
115007: ARRAY
115008: PUSH
115009: LD_VAR 0 14
115013: PUSH
115014: LD_INT 1
115016: ARRAY
115017: PPUSH
115018: CALL_OW 250
115022: PPUSH
115023: LD_VAR 0 14
115027: PUSH
115028: LD_INT 1
115030: ARRAY
115031: PPUSH
115032: CALL_OW 251
115036: PPUSH
115037: CALL_OW 546
115041: PUSH
115042: LD_INT 2
115044: ARRAY
115045: EQUAL
115046: IFFALSE 115074
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115048: LD_VAR 0 4
115052: PUSH
115053: LD_VAR 0 7
115057: ARRAY
115058: PPUSH
115059: LD_VAR 0 14
115063: PUSH
115064: LD_INT 1
115066: ARRAY
115067: PPUSH
115068: CALL 52894 0 2
115072: GO 115098
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115074: LD_VAR 0 4
115078: PUSH
115079: LD_VAR 0 7
115083: ARRAY
115084: PPUSH
115085: LD_VAR 0 14
115089: PUSH
115090: LD_INT 1
115092: ARRAY
115093: PPUSH
115094: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115098: LD_VAR 0 4
115102: PUSH
115103: LD_VAR 0 7
115107: ARRAY
115108: PPUSH
115109: CALL_OW 264
115113: PUSH
115114: LD_INT 29
115116: EQUAL
115117: IFFALSE 115483
// begin if WantsToAttack ( group [ i ] ) in bombed then
115119: LD_VAR 0 4
115123: PUSH
115124: LD_VAR 0 7
115128: ARRAY
115129: PPUSH
115130: CALL_OW 319
115134: PUSH
115135: LD_VAR 0 28
115139: IN
115140: IFFALSE 115144
// continue ;
115142: GO 112148
// k := 8 ;
115144: LD_ADDR_VAR 0 9
115148: PUSH
115149: LD_INT 8
115151: ST_TO_ADDR
// x := 0 ;
115152: LD_ADDR_VAR 0 10
115156: PUSH
115157: LD_INT 0
115159: ST_TO_ADDR
// if tmp < k then
115160: LD_VAR 0 14
115164: PUSH
115165: LD_VAR 0 9
115169: LESS
115170: IFFALSE 115182
// k := tmp ;
115172: LD_ADDR_VAR 0 9
115176: PUSH
115177: LD_VAR 0 14
115181: ST_TO_ADDR
// for j = 1 to k do
115182: LD_ADDR_VAR 0 8
115186: PUSH
115187: DOUBLE
115188: LD_INT 1
115190: DEC
115191: ST_TO_ADDR
115192: LD_VAR 0 9
115196: PUSH
115197: FOR_TO
115198: IFFALSE 115330
// begin if GetType ( tmp [ j ] ) = unit_building then
115200: LD_VAR 0 14
115204: PUSH
115205: LD_VAR 0 8
115209: ARRAY
115210: PPUSH
115211: CALL_OW 247
115215: PUSH
115216: LD_INT 3
115218: EQUAL
115219: IFFALSE 115328
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115221: LD_VAR 0 14
115225: PUSH
115226: LD_VAR 0 8
115230: ARRAY
115231: PUSH
115232: LD_VAR 0 28
115236: IN
115237: NOT
115238: PUSH
115239: LD_VAR 0 14
115243: PUSH
115244: LD_VAR 0 8
115248: ARRAY
115249: PPUSH
115250: CALL_OW 313
115254: AND
115255: IFFALSE 115328
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115257: LD_VAR 0 4
115261: PUSH
115262: LD_VAR 0 7
115266: ARRAY
115267: PPUSH
115268: LD_VAR 0 14
115272: PUSH
115273: LD_VAR 0 8
115277: ARRAY
115278: PPUSH
115279: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115283: LD_ADDR_VAR 0 28
115287: PUSH
115288: LD_VAR 0 28
115292: PPUSH
115293: LD_VAR 0 28
115297: PUSH
115298: LD_INT 1
115300: PLUS
115301: PPUSH
115302: LD_VAR 0 14
115306: PUSH
115307: LD_VAR 0 8
115311: ARRAY
115312: PPUSH
115313: CALL_OW 1
115317: ST_TO_ADDR
// attacking := true ;
115318: LD_ADDR_VAR 0 29
115322: PUSH
115323: LD_INT 1
115325: ST_TO_ADDR
// break ;
115326: GO 115330
// end ; end ;
115328: GO 115197
115330: POP
115331: POP
// if not attacking and f_attack_depot then
115332: LD_VAR 0 29
115336: NOT
115337: PUSH
115338: LD_VAR 0 25
115342: AND
115343: IFFALSE 115438
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115345: LD_ADDR_VAR 0 13
115349: PUSH
115350: LD_VAR 0 14
115354: PPUSH
115355: LD_INT 2
115357: PUSH
115358: LD_INT 30
115360: PUSH
115361: LD_INT 0
115363: PUSH
115364: EMPTY
115365: LIST
115366: LIST
115367: PUSH
115368: LD_INT 30
115370: PUSH
115371: LD_INT 1
115373: PUSH
115374: EMPTY
115375: LIST
115376: LIST
115377: PUSH
115378: EMPTY
115379: LIST
115380: LIST
115381: LIST
115382: PPUSH
115383: CALL_OW 72
115387: ST_TO_ADDR
// if z then
115388: LD_VAR 0 13
115392: IFFALSE 115438
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115394: LD_VAR 0 4
115398: PUSH
115399: LD_VAR 0 7
115403: ARRAY
115404: PPUSH
115405: LD_VAR 0 13
115409: PPUSH
115410: LD_VAR 0 4
115414: PUSH
115415: LD_VAR 0 7
115419: ARRAY
115420: PPUSH
115421: CALL_OW 74
115425: PPUSH
115426: CALL_OW 115
// attacking := true ;
115430: LD_ADDR_VAR 0 29
115434: PUSH
115435: LD_INT 1
115437: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115438: LD_VAR 0 4
115442: PUSH
115443: LD_VAR 0 7
115447: ARRAY
115448: PPUSH
115449: CALL_OW 256
115453: PUSH
115454: LD_INT 500
115456: LESS
115457: IFFALSE 115483
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115459: LD_VAR 0 4
115463: PUSH
115464: LD_VAR 0 7
115468: ARRAY
115469: PPUSH
115470: LD_VAR 0 14
115474: PUSH
115475: LD_INT 1
115477: ARRAY
115478: PPUSH
115479: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115483: LD_VAR 0 4
115487: PUSH
115488: LD_VAR 0 7
115492: ARRAY
115493: PPUSH
115494: CALL_OW 264
115498: PUSH
115499: LD_INT 49
115501: EQUAL
115502: IFFALSE 115623
// begin if not HasTask ( group [ i ] ) then
115504: LD_VAR 0 4
115508: PUSH
115509: LD_VAR 0 7
115513: ARRAY
115514: PPUSH
115515: CALL_OW 314
115519: NOT
115520: IFFALSE 115623
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115522: LD_ADDR_VAR 0 9
115526: PUSH
115527: LD_INT 81
115529: PUSH
115530: LD_VAR 0 4
115534: PUSH
115535: LD_VAR 0 7
115539: ARRAY
115540: PPUSH
115541: CALL_OW 255
115545: PUSH
115546: EMPTY
115547: LIST
115548: LIST
115549: PPUSH
115550: CALL_OW 69
115554: PPUSH
115555: LD_VAR 0 4
115559: PUSH
115560: LD_VAR 0 7
115564: ARRAY
115565: PPUSH
115566: CALL_OW 74
115570: ST_TO_ADDR
// if k then
115571: LD_VAR 0 9
115575: IFFALSE 115623
// if GetDistUnits ( group [ i ] , k ) > 10 then
115577: LD_VAR 0 4
115581: PUSH
115582: LD_VAR 0 7
115586: ARRAY
115587: PPUSH
115588: LD_VAR 0 9
115592: PPUSH
115593: CALL_OW 296
115597: PUSH
115598: LD_INT 10
115600: GREATER
115601: IFFALSE 115623
// ComMoveUnit ( group [ i ] , k ) ;
115603: LD_VAR 0 4
115607: PUSH
115608: LD_VAR 0 7
115612: ARRAY
115613: PPUSH
115614: LD_VAR 0 9
115618: PPUSH
115619: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115623: LD_VAR 0 4
115627: PUSH
115628: LD_VAR 0 7
115632: ARRAY
115633: PPUSH
115634: CALL_OW 256
115638: PUSH
115639: LD_INT 250
115641: LESS
115642: PUSH
115643: LD_VAR 0 4
115647: PUSH
115648: LD_VAR 0 7
115652: ARRAY
115653: PUSH
115654: LD_INT 21
115656: PUSH
115657: LD_INT 2
115659: PUSH
115660: EMPTY
115661: LIST
115662: LIST
115663: PUSH
115664: LD_INT 23
115666: PUSH
115667: LD_INT 2
115669: PUSH
115670: EMPTY
115671: LIST
115672: LIST
115673: PUSH
115674: EMPTY
115675: LIST
115676: LIST
115677: PPUSH
115678: CALL_OW 69
115682: IN
115683: AND
115684: IFFALSE 115809
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115686: LD_ADDR_VAR 0 9
115690: PUSH
115691: LD_OWVAR 3
115695: PUSH
115696: LD_VAR 0 4
115700: PUSH
115701: LD_VAR 0 7
115705: ARRAY
115706: DIFF
115707: PPUSH
115708: LD_VAR 0 4
115712: PUSH
115713: LD_VAR 0 7
115717: ARRAY
115718: PPUSH
115719: CALL_OW 74
115723: ST_TO_ADDR
// if not k then
115724: LD_VAR 0 9
115728: NOT
115729: IFFALSE 115733
// continue ;
115731: GO 112148
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115733: LD_VAR 0 9
115737: PUSH
115738: LD_INT 81
115740: PUSH
115741: LD_VAR 0 4
115745: PUSH
115746: LD_VAR 0 7
115750: ARRAY
115751: PPUSH
115752: CALL_OW 255
115756: PUSH
115757: EMPTY
115758: LIST
115759: LIST
115760: PPUSH
115761: CALL_OW 69
115765: IN
115766: PUSH
115767: LD_VAR 0 9
115771: PPUSH
115772: LD_VAR 0 4
115776: PUSH
115777: LD_VAR 0 7
115781: ARRAY
115782: PPUSH
115783: CALL_OW 296
115787: PUSH
115788: LD_INT 5
115790: LESS
115791: AND
115792: IFFALSE 115809
// ComAutodestruct ( group [ i ] ) ;
115794: LD_VAR 0 4
115798: PUSH
115799: LD_VAR 0 7
115803: ARRAY
115804: PPUSH
115805: CALL 52792 0 1
// end ; if f_attack_depot then
115809: LD_VAR 0 25
115813: IFFALSE 115925
// begin k := 6 ;
115815: LD_ADDR_VAR 0 9
115819: PUSH
115820: LD_INT 6
115822: ST_TO_ADDR
// if tmp < k then
115823: LD_VAR 0 14
115827: PUSH
115828: LD_VAR 0 9
115832: LESS
115833: IFFALSE 115845
// k := tmp ;
115835: LD_ADDR_VAR 0 9
115839: PUSH
115840: LD_VAR 0 14
115844: ST_TO_ADDR
// for j = 1 to k do
115845: LD_ADDR_VAR 0 8
115849: PUSH
115850: DOUBLE
115851: LD_INT 1
115853: DEC
115854: ST_TO_ADDR
115855: LD_VAR 0 9
115859: PUSH
115860: FOR_TO
115861: IFFALSE 115923
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
115863: LD_VAR 0 8
115867: PPUSH
115868: CALL_OW 266
115872: PUSH
115873: LD_INT 0
115875: PUSH
115876: LD_INT 1
115878: PUSH
115879: EMPTY
115880: LIST
115881: LIST
115882: IN
115883: IFFALSE 115921
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115885: LD_VAR 0 4
115889: PUSH
115890: LD_VAR 0 7
115894: ARRAY
115895: PPUSH
115896: LD_VAR 0 14
115900: PUSH
115901: LD_VAR 0 8
115905: ARRAY
115906: PPUSH
115907: CALL_OW 115
// attacking := true ;
115911: LD_ADDR_VAR 0 29
115915: PUSH
115916: LD_INT 1
115918: ST_TO_ADDR
// break ;
115919: GO 115923
// end ;
115921: GO 115860
115923: POP
115924: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115925: LD_VAR 0 4
115929: PUSH
115930: LD_VAR 0 7
115934: ARRAY
115935: PPUSH
115936: CALL_OW 302
115940: PUSH
115941: LD_VAR 0 29
115945: NOT
115946: AND
115947: IFFALSE 116269
// begin if GetTag ( group [ i ] ) = 71 then
115949: LD_VAR 0 4
115953: PUSH
115954: LD_VAR 0 7
115958: ARRAY
115959: PPUSH
115960: CALL_OW 110
115964: PUSH
115965: LD_INT 71
115967: EQUAL
115968: IFFALSE 116009
// begin if HasTask ( group [ i ] ) then
115970: LD_VAR 0 4
115974: PUSH
115975: LD_VAR 0 7
115979: ARRAY
115980: PPUSH
115981: CALL_OW 314
115985: IFFALSE 115991
// continue else
115987: GO 112148
115989: GO 116009
// SetTag ( group [ i ] , 0 ) ;
115991: LD_VAR 0 4
115995: PUSH
115996: LD_VAR 0 7
116000: ARRAY
116001: PPUSH
116002: LD_INT 0
116004: PPUSH
116005: CALL_OW 109
// end ; k := 8 ;
116009: LD_ADDR_VAR 0 9
116013: PUSH
116014: LD_INT 8
116016: ST_TO_ADDR
// x := 0 ;
116017: LD_ADDR_VAR 0 10
116021: PUSH
116022: LD_INT 0
116024: ST_TO_ADDR
// if tmp < k then
116025: LD_VAR 0 14
116029: PUSH
116030: LD_VAR 0 9
116034: LESS
116035: IFFALSE 116047
// k := tmp ;
116037: LD_ADDR_VAR 0 9
116041: PUSH
116042: LD_VAR 0 14
116046: ST_TO_ADDR
// for j = 1 to k do
116047: LD_ADDR_VAR 0 8
116051: PUSH
116052: DOUBLE
116053: LD_INT 1
116055: DEC
116056: ST_TO_ADDR
116057: LD_VAR 0 9
116061: PUSH
116062: FOR_TO
116063: IFFALSE 116161
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116065: LD_VAR 0 14
116069: PUSH
116070: LD_VAR 0 8
116074: ARRAY
116075: PPUSH
116076: CALL_OW 247
116080: PUSH
116081: LD_INT 1
116083: EQUAL
116084: PUSH
116085: LD_VAR 0 14
116089: PUSH
116090: LD_VAR 0 8
116094: ARRAY
116095: PPUSH
116096: CALL_OW 256
116100: PUSH
116101: LD_INT 250
116103: LESS
116104: PUSH
116105: LD_VAR 0 20
116109: AND
116110: PUSH
116111: LD_VAR 0 20
116115: NOT
116116: PUSH
116117: LD_VAR 0 14
116121: PUSH
116122: LD_VAR 0 8
116126: ARRAY
116127: PPUSH
116128: CALL_OW 256
116132: PUSH
116133: LD_INT 250
116135: GREATEREQUAL
116136: AND
116137: OR
116138: AND
116139: IFFALSE 116159
// begin x := tmp [ j ] ;
116141: LD_ADDR_VAR 0 10
116145: PUSH
116146: LD_VAR 0 14
116150: PUSH
116151: LD_VAR 0 8
116155: ARRAY
116156: ST_TO_ADDR
// break ;
116157: GO 116161
// end ;
116159: GO 116062
116161: POP
116162: POP
// if x then
116163: LD_VAR 0 10
116167: IFFALSE 116191
// ComAttackUnit ( group [ i ] , x ) else
116169: LD_VAR 0 4
116173: PUSH
116174: LD_VAR 0 7
116178: ARRAY
116179: PPUSH
116180: LD_VAR 0 10
116184: PPUSH
116185: CALL_OW 115
116189: GO 116215
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116191: LD_VAR 0 4
116195: PUSH
116196: LD_VAR 0 7
116200: ARRAY
116201: PPUSH
116202: LD_VAR 0 14
116206: PUSH
116207: LD_INT 1
116209: ARRAY
116210: PPUSH
116211: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116215: LD_VAR 0 4
116219: PUSH
116220: LD_VAR 0 7
116224: ARRAY
116225: PPUSH
116226: CALL_OW 314
116230: NOT
116231: IFFALSE 116269
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116233: LD_VAR 0 4
116237: PUSH
116238: LD_VAR 0 7
116242: ARRAY
116243: PPUSH
116244: LD_VAR 0 14
116248: PPUSH
116249: LD_VAR 0 4
116253: PUSH
116254: LD_VAR 0 7
116258: ARRAY
116259: PPUSH
116260: CALL_OW 74
116264: PPUSH
116265: CALL_OW 115
// end ; end ; end ;
116269: GO 112148
116271: POP
116272: POP
// wait ( 0 0$2 ) ;
116273: LD_INT 70
116275: PPUSH
116276: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116280: LD_VAR 0 4
116284: NOT
116285: PUSH
116286: LD_VAR 0 4
116290: PUSH
116291: EMPTY
116292: EQUAL
116293: OR
116294: PUSH
116295: LD_INT 81
116297: PUSH
116298: LD_VAR 0 35
116302: PUSH
116303: EMPTY
116304: LIST
116305: LIST
116306: PPUSH
116307: CALL_OW 69
116311: NOT
116312: OR
116313: IFFALSE 112133
// end ;
116315: LD_VAR 0 2
116319: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116320: LD_INT 0
116322: PPUSH
116323: PPUSH
116324: PPUSH
116325: PPUSH
116326: PPUSH
116327: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116328: LD_VAR 0 1
116332: NOT
116333: PUSH
116334: LD_EXP 31
116338: PUSH
116339: LD_VAR 0 1
116343: ARRAY
116344: NOT
116345: OR
116346: PUSH
116347: LD_VAR 0 2
116351: NOT
116352: OR
116353: IFFALSE 116357
// exit ;
116355: GO 116911
// side := mc_sides [ base ] ;
116357: LD_ADDR_VAR 0 6
116361: PUSH
116362: LD_EXP 57
116366: PUSH
116367: LD_VAR 0 1
116371: ARRAY
116372: ST_TO_ADDR
// if not side then
116373: LD_VAR 0 6
116377: NOT
116378: IFFALSE 116382
// exit ;
116380: GO 116911
// for i in solds do
116382: LD_ADDR_VAR 0 7
116386: PUSH
116387: LD_VAR 0 2
116391: PUSH
116392: FOR_IN
116393: IFFALSE 116454
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116395: LD_VAR 0 7
116399: PPUSH
116400: CALL_OW 310
116404: PPUSH
116405: CALL_OW 266
116409: PUSH
116410: LD_INT 32
116412: PUSH
116413: LD_INT 31
116415: PUSH
116416: EMPTY
116417: LIST
116418: LIST
116419: IN
116420: IFFALSE 116440
// solds := solds diff i else
116422: LD_ADDR_VAR 0 2
116426: PUSH
116427: LD_VAR 0 2
116431: PUSH
116432: LD_VAR 0 7
116436: DIFF
116437: ST_TO_ADDR
116438: GO 116452
// SetTag ( i , 18 ) ;
116440: LD_VAR 0 7
116444: PPUSH
116445: LD_INT 18
116447: PPUSH
116448: CALL_OW 109
116452: GO 116392
116454: POP
116455: POP
// if not solds then
116456: LD_VAR 0 2
116460: NOT
116461: IFFALSE 116465
// exit ;
116463: GO 116911
// repeat wait ( 0 0$2 ) ;
116465: LD_INT 70
116467: PPUSH
116468: CALL_OW 67
// enemy := mc_scan [ base ] ;
116472: LD_ADDR_VAR 0 4
116476: PUSH
116477: LD_EXP 54
116481: PUSH
116482: LD_VAR 0 1
116486: ARRAY
116487: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116488: LD_EXP 31
116492: PUSH
116493: LD_VAR 0 1
116497: ARRAY
116498: NOT
116499: PUSH
116500: LD_EXP 31
116504: PUSH
116505: LD_VAR 0 1
116509: ARRAY
116510: PUSH
116511: EMPTY
116512: EQUAL
116513: OR
116514: IFFALSE 116551
// begin for i in solds do
116516: LD_ADDR_VAR 0 7
116520: PUSH
116521: LD_VAR 0 2
116525: PUSH
116526: FOR_IN
116527: IFFALSE 116540
// ComStop ( i ) ;
116529: LD_VAR 0 7
116533: PPUSH
116534: CALL_OW 141
116538: GO 116526
116540: POP
116541: POP
// solds := [ ] ;
116542: LD_ADDR_VAR 0 2
116546: PUSH
116547: EMPTY
116548: ST_TO_ADDR
// exit ;
116549: GO 116911
// end ; for i in solds do
116551: LD_ADDR_VAR 0 7
116555: PUSH
116556: LD_VAR 0 2
116560: PUSH
116561: FOR_IN
116562: IFFALSE 116883
// begin if IsInUnit ( i ) then
116564: LD_VAR 0 7
116568: PPUSH
116569: CALL_OW 310
116573: IFFALSE 116584
// ComExitBuilding ( i ) ;
116575: LD_VAR 0 7
116579: PPUSH
116580: CALL_OW 122
// if GetLives ( i ) > 500 then
116584: LD_VAR 0 7
116588: PPUSH
116589: CALL_OW 256
116593: PUSH
116594: LD_INT 500
116596: GREATER
116597: IFFALSE 116650
// begin e := NearestUnitToUnit ( enemy , i ) ;
116599: LD_ADDR_VAR 0 5
116603: PUSH
116604: LD_VAR 0 4
116608: PPUSH
116609: LD_VAR 0 7
116613: PPUSH
116614: CALL_OW 74
116618: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116619: LD_VAR 0 7
116623: PPUSH
116624: LD_VAR 0 5
116628: PPUSH
116629: CALL_OW 250
116633: PPUSH
116634: LD_VAR 0 5
116638: PPUSH
116639: CALL_OW 251
116643: PPUSH
116644: CALL_OW 114
// end else
116648: GO 116881
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116650: LD_VAR 0 7
116654: PPUSH
116655: LD_EXP 31
116659: PUSH
116660: LD_VAR 0 1
116664: ARRAY
116665: PPUSH
116666: LD_INT 2
116668: PUSH
116669: LD_INT 30
116671: PUSH
116672: LD_INT 0
116674: PUSH
116675: EMPTY
116676: LIST
116677: LIST
116678: PUSH
116679: LD_INT 30
116681: PUSH
116682: LD_INT 1
116684: PUSH
116685: EMPTY
116686: LIST
116687: LIST
116688: PUSH
116689: LD_INT 30
116691: PUSH
116692: LD_INT 6
116694: PUSH
116695: EMPTY
116696: LIST
116697: LIST
116698: PUSH
116699: EMPTY
116700: LIST
116701: LIST
116702: LIST
116703: LIST
116704: PPUSH
116705: CALL_OW 72
116709: PPUSH
116710: LD_VAR 0 7
116714: PPUSH
116715: CALL_OW 74
116719: PPUSH
116720: CALL_OW 296
116724: PUSH
116725: LD_INT 10
116727: GREATER
116728: IFFALSE 116881
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116730: LD_ADDR_VAR 0 8
116734: PUSH
116735: LD_EXP 31
116739: PUSH
116740: LD_VAR 0 1
116744: ARRAY
116745: PPUSH
116746: LD_INT 2
116748: PUSH
116749: LD_INT 30
116751: PUSH
116752: LD_INT 0
116754: PUSH
116755: EMPTY
116756: LIST
116757: LIST
116758: PUSH
116759: LD_INT 30
116761: PUSH
116762: LD_INT 1
116764: PUSH
116765: EMPTY
116766: LIST
116767: LIST
116768: PUSH
116769: LD_INT 30
116771: PUSH
116772: LD_INT 6
116774: PUSH
116775: EMPTY
116776: LIST
116777: LIST
116778: PUSH
116779: EMPTY
116780: LIST
116781: LIST
116782: LIST
116783: LIST
116784: PPUSH
116785: CALL_OW 72
116789: PPUSH
116790: LD_VAR 0 7
116794: PPUSH
116795: CALL_OW 74
116799: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116800: LD_VAR 0 7
116804: PPUSH
116805: LD_VAR 0 8
116809: PPUSH
116810: CALL_OW 250
116814: PPUSH
116815: LD_INT 3
116817: PPUSH
116818: LD_INT 5
116820: PPUSH
116821: CALL_OW 272
116825: PPUSH
116826: LD_VAR 0 8
116830: PPUSH
116831: CALL_OW 251
116835: PPUSH
116836: LD_INT 3
116838: PPUSH
116839: LD_INT 5
116841: PPUSH
116842: CALL_OW 273
116846: PPUSH
116847: CALL_OW 111
// SetTag ( i , 0 ) ;
116851: LD_VAR 0 7
116855: PPUSH
116856: LD_INT 0
116858: PPUSH
116859: CALL_OW 109
// solds := solds diff i ;
116863: LD_ADDR_VAR 0 2
116867: PUSH
116868: LD_VAR 0 2
116872: PUSH
116873: LD_VAR 0 7
116877: DIFF
116878: ST_TO_ADDR
// continue ;
116879: GO 116561
// end ; end ;
116881: GO 116561
116883: POP
116884: POP
// until not solds or not enemy ;
116885: LD_VAR 0 2
116889: NOT
116890: PUSH
116891: LD_VAR 0 4
116895: NOT
116896: OR
116897: IFFALSE 116465
// MC_Reset ( base , 18 ) ;
116899: LD_VAR 0 1
116903: PPUSH
116904: LD_INT 18
116906: PPUSH
116907: CALL 65223 0 2
// end ;
116911: LD_VAR 0 3
116915: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116916: LD_INT 0
116918: PPUSH
116919: PPUSH
116920: PPUSH
116921: PPUSH
116922: PPUSH
116923: PPUSH
116924: PPUSH
116925: PPUSH
116926: PPUSH
116927: PPUSH
116928: PPUSH
116929: PPUSH
116930: PPUSH
116931: PPUSH
116932: PPUSH
116933: PPUSH
116934: PPUSH
116935: PPUSH
116936: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116937: LD_ADDR_VAR 0 12
116941: PUSH
116942: LD_EXP 31
116946: PUSH
116947: LD_VAR 0 1
116951: ARRAY
116952: PPUSH
116953: LD_INT 25
116955: PUSH
116956: LD_INT 3
116958: PUSH
116959: EMPTY
116960: LIST
116961: LIST
116962: PPUSH
116963: CALL_OW 72
116967: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116968: LD_EXP 71
116972: PUSH
116973: LD_VAR 0 1
116977: ARRAY
116978: IFFALSE 117002
// mechs := mechs diff mc_remote_driver [ base ] ;
116980: LD_ADDR_VAR 0 12
116984: PUSH
116985: LD_VAR 0 12
116989: PUSH
116990: LD_EXP 71
116994: PUSH
116995: LD_VAR 0 1
116999: ARRAY
117000: DIFF
117001: ST_TO_ADDR
// for i in mechs do
117002: LD_ADDR_VAR 0 4
117006: PUSH
117007: LD_VAR 0 12
117011: PUSH
117012: FOR_IN
117013: IFFALSE 117048
// if GetTag ( i ) > 0 then
117015: LD_VAR 0 4
117019: PPUSH
117020: CALL_OW 110
117024: PUSH
117025: LD_INT 0
117027: GREATER
117028: IFFALSE 117046
// mechs := mechs diff i ;
117030: LD_ADDR_VAR 0 12
117034: PUSH
117035: LD_VAR 0 12
117039: PUSH
117040: LD_VAR 0 4
117044: DIFF
117045: ST_TO_ADDR
117046: GO 117012
117048: POP
117049: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117050: LD_ADDR_VAR 0 8
117054: PUSH
117055: LD_EXP 31
117059: PUSH
117060: LD_VAR 0 1
117064: ARRAY
117065: PPUSH
117066: LD_INT 2
117068: PUSH
117069: LD_INT 25
117071: PUSH
117072: LD_INT 1
117074: PUSH
117075: EMPTY
117076: LIST
117077: LIST
117078: PUSH
117079: LD_INT 25
117081: PUSH
117082: LD_INT 5
117084: PUSH
117085: EMPTY
117086: LIST
117087: LIST
117088: PUSH
117089: LD_INT 25
117091: PUSH
117092: LD_INT 8
117094: PUSH
117095: EMPTY
117096: LIST
117097: LIST
117098: PUSH
117099: LD_INT 25
117101: PUSH
117102: LD_INT 9
117104: PUSH
117105: EMPTY
117106: LIST
117107: LIST
117108: PUSH
117109: EMPTY
117110: LIST
117111: LIST
117112: LIST
117113: LIST
117114: LIST
117115: PPUSH
117116: CALL_OW 72
117120: ST_TO_ADDR
// if not defenders and not solds then
117121: LD_VAR 0 2
117125: NOT
117126: PUSH
117127: LD_VAR 0 8
117131: NOT
117132: AND
117133: IFFALSE 117137
// exit ;
117135: GO 118907
// depot_under_attack := false ;
117137: LD_ADDR_VAR 0 16
117141: PUSH
117142: LD_INT 0
117144: ST_TO_ADDR
// sold_defenders := [ ] ;
117145: LD_ADDR_VAR 0 17
117149: PUSH
117150: EMPTY
117151: ST_TO_ADDR
// if mechs then
117152: LD_VAR 0 12
117156: IFFALSE 117309
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117158: LD_ADDR_VAR 0 4
117162: PUSH
117163: LD_VAR 0 2
117167: PPUSH
117168: LD_INT 21
117170: PUSH
117171: LD_INT 2
117173: PUSH
117174: EMPTY
117175: LIST
117176: LIST
117177: PPUSH
117178: CALL_OW 72
117182: PUSH
117183: FOR_IN
117184: IFFALSE 117307
// begin if GetTag ( i ) <> 20 then
117186: LD_VAR 0 4
117190: PPUSH
117191: CALL_OW 110
117195: PUSH
117196: LD_INT 20
117198: NONEQUAL
117199: IFFALSE 117213
// SetTag ( i , 20 ) ;
117201: LD_VAR 0 4
117205: PPUSH
117206: LD_INT 20
117208: PPUSH
117209: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117213: LD_VAR 0 4
117217: PPUSH
117218: CALL_OW 263
117222: PUSH
117223: LD_INT 1
117225: EQUAL
117226: PUSH
117227: LD_VAR 0 4
117231: PPUSH
117232: CALL_OW 311
117236: NOT
117237: AND
117238: IFFALSE 117305
// begin un := mechs [ 1 ] ;
117240: LD_ADDR_VAR 0 10
117244: PUSH
117245: LD_VAR 0 12
117249: PUSH
117250: LD_INT 1
117252: ARRAY
117253: ST_TO_ADDR
// ComExit ( un ) ;
117254: LD_VAR 0 10
117258: PPUSH
117259: CALL 57658 0 1
// AddComEnterUnit ( un , i ) ;
117263: LD_VAR 0 10
117267: PPUSH
117268: LD_VAR 0 4
117272: PPUSH
117273: CALL_OW 180
// SetTag ( un , 19 ) ;
117277: LD_VAR 0 10
117281: PPUSH
117282: LD_INT 19
117284: PPUSH
117285: CALL_OW 109
// mechs := mechs diff un ;
117289: LD_ADDR_VAR 0 12
117293: PUSH
117294: LD_VAR 0 12
117298: PUSH
117299: LD_VAR 0 10
117303: DIFF
117304: ST_TO_ADDR
// end ; end ;
117305: GO 117183
117307: POP
117308: POP
// if solds then
117309: LD_VAR 0 8
117313: IFFALSE 117372
// for i in solds do
117315: LD_ADDR_VAR 0 4
117319: PUSH
117320: LD_VAR 0 8
117324: PUSH
117325: FOR_IN
117326: IFFALSE 117370
// if not GetTag ( i ) then
117328: LD_VAR 0 4
117332: PPUSH
117333: CALL_OW 110
117337: NOT
117338: IFFALSE 117368
// begin defenders := defenders union i ;
117340: LD_ADDR_VAR 0 2
117344: PUSH
117345: LD_VAR 0 2
117349: PUSH
117350: LD_VAR 0 4
117354: UNION
117355: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117356: LD_VAR 0 4
117360: PPUSH
117361: LD_INT 18
117363: PPUSH
117364: CALL_OW 109
// end ;
117368: GO 117325
117370: POP
117371: POP
// repeat wait ( 0 0$2 ) ;
117372: LD_INT 70
117374: PPUSH
117375: CALL_OW 67
// enemy := mc_scan [ base ] ;
117379: LD_ADDR_VAR 0 21
117383: PUSH
117384: LD_EXP 54
117388: PUSH
117389: LD_VAR 0 1
117393: ARRAY
117394: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117395: LD_EXP 31
117399: PUSH
117400: LD_VAR 0 1
117404: ARRAY
117405: NOT
117406: PUSH
117407: LD_EXP 31
117411: PUSH
117412: LD_VAR 0 1
117416: ARRAY
117417: PUSH
117418: EMPTY
117419: EQUAL
117420: OR
117421: IFFALSE 117458
// begin for i in defenders do
117423: LD_ADDR_VAR 0 4
117427: PUSH
117428: LD_VAR 0 2
117432: PUSH
117433: FOR_IN
117434: IFFALSE 117447
// ComStop ( i ) ;
117436: LD_VAR 0 4
117440: PPUSH
117441: CALL_OW 141
117445: GO 117433
117447: POP
117448: POP
// defenders := [ ] ;
117449: LD_ADDR_VAR 0 2
117453: PUSH
117454: EMPTY
117455: ST_TO_ADDR
// exit ;
117456: GO 118907
// end ; for i in defenders do
117458: LD_ADDR_VAR 0 4
117462: PUSH
117463: LD_VAR 0 2
117467: PUSH
117468: FOR_IN
117469: IFFALSE 118367
// begin e := NearestUnitToUnit ( enemy , i ) ;
117471: LD_ADDR_VAR 0 13
117475: PUSH
117476: LD_VAR 0 21
117480: PPUSH
117481: LD_VAR 0 4
117485: PPUSH
117486: CALL_OW 74
117490: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117491: LD_ADDR_VAR 0 7
117495: PUSH
117496: LD_EXP 31
117500: PUSH
117501: LD_VAR 0 1
117505: ARRAY
117506: PPUSH
117507: LD_INT 2
117509: PUSH
117510: LD_INT 30
117512: PUSH
117513: LD_INT 0
117515: PUSH
117516: EMPTY
117517: LIST
117518: LIST
117519: PUSH
117520: LD_INT 30
117522: PUSH
117523: LD_INT 1
117525: PUSH
117526: EMPTY
117527: LIST
117528: LIST
117529: PUSH
117530: EMPTY
117531: LIST
117532: LIST
117533: LIST
117534: PPUSH
117535: CALL_OW 72
117539: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117540: LD_ADDR_VAR 0 16
117544: PUSH
117545: LD_VAR 0 7
117549: NOT
117550: PUSH
117551: LD_VAR 0 7
117555: PPUSH
117556: LD_INT 3
117558: PUSH
117559: LD_INT 24
117561: PUSH
117562: LD_INT 600
117564: PUSH
117565: EMPTY
117566: LIST
117567: LIST
117568: PUSH
117569: EMPTY
117570: LIST
117571: LIST
117572: PPUSH
117573: CALL_OW 72
117577: OR
117578: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117579: LD_VAR 0 4
117583: PPUSH
117584: CALL_OW 247
117588: PUSH
117589: LD_INT 2
117591: DOUBLE
117592: EQUAL
117593: IFTRUE 117597
117595: GO 117993
117597: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117598: LD_VAR 0 4
117602: PPUSH
117603: CALL_OW 256
117607: PUSH
117608: LD_INT 1000
117610: EQUAL
117611: PUSH
117612: LD_VAR 0 4
117616: PPUSH
117617: LD_VAR 0 13
117621: PPUSH
117622: CALL_OW 296
117626: PUSH
117627: LD_INT 40
117629: LESS
117630: PUSH
117631: LD_VAR 0 13
117635: PPUSH
117636: LD_EXP 56
117640: PUSH
117641: LD_VAR 0 1
117645: ARRAY
117646: PPUSH
117647: CALL_OW 308
117651: OR
117652: AND
117653: IFFALSE 117775
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117655: LD_VAR 0 4
117659: PPUSH
117660: CALL_OW 262
117664: PUSH
117665: LD_INT 1
117667: EQUAL
117668: PUSH
117669: LD_VAR 0 4
117673: PPUSH
117674: CALL_OW 261
117678: PUSH
117679: LD_INT 30
117681: LESS
117682: AND
117683: PUSH
117684: LD_VAR 0 7
117688: AND
117689: IFFALSE 117759
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117691: LD_VAR 0 4
117695: PPUSH
117696: LD_VAR 0 7
117700: PPUSH
117701: LD_VAR 0 4
117705: PPUSH
117706: CALL_OW 74
117710: PPUSH
117711: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117715: LD_VAR 0 4
117719: PPUSH
117720: LD_VAR 0 7
117724: PPUSH
117725: LD_VAR 0 4
117729: PPUSH
117730: CALL_OW 74
117734: PPUSH
117735: CALL_OW 296
117739: PUSH
117740: LD_INT 6
117742: LESS
117743: IFFALSE 117757
// SetFuel ( i , 100 ) ;
117745: LD_VAR 0 4
117749: PPUSH
117750: LD_INT 100
117752: PPUSH
117753: CALL_OW 240
// end else
117757: GO 117773
// ComAttackUnit ( i , e ) ;
117759: LD_VAR 0 4
117763: PPUSH
117764: LD_VAR 0 13
117768: PPUSH
117769: CALL_OW 115
// end else
117773: GO 117876
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117775: LD_VAR 0 13
117779: PPUSH
117780: LD_EXP 56
117784: PUSH
117785: LD_VAR 0 1
117789: ARRAY
117790: PPUSH
117791: CALL_OW 308
117795: NOT
117796: PUSH
117797: LD_VAR 0 4
117801: PPUSH
117802: LD_VAR 0 13
117806: PPUSH
117807: CALL_OW 296
117811: PUSH
117812: LD_INT 40
117814: GREATEREQUAL
117815: AND
117816: PUSH
117817: LD_VAR 0 4
117821: PPUSH
117822: CALL_OW 256
117826: PUSH
117827: LD_INT 650
117829: LESSEQUAL
117830: OR
117831: PUSH
117832: LD_VAR 0 4
117836: PPUSH
117837: LD_EXP 55
117841: PUSH
117842: LD_VAR 0 1
117846: ARRAY
117847: PPUSH
117848: CALL_OW 308
117852: NOT
117853: AND
117854: IFFALSE 117876
// ComMoveToArea ( i , mc_parking [ base ] ) ;
117856: LD_VAR 0 4
117860: PPUSH
117861: LD_EXP 55
117865: PUSH
117866: LD_VAR 0 1
117870: ARRAY
117871: PPUSH
117872: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117876: LD_VAR 0 4
117880: PPUSH
117881: CALL_OW 256
117885: PUSH
117886: LD_INT 1000
117888: LESS
117889: PUSH
117890: LD_VAR 0 4
117894: PPUSH
117895: CALL_OW 263
117899: PUSH
117900: LD_INT 1
117902: EQUAL
117903: AND
117904: PUSH
117905: LD_VAR 0 4
117909: PPUSH
117910: CALL_OW 311
117914: AND
117915: PUSH
117916: LD_VAR 0 4
117920: PPUSH
117921: LD_EXP 55
117925: PUSH
117926: LD_VAR 0 1
117930: ARRAY
117931: PPUSH
117932: CALL_OW 308
117936: AND
117937: IFFALSE 117991
// begin mech := IsDrivenBy ( i ) ;
117939: LD_ADDR_VAR 0 9
117943: PUSH
117944: LD_VAR 0 4
117948: PPUSH
117949: CALL_OW 311
117953: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117954: LD_VAR 0 9
117958: PPUSH
117959: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117963: LD_VAR 0 9
117967: PPUSH
117968: LD_VAR 0 4
117972: PPUSH
117973: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117977: LD_VAR 0 9
117981: PPUSH
117982: LD_VAR 0 4
117986: PPUSH
117987: CALL_OW 180
// end ; end ; unit_human :
117991: GO 118338
117993: LD_INT 1
117995: DOUBLE
117996: EQUAL
117997: IFTRUE 118001
117999: GO 118337
118001: POP
// begin b := IsInUnit ( i ) ;
118002: LD_ADDR_VAR 0 18
118006: PUSH
118007: LD_VAR 0 4
118011: PPUSH
118012: CALL_OW 310
118016: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118017: LD_ADDR_VAR 0 19
118021: PUSH
118022: LD_VAR 0 18
118026: NOT
118027: PUSH
118028: LD_VAR 0 18
118032: PPUSH
118033: CALL_OW 266
118037: PUSH
118038: LD_INT 32
118040: PUSH
118041: LD_INT 31
118043: PUSH
118044: EMPTY
118045: LIST
118046: LIST
118047: IN
118048: OR
118049: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118050: LD_VAR 0 18
118054: PPUSH
118055: CALL_OW 266
118059: PUSH
118060: LD_INT 5
118062: EQUAL
118063: PUSH
118064: LD_VAR 0 4
118068: PPUSH
118069: CALL_OW 257
118073: PUSH
118074: LD_INT 1
118076: PUSH
118077: LD_INT 2
118079: PUSH
118080: LD_INT 3
118082: PUSH
118083: LD_INT 4
118085: PUSH
118086: EMPTY
118087: LIST
118088: LIST
118089: LIST
118090: LIST
118091: IN
118092: AND
118093: IFFALSE 118130
// begin class := AllowSpecClass ( i ) ;
118095: LD_ADDR_VAR 0 20
118099: PUSH
118100: LD_VAR 0 4
118104: PPUSH
118105: CALL 21670 0 1
118109: ST_TO_ADDR
// if class then
118110: LD_VAR 0 20
118114: IFFALSE 118130
// ComChangeProfession ( i , class ) ;
118116: LD_VAR 0 4
118120: PPUSH
118121: LD_VAR 0 20
118125: PPUSH
118126: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118130: LD_VAR 0 16
118134: PUSH
118135: LD_VAR 0 2
118139: PPUSH
118140: LD_INT 21
118142: PUSH
118143: LD_INT 2
118145: PUSH
118146: EMPTY
118147: LIST
118148: LIST
118149: PPUSH
118150: CALL_OW 72
118154: PUSH
118155: LD_INT 1
118157: LESSEQUAL
118158: OR
118159: PUSH
118160: LD_VAR 0 19
118164: AND
118165: PUSH
118166: LD_VAR 0 4
118170: PUSH
118171: LD_VAR 0 17
118175: IN
118176: NOT
118177: AND
118178: IFFALSE 118271
// begin if b then
118180: LD_VAR 0 18
118184: IFFALSE 118233
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118186: LD_VAR 0 18
118190: PPUSH
118191: LD_VAR 0 21
118195: PPUSH
118196: LD_VAR 0 18
118200: PPUSH
118201: CALL_OW 74
118205: PPUSH
118206: CALL_OW 296
118210: PUSH
118211: LD_INT 10
118213: LESS
118214: PUSH
118215: LD_VAR 0 18
118219: PPUSH
118220: CALL_OW 461
118224: PUSH
118225: LD_INT 7
118227: NONEQUAL
118228: AND
118229: IFFALSE 118233
// continue ;
118231: GO 117468
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118233: LD_ADDR_VAR 0 17
118237: PUSH
118238: LD_VAR 0 17
118242: PPUSH
118243: LD_VAR 0 17
118247: PUSH
118248: LD_INT 1
118250: PLUS
118251: PPUSH
118252: LD_VAR 0 4
118256: PPUSH
118257: CALL_OW 1
118261: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118262: LD_VAR 0 4
118266: PPUSH
118267: CALL_OW 122
// end ; if sold_defenders then
118271: LD_VAR 0 17
118275: IFFALSE 118335
// if i in sold_defenders then
118277: LD_VAR 0 4
118281: PUSH
118282: LD_VAR 0 17
118286: IN
118287: IFFALSE 118335
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118289: LD_VAR 0 4
118293: PPUSH
118294: CALL_OW 314
118298: NOT
118299: PUSH
118300: LD_VAR 0 4
118304: PPUSH
118305: LD_VAR 0 13
118309: PPUSH
118310: CALL_OW 296
118314: PUSH
118315: LD_INT 30
118317: LESS
118318: AND
118319: IFFALSE 118335
// ComAttackUnit ( i , e ) ;
118321: LD_VAR 0 4
118325: PPUSH
118326: LD_VAR 0 13
118330: PPUSH
118331: CALL_OW 115
// end ; end ; end ;
118335: GO 118338
118337: POP
// if IsDead ( i ) then
118338: LD_VAR 0 4
118342: PPUSH
118343: CALL_OW 301
118347: IFFALSE 118365
// defenders := defenders diff i ;
118349: LD_ADDR_VAR 0 2
118353: PUSH
118354: LD_VAR 0 2
118358: PUSH
118359: LD_VAR 0 4
118363: DIFF
118364: ST_TO_ADDR
// end ;
118365: GO 117468
118367: POP
118368: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118369: LD_VAR 0 21
118373: NOT
118374: PUSH
118375: LD_VAR 0 2
118379: NOT
118380: OR
118381: PUSH
118382: LD_EXP 31
118386: PUSH
118387: LD_VAR 0 1
118391: ARRAY
118392: NOT
118393: OR
118394: IFFALSE 117372
// MC_Reset ( base , 18 ) ;
118396: LD_VAR 0 1
118400: PPUSH
118401: LD_INT 18
118403: PPUSH
118404: CALL 65223 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118408: LD_ADDR_VAR 0 2
118412: PUSH
118413: LD_VAR 0 2
118417: PUSH
118418: LD_VAR 0 2
118422: PPUSH
118423: LD_INT 2
118425: PUSH
118426: LD_INT 25
118428: PUSH
118429: LD_INT 1
118431: PUSH
118432: EMPTY
118433: LIST
118434: LIST
118435: PUSH
118436: LD_INT 25
118438: PUSH
118439: LD_INT 5
118441: PUSH
118442: EMPTY
118443: LIST
118444: LIST
118445: PUSH
118446: LD_INT 25
118448: PUSH
118449: LD_INT 8
118451: PUSH
118452: EMPTY
118453: LIST
118454: LIST
118455: PUSH
118456: LD_INT 25
118458: PUSH
118459: LD_INT 9
118461: PUSH
118462: EMPTY
118463: LIST
118464: LIST
118465: PUSH
118466: EMPTY
118467: LIST
118468: LIST
118469: LIST
118470: LIST
118471: LIST
118472: PPUSH
118473: CALL_OW 72
118477: DIFF
118478: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118479: LD_VAR 0 21
118483: NOT
118484: PUSH
118485: LD_VAR 0 2
118489: PPUSH
118490: LD_INT 21
118492: PUSH
118493: LD_INT 2
118495: PUSH
118496: EMPTY
118497: LIST
118498: LIST
118499: PPUSH
118500: CALL_OW 72
118504: AND
118505: IFFALSE 118843
// begin tmp := FilterByTag ( defenders , 19 ) ;
118507: LD_ADDR_VAR 0 11
118511: PUSH
118512: LD_VAR 0 2
118516: PPUSH
118517: LD_INT 19
118519: PPUSH
118520: CALL 54834 0 2
118524: ST_TO_ADDR
// if tmp then
118525: LD_VAR 0 11
118529: IFFALSE 118599
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118531: LD_ADDR_VAR 0 11
118535: PUSH
118536: LD_VAR 0 11
118540: PPUSH
118541: LD_INT 25
118543: PUSH
118544: LD_INT 3
118546: PUSH
118547: EMPTY
118548: LIST
118549: LIST
118550: PPUSH
118551: CALL_OW 72
118555: ST_TO_ADDR
// if tmp then
118556: LD_VAR 0 11
118560: IFFALSE 118599
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118562: LD_ADDR_EXP 43
118566: PUSH
118567: LD_EXP 43
118571: PPUSH
118572: LD_VAR 0 1
118576: PPUSH
118577: LD_EXP 43
118581: PUSH
118582: LD_VAR 0 1
118586: ARRAY
118587: PUSH
118588: LD_VAR 0 11
118592: UNION
118593: PPUSH
118594: CALL_OW 1
118598: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118599: LD_VAR 0 1
118603: PPUSH
118604: LD_INT 19
118606: PPUSH
118607: CALL 65223 0 2
// repeat wait ( 0 0$1 ) ;
118611: LD_INT 35
118613: PPUSH
118614: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118618: LD_EXP 31
118622: PUSH
118623: LD_VAR 0 1
118627: ARRAY
118628: NOT
118629: PUSH
118630: LD_EXP 31
118634: PUSH
118635: LD_VAR 0 1
118639: ARRAY
118640: PUSH
118641: EMPTY
118642: EQUAL
118643: OR
118644: IFFALSE 118681
// begin for i in defenders do
118646: LD_ADDR_VAR 0 4
118650: PUSH
118651: LD_VAR 0 2
118655: PUSH
118656: FOR_IN
118657: IFFALSE 118670
// ComStop ( i ) ;
118659: LD_VAR 0 4
118663: PPUSH
118664: CALL_OW 141
118668: GO 118656
118670: POP
118671: POP
// defenders := [ ] ;
118672: LD_ADDR_VAR 0 2
118676: PUSH
118677: EMPTY
118678: ST_TO_ADDR
// exit ;
118679: GO 118907
// end ; for i in defenders do
118681: LD_ADDR_VAR 0 4
118685: PUSH
118686: LD_VAR 0 2
118690: PUSH
118691: FOR_IN
118692: IFFALSE 118781
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118694: LD_VAR 0 4
118698: PPUSH
118699: LD_EXP 55
118703: PUSH
118704: LD_VAR 0 1
118708: ARRAY
118709: PPUSH
118710: CALL_OW 308
118714: NOT
118715: IFFALSE 118739
// ComMoveToArea ( i , mc_parking [ base ] ) else
118717: LD_VAR 0 4
118721: PPUSH
118722: LD_EXP 55
118726: PUSH
118727: LD_VAR 0 1
118731: ARRAY
118732: PPUSH
118733: CALL_OW 113
118737: GO 118779
// if GetControl ( i ) = control_manual then
118739: LD_VAR 0 4
118743: PPUSH
118744: CALL_OW 263
118748: PUSH
118749: LD_INT 1
118751: EQUAL
118752: IFFALSE 118779
// if IsDrivenBy ( i ) then
118754: LD_VAR 0 4
118758: PPUSH
118759: CALL_OW 311
118763: IFFALSE 118779
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118765: LD_VAR 0 4
118769: PPUSH
118770: CALL_OW 311
118774: PPUSH
118775: CALL_OW 121
// end ;
118779: GO 118691
118781: POP
118782: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118783: LD_VAR 0 2
118787: PPUSH
118788: LD_INT 95
118790: PUSH
118791: LD_EXP 55
118795: PUSH
118796: LD_VAR 0 1
118800: ARRAY
118801: PUSH
118802: EMPTY
118803: LIST
118804: LIST
118805: PPUSH
118806: CALL_OW 72
118810: PUSH
118811: LD_VAR 0 2
118815: EQUAL
118816: PUSH
118817: LD_EXP 54
118821: PUSH
118822: LD_VAR 0 1
118826: ARRAY
118827: OR
118828: PUSH
118829: LD_EXP 31
118833: PUSH
118834: LD_VAR 0 1
118838: ARRAY
118839: NOT
118840: OR
118841: IFFALSE 118611
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
118843: LD_ADDR_EXP 53
118847: PUSH
118848: LD_EXP 53
118852: PPUSH
118853: LD_VAR 0 1
118857: PPUSH
118858: LD_VAR 0 2
118862: PPUSH
118863: LD_INT 21
118865: PUSH
118866: LD_INT 2
118868: PUSH
118869: EMPTY
118870: LIST
118871: LIST
118872: PPUSH
118873: CALL_OW 72
118877: PPUSH
118878: CALL_OW 1
118882: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118883: LD_VAR 0 1
118887: PPUSH
118888: LD_INT 19
118890: PPUSH
118891: CALL 65223 0 2
// MC_Reset ( base , 20 ) ;
118895: LD_VAR 0 1
118899: PPUSH
118900: LD_INT 20
118902: PPUSH
118903: CALL 65223 0 2
// end ; end_of_file
118907: LD_VAR 0 3
118911: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118912: LD_VAR 0 1
118916: PUSH
118917: LD_INT 200
118919: DOUBLE
118920: GREATEREQUAL
118921: IFFALSE 118929
118923: LD_INT 299
118925: DOUBLE
118926: LESSEQUAL
118927: IFTRUE 118931
118929: GO 118963
118931: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118932: LD_VAR 0 1
118936: PPUSH
118937: LD_VAR 0 2
118941: PPUSH
118942: LD_VAR 0 3
118946: PPUSH
118947: LD_VAR 0 4
118951: PPUSH
118952: LD_VAR 0 5
118956: PPUSH
118957: CALL 107698 0 5
118961: GO 119040
118963: LD_INT 300
118965: DOUBLE
118966: GREATEREQUAL
118967: IFFALSE 118975
118969: LD_INT 399
118971: DOUBLE
118972: LESSEQUAL
118973: IFTRUE 118977
118975: GO 119039
118977: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118978: LD_VAR 0 1
118982: PPUSH
118983: LD_VAR 0 2
118987: PPUSH
118988: LD_VAR 0 3
118992: PPUSH
118993: LD_VAR 0 4
118997: PPUSH
118998: LD_VAR 0 5
119002: PPUSH
119003: LD_VAR 0 6
119007: PPUSH
119008: LD_VAR 0 7
119012: PPUSH
119013: LD_VAR 0 8
119017: PPUSH
119018: LD_VAR 0 9
119022: PPUSH
119023: LD_VAR 0 10
119027: PPUSH
119028: LD_VAR 0 11
119032: PPUSH
119033: CALL 104031 0 11
119037: GO 119040
119039: POP
// end ;
119040: PPOPN 11
119042: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119043: LD_VAR 0 1
119047: PPUSH
119048: LD_VAR 0 2
119052: PPUSH
119053: LD_VAR 0 3
119057: PPUSH
119058: LD_VAR 0 4
119062: PPUSH
119063: LD_VAR 0 5
119067: PPUSH
119068: CALL 107434 0 5
// end ; end_of_file
119072: PPOPN 5
119074: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119075: LD_VAR 0 1
119079: PPUSH
119080: LD_VAR 0 2
119084: PPUSH
119085: LD_VAR 0 3
119089: PPUSH
119090: LD_VAR 0 4
119094: PPUSH
119095: LD_VAR 0 5
119099: PPUSH
119100: LD_VAR 0 6
119104: PPUSH
119105: CALL 91724 0 6
// end ;
119109: PPOPN 6
119111: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119112: LD_INT 0
119114: PPUSH
// begin if not units then
119115: LD_VAR 0 1
119119: NOT
119120: IFFALSE 119124
// exit ;
119122: GO 119124
// end ;
119124: PPOPN 7
119126: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119127: CALL 91695 0 0
// end ;
119131: PPOPN 1
119133: END
