// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 573 0 0
// SetDiplomacy ;
  42: CALL 785 0 0
// PrepareGame ;
  46: CALL 867 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := false ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 1 trigger cratesSpawns and game and GameType = 1 do
 229: LD_EXP 19
 233: IFFALSE 241
 235: PUSH
 236: LD_EXP 3
 240: AND
 241: IFFALSE 253
 243: PUSH
 244: LD_EXP 2
 248: PUSH
 249: LD_INT 1
 251: EQUAL
 252: AND
 253: IFFALSE 314
 255: GO 257
 257: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 258: LD_EXP 19
 262: PUSH
 263: LD_INT 1
 265: ARRAY
 266: PUSH
 267: LD_INT 1
 269: ARRAY
 270: PPUSH
 271: LD_EXP 19
 275: PUSH
 276: LD_INT 1
 278: ARRAY
 279: PUSH
 280: LD_INT 2
 282: ARRAY
 283: PPUSH
 284: LD_EXP 19
 288: PUSH
 289: LD_INT 1
 291: ARRAY
 292: PUSH
 293: LD_INT 3
 295: ARRAY
 296: PPUSH
 297: LD_EXP 19
 301: PUSH
 302: LD_INT 1
 304: ARRAY
 305: PUSH
 306: LD_INT 4
 308: ARRAY
 309: PPUSH
 310: CALL 57471 0 4
 314: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 315: LD_EXP 19
 319: IFFALSE 327
 321: PUSH
 322: LD_EXP 3
 326: AND
 327: IFFALSE 339
 329: PUSH
 330: LD_EXP 2
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: IFFALSE 400
 341: GO 343
 343: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 344: LD_EXP 19
 348: PUSH
 349: LD_INT 2
 351: ARRAY
 352: PUSH
 353: LD_INT 1
 355: ARRAY
 356: PPUSH
 357: LD_EXP 19
 361: PUSH
 362: LD_INT 2
 364: ARRAY
 365: PUSH
 366: LD_INT 2
 368: ARRAY
 369: PPUSH
 370: LD_EXP 19
 374: PUSH
 375: LD_INT 2
 377: ARRAY
 378: PUSH
 379: LD_INT 3
 381: ARRAY
 382: PPUSH
 383: LD_EXP 19
 387: PUSH
 388: LD_INT 2
 390: ARRAY
 391: PUSH
 392: LD_INT 4
 394: ARRAY
 395: PPUSH
 396: CALL 57471 0 4
 400: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 401: LD_EXP 19
 405: IFFALSE 413
 407: PUSH
 408: LD_EXP 3
 412: AND
 413: IFFALSE 425
 415: PUSH
 416: LD_EXP 2
 420: PUSH
 421: LD_INT 1
 423: EQUAL
 424: AND
 425: IFFALSE 486
 427: GO 429
 429: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 430: LD_EXP 19
 434: PUSH
 435: LD_INT 3
 437: ARRAY
 438: PUSH
 439: LD_INT 1
 441: ARRAY
 442: PPUSH
 443: LD_EXP 19
 447: PUSH
 448: LD_INT 3
 450: ARRAY
 451: PUSH
 452: LD_INT 2
 454: ARRAY
 455: PPUSH
 456: LD_EXP 19
 460: PUSH
 461: LD_INT 3
 463: ARRAY
 464: PUSH
 465: LD_INT 3
 467: ARRAY
 468: PPUSH
 469: LD_EXP 19
 473: PUSH
 474: LD_INT 3
 476: ARRAY
 477: PUSH
 478: LD_INT 4
 480: ARRAY
 481: PPUSH
 482: CALL 57471 0 4
 486: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 487: LD_EXP 19
 491: IFFALSE 499
 493: PUSH
 494: LD_EXP 3
 498: AND
 499: IFFALSE 511
 501: PUSH
 502: LD_EXP 2
 506: PUSH
 507: LD_INT 1
 509: EQUAL
 510: AND
 511: IFFALSE 572
 513: GO 515
 515: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 516: LD_EXP 19
 520: PUSH
 521: LD_INT 4
 523: ARRAY
 524: PUSH
 525: LD_INT 1
 527: ARRAY
 528: PPUSH
 529: LD_EXP 19
 533: PUSH
 534: LD_INT 4
 536: ARRAY
 537: PUSH
 538: LD_INT 2
 540: ARRAY
 541: PPUSH
 542: LD_EXP 19
 546: PUSH
 547: LD_INT 4
 549: ARRAY
 550: PUSH
 551: LD_INT 3
 553: ARRAY
 554: PPUSH
 555: LD_EXP 19
 559: PUSH
 560: LD_INT 4
 562: ARRAY
 563: PUSH
 564: LD_INT 4
 566: ARRAY
 567: PPUSH
 568: CALL 57471 0 4
 572: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 573: LD_INT 0
 575: PPUSH
 576: PPUSH
 577: PPUSH
 578: PPUSH
 579: PPUSH
// if GameType = 1 then
 580: LD_EXP 2
 584: PUSH
 585: LD_INT 1
 587: EQUAL
 588: IFFALSE 657
// begin ban_techs := [ ] ;
 590: LD_ADDR_VAR 0 4
 594: PUSH
 595: EMPTY
 596: ST_TO_ADDR
// if sibBombAllowed < 2 then
 597: LD_EXP 23
 601: PUSH
 602: LD_INT 2
 604: LESS
 605: IFFALSE 618
// ban_techs := [ tech_sibFiss ] ;
 607: LD_ADDR_VAR 0 4
 611: PUSH
 612: LD_INT 25
 614: PUSH
 615: EMPTY
 616: LIST
 617: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 618: LD_ADDR_VAR 0 5
 622: PUSH
 623: LD_INT 46
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: LD_INT 48
 631: PUSH
 632: LD_INT 49
 634: PUSH
 635: LD_INT 50
 637: PUSH
 638: LD_INT 39
 640: PUSH
 641: LD_INT 69
 643: PUSH
 644: LD_INT 40
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: ST_TO_ADDR
// end ; for i = 1 to 8 do
 657: LD_ADDR_VAR 0 2
 661: PUSH
 662: DOUBLE
 663: LD_INT 1
 665: DEC
 666: ST_TO_ADDR
 667: LD_INT 8
 669: PUSH
 670: FOR_TO
 671: IFFALSE 755
// begin if res_techs then
 673: LD_VAR 0 5
 677: IFFALSE 713
// for j in res_techs do
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 5
 688: PUSH
 689: FOR_IN
 690: IFFALSE 711
// SetTech ( j , i , state_researched ) ;
 692: LD_VAR 0 3
 696: PPUSH
 697: LD_VAR 0 2
 701: PPUSH
 702: LD_INT 2
 704: PPUSH
 705: CALL_OW 322
 709: GO 689
 711: POP
 712: POP
// if ban_techs then
 713: LD_VAR 0 4
 717: IFFALSE 753
// for j in ban_techs do
 719: LD_ADDR_VAR 0 3
 723: PUSH
 724: LD_VAR 0 4
 728: PUSH
 729: FOR_IN
 730: IFFALSE 751
// SetTech ( j , i , state_disabled ) ;
 732: LD_VAR 0 3
 736: PPUSH
 737: LD_VAR 0 2
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 322
 749: GO 729
 751: POP
 752: POP
// end ;
 753: GO 670
 755: POP
 756: POP
// if sibBombAllowed = 1 then
 757: LD_EXP 23
 761: PUSH
 762: LD_INT 1
 764: EQUAL
 765: IFFALSE 780
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 767: LD_INT 25
 769: PPUSH
 770: LD_INT 3
 772: PPUSH
 773: LD_INT 1
 775: PPUSH
 776: CALL_OW 322
// end ;
 780: LD_VAR 0 1
 784: RET
// export function SetDiplomacy ; begin
 785: LD_INT 0
 787: PPUSH
// if GameType = 1 then
 788: LD_EXP 2
 792: PUSH
 793: LD_INT 1
 795: EQUAL
 796: IFFALSE 862
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 798: LD_INT 1
 800: PPUSH
 801: LD_INT 4
 803: PPUSH
 804: LD_INT 1
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 814: LD_INT 3
 816: PPUSH
 817: LD_INT 6
 819: PPUSH
 820: LD_INT 1
 822: PPUSH
 823: LD_INT 1
 825: PPUSH
 826: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 830: LD_INT 3
 832: PPUSH
 833: LD_INT 8
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 8
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: CALL_OW 80
// end ; end ;
 862: LD_VAR 0 1
 866: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 867: LD_INT 0
 869: PPUSH
 870: PPUSH
 871: PPUSH
 872: PPUSH
// if GameType = 1 then
 873: LD_EXP 2
 877: PUSH
 878: LD_INT 1
 880: EQUAL
 881: IFFALSE 1377
// begin game := false ;
 883: LD_ADDR_EXP 3
 887: PUSH
 888: LD_INT 0
 890: ST_TO_ADDR
// your_side := 1 ;
 891: LD_ADDR_OWVAR 2
 895: PUSH
 896: LD_INT 1
 898: ST_TO_ADDR
// mc_amer := 1 ;
 899: LD_ADDR_EXP 5
 903: PUSH
 904: LD_INT 1
 906: ST_TO_ADDR
// mc_leg := 2 ;
 907: LD_ADDR_EXP 6
 911: PUSH
 912: LD_INT 2
 914: ST_TO_ADDR
// mc_rus_1 := 3 ;
 915: LD_ADDR_EXP 7
 919: PUSH
 920: LD_INT 3
 922: ST_TO_ADDR
// mc_rus_2 := 4 ;
 923: LD_ADDR_EXP 8
 927: PUSH
 928: LD_INT 4
 930: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 931: LD_ADDR_EXP 19
 935: PUSH
 936: LD_INT 5
 938: PUSH
 939: LD_INT 1
 941: PUSH
 942: LD_INT 0
 944: PUSH
 945: LD_INT 200
 947: PUSH
 948: LD_INT 250
 950: PUSH
 951: LD_INT 300
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: LIST
 958: PUSH
 959: LD_EXP 26
 963: ARRAY
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: LIST
 969: LIST
 970: PUSH
 971: LD_INT 13
 973: PUSH
 974: LD_INT 8
 976: PUSH
 977: LD_INT 50
 979: PUSH
 980: LD_INT 500
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: LIST
 988: PUSH
 989: LD_INT 17
 991: PUSH
 992: LD_INT 5
 994: PUSH
 995: LD_INT 50
 997: PUSH
 998: LD_INT 300
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 18
1009: PUSH
1010: LD_INT 4
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 6
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: PUSH
1024: LD_EXP 26
1028: ARRAY
1029: PUSH
1030: LD_INT 30
1032: PUSH
1033: LD_INT 300
1035: PUSH
1036: LD_INT 450
1038: PUSH
1039: LD_INT 500
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_EXP 26
1051: ARRAY
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: LD_INT 190
1072: PUSH
1073: LD_INT 193
1075: PUSH
1076: LD_INT 3
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 182
1086: PUSH
1087: LD_INT 117
1089: PUSH
1090: LD_INT 3
1092: PUSH
1093: EMPTY
1094: LIST
1095: LIST
1096: LIST
1097: PUSH
1098: LD_INT 43
1100: PUSH
1101: LD_INT 2
1103: PUSH
1104: LD_INT 3
1106: PUSH
1107: EMPTY
1108: LIST
1109: LIST
1110: LIST
1111: PUSH
1112: LD_INT 114
1114: PUSH
1115: LD_INT 152
1117: PUSH
1118: LD_INT 2
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 85
1128: PUSH
1129: LD_INT 38
1131: PUSH
1132: LD_INT 2
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: ST_TO_ADDR
// for i in sources do
1147: LD_ADDR_VAR 0 2
1151: PUSH
1152: LD_VAR 0 4
1156: PUSH
1157: FOR_IN
1158: IFFALSE 1193
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1160: LD_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: ARRAY
1168: PPUSH
1169: LD_VAR 0 2
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: LD_VAR 0 2
1182: PUSH
1183: LD_INT 3
1185: ARRAY
1186: PPUSH
1187: CALL_OW 62
1191: GO 1157
1193: POP
1194: POP
// disableGlobalTimer := false ;
1195: LD_ADDR_EXP 4
1199: PUSH
1200: LD_INT 0
1202: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1203: LD_ADDR_EXP 15
1207: PUSH
1208: LD_INT 0
1210: PUSH
1211: LD_INT 5
1213: PUSH
1214: LD_INT 6
1216: PUSH
1217: LD_INT 7
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_OWVAR 67
1229: ARRAY
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: ST_TO_ADDR
// ruOutpost := [ ] ;
1235: LD_ADDR_EXP 14
1239: PUSH
1240: EMPTY
1241: ST_TO_ADDR
// staticMines := [ ] ;
1242: LD_ADDR_EXP 16
1246: PUSH
1247: EMPTY
1248: ST_TO_ADDR
// baseCaptured := false ;
1249: LD_ADDR_EXP 17
1253: PUSH
1254: LD_INT 0
1256: ST_TO_ADDR
// legDestCounter := 0 ;
1257: LD_ADDR_EXP 18
1261: PUSH
1262: LD_INT 0
1264: ST_TO_ADDR
// legOfferAccepted := false ;
1265: LD_ADDR_EXP 20
1269: PUSH
1270: LD_INT 0
1272: ST_TO_ADDR
// legChangeSide := false ;
1273: LD_ADDR_EXP 21
1277: PUSH
1278: LD_INT 0
1280: ST_TO_ADDR
// allyDestCounter := 0 ;
1281: LD_ADDR_EXP 22
1285: PUSH
1286: LD_INT 0
1288: ST_TO_ADDR
// outpostEscape := false ;
1289: LD_ADDR_EXP 27
1293: PUSH
1294: LD_INT 0
1296: ST_TO_ADDR
// dialogueMineDetected := false ;
1297: LD_ADDR_EXP 28
1301: PUSH
1302: LD_INT 0
1304: ST_TO_ADDR
// PrepareAmericans ;
1305: CALL 7575 0 0
// PrepareLegion ;
1309: CALL 5509 0 0
// PrepareRussians ;
1313: CALL 2475 0 0
// playerForces := PreparePlayer ;
1317: LD_ADDR_EXP 10
1321: PUSH
1322: CALL 8818 0 0
1326: ST_TO_ADDR
// AnimateTrees ( true ) ;
1327: LD_INT 1
1329: PPUSH
1330: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 3
1339: PPUSH
1340: LD_INT 8
1342: PPUSH
1343: LD_INT 5
1345: PPUSH
1346: LD_INT 3
1348: PPUSH
1349: LD_INT 1
1351: PPUSH
1352: LD_INT 8
1354: PPUSH
1355: LD_INT 2
1357: PPUSH
1358: LD_INT 1
1360: PPUSH
1361: CALL 54806 0 9
// MC_Start ;
1365: CALL 65689 0 0
// SetAdditionalRussianForces ;
1369: CALL 7244 0 0
// Action ;
1373: CALL 11177 0 0
// end ; end ;
1377: LD_VAR 0 1
1381: RET
// export function CustomInitMacro ; begin
1382: LD_INT 0
1384: PPUSH
// if GameType <> 1 then
1385: LD_EXP 2
1389: PUSH
1390: LD_INT 1
1392: NONEQUAL
1393: IFFALSE 1397
// exit ;
1395: GO 2470
// MC_SetScanArea ( mc_amer , amerBase ) ;
1397: LD_EXP 5
1401: PPUSH
1402: LD_INT 3
1404: PPUSH
1405: CALL 89352 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1409: LD_EXP 5
1413: PPUSH
1414: LD_INT 4
1416: PPUSH
1417: CALL 89292 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1421: LD_EXP 5
1425: PPUSH
1426: LD_INT 11
1428: PUSH
1429: LD_INT 6
1431: PUSH
1432: LD_INT 7
1434: PUSH
1435: LD_INT 9
1437: PUSH
1438: LD_INT 10
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: PPUSH
1448: CALL 89172 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1452: LD_EXP 5
1456: PPUSH
1457: LD_INT 5
1459: PPUSH
1460: CALL 88842 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1464: LD_EXP 5
1468: PPUSH
1469: LD_INT 3
1471: PPUSH
1472: CALL 88565 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1476: LD_EXP 5
1480: PPUSH
1481: LD_INT 4
1483: PPUSH
1484: CALL 88184 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1488: LD_EXP 5
1492: PPUSH
1493: LD_INT 3
1495: PUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 2
1501: PUSH
1502: LD_INT 5
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: LIST
1509: LIST
1510: PUSH
1511: LD_INT 3
1513: PUSH
1514: LD_INT 2
1516: PUSH
1517: LD_INT 2
1519: PUSH
1520: LD_INT 9
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: PUSH
1529: LD_INT 4
1531: PUSH
1532: LD_INT 1
1534: PUSH
1535: LD_INT 2
1537: PUSH
1538: LD_INT 7
1540: PUSH
1541: EMPTY
1542: LIST
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 4
1549: PUSH
1550: LD_INT 1
1552: PUSH
1553: LD_INT 2
1555: PUSH
1556: LD_INT 6
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: LIST
1563: LIST
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: LIST
1569: LIST
1570: PPUSH
1571: CALL 87999 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1575: LD_EXP 5
1579: PPUSH
1580: LD_INT 33
1582: PUSH
1583: LD_INT 114
1585: PUSH
1586: LD_INT 16
1588: PUSH
1589: LD_INT 0
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: LIST
1597: PUSH
1598: LD_INT 32
1600: PUSH
1601: LD_INT 110
1603: PUSH
1604: LD_INT 12
1606: PUSH
1607: LD_INT 0
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: PUSH
1616: EMPTY
1617: LIST
1618: LIST
1619: PPUSH
1620: CALL 87891 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1624: LD_EXP 5
1628: PPUSH
1629: LD_INT 10
1631: PUSH
1632: LD_INT 15
1634: PUSH
1635: LD_INT 12
1637: PUSH
1638: LD_INT 11
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: PPUSH
1647: CALL 88745 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1651: LD_EXP 6
1655: PPUSH
1656: LD_INT 6
1658: PPUSH
1659: CALL 89352 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1663: LD_EXP 6
1667: PPUSH
1668: LD_INT 7
1670: PPUSH
1671: CALL 89292 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1675: LD_EXP 6
1679: PPUSH
1680: LD_INT 30
1682: PUSH
1683: LD_INT 27
1685: PUSH
1686: LD_INT 28
1688: PUSH
1689: LD_INT 25
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: PPUSH
1698: CALL 89172 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1702: LD_EXP 6
1706: PPUSH
1707: LD_INT 17
1709: PPUSH
1710: CALL 88842 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1714: LD_EXP 6
1718: PPUSH
1719: LD_INT 6
1721: PPUSH
1722: CALL 88565 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1726: LD_EXP 6
1730: PPUSH
1731: LD_INT 5
1733: PPUSH
1734: CALL 88184 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1738: LD_EXP 6
1742: PPUSH
1743: LD_INT 10
1745: PPUSH
1746: LD_INT 9
1748: PPUSH
1749: CALL 87662 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1753: LD_EXP 6
1757: PPUSH
1758: LD_INT 4
1760: PUSH
1761: LD_INT 157
1763: PUSH
1764: LD_INT 144
1766: PUSH
1767: LD_INT 0
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: PUSH
1776: LD_INT 32
1778: PUSH
1779: LD_INT 151
1781: PUSH
1782: LD_INT 142
1784: PUSH
1785: LD_INT 0
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 32
1796: PUSH
1797: LD_INT 161
1799: PUSH
1800: LD_INT 144
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: PUSH
1812: LD_INT 32
1814: PUSH
1815: LD_INT 140
1817: PUSH
1818: LD_INT 133
1820: PUSH
1821: LD_INT 0
1823: PUSH
1824: EMPTY
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL 87891 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1840: LD_EXP 6
1844: PPUSH
1845: LD_INT 13
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 31
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: PUSH
1863: LD_INT 13
1865: PUSH
1866: LD_INT 2
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 31
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: PUSH
1881: LD_INT 13
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: LD_INT 1
1889: PUSH
1890: LD_INT 27
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: PUSH
1899: LD_INT 13
1901: PUSH
1902: LD_INT 1
1904: PUSH
1905: LD_INT 2
1907: PUSH
1908: LD_INT 27
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: PUSH
1917: LD_INT 13
1919: PUSH
1920: LD_INT 1
1922: PUSH
1923: LD_INT 2
1925: PUSH
1926: LD_INT 27
1928: PUSH
1929: EMPTY
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: PUSH
1935: LD_INT 13
1937: PUSH
1938: LD_INT 1
1940: PUSH
1941: LD_INT 2
1943: PUSH
1944: LD_INT 28
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: PUSH
1953: LD_INT 13
1955: PUSH
1956: LD_INT 1
1958: PUSH
1959: LD_INT 2
1961: PUSH
1962: LD_INT 28
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: LIST
1969: LIST
1970: PUSH
1971: LD_INT 13
1973: PUSH
1974: LD_INT 1
1976: PUSH
1977: LD_INT 2
1979: PUSH
1980: LD_INT 32
1982: PUSH
1983: EMPTY
1984: LIST
1985: LIST
1986: LIST
1987: LIST
1988: PUSH
1989: LD_INT 13
1991: PUSH
1992: LD_INT 1
1994: PUSH
1995: LD_INT 2
1997: PUSH
1998: LD_INT 88
2000: PUSH
2001: EMPTY
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: PUSH
2007: EMPTY
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PPUSH
2018: CALL 87999 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2022: LD_INT 165
2024: PPUSH
2025: LD_INT 156
2027: PPUSH
2028: LD_INT 8
2030: PPUSH
2031: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2035: LD_EXP 7
2039: PPUSH
2040: LD_INT 15
2042: PPUSH
2043: CALL 89352 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2047: LD_EXP 7
2051: PPUSH
2052: LD_INT 16
2054: PPUSH
2055: CALL 89292 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2059: LD_EXP 7
2063: PPUSH
2064: LD_INT 43
2066: PUSH
2067: LD_INT 47
2069: PUSH
2070: LD_INT 45
2072: PUSH
2073: LD_INT 49
2075: PUSH
2076: LD_INT 46
2078: PUSH
2079: EMPTY
2080: LIST
2081: LIST
2082: LIST
2083: LIST
2084: LIST
2085: PPUSH
2086: CALL 89172 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2090: LD_EXP 7
2094: PPUSH
2095: LD_INT 13
2097: PPUSH
2098: CALL 88842 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2102: LD_EXP 7
2106: PPUSH
2107: LD_INT 15
2109: PPUSH
2110: CALL 88565 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2114: LD_EXP 7
2118: PPUSH
2119: LD_INT 5
2121: PPUSH
2122: CALL 88184 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2126: LD_EXP 7
2130: PPUSH
2131: LD_INT 23
2133: PUSH
2134: LD_INT 1
2136: PUSH
2137: LD_INT 3
2139: PUSH
2140: LD_INT 46
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: PUSH
2149: LD_INT 23
2151: PUSH
2152: LD_INT 1
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 46
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PUSH
2167: LD_INT 23
2169: PUSH
2170: LD_INT 1
2172: PUSH
2173: LD_INT 3
2175: PUSH
2176: LD_INT 45
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 1
2190: PUSH
2191: LD_INT 1
2193: PUSH
2194: LD_INT 47
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: LIST
2201: LIST
2202: PUSH
2203: LD_INT 23
2205: PUSH
2206: LD_INT 1
2208: PUSH
2209: LD_INT 3
2211: PUSH
2212: LD_INT 46
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 21
2223: PUSH
2224: LD_INT 1
2226: PUSH
2227: LD_INT 3
2229: PUSH
2230: LD_INT 51
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: LIST
2237: LIST
2238: PUSH
2239: LD_INT 21
2241: PUSH
2242: LD_INT 1
2244: PUSH
2245: LD_INT 3
2247: PUSH
2248: LD_INT 52
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: PUSH
2257: EMPTY
2258: LIST
2259: LIST
2260: LIST
2261: LIST
2262: LIST
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL 87999 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2270: LD_EXP 8
2274: PPUSH
2275: LD_INT 11
2277: PPUSH
2278: CALL 89352 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2282: LD_EXP 8
2286: PPUSH
2287: LD_INT 12
2289: PPUSH
2290: CALL 89292 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2294: LD_EXP 8
2298: PPUSH
2299: LD_INT 43
2301: PUSH
2302: LD_INT 47
2304: PUSH
2305: LD_INT 45
2307: PUSH
2308: LD_INT 49
2310: PUSH
2311: LD_INT 46
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: PPUSH
2321: CALL 89172 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2325: LD_EXP 8
2329: PPUSH
2330: LD_INT 13
2332: PPUSH
2333: CALL 88842 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2337: LD_EXP 8
2341: PPUSH
2342: LD_INT 11
2344: PPUSH
2345: CALL 88565 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2349: LD_EXP 8
2353: PPUSH
2354: LD_INT 4
2356: PPUSH
2357: CALL 88184 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2361: LD_EXP 8
2365: PPUSH
2366: LD_INT 115
2368: PUSH
2369: LD_INT 201
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: PPUSH
2379: CALL 88902 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2383: LD_EXP 8
2387: PPUSH
2388: LD_INT 24
2390: PUSH
2391: LD_INT 3
2393: PUSH
2394: LD_INT 3
2396: PUSH
2397: LD_INT 46
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 24
2408: PUSH
2409: LD_INT 3
2411: PUSH
2412: LD_INT 3
2414: PUSH
2415: LD_INT 46
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PUSH
2424: LD_INT 24
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 3
2432: PUSH
2433: LD_INT 46
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: PUSH
2442: LD_INT 24
2444: PUSH
2445: LD_INT 3
2447: PUSH
2448: LD_INT 3
2450: PUSH
2451: LD_INT 46
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: PUSH
2460: EMPTY
2461: LIST
2462: LIST
2463: LIST
2464: LIST
2465: PPUSH
2466: CALL 87999 0 2
// end ;
2470: LD_VAR 0 1
2474: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2475: LD_INT 0
2477: PPUSH
2478: PPUSH
2479: PPUSH
2480: PPUSH
2481: PPUSH
2482: PPUSH
2483: PPUSH
2484: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2485: LD_INT 0
2487: PPUSH
2488: LD_INT 0
2490: PPUSH
2491: LD_INT 3
2493: PPUSH
2494: LD_INT 0
2496: PPUSH
2497: LD_INT 0
2499: PPUSH
2500: LD_INT 0
2502: PPUSH
2503: LD_INT 0
2505: PPUSH
2506: LD_INT 14
2508: PPUSH
2509: LD_INT 0
2511: PPUSH
2512: CALL 54806 0 9
// side := 3 ;
2516: LD_ADDR_VAR 0 5
2520: PUSH
2521: LD_INT 3
2523: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2524: LD_INT 38
2526: PPUSH
2527: LD_VAR 0 5
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2539: LD_INT 39
2541: PPUSH
2542: LD_VAR 0 5
2546: PPUSH
2547: LD_INT 2
2549: PPUSH
2550: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2554: LD_INT 34
2556: PPUSH
2557: LD_VAR 0 5
2561: PPUSH
2562: LD_INT 2
2564: PPUSH
2565: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2569: LD_ADDR_VAR 0 4
2573: PUSH
2574: LD_INT 0
2576: PUSH
2577: LD_INT 208
2579: PUSH
2580: LD_INT 163
2582: PUSH
2583: LD_INT 4
2585: PUSH
2586: LD_INT 0
2588: PUSH
2589: LD_INT 0
2591: PUSH
2592: EMPTY
2593: LIST
2594: LIST
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: PUSH
2600: LD_INT 3
2602: PUSH
2603: LD_INT 194
2605: PUSH
2606: LD_INT 161
2608: PUSH
2609: LD_INT 1
2611: PUSH
2612: LD_INT 0
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: LIST
2622: LIST
2623: LIST
2624: LIST
2625: PUSH
2626: LD_INT 17
2628: PUSH
2629: LD_INT 190
2631: PUSH
2632: LD_INT 161
2634: PUSH
2635: LD_INT 1
2637: PUSH
2638: LD_INT 0
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 5
2654: PUSH
2655: LD_INT 200
2657: PUSH
2658: LD_INT 145
2660: PUSH
2661: LD_INT 3
2663: PUSH
2664: LD_INT 0
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: LIST
2676: LIST
2677: PUSH
2678: LD_INT 32
2680: PUSH
2681: LD_INT 192
2683: PUSH
2684: LD_INT 144
2686: PUSH
2687: LD_INT 3
2689: PUSH
2690: LD_INT 0
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: EMPTY
2697: LIST
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: LIST
2703: PUSH
2704: LD_INT 26
2706: PUSH
2707: LD_INT 216
2709: PUSH
2710: LD_INT 172
2712: PUSH
2713: LD_INT 3
2715: PUSH
2716: LD_INT 0
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: LIST
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 26
2732: PUSH
2733: LD_INT 218
2735: PUSH
2736: LD_INT 176
2738: PUSH
2739: LD_INT 3
2741: PUSH
2742: LD_INT 0
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: LIST
2755: PUSH
2756: LD_INT 29
2758: PUSH
2759: LD_INT 182
2761: PUSH
2762: LD_INT 149
2764: PUSH
2765: LD_INT 3
2767: PUSH
2768: LD_INT 0
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: LIST
2778: LIST
2779: LIST
2780: LIST
2781: PUSH
2782: LD_INT 8
2784: PUSH
2785: LD_INT 201
2787: PUSH
2788: LD_INT 171
2790: PUSH
2791: LD_INT 0
2793: PUSH
2794: LD_INT 10
2796: PUSH
2797: LD_INT 11
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: LD_INT 32
2810: PUSH
2811: LD_INT 188
2813: PUSH
2814: LD_INT 167
2816: PUSH
2817: LD_INT 0
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 0
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: LIST
2830: LIST
2831: LIST
2832: LIST
2833: PUSH
2834: LD_INT 32
2836: PUSH
2837: LD_INT 202
2839: PUSH
2840: LD_INT 179
2842: PUSH
2843: LD_INT 0
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: PUSH
2860: LD_INT 32
2862: PUSH
2863: LD_INT 209
2865: PUSH
2866: LD_INT 182
2868: PUSH
2869: LD_INT 0
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: LIST
2882: LIST
2883: LIST
2884: LIST
2885: PUSH
2886: LD_INT 32
2888: PUSH
2889: LD_INT 220
2891: PUSH
2892: LD_INT 183
2894: PUSH
2895: LD_INT 5
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: LIST
2908: LIST
2909: LIST
2910: LIST
2911: PUSH
2912: LD_INT 32
2914: PUSH
2915: LD_INT 225
2917: PUSH
2918: LD_INT 181
2920: PUSH
2921: LD_INT 5
2923: PUSH
2924: LD_INT 0
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 26
2940: PUSH
2941: LD_INT 220
2943: PUSH
2944: LD_INT 174
2946: PUSH
2947: LD_INT 5
2949: PUSH
2950: LD_INT 0
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: LIST
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: LD_INT 84
2969: PUSH
2970: LD_INT 128
2972: PUSH
2973: LD_INT 4
2975: PUSH
2976: LD_INT 0
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: EMPTY
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_INT 3
2992: PUSH
2993: LD_INT 68
2995: PUSH
2996: LD_INT 121
2998: PUSH
2999: LD_INT 1
3001: PUSH
3002: LD_INT 0
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: EMPTY
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 19
3018: PUSH
3019: LD_INT 72
3021: PUSH
3022: LD_INT 125
3024: PUSH
3025: LD_INT 5
3027: PUSH
3028: LD_INT 0
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: LIST
3040: LIST
3041: PUSH
3042: LD_INT 18
3044: PUSH
3045: LD_INT 68
3047: PUSH
3048: LD_INT 124
3050: PUSH
3051: LD_INT 0
3053: PUSH
3054: LD_INT 0
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_INT 24
3070: PUSH
3071: LD_INT 64
3073: PUSH
3074: LD_INT 121
3076: PUSH
3077: LD_INT 1
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 17
3096: PUSH
3097: LD_INT 65
3099: PUSH
3100: LD_INT 118
3102: PUSH
3103: LD_INT 2
3105: PUSH
3106: LD_INT 0
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PUSH
3120: LD_INT 21
3122: PUSH
3123: LD_INT 68
3125: PUSH
3126: LD_INT 117
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: LD_INT 0
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: PUSH
3146: LD_INT 8
3148: PUSH
3149: LD_INT 68
3151: PUSH
3152: LD_INT 130
3154: PUSH
3155: LD_INT 1
3157: PUSH
3158: LD_INT 14
3160: PUSH
3161: LD_INT 10
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 8
3174: PUSH
3175: LD_INT 67
3177: PUSH
3178: LD_INT 110
3180: PUSH
3181: LD_INT 2
3183: PUSH
3184: LD_INT 11
3186: PUSH
3187: LD_INT 12
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: LIST
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 28
3200: PUSH
3201: LD_INT 85
3203: PUSH
3204: LD_INT 108
3206: PUSH
3207: LD_INT 2
3209: PUSH
3210: LD_INT 0
3212: PUSH
3213: LD_INT 0
3215: PUSH
3216: EMPTY
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 28
3226: PUSH
3227: LD_INT 85
3229: PUSH
3230: LD_INT 124
3232: PUSH
3233: LD_INT 2
3235: PUSH
3236: LD_INT 0
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: EMPTY
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: PUSH
3250: LD_INT 30
3252: PUSH
3253: LD_INT 97
3255: PUSH
3256: LD_INT 119
3258: PUSH
3259: LD_INT 2
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 5
3278: PUSH
3279: LD_INT 111
3281: PUSH
3282: LD_INT 138
3284: PUSH
3285: LD_INT 4
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 33
3304: PUSH
3305: LD_INT 104
3307: PUSH
3308: LD_INT 130
3310: PUSH
3311: LD_INT 3
3313: PUSH
3314: LD_INT 0
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: LIST
3325: LIST
3326: LIST
3327: PUSH
3328: LD_INT 33
3330: PUSH
3331: LD_INT 110
3333: PUSH
3334: LD_INT 142
3336: PUSH
3337: LD_INT 5
3339: PUSH
3340: LD_INT 0
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: LIST
3351: LIST
3352: LIST
3353: PUSH
3354: LD_INT 33
3356: PUSH
3357: LD_INT 91
3359: PUSH
3360: LD_INT 131
3362: PUSH
3363: LD_INT 5
3365: PUSH
3366: LD_INT 0
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 33
3382: PUSH
3383: LD_INT 107
3385: PUSH
3386: LD_INT 157
3388: PUSH
3389: LD_INT 5
3391: PUSH
3392: LD_INT 0
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: EMPTY
3399: LIST
3400: LIST
3401: LIST
3402: LIST
3403: LIST
3404: LIST
3405: PUSH
3406: LD_INT 33
3408: PUSH
3409: LD_INT 104
3411: PUSH
3412: LD_INT 160
3414: PUSH
3415: LD_INT 5
3417: PUSH
3418: LD_INT 0
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 33
3434: PUSH
3435: LD_INT 101
3437: PUSH
3438: LD_INT 162
3440: PUSH
3441: LD_INT 5
3443: PUSH
3444: LD_INT 0
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: PUSH
3458: LD_INT 32
3460: PUSH
3461: LD_INT 87
3463: PUSH
3464: LD_INT 157
3466: PUSH
3467: LD_INT 5
3469: PUSH
3470: LD_INT 0
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: LIST
3483: PUSH
3484: LD_INT 32
3486: PUSH
3487: LD_INT 105
3489: PUSH
3490: LD_INT 158
3492: PUSH
3493: LD_INT 5
3495: PUSH
3496: LD_INT 0
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: PUSH
3510: LD_INT 33
3512: PUSH
3513: LD_INT 91
3515: PUSH
3516: LD_INT 118
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: LD_INT 0
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: LIST
3535: PUSH
3536: LD_INT 33
3538: PUSH
3539: LD_INT 89
3541: PUSH
3542: LD_INT 107
3544: PUSH
3545: LD_INT 4
3547: PUSH
3548: LD_INT 0
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: LIST
3560: LIST
3561: PUSH
3562: LD_INT 5
3564: PUSH
3565: LD_INT 86
3567: PUSH
3568: LD_INT 96
3570: PUSH
3571: LD_INT 3
3573: PUSH
3574: LD_INT 0
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 33
3590: PUSH
3591: LD_INT 91
3593: PUSH
3594: LD_INT 102
3596: PUSH
3597: LD_INT 4
3599: PUSH
3600: LD_INT 0
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 32
3616: PUSH
3617: LD_INT 80
3619: PUSH
3620: LD_INT 95
3622: PUSH
3623: LD_INT 3
3625: PUSH
3626: LD_INT 0
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: PUSH
3640: LD_INT 28
3642: PUSH
3643: LD_INT 77
3645: PUSH
3646: LD_INT 105
3648: PUSH
3649: LD_INT 3
3651: PUSH
3652: LD_INT 0
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: LIST
3662: LIST
3663: LIST
3664: LIST
3665: PUSH
3666: LD_INT 28
3668: PUSH
3669: LD_INT 85
3671: PUSH
3672: LD_INT 113
3674: PUSH
3675: LD_INT 3
3677: PUSH
3678: LD_INT 0
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: LIST
3688: LIST
3689: LIST
3690: LIST
3691: PUSH
3692: LD_INT 28
3694: PUSH
3695: LD_INT 55
3697: PUSH
3698: LD_INT 97
3700: PUSH
3701: LD_INT 3
3703: PUSH
3704: LD_INT 0
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 88
3723: PUSH
3724: LD_INT 128
3726: PUSH
3727: LD_INT 3
3729: PUSH
3730: LD_INT 0
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: LIST
3740: LIST
3741: LIST
3742: LIST
3743: PUSH
3744: LD_INT 32
3746: PUSH
3747: LD_INT 69
3749: PUSH
3750: LD_INT 101
3752: PUSH
3753: LD_INT 2
3755: PUSH
3756: LD_INT 0
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: LIST
3766: LIST
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 1
3772: PUSH
3773: LD_INT 34
3775: PUSH
3776: LD_INT 23
3778: PUSH
3779: LD_INT 4
3781: PUSH
3782: LD_INT 0
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 8
3798: PUSH
3799: LD_INT 25
3801: PUSH
3802: LD_INT 4
3804: PUSH
3805: LD_INT 3
3807: PUSH
3808: LD_INT 11
3810: PUSH
3811: LD_INT 10
3813: PUSH
3814: EMPTY
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: PUSH
3822: LD_INT 8
3824: PUSH
3825: LD_INT 15
3827: PUSH
3828: LD_INT 4
3830: PUSH
3831: LD_INT 2
3833: PUSH
3834: LD_INT 14
3836: PUSH
3837: LD_INT 12
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: LIST
3847: PUSH
3848: LD_INT 29
3850: PUSH
3851: LD_INT 55
3853: PUSH
3854: LD_INT 35
3856: PUSH
3857: LD_INT 2
3859: PUSH
3860: LD_INT 0
3862: PUSH
3863: LD_INT 0
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: PUSH
3874: LD_INT 29
3876: PUSH
3877: LD_INT 24
3879: PUSH
3880: LD_INT 44
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: LD_INT 0
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: PUSH
3900: LD_INT 34
3902: PUSH
3903: LD_INT 34
3905: PUSH
3906: LD_INT 32
3908: PUSH
3909: LD_INT 4
3911: PUSH
3912: LD_INT 0
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 3
3928: PUSH
3929: LD_INT 14
3931: PUSH
3932: LD_INT 16
3934: PUSH
3935: LD_INT 1
3937: PUSH
3938: LD_INT 0
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: LIST
3951: PUSH
3952: LD_INT 24
3954: PUSH
3955: LD_INT 10
3957: PUSH
3958: LD_INT 16
3960: PUSH
3961: LD_INT 1
3963: PUSH
3964: LD_INT 0
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: LIST
3977: PUSH
3978: LD_INT 21
3980: PUSH
3981: LD_INT 11
3983: PUSH
3984: LD_INT 13
3986: PUSH
3987: LD_INT 2
3989: PUSH
3990: LD_INT 0
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: LD_INT 18
4006: PUSH
4007: LD_INT 14
4009: PUSH
4010: LD_INT 12
4012: PUSH
4013: LD_INT 3
4015: PUSH
4016: LD_INT 0
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_INT 16
4032: PUSH
4033: LD_INT 14
4035: PUSH
4036: LD_INT 19
4038: PUSH
4039: LD_INT 0
4041: PUSH
4042: LD_INT 0
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: EMPTY
4049: LIST
4050: LIST
4051: LIST
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_INT 17
4058: PUSH
4059: LD_INT 18
4061: PUSH
4062: LD_INT 20
4064: PUSH
4065: LD_INT 5
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: LIST
4078: LIST
4079: LIST
4080: LIST
4081: PUSH
4082: LD_INT 28
4084: PUSH
4085: LD_INT 10
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: LD_INT 1
4093: PUSH
4094: LD_INT 0
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: PUSH
4108: LD_INT 28
4110: PUSH
4111: LD_INT 8
4113: PUSH
4114: LD_INT 8
4116: PUSH
4117: LD_INT 1
4119: PUSH
4120: LD_INT 0
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 26
4136: PUSH
4137: LD_INT 19
4139: PUSH
4140: LD_INT 2
4142: PUSH
4143: LD_INT 1
4145: PUSH
4146: LD_INT 0
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: LIST
4156: LIST
4157: LIST
4158: LIST
4159: PUSH
4160: LD_INT 26
4162: PUSH
4163: LD_INT 30
4165: PUSH
4166: LD_INT 2
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 0
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 5
4188: PUSH
4189: LD_INT 59
4191: PUSH
4192: LD_INT 20
4194: PUSH
4195: LD_INT 4
4197: PUSH
4198: LD_INT 0
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: PUSH
4212: LD_INT 32
4214: PUSH
4215: LD_INT 60
4217: PUSH
4218: LD_INT 24
4220: PUSH
4221: LD_INT 4
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: LIST
4236: LIST
4237: PUSH
4238: LD_INT 32
4240: PUSH
4241: LD_INT 61
4243: PUSH
4244: LD_INT 45
4246: PUSH
4247: LD_INT 5
4249: PUSH
4250: LD_INT 0
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 32
4266: PUSH
4267: LD_INT 52
4269: PUSH
4270: LD_INT 51
4272: PUSH
4273: LD_INT 5
4275: PUSH
4276: LD_INT 0
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: LIST
4288: LIST
4289: PUSH
4290: LD_INT 33
4292: PUSH
4293: LD_INT 56
4295: PUSH
4296: LD_INT 51
4298: PUSH
4299: LD_INT 5
4301: PUSH
4302: LD_INT 0
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: LIST
4312: LIST
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 33
4318: PUSH
4319: LD_INT 62
4321: PUSH
4322: LD_INT 49
4324: PUSH
4325: LD_INT 5
4327: PUSH
4328: LD_INT 0
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: PUSH
4342: LD_INT 33
4344: PUSH
4345: LD_INT 41
4347: PUSH
4348: LD_INT 47
4350: PUSH
4351: LD_INT 5
4353: PUSH
4354: LD_INT 0
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: LIST
4364: LIST
4365: LIST
4366: LIST
4367: PUSH
4368: LD_INT 33
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 52
4376: PUSH
4377: LD_INT 5
4379: PUSH
4380: LD_INT 0
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 5
4396: PUSH
4397: LD_INT 31
4399: PUSH
4400: LD_INT 40
4402: PUSH
4403: LD_INT 0
4405: PUSH
4406: LD_INT 0
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 33
4422: PUSH
4423: LD_INT 65
4425: PUSH
4426: LD_INT 37
4428: PUSH
4429: LD_INT 5
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: PUSH
4446: LD_INT 33
4448: PUSH
4449: LD_INT 63
4451: PUSH
4452: LD_INT 29
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: LD_INT 0
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 33
4474: PUSH
4475: LD_INT 54
4477: PUSH
4478: LD_INT 11
4480: PUSH
4481: LD_INT 4
4483: PUSH
4484: LD_INT 0
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 33
4500: PUSH
4501: LD_INT 56
4503: PUSH
4504: LD_INT 15
4506: PUSH
4507: LD_INT 4
4509: PUSH
4510: LD_INT 0
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: PUSH
4524: LD_INT 33
4526: PUSH
4527: LD_INT 51
4529: PUSH
4530: LD_INT 6
4532: PUSH
4533: LD_INT 4
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: PUSH
4550: LD_INT 26
4552: PUSH
4553: LD_INT 39
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 0
4561: PUSH
4562: LD_INT 0
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 26
4578: PUSH
4579: LD_INT 37
4581: PUSH
4582: LD_INT 21
4584: PUSH
4585: LD_INT 0
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: PUSH
4602: LD_INT 32
4604: PUSH
4605: LD_INT 35
4607: PUSH
4608: LD_INT 17
4610: PUSH
4611: LD_INT 4
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: PUSH
4628: LD_INT 33
4630: PUSH
4631: LD_INT 35
4633: PUSH
4634: LD_INT 28
4636: PUSH
4637: LD_INT 4
4639: PUSH
4640: LD_INT 0
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: LIST
4652: LIST
4653: PUSH
4654: LD_INT 33
4656: PUSH
4657: LD_INT 28
4659: PUSH
4660: LD_INT 46
4662: PUSH
4663: LD_INT 5
4665: PUSH
4666: LD_INT 0
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: LIST
4676: LIST
4677: LIST
4678: LIST
4679: PUSH
4680: LD_INT 33
4682: PUSH
4683: LD_INT 31
4685: PUSH
4686: LD_INT 6
4688: PUSH
4689: LD_INT 4
4691: PUSH
4692: LD_INT 0
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 26
4708: PUSH
4709: LD_INT 54
4711: PUSH
4712: LD_INT 38
4714: PUSH
4715: LD_INT 4
4717: PUSH
4718: LD_INT 0
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: PUSH
4732: LD_INT 33
4734: PUSH
4735: LD_INT 207
4737: PUSH
4738: LD_INT 167
4740: PUSH
4741: LD_INT 3
4743: PUSH
4744: LD_INT 0
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: LD_INT 30
4760: PUSH
4761: LD_INT 43
4763: PUSH
4764: LD_INT 2
4766: PUSH
4767: LD_INT 4
4769: PUSH
4770: LD_INT 0
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: ST_TO_ADDR
// for i in tmp do
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: LD_VAR 0 4
4880: PUSH
4881: FOR_IN
4882: IFFALSE 5113
// begin uc_side := side ;
4884: LD_ADDR_OWVAR 20
4888: PUSH
4889: LD_VAR 0 5
4893: ST_TO_ADDR
// uc_nation := nation_russian ;
4894: LD_ADDR_OWVAR 21
4898: PUSH
4899: LD_INT 3
4901: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4902: LD_ADDR_OWVAR 42
4906: PUSH
4907: LD_VAR 0 2
4911: PUSH
4912: LD_INT 1
4914: ARRAY
4915: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4916: LD_ADDR_OWVAR 43
4920: PUSH
4921: LD_INT 5
4923: PPUSH
4924: LD_INT 6
4926: PPUSH
4927: CALL_OW 12
4931: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4932: LD_ADDR_OWVAR 44
4936: PUSH
4937: LD_VAR 0 2
4941: PUSH
4942: LD_INT 5
4944: ARRAY
4945: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4946: LD_ADDR_OWVAR 45
4950: PUSH
4951: LD_VAR 0 2
4955: PUSH
4956: LD_INT 6
4958: ARRAY
4959: ST_TO_ADDR
// sr := 0 ;
4960: LD_ADDR_VAR 0 6
4964: PUSH
4965: LD_INT 0
4967: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4968: LD_VAR 0 2
4972: PUSH
4973: LD_INT 1
4975: ARRAY
4976: PUSH
4977: LD_INT 29
4979: EQUAL
4980: IFFALSE 4992
// sr := mat_oil else
4982: LD_ADDR_VAR 0 6
4986: PUSH
4987: LD_INT 2
4989: ST_TO_ADDR
4990: GO 5014
// if i [ 1 ] = b_siberite_mine then
4992: LD_VAR 0 2
4996: PUSH
4997: LD_INT 1
4999: ARRAY
5000: PUSH
5001: LD_INT 30
5003: EQUAL
5004: IFFALSE 5014
// sr := mat_siberit ;
5006: LD_ADDR_VAR 0 6
5010: PUSH
5011: LD_INT 3
5013: ST_TO_ADDR
// if sr then
5014: LD_VAR 0 6
5018: IFFALSE 5074
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5020: LD_VAR 0 2
5024: PUSH
5025: LD_INT 2
5027: ARRAY
5028: PPUSH
5029: LD_VAR 0 2
5033: PUSH
5034: LD_INT 3
5036: ARRAY
5037: PPUSH
5038: LD_VAR 0 6
5042: PPUSH
5043: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5047: LD_VAR 0 2
5051: PUSH
5052: LD_INT 2
5054: ARRAY
5055: PPUSH
5056: LD_VAR 0 2
5060: PUSH
5061: LD_INT 3
5063: ARRAY
5064: PPUSH
5065: LD_VAR 0 5
5069: PPUSH
5070: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5074: LD_ADDR_VAR 0 3
5078: PUSH
5079: LD_VAR 0 2
5083: PUSH
5084: LD_INT 2
5086: ARRAY
5087: PPUSH
5088: LD_VAR 0 2
5092: PUSH
5093: LD_INT 3
5095: ARRAY
5096: PPUSH
5097: LD_VAR 0 2
5101: PUSH
5102: LD_INT 4
5104: ARRAY
5105: PPUSH
5106: CALL_OW 47
5110: ST_TO_ADDR
// end ;
5111: GO 4881
5113: POP
5114: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5115: LD_ADDR_VAR 0 7
5119: PUSH
5120: LD_INT 22
5122: PUSH
5123: LD_VAR 0 5
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 30
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: ST_TO_ADDR
// if not depot then
5151: LD_VAR 0 7
5155: NOT
5156: IFFALSE 5160
// exit ;
5158: GO 5504
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5160: LD_ADDR_VAR 0 8
5164: PUSH
5165: LD_INT 84
5167: PPUSH
5168: LD_INT 128
5170: PPUSH
5171: CALL_OW 428
5175: PPUSH
5176: LD_INT 15
5178: PPUSH
5179: LD_INT 0
5181: PPUSH
5182: LD_INT 6
5184: PUSH
5185: LD_INT 7
5187: PUSH
5188: LD_INT 8
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: PUSH
5196: LD_OWVAR 67
5200: ARRAY
5201: PPUSH
5202: LD_INT 3000
5204: PUSH
5205: LD_INT 300
5207: PUSH
5208: LD_INT 100
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: LIST
5215: PPUSH
5216: LD_INT 12
5218: PUSH
5219: LD_INT 6
5221: PUSH
5222: LD_INT 6
5224: PUSH
5225: LD_INT 4
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: PPUSH
5234: CALL 28812 0 6
5238: ST_TO_ADDR
// if not base then
5239: LD_VAR 0 8
5243: NOT
5244: IFFALSE 5248
// exit ;
5246: GO 5504
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5248: LD_ADDR_EXP 31
5252: PUSH
5253: LD_EXP 31
5257: PPUSH
5258: LD_EXP 7
5262: PPUSH
5263: LD_VAR 0 8
5267: PPUSH
5268: CALL_OW 1
5272: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5273: LD_ADDR_VAR 0 8
5277: PUSH
5278: LD_INT 34
5280: PPUSH
5281: LD_INT 23
5283: PPUSH
5284: CALL_OW 428
5288: PPUSH
5289: LD_INT 11
5291: PPUSH
5292: LD_INT 0
5294: PPUSH
5295: LD_INT 6
5297: PUSH
5298: LD_INT 7
5300: PUSH
5301: LD_INT 8
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: LIST
5308: PUSH
5309: LD_OWVAR 67
5313: ARRAY
5314: PPUSH
5315: LD_INT 20000
5317: PUSH
5318: LD_INT 3000
5320: PUSH
5321: LD_INT 1000
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: LIST
5328: PPUSH
5329: LD_INT 12
5331: PUSH
5332: LD_INT 6
5334: PUSH
5335: LD_INT 6
5337: PUSH
5338: LD_INT 4
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: PPUSH
5347: CALL 28812 0 6
5351: ST_TO_ADDR
// if not base then
5352: LD_VAR 0 8
5356: NOT
5357: IFFALSE 5361
// exit ;
5359: GO 5504
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5361: LD_ADDR_EXP 31
5365: PUSH
5366: LD_EXP 31
5370: PPUSH
5371: LD_EXP 8
5375: PPUSH
5376: LD_VAR 0 8
5380: PPUSH
5381: CALL_OW 1
5385: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5386: LD_ADDR_EXP 14
5390: PUSH
5391: LD_INT 22
5393: PUSH
5394: LD_INT 3
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 30
5403: PUSH
5404: LD_INT 0
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PPUSH
5415: CALL_OW 69
5419: PUSH
5420: LD_INT 1
5422: ARRAY
5423: PPUSH
5424: LD_INT 25
5426: PPUSH
5427: LD_INT 0
5429: PPUSH
5430: LD_INT 6
5432: PUSH
5433: LD_INT 7
5435: PUSH
5436: LD_INT 8
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: LIST
5443: PUSH
5444: LD_OWVAR 67
5448: ARRAY
5449: PPUSH
5450: LD_INT 500
5452: PUSH
5453: LD_INT 100
5455: PUSH
5456: LD_INT 10
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: PPUSH
5464: LD_INT 6
5466: PUSH
5467: LD_INT 7
5469: PUSH
5470: LD_INT 8
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_OWVAR 67
5482: ARRAY
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 0
5489: PUSH
5490: LD_INT 1
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL 28812 0 6
5503: ST_TO_ADDR
// end ;
5504: LD_VAR 0 1
5508: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5509: LD_INT 0
5511: PPUSH
5512: PPUSH
5513: PPUSH
5514: PPUSH
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
5519: PPUSH
5520: PPUSH
5521: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5522: LD_INT 0
5524: PPUSH
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 6
5530: PPUSH
5531: LD_INT 0
5533: PPUSH
5534: LD_INT 0
5536: PPUSH
5537: LD_INT 0
5539: PPUSH
5540: LD_INT 0
5542: PPUSH
5543: LD_INT 8
5545: PPUSH
5546: LD_INT 0
5548: PPUSH
5549: CALL 54806 0 9
// side := 8 ;
5553: LD_ADDR_VAR 0 8
5557: PUSH
5558: LD_INT 8
5560: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5561: LD_ADDR_VAR 0 5
5565: PUSH
5566: LD_INT 20
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: CALL_OW 517
5576: ST_TO_ADDR
// if Difficulty > 2 then
5577: LD_OWVAR 67
5581: PUSH
5582: LD_INT 2
5584: GREATER
5585: IFFALSE 5729
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5587: LD_ADDR_VAR 0 6
5591: PUSH
5592: LD_INT 27
5594: PPUSH
5595: LD_INT 0
5597: PPUSH
5598: CALL_OW 517
5602: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5603: LD_ADDR_VAR 0 2
5607: PUSH
5608: DOUBLE
5609: LD_INT 1
5611: DEC
5612: ST_TO_ADDR
5613: LD_VAR 0 6
5617: PUSH
5618: LD_INT 1
5620: ARRAY
5621: PUSH
5622: FOR_TO
5623: IFFALSE 5727
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5625: LD_ADDR_VAR 0 5
5629: PUSH
5630: LD_VAR 0 5
5634: PPUSH
5635: LD_INT 1
5637: PUSH
5638: LD_VAR 0 5
5642: PUSH
5643: LD_INT 1
5645: ARRAY
5646: PUSH
5647: LD_INT 1
5649: PLUS
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PPUSH
5655: LD_VAR 0 6
5659: PUSH
5660: LD_INT 1
5662: ARRAY
5663: PUSH
5664: LD_VAR 0 2
5668: ARRAY
5669: PPUSH
5670: CALL 25097 0 3
5674: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5675: LD_ADDR_VAR 0 5
5679: PUSH
5680: LD_VAR 0 5
5684: PPUSH
5685: LD_INT 2
5687: PUSH
5688: LD_VAR 0 5
5692: PUSH
5693: LD_INT 2
5695: ARRAY
5696: PUSH
5697: LD_INT 1
5699: PLUS
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_VAR 0 6
5709: PUSH
5710: LD_INT 2
5712: ARRAY
5713: PUSH
5714: LD_VAR 0 2
5718: ARRAY
5719: PPUSH
5720: CALL 25097 0 3
5724: ST_TO_ADDR
// end ;
5725: GO 5622
5727: POP
5728: POP
// end ; if tmp then
5729: LD_VAR 0 5
5733: IFFALSE 5861
// begin for i = 1 to tmp [ 1 ] do
5735: LD_ADDR_VAR 0 2
5739: PUSH
5740: DOUBLE
5741: LD_INT 1
5743: DEC
5744: ST_TO_ADDR
5745: LD_VAR 0 5
5749: PUSH
5750: LD_INT 1
5752: ARRAY
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5859
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5757: LD_VAR 0 5
5761: PUSH
5762: LD_INT 1
5764: ARRAY
5765: PUSH
5766: LD_VAR 0 2
5770: ARRAY
5771: PPUSH
5772: LD_VAR 0 5
5776: PUSH
5777: LD_INT 2
5779: ARRAY
5780: PUSH
5781: LD_VAR 0 2
5785: ARRAY
5786: PPUSH
5787: LD_VAR 0 8
5791: PPUSH
5792: LD_INT 0
5794: PPUSH
5795: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5799: LD_ADDR_EXP 16
5803: PUSH
5804: LD_EXP 16
5808: PPUSH
5809: LD_EXP 16
5813: PUSH
5814: LD_INT 1
5816: PLUS
5817: PPUSH
5818: LD_VAR 0 5
5822: PUSH
5823: LD_INT 1
5825: ARRAY
5826: PUSH
5827: LD_VAR 0 2
5831: ARRAY
5832: PUSH
5833: LD_VAR 0 5
5837: PUSH
5838: LD_INT 2
5840: ARRAY
5841: PUSH
5842: LD_VAR 0 2
5846: ARRAY
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 2
5856: ST_TO_ADDR
// end ;
5857: GO 5754
5859: POP
5860: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5861: LD_ADDR_VAR 0 7
5865: PUSH
5866: LD_INT 165
5868: PUSH
5869: LD_INT 156
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: LD_INT 143
5878: PUSH
5879: LD_INT 145
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 152
5888: PUSH
5889: LD_INT 165
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 123
5898: PUSH
5899: LD_INT 153
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 161
5908: PUSH
5909: LD_INT 215
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 172
5918: PUSH
5919: LD_INT 100
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: LD_INT 148
5928: PUSH
5929: LD_INT 83
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: PUSH
5936: LD_INT 122
5938: PUSH
5939: LD_INT 68
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PUSH
5946: LD_INT 105
5948: PUSH
5949: LD_INT 74
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: PUSH
5956: LD_INT 113
5958: PUSH
5959: LD_INT 97
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: LIST
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// for i in cameras do
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_VAR 0 7
5987: PUSH
5988: FOR_IN
5989: IFFALSE 6020
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
5991: LD_VAR 0 2
5995: PUSH
5996: LD_INT 1
5998: ARRAY
5999: PPUSH
6000: LD_VAR 0 2
6004: PUSH
6005: LD_INT 2
6007: ARRAY
6008: PPUSH
6009: LD_VAR 0 8
6013: PPUSH
6014: CALL_OW 244
6018: GO 5988
6020: POP
6021: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6022: LD_ADDR_VAR 0 5
6026: PUSH
6027: LD_INT 1
6029: PUSH
6030: LD_INT 144
6032: PUSH
6033: LD_INT 110
6035: PUSH
6036: LD_INT 1
6038: PUSH
6039: LD_INT 0
6041: PUSH
6042: LD_INT 0
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: PUSH
6053: LD_INT 3
6055: PUSH
6056: LD_INT 151
6058: PUSH
6059: LD_INT 118
6061: PUSH
6062: LD_INT 0
6064: PUSH
6065: LD_INT 0
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 8
6081: PUSH
6082: LD_INT 158
6084: PUSH
6085: LD_INT 110
6087: PUSH
6088: LD_INT 4
6090: PUSH
6091: LD_INT 10
6093: PUSH
6094: LD_INT 15
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 23
6107: PUSH
6108: LD_INT 154
6110: PUSH
6111: LD_INT 121
6113: PUSH
6114: LD_INT 5
6116: PUSH
6117: LD_INT 0
6119: PUSH
6120: LD_INT 0
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 22
6133: PUSH
6134: LD_INT 155
6136: PUSH
6137: LD_INT 118
6139: PUSH
6140: LD_INT 4
6142: PUSH
6143: LD_INT 0
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PUSH
6157: LD_INT 21
6159: PUSH
6160: LD_INT 151
6162: PUSH
6163: LD_INT 122
6165: PUSH
6166: LD_INT 0
6168: PUSH
6169: LD_INT 0
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: LD_INT 18
6185: PUSH
6186: LD_INT 148
6188: PUSH
6189: LD_INT 118
6191: PUSH
6192: LD_INT 1
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 17
6211: PUSH
6212: LD_INT 147
6214: PUSH
6215: LD_INT 114
6217: PUSH
6218: LD_INT 2
6220: PUSH
6221: LD_INT 0
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 29
6237: PUSH
6238: LD_INT 163
6240: PUSH
6241: LD_INT 120
6243: PUSH
6244: LD_INT 5
6246: PUSH
6247: LD_INT 0
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: LIST
6257: LIST
6258: LIST
6259: LIST
6260: PUSH
6261: LD_INT 27
6263: PUSH
6264: LD_INT 137
6266: PUSH
6267: LD_INT 116
6269: PUSH
6270: LD_INT 3
6272: PUSH
6273: LD_INT 0
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: PUSH
6287: LD_INT 27
6289: PUSH
6290: LD_INT 133
6292: PUSH
6293: LD_INT 111
6295: PUSH
6296: LD_INT 1
6298: PUSH
6299: LD_INT 0
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_INT 27
6315: PUSH
6316: LD_INT 132
6318: PUSH
6319: LD_INT 106
6321: PUSH
6322: LD_INT 4
6324: PUSH
6325: LD_INT 0
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: LD_INT 26
6341: PUSH
6342: LD_INT 137
6344: PUSH
6345: LD_INT 111
6347: PUSH
6348: LD_INT 0
6350: PUSH
6351: LD_INT 0
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 8
6367: PUSH
6368: LD_INT 141
6370: PUSH
6371: LD_INT 117
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 13
6379: PUSH
6380: LD_INT 11
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 30
6393: PUSH
6394: LD_INT 140
6396: PUSH
6397: LD_INT 128
6399: PUSH
6400: LD_INT 1
6402: PUSH
6403: LD_INT 0
6405: PUSH
6406: LD_INT 0
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: PUSH
6417: LD_INT 5
6419: PUSH
6420: LD_INT 146
6422: PUSH
6423: LD_INT 96
6425: PUSH
6426: LD_INT 3
6428: PUSH
6429: LD_INT 0
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 32
6445: PUSH
6446: LD_INT 150
6448: PUSH
6449: LD_INT 98
6451: PUSH
6452: LD_INT 3
6454: PUSH
6455: LD_INT 0
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 32
6471: PUSH
6472: LD_INT 142
6474: PUSH
6475: LD_INT 95
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: PUSH
6495: LD_INT 32
6497: PUSH
6498: LD_INT 159
6500: PUSH
6501: LD_INT 104
6503: PUSH
6504: LD_INT 3
6506: PUSH
6507: LD_INT 0
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: LIST
6518: LIST
6519: LIST
6520: PUSH
6521: LD_INT 32
6523: PUSH
6524: LD_INT 133
6526: PUSH
6527: LD_INT 95
6529: PUSH
6530: LD_INT 3
6532: PUSH
6533: LD_INT 0
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 32
6549: PUSH
6550: LD_INT 131
6552: PUSH
6553: LD_INT 102
6555: PUSH
6556: LD_INT 2
6558: PUSH
6559: LD_INT 0
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: LIST
6569: LIST
6570: LIST
6571: LIST
6572: PUSH
6573: LD_INT 32
6575: PUSH
6576: LD_INT 164
6578: PUSH
6579: LD_INT 144
6581: PUSH
6582: LD_INT 0
6584: PUSH
6585: LD_INT 0
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: LIST
6595: LIST
6596: LIST
6597: LIST
6598: PUSH
6599: LD_INT 32
6601: PUSH
6602: LD_INT 146
6604: PUSH
6605: LD_INT 139
6607: PUSH
6608: LD_INT 0
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: LIST
6624: PUSH
6625: LD_INT 26
6627: PUSH
6628: LD_INT 143
6630: PUSH
6631: LD_INT 122
6633: PUSH
6634: LD_INT 4
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 26
6653: PUSH
6654: LD_INT 164
6656: PUSH
6657: LD_INT 116
6659: PUSH
6660: LD_INT 2
6662: PUSH
6663: LD_INT 0
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: ST_TO_ADDR
// for i in tmp do
6704: LD_ADDR_VAR 0 2
6708: PUSH
6709: LD_VAR 0 5
6713: PUSH
6714: FOR_IN
6715: IFFALSE 6946
// begin uc_side := side ;
6717: LD_ADDR_OWVAR 20
6721: PUSH
6722: LD_VAR 0 8
6726: ST_TO_ADDR
// uc_nation := nation_arabian ;
6727: LD_ADDR_OWVAR 21
6731: PUSH
6732: LD_INT 2
6734: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6735: LD_ADDR_OWVAR 42
6739: PUSH
6740: LD_VAR 0 2
6744: PUSH
6745: LD_INT 1
6747: ARRAY
6748: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6749: LD_ADDR_OWVAR 43
6753: PUSH
6754: LD_INT 5
6756: PPUSH
6757: LD_INT 6
6759: PPUSH
6760: CALL_OW 12
6764: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6765: LD_ADDR_OWVAR 44
6769: PUSH
6770: LD_VAR 0 2
6774: PUSH
6775: LD_INT 5
6777: ARRAY
6778: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6779: LD_ADDR_OWVAR 45
6783: PUSH
6784: LD_VAR 0 2
6788: PUSH
6789: LD_INT 6
6791: ARRAY
6792: ST_TO_ADDR
// sr := 0 ;
6793: LD_ADDR_VAR 0 9
6797: PUSH
6798: LD_INT 0
6800: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6801: LD_VAR 0 2
6805: PUSH
6806: LD_INT 1
6808: ARRAY
6809: PUSH
6810: LD_INT 29
6812: EQUAL
6813: IFFALSE 6825
// sr := mat_oil else
6815: LD_ADDR_VAR 0 9
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
6823: GO 6847
// if i [ 1 ] = b_siberite_mine then
6825: LD_VAR 0 2
6829: PUSH
6830: LD_INT 1
6832: ARRAY
6833: PUSH
6834: LD_INT 30
6836: EQUAL
6837: IFFALSE 6847
// sr := mat_siberit ;
6839: LD_ADDR_VAR 0 9
6843: PUSH
6844: LD_INT 3
6846: ST_TO_ADDR
// if sr then
6847: LD_VAR 0 9
6851: IFFALSE 6907
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6853: LD_VAR 0 2
6857: PUSH
6858: LD_INT 2
6860: ARRAY
6861: PPUSH
6862: LD_VAR 0 2
6866: PUSH
6867: LD_INT 3
6869: ARRAY
6870: PPUSH
6871: LD_VAR 0 9
6875: PPUSH
6876: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6880: LD_VAR 0 2
6884: PUSH
6885: LD_INT 2
6887: ARRAY
6888: PPUSH
6889: LD_VAR 0 2
6893: PUSH
6894: LD_INT 3
6896: ARRAY
6897: PPUSH
6898: LD_VAR 0 8
6902: PPUSH
6903: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6907: LD_ADDR_VAR 0 3
6911: PUSH
6912: LD_VAR 0 2
6916: PUSH
6917: LD_INT 2
6919: ARRAY
6920: PPUSH
6921: LD_VAR 0 2
6925: PUSH
6926: LD_INT 3
6928: ARRAY
6929: PPUSH
6930: LD_VAR 0 2
6934: PUSH
6935: LD_INT 4
6937: ARRAY
6938: PPUSH
6939: CALL_OW 47
6943: ST_TO_ADDR
// end ;
6944: GO 6714
6946: POP
6947: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6948: LD_ADDR_VAR 0 10
6952: PUSH
6953: LD_INT 22
6955: PUSH
6956: LD_VAR 0 8
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: PUSH
6965: LD_INT 30
6967: PUSH
6968: LD_INT 1
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: PPUSH
6979: CALL_OW 69
6983: ST_TO_ADDR
// if not depot then
6984: LD_VAR 0 10
6988: NOT
6989: IFFALSE 6993
// exit ;
6991: GO 7239
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
6993: LD_ADDR_VAR 0 11
6997: PUSH
6998: LD_VAR 0 10
7002: PUSH
7003: LD_INT 1
7005: ARRAY
7006: PPUSH
7007: LD_INT 6
7009: PPUSH
7010: LD_INT 0
7012: PPUSH
7013: LD_INT 7
7015: PUSH
7016: LD_INT 8
7018: PUSH
7019: LD_INT 10
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: LIST
7026: PUSH
7027: LD_OWVAR 67
7031: ARRAY
7032: PPUSH
7033: LD_INT 3000
7035: PUSH
7036: LD_INT 300
7038: PUSH
7039: LD_INT 100
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_INT 14
7049: PUSH
7050: LD_INT 6
7052: PUSH
7053: LD_INT 6
7055: PUSH
7056: LD_INT 5
7058: PUSH
7059: EMPTY
7060: LIST
7061: LIST
7062: LIST
7063: LIST
7064: PPUSH
7065: CALL 28812 0 6
7069: ST_TO_ADDR
// if not base then
7070: LD_VAR 0 11
7074: NOT
7075: IFFALSE 7079
// exit ;
7077: GO 7239
// if Difficulty > 1 then
7079: LD_OWVAR 67
7083: PUSH
7084: LD_INT 1
7086: GREATER
7087: IFFALSE 7160
// begin InitHc ;
7089: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7093: LD_INT 1
7095: PPUSH
7096: LD_INT 5
7098: PPUSH
7099: LD_INT 5
7101: PUSH
7102: LD_INT 8
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: PUSH
7109: LD_OWVAR 67
7113: PUSH
7114: LD_INT 1
7116: MINUS
7117: ARRAY
7118: PPUSH
7119: CALL_OW 380
// for i = 1 to Difficulty do
7123: LD_ADDR_VAR 0 2
7127: PUSH
7128: DOUBLE
7129: LD_INT 1
7131: DEC
7132: ST_TO_ADDR
7133: LD_OWVAR 67
7137: PUSH
7138: FOR_TO
7139: IFFALSE 7158
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7141: CALL_OW 44
7145: PPUSH
7146: LD_INT 24
7148: PPUSH
7149: LD_INT 0
7151: PPUSH
7152: CALL_OW 49
7156: GO 7138
7158: POP
7159: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7160: LD_ADDR_EXP 31
7164: PUSH
7165: LD_EXP 31
7169: PPUSH
7170: LD_EXP 6
7174: PPUSH
7175: LD_VAR 0 11
7179: PPUSH
7180: CALL_OW 1
7184: ST_TO_ADDR
// hc_gallery := ru ;
7185: LD_ADDR_OWVAR 33
7189: PUSH
7190: LD_STRING ru
7192: ST_TO_ADDR
// hc_face_number := 44 ;
7193: LD_ADDR_OWVAR 34
7197: PUSH
7198: LD_INT 44
7200: ST_TO_ADDR
// hc_name := Robert Farmer ;
7201: LD_ADDR_OWVAR 26
7205: PUSH
7206: LD_STRING Robert Farmer
7208: ST_TO_ADDR
// hc_sex := sex_male ;
7209: LD_ADDR_OWVAR 27
7213: PUSH
7214: LD_INT 1
7216: ST_TO_ADDR
// hc_class := 1 ;
7217: LD_ADDR_OWVAR 28
7221: PUSH
7222: LD_INT 1
7224: ST_TO_ADDR
// Farmer := CreateHuman ;
7225: LD_ADDR_EXP 13
7229: PUSH
7230: CALL_OW 44
7234: ST_TO_ADDR
// InitHc ;
7235: CALL_OW 19
// end ;
7239: LD_VAR 0 1
7243: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7244: LD_INT 0
7246: PPUSH
7247: PPUSH
7248: PPUSH
7249: PPUSH
// tmp := [ ] ;
7250: LD_ADDR_VAR 0 3
7254: PUSH
7255: EMPTY
7256: ST_TO_ADDR
// for i := 1 to 3 do
7257: LD_ADDR_VAR 0 2
7261: PUSH
7262: DOUBLE
7263: LD_INT 1
7265: DEC
7266: ST_TO_ADDR
7267: LD_INT 3
7269: PUSH
7270: FOR_TO
7271: IFFALSE 7383
// begin uc_side := 3 ;
7273: LD_ADDR_OWVAR 20
7277: PUSH
7278: LD_INT 3
7280: ST_TO_ADDR
// uc_nation := 3 ;
7281: LD_ADDR_OWVAR 21
7285: PUSH
7286: LD_INT 3
7288: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7289: LD_ADDR_OWVAR 37
7293: PUSH
7294: LD_INT 22
7296: ST_TO_ADDR
// vc_engine := engine_siberite ;
7297: LD_ADDR_OWVAR 39
7301: PUSH
7302: LD_INT 3
7304: ST_TO_ADDR
// vc_control := control_computer ;
7305: LD_ADDR_OWVAR 38
7309: PUSH
7310: LD_INT 3
7312: ST_TO_ADDR
// vc_weapon := ru_crane ;
7313: LD_ADDR_OWVAR 40
7317: PUSH
7318: LD_INT 52
7320: ST_TO_ADDR
// veh := CreateVehicle ;
7321: LD_ADDR_VAR 0 4
7325: PUSH
7326: CALL_OW 45
7330: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7331: LD_VAR 0 4
7335: PPUSH
7336: LD_INT 73
7338: PPUSH
7339: LD_INT 122
7341: PPUSH
7342: LD_INT 3
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7352: LD_ADDR_VAR 0 3
7356: PUSH
7357: LD_VAR 0 3
7361: PPUSH
7362: LD_VAR 0 3
7366: PUSH
7367: LD_INT 1
7369: PLUS
7370: PPUSH
7371: LD_VAR 0 4
7375: PPUSH
7376: CALL_OW 1
7380: ST_TO_ADDR
// end ;
7381: GO 7270
7383: POP
7384: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7385: LD_ADDR_EXP 50
7389: PUSH
7390: LD_EXP 50
7394: PPUSH
7395: LD_EXP 7
7399: PPUSH
7400: LD_VAR 0 3
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// tmp := [ ] ;
7410: LD_ADDR_VAR 0 3
7414: PUSH
7415: EMPTY
7416: ST_TO_ADDR
// for i := 1 to 3 do
7417: LD_ADDR_VAR 0 2
7421: PUSH
7422: DOUBLE
7423: LD_INT 1
7425: DEC
7426: ST_TO_ADDR
7427: LD_INT 3
7429: PUSH
7430: FOR_TO
7431: IFFALSE 7543
// begin uc_side := 3 ;
7433: LD_ADDR_OWVAR 20
7437: PUSH
7438: LD_INT 3
7440: ST_TO_ADDR
// uc_nation := 3 ;
7441: LD_ADDR_OWVAR 21
7445: PUSH
7446: LD_INT 3
7448: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7449: LD_ADDR_OWVAR 37
7453: PUSH
7454: LD_INT 22
7456: ST_TO_ADDR
// vc_engine := engine_siberite ;
7457: LD_ADDR_OWVAR 39
7461: PUSH
7462: LD_INT 3
7464: ST_TO_ADDR
// vc_control := control_computer ;
7465: LD_ADDR_OWVAR 38
7469: PUSH
7470: LD_INT 3
7472: ST_TO_ADDR
// vc_weapon := ru_crane ;
7473: LD_ADDR_OWVAR 40
7477: PUSH
7478: LD_INT 52
7480: ST_TO_ADDR
// veh := CreateVehicle ;
7481: LD_ADDR_VAR 0 4
7485: PUSH
7486: CALL_OW 45
7490: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7491: LD_VAR 0 4
7495: PPUSH
7496: LD_INT 22
7498: PPUSH
7499: LD_INT 28
7501: PPUSH
7502: LD_INT 3
7504: PPUSH
7505: LD_INT 0
7507: PPUSH
7508: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7512: LD_ADDR_VAR 0 3
7516: PUSH
7517: LD_VAR 0 3
7521: PPUSH
7522: LD_VAR 0 3
7526: PUSH
7527: LD_INT 1
7529: PLUS
7530: PPUSH
7531: LD_VAR 0 4
7535: PPUSH
7536: CALL_OW 1
7540: ST_TO_ADDR
// end ;
7541: GO 7430
7543: POP
7544: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7545: LD_ADDR_EXP 50
7549: PUSH
7550: LD_EXP 50
7554: PPUSH
7555: LD_EXP 8
7559: PPUSH
7560: LD_VAR 0 3
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: LD_VAR 0 1
7574: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7575: LD_INT 0
7577: PPUSH
7578: PPUSH
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
7584: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7585: LD_INT 0
7587: PPUSH
7588: LD_INT 0
7590: PPUSH
7591: LD_INT 4
7593: PPUSH
7594: LD_INT 0
7596: PPUSH
7597: LD_INT 0
7599: PPUSH
7600: LD_INT 0
7602: PPUSH
7603: LD_INT 0
7605: PPUSH
7606: LD_INT 10
7608: PPUSH
7609: LD_INT 0
7611: PPUSH
7612: CALL 54806 0 9
// side := 4 ;
7616: LD_ADDR_VAR 0 5
7620: PUSH
7621: LD_INT 4
7623: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7624: LD_ADDR_VAR 0 4
7628: PUSH
7629: LD_INT 1
7631: PUSH
7632: LD_INT 144
7634: PUSH
7635: LD_INT 18
7637: PUSH
7638: LD_INT 4
7640: PUSH
7641: LD_INT 0
7643: PUSH
7644: LD_INT 0
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 3
7657: PUSH
7658: LD_INT 137
7660: PUSH
7661: LD_INT 8
7663: PUSH
7664: LD_INT 4
7666: PUSH
7667: LD_INT 0
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: LIST
7680: PUSH
7681: LD_INT 22
7683: PUSH
7684: LD_INT 141
7686: PUSH
7687: LD_INT 8
7689: PUSH
7690: LD_INT 4
7692: PUSH
7693: LD_INT 0
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 25
7709: PUSH
7710: LD_INT 137
7712: PUSH
7713: LD_INT 5
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 0
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: EMPTY
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: PUSH
7733: LD_INT 18
7735: PUSH
7736: LD_INT 137
7738: PUSH
7739: LD_INT 12
7741: PUSH
7742: LD_INT 0
7744: PUSH
7745: LD_INT 0
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 17
7761: PUSH
7762: LD_INT 133
7764: PUSH
7765: LD_INT 4
7767: PUSH
7768: LD_INT 2
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: PUSH
7785: LD_INT 16
7787: PUSH
7788: LD_INT 140
7790: PUSH
7791: LD_INT 11
7793: PUSH
7794: LD_INT 5
7796: PUSH
7797: LD_INT 0
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: LIST
7807: LIST
7808: LIST
7809: LIST
7810: PUSH
7811: LD_INT 8
7813: PUSH
7814: LD_INT 149
7816: PUSH
7817: LD_INT 26
7819: PUSH
7820: LD_INT 4
7822: PUSH
7823: LD_INT 10
7825: PUSH
7826: LD_INT 15
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: LIST
7836: PUSH
7837: LD_INT 8
7839: PUSH
7840: LD_INT 142
7842: PUSH
7843: LD_INT 26
7845: PUSH
7846: LD_INT 1
7848: PUSH
7849: LD_INT 11
7851: PUSH
7852: LD_INT 12
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: LIST
7859: LIST
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 27
7865: PUSH
7866: LD_INT 153
7868: PUSH
7869: LD_INT 32
7871: PUSH
7872: LD_INT 5
7874: PUSH
7875: LD_INT 0
7877: PUSH
7878: LD_INT 0
7880: PUSH
7881: EMPTY
7882: LIST
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 27
7891: PUSH
7892: LD_INT 145
7894: PUSH
7895: LD_INT 32
7897: PUSH
7898: LD_INT 3
7900: PUSH
7901: LD_INT 0
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: LIST
7912: LIST
7913: LIST
7914: PUSH
7915: LD_INT 27
7917: PUSH
7918: LD_INT 138
7920: PUSH
7921: LD_INT 2
7923: PUSH
7924: LD_INT 4
7926: PUSH
7927: LD_INT 0
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 27
7943: PUSH
7944: LD_INT 144
7946: PUSH
7947: LD_INT 13
7949: PUSH
7950: LD_INT 0
7952: PUSH
7953: LD_INT 0
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: LD_INT 26
7969: PUSH
7970: LD_INT 124
7972: PUSH
7973: LD_INT 2
7975: PUSH
7976: LD_INT 4
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 26
7995: PUSH
7996: LD_INT 121
7998: PUSH
7999: LD_INT 2
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 0
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 26
8021: PUSH
8022: LD_INT 118
8024: PUSH
8025: LD_INT 2
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 0
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 29
8047: PUSH
8048: LD_INT 159
8050: PUSH
8051: LD_INT 47
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 0
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: EMPTY
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: LIST
8070: PUSH
8071: LD_INT 32
8073: PUSH
8074: LD_INT 146
8076: PUSH
8077: LD_INT 41
8079: PUSH
8080: LD_INT 0
8082: PUSH
8083: LD_INT 0
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: LIST
8095: LIST
8096: PUSH
8097: LD_INT 33
8099: PUSH
8100: LD_INT 136
8102: PUSH
8103: LD_INT 37
8105: PUSH
8106: LD_INT 0
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: LIST
8122: PUSH
8123: LD_INT 33
8125: PUSH
8126: LD_INT 132
8128: PUSH
8129: LD_INT 34
8131: PUSH
8132: LD_INT 0
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 36
8151: PUSH
8152: LD_INT 124
8154: PUSH
8155: LD_INT 7
8157: PUSH
8158: LD_INT 1
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: LIST
8171: LIST
8172: LIST
8173: LIST
8174: PUSH
8175: LD_INT 5
8177: PUSH
8178: LD_INT 124
8180: PUSH
8181: LD_INT 19
8183: PUSH
8184: LD_INT 0
8186: PUSH
8187: LD_INT 0
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 32
8203: PUSH
8204: LD_INT 127
8206: PUSH
8207: LD_INT 23
8209: PUSH
8210: LD_INT 0
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: EMPTY
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: ST_TO_ADDR
// for i in tmp do
8252: LD_ADDR_VAR 0 2
8256: PUSH
8257: LD_VAR 0 4
8261: PUSH
8262: FOR_IN
8263: IFFALSE 8494
// begin uc_side := side ;
8265: LD_ADDR_OWVAR 20
8269: PUSH
8270: LD_VAR 0 5
8274: ST_TO_ADDR
// uc_nation := nation_american ;
8275: LD_ADDR_OWVAR 21
8279: PUSH
8280: LD_INT 1
8282: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8283: LD_ADDR_OWVAR 42
8287: PUSH
8288: LD_VAR 0 2
8292: PUSH
8293: LD_INT 1
8295: ARRAY
8296: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8297: LD_ADDR_OWVAR 43
8301: PUSH
8302: LD_INT 5
8304: PPUSH
8305: LD_INT 6
8307: PPUSH
8308: CALL_OW 12
8312: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8313: LD_ADDR_OWVAR 44
8317: PUSH
8318: LD_VAR 0 2
8322: PUSH
8323: LD_INT 5
8325: ARRAY
8326: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8327: LD_ADDR_OWVAR 45
8331: PUSH
8332: LD_VAR 0 2
8336: PUSH
8337: LD_INT 6
8339: ARRAY
8340: ST_TO_ADDR
// sr := 0 ;
8341: LD_ADDR_VAR 0 6
8345: PUSH
8346: LD_INT 0
8348: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: PUSH
8358: LD_INT 29
8360: EQUAL
8361: IFFALSE 8373
// sr := mat_oil else
8363: LD_ADDR_VAR 0 6
8367: PUSH
8368: LD_INT 2
8370: ST_TO_ADDR
8371: GO 8395
// if i [ 1 ] = b_siberite_mine then
8373: LD_VAR 0 2
8377: PUSH
8378: LD_INT 1
8380: ARRAY
8381: PUSH
8382: LD_INT 30
8384: EQUAL
8385: IFFALSE 8395
// sr := mat_siberit ;
8387: LD_ADDR_VAR 0 6
8391: PUSH
8392: LD_INT 3
8394: ST_TO_ADDR
// if sr then
8395: LD_VAR 0 6
8399: IFFALSE 8455
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8401: LD_VAR 0 2
8405: PUSH
8406: LD_INT 2
8408: ARRAY
8409: PPUSH
8410: LD_VAR 0 2
8414: PUSH
8415: LD_INT 3
8417: ARRAY
8418: PPUSH
8419: LD_VAR 0 6
8423: PPUSH
8424: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8428: LD_VAR 0 2
8432: PUSH
8433: LD_INT 2
8435: ARRAY
8436: PPUSH
8437: LD_VAR 0 2
8441: PUSH
8442: LD_INT 3
8444: ARRAY
8445: PPUSH
8446: LD_VAR 0 5
8450: PPUSH
8451: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8455: LD_ADDR_VAR 0 3
8459: PUSH
8460: LD_VAR 0 2
8464: PUSH
8465: LD_INT 2
8467: ARRAY
8468: PPUSH
8469: LD_VAR 0 2
8473: PUSH
8474: LD_INT 3
8476: ARRAY
8477: PPUSH
8478: LD_VAR 0 2
8482: PUSH
8483: LD_INT 4
8485: ARRAY
8486: PPUSH
8487: CALL_OW 47
8491: ST_TO_ADDR
// end ;
8492: GO 8262
8494: POP
8495: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8496: LD_ADDR_VAR 0 8
8500: PUSH
8501: LD_INT 22
8503: PUSH
8504: LD_VAR 0 5
8508: PUSH
8509: EMPTY
8510: LIST
8511: LIST
8512: PUSH
8513: LD_INT 30
8515: PUSH
8516: LD_INT 1
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: PPUSH
8527: CALL_OW 69
8531: ST_TO_ADDR
// if not depot then
8532: LD_VAR 0 8
8536: NOT
8537: IFFALSE 8541
// exit ;
8539: GO 8813
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8541: LD_ADDR_VAR 0 7
8545: PUSH
8546: LD_VAR 0 8
8550: PUSH
8551: LD_INT 1
8553: ARRAY
8554: PPUSH
8555: LD_INT 3
8557: PPUSH
8558: LD_STRING theta3
8560: PPUSH
8561: LD_INT 8
8563: PUSH
8564: LD_INT 7
8566: PUSH
8567: LD_INT 6
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: LIST
8574: PUSH
8575: LD_OWVAR 67
8579: ARRAY
8580: PPUSH
8581: LD_INT 2500
8583: PUSH
8584: LD_INT 2000
8586: PUSH
8587: LD_INT 1750
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: PUSH
8601: LD_INT 300
8603: PUSH
8604: LD_INT 250
8606: PUSH
8607: LD_INT 200
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: LIST
8614: PUSH
8615: LD_OWVAR 67
8619: ARRAY
8620: PUSH
8621: LD_INT 80
8623: PUSH
8624: LD_INT 60
8626: PUSH
8627: LD_INT 50
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: PPUSH
8646: LD_INT 7
8648: PUSH
8649: LD_INT 6
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: LD_INT 5
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: PPUSH
8664: CALL 28812 0 6
8668: ST_TO_ADDR
// if not base then
8669: LD_VAR 0 7
8673: NOT
8674: IFFALSE 8678
// exit ;
8676: GO 8813
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8678: LD_ADDR_EXP 31
8682: PUSH
8683: LD_EXP 31
8687: PPUSH
8688: LD_EXP 5
8692: PPUSH
8693: LD_VAR 0 7
8697: PPUSH
8698: CALL_OW 1
8702: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8703: LD_INT 1
8705: PPUSH
8706: LD_INT 1
8708: PPUSH
8709: LD_INT 7
8711: PPUSH
8712: CALL_OW 380
// allyCommander := CreateHuman ;
8716: LD_ADDR_EXP 11
8720: PUSH
8721: CALL_OW 44
8725: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8726: LD_EXP 11
8730: PPUSH
8731: LD_INT 139
8733: PPUSH
8734: LD_INT 15
8736: PPUSH
8737: LD_INT 0
8739: PPUSH
8740: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8744: LD_EXP 11
8748: PPUSH
8749: LD_INT 137
8751: PPUSH
8752: LD_INT 15
8754: PPUSH
8755: CALL_OW 118
// hc_gallery := us ;
8759: LD_ADDR_OWVAR 33
8763: PUSH
8764: LD_STRING us
8766: ST_TO_ADDR
// hc_face_number := 7 ;
8767: LD_ADDR_OWVAR 34
8771: PUSH
8772: LD_INT 7
8774: ST_TO_ADDR
// hc_name := Arthur Powell ;
8775: LD_ADDR_OWVAR 26
8779: PUSH
8780: LD_STRING Arthur Powell
8782: ST_TO_ADDR
// hc_sex := sex_male ;
8783: LD_ADDR_OWVAR 27
8787: PUSH
8788: LD_INT 1
8790: ST_TO_ADDR
// hc_class := 1 ;
8791: LD_ADDR_OWVAR 28
8795: PUSH
8796: LD_INT 1
8798: ST_TO_ADDR
// Powell := CreateHuman ;
8799: LD_ADDR_EXP 12
8803: PUSH
8804: CALL_OW 44
8808: ST_TO_ADDR
// InitHc ;
8809: CALL_OW 19
// end ;
8813: LD_VAR 0 1
8817: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8818: LD_INT 0
8820: PPUSH
8821: PPUSH
8822: PPUSH
8823: PPUSH
8824: PPUSH
8825: PPUSH
8826: PPUSH
8827: PPUSH
8828: PPUSH
// side := 1 ;
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_INT 1
8836: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8837: LD_ADDR_VAR 0 1
8841: PUSH
8842: EMPTY
8843: PUSH
8844: EMPTY
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// uc_side := side ;
8850: LD_ADDR_OWVAR 20
8854: PUSH
8855: LD_VAR 0 3
8859: ST_TO_ADDR
// uc_nation := nation_american ;
8860: LD_ADDR_OWVAR 21
8864: PUSH
8865: LD_INT 1
8867: ST_TO_ADDR
// InitHc ;
8868: CALL_OW 19
// InitVc ;
8872: CALL_OW 20
// hc_importance := 0 ;
8876: LD_ADDR_OWVAR 32
8880: PUSH
8881: LD_INT 0
8883: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8884: LD_ADDR_VAR 0 7
8888: PUSH
8889: LD_INT 2
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 3
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: LIST
8902: ST_TO_ADDR
// if commander = 2 then
8903: LD_EXP 25
8907: PUSH
8908: LD_INT 2
8910: EQUAL
8911: IFFALSE 8932
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: LD_INT 4
8923: PUSH
8924: LD_INT 4
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 3 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 3
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 2
8949: PUSH
8950: LD_INT 5
8952: PUSH
8953: LD_INT 5
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8961: LD_ADDR_VAR 0 8
8965: PUSH
8966: LD_INT 2
8968: PUSH
8969: LD_INT 2
8971: PUSH
8972: LD_INT 1
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: ST_TO_ADDR
// if commander = 2 then
8980: LD_EXP 25
8984: PUSH
8985: LD_INT 2
8987: EQUAL
8988: IFFALSE 9009
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 1
8997: PUSH
8998: LD_INT 1
9000: PUSH
9001: LD_INT 3
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 3 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 3
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 3
9026: PUSH
9027: LD_INT 3
9029: PUSH
9030: LD_INT 1
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9038: LD_ADDR_VAR 0 9
9042: PUSH
9043: LD_INT 5
9045: PUSH
9046: LD_INT 3
9048: PUSH
9049: LD_INT 4
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: ST_TO_ADDR
// if commander = 2 then
9057: LD_EXP 25
9061: PUSH
9062: LD_INT 2
9064: EQUAL
9065: IFFALSE 9086
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 7
9074: PUSH
9075: LD_INT 5
9077: PUSH
9078: LD_INT 6
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 3 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 3
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 9
9103: PUSH
9104: LD_INT 10
9106: PUSH
9107: LD_INT 7
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9115: LD_ADDR_VAR 0 5
9119: PUSH
9120: LD_INT 5
9122: PUSH
9123: LD_INT 5
9125: PUSH
9126: LD_INT 4
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: PUSH
9134: LD_OWVAR 67
9138: ARRAY
9139: ST_TO_ADDR
// if commander = 2 then
9140: LD_EXP 25
9144: PUSH
9145: LD_INT 2
9147: EQUAL
9148: IFFALSE 9164
// tanks := tanks + 3 ;
9150: LD_ADDR_VAR 0 5
9154: PUSH
9155: LD_VAR 0 5
9159: PUSH
9160: LD_INT 3
9162: PLUS
9163: ST_TO_ADDR
// for i = 1 to tanks do
9164: LD_ADDR_VAR 0 2
9168: PUSH
9169: DOUBLE
9170: LD_INT 1
9172: DEC
9173: ST_TO_ADDR
9174: LD_VAR 0 5
9178: PUSH
9179: FOR_TO
9180: IFFALSE 9290
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9182: LD_VAR 0 7
9186: PUSH
9187: LD_VAR 0 2
9191: PUSH
9192: LD_INT 3
9194: MOD
9195: PUSH
9196: LD_INT 1
9198: PLUS
9199: ARRAY
9200: PPUSH
9201: LD_VAR 0 8
9205: PUSH
9206: LD_INT 1
9208: PPUSH
9209: LD_INT 3
9211: PPUSH
9212: CALL_OW 12
9216: ARRAY
9217: PPUSH
9218: LD_INT 1
9220: PPUSH
9221: LD_VAR 0 9
9225: PUSH
9226: LD_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: MOD
9234: PUSH
9235: LD_INT 1
9237: PLUS
9238: ARRAY
9239: PPUSH
9240: LD_INT 60
9242: PPUSH
9243: LD_INT 70
9245: PPUSH
9246: CALL_OW 12
9250: PPUSH
9251: CALL 24975 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9255: LD_ADDR_VAR 0 1
9259: PUSH
9260: LD_VAR 0 1
9264: PPUSH
9265: LD_INT 1
9267: PPUSH
9268: LD_VAR 0 1
9272: PUSH
9273: LD_INT 1
9275: ARRAY
9276: PUSH
9277: CALL_OW 45
9281: ADD
9282: PPUSH
9283: CALL_OW 1
9287: ST_TO_ADDR
// end ;
9288: GO 9179
9290: POP
9291: POP
// cl := 1 ;
9292: LD_ADDR_VAR 0 6
9296: PUSH
9297: LD_INT 1
9299: ST_TO_ADDR
// for i = 1 to 10 do
9300: LD_ADDR_VAR 0 2
9304: PUSH
9305: DOUBLE
9306: LD_INT 1
9308: DEC
9309: ST_TO_ADDR
9310: LD_INT 10
9312: PUSH
9313: FOR_TO
9314: IFFALSE 9429
// begin if i mod 4 = 0 then
9316: LD_VAR 0 2
9320: PUSH
9321: LD_INT 4
9323: MOD
9324: PUSH
9325: LD_INT 0
9327: EQUAL
9328: IFFALSE 9344
// cl := cl + 1 ;
9330: LD_ADDR_VAR 0 6
9334: PUSH
9335: LD_VAR 0 6
9339: PUSH
9340: LD_INT 1
9342: PLUS
9343: ST_TO_ADDR
// if cl = 2 then
9344: LD_VAR 0 6
9348: PUSH
9349: LD_INT 2
9351: EQUAL
9352: IFFALSE 9362
// cl := 3 ;
9354: LD_ADDR_VAR 0 6
9358: PUSH
9359: LD_INT 3
9361: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9362: LD_INT 0
9364: PPUSH
9365: LD_VAR 0 6
9369: PPUSH
9370: LD_INT 6
9372: PUSH
9373: LD_INT 6
9375: PUSH
9376: LD_INT 5
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: LIST
9383: PUSH
9384: LD_OWVAR 67
9388: ARRAY
9389: PPUSH
9390: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9394: LD_ADDR_VAR 0 1
9398: PUSH
9399: LD_VAR 0 1
9403: PPUSH
9404: LD_INT 2
9406: PPUSH
9407: LD_VAR 0 1
9411: PUSH
9412: LD_INT 2
9414: ARRAY
9415: PUSH
9416: CALL_OW 44
9420: ADD
9421: PPUSH
9422: CALL_OW 1
9426: ST_TO_ADDR
// end ;
9427: GO 9313
9429: POP
9430: POP
// if commander = 1 then
9431: LD_EXP 25
9435: PUSH
9436: LD_INT 1
9438: EQUAL
9439: IFFALSE 9507
// for i = 1 to 4 do
9441: LD_ADDR_VAR 0 2
9445: PUSH
9446: DOUBLE
9447: LD_INT 1
9449: DEC
9450: ST_TO_ADDR
9451: LD_INT 4
9453: PUSH
9454: FOR_TO
9455: IFFALSE 9505
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9457: LD_INT 0
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 8
9465: PPUSH
9466: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9470: LD_ADDR_VAR 0 1
9474: PUSH
9475: LD_VAR 0 1
9479: PPUSH
9480: LD_INT 2
9482: PPUSH
9483: LD_VAR 0 1
9487: PUSH
9488: LD_INT 2
9490: ARRAY
9491: PUSH
9492: CALL_OW 44
9496: ADD
9497: PPUSH
9498: CALL_OW 1
9502: ST_TO_ADDR
// end ;
9503: GO 9454
9505: POP
9506: POP
// techs := [ ] ;
9507: LD_ADDR_VAR 0 4
9511: PUSH
9512: EMPTY
9513: ST_TO_ADDR
// if commander = 1 then
9514: LD_EXP 25
9518: PUSH
9519: LD_INT 1
9521: EQUAL
9522: IFFALSE 9547
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9524: LD_ADDR_VAR 0 4
9528: PUSH
9529: LD_INT 51
9531: PUSH
9532: LD_INT 52
9534: PUSH
9535: LD_INT 53
9537: PUSH
9538: LD_INT 12
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: ST_TO_ADDR
// if commander = 2 then
9547: LD_EXP 25
9551: PUSH
9552: LD_INT 2
9554: EQUAL
9555: IFFALSE 9592
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9557: LD_ADDR_VAR 0 4
9561: PUSH
9562: LD_INT 48
9564: PUSH
9565: LD_INT 47
9567: PUSH
9568: LD_INT 46
9570: PUSH
9571: LD_INT 45
9573: PUSH
9574: LD_INT 35
9576: PUSH
9577: LD_INT 60
9579: PUSH
9580: LD_INT 6
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: LIST
9589: LIST
9590: LIST
9591: ST_TO_ADDR
// if commander = 3 then
9592: LD_EXP 25
9596: PUSH
9597: LD_INT 3
9599: EQUAL
9600: IFFALSE 9649
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9602: LD_ADDR_VAR 0 4
9606: PUSH
9607: LD_INT 27
9609: PUSH
9610: LD_INT 36
9612: PUSH
9613: LD_INT 32
9615: PUSH
9616: LD_INT 57
9618: PUSH
9619: LD_INT 58
9621: PUSH
9622: LD_INT 47
9624: PUSH
9625: LD_INT 46
9627: PUSH
9628: LD_INT 51
9630: PUSH
9631: LD_INT 69
9633: PUSH
9634: LD_INT 39
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: ST_TO_ADDR
// if techs then
9649: LD_VAR 0 4
9653: IFFALSE 9687
// for i in techs do
9655: LD_ADDR_VAR 0 2
9659: PUSH
9660: LD_VAR 0 4
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9685
// SetTech ( i , 1 , state_researched ) ;
9668: LD_VAR 0 2
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_INT 2
9678: PPUSH
9679: CALL_OW 322
9683: GO 9665
9685: POP
9686: POP
// hc_gallery := skirmish ;
9687: LD_ADDR_OWVAR 33
9691: PUSH
9692: LD_STRING skirmish
9694: ST_TO_ADDR
// hc_face_number := commander ;
9695: LD_ADDR_OWVAR 34
9699: PUSH
9700: LD_EXP 25
9704: ST_TO_ADDR
// hc_importance := 100 ;
9705: LD_ADDR_OWVAR 32
9709: PUSH
9710: LD_INT 100
9712: ST_TO_ADDR
// case commander of 1 :
9713: LD_EXP 25
9717: PUSH
9718: LD_INT 1
9720: DOUBLE
9721: EQUAL
9722: IFTRUE 9726
9724: GO 9750
9726: POP
// begin hc_name := Jeff Ironside ;
9727: LD_ADDR_OWVAR 26
9731: PUSH
9732: LD_STRING Jeff Ironside
9734: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9735: LD_INT 1
9737: PPUSH
9738: LD_INT 1
9740: PPUSH
9741: LD_INT 7
9743: PPUSH
9744: CALL_OW 380
// end ; 2 :
9748: GO 9815
9750: LD_INT 2
9752: DOUBLE
9753: EQUAL
9754: IFTRUE 9758
9756: GO 9782
9758: POP
// begin hc_name := Paul Johnson ;
9759: LD_ADDR_OWVAR 26
9763: PUSH
9764: LD_STRING Paul Johnson
9766: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 3
9772: PPUSH
9773: LD_INT 7
9775: PPUSH
9776: CALL_OW 380
// end ; 3 :
9780: GO 9815
9782: LD_INT 3
9784: DOUBLE
9785: EQUAL
9786: IFTRUE 9790
9788: GO 9814
9790: POP
// begin hc_name := Lisa Stuart ;
9791: LD_ADDR_OWVAR 26
9795: PUSH
9796: LD_STRING Lisa Stuart
9798: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9799: LD_INT 2
9801: PPUSH
9802: LD_INT 4
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: CALL_OW 380
// end ; end ;
9812: GO 9815
9814: POP
// playerCommander := CreateHuman ;
9815: LD_ADDR_EXP 9
9819: PUSH
9820: CALL_OW 44
9824: ST_TO_ADDR
// hc_importance := 0 ;
9825: LD_ADDR_OWVAR 32
9829: PUSH
9830: LD_INT 0
9832: ST_TO_ADDR
// hc_gallery :=  ;
9833: LD_ADDR_OWVAR 33
9837: PUSH
9838: LD_STRING 
9840: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9841: LD_ADDR_VAR 0 1
9845: PUSH
9846: LD_VAR 0 1
9850: PPUSH
9851: LD_INT 2
9853: PPUSH
9854: LD_VAR 0 1
9858: PUSH
9859: LD_INT 2
9861: ARRAY
9862: PUSH
9863: LD_EXP 9
9867: ADD
9868: PPUSH
9869: CALL_OW 1
9873: ST_TO_ADDR
// end ;
9874: LD_VAR 0 1
9878: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9879: LD_INT 0
9881: PPUSH
9882: PPUSH
9883: PPUSH
9884: PPUSH
9885: PPUSH
9886: PPUSH
// uc_side := 1 ;
9887: LD_ADDR_OWVAR 20
9891: PUSH
9892: LD_INT 1
9894: ST_TO_ADDR
// uc_nation := 1 ;
9895: LD_ADDR_OWVAR 21
9899: PUSH
9900: LD_INT 1
9902: ST_TO_ADDR
// InitHc ;
9903: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9907: LD_ADDR_VAR 0 3
9911: PUSH
9912: LD_INT 3
9914: PUSH
9915: LD_INT 3
9917: PUSH
9918: LD_INT 2
9920: PUSH
9921: EMPTY
9922: LIST
9923: LIST
9924: LIST
9925: PUSH
9926: LD_OWVAR 67
9930: ARRAY
9931: ST_TO_ADDR
// for i = 1 to peopleAmount do
9932: LD_ADDR_VAR 0 2
9936: PUSH
9937: DOUBLE
9938: LD_INT 1
9940: DEC
9941: ST_TO_ADDR
9942: LD_VAR 0 3
9946: PUSH
9947: FOR_TO
9948: IFFALSE 9997
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9950: LD_INT 0
9952: PPUSH
9953: LD_INT 2
9955: PPUSH
9956: LD_INT 7
9958: PUSH
9959: LD_INT 6
9961: PUSH
9962: LD_INT 5
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: PUSH
9970: LD_OWVAR 67
9974: ARRAY
9975: PPUSH
9976: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
9980: CALL_OW 44
9984: PPUSH
9985: LD_INT 19
9987: PPUSH
9988: LD_INT 0
9990: PPUSH
9991: CALL 57048 0 3
// end ;
9995: GO 9947
9997: POP
9998: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
9999: LD_INT 2
10001: PPUSH
10002: LD_INT 1
10004: PPUSH
10005: LD_INT 3
10007: PPUSH
10008: LD_INT 13
10010: PPUSH
10011: LD_INT 58
10013: PPUSH
10014: CALL 24975 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10018: CALL_OW 45
10022: PPUSH
10023: LD_INT 19
10025: PPUSH
10026: LD_INT 0
10028: PPUSH
10029: CALL 57048 0 3
// if commander = 1 then
10033: LD_EXP 25
10037: PUSH
10038: LD_INT 1
10040: EQUAL
10041: IFFALSE 10052
// wait ( 6 6$00 ) else
10043: LD_INT 12600
10045: PPUSH
10046: CALL_OW 67
10050: GO 10059
// wait ( 8 8$00 ) ;
10052: LD_INT 16800
10054: PPUSH
10055: CALL_OW 67
// uc_side := 1 ;
10059: LD_ADDR_OWVAR 20
10063: PUSH
10064: LD_INT 1
10066: ST_TO_ADDR
// uc_nation := 1 ;
10067: LD_ADDR_OWVAR 21
10071: PUSH
10072: LD_INT 1
10074: ST_TO_ADDR
// InitVc ;
10075: CALL_OW 20
// InitHc ;
10079: CALL_OW 19
// for i = 1 to 5 do
10083: LD_ADDR_VAR 0 2
10087: PUSH
10088: DOUBLE
10089: LD_INT 1
10091: DEC
10092: ST_TO_ADDR
10093: LD_INT 5
10095: PUSH
10096: FOR_TO
10097: IFFALSE 10341
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10099: LD_INT 4
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 1
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: LIST
10112: PUSH
10113: LD_VAR 0 2
10117: PUSH
10118: LD_INT 3
10120: MOD
10121: PUSH
10122: LD_INT 1
10124: PLUS
10125: ARRAY
10126: PPUSH
10127: LD_INT 1
10129: PPUSH
10130: LD_INT 1
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: LD_INT 3
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_VAR 0 2
10148: PUSH
10149: LD_INT 3
10151: MOD
10152: PUSH
10153: LD_INT 1
10155: PLUS
10156: ARRAY
10157: PPUSH
10158: LD_INT 6
10160: PUSH
10161: LD_INT 12
10163: PUSH
10164: LD_INT 11
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: LIST
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 3
10179: MOD
10180: PUSH
10181: LD_INT 1
10183: PLUS
10184: ARRAY
10185: PPUSH
10186: LD_INT 40
10188: PPUSH
10189: LD_INT 55
10191: PPUSH
10192: CALL_OW 12
10196: PPUSH
10197: CALL 24975 0 5
// veh := CreateVehicle ;
10201: LD_ADDR_VAR 0 6
10205: PUSH
10206: CALL_OW 45
10210: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10211: LD_VAR 0 6
10215: PPUSH
10216: LD_INT 19
10218: PPUSH
10219: LD_INT 0
10221: PPUSH
10222: CALL 57048 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10226: LD_VAR 0 6
10230: PPUSH
10231: CALL_OW 264
10235: PUSH
10236: LD_INT 12
10238: EQUAL
10239: IFFALSE 10271
// begin AddCargo ( veh , mat_cans , 70 ) ;
10241: LD_VAR 0 6
10245: PPUSH
10246: LD_INT 1
10248: PPUSH
10249: LD_INT 70
10251: PPUSH
10252: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10256: LD_VAR 0 6
10260: PPUSH
10261: LD_INT 3
10263: PPUSH
10264: LD_INT 30
10266: PPUSH
10267: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10271: LD_VAR 0 6
10275: PPUSH
10276: CALL_OW 263
10280: PUSH
10281: LD_INT 1
10283: EQUAL
10284: IFFALSE 10339
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10286: LD_INT 1
10288: PPUSH
10289: LD_INT 3
10291: PPUSH
10292: LD_INT 6
10294: PPUSH
10295: CALL_OW 380
// un := CreateHuman ;
10299: LD_ADDR_VAR 0 5
10303: PUSH
10304: CALL_OW 44
10308: ST_TO_ADDR
// tmp := tmp ^ un ;
10309: LD_ADDR_VAR 0 4
10313: PUSH
10314: LD_VAR 0 4
10318: PUSH
10319: LD_VAR 0 5
10323: ADD
10324: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10325: LD_VAR 0 5
10329: PPUSH
10330: LD_VAR 0 6
10334: PPUSH
10335: CALL_OW 52
// end ; end ;
10339: GO 10096
10341: POP
10342: POP
// if tmp then
10343: LD_VAR 0 4
10347: IFFALSE 10411
// begin CenterNowOnUnits ( tmp ) ;
10349: LD_VAR 0 4
10353: PPUSH
10354: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10358: LD_VAR 0 4
10362: PUSH
10363: LD_INT 1
10365: ARRAY
10366: PPUSH
10367: LD_STRING DAR-1
10369: PPUSH
10370: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10374: LD_EXP 9
10378: PPUSH
10379: LD_STRING D
10381: PUSH
10382: LD_STRING I
10384: PUSH
10385: LD_STRING J
10387: PUSH
10388: LD_STRING S
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: LIST
10395: PUSH
10396: LD_EXP 25
10400: ARRAY
10401: STR
10402: PUSH
10403: LD_STRING -1-DAR
10405: STR
10406: PPUSH
10407: CALL_OW 88
// end ; if not reinforceAllowed then
10411: LD_EXP 24
10415: NOT
10416: IFFALSE 10420
// exit ;
10418: GO 10574
// wait ( 25 25$00 ) ;
10420: LD_INT 52500
10422: PPUSH
10423: CALL_OW 67
// uc_side := 1 ;
10427: LD_ADDR_OWVAR 20
10431: PUSH
10432: LD_INT 1
10434: ST_TO_ADDR
// uc_nation := 1 ;
10435: LD_ADDR_OWVAR 21
10439: PUSH
10440: LD_INT 1
10442: ST_TO_ADDR
// InitVc ;
10443: CALL_OW 20
// InitHc ;
10447: CALL_OW 19
// for i = 1 to 4 do
10451: LD_ADDR_VAR 0 2
10455: PUSH
10456: DOUBLE
10457: LD_INT 1
10459: DEC
10460: ST_TO_ADDR
10461: LD_INT 4
10463: PUSH
10464: FOR_TO
10465: IFFALSE 10572
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10467: LD_INT 5
10469: PPUSH
10470: LD_INT 3
10472: PPUSH
10473: LD_INT 1
10475: PPUSH
10476: LD_INT 6
10478: PPUSH
10479: LD_INT 1
10481: PPUSH
10482: CALL 24975 0 5
// veh := CreateVehicle ;
10486: LD_ADDR_VAR 0 6
10490: PUSH
10491: CALL_OW 45
10495: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10496: LD_VAR 0 6
10500: PPUSH
10501: LD_INT 19
10503: PPUSH
10504: LD_INT 0
10506: PPUSH
10507: CALL 57048 0 3
// if GetControl ( veh ) = control_manual then
10511: LD_VAR 0 6
10515: PPUSH
10516: CALL_OW 263
10520: PUSH
10521: LD_INT 1
10523: EQUAL
10524: IFFALSE 10570
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10526: LD_INT 0
10528: PPUSH
10529: LD_INT 3
10531: PPUSH
10532: LD_INT 7
10534: PUSH
10535: LD_INT 6
10537: PUSH
10538: LD_INT 5
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: LIST
10545: PUSH
10546: LD_OWVAR 67
10550: ARRAY
10551: PPUSH
10552: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10556: CALL_OW 44
10560: PPUSH
10561: LD_VAR 0 6
10565: PPUSH
10566: CALL_OW 52
// end ; end ;
10570: GO 10464
10572: POP
10573: POP
// end ;
10574: LD_VAR 0 1
10578: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10579: LD_INT 0
10581: PPUSH
10582: PPUSH
10583: PPUSH
10584: PPUSH
10585: PPUSH
// uc_side := 8 ;
10586: LD_ADDR_OWVAR 20
10590: PUSH
10591: LD_INT 8
10593: ST_TO_ADDR
// uc_nation := nation_arabian ;
10594: LD_ADDR_OWVAR 21
10598: PUSH
10599: LD_INT 2
10601: ST_TO_ADDR
// for i = 1 to 2 do
10602: LD_ADDR_VAR 0 2
10606: PUSH
10607: DOUBLE
10608: LD_INT 1
10610: DEC
10611: ST_TO_ADDR
10612: LD_INT 2
10614: PUSH
10615: FOR_TO
10616: IFFALSE 10696
// for j = 1 to 4 do
10618: LD_ADDR_VAR 0 4
10622: PUSH
10623: DOUBLE
10624: LD_INT 1
10626: DEC
10627: ST_TO_ADDR
10628: LD_INT 4
10630: PUSH
10631: FOR_TO
10632: IFFALSE 10692
// begin PrepareHuman ( false , j , 8 ) ;
10634: LD_INT 0
10636: PPUSH
10637: LD_VAR 0 4
10641: PPUSH
10642: LD_INT 8
10644: PPUSH
10645: CALL_OW 380
// un := CreateHuman ;
10649: LD_ADDR_VAR 0 3
10653: PUSH
10654: CALL_OW 44
10658: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10659: LD_VAR 0 3
10663: PPUSH
10664: LD_INT 23
10666: PPUSH
10667: LD_INT 0
10669: PPUSH
10670: CALL_OW 49
// tmp := tmp union un ;
10674: LD_ADDR_VAR 0 5
10678: PUSH
10679: LD_VAR 0 5
10683: PUSH
10684: LD_VAR 0 3
10688: UNION
10689: ST_TO_ADDR
// end ;
10690: GO 10631
10692: POP
10693: POP
10694: GO 10615
10696: POP
10697: POP
// for i in tmp do
10698: LD_ADDR_VAR 0 2
10702: PUSH
10703: LD_VAR 0 5
10707: PUSH
10708: FOR_IN
10709: IFFALSE 10728
// ComMoveXY ( i , 150 , 136 ) ;
10711: LD_VAR 0 2
10715: PPUSH
10716: LD_INT 150
10718: PPUSH
10719: LD_INT 136
10721: PPUSH
10722: CALL_OW 111
10726: GO 10708
10728: POP
10729: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10730: LD_ADDR_EXP 31
10734: PUSH
10735: LD_EXP 31
10739: PPUSH
10740: LD_EXP 6
10744: PPUSH
10745: LD_EXP 31
10749: PUSH
10750: LD_EXP 6
10754: ARRAY
10755: PUSH
10756: LD_VAR 0 5
10760: UNION
10761: PPUSH
10762: CALL_OW 1
10766: ST_TO_ADDR
// end ;
10767: LD_VAR 0 1
10771: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10772: LD_OWVAR 67
10776: PUSH
10777: LD_INT 1
10779: GREATER
10780: IFFALSE 10798
10782: PUSH
10783: LD_INT 31
10785: PPUSH
10786: LD_INT 3
10788: PPUSH
10789: CALL_OW 321
10793: PUSH
10794: LD_INT 2
10796: EQUAL
10797: AND
10798: IFFALSE 11015
10800: GO 10802
10802: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10803: LD_EXP 7
10807: PPUSH
10808: LD_INT 33
10810: PUSH
10811: LD_INT 101
10813: PUSH
10814: LD_INT 159
10816: PUSH
10817: LD_INT 5
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 33
10828: PUSH
10829: LD_INT 105
10831: PUSH
10832: LD_INT 158
10834: PUSH
10835: LD_INT 5
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: PUSH
10844: LD_INT 33
10846: PUSH
10847: LD_INT 96
10849: PUSH
10850: LD_INT 136
10852: PUSH
10853: LD_INT 5
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: PUSH
10862: LD_INT 33
10864: PUSH
10865: LD_INT 94
10867: PUSH
10868: LD_INT 133
10870: PUSH
10871: LD_INT 4
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: PUSH
10880: LD_INT 33
10882: PUSH
10883: LD_INT 84
10885: PUSH
10886: LD_INT 102
10888: PUSH
10889: LD_INT 4
10891: PUSH
10892: EMPTY
10893: LIST
10894: LIST
10895: LIST
10896: LIST
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: PPUSH
10905: CALL 87939 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10909: LD_EXP 8
10913: PPUSH
10914: LD_INT 33
10916: PUSH
10917: LD_INT 50
10919: PUSH
10920: LD_INT 17
10922: PUSH
10923: LD_INT 4
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 33
10934: PUSH
10935: LD_INT 52
10937: PUSH
10938: LD_INT 20
10940: PUSH
10941: LD_INT 4
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: PUSH
10950: LD_INT 33
10952: PUSH
10953: LD_INT 53
10955: PUSH
10956: LD_INT 23
10958: PUSH
10959: LD_INT 4
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: PUSH
10968: LD_INT 33
10970: PUSH
10971: LD_INT 45
10973: PUSH
10974: LD_INT 32
10976: PUSH
10977: LD_INT 4
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: LIST
10984: LIST
10985: PUSH
10986: LD_INT 33
10988: PUSH
10989: LD_INT 45
10991: PUSH
10992: LD_INT 39
10994: PUSH
10995: LD_INT 4
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: LIST
11008: LIST
11009: LIST
11010: PPUSH
11011: CALL 87939 0 2
// end ;
11015: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11016: LD_INT 3
11018: PUSH
11019: LD_INT 22
11021: PUSH
11022: LD_OWVAR 2
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: PUSH
11035: LD_INT 33
11037: PUSH
11038: LD_INT 2
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 50
11047: PUSH
11048: EMPTY
11049: LIST
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 61
11056: PUSH
11057: EMPTY
11058: LIST
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: PPUSH
11070: CALL_OW 69
11074: IFFALSE 11174
11076: GO 11078
11078: DISABLE
11079: LD_INT 0
11081: PPUSH
11082: PPUSH
// begin enable ;
11083: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11084: LD_ADDR_VAR 0 2
11088: PUSH
11089: LD_INT 3
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_OWVAR 2
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 33
11110: PUSH
11111: LD_INT 2
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 50
11120: PUSH
11121: EMPTY
11122: LIST
11123: PUSH
11124: LD_INT 3
11126: PUSH
11127: LD_INT 61
11129: PUSH
11130: EMPTY
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: PPUSH
11143: CALL_OW 69
11147: ST_TO_ADDR
// for i in tmp do
11148: LD_ADDR_VAR 0 1
11152: PUSH
11153: LD_VAR 0 2
11157: PUSH
11158: FOR_IN
11159: IFFALSE 11172
// Connect ( i ) ;
11161: LD_VAR 0 1
11165: PPUSH
11166: CALL 28457 0 1
11170: GO 11158
11172: POP
11173: POP
// end ; end_of_file
11174: PPOPN 2
11176: END
// export function Action ; var i , tmp ; begin
11177: LD_INT 0
11179: PPUSH
11180: PPUSH
11181: PPUSH
// InGameOn ;
11182: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11186: LD_INT 225
11188: PPUSH
11189: LD_INT 217
11191: PPUSH
11192: CALL_OW 86
// for i in playerForces [ 2 ] do
11196: LD_ADDR_VAR 0 2
11200: PUSH
11201: LD_EXP 10
11205: PUSH
11206: LD_INT 2
11208: ARRAY
11209: PUSH
11210: FOR_IN
11211: IFFALSE 11346
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11213: LD_EXP 10
11217: PUSH
11218: LD_INT 1
11220: ARRAY
11221: IFFALSE 11245
11223: PUSH
11224: LD_VAR 0 2
11228: PPUSH
11229: CALL_OW 257
11233: PUSH
11234: LD_INT 3
11236: PUSH
11237: LD_INT 4
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: IN
11244: AND
11245: IFFALSE 11329
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11247: LD_EXP 10
11251: PUSH
11252: LD_INT 1
11254: ARRAY
11255: PUSH
11256: LD_INT 1
11258: ARRAY
11259: PPUSH
11260: LD_INT 19
11262: PPUSH
11263: LD_INT 0
11265: PPUSH
11266: CALL 57048 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11270: LD_VAR 0 2
11274: PPUSH
11275: LD_EXP 10
11279: PUSH
11280: LD_INT 1
11282: ARRAY
11283: PUSH
11284: LD_INT 1
11286: ARRAY
11287: PPUSH
11288: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11292: LD_ADDR_EXP 10
11296: PUSH
11297: LD_EXP 10
11301: PPUSH
11302: LD_INT 1
11304: PPUSH
11305: LD_EXP 10
11309: PUSH
11310: LD_INT 1
11312: ARRAY
11313: PPUSH
11314: LD_INT 1
11316: PPUSH
11317: CALL_OW 3
11321: PPUSH
11322: CALL_OW 1
11326: ST_TO_ADDR
// end else
11327: GO 11344
// PlaceUnitInArea ( i , startArea , false ) ;
11329: LD_VAR 0 2
11333: PPUSH
11334: LD_INT 19
11336: PPUSH
11337: LD_INT 0
11339: PPUSH
11340: CALL 57048 0 3
// end ;
11344: GO 11210
11346: POP
11347: POP
// wait ( 0 0$2 ) ;
11348: LD_INT 70
11350: PPUSH
11351: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING D
11362: PUSH
11363: LD_STRING I
11365: PUSH
11366: LD_STRING J
11368: PUSH
11369: LD_STRING S
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: LIST
11376: PUSH
11377: LD_EXP 25
11381: ARRAY
11382: STR
11383: PUSH
11384: LD_STRING -1
11386: STR
11387: PPUSH
11388: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11392: LD_EXP 12
11396: PPUSH
11397: LD_STRING DP-1
11399: PPUSH
11400: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11404: LD_EXP 12
11408: PPUSH
11409: LD_STRING DP-2
11411: PPUSH
11412: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11416: LD_EXP 9
11420: PPUSH
11421: LD_STRING D
11423: PUSH
11424: LD_STRING I
11426: PUSH
11427: LD_STRING J
11429: PUSH
11430: LD_STRING S
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: LIST
11437: PUSH
11438: LD_EXP 25
11442: ARRAY
11443: STR
11444: PUSH
11445: LD_STRING -2
11447: STR
11448: PPUSH
11449: CALL_OW 88
// InGameOff ;
11453: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11457: LD_STRING O1
11459: PPUSH
11460: CALL_OW 337
// game := true ;
11464: LD_ADDR_EXP 3
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// SaveForQuickRestart ;
11472: CALL_OW 22
// wait ( 0 0$5 ) ;
11476: LD_INT 175
11478: PPUSH
11479: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11483: LD_EXP 9
11487: PPUSH
11488: LD_STRING D
11490: PUSH
11491: LD_STRING I
11493: PUSH
11494: LD_STRING J
11496: PUSH
11497: LD_STRING S
11499: PUSH
11500: EMPTY
11501: LIST
11502: LIST
11503: LIST
11504: PUSH
11505: LD_EXP 25
11509: ARRAY
11510: STR
11511: PUSH
11512: LD_STRING -3
11514: STR
11515: PPUSH
11516: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11520: LD_INT 35
11522: PPUSH
11523: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11527: LD_EXP 15
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PUSH
11536: LD_EXP 15
11540: PUSH
11541: LD_INT 2
11543: ARRAY
11544: GREATEREQUAL
11545: IFFALSE 11520
// outpostEscape := true ;
11547: LD_ADDR_EXP 27
11551: PUSH
11552: LD_INT 1
11554: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_EXP 14
11564: PPUSH
11565: LD_INT 26
11567: PUSH
11568: LD_INT 1
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: PPUSH
11575: CALL_OW 72
11579: ST_TO_ADDR
// if tmp then
11580: LD_VAR 0 3
11584: IFFALSE 11602
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11586: LD_VAR 0 3
11590: PUSH
11591: LD_INT 1
11593: ARRAY
11594: PPUSH
11595: LD_STRING DR-1-Escape
11597: PPUSH
11598: CALL_OW 88
// wait ( 0 0$1 ) ;
11602: LD_INT 35
11604: PPUSH
11605: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11609: LD_EXP 9
11613: PPUSH
11614: LD_STRING D
11616: PUSH
11617: LD_STRING I
11619: PUSH
11620: LD_STRING J
11622: PUSH
11623: LD_STRING S
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: PUSH
11631: LD_EXP 25
11635: ARRAY
11636: STR
11637: PUSH
11638: LD_STRING -1-Escape
11640: STR
11641: PPUSH
11642: CALL_OW 88
// for i in ruOutpost do
11646: LD_ADDR_VAR 0 2
11650: PUSH
11651: LD_EXP 14
11655: PUSH
11656: FOR_IN
11657: IFFALSE 11711
// begin if IsInUnit ( i ) then
11659: LD_VAR 0 2
11663: PPUSH
11664: CALL_OW 310
11668: IFFALSE 11679
// ComExitBuilding ( i ) ;
11670: LD_VAR 0 2
11674: PPUSH
11675: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11679: LD_VAR 0 2
11683: PPUSH
11684: LD_INT 179
11686: PPUSH
11687: LD_INT 102
11689: PPUSH
11690: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11694: LD_VAR 0 2
11698: PPUSH
11699: LD_INT 28
11701: PPUSH
11702: LD_INT 20
11704: PPUSH
11705: CALL_OW 171
// end ;
11709: GO 11656
11711: POP
11712: POP
// tmp := [ ] ;
11713: LD_ADDR_VAR 0 3
11717: PUSH
11718: EMPTY
11719: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11720: LD_INT 35
11722: PPUSH
11723: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11727: LD_ADDR_VAR 0 3
11731: PUSH
11732: LD_EXP 14
11736: PPUSH
11737: LD_INT 95
11739: PUSH
11740: LD_INT 11
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 72
11751: ST_TO_ADDR
// if tmp then
11752: LD_VAR 0 3
11756: IFFALSE 11835
// for i in tmp do
11758: LD_ADDR_VAR 0 2
11762: PUSH
11763: LD_VAR 0 3
11767: PUSH
11768: FOR_IN
11769: IFFALSE 11833
// begin ruOutpost := ruOutpost diff i ;
11771: LD_ADDR_EXP 14
11775: PUSH
11776: LD_EXP 14
11780: PUSH
11781: LD_VAR 0 2
11785: DIFF
11786: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11787: LD_ADDR_EXP 31
11791: PUSH
11792: LD_EXP 31
11796: PPUSH
11797: LD_EXP 8
11801: PUSH
11802: LD_EXP 31
11806: PUSH
11807: LD_EXP 8
11811: ARRAY
11812: PUSH
11813: LD_INT 1
11815: PLUS
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PPUSH
11821: LD_VAR 0 2
11825: PPUSH
11826: CALL 25097 0 3
11830: ST_TO_ADDR
// end ;
11831: GO 11768
11833: POP
11834: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11835: LD_EXP 14
11839: PPUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PPUSH
11850: CALL_OW 72
11854: NOT
11855: IFFALSE 11720
// ruOutpost := [ ] ;
11857: LD_ADDR_EXP 14
11861: PUSH
11862: EMPTY
11863: ST_TO_ADDR
// end ;
11864: LD_VAR 0 1
11868: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11869: LD_EXP 27
11873: IFFALSE 12062
11875: GO 11877
11877: DISABLE
11878: LD_INT 0
11880: PPUSH
11881: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11882: LD_INT 875
11884: PPUSH
11885: LD_INT 1225
11887: PPUSH
11888: CALL_OW 12
11892: PPUSH
11893: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11897: LD_ADDR_VAR 0 2
11901: PUSH
11902: LD_INT 208
11904: PUSH
11905: LD_INT 166
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 218
11914: PUSH
11915: LD_INT 174
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PUSH
11922: LD_INT 201
11924: PUSH
11925: LD_INT 173
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PUSH
11932: LD_INT 189
11934: PUSH
11935: LD_INT 167
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PUSH
11942: LD_INT 191
11944: PUSH
11945: LD_INT 160
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: PUSH
11952: LD_INT 209
11954: PUSH
11955: LD_INT 181
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: LD_INT 192
11964: PUSH
11965: LD_INT 162
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 197
11974: PUSH
11975: LD_INT 166
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
11992: LD_ADDR_VAR 0 1
11996: PUSH
11997: DOUBLE
11998: LD_INT 1
12000: DEC
12001: ST_TO_ADDR
12002: LD_INT 5
12004: PUSH
12005: LD_OWVAR 67
12009: PLUS
12010: PUSH
12011: FOR_TO
12012: IFFALSE 12060
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12014: LD_VAR 0 2
12018: PUSH
12019: LD_VAR 0 1
12023: ARRAY
12024: PUSH
12025: LD_INT 1
12027: ARRAY
12028: PPUSH
12029: LD_VAR 0 2
12033: PUSH
12034: LD_VAR 0 1
12038: ARRAY
12039: PUSH
12040: LD_INT 2
12042: ARRAY
12043: PPUSH
12044: LD_INT 1
12046: PPUSH
12047: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12051: LD_INT 28
12053: PPUSH
12054: CALL_OW 67
// end ;
12058: GO 12011
12060: POP
12061: POP
// end ;
12062: PPOPN 2
12064: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12065: LD_EXP 27
12069: NOT
12070: IFFALSE 12732
12072: GO 12074
12074: DISABLE
12075: LD_INT 0
12077: PPUSH
12078: PPUSH
12079: PPUSH
12080: PPUSH
12081: PPUSH
12082: PPUSH
12083: PPUSH
// begin enable ;
12084: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12085: LD_ADDR_VAR 0 1
12089: PUSH
12090: LD_EXP 14
12094: PPUSH
12095: LD_INT 22
12097: PUSH
12098: LD_INT 3
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 25
12107: PUSH
12108: LD_INT 1
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 72
12123: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_EXP 14
12133: PPUSH
12134: LD_INT 22
12136: PUSH
12137: LD_INT 3
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PUSH
12144: LD_INT 25
12146: PUSH
12147: LD_INT 2
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL_OW 72
12162: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12163: LD_ADDR_VAR 0 3
12167: PUSH
12168: LD_EXP 14
12172: PPUSH
12173: LD_INT 22
12175: PUSH
12176: LD_INT 3
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PUSH
12183: LD_INT 21
12185: PUSH
12186: LD_INT 3
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 3
12195: PUSH
12196: LD_INT 24
12198: PUSH
12199: LD_INT 1000
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: PPUSH
12215: CALL_OW 72
12219: ST_TO_ADDR
// if engs and buildings then
12220: LD_VAR 0 2
12224: IFFALSE 12232
12226: PUSH
12227: LD_VAR 0 3
12231: AND
12232: IFFALSE 12305
// begin for i in engs do
12234: LD_ADDR_VAR 0 5
12238: PUSH
12239: LD_VAR 0 2
12243: PUSH
12244: FOR_IN
12245: IFFALSE 12301
// if IsInUnit ( i ) then
12247: LD_VAR 0 5
12251: PPUSH
12252: CALL_OW 310
12256: IFFALSE 12269
// ComExitBuilding ( i ) else
12258: LD_VAR 0 5
12262: PPUSH
12263: CALL_OW 122
12267: GO 12299
// if not HasTask ( i ) then
12269: LD_VAR 0 5
12273: PPUSH
12274: CALL_OW 314
12278: NOT
12279: IFFALSE 12299
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12281: LD_VAR 0 5
12285: PPUSH
12286: LD_VAR 0 3
12290: PUSH
12291: LD_INT 1
12293: ARRAY
12294: PPUSH
12295: CALL_OW 130
12299: GO 12244
12301: POP
12302: POP
// end else
12303: GO 12412
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12305: LD_VAR 0 3
12309: NOT
12310: IFFALSE 12333
12312: PUSH
12313: LD_EXP 14
12317: PPUSH
12318: LD_INT 30
12320: PUSH
12321: LD_INT 0
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PPUSH
12328: CALL_OW 72
12332: AND
12333: IFFALSE 12359
12335: PUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: LD_INT 3
12343: PUSH
12344: LD_INT 54
12346: PUSH
12347: EMPTY
12348: LIST
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PPUSH
12354: CALL_OW 72
12358: AND
12359: IFFALSE 12412
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12361: LD_VAR 0 2
12365: PPUSH
12366: LD_INT 3
12368: PUSH
12369: LD_INT 54
12371: PUSH
12372: EMPTY
12373: LIST
12374: PUSH
12375: EMPTY
12376: LIST
12377: LIST
12378: PPUSH
12379: CALL_OW 72
12383: PPUSH
12384: LD_EXP 14
12388: PPUSH
12389: LD_INT 30
12391: PUSH
12392: LD_INT 0
12394: PUSH
12395: EMPTY
12396: LIST
12397: LIST
12398: PPUSH
12399: CALL_OW 72
12403: PUSH
12404: LD_INT 1
12406: ARRAY
12407: PPUSH
12408: CALL_OW 120
// if not tmp then
12412: LD_VAR 0 1
12416: NOT
12417: IFFALSE 12421
// exit ;
12419: GO 12732
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12421: LD_INT 26
12423: PPUSH
12424: LD_INT 81
12426: PUSH
12427: LD_INT 3
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PPUSH
12434: CALL_OW 70
12438: PUSH
12439: LD_INT 1
12441: GREATER
12442: IFFALSE 12498
// begin for i in tmp do
12444: LD_ADDR_VAR 0 5
12448: PUSH
12449: LD_VAR 0 1
12453: PUSH
12454: FOR_IN
12455: IFFALSE 12494
// begin if IsInUnit ( i ) then
12457: LD_VAR 0 5
12461: PPUSH
12462: CALL_OW 310
12466: IFFALSE 12477
// ComExitBuilding ( i ) ;
12468: LD_VAR 0 5
12472: PPUSH
12473: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12477: LD_VAR 0 5
12481: PPUSH
12482: LD_INT 204
12484: PPUSH
12485: LD_INT 164
12487: PPUSH
12488: CALL_OW 174
// end ;
12492: GO 12454
12494: POP
12495: POP
// end else
12496: GO 12732
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12498: LD_VAR 0 1
12502: PPUSH
12503: LD_INT 3
12505: PUSH
12506: LD_INT 54
12508: PUSH
12509: EMPTY
12510: LIST
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PPUSH
12516: CALL_OW 72
12520: IFFALSE 12732
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12522: LD_ADDR_VAR 0 4
12526: PUSH
12527: LD_EXP 14
12531: PPUSH
12532: LD_INT 30
12534: PUSH
12535: LD_INT 32
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: LD_INT 58
12544: PUSH
12545: EMPTY
12546: LIST
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PPUSH
12552: CALL_OW 72
12556: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12557: LD_VAR 0 4
12561: NOT
12562: IFFALSE 12585
12564: PUSH
12565: LD_EXP 14
12569: PPUSH
12570: LD_INT 30
12572: PUSH
12573: LD_INT 5
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PPUSH
12580: CALL_OW 72
12584: AND
12585: IFFALSE 12622
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12587: LD_VAR 0 1
12591: PPUSH
12592: LD_EXP 14
12596: PPUSH
12597: LD_INT 30
12599: PUSH
12600: LD_INT 5
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: PPUSH
12607: CALL_OW 72
12611: PUSH
12612: LD_INT 1
12614: ARRAY
12615: PPUSH
12616: CALL_OW 120
// exit ;
12620: GO 12732
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12622: LD_ADDR_VAR 0 6
12626: PUSH
12627: LD_VAR 0 1
12631: PPUSH
12632: LD_INT 3
12634: PUSH
12635: LD_INT 54
12637: PUSH
12638: EMPTY
12639: LIST
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 72
12649: ST_TO_ADDR
// if j < empty then
12650: LD_VAR 0 6
12654: PUSH
12655: LD_VAR 0 4
12659: LESS
12660: IFFALSE 12674
// k := j else
12662: LD_ADDR_VAR 0 7
12666: PUSH
12667: LD_VAR 0 6
12671: ST_TO_ADDR
12672: GO 12684
// k := empty ;
12674: LD_ADDR_VAR 0 7
12678: PUSH
12679: LD_VAR 0 4
12683: ST_TO_ADDR
// for i = 1 to k do
12684: LD_ADDR_VAR 0 5
12688: PUSH
12689: DOUBLE
12690: LD_INT 1
12692: DEC
12693: ST_TO_ADDR
12694: LD_VAR 0 7
12698: PUSH
12699: FOR_TO
12700: IFFALSE 12730
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12702: LD_VAR 0 6
12706: PUSH
12707: LD_VAR 0 5
12711: ARRAY
12712: PPUSH
12713: LD_VAR 0 4
12717: PUSH
12718: LD_VAR 0 5
12722: ARRAY
12723: PPUSH
12724: CALL_OW 120
12728: GO 12699
12730: POP
12731: POP
// end ; end ;
12732: PPOPN 7
12734: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12735: LD_EXP 2
12739: PUSH
12740: LD_INT 1
12742: EQUAL
12743: IFFALSE 12751
12745: PUSH
12746: LD_EXP 27
12750: AND
12751: IFFALSE 12791
12753: PUSH
12754: LD_INT 22
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 92
12766: PUSH
12767: LD_INT 208
12769: PUSH
12770: LD_INT 163
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PPUSH
12786: CALL_OW 69
12790: AND
12791: IFFALSE 12843
12793: PUSH
12794: LD_INT 22
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 21
12806: PUSH
12807: LD_INT 1
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 92
12816: PUSH
12817: LD_INT 208
12819: PUSH
12820: LD_INT 163
12822: PUSH
12823: LD_INT 14
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: LIST
12830: LIST
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: PPUSH
12837: CALL_OW 69
12841: NOT
12842: AND
12843: IFFALSE 13148
12845: GO 12847
12847: DISABLE
12848: LD_INT 0
12850: PPUSH
// begin InGameOn ;
12851: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12855: LD_EXP 9
12859: PPUSH
12860: CALL_OW 87
// wait ( 0 0$1 ) ;
12864: LD_INT 35
12866: PPUSH
12867: CALL_OW 67
// DialogueOn ;
12871: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12875: LD_EXP 9
12879: PPUSH
12880: LD_STRING D
12882: PUSH
12883: LD_STRING I
12885: PUSH
12886: LD_STRING J
12888: PUSH
12889: LD_STRING S
12891: PUSH
12892: EMPTY
12893: LIST
12894: LIST
12895: LIST
12896: PUSH
12897: LD_EXP 25
12901: ARRAY
12902: STR
12903: PUSH
12904: LD_STRING -1-BaseCaptured
12906: STR
12907: PPUSH
12908: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12912: LD_EXP 12
12916: PPUSH
12917: LD_STRING DP-1-BaseCaptured
12919: PPUSH
12920: CALL_OW 94
// if sibBombAllowed then
12924: LD_EXP 23
12928: IFFALSE 13070
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12930: LD_EXP 9
12934: PPUSH
12935: LD_STRING D
12937: PUSH
12938: LD_STRING I
12940: PUSH
12941: LD_STRING J
12943: PUSH
12944: LD_STRING S
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: PUSH
12952: LD_EXP 25
12956: ARRAY
12957: STR
12958: PUSH
12959: LD_STRING -2-BaseCaptured
12961: STR
12962: PPUSH
12963: CALL_OW 88
// if commander = 1 then
12967: LD_EXP 25
12971: PUSH
12972: LD_INT 1
12974: EQUAL
12975: IFFALSE 12989
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12977: LD_EXP 12
12981: PPUSH
12982: LD_STRING DP-2b-BaseCaptured
12984: PPUSH
12985: CALL_OW 94
// if commander = 2 then
12989: LD_EXP 25
12993: PUSH
12994: LD_INT 2
12996: EQUAL
12997: IFFALSE 13011
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
12999: LD_EXP 12
13003: PPUSH
13004: LD_STRING DP-2-BaseCaptured
13006: PPUSH
13007: CALL_OW 94
// if commander = 3 then
13011: LD_EXP 25
13015: PUSH
13016: LD_INT 3
13018: EQUAL
13019: IFFALSE 13033
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13021: LD_EXP 12
13025: PPUSH
13026: LD_STRING DP-2a-BaseCaptured
13028: PPUSH
13029: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13033: LD_EXP 9
13037: PPUSH
13038: LD_STRING D
13040: PUSH
13041: LD_STRING I
13043: PUSH
13044: LD_STRING J
13046: PUSH
13047: LD_STRING S
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: PUSH
13055: LD_EXP 25
13059: ARRAY
13060: STR
13061: PUSH
13062: LD_STRING -3-BaseCaptured
13064: STR
13065: PPUSH
13066: CALL_OW 88
// end ; DialogueOff ;
13070: CALL_OW 7
// InGameOff ;
13074: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13078: LD_STRING O2
13080: PPUSH
13081: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13085: LD_ADDR_VAR 0 1
13089: PUSH
13090: LD_EXP 14
13094: PPUSH
13095: LD_INT 21
13097: PUSH
13098: LD_INT 3
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PPUSH
13105: CALL_OW 72
13109: PUSH
13110: FOR_IN
13111: IFFALSE 13127
// SetSide ( i , 1 ) ;
13113: LD_VAR 0 1
13117: PPUSH
13118: LD_INT 1
13120: PPUSH
13121: CALL_OW 235
13125: GO 13110
13127: POP
13128: POP
// baseCaptured := true ;
13129: LD_ADDR_EXP 17
13133: PUSH
13134: LD_INT 1
13136: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13137: LD_INT 1225
13139: PPUSH
13140: CALL_OW 67
// PrepareReinforcements ;
13144: CALL 9879 0 0
// end ;
13148: PPOPN 1
13150: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13151: LD_INT 22
13153: PUSH
13154: LD_INT 3
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 92
13163: PUSH
13164: LD_INT 167
13166: PUSH
13167: LD_INT 197
13169: PUSH
13170: LD_INT 20
13172: PUSH
13173: EMPTY
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PPUSH
13183: CALL_OW 69
13187: PUSH
13188: LD_INT 3
13190: GREATER
13191: IFFALSE 13208
13193: GO 13195
13195: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13196: LD_EXP 12
13200: PPUSH
13201: LD_STRING DP-RuAttack
13203: PPUSH
13204: CALL_OW 94
13208: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13209: LD_EXP 1
13213: NOT
13214: IFFALSE 13231
13216: PUSH
13217: LD_INT 1
13219: PPUSH
13220: LD_INT 168
13222: PPUSH
13223: LD_INT 74
13225: PPUSH
13226: CALL_OW 293
13230: AND
13231: IFFALSE 13245
13233: PUSH
13234: LD_INT 168
13236: PPUSH
13237: LD_INT 72
13239: PPUSH
13240: CALL_OW 553
13244: AND
13245: IFFALSE 13297
13247: GO 13249
13249: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13250: LD_INT 168
13252: PPUSH
13253: LD_INT 72
13255: PPUSH
13256: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13260: LD_EXP 9
13264: PPUSH
13265: LD_STRING D
13267: PUSH
13268: LD_STRING I
13270: PUSH
13271: LD_STRING J
13273: PUSH
13274: LD_STRING S
13276: PUSH
13277: EMPTY
13278: LIST
13279: LIST
13280: LIST
13281: PUSH
13282: LD_EXP 25
13286: ARRAY
13287: STR
13288: PUSH
13289: LD_STRING -1-Blockade
13291: STR
13292: PPUSH
13293: CALL_OW 88
// end ;
13297: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13298: LD_EXP 2
13302: PUSH
13303: LD_INT 1
13305: EQUAL
13306: IFFALSE 13338
13308: PUSH
13309: LD_INT 22
13311: PUSH
13312: LD_INT 1
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PUSH
13319: LD_INT 101
13321: PUSH
13322: LD_INT 4
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 69
13337: AND
13338: IFFALSE 13876
13340: GO 13342
13342: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13343: LD_INT 4
13345: PPUSH
13346: LD_INT 1
13348: PPUSH
13349: CALL_OW 343
// DialogueOn ;
13353: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13357: LD_EXP 11
13361: PPUSH
13362: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13366: LD_EXP 11
13370: PPUSH
13371: LD_STRING DM-1-Contact
13373: PPUSH
13374: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13378: LD_EXP 9
13382: PPUSH
13383: LD_STRING D
13385: PUSH
13386: LD_STRING I
13388: PUSH
13389: LD_STRING J
13391: PUSH
13392: LD_STRING S
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: LIST
13399: PUSH
13400: LD_EXP 25
13404: ARRAY
13405: STR
13406: PUSH
13407: LD_STRING -1-Contact
13409: STR
13410: PPUSH
13411: CALL_OW 88
// if commander = 1 then
13415: LD_EXP 25
13419: PUSH
13420: LD_INT 1
13422: EQUAL
13423: IFFALSE 13557
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13425: LD_EXP 11
13429: PPUSH
13430: LD_STRING DM-2-Contact
13432: PPUSH
13433: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13437: LD_EXP 9
13441: PPUSH
13442: LD_STRING DI-2-Contact
13444: PPUSH
13445: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13449: LD_INT 22
13451: PUSH
13452: LD_INT 8
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PUSH
13459: LD_INT 21
13461: PUSH
13462: LD_INT 1
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: PPUSH
13473: CALL_OW 69
13477: IFFALSE 13495
13479: PUSH
13480: LD_INT 8
13482: PPUSH
13483: LD_INT 1
13485: PPUSH
13486: CALL_OW 81
13490: PUSH
13491: LD_INT 2
13493: EQUAL
13494: AND
13495: IFFALSE 13521
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13497: LD_EXP 11
13501: PPUSH
13502: LD_STRING DM-3-Contact
13504: PPUSH
13505: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13509: LD_EXP 9
13513: PPUSH
13514: LD_STRING DI-3-Contact
13516: PPUSH
13517: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13521: LD_EXP 11
13525: PPUSH
13526: LD_STRING DM-4-Contact
13528: PPUSH
13529: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13533: LD_EXP 9
13537: PPUSH
13538: LD_STRING DI-4-Contact
13540: PPUSH
13541: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13545: LD_EXP 11
13549: PPUSH
13550: LD_STRING DM-5-Contact
13552: PPUSH
13553: CALL_OW 94
// end ; if commander = 2 then
13557: LD_EXP 25
13561: PUSH
13562: LD_INT 2
13564: EQUAL
13565: IFFALSE 13699
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13567: LD_EXP 11
13571: PPUSH
13572: LD_STRING DM-2c-Contact
13574: PPUSH
13575: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13579: LD_EXP 9
13583: PPUSH
13584: LD_STRING DJ-2-Contact
13586: PPUSH
13587: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13591: LD_INT 22
13593: PUSH
13594: LD_INT 8
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 21
13603: PUSH
13604: LD_INT 1
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PPUSH
13615: CALL_OW 69
13619: IFFALSE 13637
13621: PUSH
13622: LD_INT 8
13624: PPUSH
13625: LD_INT 1
13627: PPUSH
13628: CALL_OW 81
13632: PUSH
13633: LD_INT 2
13635: EQUAL
13636: AND
13637: IFFALSE 13663
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13639: LD_EXP 11
13643: PPUSH
13644: LD_STRING DM-3-Contact
13646: PPUSH
13647: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13651: LD_EXP 9
13655: PPUSH
13656: LD_STRING DJ-3-Contact
13658: PPUSH
13659: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13663: LD_EXP 11
13667: PPUSH
13668: LD_STRING DM-4-Contact
13670: PPUSH
13671: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13675: LD_EXP 9
13679: PPUSH
13680: LD_STRING DJ-4-Contact
13682: PPUSH
13683: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13687: LD_EXP 11
13691: PPUSH
13692: LD_STRING DM-5a-Contact
13694: PPUSH
13695: CALL_OW 94
// end ; if commander = 3 then
13699: LD_EXP 25
13703: PUSH
13704: LD_INT 3
13706: EQUAL
13707: IFFALSE 13865
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13709: LD_EXP 11
13713: PPUSH
13714: LD_STRING DM-2a-Contact
13716: PPUSH
13717: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13721: LD_EXP 9
13725: PPUSH
13726: LD_STRING DS-2a-Contact
13728: PPUSH
13729: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13733: LD_EXP 11
13737: PPUSH
13738: LD_STRING DM-2b-Contact
13740: PPUSH
13741: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13745: LD_EXP 9
13749: PPUSH
13750: LD_STRING DS-2b-Contact
13752: PPUSH
13753: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13757: LD_INT 22
13759: PUSH
13760: LD_INT 8
13762: PUSH
13763: EMPTY
13764: LIST
13765: LIST
13766: PUSH
13767: LD_INT 21
13769: PUSH
13770: LD_INT 1
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: PPUSH
13781: CALL_OW 69
13785: IFFALSE 13803
13787: PUSH
13788: LD_INT 8
13790: PPUSH
13791: LD_INT 1
13793: PPUSH
13794: CALL_OW 81
13798: PUSH
13799: LD_INT 2
13801: EQUAL
13802: AND
13803: IFFALSE 13829
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13805: LD_EXP 11
13809: PPUSH
13810: LD_STRING DM-3-Contact
13812: PPUSH
13813: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13817: LD_EXP 9
13821: PPUSH
13822: LD_STRING DS-3-Contact
13824: PPUSH
13825: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13829: LD_EXP 11
13833: PPUSH
13834: LD_STRING DM-4-Contact
13836: PPUSH
13837: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13841: LD_EXP 9
13845: PPUSH
13846: LD_STRING DS-4-Contact
13848: PPUSH
13849: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13853: LD_EXP 11
13857: PPUSH
13858: LD_STRING DM-5-Contact
13860: PPUSH
13861: CALL_OW 94
// end ; DialogueOff ;
13865: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13869: LD_STRING O3
13871: PPUSH
13872: CALL_OW 337
// end ;
13876: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13877: LD_EXP 2
13881: PUSH
13882: LD_INT 1
13884: EQUAL
13885: IFFALSE 13914
13887: PUSH
13888: LD_EXP 18
13892: PUSH
13893: LD_INT 15
13895: PUSH
13896: LD_INT 20
13898: PUSH
13899: LD_INT 25
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: LIST
13906: PUSH
13907: LD_OWVAR 67
13911: ARRAY
13912: GREATEREQUAL
13913: AND
13914: IFFALSE 13946
13916: PUSH
13917: LD_INT 22
13919: PUSH
13920: LD_INT 8
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 30
13929: PUSH
13930: LD_INT 1
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PPUSH
13941: CALL_OW 69
13945: AND
13946: IFFALSE 13982
13948: PUSH
13949: LD_INT 22
13951: PUSH
13952: LD_INT 8
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 21
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PPUSH
13973: CALL_OW 69
13977: PUSH
13978: LD_INT 5
13980: GREATEREQUAL
13981: AND
13982: IFFALSE 14509
13984: GO 13986
13986: DISABLE
13987: LD_INT 0
13989: PPUSH
13990: PPUSH
13991: PPUSH
13992: PPUSH
// begin DialogueOn ;
13993: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13997: LD_EXP 13
14001: PPUSH
14002: LD_STRING DF-1-Leg
14004: PPUSH
14005: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14009: LD_EXP 9
14013: PPUSH
14014: LD_STRING D
14016: PUSH
14017: LD_STRING I
14019: PUSH
14020: LD_STRING J
14022: PUSH
14023: LD_STRING S
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: PUSH
14031: LD_EXP 25
14035: ARRAY
14036: STR
14037: PUSH
14038: LD_STRING -1-Leg
14040: STR
14041: PPUSH
14042: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14046: LD_EXP 13
14050: PPUSH
14051: LD_STRING DF-2-Leg
14053: PPUSH
14054: CALL_OW 94
// DialogueOff ;
14058: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14062: LD_STRING QLegionOffer
14064: PPUSH
14065: CALL_OW 97
14069: PUSH
14070: LD_INT 1
14072: DOUBLE
14073: EQUAL
14074: IFTRUE 14078
14076: GO 14081
14078: POP
// ; 2 :
14079: GO 14095
14081: LD_INT 2
14083: DOUBLE
14084: EQUAL
14085: IFTRUE 14089
14087: GO 14094
14089: POP
// exit ; end ;
14090: GO 14509
14092: GO 14095
14094: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14095: LD_EXP 9
14099: PPUSH
14100: LD_STRING D
14102: PUSH
14103: LD_STRING I
14105: PUSH
14106: LD_STRING J
14108: PUSH
14109: LD_STRING S
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: LIST
14116: PUSH
14117: LD_EXP 25
14121: ARRAY
14122: STR
14123: PUSH
14124: LD_STRING -2-Leg
14126: STR
14127: PPUSH
14128: CALL_OW 88
// legOfferAccepted := true ;
14132: LD_ADDR_EXP 20
14136: PUSH
14137: LD_INT 1
14139: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14140: LD_INT 21
14142: PPUSH
14143: LD_INT 1
14145: PPUSH
14146: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14150: LD_INT 190
14152: PPUSH
14153: LD_INT 227
14155: PPUSH
14156: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14160: LD_ADDR_VAR 0 1
14164: PUSH
14165: LD_INT 16800
14167: PUSH
14168: LD_INT 14700
14170: PUSH
14171: LD_INT 12600
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: LIST
14178: PUSH
14179: LD_OWVAR 67
14183: ARRAY
14184: ST_TO_ADDR
// sib := 100 ;
14185: LD_ADDR_VAR 0 2
14189: PUSH
14190: LD_INT 100
14192: ST_TO_ADDR
// disableGlobalTimer := true ;
14193: LD_ADDR_EXP 4
14197: PUSH
14198: LD_INT 1
14200: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14201: LD_INT 35
14203: PPUSH
14204: CALL_OW 67
// time := time - 0 0$1 ;
14208: LD_ADDR_VAR 0 1
14212: PUSH
14213: LD_VAR 0 1
14217: PUSH
14218: LD_INT 35
14220: MINUS
14221: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14222: LD_ADDR_VAR 0 3
14226: PUSH
14227: LD_INT 21
14229: PPUSH
14230: LD_INT 3
14232: PPUSH
14233: CALL_OW 287
14237: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14238: LD_ADDR_OWVAR 47
14242: PUSH
14243: LD_STRING #SkrTime
14245: PUSH
14246: LD_OWVAR 1
14250: PUSH
14251: LD_STRING #Skr-LegOffer
14253: PUSH
14254: LD_VAR 0 2
14258: PUSH
14259: LD_VAR 0 1
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: LIST
14270: ST_TO_ADDR
// if sources then
14271: LD_VAR 0 3
14275: IFFALSE 14307
// begin sib := sib - sources * 10 ;
14277: LD_ADDR_VAR 0 2
14281: PUSH
14282: LD_VAR 0 2
14286: PUSH
14287: LD_VAR 0 3
14291: PUSH
14292: LD_INT 10
14294: MUL
14295: MINUS
14296: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14297: LD_INT 21
14299: PPUSH
14300: LD_INT 3
14302: PPUSH
14303: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14307: LD_VAR 0 1
14311: PUSH
14312: LD_INT 0
14314: EQUAL
14315: IFTRUE 14327
14317: PUSH
14318: LD_VAR 0 2
14322: PUSH
14323: LD_INT 0
14325: LESSEQUAL
14326: OR
14327: IFTRUE 14346
14329: PUSH
14330: LD_INT 22
14332: PUSH
14333: LD_INT 8
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PPUSH
14340: CALL_OW 69
14344: NOT
14345: OR
14346: IFFALSE 14201
// SetAreaMapShow ( legOfferArea , 0 ) ;
14348: LD_INT 21
14350: PPUSH
14351: LD_INT 0
14353: PPUSH
14354: CALL_OW 424
// disableGlobalTimer := false ;
14358: LD_ADDR_EXP 4
14362: PUSH
14363: LD_INT 0
14365: ST_TO_ADDR
// if sib <= 0 then
14366: LD_VAR 0 2
14370: PUSH
14371: LD_INT 0
14373: LESSEQUAL
14374: IFFALSE 14490
// begin legChangeSide := true ;
14376: LD_ADDR_EXP 21
14380: PUSH
14381: LD_INT 1
14383: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14384: LD_EXP 13
14388: PPUSH
14389: LD_STRING DF-4y-Leg
14391: PPUSH
14392: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14396: LD_STRING O3a
14398: PPUSH
14399: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14403: LD_INT 8
14405: PPUSH
14406: LD_INT 1
14408: PPUSH
14409: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14413: LD_INT 8
14415: PPUSH
14416: LD_INT 1
14418: PPUSH
14419: LD_INT 1
14421: PPUSH
14422: LD_INT 1
14424: PPUSH
14425: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14429: LD_INT 8
14431: PPUSH
14432: LD_INT 4
14434: PPUSH
14435: LD_INT 1
14437: PPUSH
14438: LD_INT 1
14440: PPUSH
14441: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14445: LD_INT 8
14447: PPUSH
14448: LD_INT 6
14450: PPUSH
14451: LD_INT 2
14453: PPUSH
14454: LD_INT 1
14456: PPUSH
14457: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14461: LD_INT 8
14463: PPUSH
14464: LD_INT 3
14466: PPUSH
14467: LD_INT 2
14469: PPUSH
14470: LD_INT 1
14472: PPUSH
14473: CALL_OW 80
// wait ( 0 0$30 ) ;
14477: LD_INT 1050
14479: PPUSH
14480: CALL_OW 67
// PrepareLegionReinforcements ;
14484: CALL 10579 0 0
// end else
14488: GO 14509
// begin ChangeMissionObjectives ( O3a ) ;
14490: LD_STRING O3a
14492: PPUSH
14493: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14497: LD_EXP 13
14501: PPUSH
14502: LD_STRING DF-4n-Leg
14504: PPUSH
14505: CALL_OW 94
// end ; end ;
14509: PPOPN 4
14511: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14512: LD_INT 22
14514: PUSH
14515: LD_INT 8
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PUSH
14522: LD_INT 21
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: EMPTY
14533: LIST
14534: LIST
14535: PPUSH
14536: CALL_OW 69
14540: PUSH
14541: LD_INT 0
14543: EQUAL
14544: IFFALSE 14562
14546: PUSH
14547: LD_INT 8
14549: PPUSH
14550: LD_INT 1
14552: PPUSH
14553: CALL_OW 81
14557: PUSH
14558: LD_INT 2
14560: EQUAL
14561: AND
14562: IFFALSE 14574
14564: GO 14566
14566: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14567: LD_STRING O3a
14569: PPUSH
14570: CALL_OW 337
14574: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14575: LD_EXP 2
14579: PUSH
14580: LD_INT 1
14582: EQUAL
14583: IFFALSE 14591
14585: PUSH
14586: LD_EXP 3
14590: AND
14591: IFFALSE 14627
14593: PUSH
14594: LD_INT 22
14596: PUSH
14597: LD_INT 3
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PUSH
14604: LD_INT 21
14606: PUSH
14607: LD_INT 1
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PPUSH
14618: CALL_OW 69
14622: PUSH
14623: LD_INT 0
14625: EQUAL
14626: AND
14627: IFFALSE 14663
14629: PUSH
14630: LD_INT 22
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: LD_INT 30
14642: PUSH
14643: LD_INT 1
14645: PUSH
14646: EMPTY
14647: LIST
14648: LIST
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PPUSH
14654: CALL_OW 69
14658: PUSH
14659: LD_INT 0
14661: EQUAL
14662: AND
14663: IFFALSE 14901
14665: GO 14667
14667: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14668: LD_EXP 9
14672: PPUSH
14673: LD_STRING D
14675: PUSH
14676: LD_STRING I
14678: PUSH
14679: LD_STRING J
14681: PUSH
14682: LD_STRING S
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: PUSH
14690: LD_EXP 25
14694: ARRAY
14695: STR
14696: PUSH
14697: LD_STRING -1-Win
14699: STR
14700: PPUSH
14701: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14705: LD_OWVAR 1
14709: PUSH
14710: LD_INT 315000
14712: PUSH
14713: LD_INT 273000
14715: PUSH
14716: LD_INT 231000
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: LIST
14723: PUSH
14724: LD_OWVAR 67
14728: ARRAY
14729: GREATEREQUAL
14730: IFFALSE 14745
// AddMedal ( med1 , - 1 ) else
14732: LD_STRING med1
14734: PPUSH
14735: LD_INT 1
14737: NEG
14738: PPUSH
14739: CALL_OW 101
14743: GO 14755
// AddMedal ( med1 , 1 ) ;
14745: LD_STRING med1
14747: PPUSH
14748: LD_INT 1
14750: PPUSH
14751: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14755: LD_EXP 22
14759: PUSH
14760: LD_INT 20
14762: PUSH
14763: LD_INT 15
14765: PUSH
14766: LD_INT 10
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: LIST
14773: PUSH
14774: LD_OWVAR 67
14778: ARRAY
14779: GREATEREQUAL
14780: IFFALSE 14795
// AddMedal ( med2 , - 1 ) else
14782: LD_STRING med2
14784: PPUSH
14785: LD_INT 1
14787: NEG
14788: PPUSH
14789: CALL_OW 101
14793: GO 14805
// AddMedal ( med2 , 1 ) ;
14795: LD_STRING med2
14797: PPUSH
14798: LD_INT 1
14800: PPUSH
14801: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14805: LD_INT 8
14807: PPUSH
14808: LD_INT 1
14810: PPUSH
14811: CALL_OW 81
14815: PUSH
14816: LD_INT 1
14818: EQUAL
14819: IFFALSE 14833
// AddMedal ( med3 , 1 ) else
14821: LD_STRING med3
14823: PPUSH
14824: LD_INT 1
14826: PPUSH
14827: CALL_OW 101
14831: GO 14890
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14833: LD_INT 22
14835: PUSH
14836: LD_INT 8
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PUSH
14843: LD_INT 21
14845: PUSH
14846: LD_INT 1
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PPUSH
14857: CALL_OW 69
14861: PUSH
14862: LD_INT 0
14864: EQUAL
14865: IFFALSE 14879
// AddMedal ( med3 , 2 ) else
14867: LD_STRING med3
14869: PPUSH
14870: LD_INT 2
14872: PPUSH
14873: CALL_OW 101
14877: GO 14890
// AddMedal ( med3 , - 1 ) ;
14879: LD_STRING med3
14881: PPUSH
14882: LD_INT 1
14884: NEG
14885: PPUSH
14886: CALL_OW 101
// GiveMedals ( MAIN ) ;
14890: LD_STRING MAIN
14892: PPUSH
14893: CALL_OW 102
// YouWin ;
14897: CALL_OW 103
// end ;
14901: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14902: LD_EXP 2
14906: PUSH
14907: LD_INT 1
14909: EQUAL
14910: IFFALSE 14918
14912: PUSH
14913: LD_EXP 16
14917: AND
14918: IFFALSE 14939
14920: PUSH
14921: LD_INT 20
14923: PPUSH
14924: LD_INT 81
14926: PUSH
14927: LD_INT 8
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PPUSH
14934: CALL_OW 70
14938: AND
14939: IFFALSE 15220
14941: GO 14943
14943: DISABLE
14944: LD_INT 0
14946: PPUSH
14947: PPUSH
14948: PPUSH
14949: PPUSH
14950: PPUSH
// begin enable ;
14951: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14952: LD_ADDR_VAR 0 3
14956: PUSH
14957: LD_INT 20
14959: PPUSH
14960: LD_INT 81
14962: PUSH
14963: LD_INT 8
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: PPUSH
14970: CALL_OW 70
14974: ST_TO_ADDR
// if not tmp then
14975: LD_VAR 0 3
14979: NOT
14980: IFFALSE 14984
// exit ;
14982: GO 15220
// for i in tmp do
14984: LD_ADDR_VAR 0 1
14988: PUSH
14989: LD_VAR 0 3
14993: PUSH
14994: FOR_IN
14995: IFFALSE 15218
// begin x := GetX ( i ) ;
14997: LD_ADDR_VAR 0 4
15001: PUSH
15002: LD_VAR 0 1
15006: PPUSH
15007: CALL_OW 250
15011: ST_TO_ADDR
// y := GetY ( i ) ;
15012: LD_ADDR_VAR 0 5
15016: PUSH
15017: LD_VAR 0 1
15021: PPUSH
15022: CALL_OW 251
15026: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15027: LD_VAR 0 4
15031: PPUSH
15032: LD_VAR 0 5
15036: PPUSH
15037: CALL_OW 458
15041: IFFALSE 15216
// begin LaunchMineAtPos ( x , y , 8 ) ;
15043: LD_VAR 0 4
15047: PPUSH
15048: LD_VAR 0 5
15052: PPUSH
15053: LD_INT 8
15055: PPUSH
15056: CALL_OW 456
// if not dialogueMineDetected then
15060: LD_EXP 28
15064: NOT
15065: IFFALSE 15126
// begin dialogueMineDetected := true ;
15067: LD_ADDR_EXP 28
15071: PUSH
15072: LD_INT 1
15074: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15075: LD_VAR 0 4
15079: PPUSH
15080: LD_VAR 0 5
15084: PPUSH
15085: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15089: LD_EXP 9
15093: PPUSH
15094: LD_STRING D
15096: PUSH
15097: LD_STRING I
15099: PUSH
15100: LD_STRING J
15102: PUSH
15103: LD_STRING S
15105: PUSH
15106: EMPTY
15107: LIST
15108: LIST
15109: LIST
15110: PUSH
15111: LD_EXP 25
15115: ARRAY
15116: STR
15117: PUSH
15118: LD_STRING -1-Mine
15120: STR
15121: PPUSH
15122: CALL_OW 88
// end ; for j = 1 to staticMines do
15126: LD_ADDR_VAR 0 2
15130: PUSH
15131: DOUBLE
15132: LD_INT 1
15134: DEC
15135: ST_TO_ADDR
15136: LD_EXP 16
15140: PUSH
15141: FOR_TO
15142: IFFALSE 15214
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15144: LD_EXP 16
15148: PUSH
15149: LD_VAR 0 2
15153: ARRAY
15154: PUSH
15155: LD_INT 1
15157: ARRAY
15158: PUSH
15159: LD_VAR 0 4
15163: EQUAL
15164: IFFALSE 15188
15166: PUSH
15167: LD_EXP 16
15171: PUSH
15172: LD_VAR 0 2
15176: ARRAY
15177: PUSH
15178: LD_INT 2
15180: ARRAY
15181: PUSH
15182: LD_VAR 0 5
15186: EQUAL
15187: AND
15188: IFFALSE 15212
// begin staticMines := Delete ( staticMines , j ) ;
15190: LD_ADDR_EXP 16
15194: PUSH
15195: LD_EXP 16
15199: PPUSH
15200: LD_VAR 0 2
15204: PPUSH
15205: CALL_OW 3
15209: ST_TO_ADDR
// break ;
15210: GO 15214
// end ;
15212: GO 15141
15214: POP
15215: POP
// end ; end ;
15216: GO 14994
15218: POP
15219: POP
// end ;
15220: PPOPN 5
15222: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15223: LD_EXP 2
15227: PUSH
15228: LD_INT 1
15230: EQUAL
15231: IFFALSE 15239
15233: PUSH
15234: LD_EXP 3
15238: AND
15239: IFFALSE 15247
15241: PUSH
15242: LD_EXP 23
15246: AND
15247: IFFALSE 15276
15249: PUSH
15250: LD_EXP 31
15254: PUSH
15255: LD_EXP 7
15259: ARRAY
15260: PPUSH
15261: LD_INT 30
15263: PUSH
15264: LD_INT 3
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 72
15275: AND
15276: IFFALSE 15480
15278: GO 15280
15280: DISABLE
15281: LD_INT 0
15283: PPUSH
15284: PPUSH
// begin enable ;
15285: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15286: LD_EXP 7
15290: PPUSH
15291: LD_INT 23
15293: PUSH
15294: LD_INT 3
15296: PUSH
15297: LD_INT 3
15299: PUSH
15300: LD_INT 48
15302: PUSH
15303: EMPTY
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: PUSH
15309: EMPTY
15310: LIST
15311: PPUSH
15312: CALL 88047 0 2
// repeat wait ( 0 0$1 ) ;
15316: LD_INT 35
15318: PPUSH
15319: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15323: LD_INT 22
15325: PUSH
15326: LD_INT 3
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 34
15335: PUSH
15336: LD_INT 48
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PPUSH
15347: CALL_OW 69
15351: IFFALSE 15316
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15353: LD_ADDR_VAR 0 1
15357: PUSH
15358: LD_INT 22
15360: PUSH
15361: LD_INT 3
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: PUSH
15368: LD_INT 34
15370: PUSH
15371: LD_INT 48
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: PPUSH
15382: CALL_OW 69
15386: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15387: LD_ADDR_VAR 0 2
15391: PUSH
15392: LD_INT 81
15394: PUSH
15395: LD_INT 3
15397: PUSH
15398: EMPTY
15399: LIST
15400: LIST
15401: PUSH
15402: LD_INT 21
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: PUSH
15412: EMPTY
15413: LIST
15414: LIST
15415: PPUSH
15416: CALL_OW 69
15420: ST_TO_ADDR
// if e then
15421: LD_VAR 0 2
15425: IFFALSE 15451
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15427: LD_ADDR_VAR 0 2
15431: PUSH
15432: LD_VAR 0 2
15436: PPUSH
15437: LD_VAR 0 1
15441: PUSH
15442: LD_INT 1
15444: ARRAY
15445: PPUSH
15446: CALL_OW 74
15450: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15451: LD_VAR 0 1
15455: PPUSH
15456: LD_VAR 0 2
15460: PPUSH
15461: CALL_OW 250
15465: PPUSH
15466: LD_VAR 0 2
15470: PPUSH
15471: CALL_OW 251
15475: PPUSH
15476: CALL_OW 116
// end ;
15480: PPOPN 2
15482: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15483: LD_OWVAR 67
15487: PUSH
15488: LD_INT 1
15490: GREATER
15491: IFFALSE 15520
15493: PUSH
15494: LD_EXP 31
15498: PUSH
15499: LD_EXP 7
15503: ARRAY
15504: PPUSH
15505: LD_INT 25
15507: PUSH
15508: LD_INT 3
15510: PUSH
15511: EMPTY
15512: LIST
15513: LIST
15514: PPUSH
15515: CALL_OW 72
15519: AND
15520: IFFALSE 15532
15522: PUSH
15523: LD_EXP 2
15527: PUSH
15528: LD_INT 1
15530: EQUAL
15531: AND
15532: IFFALSE 15540
15534: PUSH
15535: LD_EXP 3
15539: AND
15540: IFFALSE 15558
15542: PUSH
15543: LD_INT 23
15545: PPUSH
15546: LD_INT 3
15548: PPUSH
15549: CALL_OW 321
15553: PUSH
15554: LD_INT 2
15556: EQUAL
15557: AND
15558: IFFALSE 15685
15560: GO 15562
15562: DISABLE
15563: LD_INT 0
15565: PPUSH
15566: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15567: LD_ADDR_VAR 0 1
15571: PUSH
15572: LD_EXP 31
15576: PUSH
15577: LD_EXP 7
15581: ARRAY
15582: PPUSH
15583: LD_INT 25
15585: PUSH
15586: LD_INT 3
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PPUSH
15593: CALL_OW 72
15597: ST_TO_ADDR
// if not tmp then
15598: LD_VAR 0 1
15602: NOT
15603: IFFALSE 15607
// exit ;
15605: GO 15685
// for i in tmp do
15607: LD_ADDR_VAR 0 2
15611: PUSH
15612: LD_VAR 0 1
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15664
// begin SetTag ( i , 29 ) ;
15620: LD_VAR 0 2
15624: PPUSH
15625: LD_INT 29
15627: PPUSH
15628: CALL_OW 109
// ComExitBuilding ( i ) ;
15632: LD_VAR 0 2
15636: PPUSH
15637: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15641: LD_VAR 0 2
15645: PPUSH
15646: LD_INT 37
15648: PPUSH
15649: LD_INT 97
15651: PPUSH
15652: LD_INT 133
15654: PPUSH
15655: LD_INT 0
15657: PPUSH
15658: CALL_OW 230
// end ;
15662: GO 15617
15664: POP
15665: POP
// wait ( 1 1$00 ) ;
15666: LD_INT 2100
15668: PPUSH
15669: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15673: LD_EXP 7
15677: PPUSH
15678: LD_INT 29
15680: PPUSH
15681: CALL 67678 0 2
// end ;
15685: PPOPN 2
15687: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15688: LD_EXP 2
15692: PUSH
15693: LD_INT 1
15695: EQUAL
15696: IFFALSE 15719
15698: PUSH
15699: LD_INT 84
15701: PPUSH
15702: LD_INT 128
15704: PPUSH
15705: CALL_OW 428
15709: PPUSH
15710: CALL_OW 266
15714: PUSH
15715: LD_INT 1
15717: EQUAL
15718: AND
15719: IFFALSE 15742
15721: PUSH
15722: LD_INT 84
15724: PPUSH
15725: LD_INT 128
15727: PPUSH
15728: CALL_OW 428
15732: PPUSH
15733: CALL_OW 255
15737: PUSH
15738: LD_INT 3
15740: EQUAL
15741: AND
15742: IFFALSE 15915
15744: GO 15746
15746: DISABLE
15747: LD_INT 0
15749: PPUSH
15750: PPUSH
// begin enable ;
15751: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15752: LD_ADDR_VAR 0 2
15756: PUSH
15757: LD_INT 84
15759: PPUSH
15760: LD_INT 128
15762: PPUSH
15763: CALL_OW 428
15767: ST_TO_ADDR
// uc_side := 3 ;
15768: LD_ADDR_OWVAR 20
15772: PUSH
15773: LD_INT 3
15775: ST_TO_ADDR
// uc_nation := 3 ;
15776: LD_ADDR_OWVAR 21
15780: PUSH
15781: LD_INT 3
15783: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15784: LD_INT 21
15786: PPUSH
15787: LD_INT 3
15789: PPUSH
15790: LD_INT 3
15792: PPUSH
15793: LD_INT 51
15795: PPUSH
15796: LD_INT 0
15798: PPUSH
15799: CALL 24975 0 5
// veh := CreateVehicle ;
15803: LD_ADDR_VAR 0 1
15807: PUSH
15808: CALL_OW 45
15812: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15813: LD_VAR 0 1
15817: PPUSH
15818: LD_INT 126
15820: PPUSH
15821: LD_INT 227
15823: PPUSH
15824: LD_INT 0
15826: PPUSH
15827: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_INT 2
15838: PPUSH
15839: LD_INT 100
15841: PPUSH
15842: CALL_OW 290
// ComGive ( veh , depot ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_VAR 0 2
15855: PPUSH
15856: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15860: LD_VAR 0 1
15864: PPUSH
15865: LD_INT 126
15867: PPUSH
15868: LD_INT 227
15870: PPUSH
15871: CALL_OW 171
// wait ( 0 0$10 ) ;
15875: LD_INT 350
15877: PPUSH
15878: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15882: LD_INT 35
15884: PPUSH
15885: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15889: LD_VAR 0 1
15893: PPUSH
15894: LD_INT 126
15896: PPUSH
15897: LD_INT 227
15899: PPUSH
15900: CALL_OW 307
15904: IFFALSE 15882
// RemoveUnit ( veh ) ;
15906: LD_VAR 0 1
15910: PPUSH
15911: CALL_OW 64
// end ;
15915: PPOPN 2
15917: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15918: LD_EXP 2
15922: PUSH
15923: LD_INT 1
15925: EQUAL
15926: IFFALSE 15934
15928: PUSH
15929: LD_EXP 27
15933: AND
15934: IFFALSE 15946
15936: PUSH
15937: LD_EXP 25
15941: PUSH
15942: LD_INT 2
15944: EQUAL
15945: AND
15946: IFFALSE 16138
15948: GO 15950
15950: DISABLE
15951: LD_INT 0
15953: PPUSH
15954: PPUSH
// begin enable ;
15955: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15956: LD_OWVAR 1
15960: PUSH
15961: LD_INT 105000
15963: PUSH
15964: LD_INT 84000
15966: PUSH
15967: LD_INT 63000
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: LIST
15974: PUSH
15975: LD_OWVAR 67
15979: ARRAY
15980: GREATEREQUAL
15981: IFFALSE 15984
// disable ;
15983: DISABLE
// uc_side := 4 ;
15984: LD_ADDR_OWVAR 20
15988: PUSH
15989: LD_INT 4
15991: ST_TO_ADDR
// uc_nation := 1 ;
15992: LD_ADDR_OWVAR 21
15996: PUSH
15997: LD_INT 1
15999: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
16000: LD_INT 2
16002: PPUSH
16003: LD_INT 3
16005: PPUSH
16006: LD_INT 3
16008: PPUSH
16009: LD_INT 12
16011: PPUSH
16012: LD_INT 0
16014: PPUSH
16015: CALL 24975 0 5
// veh := CreateVehicle ;
16019: LD_ADDR_VAR 0 1
16023: PUSH
16024: CALL_OW 45
16028: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
16029: LD_VAR 0 1
16033: PPUSH
16034: LD_INT 229
16036: PPUSH
16037: LD_INT 226
16039: PPUSH
16040: LD_INT 0
16042: PPUSH
16043: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16047: LD_VAR 0 1
16051: PPUSH
16052: LD_INT 1
16054: PPUSH
16055: LD_INT 100
16057: PPUSH
16058: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16062: LD_VAR 0 1
16066: PPUSH
16067: LD_INT 25
16069: PPUSH
16070: CALL_OW 173
// AddComUnload ( veh ) ;
16074: LD_VAR 0 1
16078: PPUSH
16079: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16083: LD_VAR 0 1
16087: PPUSH
16088: LD_INT 229
16090: PPUSH
16091: LD_INT 226
16093: PPUSH
16094: CALL_OW 171
// wait ( 0 0$10 ) ;
16098: LD_INT 350
16100: PPUSH
16101: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16105: LD_INT 35
16107: PPUSH
16108: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16112: LD_VAR 0 1
16116: PPUSH
16117: LD_INT 229
16119: PPUSH
16120: LD_INT 226
16122: PPUSH
16123: CALL_OW 307
16127: IFFALSE 16105
// RemoveUnit ( veh ) ;
16129: LD_VAR 0 1
16133: PPUSH
16134: CALL_OW 64
// end ;
16138: PPOPN 2
16140: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16141: LD_EXP 2
16145: PUSH
16146: LD_INT 1
16148: EQUAL
16149: IFFALSE 16157
16151: PUSH
16152: LD_EXP 3
16156: AND
16157: IFFALSE 16165
16159: PUSH
16160: LD_EXP 24
16164: AND
16165: IFFALSE 16498
16167: GO 16169
16169: DISABLE
16170: LD_INT 0
16172: PPUSH
16173: PPUSH
16174: PPUSH
16175: PPUSH
16176: PPUSH
// begin enable ;
16177: ENABLE
// tmp := [ ] ;
16178: LD_ADDR_VAR 0 4
16182: PUSH
16183: EMPTY
16184: ST_TO_ADDR
// if commander = 1 then
16185: LD_EXP 25
16189: PUSH
16190: LD_INT 1
16192: EQUAL
16193: IFFALSE 16205
// amount := 3 else
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: LD_INT 3
16202: ST_TO_ADDR
16203: GO 16213
// amount := 2 ;
16205: LD_ADDR_VAR 0 5
16209: PUSH
16210: LD_INT 2
16212: ST_TO_ADDR
// for i = 1 to amount do
16213: LD_ADDR_VAR 0 1
16217: PUSH
16218: DOUBLE
16219: LD_INT 1
16221: DEC
16222: ST_TO_ADDR
16223: LD_VAR 0 5
16227: PUSH
16228: FOR_TO
16229: IFFALSE 16393
// begin wait ( 0 0$5 ) ;
16231: LD_INT 175
16233: PPUSH
16234: CALL_OW 67
// for j = 1 to 3 do
16238: LD_ADDR_VAR 0 2
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_INT 3
16250: PUSH
16251: FOR_TO
16252: IFFALSE 16389
// begin uc_side := 4 ;
16254: LD_ADDR_OWVAR 20
16258: PUSH
16259: LD_INT 4
16261: ST_TO_ADDR
// uc_nation := 1 ;
16262: LD_ADDR_OWVAR 21
16266: PUSH
16267: LD_INT 1
16269: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16270: LD_INT 3
16272: PUSH
16273: LD_INT 5
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: PUSH
16280: LD_INT 1
16282: PPUSH
16283: LD_INT 2
16285: PPUSH
16286: CALL_OW 12
16290: ARRAY
16291: PPUSH
16292: LD_INT 3
16294: PPUSH
16295: LD_INT 3
16297: PPUSH
16298: LD_INT 9
16300: PUSH
16301: LD_INT 5
16303: PUSH
16304: LD_INT 7
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: LIST
16311: PUSH
16312: LD_INT 1
16314: PPUSH
16315: LD_INT 3
16317: PPUSH
16318: CALL_OW 12
16322: ARRAY
16323: PPUSH
16324: LD_INT 100
16326: PPUSH
16327: CALL 24975 0 5
// veh := CreateVehicle ;
16331: LD_ADDR_VAR 0 3
16335: PUSH
16336: CALL_OW 45
16340: ST_TO_ADDR
// tmp := tmp ^ veh ;
16341: LD_ADDR_VAR 0 4
16345: PUSH
16346: LD_VAR 0 4
16350: PUSH
16351: LD_VAR 0 3
16355: ADD
16356: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16357: LD_VAR 0 3
16361: PPUSH
16362: LD_INT 22
16364: PPUSH
16365: LD_INT 0
16367: PPUSH
16368: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16372: LD_VAR 0 3
16376: PPUSH
16377: LD_INT 119
16379: PPUSH
16380: LD_INT 215
16382: PPUSH
16383: CALL_OW 111
// end ;
16387: GO 16251
16389: POP
16390: POP
// end ;
16391: GO 16228
16393: POP
16394: POP
// wait ( 0 0$3 ) ;
16395: LD_INT 105
16397: PPUSH
16398: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16402: LD_INT 35
16404: PPUSH
16405: CALL_OW 67
// for i in tmp do
16409: LD_ADDR_VAR 0 1
16413: PUSH
16414: LD_VAR 0 4
16418: PUSH
16419: FOR_IN
16420: IFFALSE 16487
// if IsDead ( i ) then
16422: LD_VAR 0 1
16426: PPUSH
16427: CALL_OW 301
16431: IFFALSE 16451
// tmp := tmp diff i else
16433: LD_ADDR_VAR 0 4
16437: PUSH
16438: LD_VAR 0 4
16442: PUSH
16443: LD_VAR 0 1
16447: DIFF
16448: ST_TO_ADDR
16449: GO 16485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_INT 81
16458: PUSH
16459: LD_INT 4
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PPUSH
16466: CALL_OW 69
16470: PPUSH
16471: LD_VAR 0 1
16475: PPUSH
16476: CALL_OW 74
16480: PPUSH
16481: CALL_OW 115
16485: GO 16419
16487: POP
16488: POP
// until tmp = [ ] ;
16489: LD_VAR 0 4
16493: PUSH
16494: EMPTY
16495: EQUAL
16496: IFFALSE 16402
// end ;
16498: PPOPN 5
16500: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16501: LD_EXP 2
16505: PUSH
16506: LD_INT 1
16508: EQUAL
16509: IFFALSE 16517
16511: PUSH
16512: LD_EXP 3
16516: AND
16517: IFFALSE 16618
16519: GO 16521
16521: DISABLE
16522: LD_INT 0
16524: PPUSH
16525: PPUSH
// begin enable ;
16526: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16527: LD_ADDR_VAR 0 2
16531: PUSH
16532: LD_INT 3
16534: PUSH
16535: LD_INT 22
16537: PUSH
16538: LD_INT 1
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 32
16551: PUSH
16552: LD_INT 1
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: PPUSH
16563: CALL_OW 69
16567: ST_TO_ADDR
// if tmp then
16568: LD_VAR 0 2
16572: IFFALSE 16618
// for i in tmp do
16574: LD_ADDR_VAR 0 1
16578: PUSH
16579: LD_VAR 0 2
16583: PUSH
16584: FOR_IN
16585: IFFALSE 16616
// if GetFuel ( i ) < 3 then
16587: LD_VAR 0 1
16591: PPUSH
16592: CALL_OW 261
16596: PUSH
16597: LD_INT 3
16599: LESS
16600: IFFALSE 16614
// SetFuel ( i , 3 ) ;
16602: LD_VAR 0 1
16606: PPUSH
16607: LD_INT 3
16609: PPUSH
16610: CALL_OW 240
16614: GO 16584
16616: POP
16617: POP
// end ;
16618: PPOPN 2
16620: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16621: LD_EXP 3
16625: IFFALSE 16643
16627: PUSH
16628: LD_INT 8
16630: PPUSH
16631: LD_INT 4
16633: PPUSH
16634: CALL_OW 81
16638: PUSH
16639: LD_INT 2
16641: EQUAL
16642: AND
16643: IFFALSE 16853
16645: GO 16647
16647: DISABLE
16648: LD_INT 0
16650: PPUSH
16651: PPUSH
16652: PPUSH
// begin enable ;
16653: ENABLE
// tmp := [ ] ;
16654: LD_ADDR_VAR 0 3
16658: PUSH
16659: EMPTY
16660: ST_TO_ADDR
// for i = 1 to 4 do
16661: LD_ADDR_VAR 0 1
16665: PUSH
16666: DOUBLE
16667: LD_INT 1
16669: DEC
16670: ST_TO_ADDR
16671: LD_INT 4
16673: PUSH
16674: FOR_TO
16675: IFFALSE 16819
// begin uc_side := 8 ;
16677: LD_ADDR_OWVAR 20
16681: PUSH
16682: LD_INT 8
16684: ST_TO_ADDR
// uc_nation := nation_arabian ;
16685: LD_ADDR_OWVAR 21
16689: PUSH
16690: LD_INT 2
16692: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16693: LD_INT 11
16695: PPUSH
16696: LD_INT 1
16698: PPUSH
16699: LD_INT 5
16701: PPUSH
16702: LD_INT 24
16704: PUSH
16705: LD_INT 23
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 1
16714: PPUSH
16715: LD_INT 2
16717: PPUSH
16718: CALL_OW 12
16722: ARRAY
16723: PPUSH
16724: LD_INT 60
16726: PPUSH
16727: LD_INT 80
16729: PPUSH
16730: CALL_OW 12
16734: PPUSH
16735: CALL 24975 0 5
// un := CreateVehicle ;
16739: LD_ADDR_VAR 0 2
16743: PUSH
16744: CALL_OW 45
16748: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16749: LD_VAR 0 2
16753: PPUSH
16754: LD_INT 2
16756: PPUSH
16757: CALL_OW 233
// tmp := tmp ^ un ;
16761: LD_ADDR_VAR 0 3
16765: PUSH
16766: LD_VAR 0 3
16770: PUSH
16771: LD_VAR 0 2
16775: ADD
16776: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16777: LD_VAR 0 2
16781: PPUSH
16782: LD_INT 88
16784: PPUSH
16785: LD_INT 2
16787: PPUSH
16788: LD_INT 0
16790: PPUSH
16791: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16795: LD_VAR 0 2
16799: PPUSH
16800: LD_INT 93
16802: PPUSH
16803: LD_INT 13
16805: PPUSH
16806: CALL_OW 111
// wait ( 0 0$2 ) ;
16810: LD_INT 70
16812: PPUSH
16813: CALL_OW 67
// end ;
16817: GO 16674
16819: POP
16820: POP
// for i in tmp do
16821: LD_ADDR_VAR 0 1
16825: PUSH
16826: LD_VAR 0 3
16830: PUSH
16831: FOR_IN
16832: IFFALSE 16851
// AddComMoveXY ( i , 136 , 19 ) ;
16834: LD_VAR 0 1
16838: PPUSH
16839: LD_INT 136
16841: PPUSH
16842: LD_INT 19
16844: PPUSH
16845: CALL_OW 171
16849: GO 16831
16851: POP
16852: POP
// end ;
16853: PPOPN 3
16855: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16856: LD_EXP 3
16860: IFFALSE 17781
16862: GO 16864
16864: DISABLE
16865: LD_INT 0
16867: PPUSH
16868: PPUSH
16869: PPUSH
16870: PPUSH
// begin enable ;
16871: ENABLE
// base := mc_leg ;
16872: LD_ADDR_VAR 0 2
16876: PUSH
16877: LD_EXP 6
16881: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16882: LD_INT 22
16884: PUSH
16885: LD_INT 8
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: LD_INT 23
16894: PUSH
16895: LD_INT 2
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 30
16904: PUSH
16905: LD_INT 3
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: PPUSH
16917: CALL_OW 69
16921: NOT
16922: IFFALSE 16926
// exit ;
16924: GO 17781
// if Prob ( 40 ) then
16926: LD_INT 40
16928: PPUSH
16929: CALL_OW 13
16933: IFFALSE 17062
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16935: LD_VAR 0 2
16939: PPUSH
16940: LD_INT 13
16942: PUSH
16943: LD_INT 1
16945: PUSH
16946: LD_INT 2
16948: PUSH
16949: LD_INT 28
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: PUSH
16958: LD_INT 13
16960: PUSH
16961: LD_INT 1
16963: PUSH
16964: LD_INT 2
16966: PUSH
16967: LD_INT 28
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 13
16978: PUSH
16979: LD_INT 1
16981: PUSH
16982: LD_INT 2
16984: PUSH
16985: LD_INT 28
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: PUSH
16994: LD_INT 13
16996: PUSH
16997: LD_INT 1
16999: PUSH
17000: LD_INT 2
17002: PUSH
17003: LD_INT 28
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: PUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 28
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: LIST
17028: LIST
17029: PUSH
17030: LD_INT 13
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: LD_INT 2
17038: PUSH
17039: LD_INT 26
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: LIST
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: PPUSH
17056: CALL 88047 0 2
// end else
17060: GO 17279
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17062: LD_VAR 0 2
17066: PPUSH
17067: LD_INT 13
17069: PUSH
17070: LD_INT 1
17072: PUSH
17073: LD_INT 2
17075: PUSH
17076: LD_INT 27
17078: PUSH
17079: LD_INT 26
17081: PUSH
17082: LD_INT 26
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 1
17092: PPUSH
17093: LD_INT 3
17095: PPUSH
17096: CALL_OW 12
17100: ARRAY
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: PUSH
17108: LD_INT 13
17110: PUSH
17111: LD_INT 1
17113: PUSH
17114: LD_INT 2
17116: PUSH
17117: LD_INT 27
17119: PUSH
17120: LD_INT 26
17122: PUSH
17123: LD_INT 26
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: LIST
17130: PUSH
17131: LD_INT 1
17133: PPUSH
17134: LD_INT 3
17136: PPUSH
17137: CALL_OW 12
17141: ARRAY
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 13
17151: PUSH
17152: LD_INT 1
17154: PUSH
17155: LD_INT 2
17157: PUSH
17158: LD_INT 26
17160: PUSH
17161: LD_INT 26
17163: PUSH
17164: LD_INT 29
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: LIST
17171: PUSH
17172: LD_INT 1
17174: PPUSH
17175: LD_INT 3
17177: PPUSH
17178: CALL_OW 12
17182: ARRAY
17183: PUSH
17184: EMPTY
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: PUSH
17190: LD_INT 13
17192: PUSH
17193: LD_INT 1
17195: PUSH
17196: LD_INT 2
17198: PUSH
17199: LD_INT 26
17201: PUSH
17202: LD_INT 29
17204: PUSH
17205: LD_INT 29
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: PUSH
17213: LD_INT 1
17215: PPUSH
17216: LD_INT 3
17218: PPUSH
17219: CALL_OW 12
17223: ARRAY
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: PUSH
17231: LD_INT 13
17233: PUSH
17234: LD_INT 1
17236: PUSH
17237: LD_INT 2
17239: PUSH
17240: LD_INT 29
17242: PUSH
17243: EMPTY
17244: LIST
17245: LIST
17246: LIST
17247: LIST
17248: PUSH
17249: LD_INT 13
17251: PUSH
17252: LD_INT 1
17254: PUSH
17255: LD_INT 2
17257: PUSH
17258: LD_INT 26
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: LIST
17272: LIST
17273: LIST
17274: PPUSH
17275: CALL 88047 0 2
// end ; repeat wait ( 0 0$1 ) ;
17279: LD_INT 35
17281: PPUSH
17282: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17286: LD_VAR 0 2
17290: PPUSH
17291: LD_INT 1
17293: PPUSH
17294: CALL 89503 0 2
17298: PUSH
17299: LD_INT 6
17301: GREATEREQUAL
17302: IFTRUE 17318
17304: PUSH
17305: LD_OWVAR 1
17309: PUSH
17310: LD_INT 21000
17312: MOD
17313: PUSH
17314: LD_INT 0
17316: EQUAL
17317: OR
17318: IFFALSE 17279
// wait ( 0 0$30 ) ;
17320: LD_INT 1050
17322: PPUSH
17323: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17327: LD_ADDR_VAR 0 3
17331: PUSH
17332: LD_VAR 0 2
17336: PPUSH
17337: LD_INT 1
17339: PPUSH
17340: CALL 89503 0 2
17344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17345: LD_ADDR_EXP 50
17349: PUSH
17350: LD_EXP 50
17354: PPUSH
17355: LD_VAR 0 2
17359: PPUSH
17360: LD_EXP 50
17364: PUSH
17365: LD_VAR 0 2
17369: ARRAY
17370: PUSH
17371: LD_VAR 0 3
17375: DIFF
17376: PPUSH
17377: CALL_OW 1
17381: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17382: LD_ADDR_VAR 0 4
17386: PUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 2
17392: PPUSH
17393: CALL_OW 12
17397: ST_TO_ADDR
// if legChangeSide then
17398: LD_EXP 21
17402: IFFALSE 17412
// target := 2 ;
17404: LD_ADDR_VAR 0 4
17408: PUSH
17409: LD_INT 2
17411: ST_TO_ADDR
// if target = 2 then
17412: LD_VAR 0 4
17416: PUSH
17417: LD_INT 2
17419: EQUAL
17420: IFFALSE 17548
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17422: LD_ADDR_VAR 0 3
17426: PUSH
17427: LD_VAR 0 3
17431: PPUSH
17432: LD_INT 24
17434: PUSH
17435: LD_INT 250
17437: PUSH
17438: EMPTY
17439: LIST
17440: LIST
17441: PPUSH
17442: CALL_OW 72
17446: ST_TO_ADDR
// for i in tmp do
17447: LD_ADDR_VAR 0 1
17451: PUSH
17452: LD_VAR 0 3
17456: PUSH
17457: FOR_IN
17458: IFFALSE 17498
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17460: LD_VAR 0 1
17464: PPUSH
17465: LD_INT 112
17467: PPUSH
17468: LD_INT 64
17470: PPUSH
17471: CALL_OW 297
17475: PUSH
17476: LD_INT 9
17478: GREATER
17479: IFFALSE 17496
// ComMoveXY ( i , 112 , 64 ) ;
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 112
17488: PPUSH
17489: LD_INT 64
17491: PPUSH
17492: CALL_OW 111
17496: GO 17457
17498: POP
17499: POP
// wait ( 0 0$1 ) ;
17500: LD_INT 35
17502: PPUSH
17503: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17507: LD_VAR 0 3
17511: PPUSH
17512: LD_INT 92
17514: PUSH
17515: LD_INT 112
17517: PUSH
17518: LD_INT 64
17520: PUSH
17521: LD_INT 9
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: PPUSH
17530: CALL_OW 72
17534: PUSH
17535: LD_VAR 0 3
17539: PUSH
17540: LD_INT 1
17542: MINUS
17543: GREATEREQUAL
17544: IFFALSE 17422
// end else
17546: GO 17672
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17548: LD_ADDR_VAR 0 3
17552: PUSH
17553: LD_VAR 0 3
17557: PPUSH
17558: LD_INT 24
17560: PUSH
17561: LD_INT 250
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: PPUSH
17568: CALL_OW 72
17572: ST_TO_ADDR
// for i in tmp do
17573: LD_ADDR_VAR 0 1
17577: PUSH
17578: LD_VAR 0 3
17582: PUSH
17583: FOR_IN
17584: IFFALSE 17624
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17586: LD_VAR 0 1
17590: PPUSH
17591: LD_INT 174
17593: PPUSH
17594: LD_INT 94
17596: PPUSH
17597: CALL_OW 297
17601: PUSH
17602: LD_INT 9
17604: GREATER
17605: IFFALSE 17622
// ComMoveXY ( i , 174 , 94 ) ;
17607: LD_VAR 0 1
17611: PPUSH
17612: LD_INT 174
17614: PPUSH
17615: LD_INT 94
17617: PPUSH
17618: CALL_OW 111
17622: GO 17583
17624: POP
17625: POP
// wait ( 0 0$1 ) ;
17626: LD_INT 35
17628: PPUSH
17629: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17633: LD_VAR 0 3
17637: PPUSH
17638: LD_INT 92
17640: PUSH
17641: LD_INT 174
17643: PUSH
17644: LD_INT 94
17646: PUSH
17647: LD_INT 9
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: PPUSH
17656: CALL_OW 72
17660: PUSH
17661: LD_VAR 0 3
17665: PUSH
17666: LD_INT 1
17668: MINUS
17669: GREATEREQUAL
17670: IFFALSE 17548
// end ; repeat wait ( 0 0$1 ) ;
17672: LD_INT 35
17674: PPUSH
17675: CALL_OW 67
// for i in tmp do
17679: LD_ADDR_VAR 0 1
17683: PUSH
17684: LD_VAR 0 3
17688: PUSH
17689: FOR_IN
17690: IFFALSE 17772
// begin if GetLives ( i ) > 251 then
17692: LD_VAR 0 1
17696: PPUSH
17697: CALL_OW 256
17701: PUSH
17702: LD_INT 251
17704: GREATER
17705: IFFALSE 17743
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 81
17714: PUSH
17715: LD_INT 8
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: PPUSH
17722: CALL_OW 69
17726: PPUSH
17727: LD_VAR 0 1
17731: PPUSH
17732: CALL_OW 74
17736: PPUSH
17737: CALL_OW 115
17741: GO 17770
// if IsDead ( i ) then
17743: LD_VAR 0 1
17747: PPUSH
17748: CALL_OW 301
17752: IFFALSE 17770
// tmp := tmp diff i ;
17754: LD_ADDR_VAR 0 3
17758: PUSH
17759: LD_VAR 0 3
17763: PUSH
17764: LD_VAR 0 1
17768: DIFF
17769: ST_TO_ADDR
// end ;
17770: GO 17689
17772: POP
17773: POP
// until not tmp ;
17774: LD_VAR 0 3
17778: NOT
17779: IFFALSE 17672
// end ;
17781: PPOPN 4
17783: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17784: LD_EXP 3
17788: IFFALSE 18780
17790: GO 17792
17792: DISABLE
17793: LD_INT 0
17795: PPUSH
17796: PPUSH
17797: PPUSH
17798: PPUSH
17799: PPUSH
// begin enable ;
17800: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17801: LD_EXP 31
17805: PUSH
17806: LD_EXP 8
17810: ARRAY
17811: PPUSH
17812: LD_INT 22
17814: PUSH
17815: LD_INT 3
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: PUSH
17822: LD_INT 30
17824: PUSH
17825: LD_INT 3
17827: PUSH
17828: EMPTY
17829: LIST
17830: LIST
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: PPUSH
17836: CALL_OW 72
17840: NOT
17841: IFFALSE 17845
// exit ;
17843: GO 18780
// base := mc_rus_2 ;
17845: LD_ADDR_VAR 0 2
17849: PUSH
17850: LD_EXP 8
17854: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17855: LD_ADDR_VAR 0 5
17859: PUSH
17860: LD_INT 22
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PUSH
17870: LD_INT 30
17872: PUSH
17873: LD_INT 34
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: PPUSH
17884: CALL_OW 69
17888: ST_TO_ADDR
// if Prob ( 40 ) then
17889: LD_INT 40
17891: PPUSH
17892: CALL_OW 13
17896: IFFALSE 18025
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17898: LD_VAR 0 2
17902: PPUSH
17903: LD_INT 22
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 3
17911: PUSH
17912: LD_INT 49
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 22
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 3
17929: PUSH
17930: LD_INT 49
17932: PUSH
17933: EMPTY
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: PUSH
17939: LD_INT 22
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 3
17947: PUSH
17948: LD_INT 49
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: PUSH
17957: LD_INT 24
17959: PUSH
17960: LD_INT 3
17962: PUSH
17963: LD_INT 3
17965: PUSH
17966: LD_INT 46
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 24
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 3
17983: PUSH
17984: LD_INT 46
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 24
17995: PUSH
17996: LD_INT 3
17998: PUSH
17999: LD_INT 3
18001: PUSH
18002: LD_INT 46
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL 88047 0 2
// end else
18023: GO 18150
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
18025: LD_VAR 0 2
18029: PPUSH
18030: LD_INT 24
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 3
18038: PUSH
18039: LD_INT 47
18041: PUSH
18042: EMPTY
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: PUSH
18048: LD_INT 24
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 3
18056: PUSH
18057: LD_INT 47
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: PUSH
18066: LD_INT 24
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 3
18074: PUSH
18075: LD_INT 47
18077: PUSH
18078: EMPTY
18079: LIST
18080: LIST
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 24
18086: PUSH
18087: LD_INT 3
18089: PUSH
18090: LD_INT 3
18092: PUSH
18093: LD_INT 46
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: LIST
18101: PUSH
18102: LD_INT 24
18104: PUSH
18105: LD_INT 3
18107: PUSH
18108: LD_INT 3
18110: PUSH
18111: LD_INT 46
18113: PUSH
18114: EMPTY
18115: LIST
18116: LIST
18117: LIST
18118: LIST
18119: PUSH
18120: LD_INT 24
18122: PUSH
18123: LD_INT 3
18125: PUSH
18126: LD_INT 3
18128: PUSH
18129: LD_INT 46
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: LIST
18136: LIST
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: LIST
18142: LIST
18143: LIST
18144: LIST
18145: PPUSH
18146: CALL 88047 0 2
// end ; if Difficulty > 1 then
18150: LD_OWVAR 67
18154: PUSH
18155: LD_INT 1
18157: GREATER
18158: IFFALSE 18190
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18160: LD_VAR 0 2
18164: PPUSH
18165: LD_INT 24
18167: PUSH
18168: LD_INT 3
18170: PUSH
18171: LD_INT 3
18173: PUSH
18174: LD_INT 47
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: PUSH
18183: EMPTY
18184: LIST
18185: PPUSH
18186: CALL 88047 0 2
// repeat wait ( 0 0$1 ) ;
18190: LD_INT 35
18192: PPUSH
18193: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18197: LD_VAR 0 2
18201: PPUSH
18202: LD_INT 1
18204: PPUSH
18205: CALL 89503 0 2
18209: PUSH
18210: LD_INT 6
18212: PUSH
18213: LD_INT 7
18215: PUSH
18216: LD_INT 7
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: LIST
18223: PUSH
18224: LD_OWVAR 67
18228: ARRAY
18229: GREATEREQUAL
18230: IFTRUE 18246
18232: PUSH
18233: LD_OWVAR 1
18237: PUSH
18238: LD_INT 21000
18240: MOD
18241: PUSH
18242: LD_INT 0
18244: EQUAL
18245: OR
18246: IFFALSE 18190
// wait ( 0 0$45 ) ;
18248: LD_INT 1575
18250: PPUSH
18251: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18255: LD_ADDR_VAR 0 3
18259: PUSH
18260: LD_VAR 0 2
18264: PPUSH
18265: LD_INT 1
18267: PPUSH
18268: CALL 89503 0 2
18272: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18273: LD_ADDR_EXP 50
18277: PUSH
18278: LD_EXP 50
18282: PPUSH
18283: LD_VAR 0 2
18287: PPUSH
18288: LD_EXP 50
18292: PUSH
18293: LD_VAR 0 2
18297: ARRAY
18298: PUSH
18299: LD_VAR 0 3
18303: DIFF
18304: PPUSH
18305: CALL_OW 1
18309: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18310: LD_ADDR_VAR 0 4
18314: PUSH
18315: LD_INT 0
18317: PPUSH
18318: LD_INT 1
18320: PPUSH
18321: CALL_OW 12
18325: ST_TO_ADDR
// if target then
18326: LD_VAR 0 4
18330: IFFALSE 18458
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 3
18341: PPUSH
18342: LD_INT 24
18344: PUSH
18345: LD_INT 250
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PPUSH
18352: CALL_OW 72
18356: ST_TO_ADDR
// for i in tmp do
18357: LD_ADDR_VAR 0 1
18361: PUSH
18362: LD_VAR 0 3
18366: PUSH
18367: FOR_IN
18368: IFFALSE 18408
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18370: LD_VAR 0 1
18374: PPUSH
18375: LD_INT 84
18377: PPUSH
18378: LD_INT 32
18380: PPUSH
18381: CALL_OW 297
18385: PUSH
18386: LD_INT 9
18388: GREATER
18389: IFFALSE 18406
// ComMoveXY ( i , 84 , 32 ) ;
18391: LD_VAR 0 1
18395: PPUSH
18396: LD_INT 84
18398: PPUSH
18399: LD_INT 32
18401: PPUSH
18402: CALL_OW 111
18406: GO 18367
18408: POP
18409: POP
// wait ( 0 0$1 ) ;
18410: LD_INT 35
18412: PPUSH
18413: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18417: LD_VAR 0 3
18421: PPUSH
18422: LD_INT 92
18424: PUSH
18425: LD_INT 84
18427: PUSH
18428: LD_INT 32
18430: PUSH
18431: LD_INT 9
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 72
18444: PUSH
18445: LD_VAR 0 3
18449: PUSH
18450: LD_INT 1
18452: MINUS
18453: GREATEREQUAL
18454: IFFALSE 18332
// end else
18456: GO 18620
// begin if teleport then
18458: LD_VAR 0 5
18462: IFFALSE 18482
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18464: LD_VAR 0 3
18468: PPUSH
18469: LD_VAR 0 5
18473: PUSH
18474: LD_INT 1
18476: ARRAY
18477: PPUSH
18478: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18482: LD_ADDR_VAR 0 3
18486: PUSH
18487: LD_VAR 0 3
18491: PPUSH
18492: LD_INT 24
18494: PUSH
18495: LD_INT 250
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PPUSH
18502: CALL_OW 72
18506: ST_TO_ADDR
// for i in tmp do
18507: LD_ADDR_VAR 0 1
18511: PUSH
18512: LD_VAR 0 3
18516: PUSH
18517: FOR_IN
18518: IFFALSE 18572
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18520: LD_VAR 0 1
18524: PPUSH
18525: LD_INT 140
18527: PPUSH
18528: LD_INT 219
18530: PPUSH
18531: CALL_OW 297
18535: PUSH
18536: LD_INT 9
18538: GREATER
18539: IFFALSE 18553
18541: PUSH
18542: LD_VAR 0 1
18546: PPUSH
18547: CALL_OW 314
18551: NOT
18552: AND
18553: IFFALSE 18570
// AddComMoveXY ( i , 140 , 219 ) ;
18555: LD_VAR 0 1
18559: PPUSH
18560: LD_INT 140
18562: PPUSH
18563: LD_INT 219
18565: PPUSH
18566: CALL_OW 171
18570: GO 18517
18572: POP
18573: POP
// wait ( 0 0$1 ) ;
18574: LD_INT 35
18576: PPUSH
18577: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18581: LD_VAR 0 3
18585: PPUSH
18586: LD_INT 92
18588: PUSH
18589: LD_INT 140
18591: PUSH
18592: LD_INT 219
18594: PUSH
18595: LD_INT 9
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: PPUSH
18604: CALL_OW 72
18608: PUSH
18609: LD_VAR 0 3
18613: PUSH
18614: LD_INT 1
18616: MINUS
18617: GREATEREQUAL
18618: IFFALSE 18482
// end ; repeat wait ( 0 0$1 ) ;
18620: LD_INT 35
18622: PPUSH
18623: CALL_OW 67
// for i in tmp do
18627: LD_ADDR_VAR 0 1
18631: PUSH
18632: LD_VAR 0 3
18636: PUSH
18637: FOR_IN
18638: IFFALSE 18771
// begin if GetLives ( i ) > 251 then
18640: LD_VAR 0 1
18644: PPUSH
18645: CALL_OW 256
18649: PUSH
18650: LD_INT 251
18652: GREATER
18653: IFFALSE 18742
// begin if GetWeapon ( i ) = ru_time_lapser then
18655: LD_VAR 0 1
18659: PPUSH
18660: CALL_OW 264
18664: PUSH
18665: LD_INT 49
18667: EQUAL
18668: IFFALSE 18706
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18670: LD_VAR 0 1
18674: PPUSH
18675: LD_INT 81
18677: PUSH
18678: LD_INT 3
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PPUSH
18685: CALL_OW 69
18689: PPUSH
18690: LD_VAR 0 1
18694: PPUSH
18695: CALL_OW 74
18699: PPUSH
18700: CALL_OW 112
18704: GO 18740
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18706: LD_VAR 0 1
18710: PPUSH
18711: LD_INT 81
18713: PUSH
18714: LD_INT 3
18716: PUSH
18717: EMPTY
18718: LIST
18719: LIST
18720: PPUSH
18721: CALL_OW 69
18725: PPUSH
18726: LD_VAR 0 1
18730: PPUSH
18731: CALL_OW 74
18735: PPUSH
18736: CALL_OW 115
// end else
18740: GO 18769
// if IsDead ( i ) then
18742: LD_VAR 0 1
18746: PPUSH
18747: CALL_OW 301
18751: IFFALSE 18769
// tmp := tmp diff i ;
18753: LD_ADDR_VAR 0 3
18757: PUSH
18758: LD_VAR 0 3
18762: PUSH
18763: LD_VAR 0 1
18767: DIFF
18768: ST_TO_ADDR
// end ;
18769: GO 18637
18771: POP
18772: POP
// until not tmp ;
18773: LD_VAR 0 3
18777: NOT
18778: IFFALSE 18620
// end ;
18780: PPOPN 5
18782: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18783: LD_EXP 3
18787: IFFALSE 19171
18789: GO 18791
18791: DISABLE
18792: LD_INT 0
18794: PPUSH
18795: PPUSH
18796: PPUSH
18797: PPUSH
// begin enable ;
18798: ENABLE
// base := mc_amer ;
18799: LD_ADDR_VAR 0 2
18803: PUSH
18804: LD_EXP 5
18808: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18809: LD_INT 22
18811: PUSH
18812: LD_INT 4
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: LD_INT 23
18821: PUSH
18822: LD_INT 1
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: PUSH
18829: LD_INT 30
18831: PUSH
18832: LD_INT 3
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: LIST
18843: PPUSH
18844: CALL_OW 69
18848: NOT
18849: IFFALSE 18853
// exit ;
18851: GO 19171
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18853: LD_VAR 0 2
18857: PPUSH
18858: LD_INT 3
18860: PUSH
18861: LD_INT 1
18863: PUSH
18864: LD_INT 2
18866: PUSH
18867: LD_INT 5
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 3
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: LD_INT 2
18884: PUSH
18885: LD_INT 9
18887: PUSH
18888: EMPTY
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PUSH
18894: LD_INT 3
18896: PUSH
18897: LD_INT 1
18899: PUSH
18900: LD_INT 2
18902: PUSH
18903: LD_INT 7
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: LIST
18910: LIST
18911: PUSH
18912: LD_INT 3
18914: PUSH
18915: LD_INT 1
18917: PUSH
18918: LD_INT 2
18920: PUSH
18921: LD_INT 7
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: PUSH
18930: LD_INT 3
18932: PUSH
18933: LD_INT 1
18935: PUSH
18936: LD_INT 2
18938: PUSH
18939: LD_INT 7
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: LIST
18946: LIST
18947: PUSH
18948: EMPTY
18949: LIST
18950: LIST
18951: LIST
18952: LIST
18953: LIST
18954: PPUSH
18955: CALL 88047 0 2
// repeat wait ( 0 0$1 ) ;
18959: LD_INT 35
18961: PPUSH
18962: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18966: LD_VAR 0 2
18970: PPUSH
18971: LD_INT 1
18973: PPUSH
18974: CALL 89503 0 2
18978: PUSH
18979: LD_INT 5
18981: GREATEREQUAL
18982: IFTRUE 18998
18984: PUSH
18985: LD_OWVAR 1
18989: PUSH
18990: LD_INT 21000
18992: MOD
18993: PUSH
18994: LD_INT 0
18996: EQUAL
18997: OR
18998: IFFALSE 18959
// wait ( 0 0$30 ) ;
19000: LD_INT 1050
19002: PPUSH
19003: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
19007: LD_ADDR_VAR 0 3
19011: PUSH
19012: LD_VAR 0 2
19016: PPUSH
19017: LD_INT 1
19019: PPUSH
19020: CALL 89503 0 2
19024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
19025: LD_ADDR_EXP 50
19029: PUSH
19030: LD_EXP 50
19034: PPUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: LD_EXP 50
19044: PUSH
19045: LD_VAR 0 2
19049: ARRAY
19050: PUSH
19051: LD_VAR 0 3
19055: DIFF
19056: PPUSH
19057: CALL_OW 1
19061: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19062: LD_INT 35
19064: PPUSH
19065: CALL_OW 67
// for i in tmp do
19069: LD_ADDR_VAR 0 1
19073: PUSH
19074: LD_VAR 0 3
19078: PUSH
19079: FOR_IN
19080: IFFALSE 19162
// begin if GetLives ( i ) > 251 then
19082: LD_VAR 0 1
19086: PPUSH
19087: CALL_OW 256
19091: PUSH
19092: LD_INT 251
19094: GREATER
19095: IFFALSE 19133
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19097: LD_VAR 0 1
19101: PPUSH
19102: LD_INT 81
19104: PUSH
19105: LD_INT 4
19107: PUSH
19108: EMPTY
19109: LIST
19110: LIST
19111: PPUSH
19112: CALL_OW 69
19116: PPUSH
19117: LD_VAR 0 1
19121: PPUSH
19122: CALL_OW 74
19126: PPUSH
19127: CALL_OW 115
19131: GO 19160
// if IsDead ( i ) then
19133: LD_VAR 0 1
19137: PPUSH
19138: CALL_OW 301
19142: IFFALSE 19160
// tmp := tmp diff i ;
19144: LD_ADDR_VAR 0 3
19148: PUSH
19149: LD_VAR 0 3
19153: PUSH
19154: LD_VAR 0 1
19158: DIFF
19159: ST_TO_ADDR
// end ;
19160: GO 19079
19162: POP
19163: POP
// until not tmp ;
19164: LD_VAR 0 3
19168: NOT
19169: IFFALSE 19062
// end ; end_of_file
19171: PPOPN 4
19173: END
// export function CustomEvent ( event ) ; begin
19174: LD_INT 0
19176: PPUSH
// end ;
19177: LD_VAR 0 2
19181: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19182: LD_VAR 0 1
19186: PUSH
19187: LD_INT 1
19189: EQUAL
19190: IFFALSE 19202
19192: PUSH
19193: LD_VAR 0 2
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: AND
19202: IFFALSE 19230
// begin SayRadio ( Powell , DP-Lost ) ;
19204: LD_EXP 12
19208: PPUSH
19209: LD_STRING DP-Lost
19211: PPUSH
19212: CALL_OW 94
// wait ( 0 0$2 ) ;
19216: LD_INT 70
19218: PPUSH
19219: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19223: LD_STRING FriendlyFire
19225: PPUSH
19226: CALL_OW 104
// end ; end ;
19230: PPOPN 2
19232: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19233: LD_VAR 0 1
19237: PPUSH
19238: CALL 110657 0 1
// if GameType = 1 then
19242: LD_EXP 2
19246: PUSH
19247: LD_INT 1
19249: EQUAL
19250: IFFALSE 19485
// begin if un = playerCommander then
19252: LD_VAR 0 1
19256: PUSH
19257: LD_EXP 9
19261: EQUAL
19262: IFFALSE 19271
// YouLost ( commanderDied ) ;
19264: LD_STRING commanderDied
19266: PPUSH
19267: CALL_OW 104
// if un = allyCommander then
19271: LD_VAR 0 1
19275: PUSH
19276: LD_EXP 11
19280: EQUAL
19281: IFFALSE 19290
// YouLost ( Theta ) ;
19283: LD_STRING Theta
19285: PPUSH
19286: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19290: LD_VAR 0 1
19294: PUSH
19295: LD_INT 22
19297: PUSH
19298: LD_INT 8
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: PUSH
19305: LD_INT 2
19307: PUSH
19308: LD_INT 21
19310: PUSH
19311: LD_INT 1
19313: PUSH
19314: EMPTY
19315: LIST
19316: LIST
19317: PUSH
19318: LD_INT 21
19320: PUSH
19321: LD_INT 3
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: PUSH
19328: EMPTY
19329: LIST
19330: LIST
19331: LIST
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: PPUSH
19337: CALL_OW 69
19341: IN
19342: IFFALSE 19358
// legDestCounter := legDestCounter + 1 ;
19344: LD_ADDR_EXP 18
19348: PUSH
19349: LD_EXP 18
19353: PUSH
19354: LD_INT 1
19356: PLUS
19357: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19358: LD_VAR 0 1
19362: PUSH
19363: LD_INT 22
19365: PUSH
19366: LD_INT 4
19368: PUSH
19369: EMPTY
19370: LIST
19371: LIST
19372: PUSH
19373: LD_INT 2
19375: PUSH
19376: LD_INT 21
19378: PUSH
19379: LD_INT 1
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 3
19391: PUSH
19392: EMPTY
19393: LIST
19394: LIST
19395: PUSH
19396: EMPTY
19397: LIST
19398: LIST
19399: LIST
19400: PUSH
19401: EMPTY
19402: LIST
19403: LIST
19404: PPUSH
19405: CALL_OW 69
19409: IN
19410: IFFALSE 19426
// allyDestCounter := allyDestCounter + 1 ;
19412: LD_ADDR_EXP 22
19416: PUSH
19417: LD_EXP 22
19421: PUSH
19422: LD_INT 1
19424: PLUS
19425: ST_TO_ADDR
// if un in ruOutpost then
19426: LD_VAR 0 1
19430: PUSH
19431: LD_EXP 14
19435: IN
19436: IFFALSE 19485
// begin ruOutpost := ruOutpost diff un ;
19438: LD_ADDR_EXP 14
19442: PUSH
19443: LD_EXP 14
19447: PUSH
19448: LD_VAR 0 1
19452: DIFF
19453: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19454: LD_ADDR_EXP 15
19458: PUSH
19459: LD_EXP 15
19463: PPUSH
19464: LD_INT 1
19466: PPUSH
19467: LD_EXP 15
19471: PUSH
19472: LD_INT 1
19474: ARRAY
19475: PUSH
19476: LD_INT 1
19478: PLUS
19479: PPUSH
19480: CALL_OW 1
19484: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19485: LD_VAR 0 1
19489: PPUSH
19490: CALL 91553 0 1
// end ;
19494: PPOPN 1
19496: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19497: LD_VAR 0 1
19501: PPUSH
19502: LD_VAR 0 2
19506: PPUSH
19507: CALL 93907 0 2
// end ;
19511: PPOPN 2
19513: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19514: LD_VAR 0 1
19518: PPUSH
19519: CALL 92971 0 1
// end ;
19523: PPOPN 1
19525: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19526: LD_VAR 0 1
19530: PPUSH
19531: CALL 93214 0 1
// end ;
19535: PPOPN 1
19537: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19538: LD_VAR 0 1
19542: PUSH
19543: LD_INT 14
19545: EQUAL
19546: IFFALSE 19563
19548: PUSH
19549: LD_VAR 0 2
19553: PPUSH
19554: CALL_OW 255
19558: PUSH
19559: LD_INT 1
19561: EQUAL
19562: AND
19563: IFFALSE 19604
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19565: LD_EXP 9
19569: PPUSH
19570: LD_STRING D
19572: PUSH
19573: LD_STRING I
19575: PUSH
19576: LD_STRING J
19578: PUSH
19579: LD_STRING S
19581: PUSH
19582: EMPTY
19583: LIST
19584: LIST
19585: LIST
19586: PUSH
19587: LD_EXP 25
19591: ARRAY
19592: STR
19593: PUSH
19594: LD_STRING -1-Laser
19596: STR
19597: PPUSH
19598: CALL_OW 88
// exit ;
19602: GO 19750
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19604: LD_VAR 0 1
19608: PUSH
19609: LD_INT 7
19611: EQUAL
19612: IFFALSE 19629
19614: PUSH
19615: LD_VAR 0 2
19619: PPUSH
19620: CALL_OW 255
19624: PUSH
19625: LD_INT 1
19627: EQUAL
19628: AND
19629: IFFALSE 19670
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19631: LD_EXP 9
19635: PPUSH
19636: LD_STRING D
19638: PUSH
19639: LD_STRING I
19641: PUSH
19642: LD_STRING J
19644: PUSH
19645: LD_STRING S
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PUSH
19653: LD_EXP 25
19657: ARRAY
19658: STR
19659: PUSH
19660: LD_STRING -1-Materialization
19662: STR
19663: PPUSH
19664: CALL_OW 88
// exit ;
19668: GO 19750
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19670: LD_VAR 0 1
19674: PUSH
19675: LD_INT 25
19677: EQUAL
19678: IFFALSE 19695
19680: PUSH
19681: LD_VAR 0 2
19685: PPUSH
19686: CALL_OW 255
19690: PUSH
19691: LD_INT 1
19693: EQUAL
19694: AND
19695: IFFALSE 19736
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19697: LD_EXP 9
19701: PPUSH
19702: LD_STRING D
19704: PUSH
19705: LD_STRING I
19707: PUSH
19708: LD_STRING J
19710: PUSH
19711: LD_STRING S
19713: PUSH
19714: EMPTY
19715: LIST
19716: LIST
19717: LIST
19718: PUSH
19719: LD_EXP 25
19723: ARRAY
19724: STR
19725: PUSH
19726: LD_STRING -1-Rocket
19728: STR
19729: PPUSH
19730: CALL_OW 88
// exit ;
19734: GO 19750
// end ; MCE_ResearchComplete ( tech , lab ) ;
19736: LD_VAR 0 1
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: CALL 91241 0 2
// end ;
19750: PPOPN 2
19752: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19753: LD_VAR 0 1
19757: PPUSH
19758: LD_VAR 0 2
19762: PPUSH
19763: LD_VAR 0 3
19767: PPUSH
19768: LD_VAR 0 4
19772: PPUSH
19773: LD_VAR 0 5
19777: PPUSH
19778: CALL 90859 0 5
// end ;
19782: PPOPN 5
19784: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19785: LD_VAR 0 1
19789: PPUSH
19790: LD_VAR 0 2
19794: PPUSH
19795: CALL 110715 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19799: LD_VAR 0 1
19803: PPUSH
19804: LD_VAR 0 2
19808: PPUSH
19809: CALL 90408 0 2
// end ;
19813: PPOPN 2
19815: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19816: LD_VAR 0 1
19820: PPUSH
19821: LD_VAR 0 2
19825: PPUSH
19826: LD_VAR 0 3
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: CALL 90240 0 4
// end ;
19840: PPOPN 4
19842: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19843: LD_VAR 0 1
19847: PPUSH
19848: LD_VAR 0 2
19852: PPUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: CALL 90013 0 3
// end ;
19862: PPOPN 3
19864: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19865: LD_VAR 0 1
19869: PPUSH
19870: LD_VAR 0 2
19874: PPUSH
19875: CALL 89896 0 2
// end ;
19879: PPOPN 2
19881: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19882: LD_VAR 0 1
19886: PPUSH
19887: LD_VAR 0 2
19891: PPUSH
19892: CALL 94204 0 2
// end ;
19896: PPOPN 2
19898: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19899: LD_VAR 0 1
19903: PPUSH
19904: LD_VAR 0 2
19908: PPUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_VAR 0 4
19918: PPUSH
19919: CALL 94428 0 4
// end ;
19923: PPOPN 4
19925: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19926: LD_VAR 0 1
19930: PPUSH
19931: LD_VAR 0 2
19935: PPUSH
19936: CALL 89703 0 2
// end ;
19940: PPOPN 2
19942: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19943: LD_VAR 0 1
19947: PPUSH
19948: CALL 110699 0 1
// end ; end_of_file
19952: PPOPN 1
19954: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19955: LD_INT 0
19957: PPUSH
19958: PPUSH
// if exist_mode then
19959: LD_VAR 0 2
19963: IFFALSE 20009
// begin unit := CreateCharacter ( prefix & ident ) ;
19965: LD_ADDR_VAR 0 5
19969: PUSH
19970: LD_VAR 0 3
19974: PUSH
19975: LD_VAR 0 1
19979: STR
19980: PPUSH
19981: CALL_OW 34
19985: ST_TO_ADDR
// if unit then
19986: LD_VAR 0 5
19990: IFFALSE 20007
// DeleteCharacters ( prefix & ident ) ;
19992: LD_VAR 0 3
19996: PUSH
19997: LD_VAR 0 1
20001: STR
20002: PPUSH
20003: CALL_OW 40
// end else
20007: GO 20024
// unit := NewCharacter ( ident ) ;
20009: LD_ADDR_VAR 0 5
20013: PUSH
20014: LD_VAR 0 1
20018: PPUSH
20019: CALL_OW 25
20023: ST_TO_ADDR
// result := unit ;
20024: LD_ADDR_VAR 0 4
20028: PUSH
20029: LD_VAR 0 5
20033: ST_TO_ADDR
// end ;
20034: LD_VAR 0 4
20038: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
20039: LD_INT 0
20041: PPUSH
20042: PPUSH
// if exist_mode then
20043: LD_VAR 0 2
20047: IFFALSE 20072
// unit := CreateCharacter ( prefix & ident ) else
20049: LD_ADDR_VAR 0 5
20053: PUSH
20054: LD_VAR 0 3
20058: PUSH
20059: LD_VAR 0 1
20063: STR
20064: PPUSH
20065: CALL_OW 34
20069: ST_TO_ADDR
20070: GO 20087
// unit := NewCharacter ( ident ) ;
20072: LD_ADDR_VAR 0 5
20076: PUSH
20077: LD_VAR 0 1
20081: PPUSH
20082: CALL_OW 25
20086: ST_TO_ADDR
// result := unit ;
20087: LD_ADDR_VAR 0 4
20091: PUSH
20092: LD_VAR 0 5
20096: ST_TO_ADDR
// end ;
20097: LD_VAR 0 4
20101: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
20102: LD_INT 0
20104: PPUSH
20105: PPUSH
// if not side or not nation then
20106: LD_VAR 0 1
20110: NOT
20111: IFTRUE 20120
20113: PUSH
20114: LD_VAR 0 2
20118: NOT
20119: OR
20120: IFFALSE 20124
// exit ;
20122: GO 20918
// case nation of nation_american :
20124: LD_VAR 0 2
20128: PUSH
20129: LD_INT 1
20131: DOUBLE
20132: EQUAL
20133: IFTRUE 20137
20135: GO 20359
20137: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
20138: LD_ADDR_VAR 0 4
20142: PUSH
20143: LD_INT 35
20145: PUSH
20146: LD_INT 45
20148: PUSH
20149: LD_INT 46
20151: PUSH
20152: LD_INT 47
20154: PUSH
20155: LD_INT 82
20157: PUSH
20158: LD_INT 83
20160: PUSH
20161: LD_INT 84
20163: PUSH
20164: LD_INT 85
20166: PUSH
20167: LD_INT 86
20169: PUSH
20170: LD_INT 1
20172: PUSH
20173: LD_INT 2
20175: PUSH
20176: LD_INT 6
20178: PUSH
20179: LD_INT 15
20181: PUSH
20182: LD_INT 16
20184: PUSH
20185: LD_INT 7
20187: PUSH
20188: LD_INT 12
20190: PUSH
20191: LD_INT 13
20193: PUSH
20194: LD_INT 10
20196: PUSH
20197: LD_INT 14
20199: PUSH
20200: LD_INT 20
20202: PUSH
20203: LD_INT 21
20205: PUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 25
20211: PUSH
20212: LD_INT 32
20214: PUSH
20215: LD_INT 27
20217: PUSH
20218: LD_INT 36
20220: PUSH
20221: LD_INT 69
20223: PUSH
20224: LD_INT 39
20226: PUSH
20227: LD_INT 34
20229: PUSH
20230: LD_INT 40
20232: PUSH
20233: LD_INT 48
20235: PUSH
20236: LD_INT 49
20238: PUSH
20239: LD_INT 50
20241: PUSH
20242: LD_INT 51
20244: PUSH
20245: LD_INT 52
20247: PUSH
20248: LD_INT 53
20250: PUSH
20251: LD_INT 54
20253: PUSH
20254: LD_INT 55
20256: PUSH
20257: LD_INT 56
20259: PUSH
20260: LD_INT 57
20262: PUSH
20263: LD_INT 58
20265: PUSH
20266: LD_INT 59
20268: PUSH
20269: LD_INT 60
20271: PUSH
20272: LD_INT 61
20274: PUSH
20275: LD_INT 62
20277: PUSH
20278: LD_INT 80
20280: PUSH
20281: LD_INT 82
20283: PUSH
20284: LD_INT 83
20286: PUSH
20287: LD_INT 84
20289: PUSH
20290: LD_INT 85
20292: PUSH
20293: LD_INT 86
20295: PUSH
20296: LD_INT 90
20298: PUSH
20299: LD_INT 93
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: LIST
20306: LIST
20307: LIST
20308: LIST
20309: LIST
20310: LIST
20311: LIST
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: LIST
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: LIST
20349: LIST
20350: LIST
20351: LIST
20352: LIST
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
20357: GO 20840
20359: LD_INT 2
20361: DOUBLE
20362: EQUAL
20363: IFTRUE 20367
20365: GO 20601
20367: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
20368: LD_ADDR_VAR 0 4
20372: PUSH
20373: LD_INT 35
20375: PUSH
20376: LD_INT 45
20378: PUSH
20379: LD_INT 46
20381: PUSH
20382: LD_INT 47
20384: PUSH
20385: LD_INT 82
20387: PUSH
20388: LD_INT 83
20390: PUSH
20391: LD_INT 84
20393: PUSH
20394: LD_INT 85
20396: PUSH
20397: LD_INT 87
20399: PUSH
20400: LD_INT 70
20402: PUSH
20403: LD_INT 1
20405: PUSH
20406: LD_INT 11
20408: PUSH
20409: LD_INT 3
20411: PUSH
20412: LD_INT 4
20414: PUSH
20415: LD_INT 5
20417: PUSH
20418: LD_INT 6
20420: PUSH
20421: LD_INT 15
20423: PUSH
20424: LD_INT 18
20426: PUSH
20427: LD_INT 7
20429: PUSH
20430: LD_INT 17
20432: PUSH
20433: LD_INT 8
20435: PUSH
20436: LD_INT 20
20438: PUSH
20439: LD_INT 21
20441: PUSH
20442: LD_INT 22
20444: PUSH
20445: LD_INT 72
20447: PUSH
20448: LD_INT 26
20450: PUSH
20451: LD_INT 69
20453: PUSH
20454: LD_INT 39
20456: PUSH
20457: LD_INT 40
20459: PUSH
20460: LD_INT 41
20462: PUSH
20463: LD_INT 42
20465: PUSH
20466: LD_INT 43
20468: PUSH
20469: LD_INT 48
20471: PUSH
20472: LD_INT 49
20474: PUSH
20475: LD_INT 50
20477: PUSH
20478: LD_INT 51
20480: PUSH
20481: LD_INT 52
20483: PUSH
20484: LD_INT 53
20486: PUSH
20487: LD_INT 54
20489: PUSH
20490: LD_INT 55
20492: PUSH
20493: LD_INT 56
20495: PUSH
20496: LD_INT 60
20498: PUSH
20499: LD_INT 61
20501: PUSH
20502: LD_INT 62
20504: PUSH
20505: LD_INT 66
20507: PUSH
20508: LD_INT 67
20510: PUSH
20511: LD_INT 68
20513: PUSH
20514: LD_INT 81
20516: PUSH
20517: LD_INT 82
20519: PUSH
20520: LD_INT 83
20522: PUSH
20523: LD_INT 84
20525: PUSH
20526: LD_INT 85
20528: PUSH
20529: LD_INT 87
20531: PUSH
20532: LD_INT 88
20534: PUSH
20535: LD_INT 92
20537: PUSH
20538: LD_INT 94
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: LIST
20555: LIST
20556: LIST
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: ST_TO_ADDR
20599: GO 20840
20601: LD_INT 3
20603: DOUBLE
20604: EQUAL
20605: IFTRUE 20609
20607: GO 20839
20609: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
20610: LD_ADDR_VAR 0 4
20614: PUSH
20615: LD_INT 46
20617: PUSH
20618: LD_INT 47
20620: PUSH
20621: LD_INT 1
20623: PUSH
20624: LD_INT 2
20626: PUSH
20627: LD_INT 82
20629: PUSH
20630: LD_INT 83
20632: PUSH
20633: LD_INT 84
20635: PUSH
20636: LD_INT 85
20638: PUSH
20639: LD_INT 86
20641: PUSH
20642: LD_INT 11
20644: PUSH
20645: LD_INT 9
20647: PUSH
20648: LD_INT 20
20650: PUSH
20651: LD_INT 19
20653: PUSH
20654: LD_INT 21
20656: PUSH
20657: LD_INT 24
20659: PUSH
20660: LD_INT 22
20662: PUSH
20663: LD_INT 25
20665: PUSH
20666: LD_INT 28
20668: PUSH
20669: LD_INT 29
20671: PUSH
20672: LD_INT 30
20674: PUSH
20675: LD_INT 31
20677: PUSH
20678: LD_INT 37
20680: PUSH
20681: LD_INT 38
20683: PUSH
20684: LD_INT 32
20686: PUSH
20687: LD_INT 27
20689: PUSH
20690: LD_INT 33
20692: PUSH
20693: LD_INT 69
20695: PUSH
20696: LD_INT 39
20698: PUSH
20699: LD_INT 34
20701: PUSH
20702: LD_INT 40
20704: PUSH
20705: LD_INT 71
20707: PUSH
20708: LD_INT 23
20710: PUSH
20711: LD_INT 44
20713: PUSH
20714: LD_INT 48
20716: PUSH
20717: LD_INT 49
20719: PUSH
20720: LD_INT 50
20722: PUSH
20723: LD_INT 51
20725: PUSH
20726: LD_INT 52
20728: PUSH
20729: LD_INT 53
20731: PUSH
20732: LD_INT 54
20734: PUSH
20735: LD_INT 55
20737: PUSH
20738: LD_INT 56
20740: PUSH
20741: LD_INT 57
20743: PUSH
20744: LD_INT 58
20746: PUSH
20747: LD_INT 59
20749: PUSH
20750: LD_INT 63
20752: PUSH
20753: LD_INT 64
20755: PUSH
20756: LD_INT 65
20758: PUSH
20759: LD_INT 82
20761: PUSH
20762: LD_INT 83
20764: PUSH
20765: LD_INT 84
20767: PUSH
20768: LD_INT 85
20770: PUSH
20771: LD_INT 86
20773: PUSH
20774: LD_INT 89
20776: PUSH
20777: LD_INT 91
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: LIST
20829: LIST
20830: LIST
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: ST_TO_ADDR
20837: GO 20840
20839: POP
// if state > - 1 and state < 3 then
20840: LD_VAR 0 3
20844: PUSH
20845: LD_INT 1
20847: NEG
20848: GREATER
20849: IFFALSE 20861
20851: PUSH
20852: LD_VAR 0 3
20856: PUSH
20857: LD_INT 3
20859: LESS
20860: AND
20861: IFFALSE 20918
// for i in result do
20863: LD_ADDR_VAR 0 5
20867: PUSH
20868: LD_VAR 0 4
20872: PUSH
20873: FOR_IN
20874: IFFALSE 20916
// if GetTech ( i , side ) <> state then
20876: LD_VAR 0 5
20880: PPUSH
20881: LD_VAR 0 1
20885: PPUSH
20886: CALL_OW 321
20890: PUSH
20891: LD_VAR 0 3
20895: NONEQUAL
20896: IFFALSE 20914
// result := result diff i ;
20898: LD_ADDR_VAR 0 4
20902: PUSH
20903: LD_VAR 0 4
20907: PUSH
20908: LD_VAR 0 5
20912: DIFF
20913: ST_TO_ADDR
20914: GO 20873
20916: POP
20917: POP
// end ;
20918: LD_VAR 0 4
20922: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20923: LD_INT 0
20925: PPUSH
20926: PPUSH
20927: PPUSH
// result := true ;
20928: LD_ADDR_VAR 0 3
20932: PUSH
20933: LD_INT 1
20935: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20936: LD_ADDR_VAR 0 5
20940: PUSH
20941: LD_VAR 0 2
20945: PPUSH
20946: CALL_OW 480
20950: ST_TO_ADDR
// if not tmp then
20951: LD_VAR 0 5
20955: NOT
20956: IFFALSE 20960
// exit ;
20958: GO 21009
// for i in tmp do
20960: LD_ADDR_VAR 0 4
20964: PUSH
20965: LD_VAR 0 5
20969: PUSH
20970: FOR_IN
20971: IFFALSE 21007
// if GetTech ( i , side ) <> state_researched then
20973: LD_VAR 0 4
20977: PPUSH
20978: LD_VAR 0 1
20982: PPUSH
20983: CALL_OW 321
20987: PUSH
20988: LD_INT 2
20990: NONEQUAL
20991: IFFALSE 21005
// begin result := false ;
20993: LD_ADDR_VAR 0 3
20997: PUSH
20998: LD_INT 0
21000: ST_TO_ADDR
// exit ;
21001: POP
21002: POP
21003: GO 21009
// end ;
21005: GO 20970
21007: POP
21008: POP
// end ;
21009: LD_VAR 0 3
21013: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
21014: LD_INT 0
21016: PPUSH
21017: PPUSH
21018: PPUSH
21019: PPUSH
21020: PPUSH
21021: PPUSH
21022: PPUSH
21023: PPUSH
21024: PPUSH
21025: PPUSH
21026: PPUSH
21027: PPUSH
21028: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
21029: LD_VAR 0 1
21033: NOT
21034: IFTRUE 21051
21036: PUSH
21037: LD_VAR 0 1
21041: PPUSH
21042: CALL_OW 257
21046: PUSH
21047: LD_INT 9
21049: NONEQUAL
21050: OR
21051: IFFALSE 21055
// exit ;
21053: GO 21634
// side := GetSide ( unit ) ;
21055: LD_ADDR_VAR 0 9
21059: PUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: CALL_OW 255
21069: ST_TO_ADDR
// tech_space := tech_spacanom ;
21070: LD_ADDR_VAR 0 12
21074: PUSH
21075: LD_INT 29
21077: ST_TO_ADDR
// tech_time := tech_taurad ;
21078: LD_ADDR_VAR 0 13
21082: PUSH
21083: LD_INT 28
21085: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
21086: LD_ADDR_VAR 0 11
21090: PUSH
21091: LD_VAR 0 1
21095: PPUSH
21096: CALL_OW 310
21100: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
21101: LD_VAR 0 11
21105: PPUSH
21106: CALL_OW 247
21110: PUSH
21111: LD_INT 2
21113: EQUAL
21114: IFFALSE 21118
// exit ;
21116: GO 21634
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21118: LD_ADDR_VAR 0 8
21122: PUSH
21123: LD_INT 81
21125: PUSH
21126: LD_VAR 0 9
21130: PUSH
21131: EMPTY
21132: LIST
21133: LIST
21134: PUSH
21135: LD_INT 3
21137: PUSH
21138: LD_INT 21
21140: PUSH
21141: LD_INT 3
21143: PUSH
21144: EMPTY
21145: LIST
21146: LIST
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PUSH
21152: EMPTY
21153: LIST
21154: LIST
21155: PPUSH
21156: CALL_OW 69
21160: ST_TO_ADDR
// if not tmp then
21161: LD_VAR 0 8
21165: NOT
21166: IFFALSE 21170
// exit ;
21168: GO 21634
// if in_unit then
21170: LD_VAR 0 11
21174: IFFALSE 21198
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
21176: LD_ADDR_VAR 0 10
21180: PUSH
21181: LD_VAR 0 8
21185: PPUSH
21186: LD_VAR 0 11
21190: PPUSH
21191: CALL_OW 74
21195: ST_TO_ADDR
21196: GO 21218
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21198: LD_ADDR_VAR 0 10
21202: PUSH
21203: LD_VAR 0 8
21207: PPUSH
21208: LD_VAR 0 1
21212: PPUSH
21213: CALL_OW 74
21217: ST_TO_ADDR
// if not enemy then
21218: LD_VAR 0 10
21222: NOT
21223: IFFALSE 21227
// exit ;
21225: GO 21634
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21227: LD_VAR 0 11
21231: IFFALSE 21253
21233: PUSH
21234: LD_VAR 0 11
21238: PPUSH
21239: LD_VAR 0 10
21243: PPUSH
21244: CALL_OW 296
21248: PUSH
21249: LD_INT 13
21251: GREATER
21252: AND
21253: IFTRUE 21275
21255: PUSH
21256: LD_VAR 0 1
21260: PPUSH
21261: LD_VAR 0 10
21265: PPUSH
21266: CALL_OW 296
21270: PUSH
21271: LD_INT 12
21273: GREATER
21274: OR
21275: IFFALSE 21279
// exit ;
21277: GO 21634
// missile := [ 1 ] ;
21279: LD_ADDR_VAR 0 14
21283: PUSH
21284: LD_INT 1
21286: PUSH
21287: EMPTY
21288: LIST
21289: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21290: LD_VAR 0 9
21294: PPUSH
21295: LD_VAR 0 12
21299: PPUSH
21300: CALL_OW 325
21304: IFFALSE 21333
// missile := Replace ( missile , missile + 1 , 2 ) ;
21306: LD_ADDR_VAR 0 14
21310: PUSH
21311: LD_VAR 0 14
21315: PPUSH
21316: LD_VAR 0 14
21320: PUSH
21321: LD_INT 1
21323: PLUS
21324: PPUSH
21325: LD_INT 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21333: LD_VAR 0 9
21337: PPUSH
21338: LD_VAR 0 13
21342: PPUSH
21343: CALL_OW 325
21347: IFFALSE 21371
21349: PUSH
21350: LD_VAR 0 10
21354: PPUSH
21355: CALL_OW 255
21359: PPUSH
21360: LD_VAR 0 13
21364: PPUSH
21365: CALL_OW 325
21369: NOT
21370: AND
21371: IFFALSE 21400
// missile := Replace ( missile , missile + 1 , 3 ) ;
21373: LD_ADDR_VAR 0 14
21377: PUSH
21378: LD_VAR 0 14
21382: PPUSH
21383: LD_VAR 0 14
21387: PUSH
21388: LD_INT 1
21390: PLUS
21391: PPUSH
21392: LD_INT 3
21394: PPUSH
21395: CALL_OW 1
21399: ST_TO_ADDR
// if missile < 2 then
21400: LD_VAR 0 14
21404: PUSH
21405: LD_INT 2
21407: LESS
21408: IFFALSE 21412
// exit ;
21410: GO 21634
// x := GetX ( enemy ) ;
21412: LD_ADDR_VAR 0 4
21416: PUSH
21417: LD_VAR 0 10
21421: PPUSH
21422: CALL_OW 250
21426: ST_TO_ADDR
// y := GetY ( enemy ) ;
21427: LD_ADDR_VAR 0 5
21431: PUSH
21432: LD_VAR 0 10
21436: PPUSH
21437: CALL_OW 251
21441: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21442: LD_ADDR_VAR 0 6
21446: PUSH
21447: LD_VAR 0 4
21451: PUSH
21452: LD_INT 1
21454: NEG
21455: PPUSH
21456: LD_INT 1
21458: PPUSH
21459: CALL_OW 12
21463: PLUS
21464: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21465: LD_ADDR_VAR 0 7
21469: PUSH
21470: LD_VAR 0 5
21474: PUSH
21475: LD_INT 1
21477: NEG
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 12
21486: PLUS
21487: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21488: LD_VAR 0 6
21492: PPUSH
21493: LD_VAR 0 7
21497: PPUSH
21498: CALL_OW 488
21502: NOT
21503: IFFALSE 21525
// begin _x := x ;
21505: LD_ADDR_VAR 0 6
21509: PUSH
21510: LD_VAR 0 4
21514: ST_TO_ADDR
// _y := y ;
21515: LD_ADDR_VAR 0 7
21519: PUSH
21520: LD_VAR 0 5
21524: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21525: LD_ADDR_VAR 0 3
21529: PUSH
21530: LD_INT 1
21532: PPUSH
21533: LD_VAR 0 14
21537: PPUSH
21538: CALL_OW 12
21542: ST_TO_ADDR
// case i of 1 :
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: DOUBLE
21551: EQUAL
21552: IFTRUE 21556
21554: GO 21573
21556: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21557: LD_VAR 0 1
21561: PPUSH
21562: LD_VAR 0 10
21566: PPUSH
21567: CALL_OW 115
21571: GO 21634
21573: LD_INT 2
21575: DOUBLE
21576: EQUAL
21577: IFTRUE 21581
21579: GO 21603
21581: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21582: LD_VAR 0 1
21586: PPUSH
21587: LD_VAR 0 6
21591: PPUSH
21592: LD_VAR 0 7
21596: PPUSH
21597: CALL_OW 153
21601: GO 21634
21603: LD_INT 3
21605: DOUBLE
21606: EQUAL
21607: IFTRUE 21611
21609: GO 21633
21611: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21612: LD_VAR 0 1
21616: PPUSH
21617: LD_VAR 0 6
21621: PPUSH
21622: LD_VAR 0 7
21626: PPUSH
21627: CALL_OW 154
21631: GO 21634
21633: POP
// end ;
21634: LD_VAR 0 2
21638: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21639: LD_INT 0
21641: PPUSH
21642: PPUSH
21643: PPUSH
21644: PPUSH
21645: PPUSH
21646: PPUSH
// if not unit or not building then
21647: LD_VAR 0 1
21651: NOT
21652: IFTRUE 21661
21654: PUSH
21655: LD_VAR 0 2
21659: NOT
21660: OR
21661: IFFALSE 21665
// exit ;
21663: GO 21823
// x := GetX ( building ) ;
21665: LD_ADDR_VAR 0 5
21669: PUSH
21670: LD_VAR 0 2
21674: PPUSH
21675: CALL_OW 250
21679: ST_TO_ADDR
// y := GetY ( building ) ;
21680: LD_ADDR_VAR 0 6
21684: PUSH
21685: LD_VAR 0 2
21689: PPUSH
21690: CALL_OW 251
21694: ST_TO_ADDR
// for i := 0 to 5 do
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: DOUBLE
21701: LD_INT 0
21703: DEC
21704: ST_TO_ADDR
21705: LD_INT 5
21707: PUSH
21708: FOR_TO
21709: IFFALSE 21821
// begin _x := ShiftX ( x , i , 3 ) ;
21711: LD_ADDR_VAR 0 7
21715: PUSH
21716: LD_VAR 0 5
21720: PPUSH
21721: LD_VAR 0 4
21725: PPUSH
21726: LD_INT 3
21728: PPUSH
21729: CALL_OW 272
21733: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21734: LD_ADDR_VAR 0 8
21738: PUSH
21739: LD_VAR 0 6
21743: PPUSH
21744: LD_VAR 0 4
21748: PPUSH
21749: LD_INT 3
21751: PPUSH
21752: CALL_OW 273
21756: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21757: LD_VAR 0 7
21761: PPUSH
21762: LD_VAR 0 8
21766: PPUSH
21767: CALL_OW 488
21771: NOT
21772: IFFALSE 21776
// continue ;
21774: GO 21708
// if HexInfo ( _x , _y ) = 0 then
21776: LD_VAR 0 7
21780: PPUSH
21781: LD_VAR 0 8
21785: PPUSH
21786: CALL_OW 428
21790: PUSH
21791: LD_INT 0
21793: EQUAL
21794: IFFALSE 21819
// begin ComMoveXY ( unit , _x , _y ) ;
21796: LD_VAR 0 1
21800: PPUSH
21801: LD_VAR 0 7
21805: PPUSH
21806: LD_VAR 0 8
21810: PPUSH
21811: CALL_OW 111
// exit ;
21815: POP
21816: POP
21817: GO 21823
// end ; end ;
21819: GO 21708
21821: POP
21822: POP
// end ;
21823: LD_VAR 0 3
21827: RET
// export function ScanBase ( side , base_area ) ; begin
21828: LD_INT 0
21830: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21831: LD_ADDR_VAR 0 3
21835: PUSH
21836: LD_VAR 0 2
21840: PPUSH
21841: LD_INT 81
21843: PUSH
21844: LD_VAR 0 1
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PPUSH
21853: CALL_OW 70
21857: ST_TO_ADDR
// end ;
21858: LD_VAR 0 3
21862: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21863: LD_INT 0
21865: PPUSH
21866: PPUSH
21867: PPUSH
21868: PPUSH
// result := false ;
21869: LD_ADDR_VAR 0 2
21873: PUSH
21874: LD_INT 0
21876: ST_TO_ADDR
// side := GetSide ( unit ) ;
21877: LD_ADDR_VAR 0 3
21881: PUSH
21882: LD_VAR 0 1
21886: PPUSH
21887: CALL_OW 255
21891: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21892: LD_ADDR_VAR 0 4
21896: PUSH
21897: LD_VAR 0 1
21901: PPUSH
21902: CALL_OW 248
21906: ST_TO_ADDR
// case nat of 1 :
21907: LD_VAR 0 4
21911: PUSH
21912: LD_INT 1
21914: DOUBLE
21915: EQUAL
21916: IFTRUE 21920
21918: GO 21931
21920: POP
// tech := tech_lassight ; 2 :
21921: LD_ADDR_VAR 0 5
21925: PUSH
21926: LD_INT 12
21928: ST_TO_ADDR
21929: GO 21970
21931: LD_INT 2
21933: DOUBLE
21934: EQUAL
21935: IFTRUE 21939
21937: GO 21950
21939: POP
// tech := tech_mortar ; 3 :
21940: LD_ADDR_VAR 0 5
21944: PUSH
21945: LD_INT 41
21947: ST_TO_ADDR
21948: GO 21970
21950: LD_INT 3
21952: DOUBLE
21953: EQUAL
21954: IFTRUE 21958
21956: GO 21969
21958: POP
// tech := tech_bazooka ; end ;
21959: LD_ADDR_VAR 0 5
21963: PUSH
21964: LD_INT 44
21966: ST_TO_ADDR
21967: GO 21970
21969: POP
// if Researched ( side , tech ) then
21970: LD_VAR 0 3
21974: PPUSH
21975: LD_VAR 0 5
21979: PPUSH
21980: CALL_OW 325
21984: IFFALSE 22011
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21986: LD_ADDR_VAR 0 2
21990: PUSH
21991: LD_INT 5
21993: PUSH
21994: LD_INT 8
21996: PUSH
21997: LD_INT 9
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: PUSH
22005: LD_VAR 0 4
22009: ARRAY
22010: ST_TO_ADDR
// end ;
22011: LD_VAR 0 2
22015: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
22016: LD_INT 0
22018: PPUSH
22019: PPUSH
22020: PPUSH
// if not mines then
22021: LD_VAR 0 2
22025: NOT
22026: IFFALSE 22030
// exit ;
22028: GO 22174
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22030: LD_ADDR_VAR 0 5
22034: PUSH
22035: LD_INT 81
22037: PUSH
22038: LD_VAR 0 1
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 3
22049: PUSH
22050: LD_INT 21
22052: PUSH
22053: LD_INT 3
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: PUSH
22060: EMPTY
22061: LIST
22062: LIST
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PPUSH
22068: CALL_OW 69
22072: ST_TO_ADDR
// for i in mines do
22073: LD_ADDR_VAR 0 4
22077: PUSH
22078: LD_VAR 0 2
22082: PUSH
22083: FOR_IN
22084: IFFALSE 22172
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
22086: LD_VAR 0 4
22090: PUSH
22091: LD_INT 1
22093: ARRAY
22094: PPUSH
22095: LD_VAR 0 4
22099: PUSH
22100: LD_INT 2
22102: ARRAY
22103: PPUSH
22104: CALL_OW 458
22108: NOT
22109: IFFALSE 22113
// continue ;
22111: GO 22083
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
22113: LD_VAR 0 4
22117: PUSH
22118: LD_INT 1
22120: ARRAY
22121: PPUSH
22122: LD_VAR 0 4
22126: PUSH
22127: LD_INT 2
22129: ARRAY
22130: PPUSH
22131: CALL_OW 428
22135: PUSH
22136: LD_VAR 0 5
22140: IN
22141: IFFALSE 22170
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
22143: LD_VAR 0 4
22147: PUSH
22148: LD_INT 1
22150: ARRAY
22151: PPUSH
22152: LD_VAR 0 4
22156: PUSH
22157: LD_INT 2
22159: ARRAY
22160: PPUSH
22161: LD_VAR 0 1
22165: PPUSH
22166: CALL_OW 456
// end ;
22170: GO 22083
22172: POP
22173: POP
// end ;
22174: LD_VAR 0 3
22178: RET
// export function Count ( array ) ; begin
22179: LD_INT 0
22181: PPUSH
// result := array + 0 ;
22182: LD_ADDR_VAR 0 2
22186: PUSH
22187: LD_VAR 0 1
22191: PUSH
22192: LD_INT 0
22194: PLUS
22195: ST_TO_ADDR
// end ;
22196: LD_VAR 0 2
22200: RET
// export function IsEmpty ( building ) ; begin
22201: LD_INT 0
22203: PPUSH
// if not building then
22204: LD_VAR 0 1
22208: NOT
22209: IFFALSE 22213
// exit ;
22211: GO 22256
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22213: LD_ADDR_VAR 0 2
22217: PUSH
22218: LD_VAR 0 1
22222: PUSH
22223: LD_INT 22
22225: PUSH
22226: LD_VAR 0 1
22230: PPUSH
22231: CALL_OW 255
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: PUSH
22240: LD_INT 58
22242: PUSH
22243: EMPTY
22244: LIST
22245: PUSH
22246: EMPTY
22247: LIST
22248: LIST
22249: PPUSH
22250: CALL_OW 69
22254: IN
22255: ST_TO_ADDR
// end ;
22256: LD_VAR 0 2
22260: RET
// export function IsNotFull ( building ) ; var places ; begin
22261: LD_INT 0
22263: PPUSH
22264: PPUSH
// if not building then
22265: LD_VAR 0 1
22269: NOT
22270: IFFALSE 22274
// exit ;
22272: GO 22302
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
22274: LD_ADDR_VAR 0 2
22278: PUSH
22279: LD_VAR 0 1
22283: PPUSH
22284: LD_INT 3
22286: PUSH
22287: LD_INT 62
22289: PUSH
22290: EMPTY
22291: LIST
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: PPUSH
22297: CALL_OW 72
22301: ST_TO_ADDR
// end ;
22302: LD_VAR 0 2
22306: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22307: LD_INT 0
22309: PPUSH
22310: PPUSH
22311: PPUSH
22312: PPUSH
// tmp := [ ] ;
22313: LD_ADDR_VAR 0 3
22317: PUSH
22318: EMPTY
22319: ST_TO_ADDR
// list := [ ] ;
22320: LD_ADDR_VAR 0 5
22324: PUSH
22325: EMPTY
22326: ST_TO_ADDR
// for i = 16 to 25 do
22327: LD_ADDR_VAR 0 4
22331: PUSH
22332: DOUBLE
22333: LD_INT 16
22335: DEC
22336: ST_TO_ADDR
22337: LD_INT 25
22339: PUSH
22340: FOR_TO
22341: IFFALSE 22414
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22343: LD_ADDR_VAR 0 3
22347: PUSH
22348: LD_VAR 0 3
22352: PUSH
22353: LD_INT 22
22355: PUSH
22356: LD_VAR 0 1
22360: PPUSH
22361: CALL_OW 255
22365: PUSH
22366: EMPTY
22367: LIST
22368: LIST
22369: PUSH
22370: LD_INT 91
22372: PUSH
22373: LD_VAR 0 1
22377: PUSH
22378: LD_INT 6
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: PUSH
22386: LD_INT 30
22388: PUSH
22389: LD_VAR 0 4
22393: PUSH
22394: EMPTY
22395: LIST
22396: LIST
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: LIST
22402: PUSH
22403: EMPTY
22404: LIST
22405: PPUSH
22406: CALL_OW 69
22410: ADD
22411: ST_TO_ADDR
22412: GO 22340
22414: POP
22415: POP
// for i = 1 to tmp do
22416: LD_ADDR_VAR 0 4
22420: PUSH
22421: DOUBLE
22422: LD_INT 1
22424: DEC
22425: ST_TO_ADDR
22426: LD_VAR 0 3
22430: PUSH
22431: FOR_TO
22432: IFFALSE 22520
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_VAR 0 5
22443: PUSH
22444: LD_VAR 0 3
22448: PUSH
22449: LD_VAR 0 4
22453: ARRAY
22454: PPUSH
22455: CALL_OW 266
22459: PUSH
22460: LD_VAR 0 3
22464: PUSH
22465: LD_VAR 0 4
22469: ARRAY
22470: PPUSH
22471: CALL_OW 250
22475: PUSH
22476: LD_VAR 0 3
22480: PUSH
22481: LD_VAR 0 4
22485: ARRAY
22486: PPUSH
22487: CALL_OW 251
22491: PUSH
22492: LD_VAR 0 3
22496: PUSH
22497: LD_VAR 0 4
22501: ARRAY
22502: PPUSH
22503: CALL_OW 254
22507: PUSH
22508: EMPTY
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: PUSH
22514: EMPTY
22515: LIST
22516: ADD
22517: ST_TO_ADDR
22518: GO 22431
22520: POP
22521: POP
// result := list ;
22522: LD_ADDR_VAR 0 2
22526: PUSH
22527: LD_VAR 0 5
22531: ST_TO_ADDR
// end ;
22532: LD_VAR 0 2
22536: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22537: LD_INT 0
22539: PPUSH
22540: PPUSH
22541: PPUSH
22542: PPUSH
22543: PPUSH
22544: PPUSH
22545: PPUSH
// if not factory then
22546: LD_VAR 0 1
22550: NOT
22551: IFFALSE 22555
// exit ;
22553: GO 23158
// if control = control_apeman then
22555: LD_VAR 0 4
22559: PUSH
22560: LD_INT 5
22562: EQUAL
22563: IFFALSE 22672
// begin tmp := UnitsInside ( factory ) ;
22565: LD_ADDR_VAR 0 8
22569: PUSH
22570: LD_VAR 0 1
22574: PPUSH
22575: CALL_OW 313
22579: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22580: LD_VAR 0 8
22584: PPUSH
22585: LD_INT 25
22587: PUSH
22588: LD_INT 12
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: PPUSH
22595: CALL_OW 72
22599: NOT
22600: IFFALSE 22610
// control := control_manual ;
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_INT 1
22609: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22610: LD_ADDR_VAR 0 8
22614: PUSH
22615: LD_VAR 0 1
22619: PPUSH
22620: CALL 22307 0 1
22624: ST_TO_ADDR
// if tmp then
22625: LD_VAR 0 8
22629: IFFALSE 22672
// begin for i in tmp do
22631: LD_ADDR_VAR 0 7
22635: PUSH
22636: LD_VAR 0 8
22640: PUSH
22641: FOR_IN
22642: IFFALSE 22670
// if i [ 1 ] = b_ext_radio then
22644: LD_VAR 0 7
22648: PUSH
22649: LD_INT 1
22651: ARRAY
22652: PUSH
22653: LD_INT 22
22655: EQUAL
22656: IFFALSE 22668
// begin control := control_remote ;
22658: LD_ADDR_VAR 0 4
22662: PUSH
22663: LD_INT 2
22665: ST_TO_ADDR
// break ;
22666: GO 22670
// end ;
22668: GO 22641
22670: POP
22671: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22672: LD_VAR 0 1
22676: PPUSH
22677: LD_VAR 0 2
22681: PPUSH
22682: LD_VAR 0 3
22686: PPUSH
22687: LD_VAR 0 4
22691: PPUSH
22692: LD_VAR 0 5
22696: PPUSH
22697: CALL_OW 448
22701: IFFALSE 22736
// begin result := [ chassis , engine , control , weapon ] ;
22703: LD_ADDR_VAR 0 6
22707: PUSH
22708: LD_VAR 0 2
22712: PUSH
22713: LD_VAR 0 3
22717: PUSH
22718: LD_VAR 0 4
22722: PUSH
22723: LD_VAR 0 5
22727: PUSH
22728: EMPTY
22729: LIST
22730: LIST
22731: LIST
22732: LIST
22733: ST_TO_ADDR
// exit ;
22734: GO 23158
// end ; _chassis := AvailableChassisList ( factory ) ;
22736: LD_ADDR_VAR 0 9
22740: PUSH
22741: LD_VAR 0 1
22745: PPUSH
22746: CALL_OW 475
22750: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22751: LD_ADDR_VAR 0 11
22755: PUSH
22756: LD_VAR 0 1
22760: PPUSH
22761: CALL_OW 476
22765: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22766: LD_ADDR_VAR 0 12
22770: PUSH
22771: LD_VAR 0 1
22775: PPUSH
22776: CALL_OW 477
22780: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22781: LD_ADDR_VAR 0 10
22785: PUSH
22786: LD_VAR 0 1
22790: PPUSH
22791: CALL_OW 478
22795: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22796: LD_VAR 0 9
22800: NOT
22801: IFTRUE 22810
22803: PUSH
22804: LD_VAR 0 11
22808: NOT
22809: OR
22810: IFTRUE 22819
22812: PUSH
22813: LD_VAR 0 12
22817: NOT
22818: OR
22819: IFTRUE 22828
22821: PUSH
22822: LD_VAR 0 10
22826: NOT
22827: OR
22828: IFFALSE 22863
// begin result := [ chassis , engine , control , weapon ] ;
22830: LD_ADDR_VAR 0 6
22834: PUSH
22835: LD_VAR 0 2
22839: PUSH
22840: LD_VAR 0 3
22844: PUSH
22845: LD_VAR 0 4
22849: PUSH
22850: LD_VAR 0 5
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: ST_TO_ADDR
// exit ;
22861: GO 23158
// end ; if not chassis in _chassis then
22863: LD_VAR 0 2
22867: PUSH
22868: LD_VAR 0 9
22872: IN
22873: NOT
22874: IFFALSE 22900
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22876: LD_ADDR_VAR 0 2
22880: PUSH
22881: LD_VAR 0 9
22885: PUSH
22886: LD_INT 1
22888: PPUSH
22889: LD_VAR 0 9
22893: PPUSH
22894: CALL_OW 12
22898: ARRAY
22899: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22900: LD_VAR 0 2
22904: PPUSH
22905: LD_VAR 0 3
22909: PPUSH
22910: CALL 23163 0 2
22914: NOT
22915: IFFALSE 22976
// repeat engine := _engine [ 1 ] ;
22917: LD_ADDR_VAR 0 3
22921: PUSH
22922: LD_VAR 0 11
22926: PUSH
22927: LD_INT 1
22929: ARRAY
22930: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22931: LD_ADDR_VAR 0 11
22935: PUSH
22936: LD_VAR 0 11
22940: PPUSH
22941: LD_INT 1
22943: PPUSH
22944: CALL_OW 3
22948: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22949: LD_VAR 0 2
22953: PPUSH
22954: LD_VAR 0 3
22958: PPUSH
22959: CALL 23163 0 2
22963: IFTRUE 22974
22965: PUSH
22966: LD_VAR 0 11
22970: PUSH
22971: EMPTY
22972: EQUAL
22973: OR
22974: IFFALSE 22917
// if not control in _control then
22976: LD_VAR 0 4
22980: PUSH
22981: LD_VAR 0 12
22985: IN
22986: NOT
22987: IFFALSE 23013
// control := _control [ rand ( 1 , _control ) ] ;
22989: LD_ADDR_VAR 0 4
22993: PUSH
22994: LD_VAR 0 12
22998: PUSH
22999: LD_INT 1
23001: PPUSH
23002: LD_VAR 0 12
23006: PPUSH
23007: CALL_OW 12
23011: ARRAY
23012: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
23013: LD_VAR 0 2
23017: PPUSH
23018: LD_VAR 0 5
23022: PPUSH
23023: CALL 23385 0 2
23027: NOT
23028: IFFALSE 23089
// repeat weapon := _weapon [ 1 ] ;
23030: LD_ADDR_VAR 0 5
23034: PUSH
23035: LD_VAR 0 10
23039: PUSH
23040: LD_INT 1
23042: ARRAY
23043: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23044: LD_ADDR_VAR 0 10
23048: PUSH
23049: LD_VAR 0 10
23053: PPUSH
23054: LD_INT 1
23056: PPUSH
23057: CALL_OW 3
23061: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23062: LD_VAR 0 2
23066: PPUSH
23067: LD_VAR 0 5
23071: PPUSH
23072: CALL 23385 0 2
23076: IFTRUE 23087
23078: PUSH
23079: LD_VAR 0 10
23083: PUSH
23084: EMPTY
23085: EQUAL
23086: OR
23087: IFFALSE 23030
// result := [ ] ;
23089: LD_ADDR_VAR 0 6
23093: PUSH
23094: EMPTY
23095: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23096: LD_VAR 0 1
23100: PPUSH
23101: LD_VAR 0 2
23105: PPUSH
23106: LD_VAR 0 3
23110: PPUSH
23111: LD_VAR 0 4
23115: PPUSH
23116: LD_VAR 0 5
23120: PPUSH
23121: CALL_OW 448
23125: IFFALSE 23158
// result := [ chassis , engine , control , weapon ] ;
23127: LD_ADDR_VAR 0 6
23131: PUSH
23132: LD_VAR 0 2
23136: PUSH
23137: LD_VAR 0 3
23141: PUSH
23142: LD_VAR 0 4
23146: PUSH
23147: LD_VAR 0 5
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: LIST
23156: LIST
23157: ST_TO_ADDR
// end ;
23158: LD_VAR 0 6
23162: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23163: LD_INT 0
23165: PPUSH
// if not chassis or not engine then
23166: LD_VAR 0 1
23170: NOT
23171: IFTRUE 23180
23173: PUSH
23174: LD_VAR 0 2
23178: NOT
23179: OR
23180: IFFALSE 23184
// exit ;
23182: GO 23380
// case engine of engine_solar :
23184: LD_VAR 0 2
23188: PUSH
23189: LD_INT 2
23191: DOUBLE
23192: EQUAL
23193: IFTRUE 23197
23195: GO 23235
23197: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23198: LD_ADDR_VAR 0 3
23202: PUSH
23203: LD_INT 11
23205: PUSH
23206: LD_INT 12
23208: PUSH
23209: LD_INT 13
23211: PUSH
23212: LD_INT 14
23214: PUSH
23215: LD_INT 1
23217: PUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 3
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: ST_TO_ADDR
23233: GO 23364
23235: LD_INT 1
23237: DOUBLE
23238: EQUAL
23239: IFTRUE 23243
23241: GO 23305
23243: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23244: LD_ADDR_VAR 0 3
23248: PUSH
23249: LD_INT 11
23251: PUSH
23252: LD_INT 12
23254: PUSH
23255: LD_INT 13
23257: PUSH
23258: LD_INT 14
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: LD_INT 2
23266: PUSH
23267: LD_INT 3
23269: PUSH
23270: LD_INT 4
23272: PUSH
23273: LD_INT 5
23275: PUSH
23276: LD_INT 21
23278: PUSH
23279: LD_INT 23
23281: PUSH
23282: LD_INT 22
23284: PUSH
23285: LD_INT 24
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: LIST
23302: ST_TO_ADDR
23303: GO 23364
23305: LD_INT 3
23307: DOUBLE
23308: EQUAL
23309: IFTRUE 23313
23311: GO 23363
23313: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_INT 13
23321: PUSH
23322: LD_INT 14
23324: PUSH
23325: LD_INT 2
23327: PUSH
23328: LD_INT 3
23330: PUSH
23331: LD_INT 4
23333: PUSH
23334: LD_INT 5
23336: PUSH
23337: LD_INT 21
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_INT 23
23345: PUSH
23346: LD_INT 24
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: LIST
23356: LIST
23357: LIST
23358: LIST
23359: LIST
23360: ST_TO_ADDR
23361: GO 23364
23363: POP
// result := ( chassis in result ) ;
23364: LD_ADDR_VAR 0 3
23368: PUSH
23369: LD_VAR 0 1
23373: PUSH
23374: LD_VAR 0 3
23378: IN
23379: ST_TO_ADDR
// end ;
23380: LD_VAR 0 3
23384: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23385: LD_INT 0
23387: PPUSH
// if not chassis or not weapon then
23388: LD_VAR 0 1
23392: NOT
23393: IFTRUE 23402
23395: PUSH
23396: LD_VAR 0 2
23400: NOT
23401: OR
23402: IFFALSE 23406
// exit ;
23404: GO 24500
// case weapon of us_machine_gun :
23406: LD_VAR 0 2
23410: PUSH
23411: LD_INT 2
23413: DOUBLE
23414: EQUAL
23415: IFTRUE 23419
23417: GO 23449
23419: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23420: LD_ADDR_VAR 0 3
23424: PUSH
23425: LD_INT 1
23427: PUSH
23428: LD_INT 2
23430: PUSH
23431: LD_INT 3
23433: PUSH
23434: LD_INT 4
23436: PUSH
23437: LD_INT 5
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: ST_TO_ADDR
23447: GO 24484
23449: LD_INT 3
23451: DOUBLE
23452: EQUAL
23453: IFTRUE 23457
23455: GO 23487
23457: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23458: LD_ADDR_VAR 0 3
23462: PUSH
23463: LD_INT 1
23465: PUSH
23466: LD_INT 2
23468: PUSH
23469: LD_INT 3
23471: PUSH
23472: LD_INT 4
23474: PUSH
23475: LD_INT 5
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: LIST
23482: LIST
23483: LIST
23484: ST_TO_ADDR
23485: GO 24484
23487: LD_INT 11
23489: DOUBLE
23490: EQUAL
23491: IFTRUE 23495
23493: GO 23525
23495: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23496: LD_ADDR_VAR 0 3
23500: PUSH
23501: LD_INT 1
23503: PUSH
23504: LD_INT 2
23506: PUSH
23507: LD_INT 3
23509: PUSH
23510: LD_INT 4
23512: PUSH
23513: LD_INT 5
23515: PUSH
23516: EMPTY
23517: LIST
23518: LIST
23519: LIST
23520: LIST
23521: LIST
23522: ST_TO_ADDR
23523: GO 24484
23525: LD_INT 4
23527: DOUBLE
23528: EQUAL
23529: IFTRUE 23533
23531: GO 23559
23533: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23534: LD_ADDR_VAR 0 3
23538: PUSH
23539: LD_INT 2
23541: PUSH
23542: LD_INT 3
23544: PUSH
23545: LD_INT 4
23547: PUSH
23548: LD_INT 5
23550: PUSH
23551: EMPTY
23552: LIST
23553: LIST
23554: LIST
23555: LIST
23556: ST_TO_ADDR
23557: GO 24484
23559: LD_INT 5
23561: DOUBLE
23562: EQUAL
23563: IFTRUE 23567
23565: GO 23593
23567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23568: LD_ADDR_VAR 0 3
23572: PUSH
23573: LD_INT 2
23575: PUSH
23576: LD_INT 3
23578: PUSH
23579: LD_INT 4
23581: PUSH
23582: LD_INT 5
23584: PUSH
23585: EMPTY
23586: LIST
23587: LIST
23588: LIST
23589: LIST
23590: ST_TO_ADDR
23591: GO 24484
23593: LD_INT 9
23595: DOUBLE
23596: EQUAL
23597: IFTRUE 23601
23599: GO 23627
23601: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23602: LD_ADDR_VAR 0 3
23606: PUSH
23607: LD_INT 2
23609: PUSH
23610: LD_INT 3
23612: PUSH
23613: LD_INT 4
23615: PUSH
23616: LD_INT 5
23618: PUSH
23619: EMPTY
23620: LIST
23621: LIST
23622: LIST
23623: LIST
23624: ST_TO_ADDR
23625: GO 24484
23627: LD_INT 7
23629: DOUBLE
23630: EQUAL
23631: IFTRUE 23635
23633: GO 23661
23635: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23636: LD_ADDR_VAR 0 3
23640: PUSH
23641: LD_INT 2
23643: PUSH
23644: LD_INT 3
23646: PUSH
23647: LD_INT 4
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: ST_TO_ADDR
23659: GO 24484
23661: LD_INT 12
23663: DOUBLE
23664: EQUAL
23665: IFTRUE 23669
23667: GO 23695
23669: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23670: LD_ADDR_VAR 0 3
23674: PUSH
23675: LD_INT 2
23677: PUSH
23678: LD_INT 3
23680: PUSH
23681: LD_INT 4
23683: PUSH
23684: LD_INT 5
23686: PUSH
23687: EMPTY
23688: LIST
23689: LIST
23690: LIST
23691: LIST
23692: ST_TO_ADDR
23693: GO 24484
23695: LD_INT 13
23697: DOUBLE
23698: EQUAL
23699: IFTRUE 23703
23701: GO 23729
23703: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23704: LD_ADDR_VAR 0 3
23708: PUSH
23709: LD_INT 2
23711: PUSH
23712: LD_INT 3
23714: PUSH
23715: LD_INT 4
23717: PUSH
23718: LD_INT 5
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: LIST
23725: LIST
23726: ST_TO_ADDR
23727: GO 24484
23729: LD_INT 14
23731: DOUBLE
23732: EQUAL
23733: IFTRUE 23737
23735: GO 23755
23737: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23738: LD_ADDR_VAR 0 3
23742: PUSH
23743: LD_INT 4
23745: PUSH
23746: LD_INT 5
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: ST_TO_ADDR
23753: GO 24484
23755: LD_INT 6
23757: DOUBLE
23758: EQUAL
23759: IFTRUE 23763
23761: GO 23781
23763: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23764: LD_ADDR_VAR 0 3
23768: PUSH
23769: LD_INT 4
23771: PUSH
23772: LD_INT 5
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: ST_TO_ADDR
23779: GO 24484
23781: LD_INT 10
23783: DOUBLE
23784: EQUAL
23785: IFTRUE 23789
23787: GO 23807
23789: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23790: LD_ADDR_VAR 0 3
23794: PUSH
23795: LD_INT 4
23797: PUSH
23798: LD_INT 5
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: ST_TO_ADDR
23805: GO 24484
23807: LD_INT 22
23809: DOUBLE
23810: EQUAL
23811: IFTRUE 23815
23813: GO 23841
23815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23816: LD_ADDR_VAR 0 3
23820: PUSH
23821: LD_INT 11
23823: PUSH
23824: LD_INT 12
23826: PUSH
23827: LD_INT 13
23829: PUSH
23830: LD_INT 14
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: ST_TO_ADDR
23839: GO 24484
23841: LD_INT 23
23843: DOUBLE
23844: EQUAL
23845: IFTRUE 23849
23847: GO 23875
23849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23850: LD_ADDR_VAR 0 3
23854: PUSH
23855: LD_INT 11
23857: PUSH
23858: LD_INT 12
23860: PUSH
23861: LD_INT 13
23863: PUSH
23864: LD_INT 14
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: ST_TO_ADDR
23873: GO 24484
23875: LD_INT 24
23877: DOUBLE
23878: EQUAL
23879: IFTRUE 23883
23881: GO 23909
23883: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23884: LD_ADDR_VAR 0 3
23888: PUSH
23889: LD_INT 11
23891: PUSH
23892: LD_INT 12
23894: PUSH
23895: LD_INT 13
23897: PUSH
23898: LD_INT 14
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: ST_TO_ADDR
23907: GO 24484
23909: LD_INT 30
23911: DOUBLE
23912: EQUAL
23913: IFTRUE 23917
23915: GO 23943
23917: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23918: LD_ADDR_VAR 0 3
23922: PUSH
23923: LD_INT 11
23925: PUSH
23926: LD_INT 12
23928: PUSH
23929: LD_INT 13
23931: PUSH
23932: LD_INT 14
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: ST_TO_ADDR
23941: GO 24484
23943: LD_INT 25
23945: DOUBLE
23946: EQUAL
23947: IFTRUE 23951
23949: GO 23969
23951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23952: LD_ADDR_VAR 0 3
23956: PUSH
23957: LD_INT 13
23959: PUSH
23960: LD_INT 14
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: ST_TO_ADDR
23967: GO 24484
23969: LD_INT 27
23971: DOUBLE
23972: EQUAL
23973: IFTRUE 23977
23975: GO 23995
23977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23978: LD_ADDR_VAR 0 3
23982: PUSH
23983: LD_INT 13
23985: PUSH
23986: LD_INT 14
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: ST_TO_ADDR
23993: GO 24484
23995: LD_INT 92
23997: DOUBLE
23998: EQUAL
23999: IFTRUE 24003
24001: GO 24029
24003: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
24004: LD_ADDR_VAR 0 3
24008: PUSH
24009: LD_INT 11
24011: PUSH
24012: LD_INT 12
24014: PUSH
24015: LD_INT 13
24017: PUSH
24018: LD_INT 14
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: LIST
24025: LIST
24026: ST_TO_ADDR
24027: GO 24484
24029: LD_INT 28
24031: DOUBLE
24032: EQUAL
24033: IFTRUE 24037
24035: GO 24055
24037: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24038: LD_ADDR_VAR 0 3
24042: PUSH
24043: LD_INT 13
24045: PUSH
24046: LD_INT 14
24048: PUSH
24049: EMPTY
24050: LIST
24051: LIST
24052: ST_TO_ADDR
24053: GO 24484
24055: LD_INT 29
24057: DOUBLE
24058: EQUAL
24059: IFTRUE 24063
24061: GO 24081
24063: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24064: LD_ADDR_VAR 0 3
24068: PUSH
24069: LD_INT 13
24071: PUSH
24072: LD_INT 14
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: ST_TO_ADDR
24079: GO 24484
24081: LD_INT 31
24083: DOUBLE
24084: EQUAL
24085: IFTRUE 24089
24087: GO 24107
24089: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24090: LD_ADDR_VAR 0 3
24094: PUSH
24095: LD_INT 13
24097: PUSH
24098: LD_INT 14
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: ST_TO_ADDR
24105: GO 24484
24107: LD_INT 26
24109: DOUBLE
24110: EQUAL
24111: IFTRUE 24115
24113: GO 24133
24115: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24116: LD_ADDR_VAR 0 3
24120: PUSH
24121: LD_INT 13
24123: PUSH
24124: LD_INT 14
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: ST_TO_ADDR
24131: GO 24484
24133: LD_INT 42
24135: DOUBLE
24136: EQUAL
24137: IFTRUE 24141
24139: GO 24167
24141: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24142: LD_ADDR_VAR 0 3
24146: PUSH
24147: LD_INT 21
24149: PUSH
24150: LD_INT 22
24152: PUSH
24153: LD_INT 23
24155: PUSH
24156: LD_INT 24
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: ST_TO_ADDR
24165: GO 24484
24167: LD_INT 43
24169: DOUBLE
24170: EQUAL
24171: IFTRUE 24175
24173: GO 24201
24175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24176: LD_ADDR_VAR 0 3
24180: PUSH
24181: LD_INT 21
24183: PUSH
24184: LD_INT 22
24186: PUSH
24187: LD_INT 23
24189: PUSH
24190: LD_INT 24
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: LIST
24197: LIST
24198: ST_TO_ADDR
24199: GO 24484
24201: LD_INT 44
24203: DOUBLE
24204: EQUAL
24205: IFTRUE 24209
24207: GO 24235
24209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24210: LD_ADDR_VAR 0 3
24214: PUSH
24215: LD_INT 21
24217: PUSH
24218: LD_INT 22
24220: PUSH
24221: LD_INT 23
24223: PUSH
24224: LD_INT 24
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: ST_TO_ADDR
24233: GO 24484
24235: LD_INT 45
24237: DOUBLE
24238: EQUAL
24239: IFTRUE 24243
24241: GO 24269
24243: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24244: LD_ADDR_VAR 0 3
24248: PUSH
24249: LD_INT 21
24251: PUSH
24252: LD_INT 22
24254: PUSH
24255: LD_INT 23
24257: PUSH
24258: LD_INT 24
24260: PUSH
24261: EMPTY
24262: LIST
24263: LIST
24264: LIST
24265: LIST
24266: ST_TO_ADDR
24267: GO 24484
24269: LD_INT 49
24271: DOUBLE
24272: EQUAL
24273: IFTRUE 24277
24275: GO 24303
24277: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24278: LD_ADDR_VAR 0 3
24282: PUSH
24283: LD_INT 21
24285: PUSH
24286: LD_INT 22
24288: PUSH
24289: LD_INT 23
24291: PUSH
24292: LD_INT 24
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: ST_TO_ADDR
24301: GO 24484
24303: LD_INT 51
24305: DOUBLE
24306: EQUAL
24307: IFTRUE 24311
24309: GO 24337
24311: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24312: LD_ADDR_VAR 0 3
24316: PUSH
24317: LD_INT 21
24319: PUSH
24320: LD_INT 22
24322: PUSH
24323: LD_INT 23
24325: PUSH
24326: LD_INT 24
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: LIST
24333: LIST
24334: ST_TO_ADDR
24335: GO 24484
24337: LD_INT 52
24339: DOUBLE
24340: EQUAL
24341: IFTRUE 24345
24343: GO 24371
24345: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24346: LD_ADDR_VAR 0 3
24350: PUSH
24351: LD_INT 21
24353: PUSH
24354: LD_INT 22
24356: PUSH
24357: LD_INT 23
24359: PUSH
24360: LD_INT 24
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: LIST
24367: LIST
24368: ST_TO_ADDR
24369: GO 24484
24371: LD_INT 53
24373: DOUBLE
24374: EQUAL
24375: IFTRUE 24379
24377: GO 24397
24379: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24380: LD_ADDR_VAR 0 3
24384: PUSH
24385: LD_INT 23
24387: PUSH
24388: LD_INT 24
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: ST_TO_ADDR
24395: GO 24484
24397: LD_INT 46
24399: DOUBLE
24400: EQUAL
24401: IFTRUE 24405
24403: GO 24423
24405: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24406: LD_ADDR_VAR 0 3
24410: PUSH
24411: LD_INT 23
24413: PUSH
24414: LD_INT 24
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: ST_TO_ADDR
24421: GO 24484
24423: LD_INT 47
24425: DOUBLE
24426: EQUAL
24427: IFTRUE 24431
24429: GO 24449
24431: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
24432: LD_ADDR_VAR 0 3
24436: PUSH
24437: LD_INT 23
24439: PUSH
24440: LD_INT 24
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: ST_TO_ADDR
24447: GO 24484
24449: LD_INT 98
24451: DOUBLE
24452: EQUAL
24453: IFTRUE 24457
24455: GO 24483
24457: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24458: LD_ADDR_VAR 0 3
24462: PUSH
24463: LD_INT 21
24465: PUSH
24466: LD_INT 22
24468: PUSH
24469: LD_INT 23
24471: PUSH
24472: LD_INT 24
24474: PUSH
24475: EMPTY
24476: LIST
24477: LIST
24478: LIST
24479: LIST
24480: ST_TO_ADDR
24481: GO 24484
24483: POP
// result := ( chassis in result ) ;
24484: LD_ADDR_VAR 0 3
24488: PUSH
24489: LD_VAR 0 1
24493: PUSH
24494: LD_VAR 0 3
24498: IN
24499: ST_TO_ADDR
// end ;
24500: LD_VAR 0 3
24504: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24505: LD_INT 0
24507: PPUSH
24508: PPUSH
24509: PPUSH
24510: PPUSH
24511: PPUSH
24512: PPUSH
24513: PPUSH
// result := array ;
24514: LD_ADDR_VAR 0 5
24518: PUSH
24519: LD_VAR 0 1
24523: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24524: LD_VAR 0 1
24528: NOT
24529: IFTRUE 24538
24531: PUSH
24532: LD_VAR 0 2
24536: NOT
24537: OR
24538: IFTRUE 24547
24540: PUSH
24541: LD_VAR 0 3
24545: NOT
24546: OR
24547: IFTRUE 24561
24549: PUSH
24550: LD_VAR 0 2
24554: PUSH
24555: LD_VAR 0 1
24559: GREATER
24560: OR
24561: IFTRUE 24575
24563: PUSH
24564: LD_VAR 0 3
24568: PUSH
24569: LD_VAR 0 1
24573: GREATER
24574: OR
24575: IFFALSE 24579
// exit ;
24577: GO 24875
// if direction then
24579: LD_VAR 0 4
24583: IFFALSE 24647
// begin d := 1 ;
24585: LD_ADDR_VAR 0 9
24589: PUSH
24590: LD_INT 1
24592: ST_TO_ADDR
// if i_from > i_to then
24593: LD_VAR 0 2
24597: PUSH
24598: LD_VAR 0 3
24602: GREATER
24603: IFFALSE 24629
// length := ( array - i_from ) + i_to else
24605: LD_ADDR_VAR 0 11
24609: PUSH
24610: LD_VAR 0 1
24614: PUSH
24615: LD_VAR 0 2
24619: MINUS
24620: PUSH
24621: LD_VAR 0 3
24625: PLUS
24626: ST_TO_ADDR
24627: GO 24645
// length := i_to - i_from ;
24629: LD_ADDR_VAR 0 11
24633: PUSH
24634: LD_VAR 0 3
24638: PUSH
24639: LD_VAR 0 2
24643: MINUS
24644: ST_TO_ADDR
// end else
24645: GO 24708
// begin d := - 1 ;
24647: LD_ADDR_VAR 0 9
24651: PUSH
24652: LD_INT 1
24654: NEG
24655: ST_TO_ADDR
// if i_from > i_to then
24656: LD_VAR 0 2
24660: PUSH
24661: LD_VAR 0 3
24665: GREATER
24666: IFFALSE 24686
// length := i_from - i_to else
24668: LD_ADDR_VAR 0 11
24672: PUSH
24673: LD_VAR 0 2
24677: PUSH
24678: LD_VAR 0 3
24682: MINUS
24683: ST_TO_ADDR
24684: GO 24708
// length := ( array - i_to ) + i_from ;
24686: LD_ADDR_VAR 0 11
24690: PUSH
24691: LD_VAR 0 1
24695: PUSH
24696: LD_VAR 0 3
24700: MINUS
24701: PUSH
24702: LD_VAR 0 2
24706: PLUS
24707: ST_TO_ADDR
// end ; if not length then
24708: LD_VAR 0 11
24712: NOT
24713: IFFALSE 24717
// exit ;
24715: GO 24875
// tmp := array ;
24717: LD_ADDR_VAR 0 10
24721: PUSH
24722: LD_VAR 0 1
24726: ST_TO_ADDR
// for i = 1 to length do
24727: LD_ADDR_VAR 0 6
24731: PUSH
24732: DOUBLE
24733: LD_INT 1
24735: DEC
24736: ST_TO_ADDR
24737: LD_VAR 0 11
24741: PUSH
24742: FOR_TO
24743: IFFALSE 24863
// begin for j = 1 to array do
24745: LD_ADDR_VAR 0 7
24749: PUSH
24750: DOUBLE
24751: LD_INT 1
24753: DEC
24754: ST_TO_ADDR
24755: LD_VAR 0 1
24759: PUSH
24760: FOR_TO
24761: IFFALSE 24849
// begin k := j + d ;
24763: LD_ADDR_VAR 0 8
24767: PUSH
24768: LD_VAR 0 7
24772: PUSH
24773: LD_VAR 0 9
24777: PLUS
24778: ST_TO_ADDR
// if k > array then
24779: LD_VAR 0 8
24783: PUSH
24784: LD_VAR 0 1
24788: GREATER
24789: IFFALSE 24799
// k := 1 ;
24791: LD_ADDR_VAR 0 8
24795: PUSH
24796: LD_INT 1
24798: ST_TO_ADDR
// if not k then
24799: LD_VAR 0 8
24803: NOT
24804: IFFALSE 24816
// k := array ;
24806: LD_ADDR_VAR 0 8
24810: PUSH
24811: LD_VAR 0 1
24815: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24816: LD_ADDR_VAR 0 10
24820: PUSH
24821: LD_VAR 0 10
24825: PPUSH
24826: LD_VAR 0 8
24830: PPUSH
24831: LD_VAR 0 1
24835: PUSH
24836: LD_VAR 0 7
24840: ARRAY
24841: PPUSH
24842: CALL_OW 1
24846: ST_TO_ADDR
// end ;
24847: GO 24760
24849: POP
24850: POP
// array := tmp ;
24851: LD_ADDR_VAR 0 1
24855: PUSH
24856: LD_VAR 0 10
24860: ST_TO_ADDR
// end ;
24861: GO 24742
24863: POP
24864: POP
// result := array ;
24865: LD_ADDR_VAR 0 5
24869: PUSH
24870: LD_VAR 0 1
24874: ST_TO_ADDR
// end ;
24875: LD_VAR 0 5
24879: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24880: LD_INT 0
24882: PPUSH
24883: PPUSH
// result := 0 ;
24884: LD_ADDR_VAR 0 3
24888: PUSH
24889: LD_INT 0
24891: ST_TO_ADDR
// if not array or not value in array then
24892: LD_VAR 0 1
24896: NOT
24897: IFTRUE 24912
24899: PUSH
24900: LD_VAR 0 2
24904: PUSH
24905: LD_VAR 0 1
24909: IN
24910: NOT
24911: OR
24912: IFFALSE 24916
// exit ;
24914: GO 24970
// for i = 1 to array do
24916: LD_ADDR_VAR 0 4
24920: PUSH
24921: DOUBLE
24922: LD_INT 1
24924: DEC
24925: ST_TO_ADDR
24926: LD_VAR 0 1
24930: PUSH
24931: FOR_TO
24932: IFFALSE 24968
// if value = array [ i ] then
24934: LD_VAR 0 2
24938: PUSH
24939: LD_VAR 0 1
24943: PUSH
24944: LD_VAR 0 4
24948: ARRAY
24949: EQUAL
24950: IFFALSE 24966
// begin result := i ;
24952: LD_ADDR_VAR 0 3
24956: PUSH
24957: LD_VAR 0 4
24961: ST_TO_ADDR
// exit ;
24962: POP
24963: POP
24964: GO 24970
// end ;
24966: GO 24931
24968: POP
24969: POP
// end ;
24970: LD_VAR 0 3
24974: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24975: LD_INT 0
24977: PPUSH
// vc_chassis := chassis ;
24978: LD_ADDR_OWVAR 37
24982: PUSH
24983: LD_VAR 0 1
24987: ST_TO_ADDR
// vc_engine := engine ;
24988: LD_ADDR_OWVAR 39
24992: PUSH
24993: LD_VAR 0 2
24997: ST_TO_ADDR
// vc_control := control ;
24998: LD_ADDR_OWVAR 38
25002: PUSH
25003: LD_VAR 0 3
25007: ST_TO_ADDR
// vc_weapon := weapon ;
25008: LD_ADDR_OWVAR 40
25012: PUSH
25013: LD_VAR 0 4
25017: ST_TO_ADDR
// vc_fuel_battery := fuel ;
25018: LD_ADDR_OWVAR 41
25022: PUSH
25023: LD_VAR 0 5
25027: ST_TO_ADDR
// end ;
25028: LD_VAR 0 6
25032: RET
// export function WantPlant ( unit ) ; var task ; begin
25033: LD_INT 0
25035: PPUSH
25036: PPUSH
// result := false ;
25037: LD_ADDR_VAR 0 2
25041: PUSH
25042: LD_INT 0
25044: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
25045: LD_ADDR_VAR 0 3
25049: PUSH
25050: LD_VAR 0 1
25054: PPUSH
25055: CALL_OW 437
25059: ST_TO_ADDR
// if task then
25060: LD_VAR 0 3
25064: IFFALSE 25092
// if task [ 1 ] [ 1 ] = p then
25066: LD_VAR 0 3
25070: PUSH
25071: LD_INT 1
25073: ARRAY
25074: PUSH
25075: LD_INT 1
25077: ARRAY
25078: PUSH
25079: LD_STRING p
25081: EQUAL
25082: IFFALSE 25092
// result := true ;
25084: LD_ADDR_VAR 0 2
25088: PUSH
25089: LD_INT 1
25091: ST_TO_ADDR
// end ;
25092: LD_VAR 0 2
25096: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25097: LD_INT 0
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
// if pos < 1 then
25103: LD_VAR 0 2
25107: PUSH
25108: LD_INT 1
25110: LESS
25111: IFFALSE 25115
// exit ;
25113: GO 25418
// if pos = 1 then
25115: LD_VAR 0 2
25119: PUSH
25120: LD_INT 1
25122: EQUAL
25123: IFFALSE 25156
// result := Replace ( arr , pos [ 1 ] , value ) else
25125: LD_ADDR_VAR 0 4
25129: PUSH
25130: LD_VAR 0 1
25134: PPUSH
25135: LD_VAR 0 2
25139: PUSH
25140: LD_INT 1
25142: ARRAY
25143: PPUSH
25144: LD_VAR 0 3
25148: PPUSH
25149: CALL_OW 1
25153: ST_TO_ADDR
25154: GO 25418
// begin tmp := arr ;
25156: LD_ADDR_VAR 0 6
25160: PUSH
25161: LD_VAR 0 1
25165: ST_TO_ADDR
// s_arr := [ tmp ] ;
25166: LD_ADDR_VAR 0 7
25170: PUSH
25171: LD_VAR 0 6
25175: PUSH
25176: EMPTY
25177: LIST
25178: ST_TO_ADDR
// for i = 1 to pos - 1 do
25179: LD_ADDR_VAR 0 5
25183: PUSH
25184: DOUBLE
25185: LD_INT 1
25187: DEC
25188: ST_TO_ADDR
25189: LD_VAR 0 2
25193: PUSH
25194: LD_INT 1
25196: MINUS
25197: PUSH
25198: FOR_TO
25199: IFFALSE 25244
// begin tmp := tmp [ pos [ i ] ] ;
25201: LD_ADDR_VAR 0 6
25205: PUSH
25206: LD_VAR 0 6
25210: PUSH
25211: LD_VAR 0 2
25215: PUSH
25216: LD_VAR 0 5
25220: ARRAY
25221: ARRAY
25222: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25223: LD_ADDR_VAR 0 7
25227: PUSH
25228: LD_VAR 0 7
25232: PUSH
25233: LD_VAR 0 6
25237: PUSH
25238: EMPTY
25239: LIST
25240: ADD
25241: ST_TO_ADDR
// end ;
25242: GO 25198
25244: POP
25245: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25246: LD_ADDR_VAR 0 6
25250: PUSH
25251: LD_VAR 0 6
25255: PPUSH
25256: LD_VAR 0 2
25260: PUSH
25261: LD_VAR 0 2
25265: ARRAY
25266: PPUSH
25267: LD_VAR 0 3
25271: PPUSH
25272: CALL_OW 1
25276: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25277: LD_ADDR_VAR 0 7
25281: PUSH
25282: LD_VAR 0 7
25286: PPUSH
25287: LD_VAR 0 7
25291: PPUSH
25292: LD_VAR 0 6
25296: PPUSH
25297: CALL_OW 1
25301: ST_TO_ADDR
// for i = s_arr downto 2 do
25302: LD_ADDR_VAR 0 5
25306: PUSH
25307: DOUBLE
25308: LD_VAR 0 7
25312: INC
25313: ST_TO_ADDR
25314: LD_INT 2
25316: PUSH
25317: FOR_DOWNTO
25318: IFFALSE 25402
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25320: LD_ADDR_VAR 0 6
25324: PUSH
25325: LD_VAR 0 7
25329: PUSH
25330: LD_VAR 0 5
25334: PUSH
25335: LD_INT 1
25337: MINUS
25338: ARRAY
25339: PPUSH
25340: LD_VAR 0 2
25344: PUSH
25345: LD_VAR 0 5
25349: PUSH
25350: LD_INT 1
25352: MINUS
25353: ARRAY
25354: PPUSH
25355: LD_VAR 0 7
25359: PUSH
25360: LD_VAR 0 5
25364: ARRAY
25365: PPUSH
25366: CALL_OW 1
25370: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25371: LD_ADDR_VAR 0 7
25375: PUSH
25376: LD_VAR 0 7
25380: PPUSH
25381: LD_VAR 0 5
25385: PUSH
25386: LD_INT 1
25388: MINUS
25389: PPUSH
25390: LD_VAR 0 6
25394: PPUSH
25395: CALL_OW 1
25399: ST_TO_ADDR
// end ;
25400: GO 25317
25402: POP
25403: POP
// result := s_arr [ 1 ] ;
25404: LD_ADDR_VAR 0 4
25408: PUSH
25409: LD_VAR 0 7
25413: PUSH
25414: LD_INT 1
25416: ARRAY
25417: ST_TO_ADDR
// end ; end ;
25418: LD_VAR 0 4
25422: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25423: LD_INT 0
25425: PPUSH
25426: PPUSH
// if not list then
25427: LD_VAR 0 1
25431: NOT
25432: IFFALSE 25436
// exit ;
25434: GO 25527
// i := list [ pos1 ] ;
25436: LD_ADDR_VAR 0 5
25440: PUSH
25441: LD_VAR 0 1
25445: PUSH
25446: LD_VAR 0 2
25450: ARRAY
25451: ST_TO_ADDR
// if not i then
25452: LD_VAR 0 5
25456: NOT
25457: IFFALSE 25461
// exit ;
25459: GO 25527
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25461: LD_ADDR_VAR 0 1
25465: PUSH
25466: LD_VAR 0 1
25470: PPUSH
25471: LD_VAR 0 2
25475: PPUSH
25476: LD_VAR 0 1
25480: PUSH
25481: LD_VAR 0 3
25485: ARRAY
25486: PPUSH
25487: CALL_OW 1
25491: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25492: LD_ADDR_VAR 0 1
25496: PUSH
25497: LD_VAR 0 1
25501: PPUSH
25502: LD_VAR 0 3
25506: PPUSH
25507: LD_VAR 0 5
25511: PPUSH
25512: CALL_OW 1
25516: ST_TO_ADDR
// result := list ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_VAR 0 1
25526: ST_TO_ADDR
// end ;
25527: LD_VAR 0 4
25531: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25532: LD_INT 0
25534: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25535: LD_ADDR_VAR 0 5
25539: PUSH
25540: LD_VAR 0 1
25544: PPUSH
25545: CALL_OW 250
25549: PPUSH
25550: LD_VAR 0 1
25554: PPUSH
25555: CALL_OW 251
25559: PPUSH
25560: LD_VAR 0 2
25564: PPUSH
25565: LD_VAR 0 3
25569: PPUSH
25570: LD_VAR 0 4
25574: PPUSH
25575: CALL 25957 0 5
25579: ST_TO_ADDR
// end ;
25580: LD_VAR 0 5
25584: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
25585: LD_INT 0
25587: PPUSH
25588: PPUSH
25589: PPUSH
25590: PPUSH
// if not list or not unit then
25591: LD_VAR 0 2
25595: NOT
25596: IFTRUE 25605
25598: PUSH
25599: LD_VAR 0 1
25603: NOT
25604: OR
25605: IFFALSE 25609
// exit ;
25607: GO 25952
// result := [ ] ;
25609: LD_ADDR_VAR 0 5
25613: PUSH
25614: EMPTY
25615: ST_TO_ADDR
// for i in list do
25616: LD_ADDR_VAR 0 6
25620: PUSH
25621: LD_VAR 0 2
25625: PUSH
25626: FOR_IN
25627: IFFALSE 25845
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
25629: LD_ADDR_VAR 0 8
25633: PUSH
25634: LD_VAR 0 1
25638: PPUSH
25639: LD_VAR 0 6
25643: PUSH
25644: LD_INT 1
25646: ARRAY
25647: PPUSH
25648: LD_VAR 0 6
25652: PUSH
25653: LD_INT 2
25655: ARRAY
25656: PPUSH
25657: CALL_OW 297
25661: ST_TO_ADDR
// if not Count ( result ) then
25662: LD_VAR 0 5
25666: PPUSH
25667: CALL 22179 0 1
25671: NOT
25672: IFFALSE 25705
// begin result := Join ( result , [ i , tmp ] ) ;
25674: LD_ADDR_VAR 0 5
25678: PUSH
25679: LD_VAR 0 5
25683: PPUSH
25684: LD_VAR 0 6
25688: PUSH
25689: LD_VAR 0 8
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PPUSH
25698: CALL 58155 0 2
25702: ST_TO_ADDR
// continue ;
25703: GO 25626
// end ; if result [ result ] [ 2 ] <= tmp then
25705: LD_VAR 0 5
25709: PUSH
25710: LD_VAR 0 5
25714: ARRAY
25715: PUSH
25716: LD_INT 2
25718: ARRAY
25719: PUSH
25720: LD_VAR 0 8
25724: LESSEQUAL
25725: IFFALSE 25758
// result := Join ( result , [ i , tmp ] ) else
25727: LD_ADDR_VAR 0 5
25731: PUSH
25732: LD_VAR 0 5
25736: PPUSH
25737: LD_VAR 0 6
25741: PUSH
25742: LD_VAR 0 8
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PPUSH
25751: CALL 58155 0 2
25755: ST_TO_ADDR
25756: GO 25843
// begin for j := 1 to Count ( result ) do
25758: LD_ADDR_VAR 0 7
25762: PUSH
25763: DOUBLE
25764: LD_INT 1
25766: DEC
25767: ST_TO_ADDR
25768: LD_VAR 0 5
25772: PPUSH
25773: CALL 22179 0 1
25777: PUSH
25778: FOR_TO
25779: IFFALSE 25841
// begin if tmp < result [ j ] [ 2 ] then
25781: LD_VAR 0 8
25785: PUSH
25786: LD_VAR 0 5
25790: PUSH
25791: LD_VAR 0 7
25795: ARRAY
25796: PUSH
25797: LD_INT 2
25799: ARRAY
25800: LESS
25801: IFFALSE 25839
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25803: LD_ADDR_VAR 0 5
25807: PUSH
25808: LD_VAR 0 5
25812: PPUSH
25813: LD_VAR 0 7
25817: PPUSH
25818: LD_VAR 0 6
25822: PUSH
25823: LD_VAR 0 8
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PPUSH
25832: CALL_OW 2
25836: ST_TO_ADDR
// break ;
25837: GO 25841
// end ; end ;
25839: GO 25778
25841: POP
25842: POP
// end ; end ;
25843: GO 25626
25845: POP
25846: POP
// if result and not asc then
25847: LD_VAR 0 5
25851: IFFALSE 25860
25853: PUSH
25854: LD_VAR 0 3
25858: NOT
25859: AND
25860: IFFALSE 25877
// result := ReverseArray ( result ) ;
25862: LD_ADDR_VAR 0 5
25866: PUSH
25867: LD_VAR 0 5
25871: PPUSH
25872: CALL 53235 0 1
25876: ST_TO_ADDR
// tmp := [ ] ;
25877: LD_ADDR_VAR 0 8
25881: PUSH
25882: EMPTY
25883: ST_TO_ADDR
// if mode then
25884: LD_VAR 0 4
25888: IFFALSE 25952
// begin for i := 1 to result do
25890: LD_ADDR_VAR 0 6
25894: PUSH
25895: DOUBLE
25896: LD_INT 1
25898: DEC
25899: ST_TO_ADDR
25900: LD_VAR 0 5
25904: PUSH
25905: FOR_TO
25906: IFFALSE 25940
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
25908: LD_ADDR_VAR 0 8
25912: PUSH
25913: LD_VAR 0 8
25917: PPUSH
25918: LD_VAR 0 5
25922: PUSH
25923: LD_VAR 0 6
25927: ARRAY
25928: PUSH
25929: LD_INT 1
25931: ARRAY
25932: PPUSH
25933: CALL 58155 0 2
25937: ST_TO_ADDR
25938: GO 25905
25940: POP
25941: POP
// result := tmp ;
25942: LD_ADDR_VAR 0 5
25946: PUSH
25947: LD_VAR 0 8
25951: ST_TO_ADDR
// end ; end ;
25952: LD_VAR 0 5
25956: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25957: LD_INT 0
25959: PPUSH
25960: PPUSH
25961: PPUSH
25962: PPUSH
// if not list then
25963: LD_VAR 0 3
25967: NOT
25968: IFFALSE 25972
// exit ;
25970: GO 26362
// result := [ ] ;
25972: LD_ADDR_VAR 0 6
25976: PUSH
25977: EMPTY
25978: ST_TO_ADDR
// for i in list do
25979: LD_ADDR_VAR 0 7
25983: PUSH
25984: LD_VAR 0 3
25988: PUSH
25989: FOR_IN
25990: IFFALSE 26192
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25992: LD_ADDR_VAR 0 9
25996: PUSH
25997: LD_VAR 0 7
26001: PPUSH
26002: LD_VAR 0 1
26006: PPUSH
26007: LD_VAR 0 2
26011: PPUSH
26012: CALL_OW 297
26016: ST_TO_ADDR
// if not result then
26017: LD_VAR 0 6
26021: NOT
26022: IFFALSE 26048
// result := [ [ i , tmp ] ] else
26024: LD_ADDR_VAR 0 6
26028: PUSH
26029: LD_VAR 0 7
26033: PUSH
26034: LD_VAR 0 9
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PUSH
26043: EMPTY
26044: LIST
26045: ST_TO_ADDR
26046: GO 26190
// begin if result [ result ] [ 2 ] <= tmp then
26048: LD_VAR 0 6
26052: PUSH
26053: LD_VAR 0 6
26057: ARRAY
26058: PUSH
26059: LD_INT 2
26061: ARRAY
26062: PUSH
26063: LD_VAR 0 9
26067: LESSEQUAL
26068: IFFALSE 26110
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
26070: LD_ADDR_VAR 0 6
26074: PUSH
26075: LD_VAR 0 6
26079: PPUSH
26080: LD_VAR 0 6
26084: PUSH
26085: LD_INT 1
26087: PLUS
26088: PPUSH
26089: LD_VAR 0 7
26093: PUSH
26094: LD_VAR 0 9
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PPUSH
26103: CALL_OW 2
26107: ST_TO_ADDR
26108: GO 26190
// for j := 1 to result do
26110: LD_ADDR_VAR 0 8
26114: PUSH
26115: DOUBLE
26116: LD_INT 1
26118: DEC
26119: ST_TO_ADDR
26120: LD_VAR 0 6
26124: PUSH
26125: FOR_TO
26126: IFFALSE 26188
// begin if tmp < result [ j ] [ 2 ] then
26128: LD_VAR 0 9
26132: PUSH
26133: LD_VAR 0 6
26137: PUSH
26138: LD_VAR 0 8
26142: ARRAY
26143: PUSH
26144: LD_INT 2
26146: ARRAY
26147: LESS
26148: IFFALSE 26186
// begin result := Insert ( result , j , [ i , tmp ] ) ;
26150: LD_ADDR_VAR 0 6
26154: PUSH
26155: LD_VAR 0 6
26159: PPUSH
26160: LD_VAR 0 8
26164: PPUSH
26165: LD_VAR 0 7
26169: PUSH
26170: LD_VAR 0 9
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: PPUSH
26179: CALL_OW 2
26183: ST_TO_ADDR
// break ;
26184: GO 26188
// end ; end ;
26186: GO 26125
26188: POP
26189: POP
// end ; end ;
26190: GO 25989
26192: POP
26193: POP
// if result and not asc then
26194: LD_VAR 0 6
26198: IFFALSE 26207
26200: PUSH
26201: LD_VAR 0 4
26205: NOT
26206: AND
26207: IFFALSE 26282
// begin tmp := result ;
26209: LD_ADDR_VAR 0 9
26213: PUSH
26214: LD_VAR 0 6
26218: ST_TO_ADDR
// for i = tmp downto 1 do
26219: LD_ADDR_VAR 0 7
26223: PUSH
26224: DOUBLE
26225: LD_VAR 0 9
26229: INC
26230: ST_TO_ADDR
26231: LD_INT 1
26233: PUSH
26234: FOR_DOWNTO
26235: IFFALSE 26280
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
26237: LD_ADDR_VAR 0 6
26241: PUSH
26242: LD_VAR 0 6
26246: PPUSH
26247: LD_VAR 0 9
26251: PUSH
26252: LD_VAR 0 7
26256: MINUS
26257: PUSH
26258: LD_INT 1
26260: PLUS
26261: PPUSH
26262: LD_VAR 0 9
26266: PUSH
26267: LD_VAR 0 7
26271: ARRAY
26272: PPUSH
26273: CALL_OW 1
26277: ST_TO_ADDR
26278: GO 26234
26280: POP
26281: POP
// end ; tmp := [ ] ;
26282: LD_ADDR_VAR 0 9
26286: PUSH
26287: EMPTY
26288: ST_TO_ADDR
// if mode then
26289: LD_VAR 0 5
26293: IFFALSE 26362
// begin for i = 1 to result do
26295: LD_ADDR_VAR 0 7
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_VAR 0 6
26309: PUSH
26310: FOR_TO
26311: IFFALSE 26350
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
26313: LD_ADDR_VAR 0 9
26317: PUSH
26318: LD_VAR 0 9
26322: PPUSH
26323: LD_VAR 0 7
26327: PPUSH
26328: LD_VAR 0 6
26332: PUSH
26333: LD_VAR 0 7
26337: ARRAY
26338: PUSH
26339: LD_INT 1
26341: ARRAY
26342: PPUSH
26343: CALL_OW 1
26347: ST_TO_ADDR
26348: GO 26310
26350: POP
26351: POP
// result := tmp ;
26352: LD_ADDR_VAR 0 6
26356: PUSH
26357: LD_VAR 0 9
26361: ST_TO_ADDR
// end ; end ;
26362: LD_VAR 0 6
26366: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
26367: LD_INT 0
26369: PPUSH
26370: PPUSH
26371: PPUSH
26372: PPUSH
26373: PPUSH
26374: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
26375: LD_ADDR_VAR 0 5
26379: PUSH
26380: LD_INT 0
26382: PUSH
26383: LD_INT 0
26385: PUSH
26386: LD_INT 0
26388: PUSH
26389: EMPTY
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: LIST
26395: LIST
26396: ST_TO_ADDR
// if not x or not y then
26397: LD_VAR 0 2
26401: NOT
26402: IFTRUE 26411
26404: PUSH
26405: LD_VAR 0 3
26409: NOT
26410: OR
26411: IFFALSE 26415
// exit ;
26413: GO 28071
// if not range then
26415: LD_VAR 0 4
26419: NOT
26420: IFFALSE 26430
// range := 10 ;
26422: LD_ADDR_VAR 0 4
26426: PUSH
26427: LD_INT 10
26429: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
26430: LD_ADDR_VAR 0 8
26434: PUSH
26435: LD_INT 81
26437: PUSH
26438: LD_VAR 0 1
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 92
26449: PUSH
26450: LD_VAR 0 2
26454: PUSH
26455: LD_VAR 0 3
26459: PUSH
26460: LD_VAR 0 4
26464: PUSH
26465: EMPTY
26466: LIST
26467: LIST
26468: LIST
26469: LIST
26470: PUSH
26471: LD_INT 3
26473: PUSH
26474: LD_INT 21
26476: PUSH
26477: LD_INT 3
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: LIST
26492: PPUSH
26493: CALL_OW 69
26497: ST_TO_ADDR
// if not tmp then
26498: LD_VAR 0 8
26502: NOT
26503: IFFALSE 26507
// exit ;
26505: GO 28071
// for i in tmp do
26507: LD_ADDR_VAR 0 6
26511: PUSH
26512: LD_VAR 0 8
26516: PUSH
26517: FOR_IN
26518: IFFALSE 28046
// begin points := [ 0 , 0 , 0 ] ;
26520: LD_ADDR_VAR 0 9
26524: PUSH
26525: LD_INT 0
26527: PUSH
26528: LD_INT 0
26530: PUSH
26531: LD_INT 0
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: LIST
26538: ST_TO_ADDR
// bpoints := 1 ;
26539: LD_ADDR_VAR 0 10
26543: PUSH
26544: LD_INT 1
26546: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26547: LD_VAR 0 6
26551: PPUSH
26552: CALL_OW 247
26556: PUSH
26557: LD_INT 1
26559: DOUBLE
26560: EQUAL
26561: IFTRUE 26565
26563: GO 27147
26565: POP
// begin if GetClass ( i ) = 1 then
26566: LD_VAR 0 6
26570: PPUSH
26571: CALL_OW 257
26575: PUSH
26576: LD_INT 1
26578: EQUAL
26579: IFFALSE 26600
// points := [ 10 , 5 , 3 ] ;
26581: LD_ADDR_VAR 0 9
26585: PUSH
26586: LD_INT 10
26588: PUSH
26589: LD_INT 5
26591: PUSH
26592: LD_INT 3
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: LIST
26599: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26600: LD_VAR 0 6
26604: PPUSH
26605: CALL_OW 257
26609: PUSH
26610: LD_INT 2
26612: PUSH
26613: LD_INT 3
26615: PUSH
26616: LD_INT 4
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: LIST
26623: IN
26624: IFFALSE 26645
// points := [ 3 , 2 , 1 ] ;
26626: LD_ADDR_VAR 0 9
26630: PUSH
26631: LD_INT 3
26633: PUSH
26634: LD_INT 2
26636: PUSH
26637: LD_INT 1
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: LIST
26644: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26645: LD_VAR 0 6
26649: PPUSH
26650: CALL_OW 257
26654: PUSH
26655: LD_INT 5
26657: EQUAL
26658: IFFALSE 26679
// points := [ 130 , 5 , 2 ] ;
26660: LD_ADDR_VAR 0 9
26664: PUSH
26665: LD_INT 130
26667: PUSH
26668: LD_INT 5
26670: PUSH
26671: LD_INT 2
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: LIST
26678: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26679: LD_VAR 0 6
26683: PPUSH
26684: CALL_OW 257
26688: PUSH
26689: LD_INT 8
26691: EQUAL
26692: IFFALSE 26713
// points := [ 35 , 35 , 30 ] ;
26694: LD_ADDR_VAR 0 9
26698: PUSH
26699: LD_INT 35
26701: PUSH
26702: LD_INT 35
26704: PUSH
26705: LD_INT 30
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: LIST
26712: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26713: LD_VAR 0 6
26717: PPUSH
26718: CALL_OW 257
26722: PUSH
26723: LD_INT 9
26725: EQUAL
26726: IFFALSE 26747
// points := [ 20 , 55 , 40 ] ;
26728: LD_ADDR_VAR 0 9
26732: PUSH
26733: LD_INT 20
26735: PUSH
26736: LD_INT 55
26738: PUSH
26739: LD_INT 40
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: LIST
26746: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26747: LD_VAR 0 6
26751: PPUSH
26752: CALL_OW 257
26756: PUSH
26757: LD_INT 12
26759: PUSH
26760: LD_INT 16
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: IN
26767: IFFALSE 26788
// points := [ 5 , 3 , 2 ] ;
26769: LD_ADDR_VAR 0 9
26773: PUSH
26774: LD_INT 5
26776: PUSH
26777: LD_INT 3
26779: PUSH
26780: LD_INT 2
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: LIST
26787: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26788: LD_VAR 0 6
26792: PPUSH
26793: CALL_OW 257
26797: PUSH
26798: LD_INT 17
26800: EQUAL
26801: IFFALSE 26822
// points := [ 100 , 50 , 75 ] ;
26803: LD_ADDR_VAR 0 9
26807: PUSH
26808: LD_INT 100
26810: PUSH
26811: LD_INT 50
26813: PUSH
26814: LD_INT 75
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: LIST
26821: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26822: LD_VAR 0 6
26826: PPUSH
26827: CALL_OW 257
26831: PUSH
26832: LD_INT 15
26834: EQUAL
26835: IFFALSE 26856
// points := [ 10 , 5 , 3 ] ;
26837: LD_ADDR_VAR 0 9
26841: PUSH
26842: LD_INT 10
26844: PUSH
26845: LD_INT 5
26847: PUSH
26848: LD_INT 3
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: LIST
26855: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26856: LD_VAR 0 6
26860: PPUSH
26861: CALL_OW 257
26865: PUSH
26866: LD_INT 14
26868: EQUAL
26869: IFFALSE 26890
// points := [ 10 , 0 , 0 ] ;
26871: LD_ADDR_VAR 0 9
26875: PUSH
26876: LD_INT 10
26878: PUSH
26879: LD_INT 0
26881: PUSH
26882: LD_INT 0
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: LIST
26889: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26890: LD_VAR 0 6
26894: PPUSH
26895: CALL_OW 257
26899: PUSH
26900: LD_INT 11
26902: EQUAL
26903: IFFALSE 26924
// points := [ 30 , 10 , 5 ] ;
26905: LD_ADDR_VAR 0 9
26909: PUSH
26910: LD_INT 30
26912: PUSH
26913: LD_INT 10
26915: PUSH
26916: LD_INT 5
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: LIST
26923: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26924: LD_VAR 0 1
26928: PPUSH
26929: LD_INT 5
26931: PPUSH
26932: CALL_OW 321
26936: PUSH
26937: LD_INT 2
26939: EQUAL
26940: IFFALSE 26957
// bpoints := bpoints * 1.8 ;
26942: LD_ADDR_VAR 0 10
26946: PUSH
26947: LD_VAR 0 10
26951: PUSH
26952: LD_REAL  1.80000000000000E+0000
26955: MUL
26956: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26957: LD_VAR 0 6
26961: PPUSH
26962: CALL_OW 257
26966: PUSH
26967: LD_INT 1
26969: PUSH
26970: LD_INT 2
26972: PUSH
26973: LD_INT 3
26975: PUSH
26976: LD_INT 4
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: IN
26985: IFFALSE 27005
26987: PUSH
26988: LD_VAR 0 1
26992: PPUSH
26993: LD_INT 51
26995: PPUSH
26996: CALL_OW 321
27000: PUSH
27001: LD_INT 2
27003: EQUAL
27004: AND
27005: IFFALSE 27022
// bpoints := bpoints * 1.2 ;
27007: LD_ADDR_VAR 0 10
27011: PUSH
27012: LD_VAR 0 10
27016: PUSH
27017: LD_REAL  1.20000000000000E+0000
27020: MUL
27021: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
27022: LD_VAR 0 6
27026: PPUSH
27027: CALL_OW 257
27031: PUSH
27032: LD_INT 5
27034: PUSH
27035: LD_INT 7
27037: PUSH
27038: LD_INT 9
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: LIST
27045: IN
27046: IFFALSE 27066
27048: PUSH
27049: LD_VAR 0 1
27053: PPUSH
27054: LD_INT 52
27056: PPUSH
27057: CALL_OW 321
27061: PUSH
27062: LD_INT 2
27064: EQUAL
27065: AND
27066: IFFALSE 27083
// bpoints := bpoints * 1.5 ;
27068: LD_ADDR_VAR 0 10
27072: PUSH
27073: LD_VAR 0 10
27077: PUSH
27078: LD_REAL  1.50000000000000E+0000
27081: MUL
27082: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
27083: LD_VAR 0 1
27087: PPUSH
27088: LD_INT 66
27090: PPUSH
27091: CALL_OW 321
27095: PUSH
27096: LD_INT 2
27098: EQUAL
27099: IFFALSE 27116
// bpoints := bpoints * 1.1 ;
27101: LD_ADDR_VAR 0 10
27105: PUSH
27106: LD_VAR 0 10
27110: PUSH
27111: LD_REAL  1.10000000000000E+0000
27114: MUL
27115: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
27116: LD_ADDR_VAR 0 10
27120: PUSH
27121: LD_VAR 0 10
27125: PUSH
27126: LD_VAR 0 6
27130: PPUSH
27131: LD_INT 1
27133: PPUSH
27134: CALL_OW 259
27138: PUSH
27139: LD_REAL  1.15000000000000E+0000
27142: MUL
27143: MUL
27144: ST_TO_ADDR
// end ; unit_vehicle :
27145: GO 27975
27147: LD_INT 2
27149: DOUBLE
27150: EQUAL
27151: IFTRUE 27155
27153: GO 27963
27155: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
27156: LD_VAR 0 6
27160: PPUSH
27161: CALL_OW 264
27165: PUSH
27166: LD_INT 2
27168: PUSH
27169: LD_INT 42
27171: PUSH
27172: LD_INT 24
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: LIST
27179: IN
27180: IFFALSE 27201
// points := [ 25 , 5 , 3 ] ;
27182: LD_ADDR_VAR 0 9
27186: PUSH
27187: LD_INT 25
27189: PUSH
27190: LD_INT 5
27192: PUSH
27193: LD_INT 3
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: LIST
27200: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
27201: LD_VAR 0 6
27205: PPUSH
27206: CALL_OW 264
27210: PUSH
27211: LD_INT 4
27213: PUSH
27214: LD_INT 43
27216: PUSH
27217: LD_INT 25
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: LIST
27224: IN
27225: IFFALSE 27246
// points := [ 40 , 15 , 5 ] ;
27227: LD_ADDR_VAR 0 9
27231: PUSH
27232: LD_INT 40
27234: PUSH
27235: LD_INT 15
27237: PUSH
27238: LD_INT 5
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: LIST
27245: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
27246: LD_VAR 0 6
27250: PPUSH
27251: CALL_OW 264
27255: PUSH
27256: LD_INT 3
27258: PUSH
27259: LD_INT 23
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: IN
27266: IFFALSE 27287
// points := [ 7 , 25 , 8 ] ;
27268: LD_ADDR_VAR 0 9
27272: PUSH
27273: LD_INT 7
27275: PUSH
27276: LD_INT 25
27278: PUSH
27279: LD_INT 8
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: LIST
27286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
27287: LD_VAR 0 6
27291: PPUSH
27292: CALL_OW 264
27296: PUSH
27297: LD_INT 5
27299: PUSH
27300: LD_INT 27
27302: PUSH
27303: LD_INT 44
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: LIST
27310: IN
27311: IFFALSE 27332
// points := [ 14 , 50 , 16 ] ;
27313: LD_ADDR_VAR 0 9
27317: PUSH
27318: LD_INT 14
27320: PUSH
27321: LD_INT 50
27323: PUSH
27324: LD_INT 16
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: LIST
27331: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
27332: LD_VAR 0 6
27336: PPUSH
27337: CALL_OW 264
27341: PUSH
27342: LD_INT 6
27344: PUSH
27345: LD_INT 46
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: IN
27352: IFFALSE 27373
// points := [ 32 , 120 , 70 ] ;
27354: LD_ADDR_VAR 0 9
27358: PUSH
27359: LD_INT 32
27361: PUSH
27362: LD_INT 120
27364: PUSH
27365: LD_INT 70
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: LIST
27372: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
27373: LD_VAR 0 6
27377: PPUSH
27378: CALL_OW 264
27382: PUSH
27383: LD_INT 7
27385: PUSH
27386: LD_INT 28
27388: PUSH
27389: LD_INT 45
27391: PUSH
27392: LD_INT 92
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: IN
27401: IFFALSE 27422
// points := [ 35 , 20 , 45 ] ;
27403: LD_ADDR_VAR 0 9
27407: PUSH
27408: LD_INT 35
27410: PUSH
27411: LD_INT 20
27413: PUSH
27414: LD_INT 45
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: LIST
27421: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
27422: LD_VAR 0 6
27426: PPUSH
27427: CALL_OW 264
27431: PUSH
27432: LD_INT 47
27434: PUSH
27435: EMPTY
27436: LIST
27437: IN
27438: IFFALSE 27459
// points := [ 67 , 45 , 75 ] ;
27440: LD_ADDR_VAR 0 9
27444: PUSH
27445: LD_INT 67
27447: PUSH
27448: LD_INT 45
27450: PUSH
27451: LD_INT 75
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: LIST
27458: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27459: LD_VAR 0 6
27463: PPUSH
27464: CALL_OW 264
27468: PUSH
27469: LD_INT 26
27471: PUSH
27472: EMPTY
27473: LIST
27474: IN
27475: IFFALSE 27496
// points := [ 120 , 30 , 80 ] ;
27477: LD_ADDR_VAR 0 9
27481: PUSH
27482: LD_INT 120
27484: PUSH
27485: LD_INT 30
27487: PUSH
27488: LD_INT 80
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: LIST
27495: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27496: LD_VAR 0 6
27500: PPUSH
27501: CALL_OW 264
27505: PUSH
27506: LD_INT 22
27508: PUSH
27509: EMPTY
27510: LIST
27511: IN
27512: IFFALSE 27533
// points := [ 40 , 1 , 1 ] ;
27514: LD_ADDR_VAR 0 9
27518: PUSH
27519: LD_INT 40
27521: PUSH
27522: LD_INT 1
27524: PUSH
27525: LD_INT 1
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: LIST
27532: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27533: LD_VAR 0 6
27537: PPUSH
27538: CALL_OW 264
27542: PUSH
27543: LD_INT 29
27545: PUSH
27546: EMPTY
27547: LIST
27548: IN
27549: IFFALSE 27570
// points := [ 70 , 200 , 400 ] ;
27551: LD_ADDR_VAR 0 9
27555: PUSH
27556: LD_INT 70
27558: PUSH
27559: LD_INT 200
27561: PUSH
27562: LD_INT 400
27564: PUSH
27565: EMPTY
27566: LIST
27567: LIST
27568: LIST
27569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27570: LD_VAR 0 6
27574: PPUSH
27575: CALL_OW 264
27579: PUSH
27580: LD_INT 14
27582: PUSH
27583: LD_INT 53
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: IN
27590: IFFALSE 27611
// points := [ 40 , 10 , 20 ] ;
27592: LD_ADDR_VAR 0 9
27596: PUSH
27597: LD_INT 40
27599: PUSH
27600: LD_INT 10
27602: PUSH
27603: LD_INT 20
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: LIST
27610: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27611: LD_VAR 0 6
27615: PPUSH
27616: CALL_OW 264
27620: PUSH
27621: LD_INT 9
27623: PUSH
27624: EMPTY
27625: LIST
27626: IN
27627: IFFALSE 27648
// points := [ 5 , 70 , 20 ] ;
27629: LD_ADDR_VAR 0 9
27633: PUSH
27634: LD_INT 5
27636: PUSH
27637: LD_INT 70
27639: PUSH
27640: LD_INT 20
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: LIST
27647: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27648: LD_VAR 0 6
27652: PPUSH
27653: CALL_OW 264
27657: PUSH
27658: LD_INT 10
27660: PUSH
27661: EMPTY
27662: LIST
27663: IN
27664: IFFALSE 27685
// points := [ 35 , 110 , 70 ] ;
27666: LD_ADDR_VAR 0 9
27670: PUSH
27671: LD_INT 35
27673: PUSH
27674: LD_INT 110
27676: PUSH
27677: LD_INT 70
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27685: LD_VAR 0 6
27689: PPUSH
27690: CALL_OW 265
27694: PUSH
27695: LD_INT 25
27697: EQUAL
27698: IFFALSE 27719
// points := [ 80 , 65 , 100 ] ;
27700: LD_ADDR_VAR 0 9
27704: PUSH
27705: LD_INT 80
27707: PUSH
27708: LD_INT 65
27710: PUSH
27711: LD_INT 100
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: LIST
27718: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27719: LD_VAR 0 6
27723: PPUSH
27724: CALL_OW 263
27728: PUSH
27729: LD_INT 1
27731: EQUAL
27732: IFFALSE 27767
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27734: LD_ADDR_VAR 0 10
27738: PUSH
27739: LD_VAR 0 10
27743: PUSH
27744: LD_VAR 0 6
27748: PPUSH
27749: CALL_OW 311
27753: PPUSH
27754: LD_INT 3
27756: PPUSH
27757: CALL_OW 259
27761: PUSH
27762: LD_INT 4
27764: MUL
27765: MUL
27766: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27767: LD_VAR 0 6
27771: PPUSH
27772: CALL_OW 263
27776: PUSH
27777: LD_INT 2
27779: EQUAL
27780: IFFALSE 27831
// begin j := IsControledBy ( i ) ;
27782: LD_ADDR_VAR 0 7
27786: PUSH
27787: LD_VAR 0 6
27791: PPUSH
27792: CALL_OW 312
27796: ST_TO_ADDR
// if j then
27797: LD_VAR 0 7
27801: IFFALSE 27831
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27803: LD_ADDR_VAR 0 10
27807: PUSH
27808: LD_VAR 0 10
27812: PUSH
27813: LD_VAR 0 7
27817: PPUSH
27818: LD_INT 3
27820: PPUSH
27821: CALL_OW 259
27825: PUSH
27826: LD_INT 3
27828: MUL
27829: MUL
27830: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27831: LD_VAR 0 6
27835: PPUSH
27836: CALL_OW 264
27840: PUSH
27841: LD_INT 5
27843: PUSH
27844: LD_INT 6
27846: PUSH
27847: LD_INT 46
27849: PUSH
27850: LD_INT 44
27852: PUSH
27853: LD_INT 47
27855: PUSH
27856: LD_INT 45
27858: PUSH
27859: LD_INT 28
27861: PUSH
27862: LD_INT 7
27864: PUSH
27865: LD_INT 27
27867: PUSH
27868: LD_INT 29
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: LIST
27882: IN
27883: IFFALSE 27903
27885: PUSH
27886: LD_VAR 0 1
27890: PPUSH
27891: LD_INT 52
27893: PPUSH
27894: CALL_OW 321
27898: PUSH
27899: LD_INT 2
27901: EQUAL
27902: AND
27903: IFFALSE 27920
// bpoints := bpoints * 1.2 ;
27905: LD_ADDR_VAR 0 10
27909: PUSH
27910: LD_VAR 0 10
27914: PUSH
27915: LD_REAL  1.20000000000000E+0000
27918: MUL
27919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27920: LD_VAR 0 6
27924: PPUSH
27925: CALL_OW 264
27929: PUSH
27930: LD_INT 6
27932: PUSH
27933: LD_INT 46
27935: PUSH
27936: LD_INT 47
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: LIST
27943: IN
27944: IFFALSE 27961
// bpoints := bpoints * 1.2 ;
27946: LD_ADDR_VAR 0 10
27950: PUSH
27951: LD_VAR 0 10
27955: PUSH
27956: LD_REAL  1.20000000000000E+0000
27959: MUL
27960: ST_TO_ADDR
// end ; unit_building :
27961: GO 27975
27963: LD_INT 3
27965: DOUBLE
27966: EQUAL
27967: IFTRUE 27971
27969: GO 27974
27971: POP
// ; end ;
27972: GO 27975
27974: POP
// for j = 1 to 3 do
27975: LD_ADDR_VAR 0 7
27979: PUSH
27980: DOUBLE
27981: LD_INT 1
27983: DEC
27984: ST_TO_ADDR
27985: LD_INT 3
27987: PUSH
27988: FOR_TO
27989: IFFALSE 28042
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27991: LD_ADDR_VAR 0 5
27995: PUSH
27996: LD_VAR 0 5
28000: PPUSH
28001: LD_VAR 0 7
28005: PPUSH
28006: LD_VAR 0 5
28010: PUSH
28011: LD_VAR 0 7
28015: ARRAY
28016: PUSH
28017: LD_VAR 0 9
28021: PUSH
28022: LD_VAR 0 7
28026: ARRAY
28027: PUSH
28028: LD_VAR 0 10
28032: MUL
28033: PLUS
28034: PPUSH
28035: CALL_OW 1
28039: ST_TO_ADDR
28040: GO 27988
28042: POP
28043: POP
// end ;
28044: GO 26517
28046: POP
28047: POP
// result := Replace ( result , 4 , tmp ) ;
28048: LD_ADDR_VAR 0 5
28052: PUSH
28053: LD_VAR 0 5
28057: PPUSH
28058: LD_INT 4
28060: PPUSH
28061: LD_VAR 0 8
28065: PPUSH
28066: CALL_OW 1
28070: ST_TO_ADDR
// end ;
28071: LD_VAR 0 5
28075: RET
// export function DangerAtRange ( unit , range ) ; begin
28076: LD_INT 0
28078: PPUSH
// if not unit then
28079: LD_VAR 0 1
28083: NOT
28084: IFFALSE 28088
// exit ;
28086: GO 28133
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
28088: LD_ADDR_VAR 0 3
28092: PUSH
28093: LD_VAR 0 1
28097: PPUSH
28098: CALL_OW 255
28102: PPUSH
28103: LD_VAR 0 1
28107: PPUSH
28108: CALL_OW 250
28112: PPUSH
28113: LD_VAR 0 1
28117: PPUSH
28118: CALL_OW 251
28122: PPUSH
28123: LD_VAR 0 2
28127: PPUSH
28128: CALL 26367 0 4
28132: ST_TO_ADDR
// end ;
28133: LD_VAR 0 3
28137: RET
// export function DangerInArea ( side , area ) ; begin
28138: LD_INT 0
28140: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
28141: LD_ADDR_VAR 0 3
28145: PUSH
28146: LD_VAR 0 2
28150: PPUSH
28151: LD_INT 81
28153: PUSH
28154: LD_VAR 0 1
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: PPUSH
28163: CALL_OW 70
28167: ST_TO_ADDR
// end ;
28168: LD_VAR 0 3
28172: RET
// export function IsExtension ( b ) ; begin
28173: LD_INT 0
28175: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
28176: LD_ADDR_VAR 0 2
28180: PUSH
28181: LD_VAR 0 1
28185: PUSH
28186: LD_INT 23
28188: PUSH
28189: LD_INT 20
28191: PUSH
28192: LD_INT 22
28194: PUSH
28195: LD_INT 17
28197: PUSH
28198: LD_INT 24
28200: PUSH
28201: LD_INT 21
28203: PUSH
28204: LD_INT 19
28206: PUSH
28207: LD_INT 16
28209: PUSH
28210: LD_INT 25
28212: PUSH
28213: LD_INT 18
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: IN
28228: ST_TO_ADDR
// end ;
28229: LD_VAR 0 2
28233: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
28234: LD_INT 0
28236: PPUSH
28237: PPUSH
28238: PPUSH
// result := [ ] ;
28239: LD_ADDR_VAR 0 4
28243: PUSH
28244: EMPTY
28245: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
28246: LD_ADDR_VAR 0 5
28250: PUSH
28251: LD_VAR 0 2
28255: PPUSH
28256: LD_INT 21
28258: PUSH
28259: LD_INT 3
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PPUSH
28266: CALL_OW 70
28270: ST_TO_ADDR
// if not tmp then
28271: LD_VAR 0 5
28275: NOT
28276: IFFALSE 28280
// exit ;
28278: GO 28344
// if checkLink then
28280: LD_VAR 0 3
28284: IFFALSE 28334
// begin for i in tmp do
28286: LD_ADDR_VAR 0 6
28290: PUSH
28291: LD_VAR 0 5
28295: PUSH
28296: FOR_IN
28297: IFFALSE 28332
// if GetBase ( i ) <> base then
28299: LD_VAR 0 6
28303: PPUSH
28304: CALL_OW 274
28308: PUSH
28309: LD_VAR 0 1
28313: NONEQUAL
28314: IFFALSE 28330
// ComLinkToBase ( base , i ) ;
28316: LD_VAR 0 1
28320: PPUSH
28321: LD_VAR 0 6
28325: PPUSH
28326: CALL_OW 169
28330: GO 28296
28332: POP
28333: POP
// end ; result := tmp ;
28334: LD_ADDR_VAR 0 4
28338: PUSH
28339: LD_VAR 0 5
28343: ST_TO_ADDR
// end ;
28344: LD_VAR 0 4
28348: RET
// export function ComComplete ( units , b ) ; var i ; begin
28349: LD_INT 0
28351: PPUSH
28352: PPUSH
// if not units then
28353: LD_VAR 0 1
28357: NOT
28358: IFFALSE 28362
// exit ;
28360: GO 28452
// for i in units do
28362: LD_ADDR_VAR 0 4
28366: PUSH
28367: LD_VAR 0 1
28371: PUSH
28372: FOR_IN
28373: IFFALSE 28450
// if BuildingStatus ( b ) = bs_build then
28375: LD_VAR 0 2
28379: PPUSH
28380: CALL_OW 461
28384: PUSH
28385: LD_INT 1
28387: EQUAL
28388: IFFALSE 28448
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
28390: LD_VAR 0 4
28394: PPUSH
28395: LD_STRING h
28397: PUSH
28398: LD_VAR 0 2
28402: PPUSH
28403: CALL_OW 250
28407: PUSH
28408: LD_VAR 0 2
28412: PPUSH
28413: CALL_OW 251
28417: PUSH
28418: LD_VAR 0 2
28422: PUSH
28423: LD_INT 0
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 0
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: PUSH
28441: EMPTY
28442: LIST
28443: PPUSH
28444: CALL_OW 446
28448: GO 28372
28450: POP
28451: POP
// end ;
28452: LD_VAR 0 3
28456: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
28457: LD_INT 0
28459: PPUSH
28460: PPUSH
28461: PPUSH
28462: PPUSH
28463: PPUSH
28464: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
28465: LD_VAR 0 1
28469: NOT
28470: IFTRUE 28487
28472: PUSH
28473: LD_VAR 0 1
28477: PPUSH
28478: CALL_OW 263
28482: PUSH
28483: LD_INT 2
28485: NONEQUAL
28486: OR
28487: IFFALSE 28491
// exit ;
28489: GO 28807
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28491: LD_ADDR_VAR 0 6
28495: PUSH
28496: LD_INT 22
28498: PUSH
28499: LD_VAR 0 1
28503: PPUSH
28504: CALL_OW 255
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 2
28515: PUSH
28516: LD_INT 30
28518: PUSH
28519: LD_INT 36
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 34
28528: PUSH
28529: LD_INT 31
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: LIST
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PPUSH
28545: CALL_OW 69
28549: ST_TO_ADDR
// if not tmp then
28550: LD_VAR 0 6
28554: NOT
28555: IFFALSE 28559
// exit ;
28557: GO 28807
// result := [ ] ;
28559: LD_ADDR_VAR 0 2
28563: PUSH
28564: EMPTY
28565: ST_TO_ADDR
// for i in tmp do
28566: LD_ADDR_VAR 0 3
28570: PUSH
28571: LD_VAR 0 6
28575: PUSH
28576: FOR_IN
28577: IFFALSE 28648
// begin t := UnitsInside ( i ) ;
28579: LD_ADDR_VAR 0 4
28583: PUSH
28584: LD_VAR 0 3
28588: PPUSH
28589: CALL_OW 313
28593: ST_TO_ADDR
// if t then
28594: LD_VAR 0 4
28598: IFFALSE 28646
// for j in t do
28600: LD_ADDR_VAR 0 7
28604: PUSH
28605: LD_VAR 0 4
28609: PUSH
28610: FOR_IN
28611: IFFALSE 28644
// result := Replace ( result , result + 1 , j ) ;
28613: LD_ADDR_VAR 0 2
28617: PUSH
28618: LD_VAR 0 2
28622: PPUSH
28623: LD_VAR 0 2
28627: PUSH
28628: LD_INT 1
28630: PLUS
28631: PPUSH
28632: LD_VAR 0 7
28636: PPUSH
28637: CALL_OW 1
28641: ST_TO_ADDR
28642: GO 28610
28644: POP
28645: POP
// end ;
28646: GO 28576
28648: POP
28649: POP
// if not result then
28650: LD_VAR 0 2
28654: NOT
28655: IFFALSE 28659
// exit ;
28657: GO 28807
// mech := result [ 1 ] ;
28659: LD_ADDR_VAR 0 5
28663: PUSH
28664: LD_VAR 0 2
28668: PUSH
28669: LD_INT 1
28671: ARRAY
28672: ST_TO_ADDR
// if result > 1 then
28673: LD_VAR 0 2
28677: PUSH
28678: LD_INT 1
28680: GREATER
28681: IFFALSE 28793
// begin for i = 2 to result do
28683: LD_ADDR_VAR 0 3
28687: PUSH
28688: DOUBLE
28689: LD_INT 2
28691: DEC
28692: ST_TO_ADDR
28693: LD_VAR 0 2
28697: PUSH
28698: FOR_TO
28699: IFFALSE 28791
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28701: LD_ADDR_VAR 0 4
28705: PUSH
28706: LD_VAR 0 2
28710: PUSH
28711: LD_VAR 0 3
28715: ARRAY
28716: PPUSH
28717: LD_INT 3
28719: PPUSH
28720: CALL_OW 259
28724: PUSH
28725: LD_VAR 0 2
28729: PUSH
28730: LD_VAR 0 3
28734: ARRAY
28735: PPUSH
28736: CALL_OW 432
28740: MINUS
28741: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28742: LD_VAR 0 4
28746: PUSH
28747: LD_VAR 0 5
28751: PPUSH
28752: LD_INT 3
28754: PPUSH
28755: CALL_OW 259
28759: PUSH
28760: LD_VAR 0 5
28764: PPUSH
28765: CALL_OW 432
28769: MINUS
28770: GREATEREQUAL
28771: IFFALSE 28789
// mech := result [ i ] ;
28773: LD_ADDR_VAR 0 5
28777: PUSH
28778: LD_VAR 0 2
28782: PUSH
28783: LD_VAR 0 3
28787: ARRAY
28788: ST_TO_ADDR
// end ;
28789: GO 28698
28791: POP
28792: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28793: LD_VAR 0 1
28797: PPUSH
28798: LD_VAR 0 5
28802: PPUSH
28803: CALL_OW 135
// end ;
28807: LD_VAR 0 2
28811: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28812: LD_INT 0
28814: PPUSH
28815: PPUSH
28816: PPUSH
28817: PPUSH
28818: PPUSH
28819: PPUSH
28820: PPUSH
28821: PPUSH
28822: PPUSH
28823: PPUSH
28824: PPUSH
28825: PPUSH
28826: PPUSH
// result := [ ] ;
28827: LD_ADDR_VAR 0 7
28831: PUSH
28832: EMPTY
28833: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28834: LD_VAR 0 1
28838: PPUSH
28839: CALL_OW 266
28843: PUSH
28844: LD_INT 0
28846: PUSH
28847: LD_INT 1
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: IN
28854: NOT
28855: IFFALSE 28859
// exit ;
28857: GO 30499
// if name then
28859: LD_VAR 0 3
28863: IFFALSE 28879
// SetBName ( base_dep , name ) ;
28865: LD_VAR 0 1
28869: PPUSH
28870: LD_VAR 0 3
28874: PPUSH
28875: CALL_OW 500
// base := GetBase ( base_dep ) ;
28879: LD_ADDR_VAR 0 15
28883: PUSH
28884: LD_VAR 0 1
28888: PPUSH
28889: CALL_OW 274
28893: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28894: LD_ADDR_VAR 0 16
28898: PUSH
28899: LD_VAR 0 1
28903: PPUSH
28904: CALL_OW 255
28908: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28909: LD_ADDR_VAR 0 17
28913: PUSH
28914: LD_VAR 0 1
28918: PPUSH
28919: CALL_OW 248
28923: ST_TO_ADDR
// if sources then
28924: LD_VAR 0 5
28928: IFFALSE 28975
// for i = 1 to 3 do
28930: LD_ADDR_VAR 0 8
28934: PUSH
28935: DOUBLE
28936: LD_INT 1
28938: DEC
28939: ST_TO_ADDR
28940: LD_INT 3
28942: PUSH
28943: FOR_TO
28944: IFFALSE 28973
// AddResourceType ( base , i , sources [ i ] ) ;
28946: LD_VAR 0 15
28950: PPUSH
28951: LD_VAR 0 8
28955: PPUSH
28956: LD_VAR 0 5
28960: PUSH
28961: LD_VAR 0 8
28965: ARRAY
28966: PPUSH
28967: CALL_OW 276
28971: GO 28943
28973: POP
28974: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28975: LD_ADDR_VAR 0 18
28979: PUSH
28980: LD_VAR 0 15
28984: PPUSH
28985: LD_VAR 0 2
28989: PPUSH
28990: LD_INT 1
28992: PPUSH
28993: CALL 28234 0 3
28997: ST_TO_ADDR
// InitHc ;
28998: CALL_OW 19
// InitUc ;
29002: CALL_OW 18
// uc_side := side ;
29006: LD_ADDR_OWVAR 20
29010: PUSH
29011: LD_VAR 0 16
29015: ST_TO_ADDR
// uc_nation := nation ;
29016: LD_ADDR_OWVAR 21
29020: PUSH
29021: LD_VAR 0 17
29025: ST_TO_ADDR
// if buildings then
29026: LD_VAR 0 18
29030: IFFALSE 30358
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
29032: LD_ADDR_VAR 0 19
29036: PUSH
29037: LD_VAR 0 18
29041: PPUSH
29042: LD_INT 2
29044: PUSH
29045: LD_INT 30
29047: PUSH
29048: LD_INT 29
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 30
29057: PUSH
29058: LD_INT 30
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: EMPTY
29066: LIST
29067: LIST
29068: LIST
29069: PPUSH
29070: CALL_OW 72
29074: ST_TO_ADDR
// if tmp then
29075: LD_VAR 0 19
29079: IFFALSE 29127
// for i in tmp do
29081: LD_ADDR_VAR 0 8
29085: PUSH
29086: LD_VAR 0 19
29090: PUSH
29091: FOR_IN
29092: IFFALSE 29125
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
29094: LD_VAR 0 8
29098: PPUSH
29099: CALL_OW 250
29103: PPUSH
29104: LD_VAR 0 8
29108: PPUSH
29109: CALL_OW 251
29113: PPUSH
29114: LD_VAR 0 16
29118: PPUSH
29119: CALL_OW 441
29123: GO 29091
29125: POP
29126: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
29127: LD_VAR 0 18
29131: PPUSH
29132: LD_INT 2
29134: PUSH
29135: LD_INT 30
29137: PUSH
29138: LD_INT 32
29140: PUSH
29141: EMPTY
29142: LIST
29143: LIST
29144: PUSH
29145: LD_INT 30
29147: PUSH
29148: LD_INT 33
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: LIST
29159: PPUSH
29160: CALL_OW 72
29164: IFFALSE 29252
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
29166: LD_ADDR_VAR 0 8
29170: PUSH
29171: LD_VAR 0 18
29175: PPUSH
29176: LD_INT 2
29178: PUSH
29179: LD_INT 30
29181: PUSH
29182: LD_INT 32
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: LD_INT 30
29191: PUSH
29192: LD_INT 33
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: LIST
29203: PPUSH
29204: CALL_OW 72
29208: PUSH
29209: FOR_IN
29210: IFFALSE 29250
// begin if not GetBWeapon ( i ) then
29212: LD_VAR 0 8
29216: PPUSH
29217: CALL_OW 269
29221: NOT
29222: IFFALSE 29248
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
29224: LD_VAR 0 8
29228: PPUSH
29229: LD_VAR 0 8
29233: PPUSH
29234: LD_VAR 0 2
29238: PPUSH
29239: CALL 30504 0 2
29243: PPUSH
29244: CALL_OW 431
// end ;
29248: GO 29209
29250: POP
29251: POP
// end ; for i = 1 to personel do
29252: LD_ADDR_VAR 0 8
29256: PUSH
29257: DOUBLE
29258: LD_INT 1
29260: DEC
29261: ST_TO_ADDR
29262: LD_VAR 0 6
29266: PUSH
29267: FOR_TO
29268: IFFALSE 30338
// begin if i > 4 then
29270: LD_VAR 0 8
29274: PUSH
29275: LD_INT 4
29277: GREATER
29278: IFFALSE 29282
// break ;
29280: GO 30338
// case i of 1 :
29282: LD_VAR 0 8
29286: PUSH
29287: LD_INT 1
29289: DOUBLE
29290: EQUAL
29291: IFTRUE 29295
29293: GO 29375
29295: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
29296: LD_ADDR_VAR 0 12
29300: PUSH
29301: LD_VAR 0 18
29305: PPUSH
29306: LD_INT 22
29308: PUSH
29309: LD_VAR 0 16
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 58
29320: PUSH
29321: EMPTY
29322: LIST
29323: PUSH
29324: LD_INT 2
29326: PUSH
29327: LD_INT 30
29329: PUSH
29330: LD_INT 32
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 30
29339: PUSH
29340: LD_INT 4
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 30
29349: PUSH
29350: LD_INT 5
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: LIST
29367: PPUSH
29368: CALL_OW 72
29372: ST_TO_ADDR
29373: GO 29597
29375: LD_INT 2
29377: DOUBLE
29378: EQUAL
29379: IFTRUE 29383
29381: GO 29445
29383: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
29384: LD_ADDR_VAR 0 12
29388: PUSH
29389: LD_VAR 0 18
29393: PPUSH
29394: LD_INT 22
29396: PUSH
29397: LD_VAR 0 16
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: LD_INT 2
29408: PUSH
29409: LD_INT 30
29411: PUSH
29412: LD_INT 0
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 30
29421: PUSH
29422: LD_INT 1
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: PUSH
29429: EMPTY
29430: LIST
29431: LIST
29432: LIST
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PPUSH
29438: CALL_OW 72
29442: ST_TO_ADDR
29443: GO 29597
29445: LD_INT 3
29447: DOUBLE
29448: EQUAL
29449: IFTRUE 29453
29451: GO 29515
29453: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
29454: LD_ADDR_VAR 0 12
29458: PUSH
29459: LD_VAR 0 18
29463: PPUSH
29464: LD_INT 22
29466: PUSH
29467: LD_VAR 0 16
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 2
29478: PUSH
29479: LD_INT 30
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 30
29491: PUSH
29492: LD_INT 3
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: LIST
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PPUSH
29508: CALL_OW 72
29512: ST_TO_ADDR
29513: GO 29597
29515: LD_INT 4
29517: DOUBLE
29518: EQUAL
29519: IFTRUE 29523
29521: GO 29596
29523: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29524: LD_ADDR_VAR 0 12
29528: PUSH
29529: LD_VAR 0 18
29533: PPUSH
29534: LD_INT 22
29536: PUSH
29537: LD_VAR 0 16
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 2
29548: PUSH
29549: LD_INT 30
29551: PUSH
29552: LD_INT 6
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: PUSH
29559: LD_INT 30
29561: PUSH
29562: LD_INT 7
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 30
29571: PUSH
29572: LD_INT 8
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: LIST
29583: LIST
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PPUSH
29589: CALL_OW 72
29593: ST_TO_ADDR
29594: GO 29597
29596: POP
// if i = 1 then
29597: LD_VAR 0 8
29601: PUSH
29602: LD_INT 1
29604: EQUAL
29605: IFFALSE 29716
// begin tmp := [ ] ;
29607: LD_ADDR_VAR 0 19
29611: PUSH
29612: EMPTY
29613: ST_TO_ADDR
// for j in f do
29614: LD_ADDR_VAR 0 9
29618: PUSH
29619: LD_VAR 0 12
29623: PUSH
29624: FOR_IN
29625: IFFALSE 29698
// if GetBType ( j ) = b_bunker then
29627: LD_VAR 0 9
29631: PPUSH
29632: CALL_OW 266
29636: PUSH
29637: LD_INT 32
29639: EQUAL
29640: IFFALSE 29667
// tmp := Insert ( tmp , 1 , j ) else
29642: LD_ADDR_VAR 0 19
29646: PUSH
29647: LD_VAR 0 19
29651: PPUSH
29652: LD_INT 1
29654: PPUSH
29655: LD_VAR 0 9
29659: PPUSH
29660: CALL_OW 2
29664: ST_TO_ADDR
29665: GO 29696
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29667: LD_ADDR_VAR 0 19
29671: PUSH
29672: LD_VAR 0 19
29676: PPUSH
29677: LD_VAR 0 19
29681: PUSH
29682: LD_INT 1
29684: PLUS
29685: PPUSH
29686: LD_VAR 0 9
29690: PPUSH
29691: CALL_OW 2
29695: ST_TO_ADDR
29696: GO 29624
29698: POP
29699: POP
// if tmp then
29700: LD_VAR 0 19
29704: IFFALSE 29716
// f := tmp ;
29706: LD_ADDR_VAR 0 12
29710: PUSH
29711: LD_VAR 0 19
29715: ST_TO_ADDR
// end ; x := personel [ i ] ;
29716: LD_ADDR_VAR 0 13
29720: PUSH
29721: LD_VAR 0 6
29725: PUSH
29726: LD_VAR 0 8
29730: ARRAY
29731: ST_TO_ADDR
// if x = - 1 then
29732: LD_VAR 0 13
29736: PUSH
29737: LD_INT 1
29739: NEG
29740: EQUAL
29741: IFFALSE 29952
// begin for j in f do
29743: LD_ADDR_VAR 0 9
29747: PUSH
29748: LD_VAR 0 12
29752: PUSH
29753: FOR_IN
29754: IFFALSE 29948
// repeat InitHc ;
29756: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29760: LD_VAR 0 9
29764: PPUSH
29765: CALL_OW 266
29769: PUSH
29770: LD_INT 5
29772: EQUAL
29773: IFFALSE 29843
// begin if UnitsInside ( j ) < 3 then
29775: LD_VAR 0 9
29779: PPUSH
29780: CALL_OW 313
29784: PUSH
29785: LD_INT 3
29787: LESS
29788: IFFALSE 29824
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29790: LD_INT 0
29792: PPUSH
29793: LD_INT 5
29795: PUSH
29796: LD_INT 8
29798: PUSH
29799: LD_INT 9
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: LIST
29806: PUSH
29807: LD_VAR 0 17
29811: ARRAY
29812: PPUSH
29813: LD_VAR 0 4
29817: PPUSH
29818: CALL_OW 380
29822: GO 29841
// PrepareHuman ( false , i , skill ) ;
29824: LD_INT 0
29826: PPUSH
29827: LD_VAR 0 8
29831: PPUSH
29832: LD_VAR 0 4
29836: PPUSH
29837: CALL_OW 380
// end else
29841: GO 29860
// PrepareHuman ( false , i , skill ) ;
29843: LD_INT 0
29845: PPUSH
29846: LD_VAR 0 8
29850: PPUSH
29851: LD_VAR 0 4
29855: PPUSH
29856: CALL_OW 380
// un := CreateHuman ;
29860: LD_ADDR_VAR 0 14
29864: PUSH
29865: CALL_OW 44
29869: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29870: LD_ADDR_VAR 0 7
29874: PUSH
29875: LD_VAR 0 7
29879: PPUSH
29880: LD_INT 1
29882: PPUSH
29883: LD_VAR 0 14
29887: PPUSH
29888: CALL_OW 2
29892: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29893: LD_VAR 0 14
29897: PPUSH
29898: LD_VAR 0 9
29902: PPUSH
29903: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29907: LD_VAR 0 9
29911: PPUSH
29912: CALL_OW 313
29916: PUSH
29917: LD_INT 6
29919: EQUAL
29920: IFTRUE 29944
29922: PUSH
29923: LD_VAR 0 9
29927: PPUSH
29928: CALL_OW 266
29932: PUSH
29933: LD_INT 32
29935: PUSH
29936: LD_INT 31
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: IN
29943: OR
29944: IFFALSE 29756
29946: GO 29753
29948: POP
29949: POP
// end else
29950: GO 30336
// for j = 1 to x do
29952: LD_ADDR_VAR 0 9
29956: PUSH
29957: DOUBLE
29958: LD_INT 1
29960: DEC
29961: ST_TO_ADDR
29962: LD_VAR 0 13
29966: PUSH
29967: FOR_TO
29968: IFFALSE 30334
// begin InitHc ;
29970: CALL_OW 19
// if not f then
29974: LD_VAR 0 12
29978: NOT
29979: IFFALSE 30068
// begin PrepareHuman ( false , i , skill ) ;
29981: LD_INT 0
29983: PPUSH
29984: LD_VAR 0 8
29988: PPUSH
29989: LD_VAR 0 4
29993: PPUSH
29994: CALL_OW 380
// un := CreateHuman ;
29998: LD_ADDR_VAR 0 14
30002: PUSH
30003: CALL_OW 44
30007: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
30008: LD_ADDR_VAR 0 7
30012: PUSH
30013: LD_VAR 0 7
30017: PPUSH
30018: LD_INT 1
30020: PPUSH
30021: LD_VAR 0 14
30025: PPUSH
30026: CALL_OW 2
30030: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
30031: LD_VAR 0 14
30035: PPUSH
30036: LD_VAR 0 1
30040: PPUSH
30041: CALL_OW 250
30045: PPUSH
30046: LD_VAR 0 1
30050: PPUSH
30051: CALL_OW 251
30055: PPUSH
30056: LD_INT 10
30058: PPUSH
30059: LD_INT 0
30061: PPUSH
30062: CALL_OW 50
// continue ;
30066: GO 29967
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
30068: LD_VAR 0 12
30072: PUSH
30073: LD_INT 1
30075: ARRAY
30076: PPUSH
30077: CALL_OW 313
30081: IFFALSE 30109
30083: PUSH
30084: LD_VAR 0 12
30088: PUSH
30089: LD_INT 1
30091: ARRAY
30092: PPUSH
30093: CALL_OW 266
30097: PUSH
30098: LD_INT 32
30100: PUSH
30101: LD_INT 31
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: IN
30108: AND
30109: IFTRUE 30130
30111: PUSH
30112: LD_VAR 0 12
30116: PUSH
30117: LD_INT 1
30119: ARRAY
30120: PPUSH
30121: CALL_OW 313
30125: PUSH
30126: LD_INT 6
30128: EQUAL
30129: OR
30130: IFFALSE 30150
// f := Delete ( f , 1 ) ;
30132: LD_ADDR_VAR 0 12
30136: PUSH
30137: LD_VAR 0 12
30141: PPUSH
30142: LD_INT 1
30144: PPUSH
30145: CALL_OW 3
30149: ST_TO_ADDR
// if not f then
30150: LD_VAR 0 12
30154: NOT
30155: IFFALSE 30173
// begin x := x + 2 ;
30157: LD_ADDR_VAR 0 13
30161: PUSH
30162: LD_VAR 0 13
30166: PUSH
30167: LD_INT 2
30169: PLUS
30170: ST_TO_ADDR
// continue ;
30171: GO 29967
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
30173: LD_VAR 0 12
30177: PUSH
30178: LD_INT 1
30180: ARRAY
30181: PPUSH
30182: CALL_OW 266
30186: PUSH
30187: LD_INT 5
30189: EQUAL
30190: IFFALSE 30264
// begin if UnitsInside ( f [ 1 ] ) < 3 then
30192: LD_VAR 0 12
30196: PUSH
30197: LD_INT 1
30199: ARRAY
30200: PPUSH
30201: CALL_OW 313
30205: PUSH
30206: LD_INT 3
30208: LESS
30209: IFFALSE 30245
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
30211: LD_INT 0
30213: PPUSH
30214: LD_INT 5
30216: PUSH
30217: LD_INT 8
30219: PUSH
30220: LD_INT 9
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: LIST
30227: PUSH
30228: LD_VAR 0 17
30232: ARRAY
30233: PPUSH
30234: LD_VAR 0 4
30238: PPUSH
30239: CALL_OW 380
30243: GO 30262
// PrepareHuman ( false , i , skill ) ;
30245: LD_INT 0
30247: PPUSH
30248: LD_VAR 0 8
30252: PPUSH
30253: LD_VAR 0 4
30257: PPUSH
30258: CALL_OW 380
// end else
30262: GO 30281
// PrepareHuman ( false , i , skill ) ;
30264: LD_INT 0
30266: PPUSH
30267: LD_VAR 0 8
30271: PPUSH
30272: LD_VAR 0 4
30276: PPUSH
30277: CALL_OW 380
// un := CreateHuman ;
30281: LD_ADDR_VAR 0 14
30285: PUSH
30286: CALL_OW 44
30290: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
30291: LD_ADDR_VAR 0 7
30295: PUSH
30296: LD_VAR 0 7
30300: PPUSH
30301: LD_INT 1
30303: PPUSH
30304: LD_VAR 0 14
30308: PPUSH
30309: CALL_OW 2
30313: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
30314: LD_VAR 0 14
30318: PPUSH
30319: LD_VAR 0 12
30323: PUSH
30324: LD_INT 1
30326: ARRAY
30327: PPUSH
30328: CALL_OW 52
// end ;
30332: GO 29967
30334: POP
30335: POP
// end ;
30336: GO 29267
30338: POP
30339: POP
// result := result ^ buildings ;
30340: LD_ADDR_VAR 0 7
30344: PUSH
30345: LD_VAR 0 7
30349: PUSH
30350: LD_VAR 0 18
30354: ADD
30355: ST_TO_ADDR
// end else
30356: GO 30499
// begin for i = 1 to personel do
30358: LD_ADDR_VAR 0 8
30362: PUSH
30363: DOUBLE
30364: LD_INT 1
30366: DEC
30367: ST_TO_ADDR
30368: LD_VAR 0 6
30372: PUSH
30373: FOR_TO
30374: IFFALSE 30497
// begin if i > 4 then
30376: LD_VAR 0 8
30380: PUSH
30381: LD_INT 4
30383: GREATER
30384: IFFALSE 30388
// break ;
30386: GO 30497
// x := personel [ i ] ;
30388: LD_ADDR_VAR 0 13
30392: PUSH
30393: LD_VAR 0 6
30397: PUSH
30398: LD_VAR 0 8
30402: ARRAY
30403: ST_TO_ADDR
// if x = - 1 then
30404: LD_VAR 0 13
30408: PUSH
30409: LD_INT 1
30411: NEG
30412: EQUAL
30413: IFFALSE 30417
// continue ;
30415: GO 30373
// PrepareHuman ( false , i , skill ) ;
30417: LD_INT 0
30419: PPUSH
30420: LD_VAR 0 8
30424: PPUSH
30425: LD_VAR 0 4
30429: PPUSH
30430: CALL_OW 380
// un := CreateHuman ;
30434: LD_ADDR_VAR 0 14
30438: PUSH
30439: CALL_OW 44
30443: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
30444: LD_VAR 0 14
30448: PPUSH
30449: LD_VAR 0 1
30453: PPUSH
30454: CALL_OW 250
30458: PPUSH
30459: LD_VAR 0 1
30463: PPUSH
30464: CALL_OW 251
30468: PPUSH
30469: LD_INT 10
30471: PPUSH
30472: LD_INT 0
30474: PPUSH
30475: CALL_OW 50
// result := result ^ un ;
30479: LD_ADDR_VAR 0 7
30483: PUSH
30484: LD_VAR 0 7
30488: PUSH
30489: LD_VAR 0 14
30493: ADD
30494: ST_TO_ADDR
// end ;
30495: GO 30373
30497: POP
30498: POP
// end ; end ;
30499: LD_VAR 0 7
30503: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30504: LD_INT 0
30506: PPUSH
30507: PPUSH
30508: PPUSH
30509: PPUSH
30510: PPUSH
30511: PPUSH
30512: PPUSH
30513: PPUSH
30514: PPUSH
30515: PPUSH
30516: PPUSH
30517: PPUSH
30518: PPUSH
30519: PPUSH
30520: PPUSH
30521: PPUSH
// result := false ;
30522: LD_ADDR_VAR 0 3
30526: PUSH
30527: LD_INT 0
30529: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30530: LD_VAR 0 1
30534: NOT
30535: IFTRUE 30560
30537: PUSH
30538: LD_VAR 0 1
30542: PPUSH
30543: CALL_OW 266
30547: PUSH
30548: LD_INT 32
30550: PUSH
30551: LD_INT 33
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: IN
30558: NOT
30559: OR
30560: IFFALSE 30564
// exit ;
30562: GO 31699
// nat := GetNation ( tower ) ;
30564: LD_ADDR_VAR 0 12
30568: PUSH
30569: LD_VAR 0 1
30573: PPUSH
30574: CALL_OW 248
30578: ST_TO_ADDR
// side := GetSide ( tower ) ;
30579: LD_ADDR_VAR 0 16
30583: PUSH
30584: LD_VAR 0 1
30588: PPUSH
30589: CALL_OW 255
30593: ST_TO_ADDR
// x := GetX ( tower ) ;
30594: LD_ADDR_VAR 0 10
30598: PUSH
30599: LD_VAR 0 1
30603: PPUSH
30604: CALL_OW 250
30608: ST_TO_ADDR
// y := GetY ( tower ) ;
30609: LD_ADDR_VAR 0 11
30613: PUSH
30614: LD_VAR 0 1
30618: PPUSH
30619: CALL_OW 251
30623: ST_TO_ADDR
// if not x or not y then
30624: LD_VAR 0 10
30628: NOT
30629: IFTRUE 30638
30631: PUSH
30632: LD_VAR 0 11
30636: NOT
30637: OR
30638: IFFALSE 30642
// exit ;
30640: GO 31699
// weapon := 0 ;
30642: LD_ADDR_VAR 0 18
30646: PUSH
30647: LD_INT 0
30649: ST_TO_ADDR
// fac_list := [ ] ;
30650: LD_ADDR_VAR 0 17
30654: PUSH
30655: EMPTY
30656: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30657: LD_ADDR_VAR 0 6
30661: PUSH
30662: LD_VAR 0 1
30666: PPUSH
30667: CALL_OW 274
30671: PPUSH
30672: LD_VAR 0 2
30676: PPUSH
30677: LD_INT 0
30679: PPUSH
30680: CALL 28234 0 3
30684: PPUSH
30685: LD_INT 30
30687: PUSH
30688: LD_INT 3
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PPUSH
30695: CALL_OW 72
30699: ST_TO_ADDR
// if not factories then
30700: LD_VAR 0 6
30704: NOT
30705: IFFALSE 30709
// exit ;
30707: GO 31699
// for i in factories do
30709: LD_ADDR_VAR 0 8
30713: PUSH
30714: LD_VAR 0 6
30718: PUSH
30719: FOR_IN
30720: IFFALSE 30745
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30722: LD_ADDR_VAR 0 17
30726: PUSH
30727: LD_VAR 0 17
30731: PUSH
30732: LD_VAR 0 8
30736: PPUSH
30737: CALL_OW 478
30741: UNION
30742: ST_TO_ADDR
30743: GO 30719
30745: POP
30746: POP
// if not fac_list then
30747: LD_VAR 0 17
30751: NOT
30752: IFFALSE 30756
// exit ;
30754: GO 31699
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30756: LD_ADDR_VAR 0 5
30760: PUSH
30761: LD_INT 4
30763: PUSH
30764: LD_INT 5
30766: PUSH
30767: LD_INT 9
30769: PUSH
30770: LD_INT 10
30772: PUSH
30773: LD_INT 6
30775: PUSH
30776: LD_INT 7
30778: PUSH
30779: LD_INT 11
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: LIST
30786: LIST
30787: LIST
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 27
30793: PUSH
30794: LD_INT 28
30796: PUSH
30797: LD_INT 26
30799: PUSH
30800: LD_INT 30
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 43
30811: PUSH
30812: LD_INT 44
30814: PUSH
30815: LD_INT 46
30817: PUSH
30818: LD_INT 45
30820: PUSH
30821: LD_INT 47
30823: PUSH
30824: LD_INT 49
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: LIST
30839: PUSH
30840: LD_VAR 0 12
30844: ARRAY
30845: ST_TO_ADDR
// list := list isect fac_list ;
30846: LD_ADDR_VAR 0 5
30850: PUSH
30851: LD_VAR 0 5
30855: PUSH
30856: LD_VAR 0 17
30860: ISECT
30861: ST_TO_ADDR
// if not list then
30862: LD_VAR 0 5
30866: NOT
30867: IFFALSE 30871
// exit ;
30869: GO 31699
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30871: LD_VAR 0 12
30875: PUSH
30876: LD_INT 3
30878: EQUAL
30879: IFFALSE 30891
30881: PUSH
30882: LD_INT 49
30884: PUSH
30885: LD_VAR 0 5
30889: IN
30890: AND
30891: IFFALSE 30911
30893: PUSH
30894: LD_INT 31
30896: PPUSH
30897: LD_VAR 0 16
30901: PPUSH
30902: CALL_OW 321
30906: PUSH
30907: LD_INT 2
30909: EQUAL
30910: AND
30911: IFFALSE 30971
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30913: LD_INT 22
30915: PUSH
30916: LD_VAR 0 16
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 35
30927: PUSH
30928: LD_INT 49
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 91
30937: PUSH
30938: LD_VAR 0 1
30942: PUSH
30943: LD_INT 10
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: LIST
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: LIST
30955: PPUSH
30956: CALL_OW 69
30960: NOT
30961: IFFALSE 30971
// weapon := ru_time_lapser ;
30963: LD_ADDR_VAR 0 18
30967: PUSH
30968: LD_INT 49
30970: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30971: LD_VAR 0 12
30975: PUSH
30976: LD_INT 1
30978: PUSH
30979: LD_INT 2
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: IN
30986: IFFALSE 31010
30988: PUSH
30989: LD_INT 11
30991: PUSH
30992: LD_VAR 0 5
30996: IN
30997: IFTRUE 31009
30999: PUSH
31000: LD_INT 30
31002: PUSH
31003: LD_VAR 0 5
31007: IN
31008: OR
31009: AND
31010: IFFALSE 31030
31012: PUSH
31013: LD_INT 6
31015: PPUSH
31016: LD_VAR 0 16
31020: PPUSH
31021: CALL_OW 321
31025: PUSH
31026: LD_INT 2
31028: EQUAL
31029: AND
31030: IFFALSE 31197
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
31032: LD_INT 22
31034: PUSH
31035: LD_VAR 0 16
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 2
31046: PUSH
31047: LD_INT 35
31049: PUSH
31050: LD_INT 11
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 35
31059: PUSH
31060: LD_INT 30
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 91
31074: PUSH
31075: LD_VAR 0 1
31079: PUSH
31080: LD_INT 18
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: LIST
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: LIST
31092: PPUSH
31093: CALL_OW 69
31097: NOT
31098: IFFALSE 31174
31100: PUSH
31101: LD_INT 22
31103: PUSH
31104: LD_VAR 0 16
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 2
31115: PUSH
31116: LD_INT 30
31118: PUSH
31119: LD_INT 32
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 30
31128: PUSH
31129: LD_INT 33
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 91
31143: PUSH
31144: LD_VAR 0 1
31148: PUSH
31149: LD_INT 12
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: LIST
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: LIST
31161: PUSH
31162: EMPTY
31163: LIST
31164: PPUSH
31165: CALL_OW 69
31169: PUSH
31170: LD_INT 2
31172: GREATER
31173: AND
31174: IFFALSE 31197
// weapon := [ us_radar , ar_radar ] [ nat ] ;
31176: LD_ADDR_VAR 0 18
31180: PUSH
31181: LD_INT 11
31183: PUSH
31184: LD_INT 30
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PUSH
31191: LD_VAR 0 12
31195: ARRAY
31196: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
31197: LD_VAR 0 18
31201: NOT
31202: IFFALSE 31222
31204: PUSH
31205: LD_INT 40
31207: PPUSH
31208: LD_VAR 0 16
31212: PPUSH
31213: CALL_OW 321
31217: PUSH
31218: LD_INT 2
31220: EQUAL
31221: AND
31222: IFFALSE 31258
31224: PUSH
31225: LD_INT 7
31227: PUSH
31228: LD_VAR 0 5
31232: IN
31233: IFTRUE 31245
31235: PUSH
31236: LD_INT 28
31238: PUSH
31239: LD_VAR 0 5
31243: IN
31244: OR
31245: IFTRUE 31257
31247: PUSH
31248: LD_INT 45
31250: PUSH
31251: LD_VAR 0 5
31255: IN
31256: OR
31257: AND
31258: IFFALSE 31512
// begin hex := GetHexInfo ( x , y ) ;
31260: LD_ADDR_VAR 0 4
31264: PUSH
31265: LD_VAR 0 10
31269: PPUSH
31270: LD_VAR 0 11
31274: PPUSH
31275: CALL_OW 546
31279: ST_TO_ADDR
// if hex [ 1 ] then
31280: LD_VAR 0 4
31284: PUSH
31285: LD_INT 1
31287: ARRAY
31288: IFFALSE 31292
// exit ;
31290: GO 31699
// height := hex [ 2 ] ;
31292: LD_ADDR_VAR 0 15
31296: PUSH
31297: LD_VAR 0 4
31301: PUSH
31302: LD_INT 2
31304: ARRAY
31305: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
31306: LD_ADDR_VAR 0 14
31310: PUSH
31311: LD_INT 0
31313: PUSH
31314: LD_INT 2
31316: PUSH
31317: LD_INT 3
31319: PUSH
31320: LD_INT 5
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: ST_TO_ADDR
// for i in tmp do
31329: LD_ADDR_VAR 0 8
31333: PUSH
31334: LD_VAR 0 14
31338: PUSH
31339: FOR_IN
31340: IFFALSE 31510
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
31342: LD_ADDR_VAR 0 9
31346: PUSH
31347: LD_VAR 0 10
31351: PPUSH
31352: LD_VAR 0 8
31356: PPUSH
31357: LD_INT 5
31359: PPUSH
31360: CALL_OW 272
31364: PUSH
31365: LD_VAR 0 11
31369: PPUSH
31370: LD_VAR 0 8
31374: PPUSH
31375: LD_INT 5
31377: PPUSH
31378: CALL_OW 273
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
31387: LD_VAR 0 9
31391: PUSH
31392: LD_INT 1
31394: ARRAY
31395: PPUSH
31396: LD_VAR 0 9
31400: PUSH
31401: LD_INT 2
31403: ARRAY
31404: PPUSH
31405: CALL_OW 488
31409: IFFALSE 31508
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
31411: LD_ADDR_VAR 0 4
31415: PUSH
31416: LD_VAR 0 9
31420: PUSH
31421: LD_INT 1
31423: ARRAY
31424: PPUSH
31425: LD_VAR 0 9
31429: PUSH
31430: LD_INT 2
31432: ARRAY
31433: PPUSH
31434: CALL_OW 546
31438: ST_TO_ADDR
// if hex [ 1 ] then
31439: LD_VAR 0 4
31443: PUSH
31444: LD_INT 1
31446: ARRAY
31447: IFFALSE 31451
// continue ;
31449: GO 31339
// h := hex [ 2 ] ;
31451: LD_ADDR_VAR 0 13
31455: PUSH
31456: LD_VAR 0 4
31460: PUSH
31461: LD_INT 2
31463: ARRAY
31464: ST_TO_ADDR
// if h + 7 < height then
31465: LD_VAR 0 13
31469: PUSH
31470: LD_INT 7
31472: PLUS
31473: PUSH
31474: LD_VAR 0 15
31478: LESS
31479: IFFALSE 31508
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
31481: LD_ADDR_VAR 0 18
31485: PUSH
31486: LD_INT 7
31488: PUSH
31489: LD_INT 28
31491: PUSH
31492: LD_INT 45
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: LIST
31499: PUSH
31500: LD_VAR 0 12
31504: ARRAY
31505: ST_TO_ADDR
// break ;
31506: GO 31510
// end ; end ; end ;
31508: GO 31339
31510: POP
31511: POP
// end ; if not weapon then
31512: LD_VAR 0 18
31516: NOT
31517: IFFALSE 31577
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31519: LD_ADDR_VAR 0 5
31523: PUSH
31524: LD_VAR 0 5
31528: PUSH
31529: LD_INT 11
31531: PUSH
31532: LD_INT 30
31534: PUSH
31535: LD_INT 49
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: LIST
31542: DIFF
31543: ST_TO_ADDR
// if not list then
31544: LD_VAR 0 5
31548: NOT
31549: IFFALSE 31553
// exit ;
31551: GO 31699
// weapon := list [ rand ( 1 , list ) ] ;
31553: LD_ADDR_VAR 0 18
31557: PUSH
31558: LD_VAR 0 5
31562: PUSH
31563: LD_INT 1
31565: PPUSH
31566: LD_VAR 0 5
31570: PPUSH
31571: CALL_OW 12
31575: ARRAY
31576: ST_TO_ADDR
// end ; if weapon then
31577: LD_VAR 0 18
31581: IFFALSE 31699
// begin tmp := CostOfWeapon ( weapon ) ;
31583: LD_ADDR_VAR 0 14
31587: PUSH
31588: LD_VAR 0 18
31592: PPUSH
31593: CALL_OW 451
31597: ST_TO_ADDR
// j := GetBase ( tower ) ;
31598: LD_ADDR_VAR 0 9
31602: PUSH
31603: LD_VAR 0 1
31607: PPUSH
31608: CALL_OW 274
31612: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31613: LD_VAR 0 9
31617: PPUSH
31618: LD_INT 1
31620: PPUSH
31621: CALL_OW 275
31625: PUSH
31626: LD_VAR 0 14
31630: PUSH
31631: LD_INT 1
31633: ARRAY
31634: GREATEREQUAL
31635: IFFALSE 31661
31637: PUSH
31638: LD_VAR 0 9
31642: PPUSH
31643: LD_INT 2
31645: PPUSH
31646: CALL_OW 275
31650: PUSH
31651: LD_VAR 0 14
31655: PUSH
31656: LD_INT 2
31658: ARRAY
31659: GREATEREQUAL
31660: AND
31661: IFFALSE 31687
31663: PUSH
31664: LD_VAR 0 9
31668: PPUSH
31669: LD_INT 3
31671: PPUSH
31672: CALL_OW 275
31676: PUSH
31677: LD_VAR 0 14
31681: PUSH
31682: LD_INT 3
31684: ARRAY
31685: GREATEREQUAL
31686: AND
31687: IFFALSE 31699
// result := weapon ;
31689: LD_ADDR_VAR 0 3
31693: PUSH
31694: LD_VAR 0 18
31698: ST_TO_ADDR
// end ; end ;
31699: LD_VAR 0 3
31703: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31704: LD_INT 0
31706: PPUSH
31707: PPUSH
// result := true ;
31708: LD_ADDR_VAR 0 3
31712: PUSH
31713: LD_INT 1
31715: ST_TO_ADDR
// if array1 = array2 then
31716: LD_VAR 0 1
31720: PUSH
31721: LD_VAR 0 2
31725: EQUAL
31726: IFFALSE 31786
// begin for i = 1 to array1 do
31728: LD_ADDR_VAR 0 4
31732: PUSH
31733: DOUBLE
31734: LD_INT 1
31736: DEC
31737: ST_TO_ADDR
31738: LD_VAR 0 1
31742: PUSH
31743: FOR_TO
31744: IFFALSE 31782
// if array1 [ i ] <> array2 [ i ] then
31746: LD_VAR 0 1
31750: PUSH
31751: LD_VAR 0 4
31755: ARRAY
31756: PUSH
31757: LD_VAR 0 2
31761: PUSH
31762: LD_VAR 0 4
31766: ARRAY
31767: NONEQUAL
31768: IFFALSE 31780
// begin result := false ;
31770: LD_ADDR_VAR 0 3
31774: PUSH
31775: LD_INT 0
31777: ST_TO_ADDR
// break ;
31778: GO 31782
// end ;
31780: GO 31743
31782: POP
31783: POP
// end else
31784: GO 31794
// result := false ;
31786: LD_ADDR_VAR 0 3
31790: PUSH
31791: LD_INT 0
31793: ST_TO_ADDR
// end ;
31794: LD_VAR 0 3
31798: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31799: LD_INT 0
31801: PPUSH
31802: PPUSH
// if not array1 or not array2 then
31803: LD_VAR 0 1
31807: NOT
31808: IFTRUE 31817
31810: PUSH
31811: LD_VAR 0 2
31815: NOT
31816: OR
31817: IFFALSE 31821
// exit ;
31819: GO 31885
// result := true ;
31821: LD_ADDR_VAR 0 3
31825: PUSH
31826: LD_INT 1
31828: ST_TO_ADDR
// for i = 1 to array1 do
31829: LD_ADDR_VAR 0 4
31833: PUSH
31834: DOUBLE
31835: LD_INT 1
31837: DEC
31838: ST_TO_ADDR
31839: LD_VAR 0 1
31843: PUSH
31844: FOR_TO
31845: IFFALSE 31883
// if array1 [ i ] <> array2 [ i ] then
31847: LD_VAR 0 1
31851: PUSH
31852: LD_VAR 0 4
31856: ARRAY
31857: PUSH
31858: LD_VAR 0 2
31862: PUSH
31863: LD_VAR 0 4
31867: ARRAY
31868: NONEQUAL
31869: IFFALSE 31881
// begin result := false ;
31871: LD_ADDR_VAR 0 3
31875: PUSH
31876: LD_INT 0
31878: ST_TO_ADDR
// break ;
31879: GO 31883
// end ;
31881: GO 31844
31883: POP
31884: POP
// end ;
31885: LD_VAR 0 3
31889: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31890: LD_INT 0
31892: PPUSH
31893: PPUSH
31894: PPUSH
// pom := GetBase ( fac ) ;
31895: LD_ADDR_VAR 0 5
31899: PUSH
31900: LD_VAR 0 1
31904: PPUSH
31905: CALL_OW 274
31909: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31910: LD_ADDR_VAR 0 4
31914: PUSH
31915: LD_VAR 0 2
31919: PUSH
31920: LD_INT 1
31922: ARRAY
31923: PPUSH
31924: LD_VAR 0 2
31928: PUSH
31929: LD_INT 2
31931: ARRAY
31932: PPUSH
31933: LD_VAR 0 2
31937: PUSH
31938: LD_INT 3
31940: ARRAY
31941: PPUSH
31942: LD_VAR 0 2
31946: PUSH
31947: LD_INT 4
31949: ARRAY
31950: PPUSH
31951: CALL_OW 449
31955: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31956: LD_ADDR_VAR 0 3
31960: PUSH
31961: LD_VAR 0 5
31965: PPUSH
31966: LD_INT 1
31968: PPUSH
31969: CALL_OW 275
31973: PUSH
31974: LD_VAR 0 4
31978: PUSH
31979: LD_INT 1
31981: ARRAY
31982: GREATEREQUAL
31983: IFFALSE 32009
31985: PUSH
31986: LD_VAR 0 5
31990: PPUSH
31991: LD_INT 2
31993: PPUSH
31994: CALL_OW 275
31998: PUSH
31999: LD_VAR 0 4
32003: PUSH
32004: LD_INT 2
32006: ARRAY
32007: GREATEREQUAL
32008: AND
32009: IFFALSE 32035
32011: PUSH
32012: LD_VAR 0 5
32016: PPUSH
32017: LD_INT 3
32019: PPUSH
32020: CALL_OW 275
32024: PUSH
32025: LD_VAR 0 4
32029: PUSH
32030: LD_INT 3
32032: ARRAY
32033: GREATEREQUAL
32034: AND
32035: ST_TO_ADDR
// end ;
32036: LD_VAR 0 3
32040: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
32041: LD_INT 0
32043: PPUSH
32044: PPUSH
32045: PPUSH
32046: PPUSH
// pom := GetBase ( building ) ;
32047: LD_ADDR_VAR 0 3
32051: PUSH
32052: LD_VAR 0 1
32056: PPUSH
32057: CALL_OW 274
32061: ST_TO_ADDR
// if not pom then
32062: LD_VAR 0 3
32066: NOT
32067: IFFALSE 32071
// exit ;
32069: GO 32245
// btype := GetBType ( building ) ;
32071: LD_ADDR_VAR 0 5
32075: PUSH
32076: LD_VAR 0 1
32080: PPUSH
32081: CALL_OW 266
32085: ST_TO_ADDR
// if btype = b_armoury then
32086: LD_VAR 0 5
32090: PUSH
32091: LD_INT 4
32093: EQUAL
32094: IFFALSE 32104
// btype := b_barracks ;
32096: LD_ADDR_VAR 0 5
32100: PUSH
32101: LD_INT 5
32103: ST_TO_ADDR
// if btype = b_depot then
32104: LD_VAR 0 5
32108: PUSH
32109: LD_INT 0
32111: EQUAL
32112: IFFALSE 32122
// btype := b_warehouse ;
32114: LD_ADDR_VAR 0 5
32118: PUSH
32119: LD_INT 1
32121: ST_TO_ADDR
// if btype = b_workshop then
32122: LD_VAR 0 5
32126: PUSH
32127: LD_INT 2
32129: EQUAL
32130: IFFALSE 32140
// btype := b_factory ;
32132: LD_ADDR_VAR 0 5
32136: PUSH
32137: LD_INT 3
32139: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
32140: LD_ADDR_VAR 0 4
32144: PUSH
32145: LD_VAR 0 5
32149: PPUSH
32150: LD_VAR 0 1
32154: PPUSH
32155: CALL_OW 248
32159: PPUSH
32160: CALL_OW 450
32164: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
32165: LD_ADDR_VAR 0 2
32169: PUSH
32170: LD_VAR 0 3
32174: PPUSH
32175: LD_INT 1
32177: PPUSH
32178: CALL_OW 275
32182: PUSH
32183: LD_VAR 0 4
32187: PUSH
32188: LD_INT 1
32190: ARRAY
32191: GREATEREQUAL
32192: IFFALSE 32218
32194: PUSH
32195: LD_VAR 0 3
32199: PPUSH
32200: LD_INT 2
32202: PPUSH
32203: CALL_OW 275
32207: PUSH
32208: LD_VAR 0 4
32212: PUSH
32213: LD_INT 2
32215: ARRAY
32216: GREATEREQUAL
32217: AND
32218: IFFALSE 32244
32220: PUSH
32221: LD_VAR 0 3
32225: PPUSH
32226: LD_INT 3
32228: PPUSH
32229: CALL_OW 275
32233: PUSH
32234: LD_VAR 0 4
32238: PUSH
32239: LD_INT 3
32241: ARRAY
32242: GREATEREQUAL
32243: AND
32244: ST_TO_ADDR
// end ;
32245: LD_VAR 0 2
32249: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
32250: LD_INT 0
32252: PPUSH
32253: PPUSH
32254: PPUSH
// pom := GetBase ( building ) ;
32255: LD_ADDR_VAR 0 4
32259: PUSH
32260: LD_VAR 0 1
32264: PPUSH
32265: CALL_OW 274
32269: ST_TO_ADDR
// if not pom then
32270: LD_VAR 0 4
32274: NOT
32275: IFFALSE 32279
// exit ;
32277: GO 32384
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
32279: LD_ADDR_VAR 0 5
32283: PUSH
32284: LD_VAR 0 2
32288: PPUSH
32289: LD_VAR 0 1
32293: PPUSH
32294: CALL_OW 248
32298: PPUSH
32299: CALL_OW 450
32303: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
32304: LD_ADDR_VAR 0 3
32308: PUSH
32309: LD_VAR 0 4
32313: PPUSH
32314: LD_INT 1
32316: PPUSH
32317: CALL_OW 275
32321: PUSH
32322: LD_VAR 0 5
32326: PUSH
32327: LD_INT 1
32329: ARRAY
32330: GREATEREQUAL
32331: IFFALSE 32357
32333: PUSH
32334: LD_VAR 0 4
32338: PPUSH
32339: LD_INT 2
32341: PPUSH
32342: CALL_OW 275
32346: PUSH
32347: LD_VAR 0 5
32351: PUSH
32352: LD_INT 2
32354: ARRAY
32355: GREATEREQUAL
32356: AND
32357: IFFALSE 32383
32359: PUSH
32360: LD_VAR 0 4
32364: PPUSH
32365: LD_INT 3
32367: PPUSH
32368: CALL_OW 275
32372: PUSH
32373: LD_VAR 0 5
32377: PUSH
32378: LD_INT 3
32380: ARRAY
32381: GREATEREQUAL
32382: AND
32383: ST_TO_ADDR
// end ;
32384: LD_VAR 0 3
32388: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
32389: LD_INT 0
32391: PPUSH
32392: PPUSH
32393: PPUSH
32394: PPUSH
32395: PPUSH
32396: PPUSH
32397: PPUSH
32398: PPUSH
32399: PPUSH
32400: PPUSH
32401: PPUSH
// result := false ;
32402: LD_ADDR_VAR 0 8
32406: PUSH
32407: LD_INT 0
32409: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
32410: LD_VAR 0 5
32414: NOT
32415: IFTRUE 32424
32417: PUSH
32418: LD_VAR 0 1
32422: NOT
32423: OR
32424: IFTRUE 32433
32426: PUSH
32427: LD_VAR 0 2
32431: NOT
32432: OR
32433: IFTRUE 32442
32435: PUSH
32436: LD_VAR 0 3
32440: NOT
32441: OR
32442: IFFALSE 32446
// exit ;
32444: GO 33272
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
32446: LD_ADDR_VAR 0 14
32450: PUSH
32451: LD_VAR 0 1
32455: PPUSH
32456: LD_VAR 0 2
32460: PPUSH
32461: LD_VAR 0 3
32465: PPUSH
32466: LD_VAR 0 4
32470: PPUSH
32471: LD_VAR 0 5
32475: PUSH
32476: LD_INT 1
32478: ARRAY
32479: PPUSH
32480: CALL_OW 248
32484: PPUSH
32485: LD_INT 0
32487: PPUSH
32488: CALL 34553 0 6
32492: ST_TO_ADDR
// if not hexes then
32493: LD_VAR 0 14
32497: NOT
32498: IFFALSE 32502
// exit ;
32500: GO 33272
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
32502: LD_ADDR_VAR 0 17
32506: PUSH
32507: LD_VAR 0 5
32511: PPUSH
32512: LD_INT 22
32514: PUSH
32515: LD_VAR 0 13
32519: PPUSH
32520: CALL_OW 255
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 2
32531: PUSH
32532: LD_INT 30
32534: PUSH
32535: LD_INT 0
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 30
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: LIST
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PPUSH
32561: CALL_OW 72
32565: ST_TO_ADDR
// for i = 1 to hexes do
32566: LD_ADDR_VAR 0 9
32570: PUSH
32571: DOUBLE
32572: LD_INT 1
32574: DEC
32575: ST_TO_ADDR
32576: LD_VAR 0 14
32580: PUSH
32581: FOR_TO
32582: IFFALSE 33270
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32584: LD_ADDR_VAR 0 13
32588: PUSH
32589: LD_VAR 0 14
32593: PUSH
32594: LD_VAR 0 9
32598: ARRAY
32599: PUSH
32600: LD_INT 1
32602: ARRAY
32603: PPUSH
32604: LD_VAR 0 14
32608: PUSH
32609: LD_VAR 0 9
32613: ARRAY
32614: PUSH
32615: LD_INT 2
32617: ARRAY
32618: PPUSH
32619: CALL_OW 428
32623: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32624: LD_VAR 0 14
32628: PUSH
32629: LD_VAR 0 9
32633: ARRAY
32634: PUSH
32635: LD_INT 1
32637: ARRAY
32638: PPUSH
32639: LD_VAR 0 14
32643: PUSH
32644: LD_VAR 0 9
32648: ARRAY
32649: PUSH
32650: LD_INT 2
32652: ARRAY
32653: PPUSH
32654: CALL_OW 351
32658: IFTRUE 32697
32660: PUSH
32661: LD_VAR 0 14
32665: PUSH
32666: LD_VAR 0 9
32670: ARRAY
32671: PUSH
32672: LD_INT 1
32674: ARRAY
32675: PPUSH
32676: LD_VAR 0 14
32680: PUSH
32681: LD_VAR 0 9
32685: ARRAY
32686: PUSH
32687: LD_INT 2
32689: ARRAY
32690: PPUSH
32691: CALL_OW 488
32695: NOT
32696: OR
32697: IFTRUE 32714
32699: PUSH
32700: LD_VAR 0 13
32704: PPUSH
32705: CALL_OW 247
32709: PUSH
32710: LD_INT 3
32712: EQUAL
32713: OR
32714: IFFALSE 32720
// exit ;
32716: POP
32717: POP
32718: GO 33272
// if not tmp then
32720: LD_VAR 0 13
32724: NOT
32725: IFFALSE 32729
// continue ;
32727: GO 32581
// result := true ;
32729: LD_ADDR_VAR 0 8
32733: PUSH
32734: LD_INT 1
32736: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32737: LD_VAR 0 6
32741: IFFALSE 32758
32743: PUSH
32744: LD_VAR 0 13
32748: PPUSH
32749: CALL_OW 247
32753: PUSH
32754: LD_INT 2
32756: EQUAL
32757: AND
32758: IFFALSE 32775
32760: PUSH
32761: LD_VAR 0 13
32765: PPUSH
32766: CALL_OW 263
32770: PUSH
32771: LD_INT 1
32773: EQUAL
32774: AND
32775: IFFALSE 32939
// begin if IsDrivenBy ( tmp ) then
32777: LD_VAR 0 13
32781: PPUSH
32782: CALL_OW 311
32786: IFFALSE 32790
// continue ;
32788: GO 32581
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32790: LD_VAR 0 6
32794: PPUSH
32795: LD_INT 3
32797: PUSH
32798: LD_INT 60
32800: PUSH
32801: EMPTY
32802: LIST
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 3
32810: PUSH
32811: LD_INT 55
32813: PUSH
32814: EMPTY
32815: LIST
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PPUSH
32825: CALL_OW 72
32829: IFFALSE 32937
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32831: LD_ADDR_VAR 0 18
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_INT 3
32843: PUSH
32844: LD_INT 60
32846: PUSH
32847: EMPTY
32848: LIST
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 3
32856: PUSH
32857: LD_INT 55
32859: PUSH
32860: EMPTY
32861: LIST
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PPUSH
32871: CALL_OW 72
32875: PUSH
32876: LD_INT 1
32878: ARRAY
32879: ST_TO_ADDR
// if IsInUnit ( driver ) then
32880: LD_VAR 0 18
32884: PPUSH
32885: CALL_OW 310
32889: IFFALSE 32900
// ComExit ( driver ) ;
32891: LD_VAR 0 18
32895: PPUSH
32896: CALL 58553 0 1
// AddComEnterUnit ( driver , tmp ) ;
32900: LD_VAR 0 18
32904: PPUSH
32905: LD_VAR 0 13
32909: PPUSH
32910: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32914: LD_VAR 0 18
32918: PPUSH
32919: LD_VAR 0 7
32923: PPUSH
32924: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32928: LD_VAR 0 18
32932: PPUSH
32933: CALL_OW 181
// end ; continue ;
32937: GO 32581
// end ; if not cleaners or not tmp in cleaners then
32939: LD_VAR 0 6
32943: NOT
32944: IFTRUE 32959
32946: PUSH
32947: LD_VAR 0 13
32951: PUSH
32952: LD_VAR 0 6
32956: IN
32957: NOT
32958: OR
32959: IFFALSE 33268
// begin if dep then
32961: LD_VAR 0 17
32965: IFFALSE 33101
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32967: LD_ADDR_VAR 0 16
32971: PUSH
32972: LD_VAR 0 17
32976: PUSH
32977: LD_INT 1
32979: ARRAY
32980: PPUSH
32981: CALL_OW 250
32985: PPUSH
32986: LD_VAR 0 17
32990: PUSH
32991: LD_INT 1
32993: ARRAY
32994: PPUSH
32995: CALL_OW 254
32999: PPUSH
33000: LD_INT 5
33002: PPUSH
33003: CALL_OW 272
33007: PUSH
33008: LD_VAR 0 17
33012: PUSH
33013: LD_INT 1
33015: ARRAY
33016: PPUSH
33017: CALL_OW 251
33021: PPUSH
33022: LD_VAR 0 17
33026: PUSH
33027: LD_INT 1
33029: ARRAY
33030: PPUSH
33031: CALL_OW 254
33035: PPUSH
33036: LD_INT 5
33038: PPUSH
33039: CALL_OW 273
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
33048: LD_VAR 0 16
33052: PUSH
33053: LD_INT 1
33055: ARRAY
33056: PPUSH
33057: LD_VAR 0 16
33061: PUSH
33062: LD_INT 2
33064: ARRAY
33065: PPUSH
33066: CALL_OW 488
33070: IFFALSE 33101
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
33072: LD_VAR 0 13
33076: PPUSH
33077: LD_VAR 0 16
33081: PUSH
33082: LD_INT 1
33084: ARRAY
33085: PPUSH
33086: LD_VAR 0 16
33090: PUSH
33091: LD_INT 2
33093: ARRAY
33094: PPUSH
33095: CALL_OW 111
// continue ;
33099: GO 32581
// end ; end ; r := GetDir ( tmp ) ;
33101: LD_ADDR_VAR 0 15
33105: PUSH
33106: LD_VAR 0 13
33110: PPUSH
33111: CALL_OW 254
33115: ST_TO_ADDR
// if r = 5 then
33116: LD_VAR 0 15
33120: PUSH
33121: LD_INT 5
33123: EQUAL
33124: IFFALSE 33134
// r := 0 ;
33126: LD_ADDR_VAR 0 15
33130: PUSH
33131: LD_INT 0
33133: ST_TO_ADDR
// for j = r to 5 do
33134: LD_ADDR_VAR 0 10
33138: PUSH
33139: DOUBLE
33140: LD_VAR 0 15
33144: DEC
33145: ST_TO_ADDR
33146: LD_INT 5
33148: PUSH
33149: FOR_TO
33150: IFFALSE 33266
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
33152: LD_ADDR_VAR 0 11
33156: PUSH
33157: LD_VAR 0 13
33161: PPUSH
33162: CALL_OW 250
33166: PPUSH
33167: LD_VAR 0 10
33171: PPUSH
33172: LD_INT 2
33174: PPUSH
33175: CALL_OW 272
33179: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
33180: LD_ADDR_VAR 0 12
33184: PUSH
33185: LD_VAR 0 13
33189: PPUSH
33190: CALL_OW 251
33194: PPUSH
33195: LD_VAR 0 10
33199: PPUSH
33200: LD_INT 2
33202: PPUSH
33203: CALL_OW 273
33207: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
33208: LD_VAR 0 11
33212: PPUSH
33213: LD_VAR 0 12
33217: PPUSH
33218: CALL_OW 488
33222: IFFALSE 33241
33224: PUSH
33225: LD_VAR 0 11
33229: PPUSH
33230: LD_VAR 0 12
33234: PPUSH
33235: CALL_OW 428
33239: NOT
33240: AND
33241: IFFALSE 33264
// begin ComMoveXY ( tmp , _x , _y ) ;
33243: LD_VAR 0 13
33247: PPUSH
33248: LD_VAR 0 11
33252: PPUSH
33253: LD_VAR 0 12
33257: PPUSH
33258: CALL_OW 111
// break ;
33262: GO 33266
// end ; end ;
33264: GO 33149
33266: POP
33267: POP
// end ; end ;
33268: GO 32581
33270: POP
33271: POP
// end ;
33272: LD_VAR 0 8
33276: RET
// export function BuildingTechInvented ( side , btype ) ; begin
33277: LD_INT 0
33279: PPUSH
// result := true ;
33280: LD_ADDR_VAR 0 3
33284: PUSH
33285: LD_INT 1
33287: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
33288: LD_VAR 0 2
33292: PUSH
33293: LD_INT 24
33295: DOUBLE
33296: EQUAL
33297: IFTRUE 33307
33299: LD_INT 33
33301: DOUBLE
33302: EQUAL
33303: IFTRUE 33307
33305: GO 33332
33307: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
33308: LD_ADDR_VAR 0 3
33312: PUSH
33313: LD_INT 32
33315: PPUSH
33316: LD_VAR 0 1
33320: PPUSH
33321: CALL_OW 321
33325: PUSH
33326: LD_INT 2
33328: EQUAL
33329: ST_TO_ADDR
33330: GO 33648
33332: LD_INT 20
33334: DOUBLE
33335: EQUAL
33336: IFTRUE 33340
33338: GO 33365
33340: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
33341: LD_ADDR_VAR 0 3
33345: PUSH
33346: LD_INT 6
33348: PPUSH
33349: LD_VAR 0 1
33353: PPUSH
33354: CALL_OW 321
33358: PUSH
33359: LD_INT 2
33361: EQUAL
33362: ST_TO_ADDR
33363: GO 33648
33365: LD_INT 22
33367: DOUBLE
33368: EQUAL
33369: IFTRUE 33379
33371: LD_INT 36
33373: DOUBLE
33374: EQUAL
33375: IFTRUE 33379
33377: GO 33404
33379: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
33380: LD_ADDR_VAR 0 3
33384: PUSH
33385: LD_INT 15
33387: PPUSH
33388: LD_VAR 0 1
33392: PPUSH
33393: CALL_OW 321
33397: PUSH
33398: LD_INT 2
33400: EQUAL
33401: ST_TO_ADDR
33402: GO 33648
33404: LD_INT 30
33406: DOUBLE
33407: EQUAL
33408: IFTRUE 33412
33410: GO 33437
33412: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
33413: LD_ADDR_VAR 0 3
33417: PUSH
33418: LD_INT 20
33420: PPUSH
33421: LD_VAR 0 1
33425: PPUSH
33426: CALL_OW 321
33430: PUSH
33431: LD_INT 2
33433: EQUAL
33434: ST_TO_ADDR
33435: GO 33648
33437: LD_INT 28
33439: DOUBLE
33440: EQUAL
33441: IFTRUE 33451
33443: LD_INT 21
33445: DOUBLE
33446: EQUAL
33447: IFTRUE 33451
33449: GO 33476
33451: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
33452: LD_ADDR_VAR 0 3
33456: PUSH
33457: LD_INT 21
33459: PPUSH
33460: LD_VAR 0 1
33464: PPUSH
33465: CALL_OW 321
33469: PUSH
33470: LD_INT 2
33472: EQUAL
33473: ST_TO_ADDR
33474: GO 33648
33476: LD_INT 16
33478: DOUBLE
33479: EQUAL
33480: IFTRUE 33484
33482: GO 33509
33484: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
33485: LD_ADDR_VAR 0 3
33489: PUSH
33490: LD_INT 84
33492: PPUSH
33493: LD_VAR 0 1
33497: PPUSH
33498: CALL_OW 321
33502: PUSH
33503: LD_INT 2
33505: EQUAL
33506: ST_TO_ADDR
33507: GO 33648
33509: LD_INT 19
33511: DOUBLE
33512: EQUAL
33513: IFTRUE 33523
33515: LD_INT 23
33517: DOUBLE
33518: EQUAL
33519: IFTRUE 33523
33521: GO 33548
33523: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
33524: LD_ADDR_VAR 0 3
33528: PUSH
33529: LD_INT 83
33531: PPUSH
33532: LD_VAR 0 1
33536: PPUSH
33537: CALL_OW 321
33541: PUSH
33542: LD_INT 2
33544: EQUAL
33545: ST_TO_ADDR
33546: GO 33648
33548: LD_INT 17
33550: DOUBLE
33551: EQUAL
33552: IFTRUE 33556
33554: GO 33581
33556: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33557: LD_ADDR_VAR 0 3
33561: PUSH
33562: LD_INT 39
33564: PPUSH
33565: LD_VAR 0 1
33569: PPUSH
33570: CALL_OW 321
33574: PUSH
33575: LD_INT 2
33577: EQUAL
33578: ST_TO_ADDR
33579: GO 33648
33581: LD_INT 18
33583: DOUBLE
33584: EQUAL
33585: IFTRUE 33589
33587: GO 33614
33589: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33590: LD_ADDR_VAR 0 3
33594: PUSH
33595: LD_INT 40
33597: PPUSH
33598: LD_VAR 0 1
33602: PPUSH
33603: CALL_OW 321
33607: PUSH
33608: LD_INT 2
33610: EQUAL
33611: ST_TO_ADDR
33612: GO 33648
33614: LD_INT 27
33616: DOUBLE
33617: EQUAL
33618: IFTRUE 33622
33620: GO 33647
33622: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33623: LD_ADDR_VAR 0 3
33627: PUSH
33628: LD_INT 35
33630: PPUSH
33631: LD_VAR 0 1
33635: PPUSH
33636: CALL_OW 321
33640: PUSH
33641: LD_INT 2
33643: EQUAL
33644: ST_TO_ADDR
33645: GO 33648
33647: POP
// end ;
33648: LD_VAR 0 3
33652: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33653: LD_INT 0
33655: PPUSH
33656: PPUSH
33657: PPUSH
33658: PPUSH
33659: PPUSH
33660: PPUSH
33661: PPUSH
33662: PPUSH
33663: PPUSH
33664: PPUSH
33665: PPUSH
// result := false ;
33666: LD_ADDR_VAR 0 6
33670: PUSH
33671: LD_INT 0
33673: ST_TO_ADDR
// if btype = b_depot then
33674: LD_VAR 0 2
33678: PUSH
33679: LD_INT 0
33681: EQUAL
33682: IFFALSE 33694
// begin result := true ;
33684: LD_ADDR_VAR 0 6
33688: PUSH
33689: LD_INT 1
33691: ST_TO_ADDR
// exit ;
33692: GO 34548
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33694: LD_VAR 0 1
33698: NOT
33699: IFTRUE 33724
33701: PUSH
33702: LD_VAR 0 1
33706: PPUSH
33707: CALL_OW 266
33711: PUSH
33712: LD_INT 0
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: IN
33722: NOT
33723: OR
33724: IFTRUE 33733
33726: PUSH
33727: LD_VAR 0 2
33731: NOT
33732: OR
33733: IFTRUE 33769
33735: PUSH
33736: LD_VAR 0 5
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 3
33752: PUSH
33753: LD_INT 4
33755: PUSH
33756: LD_INT 5
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: IN
33767: NOT
33768: OR
33769: IFTRUE 33788
33771: PUSH
33772: LD_VAR 0 3
33776: PPUSH
33777: LD_VAR 0 4
33781: PPUSH
33782: CALL_OW 488
33786: NOT
33787: OR
33788: IFFALSE 33792
// exit ;
33790: GO 34548
// side := GetSide ( depot ) ;
33792: LD_ADDR_VAR 0 9
33796: PUSH
33797: LD_VAR 0 1
33801: PPUSH
33802: CALL_OW 255
33806: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33807: LD_VAR 0 9
33811: PPUSH
33812: LD_VAR 0 2
33816: PPUSH
33817: CALL 33277 0 2
33821: NOT
33822: IFFALSE 33826
// exit ;
33824: GO 34548
// pom := GetBase ( depot ) ;
33826: LD_ADDR_VAR 0 10
33830: PUSH
33831: LD_VAR 0 1
33835: PPUSH
33836: CALL_OW 274
33840: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33841: LD_ADDR_VAR 0 11
33845: PUSH
33846: LD_VAR 0 2
33850: PPUSH
33851: LD_VAR 0 1
33855: PPUSH
33856: CALL_OW 248
33860: PPUSH
33861: CALL_OW 450
33865: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33866: LD_VAR 0 10
33870: PPUSH
33871: LD_INT 1
33873: PPUSH
33874: CALL_OW 275
33878: PUSH
33879: LD_VAR 0 11
33883: PUSH
33884: LD_INT 1
33886: ARRAY
33887: GREATEREQUAL
33888: IFFALSE 33914
33890: PUSH
33891: LD_VAR 0 10
33895: PPUSH
33896: LD_INT 2
33898: PPUSH
33899: CALL_OW 275
33903: PUSH
33904: LD_VAR 0 11
33908: PUSH
33909: LD_INT 2
33911: ARRAY
33912: GREATEREQUAL
33913: AND
33914: IFFALSE 33940
33916: PUSH
33917: LD_VAR 0 10
33921: PPUSH
33922: LD_INT 3
33924: PPUSH
33925: CALL_OW 275
33929: PUSH
33930: LD_VAR 0 11
33934: PUSH
33935: LD_INT 3
33937: ARRAY
33938: GREATEREQUAL
33939: AND
33940: NOT
33941: IFFALSE 33945
// exit ;
33943: GO 34548
// if GetBType ( depot ) = b_depot then
33945: LD_VAR 0 1
33949: PPUSH
33950: CALL_OW 266
33954: PUSH
33955: LD_INT 0
33957: EQUAL
33958: IFFALSE 33970
// dist := 28 else
33960: LD_ADDR_VAR 0 14
33964: PUSH
33965: LD_INT 28
33967: ST_TO_ADDR
33968: GO 33978
// dist := 36 ;
33970: LD_ADDR_VAR 0 14
33974: PUSH
33975: LD_INT 36
33977: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33978: LD_VAR 0 1
33982: PPUSH
33983: LD_VAR 0 3
33987: PPUSH
33988: LD_VAR 0 4
33992: PPUSH
33993: CALL_OW 297
33997: PUSH
33998: LD_VAR 0 14
34002: GREATER
34003: IFFALSE 34007
// exit ;
34005: GO 34548
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
34007: LD_ADDR_VAR 0 12
34011: PUSH
34012: LD_VAR 0 2
34016: PPUSH
34017: LD_VAR 0 3
34021: PPUSH
34022: LD_VAR 0 4
34026: PPUSH
34027: LD_VAR 0 5
34031: PPUSH
34032: LD_VAR 0 1
34036: PPUSH
34037: CALL_OW 248
34041: PPUSH
34042: LD_INT 0
34044: PPUSH
34045: CALL 34553 0 6
34049: ST_TO_ADDR
// if not hexes then
34050: LD_VAR 0 12
34054: NOT
34055: IFFALSE 34059
// exit ;
34057: GO 34548
// hex := GetHexInfo ( x , y ) ;
34059: LD_ADDR_VAR 0 15
34063: PUSH
34064: LD_VAR 0 3
34068: PPUSH
34069: LD_VAR 0 4
34073: PPUSH
34074: CALL_OW 546
34078: ST_TO_ADDR
// if hex [ 1 ] then
34079: LD_VAR 0 15
34083: PUSH
34084: LD_INT 1
34086: ARRAY
34087: IFFALSE 34091
// exit ;
34089: GO 34548
// height := hex [ 2 ] ;
34091: LD_ADDR_VAR 0 13
34095: PUSH
34096: LD_VAR 0 15
34100: PUSH
34101: LD_INT 2
34103: ARRAY
34104: ST_TO_ADDR
// for i = 1 to hexes do
34105: LD_ADDR_VAR 0 7
34109: PUSH
34110: DOUBLE
34111: LD_INT 1
34113: DEC
34114: ST_TO_ADDR
34115: LD_VAR 0 12
34119: PUSH
34120: FOR_TO
34121: IFFALSE 34465
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
34123: LD_VAR 0 12
34127: PUSH
34128: LD_VAR 0 7
34132: ARRAY
34133: PUSH
34134: LD_INT 1
34136: ARRAY
34137: PPUSH
34138: LD_VAR 0 12
34142: PUSH
34143: LD_VAR 0 7
34147: ARRAY
34148: PUSH
34149: LD_INT 2
34151: ARRAY
34152: PPUSH
34153: CALL_OW 488
34157: NOT
34158: IFTRUE 34200
34160: PUSH
34161: LD_VAR 0 12
34165: PUSH
34166: LD_VAR 0 7
34170: ARRAY
34171: PUSH
34172: LD_INT 1
34174: ARRAY
34175: PPUSH
34176: LD_VAR 0 12
34180: PUSH
34181: LD_VAR 0 7
34185: ARRAY
34186: PUSH
34187: LD_INT 2
34189: ARRAY
34190: PPUSH
34191: CALL_OW 428
34195: PUSH
34196: LD_INT 0
34198: GREATER
34199: OR
34200: IFTRUE 34238
34202: PUSH
34203: LD_VAR 0 12
34207: PUSH
34208: LD_VAR 0 7
34212: ARRAY
34213: PUSH
34214: LD_INT 1
34216: ARRAY
34217: PPUSH
34218: LD_VAR 0 12
34222: PUSH
34223: LD_VAR 0 7
34227: ARRAY
34228: PUSH
34229: LD_INT 2
34231: ARRAY
34232: PPUSH
34233: CALL_OW 351
34237: OR
34238: IFFALSE 34244
// exit ;
34240: POP
34241: POP
34242: GO 34548
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
34244: LD_ADDR_VAR 0 8
34248: PUSH
34249: LD_VAR 0 12
34253: PUSH
34254: LD_VAR 0 7
34258: ARRAY
34259: PUSH
34260: LD_INT 1
34262: ARRAY
34263: PPUSH
34264: LD_VAR 0 12
34268: PUSH
34269: LD_VAR 0 7
34273: ARRAY
34274: PUSH
34275: LD_INT 2
34277: ARRAY
34278: PPUSH
34279: CALL_OW 546
34283: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
34284: LD_VAR 0 8
34288: PUSH
34289: LD_INT 1
34291: ARRAY
34292: IFTRUE 34314
34294: PUSH
34295: LD_VAR 0 8
34299: PUSH
34300: LD_INT 2
34302: ARRAY
34303: PUSH
34304: LD_VAR 0 13
34308: PUSH
34309: LD_INT 2
34311: PLUS
34312: GREATER
34313: OR
34314: IFTRUE 34336
34316: PUSH
34317: LD_VAR 0 8
34321: PUSH
34322: LD_INT 2
34324: ARRAY
34325: PUSH
34326: LD_VAR 0 13
34330: PUSH
34331: LD_INT 2
34333: MINUS
34334: LESS
34335: OR
34336: IFTRUE 34404
34338: PUSH
34339: LD_VAR 0 8
34343: PUSH
34344: LD_INT 3
34346: ARRAY
34347: PUSH
34348: LD_INT 0
34350: PUSH
34351: LD_INT 8
34353: PUSH
34354: LD_INT 9
34356: PUSH
34357: LD_INT 10
34359: PUSH
34360: LD_INT 11
34362: PUSH
34363: LD_INT 12
34365: PUSH
34366: LD_INT 13
34368: PUSH
34369: LD_INT 16
34371: PUSH
34372: LD_INT 17
34374: PUSH
34375: LD_INT 18
34377: PUSH
34378: LD_INT 19
34380: PUSH
34381: LD_INT 20
34383: PUSH
34384: LD_INT 21
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: IN
34402: NOT
34403: OR
34404: IFTRUE 34417
34406: PUSH
34407: LD_VAR 0 8
34411: PUSH
34412: LD_INT 5
34414: ARRAY
34415: NOT
34416: OR
34417: IFTRUE 34457
34419: PUSH
34420: LD_VAR 0 8
34424: PUSH
34425: LD_INT 6
34427: ARRAY
34428: PUSH
34429: LD_INT 1
34431: PUSH
34432: LD_INT 2
34434: PUSH
34435: LD_INT 7
34437: PUSH
34438: LD_INT 9
34440: PUSH
34441: LD_INT 10
34443: PUSH
34444: LD_INT 11
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: IN
34455: NOT
34456: OR
34457: IFFALSE 34463
// exit ;
34459: POP
34460: POP
34461: GO 34548
// end ;
34463: GO 34120
34465: POP
34466: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
34467: LD_VAR 0 9
34471: PPUSH
34472: LD_VAR 0 3
34476: PPUSH
34477: LD_VAR 0 4
34481: PPUSH
34482: LD_INT 20
34484: PPUSH
34485: CALL 26367 0 4
34489: PUSH
34490: LD_INT 4
34492: ARRAY
34493: IFFALSE 34497
// exit ;
34495: GO 34548
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
34497: LD_VAR 0 2
34501: PUSH
34502: LD_INT 29
34504: PUSH
34505: LD_INT 30
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: IN
34512: IFFALSE 34536
34514: PUSH
34515: LD_VAR 0 3
34519: PPUSH
34520: LD_VAR 0 4
34524: PPUSH
34525: LD_VAR 0 9
34529: PPUSH
34530: CALL_OW 440
34534: NOT
34535: AND
34536: IFFALSE 34540
// exit ;
34538: GO 34548
// result := true ;
34540: LD_ADDR_VAR 0 6
34544: PUSH
34545: LD_INT 1
34547: ST_TO_ADDR
// end ;
34548: LD_VAR 0 6
34552: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
34553: LD_INT 0
34555: PPUSH
34556: PPUSH
34557: PPUSH
34558: PPUSH
34559: PPUSH
34560: PPUSH
34561: PPUSH
34562: PPUSH
34563: PPUSH
34564: PPUSH
34565: PPUSH
34566: PPUSH
34567: PPUSH
34568: PPUSH
34569: PPUSH
34570: PPUSH
34571: PPUSH
34572: PPUSH
34573: PPUSH
34574: PPUSH
34575: PPUSH
34576: PPUSH
34577: PPUSH
34578: PPUSH
34579: PPUSH
34580: PPUSH
34581: PPUSH
34582: PPUSH
34583: PPUSH
34584: PPUSH
34585: PPUSH
34586: PPUSH
34587: PPUSH
34588: PPUSH
34589: PPUSH
34590: PPUSH
34591: PPUSH
34592: PPUSH
34593: PPUSH
34594: PPUSH
34595: PPUSH
34596: PPUSH
34597: PPUSH
34598: PPUSH
34599: PPUSH
34600: PPUSH
34601: PPUSH
34602: PPUSH
34603: PPUSH
34604: PPUSH
34605: PPUSH
34606: PPUSH
34607: PPUSH
34608: PPUSH
34609: PPUSH
34610: PPUSH
34611: PPUSH
34612: PPUSH
// result = [ ] ;
34613: LD_ADDR_VAR 0 7
34617: PUSH
34618: EMPTY
34619: ST_TO_ADDR
// temp_list = [ ] ;
34620: LD_ADDR_VAR 0 9
34624: PUSH
34625: EMPTY
34626: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34627: LD_VAR 0 4
34631: PUSH
34632: LD_INT 0
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: LD_INT 2
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: LD_INT 4
34646: PUSH
34647: LD_INT 5
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: LIST
34654: LIST
34655: LIST
34656: LIST
34657: IN
34658: NOT
34659: IFTRUE 34702
34661: PUSH
34662: LD_VAR 0 1
34666: PUSH
34667: LD_INT 0
34669: PUSH
34670: LD_INT 1
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: IN
34677: IFFALSE 34701
34679: PUSH
34680: LD_VAR 0 5
34684: PUSH
34685: LD_INT 1
34687: PUSH
34688: LD_INT 2
34690: PUSH
34691: LD_INT 3
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: LIST
34698: IN
34699: NOT
34700: AND
34701: OR
34702: IFFALSE 34706
// exit ;
34704: GO 53105
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34706: LD_VAR 0 1
34710: PUSH
34711: LD_INT 6
34713: PUSH
34714: LD_INT 7
34716: PUSH
34717: LD_INT 8
34719: PUSH
34720: LD_INT 13
34722: PUSH
34723: LD_INT 12
34725: PUSH
34726: LD_INT 15
34728: PUSH
34729: LD_INT 11
34731: PUSH
34732: LD_INT 14
34734: PUSH
34735: LD_INT 10
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: IN
34749: IFFALSE 34759
// btype = b_lab ;
34751: LD_ADDR_VAR 0 1
34755: PUSH
34756: LD_INT 6
34758: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34759: LD_VAR 0 6
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: LD_INT 2
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: LIST
34777: IN
34778: NOT
34779: IFTRUE 34847
34781: PUSH
34782: LD_VAR 0 1
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: LD_INT 1
34792: PUSH
34793: LD_INT 2
34795: PUSH
34796: LD_INT 3
34798: PUSH
34799: LD_INT 6
34801: PUSH
34802: LD_INT 36
34804: PUSH
34805: LD_INT 4
34807: PUSH
34808: LD_INT 5
34810: PUSH
34811: LD_INT 31
34813: PUSH
34814: LD_INT 32
34816: PUSH
34817: LD_INT 33
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: IN
34833: NOT
34834: IFFALSE 34846
34836: PUSH
34837: LD_VAR 0 6
34841: PUSH
34842: LD_INT 1
34844: EQUAL
34845: AND
34846: OR
34847: IFTRUE 34879
34849: PUSH
34850: LD_VAR 0 1
34854: PUSH
34855: LD_INT 2
34857: PUSH
34858: LD_INT 3
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: IN
34865: NOT
34866: IFFALSE 34878
34868: PUSH
34869: LD_VAR 0 6
34873: PUSH
34874: LD_INT 2
34876: EQUAL
34877: AND
34878: OR
34879: IFFALSE 34889
// mode = 0 ;
34881: LD_ADDR_VAR 0 6
34885: PUSH
34886: LD_INT 0
34888: ST_TO_ADDR
// case mode of 0 :
34889: LD_VAR 0 6
34893: PUSH
34894: LD_INT 0
34896: DOUBLE
34897: EQUAL
34898: IFTRUE 34902
34900: GO 46355
34902: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34903: LD_ADDR_VAR 0 11
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 1
34961: NEG
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 1
34972: NEG
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 2
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 1
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: LD_INT 2
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: LD_INT 2
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 1
35038: NEG
35039: PUSH
35040: LD_INT 1
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 1
35049: PUSH
35050: LD_INT 3
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: LD_INT 3
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 1
35069: NEG
35070: PUSH
35071: LD_INT 2
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35096: LD_ADDR_VAR 0 12
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 0
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 0
35113: PUSH
35114: LD_INT 1
35116: NEG
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 1
35134: PUSH
35135: LD_INT 1
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: LD_INT 1
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: PUSH
35178: LD_INT 1
35180: NEG
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: LD_INT 0
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 2
35198: PUSH
35199: LD_INT 1
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 2
35219: NEG
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 2
35230: NEG
35231: PUSH
35232: LD_INT 1
35234: NEG
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 3
35253: NEG
35254: PUSH
35255: LD_INT 0
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: LD_INT 1
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35292: LD_ADDR_VAR 0 13
35296: PUSH
35297: LD_INT 0
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: LD_INT 1
35312: NEG
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 1
35320: PUSH
35321: LD_INT 0
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 1
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 0
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 1
35350: NEG
35351: PUSH
35352: LD_INT 0
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: LD_INT 1
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 1
35373: NEG
35374: PUSH
35375: LD_INT 2
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 2
35385: PUSH
35386: LD_INT 1
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: PUSH
35396: LD_INT 2
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 1
35405: PUSH
35406: LD_INT 2
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 2
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 2
35427: NEG
35428: PUSH
35429: LD_INT 2
35431: NEG
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 2
35439: NEG
35440: PUSH
35441: LD_INT 3
35443: NEG
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 3
35451: NEG
35452: PUSH
35453: LD_INT 2
35455: NEG
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 3
35463: NEG
35464: PUSH
35465: LD_INT 3
35467: NEG
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35491: LD_ADDR_VAR 0 14
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 0
35508: PUSH
35509: LD_INT 1
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: NEG
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: LD_INT 2
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: LD_INT 2
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: LD_INT 2
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 0
35616: PUSH
35617: LD_INT 2
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: NEG
35627: PUSH
35628: LD_INT 1
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 1
35637: NEG
35638: PUSH
35639: LD_INT 3
35641: NEG
35642: PUSH
35643: EMPTY
35644: LIST
35645: LIST
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: LD_INT 3
35652: NEG
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 2
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35687: LD_ADDR_VAR 0 15
35691: PUSH
35692: LD_INT 0
35694: PUSH
35695: LD_INT 0
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 0
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 1
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 1
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 0
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: EMPTY
35740: LIST
35741: LIST
35742: PUSH
35743: LD_INT 1
35745: NEG
35746: PUSH
35747: LD_INT 0
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 1
35756: NEG
35757: PUSH
35758: LD_INT 1
35760: NEG
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: LD_INT 1
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 2
35779: PUSH
35780: LD_INT 0
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 2
35789: PUSH
35790: LD_INT 1
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: NEG
35800: PUSH
35801: LD_INT 1
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: NEG
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 2
35821: NEG
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 3
35844: PUSH
35845: LD_INT 0
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 3
35854: PUSH
35855: LD_INT 1
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: LIST
35866: LIST
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: LIST
35877: LIST
35878: LIST
35879: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35880: LD_ADDR_VAR 0 16
35884: PUSH
35885: LD_INT 0
35887: PUSH
35888: LD_INT 0
35890: PUSH
35891: EMPTY
35892: LIST
35893: LIST
35894: PUSH
35895: LD_INT 0
35897: PUSH
35898: LD_INT 1
35900: NEG
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: LD_INT 0
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: LD_INT 1
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 1
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 0
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: NEG
35950: PUSH
35951: LD_INT 1
35953: NEG
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 1
35961: NEG
35962: PUSH
35963: LD_INT 2
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PUSH
35981: LD_INT 2
35983: PUSH
35984: LD_INT 2
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 1
35993: PUSH
35994: LD_INT 2
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 2
36003: NEG
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 2
36015: NEG
36016: PUSH
36017: LD_INT 2
36019: NEG
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: PUSH
36025: LD_INT 3
36027: PUSH
36028: LD_INT 2
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 3
36037: PUSH
36038: LD_INT 3
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: LD_INT 3
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: LIST
36061: LIST
36062: LIST
36063: LIST
36064: LIST
36065: LIST
36066: LIST
36067: LIST
36068: LIST
36069: LIST
36070: LIST
36071: LIST
36072: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36073: LD_ADDR_VAR 0 17
36077: PUSH
36078: LD_INT 0
36080: PUSH
36081: LD_INT 0
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 0
36090: PUSH
36091: LD_INT 1
36093: NEG
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 1
36101: PUSH
36102: LD_INT 0
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 1
36111: PUSH
36112: LD_INT 1
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 0
36121: PUSH
36122: LD_INT 1
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 1
36131: NEG
36132: PUSH
36133: LD_INT 0
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 1
36142: NEG
36143: PUSH
36144: LD_INT 1
36146: NEG
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 1
36154: NEG
36155: PUSH
36156: LD_INT 2
36158: NEG
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 0
36166: PUSH
36167: LD_INT 2
36169: NEG
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 1
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 0
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 2
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 2
36208: PUSH
36209: LD_INT 2
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: PUSH
36219: LD_INT 2
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 0
36228: PUSH
36229: LD_INT 2
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 1
36238: NEG
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 2
36249: NEG
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 2
36260: NEG
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 2
36272: NEG
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: LIST
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: LIST
36302: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36303: LD_ADDR_VAR 0 18
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: LD_INT 0
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 0
36320: PUSH
36321: LD_INT 1
36323: NEG
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 1
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 0
36351: PUSH
36352: LD_INT 1
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: NEG
36362: PUSH
36363: LD_INT 0
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 1
36372: NEG
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 1
36384: NEG
36385: PUSH
36386: LD_INT 2
36388: NEG
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 0
36396: PUSH
36397: LD_INT 2
36399: NEG
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 2
36428: PUSH
36429: LD_INT 1
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 2
36438: PUSH
36439: LD_INT 2
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 1
36448: PUSH
36449: LD_INT 2
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 0
36458: PUSH
36459: LD_INT 2
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: LD_INT 1
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 2
36479: NEG
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: EMPTY
36485: LIST
36486: LIST
36487: PUSH
36488: LD_INT 2
36490: NEG
36491: PUSH
36492: LD_INT 1
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 2
36502: NEG
36503: PUSH
36504: LD_INT 2
36506: NEG
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36533: LD_ADDR_VAR 0 19
36537: PUSH
36538: LD_INT 0
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 0
36550: PUSH
36551: LD_INT 1
36553: NEG
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 1
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 1
36571: PUSH
36572: LD_INT 1
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 0
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: LD_INT 0
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 1
36602: NEG
36603: PUSH
36604: LD_INT 1
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 1
36614: NEG
36615: PUSH
36616: LD_INT 2
36618: NEG
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 1
36640: NEG
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 2
36648: PUSH
36649: LD_INT 0
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 2
36658: PUSH
36659: LD_INT 1
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 2
36668: PUSH
36669: LD_INT 2
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: PUSH
36679: LD_INT 2
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: LD_INT 2
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: LD_INT 1
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 2
36709: NEG
36710: PUSH
36711: LD_INT 0
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 2
36720: NEG
36721: PUSH
36722: LD_INT 1
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 2
36732: NEG
36733: PUSH
36734: LD_INT 2
36736: NEG
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: LIST
36762: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36763: LD_ADDR_VAR 0 20
36767: PUSH
36768: LD_INT 0
36770: PUSH
36771: LD_INT 0
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 0
36780: PUSH
36781: LD_INT 1
36783: NEG
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 1
36801: PUSH
36802: LD_INT 1
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: LD_INT 1
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 1
36821: NEG
36822: PUSH
36823: LD_INT 0
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: LD_INT 1
36836: NEG
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 1
36844: NEG
36845: PUSH
36846: LD_INT 2
36848: NEG
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: LD_INT 2
36859: NEG
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 1
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 2
36878: PUSH
36879: LD_INT 0
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 2
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 2
36898: PUSH
36899: LD_INT 2
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: LD_INT 2
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 0
36918: PUSH
36919: LD_INT 2
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 1
36928: NEG
36929: PUSH
36930: LD_INT 1
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: NEG
36940: PUSH
36941: LD_INT 0
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 2
36950: NEG
36951: PUSH
36952: LD_INT 1
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 2
36962: NEG
36963: PUSH
36964: LD_INT 2
36966: NEG
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36993: LD_ADDR_VAR 0 21
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: LD_INT 0
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 0
37010: PUSH
37011: LD_INT 1
37013: NEG
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: LD_INT 1
37021: PUSH
37022: LD_INT 0
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 1
37031: PUSH
37032: LD_INT 1
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: LD_INT 1
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 1
37051: NEG
37052: PUSH
37053: LD_INT 0
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 1
37062: NEG
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: LD_INT 2
37078: NEG
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 0
37086: PUSH
37087: LD_INT 2
37089: NEG
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: LD_INT 1
37100: NEG
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 2
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 2
37128: PUSH
37129: LD_INT 2
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: LD_INT 2
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: LD_INT 1
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: NEG
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 2
37180: NEG
37181: PUSH
37182: LD_INT 1
37184: NEG
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 2
37192: NEG
37193: PUSH
37194: LD_INT 2
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: LIST
37214: LIST
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37223: LD_ADDR_VAR 0 22
37227: PUSH
37228: LD_INT 0
37230: PUSH
37231: LD_INT 0
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 1
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 1
37261: PUSH
37262: LD_INT 1
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 0
37271: PUSH
37272: LD_INT 1
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 1
37281: NEG
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 1
37292: NEG
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: NEG
37305: PUSH
37306: LD_INT 2
37308: NEG
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 0
37316: PUSH
37317: LD_INT 2
37319: NEG
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 1
37327: PUSH
37328: LD_INT 1
37330: NEG
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 2
37338: PUSH
37339: LD_INT 0
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 2
37348: PUSH
37349: LD_INT 1
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: PUSH
37359: LD_INT 2
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: LD_INT 2
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: LD_INT 1
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 2
37410: NEG
37411: PUSH
37412: LD_INT 1
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 2
37422: NEG
37423: PUSH
37424: LD_INT 2
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: LIST
37439: LIST
37440: LIST
37441: LIST
37442: LIST
37443: LIST
37444: LIST
37445: LIST
37446: LIST
37447: LIST
37448: LIST
37449: LIST
37450: LIST
37451: LIST
37452: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37453: LD_ADDR_VAR 0 23
37457: PUSH
37458: LD_INT 0
37460: PUSH
37461: LD_INT 0
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: PUSH
37482: LD_INT 0
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 1
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: LD_INT 1
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: LD_INT 0
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: NEG
37523: PUSH
37524: LD_INT 1
37526: NEG
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 1
37534: NEG
37535: PUSH
37536: LD_INT 2
37538: NEG
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 0
37546: PUSH
37547: LD_INT 2
37549: NEG
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 1
37557: PUSH
37558: LD_INT 1
37560: NEG
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 2
37568: PUSH
37569: LD_INT 0
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 2
37578: PUSH
37579: LD_INT 1
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 2
37588: PUSH
37589: LD_INT 2
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PUSH
37596: LD_INT 1
37598: PUSH
37599: LD_INT 2
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 0
37608: PUSH
37609: LD_INT 2
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 1
37618: NEG
37619: PUSH
37620: LD_INT 1
37622: PUSH
37623: EMPTY
37624: LIST
37625: LIST
37626: PUSH
37627: LD_INT 2
37629: NEG
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 2
37640: NEG
37641: PUSH
37642: LD_INT 1
37644: NEG
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 2
37652: NEG
37653: PUSH
37654: LD_INT 2
37656: NEG
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 2
37664: NEG
37665: PUSH
37666: LD_INT 3
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 3
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 2
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37733: LD_ADDR_VAR 0 24
37737: PUSH
37738: LD_INT 0
37740: PUSH
37741: LD_INT 0
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 1
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 1
37791: NEG
37792: PUSH
37793: LD_INT 0
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: NEG
37803: PUSH
37804: LD_INT 1
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 1
37814: NEG
37815: PUSH
37816: LD_INT 2
37818: NEG
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 0
37826: PUSH
37827: LD_INT 2
37829: NEG
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 1
37837: PUSH
37838: LD_INT 1
37840: NEG
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 2
37848: PUSH
37849: LD_INT 0
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 2
37858: PUSH
37859: LD_INT 1
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 2
37868: PUSH
37869: LD_INT 2
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 1
37878: PUSH
37879: LD_INT 2
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 0
37888: PUSH
37889: LD_INT 2
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: LD_INT 1
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 2
37909: NEG
37910: PUSH
37911: LD_INT 0
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 2
37920: NEG
37921: PUSH
37922: LD_INT 1
37924: NEG
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 2
37932: NEG
37933: PUSH
37934: LD_INT 2
37936: NEG
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 2
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 2
37955: PUSH
37956: LD_INT 1
37958: NEG
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 3
37966: PUSH
37967: LD_INT 1
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 3
37976: PUSH
37977: LD_INT 2
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
38009: LD_ADDR_VAR 0 25
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: LD_INT 0
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 0
38026: PUSH
38027: LD_INT 1
38029: NEG
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 1
38037: PUSH
38038: LD_INT 0
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 1
38047: PUSH
38048: LD_INT 1
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 1
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: NEG
38068: PUSH
38069: LD_INT 0
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: NEG
38079: PUSH
38080: LD_INT 1
38082: NEG
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 1
38090: NEG
38091: PUSH
38092: LD_INT 2
38094: NEG
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: LD_INT 0
38102: PUSH
38103: LD_INT 2
38105: NEG
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: PUSH
38114: LD_INT 1
38116: NEG
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 2
38124: PUSH
38125: LD_INT 0
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 2
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 2
38144: PUSH
38145: LD_INT 2
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: LD_INT 2
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: PUSH
38162: LD_INT 0
38164: PUSH
38165: LD_INT 2
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: NEG
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 2
38185: NEG
38186: PUSH
38187: LD_INT 0
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 2
38196: NEG
38197: PUSH
38198: LD_INT 1
38200: NEG
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: LD_INT 2
38208: NEG
38209: PUSH
38210: LD_INT 2
38212: NEG
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 3
38220: PUSH
38221: LD_INT 1
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 3
38230: PUSH
38231: LD_INT 2
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 2
38240: PUSH
38241: LD_INT 3
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 1
38250: PUSH
38251: LD_INT 3
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38283: LD_ADDR_VAR 0 26
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 0
38300: PUSH
38301: LD_INT 1
38303: NEG
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 1
38311: PUSH
38312: LD_INT 0
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: PUSH
38322: LD_INT 1
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 0
38331: PUSH
38332: LD_INT 1
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: LD_INT 1
38356: NEG
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 1
38364: NEG
38365: PUSH
38366: LD_INT 2
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: LD_INT 2
38379: NEG
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 1
38387: PUSH
38388: LD_INT 1
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: LD_INT 2
38398: PUSH
38399: LD_INT 0
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 2
38408: PUSH
38409: LD_INT 1
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 2
38418: PUSH
38419: LD_INT 2
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: PUSH
38429: LD_INT 2
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: LD_INT 2
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: NEG
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 2
38459: NEG
38460: PUSH
38461: LD_INT 0
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 2
38470: NEG
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 2
38482: NEG
38483: PUSH
38484: LD_INT 2
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: LD_INT 3
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 3
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: NEG
38515: PUSH
38516: LD_INT 2
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: LD_INT 1
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38559: LD_ADDR_VAR 0 27
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 0
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 1
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: LD_INT 1
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 1
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: NEG
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 1
38640: NEG
38641: PUSH
38642: LD_INT 2
38644: NEG
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 0
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: LD_INT 1
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: LD_INT 0
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: LD_INT 2
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 1
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 1
38724: NEG
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 2
38735: NEG
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 2
38746: NEG
38747: PUSH
38748: LD_INT 1
38750: NEG
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 2
38758: NEG
38759: PUSH
38760: LD_INT 2
38762: NEG
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 1
38770: NEG
38771: PUSH
38772: LD_INT 2
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 2
38781: NEG
38782: PUSH
38783: LD_INT 1
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 3
38792: NEG
38793: PUSH
38794: LD_INT 1
38796: NEG
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 3
38804: NEG
38805: PUSH
38806: LD_INT 2
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38839: LD_ADDR_VAR 0 28
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: LD_INT 0
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 0
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 1
38867: PUSH
38868: LD_INT 0
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 1
38920: NEG
38921: PUSH
38922: LD_INT 2
38924: NEG
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: LD_INT 2
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 0
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 2
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 2
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 2
39038: NEG
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 2
39050: NEG
39051: PUSH
39052: LD_INT 3
39054: NEG
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: LD_INT 3
39066: NEG
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 3
39074: NEG
39075: PUSH
39076: LD_INT 1
39078: NEG
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 3
39086: NEG
39087: PUSH
39088: LD_INT 2
39090: NEG
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39121: LD_ADDR_VAR 0 29
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: LD_INT 0
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 1
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 0
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: LD_INT 0
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: LD_INT 1
39190: NEG
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 1
39202: NEG
39203: PUSH
39204: LD_INT 2
39206: NEG
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 0
39214: PUSH
39215: LD_INT 2
39217: NEG
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 1
39225: PUSH
39226: LD_INT 1
39228: NEG
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PUSH
39234: LD_INT 2
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 2
39246: PUSH
39247: LD_INT 1
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PUSH
39254: LD_INT 1
39256: PUSH
39257: LD_INT 2
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: LD_INT 2
39269: PUSH
39270: EMPTY
39271: LIST
39272: LIST
39273: PUSH
39274: LD_INT 1
39276: NEG
39277: PUSH
39278: LD_INT 1
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 2
39287: NEG
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 2
39299: NEG
39300: PUSH
39301: LD_INT 2
39303: NEG
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 2
39311: NEG
39312: PUSH
39313: LD_INT 3
39315: NEG
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PUSH
39321: LD_INT 2
39323: PUSH
39324: LD_INT 1
39326: NEG
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 3
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 1
39344: PUSH
39345: LD_INT 3
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 1
39354: NEG
39355: PUSH
39356: LD_INT 2
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 3
39365: NEG
39366: PUSH
39367: LD_INT 2
39369: NEG
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: LIST
39397: LIST
39398: LIST
39399: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39400: LD_ADDR_VAR 0 30
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 0
39417: PUSH
39418: LD_INT 1
39420: NEG
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 1
39428: PUSH
39429: LD_INT 0
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 1
39438: PUSH
39439: LD_INT 1
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 0
39448: PUSH
39449: LD_INT 1
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: LD_INT 1
39458: NEG
39459: PUSH
39460: LD_INT 0
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: NEG
39470: PUSH
39471: LD_INT 1
39473: NEG
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 1
39481: NEG
39482: PUSH
39483: LD_INT 2
39485: NEG
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 0
39493: PUSH
39494: LD_INT 2
39496: NEG
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: LD_INT 1
39507: NEG
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 2
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: PUSH
39526: LD_INT 1
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: PUSH
39536: LD_INT 2
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 1
39545: PUSH
39546: LD_INT 2
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: LD_INT 1
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 2
39566: NEG
39567: PUSH
39568: LD_INT 0
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 2
39577: NEG
39578: PUSH
39579: LD_INT 1
39581: NEG
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: LD_INT 3
39593: NEG
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 1
39601: PUSH
39602: LD_INT 2
39604: NEG
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: LD_INT 2
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 2
39622: PUSH
39623: LD_INT 3
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 2
39632: NEG
39633: PUSH
39634: LD_INT 1
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 3
39643: NEG
39644: PUSH
39645: LD_INT 1
39647: NEG
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: LIST
39660: LIST
39661: LIST
39662: LIST
39663: LIST
39664: LIST
39665: LIST
39666: LIST
39667: LIST
39668: LIST
39669: LIST
39670: LIST
39671: LIST
39672: LIST
39673: LIST
39674: LIST
39675: LIST
39676: LIST
39677: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39678: LD_ADDR_VAR 0 31
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: LD_INT 0
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 0
39695: PUSH
39696: LD_INT 1
39698: NEG
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 1
39706: PUSH
39707: LD_INT 0
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 1
39716: PUSH
39717: LD_INT 1
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 0
39726: PUSH
39727: LD_INT 1
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PUSH
39734: LD_INT 1
39736: NEG
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 1
39747: NEG
39748: PUSH
39749: LD_INT 1
39751: NEG
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 2
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 2
39782: PUSH
39783: LD_INT 0
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 2
39792: PUSH
39793: LD_INT 1
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 2
39802: PUSH
39803: LD_INT 2
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 1
39812: PUSH
39813: LD_INT 2
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: LD_INT 2
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: LD_INT 1
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 2
39843: NEG
39844: PUSH
39845: LD_INT 1
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 2
39867: NEG
39868: PUSH
39869: LD_INT 3
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 2
39879: PUSH
39880: LD_INT 1
39882: NEG
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 3
39890: PUSH
39891: LD_INT 1
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 1
39900: PUSH
39901: LD_INT 3
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: LD_INT 2
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 3
39921: NEG
39922: PUSH
39923: LD_INT 2
39925: NEG
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39956: LD_ADDR_VAR 0 32
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: LD_INT 1
39976: NEG
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: LD_INT 0
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: LD_INT 1
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: LD_INT 1
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 1
40014: NEG
40015: PUSH
40016: LD_INT 0
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: LD_INT 1
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: LD_INT 2
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: LD_INT 2
40052: NEG
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 2
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: PUSH
40082: LD_INT 2
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PUSH
40089: LD_INT 1
40091: PUSH
40092: LD_INT 2
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: PUSH
40099: LD_INT 0
40101: PUSH
40102: LD_INT 2
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 1
40111: NEG
40112: PUSH
40113: LD_INT 1
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 2
40122: NEG
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 2
40133: NEG
40134: PUSH
40135: LD_INT 1
40137: NEG
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 1
40145: NEG
40146: PUSH
40147: LD_INT 3
40149: NEG
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: LD_INT 2
40160: NEG
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 3
40168: PUSH
40169: LD_INT 2
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 2
40178: PUSH
40179: LD_INT 3
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 2
40188: NEG
40189: PUSH
40190: LD_INT 1
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 3
40199: NEG
40200: PUSH
40201: LD_INT 1
40203: NEG
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: LIST
40218: LIST
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
40234: LD_ADDR_VAR 0 33
40238: PUSH
40239: LD_INT 0
40241: PUSH
40242: LD_INT 0
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 0
40251: PUSH
40252: LD_INT 1
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 1
40262: PUSH
40263: LD_INT 0
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: PUSH
40270: LD_INT 1
40272: PUSH
40273: LD_INT 1
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 0
40282: PUSH
40283: LD_INT 1
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 1
40292: NEG
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 1
40303: NEG
40304: PUSH
40305: LD_INT 1
40307: NEG
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 1
40315: NEG
40316: PUSH
40317: LD_INT 2
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 2
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 2
40348: PUSH
40349: LD_INT 1
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 2
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: LD_INT 2
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 1
40378: NEG
40379: PUSH
40380: LD_INT 1
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 2
40389: NEG
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 2
40400: NEG
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 2
40412: NEG
40413: PUSH
40414: LD_INT 2
40416: NEG
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 2
40424: NEG
40425: PUSH
40426: LD_INT 3
40428: NEG
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 2
40436: PUSH
40437: LD_INT 1
40439: NEG
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 3
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 1
40457: PUSH
40458: LD_INT 3
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 1
40467: NEG
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 3
40478: NEG
40479: PUSH
40480: LD_INT 2
40482: NEG
40483: PUSH
40484: EMPTY
40485: LIST
40486: LIST
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: LIST
40492: LIST
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40513: LD_ADDR_VAR 0 34
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: LD_INT 1
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: LD_INT 1
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 1
40571: NEG
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: NEG
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 1
40594: NEG
40595: PUSH
40596: LD_INT 2
40598: NEG
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 1
40617: PUSH
40618: LD_INT 1
40620: NEG
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 2
40628: PUSH
40629: LD_INT 1
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 2
40638: PUSH
40639: LD_INT 2
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 1
40648: PUSH
40649: LD_INT 2
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 1
40658: NEG
40659: PUSH
40660: LD_INT 1
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 2
40669: NEG
40670: PUSH
40671: LD_INT 0
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 2
40680: NEG
40681: PUSH
40682: LD_INT 1
40684: NEG
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 2
40692: NEG
40693: PUSH
40694: LD_INT 2
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 3
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 1
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 3
40727: PUSH
40728: LD_INT 2
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 2
40737: PUSH
40738: LD_INT 3
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 2
40747: NEG
40748: PUSH
40749: LD_INT 1
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 3
40758: NEG
40759: PUSH
40760: LD_INT 1
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: LIST
40772: LIST
40773: LIST
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40793: LD_ADDR_VAR 0 35
40797: PUSH
40798: LD_INT 0
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 0
40810: PUSH
40811: LD_INT 1
40813: NEG
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 1
40821: PUSH
40822: LD_INT 0
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 1
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 0
40841: PUSH
40842: LD_INT 1
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 1
40851: NEG
40852: PUSH
40853: LD_INT 0
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 1
40862: NEG
40863: PUSH
40864: LD_INT 1
40866: NEG
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 2
40874: PUSH
40875: LD_INT 1
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 2
40884: NEG
40885: PUSH
40886: LD_INT 1
40888: NEG
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40905: LD_ADDR_VAR 0 36
40909: PUSH
40910: LD_INT 0
40912: PUSH
40913: LD_INT 0
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 0
40922: PUSH
40923: LD_INT 1
40925: NEG
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 1
40933: PUSH
40934: LD_INT 0
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: LD_INT 1
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 1
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 0
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 1
40974: NEG
40975: PUSH
40976: LD_INT 1
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 1
40986: NEG
40987: PUSH
40988: LD_INT 2
40990: NEG
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: EMPTY
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
41017: LD_ADDR_VAR 0 37
41021: PUSH
41022: LD_INT 0
41024: PUSH
41025: LD_INT 0
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: LD_INT 0
41034: PUSH
41035: LD_INT 1
41037: NEG
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: LD_INT 1
41045: PUSH
41046: LD_INT 0
41048: PUSH
41049: EMPTY
41050: LIST
41051: LIST
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: LD_INT 1
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: LD_INT 1
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: LD_INT 0
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 1
41086: NEG
41087: PUSH
41088: LD_INT 1
41090: NEG
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 1
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 1
41109: NEG
41110: PUSH
41111: LD_INT 1
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: LIST
41124: LIST
41125: LIST
41126: LIST
41127: LIST
41128: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
41129: LD_ADDR_VAR 0 38
41133: PUSH
41134: LD_INT 0
41136: PUSH
41137: LD_INT 0
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: LD_INT 0
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: LD_INT 1
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: LD_INT 1
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 1
41187: NEG
41188: PUSH
41189: LD_INT 0
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 1
41198: NEG
41199: PUSH
41200: LD_INT 1
41202: NEG
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 2
41210: PUSH
41211: LD_INT 1
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: LD_INT 2
41220: NEG
41221: PUSH
41222: LD_INT 1
41224: NEG
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
41241: LD_ADDR_VAR 0 39
41245: PUSH
41246: LD_INT 0
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 0
41258: PUSH
41259: LD_INT 1
41261: NEG
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 1
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 1
41279: PUSH
41280: LD_INT 1
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 0
41289: PUSH
41290: LD_INT 1
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: NEG
41300: PUSH
41301: LD_INT 0
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 1
41310: NEG
41311: PUSH
41312: LD_INT 1
41314: NEG
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 1
41322: NEG
41323: PUSH
41324: LD_INT 2
41326: NEG
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: LD_INT 1
41334: PUSH
41335: LD_INT 2
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: LIST
41346: LIST
41347: LIST
41348: LIST
41349: LIST
41350: LIST
41351: LIST
41352: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
41353: LD_ADDR_VAR 0 40
41357: PUSH
41358: LD_INT 0
41360: PUSH
41361: LD_INT 0
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 0
41370: PUSH
41371: LD_INT 1
41373: NEG
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 1
41381: PUSH
41382: LD_INT 0
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 1
41391: PUSH
41392: LD_INT 1
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 0
41401: PUSH
41402: LD_INT 1
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 1
41411: NEG
41412: PUSH
41413: LD_INT 0
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: NEG
41423: PUSH
41424: LD_INT 1
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 1
41434: PUSH
41435: LD_INT 1
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: NEG
41446: PUSH
41447: LD_INT 1
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: EMPTY
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41465: LD_ADDR_VAR 0 41
41469: PUSH
41470: LD_INT 0
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: LD_INT 1
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 1
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 1
41503: PUSH
41504: LD_INT 1
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PUSH
41511: LD_INT 0
41513: PUSH
41514: LD_INT 1
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PUSH
41521: LD_INT 1
41523: NEG
41524: PUSH
41525: LD_INT 0
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 1
41534: NEG
41535: PUSH
41536: LD_INT 1
41538: NEG
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 1
41546: NEG
41547: PUSH
41548: LD_INT 2
41550: NEG
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 1
41558: PUSH
41559: LD_INT 1
41561: NEG
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 2
41569: PUSH
41570: LD_INT 0
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: LD_INT 2
41579: PUSH
41580: LD_INT 1
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 2
41589: PUSH
41590: LD_INT 2
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 1
41599: PUSH
41600: LD_INT 2
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 1
41609: NEG
41610: PUSH
41611: LD_INT 1
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 2
41620: NEG
41621: PUSH
41622: LD_INT 0
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: PUSH
41629: LD_INT 2
41631: NEG
41632: PUSH
41633: LD_INT 1
41635: NEG
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: LD_INT 2
41643: NEG
41644: PUSH
41645: LD_INT 2
41647: NEG
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PUSH
41653: LD_INT 2
41655: NEG
41656: PUSH
41657: LD_INT 3
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 2
41667: PUSH
41668: LD_INT 1
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: PUSH
41679: LD_INT 0
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 3
41688: PUSH
41689: LD_INT 1
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: PUSH
41699: LD_INT 2
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 3
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: LD_INT 3
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 2
41728: NEG
41729: PUSH
41730: LD_INT 1
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 3
41739: NEG
41740: PUSH
41741: LD_INT 0
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 3
41750: NEG
41751: PUSH
41752: LD_INT 1
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 3
41762: NEG
41763: PUSH
41764: LD_INT 2
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: LD_INT 3
41778: NEG
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: LIST
41813: LIST
41814: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41815: LD_ADDR_VAR 0 42
41819: PUSH
41820: LD_INT 0
41822: PUSH
41823: LD_INT 0
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 0
41832: PUSH
41833: LD_INT 1
41835: NEG
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 1
41843: PUSH
41844: LD_INT 0
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: PUSH
41854: LD_INT 1
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 0
41863: PUSH
41864: LD_INT 1
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: LD_INT 1
41873: NEG
41874: PUSH
41875: LD_INT 0
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: LD_INT 1
41884: NEG
41885: PUSH
41886: LD_INT 1
41888: NEG
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 1
41896: NEG
41897: PUSH
41898: LD_INT 2
41900: NEG
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 0
41908: PUSH
41909: LD_INT 2
41911: NEG
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 1
41919: PUSH
41920: LD_INT 1
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: LD_INT 1
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: LD_INT 2
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 1
41950: PUSH
41951: LD_INT 2
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 0
41960: PUSH
41961: LD_INT 2
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 1
41970: NEG
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 2
41981: NEG
41982: PUSH
41983: LD_INT 1
41985: NEG
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 2
41993: NEG
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 2
42005: NEG
42006: PUSH
42007: LD_INT 3
42009: NEG
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 1
42017: NEG
42018: PUSH
42019: LD_INT 3
42021: NEG
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 0
42029: PUSH
42030: LD_INT 3
42032: NEG
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 1
42040: PUSH
42041: LD_INT 2
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 3
42051: PUSH
42052: LD_INT 2
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 3
42061: PUSH
42062: LD_INT 3
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 2
42071: PUSH
42072: LD_INT 3
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 1
42081: PUSH
42082: LD_INT 3
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 0
42091: PUSH
42092: LD_INT 3
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: NEG
42102: PUSH
42103: LD_INT 2
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: LD_INT 2
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 3
42124: NEG
42125: PUSH
42126: LD_INT 3
42128: NEG
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42165: LD_ADDR_VAR 0 43
42169: PUSH
42170: LD_INT 0
42172: PUSH
42173: LD_INT 0
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 0
42182: PUSH
42183: LD_INT 1
42185: NEG
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 1
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 1
42203: PUSH
42204: LD_INT 1
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 0
42213: PUSH
42214: LD_INT 1
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 1
42223: NEG
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 1
42234: NEG
42235: PUSH
42236: LD_INT 1
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 1
42246: NEG
42247: PUSH
42248: LD_INT 2
42250: NEG
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: LD_INT 2
42261: NEG
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: LD_INT 1
42269: PUSH
42270: LD_INT 1
42272: NEG
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 2
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: LD_INT 1
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 1
42300: PUSH
42301: LD_INT 2
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 0
42310: PUSH
42311: LD_INT 2
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 1
42320: NEG
42321: PUSH
42322: LD_INT 1
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 2
42331: NEG
42332: PUSH
42333: LD_INT 0
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 2
42342: NEG
42343: PUSH
42344: LD_INT 1
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 1
42354: NEG
42355: PUSH
42356: LD_INT 3
42358: NEG
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PUSH
42364: LD_INT 0
42366: PUSH
42367: LD_INT 3
42369: NEG
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 1
42377: PUSH
42378: LD_INT 2
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 2
42388: PUSH
42389: LD_INT 1
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 3
42399: PUSH
42400: LD_INT 0
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: LD_INT 3
42409: PUSH
42410: LD_INT 1
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: LD_INT 1
42419: PUSH
42420: LD_INT 3
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 0
42429: PUSH
42430: LD_INT 3
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: LD_INT 1
42439: NEG
42440: PUSH
42441: LD_INT 2
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: LD_INT 1
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 3
42461: NEG
42462: PUSH
42463: LD_INT 0
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 3
42472: NEG
42473: PUSH
42474: LD_INT 1
42476: NEG
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42513: LD_ADDR_VAR 0 44
42517: PUSH
42518: LD_INT 0
42520: PUSH
42521: LD_INT 0
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 0
42530: PUSH
42531: LD_INT 1
42533: NEG
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 1
42541: PUSH
42542: LD_INT 0
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: PUSH
42552: LD_INT 1
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: LD_INT 1
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 1
42571: NEG
42572: PUSH
42573: LD_INT 0
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 1
42582: NEG
42583: PUSH
42584: LD_INT 1
42586: NEG
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 1
42594: NEG
42595: PUSH
42596: LD_INT 2
42598: NEG
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 1
42606: PUSH
42607: LD_INT 1
42609: NEG
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 2
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 2
42627: PUSH
42628: LD_INT 1
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PUSH
42635: LD_INT 2
42637: PUSH
42638: LD_INT 2
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 1
42647: PUSH
42648: LD_INT 2
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 1
42657: NEG
42658: PUSH
42659: LD_INT 1
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: LD_INT 0
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 2
42679: NEG
42680: PUSH
42681: LD_INT 1
42683: NEG
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 2
42691: NEG
42692: PUSH
42693: LD_INT 2
42695: NEG
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 2
42703: NEG
42704: PUSH
42705: LD_INT 3
42707: NEG
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: LD_INT 1
42718: NEG
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 3
42726: PUSH
42727: LD_INT 0
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 3
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 3
42746: PUSH
42747: LD_INT 2
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 3
42756: PUSH
42757: LD_INT 3
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 2
42766: PUSH
42767: LD_INT 3
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 2
42776: NEG
42777: PUSH
42778: LD_INT 1
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: LD_INT 0
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 3
42798: NEG
42799: PUSH
42800: LD_INT 1
42802: NEG
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 3
42810: NEG
42811: PUSH
42812: LD_INT 2
42814: NEG
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 3
42822: NEG
42823: PUSH
42824: LD_INT 3
42826: NEG
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42863: LD_ADDR_VAR 0 45
42867: PUSH
42868: LD_INT 0
42870: PUSH
42871: LD_INT 0
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 0
42880: PUSH
42881: LD_INT 1
42883: NEG
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 1
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 1
42901: PUSH
42902: LD_INT 1
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 1
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 1
42921: NEG
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 1
42932: NEG
42933: PUSH
42934: LD_INT 1
42936: NEG
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 1
42944: NEG
42945: PUSH
42946: LD_INT 2
42948: NEG
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: LD_INT 2
42959: NEG
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 1
42967: PUSH
42968: LD_INT 1
42970: NEG
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 2
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 2
42988: PUSH
42989: LD_INT 2
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 1
42998: PUSH
42999: LD_INT 2
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 0
43008: PUSH
43009: LD_INT 2
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 1
43018: NEG
43019: PUSH
43020: LD_INT 1
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 2
43029: NEG
43030: PUSH
43031: LD_INT 1
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: LD_INT 2
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 2
43053: NEG
43054: PUSH
43055: LD_INT 3
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 1
43065: NEG
43066: PUSH
43067: LD_INT 3
43069: NEG
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: LD_INT 3
43080: NEG
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: LD_INT 2
43091: NEG
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 3
43099: PUSH
43100: LD_INT 2
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 3
43109: PUSH
43110: LD_INT 3
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 2
43119: PUSH
43120: LD_INT 3
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 1
43129: PUSH
43130: LD_INT 3
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 0
43139: PUSH
43140: LD_INT 3
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: NEG
43150: PUSH
43151: LD_INT 2
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 3
43160: NEG
43161: PUSH
43162: LD_INT 2
43164: NEG
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: LD_INT 3
43172: NEG
43173: PUSH
43174: LD_INT 3
43176: NEG
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: LIST
43210: LIST
43211: LIST
43212: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43213: LD_ADDR_VAR 0 46
43217: PUSH
43218: LD_INT 0
43220: PUSH
43221: LD_INT 0
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 0
43230: PUSH
43231: LD_INT 1
43233: NEG
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 1
43241: PUSH
43242: LD_INT 0
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 1
43251: PUSH
43252: LD_INT 1
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 0
43261: PUSH
43262: LD_INT 1
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: LD_INT 0
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 1
43282: NEG
43283: PUSH
43284: LD_INT 1
43286: NEG
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 1
43294: NEG
43295: PUSH
43296: LD_INT 2
43298: NEG
43299: PUSH
43300: EMPTY
43301: LIST
43302: LIST
43303: PUSH
43304: LD_INT 0
43306: PUSH
43307: LD_INT 2
43309: NEG
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: LD_INT 1
43317: PUSH
43318: LD_INT 1
43320: NEG
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PUSH
43326: LD_INT 2
43328: PUSH
43329: LD_INT 0
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 2
43338: PUSH
43339: LD_INT 1
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PUSH
43346: LD_INT 1
43348: PUSH
43349: LD_INT 2
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: PUSH
43356: LD_INT 0
43358: PUSH
43359: LD_INT 2
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 1
43368: NEG
43369: PUSH
43370: LD_INT 1
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 2
43379: NEG
43380: PUSH
43381: LD_INT 0
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 2
43390: NEG
43391: PUSH
43392: LD_INT 1
43394: NEG
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 1
43402: NEG
43403: PUSH
43404: LD_INT 3
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 0
43414: PUSH
43415: LD_INT 3
43417: NEG
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 1
43425: PUSH
43426: LD_INT 2
43428: NEG
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 2
43436: PUSH
43437: LD_INT 1
43439: NEG
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 3
43447: PUSH
43448: LD_INT 0
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PUSH
43455: LD_INT 3
43457: PUSH
43458: LD_INT 1
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 1
43467: PUSH
43468: LD_INT 3
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 0
43477: PUSH
43478: LD_INT 3
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 1
43487: NEG
43488: PUSH
43489: LD_INT 2
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 2
43498: NEG
43499: PUSH
43500: LD_INT 1
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 3
43509: NEG
43510: PUSH
43511: LD_INT 0
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 3
43520: NEG
43521: PUSH
43522: LD_INT 1
43524: NEG
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43561: LD_ADDR_VAR 0 47
43565: PUSH
43566: LD_INT 0
43568: PUSH
43569: LD_INT 0
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 0
43578: PUSH
43579: LD_INT 1
43581: NEG
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 1
43589: PUSH
43590: LD_INT 0
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 1
43599: PUSH
43600: LD_INT 1
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 0
43609: PUSH
43610: LD_INT 1
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 1
43619: NEG
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 1
43630: NEG
43631: PUSH
43632: LD_INT 1
43634: NEG
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 1
43642: NEG
43643: PUSH
43644: LD_INT 2
43646: NEG
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 0
43654: PUSH
43655: LD_INT 2
43657: NEG
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 1
43665: PUSH
43666: LD_INT 1
43668: NEG
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 2
43676: NEG
43677: PUSH
43678: LD_INT 1
43680: NEG
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 2
43688: NEG
43689: PUSH
43690: LD_INT 2
43692: NEG
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43712: LD_ADDR_VAR 0 48
43716: PUSH
43717: LD_INT 0
43719: PUSH
43720: LD_INT 0
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 0
43729: PUSH
43730: LD_INT 1
43732: NEG
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 1
43740: PUSH
43741: LD_INT 0
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: LD_INT 1
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 0
43760: PUSH
43761: LD_INT 1
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 1
43770: NEG
43771: PUSH
43772: LD_INT 0
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 1
43781: NEG
43782: PUSH
43783: LD_INT 1
43785: NEG
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: NEG
43794: PUSH
43795: LD_INT 2
43797: NEG
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: LD_INT 2
43808: NEG
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: PUSH
43817: LD_INT 1
43819: NEG
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 2
43827: PUSH
43828: LD_INT 0
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 2
43837: PUSH
43838: LD_INT 1
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43859: LD_ADDR_VAR 0 49
43863: PUSH
43864: LD_INT 0
43866: PUSH
43867: LD_INT 0
43869: PUSH
43870: EMPTY
43871: LIST
43872: LIST
43873: PUSH
43874: LD_INT 0
43876: PUSH
43877: LD_INT 1
43879: NEG
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: PUSH
43885: LD_INT 1
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 1
43897: PUSH
43898: LD_INT 1
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 0
43907: PUSH
43908: LD_INT 1
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: PUSH
43915: LD_INT 1
43917: NEG
43918: PUSH
43919: LD_INT 0
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 1
43928: NEG
43929: PUSH
43930: LD_INT 1
43932: NEG
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: PUSH
43938: LD_INT 1
43940: PUSH
43941: LD_INT 1
43943: NEG
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 2
43951: PUSH
43952: LD_INT 0
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 2
43961: PUSH
43962: LD_INT 1
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 2
43971: PUSH
43972: LD_INT 2
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 1
43981: PUSH
43982: LD_INT 2
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44003: LD_ADDR_VAR 0 50
44007: PUSH
44008: LD_INT 0
44010: PUSH
44011: LD_INT 0
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 0
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 1
44031: PUSH
44032: LD_INT 0
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 1
44041: PUSH
44042: LD_INT 1
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 0
44051: PUSH
44052: LD_INT 1
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 1
44061: NEG
44062: PUSH
44063: LD_INT 0
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 1
44072: NEG
44073: PUSH
44074: LD_INT 1
44076: NEG
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 2
44084: PUSH
44085: LD_INT 1
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 2
44094: PUSH
44095: LD_INT 2
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: LD_INT 2
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 0
44114: PUSH
44115: LD_INT 2
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 1
44124: NEG
44125: PUSH
44126: LD_INT 1
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44147: LD_ADDR_VAR 0 51
44151: PUSH
44152: LD_INT 0
44154: PUSH
44155: LD_INT 0
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 0
44164: PUSH
44165: LD_INT 1
44167: NEG
44168: PUSH
44169: EMPTY
44170: LIST
44171: LIST
44172: PUSH
44173: LD_INT 1
44175: PUSH
44176: LD_INT 0
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PUSH
44183: LD_INT 1
44185: PUSH
44186: LD_INT 1
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 0
44195: PUSH
44196: LD_INT 1
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 1
44205: NEG
44206: PUSH
44207: LD_INT 0
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 1
44216: NEG
44217: PUSH
44218: LD_INT 1
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 1
44228: PUSH
44229: LD_INT 2
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 0
44238: PUSH
44239: LD_INT 2
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 1
44248: NEG
44249: PUSH
44250: LD_INT 1
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: LD_INT 0
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 2
44270: NEG
44271: PUSH
44272: LD_INT 1
44274: NEG
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44294: LD_ADDR_VAR 0 52
44298: PUSH
44299: LD_INT 0
44301: PUSH
44302: LD_INT 0
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: LD_INT 0
44311: PUSH
44312: LD_INT 1
44314: NEG
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 1
44322: PUSH
44323: LD_INT 0
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 1
44332: PUSH
44333: LD_INT 1
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 0
44342: PUSH
44343: LD_INT 1
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 1
44352: NEG
44353: PUSH
44354: LD_INT 0
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 1
44363: NEG
44364: PUSH
44365: LD_INT 1
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 1
44375: NEG
44376: PUSH
44377: LD_INT 2
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 1
44387: NEG
44388: PUSH
44389: LD_INT 1
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: LD_INT 0
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 2
44409: NEG
44410: PUSH
44411: LD_INT 1
44413: NEG
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 2
44421: NEG
44422: PUSH
44423: LD_INT 2
44425: NEG
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44445: LD_ADDR_VAR 0 53
44449: PUSH
44450: LD_INT 0
44452: PUSH
44453: LD_INT 0
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 0
44462: PUSH
44463: LD_INT 1
44465: NEG
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 1
44473: PUSH
44474: LD_INT 0
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: PUSH
44484: LD_INT 1
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 0
44493: PUSH
44494: LD_INT 1
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 1
44503: NEG
44504: PUSH
44505: LD_INT 0
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 1
44514: NEG
44515: PUSH
44516: LD_INT 1
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 1
44526: NEG
44527: PUSH
44528: LD_INT 2
44530: NEG
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: LD_INT 0
44538: PUSH
44539: LD_INT 2
44541: NEG
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PUSH
44547: LD_INT 1
44549: PUSH
44550: LD_INT 1
44552: NEG
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 2
44560: PUSH
44561: LD_INT 0
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 2
44570: PUSH
44571: LD_INT 1
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 2
44580: PUSH
44581: LD_INT 2
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 1
44590: PUSH
44591: LD_INT 2
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 0
44600: PUSH
44601: LD_INT 2
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 1
44610: NEG
44611: PUSH
44612: LD_INT 1
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 2
44621: NEG
44622: PUSH
44623: LD_INT 0
44625: PUSH
44626: EMPTY
44627: LIST
44628: LIST
44629: PUSH
44630: LD_INT 2
44632: NEG
44633: PUSH
44634: LD_INT 1
44636: NEG
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 2
44644: NEG
44645: PUSH
44646: LD_INT 2
44648: NEG
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44675: LD_ADDR_VAR 0 54
44679: PUSH
44680: LD_INT 0
44682: PUSH
44683: LD_INT 0
44685: PUSH
44686: EMPTY
44687: LIST
44688: LIST
44689: PUSH
44690: LD_INT 0
44692: PUSH
44693: LD_INT 1
44695: NEG
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_INT 1
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 1
44713: PUSH
44714: LD_INT 1
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 0
44723: PUSH
44724: LD_INT 1
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 1
44733: NEG
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 1
44744: NEG
44745: PUSH
44746: LD_INT 1
44748: NEG
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: PUSH
44754: LD_INT 1
44756: NEG
44757: PUSH
44758: LD_INT 2
44760: NEG
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: LD_INT 2
44771: NEG
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 1
44779: PUSH
44780: LD_INT 1
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 2
44790: PUSH
44791: LD_INT 0
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 2
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 2
44810: PUSH
44811: LD_INT 2
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 1
44820: PUSH
44821: LD_INT 2
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: PUSH
44828: LD_INT 0
44830: PUSH
44831: LD_INT 2
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: PUSH
44838: LD_INT 1
44840: NEG
44841: PUSH
44842: LD_INT 1
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 2
44851: NEG
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 2
44862: NEG
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 2
44874: NEG
44875: PUSH
44876: LD_INT 2
44878: NEG
44879: PUSH
44880: EMPTY
44881: LIST
44882: LIST
44883: PUSH
44884: EMPTY
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44905: LD_ADDR_VAR 0 55
44909: PUSH
44910: LD_INT 0
44912: PUSH
44913: LD_INT 0
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 0
44922: PUSH
44923: LD_INT 1
44925: NEG
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 1
44933: PUSH
44934: LD_INT 0
44936: PUSH
44937: EMPTY
44938: LIST
44939: LIST
44940: PUSH
44941: LD_INT 1
44943: PUSH
44944: LD_INT 1
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 0
44953: PUSH
44954: LD_INT 1
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 1
44963: NEG
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 1
44974: NEG
44975: PUSH
44976: LD_INT 1
44978: NEG
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 1
44986: NEG
44987: PUSH
44988: LD_INT 2
44990: NEG
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: PUSH
44996: LD_INT 0
44998: PUSH
44999: LD_INT 2
45001: NEG
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 1
45009: PUSH
45010: LD_INT 1
45012: NEG
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 2
45020: PUSH
45021: LD_INT 0
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 2
45030: PUSH
45031: LD_INT 1
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 2
45040: PUSH
45041: LD_INT 2
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: PUSH
45048: LD_INT 1
45050: PUSH
45051: LD_INT 2
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 0
45060: PUSH
45061: LD_INT 2
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: PUSH
45068: LD_INT 1
45070: NEG
45071: PUSH
45072: LD_INT 1
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 2
45081: NEG
45082: PUSH
45083: LD_INT 0
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 2
45092: NEG
45093: PUSH
45094: LD_INT 1
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 2
45104: NEG
45105: PUSH
45106: LD_INT 2
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45135: LD_ADDR_VAR 0 56
45139: PUSH
45140: LD_INT 0
45142: PUSH
45143: LD_INT 0
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: LD_INT 0
45152: PUSH
45153: LD_INT 1
45155: NEG
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 1
45163: PUSH
45164: LD_INT 0
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 1
45173: PUSH
45174: LD_INT 1
45176: PUSH
45177: EMPTY
45178: LIST
45179: LIST
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: LD_INT 1
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 1
45193: NEG
45194: PUSH
45195: LD_INT 0
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 1
45204: NEG
45205: PUSH
45206: LD_INT 1
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 1
45216: NEG
45217: PUSH
45218: LD_INT 2
45220: NEG
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 0
45228: PUSH
45229: LD_INT 2
45231: NEG
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 1
45239: PUSH
45240: LD_INT 1
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 2
45250: PUSH
45251: LD_INT 0
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: LD_INT 2
45260: PUSH
45261: LD_INT 1
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 2
45270: PUSH
45271: LD_INT 2
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: PUSH
45278: LD_INT 1
45280: PUSH
45281: LD_INT 2
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 0
45290: PUSH
45291: LD_INT 2
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 1
45300: NEG
45301: PUSH
45302: LD_INT 1
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: LD_INT 2
45311: NEG
45312: PUSH
45313: LD_INT 0
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 2
45322: NEG
45323: PUSH
45324: LD_INT 1
45326: NEG
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 2
45334: NEG
45335: PUSH
45336: LD_INT 2
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45365: LD_ADDR_VAR 0 57
45369: PUSH
45370: LD_INT 0
45372: PUSH
45373: LD_INT 0
45375: PUSH
45376: EMPTY
45377: LIST
45378: LIST
45379: PUSH
45380: LD_INT 0
45382: PUSH
45383: LD_INT 1
45385: NEG
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 1
45393: PUSH
45394: LD_INT 0
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 1
45403: PUSH
45404: LD_INT 1
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 0
45413: PUSH
45414: LD_INT 1
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 1
45423: NEG
45424: PUSH
45425: LD_INT 0
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 1
45434: NEG
45435: PUSH
45436: LD_INT 1
45438: NEG
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 1
45446: NEG
45447: PUSH
45448: LD_INT 2
45450: NEG
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 0
45458: PUSH
45459: LD_INT 2
45461: NEG
45462: PUSH
45463: EMPTY
45464: LIST
45465: LIST
45466: PUSH
45467: LD_INT 1
45469: PUSH
45470: LD_INT 1
45472: NEG
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: LD_INT 2
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 2
45490: PUSH
45491: LD_INT 1
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 2
45500: PUSH
45501: LD_INT 2
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 1
45510: PUSH
45511: LD_INT 2
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: LD_INT 2
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: PUSH
45528: LD_INT 1
45530: NEG
45531: PUSH
45532: LD_INT 1
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 2
45541: NEG
45542: PUSH
45543: LD_INT 0
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 2
45552: NEG
45553: PUSH
45554: LD_INT 1
45556: NEG
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 2
45564: NEG
45565: PUSH
45566: LD_INT 2
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45595: LD_ADDR_VAR 0 58
45599: PUSH
45600: LD_INT 0
45602: PUSH
45603: LD_INT 0
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 0
45612: PUSH
45613: LD_INT 1
45615: NEG
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: LD_INT 0
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: LD_INT 1
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 0
45643: PUSH
45644: LD_INT 1
45646: PUSH
45647: EMPTY
45648: LIST
45649: LIST
45650: PUSH
45651: LD_INT 1
45653: NEG
45654: PUSH
45655: LD_INT 0
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: LD_INT 1
45664: NEG
45665: PUSH
45666: LD_INT 1
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 1
45676: NEG
45677: PUSH
45678: LD_INT 2
45680: NEG
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: LD_INT 2
45691: NEG
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 1
45699: PUSH
45700: LD_INT 1
45702: NEG
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: PUSH
45708: LD_INT 2
45710: PUSH
45711: LD_INT 0
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: PUSH
45718: LD_INT 2
45720: PUSH
45721: LD_INT 1
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: LD_INT 2
45730: PUSH
45731: LD_INT 2
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 1
45740: PUSH
45741: LD_INT 2
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PUSH
45748: LD_INT 0
45750: PUSH
45751: LD_INT 2
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: PUSH
45758: LD_INT 1
45760: NEG
45761: PUSH
45762: LD_INT 1
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 2
45771: NEG
45772: PUSH
45773: LD_INT 0
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 2
45782: NEG
45783: PUSH
45784: LD_INT 1
45786: NEG
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 2
45794: NEG
45795: PUSH
45796: LD_INT 2
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45825: LD_ADDR_VAR 0 59
45829: PUSH
45830: LD_INT 0
45832: PUSH
45833: LD_INT 0
45835: PUSH
45836: EMPTY
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 0
45842: PUSH
45843: LD_INT 1
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 1
45853: PUSH
45854: LD_INT 0
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 1
45863: PUSH
45864: LD_INT 1
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 0
45873: PUSH
45874: LD_INT 1
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 1
45883: NEG
45884: PUSH
45885: LD_INT 0
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: LD_INT 1
45894: NEG
45895: PUSH
45896: LD_INT 1
45898: NEG
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45913: LD_ADDR_VAR 0 60
45917: PUSH
45918: LD_INT 0
45920: PUSH
45921: LD_INT 0
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 0
45930: PUSH
45931: LD_INT 1
45933: NEG
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 1
45941: PUSH
45942: LD_INT 0
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 1
45951: PUSH
45952: LD_INT 1
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 0
45961: PUSH
45962: LD_INT 1
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 1
45971: NEG
45972: PUSH
45973: LD_INT 0
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: PUSH
45980: LD_INT 1
45982: NEG
45983: PUSH
45984: LD_INT 1
45986: NEG
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46001: LD_ADDR_VAR 0 61
46005: PUSH
46006: LD_INT 0
46008: PUSH
46009: LD_INT 0
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 0
46018: PUSH
46019: LD_INT 1
46021: NEG
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: PUSH
46027: LD_INT 1
46029: PUSH
46030: LD_INT 0
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: PUSH
46037: LD_INT 1
46039: PUSH
46040: LD_INT 1
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: PUSH
46047: LD_INT 0
46049: PUSH
46050: LD_INT 1
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: PUSH
46057: LD_INT 1
46059: NEG
46060: PUSH
46061: LD_INT 0
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 1
46070: NEG
46071: PUSH
46072: LD_INT 1
46074: NEG
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46089: LD_ADDR_VAR 0 62
46093: PUSH
46094: LD_INT 0
46096: PUSH
46097: LD_INT 0
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 0
46106: PUSH
46107: LD_INT 1
46109: NEG
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 1
46117: PUSH
46118: LD_INT 0
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 1
46127: PUSH
46128: LD_INT 1
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 0
46137: PUSH
46138: LD_INT 1
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 1
46147: NEG
46148: PUSH
46149: LD_INT 0
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 1
46158: NEG
46159: PUSH
46160: LD_INT 1
46162: NEG
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46177: LD_ADDR_VAR 0 63
46181: PUSH
46182: LD_INT 0
46184: PUSH
46185: LD_INT 0
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 0
46194: PUSH
46195: LD_INT 1
46197: NEG
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 1
46205: PUSH
46206: LD_INT 0
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 1
46215: PUSH
46216: LD_INT 1
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 0
46225: PUSH
46226: LD_INT 1
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 1
46235: NEG
46236: PUSH
46237: LD_INT 0
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: LD_INT 1
46246: NEG
46247: PUSH
46248: LD_INT 1
46250: NEG
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: LIST
46260: LIST
46261: LIST
46262: LIST
46263: LIST
46264: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46265: LD_ADDR_VAR 0 64
46269: PUSH
46270: LD_INT 0
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 0
46282: PUSH
46283: LD_INT 1
46285: NEG
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 1
46293: PUSH
46294: LD_INT 0
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 1
46303: PUSH
46304: LD_INT 1
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 0
46313: PUSH
46314: LD_INT 1
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 1
46323: NEG
46324: PUSH
46325: LD_INT 0
46327: PUSH
46328: EMPTY
46329: LIST
46330: LIST
46331: PUSH
46332: LD_INT 1
46334: NEG
46335: PUSH
46336: LD_INT 1
46338: NEG
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: ST_TO_ADDR
// end ; 1 :
46353: GO 52250
46355: LD_INT 1
46357: DOUBLE
46358: EQUAL
46359: IFTRUE 46363
46361: GO 48986
46363: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46364: LD_ADDR_VAR 0 11
46368: PUSH
46369: LD_INT 1
46371: NEG
46372: PUSH
46373: LD_INT 3
46375: NEG
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 0
46383: PUSH
46384: LD_INT 3
46386: NEG
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: PUSH
46392: LD_INT 1
46394: PUSH
46395: LD_INT 2
46397: NEG
46398: PUSH
46399: EMPTY
46400: LIST
46401: LIST
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: LIST
46407: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46408: LD_ADDR_VAR 0 12
46412: PUSH
46413: LD_INT 2
46415: PUSH
46416: LD_INT 1
46418: NEG
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: PUSH
46424: LD_INT 3
46426: PUSH
46427: LD_INT 0
46429: PUSH
46430: EMPTY
46431: LIST
46432: LIST
46433: PUSH
46434: LD_INT 3
46436: PUSH
46437: LD_INT 1
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: LIST
46448: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46449: LD_ADDR_VAR 0 13
46453: PUSH
46454: LD_INT 3
46456: PUSH
46457: LD_INT 2
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: PUSH
46464: LD_INT 3
46466: PUSH
46467: LD_INT 3
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 2
46476: PUSH
46477: LD_INT 3
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: LIST
46488: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46489: LD_ADDR_VAR 0 14
46493: PUSH
46494: LD_INT 1
46496: PUSH
46497: LD_INT 3
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 0
46506: PUSH
46507: LD_INT 3
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: PUSH
46514: LD_INT 1
46516: NEG
46517: PUSH
46518: LD_INT 2
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: LIST
46529: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46530: LD_ADDR_VAR 0 15
46534: PUSH
46535: LD_INT 2
46537: NEG
46538: PUSH
46539: LD_INT 1
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: PUSH
46546: LD_INT 3
46548: NEG
46549: PUSH
46550: LD_INT 0
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: PUSH
46557: LD_INT 3
46559: NEG
46560: PUSH
46561: LD_INT 1
46563: NEG
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: LIST
46573: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46574: LD_ADDR_VAR 0 16
46578: PUSH
46579: LD_INT 2
46581: NEG
46582: PUSH
46583: LD_INT 3
46585: NEG
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: LD_INT 3
46593: NEG
46594: PUSH
46595: LD_INT 2
46597: NEG
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 3
46605: NEG
46606: PUSH
46607: LD_INT 3
46609: NEG
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: LIST
46619: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46620: LD_ADDR_VAR 0 17
46624: PUSH
46625: LD_INT 1
46627: NEG
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 0
46639: PUSH
46640: LD_INT 3
46642: NEG
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: PUSH
46648: LD_INT 1
46650: PUSH
46651: LD_INT 2
46653: NEG
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: LIST
46663: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46664: LD_ADDR_VAR 0 18
46668: PUSH
46669: LD_INT 2
46671: PUSH
46672: LD_INT 1
46674: NEG
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: LD_INT 3
46682: PUSH
46683: LD_INT 0
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PUSH
46690: LD_INT 3
46692: PUSH
46693: LD_INT 1
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: EMPTY
46701: LIST
46702: LIST
46703: LIST
46704: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46705: LD_ADDR_VAR 0 19
46709: PUSH
46710: LD_INT 3
46712: PUSH
46713: LD_INT 2
46715: PUSH
46716: EMPTY
46717: LIST
46718: LIST
46719: PUSH
46720: LD_INT 3
46722: PUSH
46723: LD_INT 3
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 2
46732: PUSH
46733: LD_INT 3
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: LIST
46744: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46745: LD_ADDR_VAR 0 20
46749: PUSH
46750: LD_INT 1
46752: PUSH
46753: LD_INT 3
46755: PUSH
46756: EMPTY
46757: LIST
46758: LIST
46759: PUSH
46760: LD_INT 0
46762: PUSH
46763: LD_INT 3
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 1
46772: NEG
46773: PUSH
46774: LD_INT 2
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: LIST
46785: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46786: LD_ADDR_VAR 0 21
46790: PUSH
46791: LD_INT 2
46793: NEG
46794: PUSH
46795: LD_INT 1
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: PUSH
46802: LD_INT 3
46804: NEG
46805: PUSH
46806: LD_INT 0
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: PUSH
46813: LD_INT 3
46815: NEG
46816: PUSH
46817: LD_INT 1
46819: NEG
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: PUSH
46825: EMPTY
46826: LIST
46827: LIST
46828: LIST
46829: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46830: LD_ADDR_VAR 0 22
46834: PUSH
46835: LD_INT 2
46837: NEG
46838: PUSH
46839: LD_INT 3
46841: NEG
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 3
46849: NEG
46850: PUSH
46851: LD_INT 2
46853: NEG
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_INT 3
46861: NEG
46862: PUSH
46863: LD_INT 3
46865: NEG
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: LIST
46875: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46876: LD_ADDR_VAR 0 23
46880: PUSH
46881: LD_INT 0
46883: PUSH
46884: LD_INT 3
46886: NEG
46887: PUSH
46888: EMPTY
46889: LIST
46890: LIST
46891: PUSH
46892: LD_INT 1
46894: NEG
46895: PUSH
46896: LD_INT 4
46898: NEG
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 1
46906: PUSH
46907: LD_INT 3
46909: NEG
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: LIST
46919: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46920: LD_ADDR_VAR 0 24
46924: PUSH
46925: LD_INT 3
46927: PUSH
46928: LD_INT 0
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 3
46937: PUSH
46938: LD_INT 1
46940: NEG
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: LD_INT 4
46948: PUSH
46949: LD_INT 1
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: LIST
46960: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46961: LD_ADDR_VAR 0 25
46965: PUSH
46966: LD_INT 3
46968: PUSH
46969: LD_INT 3
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 4
46978: PUSH
46979: LD_INT 3
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_INT 3
46988: PUSH
46989: LD_INT 4
46991: PUSH
46992: EMPTY
46993: LIST
46994: LIST
46995: PUSH
46996: EMPTY
46997: LIST
46998: LIST
46999: LIST
47000: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
47001: LD_ADDR_VAR 0 26
47005: PUSH
47006: LD_INT 0
47008: PUSH
47009: LD_INT 3
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: LD_INT 1
47018: PUSH
47019: LD_INT 4
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: LD_INT 1
47028: NEG
47029: PUSH
47030: LD_INT 3
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: LIST
47041: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
47042: LD_ADDR_VAR 0 27
47046: PUSH
47047: LD_INT 3
47049: NEG
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: EMPTY
47055: LIST
47056: LIST
47057: PUSH
47058: LD_INT 3
47060: NEG
47061: PUSH
47062: LD_INT 1
47064: PUSH
47065: EMPTY
47066: LIST
47067: LIST
47068: PUSH
47069: LD_INT 4
47071: NEG
47072: PUSH
47073: LD_INT 1
47075: NEG
47076: PUSH
47077: EMPTY
47078: LIST
47079: LIST
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: LIST
47085: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
47086: LD_ADDR_VAR 0 28
47090: PUSH
47091: LD_INT 3
47093: NEG
47094: PUSH
47095: LD_INT 3
47097: NEG
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 3
47105: NEG
47106: PUSH
47107: LD_INT 4
47109: NEG
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: PUSH
47115: LD_INT 4
47117: NEG
47118: PUSH
47119: LD_INT 3
47121: NEG
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: EMPTY
47128: LIST
47129: LIST
47130: LIST
47131: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
47132: LD_ADDR_VAR 0 29
47136: PUSH
47137: LD_INT 1
47139: NEG
47140: PUSH
47141: LD_INT 3
47143: NEG
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: LD_INT 3
47154: NEG
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: LD_INT 2
47165: NEG
47166: PUSH
47167: EMPTY
47168: LIST
47169: LIST
47170: PUSH
47171: LD_INT 1
47173: NEG
47174: PUSH
47175: LD_INT 4
47177: NEG
47178: PUSH
47179: EMPTY
47180: LIST
47181: LIST
47182: PUSH
47183: LD_INT 0
47185: PUSH
47186: LD_INT 4
47188: NEG
47189: PUSH
47190: EMPTY
47191: LIST
47192: LIST
47193: PUSH
47194: LD_INT 1
47196: PUSH
47197: LD_INT 3
47199: NEG
47200: PUSH
47201: EMPTY
47202: LIST
47203: LIST
47204: PUSH
47205: LD_INT 1
47207: NEG
47208: PUSH
47209: LD_INT 5
47211: NEG
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: PUSH
47217: LD_INT 0
47219: PUSH
47220: LD_INT 5
47222: NEG
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: LD_INT 4
47233: NEG
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 1
47241: NEG
47242: PUSH
47243: LD_INT 6
47245: NEG
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: PUSH
47251: LD_INT 0
47253: PUSH
47254: LD_INT 6
47256: NEG
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: PUSH
47262: LD_INT 1
47264: PUSH
47265: LD_INT 5
47267: NEG
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
47287: LD_ADDR_VAR 0 30
47291: PUSH
47292: LD_INT 2
47294: PUSH
47295: LD_INT 1
47297: NEG
47298: PUSH
47299: EMPTY
47300: LIST
47301: LIST
47302: PUSH
47303: LD_INT 3
47305: PUSH
47306: LD_INT 0
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 3
47315: PUSH
47316: LD_INT 1
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: LD_INT 3
47325: PUSH
47326: LD_INT 1
47328: NEG
47329: PUSH
47330: EMPTY
47331: LIST
47332: LIST
47333: PUSH
47334: LD_INT 4
47336: PUSH
47337: LD_INT 0
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PUSH
47344: LD_INT 4
47346: PUSH
47347: LD_INT 1
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: LD_INT 4
47356: PUSH
47357: LD_INT 1
47359: NEG
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 5
47367: PUSH
47368: LD_INT 0
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: LD_INT 5
47377: PUSH
47378: LD_INT 1
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: LD_INT 5
47387: PUSH
47388: LD_INT 1
47390: NEG
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: LD_INT 6
47398: PUSH
47399: LD_INT 0
47401: PUSH
47402: EMPTY
47403: LIST
47404: LIST
47405: PUSH
47406: LD_INT 6
47408: PUSH
47409: LD_INT 1
47411: PUSH
47412: EMPTY
47413: LIST
47414: LIST
47415: PUSH
47416: EMPTY
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
47430: LD_ADDR_VAR 0 31
47434: PUSH
47435: LD_INT 3
47437: PUSH
47438: LD_INT 2
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: PUSH
47445: LD_INT 3
47447: PUSH
47448: LD_INT 3
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: LD_INT 2
47457: PUSH
47458: LD_INT 3
47460: PUSH
47461: EMPTY
47462: LIST
47463: LIST
47464: PUSH
47465: LD_INT 4
47467: PUSH
47468: LD_INT 3
47470: PUSH
47471: EMPTY
47472: LIST
47473: LIST
47474: PUSH
47475: LD_INT 4
47477: PUSH
47478: LD_INT 4
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: LD_INT 3
47487: PUSH
47488: LD_INT 4
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: PUSH
47495: LD_INT 5
47497: PUSH
47498: LD_INT 4
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 5
47507: PUSH
47508: LD_INT 5
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: LD_INT 4
47517: PUSH
47518: LD_INT 5
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PUSH
47525: LD_INT 6
47527: PUSH
47528: LD_INT 5
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 6
47537: PUSH
47538: LD_INT 6
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 5
47547: PUSH
47548: LD_INT 6
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
47569: LD_ADDR_VAR 0 32
47573: PUSH
47574: LD_INT 1
47576: PUSH
47577: LD_INT 3
47579: PUSH
47580: EMPTY
47581: LIST
47582: LIST
47583: PUSH
47584: LD_INT 0
47586: PUSH
47587: LD_INT 3
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PUSH
47594: LD_INT 1
47596: NEG
47597: PUSH
47598: LD_INT 2
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: PUSH
47605: LD_INT 1
47607: PUSH
47608: LD_INT 4
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: PUSH
47615: LD_INT 0
47617: PUSH
47618: LD_INT 4
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: PUSH
47625: LD_INT 1
47627: NEG
47628: PUSH
47629: LD_INT 3
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: PUSH
47636: LD_INT 1
47638: PUSH
47639: LD_INT 5
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: PUSH
47646: LD_INT 0
47648: PUSH
47649: LD_INT 5
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: PUSH
47656: LD_INT 1
47658: NEG
47659: PUSH
47660: LD_INT 4
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: PUSH
47667: LD_INT 1
47669: PUSH
47670: LD_INT 6
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PUSH
47677: LD_INT 0
47679: PUSH
47680: LD_INT 6
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: PUSH
47687: LD_INT 1
47689: NEG
47690: PUSH
47691: LD_INT 5
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: PUSH
47698: EMPTY
47699: LIST
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47712: LD_ADDR_VAR 0 33
47716: PUSH
47717: LD_INT 2
47719: NEG
47720: PUSH
47721: LD_INT 1
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PUSH
47728: LD_INT 3
47730: NEG
47731: PUSH
47732: LD_INT 0
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PUSH
47739: LD_INT 3
47741: NEG
47742: PUSH
47743: LD_INT 1
47745: NEG
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: LD_INT 3
47753: NEG
47754: PUSH
47755: LD_INT 1
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 4
47764: NEG
47765: PUSH
47766: LD_INT 0
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 4
47775: NEG
47776: PUSH
47777: LD_INT 1
47779: NEG
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: LD_INT 4
47787: NEG
47788: PUSH
47789: LD_INT 1
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PUSH
47796: LD_INT 5
47798: NEG
47799: PUSH
47800: LD_INT 0
47802: PUSH
47803: EMPTY
47804: LIST
47805: LIST
47806: PUSH
47807: LD_INT 5
47809: NEG
47810: PUSH
47811: LD_INT 1
47813: NEG
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: LD_INT 5
47821: NEG
47822: PUSH
47823: LD_INT 1
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 6
47832: NEG
47833: PUSH
47834: LD_INT 0
47836: PUSH
47837: EMPTY
47838: LIST
47839: LIST
47840: PUSH
47841: LD_INT 6
47843: NEG
47844: PUSH
47845: LD_INT 1
47847: NEG
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: PUSH
47853: EMPTY
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47867: LD_ADDR_VAR 0 34
47871: PUSH
47872: LD_INT 2
47874: NEG
47875: PUSH
47876: LD_INT 3
47878: NEG
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: PUSH
47884: LD_INT 3
47886: NEG
47887: PUSH
47888: LD_INT 2
47890: NEG
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PUSH
47896: LD_INT 3
47898: NEG
47899: PUSH
47900: LD_INT 3
47902: NEG
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: PUSH
47908: LD_INT 3
47910: NEG
47911: PUSH
47912: LD_INT 4
47914: NEG
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: LD_INT 4
47922: NEG
47923: PUSH
47924: LD_INT 3
47926: NEG
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: PUSH
47932: LD_INT 4
47934: NEG
47935: PUSH
47936: LD_INT 4
47938: NEG
47939: PUSH
47940: EMPTY
47941: LIST
47942: LIST
47943: PUSH
47944: LD_INT 4
47946: NEG
47947: PUSH
47948: LD_INT 5
47950: NEG
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PUSH
47956: LD_INT 5
47958: NEG
47959: PUSH
47960: LD_INT 4
47962: NEG
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: LD_INT 5
47970: NEG
47971: PUSH
47972: LD_INT 5
47974: NEG
47975: PUSH
47976: EMPTY
47977: LIST
47978: LIST
47979: PUSH
47980: LD_INT 5
47982: NEG
47983: PUSH
47984: LD_INT 6
47986: NEG
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 6
47994: NEG
47995: PUSH
47996: LD_INT 5
47998: NEG
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: PUSH
48004: LD_INT 6
48006: NEG
48007: PUSH
48008: LD_INT 6
48010: NEG
48011: PUSH
48012: EMPTY
48013: LIST
48014: LIST
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
48030: LD_ADDR_VAR 0 41
48034: PUSH
48035: LD_INT 0
48037: PUSH
48038: LD_INT 2
48040: NEG
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_INT 1
48048: NEG
48049: PUSH
48050: LD_INT 3
48052: NEG
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: LD_INT 1
48060: PUSH
48061: LD_INT 2
48063: NEG
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: PUSH
48069: EMPTY
48070: LIST
48071: LIST
48072: LIST
48073: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
48074: LD_ADDR_VAR 0 42
48078: PUSH
48079: LD_INT 2
48081: PUSH
48082: LD_INT 0
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: PUSH
48089: LD_INT 2
48091: PUSH
48092: LD_INT 1
48094: NEG
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: PUSH
48100: LD_INT 3
48102: PUSH
48103: LD_INT 1
48105: PUSH
48106: EMPTY
48107: LIST
48108: LIST
48109: PUSH
48110: EMPTY
48111: LIST
48112: LIST
48113: LIST
48114: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
48115: LD_ADDR_VAR 0 43
48119: PUSH
48120: LD_INT 2
48122: PUSH
48123: LD_INT 2
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: PUSH
48130: LD_INT 3
48132: PUSH
48133: LD_INT 2
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: PUSH
48140: LD_INT 2
48142: PUSH
48143: LD_INT 3
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: LIST
48154: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
48155: LD_ADDR_VAR 0 44
48159: PUSH
48160: LD_INT 0
48162: PUSH
48163: LD_INT 2
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: LD_INT 1
48172: PUSH
48173: LD_INT 3
48175: PUSH
48176: EMPTY
48177: LIST
48178: LIST
48179: PUSH
48180: LD_INT 1
48182: NEG
48183: PUSH
48184: LD_INT 2
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: PUSH
48191: EMPTY
48192: LIST
48193: LIST
48194: LIST
48195: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
48196: LD_ADDR_VAR 0 45
48200: PUSH
48201: LD_INT 2
48203: NEG
48204: PUSH
48205: LD_INT 0
48207: PUSH
48208: EMPTY
48209: LIST
48210: LIST
48211: PUSH
48212: LD_INT 2
48214: NEG
48215: PUSH
48216: LD_INT 1
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 3
48225: NEG
48226: PUSH
48227: LD_INT 1
48229: NEG
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: PUSH
48235: EMPTY
48236: LIST
48237: LIST
48238: LIST
48239: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
48240: LD_ADDR_VAR 0 46
48244: PUSH
48245: LD_INT 2
48247: NEG
48248: PUSH
48249: LD_INT 2
48251: NEG
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: PUSH
48257: LD_INT 2
48259: NEG
48260: PUSH
48261: LD_INT 3
48263: NEG
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PUSH
48269: LD_INT 3
48271: NEG
48272: PUSH
48273: LD_INT 2
48275: NEG
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: LIST
48285: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
48286: LD_ADDR_VAR 0 47
48290: PUSH
48291: LD_INT 2
48293: NEG
48294: PUSH
48295: LD_INT 3
48297: NEG
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: PUSH
48303: LD_INT 1
48305: NEG
48306: PUSH
48307: LD_INT 3
48309: NEG
48310: PUSH
48311: EMPTY
48312: LIST
48313: LIST
48314: PUSH
48315: EMPTY
48316: LIST
48317: LIST
48318: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
48319: LD_ADDR_VAR 0 48
48323: PUSH
48324: LD_INT 1
48326: PUSH
48327: LD_INT 2
48329: NEG
48330: PUSH
48331: EMPTY
48332: LIST
48333: LIST
48334: PUSH
48335: LD_INT 2
48337: PUSH
48338: LD_INT 1
48340: NEG
48341: PUSH
48342: EMPTY
48343: LIST
48344: LIST
48345: PUSH
48346: EMPTY
48347: LIST
48348: LIST
48349: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
48350: LD_ADDR_VAR 0 49
48354: PUSH
48355: LD_INT 3
48357: PUSH
48358: LD_INT 1
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: PUSH
48365: LD_INT 3
48367: PUSH
48368: LD_INT 2
48370: PUSH
48371: EMPTY
48372: LIST
48373: LIST
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
48379: LD_ADDR_VAR 0 50
48383: PUSH
48384: LD_INT 2
48386: PUSH
48387: LD_INT 3
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: PUSH
48394: LD_INT 1
48396: PUSH
48397: LD_INT 3
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: EMPTY
48405: LIST
48406: LIST
48407: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
48408: LD_ADDR_VAR 0 51
48412: PUSH
48413: LD_INT 1
48415: NEG
48416: PUSH
48417: LD_INT 2
48419: PUSH
48420: EMPTY
48421: LIST
48422: LIST
48423: PUSH
48424: LD_INT 2
48426: NEG
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
48439: LD_ADDR_VAR 0 52
48443: PUSH
48444: LD_INT 3
48446: NEG
48447: PUSH
48448: LD_INT 1
48450: NEG
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: LD_INT 3
48458: NEG
48459: PUSH
48460: LD_INT 2
48462: NEG
48463: PUSH
48464: EMPTY
48465: LIST
48466: LIST
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
48472: LD_ADDR_VAR 0 53
48476: PUSH
48477: LD_INT 1
48479: NEG
48480: PUSH
48481: LD_INT 3
48483: NEG
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: LD_INT 0
48491: PUSH
48492: LD_INT 3
48494: NEG
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: PUSH
48500: LD_INT 1
48502: PUSH
48503: LD_INT 2
48505: NEG
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: LIST
48515: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
48516: LD_ADDR_VAR 0 54
48520: PUSH
48521: LD_INT 2
48523: PUSH
48524: LD_INT 1
48526: NEG
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: LD_INT 3
48534: PUSH
48535: LD_INT 0
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 3
48544: PUSH
48545: LD_INT 1
48547: PUSH
48548: EMPTY
48549: LIST
48550: LIST
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: LIST
48556: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
48557: LD_ADDR_VAR 0 55
48561: PUSH
48562: LD_INT 3
48564: PUSH
48565: LD_INT 2
48567: PUSH
48568: EMPTY
48569: LIST
48570: LIST
48571: PUSH
48572: LD_INT 3
48574: PUSH
48575: LD_INT 3
48577: PUSH
48578: EMPTY
48579: LIST
48580: LIST
48581: PUSH
48582: LD_INT 2
48584: PUSH
48585: LD_INT 3
48587: PUSH
48588: EMPTY
48589: LIST
48590: LIST
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: LIST
48596: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48597: LD_ADDR_VAR 0 56
48601: PUSH
48602: LD_INT 1
48604: PUSH
48605: LD_INT 3
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: PUSH
48612: LD_INT 0
48614: PUSH
48615: LD_INT 3
48617: PUSH
48618: EMPTY
48619: LIST
48620: LIST
48621: PUSH
48622: LD_INT 1
48624: NEG
48625: PUSH
48626: LD_INT 2
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: LIST
48637: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48638: LD_ADDR_VAR 0 57
48642: PUSH
48643: LD_INT 2
48645: NEG
48646: PUSH
48647: LD_INT 1
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PUSH
48654: LD_INT 3
48656: NEG
48657: PUSH
48658: LD_INT 0
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PUSH
48665: LD_INT 3
48667: NEG
48668: PUSH
48669: LD_INT 1
48671: NEG
48672: PUSH
48673: EMPTY
48674: LIST
48675: LIST
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: LIST
48681: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48682: LD_ADDR_VAR 0 58
48686: PUSH
48687: LD_INT 2
48689: NEG
48690: PUSH
48691: LD_INT 3
48693: NEG
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: PUSH
48699: LD_INT 3
48701: NEG
48702: PUSH
48703: LD_INT 2
48705: NEG
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PUSH
48711: LD_INT 3
48713: NEG
48714: PUSH
48715: LD_INT 3
48717: NEG
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: PUSH
48723: EMPTY
48724: LIST
48725: LIST
48726: LIST
48727: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48728: LD_ADDR_VAR 0 59
48732: PUSH
48733: LD_INT 1
48735: NEG
48736: PUSH
48737: LD_INT 2
48739: NEG
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PUSH
48745: LD_INT 0
48747: PUSH
48748: LD_INT 2
48750: NEG
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: LD_INT 1
48758: PUSH
48759: LD_INT 1
48761: NEG
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: LIST
48771: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48772: LD_ADDR_VAR 0 60
48776: PUSH
48777: LD_INT 1
48779: PUSH
48780: LD_INT 1
48782: NEG
48783: PUSH
48784: EMPTY
48785: LIST
48786: LIST
48787: PUSH
48788: LD_INT 2
48790: PUSH
48791: LD_INT 0
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: PUSH
48798: LD_INT 2
48800: PUSH
48801: LD_INT 1
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: LIST
48812: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48813: LD_ADDR_VAR 0 61
48817: PUSH
48818: LD_INT 2
48820: PUSH
48821: LD_INT 1
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: LD_INT 2
48830: PUSH
48831: LD_INT 2
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: PUSH
48838: LD_INT 1
48840: PUSH
48841: LD_INT 2
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: LIST
48852: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48853: LD_ADDR_VAR 0 62
48857: PUSH
48858: LD_INT 1
48860: PUSH
48861: LD_INT 2
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PUSH
48868: LD_INT 0
48870: PUSH
48871: LD_INT 2
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 1
48880: NEG
48881: PUSH
48882: LD_INT 1
48884: PUSH
48885: EMPTY
48886: LIST
48887: LIST
48888: PUSH
48889: EMPTY
48890: LIST
48891: LIST
48892: LIST
48893: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48894: LD_ADDR_VAR 0 63
48898: PUSH
48899: LD_INT 1
48901: NEG
48902: PUSH
48903: LD_INT 1
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: LD_INT 2
48912: NEG
48913: PUSH
48914: LD_INT 0
48916: PUSH
48917: EMPTY
48918: LIST
48919: LIST
48920: PUSH
48921: LD_INT 2
48923: NEG
48924: PUSH
48925: LD_INT 1
48927: NEG
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: LIST
48937: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48938: LD_ADDR_VAR 0 64
48942: PUSH
48943: LD_INT 1
48945: NEG
48946: PUSH
48947: LD_INT 2
48949: NEG
48950: PUSH
48951: EMPTY
48952: LIST
48953: LIST
48954: PUSH
48955: LD_INT 2
48957: NEG
48958: PUSH
48959: LD_INT 1
48961: NEG
48962: PUSH
48963: EMPTY
48964: LIST
48965: LIST
48966: PUSH
48967: LD_INT 2
48969: NEG
48970: PUSH
48971: LD_INT 2
48973: NEG
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: LIST
48983: ST_TO_ADDR
// end ; 2 :
48984: GO 52250
48986: LD_INT 2
48988: DOUBLE
48989: EQUAL
48990: IFTRUE 48994
48992: GO 52249
48994: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48995: LD_ADDR_VAR 0 29
48999: PUSH
49000: LD_INT 4
49002: PUSH
49003: LD_INT 0
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 4
49012: PUSH
49013: LD_INT 1
49015: NEG
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 5
49023: PUSH
49024: LD_INT 0
49026: PUSH
49027: EMPTY
49028: LIST
49029: LIST
49030: PUSH
49031: LD_INT 5
49033: PUSH
49034: LD_INT 1
49036: PUSH
49037: EMPTY
49038: LIST
49039: LIST
49040: PUSH
49041: LD_INT 4
49043: PUSH
49044: LD_INT 1
49046: PUSH
49047: EMPTY
49048: LIST
49049: LIST
49050: PUSH
49051: LD_INT 3
49053: PUSH
49054: LD_INT 0
49056: PUSH
49057: EMPTY
49058: LIST
49059: LIST
49060: PUSH
49061: LD_INT 3
49063: PUSH
49064: LD_INT 1
49066: NEG
49067: PUSH
49068: EMPTY
49069: LIST
49070: LIST
49071: PUSH
49072: LD_INT 3
49074: PUSH
49075: LD_INT 2
49077: NEG
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 5
49085: PUSH
49086: LD_INT 2
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: LD_INT 3
49095: PUSH
49096: LD_INT 3
49098: PUSH
49099: EMPTY
49100: LIST
49101: LIST
49102: PUSH
49103: LD_INT 3
49105: PUSH
49106: LD_INT 2
49108: PUSH
49109: EMPTY
49110: LIST
49111: LIST
49112: PUSH
49113: LD_INT 4
49115: PUSH
49116: LD_INT 3
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: PUSH
49123: LD_INT 4
49125: PUSH
49126: LD_INT 4
49128: PUSH
49129: EMPTY
49130: LIST
49131: LIST
49132: PUSH
49133: LD_INT 3
49135: PUSH
49136: LD_INT 4
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: PUSH
49143: LD_INT 2
49145: PUSH
49146: LD_INT 3
49148: PUSH
49149: EMPTY
49150: LIST
49151: LIST
49152: PUSH
49153: LD_INT 2
49155: PUSH
49156: LD_INT 2
49158: PUSH
49159: EMPTY
49160: LIST
49161: LIST
49162: PUSH
49163: LD_INT 4
49165: PUSH
49166: LD_INT 2
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 2
49175: PUSH
49176: LD_INT 4
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: LD_INT 0
49185: PUSH
49186: LD_INT 4
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PUSH
49193: LD_INT 0
49195: PUSH
49196: LD_INT 3
49198: PUSH
49199: EMPTY
49200: LIST
49201: LIST
49202: PUSH
49203: LD_INT 1
49205: PUSH
49206: LD_INT 4
49208: PUSH
49209: EMPTY
49210: LIST
49211: LIST
49212: PUSH
49213: LD_INT 1
49215: PUSH
49216: LD_INT 5
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: LD_INT 0
49225: PUSH
49226: LD_INT 5
49228: PUSH
49229: EMPTY
49230: LIST
49231: LIST
49232: PUSH
49233: LD_INT 1
49235: NEG
49236: PUSH
49237: LD_INT 4
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PUSH
49244: LD_INT 1
49246: NEG
49247: PUSH
49248: LD_INT 3
49250: PUSH
49251: EMPTY
49252: LIST
49253: LIST
49254: PUSH
49255: LD_INT 2
49257: PUSH
49258: LD_INT 5
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: LD_INT 2
49267: NEG
49268: PUSH
49269: LD_INT 3
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 3
49278: NEG
49279: PUSH
49280: LD_INT 0
49282: PUSH
49283: EMPTY
49284: LIST
49285: LIST
49286: PUSH
49287: LD_INT 3
49289: NEG
49290: PUSH
49291: LD_INT 1
49293: NEG
49294: PUSH
49295: EMPTY
49296: LIST
49297: LIST
49298: PUSH
49299: LD_INT 2
49301: NEG
49302: PUSH
49303: LD_INT 0
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: PUSH
49310: LD_INT 2
49312: NEG
49313: PUSH
49314: LD_INT 1
49316: PUSH
49317: EMPTY
49318: LIST
49319: LIST
49320: PUSH
49321: LD_INT 3
49323: NEG
49324: PUSH
49325: LD_INT 1
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: PUSH
49332: LD_INT 4
49334: NEG
49335: PUSH
49336: LD_INT 0
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PUSH
49343: LD_INT 4
49345: NEG
49346: PUSH
49347: LD_INT 1
49349: NEG
49350: PUSH
49351: EMPTY
49352: LIST
49353: LIST
49354: PUSH
49355: LD_INT 4
49357: NEG
49358: PUSH
49359: LD_INT 2
49361: NEG
49362: PUSH
49363: EMPTY
49364: LIST
49365: LIST
49366: PUSH
49367: LD_INT 2
49369: NEG
49370: PUSH
49371: LD_INT 2
49373: PUSH
49374: EMPTY
49375: LIST
49376: LIST
49377: PUSH
49378: LD_INT 4
49380: NEG
49381: PUSH
49382: LD_INT 4
49384: NEG
49385: PUSH
49386: EMPTY
49387: LIST
49388: LIST
49389: PUSH
49390: LD_INT 4
49392: NEG
49393: PUSH
49394: LD_INT 5
49396: NEG
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: LD_INT 3
49404: NEG
49405: PUSH
49406: LD_INT 4
49408: NEG
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: PUSH
49414: LD_INT 3
49416: NEG
49417: PUSH
49418: LD_INT 3
49420: NEG
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 4
49428: NEG
49429: PUSH
49430: LD_INT 3
49432: NEG
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: LD_INT 5
49440: NEG
49441: PUSH
49442: LD_INT 4
49444: NEG
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: PUSH
49450: LD_INT 5
49452: NEG
49453: PUSH
49454: LD_INT 5
49456: NEG
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 3
49464: NEG
49465: PUSH
49466: LD_INT 5
49468: NEG
49469: PUSH
49470: EMPTY
49471: LIST
49472: LIST
49473: PUSH
49474: LD_INT 5
49476: NEG
49477: PUSH
49478: LD_INT 3
49480: NEG
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: LIST
49494: LIST
49495: LIST
49496: LIST
49497: LIST
49498: LIST
49499: LIST
49500: LIST
49501: LIST
49502: LIST
49503: LIST
49504: LIST
49505: LIST
49506: LIST
49507: LIST
49508: LIST
49509: LIST
49510: LIST
49511: LIST
49512: LIST
49513: LIST
49514: LIST
49515: LIST
49516: LIST
49517: LIST
49518: LIST
49519: LIST
49520: LIST
49521: LIST
49522: LIST
49523: LIST
49524: LIST
49525: LIST
49526: LIST
49527: LIST
49528: LIST
49529: LIST
49530: LIST
49531: LIST
49532: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
49533: LD_ADDR_VAR 0 30
49537: PUSH
49538: LD_INT 4
49540: PUSH
49541: LD_INT 4
49543: PUSH
49544: EMPTY
49545: LIST
49546: LIST
49547: PUSH
49548: LD_INT 4
49550: PUSH
49551: LD_INT 3
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: PUSH
49558: LD_INT 5
49560: PUSH
49561: LD_INT 4
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 5
49570: PUSH
49571: LD_INT 5
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: PUSH
49581: LD_INT 5
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 3
49590: PUSH
49591: LD_INT 4
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 3
49600: PUSH
49601: LD_INT 3
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: LD_INT 5
49610: PUSH
49611: LD_INT 3
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: PUSH
49618: LD_INT 3
49620: PUSH
49621: LD_INT 5
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: LD_INT 0
49630: PUSH
49631: LD_INT 3
49633: PUSH
49634: EMPTY
49635: LIST
49636: LIST
49637: PUSH
49638: LD_INT 0
49640: PUSH
49641: LD_INT 2
49643: PUSH
49644: EMPTY
49645: LIST
49646: LIST
49647: PUSH
49648: LD_INT 1
49650: PUSH
49651: LD_INT 3
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: PUSH
49658: LD_INT 1
49660: PUSH
49661: LD_INT 4
49663: PUSH
49664: EMPTY
49665: LIST
49666: LIST
49667: PUSH
49668: LD_INT 0
49670: PUSH
49671: LD_INT 4
49673: PUSH
49674: EMPTY
49675: LIST
49676: LIST
49677: PUSH
49678: LD_INT 1
49680: NEG
49681: PUSH
49682: LD_INT 3
49684: PUSH
49685: EMPTY
49686: LIST
49687: LIST
49688: PUSH
49689: LD_INT 1
49691: NEG
49692: PUSH
49693: LD_INT 2
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 2
49702: PUSH
49703: LD_INT 4
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 2
49712: NEG
49713: PUSH
49714: LD_INT 2
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 4
49723: NEG
49724: PUSH
49725: LD_INT 0
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PUSH
49732: LD_INT 4
49734: NEG
49735: PUSH
49736: LD_INT 1
49738: NEG
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: PUSH
49744: LD_INT 3
49746: NEG
49747: PUSH
49748: LD_INT 0
49750: PUSH
49751: EMPTY
49752: LIST
49753: LIST
49754: PUSH
49755: LD_INT 3
49757: NEG
49758: PUSH
49759: LD_INT 1
49761: PUSH
49762: EMPTY
49763: LIST
49764: LIST
49765: PUSH
49766: LD_INT 4
49768: NEG
49769: PUSH
49770: LD_INT 1
49772: PUSH
49773: EMPTY
49774: LIST
49775: LIST
49776: PUSH
49777: LD_INT 5
49779: NEG
49780: PUSH
49781: LD_INT 0
49783: PUSH
49784: EMPTY
49785: LIST
49786: LIST
49787: PUSH
49788: LD_INT 5
49790: NEG
49791: PUSH
49792: LD_INT 1
49794: NEG
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PUSH
49800: LD_INT 5
49802: NEG
49803: PUSH
49804: LD_INT 2
49806: NEG
49807: PUSH
49808: EMPTY
49809: LIST
49810: LIST
49811: PUSH
49812: LD_INT 3
49814: NEG
49815: PUSH
49816: LD_INT 2
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PUSH
49823: LD_INT 3
49825: NEG
49826: PUSH
49827: LD_INT 3
49829: NEG
49830: PUSH
49831: EMPTY
49832: LIST
49833: LIST
49834: PUSH
49835: LD_INT 3
49837: NEG
49838: PUSH
49839: LD_INT 4
49841: NEG
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: PUSH
49847: LD_INT 2
49849: NEG
49850: PUSH
49851: LD_INT 3
49853: NEG
49854: PUSH
49855: EMPTY
49856: LIST
49857: LIST
49858: PUSH
49859: LD_INT 2
49861: NEG
49862: PUSH
49863: LD_INT 2
49865: NEG
49866: PUSH
49867: EMPTY
49868: LIST
49869: LIST
49870: PUSH
49871: LD_INT 3
49873: NEG
49874: PUSH
49875: LD_INT 2
49877: NEG
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: LD_INT 4
49885: NEG
49886: PUSH
49887: LD_INT 3
49889: NEG
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 4
49897: NEG
49898: PUSH
49899: LD_INT 4
49901: NEG
49902: PUSH
49903: EMPTY
49904: LIST
49905: LIST
49906: PUSH
49907: LD_INT 2
49909: NEG
49910: PUSH
49911: LD_INT 4
49913: NEG
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: PUSH
49919: LD_INT 4
49921: NEG
49922: PUSH
49923: LD_INT 2
49925: NEG
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: PUSH
49931: LD_INT 0
49933: PUSH
49934: LD_INT 4
49936: NEG
49937: PUSH
49938: EMPTY
49939: LIST
49940: LIST
49941: PUSH
49942: LD_INT 0
49944: PUSH
49945: LD_INT 5
49947: NEG
49948: PUSH
49949: EMPTY
49950: LIST
49951: LIST
49952: PUSH
49953: LD_INT 1
49955: PUSH
49956: LD_INT 4
49958: NEG
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: PUSH
49964: LD_INT 1
49966: PUSH
49967: LD_INT 3
49969: NEG
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: PUSH
49975: LD_INT 0
49977: PUSH
49978: LD_INT 3
49980: NEG
49981: PUSH
49982: EMPTY
49983: LIST
49984: LIST
49985: PUSH
49986: LD_INT 1
49988: NEG
49989: PUSH
49990: LD_INT 4
49992: NEG
49993: PUSH
49994: EMPTY
49995: LIST
49996: LIST
49997: PUSH
49998: LD_INT 1
50000: NEG
50001: PUSH
50002: LD_INT 5
50004: NEG
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: PUSH
50010: LD_INT 2
50012: PUSH
50013: LD_INT 3
50015: NEG
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: PUSH
50021: LD_INT 2
50023: NEG
50024: PUSH
50025: LD_INT 5
50027: NEG
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: LIST
50037: LIST
50038: LIST
50039: LIST
50040: LIST
50041: LIST
50042: LIST
50043: LIST
50044: LIST
50045: LIST
50046: LIST
50047: LIST
50048: LIST
50049: LIST
50050: LIST
50051: LIST
50052: LIST
50053: LIST
50054: LIST
50055: LIST
50056: LIST
50057: LIST
50058: LIST
50059: LIST
50060: LIST
50061: LIST
50062: LIST
50063: LIST
50064: LIST
50065: LIST
50066: LIST
50067: LIST
50068: LIST
50069: LIST
50070: LIST
50071: LIST
50072: LIST
50073: LIST
50074: LIST
50075: LIST
50076: LIST
50077: LIST
50078: LIST
50079: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
50080: LD_ADDR_VAR 0 31
50084: PUSH
50085: LD_INT 0
50087: PUSH
50088: LD_INT 4
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: LD_INT 0
50097: PUSH
50098: LD_INT 3
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 1
50107: PUSH
50108: LD_INT 4
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 1
50117: PUSH
50118: LD_INT 5
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 0
50127: PUSH
50128: LD_INT 5
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 1
50137: NEG
50138: PUSH
50139: LD_INT 4
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: PUSH
50146: LD_INT 1
50148: NEG
50149: PUSH
50150: LD_INT 3
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PUSH
50157: LD_INT 2
50159: PUSH
50160: LD_INT 5
50162: PUSH
50163: EMPTY
50164: LIST
50165: LIST
50166: PUSH
50167: LD_INT 2
50169: NEG
50170: PUSH
50171: LD_INT 3
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 3
50180: NEG
50181: PUSH
50182: LD_INT 0
50184: PUSH
50185: EMPTY
50186: LIST
50187: LIST
50188: PUSH
50189: LD_INT 3
50191: NEG
50192: PUSH
50193: LD_INT 1
50195: NEG
50196: PUSH
50197: EMPTY
50198: LIST
50199: LIST
50200: PUSH
50201: LD_INT 2
50203: NEG
50204: PUSH
50205: LD_INT 0
50207: PUSH
50208: EMPTY
50209: LIST
50210: LIST
50211: PUSH
50212: LD_INT 2
50214: NEG
50215: PUSH
50216: LD_INT 1
50218: PUSH
50219: EMPTY
50220: LIST
50221: LIST
50222: PUSH
50223: LD_INT 3
50225: NEG
50226: PUSH
50227: LD_INT 1
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: PUSH
50234: LD_INT 4
50236: NEG
50237: PUSH
50238: LD_INT 0
50240: PUSH
50241: EMPTY
50242: LIST
50243: LIST
50244: PUSH
50245: LD_INT 4
50247: NEG
50248: PUSH
50249: LD_INT 1
50251: NEG
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PUSH
50257: LD_INT 4
50259: NEG
50260: PUSH
50261: LD_INT 2
50263: NEG
50264: PUSH
50265: EMPTY
50266: LIST
50267: LIST
50268: PUSH
50269: LD_INT 2
50271: NEG
50272: PUSH
50273: LD_INT 2
50275: PUSH
50276: EMPTY
50277: LIST
50278: LIST
50279: PUSH
50280: LD_INT 4
50282: NEG
50283: PUSH
50284: LD_INT 4
50286: NEG
50287: PUSH
50288: EMPTY
50289: LIST
50290: LIST
50291: PUSH
50292: LD_INT 4
50294: NEG
50295: PUSH
50296: LD_INT 5
50298: NEG
50299: PUSH
50300: EMPTY
50301: LIST
50302: LIST
50303: PUSH
50304: LD_INT 3
50306: NEG
50307: PUSH
50308: LD_INT 4
50310: NEG
50311: PUSH
50312: EMPTY
50313: LIST
50314: LIST
50315: PUSH
50316: LD_INT 3
50318: NEG
50319: PUSH
50320: LD_INT 3
50322: NEG
50323: PUSH
50324: EMPTY
50325: LIST
50326: LIST
50327: PUSH
50328: LD_INT 4
50330: NEG
50331: PUSH
50332: LD_INT 3
50334: NEG
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 5
50342: NEG
50343: PUSH
50344: LD_INT 4
50346: NEG
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 5
50354: NEG
50355: PUSH
50356: LD_INT 5
50358: NEG
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 3
50366: NEG
50367: PUSH
50368: LD_INT 5
50370: NEG
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 5
50378: NEG
50379: PUSH
50380: LD_INT 3
50382: NEG
50383: PUSH
50384: EMPTY
50385: LIST
50386: LIST
50387: PUSH
50388: LD_INT 0
50390: PUSH
50391: LD_INT 3
50393: NEG
50394: PUSH
50395: EMPTY
50396: LIST
50397: LIST
50398: PUSH
50399: LD_INT 0
50401: PUSH
50402: LD_INT 4
50404: NEG
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 1
50412: PUSH
50413: LD_INT 3
50415: NEG
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: LD_INT 1
50423: PUSH
50424: LD_INT 2
50426: NEG
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: PUSH
50432: LD_INT 0
50434: PUSH
50435: LD_INT 2
50437: NEG
50438: PUSH
50439: EMPTY
50440: LIST
50441: LIST
50442: PUSH
50443: LD_INT 1
50445: NEG
50446: PUSH
50447: LD_INT 3
50449: NEG
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: PUSH
50455: LD_INT 1
50457: NEG
50458: PUSH
50459: LD_INT 4
50461: NEG
50462: PUSH
50463: EMPTY
50464: LIST
50465: LIST
50466: PUSH
50467: LD_INT 2
50469: PUSH
50470: LD_INT 2
50472: NEG
50473: PUSH
50474: EMPTY
50475: LIST
50476: LIST
50477: PUSH
50478: LD_INT 2
50480: NEG
50481: PUSH
50482: LD_INT 4
50484: NEG
50485: PUSH
50486: EMPTY
50487: LIST
50488: LIST
50489: PUSH
50490: LD_INT 4
50492: PUSH
50493: LD_INT 0
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: PUSH
50500: LD_INT 4
50502: PUSH
50503: LD_INT 1
50505: NEG
50506: PUSH
50507: EMPTY
50508: LIST
50509: LIST
50510: PUSH
50511: LD_INT 5
50513: PUSH
50514: LD_INT 0
50516: PUSH
50517: EMPTY
50518: LIST
50519: LIST
50520: PUSH
50521: LD_INT 5
50523: PUSH
50524: LD_INT 1
50526: PUSH
50527: EMPTY
50528: LIST
50529: LIST
50530: PUSH
50531: LD_INT 4
50533: PUSH
50534: LD_INT 1
50536: PUSH
50537: EMPTY
50538: LIST
50539: LIST
50540: PUSH
50541: LD_INT 3
50543: PUSH
50544: LD_INT 0
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PUSH
50551: LD_INT 3
50553: PUSH
50554: LD_INT 1
50556: NEG
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: PUSH
50562: LD_INT 3
50564: PUSH
50565: LD_INT 2
50567: NEG
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PUSH
50573: LD_INT 5
50575: PUSH
50576: LD_INT 2
50578: PUSH
50579: EMPTY
50580: LIST
50581: LIST
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: LIST
50587: LIST
50588: LIST
50589: LIST
50590: LIST
50591: LIST
50592: LIST
50593: LIST
50594: LIST
50595: LIST
50596: LIST
50597: LIST
50598: LIST
50599: LIST
50600: LIST
50601: LIST
50602: LIST
50603: LIST
50604: LIST
50605: LIST
50606: LIST
50607: LIST
50608: LIST
50609: LIST
50610: LIST
50611: LIST
50612: LIST
50613: LIST
50614: LIST
50615: LIST
50616: LIST
50617: LIST
50618: LIST
50619: LIST
50620: LIST
50621: LIST
50622: LIST
50623: LIST
50624: LIST
50625: LIST
50626: LIST
50627: LIST
50628: LIST
50629: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50630: LD_ADDR_VAR 0 32
50634: PUSH
50635: LD_INT 4
50637: NEG
50638: PUSH
50639: LD_INT 0
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: LD_INT 4
50648: NEG
50649: PUSH
50650: LD_INT 1
50652: NEG
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: PUSH
50658: LD_INT 3
50660: NEG
50661: PUSH
50662: LD_INT 0
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PUSH
50669: LD_INT 3
50671: NEG
50672: PUSH
50673: LD_INT 1
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 4
50682: NEG
50683: PUSH
50684: LD_INT 1
50686: PUSH
50687: EMPTY
50688: LIST
50689: LIST
50690: PUSH
50691: LD_INT 5
50693: NEG
50694: PUSH
50695: LD_INT 0
50697: PUSH
50698: EMPTY
50699: LIST
50700: LIST
50701: PUSH
50702: LD_INT 5
50704: NEG
50705: PUSH
50706: LD_INT 1
50708: NEG
50709: PUSH
50710: EMPTY
50711: LIST
50712: LIST
50713: PUSH
50714: LD_INT 5
50716: NEG
50717: PUSH
50718: LD_INT 2
50720: NEG
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: PUSH
50726: LD_INT 3
50728: NEG
50729: PUSH
50730: LD_INT 2
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PUSH
50737: LD_INT 3
50739: NEG
50740: PUSH
50741: LD_INT 3
50743: NEG
50744: PUSH
50745: EMPTY
50746: LIST
50747: LIST
50748: PUSH
50749: LD_INT 3
50751: NEG
50752: PUSH
50753: LD_INT 4
50755: NEG
50756: PUSH
50757: EMPTY
50758: LIST
50759: LIST
50760: PUSH
50761: LD_INT 2
50763: NEG
50764: PUSH
50765: LD_INT 3
50767: NEG
50768: PUSH
50769: EMPTY
50770: LIST
50771: LIST
50772: PUSH
50773: LD_INT 2
50775: NEG
50776: PUSH
50777: LD_INT 2
50779: NEG
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: PUSH
50785: LD_INT 3
50787: NEG
50788: PUSH
50789: LD_INT 2
50791: NEG
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: LD_INT 4
50799: NEG
50800: PUSH
50801: LD_INT 3
50803: NEG
50804: PUSH
50805: EMPTY
50806: LIST
50807: LIST
50808: PUSH
50809: LD_INT 4
50811: NEG
50812: PUSH
50813: LD_INT 4
50815: NEG
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: PUSH
50821: LD_INT 2
50823: NEG
50824: PUSH
50825: LD_INT 4
50827: NEG
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PUSH
50833: LD_INT 4
50835: NEG
50836: PUSH
50837: LD_INT 2
50839: NEG
50840: PUSH
50841: EMPTY
50842: LIST
50843: LIST
50844: PUSH
50845: LD_INT 0
50847: PUSH
50848: LD_INT 4
50850: NEG
50851: PUSH
50852: EMPTY
50853: LIST
50854: LIST
50855: PUSH
50856: LD_INT 0
50858: PUSH
50859: LD_INT 5
50861: NEG
50862: PUSH
50863: EMPTY
50864: LIST
50865: LIST
50866: PUSH
50867: LD_INT 1
50869: PUSH
50870: LD_INT 4
50872: NEG
50873: PUSH
50874: EMPTY
50875: LIST
50876: LIST
50877: PUSH
50878: LD_INT 1
50880: PUSH
50881: LD_INT 3
50883: NEG
50884: PUSH
50885: EMPTY
50886: LIST
50887: LIST
50888: PUSH
50889: LD_INT 0
50891: PUSH
50892: LD_INT 3
50894: NEG
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PUSH
50900: LD_INT 1
50902: NEG
50903: PUSH
50904: LD_INT 4
50906: NEG
50907: PUSH
50908: EMPTY
50909: LIST
50910: LIST
50911: PUSH
50912: LD_INT 1
50914: NEG
50915: PUSH
50916: LD_INT 5
50918: NEG
50919: PUSH
50920: EMPTY
50921: LIST
50922: LIST
50923: PUSH
50924: LD_INT 2
50926: PUSH
50927: LD_INT 3
50929: NEG
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PUSH
50935: LD_INT 2
50937: NEG
50938: PUSH
50939: LD_INT 5
50941: NEG
50942: PUSH
50943: EMPTY
50944: LIST
50945: LIST
50946: PUSH
50947: LD_INT 3
50949: PUSH
50950: LD_INT 0
50952: PUSH
50953: EMPTY
50954: LIST
50955: LIST
50956: PUSH
50957: LD_INT 3
50959: PUSH
50960: LD_INT 1
50962: NEG
50963: PUSH
50964: EMPTY
50965: LIST
50966: LIST
50967: PUSH
50968: LD_INT 4
50970: PUSH
50971: LD_INT 0
50973: PUSH
50974: EMPTY
50975: LIST
50976: LIST
50977: PUSH
50978: LD_INT 4
50980: PUSH
50981: LD_INT 1
50983: PUSH
50984: EMPTY
50985: LIST
50986: LIST
50987: PUSH
50988: LD_INT 3
50990: PUSH
50991: LD_INT 1
50993: PUSH
50994: EMPTY
50995: LIST
50996: LIST
50997: PUSH
50998: LD_INT 2
51000: PUSH
51001: LD_INT 0
51003: PUSH
51004: EMPTY
51005: LIST
51006: LIST
51007: PUSH
51008: LD_INT 2
51010: PUSH
51011: LD_INT 1
51013: NEG
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PUSH
51019: LD_INT 2
51021: PUSH
51022: LD_INT 2
51024: NEG
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 4
51032: PUSH
51033: LD_INT 2
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PUSH
51040: LD_INT 4
51042: PUSH
51043: LD_INT 4
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: PUSH
51050: LD_INT 4
51052: PUSH
51053: LD_INT 3
51055: PUSH
51056: EMPTY
51057: LIST
51058: LIST
51059: PUSH
51060: LD_INT 5
51062: PUSH
51063: LD_INT 4
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PUSH
51070: LD_INT 5
51072: PUSH
51073: LD_INT 5
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: PUSH
51080: LD_INT 4
51082: PUSH
51083: LD_INT 5
51085: PUSH
51086: EMPTY
51087: LIST
51088: LIST
51089: PUSH
51090: LD_INT 3
51092: PUSH
51093: LD_INT 4
51095: PUSH
51096: EMPTY
51097: LIST
51098: LIST
51099: PUSH
51100: LD_INT 3
51102: PUSH
51103: LD_INT 3
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: PUSH
51110: LD_INT 5
51112: PUSH
51113: LD_INT 3
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PUSH
51120: LD_INT 3
51122: PUSH
51123: LD_INT 5
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: PUSH
51130: EMPTY
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: LIST
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: LIST
51153: LIST
51154: LIST
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
51177: LD_ADDR_VAR 0 33
51181: PUSH
51182: LD_INT 4
51184: NEG
51185: PUSH
51186: LD_INT 4
51188: NEG
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: PUSH
51194: LD_INT 4
51196: NEG
51197: PUSH
51198: LD_INT 5
51200: NEG
51201: PUSH
51202: EMPTY
51203: LIST
51204: LIST
51205: PUSH
51206: LD_INT 3
51208: NEG
51209: PUSH
51210: LD_INT 4
51212: NEG
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: PUSH
51218: LD_INT 3
51220: NEG
51221: PUSH
51222: LD_INT 3
51224: NEG
51225: PUSH
51226: EMPTY
51227: LIST
51228: LIST
51229: PUSH
51230: LD_INT 4
51232: NEG
51233: PUSH
51234: LD_INT 3
51236: NEG
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 5
51244: NEG
51245: PUSH
51246: LD_INT 4
51248: NEG
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: LD_INT 5
51256: NEG
51257: PUSH
51258: LD_INT 5
51260: NEG
51261: PUSH
51262: EMPTY
51263: LIST
51264: LIST
51265: PUSH
51266: LD_INT 3
51268: NEG
51269: PUSH
51270: LD_INT 5
51272: NEG
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 5
51280: NEG
51281: PUSH
51282: LD_INT 3
51284: NEG
51285: PUSH
51286: EMPTY
51287: LIST
51288: LIST
51289: PUSH
51290: LD_INT 0
51292: PUSH
51293: LD_INT 3
51295: NEG
51296: PUSH
51297: EMPTY
51298: LIST
51299: LIST
51300: PUSH
51301: LD_INT 0
51303: PUSH
51304: LD_INT 4
51306: NEG
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: PUSH
51312: LD_INT 1
51314: PUSH
51315: LD_INT 3
51317: NEG
51318: PUSH
51319: EMPTY
51320: LIST
51321: LIST
51322: PUSH
51323: LD_INT 1
51325: PUSH
51326: LD_INT 2
51328: NEG
51329: PUSH
51330: EMPTY
51331: LIST
51332: LIST
51333: PUSH
51334: LD_INT 0
51336: PUSH
51337: LD_INT 2
51339: NEG
51340: PUSH
51341: EMPTY
51342: LIST
51343: LIST
51344: PUSH
51345: LD_INT 1
51347: NEG
51348: PUSH
51349: LD_INT 3
51351: NEG
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: PUSH
51357: LD_INT 1
51359: NEG
51360: PUSH
51361: LD_INT 4
51363: NEG
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 2
51371: PUSH
51372: LD_INT 2
51374: NEG
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 2
51382: NEG
51383: PUSH
51384: LD_INT 4
51386: NEG
51387: PUSH
51388: EMPTY
51389: LIST
51390: LIST
51391: PUSH
51392: LD_INT 4
51394: PUSH
51395: LD_INT 0
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: PUSH
51402: LD_INT 4
51404: PUSH
51405: LD_INT 1
51407: NEG
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: PUSH
51413: LD_INT 5
51415: PUSH
51416: LD_INT 0
51418: PUSH
51419: EMPTY
51420: LIST
51421: LIST
51422: PUSH
51423: LD_INT 5
51425: PUSH
51426: LD_INT 1
51428: PUSH
51429: EMPTY
51430: LIST
51431: LIST
51432: PUSH
51433: LD_INT 4
51435: PUSH
51436: LD_INT 1
51438: PUSH
51439: EMPTY
51440: LIST
51441: LIST
51442: PUSH
51443: LD_INT 3
51445: PUSH
51446: LD_INT 0
51448: PUSH
51449: EMPTY
51450: LIST
51451: LIST
51452: PUSH
51453: LD_INT 3
51455: PUSH
51456: LD_INT 1
51458: NEG
51459: PUSH
51460: EMPTY
51461: LIST
51462: LIST
51463: PUSH
51464: LD_INT 3
51466: PUSH
51467: LD_INT 2
51469: NEG
51470: PUSH
51471: EMPTY
51472: LIST
51473: LIST
51474: PUSH
51475: LD_INT 5
51477: PUSH
51478: LD_INT 2
51480: PUSH
51481: EMPTY
51482: LIST
51483: LIST
51484: PUSH
51485: LD_INT 3
51487: PUSH
51488: LD_INT 3
51490: PUSH
51491: EMPTY
51492: LIST
51493: LIST
51494: PUSH
51495: LD_INT 3
51497: PUSH
51498: LD_INT 2
51500: PUSH
51501: EMPTY
51502: LIST
51503: LIST
51504: PUSH
51505: LD_INT 4
51507: PUSH
51508: LD_INT 3
51510: PUSH
51511: EMPTY
51512: LIST
51513: LIST
51514: PUSH
51515: LD_INT 4
51517: PUSH
51518: LD_INT 4
51520: PUSH
51521: EMPTY
51522: LIST
51523: LIST
51524: PUSH
51525: LD_INT 3
51527: PUSH
51528: LD_INT 4
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: PUSH
51535: LD_INT 2
51537: PUSH
51538: LD_INT 3
51540: PUSH
51541: EMPTY
51542: LIST
51543: LIST
51544: PUSH
51545: LD_INT 2
51547: PUSH
51548: LD_INT 2
51550: PUSH
51551: EMPTY
51552: LIST
51553: LIST
51554: PUSH
51555: LD_INT 4
51557: PUSH
51558: LD_INT 2
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: PUSH
51565: LD_INT 2
51567: PUSH
51568: LD_INT 4
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: LD_INT 0
51577: PUSH
51578: LD_INT 4
51580: PUSH
51581: EMPTY
51582: LIST
51583: LIST
51584: PUSH
51585: LD_INT 0
51587: PUSH
51588: LD_INT 3
51590: PUSH
51591: EMPTY
51592: LIST
51593: LIST
51594: PUSH
51595: LD_INT 1
51597: PUSH
51598: LD_INT 4
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: LD_INT 1
51607: PUSH
51608: LD_INT 5
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: PUSH
51615: LD_INT 0
51617: PUSH
51618: LD_INT 5
51620: PUSH
51621: EMPTY
51622: LIST
51623: LIST
51624: PUSH
51625: LD_INT 1
51627: NEG
51628: PUSH
51629: LD_INT 4
51631: PUSH
51632: EMPTY
51633: LIST
51634: LIST
51635: PUSH
51636: LD_INT 1
51638: NEG
51639: PUSH
51640: LD_INT 3
51642: PUSH
51643: EMPTY
51644: LIST
51645: LIST
51646: PUSH
51647: LD_INT 2
51649: PUSH
51650: LD_INT 5
51652: PUSH
51653: EMPTY
51654: LIST
51655: LIST
51656: PUSH
51657: LD_INT 2
51659: NEG
51660: PUSH
51661: LD_INT 3
51663: PUSH
51664: EMPTY
51665: LIST
51666: LIST
51667: PUSH
51668: EMPTY
51669: LIST
51670: LIST
51671: LIST
51672: LIST
51673: LIST
51674: LIST
51675: LIST
51676: LIST
51677: LIST
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: LIST
51683: LIST
51684: LIST
51685: LIST
51686: LIST
51687: LIST
51688: LIST
51689: LIST
51690: LIST
51691: LIST
51692: LIST
51693: LIST
51694: LIST
51695: LIST
51696: LIST
51697: LIST
51698: LIST
51699: LIST
51700: LIST
51701: LIST
51702: LIST
51703: LIST
51704: LIST
51705: LIST
51706: LIST
51707: LIST
51708: LIST
51709: LIST
51710: LIST
51711: LIST
51712: LIST
51713: LIST
51714: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51715: LD_ADDR_VAR 0 34
51719: PUSH
51720: LD_INT 0
51722: PUSH
51723: LD_INT 4
51725: NEG
51726: PUSH
51727: EMPTY
51728: LIST
51729: LIST
51730: PUSH
51731: LD_INT 0
51733: PUSH
51734: LD_INT 5
51736: NEG
51737: PUSH
51738: EMPTY
51739: LIST
51740: LIST
51741: PUSH
51742: LD_INT 1
51744: PUSH
51745: LD_INT 4
51747: NEG
51748: PUSH
51749: EMPTY
51750: LIST
51751: LIST
51752: PUSH
51753: LD_INT 1
51755: PUSH
51756: LD_INT 3
51758: NEG
51759: PUSH
51760: EMPTY
51761: LIST
51762: LIST
51763: PUSH
51764: LD_INT 0
51766: PUSH
51767: LD_INT 3
51769: NEG
51770: PUSH
51771: EMPTY
51772: LIST
51773: LIST
51774: PUSH
51775: LD_INT 1
51777: NEG
51778: PUSH
51779: LD_INT 4
51781: NEG
51782: PUSH
51783: EMPTY
51784: LIST
51785: LIST
51786: PUSH
51787: LD_INT 1
51789: NEG
51790: PUSH
51791: LD_INT 5
51793: NEG
51794: PUSH
51795: EMPTY
51796: LIST
51797: LIST
51798: PUSH
51799: LD_INT 2
51801: PUSH
51802: LD_INT 3
51804: NEG
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PUSH
51810: LD_INT 2
51812: NEG
51813: PUSH
51814: LD_INT 5
51816: NEG
51817: PUSH
51818: EMPTY
51819: LIST
51820: LIST
51821: PUSH
51822: LD_INT 3
51824: PUSH
51825: LD_INT 0
51827: PUSH
51828: EMPTY
51829: LIST
51830: LIST
51831: PUSH
51832: LD_INT 3
51834: PUSH
51835: LD_INT 1
51837: NEG
51838: PUSH
51839: EMPTY
51840: LIST
51841: LIST
51842: PUSH
51843: LD_INT 4
51845: PUSH
51846: LD_INT 0
51848: PUSH
51849: EMPTY
51850: LIST
51851: LIST
51852: PUSH
51853: LD_INT 4
51855: PUSH
51856: LD_INT 1
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PUSH
51863: LD_INT 3
51865: PUSH
51866: LD_INT 1
51868: PUSH
51869: EMPTY
51870: LIST
51871: LIST
51872: PUSH
51873: LD_INT 2
51875: PUSH
51876: LD_INT 0
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: PUSH
51883: LD_INT 2
51885: PUSH
51886: LD_INT 1
51888: NEG
51889: PUSH
51890: EMPTY
51891: LIST
51892: LIST
51893: PUSH
51894: LD_INT 2
51896: PUSH
51897: LD_INT 2
51899: NEG
51900: PUSH
51901: EMPTY
51902: LIST
51903: LIST
51904: PUSH
51905: LD_INT 4
51907: PUSH
51908: LD_INT 2
51910: PUSH
51911: EMPTY
51912: LIST
51913: LIST
51914: PUSH
51915: LD_INT 4
51917: PUSH
51918: LD_INT 4
51920: PUSH
51921: EMPTY
51922: LIST
51923: LIST
51924: PUSH
51925: LD_INT 4
51927: PUSH
51928: LD_INT 3
51930: PUSH
51931: EMPTY
51932: LIST
51933: LIST
51934: PUSH
51935: LD_INT 5
51937: PUSH
51938: LD_INT 4
51940: PUSH
51941: EMPTY
51942: LIST
51943: LIST
51944: PUSH
51945: LD_INT 5
51947: PUSH
51948: LD_INT 5
51950: PUSH
51951: EMPTY
51952: LIST
51953: LIST
51954: PUSH
51955: LD_INT 4
51957: PUSH
51958: LD_INT 5
51960: PUSH
51961: EMPTY
51962: LIST
51963: LIST
51964: PUSH
51965: LD_INT 3
51967: PUSH
51968: LD_INT 4
51970: PUSH
51971: EMPTY
51972: LIST
51973: LIST
51974: PUSH
51975: LD_INT 3
51977: PUSH
51978: LD_INT 3
51980: PUSH
51981: EMPTY
51982: LIST
51983: LIST
51984: PUSH
51985: LD_INT 5
51987: PUSH
51988: LD_INT 3
51990: PUSH
51991: EMPTY
51992: LIST
51993: LIST
51994: PUSH
51995: LD_INT 3
51997: PUSH
51998: LD_INT 5
52000: PUSH
52001: EMPTY
52002: LIST
52003: LIST
52004: PUSH
52005: LD_INT 0
52007: PUSH
52008: LD_INT 3
52010: PUSH
52011: EMPTY
52012: LIST
52013: LIST
52014: PUSH
52015: LD_INT 0
52017: PUSH
52018: LD_INT 2
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: PUSH
52025: LD_INT 1
52027: PUSH
52028: LD_INT 3
52030: PUSH
52031: EMPTY
52032: LIST
52033: LIST
52034: PUSH
52035: LD_INT 1
52037: PUSH
52038: LD_INT 4
52040: PUSH
52041: EMPTY
52042: LIST
52043: LIST
52044: PUSH
52045: LD_INT 0
52047: PUSH
52048: LD_INT 4
52050: PUSH
52051: EMPTY
52052: LIST
52053: LIST
52054: PUSH
52055: LD_INT 1
52057: NEG
52058: PUSH
52059: LD_INT 3
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: PUSH
52066: LD_INT 1
52068: NEG
52069: PUSH
52070: LD_INT 2
52072: PUSH
52073: EMPTY
52074: LIST
52075: LIST
52076: PUSH
52077: LD_INT 2
52079: PUSH
52080: LD_INT 4
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PUSH
52087: LD_INT 2
52089: NEG
52090: PUSH
52091: LD_INT 2
52093: PUSH
52094: EMPTY
52095: LIST
52096: LIST
52097: PUSH
52098: LD_INT 4
52100: NEG
52101: PUSH
52102: LD_INT 0
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: PUSH
52109: LD_INT 4
52111: NEG
52112: PUSH
52113: LD_INT 1
52115: NEG
52116: PUSH
52117: EMPTY
52118: LIST
52119: LIST
52120: PUSH
52121: LD_INT 3
52123: NEG
52124: PUSH
52125: LD_INT 0
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: PUSH
52132: LD_INT 3
52134: NEG
52135: PUSH
52136: LD_INT 1
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: PUSH
52143: LD_INT 4
52145: NEG
52146: PUSH
52147: LD_INT 1
52149: PUSH
52150: EMPTY
52151: LIST
52152: LIST
52153: PUSH
52154: LD_INT 5
52156: NEG
52157: PUSH
52158: LD_INT 0
52160: PUSH
52161: EMPTY
52162: LIST
52163: LIST
52164: PUSH
52165: LD_INT 5
52167: NEG
52168: PUSH
52169: LD_INT 1
52171: NEG
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: PUSH
52177: LD_INT 5
52179: NEG
52180: PUSH
52181: LD_INT 2
52183: NEG
52184: PUSH
52185: EMPTY
52186: LIST
52187: LIST
52188: PUSH
52189: LD_INT 3
52191: NEG
52192: PUSH
52193: LD_INT 2
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: PUSH
52200: EMPTY
52201: LIST
52202: LIST
52203: LIST
52204: LIST
52205: LIST
52206: LIST
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: LIST
52227: LIST
52228: LIST
52229: LIST
52230: LIST
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: LIST
52237: LIST
52238: LIST
52239: LIST
52240: LIST
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: ST_TO_ADDR
// end ; end ;
52247: GO 52250
52249: POP
// case btype of b_depot , b_warehouse :
52250: LD_VAR 0 1
52254: PUSH
52255: LD_INT 0
52257: DOUBLE
52258: EQUAL
52259: IFTRUE 52269
52261: LD_INT 1
52263: DOUBLE
52264: EQUAL
52265: IFTRUE 52269
52267: GO 52470
52269: POP
// case nation of nation_american :
52270: LD_VAR 0 5
52274: PUSH
52275: LD_INT 1
52277: DOUBLE
52278: EQUAL
52279: IFTRUE 52283
52281: GO 52339
52283: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
52284: LD_ADDR_VAR 0 9
52288: PUSH
52289: LD_VAR 0 11
52293: PUSH
52294: LD_VAR 0 12
52298: PUSH
52299: LD_VAR 0 13
52303: PUSH
52304: LD_VAR 0 14
52308: PUSH
52309: LD_VAR 0 15
52313: PUSH
52314: LD_VAR 0 16
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: PUSH
52327: LD_VAR 0 4
52331: PUSH
52332: LD_INT 1
52334: PLUS
52335: ARRAY
52336: ST_TO_ADDR
52337: GO 52468
52339: LD_INT 2
52341: DOUBLE
52342: EQUAL
52343: IFTRUE 52347
52345: GO 52403
52347: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
52348: LD_ADDR_VAR 0 9
52352: PUSH
52353: LD_VAR 0 17
52357: PUSH
52358: LD_VAR 0 18
52362: PUSH
52363: LD_VAR 0 19
52367: PUSH
52368: LD_VAR 0 20
52372: PUSH
52373: LD_VAR 0 21
52377: PUSH
52378: LD_VAR 0 22
52382: PUSH
52383: EMPTY
52384: LIST
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: LIST
52390: PUSH
52391: LD_VAR 0 4
52395: PUSH
52396: LD_INT 1
52398: PLUS
52399: ARRAY
52400: ST_TO_ADDR
52401: GO 52468
52403: LD_INT 3
52405: DOUBLE
52406: EQUAL
52407: IFTRUE 52411
52409: GO 52467
52411: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
52412: LD_ADDR_VAR 0 9
52416: PUSH
52417: LD_VAR 0 23
52421: PUSH
52422: LD_VAR 0 24
52426: PUSH
52427: LD_VAR 0 25
52431: PUSH
52432: LD_VAR 0 26
52436: PUSH
52437: LD_VAR 0 27
52441: PUSH
52442: LD_VAR 0 28
52446: PUSH
52447: EMPTY
52448: LIST
52449: LIST
52450: LIST
52451: LIST
52452: LIST
52453: LIST
52454: PUSH
52455: LD_VAR 0 4
52459: PUSH
52460: LD_INT 1
52462: PLUS
52463: ARRAY
52464: ST_TO_ADDR
52465: GO 52468
52467: POP
52468: GO 53023
52470: LD_INT 2
52472: DOUBLE
52473: EQUAL
52474: IFTRUE 52484
52476: LD_INT 3
52478: DOUBLE
52479: EQUAL
52480: IFTRUE 52484
52482: GO 52540
52484: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
52485: LD_ADDR_VAR 0 9
52489: PUSH
52490: LD_VAR 0 29
52494: PUSH
52495: LD_VAR 0 30
52499: PUSH
52500: LD_VAR 0 31
52504: PUSH
52505: LD_VAR 0 32
52509: PUSH
52510: LD_VAR 0 33
52514: PUSH
52515: LD_VAR 0 34
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: PUSH
52528: LD_VAR 0 4
52532: PUSH
52533: LD_INT 1
52535: PLUS
52536: ARRAY
52537: ST_TO_ADDR
52538: GO 53023
52540: LD_INT 16
52542: DOUBLE
52543: EQUAL
52544: IFTRUE 52602
52546: LD_INT 17
52548: DOUBLE
52549: EQUAL
52550: IFTRUE 52602
52552: LD_INT 18
52554: DOUBLE
52555: EQUAL
52556: IFTRUE 52602
52558: LD_INT 19
52560: DOUBLE
52561: EQUAL
52562: IFTRUE 52602
52564: LD_INT 22
52566: DOUBLE
52567: EQUAL
52568: IFTRUE 52602
52570: LD_INT 20
52572: DOUBLE
52573: EQUAL
52574: IFTRUE 52602
52576: LD_INT 21
52578: DOUBLE
52579: EQUAL
52580: IFTRUE 52602
52582: LD_INT 23
52584: DOUBLE
52585: EQUAL
52586: IFTRUE 52602
52588: LD_INT 24
52590: DOUBLE
52591: EQUAL
52592: IFTRUE 52602
52594: LD_INT 25
52596: DOUBLE
52597: EQUAL
52598: IFTRUE 52602
52600: GO 52658
52602: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52603: LD_ADDR_VAR 0 9
52607: PUSH
52608: LD_VAR 0 35
52612: PUSH
52613: LD_VAR 0 36
52617: PUSH
52618: LD_VAR 0 37
52622: PUSH
52623: LD_VAR 0 38
52627: PUSH
52628: LD_VAR 0 39
52632: PUSH
52633: LD_VAR 0 40
52637: PUSH
52638: EMPTY
52639: LIST
52640: LIST
52641: LIST
52642: LIST
52643: LIST
52644: LIST
52645: PUSH
52646: LD_VAR 0 4
52650: PUSH
52651: LD_INT 1
52653: PLUS
52654: ARRAY
52655: ST_TO_ADDR
52656: GO 53023
52658: LD_INT 6
52660: DOUBLE
52661: EQUAL
52662: IFTRUE 52714
52664: LD_INT 7
52666: DOUBLE
52667: EQUAL
52668: IFTRUE 52714
52670: LD_INT 8
52672: DOUBLE
52673: EQUAL
52674: IFTRUE 52714
52676: LD_INT 13
52678: DOUBLE
52679: EQUAL
52680: IFTRUE 52714
52682: LD_INT 12
52684: DOUBLE
52685: EQUAL
52686: IFTRUE 52714
52688: LD_INT 15
52690: DOUBLE
52691: EQUAL
52692: IFTRUE 52714
52694: LD_INT 11
52696: DOUBLE
52697: EQUAL
52698: IFTRUE 52714
52700: LD_INT 14
52702: DOUBLE
52703: EQUAL
52704: IFTRUE 52714
52706: LD_INT 10
52708: DOUBLE
52709: EQUAL
52710: IFTRUE 52714
52712: GO 52770
52714: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52715: LD_ADDR_VAR 0 9
52719: PUSH
52720: LD_VAR 0 41
52724: PUSH
52725: LD_VAR 0 42
52729: PUSH
52730: LD_VAR 0 43
52734: PUSH
52735: LD_VAR 0 44
52739: PUSH
52740: LD_VAR 0 45
52744: PUSH
52745: LD_VAR 0 46
52749: PUSH
52750: EMPTY
52751: LIST
52752: LIST
52753: LIST
52754: LIST
52755: LIST
52756: LIST
52757: PUSH
52758: LD_VAR 0 4
52762: PUSH
52763: LD_INT 1
52765: PLUS
52766: ARRAY
52767: ST_TO_ADDR
52768: GO 53023
52770: LD_INT 36
52772: DOUBLE
52773: EQUAL
52774: IFTRUE 52778
52776: GO 52834
52778: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52779: LD_ADDR_VAR 0 9
52783: PUSH
52784: LD_VAR 0 47
52788: PUSH
52789: LD_VAR 0 48
52793: PUSH
52794: LD_VAR 0 49
52798: PUSH
52799: LD_VAR 0 50
52803: PUSH
52804: LD_VAR 0 51
52808: PUSH
52809: LD_VAR 0 52
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: LIST
52821: PUSH
52822: LD_VAR 0 4
52826: PUSH
52827: LD_INT 1
52829: PLUS
52830: ARRAY
52831: ST_TO_ADDR
52832: GO 53023
52834: LD_INT 4
52836: DOUBLE
52837: EQUAL
52838: IFTRUE 52860
52840: LD_INT 5
52842: DOUBLE
52843: EQUAL
52844: IFTRUE 52860
52846: LD_INT 34
52848: DOUBLE
52849: EQUAL
52850: IFTRUE 52860
52852: LD_INT 37
52854: DOUBLE
52855: EQUAL
52856: IFTRUE 52860
52858: GO 52916
52860: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52861: LD_ADDR_VAR 0 9
52865: PUSH
52866: LD_VAR 0 53
52870: PUSH
52871: LD_VAR 0 54
52875: PUSH
52876: LD_VAR 0 55
52880: PUSH
52881: LD_VAR 0 56
52885: PUSH
52886: LD_VAR 0 57
52890: PUSH
52891: LD_VAR 0 58
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: LIST
52900: LIST
52901: LIST
52902: LIST
52903: PUSH
52904: LD_VAR 0 4
52908: PUSH
52909: LD_INT 1
52911: PLUS
52912: ARRAY
52913: ST_TO_ADDR
52914: GO 53023
52916: LD_INT 31
52918: DOUBLE
52919: EQUAL
52920: IFTRUE 52966
52922: LD_INT 32
52924: DOUBLE
52925: EQUAL
52926: IFTRUE 52966
52928: LD_INT 33
52930: DOUBLE
52931: EQUAL
52932: IFTRUE 52966
52934: LD_INT 27
52936: DOUBLE
52937: EQUAL
52938: IFTRUE 52966
52940: LD_INT 26
52942: DOUBLE
52943: EQUAL
52944: IFTRUE 52966
52946: LD_INT 28
52948: DOUBLE
52949: EQUAL
52950: IFTRUE 52966
52952: LD_INT 29
52954: DOUBLE
52955: EQUAL
52956: IFTRUE 52966
52958: LD_INT 30
52960: DOUBLE
52961: EQUAL
52962: IFTRUE 52966
52964: GO 53022
52966: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52967: LD_ADDR_VAR 0 9
52971: PUSH
52972: LD_VAR 0 59
52976: PUSH
52977: LD_VAR 0 60
52981: PUSH
52982: LD_VAR 0 61
52986: PUSH
52987: LD_VAR 0 62
52991: PUSH
52992: LD_VAR 0 63
52996: PUSH
52997: LD_VAR 0 64
53001: PUSH
53002: EMPTY
53003: LIST
53004: LIST
53005: LIST
53006: LIST
53007: LIST
53008: LIST
53009: PUSH
53010: LD_VAR 0 4
53014: PUSH
53015: LD_INT 1
53017: PLUS
53018: ARRAY
53019: ST_TO_ADDR
53020: GO 53023
53022: POP
// temp_list2 = [ ] ;
53023: LD_ADDR_VAR 0 10
53027: PUSH
53028: EMPTY
53029: ST_TO_ADDR
// for i in temp_list do
53030: LD_ADDR_VAR 0 8
53034: PUSH
53035: LD_VAR 0 9
53039: PUSH
53040: FOR_IN
53041: IFFALSE 53093
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
53043: LD_ADDR_VAR 0 10
53047: PUSH
53048: LD_VAR 0 10
53052: PUSH
53053: LD_VAR 0 8
53057: PUSH
53058: LD_INT 1
53060: ARRAY
53061: PUSH
53062: LD_VAR 0 2
53066: PLUS
53067: PUSH
53068: LD_VAR 0 8
53072: PUSH
53073: LD_INT 2
53075: ARRAY
53076: PUSH
53077: LD_VAR 0 3
53081: PLUS
53082: PUSH
53083: EMPTY
53084: LIST
53085: LIST
53086: PUSH
53087: EMPTY
53088: LIST
53089: ADD
53090: ST_TO_ADDR
53091: GO 53040
53093: POP
53094: POP
// result = temp_list2 ;
53095: LD_ADDR_VAR 0 7
53099: PUSH
53100: LD_VAR 0 10
53104: ST_TO_ADDR
// end ;
53105: LD_VAR 0 7
53109: RET
// export function EnemyInRange ( unit , dist ) ; begin
53110: LD_INT 0
53112: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
53113: LD_ADDR_VAR 0 3
53117: PUSH
53118: LD_VAR 0 1
53122: PPUSH
53123: CALL_OW 255
53127: PPUSH
53128: LD_VAR 0 1
53132: PPUSH
53133: CALL_OW 250
53137: PPUSH
53138: LD_VAR 0 1
53142: PPUSH
53143: CALL_OW 251
53147: PPUSH
53148: LD_VAR 0 2
53152: PPUSH
53153: CALL 26367 0 4
53157: PUSH
53158: LD_INT 4
53160: ARRAY
53161: ST_TO_ADDR
// end ;
53162: LD_VAR 0 3
53166: RET
// export function PlayerSeeMe ( unit ) ; begin
53167: LD_INT 0
53169: PPUSH
// result := See ( your_side , unit ) ;
53170: LD_ADDR_VAR 0 2
53174: PUSH
53175: LD_OWVAR 2
53179: PPUSH
53180: LD_VAR 0 1
53184: PPUSH
53185: CALL_OW 292
53189: ST_TO_ADDR
// end ;
53190: LD_VAR 0 2
53194: RET
// export function ReverseDir ( unit ) ; begin
53195: LD_INT 0
53197: PPUSH
// if not unit then
53198: LD_VAR 0 1
53202: NOT
53203: IFFALSE 53207
// exit ;
53205: GO 53230
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
53207: LD_ADDR_VAR 0 2
53211: PUSH
53212: LD_VAR 0 1
53216: PPUSH
53217: CALL_OW 254
53221: PUSH
53222: LD_INT 3
53224: PLUS
53225: PUSH
53226: LD_INT 6
53228: MOD
53229: ST_TO_ADDR
// end ;
53230: LD_VAR 0 2
53234: RET
// export function ReverseArray ( array ) ; var i ; begin
53235: LD_INT 0
53237: PPUSH
53238: PPUSH
// if not array then
53239: LD_VAR 0 1
53243: NOT
53244: IFFALSE 53248
// exit ;
53246: GO 53303
// result := [ ] ;
53248: LD_ADDR_VAR 0 2
53252: PUSH
53253: EMPTY
53254: ST_TO_ADDR
// for i := array downto 1 do
53255: LD_ADDR_VAR 0 3
53259: PUSH
53260: DOUBLE
53261: LD_VAR 0 1
53265: INC
53266: ST_TO_ADDR
53267: LD_INT 1
53269: PUSH
53270: FOR_DOWNTO
53271: IFFALSE 53301
// result := Join ( result , array [ i ] ) ;
53273: LD_ADDR_VAR 0 2
53277: PUSH
53278: LD_VAR 0 2
53282: PPUSH
53283: LD_VAR 0 1
53287: PUSH
53288: LD_VAR 0 3
53292: ARRAY
53293: PPUSH
53294: CALL 58155 0 2
53298: ST_TO_ADDR
53299: GO 53270
53301: POP
53302: POP
// end ;
53303: LD_VAR 0 2
53307: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
53308: LD_INT 0
53310: PPUSH
53311: PPUSH
53312: PPUSH
53313: PPUSH
53314: PPUSH
53315: PPUSH
// if not unit or not hexes then
53316: LD_VAR 0 1
53320: NOT
53321: IFTRUE 53330
53323: PUSH
53324: LD_VAR 0 2
53328: NOT
53329: OR
53330: IFFALSE 53334
// exit ;
53332: GO 53457
// dist := 9999 ;
53334: LD_ADDR_VAR 0 5
53338: PUSH
53339: LD_INT 9999
53341: ST_TO_ADDR
// for i = 1 to hexes do
53342: LD_ADDR_VAR 0 4
53346: PUSH
53347: DOUBLE
53348: LD_INT 1
53350: DEC
53351: ST_TO_ADDR
53352: LD_VAR 0 2
53356: PUSH
53357: FOR_TO
53358: IFFALSE 53445
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
53360: LD_ADDR_VAR 0 6
53364: PUSH
53365: LD_VAR 0 1
53369: PPUSH
53370: LD_VAR 0 2
53374: PUSH
53375: LD_VAR 0 4
53379: ARRAY
53380: PUSH
53381: LD_INT 1
53383: ARRAY
53384: PPUSH
53385: LD_VAR 0 2
53389: PUSH
53390: LD_VAR 0 4
53394: ARRAY
53395: PUSH
53396: LD_INT 2
53398: ARRAY
53399: PPUSH
53400: CALL_OW 297
53404: ST_TO_ADDR
// if tdist < dist then
53405: LD_VAR 0 6
53409: PUSH
53410: LD_VAR 0 5
53414: LESS
53415: IFFALSE 53443
// begin hex := hexes [ i ] ;
53417: LD_ADDR_VAR 0 8
53421: PUSH
53422: LD_VAR 0 2
53426: PUSH
53427: LD_VAR 0 4
53431: ARRAY
53432: ST_TO_ADDR
// dist := tdist ;
53433: LD_ADDR_VAR 0 5
53437: PUSH
53438: LD_VAR 0 6
53442: ST_TO_ADDR
// end ; end ;
53443: GO 53357
53445: POP
53446: POP
// result := hex ;
53447: LD_ADDR_VAR 0 3
53451: PUSH
53452: LD_VAR 0 8
53456: ST_TO_ADDR
// end ;
53457: LD_VAR 0 3
53461: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
53462: LD_INT 0
53464: PPUSH
53465: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53466: LD_VAR 0 1
53470: NOT
53471: IFTRUE 53510
53473: PUSH
53474: LD_VAR 0 1
53478: PUSH
53479: LD_INT 21
53481: PUSH
53482: LD_INT 2
53484: PUSH
53485: EMPTY
53486: LIST
53487: LIST
53488: PUSH
53489: LD_INT 23
53491: PUSH
53492: LD_INT 2
53494: PUSH
53495: EMPTY
53496: LIST
53497: LIST
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: PPUSH
53503: CALL_OW 69
53507: IN
53508: NOT
53509: OR
53510: IFFALSE 53514
// exit ;
53512: GO 53561
// for i = 1 to 3 do
53514: LD_ADDR_VAR 0 3
53518: PUSH
53519: DOUBLE
53520: LD_INT 1
53522: DEC
53523: ST_TO_ADDR
53524: LD_INT 3
53526: PUSH
53527: FOR_TO
53528: IFFALSE 53559
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
53530: LD_VAR 0 1
53534: PPUSH
53535: CALL_OW 250
53539: PPUSH
53540: LD_VAR 0 1
53544: PPUSH
53545: CALL_OW 251
53549: PPUSH
53550: LD_INT 1
53552: PPUSH
53553: CALL_OW 453
53557: GO 53527
53559: POP
53560: POP
// end ;
53561: LD_VAR 0 2
53565: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
53566: LD_INT 0
53568: PPUSH
53569: PPUSH
53570: PPUSH
53571: PPUSH
53572: PPUSH
53573: PPUSH
// if not unit or not enemy_unit then
53574: LD_VAR 0 1
53578: NOT
53579: IFTRUE 53588
53581: PUSH
53582: LD_VAR 0 2
53586: NOT
53587: OR
53588: IFFALSE 53592
// exit ;
53590: GO 54073
// if GetLives ( i ) < 250 then
53592: LD_VAR 0 4
53596: PPUSH
53597: CALL_OW 256
53601: PUSH
53602: LD_INT 250
53604: LESS
53605: IFFALSE 53618
// begin ComAutodestruct ( i ) ;
53607: LD_VAR 0 4
53611: PPUSH
53612: CALL 53462 0 1
// exit ;
53616: GO 54073
// end ; x := GetX ( enemy_unit ) ;
53618: LD_ADDR_VAR 0 7
53622: PUSH
53623: LD_VAR 0 2
53627: PPUSH
53628: CALL_OW 250
53632: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53633: LD_ADDR_VAR 0 8
53637: PUSH
53638: LD_VAR 0 2
53642: PPUSH
53643: CALL_OW 251
53647: ST_TO_ADDR
// if not x or not y then
53648: LD_VAR 0 7
53652: NOT
53653: IFTRUE 53662
53655: PUSH
53656: LD_VAR 0 8
53660: NOT
53661: OR
53662: IFFALSE 53666
// exit ;
53664: GO 54073
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53666: LD_ADDR_VAR 0 6
53670: PUSH
53671: LD_VAR 0 7
53675: PPUSH
53676: LD_INT 0
53678: PPUSH
53679: LD_INT 4
53681: PPUSH
53682: CALL_OW 272
53686: PUSH
53687: LD_VAR 0 8
53691: PPUSH
53692: LD_INT 0
53694: PPUSH
53695: LD_INT 4
53697: PPUSH
53698: CALL_OW 273
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: PUSH
53707: LD_VAR 0 7
53711: PPUSH
53712: LD_INT 1
53714: PPUSH
53715: LD_INT 4
53717: PPUSH
53718: CALL_OW 272
53722: PUSH
53723: LD_VAR 0 8
53727: PPUSH
53728: LD_INT 1
53730: PPUSH
53731: LD_INT 4
53733: PPUSH
53734: CALL_OW 273
53738: PUSH
53739: EMPTY
53740: LIST
53741: LIST
53742: PUSH
53743: LD_VAR 0 7
53747: PPUSH
53748: LD_INT 2
53750: PPUSH
53751: LD_INT 4
53753: PPUSH
53754: CALL_OW 272
53758: PUSH
53759: LD_VAR 0 8
53763: PPUSH
53764: LD_INT 2
53766: PPUSH
53767: LD_INT 4
53769: PPUSH
53770: CALL_OW 273
53774: PUSH
53775: EMPTY
53776: LIST
53777: LIST
53778: PUSH
53779: LD_VAR 0 7
53783: PPUSH
53784: LD_INT 3
53786: PPUSH
53787: LD_INT 4
53789: PPUSH
53790: CALL_OW 272
53794: PUSH
53795: LD_VAR 0 8
53799: PPUSH
53800: LD_INT 3
53802: PPUSH
53803: LD_INT 4
53805: PPUSH
53806: CALL_OW 273
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: PUSH
53815: LD_VAR 0 7
53819: PPUSH
53820: LD_INT 4
53822: PPUSH
53823: LD_INT 4
53825: PPUSH
53826: CALL_OW 272
53830: PUSH
53831: LD_VAR 0 8
53835: PPUSH
53836: LD_INT 4
53838: PPUSH
53839: LD_INT 4
53841: PPUSH
53842: CALL_OW 273
53846: PUSH
53847: EMPTY
53848: LIST
53849: LIST
53850: PUSH
53851: LD_VAR 0 7
53855: PPUSH
53856: LD_INT 5
53858: PPUSH
53859: LD_INT 4
53861: PPUSH
53862: CALL_OW 272
53866: PUSH
53867: LD_VAR 0 8
53871: PPUSH
53872: LD_INT 5
53874: PPUSH
53875: LD_INT 4
53877: PPUSH
53878: CALL_OW 273
53882: PUSH
53883: EMPTY
53884: LIST
53885: LIST
53886: PUSH
53887: EMPTY
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: LIST
53893: LIST
53894: ST_TO_ADDR
// for i = tmp downto 1 do
53895: LD_ADDR_VAR 0 4
53899: PUSH
53900: DOUBLE
53901: LD_VAR 0 6
53905: INC
53906: ST_TO_ADDR
53907: LD_INT 1
53909: PUSH
53910: FOR_DOWNTO
53911: IFFALSE 54014
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53913: LD_VAR 0 6
53917: PUSH
53918: LD_VAR 0 4
53922: ARRAY
53923: PUSH
53924: LD_INT 1
53926: ARRAY
53927: PPUSH
53928: LD_VAR 0 6
53932: PUSH
53933: LD_VAR 0 4
53937: ARRAY
53938: PUSH
53939: LD_INT 2
53941: ARRAY
53942: PPUSH
53943: CALL_OW 488
53947: NOT
53948: IFTRUE 53990
53950: PUSH
53951: LD_VAR 0 6
53955: PUSH
53956: LD_VAR 0 4
53960: ARRAY
53961: PUSH
53962: LD_INT 1
53964: ARRAY
53965: PPUSH
53966: LD_VAR 0 6
53970: PUSH
53971: LD_VAR 0 4
53975: ARRAY
53976: PUSH
53977: LD_INT 2
53979: ARRAY
53980: PPUSH
53981: CALL_OW 428
53985: PUSH
53986: LD_INT 0
53988: NONEQUAL
53989: OR
53990: IFFALSE 54012
// tmp := Delete ( tmp , i ) ;
53992: LD_ADDR_VAR 0 6
53996: PUSH
53997: LD_VAR 0 6
54001: PPUSH
54002: LD_VAR 0 4
54006: PPUSH
54007: CALL_OW 3
54011: ST_TO_ADDR
54012: GO 53910
54014: POP
54015: POP
// j := GetClosestHex ( unit , tmp ) ;
54016: LD_ADDR_VAR 0 5
54020: PUSH
54021: LD_VAR 0 1
54025: PPUSH
54026: LD_VAR 0 6
54030: PPUSH
54031: CALL 53308 0 2
54035: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
54036: LD_VAR 0 1
54040: PPUSH
54041: LD_VAR 0 5
54045: PUSH
54046: LD_INT 1
54048: ARRAY
54049: PPUSH
54050: LD_VAR 0 5
54054: PUSH
54055: LD_INT 2
54057: ARRAY
54058: PPUSH
54059: CALL_OW 111
// result := j ;
54063: LD_ADDR_VAR 0 3
54067: PUSH
54068: LD_VAR 0 5
54072: ST_TO_ADDR
// end ;
54073: LD_VAR 0 3
54077: RET
// export function PrepareApemanSoldier ( ) ; begin
54078: LD_INT 0
54080: PPUSH
// uc_nation := 0 ;
54081: LD_ADDR_OWVAR 21
54085: PUSH
54086: LD_INT 0
54088: ST_TO_ADDR
// hc_sex := sex_male ;
54089: LD_ADDR_OWVAR 27
54093: PUSH
54094: LD_INT 1
54096: ST_TO_ADDR
// hc_name :=  ;
54097: LD_ADDR_OWVAR 26
54101: PUSH
54102: LD_STRING 
54104: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
54105: LD_ADDR_OWVAR 28
54109: PUSH
54110: LD_INT 15
54112: ST_TO_ADDR
// hc_gallery :=  ;
54113: LD_ADDR_OWVAR 33
54117: PUSH
54118: LD_STRING 
54120: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
54121: LD_ADDR_OWVAR 31
54125: PUSH
54126: LD_INT 0
54128: PPUSH
54129: LD_INT 3
54131: PPUSH
54132: CALL_OW 12
54136: PUSH
54137: LD_INT 0
54139: PPUSH
54140: LD_INT 3
54142: PPUSH
54143: CALL_OW 12
54147: PUSH
54148: LD_INT 0
54150: PUSH
54151: LD_INT 0
54153: PUSH
54154: EMPTY
54155: LIST
54156: LIST
54157: LIST
54158: LIST
54159: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
54160: LD_ADDR_OWVAR 29
54164: PUSH
54165: LD_INT 10
54167: PUSH
54168: LD_INT 12
54170: PUSH
54171: EMPTY
54172: LIST
54173: LIST
54174: ST_TO_ADDR
// end ;
54175: LD_VAR 0 1
54179: RET
// export function PrepareApemanEngineer ( ) ; begin
54180: LD_INT 0
54182: PPUSH
// uc_nation := 0 ;
54183: LD_ADDR_OWVAR 21
54187: PUSH
54188: LD_INT 0
54190: ST_TO_ADDR
// hc_sex := sex_male ;
54191: LD_ADDR_OWVAR 27
54195: PUSH
54196: LD_INT 1
54198: ST_TO_ADDR
// hc_name :=  ;
54199: LD_ADDR_OWVAR 26
54203: PUSH
54204: LD_STRING 
54206: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
54207: LD_ADDR_OWVAR 28
54211: PUSH
54212: LD_INT 16
54214: ST_TO_ADDR
// hc_gallery :=  ;
54215: LD_ADDR_OWVAR 33
54219: PUSH
54220: LD_STRING 
54222: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
54223: LD_ADDR_OWVAR 31
54227: PUSH
54228: LD_INT 0
54230: PPUSH
54231: LD_INT 3
54233: PPUSH
54234: CALL_OW 12
54238: PUSH
54239: LD_INT 0
54241: PPUSH
54242: LD_INT 3
54244: PPUSH
54245: CALL_OW 12
54249: PUSH
54250: LD_INT 0
54252: PUSH
54253: LD_INT 0
54255: PUSH
54256: EMPTY
54257: LIST
54258: LIST
54259: LIST
54260: LIST
54261: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
54262: LD_ADDR_OWVAR 29
54266: PUSH
54267: LD_INT 10
54269: PUSH
54270: LD_INT 12
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: ST_TO_ADDR
// end ;
54277: LD_VAR 0 1
54281: RET
// export function PrepareApeman ( agressivity ) ; begin
54282: LD_INT 0
54284: PPUSH
// uc_side := 0 ;
54285: LD_ADDR_OWVAR 20
54289: PUSH
54290: LD_INT 0
54292: ST_TO_ADDR
// uc_nation := 0 ;
54293: LD_ADDR_OWVAR 21
54297: PUSH
54298: LD_INT 0
54300: ST_TO_ADDR
// hc_sex := sex_male ;
54301: LD_ADDR_OWVAR 27
54305: PUSH
54306: LD_INT 1
54308: ST_TO_ADDR
// hc_class := class_apeman ;
54309: LD_ADDR_OWVAR 28
54313: PUSH
54314: LD_INT 12
54316: ST_TO_ADDR
// hc_gallery :=  ;
54317: LD_ADDR_OWVAR 33
54321: PUSH
54322: LD_STRING 
54324: ST_TO_ADDR
// hc_name :=  ;
54325: LD_ADDR_OWVAR 26
54329: PUSH
54330: LD_STRING 
54332: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
54333: LD_ADDR_OWVAR 29
54337: PUSH
54338: LD_INT 10
54340: PUSH
54341: LD_INT 12
54343: PUSH
54344: EMPTY
54345: LIST
54346: LIST
54347: ST_TO_ADDR
// if agressivity = 0 then
54348: LD_VAR 0 1
54352: PUSH
54353: LD_INT 0
54355: EQUAL
54356: IFFALSE 54368
// hc_agressivity := 0 else
54358: LD_ADDR_OWVAR 35
54362: PUSH
54363: LD_INT 0
54365: ST_TO_ADDR
54366: GO 54389
// hc_agressivity := rand ( - agressivity , agressivity ) ;
54368: LD_ADDR_OWVAR 35
54372: PUSH
54373: LD_VAR 0 1
54377: NEG
54378: PPUSH
54379: LD_VAR 0 1
54383: PPUSH
54384: CALL_OW 12
54388: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
54389: LD_ADDR_OWVAR 31
54393: PUSH
54394: LD_INT 0
54396: PPUSH
54397: LD_INT 3
54399: PPUSH
54400: CALL_OW 12
54404: PUSH
54405: LD_INT 0
54407: PPUSH
54408: LD_INT 3
54410: PPUSH
54411: CALL_OW 12
54415: PUSH
54416: LD_INT 0
54418: PUSH
54419: LD_INT 0
54421: PUSH
54422: EMPTY
54423: LIST
54424: LIST
54425: LIST
54426: LIST
54427: ST_TO_ADDR
// end ;
54428: LD_VAR 0 2
54432: RET
// export function PrepareTiger ( agressivity ) ; begin
54433: LD_INT 0
54435: PPUSH
// uc_side := 0 ;
54436: LD_ADDR_OWVAR 20
54440: PUSH
54441: LD_INT 0
54443: ST_TO_ADDR
// uc_nation := 0 ;
54444: LD_ADDR_OWVAR 21
54448: PUSH
54449: LD_INT 0
54451: ST_TO_ADDR
// InitHc ;
54452: CALL_OW 19
// hc_class := class_tiger ;
54456: LD_ADDR_OWVAR 28
54460: PUSH
54461: LD_INT 14
54463: ST_TO_ADDR
// hc_gallery :=  ;
54464: LD_ADDR_OWVAR 33
54468: PUSH
54469: LD_STRING 
54471: ST_TO_ADDR
// hc_name :=  ;
54472: LD_ADDR_OWVAR 26
54476: PUSH
54477: LD_STRING 
54479: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
54480: LD_ADDR_OWVAR 35
54484: PUSH
54485: LD_VAR 0 1
54489: NEG
54490: PPUSH
54491: LD_VAR 0 1
54495: PPUSH
54496: CALL_OW 12
54500: ST_TO_ADDR
// end ;
54501: LD_VAR 0 2
54505: RET
// export function PrepareEnchidna ( ) ; begin
54506: LD_INT 0
54508: PPUSH
// uc_side := 0 ;
54509: LD_ADDR_OWVAR 20
54513: PUSH
54514: LD_INT 0
54516: ST_TO_ADDR
// uc_nation := 0 ;
54517: LD_ADDR_OWVAR 21
54521: PUSH
54522: LD_INT 0
54524: ST_TO_ADDR
// InitHc ;
54525: CALL_OW 19
// hc_class := class_baggie ;
54529: LD_ADDR_OWVAR 28
54533: PUSH
54534: LD_INT 13
54536: ST_TO_ADDR
// hc_gallery :=  ;
54537: LD_ADDR_OWVAR 33
54541: PUSH
54542: LD_STRING 
54544: ST_TO_ADDR
// hc_name :=  ;
54545: LD_ADDR_OWVAR 26
54549: PUSH
54550: LD_STRING 
54552: ST_TO_ADDR
// end ;
54553: LD_VAR 0 1
54557: RET
// export function PrepareFrog ( ) ; begin
54558: LD_INT 0
54560: PPUSH
// uc_side := 0 ;
54561: LD_ADDR_OWVAR 20
54565: PUSH
54566: LD_INT 0
54568: ST_TO_ADDR
// uc_nation := 0 ;
54569: LD_ADDR_OWVAR 21
54573: PUSH
54574: LD_INT 0
54576: ST_TO_ADDR
// InitHc ;
54577: CALL_OW 19
// hc_class := class_frog ;
54581: LD_ADDR_OWVAR 28
54585: PUSH
54586: LD_INT 19
54588: ST_TO_ADDR
// hc_gallery :=  ;
54589: LD_ADDR_OWVAR 33
54593: PUSH
54594: LD_STRING 
54596: ST_TO_ADDR
// hc_name :=  ;
54597: LD_ADDR_OWVAR 26
54601: PUSH
54602: LD_STRING 
54604: ST_TO_ADDR
// end ;
54605: LD_VAR 0 1
54609: RET
// export function PrepareFish ( ) ; begin
54610: LD_INT 0
54612: PPUSH
// uc_side := 0 ;
54613: LD_ADDR_OWVAR 20
54617: PUSH
54618: LD_INT 0
54620: ST_TO_ADDR
// uc_nation := 0 ;
54621: LD_ADDR_OWVAR 21
54625: PUSH
54626: LD_INT 0
54628: ST_TO_ADDR
// InitHc ;
54629: CALL_OW 19
// hc_class := class_fish ;
54633: LD_ADDR_OWVAR 28
54637: PUSH
54638: LD_INT 20
54640: ST_TO_ADDR
// hc_gallery :=  ;
54641: LD_ADDR_OWVAR 33
54645: PUSH
54646: LD_STRING 
54648: ST_TO_ADDR
// hc_name :=  ;
54649: LD_ADDR_OWVAR 26
54653: PUSH
54654: LD_STRING 
54656: ST_TO_ADDR
// end ;
54657: LD_VAR 0 1
54661: RET
// export function PrepareBird ( ) ; begin
54662: LD_INT 0
54664: PPUSH
// uc_side := 0 ;
54665: LD_ADDR_OWVAR 20
54669: PUSH
54670: LD_INT 0
54672: ST_TO_ADDR
// uc_nation := 0 ;
54673: LD_ADDR_OWVAR 21
54677: PUSH
54678: LD_INT 0
54680: ST_TO_ADDR
// InitHc ;
54681: CALL_OW 19
// hc_class := class_phororhacos ;
54685: LD_ADDR_OWVAR 28
54689: PUSH
54690: LD_INT 18
54692: ST_TO_ADDR
// hc_gallery :=  ;
54693: LD_ADDR_OWVAR 33
54697: PUSH
54698: LD_STRING 
54700: ST_TO_ADDR
// hc_name :=  ;
54701: LD_ADDR_OWVAR 26
54705: PUSH
54706: LD_STRING 
54708: ST_TO_ADDR
// end ;
54709: LD_VAR 0 1
54713: RET
// export function PrepareHorse ( ) ; begin
54714: LD_INT 0
54716: PPUSH
// uc_side := 0 ;
54717: LD_ADDR_OWVAR 20
54721: PUSH
54722: LD_INT 0
54724: ST_TO_ADDR
// uc_nation := 0 ;
54725: LD_ADDR_OWVAR 21
54729: PUSH
54730: LD_INT 0
54732: ST_TO_ADDR
// InitHc ;
54733: CALL_OW 19
// hc_class := class_horse ;
54737: LD_ADDR_OWVAR 28
54741: PUSH
54742: LD_INT 21
54744: ST_TO_ADDR
// hc_gallery :=  ;
54745: LD_ADDR_OWVAR 33
54749: PUSH
54750: LD_STRING 
54752: ST_TO_ADDR
// hc_name :=  ;
54753: LD_ADDR_OWVAR 26
54757: PUSH
54758: LD_STRING 
54760: ST_TO_ADDR
// end ;
54761: LD_VAR 0 1
54765: RET
// export function PrepareMastodont ( ) ; begin
54766: LD_INT 0
54768: PPUSH
// uc_side := 0 ;
54769: LD_ADDR_OWVAR 20
54773: PUSH
54774: LD_INT 0
54776: ST_TO_ADDR
// uc_nation := 0 ;
54777: LD_ADDR_OWVAR 21
54781: PUSH
54782: LD_INT 0
54784: ST_TO_ADDR
// vc_chassis := class_mastodont ;
54785: LD_ADDR_OWVAR 37
54789: PUSH
54790: LD_INT 31
54792: ST_TO_ADDR
// vc_control := control_rider ;
54793: LD_ADDR_OWVAR 38
54797: PUSH
54798: LD_INT 4
54800: ST_TO_ADDR
// end ;
54801: LD_VAR 0 1
54805: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54806: LD_INT 0
54808: PPUSH
54809: PPUSH
54810: PPUSH
// uc_side = 0 ;
54811: LD_ADDR_OWVAR 20
54815: PUSH
54816: LD_INT 0
54818: ST_TO_ADDR
// uc_nation = 0 ;
54819: LD_ADDR_OWVAR 21
54823: PUSH
54824: LD_INT 0
54826: ST_TO_ADDR
// InitHc_All ( ) ;
54827: CALL_OW 584
// InitVc ;
54831: CALL_OW 20
// if mastodonts then
54835: LD_VAR 0 6
54839: IFFALSE 54906
// for i = 1 to mastodonts do
54841: LD_ADDR_VAR 0 11
54845: PUSH
54846: DOUBLE
54847: LD_INT 1
54849: DEC
54850: ST_TO_ADDR
54851: LD_VAR 0 6
54855: PUSH
54856: FOR_TO
54857: IFFALSE 54904
// begin vc_chassis := 31 ;
54859: LD_ADDR_OWVAR 37
54863: PUSH
54864: LD_INT 31
54866: ST_TO_ADDR
// vc_control := control_rider ;
54867: LD_ADDR_OWVAR 38
54871: PUSH
54872: LD_INT 4
54874: ST_TO_ADDR
// animal := CreateVehicle ;
54875: LD_ADDR_VAR 0 12
54879: PUSH
54880: CALL_OW 45
54884: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54885: LD_VAR 0 12
54889: PPUSH
54890: LD_VAR 0 8
54894: PPUSH
54895: LD_INT 0
54897: PPUSH
54898: CALL 57048 0 3
// end ;
54902: GO 54856
54904: POP
54905: POP
// if horses then
54906: LD_VAR 0 5
54910: IFFALSE 54977
// for i = 1 to horses do
54912: LD_ADDR_VAR 0 11
54916: PUSH
54917: DOUBLE
54918: LD_INT 1
54920: DEC
54921: ST_TO_ADDR
54922: LD_VAR 0 5
54926: PUSH
54927: FOR_TO
54928: IFFALSE 54975
// begin hc_class := 21 ;
54930: LD_ADDR_OWVAR 28
54934: PUSH
54935: LD_INT 21
54937: ST_TO_ADDR
// hc_gallery :=  ;
54938: LD_ADDR_OWVAR 33
54942: PUSH
54943: LD_STRING 
54945: ST_TO_ADDR
// animal := CreateHuman ;
54946: LD_ADDR_VAR 0 12
54950: PUSH
54951: CALL_OW 44
54955: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54956: LD_VAR 0 12
54960: PPUSH
54961: LD_VAR 0 8
54965: PPUSH
54966: LD_INT 0
54968: PPUSH
54969: CALL 57048 0 3
// end ;
54973: GO 54927
54975: POP
54976: POP
// if birds then
54977: LD_VAR 0 1
54981: IFFALSE 55048
// for i = 1 to birds do
54983: LD_ADDR_VAR 0 11
54987: PUSH
54988: DOUBLE
54989: LD_INT 1
54991: DEC
54992: ST_TO_ADDR
54993: LD_VAR 0 1
54997: PUSH
54998: FOR_TO
54999: IFFALSE 55046
// begin hc_class := 18 ;
55001: LD_ADDR_OWVAR 28
55005: PUSH
55006: LD_INT 18
55008: ST_TO_ADDR
// hc_gallery =  ;
55009: LD_ADDR_OWVAR 33
55013: PUSH
55014: LD_STRING 
55016: ST_TO_ADDR
// animal := CreateHuman ;
55017: LD_ADDR_VAR 0 12
55021: PUSH
55022: CALL_OW 44
55026: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55027: LD_VAR 0 12
55031: PPUSH
55032: LD_VAR 0 8
55036: PPUSH
55037: LD_INT 0
55039: PPUSH
55040: CALL 57048 0 3
// end ;
55044: GO 54998
55046: POP
55047: POP
// if tigers then
55048: LD_VAR 0 2
55052: IFFALSE 55136
// for i = 1 to tigers do
55054: LD_ADDR_VAR 0 11
55058: PUSH
55059: DOUBLE
55060: LD_INT 1
55062: DEC
55063: ST_TO_ADDR
55064: LD_VAR 0 2
55068: PUSH
55069: FOR_TO
55070: IFFALSE 55134
// begin hc_class = class_tiger ;
55072: LD_ADDR_OWVAR 28
55076: PUSH
55077: LD_INT 14
55079: ST_TO_ADDR
// hc_gallery =  ;
55080: LD_ADDR_OWVAR 33
55084: PUSH
55085: LD_STRING 
55087: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
55088: LD_ADDR_OWVAR 35
55092: PUSH
55093: LD_INT 7
55095: NEG
55096: PPUSH
55097: LD_INT 7
55099: PPUSH
55100: CALL_OW 12
55104: ST_TO_ADDR
// animal := CreateHuman ;
55105: LD_ADDR_VAR 0 12
55109: PUSH
55110: CALL_OW 44
55114: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55115: LD_VAR 0 12
55119: PPUSH
55120: LD_VAR 0 8
55124: PPUSH
55125: LD_INT 0
55127: PPUSH
55128: CALL 57048 0 3
// end ;
55132: GO 55069
55134: POP
55135: POP
// if apemans then
55136: LD_VAR 0 3
55140: IFFALSE 55263
// for i = 1 to apemans do
55142: LD_ADDR_VAR 0 11
55146: PUSH
55147: DOUBLE
55148: LD_INT 1
55150: DEC
55151: ST_TO_ADDR
55152: LD_VAR 0 3
55156: PUSH
55157: FOR_TO
55158: IFFALSE 55261
// begin hc_class = class_apeman ;
55160: LD_ADDR_OWVAR 28
55164: PUSH
55165: LD_INT 12
55167: ST_TO_ADDR
// hc_gallery =  ;
55168: LD_ADDR_OWVAR 33
55172: PUSH
55173: LD_STRING 
55175: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
55176: LD_ADDR_OWVAR 35
55180: PUSH
55181: LD_INT 2
55183: NEG
55184: PPUSH
55185: LD_INT 2
55187: PPUSH
55188: CALL_OW 12
55192: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
55193: LD_ADDR_OWVAR 31
55197: PUSH
55198: LD_INT 1
55200: PPUSH
55201: LD_INT 3
55203: PPUSH
55204: CALL_OW 12
55208: PUSH
55209: LD_INT 1
55211: PPUSH
55212: LD_INT 3
55214: PPUSH
55215: CALL_OW 12
55219: PUSH
55220: LD_INT 0
55222: PUSH
55223: LD_INT 0
55225: PUSH
55226: EMPTY
55227: LIST
55228: LIST
55229: LIST
55230: LIST
55231: ST_TO_ADDR
// animal := CreateHuman ;
55232: LD_ADDR_VAR 0 12
55236: PUSH
55237: CALL_OW 44
55241: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55242: LD_VAR 0 12
55246: PPUSH
55247: LD_VAR 0 8
55251: PPUSH
55252: LD_INT 0
55254: PPUSH
55255: CALL 57048 0 3
// end ;
55259: GO 55157
55261: POP
55262: POP
// if enchidnas then
55263: LD_VAR 0 4
55267: IFFALSE 55334
// for i = 1 to enchidnas do
55269: LD_ADDR_VAR 0 11
55273: PUSH
55274: DOUBLE
55275: LD_INT 1
55277: DEC
55278: ST_TO_ADDR
55279: LD_VAR 0 4
55283: PUSH
55284: FOR_TO
55285: IFFALSE 55332
// begin hc_class = 13 ;
55287: LD_ADDR_OWVAR 28
55291: PUSH
55292: LD_INT 13
55294: ST_TO_ADDR
// hc_gallery =  ;
55295: LD_ADDR_OWVAR 33
55299: PUSH
55300: LD_STRING 
55302: ST_TO_ADDR
// animal := CreateHuman ;
55303: LD_ADDR_VAR 0 12
55307: PUSH
55308: CALL_OW 44
55312: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55313: LD_VAR 0 12
55317: PPUSH
55318: LD_VAR 0 8
55322: PPUSH
55323: LD_INT 0
55325: PPUSH
55326: CALL 57048 0 3
// end ;
55330: GO 55284
55332: POP
55333: POP
// if fishes then
55334: LD_VAR 0 7
55338: IFFALSE 55405
// for i = 1 to fishes do
55340: LD_ADDR_VAR 0 11
55344: PUSH
55345: DOUBLE
55346: LD_INT 1
55348: DEC
55349: ST_TO_ADDR
55350: LD_VAR 0 7
55354: PUSH
55355: FOR_TO
55356: IFFALSE 55403
// begin hc_class = 20 ;
55358: LD_ADDR_OWVAR 28
55362: PUSH
55363: LD_INT 20
55365: ST_TO_ADDR
// hc_gallery =  ;
55366: LD_ADDR_OWVAR 33
55370: PUSH
55371: LD_STRING 
55373: ST_TO_ADDR
// animal := CreateHuman ;
55374: LD_ADDR_VAR 0 12
55378: PUSH
55379: CALL_OW 44
55383: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
55384: LD_VAR 0 12
55388: PPUSH
55389: LD_VAR 0 9
55393: PPUSH
55394: LD_INT 0
55396: PPUSH
55397: CALL 57048 0 3
// end ;
55401: GO 55355
55403: POP
55404: POP
// end ;
55405: LD_VAR 0 10
55409: RET
// export function WantHeal ( sci , unit ) ; begin
55410: LD_INT 0
55412: PPUSH
// if GetTaskList ( sci ) > 0 then
55413: LD_VAR 0 1
55417: PPUSH
55418: CALL_OW 437
55422: PUSH
55423: LD_INT 0
55425: GREATER
55426: IFFALSE 55498
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
55428: LD_VAR 0 1
55432: PPUSH
55433: CALL_OW 437
55437: PUSH
55438: LD_INT 1
55440: ARRAY
55441: PUSH
55442: LD_INT 1
55444: ARRAY
55445: PUSH
55446: LD_STRING l
55448: EQUAL
55449: IFFALSE 55476
55451: PUSH
55452: LD_VAR 0 1
55456: PPUSH
55457: CALL_OW 437
55461: PUSH
55462: LD_INT 1
55464: ARRAY
55465: PUSH
55466: LD_INT 4
55468: ARRAY
55469: PUSH
55470: LD_VAR 0 2
55474: EQUAL
55475: AND
55476: IFFALSE 55488
// result := true else
55478: LD_ADDR_VAR 0 3
55482: PUSH
55483: LD_INT 1
55485: ST_TO_ADDR
55486: GO 55496
// result := false ;
55488: LD_ADDR_VAR 0 3
55492: PUSH
55493: LD_INT 0
55495: ST_TO_ADDR
// end else
55496: GO 55506
// result := false ;
55498: LD_ADDR_VAR 0 3
55502: PUSH
55503: LD_INT 0
55505: ST_TO_ADDR
// end ;
55506: LD_VAR 0 3
55510: RET
// export function HealTarget ( sci ) ; begin
55511: LD_INT 0
55513: PPUSH
// if not sci then
55514: LD_VAR 0 1
55518: NOT
55519: IFFALSE 55523
// exit ;
55521: GO 55588
// result := 0 ;
55523: LD_ADDR_VAR 0 2
55527: PUSH
55528: LD_INT 0
55530: ST_TO_ADDR
// if GetTaskList ( sci ) then
55531: LD_VAR 0 1
55535: PPUSH
55536: CALL_OW 437
55540: IFFALSE 55588
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
55542: LD_VAR 0 1
55546: PPUSH
55547: CALL_OW 437
55551: PUSH
55552: LD_INT 1
55554: ARRAY
55555: PUSH
55556: LD_INT 1
55558: ARRAY
55559: PUSH
55560: LD_STRING l
55562: EQUAL
55563: IFFALSE 55588
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
55565: LD_ADDR_VAR 0 2
55569: PUSH
55570: LD_VAR 0 1
55574: PPUSH
55575: CALL_OW 437
55579: PUSH
55580: LD_INT 1
55582: ARRAY
55583: PUSH
55584: LD_INT 4
55586: ARRAY
55587: ST_TO_ADDR
// end ;
55588: LD_VAR 0 2
55592: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
55593: LD_INT 0
55595: PPUSH
55596: PPUSH
55597: PPUSH
55598: PPUSH
// if not base_units then
55599: LD_VAR 0 1
55603: NOT
55604: IFFALSE 55608
// exit ;
55606: GO 55695
// result := false ;
55608: LD_ADDR_VAR 0 2
55612: PUSH
55613: LD_INT 0
55615: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
55616: LD_ADDR_VAR 0 5
55620: PUSH
55621: LD_VAR 0 1
55625: PPUSH
55626: LD_INT 21
55628: PUSH
55629: LD_INT 3
55631: PUSH
55632: EMPTY
55633: LIST
55634: LIST
55635: PPUSH
55636: CALL_OW 72
55640: ST_TO_ADDR
// if not tmp then
55641: LD_VAR 0 5
55645: NOT
55646: IFFALSE 55650
// exit ;
55648: GO 55695
// for i in tmp do
55650: LD_ADDR_VAR 0 3
55654: PUSH
55655: LD_VAR 0 5
55659: PUSH
55660: FOR_IN
55661: IFFALSE 55693
// begin result := EnemyInRange ( i , 22 ) ;
55663: LD_ADDR_VAR 0 2
55667: PUSH
55668: LD_VAR 0 3
55672: PPUSH
55673: LD_INT 22
55675: PPUSH
55676: CALL 53110 0 2
55680: ST_TO_ADDR
// if result then
55681: LD_VAR 0 2
55685: IFFALSE 55691
// exit ;
55687: POP
55688: POP
55689: GO 55695
// end ;
55691: GO 55660
55693: POP
55694: POP
// end ;
55695: LD_VAR 0 2
55699: RET
// export function FilterByTag ( units , tag ) ; begin
55700: LD_INT 0
55702: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
55703: LD_ADDR_VAR 0 3
55707: PUSH
55708: LD_VAR 0 1
55712: PPUSH
55713: LD_INT 120
55715: PUSH
55716: LD_VAR 0 2
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PPUSH
55725: CALL_OW 72
55729: ST_TO_ADDR
// end ;
55730: LD_VAR 0 3
55734: RET
// export function IsDriver ( un ) ; begin
55735: LD_INT 0
55737: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
55738: LD_ADDR_VAR 0 2
55742: PUSH
55743: LD_VAR 0 1
55747: PUSH
55748: LD_INT 55
55750: PUSH
55751: EMPTY
55752: LIST
55753: PPUSH
55754: CALL_OW 69
55758: IN
55759: ST_TO_ADDR
// end ;
55760: LD_VAR 0 2
55764: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
55765: LD_INT 0
55767: PPUSH
55768: PPUSH
// list := [ ] ;
55769: LD_ADDR_VAR 0 5
55773: PUSH
55774: EMPTY
55775: ST_TO_ADDR
// case d of 0 :
55776: LD_VAR 0 3
55780: PUSH
55781: LD_INT 0
55783: DOUBLE
55784: EQUAL
55785: IFTRUE 55789
55787: GO 55922
55789: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55790: LD_ADDR_VAR 0 5
55794: PUSH
55795: LD_VAR 0 1
55799: PUSH
55800: LD_INT 4
55802: MINUS
55803: PUSH
55804: LD_VAR 0 2
55808: PUSH
55809: LD_INT 4
55811: MINUS
55812: PUSH
55813: LD_INT 2
55815: PUSH
55816: EMPTY
55817: LIST
55818: LIST
55819: LIST
55820: PUSH
55821: LD_VAR 0 1
55825: PUSH
55826: LD_INT 3
55828: MINUS
55829: PUSH
55830: LD_VAR 0 2
55834: PUSH
55835: LD_INT 1
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: LIST
55842: PUSH
55843: LD_VAR 0 1
55847: PUSH
55848: LD_INT 4
55850: PLUS
55851: PUSH
55852: LD_VAR 0 2
55856: PUSH
55857: LD_INT 4
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: LIST
55864: PUSH
55865: LD_VAR 0 1
55869: PUSH
55870: LD_INT 3
55872: PLUS
55873: PUSH
55874: LD_VAR 0 2
55878: PUSH
55879: LD_INT 3
55881: PLUS
55882: PUSH
55883: LD_INT 5
55885: PUSH
55886: EMPTY
55887: LIST
55888: LIST
55889: LIST
55890: PUSH
55891: LD_VAR 0 1
55895: PUSH
55896: LD_VAR 0 2
55900: PUSH
55901: LD_INT 4
55903: PLUS
55904: PUSH
55905: LD_INT 0
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: LIST
55912: PUSH
55913: EMPTY
55914: LIST
55915: LIST
55916: LIST
55917: LIST
55918: LIST
55919: ST_TO_ADDR
// end ; 1 :
55920: GO 56620
55922: LD_INT 1
55924: DOUBLE
55925: EQUAL
55926: IFTRUE 55930
55928: GO 56063
55930: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55931: LD_ADDR_VAR 0 5
55935: PUSH
55936: LD_VAR 0 1
55940: PUSH
55941: LD_VAR 0 2
55945: PUSH
55946: LD_INT 4
55948: MINUS
55949: PUSH
55950: LD_INT 3
55952: PUSH
55953: EMPTY
55954: LIST
55955: LIST
55956: LIST
55957: PUSH
55958: LD_VAR 0 1
55962: PUSH
55963: LD_INT 3
55965: MINUS
55966: PUSH
55967: LD_VAR 0 2
55971: PUSH
55972: LD_INT 3
55974: MINUS
55975: PUSH
55976: LD_INT 2
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: LIST
55983: PUSH
55984: LD_VAR 0 1
55988: PUSH
55989: LD_INT 4
55991: MINUS
55992: PUSH
55993: LD_VAR 0 2
55997: PUSH
55998: LD_INT 1
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: LIST
56005: PUSH
56006: LD_VAR 0 1
56010: PUSH
56011: LD_VAR 0 2
56015: PUSH
56016: LD_INT 3
56018: PLUS
56019: PUSH
56020: LD_INT 0
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: LIST
56027: PUSH
56028: LD_VAR 0 1
56032: PUSH
56033: LD_INT 4
56035: PLUS
56036: PUSH
56037: LD_VAR 0 2
56041: PUSH
56042: LD_INT 4
56044: PLUS
56045: PUSH
56046: LD_INT 5
56048: PUSH
56049: EMPTY
56050: LIST
56051: LIST
56052: LIST
56053: PUSH
56054: EMPTY
56055: LIST
56056: LIST
56057: LIST
56058: LIST
56059: LIST
56060: ST_TO_ADDR
// end ; 2 :
56061: GO 56620
56063: LD_INT 2
56065: DOUBLE
56066: EQUAL
56067: IFTRUE 56071
56069: GO 56200
56071: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
56072: LD_ADDR_VAR 0 5
56076: PUSH
56077: LD_VAR 0 1
56081: PUSH
56082: LD_VAR 0 2
56086: PUSH
56087: LD_INT 3
56089: MINUS
56090: PUSH
56091: LD_INT 3
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: LIST
56098: PUSH
56099: LD_VAR 0 1
56103: PUSH
56104: LD_INT 4
56106: PLUS
56107: PUSH
56108: LD_VAR 0 2
56112: PUSH
56113: LD_INT 4
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: LIST
56120: PUSH
56121: LD_VAR 0 1
56125: PUSH
56126: LD_VAR 0 2
56130: PUSH
56131: LD_INT 4
56133: PLUS
56134: PUSH
56135: LD_INT 0
56137: PUSH
56138: EMPTY
56139: LIST
56140: LIST
56141: LIST
56142: PUSH
56143: LD_VAR 0 1
56147: PUSH
56148: LD_INT 3
56150: MINUS
56151: PUSH
56152: LD_VAR 0 2
56156: PUSH
56157: LD_INT 1
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: LIST
56164: PUSH
56165: LD_VAR 0 1
56169: PUSH
56170: LD_INT 4
56172: MINUS
56173: PUSH
56174: LD_VAR 0 2
56178: PUSH
56179: LD_INT 4
56181: MINUS
56182: PUSH
56183: LD_INT 2
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: LIST
56190: PUSH
56191: EMPTY
56192: LIST
56193: LIST
56194: LIST
56195: LIST
56196: LIST
56197: ST_TO_ADDR
// end ; 3 :
56198: GO 56620
56200: LD_INT 3
56202: DOUBLE
56203: EQUAL
56204: IFTRUE 56208
56206: GO 56341
56208: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
56209: LD_ADDR_VAR 0 5
56213: PUSH
56214: LD_VAR 0 1
56218: PUSH
56219: LD_INT 3
56221: PLUS
56222: PUSH
56223: LD_VAR 0 2
56227: PUSH
56228: LD_INT 4
56230: PUSH
56231: EMPTY
56232: LIST
56233: LIST
56234: LIST
56235: PUSH
56236: LD_VAR 0 1
56240: PUSH
56241: LD_INT 4
56243: PLUS
56244: PUSH
56245: LD_VAR 0 2
56249: PUSH
56250: LD_INT 4
56252: PLUS
56253: PUSH
56254: LD_INT 5
56256: PUSH
56257: EMPTY
56258: LIST
56259: LIST
56260: LIST
56261: PUSH
56262: LD_VAR 0 1
56266: PUSH
56267: LD_INT 4
56269: MINUS
56270: PUSH
56271: LD_VAR 0 2
56275: PUSH
56276: LD_INT 1
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: LIST
56283: PUSH
56284: LD_VAR 0 1
56288: PUSH
56289: LD_VAR 0 2
56293: PUSH
56294: LD_INT 4
56296: MINUS
56297: PUSH
56298: LD_INT 3
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: LIST
56305: PUSH
56306: LD_VAR 0 1
56310: PUSH
56311: LD_INT 3
56313: MINUS
56314: PUSH
56315: LD_VAR 0 2
56319: PUSH
56320: LD_INT 3
56322: MINUS
56323: PUSH
56324: LD_INT 2
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: LIST
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: LIST
56336: LIST
56337: LIST
56338: ST_TO_ADDR
// end ; 4 :
56339: GO 56620
56341: LD_INT 4
56343: DOUBLE
56344: EQUAL
56345: IFTRUE 56349
56347: GO 56482
56349: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
56350: LD_ADDR_VAR 0 5
56354: PUSH
56355: LD_VAR 0 1
56359: PUSH
56360: LD_VAR 0 2
56364: PUSH
56365: LD_INT 4
56367: PLUS
56368: PUSH
56369: LD_INT 0
56371: PUSH
56372: EMPTY
56373: LIST
56374: LIST
56375: LIST
56376: PUSH
56377: LD_VAR 0 1
56381: PUSH
56382: LD_INT 3
56384: PLUS
56385: PUSH
56386: LD_VAR 0 2
56390: PUSH
56391: LD_INT 3
56393: PLUS
56394: PUSH
56395: LD_INT 5
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: LIST
56402: PUSH
56403: LD_VAR 0 1
56407: PUSH
56408: LD_INT 4
56410: PLUS
56411: PUSH
56412: LD_VAR 0 2
56416: PUSH
56417: LD_INT 4
56419: PUSH
56420: EMPTY
56421: LIST
56422: LIST
56423: LIST
56424: PUSH
56425: LD_VAR 0 1
56429: PUSH
56430: LD_VAR 0 2
56434: PUSH
56435: LD_INT 3
56437: MINUS
56438: PUSH
56439: LD_INT 3
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: LIST
56446: PUSH
56447: LD_VAR 0 1
56451: PUSH
56452: LD_INT 4
56454: MINUS
56455: PUSH
56456: LD_VAR 0 2
56460: PUSH
56461: LD_INT 4
56463: MINUS
56464: PUSH
56465: LD_INT 2
56467: PUSH
56468: EMPTY
56469: LIST
56470: LIST
56471: LIST
56472: PUSH
56473: EMPTY
56474: LIST
56475: LIST
56476: LIST
56477: LIST
56478: LIST
56479: ST_TO_ADDR
// end ; 5 :
56480: GO 56620
56482: LD_INT 5
56484: DOUBLE
56485: EQUAL
56486: IFTRUE 56490
56488: GO 56619
56490: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
56491: LD_ADDR_VAR 0 5
56495: PUSH
56496: LD_VAR 0 1
56500: PUSH
56501: LD_INT 4
56503: MINUS
56504: PUSH
56505: LD_VAR 0 2
56509: PUSH
56510: LD_INT 1
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: LIST
56517: PUSH
56518: LD_VAR 0 1
56522: PUSH
56523: LD_VAR 0 2
56527: PUSH
56528: LD_INT 4
56530: MINUS
56531: PUSH
56532: LD_INT 3
56534: PUSH
56535: EMPTY
56536: LIST
56537: LIST
56538: LIST
56539: PUSH
56540: LD_VAR 0 1
56544: PUSH
56545: LD_INT 4
56547: PLUS
56548: PUSH
56549: LD_VAR 0 2
56553: PUSH
56554: LD_INT 4
56556: PLUS
56557: PUSH
56558: LD_INT 5
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: LIST
56565: PUSH
56566: LD_VAR 0 1
56570: PUSH
56571: LD_INT 3
56573: PLUS
56574: PUSH
56575: LD_VAR 0 2
56579: PUSH
56580: LD_INT 4
56582: PUSH
56583: EMPTY
56584: LIST
56585: LIST
56586: LIST
56587: PUSH
56588: LD_VAR 0 1
56592: PUSH
56593: LD_VAR 0 2
56597: PUSH
56598: LD_INT 3
56600: PLUS
56601: PUSH
56602: LD_INT 0
56604: PUSH
56605: EMPTY
56606: LIST
56607: LIST
56608: LIST
56609: PUSH
56610: EMPTY
56611: LIST
56612: LIST
56613: LIST
56614: LIST
56615: LIST
56616: ST_TO_ADDR
// end ; end ;
56617: GO 56620
56619: POP
// result := list ;
56620: LD_ADDR_VAR 0 4
56624: PUSH
56625: LD_VAR 0 5
56629: ST_TO_ADDR
// end ;
56630: LD_VAR 0 4
56634: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
56635: LD_INT 0
56637: PPUSH
56638: PPUSH
56639: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
56640: LD_VAR 0 1
56644: NOT
56645: IFTRUE 56673
56647: PUSH
56648: LD_VAR 0 2
56652: PUSH
56653: LD_INT 1
56655: PUSH
56656: LD_INT 2
56658: PUSH
56659: LD_INT 3
56661: PUSH
56662: LD_INT 4
56664: PUSH
56665: EMPTY
56666: LIST
56667: LIST
56668: LIST
56669: LIST
56670: IN
56671: NOT
56672: OR
56673: IFFALSE 56677
// exit ;
56675: GO 56760
// tmp := [ ] ;
56677: LD_ADDR_VAR 0 5
56681: PUSH
56682: EMPTY
56683: ST_TO_ADDR
// for i in units do
56684: LD_ADDR_VAR 0 4
56688: PUSH
56689: LD_VAR 0 1
56693: PUSH
56694: FOR_IN
56695: IFFALSE 56729
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
56697: LD_ADDR_VAR 0 5
56701: PUSH
56702: LD_VAR 0 5
56706: PPUSH
56707: LD_VAR 0 4
56711: PPUSH
56712: LD_VAR 0 2
56716: PPUSH
56717: CALL_OW 259
56721: PPUSH
56722: CALL 58155 0 2
56726: ST_TO_ADDR
56727: GO 56694
56729: POP
56730: POP
// if not tmp then
56731: LD_VAR 0 5
56735: NOT
56736: IFFALSE 56740
// exit ;
56738: GO 56760
// result := SortListByListDesc ( units , tmp ) ;
56740: LD_ADDR_VAR 0 3
56744: PUSH
56745: LD_VAR 0 1
56749: PPUSH
56750: LD_VAR 0 5
56754: PPUSH
56755: CALL_OW 77
56759: ST_TO_ADDR
// end ;
56760: LD_VAR 0 3
56764: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
56765: LD_INT 0
56767: PPUSH
56768: PPUSH
56769: PPUSH
// result := false ;
56770: LD_ADDR_VAR 0 3
56774: PUSH
56775: LD_INT 0
56777: ST_TO_ADDR
// if not building then
56778: LD_VAR 0 2
56782: NOT
56783: IFFALSE 56787
// exit ;
56785: GO 56931
// x := GetX ( building ) ;
56787: LD_ADDR_VAR 0 4
56791: PUSH
56792: LD_VAR 0 2
56796: PPUSH
56797: CALL_OW 250
56801: ST_TO_ADDR
// y := GetY ( building ) ;
56802: LD_ADDR_VAR 0 5
56806: PUSH
56807: LD_VAR 0 2
56811: PPUSH
56812: CALL_OW 251
56816: ST_TO_ADDR
// if not x or not y then
56817: LD_VAR 0 4
56821: NOT
56822: IFTRUE 56831
56824: PUSH
56825: LD_VAR 0 5
56829: NOT
56830: OR
56831: IFFALSE 56835
// exit ;
56833: GO 56931
// if GetTaskList ( unit ) then
56835: LD_VAR 0 1
56839: PPUSH
56840: CALL_OW 437
56844: IFFALSE 56931
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56846: LD_STRING e
56848: PUSH
56849: LD_VAR 0 1
56853: PPUSH
56854: CALL_OW 437
56858: PUSH
56859: LD_INT 1
56861: ARRAY
56862: PUSH
56863: LD_INT 1
56865: ARRAY
56866: EQUAL
56867: IFFALSE 56894
56869: PUSH
56870: LD_VAR 0 4
56874: PUSH
56875: LD_VAR 0 1
56879: PPUSH
56880: CALL_OW 437
56884: PUSH
56885: LD_INT 1
56887: ARRAY
56888: PUSH
56889: LD_INT 2
56891: ARRAY
56892: EQUAL
56893: AND
56894: IFFALSE 56921
56896: PUSH
56897: LD_VAR 0 5
56901: PUSH
56902: LD_VAR 0 1
56906: PPUSH
56907: CALL_OW 437
56911: PUSH
56912: LD_INT 1
56914: ARRAY
56915: PUSH
56916: LD_INT 3
56918: ARRAY
56919: EQUAL
56920: AND
56921: IFFALSE 56931
// result := true end ;
56923: LD_ADDR_VAR 0 3
56927: PUSH
56928: LD_INT 1
56930: ST_TO_ADDR
// end ;
56931: LD_VAR 0 3
56935: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56936: LD_INT 0
56938: PPUSH
// result := false ;
56939: LD_ADDR_VAR 0 4
56943: PUSH
56944: LD_INT 0
56946: ST_TO_ADDR
// if GetTaskList ( unit ) then
56947: LD_VAR 0 1
56951: PPUSH
56952: CALL_OW 437
56956: IFFALSE 57043
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56958: LD_STRING M
56960: PUSH
56961: LD_VAR 0 1
56965: PPUSH
56966: CALL_OW 437
56970: PUSH
56971: LD_INT 1
56973: ARRAY
56974: PUSH
56975: LD_INT 1
56977: ARRAY
56978: EQUAL
56979: IFFALSE 57006
56981: PUSH
56982: LD_VAR 0 2
56986: PUSH
56987: LD_VAR 0 1
56991: PPUSH
56992: CALL_OW 437
56996: PUSH
56997: LD_INT 1
56999: ARRAY
57000: PUSH
57001: LD_INT 2
57003: ARRAY
57004: EQUAL
57005: AND
57006: IFFALSE 57033
57008: PUSH
57009: LD_VAR 0 3
57013: PUSH
57014: LD_VAR 0 1
57018: PPUSH
57019: CALL_OW 437
57023: PUSH
57024: LD_INT 1
57026: ARRAY
57027: PUSH
57028: LD_INT 3
57030: ARRAY
57031: EQUAL
57032: AND
57033: IFFALSE 57043
// result := true ;
57035: LD_ADDR_VAR 0 4
57039: PUSH
57040: LD_INT 1
57042: ST_TO_ADDR
// end ; end ;
57043: LD_VAR 0 4
57047: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
57048: LD_INT 0
57050: PPUSH
57051: PPUSH
57052: PPUSH
57053: PPUSH
// if not unit or not area then
57054: LD_VAR 0 1
57058: NOT
57059: IFTRUE 57068
57061: PUSH
57062: LD_VAR 0 2
57066: NOT
57067: OR
57068: IFFALSE 57072
// exit ;
57070: GO 57248
// tmp := AreaToList ( area , i ) ;
57072: LD_ADDR_VAR 0 6
57076: PUSH
57077: LD_VAR 0 2
57081: PPUSH
57082: LD_VAR 0 5
57086: PPUSH
57087: CALL_OW 517
57091: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
57092: LD_ADDR_VAR 0 5
57096: PUSH
57097: DOUBLE
57098: LD_INT 1
57100: DEC
57101: ST_TO_ADDR
57102: LD_VAR 0 6
57106: PUSH
57107: LD_INT 1
57109: ARRAY
57110: PUSH
57111: FOR_TO
57112: IFFALSE 57246
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
57114: LD_ADDR_VAR 0 7
57118: PUSH
57119: LD_VAR 0 6
57123: PUSH
57124: LD_INT 1
57126: ARRAY
57127: PUSH
57128: LD_VAR 0 5
57132: ARRAY
57133: PUSH
57134: LD_VAR 0 6
57138: PUSH
57139: LD_INT 2
57141: ARRAY
57142: PUSH
57143: LD_VAR 0 5
57147: ARRAY
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
57153: LD_INT 92
57155: PUSH
57156: LD_VAR 0 7
57160: PUSH
57161: LD_INT 1
57163: ARRAY
57164: PUSH
57165: LD_VAR 0 7
57169: PUSH
57170: LD_INT 2
57172: ARRAY
57173: PUSH
57174: LD_INT 2
57176: PUSH
57177: EMPTY
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: PPUSH
57183: CALL_OW 69
57187: PUSH
57188: LD_INT 0
57190: EQUAL
57191: IFFALSE 57244
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
57193: LD_VAR 0 1
57197: PPUSH
57198: LD_VAR 0 7
57202: PUSH
57203: LD_INT 1
57205: ARRAY
57206: PPUSH
57207: LD_VAR 0 7
57211: PUSH
57212: LD_INT 2
57214: ARRAY
57215: PPUSH
57216: LD_VAR 0 3
57220: PPUSH
57221: CALL_OW 48
// result := IsPlaced ( unit ) ;
57225: LD_ADDR_VAR 0 4
57229: PUSH
57230: LD_VAR 0 1
57234: PPUSH
57235: CALL_OW 305
57239: ST_TO_ADDR
// exit ;
57240: POP
57241: POP
57242: GO 57248
// end ; end ;
57244: GO 57111
57246: POP
57247: POP
// end ;
57248: LD_VAR 0 4
57252: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
57253: LD_INT 0
57255: PPUSH
57256: PPUSH
57257: PPUSH
// if not side or side > 8 then
57258: LD_VAR 0 1
57262: NOT
57263: IFTRUE 57275
57265: PUSH
57266: LD_VAR 0 1
57270: PUSH
57271: LD_INT 8
57273: GREATER
57274: OR
57275: IFFALSE 57279
// exit ;
57277: GO 57466
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
57279: LD_ADDR_VAR 0 4
57283: PUSH
57284: LD_INT 22
57286: PUSH
57287: LD_VAR 0 1
57291: PUSH
57292: EMPTY
57293: LIST
57294: LIST
57295: PUSH
57296: LD_INT 21
57298: PUSH
57299: LD_INT 3
57301: PUSH
57302: EMPTY
57303: LIST
57304: LIST
57305: PUSH
57306: EMPTY
57307: LIST
57308: LIST
57309: PPUSH
57310: CALL_OW 69
57314: ST_TO_ADDR
// if not tmp then
57315: LD_VAR 0 4
57319: NOT
57320: IFFALSE 57324
// exit ;
57322: GO 57466
// enable_addtolog := true ;
57324: LD_ADDR_OWVAR 81
57328: PUSH
57329: LD_INT 1
57331: ST_TO_ADDR
// AddToLog ( [ ) ;
57332: LD_STRING [
57334: PPUSH
57335: CALL_OW 561
// for i in tmp do
57339: LD_ADDR_VAR 0 3
57343: PUSH
57344: LD_VAR 0 4
57348: PUSH
57349: FOR_IN
57350: IFFALSE 57457
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
57352: LD_STRING [
57354: PUSH
57355: LD_VAR 0 3
57359: PPUSH
57360: CALL_OW 266
57364: STR
57365: PUSH
57366: LD_STRING , 
57368: STR
57369: PUSH
57370: LD_VAR 0 3
57374: PPUSH
57375: CALL_OW 250
57379: STR
57380: PUSH
57381: LD_STRING , 
57383: STR
57384: PUSH
57385: LD_VAR 0 3
57389: PPUSH
57390: CALL_OW 251
57394: STR
57395: PUSH
57396: LD_STRING , 
57398: STR
57399: PUSH
57400: LD_VAR 0 3
57404: PPUSH
57405: CALL_OW 254
57409: STR
57410: PUSH
57411: LD_STRING , 
57413: STR
57414: PUSH
57415: LD_VAR 0 3
57419: PPUSH
57420: LD_INT 1
57422: PPUSH
57423: CALL_OW 268
57427: STR
57428: PUSH
57429: LD_STRING , 
57431: STR
57432: PUSH
57433: LD_VAR 0 3
57437: PPUSH
57438: LD_INT 2
57440: PPUSH
57441: CALL_OW 268
57445: STR
57446: PUSH
57447: LD_STRING ],
57449: STR
57450: PPUSH
57451: CALL_OW 561
// end ;
57455: GO 57349
57457: POP
57458: POP
// AddToLog ( ]; ) ;
57459: LD_STRING ];
57461: PPUSH
57462: CALL_OW 561
// end ;
57466: LD_VAR 0 2
57470: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
57471: LD_INT 0
57473: PPUSH
57474: PPUSH
57475: PPUSH
57476: PPUSH
57477: PPUSH
// if not area or not rate or not max then
57478: LD_VAR 0 1
57482: NOT
57483: IFTRUE 57492
57485: PUSH
57486: LD_VAR 0 2
57490: NOT
57491: OR
57492: IFTRUE 57501
57494: PUSH
57495: LD_VAR 0 4
57499: NOT
57500: OR
57501: IFFALSE 57505
// exit ;
57503: GO 57694
// while 1 do
57505: LD_INT 1
57507: IFFALSE 57694
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
57509: LD_ADDR_VAR 0 9
57513: PUSH
57514: LD_VAR 0 1
57518: PPUSH
57519: LD_INT 1
57521: PPUSH
57522: CALL_OW 287
57526: PUSH
57527: LD_INT 10
57529: MUL
57530: ST_TO_ADDR
// r := rate / 10 ;
57531: LD_ADDR_VAR 0 7
57535: PUSH
57536: LD_VAR 0 2
57540: PUSH
57541: LD_INT 10
57543: DIVREAL
57544: ST_TO_ADDR
// time := 1 1$00 ;
57545: LD_ADDR_VAR 0 8
57549: PUSH
57550: LD_INT 2100
57552: ST_TO_ADDR
// if amount < min then
57553: LD_VAR 0 9
57557: PUSH
57558: LD_VAR 0 3
57562: LESS
57563: IFFALSE 57581
// r := r * 2 else
57565: LD_ADDR_VAR 0 7
57569: PUSH
57570: LD_VAR 0 7
57574: PUSH
57575: LD_INT 2
57577: MUL
57578: ST_TO_ADDR
57579: GO 57607
// if amount > max then
57581: LD_VAR 0 9
57585: PUSH
57586: LD_VAR 0 4
57590: GREATER
57591: IFFALSE 57607
// r := r / 2 ;
57593: LD_ADDR_VAR 0 7
57597: PUSH
57598: LD_VAR 0 7
57602: PUSH
57603: LD_INT 2
57605: DIVREAL
57606: ST_TO_ADDR
// time := time / r ;
57607: LD_ADDR_VAR 0 8
57611: PUSH
57612: LD_VAR 0 8
57616: PUSH
57617: LD_VAR 0 7
57621: DIVREAL
57622: ST_TO_ADDR
// if time < 0 then
57623: LD_VAR 0 8
57627: PUSH
57628: LD_INT 0
57630: LESS
57631: IFFALSE 57648
// time := time * - 1 ;
57633: LD_ADDR_VAR 0 8
57637: PUSH
57638: LD_VAR 0 8
57642: PUSH
57643: LD_INT 1
57645: NEG
57646: MUL
57647: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
57648: LD_VAR 0 8
57652: PUSH
57653: LD_INT 35
57655: PPUSH
57656: LD_INT 875
57658: PPUSH
57659: CALL_OW 12
57663: PLUS
57664: PPUSH
57665: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
57669: LD_INT 1
57671: PPUSH
57672: LD_INT 5
57674: PPUSH
57675: CALL_OW 12
57679: PPUSH
57680: LD_VAR 0 1
57684: PPUSH
57685: LD_INT 1
57687: PPUSH
57688: CALL_OW 55
// end ;
57692: GO 57505
// end ;
57694: LD_VAR 0 5
57698: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
57699: LD_INT 0
57701: PPUSH
57702: PPUSH
57703: PPUSH
57704: PPUSH
57705: PPUSH
57706: PPUSH
57707: PPUSH
57708: PPUSH
// if not turrets or not factories then
57709: LD_VAR 0 1
57713: NOT
57714: IFTRUE 57723
57716: PUSH
57717: LD_VAR 0 2
57721: NOT
57722: OR
57723: IFFALSE 57727
// exit ;
57725: GO 58034
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
57727: LD_ADDR_VAR 0 10
57731: PUSH
57732: LD_INT 5
57734: PUSH
57735: LD_INT 6
57737: PUSH
57738: EMPTY
57739: LIST
57740: LIST
57741: PUSH
57742: LD_INT 2
57744: PUSH
57745: LD_INT 4
57747: PUSH
57748: EMPTY
57749: LIST
57750: LIST
57751: PUSH
57752: LD_INT 3
57754: PUSH
57755: LD_INT 5
57757: PUSH
57758: EMPTY
57759: LIST
57760: LIST
57761: PUSH
57762: EMPTY
57763: LIST
57764: LIST
57765: LIST
57766: PUSH
57767: LD_INT 24
57769: PUSH
57770: LD_INT 25
57772: PUSH
57773: EMPTY
57774: LIST
57775: LIST
57776: PUSH
57777: LD_INT 23
57779: PUSH
57780: LD_INT 27
57782: PUSH
57783: EMPTY
57784: LIST
57785: LIST
57786: PUSH
57787: EMPTY
57788: LIST
57789: LIST
57790: PUSH
57791: LD_INT 42
57793: PUSH
57794: LD_INT 43
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: PUSH
57801: LD_INT 44
57803: PUSH
57804: LD_INT 46
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: PUSH
57811: LD_INT 45
57813: PUSH
57814: LD_INT 47
57816: PUSH
57817: EMPTY
57818: LIST
57819: LIST
57820: PUSH
57821: EMPTY
57822: LIST
57823: LIST
57824: LIST
57825: PUSH
57826: EMPTY
57827: LIST
57828: LIST
57829: LIST
57830: ST_TO_ADDR
// result := [ ] ;
57831: LD_ADDR_VAR 0 3
57835: PUSH
57836: EMPTY
57837: ST_TO_ADDR
// for i in turrets do
57838: LD_ADDR_VAR 0 4
57842: PUSH
57843: LD_VAR 0 1
57847: PUSH
57848: FOR_IN
57849: IFFALSE 58032
// begin nat := GetNation ( i ) ;
57851: LD_ADDR_VAR 0 7
57855: PUSH
57856: LD_VAR 0 4
57860: PPUSH
57861: CALL_OW 248
57865: ST_TO_ADDR
// weapon := 0 ;
57866: LD_ADDR_VAR 0 8
57870: PUSH
57871: LD_INT 0
57873: ST_TO_ADDR
// if not nat then
57874: LD_VAR 0 7
57878: NOT
57879: IFFALSE 57883
// continue ;
57881: GO 57848
// for j in list [ nat ] do
57883: LD_ADDR_VAR 0 5
57887: PUSH
57888: LD_VAR 0 10
57892: PUSH
57893: LD_VAR 0 7
57897: ARRAY
57898: PUSH
57899: FOR_IN
57900: IFFALSE 57941
// if GetBWeapon ( i ) = j [ 1 ] then
57902: LD_VAR 0 4
57906: PPUSH
57907: CALL_OW 269
57911: PUSH
57912: LD_VAR 0 5
57916: PUSH
57917: LD_INT 1
57919: ARRAY
57920: EQUAL
57921: IFFALSE 57939
// begin weapon := j [ 2 ] ;
57923: LD_ADDR_VAR 0 8
57927: PUSH
57928: LD_VAR 0 5
57932: PUSH
57933: LD_INT 2
57935: ARRAY
57936: ST_TO_ADDR
// break ;
57937: GO 57941
// end ;
57939: GO 57899
57941: POP
57942: POP
// if not weapon then
57943: LD_VAR 0 8
57947: NOT
57948: IFFALSE 57952
// continue ;
57950: GO 57848
// for k in factories do
57952: LD_ADDR_VAR 0 6
57956: PUSH
57957: LD_VAR 0 2
57961: PUSH
57962: FOR_IN
57963: IFFALSE 58028
// begin weapons := AvailableWeaponList ( k ) ;
57965: LD_ADDR_VAR 0 9
57969: PUSH
57970: LD_VAR 0 6
57974: PPUSH
57975: CALL_OW 478
57979: ST_TO_ADDR
// if not weapons then
57980: LD_VAR 0 9
57984: NOT
57985: IFFALSE 57989
// continue ;
57987: GO 57962
// if weapon in weapons then
57989: LD_VAR 0 8
57993: PUSH
57994: LD_VAR 0 9
57998: IN
57999: IFFALSE 58026
// begin result := [ i , weapon ] ;
58001: LD_ADDR_VAR 0 3
58005: PUSH
58006: LD_VAR 0 4
58010: PUSH
58011: LD_VAR 0 8
58015: PUSH
58016: EMPTY
58017: LIST
58018: LIST
58019: ST_TO_ADDR
// exit ;
58020: POP
58021: POP
58022: POP
58023: POP
58024: GO 58034
// end ; end ;
58026: GO 57962
58028: POP
58029: POP
// end ;
58030: GO 57848
58032: POP
58033: POP
// end ;
58034: LD_VAR 0 3
58038: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
58039: LD_INT 0
58041: PPUSH
// if not side or side > 8 then
58042: LD_VAR 0 3
58046: NOT
58047: IFTRUE 58059
58049: PUSH
58050: LD_VAR 0 3
58054: PUSH
58055: LD_INT 8
58057: GREATER
58058: OR
58059: IFFALSE 58063
// exit ;
58061: GO 58122
// if not range then
58063: LD_VAR 0 4
58067: NOT
58068: IFFALSE 58079
// range := - 12 ;
58070: LD_ADDR_VAR 0 4
58074: PUSH
58075: LD_INT 12
58077: NEG
58078: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
58079: LD_VAR 0 1
58083: PPUSH
58084: LD_VAR 0 2
58088: PPUSH
58089: LD_VAR 0 3
58093: PPUSH
58094: LD_VAR 0 4
58098: PPUSH
58099: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
58103: LD_VAR 0 1
58107: PPUSH
58108: LD_VAR 0 2
58112: PPUSH
58113: LD_VAR 0 3
58117: PPUSH
58118: CALL_OW 331
// end ;
58122: LD_VAR 0 5
58126: RET
// export function Video ( mode ) ; begin
58127: LD_INT 0
58129: PPUSH
// ingame_video = mode ;
58130: LD_ADDR_OWVAR 52
58134: PUSH
58135: LD_VAR 0 1
58139: ST_TO_ADDR
// interface_hidden = mode ;
58140: LD_ADDR_OWVAR 54
58144: PUSH
58145: LD_VAR 0 1
58149: ST_TO_ADDR
// end ;
58150: LD_VAR 0 2
58154: RET
// export function Join ( array , element ) ; begin
58155: LD_INT 0
58157: PPUSH
// result := Replace ( array , array + 1 , element ) ;
58158: LD_ADDR_VAR 0 3
58162: PUSH
58163: LD_VAR 0 1
58167: PPUSH
58168: LD_VAR 0 1
58172: PUSH
58173: LD_INT 1
58175: PLUS
58176: PPUSH
58177: LD_VAR 0 2
58181: PPUSH
58182: CALL_OW 1
58186: ST_TO_ADDR
// end ;
58187: LD_VAR 0 3
58191: RET
// export function JoinUnion ( array , element ) ; begin
58192: LD_INT 0
58194: PPUSH
// result := array union element ;
58195: LD_ADDR_VAR 0 3
58199: PUSH
58200: LD_VAR 0 1
58204: PUSH
58205: LD_VAR 0 2
58209: UNION
58210: ST_TO_ADDR
// end ;
58211: LD_VAR 0 3
58215: RET
// export function GetBehemoths ( side ) ; begin
58216: LD_INT 0
58218: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
58219: LD_ADDR_VAR 0 2
58223: PUSH
58224: LD_INT 22
58226: PUSH
58227: LD_VAR 0 1
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: PUSH
58236: LD_INT 31
58238: PUSH
58239: LD_INT 25
58241: PUSH
58242: EMPTY
58243: LIST
58244: LIST
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: PPUSH
58250: CALL_OW 69
58254: ST_TO_ADDR
// end ;
58255: LD_VAR 0 2
58259: RET
// export function Shuffle ( array ) ; var i , index ; begin
58260: LD_INT 0
58262: PPUSH
58263: PPUSH
58264: PPUSH
// result := [ ] ;
58265: LD_ADDR_VAR 0 2
58269: PUSH
58270: EMPTY
58271: ST_TO_ADDR
// if not array then
58272: LD_VAR 0 1
58276: NOT
58277: IFFALSE 58281
// exit ;
58279: GO 58380
// Randomize ;
58281: CALL_OW 10
// for i = array downto 1 do
58285: LD_ADDR_VAR 0 3
58289: PUSH
58290: DOUBLE
58291: LD_VAR 0 1
58295: INC
58296: ST_TO_ADDR
58297: LD_INT 1
58299: PUSH
58300: FOR_DOWNTO
58301: IFFALSE 58378
// begin index := rand ( 1 , array ) ;
58303: LD_ADDR_VAR 0 4
58307: PUSH
58308: LD_INT 1
58310: PPUSH
58311: LD_VAR 0 1
58315: PPUSH
58316: CALL_OW 12
58320: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
58321: LD_ADDR_VAR 0 2
58325: PUSH
58326: LD_VAR 0 2
58330: PPUSH
58331: LD_VAR 0 2
58335: PUSH
58336: LD_INT 1
58338: PLUS
58339: PPUSH
58340: LD_VAR 0 1
58344: PUSH
58345: LD_VAR 0 4
58349: ARRAY
58350: PPUSH
58351: CALL_OW 2
58355: ST_TO_ADDR
// array := Delete ( array , index ) ;
58356: LD_ADDR_VAR 0 1
58360: PUSH
58361: LD_VAR 0 1
58365: PPUSH
58366: LD_VAR 0 4
58370: PPUSH
58371: CALL_OW 3
58375: ST_TO_ADDR
// end ;
58376: GO 58300
58378: POP
58379: POP
// end ;
58380: LD_VAR 0 2
58384: RET
// export function GetBaseMaterials ( base ) ; begin
58385: LD_INT 0
58387: PPUSH
// result := [ 0 , 0 , 0 ] ;
58388: LD_ADDR_VAR 0 2
58392: PUSH
58393: LD_INT 0
58395: PUSH
58396: LD_INT 0
58398: PUSH
58399: LD_INT 0
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: LIST
58406: ST_TO_ADDR
// if not base then
58407: LD_VAR 0 1
58411: NOT
58412: IFFALSE 58416
// exit ;
58414: GO 58465
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
58416: LD_ADDR_VAR 0 2
58420: PUSH
58421: LD_VAR 0 1
58425: PPUSH
58426: LD_INT 1
58428: PPUSH
58429: CALL_OW 275
58433: PUSH
58434: LD_VAR 0 1
58438: PPUSH
58439: LD_INT 2
58441: PPUSH
58442: CALL_OW 275
58446: PUSH
58447: LD_VAR 0 1
58451: PPUSH
58452: LD_INT 3
58454: PPUSH
58455: CALL_OW 275
58459: PUSH
58460: EMPTY
58461: LIST
58462: LIST
58463: LIST
58464: ST_TO_ADDR
// end ;
58465: LD_VAR 0 2
58469: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
58470: LD_INT 0
58472: PPUSH
58473: PPUSH
// result := array ;
58474: LD_ADDR_VAR 0 3
58478: PUSH
58479: LD_VAR 0 1
58483: ST_TO_ADDR
// if size >= result then
58484: LD_VAR 0 2
58488: PUSH
58489: LD_VAR 0 3
58493: GREATEREQUAL
58494: IFFALSE 58498
// exit ;
58496: GO 58548
// if size then
58498: LD_VAR 0 2
58502: IFFALSE 58548
// for i := array downto size do
58504: LD_ADDR_VAR 0 4
58508: PUSH
58509: DOUBLE
58510: LD_VAR 0 1
58514: INC
58515: ST_TO_ADDR
58516: LD_VAR 0 2
58520: PUSH
58521: FOR_DOWNTO
58522: IFFALSE 58546
// result := Delete ( result , result ) ;
58524: LD_ADDR_VAR 0 3
58528: PUSH
58529: LD_VAR 0 3
58533: PPUSH
58534: LD_VAR 0 3
58538: PPUSH
58539: CALL_OW 3
58543: ST_TO_ADDR
58544: GO 58521
58546: POP
58547: POP
// end ;
58548: LD_VAR 0 3
58552: RET
// export function ComExit ( unit ) ; var tmp ; begin
58553: LD_INT 0
58555: PPUSH
58556: PPUSH
// if not IsInUnit ( unit ) then
58557: LD_VAR 0 1
58561: PPUSH
58562: CALL_OW 310
58566: NOT
58567: IFFALSE 58571
// exit ;
58569: GO 58631
// tmp := IsInUnit ( unit ) ;
58571: LD_ADDR_VAR 0 3
58575: PUSH
58576: LD_VAR 0 1
58580: PPUSH
58581: CALL_OW 310
58585: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
58586: LD_VAR 0 3
58590: PPUSH
58591: CALL_OW 247
58595: PUSH
58596: LD_INT 2
58598: EQUAL
58599: IFFALSE 58612
// ComExitVehicle ( unit ) else
58601: LD_VAR 0 1
58605: PPUSH
58606: CALL_OW 121
58610: GO 58621
// ComExitBuilding ( unit ) ;
58612: LD_VAR 0 1
58616: PPUSH
58617: CALL_OW 122
// result := tmp ;
58621: LD_ADDR_VAR 0 2
58625: PUSH
58626: LD_VAR 0 3
58630: ST_TO_ADDR
// end ;
58631: LD_VAR 0 2
58635: RET
// export function ComExitAll ( units ) ; var i ; begin
58636: LD_INT 0
58638: PPUSH
58639: PPUSH
// if not units then
58640: LD_VAR 0 1
58644: NOT
58645: IFFALSE 58649
// exit ;
58647: GO 58675
// for i in units do
58649: LD_ADDR_VAR 0 3
58653: PUSH
58654: LD_VAR 0 1
58658: PUSH
58659: FOR_IN
58660: IFFALSE 58673
// ComExit ( i ) ;
58662: LD_VAR 0 3
58666: PPUSH
58667: CALL 58553 0 1
58671: GO 58659
58673: POP
58674: POP
// end ;
58675: LD_VAR 0 2
58679: RET
// export function ResetHc ; begin
58680: LD_INT 0
58682: PPUSH
// InitHc ;
58683: CALL_OW 19
// hc_importance := 0 ;
58687: LD_ADDR_OWVAR 32
58691: PUSH
58692: LD_INT 0
58694: ST_TO_ADDR
// end ;
58695: LD_VAR 0 1
58699: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
58700: LD_INT 0
58702: PPUSH
58703: PPUSH
58704: PPUSH
// _x := ( x1 + x2 ) div 2 ;
58705: LD_ADDR_VAR 0 6
58709: PUSH
58710: LD_VAR 0 1
58714: PUSH
58715: LD_VAR 0 3
58719: PLUS
58720: PUSH
58721: LD_INT 2
58723: DIV
58724: ST_TO_ADDR
// if _x < 0 then
58725: LD_VAR 0 6
58729: PUSH
58730: LD_INT 0
58732: LESS
58733: IFFALSE 58750
// _x := _x * - 1 ;
58735: LD_ADDR_VAR 0 6
58739: PUSH
58740: LD_VAR 0 6
58744: PUSH
58745: LD_INT 1
58747: NEG
58748: MUL
58749: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
58750: LD_ADDR_VAR 0 7
58754: PUSH
58755: LD_VAR 0 2
58759: PUSH
58760: LD_VAR 0 4
58764: PLUS
58765: PUSH
58766: LD_INT 2
58768: DIV
58769: ST_TO_ADDR
// if _y < 0 then
58770: LD_VAR 0 7
58774: PUSH
58775: LD_INT 0
58777: LESS
58778: IFFALSE 58795
// _y := _y * - 1 ;
58780: LD_ADDR_VAR 0 7
58784: PUSH
58785: LD_VAR 0 7
58789: PUSH
58790: LD_INT 1
58792: NEG
58793: MUL
58794: ST_TO_ADDR
// result := [ _x , _y ] ;
58795: LD_ADDR_VAR 0 5
58799: PUSH
58800: LD_VAR 0 6
58804: PUSH
58805: LD_VAR 0 7
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: ST_TO_ADDR
// end ;
58814: LD_VAR 0 5
58818: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
58819: LD_INT 0
58821: PPUSH
58822: PPUSH
58823: PPUSH
58824: PPUSH
// task := GetTaskList ( unit ) ;
58825: LD_ADDR_VAR 0 7
58829: PUSH
58830: LD_VAR 0 1
58834: PPUSH
58835: CALL_OW 437
58839: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58840: LD_VAR 0 7
58844: NOT
58845: IFFALSE 58864
58847: PUSH
58848: LD_VAR 0 1
58852: PPUSH
58853: LD_VAR 0 2
58857: PPUSH
58858: CALL_OW 308
58862: NOT
58863: AND
58864: IFFALSE 58868
// exit ;
58866: GO 58986
// if IsInArea ( unit , area ) then
58868: LD_VAR 0 1
58872: PPUSH
58873: LD_VAR 0 2
58877: PPUSH
58878: CALL_OW 308
58882: IFFALSE 58900
// begin ComMoveToArea ( unit , goAway ) ;
58884: LD_VAR 0 1
58888: PPUSH
58889: LD_VAR 0 3
58893: PPUSH
58894: CALL_OW 113
// exit ;
58898: GO 58986
// end ; if task [ 1 ] [ 1 ] <> M then
58900: LD_VAR 0 7
58904: PUSH
58905: LD_INT 1
58907: ARRAY
58908: PUSH
58909: LD_INT 1
58911: ARRAY
58912: PUSH
58913: LD_STRING M
58915: NONEQUAL
58916: IFFALSE 58920
// exit ;
58918: GO 58986
// x := task [ 1 ] [ 2 ] ;
58920: LD_ADDR_VAR 0 5
58924: PUSH
58925: LD_VAR 0 7
58929: PUSH
58930: LD_INT 1
58932: ARRAY
58933: PUSH
58934: LD_INT 2
58936: ARRAY
58937: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58938: LD_ADDR_VAR 0 6
58942: PUSH
58943: LD_VAR 0 7
58947: PUSH
58948: LD_INT 1
58950: ARRAY
58951: PUSH
58952: LD_INT 3
58954: ARRAY
58955: ST_TO_ADDR
// if InArea ( x , y , area ) then
58956: LD_VAR 0 5
58960: PPUSH
58961: LD_VAR 0 6
58965: PPUSH
58966: LD_VAR 0 2
58970: PPUSH
58971: CALL_OW 309
58975: IFFALSE 58986
// ComStop ( unit ) ;
58977: LD_VAR 0 1
58981: PPUSH
58982: CALL_OW 141
// end ;
58986: LD_VAR 0 4
58990: RET
// export function Abs ( value ) ; begin
58991: LD_INT 0
58993: PPUSH
// result := value ;
58994: LD_ADDR_VAR 0 2
58998: PUSH
58999: LD_VAR 0 1
59003: ST_TO_ADDR
// if value < 0 then
59004: LD_VAR 0 1
59008: PUSH
59009: LD_INT 0
59011: LESS
59012: IFFALSE 59029
// result := value * - 1 ;
59014: LD_ADDR_VAR 0 2
59018: PUSH
59019: LD_VAR 0 1
59023: PUSH
59024: LD_INT 1
59026: NEG
59027: MUL
59028: ST_TO_ADDR
// end ;
59029: LD_VAR 0 2
59033: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
59034: LD_INT 0
59036: PPUSH
59037: PPUSH
59038: PPUSH
59039: PPUSH
59040: PPUSH
59041: PPUSH
59042: PPUSH
59043: PPUSH
// if not unit or not building then
59044: LD_VAR 0 1
59048: NOT
59049: IFTRUE 59058
59051: PUSH
59052: LD_VAR 0 2
59056: NOT
59057: OR
59058: IFFALSE 59062
// exit ;
59060: GO 59290
// x := GetX ( building ) ;
59062: LD_ADDR_VAR 0 4
59066: PUSH
59067: LD_VAR 0 2
59071: PPUSH
59072: CALL_OW 250
59076: ST_TO_ADDR
// y := GetY ( building ) ;
59077: LD_ADDR_VAR 0 6
59081: PUSH
59082: LD_VAR 0 2
59086: PPUSH
59087: CALL_OW 251
59091: ST_TO_ADDR
// d := GetDir ( building ) ;
59092: LD_ADDR_VAR 0 8
59096: PUSH
59097: LD_VAR 0 2
59101: PPUSH
59102: CALL_OW 254
59106: ST_TO_ADDR
// r := 4 ;
59107: LD_ADDR_VAR 0 9
59111: PUSH
59112: LD_INT 4
59114: ST_TO_ADDR
// for i := 1 to 5 do
59115: LD_ADDR_VAR 0 10
59119: PUSH
59120: DOUBLE
59121: LD_INT 1
59123: DEC
59124: ST_TO_ADDR
59125: LD_INT 5
59127: PUSH
59128: FOR_TO
59129: IFFALSE 59288
// begin _x := ShiftX ( x , d , r + i ) ;
59131: LD_ADDR_VAR 0 5
59135: PUSH
59136: LD_VAR 0 4
59140: PPUSH
59141: LD_VAR 0 8
59145: PPUSH
59146: LD_VAR 0 9
59150: PUSH
59151: LD_VAR 0 10
59155: PLUS
59156: PPUSH
59157: CALL_OW 272
59161: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
59162: LD_ADDR_VAR 0 7
59166: PUSH
59167: LD_VAR 0 6
59171: PPUSH
59172: LD_VAR 0 8
59176: PPUSH
59177: LD_VAR 0 9
59181: PUSH
59182: LD_VAR 0 10
59186: PLUS
59187: PPUSH
59188: CALL_OW 273
59192: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
59193: LD_VAR 0 5
59197: PPUSH
59198: LD_VAR 0 7
59202: PPUSH
59203: CALL_OW 488
59207: IFFALSE 59242
59209: PUSH
59210: LD_VAR 0 5
59214: PPUSH
59215: LD_VAR 0 7
59219: PPUSH
59220: CALL_OW 428
59224: PPUSH
59225: CALL_OW 247
59229: PUSH
59230: LD_INT 3
59232: PUSH
59233: LD_INT 2
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: IN
59240: NOT
59241: AND
59242: IFFALSE 59286
// begin ComMoveXY ( unit , _x , _y ) ;
59244: LD_VAR 0 1
59248: PPUSH
59249: LD_VAR 0 5
59253: PPUSH
59254: LD_VAR 0 7
59258: PPUSH
59259: CALL_OW 111
// result := [ _x , _y ] ;
59263: LD_ADDR_VAR 0 3
59267: PUSH
59268: LD_VAR 0 5
59272: PUSH
59273: LD_VAR 0 7
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: ST_TO_ADDR
// exit ;
59282: POP
59283: POP
59284: GO 59290
// end ; end ;
59286: GO 59128
59288: POP
59289: POP
// end ;
59290: LD_VAR 0 3
59294: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
59295: LD_INT 0
59297: PPUSH
59298: PPUSH
59299: PPUSH
// result := 0 ;
59300: LD_ADDR_VAR 0 3
59304: PUSH
59305: LD_INT 0
59307: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
59308: LD_VAR 0 1
59312: PUSH
59313: LD_INT 0
59315: LESS
59316: IFTRUE 59328
59318: PUSH
59319: LD_VAR 0 1
59323: PUSH
59324: LD_INT 8
59326: GREATER
59327: OR
59328: IFTRUE 59340
59330: PUSH
59331: LD_VAR 0 2
59335: PUSH
59336: LD_INT 0
59338: LESS
59339: OR
59340: IFTRUE 59352
59342: PUSH
59343: LD_VAR 0 2
59347: PUSH
59348: LD_INT 8
59350: GREATER
59351: OR
59352: IFFALSE 59356
// exit ;
59354: GO 59431
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
59356: LD_ADDR_VAR 0 4
59360: PUSH
59361: LD_INT 22
59363: PUSH
59364: LD_VAR 0 2
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PPUSH
59373: CALL_OW 69
59377: PUSH
59378: FOR_IN
59379: IFFALSE 59429
// begin un := UnitShoot ( i ) ;
59381: LD_ADDR_VAR 0 5
59385: PUSH
59386: LD_VAR 0 4
59390: PPUSH
59391: CALL_OW 504
59395: ST_TO_ADDR
// if GetSide ( un ) = side1 then
59396: LD_VAR 0 5
59400: PPUSH
59401: CALL_OW 255
59405: PUSH
59406: LD_VAR 0 1
59410: EQUAL
59411: IFFALSE 59427
// begin result := un ;
59413: LD_ADDR_VAR 0 3
59417: PUSH
59418: LD_VAR 0 5
59422: ST_TO_ADDR
// exit ;
59423: POP
59424: POP
59425: GO 59431
// end ; end ;
59427: GO 59378
59429: POP
59430: POP
// end ;
59431: LD_VAR 0 3
59435: RET
// export function GetCargoBay ( units ) ; begin
59436: LD_INT 0
59438: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
59439: LD_ADDR_VAR 0 2
59443: PUSH
59444: LD_VAR 0 1
59448: PPUSH
59449: LD_INT 2
59451: PUSH
59452: LD_INT 34
59454: PUSH
59455: LD_INT 12
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: PUSH
59462: LD_INT 34
59464: PUSH
59465: LD_INT 51
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: PUSH
59472: LD_INT 34
59474: PUSH
59475: LD_INT 32
59477: PUSH
59478: EMPTY
59479: LIST
59480: LIST
59481: PUSH
59482: LD_INT 34
59484: PUSH
59485: LD_INT 89
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PUSH
59492: EMPTY
59493: LIST
59494: LIST
59495: LIST
59496: LIST
59497: LIST
59498: PPUSH
59499: CALL_OW 72
59503: ST_TO_ADDR
// end ;
59504: LD_VAR 0 2
59508: RET
// export function Negate ( value ) ; begin
59509: LD_INT 0
59511: PPUSH
// result := not value ;
59512: LD_ADDR_VAR 0 2
59516: PUSH
59517: LD_VAR 0 1
59521: NOT
59522: ST_TO_ADDR
// end ;
59523: LD_VAR 0 2
59527: RET
// export function Inc ( value ) ; begin
59528: LD_INT 0
59530: PPUSH
// result := value + 1 ;
59531: LD_ADDR_VAR 0 2
59535: PUSH
59536: LD_VAR 0 1
59540: PUSH
59541: LD_INT 1
59543: PLUS
59544: ST_TO_ADDR
// end ;
59545: LD_VAR 0 2
59549: RET
// export function Dec ( value ) ; begin
59550: LD_INT 0
59552: PPUSH
// result := value - 1 ;
59553: LD_ADDR_VAR 0 2
59557: PUSH
59558: LD_VAR 0 1
59562: PUSH
59563: LD_INT 1
59565: MINUS
59566: ST_TO_ADDR
// end ;
59567: LD_VAR 0 2
59571: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
59572: LD_INT 0
59574: PPUSH
59575: PPUSH
59576: PPUSH
59577: PPUSH
59578: PPUSH
59579: PPUSH
59580: PPUSH
59581: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
59582: LD_VAR 0 1
59586: PPUSH
59587: LD_VAR 0 2
59591: PPUSH
59592: CALL_OW 488
59596: NOT
59597: IFTRUE 59616
59599: PUSH
59600: LD_VAR 0 3
59604: PPUSH
59605: LD_VAR 0 4
59609: PPUSH
59610: CALL_OW 488
59614: NOT
59615: OR
59616: IFFALSE 59629
// begin result := - 1 ;
59618: LD_ADDR_VAR 0 5
59622: PUSH
59623: LD_INT 1
59625: NEG
59626: ST_TO_ADDR
// exit ;
59627: GO 59864
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
59629: LD_ADDR_VAR 0 12
59633: PUSH
59634: LD_VAR 0 1
59638: PPUSH
59639: LD_VAR 0 2
59643: PPUSH
59644: LD_VAR 0 3
59648: PPUSH
59649: LD_VAR 0 4
59653: PPUSH
59654: CALL 58700 0 4
59658: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
59659: LD_ADDR_VAR 0 11
59663: PUSH
59664: LD_VAR 0 1
59668: PPUSH
59669: LD_VAR 0 2
59673: PPUSH
59674: LD_VAR 0 12
59678: PUSH
59679: LD_INT 1
59681: ARRAY
59682: PPUSH
59683: LD_VAR 0 12
59687: PUSH
59688: LD_INT 2
59690: ARRAY
59691: PPUSH
59692: CALL_OW 298
59696: ST_TO_ADDR
// distance := 9999 ;
59697: LD_ADDR_VAR 0 10
59701: PUSH
59702: LD_INT 9999
59704: ST_TO_ADDR
// for i := 0 to 5 do
59705: LD_ADDR_VAR 0 6
59709: PUSH
59710: DOUBLE
59711: LD_INT 0
59713: DEC
59714: ST_TO_ADDR
59715: LD_INT 5
59717: PUSH
59718: FOR_TO
59719: IFFALSE 59862
// begin _x := ShiftX ( x1 , i , centerDist ) ;
59721: LD_ADDR_VAR 0 7
59725: PUSH
59726: LD_VAR 0 1
59730: PPUSH
59731: LD_VAR 0 6
59735: PPUSH
59736: LD_VAR 0 11
59740: PPUSH
59741: CALL_OW 272
59745: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
59746: LD_ADDR_VAR 0 8
59750: PUSH
59751: LD_VAR 0 2
59755: PPUSH
59756: LD_VAR 0 6
59760: PPUSH
59761: LD_VAR 0 11
59765: PPUSH
59766: CALL_OW 273
59770: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59771: LD_VAR 0 7
59775: PPUSH
59776: LD_VAR 0 8
59780: PPUSH
59781: CALL_OW 488
59785: NOT
59786: IFFALSE 59790
// continue ;
59788: GO 59718
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
59790: LD_ADDR_VAR 0 9
59794: PUSH
59795: LD_VAR 0 12
59799: PUSH
59800: LD_INT 1
59802: ARRAY
59803: PPUSH
59804: LD_VAR 0 12
59808: PUSH
59809: LD_INT 2
59811: ARRAY
59812: PPUSH
59813: LD_VAR 0 7
59817: PPUSH
59818: LD_VAR 0 8
59822: PPUSH
59823: CALL_OW 298
59827: ST_TO_ADDR
// if tmp < distance then
59828: LD_VAR 0 9
59832: PUSH
59833: LD_VAR 0 10
59837: LESS
59838: IFFALSE 59860
// begin result := i ;
59840: LD_ADDR_VAR 0 5
59844: PUSH
59845: LD_VAR 0 6
59849: ST_TO_ADDR
// distance := tmp ;
59850: LD_ADDR_VAR 0 10
59854: PUSH
59855: LD_VAR 0 9
59859: ST_TO_ADDR
// end ; end ;
59860: GO 59718
59862: POP
59863: POP
// end ;
59864: LD_VAR 0 5
59868: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59869: LD_INT 0
59871: PPUSH
59872: PPUSH
// if not driver or not IsInUnit ( driver ) then
59873: LD_VAR 0 1
59877: NOT
59878: IFTRUE 59892
59880: PUSH
59881: LD_VAR 0 1
59885: PPUSH
59886: CALL_OW 310
59890: NOT
59891: OR
59892: IFFALSE 59896
// exit ;
59894: GO 59986
// vehicle := IsInUnit ( driver ) ;
59896: LD_ADDR_VAR 0 3
59900: PUSH
59901: LD_VAR 0 1
59905: PPUSH
59906: CALL_OW 310
59910: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59911: LD_VAR 0 1
59915: PPUSH
59916: LD_STRING \
59918: PUSH
59919: LD_INT 0
59921: PUSH
59922: LD_INT 0
59924: PUSH
59925: LD_INT 0
59927: PUSH
59928: LD_INT 0
59930: PUSH
59931: LD_INT 0
59933: PUSH
59934: LD_INT 0
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: LIST
59941: LIST
59942: LIST
59943: LIST
59944: LIST
59945: PUSH
59946: LD_STRING E
59948: PUSH
59949: LD_INT 0
59951: PUSH
59952: LD_INT 0
59954: PUSH
59955: LD_VAR 0 3
59959: PUSH
59960: LD_INT 0
59962: PUSH
59963: LD_INT 0
59965: PUSH
59966: LD_INT 0
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: LIST
59973: LIST
59974: LIST
59975: LIST
59976: LIST
59977: PUSH
59978: EMPTY
59979: LIST
59980: LIST
59981: PPUSH
59982: CALL_OW 446
// end ;
59986: LD_VAR 0 2
59990: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59991: LD_INT 0
59993: PPUSH
59994: PPUSH
// if not driver or not IsInUnit ( driver ) then
59995: LD_VAR 0 1
59999: NOT
60000: IFTRUE 60014
60002: PUSH
60003: LD_VAR 0 1
60007: PPUSH
60008: CALL_OW 310
60012: NOT
60013: OR
60014: IFFALSE 60018
// exit ;
60016: GO 60108
// vehicle := IsInUnit ( driver ) ;
60018: LD_ADDR_VAR 0 3
60022: PUSH
60023: LD_VAR 0 1
60027: PPUSH
60028: CALL_OW 310
60032: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
60033: LD_VAR 0 1
60037: PPUSH
60038: LD_STRING \
60040: PUSH
60041: LD_INT 0
60043: PUSH
60044: LD_INT 0
60046: PUSH
60047: LD_INT 0
60049: PUSH
60050: LD_INT 0
60052: PUSH
60053: LD_INT 0
60055: PUSH
60056: LD_INT 0
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: LIST
60063: LIST
60064: LIST
60065: LIST
60066: LIST
60067: PUSH
60068: LD_STRING E
60070: PUSH
60071: LD_INT 0
60073: PUSH
60074: LD_INT 0
60076: PUSH
60077: LD_VAR 0 3
60081: PUSH
60082: LD_INT 0
60084: PUSH
60085: LD_INT 0
60087: PUSH
60088: LD_INT 0
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: LIST
60095: LIST
60096: LIST
60097: LIST
60098: LIST
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PPUSH
60104: CALL_OW 447
// end ;
60108: LD_VAR 0 2
60112: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
60113: LD_INT 0
60115: PPUSH
60116: PPUSH
60117: PPUSH
// tmp := [ ] ;
60118: LD_ADDR_VAR 0 5
60122: PUSH
60123: EMPTY
60124: ST_TO_ADDR
// for i in units do
60125: LD_ADDR_VAR 0 4
60129: PUSH
60130: LD_VAR 0 1
60134: PUSH
60135: FOR_IN
60136: IFFALSE 60174
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
60138: LD_ADDR_VAR 0 5
60142: PUSH
60143: LD_VAR 0 5
60147: PPUSH
60148: LD_VAR 0 5
60152: PUSH
60153: LD_INT 1
60155: PLUS
60156: PPUSH
60157: LD_VAR 0 4
60161: PPUSH
60162: CALL_OW 256
60166: PPUSH
60167: CALL_OW 2
60171: ST_TO_ADDR
60172: GO 60135
60174: POP
60175: POP
// if not tmp then
60176: LD_VAR 0 5
60180: NOT
60181: IFFALSE 60185
// exit ;
60183: GO 60233
// if asc then
60185: LD_VAR 0 2
60189: IFFALSE 60213
// result := SortListByListAsc ( units , tmp ) else
60191: LD_ADDR_VAR 0 3
60195: PUSH
60196: LD_VAR 0 1
60200: PPUSH
60201: LD_VAR 0 5
60205: PPUSH
60206: CALL_OW 76
60210: ST_TO_ADDR
60211: GO 60233
// result := SortListByListDesc ( units , tmp ) ;
60213: LD_ADDR_VAR 0 3
60217: PUSH
60218: LD_VAR 0 1
60222: PPUSH
60223: LD_VAR 0 5
60227: PPUSH
60228: CALL_OW 77
60232: ST_TO_ADDR
// end ;
60233: LD_VAR 0 3
60237: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
60238: LD_INT 0
60240: PPUSH
60241: PPUSH
// task := GetTaskList ( mech ) ;
60242: LD_ADDR_VAR 0 4
60246: PUSH
60247: LD_VAR 0 1
60251: PPUSH
60252: CALL_OW 437
60256: ST_TO_ADDR
// if not task then
60257: LD_VAR 0 4
60261: NOT
60262: IFFALSE 60266
// exit ;
60264: GO 60310
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
60266: LD_ADDR_VAR 0 3
60270: PUSH
60271: LD_VAR 0 4
60275: PUSH
60276: LD_INT 1
60278: ARRAY
60279: PUSH
60280: LD_INT 1
60282: ARRAY
60283: PUSH
60284: LD_STRING r
60286: EQUAL
60287: IFFALSE 60309
60289: PUSH
60290: LD_VAR 0 4
60294: PUSH
60295: LD_INT 1
60297: ARRAY
60298: PUSH
60299: LD_INT 4
60301: ARRAY
60302: PUSH
60303: LD_VAR 0 2
60307: EQUAL
60308: AND
60309: ST_TO_ADDR
// end ;
60310: LD_VAR 0 3
60314: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
60315: LD_INT 0
60317: PPUSH
// SetDir ( unit , d ) ;
60318: LD_VAR 0 1
60322: PPUSH
60323: LD_VAR 0 4
60327: PPUSH
60328: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
60332: LD_ADDR_VAR 0 6
60336: PUSH
60337: LD_VAR 0 1
60341: PPUSH
60342: LD_VAR 0 2
60346: PPUSH
60347: LD_VAR 0 3
60351: PPUSH
60352: LD_VAR 0 5
60356: PPUSH
60357: CALL_OW 48
60361: ST_TO_ADDR
// end ;
60362: LD_VAR 0 6
60366: RET
// export function ToNaturalNumber ( number ) ; begin
60367: LD_INT 0
60369: PPUSH
// result := number div 1 ;
60370: LD_ADDR_VAR 0 2
60374: PUSH
60375: LD_VAR 0 1
60379: PUSH
60380: LD_INT 1
60382: DIV
60383: ST_TO_ADDR
// if number < 0 then
60384: LD_VAR 0 1
60388: PUSH
60389: LD_INT 0
60391: LESS
60392: IFFALSE 60402
// result := 0 ;
60394: LD_ADDR_VAR 0 2
60398: PUSH
60399: LD_INT 0
60401: ST_TO_ADDR
// end ;
60402: LD_VAR 0 2
60406: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
60407: LD_INT 0
60409: PPUSH
60410: PPUSH
60411: PPUSH
// if not buildings then
60412: LD_VAR 0 1
60416: NOT
60417: IFFALSE 60421
// exit ;
60419: GO 60536
// tmp := [ ] ;
60421: LD_ADDR_VAR 0 5
60425: PUSH
60426: EMPTY
60427: ST_TO_ADDR
// for b in buildings do
60428: LD_ADDR_VAR 0 4
60432: PUSH
60433: LD_VAR 0 1
60437: PUSH
60438: FOR_IN
60439: IFFALSE 60477
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
60441: LD_ADDR_VAR 0 5
60445: PUSH
60446: LD_VAR 0 5
60450: PPUSH
60451: LD_VAR 0 5
60455: PUSH
60456: LD_INT 1
60458: PLUS
60459: PPUSH
60460: LD_VAR 0 4
60464: PPUSH
60465: CALL_OW 266
60469: PPUSH
60470: CALL_OW 1
60474: ST_TO_ADDR
60475: GO 60438
60477: POP
60478: POP
// if not tmp then
60479: LD_VAR 0 5
60483: NOT
60484: IFFALSE 60488
// exit ;
60486: GO 60536
// if asc then
60488: LD_VAR 0 2
60492: IFFALSE 60516
// result := SortListByListAsc ( buildings , tmp ) else
60494: LD_ADDR_VAR 0 3
60498: PUSH
60499: LD_VAR 0 1
60503: PPUSH
60504: LD_VAR 0 5
60508: PPUSH
60509: CALL_OW 76
60513: ST_TO_ADDR
60514: GO 60536
// result := SortListByListDesc ( buildings , tmp ) ;
60516: LD_ADDR_VAR 0 3
60520: PUSH
60521: LD_VAR 0 1
60525: PPUSH
60526: LD_VAR 0 5
60530: PPUSH
60531: CALL_OW 77
60535: ST_TO_ADDR
// end ;
60536: LD_VAR 0 3
60540: RET
// export function SortByClass ( units , class ) ; var un ; begin
60541: LD_INT 0
60543: PPUSH
60544: PPUSH
// if not units or not class then
60545: LD_VAR 0 1
60549: NOT
60550: IFTRUE 60559
60552: PUSH
60553: LD_VAR 0 2
60557: NOT
60558: OR
60559: IFFALSE 60563
// exit ;
60561: GO 60658
// result := [ ] ;
60563: LD_ADDR_VAR 0 3
60567: PUSH
60568: EMPTY
60569: ST_TO_ADDR
// for un in units do
60570: LD_ADDR_VAR 0 4
60574: PUSH
60575: LD_VAR 0 1
60579: PUSH
60580: FOR_IN
60581: IFFALSE 60656
// if GetClass ( un ) = class then
60583: LD_VAR 0 4
60587: PPUSH
60588: CALL_OW 257
60592: PUSH
60593: LD_VAR 0 2
60597: EQUAL
60598: IFFALSE 60625
// result := Insert ( result , 1 , un ) else
60600: LD_ADDR_VAR 0 3
60604: PUSH
60605: LD_VAR 0 3
60609: PPUSH
60610: LD_INT 1
60612: PPUSH
60613: LD_VAR 0 4
60617: PPUSH
60618: CALL_OW 2
60622: ST_TO_ADDR
60623: GO 60654
// result := Replace ( result , result + 1 , un ) ;
60625: LD_ADDR_VAR 0 3
60629: PUSH
60630: LD_VAR 0 3
60634: PPUSH
60635: LD_VAR 0 3
60639: PUSH
60640: LD_INT 1
60642: PLUS
60643: PPUSH
60644: LD_VAR 0 4
60648: PPUSH
60649: CALL_OW 1
60653: ST_TO_ADDR
60654: GO 60580
60656: POP
60657: POP
// end ;
60658: LD_VAR 0 3
60662: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
60663: LD_INT 0
60665: PPUSH
60666: PPUSH
60667: PPUSH
60668: PPUSH
60669: PPUSH
60670: PPUSH
60671: PPUSH
// result := [ ] ;
60672: LD_ADDR_VAR 0 4
60676: PUSH
60677: EMPTY
60678: ST_TO_ADDR
// if x - r < 0 then
60679: LD_VAR 0 1
60683: PUSH
60684: LD_VAR 0 3
60688: MINUS
60689: PUSH
60690: LD_INT 0
60692: LESS
60693: IFFALSE 60705
// min_x := 0 else
60695: LD_ADDR_VAR 0 8
60699: PUSH
60700: LD_INT 0
60702: ST_TO_ADDR
60703: GO 60721
// min_x := x - r ;
60705: LD_ADDR_VAR 0 8
60709: PUSH
60710: LD_VAR 0 1
60714: PUSH
60715: LD_VAR 0 3
60719: MINUS
60720: ST_TO_ADDR
// if y - r < 0 then
60721: LD_VAR 0 2
60725: PUSH
60726: LD_VAR 0 3
60730: MINUS
60731: PUSH
60732: LD_INT 0
60734: LESS
60735: IFFALSE 60747
// min_y := 0 else
60737: LD_ADDR_VAR 0 7
60741: PUSH
60742: LD_INT 0
60744: ST_TO_ADDR
60745: GO 60763
// min_y := y - r ;
60747: LD_ADDR_VAR 0 7
60751: PUSH
60752: LD_VAR 0 2
60756: PUSH
60757: LD_VAR 0 3
60761: MINUS
60762: ST_TO_ADDR
// max_x := x + r ;
60763: LD_ADDR_VAR 0 9
60767: PUSH
60768: LD_VAR 0 1
60772: PUSH
60773: LD_VAR 0 3
60777: PLUS
60778: ST_TO_ADDR
// max_y := y + r ;
60779: LD_ADDR_VAR 0 10
60783: PUSH
60784: LD_VAR 0 2
60788: PUSH
60789: LD_VAR 0 3
60793: PLUS
60794: ST_TO_ADDR
// for _x = min_x to max_x do
60795: LD_ADDR_VAR 0 5
60799: PUSH
60800: DOUBLE
60801: LD_VAR 0 8
60805: DEC
60806: ST_TO_ADDR
60807: LD_VAR 0 9
60811: PUSH
60812: FOR_TO
60813: IFFALSE 60914
// for _y = min_y to max_y do
60815: LD_ADDR_VAR 0 6
60819: PUSH
60820: DOUBLE
60821: LD_VAR 0 7
60825: DEC
60826: ST_TO_ADDR
60827: LD_VAR 0 10
60831: PUSH
60832: FOR_TO
60833: IFFALSE 60910
// begin if not ValidHex ( _x , _y ) then
60835: LD_VAR 0 5
60839: PPUSH
60840: LD_VAR 0 6
60844: PPUSH
60845: CALL_OW 488
60849: NOT
60850: IFFALSE 60854
// continue ;
60852: GO 60832
// if GetResourceTypeXY ( _x , _y ) then
60854: LD_VAR 0 5
60858: PPUSH
60859: LD_VAR 0 6
60863: PPUSH
60864: CALL_OW 283
60868: IFFALSE 60908
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
60870: LD_ADDR_VAR 0 4
60874: PUSH
60875: LD_VAR 0 4
60879: PPUSH
60880: LD_VAR 0 4
60884: PUSH
60885: LD_INT 1
60887: PLUS
60888: PPUSH
60889: LD_VAR 0 5
60893: PUSH
60894: LD_VAR 0 6
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PPUSH
60903: CALL_OW 1
60907: ST_TO_ADDR
// end ;
60908: GO 60832
60910: POP
60911: POP
60912: GO 60812
60914: POP
60915: POP
// end ;
60916: LD_VAR 0 4
60920: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
60921: LD_INT 0
60923: PPUSH
60924: PPUSH
60925: PPUSH
60926: PPUSH
60927: PPUSH
60928: PPUSH
60929: PPUSH
60930: PPUSH
// if not units then
60931: LD_VAR 0 1
60935: NOT
60936: IFFALSE 60940
// exit ;
60938: GO 61472
// result := UnitFilter ( units , [ f_ok ] ) ;
60940: LD_ADDR_VAR 0 3
60944: PUSH
60945: LD_VAR 0 1
60949: PPUSH
60950: LD_INT 50
60952: PUSH
60953: EMPTY
60954: LIST
60955: PPUSH
60956: CALL_OW 72
60960: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
60961: LD_ADDR_VAR 0 8
60965: PUSH
60966: LD_VAR 0 1
60970: PUSH
60971: LD_INT 1
60973: ARRAY
60974: PPUSH
60975: CALL_OW 255
60979: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
60980: LD_ADDR_VAR 0 10
60984: PUSH
60985: LD_INT 29
60987: PUSH
60988: LD_INT 91
60990: PUSH
60991: LD_INT 49
60993: PUSH
60994: EMPTY
60995: LIST
60996: LIST
60997: LIST
60998: ST_TO_ADDR
// if not result then
60999: LD_VAR 0 3
61003: NOT
61004: IFFALSE 61008
// exit ;
61006: GO 61472
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
61008: LD_ADDR_VAR 0 5
61012: PUSH
61013: LD_INT 81
61015: PUSH
61016: LD_VAR 0 8
61020: PUSH
61021: EMPTY
61022: LIST
61023: LIST
61024: PPUSH
61025: CALL_OW 69
61029: ST_TO_ADDR
// for i in result do
61030: LD_ADDR_VAR 0 4
61034: PUSH
61035: LD_VAR 0 3
61039: PUSH
61040: FOR_IN
61041: IFFALSE 61470
// begin tag := GetTag ( i ) + 1 ;
61043: LD_ADDR_VAR 0 9
61047: PUSH
61048: LD_VAR 0 4
61052: PPUSH
61053: CALL_OW 110
61057: PUSH
61058: LD_INT 1
61060: PLUS
61061: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
61062: LD_ADDR_VAR 0 7
61066: PUSH
61067: LD_VAR 0 4
61071: PPUSH
61072: CALL_OW 250
61076: PPUSH
61077: LD_VAR 0 4
61081: PPUSH
61082: CALL_OW 251
61086: PPUSH
61087: LD_INT 4
61089: PPUSH
61090: CALL 60663 0 3
61094: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
61095: LD_VAR 0 4
61099: PPUSH
61100: CALL_OW 247
61104: PUSH
61105: LD_INT 2
61107: EQUAL
61108: IFFALSE 61120
61110: PUSH
61111: LD_VAR 0 7
61115: PUSH
61116: LD_INT 2
61118: GREATER
61119: AND
61120: IFFALSE 61140
61122: PUSH
61123: LD_VAR 0 4
61127: PPUSH
61128: CALL_OW 264
61132: PUSH
61133: LD_VAR 0 10
61137: IN
61138: NOT
61139: AND
61140: IFFALSE 61179
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
61142: LD_VAR 0 4
61146: PPUSH
61147: LD_VAR 0 7
61151: PUSH
61152: LD_INT 1
61154: ARRAY
61155: PUSH
61156: LD_INT 1
61158: ARRAY
61159: PPUSH
61160: LD_VAR 0 7
61164: PUSH
61165: LD_INT 1
61167: ARRAY
61168: PUSH
61169: LD_INT 2
61171: ARRAY
61172: PPUSH
61173: CALL_OW 116
61177: GO 61468
// if path > tag then
61179: LD_VAR 0 2
61183: PUSH
61184: LD_VAR 0 9
61188: GREATER
61189: IFFALSE 61397
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
61191: LD_ADDR_VAR 0 6
61195: PUSH
61196: LD_VAR 0 5
61200: PPUSH
61201: LD_INT 91
61203: PUSH
61204: LD_VAR 0 4
61208: PUSH
61209: LD_INT 8
61211: PUSH
61212: EMPTY
61213: LIST
61214: LIST
61215: LIST
61216: PPUSH
61217: CALL_OW 72
61221: ST_TO_ADDR
// if nearEnemy then
61222: LD_VAR 0 6
61226: IFFALSE 61295
// begin if GetWeapon ( i ) = ru_time_lapser then
61228: LD_VAR 0 4
61232: PPUSH
61233: CALL_OW 264
61237: PUSH
61238: LD_INT 49
61240: EQUAL
61241: IFFALSE 61269
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
61243: LD_VAR 0 4
61247: PPUSH
61248: LD_VAR 0 6
61252: PPUSH
61253: LD_VAR 0 4
61257: PPUSH
61258: CALL_OW 74
61262: PPUSH
61263: CALL_OW 112
61267: GO 61293
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
61269: LD_VAR 0 4
61273: PPUSH
61274: LD_VAR 0 6
61278: PPUSH
61279: LD_VAR 0 4
61283: PPUSH
61284: CALL_OW 74
61288: PPUSH
61289: CALL 62553 0 2
// end else
61293: GO 61395
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
61295: LD_VAR 0 4
61299: PPUSH
61300: LD_VAR 0 2
61304: PUSH
61305: LD_VAR 0 9
61309: ARRAY
61310: PUSH
61311: LD_INT 1
61313: ARRAY
61314: PPUSH
61315: LD_VAR 0 2
61319: PUSH
61320: LD_VAR 0 9
61324: ARRAY
61325: PUSH
61326: LD_INT 2
61328: ARRAY
61329: PPUSH
61330: CALL_OW 297
61334: PUSH
61335: LD_INT 6
61337: GREATER
61338: IFFALSE 61381
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
61340: LD_VAR 0 4
61344: PPUSH
61345: LD_VAR 0 2
61349: PUSH
61350: LD_VAR 0 9
61354: ARRAY
61355: PUSH
61356: LD_INT 1
61358: ARRAY
61359: PPUSH
61360: LD_VAR 0 2
61364: PUSH
61365: LD_VAR 0 9
61369: ARRAY
61370: PUSH
61371: LD_INT 2
61373: ARRAY
61374: PPUSH
61375: CALL_OW 114
61379: GO 61395
// SetTag ( i , tag ) ;
61381: LD_VAR 0 4
61385: PPUSH
61386: LD_VAR 0 9
61390: PPUSH
61391: CALL_OW 109
// end else
61395: GO 61468
// if enemy then
61397: LD_VAR 0 5
61401: IFFALSE 61468
// begin if GetWeapon ( i ) = ru_time_lapser then
61403: LD_VAR 0 4
61407: PPUSH
61408: CALL_OW 264
61412: PUSH
61413: LD_INT 49
61415: EQUAL
61416: IFFALSE 61444
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
61418: LD_VAR 0 4
61422: PPUSH
61423: LD_VAR 0 5
61427: PPUSH
61428: LD_VAR 0 4
61432: PPUSH
61433: CALL_OW 74
61437: PPUSH
61438: CALL_OW 112
61442: GO 61468
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
61444: LD_VAR 0 4
61448: PPUSH
61449: LD_VAR 0 5
61453: PPUSH
61454: LD_VAR 0 4
61458: PPUSH
61459: CALL_OW 74
61463: PPUSH
61464: CALL 62553 0 2
// end ; end ;
61468: GO 61040
61470: POP
61471: POP
// end ;
61472: LD_VAR 0 3
61476: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
61477: LD_INT 0
61479: PPUSH
61480: PPUSH
61481: PPUSH
// if not unit or IsInUnit ( unit ) then
61482: LD_VAR 0 1
61486: NOT
61487: IFTRUE 61500
61489: PUSH
61490: LD_VAR 0 1
61494: PPUSH
61495: CALL_OW 310
61499: OR
61500: IFFALSE 61504
// exit ;
61502: GO 61595
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
61504: LD_ADDR_VAR 0 4
61508: PUSH
61509: LD_VAR 0 1
61513: PPUSH
61514: CALL_OW 250
61518: PPUSH
61519: LD_VAR 0 2
61523: PPUSH
61524: LD_INT 1
61526: PPUSH
61527: CALL_OW 272
61531: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
61532: LD_ADDR_VAR 0 5
61536: PUSH
61537: LD_VAR 0 1
61541: PPUSH
61542: CALL_OW 251
61546: PPUSH
61547: LD_VAR 0 2
61551: PPUSH
61552: LD_INT 1
61554: PPUSH
61555: CALL_OW 273
61559: ST_TO_ADDR
// if ValidHex ( x , y ) then
61560: LD_VAR 0 4
61564: PPUSH
61565: LD_VAR 0 5
61569: PPUSH
61570: CALL_OW 488
61574: IFFALSE 61595
// ComTurnXY ( unit , x , y ) ;
61576: LD_VAR 0 1
61580: PPUSH
61581: LD_VAR 0 4
61585: PPUSH
61586: LD_VAR 0 5
61590: PPUSH
61591: CALL_OW 118
// end ;
61595: LD_VAR 0 3
61599: RET
// export function SeeUnits ( side , units ) ; var i ; begin
61600: LD_INT 0
61602: PPUSH
61603: PPUSH
// result := false ;
61604: LD_ADDR_VAR 0 3
61608: PUSH
61609: LD_INT 0
61611: ST_TO_ADDR
// if not units then
61612: LD_VAR 0 2
61616: NOT
61617: IFFALSE 61621
// exit ;
61619: GO 61666
// for i in units do
61621: LD_ADDR_VAR 0 4
61625: PUSH
61626: LD_VAR 0 2
61630: PUSH
61631: FOR_IN
61632: IFFALSE 61664
// if See ( side , i ) then
61634: LD_VAR 0 1
61638: PPUSH
61639: LD_VAR 0 4
61643: PPUSH
61644: CALL_OW 292
61648: IFFALSE 61662
// begin result := true ;
61650: LD_ADDR_VAR 0 3
61654: PUSH
61655: LD_INT 1
61657: ST_TO_ADDR
// exit ;
61658: POP
61659: POP
61660: GO 61666
// end ;
61662: GO 61631
61664: POP
61665: POP
// end ;
61666: LD_VAR 0 3
61670: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
61671: LD_INT 0
61673: PPUSH
61674: PPUSH
61675: PPUSH
61676: PPUSH
// if not unit or not points then
61677: LD_VAR 0 1
61681: NOT
61682: IFTRUE 61691
61684: PUSH
61685: LD_VAR 0 2
61689: NOT
61690: OR
61691: IFFALSE 61695
// exit ;
61693: GO 61785
// dist := 99999 ;
61695: LD_ADDR_VAR 0 5
61699: PUSH
61700: LD_INT 99999
61702: ST_TO_ADDR
// for i in points do
61703: LD_ADDR_VAR 0 4
61707: PUSH
61708: LD_VAR 0 2
61712: PUSH
61713: FOR_IN
61714: IFFALSE 61783
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
61716: LD_ADDR_VAR 0 6
61720: PUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: LD_VAR 0 4
61730: PUSH
61731: LD_INT 1
61733: ARRAY
61734: PPUSH
61735: LD_VAR 0 4
61739: PUSH
61740: LD_INT 2
61742: ARRAY
61743: PPUSH
61744: CALL_OW 297
61748: ST_TO_ADDR
// if tmpDist < dist then
61749: LD_VAR 0 6
61753: PUSH
61754: LD_VAR 0 5
61758: LESS
61759: IFFALSE 61781
// begin result := i ;
61761: LD_ADDR_VAR 0 3
61765: PUSH
61766: LD_VAR 0 4
61770: ST_TO_ADDR
// dist := tmpDist ;
61771: LD_ADDR_VAR 0 5
61775: PUSH
61776: LD_VAR 0 6
61780: ST_TO_ADDR
// end ; end ;
61781: GO 61713
61783: POP
61784: POP
// end ;
61785: LD_VAR 0 3
61789: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
61790: LD_INT 0
61792: PPUSH
// uc_side := side ;
61793: LD_ADDR_OWVAR 20
61797: PUSH
61798: LD_VAR 0 1
61802: ST_TO_ADDR
// uc_nation := 3 ;
61803: LD_ADDR_OWVAR 21
61807: PUSH
61808: LD_INT 3
61810: ST_TO_ADDR
// vc_chassis := 25 ;
61811: LD_ADDR_OWVAR 37
61815: PUSH
61816: LD_INT 25
61818: ST_TO_ADDR
// vc_engine := engine_siberite ;
61819: LD_ADDR_OWVAR 39
61823: PUSH
61824: LD_INT 3
61826: ST_TO_ADDR
// vc_control := control_computer ;
61827: LD_ADDR_OWVAR 38
61831: PUSH
61832: LD_INT 3
61834: ST_TO_ADDR
// vc_weapon := 59 ;
61835: LD_ADDR_OWVAR 40
61839: PUSH
61840: LD_INT 59
61842: ST_TO_ADDR
// result := CreateVehicle ;
61843: LD_ADDR_VAR 0 5
61847: PUSH
61848: CALL_OW 45
61852: ST_TO_ADDR
// SetDir ( result , d ) ;
61853: LD_VAR 0 5
61857: PPUSH
61858: LD_VAR 0 4
61862: PPUSH
61863: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
61867: LD_VAR 0 5
61871: PPUSH
61872: LD_VAR 0 2
61876: PPUSH
61877: LD_VAR 0 3
61881: PPUSH
61882: LD_INT 0
61884: PPUSH
61885: CALL_OW 48
// end ;
61889: LD_VAR 0 5
61893: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
61894: LD_INT 0
61896: PPUSH
61897: PPUSH
61898: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
61899: LD_ADDR_VAR 0 2
61903: PUSH
61904: LD_INT 0
61906: PUSH
61907: LD_INT 0
61909: PUSH
61910: LD_INT 0
61912: PUSH
61913: LD_INT 0
61915: PUSH
61916: EMPTY
61917: LIST
61918: LIST
61919: LIST
61920: LIST
61921: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
61922: LD_VAR 0 1
61926: NOT
61927: IFTRUE 61960
61929: PUSH
61930: LD_VAR 0 1
61934: PPUSH
61935: CALL_OW 264
61939: PUSH
61940: LD_INT 12
61942: PUSH
61943: LD_INT 51
61945: PUSH
61946: LD_INT 32
61948: PUSH
61949: LD_INT 89
61951: PUSH
61952: EMPTY
61953: LIST
61954: LIST
61955: LIST
61956: LIST
61957: IN
61958: NOT
61959: OR
61960: IFFALSE 61964
// exit ;
61962: GO 62062
// for i := 1 to 3 do
61964: LD_ADDR_VAR 0 3
61968: PUSH
61969: DOUBLE
61970: LD_INT 1
61972: DEC
61973: ST_TO_ADDR
61974: LD_INT 3
61976: PUSH
61977: FOR_TO
61978: IFFALSE 62060
// begin tmp := GetCargo ( cargo , i ) ;
61980: LD_ADDR_VAR 0 4
61984: PUSH
61985: LD_VAR 0 1
61989: PPUSH
61990: LD_VAR 0 3
61994: PPUSH
61995: CALL_OW 289
61999: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
62000: LD_ADDR_VAR 0 2
62004: PUSH
62005: LD_VAR 0 2
62009: PPUSH
62010: LD_VAR 0 3
62014: PPUSH
62015: LD_VAR 0 4
62019: PPUSH
62020: CALL_OW 1
62024: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
62025: LD_ADDR_VAR 0 2
62029: PUSH
62030: LD_VAR 0 2
62034: PPUSH
62035: LD_INT 4
62037: PPUSH
62038: LD_VAR 0 2
62042: PUSH
62043: LD_INT 4
62045: ARRAY
62046: PUSH
62047: LD_VAR 0 4
62051: PLUS
62052: PPUSH
62053: CALL_OW 1
62057: ST_TO_ADDR
// end ;
62058: GO 61977
62060: POP
62061: POP
// end ;
62062: LD_VAR 0 2
62066: RET
// export function Length ( array ) ; begin
62067: LD_INT 0
62069: PPUSH
// result := array + 0 ;
62070: LD_ADDR_VAR 0 2
62074: PUSH
62075: LD_VAR 0 1
62079: PUSH
62080: LD_INT 0
62082: PLUS
62083: ST_TO_ADDR
// end ;
62084: LD_VAR 0 2
62088: RET
// export function PrepareArray ( array ) ; begin
62089: LD_INT 0
62091: PPUSH
// result := array diff 0 ;
62092: LD_ADDR_VAR 0 2
62096: PUSH
62097: LD_VAR 0 1
62101: PUSH
62102: LD_INT 0
62104: DIFF
62105: ST_TO_ADDR
// if not result [ 1 ] then
62106: LD_VAR 0 2
62110: PUSH
62111: LD_INT 1
62113: ARRAY
62114: NOT
62115: IFFALSE 62135
// result := Delete ( result , 1 ) ;
62117: LD_ADDR_VAR 0 2
62121: PUSH
62122: LD_VAR 0 2
62126: PPUSH
62127: LD_INT 1
62129: PPUSH
62130: CALL_OW 3
62134: ST_TO_ADDR
// end ;
62135: LD_VAR 0 2
62139: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
62140: LD_INT 0
62142: PPUSH
62143: PPUSH
62144: PPUSH
62145: PPUSH
// sibRocketRange := 25 ;
62146: LD_ADDR_VAR 0 6
62150: PUSH
62151: LD_INT 25
62153: ST_TO_ADDR
// result := false ;
62154: LD_ADDR_VAR 0 4
62158: PUSH
62159: LD_INT 0
62161: ST_TO_ADDR
// for i := 0 to 5 do
62162: LD_ADDR_VAR 0 5
62166: PUSH
62167: DOUBLE
62168: LD_INT 0
62170: DEC
62171: ST_TO_ADDR
62172: LD_INT 5
62174: PUSH
62175: FOR_TO
62176: IFFALSE 62243
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
62178: LD_VAR 0 1
62182: PPUSH
62183: LD_VAR 0 5
62187: PPUSH
62188: LD_VAR 0 6
62192: PPUSH
62193: CALL_OW 272
62197: PPUSH
62198: LD_VAR 0 2
62202: PPUSH
62203: LD_VAR 0 5
62207: PPUSH
62208: LD_VAR 0 6
62212: PPUSH
62213: CALL_OW 273
62217: PPUSH
62218: LD_VAR 0 3
62222: PPUSH
62223: CALL_OW 309
62227: IFFALSE 62241
// begin result := true ;
62229: LD_ADDR_VAR 0 4
62233: PUSH
62234: LD_INT 1
62236: ST_TO_ADDR
// exit ;
62237: POP
62238: POP
62239: GO 62245
// end ;
62241: GO 62175
62243: POP
62244: POP
// end ;
62245: LD_VAR 0 4
62249: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
62250: LD_INT 0
62252: PPUSH
62253: PPUSH
62254: PPUSH
// if btype = b_depot then
62255: LD_VAR 0 2
62259: PUSH
62260: LD_INT 0
62262: EQUAL
62263: IFFALSE 62275
// begin result := true ;
62265: LD_ADDR_VAR 0 3
62269: PUSH
62270: LD_INT 1
62272: ST_TO_ADDR
// exit ;
62273: GO 62395
// end ; pom := GetBase ( depot ) ;
62275: LD_ADDR_VAR 0 4
62279: PUSH
62280: LD_VAR 0 1
62284: PPUSH
62285: CALL_OW 274
62289: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62290: LD_ADDR_VAR 0 5
62294: PUSH
62295: LD_VAR 0 2
62299: PPUSH
62300: LD_VAR 0 1
62304: PPUSH
62305: CALL_OW 248
62309: PPUSH
62310: CALL_OW 450
62314: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
62315: LD_ADDR_VAR 0 3
62319: PUSH
62320: LD_VAR 0 4
62324: PPUSH
62325: LD_INT 1
62327: PPUSH
62328: CALL_OW 275
62332: PUSH
62333: LD_VAR 0 5
62337: PUSH
62338: LD_INT 1
62340: ARRAY
62341: GREATEREQUAL
62342: IFFALSE 62368
62344: PUSH
62345: LD_VAR 0 4
62349: PPUSH
62350: LD_INT 2
62352: PPUSH
62353: CALL_OW 275
62357: PUSH
62358: LD_VAR 0 5
62362: PUSH
62363: LD_INT 2
62365: ARRAY
62366: GREATEREQUAL
62367: AND
62368: IFFALSE 62394
62370: PUSH
62371: LD_VAR 0 4
62375: PPUSH
62376: LD_INT 3
62378: PPUSH
62379: CALL_OW 275
62383: PUSH
62384: LD_VAR 0 5
62388: PUSH
62389: LD_INT 3
62391: ARRAY
62392: GREATEREQUAL
62393: AND
62394: ST_TO_ADDR
// end ;
62395: LD_VAR 0 3
62399: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
62400: LD_INT 0
62402: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
62403: LD_VAR 0 1
62407: PPUSH
62408: LD_VAR 0 2
62412: PPUSH
62413: LD_INT 0
62415: PPUSH
62416: LD_INT 0
62418: PPUSH
62419: LD_INT 1
62421: PPUSH
62422: LD_INT 0
62424: PPUSH
62425: CALL_OW 587
// end ;
62429: LD_VAR 0 3
62433: RET
// export function CenterOnNow ( unit ) ; begin
62434: LD_INT 0
62436: PPUSH
// result := IsInUnit ( unit ) ;
62437: LD_ADDR_VAR 0 2
62441: PUSH
62442: LD_VAR 0 1
62446: PPUSH
62447: CALL_OW 310
62451: ST_TO_ADDR
// if not result then
62452: LD_VAR 0 2
62456: NOT
62457: IFFALSE 62469
// result := unit ;
62459: LD_ADDR_VAR 0 2
62463: PUSH
62464: LD_VAR 0 1
62468: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
62469: LD_VAR 0 1
62473: PPUSH
62474: CALL_OW 87
// end ;
62478: LD_VAR 0 2
62482: RET
// export function ComMoveHex ( unit , hex ) ; begin
62483: LD_INT 0
62485: PPUSH
// if not hex then
62486: LD_VAR 0 2
62490: NOT
62491: IFFALSE 62495
// exit ;
62493: GO 62548
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
62495: LD_VAR 0 2
62499: PUSH
62500: LD_INT 1
62502: ARRAY
62503: PPUSH
62504: LD_VAR 0 2
62508: PUSH
62509: LD_INT 2
62511: ARRAY
62512: PPUSH
62513: CALL_OW 428
62517: IFFALSE 62521
// exit ;
62519: GO 62548
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
62521: LD_VAR 0 1
62525: PPUSH
62526: LD_VAR 0 2
62530: PUSH
62531: LD_INT 1
62533: ARRAY
62534: PPUSH
62535: LD_VAR 0 2
62539: PUSH
62540: LD_INT 2
62542: ARRAY
62543: PPUSH
62544: CALL_OW 111
// end ;
62548: LD_VAR 0 3
62552: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
62553: LD_INT 0
62555: PPUSH
62556: PPUSH
62557: PPUSH
// if not unit or not enemy then
62558: LD_VAR 0 1
62562: NOT
62563: IFTRUE 62572
62565: PUSH
62566: LD_VAR 0 2
62570: NOT
62571: OR
62572: IFFALSE 62576
// exit ;
62574: GO 62702
// x := GetX ( enemy ) ;
62576: LD_ADDR_VAR 0 4
62580: PUSH
62581: LD_VAR 0 2
62585: PPUSH
62586: CALL_OW 250
62590: ST_TO_ADDR
// y := GetY ( enemy ) ;
62591: LD_ADDR_VAR 0 5
62595: PUSH
62596: LD_VAR 0 2
62600: PPUSH
62601: CALL_OW 251
62605: ST_TO_ADDR
// if ValidHex ( x , y ) then
62606: LD_VAR 0 4
62610: PPUSH
62611: LD_VAR 0 5
62615: PPUSH
62616: CALL_OW 488
62620: IFFALSE 62702
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
62622: LD_VAR 0 2
62626: PPUSH
62627: CALL_OW 247
62631: PUSH
62632: LD_INT 3
62634: PUSH
62635: LD_INT 2
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: IN
62642: IFTRUE 62665
62644: PUSH
62645: LD_VAR 0 1
62649: PPUSH
62650: CALL_OW 255
62654: PPUSH
62655: LD_VAR 0 2
62659: PPUSH
62660: CALL_OW 292
62664: OR
62665: IFFALSE 62683
// ComAttackUnit ( unit , enemy ) else
62667: LD_VAR 0 1
62671: PPUSH
62672: LD_VAR 0 2
62676: PPUSH
62677: CALL_OW 115
62681: GO 62702
// ComAgressiveMove ( unit , x , y ) ;
62683: LD_VAR 0 1
62687: PPUSH
62688: LD_VAR 0 4
62692: PPUSH
62693: LD_VAR 0 5
62697: PPUSH
62698: CALL_OW 114
// end ;
62702: LD_VAR 0 3
62706: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
62707: LD_INT 0
62709: PPUSH
62710: PPUSH
62711: PPUSH
// list := AreaToList ( area , 0 ) ;
62712: LD_ADDR_VAR 0 5
62716: PUSH
62717: LD_VAR 0 1
62721: PPUSH
62722: LD_INT 0
62724: PPUSH
62725: CALL_OW 517
62729: ST_TO_ADDR
// if not list then
62730: LD_VAR 0 5
62734: NOT
62735: IFFALSE 62739
// exit ;
62737: GO 62869
// if all then
62739: LD_VAR 0 2
62743: IFFALSE 62831
// begin for i := 1 to list [ 1 ] do
62745: LD_ADDR_VAR 0 4
62749: PUSH
62750: DOUBLE
62751: LD_INT 1
62753: DEC
62754: ST_TO_ADDR
62755: LD_VAR 0 5
62759: PUSH
62760: LD_INT 1
62762: ARRAY
62763: PUSH
62764: FOR_TO
62765: IFFALSE 62827
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62767: LD_ADDR_VAR 0 3
62771: PUSH
62772: LD_VAR 0 3
62776: PPUSH
62777: LD_VAR 0 3
62781: PUSH
62782: LD_INT 1
62784: PLUS
62785: PPUSH
62786: LD_VAR 0 5
62790: PUSH
62791: LD_INT 1
62793: ARRAY
62794: PUSH
62795: LD_VAR 0 4
62799: ARRAY
62800: PUSH
62801: LD_VAR 0 5
62805: PUSH
62806: LD_INT 2
62808: ARRAY
62809: PUSH
62810: LD_VAR 0 4
62814: ARRAY
62815: PUSH
62816: EMPTY
62817: LIST
62818: LIST
62819: PPUSH
62820: CALL_OW 1
62824: ST_TO_ADDR
62825: GO 62764
62827: POP
62828: POP
// exit ;
62829: GO 62869
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
62831: LD_ADDR_VAR 0 3
62835: PUSH
62836: LD_VAR 0 5
62840: PUSH
62841: LD_INT 1
62843: ARRAY
62844: PUSH
62845: LD_INT 1
62847: ARRAY
62848: PUSH
62849: LD_VAR 0 5
62853: PUSH
62854: LD_INT 2
62856: ARRAY
62857: PUSH
62858: LD_INT 1
62860: ARRAY
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: EMPTY
62867: LIST
62868: ST_TO_ADDR
// end ;
62869: LD_VAR 0 3
62873: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
62874: LD_INT 0
62876: PPUSH
62877: PPUSH
// list := AreaToList ( area , 0 ) ;
62878: LD_ADDR_VAR 0 4
62882: PUSH
62883: LD_VAR 0 1
62887: PPUSH
62888: LD_INT 0
62890: PPUSH
62891: CALL_OW 517
62895: ST_TO_ADDR
// if not list then
62896: LD_VAR 0 4
62900: NOT
62901: IFFALSE 62905
// exit ;
62903: GO 62946
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
62905: LD_ADDR_VAR 0 3
62909: PUSH
62910: LD_VAR 0 4
62914: PUSH
62915: LD_INT 1
62917: ARRAY
62918: PUSH
62919: LD_INT 1
62921: ARRAY
62922: PUSH
62923: LD_VAR 0 4
62927: PUSH
62928: LD_INT 2
62930: ARRAY
62931: PUSH
62932: LD_INT 1
62934: ARRAY
62935: PUSH
62936: LD_VAR 0 2
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: LIST
62945: ST_TO_ADDR
// end ;
62946: LD_VAR 0 3
62950: RET
// export function First ( array ) ; begin
62951: LD_INT 0
62953: PPUSH
// if not array then
62954: LD_VAR 0 1
62958: NOT
62959: IFFALSE 62963
// exit ;
62961: GO 62977
// result := array [ 1 ] ;
62963: LD_ADDR_VAR 0 2
62967: PUSH
62968: LD_VAR 0 1
62972: PUSH
62973: LD_INT 1
62975: ARRAY
62976: ST_TO_ADDR
// end ;
62977: LD_VAR 0 2
62981: RET
// export function Last ( array ) ; begin
62982: LD_INT 0
62984: PPUSH
// if not array then
62985: LD_VAR 0 1
62989: NOT
62990: IFFALSE 62994
// exit ;
62992: GO 63010
// result := array [ array ] ;
62994: LD_ADDR_VAR 0 2
62998: PUSH
62999: LD_VAR 0 1
63003: PUSH
63004: LD_VAR 0 1
63008: ARRAY
63009: ST_TO_ADDR
// end ;
63010: LD_VAR 0 2
63014: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
63015: LD_INT 0
63017: PPUSH
63018: PPUSH
// result := [ ] ;
63019: LD_ADDR_VAR 0 5
63023: PUSH
63024: EMPTY
63025: ST_TO_ADDR
// if not array then
63026: LD_VAR 0 1
63030: NOT
63031: IFFALSE 63035
// exit ;
63033: GO 63147
// for i := 1 to array do
63035: LD_ADDR_VAR 0 6
63039: PUSH
63040: DOUBLE
63041: LD_INT 1
63043: DEC
63044: ST_TO_ADDR
63045: LD_VAR 0 1
63049: PUSH
63050: FOR_TO
63051: IFFALSE 63145
// if array [ i ] [ index ] = value then
63053: LD_VAR 0 1
63057: PUSH
63058: LD_VAR 0 6
63062: ARRAY
63063: PUSH
63064: LD_VAR 0 2
63068: ARRAY
63069: PUSH
63070: LD_VAR 0 3
63074: EQUAL
63075: IFFALSE 63143
// begin if indexColumn then
63077: LD_VAR 0 4
63081: IFFALSE 63117
// result := Join ( result , array [ i ] [ indexColumn ] ) else
63083: LD_ADDR_VAR 0 5
63087: PUSH
63088: LD_VAR 0 5
63092: PPUSH
63093: LD_VAR 0 1
63097: PUSH
63098: LD_VAR 0 6
63102: ARRAY
63103: PUSH
63104: LD_VAR 0 4
63108: ARRAY
63109: PPUSH
63110: CALL 58155 0 2
63114: ST_TO_ADDR
63115: GO 63143
// result := Join ( result , array [ i ] ) ;
63117: LD_ADDR_VAR 0 5
63121: PUSH
63122: LD_VAR 0 5
63126: PPUSH
63127: LD_VAR 0 1
63131: PUSH
63132: LD_VAR 0 6
63136: ARRAY
63137: PPUSH
63138: CALL 58155 0 2
63142: ST_TO_ADDR
// end ;
63143: GO 63050
63145: POP
63146: POP
// end ;
63147: LD_VAR 0 5
63151: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
63152: LD_INT 0
63154: PPUSH
// if not vehicles or not parkingPoint then
63155: LD_VAR 0 1
63159: NOT
63160: IFTRUE 63169
63162: PUSH
63163: LD_VAR 0 2
63167: NOT
63168: OR
63169: IFFALSE 63173
// exit ;
63171: GO 63271
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
63173: LD_ADDR_VAR 0 1
63177: PUSH
63178: LD_VAR 0 1
63182: PPUSH
63183: LD_INT 50
63185: PUSH
63186: EMPTY
63187: LIST
63188: PUSH
63189: LD_INT 3
63191: PUSH
63192: LD_INT 92
63194: PUSH
63195: LD_VAR 0 2
63199: PUSH
63200: LD_INT 1
63202: ARRAY
63203: PUSH
63204: LD_VAR 0 2
63208: PUSH
63209: LD_INT 2
63211: ARRAY
63212: PUSH
63213: LD_INT 8
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: PUSH
63222: EMPTY
63223: LIST
63224: LIST
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PPUSH
63230: CALL_OW 72
63234: ST_TO_ADDR
// if not vehicles then
63235: LD_VAR 0 1
63239: NOT
63240: IFFALSE 63244
// exit ;
63242: GO 63271
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
63244: LD_VAR 0 1
63248: PPUSH
63249: LD_VAR 0 2
63253: PUSH
63254: LD_INT 1
63256: ARRAY
63257: PPUSH
63258: LD_VAR 0 2
63262: PUSH
63263: LD_INT 2
63265: ARRAY
63266: PPUSH
63267: CALL_OW 111
// end ;
63271: LD_VAR 0 3
63275: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
63276: LD_INT 0
63278: PPUSH
63279: PPUSH
63280: PPUSH
// if not side or not area then
63281: LD_VAR 0 1
63285: NOT
63286: IFTRUE 63295
63288: PUSH
63289: LD_VAR 0 2
63293: NOT
63294: OR
63295: IFFALSE 63299
// exit ;
63297: GO 63418
// tmp := AreaToList ( area , 0 ) ;
63299: LD_ADDR_VAR 0 5
63303: PUSH
63304: LD_VAR 0 2
63308: PPUSH
63309: LD_INT 0
63311: PPUSH
63312: CALL_OW 517
63316: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
63317: LD_ADDR_VAR 0 4
63321: PUSH
63322: DOUBLE
63323: LD_INT 1
63325: DEC
63326: ST_TO_ADDR
63327: LD_VAR 0 5
63331: PUSH
63332: LD_INT 1
63334: ARRAY
63335: PUSH
63336: FOR_TO
63337: IFFALSE 63416
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
63339: LD_VAR 0 5
63343: PUSH
63344: LD_INT 1
63346: ARRAY
63347: PUSH
63348: LD_VAR 0 4
63352: ARRAY
63353: PPUSH
63354: LD_VAR 0 5
63358: PUSH
63359: LD_INT 2
63361: ARRAY
63362: PUSH
63363: LD_VAR 0 4
63367: ARRAY
63368: PPUSH
63369: CALL_OW 351
63373: IFFALSE 63414
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
63375: LD_VAR 0 5
63379: PUSH
63380: LD_INT 1
63382: ARRAY
63383: PUSH
63384: LD_VAR 0 4
63388: ARRAY
63389: PPUSH
63390: LD_VAR 0 5
63394: PUSH
63395: LD_INT 2
63397: ARRAY
63398: PUSH
63399: LD_VAR 0 4
63403: ARRAY
63404: PPUSH
63405: LD_VAR 0 1
63409: PPUSH
63410: CALL_OW 244
// end ;
63414: GO 63336
63416: POP
63417: POP
// end ;
63418: LD_VAR 0 3
63422: RET
// export function UniqueArray ( array ) ; var i ; begin
63423: LD_INT 0
63425: PPUSH
63426: PPUSH
// result := [ ] ;
63427: LD_ADDR_VAR 0 2
63431: PUSH
63432: EMPTY
63433: ST_TO_ADDR
// if not array then
63434: LD_VAR 0 1
63438: NOT
63439: IFFALSE 63443
// exit ;
63441: GO 63504
// for i := 1 to array do
63443: LD_ADDR_VAR 0 3
63447: PUSH
63448: DOUBLE
63449: LD_INT 1
63451: DEC
63452: ST_TO_ADDR
63453: LD_VAR 0 1
63457: PUSH
63458: FOR_TO
63459: IFFALSE 63502
// if not array [ i ] in result then
63461: LD_VAR 0 1
63465: PUSH
63466: LD_VAR 0 3
63470: ARRAY
63471: PUSH
63472: LD_VAR 0 2
63476: IN
63477: NOT
63478: IFFALSE 63500
// result := Join ( result , i ) ;
63480: LD_ADDR_VAR 0 2
63484: PUSH
63485: LD_VAR 0 2
63489: PPUSH
63490: LD_VAR 0 3
63494: PPUSH
63495: CALL 58155 0 2
63499: ST_TO_ADDR
63500: GO 63458
63502: POP
63503: POP
// end ; end_of_file
63504: LD_VAR 0 2
63508: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
63509: LD_INT 0
63511: PPUSH
63512: PPUSH
// skirmish := false ;
63513: LD_ADDR_EXP 29
63517: PUSH
63518: LD_INT 0
63520: ST_TO_ADDR
// debug_mc := false ;
63521: LD_ADDR_EXP 30
63525: PUSH
63526: LD_INT 0
63528: ST_TO_ADDR
// mc_bases := [ ] ;
63529: LD_ADDR_EXP 31
63533: PUSH
63534: EMPTY
63535: ST_TO_ADDR
// mc_sides := [ ] ;
63536: LD_ADDR_EXP 57
63540: PUSH
63541: EMPTY
63542: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
63543: LD_ADDR_EXP 32
63547: PUSH
63548: EMPTY
63549: ST_TO_ADDR
// mc_building_repairs := [ ] ;
63550: LD_ADDR_EXP 33
63554: PUSH
63555: EMPTY
63556: ST_TO_ADDR
// mc_need_heal := [ ] ;
63557: LD_ADDR_EXP 34
63561: PUSH
63562: EMPTY
63563: ST_TO_ADDR
// mc_healers := [ ] ;
63564: LD_ADDR_EXP 35
63568: PUSH
63569: EMPTY
63570: ST_TO_ADDR
// mc_build_list := [ ] ;
63571: LD_ADDR_EXP 36
63575: PUSH
63576: EMPTY
63577: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
63578: LD_ADDR_EXP 63
63582: PUSH
63583: EMPTY
63584: ST_TO_ADDR
// mc_builders := [ ] ;
63585: LD_ADDR_EXP 37
63589: PUSH
63590: EMPTY
63591: ST_TO_ADDR
// mc_construct_list := [ ] ;
63592: LD_ADDR_EXP 38
63596: PUSH
63597: EMPTY
63598: ST_TO_ADDR
// mc_turret_list := [ ] ;
63599: LD_ADDR_EXP 39
63603: PUSH
63604: EMPTY
63605: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
63606: LD_ADDR_EXP 40
63610: PUSH
63611: EMPTY
63612: ST_TO_ADDR
// mc_miners := [ ] ;
63613: LD_ADDR_EXP 45
63617: PUSH
63618: EMPTY
63619: ST_TO_ADDR
// mc_mines := [ ] ;
63620: LD_ADDR_EXP 44
63624: PUSH
63625: EMPTY
63626: ST_TO_ADDR
// mc_minefields := [ ] ;
63627: LD_ADDR_EXP 46
63631: PUSH
63632: EMPTY
63633: ST_TO_ADDR
// mc_crates := [ ] ;
63634: LD_ADDR_EXP 47
63638: PUSH
63639: EMPTY
63640: ST_TO_ADDR
// mc_crates_collector := [ ] ;
63641: LD_ADDR_EXP 48
63645: PUSH
63646: EMPTY
63647: ST_TO_ADDR
// mc_crates_area := [ ] ;
63648: LD_ADDR_EXP 49
63652: PUSH
63653: EMPTY
63654: ST_TO_ADDR
// mc_vehicles := [ ] ;
63655: LD_ADDR_EXP 50
63659: PUSH
63660: EMPTY
63661: ST_TO_ADDR
// mc_attack := [ ] ;
63662: LD_ADDR_EXP 51
63666: PUSH
63667: EMPTY
63668: ST_TO_ADDR
// mc_produce := [ ] ;
63669: LD_ADDR_EXP 52
63673: PUSH
63674: EMPTY
63675: ST_TO_ADDR
// mc_defender := [ ] ;
63676: LD_ADDR_EXP 53
63680: PUSH
63681: EMPTY
63682: ST_TO_ADDR
// mc_parking := [ ] ;
63683: LD_ADDR_EXP 55
63687: PUSH
63688: EMPTY
63689: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
63690: LD_ADDR_EXP 41
63694: PUSH
63695: EMPTY
63696: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
63697: LD_ADDR_EXP 43
63701: PUSH
63702: EMPTY
63703: ST_TO_ADDR
// mc_scan := [ ] ;
63704: LD_ADDR_EXP 54
63708: PUSH
63709: EMPTY
63710: ST_TO_ADDR
// mc_scan_area := [ ] ;
63711: LD_ADDR_EXP 56
63715: PUSH
63716: EMPTY
63717: ST_TO_ADDR
// mc_tech := [ ] ;
63718: LD_ADDR_EXP 58
63722: PUSH
63723: EMPTY
63724: ST_TO_ADDR
// mc_class := [ ] ;
63725: LD_ADDR_EXP 72
63729: PUSH
63730: EMPTY
63731: ST_TO_ADDR
// mc_class_case_use := [ ] ;
63732: LD_ADDR_EXP 73
63736: PUSH
63737: EMPTY
63738: ST_TO_ADDR
// mc_is_defending := [ ] ;
63739: LD_ADDR_EXP 74
63743: PUSH
63744: EMPTY
63745: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
63746: LD_ADDR_EXP 65
63750: PUSH
63751: EMPTY
63752: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
63753: LD_ADDR_EXP 75
63757: PUSH
63758: LD_INT 0
63760: ST_TO_ADDR
// end ;
63761: LD_VAR 0 1
63765: RET
// export function MC_Kill ( base ) ; begin
63766: LD_INT 0
63768: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
63769: LD_ADDR_EXP 31
63773: PUSH
63774: LD_EXP 31
63778: PPUSH
63779: LD_VAR 0 1
63783: PPUSH
63784: EMPTY
63785: PPUSH
63786: CALL_OW 1
63790: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
63791: LD_ADDR_EXP 32
63795: PUSH
63796: LD_EXP 32
63800: PPUSH
63801: LD_VAR 0 1
63805: PPUSH
63806: EMPTY
63807: PPUSH
63808: CALL_OW 1
63812: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63813: LD_ADDR_EXP 33
63817: PUSH
63818: LD_EXP 33
63822: PPUSH
63823: LD_VAR 0 1
63827: PPUSH
63828: EMPTY
63829: PPUSH
63830: CALL_OW 1
63834: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63835: LD_ADDR_EXP 34
63839: PUSH
63840: LD_EXP 34
63844: PPUSH
63845: LD_VAR 0 1
63849: PPUSH
63850: EMPTY
63851: PPUSH
63852: CALL_OW 1
63856: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63857: LD_ADDR_EXP 35
63861: PUSH
63862: LD_EXP 35
63866: PPUSH
63867: LD_VAR 0 1
63871: PPUSH
63872: EMPTY
63873: PPUSH
63874: CALL_OW 1
63878: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63879: LD_ADDR_EXP 36
63883: PUSH
63884: LD_EXP 36
63888: PPUSH
63889: LD_VAR 0 1
63893: PPUSH
63894: EMPTY
63895: PPUSH
63896: CALL_OW 1
63900: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63901: LD_ADDR_EXP 37
63905: PUSH
63906: LD_EXP 37
63910: PPUSH
63911: LD_VAR 0 1
63915: PPUSH
63916: EMPTY
63917: PPUSH
63918: CALL_OW 1
63922: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63923: LD_ADDR_EXP 38
63927: PUSH
63928: LD_EXP 38
63932: PPUSH
63933: LD_VAR 0 1
63937: PPUSH
63938: EMPTY
63939: PPUSH
63940: CALL_OW 1
63944: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63945: LD_ADDR_EXP 39
63949: PUSH
63950: LD_EXP 39
63954: PPUSH
63955: LD_VAR 0 1
63959: PPUSH
63960: EMPTY
63961: PPUSH
63962: CALL_OW 1
63966: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63967: LD_ADDR_EXP 40
63971: PUSH
63972: LD_EXP 40
63976: PPUSH
63977: LD_VAR 0 1
63981: PPUSH
63982: EMPTY
63983: PPUSH
63984: CALL_OW 1
63988: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63989: LD_ADDR_EXP 41
63993: PUSH
63994: LD_EXP 41
63998: PPUSH
63999: LD_VAR 0 1
64003: PPUSH
64004: EMPTY
64005: PPUSH
64006: CALL_OW 1
64010: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
64011: LD_ADDR_EXP 42
64015: PUSH
64016: LD_EXP 42
64020: PPUSH
64021: LD_VAR 0 1
64025: PPUSH
64026: LD_INT 0
64028: PPUSH
64029: CALL_OW 1
64033: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
64034: LD_ADDR_EXP 43
64038: PUSH
64039: LD_EXP 43
64043: PPUSH
64044: LD_VAR 0 1
64048: PPUSH
64049: EMPTY
64050: PPUSH
64051: CALL_OW 1
64055: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
64056: LD_ADDR_EXP 44
64060: PUSH
64061: LD_EXP 44
64065: PPUSH
64066: LD_VAR 0 1
64070: PPUSH
64071: EMPTY
64072: PPUSH
64073: CALL_OW 1
64077: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
64078: LD_ADDR_EXP 45
64082: PUSH
64083: LD_EXP 45
64087: PPUSH
64088: LD_VAR 0 1
64092: PPUSH
64093: EMPTY
64094: PPUSH
64095: CALL_OW 1
64099: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
64100: LD_ADDR_EXP 46
64104: PUSH
64105: LD_EXP 46
64109: PPUSH
64110: LD_VAR 0 1
64114: PPUSH
64115: EMPTY
64116: PPUSH
64117: CALL_OW 1
64121: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
64122: LD_ADDR_EXP 47
64126: PUSH
64127: LD_EXP 47
64131: PPUSH
64132: LD_VAR 0 1
64136: PPUSH
64137: EMPTY
64138: PPUSH
64139: CALL_OW 1
64143: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
64144: LD_ADDR_EXP 48
64148: PUSH
64149: LD_EXP 48
64153: PPUSH
64154: LD_VAR 0 1
64158: PPUSH
64159: EMPTY
64160: PPUSH
64161: CALL_OW 1
64165: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
64166: LD_ADDR_EXP 49
64170: PUSH
64171: LD_EXP 49
64175: PPUSH
64176: LD_VAR 0 1
64180: PPUSH
64181: EMPTY
64182: PPUSH
64183: CALL_OW 1
64187: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
64188: LD_ADDR_EXP 50
64192: PUSH
64193: LD_EXP 50
64197: PPUSH
64198: LD_VAR 0 1
64202: PPUSH
64203: EMPTY
64204: PPUSH
64205: CALL_OW 1
64209: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
64210: LD_ADDR_EXP 51
64214: PUSH
64215: LD_EXP 51
64219: PPUSH
64220: LD_VAR 0 1
64224: PPUSH
64225: EMPTY
64226: PPUSH
64227: CALL_OW 1
64231: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
64232: LD_ADDR_EXP 52
64236: PUSH
64237: LD_EXP 52
64241: PPUSH
64242: LD_VAR 0 1
64246: PPUSH
64247: EMPTY
64248: PPUSH
64249: CALL_OW 1
64253: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
64254: LD_ADDR_EXP 53
64258: PUSH
64259: LD_EXP 53
64263: PPUSH
64264: LD_VAR 0 1
64268: PPUSH
64269: EMPTY
64270: PPUSH
64271: CALL_OW 1
64275: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
64276: LD_ADDR_EXP 54
64280: PUSH
64281: LD_EXP 54
64285: PPUSH
64286: LD_VAR 0 1
64290: PPUSH
64291: EMPTY
64292: PPUSH
64293: CALL_OW 1
64297: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
64298: LD_ADDR_EXP 55
64302: PUSH
64303: LD_EXP 55
64307: PPUSH
64308: LD_VAR 0 1
64312: PPUSH
64313: EMPTY
64314: PPUSH
64315: CALL_OW 1
64319: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
64320: LD_ADDR_EXP 56
64324: PUSH
64325: LD_EXP 56
64329: PPUSH
64330: LD_VAR 0 1
64334: PPUSH
64335: EMPTY
64336: PPUSH
64337: CALL_OW 1
64341: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
64342: LD_ADDR_EXP 58
64346: PUSH
64347: LD_EXP 58
64351: PPUSH
64352: LD_VAR 0 1
64356: PPUSH
64357: EMPTY
64358: PPUSH
64359: CALL_OW 1
64363: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
64364: LD_ADDR_EXP 60
64368: PUSH
64369: LD_EXP 60
64373: PPUSH
64374: LD_VAR 0 1
64378: PPUSH
64379: EMPTY
64380: PPUSH
64381: CALL_OW 1
64385: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
64386: LD_ADDR_EXP 61
64390: PUSH
64391: LD_EXP 61
64395: PPUSH
64396: LD_VAR 0 1
64400: PPUSH
64401: EMPTY
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
64408: LD_ADDR_EXP 62
64412: PUSH
64413: LD_EXP 62
64417: PPUSH
64418: LD_VAR 0 1
64422: PPUSH
64423: EMPTY
64424: PPUSH
64425: CALL_OW 1
64429: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
64430: LD_ADDR_EXP 63
64434: PUSH
64435: LD_EXP 63
64439: PPUSH
64440: LD_VAR 0 1
64444: PPUSH
64445: EMPTY
64446: PPUSH
64447: CALL_OW 1
64451: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
64452: LD_ADDR_EXP 64
64456: PUSH
64457: LD_EXP 64
64461: PPUSH
64462: LD_VAR 0 1
64466: PPUSH
64467: EMPTY
64468: PPUSH
64469: CALL_OW 1
64473: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
64474: LD_ADDR_EXP 65
64478: PUSH
64479: LD_EXP 65
64483: PPUSH
64484: LD_VAR 0 1
64488: PPUSH
64489: EMPTY
64490: PPUSH
64491: CALL_OW 1
64495: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
64496: LD_ADDR_EXP 66
64500: PUSH
64501: LD_EXP 66
64505: PPUSH
64506: LD_VAR 0 1
64510: PPUSH
64511: EMPTY
64512: PPUSH
64513: CALL_OW 1
64517: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
64518: LD_ADDR_EXP 67
64522: PUSH
64523: LD_EXP 67
64527: PPUSH
64528: LD_VAR 0 1
64532: PPUSH
64533: EMPTY
64534: PPUSH
64535: CALL_OW 1
64539: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
64540: LD_ADDR_EXP 68
64544: PUSH
64545: LD_EXP 68
64549: PPUSH
64550: LD_VAR 0 1
64554: PPUSH
64555: EMPTY
64556: PPUSH
64557: CALL_OW 1
64561: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
64562: LD_ADDR_EXP 69
64566: PUSH
64567: LD_EXP 69
64571: PPUSH
64572: LD_VAR 0 1
64576: PPUSH
64577: EMPTY
64578: PPUSH
64579: CALL_OW 1
64583: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
64584: LD_ADDR_EXP 70
64588: PUSH
64589: LD_EXP 70
64593: PPUSH
64594: LD_VAR 0 1
64598: PPUSH
64599: EMPTY
64600: PPUSH
64601: CALL_OW 1
64605: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
64606: LD_ADDR_EXP 71
64610: PUSH
64611: LD_EXP 71
64615: PPUSH
64616: LD_VAR 0 1
64620: PPUSH
64621: EMPTY
64622: PPUSH
64623: CALL_OW 1
64627: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
64628: LD_ADDR_EXP 72
64632: PUSH
64633: LD_EXP 72
64637: PPUSH
64638: LD_VAR 0 1
64642: PPUSH
64643: EMPTY
64644: PPUSH
64645: CALL_OW 1
64649: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
64650: LD_ADDR_EXP 73
64654: PUSH
64655: LD_EXP 73
64659: PPUSH
64660: LD_VAR 0 1
64664: PPUSH
64665: LD_INT 0
64667: PPUSH
64668: CALL_OW 1
64672: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
64673: LD_ADDR_EXP 74
64677: PUSH
64678: LD_EXP 74
64682: PPUSH
64683: LD_VAR 0 1
64687: PPUSH
64688: LD_INT 0
64690: PPUSH
64691: CALL_OW 1
64695: ST_TO_ADDR
// end ;
64696: LD_VAR 0 2
64700: RET
// export function MC_Add ( side , units ) ; var base ; begin
64701: LD_INT 0
64703: PPUSH
64704: PPUSH
// base := mc_bases + 1 ;
64705: LD_ADDR_VAR 0 4
64709: PUSH
64710: LD_EXP 31
64714: PUSH
64715: LD_INT 1
64717: PLUS
64718: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
64719: LD_ADDR_EXP 57
64723: PUSH
64724: LD_EXP 57
64728: PPUSH
64729: LD_VAR 0 4
64733: PPUSH
64734: LD_VAR 0 1
64738: PPUSH
64739: CALL_OW 1
64743: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
64744: LD_ADDR_EXP 31
64748: PUSH
64749: LD_EXP 31
64753: PPUSH
64754: LD_VAR 0 4
64758: PPUSH
64759: LD_VAR 0 2
64763: PPUSH
64764: CALL_OW 1
64768: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
64769: LD_ADDR_EXP 32
64773: PUSH
64774: LD_EXP 32
64778: PPUSH
64779: LD_VAR 0 4
64783: PPUSH
64784: EMPTY
64785: PPUSH
64786: CALL_OW 1
64790: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
64791: LD_ADDR_EXP 33
64795: PUSH
64796: LD_EXP 33
64800: PPUSH
64801: LD_VAR 0 4
64805: PPUSH
64806: EMPTY
64807: PPUSH
64808: CALL_OW 1
64812: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
64813: LD_ADDR_EXP 34
64817: PUSH
64818: LD_EXP 34
64822: PPUSH
64823: LD_VAR 0 4
64827: PPUSH
64828: EMPTY
64829: PPUSH
64830: CALL_OW 1
64834: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
64835: LD_ADDR_EXP 35
64839: PUSH
64840: LD_EXP 35
64844: PPUSH
64845: LD_VAR 0 4
64849: PPUSH
64850: EMPTY
64851: PPUSH
64852: CALL_OW 1
64856: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
64857: LD_ADDR_EXP 36
64861: PUSH
64862: LD_EXP 36
64866: PPUSH
64867: LD_VAR 0 4
64871: PPUSH
64872: EMPTY
64873: PPUSH
64874: CALL_OW 1
64878: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
64879: LD_ADDR_EXP 37
64883: PUSH
64884: LD_EXP 37
64888: PPUSH
64889: LD_VAR 0 4
64893: PPUSH
64894: EMPTY
64895: PPUSH
64896: CALL_OW 1
64900: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
64901: LD_ADDR_EXP 38
64905: PUSH
64906: LD_EXP 38
64910: PPUSH
64911: LD_VAR 0 4
64915: PPUSH
64916: EMPTY
64917: PPUSH
64918: CALL_OW 1
64922: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
64923: LD_ADDR_EXP 39
64927: PUSH
64928: LD_EXP 39
64932: PPUSH
64933: LD_VAR 0 4
64937: PPUSH
64938: EMPTY
64939: PPUSH
64940: CALL_OW 1
64944: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
64945: LD_ADDR_EXP 40
64949: PUSH
64950: LD_EXP 40
64954: PPUSH
64955: LD_VAR 0 4
64959: PPUSH
64960: EMPTY
64961: PPUSH
64962: CALL_OW 1
64966: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
64967: LD_ADDR_EXP 41
64971: PUSH
64972: LD_EXP 41
64976: PPUSH
64977: LD_VAR 0 4
64981: PPUSH
64982: EMPTY
64983: PPUSH
64984: CALL_OW 1
64988: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
64989: LD_ADDR_EXP 42
64993: PUSH
64994: LD_EXP 42
64998: PPUSH
64999: LD_VAR 0 4
65003: PPUSH
65004: LD_INT 0
65006: PPUSH
65007: CALL_OW 1
65011: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
65012: LD_ADDR_EXP 43
65016: PUSH
65017: LD_EXP 43
65021: PPUSH
65022: LD_VAR 0 4
65026: PPUSH
65027: EMPTY
65028: PPUSH
65029: CALL_OW 1
65033: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
65034: LD_ADDR_EXP 44
65038: PUSH
65039: LD_EXP 44
65043: PPUSH
65044: LD_VAR 0 4
65048: PPUSH
65049: EMPTY
65050: PPUSH
65051: CALL_OW 1
65055: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
65056: LD_ADDR_EXP 45
65060: PUSH
65061: LD_EXP 45
65065: PPUSH
65066: LD_VAR 0 4
65070: PPUSH
65071: EMPTY
65072: PPUSH
65073: CALL_OW 1
65077: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
65078: LD_ADDR_EXP 46
65082: PUSH
65083: LD_EXP 46
65087: PPUSH
65088: LD_VAR 0 4
65092: PPUSH
65093: EMPTY
65094: PPUSH
65095: CALL_OW 1
65099: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
65100: LD_ADDR_EXP 47
65104: PUSH
65105: LD_EXP 47
65109: PPUSH
65110: LD_VAR 0 4
65114: PPUSH
65115: EMPTY
65116: PPUSH
65117: CALL_OW 1
65121: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
65122: LD_ADDR_EXP 48
65126: PUSH
65127: LD_EXP 48
65131: PPUSH
65132: LD_VAR 0 4
65136: PPUSH
65137: EMPTY
65138: PPUSH
65139: CALL_OW 1
65143: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
65144: LD_ADDR_EXP 49
65148: PUSH
65149: LD_EXP 49
65153: PPUSH
65154: LD_VAR 0 4
65158: PPUSH
65159: EMPTY
65160: PPUSH
65161: CALL_OW 1
65165: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
65166: LD_ADDR_EXP 50
65170: PUSH
65171: LD_EXP 50
65175: PPUSH
65176: LD_VAR 0 4
65180: PPUSH
65181: EMPTY
65182: PPUSH
65183: CALL_OW 1
65187: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
65188: LD_ADDR_EXP 51
65192: PUSH
65193: LD_EXP 51
65197: PPUSH
65198: LD_VAR 0 4
65202: PPUSH
65203: EMPTY
65204: PPUSH
65205: CALL_OW 1
65209: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
65210: LD_ADDR_EXP 52
65214: PUSH
65215: LD_EXP 52
65219: PPUSH
65220: LD_VAR 0 4
65224: PPUSH
65225: EMPTY
65226: PPUSH
65227: CALL_OW 1
65231: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
65232: LD_ADDR_EXP 53
65236: PUSH
65237: LD_EXP 53
65241: PPUSH
65242: LD_VAR 0 4
65246: PPUSH
65247: EMPTY
65248: PPUSH
65249: CALL_OW 1
65253: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
65254: LD_ADDR_EXP 54
65258: PUSH
65259: LD_EXP 54
65263: PPUSH
65264: LD_VAR 0 4
65268: PPUSH
65269: EMPTY
65270: PPUSH
65271: CALL_OW 1
65275: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
65276: LD_ADDR_EXP 55
65280: PUSH
65281: LD_EXP 55
65285: PPUSH
65286: LD_VAR 0 4
65290: PPUSH
65291: EMPTY
65292: PPUSH
65293: CALL_OW 1
65297: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
65298: LD_ADDR_EXP 56
65302: PUSH
65303: LD_EXP 56
65307: PPUSH
65308: LD_VAR 0 4
65312: PPUSH
65313: EMPTY
65314: PPUSH
65315: CALL_OW 1
65319: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
65320: LD_ADDR_EXP 58
65324: PUSH
65325: LD_EXP 58
65329: PPUSH
65330: LD_VAR 0 4
65334: PPUSH
65335: EMPTY
65336: PPUSH
65337: CALL_OW 1
65341: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
65342: LD_ADDR_EXP 60
65346: PUSH
65347: LD_EXP 60
65351: PPUSH
65352: LD_VAR 0 4
65356: PPUSH
65357: EMPTY
65358: PPUSH
65359: CALL_OW 1
65363: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
65364: LD_ADDR_EXP 61
65368: PUSH
65369: LD_EXP 61
65373: PPUSH
65374: LD_VAR 0 4
65378: PPUSH
65379: EMPTY
65380: PPUSH
65381: CALL_OW 1
65385: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
65386: LD_ADDR_EXP 62
65390: PUSH
65391: LD_EXP 62
65395: PPUSH
65396: LD_VAR 0 4
65400: PPUSH
65401: EMPTY
65402: PPUSH
65403: CALL_OW 1
65407: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
65408: LD_ADDR_EXP 63
65412: PUSH
65413: LD_EXP 63
65417: PPUSH
65418: LD_VAR 0 4
65422: PPUSH
65423: EMPTY
65424: PPUSH
65425: CALL_OW 1
65429: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
65430: LD_ADDR_EXP 64
65434: PUSH
65435: LD_EXP 64
65439: PPUSH
65440: LD_VAR 0 4
65444: PPUSH
65445: EMPTY
65446: PPUSH
65447: CALL_OW 1
65451: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
65452: LD_ADDR_EXP 65
65456: PUSH
65457: LD_EXP 65
65461: PPUSH
65462: LD_VAR 0 4
65466: PPUSH
65467: EMPTY
65468: PPUSH
65469: CALL_OW 1
65473: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
65474: LD_ADDR_EXP 66
65478: PUSH
65479: LD_EXP 66
65483: PPUSH
65484: LD_VAR 0 4
65488: PPUSH
65489: EMPTY
65490: PPUSH
65491: CALL_OW 1
65495: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
65496: LD_ADDR_EXP 67
65500: PUSH
65501: LD_EXP 67
65505: PPUSH
65506: LD_VAR 0 4
65510: PPUSH
65511: EMPTY
65512: PPUSH
65513: CALL_OW 1
65517: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
65518: LD_ADDR_EXP 68
65522: PUSH
65523: LD_EXP 68
65527: PPUSH
65528: LD_VAR 0 4
65532: PPUSH
65533: EMPTY
65534: PPUSH
65535: CALL_OW 1
65539: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
65540: LD_ADDR_EXP 69
65544: PUSH
65545: LD_EXP 69
65549: PPUSH
65550: LD_VAR 0 4
65554: PPUSH
65555: EMPTY
65556: PPUSH
65557: CALL_OW 1
65561: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
65562: LD_ADDR_EXP 70
65566: PUSH
65567: LD_EXP 70
65571: PPUSH
65572: LD_VAR 0 4
65576: PPUSH
65577: EMPTY
65578: PPUSH
65579: CALL_OW 1
65583: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
65584: LD_ADDR_EXP 71
65588: PUSH
65589: LD_EXP 71
65593: PPUSH
65594: LD_VAR 0 4
65598: PPUSH
65599: EMPTY
65600: PPUSH
65601: CALL_OW 1
65605: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
65606: LD_ADDR_EXP 72
65610: PUSH
65611: LD_EXP 72
65615: PPUSH
65616: LD_VAR 0 4
65620: PPUSH
65621: EMPTY
65622: PPUSH
65623: CALL_OW 1
65627: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
65628: LD_ADDR_EXP 73
65632: PUSH
65633: LD_EXP 73
65637: PPUSH
65638: LD_VAR 0 4
65642: PPUSH
65643: LD_INT 0
65645: PPUSH
65646: CALL_OW 1
65650: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
65651: LD_ADDR_EXP 74
65655: PUSH
65656: LD_EXP 74
65660: PPUSH
65661: LD_VAR 0 4
65665: PPUSH
65666: LD_INT 0
65668: PPUSH
65669: CALL_OW 1
65673: ST_TO_ADDR
// result := base ;
65674: LD_ADDR_VAR 0 3
65678: PUSH
65679: LD_VAR 0 4
65683: ST_TO_ADDR
// end ;
65684: LD_VAR 0 3
65688: RET
// export function MC_Start ( ) ; var i ; begin
65689: LD_INT 0
65691: PPUSH
65692: PPUSH
// for i = 1 to mc_bases do
65693: LD_ADDR_VAR 0 2
65697: PUSH
65698: DOUBLE
65699: LD_INT 1
65701: DEC
65702: ST_TO_ADDR
65703: LD_EXP 31
65707: PUSH
65708: FOR_TO
65709: IFFALSE 66809
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
65711: LD_ADDR_EXP 31
65715: PUSH
65716: LD_EXP 31
65720: PPUSH
65721: LD_VAR 0 2
65725: PPUSH
65726: LD_EXP 31
65730: PUSH
65731: LD_VAR 0 2
65735: ARRAY
65736: PUSH
65737: LD_INT 0
65739: DIFF
65740: PPUSH
65741: CALL_OW 1
65745: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
65746: LD_ADDR_EXP 32
65750: PUSH
65751: LD_EXP 32
65755: PPUSH
65756: LD_VAR 0 2
65760: PPUSH
65761: EMPTY
65762: PPUSH
65763: CALL_OW 1
65767: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65768: LD_ADDR_EXP 33
65772: PUSH
65773: LD_EXP 33
65777: PPUSH
65778: LD_VAR 0 2
65782: PPUSH
65783: EMPTY
65784: PPUSH
65785: CALL_OW 1
65789: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
65790: LD_ADDR_EXP 34
65794: PUSH
65795: LD_EXP 34
65799: PPUSH
65800: LD_VAR 0 2
65804: PPUSH
65805: EMPTY
65806: PPUSH
65807: CALL_OW 1
65811: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
65812: LD_ADDR_EXP 35
65816: PUSH
65817: LD_EXP 35
65821: PPUSH
65822: LD_VAR 0 2
65826: PPUSH
65827: EMPTY
65828: PUSH
65829: EMPTY
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PPUSH
65835: CALL_OW 1
65839: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
65840: LD_ADDR_EXP 36
65844: PUSH
65845: LD_EXP 36
65849: PPUSH
65850: LD_VAR 0 2
65854: PPUSH
65855: EMPTY
65856: PPUSH
65857: CALL_OW 1
65861: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
65862: LD_ADDR_EXP 63
65866: PUSH
65867: LD_EXP 63
65871: PPUSH
65872: LD_VAR 0 2
65876: PPUSH
65877: EMPTY
65878: PPUSH
65879: CALL_OW 1
65883: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
65884: LD_ADDR_EXP 37
65888: PUSH
65889: LD_EXP 37
65893: PPUSH
65894: LD_VAR 0 2
65898: PPUSH
65899: EMPTY
65900: PPUSH
65901: CALL_OW 1
65905: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
65906: LD_ADDR_EXP 38
65910: PUSH
65911: LD_EXP 38
65915: PPUSH
65916: LD_VAR 0 2
65920: PPUSH
65921: EMPTY
65922: PPUSH
65923: CALL_OW 1
65927: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
65928: LD_ADDR_EXP 39
65932: PUSH
65933: LD_EXP 39
65937: PPUSH
65938: LD_VAR 0 2
65942: PPUSH
65943: LD_EXP 31
65947: PUSH
65948: LD_VAR 0 2
65952: ARRAY
65953: PPUSH
65954: LD_INT 2
65956: PUSH
65957: LD_INT 30
65959: PUSH
65960: LD_INT 32
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PUSH
65967: LD_INT 30
65969: PUSH
65970: LD_INT 33
65972: PUSH
65973: EMPTY
65974: LIST
65975: LIST
65976: PUSH
65977: EMPTY
65978: LIST
65979: LIST
65980: LIST
65981: PPUSH
65982: CALL_OW 72
65986: PPUSH
65987: CALL_OW 1
65991: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
65992: LD_ADDR_EXP 40
65996: PUSH
65997: LD_EXP 40
66001: PPUSH
66002: LD_VAR 0 2
66006: PPUSH
66007: LD_EXP 31
66011: PUSH
66012: LD_VAR 0 2
66016: ARRAY
66017: PPUSH
66018: LD_INT 2
66020: PUSH
66021: LD_INT 30
66023: PUSH
66024: LD_INT 32
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 30
66033: PUSH
66034: LD_INT 31
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: LIST
66045: PUSH
66046: LD_INT 58
66048: PUSH
66049: EMPTY
66050: LIST
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PPUSH
66056: CALL_OW 72
66060: PPUSH
66061: CALL_OW 1
66065: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
66066: LD_ADDR_EXP 41
66070: PUSH
66071: LD_EXP 41
66075: PPUSH
66076: LD_VAR 0 2
66080: PPUSH
66081: EMPTY
66082: PPUSH
66083: CALL_OW 1
66087: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
66088: LD_ADDR_EXP 45
66092: PUSH
66093: LD_EXP 45
66097: PPUSH
66098: LD_VAR 0 2
66102: PPUSH
66103: EMPTY
66104: PPUSH
66105: CALL_OW 1
66109: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
66110: LD_ADDR_EXP 44
66114: PUSH
66115: LD_EXP 44
66119: PPUSH
66120: LD_VAR 0 2
66124: PPUSH
66125: EMPTY
66126: PPUSH
66127: CALL_OW 1
66131: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
66132: LD_ADDR_EXP 46
66136: PUSH
66137: LD_EXP 46
66141: PPUSH
66142: LD_VAR 0 2
66146: PPUSH
66147: EMPTY
66148: PPUSH
66149: CALL_OW 1
66153: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
66154: LD_ADDR_EXP 47
66158: PUSH
66159: LD_EXP 47
66163: PPUSH
66164: LD_VAR 0 2
66168: PPUSH
66169: EMPTY
66170: PPUSH
66171: CALL_OW 1
66175: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66176: LD_ADDR_EXP 48
66180: PUSH
66181: LD_EXP 48
66185: PPUSH
66186: LD_VAR 0 2
66190: PPUSH
66191: EMPTY
66192: PPUSH
66193: CALL_OW 1
66197: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
66198: LD_ADDR_EXP 49
66202: PUSH
66203: LD_EXP 49
66207: PPUSH
66208: LD_VAR 0 2
66212: PPUSH
66213: EMPTY
66214: PPUSH
66215: CALL_OW 1
66219: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
66220: LD_ADDR_EXP 50
66224: PUSH
66225: LD_EXP 50
66229: PPUSH
66230: LD_VAR 0 2
66234: PPUSH
66235: EMPTY
66236: PPUSH
66237: CALL_OW 1
66241: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66242: LD_ADDR_EXP 51
66246: PUSH
66247: LD_EXP 51
66251: PPUSH
66252: LD_VAR 0 2
66256: PPUSH
66257: EMPTY
66258: PPUSH
66259: CALL_OW 1
66263: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
66264: LD_ADDR_EXP 52
66268: PUSH
66269: LD_EXP 52
66273: PPUSH
66274: LD_VAR 0 2
66278: PPUSH
66279: EMPTY
66280: PPUSH
66281: CALL_OW 1
66285: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66286: LD_ADDR_EXP 53
66290: PUSH
66291: LD_EXP 53
66295: PPUSH
66296: LD_VAR 0 2
66300: PPUSH
66301: EMPTY
66302: PPUSH
66303: CALL_OW 1
66307: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
66308: LD_ADDR_EXP 42
66312: PUSH
66313: LD_EXP 42
66317: PPUSH
66318: LD_VAR 0 2
66322: PPUSH
66323: LD_INT 0
66325: PPUSH
66326: CALL_OW 1
66330: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
66331: LD_ADDR_EXP 55
66335: PUSH
66336: LD_EXP 55
66340: PPUSH
66341: LD_VAR 0 2
66345: PPUSH
66346: LD_INT 0
66348: PPUSH
66349: CALL_OW 1
66353: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
66354: LD_ADDR_EXP 43
66358: PUSH
66359: LD_EXP 43
66363: PPUSH
66364: LD_VAR 0 2
66368: PPUSH
66369: EMPTY
66370: PPUSH
66371: CALL_OW 1
66375: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
66376: LD_ADDR_EXP 54
66380: PUSH
66381: LD_EXP 54
66385: PPUSH
66386: LD_VAR 0 2
66390: PPUSH
66391: LD_INT 0
66393: PPUSH
66394: CALL_OW 1
66398: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
66399: LD_ADDR_EXP 56
66403: PUSH
66404: LD_EXP 56
66408: PPUSH
66409: LD_VAR 0 2
66413: PPUSH
66414: EMPTY
66415: PPUSH
66416: CALL_OW 1
66420: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
66421: LD_ADDR_EXP 59
66425: PUSH
66426: LD_EXP 59
66430: PPUSH
66431: LD_VAR 0 2
66435: PPUSH
66436: LD_INT 0
66438: PPUSH
66439: CALL_OW 1
66443: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
66444: LD_ADDR_EXP 60
66448: PUSH
66449: LD_EXP 60
66453: PPUSH
66454: LD_VAR 0 2
66458: PPUSH
66459: EMPTY
66460: PPUSH
66461: CALL_OW 1
66465: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66466: LD_ADDR_EXP 61
66470: PUSH
66471: LD_EXP 61
66475: PPUSH
66476: LD_VAR 0 2
66480: PPUSH
66481: EMPTY
66482: PPUSH
66483: CALL_OW 1
66487: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66488: LD_ADDR_EXP 62
66492: PUSH
66493: LD_EXP 62
66497: PPUSH
66498: LD_VAR 0 2
66502: PPUSH
66503: EMPTY
66504: PPUSH
66505: CALL_OW 1
66509: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
66510: LD_ADDR_EXP 64
66514: PUSH
66515: LD_EXP 64
66519: PPUSH
66520: LD_VAR 0 2
66524: PPUSH
66525: LD_EXP 31
66529: PUSH
66530: LD_VAR 0 2
66534: ARRAY
66535: PPUSH
66536: LD_INT 2
66538: PUSH
66539: LD_INT 30
66541: PUSH
66542: LD_INT 6
66544: PUSH
66545: EMPTY
66546: LIST
66547: LIST
66548: PUSH
66549: LD_INT 30
66551: PUSH
66552: LD_INT 7
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 30
66561: PUSH
66562: LD_INT 8
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: PPUSH
66575: CALL_OW 72
66579: PPUSH
66580: CALL_OW 1
66584: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
66585: LD_ADDR_EXP 65
66589: PUSH
66590: LD_EXP 65
66594: PPUSH
66595: LD_VAR 0 2
66599: PPUSH
66600: EMPTY
66601: PPUSH
66602: CALL_OW 1
66606: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
66607: LD_ADDR_EXP 66
66611: PUSH
66612: LD_EXP 66
66616: PPUSH
66617: LD_VAR 0 2
66621: PPUSH
66622: EMPTY
66623: PPUSH
66624: CALL_OW 1
66628: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
66629: LD_ADDR_EXP 67
66633: PUSH
66634: LD_EXP 67
66638: PPUSH
66639: LD_VAR 0 2
66643: PPUSH
66644: EMPTY
66645: PPUSH
66646: CALL_OW 1
66650: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
66651: LD_ADDR_EXP 68
66655: PUSH
66656: LD_EXP 68
66660: PPUSH
66661: LD_VAR 0 2
66665: PPUSH
66666: EMPTY
66667: PPUSH
66668: CALL_OW 1
66672: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
66673: LD_ADDR_EXP 69
66677: PUSH
66678: LD_EXP 69
66682: PPUSH
66683: LD_VAR 0 2
66687: PPUSH
66688: EMPTY
66689: PPUSH
66690: CALL_OW 1
66694: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
66695: LD_ADDR_EXP 70
66699: PUSH
66700: LD_EXP 70
66704: PPUSH
66705: LD_VAR 0 2
66709: PPUSH
66710: EMPTY
66711: PPUSH
66712: CALL_OW 1
66716: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
66717: LD_ADDR_EXP 71
66721: PUSH
66722: LD_EXP 71
66726: PPUSH
66727: LD_VAR 0 2
66731: PPUSH
66732: EMPTY
66733: PPUSH
66734: CALL_OW 1
66738: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
66739: LD_ADDR_EXP 72
66743: PUSH
66744: LD_EXP 72
66748: PPUSH
66749: LD_VAR 0 2
66753: PPUSH
66754: EMPTY
66755: PPUSH
66756: CALL_OW 1
66760: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
66761: LD_ADDR_EXP 73
66765: PUSH
66766: LD_EXP 73
66770: PPUSH
66771: LD_VAR 0 2
66775: PPUSH
66776: LD_INT 0
66778: PPUSH
66779: CALL_OW 1
66783: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
66784: LD_ADDR_EXP 74
66788: PUSH
66789: LD_EXP 74
66793: PPUSH
66794: LD_VAR 0 2
66798: PPUSH
66799: LD_INT 0
66801: PPUSH
66802: CALL_OW 1
66806: ST_TO_ADDR
// end ;
66807: GO 65708
66809: POP
66810: POP
// MC_InitSides ( ) ;
66811: CALL 67097 0 0
// MC_InitResearch ( ) ;
66815: CALL 66836 0 0
// CustomInitMacro ( ) ;
66819: CALL 1382 0 0
// skirmish := true ;
66823: LD_ADDR_EXP 29
66827: PUSH
66828: LD_INT 1
66830: ST_TO_ADDR
// end ;
66831: LD_VAR 0 1
66835: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
66836: LD_INT 0
66838: PPUSH
66839: PPUSH
66840: PPUSH
66841: PPUSH
66842: PPUSH
66843: PPUSH
// if not mc_bases then
66844: LD_EXP 31
66848: NOT
66849: IFFALSE 66853
// exit ;
66851: GO 67092
// for i = 1 to 8 do
66853: LD_ADDR_VAR 0 2
66857: PUSH
66858: DOUBLE
66859: LD_INT 1
66861: DEC
66862: ST_TO_ADDR
66863: LD_INT 8
66865: PUSH
66866: FOR_TO
66867: IFFALSE 66893
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
66869: LD_ADDR_EXP 58
66873: PUSH
66874: LD_EXP 58
66878: PPUSH
66879: LD_VAR 0 2
66883: PPUSH
66884: EMPTY
66885: PPUSH
66886: CALL_OW 1
66890: ST_TO_ADDR
66891: GO 66866
66893: POP
66894: POP
// tmp := [ ] ;
66895: LD_ADDR_VAR 0 5
66899: PUSH
66900: EMPTY
66901: ST_TO_ADDR
// for i = 1 to mc_sides do
66902: LD_ADDR_VAR 0 2
66906: PUSH
66907: DOUBLE
66908: LD_INT 1
66910: DEC
66911: ST_TO_ADDR
66912: LD_EXP 57
66916: PUSH
66917: FOR_TO
66918: IFFALSE 66976
// if not mc_sides [ i ] in tmp then
66920: LD_EXP 57
66924: PUSH
66925: LD_VAR 0 2
66929: ARRAY
66930: PUSH
66931: LD_VAR 0 5
66935: IN
66936: NOT
66937: IFFALSE 66974
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
66939: LD_ADDR_VAR 0 5
66943: PUSH
66944: LD_VAR 0 5
66948: PPUSH
66949: LD_VAR 0 5
66953: PUSH
66954: LD_INT 1
66956: PLUS
66957: PPUSH
66958: LD_EXP 57
66962: PUSH
66963: LD_VAR 0 2
66967: ARRAY
66968: PPUSH
66969: CALL_OW 2
66973: ST_TO_ADDR
66974: GO 66917
66976: POP
66977: POP
// if not tmp then
66978: LD_VAR 0 5
66982: NOT
66983: IFFALSE 66987
// exit ;
66985: GO 67092
// for j in tmp do
66987: LD_ADDR_VAR 0 3
66991: PUSH
66992: LD_VAR 0 5
66996: PUSH
66997: FOR_IN
66998: IFFALSE 67090
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
67000: LD_ADDR_VAR 0 6
67004: PUSH
67005: LD_INT 22
67007: PUSH
67008: LD_VAR 0 3
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PPUSH
67017: CALL_OW 69
67021: ST_TO_ADDR
// if not un then
67022: LD_VAR 0 6
67026: NOT
67027: IFFALSE 67031
// continue ;
67029: GO 66997
// nation := GetNation ( un [ 1 ] ) ;
67031: LD_ADDR_VAR 0 4
67035: PUSH
67036: LD_VAR 0 6
67040: PUSH
67041: LD_INT 1
67043: ARRAY
67044: PPUSH
67045: CALL_OW 248
67049: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
67050: LD_ADDR_EXP 58
67054: PUSH
67055: LD_EXP 58
67059: PPUSH
67060: LD_VAR 0 3
67064: PPUSH
67065: LD_VAR 0 3
67069: PPUSH
67070: LD_VAR 0 4
67074: PPUSH
67075: LD_INT 1
67077: PPUSH
67078: CALL 20102 0 3
67082: PPUSH
67083: CALL_OW 1
67087: ST_TO_ADDR
// end ;
67088: GO 66997
67090: POP
67091: POP
// end ;
67092: LD_VAR 0 1
67096: RET
// export function MC_InitSides ( ) ; var i ; begin
67097: LD_INT 0
67099: PPUSH
67100: PPUSH
// if not mc_bases then
67101: LD_EXP 31
67105: NOT
67106: IFFALSE 67110
// exit ;
67108: GO 67184
// for i = 1 to mc_bases do
67110: LD_ADDR_VAR 0 2
67114: PUSH
67115: DOUBLE
67116: LD_INT 1
67118: DEC
67119: ST_TO_ADDR
67120: LD_EXP 31
67124: PUSH
67125: FOR_TO
67126: IFFALSE 67182
// if mc_bases [ i ] then
67128: LD_EXP 31
67132: PUSH
67133: LD_VAR 0 2
67137: ARRAY
67138: IFFALSE 67180
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
67140: LD_ADDR_EXP 57
67144: PUSH
67145: LD_EXP 57
67149: PPUSH
67150: LD_VAR 0 2
67154: PPUSH
67155: LD_EXP 31
67159: PUSH
67160: LD_VAR 0 2
67164: ARRAY
67165: PUSH
67166: LD_INT 1
67168: ARRAY
67169: PPUSH
67170: CALL_OW 255
67174: PPUSH
67175: CALL_OW 1
67179: ST_TO_ADDR
67180: GO 67125
67182: POP
67183: POP
// end ;
67184: LD_VAR 0 1
67188: RET
// every 0 0$03 trigger skirmish do
67189: LD_EXP 29
67193: IFFALSE 67347
67195: GO 67197
67197: DISABLE
// begin enable ;
67198: ENABLE
// MC_CheckBuildings ( ) ;
67199: CALL 71905 0 0
// MC_CheckPeopleLife ( ) ;
67203: CALL 72066 0 0
// RaiseSailEvent ( 100 ) ;
67207: LD_INT 100
67209: PPUSH
67210: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
67214: LD_INT 103
67216: PPUSH
67217: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
67221: LD_INT 104
67223: PPUSH
67224: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
67228: LD_INT 105
67230: PPUSH
67231: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
67235: LD_INT 106
67237: PPUSH
67238: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
67242: LD_INT 107
67244: PPUSH
67245: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
67249: LD_INT 108
67251: PPUSH
67252: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
67256: LD_INT 109
67258: PPUSH
67259: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
67263: LD_INT 110
67265: PPUSH
67266: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
67270: LD_INT 111
67272: PPUSH
67273: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
67277: LD_INT 112
67279: PPUSH
67280: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
67284: LD_INT 113
67286: PPUSH
67287: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
67291: LD_INT 120
67293: PPUSH
67294: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
67298: LD_INT 121
67300: PPUSH
67301: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
67305: LD_INT 122
67307: PPUSH
67308: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
67312: LD_INT 123
67314: PPUSH
67315: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
67319: LD_INT 124
67321: PPUSH
67322: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
67326: LD_INT 125
67328: PPUSH
67329: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
67333: LD_INT 126
67335: PPUSH
67336: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
67340: LD_INT 200
67342: PPUSH
67343: CALL_OW 427
// end ;
67347: END
// on SailEvent ( event ) do begin if event < 100 then
67348: LD_VAR 0 1
67352: PUSH
67353: LD_INT 100
67355: LESS
67356: IFFALSE 67367
// CustomEvent ( event ) ;
67358: LD_VAR 0 1
67362: PPUSH
67363: CALL 19174 0 1
// if event = 100 then
67367: LD_VAR 0 1
67371: PUSH
67372: LD_INT 100
67374: EQUAL
67375: IFFALSE 67381
// MC_ClassManager ( ) ;
67377: CALL 67775 0 0
// if event = 101 then
67381: LD_VAR 0 1
67385: PUSH
67386: LD_INT 101
67388: EQUAL
67389: IFFALSE 67395
// MC_RepairBuildings ( ) ;
67391: CALL 72653 0 0
// if event = 102 then
67395: LD_VAR 0 1
67399: PUSH
67400: LD_INT 102
67402: EQUAL
67403: IFFALSE 67409
// MC_Heal ( ) ;
67405: CALL 73592 0 0
// if event = 103 then
67409: LD_VAR 0 1
67413: PUSH
67414: LD_INT 103
67416: EQUAL
67417: IFFALSE 67423
// MC_Build ( ) ;
67419: CALL 74018 0 0
// if event = 104 then
67423: LD_VAR 0 1
67427: PUSH
67428: LD_INT 104
67430: EQUAL
67431: IFFALSE 67437
// MC_TurretWeapon ( ) ;
67433: CALL 75666 0 0
// if event = 105 then
67437: LD_VAR 0 1
67441: PUSH
67442: LD_INT 105
67444: EQUAL
67445: IFFALSE 67451
// MC_BuildUpgrade ( ) ;
67447: CALL 75211 0 0
// if event = 106 then
67451: LD_VAR 0 1
67455: PUSH
67456: LD_INT 106
67458: EQUAL
67459: IFFALSE 67465
// MC_PlantMines ( ) ;
67461: CALL 76098 0 0
// if event = 107 then
67465: LD_VAR 0 1
67469: PUSH
67470: LD_INT 107
67472: EQUAL
67473: IFFALSE 67479
// MC_CollectCrates ( ) ;
67475: CALL 76908 0 0
// if event = 108 then
67479: LD_VAR 0 1
67483: PUSH
67484: LD_INT 108
67486: EQUAL
67487: IFFALSE 67493
// MC_LinkRemoteControl ( ) ;
67489: CALL 78782 0 0
// if event = 109 then
67493: LD_VAR 0 1
67497: PUSH
67498: LD_INT 109
67500: EQUAL
67501: IFFALSE 67507
// MC_ProduceVehicle ( ) ;
67503: CALL 78967 0 0
// if event = 110 then
67507: LD_VAR 0 1
67511: PUSH
67512: LD_INT 110
67514: EQUAL
67515: IFFALSE 67521
// MC_SendAttack ( ) ;
67517: CALL 79437 0 0
// if event = 111 then
67521: LD_VAR 0 1
67525: PUSH
67526: LD_INT 111
67528: EQUAL
67529: IFFALSE 67535
// MC_Defend ( ) ;
67531: CALL 79545 0 0
// if event = 112 then
67535: LD_VAR 0 1
67539: PUSH
67540: LD_INT 112
67542: EQUAL
67543: IFFALSE 67549
// MC_Research ( ) ;
67545: CALL 80445 0 0
// if event = 113 then
67549: LD_VAR 0 1
67553: PUSH
67554: LD_INT 113
67556: EQUAL
67557: IFFALSE 67563
// MC_MinesTrigger ( ) ;
67559: CALL 81585 0 0
// if event = 120 then
67563: LD_VAR 0 1
67567: PUSH
67568: LD_INT 120
67570: EQUAL
67571: IFFALSE 67577
// MC_RepairVehicle ( ) ;
67573: CALL 81686 0 0
// if event = 121 then
67577: LD_VAR 0 1
67581: PUSH
67582: LD_INT 121
67584: EQUAL
67585: IFFALSE 67591
// MC_TameApe ( ) ;
67587: CALL 82463 0 0
// if event = 122 then
67591: LD_VAR 0 1
67595: PUSH
67596: LD_INT 122
67598: EQUAL
67599: IFFALSE 67605
// MC_ChangeApeClass ( ) ;
67601: CALL 83308 0 0
// if event = 123 then
67605: LD_VAR 0 1
67609: PUSH
67610: LD_INT 123
67612: EQUAL
67613: IFFALSE 67619
// MC_Bazooka ( ) ;
67615: CALL 83964 0 0
// if event = 124 then
67619: LD_VAR 0 1
67623: PUSH
67624: LD_INT 124
67626: EQUAL
67627: IFFALSE 67633
// MC_TeleportExit ( ) ;
67629: CALL 84166 0 0
// if event = 125 then
67633: LD_VAR 0 1
67637: PUSH
67638: LD_INT 125
67640: EQUAL
67641: IFFALSE 67647
// MC_Deposits ( ) ;
67643: CALL 84823 0 0
// if event = 126 then
67647: LD_VAR 0 1
67651: PUSH
67652: LD_INT 126
67654: EQUAL
67655: IFFALSE 67661
// MC_RemoteDriver ( ) ;
67657: CALL 85456 0 0
// if event = 200 then
67661: LD_VAR 0 1
67665: PUSH
67666: LD_INT 200
67668: EQUAL
67669: IFFALSE 67675
// MC_Idle ( ) ;
67671: CALL 87391 0 0
// end ;
67675: PPOPN 1
67677: END
// export function MC_Reset ( base , tag ) ; var i ; begin
67678: LD_INT 0
67680: PPUSH
67681: PPUSH
// if not mc_bases [ base ] or not tag then
67682: LD_EXP 31
67686: PUSH
67687: LD_VAR 0 1
67691: ARRAY
67692: NOT
67693: IFTRUE 67702
67695: PUSH
67696: LD_VAR 0 2
67700: NOT
67701: OR
67702: IFFALSE 67706
// exit ;
67704: GO 67770
// for i in mc_bases [ base ] union mc_ape [ base ] do
67706: LD_ADDR_VAR 0 4
67710: PUSH
67711: LD_EXP 31
67715: PUSH
67716: LD_VAR 0 1
67720: ARRAY
67721: PUSH
67722: LD_EXP 60
67726: PUSH
67727: LD_VAR 0 1
67731: ARRAY
67732: UNION
67733: PUSH
67734: FOR_IN
67735: IFFALSE 67768
// if GetTag ( i ) = tag then
67737: LD_VAR 0 4
67741: PPUSH
67742: CALL_OW 110
67746: PUSH
67747: LD_VAR 0 2
67751: EQUAL
67752: IFFALSE 67766
// SetTag ( i , 0 ) ;
67754: LD_VAR 0 4
67758: PPUSH
67759: LD_INT 0
67761: PPUSH
67762: CALL_OW 109
67766: GO 67734
67768: POP
67769: POP
// end ;
67770: LD_VAR 0 3
67774: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
67775: LD_INT 0
67777: PPUSH
67778: PPUSH
67779: PPUSH
67780: PPUSH
67781: PPUSH
67782: PPUSH
67783: PPUSH
67784: PPUSH
// if not mc_bases then
67785: LD_EXP 31
67789: NOT
67790: IFFALSE 67794
// exit ;
67792: GO 68245
// for i = 1 to mc_bases do
67794: LD_ADDR_VAR 0 2
67798: PUSH
67799: DOUBLE
67800: LD_INT 1
67802: DEC
67803: ST_TO_ADDR
67804: LD_EXP 31
67808: PUSH
67809: FOR_TO
67810: IFFALSE 68243
// begin tmp := MC_ClassCheckReq ( i ) ;
67812: LD_ADDR_VAR 0 4
67816: PUSH
67817: LD_VAR 0 2
67821: PPUSH
67822: CALL 68250 0 1
67826: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
67827: LD_ADDR_EXP 72
67831: PUSH
67832: LD_EXP 72
67836: PPUSH
67837: LD_VAR 0 2
67841: PPUSH
67842: LD_VAR 0 4
67846: PPUSH
67847: CALL_OW 1
67851: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
67852: LD_ADDR_VAR 0 6
67856: PUSH
67857: LD_EXP 31
67861: PUSH
67862: LD_VAR 0 2
67866: ARRAY
67867: PPUSH
67868: LD_INT 2
67870: PUSH
67871: LD_INT 30
67873: PUSH
67874: LD_INT 4
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 30
67883: PUSH
67884: LD_INT 5
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: LIST
67895: PPUSH
67896: CALL_OW 72
67900: PUSH
67901: LD_EXP 31
67905: PUSH
67906: LD_VAR 0 2
67910: ARRAY
67911: PPUSH
67912: LD_INT 2
67914: PUSH
67915: LD_INT 30
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: LD_INT 30
67927: PUSH
67928: LD_INT 1
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: LIST
67939: PPUSH
67940: CALL_OW 72
67944: PUSH
67945: LD_EXP 31
67949: PUSH
67950: LD_VAR 0 2
67954: ARRAY
67955: PPUSH
67956: LD_INT 30
67958: PUSH
67959: LD_INT 3
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PPUSH
67966: CALL_OW 72
67970: PUSH
67971: LD_EXP 31
67975: PUSH
67976: LD_VAR 0 2
67980: ARRAY
67981: PPUSH
67982: LD_INT 2
67984: PUSH
67985: LD_INT 30
67987: PUSH
67988: LD_INT 6
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 30
67997: PUSH
67998: LD_INT 7
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 30
68007: PUSH
68008: LD_INT 8
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: PPUSH
68021: CALL_OW 72
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: ST_TO_ADDR
// for j := 1 to 4 do
68032: LD_ADDR_VAR 0 3
68036: PUSH
68037: DOUBLE
68038: LD_INT 1
68040: DEC
68041: ST_TO_ADDR
68042: LD_INT 4
68044: PUSH
68045: FOR_TO
68046: IFFALSE 68239
// begin if not tmp [ j ] then
68048: LD_VAR 0 4
68052: PUSH
68053: LD_VAR 0 3
68057: ARRAY
68058: NOT
68059: IFFALSE 68063
// continue ;
68061: GO 68045
// for p in tmp [ j ] do
68063: LD_ADDR_VAR 0 5
68067: PUSH
68068: LD_VAR 0 4
68072: PUSH
68073: LD_VAR 0 3
68077: ARRAY
68078: PUSH
68079: FOR_IN
68080: IFFALSE 68235
// begin if not b [ j ] then
68082: LD_VAR 0 6
68086: PUSH
68087: LD_VAR 0 3
68091: ARRAY
68092: NOT
68093: IFFALSE 68097
// break ;
68095: GO 68235
// e := 0 ;
68097: LD_ADDR_VAR 0 7
68101: PUSH
68102: LD_INT 0
68104: ST_TO_ADDR
// for k in b [ j ] do
68105: LD_ADDR_VAR 0 8
68109: PUSH
68110: LD_VAR 0 6
68114: PUSH
68115: LD_VAR 0 3
68119: ARRAY
68120: PUSH
68121: FOR_IN
68122: IFFALSE 68149
// if IsNotFull ( k ) then
68124: LD_VAR 0 8
68128: PPUSH
68129: CALL 22261 0 1
68133: IFFALSE 68147
// begin e := k ;
68135: LD_ADDR_VAR 0 7
68139: PUSH
68140: LD_VAR 0 8
68144: ST_TO_ADDR
// break ;
68145: GO 68149
// end ;
68147: GO 68121
68149: POP
68150: POP
// if e and not UnitGoingToBuilding ( p , e ) then
68151: LD_VAR 0 7
68155: IFFALSE 68174
68157: PUSH
68158: LD_VAR 0 5
68162: PPUSH
68163: LD_VAR 0 7
68167: PPUSH
68168: CALL 56765 0 2
68172: NOT
68173: AND
68174: IFFALSE 68233
// begin if IsInUnit ( p ) then
68176: LD_VAR 0 5
68180: PPUSH
68181: CALL_OW 310
68185: IFFALSE 68196
// ComExitBuilding ( p ) ;
68187: LD_VAR 0 5
68191: PPUSH
68192: CALL_OW 122
// ComEnterUnit ( p , e ) ;
68196: LD_VAR 0 5
68200: PPUSH
68201: LD_VAR 0 7
68205: PPUSH
68206: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
68210: LD_VAR 0 5
68214: PPUSH
68215: LD_VAR 0 3
68219: PPUSH
68220: CALL_OW 183
// AddComExitBuilding ( p ) ;
68224: LD_VAR 0 5
68228: PPUSH
68229: CALL_OW 182
// end ; end ;
68233: GO 68079
68235: POP
68236: POP
// end ;
68237: GO 68045
68239: POP
68240: POP
// end ;
68241: GO 67809
68243: POP
68244: POP
// end ;
68245: LD_VAR 0 1
68249: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
68250: LD_INT 0
68252: PPUSH
68253: PPUSH
68254: PPUSH
68255: PPUSH
68256: PPUSH
68257: PPUSH
68258: PPUSH
68259: PPUSH
68260: PPUSH
68261: PPUSH
68262: PPUSH
68263: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
68264: LD_ADDR_VAR 0 2
68268: PUSH
68269: LD_INT 0
68271: PUSH
68272: LD_INT 0
68274: PUSH
68275: LD_INT 0
68277: PUSH
68278: LD_INT 0
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68287: LD_VAR 0 1
68291: NOT
68292: IFTRUE 68307
68294: PUSH
68295: LD_EXP 31
68299: PUSH
68300: LD_VAR 0 1
68304: ARRAY
68305: NOT
68306: OR
68307: IFTRUE 68355
68309: PUSH
68310: LD_EXP 31
68314: PUSH
68315: LD_VAR 0 1
68319: ARRAY
68320: PPUSH
68321: LD_INT 2
68323: PUSH
68324: LD_INT 30
68326: PUSH
68327: LD_INT 0
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: PUSH
68334: LD_INT 30
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: LIST
68348: PPUSH
68349: CALL_OW 72
68353: NOT
68354: OR
68355: IFFALSE 68359
// exit ;
68357: GO 71900
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68359: LD_ADDR_VAR 0 4
68363: PUSH
68364: LD_EXP 31
68368: PUSH
68369: LD_VAR 0 1
68373: ARRAY
68374: PPUSH
68375: LD_INT 2
68377: PUSH
68378: LD_INT 25
68380: PUSH
68381: LD_INT 1
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 25
68390: PUSH
68391: LD_INT 2
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 25
68400: PUSH
68401: LD_INT 3
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 25
68410: PUSH
68411: LD_INT 4
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 25
68420: PUSH
68421: LD_INT 5
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 25
68430: PUSH
68431: LD_INT 8
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 25
68440: PUSH
68441: LD_INT 9
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: PPUSH
68458: CALL_OW 72
68462: ST_TO_ADDR
// if not tmp then
68463: LD_VAR 0 4
68467: NOT
68468: IFFALSE 68472
// exit ;
68470: GO 71900
// for i in tmp do
68472: LD_ADDR_VAR 0 3
68476: PUSH
68477: LD_VAR 0 4
68481: PUSH
68482: FOR_IN
68483: IFFALSE 68514
// if GetTag ( i ) then
68485: LD_VAR 0 3
68489: PPUSH
68490: CALL_OW 110
68494: IFFALSE 68512
// tmp := tmp diff i ;
68496: LD_ADDR_VAR 0 4
68500: PUSH
68501: LD_VAR 0 4
68505: PUSH
68506: LD_VAR 0 3
68510: DIFF
68511: ST_TO_ADDR
68512: GO 68482
68514: POP
68515: POP
// if not tmp then
68516: LD_VAR 0 4
68520: NOT
68521: IFFALSE 68525
// exit ;
68523: GO 71900
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68525: LD_ADDR_VAR 0 5
68529: PUSH
68530: LD_EXP 31
68534: PUSH
68535: LD_VAR 0 1
68539: ARRAY
68540: PPUSH
68541: LD_INT 2
68543: PUSH
68544: LD_INT 25
68546: PUSH
68547: LD_INT 1
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: LD_INT 25
68556: PUSH
68557: LD_INT 5
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 25
68566: PUSH
68567: LD_INT 8
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 25
68576: PUSH
68577: LD_INT 9
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: PPUSH
68591: CALL_OW 72
68595: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
68596: LD_ADDR_VAR 0 6
68600: PUSH
68601: LD_EXP 31
68605: PUSH
68606: LD_VAR 0 1
68610: ARRAY
68611: PPUSH
68612: LD_INT 25
68614: PUSH
68615: LD_INT 2
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PPUSH
68622: CALL_OW 72
68626: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
68627: LD_ADDR_VAR 0 7
68631: PUSH
68632: LD_EXP 31
68636: PUSH
68637: LD_VAR 0 1
68641: ARRAY
68642: PPUSH
68643: LD_INT 25
68645: PUSH
68646: LD_INT 3
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PPUSH
68653: CALL_OW 72
68657: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
68658: LD_ADDR_VAR 0 8
68662: PUSH
68663: LD_EXP 31
68667: PUSH
68668: LD_VAR 0 1
68672: ARRAY
68673: PPUSH
68674: LD_INT 25
68676: PUSH
68677: LD_INT 4
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 24
68686: PUSH
68687: LD_INT 251
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PPUSH
68698: CALL_OW 72
68702: ST_TO_ADDR
// if mc_is_defending [ base ] then
68703: LD_EXP 74
68707: PUSH
68708: LD_VAR 0 1
68712: ARRAY
68713: IFFALSE 69174
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
68715: LD_ADDR_EXP 73
68719: PUSH
68720: LD_EXP 73
68724: PPUSH
68725: LD_VAR 0 1
68729: PPUSH
68730: LD_INT 4
68732: PPUSH
68733: CALL_OW 1
68737: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68738: LD_ADDR_VAR 0 12
68742: PUSH
68743: LD_EXP 31
68747: PUSH
68748: LD_VAR 0 1
68752: ARRAY
68753: PPUSH
68754: LD_INT 2
68756: PUSH
68757: LD_INT 30
68759: PUSH
68760: LD_INT 4
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 30
68769: PUSH
68770: LD_INT 5
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: LIST
68781: PPUSH
68782: CALL_OW 72
68786: ST_TO_ADDR
// if not b then
68787: LD_VAR 0 12
68791: NOT
68792: IFFALSE 68796
// exit ;
68794: GO 71900
// p := [ ] ;
68796: LD_ADDR_VAR 0 11
68800: PUSH
68801: EMPTY
68802: ST_TO_ADDR
// if sci >= 2 then
68803: LD_VAR 0 8
68807: PUSH
68808: LD_INT 2
68810: GREATEREQUAL
68811: IFFALSE 68842
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
68813: LD_ADDR_VAR 0 8
68817: PUSH
68818: LD_VAR 0 8
68822: PUSH
68823: LD_INT 1
68825: ARRAY
68826: PUSH
68827: LD_VAR 0 8
68831: PUSH
68832: LD_INT 2
68834: ARRAY
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: ST_TO_ADDR
68840: GO 68903
// if sci = 1 then
68842: LD_VAR 0 8
68846: PUSH
68847: LD_INT 1
68849: EQUAL
68850: IFFALSE 68871
// sci := [ sci [ 1 ] ] else
68852: LD_ADDR_VAR 0 8
68856: PUSH
68857: LD_VAR 0 8
68861: PUSH
68862: LD_INT 1
68864: ARRAY
68865: PUSH
68866: EMPTY
68867: LIST
68868: ST_TO_ADDR
68869: GO 68903
// if sci = 0 then
68871: LD_VAR 0 8
68875: PUSH
68876: LD_INT 0
68878: EQUAL
68879: IFFALSE 68903
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
68881: LD_ADDR_VAR 0 11
68885: PUSH
68886: LD_VAR 0 4
68890: PPUSH
68891: LD_INT 4
68893: PPUSH
68894: CALL 56635 0 2
68898: PUSH
68899: LD_INT 1
68901: ARRAY
68902: ST_TO_ADDR
// if eng > 4 then
68903: LD_VAR 0 6
68907: PUSH
68908: LD_INT 4
68910: GREATER
68911: IFFALSE 68957
// for i = eng downto 4 do
68913: LD_ADDR_VAR 0 3
68917: PUSH
68918: DOUBLE
68919: LD_VAR 0 6
68923: INC
68924: ST_TO_ADDR
68925: LD_INT 4
68927: PUSH
68928: FOR_DOWNTO
68929: IFFALSE 68955
// eng := eng diff eng [ i ] ;
68931: LD_ADDR_VAR 0 6
68935: PUSH
68936: LD_VAR 0 6
68940: PUSH
68941: LD_VAR 0 6
68945: PUSH
68946: LD_VAR 0 3
68950: ARRAY
68951: DIFF
68952: ST_TO_ADDR
68953: GO 68928
68955: POP
68956: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
68957: LD_ADDR_VAR 0 4
68961: PUSH
68962: LD_VAR 0 4
68966: PUSH
68967: LD_VAR 0 5
68971: PUSH
68972: LD_VAR 0 6
68976: UNION
68977: PUSH
68978: LD_VAR 0 7
68982: UNION
68983: PUSH
68984: LD_VAR 0 8
68988: UNION
68989: DIFF
68990: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
68991: LD_ADDR_VAR 0 13
68995: PUSH
68996: LD_EXP 31
69000: PUSH
69001: LD_VAR 0 1
69005: ARRAY
69006: PPUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 30
69012: PUSH
69013: LD_INT 32
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 30
69022: PUSH
69023: LD_INT 31
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: LIST
69034: PPUSH
69035: CALL_OW 72
69039: PUSH
69040: LD_EXP 31
69044: PUSH
69045: LD_VAR 0 1
69049: ARRAY
69050: PPUSH
69051: LD_INT 2
69053: PUSH
69054: LD_INT 30
69056: PUSH
69057: LD_INT 4
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 30
69066: PUSH
69067: LD_INT 5
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: EMPTY
69075: LIST
69076: LIST
69077: LIST
69078: PPUSH
69079: CALL_OW 72
69083: PUSH
69084: LD_INT 6
69086: MUL
69087: PLUS
69088: ST_TO_ADDR
// if bcount < tmp then
69089: LD_VAR 0 13
69093: PUSH
69094: LD_VAR 0 4
69098: LESS
69099: IFFALSE 69145
// for i = tmp downto bcount do
69101: LD_ADDR_VAR 0 3
69105: PUSH
69106: DOUBLE
69107: LD_VAR 0 4
69111: INC
69112: ST_TO_ADDR
69113: LD_VAR 0 13
69117: PUSH
69118: FOR_DOWNTO
69119: IFFALSE 69143
// tmp := Delete ( tmp , tmp ) ;
69121: LD_ADDR_VAR 0 4
69125: PUSH
69126: LD_VAR 0 4
69130: PPUSH
69131: LD_VAR 0 4
69135: PPUSH
69136: CALL_OW 3
69140: ST_TO_ADDR
69141: GO 69118
69143: POP
69144: POP
// result := [ tmp , 0 , 0 , p ] ;
69145: LD_ADDR_VAR 0 2
69149: PUSH
69150: LD_VAR 0 4
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: LD_INT 0
69160: PUSH
69161: LD_VAR 0 11
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: ST_TO_ADDR
// exit ;
69172: GO 71900
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
69174: LD_EXP 31
69178: PUSH
69179: LD_VAR 0 1
69183: ARRAY
69184: PPUSH
69185: LD_INT 2
69187: PUSH
69188: LD_INT 30
69190: PUSH
69191: LD_INT 6
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 30
69200: PUSH
69201: LD_INT 7
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 30
69210: PUSH
69211: LD_INT 8
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: PPUSH
69224: CALL_OW 72
69228: NOT
69229: IFFALSE 69259
69231: PUSH
69232: LD_EXP 31
69236: PUSH
69237: LD_VAR 0 1
69241: ARRAY
69242: PPUSH
69243: LD_INT 30
69245: PUSH
69246: LD_INT 3
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PPUSH
69253: CALL_OW 72
69257: NOT
69258: AND
69259: IFFALSE 69331
// begin if eng = tmp then
69261: LD_VAR 0 6
69265: PUSH
69266: LD_VAR 0 4
69270: EQUAL
69271: IFFALSE 69275
// exit ;
69273: GO 71900
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
69275: LD_ADDR_EXP 73
69279: PUSH
69280: LD_EXP 73
69284: PPUSH
69285: LD_VAR 0 1
69289: PPUSH
69290: LD_INT 1
69292: PPUSH
69293: CALL_OW 1
69297: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
69298: LD_ADDR_VAR 0 2
69302: PUSH
69303: LD_INT 0
69305: PUSH
69306: LD_VAR 0 4
69310: PUSH
69311: LD_VAR 0 6
69315: DIFF
69316: PUSH
69317: LD_INT 0
69319: PUSH
69320: LD_INT 0
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: ST_TO_ADDR
// exit ;
69329: GO 71900
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
69331: LD_EXP 58
69335: PUSH
69336: LD_EXP 57
69340: PUSH
69341: LD_VAR 0 1
69345: ARRAY
69346: ARRAY
69347: IFFALSE 69405
69349: PUSH
69350: LD_EXP 31
69354: PUSH
69355: LD_VAR 0 1
69359: ARRAY
69360: PPUSH
69361: LD_INT 2
69363: PUSH
69364: LD_INT 30
69366: PUSH
69367: LD_INT 6
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 30
69376: PUSH
69377: LD_INT 7
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 30
69386: PUSH
69387: LD_INT 8
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: PPUSH
69400: CALL_OW 72
69404: AND
69405: IFFALSE 69435
69407: PUSH
69408: LD_EXP 31
69412: PUSH
69413: LD_VAR 0 1
69417: ARRAY
69418: PPUSH
69419: LD_INT 30
69421: PUSH
69422: LD_INT 3
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PPUSH
69429: CALL_OW 72
69433: NOT
69434: AND
69435: IFFALSE 69651
// begin if sci >= 6 then
69437: LD_VAR 0 8
69441: PUSH
69442: LD_INT 6
69444: GREATEREQUAL
69445: IFFALSE 69449
// exit ;
69447: GO 71900
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
69449: LD_ADDR_EXP 73
69453: PUSH
69454: LD_EXP 73
69458: PPUSH
69459: LD_VAR 0 1
69463: PPUSH
69464: LD_INT 2
69466: PPUSH
69467: CALL_OW 1
69471: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
69472: LD_ADDR_VAR 0 9
69476: PUSH
69477: LD_VAR 0 4
69481: PUSH
69482: LD_VAR 0 8
69486: DIFF
69487: PPUSH
69488: LD_INT 4
69490: PPUSH
69491: CALL 56635 0 2
69495: ST_TO_ADDR
// p := [ ] ;
69496: LD_ADDR_VAR 0 11
69500: PUSH
69501: EMPTY
69502: ST_TO_ADDR
// if sci < 6 and sort > 6 then
69503: LD_VAR 0 8
69507: PUSH
69508: LD_INT 6
69510: LESS
69511: IFFALSE 69523
69513: PUSH
69514: LD_VAR 0 9
69518: PUSH
69519: LD_INT 6
69521: GREATER
69522: AND
69523: IFFALSE 69604
// begin for i = 1 to 6 - sci do
69525: LD_ADDR_VAR 0 3
69529: PUSH
69530: DOUBLE
69531: LD_INT 1
69533: DEC
69534: ST_TO_ADDR
69535: LD_INT 6
69537: PUSH
69538: LD_VAR 0 8
69542: MINUS
69543: PUSH
69544: FOR_TO
69545: IFFALSE 69600
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
69547: LD_ADDR_VAR 0 11
69551: PUSH
69552: LD_VAR 0 11
69556: PPUSH
69557: LD_VAR 0 11
69561: PUSH
69562: LD_INT 1
69564: PLUS
69565: PPUSH
69566: LD_VAR 0 9
69570: PUSH
69571: LD_INT 1
69573: ARRAY
69574: PPUSH
69575: CALL_OW 2
69579: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
69580: LD_ADDR_VAR 0 9
69584: PUSH
69585: LD_VAR 0 9
69589: PPUSH
69590: LD_INT 1
69592: PPUSH
69593: CALL_OW 3
69597: ST_TO_ADDR
// end ;
69598: GO 69544
69600: POP
69601: POP
// end else
69602: GO 69624
// if sort then
69604: LD_VAR 0 9
69608: IFFALSE 69624
// p := sort [ 1 ] ;
69610: LD_ADDR_VAR 0 11
69614: PUSH
69615: LD_VAR 0 9
69619: PUSH
69620: LD_INT 1
69622: ARRAY
69623: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
69624: LD_ADDR_VAR 0 2
69628: PUSH
69629: LD_INT 0
69631: PUSH
69632: LD_INT 0
69634: PUSH
69635: LD_INT 0
69637: PUSH
69638: LD_VAR 0 11
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: ST_TO_ADDR
// exit ;
69649: GO 71900
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
69651: LD_EXP 58
69655: PUSH
69656: LD_EXP 57
69660: PUSH
69661: LD_VAR 0 1
69665: ARRAY
69666: ARRAY
69667: IFFALSE 69725
69669: PUSH
69670: LD_EXP 31
69674: PUSH
69675: LD_VAR 0 1
69679: ARRAY
69680: PPUSH
69681: LD_INT 2
69683: PUSH
69684: LD_INT 30
69686: PUSH
69687: LD_INT 6
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 30
69696: PUSH
69697: LD_INT 7
69699: PUSH
69700: EMPTY
69701: LIST
69702: LIST
69703: PUSH
69704: LD_INT 30
69706: PUSH
69707: LD_INT 8
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: PPUSH
69720: CALL_OW 72
69724: AND
69725: IFFALSE 69754
69727: PUSH
69728: LD_EXP 31
69732: PUSH
69733: LD_VAR 0 1
69737: ARRAY
69738: PPUSH
69739: LD_INT 30
69741: PUSH
69742: LD_INT 3
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PPUSH
69749: CALL_OW 72
69753: AND
69754: IFFALSE 70494
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
69756: LD_ADDR_EXP 73
69760: PUSH
69761: LD_EXP 73
69765: PPUSH
69766: LD_VAR 0 1
69770: PPUSH
69771: LD_INT 3
69773: PPUSH
69774: CALL_OW 1
69778: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69779: LD_ADDR_VAR 0 2
69783: PUSH
69784: LD_INT 0
69786: PUSH
69787: LD_INT 0
69789: PUSH
69790: LD_INT 0
69792: PUSH
69793: LD_INT 0
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: ST_TO_ADDR
// if not eng then
69802: LD_VAR 0 6
69806: NOT
69807: IFFALSE 69870
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
69809: LD_ADDR_VAR 0 11
69813: PUSH
69814: LD_VAR 0 4
69818: PPUSH
69819: LD_INT 2
69821: PPUSH
69822: CALL 56635 0 2
69826: PUSH
69827: LD_INT 1
69829: ARRAY
69830: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
69831: LD_ADDR_VAR 0 2
69835: PUSH
69836: LD_VAR 0 2
69840: PPUSH
69841: LD_INT 2
69843: PPUSH
69844: LD_VAR 0 11
69848: PPUSH
69849: CALL_OW 1
69853: ST_TO_ADDR
// tmp := tmp diff p ;
69854: LD_ADDR_VAR 0 4
69858: PUSH
69859: LD_VAR 0 4
69863: PUSH
69864: LD_VAR 0 11
69868: DIFF
69869: ST_TO_ADDR
// end ; if tmp and sci < 6 then
69870: LD_VAR 0 4
69874: IFFALSE 69886
69876: PUSH
69877: LD_VAR 0 8
69881: PUSH
69882: LD_INT 6
69884: LESS
69885: AND
69886: IFFALSE 70074
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
69888: LD_ADDR_VAR 0 9
69892: PUSH
69893: LD_VAR 0 4
69897: PUSH
69898: LD_VAR 0 8
69902: PUSH
69903: LD_VAR 0 7
69907: UNION
69908: DIFF
69909: PPUSH
69910: LD_INT 4
69912: PPUSH
69913: CALL 56635 0 2
69917: ST_TO_ADDR
// p := [ ] ;
69918: LD_ADDR_VAR 0 11
69922: PUSH
69923: EMPTY
69924: ST_TO_ADDR
// if sort then
69925: LD_VAR 0 9
69929: IFFALSE 70045
// for i = 1 to 6 - sci do
69931: LD_ADDR_VAR 0 3
69935: PUSH
69936: DOUBLE
69937: LD_INT 1
69939: DEC
69940: ST_TO_ADDR
69941: LD_INT 6
69943: PUSH
69944: LD_VAR 0 8
69948: MINUS
69949: PUSH
69950: FOR_TO
69951: IFFALSE 70043
// begin if i = sort then
69953: LD_VAR 0 3
69957: PUSH
69958: LD_VAR 0 9
69962: EQUAL
69963: IFFALSE 69967
// break ;
69965: GO 70043
// if GetClass ( i ) = 4 then
69967: LD_VAR 0 3
69971: PPUSH
69972: CALL_OW 257
69976: PUSH
69977: LD_INT 4
69979: EQUAL
69980: IFFALSE 69984
// continue ;
69982: GO 69950
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69984: LD_ADDR_VAR 0 11
69988: PUSH
69989: LD_VAR 0 11
69993: PPUSH
69994: LD_VAR 0 11
69998: PUSH
69999: LD_INT 1
70001: PLUS
70002: PPUSH
70003: LD_VAR 0 9
70007: PUSH
70008: LD_VAR 0 3
70012: ARRAY
70013: PPUSH
70014: CALL_OW 2
70018: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70019: LD_ADDR_VAR 0 4
70023: PUSH
70024: LD_VAR 0 4
70028: PUSH
70029: LD_VAR 0 9
70033: PUSH
70034: LD_VAR 0 3
70038: ARRAY
70039: DIFF
70040: ST_TO_ADDR
// end ;
70041: GO 69950
70043: POP
70044: POP
// if p then
70045: LD_VAR 0 11
70049: IFFALSE 70074
// result := Replace ( result , 4 , p ) ;
70051: LD_ADDR_VAR 0 2
70055: PUSH
70056: LD_VAR 0 2
70060: PPUSH
70061: LD_INT 4
70063: PPUSH
70064: LD_VAR 0 11
70068: PPUSH
70069: CALL_OW 1
70073: ST_TO_ADDR
// end ; if tmp and mech < 6 then
70074: LD_VAR 0 4
70078: IFFALSE 70090
70080: PUSH
70081: LD_VAR 0 7
70085: PUSH
70086: LD_INT 6
70088: LESS
70089: AND
70090: IFFALSE 70278
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
70092: LD_ADDR_VAR 0 9
70096: PUSH
70097: LD_VAR 0 4
70101: PUSH
70102: LD_VAR 0 8
70106: PUSH
70107: LD_VAR 0 7
70111: UNION
70112: DIFF
70113: PPUSH
70114: LD_INT 3
70116: PPUSH
70117: CALL 56635 0 2
70121: ST_TO_ADDR
// p := [ ] ;
70122: LD_ADDR_VAR 0 11
70126: PUSH
70127: EMPTY
70128: ST_TO_ADDR
// if sort then
70129: LD_VAR 0 9
70133: IFFALSE 70249
// for i = 1 to 6 - mech do
70135: LD_ADDR_VAR 0 3
70139: PUSH
70140: DOUBLE
70141: LD_INT 1
70143: DEC
70144: ST_TO_ADDR
70145: LD_INT 6
70147: PUSH
70148: LD_VAR 0 7
70152: MINUS
70153: PUSH
70154: FOR_TO
70155: IFFALSE 70247
// begin if i = sort then
70157: LD_VAR 0 3
70161: PUSH
70162: LD_VAR 0 9
70166: EQUAL
70167: IFFALSE 70171
// break ;
70169: GO 70247
// if GetClass ( i ) = 3 then
70171: LD_VAR 0 3
70175: PPUSH
70176: CALL_OW 257
70180: PUSH
70181: LD_INT 3
70183: EQUAL
70184: IFFALSE 70188
// continue ;
70186: GO 70154
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70188: LD_ADDR_VAR 0 11
70192: PUSH
70193: LD_VAR 0 11
70197: PPUSH
70198: LD_VAR 0 11
70202: PUSH
70203: LD_INT 1
70205: PLUS
70206: PPUSH
70207: LD_VAR 0 9
70211: PUSH
70212: LD_VAR 0 3
70216: ARRAY
70217: PPUSH
70218: CALL_OW 2
70222: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70223: LD_ADDR_VAR 0 4
70227: PUSH
70228: LD_VAR 0 4
70232: PUSH
70233: LD_VAR 0 9
70237: PUSH
70238: LD_VAR 0 3
70242: ARRAY
70243: DIFF
70244: ST_TO_ADDR
// end ;
70245: GO 70154
70247: POP
70248: POP
// if p then
70249: LD_VAR 0 11
70253: IFFALSE 70278
// result := Replace ( result , 3 , p ) ;
70255: LD_ADDR_VAR 0 2
70259: PUSH
70260: LD_VAR 0 2
70264: PPUSH
70265: LD_INT 3
70267: PPUSH
70268: LD_VAR 0 11
70272: PPUSH
70273: CALL_OW 1
70277: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
70278: LD_VAR 0 4
70282: PUSH
70283: LD_INT 6
70285: GREATER
70286: IFFALSE 70298
70288: PUSH
70289: LD_VAR 0 6
70293: PUSH
70294: LD_INT 6
70296: LESS
70297: AND
70298: IFFALSE 70492
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
70300: LD_ADDR_VAR 0 9
70304: PUSH
70305: LD_VAR 0 4
70309: PUSH
70310: LD_VAR 0 8
70314: PUSH
70315: LD_VAR 0 7
70319: UNION
70320: PUSH
70321: LD_VAR 0 6
70325: UNION
70326: DIFF
70327: PPUSH
70328: LD_INT 2
70330: PPUSH
70331: CALL 56635 0 2
70335: ST_TO_ADDR
// p := [ ] ;
70336: LD_ADDR_VAR 0 11
70340: PUSH
70341: EMPTY
70342: ST_TO_ADDR
// if sort then
70343: LD_VAR 0 9
70347: IFFALSE 70463
// for i = 1 to 6 - eng do
70349: LD_ADDR_VAR 0 3
70353: PUSH
70354: DOUBLE
70355: LD_INT 1
70357: DEC
70358: ST_TO_ADDR
70359: LD_INT 6
70361: PUSH
70362: LD_VAR 0 6
70366: MINUS
70367: PUSH
70368: FOR_TO
70369: IFFALSE 70461
// begin if i = sort then
70371: LD_VAR 0 3
70375: PUSH
70376: LD_VAR 0 9
70380: EQUAL
70381: IFFALSE 70385
// break ;
70383: GO 70461
// if GetClass ( i ) = 2 then
70385: LD_VAR 0 3
70389: PPUSH
70390: CALL_OW 257
70394: PUSH
70395: LD_INT 2
70397: EQUAL
70398: IFFALSE 70402
// continue ;
70400: GO 70368
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70402: LD_ADDR_VAR 0 11
70406: PUSH
70407: LD_VAR 0 11
70411: PPUSH
70412: LD_VAR 0 11
70416: PUSH
70417: LD_INT 1
70419: PLUS
70420: PPUSH
70421: LD_VAR 0 9
70425: PUSH
70426: LD_VAR 0 3
70430: ARRAY
70431: PPUSH
70432: CALL_OW 2
70436: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70437: LD_ADDR_VAR 0 4
70441: PUSH
70442: LD_VAR 0 4
70446: PUSH
70447: LD_VAR 0 9
70451: PUSH
70452: LD_VAR 0 3
70456: ARRAY
70457: DIFF
70458: ST_TO_ADDR
// end ;
70459: GO 70368
70461: POP
70462: POP
// if p then
70463: LD_VAR 0 11
70467: IFFALSE 70492
// result := Replace ( result , 2 , p ) ;
70469: LD_ADDR_VAR 0 2
70473: PUSH
70474: LD_VAR 0 2
70478: PPUSH
70479: LD_INT 2
70481: PPUSH
70482: LD_VAR 0 11
70486: PPUSH
70487: CALL_OW 1
70491: ST_TO_ADDR
// end ; exit ;
70492: GO 71900
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
70494: LD_EXP 58
70498: PUSH
70499: LD_EXP 57
70503: PUSH
70504: LD_VAR 0 1
70508: ARRAY
70509: ARRAY
70510: NOT
70511: IFFALSE 70540
70513: PUSH
70514: LD_EXP 31
70518: PUSH
70519: LD_VAR 0 1
70523: ARRAY
70524: PPUSH
70525: LD_INT 30
70527: PUSH
70528: LD_INT 3
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PPUSH
70535: CALL_OW 72
70539: AND
70540: IFFALSE 70554
70542: PUSH
70543: LD_EXP 36
70547: PUSH
70548: LD_VAR 0 1
70552: ARRAY
70553: AND
70554: IFFALSE 71168
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
70556: LD_ADDR_EXP 73
70560: PUSH
70561: LD_EXP 73
70565: PPUSH
70566: LD_VAR 0 1
70570: PPUSH
70571: LD_INT 5
70573: PPUSH
70574: CALL_OW 1
70578: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
70579: LD_ADDR_VAR 0 2
70583: PUSH
70584: LD_INT 0
70586: PUSH
70587: LD_INT 0
70589: PUSH
70590: LD_INT 0
70592: PUSH
70593: LD_INT 0
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: ST_TO_ADDR
// if sci > 1 then
70602: LD_VAR 0 8
70606: PUSH
70607: LD_INT 1
70609: GREATER
70610: IFFALSE 70638
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
70612: LD_ADDR_VAR 0 4
70616: PUSH
70617: LD_VAR 0 4
70621: PUSH
70622: LD_VAR 0 8
70626: PUSH
70627: LD_VAR 0 8
70631: PUSH
70632: LD_INT 1
70634: ARRAY
70635: DIFF
70636: DIFF
70637: ST_TO_ADDR
// if tmp and not sci then
70638: LD_VAR 0 4
70642: IFFALSE 70651
70644: PUSH
70645: LD_VAR 0 8
70649: NOT
70650: AND
70651: IFFALSE 70720
// begin sort := SortBySkill ( tmp , 4 ) ;
70653: LD_ADDR_VAR 0 9
70657: PUSH
70658: LD_VAR 0 4
70662: PPUSH
70663: LD_INT 4
70665: PPUSH
70666: CALL 56635 0 2
70670: ST_TO_ADDR
// if sort then
70671: LD_VAR 0 9
70675: IFFALSE 70691
// p := sort [ 1 ] ;
70677: LD_ADDR_VAR 0 11
70681: PUSH
70682: LD_VAR 0 9
70686: PUSH
70687: LD_INT 1
70689: ARRAY
70690: ST_TO_ADDR
// if p then
70691: LD_VAR 0 11
70695: IFFALSE 70720
// result := Replace ( result , 4 , p ) ;
70697: LD_ADDR_VAR 0 2
70701: PUSH
70702: LD_VAR 0 2
70706: PPUSH
70707: LD_INT 4
70709: PPUSH
70710: LD_VAR 0 11
70714: PPUSH
70715: CALL_OW 1
70719: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
70720: LD_ADDR_VAR 0 4
70724: PUSH
70725: LD_VAR 0 4
70729: PUSH
70730: LD_VAR 0 7
70734: DIFF
70735: ST_TO_ADDR
// if tmp and mech < 6 then
70736: LD_VAR 0 4
70740: IFFALSE 70752
70742: PUSH
70743: LD_VAR 0 7
70747: PUSH
70748: LD_INT 6
70750: LESS
70751: AND
70752: IFFALSE 70940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
70754: LD_ADDR_VAR 0 9
70758: PUSH
70759: LD_VAR 0 4
70763: PUSH
70764: LD_VAR 0 8
70768: PUSH
70769: LD_VAR 0 7
70773: UNION
70774: DIFF
70775: PPUSH
70776: LD_INT 3
70778: PPUSH
70779: CALL 56635 0 2
70783: ST_TO_ADDR
// p := [ ] ;
70784: LD_ADDR_VAR 0 11
70788: PUSH
70789: EMPTY
70790: ST_TO_ADDR
// if sort then
70791: LD_VAR 0 9
70795: IFFALSE 70911
// for i = 1 to 6 - mech do
70797: LD_ADDR_VAR 0 3
70801: PUSH
70802: DOUBLE
70803: LD_INT 1
70805: DEC
70806: ST_TO_ADDR
70807: LD_INT 6
70809: PUSH
70810: LD_VAR 0 7
70814: MINUS
70815: PUSH
70816: FOR_TO
70817: IFFALSE 70909
// begin if i = sort then
70819: LD_VAR 0 3
70823: PUSH
70824: LD_VAR 0 9
70828: EQUAL
70829: IFFALSE 70833
// break ;
70831: GO 70909
// if GetClass ( i ) = 3 then
70833: LD_VAR 0 3
70837: PPUSH
70838: CALL_OW 257
70842: PUSH
70843: LD_INT 3
70845: EQUAL
70846: IFFALSE 70850
// continue ;
70848: GO 70816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70850: LD_ADDR_VAR 0 11
70854: PUSH
70855: LD_VAR 0 11
70859: PPUSH
70860: LD_VAR 0 11
70864: PUSH
70865: LD_INT 1
70867: PLUS
70868: PPUSH
70869: LD_VAR 0 9
70873: PUSH
70874: LD_VAR 0 3
70878: ARRAY
70879: PPUSH
70880: CALL_OW 2
70884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70885: LD_ADDR_VAR 0 4
70889: PUSH
70890: LD_VAR 0 4
70894: PUSH
70895: LD_VAR 0 9
70899: PUSH
70900: LD_VAR 0 3
70904: ARRAY
70905: DIFF
70906: ST_TO_ADDR
// end ;
70907: GO 70816
70909: POP
70910: POP
// if p then
70911: LD_VAR 0 11
70915: IFFALSE 70940
// result := Replace ( result , 3 , p ) ;
70917: LD_ADDR_VAR 0 2
70921: PUSH
70922: LD_VAR 0 2
70926: PPUSH
70927: LD_INT 3
70929: PPUSH
70930: LD_VAR 0 11
70934: PPUSH
70935: CALL_OW 1
70939: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
70940: LD_ADDR_VAR 0 4
70944: PUSH
70945: LD_VAR 0 4
70949: PUSH
70950: LD_VAR 0 6
70954: DIFF
70955: ST_TO_ADDR
// if tmp and eng < 6 then
70956: LD_VAR 0 4
70960: IFFALSE 70972
70962: PUSH
70963: LD_VAR 0 6
70967: PUSH
70968: LD_INT 6
70970: LESS
70971: AND
70972: IFFALSE 71166
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
70974: LD_ADDR_VAR 0 9
70978: PUSH
70979: LD_VAR 0 4
70983: PUSH
70984: LD_VAR 0 8
70988: PUSH
70989: LD_VAR 0 7
70993: UNION
70994: PUSH
70995: LD_VAR 0 6
70999: UNION
71000: DIFF
71001: PPUSH
71002: LD_INT 2
71004: PPUSH
71005: CALL 56635 0 2
71009: ST_TO_ADDR
// p := [ ] ;
71010: LD_ADDR_VAR 0 11
71014: PUSH
71015: EMPTY
71016: ST_TO_ADDR
// if sort then
71017: LD_VAR 0 9
71021: IFFALSE 71137
// for i = 1 to 6 - eng do
71023: LD_ADDR_VAR 0 3
71027: PUSH
71028: DOUBLE
71029: LD_INT 1
71031: DEC
71032: ST_TO_ADDR
71033: LD_INT 6
71035: PUSH
71036: LD_VAR 0 6
71040: MINUS
71041: PUSH
71042: FOR_TO
71043: IFFALSE 71135
// begin if i = sort then
71045: LD_VAR 0 3
71049: PUSH
71050: LD_VAR 0 9
71054: EQUAL
71055: IFFALSE 71059
// break ;
71057: GO 71135
// if GetClass ( i ) = 2 then
71059: LD_VAR 0 3
71063: PPUSH
71064: CALL_OW 257
71068: PUSH
71069: LD_INT 2
71071: EQUAL
71072: IFFALSE 71076
// continue ;
71074: GO 71042
// p := Insert ( p , p + 1 , sort [ i ] ) ;
71076: LD_ADDR_VAR 0 11
71080: PUSH
71081: LD_VAR 0 11
71085: PPUSH
71086: LD_VAR 0 11
71090: PUSH
71091: LD_INT 1
71093: PLUS
71094: PPUSH
71095: LD_VAR 0 9
71099: PUSH
71100: LD_VAR 0 3
71104: ARRAY
71105: PPUSH
71106: CALL_OW 2
71110: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
71111: LD_ADDR_VAR 0 4
71115: PUSH
71116: LD_VAR 0 4
71120: PUSH
71121: LD_VAR 0 9
71125: PUSH
71126: LD_VAR 0 3
71130: ARRAY
71131: DIFF
71132: ST_TO_ADDR
// end ;
71133: GO 71042
71135: POP
71136: POP
// if p then
71137: LD_VAR 0 11
71141: IFFALSE 71166
// result := Replace ( result , 2 , p ) ;
71143: LD_ADDR_VAR 0 2
71147: PUSH
71148: LD_VAR 0 2
71152: PPUSH
71153: LD_INT 2
71155: PPUSH
71156: LD_VAR 0 11
71160: PPUSH
71161: CALL_OW 1
71165: ST_TO_ADDR
// end ; exit ;
71166: GO 71900
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
71168: LD_EXP 58
71172: PUSH
71173: LD_EXP 57
71177: PUSH
71178: LD_VAR 0 1
71182: ARRAY
71183: ARRAY
71184: NOT
71185: IFFALSE 71214
71187: PUSH
71188: LD_EXP 31
71192: PUSH
71193: LD_VAR 0 1
71197: ARRAY
71198: PPUSH
71199: LD_INT 30
71201: PUSH
71202: LD_INT 3
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PPUSH
71209: CALL_OW 72
71213: AND
71214: IFFALSE 71229
71216: PUSH
71217: LD_EXP 36
71221: PUSH
71222: LD_VAR 0 1
71226: ARRAY
71227: NOT
71228: AND
71229: IFFALSE 71900
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
71231: LD_ADDR_EXP 73
71235: PUSH
71236: LD_EXP 73
71240: PPUSH
71241: LD_VAR 0 1
71245: PPUSH
71246: LD_INT 6
71248: PPUSH
71249: CALL_OW 1
71253: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
71254: LD_ADDR_VAR 0 2
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: LD_INT 0
71264: PUSH
71265: LD_INT 0
71267: PUSH
71268: LD_INT 0
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: ST_TO_ADDR
// if sci >= 1 then
71277: LD_VAR 0 8
71281: PUSH
71282: LD_INT 1
71284: GREATEREQUAL
71285: IFFALSE 71307
// tmp := tmp diff sci [ 1 ] ;
71287: LD_ADDR_VAR 0 4
71291: PUSH
71292: LD_VAR 0 4
71296: PUSH
71297: LD_VAR 0 8
71301: PUSH
71302: LD_INT 1
71304: ARRAY
71305: DIFF
71306: ST_TO_ADDR
// if tmp and not sci then
71307: LD_VAR 0 4
71311: IFFALSE 71320
71313: PUSH
71314: LD_VAR 0 8
71318: NOT
71319: AND
71320: IFFALSE 71389
// begin sort := SortBySkill ( tmp , 4 ) ;
71322: LD_ADDR_VAR 0 9
71326: PUSH
71327: LD_VAR 0 4
71331: PPUSH
71332: LD_INT 4
71334: PPUSH
71335: CALL 56635 0 2
71339: ST_TO_ADDR
// if sort then
71340: LD_VAR 0 9
71344: IFFALSE 71360
// p := sort [ 1 ] ;
71346: LD_ADDR_VAR 0 11
71350: PUSH
71351: LD_VAR 0 9
71355: PUSH
71356: LD_INT 1
71358: ARRAY
71359: ST_TO_ADDR
// if p then
71360: LD_VAR 0 11
71364: IFFALSE 71389
// result := Replace ( result , 4 , p ) ;
71366: LD_ADDR_VAR 0 2
71370: PUSH
71371: LD_VAR 0 2
71375: PPUSH
71376: LD_INT 4
71378: PPUSH
71379: LD_VAR 0 11
71383: PPUSH
71384: CALL_OW 1
71388: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
71389: LD_ADDR_VAR 0 4
71393: PUSH
71394: LD_VAR 0 4
71398: PUSH
71399: LD_VAR 0 7
71403: DIFF
71404: ST_TO_ADDR
// if tmp and mech < 6 then
71405: LD_VAR 0 4
71409: IFFALSE 71421
71411: PUSH
71412: LD_VAR 0 7
71416: PUSH
71417: LD_INT 6
71419: LESS
71420: AND
71421: IFFALSE 71603
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
71423: LD_ADDR_VAR 0 9
71427: PUSH
71428: LD_VAR 0 4
71432: PUSH
71433: LD_VAR 0 7
71437: DIFF
71438: PPUSH
71439: LD_INT 3
71441: PPUSH
71442: CALL 56635 0 2
71446: ST_TO_ADDR
// p := [ ] ;
71447: LD_ADDR_VAR 0 11
71451: PUSH
71452: EMPTY
71453: ST_TO_ADDR
// if sort then
71454: LD_VAR 0 9
71458: IFFALSE 71574
// for i = 1 to 6 - mech do
71460: LD_ADDR_VAR 0 3
71464: PUSH
71465: DOUBLE
71466: LD_INT 1
71468: DEC
71469: ST_TO_ADDR
71470: LD_INT 6
71472: PUSH
71473: LD_VAR 0 7
71477: MINUS
71478: PUSH
71479: FOR_TO
71480: IFFALSE 71572
// begin if i = sort then
71482: LD_VAR 0 3
71486: PUSH
71487: LD_VAR 0 9
71491: EQUAL
71492: IFFALSE 71496
// break ;
71494: GO 71572
// if GetClass ( i ) = 3 then
71496: LD_VAR 0 3
71500: PPUSH
71501: CALL_OW 257
71505: PUSH
71506: LD_INT 3
71508: EQUAL
71509: IFFALSE 71513
// continue ;
71511: GO 71479
// p := Insert ( p , p + 1 , sort [ i ] ) ;
71513: LD_ADDR_VAR 0 11
71517: PUSH
71518: LD_VAR 0 11
71522: PPUSH
71523: LD_VAR 0 11
71527: PUSH
71528: LD_INT 1
71530: PLUS
71531: PPUSH
71532: LD_VAR 0 9
71536: PUSH
71537: LD_VAR 0 3
71541: ARRAY
71542: PPUSH
71543: CALL_OW 2
71547: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
71548: LD_ADDR_VAR 0 4
71552: PUSH
71553: LD_VAR 0 4
71557: PUSH
71558: LD_VAR 0 9
71562: PUSH
71563: LD_VAR 0 3
71567: ARRAY
71568: DIFF
71569: ST_TO_ADDR
// end ;
71570: GO 71479
71572: POP
71573: POP
// if p then
71574: LD_VAR 0 11
71578: IFFALSE 71603
// result := Replace ( result , 3 , p ) ;
71580: LD_ADDR_VAR 0 2
71584: PUSH
71585: LD_VAR 0 2
71589: PPUSH
71590: LD_INT 3
71592: PPUSH
71593: LD_VAR 0 11
71597: PPUSH
71598: CALL_OW 1
71602: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
71603: LD_ADDR_VAR 0 4
71607: PUSH
71608: LD_VAR 0 4
71612: PUSH
71613: LD_VAR 0 6
71617: DIFF
71618: ST_TO_ADDR
// if tmp and eng < 4 then
71619: LD_VAR 0 4
71623: IFFALSE 71635
71625: PUSH
71626: LD_VAR 0 6
71630: PUSH
71631: LD_INT 4
71633: LESS
71634: AND
71635: IFFALSE 71825
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
71637: LD_ADDR_VAR 0 9
71641: PUSH
71642: LD_VAR 0 4
71646: PUSH
71647: LD_VAR 0 7
71651: PUSH
71652: LD_VAR 0 6
71656: UNION
71657: DIFF
71658: PPUSH
71659: LD_INT 2
71661: PPUSH
71662: CALL 56635 0 2
71666: ST_TO_ADDR
// p := [ ] ;
71667: LD_ADDR_VAR 0 11
71671: PUSH
71672: EMPTY
71673: ST_TO_ADDR
// if sort then
71674: LD_VAR 0 9
71678: IFFALSE 71794
// for i = 1 to 4 - eng do
71680: LD_ADDR_VAR 0 3
71684: PUSH
71685: DOUBLE
71686: LD_INT 1
71688: DEC
71689: ST_TO_ADDR
71690: LD_INT 4
71692: PUSH
71693: LD_VAR 0 6
71697: MINUS
71698: PUSH
71699: FOR_TO
71700: IFFALSE 71792
// begin if i = sort then
71702: LD_VAR 0 3
71706: PUSH
71707: LD_VAR 0 9
71711: EQUAL
71712: IFFALSE 71716
// break ;
71714: GO 71792
// if GetClass ( i ) = 2 then
71716: LD_VAR 0 3
71720: PPUSH
71721: CALL_OW 257
71725: PUSH
71726: LD_INT 2
71728: EQUAL
71729: IFFALSE 71733
// continue ;
71731: GO 71699
// p := Insert ( p , p + 1 , sort [ i ] ) ;
71733: LD_ADDR_VAR 0 11
71737: PUSH
71738: LD_VAR 0 11
71742: PPUSH
71743: LD_VAR 0 11
71747: PUSH
71748: LD_INT 1
71750: PLUS
71751: PPUSH
71752: LD_VAR 0 9
71756: PUSH
71757: LD_VAR 0 3
71761: ARRAY
71762: PPUSH
71763: CALL_OW 2
71767: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
71768: LD_ADDR_VAR 0 4
71772: PUSH
71773: LD_VAR 0 4
71777: PUSH
71778: LD_VAR 0 9
71782: PUSH
71783: LD_VAR 0 3
71787: ARRAY
71788: DIFF
71789: ST_TO_ADDR
// end ;
71790: GO 71699
71792: POP
71793: POP
// if p then
71794: LD_VAR 0 11
71798: IFFALSE 71823
// result := Replace ( result , 2 , p ) ;
71800: LD_ADDR_VAR 0 2
71804: PUSH
71805: LD_VAR 0 2
71809: PPUSH
71810: LD_INT 2
71812: PPUSH
71813: LD_VAR 0 11
71817: PPUSH
71818: CALL_OW 1
71822: ST_TO_ADDR
// end else
71823: GO 71869
// for i = eng downto 5 do
71825: LD_ADDR_VAR 0 3
71829: PUSH
71830: DOUBLE
71831: LD_VAR 0 6
71835: INC
71836: ST_TO_ADDR
71837: LD_INT 5
71839: PUSH
71840: FOR_DOWNTO
71841: IFFALSE 71867
// tmp := tmp union eng [ i ] ;
71843: LD_ADDR_VAR 0 4
71847: PUSH
71848: LD_VAR 0 4
71852: PUSH
71853: LD_VAR 0 6
71857: PUSH
71858: LD_VAR 0 3
71862: ARRAY
71863: UNION
71864: ST_TO_ADDR
71865: GO 71840
71867: POP
71868: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
71869: LD_ADDR_VAR 0 2
71873: PUSH
71874: LD_VAR 0 2
71878: PPUSH
71879: LD_INT 1
71881: PPUSH
71882: LD_VAR 0 4
71886: PUSH
71887: LD_VAR 0 5
71891: DIFF
71892: PPUSH
71893: CALL_OW 1
71897: ST_TO_ADDR
// exit ;
71898: GO 71900
// end ; end ;
71900: LD_VAR 0 2
71904: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
71905: LD_INT 0
71907: PPUSH
71908: PPUSH
71909: PPUSH
// if not mc_bases then
71910: LD_EXP 31
71914: NOT
71915: IFFALSE 71919
// exit ;
71917: GO 72061
// for i = 1 to mc_bases do
71919: LD_ADDR_VAR 0 2
71923: PUSH
71924: DOUBLE
71925: LD_INT 1
71927: DEC
71928: ST_TO_ADDR
71929: LD_EXP 31
71933: PUSH
71934: FOR_TO
71935: IFFALSE 72052
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71937: LD_ADDR_VAR 0 3
71941: PUSH
71942: LD_EXP 31
71946: PUSH
71947: LD_VAR 0 2
71951: ARRAY
71952: PPUSH
71953: LD_INT 21
71955: PUSH
71956: LD_INT 3
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 3
71965: PUSH
71966: LD_INT 2
71968: PUSH
71969: LD_INT 30
71971: PUSH
71972: LD_INT 29
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 30
71981: PUSH
71982: LD_INT 30
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: LIST
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 3
72000: PUSH
72001: LD_INT 24
72003: PUSH
72004: LD_INT 1000
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: LIST
72019: PPUSH
72020: CALL_OW 72
72024: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
72025: LD_ADDR_EXP 32
72029: PUSH
72030: LD_EXP 32
72034: PPUSH
72035: LD_VAR 0 2
72039: PPUSH
72040: LD_VAR 0 3
72044: PPUSH
72045: CALL_OW 1
72049: ST_TO_ADDR
// end ;
72050: GO 71934
72052: POP
72053: POP
// RaiseSailEvent ( 101 ) ;
72054: LD_INT 101
72056: PPUSH
72057: CALL_OW 427
// end ;
72061: LD_VAR 0 1
72065: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
72066: LD_INT 0
72068: PPUSH
72069: PPUSH
72070: PPUSH
72071: PPUSH
72072: PPUSH
72073: PPUSH
72074: PPUSH
// if not mc_bases then
72075: LD_EXP 31
72079: NOT
72080: IFFALSE 72084
// exit ;
72082: GO 72648
// for i = 1 to mc_bases do
72084: LD_ADDR_VAR 0 2
72088: PUSH
72089: DOUBLE
72090: LD_INT 1
72092: DEC
72093: ST_TO_ADDR
72094: LD_EXP 31
72098: PUSH
72099: FOR_TO
72100: IFFALSE 72639
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
72102: LD_ADDR_VAR 0 5
72106: PUSH
72107: LD_EXP 31
72111: PUSH
72112: LD_VAR 0 2
72116: ARRAY
72117: PUSH
72118: LD_EXP 60
72122: PUSH
72123: LD_VAR 0 2
72127: ARRAY
72128: UNION
72129: PPUSH
72130: LD_INT 21
72132: PUSH
72133: LD_INT 1
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 1
72142: PUSH
72143: LD_INT 3
72145: PUSH
72146: LD_INT 54
72148: PUSH
72149: EMPTY
72150: LIST
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 3
72158: PUSH
72159: LD_INT 24
72161: PUSH
72162: LD_INT 1000
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: LIST
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: PPUSH
72182: CALL_OW 72
72186: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
72187: LD_ADDR_VAR 0 6
72191: PUSH
72192: LD_EXP 31
72196: PUSH
72197: LD_VAR 0 2
72201: ARRAY
72202: PPUSH
72203: LD_INT 21
72205: PUSH
72206: LD_INT 1
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 1
72215: PUSH
72216: LD_INT 3
72218: PUSH
72219: LD_INT 54
72221: PUSH
72222: EMPTY
72223: LIST
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 3
72231: PUSH
72232: LD_INT 24
72234: PUSH
72235: LD_INT 250
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: LIST
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PPUSH
72255: CALL_OW 72
72259: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
72260: LD_ADDR_VAR 0 7
72264: PUSH
72265: LD_VAR 0 5
72269: PUSH
72270: LD_VAR 0 6
72274: DIFF
72275: ST_TO_ADDR
// if not need_heal_1 then
72276: LD_VAR 0 6
72280: NOT
72281: IFFALSE 72314
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
72283: LD_ADDR_EXP 34
72287: PUSH
72288: LD_EXP 34
72292: PPUSH
72293: LD_VAR 0 2
72297: PUSH
72298: LD_INT 1
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PPUSH
72305: EMPTY
72306: PPUSH
72307: CALL 25097 0 3
72311: ST_TO_ADDR
72312: GO 72384
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
72314: LD_ADDR_EXP 34
72318: PUSH
72319: LD_EXP 34
72323: PPUSH
72324: LD_VAR 0 2
72328: PUSH
72329: LD_INT 1
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PPUSH
72336: LD_EXP 34
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PUSH
72347: LD_INT 1
72349: ARRAY
72350: PPUSH
72351: LD_INT 3
72353: PUSH
72354: LD_INT 24
72356: PUSH
72357: LD_INT 1000
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PPUSH
72368: CALL_OW 72
72372: PUSH
72373: LD_VAR 0 6
72377: UNION
72378: PPUSH
72379: CALL 25097 0 3
72383: ST_TO_ADDR
// if not need_heal_2 then
72384: LD_VAR 0 7
72388: NOT
72389: IFFALSE 72422
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
72391: LD_ADDR_EXP 34
72395: PUSH
72396: LD_EXP 34
72400: PPUSH
72401: LD_VAR 0 2
72405: PUSH
72406: LD_INT 2
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PPUSH
72413: EMPTY
72414: PPUSH
72415: CALL 25097 0 3
72419: ST_TO_ADDR
72420: GO 72454
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
72422: LD_ADDR_EXP 34
72426: PUSH
72427: LD_EXP 34
72431: PPUSH
72432: LD_VAR 0 2
72436: PUSH
72437: LD_INT 2
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PPUSH
72444: LD_VAR 0 7
72448: PPUSH
72449: CALL 25097 0 3
72453: ST_TO_ADDR
// if need_heal_2 then
72454: LD_VAR 0 7
72458: IFFALSE 72619
// for j in need_heal_2 do
72460: LD_ADDR_VAR 0 3
72464: PUSH
72465: LD_VAR 0 7
72469: PUSH
72470: FOR_IN
72471: IFFALSE 72617
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72473: LD_ADDR_VAR 0 5
72477: PUSH
72478: LD_EXP 31
72482: PUSH
72483: LD_VAR 0 2
72487: ARRAY
72488: PPUSH
72489: LD_INT 2
72491: PUSH
72492: LD_INT 30
72494: PUSH
72495: LD_INT 6
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 30
72504: PUSH
72505: LD_INT 7
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 30
72514: PUSH
72515: LD_INT 8
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 30
72524: PUSH
72525: LD_INT 0
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 30
72534: PUSH
72535: LD_INT 1
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: PPUSH
72550: CALL_OW 72
72554: ST_TO_ADDR
// if tmp then
72555: LD_VAR 0 5
72559: IFFALSE 72615
// begin k := NearestUnitToUnit ( tmp , j ) ;
72561: LD_ADDR_VAR 0 4
72565: PUSH
72566: LD_VAR 0 5
72570: PPUSH
72571: LD_VAR 0 3
72575: PPUSH
72576: CALL_OW 74
72580: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
72581: LD_VAR 0 3
72585: PPUSH
72586: LD_VAR 0 4
72590: PPUSH
72591: CALL_OW 296
72595: PUSH
72596: LD_INT 5
72598: GREATER
72599: IFFALSE 72615
// ComMoveToNearbyEntrance ( j , k ) ;
72601: LD_VAR 0 3
72605: PPUSH
72606: LD_VAR 0 4
72610: PPUSH
72611: CALL 59034 0 2
// end ; end ;
72615: GO 72470
72617: POP
72618: POP
// if not need_heal_1 and not need_heal_2 then
72619: LD_VAR 0 6
72623: NOT
72624: IFFALSE 72633
72626: PUSH
72627: LD_VAR 0 7
72631: NOT
72632: AND
72633: IFFALSE 72637
// continue ;
72635: GO 72099
// end ;
72637: GO 72099
72639: POP
72640: POP
// RaiseSailEvent ( 102 ) ;
72641: LD_INT 102
72643: PPUSH
72644: CALL_OW 427
// end ;
72648: LD_VAR 0 1
72652: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
72653: LD_INT 0
72655: PPUSH
72656: PPUSH
72657: PPUSH
72658: PPUSH
72659: PPUSH
72660: PPUSH
72661: PPUSH
72662: PPUSH
// if not mc_bases then
72663: LD_EXP 31
72667: NOT
72668: IFFALSE 72672
// exit ;
72670: GO 73587
// for i = 1 to mc_bases do
72672: LD_ADDR_VAR 0 2
72676: PUSH
72677: DOUBLE
72678: LD_INT 1
72680: DEC
72681: ST_TO_ADDR
72682: LD_EXP 31
72686: PUSH
72687: FOR_TO
72688: IFFALSE 73585
// begin if not mc_building_need_repair [ i ] then
72690: LD_EXP 32
72694: PUSH
72695: LD_VAR 0 2
72699: ARRAY
72700: NOT
72701: IFFALSE 72886
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
72703: LD_ADDR_VAR 0 6
72707: PUSH
72708: LD_EXP 50
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: PPUSH
72719: LD_INT 3
72721: PUSH
72722: LD_INT 24
72724: PUSH
72725: LD_INT 1000
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 2
72738: PUSH
72739: LD_INT 34
72741: PUSH
72742: LD_INT 13
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 34
72751: PUSH
72752: LD_INT 52
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 34
72761: PUSH
72762: LD_INT 88
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PPUSH
72779: CALL_OW 72
72783: ST_TO_ADDR
// if cranes then
72784: LD_VAR 0 6
72788: IFFALSE 72850
// for j in cranes do
72790: LD_ADDR_VAR 0 3
72794: PUSH
72795: LD_VAR 0 6
72799: PUSH
72800: FOR_IN
72801: IFFALSE 72848
// if not IsInArea ( j , mc_parking [ i ] ) then
72803: LD_VAR 0 3
72807: PPUSH
72808: LD_EXP 55
72812: PUSH
72813: LD_VAR 0 2
72817: ARRAY
72818: PPUSH
72819: CALL_OW 308
72823: NOT
72824: IFFALSE 72846
// ComMoveToArea ( j , mc_parking [ i ] ) ;
72826: LD_VAR 0 3
72830: PPUSH
72831: LD_EXP 55
72835: PUSH
72836: LD_VAR 0 2
72840: ARRAY
72841: PPUSH
72842: CALL_OW 113
72846: GO 72800
72848: POP
72849: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
72850: LD_ADDR_EXP 33
72854: PUSH
72855: LD_EXP 33
72859: PPUSH
72860: LD_VAR 0 2
72864: PPUSH
72865: EMPTY
72866: PPUSH
72867: CALL_OW 1
72871: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
72872: LD_VAR 0 2
72876: PPUSH
72877: LD_INT 101
72879: PPUSH
72880: CALL 67678 0 2
// continue ;
72884: GO 72687
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
72886: LD_ADDR_EXP 37
72890: PUSH
72891: LD_EXP 37
72895: PPUSH
72896: LD_VAR 0 2
72900: PPUSH
72901: EMPTY
72902: PPUSH
72903: CALL_OW 1
72907: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
72908: LD_VAR 0 2
72912: PPUSH
72913: LD_INT 103
72915: PPUSH
72916: CALL 67678 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
72920: LD_ADDR_VAR 0 5
72924: PUSH
72925: LD_EXP 31
72929: PUSH
72930: LD_VAR 0 2
72934: ARRAY
72935: PUSH
72936: LD_EXP 60
72940: PUSH
72941: LD_VAR 0 2
72945: ARRAY
72946: UNION
72947: PPUSH
72948: LD_INT 2
72950: PUSH
72951: LD_INT 25
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 25
72963: PUSH
72964: LD_INT 16
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: LIST
72975: PUSH
72976: EMPTY
72977: LIST
72978: PPUSH
72979: CALL_OW 72
72983: ST_TO_ADDR
// if mc_need_heal [ i ] then
72984: LD_EXP 34
72988: PUSH
72989: LD_VAR 0 2
72993: ARRAY
72994: IFFALSE 73038
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
72996: LD_ADDR_VAR 0 5
73000: PUSH
73001: LD_VAR 0 5
73005: PUSH
73006: LD_EXP 34
73010: PUSH
73011: LD_VAR 0 2
73015: ARRAY
73016: PUSH
73017: LD_INT 1
73019: ARRAY
73020: PUSH
73021: LD_EXP 34
73025: PUSH
73026: LD_VAR 0 2
73030: ARRAY
73031: PUSH
73032: LD_INT 2
73034: ARRAY
73035: UNION
73036: DIFF
73037: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
73038: LD_ADDR_VAR 0 6
73042: PUSH
73043: LD_EXP 50
73047: PUSH
73048: LD_VAR 0 2
73052: ARRAY
73053: PPUSH
73054: LD_INT 2
73056: PUSH
73057: LD_INT 34
73059: PUSH
73060: LD_INT 13
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 34
73069: PUSH
73070: LD_INT 52
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 34
73079: PUSH
73080: LD_INT 88
73082: PUSH
73083: EMPTY
73084: LIST
73085: LIST
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: PPUSH
73093: CALL_OW 72
73097: ST_TO_ADDR
// if cranes then
73098: LD_VAR 0 6
73102: IFFALSE 73274
// begin for j in cranes do
73104: LD_ADDR_VAR 0 3
73108: PUSH
73109: LD_VAR 0 6
73113: PUSH
73114: FOR_IN
73115: IFFALSE 73272
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
73117: LD_VAR 0 3
73121: PPUSH
73122: CALL_OW 256
73126: PUSH
73127: LD_INT 1000
73129: EQUAL
73130: IFFALSE 73144
73132: PUSH
73133: LD_VAR 0 3
73137: PPUSH
73138: CALL_OW 314
73142: NOT
73143: AND
73144: IFFALSE 73210
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
73146: LD_ADDR_VAR 0 8
73150: PUSH
73151: LD_EXP 32
73155: PUSH
73156: LD_VAR 0 2
73160: ARRAY
73161: PPUSH
73162: LD_VAR 0 3
73166: PPUSH
73167: CALL_OW 74
73171: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
73172: LD_VAR 0 8
73176: PPUSH
73177: LD_INT 16
73179: PPUSH
73180: CALL 28076 0 2
73184: PUSH
73185: LD_INT 4
73187: ARRAY
73188: PUSH
73189: LD_INT 10
73191: LESS
73192: IFFALSE 73208
// ComRepairBuilding ( j , to_repair ) ;
73194: LD_VAR 0 3
73198: PPUSH
73199: LD_VAR 0 8
73203: PPUSH
73204: CALL_OW 130
// end else
73208: GO 73270
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
73210: LD_VAR 0 3
73214: PPUSH
73215: CALL_OW 256
73219: PUSH
73220: LD_INT 500
73222: LESS
73223: IFFALSE 73248
73225: PUSH
73226: LD_VAR 0 3
73230: PPUSH
73231: LD_EXP 55
73235: PUSH
73236: LD_VAR 0 2
73240: ARRAY
73241: PPUSH
73242: CALL_OW 308
73246: NOT
73247: AND
73248: IFFALSE 73270
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73250: LD_VAR 0 3
73254: PPUSH
73255: LD_EXP 55
73259: PUSH
73260: LD_VAR 0 2
73264: ARRAY
73265: PPUSH
73266: CALL_OW 113
// end ;
73270: GO 73114
73272: POP
73273: POP
// end ; if tmp > 3 then
73274: LD_VAR 0 5
73278: PUSH
73279: LD_INT 3
73281: GREATER
73282: IFFALSE 73302
// tmp := ShrinkArray ( tmp , 4 ) ;
73284: LD_ADDR_VAR 0 5
73288: PUSH
73289: LD_VAR 0 5
73293: PPUSH
73294: LD_INT 4
73296: PPUSH
73297: CALL 58470 0 2
73301: ST_TO_ADDR
// if not tmp then
73302: LD_VAR 0 5
73306: NOT
73307: IFFALSE 73311
// continue ;
73309: GO 72687
// for j in tmp do
73311: LD_ADDR_VAR 0 3
73315: PUSH
73316: LD_VAR 0 5
73320: PUSH
73321: FOR_IN
73322: IFFALSE 73581
// begin if IsInUnit ( j ) then
73324: LD_VAR 0 3
73328: PPUSH
73329: CALL_OW 310
73333: IFFALSE 73344
// ComExitBuilding ( j ) ;
73335: LD_VAR 0 3
73339: PPUSH
73340: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
73344: LD_VAR 0 3
73348: PUSH
73349: LD_EXP 33
73353: PUSH
73354: LD_VAR 0 2
73358: ARRAY
73359: IN
73360: NOT
73361: IFFALSE 73419
// begin SetTag ( j , 101 ) ;
73363: LD_VAR 0 3
73367: PPUSH
73368: LD_INT 101
73370: PPUSH
73371: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
73375: LD_ADDR_EXP 33
73379: PUSH
73380: LD_EXP 33
73384: PPUSH
73385: LD_VAR 0 2
73389: PUSH
73390: LD_EXP 33
73394: PUSH
73395: LD_VAR 0 2
73399: ARRAY
73400: PUSH
73401: LD_INT 1
73403: PLUS
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PPUSH
73409: LD_VAR 0 3
73413: PPUSH
73414: CALL 25097 0 3
73418: ST_TO_ADDR
// end ; wait ( 1 ) ;
73419: LD_INT 1
73421: PPUSH
73422: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
73426: LD_ADDR_VAR 0 7
73430: PUSH
73431: LD_EXP 32
73435: PUSH
73436: LD_VAR 0 2
73440: ARRAY
73441: ST_TO_ADDR
// if mc_scan [ i ] then
73442: LD_EXP 54
73446: PUSH
73447: LD_VAR 0 2
73451: ARRAY
73452: IFFALSE 73514
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
73454: LD_ADDR_VAR 0 7
73458: PUSH
73459: LD_EXP 32
73463: PUSH
73464: LD_VAR 0 2
73468: ARRAY
73469: PPUSH
73470: LD_INT 3
73472: PUSH
73473: LD_INT 30
73475: PUSH
73476: LD_INT 32
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 30
73485: PUSH
73486: LD_INT 33
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 30
73495: PUSH
73496: LD_INT 31
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: PPUSH
73509: CALL_OW 72
73513: ST_TO_ADDR
// if not to_repair_tmp then
73514: LD_VAR 0 7
73518: NOT
73519: IFFALSE 73523
// continue ;
73521: GO 73321
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
73523: LD_ADDR_VAR 0 8
73527: PUSH
73528: LD_VAR 0 7
73532: PPUSH
73533: LD_VAR 0 3
73537: PPUSH
73538: CALL_OW 74
73542: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
73543: LD_VAR 0 8
73547: PPUSH
73548: LD_INT 16
73550: PPUSH
73551: CALL 28076 0 2
73555: PUSH
73556: LD_INT 4
73558: ARRAY
73559: PUSH
73560: LD_INT 14
73562: LESS
73563: IFFALSE 73579
// ComRepairBuilding ( j , to_repair ) ;
73565: LD_VAR 0 3
73569: PPUSH
73570: LD_VAR 0 8
73574: PPUSH
73575: CALL_OW 130
// end ;
73579: GO 73321
73581: POP
73582: POP
// end ;
73583: GO 72687
73585: POP
73586: POP
// end ;
73587: LD_VAR 0 1
73591: RET
// export function MC_Heal ; var i , j , tmp ; begin
73592: LD_INT 0
73594: PPUSH
73595: PPUSH
73596: PPUSH
73597: PPUSH
// if not mc_bases then
73598: LD_EXP 31
73602: NOT
73603: IFFALSE 73607
// exit ;
73605: GO 74013
// for i = 1 to mc_bases do
73607: LD_ADDR_VAR 0 2
73611: PUSH
73612: DOUBLE
73613: LD_INT 1
73615: DEC
73616: ST_TO_ADDR
73617: LD_EXP 31
73621: PUSH
73622: FOR_TO
73623: IFFALSE 74011
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
73625: LD_EXP 34
73629: PUSH
73630: LD_VAR 0 2
73634: ARRAY
73635: PUSH
73636: LD_INT 1
73638: ARRAY
73639: NOT
73640: IFFALSE 73659
73642: PUSH
73643: LD_EXP 34
73647: PUSH
73648: LD_VAR 0 2
73652: ARRAY
73653: PUSH
73654: LD_INT 2
73656: ARRAY
73657: NOT
73658: AND
73659: IFFALSE 73697
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
73661: LD_ADDR_EXP 35
73665: PUSH
73666: LD_EXP 35
73670: PPUSH
73671: LD_VAR 0 2
73675: PPUSH
73676: EMPTY
73677: PPUSH
73678: CALL_OW 1
73682: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
73683: LD_VAR 0 2
73687: PPUSH
73688: LD_INT 102
73690: PPUSH
73691: CALL 67678 0 2
// continue ;
73695: GO 73622
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73697: LD_ADDR_VAR 0 4
73701: PUSH
73702: LD_EXP 31
73706: PUSH
73707: LD_VAR 0 2
73711: ARRAY
73712: PPUSH
73713: LD_INT 25
73715: PUSH
73716: LD_INT 4
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PPUSH
73723: CALL_OW 72
73727: ST_TO_ADDR
// if not tmp then
73728: LD_VAR 0 4
73732: NOT
73733: IFFALSE 73737
// continue ;
73735: GO 73622
// if mc_taming [ i ] then
73737: LD_EXP 62
73741: PUSH
73742: LD_VAR 0 2
73746: ARRAY
73747: IFFALSE 73771
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73749: LD_ADDR_EXP 62
73753: PUSH
73754: LD_EXP 62
73758: PPUSH
73759: LD_VAR 0 2
73763: PPUSH
73764: EMPTY
73765: PPUSH
73766: CALL_OW 1
73770: ST_TO_ADDR
// for j in tmp do
73771: LD_ADDR_VAR 0 3
73775: PUSH
73776: LD_VAR 0 4
73780: PUSH
73781: FOR_IN
73782: IFFALSE 74007
// begin if IsInUnit ( j ) then
73784: LD_VAR 0 3
73788: PPUSH
73789: CALL_OW 310
73793: IFFALSE 73804
// ComExitBuilding ( j ) ;
73795: LD_VAR 0 3
73799: PPUSH
73800: CALL_OW 122
// if not j in mc_healers [ i ] then
73804: LD_VAR 0 3
73808: PUSH
73809: LD_EXP 35
73813: PUSH
73814: LD_VAR 0 2
73818: ARRAY
73819: IN
73820: NOT
73821: IFFALSE 73867
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
73823: LD_ADDR_EXP 35
73827: PUSH
73828: LD_EXP 35
73832: PPUSH
73833: LD_VAR 0 2
73837: PUSH
73838: LD_EXP 35
73842: PUSH
73843: LD_VAR 0 2
73847: ARRAY
73848: PUSH
73849: LD_INT 1
73851: PLUS
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PPUSH
73857: LD_VAR 0 3
73861: PPUSH
73862: CALL 25097 0 3
73866: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
73867: LD_VAR 0 3
73871: PPUSH
73872: CALL_OW 110
73876: PUSH
73877: LD_INT 102
73879: NONEQUAL
73880: IFFALSE 73894
// SetTag ( j , 102 ) ;
73882: LD_VAR 0 3
73886: PPUSH
73887: LD_INT 102
73889: PPUSH
73890: CALL_OW 109
// Wait ( 3 ) ;
73894: LD_INT 3
73896: PPUSH
73897: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
73901: LD_EXP 34
73905: PUSH
73906: LD_VAR 0 2
73910: ARRAY
73911: PUSH
73912: LD_INT 1
73914: ARRAY
73915: IFFALSE 73947
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
73917: LD_VAR 0 3
73921: PPUSH
73922: LD_EXP 34
73926: PUSH
73927: LD_VAR 0 2
73931: ARRAY
73932: PUSH
73933: LD_INT 1
73935: ARRAY
73936: PUSH
73937: LD_INT 1
73939: ARRAY
73940: PPUSH
73941: CALL_OW 128
73945: GO 74005
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
73947: LD_VAR 0 3
73951: PPUSH
73952: CALL_OW 314
73956: NOT
73957: IFFALSE 73975
73959: PUSH
73960: LD_EXP 34
73964: PUSH
73965: LD_VAR 0 2
73969: ARRAY
73970: PUSH
73971: LD_INT 2
73973: ARRAY
73974: AND
73975: IFFALSE 74005
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
73977: LD_VAR 0 3
73981: PPUSH
73982: LD_EXP 34
73986: PUSH
73987: LD_VAR 0 2
73991: ARRAY
73992: PUSH
73993: LD_INT 2
73995: ARRAY
73996: PUSH
73997: LD_INT 1
73999: ARRAY
74000: PPUSH
74001: CALL_OW 128
// end ;
74005: GO 73781
74007: POP
74008: POP
// end ;
74009: GO 73622
74011: POP
74012: POP
// end ;
74013: LD_VAR 0 1
74017: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
74018: LD_INT 0
74020: PPUSH
74021: PPUSH
74022: PPUSH
74023: PPUSH
74024: PPUSH
74025: PPUSH
// if not mc_bases then
74026: LD_EXP 31
74030: NOT
74031: IFFALSE 74035
// exit ;
74033: GO 75206
// for i = 1 to mc_bases do
74035: LD_ADDR_VAR 0 2
74039: PUSH
74040: DOUBLE
74041: LD_INT 1
74043: DEC
74044: ST_TO_ADDR
74045: LD_EXP 31
74049: PUSH
74050: FOR_TO
74051: IFFALSE 75204
// begin if mc_scan [ i ] then
74053: LD_EXP 54
74057: PUSH
74058: LD_VAR 0 2
74062: ARRAY
74063: IFFALSE 74067
// continue ;
74065: GO 74050
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
74067: LD_EXP 36
74071: PUSH
74072: LD_VAR 0 2
74076: ARRAY
74077: NOT
74078: IFFALSE 74093
74080: PUSH
74081: LD_EXP 38
74085: PUSH
74086: LD_VAR 0 2
74090: ARRAY
74091: NOT
74092: AND
74093: IFFALSE 74107
74095: PUSH
74096: LD_EXP 37
74100: PUSH
74101: LD_VAR 0 2
74105: ARRAY
74106: AND
74107: IFFALSE 74145
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
74109: LD_ADDR_EXP 37
74113: PUSH
74114: LD_EXP 37
74118: PPUSH
74119: LD_VAR 0 2
74123: PPUSH
74124: EMPTY
74125: PPUSH
74126: CALL_OW 1
74130: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
74131: LD_VAR 0 2
74135: PPUSH
74136: LD_INT 103
74138: PPUSH
74139: CALL 67678 0 2
// continue ;
74143: GO 74050
// end ; if mc_construct_list [ i ] then
74145: LD_EXP 38
74149: PUSH
74150: LD_VAR 0 2
74154: ARRAY
74155: IFFALSE 74375
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
74157: LD_ADDR_VAR 0 5
74161: PUSH
74162: LD_EXP 31
74166: PUSH
74167: LD_VAR 0 2
74171: ARRAY
74172: PPUSH
74173: LD_INT 25
74175: PUSH
74176: LD_INT 2
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PPUSH
74183: CALL_OW 72
74187: PUSH
74188: LD_EXP 33
74192: PUSH
74193: LD_VAR 0 2
74197: ARRAY
74198: DIFF
74199: ST_TO_ADDR
// if not tmp then
74200: LD_VAR 0 5
74204: NOT
74205: IFFALSE 74209
// continue ;
74207: GO 74050
// for j in tmp do
74209: LD_ADDR_VAR 0 3
74213: PUSH
74214: LD_VAR 0 5
74218: PUSH
74219: FOR_IN
74220: IFFALSE 74371
// begin if not mc_builders [ i ] then
74222: LD_EXP 37
74226: PUSH
74227: LD_VAR 0 2
74231: ARRAY
74232: NOT
74233: IFFALSE 74291
// begin SetTag ( j , 103 ) ;
74235: LD_VAR 0 3
74239: PPUSH
74240: LD_INT 103
74242: PPUSH
74243: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
74247: LD_ADDR_EXP 37
74251: PUSH
74252: LD_EXP 37
74256: PPUSH
74257: LD_VAR 0 2
74261: PUSH
74262: LD_EXP 37
74266: PUSH
74267: LD_VAR 0 2
74271: ARRAY
74272: PUSH
74273: LD_INT 1
74275: PLUS
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PPUSH
74281: LD_VAR 0 3
74285: PPUSH
74286: CALL 25097 0 3
74290: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
74291: LD_VAR 0 3
74295: PPUSH
74296: CALL_OW 310
74300: IFFALSE 74311
// ComExitBuilding ( j ) ;
74302: LD_VAR 0 3
74306: PPUSH
74307: CALL_OW 122
// wait ( 3 ) ;
74311: LD_INT 3
74313: PPUSH
74314: CALL_OW 67
// if not mc_construct_list [ i ] then
74318: LD_EXP 38
74322: PUSH
74323: LD_VAR 0 2
74327: ARRAY
74328: NOT
74329: IFFALSE 74333
// break ;
74331: GO 74371
// if not HasTask ( j ) then
74333: LD_VAR 0 3
74337: PPUSH
74338: CALL_OW 314
74342: NOT
74343: IFFALSE 74369
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
74345: LD_VAR 0 3
74349: PPUSH
74350: LD_EXP 38
74354: PUSH
74355: LD_VAR 0 2
74359: ARRAY
74360: PUSH
74361: LD_INT 1
74363: ARRAY
74364: PPUSH
74365: CALL 28349 0 2
// end ;
74369: GO 74219
74371: POP
74372: POP
// end else
74373: GO 75202
// if mc_build_list [ i ] then
74375: LD_EXP 36
74379: PUSH
74380: LD_VAR 0 2
74384: ARRAY
74385: IFFALSE 75202
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
74387: LD_EXP 36
74391: PUSH
74392: LD_VAR 0 2
74396: ARRAY
74397: PUSH
74398: LD_INT 1
74400: ARRAY
74401: PUSH
74402: LD_INT 1
74404: ARRAY
74405: PPUSH
74406: CALL 28173 0 1
74410: IFFALSE 74458
74412: PUSH
74413: LD_EXP 31
74417: PUSH
74418: LD_VAR 0 2
74422: ARRAY
74423: PPUSH
74424: LD_INT 2
74426: PUSH
74427: LD_INT 30
74429: PUSH
74430: LD_INT 2
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 30
74439: PUSH
74440: LD_INT 3
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: LIST
74451: PPUSH
74452: CALL_OW 72
74456: NOT
74457: AND
74458: IFFALSE 74563
// begin for j = 1 to mc_build_list [ i ] do
74460: LD_ADDR_VAR 0 3
74464: PUSH
74465: DOUBLE
74466: LD_INT 1
74468: DEC
74469: ST_TO_ADDR
74470: LD_EXP 36
74474: PUSH
74475: LD_VAR 0 2
74479: ARRAY
74480: PUSH
74481: FOR_TO
74482: IFFALSE 74561
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
74484: LD_EXP 36
74488: PUSH
74489: LD_VAR 0 2
74493: ARRAY
74494: PUSH
74495: LD_VAR 0 3
74499: ARRAY
74500: PUSH
74501: LD_INT 1
74503: ARRAY
74504: PUSH
74505: LD_INT 2
74507: EQUAL
74508: IFFALSE 74559
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
74510: LD_ADDR_EXP 36
74514: PUSH
74515: LD_EXP 36
74519: PPUSH
74520: LD_VAR 0 2
74524: PPUSH
74525: LD_EXP 36
74529: PUSH
74530: LD_VAR 0 2
74534: ARRAY
74535: PPUSH
74536: LD_VAR 0 3
74540: PPUSH
74541: LD_INT 1
74543: PPUSH
74544: LD_INT 0
74546: PPUSH
74547: CALL 24505 0 4
74551: PPUSH
74552: CALL_OW 1
74556: ST_TO_ADDR
// break ;
74557: GO 74561
// end ;
74559: GO 74481
74561: POP
74562: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74563: LD_ADDR_VAR 0 6
74567: PUSH
74568: LD_EXP 31
74572: PUSH
74573: LD_VAR 0 2
74577: ARRAY
74578: PPUSH
74579: LD_INT 2
74581: PUSH
74582: LD_INT 30
74584: PUSH
74585: LD_INT 0
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 30
74594: PUSH
74595: LD_INT 1
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: LIST
74606: PPUSH
74607: CALL_OW 72
74611: ST_TO_ADDR
// for k := 1 to depot do
74612: LD_ADDR_VAR 0 4
74616: PUSH
74617: DOUBLE
74618: LD_INT 1
74620: DEC
74621: ST_TO_ADDR
74622: LD_VAR 0 6
74626: PUSH
74627: FOR_TO
74628: IFFALSE 75200
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
74630: LD_EXP 36
74634: PUSH
74635: LD_VAR 0 2
74639: ARRAY
74640: PUSH
74641: LD_INT 1
74643: ARRAY
74644: PUSH
74645: LD_INT 1
74647: ARRAY
74648: PUSH
74649: LD_INT 0
74651: EQUAL
74652: IFTRUE 74747
74654: PUSH
74655: LD_VAR 0 6
74659: PUSH
74660: LD_VAR 0 4
74664: ARRAY
74665: PPUSH
74666: LD_EXP 36
74670: PUSH
74671: LD_VAR 0 2
74675: ARRAY
74676: PUSH
74677: LD_INT 1
74679: ARRAY
74680: PUSH
74681: LD_INT 1
74683: ARRAY
74684: PPUSH
74685: LD_EXP 36
74689: PUSH
74690: LD_VAR 0 2
74694: ARRAY
74695: PUSH
74696: LD_INT 1
74698: ARRAY
74699: PUSH
74700: LD_INT 2
74702: ARRAY
74703: PPUSH
74704: LD_EXP 36
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: PUSH
74715: LD_INT 1
74717: ARRAY
74718: PUSH
74719: LD_INT 3
74721: ARRAY
74722: PPUSH
74723: LD_EXP 36
74727: PUSH
74728: LD_VAR 0 2
74732: ARRAY
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: PUSH
74738: LD_INT 4
74740: ARRAY
74741: PPUSH
74742: CALL 33653 0 5
74746: OR
74747: IFFALSE 75028
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
74749: LD_ADDR_VAR 0 5
74753: PUSH
74754: LD_EXP 31
74758: PUSH
74759: LD_VAR 0 2
74763: ARRAY
74764: PPUSH
74765: LD_INT 25
74767: PUSH
74768: LD_INT 2
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PPUSH
74775: CALL_OW 72
74779: PUSH
74780: LD_EXP 33
74784: PUSH
74785: LD_VAR 0 2
74789: ARRAY
74790: DIFF
74791: ST_TO_ADDR
// if not tmp then
74792: LD_VAR 0 5
74796: NOT
74797: IFFALSE 74801
// continue ;
74799: GO 74627
// for j in tmp do
74801: LD_ADDR_VAR 0 3
74805: PUSH
74806: LD_VAR 0 5
74810: PUSH
74811: FOR_IN
74812: IFFALSE 75024
// begin if not mc_builders [ i ] then
74814: LD_EXP 37
74818: PUSH
74819: LD_VAR 0 2
74823: ARRAY
74824: NOT
74825: IFFALSE 74883
// begin SetTag ( j , 103 ) ;
74827: LD_VAR 0 3
74831: PPUSH
74832: LD_INT 103
74834: PPUSH
74835: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
74839: LD_ADDR_EXP 37
74843: PUSH
74844: LD_EXP 37
74848: PPUSH
74849: LD_VAR 0 2
74853: PUSH
74854: LD_EXP 37
74858: PUSH
74859: LD_VAR 0 2
74863: ARRAY
74864: PUSH
74865: LD_INT 1
74867: PLUS
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PPUSH
74873: LD_VAR 0 3
74877: PPUSH
74878: CALL 25097 0 3
74882: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
74883: LD_VAR 0 3
74887: PPUSH
74888: CALL_OW 310
74892: IFFALSE 74903
// ComExitBuilding ( j ) ;
74894: LD_VAR 0 3
74898: PPUSH
74899: CALL_OW 122
// wait ( 3 ) ;
74903: LD_INT 3
74905: PPUSH
74906: CALL_OW 67
// if not mc_build_list [ i ] then
74910: LD_EXP 36
74914: PUSH
74915: LD_VAR 0 2
74919: ARRAY
74920: NOT
74921: IFFALSE 74925
// break ;
74923: GO 75024
// if not HasTask ( j ) then
74925: LD_VAR 0 3
74929: PPUSH
74930: CALL_OW 314
74934: NOT
74935: IFFALSE 75022
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
74937: LD_VAR 0 3
74941: PPUSH
74942: LD_EXP 36
74946: PUSH
74947: LD_VAR 0 2
74951: ARRAY
74952: PUSH
74953: LD_INT 1
74955: ARRAY
74956: PUSH
74957: LD_INT 1
74959: ARRAY
74960: PPUSH
74961: LD_EXP 36
74965: PUSH
74966: LD_VAR 0 2
74970: ARRAY
74971: PUSH
74972: LD_INT 1
74974: ARRAY
74975: PUSH
74976: LD_INT 2
74978: ARRAY
74979: PPUSH
74980: LD_EXP 36
74984: PUSH
74985: LD_VAR 0 2
74989: ARRAY
74990: PUSH
74991: LD_INT 1
74993: ARRAY
74994: PUSH
74995: LD_INT 3
74997: ARRAY
74998: PPUSH
74999: LD_EXP 36
75003: PUSH
75004: LD_VAR 0 2
75008: ARRAY
75009: PUSH
75010: LD_INT 1
75012: ARRAY
75013: PUSH
75014: LD_INT 4
75016: ARRAY
75017: PPUSH
75018: CALL_OW 145
// end ;
75022: GO 74811
75024: POP
75025: POP
// end else
75026: GO 75198
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
75028: LD_EXP 31
75032: PUSH
75033: LD_VAR 0 2
75037: ARRAY
75038: PPUSH
75039: LD_EXP 36
75043: PUSH
75044: LD_VAR 0 2
75048: ARRAY
75049: PUSH
75050: LD_INT 1
75052: ARRAY
75053: PUSH
75054: LD_INT 1
75056: ARRAY
75057: PPUSH
75058: LD_EXP 36
75062: PUSH
75063: LD_VAR 0 2
75067: ARRAY
75068: PUSH
75069: LD_INT 1
75071: ARRAY
75072: PUSH
75073: LD_INT 2
75075: ARRAY
75076: PPUSH
75077: LD_EXP 36
75081: PUSH
75082: LD_VAR 0 2
75086: ARRAY
75087: PUSH
75088: LD_INT 1
75090: ARRAY
75091: PUSH
75092: LD_INT 3
75094: ARRAY
75095: PPUSH
75096: LD_EXP 36
75100: PUSH
75101: LD_VAR 0 2
75105: ARRAY
75106: PUSH
75107: LD_INT 1
75109: ARRAY
75110: PUSH
75111: LD_INT 4
75113: ARRAY
75114: PPUSH
75115: LD_EXP 31
75119: PUSH
75120: LD_VAR 0 2
75124: ARRAY
75125: PPUSH
75126: LD_INT 21
75128: PUSH
75129: LD_INT 3
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PPUSH
75136: CALL_OW 72
75140: PPUSH
75141: EMPTY
75142: PPUSH
75143: CALL 32389 0 7
75147: NOT
75148: IFFALSE 75198
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
75150: LD_ADDR_EXP 36
75154: PUSH
75155: LD_EXP 36
75159: PPUSH
75160: LD_VAR 0 2
75164: PPUSH
75165: LD_EXP 36
75169: PUSH
75170: LD_VAR 0 2
75174: ARRAY
75175: PPUSH
75176: LD_INT 1
75178: PPUSH
75179: LD_INT 1
75181: NEG
75182: PPUSH
75183: LD_INT 0
75185: PPUSH
75186: CALL 24505 0 4
75190: PPUSH
75191: CALL_OW 1
75195: ST_TO_ADDR
// continue ;
75196: GO 74627
// end ; end ;
75198: GO 74627
75200: POP
75201: POP
// end ; end ;
75202: GO 74050
75204: POP
75205: POP
// end ;
75206: LD_VAR 0 1
75210: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
75211: LD_INT 0
75213: PPUSH
75214: PPUSH
75215: PPUSH
75216: PPUSH
75217: PPUSH
75218: PPUSH
// if not mc_bases then
75219: LD_EXP 31
75223: NOT
75224: IFFALSE 75228
// exit ;
75226: GO 75661
// for i = 1 to mc_bases do
75228: LD_ADDR_VAR 0 2
75232: PUSH
75233: DOUBLE
75234: LD_INT 1
75236: DEC
75237: ST_TO_ADDR
75238: LD_EXP 31
75242: PUSH
75243: FOR_TO
75244: IFFALSE 75659
// begin tmp := mc_build_upgrade [ i ] ;
75246: LD_ADDR_VAR 0 4
75250: PUSH
75251: LD_EXP 63
75255: PUSH
75256: LD_VAR 0 2
75260: ARRAY
75261: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
75262: LD_ADDR_VAR 0 6
75266: PUSH
75267: LD_EXP 64
75271: PUSH
75272: LD_VAR 0 2
75276: ARRAY
75277: PPUSH
75278: LD_INT 2
75280: PUSH
75281: LD_INT 30
75283: PUSH
75284: LD_INT 6
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 30
75293: PUSH
75294: LD_INT 7
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: LIST
75305: PPUSH
75306: CALL_OW 72
75310: ST_TO_ADDR
// if not tmp and not lab then
75311: LD_VAR 0 4
75315: NOT
75316: IFFALSE 75325
75318: PUSH
75319: LD_VAR 0 6
75323: NOT
75324: AND
75325: IFFALSE 75329
// continue ;
75327: GO 75243
// if tmp then
75329: LD_VAR 0 4
75333: IFFALSE 75453
// for j in tmp do
75335: LD_ADDR_VAR 0 3
75339: PUSH
75340: LD_VAR 0 4
75344: PUSH
75345: FOR_IN
75346: IFFALSE 75451
// begin if UpgradeCost ( j ) then
75348: LD_VAR 0 3
75352: PPUSH
75353: CALL 32041 0 1
75357: IFFALSE 75449
// begin ComUpgrade ( j ) ;
75359: LD_VAR 0 3
75363: PPUSH
75364: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
75368: LD_ADDR_EXP 63
75372: PUSH
75373: LD_EXP 63
75377: PPUSH
75378: LD_VAR 0 2
75382: PPUSH
75383: LD_EXP 63
75387: PUSH
75388: LD_VAR 0 2
75392: ARRAY
75393: PUSH
75394: LD_VAR 0 3
75398: DIFF
75399: PPUSH
75400: CALL_OW 1
75404: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
75405: LD_ADDR_EXP 38
75409: PUSH
75410: LD_EXP 38
75414: PPUSH
75415: LD_VAR 0 2
75419: PUSH
75420: LD_EXP 38
75424: PUSH
75425: LD_VAR 0 2
75429: ARRAY
75430: PUSH
75431: LD_INT 1
75433: PLUS
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PPUSH
75439: LD_VAR 0 3
75443: PPUSH
75444: CALL 25097 0 3
75448: ST_TO_ADDR
// end ; end ;
75449: GO 75345
75451: POP
75452: POP
// if not lab or not mc_lab_upgrade [ i ] then
75453: LD_VAR 0 6
75457: NOT
75458: IFTRUE 75473
75460: PUSH
75461: LD_EXP 65
75465: PUSH
75466: LD_VAR 0 2
75470: ARRAY
75471: NOT
75472: OR
75473: IFFALSE 75477
// continue ;
75475: GO 75243
// for j in lab do
75477: LD_ADDR_VAR 0 3
75481: PUSH
75482: LD_VAR 0 6
75486: PUSH
75487: FOR_IN
75488: IFFALSE 75655
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
75490: LD_VAR 0 3
75494: PPUSH
75495: CALL_OW 266
75499: PUSH
75500: LD_INT 6
75502: PUSH
75503: LD_INT 7
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: IN
75510: IFFALSE 75527
75512: PUSH
75513: LD_VAR 0 3
75517: PPUSH
75518: CALL_OW 461
75522: PUSH
75523: LD_INT 1
75525: NONEQUAL
75526: AND
75527: IFFALSE 75653
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
75529: LD_VAR 0 3
75533: PPUSH
75534: LD_EXP 65
75538: PUSH
75539: LD_VAR 0 2
75543: ARRAY
75544: PUSH
75545: LD_INT 1
75547: ARRAY
75548: PPUSH
75549: CALL 32250 0 2
75553: IFFALSE 75653
// begin ComCancel ( j ) ;
75555: LD_VAR 0 3
75559: PPUSH
75560: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
75564: LD_VAR 0 3
75568: PPUSH
75569: LD_EXP 65
75573: PUSH
75574: LD_VAR 0 2
75578: ARRAY
75579: PUSH
75580: LD_INT 1
75582: ARRAY
75583: PPUSH
75584: CALL_OW 207
// if not j in mc_construct_list [ i ] then
75588: LD_VAR 0 3
75592: PUSH
75593: LD_EXP 38
75597: PUSH
75598: LD_VAR 0 2
75602: ARRAY
75603: IN
75604: NOT
75605: IFFALSE 75651
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
75607: LD_ADDR_EXP 38
75611: PUSH
75612: LD_EXP 38
75616: PPUSH
75617: LD_VAR 0 2
75621: PUSH
75622: LD_EXP 38
75626: PUSH
75627: LD_VAR 0 2
75631: ARRAY
75632: PUSH
75633: LD_INT 1
75635: PLUS
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PPUSH
75641: LD_VAR 0 3
75645: PPUSH
75646: CALL 25097 0 3
75650: ST_TO_ADDR
// break ;
75651: GO 75655
// end ; end ; end ;
75653: GO 75487
75655: POP
75656: POP
// end ;
75657: GO 75243
75659: POP
75660: POP
// end ;
75661: LD_VAR 0 1
75665: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
75666: LD_INT 0
75668: PPUSH
75669: PPUSH
75670: PPUSH
75671: PPUSH
75672: PPUSH
75673: PPUSH
75674: PPUSH
75675: PPUSH
75676: PPUSH
// if not mc_bases then
75677: LD_EXP 31
75681: NOT
75682: IFFALSE 75686
// exit ;
75684: GO 76093
// for i = 1 to mc_bases do
75686: LD_ADDR_VAR 0 2
75690: PUSH
75691: DOUBLE
75692: LD_INT 1
75694: DEC
75695: ST_TO_ADDR
75696: LD_EXP 31
75700: PUSH
75701: FOR_TO
75702: IFFALSE 76091
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
75704: LD_EXP 39
75708: PUSH
75709: LD_VAR 0 2
75713: ARRAY
75714: NOT
75715: IFTRUE 75745
75717: PUSH
75718: LD_EXP 31
75722: PUSH
75723: LD_VAR 0 2
75727: ARRAY
75728: PPUSH
75729: LD_INT 30
75731: PUSH
75732: LD_INT 3
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PPUSH
75739: CALL_OW 72
75743: NOT
75744: OR
75745: IFFALSE 75749
// continue ;
75747: GO 75701
// busy := false ;
75749: LD_ADDR_VAR 0 8
75753: PUSH
75754: LD_INT 0
75756: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75757: LD_ADDR_VAR 0 4
75761: PUSH
75762: LD_EXP 31
75766: PUSH
75767: LD_VAR 0 2
75771: ARRAY
75772: PPUSH
75773: LD_INT 30
75775: PUSH
75776: LD_INT 3
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PPUSH
75783: CALL_OW 72
75787: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
75788: LD_ADDR_VAR 0 6
75792: PUSH
75793: LD_EXP 39
75797: PUSH
75798: LD_VAR 0 2
75802: ARRAY
75803: PPUSH
75804: LD_INT 2
75806: PUSH
75807: LD_INT 30
75809: PUSH
75810: LD_INT 32
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 30
75819: PUSH
75820: LD_INT 33
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: LIST
75831: PPUSH
75832: CALL_OW 72
75836: ST_TO_ADDR
// if not t then
75837: LD_VAR 0 6
75841: NOT
75842: IFFALSE 75846
// continue ;
75844: GO 75701
// for j in tmp do
75846: LD_ADDR_VAR 0 3
75850: PUSH
75851: LD_VAR 0 4
75855: PUSH
75856: FOR_IN
75857: IFFALSE 75887
// if not BuildingStatus ( j ) = bs_idle then
75859: LD_VAR 0 3
75863: PPUSH
75864: CALL_OW 461
75868: PUSH
75869: LD_INT 2
75871: EQUAL
75872: NOT
75873: IFFALSE 75885
// begin busy := true ;
75875: LD_ADDR_VAR 0 8
75879: PUSH
75880: LD_INT 1
75882: ST_TO_ADDR
// break ;
75883: GO 75887
// end ;
75885: GO 75856
75887: POP
75888: POP
// if busy then
75889: LD_VAR 0 8
75893: IFFALSE 75897
// continue ;
75895: GO 75701
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
75897: LD_ADDR_VAR 0 7
75901: PUSH
75902: LD_VAR 0 6
75906: PPUSH
75907: LD_INT 35
75909: PUSH
75910: LD_INT 0
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PPUSH
75917: CALL_OW 72
75921: ST_TO_ADDR
// if tw then
75922: LD_VAR 0 7
75926: IFFALSE 76003
// begin tw := tw [ 1 ] ;
75928: LD_ADDR_VAR 0 7
75932: PUSH
75933: LD_VAR 0 7
75937: PUSH
75938: LD_INT 1
75940: ARRAY
75941: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
75942: LD_ADDR_VAR 0 9
75946: PUSH
75947: LD_VAR 0 7
75951: PPUSH
75952: LD_EXP 56
75956: PUSH
75957: LD_VAR 0 2
75961: ARRAY
75962: PPUSH
75963: CALL 30504 0 2
75967: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
75968: LD_EXP 70
75972: PUSH
75973: LD_VAR 0 2
75977: ARRAY
75978: IFFALSE 76001
// if not weapon in mc_allowed_tower_weapons [ i ] then
75980: LD_VAR 0 9
75984: PUSH
75985: LD_EXP 70
75989: PUSH
75990: LD_VAR 0 2
75994: ARRAY
75995: IN
75996: NOT
75997: IFFALSE 76001
// continue ;
75999: GO 75701
// end else
76001: GO 76066
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
76003: LD_ADDR_VAR 0 5
76007: PUSH
76008: LD_EXP 39
76012: PUSH
76013: LD_VAR 0 2
76017: ARRAY
76018: PPUSH
76019: LD_VAR 0 4
76023: PPUSH
76024: CALL 57699 0 2
76028: ST_TO_ADDR
// if not tmp2 then
76029: LD_VAR 0 5
76033: NOT
76034: IFFALSE 76038
// continue ;
76036: GO 75701
// tw := tmp2 [ 1 ] ;
76038: LD_ADDR_VAR 0 7
76042: PUSH
76043: LD_VAR 0 5
76047: PUSH
76048: LD_INT 1
76050: ARRAY
76051: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
76052: LD_ADDR_VAR 0 9
76056: PUSH
76057: LD_VAR 0 5
76061: PUSH
76062: LD_INT 2
76064: ARRAY
76065: ST_TO_ADDR
// end ; if not weapon then
76066: LD_VAR 0 9
76070: NOT
76071: IFFALSE 76075
// continue ;
76073: GO 75701
// ComPlaceWeapon ( tw , weapon ) ;
76075: LD_VAR 0 7
76079: PPUSH
76080: LD_VAR 0 9
76084: PPUSH
76085: CALL_OW 148
// end ;
76089: GO 75701
76091: POP
76092: POP
// end ;
76093: LD_VAR 0 1
76097: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
76098: LD_INT 0
76100: PPUSH
76101: PPUSH
76102: PPUSH
76103: PPUSH
76104: PPUSH
76105: PPUSH
76106: PPUSH
// if not mc_bases then
76107: LD_EXP 31
76111: NOT
76112: IFFALSE 76116
// exit ;
76114: GO 76903
// for i = 1 to mc_bases do
76116: LD_ADDR_VAR 0 2
76120: PUSH
76121: DOUBLE
76122: LD_INT 1
76124: DEC
76125: ST_TO_ADDR
76126: LD_EXP 31
76130: PUSH
76131: FOR_TO
76132: IFFALSE 76901
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
76134: LD_EXP 44
76138: PUSH
76139: LD_VAR 0 2
76143: ARRAY
76144: NOT
76145: IFTRUE 76171
76147: PUSH
76148: LD_EXP 44
76152: PUSH
76153: LD_VAR 0 2
76157: ARRAY
76158: PUSH
76159: LD_EXP 45
76163: PUSH
76164: LD_VAR 0 2
76168: ARRAY
76169: EQUAL
76170: OR
76171: IFTRUE 76185
76173: PUSH
76174: LD_EXP 54
76178: PUSH
76179: LD_VAR 0 2
76183: ARRAY
76184: OR
76185: IFFALSE 76189
// continue ;
76187: GO 76131
// if mc_miners [ i ] then
76189: LD_EXP 45
76193: PUSH
76194: LD_VAR 0 2
76198: ARRAY
76199: IFFALSE 76586
// begin for j = mc_miners [ i ] downto 1 do
76201: LD_ADDR_VAR 0 3
76205: PUSH
76206: DOUBLE
76207: LD_EXP 45
76211: PUSH
76212: LD_VAR 0 2
76216: ARRAY
76217: INC
76218: ST_TO_ADDR
76219: LD_INT 1
76221: PUSH
76222: FOR_DOWNTO
76223: IFFALSE 76584
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
76225: LD_EXP 45
76229: PUSH
76230: LD_VAR 0 2
76234: ARRAY
76235: PUSH
76236: LD_VAR 0 3
76240: ARRAY
76241: PPUSH
76242: CALL_OW 301
76246: IFTRUE 76275
76248: PUSH
76249: LD_EXP 45
76253: PUSH
76254: LD_VAR 0 2
76258: ARRAY
76259: PUSH
76260: LD_VAR 0 3
76264: ARRAY
76265: PPUSH
76266: CALL_OW 257
76270: PUSH
76271: LD_INT 1
76273: NONEQUAL
76274: OR
76275: IFFALSE 76338
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
76277: LD_ADDR_VAR 0 5
76281: PUSH
76282: LD_EXP 45
76286: PUSH
76287: LD_VAR 0 2
76291: ARRAY
76292: PUSH
76293: LD_EXP 45
76297: PUSH
76298: LD_VAR 0 2
76302: ARRAY
76303: PUSH
76304: LD_VAR 0 3
76308: ARRAY
76309: DIFF
76310: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
76311: LD_ADDR_EXP 45
76315: PUSH
76316: LD_EXP 45
76320: PPUSH
76321: LD_VAR 0 2
76325: PPUSH
76326: LD_VAR 0 5
76330: PPUSH
76331: CALL_OW 1
76335: ST_TO_ADDR
// continue ;
76336: GO 76222
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
76338: LD_EXP 45
76342: PUSH
76343: LD_VAR 0 2
76347: ARRAY
76348: PUSH
76349: LD_VAR 0 3
76353: ARRAY
76354: PPUSH
76355: CALL_OW 257
76359: PUSH
76360: LD_INT 1
76362: EQUAL
76363: IFFALSE 76389
76365: PUSH
76366: LD_EXP 45
76370: PUSH
76371: LD_VAR 0 2
76375: ARRAY
76376: PUSH
76377: LD_VAR 0 3
76381: ARRAY
76382: PPUSH
76383: CALL_OW 459
76387: NOT
76388: AND
76389: IFFALSE 76415
76391: PUSH
76392: LD_EXP 45
76396: PUSH
76397: LD_VAR 0 2
76401: ARRAY
76402: PUSH
76403: LD_VAR 0 3
76407: ARRAY
76408: PPUSH
76409: CALL_OW 314
76413: NOT
76414: AND
76415: IFFALSE 76582
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
76417: LD_EXP 45
76421: PUSH
76422: LD_VAR 0 2
76426: ARRAY
76427: PUSH
76428: LD_VAR 0 3
76432: ARRAY
76433: PPUSH
76434: CALL_OW 310
76438: IFFALSE 76461
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
76440: LD_EXP 45
76444: PUSH
76445: LD_VAR 0 2
76449: ARRAY
76450: PUSH
76451: LD_VAR 0 3
76455: ARRAY
76456: PPUSH
76457: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
76461: LD_EXP 45
76465: PUSH
76466: LD_VAR 0 2
76470: ARRAY
76471: PUSH
76472: LD_VAR 0 3
76476: ARRAY
76477: PPUSH
76478: CALL_OW 314
76482: NOT
76483: IFFALSE 76582
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
76485: LD_ADDR_VAR 0 7
76489: PUSH
76490: LD_VAR 0 3
76494: PUSH
76495: LD_EXP 44
76499: PUSH
76500: LD_VAR 0 2
76504: ARRAY
76505: PPUSH
76506: CALL 22179 0 1
76510: MOD
76511: PUSH
76512: LD_INT 1
76514: PLUS
76515: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
76516: LD_EXP 45
76520: PUSH
76521: LD_VAR 0 2
76525: ARRAY
76526: PUSH
76527: LD_VAR 0 3
76531: ARRAY
76532: PPUSH
76533: LD_EXP 44
76537: PUSH
76538: LD_VAR 0 2
76542: ARRAY
76543: PUSH
76544: LD_VAR 0 7
76548: ARRAY
76549: PUSH
76550: LD_INT 1
76552: ARRAY
76553: PPUSH
76554: LD_EXP 44
76558: PUSH
76559: LD_VAR 0 2
76563: ARRAY
76564: PUSH
76565: LD_VAR 0 7
76569: ARRAY
76570: PUSH
76571: LD_INT 2
76573: ARRAY
76574: PPUSH
76575: LD_INT 0
76577: PPUSH
76578: CALL_OW 193
// end ; end ; end ;
76582: GO 76222
76584: POP
76585: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
76586: LD_ADDR_VAR 0 5
76590: PUSH
76591: LD_EXP 31
76595: PUSH
76596: LD_VAR 0 2
76600: ARRAY
76601: PPUSH
76602: LD_INT 2
76604: PUSH
76605: LD_INT 30
76607: PUSH
76608: LD_INT 4
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 30
76617: PUSH
76618: LD_INT 5
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 30
76627: PUSH
76628: LD_INT 32
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: LIST
76639: LIST
76640: PPUSH
76641: CALL_OW 72
76645: ST_TO_ADDR
// if not tmp then
76646: LD_VAR 0 5
76650: NOT
76651: IFFALSE 76655
// continue ;
76653: GO 76131
// list := [ ] ;
76655: LD_ADDR_VAR 0 6
76659: PUSH
76660: EMPTY
76661: ST_TO_ADDR
// for j in tmp do
76662: LD_ADDR_VAR 0 3
76666: PUSH
76667: LD_VAR 0 5
76671: PUSH
76672: FOR_IN
76673: IFFALSE 76744
// begin for k in UnitsInside ( j ) do
76675: LD_ADDR_VAR 0 4
76679: PUSH
76680: LD_VAR 0 3
76684: PPUSH
76685: CALL_OW 313
76689: PUSH
76690: FOR_IN
76691: IFFALSE 76740
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
76693: LD_VAR 0 4
76697: PPUSH
76698: CALL_OW 257
76702: PUSH
76703: LD_INT 1
76705: EQUAL
76706: IFFALSE 76720
76708: PUSH
76709: LD_VAR 0 4
76713: PPUSH
76714: CALL_OW 459
76718: NOT
76719: AND
76720: IFFALSE 76738
// list := list ^ k ;
76722: LD_ADDR_VAR 0 6
76726: PUSH
76727: LD_VAR 0 6
76731: PUSH
76732: LD_VAR 0 4
76736: ADD
76737: ST_TO_ADDR
76738: GO 76690
76740: POP
76741: POP
// end ;
76742: GO 76672
76744: POP
76745: POP
// list := list diff mc_miners [ i ] ;
76746: LD_ADDR_VAR 0 6
76750: PUSH
76751: LD_VAR 0 6
76755: PUSH
76756: LD_EXP 45
76760: PUSH
76761: LD_VAR 0 2
76765: ARRAY
76766: DIFF
76767: ST_TO_ADDR
// if not list then
76768: LD_VAR 0 6
76772: NOT
76773: IFFALSE 76777
// continue ;
76775: GO 76131
// k := mc_mines [ i ] - mc_miners [ i ] ;
76777: LD_ADDR_VAR 0 4
76781: PUSH
76782: LD_EXP 44
76786: PUSH
76787: LD_VAR 0 2
76791: ARRAY
76792: PUSH
76793: LD_EXP 45
76797: PUSH
76798: LD_VAR 0 2
76802: ARRAY
76803: MINUS
76804: ST_TO_ADDR
// if k > list then
76805: LD_VAR 0 4
76809: PUSH
76810: LD_VAR 0 6
76814: GREATER
76815: IFFALSE 76827
// k := list ;
76817: LD_ADDR_VAR 0 4
76821: PUSH
76822: LD_VAR 0 6
76826: ST_TO_ADDR
// for j = 1 to k do
76827: LD_ADDR_VAR 0 3
76831: PUSH
76832: DOUBLE
76833: LD_INT 1
76835: DEC
76836: ST_TO_ADDR
76837: LD_VAR 0 4
76841: PUSH
76842: FOR_TO
76843: IFFALSE 76897
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
76845: LD_ADDR_EXP 45
76849: PUSH
76850: LD_EXP 45
76854: PPUSH
76855: LD_VAR 0 2
76859: PUSH
76860: LD_EXP 45
76864: PUSH
76865: LD_VAR 0 2
76869: ARRAY
76870: PUSH
76871: LD_INT 1
76873: PLUS
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PPUSH
76879: LD_VAR 0 6
76883: PUSH
76884: LD_VAR 0 3
76888: ARRAY
76889: PPUSH
76890: CALL 25097 0 3
76894: ST_TO_ADDR
76895: GO 76842
76897: POP
76898: POP
// end ;
76899: GO 76131
76901: POP
76902: POP
// end ;
76903: LD_VAR 0 1
76907: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
76908: LD_INT 0
76910: PPUSH
76911: PPUSH
76912: PPUSH
76913: PPUSH
76914: PPUSH
76915: PPUSH
76916: PPUSH
76917: PPUSH
76918: PPUSH
76919: PPUSH
76920: PPUSH
// if not mc_bases then
76921: LD_EXP 31
76925: NOT
76926: IFFALSE 76930
// exit ;
76928: GO 78777
// for i = 1 to mc_bases do
76930: LD_ADDR_VAR 0 2
76934: PUSH
76935: DOUBLE
76936: LD_INT 1
76938: DEC
76939: ST_TO_ADDR
76940: LD_EXP 31
76944: PUSH
76945: FOR_TO
76946: IFFALSE 78775
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
76948: LD_EXP 31
76952: PUSH
76953: LD_VAR 0 2
76957: ARRAY
76958: NOT
76959: IFTRUE 76973
76961: PUSH
76962: LD_EXP 38
76966: PUSH
76967: LD_VAR 0 2
76971: ARRAY
76972: OR
76973: IFFALSE 76977
// continue ;
76975: GO 76945
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
76977: LD_EXP 47
76981: PUSH
76982: LD_VAR 0 2
76986: ARRAY
76987: NOT
76988: IFFALSE 77002
76990: PUSH
76991: LD_EXP 48
76995: PUSH
76996: LD_VAR 0 2
77000: ARRAY
77001: AND
77002: IFFALSE 77040
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
77004: LD_ADDR_EXP 48
77008: PUSH
77009: LD_EXP 48
77013: PPUSH
77014: LD_VAR 0 2
77018: PPUSH
77019: EMPTY
77020: PPUSH
77021: CALL_OW 1
77025: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
77026: LD_VAR 0 2
77030: PPUSH
77031: LD_INT 107
77033: PPUSH
77034: CALL 67678 0 2
// continue ;
77038: GO 76945
// end ; target := [ ] ;
77040: LD_ADDR_VAR 0 7
77044: PUSH
77045: EMPTY
77046: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
77047: LD_ADDR_VAR 0 6
77051: PUSH
77052: LD_EXP 31
77056: PUSH
77057: LD_VAR 0 2
77061: ARRAY
77062: PUSH
77063: LD_INT 1
77065: ARRAY
77066: PPUSH
77067: CALL_OW 255
77071: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77072: LD_ADDR_VAR 0 9
77076: PUSH
77077: LD_EXP 31
77081: PUSH
77082: LD_VAR 0 2
77086: ARRAY
77087: PPUSH
77088: LD_INT 2
77090: PUSH
77091: LD_INT 30
77093: PUSH
77094: LD_INT 0
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 30
77103: PUSH
77104: LD_INT 1
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: LIST
77115: PPUSH
77116: CALL_OW 72
77120: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
77121: LD_ADDR_VAR 0 3
77125: PUSH
77126: DOUBLE
77127: LD_EXP 47
77131: PUSH
77132: LD_VAR 0 2
77136: ARRAY
77137: INC
77138: ST_TO_ADDR
77139: LD_INT 1
77141: PUSH
77142: FOR_DOWNTO
77143: IFFALSE 77390
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
77145: LD_EXP 47
77149: PUSH
77150: LD_VAR 0 2
77154: ARRAY
77155: PUSH
77156: LD_VAR 0 3
77160: ARRAY
77161: PUSH
77162: LD_INT 2
77164: ARRAY
77165: PPUSH
77166: LD_EXP 47
77170: PUSH
77171: LD_VAR 0 2
77175: ARRAY
77176: PUSH
77177: LD_VAR 0 3
77181: ARRAY
77182: PUSH
77183: LD_INT 3
77185: ARRAY
77186: PPUSH
77187: CALL_OW 488
77191: IFFALSE 77245
77193: PUSH
77194: LD_EXP 47
77198: PUSH
77199: LD_VAR 0 2
77203: ARRAY
77204: PUSH
77205: LD_VAR 0 3
77209: ARRAY
77210: PUSH
77211: LD_INT 2
77213: ARRAY
77214: PPUSH
77215: LD_EXP 47
77219: PUSH
77220: LD_VAR 0 2
77224: ARRAY
77225: PUSH
77226: LD_VAR 0 3
77230: ARRAY
77231: PUSH
77232: LD_INT 3
77234: ARRAY
77235: PPUSH
77236: CALL_OW 284
77240: PUSH
77241: LD_INT 0
77243: EQUAL
77244: AND
77245: IFFALSE 77300
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
77247: LD_ADDR_VAR 0 5
77251: PUSH
77252: LD_EXP 47
77256: PUSH
77257: LD_VAR 0 2
77261: ARRAY
77262: PPUSH
77263: LD_VAR 0 3
77267: PPUSH
77268: CALL_OW 3
77272: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
77273: LD_ADDR_EXP 47
77277: PUSH
77278: LD_EXP 47
77282: PPUSH
77283: LD_VAR 0 2
77287: PPUSH
77288: LD_VAR 0 5
77292: PPUSH
77293: CALL_OW 1
77297: ST_TO_ADDR
// continue ;
77298: GO 77142
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
77300: LD_VAR 0 6
77304: PPUSH
77305: LD_EXP 47
77309: PUSH
77310: LD_VAR 0 2
77314: ARRAY
77315: PUSH
77316: LD_VAR 0 3
77320: ARRAY
77321: PUSH
77322: LD_INT 2
77324: ARRAY
77325: PPUSH
77326: LD_EXP 47
77330: PUSH
77331: LD_VAR 0 2
77335: ARRAY
77336: PUSH
77337: LD_VAR 0 3
77341: ARRAY
77342: PUSH
77343: LD_INT 3
77345: ARRAY
77346: PPUSH
77347: LD_INT 30
77349: PPUSH
77350: CALL 26367 0 4
77354: PUSH
77355: LD_INT 4
77357: ARRAY
77358: PUSH
77359: LD_INT 0
77361: EQUAL
77362: IFFALSE 77388
// begin target := mc_crates [ i ] [ j ] ;
77364: LD_ADDR_VAR 0 7
77368: PUSH
77369: LD_EXP 47
77373: PUSH
77374: LD_VAR 0 2
77378: ARRAY
77379: PUSH
77380: LD_VAR 0 3
77384: ARRAY
77385: ST_TO_ADDR
// break ;
77386: GO 77390
// end ; end ;
77388: GO 77142
77390: POP
77391: POP
// if not target then
77392: LD_VAR 0 7
77396: NOT
77397: IFFALSE 77401
// continue ;
77399: GO 76945
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
77401: LD_ADDR_VAR 0 8
77405: PUSH
77406: LD_EXP 50
77410: PUSH
77411: LD_VAR 0 2
77415: ARRAY
77416: PPUSH
77417: LD_INT 2
77419: PUSH
77420: LD_INT 3
77422: PUSH
77423: LD_INT 58
77425: PUSH
77426: EMPTY
77427: LIST
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 61
77435: PUSH
77436: EMPTY
77437: LIST
77438: PUSH
77439: LD_INT 33
77441: PUSH
77442: LD_INT 5
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 33
77451: PUSH
77452: LD_INT 3
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 2
77468: PUSH
77469: LD_INT 34
77471: PUSH
77472: LD_INT 32
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 34
77481: PUSH
77482: LD_INT 51
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 34
77491: PUSH
77492: LD_INT 12
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: LIST
77503: LIST
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PPUSH
77509: CALL_OW 72
77513: ST_TO_ADDR
// if not cargo then
77514: LD_VAR 0 8
77518: NOT
77519: IFFALSE 78233
// begin if mc_crates_collector [ i ] < 5 then
77521: LD_EXP 48
77525: PUSH
77526: LD_VAR 0 2
77530: ARRAY
77531: PUSH
77532: LD_INT 5
77534: LESS
77535: IFFALSE 77905
// begin if mc_ape [ i ] then
77537: LD_EXP 60
77541: PUSH
77542: LD_VAR 0 2
77546: ARRAY
77547: IFFALSE 77594
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
77549: LD_ADDR_VAR 0 5
77553: PUSH
77554: LD_EXP 60
77558: PUSH
77559: LD_VAR 0 2
77563: ARRAY
77564: PPUSH
77565: LD_INT 25
77567: PUSH
77568: LD_INT 16
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 24
77577: PUSH
77578: LD_INT 750
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PPUSH
77589: CALL_OW 72
77593: ST_TO_ADDR
// if not tmp then
77594: LD_VAR 0 5
77598: NOT
77599: IFFALSE 77646
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
77601: LD_ADDR_VAR 0 5
77605: PUSH
77606: LD_EXP 31
77610: PUSH
77611: LD_VAR 0 2
77615: ARRAY
77616: PPUSH
77617: LD_INT 25
77619: PUSH
77620: LD_INT 2
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 24
77629: PUSH
77630: LD_INT 750
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PPUSH
77641: CALL_OW 72
77645: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
77646: LD_EXP 60
77650: PUSH
77651: LD_VAR 0 2
77655: ARRAY
77656: IFFALSE 77699
77658: PUSH
77659: LD_EXP 31
77663: PUSH
77664: LD_VAR 0 2
77668: ARRAY
77669: PPUSH
77670: LD_INT 25
77672: PUSH
77673: LD_INT 2
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 24
77682: PUSH
77683: LD_INT 750
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PPUSH
77694: CALL_OW 72
77698: AND
77699: IFFALSE 77711
77701: PUSH
77702: LD_VAR 0 5
77706: PUSH
77707: LD_INT 5
77709: LESS
77710: AND
77711: IFFALSE 77793
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
77713: LD_ADDR_VAR 0 3
77717: PUSH
77718: LD_EXP 31
77722: PUSH
77723: LD_VAR 0 2
77727: ARRAY
77728: PPUSH
77729: LD_INT 25
77731: PUSH
77732: LD_INT 2
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 24
77741: PUSH
77742: LD_INT 750
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PPUSH
77753: CALL_OW 72
77757: PUSH
77758: FOR_IN
77759: IFFALSE 77791
// begin tmp := tmp union j ;
77761: LD_ADDR_VAR 0 5
77765: PUSH
77766: LD_VAR 0 5
77770: PUSH
77771: LD_VAR 0 3
77775: UNION
77776: ST_TO_ADDR
// if tmp >= 5 then
77777: LD_VAR 0 5
77781: PUSH
77782: LD_INT 5
77784: GREATEREQUAL
77785: IFFALSE 77789
// break ;
77787: GO 77791
// end ;
77789: GO 77758
77791: POP
77792: POP
// end ; if not tmp then
77793: LD_VAR 0 5
77797: NOT
77798: IFFALSE 77802
// continue ;
77800: GO 76945
// for j in tmp do
77802: LD_ADDR_VAR 0 3
77806: PUSH
77807: LD_VAR 0 5
77811: PUSH
77812: FOR_IN
77813: IFFALSE 77903
// if not GetTag ( j ) then
77815: LD_VAR 0 3
77819: PPUSH
77820: CALL_OW 110
77824: NOT
77825: IFFALSE 77901
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
77827: LD_ADDR_EXP 48
77831: PUSH
77832: LD_EXP 48
77836: PPUSH
77837: LD_VAR 0 2
77841: PUSH
77842: LD_EXP 48
77846: PUSH
77847: LD_VAR 0 2
77851: ARRAY
77852: PUSH
77853: LD_INT 1
77855: PLUS
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PPUSH
77861: LD_VAR 0 3
77865: PPUSH
77866: CALL 25097 0 3
77870: ST_TO_ADDR
// SetTag ( j , 107 ) ;
77871: LD_VAR 0 3
77875: PPUSH
77876: LD_INT 107
77878: PPUSH
77879: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
77883: LD_EXP 48
77887: PUSH
77888: LD_VAR 0 2
77892: ARRAY
77893: PUSH
77894: LD_INT 5
77896: GREATEREQUAL
77897: IFFALSE 77901
// break ;
77899: GO 77903
// end ;
77901: GO 77812
77903: POP
77904: POP
// end ; if mc_crates_collector [ i ] and target then
77905: LD_EXP 48
77909: PUSH
77910: LD_VAR 0 2
77914: ARRAY
77915: IFFALSE 77923
77917: PUSH
77918: LD_VAR 0 7
77922: AND
77923: IFFALSE 78231
// begin if mc_crates_collector [ i ] < target [ 1 ] then
77925: LD_EXP 48
77929: PUSH
77930: LD_VAR 0 2
77934: ARRAY
77935: PUSH
77936: LD_VAR 0 7
77940: PUSH
77941: LD_INT 1
77943: ARRAY
77944: LESS
77945: IFFALSE 77965
// tmp := mc_crates_collector [ i ] else
77947: LD_ADDR_VAR 0 5
77951: PUSH
77952: LD_EXP 48
77956: PUSH
77957: LD_VAR 0 2
77961: ARRAY
77962: ST_TO_ADDR
77963: GO 77979
// tmp := target [ 1 ] ;
77965: LD_ADDR_VAR 0 5
77969: PUSH
77970: LD_VAR 0 7
77974: PUSH
77975: LD_INT 1
77977: ARRAY
77978: ST_TO_ADDR
// k := 0 ;
77979: LD_ADDR_VAR 0 4
77983: PUSH
77984: LD_INT 0
77986: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
77987: LD_ADDR_VAR 0 3
77991: PUSH
77992: LD_EXP 48
77996: PUSH
77997: LD_VAR 0 2
78001: ARRAY
78002: PUSH
78003: FOR_IN
78004: IFFALSE 78229
// begin k := k + 1 ;
78006: LD_ADDR_VAR 0 4
78010: PUSH
78011: LD_VAR 0 4
78015: PUSH
78016: LD_INT 1
78018: PLUS
78019: ST_TO_ADDR
// if k > tmp then
78020: LD_VAR 0 4
78024: PUSH
78025: LD_VAR 0 5
78029: GREATER
78030: IFFALSE 78034
// break ;
78032: GO 78229
// if not GetClass ( j ) in [ 2 , 16 ] then
78034: LD_VAR 0 3
78038: PPUSH
78039: CALL_OW 257
78043: PUSH
78044: LD_INT 2
78046: PUSH
78047: LD_INT 16
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: IN
78054: NOT
78055: IFFALSE 78108
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
78057: LD_ADDR_EXP 48
78061: PUSH
78062: LD_EXP 48
78066: PPUSH
78067: LD_VAR 0 2
78071: PPUSH
78072: LD_EXP 48
78076: PUSH
78077: LD_VAR 0 2
78081: ARRAY
78082: PUSH
78083: LD_VAR 0 3
78087: DIFF
78088: PPUSH
78089: CALL_OW 1
78093: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78094: LD_VAR 0 3
78098: PPUSH
78099: LD_INT 0
78101: PPUSH
78102: CALL_OW 109
// continue ;
78106: GO 78003
// end ; if IsInUnit ( j ) then
78108: LD_VAR 0 3
78112: PPUSH
78113: CALL_OW 310
78117: IFFALSE 78128
// ComExitBuilding ( j ) ;
78119: LD_VAR 0 3
78123: PPUSH
78124: CALL_OW 122
// wait ( 3 ) ;
78128: LD_INT 3
78130: PPUSH
78131: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
78135: LD_VAR 0 3
78139: PPUSH
78140: CALL_OW 314
78144: IFFALSE 78182
78146: PUSH
78147: LD_VAR 0 6
78151: PPUSH
78152: LD_VAR 0 7
78156: PUSH
78157: LD_INT 2
78159: ARRAY
78160: PPUSH
78161: LD_VAR 0 7
78165: PUSH
78166: LD_INT 3
78168: ARRAY
78169: PPUSH
78170: LD_INT 30
78172: PPUSH
78173: CALL 26367 0 4
78177: PUSH
78178: LD_INT 4
78180: ARRAY
78181: AND
78182: IFFALSE 78200
// ComStandNearbyBuilding ( j , depot ) else
78184: LD_VAR 0 3
78188: PPUSH
78189: LD_VAR 0 9
78193: PPUSH
78194: CALL 21639 0 2
78198: GO 78227
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
78200: LD_VAR 0 3
78204: PPUSH
78205: LD_VAR 0 7
78209: PUSH
78210: LD_INT 2
78212: ARRAY
78213: PPUSH
78214: LD_VAR 0 7
78218: PUSH
78219: LD_INT 3
78221: ARRAY
78222: PPUSH
78223: CALL_OW 117
// end ;
78227: GO 78003
78229: POP
78230: POP
// end ; end else
78231: GO 78773
// begin for j in cargo do
78233: LD_ADDR_VAR 0 3
78237: PUSH
78238: LD_VAR 0 8
78242: PUSH
78243: FOR_IN
78244: IFFALSE 78771
// begin if GetTag ( j ) <> 0 then
78246: LD_VAR 0 3
78250: PPUSH
78251: CALL_OW 110
78255: PUSH
78256: LD_INT 0
78258: NONEQUAL
78259: IFFALSE 78263
// continue ;
78261: GO 78243
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
78263: LD_VAR 0 3
78267: PPUSH
78268: CALL_OW 256
78272: PUSH
78273: LD_INT 1000
78275: LESS
78276: IFFALSE 78301
78278: PUSH
78279: LD_VAR 0 3
78283: PPUSH
78284: LD_EXP 55
78288: PUSH
78289: LD_VAR 0 2
78293: ARRAY
78294: PPUSH
78295: CALL_OW 308
78299: NOT
78300: AND
78301: IFFALSE 78323
// ComMoveToArea ( j , mc_parking [ i ] ) ;
78303: LD_VAR 0 3
78307: PPUSH
78308: LD_EXP 55
78312: PUSH
78313: LD_VAR 0 2
78317: ARRAY
78318: PPUSH
78319: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
78323: LD_VAR 0 3
78327: PPUSH
78328: CALL_OW 256
78332: PUSH
78333: LD_INT 1000
78335: LESS
78336: IFFALSE 78360
78338: PUSH
78339: LD_VAR 0 3
78343: PPUSH
78344: LD_EXP 55
78348: PUSH
78349: LD_VAR 0 2
78353: ARRAY
78354: PPUSH
78355: CALL_OW 308
78359: AND
78360: IFFALSE 78364
// continue ;
78362: GO 78243
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
78364: LD_VAR 0 3
78368: PPUSH
78369: CALL_OW 262
78373: PUSH
78374: LD_INT 2
78376: EQUAL
78377: IFFALSE 78394
78379: PUSH
78380: LD_VAR 0 3
78384: PPUSH
78385: CALL_OW 261
78389: PUSH
78390: LD_INT 15
78392: LESS
78393: AND
78394: IFFALSE 78398
// continue ;
78396: GO 78243
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
78398: LD_VAR 0 3
78402: PPUSH
78403: CALL_OW 262
78407: PUSH
78408: LD_INT 1
78410: EQUAL
78411: IFFALSE 78428
78413: PUSH
78414: LD_VAR 0 3
78418: PPUSH
78419: CALL_OW 261
78423: PUSH
78424: LD_INT 10
78426: LESS
78427: AND
78428: IFFALSE 78708
// begin if not depot then
78430: LD_VAR 0 9
78434: NOT
78435: IFFALSE 78439
// continue ;
78437: GO 78243
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
78439: LD_VAR 0 3
78443: PPUSH
78444: LD_VAR 0 9
78448: PPUSH
78449: LD_VAR 0 3
78453: PPUSH
78454: CALL_OW 74
78458: PPUSH
78459: CALL_OW 296
78463: PUSH
78464: LD_INT 6
78466: LESS
78467: IFFALSE 78483
// SetFuel ( j , 100 ) else
78469: LD_VAR 0 3
78473: PPUSH
78474: LD_INT 100
78476: PPUSH
78477: CALL_OW 240
78481: GO 78708
// if GetFuel ( j ) = 0 then
78483: LD_VAR 0 3
78487: PPUSH
78488: CALL_OW 261
78492: PUSH
78493: LD_INT 0
78495: EQUAL
78496: IFFALSE 78708
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
78498: LD_ADDR_EXP 50
78502: PUSH
78503: LD_EXP 50
78507: PPUSH
78508: LD_VAR 0 2
78512: PPUSH
78513: LD_EXP 50
78517: PUSH
78518: LD_VAR 0 2
78522: ARRAY
78523: PUSH
78524: LD_VAR 0 3
78528: DIFF
78529: PPUSH
78530: CALL_OW 1
78534: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
78535: LD_VAR 0 3
78539: PPUSH
78540: CALL_OW 263
78544: PUSH
78545: LD_INT 1
78547: EQUAL
78548: IFFALSE 78564
// ComExitVehicle ( IsInUnit ( j ) ) ;
78550: LD_VAR 0 3
78554: PPUSH
78555: CALL_OW 310
78559: PPUSH
78560: CALL_OW 121
// if GetControl ( j ) = control_remote then
78564: LD_VAR 0 3
78568: PPUSH
78569: CALL_OW 263
78573: PUSH
78574: LD_INT 2
78576: EQUAL
78577: IFFALSE 78588
// ComUnlink ( j ) ;
78579: LD_VAR 0 3
78583: PPUSH
78584: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
78588: LD_ADDR_VAR 0 10
78592: PUSH
78593: LD_VAR 0 2
78597: PPUSH
78598: LD_INT 3
78600: PPUSH
78601: CALL 88502 0 2
78605: ST_TO_ADDR
// if fac then
78606: LD_VAR 0 10
78610: IFFALSE 78706
// begin for k in fac do
78612: LD_ADDR_VAR 0 4
78616: PUSH
78617: LD_VAR 0 10
78621: PUSH
78622: FOR_IN
78623: IFFALSE 78704
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
78625: LD_ADDR_VAR 0 11
78629: PUSH
78630: LD_VAR 0 10
78634: PPUSH
78635: LD_VAR 0 3
78639: PPUSH
78640: CALL_OW 265
78644: PPUSH
78645: LD_VAR 0 3
78649: PPUSH
78650: CALL_OW 262
78654: PPUSH
78655: LD_VAR 0 3
78659: PPUSH
78660: CALL_OW 263
78664: PPUSH
78665: LD_VAR 0 3
78669: PPUSH
78670: CALL_OW 264
78674: PPUSH
78675: CALL 22537 0 5
78679: ST_TO_ADDR
// if components then
78680: LD_VAR 0 11
78684: IFFALSE 78702
// begin MC_InsertProduceList ( i , components ) ;
78686: LD_VAR 0 2
78690: PPUSH
78691: LD_VAR 0 11
78695: PPUSH
78696: CALL 88047 0 2
// break ;
78700: GO 78704
// end ; end ;
78702: GO 78622
78704: POP
78705: POP
// end ; continue ;
78706: GO 78243
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
78708: LD_VAR 0 3
78712: PPUSH
78713: LD_INT 1
78715: PPUSH
78716: CALL_OW 289
78720: PUSH
78721: LD_INT 100
78723: LESS
78724: IFFALSE 78738
78726: PUSH
78727: LD_VAR 0 3
78731: PPUSH
78732: CALL_OW 314
78736: NOT
78737: AND
78738: IFFALSE 78767
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
78740: LD_VAR 0 3
78744: PPUSH
78745: LD_VAR 0 7
78749: PUSH
78750: LD_INT 2
78752: ARRAY
78753: PPUSH
78754: LD_VAR 0 7
78758: PUSH
78759: LD_INT 3
78761: ARRAY
78762: PPUSH
78763: CALL_OW 117
// break ;
78767: GO 78771
// end ;
78769: GO 78243
78771: POP
78772: POP
// end ; end ;
78773: GO 76945
78775: POP
78776: POP
// end ;
78777: LD_VAR 0 1
78781: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
78782: LD_INT 0
78784: PPUSH
78785: PPUSH
78786: PPUSH
78787: PPUSH
// if not mc_bases then
78788: LD_EXP 31
78792: NOT
78793: IFFALSE 78797
// exit ;
78795: GO 78962
// for i = 1 to mc_bases do
78797: LD_ADDR_VAR 0 2
78801: PUSH
78802: DOUBLE
78803: LD_INT 1
78805: DEC
78806: ST_TO_ADDR
78807: LD_EXP 31
78811: PUSH
78812: FOR_TO
78813: IFFALSE 78960
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
78815: LD_ADDR_VAR 0 4
78819: PUSH
78820: LD_EXP 50
78824: PUSH
78825: LD_VAR 0 2
78829: ARRAY
78830: PUSH
78831: LD_EXP 53
78835: PUSH
78836: LD_VAR 0 2
78840: ARRAY
78841: UNION
78842: PPUSH
78843: LD_INT 33
78845: PUSH
78846: LD_INT 2
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PPUSH
78853: CALL_OW 72
78857: ST_TO_ADDR
// if tmp then
78858: LD_VAR 0 4
78862: IFFALSE 78958
// for j in tmp do
78864: LD_ADDR_VAR 0 3
78868: PUSH
78869: LD_VAR 0 4
78873: PUSH
78874: FOR_IN
78875: IFFALSE 78956
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
78877: LD_VAR 0 3
78881: PPUSH
78882: CALL_OW 312
78886: NOT
78887: IFFALSE 78904
78889: PUSH
78890: LD_VAR 0 3
78894: PPUSH
78895: CALL_OW 256
78899: PUSH
78900: LD_INT 250
78902: GREATEREQUAL
78903: AND
78904: IFFALSE 78917
// Connect ( j ) else
78906: LD_VAR 0 3
78910: PPUSH
78911: CALL 28457 0 1
78915: GO 78954
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
78917: LD_VAR 0 3
78921: PPUSH
78922: CALL_OW 256
78926: PUSH
78927: LD_INT 250
78929: LESS
78930: IFFALSE 78943
78932: PUSH
78933: LD_VAR 0 3
78937: PPUSH
78938: CALL_OW 312
78942: AND
78943: IFFALSE 78954
// ComUnlink ( j ) ;
78945: LD_VAR 0 3
78949: PPUSH
78950: CALL_OW 136
78954: GO 78874
78956: POP
78957: POP
// end ;
78958: GO 78812
78960: POP
78961: POP
// end ;
78962: LD_VAR 0 1
78966: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
78967: LD_INT 0
78969: PPUSH
78970: PPUSH
78971: PPUSH
78972: PPUSH
78973: PPUSH
// if not mc_bases then
78974: LD_EXP 31
78978: NOT
78979: IFFALSE 78983
// exit ;
78981: GO 79432
// for i = 1 to mc_bases do
78983: LD_ADDR_VAR 0 2
78987: PUSH
78988: DOUBLE
78989: LD_INT 1
78991: DEC
78992: ST_TO_ADDR
78993: LD_EXP 31
78997: PUSH
78998: FOR_TO
78999: IFFALSE 79430
// begin if not mc_produce [ i ] then
79001: LD_EXP 52
79005: PUSH
79006: LD_VAR 0 2
79010: ARRAY
79011: NOT
79012: IFFALSE 79016
// continue ;
79014: GO 78998
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79016: LD_ADDR_VAR 0 5
79020: PUSH
79021: LD_EXP 31
79025: PUSH
79026: LD_VAR 0 2
79030: ARRAY
79031: PPUSH
79032: LD_INT 30
79034: PUSH
79035: LD_INT 3
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PPUSH
79042: CALL_OW 72
79046: ST_TO_ADDR
// if not fac then
79047: LD_VAR 0 5
79051: NOT
79052: IFFALSE 79056
// continue ;
79054: GO 78998
// for j in fac do
79056: LD_ADDR_VAR 0 3
79060: PUSH
79061: LD_VAR 0 5
79065: PUSH
79066: FOR_IN
79067: IFFALSE 79426
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
79069: LD_VAR 0 3
79073: PPUSH
79074: CALL_OW 461
79078: PUSH
79079: LD_INT 2
79081: NONEQUAL
79082: IFTRUE 79102
79084: PUSH
79085: LD_VAR 0 3
79089: PPUSH
79090: LD_INT 15
79092: PPUSH
79093: CALL 28076 0 2
79097: PUSH
79098: LD_INT 4
79100: ARRAY
79101: OR
79102: IFFALSE 79106
// continue ;
79104: GO 79066
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
79106: LD_VAR 0 3
79110: PPUSH
79111: LD_EXP 52
79115: PUSH
79116: LD_VAR 0 2
79120: ARRAY
79121: PUSH
79122: LD_INT 1
79124: ARRAY
79125: PUSH
79126: LD_INT 1
79128: ARRAY
79129: PPUSH
79130: LD_EXP 52
79134: PUSH
79135: LD_VAR 0 2
79139: ARRAY
79140: PUSH
79141: LD_INT 1
79143: ARRAY
79144: PUSH
79145: LD_INT 2
79147: ARRAY
79148: PPUSH
79149: LD_EXP 52
79153: PUSH
79154: LD_VAR 0 2
79158: ARRAY
79159: PUSH
79160: LD_INT 1
79162: ARRAY
79163: PUSH
79164: LD_INT 3
79166: ARRAY
79167: PPUSH
79168: LD_EXP 52
79172: PUSH
79173: LD_VAR 0 2
79177: ARRAY
79178: PUSH
79179: LD_INT 1
79181: ARRAY
79182: PUSH
79183: LD_INT 4
79185: ARRAY
79186: PPUSH
79187: CALL_OW 448
79191: IFFALSE 79286
79193: PUSH
79194: LD_VAR 0 3
79198: PPUSH
79199: LD_EXP 52
79203: PUSH
79204: LD_VAR 0 2
79208: ARRAY
79209: PUSH
79210: LD_INT 1
79212: ARRAY
79213: PUSH
79214: LD_INT 1
79216: ARRAY
79217: PUSH
79218: LD_EXP 52
79222: PUSH
79223: LD_VAR 0 2
79227: ARRAY
79228: PUSH
79229: LD_INT 1
79231: ARRAY
79232: PUSH
79233: LD_INT 2
79235: ARRAY
79236: PUSH
79237: LD_EXP 52
79241: PUSH
79242: LD_VAR 0 2
79246: ARRAY
79247: PUSH
79248: LD_INT 1
79250: ARRAY
79251: PUSH
79252: LD_INT 3
79254: ARRAY
79255: PUSH
79256: LD_EXP 52
79260: PUSH
79261: LD_VAR 0 2
79265: ARRAY
79266: PUSH
79267: LD_INT 1
79269: ARRAY
79270: PUSH
79271: LD_INT 4
79273: ARRAY
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: LIST
79279: LIST
79280: PPUSH
79281: CALL 31890 0 2
79285: AND
79286: IFFALSE 79424
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
79288: LD_VAR 0 3
79292: PPUSH
79293: LD_EXP 52
79297: PUSH
79298: LD_VAR 0 2
79302: ARRAY
79303: PUSH
79304: LD_INT 1
79306: ARRAY
79307: PUSH
79308: LD_INT 1
79310: ARRAY
79311: PPUSH
79312: LD_EXP 52
79316: PUSH
79317: LD_VAR 0 2
79321: ARRAY
79322: PUSH
79323: LD_INT 1
79325: ARRAY
79326: PUSH
79327: LD_INT 2
79329: ARRAY
79330: PPUSH
79331: LD_EXP 52
79335: PUSH
79336: LD_VAR 0 2
79340: ARRAY
79341: PUSH
79342: LD_INT 1
79344: ARRAY
79345: PUSH
79346: LD_INT 3
79348: ARRAY
79349: PPUSH
79350: LD_EXP 52
79354: PUSH
79355: LD_VAR 0 2
79359: ARRAY
79360: PUSH
79361: LD_INT 1
79363: ARRAY
79364: PUSH
79365: LD_INT 4
79367: ARRAY
79368: PPUSH
79369: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
79373: LD_ADDR_VAR 0 4
79377: PUSH
79378: LD_EXP 52
79382: PUSH
79383: LD_VAR 0 2
79387: ARRAY
79388: PPUSH
79389: LD_INT 1
79391: PPUSH
79392: CALL_OW 3
79396: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79397: LD_ADDR_EXP 52
79401: PUSH
79402: LD_EXP 52
79406: PPUSH
79407: LD_VAR 0 2
79411: PPUSH
79412: LD_VAR 0 4
79416: PPUSH
79417: CALL_OW 1
79421: ST_TO_ADDR
// break ;
79422: GO 79426
// end ; end ;
79424: GO 79066
79426: POP
79427: POP
// end ;
79428: GO 78998
79430: POP
79431: POP
// end ;
79432: LD_VAR 0 1
79436: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
79437: LD_INT 0
79439: PPUSH
79440: PPUSH
79441: PPUSH
// if not mc_bases then
79442: LD_EXP 31
79446: NOT
79447: IFFALSE 79451
// exit ;
79449: GO 79540
// for i = 1 to mc_bases do
79451: LD_ADDR_VAR 0 2
79455: PUSH
79456: DOUBLE
79457: LD_INT 1
79459: DEC
79460: ST_TO_ADDR
79461: LD_EXP 31
79465: PUSH
79466: FOR_TO
79467: IFFALSE 79538
// begin if mc_attack [ i ] then
79469: LD_EXP 51
79473: PUSH
79474: LD_VAR 0 2
79478: ARRAY
79479: IFFALSE 79536
// begin tmp := mc_attack [ i ] [ 1 ] ;
79481: LD_ADDR_VAR 0 3
79485: PUSH
79486: LD_EXP 51
79490: PUSH
79491: LD_VAR 0 2
79495: ARRAY
79496: PUSH
79497: LD_INT 1
79499: ARRAY
79500: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
79501: LD_ADDR_EXP 51
79505: PUSH
79506: LD_EXP 51
79510: PPUSH
79511: LD_VAR 0 2
79515: PPUSH
79516: EMPTY
79517: PPUSH
79518: CALL_OW 1
79522: ST_TO_ADDR
// Attack ( tmp ) ;
79523: LD_VAR 0 3
79527: PPUSH
79528: CALL 117131 0 1
// exit ;
79532: POP
79533: POP
79534: GO 79540
// end ; end ;
79536: GO 79466
79538: POP
79539: POP
// end ;
79540: LD_VAR 0 1
79544: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
79545: LD_INT 0
79547: PPUSH
79548: PPUSH
79549: PPUSH
79550: PPUSH
79551: PPUSH
79552: PPUSH
79553: PPUSH
// if not mc_bases then
79554: LD_EXP 31
79558: NOT
79559: IFFALSE 79563
// exit ;
79561: GO 80440
// for i = 1 to mc_bases do
79563: LD_ADDR_VAR 0 2
79567: PUSH
79568: DOUBLE
79569: LD_INT 1
79571: DEC
79572: ST_TO_ADDR
79573: LD_EXP 31
79577: PUSH
79578: FOR_TO
79579: IFFALSE 80438
// begin if not mc_bases [ i ] then
79581: LD_EXP 31
79585: PUSH
79586: LD_VAR 0 2
79590: ARRAY
79591: NOT
79592: IFFALSE 79596
// continue ;
79594: GO 79578
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
79596: LD_ADDR_VAR 0 7
79600: PUSH
79601: LD_EXP 31
79605: PUSH
79606: LD_VAR 0 2
79610: ARRAY
79611: PUSH
79612: LD_INT 1
79614: ARRAY
79615: PPUSH
79616: CALL 21863 0 1
79620: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
79621: LD_ADDR_EXP 54
79625: PUSH
79626: LD_EXP 54
79630: PPUSH
79631: LD_VAR 0 2
79635: PPUSH
79636: LD_EXP 31
79640: PUSH
79641: LD_VAR 0 2
79645: ARRAY
79646: PUSH
79647: LD_INT 1
79649: ARRAY
79650: PPUSH
79651: CALL_OW 255
79655: PPUSH
79656: LD_EXP 56
79660: PUSH
79661: LD_VAR 0 2
79665: ARRAY
79666: PPUSH
79667: CALL 21828 0 2
79671: PPUSH
79672: CALL_OW 1
79676: ST_TO_ADDR
// if not mc_scan [ i ] then
79677: LD_EXP 54
79681: PUSH
79682: LD_VAR 0 2
79686: ARRAY
79687: NOT
79688: IFFALSE 79872
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
79690: LD_ADDR_EXP 74
79694: PUSH
79695: LD_EXP 74
79699: PPUSH
79700: LD_VAR 0 2
79704: PPUSH
79705: LD_INT 0
79707: PPUSH
79708: CALL_OW 1
79712: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79713: LD_ADDR_VAR 0 4
79717: PUSH
79718: LD_EXP 31
79722: PUSH
79723: LD_VAR 0 2
79727: ARRAY
79728: PPUSH
79729: LD_INT 2
79731: PUSH
79732: LD_INT 25
79734: PUSH
79735: LD_INT 5
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 25
79744: PUSH
79745: LD_INT 8
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 25
79754: PUSH
79755: LD_INT 9
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: PPUSH
79768: CALL_OW 72
79772: ST_TO_ADDR
// if not tmp then
79773: LD_VAR 0 4
79777: NOT
79778: IFFALSE 79782
// continue ;
79780: GO 79578
// for j in tmp do
79782: LD_ADDR_VAR 0 3
79786: PUSH
79787: LD_VAR 0 4
79791: PUSH
79792: FOR_IN
79793: IFFALSE 79870
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
79795: LD_VAR 0 3
79799: PPUSH
79800: CALL_OW 310
79804: PPUSH
79805: CALL_OW 266
79809: PUSH
79810: LD_INT 5
79812: EQUAL
79813: IFFALSE 79830
79815: PUSH
79816: LD_VAR 0 3
79820: PPUSH
79821: CALL_OW 257
79825: PUSH
79826: LD_INT 1
79828: EQUAL
79829: AND
79830: IFFALSE 79844
79832: PUSH
79833: LD_VAR 0 3
79837: PPUSH
79838: CALL_OW 459
79842: NOT
79843: AND
79844: IFFALSE 79852
79846: PUSH
79847: LD_VAR 0 7
79851: AND
79852: IFFALSE 79868
// ComChangeProfession ( j , class ) ;
79854: LD_VAR 0 3
79858: PPUSH
79859: LD_VAR 0 7
79863: PPUSH
79864: CALL_OW 123
79868: GO 79792
79870: POP
79871: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
79872: LD_EXP 54
79876: PUSH
79877: LD_VAR 0 2
79881: ARRAY
79882: IFFALSE 79897
79884: PUSH
79885: LD_EXP 74
79889: PUSH
79890: LD_VAR 0 2
79894: ARRAY
79895: NOT
79896: AND
79897: IFFALSE 79912
79899: PUSH
79900: LD_EXP 53
79904: PUSH
79905: LD_VAR 0 2
79909: ARRAY
79910: NOT
79911: AND
79912: IFFALSE 80063
79914: PUSH
79915: LD_EXP 31
79919: PUSH
79920: LD_VAR 0 2
79924: ARRAY
79925: PPUSH
79926: LD_INT 50
79928: PUSH
79929: EMPTY
79930: LIST
79931: PUSH
79932: LD_INT 2
79934: PUSH
79935: LD_INT 30
79937: PUSH
79938: LD_INT 32
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 30
79947: PUSH
79948: LD_INT 33
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 30
79957: PUSH
79958: LD_INT 4
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 30
79967: PUSH
79968: LD_INT 5
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PPUSH
79986: CALL_OW 72
79990: PUSH
79991: LD_INT 4
79993: LESS
79994: IFTRUE 80062
79996: PUSH
79997: LD_EXP 31
80001: PUSH
80002: LD_VAR 0 2
80006: ARRAY
80007: PPUSH
80008: LD_INT 3
80010: PUSH
80011: LD_INT 24
80013: PUSH
80014: LD_INT 1000
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 2
80027: PUSH
80028: LD_INT 30
80030: PUSH
80031: LD_INT 0
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 30
80040: PUSH
80041: LD_INT 1
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: LIST
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PPUSH
80057: CALL_OW 72
80061: OR
80062: AND
80063: IFFALSE 80316
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
80065: LD_ADDR_EXP 74
80069: PUSH
80070: LD_EXP 74
80074: PPUSH
80075: LD_VAR 0 2
80079: PPUSH
80080: LD_INT 1
80082: PPUSH
80083: CALL_OW 1
80087: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
80088: LD_ADDR_VAR 0 4
80092: PUSH
80093: LD_EXP 31
80097: PUSH
80098: LD_VAR 0 2
80102: ARRAY
80103: PPUSH
80104: LD_INT 2
80106: PUSH
80107: LD_INT 25
80109: PUSH
80110: LD_INT 1
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: PUSH
80117: LD_INT 25
80119: PUSH
80120: LD_INT 5
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 25
80129: PUSH
80130: LD_INT 8
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 25
80139: PUSH
80140: LD_INT 9
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: PPUSH
80154: CALL_OW 72
80158: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
80159: LD_ADDR_VAR 0 4
80163: PUSH
80164: LD_VAR 0 4
80168: PUSH
80169: LD_VAR 0 4
80173: PPUSH
80174: LD_INT 18
80176: PPUSH
80177: CALL 55700 0 2
80181: DIFF
80182: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
80183: LD_VAR 0 4
80187: NOT
80188: IFFALSE 80236
80190: PUSH
80191: LD_EXP 31
80195: PUSH
80196: LD_VAR 0 2
80200: ARRAY
80201: PPUSH
80202: LD_INT 2
80204: PUSH
80205: LD_INT 30
80207: PUSH
80208: LD_INT 4
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 30
80217: PUSH
80218: LD_INT 5
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: LIST
80229: PPUSH
80230: CALL_OW 72
80234: NOT
80235: AND
80236: IFFALSE 80298
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
80238: LD_ADDR_VAR 0 4
80242: PUSH
80243: LD_EXP 31
80247: PUSH
80248: LD_VAR 0 2
80252: ARRAY
80253: PPUSH
80254: LD_INT 2
80256: PUSH
80257: LD_INT 25
80259: PUSH
80260: LD_INT 2
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 25
80269: PUSH
80270: LD_INT 3
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 25
80279: PUSH
80280: LD_INT 4
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: PPUSH
80293: CALL_OW 72
80297: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
80298: LD_VAR 0 2
80302: PPUSH
80303: LD_VAR 0 4
80307: PPUSH
80308: CALL 121900 0 2
// exit ;
80312: POP
80313: POP
80314: GO 80440
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
80316: LD_EXP 54
80320: PUSH
80321: LD_VAR 0 2
80325: ARRAY
80326: IFFALSE 80341
80328: PUSH
80329: LD_EXP 74
80333: PUSH
80334: LD_VAR 0 2
80338: ARRAY
80339: NOT
80340: AND
80341: IFFALSE 80355
80343: PUSH
80344: LD_EXP 53
80348: PUSH
80349: LD_VAR 0 2
80353: ARRAY
80354: AND
80355: IFFALSE 80436
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
80357: LD_ADDR_EXP 74
80361: PUSH
80362: LD_EXP 74
80366: PPUSH
80367: LD_VAR 0 2
80371: PPUSH
80372: LD_INT 1
80374: PPUSH
80375: CALL_OW 1
80379: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
80380: LD_ADDR_VAR 0 4
80384: PUSH
80385: LD_EXP 53
80389: PUSH
80390: LD_VAR 0 2
80394: ARRAY
80395: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
80396: LD_ADDR_EXP 53
80400: PUSH
80401: LD_EXP 53
80405: PPUSH
80406: LD_VAR 0 2
80410: PPUSH
80411: EMPTY
80412: PPUSH
80413: CALL_OW 1
80417: ST_TO_ADDR
// Defend ( i , tmp ) ;
80418: LD_VAR 0 2
80422: PPUSH
80423: LD_VAR 0 4
80427: PPUSH
80428: CALL 122504 0 2
// exit ;
80432: POP
80433: POP
80434: GO 80440
// end ; end ;
80436: GO 79578
80438: POP
80439: POP
// end ;
80440: LD_VAR 0 1
80444: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
80445: LD_INT 0
80447: PPUSH
80448: PPUSH
80449: PPUSH
80450: PPUSH
80451: PPUSH
80452: PPUSH
80453: PPUSH
80454: PPUSH
80455: PPUSH
80456: PPUSH
80457: PPUSH
// if not mc_bases then
80458: LD_EXP 31
80462: NOT
80463: IFFALSE 80467
// exit ;
80465: GO 81580
// for i = 1 to mc_bases do
80467: LD_ADDR_VAR 0 2
80471: PUSH
80472: DOUBLE
80473: LD_INT 1
80475: DEC
80476: ST_TO_ADDR
80477: LD_EXP 31
80481: PUSH
80482: FOR_TO
80483: IFFALSE 81578
// begin tmp := mc_lab [ i ] ;
80485: LD_ADDR_VAR 0 6
80489: PUSH
80490: LD_EXP 64
80494: PUSH
80495: LD_VAR 0 2
80499: ARRAY
80500: ST_TO_ADDR
// if not tmp then
80501: LD_VAR 0 6
80505: NOT
80506: IFFALSE 80510
// continue ;
80508: GO 80482
// idle_lab := 0 ;
80510: LD_ADDR_VAR 0 11
80514: PUSH
80515: LD_INT 0
80517: ST_TO_ADDR
// for j in tmp do
80518: LD_ADDR_VAR 0 3
80522: PUSH
80523: LD_VAR 0 6
80527: PUSH
80528: FOR_IN
80529: IFFALSE 81574
// begin researching := false ;
80531: LD_ADDR_VAR 0 10
80535: PUSH
80536: LD_INT 0
80538: ST_TO_ADDR
// side := GetSide ( j ) ;
80539: LD_ADDR_VAR 0 4
80543: PUSH
80544: LD_VAR 0 3
80548: PPUSH
80549: CALL_OW 255
80553: ST_TO_ADDR
// if not mc_tech [ side ] then
80554: LD_EXP 58
80558: PUSH
80559: LD_VAR 0 4
80563: ARRAY
80564: NOT
80565: IFFALSE 80569
// continue ;
80567: GO 80528
// if BuildingStatus ( j ) = bs_idle then
80569: LD_VAR 0 3
80573: PPUSH
80574: CALL_OW 461
80578: PUSH
80579: LD_INT 2
80581: EQUAL
80582: IFFALSE 80774
// begin if idle_lab and UnitsInside ( j ) < 6 then
80584: LD_VAR 0 11
80588: IFFALSE 80605
80590: PUSH
80591: LD_VAR 0 3
80595: PPUSH
80596: CALL_OW 313
80600: PUSH
80601: LD_INT 6
80603: LESS
80604: AND
80605: IFFALSE 80676
// begin tmp2 := UnitsInside ( idle_lab ) ;
80607: LD_ADDR_VAR 0 9
80611: PUSH
80612: LD_VAR 0 11
80616: PPUSH
80617: CALL_OW 313
80621: ST_TO_ADDR
// if tmp2 then
80622: LD_VAR 0 9
80626: IFFALSE 80668
// for x in tmp2 do
80628: LD_ADDR_VAR 0 7
80632: PUSH
80633: LD_VAR 0 9
80637: PUSH
80638: FOR_IN
80639: IFFALSE 80666
// begin ComExitBuilding ( x ) ;
80641: LD_VAR 0 7
80645: PPUSH
80646: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
80650: LD_VAR 0 7
80654: PPUSH
80655: LD_VAR 0 3
80659: PPUSH
80660: CALL_OW 180
// end ;
80664: GO 80638
80666: POP
80667: POP
// idle_lab := 0 ;
80668: LD_ADDR_VAR 0 11
80672: PUSH
80673: LD_INT 0
80675: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
80676: LD_ADDR_VAR 0 5
80680: PUSH
80681: LD_EXP 58
80685: PUSH
80686: LD_VAR 0 4
80690: ARRAY
80691: PUSH
80692: FOR_IN
80693: IFFALSE 80755
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
80695: LD_VAR 0 3
80699: PPUSH
80700: LD_VAR 0 5
80704: PPUSH
80705: CALL_OW 430
80709: IFFALSE 80727
80711: PUSH
80712: LD_VAR 0 4
80716: PPUSH
80717: LD_VAR 0 5
80721: PPUSH
80722: CALL 20923 0 2
80726: AND
80727: IFFALSE 80753
// begin researching := true ;
80729: LD_ADDR_VAR 0 10
80733: PUSH
80734: LD_INT 1
80736: ST_TO_ADDR
// ComResearch ( j , t ) ;
80737: LD_VAR 0 3
80741: PPUSH
80742: LD_VAR 0 5
80746: PPUSH
80747: CALL_OW 124
// break ;
80751: GO 80755
// end ;
80753: GO 80692
80755: POP
80756: POP
// if not researching then
80757: LD_VAR 0 10
80761: NOT
80762: IFFALSE 80774
// idle_lab := j ;
80764: LD_ADDR_VAR 0 11
80768: PUSH
80769: LD_VAR 0 3
80773: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
80774: LD_VAR 0 3
80778: PPUSH
80779: CALL_OW 461
80783: PUSH
80784: LD_INT 10
80786: EQUAL
80787: IFFALSE 81393
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
80789: LD_EXP 60
80793: PUSH
80794: LD_VAR 0 2
80798: ARRAY
80799: NOT
80800: IFFALSE 80815
80802: PUSH
80803: LD_EXP 61
80807: PUSH
80808: LD_VAR 0 2
80812: ARRAY
80813: NOT
80814: AND
80815: IFFALSE 80833
80817: PUSH
80818: LD_EXP 58
80822: PUSH
80823: LD_VAR 0 4
80827: ARRAY
80828: PUSH
80829: LD_INT 1
80831: GREATER
80832: AND
80833: IFFALSE 80964
// begin ComCancel ( j ) ;
80835: LD_VAR 0 3
80839: PPUSH
80840: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
80844: LD_ADDR_EXP 58
80848: PUSH
80849: LD_EXP 58
80853: PPUSH
80854: LD_VAR 0 4
80858: PPUSH
80859: LD_EXP 58
80863: PUSH
80864: LD_VAR 0 4
80868: ARRAY
80869: PPUSH
80870: LD_EXP 58
80874: PUSH
80875: LD_VAR 0 4
80879: ARRAY
80880: PUSH
80881: LD_INT 1
80883: MINUS
80884: PPUSH
80885: LD_EXP 58
80889: PUSH
80890: LD_VAR 0 4
80894: ARRAY
80895: PPUSH
80896: LD_INT 0
80898: PPUSH
80899: CALL 24505 0 4
80903: PPUSH
80904: CALL_OW 1
80908: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
80909: LD_ADDR_EXP 58
80913: PUSH
80914: LD_EXP 58
80918: PPUSH
80919: LD_VAR 0 4
80923: PPUSH
80924: LD_EXP 58
80928: PUSH
80929: LD_VAR 0 4
80933: ARRAY
80934: PPUSH
80935: LD_EXP 58
80939: PUSH
80940: LD_VAR 0 4
80944: ARRAY
80945: PPUSH
80946: LD_INT 1
80948: PPUSH
80949: LD_INT 0
80951: PPUSH
80952: CALL 24505 0 4
80956: PPUSH
80957: CALL_OW 1
80961: ST_TO_ADDR
// continue ;
80962: GO 80528
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
80964: LD_EXP 60
80968: PUSH
80969: LD_VAR 0 2
80973: ARRAY
80974: IFFALSE 80989
80976: PUSH
80977: LD_EXP 61
80981: PUSH
80982: LD_VAR 0 2
80986: ARRAY
80987: NOT
80988: AND
80989: IFFALSE 81116
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
80991: LD_ADDR_EXP 61
80995: PUSH
80996: LD_EXP 61
81000: PPUSH
81001: LD_VAR 0 2
81005: PUSH
81006: LD_EXP 61
81010: PUSH
81011: LD_VAR 0 2
81015: ARRAY
81016: PUSH
81017: LD_INT 1
81019: PLUS
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PPUSH
81025: LD_EXP 60
81029: PUSH
81030: LD_VAR 0 2
81034: ARRAY
81035: PUSH
81036: LD_INT 1
81038: ARRAY
81039: PPUSH
81040: CALL 25097 0 3
81044: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
81045: LD_EXP 60
81049: PUSH
81050: LD_VAR 0 2
81054: ARRAY
81055: PUSH
81056: LD_INT 1
81058: ARRAY
81059: PPUSH
81060: LD_INT 112
81062: PPUSH
81063: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
81067: LD_ADDR_VAR 0 9
81071: PUSH
81072: LD_EXP 60
81076: PUSH
81077: LD_VAR 0 2
81081: ARRAY
81082: PPUSH
81083: LD_INT 1
81085: PPUSH
81086: CALL_OW 3
81090: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
81091: LD_ADDR_EXP 60
81095: PUSH
81096: LD_EXP 60
81100: PPUSH
81101: LD_VAR 0 2
81105: PPUSH
81106: LD_VAR 0 9
81110: PPUSH
81111: CALL_OW 1
81115: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
81116: LD_EXP 60
81120: PUSH
81121: LD_VAR 0 2
81125: ARRAY
81126: IFFALSE 81140
81128: PUSH
81129: LD_EXP 61
81133: PUSH
81134: LD_VAR 0 2
81138: ARRAY
81139: AND
81140: IFFALSE 81164
81142: PUSH
81143: LD_EXP 61
81147: PUSH
81148: LD_VAR 0 2
81152: ARRAY
81153: PUSH
81154: LD_INT 1
81156: ARRAY
81157: PPUSH
81158: CALL_OW 310
81162: NOT
81163: AND
81164: IFFALSE 81181
81166: PUSH
81167: LD_VAR 0 3
81171: PPUSH
81172: CALL_OW 313
81176: PUSH
81177: LD_INT 6
81179: EQUAL
81180: AND
81181: IFFALSE 81237
// begin tmp2 := UnitsInside ( j ) ;
81183: LD_ADDR_VAR 0 9
81187: PUSH
81188: LD_VAR 0 3
81192: PPUSH
81193: CALL_OW 313
81197: ST_TO_ADDR
// if tmp2 = 6 then
81198: LD_VAR 0 9
81202: PUSH
81203: LD_INT 6
81205: EQUAL
81206: IFFALSE 81237
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
81208: LD_VAR 0 9
81212: PUSH
81213: LD_INT 1
81215: ARRAY
81216: PPUSH
81217: LD_INT 112
81219: PPUSH
81220: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
81224: LD_VAR 0 9
81228: PUSH
81229: LD_INT 1
81231: ARRAY
81232: PPUSH
81233: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
81237: LD_EXP 61
81241: PUSH
81242: LD_VAR 0 2
81246: ARRAY
81247: IFFALSE 81271
81249: PUSH
81250: LD_EXP 61
81254: PUSH
81255: LD_VAR 0 2
81259: ARRAY
81260: PUSH
81261: LD_INT 1
81263: ARRAY
81264: PPUSH
81265: CALL_OW 314
81269: NOT
81270: AND
81271: IFFALSE 81295
81273: PUSH
81274: LD_EXP 61
81278: PUSH
81279: LD_VAR 0 2
81283: ARRAY
81284: PUSH
81285: LD_INT 1
81287: ARRAY
81288: PPUSH
81289: CALL_OW 310
81293: NOT
81294: AND
81295: IFFALSE 81321
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
81297: LD_EXP 61
81301: PUSH
81302: LD_VAR 0 2
81306: ARRAY
81307: PUSH
81308: LD_INT 1
81310: ARRAY
81311: PPUSH
81312: LD_VAR 0 3
81316: PPUSH
81317: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
81321: LD_EXP 61
81325: PUSH
81326: LD_VAR 0 2
81330: ARRAY
81331: PUSH
81332: LD_INT 1
81334: ARRAY
81335: PPUSH
81336: CALL_OW 310
81340: IFFALSE 81372
81342: PUSH
81343: LD_EXP 61
81347: PUSH
81348: LD_VAR 0 2
81352: ARRAY
81353: PUSH
81354: LD_INT 1
81356: ARRAY
81357: PPUSH
81358: CALL_OW 310
81362: PPUSH
81363: CALL_OW 461
81367: PUSH
81368: LD_INT 3
81370: NONEQUAL
81371: AND
81372: IFFALSE 81393
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
81374: LD_EXP 61
81378: PUSH
81379: LD_VAR 0 2
81383: ARRAY
81384: PUSH
81385: LD_INT 1
81387: ARRAY
81388: PPUSH
81389: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
81393: LD_VAR 0 3
81397: PPUSH
81398: CALL_OW 461
81402: PUSH
81403: LD_INT 6
81405: EQUAL
81406: IFFALSE 81418
81408: PUSH
81409: LD_VAR 0 6
81413: PUSH
81414: LD_INT 1
81416: GREATER
81417: AND
81418: IFFALSE 81572
// begin sci := [ ] ;
81420: LD_ADDR_VAR 0 8
81424: PUSH
81425: EMPTY
81426: ST_TO_ADDR
// for x in ( tmp diff j ) do
81427: LD_ADDR_VAR 0 7
81431: PUSH
81432: LD_VAR 0 6
81436: PUSH
81437: LD_VAR 0 3
81441: DIFF
81442: PUSH
81443: FOR_IN
81444: IFFALSE 81496
// begin if sci = 6 then
81446: LD_VAR 0 8
81450: PUSH
81451: LD_INT 6
81453: EQUAL
81454: IFFALSE 81458
// break ;
81456: GO 81496
// if BuildingStatus ( x ) = bs_idle then
81458: LD_VAR 0 7
81462: PPUSH
81463: CALL_OW 461
81467: PUSH
81468: LD_INT 2
81470: EQUAL
81471: IFFALSE 81494
// sci := sci ^ UnitsInside ( x ) ;
81473: LD_ADDR_VAR 0 8
81477: PUSH
81478: LD_VAR 0 8
81482: PUSH
81483: LD_VAR 0 7
81487: PPUSH
81488: CALL_OW 313
81492: ADD
81493: ST_TO_ADDR
// end ;
81494: GO 81443
81496: POP
81497: POP
// if not sci then
81498: LD_VAR 0 8
81502: NOT
81503: IFFALSE 81507
// continue ;
81505: GO 80528
// for x in sci do
81507: LD_ADDR_VAR 0 7
81511: PUSH
81512: LD_VAR 0 8
81516: PUSH
81517: FOR_IN
81518: IFFALSE 81570
// if IsInUnit ( x ) and not HasTask ( x ) then
81520: LD_VAR 0 7
81524: PPUSH
81525: CALL_OW 310
81529: IFFALSE 81543
81531: PUSH
81532: LD_VAR 0 7
81536: PPUSH
81537: CALL_OW 314
81541: NOT
81542: AND
81543: IFFALSE 81568
// begin ComExitBuilding ( x ) ;
81545: LD_VAR 0 7
81549: PPUSH
81550: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
81554: LD_VAR 0 7
81558: PPUSH
81559: LD_VAR 0 3
81563: PPUSH
81564: CALL_OW 180
// end ;
81568: GO 81517
81570: POP
81571: POP
// end ; end ;
81572: GO 80528
81574: POP
81575: POP
// end ;
81576: GO 80482
81578: POP
81579: POP
// end ;
81580: LD_VAR 0 1
81584: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
81585: LD_INT 0
81587: PPUSH
81588: PPUSH
// if not mc_bases then
81589: LD_EXP 31
81593: NOT
81594: IFFALSE 81598
// exit ;
81596: GO 81681
// for i = 1 to mc_bases do
81598: LD_ADDR_VAR 0 2
81602: PUSH
81603: DOUBLE
81604: LD_INT 1
81606: DEC
81607: ST_TO_ADDR
81608: LD_EXP 31
81612: PUSH
81613: FOR_TO
81614: IFFALSE 81679
// if mc_mines [ i ] and mc_miners [ i ] then
81616: LD_EXP 44
81620: PUSH
81621: LD_VAR 0 2
81625: ARRAY
81626: IFFALSE 81640
81628: PUSH
81629: LD_EXP 45
81633: PUSH
81634: LD_VAR 0 2
81638: ARRAY
81639: AND
81640: IFFALSE 81677
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
81642: LD_EXP 45
81646: PUSH
81647: LD_VAR 0 2
81651: ARRAY
81652: PUSH
81653: LD_INT 1
81655: ARRAY
81656: PPUSH
81657: CALL_OW 255
81661: PPUSH
81662: LD_EXP 44
81666: PUSH
81667: LD_VAR 0 2
81671: ARRAY
81672: PPUSH
81673: CALL 22016 0 2
81677: GO 81613
81679: POP
81680: POP
// end ;
81681: LD_VAR 0 1
81685: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
81686: LD_INT 0
81688: PPUSH
81689: PPUSH
81690: PPUSH
81691: PPUSH
81692: PPUSH
81693: PPUSH
81694: PPUSH
81695: PPUSH
// if not mc_bases or not mc_parking then
81696: LD_EXP 31
81700: NOT
81701: IFTRUE 81710
81703: PUSH
81704: LD_EXP 55
81708: NOT
81709: OR
81710: IFFALSE 81714
// exit ;
81712: GO 82458
// for i = 1 to mc_bases do
81714: LD_ADDR_VAR 0 2
81718: PUSH
81719: DOUBLE
81720: LD_INT 1
81722: DEC
81723: ST_TO_ADDR
81724: LD_EXP 31
81728: PUSH
81729: FOR_TO
81730: IFFALSE 82456
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
81732: LD_EXP 31
81736: PUSH
81737: LD_VAR 0 2
81741: ARRAY
81742: NOT
81743: IFTRUE 81758
81745: PUSH
81746: LD_EXP 55
81750: PUSH
81751: LD_VAR 0 2
81755: ARRAY
81756: NOT
81757: OR
81758: IFFALSE 81762
// continue ;
81760: GO 81729
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
81762: LD_ADDR_VAR 0 5
81766: PUSH
81767: LD_EXP 31
81771: PUSH
81772: LD_VAR 0 2
81776: ARRAY
81777: PUSH
81778: LD_INT 1
81780: ARRAY
81781: PPUSH
81782: CALL_OW 255
81786: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
81787: LD_ADDR_VAR 0 6
81791: PUSH
81792: LD_EXP 31
81796: PUSH
81797: LD_VAR 0 2
81801: ARRAY
81802: PPUSH
81803: LD_INT 30
81805: PUSH
81806: LD_INT 3
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PPUSH
81813: CALL_OW 72
81817: ST_TO_ADDR
// if not fac then
81818: LD_VAR 0 6
81822: NOT
81823: IFFALSE 81874
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81825: LD_ADDR_VAR 0 6
81829: PUSH
81830: LD_EXP 31
81834: PUSH
81835: LD_VAR 0 2
81839: ARRAY
81840: PPUSH
81841: LD_INT 2
81843: PUSH
81844: LD_INT 30
81846: PUSH
81847: LD_INT 0
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 30
81856: PUSH
81857: LD_INT 1
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: LIST
81868: PPUSH
81869: CALL_OW 72
81873: ST_TO_ADDR
// if not fac then
81874: LD_VAR 0 6
81878: NOT
81879: IFFALSE 81883
// continue ;
81881: GO 81729
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
81883: LD_ADDR_VAR 0 7
81887: PUSH
81888: LD_EXP 55
81892: PUSH
81893: LD_VAR 0 2
81897: ARRAY
81898: PPUSH
81899: LD_INT 22
81901: PUSH
81902: LD_VAR 0 5
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 21
81913: PUSH
81914: LD_INT 2
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 3
81923: PUSH
81924: LD_INT 60
81926: PUSH
81927: EMPTY
81928: LIST
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 3
81936: PUSH
81937: LD_INT 24
81939: PUSH
81940: LD_INT 1000
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: PPUSH
81957: CALL_OW 70
81961: ST_TO_ADDR
// for j in fac do
81962: LD_ADDR_VAR 0 3
81966: PUSH
81967: LD_VAR 0 6
81971: PUSH
81972: FOR_IN
81973: IFFALSE 82068
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
81975: LD_ADDR_VAR 0 7
81979: PUSH
81980: LD_VAR 0 7
81984: PUSH
81985: LD_INT 22
81987: PUSH
81988: LD_VAR 0 5
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 91
81999: PUSH
82000: LD_VAR 0 3
82004: PUSH
82005: LD_INT 15
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 21
82015: PUSH
82016: LD_INT 2
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 3
82025: PUSH
82026: LD_INT 60
82028: PUSH
82029: EMPTY
82030: LIST
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 3
82038: PUSH
82039: LD_INT 24
82041: PUSH
82042: LD_INT 1000
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: PPUSH
82060: CALL_OW 69
82064: UNION
82065: ST_TO_ADDR
82066: GO 81972
82068: POP
82069: POP
// if not vehs then
82070: LD_VAR 0 7
82074: NOT
82075: IFFALSE 82101
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
82077: LD_ADDR_EXP 43
82081: PUSH
82082: LD_EXP 43
82086: PPUSH
82087: LD_VAR 0 2
82091: PPUSH
82092: EMPTY
82093: PPUSH
82094: CALL_OW 1
82098: ST_TO_ADDR
// continue ;
82099: GO 81729
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
82101: LD_ADDR_VAR 0 8
82105: PUSH
82106: LD_EXP 31
82110: PUSH
82111: LD_VAR 0 2
82115: ARRAY
82116: PPUSH
82117: LD_INT 30
82119: PUSH
82120: LD_INT 3
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PPUSH
82127: CALL_OW 72
82131: ST_TO_ADDR
// if tmp then
82132: LD_VAR 0 8
82136: IFFALSE 82239
// begin for j in tmp do
82138: LD_ADDR_VAR 0 3
82142: PUSH
82143: LD_VAR 0 8
82147: PUSH
82148: FOR_IN
82149: IFFALSE 82237
// for k in UnitsInside ( j ) do
82151: LD_ADDR_VAR 0 4
82155: PUSH
82156: LD_VAR 0 3
82160: PPUSH
82161: CALL_OW 313
82165: PUSH
82166: FOR_IN
82167: IFFALSE 82233
// if k then
82169: LD_VAR 0 4
82173: IFFALSE 82231
// if not k in mc_repair_vehicle [ i ] then
82175: LD_VAR 0 4
82179: PUSH
82180: LD_EXP 43
82184: PUSH
82185: LD_VAR 0 2
82189: ARRAY
82190: IN
82191: NOT
82192: IFFALSE 82231
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
82194: LD_ADDR_EXP 43
82198: PUSH
82199: LD_EXP 43
82203: PPUSH
82204: LD_VAR 0 2
82208: PPUSH
82209: LD_EXP 43
82213: PUSH
82214: LD_VAR 0 2
82218: ARRAY
82219: PUSH
82220: LD_VAR 0 4
82224: UNION
82225: PPUSH
82226: CALL_OW 1
82230: ST_TO_ADDR
82231: GO 82166
82233: POP
82234: POP
82235: GO 82148
82237: POP
82238: POP
// end ; if not mc_repair_vehicle [ i ] then
82239: LD_EXP 43
82243: PUSH
82244: LD_VAR 0 2
82248: ARRAY
82249: NOT
82250: IFFALSE 82254
// continue ;
82252: GO 81729
// for j in mc_repair_vehicle [ i ] do
82254: LD_ADDR_VAR 0 3
82258: PUSH
82259: LD_EXP 43
82263: PUSH
82264: LD_VAR 0 2
82268: ARRAY
82269: PUSH
82270: FOR_IN
82271: IFFALSE 82452
// begin if GetClass ( j ) <> 3 then
82273: LD_VAR 0 3
82277: PPUSH
82278: CALL_OW 257
82282: PUSH
82283: LD_INT 3
82285: NONEQUAL
82286: IFFALSE 82327
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
82288: LD_ADDR_EXP 43
82292: PUSH
82293: LD_EXP 43
82297: PPUSH
82298: LD_VAR 0 2
82302: PPUSH
82303: LD_EXP 43
82307: PUSH
82308: LD_VAR 0 2
82312: ARRAY
82313: PUSH
82314: LD_VAR 0 3
82318: DIFF
82319: PPUSH
82320: CALL_OW 1
82324: ST_TO_ADDR
// continue ;
82325: GO 82270
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
82327: LD_VAR 0 3
82331: PPUSH
82332: CALL_OW 311
82336: NOT
82337: IFFALSE 82362
82339: PUSH
82340: LD_VAR 0 3
82344: PUSH
82345: LD_EXP 34
82349: PUSH
82350: LD_VAR 0 2
82354: ARRAY
82355: PUSH
82356: LD_INT 1
82358: ARRAY
82359: IN
82360: NOT
82361: AND
82362: IFFALSE 82387
82364: PUSH
82365: LD_VAR 0 3
82369: PUSH
82370: LD_EXP 34
82374: PUSH
82375: LD_VAR 0 2
82379: ARRAY
82380: PUSH
82381: LD_INT 2
82383: ARRAY
82384: IN
82385: NOT
82386: AND
82387: IFFALSE 82450
// begin if IsInUnit ( j ) then
82389: LD_VAR 0 3
82393: PPUSH
82394: CALL_OW 310
82398: IFFALSE 82411
// ComExitBuilding ( j ) else
82400: LD_VAR 0 3
82404: PPUSH
82405: CALL_OW 122
82409: GO 82450
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
82411: LD_VAR 0 3
82415: PPUSH
82416: LD_VAR 0 7
82420: PUSH
82421: LD_INT 1
82423: ARRAY
82424: PPUSH
82425: CALL 60238 0 2
82429: NOT
82430: IFFALSE 82450
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
82432: LD_VAR 0 3
82436: PPUSH
82437: LD_VAR 0 7
82441: PUSH
82442: LD_INT 1
82444: ARRAY
82445: PPUSH
82446: CALL_OW 129
// end ; end ;
82450: GO 82270
82452: POP
82453: POP
// end ;
82454: GO 81729
82456: POP
82457: POP
// end ;
82458: LD_VAR 0 1
82462: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
82463: LD_INT 0
82465: PPUSH
82466: PPUSH
82467: PPUSH
82468: PPUSH
82469: PPUSH
82470: PPUSH
82471: PPUSH
82472: PPUSH
82473: PPUSH
82474: PPUSH
82475: PPUSH
// if not mc_bases then
82476: LD_EXP 31
82480: NOT
82481: IFFALSE 82485
// exit ;
82483: GO 83303
// for i = 1 to mc_bases do
82485: LD_ADDR_VAR 0 2
82489: PUSH
82490: DOUBLE
82491: LD_INT 1
82493: DEC
82494: ST_TO_ADDR
82495: LD_EXP 31
82499: PUSH
82500: FOR_TO
82501: IFFALSE 83301
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
82503: LD_EXP 59
82507: PUSH
82508: LD_VAR 0 2
82512: ARRAY
82513: NOT
82514: IFTRUE 82532
82516: PUSH
82517: LD_EXP 34
82521: PUSH
82522: LD_VAR 0 2
82526: ARRAY
82527: PUSH
82528: LD_INT 1
82530: ARRAY
82531: OR
82532: IFTRUE 82550
82534: PUSH
82535: LD_EXP 34
82539: PUSH
82540: LD_VAR 0 2
82544: ARRAY
82545: PUSH
82546: LD_INT 2
82548: ARRAY
82549: OR
82550: IFTRUE 82573
82552: PUSH
82553: LD_EXP 57
82557: PUSH
82558: LD_VAR 0 2
82562: ARRAY
82563: PPUSH
82564: LD_INT 1
82566: PPUSH
82567: CALL_OW 325
82571: NOT
82572: OR
82573: IFTRUE 82587
82575: PUSH
82576: LD_EXP 54
82580: PUSH
82581: LD_VAR 0 2
82585: ARRAY
82586: OR
82587: IFFALSE 82591
// continue ;
82589: GO 82500
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
82591: LD_ADDR_VAR 0 8
82595: PUSH
82596: LD_EXP 31
82600: PUSH
82601: LD_VAR 0 2
82605: ARRAY
82606: PPUSH
82607: LD_INT 25
82609: PUSH
82610: LD_INT 4
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 50
82619: PUSH
82620: EMPTY
82621: LIST
82622: PUSH
82623: LD_INT 3
82625: PUSH
82626: LD_INT 60
82628: PUSH
82629: EMPTY
82630: LIST
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: LIST
82640: PPUSH
82641: CALL_OW 72
82645: PUSH
82646: LD_EXP 35
82650: PUSH
82651: LD_VAR 0 2
82655: ARRAY
82656: DIFF
82657: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82658: LD_ADDR_VAR 0 9
82662: PUSH
82663: LD_EXP 31
82667: PUSH
82668: LD_VAR 0 2
82672: ARRAY
82673: PPUSH
82674: LD_INT 2
82676: PUSH
82677: LD_INT 30
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 30
82689: PUSH
82690: LD_INT 1
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: LIST
82701: PPUSH
82702: CALL_OW 72
82706: ST_TO_ADDR
// if not tmp or not dep then
82707: LD_VAR 0 8
82711: NOT
82712: IFTRUE 82721
82714: PUSH
82715: LD_VAR 0 9
82719: NOT
82720: OR
82721: IFFALSE 82725
// continue ;
82723: GO 82500
// side := GetSide ( tmp [ 1 ] ) ;
82725: LD_ADDR_VAR 0 11
82729: PUSH
82730: LD_VAR 0 8
82734: PUSH
82735: LD_INT 1
82737: ARRAY
82738: PPUSH
82739: CALL_OW 255
82743: ST_TO_ADDR
// dep := dep [ 1 ] ;
82744: LD_ADDR_VAR 0 9
82748: PUSH
82749: LD_VAR 0 9
82753: PUSH
82754: LD_INT 1
82756: ARRAY
82757: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
82758: LD_ADDR_VAR 0 7
82762: PUSH
82763: LD_EXP 59
82767: PUSH
82768: LD_VAR 0 2
82772: ARRAY
82773: PPUSH
82774: LD_INT 22
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 25
82786: PUSH
82787: LD_INT 12
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PPUSH
82798: CALL_OW 70
82802: PUSH
82803: LD_INT 22
82805: PUSH
82806: LD_INT 0
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 25
82815: PUSH
82816: LD_INT 12
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 91
82825: PUSH
82826: LD_VAR 0 9
82830: PUSH
82831: LD_INT 20
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: LIST
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: LIST
82843: PPUSH
82844: CALL_OW 69
82848: UNION
82849: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
82850: LD_ADDR_VAR 0 10
82854: PUSH
82855: LD_EXP 59
82859: PUSH
82860: LD_VAR 0 2
82864: ARRAY
82865: PPUSH
82866: LD_INT 81
82868: PUSH
82869: LD_VAR 0 11
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PPUSH
82878: CALL_OW 70
82882: ST_TO_ADDR
// if not apes or danger_at_area then
82883: LD_VAR 0 7
82887: NOT
82888: IFTRUE 82896
82890: PUSH
82891: LD_VAR 0 10
82895: OR
82896: IFFALSE 82946
// begin if mc_taming [ i ] then
82898: LD_EXP 62
82902: PUSH
82903: LD_VAR 0 2
82907: ARRAY
82908: IFFALSE 82944
// begin MC_Reset ( i , 121 ) ;
82910: LD_VAR 0 2
82914: PPUSH
82915: LD_INT 121
82917: PPUSH
82918: CALL 67678 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
82922: LD_ADDR_EXP 62
82926: PUSH
82927: LD_EXP 62
82931: PPUSH
82932: LD_VAR 0 2
82936: PPUSH
82937: EMPTY
82938: PPUSH
82939: CALL_OW 1
82943: ST_TO_ADDR
// end ; continue ;
82944: GO 82500
// end ; for j in tmp do
82946: LD_ADDR_VAR 0 3
82950: PUSH
82951: LD_VAR 0 8
82955: PUSH
82956: FOR_IN
82957: IFFALSE 83297
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
82959: LD_VAR 0 3
82963: PUSH
82964: LD_EXP 62
82968: PUSH
82969: LD_VAR 0 2
82973: ARRAY
82974: IN
82975: NOT
82976: IFFALSE 82994
82978: PUSH
82979: LD_EXP 62
82983: PUSH
82984: LD_VAR 0 2
82988: ARRAY
82989: PUSH
82990: LD_INT 3
82992: LESS
82993: AND
82994: IFFALSE 83052
// begin SetTag ( j , 121 ) ;
82996: LD_VAR 0 3
83000: PPUSH
83001: LD_INT 121
83003: PPUSH
83004: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
83008: LD_ADDR_EXP 62
83012: PUSH
83013: LD_EXP 62
83017: PPUSH
83018: LD_VAR 0 2
83022: PUSH
83023: LD_EXP 62
83027: PUSH
83028: LD_VAR 0 2
83032: ARRAY
83033: PUSH
83034: LD_INT 1
83036: PLUS
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PPUSH
83042: LD_VAR 0 3
83046: PPUSH
83047: CALL 25097 0 3
83051: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
83052: LD_VAR 0 3
83056: PUSH
83057: LD_EXP 62
83061: PUSH
83062: LD_VAR 0 2
83066: ARRAY
83067: IN
83068: IFFALSE 83295
// begin if GetClass ( j ) <> 4 then
83070: LD_VAR 0 3
83074: PPUSH
83075: CALL_OW 257
83079: PUSH
83080: LD_INT 4
83082: NONEQUAL
83083: IFFALSE 83136
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
83085: LD_ADDR_EXP 62
83089: PUSH
83090: LD_EXP 62
83094: PPUSH
83095: LD_VAR 0 2
83099: PPUSH
83100: LD_EXP 62
83104: PUSH
83105: LD_VAR 0 2
83109: ARRAY
83110: PUSH
83111: LD_VAR 0 3
83115: DIFF
83116: PPUSH
83117: CALL_OW 1
83121: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83122: LD_VAR 0 3
83126: PPUSH
83127: LD_INT 0
83129: PPUSH
83130: CALL_OW 109
// continue ;
83134: GO 82956
// end ; if IsInUnit ( j ) then
83136: LD_VAR 0 3
83140: PPUSH
83141: CALL_OW 310
83145: IFFALSE 83156
// ComExitBuilding ( j ) ;
83147: LD_VAR 0 3
83151: PPUSH
83152: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
83156: LD_ADDR_VAR 0 6
83160: PUSH
83161: LD_VAR 0 7
83165: PPUSH
83166: LD_VAR 0 3
83170: PPUSH
83171: CALL_OW 74
83175: ST_TO_ADDR
// if not ape then
83176: LD_VAR 0 6
83180: NOT
83181: IFFALSE 83185
// break ;
83183: GO 83297
// x := GetX ( ape ) ;
83185: LD_ADDR_VAR 0 4
83189: PUSH
83190: LD_VAR 0 6
83194: PPUSH
83195: CALL_OW 250
83199: ST_TO_ADDR
// y := GetY ( ape ) ;
83200: LD_ADDR_VAR 0 5
83204: PUSH
83205: LD_VAR 0 6
83209: PPUSH
83210: CALL_OW 251
83214: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83215: LD_VAR 0 4
83219: PPUSH
83220: LD_VAR 0 5
83224: PPUSH
83225: CALL_OW 488
83229: NOT
83230: IFTRUE 83260
83232: PUSH
83233: LD_VAR 0 11
83237: PPUSH
83238: LD_VAR 0 4
83242: PPUSH
83243: LD_VAR 0 5
83247: PPUSH
83248: LD_INT 20
83250: PPUSH
83251: CALL 26367 0 4
83255: PUSH
83256: LD_INT 4
83258: ARRAY
83259: OR
83260: IFFALSE 83264
// break ;
83262: GO 83297
// if not HasTask ( j ) then
83264: LD_VAR 0 3
83268: PPUSH
83269: CALL_OW 314
83273: NOT
83274: IFFALSE 83295
// ComTameXY ( j , x , y ) ;
83276: LD_VAR 0 3
83280: PPUSH
83281: LD_VAR 0 4
83285: PPUSH
83286: LD_VAR 0 5
83290: PPUSH
83291: CALL_OW 131
// end ; end ;
83295: GO 82956
83297: POP
83298: POP
// end ;
83299: GO 82500
83301: POP
83302: POP
// end ;
83303: LD_VAR 0 1
83307: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
83308: LD_INT 0
83310: PPUSH
83311: PPUSH
83312: PPUSH
83313: PPUSH
83314: PPUSH
83315: PPUSH
83316: PPUSH
83317: PPUSH
// if not mc_bases then
83318: LD_EXP 31
83322: NOT
83323: IFFALSE 83327
// exit ;
83325: GO 83959
// for i = 1 to mc_bases do
83327: LD_ADDR_VAR 0 2
83331: PUSH
83332: DOUBLE
83333: LD_INT 1
83335: DEC
83336: ST_TO_ADDR
83337: LD_EXP 31
83341: PUSH
83342: FOR_TO
83343: IFFALSE 83957
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
83345: LD_EXP 60
83349: PUSH
83350: LD_VAR 0 2
83354: ARRAY
83355: NOT
83356: IFTRUE 83386
83358: PUSH
83359: LD_EXP 60
83363: PUSH
83364: LD_VAR 0 2
83368: ARRAY
83369: PPUSH
83370: LD_INT 25
83372: PUSH
83373: LD_INT 12
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PPUSH
83380: CALL_OW 72
83384: NOT
83385: OR
83386: IFFALSE 83390
// continue ;
83388: GO 83342
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
83390: LD_ADDR_VAR 0 5
83394: PUSH
83395: LD_EXP 60
83399: PUSH
83400: LD_VAR 0 2
83404: ARRAY
83405: PUSH
83406: LD_INT 1
83408: ARRAY
83409: PPUSH
83410: CALL_OW 255
83414: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
83415: LD_VAR 0 5
83419: PPUSH
83420: LD_INT 2
83422: PPUSH
83423: CALL_OW 325
83427: IFFALSE 83680
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
83429: LD_ADDR_VAR 0 4
83433: PUSH
83434: LD_EXP 60
83438: PUSH
83439: LD_VAR 0 2
83443: ARRAY
83444: PPUSH
83445: LD_INT 25
83447: PUSH
83448: LD_INT 16
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PPUSH
83455: CALL_OW 72
83459: ST_TO_ADDR
// if tmp < 6 then
83460: LD_VAR 0 4
83464: PUSH
83465: LD_INT 6
83467: LESS
83468: IFFALSE 83680
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83470: LD_ADDR_VAR 0 6
83474: PUSH
83475: LD_EXP 31
83479: PUSH
83480: LD_VAR 0 2
83484: ARRAY
83485: PPUSH
83486: LD_INT 2
83488: PUSH
83489: LD_INT 30
83491: PUSH
83492: LD_INT 0
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 30
83501: PUSH
83502: LD_INT 1
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: LIST
83513: PPUSH
83514: CALL_OW 72
83518: ST_TO_ADDR
// if depot then
83519: LD_VAR 0 6
83523: IFFALSE 83680
// begin selected := 0 ;
83525: LD_ADDR_VAR 0 7
83529: PUSH
83530: LD_INT 0
83532: ST_TO_ADDR
// for j in depot do
83533: LD_ADDR_VAR 0 3
83537: PUSH
83538: LD_VAR 0 6
83542: PUSH
83543: FOR_IN
83544: IFFALSE 83575
// begin if UnitsInside ( j ) < 6 then
83546: LD_VAR 0 3
83550: PPUSH
83551: CALL_OW 313
83555: PUSH
83556: LD_INT 6
83558: LESS
83559: IFFALSE 83573
// begin selected := j ;
83561: LD_ADDR_VAR 0 7
83565: PUSH
83566: LD_VAR 0 3
83570: ST_TO_ADDR
// break ;
83571: GO 83575
// end ; end ;
83573: GO 83543
83575: POP
83576: POP
// if selected then
83577: LD_VAR 0 7
83581: IFFALSE 83680
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
83583: LD_ADDR_VAR 0 3
83587: PUSH
83588: LD_EXP 60
83592: PUSH
83593: LD_VAR 0 2
83597: ARRAY
83598: PPUSH
83599: LD_INT 25
83601: PUSH
83602: LD_INT 12
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PPUSH
83609: CALL_OW 72
83613: PUSH
83614: FOR_IN
83615: IFFALSE 83678
// if not HasTask ( j ) then
83617: LD_VAR 0 3
83621: PPUSH
83622: CALL_OW 314
83626: NOT
83627: IFFALSE 83676
// begin if not IsInUnit ( j ) then
83629: LD_VAR 0 3
83633: PPUSH
83634: CALL_OW 310
83638: NOT
83639: IFFALSE 83655
// ComEnterUnit ( j , selected ) ;
83641: LD_VAR 0 3
83645: PPUSH
83646: LD_VAR 0 7
83650: PPUSH
83651: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
83655: LD_VAR 0 3
83659: PPUSH
83660: LD_INT 16
83662: PPUSH
83663: CALL_OW 183
// AddComExitBuilding ( j ) ;
83667: LD_VAR 0 3
83671: PPUSH
83672: CALL_OW 182
// end ;
83676: GO 83614
83678: POP
83679: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
83680: LD_VAR 0 5
83684: PPUSH
83685: LD_INT 11
83687: PPUSH
83688: CALL_OW 325
83692: IFFALSE 83955
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
83694: LD_ADDR_VAR 0 4
83698: PUSH
83699: LD_EXP 60
83703: PUSH
83704: LD_VAR 0 2
83708: ARRAY
83709: PPUSH
83710: LD_INT 25
83712: PUSH
83713: LD_INT 16
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PPUSH
83720: CALL_OW 72
83724: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
83725: LD_VAR 0 4
83729: PUSH
83730: LD_INT 6
83732: GREATEREQUAL
83733: IFTRUE 83750
83735: PUSH
83736: LD_VAR 0 5
83740: PPUSH
83741: LD_INT 2
83743: PPUSH
83744: CALL_OW 325
83748: NOT
83749: OR
83750: IFFALSE 83955
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83752: LD_ADDR_VAR 0 8
83756: PUSH
83757: LD_EXP 31
83761: PUSH
83762: LD_VAR 0 2
83766: ARRAY
83767: PPUSH
83768: LD_INT 2
83770: PUSH
83771: LD_INT 30
83773: PUSH
83774: LD_INT 4
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 30
83783: PUSH
83784: LD_INT 5
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: LIST
83795: PPUSH
83796: CALL_OW 72
83800: ST_TO_ADDR
// if barracks then
83801: LD_VAR 0 8
83805: IFFALSE 83955
// begin selected := 0 ;
83807: LD_ADDR_VAR 0 7
83811: PUSH
83812: LD_INT 0
83814: ST_TO_ADDR
// for j in barracks do
83815: LD_ADDR_VAR 0 3
83819: PUSH
83820: LD_VAR 0 8
83824: PUSH
83825: FOR_IN
83826: IFFALSE 83857
// begin if UnitsInside ( j ) < 6 then
83828: LD_VAR 0 3
83832: PPUSH
83833: CALL_OW 313
83837: PUSH
83838: LD_INT 6
83840: LESS
83841: IFFALSE 83855
// begin selected := j ;
83843: LD_ADDR_VAR 0 7
83847: PUSH
83848: LD_VAR 0 3
83852: ST_TO_ADDR
// break ;
83853: GO 83857
// end ; end ;
83855: GO 83825
83857: POP
83858: POP
// if selected then
83859: LD_VAR 0 7
83863: IFFALSE 83955
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
83865: LD_ADDR_VAR 0 3
83869: PUSH
83870: LD_EXP 60
83874: PUSH
83875: LD_VAR 0 2
83879: ARRAY
83880: PPUSH
83881: LD_INT 25
83883: PUSH
83884: LD_INT 12
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PPUSH
83891: CALL_OW 72
83895: PUSH
83896: FOR_IN
83897: IFFALSE 83953
// if not IsInUnit ( j ) and not HasTask ( j ) then
83899: LD_VAR 0 3
83903: PPUSH
83904: CALL_OW 310
83908: NOT
83909: IFFALSE 83923
83911: PUSH
83912: LD_VAR 0 3
83916: PPUSH
83917: CALL_OW 314
83921: NOT
83922: AND
83923: IFFALSE 83951
// begin ComEnterUnit ( j , selected ) ;
83925: LD_VAR 0 3
83929: PPUSH
83930: LD_VAR 0 7
83934: PPUSH
83935: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
83939: LD_VAR 0 3
83943: PPUSH
83944: LD_INT 15
83946: PPUSH
83947: CALL_OW 183
// end ;
83951: GO 83896
83953: POP
83954: POP
// end ; end ; end ; end ; end ;
83955: GO 83342
83957: POP
83958: POP
// end ;
83959: LD_VAR 0 1
83963: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
83964: LD_INT 0
83966: PPUSH
83967: PPUSH
83968: PPUSH
83969: PPUSH
// if not mc_bases then
83970: LD_EXP 31
83974: NOT
83975: IFFALSE 83979
// exit ;
83977: GO 84161
// for i = 1 to mc_bases do
83979: LD_ADDR_VAR 0 2
83983: PUSH
83984: DOUBLE
83985: LD_INT 1
83987: DEC
83988: ST_TO_ADDR
83989: LD_EXP 31
83993: PUSH
83994: FOR_TO
83995: IFFALSE 84159
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
83997: LD_ADDR_VAR 0 4
84001: PUSH
84002: LD_EXP 31
84006: PUSH
84007: LD_VAR 0 2
84011: ARRAY
84012: PPUSH
84013: LD_INT 25
84015: PUSH
84016: LD_INT 9
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PPUSH
84023: CALL_OW 72
84027: ST_TO_ADDR
// if not tmp then
84028: LD_VAR 0 4
84032: NOT
84033: IFFALSE 84037
// continue ;
84035: GO 83994
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
84037: LD_EXP 57
84041: PUSH
84042: LD_VAR 0 2
84046: ARRAY
84047: PPUSH
84048: LD_INT 29
84050: PPUSH
84051: CALL_OW 325
84055: NOT
84056: IFFALSE 84079
84058: PUSH
84059: LD_EXP 57
84063: PUSH
84064: LD_VAR 0 2
84068: ARRAY
84069: PPUSH
84070: LD_INT 28
84072: PPUSH
84073: CALL_OW 325
84077: NOT
84078: AND
84079: IFFALSE 84083
// continue ;
84081: GO 83994
// for j in tmp do
84083: LD_ADDR_VAR 0 3
84087: PUSH
84088: LD_VAR 0 4
84092: PUSH
84093: FOR_IN
84094: IFFALSE 84155
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
84096: LD_VAR 0 3
84100: PUSH
84101: LD_EXP 34
84105: PUSH
84106: LD_VAR 0 2
84110: ARRAY
84111: PUSH
84112: LD_INT 1
84114: ARRAY
84115: IN
84116: NOT
84117: IFFALSE 84142
84119: PUSH
84120: LD_VAR 0 3
84124: PUSH
84125: LD_EXP 34
84129: PUSH
84130: LD_VAR 0 2
84134: ARRAY
84135: PUSH
84136: LD_INT 2
84138: ARRAY
84139: IN
84140: NOT
84141: AND
84142: IFFALSE 84153
// ComSpaceTimeShoot ( j ) ;
84144: LD_VAR 0 3
84148: PPUSH
84149: CALL 21014 0 1
84153: GO 84093
84155: POP
84156: POP
// end ;
84157: GO 83994
84159: POP
84160: POP
// end ;
84161: LD_VAR 0 1
84165: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
84166: LD_INT 0
84168: PPUSH
84169: PPUSH
84170: PPUSH
84171: PPUSH
84172: PPUSH
84173: PPUSH
84174: PPUSH
84175: PPUSH
84176: PPUSH
// if not mc_bases then
84177: LD_EXP 31
84181: NOT
84182: IFFALSE 84186
// exit ;
84184: GO 84818
// for i = 1 to mc_bases do
84186: LD_ADDR_VAR 0 2
84190: PUSH
84191: DOUBLE
84192: LD_INT 1
84194: DEC
84195: ST_TO_ADDR
84196: LD_EXP 31
84200: PUSH
84201: FOR_TO
84202: IFFALSE 84816
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
84204: LD_EXP 66
84208: PUSH
84209: LD_VAR 0 2
84213: ARRAY
84214: NOT
84215: IFTRUE 84241
84217: PUSH
84218: LD_INT 38
84220: PPUSH
84221: LD_EXP 57
84225: PUSH
84226: LD_VAR 0 2
84230: ARRAY
84231: PPUSH
84232: CALL_OW 321
84236: PUSH
84237: LD_INT 2
84239: NONEQUAL
84240: OR
84241: IFFALSE 84245
// continue ;
84243: GO 84201
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
84245: LD_ADDR_VAR 0 8
84249: PUSH
84250: LD_EXP 31
84254: PUSH
84255: LD_VAR 0 2
84259: ARRAY
84260: PPUSH
84261: LD_INT 30
84263: PUSH
84264: LD_INT 34
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PPUSH
84271: CALL_OW 72
84275: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
84276: LD_ADDR_VAR 0 9
84280: PUSH
84281: LD_EXP 31
84285: PUSH
84286: LD_VAR 0 2
84290: ARRAY
84291: PPUSH
84292: LD_INT 25
84294: PUSH
84295: LD_INT 4
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PPUSH
84302: CALL_OW 72
84306: PPUSH
84307: LD_INT 0
84309: PPUSH
84310: CALL 55700 0 2
84314: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
84315: LD_VAR 0 9
84319: NOT
84320: IFTRUE 84329
84322: PUSH
84323: LD_VAR 0 8
84327: NOT
84328: OR
84329: IFTRUE 84351
84331: PUSH
84332: LD_EXP 31
84336: PUSH
84337: LD_VAR 0 2
84341: ARRAY
84342: PPUSH
84343: LD_INT 124
84345: PPUSH
84346: CALL 55700 0 2
84350: OR
84351: IFFALSE 84355
// continue ;
84353: GO 84201
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
84355: LD_EXP 67
84359: PUSH
84360: LD_VAR 0 2
84364: ARRAY
84365: PUSH
84366: LD_EXP 66
84370: PUSH
84371: LD_VAR 0 2
84375: ARRAY
84376: LESS
84377: IFFALSE 84397
84379: PUSH
84380: LD_EXP 67
84384: PUSH
84385: LD_VAR 0 2
84389: ARRAY
84390: PUSH
84391: LD_VAR 0 8
84395: LESS
84396: AND
84397: IFFALSE 84814
// begin tmp := sci [ 1 ] ;
84399: LD_ADDR_VAR 0 7
84403: PUSH
84404: LD_VAR 0 9
84408: PUSH
84409: LD_INT 1
84411: ARRAY
84412: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
84413: LD_VAR 0 7
84417: PPUSH
84418: LD_INT 124
84420: PPUSH
84421: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
84425: LD_ADDR_VAR 0 3
84429: PUSH
84430: DOUBLE
84431: LD_EXP 66
84435: PUSH
84436: LD_VAR 0 2
84440: ARRAY
84441: INC
84442: ST_TO_ADDR
84443: LD_EXP 66
84447: PUSH
84448: LD_VAR 0 2
84452: ARRAY
84453: PUSH
84454: FOR_DOWNTO
84455: IFFALSE 84800
// begin if IsInUnit ( tmp ) then
84457: LD_VAR 0 7
84461: PPUSH
84462: CALL_OW 310
84466: IFFALSE 84477
// ComExitBuilding ( tmp ) ;
84468: LD_VAR 0 7
84472: PPUSH
84473: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
84477: LD_INT 35
84479: PPUSH
84480: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
84484: LD_VAR 0 7
84488: PPUSH
84489: CALL_OW 310
84493: NOT
84494: IFFALSE 84508
84496: PUSH
84497: LD_VAR 0 7
84501: PPUSH
84502: CALL_OW 314
84506: NOT
84507: AND
84508: IFFALSE 84477
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
84510: LD_ADDR_VAR 0 6
84514: PUSH
84515: LD_VAR 0 7
84519: PPUSH
84520: CALL_OW 250
84524: PUSH
84525: LD_VAR 0 7
84529: PPUSH
84530: CALL_OW 251
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
84539: LD_INT 35
84541: PPUSH
84542: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
84546: LD_ADDR_VAR 0 4
84550: PUSH
84551: LD_EXP 66
84555: PUSH
84556: LD_VAR 0 2
84560: ARRAY
84561: PUSH
84562: LD_VAR 0 3
84566: ARRAY
84567: PUSH
84568: LD_INT 1
84570: ARRAY
84571: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
84572: LD_ADDR_VAR 0 5
84576: PUSH
84577: LD_EXP 66
84581: PUSH
84582: LD_VAR 0 2
84586: ARRAY
84587: PUSH
84588: LD_VAR 0 3
84592: ARRAY
84593: PUSH
84594: LD_INT 2
84596: ARRAY
84597: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
84598: LD_VAR 0 7
84602: PPUSH
84603: LD_INT 10
84605: PPUSH
84606: CALL 28076 0 2
84610: PUSH
84611: LD_INT 4
84613: ARRAY
84614: IFFALSE 84652
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
84616: LD_VAR 0 7
84620: PPUSH
84621: LD_VAR 0 6
84625: PUSH
84626: LD_INT 1
84628: ARRAY
84629: PPUSH
84630: LD_VAR 0 6
84634: PUSH
84635: LD_INT 2
84637: ARRAY
84638: PPUSH
84639: CALL_OW 111
// wait ( 0 0$10 ) ;
84643: LD_INT 350
84645: PPUSH
84646: CALL_OW 67
// end else
84650: GO 84678
// begin ComMoveXY ( tmp , x , y ) ;
84652: LD_VAR 0 7
84656: PPUSH
84657: LD_VAR 0 4
84661: PPUSH
84662: LD_VAR 0 5
84666: PPUSH
84667: CALL_OW 111
// wait ( 0 0$3 ) ;
84671: LD_INT 105
84673: PPUSH
84674: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
84678: LD_VAR 0 7
84682: PPUSH
84683: LD_VAR 0 4
84687: PPUSH
84688: LD_VAR 0 5
84692: PPUSH
84693: CALL_OW 307
84697: IFFALSE 84539
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
84699: LD_VAR 0 7
84703: PPUSH
84704: LD_VAR 0 4
84708: PPUSH
84709: LD_VAR 0 5
84713: PPUSH
84714: LD_VAR 0 8
84718: PUSH
84719: LD_VAR 0 3
84723: ARRAY
84724: PPUSH
84725: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
84729: LD_INT 35
84731: PPUSH
84732: CALL_OW 67
// until not HasTask ( tmp ) ;
84736: LD_VAR 0 7
84740: PPUSH
84741: CALL_OW 314
84745: NOT
84746: IFFALSE 84729
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
84748: LD_ADDR_EXP 67
84752: PUSH
84753: LD_EXP 67
84757: PPUSH
84758: LD_VAR 0 2
84762: PUSH
84763: LD_EXP 67
84767: PUSH
84768: LD_VAR 0 2
84772: ARRAY
84773: PUSH
84774: LD_INT 1
84776: PLUS
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PPUSH
84782: LD_VAR 0 8
84786: PUSH
84787: LD_VAR 0 3
84791: ARRAY
84792: PPUSH
84793: CALL 25097 0 3
84797: ST_TO_ADDR
// end ;
84798: GO 84454
84800: POP
84801: POP
// MC_Reset ( i , 124 ) ;
84802: LD_VAR 0 2
84806: PPUSH
84807: LD_INT 124
84809: PPUSH
84810: CALL 67678 0 2
// end ; end ;
84814: GO 84201
84816: POP
84817: POP
// end ;
84818: LD_VAR 0 1
84822: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
84823: LD_INT 0
84825: PPUSH
84826: PPUSH
84827: PPUSH
// if not mc_bases then
84828: LD_EXP 31
84832: NOT
84833: IFFALSE 84837
// exit ;
84835: GO 85451
// for i = 1 to mc_bases do
84837: LD_ADDR_VAR 0 2
84841: PUSH
84842: DOUBLE
84843: LD_INT 1
84845: DEC
84846: ST_TO_ADDR
84847: LD_EXP 31
84851: PUSH
84852: FOR_TO
84853: IFFALSE 85449
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
84855: LD_ADDR_VAR 0 3
84859: PUSH
84860: LD_EXP 31
84864: PUSH
84865: LD_VAR 0 2
84869: ARRAY
84870: PPUSH
84871: LD_INT 25
84873: PUSH
84874: LD_INT 4
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PPUSH
84881: CALL_OW 72
84885: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84886: LD_VAR 0 3
84890: NOT
84891: IFTRUE 84906
84893: PUSH
84894: LD_EXP 68
84898: PUSH
84899: LD_VAR 0 2
84903: ARRAY
84904: NOT
84905: OR
84906: IFTRUE 84954
84908: PUSH
84909: LD_EXP 31
84913: PUSH
84914: LD_VAR 0 2
84918: ARRAY
84919: PPUSH
84920: LD_INT 2
84922: PUSH
84923: LD_INT 30
84925: PUSH
84926: LD_INT 0
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 30
84935: PUSH
84936: LD_INT 1
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: LIST
84947: PPUSH
84948: CALL_OW 72
84952: NOT
84953: OR
84954: IFFALSE 85004
// begin if mc_deposits_finder [ i ] then
84956: LD_EXP 69
84960: PUSH
84961: LD_VAR 0 2
84965: ARRAY
84966: IFFALSE 85002
// begin MC_Reset ( i , 125 ) ;
84968: LD_VAR 0 2
84972: PPUSH
84973: LD_INT 125
84975: PPUSH
84976: CALL 67678 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
84980: LD_ADDR_EXP 69
84984: PUSH
84985: LD_EXP 69
84989: PPUSH
84990: LD_VAR 0 2
84994: PPUSH
84995: EMPTY
84996: PPUSH
84997: CALL_OW 1
85001: ST_TO_ADDR
// end ; continue ;
85002: GO 84852
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
85004: LD_EXP 68
85008: PUSH
85009: LD_VAR 0 2
85013: ARRAY
85014: PUSH
85015: LD_INT 1
85017: ARRAY
85018: PUSH
85019: LD_INT 3
85021: ARRAY
85022: PUSH
85023: LD_INT 1
85025: EQUAL
85026: IFFALSE 85052
85028: PUSH
85029: LD_INT 20
85031: PPUSH
85032: LD_EXP 57
85036: PUSH
85037: LD_VAR 0 2
85041: ARRAY
85042: PPUSH
85043: CALL_OW 321
85047: PUSH
85048: LD_INT 2
85050: NONEQUAL
85051: AND
85052: IFFALSE 85102
// begin if mc_deposits_finder [ i ] then
85054: LD_EXP 69
85058: PUSH
85059: LD_VAR 0 2
85063: ARRAY
85064: IFFALSE 85100
// begin MC_Reset ( i , 125 ) ;
85066: LD_VAR 0 2
85070: PPUSH
85071: LD_INT 125
85073: PPUSH
85074: CALL 67678 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
85078: LD_ADDR_EXP 69
85082: PUSH
85083: LD_EXP 69
85087: PPUSH
85088: LD_VAR 0 2
85092: PPUSH
85093: EMPTY
85094: PPUSH
85095: CALL_OW 1
85099: ST_TO_ADDR
// end ; continue ;
85100: GO 84852
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
85102: LD_EXP 68
85106: PUSH
85107: LD_VAR 0 2
85111: ARRAY
85112: PUSH
85113: LD_INT 1
85115: ARRAY
85116: PUSH
85117: LD_INT 1
85119: ARRAY
85120: PPUSH
85121: LD_EXP 68
85125: PUSH
85126: LD_VAR 0 2
85130: ARRAY
85131: PUSH
85132: LD_INT 1
85134: ARRAY
85135: PUSH
85136: LD_INT 2
85138: ARRAY
85139: PPUSH
85140: LD_EXP 57
85144: PUSH
85145: LD_VAR 0 2
85149: ARRAY
85150: PPUSH
85151: CALL_OW 440
85155: IFFALSE 85198
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
85157: LD_ADDR_EXP 68
85161: PUSH
85162: LD_EXP 68
85166: PPUSH
85167: LD_VAR 0 2
85171: PPUSH
85172: LD_EXP 68
85176: PUSH
85177: LD_VAR 0 2
85181: ARRAY
85182: PPUSH
85183: LD_INT 1
85185: PPUSH
85186: CALL_OW 3
85190: PPUSH
85191: CALL_OW 1
85195: ST_TO_ADDR
85196: GO 85447
// begin if not mc_deposits_finder [ i ] then
85198: LD_EXP 69
85202: PUSH
85203: LD_VAR 0 2
85207: ARRAY
85208: NOT
85209: IFFALSE 85261
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
85211: LD_ADDR_EXP 69
85215: PUSH
85216: LD_EXP 69
85220: PPUSH
85221: LD_VAR 0 2
85225: PPUSH
85226: LD_VAR 0 3
85230: PUSH
85231: LD_INT 1
85233: ARRAY
85234: PUSH
85235: EMPTY
85236: LIST
85237: PPUSH
85238: CALL_OW 1
85242: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
85243: LD_VAR 0 3
85247: PUSH
85248: LD_INT 1
85250: ARRAY
85251: PPUSH
85252: LD_INT 125
85254: PPUSH
85255: CALL_OW 109
// end else
85259: GO 85447
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
85261: LD_EXP 69
85265: PUSH
85266: LD_VAR 0 2
85270: ARRAY
85271: PUSH
85272: LD_INT 1
85274: ARRAY
85275: PPUSH
85276: CALL_OW 310
85280: IFFALSE 85303
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
85282: LD_EXP 69
85286: PUSH
85287: LD_VAR 0 2
85291: ARRAY
85292: PUSH
85293: LD_INT 1
85295: ARRAY
85296: PPUSH
85297: CALL_OW 122
85301: GO 85447
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
85303: LD_EXP 69
85307: PUSH
85308: LD_VAR 0 2
85312: ARRAY
85313: PUSH
85314: LD_INT 1
85316: ARRAY
85317: PPUSH
85318: CALL_OW 314
85322: NOT
85323: IFFALSE 85388
85325: PUSH
85326: LD_EXP 69
85330: PUSH
85331: LD_VAR 0 2
85335: ARRAY
85336: PUSH
85337: LD_INT 1
85339: ARRAY
85340: PPUSH
85341: LD_EXP 68
85345: PUSH
85346: LD_VAR 0 2
85350: ARRAY
85351: PUSH
85352: LD_INT 1
85354: ARRAY
85355: PUSH
85356: LD_INT 1
85358: ARRAY
85359: PPUSH
85360: LD_EXP 68
85364: PUSH
85365: LD_VAR 0 2
85369: ARRAY
85370: PUSH
85371: LD_INT 1
85373: ARRAY
85374: PUSH
85375: LD_INT 2
85377: ARRAY
85378: PPUSH
85379: CALL_OW 297
85383: PUSH
85384: LD_INT 6
85386: GREATER
85387: AND
85388: IFFALSE 85447
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
85390: LD_EXP 69
85394: PUSH
85395: LD_VAR 0 2
85399: ARRAY
85400: PUSH
85401: LD_INT 1
85403: ARRAY
85404: PPUSH
85405: LD_EXP 68
85409: PUSH
85410: LD_VAR 0 2
85414: ARRAY
85415: PUSH
85416: LD_INT 1
85418: ARRAY
85419: PUSH
85420: LD_INT 1
85422: ARRAY
85423: PPUSH
85424: LD_EXP 68
85428: PUSH
85429: LD_VAR 0 2
85433: ARRAY
85434: PUSH
85435: LD_INT 1
85437: ARRAY
85438: PUSH
85439: LD_INT 2
85441: ARRAY
85442: PPUSH
85443: CALL_OW 111
// end ; end ; end ;
85447: GO 84852
85449: POP
85450: POP
// end ;
85451: LD_VAR 0 1
85455: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
85456: LD_INT 0
85458: PPUSH
85459: PPUSH
85460: PPUSH
85461: PPUSH
85462: PPUSH
85463: PPUSH
85464: PPUSH
85465: PPUSH
85466: PPUSH
85467: PPUSH
85468: PPUSH
// if not mc_bases then
85469: LD_EXP 31
85473: NOT
85474: IFFALSE 85478
// exit ;
85476: GO 86438
// for i = 1 to mc_bases do
85478: LD_ADDR_VAR 0 2
85482: PUSH
85483: DOUBLE
85484: LD_INT 1
85486: DEC
85487: ST_TO_ADDR
85488: LD_EXP 31
85492: PUSH
85493: FOR_TO
85494: IFFALSE 86436
// begin if not mc_bases [ i ] or mc_scan [ i ] then
85496: LD_EXP 31
85500: PUSH
85501: LD_VAR 0 2
85505: ARRAY
85506: NOT
85507: IFTRUE 85521
85509: PUSH
85510: LD_EXP 54
85514: PUSH
85515: LD_VAR 0 2
85519: ARRAY
85520: OR
85521: IFFALSE 85525
// continue ;
85523: GO 85493
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
85525: LD_ADDR_VAR 0 7
85529: PUSH
85530: LD_EXP 31
85534: PUSH
85535: LD_VAR 0 2
85539: ARRAY
85540: PUSH
85541: LD_INT 1
85543: ARRAY
85544: PPUSH
85545: CALL_OW 248
85549: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
85550: LD_VAR 0 7
85554: PUSH
85555: LD_INT 3
85557: EQUAL
85558: IFTRUE 85600
85560: PUSH
85561: LD_EXP 50
85565: PUSH
85566: LD_VAR 0 2
85570: ARRAY
85571: PUSH
85572: LD_EXP 53
85576: PUSH
85577: LD_VAR 0 2
85581: ARRAY
85582: UNION
85583: PPUSH
85584: LD_INT 33
85586: PUSH
85587: LD_INT 2
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PPUSH
85594: CALL_OW 72
85598: NOT
85599: OR
85600: IFFALSE 85604
// continue ;
85602: GO 85493
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
85604: LD_ADDR_VAR 0 9
85608: PUSH
85609: LD_EXP 31
85613: PUSH
85614: LD_VAR 0 2
85618: ARRAY
85619: PPUSH
85620: LD_INT 30
85622: PUSH
85623: LD_INT 36
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PPUSH
85630: CALL_OW 72
85634: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
85635: LD_ADDR_VAR 0 10
85639: PUSH
85640: LD_EXP 50
85644: PUSH
85645: LD_VAR 0 2
85649: ARRAY
85650: PPUSH
85651: LD_INT 34
85653: PUSH
85654: LD_INT 31
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PPUSH
85661: CALL_OW 72
85665: ST_TO_ADDR
// if not cts and not mcts then
85666: LD_VAR 0 9
85670: NOT
85671: IFFALSE 85680
85673: PUSH
85674: LD_VAR 0 10
85678: NOT
85679: AND
85680: IFFALSE 85684
// continue ;
85682: GO 85493
// x := cts ;
85684: LD_ADDR_VAR 0 11
85688: PUSH
85689: LD_VAR 0 9
85693: ST_TO_ADDR
// if not x then
85694: LD_VAR 0 11
85698: NOT
85699: IFFALSE 85711
// x := mcts ;
85701: LD_ADDR_VAR 0 11
85705: PUSH
85706: LD_VAR 0 10
85710: ST_TO_ADDR
// if not x then
85711: LD_VAR 0 11
85715: NOT
85716: IFFALSE 85720
// continue ;
85718: GO 85493
// if mc_remote_driver [ i ] then
85720: LD_EXP 71
85724: PUSH
85725: LD_VAR 0 2
85729: ARRAY
85730: IFFALSE 86129
// for j in mc_remote_driver [ i ] do
85732: LD_ADDR_VAR 0 3
85736: PUSH
85737: LD_EXP 71
85741: PUSH
85742: LD_VAR 0 2
85746: ARRAY
85747: PUSH
85748: FOR_IN
85749: IFFALSE 86127
// begin if GetClass ( j ) <> 3 then
85751: LD_VAR 0 3
85755: PPUSH
85756: CALL_OW 257
85760: PUSH
85761: LD_INT 3
85763: NONEQUAL
85764: IFFALSE 85817
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
85766: LD_ADDR_EXP 71
85770: PUSH
85771: LD_EXP 71
85775: PPUSH
85776: LD_VAR 0 2
85780: PPUSH
85781: LD_EXP 71
85785: PUSH
85786: LD_VAR 0 2
85790: ARRAY
85791: PUSH
85792: LD_VAR 0 3
85796: DIFF
85797: PPUSH
85798: CALL_OW 1
85802: ST_TO_ADDR
// SetTag ( j , 0 ) ;
85803: LD_VAR 0 3
85807: PPUSH
85808: LD_INT 0
85810: PPUSH
85811: CALL_OW 109
// continue ;
85815: GO 85748
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
85817: LD_EXP 50
85821: PUSH
85822: LD_VAR 0 2
85826: ARRAY
85827: PPUSH
85828: LD_INT 34
85830: PUSH
85831: LD_INT 31
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 58
85840: PUSH
85841: EMPTY
85842: LIST
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PPUSH
85848: CALL_OW 72
85852: IFFALSE 85866
85854: PUSH
85855: LD_VAR 0 3
85859: PPUSH
85860: CALL 55735 0 1
85864: NOT
85865: AND
85866: IFFALSE 85937
// begin if IsInUnit ( j ) then
85868: LD_VAR 0 3
85872: PPUSH
85873: CALL_OW 310
85877: IFFALSE 85888
// ComExitBuilding ( j ) ;
85879: LD_VAR 0 3
85883: PPUSH
85884: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
85888: LD_VAR 0 3
85892: PPUSH
85893: LD_EXP 50
85897: PUSH
85898: LD_VAR 0 2
85902: ARRAY
85903: PPUSH
85904: LD_INT 34
85906: PUSH
85907: LD_INT 31
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 58
85916: PUSH
85917: EMPTY
85918: LIST
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PPUSH
85924: CALL_OW 72
85928: PUSH
85929: LD_INT 1
85931: ARRAY
85932: PPUSH
85933: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
85937: LD_VAR 0 3
85941: PPUSH
85942: CALL_OW 310
85946: NOT
85947: IFTRUE 85983
85949: PUSH
85950: LD_VAR 0 3
85954: PPUSH
85955: CALL_OW 310
85959: PPUSH
85960: CALL_OW 266
85964: PUSH
85965: LD_INT 36
85967: NONEQUAL
85968: IFFALSE 85982
85970: PUSH
85971: LD_VAR 0 3
85975: PPUSH
85976: CALL 55735 0 1
85980: NOT
85981: AND
85982: OR
85983: IFFALSE 86125
// begin if IsInUnit ( j ) then
85985: LD_VAR 0 3
85989: PPUSH
85990: CALL_OW 310
85994: IFFALSE 86005
// ComExitBuilding ( j ) ;
85996: LD_VAR 0 3
86000: PPUSH
86001: CALL_OW 122
// ct := 0 ;
86005: LD_ADDR_VAR 0 8
86009: PUSH
86010: LD_INT 0
86012: ST_TO_ADDR
// for k in x do
86013: LD_ADDR_VAR 0 4
86017: PUSH
86018: LD_VAR 0 11
86022: PUSH
86023: FOR_IN
86024: IFFALSE 86103
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
86026: LD_VAR 0 4
86030: PPUSH
86031: CALL_OW 264
86035: PUSH
86036: LD_INT 31
86038: EQUAL
86039: IFFALSE 86053
86041: PUSH
86042: LD_VAR 0 4
86046: PPUSH
86047: CALL_OW 311
86051: NOT
86052: AND
86053: IFTRUE 86087
86055: PUSH
86056: LD_VAR 0 4
86060: PPUSH
86061: CALL_OW 266
86065: PUSH
86066: LD_INT 36
86068: EQUAL
86069: IFFALSE 86086
86071: PUSH
86072: LD_VAR 0 4
86076: PPUSH
86077: CALL_OW 313
86081: PUSH
86082: LD_INT 3
86084: LESS
86085: AND
86086: OR
86087: IFFALSE 86101
// begin ct := k ;
86089: LD_ADDR_VAR 0 8
86093: PUSH
86094: LD_VAR 0 4
86098: ST_TO_ADDR
// break ;
86099: GO 86103
// end ;
86101: GO 86023
86103: POP
86104: POP
// if ct then
86105: LD_VAR 0 8
86109: IFFALSE 86125
// ComEnterUnit ( j , ct ) ;
86111: LD_VAR 0 3
86115: PPUSH
86116: LD_VAR 0 8
86120: PPUSH
86121: CALL_OW 120
// end ; end ;
86125: GO 85748
86127: POP
86128: POP
// places := 0 ;
86129: LD_ADDR_VAR 0 5
86133: PUSH
86134: LD_INT 0
86136: ST_TO_ADDR
// for j = 1 to x do
86137: LD_ADDR_VAR 0 3
86141: PUSH
86142: DOUBLE
86143: LD_INT 1
86145: DEC
86146: ST_TO_ADDR
86147: LD_VAR 0 11
86151: PUSH
86152: FOR_TO
86153: IFFALSE 86229
// if GetWeapon ( x [ j ] ) = ar_control_tower then
86155: LD_VAR 0 11
86159: PUSH
86160: LD_VAR 0 3
86164: ARRAY
86165: PPUSH
86166: CALL_OW 264
86170: PUSH
86171: LD_INT 31
86173: EQUAL
86174: IFFALSE 86192
// places := places + 1 else
86176: LD_ADDR_VAR 0 5
86180: PUSH
86181: LD_VAR 0 5
86185: PUSH
86186: LD_INT 1
86188: PLUS
86189: ST_TO_ADDR
86190: GO 86227
// if GetBType ( x [ j ] ) = b_control_tower then
86192: LD_VAR 0 11
86196: PUSH
86197: LD_VAR 0 3
86201: ARRAY
86202: PPUSH
86203: CALL_OW 266
86207: PUSH
86208: LD_INT 36
86210: EQUAL
86211: IFFALSE 86227
// places := places + 3 ;
86213: LD_ADDR_VAR 0 5
86217: PUSH
86218: LD_VAR 0 5
86222: PUSH
86223: LD_INT 3
86225: PLUS
86226: ST_TO_ADDR
86227: GO 86152
86229: POP
86230: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
86231: LD_VAR 0 5
86235: PUSH
86236: LD_INT 0
86238: EQUAL
86239: IFTRUE 86259
86241: PUSH
86242: LD_VAR 0 5
86246: PUSH
86247: LD_EXP 71
86251: PUSH
86252: LD_VAR 0 2
86256: ARRAY
86257: LESSEQUAL
86258: OR
86259: IFFALSE 86263
// continue ;
86261: GO 85493
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
86263: LD_ADDR_VAR 0 6
86267: PUSH
86268: LD_EXP 31
86272: PUSH
86273: LD_VAR 0 2
86277: ARRAY
86278: PPUSH
86279: LD_INT 25
86281: PUSH
86282: LD_INT 3
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PPUSH
86289: CALL_OW 72
86293: PUSH
86294: LD_EXP 71
86298: PUSH
86299: LD_VAR 0 2
86303: ARRAY
86304: DIFF
86305: PPUSH
86306: LD_INT 3
86308: PPUSH
86309: CALL 56635 0 2
86313: ST_TO_ADDR
// for j in tmp do
86314: LD_ADDR_VAR 0 3
86318: PUSH
86319: LD_VAR 0 6
86323: PUSH
86324: FOR_IN
86325: IFFALSE 86360
// if GetTag ( j ) > 0 then
86327: LD_VAR 0 3
86331: PPUSH
86332: CALL_OW 110
86336: PUSH
86337: LD_INT 0
86339: GREATER
86340: IFFALSE 86358
// tmp := tmp diff j ;
86342: LD_ADDR_VAR 0 6
86346: PUSH
86347: LD_VAR 0 6
86351: PUSH
86352: LD_VAR 0 3
86356: DIFF
86357: ST_TO_ADDR
86358: GO 86324
86360: POP
86361: POP
// if not tmp then
86362: LD_VAR 0 6
86366: NOT
86367: IFFALSE 86371
// continue ;
86369: GO 85493
// if places then
86371: LD_VAR 0 5
86375: IFFALSE 86434
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
86377: LD_ADDR_EXP 71
86381: PUSH
86382: LD_EXP 71
86386: PPUSH
86387: LD_VAR 0 2
86391: PPUSH
86392: LD_EXP 71
86396: PUSH
86397: LD_VAR 0 2
86401: ARRAY
86402: PUSH
86403: LD_VAR 0 6
86407: PUSH
86408: LD_INT 1
86410: ARRAY
86411: UNION
86412: PPUSH
86413: CALL_OW 1
86417: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
86418: LD_VAR 0 6
86422: PUSH
86423: LD_INT 1
86425: ARRAY
86426: PPUSH
86427: LD_INT 126
86429: PPUSH
86430: CALL_OW 109
// end ; end ;
86434: GO 85493
86436: POP
86437: POP
// end ;
86438: LD_VAR 0 1
86442: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
86443: LD_INT 0
86445: PPUSH
86446: PPUSH
86447: PPUSH
86448: PPUSH
86449: PPUSH
86450: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
86451: LD_VAR 0 1
86455: NOT
86456: IFTRUE 86465
86458: PUSH
86459: LD_VAR 0 2
86463: NOT
86464: OR
86465: IFTRUE 86474
86467: PUSH
86468: LD_VAR 0 3
86472: NOT
86473: OR
86474: IFTRUE 86522
86476: PUSH
86477: LD_VAR 0 4
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: LD_INT 2
86487: PUSH
86488: LD_INT 3
86490: PUSH
86491: LD_INT 4
86493: PUSH
86494: LD_INT 5
86496: PUSH
86497: LD_INT 8
86499: PUSH
86500: LD_INT 9
86502: PUSH
86503: LD_INT 15
86505: PUSH
86506: LD_INT 16
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: IN
86520: NOT
86521: OR
86522: IFFALSE 86526
// exit ;
86524: GO 87386
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
86526: LD_ADDR_VAR 0 2
86530: PUSH
86531: LD_VAR 0 2
86535: PPUSH
86536: LD_INT 21
86538: PUSH
86539: LD_INT 3
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: PUSH
86546: LD_INT 24
86548: PUSH
86549: LD_INT 250
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PPUSH
86560: CALL_OW 72
86564: ST_TO_ADDR
// case class of 1 , 15 :
86565: LD_VAR 0 4
86569: PUSH
86570: LD_INT 1
86572: DOUBLE
86573: EQUAL
86574: IFTRUE 86584
86576: LD_INT 15
86578: DOUBLE
86579: EQUAL
86580: IFTRUE 86584
86582: GO 86669
86584: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
86585: LD_ADDR_VAR 0 8
86589: PUSH
86590: LD_VAR 0 2
86594: PPUSH
86595: LD_INT 2
86597: PUSH
86598: LD_INT 30
86600: PUSH
86601: LD_INT 32
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 30
86610: PUSH
86611: LD_INT 31
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: LIST
86622: PPUSH
86623: CALL_OW 72
86627: PUSH
86628: LD_VAR 0 2
86632: PPUSH
86633: LD_INT 2
86635: PUSH
86636: LD_INT 30
86638: PUSH
86639: LD_INT 4
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 30
86648: PUSH
86649: LD_INT 5
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: LIST
86660: PPUSH
86661: CALL_OW 72
86665: ADD
86666: ST_TO_ADDR
86667: GO 86915
86669: LD_INT 2
86671: DOUBLE
86672: EQUAL
86673: IFTRUE 86683
86675: LD_INT 16
86677: DOUBLE
86678: EQUAL
86679: IFTRUE 86683
86681: GO 86729
86683: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
86684: LD_ADDR_VAR 0 8
86688: PUSH
86689: LD_VAR 0 2
86693: PPUSH
86694: LD_INT 2
86696: PUSH
86697: LD_INT 30
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 30
86709: PUSH
86710: LD_INT 1
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: LIST
86721: PPUSH
86722: CALL_OW 72
86726: ST_TO_ADDR
86727: GO 86915
86729: LD_INT 3
86731: DOUBLE
86732: EQUAL
86733: IFTRUE 86737
86735: GO 86783
86737: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
86738: LD_ADDR_VAR 0 8
86742: PUSH
86743: LD_VAR 0 2
86747: PPUSH
86748: LD_INT 2
86750: PUSH
86751: LD_INT 30
86753: PUSH
86754: LD_INT 2
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 30
86763: PUSH
86764: LD_INT 3
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: LIST
86775: PPUSH
86776: CALL_OW 72
86780: ST_TO_ADDR
86781: GO 86915
86783: LD_INT 4
86785: DOUBLE
86786: EQUAL
86787: IFTRUE 86791
86789: GO 86848
86791: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
86792: LD_ADDR_VAR 0 8
86796: PUSH
86797: LD_VAR 0 2
86801: PPUSH
86802: LD_INT 2
86804: PUSH
86805: LD_INT 30
86807: PUSH
86808: LD_INT 6
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 30
86817: PUSH
86818: LD_INT 7
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 30
86827: PUSH
86828: LD_INT 8
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: PPUSH
86841: CALL_OW 72
86845: ST_TO_ADDR
86846: GO 86915
86848: LD_INT 5
86850: DOUBLE
86851: EQUAL
86852: IFTRUE 86868
86854: LD_INT 8
86856: DOUBLE
86857: EQUAL
86858: IFTRUE 86868
86860: LD_INT 9
86862: DOUBLE
86863: EQUAL
86864: IFTRUE 86868
86866: GO 86914
86868: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
86869: LD_ADDR_VAR 0 8
86873: PUSH
86874: LD_VAR 0 2
86878: PPUSH
86879: LD_INT 2
86881: PUSH
86882: LD_INT 30
86884: PUSH
86885: LD_INT 4
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 30
86894: PUSH
86895: LD_INT 5
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: LIST
86906: PPUSH
86907: CALL_OW 72
86911: ST_TO_ADDR
86912: GO 86915
86914: POP
// if not tmp then
86915: LD_VAR 0 8
86919: NOT
86920: IFFALSE 86924
// exit ;
86922: GO 87386
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
86924: LD_VAR 0 4
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: LD_INT 15
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: IN
86939: IFFALSE 86953
86941: PUSH
86942: LD_EXP 40
86946: PUSH
86947: LD_VAR 0 1
86951: ARRAY
86952: AND
86953: IFFALSE 87109
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
86955: LD_ADDR_VAR 0 9
86959: PUSH
86960: LD_EXP 40
86964: PUSH
86965: LD_VAR 0 1
86969: ARRAY
86970: PUSH
86971: LD_INT 1
86973: ARRAY
86974: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
86975: LD_VAR 0 9
86979: PUSH
86980: LD_EXP 41
86984: PUSH
86985: LD_VAR 0 1
86989: ARRAY
86990: IN
86991: NOT
86992: IFFALSE 87107
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
86994: LD_ADDR_EXP 41
86998: PUSH
86999: LD_EXP 41
87003: PPUSH
87004: LD_VAR 0 1
87008: PUSH
87009: LD_EXP 41
87013: PUSH
87014: LD_VAR 0 1
87018: ARRAY
87019: PUSH
87020: LD_INT 1
87022: PLUS
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PPUSH
87028: LD_VAR 0 9
87032: PPUSH
87033: CALL 25097 0 3
87037: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
87038: LD_ADDR_EXP 40
87042: PUSH
87043: LD_EXP 40
87047: PPUSH
87048: LD_VAR 0 1
87052: PPUSH
87053: LD_EXP 40
87057: PUSH
87058: LD_VAR 0 1
87062: ARRAY
87063: PUSH
87064: LD_VAR 0 9
87068: DIFF
87069: PPUSH
87070: CALL_OW 1
87074: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
87075: LD_VAR 0 3
87079: PPUSH
87080: LD_EXP 41
87084: PUSH
87085: LD_VAR 0 1
87089: ARRAY
87090: PUSH
87091: LD_EXP 41
87095: PUSH
87096: LD_VAR 0 1
87100: ARRAY
87101: ARRAY
87102: PPUSH
87103: CALL_OW 120
// end ; exit ;
87107: GO 87386
// end ; if tmp > 1 then
87109: LD_VAR 0 8
87113: PUSH
87114: LD_INT 1
87116: GREATER
87117: IFFALSE 87221
// for i = 2 to tmp do
87119: LD_ADDR_VAR 0 6
87123: PUSH
87124: DOUBLE
87125: LD_INT 2
87127: DEC
87128: ST_TO_ADDR
87129: LD_VAR 0 8
87133: PUSH
87134: FOR_TO
87135: IFFALSE 87219
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
87137: LD_VAR 0 8
87141: PUSH
87142: LD_VAR 0 6
87146: ARRAY
87147: PPUSH
87148: CALL_OW 461
87152: PUSH
87153: LD_INT 6
87155: EQUAL
87156: IFFALSE 87217
// begin x := tmp [ i ] ;
87158: LD_ADDR_VAR 0 9
87162: PUSH
87163: LD_VAR 0 8
87167: PUSH
87168: LD_VAR 0 6
87172: ARRAY
87173: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
87174: LD_ADDR_VAR 0 8
87178: PUSH
87179: LD_VAR 0 8
87183: PPUSH
87184: LD_VAR 0 6
87188: PPUSH
87189: CALL_OW 3
87193: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
87194: LD_ADDR_VAR 0 8
87198: PUSH
87199: LD_VAR 0 8
87203: PPUSH
87204: LD_INT 1
87206: PPUSH
87207: LD_VAR 0 9
87211: PPUSH
87212: CALL_OW 2
87216: ST_TO_ADDR
// end ;
87217: GO 87134
87219: POP
87220: POP
// for i in tmp do
87221: LD_ADDR_VAR 0 6
87225: PUSH
87226: LD_VAR 0 8
87230: PUSH
87231: FOR_IN
87232: IFFALSE 87259
// begin if IsNotFull ( i ) then
87234: LD_VAR 0 6
87238: PPUSH
87239: CALL 22261 0 1
87243: IFFALSE 87257
// begin j := i ;
87245: LD_ADDR_VAR 0 7
87249: PUSH
87250: LD_VAR 0 6
87254: ST_TO_ADDR
// break ;
87255: GO 87259
// end ; end ;
87257: GO 87231
87259: POP
87260: POP
// if j then
87261: LD_VAR 0 7
87265: IFFALSE 87283
// ComEnterUnit ( unit , j ) else
87267: LD_VAR 0 3
87271: PPUSH
87272: LD_VAR 0 7
87276: PPUSH
87277: CALL_OW 120
87281: GO 87386
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87283: LD_ADDR_VAR 0 10
87287: PUSH
87288: LD_VAR 0 2
87292: PPUSH
87293: LD_INT 2
87295: PUSH
87296: LD_INT 30
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 30
87308: PUSH
87309: LD_INT 1
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: LIST
87320: PPUSH
87321: CALL_OW 72
87325: ST_TO_ADDR
// if depot then
87326: LD_VAR 0 10
87330: IFFALSE 87386
// begin depot := NearestUnitToUnit ( depot , unit ) ;
87332: LD_ADDR_VAR 0 10
87336: PUSH
87337: LD_VAR 0 10
87341: PPUSH
87342: LD_VAR 0 3
87346: PPUSH
87347: CALL_OW 74
87351: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
87352: LD_VAR 0 3
87356: PPUSH
87357: LD_VAR 0 10
87361: PPUSH
87362: CALL_OW 296
87366: PUSH
87367: LD_INT 10
87369: GREATER
87370: IFFALSE 87386
// ComStandNearbyBuilding ( unit , depot ) ;
87372: LD_VAR 0 3
87376: PPUSH
87377: LD_VAR 0 10
87381: PPUSH
87382: CALL 21639 0 2
// end ; end ; end ;
87386: LD_VAR 0 5
87390: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
87391: LD_INT 0
87393: PPUSH
87394: PPUSH
87395: PPUSH
87396: PPUSH
// if not mc_bases then
87397: LD_EXP 31
87401: NOT
87402: IFFALSE 87406
// exit ;
87404: GO 87657
// for i = 1 to mc_bases do
87406: LD_ADDR_VAR 0 2
87410: PUSH
87411: DOUBLE
87412: LD_INT 1
87414: DEC
87415: ST_TO_ADDR
87416: LD_EXP 31
87420: PUSH
87421: FOR_TO
87422: IFFALSE 87655
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
87424: LD_ADDR_VAR 0 4
87428: PUSH
87429: LD_EXP 31
87433: PUSH
87434: LD_VAR 0 2
87438: ARRAY
87439: PPUSH
87440: LD_INT 21
87442: PUSH
87443: LD_INT 1
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PPUSH
87450: CALL_OW 72
87454: PUSH
87455: LD_EXP 60
87459: PUSH
87460: LD_VAR 0 2
87464: ARRAY
87465: UNION
87466: ST_TO_ADDR
// if not tmp then
87467: LD_VAR 0 4
87471: NOT
87472: IFFALSE 87476
// continue ;
87474: GO 87421
// for j in tmp do
87476: LD_ADDR_VAR 0 3
87480: PUSH
87481: LD_VAR 0 4
87485: PUSH
87486: FOR_IN
87487: IFFALSE 87651
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
87489: LD_VAR 0 3
87493: PPUSH
87494: CALL_OW 110
87498: NOT
87499: IFFALSE 87513
87501: PUSH
87502: LD_VAR 0 3
87506: PPUSH
87507: CALL_OW 314
87511: NOT
87512: AND
87513: IFFALSE 87527
87515: PUSH
87516: LD_VAR 0 3
87520: PPUSH
87521: CALL_OW 311
87525: NOT
87526: AND
87527: IFFALSE 87541
87529: PUSH
87530: LD_VAR 0 3
87534: PPUSH
87535: CALL_OW 310
87539: NOT
87540: AND
87541: IFFALSE 87566
87543: PUSH
87544: LD_VAR 0 3
87548: PUSH
87549: LD_EXP 34
87553: PUSH
87554: LD_VAR 0 2
87558: ARRAY
87559: PUSH
87560: LD_INT 1
87562: ARRAY
87563: IN
87564: NOT
87565: AND
87566: IFFALSE 87591
87568: PUSH
87569: LD_VAR 0 3
87573: PUSH
87574: LD_EXP 34
87578: PUSH
87579: LD_VAR 0 2
87583: ARRAY
87584: PUSH
87585: LD_INT 2
87587: ARRAY
87588: IN
87589: NOT
87590: AND
87591: IFFALSE 87612
87593: PUSH
87594: LD_VAR 0 3
87598: PUSH
87599: LD_EXP 43
87603: PUSH
87604: LD_VAR 0 2
87608: ARRAY
87609: IN
87610: NOT
87611: AND
87612: IFFALSE 87649
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
87614: LD_VAR 0 2
87618: PPUSH
87619: LD_EXP 31
87623: PUSH
87624: LD_VAR 0 2
87628: ARRAY
87629: PPUSH
87630: LD_VAR 0 3
87634: PPUSH
87635: LD_VAR 0 3
87639: PPUSH
87640: CALL_OW 257
87644: PPUSH
87645: CALL 86443 0 4
// end ;
87649: GO 87486
87651: POP
87652: POP
// end ;
87653: GO 87421
87655: POP
87656: POP
// end ;
87657: LD_VAR 0 1
87661: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
87662: LD_INT 0
87664: PPUSH
87665: PPUSH
87666: PPUSH
87667: PPUSH
87668: PPUSH
87669: PPUSH
// if not mc_bases [ base ] then
87670: LD_EXP 31
87674: PUSH
87675: LD_VAR 0 1
87679: ARRAY
87680: NOT
87681: IFFALSE 87685
// exit ;
87683: GO 87886
// tmp := [ ] ;
87685: LD_ADDR_VAR 0 6
87689: PUSH
87690: EMPTY
87691: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
87692: LD_ADDR_VAR 0 7
87696: PUSH
87697: LD_VAR 0 3
87701: PPUSH
87702: LD_INT 0
87704: PPUSH
87705: CALL_OW 517
87709: ST_TO_ADDR
// if not list then
87710: LD_VAR 0 7
87714: NOT
87715: IFFALSE 87719
// exit ;
87717: GO 87886
// c := Count ( list [ 1 ] ) ;
87719: LD_ADDR_VAR 0 9
87723: PUSH
87724: LD_VAR 0 7
87728: PUSH
87729: LD_INT 1
87731: ARRAY
87732: PPUSH
87733: CALL 22179 0 1
87737: ST_TO_ADDR
// if amount > c then
87738: LD_VAR 0 2
87742: PUSH
87743: LD_VAR 0 9
87747: GREATER
87748: IFFALSE 87760
// amount := c ;
87750: LD_ADDR_VAR 0 2
87754: PUSH
87755: LD_VAR 0 9
87759: ST_TO_ADDR
// for i := 1 to amount do
87760: LD_ADDR_VAR 0 5
87764: PUSH
87765: DOUBLE
87766: LD_INT 1
87768: DEC
87769: ST_TO_ADDR
87770: LD_VAR 0 2
87774: PUSH
87775: FOR_TO
87776: IFFALSE 87834
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
87778: LD_ADDR_VAR 0 6
87782: PUSH
87783: LD_VAR 0 6
87787: PPUSH
87788: LD_VAR 0 5
87792: PPUSH
87793: LD_VAR 0 7
87797: PUSH
87798: LD_INT 1
87800: ARRAY
87801: PUSH
87802: LD_VAR 0 5
87806: ARRAY
87807: PUSH
87808: LD_VAR 0 7
87812: PUSH
87813: LD_INT 2
87815: ARRAY
87816: PUSH
87817: LD_VAR 0 5
87821: ARRAY
87822: PUSH
87823: EMPTY
87824: LIST
87825: LIST
87826: PPUSH
87827: CALL_OW 1
87831: ST_TO_ADDR
87832: GO 87775
87834: POP
87835: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
87836: LD_ADDR_EXP 44
87840: PUSH
87841: LD_EXP 44
87845: PPUSH
87846: LD_VAR 0 1
87850: PPUSH
87851: LD_VAR 0 6
87855: PPUSH
87856: CALL_OW 1
87860: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
87861: LD_ADDR_EXP 46
87865: PUSH
87866: LD_EXP 46
87870: PPUSH
87871: LD_VAR 0 1
87875: PPUSH
87876: LD_VAR 0 3
87880: PPUSH
87881: CALL_OW 1
87885: ST_TO_ADDR
// end ;
87886: LD_VAR 0 4
87890: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
87891: LD_INT 0
87893: PPUSH
// if not mc_bases [ base ] then
87894: LD_EXP 31
87898: PUSH
87899: LD_VAR 0 1
87903: ARRAY
87904: NOT
87905: IFFALSE 87909
// exit ;
87907: GO 87934
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
87909: LD_ADDR_EXP 36
87913: PUSH
87914: LD_EXP 36
87918: PPUSH
87919: LD_VAR 0 1
87923: PPUSH
87924: LD_VAR 0 2
87928: PPUSH
87929: CALL_OW 1
87933: ST_TO_ADDR
// end ;
87934: LD_VAR 0 3
87938: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
87939: LD_INT 0
87941: PPUSH
// if not mc_bases [ base ] then
87942: LD_EXP 31
87946: PUSH
87947: LD_VAR 0 1
87951: ARRAY
87952: NOT
87953: IFFALSE 87957
// exit ;
87955: GO 87994
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
87957: LD_ADDR_EXP 36
87961: PUSH
87962: LD_EXP 36
87966: PPUSH
87967: LD_VAR 0 1
87971: PPUSH
87972: LD_EXP 36
87976: PUSH
87977: LD_VAR 0 1
87981: ARRAY
87982: PUSH
87983: LD_VAR 0 2
87987: UNION
87988: PPUSH
87989: CALL_OW 1
87993: ST_TO_ADDR
// end ;
87994: LD_VAR 0 3
87998: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
87999: LD_INT 0
88001: PPUSH
// if not mc_bases [ base ] then
88002: LD_EXP 31
88006: PUSH
88007: LD_VAR 0 1
88011: ARRAY
88012: NOT
88013: IFFALSE 88017
// exit ;
88015: GO 88042
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
88017: LD_ADDR_EXP 52
88021: PUSH
88022: LD_EXP 52
88026: PPUSH
88027: LD_VAR 0 1
88031: PPUSH
88032: LD_VAR 0 2
88036: PPUSH
88037: CALL_OW 1
88041: ST_TO_ADDR
// end ;
88042: LD_VAR 0 3
88046: RET
// export function MC_InsertProduceList ( base , components ) ; begin
88047: LD_INT 0
88049: PPUSH
// if not mc_bases [ base ] then
88050: LD_EXP 31
88054: PUSH
88055: LD_VAR 0 1
88059: ARRAY
88060: NOT
88061: IFFALSE 88065
// exit ;
88063: GO 88102
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
88065: LD_ADDR_EXP 52
88069: PUSH
88070: LD_EXP 52
88074: PPUSH
88075: LD_VAR 0 1
88079: PPUSH
88080: LD_EXP 52
88084: PUSH
88085: LD_VAR 0 1
88089: ARRAY
88090: PUSH
88091: LD_VAR 0 2
88095: ADD
88096: PPUSH
88097: CALL_OW 1
88101: ST_TO_ADDR
// end ;
88102: LD_VAR 0 3
88106: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
88107: LD_INT 0
88109: PPUSH
// if not mc_bases [ base ] then
88110: LD_EXP 31
88114: PUSH
88115: LD_VAR 0 1
88119: ARRAY
88120: NOT
88121: IFFALSE 88125
// exit ;
88123: GO 88179
// mc_defender := Replace ( mc_defender , base , deflist ) ;
88125: LD_ADDR_EXP 53
88129: PUSH
88130: LD_EXP 53
88134: PPUSH
88135: LD_VAR 0 1
88139: PPUSH
88140: LD_VAR 0 2
88144: PPUSH
88145: CALL_OW 1
88149: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
88150: LD_ADDR_EXP 42
88154: PUSH
88155: LD_EXP 42
88159: PPUSH
88160: LD_VAR 0 1
88164: PPUSH
88165: LD_VAR 0 2
88169: PUSH
88170: LD_INT 0
88172: PLUS
88173: PPUSH
88174: CALL_OW 1
88178: ST_TO_ADDR
// end ;
88179: LD_VAR 0 3
88183: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
88184: LD_INT 0
88186: PPUSH
// if not mc_bases [ base ] then
88187: LD_EXP 31
88191: PUSH
88192: LD_VAR 0 1
88196: ARRAY
88197: NOT
88198: IFFALSE 88202
// exit ;
88200: GO 88227
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
88202: LD_ADDR_EXP 42
88206: PUSH
88207: LD_EXP 42
88211: PPUSH
88212: LD_VAR 0 1
88216: PPUSH
88217: LD_VAR 0 2
88221: PPUSH
88222: CALL_OW 1
88226: ST_TO_ADDR
// end ;
88227: LD_VAR 0 3
88231: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
88232: LD_INT 0
88234: PPUSH
88235: PPUSH
88236: PPUSH
88237: PPUSH
// if not mc_bases [ base ] then
88238: LD_EXP 31
88242: PUSH
88243: LD_VAR 0 1
88247: ARRAY
88248: NOT
88249: IFFALSE 88253
// exit ;
88251: GO 88318
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
88253: LD_ADDR_EXP 51
88257: PUSH
88258: LD_EXP 51
88262: PPUSH
88263: LD_VAR 0 1
88267: PUSH
88268: LD_EXP 51
88272: PUSH
88273: LD_VAR 0 1
88277: ARRAY
88278: PUSH
88279: LD_INT 1
88281: PLUS
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PPUSH
88287: LD_VAR 0 1
88291: PUSH
88292: LD_VAR 0 2
88296: PUSH
88297: LD_VAR 0 3
88301: PUSH
88302: LD_VAR 0 4
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: PPUSH
88313: CALL 25097 0 3
88317: ST_TO_ADDR
// end ;
88318: LD_VAR 0 5
88322: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
88323: LD_INT 0
88325: PPUSH
// if not mc_bases [ base ] then
88326: LD_EXP 31
88330: PUSH
88331: LD_VAR 0 1
88335: ARRAY
88336: NOT
88337: IFFALSE 88341
// exit ;
88339: GO 88366
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
88341: LD_ADDR_EXP 68
88345: PUSH
88346: LD_EXP 68
88350: PPUSH
88351: LD_VAR 0 1
88355: PPUSH
88356: LD_VAR 0 2
88360: PPUSH
88361: CALL_OW 1
88365: ST_TO_ADDR
// end ;
88366: LD_VAR 0 3
88370: RET
// export function MC_GetMinesField ( base ) ; begin
88371: LD_INT 0
88373: PPUSH
// result := mc_mines [ base ] ;
88374: LD_ADDR_VAR 0 2
88378: PUSH
88379: LD_EXP 44
88383: PUSH
88384: LD_VAR 0 1
88388: ARRAY
88389: ST_TO_ADDR
// end ;
88390: LD_VAR 0 2
88394: RET
// export function MC_GetProduceList ( base ) ; begin
88395: LD_INT 0
88397: PPUSH
// result := mc_produce [ base ] ;
88398: LD_ADDR_VAR 0 2
88402: PUSH
88403: LD_EXP 52
88407: PUSH
88408: LD_VAR 0 1
88412: ARRAY
88413: ST_TO_ADDR
// end ;
88414: LD_VAR 0 2
88418: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
88419: LD_INT 0
88421: PPUSH
88422: PPUSH
// if not mc_bases then
88423: LD_EXP 31
88427: NOT
88428: IFFALSE 88432
// exit ;
88430: GO 88497
// if mc_bases [ base ] then
88432: LD_EXP 31
88436: PUSH
88437: LD_VAR 0 1
88441: ARRAY
88442: IFFALSE 88497
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
88444: LD_ADDR_VAR 0 3
88448: PUSH
88449: LD_EXP 31
88453: PUSH
88454: LD_VAR 0 1
88458: ARRAY
88459: PPUSH
88460: LD_INT 30
88462: PUSH
88463: LD_VAR 0 2
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PPUSH
88472: CALL_OW 72
88476: ST_TO_ADDR
// if result then
88477: LD_VAR 0 3
88481: IFFALSE 88497
// result := result [ 1 ] ;
88483: LD_ADDR_VAR 0 3
88487: PUSH
88488: LD_VAR 0 3
88492: PUSH
88493: LD_INT 1
88495: ARRAY
88496: ST_TO_ADDR
// end ; end ;
88497: LD_VAR 0 3
88501: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
88502: LD_INT 0
88504: PPUSH
88505: PPUSH
// if not mc_bases then
88506: LD_EXP 31
88510: NOT
88511: IFFALSE 88515
// exit ;
88513: GO 88560
// if mc_bases [ base ] then
88515: LD_EXP 31
88519: PUSH
88520: LD_VAR 0 1
88524: ARRAY
88525: IFFALSE 88560
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
88527: LD_ADDR_VAR 0 3
88531: PUSH
88532: LD_EXP 31
88536: PUSH
88537: LD_VAR 0 1
88541: ARRAY
88542: PPUSH
88543: LD_INT 30
88545: PUSH
88546: LD_VAR 0 2
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PPUSH
88555: CALL_OW 72
88559: ST_TO_ADDR
// end ;
88560: LD_VAR 0 3
88564: RET
// export function MC_SetTame ( base , area ) ; begin
88565: LD_INT 0
88567: PPUSH
// if not mc_bases or not base then
88568: LD_EXP 31
88572: NOT
88573: IFTRUE 88582
88575: PUSH
88576: LD_VAR 0 1
88580: NOT
88581: OR
88582: IFFALSE 88586
// exit ;
88584: GO 88611
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
88586: LD_ADDR_EXP 59
88590: PUSH
88591: LD_EXP 59
88595: PPUSH
88596: LD_VAR 0 1
88600: PPUSH
88601: LD_VAR 0 2
88605: PPUSH
88606: CALL_OW 1
88610: ST_TO_ADDR
// end ;
88611: LD_VAR 0 3
88615: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
88616: LD_INT 0
88618: PPUSH
88619: PPUSH
// if not mc_bases or not base then
88620: LD_EXP 31
88624: NOT
88625: IFTRUE 88634
88627: PUSH
88628: LD_VAR 0 1
88632: NOT
88633: OR
88634: IFFALSE 88638
// exit ;
88636: GO 88740
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
88638: LD_ADDR_VAR 0 4
88642: PUSH
88643: LD_EXP 31
88647: PUSH
88648: LD_VAR 0 1
88652: ARRAY
88653: PPUSH
88654: LD_INT 30
88656: PUSH
88657: LD_VAR 0 2
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PPUSH
88666: CALL_OW 72
88670: ST_TO_ADDR
// if not tmp then
88671: LD_VAR 0 4
88675: NOT
88676: IFFALSE 88680
// exit ;
88678: GO 88740
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
88680: LD_ADDR_EXP 63
88684: PUSH
88685: LD_EXP 63
88689: PPUSH
88690: LD_VAR 0 1
88694: PPUSH
88695: LD_EXP 63
88699: PUSH
88700: LD_VAR 0 1
88704: ARRAY
88705: PPUSH
88706: LD_EXP 63
88710: PUSH
88711: LD_VAR 0 1
88715: ARRAY
88716: PUSH
88717: LD_INT 1
88719: PLUS
88720: PPUSH
88721: LD_VAR 0 4
88725: PUSH
88726: LD_INT 1
88728: ARRAY
88729: PPUSH
88730: CALL_OW 2
88734: PPUSH
88735: CALL_OW 1
88739: ST_TO_ADDR
// end ;
88740: LD_VAR 0 3
88744: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
88745: LD_INT 0
88747: PPUSH
88748: PPUSH
// if not mc_bases or not base or not kinds then
88749: LD_EXP 31
88753: NOT
88754: IFTRUE 88763
88756: PUSH
88757: LD_VAR 0 1
88761: NOT
88762: OR
88763: IFTRUE 88772
88765: PUSH
88766: LD_VAR 0 2
88770: NOT
88771: OR
88772: IFFALSE 88776
// exit ;
88774: GO 88837
// for i in kinds do
88776: LD_ADDR_VAR 0 4
88780: PUSH
88781: LD_VAR 0 2
88785: PUSH
88786: FOR_IN
88787: IFFALSE 88835
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
88789: LD_ADDR_EXP 65
88793: PUSH
88794: LD_EXP 65
88798: PPUSH
88799: LD_VAR 0 1
88803: PUSH
88804: LD_EXP 65
88808: PUSH
88809: LD_VAR 0 1
88813: ARRAY
88814: PUSH
88815: LD_INT 1
88817: PLUS
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PPUSH
88823: LD_VAR 0 4
88827: PPUSH
88828: CALL 25097 0 3
88832: ST_TO_ADDR
88833: GO 88786
88835: POP
88836: POP
// end ;
88837: LD_VAR 0 3
88841: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
88842: LD_INT 0
88844: PPUSH
// if not mc_bases or not base or not areas then
88845: LD_EXP 31
88849: NOT
88850: IFTRUE 88859
88852: PUSH
88853: LD_VAR 0 1
88857: NOT
88858: OR
88859: IFTRUE 88868
88861: PUSH
88862: LD_VAR 0 2
88866: NOT
88867: OR
88868: IFFALSE 88872
// exit ;
88870: GO 88897
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
88872: LD_ADDR_EXP 49
88876: PUSH
88877: LD_EXP 49
88881: PPUSH
88882: LD_VAR 0 1
88886: PPUSH
88887: LD_VAR 0 2
88891: PPUSH
88892: CALL_OW 1
88896: ST_TO_ADDR
// end ;
88897: LD_VAR 0 3
88901: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
88902: LD_INT 0
88904: PPUSH
// if not mc_bases or not base or not teleports_exit then
88905: LD_EXP 31
88909: NOT
88910: IFTRUE 88919
88912: PUSH
88913: LD_VAR 0 1
88917: NOT
88918: OR
88919: IFTRUE 88928
88921: PUSH
88922: LD_VAR 0 2
88926: NOT
88927: OR
88928: IFFALSE 88932
// exit ;
88930: GO 88957
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
88932: LD_ADDR_EXP 66
88936: PUSH
88937: LD_EXP 66
88941: PPUSH
88942: LD_VAR 0 1
88946: PPUSH
88947: LD_VAR 0 2
88951: PPUSH
88952: CALL_OW 1
88956: ST_TO_ADDR
// end ;
88957: LD_VAR 0 3
88961: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
88962: LD_INT 0
88964: PPUSH
88965: PPUSH
88966: PPUSH
// if not mc_bases or not base or not ext_list then
88967: LD_EXP 31
88971: NOT
88972: IFTRUE 88981
88974: PUSH
88975: LD_VAR 0 1
88979: NOT
88980: OR
88981: IFTRUE 88990
88983: PUSH
88984: LD_VAR 0 5
88988: NOT
88989: OR
88990: IFFALSE 88994
// exit ;
88992: GO 89167
// tmp := GetFacExtXYD ( x , y , d ) ;
88994: LD_ADDR_VAR 0 8
88998: PUSH
88999: LD_VAR 0 2
89003: PPUSH
89004: LD_VAR 0 3
89008: PPUSH
89009: LD_VAR 0 4
89013: PPUSH
89014: CALL 55765 0 3
89018: ST_TO_ADDR
// if not tmp then
89019: LD_VAR 0 8
89023: NOT
89024: IFFALSE 89028
// exit ;
89026: GO 89167
// for i in tmp do
89028: LD_ADDR_VAR 0 7
89032: PUSH
89033: LD_VAR 0 8
89037: PUSH
89038: FOR_IN
89039: IFFALSE 89165
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
89041: LD_ADDR_EXP 36
89045: PUSH
89046: LD_EXP 36
89050: PPUSH
89051: LD_VAR 0 1
89055: PPUSH
89056: LD_EXP 36
89060: PUSH
89061: LD_VAR 0 1
89065: ARRAY
89066: PPUSH
89067: LD_EXP 36
89071: PUSH
89072: LD_VAR 0 1
89076: ARRAY
89077: PUSH
89078: LD_INT 1
89080: PLUS
89081: PPUSH
89082: LD_VAR 0 5
89086: PUSH
89087: LD_INT 1
89089: ARRAY
89090: PUSH
89091: LD_VAR 0 7
89095: PUSH
89096: LD_INT 1
89098: ARRAY
89099: PUSH
89100: LD_VAR 0 7
89104: PUSH
89105: LD_INT 2
89107: ARRAY
89108: PUSH
89109: LD_VAR 0 7
89113: PUSH
89114: LD_INT 3
89116: ARRAY
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: PPUSH
89124: CALL_OW 2
89128: PPUSH
89129: CALL_OW 1
89133: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
89134: LD_ADDR_VAR 0 5
89138: PUSH
89139: LD_VAR 0 5
89143: PPUSH
89144: LD_INT 1
89146: PPUSH
89147: CALL_OW 3
89151: ST_TO_ADDR
// if not ext_list then
89152: LD_VAR 0 5
89156: NOT
89157: IFFALSE 89163
// exit ;
89159: POP
89160: POP
89161: GO 89167
// end ;
89163: GO 89038
89165: POP
89166: POP
// end ;
89167: LD_VAR 0 6
89171: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
89172: LD_INT 0
89174: PPUSH
// if not mc_bases or not base or not weapon_list then
89175: LD_EXP 31
89179: NOT
89180: IFTRUE 89189
89182: PUSH
89183: LD_VAR 0 1
89187: NOT
89188: OR
89189: IFTRUE 89198
89191: PUSH
89192: LD_VAR 0 2
89196: NOT
89197: OR
89198: IFFALSE 89202
// exit ;
89200: GO 89227
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
89202: LD_ADDR_EXP 70
89206: PUSH
89207: LD_EXP 70
89211: PPUSH
89212: LD_VAR 0 1
89216: PPUSH
89217: LD_VAR 0 2
89221: PPUSH
89222: CALL_OW 1
89226: ST_TO_ADDR
// end ;
89227: LD_VAR 0 3
89231: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
89232: LD_INT 0
89234: PPUSH
// if not mc_bases or not base or not tech_list then
89235: LD_EXP 31
89239: NOT
89240: IFTRUE 89249
89242: PUSH
89243: LD_VAR 0 1
89247: NOT
89248: OR
89249: IFTRUE 89258
89251: PUSH
89252: LD_VAR 0 2
89256: NOT
89257: OR
89258: IFFALSE 89262
// exit ;
89260: GO 89287
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
89262: LD_ADDR_EXP 58
89266: PUSH
89267: LD_EXP 58
89271: PPUSH
89272: LD_VAR 0 1
89276: PPUSH
89277: LD_VAR 0 2
89281: PPUSH
89282: CALL_OW 1
89286: ST_TO_ADDR
// end ;
89287: LD_VAR 0 3
89291: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
89292: LD_INT 0
89294: PPUSH
// if not mc_bases or not parking_area or not base then
89295: LD_EXP 31
89299: NOT
89300: IFTRUE 89309
89302: PUSH
89303: LD_VAR 0 2
89307: NOT
89308: OR
89309: IFTRUE 89318
89311: PUSH
89312: LD_VAR 0 1
89316: NOT
89317: OR
89318: IFFALSE 89322
// exit ;
89320: GO 89347
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
89322: LD_ADDR_EXP 55
89326: PUSH
89327: LD_EXP 55
89331: PPUSH
89332: LD_VAR 0 1
89336: PPUSH
89337: LD_VAR 0 2
89341: PPUSH
89342: CALL_OW 1
89346: ST_TO_ADDR
// end ;
89347: LD_VAR 0 3
89351: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
89352: LD_INT 0
89354: PPUSH
// if not mc_bases or not base or not scan_area then
89355: LD_EXP 31
89359: NOT
89360: IFTRUE 89369
89362: PUSH
89363: LD_VAR 0 1
89367: NOT
89368: OR
89369: IFTRUE 89378
89371: PUSH
89372: LD_VAR 0 2
89376: NOT
89377: OR
89378: IFFALSE 89382
// exit ;
89380: GO 89407
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
89382: LD_ADDR_EXP 56
89386: PUSH
89387: LD_EXP 56
89391: PPUSH
89392: LD_VAR 0 1
89396: PPUSH
89397: LD_VAR 0 2
89401: PPUSH
89402: CALL_OW 1
89406: ST_TO_ADDR
// end ;
89407: LD_VAR 0 3
89411: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
89412: LD_INT 0
89414: PPUSH
89415: PPUSH
// if not mc_bases or not base then
89416: LD_EXP 31
89420: NOT
89421: IFTRUE 89430
89423: PUSH
89424: LD_VAR 0 1
89428: NOT
89429: OR
89430: IFFALSE 89434
// exit ;
89432: GO 89498
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
89434: LD_ADDR_VAR 0 3
89438: PUSH
89439: LD_INT 1
89441: PUSH
89442: LD_INT 2
89444: PUSH
89445: LD_INT 3
89447: PUSH
89448: LD_INT 4
89450: PUSH
89451: LD_INT 11
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
89461: LD_ADDR_EXP 58
89465: PUSH
89466: LD_EXP 58
89470: PPUSH
89471: LD_VAR 0 1
89475: PPUSH
89476: LD_EXP 58
89480: PUSH
89481: LD_VAR 0 1
89485: ARRAY
89486: PUSH
89487: LD_VAR 0 3
89491: DIFF
89492: PPUSH
89493: CALL_OW 1
89497: ST_TO_ADDR
// end ;
89498: LD_VAR 0 2
89502: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
89503: LD_INT 0
89505: PPUSH
// result := mc_vehicles [ base ] ;
89506: LD_ADDR_VAR 0 3
89510: PUSH
89511: LD_EXP 50
89515: PUSH
89516: LD_VAR 0 1
89520: ARRAY
89521: ST_TO_ADDR
// if onlyCombat then
89522: LD_VAR 0 2
89526: IFFALSE 89698
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
89528: LD_ADDR_VAR 0 3
89532: PUSH
89533: LD_VAR 0 3
89537: PUSH
89538: LD_VAR 0 3
89542: PPUSH
89543: LD_INT 2
89545: PUSH
89546: LD_INT 34
89548: PUSH
89549: LD_INT 12
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: PUSH
89556: LD_INT 34
89558: PUSH
89559: LD_INT 51
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PUSH
89566: LD_INT 34
89568: PUSH
89569: LD_INT 89
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 34
89578: PUSH
89579: LD_INT 32
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 34
89588: PUSH
89589: LD_INT 13
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 34
89598: PUSH
89599: LD_INT 52
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 34
89608: PUSH
89609: LD_INT 88
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 34
89618: PUSH
89619: LD_INT 14
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 34
89628: PUSH
89629: LD_INT 53
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: LD_INT 34
89638: PUSH
89639: LD_INT 98
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 34
89648: PUSH
89649: LD_INT 31
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 34
89658: PUSH
89659: LD_INT 48
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 34
89668: PUSH
89669: LD_INT 8
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: PPUSH
89692: CALL_OW 72
89696: DIFF
89697: ST_TO_ADDR
// end ; end_of_file
89698: LD_VAR 0 3
89702: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
89703: LD_INT 0
89705: PPUSH
89706: PPUSH
89707: PPUSH
// if not mc_bases or not skirmish then
89708: LD_EXP 31
89712: NOT
89713: IFTRUE 89722
89715: PUSH
89716: LD_EXP 29
89720: NOT
89721: OR
89722: IFFALSE 89726
// exit ;
89724: GO 89891
// for i = 1 to mc_bases do
89726: LD_ADDR_VAR 0 4
89730: PUSH
89731: DOUBLE
89732: LD_INT 1
89734: DEC
89735: ST_TO_ADDR
89736: LD_EXP 31
89740: PUSH
89741: FOR_TO
89742: IFFALSE 89889
// begin if sci in mc_bases [ i ] then
89744: LD_VAR 0 2
89748: PUSH
89749: LD_EXP 31
89753: PUSH
89754: LD_VAR 0 4
89758: ARRAY
89759: IN
89760: IFFALSE 89887
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
89762: LD_ADDR_EXP 60
89766: PUSH
89767: LD_EXP 60
89771: PPUSH
89772: LD_VAR 0 4
89776: PUSH
89777: LD_EXP 60
89781: PUSH
89782: LD_VAR 0 4
89786: ARRAY
89787: PUSH
89788: LD_INT 1
89790: PLUS
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: PPUSH
89796: LD_VAR 0 1
89800: PPUSH
89801: CALL 25097 0 3
89805: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
89806: LD_ADDR_VAR 0 5
89810: PUSH
89811: LD_EXP 31
89815: PUSH
89816: LD_VAR 0 4
89820: ARRAY
89821: PPUSH
89822: LD_INT 2
89824: PUSH
89825: LD_INT 30
89827: PUSH
89828: LD_INT 0
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 30
89837: PUSH
89838: LD_INT 1
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: LIST
89849: PPUSH
89850: CALL_OW 72
89854: PPUSH
89855: LD_VAR 0 1
89859: PPUSH
89860: CALL_OW 74
89864: ST_TO_ADDR
// if tmp then
89865: LD_VAR 0 5
89869: IFFALSE 89885
// ComStandNearbyBuilding ( ape , tmp ) ;
89871: LD_VAR 0 1
89875: PPUSH
89876: LD_VAR 0 5
89880: PPUSH
89881: CALL 21639 0 2
// break ;
89885: GO 89889
// end ; end ;
89887: GO 89741
89889: POP
89890: POP
// end ;
89891: LD_VAR 0 3
89895: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
89896: LD_INT 0
89898: PPUSH
89899: PPUSH
89900: PPUSH
// if not mc_bases or not skirmish then
89901: LD_EXP 31
89905: NOT
89906: IFTRUE 89915
89908: PUSH
89909: LD_EXP 29
89913: NOT
89914: OR
89915: IFFALSE 89919
// exit ;
89917: GO 90008
// for i = 1 to mc_bases do
89919: LD_ADDR_VAR 0 4
89923: PUSH
89924: DOUBLE
89925: LD_INT 1
89927: DEC
89928: ST_TO_ADDR
89929: LD_EXP 31
89933: PUSH
89934: FOR_TO
89935: IFFALSE 90006
// begin if building in mc_busy_turret_list [ i ] then
89937: LD_VAR 0 1
89941: PUSH
89942: LD_EXP 41
89946: PUSH
89947: LD_VAR 0 4
89951: ARRAY
89952: IN
89953: IFFALSE 90004
// begin tmp := mc_busy_turret_list [ i ] diff building ;
89955: LD_ADDR_VAR 0 5
89959: PUSH
89960: LD_EXP 41
89964: PUSH
89965: LD_VAR 0 4
89969: ARRAY
89970: PUSH
89971: LD_VAR 0 1
89975: DIFF
89976: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
89977: LD_ADDR_EXP 41
89981: PUSH
89982: LD_EXP 41
89986: PPUSH
89987: LD_VAR 0 4
89991: PPUSH
89992: LD_VAR 0 5
89996: PPUSH
89997: CALL_OW 1
90001: ST_TO_ADDR
// break ;
90002: GO 90006
// end ; end ;
90004: GO 89934
90006: POP
90007: POP
// end ;
90008: LD_VAR 0 3
90012: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
90013: LD_INT 0
90015: PPUSH
90016: PPUSH
90017: PPUSH
// if not mc_bases or not skirmish then
90018: LD_EXP 31
90022: NOT
90023: IFTRUE 90032
90025: PUSH
90026: LD_EXP 29
90030: NOT
90031: OR
90032: IFFALSE 90036
// exit ;
90034: GO 90235
// for i = 1 to mc_bases do
90036: LD_ADDR_VAR 0 5
90040: PUSH
90041: DOUBLE
90042: LD_INT 1
90044: DEC
90045: ST_TO_ADDR
90046: LD_EXP 31
90050: PUSH
90051: FOR_TO
90052: IFFALSE 90233
// if building in mc_bases [ i ] then
90054: LD_VAR 0 1
90058: PUSH
90059: LD_EXP 31
90063: PUSH
90064: LD_VAR 0 5
90068: ARRAY
90069: IN
90070: IFFALSE 90231
// begin tmp := mc_bases [ i ] diff building ;
90072: LD_ADDR_VAR 0 6
90076: PUSH
90077: LD_EXP 31
90081: PUSH
90082: LD_VAR 0 5
90086: ARRAY
90087: PUSH
90088: LD_VAR 0 1
90092: DIFF
90093: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
90094: LD_ADDR_EXP 31
90098: PUSH
90099: LD_EXP 31
90103: PPUSH
90104: LD_VAR 0 5
90108: PPUSH
90109: LD_VAR 0 6
90113: PPUSH
90114: CALL_OW 1
90118: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
90119: LD_VAR 0 1
90123: PUSH
90124: LD_EXP 39
90128: PUSH
90129: LD_VAR 0 5
90133: ARRAY
90134: IN
90135: IFFALSE 90174
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
90137: LD_ADDR_EXP 39
90141: PUSH
90142: LD_EXP 39
90146: PPUSH
90147: LD_VAR 0 5
90151: PPUSH
90152: LD_EXP 39
90156: PUSH
90157: LD_VAR 0 5
90161: ARRAY
90162: PUSH
90163: LD_VAR 0 1
90167: DIFF
90168: PPUSH
90169: CALL_OW 1
90173: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
90174: LD_VAR 0 1
90178: PUSH
90179: LD_EXP 40
90183: PUSH
90184: LD_VAR 0 5
90188: ARRAY
90189: IN
90190: IFFALSE 90229
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
90192: LD_ADDR_EXP 40
90196: PUSH
90197: LD_EXP 40
90201: PPUSH
90202: LD_VAR 0 5
90206: PPUSH
90207: LD_EXP 40
90211: PUSH
90212: LD_VAR 0 5
90216: ARRAY
90217: PUSH
90218: LD_VAR 0 1
90222: DIFF
90223: PPUSH
90224: CALL_OW 1
90228: ST_TO_ADDR
// break ;
90229: GO 90233
// end ;
90231: GO 90051
90233: POP
90234: POP
// end ;
90235: LD_VAR 0 4
90239: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
90240: LD_INT 0
90242: PPUSH
90243: PPUSH
90244: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
90245: LD_EXP 31
90249: NOT
90250: IFTRUE 90259
90252: PUSH
90253: LD_EXP 29
90257: NOT
90258: OR
90259: IFTRUE 90274
90261: PUSH
90262: LD_VAR 0 3
90266: PUSH
90267: LD_EXP 57
90271: IN
90272: NOT
90273: OR
90274: IFFALSE 90278
// exit ;
90276: GO 90403
// for i = 1 to mc_vehicles do
90278: LD_ADDR_VAR 0 6
90282: PUSH
90283: DOUBLE
90284: LD_INT 1
90286: DEC
90287: ST_TO_ADDR
90288: LD_EXP 50
90292: PUSH
90293: FOR_TO
90294: IFFALSE 90401
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
90296: LD_VAR 0 2
90300: PUSH
90301: LD_EXP 50
90305: PUSH
90306: LD_VAR 0 6
90310: ARRAY
90311: IN
90312: IFTRUE 90332
90314: PUSH
90315: LD_VAR 0 1
90319: PUSH
90320: LD_EXP 50
90324: PUSH
90325: LD_VAR 0 6
90329: ARRAY
90330: IN
90331: OR
90332: IFFALSE 90399
// begin tmp := mc_vehicles [ i ] diff old ;
90334: LD_ADDR_VAR 0 7
90338: PUSH
90339: LD_EXP 50
90343: PUSH
90344: LD_VAR 0 6
90348: ARRAY
90349: PUSH
90350: LD_VAR 0 2
90354: DIFF
90355: ST_TO_ADDR
// tmp := tmp diff new ;
90356: LD_ADDR_VAR 0 7
90360: PUSH
90361: LD_VAR 0 7
90365: PUSH
90366: LD_VAR 0 1
90370: DIFF
90371: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
90372: LD_ADDR_EXP 50
90376: PUSH
90377: LD_EXP 50
90381: PPUSH
90382: LD_VAR 0 6
90386: PPUSH
90387: LD_VAR 0 7
90391: PPUSH
90392: CALL_OW 1
90396: ST_TO_ADDR
// break ;
90397: GO 90401
// end ;
90399: GO 90293
90401: POP
90402: POP
// end ;
90403: LD_VAR 0 5
90407: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
90408: LD_INT 0
90410: PPUSH
90411: PPUSH
90412: PPUSH
90413: PPUSH
// if not mc_bases or not skirmish then
90414: LD_EXP 31
90418: NOT
90419: IFTRUE 90428
90421: PUSH
90422: LD_EXP 29
90426: NOT
90427: OR
90428: IFFALSE 90432
// exit ;
90430: GO 90854
// repeat wait ( 0 0$1 ) ;
90432: LD_INT 35
90434: PPUSH
90435: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
90439: LD_EXP 75
90443: NOT
90444: IFFALSE 90432
// mc_block_vehicle_constructed_thread := true ;
90446: LD_ADDR_EXP 75
90450: PUSH
90451: LD_INT 1
90453: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
90454: LD_ADDR_VAR 0 5
90458: PUSH
90459: LD_VAR 0 1
90463: PPUSH
90464: CALL_OW 255
90468: ST_TO_ADDR
// for i = 1 to mc_bases do
90469: LD_ADDR_VAR 0 4
90473: PUSH
90474: DOUBLE
90475: LD_INT 1
90477: DEC
90478: ST_TO_ADDR
90479: LD_EXP 31
90483: PUSH
90484: FOR_TO
90485: IFFALSE 90844
// begin if factory in mc_bases [ i ] then
90487: LD_VAR 0 2
90491: PUSH
90492: LD_EXP 31
90496: PUSH
90497: LD_VAR 0 4
90501: ARRAY
90502: IN
90503: IFFALSE 90842
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
90505: LD_EXP 53
90509: PUSH
90510: LD_VAR 0 4
90514: ARRAY
90515: PUSH
90516: LD_EXP 42
90520: PUSH
90521: LD_VAR 0 4
90525: ARRAY
90526: LESS
90527: IFFALSE 90616
90529: PUSH
90530: LD_VAR 0 1
90534: PPUSH
90535: CALL_OW 264
90539: PUSH
90540: LD_INT 31
90542: PUSH
90543: LD_INT 32
90545: PUSH
90546: LD_INT 51
90548: PUSH
90549: LD_INT 89
90551: PUSH
90552: LD_INT 12
90554: PUSH
90555: LD_INT 30
90557: PUSH
90558: LD_INT 98
90560: PUSH
90561: LD_INT 11
90563: PUSH
90564: LD_INT 53
90566: PUSH
90567: LD_INT 14
90569: PUSH
90570: LD_INT 91
90572: PUSH
90573: LD_INT 29
90575: PUSH
90576: LD_INT 99
90578: PUSH
90579: LD_INT 13
90581: PUSH
90582: LD_INT 52
90584: PUSH
90585: LD_INT 88
90587: PUSH
90588: LD_INT 48
90590: PUSH
90591: LD_INT 8
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: IN
90614: NOT
90615: AND
90616: IFFALSE 90664
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
90618: LD_ADDR_EXP 53
90622: PUSH
90623: LD_EXP 53
90627: PPUSH
90628: LD_VAR 0 4
90632: PUSH
90633: LD_EXP 53
90637: PUSH
90638: LD_VAR 0 4
90642: ARRAY
90643: PUSH
90644: LD_INT 1
90646: PLUS
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PPUSH
90652: LD_VAR 0 1
90656: PPUSH
90657: CALL 25097 0 3
90661: ST_TO_ADDR
90662: GO 90708
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
90664: LD_ADDR_EXP 50
90668: PUSH
90669: LD_EXP 50
90673: PPUSH
90674: LD_VAR 0 4
90678: PUSH
90679: LD_EXP 50
90683: PUSH
90684: LD_VAR 0 4
90688: ARRAY
90689: PUSH
90690: LD_INT 1
90692: PLUS
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PPUSH
90698: LD_VAR 0 1
90702: PPUSH
90703: CALL 25097 0 3
90707: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
90708: LD_ADDR_EXP 75
90712: PUSH
90713: LD_INT 0
90715: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
90716: LD_VAR 0 1
90720: PPUSH
90721: CALL_OW 263
90725: PUSH
90726: LD_INT 2
90728: EQUAL
90729: IFFALSE 90758
// begin repeat wait ( 0 0$3 ) ;
90731: LD_INT 105
90733: PPUSH
90734: CALL_OW 67
// Connect ( vehicle ) ;
90738: LD_VAR 0 1
90742: PPUSH
90743: CALL 28457 0 1
// until IsControledBy ( vehicle ) ;
90747: LD_VAR 0 1
90751: PPUSH
90752: CALL_OW 312
90756: IFFALSE 90731
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
90758: LD_VAR 0 1
90762: PPUSH
90763: LD_EXP 55
90767: PUSH
90768: LD_VAR 0 4
90772: ARRAY
90773: PPUSH
90774: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
90778: LD_VAR 0 1
90782: PPUSH
90783: CALL_OW 263
90787: PUSH
90788: LD_INT 1
90790: NONEQUAL
90791: IFFALSE 90795
// break ;
90793: GO 90844
// repeat wait ( 0 0$1 ) ;
90795: LD_INT 35
90797: PPUSH
90798: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
90802: LD_VAR 0 1
90806: PPUSH
90807: LD_EXP 55
90811: PUSH
90812: LD_VAR 0 4
90816: ARRAY
90817: PPUSH
90818: CALL_OW 308
90822: IFFALSE 90795
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
90824: LD_VAR 0 1
90828: PPUSH
90829: CALL_OW 311
90833: PPUSH
90834: CALL_OW 121
// exit ;
90838: POP
90839: POP
90840: GO 90854
// end ; end ;
90842: GO 90484
90844: POP
90845: POP
// mc_block_vehicle_constructed_thread := false ;
90846: LD_ADDR_EXP 75
90850: PUSH
90851: LD_INT 0
90853: ST_TO_ADDR
// end ;
90854: LD_VAR 0 3
90858: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
90859: LD_INT 0
90861: PPUSH
90862: PPUSH
90863: PPUSH
90864: PPUSH
// if not mc_bases or not skirmish then
90865: LD_EXP 31
90869: NOT
90870: IFTRUE 90879
90872: PUSH
90873: LD_EXP 29
90877: NOT
90878: OR
90879: IFFALSE 90883
// exit ;
90881: GO 91236
// repeat wait ( 0 0$1 ) ;
90883: LD_INT 35
90885: PPUSH
90886: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
90890: LD_VAR 0 2
90894: PPUSH
90895: LD_VAR 0 3
90899: PPUSH
90900: CALL_OW 284
90904: IFFALSE 90883
// if GetResourceTypeXY ( x , y ) = mat_artefact then
90906: LD_VAR 0 2
90910: PPUSH
90911: LD_VAR 0 3
90915: PPUSH
90916: CALL_OW 283
90920: PUSH
90921: LD_INT 4
90923: EQUAL
90924: IFFALSE 90928
// exit ;
90926: GO 91236
// for i = 1 to mc_bases do
90928: LD_ADDR_VAR 0 7
90932: PUSH
90933: DOUBLE
90934: LD_INT 1
90936: DEC
90937: ST_TO_ADDR
90938: LD_EXP 31
90942: PUSH
90943: FOR_TO
90944: IFFALSE 91234
// begin if mc_crates_area [ i ] then
90946: LD_EXP 49
90950: PUSH
90951: LD_VAR 0 7
90955: ARRAY
90956: IFFALSE 91067
// for j in mc_crates_area [ i ] do
90958: LD_ADDR_VAR 0 8
90962: PUSH
90963: LD_EXP 49
90967: PUSH
90968: LD_VAR 0 7
90972: ARRAY
90973: PUSH
90974: FOR_IN
90975: IFFALSE 91065
// if InArea ( x , y , j ) then
90977: LD_VAR 0 2
90981: PPUSH
90982: LD_VAR 0 3
90986: PPUSH
90987: LD_VAR 0 8
90991: PPUSH
90992: CALL_OW 309
90996: IFFALSE 91063
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
90998: LD_ADDR_EXP 47
91002: PUSH
91003: LD_EXP 47
91007: PPUSH
91008: LD_VAR 0 7
91012: PUSH
91013: LD_EXP 47
91017: PUSH
91018: LD_VAR 0 7
91022: ARRAY
91023: PUSH
91024: LD_INT 1
91026: PLUS
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PPUSH
91032: LD_VAR 0 4
91036: PUSH
91037: LD_VAR 0 2
91041: PUSH
91042: LD_VAR 0 3
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: LIST
91051: PPUSH
91052: CALL 25097 0 3
91056: ST_TO_ADDR
// exit ;
91057: POP
91058: POP
91059: POP
91060: POP
91061: GO 91236
// end ;
91063: GO 90974
91065: POP
91066: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
91067: LD_ADDR_VAR 0 9
91071: PUSH
91072: LD_EXP 31
91076: PUSH
91077: LD_VAR 0 7
91081: ARRAY
91082: PPUSH
91083: LD_INT 2
91085: PUSH
91086: LD_INT 30
91088: PUSH
91089: LD_INT 0
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 30
91098: PUSH
91099: LD_INT 1
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: LIST
91110: PPUSH
91111: CALL_OW 72
91115: ST_TO_ADDR
// if not depot then
91116: LD_VAR 0 9
91120: NOT
91121: IFFALSE 91125
// continue ;
91123: GO 90943
// for j in depot do
91125: LD_ADDR_VAR 0 8
91129: PUSH
91130: LD_VAR 0 9
91134: PUSH
91135: FOR_IN
91136: IFFALSE 91230
// if GetDistUnitXY ( j , x , y ) < 30 then
91138: LD_VAR 0 8
91142: PPUSH
91143: LD_VAR 0 2
91147: PPUSH
91148: LD_VAR 0 3
91152: PPUSH
91153: CALL_OW 297
91157: PUSH
91158: LD_INT 30
91160: LESS
91161: IFFALSE 91228
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
91163: LD_ADDR_EXP 47
91167: PUSH
91168: LD_EXP 47
91172: PPUSH
91173: LD_VAR 0 7
91177: PUSH
91178: LD_EXP 47
91182: PUSH
91183: LD_VAR 0 7
91187: ARRAY
91188: PUSH
91189: LD_INT 1
91191: PLUS
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PPUSH
91197: LD_VAR 0 4
91201: PUSH
91202: LD_VAR 0 2
91206: PUSH
91207: LD_VAR 0 3
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: LIST
91216: PPUSH
91217: CALL 25097 0 3
91221: ST_TO_ADDR
// exit ;
91222: POP
91223: POP
91224: POP
91225: POP
91226: GO 91236
// end ;
91228: GO 91135
91230: POP
91231: POP
// end ;
91232: GO 90943
91234: POP
91235: POP
// end ;
91236: LD_VAR 0 6
91240: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
91241: LD_INT 0
91243: PPUSH
91244: PPUSH
91245: PPUSH
91246: PPUSH
// if not mc_bases or not skirmish then
91247: LD_EXP 31
91251: NOT
91252: IFTRUE 91261
91254: PUSH
91255: LD_EXP 29
91259: NOT
91260: OR
91261: IFFALSE 91265
// exit ;
91263: GO 91548
// side := GetSide ( lab ) ;
91265: LD_ADDR_VAR 0 4
91269: PUSH
91270: LD_VAR 0 2
91274: PPUSH
91275: CALL_OW 255
91279: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
91280: LD_VAR 0 4
91284: PUSH
91285: LD_EXP 57
91289: IN
91290: NOT
91291: IFTRUE 91300
91293: PUSH
91294: LD_EXP 58
91298: NOT
91299: OR
91300: IFTRUE 91309
91302: PUSH
91303: LD_EXP 31
91307: NOT
91308: OR
91309: IFFALSE 91313
// exit ;
91311: GO 91548
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
91313: LD_ADDR_EXP 58
91317: PUSH
91318: LD_EXP 58
91322: PPUSH
91323: LD_VAR 0 4
91327: PPUSH
91328: LD_EXP 58
91332: PUSH
91333: LD_VAR 0 4
91337: ARRAY
91338: PUSH
91339: LD_VAR 0 1
91343: DIFF
91344: PPUSH
91345: CALL_OW 1
91349: ST_TO_ADDR
// for i = 1 to mc_bases do
91350: LD_ADDR_VAR 0 5
91354: PUSH
91355: DOUBLE
91356: LD_INT 1
91358: DEC
91359: ST_TO_ADDR
91360: LD_EXP 31
91364: PUSH
91365: FOR_TO
91366: IFFALSE 91546
// begin if lab in mc_bases [ i ] then
91368: LD_VAR 0 2
91372: PUSH
91373: LD_EXP 31
91377: PUSH
91378: LD_VAR 0 5
91382: ARRAY
91383: IN
91384: IFFALSE 91544
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
91386: LD_VAR 0 1
91390: PUSH
91391: LD_INT 11
91393: PUSH
91394: LD_INT 4
91396: PUSH
91397: LD_INT 3
91399: PUSH
91400: LD_INT 2
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: IN
91409: IFFALSE 91423
91411: PUSH
91412: LD_EXP 61
91416: PUSH
91417: LD_VAR 0 5
91421: ARRAY
91422: AND
91423: IFFALSE 91544
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
91425: LD_ADDR_VAR 0 6
91429: PUSH
91430: LD_EXP 61
91434: PUSH
91435: LD_VAR 0 5
91439: ARRAY
91440: PUSH
91441: LD_INT 1
91443: ARRAY
91444: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91445: LD_ADDR_EXP 61
91449: PUSH
91450: LD_EXP 61
91454: PPUSH
91455: LD_VAR 0 5
91459: PPUSH
91460: EMPTY
91461: PPUSH
91462: CALL_OW 1
91466: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
91467: LD_VAR 0 6
91471: PPUSH
91472: LD_INT 0
91474: PPUSH
91475: CALL_OW 109
// ComExitBuilding ( tmp ) ;
91479: LD_VAR 0 6
91483: PPUSH
91484: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
91488: LD_ADDR_EXP 60
91492: PUSH
91493: LD_EXP 60
91497: PPUSH
91498: LD_VAR 0 5
91502: PPUSH
91503: LD_EXP 60
91507: PUSH
91508: LD_VAR 0 5
91512: ARRAY
91513: PPUSH
91514: LD_INT 1
91516: PPUSH
91517: LD_VAR 0 6
91521: PPUSH
91522: CALL_OW 2
91526: PPUSH
91527: CALL_OW 1
91531: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
91532: LD_VAR 0 5
91536: PPUSH
91537: LD_INT 112
91539: PPUSH
91540: CALL 67678 0 2
// end ; end ; end ;
91544: GO 91365
91546: POP
91547: POP
// end ;
91548: LD_VAR 0 3
91552: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
91553: LD_INT 0
91555: PPUSH
91556: PPUSH
91557: PPUSH
91558: PPUSH
91559: PPUSH
91560: PPUSH
91561: PPUSH
91562: PPUSH
// if not mc_bases or not skirmish then
91563: LD_EXP 31
91567: NOT
91568: IFTRUE 91577
91570: PUSH
91571: LD_EXP 29
91575: NOT
91576: OR
91577: IFFALSE 91581
// exit ;
91579: GO 92966
// for i = 1 to mc_bases do
91581: LD_ADDR_VAR 0 3
91585: PUSH
91586: DOUBLE
91587: LD_INT 1
91589: DEC
91590: ST_TO_ADDR
91591: LD_EXP 31
91595: PUSH
91596: FOR_TO
91597: IFFALSE 92964
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
91599: LD_VAR 0 1
91603: PUSH
91604: LD_EXP 31
91608: PUSH
91609: LD_VAR 0 3
91613: ARRAY
91614: IN
91615: IFTRUE 91635
91617: PUSH
91618: LD_VAR 0 1
91622: PUSH
91623: LD_EXP 38
91627: PUSH
91628: LD_VAR 0 3
91632: ARRAY
91633: IN
91634: OR
91635: IFTRUE 91655
91637: PUSH
91638: LD_VAR 0 1
91642: PUSH
91643: LD_EXP 53
91647: PUSH
91648: LD_VAR 0 3
91652: ARRAY
91653: IN
91654: OR
91655: IFTRUE 91675
91657: PUSH
91658: LD_VAR 0 1
91662: PUSH
91663: LD_EXP 50
91667: PUSH
91668: LD_VAR 0 3
91672: ARRAY
91673: IN
91674: OR
91675: IFTRUE 91695
91677: PUSH
91678: LD_VAR 0 1
91682: PUSH
91683: LD_EXP 60
91687: PUSH
91688: LD_VAR 0 3
91692: ARRAY
91693: IN
91694: OR
91695: IFTRUE 91715
91697: PUSH
91698: LD_VAR 0 1
91702: PUSH
91703: LD_EXP 61
91707: PUSH
91708: LD_VAR 0 3
91712: ARRAY
91713: IN
91714: OR
91715: IFFALSE 92962
// begin if un in mc_ape [ i ] then
91717: LD_VAR 0 1
91721: PUSH
91722: LD_EXP 60
91726: PUSH
91727: LD_VAR 0 3
91731: ARRAY
91732: IN
91733: IFFALSE 91772
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
91735: LD_ADDR_EXP 60
91739: PUSH
91740: LD_EXP 60
91744: PPUSH
91745: LD_VAR 0 3
91749: PPUSH
91750: LD_EXP 60
91754: PUSH
91755: LD_VAR 0 3
91759: ARRAY
91760: PUSH
91761: LD_VAR 0 1
91765: DIFF
91766: PPUSH
91767: CALL_OW 1
91771: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
91772: LD_VAR 0 1
91776: PUSH
91777: LD_EXP 61
91781: PUSH
91782: LD_VAR 0 3
91786: ARRAY
91787: IN
91788: IFFALSE 91812
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91790: LD_ADDR_EXP 61
91794: PUSH
91795: LD_EXP 61
91799: PPUSH
91800: LD_VAR 0 3
91804: PPUSH
91805: EMPTY
91806: PPUSH
91807: CALL_OW 1
91811: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
91812: LD_VAR 0 1
91816: PPUSH
91817: CALL_OW 247
91821: PUSH
91822: LD_INT 2
91824: EQUAL
91825: IFFALSE 91906
91827: PUSH
91828: LD_VAR 0 1
91832: PPUSH
91833: CALL_OW 110
91837: PUSH
91838: LD_INT 20
91840: EQUAL
91841: IFTRUE 91861
91843: PUSH
91844: LD_VAR 0 1
91848: PUSH
91849: LD_EXP 53
91853: PUSH
91854: LD_VAR 0 3
91858: ARRAY
91859: IN
91860: OR
91861: IFTRUE 91905
91863: PUSH
91864: LD_VAR 0 1
91868: PPUSH
91869: CALL_OW 264
91873: PUSH
91874: LD_INT 12
91876: PUSH
91877: LD_INT 51
91879: PUSH
91880: LD_INT 89
91882: PUSH
91883: LD_INT 32
91885: PUSH
91886: LD_INT 13
91888: PUSH
91889: LD_INT 52
91891: PUSH
91892: LD_INT 31
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: IN
91904: OR
91905: AND
91906: IFFALSE 92214
// begin if un in mc_defender [ i ] then
91908: LD_VAR 0 1
91912: PUSH
91913: LD_EXP 53
91917: PUSH
91918: LD_VAR 0 3
91922: ARRAY
91923: IN
91924: IFFALSE 91963
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
91926: LD_ADDR_EXP 53
91930: PUSH
91931: LD_EXP 53
91935: PPUSH
91936: LD_VAR 0 3
91940: PPUSH
91941: LD_EXP 53
91945: PUSH
91946: LD_VAR 0 3
91950: ARRAY
91951: PUSH
91952: LD_VAR 0 1
91956: DIFF
91957: PPUSH
91958: CALL_OW 1
91962: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
91963: LD_ADDR_VAR 0 8
91967: PUSH
91968: LD_VAR 0 3
91972: PPUSH
91973: LD_INT 3
91975: PPUSH
91976: CALL 88502 0 2
91980: ST_TO_ADDR
// if fac then
91981: LD_VAR 0 8
91985: IFFALSE 92214
// begin for j in fac do
91987: LD_ADDR_VAR 0 4
91991: PUSH
91992: LD_VAR 0 8
91996: PUSH
91997: FOR_IN
91998: IFFALSE 92212
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
92000: LD_ADDR_VAR 0 9
92004: PUSH
92005: LD_VAR 0 8
92009: PPUSH
92010: LD_VAR 0 1
92014: PPUSH
92015: CALL_OW 265
92019: PPUSH
92020: LD_VAR 0 1
92024: PPUSH
92025: CALL_OW 262
92029: PPUSH
92030: LD_VAR 0 1
92034: PPUSH
92035: CALL_OW 263
92039: PPUSH
92040: LD_VAR 0 1
92044: PPUSH
92045: CALL_OW 264
92049: PPUSH
92050: CALL 22537 0 5
92054: ST_TO_ADDR
// if components then
92055: LD_VAR 0 9
92059: IFFALSE 92210
// begin if GetWeapon ( un ) = ar_control_tower then
92061: LD_VAR 0 1
92065: PPUSH
92066: CALL_OW 264
92070: PUSH
92071: LD_INT 31
92073: EQUAL
92074: IFFALSE 92191
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
92076: LD_VAR 0 1
92080: PPUSH
92081: CALL_OW 311
92085: PPUSH
92086: LD_INT 0
92088: PPUSH
92089: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
92093: LD_ADDR_EXP 71
92097: PUSH
92098: LD_EXP 71
92102: PPUSH
92103: LD_VAR 0 3
92107: PPUSH
92108: LD_EXP 71
92112: PUSH
92113: LD_VAR 0 3
92117: ARRAY
92118: PUSH
92119: LD_VAR 0 1
92123: PPUSH
92124: CALL_OW 311
92128: DIFF
92129: PPUSH
92130: CALL_OW 1
92134: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
92135: LD_ADDR_VAR 0 7
92139: PUSH
92140: LD_EXP 52
92144: PUSH
92145: LD_VAR 0 3
92149: ARRAY
92150: PPUSH
92151: LD_INT 1
92153: PPUSH
92154: LD_VAR 0 9
92158: PPUSH
92159: CALL_OW 2
92163: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
92164: LD_ADDR_EXP 52
92168: PUSH
92169: LD_EXP 52
92173: PPUSH
92174: LD_VAR 0 3
92178: PPUSH
92179: LD_VAR 0 7
92183: PPUSH
92184: CALL_OW 1
92188: ST_TO_ADDR
// end else
92189: GO 92208
// MC_InsertProduceList ( i , [ components ] ) ;
92191: LD_VAR 0 3
92195: PPUSH
92196: LD_VAR 0 9
92200: PUSH
92201: EMPTY
92202: LIST
92203: PPUSH
92204: CALL 88047 0 2
// break ;
92208: GO 92212
// end ; end ;
92210: GO 91997
92212: POP
92213: POP
// end ; end ; if GetType ( un ) = unit_building then
92214: LD_VAR 0 1
92218: PPUSH
92219: CALL_OW 247
92223: PUSH
92224: LD_INT 3
92226: EQUAL
92227: IFFALSE 92630
// begin btype := GetBType ( un ) ;
92229: LD_ADDR_VAR 0 5
92233: PUSH
92234: LD_VAR 0 1
92238: PPUSH
92239: CALL_OW 266
92243: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
92244: LD_VAR 0 5
92248: PUSH
92249: LD_INT 29
92251: PUSH
92252: LD_INT 30
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: IN
92259: IFFALSE 92332
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
92261: LD_VAR 0 1
92265: PPUSH
92266: CALL_OW 250
92270: PPUSH
92271: LD_VAR 0 1
92275: PPUSH
92276: CALL_OW 251
92280: PPUSH
92281: LD_VAR 0 1
92285: PPUSH
92286: CALL_OW 255
92290: PPUSH
92291: CALL_OW 440
92295: NOT
92296: IFFALSE 92332
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
92298: LD_VAR 0 1
92302: PPUSH
92303: CALL_OW 250
92307: PPUSH
92308: LD_VAR 0 1
92312: PPUSH
92313: CALL_OW 251
92317: PPUSH
92318: LD_VAR 0 1
92322: PPUSH
92323: CALL_OW 255
92327: PPUSH
92328: CALL_OW 441
// end ; if btype = b_warehouse then
92332: LD_VAR 0 5
92336: PUSH
92337: LD_INT 1
92339: EQUAL
92340: IFFALSE 92358
// begin btype := b_depot ;
92342: LD_ADDR_VAR 0 5
92346: PUSH
92347: LD_INT 0
92349: ST_TO_ADDR
// pos := 1 ;
92350: LD_ADDR_VAR 0 6
92354: PUSH
92355: LD_INT 1
92357: ST_TO_ADDR
// end ; if btype = b_factory then
92358: LD_VAR 0 5
92362: PUSH
92363: LD_INT 3
92365: EQUAL
92366: IFFALSE 92384
// begin btype := b_workshop ;
92368: LD_ADDR_VAR 0 5
92372: PUSH
92373: LD_INT 2
92375: ST_TO_ADDR
// pos := 1 ;
92376: LD_ADDR_VAR 0 6
92380: PUSH
92381: LD_INT 1
92383: ST_TO_ADDR
// end ; if btype = b_barracks then
92384: LD_VAR 0 5
92388: PUSH
92389: LD_INT 5
92391: EQUAL
92392: IFFALSE 92402
// btype := b_armoury ;
92394: LD_ADDR_VAR 0 5
92398: PUSH
92399: LD_INT 4
92401: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
92402: LD_VAR 0 5
92406: PUSH
92407: LD_INT 7
92409: PUSH
92410: LD_INT 8
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: IN
92417: IFFALSE 92427
// btype := b_lab ;
92419: LD_ADDR_VAR 0 5
92423: PUSH
92424: LD_INT 6
92426: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
92427: LD_ADDR_EXP 36
92431: PUSH
92432: LD_EXP 36
92436: PPUSH
92437: LD_VAR 0 3
92441: PUSH
92442: LD_EXP 36
92446: PUSH
92447: LD_VAR 0 3
92451: ARRAY
92452: PUSH
92453: LD_INT 1
92455: PLUS
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PPUSH
92461: LD_VAR 0 5
92465: PUSH
92466: LD_VAR 0 1
92470: PPUSH
92471: CALL_OW 250
92475: PUSH
92476: LD_VAR 0 1
92480: PPUSH
92481: CALL_OW 251
92485: PUSH
92486: LD_VAR 0 1
92490: PPUSH
92491: CALL_OW 254
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: PPUSH
92502: CALL 25097 0 3
92506: ST_TO_ADDR
// if pos = 1 then
92507: LD_VAR 0 6
92511: PUSH
92512: LD_INT 1
92514: EQUAL
92515: IFFALSE 92630
// begin tmp := mc_build_list [ i ] ;
92517: LD_ADDR_VAR 0 7
92521: PUSH
92522: LD_EXP 36
92526: PUSH
92527: LD_VAR 0 3
92531: ARRAY
92532: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
92533: LD_VAR 0 7
92537: PPUSH
92538: LD_INT 2
92540: PUSH
92541: LD_INT 30
92543: PUSH
92544: LD_INT 0
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 30
92553: PUSH
92554: LD_INT 1
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: LIST
92565: PPUSH
92566: CALL_OW 72
92570: IFFALSE 92580
// pos := 2 ;
92572: LD_ADDR_VAR 0 6
92576: PUSH
92577: LD_INT 2
92579: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
92580: LD_ADDR_VAR 0 7
92584: PUSH
92585: LD_VAR 0 7
92589: PPUSH
92590: LD_VAR 0 6
92594: PPUSH
92595: LD_VAR 0 7
92599: PPUSH
92600: CALL 25423 0 3
92604: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
92605: LD_ADDR_EXP 36
92609: PUSH
92610: LD_EXP 36
92614: PPUSH
92615: LD_VAR 0 3
92619: PPUSH
92620: LD_VAR 0 7
92624: PPUSH
92625: CALL_OW 1
92629: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
92630: LD_VAR 0 1
92634: PUSH
92635: LD_EXP 31
92639: PUSH
92640: LD_VAR 0 3
92644: ARRAY
92645: IN
92646: IFFALSE 92685
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
92648: LD_ADDR_EXP 31
92652: PUSH
92653: LD_EXP 31
92657: PPUSH
92658: LD_VAR 0 3
92662: PPUSH
92663: LD_EXP 31
92667: PUSH
92668: LD_VAR 0 3
92672: ARRAY
92673: PUSH
92674: LD_VAR 0 1
92678: DIFF
92679: PPUSH
92680: CALL_OW 1
92684: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
92685: LD_VAR 0 1
92689: PUSH
92690: LD_EXP 38
92694: PUSH
92695: LD_VAR 0 3
92699: ARRAY
92700: IN
92701: IFFALSE 92740
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
92703: LD_ADDR_EXP 38
92707: PUSH
92708: LD_EXP 38
92712: PPUSH
92713: LD_VAR 0 3
92717: PPUSH
92718: LD_EXP 38
92722: PUSH
92723: LD_VAR 0 3
92727: ARRAY
92728: PUSH
92729: LD_VAR 0 1
92733: DIFF
92734: PPUSH
92735: CALL_OW 1
92739: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
92740: LD_VAR 0 1
92744: PUSH
92745: LD_EXP 50
92749: PUSH
92750: LD_VAR 0 3
92754: ARRAY
92755: IN
92756: IFFALSE 92795
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
92758: LD_ADDR_EXP 50
92762: PUSH
92763: LD_EXP 50
92767: PPUSH
92768: LD_VAR 0 3
92772: PPUSH
92773: LD_EXP 50
92777: PUSH
92778: LD_VAR 0 3
92782: ARRAY
92783: PUSH
92784: LD_VAR 0 1
92788: DIFF
92789: PPUSH
92790: CALL_OW 1
92794: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
92795: LD_VAR 0 1
92799: PUSH
92800: LD_EXP 53
92804: PUSH
92805: LD_VAR 0 3
92809: ARRAY
92810: IN
92811: IFFALSE 92850
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
92813: LD_ADDR_EXP 53
92817: PUSH
92818: LD_EXP 53
92822: PPUSH
92823: LD_VAR 0 3
92827: PPUSH
92828: LD_EXP 53
92832: PUSH
92833: LD_VAR 0 3
92837: ARRAY
92838: PUSH
92839: LD_VAR 0 1
92843: DIFF
92844: PPUSH
92845: CALL_OW 1
92849: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
92850: LD_VAR 0 1
92854: PUSH
92855: LD_EXP 40
92859: PUSH
92860: LD_VAR 0 3
92864: ARRAY
92865: IN
92866: IFFALSE 92905
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
92868: LD_ADDR_EXP 40
92872: PUSH
92873: LD_EXP 40
92877: PPUSH
92878: LD_VAR 0 3
92882: PPUSH
92883: LD_EXP 40
92887: PUSH
92888: LD_VAR 0 3
92892: ARRAY
92893: PUSH
92894: LD_VAR 0 1
92898: DIFF
92899: PPUSH
92900: CALL_OW 1
92904: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
92905: LD_VAR 0 1
92909: PUSH
92910: LD_EXP 39
92914: PUSH
92915: LD_VAR 0 3
92919: ARRAY
92920: IN
92921: IFFALSE 92960
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
92923: LD_ADDR_EXP 39
92927: PUSH
92928: LD_EXP 39
92932: PPUSH
92933: LD_VAR 0 3
92937: PPUSH
92938: LD_EXP 39
92942: PUSH
92943: LD_VAR 0 3
92947: ARRAY
92948: PUSH
92949: LD_VAR 0 1
92953: DIFF
92954: PPUSH
92955: CALL_OW 1
92959: ST_TO_ADDR
// end ; break ;
92960: GO 92964
// end ;
92962: GO 91596
92964: POP
92965: POP
// end ;
92966: LD_VAR 0 2
92970: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
92971: LD_INT 0
92973: PPUSH
92974: PPUSH
92975: PPUSH
// if not mc_bases or not skirmish then
92976: LD_EXP 31
92980: NOT
92981: IFTRUE 92990
92983: PUSH
92984: LD_EXP 29
92988: NOT
92989: OR
92990: IFFALSE 92994
// exit ;
92992: GO 93209
// for i = 1 to mc_bases do
92994: LD_ADDR_VAR 0 3
92998: PUSH
92999: DOUBLE
93000: LD_INT 1
93002: DEC
93003: ST_TO_ADDR
93004: LD_EXP 31
93008: PUSH
93009: FOR_TO
93010: IFFALSE 93207
// begin if building in mc_construct_list [ i ] then
93012: LD_VAR 0 1
93016: PUSH
93017: LD_EXP 38
93021: PUSH
93022: LD_VAR 0 3
93026: ARRAY
93027: IN
93028: IFFALSE 93205
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
93030: LD_ADDR_EXP 38
93034: PUSH
93035: LD_EXP 38
93039: PPUSH
93040: LD_VAR 0 3
93044: PPUSH
93045: LD_EXP 38
93049: PUSH
93050: LD_VAR 0 3
93054: ARRAY
93055: PUSH
93056: LD_VAR 0 1
93060: DIFF
93061: PPUSH
93062: CALL_OW 1
93066: ST_TO_ADDR
// if building in mc_lab [ i ] then
93067: LD_VAR 0 1
93071: PUSH
93072: LD_EXP 64
93076: PUSH
93077: LD_VAR 0 3
93081: ARRAY
93082: IN
93083: IFFALSE 93138
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
93085: LD_ADDR_EXP 65
93089: PUSH
93090: LD_EXP 65
93094: PPUSH
93095: LD_VAR 0 3
93099: PPUSH
93100: LD_EXP 65
93104: PUSH
93105: LD_VAR 0 3
93109: ARRAY
93110: PPUSH
93111: LD_INT 1
93113: PPUSH
93114: LD_EXP 65
93118: PUSH
93119: LD_VAR 0 3
93123: ARRAY
93124: PPUSH
93125: LD_INT 0
93127: PPUSH
93128: CALL 24505 0 4
93132: PPUSH
93133: CALL_OW 1
93137: ST_TO_ADDR
// if not building in mc_bases [ i ] then
93138: LD_VAR 0 1
93142: PUSH
93143: LD_EXP 31
93147: PUSH
93148: LD_VAR 0 3
93152: ARRAY
93153: IN
93154: NOT
93155: IFFALSE 93201
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
93157: LD_ADDR_EXP 31
93161: PUSH
93162: LD_EXP 31
93166: PPUSH
93167: LD_VAR 0 3
93171: PUSH
93172: LD_EXP 31
93176: PUSH
93177: LD_VAR 0 3
93181: ARRAY
93182: PUSH
93183: LD_INT 1
93185: PLUS
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PPUSH
93191: LD_VAR 0 1
93195: PPUSH
93196: CALL 25097 0 3
93200: ST_TO_ADDR
// exit ;
93201: POP
93202: POP
93203: GO 93209
// end ; end ;
93205: GO 93009
93207: POP
93208: POP
// end ;
93209: LD_VAR 0 2
93213: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
93214: LD_INT 0
93216: PPUSH
93217: PPUSH
93218: PPUSH
93219: PPUSH
93220: PPUSH
93221: PPUSH
93222: PPUSH
// if not mc_bases or not skirmish then
93223: LD_EXP 31
93227: NOT
93228: IFTRUE 93237
93230: PUSH
93231: LD_EXP 29
93235: NOT
93236: OR
93237: IFFALSE 93241
// exit ;
93239: GO 93902
// for i = 1 to mc_bases do
93241: LD_ADDR_VAR 0 3
93245: PUSH
93246: DOUBLE
93247: LD_INT 1
93249: DEC
93250: ST_TO_ADDR
93251: LD_EXP 31
93255: PUSH
93256: FOR_TO
93257: IFFALSE 93900
// begin if building in mc_construct_list [ i ] then
93259: LD_VAR 0 1
93263: PUSH
93264: LD_EXP 38
93268: PUSH
93269: LD_VAR 0 3
93273: ARRAY
93274: IN
93275: IFFALSE 93898
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
93277: LD_ADDR_EXP 38
93281: PUSH
93282: LD_EXP 38
93286: PPUSH
93287: LD_VAR 0 3
93291: PPUSH
93292: LD_EXP 38
93296: PUSH
93297: LD_VAR 0 3
93301: ARRAY
93302: PUSH
93303: LD_VAR 0 1
93307: DIFF
93308: PPUSH
93309: CALL_OW 1
93313: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
93314: LD_ADDR_EXP 31
93318: PUSH
93319: LD_EXP 31
93323: PPUSH
93324: LD_VAR 0 3
93328: PUSH
93329: LD_EXP 31
93333: PUSH
93334: LD_VAR 0 3
93338: ARRAY
93339: PUSH
93340: LD_INT 1
93342: PLUS
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PPUSH
93348: LD_VAR 0 1
93352: PPUSH
93353: CALL 25097 0 3
93357: ST_TO_ADDR
// btype := GetBType ( building ) ;
93358: LD_ADDR_VAR 0 5
93362: PUSH
93363: LD_VAR 0 1
93367: PPUSH
93368: CALL_OW 266
93372: ST_TO_ADDR
// side := GetSide ( building ) ;
93373: LD_ADDR_VAR 0 8
93377: PUSH
93378: LD_VAR 0 1
93382: PPUSH
93383: CALL_OW 255
93387: ST_TO_ADDR
// if btype = b_lab then
93388: LD_VAR 0 5
93392: PUSH
93393: LD_INT 6
93395: EQUAL
93396: IFFALSE 93446
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
93398: LD_ADDR_EXP 64
93402: PUSH
93403: LD_EXP 64
93407: PPUSH
93408: LD_VAR 0 3
93412: PUSH
93413: LD_EXP 64
93417: PUSH
93418: LD_VAR 0 3
93422: ARRAY
93423: PUSH
93424: LD_INT 1
93426: PLUS
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PPUSH
93432: LD_VAR 0 1
93436: PPUSH
93437: CALL 25097 0 3
93441: ST_TO_ADDR
// exit ;
93442: POP
93443: POP
93444: GO 93902
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
93446: LD_VAR 0 5
93450: PUSH
93451: LD_INT 0
93453: PUSH
93454: LD_INT 2
93456: PUSH
93457: LD_INT 4
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: LIST
93464: IN
93465: IFFALSE 93589
// begin if btype = b_armoury then
93467: LD_VAR 0 5
93471: PUSH
93472: LD_INT 4
93474: EQUAL
93475: IFFALSE 93485
// btype := b_barracks ;
93477: LD_ADDR_VAR 0 5
93481: PUSH
93482: LD_INT 5
93484: ST_TO_ADDR
// if btype = b_depot then
93485: LD_VAR 0 5
93489: PUSH
93490: LD_INT 0
93492: EQUAL
93493: IFFALSE 93503
// btype := b_warehouse ;
93495: LD_ADDR_VAR 0 5
93499: PUSH
93500: LD_INT 1
93502: ST_TO_ADDR
// if btype = b_workshop then
93503: LD_VAR 0 5
93507: PUSH
93508: LD_INT 2
93510: EQUAL
93511: IFFALSE 93521
// btype := b_factory ;
93513: LD_ADDR_VAR 0 5
93517: PUSH
93518: LD_INT 3
93520: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
93521: LD_VAR 0 5
93525: PPUSH
93526: LD_VAR 0 8
93530: PPUSH
93531: CALL_OW 323
93535: PUSH
93536: LD_INT 1
93538: EQUAL
93539: IFFALSE 93585
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
93541: LD_ADDR_EXP 63
93545: PUSH
93546: LD_EXP 63
93550: PPUSH
93551: LD_VAR 0 3
93555: PUSH
93556: LD_EXP 63
93560: PUSH
93561: LD_VAR 0 3
93565: ARRAY
93566: PUSH
93567: LD_INT 1
93569: PLUS
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PPUSH
93575: LD_VAR 0 1
93579: PPUSH
93580: CALL 25097 0 3
93584: ST_TO_ADDR
// exit ;
93585: POP
93586: POP
93587: GO 93902
// end ; if btype in [ b_bunker , b_turret ] then
93589: LD_VAR 0 5
93593: PUSH
93594: LD_INT 32
93596: PUSH
93597: LD_INT 33
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: IN
93604: IFFALSE 93894
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
93606: LD_ADDR_EXP 39
93610: PUSH
93611: LD_EXP 39
93615: PPUSH
93616: LD_VAR 0 3
93620: PUSH
93621: LD_EXP 39
93625: PUSH
93626: LD_VAR 0 3
93630: ARRAY
93631: PUSH
93632: LD_INT 1
93634: PLUS
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PPUSH
93640: LD_VAR 0 1
93644: PPUSH
93645: CALL 25097 0 3
93649: ST_TO_ADDR
// if btype = b_bunker then
93650: LD_VAR 0 5
93654: PUSH
93655: LD_INT 32
93657: EQUAL
93658: IFFALSE 93894
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
93660: LD_ADDR_EXP 40
93664: PUSH
93665: LD_EXP 40
93669: PPUSH
93670: LD_VAR 0 3
93674: PUSH
93675: LD_EXP 40
93679: PUSH
93680: LD_VAR 0 3
93684: ARRAY
93685: PUSH
93686: LD_INT 1
93688: PLUS
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PPUSH
93694: LD_VAR 0 1
93698: PPUSH
93699: CALL 25097 0 3
93703: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
93704: LD_ADDR_VAR 0 6
93708: PUSH
93709: LD_EXP 31
93713: PUSH
93714: LD_VAR 0 3
93718: ARRAY
93719: PPUSH
93720: LD_INT 25
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 3
93732: PUSH
93733: LD_INT 54
93735: PUSH
93736: EMPTY
93737: LIST
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PPUSH
93747: CALL_OW 72
93751: ST_TO_ADDR
// if tmp then
93752: LD_VAR 0 6
93756: IFFALSE 93762
// exit ;
93758: POP
93759: POP
93760: GO 93902
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93762: LD_ADDR_VAR 0 6
93766: PUSH
93767: LD_EXP 31
93771: PUSH
93772: LD_VAR 0 3
93776: ARRAY
93777: PPUSH
93778: LD_INT 2
93780: PUSH
93781: LD_INT 30
93783: PUSH
93784: LD_INT 4
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 30
93793: PUSH
93794: LD_INT 5
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: LIST
93805: PPUSH
93806: CALL_OW 72
93810: ST_TO_ADDR
// if not tmp then
93811: LD_VAR 0 6
93815: NOT
93816: IFFALSE 93822
// exit ;
93818: POP
93819: POP
93820: GO 93902
// for j in tmp do
93822: LD_ADDR_VAR 0 4
93826: PUSH
93827: LD_VAR 0 6
93831: PUSH
93832: FOR_IN
93833: IFFALSE 93892
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
93835: LD_ADDR_VAR 0 7
93839: PUSH
93840: LD_VAR 0 4
93844: PPUSH
93845: CALL_OW 313
93849: PPUSH
93850: LD_INT 25
93852: PUSH
93853: LD_INT 1
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PPUSH
93860: CALL_OW 72
93864: ST_TO_ADDR
// if units then
93865: LD_VAR 0 7
93869: IFFALSE 93890
// begin ComExitBuilding ( units [ 1 ] ) ;
93871: LD_VAR 0 7
93875: PUSH
93876: LD_INT 1
93878: ARRAY
93879: PPUSH
93880: CALL_OW 122
// exit ;
93884: POP
93885: POP
93886: POP
93887: POP
93888: GO 93902
// end ; end ;
93890: GO 93832
93892: POP
93893: POP
// end ; end ; exit ;
93894: POP
93895: POP
93896: GO 93902
// end ; end ;
93898: GO 93256
93900: POP
93901: POP
// end ;
93902: LD_VAR 0 2
93906: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
93907: LD_INT 0
93909: PPUSH
93910: PPUSH
93911: PPUSH
93912: PPUSH
93913: PPUSH
93914: PPUSH
93915: PPUSH
// if not mc_bases or not skirmish then
93916: LD_EXP 31
93920: NOT
93921: IFTRUE 93930
93923: PUSH
93924: LD_EXP 29
93928: NOT
93929: OR
93930: IFFALSE 93934
// exit ;
93932: GO 94199
// btype := GetBType ( building ) ;
93934: LD_ADDR_VAR 0 6
93938: PUSH
93939: LD_VAR 0 1
93943: PPUSH
93944: CALL_OW 266
93948: ST_TO_ADDR
// x := GetX ( building ) ;
93949: LD_ADDR_VAR 0 7
93953: PUSH
93954: LD_VAR 0 1
93958: PPUSH
93959: CALL_OW 250
93963: ST_TO_ADDR
// y := GetY ( building ) ;
93964: LD_ADDR_VAR 0 8
93968: PUSH
93969: LD_VAR 0 1
93973: PPUSH
93974: CALL_OW 251
93978: ST_TO_ADDR
// d := GetDir ( building ) ;
93979: LD_ADDR_VAR 0 9
93983: PUSH
93984: LD_VAR 0 1
93988: PPUSH
93989: CALL_OW 254
93993: ST_TO_ADDR
// for i = 1 to mc_bases do
93994: LD_ADDR_VAR 0 4
93998: PUSH
93999: DOUBLE
94000: LD_INT 1
94002: DEC
94003: ST_TO_ADDR
94004: LD_EXP 31
94008: PUSH
94009: FOR_TO
94010: IFFALSE 94197
// begin if not mc_build_list [ i ] then
94012: LD_EXP 36
94016: PUSH
94017: LD_VAR 0 4
94021: ARRAY
94022: NOT
94023: IFFALSE 94027
// continue ;
94025: GO 94009
// for j := 1 to mc_build_list [ i ] do
94027: LD_ADDR_VAR 0 5
94031: PUSH
94032: DOUBLE
94033: LD_INT 1
94035: DEC
94036: ST_TO_ADDR
94037: LD_EXP 36
94041: PUSH
94042: LD_VAR 0 4
94046: ARRAY
94047: PUSH
94048: FOR_TO
94049: IFFALSE 94193
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
94051: LD_VAR 0 6
94055: PUSH
94056: LD_VAR 0 7
94060: PUSH
94061: LD_VAR 0 8
94065: PUSH
94066: LD_VAR 0 9
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: PPUSH
94077: LD_EXP 36
94081: PUSH
94082: LD_VAR 0 4
94086: ARRAY
94087: PUSH
94088: LD_VAR 0 5
94092: ARRAY
94093: PPUSH
94094: CALL 31704 0 2
94098: IFFALSE 94191
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
94100: LD_ADDR_EXP 36
94104: PUSH
94105: LD_EXP 36
94109: PPUSH
94110: LD_VAR 0 4
94114: PPUSH
94115: LD_EXP 36
94119: PUSH
94120: LD_VAR 0 4
94124: ARRAY
94125: PPUSH
94126: LD_VAR 0 5
94130: PPUSH
94131: CALL_OW 3
94135: PPUSH
94136: CALL_OW 1
94140: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
94141: LD_ADDR_EXP 38
94145: PUSH
94146: LD_EXP 38
94150: PPUSH
94151: LD_VAR 0 4
94155: PUSH
94156: LD_EXP 38
94160: PUSH
94161: LD_VAR 0 4
94165: ARRAY
94166: PUSH
94167: LD_INT 1
94169: PLUS
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PPUSH
94175: LD_VAR 0 1
94179: PPUSH
94180: CALL 25097 0 3
94184: ST_TO_ADDR
// exit ;
94185: POP
94186: POP
94187: POP
94188: POP
94189: GO 94199
// end ;
94191: GO 94048
94193: POP
94194: POP
// end ;
94195: GO 94009
94197: POP
94198: POP
// end ;
94199: LD_VAR 0 3
94203: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
94204: LD_INT 0
94206: PPUSH
94207: PPUSH
94208: PPUSH
// if not mc_bases or not skirmish then
94209: LD_EXP 31
94213: NOT
94214: IFTRUE 94223
94216: PUSH
94217: LD_EXP 29
94221: NOT
94222: OR
94223: IFFALSE 94227
// exit ;
94225: GO 94423
// for i = 1 to mc_bases do
94227: LD_ADDR_VAR 0 4
94231: PUSH
94232: DOUBLE
94233: LD_INT 1
94235: DEC
94236: ST_TO_ADDR
94237: LD_EXP 31
94241: PUSH
94242: FOR_TO
94243: IFFALSE 94332
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
94245: LD_VAR 0 1
94249: PUSH
94250: LD_EXP 39
94254: PUSH
94255: LD_VAR 0 4
94259: ARRAY
94260: IN
94261: IFFALSE 94282
94263: PUSH
94264: LD_VAR 0 1
94268: PUSH
94269: LD_EXP 40
94273: PUSH
94274: LD_VAR 0 4
94278: ARRAY
94279: IN
94280: NOT
94281: AND
94282: IFFALSE 94330
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
94284: LD_ADDR_EXP 40
94288: PUSH
94289: LD_EXP 40
94293: PPUSH
94294: LD_VAR 0 4
94298: PUSH
94299: LD_EXP 40
94303: PUSH
94304: LD_VAR 0 4
94308: ARRAY
94309: PUSH
94310: LD_INT 1
94312: PLUS
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PPUSH
94318: LD_VAR 0 1
94322: PPUSH
94323: CALL 25097 0 3
94327: ST_TO_ADDR
// break ;
94328: GO 94332
// end ; end ;
94330: GO 94242
94332: POP
94333: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
94334: LD_VAR 0 1
94338: PPUSH
94339: CALL_OW 257
94343: PUSH
94344: LD_EXP 57
94348: IN
94349: IFFALSE 94366
94351: PUSH
94352: LD_VAR 0 1
94356: PPUSH
94357: CALL_OW 266
94361: PUSH
94362: LD_INT 5
94364: EQUAL
94365: AND
94366: IFFALSE 94383
94368: PUSH
94369: LD_VAR 0 2
94373: PPUSH
94374: CALL_OW 110
94378: PUSH
94379: LD_INT 18
94381: NONEQUAL
94382: AND
94383: IFFALSE 94423
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
94385: LD_VAR 0 2
94389: PPUSH
94390: CALL_OW 257
94394: PUSH
94395: LD_INT 5
94397: PUSH
94398: LD_INT 8
94400: PUSH
94401: LD_INT 9
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: LIST
94408: IN
94409: IFFALSE 94423
// SetClass ( unit , 1 ) ;
94411: LD_VAR 0 2
94415: PPUSH
94416: LD_INT 1
94418: PPUSH
94419: CALL_OW 336
// end ;
94423: LD_VAR 0 3
94427: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
94428: LD_INT 0
94430: PPUSH
94431: PPUSH
// if not mc_bases or not skirmish then
94432: LD_EXP 31
94436: NOT
94437: IFTRUE 94446
94439: PUSH
94440: LD_EXP 29
94444: NOT
94445: OR
94446: IFFALSE 94450
// exit ;
94448: GO 94566
// if GetLives ( abandoned_vehicle ) > 250 then
94450: LD_VAR 0 2
94454: PPUSH
94455: CALL_OW 256
94459: PUSH
94460: LD_INT 250
94462: GREATER
94463: IFFALSE 94467
// exit ;
94465: GO 94566
// for i = 1 to mc_bases do
94467: LD_ADDR_VAR 0 6
94471: PUSH
94472: DOUBLE
94473: LD_INT 1
94475: DEC
94476: ST_TO_ADDR
94477: LD_EXP 31
94481: PUSH
94482: FOR_TO
94483: IFFALSE 94564
// begin if driver in mc_bases [ i ] then
94485: LD_VAR 0 1
94489: PUSH
94490: LD_EXP 31
94494: PUSH
94495: LD_VAR 0 6
94499: ARRAY
94500: IN
94501: IFFALSE 94562
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
94503: LD_VAR 0 1
94507: PPUSH
94508: LD_EXP 31
94512: PUSH
94513: LD_VAR 0 6
94517: ARRAY
94518: PPUSH
94519: LD_INT 2
94521: PUSH
94522: LD_INT 30
94524: PUSH
94525: LD_INT 0
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 30
94534: PUSH
94535: LD_INT 1
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: LIST
94546: PPUSH
94547: CALL_OW 72
94551: PUSH
94552: LD_INT 1
94554: ARRAY
94555: PPUSH
94556: CALL 59034 0 2
// break ;
94560: GO 94564
// end ; end ;
94562: GO 94482
94564: POP
94565: POP
// end ; end_of_file end_of_file
94566: LD_VAR 0 5
94570: RET
// export globalGameSaveCounter ; every 0 0$1 do
94571: GO 94573
94573: DISABLE
// begin enable ;
94574: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94575: LD_STRING updateTimer(
94577: PUSH
94578: LD_OWVAR 1
94582: STR
94583: PUSH
94584: LD_STRING );
94586: STR
94587: PPUSH
94588: CALL_OW 559
// end ;
94592: END
// every 0 0$1 do
94593: GO 94595
94595: DISABLE
// begin globalGameSaveCounter := 0 ;
94596: LD_ADDR_EXP 76
94600: PUSH
94601: LD_INT 0
94603: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94604: LD_STRING setGameSaveCounter(0)
94606: PPUSH
94607: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94611: LD_STRING initStreamRollete();
94613: PPUSH
94614: CALL_OW 559
// InitStreamMode ;
94618: CALL 95970 0 0
// DefineStreamItems ( false ) ;
94622: LD_INT 0
94624: PPUSH
94625: CALL 96434 0 1
// end ;
94629: END
// export function SOS_MapStart ( ) ; begin
94630: LD_INT 0
94632: PPUSH
// if streamModeActive then
94633: LD_EXP 77
94637: IFFALSE 94646
// DefineStreamItems ( true ) ;
94639: LD_INT 1
94641: PPUSH
94642: CALL 96434 0 1
// ToLua ( LFC_UNITS_CUSTOM_ICON = {}; ) ;
94646: LD_STRING LFC_UNITS_CUSTOM_ICON = {};
94648: PPUSH
94649: CALL_OW 559
// UpdateLuaVariables ( ) ;
94653: CALL 94670 0 0
// UpdateFactoryWaypoints ( ) ;
94657: CALL 109556 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94661: CALL 109808 0 0
// end ;
94665: LD_VAR 0 1
94669: RET
// function UpdateLuaVariables ( ) ; begin
94670: LD_INT 0
94672: PPUSH
// if globalGameSaveCounter then
94673: LD_EXP 76
94677: IFFALSE 94711
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94679: LD_ADDR_EXP 76
94683: PUSH
94684: LD_EXP 76
94688: PPUSH
94689: CALL 59528 0 1
94693: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94694: LD_STRING setGameSaveCounter(
94696: PUSH
94697: LD_EXP 76
94701: STR
94702: PUSH
94703: LD_STRING )
94705: STR
94706: PPUSH
94707: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94711: LD_STRING setGameDifficulty(
94713: PUSH
94714: LD_OWVAR 67
94718: STR
94719: PUSH
94720: LD_STRING )
94722: STR
94723: PPUSH
94724: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
94728: LD_STRING displayDifficulty(
94730: PUSH
94731: LD_OWVAR 67
94735: STR
94736: PUSH
94737: LD_STRING )
94739: STR
94740: PPUSH
94741: CALL_OW 559
// end ;
94745: LD_VAR 0 1
94749: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94750: LD_INT 0
94752: PPUSH
// if p2 = stream_mode then
94753: LD_VAR 0 2
94757: PUSH
94758: LD_INT 100
94760: EQUAL
94761: IFFALSE 95764
// begin if not StreamModeActive then
94763: LD_EXP 77
94767: NOT
94768: IFFALSE 94778
// StreamModeActive := true ;
94770: LD_ADDR_EXP 77
94774: PUSH
94775: LD_INT 1
94777: ST_TO_ADDR
// if p3 = 0 then
94778: LD_VAR 0 3
94782: PUSH
94783: LD_INT 0
94785: EQUAL
94786: IFFALSE 94792
// InitStreamMode ;
94788: CALL 95970 0 0
// if p3 = 1 then
94792: LD_VAR 0 3
94796: PUSH
94797: LD_INT 1
94799: EQUAL
94800: IFFALSE 94810
// sRocket := true ;
94802: LD_ADDR_EXP 82
94806: PUSH
94807: LD_INT 1
94809: ST_TO_ADDR
// if p3 = 2 then
94810: LD_VAR 0 3
94814: PUSH
94815: LD_INT 2
94817: EQUAL
94818: IFFALSE 94828
// sSpeed := true ;
94820: LD_ADDR_EXP 81
94824: PUSH
94825: LD_INT 1
94827: ST_TO_ADDR
// if p3 = 3 then
94828: LD_VAR 0 3
94832: PUSH
94833: LD_INT 3
94835: EQUAL
94836: IFFALSE 94846
// sEngine := true ;
94838: LD_ADDR_EXP 83
94842: PUSH
94843: LD_INT 1
94845: ST_TO_ADDR
// if p3 = 4 then
94846: LD_VAR 0 3
94850: PUSH
94851: LD_INT 4
94853: EQUAL
94854: IFFALSE 94864
// sSpec := true ;
94856: LD_ADDR_EXP 80
94860: PUSH
94861: LD_INT 1
94863: ST_TO_ADDR
// if p3 = 5 then
94864: LD_VAR 0 3
94868: PUSH
94869: LD_INT 5
94871: EQUAL
94872: IFFALSE 94882
// sLevel := true ;
94874: LD_ADDR_EXP 84
94878: PUSH
94879: LD_INT 1
94881: ST_TO_ADDR
// if p3 = 6 then
94882: LD_VAR 0 3
94886: PUSH
94887: LD_INT 6
94889: EQUAL
94890: IFFALSE 94900
// sArmoury := true ;
94892: LD_ADDR_EXP 85
94896: PUSH
94897: LD_INT 1
94899: ST_TO_ADDR
// if p3 = 7 then
94900: LD_VAR 0 3
94904: PUSH
94905: LD_INT 7
94907: EQUAL
94908: IFFALSE 94918
// sRadar := true ;
94910: LD_ADDR_EXP 86
94914: PUSH
94915: LD_INT 1
94917: ST_TO_ADDR
// if p3 = 8 then
94918: LD_VAR 0 3
94922: PUSH
94923: LD_INT 8
94925: EQUAL
94926: IFFALSE 94936
// sBunker := true ;
94928: LD_ADDR_EXP 87
94932: PUSH
94933: LD_INT 1
94935: ST_TO_ADDR
// if p3 = 9 then
94936: LD_VAR 0 3
94940: PUSH
94941: LD_INT 9
94943: EQUAL
94944: IFFALSE 94954
// sHack := true ;
94946: LD_ADDR_EXP 88
94950: PUSH
94951: LD_INT 1
94953: ST_TO_ADDR
// if p3 = 10 then
94954: LD_VAR 0 3
94958: PUSH
94959: LD_INT 10
94961: EQUAL
94962: IFFALSE 94972
// sFire := true ;
94964: LD_ADDR_EXP 89
94968: PUSH
94969: LD_INT 1
94971: ST_TO_ADDR
// if p3 = 11 then
94972: LD_VAR 0 3
94976: PUSH
94977: LD_INT 11
94979: EQUAL
94980: IFFALSE 94990
// sRefresh := true ;
94982: LD_ADDR_EXP 90
94986: PUSH
94987: LD_INT 1
94989: ST_TO_ADDR
// if p3 = 12 then
94990: LD_VAR 0 3
94994: PUSH
94995: LD_INT 12
94997: EQUAL
94998: IFFALSE 95008
// sExp := true ;
95000: LD_ADDR_EXP 91
95004: PUSH
95005: LD_INT 1
95007: ST_TO_ADDR
// if p3 = 13 then
95008: LD_VAR 0 3
95012: PUSH
95013: LD_INT 13
95015: EQUAL
95016: IFFALSE 95026
// sDepot := true ;
95018: LD_ADDR_EXP 92
95022: PUSH
95023: LD_INT 1
95025: ST_TO_ADDR
// if p3 = 14 then
95026: LD_VAR 0 3
95030: PUSH
95031: LD_INT 14
95033: EQUAL
95034: IFFALSE 95044
// sFlag := true ;
95036: LD_ADDR_EXP 93
95040: PUSH
95041: LD_INT 1
95043: ST_TO_ADDR
// if p3 = 15 then
95044: LD_VAR 0 3
95048: PUSH
95049: LD_INT 15
95051: EQUAL
95052: IFFALSE 95062
// sKamikadze := true ;
95054: LD_ADDR_EXP 101
95058: PUSH
95059: LD_INT 1
95061: ST_TO_ADDR
// if p3 = 16 then
95062: LD_VAR 0 3
95066: PUSH
95067: LD_INT 16
95069: EQUAL
95070: IFFALSE 95080
// sTroll := true ;
95072: LD_ADDR_EXP 102
95076: PUSH
95077: LD_INT 1
95079: ST_TO_ADDR
// if p3 = 17 then
95080: LD_VAR 0 3
95084: PUSH
95085: LD_INT 17
95087: EQUAL
95088: IFFALSE 95098
// sSlow := true ;
95090: LD_ADDR_EXP 103
95094: PUSH
95095: LD_INT 1
95097: ST_TO_ADDR
// if p3 = 18 then
95098: LD_VAR 0 3
95102: PUSH
95103: LD_INT 18
95105: EQUAL
95106: IFFALSE 95116
// sLack := true ;
95108: LD_ADDR_EXP 104
95112: PUSH
95113: LD_INT 1
95115: ST_TO_ADDR
// if p3 = 19 then
95116: LD_VAR 0 3
95120: PUSH
95121: LD_INT 19
95123: EQUAL
95124: IFFALSE 95134
// sTank := true ;
95126: LD_ADDR_EXP 106
95130: PUSH
95131: LD_INT 1
95133: ST_TO_ADDR
// if p3 = 20 then
95134: LD_VAR 0 3
95138: PUSH
95139: LD_INT 20
95141: EQUAL
95142: IFFALSE 95152
// sRemote := true ;
95144: LD_ADDR_EXP 107
95148: PUSH
95149: LD_INT 1
95151: ST_TO_ADDR
// if p3 = 21 then
95152: LD_VAR 0 3
95156: PUSH
95157: LD_INT 21
95159: EQUAL
95160: IFFALSE 95170
// sPowell := true ;
95162: LD_ADDR_EXP 108
95166: PUSH
95167: LD_INT 1
95169: ST_TO_ADDR
// if p3 = 22 then
95170: LD_VAR 0 3
95174: PUSH
95175: LD_INT 22
95177: EQUAL
95178: IFFALSE 95188
// sTeleport := true ;
95180: LD_ADDR_EXP 111
95184: PUSH
95185: LD_INT 1
95187: ST_TO_ADDR
// if p3 = 23 then
95188: LD_VAR 0 3
95192: PUSH
95193: LD_INT 23
95195: EQUAL
95196: IFFALSE 95206
// sOilTower := true ;
95198: LD_ADDR_EXP 113
95202: PUSH
95203: LD_INT 1
95205: ST_TO_ADDR
// if p3 = 24 then
95206: LD_VAR 0 3
95210: PUSH
95211: LD_INT 24
95213: EQUAL
95214: IFFALSE 95224
// sShovel := true ;
95216: LD_ADDR_EXP 114
95220: PUSH
95221: LD_INT 1
95223: ST_TO_ADDR
// if p3 = 25 then
95224: LD_VAR 0 3
95228: PUSH
95229: LD_INT 25
95231: EQUAL
95232: IFFALSE 95242
// sSheik := true ;
95234: LD_ADDR_EXP 115
95238: PUSH
95239: LD_INT 1
95241: ST_TO_ADDR
// if p3 = 26 then
95242: LD_VAR 0 3
95246: PUSH
95247: LD_INT 26
95249: EQUAL
95250: IFFALSE 95260
// sEarthquake := true ;
95252: LD_ADDR_EXP 117
95256: PUSH
95257: LD_INT 1
95259: ST_TO_ADDR
// if p3 = 27 then
95260: LD_VAR 0 3
95264: PUSH
95265: LD_INT 27
95267: EQUAL
95268: IFFALSE 95278
// sAI := true ;
95270: LD_ADDR_EXP 118
95274: PUSH
95275: LD_INT 1
95277: ST_TO_ADDR
// if p3 = 28 then
95278: LD_VAR 0 3
95282: PUSH
95283: LD_INT 28
95285: EQUAL
95286: IFFALSE 95296
// sCargo := true ;
95288: LD_ADDR_EXP 121
95292: PUSH
95293: LD_INT 1
95295: ST_TO_ADDR
// if p3 = 29 then
95296: LD_VAR 0 3
95300: PUSH
95301: LD_INT 29
95303: EQUAL
95304: IFFALSE 95314
// sDLaser := true ;
95306: LD_ADDR_EXP 122
95310: PUSH
95311: LD_INT 1
95313: ST_TO_ADDR
// if p3 = 30 then
95314: LD_VAR 0 3
95318: PUSH
95319: LD_INT 30
95321: EQUAL
95322: IFFALSE 95332
// sExchange := true ;
95324: LD_ADDR_EXP 123
95328: PUSH
95329: LD_INT 1
95331: ST_TO_ADDR
// if p3 = 31 then
95332: LD_VAR 0 3
95336: PUSH
95337: LD_INT 31
95339: EQUAL
95340: IFFALSE 95350
// sFac := true ;
95342: LD_ADDR_EXP 124
95346: PUSH
95347: LD_INT 1
95349: ST_TO_ADDR
// if p3 = 32 then
95350: LD_VAR 0 3
95354: PUSH
95355: LD_INT 32
95357: EQUAL
95358: IFFALSE 95368
// sPower := true ;
95360: LD_ADDR_EXP 125
95364: PUSH
95365: LD_INT 1
95367: ST_TO_ADDR
// if p3 = 33 then
95368: LD_VAR 0 3
95372: PUSH
95373: LD_INT 33
95375: EQUAL
95376: IFFALSE 95386
// sRandom := true ;
95378: LD_ADDR_EXP 126
95382: PUSH
95383: LD_INT 1
95385: ST_TO_ADDR
// if p3 = 34 then
95386: LD_VAR 0 3
95390: PUSH
95391: LD_INT 34
95393: EQUAL
95394: IFFALSE 95404
// sShield := true ;
95396: LD_ADDR_EXP 127
95400: PUSH
95401: LD_INT 1
95403: ST_TO_ADDR
// if p3 = 35 then
95404: LD_VAR 0 3
95408: PUSH
95409: LD_INT 35
95411: EQUAL
95412: IFFALSE 95422
// sTime := true ;
95414: LD_ADDR_EXP 128
95418: PUSH
95419: LD_INT 1
95421: ST_TO_ADDR
// if p3 = 36 then
95422: LD_VAR 0 3
95426: PUSH
95427: LD_INT 36
95429: EQUAL
95430: IFFALSE 95440
// sTools := true ;
95432: LD_ADDR_EXP 129
95436: PUSH
95437: LD_INT 1
95439: ST_TO_ADDR
// if p3 = 101 then
95440: LD_VAR 0 3
95444: PUSH
95445: LD_INT 101
95447: EQUAL
95448: IFFALSE 95458
// sSold := true ;
95450: LD_ADDR_EXP 94
95454: PUSH
95455: LD_INT 1
95457: ST_TO_ADDR
// if p3 = 102 then
95458: LD_VAR 0 3
95462: PUSH
95463: LD_INT 102
95465: EQUAL
95466: IFFALSE 95476
// sDiff := true ;
95468: LD_ADDR_EXP 95
95472: PUSH
95473: LD_INT 1
95475: ST_TO_ADDR
// if p3 = 103 then
95476: LD_VAR 0 3
95480: PUSH
95481: LD_INT 103
95483: EQUAL
95484: IFFALSE 95494
// sFog := true ;
95486: LD_ADDR_EXP 98
95490: PUSH
95491: LD_INT 1
95493: ST_TO_ADDR
// if p3 = 104 then
95494: LD_VAR 0 3
95498: PUSH
95499: LD_INT 104
95501: EQUAL
95502: IFFALSE 95512
// sReset := true ;
95504: LD_ADDR_EXP 99
95508: PUSH
95509: LD_INT 1
95511: ST_TO_ADDR
// if p3 = 105 then
95512: LD_VAR 0 3
95516: PUSH
95517: LD_INT 105
95519: EQUAL
95520: IFFALSE 95530
// sSun := true ;
95522: LD_ADDR_EXP 100
95526: PUSH
95527: LD_INT 1
95529: ST_TO_ADDR
// if p3 = 106 then
95530: LD_VAR 0 3
95534: PUSH
95535: LD_INT 106
95537: EQUAL
95538: IFFALSE 95548
// sTiger := true ;
95540: LD_ADDR_EXP 96
95544: PUSH
95545: LD_INT 1
95547: ST_TO_ADDR
// if p3 = 107 then
95548: LD_VAR 0 3
95552: PUSH
95553: LD_INT 107
95555: EQUAL
95556: IFFALSE 95566
// sBomb := true ;
95558: LD_ADDR_EXP 97
95562: PUSH
95563: LD_INT 1
95565: ST_TO_ADDR
// if p3 = 108 then
95566: LD_VAR 0 3
95570: PUSH
95571: LD_INT 108
95573: EQUAL
95574: IFFALSE 95584
// sWound := true ;
95576: LD_ADDR_EXP 105
95580: PUSH
95581: LD_INT 1
95583: ST_TO_ADDR
// if p3 = 109 then
95584: LD_VAR 0 3
95588: PUSH
95589: LD_INT 109
95591: EQUAL
95592: IFFALSE 95602
// sBetray := true ;
95594: LD_ADDR_EXP 109
95598: PUSH
95599: LD_INT 1
95601: ST_TO_ADDR
// if p3 = 110 then
95602: LD_VAR 0 3
95606: PUSH
95607: LD_INT 110
95609: EQUAL
95610: IFFALSE 95620
// sContamin := true ;
95612: LD_ADDR_EXP 110
95616: PUSH
95617: LD_INT 1
95619: ST_TO_ADDR
// if p3 = 111 then
95620: LD_VAR 0 3
95624: PUSH
95625: LD_INT 111
95627: EQUAL
95628: IFFALSE 95638
// sOil := true ;
95630: LD_ADDR_EXP 112
95634: PUSH
95635: LD_INT 1
95637: ST_TO_ADDR
// if p3 = 112 then
95638: LD_VAR 0 3
95642: PUSH
95643: LD_INT 112
95645: EQUAL
95646: IFFALSE 95656
// sStu := true ;
95648: LD_ADDR_EXP 116
95652: PUSH
95653: LD_INT 1
95655: ST_TO_ADDR
// if p3 = 113 then
95656: LD_VAR 0 3
95660: PUSH
95661: LD_INT 113
95663: EQUAL
95664: IFFALSE 95674
// sBazooka := true ;
95666: LD_ADDR_EXP 119
95670: PUSH
95671: LD_INT 1
95673: ST_TO_ADDR
// if p3 = 114 then
95674: LD_VAR 0 3
95678: PUSH
95679: LD_INT 114
95681: EQUAL
95682: IFFALSE 95692
// sMortar := true ;
95684: LD_ADDR_EXP 120
95688: PUSH
95689: LD_INT 1
95691: ST_TO_ADDR
// if p3 = 115 then
95692: LD_VAR 0 3
95696: PUSH
95697: LD_INT 115
95699: EQUAL
95700: IFFALSE 95710
// sRanger := true ;
95702: LD_ADDR_EXP 130
95706: PUSH
95707: LD_INT 1
95709: ST_TO_ADDR
// if p3 = 116 then
95710: LD_VAR 0 3
95714: PUSH
95715: LD_INT 116
95717: EQUAL
95718: IFFALSE 95728
// sComputer := true ;
95720: LD_ADDR_EXP 131
95724: PUSH
95725: LD_INT 1
95727: ST_TO_ADDR
// if p3 = 117 then
95728: LD_VAR 0 3
95732: PUSH
95733: LD_INT 117
95735: EQUAL
95736: IFFALSE 95746
// s30 := true ;
95738: LD_ADDR_EXP 132
95742: PUSH
95743: LD_INT 1
95745: ST_TO_ADDR
// if p3 = 118 then
95746: LD_VAR 0 3
95750: PUSH
95751: LD_INT 118
95753: EQUAL
95754: IFFALSE 95764
// s60 := true ;
95756: LD_ADDR_EXP 133
95760: PUSH
95761: LD_INT 1
95763: ST_TO_ADDR
// end ; if p2 = hack_mode then
95764: LD_VAR 0 2
95768: PUSH
95769: LD_INT 101
95771: EQUAL
95772: IFFALSE 95900
// begin case p3 of 1 :
95774: LD_VAR 0 3
95778: PUSH
95779: LD_INT 1
95781: DOUBLE
95782: EQUAL
95783: IFTRUE 95787
95785: GO 95794
95787: POP
// hHackUnlimitedResources ; 2 :
95788: CALL 108163 0 0
95792: GO 95900
95794: LD_INT 2
95796: DOUBLE
95797: EQUAL
95798: IFTRUE 95802
95800: GO 95809
95802: POP
// hHackSetLevel10 ; 3 :
95803: CALL 108296 0 0
95807: GO 95900
95809: LD_INT 3
95811: DOUBLE
95812: EQUAL
95813: IFTRUE 95817
95815: GO 95824
95817: POP
// hHackSetLevel10YourUnits ; 4 :
95818: CALL 108381 0 0
95822: GO 95900
95824: LD_INT 4
95826: DOUBLE
95827: EQUAL
95828: IFTRUE 95832
95830: GO 95839
95832: POP
// hHackInvincible ; 5 :
95833: CALL 108829 0 0
95837: GO 95900
95839: LD_INT 5
95841: DOUBLE
95842: EQUAL
95843: IFTRUE 95847
95845: GO 95854
95847: POP
// hHackInvisible ; 6 :
95848: CALL 108940 0 0
95852: GO 95900
95854: LD_INT 6
95856: DOUBLE
95857: EQUAL
95858: IFTRUE 95862
95860: GO 95869
95862: POP
// hHackChangeYourSide ; 7 :
95863: CALL 108997 0 0
95867: GO 95900
95869: LD_INT 7
95871: DOUBLE
95872: EQUAL
95873: IFTRUE 95877
95875: GO 95884
95877: POP
// hHackChangeUnitSide ; 8 :
95878: CALL 109039 0 0
95882: GO 95900
95884: LD_INT 8
95886: DOUBLE
95887: EQUAL
95888: IFTRUE 95892
95890: GO 95899
95892: POP
// hHackFog ; end ;
95893: CALL 109140 0 0
95897: GO 95900
95899: POP
// end ; if p2 = game_save_mode then
95900: LD_VAR 0 2
95904: PUSH
95905: LD_INT 102
95907: EQUAL
95908: IFFALSE 95965
// begin if p3 = 1 then
95910: LD_VAR 0 3
95914: PUSH
95915: LD_INT 1
95917: EQUAL
95918: IFFALSE 95930
// globalGameSaveCounter := p4 ;
95920: LD_ADDR_EXP 76
95924: PUSH
95925: LD_VAR 0 4
95929: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95930: LD_VAR 0 3
95934: PUSH
95935: LD_INT 2
95937: EQUAL
95938: IFFALSE 95946
95940: PUSH
95941: LD_EXP 76
95945: AND
95946: IFFALSE 95965
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95948: LD_STRING setGameSaveCounter(
95950: PUSH
95951: LD_EXP 76
95955: STR
95956: PUSH
95957: LD_STRING )
95959: STR
95960: PPUSH
95961: CALL_OW 559
// end ; end ;
95965: LD_VAR 0 7
95969: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95970: LD_INT 0
95972: PPUSH
// streamModeActive := false ;
95973: LD_ADDR_EXP 77
95977: PUSH
95978: LD_INT 0
95980: ST_TO_ADDR
// normalCounter := 36 ;
95981: LD_ADDR_EXP 78
95985: PUSH
95986: LD_INT 36
95988: ST_TO_ADDR
// hardcoreCounter := 18 ;
95989: LD_ADDR_EXP 79
95993: PUSH
95994: LD_INT 18
95996: ST_TO_ADDR
// sRocket := false ;
95997: LD_ADDR_EXP 82
96001: PUSH
96002: LD_INT 0
96004: ST_TO_ADDR
// sSpeed := false ;
96005: LD_ADDR_EXP 81
96009: PUSH
96010: LD_INT 0
96012: ST_TO_ADDR
// sEngine := false ;
96013: LD_ADDR_EXP 83
96017: PUSH
96018: LD_INT 0
96020: ST_TO_ADDR
// sSpec := false ;
96021: LD_ADDR_EXP 80
96025: PUSH
96026: LD_INT 0
96028: ST_TO_ADDR
// sLevel := false ;
96029: LD_ADDR_EXP 84
96033: PUSH
96034: LD_INT 0
96036: ST_TO_ADDR
// sArmoury := false ;
96037: LD_ADDR_EXP 85
96041: PUSH
96042: LD_INT 0
96044: ST_TO_ADDR
// sRadar := false ;
96045: LD_ADDR_EXP 86
96049: PUSH
96050: LD_INT 0
96052: ST_TO_ADDR
// sBunker := false ;
96053: LD_ADDR_EXP 87
96057: PUSH
96058: LD_INT 0
96060: ST_TO_ADDR
// sHack := false ;
96061: LD_ADDR_EXP 88
96065: PUSH
96066: LD_INT 0
96068: ST_TO_ADDR
// sFire := false ;
96069: LD_ADDR_EXP 89
96073: PUSH
96074: LD_INT 0
96076: ST_TO_ADDR
// sRefresh := false ;
96077: LD_ADDR_EXP 90
96081: PUSH
96082: LD_INT 0
96084: ST_TO_ADDR
// sExp := false ;
96085: LD_ADDR_EXP 91
96089: PUSH
96090: LD_INT 0
96092: ST_TO_ADDR
// sDepot := false ;
96093: LD_ADDR_EXP 92
96097: PUSH
96098: LD_INT 0
96100: ST_TO_ADDR
// sFlag := false ;
96101: LD_ADDR_EXP 93
96105: PUSH
96106: LD_INT 0
96108: ST_TO_ADDR
// sKamikadze := false ;
96109: LD_ADDR_EXP 101
96113: PUSH
96114: LD_INT 0
96116: ST_TO_ADDR
// sTroll := false ;
96117: LD_ADDR_EXP 102
96121: PUSH
96122: LD_INT 0
96124: ST_TO_ADDR
// sSlow := false ;
96125: LD_ADDR_EXP 103
96129: PUSH
96130: LD_INT 0
96132: ST_TO_ADDR
// sLack := false ;
96133: LD_ADDR_EXP 104
96137: PUSH
96138: LD_INT 0
96140: ST_TO_ADDR
// sTank := false ;
96141: LD_ADDR_EXP 106
96145: PUSH
96146: LD_INT 0
96148: ST_TO_ADDR
// sRemote := false ;
96149: LD_ADDR_EXP 107
96153: PUSH
96154: LD_INT 0
96156: ST_TO_ADDR
// sPowell := false ;
96157: LD_ADDR_EXP 108
96161: PUSH
96162: LD_INT 0
96164: ST_TO_ADDR
// sTeleport := false ;
96165: LD_ADDR_EXP 111
96169: PUSH
96170: LD_INT 0
96172: ST_TO_ADDR
// sOilTower := false ;
96173: LD_ADDR_EXP 113
96177: PUSH
96178: LD_INT 0
96180: ST_TO_ADDR
// sShovel := false ;
96181: LD_ADDR_EXP 114
96185: PUSH
96186: LD_INT 0
96188: ST_TO_ADDR
// sSheik := false ;
96189: LD_ADDR_EXP 115
96193: PUSH
96194: LD_INT 0
96196: ST_TO_ADDR
// sEarthquake := false ;
96197: LD_ADDR_EXP 117
96201: PUSH
96202: LD_INT 0
96204: ST_TO_ADDR
// sAI := false ;
96205: LD_ADDR_EXP 118
96209: PUSH
96210: LD_INT 0
96212: ST_TO_ADDR
// sCargo := false ;
96213: LD_ADDR_EXP 121
96217: PUSH
96218: LD_INT 0
96220: ST_TO_ADDR
// sDLaser := false ;
96221: LD_ADDR_EXP 122
96225: PUSH
96226: LD_INT 0
96228: ST_TO_ADDR
// sExchange := false ;
96229: LD_ADDR_EXP 123
96233: PUSH
96234: LD_INT 0
96236: ST_TO_ADDR
// sFac := false ;
96237: LD_ADDR_EXP 124
96241: PUSH
96242: LD_INT 0
96244: ST_TO_ADDR
// sPower := false ;
96245: LD_ADDR_EXP 125
96249: PUSH
96250: LD_INT 0
96252: ST_TO_ADDR
// sRandom := false ;
96253: LD_ADDR_EXP 126
96257: PUSH
96258: LD_INT 0
96260: ST_TO_ADDR
// sShield := false ;
96261: LD_ADDR_EXP 127
96265: PUSH
96266: LD_INT 0
96268: ST_TO_ADDR
// sTime := false ;
96269: LD_ADDR_EXP 128
96273: PUSH
96274: LD_INT 0
96276: ST_TO_ADDR
// sTools := false ;
96277: LD_ADDR_EXP 129
96281: PUSH
96282: LD_INT 0
96284: ST_TO_ADDR
// sSold := false ;
96285: LD_ADDR_EXP 94
96289: PUSH
96290: LD_INT 0
96292: ST_TO_ADDR
// sDiff := false ;
96293: LD_ADDR_EXP 95
96297: PUSH
96298: LD_INT 0
96300: ST_TO_ADDR
// sFog := false ;
96301: LD_ADDR_EXP 98
96305: PUSH
96306: LD_INT 0
96308: ST_TO_ADDR
// sReset := false ;
96309: LD_ADDR_EXP 99
96313: PUSH
96314: LD_INT 0
96316: ST_TO_ADDR
// sSun := false ;
96317: LD_ADDR_EXP 100
96321: PUSH
96322: LD_INT 0
96324: ST_TO_ADDR
// sTiger := false ;
96325: LD_ADDR_EXP 96
96329: PUSH
96330: LD_INT 0
96332: ST_TO_ADDR
// sBomb := false ;
96333: LD_ADDR_EXP 97
96337: PUSH
96338: LD_INT 0
96340: ST_TO_ADDR
// sWound := false ;
96341: LD_ADDR_EXP 105
96345: PUSH
96346: LD_INT 0
96348: ST_TO_ADDR
// sBetray := false ;
96349: LD_ADDR_EXP 109
96353: PUSH
96354: LD_INT 0
96356: ST_TO_ADDR
// sContamin := false ;
96357: LD_ADDR_EXP 110
96361: PUSH
96362: LD_INT 0
96364: ST_TO_ADDR
// sOil := false ;
96365: LD_ADDR_EXP 112
96369: PUSH
96370: LD_INT 0
96372: ST_TO_ADDR
// sStu := false ;
96373: LD_ADDR_EXP 116
96377: PUSH
96378: LD_INT 0
96380: ST_TO_ADDR
// sBazooka := false ;
96381: LD_ADDR_EXP 119
96385: PUSH
96386: LD_INT 0
96388: ST_TO_ADDR
// sMortar := false ;
96389: LD_ADDR_EXP 120
96393: PUSH
96394: LD_INT 0
96396: ST_TO_ADDR
// sRanger := false ;
96397: LD_ADDR_EXP 130
96401: PUSH
96402: LD_INT 0
96404: ST_TO_ADDR
// sComputer := false ;
96405: LD_ADDR_EXP 131
96409: PUSH
96410: LD_INT 0
96412: ST_TO_ADDR
// s30 := false ;
96413: LD_ADDR_EXP 132
96417: PUSH
96418: LD_INT 0
96420: ST_TO_ADDR
// s60 := false ;
96421: LD_ADDR_EXP 133
96425: PUSH
96426: LD_INT 0
96428: ST_TO_ADDR
// end ;
96429: LD_VAR 0 1
96433: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96434: LD_INT 0
96436: PPUSH
96437: PPUSH
96438: PPUSH
96439: PPUSH
96440: PPUSH
96441: PPUSH
96442: PPUSH
// result := [ ] ;
96443: LD_ADDR_VAR 0 2
96447: PUSH
96448: EMPTY
96449: ST_TO_ADDR
// if campaign_id = 1 then
96450: LD_OWVAR 69
96454: PUSH
96455: LD_INT 1
96457: EQUAL
96458: IFFALSE 99624
// begin case mission_number of 1 :
96460: LD_OWVAR 70
96464: PUSH
96465: LD_INT 1
96467: DOUBLE
96468: EQUAL
96469: IFTRUE 96473
96471: GO 96549
96473: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96474: LD_ADDR_VAR 0 2
96478: PUSH
96479: LD_INT 2
96481: PUSH
96482: LD_INT 4
96484: PUSH
96485: LD_INT 11
96487: PUSH
96488: LD_INT 12
96490: PUSH
96491: LD_INT 15
96493: PUSH
96494: LD_INT 16
96496: PUSH
96497: LD_INT 22
96499: PUSH
96500: LD_INT 23
96502: PUSH
96503: LD_INT 26
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 101
96519: PUSH
96520: LD_INT 102
96522: PUSH
96523: LD_INT 106
96525: PUSH
96526: LD_INT 116
96528: PUSH
96529: LD_INT 117
96531: PUSH
96532: LD_INT 118
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: ST_TO_ADDR
96547: GO 99622
96549: LD_INT 2
96551: DOUBLE
96552: EQUAL
96553: IFTRUE 96557
96555: GO 96641
96557: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96558: LD_ADDR_VAR 0 2
96562: PUSH
96563: LD_INT 2
96565: PUSH
96566: LD_INT 4
96568: PUSH
96569: LD_INT 11
96571: PUSH
96572: LD_INT 12
96574: PUSH
96575: LD_INT 15
96577: PUSH
96578: LD_INT 16
96580: PUSH
96581: LD_INT 22
96583: PUSH
96584: LD_INT 23
96586: PUSH
96587: LD_INT 26
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: PUSH
96601: LD_INT 101
96603: PUSH
96604: LD_INT 102
96606: PUSH
96607: LD_INT 105
96609: PUSH
96610: LD_INT 106
96612: PUSH
96613: LD_INT 108
96615: PUSH
96616: LD_INT 116
96618: PUSH
96619: LD_INT 117
96621: PUSH
96622: LD_INT 118
96624: PUSH
96625: EMPTY
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: PUSH
96635: EMPTY
96636: LIST
96637: LIST
96638: ST_TO_ADDR
96639: GO 99622
96641: LD_INT 3
96643: DOUBLE
96644: EQUAL
96645: IFTRUE 96649
96647: GO 96737
96649: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96650: LD_ADDR_VAR 0 2
96654: PUSH
96655: LD_INT 2
96657: PUSH
96658: LD_INT 4
96660: PUSH
96661: LD_INT 5
96663: PUSH
96664: LD_INT 11
96666: PUSH
96667: LD_INT 12
96669: PUSH
96670: LD_INT 15
96672: PUSH
96673: LD_INT 16
96675: PUSH
96676: LD_INT 22
96678: PUSH
96679: LD_INT 26
96681: PUSH
96682: LD_INT 36
96684: PUSH
96685: EMPTY
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 101
96699: PUSH
96700: LD_INT 102
96702: PUSH
96703: LD_INT 105
96705: PUSH
96706: LD_INT 106
96708: PUSH
96709: LD_INT 108
96711: PUSH
96712: LD_INT 116
96714: PUSH
96715: LD_INT 117
96717: PUSH
96718: LD_INT 118
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: ST_TO_ADDR
96735: GO 99622
96737: LD_INT 4
96739: DOUBLE
96740: EQUAL
96741: IFTRUE 96745
96743: GO 96841
96745: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96746: LD_ADDR_VAR 0 2
96750: PUSH
96751: LD_INT 2
96753: PUSH
96754: LD_INT 4
96756: PUSH
96757: LD_INT 5
96759: PUSH
96760: LD_INT 8
96762: PUSH
96763: LD_INT 11
96765: PUSH
96766: LD_INT 12
96768: PUSH
96769: LD_INT 15
96771: PUSH
96772: LD_INT 16
96774: PUSH
96775: LD_INT 22
96777: PUSH
96778: LD_INT 23
96780: PUSH
96781: LD_INT 26
96783: PUSH
96784: LD_INT 36
96786: PUSH
96787: EMPTY
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 101
96803: PUSH
96804: LD_INT 102
96806: PUSH
96807: LD_INT 105
96809: PUSH
96810: LD_INT 106
96812: PUSH
96813: LD_INT 108
96815: PUSH
96816: LD_INT 116
96818: PUSH
96819: LD_INT 117
96821: PUSH
96822: LD_INT 118
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: PUSH
96835: EMPTY
96836: LIST
96837: LIST
96838: ST_TO_ADDR
96839: GO 99622
96841: LD_INT 5
96843: DOUBLE
96844: EQUAL
96845: IFTRUE 96849
96847: GO 96961
96849: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96850: LD_ADDR_VAR 0 2
96854: PUSH
96855: LD_INT 2
96857: PUSH
96858: LD_INT 4
96860: PUSH
96861: LD_INT 5
96863: PUSH
96864: LD_INT 6
96866: PUSH
96867: LD_INT 8
96869: PUSH
96870: LD_INT 11
96872: PUSH
96873: LD_INT 12
96875: PUSH
96876: LD_INT 15
96878: PUSH
96879: LD_INT 16
96881: PUSH
96882: LD_INT 22
96884: PUSH
96885: LD_INT 23
96887: PUSH
96888: LD_INT 25
96890: PUSH
96891: LD_INT 26
96893: PUSH
96894: LD_INT 36
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 101
96915: PUSH
96916: LD_INT 102
96918: PUSH
96919: LD_INT 105
96921: PUSH
96922: LD_INT 106
96924: PUSH
96925: LD_INT 108
96927: PUSH
96928: LD_INT 109
96930: PUSH
96931: LD_INT 112
96933: PUSH
96934: LD_INT 116
96936: PUSH
96937: LD_INT 117
96939: PUSH
96940: LD_INT 118
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: PUSH
96955: EMPTY
96956: LIST
96957: LIST
96958: ST_TO_ADDR
96959: GO 99622
96961: LD_INT 6
96963: DOUBLE
96964: EQUAL
96965: IFTRUE 96969
96967: GO 97101
96969: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96970: LD_ADDR_VAR 0 2
96974: PUSH
96975: LD_INT 2
96977: PUSH
96978: LD_INT 4
96980: PUSH
96981: LD_INT 5
96983: PUSH
96984: LD_INT 6
96986: PUSH
96987: LD_INT 8
96989: PUSH
96990: LD_INT 11
96992: PUSH
96993: LD_INT 12
96995: PUSH
96996: LD_INT 15
96998: PUSH
96999: LD_INT 16
97001: PUSH
97002: LD_INT 20
97004: PUSH
97005: LD_INT 21
97007: PUSH
97008: LD_INT 22
97010: PUSH
97011: LD_INT 23
97013: PUSH
97014: LD_INT 25
97016: PUSH
97017: LD_INT 26
97019: PUSH
97020: LD_INT 30
97022: PUSH
97023: LD_INT 31
97025: PUSH
97026: LD_INT 32
97028: PUSH
97029: LD_INT 36
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: PUSH
97053: LD_INT 101
97055: PUSH
97056: LD_INT 102
97058: PUSH
97059: LD_INT 105
97061: PUSH
97062: LD_INT 106
97064: PUSH
97065: LD_INT 108
97067: PUSH
97068: LD_INT 109
97070: PUSH
97071: LD_INT 112
97073: PUSH
97074: LD_INT 116
97076: PUSH
97077: LD_INT 117
97079: PUSH
97080: LD_INT 118
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: ST_TO_ADDR
97099: GO 99622
97101: LD_INT 7
97103: DOUBLE
97104: EQUAL
97105: IFTRUE 97109
97107: GO 97221
97109: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97110: LD_ADDR_VAR 0 2
97114: PUSH
97115: LD_INT 2
97117: PUSH
97118: LD_INT 4
97120: PUSH
97121: LD_INT 5
97123: PUSH
97124: LD_INT 7
97126: PUSH
97127: LD_INT 11
97129: PUSH
97130: LD_INT 12
97132: PUSH
97133: LD_INT 15
97135: PUSH
97136: LD_INT 16
97138: PUSH
97139: LD_INT 20
97141: PUSH
97142: LD_INT 21
97144: PUSH
97145: LD_INT 22
97147: PUSH
97148: LD_INT 23
97150: PUSH
97151: LD_INT 25
97153: PUSH
97154: LD_INT 26
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: PUSH
97173: LD_INT 101
97175: PUSH
97176: LD_INT 102
97178: PUSH
97179: LD_INT 103
97181: PUSH
97182: LD_INT 105
97184: PUSH
97185: LD_INT 106
97187: PUSH
97188: LD_INT 108
97190: PUSH
97191: LD_INT 112
97193: PUSH
97194: LD_INT 116
97196: PUSH
97197: LD_INT 117
97199: PUSH
97200: LD_INT 118
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: ST_TO_ADDR
97219: GO 99622
97221: LD_INT 8
97223: DOUBLE
97224: EQUAL
97225: IFTRUE 97229
97227: GO 97369
97229: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97230: LD_ADDR_VAR 0 2
97234: PUSH
97235: LD_INT 2
97237: PUSH
97238: LD_INT 4
97240: PUSH
97241: LD_INT 5
97243: PUSH
97244: LD_INT 6
97246: PUSH
97247: LD_INT 7
97249: PUSH
97250: LD_INT 8
97252: PUSH
97253: LD_INT 11
97255: PUSH
97256: LD_INT 12
97258: PUSH
97259: LD_INT 15
97261: PUSH
97262: LD_INT 16
97264: PUSH
97265: LD_INT 20
97267: PUSH
97268: LD_INT 21
97270: PUSH
97271: LD_INT 22
97273: PUSH
97274: LD_INT 23
97276: PUSH
97277: LD_INT 25
97279: PUSH
97280: LD_INT 26
97282: PUSH
97283: LD_INT 30
97285: PUSH
97286: LD_INT 31
97288: PUSH
97289: LD_INT 32
97291: PUSH
97292: LD_INT 36
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 101
97319: PUSH
97320: LD_INT 102
97322: PUSH
97323: LD_INT 103
97325: PUSH
97326: LD_INT 105
97328: PUSH
97329: LD_INT 106
97331: PUSH
97332: LD_INT 108
97334: PUSH
97335: LD_INT 109
97337: PUSH
97338: LD_INT 112
97340: PUSH
97341: LD_INT 116
97343: PUSH
97344: LD_INT 117
97346: PUSH
97347: LD_INT 118
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: ST_TO_ADDR
97367: GO 99622
97369: LD_INT 9
97371: DOUBLE
97372: EQUAL
97373: IFTRUE 97377
97375: GO 97525
97377: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97378: LD_ADDR_VAR 0 2
97382: PUSH
97383: LD_INT 2
97385: PUSH
97386: LD_INT 4
97388: PUSH
97389: LD_INT 5
97391: PUSH
97392: LD_INT 6
97394: PUSH
97395: LD_INT 7
97397: PUSH
97398: LD_INT 8
97400: PUSH
97401: LD_INT 11
97403: PUSH
97404: LD_INT 12
97406: PUSH
97407: LD_INT 15
97409: PUSH
97410: LD_INT 16
97412: PUSH
97413: LD_INT 20
97415: PUSH
97416: LD_INT 21
97418: PUSH
97419: LD_INT 22
97421: PUSH
97422: LD_INT 23
97424: PUSH
97425: LD_INT 25
97427: PUSH
97428: LD_INT 26
97430: PUSH
97431: LD_INT 28
97433: PUSH
97434: LD_INT 30
97436: PUSH
97437: LD_INT 31
97439: PUSH
97440: LD_INT 32
97442: PUSH
97443: LD_INT 36
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 101
97471: PUSH
97472: LD_INT 102
97474: PUSH
97475: LD_INT 103
97477: PUSH
97478: LD_INT 105
97480: PUSH
97481: LD_INT 106
97483: PUSH
97484: LD_INT 108
97486: PUSH
97487: LD_INT 109
97489: PUSH
97490: LD_INT 112
97492: PUSH
97493: LD_INT 114
97495: PUSH
97496: LD_INT 116
97498: PUSH
97499: LD_INT 117
97501: PUSH
97502: LD_INT 118
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: ST_TO_ADDR
97523: GO 99622
97525: LD_INT 10
97527: DOUBLE
97528: EQUAL
97529: IFTRUE 97533
97531: GO 97729
97533: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97534: LD_ADDR_VAR 0 2
97538: PUSH
97539: LD_INT 2
97541: PUSH
97542: LD_INT 4
97544: PUSH
97545: LD_INT 5
97547: PUSH
97548: LD_INT 6
97550: PUSH
97551: LD_INT 7
97553: PUSH
97554: LD_INT 8
97556: PUSH
97557: LD_INT 9
97559: PUSH
97560: LD_INT 10
97562: PUSH
97563: LD_INT 11
97565: PUSH
97566: LD_INT 12
97568: PUSH
97569: LD_INT 13
97571: PUSH
97572: LD_INT 14
97574: PUSH
97575: LD_INT 15
97577: PUSH
97578: LD_INT 16
97580: PUSH
97581: LD_INT 17
97583: PUSH
97584: LD_INT 18
97586: PUSH
97587: LD_INT 19
97589: PUSH
97590: LD_INT 20
97592: PUSH
97593: LD_INT 21
97595: PUSH
97596: LD_INT 22
97598: PUSH
97599: LD_INT 23
97601: PUSH
97602: LD_INT 24
97604: PUSH
97605: LD_INT 25
97607: PUSH
97608: LD_INT 26
97610: PUSH
97611: LD_INT 28
97613: PUSH
97614: LD_INT 30
97616: PUSH
97617: LD_INT 31
97619: PUSH
97620: LD_INT 32
97622: PUSH
97623: LD_INT 36
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: PUSH
97657: LD_INT 101
97659: PUSH
97660: LD_INT 102
97662: PUSH
97663: LD_INT 103
97665: PUSH
97666: LD_INT 104
97668: PUSH
97669: LD_INT 105
97671: PUSH
97672: LD_INT 106
97674: PUSH
97675: LD_INT 107
97677: PUSH
97678: LD_INT 108
97680: PUSH
97681: LD_INT 109
97683: PUSH
97684: LD_INT 110
97686: PUSH
97687: LD_INT 111
97689: PUSH
97690: LD_INT 112
97692: PUSH
97693: LD_INT 114
97695: PUSH
97696: LD_INT 116
97698: PUSH
97699: LD_INT 117
97701: PUSH
97702: LD_INT 118
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: ST_TO_ADDR
97727: GO 99622
97729: LD_INT 11
97731: DOUBLE
97732: EQUAL
97733: IFTRUE 97737
97735: GO 97941
97737: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97738: LD_ADDR_VAR 0 2
97742: PUSH
97743: LD_INT 2
97745: PUSH
97746: LD_INT 3
97748: PUSH
97749: LD_INT 4
97751: PUSH
97752: LD_INT 5
97754: PUSH
97755: LD_INT 6
97757: PUSH
97758: LD_INT 7
97760: PUSH
97761: LD_INT 8
97763: PUSH
97764: LD_INT 9
97766: PUSH
97767: LD_INT 10
97769: PUSH
97770: LD_INT 11
97772: PUSH
97773: LD_INT 12
97775: PUSH
97776: LD_INT 13
97778: PUSH
97779: LD_INT 14
97781: PUSH
97782: LD_INT 15
97784: PUSH
97785: LD_INT 16
97787: PUSH
97788: LD_INT 17
97790: PUSH
97791: LD_INT 18
97793: PUSH
97794: LD_INT 19
97796: PUSH
97797: LD_INT 20
97799: PUSH
97800: LD_INT 21
97802: PUSH
97803: LD_INT 22
97805: PUSH
97806: LD_INT 23
97808: PUSH
97809: LD_INT 24
97811: PUSH
97812: LD_INT 25
97814: PUSH
97815: LD_INT 26
97817: PUSH
97818: LD_INT 28
97820: PUSH
97821: LD_INT 30
97823: PUSH
97824: LD_INT 31
97826: PUSH
97827: LD_INT 32
97829: PUSH
97830: LD_INT 34
97832: PUSH
97833: LD_INT 36
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: PUSH
97869: LD_INT 101
97871: PUSH
97872: LD_INT 102
97874: PUSH
97875: LD_INT 103
97877: PUSH
97878: LD_INT 104
97880: PUSH
97881: LD_INT 105
97883: PUSH
97884: LD_INT 106
97886: PUSH
97887: LD_INT 107
97889: PUSH
97890: LD_INT 108
97892: PUSH
97893: LD_INT 109
97895: PUSH
97896: LD_INT 110
97898: PUSH
97899: LD_INT 111
97901: PUSH
97902: LD_INT 112
97904: PUSH
97905: LD_INT 114
97907: PUSH
97908: LD_INT 116
97910: PUSH
97911: LD_INT 117
97913: PUSH
97914: LD_INT 118
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: PUSH
97935: EMPTY
97936: LIST
97937: LIST
97938: ST_TO_ADDR
97939: GO 99622
97941: LD_INT 12
97943: DOUBLE
97944: EQUAL
97945: IFTRUE 97949
97947: GO 98169
97949: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97950: LD_ADDR_VAR 0 2
97954: PUSH
97955: LD_INT 1
97957: PUSH
97958: LD_INT 2
97960: PUSH
97961: LD_INT 3
97963: PUSH
97964: LD_INT 4
97966: PUSH
97967: LD_INT 5
97969: PUSH
97970: LD_INT 6
97972: PUSH
97973: LD_INT 7
97975: PUSH
97976: LD_INT 8
97978: PUSH
97979: LD_INT 9
97981: PUSH
97982: LD_INT 10
97984: PUSH
97985: LD_INT 11
97987: PUSH
97988: LD_INT 12
97990: PUSH
97991: LD_INT 13
97993: PUSH
97994: LD_INT 14
97996: PUSH
97997: LD_INT 15
97999: PUSH
98000: LD_INT 16
98002: PUSH
98003: LD_INT 17
98005: PUSH
98006: LD_INT 18
98008: PUSH
98009: LD_INT 19
98011: PUSH
98012: LD_INT 20
98014: PUSH
98015: LD_INT 21
98017: PUSH
98018: LD_INT 22
98020: PUSH
98021: LD_INT 23
98023: PUSH
98024: LD_INT 24
98026: PUSH
98027: LD_INT 25
98029: PUSH
98030: LD_INT 26
98032: PUSH
98033: LD_INT 27
98035: PUSH
98036: LD_INT 28
98038: PUSH
98039: LD_INT 30
98041: PUSH
98042: LD_INT 31
98044: PUSH
98045: LD_INT 32
98047: PUSH
98048: LD_INT 33
98050: PUSH
98051: LD_INT 34
98053: PUSH
98054: LD_INT 36
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: LIST
98061: LIST
98062: LIST
98063: LIST
98064: LIST
98065: LIST
98066: LIST
98067: LIST
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: LIST
98073: LIST
98074: LIST
98075: LIST
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: LIST
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: PUSH
98093: LD_INT 101
98095: PUSH
98096: LD_INT 102
98098: PUSH
98099: LD_INT 103
98101: PUSH
98102: LD_INT 104
98104: PUSH
98105: LD_INT 105
98107: PUSH
98108: LD_INT 106
98110: PUSH
98111: LD_INT 107
98113: PUSH
98114: LD_INT 108
98116: PUSH
98117: LD_INT 109
98119: PUSH
98120: LD_INT 110
98122: PUSH
98123: LD_INT 111
98125: PUSH
98126: LD_INT 112
98128: PUSH
98129: LD_INT 113
98131: PUSH
98132: LD_INT 114
98134: PUSH
98135: LD_INT 116
98137: PUSH
98138: LD_INT 117
98140: PUSH
98141: LD_INT 118
98143: PUSH
98144: EMPTY
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: LIST
98156: LIST
98157: LIST
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: PUSH
98163: EMPTY
98164: LIST
98165: LIST
98166: ST_TO_ADDR
98167: GO 99622
98169: LD_INT 13
98171: DOUBLE
98172: EQUAL
98173: IFTRUE 98177
98175: GO 98385
98177: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98178: LD_ADDR_VAR 0 2
98182: PUSH
98183: LD_INT 1
98185: PUSH
98186: LD_INT 2
98188: PUSH
98189: LD_INT 3
98191: PUSH
98192: LD_INT 4
98194: PUSH
98195: LD_INT 5
98197: PUSH
98198: LD_INT 8
98200: PUSH
98201: LD_INT 9
98203: PUSH
98204: LD_INT 10
98206: PUSH
98207: LD_INT 11
98209: PUSH
98210: LD_INT 12
98212: PUSH
98213: LD_INT 14
98215: PUSH
98216: LD_INT 15
98218: PUSH
98219: LD_INT 16
98221: PUSH
98222: LD_INT 17
98224: PUSH
98225: LD_INT 18
98227: PUSH
98228: LD_INT 19
98230: PUSH
98231: LD_INT 20
98233: PUSH
98234: LD_INT 21
98236: PUSH
98237: LD_INT 22
98239: PUSH
98240: LD_INT 23
98242: PUSH
98243: LD_INT 24
98245: PUSH
98246: LD_INT 25
98248: PUSH
98249: LD_INT 26
98251: PUSH
98252: LD_INT 27
98254: PUSH
98255: LD_INT 28
98257: PUSH
98258: LD_INT 30
98260: PUSH
98261: LD_INT 31
98263: PUSH
98264: LD_INT 32
98266: PUSH
98267: LD_INT 33
98269: PUSH
98270: LD_INT 34
98272: PUSH
98273: LD_INT 36
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: LIST
98287: LIST
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: LIST
98294: LIST
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: PUSH
98309: LD_INT 101
98311: PUSH
98312: LD_INT 102
98314: PUSH
98315: LD_INT 103
98317: PUSH
98318: LD_INT 104
98320: PUSH
98321: LD_INT 105
98323: PUSH
98324: LD_INT 106
98326: PUSH
98327: LD_INT 107
98329: PUSH
98330: LD_INT 108
98332: PUSH
98333: LD_INT 109
98335: PUSH
98336: LD_INT 110
98338: PUSH
98339: LD_INT 111
98341: PUSH
98342: LD_INT 112
98344: PUSH
98345: LD_INT 113
98347: PUSH
98348: LD_INT 114
98350: PUSH
98351: LD_INT 116
98353: PUSH
98354: LD_INT 117
98356: PUSH
98357: LD_INT 118
98359: PUSH
98360: EMPTY
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: ST_TO_ADDR
98383: GO 99622
98385: LD_INT 14
98387: DOUBLE
98388: EQUAL
98389: IFTRUE 98393
98391: GO 98617
98393: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98394: LD_ADDR_VAR 0 2
98398: PUSH
98399: LD_INT 1
98401: PUSH
98402: LD_INT 2
98404: PUSH
98405: LD_INT 3
98407: PUSH
98408: LD_INT 4
98410: PUSH
98411: LD_INT 5
98413: PUSH
98414: LD_INT 6
98416: PUSH
98417: LD_INT 7
98419: PUSH
98420: LD_INT 8
98422: PUSH
98423: LD_INT 9
98425: PUSH
98426: LD_INT 10
98428: PUSH
98429: LD_INT 11
98431: PUSH
98432: LD_INT 12
98434: PUSH
98435: LD_INT 13
98437: PUSH
98438: LD_INT 14
98440: PUSH
98441: LD_INT 15
98443: PUSH
98444: LD_INT 16
98446: PUSH
98447: LD_INT 17
98449: PUSH
98450: LD_INT 18
98452: PUSH
98453: LD_INT 19
98455: PUSH
98456: LD_INT 20
98458: PUSH
98459: LD_INT 21
98461: PUSH
98462: LD_INT 22
98464: PUSH
98465: LD_INT 23
98467: PUSH
98468: LD_INT 24
98470: PUSH
98471: LD_INT 25
98473: PUSH
98474: LD_INT 26
98476: PUSH
98477: LD_INT 27
98479: PUSH
98480: LD_INT 28
98482: PUSH
98483: LD_INT 29
98485: PUSH
98486: LD_INT 30
98488: PUSH
98489: LD_INT 31
98491: PUSH
98492: LD_INT 32
98494: PUSH
98495: LD_INT 33
98497: PUSH
98498: LD_INT 34
98500: PUSH
98501: LD_INT 36
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: LIST
98519: LIST
98520: LIST
98521: LIST
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: PUSH
98541: LD_INT 101
98543: PUSH
98544: LD_INT 102
98546: PUSH
98547: LD_INT 103
98549: PUSH
98550: LD_INT 104
98552: PUSH
98553: LD_INT 105
98555: PUSH
98556: LD_INT 106
98558: PUSH
98559: LD_INT 107
98561: PUSH
98562: LD_INT 108
98564: PUSH
98565: LD_INT 109
98567: PUSH
98568: LD_INT 110
98570: PUSH
98571: LD_INT 111
98573: PUSH
98574: LD_INT 112
98576: PUSH
98577: LD_INT 113
98579: PUSH
98580: LD_INT 114
98582: PUSH
98583: LD_INT 116
98585: PUSH
98586: LD_INT 117
98588: PUSH
98589: LD_INT 118
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: LIST
98599: LIST
98600: LIST
98601: LIST
98602: LIST
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: LIST
98608: LIST
98609: LIST
98610: PUSH
98611: EMPTY
98612: LIST
98613: LIST
98614: ST_TO_ADDR
98615: GO 99622
98617: LD_INT 15
98619: DOUBLE
98620: EQUAL
98621: IFTRUE 98625
98623: GO 98849
98625: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98626: LD_ADDR_VAR 0 2
98630: PUSH
98631: LD_INT 1
98633: PUSH
98634: LD_INT 2
98636: PUSH
98637: LD_INT 3
98639: PUSH
98640: LD_INT 4
98642: PUSH
98643: LD_INT 5
98645: PUSH
98646: LD_INT 6
98648: PUSH
98649: LD_INT 7
98651: PUSH
98652: LD_INT 8
98654: PUSH
98655: LD_INT 9
98657: PUSH
98658: LD_INT 10
98660: PUSH
98661: LD_INT 11
98663: PUSH
98664: LD_INT 12
98666: PUSH
98667: LD_INT 13
98669: PUSH
98670: LD_INT 14
98672: PUSH
98673: LD_INT 15
98675: PUSH
98676: LD_INT 16
98678: PUSH
98679: LD_INT 17
98681: PUSH
98682: LD_INT 18
98684: PUSH
98685: LD_INT 19
98687: PUSH
98688: LD_INT 20
98690: PUSH
98691: LD_INT 21
98693: PUSH
98694: LD_INT 22
98696: PUSH
98697: LD_INT 23
98699: PUSH
98700: LD_INT 24
98702: PUSH
98703: LD_INT 25
98705: PUSH
98706: LD_INT 26
98708: PUSH
98709: LD_INT 27
98711: PUSH
98712: LD_INT 28
98714: PUSH
98715: LD_INT 29
98717: PUSH
98718: LD_INT 30
98720: PUSH
98721: LD_INT 31
98723: PUSH
98724: LD_INT 32
98726: PUSH
98727: LD_INT 33
98729: PUSH
98730: LD_INT 34
98732: PUSH
98733: LD_INT 36
98735: PUSH
98736: EMPTY
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: LIST
98771: LIST
98772: PUSH
98773: LD_INT 101
98775: PUSH
98776: LD_INT 102
98778: PUSH
98779: LD_INT 103
98781: PUSH
98782: LD_INT 104
98784: PUSH
98785: LD_INT 105
98787: PUSH
98788: LD_INT 106
98790: PUSH
98791: LD_INT 107
98793: PUSH
98794: LD_INT 108
98796: PUSH
98797: LD_INT 109
98799: PUSH
98800: LD_INT 110
98802: PUSH
98803: LD_INT 111
98805: PUSH
98806: LD_INT 112
98808: PUSH
98809: LD_INT 113
98811: PUSH
98812: LD_INT 114
98814: PUSH
98815: LD_INT 116
98817: PUSH
98818: LD_INT 117
98820: PUSH
98821: LD_INT 118
98823: PUSH
98824: EMPTY
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: PUSH
98843: EMPTY
98844: LIST
98845: LIST
98846: ST_TO_ADDR
98847: GO 99622
98849: LD_INT 16
98851: DOUBLE
98852: EQUAL
98853: IFTRUE 98857
98855: GO 98993
98857: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98858: LD_ADDR_VAR 0 2
98862: PUSH
98863: LD_INT 2
98865: PUSH
98866: LD_INT 4
98868: PUSH
98869: LD_INT 5
98871: PUSH
98872: LD_INT 7
98874: PUSH
98875: LD_INT 11
98877: PUSH
98878: LD_INT 12
98880: PUSH
98881: LD_INT 15
98883: PUSH
98884: LD_INT 16
98886: PUSH
98887: LD_INT 20
98889: PUSH
98890: LD_INT 21
98892: PUSH
98893: LD_INT 22
98895: PUSH
98896: LD_INT 23
98898: PUSH
98899: LD_INT 25
98901: PUSH
98902: LD_INT 26
98904: PUSH
98905: LD_INT 30
98907: PUSH
98908: LD_INT 31
98910: PUSH
98911: LD_INT 32
98913: PUSH
98914: LD_INT 33
98916: PUSH
98917: LD_INT 34
98919: PUSH
98920: EMPTY
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: PUSH
98941: LD_INT 101
98943: PUSH
98944: LD_INT 102
98946: PUSH
98947: LD_INT 103
98949: PUSH
98950: LD_INT 106
98952: PUSH
98953: LD_INT 108
98955: PUSH
98956: LD_INT 112
98958: PUSH
98959: LD_INT 113
98961: PUSH
98962: LD_INT 114
98964: PUSH
98965: LD_INT 116
98967: PUSH
98968: LD_INT 117
98970: PUSH
98971: LD_INT 118
98973: PUSH
98974: EMPTY
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: ST_TO_ADDR
98991: GO 99622
98993: LD_INT 17
98995: DOUBLE
98996: EQUAL
98997: IFTRUE 99001
98999: GO 99225
99001: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99002: LD_ADDR_VAR 0 2
99006: PUSH
99007: LD_INT 1
99009: PUSH
99010: LD_INT 2
99012: PUSH
99013: LD_INT 3
99015: PUSH
99016: LD_INT 4
99018: PUSH
99019: LD_INT 5
99021: PUSH
99022: LD_INT 6
99024: PUSH
99025: LD_INT 7
99027: PUSH
99028: LD_INT 8
99030: PUSH
99031: LD_INT 9
99033: PUSH
99034: LD_INT 10
99036: PUSH
99037: LD_INT 11
99039: PUSH
99040: LD_INT 12
99042: PUSH
99043: LD_INT 13
99045: PUSH
99046: LD_INT 14
99048: PUSH
99049: LD_INT 15
99051: PUSH
99052: LD_INT 16
99054: PUSH
99055: LD_INT 17
99057: PUSH
99058: LD_INT 18
99060: PUSH
99061: LD_INT 19
99063: PUSH
99064: LD_INT 20
99066: PUSH
99067: LD_INT 21
99069: PUSH
99070: LD_INT 22
99072: PUSH
99073: LD_INT 23
99075: PUSH
99076: LD_INT 24
99078: PUSH
99079: LD_INT 25
99081: PUSH
99082: LD_INT 26
99084: PUSH
99085: LD_INT 27
99087: PUSH
99088: LD_INT 28
99090: PUSH
99091: LD_INT 29
99093: PUSH
99094: LD_INT 30
99096: PUSH
99097: LD_INT 31
99099: PUSH
99100: LD_INT 32
99102: PUSH
99103: LD_INT 33
99105: PUSH
99106: LD_INT 34
99108: PUSH
99109: LD_INT 36
99111: PUSH
99112: EMPTY
99113: LIST
99114: LIST
99115: LIST
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: LIST
99134: LIST
99135: LIST
99136: LIST
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: LIST
99144: LIST
99145: LIST
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 101
99151: PUSH
99152: LD_INT 102
99154: PUSH
99155: LD_INT 103
99157: PUSH
99158: LD_INT 104
99160: PUSH
99161: LD_INT 105
99163: PUSH
99164: LD_INT 106
99166: PUSH
99167: LD_INT 107
99169: PUSH
99170: LD_INT 108
99172: PUSH
99173: LD_INT 109
99175: PUSH
99176: LD_INT 110
99178: PUSH
99179: LD_INT 111
99181: PUSH
99182: LD_INT 112
99184: PUSH
99185: LD_INT 113
99187: PUSH
99188: LD_INT 114
99190: PUSH
99191: LD_INT 116
99193: PUSH
99194: LD_INT 117
99196: PUSH
99197: LD_INT 118
99199: PUSH
99200: EMPTY
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: LIST
99206: LIST
99207: LIST
99208: LIST
99209: LIST
99210: LIST
99211: LIST
99212: LIST
99213: LIST
99214: LIST
99215: LIST
99216: LIST
99217: LIST
99218: PUSH
99219: EMPTY
99220: LIST
99221: LIST
99222: ST_TO_ADDR
99223: GO 99622
99225: LD_INT 18
99227: DOUBLE
99228: EQUAL
99229: IFTRUE 99233
99231: GO 99381
99233: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99234: LD_ADDR_VAR 0 2
99238: PUSH
99239: LD_INT 2
99241: PUSH
99242: LD_INT 4
99244: PUSH
99245: LD_INT 5
99247: PUSH
99248: LD_INT 7
99250: PUSH
99251: LD_INT 11
99253: PUSH
99254: LD_INT 12
99256: PUSH
99257: LD_INT 15
99259: PUSH
99260: LD_INT 16
99262: PUSH
99263: LD_INT 20
99265: PUSH
99266: LD_INT 21
99268: PUSH
99269: LD_INT 22
99271: PUSH
99272: LD_INT 23
99274: PUSH
99275: LD_INT 25
99277: PUSH
99278: LD_INT 26
99280: PUSH
99281: LD_INT 30
99283: PUSH
99284: LD_INT 31
99286: PUSH
99287: LD_INT 32
99289: PUSH
99290: LD_INT 33
99292: PUSH
99293: LD_INT 34
99295: PUSH
99296: LD_INT 35
99298: PUSH
99299: LD_INT 36
99301: PUSH
99302: EMPTY
99303: LIST
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: PUSH
99325: LD_INT 101
99327: PUSH
99328: LD_INT 102
99330: PUSH
99331: LD_INT 103
99333: PUSH
99334: LD_INT 106
99336: PUSH
99337: LD_INT 108
99339: PUSH
99340: LD_INT 112
99342: PUSH
99343: LD_INT 113
99345: PUSH
99346: LD_INT 114
99348: PUSH
99349: LD_INT 115
99351: PUSH
99352: LD_INT 116
99354: PUSH
99355: LD_INT 117
99357: PUSH
99358: LD_INT 118
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: LIST
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: LIST
99370: LIST
99371: LIST
99372: LIST
99373: LIST
99374: PUSH
99375: EMPTY
99376: LIST
99377: LIST
99378: ST_TO_ADDR
99379: GO 99622
99381: LD_INT 19
99383: DOUBLE
99384: EQUAL
99385: IFTRUE 99389
99387: GO 99621
99389: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99390: LD_ADDR_VAR 0 2
99394: PUSH
99395: LD_INT 1
99397: PUSH
99398: LD_INT 2
99400: PUSH
99401: LD_INT 3
99403: PUSH
99404: LD_INT 4
99406: PUSH
99407: LD_INT 5
99409: PUSH
99410: LD_INT 6
99412: PUSH
99413: LD_INT 7
99415: PUSH
99416: LD_INT 8
99418: PUSH
99419: LD_INT 9
99421: PUSH
99422: LD_INT 10
99424: PUSH
99425: LD_INT 11
99427: PUSH
99428: LD_INT 12
99430: PUSH
99431: LD_INT 13
99433: PUSH
99434: LD_INT 14
99436: PUSH
99437: LD_INT 15
99439: PUSH
99440: LD_INT 16
99442: PUSH
99443: LD_INT 17
99445: PUSH
99446: LD_INT 18
99448: PUSH
99449: LD_INT 19
99451: PUSH
99452: LD_INT 20
99454: PUSH
99455: LD_INT 21
99457: PUSH
99458: LD_INT 22
99460: PUSH
99461: LD_INT 23
99463: PUSH
99464: LD_INT 24
99466: PUSH
99467: LD_INT 25
99469: PUSH
99470: LD_INT 26
99472: PUSH
99473: LD_INT 27
99475: PUSH
99476: LD_INT 28
99478: PUSH
99479: LD_INT 29
99481: PUSH
99482: LD_INT 30
99484: PUSH
99485: LD_INT 31
99487: PUSH
99488: LD_INT 32
99490: PUSH
99491: LD_INT 33
99493: PUSH
99494: LD_INT 34
99496: PUSH
99497: LD_INT 35
99499: PUSH
99500: LD_INT 36
99502: PUSH
99503: EMPTY
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: PUSH
99541: LD_INT 101
99543: PUSH
99544: LD_INT 102
99546: PUSH
99547: LD_INT 103
99549: PUSH
99550: LD_INT 104
99552: PUSH
99553: LD_INT 105
99555: PUSH
99556: LD_INT 106
99558: PUSH
99559: LD_INT 107
99561: PUSH
99562: LD_INT 108
99564: PUSH
99565: LD_INT 109
99567: PUSH
99568: LD_INT 110
99570: PUSH
99571: LD_INT 111
99573: PUSH
99574: LD_INT 112
99576: PUSH
99577: LD_INT 113
99579: PUSH
99580: LD_INT 114
99582: PUSH
99583: LD_INT 115
99585: PUSH
99586: LD_INT 116
99588: PUSH
99589: LD_INT 117
99591: PUSH
99592: LD_INT 118
99594: PUSH
99595: EMPTY
99596: LIST
99597: LIST
99598: LIST
99599: LIST
99600: LIST
99601: LIST
99602: LIST
99603: LIST
99604: LIST
99605: LIST
99606: LIST
99607: LIST
99608: LIST
99609: LIST
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: PUSH
99615: EMPTY
99616: LIST
99617: LIST
99618: ST_TO_ADDR
99619: GO 99622
99621: POP
// end else
99622: GO 99853
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99624: LD_ADDR_VAR 0 2
99628: PUSH
99629: LD_INT 1
99631: PUSH
99632: LD_INT 2
99634: PUSH
99635: LD_INT 3
99637: PUSH
99638: LD_INT 4
99640: PUSH
99641: LD_INT 5
99643: PUSH
99644: LD_INT 6
99646: PUSH
99647: LD_INT 7
99649: PUSH
99650: LD_INT 8
99652: PUSH
99653: LD_INT 9
99655: PUSH
99656: LD_INT 10
99658: PUSH
99659: LD_INT 11
99661: PUSH
99662: LD_INT 12
99664: PUSH
99665: LD_INT 13
99667: PUSH
99668: LD_INT 14
99670: PUSH
99671: LD_INT 15
99673: PUSH
99674: LD_INT 16
99676: PUSH
99677: LD_INT 17
99679: PUSH
99680: LD_INT 18
99682: PUSH
99683: LD_INT 19
99685: PUSH
99686: LD_INT 20
99688: PUSH
99689: LD_INT 21
99691: PUSH
99692: LD_INT 22
99694: PUSH
99695: LD_INT 23
99697: PUSH
99698: LD_INT 24
99700: PUSH
99701: LD_INT 25
99703: PUSH
99704: LD_INT 26
99706: PUSH
99707: LD_INT 27
99709: PUSH
99710: LD_INT 28
99712: PUSH
99713: LD_INT 29
99715: PUSH
99716: LD_INT 30
99718: PUSH
99719: LD_INT 31
99721: PUSH
99722: LD_INT 32
99724: PUSH
99725: LD_INT 33
99727: PUSH
99728: LD_INT 34
99730: PUSH
99731: LD_INT 35
99733: PUSH
99734: LD_INT 36
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: LIST
99741: LIST
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: LIST
99754: LIST
99755: LIST
99756: LIST
99757: LIST
99758: LIST
99759: LIST
99760: LIST
99761: LIST
99762: LIST
99763: LIST
99764: LIST
99765: LIST
99766: LIST
99767: LIST
99768: LIST
99769: LIST
99770: LIST
99771: LIST
99772: LIST
99773: LIST
99774: PUSH
99775: LD_INT 101
99777: PUSH
99778: LD_INT 102
99780: PUSH
99781: LD_INT 103
99783: PUSH
99784: LD_INT 104
99786: PUSH
99787: LD_INT 105
99789: PUSH
99790: LD_INT 106
99792: PUSH
99793: LD_INT 107
99795: PUSH
99796: LD_INT 108
99798: PUSH
99799: LD_INT 109
99801: PUSH
99802: LD_INT 110
99804: PUSH
99805: LD_INT 111
99807: PUSH
99808: LD_INT 112
99810: PUSH
99811: LD_INT 113
99813: PUSH
99814: LD_INT 114
99816: PUSH
99817: LD_INT 115
99819: PUSH
99820: LD_INT 116
99822: PUSH
99823: LD_INT 117
99825: PUSH
99826: LD_INT 118
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: LIST
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: LIST
99848: PUSH
99849: EMPTY
99850: LIST
99851: LIST
99852: ST_TO_ADDR
// if result then
99853: LD_VAR 0 2
99857: IFFALSE 100643
// begin normal :=  ;
99859: LD_ADDR_VAR 0 5
99863: PUSH
99864: LD_STRING 
99866: ST_TO_ADDR
// hardcore :=  ;
99867: LD_ADDR_VAR 0 6
99871: PUSH
99872: LD_STRING 
99874: ST_TO_ADDR
// active :=  ;
99875: LD_ADDR_VAR 0 7
99879: PUSH
99880: LD_STRING 
99882: ST_TO_ADDR
// for i = 1 to normalCounter do
99883: LD_ADDR_VAR 0 8
99887: PUSH
99888: DOUBLE
99889: LD_INT 1
99891: DEC
99892: ST_TO_ADDR
99893: LD_EXP 78
99897: PUSH
99898: FOR_TO
99899: IFFALSE 100000
// begin tmp := 0 ;
99901: LD_ADDR_VAR 0 3
99905: PUSH
99906: LD_STRING 0
99908: ST_TO_ADDR
// if result [ 1 ] then
99909: LD_VAR 0 2
99913: PUSH
99914: LD_INT 1
99916: ARRAY
99917: IFFALSE 99982
// if result [ 1 ] [ 1 ] = i then
99919: LD_VAR 0 2
99923: PUSH
99924: LD_INT 1
99926: ARRAY
99927: PUSH
99928: LD_INT 1
99930: ARRAY
99931: PUSH
99932: LD_VAR 0 8
99936: EQUAL
99937: IFFALSE 99982
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99939: LD_ADDR_VAR 0 2
99943: PUSH
99944: LD_VAR 0 2
99948: PPUSH
99949: LD_INT 1
99951: PPUSH
99952: LD_VAR 0 2
99956: PUSH
99957: LD_INT 1
99959: ARRAY
99960: PPUSH
99961: LD_INT 1
99963: PPUSH
99964: CALL_OW 3
99968: PPUSH
99969: CALL_OW 1
99973: ST_TO_ADDR
// tmp := 1 ;
99974: LD_ADDR_VAR 0 3
99978: PUSH
99979: LD_STRING 1
99981: ST_TO_ADDR
// end ; normal := normal & tmp ;
99982: LD_ADDR_VAR 0 5
99986: PUSH
99987: LD_VAR 0 5
99991: PUSH
99992: LD_VAR 0 3
99996: STR
99997: ST_TO_ADDR
// end ;
99998: GO 99898
100000: POP
100001: POP
// for i = 1 to hardcoreCounter do
100002: LD_ADDR_VAR 0 8
100006: PUSH
100007: DOUBLE
100008: LD_INT 1
100010: DEC
100011: ST_TO_ADDR
100012: LD_EXP 79
100016: PUSH
100017: FOR_TO
100018: IFFALSE 100123
// begin tmp := 0 ;
100020: LD_ADDR_VAR 0 3
100024: PUSH
100025: LD_STRING 0
100027: ST_TO_ADDR
// if result [ 2 ] then
100028: LD_VAR 0 2
100032: PUSH
100033: LD_INT 2
100035: ARRAY
100036: IFFALSE 100105
// if result [ 2 ] [ 1 ] = 100 + i then
100038: LD_VAR 0 2
100042: PUSH
100043: LD_INT 2
100045: ARRAY
100046: PUSH
100047: LD_INT 1
100049: ARRAY
100050: PUSH
100051: LD_INT 100
100053: PUSH
100054: LD_VAR 0 8
100058: PLUS
100059: EQUAL
100060: IFFALSE 100105
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100062: LD_ADDR_VAR 0 2
100066: PUSH
100067: LD_VAR 0 2
100071: PPUSH
100072: LD_INT 2
100074: PPUSH
100075: LD_VAR 0 2
100079: PUSH
100080: LD_INT 2
100082: ARRAY
100083: PPUSH
100084: LD_INT 1
100086: PPUSH
100087: CALL_OW 3
100091: PPUSH
100092: CALL_OW 1
100096: ST_TO_ADDR
// tmp := 1 ;
100097: LD_ADDR_VAR 0 3
100101: PUSH
100102: LD_STRING 1
100104: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100105: LD_ADDR_VAR 0 6
100109: PUSH
100110: LD_VAR 0 6
100114: PUSH
100115: LD_VAR 0 3
100119: STR
100120: ST_TO_ADDR
// end ;
100121: GO 100017
100123: POP
100124: POP
// if isGameLoad then
100125: LD_VAR 0 1
100129: IFFALSE 100604
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100131: LD_ADDR_VAR 0 4
100135: PUSH
100136: LD_EXP 82
100140: PUSH
100141: LD_EXP 81
100145: PUSH
100146: LD_EXP 83
100150: PUSH
100151: LD_EXP 80
100155: PUSH
100156: LD_EXP 84
100160: PUSH
100161: LD_EXP 85
100165: PUSH
100166: LD_EXP 86
100170: PUSH
100171: LD_EXP 87
100175: PUSH
100176: LD_EXP 88
100180: PUSH
100181: LD_EXP 89
100185: PUSH
100186: LD_EXP 90
100190: PUSH
100191: LD_EXP 91
100195: PUSH
100196: LD_EXP 92
100200: PUSH
100201: LD_EXP 93
100205: PUSH
100206: LD_EXP 101
100210: PUSH
100211: LD_EXP 102
100215: PUSH
100216: LD_EXP 103
100220: PUSH
100221: LD_EXP 104
100225: PUSH
100226: LD_EXP 106
100230: PUSH
100231: LD_EXP 107
100235: PUSH
100236: LD_EXP 108
100240: PUSH
100241: LD_EXP 111
100245: PUSH
100246: LD_EXP 113
100250: PUSH
100251: LD_EXP 114
100255: PUSH
100256: LD_EXP 115
100260: PUSH
100261: LD_EXP 117
100265: PUSH
100266: LD_EXP 118
100270: PUSH
100271: LD_EXP 121
100275: PUSH
100276: LD_EXP 122
100280: PUSH
100281: LD_EXP 123
100285: PUSH
100286: LD_EXP 124
100290: PUSH
100291: LD_EXP 125
100295: PUSH
100296: LD_EXP 126
100300: PUSH
100301: LD_EXP 127
100305: PUSH
100306: LD_EXP 128
100310: PUSH
100311: LD_EXP 129
100315: PUSH
100316: LD_EXP 94
100320: PUSH
100321: LD_EXP 95
100325: PUSH
100326: LD_EXP 98
100330: PUSH
100331: LD_EXP 99
100335: PUSH
100336: LD_EXP 100
100340: PUSH
100341: LD_EXP 96
100345: PUSH
100346: LD_EXP 97
100350: PUSH
100351: LD_EXP 105
100355: PUSH
100356: LD_EXP 109
100360: PUSH
100361: LD_EXP 110
100365: PUSH
100366: LD_EXP 112
100370: PUSH
100371: LD_EXP 116
100375: PUSH
100376: LD_EXP 119
100380: PUSH
100381: LD_EXP 120
100385: PUSH
100386: LD_EXP 130
100390: PUSH
100391: LD_EXP 131
100395: PUSH
100396: LD_EXP 132
100400: PUSH
100401: LD_EXP 133
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: LIST
100430: LIST
100431: LIST
100432: LIST
100433: LIST
100434: LIST
100435: LIST
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: LIST
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: ST_TO_ADDR
// tmp :=  ;
100462: LD_ADDR_VAR 0 3
100466: PUSH
100467: LD_STRING 
100469: ST_TO_ADDR
// for i = 1 to normalCounter do
100470: LD_ADDR_VAR 0 8
100474: PUSH
100475: DOUBLE
100476: LD_INT 1
100478: DEC
100479: ST_TO_ADDR
100480: LD_EXP 78
100484: PUSH
100485: FOR_TO
100486: IFFALSE 100522
// begin if flags [ i ] then
100488: LD_VAR 0 4
100492: PUSH
100493: LD_VAR 0 8
100497: ARRAY
100498: IFFALSE 100520
// tmp := tmp & i & ; ;
100500: LD_ADDR_VAR 0 3
100504: PUSH
100505: LD_VAR 0 3
100509: PUSH
100510: LD_VAR 0 8
100514: STR
100515: PUSH
100516: LD_STRING ;
100518: STR
100519: ST_TO_ADDR
// end ;
100520: GO 100485
100522: POP
100523: POP
// for i = 1 to hardcoreCounter do
100524: LD_ADDR_VAR 0 8
100528: PUSH
100529: DOUBLE
100530: LD_INT 1
100532: DEC
100533: ST_TO_ADDR
100534: LD_EXP 79
100538: PUSH
100539: FOR_TO
100540: IFFALSE 100586
// begin if flags [ normalCounter + i ] then
100542: LD_VAR 0 4
100546: PUSH
100547: LD_EXP 78
100551: PUSH
100552: LD_VAR 0 8
100556: PLUS
100557: ARRAY
100558: IFFALSE 100584
// tmp := tmp & ( 100 + i ) & ; ;
100560: LD_ADDR_VAR 0 3
100564: PUSH
100565: LD_VAR 0 3
100569: PUSH
100570: LD_INT 100
100572: PUSH
100573: LD_VAR 0 8
100577: PLUS
100578: STR
100579: PUSH
100580: LD_STRING ;
100582: STR
100583: ST_TO_ADDR
// end ;
100584: GO 100539
100586: POP
100587: POP
// if tmp then
100588: LD_VAR 0 3
100592: IFFALSE 100604
// active := tmp ;
100594: LD_ADDR_VAR 0 7
100598: PUSH
100599: LD_VAR 0 3
100603: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100604: LD_STRING getStreamItemsFromMission("
100606: PUSH
100607: LD_VAR 0 5
100611: STR
100612: PUSH
100613: LD_STRING ","
100615: STR
100616: PUSH
100617: LD_VAR 0 6
100621: STR
100622: PUSH
100623: LD_STRING ","
100625: STR
100626: PUSH
100627: LD_VAR 0 7
100631: STR
100632: PUSH
100633: LD_STRING ")
100635: STR
100636: PPUSH
100637: CALL_OW 559
// end else
100641: GO 100650
// ToLua ( getStreamItemsFromMission("","","") ) ;
100643: LD_STRING getStreamItemsFromMission("","","")
100645: PPUSH
100646: CALL_OW 559
// end ;
100650: LD_VAR 0 2
100654: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100655: LD_EXP 77
100659: IFFALSE 100667
100661: PUSH
100662: LD_EXP 82
100666: AND
100667: IFFALSE 100791
100669: GO 100671
100671: DISABLE
100672: LD_INT 0
100674: PPUSH
100675: PPUSH
// begin enable ;
100676: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100677: LD_ADDR_VAR 0 2
100681: PUSH
100682: LD_INT 22
100684: PUSH
100685: LD_OWVAR 2
100689: PUSH
100690: EMPTY
100691: LIST
100692: LIST
100693: PUSH
100694: LD_INT 2
100696: PUSH
100697: LD_INT 34
100699: PUSH
100700: LD_INT 7
100702: PUSH
100703: EMPTY
100704: LIST
100705: LIST
100706: PUSH
100707: LD_INT 34
100709: PUSH
100710: LD_INT 45
100712: PUSH
100713: EMPTY
100714: LIST
100715: LIST
100716: PUSH
100717: LD_INT 34
100719: PUSH
100720: LD_INT 28
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: PUSH
100727: LD_INT 34
100729: PUSH
100730: LD_INT 47
100732: PUSH
100733: EMPTY
100734: LIST
100735: LIST
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: LIST
100741: LIST
100742: LIST
100743: PUSH
100744: EMPTY
100745: LIST
100746: LIST
100747: PPUSH
100748: CALL_OW 69
100752: ST_TO_ADDR
// if not tmp then
100753: LD_VAR 0 2
100757: NOT
100758: IFFALSE 100762
// exit ;
100760: GO 100791
// for i in tmp do
100762: LD_ADDR_VAR 0 1
100766: PUSH
100767: LD_VAR 0 2
100771: PUSH
100772: FOR_IN
100773: IFFALSE 100789
// begin SetLives ( i , 0 ) ;
100775: LD_VAR 0 1
100779: PPUSH
100780: LD_INT 0
100782: PPUSH
100783: CALL_OW 234
// end ;
100787: GO 100772
100789: POP
100790: POP
// end ;
100791: PPOPN 2
100793: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100794: LD_EXP 77
100798: IFFALSE 100806
100800: PUSH
100801: LD_EXP 83
100805: AND
100806: IFFALSE 100890
100808: GO 100810
100810: DISABLE
100811: LD_INT 0
100813: PPUSH
100814: PPUSH
// begin enable ;
100815: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100816: LD_ADDR_VAR 0 2
100820: PUSH
100821: LD_INT 22
100823: PUSH
100824: LD_OWVAR 2
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 32
100835: PUSH
100836: LD_INT 3
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: EMPTY
100844: LIST
100845: LIST
100846: PPUSH
100847: CALL_OW 69
100851: ST_TO_ADDR
// if not tmp then
100852: LD_VAR 0 2
100856: NOT
100857: IFFALSE 100861
// exit ;
100859: GO 100890
// for i in tmp do
100861: LD_ADDR_VAR 0 1
100865: PUSH
100866: LD_VAR 0 2
100870: PUSH
100871: FOR_IN
100872: IFFALSE 100888
// begin SetLives ( i , 0 ) ;
100874: LD_VAR 0 1
100878: PPUSH
100879: LD_INT 0
100881: PPUSH
100882: CALL_OW 234
// end ;
100886: GO 100871
100888: POP
100889: POP
// end ;
100890: PPOPN 2
100892: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100893: LD_EXP 77
100897: IFFALSE 100905
100899: PUSH
100900: LD_EXP 80
100904: AND
100905: IFFALSE 100998
100907: GO 100909
100909: DISABLE
100910: LD_INT 0
100912: PPUSH
// begin enable ;
100913: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100914: LD_ADDR_VAR 0 1
100918: PUSH
100919: LD_INT 22
100921: PUSH
100922: LD_OWVAR 2
100926: PUSH
100927: EMPTY
100928: LIST
100929: LIST
100930: PUSH
100931: LD_INT 2
100933: PUSH
100934: LD_INT 25
100936: PUSH
100937: LD_INT 5
100939: PUSH
100940: EMPTY
100941: LIST
100942: LIST
100943: PUSH
100944: LD_INT 25
100946: PUSH
100947: LD_INT 9
100949: PUSH
100950: EMPTY
100951: LIST
100952: LIST
100953: PUSH
100954: LD_INT 25
100956: PUSH
100957: LD_INT 8
100959: PUSH
100960: EMPTY
100961: LIST
100962: LIST
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: PUSH
100970: EMPTY
100971: LIST
100972: LIST
100973: PPUSH
100974: CALL_OW 69
100978: PUSH
100979: FOR_IN
100980: IFFALSE 100996
// begin SetClass ( i , 1 ) ;
100982: LD_VAR 0 1
100986: PPUSH
100987: LD_INT 1
100989: PPUSH
100990: CALL_OW 336
// end ;
100994: GO 100979
100996: POP
100997: POP
// end ;
100998: PPOPN 1
101000: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101001: LD_EXP 77
101005: IFFALSE 101013
101007: PUSH
101008: LD_EXP 81
101012: AND
101013: IFFALSE 101025
101015: PUSH
101016: LD_OWVAR 65
101020: PUSH
101021: LD_INT 7
101023: LESS
101024: AND
101025: IFFALSE 101039
101027: GO 101029
101029: DISABLE
// begin enable ;
101030: ENABLE
// game_speed := 7 ;
101031: LD_ADDR_OWVAR 65
101035: PUSH
101036: LD_INT 7
101038: ST_TO_ADDR
// end ;
101039: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101040: LD_EXP 77
101044: IFFALSE 101052
101046: PUSH
101047: LD_EXP 84
101051: AND
101052: IFFALSE 101254
101054: GO 101056
101056: DISABLE
101057: LD_INT 0
101059: PPUSH
101060: PPUSH
101061: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101062: LD_ADDR_VAR 0 3
101066: PUSH
101067: LD_INT 81
101069: PUSH
101070: LD_OWVAR 2
101074: PUSH
101075: EMPTY
101076: LIST
101077: LIST
101078: PUSH
101079: LD_INT 21
101081: PUSH
101082: LD_INT 1
101084: PUSH
101085: EMPTY
101086: LIST
101087: LIST
101088: PUSH
101089: EMPTY
101090: LIST
101091: LIST
101092: PPUSH
101093: CALL_OW 69
101097: ST_TO_ADDR
// if not tmp then
101098: LD_VAR 0 3
101102: NOT
101103: IFFALSE 101107
// exit ;
101105: GO 101254
// if tmp > 5 then
101107: LD_VAR 0 3
101111: PUSH
101112: LD_INT 5
101114: GREATER
101115: IFFALSE 101127
// k := 5 else
101117: LD_ADDR_VAR 0 2
101121: PUSH
101122: LD_INT 5
101124: ST_TO_ADDR
101125: GO 101137
// k := tmp ;
101127: LD_ADDR_VAR 0 2
101131: PUSH
101132: LD_VAR 0 3
101136: ST_TO_ADDR
// for i := 1 to k do
101137: LD_ADDR_VAR 0 1
101141: PUSH
101142: DOUBLE
101143: LD_INT 1
101145: DEC
101146: ST_TO_ADDR
101147: LD_VAR 0 2
101151: PUSH
101152: FOR_TO
101153: IFFALSE 101252
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101155: LD_VAR 0 3
101159: PUSH
101160: LD_VAR 0 1
101164: ARRAY
101165: PPUSH
101166: LD_VAR 0 1
101170: PUSH
101171: LD_INT 4
101173: MOD
101174: PUSH
101175: LD_INT 1
101177: PLUS
101178: PPUSH
101179: CALL_OW 259
101183: PUSH
101184: LD_INT 10
101186: LESS
101187: IFFALSE 101250
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101189: LD_VAR 0 3
101193: PUSH
101194: LD_VAR 0 1
101198: ARRAY
101199: PPUSH
101200: LD_VAR 0 1
101204: PUSH
101205: LD_INT 4
101207: MOD
101208: PUSH
101209: LD_INT 1
101211: PLUS
101212: PPUSH
101213: LD_VAR 0 3
101217: PUSH
101218: LD_VAR 0 1
101222: ARRAY
101223: PPUSH
101224: LD_VAR 0 1
101228: PUSH
101229: LD_INT 4
101231: MOD
101232: PUSH
101233: LD_INT 1
101235: PLUS
101236: PPUSH
101237: CALL_OW 259
101241: PUSH
101242: LD_INT 1
101244: PLUS
101245: PPUSH
101246: CALL_OW 237
101250: GO 101152
101252: POP
101253: POP
// end ;
101254: PPOPN 3
101256: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101257: LD_EXP 77
101261: IFFALSE 101269
101263: PUSH
101264: LD_EXP 85
101268: AND
101269: IFFALSE 101289
101271: GO 101273
101273: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101274: LD_INT 4
101276: PPUSH
101277: LD_OWVAR 2
101281: PPUSH
101282: LD_INT 0
101284: PPUSH
101285: CALL_OW 324
101289: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101290: LD_EXP 77
101294: IFFALSE 101302
101296: PUSH
101297: LD_EXP 114
101301: AND
101302: IFFALSE 101322
101304: GO 101306
101306: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101307: LD_INT 19
101309: PPUSH
101310: LD_OWVAR 2
101314: PPUSH
101315: LD_INT 0
101317: PPUSH
101318: CALL_OW 324
101322: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101323: LD_EXP 77
101327: IFFALSE 101335
101329: PUSH
101330: LD_EXP 86
101334: AND
101335: IFFALSE 101437
101337: GO 101339
101339: DISABLE
101340: LD_INT 0
101342: PPUSH
101343: PPUSH
// begin enable ;
101344: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101345: LD_ADDR_VAR 0 2
101349: PUSH
101350: LD_INT 22
101352: PUSH
101353: LD_OWVAR 2
101357: PUSH
101358: EMPTY
101359: LIST
101360: LIST
101361: PUSH
101362: LD_INT 2
101364: PUSH
101365: LD_INT 34
101367: PUSH
101368: LD_INT 11
101370: PUSH
101371: EMPTY
101372: LIST
101373: LIST
101374: PUSH
101375: LD_INT 34
101377: PUSH
101378: LD_INT 30
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: PUSH
101385: EMPTY
101386: LIST
101387: LIST
101388: LIST
101389: PUSH
101390: EMPTY
101391: LIST
101392: LIST
101393: PPUSH
101394: CALL_OW 69
101398: ST_TO_ADDR
// if not tmp then
101399: LD_VAR 0 2
101403: NOT
101404: IFFALSE 101408
// exit ;
101406: GO 101437
// for i in tmp do
101408: LD_ADDR_VAR 0 1
101412: PUSH
101413: LD_VAR 0 2
101417: PUSH
101418: FOR_IN
101419: IFFALSE 101435
// begin SetLives ( i , 0 ) ;
101421: LD_VAR 0 1
101425: PPUSH
101426: LD_INT 0
101428: PPUSH
101429: CALL_OW 234
// end ;
101433: GO 101418
101435: POP
101436: POP
// end ;
101437: PPOPN 2
101439: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101440: LD_EXP 77
101444: IFFALSE 101452
101446: PUSH
101447: LD_EXP 87
101451: AND
101452: IFFALSE 101472
101454: GO 101456
101456: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101457: LD_INT 32
101459: PPUSH
101460: LD_OWVAR 2
101464: PPUSH
101465: LD_INT 0
101467: PPUSH
101468: CALL_OW 324
101472: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101473: LD_EXP 77
101477: IFFALSE 101485
101479: PUSH
101480: LD_EXP 88
101484: AND
101485: IFFALSE 101668
101487: GO 101489
101489: DISABLE
101490: LD_INT 0
101492: PPUSH
101493: PPUSH
101494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101495: LD_ADDR_VAR 0 2
101499: PUSH
101500: LD_INT 22
101502: PUSH
101503: LD_OWVAR 2
101507: PUSH
101508: EMPTY
101509: LIST
101510: LIST
101511: PUSH
101512: LD_INT 33
101514: PUSH
101515: LD_INT 3
101517: PUSH
101518: EMPTY
101519: LIST
101520: LIST
101521: PUSH
101522: EMPTY
101523: LIST
101524: LIST
101525: PPUSH
101526: CALL_OW 69
101530: ST_TO_ADDR
// if not tmp then
101531: LD_VAR 0 2
101535: NOT
101536: IFFALSE 101540
// exit ;
101538: GO 101668
// side := 0 ;
101540: LD_ADDR_VAR 0 3
101544: PUSH
101545: LD_INT 0
101547: ST_TO_ADDR
// for i := 1 to 8 do
101548: LD_ADDR_VAR 0 1
101552: PUSH
101553: DOUBLE
101554: LD_INT 1
101556: DEC
101557: ST_TO_ADDR
101558: LD_INT 8
101560: PUSH
101561: FOR_TO
101562: IFFALSE 101612
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101564: LD_OWVAR 2
101568: PUSH
101569: LD_VAR 0 1
101573: NONEQUAL
101574: IFFALSE 101596
101576: PUSH
101577: LD_OWVAR 2
101581: PPUSH
101582: LD_VAR 0 1
101586: PPUSH
101587: CALL_OW 81
101591: PUSH
101592: LD_INT 2
101594: EQUAL
101595: AND
101596: IFFALSE 101610
// begin side := i ;
101598: LD_ADDR_VAR 0 3
101602: PUSH
101603: LD_VAR 0 1
101607: ST_TO_ADDR
// break ;
101608: GO 101612
// end ;
101610: GO 101561
101612: POP
101613: POP
// if not side then
101614: LD_VAR 0 3
101618: NOT
101619: IFFALSE 101623
// exit ;
101621: GO 101668
// for i := 1 to tmp do
101623: LD_ADDR_VAR 0 1
101627: PUSH
101628: DOUBLE
101629: LD_INT 1
101631: DEC
101632: ST_TO_ADDR
101633: LD_VAR 0 2
101637: PUSH
101638: FOR_TO
101639: IFFALSE 101666
// if Prob ( 60 ) then
101641: LD_INT 60
101643: PPUSH
101644: CALL_OW 13
101648: IFFALSE 101664
// SetSide ( i , side ) ;
101650: LD_VAR 0 1
101654: PPUSH
101655: LD_VAR 0 3
101659: PPUSH
101660: CALL_OW 235
101664: GO 101638
101666: POP
101667: POP
// end ;
101668: PPOPN 3
101670: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101671: LD_EXP 77
101675: IFFALSE 101683
101677: PUSH
101678: LD_EXP 90
101682: AND
101683: IFFALSE 101802
101685: GO 101687
101687: DISABLE
101688: LD_INT 0
101690: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101691: LD_ADDR_VAR 0 1
101695: PUSH
101696: LD_INT 22
101698: PUSH
101699: LD_OWVAR 2
101703: PUSH
101704: EMPTY
101705: LIST
101706: LIST
101707: PUSH
101708: LD_INT 21
101710: PUSH
101711: LD_INT 1
101713: PUSH
101714: EMPTY
101715: LIST
101716: LIST
101717: PUSH
101718: LD_INT 3
101720: PUSH
101721: LD_INT 23
101723: PUSH
101724: LD_INT 0
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: LIST
101739: PPUSH
101740: CALL_OW 69
101744: PUSH
101745: FOR_IN
101746: IFFALSE 101800
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101748: LD_VAR 0 1
101752: PPUSH
101753: CALL_OW 257
101757: PUSH
101758: LD_INT 1
101760: PUSH
101761: LD_INT 2
101763: PUSH
101764: LD_INT 3
101766: PUSH
101767: LD_INT 4
101769: PUSH
101770: EMPTY
101771: LIST
101772: LIST
101773: LIST
101774: LIST
101775: IN
101776: IFFALSE 101798
// SetClass ( un , rand ( 1 , 4 ) ) ;
101778: LD_VAR 0 1
101782: PPUSH
101783: LD_INT 1
101785: PPUSH
101786: LD_INT 4
101788: PPUSH
101789: CALL_OW 12
101793: PPUSH
101794: CALL_OW 336
101798: GO 101745
101800: POP
101801: POP
// end ;
101802: PPOPN 1
101804: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101805: LD_EXP 77
101809: IFFALSE 101817
101811: PUSH
101812: LD_EXP 89
101816: AND
101817: IFFALSE 101896
101819: GO 101821
101821: DISABLE
101822: LD_INT 0
101824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101825: LD_ADDR_VAR 0 1
101829: PUSH
101830: LD_INT 22
101832: PUSH
101833: LD_OWVAR 2
101837: PUSH
101838: EMPTY
101839: LIST
101840: LIST
101841: PUSH
101842: LD_INT 21
101844: PUSH
101845: LD_INT 3
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: PUSH
101852: EMPTY
101853: LIST
101854: LIST
101855: PPUSH
101856: CALL_OW 69
101860: ST_TO_ADDR
// if not tmp then
101861: LD_VAR 0 1
101865: NOT
101866: IFFALSE 101870
// exit ;
101868: GO 101896
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101870: LD_VAR 0 1
101874: PUSH
101875: LD_INT 1
101877: PPUSH
101878: LD_VAR 0 1
101882: PPUSH
101883: CALL_OW 12
101887: ARRAY
101888: PPUSH
101889: LD_INT 100
101891: PPUSH
101892: CALL_OW 234
// end ;
101896: PPOPN 1
101898: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101899: LD_EXP 77
101903: IFFALSE 101911
101905: PUSH
101906: LD_EXP 91
101910: AND
101911: IFFALSE 102009
101913: GO 101915
101915: DISABLE
101916: LD_INT 0
101918: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101919: LD_ADDR_VAR 0 1
101923: PUSH
101924: LD_INT 22
101926: PUSH
101927: LD_OWVAR 2
101931: PUSH
101932: EMPTY
101933: LIST
101934: LIST
101935: PUSH
101936: LD_INT 21
101938: PUSH
101939: LD_INT 1
101941: PUSH
101942: EMPTY
101943: LIST
101944: LIST
101945: PUSH
101946: EMPTY
101947: LIST
101948: LIST
101949: PPUSH
101950: CALL_OW 69
101954: ST_TO_ADDR
// if not tmp then
101955: LD_VAR 0 1
101959: NOT
101960: IFFALSE 101964
// exit ;
101962: GO 102009
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101964: LD_VAR 0 1
101968: PUSH
101969: LD_INT 1
101971: PPUSH
101972: LD_VAR 0 1
101976: PPUSH
101977: CALL_OW 12
101981: ARRAY
101982: PPUSH
101983: LD_INT 1
101985: PPUSH
101986: LD_INT 4
101988: PPUSH
101989: CALL_OW 12
101993: PPUSH
101994: LD_INT 3000
101996: PPUSH
101997: LD_INT 9000
101999: PPUSH
102000: CALL_OW 12
102004: PPUSH
102005: CALL_OW 492
// end ;
102009: PPOPN 1
102011: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102012: LD_EXP 77
102016: IFFALSE 102024
102018: PUSH
102019: LD_EXP 92
102023: AND
102024: IFFALSE 102044
102026: GO 102028
102028: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102029: LD_INT 1
102031: PPUSH
102032: LD_OWVAR 2
102036: PPUSH
102037: LD_INT 0
102039: PPUSH
102040: CALL_OW 324
102044: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102045: LD_EXP 77
102049: IFFALSE 102057
102051: PUSH
102052: LD_EXP 93
102056: AND
102057: IFFALSE 102140
102059: GO 102061
102061: DISABLE
102062: LD_INT 0
102064: PPUSH
102065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102066: LD_ADDR_VAR 0 2
102070: PUSH
102071: LD_INT 22
102073: PUSH
102074: LD_OWVAR 2
102078: PUSH
102079: EMPTY
102080: LIST
102081: LIST
102082: PUSH
102083: LD_INT 21
102085: PUSH
102086: LD_INT 3
102088: PUSH
102089: EMPTY
102090: LIST
102091: LIST
102092: PUSH
102093: EMPTY
102094: LIST
102095: LIST
102096: PPUSH
102097: CALL_OW 69
102101: ST_TO_ADDR
// if not tmp then
102102: LD_VAR 0 2
102106: NOT
102107: IFFALSE 102111
// exit ;
102109: GO 102140
// for i in tmp do
102111: LD_ADDR_VAR 0 1
102115: PUSH
102116: LD_VAR 0 2
102120: PUSH
102121: FOR_IN
102122: IFFALSE 102138
// SetBLevel ( i , 10 ) ;
102124: LD_VAR 0 1
102128: PPUSH
102129: LD_INT 10
102131: PPUSH
102132: CALL_OW 241
102136: GO 102121
102138: POP
102139: POP
// end ;
102140: PPOPN 2
102142: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102143: LD_EXP 77
102147: IFFALSE 102155
102149: PUSH
102150: LD_EXP 94
102154: AND
102155: IFFALSE 102266
102157: GO 102159
102159: DISABLE
102160: LD_INT 0
102162: PPUSH
102163: PPUSH
102164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102165: LD_ADDR_VAR 0 3
102169: PUSH
102170: LD_INT 22
102172: PUSH
102173: LD_OWVAR 2
102177: PUSH
102178: EMPTY
102179: LIST
102180: LIST
102181: PUSH
102182: LD_INT 25
102184: PUSH
102185: LD_INT 1
102187: PUSH
102188: EMPTY
102189: LIST
102190: LIST
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: PPUSH
102196: CALL_OW 69
102200: ST_TO_ADDR
// if not tmp then
102201: LD_VAR 0 3
102205: NOT
102206: IFFALSE 102210
// exit ;
102208: GO 102266
// un := tmp [ rand ( 1 , tmp ) ] ;
102210: LD_ADDR_VAR 0 2
102214: PUSH
102215: LD_VAR 0 3
102219: PUSH
102220: LD_INT 1
102222: PPUSH
102223: LD_VAR 0 3
102227: PPUSH
102228: CALL_OW 12
102232: ARRAY
102233: ST_TO_ADDR
// if Crawls ( un ) then
102234: LD_VAR 0 2
102238: PPUSH
102239: CALL_OW 318
102243: IFFALSE 102254
// ComWalk ( un ) ;
102245: LD_VAR 0 2
102249: PPUSH
102250: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102254: LD_VAR 0 2
102258: PPUSH
102259: LD_INT 5
102261: PPUSH
102262: CALL_OW 336
// end ;
102266: PPOPN 3
102268: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102269: LD_EXP 77
102273: IFFALSE 102281
102275: PUSH
102276: LD_EXP 95
102280: AND
102281: IFFALSE 102293
102283: PUSH
102284: LD_OWVAR 67
102288: PUSH
102289: LD_INT 4
102291: LESS
102292: AND
102293: IFFALSE 102312
102295: GO 102297
102297: DISABLE
// begin Difficulty := Difficulty + 1 ;
102298: LD_ADDR_OWVAR 67
102302: PUSH
102303: LD_OWVAR 67
102307: PUSH
102308: LD_INT 1
102310: PLUS
102311: ST_TO_ADDR
// end ;
102312: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102313: LD_EXP 77
102317: IFFALSE 102325
102319: PUSH
102320: LD_EXP 96
102324: AND
102325: IFFALSE 102428
102327: GO 102329
102329: DISABLE
102330: LD_INT 0
102332: PPUSH
// begin for i := 1 to 5 do
102333: LD_ADDR_VAR 0 1
102337: PUSH
102338: DOUBLE
102339: LD_INT 1
102341: DEC
102342: ST_TO_ADDR
102343: LD_INT 5
102345: PUSH
102346: FOR_TO
102347: IFFALSE 102426
// begin uc_nation := nation_nature ;
102349: LD_ADDR_OWVAR 21
102353: PUSH
102354: LD_INT 0
102356: ST_TO_ADDR
// uc_side := 0 ;
102357: LD_ADDR_OWVAR 20
102361: PUSH
102362: LD_INT 0
102364: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102365: LD_ADDR_OWVAR 29
102369: PUSH
102370: LD_INT 12
102372: PUSH
102373: LD_INT 12
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: ST_TO_ADDR
// hc_agressivity := 20 ;
102380: LD_ADDR_OWVAR 35
102384: PUSH
102385: LD_INT 20
102387: ST_TO_ADDR
// hc_class := class_tiger ;
102388: LD_ADDR_OWVAR 28
102392: PUSH
102393: LD_INT 14
102395: ST_TO_ADDR
// hc_gallery :=  ;
102396: LD_ADDR_OWVAR 33
102400: PUSH
102401: LD_STRING 
102403: ST_TO_ADDR
// hc_name :=  ;
102404: LD_ADDR_OWVAR 26
102408: PUSH
102409: LD_STRING 
102411: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102412: CALL_OW 44
102416: PPUSH
102417: LD_INT 0
102419: PPUSH
102420: CALL_OW 51
// end ;
102424: GO 102346
102426: POP
102427: POP
// end ;
102428: PPOPN 1
102430: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102431: LD_EXP 77
102435: IFFALSE 102443
102437: PUSH
102438: LD_EXP 97
102442: AND
102443: IFFALSE 102452
102445: GO 102447
102447: DISABLE
// StreamSibBomb ;
102448: CALL 102453 0 0
102452: END
// export function StreamSibBomb ; var i , x , y ; begin
102453: LD_INT 0
102455: PPUSH
102456: PPUSH
102457: PPUSH
102458: PPUSH
// result := false ;
102459: LD_ADDR_VAR 0 1
102463: PUSH
102464: LD_INT 0
102466: ST_TO_ADDR
// for i := 1 to 16 do
102467: LD_ADDR_VAR 0 2
102471: PUSH
102472: DOUBLE
102473: LD_INT 1
102475: DEC
102476: ST_TO_ADDR
102477: LD_INT 16
102479: PUSH
102480: FOR_TO
102481: IFFALSE 102680
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102483: LD_ADDR_VAR 0 3
102487: PUSH
102488: LD_INT 10
102490: PUSH
102491: LD_INT 20
102493: PUSH
102494: LD_INT 30
102496: PUSH
102497: LD_INT 40
102499: PUSH
102500: LD_INT 50
102502: PUSH
102503: LD_INT 60
102505: PUSH
102506: LD_INT 70
102508: PUSH
102509: LD_INT 80
102511: PUSH
102512: LD_INT 90
102514: PUSH
102515: LD_INT 100
102517: PUSH
102518: LD_INT 110
102520: PUSH
102521: LD_INT 120
102523: PUSH
102524: LD_INT 130
102526: PUSH
102527: LD_INT 140
102529: PUSH
102530: LD_INT 150
102532: PUSH
102533: EMPTY
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: LIST
102544: LIST
102545: LIST
102546: LIST
102547: LIST
102548: LIST
102549: PUSH
102550: LD_INT 1
102552: PPUSH
102553: LD_INT 15
102555: PPUSH
102556: CALL_OW 12
102560: ARRAY
102561: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102562: LD_ADDR_VAR 0 4
102566: PUSH
102567: LD_INT 10
102569: PUSH
102570: LD_INT 20
102572: PUSH
102573: LD_INT 30
102575: PUSH
102576: LD_INT 40
102578: PUSH
102579: LD_INT 50
102581: PUSH
102582: LD_INT 60
102584: PUSH
102585: LD_INT 70
102587: PUSH
102588: LD_INT 80
102590: PUSH
102591: LD_INT 90
102593: PUSH
102594: LD_INT 100
102596: PUSH
102597: LD_INT 110
102599: PUSH
102600: LD_INT 120
102602: PUSH
102603: LD_INT 130
102605: PUSH
102606: LD_INT 140
102608: PUSH
102609: LD_INT 150
102611: PUSH
102612: EMPTY
102613: LIST
102614: LIST
102615: LIST
102616: LIST
102617: LIST
102618: LIST
102619: LIST
102620: LIST
102621: LIST
102622: LIST
102623: LIST
102624: LIST
102625: LIST
102626: LIST
102627: LIST
102628: PUSH
102629: LD_INT 1
102631: PPUSH
102632: LD_INT 15
102634: PPUSH
102635: CALL_OW 12
102639: ARRAY
102640: ST_TO_ADDR
// if ValidHex ( x , y ) then
102641: LD_VAR 0 3
102645: PPUSH
102646: LD_VAR 0 4
102650: PPUSH
102651: CALL_OW 488
102655: IFFALSE 102678
// begin result := [ x , y ] ;
102657: LD_ADDR_VAR 0 1
102661: PUSH
102662: LD_VAR 0 3
102666: PUSH
102667: LD_VAR 0 4
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: ST_TO_ADDR
// break ;
102676: GO 102680
// end ; end ;
102678: GO 102480
102680: POP
102681: POP
// if result then
102682: LD_VAR 0 1
102686: IFFALSE 102746
// begin ToLua ( playSibBomb() ) ;
102688: LD_STRING playSibBomb()
102690: PPUSH
102691: CALL_OW 559
// wait ( 0 0$14 ) ;
102695: LD_INT 490
102697: PPUSH
102698: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102702: LD_VAR 0 1
102706: PUSH
102707: LD_INT 1
102709: ARRAY
102710: PPUSH
102711: LD_VAR 0 1
102715: PUSH
102716: LD_INT 2
102718: ARRAY
102719: PPUSH
102720: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102724: LD_VAR 0 1
102728: PUSH
102729: LD_INT 1
102731: ARRAY
102732: PPUSH
102733: LD_VAR 0 1
102737: PUSH
102738: LD_INT 2
102740: ARRAY
102741: PPUSH
102742: CALL_OW 429
// end ; end ;
102746: LD_VAR 0 1
102750: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102751: LD_EXP 77
102755: IFFALSE 102763
102757: PUSH
102758: LD_EXP 99
102762: AND
102763: IFFALSE 102775
102765: GO 102767
102767: DISABLE
// YouLost (  ) ;
102768: LD_STRING 
102770: PPUSH
102771: CALL_OW 104
102775: END
// every 0 0$1 trigger StreamModeActive and sFog do
102776: LD_EXP 77
102780: IFFALSE 102788
102782: PUSH
102783: LD_EXP 98
102787: AND
102788: IFFALSE 102802
102790: GO 102792
102792: DISABLE
// FogOff ( your_side ) ;
102793: LD_OWVAR 2
102797: PPUSH
102798: CALL_OW 344
102802: END
// every 0 0$1 trigger StreamModeActive and sSun do
102803: LD_EXP 77
102807: IFFALSE 102815
102809: PUSH
102810: LD_EXP 100
102814: AND
102815: IFFALSE 102843
102817: GO 102819
102819: DISABLE
// begin solar_recharge_percent := 0 ;
102820: LD_ADDR_OWVAR 79
102824: PUSH
102825: LD_INT 0
102827: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102828: LD_INT 10500
102830: PPUSH
102831: CALL_OW 67
// solar_recharge_percent := 100 ;
102835: LD_ADDR_OWVAR 79
102839: PUSH
102840: LD_INT 100
102842: ST_TO_ADDR
// end ;
102843: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102844: LD_EXP 77
102848: IFFALSE 102856
102850: PUSH
102851: LD_EXP 101
102855: AND
102856: IFFALSE 103095
102858: GO 102860
102860: DISABLE
102861: LD_INT 0
102863: PPUSH
102864: PPUSH
102865: PPUSH
// begin tmp := [ ] ;
102866: LD_ADDR_VAR 0 3
102870: PUSH
102871: EMPTY
102872: ST_TO_ADDR
// for i := 1 to 6 do
102873: LD_ADDR_VAR 0 1
102877: PUSH
102878: DOUBLE
102879: LD_INT 1
102881: DEC
102882: ST_TO_ADDR
102883: LD_INT 6
102885: PUSH
102886: FOR_TO
102887: IFFALSE 102992
// begin uc_nation := nation_nature ;
102889: LD_ADDR_OWVAR 21
102893: PUSH
102894: LD_INT 0
102896: ST_TO_ADDR
// uc_side := 0 ;
102897: LD_ADDR_OWVAR 20
102901: PUSH
102902: LD_INT 0
102904: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102905: LD_ADDR_OWVAR 29
102909: PUSH
102910: LD_INT 12
102912: PUSH
102913: LD_INT 12
102915: PUSH
102916: EMPTY
102917: LIST
102918: LIST
102919: ST_TO_ADDR
// hc_agressivity := 20 ;
102920: LD_ADDR_OWVAR 35
102924: PUSH
102925: LD_INT 20
102927: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102928: LD_ADDR_OWVAR 28
102932: PUSH
102933: LD_INT 17
102935: ST_TO_ADDR
// hc_gallery :=  ;
102936: LD_ADDR_OWVAR 33
102940: PUSH
102941: LD_STRING 
102943: ST_TO_ADDR
// hc_name :=  ;
102944: LD_ADDR_OWVAR 26
102948: PUSH
102949: LD_STRING 
102951: ST_TO_ADDR
// un := CreateHuman ;
102952: LD_ADDR_VAR 0 2
102956: PUSH
102957: CALL_OW 44
102961: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102962: LD_VAR 0 2
102966: PPUSH
102967: LD_INT 1
102969: PPUSH
102970: CALL_OW 51
// tmp := tmp ^ un ;
102974: LD_ADDR_VAR 0 3
102978: PUSH
102979: LD_VAR 0 3
102983: PUSH
102984: LD_VAR 0 2
102988: ADD
102989: ST_TO_ADDR
// end ;
102990: GO 102886
102992: POP
102993: POP
// repeat wait ( 0 0$1 ) ;
102994: LD_INT 35
102996: PPUSH
102997: CALL_OW 67
// for un in tmp do
103001: LD_ADDR_VAR 0 2
103005: PUSH
103006: LD_VAR 0 3
103010: PUSH
103011: FOR_IN
103012: IFFALSE 103086
// begin if IsDead ( un ) then
103014: LD_VAR 0 2
103018: PPUSH
103019: CALL_OW 301
103023: IFFALSE 103043
// begin tmp := tmp diff un ;
103025: LD_ADDR_VAR 0 3
103029: PUSH
103030: LD_VAR 0 3
103034: PUSH
103035: LD_VAR 0 2
103039: DIFF
103040: ST_TO_ADDR
// continue ;
103041: GO 103011
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103043: LD_VAR 0 2
103047: PPUSH
103048: LD_INT 3
103050: PUSH
103051: LD_INT 22
103053: PUSH
103054: LD_INT 0
103056: PUSH
103057: EMPTY
103058: LIST
103059: LIST
103060: PUSH
103061: EMPTY
103062: LIST
103063: LIST
103064: PPUSH
103065: CALL_OW 69
103069: PPUSH
103070: LD_VAR 0 2
103074: PPUSH
103075: CALL_OW 74
103079: PPUSH
103080: CALL_OW 115
// end ;
103084: GO 103011
103086: POP
103087: POP
// until not tmp ;
103088: LD_VAR 0 3
103092: NOT
103093: IFFALSE 102994
// end ;
103095: PPOPN 3
103097: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103098: LD_EXP 77
103102: IFFALSE 103110
103104: PUSH
103105: LD_EXP 102
103109: AND
103110: IFFALSE 103164
103112: GO 103114
103114: DISABLE
// begin ToLua ( displayTroll(); ) ;
103115: LD_STRING displayTroll();
103117: PPUSH
103118: CALL_OW 559
// wait ( 3 3$00 ) ;
103122: LD_INT 6300
103124: PPUSH
103125: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103129: LD_STRING hideTroll();
103131: PPUSH
103132: CALL_OW 559
// wait ( 1 1$00 ) ;
103136: LD_INT 2100
103138: PPUSH
103139: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103143: LD_STRING displayTroll();
103145: PPUSH
103146: CALL_OW 559
// wait ( 1 1$00 ) ;
103150: LD_INT 2100
103152: PPUSH
103153: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103157: LD_STRING hideTroll();
103159: PPUSH
103160: CALL_OW 559
// end ;
103164: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103165: LD_EXP 77
103169: IFFALSE 103177
103171: PUSH
103172: LD_EXP 103
103176: AND
103177: IFFALSE 103240
103179: GO 103181
103181: DISABLE
103182: LD_INT 0
103184: PPUSH
// begin p := 0 ;
103185: LD_ADDR_VAR 0 1
103189: PUSH
103190: LD_INT 0
103192: ST_TO_ADDR
// repeat game_speed := 1 ;
103193: LD_ADDR_OWVAR 65
103197: PUSH
103198: LD_INT 1
103200: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103201: LD_INT 35
103203: PPUSH
103204: CALL_OW 67
// p := p + 1 ;
103208: LD_ADDR_VAR 0 1
103212: PUSH
103213: LD_VAR 0 1
103217: PUSH
103218: LD_INT 1
103220: PLUS
103221: ST_TO_ADDR
// until p >= 60 ;
103222: LD_VAR 0 1
103226: PUSH
103227: LD_INT 60
103229: GREATEREQUAL
103230: IFFALSE 103193
// game_speed := 4 ;
103232: LD_ADDR_OWVAR 65
103236: PUSH
103237: LD_INT 4
103239: ST_TO_ADDR
// end ;
103240: PPOPN 1
103242: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103243: LD_EXP 77
103247: IFFALSE 103255
103249: PUSH
103250: LD_EXP 104
103254: AND
103255: IFFALSE 103401
103257: GO 103259
103259: DISABLE
103260: LD_INT 0
103262: PPUSH
103263: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103264: LD_ADDR_VAR 0 1
103268: PUSH
103269: LD_INT 22
103271: PUSH
103272: LD_OWVAR 2
103276: PUSH
103277: EMPTY
103278: LIST
103279: LIST
103280: PUSH
103281: LD_INT 2
103283: PUSH
103284: LD_INT 30
103286: PUSH
103287: LD_INT 0
103289: PUSH
103290: EMPTY
103291: LIST
103292: LIST
103293: PUSH
103294: LD_INT 30
103296: PUSH
103297: LD_INT 1
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: PUSH
103304: EMPTY
103305: LIST
103306: LIST
103307: LIST
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: PPUSH
103313: CALL_OW 69
103317: ST_TO_ADDR
// if not depot then
103318: LD_VAR 0 1
103322: NOT
103323: IFFALSE 103327
// exit ;
103325: GO 103401
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103327: LD_ADDR_VAR 0 2
103331: PUSH
103332: LD_VAR 0 1
103336: PUSH
103337: LD_INT 1
103339: PPUSH
103340: LD_VAR 0 1
103344: PPUSH
103345: CALL_OW 12
103349: ARRAY
103350: PPUSH
103351: CALL_OW 274
103355: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103356: LD_VAR 0 2
103360: PPUSH
103361: LD_INT 1
103363: PPUSH
103364: LD_INT 0
103366: PPUSH
103367: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103371: LD_VAR 0 2
103375: PPUSH
103376: LD_INT 2
103378: PPUSH
103379: LD_INT 0
103381: PPUSH
103382: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103386: LD_VAR 0 2
103390: PPUSH
103391: LD_INT 3
103393: PPUSH
103394: LD_INT 0
103396: PPUSH
103397: CALL_OW 277
// end ;
103401: PPOPN 2
103403: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103404: LD_EXP 77
103408: IFFALSE 103416
103410: PUSH
103411: LD_EXP 105
103415: AND
103416: IFFALSE 103513
103418: GO 103420
103420: DISABLE
103421: LD_INT 0
103423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103424: LD_ADDR_VAR 0 1
103428: PUSH
103429: LD_INT 22
103431: PUSH
103432: LD_OWVAR 2
103436: PUSH
103437: EMPTY
103438: LIST
103439: LIST
103440: PUSH
103441: LD_INT 21
103443: PUSH
103444: LD_INT 1
103446: PUSH
103447: EMPTY
103448: LIST
103449: LIST
103450: PUSH
103451: LD_INT 3
103453: PUSH
103454: LD_INT 23
103456: PUSH
103457: LD_INT 0
103459: PUSH
103460: EMPTY
103461: LIST
103462: LIST
103463: PUSH
103464: EMPTY
103465: LIST
103466: LIST
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: LIST
103472: PPUSH
103473: CALL_OW 69
103477: ST_TO_ADDR
// if not tmp then
103478: LD_VAR 0 1
103482: NOT
103483: IFFALSE 103487
// exit ;
103485: GO 103513
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103487: LD_VAR 0 1
103491: PUSH
103492: LD_INT 1
103494: PPUSH
103495: LD_VAR 0 1
103499: PPUSH
103500: CALL_OW 12
103504: ARRAY
103505: PPUSH
103506: LD_INT 200
103508: PPUSH
103509: CALL_OW 234
// end ;
103513: PPOPN 1
103515: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103516: LD_EXP 77
103520: IFFALSE 103528
103522: PUSH
103523: LD_EXP 106
103527: AND
103528: IFFALSE 103607
103530: GO 103532
103532: DISABLE
103533: LD_INT 0
103535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103536: LD_ADDR_VAR 0 1
103540: PUSH
103541: LD_INT 22
103543: PUSH
103544: LD_OWVAR 2
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: PUSH
103553: LD_INT 21
103555: PUSH
103556: LD_INT 2
103558: PUSH
103559: EMPTY
103560: LIST
103561: LIST
103562: PUSH
103563: EMPTY
103564: LIST
103565: LIST
103566: PPUSH
103567: CALL_OW 69
103571: ST_TO_ADDR
// if not tmp then
103572: LD_VAR 0 1
103576: NOT
103577: IFFALSE 103581
// exit ;
103579: GO 103607
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103581: LD_VAR 0 1
103585: PUSH
103586: LD_INT 1
103588: PPUSH
103589: LD_VAR 0 1
103593: PPUSH
103594: CALL_OW 12
103598: ARRAY
103599: PPUSH
103600: LD_INT 60
103602: PPUSH
103603: CALL_OW 234
// end ;
103607: PPOPN 1
103609: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103610: LD_EXP 77
103614: IFFALSE 103622
103616: PUSH
103617: LD_EXP 107
103621: AND
103622: IFFALSE 103721
103624: GO 103626
103626: DISABLE
103627: LD_INT 0
103629: PPUSH
103630: PPUSH
// begin enable ;
103631: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103632: LD_ADDR_VAR 0 1
103636: PUSH
103637: LD_INT 22
103639: PUSH
103640: LD_OWVAR 2
103644: PUSH
103645: EMPTY
103646: LIST
103647: LIST
103648: PUSH
103649: LD_INT 61
103651: PUSH
103652: EMPTY
103653: LIST
103654: PUSH
103655: LD_INT 33
103657: PUSH
103658: LD_INT 2
103660: PUSH
103661: EMPTY
103662: LIST
103663: LIST
103664: PUSH
103665: EMPTY
103666: LIST
103667: LIST
103668: LIST
103669: PPUSH
103670: CALL_OW 69
103674: ST_TO_ADDR
// if not tmp then
103675: LD_VAR 0 1
103679: NOT
103680: IFFALSE 103684
// exit ;
103682: GO 103721
// for i in tmp do
103684: LD_ADDR_VAR 0 2
103688: PUSH
103689: LD_VAR 0 1
103693: PUSH
103694: FOR_IN
103695: IFFALSE 103719
// if IsControledBy ( i ) then
103697: LD_VAR 0 2
103701: PPUSH
103702: CALL_OW 312
103706: IFFALSE 103717
// ComUnlink ( i ) ;
103708: LD_VAR 0 2
103712: PPUSH
103713: CALL_OW 136
103717: GO 103694
103719: POP
103720: POP
// end ;
103721: PPOPN 2
103723: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103724: LD_EXP 77
103728: IFFALSE 103736
103730: PUSH
103731: LD_EXP 108
103735: AND
103736: IFFALSE 103876
103738: GO 103740
103740: DISABLE
103741: LD_INT 0
103743: PPUSH
103744: PPUSH
// begin ToLua ( displayPowell(); ) ;
103745: LD_STRING displayPowell();
103747: PPUSH
103748: CALL_OW 559
// uc_side := 0 ;
103752: LD_ADDR_OWVAR 20
103756: PUSH
103757: LD_INT 0
103759: ST_TO_ADDR
// uc_nation := 2 ;
103760: LD_ADDR_OWVAR 21
103764: PUSH
103765: LD_INT 2
103767: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103768: LD_ADDR_OWVAR 37
103772: PUSH
103773: LD_INT 14
103775: ST_TO_ADDR
// vc_engine := engine_siberite ;
103776: LD_ADDR_OWVAR 39
103780: PUSH
103781: LD_INT 3
103783: ST_TO_ADDR
// vc_control := control_apeman ;
103784: LD_ADDR_OWVAR 38
103788: PUSH
103789: LD_INT 5
103791: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103792: LD_ADDR_OWVAR 40
103796: PUSH
103797: LD_INT 29
103799: ST_TO_ADDR
// un := CreateVehicle ;
103800: LD_ADDR_VAR 0 2
103804: PUSH
103805: CALL_OW 45
103809: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103810: LD_VAR 0 2
103814: PPUSH
103815: LD_INT 1
103817: PPUSH
103818: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103822: LD_INT 35
103824: PPUSH
103825: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103829: LD_VAR 0 2
103833: PPUSH
103834: LD_INT 22
103836: PUSH
103837: LD_OWVAR 2
103841: PUSH
103842: EMPTY
103843: LIST
103844: LIST
103845: PPUSH
103846: CALL_OW 69
103850: PPUSH
103851: LD_VAR 0 2
103855: PPUSH
103856: CALL_OW 74
103860: PPUSH
103861: CALL_OW 115
// until IsDead ( un ) ;
103865: LD_VAR 0 2
103869: PPUSH
103870: CALL_OW 301
103874: IFFALSE 103822
// end ;
103876: PPOPN 2
103878: END
// every 0 0$1 trigger StreamModeActive and sStu do
103879: LD_EXP 77
103883: IFFALSE 103891
103885: PUSH
103886: LD_EXP 116
103890: AND
103891: IFFALSE 103907
103893: GO 103895
103895: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103896: LD_STRING displayStucuk();
103898: PPUSH
103899: CALL_OW 559
// ResetFog ;
103903: CALL_OW 335
// end ;
103907: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103908: LD_EXP 77
103912: IFFALSE 103920
103914: PUSH
103915: LD_EXP 109
103919: AND
103920: IFFALSE 104061
103922: GO 103924
103924: DISABLE
103925: LD_INT 0
103927: PPUSH
103928: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103929: LD_ADDR_VAR 0 2
103933: PUSH
103934: LD_INT 22
103936: PUSH
103937: LD_OWVAR 2
103941: PUSH
103942: EMPTY
103943: LIST
103944: LIST
103945: PUSH
103946: LD_INT 21
103948: PUSH
103949: LD_INT 1
103951: PUSH
103952: EMPTY
103953: LIST
103954: LIST
103955: PUSH
103956: EMPTY
103957: LIST
103958: LIST
103959: PPUSH
103960: CALL_OW 69
103964: ST_TO_ADDR
// if not tmp then
103965: LD_VAR 0 2
103969: NOT
103970: IFFALSE 103974
// exit ;
103972: GO 104061
// un := tmp [ rand ( 1 , tmp ) ] ;
103974: LD_ADDR_VAR 0 1
103978: PUSH
103979: LD_VAR 0 2
103983: PUSH
103984: LD_INT 1
103986: PPUSH
103987: LD_VAR 0 2
103991: PPUSH
103992: CALL_OW 12
103996: ARRAY
103997: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103998: LD_VAR 0 1
104002: PPUSH
104003: LD_INT 0
104005: PPUSH
104006: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104010: LD_VAR 0 1
104014: PPUSH
104015: LD_OWVAR 3
104019: PUSH
104020: LD_VAR 0 1
104024: DIFF
104025: PPUSH
104026: LD_VAR 0 1
104030: PPUSH
104031: CALL_OW 74
104035: PPUSH
104036: CALL_OW 115
// wait ( 0 0$20 ) ;
104040: LD_INT 700
104042: PPUSH
104043: CALL_OW 67
// SetSide ( un , your_side ) ;
104047: LD_VAR 0 1
104051: PPUSH
104052: LD_OWVAR 2
104056: PPUSH
104057: CALL_OW 235
// end ;
104061: PPOPN 2
104063: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104064: LD_EXP 77
104068: IFFALSE 104076
104070: PUSH
104071: LD_EXP 110
104075: AND
104076: IFFALSE 104182
104078: GO 104080
104080: DISABLE
104081: LD_INT 0
104083: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104084: LD_ADDR_VAR 0 1
104088: PUSH
104089: LD_INT 22
104091: PUSH
104092: LD_OWVAR 2
104096: PUSH
104097: EMPTY
104098: LIST
104099: LIST
104100: PUSH
104101: LD_INT 2
104103: PUSH
104104: LD_INT 30
104106: PUSH
104107: LD_INT 0
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: PUSH
104114: LD_INT 30
104116: PUSH
104117: LD_INT 1
104119: PUSH
104120: EMPTY
104121: LIST
104122: LIST
104123: PUSH
104124: EMPTY
104125: LIST
104126: LIST
104127: LIST
104128: PUSH
104129: EMPTY
104130: LIST
104131: LIST
104132: PPUSH
104133: CALL_OW 69
104137: ST_TO_ADDR
// if not depot then
104138: LD_VAR 0 1
104142: NOT
104143: IFFALSE 104147
// exit ;
104145: GO 104182
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104147: LD_VAR 0 1
104151: PUSH
104152: LD_INT 1
104154: ARRAY
104155: PPUSH
104156: CALL_OW 250
104160: PPUSH
104161: LD_VAR 0 1
104165: PUSH
104166: LD_INT 1
104168: ARRAY
104169: PPUSH
104170: CALL_OW 251
104174: PPUSH
104175: LD_INT 70
104177: PPUSH
104178: CALL_OW 495
// end ;
104182: PPOPN 1
104184: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104185: LD_EXP 77
104189: IFFALSE 104197
104191: PUSH
104192: LD_EXP 111
104196: AND
104197: IFFALSE 104408
104199: GO 104201
104201: DISABLE
104202: LD_INT 0
104204: PPUSH
104205: PPUSH
104206: PPUSH
104207: PPUSH
104208: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104209: LD_ADDR_VAR 0 5
104213: PUSH
104214: LD_INT 22
104216: PUSH
104217: LD_OWVAR 2
104221: PUSH
104222: EMPTY
104223: LIST
104224: LIST
104225: PUSH
104226: LD_INT 21
104228: PUSH
104229: LD_INT 1
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: PUSH
104236: EMPTY
104237: LIST
104238: LIST
104239: PPUSH
104240: CALL_OW 69
104244: ST_TO_ADDR
// if not tmp then
104245: LD_VAR 0 5
104249: NOT
104250: IFFALSE 104254
// exit ;
104252: GO 104408
// for i in tmp do
104254: LD_ADDR_VAR 0 1
104258: PUSH
104259: LD_VAR 0 5
104263: PUSH
104264: FOR_IN
104265: IFFALSE 104406
// begin d := rand ( 0 , 5 ) ;
104267: LD_ADDR_VAR 0 4
104271: PUSH
104272: LD_INT 0
104274: PPUSH
104275: LD_INT 5
104277: PPUSH
104278: CALL_OW 12
104282: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104283: LD_ADDR_VAR 0 2
104287: PUSH
104288: LD_VAR 0 1
104292: PPUSH
104293: CALL_OW 250
104297: PPUSH
104298: LD_VAR 0 4
104302: PPUSH
104303: LD_INT 3
104305: PPUSH
104306: LD_INT 12
104308: PPUSH
104309: CALL_OW 12
104313: PPUSH
104314: CALL_OW 272
104318: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104319: LD_ADDR_VAR 0 3
104323: PUSH
104324: LD_VAR 0 1
104328: PPUSH
104329: CALL_OW 251
104333: PPUSH
104334: LD_VAR 0 4
104338: PPUSH
104339: LD_INT 3
104341: PPUSH
104342: LD_INT 12
104344: PPUSH
104345: CALL_OW 12
104349: PPUSH
104350: CALL_OW 273
104354: ST_TO_ADDR
// if ValidHex ( x , y ) then
104355: LD_VAR 0 2
104359: PPUSH
104360: LD_VAR 0 3
104364: PPUSH
104365: CALL_OW 488
104369: IFFALSE 104404
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104371: LD_VAR 0 1
104375: PPUSH
104376: LD_VAR 0 2
104380: PPUSH
104381: LD_VAR 0 3
104385: PPUSH
104386: LD_INT 3
104388: PPUSH
104389: LD_INT 6
104391: PPUSH
104392: CALL_OW 12
104396: PPUSH
104397: LD_INT 1
104399: PPUSH
104400: CALL_OW 483
// end ;
104404: GO 104264
104406: POP
104407: POP
// end ;
104408: PPOPN 5
104410: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104411: LD_EXP 77
104415: IFFALSE 104423
104417: PUSH
104418: LD_EXP 112
104422: AND
104423: IFFALSE 104517
104425: GO 104427
104427: DISABLE
104428: LD_INT 0
104430: PPUSH
104431: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104432: LD_ADDR_VAR 0 2
104436: PUSH
104437: LD_INT 22
104439: PUSH
104440: LD_OWVAR 2
104444: PUSH
104445: EMPTY
104446: LIST
104447: LIST
104448: PUSH
104449: LD_INT 32
104451: PUSH
104452: LD_INT 1
104454: PUSH
104455: EMPTY
104456: LIST
104457: LIST
104458: PUSH
104459: LD_INT 21
104461: PUSH
104462: LD_INT 2
104464: PUSH
104465: EMPTY
104466: LIST
104467: LIST
104468: PUSH
104469: EMPTY
104470: LIST
104471: LIST
104472: LIST
104473: PPUSH
104474: CALL_OW 69
104478: ST_TO_ADDR
// if not tmp then
104479: LD_VAR 0 2
104483: NOT
104484: IFFALSE 104488
// exit ;
104486: GO 104517
// for i in tmp do
104488: LD_ADDR_VAR 0 1
104492: PUSH
104493: LD_VAR 0 2
104497: PUSH
104498: FOR_IN
104499: IFFALSE 104515
// SetFuel ( i , 0 ) ;
104501: LD_VAR 0 1
104505: PPUSH
104506: LD_INT 0
104508: PPUSH
104509: CALL_OW 240
104513: GO 104498
104515: POP
104516: POP
// end ;
104517: PPOPN 2
104519: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104520: LD_EXP 77
104524: IFFALSE 104532
104526: PUSH
104527: LD_EXP 113
104531: AND
104532: IFFALSE 104598
104534: GO 104536
104536: DISABLE
104537: LD_INT 0
104539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104540: LD_ADDR_VAR 0 1
104544: PUSH
104545: LD_INT 22
104547: PUSH
104548: LD_OWVAR 2
104552: PUSH
104553: EMPTY
104554: LIST
104555: LIST
104556: PUSH
104557: LD_INT 30
104559: PUSH
104560: LD_INT 29
104562: PUSH
104563: EMPTY
104564: LIST
104565: LIST
104566: PUSH
104567: EMPTY
104568: LIST
104569: LIST
104570: PPUSH
104571: CALL_OW 69
104575: ST_TO_ADDR
// if not tmp then
104576: LD_VAR 0 1
104580: NOT
104581: IFFALSE 104585
// exit ;
104583: GO 104598
// DestroyUnit ( tmp [ 1 ] ) ;
104585: LD_VAR 0 1
104589: PUSH
104590: LD_INT 1
104592: ARRAY
104593: PPUSH
104594: CALL_OW 65
// end ;
104598: PPOPN 1
104600: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104601: LD_EXP 77
104605: IFFALSE 104613
104607: PUSH
104608: LD_EXP 115
104612: AND
104613: IFFALSE 104742
104615: GO 104617
104617: DISABLE
104618: LD_INT 0
104620: PPUSH
// begin uc_side := 0 ;
104621: LD_ADDR_OWVAR 20
104625: PUSH
104626: LD_INT 0
104628: ST_TO_ADDR
// uc_nation := nation_arabian ;
104629: LD_ADDR_OWVAR 21
104633: PUSH
104634: LD_INT 2
104636: ST_TO_ADDR
// hc_gallery :=  ;
104637: LD_ADDR_OWVAR 33
104641: PUSH
104642: LD_STRING 
104644: ST_TO_ADDR
// hc_name :=  ;
104645: LD_ADDR_OWVAR 26
104649: PUSH
104650: LD_STRING 
104652: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104653: LD_INT 1
104655: PPUSH
104656: LD_INT 11
104658: PPUSH
104659: LD_INT 10
104661: PPUSH
104662: CALL_OW 380
// un := CreateHuman ;
104666: LD_ADDR_VAR 0 1
104670: PUSH
104671: CALL_OW 44
104675: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104676: LD_VAR 0 1
104680: PPUSH
104681: LD_INT 1
104683: PPUSH
104684: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104688: LD_INT 35
104690: PPUSH
104691: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104695: LD_VAR 0 1
104699: PPUSH
104700: LD_INT 22
104702: PUSH
104703: LD_OWVAR 2
104707: PUSH
104708: EMPTY
104709: LIST
104710: LIST
104711: PPUSH
104712: CALL_OW 69
104716: PPUSH
104717: LD_VAR 0 1
104721: PPUSH
104722: CALL_OW 74
104726: PPUSH
104727: CALL_OW 115
// until IsDead ( un ) ;
104731: LD_VAR 0 1
104735: PPUSH
104736: CALL_OW 301
104740: IFFALSE 104688
// end ;
104742: PPOPN 1
104744: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104745: LD_EXP 77
104749: IFFALSE 104757
104751: PUSH
104752: LD_EXP 117
104756: AND
104757: IFFALSE 104769
104759: GO 104761
104761: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104762: LD_STRING earthquake(getX(game), 0, 32)
104764: PPUSH
104765: CALL_OW 559
104769: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104770: LD_EXP 77
104774: IFFALSE 104782
104776: PUSH
104777: LD_EXP 118
104781: AND
104782: IFFALSE 104873
104784: GO 104786
104786: DISABLE
104787: LD_INT 0
104789: PPUSH
// begin enable ;
104790: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104791: LD_ADDR_VAR 0 1
104795: PUSH
104796: LD_INT 22
104798: PUSH
104799: LD_OWVAR 2
104803: PUSH
104804: EMPTY
104805: LIST
104806: LIST
104807: PUSH
104808: LD_INT 21
104810: PUSH
104811: LD_INT 2
104813: PUSH
104814: EMPTY
104815: LIST
104816: LIST
104817: PUSH
104818: LD_INT 33
104820: PUSH
104821: LD_INT 3
104823: PUSH
104824: EMPTY
104825: LIST
104826: LIST
104827: PUSH
104828: EMPTY
104829: LIST
104830: LIST
104831: LIST
104832: PPUSH
104833: CALL_OW 69
104837: ST_TO_ADDR
// if not tmp then
104838: LD_VAR 0 1
104842: NOT
104843: IFFALSE 104847
// exit ;
104845: GO 104873
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104847: LD_VAR 0 1
104851: PUSH
104852: LD_INT 1
104854: PPUSH
104855: LD_VAR 0 1
104859: PPUSH
104860: CALL_OW 12
104864: ARRAY
104865: PPUSH
104866: LD_INT 1
104868: PPUSH
104869: CALL_OW 234
// end ;
104873: PPOPN 1
104875: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104876: LD_EXP 77
104880: IFFALSE 104888
104882: PUSH
104883: LD_EXP 119
104887: AND
104888: IFFALSE 105029
104890: GO 104892
104892: DISABLE
104893: LD_INT 0
104895: PPUSH
104896: PPUSH
104897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104898: LD_ADDR_VAR 0 3
104902: PUSH
104903: LD_INT 22
104905: PUSH
104906: LD_OWVAR 2
104910: PUSH
104911: EMPTY
104912: LIST
104913: LIST
104914: PUSH
104915: LD_INT 25
104917: PUSH
104918: LD_INT 1
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: PUSH
104925: EMPTY
104926: LIST
104927: LIST
104928: PPUSH
104929: CALL_OW 69
104933: ST_TO_ADDR
// if not tmp then
104934: LD_VAR 0 3
104938: NOT
104939: IFFALSE 104943
// exit ;
104941: GO 105029
// un := tmp [ rand ( 1 , tmp ) ] ;
104943: LD_ADDR_VAR 0 2
104947: PUSH
104948: LD_VAR 0 3
104952: PUSH
104953: LD_INT 1
104955: PPUSH
104956: LD_VAR 0 3
104960: PPUSH
104961: CALL_OW 12
104965: ARRAY
104966: ST_TO_ADDR
// if Crawls ( un ) then
104967: LD_VAR 0 2
104971: PPUSH
104972: CALL_OW 318
104976: IFFALSE 104987
// ComWalk ( un ) ;
104978: LD_VAR 0 2
104982: PPUSH
104983: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104987: LD_VAR 0 2
104991: PPUSH
104992: LD_INT 9
104994: PPUSH
104995: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104999: LD_INT 28
105001: PPUSH
105002: LD_OWVAR 2
105006: PPUSH
105007: LD_INT 2
105009: PPUSH
105010: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105014: LD_INT 29
105016: PPUSH
105017: LD_OWVAR 2
105021: PPUSH
105022: LD_INT 2
105024: PPUSH
105025: CALL_OW 322
// end ;
105029: PPOPN 3
105031: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105032: LD_EXP 77
105036: IFFALSE 105044
105038: PUSH
105039: LD_EXP 120
105043: AND
105044: IFFALSE 105155
105046: GO 105048
105048: DISABLE
105049: LD_INT 0
105051: PPUSH
105052: PPUSH
105053: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105054: LD_ADDR_VAR 0 3
105058: PUSH
105059: LD_INT 22
105061: PUSH
105062: LD_OWVAR 2
105066: PUSH
105067: EMPTY
105068: LIST
105069: LIST
105070: PUSH
105071: LD_INT 25
105073: PUSH
105074: LD_INT 1
105076: PUSH
105077: EMPTY
105078: LIST
105079: LIST
105080: PUSH
105081: EMPTY
105082: LIST
105083: LIST
105084: PPUSH
105085: CALL_OW 69
105089: ST_TO_ADDR
// if not tmp then
105090: LD_VAR 0 3
105094: NOT
105095: IFFALSE 105099
// exit ;
105097: GO 105155
// un := tmp [ rand ( 1 , tmp ) ] ;
105099: LD_ADDR_VAR 0 2
105103: PUSH
105104: LD_VAR 0 3
105108: PUSH
105109: LD_INT 1
105111: PPUSH
105112: LD_VAR 0 3
105116: PPUSH
105117: CALL_OW 12
105121: ARRAY
105122: ST_TO_ADDR
// if Crawls ( un ) then
105123: LD_VAR 0 2
105127: PPUSH
105128: CALL_OW 318
105132: IFFALSE 105143
// ComWalk ( un ) ;
105134: LD_VAR 0 2
105138: PPUSH
105139: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105143: LD_VAR 0 2
105147: PPUSH
105148: LD_INT 8
105150: PPUSH
105151: CALL_OW 336
// end ;
105155: PPOPN 3
105157: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105158: LD_EXP 77
105162: IFFALSE 105170
105164: PUSH
105165: LD_EXP 121
105169: AND
105170: IFFALSE 105314
105172: GO 105174
105174: DISABLE
105175: LD_INT 0
105177: PPUSH
105178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105179: LD_ADDR_VAR 0 2
105183: PUSH
105184: LD_INT 22
105186: PUSH
105187: LD_OWVAR 2
105191: PUSH
105192: EMPTY
105193: LIST
105194: LIST
105195: PUSH
105196: LD_INT 21
105198: PUSH
105199: LD_INT 2
105201: PUSH
105202: EMPTY
105203: LIST
105204: LIST
105205: PUSH
105206: LD_INT 2
105208: PUSH
105209: LD_INT 34
105211: PUSH
105212: LD_INT 12
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: PUSH
105219: LD_INT 34
105221: PUSH
105222: LD_INT 51
105224: PUSH
105225: EMPTY
105226: LIST
105227: LIST
105228: PUSH
105229: LD_INT 34
105231: PUSH
105232: LD_INT 32
105234: PUSH
105235: EMPTY
105236: LIST
105237: LIST
105238: PUSH
105239: EMPTY
105240: LIST
105241: LIST
105242: LIST
105243: LIST
105244: PUSH
105245: EMPTY
105246: LIST
105247: LIST
105248: LIST
105249: PPUSH
105250: CALL_OW 69
105254: ST_TO_ADDR
// if not tmp then
105255: LD_VAR 0 2
105259: NOT
105260: IFFALSE 105264
// exit ;
105262: GO 105314
// for i in tmp do
105264: LD_ADDR_VAR 0 1
105268: PUSH
105269: LD_VAR 0 2
105273: PUSH
105274: FOR_IN
105275: IFFALSE 105312
// if GetCargo ( i , mat_artifact ) = 0 then
105277: LD_VAR 0 1
105281: PPUSH
105282: LD_INT 4
105284: PPUSH
105285: CALL_OW 289
105289: PUSH
105290: LD_INT 0
105292: EQUAL
105293: IFFALSE 105310
// SetCargo ( i , mat_siberit , 100 ) ;
105295: LD_VAR 0 1
105299: PPUSH
105300: LD_INT 3
105302: PPUSH
105303: LD_INT 100
105305: PPUSH
105306: CALL_OW 290
105310: GO 105274
105312: POP
105313: POP
// end ;
105314: PPOPN 2
105316: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105317: LD_EXP 77
105321: IFFALSE 105329
105323: PUSH
105324: LD_EXP 122
105328: AND
105329: IFFALSE 105512
105331: GO 105333
105333: DISABLE
105334: LD_INT 0
105336: PPUSH
105337: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105338: LD_ADDR_VAR 0 2
105342: PUSH
105343: LD_INT 22
105345: PUSH
105346: LD_OWVAR 2
105350: PUSH
105351: EMPTY
105352: LIST
105353: LIST
105354: PPUSH
105355: CALL_OW 69
105359: ST_TO_ADDR
// if not tmp then
105360: LD_VAR 0 2
105364: NOT
105365: IFFALSE 105369
// exit ;
105367: GO 105512
// for i := 1 to 2 do
105369: LD_ADDR_VAR 0 1
105373: PUSH
105374: DOUBLE
105375: LD_INT 1
105377: DEC
105378: ST_TO_ADDR
105379: LD_INT 2
105381: PUSH
105382: FOR_TO
105383: IFFALSE 105510
// begin uc_side := your_side ;
105385: LD_ADDR_OWVAR 20
105389: PUSH
105390: LD_OWVAR 2
105394: ST_TO_ADDR
// uc_nation := nation_american ;
105395: LD_ADDR_OWVAR 21
105399: PUSH
105400: LD_INT 1
105402: ST_TO_ADDR
// vc_chassis := us_morphling ;
105403: LD_ADDR_OWVAR 37
105407: PUSH
105408: LD_INT 5
105410: ST_TO_ADDR
// vc_engine := engine_siberite ;
105411: LD_ADDR_OWVAR 39
105415: PUSH
105416: LD_INT 3
105418: ST_TO_ADDR
// vc_control := control_computer ;
105419: LD_ADDR_OWVAR 38
105423: PUSH
105424: LD_INT 3
105426: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105427: LD_ADDR_OWVAR 40
105431: PUSH
105432: LD_INT 10
105434: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105435: LD_VAR 0 2
105439: PUSH
105440: LD_INT 1
105442: ARRAY
105443: PPUSH
105444: CALL_OW 310
105448: NOT
105449: IFFALSE 105496
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105451: CALL_OW 45
105455: PPUSH
105456: LD_VAR 0 2
105460: PUSH
105461: LD_INT 1
105463: ARRAY
105464: PPUSH
105465: CALL_OW 250
105469: PPUSH
105470: LD_VAR 0 2
105474: PUSH
105475: LD_INT 1
105477: ARRAY
105478: PPUSH
105479: CALL_OW 251
105483: PPUSH
105484: LD_INT 12
105486: PPUSH
105487: LD_INT 1
105489: PPUSH
105490: CALL_OW 50
105494: GO 105508
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105496: CALL_OW 45
105500: PPUSH
105501: LD_INT 1
105503: PPUSH
105504: CALL_OW 51
// end ;
105508: GO 105382
105510: POP
105511: POP
// end ;
105512: PPOPN 2
105514: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105515: LD_EXP 77
105519: IFFALSE 105527
105521: PUSH
105522: LD_EXP 123
105526: AND
105527: IFFALSE 105749
105529: GO 105531
105531: DISABLE
105532: LD_INT 0
105534: PPUSH
105535: PPUSH
105536: PPUSH
105537: PPUSH
105538: PPUSH
105539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105540: LD_ADDR_VAR 0 6
105544: PUSH
105545: LD_INT 22
105547: PUSH
105548: LD_OWVAR 2
105552: PUSH
105553: EMPTY
105554: LIST
105555: LIST
105556: PUSH
105557: LD_INT 21
105559: PUSH
105560: LD_INT 1
105562: PUSH
105563: EMPTY
105564: LIST
105565: LIST
105566: PUSH
105567: LD_INT 3
105569: PUSH
105570: LD_INT 23
105572: PUSH
105573: LD_INT 0
105575: PUSH
105576: EMPTY
105577: LIST
105578: LIST
105579: PUSH
105580: EMPTY
105581: LIST
105582: LIST
105583: PUSH
105584: EMPTY
105585: LIST
105586: LIST
105587: LIST
105588: PPUSH
105589: CALL_OW 69
105593: ST_TO_ADDR
// if not tmp then
105594: LD_VAR 0 6
105598: NOT
105599: IFFALSE 105603
// exit ;
105601: GO 105749
// s1 := rand ( 1 , 4 ) ;
105603: LD_ADDR_VAR 0 2
105607: PUSH
105608: LD_INT 1
105610: PPUSH
105611: LD_INT 4
105613: PPUSH
105614: CALL_OW 12
105618: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105619: LD_ADDR_VAR 0 4
105623: PUSH
105624: LD_VAR 0 6
105628: PUSH
105629: LD_INT 1
105631: ARRAY
105632: PPUSH
105633: LD_VAR 0 2
105637: PPUSH
105638: CALL_OW 259
105642: ST_TO_ADDR
// if s1 = 1 then
105643: LD_VAR 0 2
105647: PUSH
105648: LD_INT 1
105650: EQUAL
105651: IFFALSE 105671
// s2 := rand ( 2 , 4 ) else
105653: LD_ADDR_VAR 0 3
105657: PUSH
105658: LD_INT 2
105660: PPUSH
105661: LD_INT 4
105663: PPUSH
105664: CALL_OW 12
105668: ST_TO_ADDR
105669: GO 105679
// s2 := 1 ;
105671: LD_ADDR_VAR 0 3
105675: PUSH
105676: LD_INT 1
105678: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105679: LD_ADDR_VAR 0 5
105683: PUSH
105684: LD_VAR 0 6
105688: PUSH
105689: LD_INT 1
105691: ARRAY
105692: PPUSH
105693: LD_VAR 0 3
105697: PPUSH
105698: CALL_OW 259
105702: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105703: LD_VAR 0 6
105707: PUSH
105708: LD_INT 1
105710: ARRAY
105711: PPUSH
105712: LD_VAR 0 2
105716: PPUSH
105717: LD_VAR 0 5
105721: PPUSH
105722: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105726: LD_VAR 0 6
105730: PUSH
105731: LD_INT 1
105733: ARRAY
105734: PPUSH
105735: LD_VAR 0 3
105739: PPUSH
105740: LD_VAR 0 4
105744: PPUSH
105745: CALL_OW 237
// end ;
105749: PPOPN 6
105751: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105752: LD_EXP 77
105756: IFFALSE 105764
105758: PUSH
105759: LD_EXP 124
105763: AND
105764: IFFALSE 105843
105766: GO 105768
105768: DISABLE
105769: LD_INT 0
105771: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105772: LD_ADDR_VAR 0 1
105776: PUSH
105777: LD_INT 22
105779: PUSH
105780: LD_OWVAR 2
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: PUSH
105789: LD_INT 30
105791: PUSH
105792: LD_INT 3
105794: PUSH
105795: EMPTY
105796: LIST
105797: LIST
105798: PUSH
105799: EMPTY
105800: LIST
105801: LIST
105802: PPUSH
105803: CALL_OW 69
105807: ST_TO_ADDR
// if not tmp then
105808: LD_VAR 0 1
105812: NOT
105813: IFFALSE 105817
// exit ;
105815: GO 105843
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105817: LD_VAR 0 1
105821: PUSH
105822: LD_INT 1
105824: PPUSH
105825: LD_VAR 0 1
105829: PPUSH
105830: CALL_OW 12
105834: ARRAY
105835: PPUSH
105836: LD_INT 1
105838: PPUSH
105839: CALL_OW 234
// end ;
105843: PPOPN 1
105845: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105846: LD_EXP 77
105850: IFFALSE 105858
105852: PUSH
105853: LD_EXP 125
105857: AND
105858: IFFALSE 105970
105860: GO 105862
105862: DISABLE
105863: LD_INT 0
105865: PPUSH
105866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105867: LD_ADDR_VAR 0 2
105871: PUSH
105872: LD_INT 22
105874: PUSH
105875: LD_OWVAR 2
105879: PUSH
105880: EMPTY
105881: LIST
105882: LIST
105883: PUSH
105884: LD_INT 2
105886: PUSH
105887: LD_INT 30
105889: PUSH
105890: LD_INT 27
105892: PUSH
105893: EMPTY
105894: LIST
105895: LIST
105896: PUSH
105897: LD_INT 30
105899: PUSH
105900: LD_INT 26
105902: PUSH
105903: EMPTY
105904: LIST
105905: LIST
105906: PUSH
105907: LD_INT 30
105909: PUSH
105910: LD_INT 28
105912: PUSH
105913: EMPTY
105914: LIST
105915: LIST
105916: PUSH
105917: EMPTY
105918: LIST
105919: LIST
105920: LIST
105921: LIST
105922: PUSH
105923: EMPTY
105924: LIST
105925: LIST
105926: PPUSH
105927: CALL_OW 69
105931: ST_TO_ADDR
// if not tmp then
105932: LD_VAR 0 2
105936: NOT
105937: IFFALSE 105941
// exit ;
105939: GO 105970
// for i in tmp do
105941: LD_ADDR_VAR 0 1
105945: PUSH
105946: LD_VAR 0 2
105950: PUSH
105951: FOR_IN
105952: IFFALSE 105968
// SetLives ( i , 1 ) ;
105954: LD_VAR 0 1
105958: PPUSH
105959: LD_INT 1
105961: PPUSH
105962: CALL_OW 234
105966: GO 105951
105968: POP
105969: POP
// end ;
105970: PPOPN 2
105972: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105973: LD_EXP 77
105977: IFFALSE 105985
105979: PUSH
105980: LD_EXP 126
105984: AND
105985: IFFALSE 106272
105987: GO 105989
105989: DISABLE
105990: LD_INT 0
105992: PPUSH
105993: PPUSH
105994: PPUSH
// begin i := rand ( 1 , 7 ) ;
105995: LD_ADDR_VAR 0 1
105999: PUSH
106000: LD_INT 1
106002: PPUSH
106003: LD_INT 7
106005: PPUSH
106006: CALL_OW 12
106010: ST_TO_ADDR
// case i of 1 :
106011: LD_VAR 0 1
106015: PUSH
106016: LD_INT 1
106018: DOUBLE
106019: EQUAL
106020: IFTRUE 106024
106022: GO 106034
106024: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106025: LD_STRING earthquake(getX(game), 0, 32)
106027: PPUSH
106028: CALL_OW 559
106032: GO 106272
106034: LD_INT 2
106036: DOUBLE
106037: EQUAL
106038: IFTRUE 106042
106040: GO 106056
106042: POP
// begin ToLua ( displayStucuk(); ) ;
106043: LD_STRING displayStucuk();
106045: PPUSH
106046: CALL_OW 559
// ResetFog ;
106050: CALL_OW 335
// end ; 3 :
106054: GO 106272
106056: LD_INT 3
106058: DOUBLE
106059: EQUAL
106060: IFTRUE 106064
106062: GO 106168
106064: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106065: LD_ADDR_VAR 0 2
106069: PUSH
106070: LD_INT 22
106072: PUSH
106073: LD_OWVAR 2
106077: PUSH
106078: EMPTY
106079: LIST
106080: LIST
106081: PUSH
106082: LD_INT 25
106084: PUSH
106085: LD_INT 1
106087: PUSH
106088: EMPTY
106089: LIST
106090: LIST
106091: PUSH
106092: EMPTY
106093: LIST
106094: LIST
106095: PPUSH
106096: CALL_OW 69
106100: ST_TO_ADDR
// if not tmp then
106101: LD_VAR 0 2
106105: NOT
106106: IFFALSE 106110
// exit ;
106108: GO 106272
// un := tmp [ rand ( 1 , tmp ) ] ;
106110: LD_ADDR_VAR 0 3
106114: PUSH
106115: LD_VAR 0 2
106119: PUSH
106120: LD_INT 1
106122: PPUSH
106123: LD_VAR 0 2
106127: PPUSH
106128: CALL_OW 12
106132: ARRAY
106133: ST_TO_ADDR
// if Crawls ( un ) then
106134: LD_VAR 0 3
106138: PPUSH
106139: CALL_OW 318
106143: IFFALSE 106154
// ComWalk ( un ) ;
106145: LD_VAR 0 3
106149: PPUSH
106150: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106154: LD_VAR 0 3
106158: PPUSH
106159: LD_INT 8
106161: PPUSH
106162: CALL_OW 336
// end ; 4 :
106166: GO 106272
106168: LD_INT 4
106170: DOUBLE
106171: EQUAL
106172: IFTRUE 106176
106174: GO 106250
106176: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106177: LD_ADDR_VAR 0 2
106181: PUSH
106182: LD_INT 22
106184: PUSH
106185: LD_OWVAR 2
106189: PUSH
106190: EMPTY
106191: LIST
106192: LIST
106193: PUSH
106194: LD_INT 30
106196: PUSH
106197: LD_INT 29
106199: PUSH
106200: EMPTY
106201: LIST
106202: LIST
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: PPUSH
106208: CALL_OW 69
106212: ST_TO_ADDR
// if not tmp then
106213: LD_VAR 0 2
106217: NOT
106218: IFFALSE 106222
// exit ;
106220: GO 106272
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106222: LD_VAR 0 2
106226: PUSH
106227: LD_INT 1
106229: ARRAY
106230: PPUSH
106231: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106235: LD_VAR 0 2
106239: PUSH
106240: LD_INT 1
106242: ARRAY
106243: PPUSH
106244: CALL_OW 65
// end ; 5 .. 7 :
106248: GO 106272
106250: LD_INT 5
106252: DOUBLE
106253: GREATEREQUAL
106254: IFFALSE 106262
106256: LD_INT 7
106258: DOUBLE
106259: LESSEQUAL
106260: IFTRUE 106264
106262: GO 106271
106264: POP
// StreamSibBomb ; end ;
106265: CALL 102453 0 0
106269: GO 106272
106271: POP
// end ;
106272: PPOPN 3
106274: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106275: LD_EXP 77
106279: IFFALSE 106287
106281: PUSH
106282: LD_EXP 127
106286: AND
106287: IFFALSE 106443
106289: GO 106291
106291: DISABLE
106292: LD_INT 0
106294: PPUSH
106295: PPUSH
106296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106297: LD_ADDR_VAR 0 2
106301: PUSH
106302: LD_INT 81
106304: PUSH
106305: LD_OWVAR 2
106309: PUSH
106310: EMPTY
106311: LIST
106312: LIST
106313: PUSH
106314: LD_INT 2
106316: PUSH
106317: LD_INT 21
106319: PUSH
106320: LD_INT 1
106322: PUSH
106323: EMPTY
106324: LIST
106325: LIST
106326: PUSH
106327: LD_INT 21
106329: PUSH
106330: LD_INT 2
106332: PUSH
106333: EMPTY
106334: LIST
106335: LIST
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: LIST
106341: PUSH
106342: EMPTY
106343: LIST
106344: LIST
106345: PPUSH
106346: CALL_OW 69
106350: ST_TO_ADDR
// if not tmp then
106351: LD_VAR 0 2
106355: NOT
106356: IFFALSE 106360
// exit ;
106358: GO 106443
// p := 0 ;
106360: LD_ADDR_VAR 0 3
106364: PUSH
106365: LD_INT 0
106367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106368: LD_INT 35
106370: PPUSH
106371: CALL_OW 67
// p := p + 1 ;
106375: LD_ADDR_VAR 0 3
106379: PUSH
106380: LD_VAR 0 3
106384: PUSH
106385: LD_INT 1
106387: PLUS
106388: ST_TO_ADDR
// for i in tmp do
106389: LD_ADDR_VAR 0 1
106393: PUSH
106394: LD_VAR 0 2
106398: PUSH
106399: FOR_IN
106400: IFFALSE 106431
// if GetLives ( i ) < 1000 then
106402: LD_VAR 0 1
106406: PPUSH
106407: CALL_OW 256
106411: PUSH
106412: LD_INT 1000
106414: LESS
106415: IFFALSE 106429
// SetLives ( i , 1000 ) ;
106417: LD_VAR 0 1
106421: PPUSH
106422: LD_INT 1000
106424: PPUSH
106425: CALL_OW 234
106429: GO 106399
106431: POP
106432: POP
// until p > 20 ;
106433: LD_VAR 0 3
106437: PUSH
106438: LD_INT 20
106440: GREATER
106441: IFFALSE 106368
// end ;
106443: PPOPN 3
106445: END
// every 0 0$1 trigger StreamModeActive and sTime do
106446: LD_EXP 77
106450: IFFALSE 106458
106452: PUSH
106453: LD_EXP 128
106457: AND
106458: IFFALSE 106493
106460: GO 106462
106462: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106463: LD_INT 28
106465: PPUSH
106466: LD_OWVAR 2
106470: PPUSH
106471: LD_INT 2
106473: PPUSH
106474: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106478: LD_INT 30
106480: PPUSH
106481: LD_OWVAR 2
106485: PPUSH
106486: LD_INT 2
106488: PPUSH
106489: CALL_OW 322
// end ;
106493: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106494: LD_EXP 77
106498: IFFALSE 106506
106500: PUSH
106501: LD_EXP 129
106505: AND
106506: IFFALSE 106627
106508: GO 106510
106510: DISABLE
106511: LD_INT 0
106513: PPUSH
106514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106515: LD_ADDR_VAR 0 2
106519: PUSH
106520: LD_INT 22
106522: PUSH
106523: LD_OWVAR 2
106527: PUSH
106528: EMPTY
106529: LIST
106530: LIST
106531: PUSH
106532: LD_INT 21
106534: PUSH
106535: LD_INT 1
106537: PUSH
106538: EMPTY
106539: LIST
106540: LIST
106541: PUSH
106542: LD_INT 3
106544: PUSH
106545: LD_INT 23
106547: PUSH
106548: LD_INT 0
106550: PUSH
106551: EMPTY
106552: LIST
106553: LIST
106554: PUSH
106555: EMPTY
106556: LIST
106557: LIST
106558: PUSH
106559: EMPTY
106560: LIST
106561: LIST
106562: LIST
106563: PPUSH
106564: CALL_OW 69
106568: ST_TO_ADDR
// if not tmp then
106569: LD_VAR 0 2
106573: NOT
106574: IFFALSE 106578
// exit ;
106576: GO 106627
// for i in tmp do
106578: LD_ADDR_VAR 0 1
106582: PUSH
106583: LD_VAR 0 2
106587: PUSH
106588: FOR_IN
106589: IFFALSE 106625
// begin if Crawls ( i ) then
106591: LD_VAR 0 1
106595: PPUSH
106596: CALL_OW 318
106600: IFFALSE 106611
// ComWalk ( i ) ;
106602: LD_VAR 0 1
106606: PPUSH
106607: CALL_OW 138
// SetClass ( i , 2 ) ;
106611: LD_VAR 0 1
106615: PPUSH
106616: LD_INT 2
106618: PPUSH
106619: CALL_OW 336
// end ;
106623: GO 106588
106625: POP
106626: POP
// end ;
106627: PPOPN 2
106629: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106630: LD_EXP 77
106634: IFFALSE 106642
106636: PUSH
106637: LD_EXP 130
106641: AND
106642: IFFALSE 106932
106644: GO 106646
106646: DISABLE
106647: LD_INT 0
106649: PPUSH
106650: PPUSH
106651: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106652: LD_OWVAR 2
106656: PPUSH
106657: LD_INT 9
106659: PPUSH
106660: LD_INT 1
106662: PPUSH
106663: LD_INT 1
106665: PPUSH
106666: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106670: LD_INT 9
106672: PPUSH
106673: LD_OWVAR 2
106677: PPUSH
106678: CALL_OW 343
// uc_side := 9 ;
106682: LD_ADDR_OWVAR 20
106686: PUSH
106687: LD_INT 9
106689: ST_TO_ADDR
// uc_nation := 2 ;
106690: LD_ADDR_OWVAR 21
106694: PUSH
106695: LD_INT 2
106697: ST_TO_ADDR
// hc_name := Dark Warrior ;
106698: LD_ADDR_OWVAR 26
106702: PUSH
106703: LD_STRING Dark Warrior
106705: ST_TO_ADDR
// hc_gallery :=  ;
106706: LD_ADDR_OWVAR 33
106710: PUSH
106711: LD_STRING 
106713: ST_TO_ADDR
// hc_noskilllimit := true ;
106714: LD_ADDR_OWVAR 76
106718: PUSH
106719: LD_INT 1
106721: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106722: LD_ADDR_OWVAR 31
106726: PUSH
106727: LD_INT 30
106729: PUSH
106730: LD_INT 30
106732: PUSH
106733: LD_INT 30
106735: PUSH
106736: LD_INT 30
106738: PUSH
106739: EMPTY
106740: LIST
106741: LIST
106742: LIST
106743: LIST
106744: ST_TO_ADDR
// un := CreateHuman ;
106745: LD_ADDR_VAR 0 3
106749: PUSH
106750: CALL_OW 44
106754: ST_TO_ADDR
// hc_noskilllimit := false ;
106755: LD_ADDR_OWVAR 76
106759: PUSH
106760: LD_INT 0
106762: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106763: LD_VAR 0 3
106767: PPUSH
106768: LD_INT 1
106770: PPUSH
106771: CALL_OW 51
// ToLua ( playRanger() ) ;
106775: LD_STRING playRanger()
106777: PPUSH
106778: CALL_OW 559
// p := 0 ;
106782: LD_ADDR_VAR 0 2
106786: PUSH
106787: LD_INT 0
106789: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106790: LD_INT 35
106792: PPUSH
106793: CALL_OW 67
// p := p + 1 ;
106797: LD_ADDR_VAR 0 2
106801: PUSH
106802: LD_VAR 0 2
106806: PUSH
106807: LD_INT 1
106809: PLUS
106810: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106811: LD_VAR 0 3
106815: PPUSH
106816: CALL_OW 256
106820: PUSH
106821: LD_INT 1000
106823: LESS
106824: IFFALSE 106838
// SetLives ( un , 1000 ) ;
106826: LD_VAR 0 3
106830: PPUSH
106831: LD_INT 1000
106833: PPUSH
106834: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106838: LD_VAR 0 3
106842: PPUSH
106843: LD_INT 81
106845: PUSH
106846: LD_OWVAR 2
106850: PUSH
106851: EMPTY
106852: LIST
106853: LIST
106854: PUSH
106855: LD_INT 91
106857: PUSH
106858: LD_VAR 0 3
106862: PUSH
106863: LD_INT 30
106865: PUSH
106866: EMPTY
106867: LIST
106868: LIST
106869: LIST
106870: PUSH
106871: EMPTY
106872: LIST
106873: LIST
106874: PPUSH
106875: CALL_OW 69
106879: PPUSH
106880: LD_VAR 0 3
106884: PPUSH
106885: CALL_OW 74
106889: PPUSH
106890: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106894: LD_VAR 0 2
106898: PUSH
106899: LD_INT 80
106901: GREATER
106902: IFTRUE 106915
106904: PUSH
106905: LD_VAR 0 3
106909: PPUSH
106910: CALL_OW 301
106914: OR
106915: IFFALSE 106790
// if un then
106917: LD_VAR 0 3
106921: IFFALSE 106932
// RemoveUnit ( un ) ;
106923: LD_VAR 0 3
106927: PPUSH
106928: CALL_OW 64
// end ;
106932: PPOPN 3
106934: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106935: LD_EXP 131
106939: IFFALSE 107055
106941: GO 106943
106943: DISABLE
106944: LD_INT 0
106946: PPUSH
106947: PPUSH
106948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106949: LD_ADDR_VAR 0 2
106953: PUSH
106954: LD_INT 81
106956: PUSH
106957: LD_OWVAR 2
106961: PUSH
106962: EMPTY
106963: LIST
106964: LIST
106965: PUSH
106966: LD_INT 21
106968: PUSH
106969: LD_INT 1
106971: PUSH
106972: EMPTY
106973: LIST
106974: LIST
106975: PUSH
106976: EMPTY
106977: LIST
106978: LIST
106979: PPUSH
106980: CALL_OW 69
106984: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106985: LD_STRING playComputer()
106987: PPUSH
106988: CALL_OW 559
// if not tmp then
106992: LD_VAR 0 2
106996: NOT
106997: IFFALSE 107001
// exit ;
106999: GO 107055
// for i in tmp do
107001: LD_ADDR_VAR 0 1
107005: PUSH
107006: LD_VAR 0 2
107010: PUSH
107011: FOR_IN
107012: IFFALSE 107053
// for j := 1 to 4 do
107014: LD_ADDR_VAR 0 3
107018: PUSH
107019: DOUBLE
107020: LD_INT 1
107022: DEC
107023: ST_TO_ADDR
107024: LD_INT 4
107026: PUSH
107027: FOR_TO
107028: IFFALSE 107049
// SetSkill ( i , j , 10 ) ;
107030: LD_VAR 0 1
107034: PPUSH
107035: LD_VAR 0 3
107039: PPUSH
107040: LD_INT 10
107042: PPUSH
107043: CALL_OW 237
107047: GO 107027
107049: POP
107050: POP
107051: GO 107011
107053: POP
107054: POP
// end ;
107055: PPOPN 3
107057: END
// every 0 0$1 trigger s30 do var i , tmp ;
107058: LD_EXP 132
107062: IFFALSE 107131
107064: GO 107066
107066: DISABLE
107067: LD_INT 0
107069: PPUSH
107070: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107071: LD_ADDR_VAR 0 2
107075: PUSH
107076: LD_INT 22
107078: PUSH
107079: LD_OWVAR 2
107083: PUSH
107084: EMPTY
107085: LIST
107086: LIST
107087: PPUSH
107088: CALL_OW 69
107092: ST_TO_ADDR
// if not tmp then
107093: LD_VAR 0 2
107097: NOT
107098: IFFALSE 107102
// exit ;
107100: GO 107131
// for i in tmp do
107102: LD_ADDR_VAR 0 1
107106: PUSH
107107: LD_VAR 0 2
107111: PUSH
107112: FOR_IN
107113: IFFALSE 107129
// SetLives ( i , 300 ) ;
107115: LD_VAR 0 1
107119: PPUSH
107120: LD_INT 300
107122: PPUSH
107123: CALL_OW 234
107127: GO 107112
107129: POP
107130: POP
// end ;
107131: PPOPN 2
107133: END
// every 0 0$1 trigger s60 do var i , tmp ;
107134: LD_EXP 133
107138: IFFALSE 107207
107140: GO 107142
107142: DISABLE
107143: LD_INT 0
107145: PPUSH
107146: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107147: LD_ADDR_VAR 0 2
107151: PUSH
107152: LD_INT 22
107154: PUSH
107155: LD_OWVAR 2
107159: PUSH
107160: EMPTY
107161: LIST
107162: LIST
107163: PPUSH
107164: CALL_OW 69
107168: ST_TO_ADDR
// if not tmp then
107169: LD_VAR 0 2
107173: NOT
107174: IFFALSE 107178
// exit ;
107176: GO 107207
// for i in tmp do
107178: LD_ADDR_VAR 0 1
107182: PUSH
107183: LD_VAR 0 2
107187: PUSH
107188: FOR_IN
107189: IFFALSE 107205
// SetLives ( i , 600 ) ;
107191: LD_VAR 0 1
107195: PPUSH
107196: LD_INT 600
107198: PPUSH
107199: CALL_OW 234
107203: GO 107188
107205: POP
107206: POP
// end ;
107207: PPOPN 2
107209: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107210: LD_INT 0
107212: PPUSH
// case cmd of 301 :
107213: LD_VAR 0 1
107217: PUSH
107218: LD_INT 301
107220: DOUBLE
107221: EQUAL
107222: IFTRUE 107226
107224: GO 107258
107226: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107227: LD_VAR 0 6
107231: PPUSH
107232: LD_VAR 0 7
107236: PPUSH
107237: LD_VAR 0 8
107241: PPUSH
107242: LD_VAR 0 4
107246: PPUSH
107247: LD_VAR 0 5
107251: PPUSH
107252: CALL 108471 0 5
107256: GO 107379
107258: LD_INT 302
107260: DOUBLE
107261: EQUAL
107262: IFTRUE 107266
107264: GO 107303
107266: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107267: LD_VAR 0 6
107271: PPUSH
107272: LD_VAR 0 7
107276: PPUSH
107277: LD_VAR 0 8
107281: PPUSH
107282: LD_VAR 0 9
107286: PPUSH
107287: LD_VAR 0 4
107291: PPUSH
107292: LD_VAR 0 5
107296: PPUSH
107297: CALL 108562 0 6
107301: GO 107379
107303: LD_INT 303
107305: DOUBLE
107306: EQUAL
107307: IFTRUE 107311
107309: GO 107348
107311: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107312: LD_VAR 0 6
107316: PPUSH
107317: LD_VAR 0 7
107321: PPUSH
107322: LD_VAR 0 8
107326: PPUSH
107327: LD_VAR 0 9
107331: PPUSH
107332: LD_VAR 0 4
107336: PPUSH
107337: LD_VAR 0 5
107341: PPUSH
107342: CALL 107384 0 6
107346: GO 107379
107348: LD_INT 304
107350: DOUBLE
107351: EQUAL
107352: IFTRUE 107356
107354: GO 107378
107356: POP
// hHackTeleport ( unit , x , y ) ; end ;
107357: LD_VAR 0 2
107361: PPUSH
107362: LD_VAR 0 4
107366: PPUSH
107367: LD_VAR 0 5
107371: PPUSH
107372: CALL 109155 0 3
107376: GO 107379
107378: POP
// end ;
107379: LD_VAR 0 12
107383: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107384: LD_INT 0
107386: PPUSH
107387: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107388: LD_VAR 0 1
107392: PUSH
107393: LD_INT 1
107395: LESS
107396: IFTRUE 107408
107398: PUSH
107399: LD_VAR 0 1
107403: PUSH
107404: LD_INT 3
107406: GREATER
107407: OR
107408: IFTRUE 107426
107410: PUSH
107411: LD_VAR 0 5
107415: PPUSH
107416: LD_VAR 0 6
107420: PPUSH
107421: CALL_OW 428
107425: OR
107426: IFFALSE 107430
// exit ;
107428: GO 108158
// uc_side := your_side ;
107430: LD_ADDR_OWVAR 20
107434: PUSH
107435: LD_OWVAR 2
107439: ST_TO_ADDR
// uc_nation := nation ;
107440: LD_ADDR_OWVAR 21
107444: PUSH
107445: LD_VAR 0 1
107449: ST_TO_ADDR
// bc_level = 1 ;
107450: LD_ADDR_OWVAR 43
107454: PUSH
107455: LD_INT 1
107457: ST_TO_ADDR
// case btype of 1 :
107458: LD_VAR 0 2
107462: PUSH
107463: LD_INT 1
107465: DOUBLE
107466: EQUAL
107467: IFTRUE 107471
107469: GO 107482
107471: POP
// bc_type := b_depot ; 2 :
107472: LD_ADDR_OWVAR 42
107476: PUSH
107477: LD_INT 0
107479: ST_TO_ADDR
107480: GO 108102
107482: LD_INT 2
107484: DOUBLE
107485: EQUAL
107486: IFTRUE 107490
107488: GO 107501
107490: POP
// bc_type := b_warehouse ; 3 :
107491: LD_ADDR_OWVAR 42
107495: PUSH
107496: LD_INT 1
107498: ST_TO_ADDR
107499: GO 108102
107501: LD_INT 3
107503: DOUBLE
107504: EQUAL
107505: IFTRUE 107509
107507: GO 107520
107509: POP
// bc_type := b_lab ; 4 .. 9 :
107510: LD_ADDR_OWVAR 42
107514: PUSH
107515: LD_INT 6
107517: ST_TO_ADDR
107518: GO 108102
107520: LD_INT 4
107522: DOUBLE
107523: GREATEREQUAL
107524: IFFALSE 107532
107526: LD_INT 9
107528: DOUBLE
107529: LESSEQUAL
107530: IFTRUE 107534
107532: GO 107594
107534: POP
// begin bc_type := b_lab_half ;
107535: LD_ADDR_OWVAR 42
107539: PUSH
107540: LD_INT 7
107542: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107543: LD_ADDR_OWVAR 44
107547: PUSH
107548: LD_INT 10
107550: PUSH
107551: LD_INT 11
107553: PUSH
107554: LD_INT 12
107556: PUSH
107557: LD_INT 15
107559: PUSH
107560: LD_INT 14
107562: PUSH
107563: LD_INT 13
107565: PUSH
107566: EMPTY
107567: LIST
107568: LIST
107569: LIST
107570: LIST
107571: LIST
107572: LIST
107573: PUSH
107574: LD_VAR 0 2
107578: PUSH
107579: LD_INT 3
107581: MINUS
107582: ARRAY
107583: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107584: LD_ADDR_OWVAR 45
107588: PUSH
107589: LD_INT 9
107591: ST_TO_ADDR
// end ; 10 .. 13 :
107592: GO 108102
107594: LD_INT 10
107596: DOUBLE
107597: GREATEREQUAL
107598: IFFALSE 107606
107600: LD_INT 13
107602: DOUBLE
107603: LESSEQUAL
107604: IFTRUE 107608
107606: GO 107685
107608: POP
// begin bc_type := b_lab_full ;
107609: LD_ADDR_OWVAR 42
107613: PUSH
107614: LD_INT 8
107616: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107617: LD_ADDR_OWVAR 44
107621: PUSH
107622: LD_INT 10
107624: PUSH
107625: LD_INT 12
107627: PUSH
107628: LD_INT 14
107630: PUSH
107631: LD_INT 13
107633: PUSH
107634: EMPTY
107635: LIST
107636: LIST
107637: LIST
107638: LIST
107639: PUSH
107640: LD_VAR 0 2
107644: PUSH
107645: LD_INT 9
107647: MINUS
107648: ARRAY
107649: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107650: LD_ADDR_OWVAR 45
107654: PUSH
107655: LD_INT 11
107657: PUSH
107658: LD_INT 15
107660: PUSH
107661: LD_INT 12
107663: PUSH
107664: LD_INT 15
107666: PUSH
107667: EMPTY
107668: LIST
107669: LIST
107670: LIST
107671: LIST
107672: PUSH
107673: LD_VAR 0 2
107677: PUSH
107678: LD_INT 9
107680: MINUS
107681: ARRAY
107682: ST_TO_ADDR
// end ; 14 :
107683: GO 108102
107685: LD_INT 14
107687: DOUBLE
107688: EQUAL
107689: IFTRUE 107693
107691: GO 107704
107693: POP
// bc_type := b_workshop ; 15 :
107694: LD_ADDR_OWVAR 42
107698: PUSH
107699: LD_INT 2
107701: ST_TO_ADDR
107702: GO 108102
107704: LD_INT 15
107706: DOUBLE
107707: EQUAL
107708: IFTRUE 107712
107710: GO 107723
107712: POP
// bc_type := b_factory ; 16 :
107713: LD_ADDR_OWVAR 42
107717: PUSH
107718: LD_INT 3
107720: ST_TO_ADDR
107721: GO 108102
107723: LD_INT 16
107725: DOUBLE
107726: EQUAL
107727: IFTRUE 107731
107729: GO 107742
107731: POP
// bc_type := b_ext_gun ; 17 :
107732: LD_ADDR_OWVAR 42
107736: PUSH
107737: LD_INT 17
107739: ST_TO_ADDR
107740: GO 108102
107742: LD_INT 17
107744: DOUBLE
107745: EQUAL
107746: IFTRUE 107750
107748: GO 107778
107750: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107751: LD_ADDR_OWVAR 42
107755: PUSH
107756: LD_INT 19
107758: PUSH
107759: LD_INT 23
107761: PUSH
107762: LD_INT 19
107764: PUSH
107765: EMPTY
107766: LIST
107767: LIST
107768: LIST
107769: PUSH
107770: LD_VAR 0 1
107774: ARRAY
107775: ST_TO_ADDR
107776: GO 108102
107778: LD_INT 18
107780: DOUBLE
107781: EQUAL
107782: IFTRUE 107786
107784: GO 107797
107786: POP
// bc_type := b_ext_radar ; 19 :
107787: LD_ADDR_OWVAR 42
107791: PUSH
107792: LD_INT 20
107794: ST_TO_ADDR
107795: GO 108102
107797: LD_INT 19
107799: DOUBLE
107800: EQUAL
107801: IFTRUE 107805
107803: GO 107816
107805: POP
// bc_type := b_ext_radio ; 20 :
107806: LD_ADDR_OWVAR 42
107810: PUSH
107811: LD_INT 22
107813: ST_TO_ADDR
107814: GO 108102
107816: LD_INT 20
107818: DOUBLE
107819: EQUAL
107820: IFTRUE 107824
107822: GO 107835
107824: POP
// bc_type := b_ext_siberium ; 21 :
107825: LD_ADDR_OWVAR 42
107829: PUSH
107830: LD_INT 21
107832: ST_TO_ADDR
107833: GO 108102
107835: LD_INT 21
107837: DOUBLE
107838: EQUAL
107839: IFTRUE 107843
107841: GO 107854
107843: POP
// bc_type := b_ext_computer ; 22 :
107844: LD_ADDR_OWVAR 42
107848: PUSH
107849: LD_INT 24
107851: ST_TO_ADDR
107852: GO 108102
107854: LD_INT 22
107856: DOUBLE
107857: EQUAL
107858: IFTRUE 107862
107860: GO 107873
107862: POP
// bc_type := b_ext_track ; 23 :
107863: LD_ADDR_OWVAR 42
107867: PUSH
107868: LD_INT 16
107870: ST_TO_ADDR
107871: GO 108102
107873: LD_INT 23
107875: DOUBLE
107876: EQUAL
107877: IFTRUE 107881
107879: GO 107892
107881: POP
// bc_type := b_ext_laser ; 24 :
107882: LD_ADDR_OWVAR 42
107886: PUSH
107887: LD_INT 25
107889: ST_TO_ADDR
107890: GO 108102
107892: LD_INT 24
107894: DOUBLE
107895: EQUAL
107896: IFTRUE 107900
107898: GO 107911
107900: POP
// bc_type := b_control_tower ; 25 :
107901: LD_ADDR_OWVAR 42
107905: PUSH
107906: LD_INT 36
107908: ST_TO_ADDR
107909: GO 108102
107911: LD_INT 25
107913: DOUBLE
107914: EQUAL
107915: IFTRUE 107919
107917: GO 107930
107919: POP
// bc_type := b_breastwork ; 26 :
107920: LD_ADDR_OWVAR 42
107924: PUSH
107925: LD_INT 31
107927: ST_TO_ADDR
107928: GO 108102
107930: LD_INT 26
107932: DOUBLE
107933: EQUAL
107934: IFTRUE 107938
107936: GO 107949
107938: POP
// bc_type := b_bunker ; 27 :
107939: LD_ADDR_OWVAR 42
107943: PUSH
107944: LD_INT 32
107946: ST_TO_ADDR
107947: GO 108102
107949: LD_INT 27
107951: DOUBLE
107952: EQUAL
107953: IFTRUE 107957
107955: GO 107968
107957: POP
// bc_type := b_turret ; 28 :
107958: LD_ADDR_OWVAR 42
107962: PUSH
107963: LD_INT 33
107965: ST_TO_ADDR
107966: GO 108102
107968: LD_INT 28
107970: DOUBLE
107971: EQUAL
107972: IFTRUE 107976
107974: GO 107987
107976: POP
// bc_type := b_armoury ; 29 :
107977: LD_ADDR_OWVAR 42
107981: PUSH
107982: LD_INT 4
107984: ST_TO_ADDR
107985: GO 108102
107987: LD_INT 29
107989: DOUBLE
107990: EQUAL
107991: IFTRUE 107995
107993: GO 108006
107995: POP
// bc_type := b_barracks ; 30 :
107996: LD_ADDR_OWVAR 42
108000: PUSH
108001: LD_INT 5
108003: ST_TO_ADDR
108004: GO 108102
108006: LD_INT 30
108008: DOUBLE
108009: EQUAL
108010: IFTRUE 108014
108012: GO 108025
108014: POP
// bc_type := b_solar_power ; 31 :
108015: LD_ADDR_OWVAR 42
108019: PUSH
108020: LD_INT 27
108022: ST_TO_ADDR
108023: GO 108102
108025: LD_INT 31
108027: DOUBLE
108028: EQUAL
108029: IFTRUE 108033
108031: GO 108044
108033: POP
// bc_type := b_oil_power ; 32 :
108034: LD_ADDR_OWVAR 42
108038: PUSH
108039: LD_INT 26
108041: ST_TO_ADDR
108042: GO 108102
108044: LD_INT 32
108046: DOUBLE
108047: EQUAL
108048: IFTRUE 108052
108050: GO 108063
108052: POP
// bc_type := b_siberite_power ; 33 :
108053: LD_ADDR_OWVAR 42
108057: PUSH
108058: LD_INT 28
108060: ST_TO_ADDR
108061: GO 108102
108063: LD_INT 33
108065: DOUBLE
108066: EQUAL
108067: IFTRUE 108071
108069: GO 108082
108071: POP
// bc_type := b_oil_mine ; 34 :
108072: LD_ADDR_OWVAR 42
108076: PUSH
108077: LD_INT 29
108079: ST_TO_ADDR
108080: GO 108102
108082: LD_INT 34
108084: DOUBLE
108085: EQUAL
108086: IFTRUE 108090
108088: GO 108101
108090: POP
// bc_type := b_siberite_mine ; end ;
108091: LD_ADDR_OWVAR 42
108095: PUSH
108096: LD_INT 30
108098: ST_TO_ADDR
108099: GO 108102
108101: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108102: LD_ADDR_VAR 0 8
108106: PUSH
108107: LD_VAR 0 5
108111: PPUSH
108112: LD_VAR 0 6
108116: PPUSH
108117: LD_VAR 0 3
108121: PPUSH
108122: CALL_OW 47
108126: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108127: LD_OWVAR 42
108131: PUSH
108132: LD_INT 32
108134: PUSH
108135: LD_INT 33
108137: PUSH
108138: EMPTY
108139: LIST
108140: LIST
108141: IN
108142: IFFALSE 108158
// PlaceWeaponTurret ( b , weapon ) ;
108144: LD_VAR 0 8
108148: PPUSH
108149: LD_VAR 0 4
108153: PPUSH
108154: CALL_OW 431
// end ;
108158: LD_VAR 0 7
108162: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108163: LD_INT 0
108165: PPUSH
108166: PPUSH
108167: PPUSH
108168: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108169: LD_ADDR_VAR 0 4
108173: PUSH
108174: LD_INT 22
108176: PUSH
108177: LD_OWVAR 2
108181: PUSH
108182: EMPTY
108183: LIST
108184: LIST
108185: PUSH
108186: LD_INT 2
108188: PUSH
108189: LD_INT 30
108191: PUSH
108192: LD_INT 0
108194: PUSH
108195: EMPTY
108196: LIST
108197: LIST
108198: PUSH
108199: LD_INT 30
108201: PUSH
108202: LD_INT 1
108204: PUSH
108205: EMPTY
108206: LIST
108207: LIST
108208: PUSH
108209: EMPTY
108210: LIST
108211: LIST
108212: LIST
108213: PUSH
108214: EMPTY
108215: LIST
108216: LIST
108217: PPUSH
108218: CALL_OW 69
108222: ST_TO_ADDR
// if not tmp then
108223: LD_VAR 0 4
108227: NOT
108228: IFFALSE 108232
// exit ;
108230: GO 108291
// for i in tmp do
108232: LD_ADDR_VAR 0 2
108236: PUSH
108237: LD_VAR 0 4
108241: PUSH
108242: FOR_IN
108243: IFFALSE 108289
// for j = 1 to 3 do
108245: LD_ADDR_VAR 0 3
108249: PUSH
108250: DOUBLE
108251: LD_INT 1
108253: DEC
108254: ST_TO_ADDR
108255: LD_INT 3
108257: PUSH
108258: FOR_TO
108259: IFFALSE 108285
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108261: LD_VAR 0 2
108265: PPUSH
108266: CALL_OW 274
108270: PPUSH
108271: LD_VAR 0 3
108275: PPUSH
108276: LD_INT 99999
108278: PPUSH
108279: CALL_OW 277
108283: GO 108258
108285: POP
108286: POP
108287: GO 108242
108289: POP
108290: POP
// end ;
108291: LD_VAR 0 1
108295: RET
// export function hHackSetLevel10 ; var i , j ; begin
108296: LD_INT 0
108298: PPUSH
108299: PPUSH
108300: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108301: LD_ADDR_VAR 0 2
108305: PUSH
108306: LD_INT 21
108308: PUSH
108309: LD_INT 1
108311: PUSH
108312: EMPTY
108313: LIST
108314: LIST
108315: PPUSH
108316: CALL_OW 69
108320: PUSH
108321: FOR_IN
108322: IFFALSE 108374
// if IsSelected ( i ) then
108324: LD_VAR 0 2
108328: PPUSH
108329: CALL_OW 306
108333: IFFALSE 108372
// begin for j := 1 to 4 do
108335: LD_ADDR_VAR 0 3
108339: PUSH
108340: DOUBLE
108341: LD_INT 1
108343: DEC
108344: ST_TO_ADDR
108345: LD_INT 4
108347: PUSH
108348: FOR_TO
108349: IFFALSE 108370
// SetSkill ( i , j , 10 ) ;
108351: LD_VAR 0 2
108355: PPUSH
108356: LD_VAR 0 3
108360: PPUSH
108361: LD_INT 10
108363: PPUSH
108364: CALL_OW 237
108368: GO 108348
108370: POP
108371: POP
// end ;
108372: GO 108321
108374: POP
108375: POP
// end ;
108376: LD_VAR 0 1
108380: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108381: LD_INT 0
108383: PPUSH
108384: PPUSH
108385: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108386: LD_ADDR_VAR 0 2
108390: PUSH
108391: LD_INT 22
108393: PUSH
108394: LD_OWVAR 2
108398: PUSH
108399: EMPTY
108400: LIST
108401: LIST
108402: PUSH
108403: LD_INT 21
108405: PUSH
108406: LD_INT 1
108408: PUSH
108409: EMPTY
108410: LIST
108411: LIST
108412: PUSH
108413: EMPTY
108414: LIST
108415: LIST
108416: PPUSH
108417: CALL_OW 69
108421: PUSH
108422: FOR_IN
108423: IFFALSE 108464
// begin for j := 1 to 4 do
108425: LD_ADDR_VAR 0 3
108429: PUSH
108430: DOUBLE
108431: LD_INT 1
108433: DEC
108434: ST_TO_ADDR
108435: LD_INT 4
108437: PUSH
108438: FOR_TO
108439: IFFALSE 108460
// SetSkill ( i , j , 10 ) ;
108441: LD_VAR 0 2
108445: PPUSH
108446: LD_VAR 0 3
108450: PPUSH
108451: LD_INT 10
108453: PPUSH
108454: CALL_OW 237
108458: GO 108438
108460: POP
108461: POP
// end ;
108462: GO 108422
108464: POP
108465: POP
// end ;
108466: LD_VAR 0 1
108470: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108471: LD_INT 0
108473: PPUSH
// uc_side := your_side ;
108474: LD_ADDR_OWVAR 20
108478: PUSH
108479: LD_OWVAR 2
108483: ST_TO_ADDR
// uc_nation := nation ;
108484: LD_ADDR_OWVAR 21
108488: PUSH
108489: LD_VAR 0 1
108493: ST_TO_ADDR
// InitHc ;
108494: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108498: LD_INT 0
108500: PPUSH
108501: LD_VAR 0 2
108505: PPUSH
108506: LD_VAR 0 3
108510: PPUSH
108511: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108515: LD_VAR 0 4
108519: PPUSH
108520: LD_VAR 0 5
108524: PPUSH
108525: CALL_OW 428
108529: PUSH
108530: LD_INT 0
108532: EQUAL
108533: IFFALSE 108557
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108535: CALL_OW 44
108539: PPUSH
108540: LD_VAR 0 4
108544: PPUSH
108545: LD_VAR 0 5
108549: PPUSH
108550: LD_INT 1
108552: PPUSH
108553: CALL_OW 48
// end ;
108557: LD_VAR 0 6
108561: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108562: LD_INT 0
108564: PPUSH
108565: PPUSH
// uc_side := your_side ;
108566: LD_ADDR_OWVAR 20
108570: PUSH
108571: LD_OWVAR 2
108575: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108576: LD_VAR 0 1
108580: PUSH
108581: LD_INT 1
108583: PUSH
108584: LD_INT 2
108586: PUSH
108587: LD_INT 3
108589: PUSH
108590: LD_INT 4
108592: PUSH
108593: LD_INT 5
108595: PUSH
108596: EMPTY
108597: LIST
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: IN
108603: IFFALSE 108615
// uc_nation := nation_american else
108605: LD_ADDR_OWVAR 21
108609: PUSH
108610: LD_INT 1
108612: ST_TO_ADDR
108613: GO 108658
// if chassis in [ 11 , 12 , 13 , 14 ] then
108615: LD_VAR 0 1
108619: PUSH
108620: LD_INT 11
108622: PUSH
108623: LD_INT 12
108625: PUSH
108626: LD_INT 13
108628: PUSH
108629: LD_INT 14
108631: PUSH
108632: EMPTY
108633: LIST
108634: LIST
108635: LIST
108636: LIST
108637: IN
108638: IFFALSE 108650
// uc_nation := nation_arabian else
108640: LD_ADDR_OWVAR 21
108644: PUSH
108645: LD_INT 2
108647: ST_TO_ADDR
108648: GO 108658
// uc_nation := nation_russian ;
108650: LD_ADDR_OWVAR 21
108654: PUSH
108655: LD_INT 3
108657: ST_TO_ADDR
// vc_chassis := chassis ;
108658: LD_ADDR_OWVAR 37
108662: PUSH
108663: LD_VAR 0 1
108667: ST_TO_ADDR
// vc_engine := engine ;
108668: LD_ADDR_OWVAR 39
108672: PUSH
108673: LD_VAR 0 2
108677: ST_TO_ADDR
// vc_control := control ;
108678: LD_ADDR_OWVAR 38
108682: PUSH
108683: LD_VAR 0 3
108687: ST_TO_ADDR
// vc_weapon := weapon ;
108688: LD_ADDR_OWVAR 40
108692: PUSH
108693: LD_VAR 0 4
108697: ST_TO_ADDR
// un := CreateVehicle ;
108698: LD_ADDR_VAR 0 8
108702: PUSH
108703: CALL_OW 45
108707: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108708: LD_VAR 0 8
108712: PPUSH
108713: LD_INT 0
108715: PPUSH
108716: LD_INT 5
108718: PPUSH
108719: CALL_OW 12
108723: PPUSH
108724: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108728: LD_VAR 0 8
108732: PPUSH
108733: LD_VAR 0 5
108737: PPUSH
108738: LD_VAR 0 6
108742: PPUSH
108743: LD_INT 1
108745: PPUSH
108746: CALL_OW 48
// end ;
108750: LD_VAR 0 7
108754: RET
// export hInvincible ; every 1 do
108755: GO 108757
108757: DISABLE
// hInvincible := [ ] ;
108758: LD_ADDR_EXP 134
108762: PUSH
108763: EMPTY
108764: ST_TO_ADDR
108765: END
// every 10 do var i ;
108766: GO 108768
108768: DISABLE
108769: LD_INT 0
108771: PPUSH
// begin enable ;
108772: ENABLE
// if not hInvincible then
108773: LD_EXP 134
108777: NOT
108778: IFFALSE 108782
// exit ;
108780: GO 108826
// for i in hInvincible do
108782: LD_ADDR_VAR 0 1
108786: PUSH
108787: LD_EXP 134
108791: PUSH
108792: FOR_IN
108793: IFFALSE 108824
// if GetLives ( i ) < 1000 then
108795: LD_VAR 0 1
108799: PPUSH
108800: CALL_OW 256
108804: PUSH
108805: LD_INT 1000
108807: LESS
108808: IFFALSE 108822
// SetLives ( i , 1000 ) ;
108810: LD_VAR 0 1
108814: PPUSH
108815: LD_INT 1000
108817: PPUSH
108818: CALL_OW 234
108822: GO 108792
108824: POP
108825: POP
// end ;
108826: PPOPN 1
108828: END
// export function hHackInvincible ; var i ; begin
108829: LD_INT 0
108831: PPUSH
108832: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108833: LD_ADDR_VAR 0 2
108837: PUSH
108838: LD_INT 2
108840: PUSH
108841: LD_INT 21
108843: PUSH
108844: LD_INT 1
108846: PUSH
108847: EMPTY
108848: LIST
108849: LIST
108850: PUSH
108851: LD_INT 21
108853: PUSH
108854: LD_INT 2
108856: PUSH
108857: EMPTY
108858: LIST
108859: LIST
108860: PUSH
108861: EMPTY
108862: LIST
108863: LIST
108864: LIST
108865: PPUSH
108866: CALL_OW 69
108870: PUSH
108871: FOR_IN
108872: IFFALSE 108933
// if IsSelected ( i ) then
108874: LD_VAR 0 2
108878: PPUSH
108879: CALL_OW 306
108883: IFFALSE 108931
// begin if i in hInvincible then
108885: LD_VAR 0 2
108889: PUSH
108890: LD_EXP 134
108894: IN
108895: IFFALSE 108915
// hInvincible := hInvincible diff i else
108897: LD_ADDR_EXP 134
108901: PUSH
108902: LD_EXP 134
108906: PUSH
108907: LD_VAR 0 2
108911: DIFF
108912: ST_TO_ADDR
108913: GO 108931
// hInvincible := hInvincible union i ;
108915: LD_ADDR_EXP 134
108919: PUSH
108920: LD_EXP 134
108924: PUSH
108925: LD_VAR 0 2
108929: UNION
108930: ST_TO_ADDR
// end ;
108931: GO 108871
108933: POP
108934: POP
// end ;
108935: LD_VAR 0 1
108939: RET
// export function hHackInvisible ; var i , j ; begin
108940: LD_INT 0
108942: PPUSH
108943: PPUSH
108944: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108945: LD_ADDR_VAR 0 2
108949: PUSH
108950: LD_INT 21
108952: PUSH
108953: LD_INT 1
108955: PUSH
108956: EMPTY
108957: LIST
108958: LIST
108959: PPUSH
108960: CALL_OW 69
108964: PUSH
108965: FOR_IN
108966: IFFALSE 108990
// if IsSelected ( i ) then
108968: LD_VAR 0 2
108972: PPUSH
108973: CALL_OW 306
108977: IFFALSE 108988
// ComForceInvisible ( i ) ;
108979: LD_VAR 0 2
108983: PPUSH
108984: CALL_OW 496
108988: GO 108965
108990: POP
108991: POP
// end ;
108992: LD_VAR 0 1
108996: RET
// export function hHackChangeYourSide ; begin
108997: LD_INT 0
108999: PPUSH
// if your_side = 8 then
109000: LD_OWVAR 2
109004: PUSH
109005: LD_INT 8
109007: EQUAL
109008: IFFALSE 109020
// your_side := 0 else
109010: LD_ADDR_OWVAR 2
109014: PUSH
109015: LD_INT 0
109017: ST_TO_ADDR
109018: GO 109034
// your_side := your_side + 1 ;
109020: LD_ADDR_OWVAR 2
109024: PUSH
109025: LD_OWVAR 2
109029: PUSH
109030: LD_INT 1
109032: PLUS
109033: ST_TO_ADDR
// end ;
109034: LD_VAR 0 1
109038: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109039: LD_INT 0
109041: PPUSH
109042: PPUSH
109043: PPUSH
// for i in all_units do
109044: LD_ADDR_VAR 0 2
109048: PUSH
109049: LD_OWVAR 3
109053: PUSH
109054: FOR_IN
109055: IFFALSE 109133
// if IsSelected ( i ) then
109057: LD_VAR 0 2
109061: PPUSH
109062: CALL_OW 306
109066: IFFALSE 109131
// begin j := GetSide ( i ) ;
109068: LD_ADDR_VAR 0 3
109072: PUSH
109073: LD_VAR 0 2
109077: PPUSH
109078: CALL_OW 255
109082: ST_TO_ADDR
// if j = 8 then
109083: LD_VAR 0 3
109087: PUSH
109088: LD_INT 8
109090: EQUAL
109091: IFFALSE 109103
// j := 0 else
109093: LD_ADDR_VAR 0 3
109097: PUSH
109098: LD_INT 0
109100: ST_TO_ADDR
109101: GO 109117
// j := j + 1 ;
109103: LD_ADDR_VAR 0 3
109107: PUSH
109108: LD_VAR 0 3
109112: PUSH
109113: LD_INT 1
109115: PLUS
109116: ST_TO_ADDR
// SetSide ( i , j ) ;
109117: LD_VAR 0 2
109121: PPUSH
109122: LD_VAR 0 3
109126: PPUSH
109127: CALL_OW 235
// end ;
109131: GO 109054
109133: POP
109134: POP
// end ;
109135: LD_VAR 0 1
109139: RET
// export function hHackFog ; begin
109140: LD_INT 0
109142: PPUSH
// FogOff ( true ) ;
109143: LD_INT 1
109145: PPUSH
109146: CALL_OW 344
// end ;
109150: LD_VAR 0 1
109154: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109155: LD_INT 0
109157: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109158: LD_VAR 0 1
109162: PPUSH
109163: LD_VAR 0 2
109167: PPUSH
109168: LD_VAR 0 3
109172: PPUSH
109173: LD_INT 1
109175: PPUSH
109176: LD_INT 1
109178: PPUSH
109179: CALL_OW 483
// CenterOnXY ( x , y ) ;
109183: LD_VAR 0 2
109187: PPUSH
109188: LD_VAR 0 3
109192: PPUSH
109193: CALL_OW 84
// end ;
109197: LD_VAR 0 4
109201: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109202: LD_INT 0
109204: PPUSH
109205: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109206: LD_VAR 0 1
109210: NOT
109211: IFTRUE 109230
109213: PUSH
109214: LD_VAR 0 2
109218: PPUSH
109219: LD_VAR 0 3
109223: PPUSH
109224: CALL_OW 488
109228: NOT
109229: OR
109230: IFTRUE 109265
109232: PUSH
109233: LD_VAR 0 1
109237: PPUSH
109238: CALL_OW 266
109242: PUSH
109243: LD_INT 3
109245: NONEQUAL
109246: IFFALSE 109264
109248: PUSH
109249: LD_VAR 0 1
109253: PPUSH
109254: CALL_OW 247
109258: PUSH
109259: LD_INT 1
109261: EQUAL
109262: NOT
109263: AND
109264: OR
109265: IFFALSE 109269
// exit ;
109267: GO 109551
// if GetType ( factory ) = unit_human then
109269: LD_VAR 0 1
109273: PPUSH
109274: CALL_OW 247
109278: PUSH
109279: LD_INT 1
109281: EQUAL
109282: IFFALSE 109299
// factory := IsInUnit ( factory ) ;
109284: LD_ADDR_VAR 0 1
109288: PUSH
109289: LD_VAR 0 1
109293: PPUSH
109294: CALL_OW 310
109298: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109299: LD_VAR 0 1
109303: PPUSH
109304: CALL_OW 266
109308: PUSH
109309: LD_INT 3
109311: NONEQUAL
109312: IFFALSE 109316
// exit ;
109314: GO 109551
// for i := 1 to Count ( factoryWaypoints ) do
109316: LD_ADDR_VAR 0 5
109320: PUSH
109321: DOUBLE
109322: LD_INT 1
109324: DEC
109325: ST_TO_ADDR
109326: LD_EXP 135
109330: PPUSH
109331: CALL 22179 0 1
109335: PUSH
109336: FOR_TO
109337: IFFALSE 109499
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
109339: LD_VAR 0 2
109343: PPUSH
109344: LD_VAR 0 3
109348: PPUSH
109349: CALL_OW 428
109353: PUSH
109354: LD_EXP 135
109358: PUSH
109359: LD_VAR 0 5
109363: ARRAY
109364: PUSH
109365: LD_INT 2
109367: ARRAY
109368: EQUAL
109369: IFFALSE 109401
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
109371: LD_ADDR_EXP 135
109375: PUSH
109376: LD_EXP 135
109380: PPUSH
109381: LD_VAR 0 5
109385: PPUSH
109386: CALL_OW 3
109390: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109391: CALL 109556 0 0
// exit ;
109395: POP
109396: POP
109397: GO 109551
// end else
109399: GO 109497
// if factory = factoryWaypoints [ i ] [ 2 ] then
109401: LD_VAR 0 1
109405: PUSH
109406: LD_EXP 135
109410: PUSH
109411: LD_VAR 0 5
109415: ARRAY
109416: PUSH
109417: LD_INT 2
109419: ARRAY
109420: EQUAL
109421: IFFALSE 109497
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
109423: LD_ADDR_EXP 135
109427: PUSH
109428: LD_EXP 135
109432: PPUSH
109433: LD_VAR 0 5
109437: PPUSH
109438: CALL_OW 3
109442: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
109443: LD_ADDR_EXP 135
109447: PUSH
109448: LD_EXP 135
109452: PPUSH
109453: LD_VAR 0 1
109457: PPUSH
109458: CALL_OW 255
109462: PUSH
109463: LD_VAR 0 1
109467: PUSH
109468: LD_VAR 0 2
109472: PUSH
109473: LD_VAR 0 3
109477: PUSH
109478: EMPTY
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: PPUSH
109484: CALL 58155 0 2
109488: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109489: CALL 109556 0 0
// exit ;
109493: POP
109494: POP
109495: GO 109551
// end ; end ;
109497: GO 109336
109499: POP
109500: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
109501: LD_ADDR_EXP 135
109505: PUSH
109506: LD_EXP 135
109510: PPUSH
109511: LD_VAR 0 1
109515: PPUSH
109516: CALL_OW 255
109520: PUSH
109521: LD_VAR 0 1
109525: PUSH
109526: LD_VAR 0 2
109530: PUSH
109531: LD_VAR 0 3
109535: PUSH
109536: EMPTY
109537: LIST
109538: LIST
109539: LIST
109540: LIST
109541: PPUSH
109542: CALL 58155 0 2
109546: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109547: CALL 109556 0 0
// end ;
109551: LD_VAR 0 4
109555: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109556: LD_INT 0
109558: PPUSH
109559: PPUSH
109560: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109561: LD_STRING resetFactoryWaypoint();
109563: PPUSH
109564: CALL_OW 559
// if factoryWaypoints then
109568: LD_EXP 135
109572: IFFALSE 109693
// begin list := factoryWaypoints ;
109574: LD_ADDR_VAR 0 3
109578: PUSH
109579: LD_EXP 135
109583: ST_TO_ADDR
// for i := 1 to list do
109584: LD_ADDR_VAR 0 2
109588: PUSH
109589: DOUBLE
109590: LD_INT 1
109592: DEC
109593: ST_TO_ADDR
109594: LD_VAR 0 3
109598: PUSH
109599: FOR_TO
109600: IFFALSE 109691
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109602: LD_STRING setFactoryWaypointXY(
109604: PUSH
109605: LD_VAR 0 3
109609: PUSH
109610: LD_VAR 0 2
109614: ARRAY
109615: PUSH
109616: LD_INT 1
109618: ARRAY
109619: STR
109620: PUSH
109621: LD_STRING ,
109623: STR
109624: PUSH
109625: LD_VAR 0 3
109629: PUSH
109630: LD_VAR 0 2
109634: ARRAY
109635: PUSH
109636: LD_INT 2
109638: ARRAY
109639: STR
109640: PUSH
109641: LD_STRING ,
109643: STR
109644: PUSH
109645: LD_VAR 0 3
109649: PUSH
109650: LD_VAR 0 2
109654: ARRAY
109655: PUSH
109656: LD_INT 3
109658: ARRAY
109659: STR
109660: PUSH
109661: LD_STRING ,
109663: STR
109664: PUSH
109665: LD_VAR 0 3
109669: PUSH
109670: LD_VAR 0 2
109674: ARRAY
109675: PUSH
109676: LD_INT 4
109678: ARRAY
109679: STR
109680: PUSH
109681: LD_STRING )
109683: STR
109684: PPUSH
109685: CALL_OW 559
109689: GO 109599
109691: POP
109692: POP
// end ; end ;
109693: LD_VAR 0 1
109697: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109698: LD_INT 0
109700: PPUSH
// if HexInfo ( x , y ) = warehouse then
109701: LD_VAR 0 2
109705: PPUSH
109706: LD_VAR 0 3
109710: PPUSH
109711: CALL_OW 428
109715: PUSH
109716: LD_VAR 0 1
109720: EQUAL
109721: IFFALSE 109748
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109723: LD_ADDR_EXP 137
109727: PUSH
109728: LD_EXP 137
109732: PPUSH
109733: LD_VAR 0 1
109737: PPUSH
109738: LD_INT 0
109740: PPUSH
109741: CALL_OW 1
109745: ST_TO_ADDR
109746: GO 109799
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109748: LD_ADDR_EXP 137
109752: PUSH
109753: LD_EXP 137
109757: PPUSH
109758: LD_VAR 0 1
109762: PPUSH
109763: LD_VAR 0 1
109767: PPUSH
109768: CALL_OW 255
109772: PUSH
109773: LD_VAR 0 1
109777: PUSH
109778: LD_VAR 0 2
109782: PUSH
109783: LD_VAR 0 3
109787: PUSH
109788: EMPTY
109789: LIST
109790: LIST
109791: LIST
109792: LIST
109793: PPUSH
109794: CALL_OW 1
109798: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109799: CALL 109808 0 0
// end ;
109803: LD_VAR 0 4
109807: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109808: LD_INT 0
109810: PPUSH
109811: PPUSH
109812: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109813: LD_STRING resetWarehouseGatheringPoints();
109815: PPUSH
109816: CALL_OW 559
// if warehouseGatheringPoints then
109820: LD_EXP 137
109824: IFFALSE 109950
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109826: LD_ADDR_VAR 0 3
109830: PUSH
109831: LD_EXP 137
109835: PPUSH
109836: CALL 62089 0 1
109840: ST_TO_ADDR
// for i := 1 to list do
109841: LD_ADDR_VAR 0 2
109845: PUSH
109846: DOUBLE
109847: LD_INT 1
109849: DEC
109850: ST_TO_ADDR
109851: LD_VAR 0 3
109855: PUSH
109856: FOR_TO
109857: IFFALSE 109948
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109859: LD_STRING setWarehouseGatheringPointXY(
109861: PUSH
109862: LD_VAR 0 3
109866: PUSH
109867: LD_VAR 0 2
109871: ARRAY
109872: PUSH
109873: LD_INT 1
109875: ARRAY
109876: STR
109877: PUSH
109878: LD_STRING ,
109880: STR
109881: PUSH
109882: LD_VAR 0 3
109886: PUSH
109887: LD_VAR 0 2
109891: ARRAY
109892: PUSH
109893: LD_INT 2
109895: ARRAY
109896: STR
109897: PUSH
109898: LD_STRING ,
109900: STR
109901: PUSH
109902: LD_VAR 0 3
109906: PUSH
109907: LD_VAR 0 2
109911: ARRAY
109912: PUSH
109913: LD_INT 3
109915: ARRAY
109916: STR
109917: PUSH
109918: LD_STRING ,
109920: STR
109921: PUSH
109922: LD_VAR 0 3
109926: PUSH
109927: LD_VAR 0 2
109931: ARRAY
109932: PUSH
109933: LD_INT 4
109935: ARRAY
109936: STR
109937: PUSH
109938: LD_STRING )
109940: STR
109941: PPUSH
109942: CALL_OW 559
109946: GO 109856
109948: POP
109949: POP
// end ; end ;
109950: LD_VAR 0 1
109954: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109955: LD_EXP 137
109959: IFFALSE 110654
109961: GO 109963
109963: DISABLE
109964: LD_INT 0
109966: PPUSH
109967: PPUSH
109968: PPUSH
109969: PPUSH
109970: PPUSH
109971: PPUSH
109972: PPUSH
109973: PPUSH
109974: PPUSH
// begin enable ;
109975: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109976: LD_ADDR_VAR 0 3
109980: PUSH
109981: LD_EXP 137
109985: PPUSH
109986: CALL 62089 0 1
109990: ST_TO_ADDR
// if not list then
109991: LD_VAR 0 3
109995: NOT
109996: IFFALSE 110000
// exit ;
109998: GO 110654
// for i := 1 to list do
110000: LD_ADDR_VAR 0 1
110004: PUSH
110005: DOUBLE
110006: LD_INT 1
110008: DEC
110009: ST_TO_ADDR
110010: LD_VAR 0 3
110014: PUSH
110015: FOR_TO
110016: IFFALSE 110652
// begin depot := list [ i ] [ 2 ] ;
110018: LD_ADDR_VAR 0 8
110022: PUSH
110023: LD_VAR 0 3
110027: PUSH
110028: LD_VAR 0 1
110032: ARRAY
110033: PUSH
110034: LD_INT 2
110036: ARRAY
110037: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
110038: LD_ADDR_VAR 0 5
110042: PUSH
110043: LD_VAR 0 3
110047: PUSH
110048: LD_VAR 0 1
110052: ARRAY
110053: PUSH
110054: LD_INT 1
110056: ARRAY
110057: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110058: LD_VAR 0 8
110062: PPUSH
110063: CALL_OW 301
110067: IFTRUE 110086
110069: PUSH
110070: LD_VAR 0 5
110074: PUSH
110075: LD_VAR 0 8
110079: PPUSH
110080: CALL_OW 255
110084: NONEQUAL
110085: OR
110086: IFFALSE 110115
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110088: LD_ADDR_EXP 137
110092: PUSH
110093: LD_EXP 137
110097: PPUSH
110098: LD_VAR 0 8
110102: PPUSH
110103: LD_INT 0
110105: PPUSH
110106: CALL_OW 1
110110: ST_TO_ADDR
// exit ;
110111: POP
110112: POP
110113: GO 110654
// end ; x := list [ i ] [ 3 ] ;
110115: LD_ADDR_VAR 0 6
110119: PUSH
110120: LD_VAR 0 3
110124: PUSH
110125: LD_VAR 0 1
110129: ARRAY
110130: PUSH
110131: LD_INT 3
110133: ARRAY
110134: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110135: LD_ADDR_VAR 0 7
110139: PUSH
110140: LD_VAR 0 3
110144: PUSH
110145: LD_VAR 0 1
110149: ARRAY
110150: PUSH
110151: LD_INT 4
110153: ARRAY
110154: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110155: LD_ADDR_VAR 0 9
110159: PUSH
110160: LD_VAR 0 6
110164: PPUSH
110165: LD_VAR 0 7
110169: PPUSH
110170: LD_INT 16
110172: PPUSH
110173: CALL 60663 0 3
110177: ST_TO_ADDR
// if not cratesNearbyPoint then
110178: LD_VAR 0 9
110182: NOT
110183: IFFALSE 110189
// exit ;
110185: POP
110186: POP
110187: GO 110654
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110189: LD_ADDR_VAR 0 4
110193: PUSH
110194: LD_INT 22
110196: PUSH
110197: LD_VAR 0 5
110201: PUSH
110202: EMPTY
110203: LIST
110204: LIST
110205: PUSH
110206: LD_INT 3
110208: PUSH
110209: LD_INT 60
110211: PUSH
110212: EMPTY
110213: LIST
110214: PUSH
110215: EMPTY
110216: LIST
110217: LIST
110218: PUSH
110219: LD_INT 91
110221: PUSH
110222: LD_VAR 0 8
110226: PUSH
110227: LD_INT 6
110229: PUSH
110230: EMPTY
110231: LIST
110232: LIST
110233: LIST
110234: PUSH
110235: LD_INT 2
110237: PUSH
110238: LD_INT 25
110240: PUSH
110241: LD_INT 2
110243: PUSH
110244: EMPTY
110245: LIST
110246: LIST
110247: PUSH
110248: LD_INT 25
110250: PUSH
110251: LD_INT 16
110253: PUSH
110254: EMPTY
110255: LIST
110256: LIST
110257: PUSH
110258: EMPTY
110259: LIST
110260: LIST
110261: LIST
110262: PUSH
110263: EMPTY
110264: LIST
110265: LIST
110266: LIST
110267: LIST
110268: PPUSH
110269: CALL_OW 69
110273: PUSH
110274: LD_VAR 0 8
110278: PPUSH
110279: CALL_OW 313
110283: PPUSH
110284: LD_INT 3
110286: PUSH
110287: LD_INT 60
110289: PUSH
110290: EMPTY
110291: LIST
110292: PUSH
110293: EMPTY
110294: LIST
110295: LIST
110296: PUSH
110297: LD_INT 2
110299: PUSH
110300: LD_INT 25
110302: PUSH
110303: LD_INT 2
110305: PUSH
110306: EMPTY
110307: LIST
110308: LIST
110309: PUSH
110310: LD_INT 25
110312: PUSH
110313: LD_INT 16
110315: PUSH
110316: EMPTY
110317: LIST
110318: LIST
110319: PUSH
110320: EMPTY
110321: LIST
110322: LIST
110323: LIST
110324: PUSH
110325: EMPTY
110326: LIST
110327: LIST
110328: PPUSH
110329: CALL_OW 72
110333: UNION
110334: ST_TO_ADDR
// if tmp then
110335: LD_VAR 0 4
110339: IFFALSE 110419
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110341: LD_ADDR_VAR 0 4
110345: PUSH
110346: LD_VAR 0 4
110350: PPUSH
110351: LD_INT 3
110353: PPUSH
110354: CALL 58470 0 2
110358: ST_TO_ADDR
// for j in tmp do
110359: LD_ADDR_VAR 0 2
110363: PUSH
110364: LD_VAR 0 4
110368: PUSH
110369: FOR_IN
110370: IFFALSE 110413
// begin if IsInUnit ( j ) then
110372: LD_VAR 0 2
110376: PPUSH
110377: CALL_OW 310
110381: IFFALSE 110392
// ComExit ( j ) ;
110383: LD_VAR 0 2
110387: PPUSH
110388: CALL 58553 0 1
// AddComCollect ( j , x , y ) ;
110392: LD_VAR 0 2
110396: PPUSH
110397: LD_VAR 0 6
110401: PPUSH
110402: LD_VAR 0 7
110406: PPUSH
110407: CALL_OW 177
// end ;
110411: GO 110369
110413: POP
110414: POP
// exit ;
110415: POP
110416: POP
110417: GO 110654
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110419: LD_ADDR_VAR 0 4
110423: PUSH
110424: LD_INT 22
110426: PUSH
110427: LD_VAR 0 5
110431: PUSH
110432: EMPTY
110433: LIST
110434: LIST
110435: PUSH
110436: LD_INT 91
110438: PUSH
110439: LD_VAR 0 8
110443: PUSH
110444: LD_INT 8
110446: PUSH
110447: EMPTY
110448: LIST
110449: LIST
110450: LIST
110451: PUSH
110452: LD_INT 2
110454: PUSH
110455: LD_INT 34
110457: PUSH
110458: LD_INT 12
110460: PUSH
110461: EMPTY
110462: LIST
110463: LIST
110464: PUSH
110465: LD_INT 34
110467: PUSH
110468: LD_INT 51
110470: PUSH
110471: EMPTY
110472: LIST
110473: LIST
110474: PUSH
110475: LD_INT 34
110477: PUSH
110478: LD_INT 32
110480: PUSH
110481: EMPTY
110482: LIST
110483: LIST
110484: PUSH
110485: LD_INT 34
110487: PUSH
110488: LD_INT 89
110490: PUSH
110491: EMPTY
110492: LIST
110493: LIST
110494: PUSH
110495: EMPTY
110496: LIST
110497: LIST
110498: LIST
110499: LIST
110500: LIST
110501: PUSH
110502: EMPTY
110503: LIST
110504: LIST
110505: LIST
110506: PPUSH
110507: CALL_OW 69
110511: ST_TO_ADDR
// if tmp then
110512: LD_VAR 0 4
110516: IFFALSE 110650
// begin for j in tmp do
110518: LD_ADDR_VAR 0 2
110522: PUSH
110523: LD_VAR 0 4
110527: PUSH
110528: FOR_IN
110529: IFFALSE 110648
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110531: LD_VAR 0 2
110535: PPUSH
110536: CALL_OW 262
110540: PUSH
110541: LD_INT 3
110543: EQUAL
110544: IFTRUE 110561
110546: PUSH
110547: LD_VAR 0 2
110551: PPUSH
110552: CALL_OW 261
110556: PUSH
110557: LD_INT 20
110559: GREATER
110560: OR
110561: IFFALSE 110575
110563: PUSH
110564: LD_VAR 0 2
110568: PPUSH
110569: CALL_OW 314
110573: NOT
110574: AND
110575: IFFALSE 110605
110577: PUSH
110578: LD_VAR 0 2
110582: PPUSH
110583: CALL_OW 263
110587: PUSH
110588: LD_INT 1
110590: NONEQUAL
110591: IFTRUE 110604
110593: PUSH
110594: LD_VAR 0 2
110598: PPUSH
110599: CALL_OW 311
110603: OR
110604: AND
110605: IFFALSE 110646
// begin ComCollect ( j , x , y ) ;
110607: LD_VAR 0 2
110611: PPUSH
110612: LD_VAR 0 6
110616: PPUSH
110617: LD_VAR 0 7
110621: PPUSH
110622: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110626: LD_VAR 0 2
110630: PPUSH
110631: LD_VAR 0 8
110635: PPUSH
110636: CALL_OW 172
// exit ;
110640: POP
110641: POP
110642: POP
110643: POP
110644: GO 110654
// end ;
110646: GO 110528
110648: POP
110649: POP
// end ; end ;
110650: GO 110015
110652: POP
110653: POP
// end ; end_of_file
110654: PPOPN 9
110656: END
// export function SOS_UnitDestroyed ( un ) ; begin
110657: LD_INT 0
110659: PPUSH
// ComRadiation ( un ) ;
110660: LD_VAR 0 1
110664: PPUSH
110665: CALL 111827 0 1
// end ;
110669: LD_VAR 0 2
110673: RET
// export function SOS_UnitKamikazed ( un ) ; begin
110674: LD_INT 0
110676: PPUSH
// ComRadiation ( un ) ;
110677: LD_VAR 0 1
110681: PPUSH
110682: CALL 111827 0 1
// end ;
110686: LD_VAR 0 2
110690: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110691: LD_INT 0
110693: PPUSH
// end ;
110694: LD_VAR 0 4
110698: RET
// export function SOS_Command ( cmd ) ; begin
110699: LD_INT 0
110701: PPUSH
// end ;
110702: LD_VAR 0 2
110706: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110707: LD_INT 0
110709: PPUSH
// end ;
110710: LD_VAR 0 6
110714: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
110715: LD_INT 0
110717: PPUSH
110718: PPUSH
110719: PPUSH
110720: PPUSH
110721: PPUSH
// if not vehicle or not factory then
110722: LD_VAR 0 1
110726: NOT
110727: IFTRUE 110736
110729: PUSH
110730: LD_VAR 0 2
110734: NOT
110735: OR
110736: IFFALSE 110740
// exit ;
110738: GO 111402
// weapon := GetWeapon ( vehicle ) ;
110740: LD_ADDR_VAR 0 7
110744: PUSH
110745: LD_VAR 0 1
110749: PPUSH
110750: CALL_OW 264
110754: ST_TO_ADDR
// if weapon = ar_miner then
110755: LD_VAR 0 7
110759: PUSH
110760: LD_INT 81
110762: EQUAL
110763: IFFALSE 110820
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
110765: LD_ADDR_EXP 146
110769: PUSH
110770: LD_EXP 146
110774: PPUSH
110775: LD_EXP 146
110779: PUSH
110780: LD_INT 1
110782: PLUS
110783: PPUSH
110784: LD_VAR 0 1
110788: PPUSH
110789: CALL_OW 1
110793: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110794: LD_ADDR_EXP 147
110798: PUSH
110799: LD_EXP 147
110803: PPUSH
110804: LD_EXP 147
110808: PUSH
110809: LD_INT 1
110811: PLUS
110812: PPUSH
110813: EMPTY
110814: PPUSH
110815: CALL_OW 1
110819: ST_TO_ADDR
// end ; if not factoryWaypoints then
110820: LD_EXP 135
110824: NOT
110825: IFFALSE 110829
// exit ;
110827: GO 111402
// for i := 1 to Count ( factoryWaypoints ) do
110829: LD_ADDR_VAR 0 4
110833: PUSH
110834: DOUBLE
110835: LD_INT 1
110837: DEC
110838: ST_TO_ADDR
110839: LD_EXP 135
110843: PPUSH
110844: CALL 22179 0 1
110848: PUSH
110849: FOR_TO
110850: IFFALSE 111400
// if factoryWaypoints [ i ] [ 2 ] = factory then
110852: LD_EXP 135
110856: PUSH
110857: LD_VAR 0 4
110861: ARRAY
110862: PUSH
110863: LD_INT 2
110865: ARRAY
110866: PUSH
110867: LD_VAR 0 2
110871: EQUAL
110872: IFFALSE 111398
// begin if GetControl ( vehicle ) = control_manual then
110874: LD_VAR 0 1
110878: PPUSH
110879: CALL_OW 263
110883: PUSH
110884: LD_INT 1
110886: EQUAL
110887: IFFALSE 111251
// begin driver := IsDrivenBy ( vehicle ) ;
110889: LD_ADDR_VAR 0 5
110893: PUSH
110894: LD_VAR 0 1
110898: PPUSH
110899: CALL_OW 311
110903: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
110904: LD_VAR 0 5
110908: PUSH
110909: LD_EXP 136
110913: IN
110914: IFTRUE 110928
110916: PUSH
110917: LD_VAR 0 1
110921: PUSH
110922: LD_EXP 136
110926: IN
110927: OR
110928: IFFALSE 110934
// exit ;
110930: POP
110931: POP
110932: GO 111402
// if not HasTask ( driver ) then
110934: LD_VAR 0 5
110938: PPUSH
110939: CALL_OW 314
110943: NOT
110944: IFFALSE 111249
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
110946: LD_ADDR_EXP 136
110950: PUSH
110951: LD_EXP 136
110955: PPUSH
110956: LD_VAR 0 5
110960: PPUSH
110961: CALL 58155 0 2
110965: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
110966: LD_ADDR_EXP 136
110970: PUSH
110971: LD_EXP 136
110975: PPUSH
110976: LD_VAR 0 1
110980: PPUSH
110981: CALL 58155 0 2
110985: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
110986: LD_ADDR_VAR 0 6
110990: PUSH
110991: LD_EXP 135
110995: PUSH
110996: LD_VAR 0 4
111000: ARRAY
111001: PUSH
111002: LD_INT 3
111004: ARRAY
111005: PPUSH
111006: LD_EXP 135
111010: PUSH
111011: LD_VAR 0 4
111015: ARRAY
111016: PUSH
111017: LD_INT 4
111019: ARRAY
111020: PPUSH
111021: CALL_OW 428
111025: ST_TO_ADDR
// if hex then
111026: LD_VAR 0 6
111030: IFFALSE 111048
// ComMoveUnit ( driver , hex ) else
111032: LD_VAR 0 5
111036: PPUSH
111037: LD_VAR 0 6
111041: PPUSH
111042: CALL_OW 112
111046: GO 111132
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
111048: LD_VAR 0 1
111052: PPUSH
111053: LD_EXP 135
111057: PUSH
111058: LD_VAR 0 4
111062: ARRAY
111063: PUSH
111064: LD_INT 3
111066: ARRAY
111067: PPUSH
111068: LD_EXP 135
111072: PUSH
111073: LD_VAR 0 4
111077: ARRAY
111078: PUSH
111079: LD_INT 4
111081: ARRAY
111082: PPUSH
111083: CALL_OW 297
111087: PUSH
111088: LD_INT 0
111090: GREATER
111091: IFFALSE 111132
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
111093: LD_VAR 0 5
111097: PPUSH
111098: LD_EXP 135
111102: PUSH
111103: LD_VAR 0 4
111107: ARRAY
111108: PUSH
111109: LD_INT 3
111111: ARRAY
111112: PPUSH
111113: LD_EXP 135
111117: PUSH
111118: LD_VAR 0 4
111122: ARRAY
111123: PUSH
111124: LD_INT 4
111126: ARRAY
111127: PPUSH
111128: CALL_OW 111
// AddComExitVehicle ( driver ) ;
111132: LD_VAR 0 5
111136: PPUSH
111137: CALL_OW 181
// if Multiplayer then
111141: LD_OWVAR 4
111145: IFFALSE 111194
// begin repeat wait ( 10 ) ;
111147: LD_INT 10
111149: PPUSH
111150: CALL_OW 67
// until not IsInUnit ( driver ) ;
111154: LD_VAR 0 5
111158: PPUSH
111159: CALL_OW 310
111163: NOT
111164: IFFALSE 111147
// if not HasTask ( driver ) then
111166: LD_VAR 0 5
111170: PPUSH
111171: CALL_OW 314
111175: NOT
111176: IFFALSE 111192
// ComEnterUnit ( driver , factory ) ;
111178: LD_VAR 0 5
111182: PPUSH
111183: LD_VAR 0 2
111187: PPUSH
111188: CALL_OW 120
// end else
111192: GO 111208
// AddComEnterUnit ( driver , factory ) ;
111194: LD_VAR 0 5
111198: PPUSH
111199: LD_VAR 0 2
111203: PPUSH
111204: CALL_OW 180
// wait ( 0 0$1 ) ;
111208: LD_INT 35
111210: PPUSH
111211: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
111215: LD_ADDR_EXP 136
111219: PUSH
111220: LD_EXP 136
111224: PUSH
111225: LD_VAR 0 5
111229: DIFF
111230: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
111231: LD_ADDR_EXP 136
111235: PUSH
111236: LD_EXP 136
111240: PUSH
111241: LD_VAR 0 1
111245: DIFF
111246: ST_TO_ADDR
// break ;
111247: GO 111400
// end ; end else
111249: GO 111398
// if GetControl ( vehicle ) = control_remote then
111251: LD_VAR 0 1
111255: PPUSH
111256: CALL_OW 263
111260: PUSH
111261: LD_INT 2
111263: EQUAL
111264: IFFALSE 111350
// begin wait ( 0 0$2 ) ;
111266: LD_INT 70
111268: PPUSH
111269: CALL_OW 67
// repeat wait ( 10 ) ;
111273: LD_INT 10
111275: PPUSH
111276: CALL_OW 67
// Connect ( vehicle ) ;
111280: LD_VAR 0 1
111284: PPUSH
111285: CALL 28457 0 1
// until IsControledBy ( vehicle ) ;
111289: LD_VAR 0 1
111293: PPUSH
111294: CALL_OW 312
111298: IFFALSE 111273
// wait ( 10 ) ;
111300: LD_INT 10
111302: PPUSH
111303: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
111307: LD_VAR 0 1
111311: PPUSH
111312: LD_EXP 135
111316: PUSH
111317: LD_VAR 0 4
111321: ARRAY
111322: PUSH
111323: LD_INT 3
111325: ARRAY
111326: PPUSH
111327: LD_EXP 135
111331: PUSH
111332: LD_VAR 0 4
111336: ARRAY
111337: PUSH
111338: LD_INT 4
111340: ARRAY
111341: PPUSH
111342: CALL_OW 111
// break ;
111346: GO 111400
// end else
111348: GO 111398
// begin wait ( 0 0$3 ) ;
111350: LD_INT 105
111352: PPUSH
111353: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
111357: LD_VAR 0 1
111361: PPUSH
111362: LD_EXP 135
111366: PUSH
111367: LD_VAR 0 4
111371: ARRAY
111372: PUSH
111373: LD_INT 3
111375: ARRAY
111376: PPUSH
111377: LD_EXP 135
111381: PUSH
111382: LD_VAR 0 4
111386: ARRAY
111387: PUSH
111388: LD_INT 4
111390: ARRAY
111391: PPUSH
111392: CALL_OW 111
// break ;
111396: GO 111400
// end ; end ;
111398: GO 110849
111400: POP
111401: POP
// end ;
111402: LD_VAR 0 3
111406: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
111407: LD_INT 0
111409: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
111410: LD_VAR 0 1
111414: PUSH
111415: LD_INT 250
111417: EQUAL
111418: IFFALSE 111435
111420: PUSH
111421: LD_VAR 0 2
111425: PPUSH
111426: CALL_OW 264
111430: PUSH
111431: LD_INT 81
111433: EQUAL
111434: AND
111435: IFFALSE 111456
// MinerPlaceMine ( unit , x , y ) ;
111437: LD_VAR 0 2
111441: PPUSH
111442: LD_VAR 0 4
111446: PPUSH
111447: LD_VAR 0 5
111451: PPUSH
111452: CALL 114802 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
111456: LD_VAR 0 1
111460: PUSH
111461: LD_INT 251
111463: EQUAL
111464: IFFALSE 111481
111466: PUSH
111467: LD_VAR 0 2
111471: PPUSH
111472: CALL_OW 264
111476: PUSH
111477: LD_INT 81
111479: EQUAL
111480: AND
111481: IFFALSE 111502
// MinerDetonateMine ( unit , x , y ) ;
111483: LD_VAR 0 2
111487: PPUSH
111488: LD_VAR 0 4
111492: PPUSH
111493: LD_VAR 0 5
111497: PPUSH
111498: CALL 115209 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
111502: LD_VAR 0 1
111506: PUSH
111507: LD_INT 252
111509: EQUAL
111510: IFFALSE 111527
111512: PUSH
111513: LD_VAR 0 2
111517: PPUSH
111518: CALL_OW 264
111522: PUSH
111523: LD_INT 81
111525: EQUAL
111526: AND
111527: IFFALSE 111548
// MinerCreateMinefield ( unit , x , y ) ;
111529: LD_VAR 0 2
111533: PPUSH
111534: LD_VAR 0 4
111538: PPUSH
111539: LD_VAR 0 5
111543: PPUSH
111544: CALL 115441 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
111548: LD_VAR 0 1
111552: PUSH
111553: LD_INT 253
111555: EQUAL
111556: IFFALSE 111573
111558: PUSH
111559: LD_VAR 0 2
111563: PPUSH
111564: CALL_OW 257
111568: PUSH
111569: LD_INT 5
111571: EQUAL
111572: AND
111573: IFFALSE 111594
// ComBinocular ( unit , x , y ) ;
111575: LD_VAR 0 2
111579: PPUSH
111580: LD_VAR 0 4
111584: PPUSH
111585: LD_VAR 0 5
111589: PPUSH
111590: CALL 115816 0 3
// if selectedUnit then
111594: LD_VAR 0 3
111598: IFFALSE 111658
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
111600: LD_VAR 0 1
111604: PUSH
111605: LD_INT 254
111607: EQUAL
111608: IFFALSE 111625
111610: PUSH
111611: LD_VAR 0 2
111615: PPUSH
111616: CALL_OW 264
111620: PUSH
111621: LD_INT 99
111623: EQUAL
111624: AND
111625: IFFALSE 111642
111627: PUSH
111628: LD_VAR 0 3
111632: PPUSH
111633: CALL_OW 263
111637: PUSH
111638: LD_INT 3
111640: EQUAL
111641: AND
111642: IFFALSE 111658
// HackDestroyVehicle ( unit , selectedUnit ) ;
111644: LD_VAR 0 2
111648: PPUSH
111649: LD_VAR 0 3
111653: PPUSH
111654: CALL 113992 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
111658: LD_VAR 0 1
111662: PUSH
111663: LD_INT 255
111665: EQUAL
111666: IFFALSE 111690
111668: PUSH
111669: LD_VAR 0 2
111673: PPUSH
111674: CALL_OW 264
111678: PUSH
111679: LD_INT 14
111681: PUSH
111682: LD_INT 53
111684: PUSH
111685: EMPTY
111686: LIST
111687: LIST
111688: IN
111689: AND
111690: IFFALSE 111708
111692: PUSH
111693: LD_VAR 0 4
111697: PPUSH
111698: LD_VAR 0 5
111702: PPUSH
111703: CALL_OW 488
111707: AND
111708: IFFALSE 111732
// CutTreeXYR ( unit , x , y , 12 ) ;
111710: LD_VAR 0 2
111714: PPUSH
111715: LD_VAR 0 4
111719: PPUSH
111720: LD_VAR 0 5
111724: PPUSH
111725: LD_INT 12
111727: PPUSH
111728: CALL 111923 0 4
// if cmd = 256 then
111732: LD_VAR 0 1
111736: PUSH
111737: LD_INT 256
111739: EQUAL
111740: IFFALSE 111761
// SetFactoryWaypoint ( unit , x , y ) ;
111742: LD_VAR 0 2
111746: PPUSH
111747: LD_VAR 0 4
111751: PPUSH
111752: LD_VAR 0 5
111756: PPUSH
111757: CALL 109202 0 3
// if cmd = 257 then
111761: LD_VAR 0 1
111765: PUSH
111766: LD_INT 257
111768: EQUAL
111769: IFFALSE 111790
// SetWarehouseGatheringPoint ( unit , x , y ) ;
111771: LD_VAR 0 2
111775: PPUSH
111776: LD_VAR 0 4
111780: PPUSH
111781: LD_VAR 0 5
111785: PPUSH
111786: CALL 109698 0 3
// if cmd = 258 then
111790: LD_VAR 0 1
111794: PUSH
111795: LD_INT 258
111797: EQUAL
111798: IFFALSE 111822
// BurnTreeXYR ( unit , x , y , 8 ) ;
111800: LD_VAR 0 2
111804: PPUSH
111805: LD_VAR 0 4
111809: PPUSH
111810: LD_VAR 0 5
111814: PPUSH
111815: LD_INT 8
111817: PPUSH
111818: CALL 112345 0 4
// end ;
111822: LD_VAR 0 6
111826: RET
// export function ComRadiation ( un ) ; var eff ; begin
111827: LD_INT 0
111829: PPUSH
111830: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
111831: LD_VAR 0 1
111835: PPUSH
111836: CALL_OW 264
111840: PUSH
111841: LD_INT 91
111843: NONEQUAL
111844: IFFALSE 111848
// exit ;
111846: GO 111918
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
111848: LD_INT 68
111850: PPUSH
111851: LD_VAR 0 1
111855: PPUSH
111856: CALL_OW 255
111860: PPUSH
111861: CALL_OW 321
111865: PUSH
111866: LD_INT 2
111868: EQUAL
111869: IFFALSE 111881
// eff := 50 else
111871: LD_ADDR_VAR 0 3
111875: PUSH
111876: LD_INT 50
111878: ST_TO_ADDR
111879: GO 111889
// eff := 25 ;
111881: LD_ADDR_VAR 0 3
111885: PUSH
111886: LD_INT 25
111888: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
111889: LD_VAR 0 1
111893: PPUSH
111894: CALL_OW 250
111898: PPUSH
111899: LD_VAR 0 1
111903: PPUSH
111904: CALL_OW 251
111908: PPUSH
111909: LD_VAR 0 3
111913: PPUSH
111914: CALL_OW 495
// end ;
111918: LD_VAR 0 2
111922: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
111923: LD_INT 0
111925: PPUSH
111926: PPUSH
111927: PPUSH
111928: PPUSH
111929: PPUSH
111930: PPUSH
111931: PPUSH
111932: PPUSH
111933: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
111934: LD_VAR 0 1
111938: PPUSH
111939: CALL_OW 302
111943: NOT
111944: IFTRUE 111963
111946: PUSH
111947: LD_VAR 0 2
111951: PPUSH
111952: LD_VAR 0 3
111956: PPUSH
111957: CALL_OW 488
111961: NOT
111962: OR
111963: IFTRUE 111972
111965: PUSH
111966: LD_VAR 0 4
111970: NOT
111971: OR
111972: IFFALSE 111976
// exit ;
111974: GO 112340
// if Count ( GetTaskList ( bulldozer ) ) > 10 then
111976: LD_VAR 0 1
111980: PPUSH
111981: CALL_OW 437
111985: PPUSH
111986: CALL 22179 0 1
111990: PUSH
111991: LD_INT 10
111993: GREATER
111994: IFFALSE 111998
// exit ;
111996: GO 112340
// list := [ ] ;
111998: LD_ADDR_VAR 0 13
112002: PUSH
112003: EMPTY
112004: ST_TO_ADDR
// if x - r < 0 then
112005: LD_VAR 0 2
112009: PUSH
112010: LD_VAR 0 4
112014: MINUS
112015: PUSH
112016: LD_INT 0
112018: LESS
112019: IFFALSE 112031
// min_x := 0 else
112021: LD_ADDR_VAR 0 7
112025: PUSH
112026: LD_INT 0
112028: ST_TO_ADDR
112029: GO 112047
// min_x := x - r ;
112031: LD_ADDR_VAR 0 7
112035: PUSH
112036: LD_VAR 0 2
112040: PUSH
112041: LD_VAR 0 4
112045: MINUS
112046: ST_TO_ADDR
// if y - r < 0 then
112047: LD_VAR 0 3
112051: PUSH
112052: LD_VAR 0 4
112056: MINUS
112057: PUSH
112058: LD_INT 0
112060: LESS
112061: IFFALSE 112073
// min_y := 0 else
112063: LD_ADDR_VAR 0 8
112067: PUSH
112068: LD_INT 0
112070: ST_TO_ADDR
112071: GO 112089
// min_y := y - r ;
112073: LD_ADDR_VAR 0 8
112077: PUSH
112078: LD_VAR 0 3
112082: PUSH
112083: LD_VAR 0 4
112087: MINUS
112088: ST_TO_ADDR
// max_x := x + r ;
112089: LD_ADDR_VAR 0 9
112093: PUSH
112094: LD_VAR 0 2
112098: PUSH
112099: LD_VAR 0 4
112103: PLUS
112104: ST_TO_ADDR
// max_y := y + r ;
112105: LD_ADDR_VAR 0 10
112109: PUSH
112110: LD_VAR 0 3
112114: PUSH
112115: LD_VAR 0 4
112119: PLUS
112120: ST_TO_ADDR
// for _x = min_x to max_x do
112121: LD_ADDR_VAR 0 11
112125: PUSH
112126: DOUBLE
112127: LD_VAR 0 7
112131: DEC
112132: ST_TO_ADDR
112133: LD_VAR 0 9
112137: PUSH
112138: FOR_TO
112139: IFFALSE 112258
// for _y = min_y to max_y do
112141: LD_ADDR_VAR 0 12
112145: PUSH
112146: DOUBLE
112147: LD_VAR 0 8
112151: DEC
112152: ST_TO_ADDR
112153: LD_VAR 0 10
112157: PUSH
112158: FOR_TO
112159: IFFALSE 112254
// begin if not ValidHex ( _x , _y ) then
112161: LD_VAR 0 11
112165: PPUSH
112166: LD_VAR 0 12
112170: PPUSH
112171: CALL_OW 488
112175: NOT
112176: IFFALSE 112180
// continue ;
112178: GO 112158
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112180: LD_VAR 0 11
112184: PPUSH
112185: LD_VAR 0 12
112189: PPUSH
112190: CALL_OW 351
112194: IFFALSE 112212
112196: PUSH
112197: LD_VAR 0 11
112201: PPUSH
112202: LD_VAR 0 12
112206: PPUSH
112207: CALL_OW 554
112211: AND
112212: IFFALSE 112252
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112214: LD_ADDR_VAR 0 13
112218: PUSH
112219: LD_VAR 0 13
112223: PPUSH
112224: LD_VAR 0 13
112228: PUSH
112229: LD_INT 1
112231: PLUS
112232: PPUSH
112233: LD_VAR 0 11
112237: PUSH
112238: LD_VAR 0 12
112242: PUSH
112243: EMPTY
112244: LIST
112245: LIST
112246: PPUSH
112247: CALL_OW 2
112251: ST_TO_ADDR
// end ;
112252: GO 112158
112254: POP
112255: POP
112256: GO 112138
112258: POP
112259: POP
// if not list then
112260: LD_VAR 0 13
112264: NOT
112265: IFFALSE 112269
// exit ;
112267: GO 112340
// for i in list do
112269: LD_ADDR_VAR 0 6
112273: PUSH
112274: LD_VAR 0 13
112278: PUSH
112279: FOR_IN
112280: IFFALSE 112338
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112282: LD_VAR 0 1
112286: PPUSH
112287: LD_STRING M
112289: PUSH
112290: LD_VAR 0 6
112294: PUSH
112295: LD_INT 1
112297: ARRAY
112298: PUSH
112299: LD_VAR 0 6
112303: PUSH
112304: LD_INT 2
112306: ARRAY
112307: PUSH
112308: LD_INT 0
112310: PUSH
112311: LD_INT 0
112313: PUSH
112314: LD_INT 0
112316: PUSH
112317: LD_INT 0
112319: PUSH
112320: EMPTY
112321: LIST
112322: LIST
112323: LIST
112324: LIST
112325: LIST
112326: LIST
112327: LIST
112328: PUSH
112329: EMPTY
112330: LIST
112331: PPUSH
112332: CALL_OW 447
112336: GO 112279
112338: POP
112339: POP
// end ;
112340: LD_VAR 0 5
112344: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
112345: LD_INT 0
112347: PPUSH
112348: PPUSH
112349: PPUSH
112350: PPUSH
112351: PPUSH
112352: PPUSH
112353: PPUSH
112354: PPUSH
112355: PPUSH
112356: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
112357: LD_VAR 0 1
112361: PPUSH
112362: CALL_OW 302
112366: NOT
112367: IFTRUE 112386
112369: PUSH
112370: LD_VAR 0 2
112374: PPUSH
112375: LD_VAR 0 3
112379: PPUSH
112380: CALL_OW 488
112384: NOT
112385: OR
112386: IFTRUE 112395
112388: PUSH
112389: LD_VAR 0 4
112393: NOT
112394: OR
112395: IFFALSE 112399
// exit ;
112397: GO 112938
// if Count ( GetTaskList ( flame ) ) > 10 then
112399: LD_VAR 0 1
112403: PPUSH
112404: CALL_OW 437
112408: PPUSH
112409: CALL 22179 0 1
112413: PUSH
112414: LD_INT 10
112416: GREATER
112417: IFFALSE 112421
// exit ;
112419: GO 112938
// list := [ ] ;
112421: LD_ADDR_VAR 0 13
112425: PUSH
112426: EMPTY
112427: ST_TO_ADDR
// if x - r < 0 then
112428: LD_VAR 0 2
112432: PUSH
112433: LD_VAR 0 4
112437: MINUS
112438: PUSH
112439: LD_INT 0
112441: LESS
112442: IFFALSE 112454
// min_x := 0 else
112444: LD_ADDR_VAR 0 7
112448: PUSH
112449: LD_INT 0
112451: ST_TO_ADDR
112452: GO 112470
// min_x := x - r ;
112454: LD_ADDR_VAR 0 7
112458: PUSH
112459: LD_VAR 0 2
112463: PUSH
112464: LD_VAR 0 4
112468: MINUS
112469: ST_TO_ADDR
// if y - r < 0 then
112470: LD_VAR 0 3
112474: PUSH
112475: LD_VAR 0 4
112479: MINUS
112480: PUSH
112481: LD_INT 0
112483: LESS
112484: IFFALSE 112496
// min_y := 0 else
112486: LD_ADDR_VAR 0 8
112490: PUSH
112491: LD_INT 0
112493: ST_TO_ADDR
112494: GO 112512
// min_y := y - r ;
112496: LD_ADDR_VAR 0 8
112500: PUSH
112501: LD_VAR 0 3
112505: PUSH
112506: LD_VAR 0 4
112510: MINUS
112511: ST_TO_ADDR
// max_x := x + r ;
112512: LD_ADDR_VAR 0 9
112516: PUSH
112517: LD_VAR 0 2
112521: PUSH
112522: LD_VAR 0 4
112526: PLUS
112527: ST_TO_ADDR
// max_y := y + r ;
112528: LD_ADDR_VAR 0 10
112532: PUSH
112533: LD_VAR 0 3
112537: PUSH
112538: LD_VAR 0 4
112542: PLUS
112543: ST_TO_ADDR
// for _x = min_x to max_x do
112544: LD_ADDR_VAR 0 11
112548: PUSH
112549: DOUBLE
112550: LD_VAR 0 7
112554: DEC
112555: ST_TO_ADDR
112556: LD_VAR 0 9
112560: PUSH
112561: FOR_TO
112562: IFFALSE 112681
// for _y = min_y to max_y do
112564: LD_ADDR_VAR 0 12
112568: PUSH
112569: DOUBLE
112570: LD_VAR 0 8
112574: DEC
112575: ST_TO_ADDR
112576: LD_VAR 0 10
112580: PUSH
112581: FOR_TO
112582: IFFALSE 112677
// begin if not ValidHex ( _x , _y ) then
112584: LD_VAR 0 11
112588: PPUSH
112589: LD_VAR 0 12
112593: PPUSH
112594: CALL_OW 488
112598: NOT
112599: IFFALSE 112603
// continue ;
112601: GO 112581
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112603: LD_VAR 0 11
112607: PPUSH
112608: LD_VAR 0 12
112612: PPUSH
112613: CALL_OW 351
112617: IFFALSE 112635
112619: PUSH
112620: LD_VAR 0 11
112624: PPUSH
112625: LD_VAR 0 12
112629: PPUSH
112630: CALL_OW 554
112634: AND
112635: IFFALSE 112675
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112637: LD_ADDR_VAR 0 13
112641: PUSH
112642: LD_VAR 0 13
112646: PPUSH
112647: LD_VAR 0 13
112651: PUSH
112652: LD_INT 1
112654: PLUS
112655: PPUSH
112656: LD_VAR 0 11
112660: PUSH
112661: LD_VAR 0 12
112665: PUSH
112666: EMPTY
112667: LIST
112668: LIST
112669: PPUSH
112670: CALL_OW 2
112674: ST_TO_ADDR
// end ;
112675: GO 112581
112677: POP
112678: POP
112679: GO 112561
112681: POP
112682: POP
// if not list then
112683: LD_VAR 0 13
112687: NOT
112688: IFFALSE 112692
// exit ;
112690: GO 112938
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
112692: LD_ADDR_VAR 0 13
112696: PUSH
112697: LD_VAR 0 1
112701: PPUSH
112702: LD_VAR 0 13
112706: PPUSH
112707: LD_INT 1
112709: PPUSH
112710: LD_INT 1
112712: PPUSH
112713: CALL 25585 0 4
112717: ST_TO_ADDR
// ComStop ( flame ) ;
112718: LD_VAR 0 1
112722: PPUSH
112723: CALL_OW 141
// for i in list do
112727: LD_ADDR_VAR 0 6
112731: PUSH
112732: LD_VAR 0 13
112736: PUSH
112737: FOR_IN
112738: IFFALSE 112769
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
112740: LD_VAR 0 1
112744: PPUSH
112745: LD_VAR 0 6
112749: PUSH
112750: LD_INT 1
112752: ARRAY
112753: PPUSH
112754: LD_VAR 0 6
112758: PUSH
112759: LD_INT 2
112761: ARRAY
112762: PPUSH
112763: CALL_OW 176
112767: GO 112737
112769: POP
112770: POP
// repeat wait ( 0 0$1 ) ;
112771: LD_INT 35
112773: PPUSH
112774: CALL_OW 67
// task := GetTaskList ( flame ) ;
112778: LD_ADDR_VAR 0 14
112782: PUSH
112783: LD_VAR 0 1
112787: PPUSH
112788: CALL_OW 437
112792: ST_TO_ADDR
// if not task then
112793: LD_VAR 0 14
112797: NOT
112798: IFFALSE 112802
// exit ;
112800: GO 112938
// if task [ 1 ] [ 1 ] <> | then
112802: LD_VAR 0 14
112806: PUSH
112807: LD_INT 1
112809: ARRAY
112810: PUSH
112811: LD_INT 1
112813: ARRAY
112814: PUSH
112815: LD_STRING |
112817: NONEQUAL
112818: IFFALSE 112822
// exit ;
112820: GO 112938
// _x := task [ 1 ] [ 2 ] ;
112822: LD_ADDR_VAR 0 11
112826: PUSH
112827: LD_VAR 0 14
112831: PUSH
112832: LD_INT 1
112834: ARRAY
112835: PUSH
112836: LD_INT 2
112838: ARRAY
112839: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
112840: LD_ADDR_VAR 0 12
112844: PUSH
112845: LD_VAR 0 14
112849: PUSH
112850: LD_INT 1
112852: ARRAY
112853: PUSH
112854: LD_INT 3
112856: ARRAY
112857: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
112858: LD_VAR 0 11
112862: PPUSH
112863: LD_VAR 0 12
112867: PPUSH
112868: CALL_OW 351
112872: NOT
112873: IFTRUE 112892
112875: PUSH
112876: LD_VAR 0 11
112880: PPUSH
112881: LD_VAR 0 12
112885: PPUSH
112886: CALL_OW 554
112890: NOT
112891: OR
112892: IFFALSE 112926
// begin task := Delete ( task , 1 ) ;
112894: LD_ADDR_VAR 0 14
112898: PUSH
112899: LD_VAR 0 14
112903: PPUSH
112904: LD_INT 1
112906: PPUSH
112907: CALL_OW 3
112911: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
112912: LD_VAR 0 1
112916: PPUSH
112917: LD_VAR 0 14
112921: PPUSH
112922: CALL_OW 446
// end ; until not HasTask ( flame ) ;
112926: LD_VAR 0 1
112930: PPUSH
112931: CALL_OW 314
112935: NOT
112936: IFFALSE 112771
// end ;
112938: LD_VAR 0 5
112942: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
112943: LD_EXP 139
112947: NOT
112948: IFFALSE 112998
112950: GO 112952
112952: DISABLE
// begin initHack := true ;
112953: LD_ADDR_EXP 139
112957: PUSH
112958: LD_INT 1
112960: ST_TO_ADDR
// hackTanks := [ ] ;
112961: LD_ADDR_EXP 140
112965: PUSH
112966: EMPTY
112967: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
112968: LD_ADDR_EXP 141
112972: PUSH
112973: EMPTY
112974: ST_TO_ADDR
// hackLimit := 3 ;
112975: LD_ADDR_EXP 142
112979: PUSH
112980: LD_INT 3
112982: ST_TO_ADDR
// hackDist := 12 ;
112983: LD_ADDR_EXP 143
112987: PUSH
112988: LD_INT 12
112990: ST_TO_ADDR
// hackCounter := [ ] ;
112991: LD_ADDR_EXP 144
112995: PUSH
112996: EMPTY
112997: ST_TO_ADDR
// end ;
112998: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
112999: LD_EXP 139
113003: IFFALSE 113021
113005: PUSH
113006: LD_INT 34
113008: PUSH
113009: LD_INT 99
113011: PUSH
113012: EMPTY
113013: LIST
113014: LIST
113015: PPUSH
113016: CALL_OW 69
113020: AND
113021: IFFALSE 113274
113023: GO 113025
113025: DISABLE
113026: LD_INT 0
113028: PPUSH
113029: PPUSH
// begin enable ;
113030: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
113031: LD_ADDR_VAR 0 1
113035: PUSH
113036: LD_INT 34
113038: PUSH
113039: LD_INT 99
113041: PUSH
113042: EMPTY
113043: LIST
113044: LIST
113045: PPUSH
113046: CALL_OW 69
113050: PUSH
113051: FOR_IN
113052: IFFALSE 113272
// begin if not i in hackTanks then
113054: LD_VAR 0 1
113058: PUSH
113059: LD_EXP 140
113063: IN
113064: NOT
113065: IFFALSE 113148
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
113067: LD_ADDR_EXP 140
113071: PUSH
113072: LD_EXP 140
113076: PPUSH
113077: LD_EXP 140
113081: PUSH
113082: LD_INT 1
113084: PLUS
113085: PPUSH
113086: LD_VAR 0 1
113090: PPUSH
113091: CALL_OW 1
113095: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
113096: LD_ADDR_EXP 141
113100: PUSH
113101: LD_EXP 141
113105: PPUSH
113106: LD_EXP 141
113110: PUSH
113111: LD_INT 1
113113: PLUS
113114: PPUSH
113115: EMPTY
113116: PPUSH
113117: CALL_OW 1
113121: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
113122: LD_ADDR_EXP 144
113126: PUSH
113127: LD_EXP 144
113131: PPUSH
113132: LD_EXP 144
113136: PUSH
113137: LD_INT 1
113139: PLUS
113140: PPUSH
113141: EMPTY
113142: PPUSH
113143: CALL_OW 1
113147: ST_TO_ADDR
// end ; if not IsOk ( i ) then
113148: LD_VAR 0 1
113152: PPUSH
113153: CALL_OW 302
113157: NOT
113158: IFFALSE 113171
// begin HackUnlinkAll ( i ) ;
113160: LD_VAR 0 1
113164: PPUSH
113165: CALL 113277 0 1
// continue ;
113169: GO 113051
// end ; HackCheckCapturedStatus ( i ) ;
113171: LD_VAR 0 1
113175: PPUSH
113176: CALL 113722 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
113180: LD_ADDR_VAR 0 2
113184: PUSH
113185: LD_INT 81
113187: PUSH
113188: LD_VAR 0 1
113192: PPUSH
113193: CALL_OW 255
113197: PUSH
113198: EMPTY
113199: LIST
113200: LIST
113201: PUSH
113202: LD_INT 33
113204: PUSH
113205: LD_INT 3
113207: PUSH
113208: EMPTY
113209: LIST
113210: LIST
113211: PUSH
113212: LD_INT 91
113214: PUSH
113215: LD_VAR 0 1
113219: PUSH
113220: LD_EXP 143
113224: PUSH
113225: EMPTY
113226: LIST
113227: LIST
113228: LIST
113229: PUSH
113230: LD_INT 50
113232: PUSH
113233: EMPTY
113234: LIST
113235: PUSH
113236: EMPTY
113237: LIST
113238: LIST
113239: LIST
113240: LIST
113241: PPUSH
113242: CALL_OW 69
113246: ST_TO_ADDR
// if not tmp then
113247: LD_VAR 0 2
113251: NOT
113252: IFFALSE 113256
// continue ;
113254: GO 113051
// HackLink ( i , tmp ) ;
113256: LD_VAR 0 1
113260: PPUSH
113261: LD_VAR 0 2
113265: PPUSH
113266: CALL 113413 0 2
// end ;
113270: GO 113051
113272: POP
113273: POP
// end ;
113274: PPOPN 2
113276: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
113277: LD_INT 0
113279: PPUSH
113280: PPUSH
113281: PPUSH
// if not hack in hackTanks then
113282: LD_VAR 0 1
113286: PUSH
113287: LD_EXP 140
113291: IN
113292: NOT
113293: IFFALSE 113297
// exit ;
113295: GO 113408
// index := GetElementIndex ( hackTanks , hack ) ;
113297: LD_ADDR_VAR 0 4
113301: PUSH
113302: LD_EXP 140
113306: PPUSH
113307: LD_VAR 0 1
113311: PPUSH
113312: CALL 24880 0 2
113316: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
113317: LD_EXP 141
113321: PUSH
113322: LD_VAR 0 4
113326: ARRAY
113327: IFFALSE 113408
// begin for i in hackTanksCaptured [ index ] do
113329: LD_ADDR_VAR 0 3
113333: PUSH
113334: LD_EXP 141
113338: PUSH
113339: LD_VAR 0 4
113343: ARRAY
113344: PUSH
113345: FOR_IN
113346: IFFALSE 113372
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
113348: LD_VAR 0 3
113352: PUSH
113353: LD_INT 1
113355: ARRAY
113356: PPUSH
113357: LD_VAR 0 3
113361: PUSH
113362: LD_INT 2
113364: ARRAY
113365: PPUSH
113366: CALL_OW 235
113370: GO 113345
113372: POP
113373: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
113374: LD_ADDR_EXP 141
113378: PUSH
113379: LD_EXP 141
113383: PPUSH
113384: LD_VAR 0 4
113388: PPUSH
113389: EMPTY
113390: PPUSH
113391: CALL_OW 1
113395: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
113396: LD_VAR 0 1
113400: PPUSH
113401: LD_INT 0
113403: PPUSH
113404: CALL_OW 505
// end ; end ;
113408: LD_VAR 0 2
113412: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
113413: LD_INT 0
113415: PPUSH
113416: PPUSH
113417: PPUSH
// if not hack in hackTanks or not vehicles then
113418: LD_VAR 0 1
113422: PUSH
113423: LD_EXP 140
113427: IN
113428: NOT
113429: IFTRUE 113438
113431: PUSH
113432: LD_VAR 0 2
113436: NOT
113437: OR
113438: IFFALSE 113442
// exit ;
113440: GO 113717
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
113442: LD_ADDR_VAR 0 2
113446: PUSH
113447: LD_VAR 0 1
113451: PPUSH
113452: LD_VAR 0 2
113456: PPUSH
113457: LD_INT 1
113459: PPUSH
113460: LD_INT 1
113462: PPUSH
113463: CALL 25532 0 4
113467: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
113468: LD_ADDR_VAR 0 5
113472: PUSH
113473: LD_EXP 140
113477: PPUSH
113478: LD_VAR 0 1
113482: PPUSH
113483: CALL 24880 0 2
113487: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
113488: LD_EXP 141
113492: PUSH
113493: LD_VAR 0 5
113497: ARRAY
113498: PUSH
113499: LD_EXP 142
113503: LESS
113504: IFFALSE 113693
// begin for i := 1 to vehicles do
113506: LD_ADDR_VAR 0 4
113510: PUSH
113511: DOUBLE
113512: LD_INT 1
113514: DEC
113515: ST_TO_ADDR
113516: LD_VAR 0 2
113520: PUSH
113521: FOR_TO
113522: IFFALSE 113691
// begin if hackTanksCaptured [ index ] = hackLimit then
113524: LD_EXP 141
113528: PUSH
113529: LD_VAR 0 5
113533: ARRAY
113534: PUSH
113535: LD_EXP 142
113539: EQUAL
113540: IFFALSE 113544
// break ;
113542: GO 113691
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
113544: LD_ADDR_EXP 144
113548: PUSH
113549: LD_EXP 144
113553: PPUSH
113554: LD_VAR 0 5
113558: PPUSH
113559: LD_EXP 144
113563: PUSH
113564: LD_VAR 0 5
113568: ARRAY
113569: PUSH
113570: LD_INT 1
113572: PLUS
113573: PPUSH
113574: CALL_OW 1
113578: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
113579: LD_ADDR_EXP 141
113583: PUSH
113584: LD_EXP 141
113588: PPUSH
113589: LD_VAR 0 5
113593: PUSH
113594: LD_EXP 141
113598: PUSH
113599: LD_VAR 0 5
113603: ARRAY
113604: PUSH
113605: LD_INT 1
113607: PLUS
113608: PUSH
113609: EMPTY
113610: LIST
113611: LIST
113612: PPUSH
113613: LD_VAR 0 2
113617: PUSH
113618: LD_VAR 0 4
113622: ARRAY
113623: PUSH
113624: LD_VAR 0 2
113628: PUSH
113629: LD_VAR 0 4
113633: ARRAY
113634: PPUSH
113635: CALL_OW 255
113639: PUSH
113640: EMPTY
113641: LIST
113642: LIST
113643: PPUSH
113644: CALL 25097 0 3
113648: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
113649: LD_VAR 0 2
113653: PUSH
113654: LD_VAR 0 4
113658: ARRAY
113659: PPUSH
113660: LD_VAR 0 1
113664: PPUSH
113665: CALL_OW 255
113669: PPUSH
113670: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
113674: LD_VAR 0 2
113678: PUSH
113679: LD_VAR 0 4
113683: ARRAY
113684: PPUSH
113685: CALL_OW 141
// end ;
113689: GO 113521
113691: POP
113692: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113693: LD_VAR 0 1
113697: PPUSH
113698: LD_EXP 141
113702: PUSH
113703: LD_VAR 0 5
113707: ARRAY
113708: PUSH
113709: LD_INT 0
113711: PLUS
113712: PPUSH
113713: CALL_OW 505
// end ;
113717: LD_VAR 0 3
113721: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
113722: LD_INT 0
113724: PPUSH
113725: PPUSH
113726: PPUSH
113727: PPUSH
// if not hack in hackTanks then
113728: LD_VAR 0 1
113732: PUSH
113733: LD_EXP 140
113737: IN
113738: NOT
113739: IFFALSE 113743
// exit ;
113741: GO 113987
// index := GetElementIndex ( hackTanks , hack ) ;
113743: LD_ADDR_VAR 0 4
113747: PUSH
113748: LD_EXP 140
113752: PPUSH
113753: LD_VAR 0 1
113757: PPUSH
113758: CALL 24880 0 2
113762: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
113763: LD_ADDR_VAR 0 3
113767: PUSH
113768: DOUBLE
113769: LD_EXP 141
113773: PUSH
113774: LD_VAR 0 4
113778: ARRAY
113779: INC
113780: ST_TO_ADDR
113781: LD_INT 1
113783: PUSH
113784: FOR_DOWNTO
113785: IFFALSE 113961
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
113787: LD_ADDR_VAR 0 5
113791: PUSH
113792: LD_EXP 141
113796: PUSH
113797: LD_VAR 0 4
113801: ARRAY
113802: PUSH
113803: LD_VAR 0 3
113807: ARRAY
113808: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
113809: LD_VAR 0 5
113813: PUSH
113814: LD_INT 1
113816: ARRAY
113817: PPUSH
113818: CALL_OW 302
113822: NOT
113823: IFTRUE 113851
113825: PUSH
113826: LD_VAR 0 5
113830: PUSH
113831: LD_INT 1
113833: ARRAY
113834: PPUSH
113835: CALL_OW 255
113839: PUSH
113840: LD_VAR 0 1
113844: PPUSH
113845: CALL_OW 255
113849: NONEQUAL
113850: OR
113851: IFFALSE 113959
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
113853: LD_VAR 0 5
113857: PUSH
113858: LD_INT 1
113860: ARRAY
113861: PPUSH
113862: CALL_OW 305
113866: IFFALSE 113894
113868: PUSH
113869: LD_VAR 0 5
113873: PUSH
113874: LD_INT 1
113876: ARRAY
113877: PPUSH
113878: CALL_OW 255
113882: PUSH
113883: LD_VAR 0 1
113887: PPUSH
113888: CALL_OW 255
113892: EQUAL
113893: AND
113894: IFFALSE 113918
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
113896: LD_VAR 0 5
113900: PUSH
113901: LD_INT 1
113903: ARRAY
113904: PPUSH
113905: LD_VAR 0 5
113909: PUSH
113910: LD_INT 2
113912: ARRAY
113913: PPUSH
113914: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
113918: LD_ADDR_EXP 141
113922: PUSH
113923: LD_EXP 141
113927: PPUSH
113928: LD_VAR 0 4
113932: PPUSH
113933: LD_EXP 141
113937: PUSH
113938: LD_VAR 0 4
113942: ARRAY
113943: PPUSH
113944: LD_VAR 0 3
113948: PPUSH
113949: CALL_OW 3
113953: PPUSH
113954: CALL_OW 1
113958: ST_TO_ADDR
// end ; end ;
113959: GO 113784
113961: POP
113962: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113963: LD_VAR 0 1
113967: PPUSH
113968: LD_EXP 141
113972: PUSH
113973: LD_VAR 0 4
113977: ARRAY
113978: PUSH
113979: LD_INT 0
113981: PLUS
113982: PPUSH
113983: CALL_OW 505
// end ;
113987: LD_VAR 0 2
113991: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
113992: LD_INT 0
113994: PPUSH
113995: PPUSH
113996: PPUSH
113997: PPUSH
// if not hack in hackTanks then
113998: LD_VAR 0 1
114002: PUSH
114003: LD_EXP 140
114007: IN
114008: NOT
114009: IFFALSE 114013
// exit ;
114011: GO 114098
// index := GetElementIndex ( hackTanks , hack ) ;
114013: LD_ADDR_VAR 0 5
114017: PUSH
114018: LD_EXP 140
114022: PPUSH
114023: LD_VAR 0 1
114027: PPUSH
114028: CALL 24880 0 2
114032: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
114033: LD_ADDR_VAR 0 4
114037: PUSH
114038: DOUBLE
114039: LD_INT 1
114041: DEC
114042: ST_TO_ADDR
114043: LD_EXP 141
114047: PUSH
114048: LD_VAR 0 5
114052: ARRAY
114053: PUSH
114054: FOR_TO
114055: IFFALSE 114096
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
114057: LD_EXP 141
114061: PUSH
114062: LD_VAR 0 5
114066: ARRAY
114067: PUSH
114068: LD_VAR 0 4
114072: ARRAY
114073: PUSH
114074: LD_INT 1
114076: ARRAY
114077: PUSH
114078: LD_VAR 0 2
114082: EQUAL
114083: IFFALSE 114094
// KillUnit ( vehicle ) ;
114085: LD_VAR 0 2
114089: PPUSH
114090: CALL_OW 66
114094: GO 114054
114096: POP
114097: POP
// end ;
114098: LD_VAR 0 3
114102: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
114103: LD_EXP 145
114107: NOT
114108: IFFALSE 114241
114110: GO 114112
114112: DISABLE
114113: LD_INT 0
114115: PPUSH
// begin initMiner := true ;
114116: LD_ADDR_EXP 145
114120: PUSH
114121: LD_INT 1
114123: ST_TO_ADDR
// minersList := [ ] ;
114124: LD_ADDR_EXP 146
114128: PUSH
114129: EMPTY
114130: ST_TO_ADDR
// minerMinesList := [ ] ;
114131: LD_ADDR_EXP 147
114135: PUSH
114136: EMPTY
114137: ST_TO_ADDR
// minesLimitPerVehicle := 10 ;
114138: LD_ADDR_EXP 148
114142: PUSH
114143: LD_INT 10
114145: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
114146: LD_ADDR_VAR 0 1
114150: PUSH
114151: LD_INT 34
114153: PUSH
114154: LD_INT 81
114156: PUSH
114157: EMPTY
114158: LIST
114159: LIST
114160: PPUSH
114161: CALL_OW 69
114165: PUSH
114166: FOR_IN
114167: IFFALSE 114239
// begin if not i in minersList then
114169: LD_VAR 0 1
114173: PUSH
114174: LD_EXP 146
114178: IN
114179: NOT
114180: IFFALSE 114237
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
114182: LD_ADDR_EXP 146
114186: PUSH
114187: LD_EXP 146
114191: PPUSH
114192: LD_EXP 146
114196: PUSH
114197: LD_INT 1
114199: PLUS
114200: PPUSH
114201: LD_VAR 0 1
114205: PPUSH
114206: CALL_OW 1
114210: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
114211: LD_ADDR_EXP 147
114215: PUSH
114216: LD_EXP 147
114220: PPUSH
114221: LD_EXP 147
114225: PUSH
114226: LD_INT 1
114228: PLUS
114229: PPUSH
114230: EMPTY
114231: PPUSH
114232: CALL_OW 1
114236: ST_TO_ADDR
// end end ;
114237: GO 114166
114239: POP
114240: POP
// end ;
114241: PPOPN 1
114243: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
114244: LD_EXP 145
114248: IFFALSE 114279
114250: PUSH
114251: LD_EXP 147
114255: PPUSH
114256: CALL 22179 0 1
114260: IFTRUE 114278
114262: PUSH
114263: LD_INT 34
114265: PUSH
114266: LD_INT 81
114268: PUSH
114269: EMPTY
114270: LIST
114271: LIST
114272: PPUSH
114273: CALL_OW 69
114277: OR
114278: AND
114279: IFFALSE 114799
114281: GO 114283
114283: DISABLE
114284: LD_INT 0
114286: PPUSH
114287: PPUSH
114288: PPUSH
114289: PPUSH
// begin enable ;
114290: ENABLE
// for i := minerMinesList downto 1 do
114291: LD_ADDR_VAR 0 1
114295: PUSH
114296: DOUBLE
114297: LD_EXP 147
114301: INC
114302: ST_TO_ADDR
114303: LD_INT 1
114305: PUSH
114306: FOR_DOWNTO
114307: IFFALSE 114797
// begin side := GetSide ( minersList [ i ] ) ;
114309: LD_ADDR_VAR 0 3
114313: PUSH
114314: LD_EXP 146
114318: PUSH
114319: LD_VAR 0 1
114323: ARRAY
114324: PPUSH
114325: CALL_OW 255
114329: ST_TO_ADDR
// if IsLive ( minersList [ i ] ) and side in [ your_side , 9 ] then
114330: LD_EXP 146
114334: PUSH
114335: LD_VAR 0 1
114339: ARRAY
114340: PPUSH
114341: CALL_OW 300
114345: IFFALSE 114366
114347: PUSH
114348: LD_VAR 0 3
114352: PUSH
114353: LD_OWVAR 2
114357: PUSH
114358: LD_INT 9
114360: PUSH
114361: EMPTY
114362: LIST
114363: LIST
114364: IN
114365: AND
114366: IFFALSE 114399
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
114368: LD_EXP 146
114372: PUSH
114373: LD_VAR 0 1
114377: ARRAY
114378: PPUSH
114379: LD_EXP 147
114383: PUSH
114384: LD_VAR 0 1
114388: ARRAY
114389: PPUSH
114390: CALL 22179 0 1
114394: PPUSH
114395: CALL_OW 505
// if not minerMinesList [ i ] then
114399: LD_EXP 147
114403: PUSH
114404: LD_VAR 0 1
114408: ARRAY
114409: NOT
114410: IFFALSE 114414
// continue ;
114412: GO 114306
// for j := minerMinesList [ i ] downto 1 do
114414: LD_ADDR_VAR 0 2
114418: PUSH
114419: DOUBLE
114420: LD_EXP 147
114424: PUSH
114425: LD_VAR 0 1
114429: ARRAY
114430: INC
114431: ST_TO_ADDR
114432: LD_INT 1
114434: PUSH
114435: FOR_DOWNTO
114436: IFFALSE 114793
// begin if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
114438: LD_EXP 146
114442: PUSH
114443: LD_VAR 0 1
114447: ARRAY
114448: PPUSH
114449: CALL_OW 301
114453: IFTRUE 114473
114455: PUSH
114456: LD_EXP 146
114460: PUSH
114461: LD_VAR 0 1
114465: ARRAY
114466: PPUSH
114467: CALL_OW 305
114471: NOT
114472: OR
114473: IFFALSE 114564
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
114475: LD_EXP 147
114479: PUSH
114480: LD_VAR 0 1
114484: ARRAY
114485: PUSH
114486: LD_VAR 0 2
114490: ARRAY
114491: PUSH
114492: LD_INT 1
114494: ARRAY
114495: PPUSH
114496: LD_EXP 147
114500: PUSH
114501: LD_VAR 0 1
114505: ARRAY
114506: PUSH
114507: LD_VAR 0 2
114511: ARRAY
114512: PUSH
114513: LD_INT 2
114515: ARRAY
114516: PPUSH
114517: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
114521: LD_ADDR_EXP 147
114525: PUSH
114526: LD_EXP 147
114530: PPUSH
114531: LD_VAR 0 1
114535: PPUSH
114536: LD_EXP 147
114540: PUSH
114541: LD_VAR 0 1
114545: ARRAY
114546: PPUSH
114547: LD_VAR 0 2
114551: PPUSH
114552: CALL_OW 3
114556: PPUSH
114557: CALL_OW 1
114561: ST_TO_ADDR
// continue ;
114562: GO 114435
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
114564: LD_ADDR_VAR 0 4
114568: PUSH
114569: LD_EXP 147
114573: PUSH
114574: LD_VAR 0 1
114578: ARRAY
114579: PUSH
114580: LD_VAR 0 2
114584: ARRAY
114585: PUSH
114586: LD_INT 1
114588: ARRAY
114589: PPUSH
114590: LD_EXP 147
114594: PUSH
114595: LD_VAR 0 1
114599: ARRAY
114600: PUSH
114601: LD_VAR 0 2
114605: ARRAY
114606: PUSH
114607: LD_INT 2
114609: ARRAY
114610: PPUSH
114611: CALL_OW 428
114615: ST_TO_ADDR
// if not tmp then
114616: LD_VAR 0 4
114620: NOT
114621: IFFALSE 114625
// continue ;
114623: GO 114435
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
114625: LD_VAR 0 4
114629: PUSH
114630: LD_INT 81
114632: PUSH
114633: LD_VAR 0 3
114637: PUSH
114638: EMPTY
114639: LIST
114640: LIST
114641: PPUSH
114642: CALL_OW 69
114646: IN
114647: IFFALSE 114697
114649: PUSH
114650: LD_EXP 147
114654: PUSH
114655: LD_VAR 0 1
114659: ARRAY
114660: PUSH
114661: LD_VAR 0 2
114665: ARRAY
114666: PUSH
114667: LD_INT 1
114669: ARRAY
114670: PPUSH
114671: LD_EXP 147
114675: PUSH
114676: LD_VAR 0 1
114680: ARRAY
114681: PUSH
114682: LD_VAR 0 2
114686: ARRAY
114687: PUSH
114688: LD_INT 2
114690: ARRAY
114691: PPUSH
114692: CALL_OW 458
114696: AND
114697: IFFALSE 114791
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
114699: LD_EXP 147
114703: PUSH
114704: LD_VAR 0 1
114708: ARRAY
114709: PUSH
114710: LD_VAR 0 2
114714: ARRAY
114715: PUSH
114716: LD_INT 1
114718: ARRAY
114719: PPUSH
114720: LD_EXP 147
114724: PUSH
114725: LD_VAR 0 1
114729: ARRAY
114730: PUSH
114731: LD_VAR 0 2
114735: ARRAY
114736: PUSH
114737: LD_INT 2
114739: ARRAY
114740: PPUSH
114741: LD_VAR 0 3
114745: PPUSH
114746: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
114750: LD_ADDR_EXP 147
114754: PUSH
114755: LD_EXP 147
114759: PPUSH
114760: LD_VAR 0 1
114764: PPUSH
114765: LD_EXP 147
114769: PUSH
114770: LD_VAR 0 1
114774: ARRAY
114775: PPUSH
114776: LD_VAR 0 2
114780: PPUSH
114781: CALL_OW 3
114785: PPUSH
114786: CALL_OW 1
114790: ST_TO_ADDR
// end ; end ;
114791: GO 114435
114793: POP
114794: POP
// end ;
114795: GO 114306
114797: POP
114798: POP
// end ;
114799: PPOPN 4
114801: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
114802: LD_INT 0
114804: PPUSH
114805: PPUSH
114806: PPUSH
114807: PPUSH
// result := false ;
114808: LD_ADDR_VAR 0 4
114812: PUSH
114813: LD_INT 0
114815: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
114816: LD_VAR 0 1
114820: PPUSH
114821: CALL_OW 264
114825: PUSH
114826: LD_INT 81
114828: EQUAL
114829: NOT
114830: IFFALSE 114834
// exit ;
114832: GO 115204
// side := GetSide ( unit ) ;
114834: LD_ADDR_VAR 0 6
114838: PUSH
114839: LD_VAR 0 1
114843: PPUSH
114844: CALL_OW 255
114848: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
114849: LD_ADDR_VAR 0 5
114853: PUSH
114854: LD_EXP 146
114858: PPUSH
114859: LD_VAR 0 1
114863: PPUSH
114864: CALL 24880 0 2
114868: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
114869: LD_EXP 147
114873: PUSH
114874: LD_VAR 0 5
114878: ARRAY
114879: PUSH
114880: LD_EXP 148
114884: GREATEREQUAL
114885: IFFALSE 114889
// exit ;
114887: GO 115204
// ComMoveXY ( unit , x , y ) ;
114889: LD_VAR 0 1
114893: PPUSH
114894: LD_VAR 0 2
114898: PPUSH
114899: LD_VAR 0 3
114903: PPUSH
114904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114908: LD_INT 35
114910: PPUSH
114911: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
114915: LD_VAR 0 1
114919: PPUSH
114920: LD_VAR 0 2
114924: PPUSH
114925: LD_VAR 0 3
114929: PPUSH
114930: CALL 56936 0 3
114934: NOT
114935: IFFALSE 114948
114937: PUSH
114938: LD_VAR 0 1
114942: PPUSH
114943: CALL_OW 314
114947: AND
114948: IFFALSE 114952
// exit ;
114950: GO 115204
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
114952: LD_VAR 0 2
114956: PPUSH
114957: LD_VAR 0 3
114961: PPUSH
114962: CALL_OW 428
114966: PUSH
114967: LD_VAR 0 1
114971: EQUAL
114972: IFFALSE 114986
114974: PUSH
114975: LD_VAR 0 1
114979: PPUSH
114980: CALL_OW 314
114984: NOT
114985: AND
114986: IFFALSE 114908
// if MineAtPos ( x , y ) then
114988: LD_VAR 0 2
114992: PPUSH
114993: LD_VAR 0 3
114997: PPUSH
114998: CALL_OW 458
115002: IFFALSE 115006
// exit ;
115004: GO 115204
// if your_side = side then
115006: LD_OWVAR 2
115010: PUSH
115011: LD_VAR 0 6
115015: EQUAL
115016: IFFALSE 115035
// PlaySoundXY ( x , y , PlantMine ) ;
115018: LD_VAR 0 2
115022: PPUSH
115023: LD_VAR 0 3
115027: PPUSH
115028: LD_STRING PlantMine
115030: PPUSH
115031: CALL_OW 366
// repeat wait ( 1 ) ;
115035: LD_INT 1
115037: PPUSH
115038: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
115042: LD_VAR 0 2
115046: PPUSH
115047: LD_VAR 0 3
115051: PPUSH
115052: LD_VAR 0 6
115056: PPUSH
115057: LD_INT 0
115059: PPUSH
115060: CALL_OW 454
115064: IFFALSE 115035
// if MineAtPos ( x , y ) then
115066: LD_VAR 0 2
115070: PPUSH
115071: LD_VAR 0 3
115075: PPUSH
115076: CALL_OW 458
115080: IFFALSE 115196
// begin for i in minerMinesList [ index ] do
115082: LD_ADDR_VAR 0 7
115086: PUSH
115087: LD_EXP 147
115091: PUSH
115092: LD_VAR 0 5
115096: ARRAY
115097: PUSH
115098: FOR_IN
115099: IFFALSE 115141
// if i [ 1 ] = x and i [ 2 ] = y then
115101: LD_VAR 0 7
115105: PUSH
115106: LD_INT 1
115108: ARRAY
115109: PUSH
115110: LD_VAR 0 2
115114: EQUAL
115115: IFFALSE 115133
115117: PUSH
115118: LD_VAR 0 7
115122: PUSH
115123: LD_INT 2
115125: ARRAY
115126: PUSH
115127: LD_VAR 0 3
115131: EQUAL
115132: AND
115133: IFFALSE 115139
// exit ;
115135: POP
115136: POP
115137: GO 115204
115139: GO 115098
115141: POP
115142: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
115143: LD_ADDR_EXP 147
115147: PUSH
115148: LD_EXP 147
115152: PPUSH
115153: LD_VAR 0 5
115157: PUSH
115158: LD_EXP 147
115162: PUSH
115163: LD_VAR 0 5
115167: ARRAY
115168: PUSH
115169: LD_INT 1
115171: PLUS
115172: PUSH
115173: EMPTY
115174: LIST
115175: LIST
115176: PPUSH
115177: LD_VAR 0 2
115181: PUSH
115182: LD_VAR 0 3
115186: PUSH
115187: EMPTY
115188: LIST
115189: LIST
115190: PPUSH
115191: CALL 25097 0 3
115195: ST_TO_ADDR
// end ; result := true ;
115196: LD_ADDR_VAR 0 4
115200: PUSH
115201: LD_INT 1
115203: ST_TO_ADDR
// end ;
115204: LD_VAR 0 4
115208: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
115209: LD_INT 0
115211: PPUSH
115212: PPUSH
115213: PPUSH
// if not unit in minersList then
115214: LD_VAR 0 1
115218: PUSH
115219: LD_EXP 146
115223: IN
115224: NOT
115225: IFFALSE 115229
// exit ;
115227: GO 115436
// index := GetElementIndex ( minersList , unit ) ;
115229: LD_ADDR_VAR 0 6
115233: PUSH
115234: LD_EXP 146
115238: PPUSH
115239: LD_VAR 0 1
115243: PPUSH
115244: CALL 24880 0 2
115248: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
115249: LD_ADDR_VAR 0 5
115253: PUSH
115254: DOUBLE
115255: LD_EXP 147
115259: PUSH
115260: LD_VAR 0 6
115264: ARRAY
115265: INC
115266: ST_TO_ADDR
115267: LD_INT 1
115269: PUSH
115270: FOR_DOWNTO
115271: IFFALSE 115434
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
115273: LD_EXP 147
115277: PUSH
115278: LD_VAR 0 6
115282: ARRAY
115283: PUSH
115284: LD_VAR 0 5
115288: ARRAY
115289: PUSH
115290: LD_INT 1
115292: ARRAY
115293: PPUSH
115294: LD_EXP 147
115298: PUSH
115299: LD_VAR 0 6
115303: ARRAY
115304: PUSH
115305: LD_VAR 0 5
115309: ARRAY
115310: PUSH
115311: LD_INT 2
115313: ARRAY
115314: PPUSH
115315: LD_VAR 0 2
115319: PPUSH
115320: LD_VAR 0 3
115324: PPUSH
115325: CALL_OW 298
115329: PUSH
115330: LD_INT 6
115332: LESS
115333: IFFALSE 115432
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115335: LD_EXP 147
115339: PUSH
115340: LD_VAR 0 6
115344: ARRAY
115345: PUSH
115346: LD_VAR 0 5
115350: ARRAY
115351: PUSH
115352: LD_INT 1
115354: ARRAY
115355: PPUSH
115356: LD_EXP 147
115360: PUSH
115361: LD_VAR 0 6
115365: ARRAY
115366: PUSH
115367: LD_VAR 0 5
115371: ARRAY
115372: PUSH
115373: LD_INT 2
115375: ARRAY
115376: PPUSH
115377: LD_VAR 0 1
115381: PPUSH
115382: CALL_OW 255
115386: PPUSH
115387: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115391: LD_ADDR_EXP 147
115395: PUSH
115396: LD_EXP 147
115400: PPUSH
115401: LD_VAR 0 6
115405: PPUSH
115406: LD_EXP 147
115410: PUSH
115411: LD_VAR 0 6
115415: ARRAY
115416: PPUSH
115417: LD_VAR 0 5
115421: PPUSH
115422: CALL_OW 3
115426: PPUSH
115427: CALL_OW 1
115431: ST_TO_ADDR
// end ; end ;
115432: GO 115270
115434: POP
115435: POP
// end ;
115436: LD_VAR 0 4
115440: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
115441: LD_INT 0
115443: PPUSH
115444: PPUSH
115445: PPUSH
115446: PPUSH
115447: PPUSH
115448: PPUSH
115449: PPUSH
115450: PPUSH
115451: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
115452: LD_VAR 0 1
115456: PPUSH
115457: CALL_OW 264
115461: PUSH
115462: LD_INT 81
115464: EQUAL
115465: NOT
115466: IFTRUE 115481
115468: PUSH
115469: LD_VAR 0 1
115473: PUSH
115474: LD_EXP 146
115478: IN
115479: NOT
115480: OR
115481: IFFALSE 115485
// exit ;
115483: GO 115811
// index := GetElementIndex ( minersList , unit ) ;
115485: LD_ADDR_VAR 0 6
115489: PUSH
115490: LD_EXP 146
115494: PPUSH
115495: LD_VAR 0 1
115499: PPUSH
115500: CALL 24880 0 2
115504: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
115505: LD_ADDR_VAR 0 8
115509: PUSH
115510: LD_EXP 148
115514: PUSH
115515: LD_EXP 147
115519: PUSH
115520: LD_VAR 0 6
115524: ARRAY
115525: MINUS
115526: ST_TO_ADDR
// if not minesFreeAmount then
115527: LD_VAR 0 8
115531: NOT
115532: IFFALSE 115536
// exit ;
115534: GO 115811
// tmp := [ ] ;
115536: LD_ADDR_VAR 0 7
115540: PUSH
115541: EMPTY
115542: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
115543: LD_ADDR_VAR 0 5
115547: PUSH
115548: DOUBLE
115549: LD_INT 1
115551: DEC
115552: ST_TO_ADDR
115553: LD_VAR 0 8
115557: PUSH
115558: FOR_TO
115559: IFFALSE 115758
// begin _d := rand ( 0 , 5 ) ;
115561: LD_ADDR_VAR 0 11
115565: PUSH
115566: LD_INT 0
115568: PPUSH
115569: LD_INT 5
115571: PPUSH
115572: CALL_OW 12
115576: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
115577: LD_ADDR_VAR 0 12
115581: PUSH
115582: LD_INT 2
115584: PPUSH
115585: LD_INT 6
115587: PPUSH
115588: CALL_OW 12
115592: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
115593: LD_ADDR_VAR 0 9
115597: PUSH
115598: LD_VAR 0 2
115602: PPUSH
115603: LD_VAR 0 11
115607: PPUSH
115608: LD_VAR 0 12
115612: PPUSH
115613: CALL_OW 272
115617: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
115618: LD_ADDR_VAR 0 10
115622: PUSH
115623: LD_VAR 0 3
115627: PPUSH
115628: LD_VAR 0 11
115632: PPUSH
115633: LD_VAR 0 12
115637: PPUSH
115638: CALL_OW 273
115642: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
115643: LD_VAR 0 9
115647: PPUSH
115648: LD_VAR 0 10
115652: PPUSH
115653: CALL_OW 488
115657: IFFALSE 115681
115659: PUSH
115660: LD_VAR 0 9
115664: PUSH
115665: LD_VAR 0 10
115669: PUSH
115670: EMPTY
115671: LIST
115672: LIST
115673: PUSH
115674: LD_VAR 0 7
115678: IN
115679: NOT
115680: AND
115681: IFFALSE 115700
115683: PUSH
115684: LD_VAR 0 9
115688: PPUSH
115689: LD_VAR 0 10
115693: PPUSH
115694: CALL_OW 458
115698: NOT
115699: AND
115700: IFFALSE 115742
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
115702: LD_ADDR_VAR 0 7
115706: PUSH
115707: LD_VAR 0 7
115711: PPUSH
115712: LD_VAR 0 7
115716: PUSH
115717: LD_INT 1
115719: PLUS
115720: PPUSH
115721: LD_VAR 0 9
115725: PUSH
115726: LD_VAR 0 10
115730: PUSH
115731: EMPTY
115732: LIST
115733: LIST
115734: PPUSH
115735: CALL_OW 1
115739: ST_TO_ADDR
115740: GO 115756
// i := i - 1 ;
115742: LD_ADDR_VAR 0 5
115746: PUSH
115747: LD_VAR 0 5
115751: PUSH
115752: LD_INT 1
115754: MINUS
115755: ST_TO_ADDR
// end ;
115756: GO 115558
115758: POP
115759: POP
// for i in tmp do
115760: LD_ADDR_VAR 0 5
115764: PUSH
115765: LD_VAR 0 7
115769: PUSH
115770: FOR_IN
115771: IFFALSE 115809
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
115773: LD_VAR 0 1
115777: PPUSH
115778: LD_VAR 0 5
115782: PUSH
115783: LD_INT 1
115785: ARRAY
115786: PPUSH
115787: LD_VAR 0 5
115791: PUSH
115792: LD_INT 2
115794: ARRAY
115795: PPUSH
115796: CALL 114802 0 3
115800: NOT
115801: IFFALSE 115807
// exit ;
115803: POP
115804: POP
115805: GO 115811
115807: GO 115770
115809: POP
115810: POP
// end ;
115811: LD_VAR 0 4
115815: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
115816: LD_INT 0
115818: PPUSH
115819: PPUSH
115820: PPUSH
115821: PPUSH
115822: PPUSH
115823: PPUSH
115824: PPUSH
115825: PPUSH
115826: PPUSH
// if GetClass ( unit ) <> class_sniper then
115827: LD_VAR 0 1
115831: PPUSH
115832: CALL_OW 257
115836: PUSH
115837: LD_INT 5
115839: NONEQUAL
115840: IFFALSE 115844
// exit ;
115842: GO 116314
// dist := 8 ;
115844: LD_ADDR_VAR 0 5
115848: PUSH
115849: LD_INT 8
115851: ST_TO_ADDR
// viewRange := 12 ;
115852: LD_ADDR_VAR 0 8
115856: PUSH
115857: LD_INT 12
115859: ST_TO_ADDR
// side := GetSide ( unit ) ;
115860: LD_ADDR_VAR 0 6
115864: PUSH
115865: LD_VAR 0 1
115869: PPUSH
115870: CALL_OW 255
115874: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
115875: LD_INT 61
115877: PPUSH
115878: LD_VAR 0 6
115882: PPUSH
115883: CALL_OW 321
115887: PUSH
115888: LD_INT 2
115890: EQUAL
115891: IFFALSE 115901
// viewRange := 16 ;
115893: LD_ADDR_VAR 0 8
115897: PUSH
115898: LD_INT 16
115900: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
115901: LD_VAR 0 1
115905: PPUSH
115906: LD_VAR 0 2
115910: PPUSH
115911: LD_VAR 0 3
115915: PPUSH
115916: CALL_OW 297
115920: PUSH
115921: LD_VAR 0 5
115925: GREATER
115926: IFFALSE 116005
// begin ComMoveXY ( unit , x , y ) ;
115928: LD_VAR 0 1
115932: PPUSH
115933: LD_VAR 0 2
115937: PPUSH
115938: LD_VAR 0 3
115942: PPUSH
115943: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115947: LD_INT 35
115949: PPUSH
115950: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
115954: LD_VAR 0 1
115958: PPUSH
115959: LD_VAR 0 2
115963: PPUSH
115964: LD_VAR 0 3
115968: PPUSH
115969: CALL 56936 0 3
115973: NOT
115974: IFFALSE 115978
// exit ;
115976: GO 116314
// until GetDistUnitXY ( unit , x , y ) < dist ;
115978: LD_VAR 0 1
115982: PPUSH
115983: LD_VAR 0 2
115987: PPUSH
115988: LD_VAR 0 3
115992: PPUSH
115993: CALL_OW 297
115997: PUSH
115998: LD_VAR 0 5
116002: LESS
116003: IFFALSE 115947
// end ; ComTurnXY ( unit , x , y ) ;
116005: LD_VAR 0 1
116009: PPUSH
116010: LD_VAR 0 2
116014: PPUSH
116015: LD_VAR 0 3
116019: PPUSH
116020: CALL_OW 118
// repeat if Multiplayer then
116024: LD_OWVAR 4
116028: IFFALSE 116039
// wait ( 35 ) else
116030: LD_INT 35
116032: PPUSH
116033: CALL_OW 67
116037: GO 116046
// wait ( 5 ) ;
116039: LD_INT 5
116041: PPUSH
116042: CALL_OW 67
// _d := GetDir ( unit ) ;
116046: LD_ADDR_VAR 0 11
116050: PUSH
116051: LD_VAR 0 1
116055: PPUSH
116056: CALL_OW 254
116060: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
116061: LD_ADDR_VAR 0 7
116065: PUSH
116066: LD_VAR 0 1
116070: PPUSH
116071: CALL_OW 250
116075: PPUSH
116076: LD_VAR 0 1
116080: PPUSH
116081: CALL_OW 251
116085: PPUSH
116086: LD_VAR 0 2
116090: PPUSH
116091: LD_VAR 0 3
116095: PPUSH
116096: CALL 59572 0 4
116100: ST_TO_ADDR
// until dir = _d ;
116101: LD_VAR 0 7
116105: PUSH
116106: LD_VAR 0 11
116110: EQUAL
116111: IFFALSE 116024
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
116113: LD_ADDR_VAR 0 9
116117: PUSH
116118: LD_VAR 0 1
116122: PPUSH
116123: CALL_OW 250
116127: PPUSH
116128: LD_VAR 0 7
116132: PPUSH
116133: LD_VAR 0 5
116137: PPUSH
116138: CALL_OW 272
116142: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
116143: LD_ADDR_VAR 0 10
116147: PUSH
116148: LD_VAR 0 1
116152: PPUSH
116153: CALL_OW 251
116157: PPUSH
116158: LD_VAR 0 7
116162: PPUSH
116163: LD_VAR 0 5
116167: PPUSH
116168: CALL_OW 273
116172: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
116173: LD_VAR 0 9
116177: PPUSH
116178: LD_VAR 0 10
116182: PPUSH
116183: CALL_OW 488
116187: NOT
116188: IFFALSE 116192
// exit ;
116190: GO 116314
// ComAnimCustom ( unit , 1 ) ;
116192: LD_VAR 0 1
116196: PPUSH
116197: LD_INT 1
116199: PPUSH
116200: CALL_OW 592
// p := 0 ;
116204: LD_ADDR_VAR 0 12
116208: PUSH
116209: LD_INT 0
116211: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
116212: LD_VAR 0 9
116216: PPUSH
116217: LD_VAR 0 10
116221: PPUSH
116222: LD_VAR 0 6
116226: PPUSH
116227: LD_VAR 0 8
116231: PPUSH
116232: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
116236: LD_INT 35
116238: PPUSH
116239: CALL_OW 67
// p := Inc ( p ) ;
116243: LD_ADDR_VAR 0 12
116247: PUSH
116248: LD_VAR 0 12
116252: PPUSH
116253: CALL 59528 0 1
116257: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
116258: LD_VAR 0 12
116262: PUSH
116263: LD_INT 3
116265: EQUAL
116266: IFTRUE 116280
116268: PUSH
116269: LD_VAR 0 1
116273: PPUSH
116274: CALL_OW 302
116278: NOT
116279: OR
116280: IFTRUE 116293
116282: PUSH
116283: LD_VAR 0 1
116287: PPUSH
116288: CALL_OW 301
116292: OR
116293: IFFALSE 116236
// RemoveSeeing ( _x , _y , side ) ;
116295: LD_VAR 0 9
116299: PPUSH
116300: LD_VAR 0 10
116304: PPUSH
116305: LD_VAR 0 6
116309: PPUSH
116310: CALL_OW 331
// end ;
116314: LD_VAR 0 4
116318: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
116319: LD_INT 0
116321: PPUSH
116322: PPUSH
116323: PPUSH
116324: PPUSH
116325: PPUSH
116326: PPUSH
116327: PPUSH
116328: PPUSH
116329: PPUSH
116330: PPUSH
116331: PPUSH
// if not unit then
116332: LD_VAR 0 1
116336: NOT
116337: IFFALSE 116341
// exit ;
116339: GO 116612
// side := GetSide ( unit ) ;
116341: LD_ADDR_VAR 0 3
116345: PUSH
116346: LD_VAR 0 1
116350: PPUSH
116351: CALL_OW 255
116355: ST_TO_ADDR
// x := GetX ( unit ) ;
116356: LD_ADDR_VAR 0 5
116360: PUSH
116361: LD_VAR 0 1
116365: PPUSH
116366: CALL_OW 250
116370: ST_TO_ADDR
// y := GetY ( unit ) ;
116371: LD_ADDR_VAR 0 6
116375: PUSH
116376: LD_VAR 0 1
116380: PPUSH
116381: CALL_OW 251
116385: ST_TO_ADDR
// r := 8 ;
116386: LD_ADDR_VAR 0 4
116390: PUSH
116391: LD_INT 8
116393: ST_TO_ADDR
// if x - r < 0 then
116394: LD_VAR 0 5
116398: PUSH
116399: LD_VAR 0 4
116403: MINUS
116404: PUSH
116405: LD_INT 0
116407: LESS
116408: IFFALSE 116420
// min_x := 0 else
116410: LD_ADDR_VAR 0 7
116414: PUSH
116415: LD_INT 0
116417: ST_TO_ADDR
116418: GO 116436
// min_x := x - r ;
116420: LD_ADDR_VAR 0 7
116424: PUSH
116425: LD_VAR 0 5
116429: PUSH
116430: LD_VAR 0 4
116434: MINUS
116435: ST_TO_ADDR
// if y - r < 0 then
116436: LD_VAR 0 6
116440: PUSH
116441: LD_VAR 0 4
116445: MINUS
116446: PUSH
116447: LD_INT 0
116449: LESS
116450: IFFALSE 116462
// min_y := 0 else
116452: LD_ADDR_VAR 0 8
116456: PUSH
116457: LD_INT 0
116459: ST_TO_ADDR
116460: GO 116478
// min_y := y - r ;
116462: LD_ADDR_VAR 0 8
116466: PUSH
116467: LD_VAR 0 6
116471: PUSH
116472: LD_VAR 0 4
116476: MINUS
116477: ST_TO_ADDR
// max_x := x + r ;
116478: LD_ADDR_VAR 0 9
116482: PUSH
116483: LD_VAR 0 5
116487: PUSH
116488: LD_VAR 0 4
116492: PLUS
116493: ST_TO_ADDR
// max_y := y + r ;
116494: LD_ADDR_VAR 0 10
116498: PUSH
116499: LD_VAR 0 6
116503: PUSH
116504: LD_VAR 0 4
116508: PLUS
116509: ST_TO_ADDR
// for _x = min_x to max_x do
116510: LD_ADDR_VAR 0 11
116514: PUSH
116515: DOUBLE
116516: LD_VAR 0 7
116520: DEC
116521: ST_TO_ADDR
116522: LD_VAR 0 9
116526: PUSH
116527: FOR_TO
116528: IFFALSE 116610
// for _y = min_y to max_y do
116530: LD_ADDR_VAR 0 12
116534: PUSH
116535: DOUBLE
116536: LD_VAR 0 8
116540: DEC
116541: ST_TO_ADDR
116542: LD_VAR 0 10
116546: PUSH
116547: FOR_TO
116548: IFFALSE 116606
// begin if not ValidHex ( _x , _y ) then
116550: LD_VAR 0 11
116554: PPUSH
116555: LD_VAR 0 12
116559: PPUSH
116560: CALL_OW 488
116564: NOT
116565: IFFALSE 116569
// continue ;
116567: GO 116547
// if MineAtPos ( _x , _y ) then
116569: LD_VAR 0 11
116573: PPUSH
116574: LD_VAR 0 12
116578: PPUSH
116579: CALL_OW 458
116583: IFFALSE 116604
// ViewMineAtPos ( _x , _y , side ) ;
116585: LD_VAR 0 11
116589: PPUSH
116590: LD_VAR 0 12
116594: PPUSH
116595: LD_VAR 0 3
116599: PPUSH
116600: CALL_OW 457
// end ;
116604: GO 116547
116606: POP
116607: POP
116608: GO 116527
116610: POP
116611: POP
// end ;
116612: LD_VAR 0 2
116616: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer , side ; begin
116617: LD_INT 0
116619: PPUSH
116620: PPUSH
116621: PPUSH
116622: PPUSH
116623: PPUSH
116624: PPUSH
116625: PPUSH
// if not units then
116626: LD_VAR 0 1
116630: NOT
116631: IFFALSE 116635
// exit ;
116633: GO 117099
// scaners := [ ] ;
116635: LD_ADDR_VAR 0 6
116639: PUSH
116640: EMPTY
116641: ST_TO_ADDR
// for i in units do
116642: LD_ADDR_VAR 0 3
116646: PUSH
116647: LD_VAR 0 1
116651: PUSH
116652: FOR_IN
116653: IFFALSE 116810
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
116655: LD_VAR 0 3
116659: PPUSH
116660: CALL_OW 264
116664: PUSH
116665: LD_INT 11
116667: NONEQUAL
116668: IFTRUE 116682
116670: PUSH
116671: LD_VAR 0 3
116675: PPUSH
116676: CALL_OW 302
116680: NOT
116681: OR
116682: IFTRUE 116699
116684: PUSH
116685: LD_VAR 0 3
116689: PPUSH
116690: CALL_OW 110
116694: PUSH
116695: LD_INT 502
116697: EQUAL
116698: OR
116699: IFFALSE 116703
// continue ;
116701: GO 116652
// ComStop ( i ) ;
116703: LD_VAR 0 3
116707: PPUSH
116708: CALL_OW 141
// x := GetX ( i ) ;
116712: LD_ADDR_VAR 0 4
116716: PUSH
116717: LD_VAR 0 3
116721: PPUSH
116722: CALL_OW 250
116726: ST_TO_ADDR
// y := GetY ( i ) ;
116727: LD_ADDR_VAR 0 5
116731: PUSH
116732: LD_VAR 0 3
116736: PPUSH
116737: CALL_OW 251
116741: ST_TO_ADDR
// if GetSide ( i ) = your_side then
116742: LD_VAR 0 3
116746: PPUSH
116747: CALL_OW 255
116751: PUSH
116752: LD_OWVAR 2
116756: EQUAL
116757: IFFALSE 116776
// PlaySoundXY ( x , y , mineDetector ) ;
116759: LD_VAR 0 4
116763: PPUSH
116764: LD_VAR 0 5
116768: PPUSH
116769: LD_STRING mineDetector
116771: PPUSH
116772: CALL_OW 366
// scaners := Join ( scaners , i ) ;
116776: LD_ADDR_VAR 0 6
116780: PUSH
116781: LD_VAR 0 6
116785: PPUSH
116786: LD_VAR 0 3
116790: PPUSH
116791: CALL 58155 0 2
116795: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
116796: LD_VAR 0 3
116800: PPUSH
116801: LD_INT 502
116803: PPUSH
116804: CALL_OW 109
// end ;
116808: GO 116652
116810: POP
116811: POP
// if not scaners then
116812: LD_VAR 0 6
116816: NOT
116817: IFFALSE 116821
// exit ;
116819: GO 117099
// wait ( 3 ) ;
116821: LD_INT 3
116823: PPUSH
116824: CALL_OW 67
// timer := 6 ;
116828: LD_ADDR_VAR 0 7
116832: PUSH
116833: LD_INT 6
116835: ST_TO_ADDR
// repeat for i in scaners do
116836: LD_ADDR_VAR 0 3
116840: PUSH
116841: LD_VAR 0 6
116845: PUSH
116846: FOR_IN
116847: IFFALSE 116997
// begin side := GetSide ( i ) ;
116849: LD_ADDR_VAR 0 8
116853: PUSH
116854: LD_VAR 0 3
116858: PPUSH
116859: CALL_OW 255
116863: ST_TO_ADDR
// if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
116864: LD_VAR 0 3
116868: PPUSH
116869: CALL_OW 302
116873: NOT
116874: IFTRUE 116887
116876: PUSH
116877: LD_VAR 0 3
116881: PPUSH
116882: CALL_OW 314
116886: OR
116887: IFTRUE 116918
116889: PUSH
116890: LD_VAR 0 3
116894: PPUSH
116895: CALL_OW 263
116899: PUSH
116900: LD_INT 1
116902: EQUAL
116903: IFFALSE 116917
116905: PUSH
116906: LD_VAR 0 3
116910: PPUSH
116911: CALL_OW 311
116915: NOT
116916: AND
116917: OR
116918: IFFALSE 116962
// begin SetUnitDisplayNumber ( i , 0 ) ;
116920: LD_VAR 0 3
116924: PPUSH
116925: LD_INT 0
116927: PPUSH
116928: CALL_OW 505
// SetTag ( i , 0 ) ;
116932: LD_VAR 0 3
116936: PPUSH
116937: LD_INT 0
116939: PPUSH
116940: CALL_OW 109
// scaners := scaners diff i ;
116944: LD_ADDR_VAR 0 6
116948: PUSH
116949: LD_VAR 0 6
116953: PUSH
116954: LD_VAR 0 3
116958: DIFF
116959: ST_TO_ADDR
// continue ;
116960: GO 116846
// end ; if side in [ your_side , 9 ] then
116962: LD_VAR 0 8
116966: PUSH
116967: LD_OWVAR 2
116971: PUSH
116972: LD_INT 9
116974: PUSH
116975: EMPTY
116976: LIST
116977: LIST
116978: IN
116979: IFFALSE 116995
// SetUnitDisplayNumber ( i , timer ) ;
116981: LD_VAR 0 3
116985: PPUSH
116986: LD_VAR 0 7
116990: PPUSH
116991: CALL_OW 505
// end ;
116995: GO 116846
116997: POP
116998: POP
// if not scaners then
116999: LD_VAR 0 6
117003: NOT
117004: IFFALSE 117008
// exit ;
117006: GO 117099
// timer := Dec ( timer ) ;
117008: LD_ADDR_VAR 0 7
117012: PUSH
117013: LD_VAR 0 7
117017: PPUSH
117018: CALL 59550 0 1
117022: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117023: LD_INT 35
117025: PPUSH
117026: CALL_OW 67
// until timer = 0 ;
117030: LD_VAR 0 7
117034: PUSH
117035: LD_INT 0
117037: EQUAL
117038: IFFALSE 116836
// if not scaners then
117040: LD_VAR 0 6
117044: NOT
117045: IFFALSE 117049
// exit ;
117047: GO 117099
// for i in scaners do
117049: LD_ADDR_VAR 0 3
117053: PUSH
117054: LD_VAR 0 6
117058: PUSH
117059: FOR_IN
117060: IFFALSE 117097
// begin SetUnitDisplayNumber ( i , 0 ) ;
117062: LD_VAR 0 3
117066: PPUSH
117067: LD_INT 0
117069: PPUSH
117070: CALL_OW 505
// SetTag ( i , 0 ) ;
117074: LD_VAR 0 3
117078: PPUSH
117079: LD_INT 0
117081: PPUSH
117082: CALL_OW 109
// RevealDetectorMine ( i ) ;
117086: LD_VAR 0 3
117090: PPUSH
117091: CALL 116319 0 1
// end ;
117095: GO 117059
117097: POP
117098: POP
// end ;
117099: LD_VAR 0 2
117103: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
117104: LD_INT 0
117106: PPUSH
// if p1 = mine_detector_mode then
117107: LD_VAR 0 2
117111: PUSH
117112: LD_INT 103
117114: EQUAL
117115: IFFALSE 117126
// DetectMine ( units ) ;
117117: LD_VAR 0 1
117121: PPUSH
117122: CALL 116617 0 1
// end ; end_of_file
117126: LD_VAR 0 7
117130: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
117131: LD_INT 0
117133: PPUSH
117134: PPUSH
117135: PPUSH
117136: PPUSH
117137: PPUSH
117138: PPUSH
117139: PPUSH
117140: PPUSH
117141: PPUSH
117142: PPUSH
117143: PPUSH
117144: PPUSH
117145: PPUSH
117146: PPUSH
117147: PPUSH
117148: PPUSH
117149: PPUSH
117150: PPUSH
117151: PPUSH
117152: PPUSH
117153: PPUSH
117154: PPUSH
117155: PPUSH
117156: PPUSH
117157: PPUSH
117158: PPUSH
117159: PPUSH
117160: PPUSH
117161: PPUSH
117162: PPUSH
117163: PPUSH
117164: PPUSH
117165: PPUSH
117166: PPUSH
// if not list then
117167: LD_VAR 0 1
117171: NOT
117172: IFFALSE 117176
// exit ;
117174: GO 121895
// base := list [ 1 ] ;
117176: LD_ADDR_VAR 0 3
117180: PUSH
117181: LD_VAR 0 1
117185: PUSH
117186: LD_INT 1
117188: ARRAY
117189: ST_TO_ADDR
// group := list [ 2 ] ;
117190: LD_ADDR_VAR 0 4
117194: PUSH
117195: LD_VAR 0 1
117199: PUSH
117200: LD_INT 2
117202: ARRAY
117203: ST_TO_ADDR
// path := list [ 3 ] ;
117204: LD_ADDR_VAR 0 5
117208: PUSH
117209: LD_VAR 0 1
117213: PUSH
117214: LD_INT 3
117216: ARRAY
117217: ST_TO_ADDR
// flags := list [ 4 ] ;
117218: LD_ADDR_VAR 0 6
117222: PUSH
117223: LD_VAR 0 1
117227: PUSH
117228: LD_INT 4
117230: ARRAY
117231: ST_TO_ADDR
// mined := [ ] ;
117232: LD_ADDR_VAR 0 27
117236: PUSH
117237: EMPTY
117238: ST_TO_ADDR
// bombed := [ ] ;
117239: LD_ADDR_VAR 0 28
117243: PUSH
117244: EMPTY
117245: ST_TO_ADDR
// healers := [ ] ;
117246: LD_ADDR_VAR 0 31
117250: PUSH
117251: EMPTY
117252: ST_TO_ADDR
// to_heal := [ ] ;
117253: LD_ADDR_VAR 0 30
117257: PUSH
117258: EMPTY
117259: ST_TO_ADDR
// repairs := [ ] ;
117260: LD_ADDR_VAR 0 33
117264: PUSH
117265: EMPTY
117266: ST_TO_ADDR
// to_repair := [ ] ;
117267: LD_ADDR_VAR 0 32
117271: PUSH
117272: EMPTY
117273: ST_TO_ADDR
// if not group or not path then
117274: LD_VAR 0 4
117278: NOT
117279: IFTRUE 117288
117281: PUSH
117282: LD_VAR 0 5
117286: NOT
117287: OR
117288: IFFALSE 117292
// exit ;
117290: GO 121895
// side := GetSide ( group [ 1 ] ) ;
117292: LD_ADDR_VAR 0 35
117296: PUSH
117297: LD_VAR 0 4
117301: PUSH
117302: LD_INT 1
117304: ARRAY
117305: PPUSH
117306: CALL_OW 255
117310: ST_TO_ADDR
// if flags then
117311: LD_VAR 0 6
117315: IFFALSE 117459
// begin f_ignore_area := flags [ 1 ] ;
117317: LD_ADDR_VAR 0 17
117321: PUSH
117322: LD_VAR 0 6
117326: PUSH
117327: LD_INT 1
117329: ARRAY
117330: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
117331: LD_ADDR_VAR 0 18
117335: PUSH
117336: LD_VAR 0 6
117340: PUSH
117341: LD_INT 2
117343: ARRAY
117344: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
117345: LD_ADDR_VAR 0 19
117349: PUSH
117350: LD_VAR 0 6
117354: PUSH
117355: LD_INT 3
117357: ARRAY
117358: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
117359: LD_ADDR_VAR 0 20
117363: PUSH
117364: LD_VAR 0 6
117368: PUSH
117369: LD_INT 4
117371: ARRAY
117372: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
117373: LD_ADDR_VAR 0 21
117377: PUSH
117378: LD_VAR 0 6
117382: PUSH
117383: LD_INT 5
117385: ARRAY
117386: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
117387: LD_ADDR_VAR 0 22
117391: PUSH
117392: LD_VAR 0 6
117396: PUSH
117397: LD_INT 6
117399: ARRAY
117400: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
117401: LD_ADDR_VAR 0 23
117405: PUSH
117406: LD_VAR 0 6
117410: PUSH
117411: LD_INT 7
117413: ARRAY
117414: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
117415: LD_ADDR_VAR 0 24
117419: PUSH
117420: LD_VAR 0 6
117424: PUSH
117425: LD_INT 8
117427: ARRAY
117428: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
117429: LD_ADDR_VAR 0 25
117433: PUSH
117434: LD_VAR 0 6
117438: PUSH
117439: LD_INT 9
117441: ARRAY
117442: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
117443: LD_ADDR_VAR 0 26
117447: PUSH
117448: LD_VAR 0 6
117452: PUSH
117453: LD_INT 10
117455: ARRAY
117456: ST_TO_ADDR
// end else
117457: GO 117539
// begin f_ignore_area := false ;
117459: LD_ADDR_VAR 0 17
117463: PUSH
117464: LD_INT 0
117466: ST_TO_ADDR
// f_capture := false ;
117467: LD_ADDR_VAR 0 18
117471: PUSH
117472: LD_INT 0
117474: ST_TO_ADDR
// f_ignore_civ := false ;
117475: LD_ADDR_VAR 0 19
117479: PUSH
117480: LD_INT 0
117482: ST_TO_ADDR
// f_murder := false ;
117483: LD_ADDR_VAR 0 20
117487: PUSH
117488: LD_INT 0
117490: ST_TO_ADDR
// f_mines := false ;
117491: LD_ADDR_VAR 0 21
117495: PUSH
117496: LD_INT 0
117498: ST_TO_ADDR
// f_repair := false ;
117499: LD_ADDR_VAR 0 22
117503: PUSH
117504: LD_INT 0
117506: ST_TO_ADDR
// f_heal := false ;
117507: LD_ADDR_VAR 0 23
117511: PUSH
117512: LD_INT 0
117514: ST_TO_ADDR
// f_spacetime := false ;
117515: LD_ADDR_VAR 0 24
117519: PUSH
117520: LD_INT 0
117522: ST_TO_ADDR
// f_attack_depot := false ;
117523: LD_ADDR_VAR 0 25
117527: PUSH
117528: LD_INT 0
117530: ST_TO_ADDR
// f_crawl := false ;
117531: LD_ADDR_VAR 0 26
117535: PUSH
117536: LD_INT 0
117538: ST_TO_ADDR
// end ; if f_heal then
117539: LD_VAR 0 23
117543: IFFALSE 117570
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
117545: LD_ADDR_VAR 0 31
117549: PUSH
117550: LD_VAR 0 4
117554: PPUSH
117555: LD_INT 25
117557: PUSH
117558: LD_INT 4
117560: PUSH
117561: EMPTY
117562: LIST
117563: LIST
117564: PPUSH
117565: CALL_OW 72
117569: ST_TO_ADDR
// if f_repair then
117570: LD_VAR 0 22
117574: IFFALSE 117601
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
117576: LD_ADDR_VAR 0 33
117580: PUSH
117581: LD_VAR 0 4
117585: PPUSH
117586: LD_INT 25
117588: PUSH
117589: LD_INT 3
117591: PUSH
117592: EMPTY
117593: LIST
117594: LIST
117595: PPUSH
117596: CALL_OW 72
117600: ST_TO_ADDR
// units_path := [ ] ;
117601: LD_ADDR_VAR 0 16
117605: PUSH
117606: EMPTY
117607: ST_TO_ADDR
// for i = 1 to group do
117608: LD_ADDR_VAR 0 7
117612: PUSH
117613: DOUBLE
117614: LD_INT 1
117616: DEC
117617: ST_TO_ADDR
117618: LD_VAR 0 4
117622: PUSH
117623: FOR_TO
117624: IFFALSE 117653
// units_path := Replace ( units_path , i , path ) ;
117626: LD_ADDR_VAR 0 16
117630: PUSH
117631: LD_VAR 0 16
117635: PPUSH
117636: LD_VAR 0 7
117640: PPUSH
117641: LD_VAR 0 5
117645: PPUSH
117646: CALL_OW 1
117650: ST_TO_ADDR
117651: GO 117623
117653: POP
117654: POP
// repeat for i = group downto 1 do
117655: LD_ADDR_VAR 0 7
117659: PUSH
117660: DOUBLE
117661: LD_VAR 0 4
117665: INC
117666: ST_TO_ADDR
117667: LD_INT 1
117669: PUSH
117670: FOR_DOWNTO
117671: IFFALSE 121847
// begin wait ( 5 ) ;
117673: LD_INT 5
117675: PPUSH
117676: CALL_OW 67
// tmp := [ ] ;
117680: LD_ADDR_VAR 0 14
117684: PUSH
117685: EMPTY
117686: ST_TO_ADDR
// attacking := false ;
117687: LD_ADDR_VAR 0 29
117691: PUSH
117692: LD_INT 0
117694: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
117695: LD_VAR 0 4
117699: PUSH
117700: LD_VAR 0 7
117704: ARRAY
117705: PPUSH
117706: CALL_OW 301
117710: IFTRUE 117725
117712: PUSH
117713: LD_VAR 0 4
117717: PUSH
117718: LD_VAR 0 7
117722: ARRAY
117723: NOT
117724: OR
117725: IFFALSE 117834
// begin if GetType ( group [ i ] ) = unit_human then
117727: LD_VAR 0 4
117731: PUSH
117732: LD_VAR 0 7
117736: ARRAY
117737: PPUSH
117738: CALL_OW 247
117742: PUSH
117743: LD_INT 1
117745: EQUAL
117746: IFFALSE 117792
// begin to_heal := to_heal diff group [ i ] ;
117748: LD_ADDR_VAR 0 30
117752: PUSH
117753: LD_VAR 0 30
117757: PUSH
117758: LD_VAR 0 4
117762: PUSH
117763: LD_VAR 0 7
117767: ARRAY
117768: DIFF
117769: ST_TO_ADDR
// healers := healers diff group [ i ] ;
117770: LD_ADDR_VAR 0 31
117774: PUSH
117775: LD_VAR 0 31
117779: PUSH
117780: LD_VAR 0 4
117784: PUSH
117785: LD_VAR 0 7
117789: ARRAY
117790: DIFF
117791: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
117792: LD_ADDR_VAR 0 4
117796: PUSH
117797: LD_VAR 0 4
117801: PPUSH
117802: LD_VAR 0 7
117806: PPUSH
117807: CALL_OW 3
117811: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
117812: LD_ADDR_VAR 0 16
117816: PUSH
117817: LD_VAR 0 16
117821: PPUSH
117822: LD_VAR 0 7
117826: PPUSH
117827: CALL_OW 3
117831: ST_TO_ADDR
// continue ;
117832: GO 117670
// end ; if f_repair then
117834: LD_VAR 0 22
117838: IFFALSE 118335
// begin if GetType ( group [ i ] ) = unit_vehicle then
117840: LD_VAR 0 4
117844: PUSH
117845: LD_VAR 0 7
117849: ARRAY
117850: PPUSH
117851: CALL_OW 247
117855: PUSH
117856: LD_INT 2
117858: EQUAL
117859: IFFALSE 118053
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
117861: LD_VAR 0 4
117865: PUSH
117866: LD_VAR 0 7
117870: ARRAY
117871: PPUSH
117872: CALL_OW 256
117876: PUSH
117877: LD_INT 700
117879: LESS
117880: IFFALSE 117901
117882: PUSH
117883: LD_VAR 0 4
117887: PUSH
117888: LD_VAR 0 7
117892: ARRAY
117893: PUSH
117894: LD_VAR 0 32
117898: IN
117899: NOT
117900: AND
117901: IFFALSE 117925
// to_repair := to_repair union group [ i ] ;
117903: LD_ADDR_VAR 0 32
117907: PUSH
117908: LD_VAR 0 32
117912: PUSH
117913: LD_VAR 0 4
117917: PUSH
117918: LD_VAR 0 7
117922: ARRAY
117923: UNION
117924: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
117925: LD_VAR 0 4
117929: PUSH
117930: LD_VAR 0 7
117934: ARRAY
117935: PPUSH
117936: CALL_OW 256
117940: PUSH
117941: LD_INT 1000
117943: EQUAL
117944: IFFALSE 117964
117946: PUSH
117947: LD_VAR 0 4
117951: PUSH
117952: LD_VAR 0 7
117956: ARRAY
117957: PUSH
117958: LD_VAR 0 32
117962: IN
117963: AND
117964: IFFALSE 117988
// to_repair := to_repair diff group [ i ] ;
117966: LD_ADDR_VAR 0 32
117970: PUSH
117971: LD_VAR 0 32
117975: PUSH
117976: LD_VAR 0 4
117980: PUSH
117981: LD_VAR 0 7
117985: ARRAY
117986: DIFF
117987: ST_TO_ADDR
// if group [ i ] in to_repair then
117988: LD_VAR 0 4
117992: PUSH
117993: LD_VAR 0 7
117997: ARRAY
117998: PUSH
117999: LD_VAR 0 32
118003: IN
118004: IFFALSE 118051
// begin if not IsInArea ( group [ i ] , f_repair ) then
118006: LD_VAR 0 4
118010: PUSH
118011: LD_VAR 0 7
118015: ARRAY
118016: PPUSH
118017: LD_VAR 0 22
118021: PPUSH
118022: CALL_OW 308
118026: NOT
118027: IFFALSE 118049
// ComMoveToArea ( group [ i ] , f_repair ) ;
118029: LD_VAR 0 4
118033: PUSH
118034: LD_VAR 0 7
118038: ARRAY
118039: PPUSH
118040: LD_VAR 0 22
118044: PPUSH
118045: CALL_OW 113
// continue ;
118049: GO 117670
// end ; end else
118051: GO 118335
// if group [ i ] in repairs then
118053: LD_VAR 0 4
118057: PUSH
118058: LD_VAR 0 7
118062: ARRAY
118063: PUSH
118064: LD_VAR 0 33
118068: IN
118069: IFFALSE 118335
// begin if IsInUnit ( group [ i ] ) then
118071: LD_VAR 0 4
118075: PUSH
118076: LD_VAR 0 7
118080: ARRAY
118081: PPUSH
118082: CALL_OW 310
118086: IFFALSE 118156
// begin z := IsInUnit ( group [ i ] ) ;
118088: LD_ADDR_VAR 0 13
118092: PUSH
118093: LD_VAR 0 4
118097: PUSH
118098: LD_VAR 0 7
118102: ARRAY
118103: PPUSH
118104: CALL_OW 310
118108: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
118109: LD_VAR 0 13
118113: PUSH
118114: LD_VAR 0 32
118118: IN
118119: IFFALSE 118137
118121: PUSH
118122: LD_VAR 0 13
118126: PPUSH
118127: LD_VAR 0 22
118131: PPUSH
118132: CALL_OW 308
118136: AND
118137: IFFALSE 118154
// ComExitVehicle ( group [ i ] ) ;
118139: LD_VAR 0 4
118143: PUSH
118144: LD_VAR 0 7
118148: ARRAY
118149: PPUSH
118150: CALL_OW 121
// end else
118154: GO 118335
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
118156: LD_ADDR_VAR 0 13
118160: PUSH
118161: LD_VAR 0 4
118165: PPUSH
118166: LD_INT 95
118168: PUSH
118169: LD_VAR 0 22
118173: PUSH
118174: EMPTY
118175: LIST
118176: LIST
118177: PUSH
118178: LD_INT 58
118180: PUSH
118181: EMPTY
118182: LIST
118183: PUSH
118184: EMPTY
118185: LIST
118186: LIST
118187: PPUSH
118188: CALL_OW 72
118192: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
118193: LD_VAR 0 4
118197: PUSH
118198: LD_VAR 0 7
118202: ARRAY
118203: PPUSH
118204: CALL_OW 314
118208: NOT
118209: IFFALSE 118333
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
118211: LD_ADDR_VAR 0 10
118215: PUSH
118216: LD_VAR 0 13
118220: PPUSH
118221: LD_VAR 0 4
118225: PUSH
118226: LD_VAR 0 7
118230: ARRAY
118231: PPUSH
118232: CALL_OW 74
118236: ST_TO_ADDR
// if not x then
118237: LD_VAR 0 10
118241: NOT
118242: IFFALSE 118246
// continue ;
118244: GO 117670
// if GetLives ( x ) < 1000 then
118246: LD_VAR 0 10
118250: PPUSH
118251: CALL_OW 256
118255: PUSH
118256: LD_INT 1000
118258: LESS
118259: IFFALSE 118283
// ComRepairVehicle ( group [ i ] , x ) else
118261: LD_VAR 0 4
118265: PUSH
118266: LD_VAR 0 7
118270: ARRAY
118271: PPUSH
118272: LD_VAR 0 10
118276: PPUSH
118277: CALL_OW 129
118281: GO 118333
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
118283: LD_VAR 0 23
118287: IFFALSE 118310
118289: PUSH
118290: LD_VAR 0 4
118294: PUSH
118295: LD_VAR 0 7
118299: ARRAY
118300: PPUSH
118301: CALL_OW 256
118305: PUSH
118306: LD_INT 1000
118308: LESS
118309: AND
118310: NOT
118311: IFFALSE 118333
// ComEnterUnit ( group [ i ] , x ) ;
118313: LD_VAR 0 4
118317: PUSH
118318: LD_VAR 0 7
118322: ARRAY
118323: PPUSH
118324: LD_VAR 0 10
118328: PPUSH
118329: CALL_OW 120
// end ; continue ;
118333: GO 117670
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
118335: LD_VAR 0 23
118339: IFFALSE 118362
118341: PUSH
118342: LD_VAR 0 4
118346: PUSH
118347: LD_VAR 0 7
118351: ARRAY
118352: PPUSH
118353: CALL_OW 247
118357: PUSH
118358: LD_INT 1
118360: EQUAL
118361: AND
118362: IFFALSE 118846
// begin if group [ i ] in healers then
118364: LD_VAR 0 4
118368: PUSH
118369: LD_VAR 0 7
118373: ARRAY
118374: PUSH
118375: LD_VAR 0 31
118379: IN
118380: IFFALSE 118657
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
118382: LD_VAR 0 4
118386: PUSH
118387: LD_VAR 0 7
118391: ARRAY
118392: PPUSH
118393: LD_VAR 0 23
118397: PPUSH
118398: CALL_OW 308
118402: NOT
118403: IFFALSE 118423
118405: PUSH
118406: LD_VAR 0 4
118410: PUSH
118411: LD_VAR 0 7
118415: ARRAY
118416: PPUSH
118417: CALL_OW 314
118421: NOT
118422: AND
118423: IFFALSE 118447
// ComMoveToArea ( group [ i ] , f_heal ) else
118425: LD_VAR 0 4
118429: PUSH
118430: LD_VAR 0 7
118434: ARRAY
118435: PPUSH
118436: LD_VAR 0 23
118440: PPUSH
118441: CALL_OW 113
118445: GO 118655
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
118447: LD_VAR 0 4
118451: PUSH
118452: LD_VAR 0 7
118456: ARRAY
118457: PPUSH
118458: CALL 55511 0 1
118462: PPUSH
118463: CALL_OW 256
118467: PUSH
118468: LD_INT 1000
118470: EQUAL
118471: IFFALSE 118490
// ComStop ( group [ i ] ) else
118473: LD_VAR 0 4
118477: PUSH
118478: LD_VAR 0 7
118482: ARRAY
118483: PPUSH
118484: CALL_OW 141
118488: GO 118655
// if not HasTask ( group [ i ] ) and to_heal then
118490: LD_VAR 0 4
118494: PUSH
118495: LD_VAR 0 7
118499: ARRAY
118500: PPUSH
118501: CALL_OW 314
118505: NOT
118506: IFFALSE 118514
118508: PUSH
118509: LD_VAR 0 30
118513: AND
118514: IFFALSE 118655
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
118516: LD_ADDR_VAR 0 13
118520: PUSH
118521: LD_VAR 0 30
118525: PPUSH
118526: LD_INT 3
118528: PUSH
118529: LD_INT 54
118531: PUSH
118532: EMPTY
118533: LIST
118534: PUSH
118535: EMPTY
118536: LIST
118537: LIST
118538: PPUSH
118539: CALL_OW 72
118543: PPUSH
118544: LD_VAR 0 4
118548: PUSH
118549: LD_VAR 0 7
118553: ARRAY
118554: PPUSH
118555: CALL_OW 74
118559: ST_TO_ADDR
// if z then
118560: LD_VAR 0 13
118564: IFFALSE 118655
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
118566: LD_INT 91
118568: PUSH
118569: LD_VAR 0 13
118573: PUSH
118574: LD_INT 10
118576: PUSH
118577: EMPTY
118578: LIST
118579: LIST
118580: LIST
118581: PUSH
118582: LD_INT 81
118584: PUSH
118585: LD_VAR 0 13
118589: PPUSH
118590: CALL_OW 255
118594: PUSH
118595: EMPTY
118596: LIST
118597: LIST
118598: PUSH
118599: EMPTY
118600: LIST
118601: LIST
118602: PPUSH
118603: CALL_OW 69
118607: PUSH
118608: LD_INT 0
118610: EQUAL
118611: IFFALSE 118635
// ComHeal ( group [ i ] , z ) else
118613: LD_VAR 0 4
118617: PUSH
118618: LD_VAR 0 7
118622: ARRAY
118623: PPUSH
118624: LD_VAR 0 13
118628: PPUSH
118629: CALL_OW 128
118633: GO 118655
// ComMoveToArea ( group [ i ] , f_heal ) ;
118635: LD_VAR 0 4
118639: PUSH
118640: LD_VAR 0 7
118644: ARRAY
118645: PPUSH
118646: LD_VAR 0 23
118650: PPUSH
118651: CALL_OW 113
// end ; continue ;
118655: GO 117670
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
118657: LD_VAR 0 4
118661: PUSH
118662: LD_VAR 0 7
118666: ARRAY
118667: PPUSH
118668: CALL_OW 256
118672: PUSH
118673: LD_INT 700
118675: LESS
118676: IFFALSE 118697
118678: PUSH
118679: LD_VAR 0 4
118683: PUSH
118684: LD_VAR 0 7
118688: ARRAY
118689: PUSH
118690: LD_VAR 0 30
118694: IN
118695: NOT
118696: AND
118697: IFFALSE 118721
// to_heal := to_heal union group [ i ] ;
118699: LD_ADDR_VAR 0 30
118703: PUSH
118704: LD_VAR 0 30
118708: PUSH
118709: LD_VAR 0 4
118713: PUSH
118714: LD_VAR 0 7
118718: ARRAY
118719: UNION
118720: ST_TO_ADDR
// if group [ i ] in to_heal then
118721: LD_VAR 0 4
118725: PUSH
118726: LD_VAR 0 7
118730: ARRAY
118731: PUSH
118732: LD_VAR 0 30
118736: IN
118737: IFFALSE 118846
// begin if GetLives ( group [ i ] ) = 1000 then
118739: LD_VAR 0 4
118743: PUSH
118744: LD_VAR 0 7
118748: ARRAY
118749: PPUSH
118750: CALL_OW 256
118754: PUSH
118755: LD_INT 1000
118757: EQUAL
118758: IFFALSE 118784
// to_heal := to_heal diff group [ i ] else
118760: LD_ADDR_VAR 0 30
118764: PUSH
118765: LD_VAR 0 30
118769: PUSH
118770: LD_VAR 0 4
118774: PUSH
118775: LD_VAR 0 7
118779: ARRAY
118780: DIFF
118781: ST_TO_ADDR
118782: GO 118846
// begin if not IsInArea ( group [ i ] , to_heal ) then
118784: LD_VAR 0 4
118788: PUSH
118789: LD_VAR 0 7
118793: ARRAY
118794: PPUSH
118795: LD_VAR 0 30
118799: PPUSH
118800: CALL_OW 308
118804: NOT
118805: IFFALSE 118829
// ComMoveToArea ( group [ i ] , f_heal ) else
118807: LD_VAR 0 4
118811: PUSH
118812: LD_VAR 0 7
118816: ARRAY
118817: PPUSH
118818: LD_VAR 0 23
118822: PPUSH
118823: CALL_OW 113
118827: GO 118844
// ComHold ( group [ i ] ) ;
118829: LD_VAR 0 4
118833: PUSH
118834: LD_VAR 0 7
118838: ARRAY
118839: PPUSH
118840: CALL_OW 140
// continue ;
118844: GO 117670
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
118846: LD_VAR 0 4
118850: PUSH
118851: LD_VAR 0 7
118855: ARRAY
118856: PPUSH
118857: LD_INT 10
118859: PPUSH
118860: CALL 53110 0 2
118864: NOT
118865: IFFALSE 118883
118867: PUSH
118868: LD_VAR 0 16
118872: PUSH
118873: LD_VAR 0 7
118877: ARRAY
118878: PUSH
118879: EMPTY
118880: EQUAL
118881: NOT
118882: AND
118883: IFFALSE 119149
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
118885: LD_VAR 0 4
118889: PUSH
118890: LD_VAR 0 7
118894: ARRAY
118895: PPUSH
118896: CALL_OW 262
118900: PUSH
118901: LD_INT 1
118903: PUSH
118904: LD_INT 2
118906: PUSH
118907: EMPTY
118908: LIST
118909: LIST
118910: IN
118911: IFFALSE 118952
// if GetFuel ( group [ i ] ) < 10 then
118913: LD_VAR 0 4
118917: PUSH
118918: LD_VAR 0 7
118922: ARRAY
118923: PPUSH
118924: CALL_OW 261
118928: PUSH
118929: LD_INT 10
118931: LESS
118932: IFFALSE 118952
// SetFuel ( group [ i ] , 12 ) ;
118934: LD_VAR 0 4
118938: PUSH
118939: LD_VAR 0 7
118943: ARRAY
118944: PPUSH
118945: LD_INT 12
118947: PPUSH
118948: CALL_OW 240
// if units_path [ i ] then
118952: LD_VAR 0 16
118956: PUSH
118957: LD_VAR 0 7
118961: ARRAY
118962: IFFALSE 119147
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
118964: LD_VAR 0 4
118968: PUSH
118969: LD_VAR 0 7
118973: ARRAY
118974: PPUSH
118975: LD_VAR 0 16
118979: PUSH
118980: LD_VAR 0 7
118984: ARRAY
118985: PUSH
118986: LD_INT 1
118988: ARRAY
118989: PUSH
118990: LD_INT 1
118992: ARRAY
118993: PPUSH
118994: LD_VAR 0 16
118998: PUSH
118999: LD_VAR 0 7
119003: ARRAY
119004: PUSH
119005: LD_INT 1
119007: ARRAY
119008: PUSH
119009: LD_INT 2
119011: ARRAY
119012: PPUSH
119013: CALL_OW 297
119017: PUSH
119018: LD_INT 6
119020: GREATER
119021: IFFALSE 119096
// begin if not HasTask ( group [ i ] ) then
119023: LD_VAR 0 4
119027: PUSH
119028: LD_VAR 0 7
119032: ARRAY
119033: PPUSH
119034: CALL_OW 314
119038: NOT
119039: IFFALSE 119094
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
119041: LD_VAR 0 4
119045: PUSH
119046: LD_VAR 0 7
119050: ARRAY
119051: PPUSH
119052: LD_VAR 0 16
119056: PUSH
119057: LD_VAR 0 7
119061: ARRAY
119062: PUSH
119063: LD_INT 1
119065: ARRAY
119066: PUSH
119067: LD_INT 1
119069: ARRAY
119070: PPUSH
119071: LD_VAR 0 16
119075: PUSH
119076: LD_VAR 0 7
119080: ARRAY
119081: PUSH
119082: LD_INT 1
119084: ARRAY
119085: PUSH
119086: LD_INT 2
119088: ARRAY
119089: PPUSH
119090: CALL_OW 114
// end else
119094: GO 119147
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
119096: LD_ADDR_VAR 0 15
119100: PUSH
119101: LD_VAR 0 16
119105: PUSH
119106: LD_VAR 0 7
119110: ARRAY
119111: PPUSH
119112: LD_INT 1
119114: PPUSH
119115: CALL_OW 3
119119: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
119120: LD_ADDR_VAR 0 16
119124: PUSH
119125: LD_VAR 0 16
119129: PPUSH
119130: LD_VAR 0 7
119134: PPUSH
119135: LD_VAR 0 15
119139: PPUSH
119140: CALL_OW 1
119144: ST_TO_ADDR
// continue ;
119145: GO 117670
// end ; end ; end else
119147: GO 121845
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
119149: LD_ADDR_VAR 0 14
119153: PUSH
119154: LD_INT 81
119156: PUSH
119157: LD_VAR 0 4
119161: PUSH
119162: LD_VAR 0 7
119166: ARRAY
119167: PPUSH
119168: CALL_OW 255
119172: PUSH
119173: EMPTY
119174: LIST
119175: LIST
119176: PPUSH
119177: CALL_OW 69
119181: ST_TO_ADDR
// if not tmp then
119182: LD_VAR 0 14
119186: NOT
119187: IFFALSE 119191
// continue ;
119189: GO 117670
// if f_ignore_area then
119191: LD_VAR 0 17
119195: IFFALSE 119283
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
119197: LD_ADDR_VAR 0 15
119201: PUSH
119202: LD_VAR 0 14
119206: PPUSH
119207: LD_INT 3
119209: PUSH
119210: LD_INT 92
119212: PUSH
119213: LD_VAR 0 17
119217: PUSH
119218: LD_INT 1
119220: ARRAY
119221: PUSH
119222: LD_VAR 0 17
119226: PUSH
119227: LD_INT 2
119229: ARRAY
119230: PUSH
119231: LD_VAR 0 17
119235: PUSH
119236: LD_INT 3
119238: ARRAY
119239: PUSH
119240: EMPTY
119241: LIST
119242: LIST
119243: LIST
119244: LIST
119245: PUSH
119246: EMPTY
119247: LIST
119248: LIST
119249: PPUSH
119250: CALL_OW 72
119254: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119255: LD_VAR 0 14
119259: PUSH
119260: LD_VAR 0 15
119264: DIFF
119265: IFFALSE 119283
// tmp := tmp diff tmp2 ;
119267: LD_ADDR_VAR 0 14
119271: PUSH
119272: LD_VAR 0 14
119276: PUSH
119277: LD_VAR 0 15
119281: DIFF
119282: ST_TO_ADDR
// end ; if not f_murder then
119283: LD_VAR 0 20
119287: NOT
119288: IFFALSE 119346
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
119290: LD_ADDR_VAR 0 15
119294: PUSH
119295: LD_VAR 0 14
119299: PPUSH
119300: LD_INT 3
119302: PUSH
119303: LD_INT 50
119305: PUSH
119306: EMPTY
119307: LIST
119308: PUSH
119309: EMPTY
119310: LIST
119311: LIST
119312: PPUSH
119313: CALL_OW 72
119317: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119318: LD_VAR 0 14
119322: PUSH
119323: LD_VAR 0 15
119327: DIFF
119328: IFFALSE 119346
// tmp := tmp diff tmp2 ;
119330: LD_ADDR_VAR 0 14
119334: PUSH
119335: LD_VAR 0 14
119339: PUSH
119340: LD_VAR 0 15
119344: DIFF
119345: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
119346: LD_ADDR_VAR 0 14
119350: PUSH
119351: LD_VAR 0 4
119355: PUSH
119356: LD_VAR 0 7
119360: ARRAY
119361: PPUSH
119362: LD_VAR 0 14
119366: PPUSH
119367: LD_INT 1
119369: PPUSH
119370: LD_INT 1
119372: PPUSH
119373: CALL 25532 0 4
119377: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
119378: LD_VAR 0 4
119382: PUSH
119383: LD_VAR 0 7
119387: ARRAY
119388: PPUSH
119389: CALL_OW 257
119393: PUSH
119394: LD_INT 1
119396: EQUAL
119397: IFFALSE 119857
// begin if WantPlant ( group [ i ] ) then
119399: LD_VAR 0 4
119403: PUSH
119404: LD_VAR 0 7
119408: ARRAY
119409: PPUSH
119410: CALL 25033 0 1
119414: IFFALSE 119418
// continue ;
119416: GO 117670
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
119418: LD_VAR 0 18
119422: IFFALSE 119442
119424: PUSH
119425: LD_VAR 0 4
119429: PUSH
119430: LD_VAR 0 7
119434: ARRAY
119435: PPUSH
119436: CALL_OW 310
119440: NOT
119441: AND
119442: IFFALSE 119485
119444: PUSH
119445: LD_VAR 0 14
119449: PUSH
119450: LD_INT 1
119452: ARRAY
119453: PUSH
119454: LD_VAR 0 14
119458: PPUSH
119459: LD_INT 21
119461: PUSH
119462: LD_INT 2
119464: PUSH
119465: EMPTY
119466: LIST
119467: LIST
119468: PUSH
119469: LD_INT 58
119471: PUSH
119472: EMPTY
119473: LIST
119474: PUSH
119475: EMPTY
119476: LIST
119477: LIST
119478: PPUSH
119479: CALL_OW 72
119483: IN
119484: AND
119485: IFFALSE 119521
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
119487: LD_VAR 0 4
119491: PUSH
119492: LD_VAR 0 7
119496: ARRAY
119497: PPUSH
119498: LD_VAR 0 14
119502: PUSH
119503: LD_INT 1
119505: ARRAY
119506: PPUSH
119507: CALL_OW 120
// attacking := true ;
119511: LD_ADDR_VAR 0 29
119515: PUSH
119516: LD_INT 1
119518: ST_TO_ADDR
// continue ;
119519: GO 117670
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
119521: LD_VAR 0 26
119525: IFFALSE 119548
119527: PUSH
119528: LD_VAR 0 4
119532: PUSH
119533: LD_VAR 0 7
119537: ARRAY
119538: PPUSH
119539: CALL_OW 257
119543: PUSH
119544: LD_INT 1
119546: EQUAL
119547: AND
119548: IFFALSE 119571
119550: PUSH
119551: LD_VAR 0 4
119555: PUSH
119556: LD_VAR 0 7
119560: ARRAY
119561: PPUSH
119562: CALL_OW 256
119566: PUSH
119567: LD_INT 800
119569: LESS
119570: AND
119571: IFFALSE 119591
119573: PUSH
119574: LD_VAR 0 4
119578: PUSH
119579: LD_VAR 0 7
119583: ARRAY
119584: PPUSH
119585: CALL_OW 318
119589: NOT
119590: AND
119591: IFFALSE 119608
// ComCrawl ( group [ i ] ) ;
119593: LD_VAR 0 4
119597: PUSH
119598: LD_VAR 0 7
119602: ARRAY
119603: PPUSH
119604: CALL_OW 137
// if f_mines then
119608: LD_VAR 0 21
119612: IFFALSE 119857
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
119614: LD_VAR 0 14
119618: PUSH
119619: LD_INT 1
119621: ARRAY
119622: PPUSH
119623: CALL_OW 247
119627: PUSH
119628: LD_INT 3
119630: EQUAL
119631: IFFALSE 119650
119633: PUSH
119634: LD_VAR 0 14
119638: PUSH
119639: LD_INT 1
119641: ARRAY
119642: PUSH
119643: LD_VAR 0 27
119647: IN
119648: NOT
119649: AND
119650: IFFALSE 119857
// begin x := GetX ( tmp [ 1 ] ) ;
119652: LD_ADDR_VAR 0 10
119656: PUSH
119657: LD_VAR 0 14
119661: PUSH
119662: LD_INT 1
119664: ARRAY
119665: PPUSH
119666: CALL_OW 250
119670: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
119671: LD_ADDR_VAR 0 11
119675: PUSH
119676: LD_VAR 0 14
119680: PUSH
119681: LD_INT 1
119683: ARRAY
119684: PPUSH
119685: CALL_OW 251
119689: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
119690: LD_ADDR_VAR 0 12
119694: PUSH
119695: LD_VAR 0 4
119699: PUSH
119700: LD_VAR 0 7
119704: ARRAY
119705: PPUSH
119706: CALL 53195 0 1
119710: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
119711: LD_VAR 0 4
119715: PUSH
119716: LD_VAR 0 7
119720: ARRAY
119721: PPUSH
119722: LD_VAR 0 10
119726: PPUSH
119727: LD_VAR 0 11
119731: PPUSH
119732: LD_VAR 0 14
119736: PUSH
119737: LD_INT 1
119739: ARRAY
119740: PPUSH
119741: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
119745: LD_VAR 0 4
119749: PUSH
119750: LD_VAR 0 7
119754: ARRAY
119755: PPUSH
119756: LD_VAR 0 10
119760: PPUSH
119761: LD_VAR 0 12
119765: PPUSH
119766: LD_INT 7
119768: PPUSH
119769: CALL_OW 272
119773: PPUSH
119774: LD_VAR 0 11
119778: PPUSH
119779: LD_VAR 0 12
119783: PPUSH
119784: LD_INT 7
119786: PPUSH
119787: CALL_OW 273
119791: PPUSH
119792: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
119796: LD_VAR 0 4
119800: PUSH
119801: LD_VAR 0 7
119805: ARRAY
119806: PPUSH
119807: LD_INT 71
119809: PPUSH
119810: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
119814: LD_ADDR_VAR 0 27
119818: PUSH
119819: LD_VAR 0 27
119823: PPUSH
119824: LD_VAR 0 27
119828: PUSH
119829: LD_INT 1
119831: PLUS
119832: PPUSH
119833: LD_VAR 0 14
119837: PUSH
119838: LD_INT 1
119840: ARRAY
119841: PPUSH
119842: CALL_OW 1
119846: ST_TO_ADDR
// attacking := true ;
119847: LD_ADDR_VAR 0 29
119851: PUSH
119852: LD_INT 1
119854: ST_TO_ADDR
// continue ;
119855: GO 117670
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
119857: LD_VAR 0 4
119861: PUSH
119862: LD_VAR 0 7
119866: ARRAY
119867: PPUSH
119868: CALL_OW 257
119872: PUSH
119873: LD_INT 17
119875: EQUAL
119876: IFFALSE 119900
119878: PUSH
119879: LD_VAR 0 4
119883: PUSH
119884: LD_VAR 0 7
119888: ARRAY
119889: PPUSH
119890: CALL_OW 110
119894: PUSH
119895: LD_INT 71
119897: EQUAL
119898: NOT
119899: AND
119900: IFFALSE 120046
// begin attacking := false ;
119902: LD_ADDR_VAR 0 29
119906: PUSH
119907: LD_INT 0
119909: ST_TO_ADDR
// k := 5 ;
119910: LD_ADDR_VAR 0 9
119914: PUSH
119915: LD_INT 5
119917: ST_TO_ADDR
// if tmp < k then
119918: LD_VAR 0 14
119922: PUSH
119923: LD_VAR 0 9
119927: LESS
119928: IFFALSE 119940
// k := tmp ;
119930: LD_ADDR_VAR 0 9
119934: PUSH
119935: LD_VAR 0 14
119939: ST_TO_ADDR
// for j = 1 to k do
119940: LD_ADDR_VAR 0 8
119944: PUSH
119945: DOUBLE
119946: LD_INT 1
119948: DEC
119949: ST_TO_ADDR
119950: LD_VAR 0 9
119954: PUSH
119955: FOR_TO
119956: IFFALSE 120044
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
119958: LD_VAR 0 14
119962: PUSH
119963: LD_VAR 0 8
119967: ARRAY
119968: PUSH
119969: LD_VAR 0 14
119973: PPUSH
119974: LD_INT 58
119976: PUSH
119977: EMPTY
119978: LIST
119979: PPUSH
119980: CALL_OW 72
119984: IN
119985: NOT
119986: IFFALSE 120042
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119988: LD_VAR 0 4
119992: PUSH
119993: LD_VAR 0 7
119997: ARRAY
119998: PPUSH
119999: LD_VAR 0 14
120003: PUSH
120004: LD_VAR 0 8
120008: ARRAY
120009: PPUSH
120010: CALL_OW 115
// attacking := true ;
120014: LD_ADDR_VAR 0 29
120018: PUSH
120019: LD_INT 1
120021: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
120022: LD_VAR 0 4
120026: PUSH
120027: LD_VAR 0 7
120031: ARRAY
120032: PPUSH
120033: LD_INT 71
120035: PPUSH
120036: CALL_OW 109
// continue ;
120040: GO 119955
// end ; end ;
120042: GO 119955
120044: POP
120045: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
120046: LD_VAR 0 4
120050: PUSH
120051: LD_VAR 0 7
120055: ARRAY
120056: PPUSH
120057: CALL_OW 257
120061: PUSH
120062: LD_INT 8
120064: EQUAL
120065: IFTRUE 120103
120067: PUSH
120068: LD_VAR 0 4
120072: PUSH
120073: LD_VAR 0 7
120077: ARRAY
120078: PPUSH
120079: CALL_OW 264
120083: PUSH
120084: LD_INT 28
120086: PUSH
120087: LD_INT 45
120089: PUSH
120090: LD_INT 7
120092: PUSH
120093: LD_INT 47
120095: PUSH
120096: EMPTY
120097: LIST
120098: LIST
120099: LIST
120100: LIST
120101: IN
120102: OR
120103: IFFALSE 120359
// begin attacking := false ;
120105: LD_ADDR_VAR 0 29
120109: PUSH
120110: LD_INT 0
120112: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
120113: LD_VAR 0 14
120117: PUSH
120118: LD_INT 1
120120: ARRAY
120121: PPUSH
120122: CALL_OW 266
120126: PUSH
120127: LD_INT 32
120129: PUSH
120130: LD_INT 31
120132: PUSH
120133: LD_INT 33
120135: PUSH
120136: LD_INT 4
120138: PUSH
120139: LD_INT 5
120141: PUSH
120142: EMPTY
120143: LIST
120144: LIST
120145: LIST
120146: LIST
120147: LIST
120148: IN
120149: IFFALSE 120335
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
120151: LD_ADDR_VAR 0 9
120155: PUSH
120156: LD_VAR 0 14
120160: PUSH
120161: LD_INT 1
120163: ARRAY
120164: PPUSH
120165: CALL_OW 266
120169: PPUSH
120170: LD_VAR 0 14
120174: PUSH
120175: LD_INT 1
120177: ARRAY
120178: PPUSH
120179: CALL_OW 250
120183: PPUSH
120184: LD_VAR 0 14
120188: PUSH
120189: LD_INT 1
120191: ARRAY
120192: PPUSH
120193: CALL_OW 251
120197: PPUSH
120198: LD_VAR 0 14
120202: PUSH
120203: LD_INT 1
120205: ARRAY
120206: PPUSH
120207: CALL_OW 254
120211: PPUSH
120212: LD_VAR 0 14
120216: PUSH
120217: LD_INT 1
120219: ARRAY
120220: PPUSH
120221: CALL_OW 248
120225: PPUSH
120226: LD_INT 0
120228: PPUSH
120229: CALL 34553 0 6
120233: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
120234: LD_ADDR_VAR 0 8
120238: PUSH
120239: LD_VAR 0 4
120243: PUSH
120244: LD_VAR 0 7
120248: ARRAY
120249: PPUSH
120250: LD_VAR 0 9
120254: PPUSH
120255: CALL 53308 0 2
120259: ST_TO_ADDR
// if j then
120260: LD_VAR 0 8
120264: IFFALSE 120333
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
120266: LD_VAR 0 8
120270: PUSH
120271: LD_INT 1
120273: ARRAY
120274: PPUSH
120275: LD_VAR 0 8
120279: PUSH
120280: LD_INT 2
120282: ARRAY
120283: PPUSH
120284: CALL_OW 488
120288: IFFALSE 120333
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
120290: LD_VAR 0 4
120294: PUSH
120295: LD_VAR 0 7
120299: ARRAY
120300: PPUSH
120301: LD_VAR 0 8
120305: PUSH
120306: LD_INT 1
120308: ARRAY
120309: PPUSH
120310: LD_VAR 0 8
120314: PUSH
120315: LD_INT 2
120317: ARRAY
120318: PPUSH
120319: CALL_OW 116
// attacking := true ;
120323: LD_ADDR_VAR 0 29
120327: PUSH
120328: LD_INT 1
120330: ST_TO_ADDR
// continue ;
120331: GO 117670
// end ; end else
120333: GO 120359
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120335: LD_VAR 0 4
120339: PUSH
120340: LD_VAR 0 7
120344: ARRAY
120345: PPUSH
120346: LD_VAR 0 14
120350: PUSH
120351: LD_INT 1
120353: ARRAY
120354: PPUSH
120355: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
120359: LD_VAR 0 4
120363: PUSH
120364: LD_VAR 0 7
120368: ARRAY
120369: PPUSH
120370: CALL_OW 265
120374: PUSH
120375: LD_INT 11
120377: EQUAL
120378: IFFALSE 120656
// begin k := 10 ;
120380: LD_ADDR_VAR 0 9
120384: PUSH
120385: LD_INT 10
120387: ST_TO_ADDR
// x := 0 ;
120388: LD_ADDR_VAR 0 10
120392: PUSH
120393: LD_INT 0
120395: ST_TO_ADDR
// if tmp < k then
120396: LD_VAR 0 14
120400: PUSH
120401: LD_VAR 0 9
120405: LESS
120406: IFFALSE 120418
// k := tmp ;
120408: LD_ADDR_VAR 0 9
120412: PUSH
120413: LD_VAR 0 14
120417: ST_TO_ADDR
// for j = k downto 1 do
120418: LD_ADDR_VAR 0 8
120422: PUSH
120423: DOUBLE
120424: LD_VAR 0 9
120428: INC
120429: ST_TO_ADDR
120430: LD_INT 1
120432: PUSH
120433: FOR_DOWNTO
120434: IFFALSE 120509
// begin if GetType ( tmp [ j ] ) = unit_human then
120436: LD_VAR 0 14
120440: PUSH
120441: LD_VAR 0 8
120445: ARRAY
120446: PPUSH
120447: CALL_OW 247
120451: PUSH
120452: LD_INT 1
120454: EQUAL
120455: IFFALSE 120507
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
120457: LD_VAR 0 4
120461: PUSH
120462: LD_VAR 0 7
120466: ARRAY
120467: PPUSH
120468: LD_VAR 0 14
120472: PUSH
120473: LD_VAR 0 8
120477: ARRAY
120478: PPUSH
120479: CALL 53566 0 2
// x := tmp [ j ] ;
120483: LD_ADDR_VAR 0 10
120487: PUSH
120488: LD_VAR 0 14
120492: PUSH
120493: LD_VAR 0 8
120497: ARRAY
120498: ST_TO_ADDR
// attacking := true ;
120499: LD_ADDR_VAR 0 29
120503: PUSH
120504: LD_INT 1
120506: ST_TO_ADDR
// end ; end ;
120507: GO 120433
120509: POP
120510: POP
// if not x then
120511: LD_VAR 0 10
120515: NOT
120516: IFFALSE 120656
// begin attacking := true ;
120518: LD_ADDR_VAR 0 29
120522: PUSH
120523: LD_INT 1
120525: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
120526: LD_VAR 0 4
120530: PUSH
120531: LD_VAR 0 7
120535: ARRAY
120536: PPUSH
120537: CALL_OW 250
120541: PPUSH
120542: LD_VAR 0 4
120546: PUSH
120547: LD_VAR 0 7
120551: ARRAY
120552: PPUSH
120553: CALL_OW 251
120557: PPUSH
120558: CALL_OW 546
120562: PUSH
120563: LD_INT 2
120565: ARRAY
120566: PUSH
120567: LD_VAR 0 14
120571: PUSH
120572: LD_INT 1
120574: ARRAY
120575: PPUSH
120576: CALL_OW 250
120580: PPUSH
120581: LD_VAR 0 14
120585: PUSH
120586: LD_INT 1
120588: ARRAY
120589: PPUSH
120590: CALL_OW 251
120594: PPUSH
120595: CALL_OW 546
120599: PUSH
120600: LD_INT 2
120602: ARRAY
120603: EQUAL
120604: IFFALSE 120632
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
120606: LD_VAR 0 4
120610: PUSH
120611: LD_VAR 0 7
120615: ARRAY
120616: PPUSH
120617: LD_VAR 0 14
120621: PUSH
120622: LD_INT 1
120624: ARRAY
120625: PPUSH
120626: CALL 53566 0 2
120630: GO 120656
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120632: LD_VAR 0 4
120636: PUSH
120637: LD_VAR 0 7
120641: ARRAY
120642: PPUSH
120643: LD_VAR 0 14
120647: PUSH
120648: LD_INT 1
120650: ARRAY
120651: PPUSH
120652: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
120656: LD_VAR 0 4
120660: PUSH
120661: LD_VAR 0 7
120665: ARRAY
120666: PPUSH
120667: CALL_OW 264
120671: PUSH
120672: LD_INT 29
120674: EQUAL
120675: IFFALSE 121045
// begin if WantsToAttack ( group [ i ] ) in bombed then
120677: LD_VAR 0 4
120681: PUSH
120682: LD_VAR 0 7
120686: ARRAY
120687: PPUSH
120688: CALL_OW 319
120692: PUSH
120693: LD_VAR 0 28
120697: IN
120698: IFFALSE 120702
// continue ;
120700: GO 117670
// k := 8 ;
120702: LD_ADDR_VAR 0 9
120706: PUSH
120707: LD_INT 8
120709: ST_TO_ADDR
// x := 0 ;
120710: LD_ADDR_VAR 0 10
120714: PUSH
120715: LD_INT 0
120717: ST_TO_ADDR
// if tmp < k then
120718: LD_VAR 0 14
120722: PUSH
120723: LD_VAR 0 9
120727: LESS
120728: IFFALSE 120740
// k := tmp ;
120730: LD_ADDR_VAR 0 9
120734: PUSH
120735: LD_VAR 0 14
120739: ST_TO_ADDR
// for j = 1 to k do
120740: LD_ADDR_VAR 0 8
120744: PUSH
120745: DOUBLE
120746: LD_INT 1
120748: DEC
120749: ST_TO_ADDR
120750: LD_VAR 0 9
120754: PUSH
120755: FOR_TO
120756: IFFALSE 120890
// begin if GetType ( tmp [ j ] ) = unit_building then
120758: LD_VAR 0 14
120762: PUSH
120763: LD_VAR 0 8
120767: ARRAY
120768: PPUSH
120769: CALL_OW 247
120773: PUSH
120774: LD_INT 3
120776: EQUAL
120777: IFFALSE 120888
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
120779: LD_VAR 0 14
120783: PUSH
120784: LD_VAR 0 8
120788: ARRAY
120789: PUSH
120790: LD_VAR 0 28
120794: IN
120795: NOT
120796: IFFALSE 120815
120798: PUSH
120799: LD_VAR 0 14
120803: PUSH
120804: LD_VAR 0 8
120808: ARRAY
120809: PPUSH
120810: CALL_OW 313
120814: AND
120815: IFFALSE 120888
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120817: LD_VAR 0 4
120821: PUSH
120822: LD_VAR 0 7
120826: ARRAY
120827: PPUSH
120828: LD_VAR 0 14
120832: PUSH
120833: LD_VAR 0 8
120837: ARRAY
120838: PPUSH
120839: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
120843: LD_ADDR_VAR 0 28
120847: PUSH
120848: LD_VAR 0 28
120852: PPUSH
120853: LD_VAR 0 28
120857: PUSH
120858: LD_INT 1
120860: PLUS
120861: PPUSH
120862: LD_VAR 0 14
120866: PUSH
120867: LD_VAR 0 8
120871: ARRAY
120872: PPUSH
120873: CALL_OW 1
120877: ST_TO_ADDR
// attacking := true ;
120878: LD_ADDR_VAR 0 29
120882: PUSH
120883: LD_INT 1
120885: ST_TO_ADDR
// break ;
120886: GO 120890
// end ; end ;
120888: GO 120755
120890: POP
120891: POP
// if not attacking and f_attack_depot then
120892: LD_VAR 0 29
120896: NOT
120897: IFFALSE 120905
120899: PUSH
120900: LD_VAR 0 25
120904: AND
120905: IFFALSE 121000
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120907: LD_ADDR_VAR 0 13
120911: PUSH
120912: LD_VAR 0 14
120916: PPUSH
120917: LD_INT 2
120919: PUSH
120920: LD_INT 30
120922: PUSH
120923: LD_INT 0
120925: PUSH
120926: EMPTY
120927: LIST
120928: LIST
120929: PUSH
120930: LD_INT 30
120932: PUSH
120933: LD_INT 1
120935: PUSH
120936: EMPTY
120937: LIST
120938: LIST
120939: PUSH
120940: EMPTY
120941: LIST
120942: LIST
120943: LIST
120944: PPUSH
120945: CALL_OW 72
120949: ST_TO_ADDR
// if z then
120950: LD_VAR 0 13
120954: IFFALSE 121000
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
120956: LD_VAR 0 4
120960: PUSH
120961: LD_VAR 0 7
120965: ARRAY
120966: PPUSH
120967: LD_VAR 0 13
120971: PPUSH
120972: LD_VAR 0 4
120976: PUSH
120977: LD_VAR 0 7
120981: ARRAY
120982: PPUSH
120983: CALL_OW 74
120987: PPUSH
120988: CALL_OW 115
// attacking := true ;
120992: LD_ADDR_VAR 0 29
120996: PUSH
120997: LD_INT 1
120999: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
121000: LD_VAR 0 4
121004: PUSH
121005: LD_VAR 0 7
121009: ARRAY
121010: PPUSH
121011: CALL_OW 256
121015: PUSH
121016: LD_INT 500
121018: LESS
121019: IFFALSE 121045
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121021: LD_VAR 0 4
121025: PUSH
121026: LD_VAR 0 7
121030: ARRAY
121031: PPUSH
121032: LD_VAR 0 14
121036: PUSH
121037: LD_INT 1
121039: ARRAY
121040: PPUSH
121041: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
121045: LD_VAR 0 4
121049: PUSH
121050: LD_VAR 0 7
121054: ARRAY
121055: PPUSH
121056: CALL_OW 264
121060: PUSH
121061: LD_INT 49
121063: EQUAL
121064: IFFALSE 121185
// begin if not HasTask ( group [ i ] ) then
121066: LD_VAR 0 4
121070: PUSH
121071: LD_VAR 0 7
121075: ARRAY
121076: PPUSH
121077: CALL_OW 314
121081: NOT
121082: IFFALSE 121185
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
121084: LD_ADDR_VAR 0 9
121088: PUSH
121089: LD_INT 81
121091: PUSH
121092: LD_VAR 0 4
121096: PUSH
121097: LD_VAR 0 7
121101: ARRAY
121102: PPUSH
121103: CALL_OW 255
121107: PUSH
121108: EMPTY
121109: LIST
121110: LIST
121111: PPUSH
121112: CALL_OW 69
121116: PPUSH
121117: LD_VAR 0 4
121121: PUSH
121122: LD_VAR 0 7
121126: ARRAY
121127: PPUSH
121128: CALL_OW 74
121132: ST_TO_ADDR
// if k then
121133: LD_VAR 0 9
121137: IFFALSE 121185
// if GetDistUnits ( group [ i ] , k ) > 10 then
121139: LD_VAR 0 4
121143: PUSH
121144: LD_VAR 0 7
121148: ARRAY
121149: PPUSH
121150: LD_VAR 0 9
121154: PPUSH
121155: CALL_OW 296
121159: PUSH
121160: LD_INT 10
121162: GREATER
121163: IFFALSE 121185
// ComMoveUnit ( group [ i ] , k ) ;
121165: LD_VAR 0 4
121169: PUSH
121170: LD_VAR 0 7
121174: ARRAY
121175: PPUSH
121176: LD_VAR 0 9
121180: PPUSH
121181: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
121185: LD_VAR 0 4
121189: PUSH
121190: LD_VAR 0 7
121194: ARRAY
121195: PPUSH
121196: CALL_OW 256
121200: PUSH
121201: LD_INT 250
121203: LESS
121204: IFFALSE 121248
121206: PUSH
121207: LD_VAR 0 4
121211: PUSH
121212: LD_VAR 0 7
121216: ARRAY
121217: PUSH
121218: LD_INT 21
121220: PUSH
121221: LD_INT 2
121223: PUSH
121224: EMPTY
121225: LIST
121226: LIST
121227: PUSH
121228: LD_INT 23
121230: PUSH
121231: LD_INT 2
121233: PUSH
121234: EMPTY
121235: LIST
121236: LIST
121237: PUSH
121238: EMPTY
121239: LIST
121240: LIST
121241: PPUSH
121242: CALL_OW 69
121246: IN
121247: AND
121248: IFFALSE 121375
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
121250: LD_ADDR_VAR 0 9
121254: PUSH
121255: LD_OWVAR 3
121259: PUSH
121260: LD_VAR 0 4
121264: PUSH
121265: LD_VAR 0 7
121269: ARRAY
121270: DIFF
121271: PPUSH
121272: LD_VAR 0 4
121276: PUSH
121277: LD_VAR 0 7
121281: ARRAY
121282: PPUSH
121283: CALL_OW 74
121287: ST_TO_ADDR
// if not k then
121288: LD_VAR 0 9
121292: NOT
121293: IFFALSE 121297
// continue ;
121295: GO 117670
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
121297: LD_VAR 0 9
121301: PUSH
121302: LD_INT 81
121304: PUSH
121305: LD_VAR 0 4
121309: PUSH
121310: LD_VAR 0 7
121314: ARRAY
121315: PPUSH
121316: CALL_OW 255
121320: PUSH
121321: EMPTY
121322: LIST
121323: LIST
121324: PPUSH
121325: CALL_OW 69
121329: IN
121330: IFFALSE 121358
121332: PUSH
121333: LD_VAR 0 9
121337: PPUSH
121338: LD_VAR 0 4
121342: PUSH
121343: LD_VAR 0 7
121347: ARRAY
121348: PPUSH
121349: CALL_OW 296
121353: PUSH
121354: LD_INT 5
121356: LESS
121357: AND
121358: IFFALSE 121375
// ComAutodestruct ( group [ i ] ) ;
121360: LD_VAR 0 4
121364: PUSH
121365: LD_VAR 0 7
121369: ARRAY
121370: PPUSH
121371: CALL 53462 0 1
// end ; if f_attack_depot then
121375: LD_VAR 0 25
121379: IFFALSE 121491
// begin k := 6 ;
121381: LD_ADDR_VAR 0 9
121385: PUSH
121386: LD_INT 6
121388: ST_TO_ADDR
// if tmp < k then
121389: LD_VAR 0 14
121393: PUSH
121394: LD_VAR 0 9
121398: LESS
121399: IFFALSE 121411
// k := tmp ;
121401: LD_ADDR_VAR 0 9
121405: PUSH
121406: LD_VAR 0 14
121410: ST_TO_ADDR
// for j = 1 to k do
121411: LD_ADDR_VAR 0 8
121415: PUSH
121416: DOUBLE
121417: LD_INT 1
121419: DEC
121420: ST_TO_ADDR
121421: LD_VAR 0 9
121425: PUSH
121426: FOR_TO
121427: IFFALSE 121489
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
121429: LD_VAR 0 8
121433: PPUSH
121434: CALL_OW 266
121438: PUSH
121439: LD_INT 0
121441: PUSH
121442: LD_INT 1
121444: PUSH
121445: EMPTY
121446: LIST
121447: LIST
121448: IN
121449: IFFALSE 121487
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121451: LD_VAR 0 4
121455: PUSH
121456: LD_VAR 0 7
121460: ARRAY
121461: PPUSH
121462: LD_VAR 0 14
121466: PUSH
121467: LD_VAR 0 8
121471: ARRAY
121472: PPUSH
121473: CALL_OW 115
// attacking := true ;
121477: LD_ADDR_VAR 0 29
121481: PUSH
121482: LD_INT 1
121484: ST_TO_ADDR
// break ;
121485: GO 121489
// end ;
121487: GO 121426
121489: POP
121490: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
121491: LD_VAR 0 4
121495: PUSH
121496: LD_VAR 0 7
121500: ARRAY
121501: PPUSH
121502: CALL_OW 302
121506: IFFALSE 121515
121508: PUSH
121509: LD_VAR 0 29
121513: NOT
121514: AND
121515: IFFALSE 121845
// begin if GetTag ( group [ i ] ) = 71 then
121517: LD_VAR 0 4
121521: PUSH
121522: LD_VAR 0 7
121526: ARRAY
121527: PPUSH
121528: CALL_OW 110
121532: PUSH
121533: LD_INT 71
121535: EQUAL
121536: IFFALSE 121577
// begin if HasTask ( group [ i ] ) then
121538: LD_VAR 0 4
121542: PUSH
121543: LD_VAR 0 7
121547: ARRAY
121548: PPUSH
121549: CALL_OW 314
121553: IFFALSE 121559
// continue else
121555: GO 117670
121557: GO 121577
// SetTag ( group [ i ] , 0 ) ;
121559: LD_VAR 0 4
121563: PUSH
121564: LD_VAR 0 7
121568: ARRAY
121569: PPUSH
121570: LD_INT 0
121572: PPUSH
121573: CALL_OW 109
// end ; k := 8 ;
121577: LD_ADDR_VAR 0 9
121581: PUSH
121582: LD_INT 8
121584: ST_TO_ADDR
// x := 0 ;
121585: LD_ADDR_VAR 0 10
121589: PUSH
121590: LD_INT 0
121592: ST_TO_ADDR
// if tmp < k then
121593: LD_VAR 0 14
121597: PUSH
121598: LD_VAR 0 9
121602: LESS
121603: IFFALSE 121615
// k := tmp ;
121605: LD_ADDR_VAR 0 9
121609: PUSH
121610: LD_VAR 0 14
121614: ST_TO_ADDR
// for j = 1 to k do
121615: LD_ADDR_VAR 0 8
121619: PUSH
121620: DOUBLE
121621: LD_INT 1
121623: DEC
121624: ST_TO_ADDR
121625: LD_VAR 0 9
121629: PUSH
121630: FOR_TO
121631: IFFALSE 121737
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
121633: LD_VAR 0 14
121637: PUSH
121638: LD_VAR 0 8
121642: ARRAY
121643: PPUSH
121644: CALL_OW 247
121648: PUSH
121649: LD_INT 1
121651: EQUAL
121652: IFFALSE 121715
121654: PUSH
121655: LD_VAR 0 14
121659: PUSH
121660: LD_VAR 0 8
121664: ARRAY
121665: PPUSH
121666: CALL_OW 256
121670: PUSH
121671: LD_INT 250
121673: LESS
121674: IFFALSE 121682
121676: PUSH
121677: LD_VAR 0 20
121681: AND
121682: IFTRUE 121714
121684: PUSH
121685: LD_VAR 0 20
121689: NOT
121690: IFFALSE 121713
121692: PUSH
121693: LD_VAR 0 14
121697: PUSH
121698: LD_VAR 0 8
121702: ARRAY
121703: PPUSH
121704: CALL_OW 256
121708: PUSH
121709: LD_INT 250
121711: GREATEREQUAL
121712: AND
121713: OR
121714: AND
121715: IFFALSE 121735
// begin x := tmp [ j ] ;
121717: LD_ADDR_VAR 0 10
121721: PUSH
121722: LD_VAR 0 14
121726: PUSH
121727: LD_VAR 0 8
121731: ARRAY
121732: ST_TO_ADDR
// break ;
121733: GO 121737
// end ;
121735: GO 121630
121737: POP
121738: POP
// if x then
121739: LD_VAR 0 10
121743: IFFALSE 121767
// ComAttackUnit ( group [ i ] , x ) else
121745: LD_VAR 0 4
121749: PUSH
121750: LD_VAR 0 7
121754: ARRAY
121755: PPUSH
121756: LD_VAR 0 10
121760: PPUSH
121761: CALL_OW 115
121765: GO 121791
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121767: LD_VAR 0 4
121771: PUSH
121772: LD_VAR 0 7
121776: ARRAY
121777: PPUSH
121778: LD_VAR 0 14
121782: PUSH
121783: LD_INT 1
121785: ARRAY
121786: PPUSH
121787: CALL_OW 115
// if not HasTask ( group [ i ] ) then
121791: LD_VAR 0 4
121795: PUSH
121796: LD_VAR 0 7
121800: ARRAY
121801: PPUSH
121802: CALL_OW 314
121806: NOT
121807: IFFALSE 121845
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
121809: LD_VAR 0 4
121813: PUSH
121814: LD_VAR 0 7
121818: ARRAY
121819: PPUSH
121820: LD_VAR 0 14
121824: PPUSH
121825: LD_VAR 0 4
121829: PUSH
121830: LD_VAR 0 7
121834: ARRAY
121835: PPUSH
121836: CALL_OW 74
121840: PPUSH
121841: CALL_OW 115
// end ; end ; end ;
121845: GO 117670
121847: POP
121848: POP
// wait ( 0 0$2 ) ;
121849: LD_INT 70
121851: PPUSH
121852: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
121856: LD_VAR 0 4
121860: NOT
121861: IFTRUE 121872
121863: PUSH
121864: LD_VAR 0 4
121868: PUSH
121869: EMPTY
121870: EQUAL
121871: OR
121872: IFTRUE 121893
121874: PUSH
121875: LD_INT 81
121877: PUSH
121878: LD_VAR 0 35
121882: PUSH
121883: EMPTY
121884: LIST
121885: LIST
121886: PPUSH
121887: CALL_OW 69
121891: NOT
121892: OR
121893: IFFALSE 117655
// end ;
121895: LD_VAR 0 2
121899: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
121900: LD_INT 0
121902: PPUSH
121903: PPUSH
121904: PPUSH
121905: PPUSH
121906: PPUSH
121907: PPUSH
// if not base or not mc_bases [ base ] or not solds then
121908: LD_VAR 0 1
121912: NOT
121913: IFTRUE 121928
121915: PUSH
121916: LD_EXP 31
121920: PUSH
121921: LD_VAR 0 1
121925: ARRAY
121926: NOT
121927: OR
121928: IFTRUE 121937
121930: PUSH
121931: LD_VAR 0 2
121935: NOT
121936: OR
121937: IFFALSE 121941
// exit ;
121939: GO 122499
// side := mc_sides [ base ] ;
121941: LD_ADDR_VAR 0 6
121945: PUSH
121946: LD_EXP 57
121950: PUSH
121951: LD_VAR 0 1
121955: ARRAY
121956: ST_TO_ADDR
// if not side then
121957: LD_VAR 0 6
121961: NOT
121962: IFFALSE 121966
// exit ;
121964: GO 122499
// for i in solds do
121966: LD_ADDR_VAR 0 7
121970: PUSH
121971: LD_VAR 0 2
121975: PUSH
121976: FOR_IN
121977: IFFALSE 122038
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
121979: LD_VAR 0 7
121983: PPUSH
121984: CALL_OW 310
121988: PPUSH
121989: CALL_OW 266
121993: PUSH
121994: LD_INT 32
121996: PUSH
121997: LD_INT 31
121999: PUSH
122000: EMPTY
122001: LIST
122002: LIST
122003: IN
122004: IFFALSE 122024
// solds := solds diff i else
122006: LD_ADDR_VAR 0 2
122010: PUSH
122011: LD_VAR 0 2
122015: PUSH
122016: LD_VAR 0 7
122020: DIFF
122021: ST_TO_ADDR
122022: GO 122036
// SetTag ( i , 18 ) ;
122024: LD_VAR 0 7
122028: PPUSH
122029: LD_INT 18
122031: PPUSH
122032: CALL_OW 109
122036: GO 121976
122038: POP
122039: POP
// if not solds then
122040: LD_VAR 0 2
122044: NOT
122045: IFFALSE 122049
// exit ;
122047: GO 122499
// repeat wait ( 0 0$2 ) ;
122049: LD_INT 70
122051: PPUSH
122052: CALL_OW 67
// enemy := mc_scan [ base ] ;
122056: LD_ADDR_VAR 0 4
122060: PUSH
122061: LD_EXP 54
122065: PUSH
122066: LD_VAR 0 1
122070: ARRAY
122071: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122072: LD_EXP 31
122076: PUSH
122077: LD_VAR 0 1
122081: ARRAY
122082: NOT
122083: IFTRUE 122100
122085: PUSH
122086: LD_EXP 31
122090: PUSH
122091: LD_VAR 0 1
122095: ARRAY
122096: PUSH
122097: EMPTY
122098: EQUAL
122099: OR
122100: IFFALSE 122137
// begin for i in solds do
122102: LD_ADDR_VAR 0 7
122106: PUSH
122107: LD_VAR 0 2
122111: PUSH
122112: FOR_IN
122113: IFFALSE 122126
// ComStop ( i ) ;
122115: LD_VAR 0 7
122119: PPUSH
122120: CALL_OW 141
122124: GO 122112
122126: POP
122127: POP
// solds := [ ] ;
122128: LD_ADDR_VAR 0 2
122132: PUSH
122133: EMPTY
122134: ST_TO_ADDR
// exit ;
122135: GO 122499
// end ; for i in solds do
122137: LD_ADDR_VAR 0 7
122141: PUSH
122142: LD_VAR 0 2
122146: PUSH
122147: FOR_IN
122148: IFFALSE 122469
// begin if IsInUnit ( i ) then
122150: LD_VAR 0 7
122154: PPUSH
122155: CALL_OW 310
122159: IFFALSE 122170
// ComExitBuilding ( i ) ;
122161: LD_VAR 0 7
122165: PPUSH
122166: CALL_OW 122
// if GetLives ( i ) > 500 then
122170: LD_VAR 0 7
122174: PPUSH
122175: CALL_OW 256
122179: PUSH
122180: LD_INT 500
122182: GREATER
122183: IFFALSE 122236
// begin e := NearestUnitToUnit ( enemy , i ) ;
122185: LD_ADDR_VAR 0 5
122189: PUSH
122190: LD_VAR 0 4
122194: PPUSH
122195: LD_VAR 0 7
122199: PPUSH
122200: CALL_OW 74
122204: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
122205: LD_VAR 0 7
122209: PPUSH
122210: LD_VAR 0 5
122214: PPUSH
122215: CALL_OW 250
122219: PPUSH
122220: LD_VAR 0 5
122224: PPUSH
122225: CALL_OW 251
122229: PPUSH
122230: CALL_OW 114
// end else
122234: GO 122467
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
122236: LD_VAR 0 7
122240: PPUSH
122241: LD_EXP 31
122245: PUSH
122246: LD_VAR 0 1
122250: ARRAY
122251: PPUSH
122252: LD_INT 2
122254: PUSH
122255: LD_INT 30
122257: PUSH
122258: LD_INT 0
122260: PUSH
122261: EMPTY
122262: LIST
122263: LIST
122264: PUSH
122265: LD_INT 30
122267: PUSH
122268: LD_INT 1
122270: PUSH
122271: EMPTY
122272: LIST
122273: LIST
122274: PUSH
122275: LD_INT 30
122277: PUSH
122278: LD_INT 6
122280: PUSH
122281: EMPTY
122282: LIST
122283: LIST
122284: PUSH
122285: EMPTY
122286: LIST
122287: LIST
122288: LIST
122289: LIST
122290: PPUSH
122291: CALL_OW 72
122295: PPUSH
122296: LD_VAR 0 7
122300: PPUSH
122301: CALL_OW 74
122305: PPUSH
122306: CALL_OW 296
122310: PUSH
122311: LD_INT 10
122313: GREATER
122314: IFFALSE 122467
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
122316: LD_ADDR_VAR 0 8
122320: PUSH
122321: LD_EXP 31
122325: PUSH
122326: LD_VAR 0 1
122330: ARRAY
122331: PPUSH
122332: LD_INT 2
122334: PUSH
122335: LD_INT 30
122337: PUSH
122338: LD_INT 0
122340: PUSH
122341: EMPTY
122342: LIST
122343: LIST
122344: PUSH
122345: LD_INT 30
122347: PUSH
122348: LD_INT 1
122350: PUSH
122351: EMPTY
122352: LIST
122353: LIST
122354: PUSH
122355: LD_INT 30
122357: PUSH
122358: LD_INT 6
122360: PUSH
122361: EMPTY
122362: LIST
122363: LIST
122364: PUSH
122365: EMPTY
122366: LIST
122367: LIST
122368: LIST
122369: LIST
122370: PPUSH
122371: CALL_OW 72
122375: PPUSH
122376: LD_VAR 0 7
122380: PPUSH
122381: CALL_OW 74
122385: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
122386: LD_VAR 0 7
122390: PPUSH
122391: LD_VAR 0 8
122395: PPUSH
122396: CALL_OW 250
122400: PPUSH
122401: LD_INT 3
122403: PPUSH
122404: LD_INT 5
122406: PPUSH
122407: CALL_OW 272
122411: PPUSH
122412: LD_VAR 0 8
122416: PPUSH
122417: CALL_OW 251
122421: PPUSH
122422: LD_INT 3
122424: PPUSH
122425: LD_INT 5
122427: PPUSH
122428: CALL_OW 273
122432: PPUSH
122433: CALL_OW 111
// SetTag ( i , 0 ) ;
122437: LD_VAR 0 7
122441: PPUSH
122442: LD_INT 0
122444: PPUSH
122445: CALL_OW 109
// solds := solds diff i ;
122449: LD_ADDR_VAR 0 2
122453: PUSH
122454: LD_VAR 0 2
122458: PUSH
122459: LD_VAR 0 7
122463: DIFF
122464: ST_TO_ADDR
// continue ;
122465: GO 122147
// end ; end ;
122467: GO 122147
122469: POP
122470: POP
// until not solds or not enemy ;
122471: LD_VAR 0 2
122475: NOT
122476: IFTRUE 122485
122478: PUSH
122479: LD_VAR 0 4
122483: NOT
122484: OR
122485: IFFALSE 122049
// MC_Reset ( base , 18 ) ;
122487: LD_VAR 0 1
122491: PPUSH
122492: LD_INT 18
122494: PPUSH
122495: CALL 67678 0 2
// end ;
122499: LD_VAR 0 3
122503: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
122504: LD_INT 0
122506: PPUSH
122507: PPUSH
122508: PPUSH
122509: PPUSH
122510: PPUSH
122511: PPUSH
122512: PPUSH
122513: PPUSH
122514: PPUSH
122515: PPUSH
122516: PPUSH
122517: PPUSH
122518: PPUSH
122519: PPUSH
122520: PPUSH
122521: PPUSH
122522: PPUSH
122523: PPUSH
122524: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
122525: LD_ADDR_VAR 0 12
122529: PUSH
122530: LD_EXP 31
122534: PUSH
122535: LD_VAR 0 1
122539: ARRAY
122540: PPUSH
122541: LD_INT 25
122543: PUSH
122544: LD_INT 3
122546: PUSH
122547: EMPTY
122548: LIST
122549: LIST
122550: PPUSH
122551: CALL_OW 72
122555: ST_TO_ADDR
// if mc_remote_driver [ base ] then
122556: LD_EXP 71
122560: PUSH
122561: LD_VAR 0 1
122565: ARRAY
122566: IFFALSE 122590
// mechs := mechs diff mc_remote_driver [ base ] ;
122568: LD_ADDR_VAR 0 12
122572: PUSH
122573: LD_VAR 0 12
122577: PUSH
122578: LD_EXP 71
122582: PUSH
122583: LD_VAR 0 1
122587: ARRAY
122588: DIFF
122589: ST_TO_ADDR
// for i in mechs do
122590: LD_ADDR_VAR 0 4
122594: PUSH
122595: LD_VAR 0 12
122599: PUSH
122600: FOR_IN
122601: IFFALSE 122636
// if GetTag ( i ) > 0 then
122603: LD_VAR 0 4
122607: PPUSH
122608: CALL_OW 110
122612: PUSH
122613: LD_INT 0
122615: GREATER
122616: IFFALSE 122634
// mechs := mechs diff i ;
122618: LD_ADDR_VAR 0 12
122622: PUSH
122623: LD_VAR 0 12
122627: PUSH
122628: LD_VAR 0 4
122632: DIFF
122633: ST_TO_ADDR
122634: GO 122600
122636: POP
122637: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122638: LD_ADDR_VAR 0 8
122642: PUSH
122643: LD_EXP 31
122647: PUSH
122648: LD_VAR 0 1
122652: ARRAY
122653: PPUSH
122654: LD_INT 2
122656: PUSH
122657: LD_INT 25
122659: PUSH
122660: LD_INT 1
122662: PUSH
122663: EMPTY
122664: LIST
122665: LIST
122666: PUSH
122667: LD_INT 25
122669: PUSH
122670: LD_INT 5
122672: PUSH
122673: EMPTY
122674: LIST
122675: LIST
122676: PUSH
122677: LD_INT 25
122679: PUSH
122680: LD_INT 8
122682: PUSH
122683: EMPTY
122684: LIST
122685: LIST
122686: PUSH
122687: LD_INT 25
122689: PUSH
122690: LD_INT 9
122692: PUSH
122693: EMPTY
122694: LIST
122695: LIST
122696: PUSH
122697: EMPTY
122698: LIST
122699: LIST
122700: LIST
122701: LIST
122702: LIST
122703: PPUSH
122704: CALL_OW 72
122708: ST_TO_ADDR
// if not defenders and not solds then
122709: LD_VAR 0 2
122713: NOT
122714: IFFALSE 122723
122716: PUSH
122717: LD_VAR 0 8
122721: NOT
122722: AND
122723: IFFALSE 122727
// exit ;
122725: GO 124549
// depot_under_attack := false ;
122727: LD_ADDR_VAR 0 16
122731: PUSH
122732: LD_INT 0
122734: ST_TO_ADDR
// sold_defenders := [ ] ;
122735: LD_ADDR_VAR 0 17
122739: PUSH
122740: EMPTY
122741: ST_TO_ADDR
// if mechs then
122742: LD_VAR 0 12
122746: IFFALSE 122901
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
122748: LD_ADDR_VAR 0 4
122752: PUSH
122753: LD_VAR 0 2
122757: PPUSH
122758: LD_INT 21
122760: PUSH
122761: LD_INT 2
122763: PUSH
122764: EMPTY
122765: LIST
122766: LIST
122767: PPUSH
122768: CALL_OW 72
122772: PUSH
122773: FOR_IN
122774: IFFALSE 122899
// begin if GetTag ( i ) <> 20 then
122776: LD_VAR 0 4
122780: PPUSH
122781: CALL_OW 110
122785: PUSH
122786: LD_INT 20
122788: NONEQUAL
122789: IFFALSE 122803
// SetTag ( i , 20 ) ;
122791: LD_VAR 0 4
122795: PPUSH
122796: LD_INT 20
122798: PPUSH
122799: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
122803: LD_VAR 0 4
122807: PPUSH
122808: CALL_OW 263
122812: PUSH
122813: LD_INT 1
122815: EQUAL
122816: IFFALSE 122830
122818: PUSH
122819: LD_VAR 0 4
122823: PPUSH
122824: CALL_OW 311
122828: NOT
122829: AND
122830: IFFALSE 122897
// begin un := mechs [ 1 ] ;
122832: LD_ADDR_VAR 0 10
122836: PUSH
122837: LD_VAR 0 12
122841: PUSH
122842: LD_INT 1
122844: ARRAY
122845: ST_TO_ADDR
// ComExit ( un ) ;
122846: LD_VAR 0 10
122850: PPUSH
122851: CALL 58553 0 1
// AddComEnterUnit ( un , i ) ;
122855: LD_VAR 0 10
122859: PPUSH
122860: LD_VAR 0 4
122864: PPUSH
122865: CALL_OW 180
// SetTag ( un , 19 ) ;
122869: LD_VAR 0 10
122873: PPUSH
122874: LD_INT 19
122876: PPUSH
122877: CALL_OW 109
// mechs := mechs diff un ;
122881: LD_ADDR_VAR 0 12
122885: PUSH
122886: LD_VAR 0 12
122890: PUSH
122891: LD_VAR 0 10
122895: DIFF
122896: ST_TO_ADDR
// end ; end ;
122897: GO 122773
122899: POP
122900: POP
// if solds then
122901: LD_VAR 0 8
122905: IFFALSE 122964
// for i in solds do
122907: LD_ADDR_VAR 0 4
122911: PUSH
122912: LD_VAR 0 8
122916: PUSH
122917: FOR_IN
122918: IFFALSE 122962
// if not GetTag ( i ) then
122920: LD_VAR 0 4
122924: PPUSH
122925: CALL_OW 110
122929: NOT
122930: IFFALSE 122960
// begin defenders := defenders union i ;
122932: LD_ADDR_VAR 0 2
122936: PUSH
122937: LD_VAR 0 2
122941: PUSH
122942: LD_VAR 0 4
122946: UNION
122947: ST_TO_ADDR
// SetTag ( i , 18 ) ;
122948: LD_VAR 0 4
122952: PPUSH
122953: LD_INT 18
122955: PPUSH
122956: CALL_OW 109
// end ;
122960: GO 122917
122962: POP
122963: POP
// repeat wait ( 0 0$2 ) ;
122964: LD_INT 70
122966: PPUSH
122967: CALL_OW 67
// enemy := mc_scan [ base ] ;
122971: LD_ADDR_VAR 0 21
122975: PUSH
122976: LD_EXP 54
122980: PUSH
122981: LD_VAR 0 1
122985: ARRAY
122986: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122987: LD_EXP 31
122991: PUSH
122992: LD_VAR 0 1
122996: ARRAY
122997: NOT
122998: IFTRUE 123015
123000: PUSH
123001: LD_EXP 31
123005: PUSH
123006: LD_VAR 0 1
123010: ARRAY
123011: PUSH
123012: EMPTY
123013: EQUAL
123014: OR
123015: IFFALSE 123052
// begin for i in defenders do
123017: LD_ADDR_VAR 0 4
123021: PUSH
123022: LD_VAR 0 2
123026: PUSH
123027: FOR_IN
123028: IFFALSE 123041
// ComStop ( i ) ;
123030: LD_VAR 0 4
123034: PPUSH
123035: CALL_OW 141
123039: GO 123027
123041: POP
123042: POP
// defenders := [ ] ;
123043: LD_ADDR_VAR 0 2
123047: PUSH
123048: EMPTY
123049: ST_TO_ADDR
// exit ;
123050: GO 124549
// end ; for i in defenders do
123052: LD_ADDR_VAR 0 4
123056: PUSH
123057: LD_VAR 0 2
123061: PUSH
123062: FOR_IN
123063: IFFALSE 123997
// begin e := NearestUnitToUnit ( enemy , i ) ;
123065: LD_ADDR_VAR 0 13
123069: PUSH
123070: LD_VAR 0 21
123074: PPUSH
123075: LD_VAR 0 4
123079: PPUSH
123080: CALL_OW 74
123084: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123085: LD_ADDR_VAR 0 7
123089: PUSH
123090: LD_EXP 31
123094: PUSH
123095: LD_VAR 0 1
123099: ARRAY
123100: PPUSH
123101: LD_INT 2
123103: PUSH
123104: LD_INT 30
123106: PUSH
123107: LD_INT 0
123109: PUSH
123110: EMPTY
123111: LIST
123112: LIST
123113: PUSH
123114: LD_INT 30
123116: PUSH
123117: LD_INT 1
123119: PUSH
123120: EMPTY
123121: LIST
123122: LIST
123123: PUSH
123124: EMPTY
123125: LIST
123126: LIST
123127: LIST
123128: PPUSH
123129: CALL_OW 72
123133: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
123134: LD_ADDR_VAR 0 16
123138: PUSH
123139: LD_VAR 0 7
123143: NOT
123144: IFTRUE 123174
123146: PUSH
123147: LD_VAR 0 7
123151: PPUSH
123152: LD_INT 3
123154: PUSH
123155: LD_INT 24
123157: PUSH
123158: LD_INT 600
123160: PUSH
123161: EMPTY
123162: LIST
123163: LIST
123164: PUSH
123165: EMPTY
123166: LIST
123167: LIST
123168: PPUSH
123169: CALL_OW 72
123173: OR
123174: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
123175: LD_VAR 0 4
123179: PPUSH
123180: CALL_OW 247
123184: PUSH
123185: LD_INT 2
123187: DOUBLE
123188: EQUAL
123189: IFTRUE 123193
123191: GO 123609
123193: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
123194: LD_VAR 0 4
123198: PPUSH
123199: CALL_OW 256
123203: PUSH
123204: LD_INT 1000
123206: EQUAL
123207: IFFALSE 123253
123209: PUSH
123210: LD_VAR 0 4
123214: PPUSH
123215: LD_VAR 0 13
123219: PPUSH
123220: CALL_OW 296
123224: PUSH
123225: LD_INT 40
123227: LESS
123228: IFTRUE 123252
123230: PUSH
123231: LD_VAR 0 13
123235: PPUSH
123236: LD_EXP 56
123240: PUSH
123241: LD_VAR 0 1
123245: ARRAY
123246: PPUSH
123247: CALL_OW 308
123251: OR
123252: AND
123253: IFFALSE 123379
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
123255: LD_VAR 0 4
123259: PPUSH
123260: CALL_OW 262
123264: PUSH
123265: LD_INT 1
123267: EQUAL
123268: IFFALSE 123285
123270: PUSH
123271: LD_VAR 0 4
123275: PPUSH
123276: CALL_OW 261
123280: PUSH
123281: LD_INT 30
123283: LESS
123284: AND
123285: IFFALSE 123293
123287: PUSH
123288: LD_VAR 0 7
123292: AND
123293: IFFALSE 123363
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
123295: LD_VAR 0 4
123299: PPUSH
123300: LD_VAR 0 7
123304: PPUSH
123305: LD_VAR 0 4
123309: PPUSH
123310: CALL_OW 74
123314: PPUSH
123315: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
123319: LD_VAR 0 4
123323: PPUSH
123324: LD_VAR 0 7
123328: PPUSH
123329: LD_VAR 0 4
123333: PPUSH
123334: CALL_OW 74
123338: PPUSH
123339: CALL_OW 296
123343: PUSH
123344: LD_INT 6
123346: LESS
123347: IFFALSE 123361
// SetFuel ( i , 100 ) ;
123349: LD_VAR 0 4
123353: PPUSH
123354: LD_INT 100
123356: PPUSH
123357: CALL_OW 240
// end else
123361: GO 123377
// ComAttackUnit ( i , e ) ;
123363: LD_VAR 0 4
123367: PPUSH
123368: LD_VAR 0 13
123372: PPUSH
123373: CALL_OW 115
// end else
123377: GO 123486
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
123379: LD_VAR 0 13
123383: PPUSH
123384: LD_EXP 56
123388: PUSH
123389: LD_VAR 0 1
123393: ARRAY
123394: PPUSH
123395: CALL_OW 308
123399: NOT
123400: IFFALSE 123422
123402: PUSH
123403: LD_VAR 0 4
123407: PPUSH
123408: LD_VAR 0 13
123412: PPUSH
123413: CALL_OW 296
123417: PUSH
123418: LD_INT 40
123420: GREATEREQUAL
123421: AND
123422: IFTRUE 123439
123424: PUSH
123425: LD_VAR 0 4
123429: PPUSH
123430: CALL_OW 256
123434: PUSH
123435: LD_INT 650
123437: LESSEQUAL
123438: OR
123439: IFFALSE 123464
123441: PUSH
123442: LD_VAR 0 4
123446: PPUSH
123447: LD_EXP 55
123451: PUSH
123452: LD_VAR 0 1
123456: ARRAY
123457: PPUSH
123458: CALL_OW 308
123462: NOT
123463: AND
123464: IFFALSE 123486
// ComMoveToArea ( i , mc_parking [ base ] ) ;
123466: LD_VAR 0 4
123470: PPUSH
123471: LD_EXP 55
123475: PUSH
123476: LD_VAR 0 1
123480: ARRAY
123481: PPUSH
123482: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
123486: LD_VAR 0 4
123490: PPUSH
123491: CALL_OW 256
123495: PUSH
123496: LD_INT 1000
123498: LESS
123499: IFFALSE 123516
123501: PUSH
123502: LD_VAR 0 4
123506: PPUSH
123507: CALL_OW 263
123511: PUSH
123512: LD_INT 1
123514: EQUAL
123515: AND
123516: IFFALSE 123529
123518: PUSH
123519: LD_VAR 0 4
123523: PPUSH
123524: CALL_OW 311
123528: AND
123529: IFFALSE 123553
123531: PUSH
123532: LD_VAR 0 4
123536: PPUSH
123537: LD_EXP 55
123541: PUSH
123542: LD_VAR 0 1
123546: ARRAY
123547: PPUSH
123548: CALL_OW 308
123552: AND
123553: IFFALSE 123607
// begin mech := IsDrivenBy ( i ) ;
123555: LD_ADDR_VAR 0 9
123559: PUSH
123560: LD_VAR 0 4
123564: PPUSH
123565: CALL_OW 311
123569: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
123570: LD_VAR 0 9
123574: PPUSH
123575: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
123579: LD_VAR 0 9
123583: PPUSH
123584: LD_VAR 0 4
123588: PPUSH
123589: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
123593: LD_VAR 0 9
123597: PPUSH
123598: LD_VAR 0 4
123602: PPUSH
123603: CALL_OW 180
// end ; end ; unit_human :
123607: GO 123968
123609: LD_INT 1
123611: DOUBLE
123612: EQUAL
123613: IFTRUE 123617
123615: GO 123967
123617: POP
// begin b := IsInUnit ( i ) ;
123618: LD_ADDR_VAR 0 18
123622: PUSH
123623: LD_VAR 0 4
123627: PPUSH
123628: CALL_OW 310
123632: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
123633: LD_ADDR_VAR 0 19
123637: PUSH
123638: LD_VAR 0 18
123642: NOT
123643: IFTRUE 123667
123645: PUSH
123646: LD_VAR 0 18
123650: PPUSH
123651: CALL_OW 266
123655: PUSH
123656: LD_INT 32
123658: PUSH
123659: LD_INT 31
123661: PUSH
123662: EMPTY
123663: LIST
123664: LIST
123665: IN
123666: OR
123667: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
123668: LD_VAR 0 18
123672: PPUSH
123673: CALL_OW 266
123677: PUSH
123678: LD_INT 5
123680: EQUAL
123681: IFFALSE 123713
123683: PUSH
123684: LD_VAR 0 4
123688: PPUSH
123689: CALL_OW 257
123693: PUSH
123694: LD_INT 1
123696: PUSH
123697: LD_INT 2
123699: PUSH
123700: LD_INT 3
123702: PUSH
123703: LD_INT 4
123705: PUSH
123706: EMPTY
123707: LIST
123708: LIST
123709: LIST
123710: LIST
123711: IN
123712: AND
123713: IFFALSE 123750
// begin class := AllowSpecClass ( i ) ;
123715: LD_ADDR_VAR 0 20
123719: PUSH
123720: LD_VAR 0 4
123724: PPUSH
123725: CALL 21863 0 1
123729: ST_TO_ADDR
// if class then
123730: LD_VAR 0 20
123734: IFFALSE 123750
// ComChangeProfession ( i , class ) ;
123736: LD_VAR 0 4
123740: PPUSH
123741: LD_VAR 0 20
123745: PPUSH
123746: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
123750: LD_VAR 0 16
123754: IFTRUE 123781
123756: PUSH
123757: LD_VAR 0 2
123761: PPUSH
123762: LD_INT 21
123764: PUSH
123765: LD_INT 2
123767: PUSH
123768: EMPTY
123769: LIST
123770: LIST
123771: PPUSH
123772: CALL_OW 72
123776: PUSH
123777: LD_INT 1
123779: LESSEQUAL
123780: OR
123781: IFFALSE 123789
123783: PUSH
123784: LD_VAR 0 19
123788: AND
123789: IFFALSE 123804
123791: PUSH
123792: LD_VAR 0 4
123796: PUSH
123797: LD_VAR 0 17
123801: IN
123802: NOT
123803: AND
123804: IFFALSE 123899
// begin if b then
123806: LD_VAR 0 18
123810: IFFALSE 123861
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
123812: LD_VAR 0 18
123816: PPUSH
123817: LD_VAR 0 21
123821: PPUSH
123822: LD_VAR 0 18
123826: PPUSH
123827: CALL_OW 74
123831: PPUSH
123832: CALL_OW 296
123836: PUSH
123837: LD_INT 10
123839: LESS
123840: IFFALSE 123857
123842: PUSH
123843: LD_VAR 0 18
123847: PPUSH
123848: CALL_OW 461
123852: PUSH
123853: LD_INT 7
123855: NONEQUAL
123856: AND
123857: IFFALSE 123861
// continue ;
123859: GO 123062
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
123861: LD_ADDR_VAR 0 17
123865: PUSH
123866: LD_VAR 0 17
123870: PPUSH
123871: LD_VAR 0 17
123875: PUSH
123876: LD_INT 1
123878: PLUS
123879: PPUSH
123880: LD_VAR 0 4
123884: PPUSH
123885: CALL_OW 1
123889: ST_TO_ADDR
// ComExitBuilding ( i ) ;
123890: LD_VAR 0 4
123894: PPUSH
123895: CALL_OW 122
// end ; if sold_defenders then
123899: LD_VAR 0 17
123903: IFFALSE 123965
// if i in sold_defenders then
123905: LD_VAR 0 4
123909: PUSH
123910: LD_VAR 0 17
123914: IN
123915: IFFALSE 123965
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
123917: LD_VAR 0 4
123921: PPUSH
123922: CALL_OW 314
123926: NOT
123927: IFFALSE 123949
123929: PUSH
123930: LD_VAR 0 4
123934: PPUSH
123935: LD_VAR 0 13
123939: PPUSH
123940: CALL_OW 296
123944: PUSH
123945: LD_INT 30
123947: LESS
123948: AND
123949: IFFALSE 123965
// ComAttackUnit ( i , e ) ;
123951: LD_VAR 0 4
123955: PPUSH
123956: LD_VAR 0 13
123960: PPUSH
123961: CALL_OW 115
// end ; end ; end ;
123965: GO 123968
123967: POP
// if IsDead ( i ) then
123968: LD_VAR 0 4
123972: PPUSH
123973: CALL_OW 301
123977: IFFALSE 123995
// defenders := defenders diff i ;
123979: LD_ADDR_VAR 0 2
123983: PUSH
123984: LD_VAR 0 2
123988: PUSH
123989: LD_VAR 0 4
123993: DIFF
123994: ST_TO_ADDR
// end ;
123995: GO 123062
123997: POP
123998: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
123999: LD_VAR 0 21
124003: NOT
124004: IFTRUE 124013
124006: PUSH
124007: LD_VAR 0 2
124011: NOT
124012: OR
124013: IFTRUE 124028
124015: PUSH
124016: LD_EXP 31
124020: PUSH
124021: LD_VAR 0 1
124025: ARRAY
124026: NOT
124027: OR
124028: IFFALSE 122964
// MC_Reset ( base , 18 ) ;
124030: LD_VAR 0 1
124034: PPUSH
124035: LD_INT 18
124037: PPUSH
124038: CALL 67678 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124042: LD_ADDR_VAR 0 2
124046: PUSH
124047: LD_VAR 0 2
124051: PUSH
124052: LD_VAR 0 2
124056: PPUSH
124057: LD_INT 2
124059: PUSH
124060: LD_INT 25
124062: PUSH
124063: LD_INT 1
124065: PUSH
124066: EMPTY
124067: LIST
124068: LIST
124069: PUSH
124070: LD_INT 25
124072: PUSH
124073: LD_INT 5
124075: PUSH
124076: EMPTY
124077: LIST
124078: LIST
124079: PUSH
124080: LD_INT 25
124082: PUSH
124083: LD_INT 8
124085: PUSH
124086: EMPTY
124087: LIST
124088: LIST
124089: PUSH
124090: LD_INT 25
124092: PUSH
124093: LD_INT 9
124095: PUSH
124096: EMPTY
124097: LIST
124098: LIST
124099: PUSH
124100: EMPTY
124101: LIST
124102: LIST
124103: LIST
124104: LIST
124105: LIST
124106: PPUSH
124107: CALL_OW 72
124111: DIFF
124112: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
124113: LD_VAR 0 21
124117: NOT
124118: IFFALSE 124141
124120: PUSH
124121: LD_VAR 0 2
124125: PPUSH
124126: LD_INT 21
124128: PUSH
124129: LD_INT 2
124131: PUSH
124132: EMPTY
124133: LIST
124134: LIST
124135: PPUSH
124136: CALL_OW 72
124140: AND
124141: IFFALSE 124485
// begin tmp := FilterByTag ( defenders , 19 ) ;
124143: LD_ADDR_VAR 0 11
124147: PUSH
124148: LD_VAR 0 2
124152: PPUSH
124153: LD_INT 19
124155: PPUSH
124156: CALL 55700 0 2
124160: ST_TO_ADDR
// if tmp then
124161: LD_VAR 0 11
124165: IFFALSE 124235
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
124167: LD_ADDR_VAR 0 11
124171: PUSH
124172: LD_VAR 0 11
124176: PPUSH
124177: LD_INT 25
124179: PUSH
124180: LD_INT 3
124182: PUSH
124183: EMPTY
124184: LIST
124185: LIST
124186: PPUSH
124187: CALL_OW 72
124191: ST_TO_ADDR
// if tmp then
124192: LD_VAR 0 11
124196: IFFALSE 124235
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
124198: LD_ADDR_EXP 43
124202: PUSH
124203: LD_EXP 43
124207: PPUSH
124208: LD_VAR 0 1
124212: PPUSH
124213: LD_EXP 43
124217: PUSH
124218: LD_VAR 0 1
124222: ARRAY
124223: PUSH
124224: LD_VAR 0 11
124228: UNION
124229: PPUSH
124230: CALL_OW 1
124234: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
124235: LD_VAR 0 1
124239: PPUSH
124240: LD_INT 19
124242: PPUSH
124243: CALL 67678 0 2
// repeat wait ( 0 0$1 ) ;
124247: LD_INT 35
124249: PPUSH
124250: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124254: LD_EXP 31
124258: PUSH
124259: LD_VAR 0 1
124263: ARRAY
124264: NOT
124265: IFTRUE 124282
124267: PUSH
124268: LD_EXP 31
124272: PUSH
124273: LD_VAR 0 1
124277: ARRAY
124278: PUSH
124279: EMPTY
124280: EQUAL
124281: OR
124282: IFFALSE 124319
// begin for i in defenders do
124284: LD_ADDR_VAR 0 4
124288: PUSH
124289: LD_VAR 0 2
124293: PUSH
124294: FOR_IN
124295: IFFALSE 124308
// ComStop ( i ) ;
124297: LD_VAR 0 4
124301: PPUSH
124302: CALL_OW 141
124306: GO 124294
124308: POP
124309: POP
// defenders := [ ] ;
124310: LD_ADDR_VAR 0 2
124314: PUSH
124315: EMPTY
124316: ST_TO_ADDR
// exit ;
124317: GO 124549
// end ; for i in defenders do
124319: LD_ADDR_VAR 0 4
124323: PUSH
124324: LD_VAR 0 2
124328: PUSH
124329: FOR_IN
124330: IFFALSE 124419
// begin if not IsInArea ( i , mc_parking [ base ] ) then
124332: LD_VAR 0 4
124336: PPUSH
124337: LD_EXP 55
124341: PUSH
124342: LD_VAR 0 1
124346: ARRAY
124347: PPUSH
124348: CALL_OW 308
124352: NOT
124353: IFFALSE 124377
// ComMoveToArea ( i , mc_parking [ base ] ) else
124355: LD_VAR 0 4
124359: PPUSH
124360: LD_EXP 55
124364: PUSH
124365: LD_VAR 0 1
124369: ARRAY
124370: PPUSH
124371: CALL_OW 113
124375: GO 124417
// if GetControl ( i ) = control_manual then
124377: LD_VAR 0 4
124381: PPUSH
124382: CALL_OW 263
124386: PUSH
124387: LD_INT 1
124389: EQUAL
124390: IFFALSE 124417
// if IsDrivenBy ( i ) then
124392: LD_VAR 0 4
124396: PPUSH
124397: CALL_OW 311
124401: IFFALSE 124417
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
124403: LD_VAR 0 4
124407: PPUSH
124408: CALL_OW 311
124412: PPUSH
124413: CALL_OW 121
// end ;
124417: GO 124329
124419: POP
124420: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
124421: LD_VAR 0 2
124425: PPUSH
124426: LD_INT 95
124428: PUSH
124429: LD_EXP 55
124433: PUSH
124434: LD_VAR 0 1
124438: ARRAY
124439: PUSH
124440: EMPTY
124441: LIST
124442: LIST
124443: PPUSH
124444: CALL_OW 72
124448: PUSH
124449: LD_VAR 0 2
124453: EQUAL
124454: IFTRUE 124468
124456: PUSH
124457: LD_EXP 54
124461: PUSH
124462: LD_VAR 0 1
124466: ARRAY
124467: OR
124468: IFTRUE 124483
124470: PUSH
124471: LD_EXP 31
124475: PUSH
124476: LD_VAR 0 1
124480: ARRAY
124481: NOT
124482: OR
124483: IFFALSE 124247
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
124485: LD_ADDR_EXP 53
124489: PUSH
124490: LD_EXP 53
124494: PPUSH
124495: LD_VAR 0 1
124499: PPUSH
124500: LD_VAR 0 2
124504: PPUSH
124505: LD_INT 21
124507: PUSH
124508: LD_INT 2
124510: PUSH
124511: EMPTY
124512: LIST
124513: LIST
124514: PPUSH
124515: CALL_OW 72
124519: PPUSH
124520: CALL_OW 1
124524: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
124525: LD_VAR 0 1
124529: PPUSH
124530: LD_INT 19
124532: PPUSH
124533: CALL 67678 0 2
// MC_Reset ( base , 20 ) ;
124537: LD_VAR 0 1
124541: PPUSH
124542: LD_INT 20
124544: PPUSH
124545: CALL 67678 0 2
// end ; end_of_file
124549: LD_VAR 0 3
124553: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
124554: LD_VAR 0 1
124558: PUSH
124559: LD_INT 200
124561: DOUBLE
124562: GREATEREQUAL
124563: IFFALSE 124571
124565: LD_INT 299
124567: DOUBLE
124568: LESSEQUAL
124569: IFTRUE 124573
124571: GO 124605
124573: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
124574: LD_VAR 0 1
124578: PPUSH
124579: LD_VAR 0 2
124583: PPUSH
124584: LD_VAR 0 3
124588: PPUSH
124589: LD_VAR 0 4
124593: PPUSH
124594: LD_VAR 0 5
124598: PPUSH
124599: CALL 111407 0 5
124603: GO 124682
124605: LD_INT 300
124607: DOUBLE
124608: GREATEREQUAL
124609: IFFALSE 124617
124611: LD_INT 399
124613: DOUBLE
124614: LESSEQUAL
124615: IFTRUE 124619
124617: GO 124681
124619: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
124620: LD_VAR 0 1
124624: PPUSH
124625: LD_VAR 0 2
124629: PPUSH
124630: LD_VAR 0 3
124634: PPUSH
124635: LD_VAR 0 4
124639: PPUSH
124640: LD_VAR 0 5
124644: PPUSH
124645: LD_VAR 0 6
124649: PPUSH
124650: LD_VAR 0 7
124654: PPUSH
124655: LD_VAR 0 8
124659: PPUSH
124660: LD_VAR 0 9
124664: PPUSH
124665: LD_VAR 0 10
124669: PPUSH
124670: LD_VAR 0 11
124674: PPUSH
124675: CALL 107210 0 11
124679: GO 124682
124681: POP
// end ;
124682: PPOPN 11
124684: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
124685: LD_VAR 0 1
124689: PPUSH
124690: LD_VAR 0 2
124694: PPUSH
124695: LD_VAR 0 3
124699: PPUSH
124700: LD_VAR 0 4
124704: PPUSH
124705: LD_VAR 0 5
124709: PPUSH
124710: CALL 110707 0 5
// end ; end_of_file
124714: PPOPN 5
124716: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
124717: LD_VAR 0 1
124721: PPUSH
124722: LD_VAR 0 2
124726: PPUSH
124727: LD_VAR 0 3
124731: PPUSH
124732: LD_VAR 0 4
124736: PPUSH
124737: LD_VAR 0 5
124741: PPUSH
124742: LD_VAR 0 6
124746: PPUSH
124747: CALL 94750 0 6
// end ;
124751: PPOPN 6
124753: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
124754: LD_INT 0
124756: PPUSH
// begin if not units then
124757: LD_VAR 0 1
124761: NOT
124762: IFFALSE 124766
// exit ;
124764: GO 124800
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
124766: LD_VAR 0 1
124770: PPUSH
124771: LD_VAR 0 2
124775: PPUSH
124776: LD_VAR 0 3
124780: PPUSH
124781: LD_VAR 0 4
124785: PPUSH
124786: LD_VAR 0 5
124790: PPUSH
124791: LD_VAR 0 6
124795: PPUSH
124796: CALL 117104 0 6
// end ;
124800: PPOPN 7
124802: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
124803: CALL 94630 0 0
// end ;
124807: PPOPN 1
124809: END
